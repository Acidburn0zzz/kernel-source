From: Jiri Slaby <jslaby@suse.cz>
Date: Tue, 2 Jul 2019 12:37:21 +0200
Subject: Revert "ovl: detect overlapping layers"
Patch-mainline: never, suse specific
References: openqa tests failing

This reverts commit 99eb836cd9a4df455ae90807bc00ee635be342f0, upstream
commit 146d62e5a5867fbf84490d82455718bfb10fe824. It breaks openqa tests.
So for now we revert these strict checks, but we will get them back with
5.2.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 fs/overlayfs/inode.c     |   48 -------------
 fs/overlayfs/namei.c     |    8 --
 fs/overlayfs/overlayfs.h |    3 
 fs/overlayfs/ovl_entry.h |    6 -
 fs/overlayfs/super.c     |  169 ++++-------------------------------------------
 fs/overlayfs/util.c      |   12 ---
 6 files changed, 17 insertions(+), 229 deletions(-)

--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@ -777,54 +777,6 @@ struct inode *ovl_lookup_inode(struct su
 	return inode;
 }
 
-bool ovl_lookup_trap_inode(struct super_block *sb, struct dentry *dir)
-{
-	struct inode *key = d_inode(dir);
-	struct inode *trap;
-	bool res;
-
-	trap = ilookup5(sb, (unsigned long) key, ovl_inode_test, key);
-	if (!trap)
-		return false;
-
-	res = IS_DEADDIR(trap) && !ovl_inode_upper(trap) &&
-				  !ovl_inode_lower(trap);
-
-	iput(trap);
-	return res;
-}
-
-/*
- * Create an inode cache entry for layer root dir, that will intentionally
- * fail ovl_verify_inode(), so any lookup that will find some layer root
- * will fail.
- */
-struct inode *ovl_get_trap_inode(struct super_block *sb, struct dentry *dir)
-{
-	struct inode *key = d_inode(dir);
-	struct inode *trap;
-
-	if (!d_is_dir(dir))
-		return ERR_PTR(-ENOTDIR);
-
-	trap = iget5_locked(sb, (unsigned long) key, ovl_inode_test,
-			    ovl_inode_set, key);
-	if (!trap)
-		return ERR_PTR(-ENOMEM);
-
-	if (!(trap->i_state & I_NEW)) {
-		/* Conflicting layer roots? */
-		iput(trap);
-		return ERR_PTR(-ELOOP);
-	}
-
-	trap->i_mode = S_IFDIR;
-	trap->i_flags = S_DEAD;
-	unlock_new_inode(trap);
-
-	return trap;
-}
-
 /*
  * Does overlay inode need to be hashed by lower inode?
  */
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@ -18,7 +18,6 @@
 #include "overlayfs.h"
 
 struct ovl_lookup_data {
-	struct super_block *sb;
 	struct qstr name;
 	bool is_dir;
 	bool opaque;
@@ -245,12 +244,6 @@ static int ovl_lookup_single(struct dent
 		if (!d->metacopy || d->last)
 			goto out;
 	} else {
-		if (ovl_lookup_trap_inode(d->sb, this)) {
-			/* Caught in a trap of overlapping layers */
-			err = -ELOOP;
-			goto out_err;
-		}
-
 		if (last_element)
 			d->is_dir = true;
 		if (d->last)
@@ -826,7 +819,6 @@ struct dentry *ovl_lookup(struct inode *
 	int err;
 	bool metacopy = false;
 	struct ovl_lookup_data d = {
-		.sb = dentry->d_sb,
 		.name = dentry->d_name,
 		.is_dir = false,
 		.opaque = false,
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -270,7 +270,6 @@ void ovl_clear_flag(unsigned long flag,
 bool ovl_test_flag(unsigned long flag, struct inode *inode);
 bool ovl_inuse_trylock(struct dentry *dentry);
 void ovl_inuse_unlock(struct dentry *dentry);
-bool ovl_is_inuse(struct dentry *dentry);
 bool ovl_need_index(struct dentry *dentry);
 int ovl_nlink_start(struct dentry *dentry);
 void ovl_nlink_end(struct dentry *dentry);
@@ -377,8 +376,6 @@ struct ovl_inode_params {
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,
 			       bool is_upper);
-bool ovl_lookup_trap_inode(struct super_block *sb, struct dentry *dir);
-struct inode *ovl_get_trap_inode(struct super_block *sb, struct dentry *dir);
 struct inode *ovl_get_inode(struct super_block *sb,
 			    struct ovl_inode_params *oip);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -29,8 +29,6 @@ struct ovl_sb {
 
 struct ovl_layer {
 	struct vfsmount *mnt;
-	/* Trap in ovl inode cache */
-	struct inode *trap;
 	struct ovl_sb *fs;
 	/* Index of this layer in fs root (upper idx == 0) */
 	int idx;
@@ -67,10 +65,6 @@ struct ovl_fs {
 	/* Did we take the inuse lock? */
 	bool upperdir_locked;
 	bool workdir_locked;
-	/* Traps in ovl inode cache */
-	struct inode *upperdir_trap;
-	struct inode *workdir_trap;
-	struct inode *indexdir_trap;
 	/* Inode numbers in all layers do not use the high xino_bits */
 	unsigned int xino_bits;
 };
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -217,9 +217,6 @@ static void ovl_free_fs(struct ovl_fs *o
 {
 	unsigned i;
 
-	iput(ofs->indexdir_trap);
-	iput(ofs->workdir_trap);
-	iput(ofs->upperdir_trap);
 	dput(ofs->indexdir);
 	dput(ofs->workdir);
 	if (ofs->workdir_locked)
@@ -228,10 +225,8 @@ static void ovl_free_fs(struct ovl_fs *o
 	if (ofs->upperdir_locked)
 		ovl_inuse_unlock(ofs->upper_mnt->mnt_root);
 	mntput(ofs->upper_mnt);
-	for (i = 0; i < ofs->numlower; i++) {
-		iput(ofs->lower_layers[i].trap);
+	for (i = 0; i < ofs->numlower; i++)
 		mntput(ofs->lower_layers[i].mnt);
-	}
 	for (i = 0; i < ofs->numlowerfs; i++)
 		free_anon_bdev(ofs->lower_fs[i].pseudo_dev);
 	kfree(ofs->lower_layers);
@@ -989,26 +984,7 @@ static const struct xattr_handler *ovl_x
 	NULL
 };
 
-static int ovl_setup_trap(struct super_block *sb, struct dentry *dir,
-			  struct inode **ptrap, const char *name)
-{
-	struct inode *trap;
-	int err;
-
-	trap = ovl_get_trap_inode(sb, dir);
-	err = PTR_ERR(trap);
-	if (IS_ERR(trap)) {
-		if (err == -ELOOP)
-			pr_err("overlayfs: conflicting %s path\n", name);
-		return err;
-	}
-
-	*ptrap = trap;
-	return 0;
-}
-
-static int ovl_get_upper(struct super_block *sb, struct ovl_fs *ofs,
-			 struct path *upperpath)
+static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
 {
 	struct vfsmount *upper_mnt;
 	int err;
@@ -1028,11 +1004,6 @@ static int ovl_get_upper(struct super_bl
 	if (err)
 		goto out;
 
-	err = ovl_setup_trap(sb, upperpath->dentry, &ofs->upperdir_trap,
-			     "upperdir");
-	if (err)
-		goto out;
-
 	upper_mnt = clone_private_mount(upperpath);
 	err = PTR_ERR(upper_mnt);
 	if (IS_ERR(upper_mnt)) {
@@ -1059,8 +1030,7 @@ out:
 	return err;
 }
 
-static int ovl_make_workdir(struct super_block *sb, struct ovl_fs *ofs,
-			    struct path *workpath)
+static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
 {
 	struct vfsmount *mnt = ofs->upper_mnt;
 	struct dentry *temp;
@@ -1075,10 +1045,6 @@ static int ovl_make_workdir(struct super
 	if (!ofs->workdir)
 		goto out;
 
-	err = ovl_setup_trap(sb, ofs->workdir, &ofs->workdir_trap, "workdir");
-	if (err)
-		goto out;
-
 	/*
 	 * Upper should support d_type, else whiteouts are visible.  Given
 	 * workdir and upper are on same fs, we can do iterate_dir() on
@@ -1139,8 +1105,7 @@ out:
 	return err;
 }
 
-static int ovl_get_workdir(struct super_block *sb, struct ovl_fs *ofs,
-			   struct path *upperpath)
+static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
 {
 	int err;
 	struct path workpath = { };
@@ -1171,16 +1136,19 @@ static int ovl_get_workdir(struct super_
 		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 	}
 
-	err = ovl_make_workdir(sb, ofs, &workpath);
+	err = ovl_make_workdir(ofs, &workpath);
+	if (err)
+		goto out;
 
+	err = 0;
 out:
 	path_put(&workpath);
 
 	return err;
 }
 
-static int ovl_get_indexdir(struct super_block *sb, struct ovl_fs *ofs,
-			    struct ovl_entry *oe, struct path *upperpath)
+static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
+			    struct path *upperpath)
 {
 	struct vfsmount *mnt = ofs->upper_mnt;
 	int err;
@@ -1199,11 +1167,6 @@ static int ovl_get_indexdir(struct super
 
 	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
 	if (ofs->indexdir) {
-		err = ovl_setup_trap(sb, ofs->indexdir, &ofs->indexdir_trap,
-				     "indexdir");
-		if (err)
-			goto out;
-
 		/*
 		 * Verify upper root is exclusively associated with index dir.
 		 * Older kernels stored upper fh in "trusted.overlay.origin"
@@ -1291,8 +1254,8 @@ static int ovl_get_fsid(struct ovl_fs *o
 	return ofs->numlowerfs;
 }
 
-static int ovl_get_lower_layers(struct super_block *sb, struct ovl_fs *ofs,
-				struct path *stack, unsigned int numlower)
+static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
+				unsigned int numlower)
 {
 	int err;
 	unsigned int i;
@@ -1310,28 +1273,16 @@ static int ovl_get_lower_layers(struct s
 
 	for (i = 0; i < numlower; i++) {
 		struct vfsmount *mnt;
-		struct inode *trap;
 		int fsid;
 
 		err = fsid = ovl_get_fsid(ofs, &stack[i]);
 		if (err < 0)
 			goto out;
 
-		err = -EBUSY;
-		if (ovl_is_inuse(stack[i].dentry)) {
-			pr_err("overlayfs: lowerdir is in-use as upperdir/workdir\n");
-			goto out;
-		}
-
-		err = ovl_setup_trap(sb, stack[i].dentry, &trap, "lowerdir");
-		if (err)
-			goto out;
-
 		mnt = clone_private_mount(&stack[i]);
 		err = PTR_ERR(mnt);
 		if (IS_ERR(mnt)) {
 			pr_err("overlayfs: failed to clone lowerpath\n");
-			iput(trap);
 			goto out;
 		}
 
@@ -1341,7 +1292,6 @@ static int ovl_get_lower_layers(struct s
 		 */
 		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
 
-		ofs->lower_layers[ofs->numlower].trap = trap;
 		ofs->lower_layers[ofs->numlower].mnt = mnt;
 		ofs->lower_layers[ofs->numlower].idx = i + 1;
 		ofs->lower_layers[ofs->numlower].fsid = fsid;
@@ -1436,7 +1386,7 @@ static struct ovl_entry *ovl_get_lowerst
 		goto out_err;
 	}
 
-	err = ovl_get_lower_layers(sb, ofs, stack, numlower);
+	err = ovl_get_lower_layers(ofs, stack, numlower);
 	if (err)
 		goto out_err;
 
@@ -1468,85 +1418,6 @@ out_err:
 	goto out;
 }
 
-/*
- * Check if this layer root is a descendant of:
- * - another layer of this overlayfs instance
- * - upper/work dir of any overlayfs instance
- * - a disconnected dentry (detached root)
- */
-static int ovl_check_layer(struct super_block *sb, struct dentry *dentry,
-			   const char *name)
-{
-	struct dentry *next, *parent;
-	bool is_root = false;
-	int err = 0;
-
-	if (!dentry || dentry == dentry->d_sb->s_root)
-		return 0;
-
-	next = dget(dentry);
-	/* Walk back ancestors to fs root (inclusive) looking for traps */
-	do {
-		parent = dget_parent(next);
-		is_root = (parent == next);
-		if (ovl_is_inuse(parent)) {
-			err = -EBUSY;
-			pr_err("overlayfs: %s path overlapping in-use upperdir/workdir\n",
-			       name);
-		} else if (ovl_lookup_trap_inode(sb, parent)) {
-			err = -ELOOP;
-			pr_err("overlayfs: overlapping %s path\n", name);
-		}
-		dput(next);
-		next = parent;
-	} while (!err && !is_root);
-
-	/* Did we really walk to fs root or found a detached root? */
-	if (!err && next != dentry->d_sb->s_root) {
-		err = -ESTALE;
-		pr_err("overlayfs: disconnected %s path\n", name);
-	}
-
-	dput(next);
-
-	return err;
-}
-
-/*
- * Check if any of the layers or work dirs overlap.
- */
-static int ovl_check_overlapping_layers(struct super_block *sb,
-					struct ovl_fs *ofs)
-{
-	int i, err;
-
-	if (ofs->upper_mnt) {
-		err = ovl_check_layer(sb, ofs->upper_mnt->mnt_root, "upperdir");
-		if (err)
-			return err;
-
-		/*
-		 * Checking workbasedir avoids hitting ovl_is_inuse(parent) of
-		 * this instance and covers overlapping work and index dirs,
-		 * unless work or index dir have been moved since created inside
-		 * workbasedir.  In that case, we already have their traps in
-		 * inode cache and we will catch that case on lookup.
-		 */
-		err = ovl_check_layer(sb, ofs->workbasedir, "workdir");
-		if (err)
-			return err;
-	}
-
-	for (i = 0; i < ofs->numlower; i++) {
-		err = ovl_check_layer(sb, ofs->lower_layers[i].mnt->mnt_root,
-				      "lowerdir");
-		if (err)
-			return err;
-	}
-
-	return 0;
-}
-
 static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 {
 	struct path upperpath = { };
@@ -1586,20 +1457,17 @@ static int ovl_fill_super(struct super_b
 	if (ofs->config.xino != OVL_XINO_OFF)
 		ofs->xino_bits = BITS_PER_LONG - 32;
 
-	/* alloc/destroy_inode needed for setting up traps in inode cache */
-	sb->s_op = &ovl_super_operations;
-
 	if (ofs->config.upperdir) {
 		if (!ofs->config.workdir) {
 			pr_err("overlayfs: missing 'workdir'\n");
 			goto out_err;
 		}
 
-		err = ovl_get_upper(sb, ofs, &upperpath);
+		err = ovl_get_upper(ofs, &upperpath);
 		if (err)
 			goto out_err;
 
-		err = ovl_get_workdir(sb, ofs, &upperpath);
+		err = ovl_get_workdir(ofs, &upperpath);
 		if (err)
 			goto out_err;
 
@@ -1620,7 +1488,7 @@ static int ovl_fill_super(struct super_b
 		sb->s_flags |= SB_RDONLY;
 
 	if (!(ovl_force_readonly(ofs)) && ofs->config.index) {
-		err = ovl_get_indexdir(sb, ofs, oe, &upperpath);
+		err = ovl_get_indexdir(ofs, oe, &upperpath);
 		if (err)
 			goto out_free_oe;
 
@@ -1633,10 +1501,6 @@ static int ovl_fill_super(struct super_b
 
 	}
 
-	err = ovl_check_overlapping_layers(sb, ofs);
-	if (err)
-		goto out_free_oe;
-
 	/* Show index=off in /proc/mounts for forced r/o mount */
 	if (!ofs->indexdir) {
 		ofs->config.index = false;
@@ -1658,6 +1522,7 @@ static int ovl_fill_super(struct super_b
 	cap_lower(cred->cap_effective, CAP_SYS_RESOURCE);
 
 	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
+	sb->s_op = &ovl_super_operations;
 	sb->s_xattr = ovl_xattr_handlers;
 	sb->s_fs_info = ofs;
 	sb->s_flags |= SB_POSIXACL;
--- a/fs/overlayfs/util.c
+++ b/fs/overlayfs/util.c
@@ -652,18 +652,6 @@ void ovl_inuse_unlock(struct dentry *den
 	}
 }
 
-bool ovl_is_inuse(struct dentry *dentry)
-{
-	struct inode *inode = d_inode(dentry);
-	bool inuse;
-
-	spin_lock(&inode->i_lock);
-	inuse = (inode->i_state & I_OVL_INUSE);
-	spin_unlock(&inode->i_lock);
-
-	return inuse;
-}
-
 /*
  * Does this overlay dentry need to be indexed on copy up?
  */
