From: Andreas Gruenbacher <agruen@suse.de>
Subject: Fix ACL umask handling over nfs
Suse-bugzilla: 48477

NFSv3 has no concept of a umask on the server side: The client applies
the umask locally, and sends the effective permissions to the server.
This behavior is wrong when files are created in a directory that has
a default ACL. In this case, the umask is supposed to be ignored, and
only the default ACL determines the file's effective permissions.

Usually its the server's task to conditionally apply the umask. But
since the server knows nothing about the umask, we have to do it on the
client side. This patch tries to fetch the parent directory's default
ACL before creating a new file, computes the appropriate create mode to
send to the server, and finally sets the new file's access and default
acl appropriately.

The patch splits nfs3_proc_setacls off nfs3_proc_setacl. When creating
files we now know exactly which permissions the new file will get, so we
use nfs3_proc_setacl. Compared to using nfs3_proc_setacl, this avoids
one unnecessare trip-around when creating directories.

Many thanks to Buck Huppmann <buchk@pobox.com> for sending the initial
version of this patch, as well as for arguing why we need this change.

Index: linux-2.6.5/fs/nfs/dir.c
===================================================================
--- linux-2.6.5.orig/fs/nfs/dir.c
+++ linux-2.6.5/fs/nfs/dir.c
@@ -31,6 +31,7 @@
 #include <linux/pagemap.h>
 #include <linux/smp_lock.h>
 #include <linux/namei.h>
+#include <linux/posix_acl.h>
 
 #define NFS_PARANOIA 1
 /* #define NFS_DEBUG_VERBOSE 1 */
@@ -1014,6 +1015,7 @@ out_err:
 static int nfs_create(struct inode *dir, struct dentry *dentry, int mode,
 		struct nameidata *nd)
 {
+	struct posix_acl *acl = NULL;
 	struct iattr attr;
 	struct inode *inode;
 	int error;
@@ -1022,7 +1024,7 @@ static int nfs_create(struct inode *dir,
 	dfprintk(VFS, "NFS: create(%s/%ld, %s\n", dir->i_sb->s_id, 
 		dir->i_ino, dentry->d_name.name);
 
-	attr.ia_mode = mode;
+	attr.ia_mode = mode & ~current->fs->umask;
 	attr.ia_valid = ATTR_MODE;
 
 	if (nd && (nd->flags & LOOKUP_CREATE))
@@ -1035,18 +1037,41 @@ static int nfs_create(struct inode *dir,
 	 * does not pass the create flags.
 	 */
 	lock_kernel();
+#ifdef CONFIG_NFS_ACL
+	acl = NFS_PROTO(dir)->getacl(dir, ACL_TYPE_DEFAULT);
+	if (IS_ERR(acl)) {
+		error = PTR_ERR(acl);
+		acl = NULL;
+		if (error != -EOPNOTSUPP)
+			goto out;
+	}
+	if (acl) {
+		mode_t xmode = mode;
+
+		error = posix_acl_create_masq(acl, &xmode);
+		if (error >= 0) 
+			attr.ia_mode = xmode;
+	}
+#endif
 	nfs_begin_data_update(dir);
 	inode = NFS_PROTO(dir)->create(dir, &dentry->d_name, &attr, open_flags);
 	nfs_end_data_update(dir);
-	if (!IS_ERR(inode)) {
-		d_instantiate(dentry, inode);
-		nfs_renew_times(dentry);
-		nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
-		error = 0;
-	} else {
+	if (IS_ERR(inode)) {
 		error = PTR_ERR(inode);
 		d_drop(dentry);
+		goto out;
 	}
+	d_instantiate(dentry, inode);
+	nfs_renew_times(dentry);
+	nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
+	error = 0;
+#ifdef CONFIG_NFS_ACL
+	if (acl)
+		error = NFS_PROTO(dir)->setacls(inode, acl, NULL);
+#endif
+
+out:
+	posix_acl_release(acl);
 	unlock_kernel();
 	return error;
 }
@@ -1057,6 +1082,7 @@ static int nfs_create(struct inode *dir,
 static int
 nfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t rdev)
 {
+	struct posix_acl *acl = NULL;
 	struct iattr attr;
 	struct nfs_fattr fattr;
 	struct nfs_fh fhandle;
@@ -1068,18 +1094,45 @@ nfs_mknod(struct inode *dir, struct dent
 	if (!new_valid_dev(rdev))
 		return -EINVAL;
 
-	attr.ia_mode = mode;
+	attr.ia_mode = mode & ~current->fs->umask;
 	attr.ia_valid = ATTR_MODE;
 
 	lock_kernel();
+#ifdef CONFIG_NFS_ACL
+	acl = NFS_PROTO(dir)->getacl(dir, ACL_TYPE_DEFAULT);
+	if (IS_ERR(acl)) {
+		error = PTR_ERR(acl);
+		acl = NULL;
+		if (error != -EOPNOTSUPP)
+			goto out;
+	}
+	if (acl) {
+		mode_t xmode = mode;
+
+		error = posix_acl_create_masq(acl, &xmode);
+		if (error >= 0)
+			attr.ia_mode = xmode;
+	}
+#endif
+
 	nfs_begin_data_update(dir);
 	error = NFS_PROTO(dir)->mknod(dir, &dentry->d_name, &attr, rdev,
 					&fhandle, &fattr);
 	nfs_end_data_update(dir);
-	if (!error)
-		error = nfs_instantiate(dentry, &fhandle, &fattr);
-	else
+	if (error) {
 		d_drop(dentry);
+		goto out;
+	}
+	error = nfs_instantiate(dentry, &fhandle, &fattr);
+	if (error)
+		goto out;
+#ifdef CONFIG_NFS_ACL
+	if (acl)
+		error = NFS_PROTO(dir)->setacls(dentry->d_inode, acl, NULL);
+#endif
+
+out:
+	posix_acl_release(acl);
 	unlock_kernel();
 	return error;
 }
@@ -1089,6 +1142,7 @@ nfs_mknod(struct inode *dir, struct dent
  */
 static int nfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
+	struct posix_acl *dfacl = NULL, *acl = NULL;
 	struct iattr attr;
 	struct nfs_fattr fattr;
 	struct nfs_fh fhandle;
@@ -1098,7 +1152,7 @@ static int nfs_mkdir(struct inode *dir, 
 		dir->i_ino, dentry->d_name.name);
 
 	attr.ia_valid = ATTR_MODE;
-	attr.ia_mode = mode | S_IFDIR;
+	attr.ia_mode = (mode & ~current->fs->umask) | S_IFDIR;
 
 	lock_kernel();
 #if 0
@@ -1110,14 +1164,46 @@ static int nfs_mkdir(struct inode *dir, 
 	 */
 	d_drop(dentry);
 #endif
+#ifdef CONFIG_NFS_ACL
+	dfacl = NFS_PROTO(dir)->getacl(dir, ACL_TYPE_DEFAULT);
+	if (IS_ERR(dfacl)) {
+		error = PTR_ERR(dfacl);
+		dfacl = NULL;
+		if (error != -EOPNOTSUPP)
+			goto out;
+	}
+	if (dfacl) {
+		mode_t xmode = mode;
+
+		acl = posix_acl_clone(dfacl, GFP_KERNEL);
+		error = -ENOMEM;
+		if (acl == NULL)
+			goto out;
+
+		error = posix_acl_create_masq(acl, &xmode);
+		if (error >= 0)
+			attr.ia_mode = xmode | S_IFDIR;
+	}
+#endif
 	nfs_begin_data_update(dir);
 	error = NFS_PROTO(dir)->mkdir(dir, &dentry->d_name, &attr, &fhandle,
 					&fattr);
 	nfs_end_data_update(dir);
-	if (!error)
-		error = nfs_instantiate(dentry, &fhandle, &fattr);
-	else
+	if (error) {
 		d_drop(dentry);
+		goto out;
+	}
+	error = nfs_instantiate(dentry, &fhandle, &fattr);
+	if (error)
+		goto out;
+#ifdef CONFIG_NFS_ACL
+	if (acl)
+		error = NFS_PROTO(dir)->setacls(dentry->d_inode, acl, dfacl);
+#endif
+
+out:
+	posix_acl_release(acl);
+	posix_acl_release(dfacl);
 	unlock_kernel();
 	return error;
 }
Index: linux-2.6.5/fs/nfs/inode.c
===================================================================
--- linux-2.6.5.orig/fs/nfs/inode.c
+++ linux-2.6.5/fs/nfs/inode.c
@@ -1446,6 +1446,8 @@ static struct super_block *nfs_get_sb(st
 		return ERR_PTR(error);
 	}
 	s->s_flags |= MS_ACTIVE;
+	/* The nfs client applies the umask itself when needed. */
+	s->s_flags |= MS_POSIXACL;
 	return s;
 }
 
Index: linux-2.6.5/include/linux/nfs_xdr.h
===================================================================
--- linux-2.6.5.orig/include/linux/nfs_xdr.h
+++ linux-2.6.5/include/linux/nfs_xdr.h
@@ -772,6 +772,7 @@ struct nfs_rpc_ops {
 #ifdef CONFIG_NFS_ACL
 	struct posix_acl * (*getacl)(struct inode *, int);
 	int	(*setacl)(struct inode *, int, struct posix_acl *);
+	int	(*setacls)(struct inode *, struct posix_acl *, struct posix_acl *);
 	int	(*checkacls)(struct inode *inode);
 #endif  /* CONFIG_NFS_ACL */
 };
Index: linux-2.6.5/fs/nfs/nfs3proc.c
===================================================================
--- linux-2.6.5.orig/fs/nfs/nfs3proc.c
+++ linux-2.6.5/fs/nfs/nfs3proc.c
@@ -864,7 +864,8 @@ getout:
 
 #ifdef CONFIG_NFS_ACL
 static int
-nfs3_proc_setacl(struct inode *inode, int type, struct posix_acl *acl)
+nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,
+		  struct posix_acl *dfacl)
 {
 	struct nfs_server *server = NFS_SERVER(inode);
 	struct nfs_fattr fattr;
@@ -881,53 +882,15 @@ nfs3_proc_setacl(struct inode *inode, in
 	   return -ENOMEM. */
 	if (acl && acl->a_count > NFS3_ACL_MAX_ENTRIES)
 		return -ENOSPC;
+	if (dfacl && dfacl->a_count > NFS3_ACL_MAX_ENTRIES)
+		return -ENOSPC;
 	args.inode = inode;
-	args.mask = NFS3_ACL|NFS3_DFACL;
+	args.mask = NFS3_ACL;
+	args.acl_access = acl;
 	if (S_ISDIR(inode->i_mode)) {
-		switch(type) {
-			case ACL_TYPE_ACCESS:
-				args.acl_access = acl;
-				args.acl_default = NFS_PROTO(inode)->getacl(
-					inode, ACL_TYPE_DEFAULT);
-				status = PTR_ERR(args.acl_default);
-				if (IS_ERR(args.acl_default)) {
-					args.acl_default = NULL;
-					goto cleanup;
-				}
-				break;
-
-			case ACL_TYPE_DEFAULT:
-				args.acl_access = NFS_PROTO(inode)->getacl(
-					inode, ACL_TYPE_ACCESS);
-				status = PTR_ERR(args.acl_access);
-				if (IS_ERR(args.acl_access)) {
-					args.acl_access = NULL;
-					goto cleanup;
-				}
-				args.acl_default = acl;
-				break;
-
-			default:
-				status = -EINVAL;
-				goto cleanup;
-		}
-	} else {
-		status = -EINVAL;
-		if (type != ACL_TYPE_ACCESS)
-			goto cleanup;
-		args.mask = NFS3_ACL;
-		args.acl_access = acl;
+		args.mask |= NFS3_DFACL;
+		args.acl_default = dfacl;
 	}
-	if (args.acl_access == NULL) {
-		args.acl_access = posix_acl_from_mode(inode->i_mode,
-						      GFP_KERNEL);
-		status = PTR_ERR(args.acl_access);
-		if (IS_ERR(args.acl_access)) {
-			args.acl_access = NULL;
-			goto cleanup;
-		}
-	}
-	args.mask = NFS3_ACL | (args.acl_default ? NFS3_DFACL : 0);
 
 	dprintk("NFS call setacl\n");
 	status = rpc_call(server->acl_client, NFS3PROC_SETACL,
@@ -954,11 +917,56 @@ nfs3_proc_setacl(struct inode *inode, in
 		status = nfs_refresh_inode(inode, &fattr);
 	}
 
+	return status;
+}
+
+static int
+nfs3_proc_setacl(struct inode *inode, int type, struct posix_acl *acl)
+{
+	struct posix_acl *dfacl = NULL;
+	int status;
+
+	if (S_ISDIR(inode->i_mode)) {
+		switch(type) {
+			case ACL_TYPE_ACCESS:
+				acl = posix_acl_dup(acl);
+				dfacl = NFS_PROTO(inode)->
+					getacl(inode, ACL_TYPE_DEFAULT);
+				if (IS_ERR(dfacl)) {
+					status = PTR_ERR(dfacl);
+					dfacl = NULL;
+					goto cleanup;
+				}
+				break;
+
+			case ACL_TYPE_DEFAULT:
+				dfacl = posix_acl_dup(acl);
+				acl = NFS_PROTO(inode)->
+					getacl(inode, ACL_TYPE_ACCESS);
+				if (IS_ERR(acl)) {
+					status = PTR_ERR(acl);
+					acl = NULL;
+					goto cleanup;
+				}
+				break;
+
+			default:
+				return -EINVAL;
+		}
+	} else if (type != ACL_TYPE_ACCESS)
+			return -EINVAL;
+
+	if (acl == NULL) {
+		acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
+		status = PTR_ERR(acl);
+		if (IS_ERR(acl))
+			goto cleanup;
+	}
+	status = nfs3_proc_setacls(inode, acl, dfacl);
+
 cleanup:
-	if (args.acl_access != acl)
-		posix_acl_release(args.acl_access);
-	if (args.acl_default != acl)
-		posix_acl_release(args.acl_default);
+	posix_acl_release(acl);
+	posix_acl_release(dfacl);
 	return status;
 }
 #endif  /* CONFIG_NFS_ACL */
@@ -1184,6 +1192,7 @@ struct nfs_rpc_ops	nfs_v3_clientops = {
 #ifdef CONFIG_NFS_ACL
 	.getacl		= nfs3_proc_getacl,
 	.setacl		= nfs3_proc_setacl,
+	.setacls	= nfs3_proc_setacls,
 	.checkacls	= nfs3_proc_checkacls,
 #endif  /* CONFIG_NFS_ACL */
 };
