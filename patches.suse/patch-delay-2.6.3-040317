diff -uNrp linux-2.6.4/fs/proc/array.c linux-2.6.4.delay/fs/proc/array.c
--- linux-2.6.4/fs/proc/array.c	2004-03-11 03:55:33.000000000 +0100
+++ linux-2.6.4.delay/fs/proc/array.c	2004-04-03 01:38:24.000000000 +0200
@@ -416,3 +416,22 @@ int proc_pid_statm(struct task_struct *t
 	return sprintf(buffer,"%d %d %d %d %d %d %d\n",
 		       size, resident, shared, text, lib, data, 0);
 }
+
+
+int proc_pid_delay(struct task_struct *task, char * buffer)
+{
+	int res;
+
+	res  = sprintf(buffer,"%lu %lu %lu %lu %lu %lu %lu\n",
+		       get_delay(task,runs),
+		       get_delay(task,runcpu_total),
+		       get_delay(task,waitcpu_total),
+		       get_delay(task,iowait_total),
+		       get_delay(task,num_iowaits),
+		       get_delay(task,mem_iowait_total),
+		       get_delay(task,num_memwaits)
+		       
+		);
+	return res;
+}
+
diff -uNrp linux-2.6.4/fs/proc/base.c linux-2.6.4.delay/fs/proc/base.c
--- linux-2.6.4/fs/proc/base.c	2004-04-03 01:37:32.000000000 +0200
+++ linux-2.6.4.delay/fs/proc/base.c	2004-04-03 01:39:32.000000000 +0200
@@ -93,6 +93,10 @@ enum pid_directory_inos {
 	PROC_TID_ATTR_EXEC,
 	PROC_TID_ATTR_FSCREATE,
 #endif
+#ifdef CONFIG_DELAY_ACCT
+        PROC_TID_DELAY_ACCT,
+        PROC_TGID_DELAY_ACCT,
+#endif
 	PROC_TID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
 	PROC_TID_OOM_SCORE,
 	PROC_TID_OOM_ADJUST,
@@ -128,6 +132,9 @@ static struct pid_entry tgid_base_stuff[
 #ifdef CONFIG_SECURITY
 	E(PROC_TGID_ATTR,      "attr",    S_IFDIR|S_IRUGO|S_IXUGO),
 #endif
+#ifdef CONFIG_DELAY_ACCT
+	E(PROC_TGID_DELAY_ACCT,"delay",   S_IFREG|S_IRUGO),
+#endif
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TGID_WCHAN,     "wchan",   S_IFREG|S_IRUGO),
 #endif
@@ -152,6 +159,9 @@ static struct pid_entry tid_base_stuff[]
 #ifdef CONFIG_SECURITY
 	E(PROC_TID_ATTR,       "attr",    S_IFDIR|S_IRUGO|S_IXUGO),
 #endif
+#ifdef CONFIG_DELAY_ACCT
+	E(PROC_TGID_DELAY_ACCT,"delay",   S_IFREG|S_IRUGO),
+#endif
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TID_WCHAN,      "wchan",   S_IFREG|S_IRUGO),
 #endif
@@ -193,6 +203,7 @@ int proc_pid_stat(struct task_struct*,ch
 int proc_pid_status(struct task_struct*,char*);
 int proc_pid_statm(struct task_struct*,char*);
 int proc_pid_cpu(struct task_struct*,char*);
+int proc_pid_delay(struct task_struct*,char*);
 
 static int proc_fd_link(struct inode *inode, struct dentry **dentry, struct vfsmount **mnt)
 {
@@ -1507,6 +1518,13 @@ static struct dentry *proc_pident_lookup
 			inode->i_fop = &proc_pid_attr_operations;
 			break;
 #endif
+#ifdef CONFIG_DELAY_ACCT
+		case PROC_TID_DELAY_ACCT:
+		case PROC_TGID_DELAY_ACCT:
+			inode->i_fop = &proc_info_file_operations;
+			ei->op.proc_read = proc_pid_delay;
+			break;
+#endif
 #ifdef CONFIG_KALLSYMS
 		case PROC_TID_WCHAN:
 		case PROC_TGID_WCHAN:
diff -uNrp linux-2.6.4/include/linux/sched.h linux-2.6.4.delay/include/linux/sched.h
--- linux-2.6.4/include/linux/sched.h	2004-04-03 01:37:33.000000000 +0200
+++ linux-2.6.4.delay/include/linux/sched.h	2004-04-03 01:38:24.000000000 +0200
@@ -134,6 +134,7 @@ struct sched_param {
 
 #ifdef __KERNEL__
 
+#include <linux/taskdelays.h>
 #include <linux/spinlock.h>
 
 /*
@@ -508,6 +509,8 @@ struct task_struct {
 	void *ce_data;
 #endif // CONFIG_CKRM
 
+	/* this is empty if CONFIG_DELAY_ACCT is not set */
+	struct task_delay_info  delays;
 /* TASK_UNMAPPED_BASE */
 	unsigned long map_base;
 };
@@ -553,6 +556,9 @@ do { if (atomic_dec_and_test(&(tsk)->usa
 #define PF_LESS_THROTTLE 0x00100000	/* Throttle me less: I clean memory */
 #define PF_SYNCWRITE	0x00200000	/* I am doing a sync write */
 
+#define PF_MEMIO   	0x00400000      /* I am  potentially doing I/O for mem */
+#define PF_IOWAIT       0x00800000      /* I am waiting on disk I/O */
+
 #ifdef CONFIG_SMP
 extern int set_cpus_allowed(task_t *p, cpumask_t new_mask);
 #else
@@ -1000,6 +1006,60 @@ static inline void set_task_cpu(struct t
 
 #endif /* CONFIG_SMP */
 
+
+/* API for registering delay info */
+#ifdef CONFIG_DELAY_ACCT
+
+#define test_delay_flag(tsk,flg)                ((tsk)->flags & (flg))
+#define set_delay_flag(tsk,flg)                 ((tsk)->flags |= (flg))
+#define clear_delay_flag(tsk,flg)               ((tsk)->flags &= ~(flg))
+
+#define def_delay_var(var)		        unsigned long long var
+#define get_delay(tsk,field)                    ((tsk)->delays.field)
+#define delay_value(x)				(((unsigned long)(x))/1000)
+
+#define start_delay(var)                        ((var) = sched_clock())
+#define start_delay_set(var,flg)                (set_delay_flag(current,flg),(var) = sched_clock())
+
+#define inc_delay(tsk,field) (((tsk)->delays.field)++)
+#define add_delay_ts(tsk,field,start_ts,end_ts) ((tsk)->delays.field += delay_value((end_ts)-(start_ts)))
+#define add_delay_clear(tsk,field,start_ts,flg) (add_delay_ts(tsk,field,start_ts,sched_clock()),clear_delay_flag(tsk,flg))
+
+static inline void add_io_delay(unsigned long dstart) 
+{
+	struct task_struct * tsk = current;
+	unsigned long val = delay_value(sched_clock()-dstart);
+	if (test_delay_flag(tsk,PF_MEMIO)) {
+		tsk->delays.mem_iowait_total += val;
+		tsk->delays.num_memwaits++;
+	} else {
+		tsk->delays.iowait_total += val;
+		tsk->delays.num_iowaits++;
+	}
+	clear_delay_flag(tsk,PF_IOWAIT);
+}
+
+
+#else
+
+#define test_delay_flag(tsk,flg)                (0)
+#define set_delay_flag(tsk,flg)                 do { } while (0)
+#define clear_delay_flag(tsk,flg)               do { } while (0)
+
+#define def_delay_var(var)			      
+#define get_delay(tsk,field)                    (0)
+
+#define start_delay(var)                        do { } while (0)
+#define start_delay_set(var,flg)                do { } while (0)
+
+#define inc_delay(tsk,field)                    do { } while (0)
+#define add_delay_ts(tsk,field,start_ts,now)    do { } while (0)
+#define add_delay_clear(tsk,field,start_ts,flg) do { } while (0)
+#define add_io_delay(dstart)			do { } while (0) 
+#endif
+
+
+
 #endif /* __KERNEL__ */
 
 #endif
diff -uNrp linux-2.6.4/include/linux/taskdelays.h linux-2.6.4.delay/include/linux/taskdelays.h
--- linux-2.6.4/include/linux/taskdelays.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.4.delay/include/linux/taskdelays.h	2004-04-03 01:38:24.000000000 +0200
@@ -0,0 +1,20 @@
+#ifndef _LINUX_TASKDELAYS_H
+#define _LINUX_TASKDELAYS_H
+
+#include <linux/config.h>
+
+struct task_delay_info {
+#ifdef CONFIG_DELAY_ACCT
+        /* delay statistics in usecs */
+	unsigned long runs;
+	unsigned long waitcpu_total;
+	unsigned long runcpu_total;
+	unsigned long iowait_total;
+	unsigned long mem_iowait_total;
+	unsigned long num_iowaits;
+	unsigned long num_memwaits;
+#endif
+};
+
+#endif // _LINUX_TASKDELAYS_H
+
diff -uNrp linux-2.6.4/init/Kconfig linux-2.6.4.delay/init/Kconfig
--- linux-2.6.4/init/Kconfig	2004-04-03 01:37:33.000000000 +0200
+++ linux-2.6.4.delay/init/Kconfig	2004-04-03 01:38:24.000000000 +0200
@@ -212,6 +212,15 @@ menuconfig EMBEDDED
 	  a "non-standard" kernel.  Only use this if you really know what you
 	  are doing.
 
+config DELAY_ACCT
+	bool "Enable delay accounting (EXPERIMENTAL)"
+	help
+	  In addition to counting frequency the total delay in ns is also
+	  recorded. CPU delays are specified as cpu-wait and cpu-run. Memory
+	  delay is recorded for minor and major faults. Information is
+	  accessible through /proc/<pid>/delay.
+
+
 config KALLSYMS
 	 bool "Load all symbols for debugging/kksymoops" if EMBEDDED
 	 default y
diff -uNrp linux-2.6.4/kernel/sched.c linux-2.6.4.delay/kernel/sched.c
--- linux-2.6.4/kernel/sched.c	2004-04-03 01:37:32.000000000 +0200
+++ linux-2.6.4.delay/kernel/sched.c	2004-04-03 01:38:24.000000000 +0200
@@ -1689,9 +1689,12 @@ switch_tasks:
 		if (!(HIGH_CREDIT(prev) || LOW_CREDIT(prev)))
 			prev->interactive_credit--;
 	}
+	add_delay_ts(prev,runcpu_total,prev->timestamp,now);
 	prev->timestamp = now;
 
 	if (likely(prev != next)) {
+		add_delay_ts(next,waitcpu_total,next->timestamp,now);
+		inc_delay(next,runs);
 		next->timestamp = now;
 		rq->nr_switches++;
 		rq->curr = next;
@@ -2455,10 +2458,13 @@ EXPORT_SYMBOL(yield);
 void io_schedule(void)
 {
 	struct runqueue *rq = this_rq();
+	def_delay_var(dstart);
 
+	start_delay_set(dstart,PF_IOWAIT);
 	atomic_inc(&rq->nr_iowait);
 	schedule();
 	atomic_dec(&rq->nr_iowait);
+	add_io_delay(dstart);
 }
 
 EXPORT_SYMBOL(io_schedule);
@@ -2467,10 +2473,13 @@ long io_schedule_timeout(long timeout)
 {
 	struct runqueue *rq = this_rq();
 	long ret;
+	def_delay_var(dstart);
 
+	start_delay_set(dstart,PF_IOWAIT);
 	atomic_inc(&rq->nr_iowait);
 	ret = schedule_timeout(timeout);
 	atomic_dec(&rq->nr_iowait);
+	add_io_delay(dstart);
 	return ret;
 }
 
@@ -3049,6 +3058,14 @@ task_t *kdb_cpu_curr(int cpu)
 }
 #endif
 
+#ifdef CONFIG_DELAY_ACCT
+int task_running_sys(struct task_struct *p)
+{
+       return task_running(task_rq(p),p);
+}
+EXPORT_SYMBOL(task_running_sys);
+#endif
+
 static int __init init_desktop(char *str)
 {
 	min_timeslice = __MIN_TIMESLICE_DESKTOP;
diff -uNrp linux-2.6.4/mm/memory.c linux-2.6.4.delay/mm/memory.c
--- linux-2.6.4/mm/memory.c	2004-04-03 01:37:33.000000000 +0200
+++ linux-2.6.4.delay/mm/memory.c	2004-04-03 01:38:24.000000000 +0200
@@ -1620,15 +1620,20 @@ int handle_mm_fault(struct mm_struct *mm
 	 * We need the page table lock to synchronize with kswapd
 	 * and the SMP-safe atomic PTE updates.
 	 */
+	set_delay_flag(current,PF_MEMIO);
 	spin_lock(&mm->page_table_lock);
 	pmd = pmd_alloc(mm, pgd, address);
 
 	if (pmd) {
 		pte_t * pte = pte_alloc_map(mm, pmd, address);
-		if (pte)
-			return handle_pte_fault(mm, vma, address, write_access, pte, pmd);
+		if (pte) {
+			int rc = handle_pte_fault(mm, vma, address, write_access, pte, pmd);
+			clear_delay_flag(current,PF_MEMIO);
+			return rc;
+		}
 	}
 	spin_unlock(&mm->page_table_lock);
+	clear_delay_flag(current,PF_MEMIO);
 	return VM_FAULT_OOM;
 }
 
