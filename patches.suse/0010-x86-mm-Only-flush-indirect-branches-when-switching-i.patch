From: Andi Kleen <ak@linux.intel.com>
Date: Tue, 7 Nov 2017 13:52:42 -0800
Subject: x86/mm: Only flush indirect branches when switching into non dumpable
 process
Git-repo: git://git.infradead.org/users/dwmw2/linux-retpoline.git
Git-commit: eb052500e0d28e8b90d4a7de0f6303f54224b84f
Patch-mainline: Queued in subsystem maintainer repository
References: bsc#1068032 CVE-2017-5753

Flush indirect branches when switching into a process that marked
itself non dumpable.  This protects high value processes like gpg
better, without having too high performance overhead.

[Ingo: clean up comments]
Signed-off-by: Andi Kleen <ak@linux.intel.com>
Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 arch/x86/mm/tlb.c |   14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

--- a/arch/x86/mm/tlb.c
+++ b/arch/x86/mm/tlb.c
@@ -225,8 +225,20 @@ void switch_mm_irqs_off(struct mm_struct
 		 * Avoid user/user BTB poisoning by flushing the branch predictor
 		 * when switching between processes. This stops one process from
 		 * doing Spectre-v2 attacks on another.
+		 *
+                 * As an optimization flush indirect branches only when
+                 * switching into processes that disable dumping.
+                 *
+                 * This will not flush branches when switching into kernel
+                 * threads, but it would flush them when switching to the
+                 * idle thread and back.
+                 *
+                 * It might be useful to have a one-off cache here
+                 * to also not flush the idle case, but we would need some
+                 * kind of stable sequence number to remember the previous mm.
 		 */
-		indirect_branch_prediction_barrier();
+		if (tsk && tsk->mm && get_dumpable(tsk->mm) != SUID_DUMP_USER)
+			indirect_branch_prediction_barrier();
 
 		if (IS_ENABLED(CONFIG_VMAP_STACK)) {
 			/*
