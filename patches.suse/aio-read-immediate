
From: Suparna Bhattacharya <suparna@in.ibm.com>

Currently, the high level AIO code keeps issuing retries until the 
entire transfer is done, i.e. until all the bytes requested are 
read (See aio_pread), which is what we needed for filesystem aio 
read. However, in the pipe read case, the expected semantics would 
be to return as soon as it has any bytes transferred, rather than 
waiting for the entire transfer.  This will also be true in for 
network aio reads if/when we implement it.
                                                                                
Hmm, so we need to get the generic code to allow for this
possibility - maybe based on a check for ISFIFO/ISSOCK ?

 aio.c |   12 ++++++++++--
 1 files changed, 10 insertions(+), 2 deletions(-)


Index: linux.dm/fs/aio.c
===================================================================
--- linux.dm.orig/fs/aio.c	2004-02-27 15:57:06.138297594 -0500
+++ linux.dm/fs/aio.c	2004-02-27 15:57:53.978124983 -0500
@@ -1265,6 +1265,8 @@
 static ssize_t aio_pread(struct kiocb *iocb)
 {
 	struct file *file = iocb->ki_filp;
+	struct address_space *mapping = file->f_mapping;
+	struct inode *inode = mapping->host;
 	ssize_t ret = 0;
 
 	ret = file->f_op->aio_read(iocb, iocb->ki_buf,
@@ -1277,8 +1279,14 @@
 	if (ret > 0) {
 		iocb->ki_buf += ret;
 		iocb->ki_left -= ret;
-
-		ret = -EIOCBRETRY;
+		/* 
+		 * For pipes and sockets we return once we have
+		 * some data; for regular files we retry till we
+		 * complete the entire read or find that we can't
+		 * read any more data (e.g short reads).
+		 */
+		if (!S_ISFIFO(inode->i_mode) && !S_ISSOCK(inode->i_mode))
+			ret = -EIOCBRETRY;
 	}
 
 	/* This means we must have transferred all that we could */
