
Hi Chris,

Here's an incremental patch for kprobes/dprobes on SLES 9.  It fixes the 
following problems:

- dprobes didn't call PROBEPOINT_HANDLER("test")when MODNAME
   is a kernel module
- dprobes wouldn't compile when loadable module support wasn't
   enabled

Regards,
Mike

-- 
Mike Mason
IBM Linux Technology Center
Beaverton, Oregon, USA
mmlnx@us.ibm.com
phone: (503) 578-4123
tie line: 775-4123

--------------000204080008010002040609
Content-Type: text/plain; name="kprobes-dprobes-mod-support-03152004-inc.patch"
Content-Disposition: inline; filename="kprobes-dprobes-mod-support-03152004-inc.patch"
Content-Transfer-Encoding: 8bit

Index: linux.t/arch/i386/Kconfig
===================================================================
--- linux.t.orig/arch/i386/Kconfig	2004-03-21 12:04:39.766462110 -0500
+++ linux.t/arch/i386/Kconfig	2004-03-21 12:04:41.043309417 -0500
@@ -1299,7 +1299,7 @@ config KWATCH
 
 config DPROBES
 	tristate "Dynamic Probes"
-	depends on DEBUG_KERNEL && KPROBES
+	depends on DEBUG_KERNEL && MODULES && KPROBES
 	help
 	  DProbes provides a higher level interface to kprobes. DProbes
 	  enables you to write probe programs in a RPN language. If
Index: linux.t/drivers/dprobes/dprobes.c
===================================================================
--- linux.t.orig/drivers/dprobes/dprobes.c	2004-03-21 12:04:39.785459838 -0500
+++ linux.t/drivers/dprobes/dprobes.c	2004-03-21 12:04:41.046309058 -0500
@@ -26,6 +26,7 @@
 #include <linux/vmalloc.h>
 #include <linux/swap.h>
 #include <linux/smp.h>
+#include <linux/notifier.h>
 #ifdef CONFIG_MAGIC_SYSRQ
 #include <linux/sysrq.h>
 #endif
@@ -1430,10 +1431,17 @@ int dp_insmod(struct module *kmod)
 {
 	struct dp_module_struct *m;
 	int retval;
+	char kmod_name[MODULE_NAME_LEN];
 
 	down_read(&dp_modlist_sem);
 	m = find_mod_by_name(kmod->name);
 	if (!m) {
+		strcpy(kmod_name, kmod->name);
+		strcat(kmod_name, ".ko");
+		m = find_mod_by_name(kmod_name);
+	}
+
+	if (!m) {
 		retval = -1;
 	} else {
 		get_kmod_bounds(m, kmod);
@@ -1452,9 +1460,15 @@ int dp_remmod(struct module *kmod)
 {
 	struct dp_module_struct *m;
 	int retval;
+	char kmod_name[MODULE_NAME_LEN];
 
 	down_read(&dp_modlist_sem);
 	m = find_mod_by_name(kmod->name);
+	if (!m) {
+		strcpy(kmod_name, kmod->name);
+		strcat(kmod_name, ".ko");
+		m = find_mod_by_name(kmod_name);
+	}
 	if (!m)
 		retval = -1;
 	else
@@ -1535,6 +1549,28 @@ static void dprobes_sysrq( int key, stru
 }
 #endif
 
+static int dp_module_load_notify(struct notifier_block * self, unsigned long val, void * data)
+{
+	struct module *kmod =(struct module *) data;
+	dp_insmod(kmod);
+	return 0;
+}
+
+static struct notifier_block dp_module_load_nb = {
+	.notifier_call = dp_module_load_notify,
+};
+
+static int dp_rmmodule_load_notify(struct notifier_block * self, unsigned long val, void * data)
+{
+	struct module *kmod =(struct module *) data;
+	dp_remmod(kmod);
+	return 0;
+}
+
+static struct notifier_block dp_rmmodule_load_nb = {
+	.notifier_call = dp_rmmodule_load_notify,
+};
+
 static int __init dprobes_init_module(void)
 {
 	int retval = 0;
@@ -1549,18 +1585,30 @@ static int __init dprobes_init_module(vo
 	printk("IBM Dynamic Probes v%d.%d.%d loaded.\n", DP_MAJOR_VER, 
 			DP_MINOR_VER, DP_PATCH_VER);
 
+	retval = register_module_notifier(&dp_module_load_nb);
+	if (retval)
+		goto err;
+	register_rmmodule_notifier(&dp_rmmodule_load_nb);
+	if (retval)
+		goto err1;
+
 #ifdef CONFIG_MAGIC_SYSRQ
 	if (!(dprobes_wq = create_workqueue("dprobes_wq"))) {
 		printk("dprobes create_workqueue failed\n");
 		retval = -ENOMEM;
-		goto err;
+		goto err2;
 	}
 	INIT_WORK(&dprobes_work, (void *)(void *)do_remove_sysrq, NULL);
 	if ((retval = register_sysrq_key('v', &key_op)))
 		printk("<1>register_sysrq_key returned %i\n", retval);
 #endif
-
+	return retval;
+err2:	unregister_rmmodule_notifier(&dp_module_load_nb);
+	printk("called unreg\n");
+err1:	unregister_module_notifier(&dp_rmmodule_load_nb);
+	printk("called unreg\n");
 err:	return retval;
+
 }
 
 static void __exit dprobes_cleanup_module(void)
@@ -1571,6 +1619,8 @@ static void __exit dprobes_cleanup_modul
 	printk("IBM Dynamic Probes v%d.%d.%d unloaded.\n", DP_MAJOR_VER, 
 			DP_MINOR_VER, DP_PATCH_VER);
 
+	unregister_rmmodule_notifier(&dp_module_load_nb);
+	unregister_module_notifier(&dp_rmmodule_load_nb);
 #ifdef CONFIG_MAGIC_SYSRQ        
 	destroy_workqueue(dprobes_wq);
 	if ((retval = unregister_sysrq_key('v', &key_op)))
Index: linux.t/include/linux/module.h
===================================================================
--- linux.t.orig/include/linux/module.h	2004-03-21 11:59:31.658278537 -0500
+++ linux.t/include/linux/module.h	2004-03-21 12:04:41.081304873 -0500
@@ -398,6 +398,8 @@ const struct exception_table_entry *sear
 
 int register_module_notifier(struct notifier_block * nb);
 int unregister_module_notifier(struct notifier_block * nb);
+int register_rmmodule_notifier(struct notifier_block * nb);
+int unregister_rmmodule_notifier(struct notifier_block * nb);
 
 #else /* !CONFIG_MODULES... */
 #define EXPORT_SYMBOL(sym)
@@ -477,6 +479,16 @@ static inline int unregister_module_noti
 	return 0;
 }
 
+static inline int register_rmmodule_notifier(struct notifier_block * nb)
+{
+	return 0;
+}
+
+static inline int unregister_rmmodule_notifier(struct notifier_block * nb)
+{
+	return 0;
+}
+
 #define module_put_and_exit(code) do_exit(code)
 
 #endif /* CONFIG_MODULES */
Index: linux.t/kernel/module.c
===================================================================
--- linux.t.orig/kernel/module.c	2004-03-21 12:04:34.841051253 -0500
+++ linux.t/kernel/module.c	2004-03-21 12:04:41.088304036 -0500
@@ -35,7 +35,7 @@
 #include <linux/notifier.h>
 #include <linux/stop_machine.h>
 #include <linux/trigevent_hooks.h>
-
+#include <linux/dprobes.h>
 #include <asm/uaccess.h>
 #include <asm/semaphore.h>
 #include <asm/pgalloc.h>
@@ -66,6 +66,8 @@ static LIST_HEAD(modules);
 
 static DECLARE_MUTEX(notify_mutex);
 static struct notifier_block * module_notify_list;
+static DECLARE_MUTEX(rmmod_notify_mutex);
+static struct notifier_block * rmmodule_notify_list;
 
 int register_module_notifier(struct notifier_block * nb)
 {
@@ -87,6 +89,26 @@ int unregister_module_notifier(struct no
 }
 EXPORT_SYMBOL(unregister_module_notifier);
 
+int register_rmmodule_notifier(struct notifier_block * nb)
+{
+	int err;
+	down(&rmmod_notify_mutex);
+	err = notifier_chain_register(&rmmodule_notify_list, nb);
+	up(&rmmod_notify_mutex);
+	return err;
+}
+EXPORT_SYMBOL(register_rmmodule_notifier);
+
+int unregister_rmmodule_notifier(struct notifier_block * nb)
+{
+	int err;
+	down(&rmmod_notify_mutex);
+	err = notifier_chain_unregister(&module_notify_list, nb);
+	up(&rmmod_notify_mutex);
+	return err;
+}
+EXPORT_SYMBOL(unregister_rmmodule_notifier);
+
 /* We require a truly strong try_module_get() */
 static inline int strong_try_module_get(struct module *mod)
 {
@@ -954,6 +976,10 @@ static void free_module(struct module *m
 	list_del(&mod->list);
 	spin_unlock_irq(&modlist_lock);
 
+	down(&rmmod_notify_mutex);
+	notifier_call_chain(&rmmodule_notify_list, MODULE_STATE_GOING, mod);
+	up(&rmmod_notify_mutex);
+
 	/* Arch-specific cleanup. */
 	module_arch_cleanup(mod);
 
@@ -1638,9 +1664,13 @@ sys_init_module(void __user *umod,
                    buggy refcounters. */
 		mod->state = MODULE_STATE_GOING;
 		synchronize_kernel();
-		if (mod->unsafe)
+		if (mod->unsafe) {
 			printk(KERN_ERR "%s: module is now stuck!\n",
 			       mod->name);
+			down(&rmmod_notify_mutex);
+			notifier_call_chain(&rmmodule_notify_list, MODULE_STATE_GOING, mod);
+			up(&rmmod_notify_mutex);
+		}
 		else {
 			module_put(mod);
 			down(&module_mutex);
