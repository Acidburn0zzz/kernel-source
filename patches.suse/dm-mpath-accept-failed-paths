From: Hannes Reinecke <hare@suse.de>
Subject: Accept failed paths for multipath maps
References: bnc#458037

The multipath kernel module is rejecting any map with an invalid
device. However, as the multipathd is processing the events serially
it will try to push a map with invalid devices if more than one
device failed at the same time.
So we can as well accept those maps and make sure to mark the
paths as down.

Signed-off-by: Hannes Reinecke <hare@suse.de>

Index: linux-2.6.27/drivers/md/dm-mpath.c
===================================================================
--- linux-2.6.27.orig/drivers/md/dm-mpath.c
+++ linux-2.6.27/drivers/md/dm-mpath.c
@@ -140,7 +140,8 @@ static void deactivate_path(struct work_
 	struct pgpath *pgpath =
 		container_of(work, struct pgpath, deactivate_path);
 
-	blk_abort_queue(pgpath->path.dev->bdev->bd_disk->queue);
+	if (pgpath->path.dev)
+		blk_abort_queue(pgpath->path.dev->bdev->bd_disk->queue);
 }
 
 static struct priority_group *alloc_priority_group(void)
@@ -571,6 +572,7 @@ static struct pgpath *parse_path(struct 
 {
 	int r;
 	struct pgpath *p;
+	char *path;
 	struct multipath *m = ti->private;
 
 	/* we need at least a path arg */
@@ -583,14 +585,33 @@ static struct pgpath *parse_path(struct 
 	if (!p)
 		return NULL;
 
-	r = dm_get_device(ti, shift(as), ti->begin, ti->len,
+	path = shift(as);
+	r = dm_get_device(ti, path, ti->begin, ti->len,
 			  dm_table_get_mode(ti->table), &p->path.dev);
 	if (r) {
-		ti->error = "error getting device";
-		goto bad;
+		unsigned major, minor;
+
+		/* Try to add a failed device */
+		if (sscanf(path, "%u:%u", &major, &minor) == 2) {
+			/* Extract the major/minor numbers */
+			p->path.pdev = MKDEV(major, minor);
+			if (MAJOR(p->path.pdev) != major ||
+			    MINOR(p->path.pdev) != minor) {
+				/* Nice try, didn't work */
+				DMWARN("Invalid device path %s", path);
+				ti->error = "error converting devnum";
+				goto bad;
+			}
+			DMWARN("adding disabled device %d:%d", major, minor);
+			p->path.dev = NULL;
+			p->is_active = 0;
+		} else {
+			ti->error = "error getting device";
+			goto bad;
+		}
 	}
 
-	if (m->hw_handler_name) {
+	if (m->hw_handler_name && p->path.dev) {
 		struct request_queue *q = bdev_get_queue(p->path.dev->bdev);
 
 		r = scsi_dh_attach(q, m->hw_handler_name);
@@ -892,8 +913,9 @@ static int fail_path(struct pgpath *pgpa
 	if (pgpath == m->current_pgpath)
 		m->current_pgpath = NULL;
 
-	dm_path_uevent(DM_UEVENT_PATH_FAILED, m->ti,
-		      pgpath->path.dev->name, m->nr_valid_paths);
+	if (pgpath->path.dev)
+		dm_path_uevent(DM_UEVENT_PATH_FAILED, m->ti,
+			       pgpath->path.dev->name, m->nr_valid_paths);
 
 	queue_work(kmultipathd, &m->trigger_event);
 	queue_work(kmultipathd, &pgpath->deactivate_path);
@@ -918,6 +940,13 @@ static int reinstate_path(struct pgpath 
 	if (pgpath->is_active)
 		goto out;
 
+	if (!pgpath->path.dev) {
+		DMWARN("Cannot reinstate disabled path %d:%d",
+		       MAJOR(pgpath->path.pdev), MINOR(pgpath->path.pdev));
+		r = -ENODEV;
+		goto out;
+	}
+
 	if (!pgpath->pg->ps.type->reinstate_path) {
 		DMWARN("Reinstate path not supported by path selector %s",
 		       pgpath->pg->ps.type->name);
@@ -956,6 +985,9 @@ static int action_dev(struct multipath *
 	struct pgpath *pgpath;
 	struct priority_group *pg;
 
+	if (!dev)
+		return 0;
+
 	list_for_each_entry(pg, &m->priority_groups, list) {
 		list_for_each_entry(pgpath, &pg->pgpaths, list) {
 			if (pgpath->path.dev == dev)
@@ -1303,9 +1335,16 @@ static int multipath_status(struct dm_ta
 			       pg->ps.type->info_args);
 
 			list_for_each_entry(p, &pg->pgpaths, list) {
-				DMEMIT("%s %s %u ", p->path.dev->name,
-				       p->is_active ? "A" : "F",
-				       p->fail_count);
+				if (p->path.dev) {
+					DMEMIT("%s %s %u ", p->path.dev->name,
+					       p->is_active ? "A" : "F",
+					       p->fail_count);
+				} else {
+					DMEMIT("%d:%d F %u ",
+					       MAJOR(p->path.pdev),
+					       MINOR(p->path.pdev),
+					       p->fail_count);
+				}
 				if (pg->ps.type->status)
 					sz += pg->ps.type->status(&pg->ps,
 					      &p->path, type, result + sz,
@@ -1329,7 +1368,12 @@ static int multipath_status(struct dm_ta
 			       pg->ps.type->table_args);
 
 			list_for_each_entry(p, &pg->pgpaths, list) {
-				DMEMIT("%s ", p->path.dev->name);
+				if (p->path.dev)
+					DMEMIT("%s ", p->path.dev->name);
+				else
+					DMEMIT("%d:%d ",
+					       MAJOR(p->path.pdev),
+					       MINOR(p->path.pdev));
 				if (pg->ps.type->status)
 					sz += pg->ps.type->status(&pg->ps,
 					      &p->path, type, result + sz,
@@ -1411,7 +1455,7 @@ static int multipath_ioctl(struct dm_tar
 	if (!m->current_pgpath)
 		__choose_pgpath(m, 1 << 19); /* Assume 512KB */
 
-	if (m->current_pgpath) {
+	if (m->current_pgpath && m->current_pgpath->path.dev) {
 		bdev = m->current_pgpath->path.dev->bdev;
 		fake_dentry.d_inode = bdev->bd_inode;
 		fake_file.f_mode = m->current_pgpath->path.dev->mode;
Index: linux-2.6.27/drivers/md/dm-mpath.h
===================================================================
--- linux-2.6.27.orig/drivers/md/dm-mpath.h
+++ linux-2.6.27/drivers/md/dm-mpath.h
@@ -12,6 +12,7 @@
 struct dm_dev;
 
 struct dm_path {
+	dev_t pdev;		/* Requested physical device */
 	struct dm_dev *dev;	/* Read-only */
 	void *pscontext;	/* For path-selector use */
 };
Index: linux-2.6.27/drivers/md/dm-table.c
===================================================================
--- linux-2.6.27.orig/drivers/md/dm-table.c
+++ linux-2.6.27/drivers/md/dm-table.c
@@ -566,6 +566,9 @@ int dm_get_device(struct dm_target *ti, 
  */
 void dm_put_device(struct dm_target *ti, struct dm_dev *dd)
 {
+	if (!dd)
+		return;
+
 	if (atomic_dec_and_test(&dd->count)) {
 		close_dev(dd, ti->table->md);
 		list_del(&dd->list);
