From: Andrea Arcangeli <andrea@suse.de>
Subject: avoid silent stack overflow over the heap
Patch-mainline: no
References: SUSE44807

x

Signed-off-by: Andrea Arcangeli <andrea@suse.de>

 arch/alpha/mm/fault.c                  |    2 -
 arch/arm/mm/fault.c                    |    2 -
 arch/arm26/mm/fault.c                  |    2 -
 arch/cris/mm/fault.c                   |    2 -
 arch/frv/mm/fault.c                    |    2 -
 arch/i386/mm/fault.c                   |   10 ++++++-
 arch/ia64/mm/fault.c                   |    2 -
 arch/m32r/mm/fault.c                   |    2 -
 arch/m68k/mm/fault.c                   |    2 -
 arch/mips/mm/fault.c                   |    2 -
 arch/parisc/mm/fault.c                 |    2 -
 arch/powerpc/mm/fault.c                |    5 ++-
 arch/powerpc/platforms/cell/spu_base.c |    2 -
 arch/ppc/mm/fault.c                    |    5 ++-
 arch/s390/mm/fault.c                   |    2 -
 arch/sh/mm/fault.c                     |    2 -
 arch/sh64/mm/fault.c                   |    2 -
 arch/sparc/mm/fault.c                  |    4 +--
 arch/sparc64/mm/fault.c                |    2 -
 arch/um/kernel/trap_kern.c             |    9 ++++---
 arch/x86_64/kernel/sys_x86_64.c        |   10 +++++++
 arch/x86_64/mm/fault.c                 |   10 ++++++-
 arch/xtensa/mm/fault.c                 |    2 -
 include/linux/mm.h                     |    5 +++
 include/linux/sysctl.h                 |    1 
 kernel/sysctl.c                        |    8 ++++++
 mm/mmap.c                              |   42 +++++++++++++++++++++++++--------
 27 files changed, 101 insertions(+), 40 deletions(-)

Index: sles10/arch/alpha/mm/fault.c
--- sles10/arch/alpha/mm/fault.c.orig	2006-01-16 13:38:59.000000000 +0100
+++ sles10/arch/alpha/mm/fault.c	2006-03-18 12:09:37.000000000 +0100
@@ -125,7 +125,7 @@ do_page_fault(unsigned long address, uns
 		goto good_area;
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
-	if (expand_stack(vma, address))
+	if (expand_stack(vma, address, NULL))
 		goto bad_area;
 
 	/* Ok, we have a good vm_area for this memory access, so
Index: sles10/arch/arm/mm/fault.c
--- sles10/arch/arm/mm/fault.c.orig	2006-01-16 13:41:58.000000000 +0100
+++ sles10/arch/arm/mm/fault.c	2006-03-18 12:09:37.000000000 +0100
@@ -210,7 +210,7 @@ survive:
 	goto survive;
 
 check_stack:
-	if (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr))
+	if (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr, NULL))
 		goto good_area;
 out:
 	return fault;
Index: sles10/arch/arm26/mm/fault.c
--- sles10/arch/arm26/mm/fault.c.orig	2006-01-16 13:41:14.000000000 +0100
+++ sles10/arch/arm26/mm/fault.c	2006-03-18 12:09:37.000000000 +0100
@@ -197,7 +197,7 @@ survive:
 	goto survive;
 
 check_stack:
-	if (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr))
+	if (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr, NULL))
 		goto good_area;
 out:
 	return fault;
Index: sles10/arch/cris/mm/fault.c
--- sles10/arch/cris/mm/fault.c.orig	2006-01-16 13:41:14.000000000 +0100
+++ sles10/arch/cris/mm/fault.c	2006-03-18 12:09:37.000000000 +0100
@@ -253,7 +253,7 @@ do_page_fault(unsigned long address, str
 		if (address + PAGE_SIZE < rdusp())
 			goto bad_area;
 	}
-	if (expand_stack(vma, address))
+	if (expand_stack(vma, address, NULL))
 		goto bad_area;
 
 	/*
Index: sles10/arch/i386/mm/fault.c
--- sles10/arch/i386/mm/fault.c.orig	2006-01-16 13:42:29.000000000 +0100
+++ sles10/arch/i386/mm/fault.c	2006-03-18 12:09:37.000000000 +0100
@@ -229,7 +229,7 @@ fastcall void __kprobes do_page_fault(st
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
-	struct vm_area_struct * vma;
+	struct vm_area_struct * vma, * prev_vma;
 	unsigned long address;
 	unsigned long page;
 	int write, si_code;
@@ -319,7 +319,13 @@ fastcall void __kprobes do_page_fault(st
 		if (address + 32 < regs->esp)
 			goto bad_area;
 	}
-	if (expand_stack(vma, address))
+	/*
+	 * find_vma_prev is just a bit slower, because it cannot
+	 * use the mmap_cache, so we run it only in the growsdown
+	 * slow path and we leave find_vma in the fast path.
+	 */
+	find_vma_prev(current->mm, address, &prev_vma);
+	if (expand_stack(vma, address, prev_vma))
 		goto bad_area;
 /*
  * Ok, we have a good vm_area for this memory access, so
Index: sles10/arch/ia64/mm/fault.c
--- sles10/arch/ia64/mm/fault.c.orig	2006-01-16 13:42:29.000000000 +0100
+++ sles10/arch/ia64/mm/fault.c	2006-03-18 12:09:37.000000000 +0100
@@ -152,7 +152,7 @@ ia64_do_page_fault (unsigned long addres
 		if (REGION_NUMBER(address) != REGION_NUMBER(vma->vm_start)
 		    || REGION_OFFSET(address) >= RGN_MAP_LIMIT)
 			goto bad_area;
-		if (expand_stack(vma, address))
+		if (expand_stack(vma, address, NULL /* FIXME? */))
 			goto bad_area;
 	} else {
 		vma = prev_vma;
Index: sles10/arch/m68k/mm/fault.c
--- sles10/arch/m68k/mm/fault.c.orig	2006-01-16 13:41:14.000000000 +0100
+++ sles10/arch/m68k/mm/fault.c	2006-03-18 12:09:37.000000000 +0100
@@ -121,7 +121,7 @@ int do_page_fault(struct pt_regs *regs, 
 		if (address + 256 < rdusp())
 			goto map_err;
 	}
-	if (expand_stack(vma, address))
+	if (expand_stack(vma, address, NULL))
 		goto map_err;
 
 /*
Index: sles10/arch/mips/mm/fault.c
--- sles10/arch/mips/mm/fault.c.orig	2006-01-16 13:42:30.000000000 +0100
+++ sles10/arch/mips/mm/fault.c	2006-03-18 12:09:37.000000000 +0100
@@ -76,7 +76,7 @@ asmlinkage void do_page_fault(struct pt_
 		goto good_area;
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
-	if (expand_stack(vma, address))
+	if (expand_stack(vma, address, NULL))
 		goto bad_area;
 /*
  * Ok, we have a good vm_area for this memory access, so
Index: sles10/arch/parisc/mm/fault.c
--- sles10/arch/parisc/mm/fault.c.orig	2006-01-16 13:41:14.000000000 +0100
+++ sles10/arch/parisc/mm/fault.c	2006-03-18 12:09:38.000000000 +0100
@@ -199,7 +199,7 @@ good_area:
 
 check_expansion:
 	vma = prev_vma;
-	if (vma && (expand_stack(vma, address) == 0))
+	if (vma && (expand_stack(vma, address, NULL) == 0))
 		goto good_area;
 
 /*
Index: sles10/arch/ppc/mm/fault.c
--- sles10/arch/ppc/mm/fault.c.orig	2006-01-16 13:41:59.000000000 +0100
+++ sles10/arch/ppc/mm/fault.c	2006-03-18 12:09:38.000000000 +0100
@@ -95,7 +95,7 @@ static int store_updates_sp(struct pt_re
 int do_page_fault(struct pt_regs *regs, unsigned long address,
 		  unsigned long error_code)
 {
-	struct vm_area_struct * vma;
+	struct vm_area_struct * vma, * prev_vma;
 	struct mm_struct *mm = current->mm;
 	siginfo_t info;
 	int code = SEGV_MAPERR;
@@ -175,7 +175,8 @@ int do_page_fault(struct pt_regs *regs, 
 		    && (!user_mode(regs) || !store_updates_sp(regs)))
 			goto bad_area;
 	}
-	if (expand_stack(vma, address))
+	find_vma_prev(mm, address, &prev_vma);
+	if (expand_stack(vma, address, prev_vma))
 		goto bad_area;
 
 good_area:
Index: sles10/arch/s390/mm/fault.c
--- sles10/arch/s390/mm/fault.c.orig	2006-03-18 12:07:35.000000000 +0100
+++ sles10/arch/s390/mm/fault.c	2006-03-18 12:09:42.000000000 +0100
@@ -226,7 +226,7 @@ do_exception(struct pt_regs *regs, unsig
                 goto good_area;
         if (!(vma->vm_flags & VM_GROWSDOWN))
                 goto bad_area;
-        if (expand_stack(vma, address))
+        if (expand_stack(vma, address, NULL /* FIXME? */))
                 goto bad_area;
 /*
  * Ok, we have a good vm_area for this memory access, so
Index: sles10/arch/sh/mm/fault.c
--- sles10/arch/sh/mm/fault.c.orig	2006-01-16 13:42:34.000000000 +0100
+++ sles10/arch/sh/mm/fault.c	2006-03-18 12:09:42.000000000 +0100
@@ -69,7 +69,7 @@ asmlinkage void do_page_fault(struct pt_
 		goto good_area;
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
-	if (expand_stack(vma, address))
+	if (expand_stack(vma, address, NULL))
 		goto bad_area;
 /*
  * Ok, we have a good vm_area for this memory access, so
Index: sles10/arch/sh64/mm/fault.c
--- sles10/arch/sh64/mm/fault.c.orig	2006-01-16 13:41:15.000000000 +0100
+++ sles10/arch/sh64/mm/fault.c	2006-03-18 12:09:42.000000000 +0100
@@ -188,7 +188,7 @@ asmlinkage void do_page_fault(struct pt_
 #endif
 		goto bad_area;
 	}
-	if (expand_stack(vma, address)) {
+	if (expand_stack(vma, address, NULL)) {
 #ifdef DEBUG_FAULT
 		print_task(tsk);
 		printk("%s:%d fault, address is 0x%08x PC %016Lx textaccess %d writeaccess %d\n",
Index: sles10/arch/sparc/mm/fault.c
--- sles10/arch/sparc/mm/fault.c.orig	2006-01-16 13:42:34.000000000 +0100
+++ sles10/arch/sparc/mm/fault.c	2006-03-18 12:09:42.000000000 +0100
@@ -268,7 +268,7 @@ asmlinkage void do_sparc_fault(struct pt
 		goto good_area;
 	if(!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
-	if(expand_stack(vma, address))
+	if(expand_stack(vma, address, NULL))
 		goto bad_area;
 	/*
 	 * Ok, we have a good vm_area for this memory access, so
@@ -522,7 +522,7 @@ inline void force_user_fault(unsigned lo
 		goto good_area;
 	if(!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
-	if(expand_stack(vma, address))
+	if(expand_stack(vma, address, NULL))
 		goto bad_area;
 good_area:
 	info.si_code = SEGV_ACCERR;
Index: sles10/arch/sparc64/mm/fault.c
--- sles10/arch/sparc64/mm/fault.c.orig	2006-01-16 13:42:34.000000000 +0100
+++ sles10/arch/sparc64/mm/fault.c	2006-03-18 12:09:42.000000000 +0100
@@ -354,7 +354,7 @@ continue_fault:
 				goto bad_area;
 		}
 	}
-	if (expand_stack(vma, address))
+	if (expand_stack(vma, address, NULL))
 		goto bad_area;
 	/*
 	 * Ok, we have a good vm_area for this memory access, so
Index: sles10/arch/um/kernel/trap_kern.c
--- sles10/arch/um/kernel/trap_kern.c.orig	2006-03-18 12:07:36.000000000 +0100
+++ sles10/arch/um/kernel/trap_kern.c	2006-03-18 12:09:42.000000000 +0100
@@ -39,7 +39,7 @@ int handle_page_fault(unsigned long addr
 		      int is_write, int is_user, int *code_out)
 {
 	struct mm_struct *mm = current->mm;
-	struct vm_area_struct *vma;
+	struct vm_area_struct *vma, *prev_vma;
 	pgd_t *pgd;
 	pud_t *pud;
 	pmd_t *pmd;
@@ -63,8 +63,11 @@ int handle_page_fault(unsigned long addr
 		goto out;
 	else if(is_user && !ARCH_IS_STACKGROW(address))
 		goto out;
-	else if(expand_stack(vma, address)) 
-		goto out;
+	else {
+		find_vma_prev(mm, address, &prev_vma);
+		if(expand_stack(vma, address, prev_vma))
+			goto out;
+	}
 
 good_area:
 	*code_out = SEGV_ACCERR;
Index: sles10/arch/x86_64/kernel/sys_x86_64.c
--- sles10/arch/x86_64/kernel/sys_x86_64.c.orig	2006-01-16 13:42:34.000000000 +0100
+++ sles10/arch/x86_64/kernel/sys_x86_64.c	2006-03-18 13:11:01.000000000 +0100
@@ -117,6 +117,7 @@ arch_get_unmapped_area(struct file *filp
 
 full_search:
 	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
+		unsigned long __heap_stack_gap;
 		/* At this point:  (!vma || addr < vma->vm_end). */
 		if (end - len < addr) {
 			/*
@@ -130,7 +131,14 @@ full_search:
 			}
 			return -ENOMEM;
 		}
-		if (!vma || addr + len <= vma->vm_start) {
+		if (!vma)
+			goto got_it;
+		__heap_stack_gap = 0;
+		if (vma->vm_flags & VM_GROWSDOWN)
+			__heap_stack_gap = min(end-(addr+len),
+					       (unsigned long) heap_stack_gap << PAGE_SHIFT);
+		if (addr + len + __heap_stack_gap <= vma->vm_start) {
+		got_it:
 			/*
 			 * Remember the place where we stopped the search:
 			 */
Index: sles10/arch/x86_64/mm/fault.c
--- sles10/arch/x86_64/mm/fault.c.orig	2006-03-18 12:08:40.000000000 +0100
+++ sles10/arch/x86_64/mm/fault.c	2006-03-18 12:09:42.000000000 +0100
@@ -305,7 +305,7 @@ asmlinkage void __kprobes do_page_fault(
 {
 	struct task_struct *tsk;
 	struct mm_struct *mm;
-	struct vm_area_struct * vma;
+	struct vm_area_struct * vma, * prev_vma;
 	unsigned long address;
 	const struct exception_table_entry *fixup;
 	int write;
@@ -407,7 +407,13 @@ asmlinkage void __kprobes do_page_fault(
 		if (address + 128 < regs->rsp)
 			goto bad_area;
 	}
-	if (expand_stack(vma, address))
+	/*
+	 * find_vma_prev is just a bit slower, because it cannot
+	 * use the mmap_cache, so we run it only in the growsdown
+	 * slow path and we leave find_vma in the fast path.
+	 */
+	find_vma_prev(current->mm, address, &prev_vma);
+	if (expand_stack(vma, address, prev_vma))
 		goto bad_area;
 /*
  * Ok, we have a good vm_area for this memory access, so
Index: sles10/arch/m32r/mm/fault.c
--- sles10/arch/m32r/mm/fault.c.~1~	2006-01-16 13:40:17.000000000 +0100
+++ sles10/arch/m32r/mm/fault.c	2006-03-18 13:07:46.000000000 +0100
@@ -186,7 +186,7 @@ asmlinkage void do_page_fault(struct pt_
 			goto bad_area;
 	}
 #endif
-	if (expand_stack(vma, address))
+	if (expand_stack(vma, address, NULL))
 		goto bad_area;
 /*
  * Ok, we have a good vm_area for this memory access, so
Index: sles10/arch/frv/mm/fault.c
--- sles10/arch/frv/mm/fault.c.~1~	2006-01-16 13:41:14.000000000 +0100
+++ sles10/arch/frv/mm/fault.c	2006-03-18 13:07:36.000000000 +0100
@@ -120,7 +120,7 @@ asmlinkage void do_page_fault(int datamm
 		}
 	}
 
-	if (expand_stack(vma, ear0))
+	if (expand_stack(vma, ear0, NULL))
 		goto bad_area;
 
 /*
Index: sles10/arch/xtensa/mm/fault.c
--- sles10/arch/xtensa/mm/fault.c.~1~	2006-01-16 13:41:15.000000000 +0100
+++ sles10/arch/xtensa/mm/fault.c	2006-03-18 13:08:12.000000000 +0100
@@ -77,7 +77,7 @@ void do_page_fault(struct pt_regs *regs)
 		goto good_area;
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
-	if (expand_stack(vma, address))
+	if (expand_stack(vma, address, NULL))
 		goto bad_area;
 
 	/* Ok, we have a good vm_area for this memory access, so
Index: sles10/arch/powerpc/mm/fault.c
--- sles10/arch/powerpc/mm/fault.c.~1~	2006-03-18 12:07:31.000000000 +0100
+++ sles10/arch/powerpc/mm/fault.c	2006-03-18 13:04:57.000000000 +0100
@@ -121,7 +121,7 @@ static void do_dabr(struct pt_regs *regs
 int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address,
 			    unsigned long error_code)
 {
-	struct vm_area_struct * vma;
+	struct vm_area_struct * vma, * prev_vma;
 	struct mm_struct *mm = current->mm;
 	siginfo_t info;
 	int code = SEGV_MAPERR;
@@ -238,7 +238,8 @@ int __kprobes do_page_fault(struct pt_re
 		    && (!user_mode(regs) || !store_updates_sp(regs)))
 			goto bad_area;
 	}
-	if (expand_stack(vma, address))
+	find_vma_prev(mm, address, &prev_vma);
+	if (expand_stack(vma, address, prev_vma))
 		goto bad_area;
 
 good_area:
Index: sles10/arch/powerpc/platforms/cell/spu_base.c
--- sles10/arch/powerpc/platforms/cell/spu_base.c.~1~	2006-03-18 12:07:32.000000000 +0100
+++ sles10/arch/powerpc/platforms/cell/spu_base.c	2006-03-18 13:08:16.000000000 +0100
@@ -438,7 +438,7 @@ static int spu_handle_mm_fault(struct sp
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
 #if 0
-	if (expand_stack(vma, ea))
+	if (expand_stack(vma, ea, NULL))
 		goto bad_area;
 #endif /* XXX */
 good_area:
Index: sles10/include/linux/mm.h
--- sles10/include/linux/mm.h.orig	2006-03-18 12:09:03.000000000 +0100
+++ sles10/include/linux/mm.h	2006-03-18 12:10:31.000000000 +0100
@@ -975,7 +975,10 @@ void handle_ra_miss(struct address_space
 unsigned long max_sane_readahead(unsigned long nr);
 
 /* Do stack extension */
-extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
+#define EXPAND_STACK_HAS_3_ARGS
+extern int heap_stack_gap;
+extern int expand_stack(struct vm_area_struct * vma, unsigned long address,
+			struct vm_area_struct * prev_vma);
 #ifdef CONFIG_IA64
 extern int expand_upwards(struct vm_area_struct *vma, unsigned long address);
 #endif
Index: sles10/include/linux/sysctl.h
--- sles10/include/linux/sysctl.h.orig	2006-03-18 12:09:03.000000000 +0100
+++ sles10/include/linux/sysctl.h	2006-03-18 12:11:02.000000000 +0100
@@ -188,6 +188,7 @@ enum
 	VM_PERCPU_PAGELIST_FRACTION=30,/* int: fraction of pages in each percpu_pagelist */
 	VM_ZONE_RECLAIM_MODE=31, /* reclaim local zone memory before going off node */
 	VM_ZONE_RECLAIM_INTERVAL=32, /* time period to wait after reclaim failure */
+	VM_HEAP_STACK_GAP=33,	/* int: page gap between heap and stack */
 };
 
 
Index: sles10/kernel/sysctl.c
--- sles10/kernel/sysctl.c.orig	2006-03-18 12:09:01.000000000 +0100
+++ sles10/kernel/sysctl.c	2006-03-18 12:09:42.000000000 +0100
@@ -935,6 +935,14 @@ static ctl_table vm_table[] = {
 		.strategy	= &sysctl_jiffies,
 	},
 #endif
+	{
+		.ctl_name	= VM_HEAP_STACK_GAP,
+		.procname	= "heap-stack-gap", 
+		.data		= &heap_stack_gap,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 	{ .ctl_name = 0 }
 };
 
Index: sles10/mm/mmap.c
--- sles10/mm/mmap.c.orig	2006-03-18 12:08:11.000000000 +0100
+++ sles10/mm/mmap.c	2006-03-18 13:11:11.000000000 +0100
@@ -64,6 +64,7 @@ int sysctl_overcommit_memory = OVERCOMMI
 int sysctl_overcommit_ratio = 50;	/* default is 50% */
 int sysctl_max_map_count __read_mostly = DEFAULT_MAX_MAP_COUNT;
 atomic_t vm_committed_space = ATOMIC_INIT(0);
+int heap_stack_gap = 1;
 
 /*
  * Check that a process has enough memory to allocate a new virtual
@@ -1189,6 +1190,7 @@ arch_get_unmapped_area(struct file *filp
 full_search:
 	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
+		unsigned long __heap_stack_gap;
 		if (TASK_SIZE - len < addr) {
 			/*
 			 * Start a new search - just in case we missed
@@ -1202,7 +1204,14 @@ full_search:
 			}
 			return -ENOMEM;
 		}
-		if (!vma || addr + len <= vma->vm_start) {
+		if (!vma)
+			goto got_it;
+		__heap_stack_gap = 0;
+		if (vma->vm_flags & VM_GROWSDOWN)
+			__heap_stack_gap = min(TASK_SIZE-(addr+len),
+					       (unsigned long) heap_stack_gap << PAGE_SHIFT);
+		if (addr + len + __heap_stack_gap <= vma->vm_start) {
+		got_it:
 			/*
 			 * Remember the place where we stopped the search:
 			 */
@@ -1535,8 +1544,16 @@ int expand_upwards(struct vm_area_struct
 #endif /* CONFIG_STACK_GROWSUP || CONFIG_IA64 */
 
 #ifdef CONFIG_STACK_GROWSUP
-int expand_stack(struct vm_area_struct *vma, unsigned long address)
+int expand_stack(struct vm_area_struct * vma, unsigned long address,
+		 struct vm_area_struct * prev_vma)
 {
+	/*
+	 * If you re-use the heap-stack-gap for a growsup stack you
+	 * should implement the feature for growsup too and remove
+	 * this WARN_ON.
+	 */
+	WARN_ON(prev_vma);
+
 	return expand_upwards(vma, address);
 }
 
@@ -1549,7 +1566,7 @@ find_extend_vma(struct mm_struct *mm, un
 	vma = find_vma_prev(mm, addr, &prev);
 	if (vma && (vma->vm_start <= addr))
 		return vma;
-	if (!prev || expand_stack(prev, addr))
+	if (!prev || expand_stack(prev, addr, NULL))
 		return NULL;
 	if (prev->vm_flags & VM_LOCKED) {
 		make_pages_present(addr, prev->vm_end);
@@ -1557,10 +1574,8 @@ find_extend_vma(struct mm_struct *mm, un
 	return prev;
 }
 #else
-/*
- * vma is the first one with address < vma->vm_start.  Have to extend vma.
- */
-int expand_stack(struct vm_area_struct *vma, unsigned long address)
+int expand_stack(struct vm_area_struct *vma, unsigned long address,
+		 struct vm_area_struct *prev_vma)
 {
 	int error;
 
@@ -1584,6 +1599,13 @@ int expand_stack(struct vm_area_struct *
 	if (address < vma->vm_start) {
 		unsigned long size, grow;
 
+		error = -ENOMEM;
+		if (prev_vma) {
+			unsigned long __heap_stack_gap = min(TASK_SIZE-prev_vma->vm_end,
+							     (unsigned long) heap_stack_gap << PAGE_SHIFT);
+			if (unlikely(prev_vma->vm_end + __heap_stack_gap > address))
+				goto out_unlock;
+		}
 		size = vma->vm_end - address;
 		grow = (vma->vm_start - address) >> PAGE_SHIFT;
 
@@ -1593,6 +1615,7 @@ int expand_stack(struct vm_area_struct *
 			vma->vm_pgoff -= grow;
 		}
 	}
+ out_unlock:
 	anon_vma_unlock(vma);
 	return error;
 }
@@ -1600,7 +1623,7 @@ int expand_stack(struct vm_area_struct *
 struct vm_area_struct *
 find_extend_vma(struct mm_struct * mm, unsigned long addr)
 {
-	struct vm_area_struct * vma;
+	struct vm_area_struct * vma, * prev_vma;
 	unsigned long start;
 
 	addr &= PAGE_MASK;
@@ -1612,7 +1635,8 @@ find_extend_vma(struct mm_struct * mm, u
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		return NULL;
 	start = vma->vm_start;
-	if (expand_stack(vma, addr))
+	find_vma_prev(mm, addr, &prev_vma);
+	if (expand_stack(vma, addr, prev_vma))
 		return NULL;
 	if (vma->vm_flags & VM_LOCKED) {
 		make_pages_present(addr, start);
