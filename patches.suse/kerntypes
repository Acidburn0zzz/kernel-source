Add support for Kerntypes, needed for lcrash from lkcdutils.

diff -Naur linux-2.6.0-test7.before/include/linux/sched.h linux-2.6.0-test7.after/include/linux/sched.h
--- linux-2.6.0-test7.before/include/linux/sched.h	2003-10-09 00:54:01.000000000 +0530
+++ linux-2.6.0-test7.after/include/linux/sched.h	2003-10-09 12:00:10.000000000 +0530
@@ -91,6 +91,7 @@
 extern int nr_threads;
 extern int last_pid;
 DECLARE_PER_CPU(unsigned long, process_counts);
+DECLARE_PER_CPU(struct runqueue, runqueues);
 extern int nr_processes(void);
 extern unsigned long nr_running(void);
 extern unsigned long nr_uninterruptible(void);
@@ -546,6 +547,44 @@
 void yield(void);
 
 /*
+ * These are the runqueue data structures:
+ */
+
+#define BITMAP_SIZE ((((MAX_PRIO+1+7)/8)+sizeof(long)-1)/sizeof(long))
+
+typedef struct runqueue runqueue_t;
+
+struct prio_array {
+	int nr_active;
+	unsigned long bitmap[BITMAP_SIZE];
+	struct list_head queue[MAX_PRIO];
+};
+
+/*
+ * This is the main, per-CPU runqueue data structure.
+ *
+ * Locking rule: those places that want to lock multiple runqueues
+ * (such as the load balancing or the thread migration code), lock
+ * acquire operations must be ordered by ascending &runqueue.
+ */
+struct runqueue {
+	spinlock_t lock;
+	unsigned long nr_running, nr_switches, expired_timestamp,
+			nr_uninterruptible;
+	task_t *curr, *idle;
+	struct mm_struct *prev_mm;
+	prio_array_t *active, *expired, arrays[2];
+	int prev_cpu_load[NR_CPUS];
+#ifdef CONFIG_NUMA
+	atomic_t *node_nr_running;
+	int prev_node_load[MAX_NUMNODES];
+#endif
+	task_t *migration_thread;
+	struct list_head migration_queue;
+
+	atomic_t nr_iowait;
+};
+/*
  * The default (Linux) execution domain.
  */
 extern struct exec_domain	default_exec_domain;
diff -Naur linux-2.6.0-test7.before/init/Makefile linux-2.6.0-test7.after/init/Makefile
--- linux-2.6.0-test7.before/init/Makefile	2003-10-09 00:54:04.000000000 +0530
+++ linux-2.6.0-test7.after/init/Makefile	2003-10-09 12:00:10.000000000 +0530
@@ -9,6 +9,9 @@
 mounts-$(CONFIG_BLK_DEV_INITRD)	+= do_mounts_initrd.o
 mounts-$(CONFIG_BLK_DEV_MD)	+= do_mounts_md.o
 
+extra-$(CONFIG_CRASH_DUMP)	+= kerntypes.o
+CFLAGS_kerntypes.o		:= -gstabs
+
 # files to be removed upon make clean
 clean-files := ../include/linux/compile.h
 
@@ -24,3 +27,4 @@
 include/linux/compile.h: FORCE
 	@echo '  CHK     $@'
 	@sh $(srctree)/scripts/mkcompile_h $@ "$(UTS_MACHINE)" "$(CONFIG_SMP)" "$(CC) $(CFLAGS)"
+
diff -Naur linux-2.6.0-test7.before/init/main.c linux-2.6.0-test7.after/init/main.c
--- linux-2.6.0-test7.before/init/main.c	2003-10-09 00:54:02.000000000 +0530
+++ linux-2.6.0-test7.after/init/main.c	2003-10-09 12:00:10.000000000 +0530
@@ -97,6 +97,16 @@
 int system_running = 0;
 
 /*
+ * The kernel_magic value represents the address of _end, which allows
+ * namelist tools to "match" each other respectively.  That way a tool
+ * that looks at /dev/mem can verify that it is using the right System.map
+ * file -- if kernel_magic doesn't equal the namelist value of _end,
+ * something's wrong.
+ */
+extern unsigned long _end;
+unsigned long *kernel_magic = &_end;
+
+/*
  * Boot command-line arguments
  */
 #define MAX_INIT_ARGS 8
diff -Naur linux-2.6.0-test7.before/init/version.c linux-2.6.0-test7.after/init/version.c
--- linux-2.6.0-test7.before/init/version.c	2003-10-09 00:54:05.000000000 +0530
+++ linux-2.6.0-test7.after/init/version.c	2003-10-09 12:00:10.000000000 +0530
@@ -11,6 +11,7 @@
 #include <linux/uts.h>
 #include <linux/utsname.h>
 #include <linux/version.h>
+#include <linux/stringify.h>
 
 #define version(a) Version_ ## a
 #define version_string(a) version(a)
@@ -31,3 +32,6 @@
 const char *linux_banner = 
 	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
 	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
+
+const char *LINUX_COMPILE_VERSION_ID = __stringify(LINUX_COMPILE_VERSION_ID);
+LINUX_COMPILE_VERSION_ID_TYPE;
diff -Naur linux-2.6.0-test7.before/kernel/sched.c linux-2.6.0-test7.after/kernel/sched.c
--- linux-2.6.0-test7.before/kernel/sched.c	2003-10-09 00:54:27.000000000 +0530
+++ linux-2.6.0-test7.after/kernel/sched.c	2003-10-09 12:00:10.000000000 +0530
@@ -175,46 +178,8 @@
 	return BASE_TIMESLICE(p);
 }
 
-/*
- * These are the runqueue data structures:
- */
-
-#define BITMAP_SIZE ((((MAX_PRIO+1+7)/8)+sizeof(long)-1)/sizeof(long))
-
-typedef struct runqueue runqueue_t;
-
-struct prio_array {
-	int nr_active;
-	unsigned long bitmap[BITMAP_SIZE];
-	struct list_head queue[MAX_PRIO];
-};
-
-/*
- * This is the main, per-CPU runqueue data structure.
- *
- * Locking rule: those places that want to lock multiple runqueues
- * (such as the load balancing or the thread migration code), lock
- * acquire operations must be ordered by ascending &runqueue.
- */
-struct runqueue {
-	spinlock_t lock;
-	unsigned long nr_running, nr_switches, expired_timestamp,
-			nr_uninterruptible;
-	task_t *curr, *idle;
-	struct mm_struct *prev_mm;
-	prio_array_t *active, *expired, arrays[2];
-	int prev_cpu_load[NR_CPUS];
-#ifdef CONFIG_NUMA
-	atomic_t *node_nr_running;
-	int prev_node_load[MAX_NUMNODES];
-#endif
-	task_t *migration_thread;
-	struct list_head migration_queue;
-
-	atomic_t nr_iowait;
-};
 
-static DEFINE_PER_CPU(struct runqueue, runqueues);
+DEFINE_PER_CPU(struct runqueue, runqueues);
 
 #define cpu_rq(cpu)		(&per_cpu(runqueues, (cpu)))
 #define this_rq()		(&__get_cpu_var(runqueues))
diff -Naur linux-2.6.0-test7.before/scripts/mkcompile_h linux-2.6.0-test7.after/scripts/mkcompile_h
--- linux-2.6.0-test7.before/scripts/mkcompile_h	2003-10-09 00:54:53.000000000 +0530
+++ linux-2.6.0-test7.after/scripts/mkcompile_h	2003-10-09 12:00:10.000000000 +0530
@@ -33,7 +33,7 @@
 
 UTS_LEN=64
 UTS_TRUNCATE="sed -e s/\(.\{1,$UTS_LEN\}\).*/\1/"
-
+LINUX_COMPILE_VERSION_ID="__linux_compile_version_id__`hostname | tr -c '[0-9A-Za-z\n]' '__'`_`LANG=C date | tr -c '[0-9A-Za-z\n]' '_'`"
 # Generate a temporary compile.h
 
 ( echo /\* This file is auto generated, version $VERSION \*/
@@ -55,6 +55,8 @@
   fi
 
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
+  echo \#define LINUX_COMPILE_VERSION_ID $LINUX_COMPILE_VERSION_ID
+  echo \#define LINUX_COMPILE_VERSION_ID_TYPE typedef char* "$LINUX_COMPILE_VERSION_ID""_t"
 ) > .tmpcompile
 
 # Only replace the real compile.h if the new one is different,
diff -Naur linux-2.6.0-test7.before/init/kerntypes.c linux-2.6.0-test7.after/init/kerntypes.c
--- linux-2.6.0-test7.before/init/kerntypes.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.0-test7.after/init/kerntypes.c	2003-10-31 11:57:13.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+ * kerntypes.c
+ *
+ * Copyright (C) 2000 Tom Morano (tjm@sgi.com) and
+ *                    Matt D. Robinson (yakker@alacritech.com)
+ *
+ * Dummy module that includes headers for all kernel types of interest. 
+ * The kernel type information is used by the lcrash utility when 
+ * analyzing system crash dumps or the live system. Using the type 
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under version 2 of the GNU GPL.
+ */
+
+#include <linux/compile.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/config.h>
+#include <linux/utsname.h>
+#include <linux/dump.h>
+
+#ifdef LINUX_COMPILE_VERSION_ID_TYPE
+/* Define version type for version validation of dump and kerntypes */
+LINUX_COMPILE_VERSION_ID_TYPE;
+#endif
+
+void
+kerntypes_dummy(void)
+{
+}
diff -Naur linux-2.6.0-test7.before/arch/s390/boot/Makefile linux-2.6.0-test7.after/arch/s390/boot/Makefile
--- linux-2.6.0-test7.before/arch/s390/boot/Makefile	2003-10-09 00:54:53.000000000 +0530
+++ linux-2.6.0-test7.after/arch/s390/boot/Makefile	2003-10-09 12:00:10.000000000 +0530
@@ -15,4 +15,4 @@
 
 install: $(CONFIGURE) $(obj)/image
 	sh -x $(obj)/install.sh $(KERNELRELEASE) $(obj)/image \
-	      System.map Kerntypes "$(INSTALL_PATH)"
+	      System.map init/kerntypes.o "$(INSTALL_PATH)"
diff -Naur linux-2.6.0-test7.before/arch/s390/boot/install.sh linux-2.6.0-test7.after/arch/s390/boot/install.sh
--- linux-2.6.0-test7.before/arch/s390/boot/install.sh	2003-10-09 00:54:16.000000000 +0530
+++ linux-2.6.0-test7.after/arch/s390/boot/install.sh	2003-10-09 12:00:10.000000000 +0530
@@ -16,7 +16,8 @@
 #   $1 - kernel version
 #   $2 - kernel image file
 #   $3 - kernel map file
-#   $4 - default install path (blank if root directory)
+#   $4 - kernel type file
+#   $5 - default install path (blank if root directory)
 #
 
 # User may have a custom install script
@@ -26,13 +27,22 @@
 
 # Default install - same as make zlilo
 
-if [ -f $4/vmlinuz ]; then
-	mv $4/vmlinuz $4/vmlinuz.old
+if [ -f $5/vmlinuz ]; then
+	mv $5/vmlinuz $5/vmlinuz.old
 fi
 
-if [ -f $4/System.map ]; then
-	mv $4/System.map $4/System.old
+if [ -f $5/System.map ]; then
+	mv $5/System.map $5/System.old
 fi
 
-cat $2 > $4/vmlinuz
-cp $3 $4/System.map
+if [ -f $5/Kerntypes ]; then
+	mv $5/Kerntypes $5/Kerntypes.old
+fi
+
+cat $2 > $5/vmlinuz
+cp $3 $5/System.map
+
+# copy the kernel type file if it exists
+if [ -f $4 ]; then
+	cp $4 $5/Kerntypes
+fi
diff -Naur linux-2.6.0-test7.before/arch/s390/Kconfig linux-2.6.0-test7.after/arch/s390/Kconfig
--- linux-2.6.0-test7.before/arch/s390/Kconfig	2003-10-31 12:15:27.000000000 +0100
+++ linux-2.6.0-test7.after/arch/s390/Kconfig	2003-10-31 12:17:31.000000000 +0100
@@ -312,6 +312,15 @@
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 	  
+config CRASH_DUMP
+	bool "Crash dump support"
+	depends on DEBUG_KERNEL
+	default n
+	help
+	  Say Y here to enable saving an image of system memory when a
+	  panic or other error occurs. Dumps can also be forced with
+	  the SysRq+d key if MAGIC_SYSRQ is enabled.
+
 config DEBUG_SPINLOCK_SLEEP
 	bool "Sleep-inside-spinlock checking"
 	help
diff -Naur linux-2.6.0-test7.before/include/linux/dump.h linux-2.6.0-test7.after/include/linux/dump.h
--- linux-2.6.0-test7.before/include/linux/dump.h	2003-03-14 14:07:09.000000000 +0100
+++ linux-2.6.0-test7.after/include/linux/dump.h	2003-10-31 13:02:10.000000000 +0100
@@ -0,0 +1,380 @@
+/*
+ * Kernel header file for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ * Copyright 1999 - 2002 Silicon Graphics, Inc. All rights reserved.
+ *
+ * vmdump.h to dump.h by: Matt D. Robinson (yakker@sourceforge.net)
+ * Copyright 2001 - 2002 Matt D. Robinson.  All rights reserved.
+ * Copyright (C) 2002 Free Software Foundation, Inc. All rights reserved.
+ *
+ * Most of this is the same old stuff from vmdump.h, except now we're
+ * actually a stand-alone driver plugged into the block layer interface,
+ * with the exception that we now allow for compression modes externally
+ * loaded (e.g., someone can come up with their own).
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/* This header file includes all structure definitions for crash dumps. */
+#ifndef _DUMP_H
+#define _DUMP_H
+
+#if defined(CONFIG_CRASH_DUMP) || defined (CONFIG_CRASH_DUMP_MODULE)
+
+#include <linux/list.h>
+#include <linux/notifier.h>
+
+/*
+ * Structure: __lkcdinfo
+ * Function:  This structure contains information needed for the lkcdutils
+ *            package (particularly lcrash) to determine what information is
+ *            associated to this kernel, specifically.
+ */
+struct __lkcdinfo {
+	int	arch;
+	int	ptrsz;
+	int	byte_order;
+	int	linux_release;
+	int	page_shift;
+	int	page_size;
+	u64	page_mask;
+	u64	page_offset;
+	int	stack_offset;
+};
+
+/*
+ * We only need to include the rest of the file if one of the
+ * dump devices are enabled.
+ */
+#if defined(CONFIG_CRASH_BLOCKDEV) || defined(CONFIG_CRASH_BLOCKDEV_MODULE) \
+    defined(CONFIG_CRASH_NETDEV) || defined(CONFIG_CRASH_NETDEV_MODULE) \
+    defined(CONFIG_CRASH_MEMDEV) || defined(CONFIG_CRASH_MEMDEV_MODULE)
+
+#include <linux/dumpdev.h>
+
+/* 
+ * Predefine default DUMP_PAGE constants, asm header may override.
+ *
+ * On ia64 discontinuous memory systems it's possible for the memory
+ * banks to stop at 2**12 page alignments, the smallest possible page
+ * size. But the system page size, PAGE_SIZE, is in fact larger.
+ */
+#define DUMP_PAGE_SHIFT 	PAGE_SHIFT
+#define DUMP_PAGE_MASK		PAGE_MASK
+#define DUMP_PAGE_ALIGN(addr)	PAGE_ALIGN(addr)
+#define DUMP_HEADER_OFFSET	PAGE_SIZE
+
+#define OLDMINORBITS	8
+#define OLDMINORMASK	((1U << OLDMINORBITS) -1)
+
+/* keep DUMP_PAGE_SIZE constant to 4K = 1<<12
+ * it may be different from PAGE_SIZE then.
+ */
+#define DUMP_PAGE_SIZE		4096
+
+/* 
+ * Predefined default memcpy() to use when copying memory to the dump buffer.
+ *
+ * On ia64 there is a heads up function that can be called to let the prom
+ * machine check monitor know that the current activity is risky and it should
+ * ignore the fault (nofault). In this case the ia64 header will redefine this
+ * macro to __dump_memcpy() and use it's arch specific version.
+ */
+#define DUMP_memcpy		memcpy
+
+/* necessary header files */
+#include <asm/dump.h>			/* for architecture-specific header */
+
+/* 
+ * Size of the buffer that's used to hold:
+ *
+ *	1. the dump header (padded to fill the complete buffer)
+ *	2. the possibly compressed page headers and data
+ */
+#define DUMP_BUFFER_SIZE	(64 * 1024)  /* size of dump buffer         */
+#define DUMP_HEADER_SIZE	DUMP_BUFFER_SIZE
+
+/* standard header definitions */
+#define DUMP_MAGIC_NUMBER	0xa8190173618f23edULL  /* dump magic number */
+#define DUMP_MAGIC_LIVE		0xa8190173618f23cdULL  /* live magic number */
+#define DUMP_VERSION_NUMBER	0x8	/* dump version number              */
+#define DUMP_PANIC_LEN		0x100	/* dump panic string length         */
+
+/* dump levels - type specific stuff added later -- add as necessary */
+#define DUMP_LEVEL_NONE		0x0	/* no dumping at all -- just bail   */
+#define DUMP_LEVEL_HEADER	0x1	/* kernel dump header only          */
+#define DUMP_LEVEL_KERN		0x2	/* dump header and kernel pages     */
+#define DUMP_LEVEL_USED		0x4	/* dump header, kernel/user pages   */
+#define DUMP_LEVEL_ALL_RAM	0x8	/* dump header, all RAM pages       */
+#define DUMP_LEVEL_ALL		0x10	/* dump all memory RAM and firmware */
+
+
+/* dump compression options -- add as necessary */
+#define DUMP_COMPRESS_NONE	0x0	/* don't compress this dump         */
+#define DUMP_COMPRESS_RLE	0x1	/* use RLE compression              */
+#define DUMP_COMPRESS_GZIP	0x2	/* use GZIP compression             */
+
+/* dump flags - any dump-type specific flags -- add as necessary */
+#define DUMP_FLAGS_NONE		0x0	/* no flags are set for this dump   */
+#define DUMP_FLAGS_SOFTBOOT	0x2	/* 2 stage soft-boot based dump	    */
+
+#define DUMP_FLAGS_TARGETMASK	0xf0000000 /* handle special case targets   */
+#define DUMP_FLAGS_DISKDUMP	0x80000000 /* dump to local disk 	    */
+#define DUMP_FLAGS_NETDUMP	0x40000000 /* dump over the network         */
+
+/* dump header flags -- add as necessary */
+#define DUMP_DH_FLAGS_NONE	0x0	/* no flags set (error condition!)  */
+#define DUMP_DH_RAW		0x1	/* raw page (no compression)        */
+#define DUMP_DH_COMPRESSED	0x2	/* page is compressed               */
+#define DUMP_DH_END		0x4	/* end marker on a full dump        */
+#define DUMP_DH_TRUNCATED	0x8	/* dump is incomplete               */
+#define DUMP_DH_TEST_PATTERN	0x10	/* dump page is a test pattern      */
+#define DUMP_DH_NOT_USED	0x20	/* 1st bit not used in flags        */
+
+/* names for various dump parameters in /proc/kernel */
+#define DUMP_ROOT_NAME		"sys/dump"
+#define DUMP_DEVICE_NAME	"device"
+#define DUMP_COMPRESS_NAME	"compress"
+#define DUMP_LEVEL_NAME		"level"
+#define DUMP_FLAGS_NAME		"flags"
+#define DUMP_ADDR_NAME		"addr"
+
+#define DUMP_SYSRQ_KEY		'd'	/* key to use for MAGIC_SYSRQ key   */
+
+/* CTL_DUMP names: */
+enum
+{
+	CTL_DUMP_DEVICE=1,
+	CTL_DUMP_COMPRESS=3,
+	CTL_DUMP_LEVEL=3,
+	CTL_DUMP_FLAGS=4,
+	CTL_DUMP_ADDR=5,
+	CTL_DUMP_TEST=6,
+};
+
+
+/* page size for gzip compression -- buffered slightly beyond hardware PAGE_SIZE used by DUMP */
+#define DUMP_DPC_PAGE_SIZE	(DUMP_PAGE_SIZE + 512)
+
+/* dump ioctl() control options */
+#define DIOSDUMPDEV		1	/* set the dump device              */
+#define DIOGDUMPDEV		2	/* get the dump device              */
+#define DIOSDUMPLEVEL		3	/* set the dump level               */
+#define DIOGDUMPLEVEL		4	/* get the dump level               */
+#define DIOSDUMPFLAGS		5	/* set the dump flag parameters     */
+#define DIOGDUMPFLAGS		6	/* get the dump flag parameters     */
+#define DIOSDUMPCOMPRESS	7	/* set the dump compress level      */
+#define DIOGDUMPCOMPRESS	8	/* get the dump compress level      */
+
+/* these ioctls are used only by netdump module */
+#define DIOSTARGETIP		9	/* set the target m/c's ip	    */
+#define DIOGTARGETIP		10	/* get the target m/c's ip	    */
+#define DIOSTARGETPORT		11	/* set the target m/c's port	    */
+#define DIOGTARGETPORT		12	/* get the target m/c's port	    */
+#define DIOSSOURCEPORT		13	/* set the source m/c's port	    */
+#define DIOGSOURCEPORT		14	/* get the source m/c's port	    */
+#define DIOSETHADDR		15	/* set ethernet address		    */
+#define DIOGETHADDR		16	/* get ethernet address		    */
+
+/*
+ * Structure: __dump_header
+ *  Function: This is the header dumped at the top of every valid crash
+ *            dump.  
+ */
+struct __dump_header {
+	/* the dump magic number -- unique to verify dump is valid */
+	u64	dh_magic_number;
+
+	/* the version number of this dump */
+	u32	dh_version;
+
+	/* the size of this header (in case we can't read it) */
+	u32	dh_header_size;
+
+	/* the level of this dump (just a header?) */
+	u32	dh_dump_level;
+
+	/* 
+	 * We assume dump_page_size to be 4K in every case.
+	 * Store here the configurable system page size (4K, 8K, 16K, etc.) 
+	 */
+	u32	dh_page_size;
+
+	/* the size of all physical memory */
+	u64	dh_memory_size;
+
+	/* the start of physical memory */
+	u64	dh_memory_start;
+
+	/* the end of physical memory */
+	u64	dh_memory_end;
+
+	/* the number of hardware/physical pages in this dump specifically */
+	u32	dh_num_dump_pages;
+
+	/* the panic string, if available */
+	char	dh_panic_string[DUMP_PANIC_LEN];
+
+	/* timeval depends on architecture, two long values */
+	struct {
+		u64 tv_sec;
+		u64 tv_usec;
+	} dh_time; /* the time of the system crash */
+
+	/* the NEW utsname (uname) information -- in character form */
+	/* we do this so we don't have to include utsname.h         */
+	/* plus it helps us be more architecture independent        */
+	/* now maybe one day soon they'll make the [65] a #define!  */
+	char	dh_utsname_sysname[65];
+	char	dh_utsname_nodename[65];
+	char	dh_utsname_release[65];
+	char	dh_utsname_version[65];
+	char	dh_utsname_machine[65];
+	char	dh_utsname_domainname[65];
+
+	/* the address of current task (OLD = void *, NEW = u64) */
+	u64	dh_current_task;
+
+	/* what type of compression we're using in this dump (if any) */
+	u32	dh_dump_compress;
+
+	/* any additional flags */
+	u32	dh_dump_flags;
+
+	/* any additional flags */
+	u32	dh_dump_device;
+} __attribute__((packed));
+
+/*
+ * Structure: __dump_page
+ *  Function: To act as the header associated to each physical page of
+ *            memory saved in the system crash dump.  This allows for
+ *            easy reassembly of each crash dump page.  The address bits
+ *            are split to make things easier for 64-bit/32-bit system
+ *            conversions.
+ *
+ * dp_byte_offset and dp_page_index are landmarks that are helpful when
+ * looking at a hex dump of /dev/vmdump,
+ */
+struct __dump_page {
+	/* the address of this dump page */
+	u64	dp_address;
+
+	/* the size of this dump page */
+	u32	dp_size;
+
+	/* flags (currently DUMP_COMPRESSED, DUMP_RAW or DUMP_END) */
+	u32	dp_flags;
+} __attribute__((packed));
+
+#ifdef __KERNEL__
+
+/*
+ * Structure: __dump_compress
+ *  Function: This is what an individual compression mechanism can use
+ *            to plug in their own compression techniques.  It's always
+ *            best to build these as individual modules so that people
+ *            can put in whatever they want.
+ */
+struct __dump_compress {
+	/* the list_head structure for list storage */
+	struct list_head list;
+
+	/* the type of compression to use (DUMP_COMPRESS_XXX) */
+	int compress_type;
+	const char *compress_name;
+
+	/* the compression function to call */
+	u16 (*compress_func)(const u8 *, u16, u8 *, u16);
+};
+
+/* functions for dump compression registration */
+extern void dump_register_compression(struct __dump_compress *);
+extern void dump_unregister_compression(int);
+
+/*
+ * Structure dump_mbank[]:
+ *
+ * For CONFIG_DISCONTIGMEM systems this array specifies the
+ * memory banks/chunks that need to be dumped after a panic.
+ *
+ * For classic systems it specifies a single set of pages from
+ * 0 to max_mapnr.
+ */
+struct __dump_mbank {
+	u64 	start;
+	u64 	end;
+	int	type;
+	int	pad1;
+	long	pad2;
+};
+
+#define DUMP_MBANK_TYPE_CONVENTIONAL_MEMORY		1
+#define DUMP_MBANK_TYPE_OTHER				2
+
+#define MAXCHUNKS 256
+extern int dump_mbanks;
+extern struct __dump_mbank dump_mbank[MAXCHUNKS];
+
+/* notification event codes */
+#define DUMP_BEGIN		0x0001	/* dump beginning */
+#define DUMP_END		0x0002	/* dump ending */
+
+/* Scheduler soft spin control.
+ *
+ * 0 - no dump in progress
+ * 1 - cpu0 is dumping, ...
+ */
+extern unsigned long dump_oncpu;
+extern void dump_execute(const char *, const struct pt_regs *);
+
+/*
+ *	Notifier list for kernel code which wants to be called
+ *	at kernel dump. 
+ */
+extern struct notifier_block *dump_notifier_list;
+static inline int register_dump_notifier(struct notifier_block *nb)
+{
+	return notifier_chain_register(&dump_notifier_list, nb);
+}
+static inline int unregister_dump_notifier(struct notifier_block * nb)
+{
+	return notifier_chain_unregister(&dump_notifier_list, nb);
+}
+
+extern void (*dump_function_ptr)(const char *, const struct pt_regs *);
+static inline void dump(char * str, struct pt_regs * regs)
+{
+	if (dump_function_ptr)
+		dump_function_ptr(str, regs);
+}
+
+/*
+ * Common Arch Specific Functions should be declared here.
+ * This allows the C compiler to detect discrepancies.
+ */
+extern void	__dump_open(void);
+extern void	__dump_cleanup(void);
+extern void	__dump_init(u64);
+extern void	__dump_save_regs(struct pt_regs *, const struct pt_regs *);
+extern int	__dump_configure_header(const struct pt_regs *);
+extern void	__dump_irq_enable(void);
+extern void	__dump_irq_restore(void);
+extern int	__dump_page_valid(unsigned long index);
+#ifdef CONFIG_SMP
+extern void 	__dump_save_other_cpus(void);
+#else
+#define 	__dump_save_other_cpus()
+#endif
+
+/* to track all used (compound + zero order) pages */
+#define PageInuse(p)   (PageCompound(p) || page_count(p))
+
+#endif /* __KERNEL__ */
+
+#endif /* CONFIG_CRASH_XXXDEV */
+
+#endif	/* CONFIG_CRASH_DUMP */
+
+#endif /* _DUMP_H */
