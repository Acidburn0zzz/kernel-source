From: Intel
Subject: IOAT: Mark ioatdma unsafe to unload
References: 142510

The locking fixes ensure that the system will not panic on unload, but
rmmod can hang if there are outstanding references to the dmaengine held
by block socket reads.  Calling rmmod with the force flag (-f) will result
in the previous behavior, it should work but in some cases will hang.

Acked-by: okir@suse.de

diff -u
--- linux-2.6.15-20060109195850.ioat.40/drivers/dma/ioatdma.c	2006-01-11 06:48:04.000000000 -0800
+++ linux-2.6.15-20060109195850.ioat.42/drivers/dma/ioatdma.c	2006-01-17 07:03:50.000000000 -0800
@@ -673,12 +673,13 @@ static void __devexit cb_remove(struct p
 	struct cb_device *device;
 
 	device = pci_get_drvdata(pdev);
+	dma_async_device_unregister(&device->common);
+
 	free_irq(device->pdev->irq, device);
 #ifdef CONFIG_PCI_MSI
 	if (device->msi)
 		pci_disable_msi(device->pdev);
 #endif
-	dma_async_device_unregister(&device->common);
 	dma_pool_destroy(device->dma_pool);
 	iounmap(device->reg_base);
 	pci_release_regions(pdev);
@@ -686,12 +687,15 @@ static void __devexit cb_remove(struct p
 }
 
 /* MODULE API */
-MODULE_VERSION("0.40");
+MODULE_VERSION("0.42");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Intel Corporation");
 
 static int __init cb_init_module(void)
 {
+	/* it's currently unsafe to unload this module */
+	/* if forced, worst case is that rmmod hangs */
+	THIS_MODULE->unsafe = 1;
 	return pci_module_init(&cb_pci_drv);
 }
 
