wait_on_page_writeback_range tried to return a count of the
number of bytes it managed to wait on before hitting -EIOCBRETRY.
The math was off though, leading to the possibility of telling
the aio subsystem all waiting was finished before it really was.

Since there is no easy way to turn a page index into the correct
number of bytes, this patch just removes the optimization entirely.

Index: linux.t/mm/filemap.c
===================================================================
--- linux.t.orig/mm/filemap.c	2004-08-13 10:42:08.035344032 -0400
+++ linux.t/mm/filemap.c	2004-08-13 10:53:37.522526048 -0400
@@ -216,7 +216,7 @@ static ssize_t wait_on_page_writeback_ra
 	struct pagevec pvec;
 	int nr_pages;
 	int ret = 0, done = 0;
-	pgoff_t index, curr = start;
+	pgoff_t index;
 
 	if (end < start)
 		return 0;
@@ -235,17 +235,10 @@ static ssize_t wait_on_page_writeback_ra
 			if (page->index > end) {
 				continue;
 			}
-			lock_page(page);
-			if (unlikely(page->mapping != mapping)) {
-				unlock_page(page);
+			if (unlikely(page->mapping != mapping))
 				continue;
-                       }
-			curr = page->index;
-			unlock_page(page);
 			ret = wait_on_page_writeback_wq(page, wait);
 			if (ret == -EIOCBRETRY) {
-				if (curr > start)
-					ret = curr - start;
 				done = 1;
 				break;
 			}
