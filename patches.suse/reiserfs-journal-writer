%patch
Index: linux.log/fs/reiserfs/journal.c
===================================================================
--- linux.log.orig/fs/reiserfs/journal.c	2004-01-09 01:59:44.000000000 -0500
+++ linux.log/fs/reiserfs/journal.c	2004-01-15 17:23:30.000000000 -0500
@@ -405,7 +405,6 @@
 #ifdef CONFIG_SMP
   if (current->lock_depth < 0) {
     printk("%s called without kernel lock held\n", caller) ;
-    show_reiserfs_locks() ;
     BUG() ;
   }
 #else
@@ -441,52 +440,6 @@
   return cn ;
 }
 
-/* once upon a time, the journal would deadlock.  a lot.  Now, when
-** CONFIG_REISERFS_CHECK is defined, anytime someone enters a
-** transaction, it pushes itself into this ugly static list, and pops
-** itself off before calling journal_end.  I made a SysRq key to dump
-** the list, and tell me what the writers are when I'm deadlocked.  */
-
-				/* are you depending on the compiler
-                                   to optimize this function away
-                                   everywhere it is called? It is not
-                                   obvious how this works, but I
-                                   suppose debugging code need not be
-                                   clear.  -Hans */
-static char *journal_writers[512] ;
-int push_journal_writer(char *s) {
-#ifdef CONFIG_REISERFS_CHECK
-  int i ;
-  for (i = 0 ; i < 512 ; i++) {
-    if (!journal_writers[i]) {
-      journal_writers[i] = s ;
-      return i ;
-    }
-  }
-  return -1 ;
-#else
-  return 0 ;
-#endif
-}
-int pop_journal_writer(int index) {
-#ifdef CONFIG_REISERFS_CHECK
-  if (index >= 0) {
-    journal_writers[index] = NULL ;
-  }
-#endif
-  return 0 ;
-}
-
-int dump_journal_writers(void) {
-  int i ;
-  for (i = 0 ; i < 512 ; i++) {
-    if (journal_writers[i]) {
-      printk("%d: %s\n", i, journal_writers[i]) ;
-    }
-  }
-  return 0 ;
-}
-
 /*
 ** this actually means 'can this block be reallocated yet?'.  If you set search_all, a block can only be allocated
 ** if it is not in the current transaction, was not freed by the current transaction, and has no chance of ever
@@ -2097,7 +2050,6 @@
   journal_list_init(p_s_sb) ;
 
   memset(SB_JOURNAL(p_s_sb)->j_list_hash_table, 0, JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *)) ;
-  memset(journal_writers, 0, sizeof(char *) * 512) ; /* debug code */
 
   INIT_LIST_HEAD(&SB_JOURNAL(p_s_sb)->j_dirty_buffers) ;
   spin_lock_init(&SB_JOURNAL(p_s_sb)->j_dirty_buffers_lock) ;
@@ -2334,7 +2286,6 @@
                             buffer_locked(bh) ? ' ' : '!',
 			    buffer_dirty(bh) ? ' ' : '!',
 			    buffer_journal_dirty(bh) ? ' ' : '!') ;
-    show_reiserfs_locks() ;
   }
   count_already_incd = clear_prepared_bits(bh) ;
 
@@ -2529,12 +2480,6 @@
   return do_journal_end(th, p_s_sb, nblocks, COMMIT_NOW | WAIT) ;
 }
 
-int show_reiserfs_locks(void) {
-
-  dump_journal_writers() ;
-  return 0 ;
-}
-
 /*
 ** used to get memory back from async commits that are floating around
 ** and to reclaim any blocks deleted but unusable because their commits
Index: linux.log/fs/reiserfs/namei.c
===================================================================
--- linux.log.orig/fs/reiserfs/namei.c	2004-01-09 01:59:44.000000000 -0500
+++ linux.log/fs/reiserfs/namei.c	2004-01-15 17:23:30.000000000 -0500
@@ -738,7 +738,6 @@
 {
     int retval;
     struct inode * inode;
-    int windex ;
     struct reiserfs_transaction_handle th ;
     int jbegin_count; 
     INITIALIZE_PATH (path);
@@ -750,7 +749,6 @@
 
     reiserfs_write_lock(dir->i_sb);
     journal_begin(&th, dir->i_sb, jbegin_count) ;
-    windex = push_journal_writer("reiserfs_rmdir") ;
 
     de.de_gen_number_bit_string = 0;
     if ( (retval = reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path, &de)) == NAME_NOT_FOUND) {
@@ -799,7 +797,6 @@
     /* prevent empty directory from getting lost */
     add_save_link (&th, inode, 0/* not truncate */);
 
-    pop_journal_writer(windex) ;
     journal_end(&th, dir->i_sb, jbegin_count) ;
     reiserfs_check_path(&path) ;
     reiserfs_write_unlock(dir->i_sb);
@@ -810,7 +807,6 @@
        reiserfs_cut_from_item, or reiserfs_cut_from_item does not
        release path if operation was not complete */
     pathrelse (&path);
-    pop_journal_writer(windex) ;
     journal_end(&th, dir->i_sb, jbegin_count) ;
     reiserfs_write_unlock(dir->i_sb);
     return retval;	
@@ -822,7 +818,6 @@
     struct inode * inode;
     struct reiserfs_dir_entry de;
     INITIALIZE_PATH (path);
-    int windex ;
     struct reiserfs_transaction_handle th ;
     int jbegin_count;
     unsigned long savelink;
@@ -835,7 +830,6 @@
 
     reiserfs_write_lock(dir->i_sb);
     journal_begin(&th, dir->i_sb, jbegin_count) ;
-    windex = push_journal_writer("reiserfs_unlink") ;
 	
     de.de_gen_number_bit_string = 0;
     if ( (retval = reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path, &de)) == NAME_NOT_FOUND) {
@@ -888,7 +882,6 @@
        /* prevent file from getting lost */
        add_save_link (&th, inode, 0/* not truncate */);
 
-    pop_journal_writer(windex) ;
     journal_end(&th, dir->i_sb, jbegin_count) ;
     reiserfs_check_path(&path) ;
     reiserfs_write_unlock(dir->i_sb);
@@ -896,7 +889,6 @@
 
  end_unlink:
     pathrelse (&path);
-    pop_journal_writer(windex) ;
     journal_end(&th, dir->i_sb, jbegin_count) ;
     reiserfs_check_path(&path) ;
     reiserfs_write_unlock(dir->i_sb);
@@ -979,7 +971,6 @@
 {
     int retval;
     struct inode *inode = old_dentry->d_inode;
-    int windex ;
     struct reiserfs_transaction_handle th ;
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
 
@@ -997,7 +988,6 @@
     inode->i_nlink++;
 
     journal_begin(&th, dir->i_sb, jbegin_count) ;
-    windex = push_journal_writer("reiserfs_link") ;
 
     /* create new entry */
     retval = reiserfs_add_entry (&th, dir, dentry->d_name.name, dentry->d_name.len,
@@ -1008,7 +998,6 @@
 
     if (retval) {
 	inode->i_nlink--;
-	pop_journal_writer(windex) ;
 	journal_end(&th, dir->i_sb, jbegin_count) ;
 	reiserfs_write_unlock(dir->i_sb);
 	return retval;
@@ -1019,7 +1008,6 @@
 
     atomic_inc(&inode->i_count) ;
     d_instantiate(dentry, inode);
-    pop_journal_writer(windex) ;
     journal_end(&th, dir->i_sb, jbegin_count) ;
     reiserfs_write_unlock(dir->i_sb);
     return 0;
@@ -1083,7 +1071,6 @@
     struct item_head new_entry_ih, old_entry_ih, dot_dot_ih ;
     struct reiserfs_dir_entry old_de, new_de, dot_dot_de;
     struct inode * old_inode, * new_dentry_inode;
-    int windex ;
     struct reiserfs_transaction_handle th ;
     int jbegin_count ; 
     umode_t old_inode_mode;
@@ -1151,7 +1138,6 @@
     }
 
     journal_begin(&th, old_dir->i_sb, jbegin_count) ;
-    windex = push_journal_writer("reiserfs_rename") ;
 
     /* add new entry (or find the existing one) */
     retval = reiserfs_add_entry (&th, new_dir, new_dentry->d_name.name, new_dentry->d_name.len, 
@@ -1162,7 +1148,6 @@
 			    "vs-7050: new entry is found, new inode == 0\n");
 	}
     } else if (retval) {
-	pop_journal_writer(windex) ;
 	journal_end(&th, old_dir->i_sb, jbegin_count) ;
 	reiserfs_write_unlock(old_dir->i_sb);
 	return retval;
@@ -1315,14 +1300,11 @@
 	reiserfs_update_sd (&th, new_dentry_inode);
     }
 
-    pop_journal_writer(windex) ;
     journal_end(&th, old_dir->i_sb, jbegin_count) ;
     reiserfs_write_unlock(old_dir->i_sb);
     return 0;
 }
 
-
-
 /*
  * directories can handle most operations...
  */
Index: linux.log/fs/reiserfs/file.c
===================================================================
--- linux.log.orig/fs/reiserfs/file.c	2004-01-09 01:59:04.000000000 -0500
+++ linux.log/fs/reiserfs/file.c	2004-01-15 17:23:30.000000000 -0500
@@ -28,7 +28,6 @@
 {
 
     struct reiserfs_transaction_handle th ;
-    int windex ;
 
     if (!S_ISREG (inode->i_mode))
 	BUG ();
@@ -58,9 +57,7 @@
 	   appended (we append by unformatted node only) or its direct
 	   item(s) had to be converted, then it may have to be
 	   indirect2direct converted */
-	windex = push_journal_writer("file_release") ;
 	reiserfs_truncate_file(inode, 0) ;
-	pop_journal_writer(windex) ;
     }
     up (&inode->i_sem); 
     reiserfs_write_unlock(inode->i_sb);
Index: linux.log/fs/reiserfs/prints.c
===================================================================
--- linux.log.orig/fs/reiserfs/prints.c	2004-01-09 01:59:45.000000000 -0500
+++ linux.log/fs/reiserfs/prints.c	2004-01-15 17:23:30.000000000 -0500
@@ -333,7 +333,6 @@
 
 void reiserfs_panic (struct super_block * sb, const char * fmt, ...)
 {
-  show_reiserfs_locks() ;
   do_reiserfs_warning(fmt);
   printk ( KERN_EMERG "%s", error_buf);
   BUG ();
Index: linux.log/fs/reiserfs/fix_node.c
===================================================================
--- linux.log.orig/fs/reiserfs/fix_node.c	2004-01-09 01:59:19.000000000 -0500
+++ linux.log/fs/reiserfs/fix_node.c	2004-01-15 17:23:30.000000000 -0500
@@ -2280,7 +2280,6 @@
     ** during wait_tb_buffers_run
     */
     int wait_tb_buffers_run = 0 ; 
-    int windex ;
     struct buffer_head  * p_s_tbS0 = PATH_PLAST_BUFFER(p_s_tb->tb_path);
 
     ++ REISERFS_SB(p_s_tb -> tb_sb) -> s_fix_nodes;
@@ -2407,10 +2406,7 @@
 		p_s_tb->insert_size[n_h + 1] = (DC_SIZE + KEY_SIZE) * (p_s_tb->blknum[n_h] - 1);
     }
 
-    
-    windex = push_journal_writer("fix_nodes") ;
     if ((n_ret_value = wait_tb_buffers_until_unlocked (p_s_tb)) == CARRY_ON) {
-	pop_journal_writer(windex) ;
 	if (FILESYSTEM_CHANGED_TB(p_s_tb)) {
 	    wait_tb_buffers_run = 1 ;
 	    n_ret_value = REPEAT_SEARCH ;
@@ -2420,7 +2416,6 @@
 	}
     } else {
 	wait_tb_buffers_run = 1 ;
-	pop_journal_writer(windex) ;
 	goto repeat; 
     }
 
Index: linux.log/fs/reiserfs/inode.c
===================================================================
--- linux.log.orig/fs/reiserfs/inode.c	2004-01-09 01:59:19.000000000 -0500
+++ linux.log/fs/reiserfs/inode.c	2004-01-15 17:23:30.000000000 -0500
@@ -29,9 +29,7 @@
 void reiserfs_delete_inode (struct inode * inode)
 {
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 2; 
-    int windex ;
     struct reiserfs_transaction_handle th ;
-
   
     reiserfs_write_lock(inode->i_sb);
 
@@ -41,10 +39,8 @@
 
 	journal_begin(&th, inode->i_sb, jbegin_count) ;
 	reiserfs_update_inode_transaction(inode) ;
-	windex = push_journal_writer("delete_inode") ;
 
 	reiserfs_delete_object (&th, inode);
-	pop_journal_writer(windex) ;
 
 	journal_end(&th, inode->i_sb, jbegin_count) ;
 
@@ -557,7 +553,6 @@
     __u32 * item;
     int done;
     int fs_gen;
-    int windex ;
     struct reiserfs_transaction_handle th ;
     /* space reserved in transaction batch: 
         . 3 balancings in direct->indirect conversion
@@ -603,8 +598,6 @@
 	 (have_small_tails (inode->i_sb) && inode->i_size < i_block_size(inode)) )
 	REISERFS_I(inode)->i_flags |= i_pack_on_close_mask ;
 
-    windex = push_journal_writer("reiserfs_get_block") ;
-  
     /* set the key of the first byte in the 'block'-th block of file */
     make_cpu_key (&key, inode, new_offset,
 		  TYPE_ANY, 3/*key length*/);
@@ -683,7 +676,6 @@
 	}
 	set_block_dev_mapped(bh_result, unfm_ptr, inode);
 	pathrelse (&path);
-	pop_journal_writer(windex) ;
 	if (transaction_started)
 	    journal_end(&th, inode->i_sb, jbegin_count) ;
 
@@ -929,7 +921,6 @@
       reiserfs_update_sd(&th, inode) ;
       journal_end(&th, inode->i_sb, jbegin_count) ;
     }
-    pop_journal_writer(windex) ;
     reiserfs_write_unlock(inode->i_sb);
     reiserfs_check_path(&path) ;
     return retval;
@@ -1832,7 +1823,6 @@
 */
 void reiserfs_truncate_file(struct inode *p_s_inode, int update_timestamps) {
     struct reiserfs_transaction_handle th ;
-    int windex ;
     /* we want the offset for the first byte after the end of the file */
     unsigned long offset = p_s_inode->i_size & (PAGE_CACHE_SIZE - 1) ;
     unsigned blocksize = p_s_inode->i_sb->s_blocksize ;
@@ -1867,14 +1857,12 @@
        cut_from_item. 1 is for update_sd */
     journal_begin(&th, p_s_inode->i_sb,  JOURNAL_PER_BALANCE_CNT * 2 + 1 ) ;
     reiserfs_update_inode_transaction(p_s_inode) ;
-    windex = push_journal_writer("reiserfs_vfs_truncate_file") ;
     if (update_timestamps)
 	    /* we are doing real truncate: if the system crashes before the last
 	       transaction of truncating gets committed - on reboot the file
 	       either appears truncated properly or not truncated at all */
 	add_save_link (&th, p_s_inode, 1);
     reiserfs_do_truncate (&th, p_s_inode, page, update_timestamps) ;
-    pop_journal_writer(windex) ;
     journal_end(&th, p_s_inode->i_sb,  JOURNAL_PER_BALANCE_CNT * 2 + 1 ) ;
 
     if (update_timestamps)
Index: linux.log/fs/reiserfs/do_balan.c
===================================================================
--- linux.log.orig/fs/reiserfs/do_balan.c	2004-01-09 01:59:10.000000000 -0500
+++ linux.log/fs/reiserfs/do_balan.c	2004-01-15 17:23:30.000000000 -0500
@@ -54,9 +54,7 @@
 	    tb->need_balance_dirty = 1;
 	}
     } else {
-	int windex = push_journal_writer("do_balance") ;
 	journal_mark_dirty(tb->transaction_handle, tb->transaction_handle->t_super, bh) ;
-	pop_journal_writer(windex) ;
     }
 }
 
Index: linux.log/include/linux/reiserfs_fs_sb.h
===================================================================
--- linux.log.orig/include/linux/reiserfs_fs_sb.h	2004-01-09 01:59:41.000000000 -0500
+++ linux.log/include/linux/reiserfs_fs_sb.h	2004-01-15 17:23:30.000000000 -0500
@@ -471,7 +471,6 @@
 extern struct file_system_type reiserfs_fs_type;
 int journal_mark_dirty(struct reiserfs_transaction_handle *, struct super_block *, struct buffer_head *bh) ;
 int flush_old_commits(struct super_block *s, int) ;
-int show_reiserfs_locks(void) ;
 int reiserfs_resize(struct super_block *, unsigned long) ;
 
 #define CARRY_ON                0
Index: linux.log/include/linux/reiserfs_fs.h
===================================================================
--- linux.log.orig/include/linux/reiserfs_fs.h	2004-01-09 02:00:02.000000000 -0500
+++ linux.log/include/linux/reiserfs_fs.h	2004-01-15 17:23:30.000000000 -0500
@@ -1726,8 +1726,6 @@
 int journal_end_sync(struct reiserfs_transaction_handle *, struct super_block *, unsigned long) ;
 int journal_mark_dirty_nolog(struct reiserfs_transaction_handle *, struct super_block *, struct buffer_head *bh) ;
 int journal_mark_freed(struct reiserfs_transaction_handle *, struct super_block *, b_blocknr_t blocknr) ;
-int push_journal_writer(char *w) ;
-int pop_journal_writer(int windex) ;
 int journal_transaction_should_end(struct reiserfs_transaction_handle *, int) ;
 int reiserfs_in_journal(struct super_block *p_s_sb, int bmap_nr, int bit_nr, int searchall, b_blocknr_t *next) ;
 int journal_begin(struct reiserfs_transaction_handle *, struct super_block *p_s_sb, unsigned long) ;

