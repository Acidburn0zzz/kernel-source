From: Patrick McHardy, Christophe Saout
Subject: nat over ipsec

The updated ipsec-04-policy-checks.diff

Acked-by: mason@suse.com

Index: linux.h/net/xfrm/xfrm_policy.c
===================================================================
--- linux.h.orig/net/xfrm/xfrm_policy.c	2005-02-17 17:20:09.000000000 -0500
+++ linux.h/net/xfrm/xfrm_policy.c	2005-02-18 14:53:18.000000000 -0500
@@ -21,6 +21,7 @@
 #include <linux/workqueue.h>
 #include <linux/notifier.h>
 #include <linux/netdevice.h>
+#include <linux/netfilter.h>
 #include <linux/module.h>
 #include <net/xfrm.h>
 #include <net/ip.h>
@@ -43,8 +44,8 @@ static struct list_head xfrm_policy_gc_l
 	LIST_HEAD_INIT(xfrm_policy_gc_list);
 static DEFINE_SPINLOCK(xfrm_policy_gc_lock);
 
-static struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family);
-static void xfrm_policy_put_afinfo(struct xfrm_policy_afinfo *afinfo);
+struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family);
+void xfrm_policy_put_afinfo(struct xfrm_policy_afinfo *afinfo);
 
 int xfrm_register_type(struct xfrm_type *type, unsigned short family)
 {
@@ -931,6 +932,7 @@ int __xfrm_policy_check(struct sock *sk,
 
 	if (_decode_session(skb, &fl, family) < 0)
 		return 0;
+	nf_nat_decode_session(skb, &fl, family);
 
 	/* First, check used SA against their selectors. */
 	if (skb->sp) {
@@ -1225,7 +1227,7 @@ int xfrm_policy_unregister_afinfo(struct
 }
 EXPORT_SYMBOL(xfrm_policy_unregister_afinfo);
 
-static struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family)
+struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family)
 {
 	struct xfrm_policy_afinfo *afinfo;
 	if (unlikely(family >= NPROTO))
@@ -1237,13 +1239,15 @@ static struct xfrm_policy_afinfo *xfrm_p
 	read_unlock(&xfrm_policy_afinfo_lock);
 	return afinfo;
 }
+EXPORT_SYMBOL(xfrm_policy_get_afinfo);
 
-static void xfrm_policy_put_afinfo(struct xfrm_policy_afinfo *afinfo)
+void xfrm_policy_put_afinfo(struct xfrm_policy_afinfo *afinfo)
 {
 	if (unlikely(afinfo == NULL))
 		return;
 	read_unlock(&afinfo->lock);
 }
+EXPORT_SYMBOL(xfrm_policy_put_afinfo);
 
 static int xfrm_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
 {
Index: linux.h/net/ipv4/udp.c
===================================================================
--- linux.h.orig/net/ipv4/udp.c	2005-02-17 17:19:57.000000000 -0500
+++ linux.h/net/ipv4/udp.c	2005-02-18 14:47:55.000000000 -0500
@@ -997,6 +997,7 @@ static int udp_queue_rcv_skb(struct sock
 		kfree_skb(skb);
 		return -1;
 	}
+	nf_reset(skb);
 
 	if (up->encap_type) {
 		/*
@@ -1162,6 +1163,7 @@ int udp_rcv(struct sk_buff *skb)
 
 	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
 		goto drop;
+	nf_reset(skb);
 
 	/* No socket. Drop packet silently, if checksum is wrong */
 	if (udp_checksum_complete(skb))
Index: linux.h/net/ipv4/tcp_ipv4.c
===================================================================
--- linux.h.orig/net/ipv4/tcp_ipv4.c	2005-02-17 17:19:57.000000000 -0500
+++ linux.h/net/ipv4/tcp_ipv4.c	2005-02-18 14:47:55.000000000 -0500
@@ -1771,6 +1771,7 @@ process:
 
 	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
 		goto discard_and_relse;
+	nf_reset(skb);
 
 	if (sk_filter(sk, skb, 0))
 		goto discard_and_relse;
Index: linux.h/net/ipv4/raw.c
===================================================================
--- linux.h.orig/net/ipv4/raw.c	2005-02-18 14:43:36.000000000 -0500
+++ linux.h/net/ipv4/raw.c	2005-02-18 14:47:55.000000000 -0500
@@ -252,6 +252,7 @@ int raw_rcv(struct sock *sk, struct sk_b
 		kfree_skb(skb);
 		return NET_RX_DROP;
 	}
+	nf_reset(skb);
 
 	skb_push(skb, skb->data - skb->nh.raw);
 
Index: linux.h/net/ipv4/ip_input.c
===================================================================
--- linux.h.orig/net/ipv4/ip_input.c	2005-02-18 14:47:51.000000000 -0500
+++ linux.h/net/ipv4/ip_input.c	2005-02-18 14:47:55.000000000 -0500
@@ -206,10 +206,6 @@ static inline int ip_local_deliver_finis
 
 	__skb_pull(skb, ihl);
 
-	/* Free reference early: we don't need it any more, and it may
-           hold ip_conntrack module loaded indefinitely. */
-	nf_reset(skb);
-
         /* Point into the IP datagram, just past the header. */
         skb->h.raw = skb->data;
 
@@ -240,10 +236,12 @@ static inline int ip_local_deliver_finis
 		if (ipprot != NULL) {
 			int ret;
 
-			if (!ipprot->no_policy &&
-			    !xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
-				kfree_skb(skb);
-				goto out;
+			if (!ipprot->no_policy) {
+				if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
+					kfree_skb(skb);
+					goto out;
+				}
+				nf_reset(skb);
 			}
 			ret = ipprot->handler(skb);
 			if (ret < 0) {
Index: linux.h/net/core/netfilter.c
===================================================================
--- linux.h.orig/net/core/netfilter.c	2005-02-18 14:47:53.000000000 -0500
+++ linux.h/net/core/netfilter.c	2005-02-18 14:47:55.000000000 -0500
@@ -711,6 +711,47 @@ int nf_rcv_postxfrm_local(struct sk_buff
 	return nf_rcv_postxfrm_nonlocal(skb);
 }
  
+#ifdef CONFIG_IP_NF_NAT_NEEDED
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ip_nat.h>
+
+void nf_nat_decode_session4(struct sk_buff *skb, struct flowi *fl)
+{
+	struct ip_conntrack *ct;
+	struct ip_conntrack_tuple *t;
+	enum ip_conntrack_info ctinfo;
+	enum ip_conntrack_dir dir;
+	int known_proto;
+	int statusbit;
+
+	ct = ip_conntrack_get(skb, &ctinfo);
+	if (ct == NULL || !(ct->status & IPS_NAT_MASK))
+		return;
+
+	dir = CTINFO2DIR(ctinfo);
+	t = &ct->tuplehash[dir].tuple;
+	known_proto = t->dst.protonum == IPPROTO_TCP ||
+	              t->dst.protonum == IPPROTO_UDP;
+
+	statusbit = ct->status;
+	if (dir == IP_CT_DIR_REPLY)
+		statusbit ^= IPS_NAT_MASK;
+
+	if (statusbit & IPS_DST_NAT) {
+		fl->fl4_dst = t->dst.ip;
+		if (known_proto)
+			fl->fl_ip_dport = t->dst.u.tcp.port;
+	}
+
+	if (statusbit & IPS_SRC_NAT) {
+		fl->fl4_src = t->src.ip;
+		if (known_proto)
+			fl->fl_ip_sport = t->src.u.tcp.port;
+	}
+}
+#endif /* CONFIG_IP_NF_NAT_NEEDED */
+#endif
+
 int skb_ip_make_writable(struct sk_buff **pskb, unsigned int writable_len)
 {
 	struct sk_buff *nskb;
Index: linux.h/include/net/xfrm.h
===================================================================
--- linux.h.orig/include/net/xfrm.h	2005-02-18 14:47:51.000000000 -0500
+++ linux.h/include/net/xfrm.h	2005-02-18 14:47:55.000000000 -0500
@@ -178,6 +178,8 @@ struct xfrm_policy_afinfo {
 
 extern int xfrm_policy_register_afinfo(struct xfrm_policy_afinfo *afinfo);
 extern int xfrm_policy_unregister_afinfo(struct xfrm_policy_afinfo *afinfo);
+extern struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family);
+extern void xfrm_policy_put_afinfo(struct xfrm_policy_afinfo *afinfo);
 
 #define XFRM_ACQ_EXPIRES	30
 
Index: linux.h/include/linux/netfilter.h
===================================================================
--- linux.h.orig/include/linux/netfilter.h	2005-02-18 14:43:36.000000000 -0500
+++ linux.h/include/linux/netfilter.h	2005-02-18 14:47:55.000000000 -0500
@@ -188,5 +188,21 @@ extern void nf_invalidate_cache(int pf);
 static inline void nf_ct_attach(struct sk_buff *new, struct sk_buff *skb) {}
 #endif /*CONFIG_NETFILTER*/
 
+#ifdef CONFIG_XFRM
+#ifdef CONFIG_IP_NF_NAT_NEEDED
+struct flowi;
+extern void nf_nat_decode_session4(struct sk_buff *skb, struct flowi *fl);
+
+static inline void
+nf_nat_decode_session(struct sk_buff *skb, struct flowi *fl, int family)
+{
+	if (family == AF_INET)
+		nf_nat_decode_session4(skb, fl);
+}
+#else /* CONFIG_IP_NF_NAT_NEEDED */
+#define nf_nat_decode_session(skb,fl,family)
+#endif /* CONFIG_IP_NF_NAT_NEEDED */
+#endif /* CONFIG_XFRM */
+
 #endif /*__KERNEL__*/
 #endif /*__LINUX_NETFILTER_H*/
