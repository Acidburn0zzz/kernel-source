From: Sachin Sant <sachinp@in.ibm.com>
Subject: Re: [RFC] [PATCH] Adding ctrl-o sysrq hack support to 8250 driver

Bug 96313 - LTC16841-sysrq fails to invoke on power4 (non-lpar)

a POWER4 system in 'full-system-partition' mode has the console device
on ttyS0. But the user interface to the Linux system console may still
be on the hardware management console (HMC). If this is the case, there
is no way to send a break to trigger a sysrq.
Other setups do already use 'ctrl o' to trigger sysrq. This includes iSeries
virtual console on tty1, and pSeries LPAR console on hvc0 or hvsi0.

To limit the 'ctrl o' only to the affected systems, query the model property
in the device-tree. The patch makes the serial console not-eight-bit-clean.
Booting with 'console=ttyS0' will disable 'ctrl o', it is only enabled
with console autodetection.

'ctrl o' is currently mapped to 'flush output', see 'stty -a'


Signed-off-by: Olaf Hering <olh@suse.de>

 arch/powerpc/kernel/legacy_serial.c |   44 ++++++++++++++++++++++++++++++++++++
 drivers/serial/8250.c               |    4 +++
 include/asm-powerpc/serial.h        |    6 ++++
 3 files changed, 54 insertions(+)

diff -r 7c24444a3b77 arch/powerpc/kernel/legacy_serial.c
--- a/arch/powerpc/kernel/legacy_serial.c	Mon Mar  6 12:36:40 2006 -0500
+++ b/arch/powerpc/kernel/legacy_serial.c	Mon Mar  6 12:39:38 2006 -0500
@@ -452,6 +452,47 @@ static int __init serial_dev_init(void)
 }
 arch_initcall(serial_dev_init);
 
+#if defined(CONFIG_PPC_PSERIES) && defined(CONFIG_SERIAL_8250_CONSOLE)
+/*
+ * Handle the SysRq ^O Hack also via ttyS0 on POWER4 systems
+ * but only on the system console, see asm/serial.h
+ * If they run in FullSystemPartition mode, the firmware console comes in via ttyS0
+ * But BREAK does not work via the HMC, to trigger sysrq.
+ * Affected Models:
+ * p690 7040-681
+ * p670 7040-671
+ * p655 7039-651
+ * p650 7038-6M2
+ * p630 7028-6E4 tower
+ * p630 7028-6C4 rack
+ * p615 7029-6E3 tower
+ * p615 7029-6C3 rack
+ */
+int power4_sysrq_via_ctrl_o;
+
+static void detect_power4_console(void)
+{
+	struct device_node *root;
+	char *model;
+
+	root = of_find_node_by_path("/");
+	if (root) {
+		model = get_property(root, "model", NULL);
+		if (model) {
+			if(!strcmp(model, "IBM,7040-681") ||
+			   !strcmp(model, "IBM,7040-671") ||
+			   !strcmp(model, "IBM,7039-651") ||
+			   !strcmp(model, "IBM,7038-6M2") ||
+			   !strcmp(model, "IBM,7028-6E4") ||
+			   !strcmp(model, "IBM,7028-6C4") ||
+			   !strcmp(model, "IBM,7029-6E3") ||
+			   !strcmp(model, "IBM,7029-6C3"))
+				power4_sysrq_via_ctrl_o = 1;
+		}
+		of_node_put(root);
+	}
+}
+#endif
 
 /*
  * This is called very early, as part of console_init() (typically just after
@@ -523,6 +564,9 @@ static int __init check_legacy_serial_co
 		}
 		if (i >= legacy_serial_count)
 			goto not_found;
+#ifdef CONFIG_PPC_PSERIES
+		detect_power4_console();
+#endif
 	}
 #endif /* CONFIG_SERIAL_8250_CONSOLE */
 #ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE
diff -r 7c24444a3b77 drivers/serial/8250.c
--- a/drivers/serial/8250.c	Mon Mar  6 12:36:40 2006 -0500
+++ b/drivers/serial/8250.c	Mon Mar  6 12:39:38 2006 -0500
@@ -103,6 +103,8 @@ static unsigned int nr_uarts = CONFIG_SE
 #ifdef CONFIG_SERIAL_8250_MANY_PORTS
 #define CONFIG_SERIAL_MANY_PORTS 1
 #endif
+
+#define arch_8250_sysrq_via_ctrl_o(a,b) (0)
 
 /*
  * HUB6 is always on.  This will be removed once the header
@@ -1172,6 +1174,8 @@ receive_chars(struct uart_8250_port *up,
 			kdb_serial_ptr = kdb_serial_str;
 		}
 #endif	/* CONFIG_KDB */
+		if (arch_8250_sysrq_via_ctrl_o(ch, &up->port))
+			goto ignore_char;
 		flag = TTY_NORMAL;
 		up->port.icount.rx++;
 
diff -r 7c24444a3b77 include/asm-powerpc/serial.h
--- a/include/asm-powerpc/serial.h	Mon Mar  6 12:36:40 2006 -0500
+++ b/include/asm-powerpc/serial.h	Mon Mar  6 12:39:38 2006 -0500
@@ -21,4 +21,10 @@ extern void find_legacy_serial_ports(voi
 #define find_legacy_serial_ports()	do { } while (0)
 #endif
 
+#if defined(SUPPORT_SYSRQ) && defined(CONFIG_PPC_PSERIES)
+#undef arch_8250_sysrq_via_ctrl_o
+extern int power4_sysrq_via_ctrl_o;
+#define arch_8250_sysrq_via_ctrl_o(ch, port) ((ch) == '\x0f' && power4_sysrq_via_ctrl_o && uart_handle_break((port)))
+#endif
+
 #endif /* _PPC64_SERIAL_H */
