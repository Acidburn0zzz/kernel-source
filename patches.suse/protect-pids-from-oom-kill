diff -uNrp linux-2.6.4/fs/proc/base.c linux-2.6.4.non-kill-pid/fs/proc/base.c
--- linux-2.6.4/fs/proc/base.c	2004-03-30 14:13:12.000000000 +0200
+++ linux-2.6.4.non-kill-pid/fs/proc/base.c	2004-03-31 17:52:13.716915408 +0200
@@ -69,6 +69,7 @@ enum pid_directory_inos {
 	PROC_TGID_ATTR_FSCREATE,
 #endif
 	PROC_TGID_FD_DIR,
+	PROC_TGID_NOOOMKILL,
 	PROC_TID_INO,
 	PROC_TID_STATUS,
 	PROC_TID_MEM,
@@ -96,6 +97,7 @@ enum pid_directory_inos {
         PROC_TGID_DELAY_ACCT,
 #endif
 	PROC_TID_FD_DIR = 0x8000,	/* 0x8000-0xffff */
+	PROC_TID_NOOOMKILL,
 };
 
 struct pid_entry {
@@ -134,6 +136,7 @@ static struct pid_entry tgid_base_stuff[
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TGID_WCHAN,     "wchan",   S_IFREG|S_IRUGO),
 #endif
+	E(PROC_TGID_NOOOMKILL, "nooomkill",S_IFREG|S_IRUSR|S_IWUSR),
 	{0,0,NULL,0}
 };
 static struct pid_entry tid_base_stuff[] = {
@@ -159,6 +162,7 @@ static struct pid_entry tid_base_stuff[]
 #ifdef CONFIG_KALLSYMS
 	E(PROC_TID_WCHAN,      "wchan",   S_IFREG|S_IRUGO),
 #endif
+	E(PROC_TID_NOOOMKILL,  "nooomkill",S_IFREG|S_IRUSR|S_IWUSR),
 	{0,0,NULL,0}
 };
 
@@ -753,6 +757,56 @@ static struct file_operations proc_mapba
 };
 #endif /* __HAS_ARCH_PROC_MAPPED_BASE */
 
+static ssize_t nooomkill_read(struct file * file, char * buf,
+			   size_t count, loff_t *ppos)
+{
+	struct task_struct *task = proc_task(file->f_dentry->d_inode);
+	char buffer[8];
+	size_t len;
+	unsigned int nooomkill = task->nooomkill;
+
+	len = sprintf(buffer, "%i\n", nooomkill) + 1;
+	if (*ppos >= len)
+		return 0;
+	if (count > len-*ppos)
+		count = len-*ppos;
+	if (copy_to_user(buf, buffer + *ppos, count)) 
+		return -EFAULT;
+	*ppos += count;
+	return count;
+}
+
+static ssize_t nooomkill_write(struct file * file, const char * buf,
+			    size_t count, loff_t *ppos)
+{
+	struct task_struct *task = proc_task(file->f_dentry->d_inode);
+	char buffer[8], *end;
+	unsigned int unkillable;
+
+	if (!capable(CAP_SYS_RESOURCE))
+		return -EPERM;
+	memset(buffer, 0, 8);	
+	if (count > 6)
+		count = 6;
+	if (copy_from_user(buffer, buf, count)) 
+		return -EFAULT;
+	unkillable = simple_strtoul(buffer, &end, 0);
+	if (*end == '\n')
+		end++;
+	if (unkillable > 0)
+		task->nooomkill = 1;
+	else
+		task->nooomkill = 0;
+	if (end - buffer == 0) 
+		return -EIO;
+	return end - buffer;
+}
+
+static struct file_operations proc_nooomkill_operations = {
+	read:		nooomkill_read,
+	write:		nooomkill_write,
+};
+
 static struct inode_operations proc_mem_inode_operations = {
 	.permission	= proc_permission,
 };
@@ -1467,6 +1521,10 @@ static struct dentry *proc_pident_lookup
 			ei->op.proc_read = proc_pid_delay;
 			break;
 #endif
+		case PROC_TID_NOOOMKILL:	
+		case PROC_TGID_NOOOMKILL:
+			inode->i_fop = &proc_nooomkill_operations;
+			break;
 		default:
 			printk("procfs: impossible type (%d)",p->type);
 			iput(inode);
diff -uNrp linux-2.6.4/include/linux/sched.h linux-2.6.4.non-kill-pid/include/linux/sched.h
--- linux-2.6.4/include/linux/sched.h	2004-03-30 14:13:12.000000000 +0200
+++ linux-2.6.4.non-kill-pid/include/linux/sched.h	2004-03-31 12:28:21.000000000 +0200
@@ -442,7 +442,8 @@ struct task_struct {
 	struct user_struct *user;
 /* limits */
 	struct rlimit rlim[RLIM_NLIMITS];
-	unsigned short used_math;
+	unsigned short used_math:1;
+	unsigned short noomkill:1;	/* OOM kill protextion */
 	char comm[16];
 /* file system info */
 	int link_count, total_link_count;
diff -uNrp linux-2.6.4/mm/oom_kill.c linux-2.6.4.non-kill-pid/mm/oom_kill.c
--- linux-2.6.4/mm/oom_kill.c	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.4.non-kill-pid/mm/oom_kill.c	2004-03-31 17:56:16.889257493 +0200
@@ -93,6 +93,13 @@ static int badness(struct task_struct *p
 	 */
 	if (cap_t(p->cap_effective) & CAP_TO_MASK(CAP_SYS_RAWIO))
 		points /= 4;
+
+	/* 
+	 * If the nooomkill flag is set, we'll be very nice to them.
+	 */
+	if (p->nooomkill)
+		points /= 128;
+		
 #ifdef DEBUG
 	printk(KERN_DEBUG "OOMkill: task %d (%s) got %d points\n",
 	p->pid, p->comm, points);
@@ -154,6 +161,9 @@ static void __oom_kill_task(task_t *p)
 	/* This process has hardware access, be more careful. */
 	if (cap_t(p->cap_effective) & CAP_TO_MASK(CAP_SYS_RAWIO)) {
 		force_sig(SIGTERM, p);
+	} else if (p->nooomkill) {
+		force_sig(SIGTERM, p);
+		p->nooomkill = 0;	/* Next time, we'll hit hard */
 	} else {
 		force_sig(SIGKILL, p);
 	}
