diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/block/ll_rw_blk.c linux-2.6.4/drivers/block/ll_rw_blk.c
--- /opt/kernel/linux-2.6.4-suse/drivers/block/ll_rw_blk.c	2004-03-15 10:20:35.458127000 +0100
+++ linux-2.6.4/drivers/block/ll_rw_blk.c	2004-03-15 10:23:30.000000000 +0100
@@ -42,12 +42,6 @@
  */
 static kmem_cache_t *request_cachep;
 
-/*
- * plug management
- */
-static LIST_HEAD(blk_plug_list);
-static spinlock_t blk_plug_lock __cacheline_aligned_in_smp = SPIN_LOCK_UNLOCKED;
-
 static wait_queue_head_t congestion_wqh[2];
 
 /*
@@ -248,8 +242,6 @@
 	 */
 	blk_queue_bounce_limit(q, BLK_BOUNCE_HIGH);
 
-	INIT_LIST_HEAD(&q->plug_list);
-
 	blk_queue_activity_fn(q, NULL, NULL);
 }
 
@@ -1101,13 +1093,11 @@
 	 * don't plug a stopped queue, it must be paired with blk_start_queue()
 	 * which will restart the queueing
 	 */
-	if (!blk_queue_plugged(q)
-	    && !test_bit(QUEUE_FLAG_STOPPED, &q->queue_flags)) {
-		spin_lock(&blk_plug_lock);
-		list_add_tail(&q->plug_list, &blk_plug_list);
+	if (test_bit(QUEUE_FLAG_STOPPED, &q->queue_flags))
+		return;
+
+	if (!test_and_set_bit(QUEUE_FLAG_PLUGGED, &q->queue_flags))
 		mod_timer(&q->unplug_timer, jiffies + q->unplug_delay);
-		spin_unlock(&blk_plug_lock);
-	}
 }
 
 EXPORT_SYMBOL(blk_plug_device);
@@ -1119,15 +1109,12 @@
 int blk_remove_plug(request_queue_t *q)
 {
 	WARN_ON(!irqs_disabled());
-	if (blk_queue_plugged(q)) {
-		spin_lock(&blk_plug_lock);
-		list_del_init(&q->plug_list);
-		del_timer(&q->unplug_timer);
-		spin_unlock(&blk_plug_lock);
-		return 1;
-	}
 
-	return 0;
+	if (!test_and_clear_bit(QUEUE_FLAG_PLUGGED, &q->queue_flags))
+		return 0;
+
+	del_timer(&q->unplug_timer);
+	return 1;
 }
 
 EXPORT_SYMBOL(blk_remove_plug);
@@ -1158,14 +1145,11 @@
  *   Linux uses plugging to build bigger requests queues before letting
  *   the device have at them. If a queue is plugged, the I/O scheduler
  *   is still adding and merging requests on the queue. Once the queue
- *   gets unplugged (either by manually calling this function, or by
- *   calling blk_run_queues()), the request_fn defined for the
- *   queue is invoked and transfers started.
+ *   gets unplugged, the request_fn defined for the queue is invoked and
+ *   transfers started.
  **/
-void generic_unplug_device(void *data)
+void generic_unplug_device(request_queue_t *q)
 {
-	request_queue_t *q = data;
-
 	spin_lock_irq(q->queue_lock);
 	__generic_unplug_device(q);
 	spin_unlock_irq(q->queue_lock);
@@ -1173,9 +1157,23 @@
 
 EXPORT_SYMBOL(generic_unplug_device);
 
+static inline void blk_backing_dev_unplug(struct backing_dev_info *bdi)
+{
+	request_queue_t *q = bdi->unplug_io_data;
+
+	/*
+	 * devices don't necessarily have an ->unplug_fn defined
+	 */
+	if (q->unplug_fn)
+		q->unplug_fn(q);
+}
+
+EXPORT_SYMBOL(blk_backing_dev_unplug);
+
 static void blk_unplug_work(void *data)
 {
 	request_queue_t *q = data;
+
 	q->unplug_fn(q);
 }
 
@@ -1253,42 +1251,6 @@
 EXPORT_SYMBOL(blk_run_queue);
 
 /**
- * blk_run_queues - fire all plugged queues
- *
- * Description:
- *   Start I/O on all plugged queues known to the block layer. Queues that
- *   are currently stopped are ignored. This is equivalent to the older
- *   tq_disk task queue run.
- **/
-#define blk_plug_entry(entry) list_entry((entry), request_queue_t, plug_list)
-void blk_run_queues(void)
-{
-	LIST_HEAD(local_plug_list);
-
-	spin_lock_irq(&blk_plug_lock);
-
-	/*
-	 * this will happen fairly often
-	 */
-	if (list_empty(&blk_plug_list))
-		goto out;
-
-	list_splice_init(&blk_plug_list, &local_plug_list);
-	
-	while (!list_empty(&local_plug_list)) {
-		request_queue_t *q = blk_plug_entry(local_plug_list.next);
-
-		spin_unlock_irq(&blk_plug_lock);
-		q->unplug_fn(q);
-		spin_lock_irq(&blk_plug_lock);
-	}
-out:
-	spin_unlock_irq(&blk_plug_lock);
-}
-
-EXPORT_SYMBOL(blk_run_queues);
-
-/**
  * blk_cleanup_queue: - release a &request_queue_t when it is no longer needed
  * @q:    the request queue to be released
  *
@@ -1387,6 +1349,10 @@
 	memset(q, 0, sizeof(*q));
 	init_timer(&q->unplug_timer);
 	atomic_set(&q->refcnt, 1);
+
+	q->backing_dev_info.unplug_io_fn = blk_backing_dev_unplug;
+	q->backing_dev_info.unplug_io_data = q;
+
 	return q;
 }
 
@@ -2047,7 +2013,6 @@
 	DEFINE_WAIT(wait);
 	wait_queue_head_t *wqh = &congestion_wqh[rw];
 
-	blk_run_queues();
 	prepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);
 	ret = io_schedule_timeout(timeout);
 	finish_wait(wqh, &wait);
@@ -2303,7 +2268,7 @@
 	if (blk_queue_plugged(q)) {
 		int nr_queued = q->rq.count[READ] + q->rq.count[WRITE];
 
-		if (nr_queued == q->unplug_thresh)
+		if (nr_queued == q->unplug_thresh || bio_sync(bio))
 			__generic_unplug_device(q);
 	}
 	spin_unlock_irq(q->queue_lock);
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/block/loop.c linux-2.6.4/drivers/block/loop.c
--- /opt/kernel/linux-2.6.4-suse/drivers/block/loop.c	2004-03-15 10:20:26.980044000 +0100
+++ linux-2.6.4/drivers/block/loop.c	2004-03-15 10:23:30.000000000 +0100
@@ -398,6 +398,17 @@
 	return bio;
 }
 
+/*
+ * kick off io on the underlying address space
+ */
+static void loop_unplug(request_queue_t *q)
+{
+	struct loop_device *lo = q->queuedata;
+
+	clear_bit(QUEUE_FLAG_PLUGGED, &q->queue_flags);
+	blk_run_address_space(lo->lo_backing_file->f_mapping);
+}
+
 static int loop_make_request(request_queue_t *q, struct bio *old_bio)
 {
 	struct loop_device *lo = q->queuedata;
@@ -614,7 +625,6 @@
 {
 	struct file	*file;
 	struct inode	*inode;
-	struct block_device *lo_device = NULL;
 	struct address_space *mapping;
 	unsigned lo_blocksize;
 	int		lo_flags = 0;
@@ -671,7 +681,7 @@
 	set_device_ro(bdev, (lo_flags & LO_FLAGS_READ_ONLY) != 0);
 
 	lo->lo_blocksize = lo_blocksize;
-	lo->lo_device = lo_device;
+	lo->lo_device = bdev;
 	lo->lo_flags = lo_flags;
 	lo->lo_backing_file = file;
 	lo->transfer = NULL;
@@ -689,6 +699,7 @@
 	 */
 	blk_queue_make_request(lo->lo_queue, loop_make_request);
 	lo->lo_queue->queuedata = lo;
+	lo->lo_queue->unplug_fn = loop_unplug;
 
 	set_capacity(disks[lo->lo_number], size);
 
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/block/rd.c linux-2.6.4/drivers/block/rd.c
--- /opt/kernel/linux-2.6.4-suse/drivers/block/rd.c	2004-03-11 03:55:34.000000000 +0100
+++ linux-2.6.4/drivers/block/rd.c	2004-03-15 10:29:42.000000000 +0100
@@ -271,6 +271,7 @@
 static struct backing_dev_info rd_backing_dev_info = {
 	.ra_pages	= 0,	/* No readahead */
 	.memory_backed	= 1,	/* Does not contribute to dirty memory */
+	.unplug_io_fn	= default_unplug_io_fn,
 };
 
 static int rd_open(struct inode *inode, struct file *filp)
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/block/umem.c linux-2.6.4/drivers/block/umem.c
--- /opt/kernel/linux-2.6.4-suse/drivers/block/umem.c	2004-03-11 03:55:54.000000000 +0100
+++ linux-2.6.4/drivers/block/umem.c	2004-03-15 10:23:49.000000000 +0100
@@ -368,9 +368,8 @@
 	page->biotail = & page->bio;
 }
 
-static void mm_unplug_device(void *data)
+static void mm_unplug_device(request_queue_t *q)
 {
-	request_queue_t *q = data;
 	struct cardinfo *card = q->queuedata;
 	unsigned long flags;
 
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/dm.c linux-2.6.4/drivers/md/dm.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/dm.c	2004-03-15 10:20:40.529578000 +0100
+++ linux-2.6.4/drivers/md/dm.c	2004-03-15 10:28:21.570697079 +0100
@@ -578,6 +578,18 @@
 	return 0;
 }
 
+static void dm_unplug_all(request_queue_t *q)
+{
+	struct mapped_device *md = q->queuedata;
+	struct dm_table *map = dm_get_table(md);
+
+	clear_bit(QUEUE_FLAG_PLUGGED, &q->queue_flags);
+	if (map) {
+		dm_table_unplug_all(md->map);
+		dm_table_put(map);
+	}
+}
+
 static int dm_any_congested(void *congested_data, int bdi_bits)
 {
 	int r;
@@ -675,6 +687,7 @@
 	md->queue->backing_dev_info.congested_fn = dm_any_congested;
 	md->queue->backing_dev_info.congested_data = md;
 	blk_queue_make_request(md->queue, dm_request);
+	md->queue->unplug_fn = dm_unplug_all;
 
 	md->io_pool = mempool_create(MIN_IOS, mempool_alloc_slab,
 				     mempool_free_slab, _io_cache);
@@ -928,11 +941,17 @@
 	add_wait_queue(&md->wait, &wait);
 	up_write(&md->lock);
 
+	/* unplug */
+	map = dm_get_table(md);
+	if (map) {
+		dm_table_unplug_all(map);
+		dm_table_put(map);
+	}
+
 	/*
 	 * Then we wait for the already mapped ios to
 	 * complete.
 	 */
-	blk_run_queues();
 	while (1) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
@@ -978,10 +997,10 @@
 	def = bio_list_get(&md->deferred);
 	__flush_deferred_io(md, def);
 	up_write(&md->lock);
+	dm_table_unplug_all(map);
 	dm_table_put(map);
 
 	__unlock_disk(md->disk);
-	blk_run_queues();
 
 	return 0;
 }
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/dm-crypt.c linux-2.6.4/drivers/md/dm-crypt.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/dm-crypt.c	2004-03-15 10:20:27.084033000 +0100
+++ linux-2.6.4/drivers/md/dm-crypt.c	2004-03-15 10:23:30.000000000 +0100
@@ -668,7 +668,7 @@
 
 		/* out of memory -> run queues */
 		if (remaining)
-			blk_run_queues();
+			blk_congestion_wait(bio_data_dir(clone), HZ/100);
 	}
 
 	/* drop reference, clones could have returned before we reach this */
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/dm.h linux-2.6.4/drivers/md/dm.h
--- /opt/kernel/linux-2.6.4-suse/drivers/md/dm.h	2004-03-15 10:20:40.508580000 +0100
+++ linux-2.6.4/drivers/md/dm.h	2004-03-15 10:23:30.000000000 +0100
@@ -116,6 +116,7 @@
 void dm_table_suspend_targets(struct dm_table *t);
 void dm_table_resume_targets(struct dm_table *t);
 int dm_table_any_congested(struct dm_table *t, int bdi_bits);
+void dm_table_unplug_all(struct dm_table *t);
 
 /*-----------------------------------------------------------------
  * A registry of target types.
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/dm-io.c linux-2.6.4/drivers/md/dm-io.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/dm-io.c	2004-03-15 10:20:40.397592000 +0100
+++ linux-2.6.4/drivers/md/dm-io.c	2004-03-15 10:23:30.000000000 +0100
@@ -475,11 +475,14 @@
 
 static void dispatch_io(int rw, unsigned int num_regions,
 			struct io_region *where, struct dpages *dp,
-			struct io *io)
+			struct io *io, int sync)
 {
 	int i;
 	struct dpages old_pages = *dp;
 
+	if (sync)
+		rw |= BIO_RW_SYNC;
+
 	/*
 	 * For multiple regions we need to be careful to rewind
 	 * the dp object for each call to do_region.
@@ -508,8 +511,7 @@
 	atomic_set(&io.count, 1); /* see dispatch_io() */
 	io.sleeper = current;
 
-	dispatch_io(rw, num_regions, where, dp, &io);
-	blk_run_queues();
+	dispatch_io(rw, num_regions, where, dp, &io, 1);
 
 	while (1) {
 		/* FIXME: handle signals */
@@ -537,7 +539,7 @@
 	io->callback = fn;
 	io->context = context;
 
-	dispatch_io(rw, num_regions, where, dp, io);
+	dispatch_io(rw, num_regions, where, dp, io, 0);
 	return 0;
 }
 
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/dm-log.c linux-2.6.4/drivers/md/dm-log.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/dm-log.c	2004-03-15 10:20:40.424589000 +0100
+++ linux-2.6.4/drivers/md/dm-log.c	2004-03-15 10:23:49.000000000 +0100
@@ -11,6 +11,7 @@
 
 #include "dm-log.h"
 #include "dm-io.h"
+#include "dm.h"
 
 static LIST_HEAD(_log_types);
 static spinlock_t _lock = SPIN_LOCK_UNLOCKED;
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/dm-mpath.c linux-2.6.4/drivers/md/dm-mpath.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/dm-mpath.c	2004-03-15 10:20:40.383594000 +0100
+++ linux-2.6.4/drivers/md/dm-mpath.c	2004-03-15 10:23:30.000000000 +0100
@@ -234,6 +234,7 @@
 static void dispatch_failed_ios(void *data)
 {
 	struct multipath *m = (struct multipath *) data;
+	struct dm_table *map;
 
 	int r;
 	unsigned long flags;
@@ -247,6 +248,8 @@
 		next = bio->bi_next;
 		bio->bi_next = NULL;
 
+		bio->bi_rw |= BIO_RW_SYNC;
+
 		r = map_io(m, bio);
 		if (r)
 			/*
@@ -260,12 +263,6 @@
 
 		bio = next;
 	}
-
-	/*
-	 * FIXME: this now gets called once for each mpath
-	 * target, rather than once per daemon cycle.
-	 */
- 	blk_run_queues();
 }
 
 static void trigger_event(void *data)
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/dm-raid1.c linux-2.6.4/drivers/md/dm-raid1.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/dm-raid1.c	2004-03-15 10:20:40.427589000 +0100
+++ linux-2.6.4/drivers/md/dm-raid1.c	2004-03-15 10:23:30.000000000 +0100
@@ -859,7 +859,9 @@
 	do_recovery(ms);
 	do_reads(ms, &reads);
 	do_writes(ms, &writes);
-	blk_run_queues();
+	dm_table_get(ms->ti->table);
+	dm_table_unplug_all(ms->ti->table);
+	dm_table_put(ms->ti->table);
 }
 
 static void do_work(void *ignored)
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/dm-snap.c linux-2.6.4/drivers/md/dm-snap.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/dm-snap.c	2004-03-15 10:20:40.416590000 +0100
+++ linux-2.6.4/drivers/md/dm-snap.c	2004-03-15 10:23:30.000000000 +0100
@@ -565,6 +565,7 @@
  */
 static void flush_bios(struct bio *bio)
 {
+	request_queue_t *target = bdev_get_queue(bio->bi_bdev);
 	struct bio *n;
 
 	DMDEBUG("begin flush");
@@ -576,7 +577,8 @@
 		bio = n;
 	}
 
-	blk_run_queues();
+	if (target)
+		blk_run_queue(target);
 }
 
 /*
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/dm-table.c linux-2.6.4/drivers/md/dm-table.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/dm-table.c	2004-03-15 10:20:40.546576000 +0100
+++ linux-2.6.4/drivers/md/dm-table.c	2004-03-15 10:23:30.000000000 +0100
@@ -885,6 +885,21 @@
 	return r;
 }
 
+void dm_table_unplug_all(struct dm_table *t)
+{
+	struct list_head *d, *devices = dm_table_get_devices(t);
+
+	for (d = devices->next; d != devices; d = d->next) {
+		struct dm_dev *dd = list_entry(d, struct dm_dev, list);
+		request_queue_t *q = bdev_get_queue(dd->bdev);
+
+		if (q->unplug_fn) {
+			set_bit(QUEUE_FLAG_PLUGGED, &q->queue_flags);
+			q->unplug_fn(q);
+		}
+	}
+}
+
 EXPORT_SYMBOL(dm_vcalloc);
 EXPORT_SYMBOL(dm_get_device);
 EXPORT_SYMBOL(dm_put_device);
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/kcopyd.c linux-2.6.4/drivers/md/kcopyd.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/kcopyd.c	2004-03-15 10:20:40.405591000 +0100
+++ linux-2.6.4/drivers/md/kcopyd.c	2004-03-15 10:23:30.000000000 +0100
@@ -409,8 +409,6 @@
 	process_jobs(&_complete_jobs, run_complete_job);
 	process_jobs(&_pages_jobs, run_pages_job);
 	process_jobs(&_io_jobs, run_io_job);
-
-	blk_run_queues();
 }
 
 /*
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/md.c linux-2.6.4/drivers/md/md.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/md.c	2004-03-15 10:20:28.285903000 +0100
+++ linux-2.6.4/drivers/md/md.c	2004-03-15 10:29:42.000000000 +0100
@@ -160,6 +160,32 @@
 	return 0;
 }
 
+void md_unplug_mddev(mddev_t *mddev)
+{
+	struct list_head *tmp;
+	mdk_rdev_t *rdev;
+
+	/*
+	 * this list iteration is done without any locking in md?!
+	 */
+	ITERATE_RDEV(mddev, rdev, tmp) {
+		request_queue_t *r_queue = bdev_get_queue(rdev->bdev);
+
+		if (r_queue->unplug_fn) {
+			set_bit(QUEUE_FLAG_PLUGGED, &r_queue->queue_flags);
+			r_queue->unplug_fn(r_queue);
+		}
+	}
+}
+
+static void md_unplug_all(request_queue_t *q)
+{
+	mddev_t *mddev = q->queuedata;
+
+	clear_bit(QUEUE_FLAG_PLUGGED, &q->queue_flags);
+	md_unplug_mddev(mddev);
+}
+
 static inline mddev_t *mddev_get(mddev_t *mddev)
 {
 	atomic_inc(&mddev->active);
@@ -335,6 +361,8 @@
 	struct bio_vec vec;
 	struct completion event;
 
+	rw |= (1 << BIO_RW_SYNC);
+
 	bio_init(&bio);
 	bio.bi_io_vec = &vec;
 	vec.bv_page = page;
@@ -349,7 +377,6 @@
 	bio.bi_private = &event;
 	bio.bi_end_io = bi_complete;
 	submit_bio(rw, &bio);
-	blk_run_queues();
 	wait_for_completion(&event);
 
 	return test_bit(BIO_UPTODATE, &bio.bi_flags);
@@ -1644,6 +1671,7 @@
 	 */
 	mddev->queue->queuedata = mddev;
 	mddev->queue->make_request_fn = mddev->pers->make_request;
+	mddev->queue->unplug_fn = md_unplug_all;
 
 	mddev->changed = 1;
 	return 0;
@@ -2718,7 +2746,7 @@
 		run = thread->run;
 		if (run) {
 			run(thread->mddev);
-			blk_run_queues();
+			md_unplug_mddev(thread->mddev);
 		}
 		if (signal_pending(current))
 			flush_signals(current);
@@ -3286,7 +3314,7 @@
 		    test_bit(MD_RECOVERY_ERR, &mddev->recovery))
 			break;
 
-		blk_run_queues();
+		md_unplug_mddev(mddev);
 
 	repeat:
 		if (jiffies >= mark[last_mark] + SYNC_MARK_STEP ) {
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/raid1.c linux-2.6.4/drivers/md/raid1.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/raid1.c	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.4/drivers/md/raid1.c	2004-03-15 10:29:42.000000000 +0100
@@ -451,6 +451,7 @@
 
 static void device_barrier(conf_t *conf, sector_t sect)
 {
+	md_unplug_mddev(conf->mddev);
 	spin_lock_irq(&conf->resync_lock);
 	wait_event_lock_irq(conf->wait_idle, !waitqueue_active(&conf->wait_resume), conf->resync_lock);
 	
@@ -478,6 +479,7 @@
 	 * thread has put up a bar for new requests.
 	 * Continue immediately if no resync is active currently.
 	 */
+	md_unplug_mddev(conf->mddev);
 	spin_lock_irq(&conf->resync_lock);
 	wait_event_lock_irq(conf->wait_resume, !conf->barrier, conf->resync_lock);
 	conf->nr_pending++;
@@ -644,6 +646,7 @@
 
 static void close_sync(conf_t *conf)
 {
+	md_unplug_mddev(conf->mddev);
 	spin_lock_irq(&conf->resync_lock);
 	wait_event_lock_irq(conf->wait_resume, !conf->barrier, conf->resync_lock);
 	spin_unlock_irq(&conf->resync_lock);
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/raid5.c linux-2.6.4/drivers/md/raid5.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/raid5.c	2004-03-15 10:20:28.287902000 +0100
+++ linux-2.6.4/drivers/md/raid5.c	2004-03-15 10:29:42.000000000 +0100
@@ -249,6 +249,7 @@
 				break;
 			if (!sh) {
 				conf->inactive_blocked = 1;
+				md_unplug_mddev(conf->mddev);
 				wait_event_lock_irq(conf->wait_for_stripe,
 						    !list_empty(&conf->inactive_list) &&
 						    (atomic_read(&conf->active_stripes) < (NR_STRIPES *3/4)
@@ -1292,9 +1293,8 @@
 		}
 	}
 }
-static void raid5_unplug_device(void *data)
+static void raid5_unplug_device(request_queue_t *q)
 {
-	request_queue_t *q = data;
 	mddev_t *mddev = q->queuedata;
 	raid5_conf_t *conf = mddev_to_conf(mddev);
 	unsigned long flags;
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/md/raid6main.c linux-2.6.4/drivers/md/raid6main.c
--- /opt/kernel/linux-2.6.4-suse/drivers/md/raid6main.c	2004-03-15 10:20:28.288902000 +0100
+++ linux-2.6.4/drivers/md/raid6main.c	2004-03-15 10:23:30.000000000 +0100
@@ -1454,9 +1454,8 @@
 		}
 	}
 }
-static void raid6_unplug_device(void *data)
+static void raid6_unplug_device(request_queue_t *q)
 {
-	request_queue_t *q = data;
 	mddev_t *mddev = q->queuedata;
 	raid6_conf_t *conf = mddev_to_conf(mddev);
 	unsigned long flags;
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/drivers/mtd/devices/blkmtd.c linux-2.6.4/drivers/mtd/devices/blkmtd.c
--- /opt/kernel/linux-2.6.4-suse/drivers/mtd/devices/blkmtd.c	2004-03-15 10:20:27.182022000 +0100
+++ linux-2.6.4/drivers/mtd/devices/blkmtd.c	2004-03-15 10:23:30.000000000 +0100
@@ -147,8 +147,7 @@
 		bio->bi_private = &event;
 		bio->bi_end_io = bi_read_complete;
 		if(bio_add_page(bio, page, PAGE_SIZE, 0) == PAGE_SIZE) {
-			submit_bio(READ, bio);
-			blk_run_queues();
+			submit_bio(READ_SYNC, bio);
 			wait_for_completion(&event);
 			err = test_bit(BIO_UPTODATE, &bio->bi_flags) ? 0 : -EIO;
 			bio_put(bio);
@@ -179,8 +178,7 @@
 	init_completion(&event);
 	bio->bi_private = &event;
 	bio->bi_end_io = bi_write_complete;
-	submit_bio(WRITE, bio);
-	blk_run_queues();
+	submit_bio(WRITE_SYNC, bio);
 	wait_for_completion(&event);
 	DEBUG(3, "submit_bio completed, bi_vcnt = %d\n", bio->bi_vcnt);
 	err = test_bit(BIO_UPTODATE, &bio->bi_flags) ? 0 : -EIO;
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/fs/buffer.c linux-2.6.4/fs/buffer.c
--- /opt/kernel/linux-2.6.4-suse/fs/buffer.c	2004-03-15 10:20:40.000000000 +0100
+++ linux-2.6.4/fs/buffer.c	2004-03-15 10:23:30.000000000 +0100
@@ -132,7 +132,7 @@
 	do {
 		prepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);
 		if (buffer_locked(bh)) {
-			blk_run_queues();
+			blk_run_address_space(bh->b_bdev->bd_inode->i_mapping);
 			io_schedule();
 		}
 	} while (buffer_locked(bh));
@@ -502,7 +502,6 @@
 	pg_data_t *pgdat;
 
 	wakeup_bdflush(1024);
-	blk_run_queues();
 	yield();
 
 	for_each_pgdat(pgdat) {
@@ -2940,7 +2939,10 @@
 
 int block_sync_page(struct page *page)
 {
-	blk_run_queues();
+	struct address_space *mapping;
+	smp_mb();
+	mapping = page->mapping;
+	blk_run_address_space(mapping);
 	return 0;
 }
 
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/fs/direct-io.c linux-2.6.4/fs/direct-io.c
--- /opt/kernel/linux-2.6.4-suse/fs/direct-io.c	2004-03-11 03:55:29.000000000 +0100
+++ linux-2.6.4/fs/direct-io.c	2004-03-15 10:23:30.000000000 +0100
@@ -329,7 +329,7 @@
 		if (dio->bio_list == NULL) {
 			dio->waiter = current;
 			spin_unlock_irqrestore(&dio->bio_list_lock, flags);
-			blk_run_queues();
+			blk_run_address_space(dio->inode->i_mapping);
 			io_schedule();
 			spin_lock_irqsave(&dio->bio_list_lock, flags);
 			dio->waiter = NULL;
@@ -960,7 +960,7 @@
 		if (ret == 0)
 			ret = dio->result;	/* Bytes written */
 		finished_one_bio(dio);		/* This can free the dio */
-		blk_run_queues();
+		blk_run_address_space(inode->i_mapping);
 	} else {
 		finished_one_bio(dio);
 		ret2 = dio_await_completion(dio);
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/fs/jfs/jfs_logmgr.c linux-2.6.4/fs/jfs/jfs_logmgr.c
--- /opt/kernel/linux-2.6.4-suse/fs/jfs/jfs_logmgr.c	2004-03-11 03:55:27.000000000 +0100
+++ linux-2.6.4/fs/jfs/jfs_logmgr.c	2004-03-15 10:23:30.000000000 +0100
@@ -1972,8 +1972,7 @@
 
 	bio->bi_end_io = lbmIODone;
 	bio->bi_private = bp;
-	submit_bio(READ, bio);
-	blk_run_queues();
+	submit_bio(READ_SYNC, bio);
 
 	wait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));
 
@@ -2117,9 +2116,8 @@
 
 	/* check if journaling to disk has been disabled */
 	if (!log->no_integrity) {
-		submit_bio(WRITE, bio);
+		submit_bio(WRITE_SYNC, bio);
 		INCREMENT(lmStat.submitted);
-		blk_run_queues();
 	}
 	else {
 		bio->bi_size = 0;
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/fs/ntfs/compress.c linux-2.6.4/fs/ntfs/compress.c
--- /opt/kernel/linux-2.6.4-suse/fs/ntfs/compress.c	2004-03-11 03:55:27.000000000 +0100
+++ linux-2.6.4/fs/ntfs/compress.c	2004-03-15 10:23:49.000000000 +0100
@@ -23,6 +23,7 @@
 
 #include <linux/fs.h>
 #include <linux/buffer_head.h>
+#include <linux/blkdev.h>
 
 #include "ntfs.h"
 
@@ -668,7 +669,7 @@
 					"uptodate! Unplugging the disk queue "
 					"and rescheduling.");
 			get_bh(tbh);
-			blk_run_queues();
+			blk_run_address_space(mapping);
 			schedule();
 			put_bh(tbh);
 			if (unlikely(!buffer_uptodate(tbh)))
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/fs/ufs/truncate.c linux-2.6.4/fs/ufs/truncate.c
--- /opt/kernel/linux-2.6.4-suse/fs/ufs/truncate.c	2004-03-11 03:55:27.000000000 +0100
+++ linux-2.6.4/fs/ufs/truncate.c	2004-03-15 10:23:49.000000000 +0100
@@ -38,6 +38,7 @@
 #include <linux/string.h>
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
+#include <linux/blkdev.h>
 #include <linux/sched.h>
 
 #include "swab.h"
@@ -456,7 +457,7 @@
 			break;
 		if (IS_SYNC(inode) && (inode->i_state & I_DIRTY))
 			ufs_sync_inode (inode);
-		blk_run_queues();
+		blk_run_address_space(inode->i_mapping);
 		yield();
 	}
 	offset = inode->i_size & uspi->s_fshift;
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/fs/xfs/linux/xfs_buf.c linux-2.6.4/fs/xfs/linux/xfs_buf.c
--- /opt/kernel/linux-2.6.4-suse/fs/xfs/linux/xfs_buf.c	2004-03-15 10:20:34.000000000 +0100
+++ linux-2.6.4/fs/xfs/linux/xfs_buf.c	2004-03-15 10:23:49.000000000 +0100
@@ -1017,7 +1017,7 @@
 {
 	PB_TRACE(pb, "lock", 0);
 	if (atomic_read(&pb->pb_io_remaining))
-		blk_run_queues();
+		blk_run_address_space(pb->pb_target->pbr_mapping);
 	down(&pb->pb_sema);
 	PB_SET_OWNER(pb);
 	PB_TRACE(pb, "locked", 0);
@@ -1113,7 +1113,7 @@
 		if (atomic_read(&pb->pb_pin_count) == 0)
 			break;
 		if (atomic_read(&pb->pb_io_remaining))
-			blk_run_queues();
+			blk_run_address_space(pb->pb_target->pbr_mapping);
 		schedule();
 	}
 	remove_wait_queue(&pb->pb_waiters, &wait);
@@ -1411,7 +1411,7 @@
 	if (pb->pb_flags & PBF_RUN_QUEUES) {
 		pb->pb_flags &= ~PBF_RUN_QUEUES;
 		if (atomic_read(&pb->pb_io_remaining) > 1)
-			blk_run_queues();
+			blk_run_address_space(pb->pb_target->pbr_mapping);
 	}
 }
 
@@ -1475,7 +1475,7 @@
 {
 	PB_TRACE(pb, "iowait", 0);
 	if (atomic_read(&pb->pb_io_remaining))
-		blk_run_queues();
+		blk_run_address_space(pb->pb_target->pbr_mapping);
 	down(&pb->pb_iodonesema);
 	PB_TRACE(pb, "iowaited", (long)pb->pb_error);
 	return pb->pb_error;
@@ -1621,7 +1621,6 @@
 pagebuf_daemon(
 	void			*data)
 {
-	int			count;
 	xfs_buf_t		*pb;
 	struct list_head	*curr, *next, tmp;
 
@@ -1644,7 +1643,6 @@
 
 		spin_lock(&pbd_delwrite_lock);
 
-		count = 0;
 		list_for_each_safe(curr, next, &pbd_delwrite_queue) {
 			pb = list_entry(curr, xfs_buf_t, pb_list);
 
@@ -1661,7 +1659,6 @@
 				pb->pb_flags &= ~PBF_DELWRI;
 				pb->pb_flags |= PBF_WRITE;
 				list_move(&pb->pb_list, &tmp);
-				count++;
 			}
 		}
 
@@ -1671,12 +1668,11 @@
 			list_del_init(&pb->pb_list);
 
 			pagebuf_iostrategy(pb);
+			blk_run_address_space(pb->pb_target->pbr_mapping);
 		}
 
 		if (as_list_len > 0)
 			purge_addresses();
-		if (count)
-			blk_run_queues();
 
 		force_flush = 0;
 	} while (pagebuf_daemon_active);
@@ -1693,7 +1689,6 @@
 	xfs_buf_t		*pb;
 	struct list_head	*curr, *next, tmp;
 	int			pincount = 0;
-	int			flush_cnt = 0;
 
 	pagebuf_runall_queues(pagebuf_dataio_workqueue);
 	pagebuf_runall_queues(pagebuf_logio_workqueue);
@@ -1737,14 +1732,8 @@
 
 		pagebuf_lock(pb);
 		pagebuf_iostrategy(pb);
-		if (++flush_cnt > 32) {
-			blk_run_queues();
-			flush_cnt = 0;
-		}
 	}
 
-	blk_run_queues();
-
 	while (!list_empty(&tmp)) {
 		pb = list_entry(tmp.next, xfs_buf_t, pb_list);
 
@@ -1755,6 +1744,9 @@
 		pagebuf_rele(pb);
 	}
 
+	if (flags & PBDF_WAIT)
+		blk_run_address_space(target->pbr_mapping);
+
 	if (pinptr)
 		*pinptr = pincount;
 }
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/include/linux/backing-dev.h linux-2.6.4/include/linux/backing-dev.h
--- /opt/kernel/linux-2.6.4-suse/include/linux/backing-dev.h	2004-03-15 10:20:40.000000000 +0100
+++ linux-2.6.4/include/linux/backing-dev.h	2004-03-15 10:29:42.000000000 +0100
@@ -28,9 +28,12 @@
 	int memory_backed;	/* Cannot clean pages with writepage */
 	congested_fn *congested_fn; /* Function pointer if device is md/dm */
 	void *congested_data;	/* Pointer to aux data for congested func */
+	void (*unplug_io_fn)(struct backing_dev_info *);
+	void *unplug_io_data;
 };
 
 extern struct backing_dev_info default_backing_dev_info;
+void default_unplug_io_fn(struct backing_dev_info *bdi);
 
 int writeback_acquire(struct backing_dev_info *bdi);
 int writeback_in_progress(struct backing_dev_info *bdi);
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/include/linux/bio.h linux-2.6.4/include/linux/bio.h
--- /opt/kernel/linux-2.6.4-suse/include/linux/bio.h	2004-03-11 03:55:37.000000000 +0100
+++ linux-2.6.4/include/linux/bio.h	2004-03-15 10:23:30.000000000 +0100
@@ -124,6 +124,7 @@
 #define BIO_RW_AHEAD	1
 #define BIO_RW_BARRIER	2
 #define BIO_RW_FAILFAST	3
+#define BIO_RW_SYNC	4
 
 /*
  * various member access, note that bio_data should of course not be used
@@ -138,6 +139,7 @@
 #define bio_cur_sectors(bio)	(bio_iovec(bio)->bv_len >> 9)
 #define bio_data(bio)		(page_address(bio_page((bio))) + bio_offset((bio)))
 #define bio_barrier(bio)	((bio)->bi_rw & (1 << BIO_RW_BARRIER))
+#define bio_sync(bio)		((bio)->bi_rw & (1 << BIO_RW_SYNC))
 
 /*
  * will die
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/include/linux/blkdev.h linux-2.6.4/include/linux/blkdev.h
--- /opt/kernel/linux-2.6.4-suse/include/linux/blkdev.h	2004-03-15 10:20:27.000000000 +0100
+++ linux-2.6.4/include/linux/blkdev.h	2004-03-15 10:23:30.000000000 +0100
@@ -243,7 +243,7 @@
 typedef void (request_fn_proc) (request_queue_t *q);
 typedef int (make_request_fn) (request_queue_t *q, struct bio *bio);
 typedef int (prep_rq_fn) (request_queue_t *, struct request *);
-typedef void (unplug_fn) (void *q);
+typedef void (unplug_fn) (request_queue_t *);
 
 struct bio_vec;
 typedef int (merge_bvec_fn) (request_queue_t *, struct bio *, struct bio_vec *);
@@ -315,8 +315,6 @@
 	unsigned long		bounce_pfn;
 	int			bounce_gfp;
 
-	struct list_head	plug_list;
-
 	/*
 	 * various queue flags, see QUEUE_* below
 	 */
@@ -370,8 +368,9 @@
 #define QUEUE_FLAG_WRITEFULL	4	/* read queue has been filled */
 #define QUEUE_FLAG_DEAD		5	/* queue being torn down */
 #define QUEUE_FLAG_REENTER	6	/* Re-entrancy avoidance */
+#define QUEUE_FLAG_PLUGGED	7	/* queue is plugged */
 
-#define blk_queue_plugged(q)	!list_empty(&(q)->plug_list)
+#define blk_queue_plugged(q)	test_bit(QUEUE_FLAG_PLUGGED, &(q)->queue_flags)
 #define blk_queue_tagged(q)	test_bit(QUEUE_FLAG_QUEUED, &(q)->queue_flags)
 #define blk_queue_stopped(q)	test_bit(QUEUE_FLAG_STOPPED, &(q)->queue_flags)
 
@@ -515,7 +514,7 @@
 extern void blk_start_queue(request_queue_t *q);
 extern void blk_stop_queue(request_queue_t *q);
 extern void __blk_stop_queue(request_queue_t *q);
-extern void blk_run_queue(request_queue_t *q);
+extern void blk_run_queue(request_queue_t *);
 extern void blk_queue_activity_fn(request_queue_t *, activity_fn *, void *);
 extern struct request *blk_rq_map_user(request_queue_t *, int, void __user *, unsigned int);
 extern int blk_rq_unmap_user(struct request *, void __user *, unsigned int);
@@ -526,6 +525,18 @@
 	return bdev->bd_disk->queue;
 }
 
+static inline void blk_run_backing_dev(struct backing_dev_info *bdi)
+{
+	if (bdi && bdi->unplug_io_fn)
+		bdi->unplug_io_fn(bdi);
+}
+
+static inline void blk_run_address_space(struct address_space *mapping)
+{
+	if (mapping)
+		blk_run_backing_dev(mapping->backing_dev_info);
+}
+
 /*
  * end_request() and friends. Must be called with the request queue spinlock
  * acquired. All functions called within end_request() _must_be_ atomic.
@@ -572,7 +583,7 @@
 
 extern int blk_rq_map_sg(request_queue_t *, struct request *, struct scatterlist *);
 extern void blk_dump_rq_flags(struct request *, char *);
-extern void generic_unplug_device(void *);
+extern void generic_unplug_device(request_queue_t *);
 extern long nr_blockdev_pages(void);
 
 int blk_get_queue(request_queue_t *);
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/include/linux/fs.h linux-2.6.4/include/linux/fs.h
--- /opt/kernel/linux-2.6.4-suse/include/linux/fs.h	2004-03-15 10:20:40.000000000 +0100
+++ linux-2.6.4/include/linux/fs.h	2004-03-15 10:23:30.000000000 +0100
@@ -82,6 +82,8 @@
 #define WRITE 1
 #define READA 2		/* read-ahead  - don't block if no resources */
 #define SPECIAL 4	/* For non-blockdevice requests in request queue */
+#define READ_SYNC	(READ | BIO_RW_SYNC)
+#define WRITE_SYNC	(WRITE | BIO_RW_SYNC)
 
 #define SEL_IN		1
 #define SEL_OUT		2
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/include/linux/raid/md.h linux-2.6.4/include/linux/raid/md.h
--- /opt/kernel/linux-2.6.4-suse/include/linux/raid/md.h	2004-03-11 03:55:22.000000000 +0100
+++ linux-2.6.4/include/linux/raid/md.h	2004-03-15 10:29:42.000000000 +0100
@@ -76,6 +76,7 @@
 extern void md_done_sync(mddev_t *mddev, int blocks, int ok);
 extern void md_sync_acct(mdk_rdev_t *rdev, unsigned long nr_sectors);
 extern void md_error (mddev_t *mddev, mdk_rdev_t *rdev);
+extern void md_unplug_mddev(mddev_t *mddev);
 
 extern void md_print_devices (void);
 
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/include/linux/raid/md_k.h linux-2.6.4/include/linux/raid/md_k.h
--- /opt/kernel/linux-2.6.4-suse/include/linux/raid/md_k.h	2004-03-11 03:55:21.000000000 +0100
+++ linux-2.6.4/include/linux/raid/md_k.h	2004-03-15 10:23:30.000000000 +0100
@@ -326,7 +326,6 @@
 		if (condition)						\
 			break;						\
 		spin_unlock_irq(&lock);					\
-		blk_run_queues();					\
 		schedule();						\
 		spin_lock_irq(&lock);					\
 	}								\
@@ -341,30 +340,5 @@
 	__wait_event_lock_irq(wq, condition, lock);			\
 } while (0)
 
-
-#define __wait_disk_event(wq, condition) 				\
-do {									\
-	wait_queue_t __wait;						\
-	init_waitqueue_entry(&__wait, current);				\
-									\
-	add_wait_queue(&wq, &__wait);					\
-	for (;;) {							\
-		set_current_state(TASK_UNINTERRUPTIBLE);		\
-		if (condition)						\
-			break;						\
-		blk_run_queues();					\
-		schedule();						\
-	}								\
-	current->state = TASK_RUNNING;					\
-	remove_wait_queue(&wq, &__wait);				\
-} while (0)
-
-#define wait_disk_event(wq, condition) 					\
-do {									\
-	if (condition)	 						\
-		break;							\
-	__wait_disk_event(wq, condition);				\
-} while (0)
-
 #endif
 
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/include/linux/swap.h linux-2.6.4/include/linux/swap.h
--- /opt/kernel/linux-2.6.4-suse/include/linux/swap.h	2004-03-11 03:55:21.000000000 +0100
+++ linux-2.6.4/include/linux/swap.h	2004-03-15 10:37:21.199322753 +0100
@@ -232,6 +232,8 @@
 extern struct swap_info_struct *get_swap_info_struct(unsigned);
 extern int can_share_swap_page(struct page *);
 extern int remove_exclusive_swap_page(struct page *);
+struct backing_dev_info;
+extern void swap_unplug_io_fn(struct backing_dev_info *);
 
 extern struct swap_list_t swap_list;
 extern spinlock_t swaplock;
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/kernel/power/disk.c linux-2.6.4/kernel/power/disk.c
--- /opt/kernel/linux-2.6.4-suse/kernel/power/disk.c	2004-03-11 03:55:21.000000000 +0100
+++ linux-2.6.4/kernel/power/disk.c	2004-03-15 10:23:30.000000000 +0100
@@ -84,7 +84,6 @@
 	while (shrink_all_memory(10000))
 		printk(".");
 	printk("|\n");
-	blk_run_queues();
 }
 
 
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/kernel/power/pmdisk.c linux-2.6.4/kernel/power/pmdisk.c
--- /opt/kernel/linux-2.6.4-suse/kernel/power/pmdisk.c	2004-03-11 03:55:28.000000000 +0100
+++ linux-2.6.4/kernel/power/pmdisk.c	2004-03-15 10:23:49.000000000 +0100
@@ -859,7 +859,6 @@
 
 static void wait_io(void)
 {
-	blk_run_queues();
 	while(atomic_read(&io_done))
 		io_schedule();
 }
@@ -898,7 +897,7 @@
 	if (rw == WRITE)
 		bio_set_pages_dirty(bio);
 	start_io();
-	submit_bio(rw,bio);
+	submit_bio(rw|BIO_RW_SYNC,bio);
 	wait_io();
  Done:
 	bio_put(bio);
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/kernel/power/swsusp.c linux-2.6.4/kernel/power/swsusp.c
--- /opt/kernel/linux-2.6.4-suse/kernel/power/swsusp.c	2004-03-11 03:55:24.000000000 +0100
+++ linux-2.6.4/kernel/power/swsusp.c	2004-03-15 10:23:30.000000000 +0100
@@ -707,11 +707,6 @@
 
 		free_some_memory();
 		
-		/* No need to invalidate any vfsmnt list -- 
-		 * they will be valid after resume, anyway.
-		 */
-		blk_run_queues();
-
 		/* Save state of all device drivers, and stop them. */		   
 		if ((res = device_suspend(4))==0)
 			/* If stopping device drivers worked, we proceed basically into
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/mm/filemap.c linux-2.6.4/mm/filemap.c
--- /opt/kernel/linux-2.6.4-suse/mm/filemap.c	2004-03-11 03:55:25.000000000 +0100
+++ linux-2.6.4/mm/filemap.c	2004-03-15 10:23:30.000000000 +0100
@@ -118,8 +118,10 @@
 
 static inline int sync_page(struct page *page)
 {
-	struct address_space *mapping = page->mapping;
-
+	struct address_space *mapping;
+	
+	smp_mb();
+	mapping = page->mapping;
 	if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
 		return mapping->a_ops->sync_page(page);
 	return 0;
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/mm/mempool.c linux-2.6.4/mm/mempool.c
--- /opt/kernel/linux-2.6.4-suse/mm/mempool.c	2004-03-15 10:20:40.000000000 +0100
+++ linux-2.6.4/mm/mempool.c	2004-03-15 10:23:30.000000000 +0100
@@ -228,8 +228,6 @@
 	if (!(gfp_mask & __GFP_WAIT))
 		return NULL;
 
-	blk_run_queues();
-
 	prepare_to_wait(&pool->wait, &wait, TASK_UNINTERRUPTIBLE);
 	mb();
 	if (!pool->curr_nr)
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/mm/readahead.c linux-2.6.4/mm/readahead.c
--- /opt/kernel/linux-2.6.4-suse/mm/readahead.c	2004-03-15 10:20:27.000000000 +0100
+++ linux-2.6.4/mm/readahead.c	2004-03-15 10:29:42.000000000 +0100
@@ -15,9 +15,15 @@
 #include <linux/backing-dev.h>
 #include <linux/pagevec.h>
 
+void default_unplug_io_fn(struct backing_dev_info *bdi)
+{
+}
+EXPORT_SYMBOL(default_unplug_io_fn);
+
 struct backing_dev_info default_backing_dev_info = {
 	.ra_pages	= (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE,
 	.state		= 0,
+	.unplug_io_fn	= default_unplug_io_fn,
 };
 
 EXPORT_SYMBOL_GPL(default_backing_dev_info);
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/mm/shmem.c linux-2.6.4/mm/shmem.c
--- /opt/kernel/linux-2.6.4-suse/mm/shmem.c	2004-03-11 03:55:26.000000000 +0100
+++ linux-2.6.4/mm/shmem.c	2004-03-15 10:29:42.000000000 +0100
@@ -133,6 +133,7 @@
 static struct backing_dev_info shmem_backing_dev_info = {
 	.ra_pages	= 0,	/* No readahead */
 	.memory_backed	= 1,	/* Does not contribute to dirty memory */
+	.unplug_io_fn	= default_unplug_io_fn,
 };
 
 LIST_HEAD(shmem_inodes);
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/mm/swapfile.c linux-2.6.4/mm/swapfile.c
--- /opt/kernel/linux-2.6.4-suse/mm/swapfile.c	2004-03-11 03:55:23.000000000 +0100
+++ linux-2.6.4/mm/swapfile.c	2004-03-15 10:37:21.211321456 +0100
@@ -23,6 +23,7 @@
 #include <linux/module.h>
 #include <linux/rmap-locking.h>
 #include <linux/security.h>
+#include <linux/backing-dev.h>
 
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
@@ -44,8 +45,64 @@
 
 struct swap_info_struct swap_info[MAX_SWAPFILES];
 
+/*
+ * Array of backing blockdevs, for swap_unplug_fn.  We need this because the
+ * bdev->unplug_fn can sleep and we cannot hold swap_list_lock while calling
+ * the unplug_fn.  And swap_list_lock cannot be turned into a semaphore.
+ */
+static DECLARE_MUTEX(swap_bdevs_sem);
+static struct block_device *swap_bdevs[MAX_SWAPFILES];
+
 #define SWAPFILE_CLUSTER 256
 
+/*
+ * Caller holds swap_bdevs_sem
+ */
+static void install_swap_bdev(struct block_device *bdev)
+{
+	int i;
+
+	for (i = 0; i < MAX_SWAPFILES; i++) {
+		if (swap_bdevs[i] == NULL) {
+			swap_bdevs[i] = bdev;
+			return;
+		}
+	}
+	BUG();
+}
+
+static void remove_swap_bdev(struct block_device *bdev)
+{
+	int i;
+
+	for (i = 0; i < MAX_SWAPFILES; i++) {
+		if (swap_bdevs[i] == bdev) {
+			memcpy(&swap_bdevs[i], &swap_bdevs[i + 1],
+				(MAX_SWAPFILES - i - 1) * sizeof(*swap_bdevs));
+			swap_bdevs[MAX_SWAPFILES - 1] = NULL;
+			return;
+		}
+	}
+	BUG();
+}
+
+void swap_unplug_io_fn(struct backing_dev_info *unused_bdi)
+{
+	int i;
+
+	down(&swap_bdevs_sem);
+	for (i = 0; i < MAX_SWAPFILES; i++) {
+		struct block_device *bdev = swap_bdevs[i];
+		struct backing_dev_info *bdi;
+
+		if (bdev == NULL)
+			break;
+		bdi = bdev->bd_inode->i_mapping->backing_dev_info;
+		(*bdi->unplug_io_fn)(bdi);
+	}
+	up(&swap_bdevs_sem);
+}
+
 static inline int scan_swap_map(struct swap_info_struct *si)
 {
 	unsigned long offset;
@@ -1088,6 +1145,7 @@
 		swap_list_unlock();
 		goto out_dput;
 	}
+	down(&swap_bdevs_sem);
 	swap_list_lock();
 	swap_device_lock(p);
 	swap_file = p->swap_file;
@@ -1099,6 +1157,8 @@
 	destroy_swap_extents(p);
 	swap_device_unlock(p);
 	swap_list_unlock();
+	remove_swap_bdev(p->bdev);
+	up(&swap_bdevs_sem);
 	vfree(swap_map);
 	if (S_ISBLK(mapping->host->i_mode)) {
 		struct block_device *bdev = I_BDEV(mapping->host);
@@ -1412,6 +1472,7 @@
 	if (error)
 		goto bad_swap;
 
+	down(&swap_bdevs_sem);
 	swap_list_lock();
 	swap_device_lock(p);
 	p->flags = SWP_ACTIVE;
@@ -1437,6 +1498,8 @@
 	}
 	swap_device_unlock(p);
 	swap_list_unlock();
+	install_swap_bdev(p->bdev);
+	up(&swap_bdevs_sem);
 	error = 0;
 	goto out;
 bad_swap:
diff -ur -X /home/axboe/cdrom/exclude /opt/kernel/linux-2.6.4-suse/mm/swap_state.c linux-2.6.4/mm/swap_state.c
--- /opt/kernel/linux-2.6.4-suse/mm/swap_state.c	2004-03-11 03:55:26.000000000 +0100
+++ linux-2.6.4/mm/swap_state.c	2004-03-15 10:37:21.212321347 +0100
@@ -19,6 +19,7 @@
 static struct backing_dev_info swap_backing_dev_info = {
 	.ra_pages	= 0,	/* No readahead */
 	.memory_backed	= 1,	/* Does not contribute to dirty memory */
+	.unplug_io_fn	= swap_unplug_io_fn,
 };
 
 extern struct address_space_operations swap_aops;
