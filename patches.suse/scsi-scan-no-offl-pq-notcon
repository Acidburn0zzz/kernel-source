garloff@suse.de

Bugfix

Don't mark devices with PQ = 1 (or 3) offline, as they can't be accessed
at all then any more, not even by sg.
Instead check in scsi_bus_attach and don't attach any other high level
driver if PQ != 0.
SPC3, 7.4.2.

 linux-2.6.5.noattach/drivers/scsi/scsi_sysfs.c |    4 +++-
 linux-2.6.5.nooffline/drivers/scsi/scsi_scan.c |   14 ++++----------
 linux-2.6.5.nooffline/include/scsi/scsi.h      |    7 +++++++
 3 files changed, 14 insertions(+), 11 deletions(-)

diff -uNrp linux-2.6.5.replun/drivers/scsi/scsi_scan.c linux-2.6.5.nooffline/drivers/scsi/scsi_scan.c
--- linux-2.6.5.replun/drivers/scsi/scsi_scan.c	2004-04-21 14:26:31.000000000 +0200
+++ linux-2.6.5.nooffline/drivers/scsi/scsi_scan.c	2004-04-21 14:28:13.000000000 +0200
@@ -542,16 +542,10 @@ static int scsi_add_lun(struct scsi_devi
 	 * 011 the same. Stay compatible with previous code, and create a
 	 * Scsi_Device for a PQ of 1
 	 *
-	 * XXX Save the PQ field let the upper layers figure out if they
-	 * want to attach or not to this device, do not set online FALSE;
-	 * otherwise, offline devices still get an sd allocated, and they
-	 * use up an sd slot.
-	 */
-	if (((inq_result[0] >> 5) & 7) == 1) {
-		SCSI_LOG_SCAN_BUS(3, printk(KERN_INFO "scsi scan: peripheral"
-				" qualifier of 1, device offlined\n"));
-		sdev->online = FALSE;
-	}
+	 * Don't set the device offline here; rather let the upper
+	 * level drivers eval the PQ to decide whether they should
+	 * attach. So remove ((inq_result[0] >> 5) & 7) == 1 check.
+	 */ 
 
 	sdev->removable = (0x80 & inq_result[1]) >> 7;
 	sdev->lockable = sdev->removable;
diff -uNrp linux-2.6.5.replun/include/scsi/scsi.h linux-2.6.5.nooffline/include/scsi/scsi.h
--- linux-2.6.5.replun/include/scsi/scsi.h	2004-04-20 21:51:40.000000000 +0200
+++ linux-2.6.5.nooffline/include/scsi/scsi.h	2004-04-21 14:28:13.000000000 +0200
@@ -365,6 +365,13 @@ struct scsi_lun {
 #define SCSI_2          3
 #define SCSI_3          4
 
+/*
+ * INQ PERIPHERAL QUALIFIERS
+ */
+#define SCSI_INQ_PQ_CON         0x00
+#define SCSI_INQ_PQ_NOT_CON     0x01
+#define SCSI_INQ_PQ_NOT_CAP     0x03
+
 
 /*
  * Here are some scsi specific ioctl commands which are sometimes useful.
diff -uNrp linux-2.6.5.attach/drivers/scsi/scsi_sysfs.c linux-2.6.5.noattach/drivers/scsi/scsi_sysfs.c
--- linux-2.6.5.attach/drivers/scsi/scsi_sysfs.c	2004-04-04 05:36:26.000000000 +0200
+++ linux-2.6.5.noattach/drivers/scsi/scsi_sysfs.c	2004-04-21 17:22:22.000000000 +0200
@@ -155,7 +155,9 @@ struct class sdev_class = {
 /* all probing is done in the individual ->probe routines */
 static int scsi_bus_match(struct device *dev, struct device_driver *gendrv)
 {
-	return 1;
+	struct scsi_device *sdp = to_scsi_device(dev);
+	int pq = (sdp->inquiry[0] >> 5) & 7;
+	return (pq == SCSI_INQ_PQ_CON)? 1: 0;
 }
 
 struct bus_type scsi_bus_type = {
