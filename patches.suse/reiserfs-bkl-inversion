From: Chris Mason <mason@suse.com>
Subject: fix reiserfs lock inversion of bkl vs inode semaphore
References: 116531

The correct lock ordering is inode lock -> BKL

Index: linux-2.6.13/fs/reiserfs/file.c
===================================================================
--- linux-2.6.13.orig/fs/reiserfs/file.c
+++ linux-2.6.13/fs/reiserfs/file.c
@@ -48,8 +48,8 @@ static int reiserfs_file_release(struct 
 		return 0;
 	}
 
-	reiserfs_write_lock(inode->i_sb);
 	down(&inode->i_sem);
+	reiserfs_write_lock(inode->i_sb);
 	/* freeing preallocation only involves relogging blocks that
 	 * are already in the current transaction.  preallocation gets
 	 * freed at the end of each transaction, so it is impossible for
Index: linux-2.6.13/fs/reiserfs/inode.c
===================================================================
--- linux-2.6.13.orig/fs/reiserfs/inode.c
+++ linux-2.6.13/fs/reiserfs/inode.c
@@ -35,11 +35,11 @@ void reiserfs_delete_inode(struct inode 
 
 	truncate_inode_pages(&inode->i_data, 0);
 
-	reiserfs_write_lock(inode->i_sb);
 
 	/* The = 0 happens when we abort creating a new inode for some reason like lack of space.. */
 	if (!(inode->i_state & I_NEW) && INODE_PKEY(inode)->k_objectid != 0) {	/* also handles bad_inode case */
 		down(&inode->i_sem);
+		reiserfs_write_lock(inode->i_sb);
 
 		reiserfs_delete_xattrs(inode);
 
@@ -72,6 +72,7 @@ void reiserfs_delete_inode(struct inode 
 	} else {
 		/* no object items are in the tree */
 		;
+		reiserfs_write_lock(inode->i_sb);
 	}
       out:
 	clear_inode(inode);	/* note this must go after the journal_end to prevent deadlock */
Index: linux-2.6.13/fs/reiserfs/ioctl.c
===================================================================
--- linux-2.6.13.orig/fs/reiserfs/ioctl.c
+++ linux-2.6.13/fs/reiserfs/ioctl.c
@@ -115,12 +115,12 @@ static int reiserfs_unpack(struct inode 
 	if (REISERFS_I(inode)->i_flags & i_nopack_mask) {
 		return 0;
 	}
-	reiserfs_write_lock(inode->i_sb);
 
 	/* we need to make sure nobody is changing the file size beneath
 	 ** us
 	 */
 	down(&inode->i_sem);
+	reiserfs_write_lock(inode->i_sb);
 
 	write_from = inode->i_size & (blocksize - 1);
 	/* if we are on a block boundary, we are already unpacked.  */
