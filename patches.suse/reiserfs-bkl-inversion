From: Chris Mason <mason@suse.com>
Subject: fix reiserfs lock inversion of bkl vs inode semaphore
References: 116531

The correct lock ordering is inode lock -> BKL

diff -r 7bc691a043f6 fs/reiserfs/file.c
--- a/fs/reiserfs/file.c	Mon Sep 12 16:47:19 2005
+++ b/fs/reiserfs/file.c	Mon Sep 12 12:52:32 2005
@@ -48,8 +48,8 @@
 		return 0;
 	}
 
+	down(&inode->i_sem);
 	reiserfs_write_lock(inode->i_sb);
-	down(&inode->i_sem);
 	/* freeing preallocation only involves relogging blocks that
 	 * are already in the current transaction.  preallocation gets
 	 * freed at the end of each transaction, so it is impossible for
diff -r 7bc691a043f6 fs/reiserfs/inode.c
--- a/fs/reiserfs/inode.c	Mon Sep 12 16:47:19 2005
+++ b/fs/reiserfs/inode.c	Mon Sep 12 12:52:32 2005
@@ -35,11 +35,11 @@
 
 	truncate_inode_pages(&inode->i_data, 0);
 
-	reiserfs_write_lock(inode->i_sb);
 
 	/* The = 0 happens when we abort creating a new inode for some reason like lack of space.. */
 	if (!(inode->i_state & I_NEW) && INODE_PKEY(inode)->k_objectid != 0) {	/* also handles bad_inode case */
 		down(&inode->i_sem);
+		reiserfs_write_lock(inode->i_sb);
 
 		reiserfs_delete_xattrs(inode);
 
@@ -72,6 +72,7 @@
 	} else {
 		/* no object items are in the tree */
 		;
+		reiserfs_write_lock(inode->i_sb);
 	}
       out:
 	clear_inode(inode);	/* note this must go after the journal_end to prevent deadlock */
diff -r 7bc691a043f6 fs/reiserfs/ioctl.c
--- a/fs/reiserfs/ioctl.c	Mon Sep 12 16:47:19 2005
+++ b/fs/reiserfs/ioctl.c	Mon Sep 12 12:52:32 2005
@@ -115,12 +115,12 @@
 	if (REISERFS_I(inode)->i_flags & i_nopack_mask) {
 		return 0;
 	}
-	reiserfs_write_lock(inode->i_sb);
 
 	/* we need to make sure nobody is changing the file size beneath
 	 ** us
 	 */
 	down(&inode->i_sem);
+	reiserfs_write_lock(inode->i_sb);
 
 	write_from = inode->i_size & (blocksize - 1);
 	/* if we are on a block boundary, we are already unpacked.  */
