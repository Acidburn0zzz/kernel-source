From: Balbir Singh <balbir@in.ibm.com>
Subject: delayacct: account real vs virtual CPU usage
References: 141936 - LTC20517-LDP 11943

This patch splits cpu_run_total into cpu_run_real_total and
cpu_run_virtual_total. cpu_run_real_total is calculated using the tasks
utime and stime values. cpu_run_virtual_total is calculated using the
stats received from sched_info for the task.

Signed-off-by: Shailabh Nagar <nagar@watson.ibm.com>
Acked-by: okir@suse.de

 include/linux/taskstats.h |   10 ++++++++--
 kernel/delayacct.c        |   12 +++++++++---
 2 files changed, 17 insertions(+), 5 deletions(-)

Index: build/include/linux/taskstats.h
===================================================================
--- build.orig/include/linux/taskstats.h
+++ build/include/linux/taskstats.h
@@ -46,8 +46,14 @@ struct taskstats {
 	__u64	swapin_count;
 	__u64	swapin_delay_total;	/* swapin page fault wait*/
 
-	__u64	cpu_run_total;		/* cpu running time
-					 * no count available/provided */
+	__u64	cpu_run_real_total;	/* cpu "wall-clock" running time
+					 * Potentially accounts for cpu
+					 * virtualization, on some arches
+					 */
+	__u64	cpu_run_virtual_total;	/* cpu "virtual" running time
+					 * Uses time intervals as seen by
+					 * the kernel
+					 */
 };
 
 
Index: build/kernel/delayacct.c
===================================================================
--- build.orig/kernel/delayacct.c
+++ build/kernel/delayacct.c
@@ -123,17 +123,18 @@ int __delayacct_add_tsk(struct taskstats
 {
 	nsec_t tmp;
 	struct timespec ts;
-	unsigned long t1,t2;
+	unsigned long t1,t2,t3;
 
 	/* zero XXX_total,non-zero XXX_count implies XXX stat overflowed */
 
-	tmp = (nsec_t)d->cpu_run_total ;
+	tmp = (nsec_t)d->cpu_run_real_total ;
 	tmp += (u64)(tsk->utime+tsk->stime)*TICK_NSEC;
-	d->cpu_run_total = (tmp < (nsec_t)d->cpu_run_total)? 0: tmp;
+	d->cpu_run_real_total = (tmp < (nsec_t)d->cpu_run_real_total)? 0: tmp;
 
 	/* No locking available for sched_info. Take snapshot first. */
 	t1 = tsk->sched_info.pcnt;
 	t2 = tsk->sched_info.run_delay;
+	t3 = tsk->sched_info.cpu_time;
 
 	d->cpu_count += t1;
 
@@ -141,6 +142,11 @@ int __delayacct_add_tsk(struct taskstats
 	tmp = (nsec_t)d->cpu_delay_total + timespec_to_ns(&ts);
 	d->cpu_delay_total = (tmp < (nsec_t)d->cpu_delay_total)? 0: tmp;
 
+	tmp = (nsec_t)d->cpu_run_virtual_total
+		+ (nsec_t)jiffies_to_usecs(t3) * 1000;
+	d->cpu_run_virtual_total = (tmp < (nsec_t)d->cpu_run_virtual_total) ?
+					0 : tmp;
+
 	spin_lock(&tsk->delays->lock);
 	tmp = d->blkio_delay_total + tsk->delays->blkio_delay;
 	d->blkio_delay_total = (tmp < d->blkio_delay_total)? 0: tmp;
