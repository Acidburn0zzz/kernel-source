bug 42038, try to avoid page faults while a transaction is running
in reiserfs_file_write, they will try to grab the mmap_sem, which 
can lead to a lock inversion deadlock.

Index: linux.t/fs/reiserfs/file.c
===================================================================
--- linux.t.orig/fs/reiserfs/file.c	2004-06-21 10:50:28.000000000 -0400
+++ linux.t/fs/reiserfs/file.c	2004-06-22 11:20:07.000000000 -0400
@@ -601,6 +601,27 @@ void reiserfs_unprepare_pages(struct pag
     }
 }
 
+static void prefault_pages_for_write(loff_t pos, const char *buf, 
+                                     size_t count)
+{
+    unsigned long off;
+    unsigned long bytes;
+
+    /* looks like fault_in_pages_readable only does 1 page, so lets make
+     * a loop
+     */
+    do {
+	off = (pos & (PAGE_CACHE_SIZE - 1));
+	bytes = PAGE_CACHE_SIZE - off;
+	if (bytes > count)
+	    bytes = count;
+	fault_in_pages_readable(buf, bytes);
+        count -= bytes;
+	buf += bytes;
+	pos += bytes;
+    } while(count > 0);
+}
+
 /* This function will copy data from userspace to specified pages within
    supplied byte range */
 int reiserfs_copy_from_user_to_file_region(
@@ -1318,6 +1339,10 @@ ssize_t reiserfs_file_write( struct file
 	reiserfs_release_claimed_blocks(inode->i_sb, (num_pages << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits)) - blocks_to_allocate );
 
 	if ( blocks_to_allocate > 0) {/*We only allocate blocks if we need to*/
+	    /* we don't want page faults once the transaction is running,
+	     * so force prefaulting now.
+	     */
+	    prefault_pages_for_write(pos, buf, count);
 	    /* Fill in all the possible holes and append the file if needed */
 	    res = reiserfs_allocate_blocks_for_region(&th, inode, pos, num_pages, write_bytes, prepared_pages, blocks_to_allocate);
 	} 
