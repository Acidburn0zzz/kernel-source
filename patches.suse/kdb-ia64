From: Keith Owens <kaos@sgi.com>
Subject: Announce: kdb v4.4 is available for kernel 2.6.10

KDB (Linux Kernel Debugger) has been updated.

ftp://oss.sgi.com/projects/kdb/download/v4.4/
ftp://ftp.ocs.com.au/pub/mirrors/oss.sgi.com/projects/kdb/download/v4.4/

Current versions are :-

  kdb-v4.4-2.6.10-common-1.bz2
  kdb-v4.4-2.6.10-i386-1.bz2
  kdb-v4.4-2.6.10-ia64-1.bz2
  kdb-v4.4-2.6.9-rc2-x86-64-1.bz2 (may or may not work with 2.6.10).

Acked-by: schwab@suse.de

Index: linux/arch/ia64/Kconfig.debug
===================================================================
--- linux.orig/arch/ia64/Kconfig.debug	2005-01-20 11:09:53.000000000 +1100
+++ linux/arch/ia64/Kconfig.debug	2005-01-20 11:12:36.000000000 +1100
@@ -56,6 +56,87 @@ config IA64_DEBUG_IRQ
 	  and restore instructions.  It's useful for tracking down spinlock
 	  problems, but slow!  If you're unsure, select N.
 
+config KDB
+	bool "Built-in Kernel Debugger support"
+	depends on DEBUG_KERNEL
+	select KALLSYMS
+	select KALLSYMS_ALL
+	help
+	  This option provides a built-in kernel debugger.  The built-in
+	  kernel debugger contains commands which allow memory to be examined,
+	  instructions to be disassembled and breakpoints to be set.  For details,
+	  see Documentation/kdb/kdb.mm and the manual pages kdb_bt, kdb_ss, etc.
+	  Kdb can also be used via the serial port.  Set up the system to
+	  have a serial console (see Documentation/serial-console.txt).
+	  The key sequence <escape>KDB on the serial port will cause the
+	  kernel debugger to be entered with input from the serial port and
+	  output to the serial console.  If unsure, say N.
+
+config KDB_MODULES
+	tristate "KDB modules"
+	depends on KDB
+	help
+	  KDB can be extended by adding your own modules, in directory
+	  kdb/modules.  This option selects the way that these modules should
+	  be compiled, as free standing modules (select M) or built into the
+	  kernel (select Y).  If unsure say M.
+
+config KDB_OFF
+	bool "KDB off by default"
+	depends on KDB
+	help
+	  Normally kdb is activated by default, as long as CONFIG_KDB is set.
+	  If you want to ship a kernel with kdb support but only have kdb
+	  turned on when the user requests it then select this option.  When
+	  compiled with CONFIG_KDB_OFF, kdb ignores all events unless you boot
+	  with kdb=on or you echo "1" > /proc/sys/kernel/kdb.  This option also
+	  works in reverse, if kdb is normally activated, you can boot with
+	  kdb=off or echo "0" > /proc/sys/kernel/kdb to deactivate kdb. If
+	  unsure, say N.
+
+config KDB_CONTINUE_CATASTROPHIC
+	int "KDB continues after catastrophic errors"
+	depends on KDB
+	default "0"
+	help
+	  This integer controls the behaviour of kdb when the kernel gets a
+	  catastrophic error, i.e. for a panic, oops, NMI or other watchdog
+	  tripping.  CONFIG_KDB_CONTINUE_CATASTROPHIC interacts with
+	  /proc/sys/kernel/kdb and CONFIG_DUMP (if your kernel has the LKCD
+	  patch).
+	  When KDB is active (/proc/sys/kernel/kdb == 1) and a catastrophic
+	  error occurs, nothing extra happens until you type 'go'.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 0 (default).  The first time
+	  you type 'go', kdb warns you.  The second time you type 'go', KDB
+	  tries to continue - no guarantees that the kernel is still usable.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 1.  KDB tries to continue - no
+	  guarantees that the kernel is still usable.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 2.  If your kernel has the LKCD
+	  patch and LKCD is configured to take a dump then KDB forces a dump.
+	  Whether or not a dump is taken, KDB forces a reboot.
+	  When KDB is not active (/proc/sys/kernel/kdb == 0) and a catastrophic
+	  error occurs, the following steps are automatic, no human
+	  intervention is required.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 0 (default) or 1.  KDB attempts
+	  to continue - no guarantees that the kernel is still usable.
+	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 2.  If your kernel has the LKCD
+	  patch and LKCD is configured to take a dump then KDB automatically
+	  forces a dump.  Whether or not a dump is taken, KDB forces a
+	  reboot.
+	  If you are not sure, say 0.  Read Documentation/kdb/dump.txt before
+	  setting to 2.
+
+# KDB_USB does not work, the usb code needs to be
+# converted from 2.4.19 to 2.5.40 APIs.  Omit it until somebody
+# fixes CONFIG_KDB_USB.
+#config KDB_USB
+#	bool "Support for USB Keyboard in KDB"
+#	depends on KDB && USB
+#	help
+#	  If you want to use kdb from a USB keyboard then say Y here.  If you
+#	  say N then kdb can only be used from a PC (AT) keyboard or a serial
+#	  console.
+
 config SYSVIPC_COMPAT
 	bool
 	depends on COMPAT && SYSVIPC
Index: linux/arch/ia64/Makefile
===================================================================
--- linux.orig/arch/ia64/Makefile	2005-01-20 11:09:53.000000000 +1100
+++ linux/arch/ia64/Makefile	2005-01-20 11:12:36.000000000 +1100
@@ -60,6 +60,7 @@ core-$(CONFIG_IA64_HP_ZX1)	+= arch/ia64/
 core-$(CONFIG_IA64_HP_ZX1_SWIOTLB) += arch/ia64/dig/
 core-$(CONFIG_IA64_SGI_SN2)	+= arch/ia64/sn/
 
+drivers-$(CONFIG_KDB)		+= arch/$(ARCH)/kdb/
 drivers-$(CONFIG_PCI)		+= arch/ia64/pci/
 drivers-$(CONFIG_IA64_HP_SIM)	+= arch/ia64/hp/sim/
 drivers-$(CONFIG_IA64_HP_ZX1)	+= arch/ia64/hp/common/ arch/ia64/hp/zx1/
Index: linux/arch/ia64/kdb/ChangeLog
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/ChangeLog	2005-01-20 11:14:01.000000000 +1100
@@ -0,0 +1,352 @@
+2005-01-20 Keith Owens  <kaos@sgi.com>
+
+	* MCA and INIT stacks moved to per-cpu area.
+	* kdb-v4.4-2.6.11-rc1-bk7-ia64-1.
+
+2005-01-12 Keith Owens  <kaos@sgi.com>
+
+	* ia64_spinlock_contention_pre3_4_end is in base kernel, remove from kdb.
+	* Use last ditch allocator if unwind cannot allocate memory.
+	* kdb-v4.4-2.6.11-rc1-ia64-1.
+
+2004-12-25 Keith Owens  <kaos@sgi.com>
+
+	* Add cpuinfo command.
+	* kdb-v4.4-2.6.10-ia64-1.
+
+2004-12-07 Keith Owens  <kaos@sgi.com>
+
+	* Clean up error path in kdba_mca_init.
+	* kdb-v4.4-2.6.10-rc3-ia64-1.
+
+2004-11-15 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.10-rc2-ia64-1.
+
+2004-10-29 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.10-rc1-ia64-1.
+
+2004-10-19 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-ia64-1.
+
+2004-10-12 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-rc4-ia64-1.
+
+2004-10-01 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-rc3-ia64-1.
+
+2004-09-30 Keith Owens  <kaos@sgi.com>
+
+	* Add stackdepth command.
+	* kdb-v4.4-2.6.9-rc2-ia64-3.
+
+2004-09-16 Keith Owens  <kaos@sgi.com>
+
+	* Fixes for current in region 5 instead of 7 (idle task on cpu 0).
+	* kdb-v4.4-2.6.9-rc2-ia64-2.
+
+2004-09-14 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-rc2-ia64-1.
+
+2004-08-27 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.9-rc1-ia64-1.
+
+2004-08-14 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.8-ia64-1.
+
+2004-08-12 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.8-rc4-ia64-1.
+
+2004-08-04 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.8-rc3-ia64-1.
+
+2004-07-18 Keith Owens  <kaos@sgi.com>
+
+	* New config name for SN serial console.
+	* kdb-v4.4-2.6.8-rc2-ia64-1.
+
+2004-07-12 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.8-rc1-ia64-1.
+
+2004-06-30 Keith Owens  <kaos@sgi.com>
+
+	* kdb-v4.4-2.6.7-ia64-040629-1.
+
+2004-06-16 Keith Owens  <kaos@sgi.com>
+
+	* Coexist with 2.6.7-ia64-040619.
+	* kdb-v4.4-2.6.7-ia64-040619-1.
+
+2004-06-16 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.7-ia64-1.
+
+2004-06-10 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.4-2.6.7-rc3-ia64-1.
+
+2004-06-09 Keith Owens  <kaos@sgi.com>
+
+	* Namespace clean up.  Mark code/variables as static when it is only
+	  used in one file, delete dead code/variables.
+	* Saved interrupt state requires long, not int.
+	* kdb v4.4-2.6.7-rc2-ia64-3.
+
+2004-06-08 Keith Owens  <kaos@sgi.com>
+
+	* Whitespace clean up, no code changes.
+	* kdb v4.4-2.6.7-rc2-2.
+
+2004-06-07 Keith Owens  <kaos@sgi.com>
+
+	* Force KALLSYMS and KALLSYMS_ALL for CONFIG_KDB.
+	* kdb v4.4-2.6.7-rc2-1.
+
+2004-06-06 Keith Owens  <kaos@sgi.com>
+
+	* Add standard archkdb commands.
+	* Move kdb_{get,put}userarea_size definitions to linux/kdb.h.
+	* kdb v4.4-2.6.6-ia64-040521-2.
+
+2004-05-25 Keith Owens  <kaos@sgi.com>
+
+	* Update Kconfig text.
+	* kdb v4.4-2.6.6-ia64-040521-1.
+
+2004-05-23 Keith Owens  <kaos@sgi.com>
+
+	* Move bfd.h and ansidecl.h from arch/$(ARCH)/kdb to include/asm-$(ARCH).
+	* ia64-opc.c needs kdbprivate.h after common reorganisation.
+	* Update copyright notices.
+	* kdb v4.4-2.6.6-ia64-1.
+
+2004-05-60 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.6-rc3-ia64-1.
+
+2004-05-60 Keith Owens  <kaos@sgi.com>
+
+	* Tweak WAR for backtrace through contended spinlocks.
+	* kdb v4.3-2.6.6-rc2-ia64-1.
+
+2004-04-30 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.6-rc1-ia64-1.
+
+2004-04-15 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.5-ia64-040413-1.
+
+2004-03-06 Keith Owens  <kaos@sgi.com>
+
+	* Use kdb_print for unwind debugging.
+	* kdb v4.3-2.6.4-rc2-ia64-1.
+
+2004-02-29 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.4-rc1-ia64-1.
+
+2004-02-18 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.6.3-ia64-1.
+
+2004-02-17 Keith Owens  <kaos@sgi.com>
+
+	* Reconcile 2.6-test versions from Xavier Bru (Bull), Greg Banks (SGI),
+	  Jim Houston (Concurrent Computer Corp).
+	* Reconcile with kdb v4.3-2.4.23-ia64-0312??-1.
+	* Reconcile with salinfo changes.
+	* Port WAR for backtrace from spinlock contention from 2.4 to 2.6.
+	* Merge PGS FIFO tweak with SERIAL_IO_MEM and concurrent support for
+	  multiple consoles (no USB consoles yet).
+	* Update pt_regs output to match the order of struct pt_regs.
+	* KDB wrappers for interrupts handlers now return the handler's return code.
+	* tpa and tpav commands from Anonymous.
+	* Reconcile with mca changes.
+	* Upgrade to 2.6.3-rc3.
+	* kdb v4.3-2.6.3-rc3-ia64-1.
+
+2003-10-22 Xavier Bru   <xavier.bru@bull.net>
+	* Merge to 2.6.0-test7
+2003-10-20 Philippe Garrigues <Philippe.Garrigues@bull.net>
+	* Enable FIFO in UART
+2003-09-08 Xavier Bru   <xavier.bru@bull.net>
+	* Merge to 2.6.0-test4
+2003-03-21 Xavier Bru <xavier.bru@bull.net>
+	* Merge kdb v4.0 on 2.5.64 ia64
+	* new kernel parameters support
+	* new kallsyms support
+
+2003-10-24 Keith Owens  <kaos@sgi.com>
+
+	* kdb v4.3-2.4.23-pre8-cset-1.1069.1.143-to-1.1108-ia64-1.
+
+2003-10-03 Keith Owens  <kaos@sgi.com>
+
+	* After MCA, copy the saved RSE registers from ia64_mca_bspstore to the
+	  stack of the failing process.
+	* Abort backtrace when we hit IVT, no unwind data which confuses
+	  unw_unwind().
+	* Workaround for backtrace through spinlock contention called from leaf
+	  functions.
+	* kdb v4.3-2.4.22-ia64-030909-1.
+
+2003-07-20 Keith Owens  <kaos@sgi.com>
+
+	* MCA rendezvous timeout affects kdb_wait_for_cpus_secs.
+	* Support SGI L1 console.
+	* kdb v4.3-2.4.21-ia64-030702-2.
+
+2003-07-08 Keith Owens  <kaos@sgi.com>
+
+	* print_symbol() in mca.c does something useful when kdb is installed.
+	* Unwind and SAL changes removed from kdb, they are in the base kernel.
+	* kdb v4.3-2.4.21-ia64-030702-1.
+
+2003-06-20 Keith Owens  <kaos@sgi.com>
+
+	* Add CONFIG_KDB_CONTINUE_CATASTROPHIC.
+	* Do not send IPI if the machine state does not require them.
+	* Correct definition of KDB_ENTER().
+	* Workaround for broken init monarch handler.
+	* Monarch cpu must get to kdb, even if it was interrupted in user space.
+	* Unwind fixes.
+	* Generalize ia64_spinlock_contention name.
+	* Add kdba_fru for SN machines.
+	* Correct test for cpu number.
+	* kdb v4.3-2.4.20-ia64-020821-1.
+
+2003-05-02 Keith Owens  <kaos@sgi.com>
+
+	* Add kdba_fp_value().
+	* Limit backtrace size to catch loops.
+	* Print spinlock name in ia64_spinlock_contention.
+	* Tweak INIT slave stack lock and handler.
+	* Add read/write access to user pages.  Vamsi Krishna S., IBM
+	* Rename cpu_is_online to cpu_online, as in 2.5.
+	* Clean up USB keyboard support.
+	* Clean up serial console support.
+	* kdb v4.2-2.4.20-ia64-020821-1.
+
+2003-04-04 Keith Owens  <kaos@sgi.com>
+
+	* Add support for INIT slave interrupts.
+	* Tell SAL to always rendezvous on MCA.
+	* No lock on SAL rendezvous call.
+	* Include unwind.c from 2.4.21-pre5.
+	* Rename cpu_online to cpu_is_online.
+	* Workarounds for scheduler bugs.
+	* kdb v4.1-2.4.20-ia64-020821-1.
+
+2003-03-16 Keith Owens  <kaos@sgi.com>
+
+	* Each cpu saves its state as it enters kdb or before it enters code
+	  which cannot call kdb, converting kdb from a pull to a push model.
+	* Clean up kdb interaction with CONFIG_SERIAL_CONSOLE.
+	* Removal of special cases for i386 backtrace from common code
+	  simplifies the architecture code.
+	* Add support for MCA events (both main and rendezvous) plus INIT
+	  monarch event.
+	* Correct decode of brl.
+	* Move kdba_print_nameval to common code.
+	* Generalize kdba unwind handlers.
+	* Fix decode of sal records (fix included in later ia64 kernels).
+	* Handle multiple pt_regs in stack (fix included in later ia64 kernels).
+	* Clean up debug code in unwind (fix included in later ia64 kernels).
+	* Move kdb break numbers to their own file so it can be used in asm.
+	* kdb v4.0-2.4.20-ia64-021210-1.
+
+2003-02-03 Keith Owens  <kaos@sgi.com>
+
+	* Register kdb commands early.
+	* Handle KDB_ENTER() when kdb=off.
+	* Optimize __kdba_getarea_size when width is a constant.
+	* Decode oops via kallsyms if it is available.
+	* Update copyright notices to 2003.
+	* Add commands to dump struct pt_regs and switch_stack.
+	* Handle padding from unw_init_running for switch_stack.
+	* Add dummy kdba_local_arch_setup/kdba_local_arch_cleanup.
+	* Warning for pod mode.
+	* Add command history and editing.  Sonic Zhang.
+	* kdb_toggleled is conditional on KDB_BLINK_LED.  Bernhard Fischer.
+	* Allow tab on serial line for symbol completion.
+	* Ignore KDB_ENTER() when kdb is already running.
+	* kdb v3.0-2.4.20-ia64-021210-1.
+
+2003-01-23 Keith Owens  <kaos@sgi.com>
+
+	* Upgrade to 2.4.20-ia64-021210.
+	* kdb v2.5-2.4.20-ia64-021210-1.
+
+2002-11-14 Keith Owens  <kaos@sgi.com>
+
+	* General clean up of handling for breakpoints and single stepping over
+	  software breakpoints.
+	* kdb v2.5-2.4.19-ia64-020821-1.
+
+2002-10-31 Keith Owens  <kaos@sgi.com>
+
+	* Remove kdb_eframe_t.
+	* Sanity check if we have pt_regs.
+	* Remove kdba_getcurrentframe().
+	* Comments for coexistence with O(1) scheduler.
+	* kdb v2.4-2.4.19-ia64-020821-1.
+
+2002-10-15 Keith Owens  <kaos@sgi.com>
+
+	* Minimize differences between patches for 2.4 and 2.5 kernels.
+	* kdb v2.3-2.4.19-ia64-020821-2.
+
+2002-08-10 Keith Owens  <kaos@sgi.com>
+
+	* Verify rw address for instruction breakpoint.
+	* Replace kdb_port with kdb_serial to support memory mapped I/O.
+	  David Mosberger.
+	  Note: This needs kdb v2.3-2.4.18-common-2 or later.
+	* kdb v2.3-2.4.18-ia64-020722-2.
+
+2002-08-07 Keith Owens  <kaos@sgi.com>
+
+	* Upgrade to 2.4.18-ia64-020722.
+	* Remove individual SGI copyrights, the general SGI copyright applies.
+	* Clean up disassembly layout.  Hugh Dickins, Keith Owens.
+	* Remove fixed KDB_MAX_COMMANDS size.
+	* Add set_fs() around __copy_to_user on kernel addresses.
+	  Randolph Chung.
+	* Position ia64 for CONFIG_NUMA_REPLICATE.
+	* Stacked registers modification support.  Sebastien Lelarge.
+	* USB keyboard support.  Sebastien Lelarge.
+	* kdb v2.3-2.4.18-ia64-020722-1.
+
+2002-03-20 Keith Owens  <kaos@sgi.com>
+
+	* Sync with 2.4.17-sn2.
+	* Add pod command.
+
+2002-02-20 Keith Owens  <kaos@sgi.com>
+
+	* Call kdb from mca handler.  Jenna S. Hall, Intel.
+	* kdb v2.1-2.4.17-ia64-011226-2.
+
+2002-01-18 Keith Owens  <kaos@sgi.com>
+
+	* Replace kdb_get/putword with kdb_get/putarea functions.
+	* Wrap kdb references in #ifdef CONFIG_KDB.
+	* Delete sample i386 code.
+	* Refuse to update kernel text on NUMA systems.
+	* Reject hardware breakpoints, not supported yet.
+	* kdb v2.1-2.4.17-ia64-011226-1.
+
+2002-01-07 Keith Owens  <kaos@sgi.com>
+
+	* Split kdb for ia64 as kdb v2.0-2.4.17-ia64-011226-1.
Index: linux/arch/ia64/kdb/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/Makefile	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,20 @@
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+#
+
+obj-y	 := kdba_bt.o kdba_bp.o kdba_io.o kdbasupport.o \
+	    cpu-ia64-opc.o ia64-dis.o ia64-opc.o kdba_id.o kdba_jmp.o
+
+# fru does not compile on 2.6.
+# obj-$(CONFIG_IA64_SGI_SN2) += kdba_fru.o
+obj-$(CONFIG_IA64_SGI_SN2) += kdba_pod.o
+
+override CFLAGS := $(CFLAGS:%-pg=% )
+
+AFLAGS_kdba_jmp.o += $(AFLAGS_KERNEL)
+
+USE_STANDARD_AS_RULE	:= true
Index: linux/arch/ia64/kdb/cpu-ia64-opc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/cpu-ia64-opc.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,586 @@
+/* Copyright (C) 1998, 1999  Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+
+/* Logically, this code should be part of libopcode but since some of
+   the operand insertion/extraction functions help bfd to implement
+   relocations, this code is included as part of elf64-ia64.c.  This
+   avoids circular dependencies between libopcode and libbfd and also
+   obviates the need for applications to link in libopcode when all
+   they really want is libbfd.
+
+   --davidm Mon Apr 13 22:14:02 1998 */
+
+#include "ia64-opc.h"
+
+#define NELEMS(a)  ((int) (sizeof (a) / sizeof ((a)[0])))
+
+static const char*
+ins_rsvd (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return "internal error---this shouldn't happen";
+}
+
+static const char*
+ext_rsvd (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return "internal error---this shouldn't happen";
+}
+
+static const char*
+ins_const (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return 0;
+}
+
+static const char*
+ext_const (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return 0;
+}
+
+static const char*
+ins_reg (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  if (value >= 1u << self->field[0].bits)
+    return "register number out of range";
+
+  *code |= value << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_reg (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  *valuep = ((code >> self->field[0].shift)
+	     & ((1u << self->field[0].bits) - 1));
+  return 0;
+}
+
+static const char*
+ins_immu (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  ia64_insn new = 0;
+  int i;
+
+  for (i = 0; i < NELEMS (self->field) && self->field[i].bits; ++i)
+    {
+      new |= ((value & ((((ia64_insn) 1) << self->field[i].bits) - 1))
+	      << self->field[i].shift);
+      value >>= self->field[i].bits;
+    }
+  if (value)
+    return "integer operand out of range";
+
+  *code |= new;
+  return 0;
+}
+
+static const char*
+ext_immu (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  BFD_HOST_U_64_BIT value = 0;
+  int i, bits = 0, total = 0;
+
+  for (i = 0; i < NELEMS (self->field) && self->field[i].bits; ++i)
+    {
+      bits = self->field[i].bits;
+      value |= ((code >> self->field[i].shift)
+		& ((((BFD_HOST_U_64_BIT) 1) << bits) - 1)) << total;
+      total += bits;
+    }
+  *valuep = value;
+  return 0;
+}
+
+static const char*
+ins_immus8 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  if (value & 0x7)
+    return "value not an integer multiple of 8";
+  return ins_immu (self, value >> 3, code);
+}
+
+static const char*
+ext_immus8 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  const char *result;
+
+  result = ext_immu (self, code, valuep);
+  if (result)
+    return result;
+
+  *valuep = *valuep << 3;
+  return 0;
+}
+
+static const char*
+ins_imms_scaled (const struct ia64_operand *self, ia64_insn value,
+		 ia64_insn *code, int scale)
+{
+  BFD_HOST_64_BIT svalue = value, sign_bit = 0;
+  ia64_insn new = 0;
+  int i;
+
+  svalue >>= scale;
+
+  for (i = 0; i < NELEMS (self->field) && self->field[i].bits; ++i)
+    {
+      new |= ((svalue & ((((ia64_insn) 1) << self->field[i].bits) - 1))
+	      << self->field[i].shift);
+      sign_bit = (svalue >> (self->field[i].bits - 1)) & 1;
+      svalue >>= self->field[i].bits;
+    }
+  if ((!sign_bit && svalue != 0) || (sign_bit && svalue != -1))
+    return "integer operand out of range";
+
+  *code |= new;
+  return 0;
+}
+
+static const char*
+ext_imms_scaled (const struct ia64_operand *self, ia64_insn code,
+		 ia64_insn *valuep, int scale)
+{
+  int i, bits = 0, total = 0, shift;
+  BFD_HOST_64_BIT val = 0;
+
+  for (i = 0; i < NELEMS (self->field) && self->field[i].bits; ++i)
+    {
+      bits = self->field[i].bits;
+      val |= ((code >> self->field[i].shift)
+	      & ((((BFD_HOST_U_64_BIT) 1) << bits) - 1)) << total;
+      total += bits;
+    }
+  /* sign extend: */
+  shift = 8*sizeof (val) - total;
+  val = (val << shift) >> shift;
+
+  *valuep = (val << scale);
+  return 0;
+}
+
+static const char*
+ins_imms (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return ins_imms_scaled (self, value, code, 0);
+}
+
+static const char*
+ins_immsu4 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  if (value == (BFD_HOST_U_64_BIT) 0x100000000)
+    value = 0;
+  else
+    value = (((BFD_HOST_64_BIT)value << 32) >> 32);
+
+  return ins_imms_scaled (self, value, code, 0);
+}
+
+static const char*
+ext_imms (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return ext_imms_scaled (self, code, valuep, 0);
+}
+
+static const char*
+ins_immsm1 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  --value;
+  return ins_imms_scaled (self, value, code, 0);
+}
+
+static const char*
+ins_immsm1u4 (const struct ia64_operand *self, ia64_insn value,
+	      ia64_insn *code)
+{
+  if (value == (BFD_HOST_U_64_BIT) 0x100000000)
+    value = 0;
+  else
+    value = (((BFD_HOST_64_BIT)value << 32) >> 32);
+
+  --value;
+  return ins_imms_scaled (self, value, code, 0);
+}
+
+static const char*
+ext_immsm1 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  const char *res = ext_imms_scaled (self, code, valuep, 0);
+
+  ++*valuep;
+  return res;
+}
+
+static const char*
+ins_imms1 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return ins_imms_scaled (self, value, code, 1);
+}
+
+static const char*
+ext_imms1 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return ext_imms_scaled (self, code, valuep, 1);
+}
+
+static const char*
+ins_imms4 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return ins_imms_scaled (self, value, code, 4);
+}
+
+static const char*
+ext_imms4 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return ext_imms_scaled (self, code, valuep, 4);
+}
+
+static const char*
+ins_imms16 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  return ins_imms_scaled (self, value, code, 16);
+}
+
+static const char*
+ext_imms16 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  return ext_imms_scaled (self, code, valuep, 16);
+}
+
+static const char*
+ins_cimmu (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  ia64_insn mask = (((ia64_insn) 1) << self->field[0].bits) - 1;
+  return ins_immu (self, value ^ mask, code);
+}
+
+static const char*
+ext_cimmu (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  const char *result;
+  ia64_insn mask;
+
+  mask = (((ia64_insn) 1) << self->field[0].bits) - 1;
+  result = ext_immu (self, code, valuep);
+  if (!result)
+    {
+      mask = (((ia64_insn) 1) << self->field[0].bits) - 1;
+      *valuep ^= mask;
+    }
+  return result;
+}
+
+static const char*
+ins_cnt (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  --value;
+  if (value >= ((BFD_HOST_U_64_BIT) 1) << self->field[0].bits)
+    return "count out of range";
+
+  *code |= value << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_cnt (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  *valuep = ((code >> self->field[0].shift)
+	     & ((((BFD_HOST_U_64_BIT) 1) << self->field[0].bits) - 1)) + 1;
+  return 0;
+}
+
+static const char*
+ins_cnt2b (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  --value;
+
+  if (value > 2)
+    return "count must be in range 1..3";
+
+  *code |= value << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_cnt2b (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  *valuep = ((code >> self->field[0].shift) & 0x3) + 1;
+  return 0;
+}
+
+static const char*
+ins_cnt2c (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  switch (value)
+    {
+    case 0:	value = 0; break;
+    case 7:	value = 1; break;
+    case 15:	value = 2; break;
+    case 16:	value = 3; break;
+    default:	return "count must be 0, 7, 15, or 16";
+    }
+  *code |= value << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_cnt2c (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  ia64_insn value;
+
+  value = (code >> self->field[0].shift) & 0x3;
+  switch (value)
+    {
+    case 0: value =  0; break;
+    case 1: value =  7; break;
+    case 2: value = 15; break;
+    case 3: value = 16; break;
+    }
+  *valuep = value;
+  return 0;
+}
+
+static const char*
+ins_inc3 (const struct ia64_operand *self, ia64_insn value, ia64_insn *code)
+{
+  BFD_HOST_64_BIT val = value;
+  BFD_HOST_U_64_BIT sign = 0;
+
+  if (val < 0)
+    {
+      sign = 0x4;
+      value = -value;
+    }
+  switch (value)
+    {
+    case  1:	value = 3; break;
+    case  4:	value = 2; break;
+    case  8:	value = 1; break;
+    case 16:	value = 0; break;
+    default:	return "count must be +/- 1, 4, 8, or 16";
+    }
+  *code |= (sign | value) << self->field[0].shift;
+  return 0;
+}
+
+static const char*
+ext_inc3 (const struct ia64_operand *self, ia64_insn code, ia64_insn *valuep)
+{
+  BFD_HOST_64_BIT val;
+  int negate;
+
+  val = (code >> self->field[0].shift) & 0x7;
+  negate = val & 0x4;
+  switch (val & 0x3)
+    {
+    case 0: val = 16; break;
+    case 1: val =  8; break;
+    case 2: val =  4; break;
+    case 3: val =  1; break;
+    }
+  if (negate)
+    val = -val;
+
+  *valuep = val;
+  return 0;
+}
+
+#define CST	IA64_OPND_CLASS_CST
+#define REG	IA64_OPND_CLASS_REG
+#define IND	IA64_OPND_CLASS_IND
+#define ABS	IA64_OPND_CLASS_ABS
+#define REL	IA64_OPND_CLASS_REL
+
+#define SDEC	IA64_OPND_FLAG_DECIMAL_SIGNED
+#define UDEC	IA64_OPND_FLAG_DECIMAL_UNSIGNED
+
+const struct ia64_operand elf64_ia64_operands[IA64_OPND_COUNT] =
+  {
+    /* constants: */
+    { CST, ins_const, ext_const, "NIL",		{{ 0, }}, 0, "<none>" },
+    { CST, ins_const, ext_const, "ar.ccv",	{{ 0, }}, 0, "ar.ccv" },
+    { CST, ins_const, ext_const, "ar.pfs",	{{ 0, }}, 0, "ar.pfs" },
+    { CST, ins_const, ext_const, "1",		{{ 0, }}, 0, "1" },
+    { CST, ins_const, ext_const, "8",		{{ 0, }}, 0, "1" },
+    { CST, ins_const, ext_const, "16",		{{ 0, }}, 0, "16" },
+    { CST, ins_const, ext_const, "r0",		{{ 0, }}, 0, "r0" },
+    { CST, ins_const, ext_const, "ip",		{{ 0, }}, 0, "ip" },
+    { CST, ins_const, ext_const, "pr",		{{ 0, }}, 0, "pr" },
+    { CST, ins_const, ext_const, "pr.rot",	{{ 0, }}, 0, "pr.rot" },
+    { CST, ins_const, ext_const, "psr",		{{ 0, }}, 0, "psr" },
+    { CST, ins_const, ext_const, "psr.l",	{{ 0, }}, 0, "psr.l" },
+    { CST, ins_const, ext_const, "psr.um",	{{ 0, }}, 0, "psr.um" },
+
+    /* register operands: */
+    { REG, ins_reg,   ext_reg,	"ar", {{ 7, 20}}, 0,		/* AR3 */
+      "an application register" },
+    { REG, ins_reg,   ext_reg,	 "b", {{ 3,  6}}, 0,		/* B1 */
+      "a branch register" },
+    { REG, ins_reg,   ext_reg,	 "b", {{ 3, 13}}, 0,		/* B2 */
+      "a branch register"},
+    { REG, ins_reg,   ext_reg,	"cr", {{ 7, 20}}, 0,		/* CR */
+      "a control register"},
+    { REG, ins_reg,   ext_reg,	 "f", {{ 7,  6}}, 0,		/* F1 */
+      "a floating-point register" },
+    { REG, ins_reg,   ext_reg,	 "f", {{ 7, 13}}, 0,		/* F2 */
+      "a floating-point register" },
+    { REG, ins_reg,   ext_reg,	 "f", {{ 7, 20}}, 0,		/* F3 */
+      "a floating-point register" },
+    { REG, ins_reg,   ext_reg,	 "f", {{ 7, 27}}, 0,		/* F4 */
+      "a floating-point register" },
+    { REG, ins_reg,   ext_reg,	 "p", {{ 6,  6}}, 0,		/* P1 */
+      "a predicate register" },
+    { REG, ins_reg,   ext_reg,	 "p", {{ 6, 27}}, 0,		/* P2 */
+      "a predicate register" },
+    { REG, ins_reg,   ext_reg,	 "r", {{ 7,  6}}, 0,		/* R1 */
+      "a general register" },
+    { REG, ins_reg,   ext_reg,	 "r", {{ 7, 13}}, 0,		/* R2 */
+      "a general register" },
+    { REG, ins_reg,   ext_reg,	 "r", {{ 7, 20}}, 0,		/* R3 */
+      "a general register" },
+    { REG, ins_reg,   ext_reg,	 "r", {{ 2, 20}}, 0,		/* R3_2 */
+      "a general register r0-r3" },
+
+    /* indirect operands: */
+    { IND, ins_reg,   ext_reg,	"cpuid", {{7, 20}}, 0,		/* CPUID_R3 */
+      "a cpuid register" },
+    { IND, ins_reg,   ext_reg,	"dbr",   {{7, 20}}, 0,		/* DBR_R3 */
+      "a dbr register" },
+    { IND, ins_reg,   ext_reg,	"dtr",   {{7, 20}}, 0,		/* DTR_R3 */
+      "a dtr register" },
+    { IND, ins_reg,   ext_reg,	"itr",   {{7, 20}}, 0,		/* ITR_R3 */
+      "an itr register" },
+    { IND, ins_reg,   ext_reg,	"ibr",   {{7, 20}}, 0,		/* IBR_R3 */
+      "an ibr register" },
+    { IND, ins_reg,   ext_reg,	"",      {{7, 20}}, 0,		/* MR3 */
+      "an indirect memory address" },
+    { IND, ins_reg,   ext_reg,	"msr",   {{7, 20}}, 0,		/* MSR_R3 */
+      "an msr register" },
+    { IND, ins_reg,   ext_reg,	"pkr",   {{7, 20}}, 0,		/* PKR_R3 */
+      "a pkr register" },
+    { IND, ins_reg,   ext_reg,	"pmc",   {{7, 20}}, 0,		/* PMC_R3 */
+      "a pmc register" },
+    { IND, ins_reg,   ext_reg,	"pmd",   {{7, 20}}, 0,		/* PMD_R3 */
+      "a pmd register" },
+    { IND, ins_reg,   ext_reg,	"rr",    {{7, 20}}, 0,		/* RR_R3 */
+      "an rr register" },
+
+    /* immediate operands: */
+    { ABS, ins_cimmu, ext_cimmu, 0, {{ 5, 20 }}, UDEC,		/* CCNT5 */
+      "a 5-bit count (0-31)" },
+    { ABS, ins_cnt,   ext_cnt,   0, {{ 2, 27 }}, UDEC,		/* CNT2a */
+      "a 2-bit count (1-4)" },
+    { ABS, ins_cnt2b, ext_cnt2b, 0, {{ 2, 27 }}, UDEC,		/* CNT2b */
+      "a 2-bit count (1-3)" },
+    { ABS, ins_cnt2c, ext_cnt2c, 0, {{ 2, 30 }}, UDEC,		/* CNT2c */
+      "a count (0, 7, 15, or 16)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 5, 14}}, UDEC,		/* CNT5 */
+      "a 5-bit count (0-31)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 6, 27}}, UDEC,		/* CNT6 */
+      "a 6-bit count (0-63)" },
+    { ABS, ins_cimmu, ext_cimmu, 0, {{ 6, 20}}, UDEC,		/* CPOS6a */
+      "a 6-bit bit pos (0-63)" },
+    { ABS, ins_cimmu, ext_cimmu, 0, {{ 6, 14}}, UDEC,		/* CPOS6b */
+      "a 6-bit bit pos (0-63)" },
+    { ABS, ins_cimmu, ext_cimmu, 0, {{ 6, 31}}, UDEC,		/* CPOS6c */
+      "a 6-bit bit pos (0-63)" },
+    { ABS, ins_imms,  ext_imms,  0, {{ 1, 36}}, SDEC,		/* IMM1 */
+      "a 1-bit integer (-1, 0)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 2, 13}}, UDEC,		/* IMMU2 */
+      "a 2-bit unsigned (0-3)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 7, 13}}, 0,		/* IMMU7a */
+      "a 7-bit unsigned (0-127)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 7, 20}}, 0,		/* IMMU7b */
+      "a 7-bit unsigned (0-127)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 7, 13}}, UDEC,		/* SOF */
+      "a frame size (register count)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 7, 20}}, UDEC,		/* SOL */
+      "a local register count" },
+    { ABS, ins_immus8,ext_immus8,0, {{ 4, 27}}, UDEC,		/* SOR */
+      "a rotating register count (integer multiple of 8)" },
+    { ABS, ins_imms,  ext_imms,  0,				/* IMM8 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit integer (-128-127)" },
+    { ABS, ins_immsu4,  ext_imms,  0,				/* IMM8U4 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit signed integer for 32-bit unsigned compare (-128-127)" },
+    { ABS, ins_immsm1,  ext_immsm1,  0,				/* IMM8M1 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit integer (-127-128)" },
+    { ABS, ins_immsm1u4,  ext_immsm1,  0,			/* IMM8M1U4 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit integer for 32-bit unsigned compare (-127-(-1),1-128,0x100000000)" },
+    { ABS, ins_immsm1,  ext_immsm1,  0,				/* IMM8M1U8 */
+      {{ 7, 13}, { 1, 36}}, SDEC,
+      "an 8-bit integer for 64-bit unsigned compare (-127-(-1),1-128,0x10000000000000000)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 2, 33}, { 7, 20}}, 0,	/* IMMU9 */
+      "a 9-bit unsigned (0-511)" },
+    { ABS, ins_imms,  ext_imms,  0,				/* IMM9a */
+      {{ 7,  6}, { 1, 27}, { 1, 36}}, SDEC,
+      "a 9-bit integer (-256-255)" },
+    { ABS, ins_imms,  ext_imms, 0,				/* IMM9b */
+      {{ 7, 13}, { 1, 27}, { 1, 36}}, SDEC,
+      "a 9-bit integer (-256-255)" },
+    { ABS, ins_imms,  ext_imms, 0,				/* IMM14 */
+      {{ 7, 13}, { 6, 27}, { 1, 36}}, SDEC,
+      "a 14-bit integer (-8192-8191)" },
+    { ABS, ins_imms1, ext_imms1, 0,				/* IMM17 */
+      {{ 7,  6}, { 8, 24}, { 1, 36}}, 0,
+      "a 17-bit integer (-65536-65535)" },
+    { ABS, ins_immu,  ext_immu,  0, {{20,  6}, { 1, 36}}, 0,	/* IMMU21 */
+      "a 21-bit unsigned" },
+    { ABS, ins_imms,  ext_imms,  0,				/* IMM22 */
+      {{ 7, 13}, { 9, 27}, { 5, 22}, { 1, 36}}, SDEC,
+      "a 22-bit integer" },
+    { ABS, ins_immu,  ext_immu,  0,				/* IMMU24 */
+      {{21,  6}, { 2, 31}, { 1, 36}}, 0,
+      "a 24-bit unsigned" },
+    { ABS, ins_imms16,ext_imms16,0, {{27,  6}, { 1, 36}}, 0,	/* IMM44 */
+      "a 44-bit unsigned (least 16 bits ignored/zeroes)" },
+    { ABS, ins_rsvd,  ext_rsvd,	0, {{0,  0}}, 0,		/* IMMU62 */
+      "a 62-bit unsigned" },
+    { ABS, ins_rsvd,  ext_rsvd,	0, {{0,  0}}, 0,		/* IMMU64 */
+      "a 64-bit unsigned" },
+    { ABS, ins_inc3,  ext_inc3,  0, {{ 3, 13}}, SDEC,		/* INC3 */
+      "an increment (+/- 1, 4, 8, or 16)" },
+    { ABS, ins_cnt,   ext_cnt,   0, {{ 4, 27}}, UDEC,		/* LEN4 */
+      "a 4-bit length (1-16)" },
+    { ABS, ins_cnt,   ext_cnt,   0, {{ 6, 27}}, UDEC,		/* LEN6 */
+      "a 6-bit length (1-64)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 4, 20}},	0,		/* MBTYPE4 */
+      "a mix type (@rev, @mix, @shuf, @alt, or @brcst)" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 8, 20}},	0,		/* MBTYPE8 */
+      "an 8-bit mix type" },
+    { ABS, ins_immu,  ext_immu,  0, {{ 6, 14}}, UDEC,		/* POS6 */
+      "a 6-bit bit pos (0-63)" },
+    { REL, ins_imms4, ext_imms4, 0, {{ 7,  6}, { 2, 33}}, 0,	/* TAG13 */
+      "a branch tag" },
+    { REL, ins_imms4, ext_imms4, 0, {{ 9, 24}}, 0,		/* TAG13b */
+      "a branch tag" },
+    { REL, ins_imms4, ext_imms4, 0, {{20,  6}, { 1, 36}}, 0,	/* TGT25 */
+      "a branch target" },
+    { REL, ins_imms4, ext_imms4, 0,				/* TGT25b */
+      {{ 7,  6}, {13, 20}, { 1, 36}}, 0,
+      "a branch target" },
+    { REL, ins_imms4, ext_imms4, 0, {{20, 13}, { 1, 36}}, 0,	/* TGT25c */
+      "a branch target" },
+    { REL, ins_rsvd, ext_rsvd, 0, {{0, 0}}, 0,                  /* TGT64  */
+      "a branch target" },
+  };
Index: linux/arch/ia64/kdb/ia64-asmtab.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/ia64-asmtab.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,6562 @@
+/* This file is automatically generated by ia64-gen.  Do not edit! */
+static const char *ia64_strings[] = {
+  "", "0", "1", "a", "acq", "add", "addl", "addp4", "adds", "alloc", "and",
+  "andcm", "b", "bias", "br", "break", "brl", "brp", "bsw", "c", "call",
+  "cexit", "chk", "cloop", "clr", "clrrrb", "cmp", "cmp4", "cmpxchg1",
+  "cmpxchg2", "cmpxchg4", "cmpxchg8", "cond", "cover", "ctop", "czx1",
+  "czx2", "d", "dc", "dep", "dpnt", "dptk", "e", "epc", "eq", "excl",
+  "exit", "exp", "extr", "f", "fabs", "fadd", "famax", "famin", "fand",
+  "fandcm", "fault", "fc", "fchkf", "fclass", "fclrf", "fcmp", "fcvt",
+  "fetchadd4", "fetchadd8", "few", "fill", "flushrs", "fma", "fmax",
+  "fmerge", "fmin", "fmix", "fmpy", "fms", "fneg", "fnegabs", "fnma",
+  "fnmpy", "fnorm", "for", "fpabs", "fpack", "fpamax", "fpamin", "fpcmp",
+  "fpcvt", "fpma", "fpmax", "fpmerge", "fpmin", "fpmpy", "fpms", "fpneg",
+  "fpnegabs", "fpnma", "fpnmpy", "fprcpa", "fprsqrta", "frcpa", "frsqrta",
+  "fselect", "fsetc", "fsub", "fswap", "fsxt", "fwb", "fx", "fxor", "fxu",
+  "g", "ga", "ge", "getf", "geu", "gt", "gtu", "h", "hu", "i", "ia", "imp",
+  "invala", "itc", "itr", "l", "ld1", "ld2", "ld4", "ld8", "ldf", "ldf8",
+  "ldfd", "ldfe", "ldfp8", "ldfpd", "ldfps", "ldfs", "le", "leu", "lfetch",
+  "loadrs", "loop", "lr", "lt", "ltu", "lu", "m", "many", "mf", "mix1",
+  "mix2", "mix4", "mov", "movl", "mux1", "mux2", "nc", "ne", "neq", "nge",
+  "ngt", "nl", "nle", "nlt", "nm", "nop", "nr", "ns", "nt", "nt1", "nt2",
+  "nta", "nz", "or", "orcm", "ord", "pack2", "pack4", "padd1", "padd2",
+  "padd4", "pavg1", "pavg2", "pavgsub1", "pavgsub2", "pcmp1", "pcmp2",
+  "pcmp4", "pmax1", "pmax2", "pmin1", "pmin2", "pmpy2", "pmpyshr2",
+  "popcnt", "pr", "probe", "psad1", "pshl2", "pshl4", "pshladd2", "pshr2",
+  "pshr4", "pshradd2", "psub1", "psub2", "psub4", "ptc", "ptr", "r", "raz",
+  "rel", "ret", "rfi", "rsm", "rum", "rw", "s", "s0", "s1", "s2", "s3",
+  "sa", "se", "setf", "shl", "shladd", "shladdp4", "shr", "shrp", "sig",
+  "spill", "spnt", "sptk", "srlz", "ssm", "sss", "st1", "st2", "st4", "st8",
+  "stf", "stf8", "stfd", "stfe", "stfs", "sub", "sum", "sxt1", "sxt2",
+  "sxt4", "sync", "tak", "tbit", "thash", "tk", "tnat", "tpa", "trunc",
+  "ttag", "u", "unc", "unord", "unpack1", "unpack2", "unpack4", "uss",
+  "uus", "uuu", "w", "wexit", "wtop", "x", "xchg1", "xchg2", "xchg4",
+  "xchg8", "xf", "xma", "xmpy", "xor", "xuf", "z", "zxt1", "zxt2", "zxt4",
+};
+
+static const struct ia64_dependency
+dependencies[] = {
+  { "ALAT", 0, 0, 0, -1, },
+  { "AR[BSP]", 25, 0, 2, 17, },
+  { "AR[BSPSTORE]", 25, 0, 2, 18, },
+  { "AR[CCV]", 25, 0, 2, 32, },
+  { "AR[EC]", 25, 0, 2, 66, },
+  { "AR[FPSR].sf0.controls", 29, 0, 2, -1, },
+  { "AR[FPSR].sf1.controls", 29, 0, 2, -1, },
+  { "AR[FPSR].sf2.controls", 29, 0, 2, -1, },
+  { "AR[FPSR].sf3.controls", 29, 0, 2, -1, },
+  { "AR[FPSR].sf0.flags", 29, 0, 2, -1, },
+  { "AR[FPSR].sf1.flags", 29, 0, 2, -1, },
+  { "AR[FPSR].sf2.flags", 29, 0, 2, -1, },
+  { "AR[FPSR].sf3.flags", 29, 0, 2, -1, },
+  { "AR[FPSR].traps", 29, 0, 2, -1, },
+  { "AR[FPSR].rv", 29, 0, 2, -1, },
+  { "AR[ITC]", 25, 0, 2, 44, },
+  { "AR[K%], % in 0 - 7", 1, 0, 2, -1, },
+  { "AR[LC]", 25, 0, 2, 65, },
+  { "AR[PFS]", 25, 0, 2, 64, },
+  { "AR[PFS]", 25, 0, 2, 64, },
+  { "AR[PFS]", 25, 0, 0, 64, },
+  { "AR[RNAT]", 25, 0, 2, 19, },
+  { "AR[RSC]", 25, 0, 2, 16, },
+  { "AR[UNAT]{%}, % in 0 - 63", 2, 0, 2, -1, },
+  { "AR%, % in 8-15, 20, 22-23, 31, 33-35, 37-39, 41-43, 45-47, 67-111", 3, 0, 0, -1, },
+  { "AR%, % in 48-63, 112-127", 4, 0, 2, -1, },
+  { "BR%, % in 0 - 7", 5, 0, 2, -1, },
+  { "BR%, % in 0 - 7", 5, 0, 0, -1, },
+  { "BR%, % in 0 - 7", 5, 0, 2, -1, },
+  { "CFM", 6, 0, 2, -1, },
+  { "CFM", 6, 0, 2, -1, },
+  { "CFM", 6, 0, 2, -1, },
+  { "CFM", 6, 0, 2, -1, },
+  { "CFM", 6, 0, 0, -1, },
+  { "CPUID#", 7, 0, 5, -1, },
+  { "CR[CMCV]", 26, 0, 3, 74, },
+  { "CR[DCR]", 26, 0, 3, 0, },
+  { "CR[EOI]", 26, 0, 6, 67, "SC Section 10.8.3.4", },
+  { "CR[GPTA]", 26, 0, 3, 9, },
+  { "CR[IFA]", 26, 0, 1, 20, },
+  { "CR[IFA]", 26, 0, 3, 20, },
+  { "CR[IFS]", 26, 0, 3, 23, },
+  { "CR[IFS]", 26, 0, 1, 23, },
+  { "CR[IFS]", 26, 0, 1, 23, },
+  { "CR[IHA]", 26, 0, 3, 25, },
+  { "CR[IIM]", 26, 0, 3, 24, },
+  { "CR[IIP]", 26, 0, 3, 19, },
+  { "CR[IIP]", 26, 0, 1, 19, },
+  { "CR[IIPA]", 26, 0, 3, 22, },
+  { "CR[IPSR]", 26, 0, 3, 16, },
+  { "CR[IPSR]", 26, 0, 1, 16, },
+  { "CR[IRR%], % in 0 - 3", 8, 0, 3, -1, },
+  { "CR[ISR]", 26, 0, 3, 17, },
+  { "CR[ITIR]", 26, 0, 3, 21, },
+  { "CR[ITIR]", 26, 0, 1, 21, },
+  { "CR[ITM]", 26, 0, 3, 1, },
+  { "CR[ITV]", 26, 0, 3, 72, },
+  { "CR[IVA]", 26, 0, 4, 2, },
+  { "CR[IVR]", 26, 0, 6, 65, "SC Section 10.8.3.2", },
+  { "CR[LID]", 26, 0, 6, 64, "SC Section 10.8.3.1", },
+  { "CR[LRR%], % in 0 - 1", 9, 0, 3, -1, },
+  { "CR[PMV]", 26, 0, 3, 73, },
+  { "CR[PTA]", 26, 0, 3, 8, },
+  { "CR[TPR]", 26, 0, 3, 66, },
+  { "CR[TPR]", 26, 0, 6, 66, "SC Section 10.8.3.3", },
+  { "CR%, % in 3-7, 10-15, 18, 26-63, 75-79, 82-127", 10, 0, 0, -1, },
+  { "DBR#", 11, 0, 2, -1, },
+  { "DBR#", 11, 0, 3, -1, },
+  { "DTC", 0, 0, 3, -1, },
+  { "DTC", 0, 0, 2, -1, },
+  { "DTC", 0, 0, 0, -1, },
+  { "DTC", 0, 0, 2, -1, },
+  { "DTC_LIMIT*", 0, 0, 2, -1, },
+  { "DTR", 0, 0, 3, -1, },
+  { "DTR", 0, 0, 2, -1, },
+  { "DTR", 0, 0, 3, -1, },
+  { "DTR", 0, 0, 0, -1, },
+  { "DTR", 0, 0, 2, -1, },
+  { "FR%, % in 0 - 1", 12, 0, 0, -1, },
+  { "FR%, % in 2 - 127", 13, 0, 2, -1, },
+  { "FR%, % in 2 - 127", 13, 0, 0, -1, },
+  { "GR0", 14, 0, 0, -1, },
+  { "GR%, % in 1 - 127", 15, 0, 0, -1, },
+  { "GR%, % in 1 - 127", 15, 0, 2, -1, },
+  { "IBR#", 16, 0, 2, -1, },
+  { "InService*", 17, 0, 3, -1, },
+  { "InService*", 17, 0, 2, -1, },
+  { "InService*", 17, 0, 2, -1, },
+  { "IP", 0, 0, 0, -1, },
+  { "ITC", 0, 0, 4, -1, },
+  { "ITC", 0, 0, 2, -1, },
+  { "ITC", 0, 0, 0, -1, },
+  { "ITC", 0, 0, 4, -1, },
+  { "ITC", 0, 0, 2, -1, },
+  { "ITC_LIMIT*", 0, 0, 2, -1, },
+  { "ITR", 0, 0, 2, -1, },
+  { "ITR", 0, 0, 4, -1, },
+  { "ITR", 0, 0, 2, -1, },
+  { "ITR", 0, 0, 0, -1, },
+  { "ITR", 0, 0, 4, -1, },
+  { "memory", 0, 0, 0, -1, },
+  { "MSR#", 18, 0, 5, -1, },
+  { "PKR#", 19, 0, 3, -1, },
+  { "PKR#", 19, 0, 0, -1, },
+  { "PKR#", 19, 0, 2, -1, },
+  { "PKR#", 19, 0, 2, -1, },
+  { "PMC#", 20, 0, 2, -1, },
+  { "PMC#", 20, 0, 6, -1, "SC+3 Section 12.1.1", },
+  { "PMD#", 21, 0, 2, -1, },
+  { "PR0", 0, 0, 0, -1, },
+  { "PR%, % in 1 - 62", 22, 0, 2, -1, },
+  { "PR%, % in 1 - 62", 22, 0, 2, -1, },
+  { "PR%, % in 1 - 62", 22, 0, 0, -1, },
+  { "PR63", 23, 0, 2, -1, },
+  { "PR63", 23, 0, 2, -1, },
+  { "PR63", 23, 0, 0, -1, },
+  { "PSR.ac", 27, 0, 1, 3, },
+  { "PSR.ac", 27, 0, 3, 3, },
+  { "PSR.ac", 27, 0, 2, 3, },
+  { "PSR.be", 27, 0, 1, 1, },
+  { "PSR.be", 27, 0, 3, 1, },
+  { "PSR.be", 27, 0, 2, 1, },
+  { "PSR.bn", 27, 0, 2, 44, },
+  { "PSR.cpl", 27, 0, 1, 32, },
+  { "PSR.da", 27, 0, 3, 38, },
+  { "PSR.db", 27, 0, 3, 24, },
+  { "PSR.db", 27, 0, 2, 24, },
+  { "PSR.db", 27, 0, 3, 24, },
+  { "PSR.dd", 27, 0, 3, 39, },
+  { "PSR.dfh", 27, 0, 3, 19, },
+  { "PSR.dfh", 27, 0, 2, 19, },
+  { "PSR.dfl", 27, 0, 3, 18, },
+  { "PSR.dfl", 27, 0, 2, 18, },
+  { "PSR.di", 27, 0, 3, 22, },
+  { "PSR.di", 27, 0, 2, 22, },
+  { "PSR.dt", 27, 0, 3, 17, },
+  { "PSR.dt", 27, 0, 2, 17, },
+  { "PSR.ed", 27, 0, 3, 43, },
+  { "PSR.i", 27, 0, 2, 14, },
+  { "PSR.i", 27, 0, 3, 14, },
+  { "PSR.ia", 27, 0, 0, 14, },
+  { "PSR.ic", 27, 0, 2, 13, },
+  { "PSR.ic", 27, 0, 3, 13, },
+  { "PSR.id", 27, 0, 0, 14, },
+  { "PSR.is", 27, 0, 0, 14, },
+  { "PSR.it", 27, 0, 3, 14, },
+  { "PSR.lp", 27, 0, 2, 25, },
+  { "PSR.lp", 27, 0, 3, 25, },
+  { "PSR.lp", 27, 0, 3, 25, },
+  { "PSR.mc", 27, 0, 0, 35, },
+  { "PSR.mfh", 27, 0, 2, 5, },
+  { "PSR.mfl", 27, 0, 2, 4, },
+  { "PSR.pk", 27, 0, 3, 15, },
+  { "PSR.pk", 27, 0, 2, 15, },
+  { "PSR.pp", 27, 0, 2, 21, },
+  { "PSR.ri", 27, 0, 0, 41, },
+  { "PSR.rt", 27, 0, 2, 27, },
+  { "PSR.rt", 27, 0, 3, 27, },
+  { "PSR.rt", 27, 0, 3, 27, },
+  { "PSR.si", 27, 0, 2, 23, },
+  { "PSR.si", 27, 0, 3, 23, },
+  { "PSR.sp", 27, 0, 2, 20, },
+  { "PSR.sp", 27, 0, 3, 20, },
+  { "PSR.ss", 27, 0, 3, 40, },
+  { "PSR.tb", 27, 0, 3, 26, },
+  { "PSR.tb", 27, 0, 2, 26, },
+  { "PSR.up", 27, 0, 2, 2, },
+  { "RR#", 24, 0, 3, -1, },
+  { "RR#", 24, 0, 2, -1, },
+  { "RSE", 28, 0, 2, -1, },
+  { "ALAT", 0, 1, 0, -1, },
+  { "AR[BSP]", 25, 1, 2, 17, },
+  { "AR[BSPSTORE]", 25, 1, 2, 18, },
+  { "AR[CCV]", 25, 1, 2, 32, },
+  { "AR[EC]", 25, 1, 2, 66, },
+  { "AR[FPSR].sf0.controls", 29, 1, 2, -1, },
+  { "AR[FPSR].sf1.controls", 29, 1, 2, -1, },
+  { "AR[FPSR].sf2.controls", 29, 1, 2, -1, },
+  { "AR[FPSR].sf3.controls", 29, 1, 2, -1, },
+  { "AR[FPSR].sf0.flags", 29, 1, 0, -1, },
+  { "AR[FPSR].sf0.flags", 29, 1, 2, -1, },
+  { "AR[FPSR].sf0.flags", 29, 1, 2, -1, },
+  { "AR[FPSR].sf1.flags", 29, 1, 0, -1, },
+  { "AR[FPSR].sf1.flags", 29, 1, 2, -1, },
+  { "AR[FPSR].sf1.flags", 29, 1, 2, -1, },
+  { "AR[FPSR].sf2.flags", 29, 1, 0, -1, },
+  { "AR[FPSR].sf2.flags", 29, 1, 2, -1, },
+  { "AR[FPSR].sf2.flags", 29, 1, 2, -1, },
+  { "AR[FPSR].sf3.flags", 29, 1, 0, -1, },
+  { "AR[FPSR].sf3.flags", 29, 1, 2, -1, },
+  { "AR[FPSR].sf3.flags", 29, 1, 2, -1, },
+  { "AR[FPSR].rv", 29, 1, 2, -1, },
+  { "AR[FPSR].traps", 29, 1, 2, -1, },
+  { "AR[ITC]", 25, 1, 2, 44, },
+  { "AR[K%], % in 0 - 7", 1, 1, 2, -1, },
+  { "AR[LC]", 25, 1, 2, 65, },
+  { "AR[PFS]", 25, 1, 0, 64, },
+  { "AR[PFS]", 25, 1, 2, 64, },
+  { "AR[PFS]", 25, 1, 2, 64, },
+  { "AR[RNAT]", 25, 1, 2, 19, },
+  { "AR[RSC]", 25, 1, 2, 16, },
+  { "AR[UNAT]{%}, % in 0 - 63", 2, 1, 2, -1, },
+  { "AR%, % in 8-15, 20, 22-23, 31, 33-35, 37-39, 41-43, 45-47, 67-111", 3, 1, 0, -1, },
+  { "AR%, % in 48 - 63, 112-127", 4, 1, 2, -1, },
+  { "BR%, % in 0 - 7", 5, 1, 2, -1, },
+  { "BR%, % in 0 - 7", 5, 1, 2, -1, },
+  { "BR%, % in 0 - 7", 5, 1, 2, -1, },
+  { "BR%, % in 0 - 7", 5, 1, 0, -1, },
+  { "CFM", 6, 1, 2, -1, },
+  { "CPUID#", 7, 1, 0, -1, },
+  { "CR[CMCV]", 26, 1, 2, 74, },
+  { "CR[DCR]", 26, 1, 2, 0, },
+  { "CR[EOI]", 26, 1, 6, 67, "SC Section 10.8.3.4", },
+  { "CR[GPTA]", 26, 1, 2, 9, },
+  { "CR[IFA]", 26, 1, 2, 20, },
+  { "CR[IFS]", 26, 1, 2, 23, },
+  { "CR[IHA]", 26, 1, 2, 25, },
+  { "CR[IIM]", 26, 1, 2, 24, },
+  { "CR[IIP]", 26, 1, 2, 19, },
+  { "CR[IIPA]", 26, 1, 2, 22, },
+  { "CR[IPSR]", 26, 1, 2, 16, },
+  { "CR[IRR%], % in 0 - 3", 8, 1, 2, -1, },
+  { "CR[ISR]", 26, 1, 2, 17, },
+  { "CR[ITIR]", 26, 1, 2, 21, },
+  { "CR[ITM]", 26, 1, 2, 1, },
+  { "CR[ITV]", 26, 1, 2, 72, },
+  { "CR[IVA]", 26, 1, 2, 2, },
+  { "CR[IVR]", 26, 1, 6, 65, "SC", },
+  { "CR[LID]", 26, 1, 6, 64, "SC", },
+  { "CR[LRR%], % in 0 - 1", 9, 1, 2, -1, },
+  { "CR[PMV]", 26, 1, 2, 73, },
+  { "CR[PTA]", 26, 1, 2, 8, },
+  { "CR[TPR]", 26, 1, 2, 66, },
+  { "CR%, % in 3-7, 10-15, 18, 26-63, 75-79, 82-127", 10, 1, 0, -1, },
+  { "DBR#", 11, 1, 2, -1, },
+  { "DTC", 0, 1, 0, -1, },
+  { "DTC", 0, 1, 2, -1, },
+  { "DTC", 0, 1, 2, -1, },
+  { "DTC_LIMIT*", 0, 1, 2, -1, },
+  { "DTR", 0, 1, 2, -1, },
+  { "DTR", 0, 1, 2, -1, },
+  { "DTR", 0, 1, 2, -1, },
+  { "DTR", 0, 1, 0, -1, },
+  { "FR%, % in 0 - 1", 12, 1, 0, -1, },
+  { "FR%, % in 2 - 127", 13, 1, 2, -1, },
+  { "GR0", 14, 1, 0, -1, },
+  { "GR%, % in 1 - 127", 15, 1, 2, -1, },
+  { "IBR#", 16, 1, 2, -1, },
+  { "InService*", 17, 1, 6, -1, "SC", },
+  { "IP", 0, 1, 0, -1, },
+  { "ITC", 0, 1, 0, -1, },
+  { "ITC", 0, 1, 2, -1, },
+  { "ITC", 0, 1, 2, -1, },
+  { "ITR", 0, 1, 2, -1, },
+  { "ITR", 0, 1, 2, -1, },
+  { "ITR", 0, 1, 0, -1, },
+  { "memory", 0, 1, 0, -1, },
+  { "MSR#", 18, 1, 6, -1, "SC", },
+  { "PKR#", 19, 1, 0, -1, },
+  { "PKR#", 19, 1, 0, -1, },
+  { "PKR#", 19, 1, 2, -1, },
+  { "PMC#", 20, 1, 2, -1, },
+  { "PMD#", 21, 1, 2, -1, },
+  { "PR0", 0, 1, 0, -1, },
+  { "PR%, % in 1 - 62", 22, 1, 0, -1, },
+  { "PR%, % in 1 - 62", 22, 1, 0, -1, },
+  { "PR%, % in 1 - 62", 22, 1, 2, -1, },
+  { "PR%, % in 1 - 62", 22, 1, 2, -1, },
+  { "PR63", 23, 1, 0, -1, },
+  { "PR63", 23, 1, 0, -1, },
+  { "PR63", 23, 1, 2, -1, },
+  { "PR63", 23, 1, 2, -1, },
+  { "PSR.ac", 27, 1, 2, 3, },
+  { "PSR.be", 27, 1, 2, 1, },
+  { "PSR.bn", 27, 1, 2, 44, },
+  { "PSR.cpl", 27, 1, 2, 32, },
+  { "PSR.da", 27, 1, 2, 38, },
+  { "PSR.db", 27, 1, 2, 24, },
+  { "PSR.dd", 27, 1, 2, 39, },
+  { "PSR.dfh", 27, 1, 2, 19, },
+  { "PSR.dfl", 27, 1, 2, 18, },
+  { "PSR.di", 27, 1, 2, 22, },
+  { "PSR.dt", 27, 1, 2, 17, },
+  { "PSR.ed", 27, 1, 2, 43, },
+  { "PSR.i", 27, 1, 2, 14, },
+  { "PSR.ia", 27, 1, 2, 14, },
+  { "PSR.ic", 27, 1, 2, 13, },
+  { "PSR.id", 27, 1, 2, 14, },
+  { "PSR.is", 27, 1, 2, 14, },
+  { "PSR.it", 27, 1, 2, 14, },
+  { "PSR.lp", 27, 1, 2, 25, },
+  { "PSR.mc", 27, 1, 2, 35, },
+  { "PSR.mfh", 27, 1, 0, 5, },
+  { "PSR.mfh", 27, 1, 2, 5, },
+  { "PSR.mfh", 27, 1, 2, 5, },
+  { "PSR.mfl", 27, 1, 0, 4, },
+  { "PSR.mfl", 27, 1, 2, 4, },
+  { "PSR.mfl", 27, 1, 2, 4, },
+  { "PSR.pk", 27, 1, 2, 15, },
+  { "PSR.pp", 27, 1, 2, 21, },
+  { "PSR.ri", 27, 1, 2, 41, },
+  { "PSR.rt", 27, 1, 2, 27, },
+  { "PSR.si", 27, 1, 2, 23, },
+  { "PSR.sp", 27, 1, 2, 20, },
+  { "PSR.ss", 27, 1, 2, 40, },
+  { "PSR.tb", 27, 1, 2, 26, },
+  { "PSR.up", 27, 1, 2, 2, },
+  { "RR#", 24, 1, 2, -1, },
+  { "RSE", 28, 1, 2, -1, },
+  { "PR63", 23, 2, 2, -1, },
+};
+
+static const short dep0[] = {
+  88, 249, 2131, 2294,
+};
+
+static const short dep1[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127, 20602,
+
+};
+
+static const short dep2[] = {
+  2131, 2294,
+};
+
+static const short dep3[] = {
+  32, 33, 2129, 2130, 2131, 2294, 4127, 20602,
+};
+
+static const short dep4[] = {
+  32, 33, 81, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127,
+  20602,
+};
+
+static const short dep5[] = {
+  88, 249, 2157, 2158, 2160, 2161, 2163, 2311, 2314, 2315, 2318, 2319,
+};
+
+static const short dep6[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2311, 2314, 2315,
+  2318, 2319, 4127, 20602,
+};
+
+static const short dep7[] = {
+  88, 249, 22637, 22638, 22640, 22641, 22643, 22791, 22794, 22795, 22798, 22799,
+
+};
+
+static const short dep8[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602, 22791,
+  22794, 22795, 22798, 22799,
+};
+
+static const short dep9[] = {
+  88, 249, 2312, 2314, 2316, 2318,
+};
+
+static const short dep10[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2312, 2315, 2316,
+  2319, 4127, 20602,
+};
+
+static const short dep11[] = {
+  88, 249, 2313, 2315, 2317, 2319,
+};
+
+static const short dep12[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2313, 2314, 2317,
+  2318, 4127, 20602,
+};
+
+static const short dep13[] = {
+  88, 249, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319,
+};
+
+static const short dep14[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2312, 2313, 2314,
+  2315, 2316, 2317, 2318, 2319, 4127, 20602,
+};
+
+static const short dep15[] = {
+  88, 249, 2357,
+};
+
+static const short dep16[] = {
+  32, 33, 88, 145, 163, 164, 249, 2074, 2075, 2157, 2159, 2160, 2162, 2163,
+  4127,
+};
+
+static const short dep17[] = {
+  88, 144, 249, 288, 2357, 28841, 28980,
+};
+
+static const short dep18[] = {
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22,
+  23, 24, 25, 32, 33, 88, 133, 145, 163, 164, 249, 288, 2074, 2075, 2157, 2159,
+  2160, 2162, 2163, 4127, 28841, 28980,
+};
+
+static const short dep19[] = {
+  1, 4, 32, 88, 123, 171, 174, 208, 249, 275, 2357, 28841, 28980,
+};
+
+static const short dep20[] = {
+  1, 18, 20, 30, 32, 33, 88, 145, 147, 148, 163, 164, 171, 174, 208, 249, 275,
+  2074, 2075, 2157, 2159, 2160, 2162, 2163, 4127, 28841, 28980,
+};
+
+static const short dep21[] = {
+  1, 32, 43, 88, 171, 208, 215, 249, 28841, 28980,
+};
+
+static const short dep22[] = {
+  1, 30, 32, 33, 88, 142, 163, 171, 208, 215, 249, 4127, 28841, 28980,
+};
+
+static const short dep23[] = {
+  32, 88, 208, 249,
+};
+
+static const short dep24[] = {
+  88, 163, 208, 249,
+};
+
+static const short dep25[] = {
+  1, 32, 88, 117, 118, 120, 121, 122, 123, 124, 127, 128, 129, 130, 131, 132,
+  133, 134, 135, 136, 137, 139, 140, 141, 142, 143, 144, 145, 148, 149, 150,
+  151, 152, 153, 154, 155, 158, 159, 160, 161, 162, 163, 164, 165, 166, 171,
+  208, 249, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284,
+  285, 286, 287, 288, 289, 290, 291, 293, 294, 296, 297, 298, 299, 300, 301,
+  302, 303, 304, 305, 306, 28841, 28980,
+};
+
+static const short dep26[] = {
+  1, 30, 32, 33, 42, 43, 47, 50, 64, 88, 123, 163, 171, 208, 249, 272, 273,
+  274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288,
+  289, 290, 291, 293, 294, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305,
+  306, 4127, 28841, 28980,
+};
+
+static const short dep27[] = {
+  88, 122, 249, 274,
+};
+
+static const short dep28[] = {
+  88, 123, 163, 249, 274,
+};
+
+static const short dep29[] = {
+  88, 123, 249, 275,
+};
+
+static const short dep30[] = {
+  18, 19, 88, 89, 92, 96, 99, 123, 145, 163, 249, 275,
+};
+
+static const short dep31[] = {
+  32, 33, 88, 163, 249, 2157, 2159, 2160, 2162, 2163, 4127,
+};
+
+static const short dep32[] = {
+  1, 18, 32, 88, 171, 196, 197, 208, 249, 2074, 2252, 2255, 2357, 28841, 28980,
+
+};
+
+static const short dep33[] = {
+  1, 4, 30, 32, 33, 88, 123, 145, 163, 164, 171, 196, 198, 208, 249, 2074, 2075,
+  2157, 2159, 2160, 2162, 2163, 2253, 2255, 4127, 28841, 28980,
+};
+
+static const short dep34[] = {
+  88, 249,
+};
+
+static const short dep35[] = {
+  88, 163, 249, 2074, 2076,
+};
+
+static const short dep36[] = {
+  32, 33, 88, 145, 163, 164, 249, 2157, 2159, 2160, 2162, 2163, 4127,
+};
+
+static const short dep37[] = {
+  4, 29, 30, 31, 88, 113, 114, 174, 208, 249, 270, 271, 2357,
+};
+
+static const short dep38[] = {
+  4, 29, 32, 33, 88, 145, 163, 164, 174, 208, 249, 270, 271, 309, 2157, 2159,
+  2160, 2162, 2163, 4127,
+};
+
+static const short dep39[] = {
+  17, 88, 195, 249, 2357,
+};
+
+static const short dep40[] = {
+  17, 32, 33, 88, 145, 163, 164, 195, 249, 2157, 2159, 2160, 2162, 2163, 4127,
+
+};
+
+static const short dep41[] = {
+  4, 17, 29, 30, 31, 88, 113, 114, 174, 195, 208, 249, 270, 271, 2357,
+};
+
+static const short dep42[] = {
+  4, 17, 29, 32, 33, 88, 145, 163, 164, 174, 195, 208, 249, 270, 271, 309, 2157,
+  2159, 2160, 2162, 2163, 4127,
+};
+
+static const short dep43[] = {
+  1, 4, 30, 32, 33, 88, 123, 145, 163, 164, 171, 196, 198, 208, 249, 2157, 2159,
+  2160, 2162, 2163, 2253, 2255, 4127, 28841, 28980,
+};
+
+static const short dep44[] = {
+  88, 163, 249,
+};
+
+static const short dep45[] = {
+  9, 88, 179, 180, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+  22637, 22638, 22639, 22641, 22642, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep46[] = {
+  5, 13, 14, 32, 33, 88, 163, 179, 181, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729, 22791, 22794, 22795,
+  22798, 22799,
+};
+
+static const short dep47[] = {
+  9, 10, 11, 12, 88, 179, 180, 182, 183, 185, 186, 188, 189, 249, 2127, 2292,
+  18582, 18583, 18724, 18725, 18727, 18728, 22637, 22638, 22639, 22641, 22642,
+  22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep48[] = {
+  5, 6, 7, 8, 13, 14, 32, 33, 88, 163, 179, 181, 182, 184, 185, 187, 188, 190,
+  249, 2126, 2127, 2128, 2157, 2158, 2161, 2292, 4127, 16513, 16515, 18724,
+  18726, 18727, 18729, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep49[] = {
+  10, 88, 182, 183, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+  22637, 22638, 22639, 22641, 22642, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep50[] = {
+  6, 13, 14, 32, 33, 88, 163, 182, 184, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729, 22791, 22794, 22795,
+  22798, 22799,
+};
+
+static const short dep51[] = {
+  11, 88, 185, 186, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+  22637, 22638, 22639, 22641, 22642, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep52[] = {
+  7, 13, 14, 32, 33, 88, 163, 185, 187, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729, 22791, 22794, 22795,
+  22798, 22799,
+};
+
+static const short dep53[] = {
+  12, 88, 188, 189, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+  22637, 22638, 22639, 22641, 22642, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep54[] = {
+  8, 13, 14, 32, 33, 88, 163, 188, 190, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729, 22791, 22794, 22795,
+  22798, 22799,
+};
+
+static const short dep55[] = {
+  9, 88, 179, 180, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+
+};
+
+static const short dep56[] = {
+  5, 13, 14, 32, 33, 88, 163, 179, 181, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729,
+};
+
+static const short dep57[] = {
+  9, 10, 11, 12, 88, 179, 180, 182, 183, 185, 186, 188, 189, 249, 2127, 2292,
+  18582, 18583, 18724, 18725, 18727, 18728,
+};
+
+static const short dep58[] = {
+  5, 6, 7, 8, 13, 14, 32, 33, 88, 163, 179, 181, 182, 184, 185, 187, 188, 190,
+  249, 2126, 2127, 2128, 2157, 2158, 2161, 2292, 4127, 16513, 16515, 18724,
+  18726, 18727, 18729,
+};
+
+static const short dep59[] = {
+  10, 88, 182, 183, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+
+};
+
+static const short dep60[] = {
+  6, 13, 14, 32, 33, 88, 163, 182, 184, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729,
+};
+
+static const short dep61[] = {
+  11, 88, 185, 186, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+
+};
+
+static const short dep62[] = {
+  7, 13, 14, 32, 33, 88, 163, 185, 187, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729,
+};
+
+static const short dep63[] = {
+  12, 88, 188, 189, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+
+};
+
+static const short dep64[] = {
+  8, 13, 14, 32, 33, 88, 163, 188, 190, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729,
+};
+
+static const short dep65[] = {
+  88, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+};
+
+static const short dep66[] = {
+  32, 33, 88, 163, 249, 2126, 2127, 2128, 2157, 2158, 2161, 2292, 4127, 16513,
+  16515, 18724, 18726, 18727, 18729,
+};
+
+static const short dep67[] = {
+  5, 88, 175, 249,
+};
+
+static const short dep68[] = {
+  5, 32, 33, 88, 163, 175, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep69[] = {
+  5, 32, 33, 88, 163, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep70[] = {
+  6, 88, 176, 249,
+};
+
+static const short dep71[] = {
+  5, 32, 33, 88, 163, 176, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep72[] = {
+  7, 88, 177, 249,
+};
+
+static const short dep73[] = {
+  5, 32, 33, 88, 163, 177, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep74[] = {
+  8, 88, 178, 249,
+};
+
+static const short dep75[] = {
+  5, 32, 33, 88, 163, 178, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep76[] = {
+  9, 88, 180, 181, 249,
+};
+
+static const short dep77[] = {
+  32, 33, 88, 163, 180, 181, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep78[] = {
+  32, 33, 88, 163, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep79[] = {
+  10, 88, 183, 184, 249,
+};
+
+static const short dep80[] = {
+  32, 33, 88, 163, 183, 184, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep81[] = {
+  11, 88, 186, 187, 249,
+};
+
+static const short dep82[] = {
+  32, 33, 88, 163, 186, 187, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep83[] = {
+  12, 88, 189, 190, 249,
+};
+
+static const short dep84[] = {
+  32, 33, 88, 163, 189, 190, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep85[] = {
+  9, 13, 14, 32, 33, 88, 145, 163, 164, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep86[] = {
+  9, 10, 13, 14, 32, 33, 88, 145, 163, 164, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep87[] = {
+  9, 11, 13, 14, 32, 33, 88, 145, 163, 164, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep88[] = {
+  9, 12, 13, 14, 32, 33, 88, 145, 163, 164, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep89[] = {
+  9, 88, 179, 180, 249,
+};
+
+static const short dep90[] = {
+  5, 13, 14, 32, 33, 88, 163, 179, 181, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep91[] = {
+  9, 10, 11, 12, 88, 179, 180, 182, 183, 185, 186, 188, 189, 249,
+};
+
+static const short dep92[] = {
+  5, 6, 7, 8, 13, 14, 32, 33, 88, 163, 179, 181, 182, 184, 185, 187, 188, 190,
+  249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep93[] = {
+  10, 88, 182, 183, 249,
+};
+
+static const short dep94[] = {
+  6, 13, 14, 32, 33, 88, 163, 182, 184, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep95[] = {
+  11, 88, 185, 186, 249,
+};
+
+static const short dep96[] = {
+  7, 13, 14, 32, 33, 88, 163, 185, 187, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep97[] = {
+  12, 88, 188, 189, 249,
+};
+
+static const short dep98[] = {
+  8, 13, 14, 32, 33, 88, 163, 188, 190, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep99[] = {
+  9, 88, 179, 180, 249, 2157, 2158, 2159, 2161, 2162, 2311, 2314, 2315, 2318,
+  2319,
+};
+
+static const short dep100[] = {
+  5, 13, 14, 32, 33, 88, 163, 179, 181, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2311, 2314, 2315, 2318, 2319, 4127, 16513, 16515,
+};
+
+static const short dep101[] = {
+  9, 10, 11, 12, 88, 179, 180, 182, 183, 185, 186, 188, 189, 249, 2157, 2158,
+  2159, 2161, 2162, 2311, 2314, 2315, 2318, 2319,
+};
+
+static const short dep102[] = {
+  5, 6, 7, 8, 13, 14, 32, 33, 88, 163, 179, 181, 182, 184, 185, 187, 188, 190,
+  249, 2126, 2127, 2128, 2157, 2158, 2161, 2311, 2314, 2315, 2318, 2319, 4127,
+  16513, 16515,
+};
+
+static const short dep103[] = {
+  10, 88, 182, 183, 249, 2157, 2158, 2159, 2161, 2162, 2311, 2314, 2315, 2318,
+  2319,
+};
+
+static const short dep104[] = {
+  6, 13, 14, 32, 33, 88, 163, 182, 184, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2311, 2314, 2315, 2318, 2319, 4127, 16513, 16515,
+};
+
+static const short dep105[] = {
+  11, 88, 185, 186, 249, 2157, 2158, 2159, 2161, 2162, 2311, 2314, 2315, 2318,
+  2319,
+};
+
+static const short dep106[] = {
+  7, 13, 14, 32, 33, 88, 163, 185, 187, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2311, 2314, 2315, 2318, 2319, 4127, 16513, 16515,
+};
+
+static const short dep107[] = {
+  12, 88, 188, 189, 249, 2157, 2158, 2159, 2161, 2162, 2311, 2314, 2315, 2318,
+  2319,
+};
+
+static const short dep108[] = {
+  8, 13, 14, 32, 33, 88, 163, 188, 190, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  2311, 2314, 2315, 2318, 2319, 4127, 16513, 16515,
+};
+
+static const short dep109[] = {
+  9, 88, 179, 180, 249, 22637, 22638, 22639, 22641, 22642, 22791, 22794, 22795,
+  22798, 22799,
+};
+
+static const short dep110[] = {
+  5, 13, 14, 32, 33, 88, 163, 179, 181, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  4127, 16513, 16515, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep111[] = {
+  9, 10, 11, 12, 88, 179, 180, 182, 183, 185, 186, 188, 189, 249, 22637, 22638,
+  22639, 22641, 22642, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep112[] = {
+  5, 6, 7, 8, 13, 14, 32, 33, 88, 163, 179, 181, 182, 184, 185, 187, 188, 190,
+  249, 2126, 2127, 2128, 2157, 2158, 2161, 4127, 16513, 16515, 22791, 22794,
+  22795, 22798, 22799,
+};
+
+static const short dep113[] = {
+  10, 88, 182, 183, 249, 22637, 22638, 22639, 22641, 22642, 22791, 22794, 22795,
+  22798, 22799,
+};
+
+static const short dep114[] = {
+  6, 13, 14, 32, 33, 88, 163, 182, 184, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  4127, 16513, 16515, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep115[] = {
+  11, 88, 185, 186, 249, 22637, 22638, 22639, 22641, 22642, 22791, 22794, 22795,
+  22798, 22799,
+};
+
+static const short dep116[] = {
+  7, 13, 14, 32, 33, 88, 163, 185, 187, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  4127, 16513, 16515, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep117[] = {
+  12, 88, 188, 189, 249, 22637, 22638, 22639, 22641, 22642, 22791, 22794, 22795,
+  22798, 22799,
+};
+
+static const short dep118[] = {
+  8, 13, 14, 32, 33, 88, 163, 188, 190, 249, 2126, 2127, 2128, 2157, 2158, 2161,
+  4127, 16513, 16515, 22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep119[] = {
+  88, 249, 2157, 2158, 2159, 2161, 2162, 2311, 2314, 2315, 2318, 2319,
+};
+
+static const short dep120[] = {
+  32, 33, 88, 163, 249, 2126, 2127, 2128, 2157, 2158, 2161, 2311, 2314, 2315,
+  2318, 2319, 4127, 16513, 16515,
+};
+
+static const short dep121[] = {
+  88, 249, 22637, 22638, 22639, 22641, 22642, 22791, 22794, 22795, 22798, 22799,
+
+};
+
+static const short dep122[] = {
+  32, 33, 88, 163, 249, 2126, 2127, 2128, 2157, 2158, 2161, 4127, 16513, 16515,
+  22791, 22794, 22795, 22798, 22799,
+};
+
+static const short dep123[] = {
+  13, 14, 32, 33, 88, 163, 249, 2126, 2127, 2128, 2157, 2158, 2161, 2292, 4127,
+  16513, 16515, 18724, 18726, 18727, 18729,
+};
+
+static const short dep124[] = {
+  32, 33, 88, 145, 163, 164, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127,
+  20602,
+};
+
+static const short dep125[] = {
+  88, 249, 2075, 2076, 2253, 2254,
+};
+
+static const short dep126[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2252, 2254, 4127,
+  20602,
+};
+
+static const short dep127[] = {
+  32, 33, 88, 163, 249, 2074, 2076, 2157, 2158, 2161, 2294, 4127, 20602,
+};
+
+static const short dep128[] = {
+  88, 249, 14446, 14448, 14449, 14451, 14602, 14603, 14606, 14607,
+};
+
+static const short dep129[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 4127, 14602, 14603, 14606, 14607,
+  20602, 24685, 24686, 24689,
+};
+
+static const short dep130[] = {
+  88, 110, 112, 113, 115, 249, 14602, 14603, 14606, 14607,
+};
+
+static const short dep131[] = {
+  32, 33, 88, 163, 249, 4127, 14602, 14603, 14606, 14607, 24685, 24686, 24689,
+
+};
+
+static const short dep132[] = {
+  32, 33, 88, 163, 249, 2157, 2158, 2161, 2294, 4127, 20602,
+};
+
+static const short dep133[] = {
+  32, 33, 88, 110, 113, 163, 249, 2294, 4127, 20602, 24685,
+};
+
+static const short dep134[] = {
+  4, 17, 19, 20, 88, 174, 195, 198, 249, 2073, 2251,
+};
+
+static const short dep135[] = {
+  32, 33, 88, 163, 174, 195, 197, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2251,
+  4127, 20602,
+};
+
+static const short dep136[] = {
+  4, 17, 18, 19, 32, 33, 88, 163, 249, 2073, 2157, 2158, 2161, 2294, 4127, 20602,
+
+};
+
+static const short dep137[] = {
+  0, 32, 33, 88, 145, 163, 164, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep138[] = {
+  0, 88, 170, 249,
+};
+
+static const short dep139[] = {
+  0, 32, 33, 88, 145, 163, 164, 170, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep140[] = {
+  32, 33, 88, 163, 170, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep141[] = {
+  2, 21, 88, 172, 199, 249, 28841, 28980,
+};
+
+static const short dep142[] = {
+  1, 2, 21, 22, 88, 157, 158, 163, 172, 199, 249, 28841, 28980,
+};
+
+static const short dep143[] = {
+  1, 21, 22, 30, 32, 33, 88, 157, 158, 163, 172, 199, 249, 4127, 28841, 28980,
+
+};
+
+static const short dep144[] = {
+  0, 32, 33, 88, 163, 170, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep145[] = {
+  1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 21, 22, 23, 88, 171, 172,
+  173, 175, 176, 177, 178, 180, 181, 183, 184, 186, 187, 189, 190, 191, 192,
+  193, 199, 200, 201, 249, 2064, 2073, 2242, 2251, 28841, 28980,
+};
+
+static const short dep146[] = {
+  22, 32, 33, 88, 123, 163, 171, 172, 173, 175, 176, 177, 178, 180, 181, 183,
+  184, 186, 187, 189, 190, 191, 192, 193, 199, 200, 201, 249, 2129, 2130, 2131,
+  2157, 2158, 2161, 2242, 2251, 4127, 20602, 28841, 28980,
+};
+
+static const short dep147[] = {
+  88, 249, 14452, 14454, 14455, 14457, 14486, 14487, 14502, 14608, 14609, 14629,
+  14630, 14632, 14633, 14642,
+};
+
+static const short dep148[] = {
+  32, 33, 88, 162, 163, 249, 2157, 2158, 2161, 4127, 14608, 14609, 14629, 14630,
+  14632, 14633, 14642,
+};
+
+static const short dep149[] = {
+  14452, 14454, 14455, 14457, 14486, 14487, 14502, 14608, 14609, 14629, 14630,
+  14632, 14633, 14642,
+};
+
+static const short dep150[] = {
+  162, 14608, 14609, 14629, 14630, 14632, 14633, 14642,
+};
+
+static const short dep151[] = {
+  88, 249, 14453, 14454, 14456, 14457, 14465, 14466, 14467, 14468, 14469, 14470,
+  14471, 14472, 14474, 14477, 14478, 14486, 14487, 14488, 14489, 14490, 14495,
+  14496, 14497, 14498, 14502, 14608, 14609, 14615, 14616, 14617, 14618, 14620,
+  14622, 14629, 14630, 14632, 14633, 14634, 14635, 14638, 14639, 14642,
+};
+
+static const short dep152[] = {
+  32, 33, 64, 88, 123, 163, 249, 2157, 2158, 2161, 4127, 14608, 14609, 14615,
+  14616, 14617, 14618, 14620, 14622, 14629, 14630, 14632, 14633, 14634, 14635,
+  14638, 14639, 14642,
+};
+
+static const short dep153[] = {
+  1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 21, 22, 23, 32, 33, 88, 123,
+  160, 163, 249, 2064, 2073, 2157, 2158, 2161, 2294, 4127, 20602, 28841,
+};
+
+static const short dep154[] = {
+  35, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 52, 53, 54, 55,
+  56, 57, 59, 61, 62, 63, 64, 85, 87, 88, 210, 211, 212, 213, 214, 215, 216,
+  217, 218, 219, 220, 222, 223, 224, 225, 226, 228, 230, 231, 232, 248, 249,
+  2108, 2277,
+};
+
+static const short dep155[] = {
+  32, 33, 87, 88, 123, 142, 163, 210, 211, 212, 213, 214, 215, 216, 217, 218,
+  219, 220, 222, 223, 224, 225, 226, 228, 230, 231, 232, 248, 249, 2129, 2130,
+  2131, 2157, 2158, 2161, 2277, 4127, 20602,
+};
+
+static const short dep156[] = {
+  51, 86, 88, 221, 248, 249, 2131, 2294,
+};
+
+static const short dep157[] = {
+  32, 33, 35, 36, 38, 40, 41, 43, 44, 45, 46, 48, 49, 52, 53, 55, 56, 57, 58,
+  59, 61, 62, 63, 85, 86, 88, 123, 142, 163, 221, 248, 249, 2099, 2108, 2157,
+  2158, 2161, 2294, 4127, 20602,
+};
+
+static const short dep158[] = {
+  2, 21, 33, 88, 172, 199, 208, 249, 2131, 2294, 28841, 28980,
+};
+
+static const short dep159[] = {
+  2, 18, 19, 21, 22, 30, 32, 33, 88, 157, 158, 163, 172, 199, 208, 249, 2294,
+  4127, 20602, 28841, 28980,
+};
+
+static const short dep160[] = {
+  88, 117, 118, 120, 121, 125, 126, 129, 130, 131, 132, 133, 134, 135, 136,
+  138, 141, 142, 146, 147, 150, 151, 152, 153, 154, 156, 157, 159, 160, 161,
+  162, 164, 165, 166, 249, 272, 273, 277, 279, 280, 281, 282, 284, 286, 290,
+  293, 294, 296, 297, 298, 299, 301, 302, 303, 305, 306,
+};
+
+static const short dep161[] = {
+  32, 33, 64, 88, 123, 163, 249, 272, 273, 277, 279, 280, 281, 282, 284, 286,
+  290, 293, 294, 296, 297, 298, 299, 301, 302, 303, 305, 306, 2129, 2130, 2131,
+  2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep162[] = {
+  88, 116, 118, 119, 121, 150, 151, 166, 249, 272, 273, 293, 294, 296, 297,
+  306,
+};
+
+static const short dep163[] = {
+  32, 33, 88, 162, 163, 249, 272, 273, 293, 294, 296, 297, 306, 2129, 2130,
+  2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep164[] = {
+  32, 33, 88, 118, 121, 123, 126, 127, 130, 132, 134, 136, 138, 139, 141, 145,
+  146, 148, 149, 150, 151, 153, 154, 156, 158, 159, 161, 163, 165, 166, 249,
+  2157, 2158, 2161, 2294, 4127, 20602,
+};
+
+static const short dep165[] = {
+  32, 33, 88, 118, 121, 150, 151, 163, 166, 249, 2157, 2158, 2161, 2294, 4127,
+  20602,
+};
+
+static const short dep166[] = {
+  32, 33, 67, 68, 73, 75, 88, 102, 123, 152, 163, 167, 249, 2129, 2130, 2131,
+  2157, 2158, 2161, 2294, 4127, 20602,
+};
+
+static const short dep167[] = {
+  32, 33, 67, 68, 73, 75, 88, 102, 123, 124, 125, 127, 128, 152, 163, 167, 249,
+  2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep168[] = {
+  68, 69, 88, 92, 93, 236, 237, 249, 251, 252,
+};
+
+static const short dep169[] = {
+  32, 33, 39, 54, 69, 71, 77, 88, 90, 93, 123, 142, 163, 167, 236, 237, 249,
+  251, 252, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep170[] = {
+  32, 33, 39, 54, 69, 71, 88, 90, 93, 95, 97, 123, 142, 163, 167, 236, 237,
+  249, 251, 252, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep171[] = {
+  88, 249, 12455, 12456, 12595,
+};
+
+static const short dep172[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 12595,
+  20602,
+};
+
+static const short dep173[] = {
+  88, 249, 6210, 6211, 6378,
+};
+
+static const short dep174[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 6378,
+  20602,
+};
+
+static const short dep175[] = {
+  88, 249, 6228, 6391,
+};
+
+static const short dep176[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 6391,
+  20602,
+};
+
+static const short dep177[] = {
+  88, 249, 6246, 6247, 6248, 6249, 6402, 6404, 8451,
+};
+
+static const short dep178[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 6249,
+  6403, 6404, 8295, 8450, 20602,
+};
+
+static const short dep179[] = {
+  88, 249, 6250, 6251, 6405,
+};
+
+static const short dep180[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 6405,
+  20602,
+};
+
+static const short dep181[] = {
+  88, 249, 6252, 6406,
+};
+
+static const short dep182[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 6406,
+  20602,
+};
+
+static const short dep183[] = {
+  88, 249, 10341, 10497,
+};
+
+static const short dep184[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 10497,
+  20602,
+};
+
+static const short dep185[] = {
+  68, 69, 73, 74, 88, 92, 93, 236, 237, 239, 240, 249, 251, 252,
+};
+
+static const short dep186[] = {
+  32, 33, 39, 69, 71, 74, 77, 88, 90, 93, 123, 142, 163, 167, 236, 237, 239,
+  241, 249, 251, 252, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep187[] = {
+  68, 69, 88, 92, 93, 95, 96, 236, 237, 249, 251, 252, 253, 254,
+};
+
+static const short dep188[] = {
+  32, 33, 39, 54, 69, 71, 88, 90, 93, 95, 97, 123, 142, 163, 167, 236, 237,
+  249, 251, 252, 253, 254, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+
+};
+
+static const short dep189[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127,
+  12456, 20602,
+};
+
+static const short dep190[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127,
+  6210, 20602,
+};
+
+static const short dep191[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127,
+  6228, 20602,
+};
+
+static const short dep192[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127,
+  6248, 8294, 20602,
+};
+
+static const short dep193[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127,
+  6250, 20602,
+};
+
+static const short dep194[] = {
+  32, 33, 88, 123, 162, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294,
+  4127, 6251, 6252, 20602,
+};
+
+static const short dep195[] = {
+  32, 33, 88, 123, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127,
+  10341, 20602,
+};
+
+static const short dep196[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127, 6178,
+  20602,
+};
+
+static const short dep197[] = {
+  68, 70, 71, 88, 89, 90, 91, 235, 236, 249, 250, 251,
+};
+
+static const short dep198[] = {
+  32, 33, 69, 70, 74, 76, 88, 91, 93, 95, 98, 123, 163, 167, 235, 237, 249,
+  250, 252, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep199[] = {
+  68, 70, 71, 72, 88, 89, 90, 91, 94, 235, 236, 238, 249, 250, 251,
+};
+
+static const short dep200[] = {
+  32, 33, 69, 70, 72, 74, 76, 88, 91, 93, 94, 95, 98, 123, 163, 167, 235, 237,
+  238, 249, 250, 252, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep201[] = {
+  68, 70, 71, 75, 76, 77, 88, 89, 90, 91, 235, 236, 241, 242, 249, 250, 251,
+
+};
+
+static const short dep202[] = {
+  32, 33, 69, 70, 74, 76, 88, 91, 93, 123, 163, 167, 235, 237, 240, 242, 249,
+  250, 252, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep203[] = {
+  68, 70, 71, 88, 89, 90, 91, 97, 98, 99, 235, 236, 249, 250, 251, 254, 255,
+
+};
+
+static const short dep204[] = {
+  32, 33, 69, 70, 88, 91, 93, 95, 98, 123, 163, 167, 235, 237, 249, 250, 252,
+  253, 255, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep205[] = {
+  32, 33, 38, 62, 88, 163, 167, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294,
+  4127, 20602,
+};
+
+static const short dep206[] = {
+  32, 33, 88, 163, 167, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127,
+  20602,
+};
+
+static const short dep207[] = {
+  32, 33, 68, 73, 75, 88, 123, 163, 167, 249, 2129, 2130, 2131, 2157, 2158,
+  2161, 2294, 4127, 20602,
+};
+
+static const short dep208[] = {
+  32, 33, 88, 145, 163, 164, 249, 2126, 2127, 2128, 2129, 2130, 2131, 2157,
+  2158, 2161, 4127, 16513, 16515, 20602,
+};
+
+static const short dep209[] = {
+  32, 33, 68, 73, 75, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127,
+  20602,
+};
+
+static const short dep210[] = {
+  32, 33, 69, 70, 88, 91, 123, 163, 235, 237, 249, 250, 252, 2129, 2130, 2131,
+  2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep211[] = {
+  32, 33, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124, 125, 127,
+  128, 135, 152, 163, 167, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294, 4127,
+  20602,
+};
+
+static const short dep212[] = {
+  32, 33, 36, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124, 125,
+  127, 128, 135, 137, 152, 163, 167, 249, 2129, 2130, 2131, 2157, 2158, 2161,
+  2294, 4127, 20602,
+};
+
+static const short dep213[] = {
+  0, 88, 170, 249, 2131, 2294,
+};
+
+static const short dep214[] = {
+  0, 32, 33, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124, 125,
+  127, 128, 135, 152, 163, 167, 170, 249, 2129, 2130, 2131, 2157, 2158, 2161,
+  2294, 4127, 20602,
+};
+
+static const short dep215[] = {
+  0, 32, 33, 36, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124,
+  125, 127, 128, 135, 137, 152, 163, 167, 170, 249, 2129, 2130, 2131, 2157,
+  2158, 2161, 2294, 4127, 20602,
+};
+
+static const short dep216[] = {
+  23, 32, 33, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124, 125,
+  127, 128, 135, 152, 163, 167, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294,
+  4127, 20602,
+};
+
+static const short dep217[] = {
+  0, 88, 170, 249, 2294, 26706,
+};
+
+static const short dep218[] = {
+  0, 88, 100, 170, 249, 256,
+};
+
+static const short dep219[] = {
+  0, 32, 33, 67, 68, 73, 75, 88, 102, 116, 117, 119, 120, 123, 124, 125, 127,
+  128, 135, 152, 163, 167, 170, 249, 256, 2129, 2130, 2131, 2157, 2158, 2161,
+  4127, 20602,
+};
+
+static const short dep220[] = {
+  0, 23, 88, 100, 170, 201, 249, 256,
+};
+
+static const short dep221[] = {
+  0, 32, 33, 67, 68, 73, 75, 88, 102, 116, 117, 119, 120, 123, 124, 125, 127,
+  128, 135, 152, 163, 167, 170, 201, 249, 256, 2129, 2130, 2131, 2157, 2158,
+  2161, 4127, 20602,
+};
+
+static const short dep222[] = {
+  0, 88, 100, 170, 249, 256, 2131, 2294,
+};
+
+static const short dep223[] = {
+  0, 3, 32, 33, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124,
+  125, 127, 128, 135, 152, 163, 167, 170, 249, 256, 2129, 2130, 2131, 2157,
+  2158, 2161, 2294, 4127, 20602,
+};
+
+static const short dep224[] = {
+  0, 32, 33, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124, 125,
+  127, 128, 135, 152, 163, 167, 170, 249, 256, 2129, 2130, 2131, 2157, 2158,
+  2161, 2294, 4127, 20602,
+};
+
+static const short dep225[] = {
+  32, 33, 88, 163, 249, 2126, 2127, 2128, 2157, 2158, 2161, 2294, 4127, 16513,
+  16515, 20602,
+};
+
+static const short dep226[] = {
+  32, 33, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124, 125, 127,
+  128, 135, 152, 163, 167, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2292, 4127,
+  16513, 16515, 18724, 18726, 18727, 18729, 20602,
+};
+
+static const short dep227[] = {
+  32, 33, 36, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124, 125,
+  127, 128, 135, 137, 152, 163, 167, 249, 2129, 2130, 2131, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729, 20602,
+};
+
+static const short dep228[] = {
+  0, 88, 170, 249, 2127, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+};
+
+static const short dep229[] = {
+  0, 32, 33, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124, 125,
+  127, 128, 135, 152, 163, 167, 170, 249, 2129, 2130, 2131, 2157, 2158, 2161,
+  2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729, 20602,
+};
+
+static const short dep230[] = {
+  0, 32, 33, 36, 67, 68, 73, 75, 88, 100, 102, 116, 117, 119, 120, 123, 124,
+  125, 127, 128, 135, 137, 152, 163, 167, 170, 249, 2129, 2130, 2131, 2157,
+  2158, 2161, 2292, 4127, 16513, 16515, 18724, 18726, 18727, 18729, 20602,
+};
+
+static const short dep231[] = {
+  0, 88, 170, 249, 2128, 2292, 18582, 18583, 18724, 18725, 18727, 18728,
+};
+
+static const short dep232[] = {
+  32, 33, 67, 88, 123, 137, 163, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep233[] = {
+  32, 33, 67, 88, 123, 124, 128, 137, 163, 249, 2157, 2158, 2161, 4127,
+};
+
+static const short dep234[] = {
+  32, 33, 67, 88, 123, 137, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 2294,
+  4127, 20602,
+};
+
+static const short dep235[] = {
+  32, 33, 67, 88, 123, 124, 128, 137, 163, 249, 2129, 2130, 2131, 2157, 2158,
+  2161, 2294, 4127, 20602,
+};
+
+static const short dep236[] = {
+  32, 33, 88, 163, 249, 2129, 2130, 2131, 2157, 2158, 2161, 4127, 20602,
+};
+
+static const short dep237[] = {
+  32, 33, 88, 163, 249, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 4127,
+};
+
+static const short dep238[] = {
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 19, 20, 21, 22, 23,
+  88, 171, 172, 173, 174, 175, 176, 177, 178, 180, 181, 183, 184, 186, 187,
+  189, 190, 191, 192, 193, 195, 198, 199, 200, 201, 249, 2064, 2073, 2131, 2242,
+  2251, 2294, 28841, 28980,
+};
+
+static const short dep239[] = {
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 21, 22, 23,
+  32, 33, 88, 123, 160, 163, 171, 172, 173, 174, 175, 176, 177, 178, 180, 181,
+  183, 184, 186, 187, 189, 190, 191, 192, 193, 195, 197, 199, 200, 201, 249,
+  2064, 2073, 2129, 2130, 2131, 2157, 2158, 2161, 2242, 2251, 2294, 4127, 20602,
+  28841, 28980,
+};
+
+#define NELS(X) (sizeof(X)/sizeof(X[0]))
+static const struct ia64_opcode_dependency
+op_dependencies[] = {
+  { NELS(dep1), dep1, NELS(dep0), dep0, },
+  { NELS(dep3), dep3, NELS(dep2), dep2, },
+  { NELS(dep4), dep4, NELS(dep0), dep0, },
+  { NELS(dep6), dep6, NELS(dep5), dep5, },
+  { NELS(dep8), dep8, NELS(dep7), dep7, },
+  { NELS(dep10), dep10, NELS(dep9), dep9, },
+  { NELS(dep12), dep12, NELS(dep11), dep11, },
+  { NELS(dep14), dep14, NELS(dep13), dep13, },
+  { NELS(dep16), dep16, NELS(dep15), dep15, },
+  { NELS(dep18), dep18, NELS(dep17), dep17, },
+  { NELS(dep20), dep20, NELS(dep19), dep19, },
+  { NELS(dep22), dep22, NELS(dep21), dep21, },
+  { NELS(dep24), dep24, NELS(dep23), dep23, },
+  { NELS(dep26), dep26, NELS(dep25), dep25, },
+  { NELS(dep28), dep28, NELS(dep27), dep27, },
+  { NELS(dep30), dep30, NELS(dep29), dep29, },
+  { NELS(dep31), dep31, NELS(dep15), dep15, },
+  { NELS(dep33), dep33, NELS(dep32), dep32, },
+  { NELS(dep35), dep35, NELS(dep34), dep34, },
+  { NELS(dep36), dep36, NELS(dep15), dep15, },
+  { NELS(dep38), dep38, NELS(dep37), dep37, },
+  { NELS(dep40), dep40, NELS(dep39), dep39, },
+  { NELS(dep42), dep42, NELS(dep41), dep41, },
+  { NELS(dep43), dep43, NELS(dep32), dep32, },
+  { NELS(dep44), dep44, NELS(dep34), dep34, },
+  { NELS(dep46), dep46, NELS(dep45), dep45, },
+  { NELS(dep48), dep48, NELS(dep47), dep47, },
+  { NELS(dep50), dep50, NELS(dep49), dep49, },
+  { NELS(dep52), dep52, NELS(dep51), dep51, },
+  { NELS(dep54), dep54, NELS(dep53), dep53, },
+  { NELS(dep56), dep56, NELS(dep55), dep55, },
+  { NELS(dep58), dep58, NELS(dep57), dep57, },
+  { NELS(dep60), dep60, NELS(dep59), dep59, },
+  { NELS(dep62), dep62, NELS(dep61), dep61, },
+  { NELS(dep64), dep64, NELS(dep63), dep63, },
+  { NELS(dep66), dep66, NELS(dep65), dep65, },
+  { NELS(dep68), dep68, NELS(dep67), dep67, },
+  { NELS(dep69), dep69, NELS(dep34), dep34, },
+  { NELS(dep71), dep71, NELS(dep70), dep70, },
+  { NELS(dep73), dep73, NELS(dep72), dep72, },
+  { NELS(dep75), dep75, NELS(dep74), dep74, },
+  { NELS(dep77), dep77, NELS(dep76), dep76, },
+  { NELS(dep78), dep78, NELS(dep34), dep34, },
+  { NELS(dep80), dep80, NELS(dep79), dep79, },
+  { NELS(dep82), dep82, NELS(dep81), dep81, },
+  { NELS(dep84), dep84, NELS(dep83), dep83, },
+  { NELS(dep85), dep85, NELS(dep34), dep34, },
+  { NELS(dep86), dep86, NELS(dep34), dep34, },
+  { NELS(dep87), dep87, NELS(dep34), dep34, },
+  { NELS(dep88), dep88, NELS(dep34), dep34, },
+  { NELS(dep90), dep90, NELS(dep89), dep89, },
+  { NELS(dep92), dep92, NELS(dep91), dep91, },
+  { NELS(dep94), dep94, NELS(dep93), dep93, },
+  { NELS(dep96), dep96, NELS(dep95), dep95, },
+  { NELS(dep98), dep98, NELS(dep97), dep97, },
+  { NELS(dep100), dep100, NELS(dep99), dep99, },
+  { NELS(dep102), dep102, NELS(dep101), dep101, },
+  { NELS(dep104), dep104, NELS(dep103), dep103, },
+  { NELS(dep106), dep106, NELS(dep105), dep105, },
+  { NELS(dep108), dep108, NELS(dep107), dep107, },
+  { NELS(dep110), dep110, NELS(dep109), dep109, },
+  { NELS(dep112), dep112, NELS(dep111), dep111, },
+  { NELS(dep114), dep114, NELS(dep113), dep113, },
+  { NELS(dep116), dep116, NELS(dep115), dep115, },
+  { NELS(dep118), dep118, NELS(dep117), dep117, },
+  { NELS(dep120), dep120, NELS(dep119), dep119, },
+  { NELS(dep122), dep122, NELS(dep121), dep121, },
+  { NELS(dep123), dep123, NELS(dep65), dep65, },
+  { NELS(dep124), dep124, NELS(dep34), dep34, },
+  { NELS(dep126), dep126, NELS(dep125), dep125, },
+  { NELS(dep127), dep127, NELS(dep0), dep0, },
+  { NELS(dep129), dep129, NELS(dep128), dep128, },
+  { NELS(dep131), dep131, NELS(dep130), dep130, },
+  { NELS(dep132), dep132, NELS(dep0), dep0, },
+  { NELS(dep133), dep133, NELS(dep0), dep0, },
+  { NELS(dep135), dep135, NELS(dep134), dep134, },
+  { NELS(dep136), dep136, NELS(dep0), dep0, },
+  { NELS(dep137), dep137, NELS(dep34), dep34, },
+  { NELS(dep139), dep139, NELS(dep138), dep138, },
+  { NELS(dep140), dep140, NELS(dep138), dep138, },
+  { NELS(dep142), dep142, NELS(dep141), dep141, },
+  { NELS(dep143), dep143, NELS(dep141), dep141, },
+  { NELS(dep144), dep144, NELS(dep138), dep138, },
+  { NELS(dep146), dep146, NELS(dep145), dep145, },
+  { NELS(dep148), dep148, NELS(dep147), dep147, },
+  { NELS(dep150), dep150, NELS(dep149), dep149, },
+  { NELS(dep152), dep152, NELS(dep151), dep151, },
+  { NELS(dep153), dep153, NELS(dep0), dep0, },
+  { NELS(dep155), dep155, NELS(dep154), dep154, },
+  { NELS(dep157), dep157, NELS(dep156), dep156, },
+  { NELS(dep159), dep159, NELS(dep158), dep158, },
+  { NELS(dep161), dep161, NELS(dep160), dep160, },
+  { NELS(dep163), dep163, NELS(dep162), dep162, },
+  { NELS(dep164), dep164, NELS(dep0), dep0, },
+  { NELS(dep165), dep165, NELS(dep0), dep0, },
+  { NELS(dep166), dep166, NELS(dep0), dep0, },
+  { NELS(dep167), dep167, NELS(dep34), dep34, },
+  { NELS(dep169), dep169, NELS(dep168), dep168, },
+  { NELS(dep170), dep170, NELS(dep168), dep168, },
+  { NELS(dep172), dep172, NELS(dep171), dep171, },
+  { NELS(dep174), dep174, NELS(dep173), dep173, },
+  { NELS(dep176), dep176, NELS(dep175), dep175, },
+  { NELS(dep178), dep178, NELS(dep177), dep177, },
+  { NELS(dep180), dep180, NELS(dep179), dep179, },
+  { NELS(dep182), dep182, NELS(dep181), dep181, },
+  { NELS(dep184), dep184, NELS(dep183), dep183, },
+  { NELS(dep186), dep186, NELS(dep185), dep185, },
+  { NELS(dep188), dep188, NELS(dep187), dep187, },
+  { NELS(dep189), dep189, NELS(dep0), dep0, },
+  { NELS(dep190), dep190, NELS(dep0), dep0, },
+  { NELS(dep191), dep191, NELS(dep0), dep0, },
+  { NELS(dep192), dep192, NELS(dep0), dep0, },
+  { NELS(dep193), dep193, NELS(dep0), dep0, },
+  { NELS(dep194), dep194, NELS(dep0), dep0, },
+  { NELS(dep195), dep195, NELS(dep0), dep0, },
+  { NELS(dep196), dep196, NELS(dep0), dep0, },
+  { NELS(dep198), dep198, NELS(dep197), dep197, },
+  { NELS(dep200), dep200, NELS(dep199), dep199, },
+  { NELS(dep202), dep202, NELS(dep201), dep201, },
+  { NELS(dep204), dep204, NELS(dep203), dep203, },
+  { NELS(dep205), dep205, NELS(dep0), dep0, },
+  { NELS(dep206), dep206, NELS(dep0), dep0, },
+  { NELS(dep207), dep207, NELS(dep0), dep0, },
+  { NELS(dep208), dep208, NELS(dep34), dep34, },
+  { NELS(dep209), dep209, NELS(dep34), dep34, },
+  { NELS(dep210), dep210, NELS(dep197), dep197, },
+  { NELS(dep211), dep211, NELS(dep0), dep0, },
+  { NELS(dep212), dep212, NELS(dep0), dep0, },
+  { NELS(dep214), dep214, NELS(dep213), dep213, },
+  { NELS(dep215), dep215, NELS(dep213), dep213, },
+  { NELS(dep216), dep216, NELS(dep0), dep0, },
+  { NELS(dep214), dep214, NELS(dep217), dep217, },
+  { NELS(dep219), dep219, NELS(dep218), dep218, },
+  { NELS(dep221), dep221, NELS(dep220), dep220, },
+  { NELS(dep223), dep223, NELS(dep222), dep222, },
+  { NELS(dep224), dep224, NELS(dep222), dep222, },
+  { NELS(dep225), dep225, NELS(dep0), dep0, },
+  { NELS(dep226), dep226, NELS(dep65), dep65, },
+  { NELS(dep227), dep227, NELS(dep65), dep65, },
+  { NELS(dep229), dep229, NELS(dep228), dep228, },
+  { NELS(dep230), dep230, NELS(dep228), dep228, },
+  { NELS(dep229), dep229, NELS(dep231), dep231, },
+  { NELS(dep232), dep232, NELS(dep34), dep34, },
+  { NELS(dep233), dep233, NELS(dep34), dep34, },
+  { NELS(dep234), dep234, NELS(dep0), dep0, },
+  { NELS(dep235), dep235, NELS(dep0), dep0, },
+  { NELS(dep236), dep236, NELS(dep34), dep34, },
+  { NELS(dep237), dep237, NELS(dep15), dep15, },
+  { NELS(dep239), dep239, NELS(dep238), dep238, },
+};
+
+static const struct ia64_completer_table
+completer_table[] = {
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 1 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 90 },
+  { 0x0, 0x0, 0, 122, -1, 0, 1, 8 },
+  { 0x0, 0x0, 0, 127, -1, 0, 1, 19 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 147 },
+  { 0x0, 0x0, 0, 724, -1, 0, 1, 12 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 11 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 73 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 15 },
+  { 0x1, 0x1, 0, 1008, -1, 13, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 35 },
+  { 0x0, 0x0, 0, 141, -1, 0, 1, 31 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 31 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 124 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 46 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 42 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 80 },
+  { 0x0, 0x0, 0, 143, -1, 0, 1, 31 },
+  { 0x0, 0x0, 0, 145, -1, 0, 1, 31 },
+  { 0x0, 0x0, 0, 756, -1, 0, 1, 31 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 26 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 37 },
+  { 0x0, 0x0, 0, 553, -1, 0, 1, 35 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 79 },
+  { 0x0, 0x0, 0, 77, -1, 0, 1, 126 },
+  { 0x0, 0x0, 0, 78, -1, 0, 1, 126 },
+  { 0x0, 0x0, 0, 79, -1, 0, 1, 137 },
+  { 0x0, 0x0, 0, 326, -1, 0, 1, 142 },
+  { 0x0, 0x0, 0, 328, -1, 0, 1, 144 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 81 },
+  { 0x0, 0x0, 0, 80, -1, 0, 1, 42 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 2 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 69 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 70 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 71 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 72 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 74 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 88 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 89 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 91 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 92 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 93 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 94 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 99 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 100 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 101 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 102 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 103 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 104 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 105 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 108 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 109 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 110 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 111 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 112 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 113 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 114 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 115 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 148 },
+  { 0x0, 0x0, 0, 938, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 731, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, 1009, -1, 0, 1, 0 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 13 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 86 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 85 },
+  { 0x0, 0x0, 0, 696, -1, 0, 1, 132 },
+  { 0x0, 0x0, 0, 698, -1, 0, 1, 132 },
+  { 0x0, 0x0, 0, 695, -1, 0, 1, 132 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 84 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 122 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 120 },
+  { 0x0, 0x0, 0, -1, -1, 0, 1, 121 },
+  { 0x0, 0x0, 0, 654, -1, 0, 1, 135 },
+  { 0x0, 0x0, 1, 75, -1, 0, 1, 14 },
+  { 0x1, 0x1, 2, -1, -1, 27, 1, 14 },
+  { 0x0, 0x0, 3, -1, 132, 0, 0, -1 },
+  { 0x1, 0x1, 3, 84, 655, 33, 1, 128 },
+  { 0x1, 0x1, 3, 85, 655, 33, 1, 128 },
+  { 0x1, 0x1, 3, 112, 663, 33, 1, 139 },
+  { 0x1, 0x1, 3, -1, -1, 27, 1, 42 },
+  { 0x0, 0x0, 4, 732, 653, 0, 1, 134 },
+  { 0x0, 0x0, 4, 733, 654, 0, 1, 135 },
+  { 0x1, 0x1, 4, 657, 657, 33, 1, 131 },
+  { 0x5, 0x5, 4, 108, 656, 32, 1, 126 },
+  { 0x5, 0x5, 4, 109, 656, 32, 1, 126 },
+  { 0x1, 0x21, 10, 701, -1, 33, 1, 5 },
+  { 0x200001, 0x200001, 10, 702, -1, 12, 1, 5 },
+  { 0x1, 0x1, 10, 703, -1, 33, 1, 5 },
+  { 0x0, 0x0, 10, 704, -1, 0, 1, 5 },
+  { 0x1, 0x1, 10, 705, -1, 12, 1, 5 },
+  { 0x0, 0x0, 10, -1, 712, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 713, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 714, 0, 0, -1 },
+  { 0x0, 0x0, 10, -1, 715, 0, 0, -1 },
+  { 0x1000001, 0x1000001, 10, 706, -1, 12, 1, 5 },
+  { 0x1, 0x1, 10, 707, -1, 36, 1, 5 },
+  { 0x0, 0x0, 10, 105, 716, 0, 0, -1 },
+  { 0x0, 0x0, 10, 106, 718, 0, 0, -1 },
+  { 0x2, 0x3, 11, -1, -1, 37, 1, 7 },
+  { 0x1, 0x1, 11, 708, -1, 12, 1, 5 },
+  { 0x0, 0x0, 11, 709, -1, 0, 1, 5 },
+  { 0x200001, 0x200001, 11, 710, -1, 12, 1, 5 },
+  { 0x1, 0x1, 11, 711, -1, 33, 1, 5 },
+  { 0x1, 0x1, 11, -1, -1, 36, 1, 7 },
+  { 0x1, 0x1, 11, 717, -1, 36, 1, 5 },
+  { 0x1000001, 0x1000001, 11, 719, -1, 12, 1, 5 },
+  { 0x0, 0x0, 12, -1, -1, 0, 1, 16 },
+  { 0x1, 0x1, 13, 110, 656, 34, 1, 126 },
+  { 0x1, 0x1, 13, 111, 656, 34, 1, 126 },
+  { 0x0, 0x0, 19, 660, 133, 0, 0, -1 },
+  { 0x0, 0x0, 19, 399, 133, 0, 0, -1 },
+  { 0x0, 0x0, 19, 667, 134, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 266, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 267, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 280, 0, 0, -1 },
+  { 0x0, 0x0, 20, -1, 281, 0, 0, -1 },
+  { 0x0, 0x0, 21, 139, 276, 0, 0, -1 },
+  { 0x0, 0x0, 21, 140, 278, 0, 0, -1 },
+  { 0x0, 0x0, 23, -1, 274, 0, 0, -1 },
+  { 0x0, 0x0, 23, -1, 275, 0, 0, -1 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, 339, -1, 35, 1, 8 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 9 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 10 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 17 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, 355, -1, 35, 1, 19 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 20 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 21 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 22 },
+  { 0x1, 0x1, 24, -1, -1, 35, 1, 23 },
+  { 0x1, 0x1, 24, 538, -1, 33, 1, 78 },
+  { 0x1, 0x1, 24, 539, 83, 35, 1, 131 },
+  { 0x1, 0x1, 24, 540, 664, 35, 1, 141 },
+  { 0x0, 0x0, 32, 260, 258, 0, 0, -1 },
+  { 0x0, 0x0, 32, 263, 261, 0, 0, -1 },
+  { 0x0, 0x0, 32, 268, 268, 0, 0, -1 },
+  { 0x0, 0x0, 32, 269, 269, 0, 0, -1 },
+  { 0x0, 0x0, 34, -1, 277, 0, 0, -1 },
+  { 0x0, 0x0, 34, -1, 279, 0, 0, -1 },
+  { 0x1, 0x1, 37, 746, 756, 37, 1, 31 },
+  { 0x0, 0x0, 37, 747, 774, 0, 0, -1 },
+  { 0x1, 0x1, 37, 748, -1, 37, 1, 31 },
+  { 0x0, 0x0, 37, 750, 774, 0, 0, -1 },
+  { 0x1, 0x1, 37, 751, -1, 37, 1, 31 },
+  { 0x3, 0x3, 37, 331, -1, 30, 1, 136 },
+  { 0x0, 0x0, 37, 433, -1, 0, 1, 97 },
+  { 0x0, 0x0, 37, -1, -1, 0, 1, 106 },
+  { 0x0, 0x0, 37, 437, -1, 0, 1, 118 },
+  { 0x3, 0x3, 37, 332, -1, 30, 1, 146 },
+  { 0x0, 0x0, 37, 438, -1, 0, 1, 42 },
+  { 0x5, 0x5, 38, 566, 441, 0, 1, 18 },
+  { 0x1, 0x1, 38, 567, 441, 1, 1, 18 },
+  { 0x0, 0x0, 38, 568, 565, 0, 0, -1 },
+  { 0x1, 0x1, 38, 569, 441, 5, 1, 18 },
+  { 0x25, 0x25, 38, 570, 441, 0, 1, 18 },
+  { 0x11, 0x11, 38, 571, 441, 1, 1, 18 },
+  { 0x0, 0x0, 38, 572, 155, 0, 0, -1 },
+  { 0x1, 0x1, 38, 573, 441, 4, 1, 18 },
+  { 0x1, 0x1, 38, -1, 441, 4, 1, 18 },
+  { 0x0, 0x0, 38, -1, 160, 0, 0, -1 },
+  { 0x15, 0x15, 38, 574, 441, 0, 1, 18 },
+  { 0x9, 0x9, 38, 575, 441, 1, 1, 18 },
+  { 0x0, 0x0, 38, 384, 159, 0, 0, -1 },
+  { 0x800001, 0x800001, 38, 577, 441, 4, 1, 18 },
+  { 0x800001, 0x800001, 38, -1, 441, 4, 1, 18 },
+  { 0x0, 0x0, 38, -1, 166, 0, 0, -1 },
+  { 0x8000015, 0x8000015, 38, 578, 441, 0, 1, 18 },
+  { 0x4000009, 0x4000009, 38, 579, 441, 1, 1, 18 },
+  { 0x0, 0x0, 38, 385, 165, 0, 0, -1 },
+  { 0x1, 0x1, 38, 581, 441, 27, 1, 18 },
+  { 0x1, 0x1, 38, -1, 441, 27, 1, 18 },
+  { 0x0, 0x0, 38, -1, 172, 0, 0, -1 },
+  { 0x8000005, 0x8000005, 38, 582, 441, 0, 1, 18 },
+  { 0x4000001, 0x4000001, 38, 583, 441, 1, 1, 18 },
+  { 0x0, 0x0, 38, 386, 171, 0, 0, -1 },
+  { 0x0, 0x0, 38, 565, 441, 0, 1, 18 },
+  { 0x0, 0x0, 38, -1, 441, 0, 1, 18 },
+  { 0x0, 0x0, 38, -1, 178, 0, 0, -1 },
+  { 0x0, 0x0, 38, 387, 177, 0, 0, -1 },
+  { 0x5, 0x5, 38, 586, 443, 0, 1, 24 },
+  { 0x1, 0x1, 38, 587, 443, 1, 1, 24 },
+  { 0x0, 0x0, 38, 588, 585, 0, 0, -1 },
+  { 0x1, 0x1, 38, 589, 443, 5, 1, 24 },
+  { 0x25, 0x25, 38, 590, 443, 0, 1, 24 },
+  { 0x11, 0x11, 38, 591, 443, 1, 1, 24 },
+  { 0x0, 0x0, 38, 592, 184, 0, 0, -1 },
+  { 0x1, 0x1, 38, 593, 443, 4, 1, 24 },
+  { 0x1, 0x1, 38, -1, 443, 4, 1, 24 },
+  { 0x0, 0x0, 38, -1, 189, 0, 0, -1 },
+  { 0x15, 0x15, 38, 594, 443, 0, 1, 24 },
+  { 0x9, 0x9, 38, 595, 443, 1, 1, 24 },
+  { 0x0, 0x0, 38, 389, 188, 0, 0, -1 },
+  { 0x3, 0x3, 38, 597, 443, 3, 1, 24 },
+  { 0x3, 0x3, 38, -1, 443, 3, 1, 24 },
+  { 0x0, 0x0, 38, -1, 195, 0, 0, -1 },
+  { 0x1d, 0x1d, 38, 598, 443, 0, 1, 24 },
+  { 0xd, 0xd, 38, 599, 443, 1, 1, 24 },
+  { 0x0, 0x0, 38, 390, 194, 0, 0, -1 },
+  { 0x1, 0x1, 38, 601, 443, 3, 1, 24 },
+  { 0x1, 0x1, 38, -1, 443, 3, 1, 24 },
+  { 0x0, 0x0, 38, -1, 201, 0, 0, -1 },
+  { 0xd, 0xd, 38, 602, 443, 0, 1, 24 },
+  { 0x5, 0x5, 38, 603, 443, 1, 1, 24 },
+  { 0x0, 0x0, 38, 391, 200, 0, 0, -1 },
+  { 0x0, 0x0, 38, 585, 443, 0, 1, 24 },
+  { 0x0, 0x0, 38, -1, 443, 0, 1, 24 },
+  { 0x0, 0x0, 38, -1, 207, 0, 0, -1 },
+  { 0x0, 0x0, 38, 392, 206, 0, 0, -1 },
+  { 0x1, 0x1, 38, 605, 445, 21, 1, 69 },
+  { 0x1005, 0x1005, 38, 606, 445, 9, 1, 69 },
+  { 0x801, 0x801, 38, 607, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 608, 210, 0, 0, -1 },
+  { 0x201, 0x201, 38, 609, 445, 12, 1, 69 },
+  { 0x100d, 0x100d, 38, 610, 445, 9, 1, 69 },
+  { 0x805, 0x805, 38, 611, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 612, 214, 0, 0, -1 },
+  { 0x1, 0x1, 38, 613, 445, 20, 1, 69 },
+  { 0x805, 0x805, 38, 614, 445, 9, 1, 69 },
+  { 0x401, 0x401, 38, 615, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 616, 218, 0, 0, -1 },
+  { 0x101, 0x101, 38, 617, 445, 12, 1, 69 },
+  { 0x80d, 0x80d, 38, 618, 445, 9, 1, 69 },
+  { 0x405, 0x405, 38, 619, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 620, 222, 0, 0, -1 },
+  { 0x3, 0x3, 38, 621, 445, 21, 1, 69 },
+  { 0x3005, 0x3005, 38, 622, 445, 9, 1, 69 },
+  { 0x1801, 0x1801, 38, 623, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 624, 226, 0, 0, -1 },
+  { 0x601, 0x601, 38, 625, 445, 12, 1, 69 },
+  { 0x300d, 0x300d, 38, 626, 445, 9, 1, 69 },
+  { 0x1805, 0x1805, 38, 627, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 628, 230, 0, 0, -1 },
+  { 0x5, 0x5, 38, 629, 445, 20, 1, 69 },
+  { 0x2805, 0x2805, 38, 630, 445, 9, 1, 69 },
+  { 0x1401, 0x1401, 38, 631, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 632, 234, 0, 0, -1 },
+  { 0x501, 0x501, 38, 633, 445, 12, 1, 69 },
+  { 0x280d, 0x280d, 38, 634, 445, 9, 1, 69 },
+  { 0x1405, 0x1405, 38, 635, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 636, 238, 0, 0, -1 },
+  { 0x1, 0x1, 38, 637, 445, 22, 1, 69 },
+  { 0x2005, 0x2005, 38, 638, 445, 9, 1, 69 },
+  { 0x1001, 0x1001, 38, 639, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 640, 242, 0, 0, -1 },
+  { 0x401, 0x401, 38, 641, 445, 12, 1, 69 },
+  { 0x200d, 0x200d, 38, 642, 445, 9, 1, 69 },
+  { 0x1005, 0x1005, 38, 643, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 644, 246, 0, 0, -1 },
+  { 0x0, 0x0, 38, 645, 445, 0, 1, 69 },
+  { 0x5, 0x5, 38, 646, 445, 9, 1, 69 },
+  { 0x1, 0x1, 38, 647, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 648, 250, 0, 0, -1 },
+  { 0x1, 0x1, 38, 649, 445, 12, 1, 69 },
+  { 0xd, 0xd, 38, 650, 445, 9, 1, 69 },
+  { 0x5, 0x5, 38, 651, 445, 10, 1, 69 },
+  { 0x0, 0x0, 38, 652, 254, 0, 0, -1 },
+  { 0x0, 0x0, 40, 282, 340, 0, 0, -1 },
+  { 0x0, 0x0, 40, 283, 343, 0, 0, -1 },
+  { 0x0, 0x0, 40, 284, 340, 0, 0, -1 },
+  { 0x3, 0x3, 40, 285, 121, 33, 1, 8 },
+  { 0x18000001, 0x18000001, 40, 286, 123, 6, 1, 9 },
+  { 0x3, 0x3, 40, 287, 121, 33, 1, 8 },
+  { 0x0, 0x0, 40, 288, 347, 0, 0, -1 },
+  { 0x3, 0x3, 40, 289, 124, 33, 1, 10 },
+  { 0x0, 0x0, 40, 290, 351, 0, 0, -1 },
+  { 0x3, 0x3, 40, 291, 125, 33, 1, 17 },
+  { 0x0, 0x0, 40, 292, 356, 0, 0, -1 },
+  { 0x3, 0x3, 40, 293, 126, 33, 1, 19 },
+  { 0x0, 0x0, 40, 294, 359, 0, 0, -1 },
+  { 0x0, 0x0, 40, 295, 363, 0, 0, -1 },
+  { 0x3, 0x3, 40, 296, 128, 33, 1, 20 },
+  { 0x18000001, 0x18000001, 40, 297, 128, 6, 1, 20 },
+  { 0x0, 0x0, 40, 298, 367, 0, 0, -1 },
+  { 0x3, 0x3, 40, 299, 129, 33, 1, 21 },
+  { 0x0, 0x0, 40, 300, 371, 0, 0, -1 },
+  { 0x0, 0x0, 40, 301, 375, 0, 0, -1 },
+  { 0x3, 0x3, 40, 302, 130, 33, 1, 22 },
+  { 0x18000001, 0x18000001, 40, 303, 130, 6, 1, 22 },
+  { 0x0, 0x0, 40, 304, 379, 0, 0, -1 },
+  { 0x3, 0x3, 40, 305, 131, 33, 1, 23 },
+  { 0x0, 0x0, 41, 884, 341, 0, 0, -1 },
+  { 0x0, 0x0, 41, 885, 344, 0, 0, -1 },
+  { 0x0, 0x0, 41, 439, 341, 0, 0, -1 },
+  { 0x1, 0x1, 41, 886, 121, 34, 1, 8 },
+  { 0x10000001, 0x10000001, 41, 887, 123, 6, 1, 9 },
+  { 0x1, 0x1, 41, 440, 121, 34, 1, 8 },
+  { 0x0, 0x0, 41, 888, 348, 0, 0, -1 },
+  { 0x1, 0x1, 41, 889, 124, 34, 1, 10 },
+  { 0x0, 0x0, 41, 890, 352, 0, 0, -1 },
+  { 0x1, 0x1, 41, 891, 125, 34, 1, 17 },
+  { 0x0, 0x0, 41, 892, 357, 0, 0, -1 },
+  { 0x1, 0x1, 41, 893, 126, 34, 1, 19 },
+  { 0x0, 0x0, 41, 894, 360, 0, 0, -1 },
+  { 0x0, 0x0, 41, 895, 364, 0, 0, -1 },
+  { 0x1, 0x1, 41, 896, 128, 34, 1, 20 },
+  { 0x10000001, 0x10000001, 41, 897, 128, 6, 1, 20 },
+  { 0x0, 0x0, 41, 898, 368, 0, 0, -1 },
+  { 0x1, 0x1, 41, 899, 129, 34, 1, 21 },
+  { 0x0, 0x0, 41, 900, 372, 0, 0, -1 },
+  { 0x0, 0x0, 41, 901, 376, 0, 0, -1 },
+  { 0x1, 0x1, 41, 902, 130, 34, 1, 22 },
+  { 0x10000001, 0x10000001, 41, 903, 130, 6, 1, 22 },
+  { 0x0, 0x0, 41, 904, 380, 0, 0, -1 },
+  { 0x1, 0x1, 41, 905, 131, 34, 1, 23 },
+  { 0x800001, 0x800001, 41, 928, 383, 4, 1, 18 },
+  { 0x1, 0x1, 41, 738, 383, 4, 1, 18 },
+  { 0x0, 0x0, 41, 930, 170, 0, 0, -1 },
+  { 0x0, 0x0, 41, 739, 164, 0, 0, -1 },
+  { 0x1, 0x1, 41, 329, 388, 4, 1, 24 },
+  { 0x0, 0x0, 41, 330, 193, 0, 0, -1 },
+  { 0x0, 0x0, 41, 396, 394, 0, 0, -1 },
+  { 0x0, 0x0, 41, 398, 393, 0, 0, -1 },
+  { 0x0, 0x0, 42, -1, -1, 0, 1, 82 },
+  { 0x0, 0x0, 42, -1, -1, 0, 1, 125 },
+  { 0x1, 0x1, 44, 468, 86, 38, 1, 3 },
+  { 0x0, 0x0, 44, 543, 100, 0, 0, -1 },
+  { 0x0, 0x0, 44, 544, 91, 0, 0, -1 },
+  { 0x1, 0x1, 44, 472, 86, 38, 1, 3 },
+  { 0x0, 0x0, 44, 459, 761, 0, 0, -1 },
+  { 0x0, 0x0, 44, 460, 1016, 0, 1, 56 },
+  { 0x0, 0x0, 44, 461, 777, 0, 0, -1 },
+  { 0x0, 0x0, 44, 462, -1, 0, 1, 51 },
+  { 0x0, 0x0, 44, 423, -1, 0, 1, 0 },
+  { 0x1, 0x1, 45, 669, 669, 30, 1, 143 },
+  { 0x1, 0x1, 45, 334, 668, 30, 1, 142 },
+  { 0x1, 0x1, 45, 671, 671, 30, 1, 145 },
+  { 0x1, 0x1, 45, 335, 670, 30, 1, 144 },
+  { 0x3, 0x3, 46, 465, 388, 3, 1, 24 },
+  { 0x0, 0x0, 46, 466, 199, 0, 0, -1 },
+  { 0x1, 0x1, 47, 752, -1, 30, 1, 136 },
+  { 0x1, 0x1, 47, 755, -1, 30, 1, 146 },
+  { 0x0, 0x0, 49, -1, -1, 0, 1, 42 },
+  { 0x1, 0x1, 56, 668, 325, 31, 1, 143 },
+  { 0x1, 0x1, 56, 670, 327, 31, 1, 145 },
+  { 0x2, 0x3, 56, -1, -1, 27, 1, 96 },
+  { 0x0, 0x0, 56, -1, -1, 0, 1, 96 },
+  { 0x1, 0x1, 56, -1, -1, 28, 1, 96 },
+  { 0x0, 0x0, 65, 486, 121, 0, 1, 8 },
+  { 0x3, 0x3, 65, 487, 121, 33, 1, 8 },
+  { 0x1, 0x1, 65, 488, 121, 34, 1, 8 },
+  { 0x1, 0x1, 65, 489, 121, 33, 1, 8 },
+  { 0x18000001, 0x18000001, 65, 490, 123, 6, 1, 9 },
+  { 0x10000001, 0x10000001, 65, 491, 123, 6, 1, 9 },
+  { 0x8000001, 0x8000001, 65, 492, 123, 6, 1, 9 },
+  { 0x1, 0x1, 65, 493, 123, 6, 1, 9 },
+  { 0x3, 0x3, 65, 494, 124, 33, 1, 10 },
+  { 0x1, 0x1, 65, 495, 124, 34, 1, 10 },
+  { 0x1, 0x1, 65, 496, 124, 33, 1, 10 },
+  { 0x0, 0x0, 65, 497, 124, 0, 1, 10 },
+  { 0x3, 0x3, 65, 498, 125, 33, 1, 17 },
+  { 0x1, 0x1, 65, 499, 125, 34, 1, 17 },
+  { 0x1, 0x1, 65, 500, 125, 33, 1, 17 },
+  { 0x0, 0x0, 65, 501, 125, 0, 1, 17 },
+  { 0x0, 0x0, 65, 502, 126, 0, 1, 19 },
+  { 0x3, 0x3, 65, 503, 126, 33, 1, 19 },
+  { 0x1, 0x1, 65, 504, 126, 34, 1, 19 },
+  { 0x1, 0x1, 65, 505, 126, 33, 1, 19 },
+  { 0x3, 0x3, 65, 506, 128, 33, 1, 20 },
+  { 0x1, 0x1, 65, 507, 128, 34, 1, 20 },
+  { 0x1, 0x1, 65, 508, 128, 33, 1, 20 },
+  { 0x0, 0x0, 65, 509, 128, 0, 1, 20 },
+  { 0x18000001, 0x18000001, 65, 510, 128, 6, 1, 20 },
+  { 0x10000001, 0x10000001, 65, 511, 128, 6, 1, 20 },
+  { 0x8000001, 0x8000001, 65, 512, 128, 6, 1, 20 },
+  { 0x1, 0x1, 65, 513, 128, 6, 1, 20 },
+  { 0x3, 0x3, 65, 514, 129, 33, 1, 21 },
+  { 0x1, 0x1, 65, 515, 129, 34, 1, 21 },
+  { 0x1, 0x1, 65, 516, 129, 33, 1, 21 },
+  { 0x0, 0x0, 65, 517, 129, 0, 1, 21 },
+  { 0x3, 0x3, 65, 518, 130, 33, 1, 22 },
+  { 0x1, 0x1, 65, 519, 130, 34, 1, 22 },
+  { 0x1, 0x1, 65, 520, 130, 33, 1, 22 },
+  { 0x0, 0x0, 65, 521, 130, 0, 1, 22 },
+  { 0x18000001, 0x18000001, 65, 522, 130, 6, 1, 22 },
+  { 0x10000001, 0x10000001, 65, 523, 130, 6, 1, 22 },
+  { 0x8000001, 0x8000001, 65, 524, 130, 6, 1, 22 },
+  { 0x1, 0x1, 65, 525, 130, 6, 1, 22 },
+  { 0x3, 0x3, 65, 526, 131, 33, 1, 23 },
+  { 0x1, 0x1, 65, 527, 131, 34, 1, 23 },
+  { 0x1, 0x1, 65, 528, 131, 33, 1, 23 },
+  { 0x0, 0x0, 65, 529, 131, 0, 1, 23 },
+  { 0x0, 0x0, 65, 442, 154, 0, 0, -1 },
+  { 0x0, 0x0, 65, 576, 161, 0, 0, -1 },
+  { 0x0, 0x0, 65, 580, 167, 0, 0, -1 },
+  { 0x0, 0x0, 65, 584, 173, 0, 0, -1 },
+  { 0x0, 0x0, 65, 568, 179, 0, 0, -1 },
+  { 0x0, 0x0, 65, 444, 183, 0, 0, -1 },
+  { 0x0, 0x0, 65, 596, 190, 0, 0, -1 },
+  { 0x0, 0x0, 65, 600, 196, 0, 0, -1 },
+  { 0x0, 0x0, 65, 604, 202, 0, 0, -1 },
+  { 0x0, 0x0, 65, 588, 208, 0, 0, -1 },
+  { 0x0, 0x0, 65, 532, 213, 0, 0, -1 },
+  { 0x0, 0x0, 65, 533, 229, 0, 0, -1 },
+  { 0x0, 0x0, 65, 534, 245, 0, 0, -1 },
+  { 0x0, 0x0, 65, 535, 237, 0, 0, -1 },
+  { 0x0, 0x0, 65, 536, 253, 0, 0, -1 },
+  { 0x0, 0x0, 65, 537, 221, 0, 0, -1 },
+  { 0x3, 0x3, 66, 660, 661, 33, 1, 130 },
+  { 0x0, 0x0, 66, -1, 662, 0, 1, 137 },
+  { 0x0, 0x0, 107, 403, 771, 0, 0, -1 },
+  { 0x0, 0x0, 107, 404, 1007, 0, 1, 31 },
+  { 0x0, 0x0, 109, -1, 773, 0, 0, -1 },
+  { 0x1, 0x1, 109, -1, 1007, 27, 1, 31 },
+  { 0x0, 0x0, 110, 406, -1, 0, 1, 117 },
+  { 0x1, 0x1, 111, -1, -1, 27, 1, 117 },
+  { 0x0, 0x0, 112, 414, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 112, 417, 88, 0, 0, -1 },
+  { 0x0, 0x0, 112, 418, 102, 0, 0, -1 },
+  { 0x0, 0x0, 112, 420, 93, 0, 0, -1 },
+  { 0x0, 0x0, 112, 542, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 112, 421, 769, 0, 0, -1 },
+  { 0x1, 0x9, 112, 422, 1016, 33, 1, 56 },
+  { 0x1, 0x1, 114, 542, 1010, 37, 1, 3 },
+  { 0x0, 0x0, 114, -1, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 115, 424, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 115, 455, 89, 0, 0, -1 },
+  { 0x0, 0x0, 115, 456, 100, 0, 0, -1 },
+  { 0x0, 0x0, 115, -1, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 115, 458, 91, 0, 0, -1 },
+  { 0x0, 0x0, 115, -1, 761, 0, 0, -1 },
+  { 0x0, 0x0, 115, -1, 1016, 0, 1, 56 },
+  { 0x1, 0x1, 115, -1, -1, 27, 1, 0 },
+  { 0x1, 0x1, 116, -1, 1010, 37, 1, 3 },
+  { 0x0, 0x0, 116, -1, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 117, 451, -1, 0, 1, 0 },
+  { 0x3, 0x3, 117, 429, -1, 34, 1, 35 },
+  { 0x3, 0x3, 117, 430, -1, 34, 1, 42 },
+  { 0x1, 0x1, 118, 452, -1, 35, 1, 35 },
+  { 0x1, 0x1, 118, 453, -1, 35, 1, 42 },
+  { 0x0, 0x0, 119, -1, -1, 0, 1, 42 },
+  { 0x0, 0x0, 119, -1, -1, 0, 1, 68 },
+  { 0x1, 0x1, 119, -1, -1, 27, 1, 98 },
+  { 0x0, 0x0, 119, -1, -1, 0, 1, 107 },
+  { 0x0, 0x0, 119, -1, -1, 0, 1, 75 },
+  { 0x0, 0x0, 119, -1, -1, 0, 1, 76 },
+  { 0x1, 0x1, 119, -1, -1, 27, 1, 119 },
+  { 0x1, 0x1, 119, -1, -1, 27, 1, 42 },
+  { 0x0, 0x0, 120, 884, 259, 0, 0, -1 },
+  { 0x0, 0x0, 120, 886, 262, 0, 0, -1 },
+  { 0x1, 0x1, 121, -1, -1, 35, 1, 18 },
+  { 0x1, 0x1, 121, 530, -1, 35, 1, 18 },
+  { 0x1, 0x1, 121, -1, -1, 35, 1, 24 },
+  { 0x1, 0x1, 121, 531, -1, 35, 1, 24 },
+  { 0x1, 0x1, 121, -1, -1, 23, 1, 69 },
+  { 0x0, 0x0, 125, 725, -1, 0, 1, 0 },
+  { 0x1, 0x1, 125, 467, -1, 28, 1, 35 },
+  { 0x1, 0x1, 125, 727, -1, 27, 1, 35 },
+  { 0x1, 0x1, 125, 728, -1, 29, 1, 0 },
+  { 0x0, 0x0, 125, -1, -1, 0, 1, 116 },
+  { 0x1, 0x1, 125, -1, -1, 29, 1, 0 },
+  { 0x0, 0x0, 125, -1, -1, 0, 1, 35 },
+  { 0x0, 0x0, 125, 480, -1, 0, 1, 42 },
+  { 0x0, 0x0, 138, 463, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 138, 469, 90, 0, 0, -1 },
+  { 0x0, 0x0, 138, 470, 101, 0, 0, -1 },
+  { 0x0, 0x0, 138, -1, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 138, 471, 92, 0, 0, -1 },
+  { 0x0, 0x0, 138, 473, 763, 0, 0, -1 },
+  { 0x1, 0x1, 138, 474, 1016, 33, 1, 56 },
+  { 0x0, 0x0, 138, 475, 778, 0, 0, -1 },
+  { 0x1, 0x1, 138, 476, -1, 28, 1, 51 },
+  { 0x1, 0x1, 139, -1, 1010, 37, 1, 3 },
+  { 0x0, 0x0, 139, -1, 1010, 0, 1, 3 },
+  { 0x1, 0x1, 142, 932, 388, 3, 1, 24 },
+  { 0x0, 0x0, 142, 933, 205, 0, 0, -1 },
+  { 0x0, 0x0, 143, 726, -1, 0, 1, 35 },
+  { 0x0, 0x0, 144, 477, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 144, -1, 87, 0, 0, -1 },
+  { 0x0, 0x0, 144, -1, 103, 0, 0, -1 },
+  { 0x0, 0x0, 144, -1, 94, 0, 0, -1 },
+  { 0x0, 0x0, 144, 541, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 144, 1019, 765, 0, 0, -1 },
+  { 0x1, 0x1, 144, 1020, 1016, 36, 1, 56 },
+  { 0x0, 0x0, 144, 547, 779, 0, 0, -1 },
+  { 0x1, 0x1, 144, 548, -1, 27, 1, 51 },
+  { 0x1, 0x1, 145, 541, 1010, 37, 1, 3 },
+  { 0x0, 0x0, 145, -1, 1010, 0, 1, 3 },
+  { 0x0, 0x0, 146, -1, -1, 0, 1, 35 },
+  { 0x0, 0x0, 146, -1, -1, 0, 1, 42 },
+  { 0x0, 0x0, 147, -1, -1, 0, 1, 42 },
+  { 0x0, 0x0, 147, -1, -1, 0, 1, 68 },
+  { 0x0, 0x0, 147, -1, 1011, 0, 1, 65 },
+  { 0x0, 0x0, 147, -1, -1, 0, 1, 83 },
+  { 0x0, 0x0, 147, -1, -1, 0, 1, 87 },
+  { 0x1, 0x1, 148, -1, 121, 12, 1, 8 },
+  { 0x600001, 0x600001, 148, -1, 121, 12, 1, 8 },
+  { 0x400001, 0x400001, 148, -1, 121, 12, 1, 8 },
+  { 0x200001, 0x200001, 148, -1, 121, 12, 1, 8 },
+  { 0x18000041, 0x18000041, 148, -1, 123, 6, 1, 9 },
+  { 0x10000041, 0x10000041, 148, -1, 123, 6, 1, 9 },
+  { 0x8000041, 0x8000041, 148, -1, 123, 6, 1, 9 },
+  { 0x41, 0x41, 148, -1, 123, 6, 1, 9 },
+  { 0x600001, 0x600001, 148, -1, 124, 12, 1, 10 },
+  { 0x400001, 0x400001, 148, -1, 124, 12, 1, 10 },
+  { 0x200001, 0x200001, 148, -1, 124, 12, 1, 10 },
+  { 0x1, 0x1, 148, -1, 124, 12, 1, 10 },
+  { 0x600001, 0x600001, 148, -1, 125, 12, 1, 17 },
+  { 0x400001, 0x400001, 148, -1, 125, 12, 1, 17 },
+  { 0x200001, 0x200001, 148, -1, 125, 12, 1, 17 },
+  { 0x1, 0x1, 148, -1, 125, 12, 1, 17 },
+  { 0x1, 0x1, 148, -1, 126, 12, 1, 19 },
+  { 0x600001, 0x600001, 148, -1, 126, 12, 1, 19 },
+  { 0x400001, 0x400001, 148, -1, 126, 12, 1, 19 },
+  { 0x200001, 0x200001, 148, -1, 126, 12, 1, 19 },
+  { 0x600001, 0x600001, 148, -1, 128, 12, 1, 20 },
+  { 0x400001, 0x400001, 148, -1, 128, 12, 1, 20 },
+  { 0x200001, 0x200001, 148, -1, 128, 12, 1, 20 },
+  { 0x1, 0x1, 148, -1, 128, 12, 1, 20 },
+  { 0x18000041, 0x18000041, 148, -1, 128, 6, 1, 20 },
+  { 0x10000041, 0x10000041, 148, -1, 128, 6, 1, 20 },
+  { 0x8000041, 0x8000041, 148, -1, 128, 6, 1, 20 },
+  { 0x41, 0x41, 148, -1, 128, 6, 1, 20 },
+  { 0x600001, 0x600001, 148, -1, 129, 12, 1, 21 },
+  { 0x400001, 0x400001, 148, -1, 129, 12, 1, 21 },
+  { 0x200001, 0x200001, 148, -1, 129, 12, 1, 21 },
+  { 0x1, 0x1, 148, -1, 129, 12, 1, 21 },
+  { 0x600001, 0x600001, 148, -1, 130, 12, 1, 22 },
+  { 0x400001, 0x400001, 148, -1, 130, 12, 1, 22 },
+  { 0x200001, 0x200001, 148, -1, 130, 12, 1, 22 },
+  { 0x1, 0x1, 148, -1, 130, 12, 1, 22 },
+  { 0x18000041, 0x18000041, 148, -1, 130, 6, 1, 22 },
+  { 0x10000041, 0x10000041, 148, -1, 130, 6, 1, 22 },
+  { 0x8000041, 0x8000041, 148, -1, 130, 6, 1, 22 },
+  { 0x41, 0x41, 148, -1, 130, 6, 1, 22 },
+  { 0x600001, 0x600001, 148, -1, 131, 12, 1, 23 },
+  { 0x400001, 0x400001, 148, -1, 131, 12, 1, 23 },
+  { 0x200001, 0x200001, 148, -1, 131, 12, 1, 23 },
+  { 0x1, 0x1, 148, -1, 131, 12, 1, 23 },
+  { 0x0, 0x0, 148, -1, 158, 0, 0, -1 },
+  { 0x0, 0x0, 148, -1, 187, 0, 0, -1 },
+  { 0x0, 0x0, 148, -1, 217, 0, 0, -1 },
+  { 0x0, 0x0, 148, -1, 233, 0, 0, -1 },
+  { 0x0, 0x0, 148, -1, 249, 0, 0, -1 },
+  { 0x0, 0x0, 148, 934, 241, 0, 0, -1 },
+  { 0x0, 0x0, 148, -1, 257, 0, 0, -1 },
+  { 0x0, 0x0, 148, 740, 225, 0, 0, -1 },
+  { 0x0, 0x0, 157, -1, -1, 0, 1, 77 },
+  { 0x9, 0x9, 157, -1, 657, 32, 1, 131 },
+  { 0x9, 0x9, 157, -1, 664, 32, 1, 141 },
+  { 0x0, 0x0, 158, -1, 87, 0, 0, -1 },
+  { 0x1, 0x1, 158, -1, 1010, 38, 1, 3 },
+  { 0x0, 0x0, 158, -1, 101, 0, 0, -1 },
+  { 0x0, 0x0, 158, -1, 92, 0, 0, -1 },
+  { 0x0, 0x0, 159, 554, 761, 0, 0, -1 },
+  { 0x0, 0x0, 159, 555, 1016, 0, 1, 56 },
+  { 0x0, 0x0, 159, 556, 780, 0, 0, -1 },
+  { 0x1, 0x1, 159, 557, -1, 29, 1, 51 },
+  { 0x0, 0x0, 160, 551, 769, 0, 0, -1 },
+  { 0x1, 0x9, 160, 552, 1016, 33, 1, 56 },
+  { 0x0, 0x0, 161, -1, 761, 0, 0, -1 },
+  { 0x0, 0x0, 161, -1, 1016, 0, 1, 56 },
+  { 0x1, 0x1, 162, 563, -1, 27, 1, 35 },
+  { 0x0, 0x0, 163, 558, 763, 0, 0, -1 },
+  { 0x1, 0x1, 163, 559, 1016, 33, 1, 56 },
+  { 0x0, 0x0, 163, 560, 781, 0, 0, -1 },
+  { 0x3, 0x3, 163, 561, -1, 28, 1, 51 },
+  { 0x0, 0x0, 164, 720, 765, 0, 0, -1 },
+  { 0x1, 0x1, 164, 721, 1016, 36, 1, 56 },
+  { 0x0, 0x0, 164, 722, 782, 0, 0, -1 },
+  { 0x5, 0x5, 164, 723, -1, 27, 1, 51 },
+  { 0x0, 0x0, 165, -1, 1011, 0, 1, 65 },
+  { 0x1, 0x1, 167, -1, -1, 28, 1, 35 },
+  { 0x1, 0x1, 168, 749, -1, 27, 1, 35 },
+  { 0x1, 0x1, 169, -1, 441, 0, 1, 18 },
+  { 0x7, 0x7, 169, 939, 441, 0, 1, 18 },
+  { 0x1, 0x1, 169, 940, 441, 2, 1, 18 },
+  { 0x0, 0x0, 169, 941, 152, 0, 0, -1 },
+  { 0x21, 0x21, 169, -1, 441, 0, 1, 18 },
+  { 0x27, 0x27, 169, 942, 441, 0, 1, 18 },
+  { 0x9, 0x9, 169, 943, 441, 2, 1, 18 },
+  { 0x0, 0x0, 169, 944, 156, 0, 0, -1 },
+  { 0x11, 0x11, 169, -1, 441, 0, 1, 18 },
+  { 0x17, 0x17, 169, 945, 441, 0, 1, 18 },
+  { 0x5, 0x5, 169, 946, 441, 2, 1, 18 },
+  { 0x0, 0x0, 169, 947, 162, 0, 0, -1 },
+  { 0x8000011, 0x8000011, 169, -1, 441, 0, 1, 18 },
+  { 0x8000017, 0x8000017, 169, 948, 441, 0, 1, 18 },
+  { 0x2000005, 0x2000005, 169, 949, 441, 2, 1, 18 },
+  { 0x0, 0x0, 169, 950, 168, 0, 0, -1 },
+  { 0x8000001, 0x8000001, 169, -1, 441, 0, 1, 18 },
+  { 0x8000007, 0x8000007, 169, 951, 441, 0, 1, 18 },
+  { 0x2000001, 0x2000001, 169, 952, 441, 2, 1, 18 },
+  { 0x0, 0x0, 169, 953, 174, 0, 0, -1 },
+  { 0x1, 0x1, 169, -1, 443, 0, 1, 24 },
+  { 0x7, 0x7, 169, 954, 443, 0, 1, 24 },
+  { 0x1, 0x1, 169, 955, 443, 2, 1, 24 },
+  { 0x0, 0x0, 169, 956, 181, 0, 0, -1 },
+  { 0x21, 0x21, 169, -1, 443, 0, 1, 24 },
+  { 0x27, 0x27, 169, 957, 443, 0, 1, 24 },
+  { 0x9, 0x9, 169, 958, 443, 2, 1, 24 },
+  { 0x0, 0x0, 169, 959, 185, 0, 0, -1 },
+  { 0x11, 0x11, 169, -1, 443, 0, 1, 24 },
+  { 0x17, 0x17, 169, 960, 443, 0, 1, 24 },
+  { 0x5, 0x5, 169, 961, 443, 2, 1, 24 },
+  { 0x0, 0x0, 169, 962, 191, 0, 0, -1 },
+  { 0x19, 0x19, 169, -1, 443, 0, 1, 24 },
+  { 0x1f, 0x1f, 169, 963, 443, 0, 1, 24 },
+  { 0x7, 0x7, 169, 964, 443, 2, 1, 24 },
+  { 0x0, 0x0, 169, 965, 197, 0, 0, -1 },
+  { 0x9, 0x9, 169, -1, 443, 0, 1, 24 },
+  { 0xf, 0xf, 169, 966, 443, 0, 1, 24 },
+  { 0x3, 0x3, 169, 967, 443, 2, 1, 24 },
+  { 0x0, 0x0, 169, 968, 203, 0, 0, -1 },
+  { 0x1001, 0x1001, 169, -1, 445, 9, 1, 69 },
+  { 0x1007, 0x1007, 169, 969, 445, 9, 1, 69 },
+  { 0x401, 0x401, 169, 970, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 971, 211, 0, 0, -1 },
+  { 0x1009, 0x1009, 169, -1, 445, 9, 1, 69 },
+  { 0x100f, 0x100f, 169, 972, 445, 9, 1, 69 },
+  { 0x403, 0x403, 169, 973, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 974, 215, 0, 0, -1 },
+  { 0x801, 0x801, 169, -1, 445, 9, 1, 69 },
+  { 0x807, 0x807, 169, 975, 445, 9, 1, 69 },
+  { 0x201, 0x201, 169, 976, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 977, 219, 0, 0, -1 },
+  { 0x809, 0x809, 169, -1, 445, 9, 1, 69 },
+  { 0x80f, 0x80f, 169, 978, 445, 9, 1, 69 },
+  { 0x203, 0x203, 169, 979, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 980, 223, 0, 0, -1 },
+  { 0x3001, 0x3001, 169, -1, 445, 9, 1, 69 },
+  { 0x3007, 0x3007, 169, 981, 445, 9, 1, 69 },
+  { 0xc01, 0xc01, 169, 982, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 983, 227, 0, 0, -1 },
+  { 0x3009, 0x3009, 169, -1, 445, 9, 1, 69 },
+  { 0x300f, 0x300f, 169, 984, 445, 9, 1, 69 },
+  { 0xc03, 0xc03, 169, 985, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 986, 231, 0, 0, -1 },
+  { 0x2801, 0x2801, 169, -1, 445, 9, 1, 69 },
+  { 0x2807, 0x2807, 169, 987, 445, 9, 1, 69 },
+  { 0xa01, 0xa01, 169, 988, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 989, 235, 0, 0, -1 },
+  { 0x2809, 0x2809, 169, -1, 445, 9, 1, 69 },
+  { 0x280f, 0x280f, 169, 990, 445, 9, 1, 69 },
+  { 0xa03, 0xa03, 169, 991, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 992, 239, 0, 0, -1 },
+  { 0x2001, 0x2001, 169, -1, 445, 9, 1, 69 },
+  { 0x2007, 0x2007, 169, 993, 445, 9, 1, 69 },
+  { 0x801, 0x801, 169, 994, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 995, 243, 0, 0, -1 },
+  { 0x2009, 0x2009, 169, -1, 445, 9, 1, 69 },
+  { 0x200f, 0x200f, 169, 996, 445, 9, 1, 69 },
+  { 0x803, 0x803, 169, 997, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 998, 247, 0, 0, -1 },
+  { 0x1, 0x1, 169, -1, 445, 9, 1, 69 },
+  { 0x7, 0x7, 169, 999, 445, 9, 1, 69 },
+  { 0x1, 0x1, 169, 1000, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 1001, 251, 0, 0, -1 },
+  { 0x9, 0x9, 169, -1, 445, 9, 1, 69 },
+  { 0xf, 0xf, 169, 1002, 445, 9, 1, 69 },
+  { 0x3, 0x3, 169, 1003, 445, 11, 1, 69 },
+  { 0x0, 0x0, 169, 1004, 255, 0, 0, -1 },
+  { 0x1, 0x1, 170, 676, -1, 28, 1, 134 },
+  { 0x1, 0x1, 170, 677, -1, 28, 1, 135 },
+  { 0x1, 0x1, 170, 678, -1, 28, 1, 128 },
+  { 0x1, 0x1, 170, 679, -1, 28, 1, 126 },
+  { 0x1, 0x1, 170, 680, -1, 28, 1, 131 },
+  { 0x1, 0x1, 170, 681, -1, 28, 1, 127 },
+  { 0x1, 0x1, 170, 682, -1, 28, 1, 129 },
+  { 0x1, 0x1, 170, 683, -1, 28, 1, 126 },
+  { 0x1, 0x1, 170, 684, -1, 28, 1, 130 },
+  { 0x1, 0x1, 170, 685, -1, 28, 1, 137 },
+  { 0x1, 0x1, 170, 686, -1, 28, 1, 139 },
+  { 0x1, 0x1, 170, 687, -1, 28, 1, 141 },
+  { 0x1, 0x1, 170, 688, -1, 28, 1, 138 },
+  { 0x1, 0x1, 170, 689, -1, 28, 1, 140 },
+  { 0x1, 0x1, 170, 690, -1, 28, 1, 137 },
+  { 0x1, 0x1, 170, 672, -1, 28, 1, 142 },
+  { 0x1, 0x1, 170, 673, -1, 28, 1, 143 },
+  { 0x1, 0x1, 170, 674, -1, 28, 1, 144 },
+  { 0x1, 0x1, 170, 675, -1, 28, 1, 145 },
+  { 0x1, 0x1, 171, 691, -1, 29, 1, 142 },
+  { 0x1, 0x1, 171, 692, -1, 29, 1, 143 },
+  { 0x1, 0x1, 171, 693, -1, 29, 1, 144 },
+  { 0x1, 0x1, 171, 694, -1, 29, 1, 145 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 134 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 135 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 128 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 126 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 131 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 127 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 129 },
+  { 0x3, 0x3, 172, 753, -1, 28, 1, 126 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 130 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 137 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 139 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 141 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 138 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 140 },
+  { 0x3, 0x3, 172, 754, -1, 28, 1, 137 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 142 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 143 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 144 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 145 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 132 },
+  { 0x3, 0x3, 172, 734, -1, 28, 1, 132 },
+  { 0x3, 0x3, 172, -1, -1, 28, 1, 133 },
+  { 0x3, 0x3, 172, 735, -1, 28, 1, 132 },
+  { 0x0, 0x0, 173, 1036, 95, 0, 0, -1 },
+  { 0x0, 0x0, 173, 1037, 97, 0, 1, 3 },
+  { 0x11, 0x31, 174, 1010, 99, 33, 1, 6 },
+  { 0x2200001, 0x2200001, 174, -1, 99, 12, 1, 6 },
+  { 0x11, 0x11, 174, -1, 99, 33, 1, 6 },
+  { 0x1, 0x1, 174, -1, 99, 37, 1, 6 },
+  { 0x2000001, 0x2000001, 174, -1, 99, 12, 1, 6 },
+  { 0x200001, 0x200001, 174, -1, 104, 12, 1, 6 },
+  { 0x1, 0x1, 174, 1010, 104, 33, 1, 6 },
+  { 0x2000001, 0x2000001, 175, -1, -1, 12, 1, 6 },
+  { 0x1, 0x1, 175, -1, -1, 37, 1, 6 },
+  { 0x2200001, 0x2200001, 175, -1, -1, 12, 1, 6 },
+  { 0x11, 0x11, 175, -1, -1, 33, 1, 6 },
+  { 0x1, 0x1, 175, -1, -1, 12, 1, 7 },
+  { 0x0, 0x0, 175, -1, -1, 0, 1, 7 },
+  { 0x200001, 0x200001, 175, -1, -1, 12, 1, 7 },
+  { 0x1, 0x1, 175, -1, -1, 33, 1, 7 },
+  { 0x9, 0x9, 175, -1, -1, 33, 1, 7 },
+  { 0x1, 0x1, 175, 1010, -1, 33, 1, 6 },
+  { 0x1200001, 0x1200001, 175, -1, -1, 12, 1, 7 },
+  { 0x200001, 0x200001, 175, -1, -1, 12, 1, 6 },
+  { 0x0, 0x0, 176, -1, 767, 0, 0, -1 },
+  { 0x9, 0x9, 176, -1, 1017, 33, 1, 51 },
+  { 0x0, 0x0, 176, 1021, 783, 0, 0, -1 },
+  { 0x7, 0x7, 176, 1022, -1, 27, 1, 51 },
+  { 0x1, 0x1, 196, -1, -1, 27, 1, 12 },
+  { 0x1, 0x1, 210, -1, -1, 29, 1, 0 },
+  { 0x2, 0x3, 210, -1, -1, 27, 1, 35 },
+  { 0x0, 0x0, 210, -1, -1, 0, 1, 35 },
+  { 0x0, 0x0, 210, -1, -1, 0, 1, 0 },
+  { 0x0, 0x0, 210, 1026, -1, 0, 1, 95 },
+  { 0x0, 0x0, 210, 741, 336, 0, 0, -1 },
+  { 0x1, 0x1, 211, -1, -1, 27, 1, 0 },
+  { 0x1, 0x1, 212, -1, 653, 32, 1, 134 },
+  { 0x1, 0x1, 212, -1, 654, 32, 1, 135 },
+  { 0x1, 0x1, 212, -1, 695, 32, 1, 132 },
+  { 0x1, 0x1, 212, 882, 695, 32, 1, 132 },
+  { 0x0, 0x0, 213, -1, 264, 0, 0, -1 },
+  { 0x0, 0x0, 213, -1, 265, 0, 0, -1 },
+  { 0x0, 0x0, 213, 929, 306, 0, 0, -1 },
+  { 0x0, 0x0, 213, 931, 308, 0, 0, -1 },
+  { 0x0, 0x0, 213, 935, 312, 0, 0, -1 },
+  { 0x0, 0x0, 217, 1027, 337, 0, 0, -1 },
+  { 0x0, 0x0, 218, -1, 432, 0, 0, -1 },
+  { 0x0, 0x0, 218, -1, 482, 0, 0, -1 },
+  { 0x0, 0x0, 218, -1, -1, 0, 1, 123 },
+  { 0x0, 0x0, 218, -1, -1, 0, 1, 68 },
+  { 0x1, 0x1, 218, 756, 757, 36, 1, 67 },
+  { 0x1, 0x1, 218, 756, 788, 36, 1, 67 },
+  { 0x0, 0x0, 218, -1, 775, 0, 0, -1 },
+  { 0x0, 0x0, 218, 879, -1, 0, 1, 35 },
+  { 0x0, 0x0, 218, 756, 776, 0, 0, -1 },
+  { 0x1, 0x1, 218, -1, -1, 36, 1, 67 },
+  { 0x1, 0x1, 218, 880, -1, 31, 1, 136 },
+  { 0x1, 0x1, 218, 877, 658, 32, 1, 127 },
+  { 0x1, 0x1, 218, 878, 665, 32, 1, 138 },
+  { 0x1, 0x1, 218, 881, -1, 31, 1, 146 },
+  { 0x0, 0x0, 219, 787, -1, 0, 1, 30 },
+  { 0x0, 0x0, 219, 788, -1, 0, 1, 67 },
+  { 0x0, 0x0, 219, 789, -1, 0, 1, 46 },
+  { 0x0, 0x0, 219, 790, -1, 0, 1, 41 },
+  { 0x1, 0x1, 219, 791, -1, 12, 1, 60 },
+  { 0x0, 0x0, 219, 792, -1, 0, 1, 55 },
+  { 0x200001, 0x200001, 219, 793, -1, 12, 1, 60 },
+  { 0x1, 0x1, 219, 794, -1, 33, 1, 55 },
+  { 0x1000001, 0x1000001, 219, 795, -1, 12, 1, 60 },
+  { 0x1, 0x1, 219, 796, -1, 36, 1, 55 },
+  { 0x1200001, 0x1200001, 219, 797, -1, 12, 1, 50 },
+  { 0x9, 0x9, 219, 798, -1, 33, 1, 50 },
+  { 0x200001, 0x1200001, 219, 799, -1, 12, 1, 60 },
+  { 0x1, 0x9, 219, 800, -1, 33, 1, 55 },
+  { 0x1, 0x1, 219, 801, -1, 28, 1, 30 },
+  { 0x0, 0x0, 219, 802, -1, 0, 1, 30 },
+  { 0x3, 0x3, 219, 803, -1, 27, 1, 30 },
+  { 0x1, 0x1, 219, 804, -1, 27, 1, 30 },
+  { 0x1, 0x1, 219, 805, -1, 37, 1, 30 },
+  { 0x1, 0x1, 219, -1, -1, 36, 1, 67 },
+  { 0x1, 0x1, 219, 806, -1, 36, 1, 67 },
+  { 0x0, 0x0, 219, 807, -1, 0, 1, 50 },
+  { 0x1, 0x1, 219, 808, -1, 28, 1, 50 },
+  { 0x1, 0x1, 219, 809, -1, 27, 1, 50 },
+  { 0x1, 0x1, 219, 810, -1, 29, 1, 50 },
+  { 0x3, 0x3, 219, 811, -1, 28, 1, 50 },
+  { 0x5, 0x5, 219, 812, -1, 27, 1, 50 },
+  { 0x7, 0x7, 219, 813, -1, 27, 1, 50 },
+  { 0x3, 0x3, 219, 814, -1, 27, 1, 50 },
+  { 0x0, 0x0, 219, 815, -1, 0, 1, 25 },
+  { 0x0, 0x0, 219, 816, -1, 0, 1, 36 },
+  { 0x1, 0x1, 220, 817, -1, 34, 1, 32 },
+  { 0x1, 0x1, 220, 818, -1, 34, 1, 67 },
+  { 0x1, 0x1, 220, 819, -1, 34, 1, 47 },
+  { 0x1, 0x1, 220, 820, -1, 34, 1, 43 },
+  { 0x400001, 0x400001, 220, 821, -1, 12, 1, 62 },
+  { 0x1, 0x1, 220, 822, -1, 34, 1, 57 },
+  { 0x600001, 0x600001, 220, 823, -1, 12, 1, 62 },
+  { 0x3, 0x3, 220, 824, -1, 33, 1, 57 },
+  { 0x1400001, 0x1400001, 220, 825, -1, 12, 1, 62 },
+  { 0x5, 0x5, 220, 826, -1, 34, 1, 57 },
+  { 0x1600001, 0x1600001, 220, 827, -1, 12, 1, 52 },
+  { 0xb, 0xb, 220, 828, -1, 33, 1, 52 },
+  { 0x600001, 0x1600001, 220, 829, -1, 12, 1, 62 },
+  { 0x3, 0xb, 220, 830, -1, 33, 1, 57 },
+  { 0x41, 0x41, 220, 831, -1, 28, 1, 32 },
+  { 0x1, 0x1, 220, 832, -1, 34, 1, 32 },
+  { 0x83, 0x83, 220, 833, -1, 27, 1, 32 },
+  { 0x81, 0x81, 220, 834, -1, 27, 1, 32 },
+  { 0x9, 0x9, 220, 835, -1, 34, 1, 32 },
+  { 0x5, 0x5, 220, 836, -1, 34, 1, 67 },
+  { 0x1, 0x1, 220, 837, -1, 34, 1, 52 },
+  { 0x41, 0x41, 220, 838, -1, 28, 1, 52 },
+  { 0x81, 0x81, 220, 839, -1, 27, 1, 52 },
+  { 0x21, 0x21, 220, 840, -1, 29, 1, 52 },
+  { 0x43, 0x43, 220, 841, -1, 28, 1, 52 },
+  { 0x85, 0x85, 220, 842, -1, 27, 1, 52 },
+  { 0x87, 0x87, 220, 843, -1, 27, 1, 52 },
+  { 0x83, 0x83, 220, 844, -1, 27, 1, 52 },
+  { 0x1, 0x1, 220, 845, -1, 34, 1, 27 },
+  { 0x1, 0x1, 220, 846, -1, 34, 1, 38 },
+  { 0x1, 0x1, 221, 847, -1, 35, 1, 33 },
+  { 0x1, 0x1, 221, 848, -1, 35, 1, 67 },
+  { 0x1, 0x1, 221, 849, -1, 35, 1, 48 },
+  { 0x1, 0x1, 221, 850, -1, 35, 1, 44 },
+  { 0x800001, 0x800001, 221, 851, -1, 12, 1, 63 },
+  { 0x1, 0x1, 221, 852, -1, 35, 1, 58 },
+  { 0xa00001, 0xa00001, 221, 853, -1, 12, 1, 63 },
+  { 0x5, 0x5, 221, 854, -1, 33, 1, 58 },
+  { 0x1800001, 0x1800001, 221, 855, -1, 12, 1, 63 },
+  { 0x3, 0x3, 221, 856, -1, 35, 1, 58 },
+  { 0x1a00001, 0x1a00001, 221, 857, -1, 12, 1, 53 },
+  { 0xd, 0xd, 221, 858, -1, 33, 1, 53 },
+  { 0xa00001, 0x1a00001, 221, 859, -1, 12, 1, 63 },
+  { 0x5, 0xd, 221, 860, -1, 33, 1, 58 },
+  { 0x81, 0x81, 221, 861, -1, 28, 1, 33 },
+  { 0x1, 0x1, 221, 862, -1, 35, 1, 33 },
+  { 0x103, 0x103, 221, 863, -1, 27, 1, 33 },
+  { 0x101, 0x101, 221, 864, -1, 27, 1, 33 },
+  { 0x5, 0x5, 221, 865, -1, 35, 1, 33 },
+  { 0x3, 0x3, 221, 866, -1, 35, 1, 67 },
+  { 0x1, 0x1, 221, 867, -1, 35, 1, 53 },
+  { 0x81, 0x81, 221, 868, -1, 28, 1, 53 },
+  { 0x101, 0x101, 221, 869, -1, 27, 1, 53 },
+  { 0x41, 0x41, 221, 870, -1, 29, 1, 53 },
+  { 0x83, 0x83, 221, 871, -1, 28, 1, 53 },
+  { 0x105, 0x105, 221, 872, -1, 27, 1, 53 },
+  { 0x107, 0x107, 221, 873, -1, 27, 1, 53 },
+  { 0x103, 0x103, 221, 874, -1, 27, 1, 53 },
+  { 0x1, 0x1, 221, 875, -1, 35, 1, 28 },
+  { 0x1, 0x1, 221, 876, -1, 35, 1, 39 },
+  { 0x3, 0x3, 222, -1, -1, 34, 1, 34 },
+  { 0x3, 0x3, 222, -1, -1, 34, 1, 67 },
+  { 0x3, 0x3, 222, -1, -1, 34, 1, 49 },
+  { 0x3, 0x3, 222, -1, -1, 34, 1, 45 },
+  { 0xc00001, 0xc00001, 222, -1, -1, 12, 1, 64 },
+  { 0x3, 0x3, 222, 1012, -1, 34, 1, 59 },
+  { 0xe00001, 0xe00001, 222, -1, -1, 12, 1, 64 },
+  { 0x7, 0x7, 222, 1013, -1, 33, 1, 59 },
+  { 0x1c00001, 0x1c00001, 222, -1, -1, 12, 1, 64 },
+  { 0x7, 0x7, 222, 1014, -1, 34, 1, 59 },
+  { 0x1e00001, 0x1e00001, 222, -1, -1, 12, 1, 54 },
+  { 0xf, 0xf, 222, 1015, -1, 33, 1, 54 },
+  { 0xe00001, 0x1e00001, 222, -1, -1, 12, 1, 64 },
+  { 0x7, 0xf, 222, 1018, -1, 33, 1, 59 },
+  { 0xc1, 0xc1, 222, -1, -1, 28, 1, 34 },
+  { 0x3, 0x3, 222, 1005, -1, 34, 1, 34 },
+  { 0x183, 0x183, 222, -1, -1, 27, 1, 34 },
+  { 0x181, 0x181, 222, 1006, -1, 27, 1, 34 },
+  { 0xb, 0xb, 222, -1, -1, 34, 1, 34 },
+  { 0x7, 0x7, 222, -1, -1, 34, 1, 67 },
+  { 0x3, 0x3, 222, -1, -1, 34, 1, 54 },
+  { 0xc1, 0xc1, 222, -1, -1, 28, 1, 54 },
+  { 0x181, 0x181, 222, -1, -1, 27, 1, 54 },
+  { 0x61, 0x61, 222, -1, -1, 29, 1, 54 },
+  { 0xc3, 0xc3, 222, -1, -1, 28, 1, 54 },
+  { 0x185, 0x185, 222, -1, -1, 27, 1, 54 },
+  { 0x187, 0x187, 222, -1, -1, 27, 1, 54 },
+  { 0x183, 0x183, 222, -1, -1, 27, 1, 54 },
+  { 0x3, 0x3, 222, -1, -1, 34, 1, 29 },
+  { 0x3, 0x3, 222, -1, -1, 34, 1, 40 },
+  { 0x3, 0x3, 223, -1, 659, 32, 1, 129 },
+  { 0x3, 0x3, 223, -1, 666, 32, 1, 140 },
+  { 0x1, 0x1, 224, -1, -1, 28, 1, 35 },
+  { 0x0, 0x0, 231, -1, -1, 0, 1, 136 },
+  { 0x0, 0x0, 231, -1, -1, 0, 1, 146 },
+  { 0x1, 0x1, 232, -1, 697, 33, 1, 133 },
+  { 0x0, 0x0, 232, -1, 695, 0, 1, 132 },
+  { 0x0, 0x0, 233, 906, 342, 0, 0, -1 },
+  { 0x0, 0x0, 233, 907, 345, 0, 0, -1 },
+  { 0x1, 0x1, 233, 908, 121, 33, 1, 8 },
+  { 0x8000001, 0x8000001, 233, 909, 123, 6, 1, 9 },
+  { 0x0, 0x0, 233, 910, 349, 0, 0, -1 },
+  { 0x1, 0x1, 233, 911, 124, 33, 1, 10 },
+  { 0x0, 0x0, 233, 912, 353, 0, 0, -1 },
+  { 0x1, 0x1, 233, 913, 125, 33, 1, 17 },
+  { 0x0, 0x0, 233, 914, 358, 0, 0, -1 },
+  { 0x1, 0x1, 233, 915, 126, 33, 1, 19 },
+  { 0x0, 0x0, 233, 916, 361, 0, 0, -1 },
+  { 0x0, 0x0, 233, 917, 365, 0, 0, -1 },
+  { 0x1, 0x1, 233, 918, 128, 33, 1, 20 },
+  { 0x8000001, 0x8000001, 233, 919, 128, 6, 1, 20 },
+  { 0x0, 0x0, 233, 920, 369, 0, 0, -1 },
+  { 0x1, 0x1, 233, 921, 129, 33, 1, 21 },
+  { 0x0, 0x0, 233, 922, 373, 0, 0, -1 },
+  { 0x0, 0x0, 233, 923, 377, 0, 0, -1 },
+  { 0x1, 0x1, 233, 924, 130, 33, 1, 22 },
+  { 0x8000001, 0x8000001, 233, 925, 130, 6, 1, 22 },
+  { 0x0, 0x0, 233, 926, 381, 0, 0, -1 },
+  { 0x1, 0x1, 233, 927, 131, 33, 1, 23 },
+  { 0x0, 0x0, 234, -1, 339, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 346, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 121, 0, 1, 8 },
+  { 0x1, 0x1, 234, -1, 123, 6, 1, 9 },
+  { 0x0, 0x0, 234, -1, 350, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 124, 0, 1, 10 },
+  { 0x0, 0x0, 234, -1, 354, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 125, 0, 1, 17 },
+  { 0x0, 0x0, 234, -1, 355, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 126, 0, 1, 19 },
+  { 0x0, 0x0, 234, -1, 362, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 366, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 128, 0, 1, 20 },
+  { 0x1, 0x1, 234, -1, 128, 6, 1, 20 },
+  { 0x0, 0x0, 234, -1, 370, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 129, 0, 1, 21 },
+  { 0x0, 0x0, 234, -1, 374, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 378, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 130, 0, 1, 22 },
+  { 0x1, 0x1, 234, -1, 130, 6, 1, 22 },
+  { 0x0, 0x0, 234, -1, 382, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 131, 0, 1, 23 },
+  { 0x1, 0x1, 234, -1, 383, 27, 1, 18 },
+  { 0x0, 0x0, 234, -1, 383, 0, 1, 18 },
+  { 0x0, 0x0, 234, -1, 176, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 180, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 388, 0, 1, 24 },
+  { 0x0, 0x0, 234, -1, 209, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 395, 0, 0, -1 },
+  { 0x0, 0x0, 234, -1, 397, 0, 0, -1 },
+  { 0x1, 0x1, 237, 1023, -1, 29, 1, 0 },
+  { 0x0, 0x0, 237, -1, -1, 0, 1, 0 },
+  { 0x1, 0x1, 237, 1024, -1, 27, 1, 0 },
+  { 0x3, 0x3, 256, -1, 441, 1, 1, 18 },
+  { 0x3, 0x3, 256, -1, 441, 0, 1, 18 },
+  { 0x0, 0x0, 256, -1, 153, 0, 0, -1 },
+  { 0x13, 0x13, 256, -1, 441, 1, 1, 18 },
+  { 0x23, 0x23, 256, -1, 441, 0, 1, 18 },
+  { 0x0, 0x0, 256, -1, 157, 0, 0, -1 },
+  { 0xb, 0xb, 256, -1, 441, 1, 1, 18 },
+  { 0x13, 0x13, 256, -1, 441, 0, 1, 18 },
+  { 0x0, 0x0, 256, -1, 163, 0, 0, -1 },
+  { 0x400000b, 0x400000b, 256, -1, 441, 1, 1, 18 },
+  { 0x8000013, 0x8000013, 256, -1, 441, 0, 1, 18 },
+  { 0x0, 0x0, 256, -1, 169, 0, 0, -1 },
+  { 0x4000003, 0x4000003, 256, -1, 441, 1, 1, 18 },
+  { 0x8000003, 0x8000003, 256, -1, 441, 0, 1, 18 },
+  { 0x0, 0x0, 256, -1, 175, 0, 0, -1 },
+  { 0x3, 0x3, 256, -1, 443, 1, 1, 24 },
+  { 0x3, 0x3, 256, -1, 443, 0, 1, 24 },
+  { 0x0, 0x0, 256, -1, 182, 0, 0, -1 },
+  { 0x13, 0x13, 256, -1, 443, 1, 1, 24 },
+  { 0x23, 0x23, 256, -1, 443, 0, 1, 24 },
+  { 0x0, 0x0, 256, -1, 186, 0, 0, -1 },
+  { 0xb, 0xb, 256, -1, 443, 1, 1, 24 },
+  { 0x13, 0x13, 256, -1, 443, 0, 1, 24 },
+  { 0x0, 0x0, 256, -1, 192, 0, 0, -1 },
+  { 0xf, 0xf, 256, -1, 443, 1, 1, 24 },
+  { 0x1b, 0x1b, 256, -1, 443, 0, 1, 24 },
+  { 0x0, 0x0, 256, -1, 198, 0, 0, -1 },
+  { 0x7, 0x7, 256, -1, 443, 1, 1, 24 },
+  { 0xb, 0xb, 256, -1, 443, 0, 1, 24 },
+  { 0x0, 0x0, 256, -1, 204, 0, 0, -1 },
+  { 0x803, 0x803, 256, -1, 445, 10, 1, 69 },
+  { 0x1003, 0x1003, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 212, 0, 0, -1 },
+  { 0x807, 0x807, 256, -1, 445, 10, 1, 69 },
+  { 0x100b, 0x100b, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 216, 0, 0, -1 },
+  { 0x403, 0x403, 256, -1, 445, 10, 1, 69 },
+  { 0x803, 0x803, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 220, 0, 0, -1 },
+  { 0x407, 0x407, 256, -1, 445, 10, 1, 69 },
+  { 0x80b, 0x80b, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 224, 0, 0, -1 },
+  { 0x1803, 0x1803, 256, -1, 445, 10, 1, 69 },
+  { 0x3003, 0x3003, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 228, 0, 0, -1 },
+  { 0x1807, 0x1807, 256, -1, 445, 10, 1, 69 },
+  { 0x300b, 0x300b, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 232, 0, 0, -1 },
+  { 0x1403, 0x1403, 256, -1, 445, 10, 1, 69 },
+  { 0x2803, 0x2803, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 236, 0, 0, -1 },
+  { 0x1407, 0x1407, 256, -1, 445, 10, 1, 69 },
+  { 0x280b, 0x280b, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 240, 0, 0, -1 },
+  { 0x1003, 0x1003, 256, -1, 445, 10, 1, 69 },
+  { 0x2003, 0x2003, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 244, 0, 0, -1 },
+  { 0x1007, 0x1007, 256, -1, 445, 10, 1, 69 },
+  { 0x200b, 0x200b, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 248, 0, 0, -1 },
+  { 0x3, 0x3, 256, -1, 445, 10, 1, 69 },
+  { 0x3, 0x3, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 252, 0, 0, -1 },
+  { 0x7, 0x7, 256, -1, 445, 10, 1, 69 },
+  { 0xb, 0xb, 256, -1, 445, 9, 1, 69 },
+  { 0x0, 0x0, 256, -1, 256, 0, 0, -1 },
+  { 0x0, 0x0, 259, -1, 770, 0, 0, -1 },
+  { 0x0, 0x0, 259, -1, 772, 0, 0, -1 },
+  { 0x1, 0x1, 259, -1, -1, 28, 1, 31 },
+  { 0x0, 0x0, 261, -1, -1, 0, 1, 0 },
+  { 0x0, 0x1, 261, -1, -1, 29, 1, 0 },
+  { 0x1, 0x1, 262, -1, -1, 12, 1, 4 },
+  { 0x1, 0x1, 262, -1, -1, 12, 1, 66 },
+  { 0x0, 0x0, 262, -1, 760, 0, 0, -1 },
+  { 0x0, 0x0, 262, -1, 762, 0, 0, -1 },
+  { 0x0, 0x0, 262, -1, 764, 0, 0, -1 },
+  { 0x0, 0x0, 262, -1, 766, 0, 0, -1 },
+  { 0x1, 0x1, 262, -1, -1, 12, 1, 61 },
+  { 0x1, 0x1, 262, -1, -1, 12, 1, 51 },
+  { 0x0, 0x0, 262, -1, 768, 0, 0, -1 },
+  { 0x0, 0x0, 263, -1, 767, 0, 0, -1 },
+  { 0x9, 0x9, 263, -1, 1017, 33, 1, 51 },
+  { 0x0, 0x0, 263, -1, 784, 0, 0, -1 },
+  { 0x3, 0x3, 263, -1, -1, 27, 1, 51 },
+  { 0x0, 0x0, 267, -1, -1, 0, 1, 0 },
+  { 0x3, 0x3, 268, 1025, -1, 27, 1, 0 },
+  { 0x1, 0x1, 269, -1, -1, 28, 1, 0 },
+  { 0x1, 0x1, 270, -1, -1, 27, 1, 95 },
+  { 0x0, 0x0, 270, -1, 338, 0, 0, -1 },
+  { 0x0, 0x0, 271, 1030, 270, 0, 0, -1 },
+  { 0x0, 0x0, 271, 1031, 272, 0, 0, -1 },
+  { 0x0, 0x0, 272, -1, 271, 0, 0, -1 },
+  { 0x0, 0x0, 272, -1, 273, 0, 0, -1 },
+  { 0x0, 0x0, 273, -1, -1, 0, 1, 42 },
+  { 0x0, 0x0, 278, -1, -1, 0, 1, 35 },
+  { 0x0, 0x0, 282, -1, 141, 0, 1, 31 },
+  { 0x0, 0x0, 283, -1, -1, 0, 1, 73 },
+  { 0x0, 0x0, 283, -1, 96, 0, 1, 3 },
+  { 0x0, 0x0, 283, -1, 98, 0, 0, -1 },
+};
+
+static const struct ia64_main_table
+main_table[] = {
+  { 5, 1, 1, 0x10000000000ull, 0x1eff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 5, 1, 1, 0x10008000000ull, 0x1eff8000000ull, { 23, 24, 25, 3, 0 }, 0x0, 0, },
+  { 5, 7, 1, 0x0ull, 0x0ull, { 23, 65, 25, 0, 0 }, 0x0, 0, },
+  { 6, 1, 1, 0x12000000000ull, 0x1e000000000ull, { 23, 65, 26, 0, 0 }, 0x0, 1, },
+  { 7, 1, 1, 0x10040000000ull, 0x1eff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 7, 1, 1, 0x10c00000000ull, 0x1ee00000000ull, { 23, 62, 25, 0, 0 }, 0x0, 0, },
+  { 8, 1, 1, 0x10800000000ull, 0x1ee00000000ull, { 23, 62, 25, 0, 0 }, 0x0, 1, },
+  { 9, 3, 1, 0x2c00000000ull, 0x1ee00000000ull, { 23, 2, 51, 52, 53 }, 0x221, 2, },
+  { 10, 1, 1, 0x10060000000ull, 0x1eff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 10, 1, 1, 0x10160000000ull, 0x1eff8000000ull, { 23, 54, 25, 0, 0 }, 0x0, 0, },
+  { 11, 1, 1, 0x10068000000ull, 0x1eff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 11, 1, 1, 0x10168000000ull, 0x1eff8000000ull, { 23, 54, 25, 0, 0 }, 0x0, 0, },
+  { 14, 4, 0, 0x100000000ull, 0x1eff80011ffull, { 15, 0, 0, 0, 0 }, 0x40, 3, },
+  { 14, 4, 0, 0x100000000ull, 0x1eff80011c0ull, { 15, 0, 0, 0, 0 }, 0x0, 135, },
+  { 14, 4, 0, 0x100000000ull, 0x1eff80011c0ull, { 15, 0, 0, 0, 0 }, 0x40, 136, },
+  { 14, 4, 0, 0x108000100ull, 0x1eff80011c0ull, { 15, 0, 0, 0, 0 }, 0x200, 736, },
+  { 14, 4, 0, 0x108000100ull, 0x1eff80011c0ull, { 15, 0, 0, 0, 0 }, 0x240, 737, },
+  { 14, 4, 1, 0x2000000000ull, 0x1ee00001000ull, { 14, 15, 0, 0, 0 }, 0x0, 113, },
+  { 14, 4, 1, 0x2000000000ull, 0x1ee00001000ull, { 14, 15, 0, 0, 0 }, 0x40, 114, },
+  { 14, 4, 0, 0x8000000000ull, 0x1ee000011ffull, { 80, 0, 0, 0, 0 }, 0x40, 4, },
+  { 14, 4, 0, 0x8000000000ull, 0x1ee000011c0ull, { 80, 0, 0, 0, 0 }, 0x0, 137, },
+  { 14, 4, 0, 0x8000000000ull, 0x1ee000011c0ull, { 80, 0, 0, 0, 0 }, 0x40, 138, },
+  { 14, 4, 0, 0x8000000080ull, 0x1ee000011c0ull, { 80, 0, 0, 0, 0 }, 0x210, 1028, },
+  { 14, 4, 0, 0x8000000080ull, 0x1ee000011c0ull, { 80, 0, 0, 0, 0 }, 0x250, 1029, },
+  { 14, 4, 0, 0x8000000140ull, 0x1ee000011c0ull, { 80, 0, 0, 0, 0 }, 0x30, 119, },
+  { 14, 4, 0, 0x8000000140ull, 0x1ee000011c0ull, { 80, 0, 0, 0, 0 }, 0x70, 120, },
+  { 14, 4, 0, 0x8000000180ull, 0x1ee000011c0ull, { 80, 0, 0, 0, 0 }, 0x230, 117, },
+  { 14, 4, 0, 0x8000000180ull, 0x1ee000011c0ull, { 80, 0, 0, 0, 0 }, 0x270, 118, },
+  { 14, 4, 1, 0xa000000000ull, 0x1ee00001000ull, { 14, 80, 0, 0, 0 }, 0x0, 115, },
+  { 14, 4, 1, 0xa000000000ull, 0x1ee00001000ull, { 14, 80, 0, 0, 0 }, 0x40, 116, },
+  { 15, 4, 0, 0x0ull, 0x1e1f8000000ull, { 64, 0, 0, 0, 0 }, 0x0, 107, },
+  { 15, 5, 0, 0x0ull, 0x1e3f8000000ull, { 64, 0, 0, 0, 0 }, 0x0, 333, },
+  { 15, 2, 0, 0x0ull, 0x1eff8000000ull, { 64, 0, 0, 0, 0 }, 0x2, 431, },
+  { 15, 3, 0, 0x0ull, 0x1eff8000000ull, { 64, 0, 0, 0, 0 }, 0x0, 481, },
+  { 15, 6, 0, 0x0ull, 0x1eff8000000ull, { 68, 0, 0, 0, 0 }, 0x0, 1032, },
+  { 15, 7, 0, 0x0ull, 0x0ull, { 64, 0, 0, 0, 0 }, 0x0, 5, },
+  { 16, 6, 0, 0x18000000000ull, 0x1ee000011ffull, { 81, 0, 0, 0, 0 }, 0x40, 4, },
+  { 16, 6, 0, 0x18000000000ull, 0x1ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x0, 137, },
+  { 16, 6, 0, 0x18000000000ull, 0x1ee000011c0ull, { 81, 0, 0, 0, 0 }, 0x40, 138, },
+  { 16, 6, 1, 0x1a000000000ull, 0x1ee00001000ull, { 14, 81, 0, 0, 0 }, 0x0, 115, },
+  { 16, 6, 1, 0x1a000000000ull, 0x1ee00001000ull, { 14, 81, 0, 0, 0 }, 0x40, 116, },
+  { 17, 4, 0, 0x4080000000ull, 0x1e9f800003full, { 15, 76, 0, 0, 0 }, 0x20, 307, },
+  { 17, 4, 0, 0x4080000000ull, 0x1e9f800003full, { 15, 76, 0, 0, 0 }, 0x60, 309, },
+  { 17, 4, 0, 0xe000000000ull, 0x1e80000003full, { 80, 76, 0, 0, 0 }, 0x20, 310, },
+  { 17, 4, 0, 0xe000000000ull, 0x1e80000003full, { 80, 76, 0, 0, 0 }, 0x60, 311, },
+  { 18, 4, 0, 0x60000000ull, 0x1e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x2c, 74, },
+  { 22, 2, 0, 0x200000000ull, 0x1ee00000000ull, { 24, 79, 0, 0, 0 }, 0x0, 742, },
+  { 22, 3, 0, 0x800000000ull, 0x1ee00000000ull, { 23, 80, 0, 0, 0 }, 0x0, 76, },
+  { 22, 3, 0, 0xc00000000ull, 0x1ee00000000ull, { 17, 80, 0, 0, 0 }, 0x0, 76, },
+  { 22, 3, 0, 0x2200000000ull, 0x1ee00000000ull, { 24, 79, 0, 0, 0 }, 0x0, 743, },
+  { 22, 3, 0, 0x2600000000ull, 0x1ee00000000ull, { 18, 79, 0, 0, 0 }, 0x0, 744, },
+  { 22, 7, 0, 0x0ull, 0x0ull, { 24, 79, 0, 0, 0 }, 0x0, 745, },
+  { 25, 4, 0, 0x20000000ull, 0x1e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x224, 6, },
+  { 26, 1, 2, 0x18000000000ull, 0x1fe00001000ull, { 21, 22, 24, 25, 0 }, 0x0, 316, },
+  { 26, 1, 2, 0x18000000000ull, 0x1fe00001000ull, { 22, 21, 25, 24, 0 }, 0x0, 454, },
+  { 26, 1, 2, 0x18000000000ull, 0x1fe00001000ull, { 21, 22, 25, 24, 0 }, 0x0, 416, },
+  { 26, 1, 2, 0x18000000000ull, 0x1fe00001000ull, { 22, 21, 24, 25, 0 }, 0x0, 407, },
+  { 26, 1, 2, 0x18200000000ull, 0x1fe00001000ull, { 21, 22, 24, 25, 0 }, 0x40, 317, },
+  { 26, 1, 2, 0x19000000000ull, 0x1fe00001000ull, { 21, 22, 6, 25, 0 }, 0x0, 408, },
+  { 26, 1, 2, 0x19000000000ull, 0x1fe00001000ull, { 21, 22, 6, 25, 0 }, 0x40, 409, },
+  { 26, 1, 2, 0x18800000000ull, 0x1ee00001000ull, { 21, 22, 54, 25, 0 }, 0x0, 316, },
+  { 26, 1, 2, 0x18800000000ull, 0x1ee00001000ull, { 21, 22, 56, 25, 0 }, 0x0, 457, },
+  { 26, 1, 2, 0x18800000000ull, 0x1ee00001000ull, { 22, 21, 56, 25, 0 }, 0x0, 419, },
+  { 26, 1, 2, 0x18800000000ull, 0x1ee00001000ull, { 22, 21, 54, 25, 0 }, 0x0, 407, },
+  { 26, 1, 2, 0x18a00000000ull, 0x1ee00001000ull, { 21, 22, 54, 25, 0 }, 0x40, 317, },
+  { 26, 1, 2, 0x1a800000000ull, 0x1ee00001000ull, { 21, 22, 58, 25, 0 }, 0x0, 464, },
+  { 26, 1, 2, 0x1a800000000ull, 0x1ee00001000ull, { 22, 21, 58, 25, 0 }, 0x0, 425, },
+  { 26, 1, 2, 0x1c200000000ull, 0x1fe00001000ull, { 22, 21, 24, 25, 0 }, 0x40, 318, },
+  { 26, 1, 2, 0x1d000000000ull, 0x1fe00001000ull, { 22, 21, 6, 25, 0 }, 0x40, 410, },
+  { 26, 1, 2, 0x1ca00000000ull, 0x1ee00001000ull, { 22, 21, 54, 25, 0 }, 0x40, 318, },
+  { 27, 1, 2, 0x18400000000ull, 0x1fe00001000ull, { 21, 22, 24, 25, 0 }, 0x0, 316, },
+  { 27, 1, 2, 0x18400000000ull, 0x1fe00001000ull, { 22, 21, 25, 24, 0 }, 0x0, 454, },
+  { 27, 1, 2, 0x18400000000ull, 0x1fe00001000ull, { 21, 22, 25, 24, 0 }, 0x0, 416, },
+  { 27, 1, 2, 0x18400000000ull, 0x1fe00001000ull, { 22, 21, 24, 25, 0 }, 0x0, 407, },
+  { 27, 1, 2, 0x18600000000ull, 0x1fe00001000ull, { 21, 22, 24, 25, 0 }, 0x40, 317, },
+  { 27, 1, 2, 0x19400000000ull, 0x1fe00001000ull, { 21, 22, 6, 25, 0 }, 0x0, 408, },
+  { 27, 1, 2, 0x19400000000ull, 0x1fe00001000ull, { 21, 22, 6, 25, 0 }, 0x40, 409, },
+  { 27, 1, 2, 0x18c00000000ull, 0x1ee00001000ull, { 21, 22, 54, 25, 0 }, 0x0, 319, },
+  { 27, 1, 2, 0x18c00000000ull, 0x1ee00001000ull, { 21, 22, 56, 25, 0 }, 0x0, 457, },
+  { 27, 1, 2, 0x18c00000000ull, 0x1ee00001000ull, { 22, 21, 56, 25, 0 }, 0x0, 419, },
+  { 27, 1, 2, 0x18c00000000ull, 0x1ee00001000ull, { 22, 21, 54, 25, 0 }, 0x0, 411, },
+  { 27, 1, 2, 0x18e00000000ull, 0x1ee00001000ull, { 21, 22, 54, 25, 0 }, 0x40, 317, },
+  { 27, 1, 2, 0x1ac00000000ull, 0x1ee00001000ull, { 21, 22, 55, 25, 0 }, 0x0, 478, },
+  { 27, 1, 2, 0x1ac00000000ull, 0x1ee00001000ull, { 21, 22, 57, 25, 0 }, 0x0, 464, },
+  { 27, 1, 2, 0x1ac00000000ull, 0x1ee00001000ull, { 22, 21, 57, 25, 0 }, 0x0, 425, },
+  { 27, 1, 2, 0x1ac00000000ull, 0x1ee00001000ull, { 22, 21, 55, 25, 0 }, 0x0, 415, },
+  { 27, 1, 2, 0x1c600000000ull, 0x1fe00001000ull, { 22, 21, 24, 25, 0 }, 0x40, 318, },
+  { 27, 1, 2, 0x1d400000000ull, 0x1fe00001000ull, { 22, 21, 6, 25, 0 }, 0x40, 410, },
+  { 27, 1, 2, 0x1ce00000000ull, 0x1ee00001000ull, { 22, 21, 54, 25, 0 }, 0x40, 318, },
+  { 28, 3, 1, 0x8008000000ull, 0x1fff8000000ull, { 23, 32, 24, 1, 0 }, 0x0, 81, },
+  { 29, 3, 1, 0x8048000000ull, 0x1fff8000000ull, { 23, 32, 24, 1, 0 }, 0x0, 81, },
+  { 30, 3, 1, 0x8088000000ull, 0x1fff8000000ull, { 23, 32, 24, 1, 0 }, 0x0, 81, },
+  { 31, 3, 1, 0x80c8000000ull, 0x1fff8000000ull, { 23, 32, 24, 1, 0 }, 0x0, 81, },
+  { 33, 4, 0, 0x10000000ull, 0x1e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x224, 7, },
+  { 35, 2, 1, 0xc0000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 446, },
+  { 36, 2, 1, 0xc8000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 446, },
+  { 39, 2, 1, 0x8000000000ull, 0x1e000000000ull, { 23, 24, 25, 46, 71 }, 0x0, 8, },
+  { 39, 2, 1, 0xa600000000ull, 0x1ee04000000ull, { 23, 24, 44, 72, 0 }, 0x0, 1035, },
+  { 39, 2, 1, 0xa604000000ull, 0x1ee04000000ull, { 23, 54, 44, 72, 0 }, 0x0, 1035, },
+  { 39, 2, 1, 0xae00000000ull, 0x1ee00000000ull, { 23, 47, 25, 45, 72 }, 0x0, 8, },
+  { 43, 4, 0, 0x80000000ull, 0x1e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x20, 9, },
+  { 48, 2, 1, 0xa400000000ull, 0x1ee00002000ull, { 23, 25, 75, 72, 0 }, 0x0, 10, },
+  { 50, 5, 1, 0x80000000ull, 0x1e3f80fe000ull, { 17, 19, 0, 0, 0 }, 0x40, 11, },
+  { 51, 5, 1, 0x10008000000ull, 0x1fff8000000ull, { 17, 19, 18, 0, 0 }, 0x40, 12, },
+  { 52, 5, 1, 0xb8000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 756, },
+  { 52, 5, 1, 0xb8000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x40, 13, },
+  { 53, 5, 1, 0xb0000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 756, },
+  { 53, 5, 1, 0xb0000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x40, 13, },
+  { 54, 5, 1, 0x160000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 11, },
+  { 55, 5, 1, 0x168000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 11, },
+  { 57, 3, 0, 0x2180000000ull, 0x1eff8000000ull, { 25, 0, 0, 0, 0 }, 0x0, 14, },
+  { 58, 5, 0, 0x40000000ull, 0x1eff8000000ull, { 78, 0, 0, 0, 0 }, 0x0, 758, },
+  { 58, 5, 0, 0x40000000ull, 0x1eff8000000ull, { 78, 0, 0, 0, 0 }, 0x40, 15, },
+  { 59, 5, 2, 0xa000000000ull, 0x1e000001000ull, { 21, 22, 18, 59, 0 }, 0x0, 483, },
+  { 59, 5, 2, 0xa000000000ull, 0x1e000001000ull, { 22, 21, 18, 59, 0 }, 0x40, 562, },
+  { 60, 5, 0, 0x28000000ull, 0x1eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 759, },
+  { 60, 5, 0, 0x28000000ull, 0x1eff8000000ull, { 0, 0, 0, 0, 0 }, 0x40, 16, },
+  { 61, 5, 2, 0x8000000000ull, 0x1fe00001000ull, { 21, 22, 18, 19, 0 }, 0x0, 320, },
+  { 61, 5, 2, 0x8000000000ull, 0x1fe00001000ull, { 21, 22, 18, 19, 0 }, 0x40, 321, },
+  { 61, 5, 2, 0x9000000000ull, 0x1fe00001000ull, { 21, 22, 19, 18, 0 }, 0x0, 412, },
+  { 61, 5, 2, 0x9000000000ull, 0x1fe00001000ull, { 21, 22, 19, 18, 0 }, 0x40, 413, },
+  { 61, 5, 2, 0x8000000000ull, 0x1fe00001000ull, { 22, 21, 18, 19, 0 }, 0x0, 545, },
+  { 61, 5, 2, 0x8000000000ull, 0x1fe00001000ull, { 22, 21, 18, 19, 0 }, 0x40, 546, },
+  { 61, 5, 2, 0x9000000000ull, 0x1fe00001000ull, { 22, 21, 19, 18, 0 }, 0x0, 549, },
+  { 61, 5, 2, 0x9000000000ull, 0x1fe00001000ull, { 22, 21, 19, 18, 0 }, 0x40, 550, },
+  { 62, 5, 1, 0xc0000000ull, 0x1eff8000000ull, { 17, 18, 0, 0, 0 }, 0x0, 401, },
+  { 62, 5, 1, 0xc0000000ull, 0x1eff8000000ull, { 17, 18, 0, 0, 0 }, 0x40, 402, },
+  { 62, 5, 1, 0xe0000000ull, 0x1e3f8000000ull, { 17, 18, 0, 0, 0 }, 0x0, 1033, },
+  { 62, 5, 1, 0x10008000000ull, 0x1fff80fe000ull, { 17, 19, 0, 0, 0 }, 0x40, 1034, },
+  { 63, 3, 1, 0x8488000000ull, 0x1fff8000000ull, { 23, 32, 70, 0, 0 }, 0x0, 82, },
+  { 64, 3, 1, 0x84c8000000ull, 0x1fff8000000ull, { 23, 32, 70, 0, 0 }, 0x0, 82, },
+  { 67, 3, 0, 0x60000000ull, 0x1eff8000000ull, { 0, 0, 0, 0, 0 }, 0x21, 17, },
+  { 68, 5, 1, 0x10000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x0, 142, },
+  { 68, 5, 1, 0x10000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x40, 18, },
+  { 69, 5, 1, 0xa8000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 756, },
+  { 69, 5, 1, 0xa8000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x40, 13, },
+  { 70, 5, 1, 0x80000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 564, },
+  { 71, 5, 1, 0xa0000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 756, },
+  { 71, 5, 1, 0xa0000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x40, 13, },
+  { 72, 5, 1, 0x1c8000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 447, },
+  { 73, 5, 1, 0x10000000000ull, 0x1fc000fe000ull, { 17, 19, 20, 0, 0 }, 0x40, 12, },
+  { 74, 5, 1, 0x14000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x0, 144, },
+  { 74, 5, 1, 0x14000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x40, 19, },
+  { 75, 5, 1, 0x88000000ull, 0x1e3f8000000ull, { 17, 19, 0, 0, 0 }, 0xc0, 11, },
+  { 76, 5, 1, 0x88000000ull, 0x1e3f80fe000ull, { 17, 19, 0, 0, 0 }, 0x40, 11, },
+  { 77, 5, 1, 0x18000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x0, 144, },
+  { 77, 5, 1, 0x18000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x40, 19, },
+  { 78, 5, 1, 0x18000000000ull, 0x1fc000fe000ull, { 17, 19, 20, 0, 0 }, 0x40, 12, },
+  { 79, 5, 1, 0x10008000000ull, 0x1fff80fe000ull, { 17, 19, 0, 0, 0 }, 0x40, 12, },
+  { 80, 5, 1, 0x170000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 11, },
+  { 81, 5, 1, 0x2080000000ull, 0x1e3f80fe000ull, { 17, 19, 0, 0, 0 }, 0x40, 11, },
+  { 82, 5, 1, 0x140000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 11, },
+  { 83, 5, 1, 0x20b8000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 756, },
+  { 83, 5, 1, 0x20b8000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x40, 13, },
+  { 84, 5, 1, 0x20b0000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 756, },
+  { 84, 5, 1, 0x20b0000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x40, 13, },
+  { 85, 5, 1, 0x2180000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 322, },
+  { 85, 5, 1, 0x2180000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x40, 323, },
+  { 86, 5, 1, 0x20c0000000ull, 0x1eff8000000ull, { 17, 18, 0, 0, 0 }, 0x0, 401, },
+  { 86, 5, 1, 0x20c0000000ull, 0x1eff8000000ull, { 17, 18, 0, 0, 0 }, 0x40, 402, },
+  { 87, 5, 1, 0x13000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x0, 756, },
+  { 87, 5, 1, 0x13000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x40, 13, },
+  { 88, 5, 1, 0x20a8000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 756, },
+  { 88, 5, 1, 0x20a8000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x40, 13, },
+  { 89, 5, 1, 0x2080000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 564, },
+  { 90, 5, 1, 0x20a0000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 756, },
+  { 90, 5, 1, 0x20a0000000ull, 0x1eff8000000ull, { 17, 18, 19, 0, 0 }, 0x40, 13, },
+  { 91, 5, 1, 0x13000000000ull, 0x1fc000fe000ull, { 17, 19, 20, 0, 0 }, 0x40, 20, },
+  { 92, 5, 1, 0x17000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x0, 756, },
+  { 92, 5, 1, 0x17000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x40, 13, },
+  { 93, 5, 1, 0x2088000000ull, 0x1e3f8000000ull, { 17, 19, 0, 0, 0 }, 0xc0, 11, },
+  { 94, 5, 1, 0x2088000000ull, 0x1e3f80fe000ull, { 17, 19, 0, 0, 0 }, 0x40, 11, },
+  { 95, 5, 1, 0x1b000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x0, 756, },
+  { 95, 5, 1, 0x1b000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x40, 13, },
+  { 96, 5, 1, 0x1b000000000ull, 0x1fc000fe000ull, { 17, 19, 20, 0, 0 }, 0x40, 20, },
+  { 97, 5, 2, 0x2200000000ull, 0x1fe00000000ull, { 17, 22, 18, 19, 0 }, 0x0, 785, },
+  { 97, 5, 2, 0x2200000000ull, 0x1fe00000000ull, { 17, 22, 18, 19, 0 }, 0x40, 21, },
+  { 98, 5, 2, 0x3200000000ull, 0x1fe00000000ull, { 17, 22, 19, 0, 0 }, 0x0, 785, },
+  { 98, 5, 2, 0x3200000000ull, 0x1fe00000000ull, { 17, 22, 19, 0, 0 }, 0x40, 21, },
+  { 99, 5, 2, 0x200000000ull, 0x1fe00000000ull, { 17, 22, 18, 19, 0 }, 0x0, 785, },
+  { 99, 5, 2, 0x200000000ull, 0x1fe00000000ull, { 17, 22, 18, 19, 0 }, 0x40, 21, },
+  { 100, 5, 2, 0x1200000000ull, 0x1fe00000000ull, { 17, 22, 19, 0, 0 }, 0x0, 785, },
+  { 100, 5, 2, 0x1200000000ull, 0x1fe00000000ull, { 17, 22, 19, 0, 0 }, 0x40, 21, },
+  { 101, 5, 1, 0x1c000000000ull, 0x1f000000000ull, { 17, 19, 20, 18, 0 }, 0x0, 11, },
+  { 102, 5, 0, 0x20000000ull, 0x1eff8000000ull, { 49, 50, 0, 0, 0 }, 0x0, 786, },
+  { 102, 5, 0, 0x20000000ull, 0x1eff8000000ull, { 49, 50, 0, 0, 0 }, 0x40, 22, },
+  { 103, 5, 1, 0x14008000000ull, 0x1fff8000000ull, { 17, 19, 18, 0, 0 }, 0x40, 12, },
+  { 104, 5, 1, 0x1a0000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 23, },
+  { 105, 5, 1, 0x1e0000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 448, },
+  { 106, 3, 0, 0x100000000ull, 0x1eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 16, },
+  { 108, 5, 1, 0x178000000ull, 0x1e3f8000000ull, { 17, 18, 19, 0, 0 }, 0x0, 11, },
+  { 113, 3, 1, 0x8708000000ull, 0x1ffc8000000ull, { 23, 18, 0, 0, 0 }, 0x0, 146, },
+  { 122, 3, 0, 0x80000000ull, 0x1eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 24, },
+  { 122, 3, 0, 0x90000000ull, 0x1eff8000000ull, { 23, 0, 0, 0, 0 }, 0x0, 314, },
+  { 122, 3, 0, 0x98000000ull, 0x1eff8000000ull, { 17, 0, 0, 0, 0 }, 0x0, 314, },
+  { 123, 3, 0, 0x2170000000ull, 0x1eff8000000ull, { 24, 0, 0, 0, 0 }, 0xc, 147, },
+  { 124, 3, 1, 0x2070000000ull, 0x1eff8000000ull, { 29, 24, 0, 0, 0 }, 0x8, 148, },
+  { 124, 3, 1, 0x2078000000ull, 0x1eff8000000ull, { 30, 24, 0, 0, 0 }, 0x8, 434, },
+  { 126, 3, 1, 0x8000000000ull, 0x1fff8000000ull, { 23, 32, 0, 0, 0 }, 0x0, 25, },
+  { 126, 3, 1, 0x9000000000ull, 0x1fff8000000ull, { 23, 32, 24, 0, 0 }, 0x0, 25, },
+  { 126, 3, 1, 0xa000000000ull, 0x1eff0000000ull, { 23, 32, 61, 0, 0 }, 0x0, 25, },
+  { 127, 3, 1, 0x8040000000ull, 0x1fff8000000ull, { 23, 32, 0, 0, 0 }, 0x0, 25, },
+  { 127, 3, 1, 0x9040000000ull, 0x1fff8000000ull, { 23, 32, 24, 0, 0 }, 0x0, 25, },
+  { 127, 3, 1, 0xa040000000ull, 0x1eff0000000ull, { 23, 32, 61, 0, 0 }, 0x0, 25, },
+  { 128, 3, 1, 0x8080000000ull, 0x1fff8000000ull, { 23, 32, 0, 0, 0 }, 0x0, 25, },
+  { 128, 3, 1, 0x9080000000ull, 0x1fff8000000ull, { 23, 32, 24, 0, 0 }, 0x0, 25, },
+  { 128, 3, 1, 0xa080000000ull, 0x1eff0000000ull, { 23, 32, 61, 0, 0 }, 0x0, 25, },
+  { 129, 3, 1, 0x80c0000000ull, 0x1fff8000000ull, { 23, 32, 0, 0, 0 }, 0x0, 26, },
+  { 129, 3, 1, 0x90c0000000ull, 0x1fff8000000ull, { 23, 32, 24, 0, 0 }, 0x0, 26, },
+  { 129, 3, 1, 0xa0c0000000ull, 0x1eff0000000ull, { 23, 32, 61, 0, 0 }, 0x0, 26, },
+  { 130, 3, 1, 0xc6c0000000ull, 0x1fff8000000ull, { 17, 32, 0, 0, 0 }, 0x0, 400, },
+  { 130, 3, 1, 0xd6c0000000ull, 0x1fff8000000ull, { 17, 32, 24, 0, 0 }, 0x0, 400, },
+  { 130, 3, 1, 0xe6c0000000ull, 0x1eff0000000ull, { 17, 32, 61, 0, 0 }, 0x0, 400, },
+  { 131, 3, 1, 0xc040000000ull, 0x1fff8000000ull, { 17, 32, 0, 0, 0 }, 0x0, 27, },
+  { 131, 3, 1, 0xd040000000ull, 0x1fff8000000ull, { 17, 32, 24, 0, 0 }, 0x0, 27, },
+  { 131, 3, 1, 0xe040000000ull, 0x1eff0000000ull, { 17, 32, 61, 0, 0 }, 0x0, 27, },
+  { 132, 3, 1, 0xc0c0000000ull, 0x1fff8000000ull, { 17, 32, 0, 0, 0 }, 0x0, 27, },
+  { 132, 3, 1, 0xd0c0000000ull, 0x1fff8000000ull, { 17, 32, 24, 0, 0 }, 0x0, 27, },
+  { 132, 3, 1, 0xe0c0000000ull, 0x1eff0000000ull, { 17, 32, 61, 0, 0 }, 0x0, 27, },
+  { 133, 3, 1, 0xc000000000ull, 0x1fff8000000ull, { 17, 32, 0, 0, 0 }, 0x0, 27, },
+  { 133, 3, 1, 0xd000000000ull, 0x1fff8000000ull, { 17, 32, 24, 0, 0 }, 0x0, 27, },
+  { 133, 3, 1, 0xe000000000ull, 0x1eff0000000ull, { 17, 32, 61, 0, 0 }, 0x0, 27, },
+  { 134, 3, 2, 0xc048000000ull, 0x1fff8000000ull, { 17, 18, 32, 0, 0 }, 0x0, 27, },
+  { 134, 3, 2, 0xd048000000ull, 0x1fff8000000ull, { 17, 18, 32, 5, 0 }, 0x0, 27, },
+  { 135, 3, 2, 0xc0c8000000ull, 0x1fff8000000ull, { 17, 18, 32, 0, 0 }, 0x0, 27, },
+  { 135, 3, 2, 0xd0c8000000ull, 0x1fff8000000ull, { 17, 18, 32, 5, 0 }, 0x0, 27, },
+  { 136, 3, 2, 0xc088000000ull, 0x1fff8000000ull, { 17, 18, 32, 0, 0 }, 0x0, 27, },
+  { 136, 3, 2, 0xd088000000ull, 0x1fff8000000ull, { 17, 18, 32, 4, 0 }, 0x0, 27, },
+  { 137, 3, 1, 0xc080000000ull, 0x1fff8000000ull, { 17, 32, 0, 0, 0 }, 0x0, 27, },
+  { 137, 3, 1, 0xd080000000ull, 0x1fff8000000ull, { 17, 32, 24, 0, 0 }, 0x0, 27, },
+  { 137, 3, 1, 0xe080000000ull, 0x1eff0000000ull, { 17, 32, 61, 0, 0 }, 0x0, 27, },
+  { 140, 3, 0, 0xcb00000000ull, 0x1fff8000000ull, { 32, 0, 0, 0, 0 }, 0x0, 28, },
+  { 140, 3, 0, 0xdb00000000ull, 0x1fff8000000ull, { 32, 24, 0, 0, 0 }, 0x0, 29, },
+  { 140, 3, 0, 0xeb00000000ull, 0x1eff0000000ull, { 32, 61, 0, 0, 0 }, 0x0, 29, },
+  { 141, 3, 0, 0x50000000ull, 0x1eff8000000ull, { 0, 0, 0, 0, 0 }, 0x21, 30, },
+  { 149, 3, 0, 0x110000000ull, 0x1eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 31, },
+  { 150, 2, 1, 0xe880000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 449, },
+  { 151, 2, 1, 0xea80000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 449, },
+  { 152, 2, 1, 0xf880000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 449, },
+  { 153, 1, 1, 0x10800000000ull, 0x1fff80fe000ull, { 23, 25, 0, 0, 0 }, 0x0, 1, },
+  { 153, 1, 1, 0x10800000000ull, 0x1ee07f00000ull, { 23, 62, 0, 0, 0 }, 0x40, 1, },
+  { 153, 1, 1, 0x12000000000ull, 0x1e000300000ull, { 23, 65, 0, 0, 0 }, 0x40, 32, },
+  { 153, 5, 1, 0x80000000ull, 0x1e3f8000000ull, { 17, 19, 0, 0, 0 }, 0xc0, 11, },
+  { 153, 2, 1, 0xe00100000ull, 0x1ee00f01e00ull, { 14, 24, 0, 0, 0 }, 0x40, 33, },
+  { 153, 2, 1, 0xe00000000ull, 0x1ee00f01e00ull, { 14, 24, 77, 0, 0 }, 0x0, 313, },
+  { 153, 2, 1, 0x188000000ull, 0x1eff8000000ull, { 23, 15, 0, 0, 0 }, 0x0, 34, },
+  { 153, 2, 1, 0x600000000ull, 0x1ee00000000ull, { 8, 24, 63, 0, 0 }, 0x0, 35, },
+  { 153, 2, 1, 0x400000000ull, 0x1ee00000000ull, { 9, 67, 0, 0, 0 }, 0x0, 36, },
+  { 153, 2, 1, 0x180000000ull, 0x1eff8000000ull, { 23, 7, 0, 0, 0 }, 0x0, 8, },
+  { 153, 2, 1, 0x198000000ull, 0x1eff8000000ull, { 23, 8, 0, 0, 0 }, 0x0, 37, },
+  { 153, 2, 1, 0x150000000ull, 0x1eff8000000ull, { 13, 24, 0, 0, 0 }, 0x0, 435, },
+  { 153, 2, 1, 0x50000000ull, 0x1eff8000000ull, { 13, 54, 0, 0, 0 }, 0x0, 435, },
+  { 153, 2, 1, 0x190000000ull, 0x1eff8000000ull, { 23, 13, 0, 0, 0 }, 0x0, 436, },
+  { 153, 3, 1, 0x140000000ull, 0x1eff8000000ull, { 13, 54, 0, 0, 0 }, 0x0, 484, },
+  { 153, 3, 1, 0x2150000000ull, 0x1eff8000000ull, { 13, 24, 0, 0, 0 }, 0x0, 484, },
+  { 153, 3, 1, 0x2110000000ull, 0x1eff8000000ull, { 23, 13, 0, 0, 0 }, 0x0, 485, },
+  { 153, 3, 1, 0x2160000000ull, 0x1eff8000000ull, { 16, 24, 0, 0, 0 }, 0x8, 38, },
+  { 153, 3, 1, 0x2120000000ull, 0x1eff8000000ull, { 23, 16, 0, 0, 0 }, 0x8, 39, },
+  { 153, 3, 1, 0x2168000000ull, 0x1eff8000000ull, { 11, 24, 0, 0, 0 }, 0x8, 40, },
+  { 153, 3, 1, 0x2148000000ull, 0x1eff8000000ull, { 12, 24, 0, 0, 0 }, 0x0, 41, },
+  { 153, 3, 1, 0x2128000000ull, 0x1eff8000000ull, { 23, 10, 0, 0, 0 }, 0x8, 42, },
+  { 153, 3, 1, 0x2108000000ull, 0x1eff8000000ull, { 23, 12, 0, 0, 0 }, 0x0, 43, },
+  { 153, 3, 1, 0x2000000000ull, 0x1eff8000000ull, { 37, 24, 0, 0, 0 }, 0x8, 44, },
+  { 153, 3, 1, 0x2008000000ull, 0x1eff8000000ull, { 28, 24, 0, 0, 0 }, 0x8, 45, },
+  { 153, 3, 1, 0x2010000000ull, 0x1eff8000000ull, { 31, 24, 0, 0, 0 }, 0x8, 46, },
+  { 153, 3, 1, 0x2018000000ull, 0x1eff8000000ull, { 34, 24, 0, 0, 0 }, 0x8, 47, },
+  { 153, 3, 1, 0x2020000000ull, 0x1eff8000000ull, { 35, 24, 0, 0, 0 }, 0x8, 48, },
+  { 153, 3, 1, 0x2028000000ull, 0x1eff8000000ull, { 36, 24, 0, 0, 0 }, 0x8, 49, },
+  { 153, 3, 1, 0x2030000000ull, 0x1eff8000000ull, { 33, 24, 0, 0, 0 }, 0x8, 50, },
+  { 153, 3, 1, 0x2080000000ull, 0x1eff8000000ull, { 23, 37, 0, 0, 0 }, 0x8, 51, },
+  { 153, 3, 1, 0x2088000000ull, 0x1eff8000000ull, { 23, 28, 0, 0, 0 }, 0x8, 52, },
+  { 153, 3, 1, 0x2090000000ull, 0x1eff8000000ull, { 23, 31, 0, 0, 0 }, 0x8, 53, },
+  { 153, 3, 1, 0x2098000000ull, 0x1eff8000000ull, { 23, 34, 0, 0, 0 }, 0x8, 54, },
+  { 153, 3, 1, 0x20a0000000ull, 0x1eff8000000ull, { 23, 35, 0, 0, 0 }, 0x8, 55, },
+  { 153, 3, 1, 0x20a8000000ull, 0x1eff8000000ull, { 23, 36, 0, 0, 0 }, 0x0, 56, },
+  { 153, 3, 1, 0x20b0000000ull, 0x1eff8000000ull, { 23, 33, 0, 0, 0 }, 0x8, 57, },
+  { 153, 3, 1, 0x20b8000000ull, 0x1eff8000000ull, { 23, 27, 0, 0, 0 }, 0x0, 58, },
+  { 153, 7, 1, 0x0ull, 0x0ull, { 23, 13, 0, 0, 0 }, 0x0, 59, },
+  { 153, 7, 1, 0x0ull, 0x0ull, { 13, 54, 0, 0, 0 }, 0x0, 59, },
+  { 153, 7, 1, 0x0ull, 0x0ull, { 13, 24, 0, 0, 0 }, 0x0, 59, },
+  { 154, 6, 1, 0xc000000000ull, 0x1e000100000ull, { 23, 69, 0, 0, 0 }, 0x0, 8, },
+  { 155, 2, 1, 0xeca0000000ull, 0x1fff0000000ull, { 23, 24, 73, 0, 0 }, 0x0, 0, },
+  { 156, 2, 1, 0xeea0000000ull, 0x1fff0000000ull, { 23, 24, 74, 0, 0 }, 0x0, 0, },
+  { 166, 4, 0, 0x4000000000ull, 0x1e1f8000000ull, { 64, 0, 0, 0, 0 }, 0x0, 107, },
+  { 166, 5, 0, 0x8000000ull, 0x1e3f8000000ull, { 64, 0, 0, 0, 0 }, 0x0, 333, },
+  { 166, 2, 0, 0x8000000ull, 0x1eff8000000ull, { 64, 0, 0, 0, 0 }, 0x2, 431, },
+  { 166, 3, 0, 0x8000000ull, 0x1eff8000000ull, { 64, 0, 0, 0, 0 }, 0x0, 481, },
+  { 166, 6, 0, 0x8000000ull, 0x1eff8000000ull, { 68, 0, 0, 0, 0 }, 0x0, 1032, },
+  { 166, 7, 0, 0x0ull, 0x0ull, { 64, 0, 0, 0, 0 }, 0x0, 5, },
+  { 174, 1, 1, 0x10070000000ull, 0x1eff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 174, 1, 1, 0x10170000000ull, 0x1eff8000000ull, { 23, 54, 25, 0, 0 }, 0x0, 0, },
+  { 177, 2, 1, 0xea00000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 936, },
+  { 178, 2, 1, 0xf820000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 937, },
+  { 179, 1, 1, 0x10400000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 60, },
+  { 180, 1, 1, 0x10600000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 60, },
+  { 181, 1, 1, 0x11400000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 182, 1, 1, 0x10450000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 61, },
+  { 183, 1, 1, 0x10650000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 61, },
+  { 184, 1, 1, 0x10470000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 185, 1, 1, 0x10670000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 186, 1, 1, 0x10520000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 324, },
+  { 187, 1, 1, 0x10720000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 324, },
+  { 188, 1, 1, 0x11520000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 324, },
+  { 189, 2, 1, 0xe850000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 1008, },
+  { 190, 2, 1, 0xea70000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 191, 2, 1, 0xe810000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 1008, },
+  { 192, 2, 1, 0xea30000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 193, 2, 1, 0xead0000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 449, },
+  { 194, 2, 1, 0xe230000000ull, 0x1ff30000000ull, { 23, 24, 25, 41, 0 }, 0x0, 62, },
+  { 195, 2, 1, 0xe690000000ull, 0x1fff0000000ull, { 23, 25, 0, 0, 0 }, 0x0, 0, },
+  { 197, 3, 1, 0x21c0000000ull, 0x1eff8000000ull, { 23, 25, 24, 0, 0 }, 0x0, 729, },
+  { 197, 3, 1, 0x20c0000000ull, 0x1eff8000000ull, { 23, 25, 48, 0, 0 }, 0x0, 729, },
+  { 197, 3, 0, 0x2188000000ull, 0x1eff8000000ull, { 25, 48, 0, 0, 0 }, 0x0, 730, },
+  { 198, 2, 1, 0xe8b0000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 199, 2, 1, 0xe240000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 199, 2, 1, 0xee50000000ull, 0x1fff0000000ull, { 23, 24, 38, 0, 0 }, 0x0, 0, },
+  { 200, 2, 1, 0xf040000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 200, 2, 1, 0xfc50000000ull, 0x1fff0000000ull, { 23, 24, 38, 0, 0 }, 0x0, 0, },
+  { 201, 1, 1, 0x10680000000ull, 0x1ffe0000000ull, { 23, 24, 40, 25, 0 }, 0x0, 0, },
+  { 202, 2, 1, 0xe220000000ull, 0x1fff0000000ull, { 23, 25, 24, 0, 0 }, 0x0, 62, },
+  { 202, 2, 1, 0xe630000000ull, 0x1fff0000000ull, { 23, 25, 42, 0, 0 }, 0x0, 62, },
+  { 203, 2, 1, 0xf020000000ull, 0x1fff0000000ull, { 23, 25, 24, 0, 0 }, 0x0, 62, },
+  { 203, 2, 1, 0xf430000000ull, 0x1fff0000000ull, { 23, 25, 42, 0, 0 }, 0x0, 62, },
+  { 204, 1, 1, 0x106c0000000ull, 0x1ffe0000000ull, { 23, 24, 40, 25, 0 }, 0x0, 0, },
+  { 205, 1, 1, 0x10420000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 60, },
+  { 206, 1, 1, 0x10620000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 60, },
+  { 207, 1, 1, 0x11420000000ull, 0x1fff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 208, 3, 0, 0x2048000000ull, 0x1eff8000000ull, { 25, 24, 0, 0, 0 }, 0x8, 450, },
+  { 208, 3, 0, 0x2050000000ull, 0x1eff8000000ull, { 25, 24, 0, 0, 0 }, 0xc, 405, },
+  { 208, 3, 0, 0x21a0000000ull, 0x1eff8000000ull, { 25, 0, 0, 0, 0 }, 0x8, 315, },
+  { 209, 3, 0, 0x2060000000ull, 0x1eff8000000ull, { 25, 24, 0, 0, 0 }, 0x8, 149, },
+  { 214, 4, 0, 0x40000000ull, 0x1e1f8000000ull, { 0, 0, 0, 0, 0 }, 0x22c, 63, },
+  { 215, 3, 0, 0x38000000ull, 0x1ee78000000ull, { 66, 0, 0, 0, 0 }, 0x8, 64, },
+  { 216, 3, 0, 0x28000000ull, 0x1ee78000000ull, { 66, 0, 0, 0, 0 }, 0x0, 65, },
+  { 225, 3, 1, 0xc708000000ull, 0x1ffc8000000ull, { 17, 24, 0, 0, 0 }, 0x0, 150, },
+  { 226, 2, 1, 0xa600000000ull, 0x1ee04000000ull, { 23, 24, 44, 0, 0 }, 0x140, 0, },
+  { 226, 2, 1, 0xf240000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 227, 1, 1, 0x10080000000ull, 0x1efe0000000ull, { 23, 24, 39, 25, 0 }, 0x0, 0, },
+  { 228, 1, 1, 0x100c0000000ull, 0x1efe0000000ull, { 23, 24, 39, 25, 0 }, 0x0, 0, },
+  { 229, 2, 1, 0xa400000000ull, 0x1ee00002000ull, { 23, 25, 75, 0, 0 }, 0x140, 10, },
+  { 229, 2, 1, 0xf220000000ull, 0x1fff0000000ull, { 23, 25, 24, 0, 0 }, 0x0, 62, },
+  { 230, 2, 1, 0xac00000000ull, 0x1ee00000000ull, { 23, 24, 25, 43, 0 }, 0x0, 0, },
+  { 235, 3, 0, 0x180000000ull, 0x1eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 151, },
+  { 236, 3, 0, 0x30000000ull, 0x1ee78000000ull, { 66, 0, 0, 0, 0 }, 0x8, 64, },
+  { 238, 3, 1, 0x8c00000000ull, 0x1fff8000000ull, { 32, 24, 0, 0, 0 }, 0x0, 66, },
+  { 238, 3, 1, 0xac00000000ull, 0x1eff0000000ull, { 32, 24, 60, 0, 0 }, 0x0, 66, },
+  { 239, 3, 1, 0x8c40000000ull, 0x1fff8000000ull, { 32, 24, 0, 0, 0 }, 0x0, 66, },
+  { 239, 3, 1, 0xac40000000ull, 0x1eff0000000ull, { 32, 24, 60, 0, 0 }, 0x0, 66, },
+  { 240, 3, 1, 0x8c80000000ull, 0x1fff8000000ull, { 32, 24, 0, 0, 0 }, 0x0, 66, },
+  { 240, 3, 1, 0xac80000000ull, 0x1eff0000000ull, { 32, 24, 60, 0, 0 }, 0x0, 66, },
+  { 241, 3, 1, 0x8cc0000000ull, 0x1fff8000000ull, { 32, 24, 0, 0, 0 }, 0x0, 67, },
+  { 241, 3, 1, 0xacc0000000ull, 0x1eff0000000ull, { 32, 24, 60, 0, 0 }, 0x0, 67, },
+  { 242, 3, 1, 0xcec0000000ull, 0x1fff8000000ull, { 32, 18, 0, 0, 0 }, 0x0, 883, },
+  { 242, 3, 1, 0xeec0000000ull, 0x1eff0000000ull, { 32, 18, 60, 0, 0 }, 0x0, 883, },
+  { 243, 3, 1, 0xcc40000000ull, 0x1fff8000000ull, { 32, 18, 0, 0, 0 }, 0x0, 68, },
+  { 243, 3, 1, 0xec40000000ull, 0x1eff0000000ull, { 32, 18, 60, 0, 0 }, 0x0, 68, },
+  { 244, 3, 1, 0xccc0000000ull, 0x1fff8000000ull, { 32, 18, 0, 0, 0 }, 0x0, 68, },
+  { 244, 3, 1, 0xecc0000000ull, 0x1eff0000000ull, { 32, 18, 60, 0, 0 }, 0x0, 68, },
+  { 245, 3, 1, 0xcc00000000ull, 0x1fff8000000ull, { 32, 18, 0, 0, 0 }, 0x0, 68, },
+  { 245, 3, 1, 0xec00000000ull, 0x1eff0000000ull, { 32, 18, 60, 0, 0 }, 0x0, 68, },
+  { 246, 3, 1, 0xcc80000000ull, 0x1fff8000000ull, { 32, 18, 0, 0, 0 }, 0x0, 68, },
+  { 246, 3, 1, 0xec80000000ull, 0x1eff0000000ull, { 32, 18, 60, 0, 0 }, 0x0, 68, },
+  { 247, 1, 1, 0x10028000000ull, 0x1eff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 247, 1, 1, 0x10020000000ull, 0x1eff8000000ull, { 23, 24, 25, 3, 0 }, 0x0, 0, },
+  { 247, 1, 1, 0x10128000000ull, 0x1eff8000000ull, { 23, 54, 25, 0, 0 }, 0x0, 0, },
+  { 248, 3, 0, 0x20000000ull, 0x1ee78000000ull, { 66, 0, 0, 0, 0 }, 0x0, 69, },
+  { 249, 2, 1, 0xa0000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 0, },
+  { 250, 2, 1, 0xa8000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 0, },
+  { 251, 2, 1, 0xb0000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 0, },
+  { 252, 3, 0, 0x198000000ull, 0x1eff8000000ull, { 0, 0, 0, 0, 0 }, 0x0, 431, },
+  { 253, 3, 1, 0x20f8000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x8, 70, },
+  { 254, 2, 2, 0xa000000000ull, 0x1fe00003000ull, { 21, 22, 25, 75, 0 }, 0x0, 699, },
+  { 254, 2, 2, 0xa000000000ull, 0x1fe00003000ull, { 22, 21, 25, 75, 0 }, 0x40, 700, },
+  { 255, 3, 1, 0x20d0000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 71, },
+  { 257, 2, 2, 0xa000002000ull, 0x1fe00003000ull, { 21, 22, 25, 0, 0 }, 0x0, 699, },
+  { 257, 2, 2, 0xa000002000ull, 0x1fe00003000ull, { 22, 21, 25, 0, 0 }, 0x40, 700, },
+  { 258, 3, 1, 0x20f0000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x8, 70, },
+  { 260, 3, 1, 0x20d8000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 72, },
+  { 264, 2, 1, 0xe840000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 426, },
+  { 265, 2, 1, 0xea40000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 426, },
+  { 266, 2, 1, 0xf840000000ull, 0x1fff0000000ull, { 23, 24, 25, 0, 0 }, 0x0, 426, },
+  { 274, 3, 1, 0x8208000000ull, 0x1fff8000000ull, { 23, 32, 24, 0, 0 }, 0x0, 73, },
+  { 275, 3, 1, 0x8248000000ull, 0x1fff8000000ull, { 23, 32, 24, 0, 0 }, 0x0, 73, },
+  { 276, 3, 1, 0x8288000000ull, 0x1fff8000000ull, { 23, 32, 24, 0, 0 }, 0x0, 73, },
+  { 277, 3, 1, 0x82c8000000ull, 0x1fff8000000ull, { 23, 32, 24, 0, 0 }, 0x0, 73, },
+  { 279, 5, 1, 0x1d000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x0, 427, },
+  { 279, 5, 1, 0x1d000000000ull, 0x1fc00000000ull, { 17, 19, 20, 18, 0 }, 0x40, 479, },
+  { 280, 5, 1, 0x1d000000000ull, 0x1fc000fe000ull, { 17, 19, 20, 0, 0 }, 0x40, 428, },
+  { 281, 1, 1, 0x10078000000ull, 0x1eff8000000ull, { 23, 24, 25, 0, 0 }, 0x0, 0, },
+  { 281, 1, 1, 0x10178000000ull, 0x1eff8000000ull, { 23, 54, 25, 0, 0 }, 0x0, 0, },
+  { 284, 2, 1, 0x80000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 0, },
+  { 285, 2, 1, 0x88000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 0, },
+  { 286, 2, 1, 0x90000000ull, 0x1eff8000000ull, { 23, 25, 0, 0, 0 }, 0x0, 0, },
+};
+
+static const char dis_table[] = {
+0xa0, 0xf0, 0xd0, 0xa0, 0x4d, 0xc8, 0xa0, 0x3e, 0x88, 0xa0, 0x2e, 0x78,
+0x98, 0xb0, 0x01, 0x40, 0x90, 0x50, 0x90, 0x28, 0x24, 0x25, 0xc8, 0x24,
+0x25, 0xc0, 0x90, 0x28, 0x24, 0x25, 0xb8, 0x24, 0x25, 0xb0, 0x90, 0x50,
+0x90, 0x28, 0x24, 0x25, 0xa0, 0x24, 0x25, 0x98, 0x90, 0x28, 0x24, 0x25,
+0x90, 0x24, 0x25, 0x88, 0xa8, 0x0b, 0x28, 0x29, 0x08, 0x97, 0x00, 0x95,
+0xa8, 0x9a, 0x98, 0x05, 0x18, 0x90, 0xf8, 0x90, 0x80, 0x90, 0x40, 0x80,
+0xa4, 0x06, 0x50, 0x39, 0x47, 0x80, 0xa4, 0x32, 0xb8, 0x34, 0xae, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x36, 0x60, 0x80, 0x31, 0xbc, 0x81, 0x35, 0xa0,
+0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x00, 0x00, 0x34, 0x8f, 0xa4,
+0x24, 0x60, 0x34, 0x8d, 0x90, 0x38, 0xa4, 0x2c, 0x70, 0x35, 0x83, 0xa4,
+0x33, 0x80, 0x36, 0x6a, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x34, 0x70, 0x36,
+0x92, 0xa4, 0x2e, 0x78, 0x35, 0xd7, 0x80, 0xa4, 0x34, 0x68, 0x36, 0x91,
+0x92, 0x18, 0x91, 0xc0, 0x80, 0x91, 0x80, 0x90, 0xf8, 0xdb, 0x84, 0x61,
+0x25, 0x80, 0xc0, 0xc0, 0x80, 0xa4, 0x52, 0x20, 0x8c, 0x52, 0xf0, 0x84,
+0x3a, 0x8e, 0xc0, 0xc0, 0x80, 0xa4, 0x52, 0x10, 0x8c, 0x52, 0xd0, 0x84,
+0x3a, 0x8a, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3a, 0x2c, 0x50,
+0xc0, 0xc0, 0x81, 0x3a, 0x2a, 0xa4, 0x0d, 0xd0, 0x31, 0xbb, 0x80, 0x90,
+0x28, 0x80, 0x30, 0xe5, 0x80, 0x30, 0xe7, 0x81, 0x90, 0x38, 0xa4, 0x07,
+0x70, 0x30, 0xea, 0xa4, 0x07, 0x40, 0x30, 0xe6, 0xc0, 0x40, 0x10, 0x10,
+0x90, 0x38, 0xa4, 0x04, 0x30, 0x30, 0x3f, 0xa4, 0x04, 0x38, 0x30, 0x7b,
+0x18, 0x24, 0x3a, 0x70, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0,
+0x80, 0xa4, 0x52, 0x50, 0x3a, 0x6a, 0xc0, 0xc0, 0x80, 0xa4, 0x52, 0x40,
+0x3a, 0x66, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3a, 0x32, 0x50,
+0xc0, 0xc0, 0x81, 0x3a, 0x30, 0x92, 0xb8, 0x99, 0x84, 0x07, 0x60, 0x90,
+0x78, 0x90, 0x50, 0x10, 0x10, 0x80, 0xa4, 0x32, 0xb0, 0x34, 0xad, 0x82,
+0x36, 0x5f, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x2c, 0x68, 0x35,
+0x82, 0xa4, 0x33, 0x78, 0x36, 0x69, 0x80, 0x90, 0x38, 0xa4, 0x2e, 0x98,
+0x35, 0xdb, 0xa4, 0x2e, 0x70, 0x35, 0xd6, 0x83, 0x90, 0xa8, 0xd3, 0x82,
+0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x52, 0x80, 0x3a, 0x76, 0xc0, 0xc0, 0x80,
+0xa4, 0x52, 0x70, 0x3a, 0x72, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81,
+0x3a, 0x38, 0x50, 0xc0, 0xc0, 0x81, 0x3a, 0x36, 0x18, 0x24, 0x07, 0x68,
+0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x52, 0xb0,
+0x3a, 0x82, 0xc0, 0xc0, 0x80, 0xa4, 0x52, 0xa0, 0x3a, 0x7e, 0xd3, 0x82,
+0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3a, 0x3e, 0x50, 0xc0, 0xc0, 0x81, 0x3a,
+0x3c, 0x94, 0x50, 0x92, 0xf8, 0x99, 0x84, 0x3a, 0x60, 0x90, 0x78, 0x90,
+0x50, 0x10, 0x10, 0x80, 0xa4, 0x32, 0xa8, 0x34, 0xac, 0x82, 0x36, 0x5e,
+0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x2c, 0x60, 0x35, 0x81, 0xa4,
+0x33, 0x70, 0x36, 0x68, 0x80, 0x90, 0x38, 0xa4, 0x2e, 0x90, 0x35, 0xda,
+0xa4, 0x2e, 0x68, 0x35, 0xd5, 0x83, 0x90, 0xe8, 0xd3, 0x83, 0xc0, 0xc0,
+0xc0, 0x80, 0xa4, 0x52, 0x30, 0x8c, 0x53, 0x10, 0x84, 0x3a, 0x8c, 0xc0,
+0xc0, 0x80, 0xa4, 0x52, 0x18, 0x8c, 0x52, 0xe0, 0x84, 0x3a, 0x8b, 0xd3,
+0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3a, 0x2e, 0x50, 0xc0, 0xc0, 0x81,
+0x3a, 0x2b, 0x18, 0x24, 0x3a, 0x68, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0,
+0xc0, 0xc0, 0x80, 0xa4, 0x52, 0x60, 0x3a, 0x6e, 0xc0, 0xc0, 0x80, 0xa4,
+0x52, 0x48, 0x3a, 0x68, 0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3a,
+0x34, 0x50, 0xc0, 0xc0, 0x81, 0x3a, 0x31, 0x92, 0xb8, 0x99, 0x84, 0x3a,
+0x50, 0x90, 0x78, 0x90, 0x50, 0x10, 0x10, 0x80, 0xa4, 0x32, 0xa0, 0x34,
+0xab, 0x82, 0x36, 0x5d, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x2c,
+0x58, 0x35, 0x80, 0xa4, 0x33, 0x68, 0x36, 0x67, 0x80, 0x90, 0x38, 0xa4,
+0x2e, 0x88, 0x35, 0xd9, 0xa4, 0x2e, 0x60, 0x35, 0xd4, 0x83, 0x90, 0xa8,
+0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4, 0x52, 0x90, 0x3a, 0x7a, 0xc0,
+0xc0, 0x80, 0xa4, 0x52, 0x78, 0x3a, 0x74, 0xd3, 0x82, 0x40, 0x50, 0xc0,
+0xc0, 0x81, 0x3a, 0x3a, 0x50, 0xc0, 0xc0, 0x81, 0x3a, 0x37, 0x18, 0x20,
+0x01, 0x48, 0x83, 0x90, 0xa8, 0xd3, 0x82, 0xc0, 0xc0, 0xc0, 0x80, 0xa4,
+0x52, 0xc0, 0x3a, 0x86, 0xc0, 0xc0, 0x80, 0xa4, 0x52, 0xa8, 0x3a, 0x80,
+0xd3, 0x82, 0x40, 0x50, 0xc0, 0xc0, 0x81, 0x3a, 0x40, 0x50, 0xc0, 0xc0,
+0x81, 0x3a, 0x3d, 0xea, 0x00, 0x57, 0x21, 0xd2, 0xc0, 0x95, 0x60, 0x93,
+0x90, 0x91, 0xc8, 0xd1, 0xc7, 0x40, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x08,
+0x60, 0x31, 0x0e, 0xa4, 0x08, 0x00, 0x31, 0x04, 0x90, 0x38, 0xa4, 0x08,
+0x50, 0x31, 0x02, 0xa4, 0x08, 0x40, 0x31, 0x06, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x07, 0xe0, 0x30, 0xfe, 0xa4, 0x07, 0x80, 0x30, 0xf4, 0x90, 0x38,
+0xa4, 0x07, 0xd0, 0x30, 0xf2, 0xa4, 0x07, 0xc0, 0x30, 0xf6, 0xd1, 0xc7,
+0x40, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0c, 0x60, 0x31, 0xaf, 0xa4, 0x0c,
+0x00, 0x31, 0x84, 0x90, 0x38, 0xa4, 0x0c, 0x50, 0x31, 0x82, 0xa4, 0x0c,
+0x40, 0x31, 0x86, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0b, 0xe0, 0x31, 0x7e,
+0xa4, 0x0b, 0x80, 0x31, 0x74, 0x90, 0x38, 0xa4, 0x0b, 0xd0, 0x31, 0x72,
+0xa4, 0x0b, 0xc0, 0x31, 0x76, 0x80, 0xd1, 0xc7, 0x40, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x0d, 0x58, 0x31, 0xad, 0xa4, 0x0c, 0xf8, 0x31, 0xa3, 0x90,
+0x38, 0xa4, 0x0d, 0x48, 0x31, 0xa1, 0xa4, 0x0d, 0x38, 0x31, 0xa5, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x0c, 0xd8, 0x31, 0x9d, 0xa4, 0x0c, 0x78, 0x31,
+0x93, 0x90, 0x38, 0xa4, 0x0c, 0xc8, 0x31, 0x91, 0xa4, 0x0c, 0xb8, 0x31,
+0x95, 0x93, 0x90, 0x91, 0xc8, 0xd1, 0xc7, 0x40, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x09, 0x60, 0x31, 0x2e, 0xa4, 0x09, 0x00, 0x31, 0x24, 0x90, 0x38,
+0xa4, 0x09, 0x50, 0x31, 0x22, 0xa4, 0x09, 0x40, 0x31, 0x26, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x08, 0xe0, 0x31, 0x1e, 0xa4, 0x08, 0x80, 0x31, 0x14,
+0x90, 0x38, 0xa4, 0x08, 0xd0, 0x31, 0x12, 0xa4, 0x08, 0xc0, 0x31, 0x16,
+0xd1, 0xc7, 0x40, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0x60, 0x31, 0x4e,
+0xa4, 0x0a, 0x00, 0x31, 0x44, 0x90, 0x38, 0xa4, 0x0a, 0x50, 0x31, 0x42,
+0xa4, 0x0a, 0x40, 0x31, 0x46, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x09, 0xe0,
+0x31, 0x3e, 0xa4, 0x09, 0x80, 0x31, 0x34, 0x90, 0x38, 0xa4, 0x09, 0xd0,
+0x31, 0x32, 0xa4, 0x09, 0xc0, 0x31, 0x36, 0x80, 0xd1, 0xc7, 0x40, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x0b, 0x60, 0x31, 0x6e, 0xa4, 0x0b, 0x00, 0x31,
+0x64, 0x90, 0x38, 0xa4, 0x0b, 0x50, 0x31, 0x62, 0xa4, 0x0b, 0x40, 0x31,
+0x66, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0a, 0xe0, 0x31, 0x5e, 0xa4, 0x0a,
+0x80, 0x31, 0x54, 0x90, 0x38, 0xa4, 0x0a, 0xd0, 0x31, 0x52, 0xa4, 0x0a,
+0xc0, 0x31, 0x56, 0x95, 0x60, 0x93, 0x90, 0x91, 0xc8, 0xd1, 0xc7, 0x40,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x08, 0x68, 0x31, 0x0f, 0xa4, 0x08, 0x08,
+0x31, 0x05, 0x90, 0x38, 0xa4, 0x08, 0x58, 0x31, 0x03, 0xa4, 0x08, 0x48,
+0x31, 0x07, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x07, 0xe8, 0x30, 0xff, 0xa4,
+0x07, 0x88, 0x30, 0xf5, 0x90, 0x38, 0xa4, 0x07, 0xd8, 0x30, 0xf3, 0xa4,
+0x07, 0xc8, 0x30, 0xf7, 0xd1, 0xc7, 0x40, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x0c, 0x68, 0x31, 0x8e, 0xa4, 0x0c, 0x08, 0x31, 0x85, 0x90, 0x38, 0xa4,
+0x0c, 0x58, 0x31, 0x83, 0xa4, 0x0c, 0x48, 0x31, 0x87, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x0b, 0xe8, 0x31, 0x7f, 0xa4, 0x0b, 0x88, 0x31, 0x75, 0x90,
+0x38, 0xa4, 0x0b, 0xd8, 0x31, 0x73, 0xa4, 0x0b, 0xc8, 0x31, 0x77, 0x80,
+0xd1, 0xc7, 0x40, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0d, 0x60, 0x31, 0xae,
+0xa4, 0x0d, 0x00, 0x31, 0xa4, 0x90, 0x38, 0xa4, 0x0d, 0x50, 0x31, 0xa2,
+0xa4, 0x0d, 0x40, 0x31, 0xa6, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0c, 0xe0,
+0x31, 0x9e, 0xa4, 0x0c, 0x80, 0x31, 0x94, 0x90, 0x38, 0xa4, 0x0c, 0xd0,
+0x31, 0x92, 0xa4, 0x0c, 0xc0, 0x31, 0x96, 0x93, 0x90, 0x91, 0xc8, 0xd1,
+0xc7, 0x40, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x09, 0x68, 0x31, 0x2f, 0xa4,
+0x09, 0x08, 0x31, 0x25, 0x90, 0x38, 0xa4, 0x09, 0x58, 0x31, 0x23, 0xa4,
+0x09, 0x48, 0x31, 0x27, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x08, 0xe8, 0x31,
+0x1f, 0xa4, 0x08, 0x88, 0x31, 0x15, 0x90, 0x38, 0xa4, 0x08, 0xd8, 0x31,
+0x13, 0xa4, 0x08, 0xc8, 0x31, 0x17, 0xd1, 0xc7, 0x40, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x0a, 0x68, 0x31, 0x4f, 0xa4, 0x0a, 0x08, 0x31, 0x45, 0x90,
+0x38, 0xa4, 0x0a, 0x58, 0x31, 0x43, 0xa4, 0x0a, 0x48, 0x31, 0x47, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x09, 0xe8, 0x31, 0x3f, 0xa4, 0x09, 0x88, 0x31,
+0x35, 0x90, 0x38, 0xa4, 0x09, 0xd8, 0x31, 0x33, 0xa4, 0x09, 0xc8, 0x31,
+0x37, 0x80, 0xd1, 0xc7, 0x40, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x0b, 0x68,
+0x31, 0x6f, 0xa4, 0x0b, 0x08, 0x31, 0x65, 0x90, 0x38, 0xa4, 0x0b, 0x58,
+0x31, 0x63, 0xa4, 0x0b, 0x48, 0x31, 0x67, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x0a, 0xe8, 0x31, 0x5f, 0xa4, 0x0a, 0x88, 0x31, 0x55, 0x90, 0x38, 0xa4,
+0x0a, 0xd8, 0x31, 0x53, 0xa4, 0x0a, 0xc8, 0x31, 0x57, 0xc8, 0x40, 0x18,
+0x00, 0x91, 0x38, 0x90, 0x40, 0x82, 0xa4, 0x06, 0x68, 0x39, 0x4a, 0x90,
+0xc0, 0x80, 0x90, 0x90, 0x90, 0x48, 0xc9, 0xe1, 0x61, 0xc0, 0x85, 0x36,
+0x82, 0xc9, 0xe1, 0x62, 0x40, 0x85, 0x35, 0x5e, 0x80, 0x35, 0x86, 0x10,
+0x10, 0x81, 0x35, 0xcb, 0x90, 0xa8, 0x10, 0x10, 0x90, 0x28, 0x81, 0x35,
+0x3d, 0x90, 0x38, 0xa4, 0x33, 0x28, 0x36, 0x66, 0xa4, 0x24, 0xa8, 0x35,
+0x3f, 0x90, 0x70, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x24, 0xd0, 0x34, 0x9b,
+0x80, 0x34, 0x99, 0x90, 0x60, 0x90, 0x28, 0x24, 0x2b, 0xf0, 0xa4, 0x2b,
+0xf8, 0x35, 0x7d, 0x80, 0xa4, 0x24, 0xc0, 0x34, 0x97, 0x80, 0x90, 0xf8,
+0x90, 0x90, 0x90, 0x50, 0x90, 0x28, 0x80, 0x39, 0x4b, 0x80, 0x36, 0x95,
+0x80, 0xa4, 0x3a, 0x30, 0x37, 0x47, 0x90, 0x28, 0x81, 0x30, 0x88, 0x80,
+0xa4, 0x3a, 0x78, 0x37, 0x50, 0x83, 0x36, 0x87, 0x98, 0xb0, 0x01, 0x40,
+0x90, 0x50, 0x90, 0x28, 0x24, 0x26, 0x18, 0x24, 0x26, 0x10, 0x90, 0x28,
+0x24, 0x26, 0x08, 0x24, 0x26, 0x00, 0x90, 0x50, 0x90, 0x28, 0x24, 0x25,
+0xf0, 0x24, 0x25, 0xe8, 0x90, 0x28, 0x24, 0x25, 0xe0, 0x24, 0x25, 0xd8,
+0xa8, 0x08, 0xe0, 0x0d, 0xe0, 0x96, 0x38, 0x95, 0xe8, 0x9b, 0x48, 0x05,
+0xa8, 0x91, 0xa0, 0x90, 0xd0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x06, 0xd8,
+0x30, 0xdc, 0xa4, 0x06, 0xc8, 0x30, 0xda, 0x90, 0x38, 0xa4, 0x06, 0xb8,
+0x30, 0xd8, 0x80, 0x30, 0xd6, 0x90, 0x60, 0x90, 0x28, 0x24, 0x04, 0x68,
+0xa4, 0x04, 0x58, 0x30, 0x8c, 0x90, 0x38, 0xa4, 0x04, 0x48, 0x30, 0x8a,
+0xa4, 0x24, 0x40, 0x34, 0x89, 0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x06, 0xa0, 0x30, 0xd5, 0xa4, 0x06, 0x90, 0x30, 0xd3, 0x90, 0x38, 0xa4,
+0x27, 0x38, 0x34, 0xdd, 0xa4, 0x29, 0xd0, 0x35, 0x34, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x27, 0xc0, 0x35, 0x04, 0xa4, 0x27, 0x90, 0x34, 0xfe, 0x10,
+0x10, 0xa4, 0x01, 0xf0, 0x30, 0x1d, 0x91, 0x50, 0x90, 0x90, 0x90, 0x50,
+0x90, 0x28, 0x24, 0x06, 0xe8, 0x80, 0x30, 0xe3, 0x80, 0xa4, 0x06, 0xf0,
+0x30, 0xe1, 0x90, 0x50, 0x90, 0x28, 0x24, 0x06, 0xf8, 0x80, 0x30, 0xe4,
+0x90, 0x38, 0xa4, 0x07, 0x00, 0x30, 0xe2, 0xa4, 0x24, 0x50, 0x34, 0x8b,
+0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x29, 0x28, 0x36, 0x62, 0xa4,
+0x28, 0x50, 0x35, 0x2b, 0x90, 0x38, 0xa4, 0x28, 0xa8, 0x35, 0x1f, 0xa4,
+0x28, 0x80, 0x35, 0x1a, 0x81, 0xa4, 0x05, 0x30, 0x30, 0xa7, 0xe4, 0xe2,
+0x84, 0x80, 0x3a, 0x14, 0xed, 0x22, 0x86, 0x21, 0xd2, 0x40, 0x3a, 0x1a,
+0x92, 0x40, 0x99, 0x18, 0x02, 0x00, 0x10, 0x10, 0x90, 0x80, 0x10, 0x10,
+0x90, 0x38, 0xa4, 0x27, 0x30, 0x34, 0xdc, 0xa4, 0x29, 0xc8, 0x35, 0x33,
+0x80, 0x90, 0x38, 0xa4, 0x27, 0xb8, 0x35, 0x03, 0xa4, 0x27, 0x88, 0x34,
+0xfd, 0x10, 0x10, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x29, 0x20, 0x35,
+0x30, 0xa4, 0x28, 0x48, 0x35, 0x2a, 0x90, 0x38, 0xa4, 0x28, 0xa0, 0x35,
+0x1e, 0xa4, 0x28, 0x78, 0x35, 0x19, 0xe4, 0xe2, 0x87, 0x80, 0x3a, 0x20,
+0xed, 0x22, 0x89, 0x21, 0xd2, 0x00, 0x3a, 0x26, 0x92, 0x80, 0x92, 0x40,
+0x99, 0x18, 0x02, 0x00, 0x10, 0x10, 0x90, 0x80, 0x10, 0x10, 0x90, 0x38,
+0xa4, 0x27, 0x28, 0x34, 0xdb, 0xa4, 0x29, 0xc0, 0x35, 0x32, 0x80, 0x90,
+0x38, 0xa4, 0x27, 0xb0, 0x35, 0x02, 0xa4, 0x27, 0x80, 0x34, 0xfc, 0x10,
+0x10, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x29, 0x18, 0x35, 0x2f, 0xa4,
+0x28, 0x40, 0x35, 0x29, 0x90, 0x38, 0xa4, 0x28, 0x98, 0x35, 0x1d, 0xa4,
+0x28, 0x70, 0x35, 0x18, 0xe4, 0xe2, 0x84, 0xc0, 0x3a, 0x16, 0xe5, 0x22,
+0x86, 0x40, 0x3a, 0x1c, 0x92, 0x50, 0x99, 0x18, 0x02, 0x00, 0x10, 0x10,
+0x90, 0x80, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x27, 0x20, 0x34, 0xda, 0xa4,
+0x29, 0xb8, 0x35, 0x31, 0x80, 0x90, 0x38, 0xa4, 0x27, 0xa8, 0x35, 0x01,
+0xa4, 0x27, 0x78, 0x34, 0xfb, 0x10, 0x10, 0x80, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x29, 0x10, 0x35, 0x2e, 0xa4, 0x28, 0x38, 0x35, 0x28, 0x90, 0x38,
+0xa4, 0x28, 0x90, 0x35, 0x1c, 0xa4, 0x28, 0x68, 0x35, 0x17, 0xec, 0xe2,
+0x87, 0xe2, 0xa5, 0x00, 0x3a, 0x22, 0xe5, 0x22, 0x89, 0x40, 0x3a, 0x28,
+0xc0, 0x40, 0x80, 0x10, 0x10, 0x81, 0x90, 0x90, 0x90, 0x48, 0xc9, 0xe1,
+0x38, 0x40, 0x85, 0x35, 0x3e, 0xc9, 0xe1, 0x38, 0x80, 0x85, 0x34, 0xcf,
+0x80, 0x34, 0xe0, 0x80, 0xd8, 0x7c, 0x80, 0x77, 0xc0, 0xc0, 0x80, 0x10,
+0x10, 0x82, 0x93, 0xa8, 0xd5, 0x4e, 0xc0, 0x90, 0xe8, 0x80, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x42, 0x38, 0x38, 0x19, 0xa4, 0x41, 0x78, 0x38, 0x37,
+0x90, 0x38, 0xa4, 0x42, 0x18, 0x38, 0x33, 0xa4, 0x41, 0xf8, 0x38, 0x3b,
+0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x46, 0xe8, 0x38, 0xaf, 0xa4, 0x46,
+0x28, 0x38, 0xcd, 0x90, 0x38, 0xa4, 0x46, 0xc8, 0x38, 0xc9, 0xa4, 0x46,
+0xa8, 0x38, 0xd1, 0x90, 0xe8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x41,
+0x40, 0x38, 0x2a, 0xa4, 0x40, 0xe0, 0x38, 0x20, 0x90, 0x38, 0xa4, 0x41,
+0x30, 0x38, 0x1e, 0xa4, 0x41, 0x20, 0x38, 0x22, 0x80, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x45, 0xf0, 0x38, 0xc0, 0xa4, 0x45, 0x90, 0x38, 0xb6, 0x90,
+0x38, 0xa4, 0x45, 0xe0, 0x38, 0xb4, 0xa4, 0x45, 0xd0, 0x38, 0xb8, 0xd5,
+0x4e, 0xc0, 0x90, 0xe8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x43, 0xc8,
+0x38, 0x4b, 0xa4, 0x43, 0x08, 0x38, 0x69, 0x90, 0x38, 0xa4, 0x43, 0xa8,
+0x38, 0x65, 0xa4, 0x43, 0x88, 0x38, 0x6d, 0x80, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x45, 0x58, 0x38, 0x7d, 0xa4, 0x44, 0x98, 0x38, 0x9b, 0x90, 0x38,
+0xa4, 0x45, 0x38, 0x38, 0x97, 0xa4, 0x45, 0x18, 0x38, 0x9f, 0x90, 0xe8,
+0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x42, 0xd0, 0x38, 0x5c, 0xa4, 0x42,
+0x70, 0x38, 0x52, 0x90, 0x38, 0xa4, 0x42, 0xc0, 0x38, 0x50, 0xa4, 0x42,
+0xb0, 0x38, 0x54, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x44, 0x60, 0x38,
+0x8e, 0xa4, 0x44, 0x00, 0x38, 0x84, 0x90, 0x38, 0xa4, 0x44, 0x50, 0x38,
+0x82, 0xa4, 0x44, 0x40, 0x38, 0x86, 0xc0, 0x80, 0x10, 0x10, 0x82, 0x93,
+0xa8, 0xd5, 0x4e, 0xc0, 0x90, 0xe8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x42, 0x48, 0x38, 0x2c, 0xa4, 0x41, 0x88, 0x38, 0x39, 0x90, 0x38, 0xa4,
+0x42, 0x28, 0x38, 0x35, 0xa4, 0x42, 0x08, 0x38, 0x3d, 0x80, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x46, 0xf8, 0x38, 0xc2, 0xa4, 0x46, 0x38, 0x38, 0xcf,
+0x90, 0x38, 0xa4, 0x46, 0xd8, 0x38, 0xcb, 0xa4, 0x46, 0xb8, 0x38, 0xd3,
+0x90, 0xe8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x41, 0x48, 0x38, 0x2b,
+0xa4, 0x40, 0xe8, 0x38, 0x21, 0x90, 0x38, 0xa4, 0x41, 0x38, 0x38, 0x1f,
+0xa4, 0x41, 0x28, 0x38, 0x23, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x45,
+0xf8, 0x38, 0xc1, 0xa4, 0x45, 0x98, 0x38, 0xb7, 0x90, 0x38, 0xa4, 0x45,
+0xe8, 0x38, 0xb5, 0xa4, 0x45, 0xd8, 0x38, 0xb9, 0xd5, 0x4e, 0xc0, 0x90,
+0xe8, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x43, 0xd8, 0x38, 0x5e, 0xa4,
+0x43, 0x18, 0x38, 0x6b, 0x90, 0x38, 0xa4, 0x43, 0xb8, 0x38, 0x67, 0xa4,
+0x43, 0x98, 0x38, 0x6f, 0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x45, 0x68,
+0x38, 0x90, 0xa4, 0x44, 0xa8, 0x38, 0x9d, 0x90, 0x38, 0xa4, 0x45, 0x48,
+0x38, 0x99, 0xa4, 0x45, 0x28, 0x38, 0xa1, 0x90, 0xe8, 0x80, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x42, 0xd8, 0x38, 0x5d, 0xa4, 0x42, 0x78, 0x38, 0x53,
+0x90, 0x38, 0xa4, 0x42, 0xc8, 0x38, 0x51, 0xa4, 0x42, 0xb8, 0x38, 0x55,
+0x80, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x44, 0x68, 0x38, 0x8f, 0xa4, 0x44,
+0x08, 0x38, 0x85, 0x90, 0x38, 0xa4, 0x44, 0x58, 0x38, 0x83, 0xa4, 0x44,
+0x48, 0x38, 0x87, 0xc0, 0x80, 0x84, 0x30, 0xce, 0xa0, 0x56, 0x50, 0xa0,
+0x40, 0x70, 0xa8, 0x1d, 0x40, 0x33, 0x18, 0xa0, 0x12, 0x38, 0xa0, 0x0b,
+0x48, 0x96, 0x00, 0x9a, 0xf0, 0x05, 0xc0, 0x91, 0x70, 0x90, 0xb8, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x35, 0x58, 0x34, 0x87, 0xa4, 0x35, 0x68, 0x34,
+0x74, 0x10, 0x10, 0xa4, 0x35, 0x60, 0x34, 0x73, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x35, 0x28, 0x34, 0x36, 0xa4, 0x35, 0x38, 0x34, 0x23, 0x10, 0x10,
+0xa4, 0x35, 0x30, 0x34, 0x22, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x34, 0xf8, 0x33, 0xe5, 0xa4, 0x35, 0x08, 0x33, 0xd2, 0x10, 0x10, 0xa4,
+0x35, 0x00, 0x33, 0xd1, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x34, 0xc8, 0x33,
+0x94, 0xa4, 0x34, 0xd8, 0x33, 0x7e, 0x10, 0x10, 0xa4, 0x34, 0xd0, 0x33,
+0x7d, 0x91, 0x70, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x35, 0x40,
+0x34, 0x70, 0xa4, 0x35, 0x50, 0x34, 0x72, 0x10, 0x10, 0xa4, 0x35, 0x48,
+0x34, 0x71, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x35, 0x10, 0x34, 0x1f, 0xa4,
+0x35, 0x20, 0x34, 0x21, 0x10, 0x10, 0xa4, 0x35, 0x18, 0x34, 0x20, 0x90,
+0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x34, 0xe0, 0x33, 0xce, 0xa4, 0x34,
+0xf0, 0x33, 0xd0, 0x10, 0x10, 0xa4, 0x34, 0xe8, 0x33, 0xcf, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x34, 0xb0, 0x33, 0x7a, 0xa4, 0x34, 0xc0, 0x33, 0x7c,
+0x10, 0x10, 0xa4, 0x34, 0xb8, 0x33, 0x7b, 0xe4, 0xe1, 0x91, 0x80, 0x36,
+0x50, 0x9a, 0xf0, 0x05, 0x00, 0x91, 0x70, 0x90, 0xb8, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x00, 0xb0, 0x34, 0x84, 0xa4, 0x00, 0xa8, 0x34, 0x86, 0x10,
+0x10, 0xa4, 0x00, 0xa0, 0x34, 0x85, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x00,
+0x98, 0x34, 0x33, 0xa4, 0x00, 0x90, 0x34, 0x35, 0x10, 0x10, 0xa4, 0x00,
+0x88, 0x34, 0x34, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x00, 0x80,
+0x33, 0xe2, 0xa4, 0x00, 0x78, 0x33, 0xe4, 0x10, 0x10, 0xa4, 0x00, 0x70,
+0x33, 0xe3, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x00, 0x68, 0x33, 0x91, 0xa4,
+0x00, 0x60, 0x33, 0x93, 0x10, 0x10, 0xa4, 0x00, 0x58, 0x33, 0x92, 0x91,
+0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x6d, 0x80, 0x34,
+0x6f, 0x10, 0x10, 0x80, 0x34, 0x6e, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34,
+0x1c, 0x80, 0x34, 0x1e, 0x10, 0x10, 0x80, 0x34, 0x1d, 0x90, 0x88, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x33, 0xcb, 0x80, 0x33, 0xcd, 0x10, 0x10, 0x80,
+0x33, 0xcc, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x77, 0x80, 0x33, 0x79,
+0x10, 0x10, 0x80, 0x33, 0x78, 0xe4, 0xe1, 0x89, 0x00, 0x36, 0x38, 0x95,
+0x40, 0x9a, 0x90, 0x05, 0x00, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x34, 0x7e, 0x80, 0x34, 0x80, 0x10, 0x10, 0x80, 0x34, 0x7f,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x2d, 0x80, 0x34, 0x2f, 0x10, 0x10,
+0x80, 0x34, 0x2e, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x2d, 0x50,
+0x33, 0xdc, 0xa4, 0x2d, 0x60, 0x33, 0xde, 0x10, 0x10, 0xa4, 0x2d, 0x58,
+0x33, 0xdd, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x2d, 0x20, 0x33, 0x8b, 0xa4,
+0x2d, 0x30, 0x33, 0x8d, 0x10, 0x10, 0xa4, 0x2d, 0x28, 0x33, 0x8c, 0x91,
+0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x81, 0x80, 0x34,
+0x83, 0x10, 0x10, 0x80, 0x34, 0x82, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34,
+0x30, 0x80, 0x34, 0x32, 0x10, 0x10, 0x80, 0x34, 0x31, 0x90, 0xb8, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x2d, 0x38, 0x33, 0xdf, 0xa4, 0x2d, 0x48, 0x33,
+0xe1, 0x10, 0x10, 0xa4, 0x2d, 0x40, 0x33, 0xe0, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x2d, 0x08, 0x33, 0x8e, 0xa4, 0x2d, 0x18, 0x33, 0x90, 0x10, 0x10,
+0xa4, 0x2d, 0x10, 0x33, 0x8f, 0xe4, 0xe1, 0x91, 0x00, 0x36, 0x4e, 0x98,
+0xb8, 0x01, 0x68, 0x10, 0x10, 0x10, 0x10, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x33, 0x7f, 0x80, 0x33, 0x81, 0x10, 0x10, 0x80, 0x33, 0x80, 0x90, 0x60,
+0x90, 0x30, 0x60, 0xa1, 0x24, 0x40, 0x60, 0xa1, 0x24, 0xc0, 0x90, 0x30,
+0x60, 0xa1, 0x24, 0x80, 0x60, 0xa1, 0x25, 0x00, 0xe4, 0xe1, 0x88, 0x00,
+0x36, 0x34, 0x96, 0xe8, 0x94, 0x80, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x10,
+0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x78, 0x80, 0x34, 0x7a,
+0x10, 0x10, 0x80, 0x34, 0x79, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x27,
+0x80, 0x34, 0x29, 0x10, 0x10, 0x80, 0x34, 0x28, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x33, 0xd6, 0x80, 0x33, 0xd8, 0x10, 0x10, 0x80, 0x33,
+0xd7, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x85, 0x80, 0x33, 0x87, 0x10,
+0x10, 0x80, 0x33, 0x86, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x34, 0x75, 0x80, 0x34, 0x77, 0x10, 0x10, 0x80, 0x34, 0x76, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x34, 0x24, 0x80, 0x34, 0x26, 0x10, 0x10, 0x80,
+0x34, 0x25, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0xd3, 0x80,
+0x33, 0xd5, 0x10, 0x10, 0x80, 0x33, 0xd4, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x33, 0x82, 0x80, 0x33, 0x84, 0x10, 0x10, 0x80, 0x33, 0x83, 0xe4, 0xe1,
+0x90, 0x80, 0x36, 0x4c, 0x88, 0x02, 0x28, 0x91, 0x10, 0x90, 0x88, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x34, 0x7b, 0x80, 0x34, 0x7d, 0x10, 0x10, 0x80,
+0x34, 0x7c, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x2a, 0x80, 0x34, 0x2c,
+0x10, 0x10, 0x80, 0x34, 0x2b, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x33, 0xd9, 0x80, 0x33, 0xdb, 0x10, 0x10, 0x80, 0x33, 0xda, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x33, 0x88, 0x80, 0x33, 0x8a, 0x10, 0x10, 0x80, 0x33,
+0x89, 0xe4, 0xe1, 0x87, 0x00, 0x36, 0x30, 0x93, 0x40, 0x99, 0x90, 0x03,
+0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x28, 0x81, 0x30, 0x7a, 0x10, 0x10,
+0x80, 0x30, 0x79, 0x90, 0x28, 0x81, 0x30, 0x72, 0x10, 0x10, 0x80, 0x30,
+0x71, 0x90, 0x60, 0x90, 0x28, 0x81, 0x30, 0x6a, 0x10, 0x10, 0x80, 0x30,
+0x69, 0x90, 0x28, 0x81, 0x30, 0x62, 0x10, 0x10, 0x80, 0x30, 0x61, 0x90,
+0xc0, 0x90, 0x60, 0x90, 0x28, 0x81, 0x30, 0x77, 0x10, 0x10, 0x80, 0x30,
+0x78, 0x90, 0x28, 0x81, 0x30, 0x6f, 0x10, 0x10, 0x80, 0x30, 0x70, 0x90,
+0x60, 0x90, 0x28, 0x81, 0x30, 0x67, 0x10, 0x10, 0x80, 0x30, 0x68, 0x90,
+0x28, 0x81, 0x30, 0x5f, 0x10, 0x10, 0x80, 0x30, 0x60, 0xe4, 0xe1, 0x90,
+0x00, 0x36, 0x4a, 0x88, 0x00, 0x88, 0x10, 0x10, 0x10, 0x10, 0x90, 0x28,
+0x81, 0x30, 0x5d, 0x10, 0x10, 0x80, 0x30, 0x5e, 0xe4, 0xe1, 0x86, 0x00,
+0x36, 0x2c, 0xa0, 0x0e, 0x80, 0xa0, 0x09, 0x08, 0x94, 0x80, 0x9a, 0x30,
+0x04, 0x40, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34,
+0x6c, 0x80, 0x34, 0x59, 0x10, 0x10, 0x80, 0x34, 0x58, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x34, 0x1b, 0x80, 0x34, 0x08, 0x10, 0x10, 0x80, 0x34, 0x07,
+0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0xca, 0x80, 0x33, 0xb7,
+0x10, 0x10, 0x80, 0x33, 0xb6, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x76,
+0x80, 0x33, 0x60, 0x10, 0x10, 0x80, 0x33, 0x5f, 0x91, 0x10, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x55, 0x80, 0x34, 0x57, 0x10, 0x10,
+0x80, 0x34, 0x56, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x04, 0x80, 0x34,
+0x06, 0x10, 0x10, 0x80, 0x34, 0x05, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x33, 0xb3, 0x80, 0x33, 0xb5, 0x10, 0x10, 0x80, 0x33, 0xb4, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x33, 0x5c, 0x80, 0x33, 0x5e, 0x10, 0x10, 0x80,
+0x33, 0x5d, 0xe4, 0xe1, 0x7f, 0x00, 0x36, 0x10, 0x9a, 0x30, 0x04, 0x40,
+0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x69, 0x80,
+0x34, 0x6b, 0x10, 0x10, 0x80, 0x34, 0x6a, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x34, 0x18, 0x80, 0x34, 0x1a, 0x10, 0x10, 0x80, 0x34, 0x19, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0xc7, 0x80, 0x33, 0xc9, 0x10, 0x10,
+0x80, 0x33, 0xc8, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x73, 0x80, 0x33,
+0x75, 0x10, 0x10, 0x80, 0x33, 0x74, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x34, 0x52, 0x80, 0x34, 0x54, 0x10, 0x10, 0x80, 0x34,
+0x53, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x01, 0x80, 0x34, 0x03, 0x10,
+0x10, 0x80, 0x34, 0x02, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0xb0, 0x80, 0x33, 0xb2, 0x10, 0x10, 0x80, 0x33, 0xb1, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x33, 0x59, 0x80, 0x33, 0x5b, 0x10, 0x10, 0x80, 0x33, 0x5a,
+0xe4, 0xe1, 0x78, 0x80, 0x35, 0xec, 0x94, 0x80, 0x9a, 0x30, 0x04, 0x40,
+0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x63, 0x80,
+0x34, 0x65, 0x10, 0x10, 0x80, 0x34, 0x64, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x34, 0x12, 0x80, 0x34, 0x14, 0x10, 0x10, 0x80, 0x34, 0x13, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0xc1, 0x80, 0x33, 0xc3, 0x10, 0x10,
+0x80, 0x33, 0xc2, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x6d, 0x80, 0x33,
+0x6f, 0x10, 0x10, 0x80, 0x33, 0x6e, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x34, 0x66, 0x80, 0x34, 0x68, 0x10, 0x10, 0x80, 0x34,
+0x67, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x15, 0x80, 0x34, 0x17, 0x10,
+0x10, 0x80, 0x34, 0x16, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0xc4, 0x80, 0x33, 0xc6, 0x10, 0x10, 0x80, 0x33, 0xc5, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x33, 0x70, 0x80, 0x33, 0x72, 0x10, 0x10, 0x80, 0x33, 0x71,
+0xe4, 0xe1, 0x7e, 0x00, 0x36, 0x0c, 0x88, 0x00, 0xb0, 0x10, 0x10, 0x10,
+0x10, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x61, 0x80, 0x33, 0x63, 0x10,
+0x10, 0x80, 0x33, 0x62, 0xe4, 0xe1, 0x78, 0x00, 0x35, 0xea, 0x96, 0xe8,
+0x94, 0x80, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x34, 0x5d, 0x80, 0x34, 0x5f, 0x10, 0x10, 0x80, 0x34,
+0x5e, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x0c, 0x80, 0x34, 0x0e, 0x10,
+0x10, 0x80, 0x34, 0x0d, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0xbb, 0x80, 0x33, 0xbd, 0x10, 0x10, 0x80, 0x33, 0xbc, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x33, 0x67, 0x80, 0x33, 0x69, 0x10, 0x10, 0x80, 0x33, 0x68,
+0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x34, 0x5a, 0x80,
+0x34, 0x5c, 0x10, 0x10, 0x80, 0x34, 0x5b, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x34, 0x09, 0x80, 0x34, 0x0b, 0x10, 0x10, 0x80, 0x34, 0x0a, 0x90, 0x88,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0xb8, 0x80, 0x33, 0xba, 0x10, 0x10,
+0x80, 0x33, 0xb9, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x64, 0x80, 0x33,
+0x66, 0x10, 0x10, 0x80, 0x33, 0x65, 0xe4, 0xe1, 0x7d, 0x00, 0x36, 0x08,
+0x88, 0x02, 0x28, 0x91, 0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x34, 0x60, 0x80, 0x34, 0x62, 0x10, 0x10, 0x80, 0x34, 0x61, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x34, 0x0f, 0x80, 0x34, 0x11, 0x10, 0x10, 0x80, 0x34,
+0x10, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0xbe, 0x80, 0x33,
+0xc0, 0x10, 0x10, 0x80, 0x33, 0xbf, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33,
+0x6a, 0x80, 0x33, 0x6c, 0x10, 0x10, 0x80, 0x33, 0x6b, 0xe4, 0xe1, 0x77,
+0x80, 0x35, 0xe8, 0x90, 0x40, 0xe5, 0x21, 0x7c, 0x00, 0x36, 0x04, 0xe5,
+0x21, 0x77, 0x00, 0x35, 0xe6, 0x9e, 0xb4, 0x34, 0x60, 0x93, 0x70, 0x91,
+0xd8, 0xd5, 0x07, 0x80, 0xd0, 0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c, 0x4f,
+0x00, 0x84, 0x3a, 0x10, 0xa4, 0x4d, 0x70, 0x39, 0xc6, 0x90, 0x28, 0x24,
+0x4c, 0xb0, 0xa4, 0x4b, 0x30, 0x39, 0x7e, 0xd0, 0xc4, 0x40, 0x90, 0x48,
+0x80, 0x8c, 0x4e, 0xe0, 0x84, 0x3a, 0x0c, 0xa4, 0x4d, 0x60, 0x39, 0xc4,
+0x90, 0x28, 0x24, 0x4c, 0xa0, 0xa4, 0x4b, 0x20, 0x39, 0x7c, 0xd5, 0x06,
+0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x39, 0xec, 0xa4, 0x4d, 0xa0,
+0x39, 0xcc, 0x90, 0x28, 0x24, 0x4c, 0xe0, 0xa4, 0x4b, 0x60, 0x39, 0x84,
+0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x39, 0xe8, 0xa4, 0x4d, 0x90, 0x39,
+0xca, 0x90, 0x28, 0x24, 0x4c, 0xd0, 0xa4, 0x4b, 0x50, 0x39, 0x82, 0x91,
+0x98, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x39, 0xf8,
+0xa4, 0x4d, 0xd0, 0x39, 0xd2, 0x90, 0x28, 0x24, 0x4d, 0x10, 0xa4, 0x4b,
+0x90, 0x39, 0x8a, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x39, 0xf4, 0xa4,
+0x4d, 0xc0, 0x39, 0xd0, 0x90, 0x28, 0x24, 0x4d, 0x00, 0xa4, 0x4b, 0x80,
+0x39, 0x88, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a,
+0x04, 0xa4, 0x4e, 0x00, 0x39, 0xd8, 0x90, 0x28, 0x24, 0x4d, 0x40, 0xa4,
+0x4b, 0xc0, 0x39, 0x90, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0x00,
+0xa4, 0x4d, 0xf0, 0x39, 0xd6, 0x90, 0x28, 0x24, 0x4d, 0x30, 0xa4, 0x4b,
+0xb0, 0x39, 0x8e, 0x93, 0x70, 0x91, 0xd8, 0xd5, 0x07, 0x80, 0xd0, 0xc4,
+0x40, 0x90, 0x48, 0x80, 0x8c, 0x4f, 0x20, 0x84, 0x3a, 0x0e, 0xa4, 0x4d,
+0x80, 0x39, 0xc8, 0x90, 0x28, 0x24, 0x4c, 0xc0, 0xa4, 0x4b, 0x40, 0x39,
+0x80, 0xd0, 0xc4, 0x40, 0x90, 0x48, 0x80, 0x8c, 0x4e, 0xf0, 0x84, 0x3a,
+0x0d, 0xa4, 0x4d, 0x68, 0x39, 0xc5, 0x90, 0x28, 0x24, 0x4c, 0xa8, 0xa4,
+0x4b, 0x28, 0x39, 0x7d, 0xd5, 0x06, 0x80, 0xd0, 0xc3, 0x40, 0x90, 0x28,
+0x80, 0x39, 0xf0, 0xa4, 0x4d, 0xb0, 0x39, 0xce, 0x90, 0x28, 0x24, 0x4c,
+0xf0, 0xa4, 0x4b, 0x70, 0x39, 0x86, 0xd0, 0xc3, 0x40, 0x90, 0x28, 0x80,
+0x39, 0xea, 0xa4, 0x4d, 0x98, 0x39, 0xcb, 0x90, 0x28, 0x24, 0x4c, 0xd8,
+0xa4, 0x4b, 0x58, 0x39, 0x83, 0x91, 0x98, 0xd5, 0x06, 0x80, 0xd0, 0xc3,
+0x40, 0x90, 0x28, 0x80, 0x39, 0xfc, 0xa4, 0x4d, 0xe0, 0x39, 0xd4, 0x90,
+0x28, 0x24, 0x4d, 0x20, 0xa4, 0x4b, 0xa0, 0x39, 0x8c, 0xd0, 0xc3, 0x40,
+0x90, 0x28, 0x80, 0x39, 0xf6, 0xa4, 0x4d, 0xc8, 0x39, 0xd1, 0x90, 0x28,
+0x24, 0x4d, 0x08, 0xa4, 0x4b, 0x88, 0x39, 0x89, 0xd5, 0x06, 0x80, 0xd0,
+0xc3, 0x40, 0x90, 0x28, 0x80, 0x3a, 0x08, 0xa4, 0x4e, 0x10, 0x39, 0xda,
+0x90, 0x28, 0x24, 0x4d, 0x50, 0xa4, 0x4b, 0xd0, 0x39, 0x92, 0xd0, 0xc3,
+0x40, 0x90, 0x28, 0x80, 0x3a, 0x02, 0xa4, 0x4d, 0xf8, 0x39, 0xd7, 0x90,
+0x28, 0x24, 0x4d, 0x38, 0xa4, 0x4b, 0xb8, 0x39, 0x8f, 0x99, 0x08, 0x01,
+0xf0, 0x81, 0x90, 0x78, 0xd4, 0xc2, 0x00, 0xa4, 0x01, 0x80, 0x30, 0x2e,
+0xa4, 0x01, 0x00, 0x30, 0x1e, 0xd4, 0xc2, 0x00, 0xa4, 0x01, 0xc0, 0x30,
+0x32, 0xa4, 0x01, 0x40, 0x30, 0x22, 0x81, 0x90, 0x78, 0xd4, 0xc2, 0x00,
+0xa4, 0x01, 0xe0, 0x30, 0x36, 0xa4, 0x01, 0x60, 0x30, 0x26, 0xd4, 0xc2,
+0x00, 0xa4, 0x01, 0xd0, 0x30, 0x34, 0xa4, 0x01, 0x50, 0x30, 0x24, 0xa8,
+0x0b, 0x18, 0x13, 0xa8, 0x96, 0x80, 0x93, 0x40, 0x99, 0x90, 0x03, 0x00,
+0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x21, 0xf0, 0x34, 0x51, 0x24,
+0x21, 0xe8, 0x90, 0x38, 0xa4, 0x1f, 0x68, 0x34, 0x00, 0x24, 0x1f, 0x60,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x1c, 0xe0, 0x33, 0xaf, 0x24, 0x1c, 0xd8,
+0x90, 0x38, 0xa4, 0x1a, 0x10, 0x33, 0x58, 0x24, 0x1a, 0x08, 0x90, 0xc0,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x21, 0xe0, 0x34, 0x3a, 0x24, 0x21, 0xd8,
+0x90, 0x38, 0xa4, 0x1f, 0x58, 0x33, 0xe9, 0x24, 0x1f, 0x50, 0x90, 0x60,
+0x90, 0x38, 0xa4, 0x1c, 0xd0, 0x33, 0x98, 0x24, 0x1c, 0xc8, 0x90, 0x38,
+0xa4, 0x1a, 0x00, 0x33, 0x3e, 0x24, 0x19, 0xf8, 0xe4, 0xe2, 0x53, 0x00,
+0x39, 0x4e, 0x99, 0x90, 0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38,
+0xa4, 0x22, 0x80, 0x34, 0x4e, 0x24, 0x22, 0x78, 0x90, 0x38, 0xa4, 0x1f,
+0xf8, 0x33, 0xfd, 0x24, 0x1f, 0xf0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d,
+0x70, 0x33, 0xac, 0x24, 0x1d, 0x68, 0x90, 0x38, 0xa4, 0x1a, 0xb8, 0x33,
+0x55, 0x24, 0x1a, 0xb0, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x21,
+0xc8, 0x34, 0x37, 0x24, 0x21, 0xc0, 0x90, 0x38, 0xa4, 0x1f, 0x40, 0x33,
+0xe6, 0x24, 0x1f, 0x38, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1c, 0xb8, 0x33,
+0x95, 0x24, 0x1c, 0xb0, 0x90, 0x38, 0xa4, 0x19, 0xe8, 0x33, 0x3b, 0x24,
+0x19, 0xe0, 0xe4, 0xe2, 0x54, 0x80, 0x39, 0x54, 0x93, 0x78, 0x99, 0x90,
+0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x22, 0x50, 0x34,
+0x48, 0x24, 0x22, 0x48, 0x90, 0x38, 0xa4, 0x1f, 0xc8, 0x33, 0xf7, 0x24,
+0x1f, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0x40, 0x33, 0xa6, 0x24,
+0x1d, 0x38, 0x90, 0x38, 0xa4, 0x1a, 0x88, 0x33, 0x4f, 0x24, 0x1a, 0x80,
+0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x22, 0x68, 0x34, 0x4b, 0x24,
+0x22, 0x60, 0x90, 0x38, 0xa4, 0x1f, 0xe0, 0x33, 0xfa, 0x24, 0x1f, 0xd8,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0x58, 0x33, 0xa9, 0x24, 0x1d, 0x50,
+0x90, 0x38, 0xa4, 0x1a, 0xa0, 0x33, 0x52, 0x24, 0x1a, 0x98, 0xec, 0xa1,
+0xa1, 0x40, 0x02, 0x00, 0x36, 0x83, 0xa4, 0x4a, 0xc0, 0x39, 0x5a, 0x88,
+0x00, 0x88, 0x10, 0x10, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x1a, 0x28, 0x33,
+0x43, 0x24, 0x1a, 0x20, 0xe9, 0x61, 0xa2, 0x40, 0x02, 0x00, 0x36, 0x8a,
+0xe3, 0x62, 0x57, 0x80, 0x39, 0x60, 0x95, 0x08, 0x93, 0x40, 0x99, 0x90,
+0x03, 0x00, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x22, 0x20, 0x34,
+0x42, 0x24, 0x22, 0x18, 0x90, 0x38, 0xa4, 0x1f, 0x98, 0x33, 0xf1, 0x24,
+0x1f, 0x90, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x1d, 0x10, 0x33, 0xa0, 0x24,
+0x1d, 0x08, 0x90, 0x38, 0xa4, 0x1a, 0x58, 0x33, 0x49, 0x24, 0x1a, 0x50,
+0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x22, 0x08, 0x34, 0x3f, 0x24,
+0x22, 0x00, 0x90, 0x38, 0xa4, 0x1f, 0x80, 0x33, 0xee, 0x24, 0x1f, 0x78,
+0x90, 0x60, 0x90, 0x38, 0xa4, 0x1c, 0xf8, 0x33, 0x9d, 0x24, 0x1c, 0xf0,
+0x90, 0x38, 0xa4, 0x1a, 0x40, 0x33, 0x46, 0x24, 0x1a, 0x38, 0xe4, 0xe2,
+0x53, 0x40, 0x39, 0x50, 0x88, 0x01, 0x88, 0x90, 0xc0, 0x90, 0x60, 0x90,
+0x38, 0xa4, 0x22, 0x38, 0x34, 0x45, 0x24, 0x22, 0x30, 0x90, 0x38, 0xa4,
+0x1f, 0xb0, 0x33, 0xf4, 0x24, 0x1f, 0xa8, 0x90, 0x60, 0x90, 0x38, 0xa4,
+0x1d, 0x28, 0x33, 0xa3, 0x24, 0x1d, 0x20, 0x90, 0x38, 0xa4, 0x1a, 0x70,
+0x33, 0x4c, 0x24, 0x1a, 0x68, 0xe4, 0xe2, 0x54, 0xc0, 0x39, 0x56, 0x92,
+0xd0, 0x99, 0x50, 0x02, 0x80, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80,
+0x30, 0x76, 0x24, 0x03, 0xa8, 0x90, 0x28, 0x80, 0x30, 0x6e, 0x24, 0x03,
+0x68, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0x66, 0x24, 0x03, 0x28, 0x90,
+0x28, 0x80, 0x30, 0x5c, 0x24, 0x02, 0xd8, 0x90, 0xa0, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x30, 0x73, 0x24, 0x03, 0xa0, 0x90, 0x28, 0x80, 0x30, 0x6b,
+0x24, 0x03, 0x60, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0x63, 0x24, 0x03,
+0x20, 0x90, 0x28, 0x80, 0x30, 0x59, 0x24, 0x02, 0xd0, 0xec, 0xe2, 0x56,
+0x60, 0x1f, 0x00, 0x39, 0x5c, 0x88, 0x00, 0x78, 0x10, 0x10, 0x10, 0x10,
+0x90, 0x28, 0x80, 0x30, 0x57, 0x24, 0x02, 0xc0, 0xec, 0xe2, 0x57, 0xe1,
+0xa2, 0x00, 0x39, 0x62, 0xe5, 0xa1, 0x96, 0xc0, 0x36, 0x59, 0xa0, 0x2a,
+0x10, 0xa8, 0x16, 0x60, 0x29, 0xd8, 0xa0, 0x0c, 0x48, 0xa0, 0x0a, 0xc8,
+0x95, 0x60, 0x92, 0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x32, 0xc5, 0x80, 0x32, 0xbb, 0x10, 0x10, 0x80, 0x32, 0xba, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x14, 0x78, 0x33, 0x31, 0xa4, 0x14, 0x28, 0x33,
+0x27, 0x10, 0x10, 0xa4, 0x14, 0x20, 0x33, 0x26, 0x90, 0xb8, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x12, 0x38, 0x32, 0x23, 0xa4, 0x11, 0xe8, 0x32, 0x19,
+0x10, 0x10, 0xa4, 0x11, 0xe0, 0x32, 0x18, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x13, 0x58, 0x32, 0xfb, 0xa4, 0x13, 0x08, 0x32, 0xf1, 0x10, 0x10, 0xa4,
+0x13, 0x00, 0x32, 0xf0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x32, 0xb7, 0x80, 0x32, 0xb9, 0x10, 0x10, 0x80, 0x32, 0xb8, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x14, 0x08, 0x33, 0x23, 0xa4, 0x14, 0x18, 0x33,
+0x25, 0x10, 0x10, 0xa4, 0x14, 0x10, 0x33, 0x24, 0x90, 0xb8, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x11, 0xc8, 0x32, 0x15, 0xa4, 0x11, 0xd8, 0x32, 0x17,
+0x10, 0x10, 0xa4, 0x11, 0xd0, 0x32, 0x16, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x12, 0xe8, 0x32, 0xed, 0xa4, 0x12, 0xf8, 0x32, 0xef, 0x10, 0x10, 0xa4,
+0x12, 0xf0, 0x32, 0xee, 0x92, 0xb0, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x32, 0xc2, 0x80, 0x32, 0xc4, 0x10, 0x10, 0x80, 0x32,
+0xc3, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x14, 0x60, 0x33, 0x2e, 0xa4, 0x14,
+0x70, 0x33, 0x30, 0x10, 0x10, 0xa4, 0x14, 0x68, 0x33, 0x2f, 0x90, 0xb8,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x12, 0x20, 0x32, 0x20, 0xa4, 0x12, 0x30,
+0x32, 0x22, 0x10, 0x10, 0xa4, 0x12, 0x28, 0x32, 0x21, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x13, 0x40, 0x32, 0xf8, 0xa4, 0x13, 0x50, 0x32, 0xfa, 0x10,
+0x10, 0xa4, 0x13, 0x48, 0x32, 0xf9, 0x91, 0x40, 0x90, 0x88, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x32, 0xb4, 0x80, 0x32, 0xb6, 0x10, 0x10, 0x80, 0x32,
+0xb5, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0xf0, 0x33, 0x20, 0xa4, 0x14,
+0x00, 0x33, 0x22, 0x10, 0x10, 0xa4, 0x13, 0xf8, 0x33, 0x21, 0x90, 0xb8,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x11, 0xb0, 0x32, 0x12, 0xa4, 0x11, 0xc0,
+0x32, 0x14, 0x10, 0x10, 0xa4, 0x11, 0xb8, 0x32, 0x13, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x12, 0xd0, 0x32, 0xea, 0xa4, 0x12, 0xe0, 0x32, 0xec, 0x10,
+0x10, 0xa4, 0x12, 0xd8, 0x32, 0xeb, 0x10, 0x10, 0x90, 0xa8, 0x10, 0x10,
+0x10, 0x10, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x38, 0x80, 0x33, 0x3a,
+0x10, 0x10, 0x80, 0x33, 0x39, 0x90, 0x60, 0x90, 0x30, 0x60, 0xa0, 0x20,
+0x80, 0x60, 0xa0, 0x21, 0x00, 0x90, 0x30, 0x60, 0xa0, 0x20, 0xc0, 0x60,
+0xa0, 0x21, 0x40, 0x97, 0xf0, 0x95, 0x60, 0x92, 0xb0, 0x91, 0x40, 0x90,
+0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xbf, 0x80, 0x32, 0xc1, 0x10,
+0x10, 0x80, 0x32, 0xc0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x14, 0x48, 0x33,
+0x2b, 0xa4, 0x14, 0x58, 0x33, 0x2d, 0x10, 0x10, 0xa4, 0x14, 0x50, 0x33,
+0x2c, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x12, 0x08, 0x32, 0x1d,
+0xa4, 0x12, 0x18, 0x32, 0x1f, 0x10, 0x10, 0xa4, 0x12, 0x10, 0x32, 0x1e,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0x28, 0x32, 0xf5, 0xa4, 0x13, 0x38,
+0x32, 0xf7, 0x10, 0x10, 0xa4, 0x13, 0x30, 0x32, 0xf6, 0x91, 0x40, 0x90,
+0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xbc, 0x80, 0x32, 0xbe, 0x10,
+0x10, 0x80, 0x32, 0xbd, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x14, 0x30, 0x33,
+0x28, 0xa4, 0x14, 0x40, 0x33, 0x2a, 0x10, 0x10, 0xa4, 0x14, 0x38, 0x33,
+0x29, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x11, 0xf0, 0x32, 0x1a,
+0xa4, 0x12, 0x00, 0x32, 0x1c, 0x10, 0x10, 0xa4, 0x11, 0xf8, 0x32, 0x1b,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0x10, 0x32, 0xf2, 0xa4, 0x13, 0x20,
+0x32, 0xf4, 0x10, 0x10, 0xa4, 0x13, 0x18, 0x32, 0xf3, 0x10, 0x10, 0x91,
+0x40, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xed, 0x80, 0x31,
+0xe0, 0x90, 0x28, 0x80, 0x31, 0xdf, 0x80, 0x31, 0xde, 0x90, 0x50, 0x90,
+0x28, 0x80, 0x31, 0xe9, 0x80, 0x31, 0xec, 0x90, 0x28, 0x80, 0x31, 0xeb,
+0x80, 0x31, 0xea, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xe1,
+0x80, 0x31, 0xe4, 0x90, 0x28, 0x80, 0x31, 0xe3, 0x80, 0x31, 0xe2, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x31, 0xe5, 0x80, 0x31, 0xe8, 0x90, 0x28, 0x80,
+0x31, 0xe7, 0x80, 0x31, 0xe6, 0x91, 0x88, 0x80, 0x90, 0xc0, 0x90, 0x60,
+0x90, 0x28, 0x81, 0x30, 0x4a, 0x10, 0x10, 0x80, 0x30, 0x49, 0x90, 0x28,
+0x81, 0x30, 0x52, 0x10, 0x10, 0x80, 0x30, 0x51, 0x90, 0x60, 0x90, 0x28,
+0x81, 0x30, 0x46, 0x10, 0x10, 0x80, 0x30, 0x45, 0x90, 0x28, 0x81, 0x30,
+0x4e, 0x10, 0x10, 0x80, 0x30, 0x4d, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90,
+0x28, 0x81, 0x30, 0x55, 0x10, 0x10, 0x80, 0x30, 0x56, 0xa0, 0x0b, 0x90,
+0xa0, 0x0a, 0xc8, 0x95, 0x60, 0x92, 0xb0, 0x91, 0x40, 0x90, 0x88, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x32, 0xb3, 0x80, 0x32, 0xa9, 0x10, 0x10, 0x80,
+0x32, 0xa8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0xe8, 0x33, 0x1f, 0xa4,
+0x13, 0x98, 0x33, 0x15, 0x10, 0x10, 0xa4, 0x13, 0x90, 0x33, 0x14, 0x90,
+0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x11, 0xa8, 0x32, 0x11, 0xa4, 0x11,
+0x58, 0x32, 0x07, 0x10, 0x10, 0xa4, 0x11, 0x50, 0x32, 0x06, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x12, 0xc8, 0x32, 0xe9, 0xa4, 0x12, 0x78, 0x32, 0xdf,
+0x10, 0x10, 0xa4, 0x12, 0x70, 0x32, 0xde, 0x91, 0x40, 0x90, 0x88, 0x90,
+0x50, 0x90, 0x28, 0x80, 0x32, 0xa5, 0x80, 0x32, 0xa7, 0x10, 0x10, 0x80,
+0x32, 0xa6, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0x78, 0x33, 0x11, 0xa4,
+0x13, 0x88, 0x33, 0x13, 0x10, 0x10, 0xa4, 0x13, 0x80, 0x33, 0x12, 0x90,
+0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x11, 0x38, 0x32, 0x03, 0xa4, 0x11,
+0x48, 0x32, 0x05, 0x10, 0x10, 0xa4, 0x11, 0x40, 0x32, 0x04, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x12, 0x58, 0x32, 0xdb, 0xa4, 0x12, 0x68, 0x32, 0xdd,
+0x10, 0x10, 0xa4, 0x12, 0x60, 0x32, 0xdc, 0x92, 0xb0, 0x91, 0x40, 0x90,
+0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xb0, 0x80, 0x32, 0xb2, 0x10,
+0x10, 0x80, 0x32, 0xb1, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0xd0, 0x33,
+0x1c, 0xa4, 0x13, 0xe0, 0x33, 0x1e, 0x10, 0x10, 0xa4, 0x13, 0xd8, 0x33,
+0x1d, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x11, 0x90, 0x32, 0x0e,
+0xa4, 0x11, 0xa0, 0x32, 0x10, 0x10, 0x10, 0xa4, 0x11, 0x98, 0x32, 0x0f,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x12, 0xb0, 0x32, 0xe6, 0xa4, 0x12, 0xc0,
+0x32, 0xe8, 0x10, 0x10, 0xa4, 0x12, 0xb8, 0x32, 0xe7, 0x91, 0x40, 0x90,
+0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xa2, 0x80, 0x32, 0xa4, 0x10,
+0x10, 0x80, 0x32, 0xa3, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x13, 0x60, 0x33,
+0x0e, 0xa4, 0x13, 0x70, 0x33, 0x10, 0x10, 0x10, 0xa4, 0x13, 0x68, 0x33,
+0x0f, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x11, 0x20, 0x32, 0x00,
+0xa4, 0x11, 0x30, 0x32, 0x02, 0x10, 0x10, 0xa4, 0x11, 0x28, 0x32, 0x01,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x12, 0x40, 0x32, 0xd8, 0xa4, 0x12, 0x50,
+0x32, 0xda, 0x10, 0x10, 0xa4, 0x12, 0x48, 0x32, 0xd9, 0x10, 0x10, 0x80,
+0x10, 0x10, 0x10, 0x10, 0x90, 0x50, 0x90, 0x28, 0x80, 0x33, 0x35, 0x80,
+0x33, 0x37, 0x10, 0x10, 0x80, 0x33, 0x36, 0x80, 0x95, 0x60, 0x92, 0xb0,
+0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xad, 0x80,
+0x32, 0xaf, 0x10, 0x10, 0x80, 0x32, 0xae, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x13, 0xb8, 0x33, 0x19, 0xa4, 0x13, 0xc8, 0x33, 0x1b, 0x10, 0x10, 0xa4,
+0x13, 0xc0, 0x33, 0x1a, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x11,
+0x78, 0x32, 0x0b, 0xa4, 0x11, 0x88, 0x32, 0x0d, 0x10, 0x10, 0xa4, 0x11,
+0x80, 0x32, 0x0c, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x12, 0x98, 0x32, 0xe3,
+0xa4, 0x12, 0xa8, 0x32, 0xe5, 0x10, 0x10, 0xa4, 0x12, 0xa0, 0x32, 0xe4,
+0x91, 0x40, 0x90, 0x88, 0x90, 0x50, 0x90, 0x28, 0x80, 0x32, 0xaa, 0x80,
+0x32, 0xac, 0x10, 0x10, 0x80, 0x32, 0xab, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x13, 0xa0, 0x33, 0x16, 0xa4, 0x13, 0xb0, 0x33, 0x18, 0x10, 0x10, 0xa4,
+0x13, 0xa8, 0x33, 0x17, 0x90, 0xb8, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x11,
+0x60, 0x32, 0x08, 0xa4, 0x11, 0x70, 0x32, 0x0a, 0x10, 0x10, 0xa4, 0x11,
+0x68, 0x32, 0x09, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x12, 0x80, 0x32, 0xe0,
+0xa4, 0x12, 0x90, 0x32, 0xe2, 0x10, 0x10, 0xa4, 0x12, 0x88, 0x32, 0xe1,
+0x10, 0x10, 0x91, 0x40, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31,
+0xdd, 0x80, 0x31, 0xd0, 0x90, 0x28, 0x80, 0x31, 0xcf, 0x80, 0x31, 0xce,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xd9, 0x80, 0x31, 0xdc, 0x90, 0x28,
+0x80, 0x31, 0xdb, 0x80, 0x31, 0xda, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x31, 0xd1, 0x80, 0x31, 0xd4, 0x90, 0x28, 0x80, 0x31, 0xd3, 0x80,
+0x31, 0xd2, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xd5, 0x80, 0x31, 0xd8,
+0x90, 0x28, 0x80, 0x31, 0xd7, 0x80, 0x31, 0xd6, 0xc3, 0xc0, 0x30, 0xd1,
+0x9c, 0xe8, 0x07, 0x60, 0x91, 0x90, 0x90, 0xf0, 0x10, 0x10, 0x80, 0x88,
+0x00, 0x80, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0x9e, 0x80, 0x30, 0x9f,
+0x81, 0x30, 0xa4, 0xd0, 0x41, 0x80, 0x24, 0x05, 0x48, 0x24, 0x05, 0x50,
+0x10, 0x10, 0x80, 0x90, 0x58, 0x80, 0x90, 0x28, 0x24, 0x04, 0xe0, 0x24,
+0x04, 0xe8, 0x81, 0x24, 0x05, 0x40, 0x92, 0x68, 0x91, 0x00, 0x80, 0x90,
+0x90, 0x90, 0x30, 0x80, 0x24, 0x05, 0x70, 0x90, 0x38, 0xa4, 0x05, 0x80,
+0x30, 0x1c, 0x80, 0x30, 0x1b, 0x80, 0x90, 0x28, 0x80, 0x31, 0xb8, 0xa4,
+0x05, 0x28, 0x31, 0xb9, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x28, 0x80,
+0x30, 0xc6, 0xa4, 0x05, 0x68, 0x30, 0xc7, 0x90, 0x28, 0x80, 0x30, 0x1a,
+0xa4, 0x05, 0x78, 0x30, 0x19, 0x90, 0x50, 0x90, 0x28, 0x80, 0x31, 0xb6,
+0x80, 0x31, 0xb7, 0x90, 0x28, 0x24, 0x05, 0x58, 0x24, 0x05, 0x60, 0x90,
+0x58, 0x80, 0x10, 0x10, 0x80, 0x10, 0x10, 0x80, 0x30, 0xd0, 0x80, 0x90,
+0x40, 0x10, 0x10, 0x80, 0x24, 0x05, 0x18, 0x80, 0x10, 0x10, 0x80, 0x30,
+0xcf, 0x91, 0x58, 0x91, 0x00, 0x90, 0x80, 0x81, 0x90, 0x50, 0x90, 0x28,
+0x80, 0x30, 0x9a, 0x80, 0x30, 0x9b, 0x81, 0x30, 0xa2, 0x81, 0x90, 0x50,
+0x90, 0x28, 0x80, 0x30, 0x7d, 0x80, 0x30, 0x7e, 0x81, 0x30, 0x81, 0x83,
+0x90, 0x28, 0x24, 0x04, 0xc0, 0x24, 0x04, 0xc8, 0x90, 0xe8, 0x81, 0x90,
+0x88, 0x90, 0x38, 0x10, 0x10, 0x80, 0x30, 0xc5, 0x90, 0x28, 0x80, 0x30,
+0x18, 0x80, 0x30, 0x17, 0x80, 0x90, 0x28, 0x80, 0x31, 0xb4, 0x80, 0x31,
+0xb5, 0x82, 0x10, 0x10, 0x80, 0x24, 0x05, 0x08, 0xa0, 0x0d, 0xa8, 0x9e,
+0x10, 0x06, 0x98, 0x93, 0x00, 0x91, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90,
+0x38, 0xa4, 0x14, 0xb8, 0x32, 0xa1, 0x24, 0x14, 0xb0, 0x90, 0x38, 0xa4,
+0x18, 0x18, 0x33, 0x0d, 0x24, 0x18, 0x10, 0x90, 0x60, 0x90, 0x38, 0xa4,
+0x0f, 0xa8, 0x31, 0xff, 0x24, 0x0f, 0xa0, 0x90, 0x38, 0xa4, 0x16, 0x68,
+0x32, 0xd7, 0x24, 0x16, 0x60, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4,
+0x14, 0xa8, 0x32, 0x93, 0x24, 0x14, 0xa0, 0x90, 0x38, 0xa4, 0x18, 0x08,
+0x32, 0xff, 0x24, 0x18, 0x00, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x0f, 0x98,
+0x31, 0xf1, 0x24, 0x0f, 0x90, 0x90, 0x38, 0xa4, 0x16, 0x58, 0x32, 0xc9,
+0x24, 0x16, 0x50, 0x91, 0x80, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4,
+0x15, 0x00, 0x32, 0x9e, 0x24, 0x14, 0xf8, 0x90, 0x38, 0xa4, 0x18, 0x60,
+0x33, 0x0a, 0x24, 0x18, 0x58, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x0f, 0xf0,
+0x31, 0xfc, 0x24, 0x0f, 0xe8, 0x90, 0x38, 0xa4, 0x16, 0xb0, 0x32, 0xd4,
+0x24, 0x16, 0xa8, 0x90, 0xc0, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x14, 0x90,
+0x32, 0x90, 0x24, 0x14, 0x88, 0x90, 0x38, 0xa4, 0x17, 0xf0, 0x32, 0xfc,
+0x24, 0x17, 0xe8, 0x90, 0x60, 0x90, 0x38, 0xa4, 0x0f, 0x80, 0x31, 0xee,
+0x24, 0x0f, 0x78, 0x90, 0x38, 0xa4, 0x16, 0x40, 0x32, 0xc6, 0x24, 0x16,
+0x38, 0x10, 0x10, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90, 0x38, 0xa4, 0x19,
+0xa0, 0x33, 0x32, 0x24, 0x19, 0x98, 0xd7, 0x1c, 0x40, 0x91, 0xc0, 0x90,
+0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x3b, 0xf8, 0x37, 0x51, 0xa4, 0x3b,
+0x38, 0x37, 0x6f, 0x90, 0x38, 0xa4, 0x3b, 0xd8, 0x37, 0x6b, 0xa4, 0x3b,
+0xb8, 0x37, 0x73, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x3d, 0x88, 0x37, 0x83,
+0xa4, 0x3c, 0xc8, 0x37, 0xa1, 0x90, 0x38, 0xa4, 0x3d, 0x68, 0x37, 0x9d,
+0xa4, 0x3d, 0x48, 0x37, 0xa5, 0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4,
+0x40, 0xa8, 0x37, 0xe7, 0xa4, 0x3f, 0xe8, 0x38, 0x05, 0x90, 0x38, 0xa4,
+0x40, 0x88, 0x38, 0x01, 0xa4, 0x40, 0x68, 0x38, 0x09, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x3f, 0x18, 0x37, 0xb5, 0xa4, 0x3e, 0x58, 0x37, 0xd3, 0x90,
+0x38, 0xa4, 0x3e, 0xf8, 0x37, 0xcf, 0xa4, 0x3e, 0xd8, 0x37, 0xd7, 0x91,
+0xc0, 0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x3b, 0x00, 0x37, 0x62,
+0xa4, 0x3a, 0xa0, 0x37, 0x58, 0x90, 0x38, 0xa4, 0x3a, 0xf0, 0x37, 0x56,
+0xa4, 0x3a, 0xe0, 0x37, 0x5a, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x3c, 0x90,
+0x37, 0x94, 0xa4, 0x3c, 0x30, 0x37, 0x8a, 0x90, 0x38, 0xa4, 0x3c, 0x80,
+0x37, 0x88, 0xa4, 0x3c, 0x70, 0x37, 0x8c, 0x90, 0xe0, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x3f, 0xb0, 0x37, 0xf8, 0xa4, 0x3f, 0x50, 0x37, 0xee, 0x90,
+0x38, 0xa4, 0x3f, 0xa0, 0x37, 0xec, 0xa4, 0x3f, 0x90, 0x37, 0xf0, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x3e, 0x20, 0x37, 0xc6, 0xa4, 0x3d, 0xc0, 0x37,
+0xbc, 0x90, 0x38, 0xa4, 0x3e, 0x10, 0x37, 0xba, 0xa4, 0x3e, 0x00, 0x37,
+0xbe, 0x9c, 0xe0, 0x06, 0x90, 0x93, 0x00, 0x91, 0x80, 0x90, 0xc0, 0x90,
+0x60, 0x90, 0x38, 0xa4, 0x14, 0xe8, 0x32, 0x9b, 0x24, 0x14, 0xe0, 0x90,
+0x38, 0xa4, 0x18, 0x48, 0x33, 0x07, 0x24, 0x18, 0x40, 0x90, 0x60, 0x90,
+0x38, 0xa4, 0x0f, 0xd8, 0x31, 0xf9, 0x24, 0x0f, 0xd0, 0x90, 0x38, 0xa4,
+0x16, 0x98, 0x32, 0xd1, 0x24, 0x16, 0x90, 0x90, 0xc0, 0x90, 0x60, 0x90,
+0x38, 0xa4, 0x14, 0xd0, 0x32, 0x98, 0x24, 0x14, 0xc8, 0x90, 0x38, 0xa4,
+0x18, 0x30, 0x33, 0x04, 0x24, 0x18, 0x28, 0x90, 0x60, 0x90, 0x38, 0xa4,
+0x0f, 0xc0, 0x31, 0xf6, 0x24, 0x0f, 0xb8, 0x90, 0x38, 0xa4, 0x16, 0x80,
+0x32, 0xce, 0x24, 0x16, 0x78, 0x10, 0x10, 0x90, 0xe0, 0x90, 0x70, 0x90,
+0x38, 0xa4, 0x0e, 0x00, 0x31, 0xcd, 0xa4, 0x0d, 0xf0, 0x31, 0xbf, 0x90,
+0x38, 0xa4, 0x0e, 0x60, 0x31, 0xc9, 0xa4, 0x0e, 0x50, 0x31, 0xcb, 0x90,
+0x70, 0x90, 0x38, 0xa4, 0x0e, 0x20, 0x31, 0xc1, 0xa4, 0x0e, 0x10, 0x31,
+0xc3, 0x90, 0x38, 0xa4, 0x0e, 0x40, 0x31, 0xc5, 0xa4, 0x0e, 0x30, 0x31,
+0xc7, 0x91, 0x48, 0x80, 0x90, 0xa0, 0x90, 0x50, 0x90, 0x28, 0x80, 0x30,
+0x48, 0x24, 0x02, 0x38, 0x90, 0x28, 0x80, 0x30, 0x50, 0x24, 0x02, 0x78,
+0x90, 0x50, 0x90, 0x28, 0x80, 0x30, 0x44, 0x24, 0x02, 0x18, 0x90, 0x28,
+0x80, 0x30, 0x4c, 0x24, 0x02, 0x58, 0x80, 0x10, 0x10, 0x10, 0x10, 0x90,
+0x28, 0x80, 0x30, 0x53, 0x24, 0x02, 0xa0, 0xd7, 0x1c, 0x40, 0x91, 0xc0,
+0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x3c, 0x08, 0x37, 0x64, 0xa4,
+0x3b, 0x48, 0x37, 0x71, 0x90, 0x38, 0xa4, 0x3b, 0xe8, 0x37, 0x6d, 0xa4,
+0x3b, 0xc8, 0x37, 0x75, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x3d, 0x98, 0x37,
+0x96, 0xa4, 0x3c, 0xd8, 0x37, 0xa3, 0x90, 0x38, 0xa4, 0x3d, 0x78, 0x37,
+0x9f, 0xa4, 0x3d, 0x58, 0x37, 0xa7, 0x90, 0xe0, 0x90, 0x70, 0x90, 0x38,
+0xa4, 0x40, 0xb8, 0x37, 0xfa, 0xa4, 0x3f, 0xf8, 0x38, 0x07, 0x90, 0x38,
+0xa4, 0x40, 0x98, 0x38, 0x03, 0xa4, 0x40, 0x78, 0x38, 0x0b, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x3f, 0x28, 0x37, 0xc8, 0xa4, 0x3e, 0x68, 0x37, 0xd5,
+0x90, 0x38, 0xa4, 0x3f, 0x08, 0x37, 0xd1, 0xa4, 0x3e, 0xe8, 0x37, 0xd9,
+0x91, 0xc0, 0x90, 0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x3b, 0x08, 0x37,
+0x63, 0xa4, 0x3a, 0xa8, 0x37, 0x59, 0x90, 0x38, 0xa4, 0x3a, 0xf8, 0x37,
+0x57, 0xa4, 0x3a, 0xe8, 0x37, 0x5b, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x3c,
+0x98, 0x37, 0x95, 0xa4, 0x3c, 0x38, 0x37, 0x8b, 0x90, 0x38, 0xa4, 0x3c,
+0x88, 0x37, 0x89, 0xa4, 0x3c, 0x78, 0x37, 0x8d, 0x90, 0xe0, 0x90, 0x70,
+0x90, 0x38, 0xa4, 0x3f, 0xb8, 0x37, 0xf9, 0xa4, 0x3f, 0x58, 0x37, 0xef,
+0x90, 0x38, 0xa4, 0x3f, 0xa8, 0x37, 0xed, 0xa4, 0x3f, 0x98, 0x37, 0xf1,
+0x90, 0x70, 0x90, 0x38, 0xa4, 0x3e, 0x28, 0x37, 0xc7, 0xa4, 0x3d, 0xc8,
+0x37, 0xbd, 0x90, 0x38, 0xa4, 0x3e, 0x18, 0x37, 0xbb, 0xa4, 0x3e, 0x08,
+0x37, 0xbf, 0xa0, 0x14, 0x90, 0xa0, 0x10, 0xb8, 0xa0, 0x0c, 0x88, 0x9e,
+0x88, 0x09, 0xd0, 0x94, 0xf0, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84, 0x10,
+0x10, 0xc9, 0xe1, 0xa0, 0x00, 0x85, 0x35, 0xb3, 0xcb, 0x61, 0x65, 0x00,
+0x85, 0x35, 0x7b, 0x9a, 0x00, 0x03, 0xf8, 0x91, 0x98, 0x80, 0x91, 0x10,
+0x90, 0xa0, 0x90, 0x68, 0x90, 0x20, 0x30, 0xc4, 0xc9, 0xe1, 0x9d, 0x00,
+0x85, 0x35, 0xb1, 0xa4, 0x06, 0x18, 0x30, 0xc2, 0x90, 0x38, 0xa4, 0x04,
+0xa8, 0x30, 0x96, 0xa4, 0x04, 0xa0, 0x30, 0x93, 0x90, 0x48, 0x10, 0x10,
+0xa4, 0x05, 0xd8, 0x30, 0xbc, 0x10, 0x10, 0x80, 0x30, 0xb8, 0x81, 0x10,
+0x10, 0x80, 0xa4, 0x05, 0xa8, 0x30, 0xb6, 0x91, 0xb0, 0x91, 0x60, 0x90,
+0xe0, 0x90, 0x70, 0x90, 0x38, 0xa4, 0x06, 0x00, 0x30, 0xc1, 0xa4, 0x05,
+0xf8, 0x30, 0xbe, 0x90, 0x38, 0xa4, 0x04, 0x88, 0x30, 0x92, 0xa4, 0x04,
+0x80, 0x30, 0x8f, 0x90, 0x48, 0x10, 0x10, 0xa4, 0x05, 0xc8, 0x30, 0xba,
+0x10, 0x10, 0x80, 0x30, 0xb7, 0x90, 0x28, 0x80, 0x30, 0xa0, 0x80, 0x30,
+0x97, 0x81, 0x10, 0x10, 0x80, 0xa4, 0x05, 0x98, 0x30, 0xb4, 0xcb, 0x61,
+0x64, 0xc0, 0x85, 0x35, 0x70, 0x90, 0xd8, 0x88, 0x00, 0x90, 0x84, 0x90,
+0x38, 0xc1, 0xc0, 0x85, 0x31, 0xb3, 0xc9, 0xe1, 0x9c, 0xc0, 0x85, 0x35,
+0xaf, 0xcb, 0x61, 0x64, 0x80, 0x85, 0x35, 0x6f, 0x88, 0x00, 0x68, 0x84,
+0x10, 0x10, 0xc9, 0xe1, 0x9c, 0x80, 0x85, 0x35, 0xad, 0xcb, 0x61, 0x64,
+0x40, 0x85, 0x35, 0x6e, 0x91, 0xf8, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84,
+0x10, 0x10, 0xc9, 0xe1, 0x9e, 0x40, 0x85, 0x35, 0xbd, 0xcb, 0x61, 0x65,
+0x80, 0x85, 0x35, 0x74, 0x88, 0x01, 0x00, 0x90, 0xa0, 0x81, 0x90, 0x70,
+0x80, 0x90, 0x20, 0x30, 0xbd, 0xc9, 0xe1, 0x9e, 0x00, 0x85, 0x35, 0xbb,
+0x81, 0x30, 0x8e, 0x81, 0x10, 0x10, 0x80, 0xa4, 0x05, 0x88, 0x30, 0xb2,
+0xcb, 0x61, 0x66, 0x80, 0x85, 0x35, 0x73, 0x90, 0xb0, 0x88, 0x00, 0x68,
+0x84, 0x10, 0x10, 0xc9, 0xe1, 0x9d, 0xc0, 0x85, 0x35, 0xb9, 0xcb, 0x61,
+0x66, 0x40, 0x85, 0x35, 0x72, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9,
+0xe1, 0x9d, 0x80, 0x85, 0x35, 0xb7, 0xcb, 0x61, 0x66, 0x00, 0x85, 0x35,
+0x71, 0x92, 0x38, 0x81, 0x91, 0x68, 0x91, 0x18, 0x90, 0x80, 0x90, 0x40,
+0x80, 0xa4, 0x54, 0xc8, 0x3a, 0x9a, 0x80, 0xa4, 0x02, 0x10, 0x30, 0x41,
+0x90, 0x28, 0x81, 0x3a, 0x97, 0x90, 0x38, 0xa4, 0x54, 0x88, 0x3a, 0x93,
+0xa4, 0x00, 0x10, 0x30, 0xc9, 0x90, 0x28, 0x80, 0x30, 0x80, 0x80, 0x30,
+0x7f, 0x80, 0x90, 0x40, 0x10, 0x10, 0x80, 0x24, 0x02, 0x00, 0x10, 0x10,
+0x90, 0x38, 0xa4, 0x54, 0x80, 0x3a, 0x92, 0xa4, 0x00, 0x08, 0x30, 0xc8,
+0x90, 0x50, 0x80, 0xc9, 0xa2, 0xa5, 0x40, 0x85, 0x31, 0xb2, 0x80, 0x3a,
+0x96, 0x9a, 0xd0, 0x03, 0xe0, 0x91, 0x60, 0x90, 0xb0, 0x88, 0x00, 0x68,
+0x84, 0x10, 0x10, 0xc9, 0xe1, 0x9f, 0x80, 0x85, 0x35, 0xc7, 0xcb, 0x61,
+0x67, 0x80, 0x85, 0x35, 0x79, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9,
+0xe1, 0x9f, 0x40, 0x85, 0x35, 0xc5, 0xcb, 0x61, 0x67, 0x40, 0x85, 0x35,
+0x78, 0x90, 0xb0, 0x88, 0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe1, 0x9f,
+0x00, 0x85, 0x35, 0xc3, 0xcb, 0x61, 0x67, 0x00, 0x85, 0x35, 0x77, 0x88,
+0x00, 0x68, 0x84, 0x10, 0x10, 0xc9, 0xe1, 0x9e, 0xc0, 0x85, 0x35, 0xc1,
+0xcb, 0x61, 0x66, 0xc0, 0x85, 0x35, 0x76, 0x90, 0x90, 0x90, 0x48, 0xcb,
+0xa1, 0x3b, 0x40, 0x85, 0x34, 0xd8, 0xcb, 0xa1, 0x3b, 0x00, 0x85, 0x34,
+0xd7, 0x90, 0x48, 0xcb, 0xa1, 0x3a, 0xc0, 0x85, 0x34, 0xd6, 0xcb, 0xa1,
+0x3a, 0x80, 0x85, 0x34, 0xd5, 0xcb, 0xa2, 0xa6, 0x00, 0x80, 0x31, 0xb1,
+0x92, 0x40, 0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x8c, 0x2b, 0x10, 0x84,
+0x24, 0x25, 0x48, 0x8c, 0x2b, 0x08, 0x84, 0x24, 0x24, 0xf0, 0x90, 0x48,
+0x8c, 0x2b, 0x00, 0x84, 0x24, 0x24, 0xe8, 0x8c, 0x2a, 0xf8, 0x84, 0x24,
+0x24, 0xe0, 0x90, 0x90, 0x90, 0x48, 0x8c, 0x2b, 0x38, 0x84, 0x24, 0x25,
+0x10, 0x8c, 0x2b, 0x30, 0x84, 0x24, 0x25, 0x08, 0x90, 0x48, 0x8c, 0x2b,
+0x28, 0x84, 0x24, 0x25, 0x00, 0x8c, 0x2b, 0x20, 0x84, 0x24, 0x24, 0xf8,
+0x91, 0x20, 0x90, 0x90, 0x90, 0x48, 0x8c, 0x2b, 0x60, 0x84, 0x24, 0x25,
+0x38, 0x8c, 0x2b, 0x58, 0x84, 0x24, 0x25, 0x30, 0x90, 0x48, 0x8c, 0x2b,
+0x50, 0x84, 0x24, 0x25, 0x28, 0x8c, 0x2b, 0x48, 0x84, 0x24, 0x25, 0x20,
+0x90, 0x38, 0xa4, 0x26, 0x90, 0x34, 0xd3, 0xa4, 0x26, 0x80, 0x34, 0xd1,
+0xa0, 0x0f, 0x50, 0xa0, 0x09, 0x08, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x90,
+0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x21, 0xce, 0x00, 0x37, 0x34,
+0xe5, 0x21, 0xca, 0x80, 0x37, 0x44, 0xcb, 0x61, 0x54, 0x80, 0x85, 0x35,
+0x4d, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x21, 0xbb, 0x00, 0x36, 0xe8, 0xe5,
+0x21, 0xb7, 0x80, 0x36, 0xf8, 0xcb, 0x61, 0x54, 0x40, 0x85, 0x35, 0x42,
+0x90, 0x48, 0xcb, 0xa1, 0x54, 0x00, 0x85, 0x35, 0x41, 0xcb, 0xa1, 0x53,
+0xc0, 0x85, 0x35, 0x40, 0x91, 0x90, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80,
+0xe5, 0x21, 0xc6, 0x00, 0x37, 0x1e, 0xe5, 0x21, 0xc4, 0x80, 0x37, 0x24,
+0xcb, 0x61, 0x55, 0xc0, 0x85, 0x35, 0x46, 0x98, 0x50, 0x00, 0x80, 0xe5,
+0x21, 0xb3, 0x00, 0x36, 0xd2, 0xe5, 0x21, 0xb1, 0x80, 0x36, 0xd8, 0xcb,
+0x61, 0x55, 0x80, 0x85, 0x35, 0x45, 0x90, 0x48, 0xcb, 0xa1, 0x55, 0x40,
+0x85, 0x35, 0x44, 0xcb, 0xa1, 0x55, 0x00, 0x85, 0x35, 0x43, 0x92, 0x20,
+0x91, 0x30, 0x90, 0xb8, 0xd5, 0x03, 0x00, 0xc0, 0xc0, 0x81, 0x8c, 0x48,
+0xa8, 0x84, 0x39, 0x45, 0xc0, 0xc0, 0x81, 0x8c, 0x48, 0x88, 0x84, 0x39,
+0x41, 0xd5, 0x02, 0x00, 0xc0, 0xc0, 0x81, 0x39, 0x21, 0xc0, 0xc0, 0x81,
+0x39, 0x1d, 0x90, 0x78, 0xd5, 0x02, 0x00, 0xc0, 0xc0, 0x81, 0x39, 0x2d,
+0xc0, 0xc0, 0x81, 0x39, 0x29, 0xd5, 0x02, 0x00, 0xc0, 0xc0, 0x81, 0x39,
+0x39, 0xc0, 0xc0, 0x81, 0x39, 0x35, 0x91, 0x70, 0x90, 0xd8, 0xd5, 0x03,
+0x80, 0xc8, 0xe1, 0xbf, 0x80, 0x81, 0x8c, 0x48, 0xc8, 0x84, 0x39, 0x43,
+0xc8, 0xe1, 0xc0, 0x80, 0x81, 0x8c, 0x48, 0x98, 0x84, 0x39, 0x42, 0xd5,
+0x02, 0x80, 0xc8, 0xe1, 0xc3, 0x00, 0x81, 0x39, 0x25, 0xc8, 0xe1, 0xbf,
+0x00, 0x81, 0x39, 0x1f, 0x90, 0x98, 0xd5, 0x02, 0x80, 0xc8, 0xe1, 0xac,
+0x80, 0x81, 0x39, 0x31, 0xc8, 0xe1, 0xad, 0x80, 0x81, 0x39, 0x2b, 0xd5,
+0x02, 0x80, 0xc8, 0xe1, 0xb0, 0x00, 0x81, 0x39, 0x3d, 0xc8, 0xe1, 0xac,
+0x00, 0x81, 0x39, 0x37, 0x9a, 0x30, 0x04, 0x40, 0x91, 0x90, 0x90, 0xc8,
+0x98, 0x50, 0x00, 0x80, 0xe5, 0x21, 0xcc, 0x00, 0x37, 0x2c, 0xe5, 0x21,
+0xc9, 0x80, 0x37, 0x40, 0xcb, 0x61, 0x57, 0x00, 0x85, 0x35, 0x4b, 0x98,
+0x50, 0x00, 0x80, 0xe5, 0x21, 0xb9, 0x00, 0x36, 0xe0, 0xe5, 0x21, 0xb6,
+0x80, 0x36, 0xf4, 0xcb, 0x61, 0x56, 0xc0, 0x85, 0x35, 0x4a, 0x90, 0x48,
+0xcb, 0xa1, 0x56, 0x80, 0x85, 0x35, 0x49, 0xcb, 0xa1, 0x56, 0x40, 0x85,
+0x35, 0x48, 0x91, 0x90, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x21,
+0xc5, 0x00, 0x37, 0x1a, 0xe5, 0x21, 0xc3, 0x80, 0x37, 0x20, 0xcb, 0x61,
+0x33, 0x40, 0x85, 0x34, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x21, 0xb2,
+0x00, 0x36, 0xce, 0xe5, 0x21, 0xb0, 0x80, 0x36, 0xd4, 0xcb, 0x61, 0x33,
+0x00, 0x85, 0x34, 0xc7, 0x90, 0x48, 0xcb, 0xa1, 0x32, 0xc0, 0x85, 0x34,
+0xc6, 0xcb, 0xa1, 0x32, 0x80, 0x85, 0x34, 0xc5, 0x91, 0x00, 0x90, 0x80,
+0x90, 0x40, 0xe5, 0x22, 0x38, 0x40, 0x38, 0xe7, 0xe5, 0x22, 0x3b, 0xc0,
+0x38, 0xf3, 0x90, 0x40, 0xe5, 0x22, 0x3e, 0x40, 0x38, 0xff, 0xe5, 0x22,
+0x41, 0xc0, 0x39, 0x0b, 0x90, 0x80, 0x90, 0x40, 0xe5, 0x22, 0x38, 0x80,
+0x38, 0xe9, 0xe5, 0x22, 0x3c, 0x00, 0x38, 0xf5, 0x90, 0x40, 0xe5, 0x22,
+0x3e, 0x80, 0x39, 0x01, 0xe5, 0x22, 0x42, 0x00, 0x39, 0x0d, 0x80, 0x99,
+0x28, 0x02, 0xf0, 0x8c, 0x25, 0x80, 0x90, 0x80, 0x90, 0x40, 0xe5, 0x21,
+0xcf, 0x80, 0x37, 0x3c, 0xe5, 0x21, 0xca, 0x00, 0x37, 0x42, 0x90, 0x40,
+0xe5, 0x21, 0xbc, 0x80, 0x36, 0xf0, 0xe5, 0x21, 0xb7, 0x00, 0x36, 0xf6,
+0x91, 0x48, 0x90, 0xc8, 0x98, 0x50, 0x00, 0x80, 0xe5, 0x21, 0xc5, 0x80,
+0x37, 0x1c, 0xe5, 0x21, 0xc4, 0x00, 0x37, 0x22, 0xcb, 0x60, 0x01, 0xc0,
+0x85, 0x30, 0x03, 0x90, 0x40, 0xe5, 0x21, 0xb2, 0x80, 0x36, 0xd0, 0xe5,
+0x21, 0xb1, 0x00, 0x36, 0xd6, 0x90, 0x48, 0xcb, 0xa0, 0x02, 0x40, 0x85,
+0x30, 0x05, 0xcb, 0xa0, 0x02, 0x80, 0x85, 0x30, 0x06, 0x10, 0x10, 0x90,
+0x80, 0x90, 0x40, 0xe5, 0x21, 0xc2, 0x00, 0x37, 0x06, 0xe5, 0x21, 0xbe,
+0x80, 0x37, 0x0a, 0x90, 0x40, 0xe5, 0x21, 0xaf, 0x00, 0x36, 0xba, 0xe5,
+0x21, 0xab, 0x80, 0x36, 0xbe,
+};
+
+static const struct ia64_dis_names ia64_dis_names[] = {
+{ 0x1, 391, 0 },
+{ 0x1, 389, 0 },
+{ 0x1, 388, 0 },
+{ 0x4, 387, 1 },
+{ 0x8, 387, 0 },
+{ 0x2, 387, 0 },
+{ 0x1, 387, 0 },
+{ 0x4, 385, 1 },
+{ 0x1, 386, 0 },
+{ 0x2, 385, 0 },
+{ 0x1, 385, 0 },
+{ 0x4, 384, 0 },
+{ 0x2, 384, 0 },
+{ 0x1, 384, 0 },
+{ 0x4, 383, 0 },
+{ 0x2, 383, 0 },
+{ 0x1, 383, 0 },
+{ 0x4, 382, 0 },
+{ 0x2, 382, 0 },
+{ 0x1, 382, 0 },
+{ 0x4, 381, 0 },
+{ 0x2, 381, 0 },
+{ 0x1, 381, 0 },
+{ 0x2, 380, 0 },
+{ 0x1, 380, 0 },
+{ 0x2, 379, 0 },
+{ 0x1, 379, 0 },
+{ 0x2, 378, 0 },
+{ 0x1, 378, 0 },
+{ 0x1, 376, 0 },
+{ 0x2, 374, 1 },
+{ 0x1, 375, 0 },
+{ 0x12, 374, 1 },
+{ 0x11, 375, 0 },
+{ 0xa, 374, 1 },
+{ 0x9, 375, 0 },
+{ 0x1a, 374, 1 },
+{ 0x7, 375, 0 },
+{ 0x6, 374, 1 },
+{ 0x5, 375, 0 },
+{ 0x5, 374, 1 },
+{ 0x12, 375, 0 },
+{ 0xd, 374, 1 },
+{ 0xe, 375, 0 },
+{ 0x3, 374, 1 },
+{ 0xa, 375, 0 },
+{ 0x2, 371, 1 },
+{ 0x1, 372, 0 },
+{ 0x12, 371, 1 },
+{ 0x11, 372, 0 },
+{ 0xa, 371, 1 },
+{ 0x9, 372, 0 },
+{ 0x1a, 371, 1 },
+{ 0x7, 372, 0 },
+{ 0x6, 371, 1 },
+{ 0x5, 372, 0 },
+{ 0x5, 371, 1 },
+{ 0x12, 372, 0 },
+{ 0xd, 371, 1 },
+{ 0xe, 372, 0 },
+{ 0x3, 371, 1 },
+{ 0xa, 372, 0 },
+{ 0x1, 370, 0 },
+{ 0x1, 365, 0 },
+{ 0x1, 364, 0 },
+{ 0x1, 363, 0 },
+{ 0x1, 362, 0 },
+{ 0x2, 361, 0 },
+{ 0x1, 361, 0 },
+{ 0x2, 360, 0 },
+{ 0x1, 360, 0 },
+{ 0x2, 359, 0 },
+{ 0x1, 359, 0 },
+{ 0x2, 358, 0 },
+{ 0x1, 358, 0 },
+{ 0x2, 357, 0 },
+{ 0x1, 357, 0 },
+{ 0x2, 356, 0 },
+{ 0x1, 356, 0 },
+{ 0x2, 355, 0 },
+{ 0x1, 355, 0 },
+{ 0x2, 354, 0 },
+{ 0x1, 354, 0 },
+{ 0x1, 353, 0 },
+{ 0x3, 353, 0 },
+{ 0x1, 352, 0 },
+{ 0x3, 352, 0 },
+{ 0x8, 351, 0 },
+{ 0x18, 351, 0 },
+{ 0x4, 351, 0 },
+{ 0xc, 351, 0 },
+{ 0x2, 351, 0 },
+{ 0x1, 351, 0 },
+{ 0x8, 350, 0 },
+{ 0x18, 350, 0 },
+{ 0x4, 350, 0 },
+{ 0xc, 350, 0 },
+{ 0x2, 350, 0 },
+{ 0x1, 350, 0 },
+{ 0x4, 349, 0 },
+{ 0xc, 349, 0 },
+{ 0x2, 349, 0 },
+{ 0x1, 349, 0 },
+{ 0x4, 348, 0 },
+{ 0xc, 348, 0 },
+{ 0x2, 348, 0 },
+{ 0x1, 348, 0 },
+{ 0x4, 347, 0 },
+{ 0xc, 347, 0 },
+{ 0x2, 347, 0 },
+{ 0x1, 347, 0 },
+{ 0x4, 346, 0 },
+{ 0xc, 346, 0 },
+{ 0x2, 346, 0 },
+{ 0x1, 346, 0 },
+{ 0x4, 345, 0 },
+{ 0xc, 345, 0 },
+{ 0x2, 345, 0 },
+{ 0x1, 345, 0 },
+{ 0x4, 344, 0 },
+{ 0xc, 344, 0 },
+{ 0x2, 344, 0 },
+{ 0x1, 344, 0 },
+{ 0x1, 343, 0 },
+{ 0x1, 341, 0 },
+{ 0x2, 340, 0 },
+{ 0x1, 340, 0 },
+{ 0x1, 338, 0 },
+{ 0x1, 337, 0 },
+{ 0x1, 336, 0 },
+{ 0x8, 334, 0 },
+{ 0x4, 334, 0 },
+{ 0x2, 334, 0 },
+{ 0x1, 334, 0 },
+{ 0x1, 333, 0 },
+{ 0x1, 332, 0 },
+{ 0x1, 331, 0 },
+{ 0x2, 330, 0 },
+{ 0x1, 330, 0 },
+{ 0x2, 328, 0 },
+{ 0x1, 328, 0 },
+{ 0x1, 327, 0 },
+{ 0x1, 326, 0 },
+{ 0x8, 325, 0 },
+{ 0x4, 325, 0 },
+{ 0x2, 325, 0 },
+{ 0x1, 325, 0 },
+{ 0x8, 324, 0 },
+{ 0x4, 324, 0 },
+{ 0x2, 324, 0 },
+{ 0x1, 324, 0 },
+{ 0x1, 323, 0 },
+{ 0x2, 322, 0 },
+{ 0x1, 322, 0 },
+{ 0x2, 321, 0 },
+{ 0x1, 321, 0 },
+{ 0x2, 320, 0 },
+{ 0x1, 320, 0 },
+{ 0x2, 319, 0 },
+{ 0x1, 319, 0 },
+{ 0x1, 318, 0 },
+{ 0x1, 317, 0 },
+{ 0x1, 316, 0 },
+{ 0x1, 315, 0 },
+{ 0x1, 314, 0 },
+{ 0x1, 313, 0 },
+{ 0x2, 310, 0 },
+{ 0x1, 310, 0 },
+{ 0x1, 309, 0 },
+{ 0x2, 308, 0 },
+{ 0x1, 308, 0 },
+{ 0x2, 307, 0 },
+{ 0x1, 307, 0 },
+{ 0x1, 306, 0 },
+{ 0x1, 305, 0 },
+{ 0x1, 304, 0 },
+{ 0x1, 303, 0 },
+{ 0x2, 302, 0 },
+{ 0x1, 302, 0 },
+{ 0x2, 301, 0 },
+{ 0x1, 301, 0 },
+{ 0x2, 300, 0 },
+{ 0x1, 300, 0 },
+{ 0x1, 299, 0 },
+{ 0x1, 298, 0 },
+{ 0x2, 297, 0 },
+{ 0x1, 297, 0 },
+{ 0x2, 296, 0 },
+{ 0x1, 296, 0 },
+{ 0x1, 295, 0 },
+{ 0x8, 294, 0 },
+{ 0x4, 294, 0 },
+{ 0x2, 294, 0 },
+{ 0x1, 294, 0 },
+{ 0x8, 293, 0 },
+{ 0x4, 293, 0 },
+{ 0x1, 293, 0 },
+{ 0x1, 292, 0 },
+{ 0x2, 291, 0 },
+{ 0x1, 291, 0 },
+{ 0x1, 290, 0 },
+{ 0x1, 289, 0 },
+{ 0x1, 285, 1 },
+{ 0x1, 286, 1 },
+{ 0x1, 287, 0 },
+{ 0x1, 284, 0 },
+{ 0x1, 283, 0 },
+{ 0x1, 282, 0 },
+{ 0x1, 281, 0 },
+{ 0x1, 280, 0 },
+{ 0x1, 272, 0 },
+{ 0x1, 271, 0 },
+{ 0x1, 270, 0 },
+{ 0x1, 269, 0 },
+{ 0x1, 268, 0 },
+{ 0x1, 267, 0 },
+{ 0x1, 266, 0 },
+{ 0x1, 265, 0 },
+{ 0x1, 264, 0 },
+{ 0x1, 263, 0 },
+{ 0x1, 262, 0 },
+{ 0x1, 261, 0 },
+{ 0x1, 260, 0 },
+{ 0x1, 259, 0 },
+{ 0x1, 258, 0 },
+{ 0x1, 257, 0 },
+{ 0x1, 256, 0 },
+{ 0x1, 255, 0 },
+{ 0x1, 254, 0 },
+{ 0x1, 253, 0 },
+{ 0x1, 252, 0 },
+{ 0x1, 250, 0 },
+{ 0x1, 249, 1 },
+{ 0x1, 369, 0 },
+{ 0x1, 248, 1 },
+{ 0x1, 342, 0 },
+{ 0x1, 247, 0 },
+{ 0x1, 246, 0 },
+{ 0x1, 245, 1 },
+{ 0x2, 342, 0 },
+{ 0x1250, 244, 0 },
+{ 0x3250, 244, 0 },
+{ 0xa50, 244, 0 },
+{ 0x1a50, 244, 0 },
+{ 0x650, 244, 0 },
+{ 0xe50, 244, 0 },
+{ 0x950, 244, 0 },
+{ 0x1950, 244, 0 },
+{ 0x550, 244, 0 },
+{ 0xd50, 244, 0 },
+{ 0x350, 244, 0 },
+{ 0x750, 244, 0 },
+{ 0x2d0, 244, 0 },
+{ 0x6d0, 244, 0 },
+{ 0x1d0, 244, 0 },
+{ 0x3d0, 244, 0 },
+{ 0x930, 244, 0 },
+{ 0x1930, 244, 0 },
+{ 0x530, 244, 0 },
+{ 0xd30, 244, 0 },
+{ 0x330, 244, 0 },
+{ 0x730, 244, 0 },
+{ 0x4b0, 244, 0 },
+{ 0xcb0, 244, 0 },
+{ 0x2b0, 244, 0 },
+{ 0x6b0, 244, 0 },
+{ 0x1b0, 244, 0 },
+{ 0x3b0, 244, 0 },
+{ 0x170, 244, 0 },
+{ 0x370, 244, 0 },
+{ 0xf0, 244, 0 },
+{ 0x1f0, 244, 0 },
+{ 0x9288, 244, 0 },
+{ 0x19288, 244, 0 },
+{ 0x5288, 244, 0 },
+{ 0xd288, 244, 0 },
+{ 0x3288, 244, 0 },
+{ 0x7288, 244, 0 },
+{ 0x4a88, 244, 0 },
+{ 0xca88, 244, 0 },
+{ 0x2a88, 244, 0 },
+{ 0x6a88, 244, 0 },
+{ 0x1a88, 244, 0 },
+{ 0x3a88, 244, 0 },
+{ 0x1688, 244, 0 },
+{ 0x3688, 244, 0 },
+{ 0xe88, 244, 0 },
+{ 0x1e88, 244, 0 },
+{ 0x4988, 244, 0 },
+{ 0xc988, 244, 0 },
+{ 0x2988, 244, 0 },
+{ 0x6988, 244, 0 },
+{ 0x1988, 244, 0 },
+{ 0x3988, 244, 0 },
+{ 0x2588, 244, 0 },
+{ 0x6588, 244, 0 },
+{ 0x1588, 244, 0 },
+{ 0x3588, 244, 0 },
+{ 0xd88, 244, 0 },
+{ 0x1d88, 244, 0 },
+{ 0xb88, 244, 0 },
+{ 0x1b88, 244, 0 },
+{ 0x788, 244, 0 },
+{ 0xf88, 244, 0 },
+{ 0x1248, 244, 0 },
+{ 0x3248, 244, 0 },
+{ 0xa48, 244, 0 },
+{ 0x1a48, 244, 0 },
+{ 0x648, 244, 0 },
+{ 0xe48, 244, 0 },
+{ 0x948, 244, 0 },
+{ 0x1948, 244, 0 },
+{ 0x548, 244, 0 },
+{ 0xd48, 244, 0 },
+{ 0x348, 244, 0 },
+{ 0x748, 244, 0 },
+{ 0x2c8, 244, 0 },
+{ 0x6c8, 244, 0 },
+{ 0x1c8, 244, 0 },
+{ 0x3c8, 244, 0 },
+{ 0x928, 244, 0 },
+{ 0x1928, 244, 0 },
+{ 0x528, 244, 0 },
+{ 0xd28, 244, 0 },
+{ 0x328, 244, 0 },
+{ 0x728, 244, 0 },
+{ 0x4a8, 244, 0 },
+{ 0xca8, 244, 0 },
+{ 0x2a8, 244, 0 },
+{ 0x6a8, 244, 0 },
+{ 0x1a8, 244, 0 },
+{ 0x3a8, 244, 0 },
+{ 0x168, 244, 0 },
+{ 0x368, 244, 0 },
+{ 0xe8, 244, 0 },
+{ 0x1e8, 244, 0 },
+{ 0x1258, 244, 0 },
+{ 0x3258, 244, 0 },
+{ 0xa58, 244, 0 },
+{ 0x1a58, 244, 0 },
+{ 0x658, 244, 0 },
+{ 0xe58, 244, 0 },
+{ 0x958, 244, 0 },
+{ 0x1958, 244, 0 },
+{ 0x558, 244, 0 },
+{ 0xd58, 244, 0 },
+{ 0x358, 244, 0 },
+{ 0x758, 244, 0 },
+{ 0x2d8, 244, 0 },
+{ 0x6d8, 244, 0 },
+{ 0x1d8, 244, 0 },
+{ 0x3d8, 244, 0 },
+{ 0x938, 244, 0 },
+{ 0x1938, 244, 0 },
+{ 0x538, 244, 0 },
+{ 0xd38, 244, 0 },
+{ 0x338, 244, 0 },
+{ 0x738, 244, 0 },
+{ 0x4b8, 244, 0 },
+{ 0xcb8, 244, 0 },
+{ 0x2b8, 244, 0 },
+{ 0x6b8, 244, 0 },
+{ 0x1b8, 244, 0 },
+{ 0x3b8, 244, 0 },
+{ 0x178, 244, 0 },
+{ 0x378, 244, 0 },
+{ 0xf8, 244, 0 },
+{ 0x1f8, 244, 0 },
+{ 0x124, 244, 0 },
+{ 0x324, 244, 0 },
+{ 0xa4, 244, 0 },
+{ 0x1a4, 244, 0 },
+{ 0x64, 244, 0 },
+{ 0xe4, 244, 0 },
+{ 0x94, 244, 0 },
+{ 0x194, 244, 0 },
+{ 0x54, 244, 0 },
+{ 0xd4, 244, 0 },
+{ 0x34, 244, 0 },
+{ 0x74, 244, 0 },
+{ 0x2c, 244, 0 },
+{ 0x6c, 244, 0 },
+{ 0x1c, 244, 0 },
+{ 0x3c, 244, 0 },
+{ 0x92, 244, 0 },
+{ 0x192, 244, 0 },
+{ 0x52, 244, 0 },
+{ 0xd2, 244, 0 },
+{ 0x32, 244, 0 },
+{ 0x72, 244, 0 },
+{ 0x4a, 244, 0 },
+{ 0xca, 244, 0 },
+{ 0x2a, 244, 0 },
+{ 0x6a, 244, 0 },
+{ 0x1a, 244, 0 },
+{ 0x3a, 244, 0 },
+{ 0x16, 244, 0 },
+{ 0x36, 244, 0 },
+{ 0x1e, 244, 0 },
+{ 0x125, 244, 0 },
+{ 0x325, 244, 0 },
+{ 0xa5, 244, 0 },
+{ 0x1a5, 244, 0 },
+{ 0x65, 244, 0 },
+{ 0xe5, 244, 0 },
+{ 0x95, 244, 0 },
+{ 0x195, 244, 0 },
+{ 0x55, 244, 0 },
+{ 0xd5, 244, 0 },
+{ 0x35, 244, 0 },
+{ 0x75, 244, 0 },
+{ 0x2d, 244, 0 },
+{ 0x6d, 244, 0 },
+{ 0x1d, 244, 0 },
+{ 0x3d, 244, 0 },
+{ 0x93, 244, 0 },
+{ 0x193, 244, 0 },
+{ 0x53, 244, 0 },
+{ 0xd3, 244, 0 },
+{ 0x33, 244, 0 },
+{ 0x73, 244, 0 },
+{ 0x4b, 244, 0 },
+{ 0xcb, 244, 0 },
+{ 0x2b, 244, 0 },
+{ 0x6b, 244, 0 },
+{ 0x1b, 244, 0 },
+{ 0x3b, 244, 0 },
+{ 0x17, 244, 0 },
+{ 0x37, 244, 0 },
+{ 0xf, 244, 0 },
+{ 0x1f, 244, 0 },
+{ 0x1, 243, 1 },
+{ 0xe, 244, 0 },
+{ 0x1, 241, 0 },
+{ 0x1, 240, 0 },
+{ 0x1, 239, 0 },
+{ 0x2, 238, 0 },
+{ 0x1, 238, 0 },
+{ 0x2, 237, 0 },
+{ 0x1, 237, 0 },
+{ 0x2, 236, 0 },
+{ 0x1, 236, 0 },
+{ 0x2, 235, 0 },
+{ 0x1, 235, 0 },
+{ 0x1, 234, 1 },
+{ 0x1, 251, 0 },
+{ 0x20, 233, 0 },
+{ 0x10, 233, 0 },
+{ 0x8, 233, 0 },
+{ 0x4, 233, 0 },
+{ 0x44, 233, 0 },
+{ 0x24, 233, 0 },
+{ 0x14, 233, 0 },
+{ 0xc, 233, 0 },
+{ 0x4c, 233, 0 },
+{ 0x2c, 233, 0 },
+{ 0x1c, 233, 0 },
+{ 0x2, 233, 0 },
+{ 0x12, 233, 0 },
+{ 0xa, 233, 0 },
+{ 0x6, 233, 0 },
+{ 0x1, 233, 0 },
+{ 0x20, 232, 0 },
+{ 0x10, 232, 0 },
+{ 0x8, 232, 0 },
+{ 0x4, 232, 0 },
+{ 0x44, 232, 0 },
+{ 0x24, 232, 0 },
+{ 0x14, 232, 0 },
+{ 0xc, 232, 0 },
+{ 0x4c, 232, 0 },
+{ 0x2c, 232, 0 },
+{ 0x1c, 232, 0 },
+{ 0x2, 232, 0 },
+{ 0x12, 232, 0 },
+{ 0xa, 232, 0 },
+{ 0x6, 232, 0 },
+{ 0x1, 232, 0 },
+{ 0x20, 231, 0 },
+{ 0x10, 231, 0 },
+{ 0x8, 231, 0 },
+{ 0x4, 231, 0 },
+{ 0x44, 231, 0 },
+{ 0x24, 231, 0 },
+{ 0x14, 231, 0 },
+{ 0xc, 231, 0 },
+{ 0x4c, 231, 0 },
+{ 0x2c, 231, 0 },
+{ 0x1c, 231, 0 },
+{ 0x2, 231, 0 },
+{ 0x12, 231, 0 },
+{ 0xa, 231, 0 },
+{ 0x6, 231, 0 },
+{ 0x1, 231, 0 },
+{ 0x40, 230, 0 },
+{ 0x140, 230, 0 },
+{ 0xc0, 230, 0 },
+{ 0x20, 230, 0 },
+{ 0xa0, 230, 0 },
+{ 0x60, 230, 0 },
+{ 0x10, 230, 0 },
+{ 0x8, 230, 0 },
+{ 0x14, 230, 0 },
+{ 0x54, 230, 0 },
+{ 0x34, 230, 0 },
+{ 0xc, 230, 0 },
+{ 0x2c, 230, 0 },
+{ 0x1c, 230, 0 },
+{ 0x2, 230, 0 },
+{ 0xa, 230, 0 },
+{ 0x6, 230, 0 },
+{ 0x1, 230, 0 },
+{ 0x40, 229, 0 },
+{ 0x140, 229, 0 },
+{ 0xc0, 229, 0 },
+{ 0x20, 229, 0 },
+{ 0xa0, 229, 0 },
+{ 0x60, 229, 0 },
+{ 0x10, 229, 0 },
+{ 0x8, 229, 0 },
+{ 0x14, 229, 0 },
+{ 0x54, 229, 0 },
+{ 0x34, 229, 0 },
+{ 0xc, 229, 0 },
+{ 0x2c, 229, 0 },
+{ 0x1c, 229, 0 },
+{ 0x2, 229, 0 },
+{ 0xa, 229, 0 },
+{ 0x6, 229, 0 },
+{ 0x1, 229, 0 },
+{ 0x40, 228, 0 },
+{ 0x140, 228, 0 },
+{ 0xc0, 228, 0 },
+{ 0x20, 228, 0 },
+{ 0xa0, 228, 0 },
+{ 0x60, 228, 0 },
+{ 0x10, 228, 0 },
+{ 0x8, 228, 0 },
+{ 0x14, 228, 0 },
+{ 0x54, 228, 0 },
+{ 0x34, 228, 0 },
+{ 0xc, 228, 0 },
+{ 0x2c, 228, 0 },
+{ 0x1c, 228, 0 },
+{ 0x2, 228, 0 },
+{ 0xa, 228, 0 },
+{ 0x6, 228, 0 },
+{ 0x1, 228, 0 },
+{ 0x40, 227, 0 },
+{ 0x140, 227, 0 },
+{ 0xc0, 227, 0 },
+{ 0x20, 227, 0 },
+{ 0xa0, 227, 0 },
+{ 0x60, 227, 0 },
+{ 0x10, 227, 0 },
+{ 0x8, 227, 0 },
+{ 0x14, 227, 0 },
+{ 0x54, 227, 0 },
+{ 0x34, 227, 0 },
+{ 0xc, 227, 0 },
+{ 0x2c, 227, 0 },
+{ 0x1c, 227, 0 },
+{ 0x2, 227, 0 },
+{ 0xa, 227, 0 },
+{ 0x6, 227, 0 },
+{ 0x1, 227, 0 },
+{ 0x40, 226, 0 },
+{ 0x140, 226, 0 },
+{ 0xc0, 226, 0 },
+{ 0x20, 226, 0 },
+{ 0xa0, 226, 0 },
+{ 0x60, 226, 0 },
+{ 0x10, 226, 0 },
+{ 0x8, 226, 0 },
+{ 0x14, 226, 0 },
+{ 0x54, 226, 0 },
+{ 0x34, 226, 0 },
+{ 0xc, 226, 0 },
+{ 0x2c, 226, 0 },
+{ 0x1c, 226, 0 },
+{ 0x2, 226, 0 },
+{ 0xa, 226, 0 },
+{ 0x6, 226, 0 },
+{ 0x1, 226, 0 },
+{ 0x40, 225, 0 },
+{ 0x140, 225, 0 },
+{ 0xc0, 225, 0 },
+{ 0x20, 225, 0 },
+{ 0xa0, 225, 0 },
+{ 0x60, 225, 0 },
+{ 0x10, 225, 0 },
+{ 0x8, 225, 0 },
+{ 0x14, 225, 0 },
+{ 0x54, 225, 0 },
+{ 0x34, 225, 0 },
+{ 0xc, 225, 0 },
+{ 0x2c, 225, 0 },
+{ 0x1c, 225, 0 },
+{ 0x2, 225, 0 },
+{ 0xa, 225, 0 },
+{ 0x6, 225, 0 },
+{ 0x1, 225, 0 },
+{ 0x40, 224, 0 },
+{ 0x140, 224, 0 },
+{ 0xc0, 224, 0 },
+{ 0x20, 224, 0 },
+{ 0xa0, 224, 0 },
+{ 0x60, 224, 0 },
+{ 0x10, 224, 0 },
+{ 0x8, 224, 0 },
+{ 0x14, 224, 0 },
+{ 0x54, 224, 0 },
+{ 0x34, 224, 0 },
+{ 0xc, 224, 0 },
+{ 0x2c, 224, 0 },
+{ 0x1c, 224, 0 },
+{ 0x2, 224, 0 },
+{ 0xa, 224, 0 },
+{ 0x6, 224, 0 },
+{ 0x1, 224, 0 },
+{ 0x40, 223, 0 },
+{ 0x140, 223, 0 },
+{ 0xc0, 223, 0 },
+{ 0x20, 223, 0 },
+{ 0xa0, 223, 0 },
+{ 0x60, 223, 0 },
+{ 0x10, 223, 0 },
+{ 0x8, 223, 0 },
+{ 0x14, 223, 0 },
+{ 0x54, 223, 0 },
+{ 0x34, 223, 0 },
+{ 0xc, 223, 0 },
+{ 0x2c, 223, 0 },
+{ 0x1c, 223, 0 },
+{ 0x2, 223, 0 },
+{ 0xa, 223, 0 },
+{ 0x6, 223, 0 },
+{ 0x1, 223, 0 },
+{ 0x40, 222, 0 },
+{ 0x140, 222, 0 },
+{ 0xc0, 222, 0 },
+{ 0x20, 222, 0 },
+{ 0xa0, 222, 0 },
+{ 0x60, 222, 0 },
+{ 0x10, 222, 0 },
+{ 0x8, 222, 0 },
+{ 0x14, 222, 0 },
+{ 0x54, 222, 0 },
+{ 0x34, 222, 0 },
+{ 0xc, 222, 0 },
+{ 0x2c, 222, 0 },
+{ 0x1c, 222, 0 },
+{ 0x2, 222, 0 },
+{ 0xa, 222, 0 },
+{ 0x6, 222, 0 },
+{ 0x1, 222, 0 },
+{ 0x40, 221, 0 },
+{ 0x140, 221, 0 },
+{ 0xc0, 221, 0 },
+{ 0x20, 221, 0 },
+{ 0xa0, 221, 0 },
+{ 0x60, 221, 0 },
+{ 0x10, 221, 0 },
+{ 0x8, 221, 0 },
+{ 0x14, 221, 0 },
+{ 0x54, 221, 0 },
+{ 0x34, 221, 0 },
+{ 0xc, 221, 0 },
+{ 0x2c, 221, 0 },
+{ 0x1c, 221, 0 },
+{ 0x2, 221, 0 },
+{ 0xa, 221, 0 },
+{ 0x6, 221, 0 },
+{ 0x1, 221, 0 },
+{ 0x40, 220, 0 },
+{ 0x140, 220, 0 },
+{ 0xc0, 220, 0 },
+{ 0x20, 220, 0 },
+{ 0xa0, 220, 0 },
+{ 0x60, 220, 0 },
+{ 0x10, 220, 0 },
+{ 0x8, 220, 0 },
+{ 0x14, 220, 0 },
+{ 0x54, 220, 0 },
+{ 0x34, 220, 0 },
+{ 0xc, 220, 0 },
+{ 0x2c, 220, 0 },
+{ 0x1c, 220, 0 },
+{ 0x2, 220, 0 },
+{ 0xa, 220, 0 },
+{ 0x6, 220, 0 },
+{ 0x1, 220, 0 },
+{ 0x40, 219, 0 },
+{ 0x140, 219, 0 },
+{ 0xc0, 219, 0 },
+{ 0x20, 219, 0 },
+{ 0xa0, 219, 0 },
+{ 0x60, 219, 0 },
+{ 0x10, 219, 0 },
+{ 0x8, 219, 0 },
+{ 0x14, 219, 0 },
+{ 0x54, 219, 0 },
+{ 0x34, 219, 0 },
+{ 0xc, 219, 0 },
+{ 0x2c, 219, 0 },
+{ 0x1c, 219, 0 },
+{ 0x2, 219, 0 },
+{ 0xa, 219, 0 },
+{ 0x6, 219, 0 },
+{ 0x1, 219, 0 },
+{ 0x40, 218, 0 },
+{ 0x140, 218, 0 },
+{ 0xc0, 218, 0 },
+{ 0x20, 218, 0 },
+{ 0xa0, 218, 0 },
+{ 0x60, 218, 0 },
+{ 0x10, 218, 0 },
+{ 0x8, 218, 0 },
+{ 0x14, 218, 0 },
+{ 0x54, 218, 0 },
+{ 0x34, 218, 0 },
+{ 0xc, 218, 0 },
+{ 0x2c, 218, 0 },
+{ 0x1c, 218, 0 },
+{ 0x2, 218, 0 },
+{ 0xa, 218, 0 },
+{ 0x6, 218, 0 },
+{ 0x1, 218, 0 },
+{ 0x40, 217, 0 },
+{ 0x140, 217, 0 },
+{ 0xc0, 217, 0 },
+{ 0x20, 217, 0 },
+{ 0xa0, 217, 0 },
+{ 0x60, 217, 0 },
+{ 0x10, 217, 0 },
+{ 0x8, 217, 0 },
+{ 0x14, 217, 0 },
+{ 0x54, 217, 0 },
+{ 0x34, 217, 0 },
+{ 0xc, 217, 0 },
+{ 0x2c, 217, 0 },
+{ 0x1c, 217, 0 },
+{ 0x2, 217, 0 },
+{ 0xa, 217, 0 },
+{ 0x6, 217, 0 },
+{ 0x1, 217, 0 },
+{ 0x40, 216, 0 },
+{ 0x140, 216, 0 },
+{ 0xc0, 216, 0 },
+{ 0x20, 216, 0 },
+{ 0xa0, 216, 0 },
+{ 0x60, 216, 0 },
+{ 0x10, 216, 0 },
+{ 0x8, 216, 0 },
+{ 0x14, 216, 0 },
+{ 0x54, 216, 0 },
+{ 0x34, 216, 0 },
+{ 0xc, 216, 0 },
+{ 0x2c, 216, 0 },
+{ 0x1c, 216, 0 },
+{ 0x2, 216, 0 },
+{ 0xa, 216, 0 },
+{ 0x6, 216, 0 },
+{ 0x1, 216, 0 },
+{ 0x40, 215, 0 },
+{ 0x140, 215, 0 },
+{ 0xc0, 215, 0 },
+{ 0x20, 215, 0 },
+{ 0xa0, 215, 0 },
+{ 0x60, 215, 0 },
+{ 0x10, 215, 0 },
+{ 0x8, 215, 0 },
+{ 0x14, 215, 0 },
+{ 0x54, 215, 0 },
+{ 0x34, 215, 0 },
+{ 0xc, 215, 0 },
+{ 0x2c, 215, 0 },
+{ 0x1c, 215, 0 },
+{ 0x2, 215, 0 },
+{ 0xa, 215, 0 },
+{ 0x6, 215, 0 },
+{ 0x1, 215, 0 },
+{ 0x40, 214, 0 },
+{ 0x140, 214, 0 },
+{ 0xc0, 214, 0 },
+{ 0x20, 214, 0 },
+{ 0xa0, 214, 0 },
+{ 0x60, 214, 0 },
+{ 0x10, 214, 0 },
+{ 0x8, 214, 0 },
+{ 0x14, 214, 0 },
+{ 0x54, 214, 0 },
+{ 0x34, 214, 0 },
+{ 0xc, 214, 0 },
+{ 0x2c, 214, 0 },
+{ 0x1c, 214, 0 },
+{ 0x2, 214, 0 },
+{ 0xa, 214, 0 },
+{ 0x6, 214, 0 },
+{ 0x1, 214, 0 },
+{ 0x40, 213, 0 },
+{ 0x140, 213, 0 },
+{ 0xc0, 213, 0 },
+{ 0x20, 213, 0 },
+{ 0xa0, 213, 0 },
+{ 0x60, 213, 0 },
+{ 0x10, 213, 0 },
+{ 0x8, 213, 0 },
+{ 0x14, 213, 0 },
+{ 0x54, 213, 0 },
+{ 0x34, 213, 0 },
+{ 0xc, 213, 0 },
+{ 0x2c, 213, 0 },
+{ 0x1c, 213, 0 },
+{ 0x2, 213, 0 },
+{ 0xa, 213, 0 },
+{ 0x6, 213, 0 },
+{ 0x1, 213, 0 },
+{ 0x1, 212, 0 },
+{ 0x5, 212, 0 },
+{ 0x3, 212, 0 },
+{ 0x1, 211, 0 },
+{ 0x5, 211, 0 },
+{ 0x3, 211, 0 },
+{ 0x1, 210, 0 },
+{ 0x5, 210, 0 },
+{ 0x3, 210, 0 },
+{ 0x200, 209, 0 },
+{ 0xa00, 209, 0 },
+{ 0x600, 209, 0 },
+{ 0x100, 209, 0 },
+{ 0x500, 209, 0 },
+{ 0x300, 209, 0 },
+{ 0x80, 209, 0 },
+{ 0x40, 209, 0 },
+{ 0x20, 209, 0 },
+{ 0xa0, 209, 0 },
+{ 0x60, 209, 0 },
+{ 0x50, 209, 0 },
+{ 0x150, 209, 0 },
+{ 0xd0, 209, 0 },
+{ 0x30, 209, 0 },
+{ 0x130, 209, 0 },
+{ 0xb0, 209, 0 },
+{ 0x70, 209, 0 },
+{ 0x170, 209, 0 },
+{ 0xf0, 209, 0 },
+{ 0x8, 209, 0 },
+{ 0x28, 209, 0 },
+{ 0x18, 209, 0 },
+{ 0x4, 209, 0 },
+{ 0x14, 209, 0 },
+{ 0xc, 209, 0 },
+{ 0x2, 209, 0 },
+{ 0xa, 209, 0 },
+{ 0x6, 209, 0 },
+{ 0x1, 209, 0 },
+{ 0x200, 208, 0 },
+{ 0xa00, 208, 0 },
+{ 0x600, 208, 0 },
+{ 0x100, 208, 0 },
+{ 0x500, 208, 0 },
+{ 0x300, 208, 0 },
+{ 0x80, 208, 0 },
+{ 0x40, 208, 0 },
+{ 0x20, 208, 0 },
+{ 0xa0, 208, 0 },
+{ 0x60, 208, 0 },
+{ 0x50, 208, 0 },
+{ 0x150, 208, 0 },
+{ 0xd0, 208, 0 },
+{ 0x30, 208, 0 },
+{ 0x130, 208, 0 },
+{ 0xb0, 208, 0 },
+{ 0x70, 208, 0 },
+{ 0x170, 208, 0 },
+{ 0xf0, 208, 0 },
+{ 0x8, 208, 0 },
+{ 0x28, 208, 0 },
+{ 0x18, 208, 0 },
+{ 0x4, 208, 0 },
+{ 0x14, 208, 0 },
+{ 0xc, 208, 0 },
+{ 0x2, 208, 0 },
+{ 0xa, 208, 0 },
+{ 0x6, 208, 0 },
+{ 0x1, 208, 0 },
+{ 0x200, 207, 0 },
+{ 0xa00, 207, 0 },
+{ 0x600, 207, 0 },
+{ 0x100, 207, 0 },
+{ 0x500, 207, 0 },
+{ 0x300, 207, 0 },
+{ 0x80, 207, 0 },
+{ 0x40, 207, 0 },
+{ 0x20, 207, 0 },
+{ 0xa0, 207, 0 },
+{ 0x60, 207, 0 },
+{ 0x50, 207, 0 },
+{ 0x150, 207, 0 },
+{ 0xd0, 207, 0 },
+{ 0x30, 207, 0 },
+{ 0x130, 207, 0 },
+{ 0xb0, 207, 0 },
+{ 0x70, 207, 0 },
+{ 0x170, 207, 0 },
+{ 0xf0, 207, 0 },
+{ 0x8, 207, 0 },
+{ 0x28, 207, 0 },
+{ 0x18, 207, 0 },
+{ 0x4, 207, 0 },
+{ 0x14, 207, 0 },
+{ 0xc, 207, 0 },
+{ 0x2, 207, 0 },
+{ 0xa, 207, 0 },
+{ 0x6, 207, 0 },
+{ 0x1, 207, 0 },
+{ 0x100, 206, 0 },
+{ 0x500, 206, 0 },
+{ 0x300, 206, 0 },
+{ 0x80, 206, 0 },
+{ 0x280, 206, 0 },
+{ 0x180, 206, 0 },
+{ 0x40, 206, 0 },
+{ 0x20, 206, 0 },
+{ 0x50, 206, 0 },
+{ 0x150, 206, 0 },
+{ 0xd0, 206, 0 },
+{ 0x30, 206, 0 },
+{ 0x130, 206, 0 },
+{ 0xb0, 206, 0 },
+{ 0x70, 206, 0 },
+{ 0x170, 206, 0 },
+{ 0xf0, 206, 0 },
+{ 0x8, 206, 0 },
+{ 0x28, 206, 0 },
+{ 0x18, 206, 0 },
+{ 0x4, 206, 0 },
+{ 0x14, 206, 0 },
+{ 0xc, 206, 0 },
+{ 0x2, 206, 0 },
+{ 0xa, 206, 0 },
+{ 0x6, 206, 0 },
+{ 0x1, 206, 0 },
+{ 0x100, 205, 0 },
+{ 0x500, 205, 0 },
+{ 0x300, 205, 0 },
+{ 0x80, 205, 0 },
+{ 0x280, 205, 0 },
+{ 0x180, 205, 0 },
+{ 0x40, 205, 0 },
+{ 0x20, 205, 0 },
+{ 0x50, 205, 0 },
+{ 0x150, 205, 0 },
+{ 0xd0, 205, 0 },
+{ 0x30, 205, 0 },
+{ 0x130, 205, 0 },
+{ 0xb0, 205, 0 },
+{ 0x70, 205, 0 },
+{ 0x170, 205, 0 },
+{ 0xf0, 205, 0 },
+{ 0x8, 205, 0 },
+{ 0x28, 205, 0 },
+{ 0x18, 205, 0 },
+{ 0x4, 205, 0 },
+{ 0x14, 205, 0 },
+{ 0xc, 205, 0 },
+{ 0x2, 205, 0 },
+{ 0xa, 205, 0 },
+{ 0x6, 205, 0 },
+{ 0x1, 205, 0 },
+{ 0x100, 204, 0 },
+{ 0x500, 204, 0 },
+{ 0x300, 204, 0 },
+{ 0x80, 204, 0 },
+{ 0x280, 204, 0 },
+{ 0x180, 204, 0 },
+{ 0x40, 204, 0 },
+{ 0x20, 204, 0 },
+{ 0x50, 204, 0 },
+{ 0x150, 204, 0 },
+{ 0xd0, 204, 0 },
+{ 0x30, 204, 0 },
+{ 0x130, 204, 0 },
+{ 0xb0, 204, 0 },
+{ 0x70, 204, 0 },
+{ 0x170, 204, 0 },
+{ 0xf0, 204, 0 },
+{ 0x8, 204, 0 },
+{ 0x28, 204, 0 },
+{ 0x18, 204, 0 },
+{ 0x4, 204, 0 },
+{ 0x14, 204, 0 },
+{ 0xc, 204, 0 },
+{ 0x2, 204, 0 },
+{ 0xa, 204, 0 },
+{ 0x6, 204, 0 },
+{ 0x1, 204, 0 },
+{ 0x100, 203, 0 },
+{ 0x500, 203, 0 },
+{ 0x300, 203, 0 },
+{ 0x80, 203, 0 },
+{ 0x280, 203, 0 },
+{ 0x180, 203, 0 },
+{ 0x40, 203, 0 },
+{ 0x20, 203, 0 },
+{ 0x50, 203, 0 },
+{ 0x150, 203, 0 },
+{ 0xd0, 203, 0 },
+{ 0x30, 203, 0 },
+{ 0x130, 203, 0 },
+{ 0xb0, 203, 0 },
+{ 0x70, 203, 0 },
+{ 0x170, 203, 0 },
+{ 0xf0, 203, 0 },
+{ 0x8, 203, 0 },
+{ 0x28, 203, 0 },
+{ 0x18, 203, 0 },
+{ 0x4, 203, 0 },
+{ 0x14, 203, 0 },
+{ 0xc, 203, 0 },
+{ 0x2, 203, 0 },
+{ 0xa, 203, 0 },
+{ 0x6, 203, 0 },
+{ 0x1, 203, 0 },
+{ 0x100, 202, 0 },
+{ 0x500, 202, 0 },
+{ 0x300, 202, 0 },
+{ 0x80, 202, 0 },
+{ 0x280, 202, 0 },
+{ 0x180, 202, 0 },
+{ 0x40, 202, 0 },
+{ 0x20, 202, 0 },
+{ 0x50, 202, 0 },
+{ 0x150, 202, 0 },
+{ 0xd0, 202, 0 },
+{ 0x30, 202, 0 },
+{ 0x130, 202, 0 },
+{ 0xb0, 202, 0 },
+{ 0x70, 202, 0 },
+{ 0x170, 202, 0 },
+{ 0xf0, 202, 0 },
+{ 0x8, 202, 0 },
+{ 0x28, 202, 0 },
+{ 0x18, 202, 0 },
+{ 0x4, 202, 0 },
+{ 0x14, 202, 0 },
+{ 0xc, 202, 0 },
+{ 0x2, 202, 0 },
+{ 0xa, 202, 0 },
+{ 0x6, 202, 0 },
+{ 0x1, 202, 0 },
+{ 0x100, 201, 0 },
+{ 0x500, 201, 0 },
+{ 0x300, 201, 0 },
+{ 0x80, 201, 0 },
+{ 0x280, 201, 0 },
+{ 0x180, 201, 0 },
+{ 0x40, 201, 0 },
+{ 0x20, 201, 0 },
+{ 0x50, 201, 0 },
+{ 0x150, 201, 0 },
+{ 0xd0, 201, 0 },
+{ 0x30, 201, 0 },
+{ 0x130, 201, 0 },
+{ 0xb0, 201, 0 },
+{ 0x70, 201, 0 },
+{ 0x170, 201, 0 },
+{ 0xf0, 201, 0 },
+{ 0x8, 201, 0 },
+{ 0x28, 201, 0 },
+{ 0x18, 201, 0 },
+{ 0x4, 201, 0 },
+{ 0x14, 201, 0 },
+{ 0xc, 201, 0 },
+{ 0x2, 201, 0 },
+{ 0xa, 201, 0 },
+{ 0x6, 201, 0 },
+{ 0x1, 201, 0 },
+{ 0x100, 200, 0 },
+{ 0x500, 200, 0 },
+{ 0x300, 200, 0 },
+{ 0x80, 200, 0 },
+{ 0x280, 200, 0 },
+{ 0x180, 200, 0 },
+{ 0x40, 200, 0 },
+{ 0x20, 200, 0 },
+{ 0x50, 200, 0 },
+{ 0x150, 200, 0 },
+{ 0xd0, 200, 0 },
+{ 0x30, 200, 0 },
+{ 0x130, 200, 0 },
+{ 0xb0, 200, 0 },
+{ 0x70, 200, 0 },
+{ 0x170, 200, 0 },
+{ 0xf0, 200, 0 },
+{ 0x8, 200, 0 },
+{ 0x28, 200, 0 },
+{ 0x18, 200, 0 },
+{ 0x4, 200, 0 },
+{ 0x14, 200, 0 },
+{ 0xc, 200, 0 },
+{ 0x2, 200, 0 },
+{ 0xa, 200, 0 },
+{ 0x6, 200, 0 },
+{ 0x1, 200, 0 },
+{ 0x100, 199, 0 },
+{ 0x500, 199, 0 },
+{ 0x300, 199, 0 },
+{ 0x80, 199, 0 },
+{ 0x280, 199, 0 },
+{ 0x180, 199, 0 },
+{ 0x40, 199, 0 },
+{ 0x20, 199, 0 },
+{ 0x50, 199, 0 },
+{ 0x150, 199, 0 },
+{ 0xd0, 199, 0 },
+{ 0x30, 199, 0 },
+{ 0x130, 199, 0 },
+{ 0xb0, 199, 0 },
+{ 0x70, 199, 0 },
+{ 0x170, 199, 0 },
+{ 0xf0, 199, 0 },
+{ 0x8, 199, 0 },
+{ 0x28, 199, 0 },
+{ 0x18, 199, 0 },
+{ 0x4, 199, 0 },
+{ 0x14, 199, 0 },
+{ 0xc, 199, 0 },
+{ 0x2, 199, 0 },
+{ 0xa, 199, 0 },
+{ 0x6, 199, 0 },
+{ 0x1, 199, 0 },
+{ 0x100, 198, 0 },
+{ 0x500, 198, 0 },
+{ 0x300, 198, 0 },
+{ 0x80, 198, 0 },
+{ 0x280, 198, 0 },
+{ 0x180, 198, 0 },
+{ 0x40, 198, 0 },
+{ 0x20, 198, 0 },
+{ 0x50, 198, 0 },
+{ 0x150, 198, 0 },
+{ 0xd0, 198, 0 },
+{ 0x30, 198, 0 },
+{ 0x130, 198, 0 },
+{ 0xb0, 198, 0 },
+{ 0x70, 198, 0 },
+{ 0x170, 198, 0 },
+{ 0xf0, 198, 0 },
+{ 0x8, 198, 0 },
+{ 0x28, 198, 0 },
+{ 0x18, 198, 0 },
+{ 0x4, 198, 0 },
+{ 0x14, 198, 0 },
+{ 0xc, 198, 0 },
+{ 0x2, 198, 0 },
+{ 0xa, 198, 0 },
+{ 0x6, 198, 0 },
+{ 0x1, 198, 0 },
+{ 0x1, 197, 0 },
+{ 0x1, 196, 0 },
+{ 0x2, 195, 0 },
+{ 0x1, 195, 0 },
+{ 0x1, 194, 0 },
+{ 0x1, 193, 1 },
+{ 0x1, 392, 0 },
+{ 0x1, 192, 1 },
+{ 0x1, 390, 0 },
+{ 0x8, 191, 0 },
+{ 0x4, 191, 0 },
+{ 0x2, 191, 0 },
+{ 0x1, 191, 0 },
+{ 0x1, 190, 0 },
+{ 0x1, 189, 0 },
+{ 0x2, 188, 0 },
+{ 0x1, 188, 0 },
+{ 0x4, 187, 0 },
+{ 0x2, 187, 0 },
+{ 0x1, 187, 0 },
+{ 0x40, 186, 0 },
+{ 0x20, 186, 0 },
+{ 0x10, 186, 0 },
+{ 0x44, 186, 0 },
+{ 0x24, 186, 0 },
+{ 0x14, 186, 0 },
+{ 0xc, 186, 1 },
+{ 0x4, 186, 0 },
+{ 0x22, 186, 0 },
+{ 0x12, 186, 0 },
+{ 0xa, 186, 0 },
+{ 0x6, 186, 1 },
+{ 0x2, 186, 0 },
+{ 0x1, 186, 1 },
+{ 0x8, 186, 0 },
+{ 0x8, 184, 0 },
+{ 0x4, 184, 0 },
+{ 0x2, 184, 0 },
+{ 0x1, 184, 1 },
+{ 0x1, 185, 0 },
+{ 0x1, 183, 0 },
+{ 0x8, 181, 0 },
+{ 0x4, 181, 0 },
+{ 0x2, 181, 0 },
+{ 0x1, 181, 1 },
+{ 0x1, 182, 0 },
+{ 0x8, 179, 0 },
+{ 0x4, 179, 0 },
+{ 0x2, 179, 0 },
+{ 0x1, 179, 1 },
+{ 0x1, 180, 0 },
+{ 0x8, 177, 0 },
+{ 0x4, 177, 0 },
+{ 0x2, 177, 0 },
+{ 0x1, 177, 1 },
+{ 0x1, 178, 0 },
+{ 0x8, 175, 0 },
+{ 0x4, 175, 0 },
+{ 0x2, 175, 0 },
+{ 0x1, 175, 1 },
+{ 0x1, 176, 0 },
+{ 0x10, 174, 0 },
+{ 0x8, 174, 0 },
+{ 0x4, 174, 0 },
+{ 0x1, 174, 1 },
+{ 0x2, 174, 0 },
+{ 0x8, 172, 0 },
+{ 0x4, 172, 0 },
+{ 0x2, 172, 0 },
+{ 0x1, 172, 1 },
+{ 0x1, 173, 0 },
+{ 0x1, 171, 0 },
+{ 0x8, 168, 0 },
+{ 0x4, 168, 0 },
+{ 0x2, 168, 0 },
+{ 0x1, 168, 1 },
+{ 0x1, 169, 0 },
+{ 0x10, 167, 0 },
+{ 0x8, 167, 0 },
+{ 0x4, 167, 0 },
+{ 0x1, 167, 1 },
+{ 0x2, 167, 0 },
+{ 0x8, 165, 0 },
+{ 0x4, 165, 0 },
+{ 0x2, 165, 0 },
+{ 0x1, 165, 1 },
+{ 0x1, 166, 1 },
+{ 0x1, 273, 0 },
+{ 0x4, 164, 0 },
+{ 0x2, 164, 0 },
+{ 0x1, 164, 1 },
+{ 0x1, 170, 0 },
+{ 0x8, 162, 0 },
+{ 0x4, 162, 0 },
+{ 0x2, 162, 0 },
+{ 0x1, 162, 1 },
+{ 0x1, 163, 1 },
+{ 0x1, 274, 0 },
+{ 0x8, 160, 0 },
+{ 0x4, 160, 0 },
+{ 0x2, 160, 0 },
+{ 0x1, 160, 1 },
+{ 0x1, 161, 0 },
+{ 0x442, 158, 0 },
+{ 0x242, 158, 0 },
+{ 0x142, 158, 0 },
+{ 0xc2, 158, 1 },
+{ 0x6, 159, 1 },
+{ 0x1, 377, 0 },
+{ 0x22, 158, 0 },
+{ 0x12, 158, 0 },
+{ 0xa, 158, 0 },
+{ 0x6, 158, 1 },
+{ 0x2, 159, 1 },
+{ 0x2, 311, 0 },
+{ 0x221, 158, 0 },
+{ 0x121, 158, 0 },
+{ 0xa1, 158, 0 },
+{ 0x61, 158, 1 },
+{ 0x3, 159, 1 },
+{ 0x1, 373, 0 },
+{ 0x11, 158, 0 },
+{ 0x9, 158, 0 },
+{ 0x5, 158, 0 },
+{ 0x3, 158, 1 },
+{ 0x1, 159, 1 },
+{ 0x1, 311, 0 },
+{ 0x880, 156, 0 },
+{ 0x480, 156, 0 },
+{ 0x280, 156, 0 },
+{ 0x180, 156, 1 },
+{ 0x80, 157, 1 },
+{ 0xc, 312, 0 },
+{ 0x440, 156, 0 },
+{ 0x240, 156, 0 },
+{ 0x140, 156, 0 },
+{ 0xc0, 156, 1 },
+{ 0x40, 157, 0 },
+{ 0x220, 156, 0 },
+{ 0x120, 156, 0 },
+{ 0xa0, 156, 0 },
+{ 0x60, 156, 1 },
+{ 0x20, 157, 0 },
+{ 0x110, 156, 0 },
+{ 0x90, 156, 0 },
+{ 0x50, 156, 0 },
+{ 0x30, 156, 1 },
+{ 0x10, 157, 0 },
+{ 0x88, 156, 0 },
+{ 0x48, 156, 0 },
+{ 0x28, 156, 0 },
+{ 0x18, 156, 1 },
+{ 0x8, 157, 1 },
+{ 0x1, 329, 0 },
+{ 0x44, 156, 0 },
+{ 0x24, 156, 0 },
+{ 0x14, 156, 0 },
+{ 0xc, 156, 1 },
+{ 0x4, 157, 1 },
+{ 0x6, 312, 0 },
+{ 0x22, 156, 0 },
+{ 0x12, 156, 0 },
+{ 0xa, 156, 0 },
+{ 0x6, 156, 1 },
+{ 0x2, 157, 1 },
+{ 0x3, 312, 0 },
+{ 0x11, 156, 0 },
+{ 0x9, 156, 0 },
+{ 0x5, 156, 0 },
+{ 0x8, 154, 0 },
+{ 0x4, 154, 0 },
+{ 0x2, 154, 0 },
+{ 0x1, 154, 1 },
+{ 0x1, 155, 1 },
+{ 0x1, 275, 0 },
+{ 0x8, 152, 0 },
+{ 0x4, 152, 0 },
+{ 0x2, 152, 0 },
+{ 0x1, 152, 1 },
+{ 0x1, 153, 1 },
+{ 0x1, 276, 0 },
+{ 0x1, 151, 0 },
+{ 0x1, 150, 0 },
+{ 0x1, 149, 0 },
+{ 0x40, 147, 0 },
+{ 0x20, 147, 0 },
+{ 0x10, 147, 0 },
+{ 0x44, 147, 0 },
+{ 0x24, 147, 0 },
+{ 0x14, 147, 0 },
+{ 0xc, 147, 1 },
+{ 0x4, 147, 0 },
+{ 0x22, 147, 0 },
+{ 0x12, 147, 0 },
+{ 0xa, 147, 0 },
+{ 0x6, 147, 1 },
+{ 0x2, 147, 0 },
+{ 0x1, 147, 1 },
+{ 0x8, 147, 0 },
+{ 0x20, 145, 0 },
+{ 0x10, 145, 0 },
+{ 0x8, 145, 0 },
+{ 0x4, 145, 1 },
+{ 0x1, 146, 0 },
+{ 0x22, 145, 0 },
+{ 0x12, 145, 0 },
+{ 0xa, 145, 0 },
+{ 0x6, 145, 1 },
+{ 0x4, 146, 0 },
+{ 0x11, 145, 0 },
+{ 0x9, 145, 0 },
+{ 0x5, 145, 0 },
+{ 0x3, 145, 1 },
+{ 0x2, 146, 0 },
+{ 0x1, 144, 0 },
+{ 0x20, 141, 0 },
+{ 0x10, 141, 0 },
+{ 0x8, 141, 0 },
+{ 0x4, 141, 1 },
+{ 0x1, 142, 0 },
+{ 0x22, 141, 0 },
+{ 0x12, 141, 0 },
+{ 0xa, 141, 0 },
+{ 0x6, 141, 1 },
+{ 0x4, 142, 0 },
+{ 0x11, 141, 0 },
+{ 0x9, 141, 0 },
+{ 0x5, 141, 0 },
+{ 0x3, 141, 1 },
+{ 0x2, 142, 0 },
+{ 0x40, 140, 0 },
+{ 0x20, 140, 0 },
+{ 0x10, 140, 0 },
+{ 0x44, 140, 0 },
+{ 0x24, 140, 0 },
+{ 0x14, 140, 0 },
+{ 0xc, 140, 1 },
+{ 0x4, 140, 0 },
+{ 0x22, 140, 0 },
+{ 0x12, 140, 0 },
+{ 0xa, 140, 0 },
+{ 0x6, 140, 1 },
+{ 0x2, 140, 0 },
+{ 0x1, 140, 1 },
+{ 0x8, 140, 0 },
+{ 0x4, 139, 0 },
+{ 0x2, 139, 0 },
+{ 0x1, 139, 0 },
+{ 0x8, 137, 0 },
+{ 0x4, 137, 0 },
+{ 0x2, 137, 0 },
+{ 0x1, 137, 1 },
+{ 0x1, 138, 1 },
+{ 0x1, 366, 0 },
+{ 0x4, 136, 0 },
+{ 0x2, 136, 1 },
+{ 0x1, 242, 0 },
+{ 0x1, 136, 1 },
+{ 0x1, 143, 0 },
+{ 0x8, 134, 0 },
+{ 0x4, 134, 0 },
+{ 0x2, 134, 0 },
+{ 0x1, 134, 1 },
+{ 0x1, 135, 1 },
+{ 0x1, 367, 0 },
+{ 0x20, 132, 0 },
+{ 0x10, 132, 0 },
+{ 0x8, 132, 0 },
+{ 0x4, 132, 1 },
+{ 0x1, 133, 0 },
+{ 0x2, 132, 1 },
+{ 0xc, 133, 0 },
+{ 0x12, 132, 0 },
+{ 0xa, 132, 0 },
+{ 0x6, 132, 0 },
+{ 0x11, 132, 0 },
+{ 0x9, 132, 0 },
+{ 0x5, 132, 0 },
+{ 0x3, 132, 1 },
+{ 0x2, 133, 0 },
+{ 0x1, 131, 0 },
+{ 0x2, 130, 0 },
+{ 0xa, 130, 0 },
+{ 0x6, 130, 0 },
+{ 0x1, 130, 0 },
+{ 0x5, 130, 0 },
+{ 0x3, 130, 0 },
+{ 0x2, 129, 0 },
+{ 0xa, 129, 0 },
+{ 0x6, 129, 0 },
+{ 0x1, 129, 0 },
+{ 0x5, 129, 0 },
+{ 0x3, 129, 0 },
+{ 0x41, 128, 1 },
+{ 0x40, 148, 0 },
+{ 0x21, 128, 1 },
+{ 0x20, 148, 0 },
+{ 0x11, 128, 1 },
+{ 0x10, 148, 0 },
+{ 0x9, 128, 1 },
+{ 0x1, 128, 1 },
+{ 0x1, 148, 1 },
+{ 0x8, 148, 0 },
+{ 0x45, 128, 1 },
+{ 0x44, 148, 0 },
+{ 0x25, 128, 1 },
+{ 0x24, 148, 0 },
+{ 0x15, 128, 1 },
+{ 0x14, 148, 0 },
+{ 0xd, 128, 1 },
+{ 0x5, 128, 1 },
+{ 0xc, 148, 1 },
+{ 0x4, 148, 0 },
+{ 0x23, 128, 1 },
+{ 0x22, 148, 0 },
+{ 0x13, 128, 1 },
+{ 0x12, 148, 0 },
+{ 0xb, 128, 1 },
+{ 0xa, 148, 0 },
+{ 0x7, 128, 1 },
+{ 0x3, 128, 1 },
+{ 0x6, 148, 1 },
+{ 0x2, 148, 0 },
+{ 0x1, 127, 0 },
+{ 0x442, 125, 0 },
+{ 0x242, 125, 0 },
+{ 0x142, 125, 0 },
+{ 0xc2, 125, 1 },
+{ 0x6, 126, 0 },
+{ 0x22, 125, 0 },
+{ 0x12, 125, 0 },
+{ 0xa, 125, 0 },
+{ 0x221, 125, 0 },
+{ 0x121, 125, 0 },
+{ 0xa1, 125, 0 },
+{ 0x61, 125, 1 },
+{ 0x3, 126, 0 },
+{ 0x11, 125, 0 },
+{ 0x9, 125, 0 },
+{ 0x5, 125, 0 },
+{ 0x1108, 117, 1 },
+{ 0x1108, 121, 0 },
+{ 0x908, 117, 1 },
+{ 0x908, 121, 0 },
+{ 0x508, 117, 1 },
+{ 0x508, 121, 0 },
+{ 0x308, 117, 1 },
+{ 0x18, 118, 1 },
+{ 0x308, 121, 1 },
+{ 0x18, 122, 0 },
+{ 0x88, 117, 1 },
+{ 0x88, 121, 0 },
+{ 0x48, 117, 1 },
+{ 0x48, 121, 0 },
+{ 0x28, 117, 1 },
+{ 0x28, 121, 0 },
+{ 0x18, 117, 1 },
+{ 0x8, 118, 1 },
+{ 0x18, 121, 1 },
+{ 0x8, 122, 0 },
+{ 0x884, 117, 1 },
+{ 0x442, 119, 1 },
+{ 0x884, 121, 1 },
+{ 0x442, 123, 0 },
+{ 0x484, 117, 1 },
+{ 0x242, 119, 1 },
+{ 0x484, 121, 1 },
+{ 0x242, 123, 0 },
+{ 0x284, 117, 1 },
+{ 0x142, 119, 1 },
+{ 0x284, 121, 1 },
+{ 0x142, 123, 0 },
+{ 0x184, 117, 1 },
+{ 0xc, 118, 1 },
+{ 0xc2, 119, 1 },
+{ 0x6, 120, 1 },
+{ 0x184, 121, 1 },
+{ 0xc, 122, 1 },
+{ 0xc2, 123, 1 },
+{ 0x6, 124, 0 },
+{ 0x44, 117, 1 },
+{ 0x22, 119, 1 },
+{ 0x44, 121, 1 },
+{ 0x22, 123, 0 },
+{ 0x24, 117, 1 },
+{ 0x12, 119, 1 },
+{ 0x24, 121, 1 },
+{ 0x12, 123, 0 },
+{ 0x14, 117, 1 },
+{ 0xa, 119, 1 },
+{ 0x14, 121, 1 },
+{ 0xa, 123, 0 },
+{ 0xc, 117, 1 },
+{ 0x4, 118, 1 },
+{ 0x6, 119, 1 },
+{ 0x2, 120, 1 },
+{ 0xc, 121, 1 },
+{ 0x4, 122, 1 },
+{ 0x6, 123, 1 },
+{ 0x2, 124, 0 },
+{ 0x442, 117, 1 },
+{ 0x221, 119, 1 },
+{ 0x442, 121, 1 },
+{ 0x221, 123, 0 },
+{ 0x242, 117, 1 },
+{ 0x121, 119, 1 },
+{ 0x242, 121, 1 },
+{ 0x121, 123, 0 },
+{ 0x142, 117, 1 },
+{ 0xa1, 119, 1 },
+{ 0x142, 121, 1 },
+{ 0xa1, 123, 0 },
+{ 0xc2, 117, 1 },
+{ 0x6, 118, 1 },
+{ 0x61, 119, 1 },
+{ 0x3, 120, 1 },
+{ 0xc2, 121, 1 },
+{ 0x6, 122, 1 },
+{ 0x61, 123, 1 },
+{ 0x3, 124, 0 },
+{ 0x22, 117, 1 },
+{ 0x11, 119, 1 },
+{ 0x22, 121, 1 },
+{ 0x11, 123, 0 },
+{ 0x12, 117, 1 },
+{ 0x9, 119, 1 },
+{ 0x12, 121, 1 },
+{ 0x9, 123, 0 },
+{ 0xa, 117, 1 },
+{ 0x5, 119, 1 },
+{ 0xa, 121, 1 },
+{ 0x5, 123, 0 },
+{ 0x6, 117, 1 },
+{ 0x2, 118, 1 },
+{ 0x3, 119, 1 },
+{ 0x1, 120, 1 },
+{ 0x6, 121, 1 },
+{ 0x2, 122, 1 },
+{ 0x3, 123, 1 },
+{ 0x1, 124, 0 },
+{ 0x221, 117, 1 },
+{ 0x221, 121, 0 },
+{ 0x121, 117, 1 },
+{ 0x121, 121, 0 },
+{ 0xa1, 117, 1 },
+{ 0xa1, 121, 0 },
+{ 0x61, 117, 1 },
+{ 0x3, 118, 1 },
+{ 0x61, 121, 1 },
+{ 0x3, 122, 0 },
+{ 0x11, 117, 1 },
+{ 0x11, 121, 0 },
+{ 0x9, 117, 1 },
+{ 0x9, 121, 0 },
+{ 0x5, 117, 1 },
+{ 0x5, 121, 0 },
+{ 0x3, 117, 1 },
+{ 0x1, 118, 1 },
+{ 0x3, 121, 1 },
+{ 0x1, 122, 0 },
+{ 0x8, 115, 0 },
+{ 0x4, 115, 0 },
+{ 0x2, 115, 0 },
+{ 0x1, 115, 1 },
+{ 0x1, 116, 0 },
+{ 0x1, 113, 1 },
+{ 0x1, 114, 0 },
+{ 0x3, 113, 1 },
+{ 0x3, 114, 0 },
+{ 0x8, 111, 0 },
+{ 0x4, 111, 0 },
+{ 0x2, 111, 0 },
+{ 0x1, 111, 1 },
+{ 0x1, 112, 0 },
+{ 0x1, 110, 1 },
+{ 0x3, 156, 1 },
+{ 0x1, 157, 0 },
+{ 0x1, 109, 0 },
+{ 0x1, 108, 0 },
+{ 0x8, 106, 0 },
+{ 0x4, 106, 0 },
+{ 0x2, 106, 0 },
+{ 0x1, 106, 1 },
+{ 0x1, 107, 1 },
+{ 0x1, 368, 0 },
+{ 0x8, 104, 0 },
+{ 0x4, 104, 0 },
+{ 0x2, 104, 0 },
+{ 0x1, 104, 1 },
+{ 0x1, 105, 0 },
+{ 0x40, 103, 0 },
+{ 0x20, 103, 0 },
+{ 0x10, 103, 1 },
+{ 0x2, 293, 0 },
+{ 0x44, 103, 0 },
+{ 0x24, 103, 0 },
+{ 0x14, 103, 0 },
+{ 0xc, 103, 1 },
+{ 0x4, 103, 0 },
+{ 0x22, 103, 0 },
+{ 0x12, 103, 0 },
+{ 0xa, 103, 0 },
+{ 0x6, 103, 1 },
+{ 0x2, 103, 0 },
+{ 0x1, 103, 1 },
+{ 0x8, 103, 0 },
+{ 0x1, 102, 0 },
+{ 0x2, 101, 1 },
+{ 0x2, 339, 0 },
+{ 0x1, 101, 1 },
+{ 0x1, 339, 0 },
+{ 0x1, 100, 0 },
+{ 0x1, 99, 0 },
+{ 0x1, 98, 0 },
+{ 0x1, 97, 1 },
+{ 0x1, 335, 0 },
+{ 0x1, 96, 0 },
+{ 0x2, 95, 0 },
+{ 0x1, 95, 1 },
+{ 0x6, 125, 1 },
+{ 0x2, 126, 0 },
+{ 0x2, 94, 0 },
+{ 0x1, 94, 1 },
+{ 0x3, 125, 1 },
+{ 0x1, 126, 0 },
+{ 0x1, 93, 0 },
+{ 0x2, 92, 0 },
+{ 0xa, 92, 0 },
+{ 0x6, 92, 0 },
+{ 0x1, 92, 0 },
+{ 0x5, 92, 0 },
+{ 0x3, 92, 0 },
+{ 0x2, 91, 0 },
+{ 0xa, 91, 0 },
+{ 0x6, 91, 0 },
+{ 0x1, 91, 0 },
+{ 0x5, 91, 0 },
+{ 0x3, 91, 0 },
+{ 0x2, 90, 0 },
+{ 0xa, 90, 0 },
+{ 0x6, 90, 0 },
+{ 0x1, 90, 0 },
+{ 0x5, 90, 0 },
+{ 0x3, 90, 0 },
+{ 0x2, 89, 0 },
+{ 0xa, 89, 0 },
+{ 0x6, 89, 0 },
+{ 0x1, 89, 0 },
+{ 0x5, 89, 0 },
+{ 0x3, 89, 0 },
+{ 0x34, 77, 1 },
+{ 0x7, 88, 0 },
+{ 0xc, 77, 1 },
+{ 0x3, 81, 0 },
+{ 0x2, 77, 1 },
+{ 0x1, 78, 1 },
+{ 0x1, 79, 1 },
+{ 0x1, 80, 0 },
+{ 0x6, 77, 1 },
+{ 0x3, 78, 1 },
+{ 0x3, 79, 1 },
+{ 0x3, 80, 0 },
+{ 0x1, 77, 1 },
+{ 0x2, 80, 0 },
+{ 0x9, 77, 1 },
+{ 0x6, 80, 0 },
+{ 0xd, 77, 1 },
+{ 0xe, 88, 0 },
+{ 0x3, 77, 1 },
+{ 0x6, 81, 0 },
+{ 0x28, 75, 1 },
+{ 0x5, 76, 0 },
+{ 0x68, 75, 1 },
+{ 0x7, 87, 0 },
+{ 0x18, 75, 1 },
+{ 0x3, 76, 0 },
+{ 0x14, 75, 1 },
+{ 0xa, 76, 0 },
+{ 0x34, 75, 1 },
+{ 0xe, 87, 0 },
+{ 0xc, 75, 1 },
+{ 0x6, 76, 0 },
+{ 0xa, 75, 1 },
+{ 0x14, 76, 0 },
+{ 0x1a, 75, 1 },
+{ 0x1c, 87, 0 },
+{ 0x6, 75, 1 },
+{ 0xc, 76, 0 },
+{ 0x5, 75, 1 },
+{ 0x28, 76, 0 },
+{ 0xd, 75, 1 },
+{ 0x38, 87, 0 },
+{ 0x3, 75, 1 },
+{ 0x18, 76, 0 },
+{ 0x28, 70, 1 },
+{ 0x5, 74, 0 },
+{ 0x68, 70, 1 },
+{ 0x7, 86, 0 },
+{ 0x18, 70, 1 },
+{ 0x3, 74, 0 },
+{ 0x4, 70, 1 },
+{ 0x2, 71, 1 },
+{ 0x2, 72, 1 },
+{ 0x2, 73, 0 },
+{ 0xc, 70, 1 },
+{ 0x6, 71, 1 },
+{ 0x6, 72, 1 },
+{ 0x6, 73, 0 },
+{ 0x2, 70, 1 },
+{ 0x1, 71, 1 },
+{ 0x1, 72, 1 },
+{ 0x1, 73, 0 },
+{ 0x6, 70, 1 },
+{ 0x3, 71, 1 },
+{ 0x3, 72, 1 },
+{ 0x3, 73, 0 },
+{ 0x1, 70, 1 },
+{ 0x4, 73, 0 },
+{ 0x9, 70, 1 },
+{ 0xc, 73, 0 },
+{ 0x5, 70, 1 },
+{ 0xa, 74, 0 },
+{ 0xd, 70, 1 },
+{ 0xe, 86, 0 },
+{ 0x3, 70, 1 },
+{ 0x6, 74, 0 },
+{ 0x68, 60, 1 },
+{ 0x7, 69, 0 },
+{ 0x18, 60, 1 },
+{ 0x3, 64, 0 },
+{ 0x2, 60, 1 },
+{ 0x1, 61, 1 },
+{ 0x1, 62, 1 },
+{ 0x1, 63, 0 },
+{ 0x6, 60, 1 },
+{ 0x3, 61, 1 },
+{ 0x3, 62, 1 },
+{ 0x3, 63, 0 },
+{ 0x1, 60, 1 },
+{ 0x4, 63, 0 },
+{ 0x9, 60, 1 },
+{ 0xc, 63, 0 },
+{ 0xd, 60, 1 },
+{ 0xe, 69, 0 },
+{ 0x3, 60, 1 },
+{ 0x6, 64, 0 },
+{ 0x28, 58, 1 },
+{ 0x5, 59, 0 },
+{ 0x68, 58, 1 },
+{ 0x7, 68, 0 },
+{ 0x18, 58, 1 },
+{ 0x3, 59, 0 },
+{ 0x14, 58, 1 },
+{ 0xa, 59, 0 },
+{ 0x34, 58, 1 },
+{ 0xe, 68, 0 },
+{ 0xc, 58, 1 },
+{ 0x6, 59, 0 },
+{ 0xa, 58, 1 },
+{ 0x14, 59, 0 },
+{ 0x1a, 58, 1 },
+{ 0x1c, 68, 0 },
+{ 0x6, 58, 1 },
+{ 0xc, 59, 0 },
+{ 0x5, 58, 1 },
+{ 0x28, 59, 0 },
+{ 0xd, 58, 1 },
+{ 0x38, 68, 0 },
+{ 0x3, 58, 1 },
+{ 0x18, 59, 0 },
+{ 0x28, 53, 1 },
+{ 0x5, 57, 0 },
+{ 0x68, 53, 1 },
+{ 0x7, 67, 0 },
+{ 0x18, 53, 1 },
+{ 0x3, 57, 0 },
+{ 0x4, 53, 1 },
+{ 0x2, 54, 1 },
+{ 0x2, 55, 1 },
+{ 0x2, 56, 0 },
+{ 0xc, 53, 1 },
+{ 0x6, 54, 1 },
+{ 0x6, 55, 1 },
+{ 0x6, 56, 0 },
+{ 0x2, 53, 1 },
+{ 0x1, 54, 1 },
+{ 0x1, 55, 1 },
+{ 0x1, 56, 0 },
+{ 0x6, 53, 1 },
+{ 0x3, 54, 1 },
+{ 0x3, 55, 1 },
+{ 0x3, 56, 0 },
+{ 0x1, 53, 1 },
+{ 0x4, 56, 0 },
+{ 0x9, 53, 1 },
+{ 0xc, 56, 0 },
+{ 0x5, 53, 1 },
+{ 0xa, 57, 0 },
+{ 0xd, 53, 1 },
+{ 0xe, 67, 0 },
+{ 0x3, 53, 1 },
+{ 0x6, 57, 0 },
+{ 0x2, 52, 0 },
+{ 0x1, 52, 0 },
+{ 0x1, 50, 0 },
+{ 0x3, 49, 0 },
+{ 0x5, 48, 0 },
+{ 0x3, 48, 0 },
+{ 0x5, 47, 0 },
+{ 0x3, 47, 0 },
+{ 0x3, 46, 0 },
+{ 0x2, 45, 0 },
+{ 0x1, 45, 0 },
+{ 0x8, 43, 1 },
+{ 0x38, 44, 1 },
+{ 0xe8, 44, 0 },
+{ 0x1248, 43, 0 },
+{ 0x3248, 43, 0 },
+{ 0xa48, 43, 0 },
+{ 0x1a48, 43, 0 },
+{ 0x648, 43, 0 },
+{ 0xe48, 43, 0 },
+{ 0x948, 43, 0 },
+{ 0x1948, 43, 0 },
+{ 0x548, 43, 0 },
+{ 0xd48, 43, 0 },
+{ 0x348, 43, 0 },
+{ 0x748, 43, 0 },
+{ 0x2c8, 43, 0 },
+{ 0x6c8, 43, 0 },
+{ 0x1c8, 43, 0 },
+{ 0x3c8, 43, 0 },
+{ 0x28, 43, 1 },
+{ 0x78, 44, 1 },
+{ 0x1e8, 44, 0 },
+{ 0x498, 43, 1 },
+{ 0x488, 44, 0 },
+{ 0xc98, 43, 1 },
+{ 0xc88, 44, 0 },
+{ 0x298, 43, 1 },
+{ 0x288, 44, 0 },
+{ 0x698, 43, 1 },
+{ 0x688, 44, 0 },
+{ 0x198, 43, 1 },
+{ 0x188, 44, 0 },
+{ 0x398, 43, 1 },
+{ 0x388, 44, 0 },
+{ 0x258, 43, 1 },
+{ 0x248, 44, 0 },
+{ 0x658, 43, 1 },
+{ 0x648, 44, 0 },
+{ 0x158, 43, 1 },
+{ 0x148, 44, 0 },
+{ 0x358, 43, 1 },
+{ 0x348, 44, 0 },
+{ 0xd8, 43, 1 },
+{ 0xc8, 44, 0 },
+{ 0x1d8, 43, 1 },
+{ 0x1c8, 44, 0 },
+{ 0x78, 43, 1 },
+{ 0x58, 44, 0 },
+{ 0xf8, 43, 1 },
+{ 0xd8, 44, 0 },
+{ 0x4, 43, 1 },
+{ 0x1c, 44, 1 },
+{ 0x74, 44, 0 },
+{ 0x924, 43, 0 },
+{ 0x1924, 43, 0 },
+{ 0x524, 43, 0 },
+{ 0xd24, 43, 0 },
+{ 0x324, 43, 0 },
+{ 0x724, 43, 0 },
+{ 0x4a4, 43, 0 },
+{ 0xca4, 43, 0 },
+{ 0x2a4, 43, 0 },
+{ 0x6a4, 43, 0 },
+{ 0x1a4, 43, 0 },
+{ 0x3a4, 43, 0 },
+{ 0x164, 43, 0 },
+{ 0x364, 43, 0 },
+{ 0xe4, 43, 0 },
+{ 0x1e4, 43, 0 },
+{ 0x14, 43, 1 },
+{ 0x3c, 44, 1 },
+{ 0xf4, 44, 0 },
+{ 0x24c, 43, 1 },
+{ 0x244, 44, 0 },
+{ 0x64c, 43, 1 },
+{ 0x644, 44, 0 },
+{ 0x14c, 43, 1 },
+{ 0x144, 44, 0 },
+{ 0x34c, 43, 1 },
+{ 0x344, 44, 0 },
+{ 0xcc, 43, 1 },
+{ 0xc4, 44, 0 },
+{ 0x1cc, 43, 1 },
+{ 0x1c4, 44, 0 },
+{ 0x12c, 43, 1 },
+{ 0x124, 44, 0 },
+{ 0x32c, 43, 1 },
+{ 0x324, 44, 0 },
+{ 0xac, 43, 1 },
+{ 0xa4, 44, 0 },
+{ 0x1ac, 43, 1 },
+{ 0x1a4, 44, 0 },
+{ 0x6c, 43, 1 },
+{ 0x64, 44, 0 },
+{ 0xec, 43, 1 },
+{ 0xe4, 44, 0 },
+{ 0x3c, 43, 1 },
+{ 0x2c, 44, 0 },
+{ 0x7c, 43, 1 },
+{ 0x6c, 44, 0 },
+{ 0x2, 43, 1 },
+{ 0xe, 44, 1 },
+{ 0x3a, 44, 0 },
+{ 0x492, 43, 0 },
+{ 0xc92, 43, 0 },
+{ 0x292, 43, 0 },
+{ 0x692, 43, 0 },
+{ 0x192, 43, 0 },
+{ 0x392, 43, 0 },
+{ 0x252, 43, 0 },
+{ 0x652, 43, 0 },
+{ 0x152, 43, 0 },
+{ 0x352, 43, 0 },
+{ 0xd2, 43, 0 },
+{ 0x1d2, 43, 0 },
+{ 0xb2, 43, 0 },
+{ 0x1b2, 43, 0 },
+{ 0x72, 43, 0 },
+{ 0xf2, 43, 0 },
+{ 0xa, 43, 1 },
+{ 0x1e, 44, 1 },
+{ 0x7a, 44, 0 },
+{ 0x126, 43, 1 },
+{ 0x122, 44, 0 },
+{ 0x326, 43, 1 },
+{ 0x322, 44, 0 },
+{ 0xa6, 43, 1 },
+{ 0xa2, 44, 0 },
+{ 0x1a6, 43, 1 },
+{ 0x1a2, 44, 0 },
+{ 0x66, 43, 1 },
+{ 0x62, 44, 0 },
+{ 0xe6, 43, 1 },
+{ 0xe2, 44, 0 },
+{ 0x96, 43, 1 },
+{ 0x92, 44, 0 },
+{ 0x196, 43, 1 },
+{ 0x192, 44, 0 },
+{ 0x56, 43, 1 },
+{ 0x52, 44, 0 },
+{ 0xd6, 43, 1 },
+{ 0xd2, 44, 0 },
+{ 0x36, 43, 1 },
+{ 0x32, 44, 0 },
+{ 0x76, 43, 1 },
+{ 0x72, 44, 0 },
+{ 0x1e, 43, 1 },
+{ 0x16, 44, 0 },
+{ 0x3e, 43, 1 },
+{ 0x36, 44, 0 },
+{ 0x1, 43, 1 },
+{ 0x7, 44, 1 },
+{ 0x1d, 44, 0 },
+{ 0x249, 43, 0 },
+{ 0x649, 43, 0 },
+{ 0x149, 43, 0 },
+{ 0x349, 43, 0 },
+{ 0xc9, 43, 0 },
+{ 0x1c9, 43, 0 },
+{ 0x129, 43, 0 },
+{ 0x329, 43, 0 },
+{ 0xa9, 43, 0 },
+{ 0x1a9, 43, 0 },
+{ 0x69, 43, 0 },
+{ 0xe9, 43, 0 },
+{ 0x59, 43, 0 },
+{ 0xd9, 43, 0 },
+{ 0x39, 43, 0 },
+{ 0x79, 43, 0 },
+{ 0x5, 43, 1 },
+{ 0xf, 44, 1 },
+{ 0x3d, 44, 0 },
+{ 0x93, 43, 1 },
+{ 0x91, 44, 0 },
+{ 0x193, 43, 1 },
+{ 0x191, 44, 0 },
+{ 0x53, 43, 1 },
+{ 0x51, 44, 0 },
+{ 0xd3, 43, 1 },
+{ 0xd1, 44, 0 },
+{ 0x33, 43, 1 },
+{ 0x31, 44, 0 },
+{ 0x73, 43, 1 },
+{ 0x71, 44, 0 },
+{ 0x4b, 43, 1 },
+{ 0x49, 44, 0 },
+{ 0xcb, 43, 1 },
+{ 0xc9, 44, 0 },
+{ 0x2b, 43, 1 },
+{ 0x29, 44, 0 },
+{ 0x6b, 43, 1 },
+{ 0x69, 44, 0 },
+{ 0x1b, 43, 1 },
+{ 0x19, 44, 0 },
+{ 0x3b, 43, 1 },
+{ 0x39, 44, 0 },
+{ 0xf, 43, 1 },
+{ 0xb, 44, 0 },
+{ 0x1f, 43, 1 },
+{ 0x1b, 44, 0 },
+{ 0x4, 41, 1 },
+{ 0x1c, 42, 1 },
+{ 0x74, 42, 0 },
+{ 0x924, 41, 0 },
+{ 0x1924, 41, 0 },
+{ 0x524, 41, 0 },
+{ 0xd24, 41, 0 },
+{ 0x324, 41, 0 },
+{ 0x724, 41, 0 },
+{ 0x4a4, 41, 0 },
+{ 0xca4, 41, 0 },
+{ 0x2a4, 41, 0 },
+{ 0x6a4, 41, 0 },
+{ 0x1a4, 41, 0 },
+{ 0x3a4, 41, 0 },
+{ 0x164, 41, 0 },
+{ 0x364, 41, 0 },
+{ 0xe4, 41, 0 },
+{ 0x1e4, 41, 0 },
+{ 0x14, 41, 1 },
+{ 0x3c, 42, 1 },
+{ 0xf4, 42, 0 },
+{ 0x24c, 41, 1 },
+{ 0x244, 42, 0 },
+{ 0x64c, 41, 1 },
+{ 0x644, 42, 0 },
+{ 0x14c, 41, 1 },
+{ 0x144, 42, 0 },
+{ 0x34c, 41, 1 },
+{ 0x344, 42, 0 },
+{ 0xcc, 41, 1 },
+{ 0xc4, 42, 0 },
+{ 0x1cc, 41, 1 },
+{ 0x1c4, 42, 0 },
+{ 0x12c, 41, 1 },
+{ 0x124, 42, 0 },
+{ 0x32c, 41, 1 },
+{ 0x324, 42, 0 },
+{ 0xac, 41, 1 },
+{ 0xa4, 42, 0 },
+{ 0x1ac, 41, 1 },
+{ 0x1a4, 42, 0 },
+{ 0x6c, 41, 1 },
+{ 0x64, 42, 0 },
+{ 0xec, 41, 1 },
+{ 0xe4, 42, 0 },
+{ 0x3c, 41, 1 },
+{ 0x2c, 42, 0 },
+{ 0x7c, 41, 1 },
+{ 0x6c, 42, 0 },
+{ 0xa, 41, 1 },
+{ 0x3a, 42, 1 },
+{ 0xea, 42, 0 },
+{ 0x124a, 41, 0 },
+{ 0x324a, 41, 0 },
+{ 0xa4a, 41, 0 },
+{ 0x1a4a, 41, 0 },
+{ 0x64a, 41, 0 },
+{ 0xe4a, 41, 0 },
+{ 0x94a, 41, 0 },
+{ 0x194a, 41, 0 },
+{ 0x54a, 41, 0 },
+{ 0xd4a, 41, 0 },
+{ 0x34a, 41, 0 },
+{ 0x74a, 41, 0 },
+{ 0x2ca, 41, 0 },
+{ 0x6ca, 41, 0 },
+{ 0x1ca, 41, 0 },
+{ 0x3ca, 41, 0 },
+{ 0x2a, 41, 1 },
+{ 0x7a, 42, 1 },
+{ 0x1ea, 42, 0 },
+{ 0x49a, 41, 1 },
+{ 0x48a, 42, 0 },
+{ 0xc9a, 41, 1 },
+{ 0xc8a, 42, 0 },
+{ 0x29a, 41, 1 },
+{ 0x28a, 42, 0 },
+{ 0x69a, 41, 1 },
+{ 0x68a, 42, 0 },
+{ 0x19a, 41, 1 },
+{ 0x18a, 42, 0 },
+{ 0x39a, 41, 1 },
+{ 0x38a, 42, 0 },
+{ 0x25a, 41, 1 },
+{ 0x24a, 42, 0 },
+{ 0x65a, 41, 1 },
+{ 0x64a, 42, 0 },
+{ 0x15a, 41, 1 },
+{ 0x14a, 42, 0 },
+{ 0x35a, 41, 1 },
+{ 0x34a, 42, 0 },
+{ 0xda, 41, 1 },
+{ 0xca, 42, 0 },
+{ 0x1da, 41, 1 },
+{ 0x1ca, 42, 0 },
+{ 0x7a, 41, 1 },
+{ 0x5a, 42, 0 },
+{ 0xfa, 41, 1 },
+{ 0xda, 42, 0 },
+{ 0x6, 41, 1 },
+{ 0x1e, 42, 1 },
+{ 0x76, 42, 0 },
+{ 0x926, 41, 0 },
+{ 0x1926, 41, 0 },
+{ 0x526, 41, 0 },
+{ 0xd26, 41, 0 },
+{ 0x326, 41, 0 },
+{ 0x726, 41, 0 },
+{ 0x4a6, 41, 0 },
+{ 0xca6, 41, 0 },
+{ 0x2a6, 41, 0 },
+{ 0x6a6, 41, 0 },
+{ 0x1a6, 41, 0 },
+{ 0x3a6, 41, 0 },
+{ 0x166, 41, 0 },
+{ 0x366, 41, 0 },
+{ 0xe6, 41, 0 },
+{ 0x1e6, 41, 0 },
+{ 0x16, 41, 1 },
+{ 0x3e, 42, 1 },
+{ 0xf6, 42, 0 },
+{ 0x24e, 41, 1 },
+{ 0x246, 42, 0 },
+{ 0x64e, 41, 1 },
+{ 0x646, 42, 0 },
+{ 0x14e, 41, 1 },
+{ 0x146, 42, 0 },
+{ 0x34e, 41, 1 },
+{ 0x346, 42, 0 },
+{ 0xce, 41, 1 },
+{ 0xc6, 42, 0 },
+{ 0x1ce, 41, 1 },
+{ 0x1c6, 42, 0 },
+{ 0x12e, 41, 1 },
+{ 0x126, 42, 0 },
+{ 0x32e, 41, 1 },
+{ 0x326, 42, 0 },
+{ 0xae, 41, 1 },
+{ 0xa6, 42, 0 },
+{ 0x1ae, 41, 1 },
+{ 0x1a6, 42, 0 },
+{ 0x6e, 41, 1 },
+{ 0x66, 42, 0 },
+{ 0xee, 41, 1 },
+{ 0xe6, 42, 0 },
+{ 0x3e, 41, 1 },
+{ 0x2e, 42, 0 },
+{ 0x7e, 41, 1 },
+{ 0x6e, 42, 0 },
+{ 0x1, 41, 1 },
+{ 0x7, 42, 1 },
+{ 0x1d, 42, 0 },
+{ 0x249, 41, 0 },
+{ 0x649, 41, 0 },
+{ 0x149, 41, 0 },
+{ 0x349, 41, 0 },
+{ 0xc9, 41, 0 },
+{ 0x1c9, 41, 0 },
+{ 0x129, 41, 0 },
+{ 0x329, 41, 0 },
+{ 0xa9, 41, 0 },
+{ 0x1a9, 41, 0 },
+{ 0x69, 41, 0 },
+{ 0xe9, 41, 0 },
+{ 0x59, 41, 0 },
+{ 0xd9, 41, 0 },
+{ 0x39, 41, 0 },
+{ 0x79, 41, 0 },
+{ 0x5, 41, 1 },
+{ 0xf, 42, 1 },
+{ 0x3d, 42, 0 },
+{ 0x93, 41, 1 },
+{ 0x91, 42, 0 },
+{ 0x193, 41, 1 },
+{ 0x191, 42, 0 },
+{ 0x53, 41, 1 },
+{ 0x51, 42, 0 },
+{ 0xd3, 41, 1 },
+{ 0xd1, 42, 0 },
+{ 0x33, 41, 1 },
+{ 0x31, 42, 0 },
+{ 0x73, 41, 1 },
+{ 0x71, 42, 0 },
+{ 0x4b, 41, 1 },
+{ 0x49, 42, 0 },
+{ 0xcb, 41, 1 },
+{ 0xc9, 42, 0 },
+{ 0x2b, 41, 1 },
+{ 0x29, 42, 0 },
+{ 0x6b, 41, 1 },
+{ 0x69, 42, 0 },
+{ 0x1b, 41, 1 },
+{ 0x19, 42, 0 },
+{ 0x3b, 41, 1 },
+{ 0x39, 42, 0 },
+{ 0xf, 41, 1 },
+{ 0xb, 42, 0 },
+{ 0x1f, 41, 1 },
+{ 0x1b, 42, 0 },
+{ 0x51, 39, 0 },
+{ 0xd1, 39, 1 },
+{ 0xc, 60, 1 },
+{ 0x6, 63, 1 },
+{ 0x3, 65, 1 },
+{ 0x3, 66, 0 },
+{ 0x31, 39, 1 },
+{ 0x11, 40, 0 },
+{ 0x71, 39, 1 },
+{ 0x31, 40, 1 },
+{ 0x4, 60, 1 },
+{ 0x2, 63, 1 },
+{ 0x1, 65, 1 },
+{ 0x1, 66, 0 },
+{ 0x29, 39, 0 },
+{ 0x69, 39, 1 },
+{ 0x28, 60, 1 },
+{ 0x5, 64, 0 },
+{ 0x19, 39, 1 },
+{ 0x9, 40, 0 },
+{ 0x39, 39, 1 },
+{ 0x19, 40, 1 },
+{ 0x5, 60, 1 },
+{ 0xa, 64, 0 },
+{ 0x15, 39, 0 },
+{ 0x35, 39, 1 },
+{ 0x3, 82, 1 },
+{ 0x3, 83, 1 },
+{ 0x3, 84, 1 },
+{ 0x3, 85, 0 },
+{ 0xd, 39, 1 },
+{ 0x5, 40, 0 },
+{ 0x1d, 39, 1 },
+{ 0xd, 40, 1 },
+{ 0x1, 82, 1 },
+{ 0x1, 83, 1 },
+{ 0x1, 84, 1 },
+{ 0x1, 85, 0 },
+{ 0xb, 39, 0 },
+{ 0x1b, 39, 1 },
+{ 0x14, 77, 1 },
+{ 0x5, 81, 0 },
+{ 0x7, 39, 1 },
+{ 0x3, 40, 0 },
+{ 0xf, 39, 1 },
+{ 0x7, 40, 1 },
+{ 0x5, 77, 1 },
+{ 0xa, 81, 0 },
+{ 0x51, 37, 1 },
+{ 0x50, 37, 0 },
+{ 0xd1, 37, 1 },
+{ 0xd0, 37, 0 },
+{ 0x31, 37, 1 },
+{ 0x30, 37, 1 },
+{ 0x11, 38, 1 },
+{ 0x10, 38, 0 },
+{ 0x71, 37, 1 },
+{ 0x70, 37, 1 },
+{ 0x31, 38, 1 },
+{ 0x30, 38, 0 },
+{ 0x29, 37, 1 },
+{ 0x28, 37, 0 },
+{ 0x69, 37, 1 },
+{ 0x68, 37, 0 },
+{ 0x19, 37, 1 },
+{ 0x18, 37, 1 },
+{ 0x9, 38, 1 },
+{ 0x8, 38, 0 },
+{ 0x39, 37, 1 },
+{ 0x38, 37, 1 },
+{ 0x19, 38, 1 },
+{ 0x18, 38, 0 },
+{ 0x15, 37, 1 },
+{ 0x14, 37, 0 },
+{ 0x35, 37, 1 },
+{ 0x34, 37, 0 },
+{ 0xd, 37, 1 },
+{ 0xc, 37, 1 },
+{ 0x5, 38, 1 },
+{ 0x4, 38, 0 },
+{ 0x1d, 37, 1 },
+{ 0x1c, 37, 1 },
+{ 0xd, 38, 1 },
+{ 0xc, 38, 0 },
+{ 0xb, 37, 1 },
+{ 0xa, 37, 0 },
+{ 0x1b, 37, 1 },
+{ 0x1a, 37, 0 },
+{ 0x7, 37, 1 },
+{ 0x6, 37, 1 },
+{ 0x3, 38, 1 },
+{ 0x2, 38, 0 },
+{ 0xf, 37, 1 },
+{ 0xe, 37, 1 },
+{ 0x7, 38, 1 },
+{ 0x6, 38, 0 },
+{ 0x8, 36, 0 },
+{ 0x18, 36, 0 },
+{ 0x2, 36, 1 },
+{ 0xc, 36, 0 },
+{ 0x1, 36, 1 },
+{ 0x4, 36, 0 },
+{ 0x1, 32, 1 },
+{ 0x1, 33, 1 },
+{ 0x1, 34, 0 },
+{ 0x1, 31, 0 },
+{ 0x1, 30, 0 },
+{ 0x51, 28, 0 },
+{ 0xd1, 28, 0 },
+{ 0x31, 28, 1 },
+{ 0x11, 29, 0 },
+{ 0x71, 28, 1 },
+{ 0x31, 29, 0 },
+{ 0x29, 28, 0 },
+{ 0x69, 28, 0 },
+{ 0x19, 28, 1 },
+{ 0x9, 29, 0 },
+{ 0x39, 28, 1 },
+{ 0x19, 29, 0 },
+{ 0x15, 28, 0 },
+{ 0x35, 28, 0 },
+{ 0xd, 28, 1 },
+{ 0x5, 29, 0 },
+{ 0x1d, 28, 1 },
+{ 0xd, 29, 0 },
+{ 0xb, 28, 0 },
+{ 0x1b, 28, 0 },
+{ 0x7, 28, 1 },
+{ 0x3, 29, 0 },
+{ 0xf, 28, 1 },
+{ 0x7, 29, 0 },
+{ 0xa2, 26, 0 },
+{ 0x1a2, 26, 0 },
+{ 0x62, 26, 1 },
+{ 0x22, 27, 0 },
+{ 0xe2, 26, 1 },
+{ 0x62, 27, 0 },
+{ 0x52, 26, 0 },
+{ 0xd2, 26, 0 },
+{ 0x32, 26, 1 },
+{ 0x12, 27, 0 },
+{ 0x72, 26, 1 },
+{ 0x32, 27, 0 },
+{ 0x2a, 26, 0 },
+{ 0x6a, 26, 0 },
+{ 0x1a, 26, 1 },
+{ 0xa, 27, 0 },
+{ 0x3a, 26, 1 },
+{ 0x1a, 27, 0 },
+{ 0x16, 26, 0 },
+{ 0x36, 26, 0 },
+{ 0xe, 26, 1 },
+{ 0x6, 27, 0 },
+{ 0x1e, 26, 1 },
+{ 0xe, 27, 0 },
+{ 0x51, 26, 0 },
+{ 0xd1, 26, 0 },
+{ 0x31, 26, 1 },
+{ 0x11, 27, 0 },
+{ 0x71, 26, 1 },
+{ 0x31, 27, 0 },
+{ 0x29, 26, 0 },
+{ 0x69, 26, 0 },
+{ 0x19, 26, 1 },
+{ 0x9, 27, 0 },
+{ 0x39, 26, 1 },
+{ 0x19, 27, 0 },
+{ 0x15, 26, 0 },
+{ 0x35, 26, 0 },
+{ 0xd, 26, 1 },
+{ 0x5, 27, 0 },
+{ 0x1d, 26, 1 },
+{ 0xd, 27, 0 },
+{ 0xb, 26, 0 },
+{ 0x1b, 26, 0 },
+{ 0x7, 26, 1 },
+{ 0x3, 27, 0 },
+{ 0xf, 26, 1 },
+{ 0x7, 27, 0 },
+{ 0x51, 24, 0 },
+{ 0xd1, 24, 0 },
+{ 0x31, 24, 1 },
+{ 0x11, 25, 0 },
+{ 0x71, 24, 1 },
+{ 0x31, 25, 0 },
+{ 0x29, 24, 0 },
+{ 0x69, 24, 0 },
+{ 0x19, 24, 1 },
+{ 0x9, 25, 0 },
+{ 0x39, 24, 1 },
+{ 0x19, 25, 0 },
+{ 0x15, 24, 0 },
+{ 0x35, 24, 0 },
+{ 0xd, 24, 1 },
+{ 0x5, 25, 0 },
+{ 0x1d, 24, 1 },
+{ 0xd, 25, 0 },
+{ 0xb, 24, 0 },
+{ 0x1b, 24, 0 },
+{ 0x7, 24, 1 },
+{ 0x3, 25, 0 },
+{ 0xf, 24, 1 },
+{ 0x7, 25, 0 },
+{ 0xa2, 22, 0 },
+{ 0x1a2, 22, 0 },
+{ 0x62, 22, 1 },
+{ 0x22, 23, 0 },
+{ 0xe2, 22, 1 },
+{ 0x62, 23, 0 },
+{ 0x52, 22, 0 },
+{ 0xd2, 22, 0 },
+{ 0x32, 22, 1 },
+{ 0x12, 23, 0 },
+{ 0x72, 22, 1 },
+{ 0x32, 23, 0 },
+{ 0x2a, 22, 0 },
+{ 0x6a, 22, 0 },
+{ 0x1a, 22, 1 },
+{ 0xa, 23, 0 },
+{ 0x3a, 22, 1 },
+{ 0x1a, 23, 0 },
+{ 0x16, 22, 0 },
+{ 0x36, 22, 0 },
+{ 0xe, 22, 1 },
+{ 0x6, 23, 0 },
+{ 0x1e, 22, 1 },
+{ 0xe, 23, 0 },
+{ 0x51, 22, 0 },
+{ 0xd1, 22, 0 },
+{ 0x31, 22, 1 },
+{ 0x11, 23, 0 },
+{ 0x71, 22, 1 },
+{ 0x31, 23, 0 },
+{ 0x29, 22, 0 },
+{ 0x69, 22, 0 },
+{ 0x19, 22, 1 },
+{ 0x9, 23, 0 },
+{ 0x39, 22, 1 },
+{ 0x19, 23, 0 },
+{ 0x15, 22, 0 },
+{ 0x35, 22, 0 },
+{ 0xd, 22, 1 },
+{ 0x5, 23, 0 },
+{ 0x1d, 22, 1 },
+{ 0xd, 23, 0 },
+{ 0xb, 22, 0 },
+{ 0x1b, 22, 0 },
+{ 0x7, 22, 1 },
+{ 0x3, 23, 0 },
+{ 0xf, 22, 1 },
+{ 0x7, 23, 0 },
+{ 0x51, 20, 1 },
+{ 0x50, 20, 0 },
+{ 0xd1, 20, 1 },
+{ 0xd0, 20, 0 },
+{ 0x31, 20, 1 },
+{ 0x30, 20, 1 },
+{ 0x11, 21, 1 },
+{ 0x10, 21, 0 },
+{ 0x71, 20, 1 },
+{ 0x70, 20, 1 },
+{ 0x31, 21, 1 },
+{ 0x30, 21, 0 },
+{ 0x29, 20, 1 },
+{ 0x28, 20, 0 },
+{ 0x69, 20, 1 },
+{ 0x68, 20, 0 },
+{ 0x19, 20, 1 },
+{ 0x18, 20, 1 },
+{ 0x9, 21, 1 },
+{ 0x8, 21, 0 },
+{ 0x39, 20, 1 },
+{ 0x38, 20, 1 },
+{ 0x19, 21, 1 },
+{ 0x18, 21, 0 },
+{ 0x15, 20, 1 },
+{ 0x14, 20, 0 },
+{ 0x35, 20, 1 },
+{ 0x34, 20, 0 },
+{ 0xd, 20, 1 },
+{ 0xc, 20, 1 },
+{ 0x5, 21, 1 },
+{ 0x4, 21, 0 },
+{ 0x1d, 20, 1 },
+{ 0x1c, 20, 1 },
+{ 0xd, 21, 1 },
+{ 0xc, 21, 0 },
+{ 0xb, 20, 1 },
+{ 0xa, 20, 0 },
+{ 0x1b, 20, 1 },
+{ 0x1a, 20, 0 },
+{ 0x7, 20, 1 },
+{ 0x6, 20, 1 },
+{ 0x3, 21, 1 },
+{ 0x2, 21, 0 },
+{ 0xf, 20, 1 },
+{ 0xe, 20, 1 },
+{ 0x7, 21, 1 },
+{ 0x6, 21, 0 },
+{ 0x8, 19, 0 },
+{ 0x18, 19, 0 },
+{ 0x2, 19, 1 },
+{ 0xc, 19, 0 },
+{ 0x1, 19, 1 },
+{ 0x4, 19, 0 },
+{ 0x51, 17, 0 },
+{ 0xd1, 17, 0 },
+{ 0x31, 17, 1 },
+{ 0x11, 18, 0 },
+{ 0x71, 17, 1 },
+{ 0x31, 18, 0 },
+{ 0x29, 17, 0 },
+{ 0x69, 17, 0 },
+{ 0x19, 17, 1 },
+{ 0x9, 18, 0 },
+{ 0x39, 17, 1 },
+{ 0x19, 18, 0 },
+{ 0x15, 17, 0 },
+{ 0x35, 17, 0 },
+{ 0xd, 17, 1 },
+{ 0x5, 18, 0 },
+{ 0x1d, 17, 1 },
+{ 0xd, 18, 0 },
+{ 0xb, 17, 0 },
+{ 0x1b, 17, 0 },
+{ 0x7, 17, 1 },
+{ 0x3, 18, 0 },
+{ 0xf, 17, 1 },
+{ 0x7, 18, 0 },
+{ 0x51, 15, 0 },
+{ 0xd1, 15, 0 },
+{ 0x31, 15, 1 },
+{ 0x11, 16, 0 },
+{ 0x71, 15, 1 },
+{ 0x31, 16, 0 },
+{ 0x29, 15, 0 },
+{ 0x69, 15, 0 },
+{ 0x19, 15, 1 },
+{ 0x9, 16, 0 },
+{ 0x39, 15, 1 },
+{ 0x19, 16, 0 },
+{ 0x15, 15, 0 },
+{ 0x35, 15, 0 },
+{ 0xd, 15, 1 },
+{ 0x5, 16, 0 },
+{ 0x1d, 15, 1 },
+{ 0xd, 16, 0 },
+{ 0xb, 15, 0 },
+{ 0x1b, 15, 0 },
+{ 0x7, 15, 1 },
+{ 0x3, 16, 0 },
+{ 0xf, 15, 1 },
+{ 0x7, 16, 0 },
+{ 0x288, 13, 0 },
+{ 0x688, 13, 0 },
+{ 0x188, 13, 1 },
+{ 0x88, 14, 0 },
+{ 0x388, 13, 1 },
+{ 0x188, 14, 0 },
+{ 0x148, 13, 0 },
+{ 0x348, 13, 0 },
+{ 0xc8, 13, 1 },
+{ 0x48, 14, 0 },
+{ 0x1c8, 13, 1 },
+{ 0xc8, 14, 0 },
+{ 0xa8, 13, 0 },
+{ 0x1a8, 13, 0 },
+{ 0x68, 13, 1 },
+{ 0x28, 14, 0 },
+{ 0xe8, 13, 1 },
+{ 0x68, 14, 0 },
+{ 0x58, 13, 0 },
+{ 0xd8, 13, 0 },
+{ 0x38, 13, 1 },
+{ 0x18, 14, 0 },
+{ 0x78, 13, 1 },
+{ 0x38, 14, 0 },
+{ 0x51, 13, 1 },
+{ 0xa0, 13, 0 },
+{ 0xd1, 13, 1 },
+{ 0x1a0, 13, 0 },
+{ 0x31, 13, 1 },
+{ 0x60, 13, 1 },
+{ 0x11, 14, 1 },
+{ 0x20, 14, 0 },
+{ 0x71, 13, 1 },
+{ 0xe0, 13, 1 },
+{ 0x31, 14, 1 },
+{ 0x60, 14, 0 },
+{ 0x29, 13, 1 },
+{ 0x50, 13, 0 },
+{ 0x69, 13, 1 },
+{ 0xd0, 13, 0 },
+{ 0x19, 13, 1 },
+{ 0x30, 13, 1 },
+{ 0x9, 14, 1 },
+{ 0x10, 14, 0 },
+{ 0x39, 13, 1 },
+{ 0x70, 13, 1 },
+{ 0x19, 14, 1 },
+{ 0x30, 14, 0 },
+{ 0x15, 13, 1 },
+{ 0x14, 13, 0 },
+{ 0x35, 13, 1 },
+{ 0x34, 13, 0 },
+{ 0xd, 13, 1 },
+{ 0xc, 13, 1 },
+{ 0x5, 14, 1 },
+{ 0x4, 14, 0 },
+{ 0x1d, 13, 1 },
+{ 0x1c, 13, 1 },
+{ 0xd, 14, 1 },
+{ 0xc, 14, 0 },
+{ 0xb, 13, 1 },
+{ 0xa, 13, 0 },
+{ 0x1b, 13, 1 },
+{ 0x1a, 13, 0 },
+{ 0x7, 13, 1 },
+{ 0x6, 13, 1 },
+{ 0x3, 14, 1 },
+{ 0x2, 14, 0 },
+{ 0xf, 13, 1 },
+{ 0xe, 13, 1 },
+{ 0x7, 14, 1 },
+{ 0x6, 14, 0 },
+{ 0x8, 12, 0 },
+{ 0x18, 12, 0 },
+{ 0x2, 12, 1 },
+{ 0xc, 12, 0 },
+{ 0x1, 12, 1 },
+{ 0x4, 12, 0 },
+{ 0x1, 11, 0 },
+{ 0x1, 10, 0 },
+{ 0x1, 9, 0 },
+{ 0x1, 8, 0 },
+{ 0x1, 7, 0 },
+{ 0x1, 6, 0 },
+{ 0x1, 5, 0 },
+{ 0x1, 4, 0 },
+{ 0x1, 3, 0 },
+{ 0x1, 1, 0 },
+{ 0x1, 0, 0 },
+};
+
Index: linux/arch/ia64/kdb/ia64-asmtab.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/ia64-asmtab.h	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,148 @@
+/* ia64-asmtab.h -- Header for compacted IA-64 opcode tables.
+   Copyright (C) 1999 Free Software Foundation, Inc.
+   Contributed by Bob Manson of Cygnus Support <manson@cygnus.com>
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version
+   2, or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#ifndef IA64_ASMTAB_H
+#define IA64_ASMTAB_H
+
+#include "ia64.h"
+
+/* The primary opcode table is made up of the following: */
+struct ia64_main_table
+{
+  /* The entry in the string table that corresponds to the name of this
+     opcode. */
+  unsigned short name_index;
+
+  /* The type of opcode; corresponds to the TYPE field in
+     struct ia64_opcode. */
+  unsigned char opcode_type;
+
+  /* The number of outputs for this opcode. */
+  unsigned char num_outputs;
+
+  /* The base insn value for this opcode.  It may be modified by completers. */
+  ia64_insn opcode;
+
+  /* The mask of valid bits in OPCODE. Zeros indicate operand fields. */
+  ia64_insn mask;
+
+  /* The operands of this instruction.  Corresponds to the OPERANDS field
+     in struct ia64_opcode. */
+  unsigned char operands[5];
+
+  /* The flags for this instruction.  Corresponds to the FLAGS field in
+     struct ia64_opcode. */
+  short flags;
+
+  /* The tree of completers for this instruction; this is an offset into
+     completer_table. */
+  short completers;
+};
+
+/* Each instruction has a set of possible "completers", or additional
+   suffixes that can alter the instruction's behavior, and which has
+   potentially different dependencies.
+
+   The completer entries modify certain bits in the instruction opcode.
+   Which bits are to be modified are marked by the BITS, MASK and
+   OFFSET fields.  The completer entry may also note dependencies for the
+   opcode.
+
+   These completers are arranged in a DAG; the pointers are indexes
+   into the completer_table array.  The completer DAG is searched by
+   find_completer () and ia64_find_matching_opcode ().
+
+   Note that each completer needs to be applied in turn, so that if we
+   have the instruction
+   	cmp.lt.unc
+   the completer entries for both "lt" and "unc" would need to be applied
+   to the opcode's value.
+
+   Some instructions do not require any completers; these contain an
+   empty completer entry.  Instructions that require a completer do
+   not contain an empty entry.
+
+   Terminal completers (those completers that validly complete an
+   instruction) are marked by having the TERMINAL_COMPLETER flag set.
+
+   Only dependencies listed in the terminal completer for an opcode are
+   considered to apply to that opcode instance. */
+
+struct ia64_completer_table
+{
+  /* The bit value that this completer sets. */
+  unsigned int bits;
+
+  /* And its mask. 1s are bits that are to be modified in the
+     instruction. */
+  unsigned int mask;
+
+  /* The entry in the string table that corresponds to the name of this
+     completer. */
+  unsigned short name_index;
+
+  /* An alternative completer, or -1 if this is the end of the chain. */
+  short alternative;
+
+  /* A pointer to the DAG of completers that can potentially follow
+     this one, or -1. */
+  short subentries;
+
+  /* The bit offset in the instruction where BITS and MASK should be
+     applied. */
+  unsigned char offset : 7;
+
+  unsigned char terminal_completer : 1;
+
+  /* Index into the dependency list table */
+  short dependencies;
+};
+
+/* This contains sufficient information for the disassembler to resolve
+   the complete name of the original instruction.  */
+struct ia64_dis_names
+{
+  /* COMPLETER_INDEX represents the tree of completers that make up
+     the instruction.  The LSB represents the top of the tree for the
+     specified instruction.
+
+     A 0 bit indicates to go to the next alternate completer via the
+     alternative field; a 1 bit indicates that the current completer
+     is part of the instruction, and to go down the subentries index.
+     We know we've reached the final completer when we run out of 1
+     bits.
+
+     There is always at least one 1 bit. */
+  unsigned int completer_index : 20;
+
+  /* The index in the main_table[] array for the instruction. */
+  unsigned short insn_index : 11;
+
+  /* If set, the next entry in this table is an alternate possibility
+     for this instruction encoding.  Which one to use is determined by
+     the instruction type and other factors (see opcode_verify ()).  */
+  unsigned int next_flag : 1;
+
+  /* The disassembly priority of this entry among instructions. */
+  unsigned short priority;
+};
+
+#endif
Index: linux/arch/ia64/kdb/ia64-dis.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/ia64-dis.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,304 @@
+/* ia64-dis.c -- Disassemble ia64 instructions
+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version
+   2, or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+/* Extracted from cygnus CVS and modified for kdb use.
+ * Keith Owens <kaos@sgi.com> 30 Oct 2000
+ */
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/dis-asm.h>
+#include "ia64.h"
+
+/* imported from bfd/libbfd.c for kernel */
+static inline bfd_vma
+bfd_getl64 (const bfd_byte *addr)
+{
+  unsigned long low, high;
+  high= (((((((addr[7] << 8) |
+	      addr[6]) << 8) |
+	    addr[5]) << 8) |
+	  addr[4]));
+
+  low = ((((((((unsigned long)addr[3] << 8) |
+	      addr[2]) << 8) |
+	    addr[1]) << 8) |
+	  addr[0]) );
+
+  return high << 32 | low;
+
+}
+
+#else	/* ! __KERNEL__ */
+#include <assert.h>
+#include <string.h>
+
+#include "dis-asm.h"
+#include "opcode/ia64.h"
+#endif
+
+#define NELEMS(a)	((int) (sizeof (a) / sizeof (a[0])))
+
+/* Disassemble ia64 instruction.  */
+
+/* Return the instruction type for OPCODE found in unit UNIT. */
+
+static enum ia64_insn_type
+unit_to_type (ia64_insn opcode, enum ia64_unit unit)
+{
+  enum ia64_insn_type type;
+  int op;
+
+  op = IA64_OP (opcode);
+
+  if (op >= 8 && (unit == IA64_UNIT_I || unit == IA64_UNIT_M))
+    {
+      type = IA64_TYPE_A;
+    }
+  else
+    {
+      switch (unit)
+	{
+	case IA64_UNIT_I:
+	  type = IA64_TYPE_I; break;
+	case IA64_UNIT_M:
+	  type = IA64_TYPE_M; break;
+	case IA64_UNIT_B:
+	  type = IA64_TYPE_B; break;
+	case IA64_UNIT_F:
+	  type = IA64_TYPE_F; break;
+        case IA64_UNIT_L:
+	case IA64_UNIT_X:
+	  type = IA64_TYPE_X; break;
+	default:
+	  type = -1;
+	}
+    }
+  return type;
+}
+
+int
+print_insn_ia64 (bfd_vma memaddr, struct disassemble_info *info)
+{
+  ia64_insn t0, t1, slot[3], template, s_bit, insn;
+  int slotnum, j, status, need_comma, retval, slot_multiplier;
+  const struct ia64_operand *odesc;
+  struct ia64_opcode *idesc;
+  const char *err, *str, *tname;
+  BFD_HOST_U_64_BIT value;
+  bfd_byte bundle[16];
+  enum ia64_unit unit;
+  char regname[16];
+
+  if (info->bytes_per_line == 0)
+    info->bytes_per_line = 6;
+  info->display_endian = info->endian;
+
+  slot_multiplier = info->bytes_per_line;
+  retval = slot_multiplier;
+
+  slotnum = (((long) memaddr) & 0xf) / slot_multiplier;
+  if (slotnum > 2)
+    return -1;
+
+  memaddr -= (memaddr & 0xf);
+  status = (*info->read_memory_func) (memaddr, bundle, sizeof (bundle), info);
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
+  /* bundles are always in little-endian byte order */
+  t0 = bfd_getl64 (bundle);
+  t1 = bfd_getl64 (bundle + 8);
+  s_bit = t0 & 1;
+  template = (t0 >> 1) & 0xf;
+  slot[0] = (t0 >>  5) & 0x1ffffffffffLL;
+  slot[1] = ((t0 >> 46) & 0x3ffff) | ((t1 & 0x7fffff) << 18);
+  slot[2] = (t1 >> 23) & 0x1ffffffffffLL;
+
+  tname = ia64_templ_desc[template].name;
+  if (slotnum == 0)
+    (*info->fprintf_func) (info->stream, "[%s] ", tname);
+  else
+    (*info->fprintf_func) (info->stream, "      ", tname);
+
+  unit = ia64_templ_desc[template].exec_unit[slotnum];
+
+  if (template == 2 && slotnum == 1)
+    {
+      /* skip L slot in MLI template: */
+      slotnum = 2;
+      retval += slot_multiplier;
+    }
+
+  insn = slot[slotnum];
+
+  if (unit == IA64_UNIT_NIL)
+    goto decoding_failed;
+
+  idesc = ia64_dis_opcode (insn, unit_to_type (insn, unit));
+  if (idesc == NULL)
+    goto decoding_failed;
+
+  /* print predicate, if any: */
+
+  if ((idesc->flags & IA64_OPCODE_NO_PRED)
+      || (insn & 0x3f) == 0)
+    (*info->fprintf_func) (info->stream, "      ");
+  else
+    (*info->fprintf_func) (info->stream, "(p%02d) ", (int)(insn & 0x3f));
+
+  /* now the actual instruction: */
+
+  (*info->fprintf_func) (info->stream, "%s", idesc->name);
+  if (idesc->operands[0])
+    (*info->fprintf_func) (info->stream, " ");
+
+  need_comma = 0;
+  for (j = 0; j < NELEMS (idesc->operands) && idesc->operands[j]; ++j)
+    {
+      odesc = elf64_ia64_operands + idesc->operands[j];
+
+      if (need_comma)
+	(*info->fprintf_func) (info->stream, ",");
+
+      if (odesc - elf64_ia64_operands == IA64_OPND_IMMU64)
+	{
+	  /* special case of 64 bit immediate load: */
+	  value = ((insn >> 13) & 0x7f) | (((insn >> 27) & 0x1ff) << 7)
+	    | (((insn >> 22) & 0x1f) << 16) | (((insn >> 21) & 0x1) << 21)
+	    | (slot[1] << 22) | (((insn >> 36) & 0x1) << 63);
+	}
+      else if (odesc - elf64_ia64_operands == IA64_OPND_IMMU62)
+        {
+          /* 62-bit immediate for nop.x/break.x */
+          value = ((slot[1] & 0x1ffffffffffLL) << 21)
+            | (((insn >> 36) & 0x1) << 20)
+            | ((insn >> 6) & 0xfffff);
+        }
+      else if (odesc - elf64_ia64_operands == IA64_OPND_TGT64)
+	{
+	  /* 60-bit immedate for long branches.  */
+	  value = (((insn >> 13) & 0xfffff)
+		   | (((insn >> 36) & 1) << 59)
+		   | ((slot[1] >> 2) << 20)) << 4;
+	}
+      else
+	{
+	  err = (*odesc->extract) (odesc, insn, &value);
+	  if (err)
+	    {
+	      (*info->fprintf_func) (info->stream, "%s", err);
+	      goto done;
+	    }
+	}
+
+	switch (odesc->class)
+	  {
+	  case IA64_OPND_CLASS_CST:
+	    (*info->fprintf_func) (info->stream, "%s", odesc->str);
+	    break;
+
+	  case IA64_OPND_CLASS_REG:
+	    if (odesc->str[0] == 'a' && odesc->str[1] == 'r')
+	      {
+		switch (value)
+		  {
+		  case 0: case 1: case 2: case 3:
+		  case 4: case 5: case 6: case 7:
+		    sprintf (regname, "ar.k%u", (unsigned int) value);
+		    break;
+		  case 16:	strcpy (regname, "ar.rsc"); break;
+		  case 17:	strcpy (regname, "ar.bsp"); break;
+		  case 18:	strcpy (regname, "ar.bspstore"); break;
+		  case 19:	strcpy (regname, "ar.rnat"); break;
+		  case 32:	strcpy (regname, "ar.ccv"); break;
+		  case 36:	strcpy (regname, "ar.unat"); break;
+		  case 40:	strcpy (regname, "ar.fpsr"); break;
+		  case 44:	strcpy (regname, "ar.itc"); break;
+		  case 64:	strcpy (regname, "ar.pfs"); break;
+		  case 65:	strcpy (regname, "ar.lc"); break;
+		  case 66:	strcpy (regname, "ar.ec"); break;
+		  default:
+		    sprintf (regname, "ar%u", (unsigned int) value);
+		    break;
+		  }
+		(*info->fprintf_func) (info->stream, "%s", regname);
+	      }
+	    else
+	      (*info->fprintf_func) (info->stream, "%s%d", odesc->str, (int)value);
+	    break;
+
+	  case IA64_OPND_CLASS_IND:
+	    (*info->fprintf_func) (info->stream, "%s[r%d]", odesc->str, (int)value);
+	    break;
+
+	  case IA64_OPND_CLASS_ABS:
+	    str = 0;
+	    if (odesc - elf64_ia64_operands == IA64_OPND_MBTYPE4)
+	      switch (value)
+		{
+		case 0x0: str = "@brcst"; break;
+		case 0x8: str = "@mix"; break;
+		case 0x9: str = "@shuf"; break;
+		case 0xa: str = "@alt"; break;
+		case 0xb: str = "@rev"; break;
+		}
+
+	    if (str)
+	      (*info->fprintf_func) (info->stream, "%s", str);
+	    else if (odesc->flags & IA64_OPND_FLAG_DECIMAL_SIGNED)
+	      (*info->fprintf_func) (info->stream, "%lld", value);
+	    else if (odesc->flags & IA64_OPND_FLAG_DECIMAL_UNSIGNED)
+	      (*info->fprintf_func) (info->stream, "%llu", value);
+	    else
+	      (*info->fprintf_func) (info->stream, "0x%llx", value);
+	    break;
+
+	  case IA64_OPND_CLASS_REL:
+	    (*info->print_address_func) (memaddr + value, info);
+	    break;
+	  }
+
+      need_comma = 1;
+      if (j + 1 == idesc->num_outputs)
+	{
+	  (*info->fprintf_func) (info->stream, "=");
+	  need_comma = 0;
+	}
+    }
+  if (slotnum + 1 == ia64_templ_desc[template].group_boundary
+      || ((slotnum == 2) && s_bit))
+    (*info->fprintf_func) (info->stream, ";;");
+
+ done:
+  ia64_free_opcode (idesc);
+ failed:
+  if (slotnum == 2)
+    retval += 16 - 3*slot_multiplier;
+  return retval;
+
+ decoding_failed:
+  (*info->fprintf_func) (info->stream, "      data8 %#011llx", insn);
+  goto failed;
+}
Index: linux/arch/ia64/kdb/ia64-opc.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/ia64-opc.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,727 @@
+/* ia64-opc.c -- Functions to access the compacted opcode table
+   Copyright (C) 1999 Free Software Foundation, Inc.
+   Written by Bob Manson of Cygnus Solutions, <manson@cygnus.com>
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version
+   2, or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+#if defined(__KERNEL__)
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/dis-asm.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#else
+#include "ansidecl.h"
+#include "libiberty.h"
+#include "sysdep.h"
+#endif
+
+#include "ia64-asmtab.h"
+#include "ia64-asmtab.c"
+
+const struct ia64_templ_desc ia64_templ_desc[16] =
+  {
+    { 0, { IA64_UNIT_M, IA64_UNIT_I, IA64_UNIT_I }, "MII" },	/* 0 */
+    { 2, { IA64_UNIT_M, IA64_UNIT_I, IA64_UNIT_I }, "MII" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_L, IA64_UNIT_X }, "MLX" },
+    { 0, { 0, },				    "-3-" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_I }, "MMI" },	/* 4 */
+    { 1, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_I }, "MMI" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_F, IA64_UNIT_I }, "MFI" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_F }, "MMF" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_I, IA64_UNIT_B }, "MIB" },	/* 8 */
+    { 0, { IA64_UNIT_M, IA64_UNIT_B, IA64_UNIT_B }, "MBB" },
+    { 0, { 0, },				    "-a-" },
+    { 0, { IA64_UNIT_B, IA64_UNIT_B, IA64_UNIT_B }, "BBB" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_M, IA64_UNIT_B }, "MMB" },	/* c */
+    { 0, { 0, },				    "-d-" },
+    { 0, { IA64_UNIT_M, IA64_UNIT_F, IA64_UNIT_B }, "MFB" },
+    { 0, { 0, },				    "-f-" },
+  };
+
+
+/* Copy the prefix contained in *PTR (up to a '.' or a NUL) to DEST.
+   PTR will be adjusted to point to the start of the next portion
+   of the opcode, or at the NUL character. */
+
+static void
+get_opc_prefix (const char **ptr, char *dest)
+{
+  char *c = strchr (*ptr, '.');
+  if (c != NULL)
+    {
+      memcpy (dest, *ptr, c - *ptr);
+      dest[c - *ptr] = '\0';
+      *ptr = c + 1;
+    }
+  else
+    {
+      int l = strlen (*ptr);
+      memcpy (dest, *ptr, l);
+      dest[l] = '\0';
+      *ptr += l;
+    }
+}
+
+/* Find the index of the entry in the string table corresponding to
+   STR; return -1 if one does not exist. */
+
+static short
+find_string_ent (const char *str)
+{
+  short start = 0;
+  short end = sizeof (ia64_strings) / sizeof (const char *);
+  short i = (start + end) / 2;
+
+  if (strcmp (str, ia64_strings[end - 1]) > 0)
+    {
+      return -1;
+    }
+  while (start <= end)
+    {
+      int c = strcmp (str, ia64_strings[i]);
+      if (c < 0)
+	{
+	  end = i - 1;
+	}
+      else if (c == 0)
+	{
+	  return i;
+	}
+      else
+	{
+	  start = i + 1;
+	}
+      i = (start + end) / 2;
+    }
+  return -1;
+}
+
+/* Find the opcode in the main opcode table whose name is STRINGINDEX, or
+   return -1 if one does not exist. */
+
+static short
+find_main_ent (short nameindex)
+{
+  short start = 0;
+  short end = sizeof (main_table) / sizeof (struct ia64_main_table);
+  short i = (start + end) / 2;
+
+  if (nameindex < main_table[0].name_index
+      || nameindex > main_table[end - 1].name_index)
+    {
+      return -1;
+    }
+  while (start <= end)
+    {
+      if (nameindex < main_table[i].name_index)
+	{
+	  end = i - 1;
+	}
+      else if (nameindex == main_table[i].name_index)
+	{
+	  while (i > 0 && main_table[i - 1].name_index == nameindex)
+	    {
+	      i--;
+	    }
+	  return i;
+	}
+      else
+	{
+	  start = i + 1;
+	}
+      i = (start + end) / 2;
+    }
+  return -1;
+}
+
+/* Find the index of the entry in the completer table that is part of
+   MAIN_ENT (starting from PREV_COMPLETER) that matches NAME, or
+   return -1 if one does not exist. */
+
+static short
+find_completer (short main_ent, short prev_completer, const char *name)
+{
+  short name_index = find_string_ent (name);
+
+  if (name_index < 0)
+    {
+      return -1;
+    }
+
+  if (prev_completer == -1)
+    {
+      prev_completer = main_table[main_ent].completers;
+    }
+  else
+    {
+      prev_completer = completer_table[prev_completer].subentries;
+    }
+
+  while (prev_completer != -1)
+    {
+      if (completer_table[prev_completer].name_index == name_index)
+	{
+	  return prev_completer;
+	}
+      prev_completer = completer_table[prev_completer].alternative;
+    }
+  return -1;
+}
+
+/* Apply the completer referred to by COMPLETER_INDEX to OPCODE, and
+   return the result. */
+
+static ia64_insn
+apply_completer (ia64_insn opcode, int completer_index)
+{
+  ia64_insn mask = completer_table[completer_index].mask;
+  ia64_insn bits = completer_table[completer_index].bits;
+  int shiftamt = (completer_table[completer_index].offset & 63);
+
+  mask = mask << shiftamt;
+  bits = bits << shiftamt;
+  opcode = (opcode & ~mask) | bits;
+  return opcode;
+}
+
+/* Extract BITS number of bits starting from OP_POINTER + BITOFFSET in
+   the dis_table array, and return its value.  (BITOFFSET is numbered
+   starting from MSB to LSB, so a BITOFFSET of 0 indicates the MSB of the
+   first byte in OP_POINTER.) */
+
+static int
+extract_op_bits (int op_pointer, int bitoffset, int bits)
+{
+  int res = 0;
+
+  op_pointer += (bitoffset / 8);
+
+  if (bitoffset % 8)
+    {
+      unsigned int op = dis_table[op_pointer++];
+      int numb = 8 - (bitoffset % 8);
+      int mask = (1 << numb) - 1;
+      int bata = (bits < numb) ? bits : numb;
+      int delta = numb - bata;
+
+      res = (res << bata) | ((op & mask) >> delta);
+      bitoffset += bata;
+      bits -= bata;
+    }
+  while (bits >= 8)
+    {
+      res = (res << 8) | (dis_table[op_pointer++] & 255);
+      bits -= 8;
+    }
+  if (bits > 0)
+    {
+      unsigned int op = (dis_table[op_pointer++] & 255);
+      res = (res << bits) | (op >> (8 - bits));
+    }
+  return res;
+}
+
+/* Examine the state machine entry at OP_POINTER in the dis_table
+   array, and extract its values into OPVAL and OP.  The length of the
+   state entry in bits is returned. */
+
+static int
+extract_op (int op_pointer, int *opval, unsigned int *op)
+{
+  int oplen = 5;
+
+  *op = dis_table[op_pointer];
+
+  if ((*op) & 0x40)
+    {
+      opval[0] = extract_op_bits (op_pointer, oplen, 5);
+      oplen += 5;
+    }
+  switch ((*op) & 0x30)
+    {
+    case 0x10:
+      {
+	opval[1] = extract_op_bits (op_pointer, oplen, 8);
+	oplen += 8;
+	opval[1] += op_pointer;
+	break;
+      }
+    case 0x20:
+      {
+	opval[1] = extract_op_bits (op_pointer, oplen, 16);
+	if (! (opval[1] & 32768))
+	  {
+	    opval[1] += op_pointer;
+	  }
+	oplen += 16;
+	break;
+      }
+    case 0x30:
+      {
+	oplen--;
+	opval[2] = extract_op_bits (op_pointer, oplen, 12);
+	oplen += 12;
+	opval[2] |= 32768;
+	break;
+      }
+    }
+  if (((*op) & 0x08) && (((*op) & 0x30) != 0x30))
+    {
+      opval[2] = extract_op_bits (op_pointer, oplen, 16);
+      oplen += 16;
+      if (! (opval[2] & 32768))
+	{
+	  opval[2] += op_pointer;
+	}
+    }
+  return oplen;
+}
+
+/* Returns a non-zero value if the opcode in the main_table list at
+   PLACE matches OPCODE and is of type TYPE. */
+
+static int
+opcode_verify (ia64_insn opcode, int place, enum ia64_insn_type type)
+{
+  if (main_table[place].opcode_type != type)
+    {
+      return 0;
+    }
+  if (main_table[place].flags
+      & (IA64_OPCODE_F2_EQ_F3 | IA64_OPCODE_LEN_EQ_64MCNT))
+    {
+      const struct ia64_operand *o1, *o2;
+      ia64_insn f2, f3;
+
+      if (main_table[place].flags & IA64_OPCODE_F2_EQ_F3)
+	{
+	  o1 = elf64_ia64_operands + IA64_OPND_F2;
+	  o2 = elf64_ia64_operands + IA64_OPND_F3;
+	  (*o1->extract) (o1, opcode, &f2);
+	  (*o2->extract) (o2, opcode, &f3);
+	  if (f2 != f3)
+	    return 0;
+	}
+      else
+	{
+	  ia64_insn len, count;
+
+	  /* length must equal 64-count: */
+	  o1 = elf64_ia64_operands + IA64_OPND_LEN6;
+	  o2 = elf64_ia64_operands + main_table[place].operands[2];
+	  (*o1->extract) (o1, opcode, &len);
+	  (*o2->extract) (o2, opcode, &count);
+	  if (len != 64 - count)
+	    return 0;
+	}
+    }
+  return 1;
+}
+
+/* Find an instruction entry in the ia64_dis_names array that matches
+   opcode OPCODE and is of type TYPE.  Returns either a positive index
+   into the array, or a negative value if an entry for OPCODE could
+   not be found.  Checks all matches and returns the one with the highest
+   priority. */
+
+static int
+locate_opcode_ent (ia64_insn opcode, enum ia64_insn_type type)
+{
+  int currtest[41];
+  int bitpos[41];
+  int op_ptr[41];
+  int currstatenum = 0;
+  short found_disent = -1;
+  short found_priority = -1;
+
+  currtest[currstatenum] = 0;
+  op_ptr[currstatenum] = 0;
+  bitpos[currstatenum] = 40;
+
+  while (1)
+    {
+      int op_pointer = op_ptr[currstatenum];
+      unsigned int op;
+      int currbitnum = bitpos[currstatenum];
+      int oplen;
+      int opval[3];
+      int next_op;
+      int currbit;
+
+      oplen = extract_op (op_pointer, opval, &op);
+
+      bitpos[currstatenum] = currbitnum;
+
+      /* Skip opval[0] bits in the instruction. */
+      if (op & 0x40)
+	{
+	  currbitnum -= opval[0];
+	}
+
+      /* The value of the current bit being tested. */
+      currbit = opcode & (((ia64_insn) 1) << currbitnum) ? 1 : 0;
+      next_op = -1;
+
+      /* We always perform the tests specified in the current state in
+	 a particular order, falling through to the next test if the
+	 previous one failed. */
+      switch (currtest[currstatenum])
+	{
+	case 0:
+	  currtest[currstatenum]++;
+	  if (currbit == 0 && (op & 0x80))
+	    {
+	      /* Check for a zero bit.  If this test solely checks for
+		 a zero bit, we can check for up to 8 consecutive zero
+		 bits (the number to check is specified by the lower 3
+		 bits in the state code.)
+
+		 If the state instruction matches, we go to the very
+		 next state instruction; otherwise, try the next test. */
+
+	      if ((op & 0xf8) == 0x80)
+		{
+		  int count = op & 0x7;
+		  int x;
+
+		  for (x = 0; x <= count; x++)
+		    {
+		      int i =
+			opcode & (((ia64_insn) 1) << (currbitnum - x)) ? 1 : 0;
+		      if (i)
+			{
+			  break;
+			}
+		    }
+		  if (x > count)
+		    {
+		      next_op = op_pointer + ((oplen + 7) / 8);
+		      currbitnum -= count;
+		      break;
+		    }
+		}
+	      else if (! currbit)
+		{
+		  next_op = op_pointer + ((oplen + 7) / 8);
+		  break;
+		}
+	    }
+	  /* FALLTHROUGH */
+	case 1:
+	  /* If the bit in the instruction is one, go to the state
+	     instruction specified by opval[1]. */
+	  currtest[currstatenum]++;
+	  if (currbit && (op & 0x30) != 0 && ((op & 0x30) != 0x30))
+	    {
+	      next_op = opval[1];
+	      break;
+	    }
+	  /* FALLTHROUGH */
+	case 2:
+	  /* Don't care.  Skip the current bit and go to the state
+	     instruction specified by opval[2].
+
+	     An encoding of 0x30 is special; this means that a 12-bit
+	     offset into the ia64_dis_names[] array is specified.  */
+	  currtest[currstatenum]++;
+	  if ((op & 0x08) || ((op & 0x30) == 0x30))
+	    {
+	      next_op = opval[2];
+	      break;
+	    }
+	}
+
+      /* If bit 15 is set in the address of the next state, an offset
+	 in the ia64_dis_names array was specified instead.  We then
+	 check to see if an entry in the list of opcodes matches the
+	 opcode we were given; if so, we have succeeded.  */
+
+      if ((next_op >= 0) && (next_op & 32768))
+	{
+	  short disent = next_op & 32767;
+          short priority = -1;
+
+	  if (next_op > 65535)
+	    {
+	      abort ();
+	    }
+
+	  /* Run through the list of opcodes to check, trying to find
+	     one that matches.  */
+	  while (disent >= 0)
+	    {
+	      int place = ia64_dis_names[disent].insn_index;
+
+              priority = ia64_dis_names[disent].priority;
+
+	      if (opcode_verify (opcode, place, type)
+                  && priority > found_priority)
+		{
+		  break;
+		}
+	      if (ia64_dis_names[disent].next_flag)
+		{
+		  disent++;
+		}
+	      else
+		{
+		  disent = -1;
+		}
+	    }
+
+	  if (disent >= 0)
+	    {
+              found_disent = disent;
+              found_priority = priority;
+	    }
+          /* Try the next test in this state, regardless of whether a match
+             was found. */
+          next_op = -2;
+	}
+
+      /* next_op == -1 is "back up to the previous state".
+	 next_op == -2 is "stay in this state and try the next test".
+	 Otherwise, transition to the state indicated by next_op. */
+
+      if (next_op == -1)
+	{
+	  currstatenum--;
+	  if (currstatenum < 0)
+	    {
+              return found_disent;
+	    }
+	}
+      else if (next_op >= 0)
+	{
+	  currstatenum++;
+	  bitpos[currstatenum] = currbitnum - 1;
+	  op_ptr[currstatenum] = next_op;
+	  currtest[currstatenum] = 0;
+	}
+    }
+}
+
+/* Construct an ia64_opcode entry based on OPCODE, NAME and PLACE. */
+
+static struct ia64_opcode *
+make_ia64_opcode (ia64_insn opcode, const char *name, int place, int depind)
+{
+  struct ia64_opcode *res =
+    (struct ia64_opcode *) xmalloc (sizeof (struct ia64_opcode));
+  res->name = xstrdup (name);
+  res->type = main_table[place].opcode_type;
+  res->num_outputs = main_table[place].num_outputs;
+  res->opcode = opcode;
+  res->mask = main_table[place].mask;
+  res->operands[0] = main_table[place].operands[0];
+  res->operands[1] = main_table[place].operands[1];
+  res->operands[2] = main_table[place].operands[2];
+  res->operands[3] = main_table[place].operands[3];
+  res->operands[4] = main_table[place].operands[4];
+  res->flags = main_table[place].flags;
+  res->ent_index = place;
+  res->dependencies = &op_dependencies[depind];
+  return res;
+}
+
+/* Determine the ia64_opcode entry for the opcode specified by INSN
+   and TYPE.  If a valid entry is not found, return NULL. */
+struct ia64_opcode *
+ia64_dis_opcode (ia64_insn insn, enum ia64_insn_type type)
+{
+  int disent = locate_opcode_ent (insn, type);
+
+  if (disent < 0)
+    {
+      return NULL;
+    }
+  else
+    {
+      unsigned int cb = ia64_dis_names[disent].completer_index;
+      static char name[128];
+      int place = ia64_dis_names[disent].insn_index;
+      int ci = main_table[place].completers;
+      ia64_insn tinsn = main_table[place].opcode;
+
+      strcpy (name, ia64_strings [main_table[place].name_index]);
+
+      while (cb)
+	{
+	  if (cb & 1)
+	    {
+	      int cname = completer_table[ci].name_index;
+
+	      tinsn = apply_completer (tinsn, ci);
+
+	      if (ia64_strings[cname][0] != '\0')
+		{
+		  strcat (name, ".");
+		  strcat (name, ia64_strings[cname]);
+		}
+	      if (cb != 1)
+		{
+		  ci = completer_table[ci].subentries;
+		}
+	    }
+	  else
+	    {
+	      ci = completer_table[ci].alternative;
+	    }
+	  if (ci < 0)
+	    {
+	      abort ();
+	    }
+	  cb = cb >> 1;
+	}
+      if (tinsn != (insn & main_table[place].mask))
+	{
+	  abort ();
+	}
+      return make_ia64_opcode (insn, name, place,
+                               completer_table[ci].dependencies);
+    }
+}
+
+/* Search the main_opcode table starting from PLACE for an opcode that
+   matches NAME.  Return NULL if one is not found. */
+
+static struct ia64_opcode *
+ia64_find_matching_opcode (const char *name, short place)
+{
+  char op[129];
+  const char *suffix;
+  short name_index;
+
+  if (strlen (name) > 128)
+    {
+      return NULL;
+    }
+  suffix = name;
+  get_opc_prefix (&suffix, op);
+  name_index = find_string_ent (op);
+  if (name_index < 0)
+    {
+      return NULL;
+    }
+
+  while (main_table[place].name_index == name_index)
+    {
+      const char *curr_suffix = suffix;
+      ia64_insn curr_insn = main_table[place].opcode;
+      short completer = -1;
+
+      do {
+      	if (suffix[0] == '\0')
+	  {
+	    completer = find_completer (place, completer, suffix);
+	  }
+	else
+	  {
+	    get_opc_prefix (&curr_suffix, op);
+	    completer = find_completer (place, completer, op);
+	  }
+	if (completer != -1)
+	  {
+	    curr_insn = apply_completer (curr_insn, completer);
+	  }
+      } while (completer != -1 && curr_suffix[0] != '\0');
+
+      if (completer != -1 && curr_suffix[0] == '\0'
+	  && completer_table[completer].terminal_completer)
+	{
+          int depind = completer_table[completer].dependencies;
+	  return make_ia64_opcode (curr_insn, name, place, depind);
+	}
+      else
+	{
+	  place++;
+	}
+    }
+  return NULL;
+}
+
+/* Find the next opcode after PREV_ENT that matches PREV_ENT, or return NULL
+   if one does not exist.
+
+   It is the caller's responsibility to invoke ia64_free_opcode () to
+   release any resources used by the returned entry. */
+
+struct ia64_opcode *
+ia64_find_next_opcode (struct ia64_opcode *prev_ent)
+{
+  return ia64_find_matching_opcode (prev_ent->name,
+				    prev_ent->ent_index + 1);
+}
+
+/* Find the first opcode that matches NAME, or return NULL if it does
+   not exist.
+
+   It is the caller's responsibility to invoke ia64_free_opcode () to
+   release any resources used by the returned entry. */
+
+struct ia64_opcode *
+ia64_find_opcode (const char *name)
+{
+  char op[129];
+  const char *suffix;
+  short place;
+  short name_index;
+
+  if (strlen (name) > 128)
+    {
+      return NULL;
+    }
+  suffix = name;
+  get_opc_prefix (&suffix, op);
+  name_index = find_string_ent (op);
+  if (name_index < 0)
+    {
+      return NULL;
+    }
+
+  place = find_main_ent (name_index);
+
+  if (place < 0)
+    {
+      return NULL;
+    }
+  return ia64_find_matching_opcode (name, place);
+}
+
+/* Free any resources used by ENT. */
+void
+ia64_free_opcode (ent)
+     struct ia64_opcode *ent;
+{
+  free ((void *)ent->name);
+  free (ent);
+}
+
+const struct ia64_dependency *
+ia64_find_dependency (index)
+  int index;
+{
+  index = DEP(index);
+
+  if (index < 0 || index >= sizeof(dependencies) / sizeof(dependencies[0]))
+    return NULL;
+
+  return &dependencies[index];
+}
Index: linux/arch/ia64/kdb/ia64-opc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/ia64-opc.h	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,129 @@
+/* ia64-opc.h -- IA-64 opcode table.
+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version
+   2, or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING.  If not, write to the
+   Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#ifndef IA64_OPC_H
+#define IA64_OPC_H
+
+#include "ia64.h"
+
+/* define a couple of abbreviations: */
+
+#define bOp(x)	(((ia64_insn) ((x) & 0xf)) << 37)
+#define mOp	bOp (-1)
+#define Op(x)	bOp (x), mOp
+
+#define FIRST		IA64_OPCODE_FIRST
+#define X_IN_MLX	IA64_OPCODE_X_IN_MLX
+#define LAST		IA64_OPCODE_LAST
+#define PRIV		IA64_OPCODE_PRIV
+#define NO_PRED		IA64_OPCODE_NO_PRED
+#define SLOT2		IA64_OPCODE_SLOT2
+#define PSEUDO		IA64_OPCODE_PSEUDO
+#define F2_EQ_F3	IA64_OPCODE_F2_EQ_F3
+#define LEN_EQ_64MCNT	IA64_OPCODE_LEN_EQ_64MCNT
+#define MOD_RRBS        IA64_OPCODE_MOD_RRBS
+
+#define AR_CCV	IA64_OPND_AR_CCV
+#define AR_PFS	IA64_OPND_AR_PFS
+#define C1	IA64_OPND_C1
+#define C8	IA64_OPND_C8
+#define C16	IA64_OPND_C16
+#define GR0	IA64_OPND_GR0
+#define IP	IA64_OPND_IP
+#define PR	IA64_OPND_PR
+#define PR_ROT	IA64_OPND_PR_ROT
+#define PSR	IA64_OPND_PSR
+#define PSR_L	IA64_OPND_PSR_L
+#define PSR_UM	IA64_OPND_PSR_UM
+
+#define AR3	IA64_OPND_AR3
+#define B1	IA64_OPND_B1
+#define B2	IA64_OPND_B2
+#define CR3	IA64_OPND_CR3
+#define F1	IA64_OPND_F1
+#define F2	IA64_OPND_F2
+#define F3	IA64_OPND_F3
+#define F4	IA64_OPND_F4
+#define P1	IA64_OPND_P1
+#define P2	IA64_OPND_P2
+#define R1	IA64_OPND_R1
+#define R2	IA64_OPND_R2
+#define R3	IA64_OPND_R3
+#define R3_2	IA64_OPND_R3_2
+
+#define CPUID_R3 IA64_OPND_CPUID_R3
+#define DBR_R3	IA64_OPND_DBR_R3
+#define DTR_R3	IA64_OPND_DTR_R3
+#define ITR_R3	IA64_OPND_ITR_R3
+#define IBR_R3	IA64_OPND_IBR_R3
+#define MR3	IA64_OPND_MR3
+#define MSR_R3	IA64_OPND_MSR_R3
+#define PKR_R3	IA64_OPND_PKR_R3
+#define PMC_R3	IA64_OPND_PMC_R3
+#define PMD_R3	IA64_OPND_PMD_R3
+#define RR_R3	IA64_OPND_RR_R3
+
+#define CCNT5	IA64_OPND_CCNT5
+#define CNT2a	IA64_OPND_CNT2a
+#define CNT2b	IA64_OPND_CNT2b
+#define CNT2c	IA64_OPND_CNT2c
+#define CNT5	IA64_OPND_CNT5
+#define CNT6	IA64_OPND_CNT6
+#define CPOS6a	IA64_OPND_CPOS6a
+#define CPOS6b	IA64_OPND_CPOS6b
+#define CPOS6c	IA64_OPND_CPOS6c
+#define IMM1	IA64_OPND_IMM1
+#define IMM14	IA64_OPND_IMM14
+#define IMM17	IA64_OPND_IMM17
+#define IMM22	IA64_OPND_IMM22
+#define IMM44	IA64_OPND_IMM44
+#define SOF	IA64_OPND_SOF
+#define SOL	IA64_OPND_SOL
+#define SOR	IA64_OPND_SOR
+#define IMM8	IA64_OPND_IMM8
+#define IMM8U4	IA64_OPND_IMM8U4
+#define IMM8M1	IA64_OPND_IMM8M1
+#define IMM8M1U4 IA64_OPND_IMM8M1U4
+#define IMM8M1U8 IA64_OPND_IMM8M1U8
+#define IMM9a	IA64_OPND_IMM9a
+#define IMM9b	IA64_OPND_IMM9b
+#define IMMU2	IA64_OPND_IMMU2
+#define IMMU21	IA64_OPND_IMMU21
+#define IMMU24	IA64_OPND_IMMU24
+#define IMMU62	IA64_OPND_IMMU62
+#define IMMU64	IA64_OPND_IMMU64
+#define IMMU7a	IA64_OPND_IMMU7a
+#define IMMU7b	IA64_OPND_IMMU7b
+#define IMMU9	IA64_OPND_IMMU9
+#define INC3	IA64_OPND_INC3
+#define LEN4	IA64_OPND_LEN4
+#define LEN6	IA64_OPND_LEN6
+#define MBTYPE4	IA64_OPND_MBTYPE4
+#define MHTYPE8	IA64_OPND_MHTYPE8
+#define POS6	IA64_OPND_POS6
+#define TAG13	IA64_OPND_TAG13
+#define TAG13b	IA64_OPND_TAG13b
+#define TGT25	IA64_OPND_TGT25
+#define TGT25b	IA64_OPND_TGT25b
+#define TGT25c	IA64_OPND_TGT25c
+#define TGT64   IA64_OPND_TGT64
+
+#endif
Index: linux/arch/ia64/kdb/ia64.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/ia64.h	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,394 @@
+/* ia64.h -- Header file for ia64 opcode table
+   Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+
+   See the file HP-COPYRIGHT for additional information.  */
+
+#ifndef opcode_ia64_h
+#define opcode_ia64_h
+
+#ifndef __KERNEL__
+#include <sys/types.h>
+#else
+#if 0	/* CONFIG_KDB */
+#include <bfd.h>
+#else
+#include <asm/bfd.h>
+#endif
+#endif
+
+
+typedef BFD_HOST_U_64_BIT ia64_insn;
+
+enum ia64_insn_type
+  {
+    IA64_TYPE_NIL = 0,	/* illegal type */
+    IA64_TYPE_A,	/* integer alu (I- or M-unit) */
+    IA64_TYPE_I,	/* non-alu integer (I-unit) */
+    IA64_TYPE_M,	/* memory (M-unit) */
+    IA64_TYPE_B,	/* branch (B-unit) */
+    IA64_TYPE_F,	/* floating-point (F-unit) */
+    IA64_TYPE_X,	/* long encoding (X-unit) */
+    IA64_TYPE_DYN,	/* Dynamic opcode */
+    IA64_NUM_TYPES
+  };
+
+enum ia64_unit
+  {
+    IA64_UNIT_NIL = 0,	/* illegal unit */
+    IA64_UNIT_I,	/* integer unit */
+    IA64_UNIT_M,	/* memory unit */
+    IA64_UNIT_B,	/* branching unit */
+    IA64_UNIT_F,	/* floating-point unit */
+    IA64_UNIT_L,	/* long "unit" */
+    IA64_UNIT_X,	/* may be integer or branch unit */
+    IA64_NUM_UNITS
+  };
+
+/* Changes to this enumeration must be propagated to the operand table in
+   bfd/cpu-ia64-opc.c
+ */
+enum ia64_opnd
+  {
+    IA64_OPND_NIL,	/* no operand---MUST BE FIRST!*/
+
+    /* constants */
+    IA64_OPND_AR_CCV,	/* application register ccv (ar.ccv) */
+    IA64_OPND_AR_PFS,	/* application register pfs (ar.pfs) */
+    IA64_OPND_C1,	/* the constant 1 */
+    IA64_OPND_C8,	/* the constant 8 */
+    IA64_OPND_C16,	/* the constant 16 */
+    IA64_OPND_GR0,	/* gr0 */
+    IA64_OPND_IP,	/* instruction pointer (ip) */
+    IA64_OPND_PR,	/* predicate register (pr) */
+    IA64_OPND_PR_ROT,	/* rotating predicate register (pr.rot) */
+    IA64_OPND_PSR,	/* processor status register (psr) */
+    IA64_OPND_PSR_L,	/* processor status register L (psr.l) */
+    IA64_OPND_PSR_UM,	/* processor status register UM (psr.um) */
+
+    /* register operands: */
+    IA64_OPND_AR3,	/* third application register # (bits 20-26) */
+    IA64_OPND_B1,	/* branch register # (bits 6-8) */
+    IA64_OPND_B2,	/* branch register # (bits 13-15) */
+    IA64_OPND_CR3,	/* third control register # (bits 20-26) */
+    IA64_OPND_F1,	/* first floating-point register # */
+    IA64_OPND_F2,	/* second floating-point register # */
+    IA64_OPND_F3,	/* third floating-point register # */
+    IA64_OPND_F4,	/* fourth floating-point register # */
+    IA64_OPND_P1,	/* first predicate # */
+    IA64_OPND_P2,	/* second predicate # */
+    IA64_OPND_R1,	/* first register # */
+    IA64_OPND_R2,	/* second register # */
+    IA64_OPND_R3,	/* third register # */
+    IA64_OPND_R3_2,	/* third register # (limited to gr0-gr3) */
+
+    /* indirect operands: */
+    IA64_OPND_CPUID_R3,	/* cpuid[reg] */
+    IA64_OPND_DBR_R3,	/* dbr[reg] */
+    IA64_OPND_DTR_R3,	/* dtr[reg] */
+    IA64_OPND_ITR_R3,	/* itr[reg] */
+    IA64_OPND_IBR_R3,	/* ibr[reg] */
+    IA64_OPND_MR3,	/* memory at addr of third register # */
+    IA64_OPND_MSR_R3,	/* msr[reg] */
+    IA64_OPND_PKR_R3,	/* pkr[reg] */
+    IA64_OPND_PMC_R3,	/* pmc[reg] */
+    IA64_OPND_PMD_R3,	/* pmd[reg] */
+    IA64_OPND_RR_R3,	/* rr[reg] */
+
+    /* immediate operands: */
+    IA64_OPND_CCNT5,	/* 5-bit count (31 - bits 20-24) */
+    IA64_OPND_CNT2a,	/* 2-bit count (1 + bits 27-28) */
+    IA64_OPND_CNT2b,	/* 2-bit count (bits 27-28): 1, 2, 3 */
+    IA64_OPND_CNT2c,	/* 2-bit count (bits 30-31): 0, 7, 15, or 16 */
+    IA64_OPND_CNT5,	/* 5-bit count (bits 14-18) */
+    IA64_OPND_CNT6,	/* 6-bit count (bits 27-32) */
+    IA64_OPND_CPOS6a,	/* 6-bit count (63 - bits 20-25) */
+    IA64_OPND_CPOS6b,	/* 6-bit count (63 - bits 14-19) */
+    IA64_OPND_CPOS6c,	/* 6-bit count (63 - bits 31-36) */
+    IA64_OPND_IMM1,	/* signed 1-bit immediate (bit 36) */
+    IA64_OPND_IMMU2,	/* unsigned 2-bit immediate (bits 13-14) */
+    IA64_OPND_IMMU7a,	/* unsigned 7-bit immediate (bits 13-19) */
+    IA64_OPND_IMMU7b,	/* unsigned 7-bit immediate (bits 20-26) */
+    IA64_OPND_SOF,	/* 8-bit stack frame size */
+    IA64_OPND_SOL,	/* 8-bit size of locals */
+    IA64_OPND_SOR,	/* 6-bit number of rotating registers (scaled by 8) */
+    IA64_OPND_IMM8,	/* signed 8-bit immediate (bits 13-19 & 36) */
+    IA64_OPND_IMM8U4,	/* cmp4*u signed 8-bit immediate (bits 13-19 & 36) */
+    IA64_OPND_IMM8M1,	/* signed 8-bit immediate -1 (bits 13-19 & 36) */
+    IA64_OPND_IMM8M1U4,	/* cmp4*u signed 8-bit immediate -1 (bits 13-19 & 36)*/
+    IA64_OPND_IMM8M1U8,	/* cmp*u signed 8-bit immediate -1 (bits 13-19 & 36) */
+    IA64_OPND_IMMU9,	/* unsigned 9-bit immediate (bits 33-34, 20-26) */
+    IA64_OPND_IMM9a,	/* signed 9-bit immediate (bits 6-12, 27, 36) */
+    IA64_OPND_IMM9b,	/* signed 9-bit immediate (bits 13-19, 27, 36) */
+    IA64_OPND_IMM14,	/* signed 14-bit immediate (bits 13-19, 27-32, 36) */
+    IA64_OPND_IMM17,	/* signed 17-bit immediate (2*bits 6-12, 24-31, 36) */
+    IA64_OPND_IMMU21,	/* unsigned 21-bit immediate (bits 6-25, 36) */
+    IA64_OPND_IMM22,	/* signed 22-bit immediate (bits 13-19, 22-36) */
+    IA64_OPND_IMMU24,	/* unsigned 24-bit immediate (bits 6-26, 31-32, 36) */
+    IA64_OPND_IMM44,	/* signed 44-bit immediate (2^16*bits 6-32, 36) */
+    IA64_OPND_IMMU62,	/* unsigned 62-bit immediate */
+    IA64_OPND_IMMU64,	/* unsigned 64-bit immediate (lotsa bits...) */
+    IA64_OPND_INC3,	/* signed 3-bit (bits 13-15): +/-1, 4, 8, 16 */
+    IA64_OPND_LEN4,	/* 4-bit count (bits 27-30 + 1) */
+    IA64_OPND_LEN6,	/* 6-bit count (bits 27-32 + 1) */
+    IA64_OPND_MBTYPE4,	/* 4-bit mux type (bits 20-23) */
+    IA64_OPND_MHTYPE8,	/* 8-bit mux type (bits 20-27) */
+    IA64_OPND_POS6,	/* 6-bit count (bits 14-19) */
+    IA64_OPND_TAG13,	/* signed 13-bit tag (ip + 16*bits 6-12, 33-34) */
+    IA64_OPND_TAG13b,	/* signed 13-bit tag (ip + 16*bits 24-32) */
+    IA64_OPND_TGT25,	/* signed 25-bit (ip + 16*bits 6-25, 36) */
+    IA64_OPND_TGT25b,	/* signed 25-bit (ip + 16*bits 6-12, 20-32, 36) */
+    IA64_OPND_TGT25c,	/* signed 25-bit (ip + 16*bits 13-32, 36) */
+    IA64_OPND_TGT64,    /* 64-bit (ip + 16*bits 13-32, 36, 2-40(L)) */
+
+    IA64_OPND_COUNT	/* # of operand types (MUST BE LAST!) */
+  };
+
+enum ia64_dependency_mode
+{
+  IA64_DV_RAW,
+  IA64_DV_WAW,
+  IA64_DV_WAR,
+};
+
+enum ia64_dependency_semantics
+{
+  IA64_DVS_NONE,
+  IA64_DVS_IMPLIED,
+  IA64_DVS_IMPLIEDF,
+  IA64_DVS_DATA,
+  IA64_DVS_INSTR,
+  IA64_DVS_SPECIFIC,
+  IA64_DVS_OTHER,
+};
+
+enum ia64_resource_specifier
+{
+  IA64_RS_ANY,
+  IA64_RS_AR_K,
+  IA64_RS_AR_UNAT,
+  IA64_RS_AR, /* 8-15, 20, 22-23, 31, 33-35, 37-39, 41-43, 45-47, 67-111 */
+  IA64_RS_ARb, /* 48-63, 112-127 */
+  IA64_RS_BR,
+  IA64_RS_CFM,
+  IA64_RS_CPUID,
+  IA64_RS_CR_IRR,
+  IA64_RS_CR_LRR,
+  IA64_RS_CR, /* 3-7,10-15,18,26-63,75-79,82-127 */
+  IA64_RS_DBR,
+  IA64_RS_FR,
+  IA64_RS_FRb,
+  IA64_RS_GR0,
+  IA64_RS_GR,
+  IA64_RS_IBR,
+  IA64_RS_INSERVICE, /* CR[EOI] or CR[IVR] */
+  IA64_RS_MSR,
+  IA64_RS_PKR,
+  IA64_RS_PMC,
+  IA64_RS_PMD,
+  IA64_RS_PR,
+  IA64_RS_PR63,
+  IA64_RS_RR,
+
+  IA64_RS_ARX, /* ARs not in RS_AR or RS_ARb */
+  IA64_RS_CRX, /* CRs not in RS_CR */
+  IA64_RS_PSR, /* PSR bits */
+  IA64_RS_RSE, /* implementation-specific RSE resources */
+  IA64_RS_AR_FPSR,
+};
+
+enum ia64_rse_resource
+{
+  IA64_RSE_N_STACKED_PHYS,
+  IA64_RSE_BOF,
+  IA64_RSE_STORE_REG,
+  IA64_RSE_LOAD_REG,
+  IA64_RSE_BSPLOAD,
+  IA64_RSE_RNATBITINDEX,
+  IA64_RSE_CFLE,
+  IA64_RSE_NDIRTY,
+};
+
+/* Information about a given resource dependency */
+struct ia64_dependency
+{
+  /* Name of the resource */
+  const char *name;
+  /* Does this dependency need further specification? */
+  enum ia64_resource_specifier specifier;
+  /* Mode of dependency */
+  enum ia64_dependency_mode mode;
+  /* Dependency semantics */
+  enum ia64_dependency_semantics semantics;
+  /* Register index, if applicable (distinguishes AR, CR, and PSR deps) */
+#define REG_NONE (-1)
+  int regindex;
+  /* Special info on semantics */
+  const char *info;
+};
+
+/* Two arrays of indexes into the ia64_dependency table.
+   chks are dependencies to check for conflicts when an opcode is
+   encountered; regs are dependencies to register (mark as used) when an
+   opcode is used.  chks correspond to readers (RAW) or writers (WAW or
+   WAR) of a resource, while regs correspond to writers (RAW or WAW) and
+   readers (WAR) of a resource.  */
+struct ia64_opcode_dependency
+{
+  int nchks;
+  const unsigned short *chks;
+  int nregs;
+  const unsigned short *regs;
+};
+
+/* encode/extract the note/index for a dependency */
+#define RDEP(N,X) (((N)<<11)|(X))
+#define NOTE(X) (((X)>>11)&0x1F)
+#define DEP(X) ((X)&0x7FF)
+
+/* A template descriptor describes the execution units that are active
+   for each of the three slots.  It also specifies the location of
+   instruction group boundaries that may be present between two slots.  */
+struct ia64_templ_desc
+  {
+    int group_boundary;	/* 0=no boundary, 1=between slot 0 & 1, etc. */
+    enum ia64_unit exec_unit[3];
+    const char *name;
+  };
+
+/* The opcode table is an array of struct ia64_opcode.  */
+
+struct ia64_opcode
+  {
+    /* The opcode name.  */
+    const char *name;
+
+    /* The type of the instruction: */
+    enum ia64_insn_type type;
+
+    /* Number of output operands: */
+    int num_outputs;
+
+    /* The opcode itself.  Those bits which will be filled in with
+       operands are zeroes.  */
+    ia64_insn opcode;
+
+    /* The opcode mask.  This is used by the disassembler.  This is a
+       mask containing ones indicating those bits which must match the
+       opcode field, and zeroes indicating those bits which need not
+       match (and are presumably filled in by operands).  */
+    ia64_insn mask;
+
+    /* An array of operand codes.  Each code is an index into the
+       operand table.  They appear in the order which the operands must
+       appear in assembly code, and are terminated by a zero.  */
+    enum ia64_opnd operands[5];
+
+    /* One bit flags for the opcode.  These are primarily used to
+       indicate specific processors and environments support the
+       instructions.  The defined values are listed below. */
+    unsigned int flags;
+
+    /* Used by ia64_find_next_opcode (). */
+    short ent_index;
+
+    /* Opcode dependencies. */
+    const struct ia64_opcode_dependency *dependencies;
+  };
+
+/* Values defined for the flags field of a struct ia64_opcode.  */
+
+#define IA64_OPCODE_FIRST	(1<<0)	/* must be first in an insn group */
+#define IA64_OPCODE_X_IN_MLX	(1<<1)	/* insn is allowed in X slot of MLX */
+#define IA64_OPCODE_LAST	(1<<2)	/* must be last in an insn group */
+#define IA64_OPCODE_PRIV	(1<<3)	/* privileged instruct */
+#define IA64_OPCODE_SLOT2	(1<<4)	/* insn allowed in slot 2 only */
+#define IA64_OPCODE_NO_PRED	(1<<5)	/* insn cannot be predicated */
+#define IA64_OPCODE_PSEUDO	(1<<6)	/* insn is a pseudo-op */
+#define IA64_OPCODE_F2_EQ_F3	(1<<7)	/* constraint: F2 == F3 */
+#define IA64_OPCODE_LEN_EQ_64MCNT	(1<<8)	/* constraint: LEN == 64-CNT */
+#define IA64_OPCODE_MOD_RRBS    (1<<9) /* modifies all rrbs in CFM */
+
+/* A macro to extract the major opcode from an instruction.  */
+#define IA64_OP(i)	(((i) >> 37) & 0xf)
+
+enum ia64_operand_class
+  {
+    IA64_OPND_CLASS_CST,	/* constant */
+    IA64_OPND_CLASS_REG,	/* register */
+    IA64_OPND_CLASS_IND,	/* indirect register */
+    IA64_OPND_CLASS_ABS,	/* absolute value */
+    IA64_OPND_CLASS_REL,	/* IP-relative value */
+  };
+
+/* The operands table is an array of struct ia64_operand.  */
+
+struct ia64_operand
+{
+  enum ia64_operand_class class;
+
+  /* Set VALUE as the operand bits for the operand of type SELF in the
+     instruction pointed to by CODE.  If an error occurs, *CODE is not
+     modified and the returned string describes the cause of the
+     error.  If no error occurs, NULL is returned.  */
+  const char *(*insert) (const struct ia64_operand *self, ia64_insn value,
+			 ia64_insn *code);
+
+  /* Extract the operand bits for an operand of type SELF from
+     instruction CODE store them in *VALUE.  If an error occurs, the
+     cause of the error is described by the string returned.  If no
+     error occurs, NULL is returned.  */
+  const char *(*extract) (const struct ia64_operand *self, ia64_insn code,
+			  ia64_insn *value);
+
+  /* A string whose meaning depends on the operand class.  */
+
+  const char *str;
+
+  struct bit_field
+    {
+      /* The number of bits in the operand.  */
+      int bits;
+
+      /* How far the operand is left shifted in the instruction.  */
+      int shift;
+    }
+  field[4];		/* no operand has more than this many bit-fields */
+
+  unsigned int flags;
+
+  const char *desc;	/* brief description */
+};
+
+/* Values defined for the flags field of a struct ia64_operand.  */
+
+/* Disassemble as signed decimal (instead of hex): */
+#define IA64_OPND_FLAG_DECIMAL_SIGNED	(1<<0)
+/* Disassemble as unsigned decimal (instead of hex): */
+#define IA64_OPND_FLAG_DECIMAL_UNSIGNED	(1<<1)
+
+extern const struct ia64_templ_desc ia64_templ_desc[16];
+
+/* The tables are sorted by major opcode number and are otherwise in
+   the order in which the disassembler should consider instructions.  */
+extern struct ia64_opcode ia64_opcodes_a[];
+extern struct ia64_opcode ia64_opcodes_i[];
+extern struct ia64_opcode ia64_opcodes_m[];
+extern struct ia64_opcode ia64_opcodes_b[];
+extern struct ia64_opcode ia64_opcodes_f[];
+extern struct ia64_opcode ia64_opcodes_d[];
+
+
+extern struct ia64_opcode *ia64_find_opcode (const char *name);
+extern struct ia64_opcode *ia64_find_next_opcode (struct ia64_opcode *ent);
+
+extern struct ia64_opcode *ia64_dis_opcode (ia64_insn insn,
+					    enum ia64_insn_type type);
+
+extern void ia64_free_opcode (struct ia64_opcode *ent);
+extern const struct ia64_dependency *ia64_find_dependency (int index);
+
+/* To avoid circular library dependencies, this array is implemented
+   in bfd/cpu-ia64-opc.c: */
+extern const struct ia64_operand elf64_ia64_operands[IA64_OPND_COUNT];
+
+#endif /* opcode_ia64_h */
Index: linux/arch/ia64/kdb/kdb_cmds
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/kdb_cmds	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,17 @@
+# Standard architecture specific commands for kdb.
+# These commands are appended to those in kdb/kdb_cmds, see that file for
+# restrictions.
+
+# Standard debugging information for first level support, invoked from archkdb*
+# commands that are defined in kdb/kdb_cmds.
+
+defcmd archkdbcommon "" "Common arch debugging"
+  set LINES 2000000
+  set BTAPROMPT 0
+  -summary
+  -id %ip-0x40
+  -cpu
+  -ps
+  -dmesg 600
+  -bt
+endefcmd
Index: linux/arch/ia64/kdb/kdba_bp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/kdba_bp.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,703 @@
+/*
+ * Kernel Debugger Architecture Dependent Breakpoint Handling
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/ptrace.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <asm/pgalloc.h>
+
+
+static char *kdba_rwtypes[] = { "Instruction(Register)", "Data Write",
+			"I/O", "Data Access"};
+
+/*
+ * Table describing processor architecture hardware
+ * breakpoint registers.
+ */
+
+static kdbhard_bp_t kdb_hardbreaks[KDB_MAXHARDBPT];
+
+/*
+ * kdba_db_trap
+ *
+ *	Perform breakpoint processing upon entry to the
+ *	processor debugger fault.   Determine and print
+ *	the active breakpoint.
+ *
+ * Parameters:
+ *	regs	Exception frame containing machine register state
+ *	error	Error number passed to kdb.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	KDB_DB_BPT	Standard instruction or data breakpoint encountered
+ *	KDB_DB_SS	Single Step fault ('ss' command or end of 'ssb' command)
+ *	KDB_DB_SSB	Single Step fault, caller should continue ('ssb' command)
+ *	KDB_DB_SSBPT	Single step over breakpoint
+ *	KDB_DB_NOBPT	No existing kdb breakpoint matches this debug exception
+ * Locking:
+ *	None.
+ * Remarks:
+ *	Yup, there be goto's here.
+ *
+ *	If multiple processors receive debug exceptions simultaneously,
+ *	one may be waiting at the kdb fence in kdb() while the user
+ *	issues a 'bc' command to clear the breakpoint the processor
+ *	which is waiting has already encountered.  If this is the case,
+ *	the debug registers will no longer match any entry in the
+ *	breakpoint table, and we'll return the value KDB_DB_NOBPT.
+ *	This can cause a panic in die_if_kernel().  It is safer to
+ *	disable the breakpoint (bd), go until all processors are past
+ *	the breakpoint then clear the breakpoint (bc).  This code
+ *	recognises a breakpoint even when disabled but not when it has
+ *	been cleared.
+ *
+ *	WARNING: This routine clears the debug state.  It should be called
+ *		 once per debug and the result cached.
+ */
+
+kdb_dbtrap_t
+kdba_db_trap(struct pt_regs *regs, int error)
+{
+	int i;
+	kdb_dbtrap_t rv = KDB_DB_BPT;
+	kdb_bp_t *bp;
+
+	if (KDB_NULL_REGS(regs))
+		return KDB_DB_NOBPT;
+
+	if (KDB_DEBUG(BP))
+		kdb_printf("kdba_db_trap: error %d\n", error);
+
+	if (error == 36) {
+		/* Single step */
+		if (KDB_STATE(SSBPT)) {
+			if (KDB_DEBUG(BP))
+				kdb_printf("ssbpt\n");
+			KDB_STATE_CLEAR(SSBPT);
+			for(i=0,bp=kdb_breakpoints;
+			    i < KDB_MAXBPT;
+			    i++, bp++) {
+				if (KDB_DEBUG(BP))
+					kdb_printf("bp 0x%p enabled %d delayed %d global %d cpu %d\n",
+						   bp, bp->bp_enabled, bp->bp_delayed, bp->bp_global, bp->bp_cpu);
+				if (!bp->bp_enabled)
+					continue;
+				if (!bp->bp_global && bp->bp_cpu != smp_processor_id())
+					continue;
+				if (KDB_DEBUG(BP))
+					kdb_printf("bp for this cpu\n");
+				if (bp->bp_delayed) {
+					bp->bp_delayed = 0;
+					if (KDB_DEBUG(BP))
+						kdb_printf("kdba_installbp\n");
+					kdba_installbp(regs, bp);
+					if (!KDB_STATE(DOING_SS)) {
+						kdba_clearsinglestep(regs);
+						return(KDB_DB_SSBPT);
+					}
+					break;
+				}
+			}
+			if (i == KDB_MAXBPT) {
+				kdb_printf("kdb: Unable to find delayed breakpoint\n");
+			}
+			if (!KDB_STATE(DOING_SS)) {
+				kdba_clearsinglestep(regs);
+				return(KDB_DB_NOBPT);
+			}
+			/* FALLTHROUGH */
+		}
+
+		/*
+		 * KDB_STATE_DOING_SS is set when the kernel debugger is using
+		 * the processor trap flag to single-step a processor.  If a
+		 * single step trap occurs and this flag is clear, the SS trap
+		 * will be ignored by KDB and the kernel will be allowed to deal
+		 * with it as necessary (e.g. for ptrace).
+		 */
+		if (!KDB_STATE(DOING_SS))
+			return(KDB_DB_NOBPT);
+
+		/* single step */
+		rv = KDB_DB_SS;		/* Indicate single step */
+		if (KDB_STATE(DOING_SSB))		/* No ia64 ssb support yet */
+			KDB_STATE_CLEAR(DOING_SSB);	/* No ia64 ssb support yet */
+		if (KDB_STATE(DOING_SSB)) {
+			/* No IA64 ssb support yet */
+		} else {
+			/*
+			 * Print current insn
+			 */
+			kdb_machreg_t pc = regs->cr_iip + ia64_psr(regs)->ri * 6;
+			kdb_printf("SS trap at ");
+			kdb_symbol_print(pc, NULL, KDB_SP_DEFAULT|KDB_SP_NEWLINE);
+			kdb_id1(pc);
+			KDB_STATE_CLEAR(DOING_SS);
+		}
+
+		if (rv != KDB_DB_SSB)
+			kdba_clearsinglestep(regs);
+	}
+
+	return(rv);
+}
+
+/*
+ * kdba_bp_trap
+ *
+ *	Perform breakpoint processing upon entry to the
+ *	processor breakpoint instruction fault.   Determine and print
+ *	the active breakpoint.
+ *
+ * Parameters:
+ *	regs	Exception frame containing machine register state
+ *	error	Error number passed to kdb.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	0	Standard instruction or data breakpoint encountered
+ *	1	Single Step fault ('ss' command)
+ *	2	Single Step fault, caller should continue ('ssb' command)
+ *	3	No existing kdb breakpoint matches this debug exception
+ * Locking:
+ *	None.
+ * Remarks:
+ *
+ *	If multiple processors receive debug exceptions simultaneously,
+ *	one may be waiting at the kdb fence in kdb() while the user
+ *	issues a 'bc' command to clear the breakpoint the processor which
+ *	is waiting has already encountered.   If this is the case, the
+ *	debug registers will no longer match any entry in the breakpoint
+ *	table, and we'll return the value '3'.  This can cause a panic
+ *	in die_if_kernel().  It is safer to disable the breakpoint (bd),
+ *	'go' until all processors are past the breakpoint then clear the
+ *	breakpoint (bc).  This code recognises a breakpoint even when
+ *	disabled but not when it has been cleared.
+ *
+ *	WARNING: This routine resets the ip.  It should be called
+ *		 once per breakpoint and the result cached.
+ */
+
+kdb_dbtrap_t
+kdba_bp_trap(struct pt_regs *regs, int error)
+{
+	int i;
+	kdb_dbtrap_t rv;
+	kdb_bp_t *bp;
+
+	if (KDB_NULL_REGS(regs))
+		return KDB_DB_NOBPT;
+
+	/*
+	 * Determine which breakpoint was encountered.
+	 */
+	if (KDB_DEBUG(BP))
+		kdb_printf("kdba_bp_trap: ip=0x%lx "
+			   "regs=0x%p sp=0x%lx\n",
+			   regs->cr_iip, regs, regs->r12);
+
+	rv = KDB_DB_NOBPT;	/* Cause kdb() to return */
+
+	for(i=0, bp=kdb_breakpoints; i<KDB_MAXBPT; i++, bp++) {
+		if (bp->bp_free)
+			continue;
+		if (!bp->bp_global && bp->bp_cpu != smp_processor_id())
+			continue;
+		 if (bp->bp_addr == regs->cr_iip) {
+			/* Hit this breakpoint.  */
+			kdb_printf("Instruction(i) breakpoint #%d at 0x%lx\n",
+				  i, regs->cr_iip);
+			kdb_id1(regs->cr_iip);
+			rv = KDB_DB_BPT;
+			bp->bp_delay = 1;
+			/* SSBPT is set when the kernel debugger must single
+			 * step a task in order to re-establish an instruction
+			 * breakpoint which uses the instruction replacement
+			 * mechanism.  It is cleared by any action that removes
+			 * the need to single-step the breakpoint.
+			 */
+			KDB_STATE_SET(SSBPT);
+			break;
+		}
+	}
+
+	return rv;
+}
+
+/*
+ * kdba_handle_bp
+ *
+ *	Handle an instruction-breakpoint trap.  Called when re-installing
+ *	an enabled breakpoint which has has the bp_delay bit set.
+ *
+ * Parameters:
+ * Returns:
+ * Locking:
+ * Remarks:
+ *
+ * Ok, we really need to:
+ *	1) Restore the original instruction byte(s)
+ *	2) Single Step
+ *	3) Restore breakpoint instruction
+ *	4) Continue.
+ *
+ *
+ */
+
+static void
+kdba_handle_bp(struct pt_regs *regs, kdb_bp_t *bp)
+{
+	if (KDB_NULL_REGS(regs))
+		return;
+
+	if (KDB_DEBUG(BP))
+		kdb_printf("regs->cr_iip = 0x%lx\n", regs->cr_iip);
+
+	/*
+	 * Setup single step
+	 */
+	kdba_setsinglestep(regs);
+
+	/*
+	 * Reset delay attribute
+	 */
+	bp->bp_delay = 0;
+	bp->bp_delayed = 1;
+}
+
+
+/*
+ * kdba_bptype
+ *
+ *	Return a string describing type of breakpoint.
+ *
+ * Parameters:
+ *	bph	Pointer to hardware breakpoint description
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Character string.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+char *
+kdba_bptype(kdbhard_bp_t *bph)
+{
+	char *mode;
+
+	mode = kdba_rwtypes[bph->bph_mode];
+
+	return mode;
+}
+
+/*
+ * kdba_printbpreg
+ *
+ *	Print register name assigned to breakpoint
+ *
+ * Parameters:
+ *	bph	Pointer hardware breakpoint structure
+ * Outputs:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+static void
+kdba_printbpreg(kdbhard_bp_t *bph)
+{
+	kdb_printf(" in dr%ld", bph->bph_reg);
+}
+
+/*
+ * kdba_printbp
+ *
+ *	Print string describing hardware breakpoint.
+ *
+ * Parameters:
+ *	bph	Pointer to hardware breakpoint description
+ * Outputs:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+void
+kdba_printbp(kdb_bp_t *bp)
+{
+	kdb_printf("\n    is enabled");
+	if (bp->bp_hardtype) {
+		kdba_printbpreg(bp->bp_hard);
+		if (bp->bp_hard->bph_mode != 0) {
+			kdb_printf(" for %d bytes",
+				   bp->bp_hard->bph_length+1);
+		}
+	}
+}
+
+/*
+ * kdba_parsebp
+ *
+ *	Parse architecture dependent portion of the
+ *	breakpoint command.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Zero for success, a kdb diagnostic for failure
+ * Locking:
+ *	None.
+ * Remarks:
+ *	for IA64 architure, data access, data write and
+ *	I/O breakpoints are supported in addition to instruction
+ *	breakpoints.
+ *
+ *	{datar|dataw|io|inst} [length]
+ */
+
+int
+kdba_parsebp(int argc, const char **argv, int *nextargp, kdb_bp_t *bp)
+{
+	int nextarg = *nextargp;
+	int diag;
+	kdbhard_bp_t *bph = &bp->bp_template;
+
+	bph->bph_mode = 0;		/* Default to instruction breakpoint */
+	bph->bph_length = 0;		/* Length must be zero for insn bp */
+	if ((argc + 1) != nextarg) {
+		if (strnicmp(argv[nextarg], "datar", sizeof("datar")) == 0) {
+			bph->bph_mode = 3;
+		} else if (strnicmp(argv[nextarg], "dataw", sizeof("dataw")) == 0) {
+			bph->bph_mode = 1;
+		} else if (strnicmp(argv[nextarg], "io", sizeof("io")) == 0) {
+			bph->bph_mode = 2;
+		} else if (strnicmp(argv[nextarg], "inst", sizeof("inst")) == 0) {
+			bph->bph_mode = 0;
+		} else {
+			return KDB_ARGCOUNT;
+		}
+
+		bph->bph_length = 3;	/* Default to 4 byte */
+
+		nextarg++;
+
+		if ((argc + 1) != nextarg) {
+			unsigned long len;
+
+			diag = kdbgetularg((char *)argv[nextarg],
+					   &len);
+			if (diag)
+				return diag;
+
+
+			if ((len > 4) || (len == 3))
+				return KDB_BADLENGTH;
+
+			bph->bph_length = len;
+			bph->bph_length--; /* Normalize for debug register */
+			nextarg++;
+		}
+
+		if ((argc + 1) != nextarg)
+			return KDB_ARGCOUNT;
+
+		/*
+		 * Indicate to architecture independent level that
+		 * a hardware register assignment is required to enable
+		 * this breakpoint.
+		 */
+
+		bph->bph_free = 0;
+	} else {
+		if (KDB_DEBUG(BP))
+			kdb_printf("kdba_bp: no args, forcehw is %d\n", bp->bp_forcehw);
+		if (bp->bp_forcehw) {
+			/*
+			 * We are forced to use a hardware register for this
+			 * breakpoint because either the bph or bpha
+			 * commands were used to establish this breakpoint.
+			 */
+			bph->bph_free = 0;
+		} else {
+			/*
+			 * Indicate to architecture dependent level that
+			 * the instruction replacement breakpoint technique
+			 * should be used for this breakpoint.
+			 */
+			bph->bph_free = 1;
+			bp->bp_adjust = 0;	/* software, break is fault, not trap */
+		}
+	}
+
+	if (bph->bph_mode == 0 && kdba_verify_rw(bp->bp_addr, bph->bph_length+1)) {
+		kdb_printf("Invalid address for breakpoint, ignoring bp command\n");
+		return KDB_BADADDR;
+	}
+
+	*nextargp = nextarg;
+	if (!bph->bph_free) {
+		kdb_printf("kdba_parsebp hardware breakpoints are not supported yet\n");
+		return KDB_NOTIMP;
+	}
+	return 0;
+}
+
+/*
+ * kdba_allocbp
+ *
+ *	Associate a hardware register with a breakpoint.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	A pointer to the allocated register kdbhard_bp_t structure for
+ *	success, Null and a non-zero diagnostic for failure.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+kdbhard_bp_t *
+kdba_allocbp(kdbhard_bp_t *bph, int *diagp)
+{
+	int i;
+	kdbhard_bp_t *newbph;
+
+	for(i=0,newbph=kdb_hardbreaks; i < KDB_MAXHARDBPT; i++, newbph++) {
+		if (newbph->bph_free) {
+			break;
+		}
+	}
+
+	if (i == KDB_MAXHARDBPT) {
+		*diagp = KDB_TOOMANYDBREGS;
+		return NULL;
+	}
+
+	*diagp = 0;
+
+	/*
+	 * Copy data from template.  Can't just copy the entire template
+	 * here because the register number in kdb_hardbreaks must be
+	 * preserved.
+	 */
+	newbph->bph_data = bph->bph_data;
+	newbph->bph_write = bph->bph_write;
+	newbph->bph_mode = bph->bph_mode;
+	newbph->bph_length = bph->bph_length;
+
+	/*
+	 * Mark entry allocated.
+	 */
+	newbph->bph_free = 0;
+
+	return newbph;
+}
+
+/*
+ * kdba_freebp
+ *
+ *	Deallocate a hardware breakpoint
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Zero for success, a kdb diagnostic for failure
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+void
+kdba_freebp(kdbhard_bp_t *bph)
+{
+	bph->bph_free = 1;
+}
+
+/*
+ * kdba_initbp
+ *
+ *	Initialize the breakpoint table for the hardware breakpoint
+ *	register.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Zero for success, a kdb diagnostic for failure
+ * Locking:
+ *	None.
+ * Remarks:
+ *
+ *	There is one entry per register.  On the ia64 architecture
+ *	all the registers are interchangeable, so no special allocation
+ *	criteria are required.
+ */
+
+void
+kdba_initbp(void)
+{
+	int i;
+	kdbhard_bp_t *bph;
+
+	/*
+	 * Clear the hardware breakpoint table
+	 */
+
+	memset(kdb_hardbreaks, '\0', sizeof(kdb_hardbreaks));
+
+	for(i=0,bph=kdb_hardbreaks; i<KDB_MAXHARDBPT; i++, bph++) {
+		bph->bph_reg = i;
+		bph->bph_free = 1;
+	}
+}
+
+/*
+ * kdba_installbp
+ *
+ *	Install a breakpoint
+ *
+ * Parameters:
+ *	regs	Exception frame
+ *	bp	Breakpoint structure for the breakpoint to be installed
+ * Outputs:
+ *	None.
+ * Returns:
+ *	0 if breakpoint set, otherwise error.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	For hardware breakpoints, a debug register is allocated
+ *	and assigned to the breakpoint.  If no debug register is
+ *	available, a warning message is printed and the breakpoint
+ *	is disabled.
+ *
+ *	For instruction replacement breakpoints, we must single-step
+ *	over the replaced instruction at this point so we can re-install
+ *	the breakpoint instruction after the single-step.  SSBPT is set
+ *	when the breakpoint is initially hit and is cleared by any action
+ *	that removes the need for single-step over the breakpoint.
+ */
+
+int
+kdba_installbp(struct pt_regs *regs, kdb_bp_t *bp)
+{
+	/*
+	 * Install the breakpoint, if it is not already installed.
+	 */
+
+	if (KDB_DEBUG(BP)) {
+		kdb_printf("kdba_installbp bp_installed %d\n", bp->bp_installed);
+	}
+	if (!KDB_STATE(SSBPT))
+		bp->bp_delay = 0;
+	if (!bp->bp_installed) {
+		if (bp->bp_hardtype) {
+			kdba_installdbreg(bp);
+			bp->bp_installed = 1;
+			if (KDB_DEBUG(BP)) {
+				kdb_printf("kdba_installbp hardware reg %ld at " kdb_bfd_vma_fmt0 "\n",
+					   bp->bp_hard->bph_reg, bp->bp_addr);
+			}
+		} else if (bp->bp_delay) {
+			if (KDB_DEBUG(BP))
+				kdb_printf("kdba_installbp delayed bp\n");
+			kdba_handle_bp(regs, bp);
+		} else {
+			/* Software breakpoints always use slot 0 in the 128 bit
+			 * bundle.  The template type does not matter, slot 0
+			 * can only be M or B and the encodings for break.m and
+			 * break.b are the same.
+			 */
+			unsigned long break_inst;
+			if (kdb_getarea_size(bp->bp_inst.inst, bp->bp_addr, sizeof(bp->bp_inst.inst))) {
+				kdb_printf("kdba_installbp failed to read software breakpoint at 0x%lx\n", bp->bp_addr);
+				return(1);
+			}
+			break_inst = (bp->bp_inst.inst[0] & ~INST_SLOT0_MASK) | BREAK_INSTR;
+			if (kdb_putarea_size(bp->bp_addr, &break_inst, sizeof(break_inst))) {
+				kdb_printf("kdba_installbp failed to set software breakpoint at 0x%lx\n", bp->bp_addr);
+				return(1);
+			}
+			if (KDB_DEBUG(BP))
+				kdb_printf("kdba_installbp instruction 0x%lx at " kdb_bfd_vma_fmt0 "\n",
+					   BREAK_INSTR, bp->bp_addr);
+			bp->bp_installed = 1;
+			flush_icache_range(bp->bp_addr, bp->bp_addr+16);
+		}
+	}
+	return(0);
+}
+
+/*
+ * kdba_removebp
+ *
+ *	Make a breakpoint ineffective.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	0 if breakpoint removed, otherwise error.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+int
+kdba_removebp(kdb_bp_t *bp)
+{
+	/*
+	 * For hardware breakpoints, remove it from the active register,
+	 * for software breakpoints, restore the instruction stream.
+	 */
+	if (KDB_DEBUG(BP)) {
+		kdb_printf("kdba_removebp bp_installed %d\n", bp->bp_installed);
+	}
+	if (bp->bp_installed) {
+		if (bp->bp_hardtype) {
+			if (KDB_DEBUG(BP)) {
+				kdb_printf("kdb: removing hardware reg %ld at " kdb_bfd_vma_fmt0 "\n",
+					   bp->bp_hard->bph_reg, bp->bp_addr);
+			}
+			kdba_removedbreg(bp);
+		} else {
+			if (KDB_DEBUG(BP))
+				kdb_printf("kdb: restoring instruction 0x%016lx%016lx at " kdb_bfd_vma_fmt0 "\n",
+					   bp->bp_inst.inst[0], bp->bp_inst.inst[1], bp->bp_addr);
+			if (kdba_putarea_size(bp->bp_addr, bp->bp_inst.inst, sizeof(bp->bp_inst.inst)))
+				return(1);
+		}
+		bp->bp_installed = 0;
+		flush_icache_range(bp->bp_addr, bp->bp_addr+16);
+	}
+	return(0);
+}
Index: linux/arch/ia64/kdb/kdba_bt.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/kdba_bt.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,289 @@
+/*
+ * Kernel Debugger Architecture Dependent Stack Traceback
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/config.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kallsyms.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <asm/system.h>
+
+/*
+ * bt_print_one
+ *
+ *	Print one back trace entry.
+ *
+ * Inputs:
+ *	ip	Current program counter.
+ *	symtab	Information about symbol that ip falls within.
+ *	ar	Activation record for this frame.
+ *	argcount Maximum number of arguments to print.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	None.
+ */
+
+static void
+bt_print_one(kdb_machreg_t ip, const kdb_ar_t *ar,
+	     const kdb_symtab_t *symtab, int argcount,
+	     struct unw_frame_info *info /* FIXME: should be part of ar for ia64 */)
+{
+	int btsymarg = 0;		/* Convert arguments to symbols */
+	int btsp = 0;			/* Print stack and backing store pointers */
+	int nosect = 0;			/* Suppress section data */
+	kdb_machreg_t sp, bsp, cfm;	/* FIXME: should be part of ar for ia64 */
+
+	kdbgetintenv("BTSYMARG", &btsymarg);
+	kdbgetintenv("BTSP", &btsp);
+	kdbgetintenv("NOSECT", &nosect);
+
+	unw_get_sp(info, &sp);		/* FIXME: should be part of ar for ia64 */
+	unw_get_bsp(info, &bsp);	/* FIXME: should be part of ar for ia64 */
+	unw_get_cfm(info, &cfm);	/* FIXME: info/cfm should be part of ar for ia64 */
+	kdb_symbol_print(ip, symtab, KDB_SP_VALUE|KDB_SP_NEWLINE);
+	/* FIXME: number of args should be set in prologue code */
+	((kdb_ar_t *)ar)->args = (cfm >> 7) & 0x7f;	/* sol */
+	if (!ar->args)
+		((kdb_ar_t *)ar)->args = cfm & 0x7f;	/* no in/local, use sof instead */
+	if (argcount && ar->args) {
+		int i, argc = ar->args;
+
+		kdb_printf("        args (");
+		if (argc > argcount)
+			argc = argcount;
+
+		for(i = 0; i < argc; i++){
+			/* FIXME: prologue code should extract arguments */
+			kdb_machreg_t arg;
+			char nat;
+			if (unw_access_gr(info, i+32, &arg, &nat, 0))
+				arg = 0;
+
+			if (i)
+				kdb_printf(", ");
+			kdb_printf("0x%lx", arg);
+		}
+		kdb_printf(")\n");
+		if (btsymarg) {
+			kdb_symtab_t	arg_symtab;
+			kdb_machreg_t	arg;
+			for(i = 0; i < argc; i++){
+				/* FIXME: prologue code should extract arguments */
+				char nat;
+				if (unw_access_gr(info, i+32, &arg, &nat, 0))
+					arg = 0;
+				if (kdbnearsym(arg, &arg_symtab)) {
+					kdb_printf("        arg %d ", i);
+					kdb_symbol_print(arg, &arg_symtab, KDB_SP_DEFAULT|KDB_SP_NEWLINE);
+				}
+			}
+		}
+	}
+	if (symtab->sym_name) {
+		if (!nosect) {
+			kdb_printf("        %s", symtab->mod_name);
+			if (symtab->sec_name)
+				kdb_printf(" %s 0x%lx", symtab->sec_name, symtab->sec_start);
+			kdb_printf(" 0x%lx", symtab->sym_start);
+			if (symtab->sym_end)
+				kdb_printf(" 0x%lx", symtab->sym_end);
+			kdb_printf("\n");
+		}
+		if (strncmp(symtab->sym_name, "ia64_spinlock_contention", 24) == 0) {
+			kdb_machreg_t r31;
+			char nat;
+			kdb_printf("        r31 (spinlock address) ");
+			if (unw_access_gr(info, 31, &r31, &nat, 0))
+				r31 = 0;
+			kdb_symbol_print(r31, NULL, KDB_SP_VALUE|KDB_SP_NEWLINE);
+		}
+	}
+	if (btsp)
+		kdb_printf("        sp 0x%016lx bsp 0x%016lx cfm 0x%016lx info->pfs_loc 0x%016lx 0x%016lx\n",
+				sp, bsp, cfm, (u64) info->pfs_loc, info->pfs_loc ? *(info->pfs_loc) : 0);
+}
+
+/*
+ * kdba_bt_stack
+ *
+ *	Unwind the ia64 backtrace for a specified process.
+ *
+ * Inputs:
+ *	argcount
+ *	p	Pointer to task structure to unwind.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	none.
+ */
+
+static int
+kdba_bt_stack(int argcount, struct task_struct *p)
+{
+	kdb_symtab_t symtab;
+	kdb_ar_t ar;
+	struct unw_frame_info info;	/* FIXME: should be part of ar */
+	struct switch_stack *sw;	/* FIXME: should be part of ar */
+	struct pt_regs *regs = NULL;	/* FIXME: should be part of ar */
+	int count = 0;
+	int btsp = 0;			/* Backtrace the kdb code as well */
+	u64 *prev_pfs_loc = NULL;
+	extern char __attribute__ ((weak)) ia64_spinlock_contention_pre3_4[];
+	extern char __attribute__ ((weak)) ia64_spinlock_contention_pre3_4_end[];
+	extern char ia64_ivt[];
+
+	/* FIXME: All the arch specific code should be in activation records, not here */
+	memset(&ar, 0, sizeof(ar));
+
+	/*
+	 * Upon entering kdb_main_loop, the stack frame looks like this:
+	 *
+	 *	+---------------------+
+	 *	|   struct pt_regs    |
+	 *	+---------------------+
+	 *	|		      |
+	 *	|   kernel stack      |
+	 *	|		      |
+	 *	+=====================+ <--- top of stack upon entering kdb
+	 *	|   struct pt_regs    |
+	 *	+---------------------+
+	 *	|		      |
+	 *	|   kdb stack         |
+	 *	|		      |
+	 *	+---------------------+
+	 *	| struct switch_stack |
+	 *	+=====================+ <--- kdb_running_process[cpu].arch.sw from do_kdba_main_loop
+	 *
+	 * When looking at another process, we do not have the address of the
+	 * current pt_regs, it is NULL.  If the process has saved its state, use
+	 * that pt_regs instead.
+	 */
+
+	kdbgetintenv("BTSP", &btsp);
+
+	if (kdb_task_has_cpu(p)) {
+		struct kdb_running_process *krp = kdb_running_process + kdb_process_cpu(p);
+		if (krp->seqno) {
+			sw = krp->arch.sw;
+			regs = krp->regs;
+		}
+		else
+			sw = NULL;
+	}
+	else {
+		/* Not running, assume blocked */
+		sw = (struct switch_stack *) (p->thread.ksp + 16);
+	}
+	if (!sw) {
+		kdb_printf("Process does not have a switch_stack, cannot backtrace\n");
+		kdb_ps1(p);
+		return 0;
+	}
+
+	unw_init_frame_info(&info, p, sw);	/* FIXME: should be using activation records */
+
+	/* If we have the address of pt_regs, suppress backtrace on the frames below
+	 * pt_regs.  No point in displaying kdb itself, unless the user is debugging
+	 * the unwinder using set BTSP=1.
+	 */
+	if (regs && !btsp) {
+		kdb_machreg_t sp;		/* FIXME: should be part of ar for ia64 */
+		if (user_mode(regs)) {
+			kdb_printf("Process was interrupted in user mode, no backtrace available\n");
+			return 0;
+		}
+		do {
+			unw_get_sp(&info, &sp);
+			if (sp >= (kdb_machreg_t)regs)
+				break;
+		} while (unw_unwind(&info) >= 0 && count++ < 200);	/* FIXME: should be using activation records */
+	}
+
+	do {
+		kdb_machreg_t ip;
+
+		/* Avoid unsightly console message from unw_unwind() when attempting
+		 * to unwind through the Interrupt Vector Table which has no unwind
+		 * information.
+		 */
+		if (info.ip >= (u64)ia64_ivt && info.ip < (u64)ia64_ivt+32768)
+			return 0;
+
+		/* WAR for spinlock contention from leaf functions.  ia64_spinlock_contention_pre3_4
+		 * has ar.pfs == r0.  Leaf functions do not modify ar.pfs so ar.pfs remains
+		 * as 0, stopping the backtrace.  Record the previous ar.pfs when the current
+		 * IP is in ia64_spinlock_contention_pre3_4 then unwind, if pfs_loc has not changed
+		 * after unwind then use pt_regs.ar_pfs which is where the real ar.pfs is for
+		 * leaf functions.
+		 */
+		if (prev_pfs_loc && regs && info.pfs_loc == prev_pfs_loc)
+			info.pfs_loc = &regs->ar_pfs;
+		prev_pfs_loc = (info.ip >= (u64)ia64_spinlock_contention_pre3_4 &&
+				info.ip < (u64)ia64_spinlock_contention_pre3_4_end) ?
+			       info.pfs_loc : NULL;
+
+		unw_get_ip(&info, &ip);	/* FIXME: should be using activation records */
+		if (ip == 0)
+			break;
+
+		kdbnearsym(ip, &symtab);
+		if (!symtab.sym_name) {
+			kdb_printf("0x%0*lx - No name.  May be an area that has no unwind data\n",
+				(int)(2*sizeof(ip)), ip);
+			return 0;
+		}
+		bt_print_one(ip, &ar, &symtab, argcount, &info);
+	} while (unw_unwind(&info) >= 0 && count++ < 200);	/* FIXME: should be using activation records */
+	if (count >= 200)
+		kdb_printf("bt truncated, count limit reached\n");
+
+	return 0;
+}
+
+int
+kdba_bt_address(kdb_machreg_t addr, int argcount)
+{
+	kdb_printf("Backtrace from a stack address is not supported on ia64\n");
+	return KDB_NOTIMP;
+}
+
+/*
+ * kdba_bt_process
+ *
+ *	Do a backtrace for a specified process.
+ *
+ * Inputs:
+ *	p	Struct task pointer extracted by 'bt' command.
+ *	argcount
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ */
+
+int
+kdba_bt_process(struct task_struct *p, int argcount)
+{
+	return kdba_bt_stack(argcount, p);
+}
Index: linux/arch/ia64/kdb/kdba_fru.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/kdba_fru.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,67 @@
+/*
+ * Kernel Debugger Architecture Dependent FRU functions.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/types.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <linux/module.h>
+#include <asm/sal.h>
+#include <asm/sn/sn_sal.h>
+
+MODULE_AUTHOR("Jesse Barnes");
+MODULE_DESCRIPTION("Capture FRU data");
+MODULE_LICENSE("GPL");
+
+/**
+ * kdba_fru - capture FRU data
+ * @argc: arg count
+ * @argv: arg values
+ * @envp: kdb env. vars
+ * @regs: current register state
+ *
+ * Tell the system contollers to capture FRU data
+ */
+static int
+kdba_fru(int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	u64 ret;
+
+	kdb_printf("Capturing FRU data...");
+	ret = ia64_sn_fru_capture();
+	kdb_printf("done.\n");
+	return ret;
+}
+
+/**
+ * kdba_fru_init - register 'fru' command with kdb
+ *
+ * Register the 'fru' command with kdb at load time.
+ */
+static int __init
+kdba_fru_init(void)
+{
+	kdb_register("fru", kdba_fru, 0, "Capture FRU data", 0);
+
+	return 0;
+}
+
+/**
+ * kdba_fru_exit - unregister the 'fru' command
+ *
+ * Tell kdb that the 'fru' command is no longer available.
+ */
+static void __exit
+kdba_fru_exit(void)
+{
+	kdb_unregister("fru");
+}
+
+kdb_module_init(kdba_fru_init)
+kdb_module_exit(kdba_fru_exit)
Index: linux/arch/ia64/kdb/kdba_id.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/kdba_id.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,274 @@
+/*
+ * Kernel Debugger Architecture Dependent Instruction Disassembly
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <stdarg.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+
+#define KDBA_PRINTBUF_LEN	64	/* buffer len to print a single instr */
+#define KDBA_READBUFFER_LEN	256	/* buffer for BFD disassembler */
+
+#define BUNDLE_MULTIPLIER	3	/* how many instr/bundle */
+#define BUNDLE_SIZE		16	/* how many bytes/bundle */
+#define KDBA_DEFAULT_IDLEN	3	/* default number of bundles to disassemble */
+
+/*
+ * kdba_dis_getsym
+ *
+ *	Get a symbol for the disassembler.
+ *
+ * Parameters:
+ *	addr	Address for which to get symbol
+ *	dip	Pointer to disassemble_info
+ * Returns:
+ *	0
+ * Locking:
+ * Remarks:
+ *	Not used for kdb.
+ */
+
+/* ARGSUSED */
+static int
+kdba_dis_getsym(bfd_vma addr, disassemble_info *dip)
+{
+
+	return 0;
+}
+
+/*
+ * kdba_printaddress
+ *
+ *	Print (symbolically) an address.
+ *
+ * Parameters:
+ *	addr	Address for which to get symbol
+ *	dip	Pointer to disassemble_info
+ *	flag	True if a ":<tab>" sequence should follow the address
+ * Returns:
+ *	0
+ * Locking:
+ * Remarks:
+ *
+ */
+
+/* ARGSUSED */
+static void
+kdba_printaddress(kdb_machreg_t addr, disassemble_info *dip, int flag)
+{
+	kdb_symtab_t symtab;
+	int spaces = 5;
+	unsigned int offset;
+	int slot;
+
+	/* Some code prints slot number, some prints "byte" offset
+	 * from start of bundle.  Standardise on "byte" offset.
+	 */
+	slot = addr & 0x0f;
+	if (slot < 3)
+		slot *= 6;
+	addr = (addr & ~0x0f) + slot;
+
+	/*
+	 * Print a symbol name or address as necessary.
+	 */
+	dip->fprintf_func(dip->stream, "0x%0*lx ", 2*sizeof(addr), addr);
+	kdbnearsym(addr, &symtab);
+	if (symtab.sym_name) {
+		/* Do not use kdb_symbol_print here, it always does
+		 * kdb_printf but we want dip->fprintf_func.
+		 */
+		dip->fprintf_func(dip->stream, "%s", symtab.sym_name);
+		if ((offset = addr - symtab.sym_start) == 0) {
+			spaces += 4;
+		}
+		else {
+			unsigned int o = offset;
+			while (o >>= 4)
+				--spaces;
+			dip->fprintf_func(dip->stream, "+0x%x", offset);
+		}
+	}
+
+	if (flag) {
+		if (spaces < 1) {
+			spaces = 1;
+		}
+		dip->fprintf_func(dip->stream, ":%*s", spaces, " ");
+	}
+}
+
+/*
+ * kdba_dis_printaddr
+ *
+ *	Print (symbolically) an address.  Called by GNU disassembly
+ *	code via disassemble_info structure.
+ *
+ * Parameters:
+ *	addr	Address for which to get symbol
+ *	dip	Pointer to disassemble_info
+ * Returns:
+ *	0
+ * Locking:
+ * Remarks:
+ *	This function will never append ":<tab>" to the printed
+ *	symbolic address.
+ */
+
+static void
+kdba_dis_printaddr(bfd_vma addr, disassemble_info *dip)
+{
+	kdba_printaddress(addr, dip, 0);
+}
+
+/*
+ * kdba_dis_getmem
+ *
+ *	Fetch 'length' bytes from 'addr' into 'buf'.
+ *
+ * Parameters:
+ *	addr	Address for which to get symbol
+ *	buf	Address of buffer to fill with bytes from 'addr'
+ *	length	Number of bytes to fetch
+ *	dip	Pointer to disassemble_info
+ * Returns:
+ *	0
+ * Locking:
+ * Remarks:
+ *
+ */
+
+/* ARGSUSED */
+static int
+kdba_dis_getmem(bfd_vma addr, bfd_byte *buf, unsigned int length, disassemble_info *dip)
+{
+	return kdb_getarea_size(buf, addr, length);
+}
+
+/*
+ * kdba_id_parsemode
+ *
+ * 	Parse IDMODE environment variable string and
+ *	set appropriate value into "disassemble_info" structure.
+ *
+ * Parameters:
+ *	mode	Mode string
+ *	dip	Disassemble_info structure pointer
+ * Returns:
+ * Locking:
+ * Remarks:
+ *	No mode supported yet.
+ */
+
+int
+kdba_id_parsemode(const char *mode, disassemble_info *dip)
+{
+	if (mode && strcmp(mode, "ia64"))
+		return KDB_BADMODE;
+	return 0;
+}
+
+/*
+ * kdba_check_pc
+ *
+ * 	Check that the pc is satisfactory.
+ *
+ * Parameters:
+ *	pc	Program Counter Value.
+ * Returns:
+ *	None
+ * Locking:
+ *	None.
+ * Remarks:
+ *	Can change pc.
+ */
+
+void
+kdba_check_pc(kdb_machreg_t *pc)
+{
+	(*pc) &= ~0xf;	/* pc must be 16 byte aligned */
+}
+
+/*
+ * kdba_id_printinsn
+ *
+ * 	Format and print a single bundle at 'pc'. Return the
+ *	length of the bundle.
+ *
+ * Parameters:
+ *	pc	Program Counter Value.
+ *	dip	Disassemble_info structure pointer
+ * Returns:
+ *	Length of instruction, -1 for error.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	None.
+ */
+
+int
+kdba_id_printinsn(kdb_machreg_t pc, disassemble_info *dip)
+{
+	int ret;
+	int byte = 0;
+	int off = 0;
+
+	dip->fprintf_func = dip->fprintf_dummy;
+	off = pc & 0xf;
+	kdba_check_pc(&pc);
+	while (byte < 16) {
+		if (byte == off)
+			dip->fprintf_func = kdb_dis_fprintf;
+		else
+			dip->fprintf_func = dip->fprintf_dummy;
+		kdba_dis_printaddr(pc+byte, dip);
+		ret = print_insn_ia64((kdb_machreg_t)(pc+byte), dip);
+		dip->fprintf_func(dip->stream, "\n");
+		if (ret < 0)
+			break;
+		byte += ret;
+	}
+	return(byte);
+}
+
+/*
+ * kdba_id_init
+ *
+ * 	Initialize the architecture dependent elements of
+ *	the disassembly information structure
+ *	for the GNU disassembler.
+ *
+ * Parameters:
+ *	None.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+
+void __init
+kdba_id_init(disassemble_info *dip)
+{
+	dip->read_memory_func       = kdba_dis_getmem;
+	dip->print_address_func     = kdba_dis_printaddr;
+	dip->symbol_at_address_func = kdba_dis_getsym;
+
+	dip->flavour                = bfd_target_elf_flavour;
+	dip->arch		    = bfd_arch_ia64;
+	dip->endian	    	    = BFD_ENDIAN_LITTLE;
+
+	dip->display_endian         = BFD_ENDIAN_LITTLE;
+}
Index: linux/arch/ia64/kdb/kdba_io.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/kdba_io.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,557 @@
+/*
+ * Kernel Debugger Architecture Dependent Console I/O handler
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/console.h>
+#include <linux/ctype.h>
+#include <linux/keyboard.h>
+#include <linux/serial.h>
+#include <linux/serial_reg.h>
+
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+
+#if defined(CONFIG_SERIAL_8250_CONSOLE) || defined(CONFIG_SERIAL_SGI_L1_CONSOLE)
+#define HAVE_KDBA_SERIAL_CONSOLE
+#endif
+
+/* from include/linux/pc_keyb.h on 2.4 */
+#define KBD_STATUS_REG		0x64	/* Status register (R) */
+#define KBD_DATA_REG		0x60	/* Keyboard data register (R/W) */
+#define KBD_CMD_SET_LEDS	0xED	/* Set keyboard leds */
+#define KBD_STAT_OBF 		0x01	/* Keyboard output buffer full */
+#define KBD_STAT_IBF 		0x02	/* Keyboard input buffer full */
+#define KBD_STAT_MOUSE_OBF	0x20	/* Mouse output buffer full */
+
+#ifdef	CONFIG_VT_CONSOLE
+#define KDB_BLINK_LED 1
+#else
+#undef	KDB_BLINK_LED
+#endif
+
+#ifdef CONFIG_KDB_USB
+struct kdb_usb_exchange kdb_usb_infos = { NULL, NULL, NULL, NULL, NULL, 0};
+
+static unsigned char kdb_usb_keycode[256] = {
+	  0,  0,  0,  0, 30, 48, 46, 32, 18, 33, 34, 35, 23, 36, 37, 38,
+	 50, 49, 24, 25, 16, 19, 31, 20, 22, 47, 17, 45, 21, 44,  2,  3,
+	  4,  5,  6,  7,  8,  9, 10, 11, 28,  1, 14, 15, 57, 12, 13, 26,
+	 27, 43, 84, 39, 40, 41, 51, 52, 53, 58, 59, 60, 61, 62, 63, 64,
+	 65, 66, 67, 68, 87, 88, 99, 70,119,110,102,104,111,107,109,106,
+	105,108,103, 69, 98, 55, 74, 78, 96, 79, 80, 81, 75, 76, 77, 71,
+	 72, 73, 82, 83, 86,127,116,117, 85, 89, 90, 91, 92, 93, 94, 95,
+	120,121,122,123,134,138,130,132,128,129,131,137,133,135,136,113,
+	115,114,  0,  0,  0,124,  0,181,182,183,184,185,186,187,188,189,
+	190,191,192,193,194,195,196,197,198,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+	 29, 42, 56,125, 97, 54,100,126,164,166,165,163,161,115,114,113,
+	150,158,159,128,136,177,178,176,142,152,173,140
+};
+
+/* get_usb_char
+ * This function drives the UHCI controller,
+ * fetch the USB scancode and decode it
+ */
+static int get_usb_char(void)
+{
+	static int usb_lock;
+	unsigned char keycode, spec;
+	extern u_short plain_map[], shift_map[], ctrl_map[];
+
+	/* Is USB initialized ? */
+	if(!kdb_usb_infos.poll_func)
+		return -1;
+
+	/* Transfer char if they are present */
+	(*kdb_usb_infos.poll_func)(kdb_usb_infos.uhci, (struct urb *)kdb_usb_infos.urb);
+
+	spec = kdb_usb_infos.buffer[0];
+	keycode = kdb_usb_infos.buffer[2];
+	kdb_usb_infos.buffer[0] = (char)0;
+	kdb_usb_infos.buffer[2] = (char)0;
+
+	if(kdb_usb_infos.buffer[3])
+		return -1;
+
+	/* A normal key is pressed, decode it */
+	if(keycode)
+		keycode = kdb_usb_keycode[keycode];
+
+	/* 2 Keys pressed at one time ? */
+	if (spec && keycode) {
+		switch(spec)
+		{
+			case 0x2:
+			case 0x20: /* Shift */
+				return shift_map[keycode];
+			case 0x1:
+			case 0x10: /* Ctrl */
+				return ctrl_map[keycode];
+			case 0x4:
+			case 0x40: /* Alt */
+				break;
+		}
+	}
+	else {
+		if(keycode) { /* If only one key pressed */
+			switch(keycode)
+			{
+				case 0x1C: /* Enter */
+					return 13;
+
+				case 0x3A: /* Capslock */
+					usb_lock ? (usb_lock = 0) : (usb_lock = 1);
+					break;
+				case 0x0E: /* Backspace */
+					return 8;
+				case 0x0F: /* TAB */
+					return 9;
+				case 0x77: /* Pause */
+					break ;
+				default:
+					if(!usb_lock) {
+						return plain_map[keycode];
+					}
+					else {
+						return shift_map[keycode];
+					}
+			}
+		}
+	}
+	return -1;
+}
+#endif
+
+/*
+ * This module contains code to read characters from the keyboard or a serial
+ * port.
+ *
+ * It is used by the kernel debugger, and is polled, not interrupt driven.
+ *
+ */
+
+#ifdef	KDB_BLINK_LED
+/*
+ * send:  Send a byte to the keyboard controller.  Used primarily to
+ * 	  alter LED settings.
+ */
+
+static void
+kdb_kbdsend(unsigned char byte)
+{
+	while (inb(KBD_STATUS_REG) & KBD_STAT_IBF)
+		;
+	outb(byte, KBD_DATA_REG);
+}
+
+static void
+kdb_toggleled(int led)
+{
+	static int leds;
+
+	leds ^= led;
+
+	kdb_kbdsend(KBD_CMD_SET_LEDS);
+	kdb_kbdsend((unsigned char)leds);
+}
+#endif	/* KDB_BLINK_LED */
+
+#ifdef	HAVE_KDBA_SERIAL_CONSOLE
+
+struct kdb_serial kdb_serial;
+enum kdba_serial_console kdba_serial_console;
+static int get_serial_char(void);
+
+/* There must be a serial_inp_xxx() and get_serial_char_xxx() for each type
+ * of console.  See enum kdba_serial_console in include/asm-$(ARCH)/kdbprivate.h.
+ */
+
+#ifdef	CONFIG_SERIAL_8250_CONSOLE
+
+static unsigned int
+serial_inp_standard(const struct kdb_serial *kdb_serial, int offset)
+{
+	offset <<= kdb_serial->ioreg_shift;
+
+	switch (kdb_serial->io_type) {
+	case SERIAL_IO_MEM:
+		return readb(kdb_serial->iobase + offset);
+		break;
+	default:
+		return inb(kdb_serial->iobase + offset);
+		break;
+	}
+}
+
+/* Check if there is a byte ready at the serial port */
+static int
+get_serial_char_standard(void)
+{
+	unsigned char ch;
+	static unsigned long fifon;
+	if (fifon == 0) {
+		/* try to set the FIFO */
+		fifon = kdb_serial.iobase +
+			(UART_FCR << kdb_serial.ioreg_shift);
+		switch (kdb_serial.io_type) {
+		case SERIAL_IO_MEM:
+			writeb((UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |
+				UART_FCR_CLEAR_XMIT), fifon);
+			break;
+		default:
+			outb((UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |
+				UART_FCR_CLEAR_XMIT), fifon);
+			break;
+		}
+	}
+
+	if (kdb_serial.iobase == 0)
+		return -1;
+
+	if (serial_inp_standard(&kdb_serial, UART_LSR) & UART_LSR_DR) {
+		ch = serial_inp_standard(&kdb_serial, UART_RX);
+		if (ch == 0x7f)
+			ch = 8;
+		return ch;
+	}
+	return -1;
+}
+
+#else	/* !CONFIG_SERIAL_8250_CONSOLE */
+
+#define get_serial_char_standard() -1
+
+#endif	/* CONFIG_SERIAL_8250_CONSOLE */
+
+#ifdef CONFIG_SERIAL_SGI_L1_CONSOLE
+
+extern u64 master_node_bedrock_address;
+
+/* UART registers on the Bedrock start at 0x80 */
+
+extern int l1_serial_in_polled(void);
+extern int l1_control_in_polled(int);
+
+/* Read a byte from the L1 port.  kdb_serial is ignored */
+static unsigned int
+serial_inp_sgi_l1(const struct kdb_serial *kdb_serial, int offset)
+{
+	if (offset & 0x80) {
+		int counter = 10000;
+		unsigned int value;
+		while ( counter-- ) {
+			value = l1_serial_in_polled();
+			/* Gobble up the 0's */
+			if ( value )
+				return(value);
+		}
+		return(0);
+	}
+	else {
+		return l1_control_in_polled(offset);
+	}
+}
+
+/* Check if there is a byte ready at the L1 port. */
+static int
+get_serial_char_sgi_l1(void)
+{
+	unsigned char ch;
+	int status;
+
+	if ((status = serial_inp_sgi_l1(&kdb_serial, UART_LSR)) & UART_LSR_DR) {
+		ch = serial_inp_sgi_l1(&kdb_serial, UART_RX | 0x80);	/* bedrock offset */
+		if (ch == 0x7f)
+			ch = 8;
+		return ch;
+	}
+	return -1;
+}
+
+#else	/* !CONFIG_SERIAL_SGI_L1_CONSOLE */
+
+#define get_serial_char_sgi_l1() -1
+
+#endif	/* CONFIG_SERIAL_SGI_L1_CONSOLE */
+
+/* Select the serial console input at run time, to handle generic kernels */
+
+static int
+get_serial_char(void)
+{
+	switch (kdba_serial_console) {
+	case KDBA_SC_NONE:
+		return -1;
+	case KDBA_SC_STANDARD:
+		return get_serial_char_standard();
+	case KDBA_SC_SGI_L1:
+		return get_serial_char_sgi_l1();
+	}
+	/* gcc is not smart enough to realize that all paths return before here :( */
+	return -1;
+}
+
+#endif /* HAVE_KDBA_SERIAL_CONSOLE */
+
+#ifdef	CONFIG_VT_CONSOLE
+
+static int kbd_exists = -1;
+
+/*
+ * Check if the keyboard controller has a keypress for us.
+ * Some parts (Enter Release, LED change) are still blocking polled here,
+ * but hopefully they are all short.
+ */
+static int get_kbd_char(void)
+{
+	int scancode, scanstatus;
+	static int shift_lock;	/* CAPS LOCK state (0-off, 1-on) */
+	static int shift_key;	/* Shift next keypress */
+	static int ctrl_key;
+	u_short keychar;
+	extern u_short plain_map[], shift_map[], ctrl_map[];
+
+	if (kbd_exists <= 0) {
+		if (kbd_exists == 0)
+			return -1;
+
+		if (inb(KBD_STATUS_REG) == 0xff && inb(KBD_DATA_REG) == 0xff) {
+			kbd_exists = 0;
+			return -1;
+		}
+		kbd_exists = 1;
+	}
+
+	if ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)
+		return -1;
+
+	/*
+	 * Fetch the scancode
+	 */
+	scancode = inb(KBD_DATA_REG);
+	scanstatus = inb(KBD_STATUS_REG);
+
+	/*
+	 * Ignore mouse events.
+	 */
+	if (scanstatus & KBD_STAT_MOUSE_OBF)
+		return -1;
+
+	/*
+	 * Ignore release, trigger on make
+	 * (except for shift keys, where we want to
+	 *  keep the shift state so long as the key is
+	 *  held down).
+	 */
+
+	if (((scancode&0x7f) == 0x2a) || ((scancode&0x7f) == 0x36)) {
+		/*
+		 * Next key may use shift table
+		 */
+		if ((scancode & 0x80) == 0) {
+			shift_key=1;
+		} else {
+			shift_key=0;
+		}
+		return -1;
+	}
+
+	if ((scancode&0x7f) == 0x1d) {
+		/*
+		 * Left ctrl key
+		 */
+		if ((scancode & 0x80) == 0) {
+			ctrl_key = 1;
+		} else {
+			ctrl_key = 0;
+		}
+		return -1;
+	}
+
+	if ((scancode & 0x80) != 0)
+		return -1;
+
+	scancode &= 0x7f;
+
+	/*
+	 * Translate scancode
+	 */
+
+	if (scancode == 0x3a) {
+		/*
+		 * Toggle caps lock
+		 */
+		shift_lock ^= 1;
+
+#ifdef	KDB_BLINK_LED
+		kdb_toggleled(0x4);
+#endif
+		return -1;
+	}
+
+	if (scancode == 0x0e) {
+		/*
+		 * Backspace
+		 */
+		return 8;
+	}
+
+	/* Special Key */
+	switch (scancode) {
+	case 0xF: /* Tab */
+		return 9;
+	case 0x53: /* Del */
+		return 4;
+	case 0x47: /* Home */
+		return 1;
+	case 0x4F: /* End */
+		return 5;
+	case 0x4B: /* Left */
+		return 2;
+	case 0x48: /* Up */
+		return 16;
+	case 0x50: /* Down */
+		return 14;
+	case 0x4D: /* Right */
+		return 6;
+	}
+
+	if (scancode == 0xe0) {
+		return -1;
+	}
+
+	/*
+	 * For Japanese 86/106 keyboards
+	 * 	See comment in drivers/char/pc_keyb.c.
+	 * 	- Masahiro Adegawa
+	 */
+	if (scancode == 0x73) {
+		scancode = 0x59;
+	} else if (scancode == 0x7d) {
+		scancode = 0x7c;
+	}
+
+	if (!shift_lock && !shift_key && !ctrl_key) {
+		keychar = plain_map[scancode];
+	} else if (shift_lock || shift_key) {
+		keychar = shift_map[scancode];
+	} else if (ctrl_key) {
+		keychar = ctrl_map[scancode];
+	} else {
+		keychar = 0x0020;
+		kdb_printf("Unknown state/scancode (%d)\n", scancode);
+	}
+	keychar &= 0x0fff;
+	switch (KTYP(keychar)) {
+	case KT_LETTER:
+	case KT_LATIN:
+		if (isprint(keychar))
+			break;		/* printable characters */
+		/* drop through */
+	case KT_SPEC:
+		if (keychar == K_ENTER)
+			break;
+		/* drop through */
+	default:
+		return(-1);	/* ignore unprintables */
+	}
+
+	if ((scancode & 0x7f) == 0x1c) {
+		/*
+		 * enter key.  All done.  Absorb the release scancode.
+		 */
+		while ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)
+			;
+
+		/*
+		 * Fetch the scancode
+		 */
+		scancode = inb(KBD_DATA_REG);
+		scanstatus = inb(KBD_STATUS_REG);
+
+		while (scanstatus & KBD_STAT_MOUSE_OBF) {
+			scancode = inb(KBD_DATA_REG);
+			scanstatus = inb(KBD_STATUS_REG);
+		}
+
+		if (scancode != 0x9c) {
+			/*
+			 * Wasn't an enter-release,  why not?
+			 */
+			kdb_printf("kdb: expected enter got 0x%x status 0x%x\n",
+			       scancode, scanstatus);
+		}
+
+		kdb_printf("\n");
+		return 13;
+	}
+
+	return keychar & 0xff;
+}
+#endif	/* CONFIG_VT_CONSOLE */
+
+#ifdef KDB_BLINK_LED
+
+/* Leave numlock alone, setting it messes up laptop keyboards with the keypad
+ * mapped over normal keys.
+ */
+static int kdba_blink_mask = 0x1 | 0x4;
+
+#ifdef CONFIG_SMP
+#define BOGOMIPS (local_cpu_data->loops_per_jiffy/(500000/HZ))
+#else
+#define BOGOMIPS (loops_per_jiffy/(500000/HZ))
+#endif
+static int blink_led(void)
+{
+	static long delay;
+
+	if (kbd_exists == 0)
+		return -1;
+
+	if (--delay < 0) {
+		if (BOGOMIPS == 0)	/* early kdb */
+			delay = 150000000/1000;     /* arbitrary bogomips */
+		else
+			delay = 150000000/BOGOMIPS; /* Roughly 1 second when polling */
+		kdb_toggleled(kdba_blink_mask);
+	}
+	return -1;
+}
+#endif
+
+get_char_func poll_funcs[] = {
+#if defined(CONFIG_VT_CONSOLE)
+	get_kbd_char,
+#endif
+#ifdef	HAVE_KDBA_SERIAL_CONSOLE
+	get_serial_char,
+#endif
+#ifdef KDB_BLINK_LED
+	blink_led,
+#endif
+#ifdef CONFIG_KDB_USB
+	get_usb_char,
+#endif
+	NULL
+};
+
+/* Dummy versions of kdba_local_arch_setup, kdba_local_arch_cleanup.
+ * FIXME: ia64 with legacy keyboard might need the same code as i386.
+ */
+
+void kdba_local_arch_setup(void) {}
+void kdba_local_arch_cleanup(void) {}
Index: linux/arch/ia64/kdb/kdba_jmp.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/kdba_jmp.S	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,394 @@
+/*
+ * Kernel Debugger Architecture Dependent Longjump Support.
+ */
+
+/* setjmp() and longjmp() assembler support for kdb on ia64.
+
+   This code was copied from glibc CVS as of 2001-06-27 and modified where
+   necessary to fit the kernel.  No glibc lines were changed or deleted, all
+   adjustments are wrapped in #ifdef __KERNEL__, except for the added
+   .mem.offset lines, they work in or out of the kenrel.  The original code is
+   in sysdeps/unix/sysv/linux/ia64/{setjmp.S,__longjmp.S}.
+
+   glibc has setjmp (save signals) and _setjmp (do not save signals).  Kernel
+   code does not have signals, only kdba_setjmp_asm() is used.
+
+   Keith Owens <kaos@melbourne.sgi.com> 2001-06-27
+ */
+
+/* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   The layout of the jmp_buf is as follows.  This is subject to change
+   and user-code should never depend on the particular layout of
+   jmp_buf!
+
+
+  	offset:	description:
+	-------	------------
+  	0x000	stack pointer (r12)	; unchangeable (see _JMPBUF_UNWINDS)
+  	0x008	r1 (gp)
+	0x010	caller's unat
+	0x018	fpsr
+  	0x020	r4
+  	0x028	r5
+  	0x030	r6
+  	0x038	r7
+  	0x040	rp (b0)
+  	0x048	b1
+  	0x050	b2
+  	0x058	b3
+  	0x060	b4
+  	0x068	b5
+  	0x070	ar.pfs
+  	0x078	ar.lc
+  	0x080	pr
+  	0x088	ar.bsp			; unchangeable (see __longjmp.S)
+  	0x090	ar.unat
+	0x098	&__jmp_buf	; address of the jmpbuf (needed to locate NaT bits in unat)
+	0x0a0	 f2
+	0x0b0	 f3
+	0x0c0	 f4
+	0x0d0	 f5
+	0x0e0	f16
+  	0x0f0	f17
+  	0x100	f18
+  	0x110	f19
+  	0x120	f20
+  	0x130	f21
+  	0x130	f22
+  	0x140	f23
+  	0x150	f24
+  	0x160	f25
+  	0x170	f26
+  	0x180	f27
+  	0x190	f28
+  	0x1a0	f29
+  	0x1b0	f30
+  	0x1c0	f31 */
+
+#ifndef __KERNEL__
+
+#include <sysdep.h>
+#include <features.h>
+
+	/* The following two entry points are the traditional entry points: */
+
+LEAF(setjmp)
+	alloc r8=ar.pfs,2,0,0,0
+	mov in1=1
+	br.cond.sptk.many __sigsetjmp
+END(setjmp)
+
+LEAF(_setjmp)
+	alloc r8=ar.pfs,2,0,0,0
+	mov in1=0
+	br.cond.sptk.many __sigsetjmp
+END(_setjmp)
+
+	/* __sigsetjmp(__jmp_buf buf, int savemask) */
+
+ENTRY(__sigsetjmp)
+
+#else	/* __KERNEL __ */
+#include <asm/asmmacro.h>
+#define ret br.ret.sptk.few rp
+GLOBAL_ENTRY(kdba_setjmp)
+#endif	/* !__KERNEL__ */
+
+	.prologue ASM_UNW_PRLG_RP|ASM_UNW_PRLG_PFS, ASM_UNW_PRLG_GRSAVE(2)
+	alloc loc1=ar.pfs,2,2,2,0
+	mov r16=ar.unat
+	;;
+	mov r17=ar.fpsr
+	mov r2=in0
+	add r3=8,in0
+	;;
+.mem.offset 0,0;
+	st8.spill.nta [r2]=sp,16	// r12 (sp)
+.mem.offset 8,0;
+	st8.spill.nta [r3]=gp,16	// r1 (gp)
+	;;
+	st8.nta [r2]=r16,16		// save caller's unat
+	st8.nta [r3]=r17,16		// save fpsr
+	add r8=0xa0,in0
+	;;
+.mem.offset 160,0;
+	st8.spill.nta [r2]=r4,16	// r4
+.mem.offset 168,0;
+	st8.spill.nta [r3]=r5,16	// r5
+	add r9=0xb0,in0
+	;;
+	stf.spill.nta [r8]=f2,32
+	stf.spill.nta [r9]=f3,32
+	mov loc0=rp
+	.body
+	;;
+	stf.spill.nta [r8]=f4,32
+	stf.spill.nta [r9]=f5,32
+	mov r17=b1
+	;;
+	stf.spill.nta [r8]=f16,32
+	stf.spill.nta [r9]=f17,32
+	mov r18=b2
+	;;
+	stf.spill.nta [r8]=f18,32
+	stf.spill.nta [r9]=f19,32
+	mov r19=b3
+	;;
+	stf.spill.nta [r8]=f20,32
+	stf.spill.nta [r9]=f21,32
+	mov r20=b4
+	;;
+	stf.spill.nta [r8]=f22,32
+	stf.spill.nta [r9]=f23,32
+	mov r21=b5
+	;;
+	stf.spill.nta [r8]=f24,32
+	stf.spill.nta [r9]=f25,32
+	mov r22=ar.lc
+	;;
+	stf.spill.nta [r8]=f26,32
+	stf.spill.nta [r9]=f27,32
+	mov r24=pr
+	;;
+	stf.spill.nta [r8]=f28,32
+	stf.spill.nta [r9]=f29,32
+	;;
+	stf.spill.nta [r8]=f30
+	stf.spill.nta [r9]=f31
+
+.mem.offset 0,0;
+	st8.spill.nta [r2]=r6,16	// r6
+.mem.offset 8,0;
+	st8.spill.nta [r3]=r7,16	// r7
+	;;
+	mov r23=ar.bsp
+	mov r25=ar.unat
+#ifndef __KERNEL__
+	mov out0=in0
+#endif	/* !__KERNEL__ */
+
+	st8.nta [r2]=loc0,16		// b0
+	st8.nta [r3]=r17,16		// b1
+#ifndef __KERNEL__
+	mov out1=in1
+#endif	/* !__KERNEL__ */
+	;;
+	st8.nta [r2]=r18,16		// b2
+	st8.nta [r3]=r19,16		// b3
+	;;
+	st8.nta [r2]=r20,16		// b4
+	st8.nta [r3]=r21,16		// b5
+	;;
+	st8.nta [r2]=loc1,16		// ar.pfs
+	st8.nta [r3]=r22,16		// ar.lc
+	;;
+	st8.nta [r2]=r24,16		// pr
+	st8.nta [r3]=r23,16		// ar.bsp
+	;;
+	st8.nta [r2]=r25		// ar.unat
+	st8.nta [r3]=in0		// &__jmp_buf
+#ifndef __KERNEL__
+	br.call.dpnt.few rp=__sigjmp_save
+.ret0:					// force a new bundle ::q
+#endif	/* !_KERNEL__ */
+	mov r8=0
+	mov rp=loc0
+	mov ar.pfs=loc1
+	ret
+#ifndef __KERNEL__
+END(__sigsetjmp)
+
+weak_extern(_setjmp)
+weak_extern(setjmp)
+
+#else	/* __KERNEL__ */
+END(kdba_setjmp)
+#endif	/* !_KERNEL__ */
+
+/* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   Note that __sigsetjmp() did NOT flush the register stack.  Instead,
+   we do it here since __longjmp() is usually much less frequently
+   invoked than __sigsetjmp(). The only difficulty is that __sigsetjmp()
+   didn't (and wouldn't be able to) save ar.rnat either.  This is a problem
+   because if we're not careful, we could end up loading random NaT bits.
+   There are two cases:
+
+	(i)  ar.bsp < ia64_rse_rnat_addr(jmpbuf.ar_bsp)
+		ar.rnat contains the desired bits---preserve ar.rnat
+		across loadrs and write to ar.bspstore
+
+	(ii) ar.bsp >= ia64_rse_rnat_addr(jmpbuf.ar_bsp)
+		The desired ar.rnat is stored in
+		ia64_rse_rnat_addr(jmpbuf.ar_bsp).  Load those
+		bits into ar.rnat after setting ar.bspstore. */
+
+#ifndef __KERNEL__
+#include <sysdep.h>
+#include <features.h>
+#endif	/* !__KERNEL__ */
+
+#	define	pPos	p6	/* is rotate count positive? */
+#	define	pNeg	p7	/* is rotate count negative? */
+
+
+	/* __longjmp(__jmp_buf buf, int val) */
+
+#ifndef __KERNEL__
+LEAF(__longjmp)
+#else	/* __KERNEL__ */
+GLOBAL_ENTRY(kdba_longjmp)
+#endif	/* !__KERNEL__ */
+	alloc r8=ar.pfs,2,1,0,0
+	mov r27=ar.rsc
+	add r2=0x98,in0		// r2 <- &jmpbuf.orig_jmp_buf_addr
+	;;
+	ld8 r8=[r2],-16		// r8 <- orig_jmp_buf_addr
+	mov r10=ar.bsp
+	and r11=~0x3,r27	// clear ar.rsc.mode
+	;;
+	flushrs			// flush dirty regs to backing store (must be first in insn grp)
+	ld8 r23=[r2],8		// r23 <- jmpbuf.ar_bsp
+	sub r8=r8,in0		// r8 <- &orig_jmpbuf - &jmpbuf
+	;;
+	ld8 r25=[r2]		// r25 <- jmpbuf.ar_unat
+	extr.u r8=r8,3,6	// r8 <- (&orig_jmpbuf - &jmpbuf)/8 & 0x3f
+	;;
+	cmp.lt pNeg,pPos=r8,r0
+	mov r2=in0
+	;;
+(pPos)	mov r16=r8
+(pNeg)	add r16=64,r8
+(pPos)	sub r17=64,r8
+(pNeg)	sub r17=r0,r8
+	;;
+	mov ar.rsc=r11		// put RSE in enforced lazy mode
+	shr.u r8=r25,r16
+	add r3=8,in0		// r3 <- &jmpbuf.r1
+	shl r9=r25,r17
+	;;
+	or r25=r8,r9
+	;;
+	mov r26=ar.rnat
+	mov ar.unat=r25		// setup ar.unat (NaT bits for r1, r4-r7, and r12)
+	;;
+	ld8.fill.nta sp=[r2],16	// r12 (sp)
+	ld8.fill.nta gp=[r3],16		// r1 (gp)
+	dep r11=-1,r23,3,6	// r11 <- ia64_rse_rnat_addr(jmpbuf.ar_bsp)
+	;;
+	ld8.nta r16=[r2],16		// caller's unat
+	ld8.nta r17=[r3],16		// fpsr
+	;;
+	ld8.fill.nta r4=[r2],16	// r4
+	ld8.fill.nta r5=[r3],16		// r5 (gp)
+	cmp.geu p8,p0=r10,r11	// p8 <- (ar.bsp >= jmpbuf.ar_bsp)
+	;;
+	ld8.fill.nta r6=[r2],16	// r6
+	ld8.fill.nta r7=[r3],16		// r7
+	;;
+	mov ar.unat=r16			// restore caller's unat
+	mov ar.fpsr=r17			// restore fpsr
+	;;
+	ld8.nta r16=[r2],16		// b0
+	ld8.nta r17=[r3],16		// b1
+	;;
+(p8)	ld8 r26=[r11]		// r26 <- *ia64_rse_rnat_addr(jmpbuf.ar_bsp)
+	mov ar.bspstore=r23	// restore ar.bspstore
+	;;
+	ld8.nta r18=[r2],16		// b2
+	ld8.nta r19=[r3],16		// b3
+	;;
+	ld8.nta r20=[r2],16		// b4
+	ld8.nta r21=[r3],16		// b5
+	;;
+	ld8.nta r11=[r2],16		// ar.pfs
+	ld8.nta r22=[r3],56		// ar.lc
+	;;
+	ld8.nta r24=[r2],32		// pr
+	mov b0=r16
+	;;
+	ldf.fill.nta f2=[r2],32
+	ldf.fill.nta f3=[r3],32
+	mov b1=r17
+	;;
+	ldf.fill.nta f4=[r2],32
+	ldf.fill.nta f5=[r3],32
+	mov b2=r18
+	;;
+	ldf.fill.nta f16=[r2],32
+	ldf.fill.nta f17=[r3],32
+	mov b3=r19
+	;;
+	ldf.fill.nta f18=[r2],32
+	ldf.fill.nta f19=[r3],32
+	mov b4=r20
+	;;
+	ldf.fill.nta f20=[r2],32
+	ldf.fill.nta f21=[r3],32
+	mov b5=r21
+	;;
+	ldf.fill.nta f22=[r2],32
+	ldf.fill.nta f23=[r3],32
+	mov ar.lc=r22
+	;;
+	ldf.fill.nta f24=[r2],32
+	ldf.fill.nta f25=[r3],32
+	cmp.eq p8,p9=0,in1
+	;;
+	ldf.fill.nta f26=[r2],32
+	ldf.fill.nta f27=[r3],32
+	mov ar.pfs=r11
+	;;
+	ldf.fill.nta f28=[r2],32
+	ldf.fill.nta f29=[r3],32
+	;;
+	ldf.fill.nta f30=[r2]
+	ldf.fill.nta f31=[r3]
+(p8)	mov r8=1
+
+	mov ar.rnat=r26		// restore ar.rnat
+	;;
+	mov ar.rsc=r27		// restore ar.rsc
+(p9)	mov r8=in1
+
+	invala			// virt. -> phys. regnum mapping may change
+	mov pr=r24,-1
+	ret
+#ifndef __KERNEL__
+END(__longjmp)
+#else	/* __KERNEL__ */
+END(kdba_longjmp)
+#endif	/* !_KERNEL__ */
Index: linux/arch/ia64/kdb/kdba_pod.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/kdba_pod.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,64 @@
+/*
+ * Kernel Debugger Architecture Dependent POD functions.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+#include <linux/types.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+#include <linux/module.h>
+#include <asm/sal.h>
+#include <asm/sn/sn_sal.h>
+
+MODULE_AUTHOR("Jesse Barnes");
+MODULE_DESCRIPTION("Enter POD through KDB");
+MODULE_LICENSE("GPL");
+
+/**
+ * kdba_pod - enter POD mode from kdb
+ * @argc: arg count
+ * @argv: arg values
+ * @envp: kdb env. vars
+ * @regs: current register state
+ *
+ * Enter POD mode from kdb using SGI SN specific SAL function call.
+ */
+static int
+kdba_pod(int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	kdb_printf("WARNING: pod commands are dangerous unless you know exactly\n"
+		   "what you are doing.  If in doubt, type exit immediately.\n");
+	return ia64_sn_pod_mode();
+}
+
+/**
+ * kdba_pod_init - register 'pod' command with kdb
+ *
+ * Register the 'pod' command with kdb at load time.
+ */
+static int __init
+kdba_pod_init(void)
+{
+	kdb_register("pod", kdba_pod, 0, "Enter POD", 0);
+
+	return 0;
+}
+
+/**
+ * kdba_pod_exit - unregister the 'pod' command
+ *
+ * Tell kdb that the 'pod' command is no longer available.
+ */
+static void __exit
+kdba_pod_exit(void)
+{
+	kdb_unregister("pod");
+}
+
+kdb_module_init(kdba_pod_init)
+kdb_module_exit(kdba_pod_exit)
Index: linux/arch/ia64/kdb/kdbasupport.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/arch/ia64/kdb/kdbasupport.c	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,1364 @@
+/*
+ * Kernel Debugger Architecture Independent Support Functions
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (C) David Mosberger-Tang <davidm@hpl.hp.com>
+ */
+
+#include <linux/config.h>
+#include <linux/string.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/ptrace.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>
+
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+#include <asm/rse.h>
+#include <asm/delay.h>
+#ifdef CONFIG_SMP
+#include <asm/hw_irq.h>
+#endif
+
+static int
+kdba_itm (int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	int diag;
+	unsigned long val;
+
+	diag = kdbgetularg(argv[1], &val);
+	if (diag)
+		return diag;
+	kdb_printf("new itm=" kdb_machreg_fmt "\n", val);
+
+	ia64_set_itm(val);
+	return 0;
+}
+
+static void
+kdba_show_intregs(void)
+{
+	u64 lid, tpr, lrr0, lrr1, itv, pmv, cmcv;
+
+	asm ("mov %0=cr.lid" : "=r"(lid));
+	asm ("mov %0=cr.tpr" : "=r"(tpr));
+	asm ("mov %0=cr.lrr0" : "=r"(lrr0));
+	asm ("mov %0=cr.lrr1" : "=r"(lrr1));
+	kdb_printf("lid=" kdb_machreg_fmt ", tpr=" kdb_machreg_fmt ", lrr0=" kdb_machreg_fmt ", llr1=" kdb_machreg_fmt "\n", lid, tpr, lrr0, lrr1);
+
+	asm ("mov %0=cr.itv" : "=r"(itv));
+	asm ("mov %0=cr.pmv" : "=r"(pmv));
+	asm ("mov %0=cr.cmcv" : "=r"(cmcv));
+	kdb_printf("itv=" kdb_machreg_fmt ", pmv=" kdb_machreg_fmt ", cmcv=" kdb_machreg_fmt "\n", itv, pmv, cmcv);
+
+	kdb_printf("irr=0x%016lx,0x%016lx,0x%016lx,0x%016lx\n",
+		ia64_getreg(_IA64_REG_CR_IRR0), ia64_getreg(_IA64_REG_CR_IRR1), ia64_getreg(_IA64_REG_CR_IRR2), ia64_getreg(_IA64_REG_CR_IRR3));
+
+	kdb_printf("itc=0x%016lx, itm=0x%016lx\n", ia64_get_itc(), ia64_get_itm());
+}
+
+static int
+kdba_sir (int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	kdba_show_intregs();
+
+	return 0;
+}
+
+/*
+ * kdba_pt_regs
+ *
+ *	Format a struct pt_regs
+ *
+ * Inputs:
+ *	argc	argument count
+ *	argv	argument vector
+ *	envp	environment vector
+ *	regs	registers at time kdb was entered.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	If no address is supplied, it uses regs.
+ */
+
+static int
+kdba_pt_regs(int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	int diag;
+	kdb_machreg_t addr;
+	long offset = 0;
+	int nextarg;
+	struct pt_regs *p;
+
+	if (argc == 0) {
+		addr = (kdb_machreg_t) regs;
+	} else if (argc == 1) {
+		nextarg = 1;
+		diag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL, regs);
+		if (diag)
+			return diag;
+	} else {
+		return KDB_ARGCOUNT;
+	}
+
+	p = (struct pt_regs *) addr;
+	kdb_printf("struct pt_regs %p-%p\n", p, (unsigned char *)p + sizeof(*p) - 1);
+	kdb_print_nameval("b6", p->b6);
+	kdb_print_nameval("b7", p->b7);
+	kdb_printf("  ar_csd      0x%lx\n", p->ar_csd);
+	kdb_printf("  ar_ssd      0x%lx\n", p->ar_ssd);
+	kdb_print_nameval("r8", p->r8);
+	kdb_print_nameval("r9", p->r9);
+	kdb_print_nameval("r10", p->r10);
+	kdb_print_nameval("r11", p->r11);
+	kdb_printf("  cr_ipsr     0x%lx\n", p->cr_ipsr);
+	kdb_print_nameval("cr_iip", p->cr_iip);
+	kdb_printf("  cr_ifs      0x%lx\n", p->cr_ifs);
+	kdb_printf("  ar_unat     0x%lx\n", p->ar_unat);
+	kdb_printf("  ar_pfs      0x%lx\n", p->ar_pfs);
+	kdb_printf("  ar_rsc      0x%lx\n", p->ar_rsc);
+	kdb_printf("  ar_rnat     0x%lx\n", p->ar_rnat);
+	kdb_printf("  ar_bspstore 0x%lx\n", p->ar_bspstore);
+	kdb_printf("  pr          0x%lx\n", p->pr);
+	kdb_print_nameval("b0", p->b0);
+	kdb_printf("  loadrs      0x%lx\n", p->loadrs);
+	kdb_print_nameval("r1", p->r1);
+	kdb_print_nameval("r12", p->r12);
+	kdb_print_nameval("r13", p->r13);
+	kdb_printf("  ar_fpsr     0x%lx\n", p->ar_fpsr);
+	kdb_print_nameval("r15", p->r15);
+	kdb_print_nameval("r14", p->r14);
+	kdb_print_nameval("r2", p->r2);
+	kdb_print_nameval("r3", p->r3);
+	kdb_print_nameval("r16", p->r16);
+	kdb_print_nameval("r17", p->r17);
+	kdb_print_nameval("r18", p->r18);
+	kdb_print_nameval("r19", p->r19);
+	kdb_print_nameval("r20", p->r20);
+	kdb_print_nameval("r21", p->r21);
+	kdb_print_nameval("r22", p->r22);
+	kdb_print_nameval("r23", p->r23);
+	kdb_print_nameval("r24", p->r24);
+	kdb_print_nameval("r25", p->r25);
+	kdb_print_nameval("r26", p->r26);
+	kdb_print_nameval("r27", p->r27);
+	kdb_print_nameval("r28", p->r28);
+	kdb_print_nameval("r29", p->r29);
+	kdb_print_nameval("r30", p->r30);
+	kdb_print_nameval("r31", p->r31);
+	kdb_printf("  ar_ccv      0x%lx\n", p->ar_ccv);
+	kdb_printf("  f6          0x%lx 0x%lx\n", p->f6.u.bits[0], p->f6.u.bits[1]);
+	kdb_printf("  f7          0x%lx 0x%lx\n", p->f7.u.bits[0], p->f7.u.bits[1]);
+	kdb_printf("  f8          0x%lx 0x%lx\n", p->f8.u.bits[0], p->f8.u.bits[1]);
+	kdb_printf("  f9          0x%lx 0x%lx\n", p->f9.u.bits[0], p->f9.u.bits[1]);
+	kdb_printf("  f10         0x%lx 0x%lx\n", p->f10.u.bits[0], p->f10.u.bits[1]);
+	kdb_printf("  f11         0x%lx 0x%lx\n", p->f11.u.bits[0], p->f11.u.bits[1]);
+
+	return 0;
+}
+
+/*
+ * kdba_stackdepth
+ *
+ *	Print processes that are using more than a specific percentage of their
+ *	stack.
+ *
+ * Inputs:
+ *	argc	argument count
+ *	argv	argument vector
+ *	envp	environment vector
+ *	regs	registers at time kdb was entered.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	If no percentage is supplied, it uses 60.
+ */
+
+static int
+kdba_stackdepth(int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	int diag, threshold, used;
+	long percentage;
+	unsigned long esp;
+	long offset = 0;
+	int nextarg;
+	struct task_struct *p, *g;
+	struct switch_stack *sw;
+
+	if (argc == 0) {
+		percentage = 60;
+	} else if (argc == 1) {
+		nextarg = 1;
+		diag = kdbgetaddrarg(argc, argv, &nextarg, &percentage, &offset, NULL, regs);
+		if (diag)
+			return diag;
+	} else {
+		return KDB_ARGCOUNT;
+	}
+	percentage = max_t(int, percentage, 1);
+	percentage = min_t(int, percentage, 100);
+	threshold = ((2 * THREAD_SIZE * percentage) / 100 + 1) >> 1;
+	kdb_printf("stackdepth: processes using more than %ld%% (%d bytes) of stack\n",
+		percentage, threshold);
+	kdb_do_each_thread(g, p) {
+		if (kdb_task_has_cpu(p)) {
+			struct kdb_running_process *krp = kdb_running_process + kdb_process_cpu(p);
+			if (krp->seqno)
+				sw = krp->arch.sw;
+			else
+				sw = NULL;
+		} else
+			sw = (struct switch_stack *) (p->thread.ksp + 16);
+		if (!sw)
+			continue;
+		esp = (unsigned long) sw;
+		used = THREAD_SIZE - (esp - sw->ar_bspstore);
+		if (used >= threshold) {
+			kdb_ps1(p);
+			kdb_printf("  esp %lx bsp %lx used %d\n", esp, sw->ar_bspstore, used);
+		}
+	} kdb_while_each_thread(g, p);
+
+	return 0;
+}
+
+/*
+ * kdb_switch_stack
+ *
+ *	Format a struct switch_stack
+ *
+ * Inputs:
+ *	argc	argument count
+ *	argv	argument vector
+ *	envp	environment vector
+ *	regs	registers at time kdb was entered.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	If no address is supplied, it uses kdb_running_process[smp_processor_id()].arch.sw.
+ */
+
+static int
+kdba_switch_stack(int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	int diag;
+	kdb_machreg_t addr;
+	long offset = 0;
+	int nextarg;
+	struct switch_stack *p;
+
+	if (argc == 0) {
+		addr = (kdb_machreg_t) kdb_running_process[smp_processor_id()].arch.sw;
+	} else if (argc == 1) {
+		nextarg = 1;
+		diag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL, regs);
+		if (diag)
+			return diag;
+	} else {
+		return KDB_ARGCOUNT;
+	}
+
+	p = (struct switch_stack *) addr;
+	kdb_printf("struct switch_stack %p-%p\n", p, (unsigned char *)p + sizeof(*p) - 1);
+	kdb_printf("  caller_unat 0x%lx\n", p->caller_unat);
+	kdb_printf("  ar_fpsr     0x%lx\n", p->ar_fpsr);
+	kdb_printf("  f2          0x%lx 0x%lx\n", p->f2.u.bits[0], p->f2.u.bits[1]);
+	kdb_printf("  f3          0x%lx 0x%lx\n", p->f3.u.bits[0], p->f3.u.bits[1]);
+	kdb_printf("  f4          0x%lx 0x%lx\n", p->f4.u.bits[0], p->f4.u.bits[1]);
+	kdb_printf("  f5          0x%lx 0x%lx\n", p->f5.u.bits[0], p->f5.u.bits[1]);
+	kdb_printf("  f12         0x%lx 0x%lx\n", p->f12.u.bits[0], p->f12.u.bits[1]);
+	kdb_printf("  f13         0x%lx 0x%lx\n", p->f13.u.bits[0], p->f13.u.bits[1]);
+	kdb_printf("  f14         0x%lx 0x%lx\n", p->f14.u.bits[0], p->f14.u.bits[1]);
+	kdb_printf("  f15         0x%lx 0x%lx\n", p->f15.u.bits[0], p->f15.u.bits[1]);
+	kdb_printf("  f16         0x%lx 0x%lx\n", p->f16.u.bits[0], p->f16.u.bits[1]);
+	kdb_printf("  f17         0x%lx 0x%lx\n", p->f17.u.bits[0], p->f17.u.bits[1]);
+	kdb_printf("  f18         0x%lx 0x%lx\n", p->f18.u.bits[0], p->f18.u.bits[1]);
+	kdb_printf("  f19         0x%lx 0x%lx\n", p->f19.u.bits[0], p->f19.u.bits[1]);
+	kdb_printf("  f20         0x%lx 0x%lx\n", p->f20.u.bits[0], p->f20.u.bits[1]);
+	kdb_printf("  f21         0x%lx 0x%lx\n", p->f21.u.bits[0], p->f21.u.bits[1]);
+	kdb_printf("  f22         0x%lx 0x%lx\n", p->f22.u.bits[0], p->f22.u.bits[1]);
+	kdb_printf("  f23         0x%lx 0x%lx\n", p->f23.u.bits[0], p->f23.u.bits[1]);
+	kdb_printf("  f24         0x%lx 0x%lx\n", p->f24.u.bits[0], p->f24.u.bits[1]);
+	kdb_printf("  f25         0x%lx 0x%lx\n", p->f25.u.bits[0], p->f25.u.bits[1]);
+	kdb_printf("  f26         0x%lx 0x%lx\n", p->f26.u.bits[0], p->f26.u.bits[1]);
+	kdb_printf("  f27         0x%lx 0x%lx\n", p->f27.u.bits[0], p->f27.u.bits[1]);
+	kdb_printf("  f28         0x%lx 0x%lx\n", p->f28.u.bits[0], p->f28.u.bits[1]);
+	kdb_printf("  f29         0x%lx 0x%lx\n", p->f29.u.bits[0], p->f29.u.bits[1]);
+	kdb_printf("  f30         0x%lx 0x%lx\n", p->f30.u.bits[0], p->f30.u.bits[1]);
+	kdb_printf("  f31         0x%lx 0x%lx\n", p->f31.u.bits[0], p->f31.u.bits[1]);
+	kdb_print_nameval("r4", p->r4);
+	kdb_print_nameval("r5", p->r5);
+	kdb_print_nameval("r6", p->r6);
+	kdb_print_nameval("r7", p->r7);
+	kdb_print_nameval("b0", p->b0);
+	kdb_print_nameval("b1", p->b1);
+	kdb_print_nameval("b2", p->b2);
+	kdb_print_nameval("b3", p->b3);
+	kdb_print_nameval("b4", p->b4);
+	kdb_print_nameval("b5", p->b5);
+	kdb_printf("  ar_pfs      0x%lx\n", p->ar_pfs);
+	kdb_printf("  ar_lc       0x%lx\n", p->ar_lc);
+	kdb_printf("  ar_unat     0x%lx\n", p->ar_unat);
+	kdb_printf("  ar_rnat     0x%lx\n", p->ar_rnat);
+	kdb_printf("  ar_bspstore 0x%lx\n", p->ar_bspstore);
+	kdb_printf("  pr          0x%lx\n", p->pr);
+
+	return 0;
+}
+
+/*
+ * kdba_cpuinfo
+ *
+ *	Format struct cpuinfo_ia64.
+ *
+ * Inputs:
+ *	argc	argument count
+ *	argv	argument vector
+ *	envp	environment vector
+ *	regs	registers at time kdb was entered.
+ * Outputs:
+ *	None.
+ * Returns:
+ *	zero for success, a kdb diagnostic if error
+ * Locking:
+ *	none.
+ * Remarks:
+ *	If no cpu is supplied, it prints cpuinfo for all online cpus.
+ */
+
+static int
+kdba_cpuinfo(int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	int diag;
+	long cpunum = -1;
+	long offset = 0;
+	int nextarg, c, i;
+	struct cpuinfo_ia64 *cpuinfo;
+
+	if (argc == 1) {
+		nextarg = 1;
+		diag = kdbgetaddrarg(argc, argv, &nextarg, &cpunum, &offset, NULL, regs);
+		if (diag)
+			return diag;
+		if (cpunum >= NR_CPUS || !cpu_online(cpunum))
+			return KDB_BADCPUNUM;
+	} else if (argc > 1) {
+		return KDB_ARGCOUNT;
+	}
+
+	for (c = (cpunum < 0 ? 0 : cpunum);
+	     c < (cpunum < 0 ? NR_CPUS : cpunum+1);
+	     ++c) {
+		if (!cpu_online(c))
+			continue;
+		cpuinfo = cpu_data(c);
+		kdb_printf("struct cpuinfo_ia64 for cpu %d is at 0x%p\n", c, cpuinfo);
+		kdb_printf("  softirq_pending  0x%x\n",   cpuinfo->softirq_pending);
+		kdb_printf("  itm_delta        %ld\n",    cpuinfo->itm_delta);
+		kdb_printf("  itm_next         %ld\n",    cpuinfo->itm_next);
+		kdb_printf("  nsec_per_cyc     %ld\n",    cpuinfo->nsec_per_cyc);
+		kdb_printf("  unimpl_va_mask   0x%lx\n",  cpuinfo->unimpl_va_mask);
+		kdb_printf("  unimpl_pa_mask   0x%lx\n",  cpuinfo->unimpl_pa_mask);
+		kdb_printf("  pgd_quick        0x%p\n",   cpuinfo->pgd_quick);
+		kdb_printf("  pgtable_cache_sz %ld\n",    cpuinfo->pgtable_cache_sz);
+		kdb_printf("  itc_freq         %ld\n",    cpuinfo->itc_freq);
+		kdb_printf("  proc_freq        %ld\n",    cpuinfo->proc_freq);
+		kdb_printf("  cyc_per_usec     %ld\n",    cpuinfo->cyc_per_usec);
+		kdb_printf("  cyc_per_usec     %ld\n",    cpuinfo->cyc_per_usec);
+#if 0	/* RJA per-cpu MCA */
+		kdb_printf("  percpu_paddr     0x%lx\n",  cpuinfo->percpu_paddr);
+#endif
+		kdb_printf("  ptce_base        0x%lx\n",  cpuinfo->ptce_base);
+		kdb_printf("  ptce_count       %d %d\n",  cpuinfo->ptce_count[0], cpuinfo->ptce_count[1]);
+		kdb_printf("  ptce_stride      %d %d\n",  cpuinfo->ptce_stride[0], cpuinfo->ptce_stride[1]);
+#if 0	/* RJA per-cpu MCA */
+		kdb_printf("  pal_paddr        0x%lx\n",  cpuinfo->pal_paddr);
+		kdb_printf("  pal_base         0x%lx\n",  cpuinfo->pal_base);
+#endif
+		kdb_printf("  ksoftirqd        0x%p\n",   cpuinfo->ksoftirqd);
+#ifdef CONFIG_SMP
+		kdb_printf("  loops_per_jiffy  %ld\n",    cpuinfo->loops_per_jiffy);
+		kdb_printf("  cpu              %d\n",     cpuinfo->cpu);
+#endif
+		kdb_printf("  ppn              0x%lx\n",  cpuinfo->ppn);
+		kdb_printf("  features         0x%lx\n",  cpuinfo->features);
+		kdb_printf("  number           %d\n",     cpuinfo->number);
+		kdb_printf("  revision         %d\n",     cpuinfo->revision);
+		kdb_printf("  model            %d\n",     cpuinfo->model);
+		kdb_printf("  family           %d\n",     cpuinfo->family);
+		kdb_printf("  archrev          %d\n",     cpuinfo->archrev);
+		kdb_printf("  vendor          ");
+		for (i = 0; i < sizeof(cpuinfo->vendor); ++i)
+			kdb_printf(" 0x%02x", cpuinfo->vendor[i]);
+		kdb_printf("\n");
+#ifdef CONFIG_NUMA
+		kdb_printf("  node_data        0x%p\n",   cpuinfo->node_data);
+#endif
+#if 0	/* RJA per-cpu MCA */
+		kdb_printf("  ia64_pa_mca_data 0x%p\n",   cpuinfo->ia64_pa_mca_data);
+#endif
+	}
+	return 0;
+}
+
+void
+kdba_installdbreg(kdb_bp_t *bp)
+{
+	/* FIXME: code this */
+}
+
+void
+kdba_removedbreg(kdb_bp_t *bp)
+{
+	/* FIXME: code this */
+}
+
+static kdb_machreg_t
+kdba_getdr(int regnum)
+{
+	kdb_machreg_t contents = 0;
+	unsigned long reg = (unsigned long)regnum;
+
+	__asm__ ("mov %0=ibr[%1]"::"r"(contents),"r"(reg));
+//        __asm__ ("mov ibr[%0]=%1"::"r"(dbreg_cond),"r"(value));
+
+	return contents;
+}
+
+
+static void
+get_fault_regs(fault_regs_t *fr)
+{
+	fr->ifa = 0 ;
+	fr->isr = 0 ;
+
+	__asm__ ("rsm psr.ic;;") ;
+	ia64_srlz_d();
+	__asm__ ("mov %0=cr.ifa" : "=r"(fr->ifa));
+	__asm__ ("mov %0=cr.isr" : "=r"(fr->isr));
+	__asm__ ("ssm psr.ic;;") ;
+	ia64_srlz_d();
+}
+
+static void
+show_kernel_regs (void)
+{
+	unsigned long kr[8];
+	int i;
+
+	asm ("mov %0=ar.k0" : "=r"(kr[0])); asm ("mov %0=ar.k1" : "=r"(kr[1]));
+	asm ("mov %0=ar.k2" : "=r"(kr[2])); asm ("mov %0=ar.k3" : "=r"(kr[3]));
+	asm ("mov %0=ar.k4" : "=r"(kr[4])); asm ("mov %0=ar.k5" : "=r"(kr[5]));
+	asm ("mov %0=ar.k6" : "=r"(kr[6])); asm ("mov %0=ar.k7" : "=r"(kr[7]));
+
+	for (i = 0; i < 4; ++i)
+		kdb_printf(" kr%d: %016lx  kr%d: %016lx\n", 2*i, kr[2*i], 2*i+1, kr[2*i+1]);
+	kdb_printf("\n");
+}
+
+static int
+change_cur_stack_frame(struct pt_regs *regs, int regno, unsigned long *contents)
+{
+	unsigned long sof, i, cfm, sp, *bsp;
+	struct unw_frame_info info;
+	mm_segment_t old_fs;
+
+	unw_init_frame_info(&info, current, kdb_running_process[smp_processor_id()].arch.sw);
+	do {
+		if (unw_unwind(&info) < 0) {
+			kdb_printf("Failed to unwind\n");
+			return 0;
+		}
+		unw_get_sp(&info, &sp);
+	} while (sp <= (unsigned long) regs);
+	unw_get_bsp(&info, (unsigned long *) &bsp);
+	unw_get_cfm(&info, &cfm);
+
+	if (!bsp) {
+		kdb_printf("Unable to get Current Stack Frame\n");
+		return 0;
+	}
+
+	sof = (cfm & 0x7f);
+
+	if(((unsigned long)regno - 32) >= (sof - 2)) return 1;
+
+	old_fs = set_fs(KERNEL_DS);
+	{
+		for (i = 0; i < (regno - 32); ++i) {
+			bsp = ia64_rse_skip_regs(bsp, 1);
+		}
+		put_user(*contents, bsp);
+	}
+	set_fs(old_fs);
+
+	return 0 ;
+}
+
+static int
+show_cur_stack_frame(struct pt_regs *regs, int regno, unsigned long *contents)
+{
+	unsigned long sof, i, cfm, val, sp, *bsp;
+	struct unw_frame_info info;
+	mm_segment_t old_fs;
+
+	/* XXX It would be better to simply create a copy of an unw_frame_info structure
+	 * that is set up in kdba_main_loop().  That way, we could avoid having to skip
+	 * over the first few frames every time...
+	 */
+	unw_init_frame_info(&info, current, kdb_running_process[smp_processor_id()].arch.sw);
+	do {
+		if (unw_unwind(&info) < 0) {
+			kdb_printf("Failed to unwind\n");
+			return 0;
+		}
+		unw_get_sp(&info, &sp);
+	} while (sp <= (unsigned long) regs);
+	unw_get_bsp(&info, (unsigned long *) &bsp);
+	unw_get_cfm(&info, &cfm);
+
+	if (!bsp) {
+		kdb_printf("Unable to display Current Stack Frame\n");
+		return 0;
+	}
+
+	sof = (cfm & 0x7f);
+
+	if (regno) {
+		if ((unsigned) regno - 32 >= sof)
+			return 0;
+		bsp = ia64_rse_skip_regs(bsp, regno - 32);
+		old_fs = set_fs(KERNEL_DS);
+		{
+			get_user(val, bsp);
+		}
+		set_fs(old_fs);
+		*contents = val;
+		return 1;
+	}
+
+	old_fs = set_fs(KERNEL_DS);
+	{
+		for (i = 0; i < sof; ++i) {
+			get_user(val, bsp);
+			kdb_printf(" r%lu: %016lx ", 32 + i, val);
+			if (!((i + 1) % 3))
+				kdb_printf("\n");
+			bsp = ia64_rse_skip_regs(bsp, 1);
+		}
+		kdb_printf("\n");
+	}
+	set_fs(old_fs);
+
+	return 0 ;
+}
+
+/*
+ * kdba_getregcontents
+ *
+ *	Return the contents of the register specified by the
+ *	input string argument.   Return an error if the string
+ *	does not match a machine register.
+ *
+ *	The following pseudo register names are supported:
+ *	   &regs	 - Prints address of exception frame
+ *	   kesp		 - Prints kernel stack pointer at time of fault
+ * 	   sstk		 - Prints switch stack for ia64
+ *	   %<regname>	 - Uses the value of the registers at the
+ *			   last time the user process entered kernel
+ *			   mode, instead of the registers at the time
+ *			   kdb was entered.
+ *
+ * Parameters:
+ *	regname		Pointer to string naming register
+ *	regs		Pointer to structure containing registers.
+ * Outputs:
+ *	*contents	Pointer to unsigned long to recieve register contents
+ * Returns:
+ *	0		Success
+ *	KDB_BADREG	Invalid register name
+ * Locking:
+ * 	None.
+ * Remarks:
+ *
+ * 	Note that this function is really machine independent.   The kdb
+ *	register list is not, however.
+ */
+
+static struct kdbregs {
+	char   *reg_name;
+	size_t	reg_offset;
+} kdbreglist[] = {
+	{ "psr",	offsetof(struct pt_regs, cr_ipsr) },
+	{ "ifs",	offsetof(struct pt_regs, cr_ifs) },
+	{ "ip",	offsetof(struct pt_regs, cr_iip) },
+
+	{ "unat", 	offsetof(struct pt_regs, ar_unat) },
+	{ "pfs",	offsetof(struct pt_regs, ar_pfs) },
+	{ "rsc", 	offsetof(struct pt_regs, ar_rsc) },
+
+	{ "rnat",	offsetof(struct pt_regs, ar_rnat) },
+	{ "bsps",	offsetof(struct pt_regs, ar_bspstore) },
+	{ "pr",	offsetof(struct pt_regs, pr) },
+
+	{ "ldrs",	offsetof(struct pt_regs, loadrs) },
+	{ "ccv",	offsetof(struct pt_regs, ar_ccv) },
+	{ "fpsr",	offsetof(struct pt_regs, ar_fpsr) },
+
+	{ "b0",	offsetof(struct pt_regs, b0) },
+	{ "b6",	offsetof(struct pt_regs, b6) },
+	{ "b7",	offsetof(struct pt_regs, b7) },
+
+	{ "r1",offsetof(struct pt_regs, r1) },
+	{ "r2",offsetof(struct pt_regs, r2) },
+	{ "r3",offsetof(struct pt_regs, r3) },
+
+	{ "r8",offsetof(struct pt_regs, r8) },
+	{ "r9",offsetof(struct pt_regs, r9) },
+	{ "r10",offsetof(struct pt_regs, r10) },
+
+	{ "r11",offsetof(struct pt_regs, r11) },
+	{ "r12",offsetof(struct pt_regs, r12) },
+	{ "r13",offsetof(struct pt_regs, r13) },
+
+	{ "r14",offsetof(struct pt_regs, r14) },
+	{ "r15",offsetof(struct pt_regs, r15) },
+	{ "r16",offsetof(struct pt_regs, r16) },
+
+	{ "r17",offsetof(struct pt_regs, r17) },
+	{ "r18",offsetof(struct pt_regs, r18) },
+	{ "r19",offsetof(struct pt_regs, r19) },
+
+	{ "r20",offsetof(struct pt_regs, r20) },
+	{ "r21",offsetof(struct pt_regs, r21) },
+	{ "r22",offsetof(struct pt_regs, r22) },
+
+	{ "r23",offsetof(struct pt_regs, r23) },
+	{ "r24",offsetof(struct pt_regs, r24) },
+	{ "r25",offsetof(struct pt_regs, r25) },
+
+	{ "r26",offsetof(struct pt_regs, r26) },
+	{ "r27",offsetof(struct pt_regs, r27) },
+	{ "r28",offsetof(struct pt_regs, r28) },
+
+	{ "r29",offsetof(struct pt_regs, r29) },
+	{ "r30",offsetof(struct pt_regs, r30) },
+	{ "r31",offsetof(struct pt_regs, r31) },
+
+};
+
+static const int nkdbreglist = sizeof(kdbreglist) / sizeof(struct kdbregs);
+
+int
+kdba_getregcontents(const char *regname, struct pt_regs *regs, unsigned long *contents)
+{
+	int i;
+
+	if (strcmp(regname, "isr") == 0) {
+		fault_regs_t fr ;
+		get_fault_regs(&fr) ;
+		*contents = fr.isr ;
+		return 0 ;
+	}
+
+	if (!regs) {
+		kdb_printf("%s: pt_regs not available\n", __FUNCTION__);
+		return KDB_BADREG;
+	}
+
+	if (strcmp(regname, "&regs") == 0) {
+		*contents = (unsigned long)regs;
+		return 0;
+	}
+
+	if (strcmp(regname, "sstk") == 0) {
+		*contents = (unsigned long)getprsregs(regs) ;
+		return 0;
+	}
+
+	if (strcmp(regname, "ksp") == 0) {
+		*contents = (unsigned long) (regs + 1);
+		return 0;
+	}
+
+	for (i=0; i<nkdbreglist; i++) {
+		if (strstr(kdbreglist[i].reg_name, regname))
+			break;
+	}
+
+	if (i == nkdbreglist) {
+		/* Lets check the rse maybe */
+		if (regname[0] == 'r')
+			if (show_cur_stack_frame(regs, simple_strtoul(regname+1, 0, 0), contents))
+				return 0 ;
+		return KDB_BADREG;
+	}
+
+	*contents = *(unsigned long *)((unsigned long)regs +
+			kdbreglist[i].reg_offset);
+
+	return 0;
+}
+
+/*
+ * kdba_setregcontents
+ *
+ *	Set the contents of the register specified by the
+ *	input string argument.   Return an error if the string
+ *	does not match a machine register.
+ *
+ *	Supports modification of user-mode registers via
+ *	%<register-name>
+ *
+ * Parameters:
+ *	regname		Pointer to string naming register
+ *	regs		Pointer to structure containing registers.
+ *	contents	Unsigned long containing new register contents
+ * Outputs:
+ * Returns:
+ *	0		Success
+ *	KDB_BADREG	Invalid register name
+ * Locking:
+ * 	None.
+ * Remarks:
+ */
+
+int
+kdba_setregcontents(const char *regname,
+		  struct pt_regs *regs,
+		  unsigned long contents)
+{
+	int i, ret = 0, fixed = 0;
+	char *endp;
+	unsigned long regno;
+
+	if (regname[0] == '%') {
+		regname++;
+		regs = (struct pt_regs *)
+			(kdb_current_task->thread.ksp - sizeof(struct pt_regs));
+	}
+
+	if (!regs) {
+		kdb_printf("%s: pt_regs not available\n", __FUNCTION__);
+		return KDB_BADREG;
+	}
+
+	/* fixed registers */
+	for (i=0; i<nkdbreglist; i++) {
+		if (strnicmp(kdbreglist[i].reg_name,
+			     regname,
+			     strlen(regname)) == 0) {
+			fixed = 1;
+			break;
+		}
+	}
+
+	/* stacked registers */
+	if (!fixed) {
+		regno = (simple_strtoul(&regname[1], &endp, 10));
+		if ((regname[0] == 'r') && regno > (unsigned long)31) {
+			ret = change_cur_stack_frame(regs, regno, &contents);
+			if(!ret) return 0;
+		}
+	}
+
+	if ((i == nkdbreglist)
+	    || (strlen(kdbreglist[i].reg_name) != strlen(regname))
+	    || ret) {
+		return KDB_BADREG;
+	}
+
+	/* just in case of "standard" register */
+	*(unsigned long *)((unsigned long)regs + kdbreglist[i].reg_offset) =
+		contents;
+
+	return 0;
+}
+
+/*
+ * kdba_dumpregs
+ *
+ *	Dump the specified register set to the display.
+ *
+ * Parameters:
+ *	regs		Pointer to structure containing registers.
+ *	type		Character string identifying register set to dump
+ *	extra		string further identifying register (optional)
+ * Outputs:
+ * Returns:
+ *	0		Success
+ * Locking:
+ * 	None.
+ * Remarks:
+ *	This function will dump the general register set if the type
+ *	argument is NULL (struct pt_regs).   The alternate register
+ *	set types supported by this function:
+ *
+ *	d 		Debug registers
+ *	c		Control registers
+ *	u		User registers at most recent entry to kernel
+ *	i		Interrupt registers -- same as "irr" command
+ * Following not yet implemented:
+ *	m		Model Specific Registers (extra defines register #)
+ *	r		Memory Type Range Registers (extra defines register)
+ *
+ *	For now, all registers are covered as follows:
+ *
+ * 	rd 		- dumps all regs
+ *	rd	%isr	- current interrupt status reg, read freshly
+ *	rd	s	- valid stacked regs
+ * 	rd 	%sstk	- gets switch stack addr. dump memory and search
+ *	rd	d	- debug regs, may not be too useful
+ *	rd	k	- dump kernel regs
+ *
+ *	ARs		TB Done
+ *	OTHERS		TB Decided ??
+ *
+ *	Intel wish list
+ *	These will be implemented later - Srinivasa
+ *
+ *      type        action
+ *      ----        ------
+ *      g           dump all General static registers
+ *      s           dump all general Stacked registers
+ *      f           dump all Floating Point registers
+ *      p           dump all Predicate registers
+ *      b           dump all Branch registers
+ *      a           dump all Application registers
+ *      c           dump all Control registers
+ *
+ */
+
+int
+kdba_dumpregs(struct pt_regs *regs,
+	    const char *type,
+	    const char *extra)
+
+{
+	int i;
+	int count = 0;
+
+	if (type
+	 && (type[0] == 'u')) {
+		type = NULL;
+		regs = (struct pt_regs *)
+			(kdb_current_task->thread.ksp - sizeof(struct pt_regs));
+	}
+
+	if (type == NULL) {
+		if (!regs) {
+			kdb_printf("%s: pt_regs not available\n", __FUNCTION__);
+			return KDB_BADREG;
+		}
+		for (i=0; i<nkdbreglist; i++) {
+			kdb_printf("%4s: 0x%16.16lx  ",
+				   kdbreglist[i].reg_name,
+				   *(unsigned long *)((unsigned long)regs +
+						  kdbreglist[i].reg_offset));
+
+			if ((++count % 3) == 0)
+				kdb_printf("\n");
+		}
+
+		kdb_printf("&regs = %p\n", (void *)regs);
+
+		return 0;
+	}
+
+	switch (type[0]) {
+	case 'd':
+	{
+		for(i=0; i<8; i+=2) {
+			kdb_printf("idr%d: 0x%16.16lx  idr%d: 0x%16.16lx\n", i,
+					kdba_getdr(i), i+1, kdba_getdr(i+1));
+
+		}
+		return 0;
+	}
+	case 'i':
+		kdba_show_intregs();
+		break;
+	case 'k':
+		show_kernel_regs();
+		break;
+	case 'm':
+		break;
+	case 'r':
+		break;
+
+	case 's':
+	{
+		if (!regs) {
+			kdb_printf("%s: pt_regs not available\n", __FUNCTION__);
+			return KDB_BADREG;
+		}
+		show_cur_stack_frame(regs, 0, NULL) ;
+
+		return 0 ;
+	}
+
+	case '%':
+	{
+		unsigned long contents ;
+
+		if (!kdba_getregcontents(type+1, regs, &contents))
+			kdb_printf("%s = 0x%16.16lx\n", type+1, contents) ;
+		else
+			kdb_printf("diag: Invalid register %s\n", type+1) ;
+
+		return 0 ;
+	}
+
+	default:
+		return KDB_BADREG;
+	}
+
+	/* NOTREACHED */
+	return 0;
+}
+
+kdb_machreg_t
+kdba_getpc(struct pt_regs *regs)
+{
+	return regs ? regs->cr_iip + ia64_psr(regs)->ri : 0;
+}
+
+int
+kdba_setpc(struct pt_regs *regs, kdb_machreg_t newpc)
+{
+	if (KDB_NULL_REGS(regs))
+		return KDB_BADREG;
+	regs->cr_iip = newpc & ~0xf;
+	ia64_psr(regs)->ri = newpc & 0x3;
+	KDB_STATE_SET(IP_ADJUSTED);
+	return 0;
+}
+
+struct kdba_main_loop_data {
+	kdb_reason_t reason;
+	kdb_reason_t reason2;
+	int error;
+	kdb_dbtrap_t db_result;
+	struct pt_regs *regs;
+	int ret;
+};
+
+/*
+ * kdba_sw_interrupt
+ *	Invoked from interrupt wrappers via unw_init_running() after that
+ *	routine has pushed a struct switch_stack.  The interrupt wrappers
+ *	go around functions that disappear into sal/pal and therefore cannot
+ *	get into kdb.  This routine saves the switch stack information so
+ *	kdb can get diagnostics for such routines, even though they are not
+ *	blocked in the kernel.
+ *
+ * Inputs:
+ *	info	Unwind information.
+ *	data	structure passed as void * to unw_init_running.  It identifies
+ *		the real interrupt handler and contains its parameters.
+ * Returns:
+ *	none (unw_init_running requires void).
+ * Outputs:
+ *	none
+ * Locking:
+ *	None.
+ * Remarks:
+ *	unw_init_running() creates struct switch_stack then struct
+ *	unw_frame_info.  We get the address of the info so step over
+ *	that to get switch_stack.  Just hope that unw_init_running
+ *	does not change its stack usage.  unw_init_running adds padding
+ *	to put switch_stack on a 16 byte boundary.
+ */
+
+KDBA_UNWIND_HANDLER(kdba_sw_interrupt, struct kdba_sw_interrupt_data, data->irq,
+	data->ret = (data->handler)(data->irq, data->arg, data->regs)
+	);
+
+/*
+ * do_kdba_main_loop
+ *
+ *	Invoked from kdba_main_loop via unw_init_running() after that routine
+ *	has pushed a struct switch_stack.
+ *
+ * Inputs:
+ *	info	Unwind information.
+ *	data	kdb data passed as void * to unw_init_running.
+ * Returns:
+ *	none (unw_init_running requires void).  vdata->ret is set to
+ *	0	KDB was invoked for an event which it wasn't responsible
+ *	1	KDB handled the event for which it was invoked.
+ * Outputs:
+ *	none
+ * Locking:
+ *	None.
+ * Remarks:
+ *	As for kdba_sw_interrupt above.
+ */
+
+static KDBA_UNWIND_HANDLER(do_kdba_main_loop, struct kdba_main_loop_data, data->reason,
+	data->ret = kdb_main_loop(data->reason, data->reason2, data->error, data->db_result, data->regs));
+
+/*
+ * kdba_main_loop
+ *
+ *	Do any architecture specific set up before entering the main kdb loop.
+ *	The primary function of this routine is to make all processes look the
+ *	same to kdb, kdb must be able to list a process without worrying if the
+ *	process is running or blocked, so make all processes look as though they
+ *	are blocked.
+ *
+ * Inputs:
+ *	reason		The reason KDB was invoked
+ *	error		The hardware-defined error code
+ *	error2		kdb's current reason code.  Initially error but can change
+ *			acording to kdb state.
+ *	db_result	Result from break or debug point.
+ *	regs		The exception frame at time of fault/breakpoint.  If reason
+ *			is KDB_REASON_SILENT then regs is NULL, otherwise it should
+ *			always be valid.
+ * Returns:
+ *	0	KDB was invoked for an event which it wasn't responsible
+ *	1	KDB handled the event for which it was invoked.
+ * Outputs:
+ *	Builds a switch_stack structure before calling the main loop.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	none.
+ */
+
+int
+kdba_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,
+	       kdb_dbtrap_t db_result, struct pt_regs *regs)
+{
+	struct kdba_main_loop_data data;
+	KDB_DEBUG_STATE("kdba_main_loop", reason);
+	data.reason = reason;
+	data.reason2 = reason2;
+	data.error = error;
+	data.db_result = db_result;
+	data.regs = regs;
+	if (reason == KDB_REASON_CALL_PRESET) {
+		/* kdb_running_process has been preset, do not overwrite it */
+		KDB_DEBUG_STATE(__FUNCTION__, KDB_REASON_CALL_PRESET);
+		data.ret = kdb_main_loop(KDB_REASON_CALL, KDB_REASON_CALL, data.error, data.db_result, data.regs);
+	}
+	else
+		unw_init_running(do_kdba_main_loop, &data);
+	return(data.ret);
+}
+
+void
+kdba_disableint(kdb_intstate_t *state)
+{
+	unsigned long *fp = (unsigned long *)state;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	*fp = flags;
+}
+
+void
+kdba_restoreint(kdb_intstate_t *state)
+{
+	unsigned long flags = *(unsigned long *)state;
+	local_irq_restore(flags);
+}
+
+void
+kdba_setsinglestep(struct pt_regs *regs)
+{
+	if (KDB_NULL_REGS(regs))
+		return;
+	ia64_psr(regs)->ss = 1;
+}
+
+void
+kdba_clearsinglestep(struct pt_regs *regs)
+{
+	if (KDB_NULL_REGS(regs))
+		return;
+	ia64_psr(regs)->ss = 0;
+}
+
+/*
+ * kdba_enable_lbr
+ *
+ *	Enable last branch recording.
+ *
+ * Parameters:
+ *	None.
+ * Returns:
+ *	None
+ * Locking:
+ *	None
+ * Remarks:
+ *	None.
+ */
+
+void
+kdba_enable_lbr(void)
+{
+}
+
+/*
+ * kdba_disable_lbr
+ *
+ *	disable last branch recording.
+ *
+ * Parameters:
+ *	None.
+ * Returns:
+ *	None
+ * Locking:
+ *	None
+ * Remarks:
+ *	None.
+ */
+
+void
+kdba_disable_lbr(void)
+{
+}
+
+/*
+ * kdba_print_lbr
+ *
+ *	Print last branch and last exception addresses
+ *
+ * Parameters:
+ *	None.
+ * Returns:
+ *	None
+ * Locking:
+ *	None
+ * Remarks:
+ *	None.
+ */
+
+void
+kdba_print_lbr(void)
+{
+}
+/*
+ * kdb_tpa
+ *
+ * 	Virtual to Physical address translation command.
+ *
+ *	tpa  <addr>
+ *
+ * Parameters:
+ *	argc	Count of arguments in argv
+ *	argv	Space delimited command line arguments
+ *	envp	Environment value
+ *	regs	Exception frame at entry to kernel debugger
+ * Outputs:
+ *	None.
+ * Returns:
+ *	Zero for success, a kdb diagnostic if failure.
+ * Locking:
+ *	None.
+ * Remarks:
+ */
+#define __xtpa(x)		({ia64_va _v; asm("tpa %0=%1" : "=r"(_v.l) : "r"(x)); _v.l;})
+static int
+kdba_tpa(int argc, const char **argv, const char **envp, struct pt_regs* regs)
+{
+	kdb_machreg_t addr;
+	int diag;
+	long offset = 0;
+	int nextarg;
+	char c;
+
+	nextarg = 1;
+	if (argc != 1)
+		return KDB_ARGCOUNT;
+	diag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL, regs);
+	if (diag)
+		return diag;
+	if (kdb_getarea(c, addr))
+		return(0);
+	kdb_printf("vaddr: 0x%lx , paddr: 0x%lx\n", addr, __xtpa(addr));
+	return(0);
+}
+#if defined(CONFIG_NUMA)
+static int
+kdba_tpav(int argc, const char **argv, const char **envp, struct pt_regs* regs)
+{
+	kdb_machreg_t addr, end, paddr;
+	int diag;
+	long offset = 0;
+	int nextarg, nid, nid_old;
+	char c;
+
+	nextarg = 1;
+	if (argc != 2)
+		return KDB_ARGCOUNT;
+	diag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL, regs);
+	if (diag)
+		return diag;
+	diag = kdbgetaddrarg(argc, argv, &nextarg, &end, &offset, NULL, regs);
+	if (diag)
+		return diag;
+	if (kdb_getarea(c, addr))
+		return(0);
+	if (kdb_getarea(c, end))
+		return(0);
+	paddr=__xtpa(addr);
+	nid = paddr_to_nid(paddr);
+	kdb_printf("begin: 0x%lx , paddr: 0x%lx , nid: %d\n", addr, __xtpa(addr), nid);
+	for(;addr<end; addr += PAGE_SIZE) {
+		nid_old=nid;
+		paddr =__xtpa(addr);
+		nid = paddr_to_nid(paddr);
+		if (nid != nid_old)
+			kdb_printf("NOT on same NODE: addr: 0x%lx , paddr: 0x%lx , nid: %d\n", addr, paddr, nid);
+	}
+	paddr=__xtpa(end);
+	nid=paddr_to_nid(end);
+	kdb_printf("end: 0x%lx , paddr: 0x%lx , nid: %d\n", end, paddr, nid);
+	return(0);
+}
+#endif
+
+#if defined(CONFIG_SMP)
+/*
+ * kdba_sendinit
+ *
+ *      This function implements the 'init' command.
+ *
+ *      init    [<cpunum>]
+ *
+ * Inputs:
+ *      argc    argument count
+ *      argv    argument vector
+ *      envp    environment vector
+ *      regs    registers at time kdb was entered.
+ * Outputs:
+ *      None.
+ * Returns:
+ *      zero for success, a kdb diagnostic if error
+ * Locking:
+ *      none.
+ * Remarks:
+ */
+
+static int
+kdba_sendinit(int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	unsigned long cpunum;
+	int diag;
+
+	if (argc != 1)
+		return KDB_ARGCOUNT;
+
+	diag = kdbgetularg(argv[1], &cpunum);
+	if (diag)
+		return diag;
+
+	if (cpunum >= NR_CPUS || !cpu_online(cpunum))
+		return KDB_BADCPUNUM;
+
+	platform_send_ipi(cpunum, 0, IA64_IPI_DM_INIT, 0);
+	return 0;
+}
+#endif /* CONFIG_SMP */
+
+/*
+ * kdba_init
+ *
+ * 	Architecture specific initialization.
+ *
+ * Parameters:
+ *	None.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	None.
+ */
+
+void
+kdba_init(void)
+{
+	kdba_enable_lbr();
+	kdb_register("irr", kdba_sir, "", "Show interrupt registers", 0);
+	kdb_register("itm", kdba_itm, "", "Set new ITM value", 0);
+#if defined(CONFIG_SMP)
+	kdb_register("init", kdba_sendinit, "", "Send INIT to cpu", 0);
+#endif
+	kdb_register("pt_regs", kdba_pt_regs, "address", "Format struct pt_regs", 0);
+	kdb_register("switch_stack", kdba_switch_stack, "address", "Format struct switch_stack", 0);
+	kdb_register("tpa", kdba_tpa, "<vaddr>", "Translate virtual to physical address", 0);
+#if defined(CONFIG_NUMA)
+	kdb_register("tpav", kdba_tpav, "<begin addr> <end addr>", "Verify that physical addresses corresponding to virtual addresses from <begin addr> to <end addr> are in same node", 0);
+#endif
+	kdb_register("stackdepth", kdba_stackdepth, "[percentage]", "Print processes using >= stack percentage", 0);
+	kdb_register("cpuinfo", kdba_cpuinfo, "[cpu]", "Print struct cpuinfo_ia64", 0);
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	kdba_serial_console = KDBA_SC_STANDARD;
+#endif
+#ifdef CONFIG_SERIAL_SGI_L1_CONSOLE
+	if (ia64_platform_is("sn2"))
+		kdba_serial_console = KDBA_SC_SGI_L1;
+#endif
+	return;
+}
+
+/*
+ * kdba_adjust_ip
+ *
+ * 	Architecture specific adjustment of instruction pointer before leaving
+ *	kdb.
+ *
+ * Parameters:
+ *	reason		The reason KDB was invoked
+ *	error		The hardware-defined error code
+ *	regs		The exception frame at time of fault/breakpoint.  If reason
+ *			is KDB_REASON_SILENT then regs is NULL, otherwise it should
+ *			always be valid.
+ * Returns:
+ *	None.
+ * Locking:
+ *	None.
+ * Remarks:
+ *	On IA64, KDB_ENTER() uses break which is a fault, not a trap.  The
+ *	instruction pointer must be stepped before leaving kdb, otherwise we
+ *	get a loop.
+ */
+
+void
+kdba_adjust_ip(kdb_reason_t reason, int error, struct pt_regs *regs)
+{
+	if (reason == KDB_REASON_ENTER &&
+	    !KDB_STATE(IP_ADJUSTED)) {
+		if (KDB_NULL_REGS(regs))
+			return;
+		if (ia64_psr(regs)->ri < 2)
+			kdba_setpc(regs, regs->cr_iip + ia64_psr(regs)->ri + 1);
+		else
+			kdba_setpc(regs, regs->cr_iip + 16);
+	}
+}
Index: linux/arch/ia64/kernel/mca.c
===================================================================
--- linux.orig/arch/ia64/kernel/mca.c	2005-01-20 11:09:53.000000000 +1100
+++ linux/arch/ia64/kernel/mca.c	2005-01-20 11:12:36.000000000 +1100
@@ -64,6 +64,13 @@
 #include <linux/kernel.h>
 #include <linux/smp.h>
 #include <linux/workqueue.h>
+#ifdef	CONFIG_KDB
+#include <linux/kdb.h>
+#include <linux/kdbprivate.h>	/* for switch state wrappers */
+#include "entry.h"		/* for pNonSys */
+#define p5		5	/* from unwind.c, needed for pNonSys */
+#include <linux/delay.h>
+#endif	/* CONFIG_KDB */
 
 #include <asm/delay.h>
 #include <asm/machvec.h>
@@ -82,6 +89,40 @@
 # define IA64_MCA_DEBUG(fmt...)
 #endif
 
+#ifdef	CONFIG_KDB
+static void kdba_mca_init(int, pal_processor_state_info_t *psp, int);
+static irqreturn_t ia64_mca_rendez_int_handler(int, void *, struct pt_regs *);
+/* Warning: usage of kdba_mca_trace assumes that ia64 atomic inc/dec are lock
+ * free.  If atomic operations ever use spinlocks on ia64 then, sooner or later,
+ * this will deadlock on an MCA or INIT event (not irq safe).
+ *
+ * If you want kdb procedure traces at all times, not just during MCA/INIT
+ * handling, then use kdb to set kdba_mca_trace to 1, 'mm4 kdba_mca_trace 1' or
+ * patch this code to set kdba_mca_trace = ATOMIC_INIT(1).
+ * To disable kdb MCA tracing, 'mm4 no_kdba_mca_trace 1' or patch this code
+ * to set no_kdba_mca_trace = 1.
+ */
+static atomic_t kdba_mca_trace;
+static int no_kdba_mca_trace;
+#define INC_KDBA_MCA_TRACE() (void)(atomic_inc(&kdba_mca_trace))
+#define DEC_KDBA_MCA_TRACE() (void)(atomic_dec(&kdba_mca_trace))
+#define KDBA_MCA_TRACE_TEST()						\
+	(!no_kdba_mca_trace && atomic_read(&kdba_mca_trace))
+#define KDBA_MCA_TRACE()						\
+	if (KDBA_MCA_TRACE_TEST())					\
+		kdb_printf("KDBA_MCA_TRACE: %s: cpu %d itc %ld\n",	\
+			__FUNCTION__,					\
+			smp_processor_id(),				\
+			ia64_get_itc())
+extern int kdb_wait_for_cpus_secs;
+#else/* !CONFIG_KDB */
+#define real_ia64_mca_rendez_int_handler ia64_mca_rendez_int_handler
+#define INC_KDBA_MCA_TRACE() do {} while(0)
+#define DEC_KDBA_MCA_TRACE() do {} while(0)
+#define KDBA_MCA_TRACE_TEST() 0
+#define KDBA_MCA_TRACE() do {} while(0)
+#endif/* CONFIG_KDB */
+
 /* Used by mca_asm.S */
 ia64_mca_sal_to_os_state_t	ia64_sal_to_os_handoff_state;
 ia64_mca_os_to_sal_state_t	ia64_os_to_sal_handoff_state;
@@ -246,6 +287,7 @@ ia64_mca_log_sal_error_record(int sal_in
 	static const char * const rec_name[] = { "MCA", "INIT", "CMC", "CPE" };
 #endif
 
+	KDBA_MCA_TRACE();
 	size = ia64_log_get(sal_info_type, &buffer, irq_safe);
 	if (!size)
 		return;
@@ -278,6 +320,7 @@ ia64_mca_cpe_int_handler (int cpe_irq, v
 	static int		index;
 	static spinlock_t	cpe_history_lock = SPIN_LOCK_UNLOCKED;
 
+	KDBA_MCA_TRACE();
 	IA64_MCA_DEBUG("%s: received interrupt vector = %#x on CPU %d\n",
 		       __FUNCTION__, cpe_irq, smp_processor_id());
 
@@ -328,6 +371,7 @@ ia64_mca_cpe_int_handler (int cpe_irq, v
 
 #endif /* CONFIG_ACPI */
 
+#ifndef	CONFIG_KDB	/* KDB replaces the simple "dump everything" code */
 static void
 show_min_state (pal_min_state_area_t *minstate)
 {
@@ -512,6 +556,7 @@ init_handler_platform (pal_min_state_are
 	printk("\nINIT dump complete.  Please reboot now.\n");
 	while (1);			/* hang city if no debugger */
 }
+#endif	/* CONFIG_KDB */
 
 #ifdef CONFIG_ACPI
 /*
@@ -671,6 +716,7 @@ ia64_mca_wakeup_ipi_wait(void)
 	int	irr_bit = (IA64_MCA_WAKEUP_VECTOR & 0x3f);
 	u64	irr = 0;
 
+	KDBA_MCA_TRACE();
 	do {
 		switch(irr_num) {
 		      case 0:
@@ -719,6 +765,7 @@ static void
 ia64_mca_wakeup_all(void)
 {
 	int cpu;
+	KDBA_MCA_TRACE();
 
 	/* Clear the Rendez checkin flag for all cpus */
 	for(cpu = 0; cpu < NR_CPUS; cpu++) {
@@ -741,11 +788,13 @@ ia64_mca_wakeup_all(void)
  *  Outputs :   None
  */
 static irqreturn_t
-ia64_mca_rendez_int_handler(int rendez_irq, void *arg, struct pt_regs *ptregs)
+real_ia64_mca_rendez_int_handler(int rendez_irq, void *arg, struct pt_regs *ptregs)
 {
 	unsigned long flags;
 	int cpu = smp_processor_id();
 
+	INC_KDBA_MCA_TRACE();
+	KDBA_MCA_TRACE();
 	/* Mask all interrupts */
 	local_irq_save(flags);
 
@@ -763,6 +812,7 @@ ia64_mca_rendez_int_handler(int rendez_i
 
 	/* Enable all interrupts */
 	local_irq_restore(flags);
+	DEC_KDBA_MCA_TRACE();
 	return IRQ_HANDLED;
 }
 
@@ -784,6 +834,7 @@ ia64_mca_rendez_int_handler(int rendez_i
 static irqreturn_t
 ia64_mca_wakeup_int_handler(int wakeup_irq, void *arg, struct pt_regs *ptregs)
 {
+	KDBA_MCA_TRACE();
 	return IRQ_HANDLED;
 }
 
@@ -804,6 +855,7 @@ ia64_mca_wakeup_int_handler(int wakeup_i
 static void
 ia64_return_to_sal_check(int recover)
 {
+	KDBA_MCA_TRACE();
 
 	/* Copy over some relevant stuff from the sal_to_os_mca_handoff
 	 * so that it can be used at the time of os_mca_to_sal_handoff
@@ -874,6 +926,8 @@ ia64_mca_ucmc_handler(void)
 	pal_processor_state_info_t *psp = (pal_processor_state_info_t *)
 		&ia64_sal_to_os_handoff_state.proc_state_param;
 	int recover; 
+	INC_KDBA_MCA_TRACE();
+	KDBA_MCA_TRACE();
 
 	/* Get the MCA error record and log it */
 	ia64_mca_log_sal_error_record(SAL_INFO_TYPE_MCA);
@@ -887,6 +941,10 @@ ia64_mca_ucmc_handler(void)
 			&ia64_sal_to_os_handoff_state,
 			&ia64_os_to_sal_handoff_state)); 
 
+#ifdef	CONFIG_KDB
+	kdba_mca_init(SAL_INFO_TYPE_MCA, psp, recover);
+#endif	/* CONFIG_KDB */
+
 	/*
 	 *  Wakeup all the processors which are spinning in the rendezvous
 	 *  loop.
@@ -895,6 +953,7 @@ ia64_mca_ucmc_handler(void)
 
 	/* Return to SAL */
 	ia64_return_to_sal_check(recover);
+	DEC_KDBA_MCA_TRACE();
 }
 
 static DECLARE_WORK(cmc_disable_work, ia64_mca_cmc_vector_disable_keventd, NULL);
@@ -1131,6 +1190,8 @@ void
 ia64_init_handler (struct pt_regs *pt, struct switch_stack *sw)
 {
 	pal_min_state_area_t *ms;
+	INC_KDBA_MCA_TRACE();
+	KDBA_MCA_TRACE();
 
 	oops_in_progress = 1;	/* avoid deadlock in printk, but it makes recovery dodgy */
 	console_loglevel = 15;	/* make sure printks make it to console */
@@ -1145,7 +1206,17 @@ ia64_init_handler (struct pt_regs *pt, s
 	 */
 	ms = (pal_min_state_area_t *)(ia64_sal_to_os_handoff_state.pal_min_state | (6ul<<61));
 
+#ifdef	CONFIG_KDB
+	{
+		u8 *buffer;
+		ia64_log_get(SAL_INFO_TYPE_INIT, &buffer, 0);
+		kdba_mca_init(SAL_INFO_TYPE_INIT, NULL, 0);
+	}
+#else	/* !CONFIG_KDB */
 	init_handler_platform(ms, pt, sw);	/* call platform specific routines */
+#endif	/* CONFIG_KDB */
+	DEC_KDBA_MCA_TRACE();
+
 }
 
 static int __init
@@ -1250,6 +1321,12 @@ ia64_mca_init(void)
 			printk(KERN_INFO "Increasing MCA rendezvous timeout from "
 				"%ld to %ld milliseconds\n", timeout, isrv.v0);
 			timeout = isrv.v0;
+#ifdef CONFIG_KDB
+			/* kdb must wait long enough for the MCA timeout to trip
+			 * and process.  The MCA timeout is in milliseconds.
+			 */
+			kdb_wait_for_cpus_secs = max(kdb_wait_for_cpus_secs, (int)(timeout/1000) + 10);
+#endif
 			continue;
 		}
 		printk(KERN_ERR "Failed to register rendezvous interrupt "
@@ -1414,3 +1491,410 @@ ia64_mca_late_init(void)
 }
 
 device_initcall(ia64_mca_late_init);
+
+#ifdef	CONFIG_KDB
+
+/* This bit is tricky.  The main MCA handler (but not the MCA rendezvous
+ * handler) has its own stack and bspstore, it does not use the current task
+ * area.  The monarch INIT handler has its own stack but uses the current
+ * bspstore.  The slave INIT handlers share a dedicated stack but use the
+ * current bspstore, single threading through the shared stack.
+ *
+ * For all of the MCA and INIT handlers, r13 points to the current task.  r12 is
+ * not pointing to the current stack, except in the MCA rendezvous handler.
+ * bspstore may or may not be pointing to the current task.
+ *
+ * MCA main has no pt_regs or switch_stack, INIT monarch has regs but no
+ * switch_stack, INIT slave has neither pt_regs nor switch_stack.  Testing has
+ * shown that the pt_regs passed to the INIT monarch handler is no good, so we
+ * ignore it and always synthesize pt_regs from the SAL error record.
+ *
+ * The unwind code expects r13, r12 and bspstore to be in the same area, with
+ * the top of stack containing switch_stack and pt_regs.  bspstore in
+ * switch_stack must be pointing at the saved registers in the current task's
+ * register save area.  In addition the unwind data for the return address given
+ * in switch_stack.b0 must be sensible in order to start the unwind process.
+ * Neither MCA nor INIT handlers in mca_asm.S define any unwind data.  Even if
+ * they did define unwind data, it would lead back into SAL/PAL which is
+ * guaranteed to have no unwind data.
+ *
+ * The solution is to synthesize some pt_regs and switch_stack structures, put
+ * them on the current task's stack and tell kdb to use that state information.
+ * switch_stack is fudged to point to the bspstore at the time of failure, it
+ * also has a return address of ia64_leave_kernel which has the correct unwind
+ * context to start the backtrace process.  Unwind then sees a "normal"
+ * interrupt structure for MCA main, INIT monarch and INIT slave.
+ *
+ * MCA rendezvous is already a normal interrupt so it needs no special
+ * processing to get pt_regs and switch_stack.  However SAL requires the MCA
+ * rendezvous handler to call back into SAL where it will spin until the MCA
+ * handler releases the other cpus.  If the rendezvous code called kdb (which
+ * also spins) then it would trip the rendezvous timeout and SAL would hit the
+ * cpu with an INIT interrupt, not nice.  The solution is to put a wrapper
+ * around the rendezvous function, the wrapper saves the process state before
+ * diving into SAL.  The cpu will appear to be dead (not in kdb) but backtrace
+ * data will still be available.
+ *
+ * It's all smoke and mirrors, you know ...
+ */
+
+/* Stack shared amongst INIT slave handlers */
+
+struct {
+	volatile struct task_struct *lock;
+	u64 stack[KERNEL_STACK_SIZE/8 - 1];
+} ia64_init_slave_stack __attribute__((aligned(16)));
+
+struct {
+	u64 stack[KERNEL_STACK_SIZE/8];
+} ia64_init_monarch_stack __attribute__((aligned(16)));
+
+/* Structures and functions to wrap MCA handlers */
+
+KDBA_SW_INTERRUPT_WRAPPER3(ia64_mca_rendez_int_handler, INC_KDBA_MCA_TRACE(), DEC_KDBA_MCA_TRACE());
+
+struct kdba_mca_init_data {
+	struct pt_regs *regs;
+	u64 r12;
+	u64 bspstore;
+};
+
+/* If we are running on the shared init slave stack we just save the process
+ * data and sequence number, release the shared stack and spin.
+ */
+
+static void
+kdba_release_init_slave_stack(struct pt_regs *regs)
+{
+	KDBA_MCA_TRACE();
+	if (ia64_init_slave_stack.lock == current) {
+		kdb_save_running(regs);
+		if (!KDB_IS_RUNNING())
+			kdb_printf("%s: INIT slave tripped on cpu %d when not in kdb, probably lost the INIT monarch event\n",
+				__FUNCTION__, smp_processor_id());
+		__asm__ __volatile__ ("mov ar.rsc=0;;" ::: "memory");
+		ia64_init_slave_stack.lock = NULL;
+		while(1) {};
+	}
+	KDBA_MCA_TRACE();
+}
+
+/* Called via kdba_mca_init() -> unw_init_running() -> kdba_mca_init_handler() ->
+ * kdba_mca_init_handler2().  At this point pt_regs and switch_stack have been
+ * built but they are on the interrupt handler's stack, not on current.  Copy
+ * them across to current and adjust b0, bspstore, etc. to suit.  Update
+ * kdb_running_process to point to the copies.  Finally we can enter kdb.
+ *
+ * Assumption: unw_init_running() does DO_SAVE_SWITCH_STACK which calls
+ *             save_switch_stack() which does flushrs.  Therefore all registers
+ *             prior to br.call save_switch_stack have been written to backing
+ *             store.
+ *
+ * data->bspstore must contain ar.bsp at the time of MCA/INIT.
+ */
+
+static void
+kdba_mca_init_handler2(struct kdba_mca_init_data *data)
+{
+	struct kdb_running_process *krp = kdb_running_process + smp_processor_id();
+	struct switch_stack *prev_sw = krp->arch.sw;
+	extern char ia64_leave_kernel[];	/* Need asm address, not function descriptor */
+	KDBA_MCA_TRACE();
+	data->r12 -= sizeof(*(krp->regs));
+	krp->regs = (struct pt_regs *)(data->r12+16);
+	memcpy(krp->regs, data->regs, sizeof(*(krp->regs)));
+	data->r12 -= sizeof(*(krp->arch.sw));
+	krp->arch.sw = (struct switch_stack *)(data->r12+16);
+	memcpy(krp->arch.sw, prev_sw, sizeof(*(krp->arch.sw)));
+	krp->arch.sw->b0 = (unsigned long)ia64_leave_kernel;
+	krp->arch.sw->ar_bspstore = data->bspstore;
+	krp->arch.sw->ar_pfs = 0;
+	krp->arch.sw->pr = krp->regs->pr;
+	kdba_release_init_slave_stack(krp->regs);
+	kdb_save_running(krp->regs);	/*temp*/
+	if (!KDB_IS_RUNNING())		/*temp*/
+		kdb(KDB_REASON_CALL_PRESET, 0, krp->regs);
+	while(1) {};
+}
+
+static KDBA_UNWIND_HANDLER(kdba_mca_init_handler, struct kdba_mca_init_data, 0,
+	kdba_mca_init_handler2(data));
+
+/* The MCA handler does not use backing store in the process stack, it uses its
+ * own backing store, ia64_mca_bspstore.  How many registers are saved in the
+ * process stack and how many in ia64_mca_bspstore is timing dependent, RSE
+ * runs asynchronously. The unwind code requires that all registers be in the
+ * process stack, so copy any registers from ia64_mca_bspstore to the process
+ * stack.
+ *
+ * Registers from ar.bspstore through ar.bsp+sof at the time of the MCA are
+ * really in ia64_mca_bspstore, copy them back to the process stack.  The copy
+ * must be done register by register because the process stack and
+ * ia64_mca_bspstore have different alignments, which means that the saved RNAT
+ * data occurs at different places.
+ * 
+ * FIXME: The code assumes that all registers are valid and sets 0 RNaT words
+ * when copying back to the original stack.
+ */
+
+static void
+kdba_mca_bspstore_fixup(const sal_processor_static_info_t *s)
+{
+	u64 *old_bspstore, *old_bsp;
+	u64 *new_bspstore, *new_bsp;
+	u64 new_bsp_pa, ia64_mca_bspstore_pa;
+	u64 sof, slots;
+
+	asm volatile (";;flushrs;; mov %0=ar.bsp;;" : "=r"(new_bsp));
+
+        /* WAR for inconsistent V->P->V mappings in mca_asm.S for non-identity
+         * mapped kernels.  We can end up with a virtual address in ar.bspstore
+         * that is not the same as ia64_mca_bspstore but it still points to the
+         * same physical page as ia64_mca_bspstore.  Check the physical address
+         * instead of the virtual one.
+         */
+
+	new_bsp_pa = ia64_tpa((u64)new_bsp);
+	ia64_mca_bspstore_pa = ia64_tpa((u64)&ia64_mca_bspstore[0]);
+        if (new_bsp_pa < ia64_mca_bspstore_pa ||
+            new_bsp_pa >= ia64_mca_bspstore_pa + sizeof(ia64_mca_bspstore)) {
+		kdb_printf("%s: MCA is not using ia64_mca_bspstore, no fixup done [0x%p]\n",
+			__FUNCTION__, new_bsp);
+                return;
+        }
+
+        old_bspstore = (u64 *)(s->ar[18]);
+        old_bsp = (u64 *)(s->ar[17]);
+        sof = s->ar[64] & 0x7f;         /* from ar.pfs at time of MCA */
+        slots = ia64_rse_num_regs(old_bspstore, old_bsp) + sof;
+        new_bspstore = ia64_mca_bspstore;
+        new_bsp = ia64_rse_skip_regs(new_bspstore, slots);
+	
+	if (KDBA_MCA_TRACE_TEST())
+		kdb_printf("KDBA_MCA_TRACE: %s: old_bspstore 0x%p old_bsp 0x%p "
+			   "sof %ld new_bspstore 0x%p new_bsp 0x%p slots %ld %ld\n",
+			__FUNCTION__, old_bspstore, old_bsp,
+			sof, new_bspstore, new_bsp, slots,
+			ia64_rse_num_regs(new_bspstore, new_bsp));
+
+	while (old_bspstore < old_bsp && new_bspstore < new_bsp) {
+		if (ia64_rse_is_rnat_slot(new_bspstore)) {
+			++new_bspstore;
+			continue;
+		}
+		if (ia64_rse_is_rnat_slot(old_bspstore)) {
+			*old_bspstore++ = 0;	/* assume that all registers are valid */
+			continue;
+		}
+		*old_bspstore++ = *new_bspstore++;
+	}
+	if (ia64_rse_is_rnat_slot(old_bspstore))
+		*old_bspstore++ = 0;
+}
+
+static void
+kdba_mca_init(int sal_info_type, pal_processor_state_info_t *psp, int recover)
+{
+	struct pt_regs regs;
+	sal_processor_static_info_t *s;
+	pal_min_state_area_t *m;
+	struct kdba_mca_init_data data;
+	ia64_err_rec_t *plog_ptr;
+	int monarch = ia64_init_slave_stack.lock != current;
+	INC_KDBA_MCA_TRACE();
+	KDBA_MCA_TRACE();
+
+	if (recover)
+		goto out;
+	if (KDB_STATE(KDB_CONTROL)) {
+		kdb_printf("MCA/INIT received while in kdb, cannot reenter\n");
+		goto out;
+	}
+
+	KDB_FLAG_SET(CATASTROPHIC);	/* KDB does not continue after MCA/INIT events */
+	KDB_FLAG_SET(NOIPI);		/* do not send IPI for MCA/INIT events */
+	plog_ptr = (ia64_err_rec_t *)IA64_LOG_CURR_BUFFER(sal_info_type);
+	if (plog_ptr)
+		s = SAL_LPI_PSI_INFO(&plog_ptr->proc_err);
+	else
+		s = NULL;
+
+	/* Synthesize a struct pt_regs for the state at the time the error occurred */
+	memset(&regs, 0, sizeof(regs));
+	if (!s ||
+	    !s->valid.minstate ||
+	    !s->valid.br ||
+	    !s->valid.cr ||
+	    !s->valid.ar ||
+	    !s->valid.rr ||
+	    !s->valid.fr) {
+		/* Use printk to get the text in dmesg */
+		printk("%s: not enough data in pal_min_state_area for kdb backtrace, cpu %d\n",
+				__FUNCTION__, smp_processor_id());
+		goto out;
+	}
+
+	m = &(s->min_state_area);
+	regs.cr_ipsr = m->pmsa_ipsr;
+	regs.cr_iip = m->pmsa_iip;
+	if (!regs.cr_iip) {
+		printk("%s: cr_iip is 0, using xip instead, it may be wrong\n", __FUNCTION__);
+		regs.cr_iip = m->pmsa_xip;
+	}
+	regs.cr_ifs = m->pmsa_ifs;
+
+	regs.ar_unat = m->pmsa_nat_bits;
+	regs.ar_pfs = s->ar[64];
+	regs.ar_rsc = m->pmsa_rsc;
+	if (ia64_psr(&regs)->cpl) {
+		regs.ar_rnat = s->ar[19];
+		regs.ar_bspstore = s->ar[18];
+	}
+
+	/* unwind.c::unw_unwind() does special processing for interrupt frames.
+	 * It checks if the pNonSys predicate is set, if the predicate is clear
+	 * then unw_unwind() does _not_ adjust bsp over pt_regs.  Not that this
+	 * is documented, of course.
+	 *
+	 * pNonSys is normally set by minstate.h::SAVE_MIN.  The MCA handler
+	 * does not use SAVE_MIN; the INIT monarch handler uses SAVE_MIN but
+	 * experience has shown that the pt_regs is useless, it reflects the
+	 * call from SAL to ia64_monarch_init_handler, not the registers at the
+	 * time INIT was received.
+	 *
+	 * Not only do we have to synthesize our own pt_regs for MCA and INIT,
+	 * we must set the pNonSys predicate ourselves, otherwise unwind gets
+	 * intermittent errors :(
+	 */
+	regs.pr = m->pmsa_pr | (1UL << pNonSys);
+	regs.b0 = m->pmsa_br0;
+
+	regs.b6 = s->br[6];
+	regs.b7 = s->br[7];
+
+	regs.r1 = m->pmsa_gr[1-1];
+	regs.r2 = m->pmsa_gr[2-1];
+	regs.r3 = m->pmsa_gr[3-1];
+	regs.r8 = m->pmsa_gr[8-1];
+	regs.r9 = m->pmsa_gr[9-1];
+	regs.r10 = m->pmsa_gr[10-1];
+	regs.r11 = m->pmsa_gr[11-1];
+	regs.r12 = m->pmsa_gr[12-1];
+	regs.r13 = m->pmsa_gr[13-1];
+	regs.r14 = m->pmsa_gr[14-1];
+	regs.r15 = m->pmsa_gr[15-1];
+	regs.r16 = m->pmsa_bank1_gr[16-16];
+	regs.r17 = m->pmsa_bank1_gr[17-16];
+	regs.r18 = m->pmsa_bank1_gr[18-16];
+	regs.r19 = m->pmsa_bank1_gr[19-16];
+	regs.r20 = m->pmsa_bank1_gr[20-16];
+	regs.r21 = m->pmsa_bank1_gr[21-16];
+	regs.r22 = m->pmsa_bank1_gr[22-16];
+	regs.r23 = m->pmsa_bank1_gr[23-16];
+	regs.r24 = m->pmsa_bank1_gr[24-16];
+	regs.r25 = m->pmsa_bank1_gr[25-16];
+	regs.r26 = m->pmsa_bank1_gr[26-16];
+	regs.r27 = m->pmsa_bank1_gr[27-16];
+	regs.r28 = m->pmsa_bank1_gr[28-16];
+	regs.r29 = m->pmsa_bank1_gr[29-16];
+	regs.r30 = m->pmsa_bank1_gr[30-16];
+	regs.r31 = m->pmsa_bank1_gr[31-16];
+
+	regs.ar_csd = s->ar[25];
+	regs.ar_ssd = s->ar[26];
+	regs.ar_ccv = s->ar[32];
+	regs.ar_fpsr = s->ar[40];
+
+	regs.f6 = s->fr[6];
+	regs.f7 = s->fr[7];
+	regs.f8 = s->fr[8];
+	regs.f9 = s->fr[9];
+	regs.f10 = s->fr[10];
+	regs.f11 = s->fr[11];
+
+	if (ia64_psr(&regs)->cpl) {
+		printk("%s: MCA/INIT in user space, regs %p\n", __FUNCTION__, &regs);
+		/* monarch must get to kdb, even if it was interrupted in user space */
+		if (!monarch) {
+			kdba_release_init_slave_stack(NULL);
+			goto out;
+		}
+	}
+
+	/* FIXME: bsp and bspstore appear to be physical for TLB errors,
+	 * confirm this.  Make them virtual.
+	 */
+	if (psp && psp->tc) {
+		if (KDBA_MCA_TRACE_TEST())
+			kdb_printf("KDBA_MCA_TRACE: %s: psp->tc set, s %p old ar[17] 0x%lx ar[18] 0x%lx\n",
+				__FUNCTION__, s, s->ar[17], s->ar[18]);
+		s->ar[17] |= 0xe000000000000000;
+		s->ar[18] |= 0xe000000000000000;
+		if (KDBA_MCA_TRACE_TEST())
+			kdb_printf("KDBA_MCA_TRACE: new ar[17] 0x%lx ar[18] 0x%lx\n",
+				s->ar[17], s->ar[18]);
+	}
+
+	/* Set up the data required by kdba_mca_init_handler2() */
+	data.regs = &regs;
+	data.r12 = regs.r12;
+	data.bspstore = s->ar[17];
+	if (sal_info_type == SAL_INFO_TYPE_MCA)
+		kdba_mca_bspstore_fixup(s);
+	unw_init_running(kdba_mca_init_handler, &data);
+
+	/* FIXME: bsp and bspstore appear to be physical for TLB errors,
+	 * confirm this.  Make them physical again.
+	 */
+	if (psp && psp->tc) {
+		if (KDBA_MCA_TRACE_TEST())
+			kdb_printf("KDBA_MCA_TRACE: %s: psp->tc set, s %p old ar[17] 0x%lx ar[18] 0x%lx\n",
+				__FUNCTION__, s, s->ar[17], s->ar[18]);
+		s->ar[17] ^= 0xe000000000000000;
+		s->ar[18] ^= 0xe000000000000000;
+		if (KDBA_MCA_TRACE_TEST())
+			kdb_printf("KDBA_MCA_TRACE: new ar[17] 0x%lx ar[18] 0x%lx\n",
+				s->ar[17], s->ar[18]);
+	}
+
+out:
+	DEC_KDBA_MCA_TRACE();
+}
+
+/*
+ * C portion of the OS INIT slave handler
+ *
+ * Called from ia64_slave_init_handler
+ *
+ * Inputs: INIT flag (GR11 from SAL to ia64_slave_init_handler).
+ *
+ * Never returns:
+ *
+ */
+void
+ia64_init_slave_handler (unsigned long init_flag)
+{
+	static int first_slave = 1;
+	int monarch = ia64_init_slave_stack.lock != current;
+	u8 *buffer;
+
+	oops_in_progress = 1;	/* avoid deadlock in printk, but it makes recovery dodgy */
+
+	KDBA_MCA_TRACE();
+	if (monarch) {
+		kdb_printf("INIT monarch handler on cpu %d\n", smp_processor_id());
+	}
+	else if (first_slave) {
+			first_slave = 0;
+			udelay(3000000);	/* wait for monarch to get ready */
+	}
+	KDBA_MCA_TRACE();
+
+	ia64_log_get(SAL_INFO_TYPE_INIT, &buffer, 0);
+	kdba_mca_init(SAL_INFO_TYPE_INIT, NULL, 0);
+	kdb_printf("%s: cpu %d spinning here\n", __FUNCTION__, smp_processor_id());
+	kdba_release_init_slave_stack(NULL);
+	while(1) {};
+}
+
+#endif	/* !CONFIG_KDB */
Index: linux/arch/ia64/kernel/mca_asm.S
===================================================================
--- linux.orig/arch/ia64/kernel/mca_asm.S	2004-12-25 08:35:25.000000000 +1100
+++ linux/arch/ia64/kernel/mca_asm.S	2005-01-20 11:12:36.000000000 +1100
@@ -924,5 +924,88 @@ END(ia64_monarch_init_handler)
 //
 
 GLOBAL_ENTRY(ia64_slave_init_handler)
+#ifdef	CONFIG_KDB
+//
+// When we get here, the following registers have been
+// set by the SAL for our use
+//
+//		1. GR1 = OS INIT GP (physical)
+//		2. GR8 = PAL_PROC physical address
+//		3. GR9 = SAL_PROC physical address
+//		4. GR10 = SAL GP (physical)
+//		5. GR11 = Init Reason
+//			0 = Received INIT for event other than crash dump switch
+//			1 = Received INIT signal on this processor during machine check rendezvous
+//			2 = Received INIT due to CrashDump switch assertion
+//		6. GR12 = Return address to location within SAL_INIT procedure
+//
+// KDB never returns from INIT interrupts, so we do not save any state.  INIT
+// slave handlers in KDB use a single shared stack to save space.  The first 8
+// bytes of that stack are a lock to single thread slave events through the
+// stack.  The lock is released in kdba_mca_init_handler2() after saving the
+// state of the interrupted code and just prior to entering kdb(), at which
+// point the shared stack is available for reuse.
+//
+	.global ia64_init_slave_stack
+	LOAD_PHYSICAL(p0,r3,ia64_init_slave_stack)
+
+	mov r13=IA64_KR(CURRENT)		// current (virtual)
+	cover
+	;;
+	invala
+	dep r1=-1,r1,61,3			// convert gp to virtual
+	;;
+	mov r4=r3				// copy slave stack (physical)
+	;;
+	mov ar.rsc=0
+	dep r4=-1,r4,61,3			// slave stack (virtual)
+1:						// lock the slave stack
+	mov ar.ccv=0
+	ld8 r2=[r3]
+	;;
+	cmp.ne p15,p0=r2,r0
+(p15)   br 1b
+	;;
+	cmpxchg8.acq r2=[r3],r13,ar.ccv
+	;;
+	cmp.ne p15,p0=r2,r0
+(p15)   br 1b
+	;;
+	addl r2=IA64_RBS_OFFSET,r3		// base of rbs (physical)
+	;;
+	addl r12=KERNEL_STACK_SIZE-16,r3	// scratch pad at top of stack (physical)
+	dep r2=-1,r2,61,3			// base of rbs (virtual)
+	;;
+	dep r12=-1,r12,61,3			// top of stack (virtual)
+	mov ar.bspstore=r2
+	;;
+	mov ar.rsc=3
+
+// We need to switch to Virtual mode before hitting the C functions.
+	movl	r2=IA64_PSR_IT|IA64_PSR_IC|IA64_PSR_DT|IA64_PSR_RT|IA64_PSR_DFH|IA64_PSR_BN
+	mov	r3=psr				// get the current psr, minimum enabled at this point
+	;;
+	or	r2=r2,r3
+	;;
+	movl	r3=2f
+	;;
+	mov	cr.iip=r3			// short return to set the appropriate bits
+	mov	cr.ipsr=r2			// need to do an rfi to set appropriate bits
+	;;
+	rfi
+	;;
+
+2:
+	alloc r14=ar.pfs,0,0,1,0
+	;;
+	mov out0=r11				// pass INIT reason to C code
+	;;
+	br.call.sptk.many rp=ia64_init_slave_handler
+	;;
+	mov ar.rsc=0				// back to lazy mode if we ever return
+	;;
+	st8 [r4]=r0				// drop shared stack on return
+#endif	/* CONFIG_KDB */
+
 1:	br.sptk 1b
 END(ia64_slave_init_handler)
Index: linux/arch/ia64/kernel/smp.c
===================================================================
--- linux.orig/arch/ia64/kernel/smp.c	2004-12-25 08:35:40.000000000 +1100
+++ linux/arch/ia64/kernel/smp.c	2005-01-20 11:12:36.000000000 +1100
@@ -35,6 +35,11 @@
 #include <asm/current.h>
 #include <asm/delay.h>
 #include <asm/machvec.h>
+
+#ifdef	CONFIG_KDB
+#include <linux/kdb.h>
+#endif	/* CONFIG_KDB */
+
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/page.h>
@@ -66,6 +71,9 @@ static volatile struct call_data_struct 
 
 #define IPI_CALL_FUNC		0
 #define IPI_CPU_STOP		1
+#ifdef	CONFIG_KDB
+#define IPI_KDB_INTERRUPT	2
+#endif	/* CONFIG_KDB */
 
 /* This needs to be cacheline aligned because it is written to by *other* CPUs.  */
 static DEFINE_PER_CPU(u64, ipi_operation) ____cacheline_aligned;
@@ -156,6 +164,13 @@ handle_IPI (int irq, void *dev_id, struc
 				stop_this_cpu();
 				break;
 
+#ifdef CONFIG_KDB
+			      case IPI_KDB_INTERRUPT:
+				if (!kdb_ipi(regs, NULL))
+					printk(KERN_ERR "kdb_ipi() rejected IPI_KDB_INTERRUPT\n");
+				break;
+#endif
+
 			      default:
 				printk(KERN_CRIT "Unknown IPI on CPU %d: %lu\n", this_cpu, which);
 				break;
@@ -375,3 +390,12 @@ setup_profiling_timer (unsigned int mult
 {
 	return -EINVAL;
 }
+
+#if defined(CONFIG_KDB)
+void
+smp_kdb_stop(void)
+{
+	if (!KDB_FLAG(NOIPI))
+		send_IPI_allbutself(IPI_KDB_INTERRUPT);
+}
+#endif	/* CONFIG_KDB */
Index: linux/arch/ia64/kernel/traps.c
===================================================================
--- linux.orig/arch/ia64/kernel/traps.c	2004-12-25 08:35:39.000000000 +1100
+++ linux/arch/ia64/kernel/traps.c	2005-01-20 11:12:36.000000000 +1100
@@ -14,6 +14,9 @@
 #include <linux/tty.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
 #include <linux/module.h>       /* for EXPORT_SYMBOL */
+#ifdef	CONFIG_KDB
+#include <linux/kdb.h>
+#endif	/* CONFIG_KDB */
 #include <linux/hardirq.h>
 
 #include <asm/fpswa.h>
@@ -95,6 +98,9 @@ die (const char *str, struct pt_regs *re
 	bust_spinlocks(0);
 	die.lock_owner = -1;
 	spin_unlock_irq(&die.lock);
+#ifdef	CONFIG_KDB
+	(void)kdb(KDB_REASON_OOPS, err, regs);
+#endif	/* CONFIG_KDB */
   	do_exit(SIGSEGV);
 }
 
@@ -178,6 +184,14 @@ ia64_bad_break (unsigned long break_num,
 		if (break_num < 0x80000) {
 			sig = SIGILL; code = __ILL_BREAK;
 		} else {
+#ifdef	CONFIG_KDB
+			if (break_num == KDB_BREAK_ENTER &&
+			    kdb(KDB_REASON_ENTER, break_num, regs))
+				return;		/* kdb handled it */
+			if (break_num == KDB_BREAK_BREAK &&
+			    kdb(KDB_REASON_BREAK, break_num, regs))
+				return;		/* kdb handled it */
+#endif	/* CONFIG_KDB */
 			sig = SIGTRAP; code = TRAP_BRKPT;
 		}
 	}
@@ -522,6 +536,10 @@ ia64_fault (unsigned long vector, unsign
 		      case 35: siginfo.si_code = TRAP_BRANCH; ifa = 0; break;
 		      case 36: siginfo.si_code = TRAP_TRACE; ifa = 0; break;
 		}
+#ifdef	CONFIG_KDB
+		if (!user_mode(regs) && kdb(KDB_REASON_DEBUG, vector, regs))
+			return;	/* kdb handled this */
+#endif	/* CONFIG_KDB */
 		siginfo.si_signo = SIGTRAP;
 		siginfo.si_errno = 0;
 		siginfo.si_addr  = (void __user *) ifa;
Index: linux/arch/ia64/kernel/unwind.c
===================================================================
--- linux.orig/arch/ia64/kernel/unwind.c	2005-01-20 11:05:56.000000000 +1100
+++ linux/arch/ia64/kernel/unwind.c	2005-01-20 11:12:36.000000000 +1100
@@ -59,13 +59,27 @@
 
 #ifdef UNW_DEBUG
   static unsigned int unw_debug_level = UNW_DEBUG;
-#  define UNW_DEBUG_ON(n)	unw_debug_level >= n
-   /* Do not code a printk level, not all debug lines end in newline */
-#  define UNW_DPRINT(n, ...)  if (UNW_DEBUG_ON(n)) printk(__VA_ARGS__)
+#  ifdef CONFIG_KDB
+#    include <linux/kdb.h>
+#    include <linux/kdbprivate.h>
+#    define UNW_KMALLOC(s, f)	debug_kmalloc(s, f)
+#    define UNW_KFREE(p)	debug_kfree(p)
+#    define UNW_DEBUG_ON(n)	(unw_debug_level >= n && !KDB_IS_RUNNING())
+#    define UNW_DPRINT(n, ...)	if (UNW_DEBUG_ON(n)) kdb_printf(__VA_ARGS__)
+#  else	/* !CONFIG_KDB */
+#    define UNW_DEBUG_ON(n)	unw_debug_level >= n
+     /* Do not code a printk level, not all debug lines end in newline */
+#    define UNW_DPRINT(n, ...)  if (UNW_DEBUG_ON(n)) printk(__VA_ARGS__)
+#    define UNW_KMALLOC(s, f)	kmalloc(s, f)
+#    define UNW_KFREE(p)	kfree(p)
+#  endif /* CONFIG_KDB */
+#  undef inline
 #  define inline
 #else /* !UNW_DEBUG */
 #  define UNW_DEBUG_ON(n)  0
 #  define UNW_DPRINT(n, ...)
+#  define UNW_KMALLOC(s, f)	kmalloc(s, f)
+#  define UNW_KFREE(p)		kfree(p)
 #endif /* UNW_DEBUG */
 
 #if UNW_STATS
@@ -74,10 +88,10 @@
 # define STAT(x...)
 #endif
 
-#define alloc_reg_state()	kmalloc(sizeof(struct unw_reg_state), GFP_ATOMIC)
-#define free_reg_state(usr)	kfree(usr)
-#define alloc_labeled_state()	kmalloc(sizeof(struct unw_labeled_state), GFP_ATOMIC)
-#define free_labeled_state(usr)	kfree(usr)
+#define alloc_reg_state()	UNW_KMALLOC(sizeof(struct unw_reg_state), GFP_ATOMIC)
+#define free_reg_state(usr)	UNW_KFREE(usr)
+#define alloc_labeled_state()	UNW_KMALLOC(sizeof(struct unw_labeled_state), GFP_ATOMIC)
+#define free_labeled_state(usr)	UNW_KFREE(usr)
 
 typedef unsigned long unw_word;
 typedef unsigned char unw_hash_index_t;
@@ -2092,7 +2106,7 @@ unw_add_unwind_table (const char *name, 
 		return NULL;
 	}
 
-	table = kmalloc(sizeof(*table), GFP_USER);
+	table = UNW_KMALLOC(sizeof(*table), GFP_USER);
 	if (!table)
 		return NULL;
 
@@ -2165,7 +2179,7 @@ unw_remove_unwind_table (void *handle)
 		write_unlock(&tmp->lock);
 	}
 
-	kfree(table);
+	UNW_KFREE(table);
 }
 
 static int __init
@@ -2199,7 +2213,7 @@ create_gate_table (void)
 		size += 3*8 + 8 + 8*UNW_LENGTH(*(u64 *) (segbase + entry->info_offset));
 	size += 8;	/* reserve space for "end of table" marker */
 
-	unw.gate_table = kmalloc(size, GFP_KERNEL);
+	unw.gate_table = UNW_KMALLOC(size, GFP_KERNEL);
 	if (!unw.gate_table) {
 		unw.gate_table_size = 0;
 		printk(KERN_ERR "%s: unable to create unwind data for gate page!\n", __FUNCTION__);
Index: linux/arch/ia64/kernel/vmlinux.lds.S
===================================================================
--- linux.orig/arch/ia64/kernel/vmlinux.lds.S	2004-12-25 08:35:25.000000000 +1100
+++ linux/arch/ia64/kernel/vmlinux.lds.S	2005-01-20 11:12:36.000000000 +1100
@@ -24,6 +24,7 @@ SECTIONS
 	*(.exit.text)
 	*(.exit.data)
 	*(.exitcall.exit)
+	*(.kdb_exitcall.exit)
 	*(.IA_64.unwind.exit.text)
 	*(.IA_64.unwind_info.exit.text)
 	}
@@ -148,6 +149,12 @@ SECTIONS
 	  *(.initcall7.init)
 	  __initcall_end = .;
 	}
+  .kdb_initcall.init : AT(ADDR(.kdb_initcall.init) - LOAD_OFFSET)
+	{
+	  __kdb_initcall_start = .;
+	  *(.kdb_initcall.init)
+	  __kdb_initcall_end = .;
+	}
    __con_initcall_start = .;
   .con_initcall.init : AT(ADDR(.con_initcall.init) - LOAD_OFFSET)
 	{ *(.con_initcall.init) }
Index: linux/include/asm-ia64/ansidecl.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-ia64/ansidecl.h	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,253 @@
+/* ANSI and traditional C compatability macros
+   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* ANSI and traditional C compatibility macros
+
+   ANSI C is assumed if __STDC__ is #defined.
+
+   Macro	ANSI C definition	Traditional C definition
+   -----	---- - ----------	----------- - ----------
+   PTR		`void *'		`char *'
+   LONG_DOUBLE	`long double'		`double'
+   VOLATILE	`volatile'		`'
+   SIGNED	`signed'		`'
+   PTRCONST	`void *const'		`char *'
+   ANSI_PROTOTYPES  1			not defined
+
+   CONST is also defined, but is obsolete.  Just use const.
+
+   obsolete --     DEFUN (name, arglist, args)
+
+	Defines function NAME.
+
+	ARGLIST lists the arguments, separated by commas and enclosed in
+	parentheses.  ARGLIST becomes the argument list in traditional C.
+
+	ARGS list the arguments with their types.  It becomes a prototype in
+	ANSI C, and the type declarations in traditional C.  Arguments should
+	be separated with `AND'.  For functions with a variable number of
+	arguments, the last thing listed should be `DOTS'.
+
+   obsolete --     DEFUN_VOID (name)
+
+	Defines a function NAME, which takes no arguments.
+
+   obsolete --     EXFUN (name, (prototype))	-- obsolete.
+
+	Replaced by PARAMS.  Do not use; will disappear someday soon.
+	Was used in external function declarations.
+	In ANSI C it is `NAME PROTOTYPE' (so PROTOTYPE should be enclosed in
+	parentheses).  In traditional C it is `NAME()'.
+	For a function that takes no arguments, PROTOTYPE should be `(void)'.
+
+   obsolete --     PROTO (type, name, (prototype)    -- obsolete.
+
+	This one has also been replaced by PARAMS.  Do not use.
+
+   PARAMS ((args))
+
+	We could use the EXFUN macro to handle prototype declarations, but
+	the name is misleading and the result is ugly.  So we just define a
+	simple macro to handle the parameter lists, as in:
+
+	      static int foo PARAMS ((int, char));
+
+	This produces:  `static int foo();' or `static int foo (int, char);'
+
+	EXFUN would have done it like this:
+
+	      static int EXFUN (foo, (int, char));
+
+	but the function is not external...and it's hard to visually parse
+	the function name out of the mess.   EXFUN should be considered
+	obsolete; new code should be written to use PARAMS.
+
+   DOTS is also obsolete.
+
+   Examples:
+
+	extern int printf PARAMS ((const char *format, ...));
+*/
+
+#ifndef	_ANSIDECL_H
+
+#define	_ANSIDECL_H	1
+
+
+/* Every source file includes this file,
+   so they will all get the switch for lint.  */
+/* LINTLIBRARY */
+
+
+#if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)
+/* All known AIX compilers implement these things (but don't always
+   define __STDC__).  The RISC/OS MIPS compiler defines these things
+   in SVR4 mode, but does not define __STDC__.  */
+
+#define	PTR		void *
+#define	PTRCONST	void *CONST
+#define	LONG_DOUBLE	long double
+
+#ifndef IN_GCC
+#define	AND		,
+#define	NOARGS		void
+#define	VOLATILE	volatile
+#define	SIGNED		signed
+#endif /* ! IN_GCC */
+
+#ifndef PARAMS
+#define PARAMS(paramlist)		paramlist
+#endif
+#define ANSI_PROTOTYPES			1
+
+#define VPARAMS(ARGS)			ARGS
+#define VA_START(va_list,var)		va_start(va_list,var)
+
+/* These are obsolete.  Do not use.  */
+#ifndef IN_GCC
+#define CONST				const
+#define DOTS				, ...
+#define PROTO(type, name, arglist)	type name arglist
+#define EXFUN(name, proto)		name proto
+#define DEFUN(name, arglist, args)	name(args)
+#define DEFUN_VOID(name)		name(void)
+#endif /* ! IN_GCC */
+
+#else	/* Not ANSI C.  */
+
+#define	PTR		char *
+#define	PTRCONST	PTR
+#define	LONG_DOUBLE	double
+
+#ifndef IN_GCC
+#define	AND		;
+#define	NOARGS
+#define	VOLATILE
+#define	SIGNED
+#endif /* !IN_GCC */
+
+#ifndef const /* some systems define it in header files for non-ansi mode */
+#define	const
+#endif
+
+#define PARAMS(paramlist)		()
+
+#define VPARAMS(ARGS)			(va_alist) va_dcl
+#define VA_START(va_list,var)		va_start(va_list)
+
+/* These are obsolete.  Do not use.  */
+#ifndef IN_GCC
+#define CONST
+#define DOTS
+#define PROTO(type, name, arglist)	type name ()
+#define EXFUN(name, proto)		name()
+#define DEFUN(name, arglist, args)	name arglist args;
+#define DEFUN_VOID(name)		name()
+#endif /* ! IN_GCC */
+
+#endif	/* ANSI C.  */
+
+/* Using MACRO(x,y) in cpp #if conditionals does not work with some
+   older preprocessors.  Thus we can't define something like this:
+
+#define HAVE_GCC_VERSION(MAJOR, MINOR) \
+  (__GNUC__ > (MAJOR) || (__GNUC__ == (MAJOR) && __GNUC_MINOR__ >= (MINOR)))
+
+and then test "#if HAVE_GCC_VERSION(2,7)".
+
+So instead we use the macro below and test it against specific values.  */
+
+/* This macro simplifies testing whether we are using gcc, and if it
+   is of a particular minimum version. (Both major & minor numbers are
+   significant.)  This macro will evaluate to 0 if we are not using
+   gcc at all.  */
+#ifndef GCC_VERSION
+#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)
+#endif /* GCC_VERSION */
+
+/* Define macros for some gcc attributes.  This permits us to use the
+   macros freely, and know that they will come into play for the
+   version of gcc in which they are supported.  */
+
+#if (GCC_VERSION < 2007)
+# define __attribute__(x)
+#endif
+
+/* Attribute __malloc__ on functions was valid as of gcc 2.96. */
+#ifndef ATTRIBUTE_MALLOC
+# if (GCC_VERSION >= 2096)
+#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
+# else
+#  define ATTRIBUTE_MALLOC
+# endif /* GNUC >= 2.96 */
+#endif /* ATTRIBUTE_MALLOC */
+
+/* Attributes on labels were valid as of gcc 2.93. */
+#ifndef ATTRIBUTE_UNUSED_LABEL
+# if (GCC_VERSION >= 2093)
+#  define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED
+# else
+#  define ATTRIBUTE_UNUSED_LABEL
+# endif /* GNUC >= 2.93 */
+#endif /* ATTRIBUTE_UNUSED_LABEL */
+
+#ifndef ATTRIBUTE_UNUSED
+#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+#endif /* ATTRIBUTE_UNUSED */
+
+#ifndef ATTRIBUTE_NORETURN
+#define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))
+#endif /* ATTRIBUTE_NORETURN */
+
+#ifndef ATTRIBUTE_PRINTF
+#define ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n)))
+#define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)
+#define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)
+#define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)
+#define ATTRIBUTE_PRINTF_4 ATTRIBUTE_PRINTF(4, 5)
+#define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)
+#endif /* ATTRIBUTE_PRINTF */
+
+/* We use __extension__ in some places to suppress -pedantic warnings
+   about GCC extensions.  This feature didn't work properly before
+   gcc 2.8.  */
+#if GCC_VERSION < 2008
+#define __extension__
+#endif
+
+/* Bootstrap support: Autoconf will possibly define the `inline' or
+   `const' keywords as macros, however this is only valid for the
+   stage1 compiler.  If we detect a modern version of gcc,
+   unconditionally reset the values.  This makes sure the right thing
+   happens in stage2 and later.  We need to do this very early;
+   i.e. before any header files that might use these keywords.
+   Otherwise conflicts might occur.  */
+
+#if (GCC_VERSION >= 2007)
+# ifdef __STDC__
+#  undef const
+# endif
+# undef inline
+# define inline __inline__  /* __inline__ prevents -pedantic warnings */
+# ifndef HAVE_LONG_DOUBLE
+#  define HAVE_LONG_DOUBLE 1
+# endif
+#endif /* GCC >= 2.7 */
+
+#endif	/* ansidecl.h	*/
Index: linux/include/asm-ia64/bfd.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-ia64/bfd.h	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,3618 @@
+/* Main header file for the bfd library -- portable access to object files.
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001
+   Free Software Foundation, Inc.
+   Contributed by Cygnus Support.
+
+** NOTE: bfd.h and bfd-in2.h are GENERATED files.  Don't change them;
+** instead, change bfd-in.h or the other BFD source files processed to
+** generate these files.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* bfd.h -- The only header file required by users of the bfd library
+
+The bfd.h file is generated from bfd-in.h and various .c files; if you
+change it, your changes will probably be lost.
+
+All the prototypes and definitions following the comment "THE FOLLOWING
+IS EXTRACTED FROM THE SOURCE" are extracted from the source files for
+BFD.  If you change it, someone oneday will extract it from the source
+again, and your changes will be lost.  To save yourself from this bind,
+change the definitions in the source in the bfd directory.  Type "make
+docs" and then "make headers" in that directory, and magically this file
+will change to reflect your changes.
+
+If you don't have the tools to perform the extraction, then you are
+safe from someone on your system trampling over your header files.
+You should still maintain the equivalence between the source and this
+file though; every change you make to the .c file should be reflected
+here.  */
+
+#ifndef __BFD_H_SEEN__
+#define __BFD_H_SEEN__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if 0	/* CONFIG_KDB */
+#include "ansidecl.h"
+#else
+#include <asm/ansidecl.h>
+#endif	/* CONFIG_KDB */
+
+/* These two lines get substitutions done by commands in Makefile.in.  */
+#define BFD_VERSION  "2.11.90.0.8"
+#define BFD_ARCH_SIZE 64
+#define BFD_HOST_64BIT_LONG 1
+#if 0
+#define BFD_HOST_64_BIT 
+#define BFD_HOST_U_64_BIT 
+#endif
+
+#if BFD_ARCH_SIZE >= 64
+#define BFD64
+#endif
+
+#ifndef INLINE
+#if __GNUC__ >= 2
+#define INLINE __inline__
+#else
+#define INLINE
+#endif
+#endif
+
+/* forward declaration */
+typedef struct _bfd bfd;
+
+/* To squelch erroneous compiler warnings ("illegal pointer
+   combination") from the SVR3 compiler, we would like to typedef
+   boolean to int (it doesn't like functions which return boolean.
+   Making sure they are never implicitly declared to return int
+   doesn't seem to help).  But this file is not configured based on
+   the host.  */
+/* General rules: functions which are boolean return true on success
+   and false on failure (unless they're a predicate).   -- bfd.doc */
+/* I'm sure this is going to break something and someone is going to
+   force me to change it.  */
+/* typedef enum boolean {false, true} boolean; */
+/* Yup, SVR4 has a "typedef enum boolean" in <sys/types.h>  -fnf */
+/* It gets worse if the host also defines a true/false enum... -sts */
+/* And even worse if your compiler has built-in boolean types... -law */
+#if defined (__GNUG__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 6))
+#define TRUE_FALSE_ALREADY_DEFINED
+#endif
+#ifdef MPW
+/* Pre-emptive strike - get the file with the enum.  */
+#include <Types.h>
+#define TRUE_FALSE_ALREADY_DEFINED
+#endif /* MPW */
+#ifndef TRUE_FALSE_ALREADY_DEFINED
+typedef enum bfd_boolean {false, true} boolean;
+#define BFD_TRUE_FALSE
+#else
+/* Use enum names that will appear nowhere else.  */
+typedef enum bfd_boolean {bfd_fffalse, bfd_tttrue} boolean;
+#endif
+
+/* A pointer to a position in a file.  */
+/* FIXME:  This should be using off_t from <sys/types.h>.
+   For now, try to avoid breaking stuff by not including <sys/types.h> here.
+   This will break on systems with 64-bit file offsets (e.g. 4.4BSD).
+   Probably the best long-term answer is to avoid using file_ptr AND off_t
+   in this header file, and to handle this in the BFD implementation
+   rather than in its interface.  */
+/* typedef off_t	file_ptr; */
+typedef long int file_ptr;
+
+/* Support for different sizes of target format ints and addresses.
+   If the type `long' is at least 64 bits, BFD_HOST_64BIT_LONG will be
+   set to 1 above.  Otherwise, if gcc is being used, this code will
+   use gcc's "long long" type.  Otherwise, BFD_HOST_64_BIT must be
+   defined above.  */
+
+#ifndef BFD_HOST_64_BIT
+# if BFD_HOST_64BIT_LONG
+#  define BFD_HOST_64_BIT long
+#  define BFD_HOST_U_64_BIT unsigned long
+# else
+#  ifdef __GNUC__
+#   if __GNUC__ >= 2
+#    define BFD_HOST_64_BIT long long
+#    define BFD_HOST_U_64_BIT unsigned long long
+#   endif /* __GNUC__ >= 2 */
+#  endif /* ! defined (__GNUC__) */
+# endif /* ! BFD_HOST_64BIT_LONG */
+#endif /* ! defined (BFD_HOST_64_BIT) */
+
+#ifdef BFD64
+
+#ifndef BFD_HOST_64_BIT
+ #error No 64 bit integer type available
+#endif /* ! defined (BFD_HOST_64_BIT) */
+
+typedef BFD_HOST_U_64_BIT bfd_vma;
+typedef BFD_HOST_64_BIT bfd_signed_vma;
+typedef BFD_HOST_U_64_BIT bfd_size_type;
+typedef BFD_HOST_U_64_BIT symvalue;
+
+#ifndef fprintf_vma
+#if BFD_HOST_64BIT_LONG
+#define sprintf_vma(s,x) sprintf (s, "%016lx", x)
+#define fprintf_vma(f,x) fprintf (f, "%016lx", x)
+#else
+#define _bfd_int64_low(x) ((unsigned long) (((x) & 0xffffffff)))
+#define _bfd_int64_high(x) ((unsigned long) (((x) >> 32) & 0xffffffff))
+#define fprintf_vma(s,x) \
+  fprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
+#define sprintf_vma(s,x) \
+  sprintf ((s), "%08lx%08lx", _bfd_int64_high (x), _bfd_int64_low (x))
+#endif
+#endif
+
+#else /* not BFD64  */
+
+/* Represent a target address.  Also used as a generic unsigned type
+   which is guaranteed to be big enough to hold any arithmetic types
+   we need to deal with.  */
+typedef unsigned long bfd_vma;
+
+/* A generic signed type which is guaranteed to be big enough to hold any
+   arithmetic types we need to deal with.  Can be assumed to be compatible
+   with bfd_vma in the same way that signed and unsigned ints are compatible
+   (as parameters, in assignment, etc).  */
+typedef long bfd_signed_vma;
+
+typedef unsigned long symvalue;
+typedef unsigned long bfd_size_type;
+
+/* Print a bfd_vma x on stream s.  */
+#define fprintf_vma(s,x) fprintf (s, "%08lx", x)
+#define sprintf_vma(s,x) sprintf (s, "%08lx", x)
+
+#endif /* not BFD64  */
+
+#define printf_vma(x) fprintf_vma(stdout,x)
+
+typedef unsigned int flagword;	/* 32 bits of flags */
+typedef unsigned char bfd_byte;
+
+/** File formats */
+
+typedef enum bfd_format {
+	      bfd_unknown = 0,	/* file format is unknown */
+	      bfd_object,	/* linker/assember/compiler output */
+	      bfd_archive,	/* object archive file */
+	      bfd_core,		/* core dump */
+	      bfd_type_end}	/* marks the end; don't use it! */
+         bfd_format;
+
+/* Values that may appear in the flags field of a BFD.  These also
+   appear in the object_flags field of the bfd_target structure, where
+   they indicate the set of flags used by that backend (not all flags
+   are meaningful for all object file formats) (FIXME: at the moment,
+   the object_flags values have mostly just been copied from backend
+   to another, and are not necessarily correct).  */
+
+/* No flags.  */
+#define BFD_NO_FLAGS   	0x00
+
+/* BFD contains relocation entries.  */
+#define HAS_RELOC   	0x01
+
+/* BFD is directly executable.  */
+#define EXEC_P      	0x02
+
+/* BFD has line number information (basically used for F_LNNO in a
+   COFF header).  */
+#define HAS_LINENO  	0x04
+
+/* BFD has debugging information.  */
+#define HAS_DEBUG   	0x08
+
+/* BFD has symbols.  */
+#define HAS_SYMS    	0x10
+
+/* BFD has local symbols (basically used for F_LSYMS in a COFF
+   header).  */
+#define HAS_LOCALS  	0x20
+
+/* BFD is a dynamic object.  */
+#define DYNAMIC     	0x40
+
+/* Text section is write protected (if D_PAGED is not set, this is
+   like an a.out NMAGIC file) (the linker sets this by default, but
+   clears it for -r or -N).  */
+#define WP_TEXT     	0x80
+
+/* BFD is dynamically paged (this is like an a.out ZMAGIC file) (the
+   linker sets this by default, but clears it for -r or -n or -N).  */
+#define D_PAGED     	0x100
+
+/* BFD is relaxable (this means that bfd_relax_section may be able to
+   do something) (sometimes bfd_relax_section can do something even if
+   this is not set).  */
+#define BFD_IS_RELAXABLE 0x200
+
+/* This may be set before writing out a BFD to request using a
+   traditional format.  For example, this is used to request that when
+   writing out an a.out object the symbols not be hashed to eliminate
+   duplicates.  */
+#define BFD_TRADITIONAL_FORMAT 0x400
+
+/* This flag indicates that the BFD contents are actually cached in
+   memory.  If this is set, iostream points to a bfd_in_memory struct.  */
+#define BFD_IN_MEMORY 0x800
+
+/* symbols and relocation */
+
+/* A count of carsyms (canonical archive symbols).  */
+typedef unsigned long symindex;
+
+/* How to perform a relocation.  */
+typedef const struct reloc_howto_struct reloc_howto_type;
+
+#define BFD_NO_MORE_SYMBOLS ((symindex) ~0)
+
+/* General purpose part of a symbol X;
+   target specific parts are in libcoff.h, libaout.h, etc.  */
+
+#define bfd_get_section(x) ((x)->section)
+#define bfd_get_output_section(x) ((x)->section->output_section)
+#define bfd_set_section(x,y) ((x)->section) = (y)
+#define bfd_asymbol_base(x) ((x)->section->vma)
+#define bfd_asymbol_value(x) (bfd_asymbol_base(x) + (x)->value)
+#define bfd_asymbol_name(x) ((x)->name)
+/*Perhaps future: #define bfd_asymbol_bfd(x) ((x)->section->owner)*/
+#define bfd_asymbol_bfd(x) ((x)->the_bfd)
+#define bfd_asymbol_flavour(x) (bfd_asymbol_bfd(x)->xvec->flavour)
+
+/* A canonical archive symbol.  */
+/* This is a type pun with struct ranlib on purpose! */
+typedef struct carsym {
+  char *name;
+  file_ptr file_offset;		/* look here to find the file */
+} carsym;			/* to make these you call a carsymogen */
+
+/* Used in generating armaps (archive tables of contents).
+   Perhaps just a forward definition would do? */
+struct orl {			/* output ranlib */
+  char **name;			/* symbol name */
+  file_ptr pos;			/* bfd* or file position */
+  int namidx;			/* index into string table */
+};
+
+/* Linenumber stuff */
+typedef struct lineno_cache_entry {
+  unsigned int line_number;	/* Linenumber from start of function*/
+  union {
+    struct symbol_cache_entry *sym; /* Function name */
+    unsigned long offset;	/* Offset into section */
+  } u;
+} alent;
+
+/* object and core file sections */
+
+#define	align_power(addr, align)	\
+	( ((addr) + ((1<<(align))-1)) & (-1 << (align)))
+
+typedef struct sec *sec_ptr;
+
+#define bfd_get_section_name(bfd, ptr) ((ptr)->name + 0)
+#define bfd_get_section_vma(bfd, ptr) ((ptr)->vma + 0)
+#define bfd_get_section_alignment(bfd, ptr) ((ptr)->alignment_power + 0)
+#define bfd_section_name(bfd, ptr) ((ptr)->name)
+#define bfd_section_size(bfd, ptr) (bfd_get_section_size_before_reloc(ptr))
+#define bfd_section_vma(bfd, ptr) ((ptr)->vma)
+#define bfd_section_lma(bfd, ptr) ((ptr)->lma)
+#define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)
+#define bfd_get_section_flags(bfd, ptr) ((ptr)->flags + 0)
+#define bfd_get_section_userdata(bfd, ptr) ((ptr)->userdata)
+
+#define bfd_is_com_section(ptr) (((ptr)->flags & SEC_IS_COMMON) != 0)
+
+#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma= (val)), ((ptr)->user_set_vma = (boolean)true), true)
+#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),true)
+#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),true)
+
+typedef struct stat stat_type;
+
+typedef enum bfd_print_symbol
+{
+  bfd_print_symbol_name,
+  bfd_print_symbol_more,
+  bfd_print_symbol_all
+} bfd_print_symbol_type;
+
+/* Information about a symbol that nm needs.  */
+
+typedef struct _symbol_info
+{
+  symvalue value;
+  char type;
+  CONST char *name;            /* Symbol name.  */
+  unsigned char stab_type;     /* Stab type.  */
+  char stab_other;             /* Stab other.  */
+  short stab_desc;             /* Stab desc.  */
+  CONST char *stab_name;       /* String for stab type.  */
+} symbol_info;
+
+/* Get the name of a stabs type code.  */
+
+extern const char *bfd_get_stab_name PARAMS ((int));
+
+/* Hash table routines.  There is no way to free up a hash table.  */
+
+/* An element in the hash table.  Most uses will actually use a larger
+   structure, and an instance of this will be the first field.  */
+
+struct bfd_hash_entry
+{
+  /* Next entry for this hash code.  */
+  struct bfd_hash_entry *next;
+  /* String being hashed.  */
+  const char *string;
+  /* Hash code.  This is the full hash code, not the index into the
+     table.  */
+  unsigned long hash;
+};
+
+/* A hash table.  */
+
+struct bfd_hash_table
+{
+  /* The hash array.  */
+  struct bfd_hash_entry **table;
+  /* The number of slots in the hash table.  */
+  unsigned int size;
+  /* A function used to create new elements in the hash table.  The
+     first entry is itself a pointer to an element.  When this
+     function is first invoked, this pointer will be NULL.  However,
+     having the pointer permits a hierarchy of method functions to be
+     built each of which calls the function in the superclass.  Thus
+     each function should be written to allocate a new block of memory
+     only if the argument is NULL.  */
+  struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
+					     struct bfd_hash_table *,
+					     const char *));
+   /* An objalloc for this hash table.  This is a struct objalloc *,
+     but we use PTR to avoid requiring the inclusion of objalloc.h.  */
+  PTR memory;
+};
+
+/* Initialize a hash table.  */
+extern boolean bfd_hash_table_init
+  PARAMS ((struct bfd_hash_table *,
+	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+				       struct bfd_hash_table *,
+				       const char *)));
+
+/* Initialize a hash table specifying a size.  */
+extern boolean bfd_hash_table_init_n
+  PARAMS ((struct bfd_hash_table *,
+	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+				       struct bfd_hash_table *,
+				       const char *),
+	   unsigned int size));
+
+/* Free up a hash table.  */
+extern void bfd_hash_table_free PARAMS ((struct bfd_hash_table *));
+
+/* Look up a string in a hash table.  If CREATE is true, a new entry
+   will be created for this string if one does not already exist.  The
+   COPY argument must be true if this routine should copy the string
+   into newly allocated memory when adding an entry.  */
+extern struct bfd_hash_entry *bfd_hash_lookup
+  PARAMS ((struct bfd_hash_table *, const char *, boolean create,
+	   boolean copy));
+
+/* Replace an entry in a hash table.  */
+extern void bfd_hash_replace
+  PARAMS ((struct bfd_hash_table *, struct bfd_hash_entry *old,
+	   struct bfd_hash_entry *nw));
+
+/* Base method for creating a hash table entry.  */
+extern struct bfd_hash_entry *bfd_hash_newfunc
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
+	   const char *));
+
+/* Grab some space for a hash table entry.  */
+extern PTR bfd_hash_allocate PARAMS ((struct bfd_hash_table *,
+				      unsigned int));
+
+/* Traverse a hash table in a random order, calling a function on each
+   element.  If the function returns false, the traversal stops.  The
+   INFO argument is passed to the function.  */
+extern void bfd_hash_traverse PARAMS ((struct bfd_hash_table *,
+				       boolean (*) (struct bfd_hash_entry *,
+						    PTR),
+				       PTR info));
+
+/* Semi-portable string concatenation in cpp.
+   The CAT4 hack is to avoid a problem with some strict ANSI C preprocessors.
+   The problem is, "32_" is not a valid preprocessing token, and we don't
+   want extra underscores (e.g., "nlm_32_").  The XCAT2 macro will cause the
+   inner CAT macros to be evaluated first, producing still-valid pp-tokens.
+   Then the final concatenation can be done.  (Sigh.)  */
+#ifndef CAT
+#ifdef SABER
+#define CAT(a,b)	a##b
+#define CAT3(a,b,c)	a##b##c
+#define CAT4(a,b,c,d)	a##b##c##d
+#else
+#if defined(__STDC__) || defined(ALMOST_STDC)
+#define CAT(a,b) a##b
+#define CAT3(a,b,c) a##b##c
+#define XCAT2(a,b)	CAT(a,b)
+#define CAT4(a,b,c,d)	XCAT2(CAT(a,b),CAT(c,d))
+#else
+#define CAT(a,b) a/**/b
+#define CAT3(a,b,c) a/**/b/**/c
+#define CAT4(a,b,c,d)	a/**/b/**/c/**/d
+#endif
+#endif
+#endif
+
+#define COFF_SWAP_TABLE (PTR) &bfd_coff_std_swap_table
+
+/* User program access to BFD facilities */
+
+/* Direct I/O routines, for programs which know more about the object
+   file than BFD does.  Use higher level routines if possible.  */
+
+extern bfd_size_type bfd_read
+  PARAMS ((PTR, bfd_size_type size, bfd_size_type nitems, bfd *abfd));
+extern bfd_size_type bfd_write
+  PARAMS ((const PTR, bfd_size_type size, bfd_size_type nitems, bfd *abfd));
+extern int bfd_seek PARAMS ((bfd *abfd, file_ptr fp, int direction));
+extern long bfd_tell PARAMS ((bfd *abfd));
+extern int bfd_flush PARAMS ((bfd *abfd));
+extern int bfd_stat PARAMS ((bfd *abfd, struct stat *));
+
+/* Cast from const char * to char * so that caller can assign to
+   a char * without a warning.  */
+#define bfd_get_filename(abfd) ((char *) (abfd)->filename)
+#define bfd_get_cacheable(abfd) ((abfd)->cacheable)
+#define bfd_get_format(abfd) ((abfd)->format)
+#define bfd_get_target(abfd) ((abfd)->xvec->name)
+#define bfd_get_flavour(abfd) ((abfd)->xvec->flavour)
+#define bfd_family_coff(abfd) \
+  (bfd_get_flavour (abfd) == bfd_target_coff_flavour || \
+   bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
+#define bfd_big_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
+#define bfd_little_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_header_big_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
+#define bfd_header_little_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_get_file_flags(abfd) ((abfd)->flags)
+#define bfd_applicable_file_flags(abfd) ((abfd)->xvec->object_flags)
+#define bfd_applicable_section_flags(abfd) ((abfd)->xvec->section_flags)
+#define bfd_my_archive(abfd) ((abfd)->my_archive)
+#define bfd_has_map(abfd) ((abfd)->has_armap)
+
+#define bfd_valid_reloc_types(abfd) ((abfd)->xvec->valid_reloc_types)
+#define bfd_usrdata(abfd) ((abfd)->usrdata)
+
+#define bfd_get_start_address(abfd) ((abfd)->start_address)
+#define bfd_get_symcount(abfd) ((abfd)->symcount)
+#define bfd_get_outsymbols(abfd) ((abfd)->outsymbols)
+#define bfd_count_sections(abfd) ((abfd)->section_count)
+
+#define bfd_get_symbol_leading_char(abfd) ((abfd)->xvec->symbol_leading_char)
+
+#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = (boolean) (bool)), true)
+
+extern boolean bfd_cache_close PARAMS ((bfd *abfd));
+/* NB: This declaration should match the autogenerated one in libbfd.h.  */
+
+extern boolean bfd_record_phdr
+  PARAMS ((bfd *, unsigned long, boolean, flagword, boolean, bfd_vma,
+	   boolean, boolean, unsigned int, struct sec **));
+
+/* Byte swapping routines.  */
+
+bfd_vma		bfd_getb64	   PARAMS ((const unsigned char *));
+#if 0	/* CONFIG_KDB */
+bfd_vma 	bfd_getl64	   PARAMS ((const unsigned char *));
+#endif	/* CONFIG_KDB */
+bfd_signed_vma	bfd_getb_signed_64 PARAMS ((const unsigned char *));
+bfd_signed_vma	bfd_getl_signed_64 PARAMS ((const unsigned char *));
+bfd_vma		bfd_getb32	   PARAMS ((const unsigned char *));
+bfd_vma		bfd_getl32	   PARAMS ((const unsigned char *));
+bfd_signed_vma	bfd_getb_signed_32 PARAMS ((const unsigned char *));
+bfd_signed_vma	bfd_getl_signed_32 PARAMS ((const unsigned char *));
+bfd_vma		bfd_getb16	   PARAMS ((const unsigned char *));
+bfd_vma		bfd_getl16	   PARAMS ((const unsigned char *));
+bfd_signed_vma	bfd_getb_signed_16 PARAMS ((const unsigned char *));
+bfd_signed_vma	bfd_getl_signed_16 PARAMS ((const unsigned char *));
+void		bfd_putb64	   PARAMS ((bfd_vma, unsigned char *));
+void		bfd_putl64	   PARAMS ((bfd_vma, unsigned char *));
+void		bfd_putb32	   PARAMS ((bfd_vma, unsigned char *));
+void		bfd_putl32	   PARAMS ((bfd_vma, unsigned char *));
+void		bfd_putb16	   PARAMS ((bfd_vma, unsigned char *));
+void		bfd_putl16	   PARAMS ((bfd_vma, unsigned char *));
+
+/* Byte swapping routines which take size and endiannes as arguments.  */
+
+bfd_vma         bfd_get_bits       PARAMS ((bfd_byte *, int, boolean));
+void            bfd_put_bits       PARAMS ((bfd_vma, bfd_byte *, int, boolean));
+
+/* Externally visible ECOFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct ecoff_debug_info;
+struct ecoff_debug_swap;
+struct ecoff_extr;
+struct symbol_cache_entry;
+struct bfd_link_info;
+struct bfd_link_hash_entry;
+struct bfd_elf_version_tree;
+#endif
+extern bfd_vma bfd_ecoff_get_gp_value PARAMS ((bfd * abfd));
+extern boolean bfd_ecoff_set_gp_value PARAMS ((bfd *abfd, bfd_vma gp_value));
+extern boolean bfd_ecoff_set_regmasks
+  PARAMS ((bfd *abfd, unsigned long gprmask, unsigned long fprmask,
+	   unsigned long *cprmask));
+extern PTR bfd_ecoff_debug_init
+  PARAMS ((bfd *output_bfd, struct ecoff_debug_info *output_debug,
+	   const struct ecoff_debug_swap *output_swap,
+	   struct bfd_link_info *));
+extern void bfd_ecoff_debug_free
+  PARAMS ((PTR handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+	   const struct ecoff_debug_swap *output_swap,
+	   struct bfd_link_info *));
+extern boolean bfd_ecoff_debug_accumulate
+  PARAMS ((PTR handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+	   const struct ecoff_debug_swap *output_swap,
+	   bfd *input_bfd, struct ecoff_debug_info *input_debug,
+	   const struct ecoff_debug_swap *input_swap,
+	   struct bfd_link_info *));
+extern boolean bfd_ecoff_debug_accumulate_other
+  PARAMS ((PTR handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+	   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
+	   struct bfd_link_info *));
+extern boolean bfd_ecoff_debug_externals
+  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
+	   const struct ecoff_debug_swap *swap,
+	   boolean relocateable,
+	   boolean (*get_extr) (struct symbol_cache_entry *,
+				struct ecoff_extr *),
+	   void (*set_index) (struct symbol_cache_entry *,
+			      bfd_size_type)));
+extern boolean bfd_ecoff_debug_one_external
+  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
+	   const struct ecoff_debug_swap *swap,
+	   const char *name, struct ecoff_extr *esym));
+extern bfd_size_type bfd_ecoff_debug_size
+  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
+	   const struct ecoff_debug_swap *swap));
+extern boolean bfd_ecoff_write_debug
+  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
+	   const struct ecoff_debug_swap *swap, file_ptr where));
+extern boolean bfd_ecoff_write_accumulated_debug
+  PARAMS ((PTR handle, bfd *abfd, struct ecoff_debug_info *debug,
+	   const struct ecoff_debug_swap *swap,
+	   struct bfd_link_info *info, file_ptr where));
+extern boolean bfd_mips_ecoff_create_embedded_relocs
+  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
+	   char **));
+
+/* Externally visible ELF routines.  */
+
+struct bfd_link_needed_list
+{
+  struct bfd_link_needed_list *next;
+  bfd *by;
+  const char *name;
+};
+
+extern boolean bfd_elf32_record_link_assignment
+  PARAMS ((bfd *, struct bfd_link_info *, const char *, boolean));
+extern boolean bfd_elf64_record_link_assignment
+  PARAMS ((bfd *, struct bfd_link_info *, const char *, boolean));
+extern struct bfd_link_needed_list *bfd_elf_get_needed_list
+  PARAMS ((bfd *, struct bfd_link_info *));
+extern boolean bfd_elf_get_bfd_needed_list
+  PARAMS ((bfd *, struct bfd_link_needed_list **));
+extern boolean bfd_elf32_size_dynamic_sections
+  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
+	   const char * const *, struct bfd_link_info *, struct sec **,
+	   struct bfd_elf_version_tree *));
+extern boolean bfd_elf64_size_dynamic_sections
+  PARAMS ((bfd *, const char *, const char *, boolean, const char *,
+	   const char * const *, struct bfd_link_info *, struct sec **,
+	   struct bfd_elf_version_tree *));
+extern void bfd_elf_set_dt_needed_name PARAMS ((bfd *, const char *));
+extern void bfd_elf_set_dt_needed_soname PARAMS ((bfd *, const char *));
+extern const char *bfd_elf_get_dt_soname PARAMS ((bfd *));
+extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+/* Return an upper bound on the number of bytes required to store a
+   copy of ABFD's program header table entries.  Return -1 if an error
+   occurs; bfd_get_error will return an appropriate code.  */
+extern long bfd_get_elf_phdr_upper_bound PARAMS ((bfd *abfd));
+
+/* Copy ABFD's program header table entries to *PHDRS.  The entries
+   will be stored as an array of Elf_Internal_Phdr structures, as
+   defined in include/elf/internal.h.  To find out how large the
+   buffer needs to be, call bfd_get_elf_phdr_upper_bound.
+
+   Return the number of program header table entries read, or -1 if an
+   error occurs; bfd_get_error will return an appropriate code.  */
+extern int bfd_get_elf_phdrs PARAMS ((bfd *abfd, void *phdrs));
+
+/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
+extern int bfd_get_arch_size PARAMS ((bfd *));
+
+/* Return true if address "naturally" sign extends, or -1 if not elf.  */
+extern int bfd_get_sign_extend_vma PARAMS ((bfd *));
+
+extern boolean bfd_m68k_elf32_create_embedded_relocs
+  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
+	   char **));
+
+/* SunOS shared library support routines for the linker.  */
+
+extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
+  PARAMS ((bfd *, struct bfd_link_info *));
+extern boolean bfd_sunos_record_link_assignment
+  PARAMS ((bfd *, struct bfd_link_info *, const char *));
+extern boolean bfd_sunos_size_dynamic_sections
+  PARAMS ((bfd *, struct bfd_link_info *, struct sec **, struct sec **,
+	   struct sec **));
+
+/* Linux shared library support routines for the linker.  */
+
+extern boolean bfd_i386linux_size_dynamic_sections
+  PARAMS ((bfd *, struct bfd_link_info *));
+extern boolean bfd_m68klinux_size_dynamic_sections
+  PARAMS ((bfd *, struct bfd_link_info *));
+extern boolean bfd_sparclinux_size_dynamic_sections
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+/* mmap hacks */
+
+struct _bfd_window_internal;
+typedef struct _bfd_window_internal bfd_window_internal;
+
+typedef struct _bfd_window {
+  /* What the user asked for.  */
+  PTR data;
+  bfd_size_type size;
+  /* The actual window used by BFD.  Small user-requested read-only
+     regions sharing a page may share a single window into the object
+     file.  Read-write versions shouldn't until I've fixed things to
+     keep track of which portions have been claimed by the
+     application; don't want to give the same region back when the
+     application wants two writable copies!  */
+  struct _bfd_window_internal *i;
+} bfd_window;
+
+extern void bfd_init_window PARAMS ((bfd_window *));
+extern void bfd_free_window PARAMS ((bfd_window *));
+extern boolean bfd_get_file_window
+  PARAMS ((bfd *, file_ptr, bfd_size_type, bfd_window *, boolean));
+
+/* XCOFF support routines for the linker.  */
+
+extern boolean bfd_xcoff_link_record_set
+  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *,
+	   bfd_size_type));
+extern boolean bfd_xcoff_import_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *,
+	   bfd_vma, const char *, const char *, const char *));
+extern boolean bfd_xcoff_export_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *,
+	   boolean));
+extern boolean bfd_xcoff_link_count_reloc
+  PARAMS ((bfd *, struct bfd_link_info *, const char *));
+extern boolean bfd_xcoff_record_link_assignment
+  PARAMS ((bfd *, struct bfd_link_info *, const char *));
+extern boolean bfd_xcoff_size_dynamic_sections
+  PARAMS ((bfd *, struct bfd_link_info *, const char *, const char *,
+	   unsigned long, unsigned long, unsigned long, boolean,
+	   int, boolean, boolean, struct sec **));
+
+/* Externally visible COFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct internal_syment;
+union internal_auxent;
+#endif
+
+extern boolean bfd_coff_get_syment
+  PARAMS ((bfd *, struct symbol_cache_entry *, struct internal_syment *));
+
+extern boolean bfd_coff_get_auxent
+  PARAMS ((bfd *, struct symbol_cache_entry *, int, union internal_auxent *));
+
+extern boolean bfd_coff_set_symbol_class
+  PARAMS ((bfd *, struct symbol_cache_entry *, unsigned int));
+
+extern boolean bfd_m68k_coff_create_embedded_relocs
+  PARAMS ((bfd *, struct bfd_link_info *, struct sec *, struct sec *,
+	   char **));
+
+/* ARM Interworking support.  Called from linker.  */
+extern boolean bfd_arm_allocate_interworking_sections
+  PARAMS ((struct bfd_link_info *));
+
+extern boolean bfd_arm_process_before_allocation
+  PARAMS ((bfd *, struct bfd_link_info *, int));
+
+extern boolean bfd_arm_get_bfd_for_interworking
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+/* PE ARM Interworking support.  Called from linker.  */
+extern boolean bfd_arm_pe_allocate_interworking_sections
+  PARAMS ((struct bfd_link_info *));
+
+extern boolean bfd_arm_pe_process_before_allocation
+  PARAMS ((bfd *, struct bfd_link_info *, int));
+
+extern boolean bfd_arm_pe_get_bfd_for_interworking
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+/* ELF ARM Interworking support.  Called from linker.  */
+extern boolean bfd_elf32_arm_allocate_interworking_sections
+  PARAMS ((struct bfd_link_info *));
+
+extern boolean bfd_elf32_arm_process_before_allocation
+  PARAMS ((bfd *, struct bfd_link_info *, int));
+
+extern boolean bfd_elf32_arm_get_bfd_for_interworking
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+/* TI COFF load page support.  */
+extern void bfd_ticoff_set_section_load_page
+  PARAMS ((struct sec *, int));
+
+extern int bfd_ticoff_get_section_load_page
+  PARAMS ((struct sec *));
+
+/* And more from the source.  */
+void
+bfd_init PARAMS ((void));
+
+bfd *
+bfd_openr PARAMS ((CONST char *filename, CONST char *target));
+
+bfd *
+bfd_fdopenr PARAMS ((CONST char *filename, CONST char *target, int fd));
+
+bfd *
+bfd_openstreamr PARAMS ((const char *, const char *, PTR));
+
+bfd *
+bfd_openw PARAMS ((CONST char *filename, CONST char *target));
+
+boolean
+bfd_close PARAMS ((bfd *abfd));
+
+boolean
+bfd_close_all_done PARAMS ((bfd *));
+
+bfd *
+bfd_create PARAMS ((CONST char *filename, bfd *templ));
+
+boolean
+bfd_make_writable PARAMS ((bfd *abfd));
+
+boolean
+bfd_make_readable PARAMS ((bfd *abfd));
+
+
+/* Byte swapping macros for user section data.  */
+
+#define bfd_put_8(abfd, val, ptr) \
+                ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
+#define bfd_put_signed_8 \
+               bfd_put_8
+#define bfd_get_8(abfd, ptr) \
+                (*(unsigned char *) (ptr))
+#define bfd_get_signed_8(abfd, ptr) \
+               ((*(unsigned char *) (ptr) ^ 0x80) - 0x80)
+
+#define bfd_put_16(abfd, val, ptr) \
+                BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
+#define bfd_put_signed_16 \
+                bfd_put_16
+#define bfd_get_16(abfd, ptr) \
+                BFD_SEND(abfd, bfd_getx16, (ptr))
+#define bfd_get_signed_16(abfd, ptr) \
+                BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
+
+#define bfd_put_32(abfd, val, ptr) \
+                BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
+#define bfd_put_signed_32 \
+                bfd_put_32
+#define bfd_get_32(abfd, ptr) \
+                BFD_SEND(abfd, bfd_getx32, (ptr))
+#define bfd_get_signed_32(abfd, ptr) \
+                BFD_SEND(abfd, bfd_getx_signed_32, (ptr))
+
+#define bfd_put_64(abfd, val, ptr) \
+                BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
+#define bfd_put_signed_64 \
+                bfd_put_64
+#define bfd_get_64(abfd, ptr) \
+                BFD_SEND(abfd, bfd_getx64, (ptr))
+#define bfd_get_signed_64(abfd, ptr) \
+                BFD_SEND(abfd, bfd_getx_signed_64, (ptr))
+
+#define bfd_get(bits, abfd, ptr)                               \
+                ((bits) == 8 ? bfd_get_8 (abfd, ptr)           \
+                : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
+                : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
+                : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
+                : (abort (), (bfd_vma) - 1))
+
+#define bfd_put(bits, abfd, val, ptr)                          \
+                ((bits) == 8 ? bfd_put_8 (abfd, val, ptr)      \
+                : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
+                : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
+                : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
+                : (abort (), (void) 0))
+
+
+/* Byte swapping macros for file header data.  */
+
+#define bfd_h_put_8(abfd, val, ptr) \
+               bfd_put_8 (abfd, val, ptr)
+#define bfd_h_put_signed_8(abfd, val, ptr) \
+               bfd_put_8 (abfd, val, ptr)
+#define bfd_h_get_8(abfd, ptr) \
+               bfd_get_8 (abfd, ptr)
+#define bfd_h_get_signed_8(abfd, ptr) \
+               bfd_get_signed_8 (abfd, ptr)
+
+#define bfd_h_put_16(abfd, val, ptr) \
+                BFD_SEND(abfd, bfd_h_putx16,(val,ptr))
+#define bfd_h_put_signed_16 \
+                bfd_h_put_16
+#define bfd_h_get_16(abfd, ptr) \
+                BFD_SEND(abfd, bfd_h_getx16,(ptr))
+#define bfd_h_get_signed_16(abfd, ptr) \
+                BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr))
+
+#define bfd_h_put_32(abfd, val, ptr) \
+                BFD_SEND(abfd, bfd_h_putx32,(val,ptr))
+#define bfd_h_put_signed_32 \
+                bfd_h_put_32
+#define bfd_h_get_32(abfd, ptr) \
+                BFD_SEND(abfd, bfd_h_getx32,(ptr))
+#define bfd_h_get_signed_32(abfd, ptr) \
+                BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr))
+
+#define bfd_h_put_64(abfd, val, ptr) \
+                BFD_SEND(abfd, bfd_h_putx64,(val, ptr))
+#define bfd_h_put_signed_64 \
+                bfd_h_put_64
+#define bfd_h_get_64(abfd, ptr) \
+                BFD_SEND(abfd, bfd_h_getx64,(ptr))
+#define bfd_h_get_signed_64(abfd, ptr) \
+                BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr))
+
+/* This structure is used for a comdat section, as in PE.  A comdat
+   section is associated with a particular symbol.  When the linker
+   sees a comdat section, it keeps only one of the sections with a
+   given name and associated with a given symbol.  */
+
+struct bfd_comdat_info
+{
+  /* The name of the symbol associated with a comdat section.  */
+  const char *name;
+
+  /* The local symbol table index of the symbol associated with a
+     comdat section.  This is only meaningful to the object file format
+     specific code; it is not an index into the list returned by
+     bfd_canonicalize_symtab.  */
+  long symbol;
+};
+
+typedef struct sec
+{
+  /* The name of the section; the name isn't a copy, the pointer is
+     the same as that passed to bfd_make_section.  */
+
+  const char *name;
+
+  /* A unique sequence number.  */
+
+  int id;
+
+  /* Which section is it; 0..nth.  */
+
+  int index;
+
+  /* The next section in the list belonging to the BFD, or NULL.  */
+
+  struct sec *next;
+
+  /* The field flags contains attributes of the section. Some
+     flags are read in from the object file, and some are
+     synthesized from other information.  */
+
+  flagword flags;
+
+#define SEC_NO_FLAGS   0x000
+
+  /* Tells the OS to allocate space for this section when loading.
+     This is clear for a section containing debug information only.  */
+#define SEC_ALLOC      0x001
+
+  /* Tells the OS to load the section from the file when loading.
+     This is clear for a .bss section.  */
+#define SEC_LOAD       0x002
+
+  /* The section contains data still to be relocated, so there is
+     some relocation information too.  */
+#define SEC_RELOC      0x004
+
+#if 0   /* Obsolete ? */
+#define SEC_BALIGN     0x008
+#endif
+
+  /* A signal to the OS that the section contains read only data.  */
+#define SEC_READONLY   0x010
+
+  /* The section contains code only.  */
+#define SEC_CODE       0x020
+
+  /* The section contains data only.  */
+#define SEC_DATA       0x040
+
+  /* The section will reside in ROM.  */
+#define SEC_ROM        0x080
+
+  /* The section contains constructor information. This section
+     type is used by the linker to create lists of constructors and
+     destructors used by <<g++>>. When a back end sees a symbol
+     which should be used in a constructor list, it creates a new
+     section for the type of name (e.g., <<__CTOR_LIST__>>), attaches
+     the symbol to it, and builds a relocation. To build the lists
+     of constructors, all the linker has to do is catenate all the
+     sections called <<__CTOR_LIST__>> and relocate the data
+     contained within - exactly the operations it would peform on
+     standard data.  */
+#define SEC_CONSTRUCTOR 0x100
+
+  /* The section is a constructor, and should be placed at the
+     end of the text, data, or bss section(?).  */
+#define SEC_CONSTRUCTOR_TEXT 0x1100
+#define SEC_CONSTRUCTOR_DATA 0x2100
+#define SEC_CONSTRUCTOR_BSS  0x3100
+
+  /* The section has contents - a data section could be
+     <<SEC_ALLOC>> | <<SEC_HAS_CONTENTS>>; a debug section could be
+     <<SEC_HAS_CONTENTS>>  */
+#define SEC_HAS_CONTENTS 0x200
+
+  /* An instruction to the linker to not output the section
+     even if it has information which would normally be written.  */
+#define SEC_NEVER_LOAD 0x400
+
+  /* The section is a COFF shared library section.  This flag is
+     only for the linker.  If this type of section appears in
+     the input file, the linker must copy it to the output file
+     without changing the vma or size.  FIXME: Although this
+     was originally intended to be general, it really is COFF
+     specific (and the flag was renamed to indicate this).  It
+     might be cleaner to have some more general mechanism to
+     allow the back end to control what the linker does with
+     sections.  */
+#define SEC_COFF_SHARED_LIBRARY 0x800
+
+  /* The section has GOT references.  This flag is only for the
+     linker, and is currently only used by the elf32-hppa back end.
+     It will be set if global offset table references were detected
+     in this section, which indicate to the linker that the section
+     contains PIC code, and must be handled specially when doing a
+     static link.  */
+#define SEC_HAS_GOT_REF 0x4000
+
+  /* The section contains common symbols (symbols may be defined
+     multiple times, the value of a symbol is the amount of
+     space it requires, and the largest symbol value is the one
+     used).  Most targets have exactly one of these (which we
+     translate to bfd_com_section_ptr), but ECOFF has two.  */
+#define SEC_IS_COMMON 0x8000
+
+  /* The section contains only debugging information.  For
+     example, this is set for ELF .debug and .stab sections.
+     strip tests this flag to see if a section can be
+     discarded.  */
+#define SEC_DEBUGGING 0x10000
+
+  /* The contents of this section are held in memory pointed to
+     by the contents field.  This is checked by bfd_get_section_contents,
+     and the data is retrieved from memory if appropriate.  */
+#define SEC_IN_MEMORY 0x20000
+
+  /* The contents of this section are to be excluded by the
+     linker for executable and shared objects unless those
+     objects are to be further relocated.  */
+#define SEC_EXCLUDE 0x40000
+
+  /* The contents of this section are to be sorted by the
+     based on the address specified in the associated symbol
+     table.  */
+#define SEC_SORT_ENTRIES 0x80000
+
+  /* When linking, duplicate sections of the same name should be
+     discarded, rather than being combined into a single section as
+     is usually done.  This is similar to how common symbols are
+     handled.  See SEC_LINK_DUPLICATES below.  */
+#define SEC_LINK_ONCE 0x100000
+
+  /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
+     should handle duplicate sections.  */
+#define SEC_LINK_DUPLICATES 0x600000
+
+  /* This value for SEC_LINK_DUPLICATES means that duplicate
+     sections with the same name should simply be discarded.  */
+#define SEC_LINK_DUPLICATES_DISCARD 0x0
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if there are any duplicate sections, although
+     it should still only link one copy.  */
+#define SEC_LINK_DUPLICATES_ONE_ONLY 0x200000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections are a different size.  */
+#define SEC_LINK_DUPLICATES_SAME_SIZE 0x400000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections contain different
+     contents.  */
+#define SEC_LINK_DUPLICATES_SAME_CONTENTS 0x600000
+
+  /* This section was created by the linker as part of dynamic
+     relocation or other arcane processing.  It is skipped when
+     going through the first-pass output, trusting that someone
+     else up the line will take care of it later.  */
+#define SEC_LINKER_CREATED 0x800000
+
+  /* This section should not be subject to garbage collection.  */
+#define SEC_KEEP 0x1000000
+
+  /* This section contains "short" data, and should be placed
+     "near" the GP.  */
+#define SEC_SMALL_DATA 0x2000000
+
+  /* This section contains data which may be shared with other
+     executables or shared objects.  */
+#define SEC_SHARED 0x4000000
+
+  /* When a section with this flag is being linked, then if the size of
+     the input section is less than a page, it should not cross a page
+     boundary.  If the size of the input section is one page or more, it
+     should be aligned on a page boundary.  */
+#define SEC_BLOCK 0x8000000
+
+  /* Conditionally link this section; do not link if there are no
+     references found to any symbol in the section.  */
+#define SEC_CLINK 0x10000000
+
+  /* Attempt to merge identical entities in the section.
+     Entity size is given in the entsize field.  */
+#define SEC_MERGE 0x20000000
+
+  /* If given with SEC_MERGE, entities to merge are zero terminated
+     strings where entsize specifies character size instead of fixed
+     size entries.  */
+#define SEC_STRINGS 0x40000000
+
+  /*  End of section flags.  */
+
+  /* Some internal packed boolean fields.  */
+
+  /* See the vma field.  */
+  unsigned int user_set_vma : 1;
+
+  /* Whether relocations have been processed.  */
+  unsigned int reloc_done : 1;
+
+  /* A mark flag used by some of the linker backends.  */
+  unsigned int linker_mark : 1;
+
+  /* A mark flag used by some linker backends for garbage collection.  */
+  unsigned int gc_mark : 1;
+
+  /* Used by the ELF code to mark sections which have been allocated to segments.  */
+  unsigned int segment_mark : 1;
+
+  /* End of internal packed boolean fields.  */
+
+  /*  The virtual memory address of the section - where it will be
+      at run time.  The symbols are relocated against this.  The
+      user_set_vma flag is maintained by bfd; if it's not set, the
+      backend can assign addresses (for example, in <<a.out>>, where
+      the default address for <<.data>> is dependent on the specific
+      target and various flags).  */
+
+  bfd_vma vma;
+
+  /*  The load address of the section - where it would be in a
+      rom image; really only used for writing section header
+      information. */
+
+  bfd_vma lma;
+
+  /* The size of the section in octets, as it will be output.
+     Contains a value even if the section has no contents (e.g., the
+     size of <<.bss>>).  This will be filled in after relocation.  */
+
+  bfd_size_type _cooked_size;
+
+  /* The original size on disk of the section, in octets.  Normally this
+     value is the same as the size, but if some relaxing has
+     been done, then this value will be bigger.  */
+
+  bfd_size_type _raw_size;
+
+  /* If this section is going to be output, then this value is the
+     offset in *bytes* into the output section of the first byte in the
+     input section (byte ==> smallest addressable unit on the
+     target).  In most cases, if this was going to start at the
+     100th octet (8-bit quantity) in the output section, this value
+     would be 100.  However, if the target byte size is 16 bits
+     (bfd_octets_per_byte is "2"), this value would be 50.  */
+
+  bfd_vma output_offset;
+
+  /* The output section through which to map on output.  */
+
+  struct sec *output_section;
+
+  /* The alignment requirement of the section, as an exponent of 2 -
+     e.g., 3 aligns to 2^3 (or 8).  */
+
+  unsigned int alignment_power;
+
+  /* If an input section, a pointer to a vector of relocation
+     records for the data in this section.  */
+
+  struct reloc_cache_entry *relocation;
+
+  /* If an output section, a pointer to a vector of pointers to
+     relocation records for the data in this section.  */
+
+  struct reloc_cache_entry **orelocation;
+
+  /* The number of relocation records in one of the above  */
+
+  unsigned reloc_count;
+
+  /* Information below is back end specific - and not always used
+     or updated.  */
+
+  /* File position of section data.  */
+
+  file_ptr filepos;
+
+  /* File position of relocation info.  */
+
+  file_ptr rel_filepos;
+
+  /* File position of line data.  */
+
+  file_ptr line_filepos;
+
+  /* Pointer to data for applications.  */
+
+  PTR userdata;
+
+  /* If the SEC_IN_MEMORY flag is set, this points to the actual
+     contents.  */
+  unsigned char *contents;
+
+  /* Attached line number information.  */
+
+  alent *lineno;
+
+  /* Number of line number records.  */
+
+  unsigned int lineno_count;
+
+  /* Entity size for merging purposes.  */
+
+  unsigned int entsize;
+
+  /* Optional information about a COMDAT entry; NULL if not COMDAT.  */
+
+  struct bfd_comdat_info *comdat;
+
+  /* Points to the kept section if this section is a link-once section,
+     and is discarded.  */
+  struct sec *kept_section;
+
+  /* When a section is being output, this value changes as more
+     linenumbers are written out.  */
+
+  file_ptr moving_line_filepos;
+
+  /* What the section number is in the target world.  */
+
+  int target_index;
+
+  PTR used_by_bfd;
+
+  /* If this is a constructor section then here is a list of the
+     relocations created to relocate items within it.  */
+
+  struct relent_chain *constructor_chain;
+
+  /* The BFD which owns the section.  */
+
+  bfd *owner;
+
+  /* A symbol which points at this section only */
+  struct symbol_cache_entry *symbol;
+  struct symbol_cache_entry **symbol_ptr_ptr;
+
+  struct bfd_link_order *link_order_head;
+  struct bfd_link_order *link_order_tail;
+} asection ;
+
+/* These sections are global, and are managed by BFD.  The application
+   and target back end are not permitted to change the values in
+   these sections.  New code should use the section_ptr macros rather
+   than referring directly to the const sections.  The const sections
+   may eventually vanish.  */
+#define BFD_ABS_SECTION_NAME "*ABS*"
+#define BFD_UND_SECTION_NAME "*UND*"
+#define BFD_COM_SECTION_NAME "*COM*"
+#define BFD_IND_SECTION_NAME "*IND*"
+
+/* the absolute section */
+extern const asection bfd_abs_section;
+#define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
+#define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
+/* Pointer to the undefined section */
+extern const asection bfd_und_section;
+#define bfd_und_section_ptr ((asection *) &bfd_und_section)
+#define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
+/* Pointer to the common section */
+extern const asection bfd_com_section;
+#define bfd_com_section_ptr ((asection *) &bfd_com_section)
+/* Pointer to the indirect section */
+extern const asection bfd_ind_section;
+#define bfd_ind_section_ptr ((asection *) &bfd_ind_section)
+#define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)
+
+extern const struct symbol_cache_entry * const bfd_abs_symbol;
+extern const struct symbol_cache_entry * const bfd_com_symbol;
+extern const struct symbol_cache_entry * const bfd_und_symbol;
+extern const struct symbol_cache_entry * const bfd_ind_symbol;
+#define bfd_get_section_size_before_reloc(section) \
+     ((section)->reloc_done ? (abort (), (bfd_size_type) 1) \
+                            : (section)->_raw_size)
+#define bfd_get_section_size_after_reloc(section) \
+     ((section)->reloc_done ? (section)->_cooked_size \
+                            : (abort (), (bfd_size_type) 1))
+asection *
+bfd_get_section_by_name PARAMS ((bfd *abfd, const char *name));
+
+char *
+bfd_get_unique_section_name PARAMS ((bfd *abfd,
+    const char *templat,
+    int *count));
+
+asection *
+bfd_make_section_old_way PARAMS ((bfd *abfd, const char *name));
+
+asection *
+bfd_make_section_anyway PARAMS ((bfd *abfd, const char *name));
+
+asection *
+bfd_make_section PARAMS ((bfd *, const char *name));
+
+boolean
+bfd_set_section_flags PARAMS ((bfd *abfd, asection *sec, flagword flags));
+
+void
+bfd_map_over_sections PARAMS ((bfd *abfd,
+    void (*func) (bfd *abfd,
+    asection *sect,
+    PTR obj),
+    PTR obj));
+
+boolean
+bfd_set_section_size PARAMS ((bfd *abfd, asection *sec, bfd_size_type val));
+
+boolean
+bfd_set_section_contents PARAMS ((bfd *abfd,
+    asection *section,
+    PTR data,
+    file_ptr offset,
+    bfd_size_type count));
+
+boolean
+bfd_get_section_contents PARAMS ((bfd *abfd, asection *section, PTR location,
+    file_ptr offset, bfd_size_type count));
+
+boolean
+bfd_copy_private_section_data PARAMS ((bfd *ibfd, asection *isec, bfd *obfd, asection *osec));
+
+#define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
+     BFD_SEND (obfd, _bfd_copy_private_section_data, \
+               (ibfd, isection, obfd, osection))
+void
+_bfd_strip_section_from_output PARAMS ((struct bfd_link_info *info, asection *section));
+
+enum bfd_architecture
+{
+  bfd_arch_unknown,   /* File arch not known */
+  bfd_arch_obscure,   /* Arch known, not one of these */
+  bfd_arch_m68k,      /* Motorola 68xxx */
+#define bfd_mach_m68000 1
+#define bfd_mach_m68008 2
+#define bfd_mach_m68010 3
+#define bfd_mach_m68020 4
+#define bfd_mach_m68030 5
+#define bfd_mach_m68040 6
+#define bfd_mach_m68060 7
+#define bfd_mach_cpu32  8
+#define bfd_mach_mcf5200  9
+#define bfd_mach_mcf5206e 10
+#define bfd_mach_mcf5307  11
+#define bfd_mach_mcf5407  12
+  bfd_arch_vax,       /* DEC Vax */
+  bfd_arch_i960,      /* Intel 960 */
+    /* The order of the following is important.
+       lower number indicates a machine type that
+       only accepts a subset of the instructions
+       available to machines with higher numbers.
+       The exception is the "ca", which is
+       incompatible with all other machines except
+       "core". */
+
+#define bfd_mach_i960_core      1
+#define bfd_mach_i960_ka_sa     2
+#define bfd_mach_i960_kb_sb     3
+#define bfd_mach_i960_mc        4
+#define bfd_mach_i960_xa        5
+#define bfd_mach_i960_ca        6
+#define bfd_mach_i960_jx        7
+#define bfd_mach_i960_hx        8
+
+  bfd_arch_a29k,      /* AMD 29000 */
+  bfd_arch_sparc,     /* SPARC */
+#define bfd_mach_sparc                 1
+/* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
+#define bfd_mach_sparc_sparclet        2
+#define bfd_mach_sparc_sparclite       3
+#define bfd_mach_sparc_v8plus          4
+#define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns */
+#define bfd_mach_sparc_sparclite_le    6
+#define bfd_mach_sparc_v9              7
+#define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns */
+#define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns */
+#define bfd_mach_sparc_v9b             10 /* with cheetah add'ns */
+/* Nonzero if MACH has the v9 instruction set.  */
+#define bfd_mach_sparc_v9_p(mach) \
+  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
+   && (mach) != bfd_mach_sparc_sparclite_le)
+  bfd_arch_mips,      /* MIPS Rxxxx */
+#define bfd_mach_mips3000              3000
+#define bfd_mach_mips3900              3900
+#define bfd_mach_mips4000              4000
+#define bfd_mach_mips4010              4010
+#define bfd_mach_mips4100              4100
+#define bfd_mach_mips4111              4111
+#define bfd_mach_mips4300              4300
+#define bfd_mach_mips4400              4400
+#define bfd_mach_mips4600              4600
+#define bfd_mach_mips4650              4650
+#define bfd_mach_mips5000              5000
+#define bfd_mach_mips6000              6000
+#define bfd_mach_mips8000              8000
+#define bfd_mach_mips10000             10000
+#define bfd_mach_mips16                16
+#define bfd_mach_mips32                32
+#define bfd_mach_mips32_4k             3204113 /* 32, 04, octal 'K' */
+#define bfd_mach_mips5                 5
+#define bfd_mach_mips64                64
+#define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
+  bfd_arch_i386,      /* Intel 386 */
+#define bfd_mach_i386_i386 0
+#define bfd_mach_i386_i8086 1
+#define bfd_mach_i386_i386_intel_syntax 2
+#define bfd_mach_x86_64 3
+#define bfd_mach_x86_64_intel_syntax 4
+  bfd_arch_we32k,     /* AT&T WE32xxx */
+  bfd_arch_tahoe,     /* CCI/Harris Tahoe */
+  bfd_arch_i860,      /* Intel 860 */
+  bfd_arch_i370,      /* IBM 360/370 Mainframes */
+  bfd_arch_romp,      /* IBM ROMP PC/RT */
+  bfd_arch_alliant,   /* Alliant */
+  bfd_arch_convex,    /* Convex */
+  bfd_arch_m88k,      /* Motorola 88xxx */
+  bfd_arch_pyramid,   /* Pyramid Technology */
+  bfd_arch_h8300,     /* Hitachi H8/300 */
+#define bfd_mach_h8300   1
+#define bfd_mach_h8300h  2
+#define bfd_mach_h8300s  3
+  bfd_arch_pdp11,     /* DEC PDP-11 */
+  bfd_arch_powerpc,   /* PowerPC */
+#define bfd_mach_ppc           0
+#define bfd_mach_ppc_403       403
+#define bfd_mach_ppc_403gc     4030
+#define bfd_mach_ppc_505       505
+#define bfd_mach_ppc_601       601
+#define bfd_mach_ppc_602       602
+#define bfd_mach_ppc_603       603
+#define bfd_mach_ppc_ec603e    6031
+#define bfd_mach_ppc_604       604
+#define bfd_mach_ppc_620       620
+#define bfd_mach_ppc_630       630
+#define bfd_mach_ppc_750       750
+#define bfd_mach_ppc_860       860
+#define bfd_mach_ppc_a35       35
+#define bfd_mach_ppc_rs64ii    642
+#define bfd_mach_ppc_rs64iii   643
+#define bfd_mach_ppc_7400      7400
+  bfd_arch_rs6000,    /* IBM RS/6000 */
+#define bfd_mach_rs6k          0
+#define bfd_mach_rs6k_rs1      6001
+#define bfd_mach_rs6k_rsc      6003
+#define bfd_mach_rs6k_rs2      6002
+  bfd_arch_hppa,      /* HP PA RISC */
+  bfd_arch_d10v,      /* Mitsubishi D10V */
+#define bfd_mach_d10v          0
+#define bfd_mach_d10v_ts2      2
+#define bfd_mach_d10v_ts3      3
+  bfd_arch_d30v,      /* Mitsubishi D30V */
+  bfd_arch_m68hc11,   /* Motorola 68HC11 */
+  bfd_arch_m68hc12,   /* Motorola 68HC12 */
+  bfd_arch_z8k,       /* Zilog Z8000 */
+#define bfd_mach_z8001         1
+#define bfd_mach_z8002         2
+  bfd_arch_h8500,     /* Hitachi H8/500 */
+  bfd_arch_sh,        /* Hitachi SH */
+#define bfd_mach_sh            0
+#define bfd_mach_sh2        0x20
+#define bfd_mach_sh_dsp     0x2d
+#define bfd_mach_sh3        0x30
+#define bfd_mach_sh3_dsp    0x3d
+#define bfd_mach_sh3e       0x3e
+#define bfd_mach_sh4        0x40
+  bfd_arch_alpha,     /* Dec Alpha */
+#define bfd_mach_alpha_ev4  0x10
+#define bfd_mach_alpha_ev5  0x20
+#define bfd_mach_alpha_ev6  0x30
+  bfd_arch_arm,       /* Advanced Risc Machines ARM */
+#define bfd_mach_arm_2         1
+#define bfd_mach_arm_2a        2
+#define bfd_mach_arm_3         3
+#define bfd_mach_arm_3M        4
+#define bfd_mach_arm_4         5
+#define bfd_mach_arm_4T        6
+#define bfd_mach_arm_5         7
+#define bfd_mach_arm_5T        8
+#define bfd_mach_arm_5TE       9
+#define bfd_mach_arm_XScale    10
+  bfd_arch_ns32k,     /* National Semiconductors ns32000 */
+  bfd_arch_w65,       /* WDC 65816 */
+  bfd_arch_tic30,     /* Texas Instruments TMS320C30 */
+  bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
+  bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+  bfd_arch_v850,      /* NEC V850 */
+#define bfd_mach_v850          0
+#define bfd_mach_v850e         'E'
+#define bfd_mach_v850ea        'A'
+  bfd_arch_arc,       /* ARC Cores */
+#define bfd_mach_arc_5         0
+#define bfd_mach_arc_6         1
+#define bfd_mach_arc_7         2
+#define bfd_mach_arc_8         3
+  bfd_arch_m32r,      /* Mitsubishi M32R/D */
+#define bfd_mach_m32r          0 /* backwards compatibility */
+#define bfd_mach_m32rx         'x'
+  bfd_arch_mn10200,   /* Matsushita MN10200 */
+  bfd_arch_mn10300,   /* Matsushita MN10300 */
+#define bfd_mach_mn10300               300
+#define bfd_mach_am33          330
+  bfd_arch_fr30,
+#define bfd_mach_fr30          0x46523330
+  bfd_arch_mcore,
+  bfd_arch_ia64,      /* HP/Intel ia64 */
+#define bfd_mach_ia64_elf64    0
+#define bfd_mach_ia64_elf32    1
+  bfd_arch_pj,
+  bfd_arch_avr,       /* Atmel AVR microcontrollers */
+#define bfd_mach_avr1          1
+#define bfd_mach_avr2          2
+#define bfd_mach_avr3          3
+#define bfd_mach_avr4          4
+#define bfd_mach_avr5          5
+  bfd_arch_cris,      /* Axis CRIS */
+  bfd_arch_s390,      /* IBM s390 */
+#define bfd_mach_s390_esa      0
+#define bfd_mach_s390_esame    1
+  bfd_arch_openrisc,  /* OpenRISC */
+  bfd_arch_last
+  };
+
+typedef struct bfd_arch_info
+{
+  int bits_per_word;
+  int bits_per_address;
+  int bits_per_byte;
+  enum bfd_architecture arch;
+  unsigned long mach;
+  const char *arch_name;
+  const char *printable_name;
+  unsigned int section_align_power;
+  /* True if this is the default machine for the architecture.  */
+  boolean the_default;
+  const struct bfd_arch_info * (*compatible)
+       PARAMS ((const struct bfd_arch_info *a,
+                const struct bfd_arch_info *b));
+
+  boolean (*scan) PARAMS ((const struct bfd_arch_info *, const char *));
+
+  const struct bfd_arch_info *next;
+} bfd_arch_info_type;
+const char *
+bfd_printable_name PARAMS ((bfd *abfd));
+
+const bfd_arch_info_type *
+bfd_scan_arch PARAMS ((const char *string));
+
+const char **
+bfd_arch_list PARAMS ((void));
+
+const bfd_arch_info_type *
+bfd_arch_get_compatible PARAMS ((
+    const bfd *abfd,
+    const bfd *bbfd));
+
+void
+bfd_set_arch_info PARAMS ((bfd *abfd, const bfd_arch_info_type *arg));
+
+enum bfd_architecture
+bfd_get_arch PARAMS ((bfd *abfd));
+
+unsigned long
+bfd_get_mach PARAMS ((bfd *abfd));
+
+unsigned int
+bfd_arch_bits_per_byte PARAMS ((bfd *abfd));
+
+unsigned int
+bfd_arch_bits_per_address PARAMS ((bfd *abfd));
+
+const bfd_arch_info_type *
+bfd_get_arch_info PARAMS ((bfd *abfd));
+
+const bfd_arch_info_type *
+bfd_lookup_arch PARAMS ((enum bfd_architecture
+    arch,
+    unsigned long machine));
+
+const char *
+bfd_printable_arch_mach PARAMS ((enum bfd_architecture arch, unsigned long machine));
+
+unsigned int
+bfd_octets_per_byte PARAMS ((bfd *abfd));
+
+unsigned int
+bfd_arch_mach_octets_per_byte PARAMS ((enum bfd_architecture arch,
+    unsigned long machine));
+
+typedef enum bfd_reloc_status
+{
+       /* No errors detected */
+  bfd_reloc_ok,
+
+       /* The relocation was performed, but there was an overflow. */
+  bfd_reloc_overflow,
+
+       /* The address to relocate was not within the section supplied. */
+  bfd_reloc_outofrange,
+
+       /* Used by special functions */
+  bfd_reloc_continue,
+
+       /* Unsupported relocation size requested. */
+  bfd_reloc_notsupported,
+
+       /* Unused */
+  bfd_reloc_other,
+
+       /* The symbol to relocate against was undefined. */
+  bfd_reloc_undefined,
+
+       /* The relocation was performed, but may not be ok - presently
+          generated only when linking i960 coff files with i960 b.out
+          symbols.  If this type is returned, the error_message argument
+          to bfd_perform_relocation will be set.  */
+  bfd_reloc_dangerous
+ }
+ bfd_reloc_status_type;
+
+
+typedef struct reloc_cache_entry
+{
+       /* A pointer into the canonical table of pointers  */
+  struct symbol_cache_entry **sym_ptr_ptr;
+
+       /* offset in section */
+  bfd_size_type address;
+
+       /* addend for relocation value */
+  bfd_vma addend;
+
+       /* Pointer to how to perform the required relocation */
+  reloc_howto_type *howto;
+
+} arelent;
+enum complain_overflow
+{
+       /* Do not complain on overflow. */
+  complain_overflow_dont,
+
+       /* Complain if the bitfield overflows, whether it is considered
+          as signed or unsigned. */
+  complain_overflow_bitfield,
+
+       /* Complain if the value overflows when considered as signed
+          number. */
+  complain_overflow_signed,
+
+       /* Complain if the value overflows when considered as an
+          unsigned number. */
+  complain_overflow_unsigned
+};
+
+struct reloc_howto_struct
+{
+       /*  The type field has mainly a documentary use - the back end can
+           do what it wants with it, though normally the back end's
+           external idea of what a reloc number is stored
+           in this field. For example, a PC relative word relocation
+           in a coff environment has the type 023 - because that's
+           what the outside world calls a R_PCRWORD reloc. */
+  unsigned int type;
+
+       /*  The value the final relocation is shifted right by. This drops
+           unwanted data from the relocation.  */
+  unsigned int rightshift;
+
+       /*  The size of the item to be relocated.  This is *not* a
+           power-of-two measure.  To get the number of bytes operated
+           on by a type of relocation, use bfd_get_reloc_size.  */
+  int size;
+
+       /*  The number of bits in the item to be relocated.  This is used
+           when doing overflow checking.  */
+  unsigned int bitsize;
+
+       /*  Notes that the relocation is relative to the location in the
+           data section of the addend. The relocation function will
+           subtract from the relocation value the address of the location
+           being relocated. */
+  boolean pc_relative;
+
+       /*  The bit position of the reloc value in the destination.
+           The relocated value is left shifted by this amount. */
+  unsigned int bitpos;
+
+       /* What type of overflow error should be checked for when
+          relocating. */
+  enum complain_overflow complain_on_overflow;
+
+       /* If this field is non null, then the supplied function is
+          called rather than the normal function. This allows really
+          strange relocation methods to be accomodated (e.g., i960 callj
+          instructions). */
+  bfd_reloc_status_type (*special_function)
+                                   PARAMS ((bfd *abfd,
+                                            arelent *reloc_entry,
+                                            struct symbol_cache_entry *symbol,
+                                            PTR data,
+                                            asection *input_section,
+                                            bfd *output_bfd,
+                                            char **error_message));
+
+       /* The textual name of the relocation type. */
+  char *name;
+
+       /* Some formats record a relocation addend in the section contents
+          rather than with the relocation.  For ELF formats this is the
+          distinction between USE_REL and USE_RELA (though the code checks
+          for USE_REL == 1/0).  The value of this field is TRUE if the
+          addend is recorded with the section contents; when performing a
+          partial link (ld -r) the section contents (the data) will be
+          modified.  The value of this field is FALSE if addends are
+          recorded with the relocation (in arelent.addend); when performing
+          a partial link the relocation will be modified.
+          All relocations for all ELF USE_RELA targets should set this field
+          to FALSE (values of TRUE should be looked on with suspicion).
+          However, the converse is not true: not all relocations of all ELF
+          USE_REL targets set this field to TRUE.  Why this is so is peculiar
+          to each particular target.  For relocs that aren't used in partial
+          links (e.g. GOT stuff) it doesn't matter what this is set to.  */
+  boolean partial_inplace;
+
+       /* The src_mask selects which parts of the read in data
+          are to be used in the relocation sum.  E.g., if this was an 8 bit
+          byte of data which we read and relocated, this would be
+          0x000000ff. When we have relocs which have an addend, such as
+          sun4 extended relocs, the value in the offset part of a
+          relocating field is garbage so we never use it. In this case
+          the mask would be 0x00000000. */
+  bfd_vma src_mask;
+
+       /* The dst_mask selects which parts of the instruction are replaced
+          into the instruction. In most cases src_mask == dst_mask,
+          except in the above special case, where dst_mask would be
+          0x000000ff, and src_mask would be 0x00000000.   */
+  bfd_vma dst_mask;
+
+       /* When some formats create PC relative instructions, they leave
+          the value of the pc of the place being relocated in the offset
+          slot of the instruction, so that a PC relative relocation can
+          be made just by adding in an ordinary offset (e.g., sun3 a.out).
+          Some formats leave the displacement part of an instruction
+          empty (e.g., m88k bcs); this flag signals the fact.*/
+  boolean pcrel_offset;
+
+};
+#define HOWTO(C, R,S,B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
+  {(unsigned)C,R,S,B, P, BI, O,SF,NAME,INPLACE,MASKSRC,MASKDST,PC}
+#define NEWHOWTO( FUNCTION, NAME,SIZE,REL,IN) HOWTO(0,0,SIZE,0,REL,0,complain_overflow_dont,FUNCTION, NAME,false,0,0,IN)
+
+#define EMPTY_HOWTO(C) \
+  HOWTO((C),0,0,0,false,0,complain_overflow_dont,NULL,NULL,false,0,0,false)
+
+#define HOWTO_PREPARE(relocation, symbol)      \
+  {                                            \
+  if (symbol != (asymbol *)NULL) {             \
+    if (bfd_is_com_section (symbol->section)) { \
+      relocation = 0;                          \
+    }                                          \
+    else {                                     \
+      relocation = symbol->value;              \
+    }                                          \
+  }                                            \
+}
+unsigned int
+bfd_get_reloc_size PARAMS ((reloc_howto_type *));
+
+typedef struct relent_chain {
+  arelent relent;
+  struct   relent_chain *next;
+} arelent_chain;
+bfd_reloc_status_type
+bfd_check_overflow PARAMS ((enum complain_overflow how,
+    unsigned int bitsize,
+    unsigned int rightshift,
+    unsigned int addrsize,
+    bfd_vma relocation));
+
+bfd_reloc_status_type
+bfd_perform_relocation PARAMS ((bfd *abfd,
+    arelent *reloc_entry,
+    PTR data,
+    asection *input_section,
+    bfd *output_bfd,
+    char **error_message));
+
+bfd_reloc_status_type
+bfd_install_relocation PARAMS ((bfd *abfd,
+    arelent *reloc_entry,
+    PTR data, bfd_vma data_start,
+    asection *input_section,
+    char **error_message));
+
+enum bfd_reloc_code_real {
+  _dummy_first_bfd_reloc_code_real,
+
+
+/* Basic absolute relocations of N bits. */
+  BFD_RELOC_64,
+  BFD_RELOC_32,
+  BFD_RELOC_26,
+  BFD_RELOC_24,
+  BFD_RELOC_16,
+  BFD_RELOC_14,
+  BFD_RELOC_8,
+
+/* PC-relative relocations.  Sometimes these are relative to the address
+of the relocation itself; sometimes they are relative to the start of
+the section containing the relocation.  It depends on the specific target.
+
+The 24-bit relocation is used in some Intel 960 configurations. */
+  BFD_RELOC_64_PCREL,
+  BFD_RELOC_32_PCREL,
+  BFD_RELOC_24_PCREL,
+  BFD_RELOC_16_PCREL,
+  BFD_RELOC_12_PCREL,
+  BFD_RELOC_8_PCREL,
+
+/* For ELF. */
+  BFD_RELOC_32_GOT_PCREL,
+  BFD_RELOC_16_GOT_PCREL,
+  BFD_RELOC_8_GOT_PCREL,
+  BFD_RELOC_32_GOTOFF,
+  BFD_RELOC_16_GOTOFF,
+  BFD_RELOC_LO16_GOTOFF,
+  BFD_RELOC_HI16_GOTOFF,
+  BFD_RELOC_HI16_S_GOTOFF,
+  BFD_RELOC_8_GOTOFF,
+  BFD_RELOC_32_PLT_PCREL,
+  BFD_RELOC_24_PLT_PCREL,
+  BFD_RELOC_16_PLT_PCREL,
+  BFD_RELOC_8_PLT_PCREL,
+  BFD_RELOC_32_PLTOFF,
+  BFD_RELOC_16_PLTOFF,
+  BFD_RELOC_LO16_PLTOFF,
+  BFD_RELOC_HI16_PLTOFF,
+  BFD_RELOC_HI16_S_PLTOFF,
+  BFD_RELOC_8_PLTOFF,
+
+/* Relocations used by 68K ELF. */
+  BFD_RELOC_68K_GLOB_DAT,
+  BFD_RELOC_68K_JMP_SLOT,
+  BFD_RELOC_68K_RELATIVE,
+
+/* Linkage-table relative. */
+  BFD_RELOC_32_BASEREL,
+  BFD_RELOC_16_BASEREL,
+  BFD_RELOC_LO16_BASEREL,
+  BFD_RELOC_HI16_BASEREL,
+  BFD_RELOC_HI16_S_BASEREL,
+  BFD_RELOC_8_BASEREL,
+  BFD_RELOC_RVA,
+
+/* Absolute 8-bit relocation, but used to form an address like 0xFFnn. */
+  BFD_RELOC_8_FFnn,
+
+/* These PC-relative relocations are stored as word displacements --
+i.e., byte displacements shifted right two bits.  The 30-bit word
+displacement (<<32_PCREL_S2>> -- 32 bits, shifted 2) is used on the
+SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
+signed 16-bit displacement is used on the MIPS, and the 23-bit
+displacement is used on the Alpha. */
+  BFD_RELOC_32_PCREL_S2,
+  BFD_RELOC_16_PCREL_S2,
+  BFD_RELOC_23_PCREL_S2,
+
+/* High 22 bits and low 10 bits of 32-bit value, placed into lower bits of
+the target word.  These are used on the SPARC. */
+  BFD_RELOC_HI22,
+  BFD_RELOC_LO10,
+
+/* For systems that allocate a Global Pointer register, these are
+displacements off that register.  These relocation types are
+handled specially, because the value the register will have is
+decided relatively late. */
+  BFD_RELOC_GPREL16,
+  BFD_RELOC_GPREL32,
+
+/* Reloc types used for i960/b.out. */
+  BFD_RELOC_I960_CALLJ,
+
+/* SPARC ELF relocations.  There is probably some overlap with other
+relocation types already defined. */
+  BFD_RELOC_NONE,
+  BFD_RELOC_SPARC_WDISP22,
+  BFD_RELOC_SPARC22,
+  BFD_RELOC_SPARC13,
+  BFD_RELOC_SPARC_GOT10,
+  BFD_RELOC_SPARC_GOT13,
+  BFD_RELOC_SPARC_GOT22,
+  BFD_RELOC_SPARC_PC10,
+  BFD_RELOC_SPARC_PC22,
+  BFD_RELOC_SPARC_WPLT30,
+  BFD_RELOC_SPARC_COPY,
+  BFD_RELOC_SPARC_GLOB_DAT,
+  BFD_RELOC_SPARC_JMP_SLOT,
+  BFD_RELOC_SPARC_RELATIVE,
+  BFD_RELOC_SPARC_UA32,
+
+/* I think these are specific to SPARC a.out (e.g., Sun 4). */
+  BFD_RELOC_SPARC_BASE13,
+  BFD_RELOC_SPARC_BASE22,
+
+/* SPARC64 relocations */
+#define BFD_RELOC_SPARC_64 BFD_RELOC_64
+  BFD_RELOC_SPARC_10,
+  BFD_RELOC_SPARC_11,
+  BFD_RELOC_SPARC_OLO10,
+  BFD_RELOC_SPARC_HH22,
+  BFD_RELOC_SPARC_HM10,
+  BFD_RELOC_SPARC_LM22,
+  BFD_RELOC_SPARC_PC_HH22,
+  BFD_RELOC_SPARC_PC_HM10,
+  BFD_RELOC_SPARC_PC_LM22,
+  BFD_RELOC_SPARC_WDISP16,
+  BFD_RELOC_SPARC_WDISP19,
+  BFD_RELOC_SPARC_7,
+  BFD_RELOC_SPARC_6,
+  BFD_RELOC_SPARC_5,
+#define BFD_RELOC_SPARC_DISP64 BFD_RELOC_64_PCREL
+  BFD_RELOC_SPARC_PLT64,
+  BFD_RELOC_SPARC_HIX22,
+  BFD_RELOC_SPARC_LOX10,
+  BFD_RELOC_SPARC_H44,
+  BFD_RELOC_SPARC_M44,
+  BFD_RELOC_SPARC_L44,
+  BFD_RELOC_SPARC_REGISTER,
+
+/* SPARC little endian relocation */
+  BFD_RELOC_SPARC_REV32,
+
+/* Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
+"addend" in some special way.
+For GPDISP_HI16 ("gpdisp") relocations, the symbol is ignored when
+writing; when reading, it will be the absolute section symbol.  The
+addend is the displacement in bytes of the "lda" instruction from
+the "ldah" instruction (which is at the address of this reloc). */
+  BFD_RELOC_ALPHA_GPDISP_HI16,
+
+/* For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
+with GPDISP_HI16 relocs.  The addend is ignored when writing the
+relocations out, and is filled in with the file's GP value on
+reading, for convenience. */
+  BFD_RELOC_ALPHA_GPDISP_LO16,
+
+/* The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
+relocation except that there is no accompanying GPDISP_LO16
+relocation. */
+  BFD_RELOC_ALPHA_GPDISP,
+
+/* The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
+the assembler turns it into a LDQ instruction to load the address of
+the symbol, and then fills in a register in the real instruction.
+
+The LITERAL reloc, at the LDQ instruction, refers to the .lita
+section symbol.  The addend is ignored when writing, but is filled
+in with the file's GP value on reading, for convenience, as with the
+GPDISP_LO16 reloc.
+
+The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
+It should refer to the symbol to be referenced, as with 16_GOTOFF,
+but it generates output not based on the position within the .got
+section, but relative to the GP value chosen for the file during the
+final link stage.
+
+The LITUSE reloc, on the instruction using the loaded address, gives
+information to the linker that it might be able to use to optimize
+away some literal section references.  The symbol is ignored (read
+as the absolute section symbol), and the "addend" indicates the type
+of instruction using the register:
+1 - "memory" fmt insn
+2 - byte-manipulation (byte offset reg)
+3 - jsr (target of branch)
+
+The GNU linker currently doesn't do any of this optimizing. */
+  BFD_RELOC_ALPHA_LITERAL,
+  BFD_RELOC_ALPHA_ELF_LITERAL,
+  BFD_RELOC_ALPHA_LITUSE,
+
+/* The BFD_RELOC_ALPHA_USER_* relocations are used by the assembler to
+process the explicit !<reloc>!sequence relocations, and are mapped
+into the normal relocations at the end of processing. */
+  BFD_RELOC_ALPHA_USER_LITERAL,
+  BFD_RELOC_ALPHA_USER_LITUSE_BASE,
+  BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF,
+  BFD_RELOC_ALPHA_USER_LITUSE_JSR,
+  BFD_RELOC_ALPHA_USER_GPDISP,
+  BFD_RELOC_ALPHA_USER_GPRELHIGH,
+  BFD_RELOC_ALPHA_USER_GPRELLOW,
+
+/* The HINT relocation indicates a value that should be filled into the
+"hint" field of a jmp/jsr/ret instruction, for possible branch-
+prediction logic which may be provided on some processors. */
+  BFD_RELOC_ALPHA_HINT,
+
+/* The LINKAGE relocation outputs a linkage pair in the object file,
+which is filled by the linker. */
+  BFD_RELOC_ALPHA_LINKAGE,
+
+/* The CODEADDR relocation outputs a STO_CA in the object file,
+which is filled by the linker. */
+  BFD_RELOC_ALPHA_CODEADDR,
+
+/* Bits 27..2 of the relocation address shifted right 2 bits;
+simple reloc otherwise. */
+  BFD_RELOC_MIPS_JMP,
+
+/* The MIPS16 jump instruction. */
+  BFD_RELOC_MIPS16_JMP,
+
+/* MIPS16 GP relative reloc. */
+  BFD_RELOC_MIPS16_GPREL,
+
+/* High 16 bits of 32-bit value; simple reloc. */
+  BFD_RELOC_HI16,
+
+/* High 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added. */
+  BFD_RELOC_HI16_S,
+
+/* Low 16 bits. */
+  BFD_RELOC_LO16,
+
+/* Like BFD_RELOC_HI16_S, but PC relative. */
+  BFD_RELOC_PCREL_HI16_S,
+
+/* Like BFD_RELOC_LO16, but PC relative. */
+  BFD_RELOC_PCREL_LO16,
+
+/* Relocation relative to the global pointer. */
+#define BFD_RELOC_MIPS_GPREL BFD_RELOC_GPREL16
+
+/* Relocation against a MIPS literal section. */
+  BFD_RELOC_MIPS_LITERAL,
+
+/* MIPS ELF relocations. */
+  BFD_RELOC_MIPS_GOT16,
+  BFD_RELOC_MIPS_CALL16,
+#define BFD_RELOC_MIPS_GPREL32 BFD_RELOC_GPREL32
+  BFD_RELOC_MIPS_GOT_HI16,
+  BFD_RELOC_MIPS_GOT_LO16,
+  BFD_RELOC_MIPS_CALL_HI16,
+  BFD_RELOC_MIPS_CALL_LO16,
+  BFD_RELOC_MIPS_SUB,
+  BFD_RELOC_MIPS_GOT_PAGE,
+  BFD_RELOC_MIPS_GOT_OFST,
+  BFD_RELOC_MIPS_GOT_DISP,
+
+
+/* i386/elf relocations */
+  BFD_RELOC_386_GOT32,
+  BFD_RELOC_386_PLT32,
+  BFD_RELOC_386_COPY,
+  BFD_RELOC_386_GLOB_DAT,
+  BFD_RELOC_386_JUMP_SLOT,
+  BFD_RELOC_386_RELATIVE,
+  BFD_RELOC_386_GOTOFF,
+  BFD_RELOC_386_GOTPC,
+
+/* x86-64/elf relocations */
+  BFD_RELOC_X86_64_GOT32,
+  BFD_RELOC_X86_64_PLT32,
+  BFD_RELOC_X86_64_COPY,
+  BFD_RELOC_X86_64_GLOB_DAT,
+  BFD_RELOC_X86_64_JUMP_SLOT,
+  BFD_RELOC_X86_64_RELATIVE,
+  BFD_RELOC_X86_64_GOTPCREL,
+  BFD_RELOC_X86_64_32S,
+
+/* ns32k relocations */
+  BFD_RELOC_NS32K_IMM_8,
+  BFD_RELOC_NS32K_IMM_16,
+  BFD_RELOC_NS32K_IMM_32,
+  BFD_RELOC_NS32K_IMM_8_PCREL,
+  BFD_RELOC_NS32K_IMM_16_PCREL,
+  BFD_RELOC_NS32K_IMM_32_PCREL,
+  BFD_RELOC_NS32K_DISP_8,
+  BFD_RELOC_NS32K_DISP_16,
+  BFD_RELOC_NS32K_DISP_32,
+  BFD_RELOC_NS32K_DISP_8_PCREL,
+  BFD_RELOC_NS32K_DISP_16_PCREL,
+  BFD_RELOC_NS32K_DISP_32_PCREL,
+
+/* PDP11 relocations */
+  BFD_RELOC_PDP11_DISP_8_PCREL,
+  BFD_RELOC_PDP11_DISP_6_PCREL,
+
+/* Picojava relocs.  Not all of these appear in object files. */
+  BFD_RELOC_PJ_CODE_HI16,
+  BFD_RELOC_PJ_CODE_LO16,
+  BFD_RELOC_PJ_CODE_DIR16,
+  BFD_RELOC_PJ_CODE_DIR32,
+  BFD_RELOC_PJ_CODE_REL16,
+  BFD_RELOC_PJ_CODE_REL32,
+
+/* Power(rs6000) and PowerPC relocations. */
+  BFD_RELOC_PPC_B26,
+  BFD_RELOC_PPC_BA26,
+  BFD_RELOC_PPC_TOC16,
+  BFD_RELOC_PPC_B16,
+  BFD_RELOC_PPC_B16_BRTAKEN,
+  BFD_RELOC_PPC_B16_BRNTAKEN,
+  BFD_RELOC_PPC_BA16,
+  BFD_RELOC_PPC_BA16_BRTAKEN,
+  BFD_RELOC_PPC_BA16_BRNTAKEN,
+  BFD_RELOC_PPC_COPY,
+  BFD_RELOC_PPC_GLOB_DAT,
+  BFD_RELOC_PPC_JMP_SLOT,
+  BFD_RELOC_PPC_RELATIVE,
+  BFD_RELOC_PPC_LOCAL24PC,
+  BFD_RELOC_PPC_EMB_NADDR32,
+  BFD_RELOC_PPC_EMB_NADDR16,
+  BFD_RELOC_PPC_EMB_NADDR16_LO,
+  BFD_RELOC_PPC_EMB_NADDR16_HI,
+  BFD_RELOC_PPC_EMB_NADDR16_HA,
+  BFD_RELOC_PPC_EMB_SDAI16,
+  BFD_RELOC_PPC_EMB_SDA2I16,
+  BFD_RELOC_PPC_EMB_SDA2REL,
+  BFD_RELOC_PPC_EMB_SDA21,
+  BFD_RELOC_PPC_EMB_MRKREF,
+  BFD_RELOC_PPC_EMB_RELSEC16,
+  BFD_RELOC_PPC_EMB_RELST_LO,
+  BFD_RELOC_PPC_EMB_RELST_HI,
+  BFD_RELOC_PPC_EMB_RELST_HA,
+  BFD_RELOC_PPC_EMB_BIT_FLD,
+  BFD_RELOC_PPC_EMB_RELSDA,
+
+/* IBM 370/390 relocations */
+  BFD_RELOC_I370_D12,
+
+/* The type of reloc used to build a contructor table - at the moment
+probably a 32 bit wide absolute relocation, but the target can choose.
+It generally does map to one of the other relocation types. */
+  BFD_RELOC_CTOR,
+
+/* ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction. */
+  BFD_RELOC_ARM_PCREL_BRANCH,
+
+/* ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction. */
+  BFD_RELOC_ARM_PCREL_BLX,
+
+/* Thumb 22 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction. */
+  BFD_RELOC_THUMB_PCREL_BLX,
+
+/* These relocs are only used within the ARM assembler.  They are not
+(at present) written to any object files. */
+  BFD_RELOC_ARM_IMMEDIATE,
+  BFD_RELOC_ARM_ADRL_IMMEDIATE,
+  BFD_RELOC_ARM_OFFSET_IMM,
+  BFD_RELOC_ARM_SHIFT_IMM,
+  BFD_RELOC_ARM_SWI,
+  BFD_RELOC_ARM_MULTI,
+  BFD_RELOC_ARM_CP_OFF_IMM,
+  BFD_RELOC_ARM_ADR_IMM,
+  BFD_RELOC_ARM_LDR_IMM,
+  BFD_RELOC_ARM_LITERAL,
+  BFD_RELOC_ARM_IN_POOL,
+  BFD_RELOC_ARM_OFFSET_IMM8,
+  BFD_RELOC_ARM_HWLITERAL,
+  BFD_RELOC_ARM_THUMB_ADD,
+  BFD_RELOC_ARM_THUMB_IMM,
+  BFD_RELOC_ARM_THUMB_SHIFT,
+  BFD_RELOC_ARM_THUMB_OFFSET,
+  BFD_RELOC_ARM_GOT12,
+  BFD_RELOC_ARM_GOT32,
+  BFD_RELOC_ARM_JUMP_SLOT,
+  BFD_RELOC_ARM_COPY,
+  BFD_RELOC_ARM_GLOB_DAT,
+  BFD_RELOC_ARM_PLT32,
+  BFD_RELOC_ARM_RELATIVE,
+  BFD_RELOC_ARM_GOTOFF,
+  BFD_RELOC_ARM_GOTPC,
+
+/* Hitachi SH relocs.  Not all of these appear in object files. */
+  BFD_RELOC_SH_PCDISP8BY2,
+  BFD_RELOC_SH_PCDISP12BY2,
+  BFD_RELOC_SH_IMM4,
+  BFD_RELOC_SH_IMM4BY2,
+  BFD_RELOC_SH_IMM4BY4,
+  BFD_RELOC_SH_IMM8,
+  BFD_RELOC_SH_IMM8BY2,
+  BFD_RELOC_SH_IMM8BY4,
+  BFD_RELOC_SH_PCRELIMM8BY2,
+  BFD_RELOC_SH_PCRELIMM8BY4,
+  BFD_RELOC_SH_SWITCH16,
+  BFD_RELOC_SH_SWITCH32,
+  BFD_RELOC_SH_USES,
+  BFD_RELOC_SH_COUNT,
+  BFD_RELOC_SH_ALIGN,
+  BFD_RELOC_SH_CODE,
+  BFD_RELOC_SH_DATA,
+  BFD_RELOC_SH_LABEL,
+  BFD_RELOC_SH_LOOP_START,
+  BFD_RELOC_SH_LOOP_END,
+  BFD_RELOC_SH_COPY,
+  BFD_RELOC_SH_GLOB_DAT,
+  BFD_RELOC_SH_JMP_SLOT,
+  BFD_RELOC_SH_RELATIVE,
+  BFD_RELOC_SH_GOTPC,
+
+/* Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
+be zero and is not stored in the instruction. */
+  BFD_RELOC_THUMB_PCREL_BRANCH9,
+  BFD_RELOC_THUMB_PCREL_BRANCH12,
+  BFD_RELOC_THUMB_PCREL_BRANCH23,
+
+/* ARC Cores relocs.
+ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction.  The high 20 bits are installed in bits 26
+through 7 of the instruction. */
+  BFD_RELOC_ARC_B22_PCREL,
+
+/* ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
+stored in the instruction.  The high 24 bits are installed in bits 23
+through 0. */
+  BFD_RELOC_ARC_B26,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0. */
+  BFD_RELOC_D10V_10_PCREL_R,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0.  This is the same as the previous reloc
+except it is in the left container, i.e.,
+shifted left 15 bits. */
+  BFD_RELOC_D10V_10_PCREL_L,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0. */
+  BFD_RELOC_D10V_18,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0. */
+  BFD_RELOC_D10V_18_PCREL,
+
+/* Mitsubishi D30V relocs.
+This is a 6-bit absolute reloc. */
+  BFD_RELOC_D30V_6,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0. */
+  BFD_RELOC_D30V_9_PCREL,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container. */
+  BFD_RELOC_D30V_9_PCREL_R,
+
+/* This is a 12-bit absolute reloc with the
+right 3 bitsassumed to be 0. */
+  BFD_RELOC_D30V_15,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0. */
+  BFD_RELOC_D30V_15_PCREL,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container. */
+  BFD_RELOC_D30V_15_PCREL_R,
+
+/* This is an 18-bit absolute reloc with
+the right 3 bits assumed to be 0. */
+  BFD_RELOC_D30V_21,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0. */
+  BFD_RELOC_D30V_21_PCREL,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container. */
+  BFD_RELOC_D30V_21_PCREL_R,
+
+/* This is a 32-bit absolute reloc. */
+  BFD_RELOC_D30V_32,
+
+/* This is a 32-bit pc-relative reloc. */
+  BFD_RELOC_D30V_32_PCREL,
+
+/* Mitsubishi M32R relocs.
+This is a 24 bit absolute address. */
+  BFD_RELOC_M32R_24,
+
+/* This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0. */
+  BFD_RELOC_M32R_10_PCREL,
+
+/* This is an 18-bit reloc with the right 2 bits assumed to be 0. */
+  BFD_RELOC_M32R_18_PCREL,
+
+/* This is a 26-bit reloc with the right 2 bits assumed to be 0. */
+  BFD_RELOC_M32R_26_PCREL,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as unsigned. */
+  BFD_RELOC_M32R_HI16_ULO,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as signed. */
+  BFD_RELOC_M32R_HI16_SLO,
+
+/* This is a 16-bit reloc containing the lower 16 bits of an address. */
+  BFD_RELOC_M32R_LO16,
+
+/* This is a 16-bit reloc containing the small data area offset for use in
+add3, load, and store instructions. */
+  BFD_RELOC_M32R_SDA16,
+
+/* This is a 9-bit reloc */
+  BFD_RELOC_V850_9_PCREL,
+
+/* This is a 22-bit reloc */
+  BFD_RELOC_V850_22_PCREL,
+
+/* This is a 16 bit offset from the short data area pointer. */
+  BFD_RELOC_V850_SDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+short data area pointer. */
+  BFD_RELOC_V850_SDA_15_16_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer. */
+  BFD_RELOC_V850_ZDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+zero data area pointer. */
+  BFD_RELOC_V850_ZDA_15_16_OFFSET,
+
+/* This is an 8 bit offset (of which only 6 bits are used) from the
+tiny data area pointer. */
+  BFD_RELOC_V850_TDA_6_8_OFFSET,
+
+/* This is an 8bit offset (of which only 7 bits are used) from the tiny
+data area pointer. */
+  BFD_RELOC_V850_TDA_7_8_OFFSET,
+
+/* This is a 7 bit offset from the tiny data area pointer. */
+  BFD_RELOC_V850_TDA_7_7_OFFSET,
+
+/* This is a 16 bit offset from the tiny data area pointer. */
+  BFD_RELOC_V850_TDA_16_16_OFFSET,
+
+/* This is a 5 bit offset (of which only 4 bits are used) from the tiny
+data area pointer. */
+  BFD_RELOC_V850_TDA_4_5_OFFSET,
+
+/* This is a 4 bit offset from the tiny data area pointer. */
+  BFD_RELOC_V850_TDA_4_4_OFFSET,
+
+/* This is a 16 bit offset from the short data area pointer, with the
+bits placed non-contigously in the instruction. */
+  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer, with the
+bits placed non-contigously in the instruction. */
+  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,
+
+/* This is a 6 bit offset from the call table base pointer. */
+  BFD_RELOC_V850_CALLT_6_7_OFFSET,
+
+/* This is a 16 bit offset from the call table base pointer. */
+  BFD_RELOC_V850_CALLT_16_16_OFFSET,
+
+
+/* This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction. */
+  BFD_RELOC_MN10300_32_PCREL,
+
+/* This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction. */
+  BFD_RELOC_MN10300_16_PCREL,
+
+/* This is a 8bit DP reloc for the tms320c30, where the most
+significant 8 bits of a 24 bit word are placed into the least
+significant 8 bits of the opcode. */
+  BFD_RELOC_TIC30_LDP,
+
+/* This is a 7bit reloc for the tms320c54x, where the least
+significant 7 bits of a 16 bit word are placed into the least
+significant 7 bits of the opcode. */
+  BFD_RELOC_TIC54X_PARTLS7,
+
+/* This is a 9bit DP reloc for the tms320c54x, where the most
+significant 9 bits of a 16 bit word are placed into the least
+significant 9 bits of the opcode. */
+  BFD_RELOC_TIC54X_PARTMS9,
+
+/* This is an extended address 23-bit reloc for the tms320c54x. */
+  BFD_RELOC_TIC54X_23,
+
+/* This is a 16-bit reloc for the tms320c54x, where the least
+significant 16 bits of a 23-bit extended address are placed into
+the opcode. */
+  BFD_RELOC_TIC54X_16_OF_23,
+
+/* This is a reloc for the tms320c54x, where the most
+significant 7 bits of a 23-bit extended address are placed into
+the opcode. */
+  BFD_RELOC_TIC54X_MS7_OF_23,
+
+/* This is a 48 bit reloc for the FR30 that stores 32 bits. */
+  BFD_RELOC_FR30_48,
+
+/* This is a 32 bit reloc for the FR30 that stores 20 bits split up into
+two sections. */
+  BFD_RELOC_FR30_20,
+
+/* This is a 16 bit reloc for the FR30 that stores a 6 bit word offset in
+4 bits. */
+  BFD_RELOC_FR30_6_IN_4,
+
+/* This is a 16 bit reloc for the FR30 that stores an 8 bit byte offset
+into 8 bits. */
+  BFD_RELOC_FR30_8_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit short offset
+into 8 bits. */
+  BFD_RELOC_FR30_9_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 10 bit word offset
+into 8 bits. */
+  BFD_RELOC_FR30_10_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
+short offset into 8 bits. */
+  BFD_RELOC_FR30_9_PCREL,
+
+/* This is a 16 bit reloc for the FR30 that stores a 12 bit pc relative
+short offset into 11 bits. */
+  BFD_RELOC_FR30_12_PCREL,
+
+/* Motorola Mcore relocations. */
+  BFD_RELOC_MCORE_PCREL_IMM8BY4,
+  BFD_RELOC_MCORE_PCREL_IMM11BY2,
+  BFD_RELOC_MCORE_PCREL_IMM4BY2,
+  BFD_RELOC_MCORE_PCREL_32,
+  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
+  BFD_RELOC_MCORE_RVA,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit pc relative
+short offset into 7 bits. */
+  BFD_RELOC_AVR_7_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 13 bit pc relative
+short offset into 12 bits. */
+  BFD_RELOC_AVR_13_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 17 bit value (usually
+program memory address) into 16 bits. */
+  BFD_RELOC_AVR_16_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+data memory address) into 8 bit immediate value of LDI insn. */
+  BFD_RELOC_AVR_LO8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of data memory address) into 8 bit immediate value of LDI insn. */
+  BFD_RELOC_AVR_HI8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of program memory address) into 8 bit immediate value of LDI insn. */
+  BFD_RELOC_AVR_HH8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually data memory address) into 8 bit immediate value of SUBI insn. */
+  BFD_RELOC_AVR_LO8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of data memory address) into 8 bit immediate value of
+SUBI insn. */
+  BFD_RELOC_AVR_HI8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(most high 8 bit of program memory address) into 8 bit immediate value
+of LDI or SUBI insn. */
+  BFD_RELOC_AVR_HH8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+command address) into 8 bit immediate value of LDI insn. */
+  BFD_RELOC_AVR_LO8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of command address) into 8 bit immediate value of LDI insn. */
+  BFD_RELOC_AVR_HI8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of command address) into 8 bit immediate value of LDI insn. */
+  BFD_RELOC_AVR_HH8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually command address) into 8 bit immediate value of SUBI insn. */
+  BFD_RELOC_AVR_LO8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of 16 bit command address) into 8 bit immediate value
+of SUBI insn. */
+  BFD_RELOC_AVR_HI8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 6 bit of 22 bit command address) into 8 bit immediate
+value of SUBI insn. */
+  BFD_RELOC_AVR_HH8_LDI_PM_NEG,
+
+/* This is a 32 bit reloc for the AVR that stores 23 bit value
+into 22 bits. */
+  BFD_RELOC_AVR_CALL,
+
+/* Direct 12 bit. */
+  BFD_RELOC_390_12,
+
+/* 12 bit GOT offset. */
+  BFD_RELOC_390_GOT12,
+
+/* 32 bit PC relative PLT address. */
+  BFD_RELOC_390_PLT32,
+
+/* Copy symbol at runtime. */
+  BFD_RELOC_390_COPY,
+
+/* Create GOT entry. */
+  BFD_RELOC_390_GLOB_DAT,
+
+/* Create PLT entry. */
+  BFD_RELOC_390_JMP_SLOT,
+
+/* Adjust by program base. */
+  BFD_RELOC_390_RELATIVE,
+
+/* 32 bit PC relative offset to GOT. */
+  BFD_RELOC_390_GOTPC,
+
+/* 16 bit GOT offset. */
+  BFD_RELOC_390_GOT16,
+
+/* PC relative 16 bit shifted by 1. */
+  BFD_RELOC_390_PC16DBL,
+
+/* 16 bit PC rel. PLT shifted by 1. */
+  BFD_RELOC_390_PLT16DBL,
+
+/* PC relative 32 bit shifted by 1. */
+  BFD_RELOC_390_PC32DBL,
+
+/* 32 bit PC rel. PLT shifted by 1. */
+  BFD_RELOC_390_PLT32DBL,
+
+/* 32 bit PC rel. GOT shifted by 1. */
+  BFD_RELOC_390_GOTPCDBL,
+
+/* 64 bit GOT offset. */
+  BFD_RELOC_390_GOT64,
+
+/* 64 bit PC relative PLT address. */
+  BFD_RELOC_390_PLT64,
+
+/* 32 bit rel. offset to GOT entry. */
+  BFD_RELOC_390_GOTENT,
+
+/* These two relocations are used by the linker to determine which of
+the entries in a C++ virtual function table are actually used.  When
+the --gc-sections option is given, the linker will zero out the entries
+that are not used, so that the code for those functions need not be
+included in the output.
+
+VTABLE_INHERIT is a zero-space relocation used to describe to the
+linker the inheritence tree of a C++ virtual function table.  The
+relocation's symbol should be the parent class' vtable, and the
+relocation should be located at the child vtable.
+
+VTABLE_ENTRY is a zero-space relocation that describes the use of a
+virtual function table entry.  The reloc's symbol should refer to the
+table of the class mentioned in the code.  Off of that base, an offset
+describes the entry that is being used.  For Rela hosts, this offset
+is stored in the reloc's addend.  For Rel hosts, we are forced to put
+this offset in the reloc's section offset. */
+  BFD_RELOC_VTABLE_INHERIT,
+  BFD_RELOC_VTABLE_ENTRY,
+
+/* Intel IA64 Relocations. */
+  BFD_RELOC_IA64_IMM14,
+  BFD_RELOC_IA64_IMM22,
+  BFD_RELOC_IA64_IMM64,
+  BFD_RELOC_IA64_DIR32MSB,
+  BFD_RELOC_IA64_DIR32LSB,
+  BFD_RELOC_IA64_DIR64MSB,
+  BFD_RELOC_IA64_DIR64LSB,
+  BFD_RELOC_IA64_GPREL22,
+  BFD_RELOC_IA64_GPREL64I,
+  BFD_RELOC_IA64_GPREL32MSB,
+  BFD_RELOC_IA64_GPREL32LSB,
+  BFD_RELOC_IA64_GPREL64MSB,
+  BFD_RELOC_IA64_GPREL64LSB,
+  BFD_RELOC_IA64_LTOFF22,
+  BFD_RELOC_IA64_LTOFF64I,
+  BFD_RELOC_IA64_PLTOFF22,
+  BFD_RELOC_IA64_PLTOFF64I,
+  BFD_RELOC_IA64_PLTOFF64MSB,
+  BFD_RELOC_IA64_PLTOFF64LSB,
+  BFD_RELOC_IA64_FPTR64I,
+  BFD_RELOC_IA64_FPTR32MSB,
+  BFD_RELOC_IA64_FPTR32LSB,
+  BFD_RELOC_IA64_FPTR64MSB,
+  BFD_RELOC_IA64_FPTR64LSB,
+  BFD_RELOC_IA64_PCREL21B,
+  BFD_RELOC_IA64_PCREL21BI,
+  BFD_RELOC_IA64_PCREL21M,
+  BFD_RELOC_IA64_PCREL21F,
+  BFD_RELOC_IA64_PCREL22,
+  BFD_RELOC_IA64_PCREL60B,
+  BFD_RELOC_IA64_PCREL64I,
+  BFD_RELOC_IA64_PCREL32MSB,
+  BFD_RELOC_IA64_PCREL32LSB,
+  BFD_RELOC_IA64_PCREL64MSB,
+  BFD_RELOC_IA64_PCREL64LSB,
+  BFD_RELOC_IA64_LTOFF_FPTR22,
+  BFD_RELOC_IA64_LTOFF_FPTR64I,
+  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
+  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
+  BFD_RELOC_IA64_SEGREL32MSB,
+  BFD_RELOC_IA64_SEGREL32LSB,
+  BFD_RELOC_IA64_SEGREL64MSB,
+  BFD_RELOC_IA64_SEGREL64LSB,
+  BFD_RELOC_IA64_SECREL32MSB,
+  BFD_RELOC_IA64_SECREL32LSB,
+  BFD_RELOC_IA64_SECREL64MSB,
+  BFD_RELOC_IA64_SECREL64LSB,
+  BFD_RELOC_IA64_REL32MSB,
+  BFD_RELOC_IA64_REL32LSB,
+  BFD_RELOC_IA64_REL64MSB,
+  BFD_RELOC_IA64_REL64LSB,
+  BFD_RELOC_IA64_LTV32MSB,
+  BFD_RELOC_IA64_LTV32LSB,
+  BFD_RELOC_IA64_LTV64MSB,
+  BFD_RELOC_IA64_LTV64LSB,
+  BFD_RELOC_IA64_IPLTMSB,
+  BFD_RELOC_IA64_IPLTLSB,
+  BFD_RELOC_IA64_COPY,
+  BFD_RELOC_IA64_TPREL22,
+  BFD_RELOC_IA64_TPREL64MSB,
+  BFD_RELOC_IA64_TPREL64LSB,
+  BFD_RELOC_IA64_LTOFF_TP22,
+  BFD_RELOC_IA64_LTOFF22X,
+  BFD_RELOC_IA64_LDXMOV,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bits high part of an absolute address. */
+  BFD_RELOC_M68HC11_HI8,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bits low part of an absolute address. */
+  BFD_RELOC_M68HC11_LO8,
+
+/* Motorola 68HC11 reloc.
+This is the 3 bits of a value. */
+  BFD_RELOC_M68HC11_3B,
+
+/* These relocs are only used within the CRIS assembler.  They are not
+(at present) written to any object files. */
+  BFD_RELOC_CRIS_BDISP8,
+  BFD_RELOC_CRIS_UNSIGNED_5,
+  BFD_RELOC_CRIS_SIGNED_6,
+  BFD_RELOC_CRIS_UNSIGNED_6,
+  BFD_RELOC_CRIS_UNSIGNED_4,
+
+/* Relocs used in ELF shared libraries for CRIS. */
+  BFD_RELOC_CRIS_COPY,
+  BFD_RELOC_CRIS_GLOB_DAT,
+  BFD_RELOC_CRIS_JUMP_SLOT,
+  BFD_RELOC_CRIS_RELATIVE,
+
+/* 32-bit offset to symbol-entry within GOT. */
+  BFD_RELOC_CRIS_32_GOT,
+
+/* 16-bit offset to symbol-entry within GOT. */
+  BFD_RELOC_CRIS_16_GOT,
+
+/* 32-bit offset to symbol-entry within GOT, with PLT handling. */
+  BFD_RELOC_CRIS_32_GOTPLT,
+
+/* 16-bit offset to symbol-entry within GOT, with PLT handling. */
+  BFD_RELOC_CRIS_16_GOTPLT,
+
+/* 32-bit offset to symbol, relative to GOT. */
+  BFD_RELOC_CRIS_32_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to GOT. */
+  BFD_RELOC_CRIS_32_PLT_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to this relocation. */
+  BFD_RELOC_CRIS_32_PLT_PCREL,
+
+/* Intel i860 Relocations. */
+  BFD_RELOC_860_COPY,
+  BFD_RELOC_860_GLOB_DAT,
+  BFD_RELOC_860_JUMP_SLOT,
+  BFD_RELOC_860_RELATIVE,
+  BFD_RELOC_860_PC26,
+  BFD_RELOC_860_PLT26,
+  BFD_RELOC_860_PC16,
+  BFD_RELOC_860_LOW0,
+  BFD_RELOC_860_SPLIT0,
+  BFD_RELOC_860_LOW1,
+  BFD_RELOC_860_SPLIT1,
+  BFD_RELOC_860_LOW2,
+  BFD_RELOC_860_SPLIT2,
+  BFD_RELOC_860_LOW3,
+  BFD_RELOC_860_LOGOT0,
+  BFD_RELOC_860_SPGOT0,
+  BFD_RELOC_860_LOGOT1,
+  BFD_RELOC_860_SPGOT1,
+  BFD_RELOC_860_LOGOTOFF0,
+  BFD_RELOC_860_SPGOTOFF0,
+  BFD_RELOC_860_LOGOTOFF1,
+  BFD_RELOC_860_SPGOTOFF1,
+  BFD_RELOC_860_LOGOTOFF2,
+  BFD_RELOC_860_LOGOTOFF3,
+  BFD_RELOC_860_LOPC,
+  BFD_RELOC_860_HIGHADJ,
+  BFD_RELOC_860_HAGOT,
+  BFD_RELOC_860_HAGOTOFF,
+  BFD_RELOC_860_HAPC,
+  BFD_RELOC_860_HIGH,
+  BFD_RELOC_860_HIGOT,
+  BFD_RELOC_860_HIGOTOFF,
+
+/* OpenRISC Relocations. */
+  BFD_RELOC_OPENRISC_ABS_26,
+  BFD_RELOC_OPENRISC_REL_26,
+  BFD_RELOC_UNUSED };
+typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
+reloc_howto_type *
+bfd_reloc_type_lookup PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
+
+const char *
+bfd_get_reloc_code_name PARAMS ((bfd_reloc_code_real_type code));
+
+
+typedef struct symbol_cache_entry
+{
+       /* A pointer to the BFD which owns the symbol. This information
+          is necessary so that a back end can work out what additional
+          information (invisible to the application writer) is carried
+          with the symbol.
+
+          This field is *almost* redundant, since you can use section->owner
+          instead, except that some symbols point to the global sections
+          bfd_{abs,com,und}_section.  This could be fixed by making
+          these globals be per-bfd (or per-target-flavor).  FIXME. */
+
+  struct _bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field. */
+
+       /* The text of the symbol. The name is left alone, and not copied; the
+          application may not alter it. */
+  CONST char *name;
+
+       /* The value of the symbol.  This really should be a union of a
+          numeric value with a pointer, since some flags indicate that
+          a pointer to another symbol is stored here.  */
+  symvalue value;
+
+       /* Attributes of a symbol: */
+
+#define BSF_NO_FLAGS    0x00
+
+       /* The symbol has local scope; <<static>> in <<C>>. The value
+          is the offset into the section of the data. */
+#define BSF_LOCAL      0x01
+
+       /* The symbol has global scope; initialized data in <<C>>. The
+          value is the offset into the section of the data. */
+#define BSF_GLOBAL     0x02
+
+       /* The symbol has global scope and is exported. The value is
+          the offset into the section of the data. */
+#define BSF_EXPORT     BSF_GLOBAL /* no real difference */
+
+       /* A normal C symbol would be one of:
+          <<BSF_LOCAL>>, <<BSF_FORT_COMM>>,  <<BSF_UNDEFINED>> or
+          <<BSF_GLOBAL>> */
+
+       /* The symbol is a debugging record. The value has an arbitary
+          meaning, unless BSF_DEBUGGING_RELOC is also set.  */
+#define BSF_DEBUGGING  0x08
+
+       /* The symbol denotes a function entry point.  Used in ELF,
+          perhaps others someday.  */
+#define BSF_FUNCTION    0x10
+
+       /* Used by the linker. */
+#define BSF_KEEP        0x20
+#define BSF_KEEP_G      0x40
+
+       /* A weak global symbol, overridable without warnings by
+          a regular global symbol of the same name.  */
+#define BSF_WEAK        0x80
+
+       /* This symbol was created to point to a section, e.g. ELF's
+          STT_SECTION symbols.  */
+#define BSF_SECTION_SYM 0x100
+
+       /* The symbol used to be a common symbol, but now it is
+          allocated. */
+#define BSF_OLD_COMMON  0x200
+
+       /* The default value for common data. */
+#define BFD_FORT_COMM_DEFAULT_VALUE 0
+
+       /* In some files the type of a symbol sometimes alters its
+          location in an output file - ie in coff a <<ISFCN>> symbol
+          which is also <<C_EXT>> symbol appears where it was
+          declared and not at the end of a section.  This bit is set
+          by the target BFD part to convey this information. */
+
+#define BSF_NOT_AT_END    0x400
+
+       /* Signal that the symbol is the label of constructor section. */
+#define BSF_CONSTRUCTOR   0x800
+
+       /* Signal that the symbol is a warning symbol.  The name is a
+          warning.  The name of the next symbol is the one to warn about;
+          if a reference is made to a symbol with the same name as the next
+          symbol, a warning is issued by the linker. */
+#define BSF_WARNING       0x1000
+
+       /* Signal that the symbol is indirect.  This symbol is an indirect
+          pointer to the symbol with the same name as the next symbol. */
+#define BSF_INDIRECT      0x2000
+
+       /* BSF_FILE marks symbols that contain a file name.  This is used
+          for ELF STT_FILE symbols.  */
+#define BSF_FILE          0x4000
+
+       /* Symbol is from dynamic linking information.  */
+#define BSF_DYNAMIC       0x8000
+
+       /* The symbol denotes a data object.  Used in ELF, and perhaps
+          others someday.  */
+#define BSF_OBJECT        0x10000
+
+       /* This symbol is a debugging symbol.  The value is the offset
+          into the section of the data.  BSF_DEBUGGING should be set
+          as well.  */
+#define BSF_DEBUGGING_RELOC 0x20000
+
+  flagword flags;
+
+       /* A pointer to the section to which this symbol is
+          relative.  This will always be non NULL, there are special
+          sections for undefined and absolute symbols.  */
+  struct sec *section;
+
+       /* Back end special data.  */
+  union
+    {
+      PTR p;
+      bfd_vma i;
+    } udata;
+
+} asymbol;
+#define bfd_get_symtab_upper_bound(abfd) \
+     BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))
+boolean
+bfd_is_local_label PARAMS ((bfd *abfd, asymbol *sym));
+
+boolean
+bfd_is_local_label_name PARAMS ((bfd *abfd, const char *name));
+
+#define bfd_is_local_label_name(abfd, name) \
+     BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
+#define bfd_canonicalize_symtab(abfd, location) \
+     BFD_SEND (abfd, _bfd_canonicalize_symtab,\
+                  (abfd, location))
+boolean
+bfd_set_symtab PARAMS ((bfd *abfd, asymbol **location, unsigned int count));
+
+void
+bfd_print_symbol_vandf PARAMS ((PTR file, asymbol *symbol));
+
+#define bfd_make_empty_symbol(abfd) \
+     BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
+#define bfd_make_debug_symbol(abfd,ptr,size) \
+        BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
+int
+bfd_decode_symclass PARAMS ((asymbol *symbol));
+
+boolean
+bfd_is_undefined_symclass PARAMS ((int symclass));
+
+void
+bfd_symbol_info PARAMS ((asymbol *symbol, symbol_info *ret));
+
+boolean
+bfd_copy_private_symbol_data PARAMS ((bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym));
+
+#define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
+     BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
+               (ibfd, isymbol, obfd, osymbol))
+struct _bfd
+{
+    /* The filename the application opened the BFD with.  */
+    CONST char *filename;
+
+    /* A pointer to the target jump table.             */
+    const struct bfd_target *xvec;
+
+    /* To avoid dragging too many header files into every file that
+       includes `<<bfd.h>>', IOSTREAM has been declared as a "char
+       *", and MTIME as a "long".  Their correct types, to which they
+       are cast when used, are "FILE *" and "time_t".    The iostream
+       is the result of an fopen on the filename.  However, if the
+       BFD_IN_MEMORY flag is set, then iostream is actually a pointer
+       to a bfd_in_memory struct.  */
+    PTR iostream;
+
+    /* Is the file descriptor being cached?  That is, can it be closed as
+       needed, and re-opened when accessed later?  */
+
+    boolean cacheable;
+
+    /* Marks whether there was a default target specified when the
+       BFD was opened. This is used to select which matching algorithm
+       to use to choose the back end. */
+
+    boolean target_defaulted;
+
+    /* The caching routines use these to maintain a
+       least-recently-used list of BFDs */
+
+    struct _bfd *lru_prev, *lru_next;
+
+    /* When a file is closed by the caching routines, BFD retains
+       state information on the file here: */
+
+    file_ptr where;
+
+    /* and here: (``once'' means at least once) */
+
+    boolean opened_once;
+
+    /* Set if we have a locally maintained mtime value, rather than
+       getting it from the file each time: */
+
+    boolean mtime_set;
+
+    /* File modified time, if mtime_set is true: */
+
+    long mtime;
+
+    /* Reserved for an unimplemented file locking extension.*/
+
+    int ifd;
+
+    /* The format which belongs to the BFD. (object, core, etc.) */
+
+    bfd_format format;
+
+    /* The direction the BFD was opened with*/
+
+    enum bfd_direction {no_direction = 0,
+                        read_direction = 1,
+                        write_direction = 2,
+                        both_direction = 3} direction;
+
+    /* Format_specific flags*/
+
+    flagword flags;
+
+    /* Currently my_archive is tested before adding origin to
+       anything. I believe that this can become always an add of
+       origin, with origin set to 0 for non archive files.   */
+
+    file_ptr origin;
+
+    /* Remember when output has begun, to stop strange things
+       from happening. */
+    boolean output_has_begun;
+
+    /* Pointer to linked list of sections*/
+    struct sec  *sections;
+
+    /* The number of sections */
+    unsigned int section_count;
+
+    /* Stuff only useful for object files:
+       The start address. */
+    bfd_vma start_address;
+
+    /* Used for input and output*/
+    unsigned int symcount;
+
+    /* Symbol table for output BFD (with symcount entries) */
+    struct symbol_cache_entry  **outsymbols;
+
+    /* Pointer to structure which contains architecture information*/
+    const struct bfd_arch_info *arch_info;
+
+    /* Stuff only useful for archives:*/
+    PTR arelt_data;
+    struct _bfd *my_archive;     /* The containing archive BFD.  */
+    struct _bfd *next;           /* The next BFD in the archive.  */
+    struct _bfd *archive_head;   /* The first BFD in the archive.  */
+    boolean has_armap;
+
+    /* A chain of BFD structures involved in a link.  */
+    struct _bfd *link_next;
+
+    /* A field used by _bfd_generic_link_add_archive_symbols.  This will
+       be used only for archive elements.  */
+    int archive_pass;
+
+    /* Used by the back end to hold private data. */
+
+    union
+      {
+      struct aout_data_struct *aout_data;
+      struct artdata *aout_ar_data;
+      struct _oasys_data *oasys_obj_data;
+      struct _oasys_ar_data *oasys_ar_data;
+      struct coff_tdata *coff_obj_data;
+      struct pe_tdata *pe_obj_data;
+      struct xcoff_tdata *xcoff_obj_data;
+      struct ecoff_tdata *ecoff_obj_data;
+      struct ieee_data_struct *ieee_data;
+      struct ieee_ar_data_struct *ieee_ar_data;
+      struct srec_data_struct *srec_data;
+      struct ihex_data_struct *ihex_data;
+      struct tekhex_data_struct *tekhex_data;
+      struct elf_obj_tdata *elf_obj_data;
+      struct nlm_obj_tdata *nlm_obj_data;
+      struct bout_data_struct *bout_data;
+      struct sun_core_struct *sun_core_data;
+      struct sco5_core_struct *sco5_core_data;
+      struct trad_core_struct *trad_core_data;
+      struct som_data_struct *som_data;
+      struct hpux_core_struct *hpux_core_data;
+      struct hppabsd_core_struct *hppabsd_core_data;
+      struct sgi_core_struct *sgi_core_data;
+      struct lynx_core_struct *lynx_core_data;
+      struct osf_core_struct *osf_core_data;
+      struct cisco_core_struct *cisco_core_data;
+      struct versados_data_struct *versados_data;
+      struct netbsd_core_struct *netbsd_core_data;
+      PTR any;
+      } tdata;
+
+    /* Used by the application to hold private data*/
+    PTR usrdata;
+
+  /* Where all the allocated stuff under this BFD goes.  This is a
+     struct objalloc *, but we use PTR to avoid requiring the inclusion of
+     objalloc.h.  */
+    PTR memory;
+};
+
+typedef enum bfd_error
+{
+  bfd_error_no_error = 0,
+  bfd_error_system_call,
+  bfd_error_invalid_target,
+  bfd_error_wrong_format,
+  bfd_error_invalid_operation,
+  bfd_error_no_memory,
+  bfd_error_no_symbols,
+  bfd_error_no_armap,
+  bfd_error_no_more_archived_files,
+  bfd_error_malformed_archive,
+  bfd_error_file_not_recognized,
+  bfd_error_file_ambiguously_recognized,
+  bfd_error_no_contents,
+  bfd_error_nonrepresentable_section,
+  bfd_error_no_debug_section,
+  bfd_error_bad_value,
+  bfd_error_file_truncated,
+  bfd_error_file_too_big,
+  bfd_error_invalid_error_code
+} bfd_error_type;
+
+bfd_error_type
+bfd_get_error PARAMS ((void));
+
+void
+bfd_set_error PARAMS ((bfd_error_type error_tag));
+
+CONST char *
+bfd_errmsg PARAMS ((bfd_error_type error_tag));
+
+void
+bfd_perror PARAMS ((CONST char *message));
+
+typedef void (*bfd_error_handler_type) PARAMS ((const char *, ...));
+
+bfd_error_handler_type
+bfd_set_error_handler PARAMS ((bfd_error_handler_type));
+
+void
+bfd_set_error_program_name PARAMS ((const char *));
+
+bfd_error_handler_type
+bfd_get_error_handler PARAMS ((void));
+
+long
+bfd_get_reloc_upper_bound PARAMS ((bfd *abfd, asection *sect));
+
+long
+bfd_canonicalize_reloc PARAMS ((bfd *abfd,
+    asection *sec,
+    arelent **loc,
+    asymbol **syms));
+
+void
+bfd_set_reloc PARAMS ((bfd *abfd, asection *sec, arelent **rel, unsigned int count)
+    
+    );
+
+boolean
+bfd_set_file_flags PARAMS ((bfd *abfd, flagword flags));
+
+int
+bfd_get_arch_size PARAMS ((bfd *abfd));
+
+int
+bfd_get_sign_extend_vma PARAMS ((bfd *abfd));
+
+boolean
+bfd_set_start_address PARAMS ((bfd *abfd, bfd_vma vma));
+
+long
+bfd_get_mtime PARAMS ((bfd *abfd));
+
+long
+bfd_get_size PARAMS ((bfd *abfd));
+
+int
+bfd_get_gp_size PARAMS ((bfd *abfd));
+
+void
+bfd_set_gp_size PARAMS ((bfd *abfd, int i));
+
+bfd_vma
+bfd_scan_vma PARAMS ((CONST char *string, CONST char **end, int base));
+
+boolean
+bfd_copy_private_bfd_data PARAMS ((bfd *ibfd, bfd *obfd));
+
+#define bfd_copy_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
+               (ibfd, obfd))
+boolean
+bfd_merge_private_bfd_data PARAMS ((bfd *ibfd, bfd *obfd));
+
+#define bfd_merge_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
+               (ibfd, obfd))
+boolean
+bfd_set_private_flags PARAMS ((bfd *abfd, flagword flags));
+
+#define bfd_set_private_flags(abfd, flags) \
+     BFD_SEND (abfd, _bfd_set_private_flags, \
+               (abfd, flags))
+#define bfd_sizeof_headers(abfd, reloc) \
+     BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc))
+
+#define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
+     BFD_SEND (abfd, _bfd_find_nearest_line,  (abfd, sec, syms, off, file, func, line))
+
+       /* Do these three do anything useful at all, for any back end?  */
+#define bfd_debug_info_start(abfd) \
+        BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
+
+#define bfd_debug_info_end(abfd) \
+        BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
+
+#define bfd_debug_info_accumulate(abfd, section) \
+        BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
+
+
+#define bfd_stat_arch_elt(abfd, stat) \
+        BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
+
+#define bfd_update_armap_timestamp(abfd) \
+        BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
+
+#define bfd_set_arch_mach(abfd, arch, mach)\
+        BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
+
+#define bfd_relax_section(abfd, section, link_info, again) \
+       BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))
+
+#define bfd_gc_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))
+
+#define bfd_merge_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
+
+#define bfd_link_hash_table_create(abfd) \
+       BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
+
+#define bfd_link_add_symbols(abfd, info) \
+       BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
+
+#define bfd_final_link(abfd, info) \
+       BFD_SEND (abfd, _bfd_final_link, (abfd, info))
+
+#define bfd_free_cached_info(abfd) \
+       BFD_SEND (abfd, _bfd_free_cached_info, (abfd))
+
+#define bfd_get_dynamic_symtab_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
+
+#define bfd_print_private_bfd_data(abfd, file)\
+       BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
+
+#define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
+
+#define bfd_get_dynamic_reloc_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
+
+#define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
+
+extern bfd_byte *bfd_get_relocated_section_contents
+       PARAMS ((bfd *, struct bfd_link_info *,
+                 struct bfd_link_order *, bfd_byte *,
+                 boolean, asymbol **));
+
+symindex
+bfd_get_next_mapent PARAMS ((bfd *abfd, symindex previous, carsym **sym));
+
+boolean
+bfd_set_archive_head PARAMS ((bfd *output, bfd *new_head));
+
+bfd *
+bfd_openr_next_archived_file PARAMS ((bfd *archive, bfd *previous));
+
+CONST char *
+bfd_core_file_failing_command PARAMS ((bfd *abfd));
+
+int
+bfd_core_file_failing_signal PARAMS ((bfd *abfd));
+
+boolean
+core_file_matches_executable_p PARAMS ((bfd *core_bfd, bfd *exec_bfd));
+
+#define BFD_SEND(bfd, message, arglist) \
+               ((*((bfd)->xvec->message)) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND
+#define BFD_SEND(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+    ((*((bfd)->xvec->message)) arglist) : \
+    (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+#define BFD_SEND_FMT(bfd, message, arglist) \
+            (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND_FMT
+#define BFD_SEND_FMT(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
+   (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+enum bfd_flavour {
+  bfd_target_unknown_flavour,
+  bfd_target_aout_flavour,
+  bfd_target_coff_flavour,
+  bfd_target_ecoff_flavour,
+  bfd_target_xcoff_flavour,
+  bfd_target_elf_flavour,
+  bfd_target_ieee_flavour,
+  bfd_target_nlm_flavour,
+  bfd_target_oasys_flavour,
+  bfd_target_tekhex_flavour,
+  bfd_target_srec_flavour,
+  bfd_target_ihex_flavour,
+  bfd_target_som_flavour,
+  bfd_target_os9k_flavour,
+  bfd_target_versados_flavour,
+  bfd_target_msdos_flavour,
+  bfd_target_ovax_flavour,
+  bfd_target_evax_flavour
+};
+
+enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
+
+/* Forward declaration.  */
+typedef struct bfd_link_info _bfd_link_info;
+
+typedef struct bfd_target
+{
+  char *name;
+  enum bfd_flavour flavour;
+  enum bfd_endian byteorder;
+  enum bfd_endian header_byteorder;
+  flagword object_flags;
+  flagword section_flags;
+  char symbol_leading_char;
+  char ar_pad_char;
+  unsigned short ar_max_namelen;
+  bfd_vma      (*bfd_getx64) PARAMS ((const bfd_byte *));
+  bfd_signed_vma (*bfd_getx_signed_64) PARAMS ((const bfd_byte *));
+  void         (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
+  bfd_vma      (*bfd_getx32) PARAMS ((const bfd_byte *));
+  bfd_signed_vma (*bfd_getx_signed_32) PARAMS ((const bfd_byte *));
+  void         (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
+  bfd_vma      (*bfd_getx16) PARAMS ((const bfd_byte *));
+  bfd_signed_vma (*bfd_getx_signed_16) PARAMS ((const bfd_byte *));
+  void         (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));
+  bfd_vma      (*bfd_h_getx64) PARAMS ((const bfd_byte *));
+  bfd_signed_vma (*bfd_h_getx_signed_64) PARAMS ((const bfd_byte *));
+  void         (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
+  bfd_vma      (*bfd_h_getx32) PARAMS ((const bfd_byte *));
+  bfd_signed_vma (*bfd_h_getx_signed_32) PARAMS ((const bfd_byte *));
+  void         (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
+  bfd_vma      (*bfd_h_getx16) PARAMS ((const bfd_byte *));
+  bfd_signed_vma (*bfd_h_getx_signed_16) PARAMS ((const bfd_byte *));
+  void         (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
+  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) PARAMS ((bfd *));
+  boolean             (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));
+  boolean             (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));
+
+  /* Generic entry points.  */
+#define BFD_JUMP_TABLE_GENERIC(NAME)\
+CAT(NAME,_close_and_cleanup),\
+CAT(NAME,_bfd_free_cached_info),\
+CAT(NAME,_new_section_hook),\
+CAT(NAME,_get_section_contents),\
+CAT(NAME,_get_section_contents_in_window)
+
+  /* Called when the BFD is being closed to do any necessary cleanup.  */
+  boolean       (*_close_and_cleanup) PARAMS ((bfd *));
+  /* Ask the BFD to free all cached information.  */
+  boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
+  /* Called when a new section is created.  */
+  boolean       (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
+  /* Read the contents of a section.  */
+  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
+                                            file_ptr, bfd_size_type));
+  boolean       (*_bfd_get_section_contents_in_window)
+                          PARAMS ((bfd *, sec_ptr, bfd_window *,
+                                   file_ptr, bfd_size_type));
+
+  /* Entry points to copy private data.  */
+#define BFD_JUMP_TABLE_COPY(NAME)\
+CAT(NAME,_bfd_copy_private_bfd_data),\
+CAT(NAME,_bfd_merge_private_bfd_data),\
+CAT(NAME,_bfd_copy_private_section_data),\
+CAT(NAME,_bfd_copy_private_symbol_data),\
+CAT(NAME,_bfd_set_private_flags),\
+CAT(NAME,_bfd_print_private_bfd_data)\
+  /* Called to copy BFD general private data from one object file
+     to another.  */
+  boolean       (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
+  /* Called to merge BFD general private data from one object file
+     to a common output file when linking.  */
+  boolean       (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
+  /* Called to copy BFD private section data from one object file
+     to another.  */
+  boolean       (*_bfd_copy_private_section_data) PARAMS ((bfd *, sec_ptr,
+                                                       bfd *, sec_ptr));
+  /* Called to copy BFD private symbol data from one symbol
+     to another.  */
+  boolean       (*_bfd_copy_private_symbol_data) PARAMS ((bfd *, asymbol *,
+                                                          bfd *, asymbol *));
+  /* Called to set private backend flags */
+  boolean       (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
+
+  /* Called to print private BFD data */
+  boolean       (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
+
+  /* Core file entry points.  */
+#define BFD_JUMP_TABLE_CORE(NAME)\
+CAT(NAME,_core_file_failing_command),\
+CAT(NAME,_core_file_failing_signal),\
+CAT(NAME,_core_file_matches_executable_p)
+  char *   (*_core_file_failing_command) PARAMS ((bfd *));
+  int      (*_core_file_failing_signal) PARAMS ((bfd *));
+  boolean  (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
+
+  /* Archive entry points.  */
+#define BFD_JUMP_TABLE_ARCHIVE(NAME)\
+CAT(NAME,_slurp_armap),\
+CAT(NAME,_slurp_extended_name_table),\
+CAT(NAME,_construct_extended_name_table),\
+CAT(NAME,_truncate_arname),\
+CAT(NAME,_write_armap),\
+CAT(NAME,_read_ar_hdr),\
+CAT(NAME,_openr_next_archived_file),\
+CAT(NAME,_get_elt_at_index),\
+CAT(NAME,_generic_stat_arch_elt),\
+CAT(NAME,_update_armap_timestamp)
+  boolean  (*_bfd_slurp_armap) PARAMS ((bfd *));
+  boolean  (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
+  boolean  (*_bfd_construct_extended_name_table)
+             PARAMS ((bfd *, char **, bfd_size_type *, const char **));
+  void     (*_bfd_truncate_arname) PARAMS ((bfd *, CONST char *, char *));
+  boolean  (*write_armap) PARAMS ((bfd *arch,
+                              unsigned int elength,
+                              struct orl *map,
+                              unsigned int orl_count,
+                              int stridx));
+  PTR (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
+  bfd *    (*openr_next_archived_file) PARAMS ((bfd *arch, bfd *prev));
+#define bfd_get_elt_at_index(b,i) BFD_SEND(b, _bfd_get_elt_at_index, (b,i))
+  bfd *    (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
+  int      (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
+  boolean  (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
+
+  /* Entry points used for symbols.  */
+#define BFD_JUMP_TABLE_SYMBOLS(NAME)\
+CAT(NAME,_get_symtab_upper_bound),\
+CAT(NAME,_get_symtab),\
+CAT(NAME,_make_empty_symbol),\
+CAT(NAME,_print_symbol),\
+CAT(NAME,_get_symbol_info),\
+CAT(NAME,_bfd_is_local_label_name),\
+CAT(NAME,_get_lineno),\
+CAT(NAME,_find_nearest_line),\
+CAT(NAME,_bfd_make_debug_symbol),\
+CAT(NAME,_read_minisymbols),\
+CAT(NAME,_minisymbol_to_symbol)
+  long  (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
+  long  (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
+                                             struct symbol_cache_entry **));
+  struct symbol_cache_entry  *
+                (*_bfd_make_empty_symbol) PARAMS ((bfd *));
+  void          (*_bfd_print_symbol) PARAMS ((bfd *, PTR,
+                                      struct symbol_cache_entry *,
+                                      bfd_print_symbol_type));
+#define bfd_print_symbol(b,p,s,e) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e))
+  void          (*_bfd_get_symbol_info) PARAMS ((bfd *,
+                                      struct symbol_cache_entry *,
+                                      symbol_info *));
+#define bfd_get_symbol_info(b,p,e) BFD_SEND(b, _bfd_get_symbol_info, (b,p,e))
+  boolean       (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
+
+  alent *    (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
+  boolean    (*_bfd_find_nearest_line) PARAMS ((bfd *abfd,
+                    struct sec *section, struct symbol_cache_entry **symbols,
+                    bfd_vma offset, CONST char **file, CONST char **func,
+                    unsigned int *line));
+ /* Back-door to allow format-aware applications to create debug symbols
+    while using BFD for everything else.  Currently used by the assembler
+    when creating COFF files.  */
+  asymbol *  (*_bfd_make_debug_symbol) PARAMS ((
+       bfd *abfd,
+       void *ptr,
+       unsigned long size));
+#define bfd_read_minisymbols(b, d, m, s) \
+  BFD_SEND (b, _read_minisymbols, (b, d, m, s))
+  long  (*_read_minisymbols) PARAMS ((bfd *, boolean, PTR *,
+                                      unsigned int *));
+#define bfd_minisymbol_to_symbol(b, d, m, f) \
+  BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
+  asymbol *(*_minisymbol_to_symbol) PARAMS ((bfd *, boolean, const PTR,
+                                             asymbol *));
+
+  /* Routines for relocs.  */
+#define BFD_JUMP_TABLE_RELOCS(NAME)\
+CAT(NAME,_get_reloc_upper_bound),\
+CAT(NAME,_canonicalize_reloc),\
+CAT(NAME,_bfd_reloc_type_lookup)
+  long  (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
+  long  (*_bfd_canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **,
+                                            struct symbol_cache_entry **));
+  /* See documentation on reloc types.  */
+  reloc_howto_type *
+       (*reloc_type_lookup) PARAMS ((bfd *abfd,
+                                     bfd_reloc_code_real_type code));
+
+  /* Routines used when writing an object file.  */
+#define BFD_JUMP_TABLE_WRITE(NAME)\
+CAT(NAME,_set_arch_mach),\
+CAT(NAME,_set_section_contents)
+  boolean    (*_bfd_set_arch_mach) PARAMS ((bfd *, enum bfd_architecture,
+                    unsigned long));
+  boolean       (*_bfd_set_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
+                                            file_ptr, bfd_size_type));
+
+  /* Routines used by the linker.  */
+#define BFD_JUMP_TABLE_LINK(NAME)\
+CAT(NAME,_sizeof_headers),\
+CAT(NAME,_bfd_get_relocated_section_contents),\
+CAT(NAME,_bfd_relax_section),\
+CAT(NAME,_bfd_link_hash_table_create),\
+CAT(NAME,_bfd_link_add_symbols),\
+CAT(NAME,_bfd_final_link),\
+CAT(NAME,_bfd_link_split_section),\
+CAT(NAME,_bfd_gc_sections),\
+CAT(NAME,_bfd_merge_sections)
+  int        (*_bfd_sizeof_headers) PARAMS ((bfd *, boolean));
+  bfd_byte * (*_bfd_get_relocated_section_contents) PARAMS ((bfd *,
+                    struct bfd_link_info *, struct bfd_link_order *,
+                    bfd_byte *data, boolean relocateable,
+                    struct symbol_cache_entry **));
+
+  boolean    (*_bfd_relax_section) PARAMS ((bfd *, struct sec *,
+                    struct bfd_link_info *, boolean *again));
+
+  /* Create a hash table for the linker.  Different backends store
+     different information in this table.  */
+  struct bfd_link_hash_table *(*_bfd_link_hash_table_create) PARAMS ((bfd *));
+
+  /* Add symbols from this object file into the hash table.  */
+  boolean (*_bfd_link_add_symbols) PARAMS ((bfd *, struct bfd_link_info *));
+
+  /* Do a link based on the link_order structures attached to each
+     section of the BFD.  */
+  boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
+
+  /* Should this section be split up into smaller pieces during linking.  */
+  boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
+
+  /* Remove sections that are not referenced from the output.  */
+  boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
+
+  /* Attempt to merge SEC_MERGE sections.  */
+  boolean (*_bfd_merge_sections) PARAMS ((bfd *, struct bfd_link_info *));
+
+  /* Routines to handle dynamic symbols and relocs.  */
+#define BFD_JUMP_TABLE_DYNAMIC(NAME)\
+CAT(NAME,_get_dynamic_symtab_upper_bound),\
+CAT(NAME,_canonicalize_dynamic_symtab),\
+CAT(NAME,_get_dynamic_reloc_upper_bound),\
+CAT(NAME,_canonicalize_dynamic_reloc)
+  /* Get the amount of memory required to hold the dynamic symbols. */
+  long  (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
+  /* Read in the dynamic symbols.  */
+  long  (*_bfd_canonicalize_dynamic_symtab)
+    PARAMS ((bfd *, struct symbol_cache_entry **));
+  /* Get the amount of memory required to hold the dynamic relocs.  */
+  long  (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
+  /* Read in the dynamic relocs.  */
+  long  (*_bfd_canonicalize_dynamic_reloc)
+    PARAMS ((bfd *, arelent **, struct symbol_cache_entry **));
+
+ /* Opposite endian version of this target.  */
+ const struct bfd_target * alternative_target;
+
+ PTR backend_data;
+
+} bfd_target;
+boolean
+bfd_set_default_target PARAMS ((const char *name));
+
+const bfd_target *
+bfd_find_target PARAMS ((CONST char *target_name, bfd *abfd));
+
+const char **
+bfd_target_list PARAMS ((void));
+
+const bfd_target *
+bfd_search_for_target PARAMS ((int (* search_func) (const bfd_target *, void *), void *));
+
+boolean
+bfd_check_format PARAMS ((bfd *abfd, bfd_format format));
+
+boolean
+bfd_check_format_matches PARAMS ((bfd *abfd, bfd_format format, char ***matching));
+
+boolean
+bfd_set_format PARAMS ((bfd *abfd, bfd_format format));
+
+CONST char *
+bfd_format_string PARAMS ((bfd_format format));
+
+#ifdef __cplusplus
+}
+#endif
+#endif
Index: linux/include/asm-ia64/kdb.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-ia64/kdb.h	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,139 @@
+#ifndef _ASM_KDB_H
+#define _ASM_KDB_H
+
+/*
+ * Kernel Debugger Architecture Dependent Global Headers
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+/*
+ * KDB_ENTER() is a macro which causes entry into the kernel
+ * debugger from any point in the kernel code stream.  If it
+ * is intended to be used from interrupt level, it must use
+ * a non-maskable entry method.
+ */
+#include <asm/kdb_break.h>		/* break numbers are separated for CONFIG_KDB_LOCK */
+#define KDB_ENTER2(b)	asm("\tbreak "#b"\n")
+#define KDB_ENTER1(b)	KDB_ENTER2(b)
+#define KDB_ENTER()	do {if (kdb_on && !KDB_IS_RUNNING()) { KDB_ENTER1(KDB_BREAK_ENTER); }} while(0)
+
+	/*
+	 * Needed for exported symbols.
+	 */
+typedef unsigned long kdb_machreg_t;
+
+#define kdb_machreg_fmt		"0x%lx"
+#define kdb_machreg_fmt0	"0x%016lx"
+#define kdb_bfd_vma_fmt		"0x%lx"
+#define kdb_bfd_vma_fmt0	"0x%016lx"
+#define kdb_elfw_addr_fmt	"0x%lx"
+#define kdb_elfw_addr_fmt0	"0x%016lx"
+
+/*
+ * Functions to safely read and write kernel areas.  The {to,from}_xxx
+ * addresses are not necessarily valid, these functions must check for
+ * validity.  If the arch already supports get and put routines with
+ * suitable validation and/or recovery on invalid addresses then use
+ * those routines, otherwise check it yourself.
+ */
+
+/*
+ * asm-ia64 uaccess.h supplies __copy_to_user which relies on MMU to
+ * trap invalid addresses in the _xxx fields.  Verify the other address
+ * of the pair is valid by accessing the first and last byte ourselves,
+ * then any access violations should only be caused by the _xxx
+ * addresses,
+ */
+
+#include <asm/uaccess.h>
+
+static inline int
+__kdba_putarea_size(unsigned long to_xxx, void *from, size_t size)
+{
+	mm_segment_t oldfs = get_fs();
+	int r;
+	char c;
+	c = *((volatile char *)from);
+	c = *((volatile char *)from + size - 1);
+
+	if (to_xxx >> 61 <= 4) {
+		return kdb_putuserarea_size(to_xxx, from, size);
+	}
+
+#ifdef VPERNODE_BASE /* if present, the new CONFIG_NUMA code */
+	if (to_xxx >= VPERNODE_BASE && to_xxx < VGLOBAL_BASE) {
+		to_xxx = ia64_imva(to_xxx);
+	}
+#endif
+	set_fs(KERNEL_DS);
+	r = __copy_to_user((void *)to_xxx, from, size);
+	set_fs(oldfs);
+	return r;
+}
+
+static inline int
+__kdba_getarea_size(void *to, unsigned long from_xxx, size_t size)
+{
+	mm_segment_t oldfs = get_fs();
+	int r;
+	*((volatile char *)to) = '\0';
+	*((volatile char *)to + size - 1) = '\0';
+
+	if (from_xxx >> 61 <= 4) {
+		return kdb_getuserarea_size(to, from_xxx, size);
+	}
+
+	set_fs(KERNEL_DS);
+	switch (size) {
+	case 1:
+		r = __copy_to_user(to, (void *)from_xxx, 1);
+		break;
+	case 2:
+		r = __copy_to_user(to, (void *)from_xxx, 2);
+		break;
+	case 4:
+		r = __copy_to_user(to, (void *)from_xxx, 4);
+		break;
+	case 8:
+		r = __copy_to_user(to, (void *)from_xxx, 8);
+		break;
+	default:
+		r = __copy_to_user(to, (void *)from_xxx, size);
+		break;
+	}
+	set_fs(oldfs);
+	return r;
+}
+
+/* For numa with replicated code/data, the platform must supply its own
+ * kdba_putarea_size and kdba_getarea_size routines.  Without replication kdb
+ * uses the standard architecture routines.
+ */
+#ifdef CONFIG_NUMA_REPLICATE
+extern int kdba_putarea_size(unsigned long to_xxx, void *from, size_t size);
+extern int kdba_getarea_size(void *to, unsigned long from_xxx, size_t size);
+#else
+#define kdba_putarea_size __kdba_putarea_size
+#define kdba_getarea_size __kdba_getarea_size
+#endif
+
+static inline int
+kdba_verify_rw(unsigned long addr, size_t size)
+{
+	unsigned char data[size];
+	return(kdba_getarea_size(data, addr, size) || kdba_putarea_size(addr, data, size));
+}
+
+static inline unsigned long
+kdba_funcptr_value(void *fp)
+{
+	/* ia64 function descriptor, first word is address of code */
+	return *(unsigned long *)fp;
+}
+
+#endif	/* !_ASM_KDB_H */
Index: linux/include/asm-ia64/kdb_break.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-ia64/kdb_break.h	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,23 @@
+#ifndef _ASM_KDB_BREAK_H
+#define _ASM_KDB_BREAK_H
+
+/*
+ * Kernel Debugger Architecture Dependent Global Headers
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+/*
+ * Break numbers are used by CONFIG_KDB_LOCK code.  They need to be seperated
+ * from asm/kdb.h to let spinlock code build without pulling in all of the kdb
+ * headers.
+ */
+
+#define KDB_BREAK_BREAK 0x80100		/* kdb breakpoint in kernel */
+#define KDB_BREAK_ENTER 0x80101		/* KDB_ENTER() */
+
+#endif	/* !_ASM_KDB_BREAK_H */
Index: linux/include/asm-ia64/kdbprivate.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux/include/asm-ia64/kdbprivate.h	2005-01-20 11:12:36.000000000 +1100
@@ -0,0 +1,203 @@
+#ifndef _ASM_KDBPRIVATE_H
+#define _ASM_KDBPRIVATE_H
+
+/*
+ * Kernel Debugger Architecture Dependent Private Headers
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (c) 1999-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ */
+
+/* Definition of an machine instruction.
+ * Takes care of VLIW processors like Itanium
+ */
+
+typedef struct {
+	unsigned long inst[2];
+} kdb_machinst_t;
+
+/*
+ * KDB_MAXBPT describes the total number of breakpoints
+ * supported by this architecure.
+ */
+#define KDB_MAXBPT	16
+
+/*
+ * KDB_MAXHARDBPT describes the total number of hardware
+ * breakpoint registers that exist.
+ */
+#define KDB_MAXHARDBPT	 4
+
+/*
+ * Platform specific environment entries
+ */
+#define KDB_PLATFORM_ENV	"IDMODE=ia64", "BYTESPERWORD=4", "IDCOUNT=8"
+
+/*
+ * Define the direction that the stack grows
+ */
+#define KDB_STACK_DIRECTION	(-1)	/* Stack grows down */
+
+/*
+ * Support for IA64 debug registers
+ */
+typedef struct _kdbhard_bp {
+	kdb_machreg_t	bph_reg;	/* Register this breakpoint uses */
+
+	unsigned int	bph_free:1;	/* Register available for use */
+	unsigned int	bph_data:1;	/* Data Access breakpoint */
+
+	unsigned int	bph_write:1;	/* Write Data breakpoint */
+	unsigned int	bph_mode:2;	/* 0=inst, 1=write, 2=io, 3=read */
+	unsigned int	bph_length:2;	/* 0=1, 1=2, 2=BAD, 3=4 (bytes) */
+} kdbhard_bp_t;
+
+#define getprsregs(regs)        ((struct switch_stack *)regs -1)
+
+/* bkpt support using break inst instead of IBP reg */
+
+/*
+ * Define certain specific instructions
+ */
+#define BREAK_INSTR             (long)(KDB_BREAK_BREAK << (5+6))
+#define INST_SLOT0_MASK         (0x1ffffffffffL << 5)
+
+#define BKPTMODE_DATAR  3
+#define BKPTMODE_IO     2
+#define BKPTMODE_DATAW  1
+#define BKPTMODE_INST   0
+
+/* Some of the fault registers needed by kdb but not passed with
+ * regs or switch stack.
+ */
+typedef struct fault_regs {
+	unsigned long   isr ;
+	unsigned long   ifa ;
+	unsigned long   iim ;
+	unsigned long   itir ;
+} fault_regs_t ;
+
+#define KDB_HAVE_LONGJMP
+#ifdef KDB_HAVE_LONGJMP
+/*
+ * Support for setjmp/longjmp
+ */
+
+/* __jmp_buf definition copied from libc/sysdeps/unix/sysv/linux/ia64/bits/setjmp.h */
+
+#define _JBLEN  70
+
+typedef struct __kdb_jmp_buf {
+	unsigned long   __jmp_buf[_JBLEN];
+} kdb_jmp_buf __attribute__ ((aligned (16)));
+
+extern int kdba_setjmp(kdb_jmp_buf *);
+extern int kdba_setjmp_asm(kdb_jmp_buf *);
+extern void kdba_longjmp(kdb_jmp_buf *, int);
+extern void kdba_longjmp_asm(kdb_jmp_buf *, int);
+
+extern kdb_jmp_buf *kdbjmpbuf;
+#endif	/* KDB_HAVE_LONGJMP */
+
+/* Arch specific data saved for running processes */
+
+struct kdba_running_process {
+	struct switch_stack *sw;
+};
+
+static inline
+void kdba_save_running(struct kdba_running_process *k, struct pt_regs *regs)
+{
+	/* ia64 data is saved by unw_init_running() via kdba_main_loop() for
+	 * normal kdb entry and kdba_interrupt_switch_stack() for wierd
+	 * interrupt handlers.
+	 */
+}
+
+static inline
+void kdba_unsave_running(struct kdba_running_process *k, struct pt_regs *regs)
+{
+}
+
+/* kdba wrappers which want to save switch stack will call unw_init_running().
+ * That routine only takes a void* so pack the interrupt data into a structure.
+ */
+
+#include <linux/interrupt.h>	/* for irqreturn_t */
+
+struct kdba_sw_interrupt_data {
+	irqreturn_t (*handler)(int, void *, struct pt_regs *);
+	int irq;
+	void *arg;
+	struct pt_regs *regs;
+	irqreturn_t ret;
+};
+
+extern void kdba_sw_interrupt(struct unw_frame_info *, void *);
+
+/* Generate a wrapper function to create a switch_stack before
+ * entering an interrupt handler.
+ */
+
+#define KDBA_SW_INTERRUPT_WRAPPER3(name,before,after)		\
+irqreturn_t real_##name(int, void *, struct pt_regs *);		\
+irqreturn_t name(int irq, void *arg, struct pt_regs *regs)	\
+{								\
+	struct kdba_sw_interrupt_data id = {			\
+		.handler = &real_##name,			\
+		.irq = irq,					\
+		.arg = arg,					\
+		.regs = regs,					\
+		.ret = 0,					\
+	};							\
+	before;							\
+	unw_init_running(kdba_sw_interrupt, &id);		\
+	after;							\
+	return id.ret;						\
+}
+
+#define KDBA_SW_INTERRUPT_WRAPPER(name)				\
+	KDBA_SW_INTERRUPT_WRAPPER3(name,,)
+
+/* The kdba handlers that sit between wrapper -> unw_init_running -> real
+ * function are almost identical.  They differ in the function name, the
+ * type of data passed as void* to unw_init_running, the value to print
+ * in the debug statement and the invocation of the real function.
+ *
+ * data_type must be a structure that contains 'struct pt_regs *regs;'.
+ */
+
+#define KDBA_UNWIND_HANDLER(name, data_type, debug_value, invoke...)	\
+void name(struct unw_frame_info *info, void *vdata)			\
+{									\
+	data_type *data = vdata;					\
+	struct switch_stack *sw, *prev_sw;				\
+	struct pt_regs *prev_regs;					\
+	struct kdb_running_process *krp =				\
+		kdb_running_process + smp_processor_id();		\
+	KDB_DEBUG_STATE(__FUNCTION__, debug_value);			\
+	prev_sw = krp->arch.sw;						\
+	sw = (struct switch_stack *)(info+1);				\
+	/* padding from unw_init_running */				\
+	sw = (struct switch_stack *)(((unsigned long)sw + 15) & ~15);	\
+	krp->arch.sw = sw;						\
+	prev_regs = krp->regs;						\
+	kdb_save_running(data->regs);					\
+	invoke;								\
+	kdb_unsave_running(data->regs);					\
+	krp->regs = prev_regs;						\
+	krp->arch.sw = prev_sw;						\
+}
+
+enum kdba_serial_console {
+	KDBA_SC_NONE = 0,
+	KDBA_SC_STANDARD,
+	KDBA_SC_SGI_L1,
+};
+
+extern enum kdba_serial_console kdba_serial_console;
+
+#endif	/* !_ASM_KDBPRIVATE_H */
