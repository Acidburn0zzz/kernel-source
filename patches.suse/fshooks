--- /usr/src/linux-2.6.5-54/fs/intermezzo/vfs.c	2004-04-04 05:36:55.000000000 +0200
+++ 2.6.5-54-LAuS/fs/intermezzo/vfs.c	2004-04-16 10:09:26.000000000 +0200
@@ -824,7 +824,7 @@
                 struct dentry *new_dentry;
                 struct nameidata nd, old_nd;
 
-                error = __user_walk(oldname, 0, &old_nd);
+                error = __user_walk(oldname, 0, &old_nd, 0);
                 if (error)
                         goto exit;
                 error = path_lookup(to, LOOKUP_PARENT, &nd);
--- /usr/src/linux-2.6.5-54/fs/Makefile	2004-04-15 12:39:39.000000000 +0200
+++ 2.6.5-54-LAuS/fs/Makefile	2004-04-16 10:09:26.000000000 +0200
@@ -43,6 +43,8 @@
 obj-y				+= sysfs/
 obj-y				+= devpts/
 
+obj-$(CONFIG_FSHOOKS)		+= fshooks.o
+
 obj-$(CONFIG_PROFILING)		+= dcookies.o
  
 # Do not add any filesystems before this line
--- /usr/src/linux-2.6.5-54/fs/Kconfig	2004-04-15 12:39:39.000000000 +0200
+++ 2.6.5-54-LAuS/fs/Kconfig	2004-04-16 10:09:26.000000000 +0200
@@ -1820,3 +1820,9 @@
 
 endmenu
 
+
+config FSHOOKS
+	bool "File system hooks"
+	default y
+	help
+	  Provide capability to monitor file system activity
--- /usr/src/linux-2.6.5-54/fs/namei.c	2004-04-15 12:39:16.000000000 +0200
+++ 2.6.5-54-LAuS/fs/namei.c	2004-04-16 10:09:26.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/namei.h>
 #include <linux/quotaops.h>
 #include <linux/pagemap.h>
@@ -971,15 +972,18 @@
  * that namei follows links, while lnamei does not.
  * SMP-safe
  */
-int fastcall __user_walk(const char __user *name, unsigned flags, struct nameidata *nd)
+int fastcall __user_walk(const char __user *name, unsigned flags, struct nameidata *nd, const char **pname)
 {
 	char *tmp = getname(name);
 	int err = PTR_ERR(tmp);
 
 	if (!IS_ERR(tmp)) {
 		err = path_lookup(tmp, flags, nd);
-		putname(tmp);
+		if (!pname)
+			putname(tmp);
 	}
+	if (pname)
+		*pname = tmp;
 	return err;
 }
 
@@ -1467,6 +1471,8 @@
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
 
+	FSHOOK_BEGIN(mknod, error, .path = tmp, .mode = mode, .dev = dev)
+
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
@@ -1500,6 +1506,8 @@
 out:
 	putname(tmp);
 
+	FSHOOK_END(mknod, error)
+
 	return error;
 }
 
@@ -1535,6 +1543,9 @@
 	tmp = getname(pathname);
 	error = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(mkdir, error, .dirname = tmp, .mode = mode)
+
 		struct dentry *dentry;
 		struct nameidata nd;
 
@@ -1552,6 +1563,9 @@
 		up(&nd.dentry->d_inode->i_sem);
 		path_release(&nd);
 out:
+
+		FSHOOK_END(mkdir, error)
+
 		putname(tmp);
 	}
 
@@ -1635,6 +1649,8 @@
 	if(IS_ERR(name))
 		return PTR_ERR(name);
 
+	FSHOOK_BEGIN(rmdir, error, .dirname = name)
+
 	error = path_lookup(name, LOOKUP_PARENT, &nd);
 	if (error)
 		goto exit;
@@ -1661,6 +1677,9 @@
 exit1:
 	path_release(&nd);
 exit:
+
+	FSHOOK_END(rmdir, error)
+
 	putname(name);
 	return error;
 }
@@ -1713,6 +1732,8 @@
 	if(IS_ERR(name))
 		return PTR_ERR(name);
 
+	FSHOOK_BEGIN(unlink, error, .filename = name)
+
 	error = path_lookup(name, LOOKUP_PARENT, &nd);
 	if (error)
 		goto exit;
@@ -1737,6 +1758,9 @@
 exit1:
 	path_release(&nd);
 exit:
+
+	FSHOOK_END(unlink, error)
+
 	putname(name);
 
 	if (inode)
@@ -1784,6 +1808,9 @@
 	to = getname(newname);
 	error = PTR_ERR(to);
 	if (!IS_ERR(to)) {
+
+		FSHOOK_BEGIN(symlink, error, .oldpath = from, .newpath = to)
+
 		struct dentry *dentry;
 		struct nameidata nd;
 
@@ -1799,6 +1826,9 @@
 		up(&nd.dentry->d_inode->i_sem);
 		path_release(&nd);
 out:
+
+		FSHOOK_END(symlink, error)
+
 		putname(to);
 	}
 	putname(from);
@@ -1865,9 +1895,13 @@
 	if (IS_ERR(to))
 		return PTR_ERR(to);
 
-	error = __user_walk(oldname, 0, &old_nd);
-	if (error)
-		goto exit;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(link,
+		error,
+		oldname,
+		old_nd,
+		oldpath,
+		.newpath = to)
+
 	error = path_lookup(to, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
@@ -1885,7 +1919,9 @@
 	path_release(&nd);
 out:
 	path_release(&old_nd);
-exit:
+
+	FSHOOK_END_USER_WALK(link, error, oldpath)
+
 	putname(to);
 
 	return error;
@@ -2127,7 +2163,13 @@
 	to = getname(newname);
 	error = PTR_ERR(to);
 	if (!IS_ERR(to)) {
+
+		FSHOOK_BEGIN(rename, error, .oldpath = from, .newpath = to)
+
 		error = do_rename(from,to);
+
+		FSHOOK_END(rename, error)
+
 		putname(to);
 	}
 	putname(from);
--- /usr/src/linux-2.6.5-54/fs/compat.c	2004-04-04 05:37:06.000000000 +0200
+++ 2.6.5-54-LAuS/fs/compat.c	2004-04-16 10:34:22.000000000 +0200
@@ -20,6 +20,7 @@
 #include <linux/errno.h>
 #include <linux/time.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/fcntl.h>
 #include <linux/namei.h>
 #include <linux/file.h>
@@ -142,14 +144,16 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(path, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(statfs, error, path, nd, path)
+
 		struct kstatfs tmp;
 		error = vfs_statfs(nd.dentry->d_inode->i_sb, &tmp);
 		if (!error && put_compat_statfs(buf, &tmp))
 			error = -EFAULT;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(statfs, error, path)
+
 	return error;
 }
 
@@ -159,6 +163,8 @@
 	struct kstatfs tmp;
 	int error;
 
+	FSHOOK_BEGIN(fstatfs, error, .fd = fd)
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -168,6 +174,9 @@
 		error = -EFAULT;
 	fput(file);
 out:
+
+	FSHOOK_END(fstatfs, error)
+
 	return error;
 }
 
@@ -203,14 +212,16 @@
 	if (sz != sizeof(*buf))
 		return -EINVAL;
 
-	error = user_path_walk(path, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(statfs, error, path, nd, path)
+
 		struct kstatfs tmp;
 		error = vfs_statfs(nd.dentry->d_inode->i_sb, &tmp);
 		if (!error && put_compat_statfs64(buf, &tmp))
 			error = -EFAULT;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(statfs, error, path)
+
 	return error;
 }
 
@@ -223,6 +234,8 @@
 	if (sz != sizeof(*buf))
 		return -EINVAL;
 
+	FSHOOK_BEGIN(fstatfs, error, .fd = fd)
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -232,6 +245,9 @@
 		error = -EFAULT;
 	fput(file);
 out:
+
+	FSHOOK_END(fstatfs, error)
+
 	return error;
 }
 
@@ -778,11 +798,21 @@
 		}
 	}
 
+	FSHOOK_BEGIN(mount,
+		retval,
+		.devname = (char *)dev_page,
+		.dirname = dir_page,
+		.type = (char *)type_page,
+		.flags = flags,
+		.data = (void *)data_page)
+
 	lock_kernel();
 	retval = do_mount((char*)dev_page, dir_page, (char*)type_page,
 			flags, (void*)data_page);
 	unlock_kernel();
 
+	FSHOOK_END(mount, retval)
+
 	free_page(data_page);
  out3:
 	free_page(dev_page);
--- /usr/src/linux-2.6.5-54/fs/exec.c	2004-04-15 12:39:40.000000000 +0200
+++ 2.6.5-54-LAuS/fs/exec.c	2004-04-16 10:34:22.000000000 +0200
@@ -43,6 +43,7 @@
 #include <linux/proc_fs.h>
 #include <linux/ptrace.h>
 #include <linux/mount.h>
+#include <linux/fshooks.h>
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/objrmap.h>
@@ -124,17 +126,23 @@
 	int error;
 
 	nd.intent.open.flags = FMODE_READ;
-	error = __user_walk(library, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
-	if (error)
-		goto out;
 
-	error = -EINVAL;
-	if (!S_ISREG(nd.dentry->d_inode->i_mode))
-		goto exit;
+	FSHOOK_BEGIN_USER_WALK(open,
+		error,
+		library,
+		LOOKUP_FOLLOW|LOOKUP_OPEN,
+		nd,
+		filename,
+		.flags = O_RDONLY)
 
-	error = permission(nd.dentry->d_inode, MAY_READ | MAY_EXEC, &nd);
-	if (error)
-		goto exit;
+	if (!S_ISREG(nd.dentry->d_inode->i_mode))
+		error = -EINVAL;
+	else
+		error = permission(nd.dentry->d_inode, MAY_READ | MAY_EXEC, &nd);
+	if (error) {
+		path_release(&nd);
+		goto out;
+	}
 
 	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
 	error = PTR_ERR(file);
@@ -162,10 +170,10 @@
 	}
 	fput(file);
 out:
+
+	FSHOOK_END_USER_WALK(open, error, filename)
+
   	return error;
-exit:
-	path_release(&nd);
-	goto out;
 }
 
 /*
@@ -485,6 +493,8 @@
 	int err;
 	struct file *file;
 
+	FSHOOK_BEGIN(open, err, .filename = name, .flags = O_RDONLY)
+
 	nd.intent.open.flags = FMODE_READ;
 	err = path_lookup(name, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
 	file = ERR_PTR(err);
@@ -507,13 +517,16 @@
 						file = ERR_PTR(err);
 					}
 				}
-out:
-				return file;
+				goto out;
 			}
 		}
 		path_release(&nd);
 	}
-	goto out;
+out:
+
+	FSHOOK_END(open, err, file = ERR_PTR(err))
+
+	return file;
 }
 
 EXPORT_SYMBOL(open_exec);
--- /usr/src/linux-2.6.5-54/fs/open.c	2004-04-15 12:39:38.000000000 +0200
+++ 2.6.5-54-LAuS/fs/open.c	2004-04-16 10:14:12.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/vfs.h>
 #include <asm/uaccess.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/pagemap.h>
 
 int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
@@ -117,14 +118,16 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(path, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(statfs, error, path, nd, path)
+
 		struct statfs tmp;
 		error = vfs_statfs_native(nd.dentry->d_inode->i_sb, &tmp);
 		if (!error && copy_to_user(buf, &tmp, sizeof(tmp)))
 			error = -EFAULT;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(statfs, error, path)
+
 	return error;
 }
 
@@ -136,14 +139,17 @@
 
 	if (sz != sizeof(*buf))
 		return -EINVAL;
-	error = user_path_walk(path, &nd);
-	if (!error) {
+
+	FSHOOK_BEGIN_USER_PATH_WALK(statfs, error, path, nd, path)
+
 		struct statfs64 tmp;
 		error = vfs_statfs64(nd.dentry->d_inode->i_sb, &tmp);
 		if (!error && copy_to_user(buf, &tmp, sizeof(tmp)))
 			error = -EFAULT;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(statfs, error, path)
+
 	return error;
 }
 
@@ -154,6 +160,8 @@
 	struct statfs tmp;
 	int error;
 
+	FSHOOK_BEGIN(fstatfs, error, .fd = fd)
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -163,6 +171,9 @@
 		error = -EFAULT;
 	fput(file);
 out:
+
+	FSHOOK_END(fstatfs, error)
+
 	return error;
 }
 
@@ -172,6 +183,8 @@
 	struct statfs64 tmp;
 	int error;
 
+	FSHOOK_BEGIN(fstatfs, error, .fd = fd)
+
 	if (sz != sizeof(*buf))
 		return -EINVAL;
 
@@ -184,6 +197,9 @@
 		error = -EFAULT;
 	fput(file);
 out:
+
+	FSHOOK_END(fstatfs, error)
+
 	return error;
 }
 
@@ -216,9 +232,8 @@
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_PATH_WALK(truncate, error, path, nd, filename, .length = length)
+
 	inode = nd.dentry->d_inode;
 
 	/* For directories it's -EISDIR, for other non-regulars - -EINVAL */
@@ -262,6 +277,9 @@
 
 dput_and_out:
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(truncate, error, filename)
+
 out:
 	return error;
 }
@@ -279,6 +297,8 @@
 	struct file * file;
 	int error;
 
+	FSHOOK_BEGIN(ftruncate, error, .fd = fd, .length = length)
+
 	error = -EINVAL;
 	if (length < 0)
 		goto out;
@@ -312,6 +332,9 @@
 out_putf:
 	fput(file);
 out:
+
+	FSHOOK_END(ftruncate, error);
+
 	return error;
 }
 
@@ -333,29 +356,25 @@
 }
 #endif
 
-#if !(defined(__alpha__) || defined(__ia64__))
-
-/*
- * sys_utime() can be implemented in user-level using sys_utimes().
- * Is this for backwards compatibility?  If so, why not move it
- * into the appropriate arch directory (for those architectures that
- * need it).
- */
-
 /* If times==NULL, set access and modification to current time,
  * must be owner or have write permission.
  * Else, update from *times, must be owner or super user.
  */
-asmlinkage long sys_utime(char __user * filename, struct utimbuf __user * times)
+long do_utimes(char __user * filename, struct timeval * times)
 {
 	int error;
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_PATH_WALK(utimes,
+		error,
+		filename,
+		nd,
+		path,
+		.atime = times,
+		.mtime = times + !!times)
+
 	inode = nd.dentry->d_inode;
 
 	error = -EROFS;
@@ -366,20 +385,16 @@
 	newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
 	if (times) {
 		error = -EPERM;
-		if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-			goto dput_and_out;
-
-		error = get_user(newattrs.ia_atime.tv_sec, &times->actime);
-		newattrs.ia_atime.tv_nsec = 0;
-		if (!error) 
-			error = get_user(newattrs.ia_mtime.tv_sec, &times->modtime);
-		newattrs.ia_mtime.tv_nsec = 0;
-		if (error)
-			goto dput_and_out;
+                if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+                        goto dput_and_out;
 
+		newattrs.ia_atime.tv_sec = times[0].tv_sec;
+		newattrs.ia_atime.tv_nsec = times[0].tv_usec * 1000;
+		newattrs.ia_mtime.tv_sec = times[1].tv_sec;
+		newattrs.ia_mtime.tv_nsec = times[1].tv_usec * 1000;
 		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
 	} else {
-                error = -EACCES;
+		error = -EACCES;
                 if (IS_IMMUTABLE(inode))
                         goto dput_and_out;
 
@@ -392,63 +407,44 @@
 	up(&inode->i_sem);
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(utimes, error, path)
+
 	return error;
 }
 
-#endif
+#if !(defined(__alpha__) || defined(__ia64__))
+
+/*
+ * sys_utime() can be implemented in user-level using sys_utimes().
+ * Is this for backwards compatibility?  If so, why not move it
+ * into the appropriate arch directory (for those architectures that
+ * need it).
+ */
 
 /* If times==NULL, set access and modification to current time,
  * must be owner or have write permission.
  * Else, update from *times, must be owner or super user.
  */
-long do_utimes(char __user * filename, struct timeval * times)
+asmlinkage long sys_utime(char __user * filename, struct utimbuf __user * utime)
 {
-	int error;
-	struct nameidata nd;
-	struct inode * inode;
-	struct iattr newattrs;
-
-	error = user_path_walk(filename, &nd);
-
-	if (error)
-		goto out;
-	inode = nd.dentry->d_inode;
-
-	error = -EROFS;
-	if (IS_RDONLY(inode))
-		goto dput_and_out;
-
-	/* Don't worry, the checks are done in inode_change_ok() */
-	newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
-	if (times) {
-		error = -EPERM;
-                if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-                        goto dput_and_out;
+	struct timeval times[2];
 
-		newattrs.ia_atime.tv_sec = times[0].tv_sec;
-		newattrs.ia_atime.tv_nsec = times[0].tv_usec * 1000;
-		newattrs.ia_mtime.tv_sec = times[1].tv_sec;
-		newattrs.ia_mtime.tv_nsec = times[1].tv_usec * 1000;
-		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
-	} else {
-		error = -EACCES;
-                if (IS_IMMUTABLE(inode))
-                        goto dput_and_out;
+	if (utime) {
+		struct utimbuf ktime;
 
-		if (current->fsuid != inode->i_uid &&
-		    (error = permission(inode,MAY_WRITE,&nd)) != 0)
-			goto dput_and_out;
+		if (copy_from_user(&ktime, utime, sizeof(ktime)))
+			return -EFAULT;
+		times[0].tv_sec = ktime.actime;
+		times[0].tv_usec = 0;
+		times[1].tv_sec = ktime.modtime;
+		times[1].tv_usec = 0;
 	}
-	down(&inode->i_sem);
-	error = notify_change(nd.dentry, &newattrs);
-	up(&inode->i_sem);
-dput_and_out:
-	path_release(&nd);
-out:
-	return error;
+	return do_utimes(filename, utime ? times : NULL);
 }
 
+#endif
+
 asmlinkage long sys_utimes(char __user * filename, struct timeval __user * utimes)
 {
 	struct timeval times[2];
@@ -494,15 +490,22 @@
 	else
 		current->cap_effective = current->cap_permitted;
 
-	res = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_ACCESS, &nd);
-	if (!res) {
+	FSHOOK_BEGIN_USER_WALK(access,
+		res,
+		filename,
+		LOOKUP_FOLLOW|LOOKUP_ACCESS,
+		nd,
+		path,
+		.mode = mode)
+
 		res = permission(nd.dentry->d_inode, mode, &nd);
 		/* SuS v2 requires we report a read only fs too */
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(access, res, path)
 
 	current->fsuid = old_fsuid;
 	current->fsgid = old_fsgid;
@@ -516,9 +519,12 @@
 	struct nameidata nd;
 	int error;
 
-	error = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_WALK(chdir,
+		error,
+		filename,
+		LOOKUP_FOLLOW|LOOKUP_DIRECTORY,
+		nd,
+		dirname)
 
 	error = permission(nd.dentry->d_inode,MAY_EXEC,&nd);
 	if (error)
@@ -528,7 +534,9 @@
 
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(chdir, error, dirname)
+
 	return error;
 }
 
@@ -540,6 +548,8 @@
 	struct vfsmount *mnt;
 	int error;
 
+	FSHOOK_BEGIN(fchdir, error, .fd = fd)
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -559,6 +569,9 @@
 out_putf:
 	fput(file);
 out:
+
+	FSHOOK_END(fchdir, error)
+
 	return error;
 }
 
@@ -567,9 +580,12 @@
 	struct nameidata nd;
 	int error;
 
-	error = __user_walk(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_WALK(chroot,
+		error,
+		filename,
+		LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT,
+		nd,
+		path)
 
 	error = permission(nd.dentry->d_inode,MAY_EXEC,&nd);
 	if (error)
@@ -584,7 +600,9 @@
 	error = 0;
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(chroot, error, path)
+
 	return error;
 }
 
@@ -593,9 +611,12 @@
 	struct inode * inode;
 	struct dentry * dentry;
 	struct file * file;
-	int err = -EBADF;
+	int err;
 	struct iattr newattrs;
 
+	FSHOOK_BEGIN(fchmod, err, .fd = fd, .mode = mode)
+
+	err = -EBADF;
 	file = fget(fd);
 	if (!file)
 		goto out;
@@ -620,6 +641,9 @@
 out_putf:
 	fput(file);
 out:
+
+	FSHOOK_END(fchmod, err)
+
 	return err;
 }
 
@@ -630,9 +654,14 @@
 	int error;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_PATH_WALK(chmod,
+		error,
+		filename,
+		nd,
+		path,
+		.mode = mode,
+		.link = false)
+
 	inode = nd.dentry->d_inode;
 
 	error = -EROFS;
@@ -653,7 +682,9 @@
 
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(chmod, error, path)
+
 	return error;
 }
 
@@ -697,11 +728,20 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(filename, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(chown,
+		error,
+		filename,
+		nd,
+		path,
+		.uid = user,
+		.gid = group,
+		.link = false)
+
 		error = chown_common(nd.dentry, user, group);
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(chown, error, path)
+
 	return error;
 }
 
@@ -710,11 +750,20 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk_link(filename, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(chown,
+		error,
+		filename,
+		nd,
+		path,
+		.uid = user,
+		.gid = group,
+		.link = true)
+
 		error = chown_common(nd.dentry, user, group);
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(chown, error, path)
+
 	return error;
 }
 
@@ -722,13 +771,19 @@
 asmlinkage long sys_fchown(unsigned int fd, uid_t user, gid_t group)
 {
 	struct file * file;
-	int error = -EBADF;
+	int error;
+
+	FSHOOK_BEGIN(fchown, error, .fd = fd, .uid = user, .gid = group)
 
+	error = -EBADF;
 	file = fget(fd);
 	if (file) {
 		error = chown_common(file->f_dentry, user, group);
 		fput(file);
 	}
+
+	FSHOOK_END(fchown, error)
+
 	return error;
 }
 
@@ -937,7 +992,7 @@
 asmlinkage long sys_open(const char __user * filename, int flags, int mode)
 {
 	char * tmp;
-	int fd, error;
+	int fd;
 
 #if BITS_PER_LONG != 32
 	flags |= O_LARGEFILE;
@@ -945,23 +1000,26 @@
 	tmp = getname(filename);
 	fd = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(open, fd, .filename = tmp, .flags = flags, .mode = mode)
+
 		fd = get_unused_fd();
 		if (fd >= 0) {
 			struct file *f = filp_open(tmp, flags, mode);
-			error = PTR_ERR(f);
-			if (IS_ERR(f))
-				goto out_error;
-			fd_install(fd, f);
+
+			if (!IS_ERR(f))
+				fd_install(fd, f);
+			else {
+				put_unused_fd(fd);
+				fd = PTR_ERR(f);
+			}
 		}
-out:
+
+		FSHOOK_END(open, fd)
+
 		putname(tmp);
 	}
 	return fd;
-
-out_error:
-	put_unused_fd(fd);
-	fd = error;
-	goto out;
 }
 EXPORT_SYMBOL_GPL(sys_open);
 
@@ -1017,24 +1075,30 @@
  */
 asmlinkage long sys_close(unsigned int fd)
 {
-	struct file * filp;
+	struct file * filp = NULL;
 	struct files_struct *files = current->files;
+	int error;
 
+	FSHOOK_BEGIN(close, error, .fd = fd)
+
+	error = -EBADF;
 	spin_lock(&files->file_lock);
-	if (fd >= files->max_fds)
-		goto out_unlock;
-	filp = files->fd[fd];
-	if (!filp)
-		goto out_unlock;
-	files->fd[fd] = NULL;
-	FD_CLR(fd, files->close_on_exec);
-	__put_unused_fd(files, fd);
+	if (fd < files->max_fds) {
+		filp = files->fd[fd];
+		if (filp) {
+			files->fd[fd] = NULL;
+			FD_CLR(fd, files->close_on_exec);
+			__put_unused_fd(files, fd);
+			error = 0;
+		}
+	}
 	spin_unlock(&files->file_lock);
-	return filp_close(filp, files);
+	if (!error)
+		error = filp_close(filp, files);
 
-out_unlock:
-	spin_unlock(&files->file_lock);
-	return -EBADF;
+	FSHOOK_END(close, error)
+
+	return error;
 }
 
 EXPORT_SYMBOL(sys_close);
--- /usr/src/linux-2.6.5-54/fs/fshooks.c	1970-01-01 01:00:00.000000000 +0100
+++ 2.6.5-54-LAuS/fs/fshooks.c	2004-03-09 12:30:42.000000000 +0100
@@ -0,0 +1,143 @@
+/*
+ * fs/fs-writeback.c
+ *
+ * Copyright (C) 2004, Novell, Inc.
+ *
+ * Contains all the fshooks support functions.
+ *
+ */
+
+#include <linux/fshooks.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+
+struct fshook_list fshooks[fshook_COUNT];
+static int initialized;
+
+int fshook_register(enum FShook type, fshook_pre_t *pre, fshook_post_t *post, void *ctx)
+{
+	struct fshook *hook;
+
+	if (unlikely(type < 0 || type >= fshook_COUNT || (!pre && !post)))
+		return -EINVAL;
+	if (unlikely(!initialized))
+		return -EPERM;
+	hook = kmalloc(sizeof(*hook), GFP_KERNEL);
+	if (unlikely(!hook))
+		return -ENOMEM;
+	hook->next = NULL;
+	hook->pre = pre;
+	hook->post = post;
+	hook->ctx = ctx;
+	down_write(&fshooks[type].lock);
+	if (fshooks[type].last)
+		fshooks[type].last->next = hook;
+	else
+		fshooks[type].first = hook;
+	fshooks[type].last = hook;
+	mb();
+	up_write(&fshooks[type].lock);
+	return 0;
+}
+
+EXPORT_SYMBOL(fshook_register);
+
+int fshook_deregister(enum FShook type, fshook_pre_t *pre, fshook_post_t *post, void *ctx)
+{
+	struct fshook *hook, *prev;
+
+	if (unlikely(type < 0 || type >= fshook_COUNT || (!pre && !post)))
+		return -EINVAL;
+	if (unlikely(!initialized))
+		return -EPERM;
+	if (unlikely(!fshooks[type].first))
+		return -ENOENT;
+	down_write(&fshooks[type].lock);
+	for (hook = fshooks[type].first, prev = NULL; hook; hook = (prev = hook)->next) {
+		if (ctx == hook->ctx
+		    && (!pre || !hook->pre || pre == hook->pre)
+		    && (!post || !hook->post || post == hook->post)) {
+			if (pre == hook->pre)
+				hook->pre = NULL;
+			if (post == hook->post)
+				hook->post = NULL;
+			if (!hook->pre && !hook->post) {
+				if (prev)
+					prev->next = hook->next;
+				else
+					fshooks[type].first = hook->next;
+				if (hook == fshooks[type].last)
+					fshooks[type].last = prev;
+			}
+			else
+				prev = hook;
+			break;
+		}
+	}
+	mb();
+	up_write(&fshooks[type].lock);
+	if (unlikely(!hook))
+		return -ENOENT;
+	if (prev != hook)
+		kfree(hook);
+	return 0;
+}
+
+EXPORT_SYMBOL(fshook_deregister);
+
+member_type(struct fshook_generic_info, result) fshook_run_pre(enum FShook type, fshook_info_t info)
+{
+	if (unlikely(type >= fshook_COUNT))
+		BUG();
+	if (fshooks[type].first) {
+		struct fshook_generic_info *gen = (struct fshook_generic_info *)info.gen;
+		const struct fshook *hook;
+
+		gen->type = type;
+		gen->result = 0;
+		down_read(&fshooks[type].lock);
+		for (hook = fshooks[type].first; hook; hook = hook->next) {
+			if (hook->pre) {
+				int err = hook->pre(info, hook->ctx);
+
+				if (!gen->result && err) {
+					gen->result = -abs(err);
+					if (unlikely(!IS_ERR(ERR_PTR(gen->result))))
+						BUG();
+				}
+			}
+		}
+		up_read(&fshooks[type].lock);
+		return info.gen->result;
+	}
+	return 0;
+}
+
+void fshook_run_post(fshook_info_t info, member_type(struct fshook_generic_info, result) result)
+{
+	if (fshooks[info.gen->type].first) {
+		struct fshook_generic_info *gen = (struct fshook_generic_info *)info.gen;
+		const struct fshook *hook;
+
+		gen->result = result;
+		down_read(&fshooks[gen->type].lock);
+		for (hook = fshooks[gen->type].first; hook; hook = hook->next) {
+			if (hook->post)
+				hook->post(info, hook->ctx);
+		}
+		up_read(&fshooks[gen->type].lock);
+	}
+}
+
+#include <linux/init.h>
+
+void __init fshooks_init(void)
+{
+	enum FShook type;
+
+	for (type = 0; type < fshook_COUNT; ++type) {
+		init_rwsem(&fshooks[type].lock);
+	}
+	initialized = 1;
+}
--- /usr/src/linux-2.6.5-54/fs/stat.c	2004-04-04 05:36:26.000000000 +0200
+++ 2.6.5-54-LAuS/fs/stat.c	2004-04-16 10:09:26.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/smp_lock.h>
 #include <linux/highuid.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/namei.h>
 #include <linux/security.h>
 
@@ -66,11 +67,13 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(name, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(stat, error, name, nd, path, .link = false)
+
 		error = vfs_getattr(nd.mnt, nd.dentry, stat);
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(stat, error, path)
+
 	return error;
 }
 
@@ -81,11 +84,13 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk_link(name, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(stat, error, name, nd, path, .link = true)
+
 		error = vfs_getattr(nd.mnt, nd.dentry, stat);
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(stat, error, path)
+
 	return error;
 }
 
@@ -93,13 +98,20 @@
 
 int vfs_fstat(unsigned int fd, struct kstat *stat)
 {
+	int error;
+
+	FSHOOK_BEGIN(fstat, error, .fd = fd)
+
 	struct file *f = fget(fd);
-	int error = -EBADF;
 
+	error = -EBADF;
 	if (f) {
 		error = vfs_getattr(f->f_vfsmnt, f->f_dentry, stat);
 		fput(f);
 	}
+
+	FSHOOK_END(fstat, error)	
+
 	return error;
 }
 
@@ -264,8 +276,8 @@
 	if (bufsiz <= 0)
 		return -EINVAL;
 
-	error = user_path_walk_link(path, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(readlink, error, path, nd, path)
+
 		struct inode * inode = nd.dentry->d_inode;
 
 		error = -EINVAL;
@@ -277,7 +289,9 @@
 			}
 		}
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(readlink, error, path)
+
 	return error;
 }
 
--- /usr/src/linux-2.6.5-54/fs/namespace.c	2004-04-04 05:37:36.000000000 +0200
+++ 2.6.5-54-LAuS/fs/namespace.c	2004-04-16 10:09:26.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/namei.h>
 #include <linux/security.h>
 #include <linux/mount.h>
+#include <linux/fshooks.h>
 #include <asm/uaccess.h>
 
 extern int __init init_rootfs(void);
@@ -378,9 +379,8 @@
 	struct nameidata nd;
 	int retval;
 
-	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
-	if (retval)
-		goto out;
+	FSHOOK_BEGIN_USER_PATH_WALK(umount, retval, name, nd, dirname, .flags = flags)
+
 	retval = -EINVAL;
 	if (nd.dentry != nd.mnt->mnt_root)
 		goto dput_and_out;
@@ -394,7 +394,9 @@
 	retval = do_umount(nd.mnt, flags);
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(umount, retval, dirname)
+
 	return retval;
 }
 
@@ -906,10 +908,21 @@
 	if (retval < 0)
 		goto out3;
 
+	FSHOOK_BEGIN(mount,
+		retval,
+		.devname = (char *)dev_page,
+		.dirname = dir_page,
+		.type = (char *)type_page,
+		.flags = flags,
+		.data = (void *)data_page)
+
 	lock_kernel();
 	retval = do_mount((char*)dev_page, dir_page, (char*)type_page,
 			  flags, (void*)data_page);
 	unlock_kernel();
+
+	FSHOOK_END(mount, retval)
+
 	free_page(data_page);
 
 out3:
@@ -1016,14 +1029,14 @@
 
 	lock_kernel();
 
-	error = __user_walk(new_root, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd);
+	error = __user_walk(new_root, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd, 0);
 	if (error)
 		goto out0;
 	error = -EINVAL;
 	if (!check_mnt(new_nd.mnt))
 		goto out1;
 
-	error = __user_walk(put_old, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &old_nd);
+	error = __user_walk(put_old, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &old_nd, 0);
 	if (error)
 		goto out1;
 
--- /usr/src/linux-2.6.5-54/fs/ioctl.c	2004-04-04 05:36:26.000000000 +0200
+++ 2.6.5-54-LAuS/fs/ioctl.c	2004-04-16 10:09:26.000000000 +0200
@@ -8,6 +8,7 @@
 #include <linux/smp_lock.h>
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/security.h>
 
 #include <asm/uaccess.h>
@@ -52,8 +53,11 @@
 {	
 	struct file * filp;
 	unsigned int flag;
-	int on, error = -EBADF;
+	int on, error;
 
+	FSHOOK_BEGIN(ioctl, error, .fd = fd, .cmd = cmd, .arg.value = arg)
+
+	error = -EBADF;
 	filp = fget(fd);
 	if (!filp)
 		goto out;
@@ -130,5 +134,8 @@
 	fput(filp);
 
 out:
+
+	FSHOOK_END(ioctl, error)
+
 	return error;
 }
--- /usr/src/linux-2.6.5-54/fs/xattr.c	2004-04-04 05:36:57.000000000 +0200
+++ 2.6.5-54-LAuS/fs/xattr.c	2004-04-16 10:09:26.000000000 +0200
@@ -7,6 +7,7 @@
   Copyright (C) 2001 SGI - Silicon Graphics, Inc <linux-xfs@oss.sgi.com>
  */
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/file.h>
@@ -71,11 +72,22 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK(setxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.value = value,
+		.size = size,
+		.flags = flags,
+		.link = false)
+
 	error = setxattr(nd.dentry, name, value, size, flags);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(setxattr, error, path)
+
 	return error;
 }
 
@@ -86,11 +98,22 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk_link(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(setxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.value = value,
+		.size = size,
+		.flags = flags,
+		.link = true)
+
 	error = setxattr(nd.dentry, name, value, size, flags);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(setxattr, error, path)
+
 	return error;
 }
 
@@ -99,13 +122,26 @@
 	      size_t size, int flags)
 {
 	struct file *f;
-	int error = -EBADF;
+	int error;
+
+	FSHOOK_BEGIN(fsetxattr,
+		error,
+		.fd = fd,
+		.name = name,
+		.value = value,
+		.size = size,
+		.flags = flags)
 
 	f = fget(fd);
-	if (!f)
-		return error;
-	error = setxattr(f->f_dentry, name, value, size, flags);
-	fput(f);
+	if (f) {
+		error = setxattr(f->f_dentry, name, value, size, flags);
+		fput(f);
+	}
+	else
+		error = -EBADF;
+
+	FSHOOK_END(fsetxattr, error)
+
 	return error;
 }
 
@@ -161,11 +197,19 @@
 	struct nameidata nd;
 	ssize_t error;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK(getxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.link = false)
+
 	error = getxattr(nd.dentry, name, value, size);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(getxattr, error, path)
+
 	return error;
 }
 
@@ -176,11 +220,19 @@
 	struct nameidata nd;
 	ssize_t error;
 
-	error = user_path_walk_link(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(getxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.link = true)
+
 	error = getxattr(nd.dentry, name, value, size);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(getxattr, error, path)
+
 	return error;
 }
 
@@ -188,13 +240,20 @@
 sys_fgetxattr(int fd, char __user *name, void __user *value, size_t size)
 {
 	struct file *f;
-	ssize_t error = -EBADF;
+	ssize_t error;
+
+	FSHOOK_BEGIN(fgetxattr, error, .fd = fd, .name = name)
 
 	f = fget(fd);
-	if (!f)
-		return error;
-	error = getxattr(f->f_dentry, name, value, size);
-	fput(f);
+	if (f) {
+		error = getxattr(f->f_dentry, name, value, size);
+		fput(f);
+	}
+	else
+		error = -EBADF;
+
+	FSHOOK_END(fgetxattr, error)
+
 	return error;
 }
 
@@ -242,11 +301,18 @@
 	struct nameidata nd;
 	ssize_t error;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK(listxattr,
+		error,
+		path,
+		nd,
+		path,
+		.link = false)
+
 	error = listxattr(nd.dentry, list, size);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(listxattr, error, path)
+
 	return error;
 }
 
@@ -256,11 +322,18 @@
 	struct nameidata nd;
 	ssize_t error;
 
-	error = user_path_walk_link(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(listxattr,
+		error,
+		path,
+		nd,
+		path,
+		.link = true)
+
 	error = listxattr(nd.dentry, list, size);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(listxattr, error, path)
+
 	return error;
 }
 
@@ -268,13 +341,20 @@
 sys_flistxattr(int fd, char __user *list, size_t size)
 {
 	struct file *f;
-	ssize_t error = -EBADF;
+	ssize_t error;
+
+	FSHOOK_BEGIN(flistxattr, error, .fd = fd)
 
 	f = fget(fd);
-	if (!f)
-		return error;
-	error = listxattr(f->f_dentry, list, size);
-	fput(f);
+	if (f) {
+		error = listxattr(f->f_dentry, list, size);
+		fput(f);
+	}
+	else
+		error = -EBADF;
+
+	FSHOOK_END(flistxattr, error)
+
 	return error;
 }
 
@@ -312,11 +392,19 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK(rmxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.link = false)
+
 	error = removexattr(nd.dentry, name);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(rmxattr, error, path)
+
 	return error;
 }
 
@@ -326,11 +414,19 @@
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk_link(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(rmxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.link = true)
+
 	error = removexattr(nd.dentry, name);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(rmxattr, error, path)
+
 	return error;
 }
 
@@ -338,12 +434,19 @@
 sys_fremovexattr(int fd, char __user *name)
 {
 	struct file *f;
-	int error = -EBADF;
+	int error;
+
+	FSHOOK_BEGIN(frmxattr, error, .fd = fd, .name = name)
 
 	f = fget(fd);
-	if (!f)
-		return error;
-	error = removexattr(f->f_dentry, name);
-	fput(f);
+	if (f) {
+		error = removexattr(f->f_dentry, name);
+		fput(f);
+	}
+	else
+		error = -EBADF;
+
+	FSHOOK_END(frmxattr, error)
+
 	return error;
 }
--- /usr/src/linux-2.6.5-54/arch/ia64/ia32/sys_ia32.c	2004-04-04 05:37:24.000000000 +0200
+++ 2.6.5-54-LAuS/arch/ia64/ia32/sys_ia32.c	2004-04-16 10:34:22.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/sysctl.h>
 #include <linux/sched.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/file.h>
 #include <linux/signal.h>
 #include <linux/resource.h>
@@ -2106,31 +2109,34 @@
  * Exactly like fs/open.c:sys_open(), except that it doesn't set the O_LARGEFILE flag.
  */
 asmlinkage long
-sys32_open (const char * filename, int flags, int mode)
+sys32_open(const char __user * filename, int flags, int mode)
 {
 	char * tmp;
-	int fd, error;
+	int fd;
 
 	tmp = getname(filename);
 	fd = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(open, fd, .filename = tmp, .flags = flags, .mode = mode)
+
 		fd = get_unused_fd();
 		if (fd >= 0) {
 			struct file *f = filp_open(tmp, flags, mode);
-			error = PTR_ERR(f);
-			if (IS_ERR(f))
-				goto out_error;
-			fd_install(fd, f);
+
+			if (!IS_ERR(f))
+				fd_install(fd, f);
+			else {
+				put_unused_fd(fd);
+				fd = PTR_ERR(f);
+			}
 		}
-out:
+
+		FSHOOK_END(open, fd)
+
 		putname(tmp);
 	}
 	return fd;
-
-out_error:
-	put_unused_fd(fd);
-	fd = error;
-	goto out;
 }
 
 /* Structure for ia32 emulation on ia64 */
--- /usr/src/linux-2.6.5-54/arch/ppc64/kernel/sys_ppc32.c	2004-04-04 05:37:37.000000000 +0200
+++ 2.6.5-54-LAuS/arch/ppc64/kernel/sys_ppc32.c	2004-04-16 10:34:22.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/fs.h> 
+#include <linux/fshooks.h>
 #include <linux/mm.h> 
 #include <linux/file.h> 
 #include <linux/signal.h>
@@ -2212,31 +2217,34 @@
  * This is just a version for 32-bit applications which does
  * not force O_LARGEFILE on.
  */
-long sys32_open(const char * filename, int flags, int mode)
+long sys32_open(const char __user * filename, int flags, int mode)
 {
 	char * tmp;
-	int fd, error;
+	int fd;
 
 	tmp = getname(filename);
 	fd = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(open, fd, .filename = tmp, .flags = flags, .mode = mode)
+
 		fd = get_unused_fd();
 		if (fd >= 0) {
-			struct file * f = filp_open(tmp, flags, mode);
-			error = PTR_ERR(f);
-			if (IS_ERR(f))
-				goto out_error;
-			fd_install(fd, f);
+			struct file *f = filp_open(tmp, flags, mode);
+
+			if (!IS_ERR(f))
+				fd_install(fd, f);
+			else {
+				put_unused_fd(fd);
+				fd = PTR_ERR(f);
+			}
 		}
-out:
+
+		FSHOOK_END(open, fd)
+
 		putname(tmp);
 	}
 	return fd;
-
-out_error:
-	put_unused_fd(fd);
-	fd = error;
-	goto out;
 }
 
 /* Note: it is necessary to treat bufsiz as an unsigned int,
--- /usr/src/linux-2.6.5-54/arch/x86_64/ia32/sys_ia32.c	2004-04-04 05:36:57.000000000 +0200
+++ 2.6.5-54-LAuS/arch/x86_64/ia32/sys_ia32.c	2004-04-16 10:43:57.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/fs.h> 
+#include <linux/fshooks.h>
 #include <linux/file.h> 
 #include <linux/signal.h>
 #include <linux/syscalls.h>
@@ -1744,25 +1746,32 @@
 	return ret;
 } 
 
-asmlinkage long sys32_open(const char * filename, int flags, int mode)
+asmlinkage long sys32_open(const char __user * filename, int flags, int mode)
 {
 	char * tmp;
-	int fd, error;
+	int fd;
 
 	/* don't force O_LARGEFILE */
 	tmp = getname(filename);
 	fd = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(open, fd, .filename = tmp, .flags = flags, .mode = mode)
+
 		fd = get_unused_fd();
 		if (fd >= 0) {
 			struct file *f = filp_open(tmp, flags, mode);
-			error = PTR_ERR(f);
-			if (unlikely(IS_ERR(f))) {
-				put_unused_fd(fd); 
-				fd = error;
-			} else
+
+			if (!IS_ERR(f))
 				fd_install(fd, f);
+			else {
+				put_unused_fd(fd);
+				fd = PTR_ERR(f);
+			}
 		}
+
+		FSHOOK_END(open, fd)
+
 		putname(tmp);
 	}
 	return fd;
--- /usr/src/linux-2.6.5-54/init/main.c	2004-04-15 12:39:40.000000000 +0200
+++ 2.6.5-54-LAuS/init/main.c	2004-04-22 11:34:25.664883160 +0200
@@ -89,6 +89,11 @@
 extern void sysctl_init(void);
 extern void signals_init(void);
 extern void buffer_init(void);
+#ifdef CONFIG_FSHOOKS
+extern void fshooks_init(void);
+#else
+#define fshooks_init() ((void)0)
+#endif
 extern void pidhash_init(void);
 extern void pidmap_init(void);
 extern void anon_vma_init(void);
@@ -514,6 +519,7 @@
 	fork_init(num_physpages);
 	proc_caches_init();
 	buffer_init();
+	fshooks_init();
 	unnamed_dev_init();
 	security_scaffolding_startup();
 	vfs_caches_init(num_physpages);
--- /usr/src/linux-2.6.5-54/include/linux/namei.h	2004-04-04 05:36:55.000000000 +0200
+++ 2.6.5-54-LAuS/include/linux/namei.h	2004-04-16 10:09:26.000000000 +0200
@@ -48,11 +48,11 @@
 #define LOOKUP_CREATE		(0x0200)
 #define LOOKUP_ACCESS		(0x0400)
 
-extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *, const char **));
 #define user_path_walk(name,nd) \
-	__user_walk(name, LOOKUP_FOLLOW, nd)
+	__user_walk(name, LOOKUP_FOLLOW, nd, 0)
 #define user_path_walk_link(name,nd) \
-	__user_walk(name, 0, nd)
+	__user_walk(name, 0, nd, 0)
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
--- /usr/src/linux-2.6.5-54/include/linux/fshooks.h	1970-01-01 01:00:00.000000000 +0100
+++ 2.6.5-54-LAuS/include/linux/fshooks.h	2004-04-22 08:49:41.000000000 +0200
@@ -0,0 +1,334 @@
+#ifndef _LINUX_FSHOOKS_H
+#define _LINUX_FSHOOKS_H
+
+/*
+ * This file has definitions for file system hooks.
+ */
+
+#include <linux/config.h>
+
+#ifdef CONFIG_FSHOOKS
+
+#include <linux/rwsem.h>
+
+enum FShook {
+#define FSHOOK_DEFINE(type, fields...) FSHOOK_##type,
+#include <linux/fshooks.h>
+	fshook_COUNT /* keep this last */
+};
+
+/* for the lack of a kernel-wide definition */
+typedef enum {
+	false,
+	true
+} boolean_t __attribute__((__mode__(__QI__)));
+
+typedef union fshook_info {
+	struct fshook_generic_info {
+		enum FShook type;
+		int result;
+	} const *gen;
+#define FSHOOK_DEFINE(type, fields...) \
+	struct fshook_##type##_info { \
+		struct fshook_generic_info gen; \
+		fields \
+	} const *type;
+#include <linux/fshooks.h>
+} fshook_info_t __attribute__((__transparent_union__));
+
+typedef int fshook_pre_t(fshook_info_t info, void *ctx);
+typedef void fshook_post_t(fshook_info_t info, void *ctx);
+
+int fshook_register(enum FShook, fshook_pre_t *, fshook_post_t *, void *);
+int fshook_deregister(enum FShook, fshook_pre_t *, fshook_post_t *, void *);
+
+#ifndef MODULE
+
+struct fshook {
+	struct fshook *next;
+	void *ctx;
+	fshook_pre_t *pre;
+	fshook_post_t *post;
+};
+
+struct fshook_list {
+	struct fshook *first;
+	struct fshook *last;
+	struct rw_semaphore lock;
+};
+
+extern struct fshook_list fshooks[fshook_COUNT];
+
+member_type(struct fshook_generic_info, result) fshook_run_pre(enum FShook type, fshook_info_t info);
+void fshook_run_post(fshook_info_t info, member_type(struct fshook_generic_info, result) result);
+
+/* there must not be semicolons after the invocations of FSHOOK_BEGN/FSHOOK_END */
+#define FSHOOK_BEGIN(type, result, args...) { \
+		struct fshook_##type##_info info = { args }; \
+		\
+		if (!fshooks[FSHOOK_##type].first \
+		   || !(result = (__typeof__(result))fshook_run_pre(FSHOOK_##type, &info))) {
+
+#define FSHOOK_END(type, result, errcode...) \
+			(void)(&info != (struct fshook_##type##_info *)-1L); \
+		} \
+		else { \
+			errcode; \
+		} \
+		if (fshooks[FSHOOK_##type].first) \
+			fshook_run_post(&info, result); \
+	}
+
+#define FSHOOK_BEGIN_USER_WALK_COMMON(type, err, walk, args...) { \
+		struct fshook_##type##_info info = { args }; \
+		if (!(err = walk) \
+		    && (!fshooks[FSHOOK_##type].first \
+		        || !(err = (__typeof__(err))fshook_run_pre(FSHOOK_##type, &info)))) {
+
+#define FSHOOK_BEGIN_USER_WALK(type, err, path, flags, nd, field, args...) \
+		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk(path, flags, &nd, &info.field), args)
+
+#define FSHOOK_BEGIN_USER_PATH_WALK(type, err, path, nd, field, args...) \
+		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk(path, LOOKUP_FOLLOW, &nd, &info.field), args)
+
+#define FSHOOK_BEGIN_USER_PATH_WALK_LINK(type, err, path, nd, field, args...) \
+		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk(path, 0, &nd, &info.field), args)
+
+#define FSHOOK_END_USER_WALK(type, err, field) \
+			(void)(&info != (struct fshook_##type##_info *)-1L); \
+		} \
+		else if (!IS_ERR(info.field) && fshooks[FSHOOK_##type].first) { \
+			__typeof__(err) fshook_err = (__typeof__(err))fshook_run_pre(FSHOOK_##type, &info); \
+			\
+			/* simulate normal (hooks precede path resolution) sequence of operation */ \
+			if (fshook_err) err = fshook_err; \
+		} \
+		if (!IS_ERR(info.field)) { \
+			if (fshooks[FSHOOK_##type].first) \
+				fshook_run_post(&info, err); \
+			putname(info.field); \
+		} \
+	}
+
+#endif /* MODULE */
+
+#else /* ndef CONFIG_FSHOOKS */
+
+#ifndef MODULE
+
+#define FSHOOK_BEGIN(type, result, args...) {
+
+#define FSHOOK_END(type, result, errcode...) ((void)0);}
+
+#define FSHOOK_BEGIN_USER_WALK(type, err, path, flags, nd, field, args...) \
+	if (!(err = __user_walk(path, flags, &nd, 0))) {
+
+#define FSHOOK_BEGIN_USER_PATH_WALK(type, err, path, nd, field, args...) \
+	if (!(err = user_path_walk(path, &nd))) {
+
+#define FSHOOK_BEGIN_USER_PATH_WALK_LINK(type, err, path, nd, field, args...) \
+	if (!(err = user_path_walk_link(path, &nd))) {
+
+#define FSHOOK_END_USER_WALK(type, err, field) ((void)0);}
+
+#endif /* MODULE */
+
+#endif /* CONFIG_FSHOOKS */
+
+#elif defined(FSHOOK_DEFINE)
+
+FSHOOK_DEFINE(access,
+	const char *path;
+	int mode;
+)
+
+FSHOOK_DEFINE(chdir,
+	const char *dirname;
+)
+
+FSHOOK_DEFINE(chmod,
+	const char *path;
+	mode_t mode;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(chown,
+	const char *path;
+	uid_t uid;
+	gid_t gid;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(chroot,
+	const char *path;
+)
+
+FSHOOK_DEFINE(close,
+	int fd;
+)
+
+FSHOOK_DEFINE(fchdir,
+	int fd;
+)
+
+FSHOOK_DEFINE(fchmod,
+	int fd;
+	mode_t mode;
+)
+
+FSHOOK_DEFINE(fchown,
+	int fd;
+	uid_t uid;
+	gid_t gid;
+)
+
+FSHOOK_DEFINE(fgetxattr,
+	int fd;
+	const char __user *name;
+)
+
+FSHOOK_DEFINE(flistxattr,
+	int fd;
+)
+
+FSHOOK_DEFINE(frmxattr,
+	int fd;
+	const char __user *name;
+)
+
+FSHOOK_DEFINE(fsetxattr,
+	int fd;
+	const char __user *name;
+	const void __user *value;
+	size_t size;
+	unsigned flags;
+)
+
+FSHOOK_DEFINE(fstat,
+	int fd;
+)
+
+FSHOOK_DEFINE(fstatfs,
+	int fd;
+)
+
+FSHOOK_DEFINE(ftruncate,
+	int fd;
+	loff_t length;
+)
+
+FSHOOK_DEFINE(getxattr,
+	const char *path;
+	const char __user *name;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(ioctl,
+	int fd;
+	unsigned cmd;
+	union {
+		unsigned long value;
+		void __user *ptr;
+	} arg;
+)
+
+FSHOOK_DEFINE(link,
+	const char *oldpath;
+	const char *newpath;
+)
+
+FSHOOK_DEFINE(listxattr,
+	const char *path;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(mkdir,
+	const char *dirname;
+	mode_t mode;
+)
+
+FSHOOK_DEFINE(mknod,
+	const char *path;
+	mode_t mode;
+	dev_t dev;
+)
+
+FSHOOK_DEFINE(mount,
+	const char *devname;
+	const char *dirname;
+	const char *type;
+	unsigned long flags;
+	const void *data;
+)
+
+FSHOOK_DEFINE(open,
+	const char *filename;
+	int flags;
+	int mode;
+)
+
+FSHOOK_DEFINE(readlink,
+	const char *path;
+)
+
+FSHOOK_DEFINE(rmxattr,
+	const char *path;
+	const char __user *name;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(rename,
+	const char *oldpath;
+	const char *newpath;
+)
+
+FSHOOK_DEFINE(rmdir,
+	const char *dirname;
+)
+
+FSHOOK_DEFINE(setxattr,
+	const char *path;
+	const char __user *name;
+	const void __user *value;
+	size_t size;
+	unsigned flags;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(stat,
+	const char *path;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(statfs,
+	const char *path;
+)
+
+FSHOOK_DEFINE(symlink,
+	const char *oldpath;
+	const char *newpath;
+)
+
+FSHOOK_DEFINE(truncate,
+	const char *filename;
+	loff_t length;
+)
+
+FSHOOK_DEFINE(umount,
+	const char *dirname;
+	int flags;
+)
+
+FSHOOK_DEFINE(unlink,
+	const char *filename;
+)
+
+FSHOOK_DEFINE(utimes,
+	const char *path;
+	const struct timeval *atime;
+	const struct timeval *mtime;
+)
+
+#undef FSHOOK_DEFINE
+
+#endif /* _LINUX_FSHOOKS_H / FSHOOK_DEFINE */
--- /usr/src/linux-2.6.5-54/include/linux/kernel.h	2004-04-15 12:39:22.000000000 +0200
+++ 2.6.5-54-LAuS/include/linux/kernel.h	2004-04-16 10:09:26.000000000 +0200
@@ -194,6 +194,15 @@
 
 
 /**
+ * member_type - get the type of a member of a structure
+ *
+ * @type:	the type of the struct.
+ * @member:	the name of the member within the struct.
+ *
+ */
+#define member_type(type, member) __typeof__( ((type *)0)->member )
+
+/**
  * container_of - cast a member of a structure out to the containing structure
  *
  * @ptr:	the pointer to the member.
@@ -202,7 +211,7 @@
  *
  */
 #define container_of(ptr, type, member) ({			\
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        const member_type(type, member) *__mptr = (ptr);	\
         (type *)( (char *)__mptr - offsetof(type,member) );})
 
 /*
