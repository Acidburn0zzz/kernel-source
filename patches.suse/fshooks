diff -urNp linux-2.6.5/arch/i386/kernel/sys_i386.c linux-2.6.5.SUSE/arch/i386/kernel/sys_i386.c
--- linux-2.6.5/arch/i386/kernel/sys_i386.c	2004-04-26 16:50:36.000000000 +0200
+++ linux-2.6.5.SUSE/arch/i386/kernel/sys_i386.c	2004-04-26 16:50:54.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
+#include <linux/fshooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -46,9 +47,20 @@ long do_mmap2(struct mm_struct *mm,
 	unsigned long prot, unsigned long flags,
 	unsigned long fd, unsigned long pgoff)
 {
-	int error = -EBADF;
+	int error;
+
+	FSHOOK_BEGIN(mmap,
+		error,
+		.paddr = &addr,
+		.length = len,
+		.prot = prot,
+		.flags = flags,
+		.fd = fd,
+		.offset = (loff_t)pgoff << PAGE_SHIFT)
+
 	struct file * file = NULL;
 
+	error = -EBADF;
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
@@ -57,12 +69,14 @@ long do_mmap2(struct mm_struct *mm,
 	}
 
 	down_write(&mm->mmap_sem);
-	error = __do_mmap_pgoff(mm, file, addr, len, prot, flags, pgoff);
+	addr = error = __do_mmap_pgoff(mm, file, addr, len, prot, flags, pgoff);
 	up_write(&mm->mmap_sem);
 
 	if (file)
 		fput(file);
 out:
+	FSHOOK_END(mmap, !IS_ERR((void *)error) ? 0 : error)
+
 	return error;
 }
 
diff -urNp linux-2.6.5/arch/ia64/ia32/sys_ia32.c linux-2.6.5.SUSE/arch/ia64/ia32/sys_ia32.c
--- linux-2.6.5/arch/ia64/ia32/sys_ia32.c	2004-04-26 16:50:33.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ia64/ia32/sys_ia32.c	2004-04-26 16:50:54.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/sysctl.h>
 #include <linux/sched.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/file.h>
 #include <linux/signal.h>
 #include <linux/resource.h>
@@ -470,22 +471,38 @@ sys32_mmap (struct mmap_arg_struct *arg)
 	if (copy_from_user(&a, arg, sizeof(a)))
 		return -EFAULT;
 
-	if (OFFSET4K(a.offset))
-		return -EINVAL;
+	FSHOOK_BEGIN(mmap,
+		addr,
+		.paddr = (addr = a.addr, &addr),
+		.length = a.len,
+		.prot = a.prot,
+		.flags = a.flags,
+		.fd = a.fd,
+		.offset = a.offset)
+
+	if (OFFSET4K(a.offset)) {
+		addr = -EINVAL;
+		goto out;
+	}
 
 	flags = a.flags;
 
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(a.fd);
-		if (!file)
-			return -EBADF;
+		if (!file) {
+			addr = -EBADF;
+			goto out;
+		}
 	}
 
 	addr = ia32_do_mmap(file, a.addr, a.len, a.prot, flags, a.offset);
 
 	if (file)
 		fput(file);
+out:
+	FSHOOK_END(mmap, !IS_ERR((void *)addr) ? 0 : addr)
+
 	return addr;
 }
 
@@ -496,11 +513,22 @@ sys32_mmap2 (unsigned int addr, unsigned
 	struct file *file = NULL;
 	unsigned long retval;
 
+	FSHOOK_BEGIN(mmap,
+		retval,
+		.paddr = (retval = addr, &retval),
+		.length = len,
+		.prot = prot,
+		.flags = flags,
+		.fd = fd,
+		.offset = (unsigned long)pgoff << IA32_PAGE_SHIFT)
+
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
-		if (!file)
-			return -EBADF;
+		if (!file) {
+			retval = -EBADF;
+			goto out;
+		}
 	}
 
 	retval = ia32_do_mmap(file, addr, len, prot, flags,
@@ -508,6 +536,9 @@ sys32_mmap2 (unsigned int addr, unsigned
 
 	if (file)
 		fput(file);
+out:
+	FSHOOK_END(mmap, !IS_ERR((void *)retval) ? 0 : retval)
+
 	return retval;
 }
 
@@ -2107,31 +2138,34 @@ sys32_brk (unsigned int brk)
  * Exactly like fs/open.c:sys_open(), except that it doesn't set the O_LARGEFILE flag.
  */
 asmlinkage long
-sys32_open (const char * filename, int flags, int mode)
+sys32_open(const char __user * filename, int flags, int mode)
 {
 	char * tmp;
-	int fd, error;
+	int fd;
 
 	tmp = getname(filename);
 	fd = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(open, fd, .filename = tmp, .flags = flags, .mode = mode)
+
 		fd = get_unused_fd();
 		if (fd >= 0) {
 			struct file *f = filp_open(tmp, flags, mode);
-			error = PTR_ERR(f);
-			if (IS_ERR(f))
-				goto out_error;
-			fd_install(fd, f);
+
+			if (!IS_ERR(f))
+				fd_install(fd, f);
+			else {
+				put_unused_fd(fd);
+				fd = PTR_ERR(f);
+			}
 		}
-out:
+
+		FSHOOK_END(open, fd)
+
 		putname(tmp);
 	}
 	return fd;
-
-out_error:
-	put_unused_fd(fd);
-	fd = error;
-	goto out;
 }
 
 /* Structure for ia32 emulation on ia64 */
diff -urNp linux-2.6.5/arch/ia64/kernel/sys_ia64.c linux-2.6.5.SUSE/arch/ia64/kernel/sys_ia64.c
--- linux-2.6.5/arch/ia64/kernel/sys_ia64.c	2004-04-26 16:50:34.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ia64/kernel/sys_ia64.c	2004-04-26 16:50:54.000000000 +0200
@@ -8,6 +8,7 @@
 #include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/mm.h>
 #include <linux/mman.h>
 #include <linux/sched.h>
@@ -182,14 +183,27 @@ sys_pipe (long arg0, long arg1, long arg
 static inline unsigned long
 do_mmap2 (unsigned long addr, unsigned long len, int prot, int flags, int fd, unsigned long pgoff)
 {
+	int error;
+
+	FSHOOK_BEGIN(mmap,
+		error,
+		.paddr = &addr,
+		.length = len,
+		.prot = prot,
+		.flags = flags,
+		.fd = fd,
+		.offset = (loff_t)pgoff << PAGE_SHIFT)
+
 	unsigned long roff;
 	struct file *file = 0;
 
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
-		if (!file)
-			return -EBADF;
+		if (!file) {
+			addr = -EBADF;
+			goto no_file;
+		}
 
 		if (!file->f_op || !file->f_op->mmap) {
 			addr = -ENODEV;
@@ -228,6 +242,9 @@ do_mmap2 (unsigned long addr, unsigned l
 
 out:	if (file)
 		fput(file);
+no_file:
+	FSHOOK_END(mmap, !IS_ERR((void *)addr) ? 0 : addr, addr = error)
+
 	return addr;
 }
 
diff -urNp linux-2.6.5/arch/ppc/kernel/syscalls.c linux-2.6.5.SUSE/arch/ppc/kernel/syscalls.c
--- linux-2.6.5/arch/ppc/kernel/syscalls.c	2004-04-04 05:38:18.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ppc/kernel/syscalls.c	2004-04-26 16:50:54.000000000 +0200
@@ -36,6 +36,7 @@
 #include <linux/utsname.h>
 #include <linux/file.h>
 #include <linux/unistd.h>
+#include <linux/fshooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -162,9 +163,20 @@ do_mmap2(unsigned long addr, size_t len,
 	 unsigned long prot, unsigned long flags,
 	 unsigned long fd, unsigned long pgoff)
 {
+	int ret;
+
+	FSHOOK_BEGIN(mmap,
+		ret,
+		.paddr = &addr,
+		.length = len,
+		.prot = prot,
+		.flags = flags,
+		.fd = fd,
+		.offset = (loff_t)pgoff << PAGE_SHIFT)
+
 	struct file * file = NULL;
-	int ret = -EBADF;
 
+	ret = -EBADF;
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		if (!(file = fget(fd)))
@@ -172,11 +184,13 @@ do_mmap2(unsigned long addr, size_t len,
 	}
 
 	down_write(&current->mm->mmap_sem);
-	ret = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	addr = ret = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
 	up_write(&current->mm->mmap_sem);
 	if (file)
 		fput(file);
 out:
+	FSHOOK_END(mmap, !IS_ERR((void *)ret) ? 0 : ret)
+
 	return ret;
 }
 
diff -urNp linux-2.6.5/arch/ppc64/kernel/sys_ppc32.c linux-2.6.5.SUSE/arch/ppc64/kernel/sys_ppc32.c
--- linux-2.6.5/arch/ppc64/kernel/sys_ppc32.c	2004-04-04 05:37:37.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ppc64/kernel/sys_ppc32.c	2004-04-26 16:50:54.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/fs.h> 
+#include <linux/fshooks.h>
 #include <linux/mm.h> 
 #include <linux/file.h> 
 #include <linux/signal.h>
@@ -2212,31 +2213,34 @@ off_t ppc32_lseek(unsigned int fd, u32 o
  * This is just a version for 32-bit applications which does
  * not force O_LARGEFILE on.
  */
-long sys32_open(const char * filename, int flags, int mode)
+long sys32_open(const char __user * filename, int flags, int mode)
 {
 	char * tmp;
-	int fd, error;
+	int fd;
 
 	tmp = getname(filename);
 	fd = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(open, fd, .filename = tmp, .flags = flags, .mode = mode)
+
 		fd = get_unused_fd();
 		if (fd >= 0) {
-			struct file * f = filp_open(tmp, flags, mode);
-			error = PTR_ERR(f);
-			if (IS_ERR(f))
-				goto out_error;
-			fd_install(fd, f);
+			struct file *f = filp_open(tmp, flags, mode);
+
+			if (!IS_ERR(f))
+				fd_install(fd, f);
+			else {
+				put_unused_fd(fd);
+				fd = PTR_ERR(f);
+			}
 		}
-out:
+
+		FSHOOK_END(open, fd)
+
 		putname(tmp);
 	}
 	return fd;
-
-out_error:
-	put_unused_fd(fd);
-	fd = error;
-	goto out;
 }
 
 /* Note: it is necessary to treat bufsiz as an unsigned int,
diff -urNp linux-2.6.5/arch/ppc64/kernel/syscalls.c linux-2.6.5.SUSE/arch/ppc64/kernel/syscalls.c
--- linux-2.6.5/arch/ppc64/kernel/syscalls.c	2004-04-04 05:37:37.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ppc64/kernel/syscalls.c	2004-04-26 16:50:54.000000000 +0200
@@ -37,6 +37,7 @@
 #include <linux/file.h>
 #include <linux/init.h>
 #include <linux/personality.h>
+#include <linux/fshooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -174,9 +175,20 @@ unsigned long sys_mmap(unsigned long add
 		       unsigned long prot, unsigned long flags,
 		       unsigned long fd, off_t offset)
 {
+	unsigned long ret;
+
+	FSHOOK_BEGIN(mmap,
+		ret,
+		.paddr = (ret = addr, &ret),
+		.length = len,
+		.prot = prot,
+		.flags = flags,
+		.fd = fd,
+		.offset = offset)
+
 	struct file * file = NULL;
-	unsigned long ret = -EBADF;
 
+	ret = -EBADF;
 	if (!(flags & MAP_ANONYMOUS)) {
 		if (!(file = fget(fd)))
 			goto out;
@@ -190,6 +202,8 @@ unsigned long sys_mmap(unsigned long add
 		fput(file);
 
 out:
+	FSHOOK_END(mmap, !IS_ERR((void *)ret) ? 0 : ret)
+
 	return ret;
 }
 
diff -urNp linux-2.6.5/arch/s390/kernel/compat_linux.c linux-2.6.5.SUSE/arch/s390/kernel/compat_linux.c
--- linux-2.6.5/arch/s390/kernel/compat_linux.c	2004-04-04 05:37:42.000000000 +0200
+++ linux-2.6.5.SUSE/arch/s390/kernel/compat_linux.c	2004-04-26 16:50:54.000000000 +0200
@@ -20,6 +20,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/fs.h> 
+#include <linux/fshooks.h> 
 #include <linux/mm.h> 
 #include <linux/file.h> 
 #include <linux/signal.h>
@@ -1845,9 +1846,20 @@ static inline long do_mmap2(
 	unsigned long prot, unsigned long flags,
 	unsigned long fd, unsigned long pgoff)
 {
+	unsigned long error;
+
+	FSHOOK_BEGIN(mmap,
+		error,
+		.paddr = (error = addr, &error),
+		.length = len,
+		.prot = prot,
+		.flags = flags,
+		.fd = fd,
+		.offset = pgoff << PAGE_SHIFT)
+
 	struct file * file = NULL;
-	unsigned long error = -EBADF;
 
+	error = -EBADF;
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
@@ -1867,6 +1879,8 @@ static inline long do_mmap2(
 	if (file)
 		fput(file);
 out:    
+	FSHOOK_END(mmap, !IS_ERR(void *)error) ? 0 : error)
+
 	return error;
 }
 
diff -urNp linux-2.6.5/arch/s390/kernel/sys_s390.c linux-2.6.5.SUSE/arch/s390/kernel/sys_s390.c
--- linux-2.6.5/arch/s390/kernel/sys_s390.c	2004-04-04 05:36:56.000000000 +0200
+++ linux-2.6.5.SUSE/arch/s390/kernel/sys_s390.c	2004-04-26 16:50:54.000000000 +0200
@@ -28,6 +28,7 @@
 #ifdef CONFIG_ARCH_S390X
 #include <linux/personality.h>
 #endif /* CONFIG_ARCH_S390X */
+#include <linux/fshooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -55,9 +56,20 @@ static inline long do_mmap2(
 	unsigned long prot, unsigned long flags,
 	unsigned long fd, unsigned long pgoff)
 {
-	long error = -EBADF;
+	long error;
+
+	FSHOOK_BEGIN(mmap,
+		error,
+		.paddr = (error = addr, &error),
+		.length = len,
+		.prot = prot,
+		.flags = flags,
+		.fd = fd,
+		.offset = pgoff << PAGE_SHIFT)
+
 	struct file * file = NULL;
 
+	error = -EBADF;
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
@@ -72,6 +84,8 @@ static inline long do_mmap2(
 	if (file)
 		fput(file);
 out:
+	FSHOOK_END(mmap, !IS_ERR((void *)error) ? 0 : error)
+
 	return error;
 }
 
diff -urNp linux-2.6.5/arch/x86_64/ia32/sys_ia32.c linux-2.6.5.SUSE/arch/x86_64/ia32/sys_ia32.c
--- linux-2.6.5/arch/x86_64/ia32/sys_ia32.c	2004-04-26 16:50:33.000000000 +0200
+++ linux-2.6.5.SUSE/arch/x86_64/ia32/sys_ia32.c	2004-04-26 16:50:54.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/fs.h> 
+#include <linux/fshooks.h>
 #include <linux/file.h> 
 #include <linux/signal.h>
 #include <linux/syscalls.h>
@@ -209,13 +210,26 @@ sys32_mmap(struct mmap_arg_struct *arg)
 	if (copy_from_user(&a, arg, sizeof(a)))
 		return -EFAULT;
 
-	if (a.offset & ~PAGE_MASK)
-		return -EINVAL; 
+	FSHOOK_BEGIN(mmap,
+		retval,
+		.paddr = (retval = a.addr, &retval),
+		.length = a.len,
+		.prot = a.prot,
+		.flags = a.flags,
+		.fd = a.fd,
+		.offset = a.offset)
+
+	if (a.offset & ~PAGE_MASK) {
+		retval = -EINVAL;
+		goto out;
+	}
 
 	if (!(a.flags & MAP_ANONYMOUS)) {
 		file = fget(a.fd);
-		if (!file)
-			return -EBADF;
+		if (!file) {
+			retval = -EBADF;
+			goto out;
+		}
 	}
 	
 	if (a.prot & PROT_READ) 
@@ -228,6 +242,8 @@ sys32_mmap(struct mmap_arg_struct *arg)
 		fput(file);
 
 	up_write(&mm->mmap_sem); 
+out:
+	FSHOOK_END(mmap, !IS_ERR((void *)retval) ? 0 : retval)
 
 	return retval;
 }
@@ -1236,11 +1252,22 @@ asmlinkage long sys32_mmap2(unsigned lon
 	unsigned long error;
 	struct file * file = NULL;
 
+	FSHOOK_BEGIN(mmap,
+		error,
+		.paddr = (error = addr, &error),
+		.length = len,
+		.prot = prot,
+		.flags = flags,
+		.fd = fd,
+		.offset = (loff_t)pgoff << PAGE_SHIFT)
+
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
 		file = fget(fd);
-		if (!file)
-			return -EBADF;
+		if (!file) {
+			error = -EBADF;
+			goto out;
+		}
 	}
 
 	if (prot & PROT_READ)
@@ -1252,6 +1279,9 @@ asmlinkage long sys32_mmap2(unsigned lon
 
 	if (file)
 		fput(file);
+out:
+	FSHOOK_END(mmap, !IS_ERR((void *)error) ? 0 : error)
+
 	return error;
 }
 
@@ -1745,25 +1775,32 @@ asmlinkage long sys32_io_getevents(aio_c
 	return ret;
 } 
 
-asmlinkage long sys32_open(const char * filename, int flags, int mode)
+asmlinkage long sys32_open(const char __user * filename, int flags, int mode)
 {
 	char * tmp;
-	int fd, error;
+	int fd;
 
 	/* don't force O_LARGEFILE */
 	tmp = getname(filename);
 	fd = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(open, fd, .filename = tmp, .flags = flags, .mode = mode)
+
 		fd = get_unused_fd();
 		if (fd >= 0) {
 			struct file *f = filp_open(tmp, flags, mode);
-			error = PTR_ERR(f);
-			if (unlikely(IS_ERR(f))) {
-				put_unused_fd(fd); 
-				fd = error;
-			} else
+
+			if (!IS_ERR(f))
 				fd_install(fd, f);
+			else {
+				put_unused_fd(fd);
+				fd = PTR_ERR(f);
+			}
 		}
+
+		FSHOOK_END(open, fd)
+
 		putname(tmp);
 	}
 	return fd;
diff -urNp linux-2.6.5/arch/x86_64/kernel/sys_x86_64.c linux-2.6.5.SUSE/arch/x86_64/kernel/sys_x86_64.c
--- linux-2.6.5/arch/x86_64/kernel/sys_x86_64.c	2004-04-04 05:37:36.000000000 +0200
+++ linux-2.6.5.SUSE/arch/x86_64/kernel/sys_x86_64.c	2004-04-26 16:50:54.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/file.h>
 #include <linux/utsname.h>
 #include <linux/personality.h>
+#include <linux/fshooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -42,6 +43,16 @@ long sys_mmap(unsigned long addr, unsign
 	unsigned long fd, unsigned long off)
 {
 	long error;
+
+	FSHOOK_BEGIN(mmap,
+		error,
+		.paddr = &addr,
+		.length = len,
+		.prot = prot,
+		.flags = flags,
+		.fd = fd,
+		.offset = off)
+
 	struct file * file;
 
 	error = -EINVAL;
@@ -57,12 +68,14 @@ long sys_mmap(unsigned long addr, unsign
 			goto out;
 	}
 	down_write(&current->mm->mmap_sem);
-	error = do_mmap_pgoff(file, addr, len, prot, flags, off >> PAGE_SHIFT);
+	addr = error = do_mmap_pgoff(file, addr, len, prot, flags, off >> PAGE_SHIFT);
 	up_write(&current->mm->mmap_sem);
 
 	if (file)
 		fput(file);
 out:
+	FSHOOK_END(mmap, !IS_ERR((void *)error) ? 0 : error)
+
 	return error;
 }
 
diff -urNp linux-2.6.5/fs/Kconfig linux-2.6.5.SUSE/fs/Kconfig
--- linux-2.6.5/fs/Kconfig	2004-04-26 16:50:40.000000000 +0200
+++ linux-2.6.5.SUSE/fs/Kconfig	2004-04-26 16:50:54.000000000 +0200
@@ -1820,3 +1820,9 @@ source "fs/nls/Kconfig"
 
 endmenu
 
+
+config FSHOOKS
+	bool "File system hooks"
+	default y
+	help
+	  Provide capability to monitor file system activity
diff -urNp linux-2.6.5/fs/Makefile linux-2.6.5.SUSE/fs/Makefile
--- linux-2.6.5/fs/Makefile	2004-04-26 16:50:40.000000000 +0200
+++ linux-2.6.5.SUSE/fs/Makefile	2004-04-26 16:50:54.000000000 +0200
@@ -43,6 +43,8 @@ obj-y				+= partitions/
 obj-y				+= sysfs/
 obj-y				+= devpts/
 
+obj-$(CONFIG_FSHOOKS)		+= fshooks.o
+
 obj-$(CONFIG_PROFILING)		+= dcookies.o
  
 # Do not add any filesystems before this line
diff -urNp linux-2.6.5/fs/buffer.c linux-2.6.5.SUSE/fs/buffer.c
--- linux-2.6.5/fs/buffer.c	2004-04-26 16:50:40.000000000 +0200
+++ linux-2.6.5.SUSE/fs/buffer.c	2004-04-26 16:50:54.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/mm.h>
 #include <linux/percpu.h>
 #include <linux/slab.h>
@@ -350,8 +351,12 @@ static void do_sync(unsigned long wait)
 
 asmlinkage long sys_sync(void)
 {
+	int ret = 0;
+
+	FSHOOK_BEGIN(sync, ret)
 	do_sync(1);
-	return 0;
+	FSHOOK_END(sync, ret)
+	return ret;
 }
 
 void emergency_sync(void)
@@ -392,6 +397,8 @@ asmlinkage long sys_fsync(unsigned int f
 	struct address_space *mapping;
 	int ret, err;
 
+	FSHOOK_BEGIN(fsync, ret, .fd = fd, .data = false)
+
 	ret = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -421,6 +428,8 @@ asmlinkage long sys_fsync(unsigned int f
 out_putf:
 	fput(file);
 out:
+	FSHOOK_END(fsync, ret)
+
 	return ret;
 }
 
@@ -430,6 +439,8 @@ asmlinkage long sys_fdatasync(unsigned i
 	struct address_space *mapping;
 	int ret, err;
 
+	FSHOOK_BEGIN(fsync, ret, .fd = fd, .data = true)
+
 	ret = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -456,6 +467,8 @@ asmlinkage long sys_fdatasync(unsigned i
 out_putf:
 	fput(file);
 out:
+	FSHOOK_END(fsync, ret)
+
 	return ret;
 }
 
diff -urNp linux-2.6.5/fs/compat.c linux-2.6.5.SUSE/fs/compat.c
--- linux-2.6.5/fs/compat.c	2004-04-26 16:50:36.000000000 +0200
+++ linux-2.6.5.SUSE/fs/compat.c	2004-04-26 16:50:54.000000000 +0200
@@ -20,6 +20,7 @@
 #include <linux/errno.h>
 #include <linux/time.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/fcntl.h>
 #include <linux/namei.h>
 #include <linux/file.h>
@@ -149,14 +150,16 @@ asmlinkage long compat_sys_statfs(const 
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(path, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(statfs, error, path, nd, path)
+
 		struct kstatfs tmp;
 		error = vfs_statfs(nd.dentry->d_inode->i_sb, &tmp);
 		if (!error && put_compat_statfs(buf, &tmp))
 			error = -EFAULT;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(statfs, error, path)
+
 	return error;
 }
 
@@ -166,6 +169,8 @@ asmlinkage long compat_sys_fstatfs(unsig
 	struct kstatfs tmp;
 	int error;
 
+	FSHOOK_BEGIN(fstatfs, error, .fd = fd)
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -175,6 +180,9 @@ asmlinkage long compat_sys_fstatfs(unsig
 		error = -EFAULT;
 	fput(file);
 out:
+
+	FSHOOK_END(fstatfs, error)
+
 	return error;
 }
 
@@ -217,14 +225,16 @@ asmlinkage long compat_statfs64(const ch
 	if (sz != sizeof(*buf))
 		return -EINVAL;
 
-	error = user_path_walk(path, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(statfs, error, path, nd, path)
+
 		struct kstatfs tmp;
 		error = vfs_statfs(nd.dentry->d_inode->i_sb, &tmp);
 		if (!error && put_compat_statfs64(buf, &tmp))
 			error = -EFAULT;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(statfs, error, path)
+
 	return error;
 }
 
@@ -237,6 +247,8 @@ asmlinkage long compat_fstatfs64(unsigne
 	if (sz != sizeof(*buf))
 		return -EINVAL;
 
+	FSHOOK_BEGIN(fstatfs, error, .fd = fd)
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -246,6 +258,9 @@ asmlinkage long compat_fstatfs64(unsigne
 		error = -EFAULT;
 	fput(file);
 out:
+
+	FSHOOK_END(fstatfs, error)
+
 	return error;
 }
 
@@ -792,11 +807,21 @@ asmlinkage int compat_sys_mount(char __u
 		}
 	}
 
+	FSHOOK_BEGIN(mount,
+		retval,
+		.devname = (char *)dev_page,
+		.dirname = dir_page,
+		.type = (char *)type_page,
+		.flags = flags,
+		.data = (void *)data_page)
+
 	lock_kernel();
 	retval = do_mount((char*)dev_page, dir_page, (char*)type_page,
 			flags, (void*)data_page);
 	unlock_kernel();
 
+	FSHOOK_END(mount, retval)
+
 	free_page(data_page);
  out3:
 	free_page(dev_page);
diff -urNp linux-2.6.5/fs/exec.c linux-2.6.5.SUSE/fs/exec.c
--- linux-2.6.5/fs/exec.c	2004-04-26 16:50:40.000000000 +0200
+++ linux-2.6.5.SUSE/fs/exec.c	2004-04-26 16:50:54.000000000 +0200
@@ -43,6 +43,7 @@
 #include <linux/proc_fs.h>
 #include <linux/ptrace.h>
 #include <linux/mount.h>
+#include <linux/fshooks.h>
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/objrmap.h>
@@ -124,17 +125,23 @@ asmlinkage long sys_uselib(const char __
 	int error;
 
 	nd.intent.open.flags = FMODE_READ;
-	error = __user_walk(library, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
-	if (error)
-		goto out;
 
-	error = -EINVAL;
-	if (!S_ISREG(nd.dentry->d_inode->i_mode))
-		goto exit;
+	FSHOOK_BEGIN_USER_WALK(open,
+		error,
+		library,
+		LOOKUP_FOLLOW|LOOKUP_OPEN,
+		nd,
+		filename,
+		.flags = O_RDONLY)
 
-	error = permission(nd.dentry->d_inode, MAY_READ | MAY_EXEC, &nd);
-	if (error)
-		goto exit;
+	if (!S_ISREG(nd.dentry->d_inode->i_mode))
+		error = -EINVAL;
+	else
+		error = permission(nd.dentry->d_inode, MAY_READ | MAY_EXEC, &nd);
+	if (error) {
+		path_release(&nd);
+		goto out;
+	}
 
 	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
 	error = PTR_ERR(file);
@@ -162,10 +169,10 @@ asmlinkage long sys_uselib(const char __
 	}
 	fput(file);
 out:
+
+	FSHOOK_END_USER_WALK(open, error, filename)
+
   	return error;
-exit:
-	path_release(&nd);
-	goto out;
 }
 
 /*
@@ -485,6 +492,8 @@ struct file *open_exec(const char *name)
 	int err;
 	struct file *file;
 
+	FSHOOK_BEGIN(open, err, .filename = name, .flags = O_RDONLY)
+
 	nd.intent.open.flags = FMODE_READ;
 	err = path_lookup(name, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
 	file = ERR_PTR(err);
@@ -507,13 +516,16 @@ struct file *open_exec(const char *name)
 						file = ERR_PTR(err);
 					}
 				}
-out:
-				return file;
+				goto out;
 			}
 		}
 		path_release(&nd);
 	}
-	goto out;
+out:
+
+	FSHOOK_END(open, err, file = ERR_PTR(err))
+
+	return file;
 }
 
 EXPORT_SYMBOL(open_exec);
diff -urNp linux-2.6.5/fs/fcntl.c linux-2.6.5.SUSE/fs/fcntl.c
--- linux-2.6.5/fs/fcntl.c	2004-04-26 16:50:33.000000000 +0200
+++ linux-2.6.5.SUSE/fs/fcntl.c	2004-04-26 16:54:13.000000000 +0200
@@ -7,6 +7,7 @@
 #include <linux/init.h>
 #include <linux/mm.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/file.h>
 #include <linux/dnotify.h>
 #include <linux/smp_lock.h>
@@ -150,10 +151,15 @@ static int dupfd(struct file *file, unsi
 
 asmlinkage long sys_dup2(unsigned int oldfd, unsigned int newfd)
 {
-	int err = -EBADF;
-	struct file * file, *tofree;
+	int err;
+	struct file * file = NULL;
 	struct files_struct * files = current->files;
 
+	FSHOOK_BEGIN(dup2, err, .oldfd = oldfd, .newfd = newfd)
+
+	struct file * tofree;
+
+	err = -EBADF;
 	spin_lock(&files->file_lock);
 	if (!(file = fcheck(oldfd)))
 		goto out_unlock;
@@ -191,6 +197,9 @@ asmlinkage long sys_dup2(unsigned int ol
 		filp_close(tofree, files);
 	err = newfd;
 out:
+
+	FSHOOK_END(dup2, err)
+
 	return err;
 out_unlock:
 	spin_unlock(&files->file_lock);
@@ -204,11 +213,18 @@ out_fput:
 
 asmlinkage long sys_dup(unsigned int fildes)
 {
-	int ret = -EBADF;
+	int ret;
+
+	FSHOOK_BEGIN(dup, ret, .fd = fildes)
+
 	struct file * file = fget(fildes);
+	ret = -EBADF;
 
 	if (file)
 		ret = dupfd(file, 0);
+
+	FSHOOK_END(dup, ret)
+
 	return ret;
 }
 
@@ -364,22 +380,24 @@ static long do_fcntl(int fd, unsigned in
 asmlinkage long sys_fcntl(int fd, unsigned int cmd, unsigned long arg)
 {	
 	struct file *filp;
-	long err = -EBADF;
+	long err;
 
+	FSHOOK_BEGIN(fcntl, err, .fd = fd, .cmd = cmd, .arg = arg)
+
+	err = -EBADF;
 	filp = fget(fd);
 	if (!filp)
 		goto out;
 
 	err = security_file_fcntl(filp, cmd, arg);
-	if (err) {
-		fput(filp);
-		return err;
-	}
-
-	err = do_fcntl(fd, cmd, arg, filp);
+	if (!err)
+		err = do_fcntl(fd, cmd, arg, filp);
 
  	fput(filp);
 out:
+
+	FSHOOK_END(fcntl, err)
+
 	return err;
 }
 
@@ -389,19 +407,16 @@ asmlinkage long sys_fcntl64(unsigned int
 	struct file * filp;
 	long err;
 
+	FSHOOK_BEGIN(fcntl, err, .fd = fd, .cmd = cmd, .arg = arg)
+
 	err = -EBADF;
 	filp = fget(fd);
 	if (!filp)
 		goto out;
 
 	err = security_file_fcntl(filp, cmd, arg);
-	if (err) {
-		fput(filp);
-		return err;
-	}
-	err = -EBADF;
-	
-	switch (cmd) {
+
+	if (!err) switch (cmd) {
 		case F_GETLK64:
 			err = fcntl_getlk64(filp, (struct flock64 __user *) arg);
 			break;
@@ -413,8 +428,12 @@ asmlinkage long sys_fcntl64(unsigned int
 			err = do_fcntl(fd, cmd, arg, filp);
 			break;
 	}
+
 	fput(filp);
 out:
+
+	FSHOOK_END(fcntl, err)
+
 	return err;
 }
 #endif
diff -urNp linux-2.6.5/fs/fshooks.c linux-2.6.5.SUSE/fs/fshooks.c
--- linux-2.6.5/fs/fshooks.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/fs/fshooks.c	2004-04-26 16:50:54.000000000 +0200
@@ -0,0 +1,143 @@
+/*
+ * fs/fs-writeback.c
+ *
+ * Copyright (C) 2004, Novell, Inc.
+ *
+ * Contains all the fshooks support functions.
+ *
+ */
+
+#include <linux/fshooks.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+
+struct fshook_list fshooks[fshook_COUNT];
+static int initialized;
+
+int fshook_register(enum FShook type, fshook_pre_t *pre, fshook_post_t *post, void *ctx)
+{
+	struct fshook *hook;
+
+	if (unlikely(type < 0 || type >= fshook_COUNT || (!pre && !post)))
+		return -EINVAL;
+	if (unlikely(!initialized))
+		return -EPERM;
+	hook = kmalloc(sizeof(*hook), GFP_KERNEL);
+	if (unlikely(!hook))
+		return -ENOMEM;
+	hook->next = NULL;
+	hook->pre = pre;
+	hook->post = post;
+	hook->ctx = ctx;
+	down_write(&fshooks[type].lock);
+	if (fshooks[type].last)
+		fshooks[type].last->next = hook;
+	else
+		fshooks[type].first = hook;
+	fshooks[type].last = hook;
+	mb();
+	up_write(&fshooks[type].lock);
+	return 0;
+}
+
+EXPORT_SYMBOL(fshook_register);
+
+int fshook_deregister(enum FShook type, fshook_pre_t *pre, fshook_post_t *post, void *ctx)
+{
+	struct fshook *hook, *prev;
+
+	if (unlikely(type < 0 || type >= fshook_COUNT || (!pre && !post)))
+		return -EINVAL;
+	if (unlikely(!initialized))
+		return -EPERM;
+	if (unlikely(!fshooks[type].first))
+		return -ENOENT;
+	down_write(&fshooks[type].lock);
+	for (hook = fshooks[type].first, prev = NULL; hook; hook = (prev = hook)->next) {
+		if (ctx == hook->ctx
+		    && (!pre || !hook->pre || pre == hook->pre)
+		    && (!post || !hook->post || post == hook->post)) {
+			if (pre == hook->pre)
+				hook->pre = NULL;
+			if (post == hook->post)
+				hook->post = NULL;
+			if (!hook->pre && !hook->post) {
+				if (prev)
+					prev->next = hook->next;
+				else
+					fshooks[type].first = hook->next;
+				if (hook == fshooks[type].last)
+					fshooks[type].last = prev;
+			}
+			else
+				prev = hook;
+			break;
+		}
+	}
+	mb();
+	up_write(&fshooks[type].lock);
+	if (unlikely(!hook))
+		return -ENOENT;
+	if (prev != hook)
+		kfree(hook);
+	return 0;
+}
+
+EXPORT_SYMBOL(fshook_deregister);
+
+member_type(struct fshook_generic_info, result) fshook_run_pre(enum FShook type, fshook_info_t info)
+{
+	if (unlikely(type >= fshook_COUNT))
+		BUG();
+	if (fshooks[type].first) {
+		struct fshook_generic_info *gen = (struct fshook_generic_info *)info.gen;
+		const struct fshook *hook;
+
+		gen->type = type;
+		gen->result = 0;
+		down_read(&fshooks[type].lock);
+		for (hook = fshooks[type].first; hook; hook = hook->next) {
+			if (hook->pre) {
+				int err = hook->pre(info, hook->ctx);
+
+				if (!gen->result && err) {
+					gen->result = -abs(err);
+					if (unlikely(!IS_ERR(ERR_PTR(gen->result))))
+						BUG();
+				}
+			}
+		}
+		up_read(&fshooks[type].lock);
+		return info.gen->result;
+	}
+	return 0;
+}
+
+void fshook_run_post(fshook_info_t info, member_type(struct fshook_generic_info, result) result)
+{
+	if (fshooks[info.gen->type].first) {
+		struct fshook_generic_info *gen = (struct fshook_generic_info *)info.gen;
+		const struct fshook *hook;
+
+		gen->result = result;
+		down_read(&fshooks[gen->type].lock);
+		for (hook = fshooks[gen->type].first; hook; hook = hook->next) {
+			if (hook->post)
+				hook->post(info, hook->ctx);
+		}
+		up_read(&fshooks[gen->type].lock);
+	}
+}
+
+#include <linux/init.h>
+
+void __init fshooks_init(void)
+{
+	enum FShook type;
+
+	for (type = 0; type < fshook_COUNT; ++type) {
+		init_rwsem(&fshooks[type].lock);
+	}
+	initialized = 1;
+}
diff -urNp linux-2.6.5/fs/intermezzo/vfs.c linux-2.6.5.SUSE/fs/intermezzo/vfs.c
--- linux-2.6.5/fs/intermezzo/vfs.c	2004-04-26 16:50:33.000000000 +0200
+++ linux-2.6.5.SUSE/fs/intermezzo/vfs.c	2004-04-26 16:50:54.000000000 +0200
@@ -824,7 +824,7 @@ int lento_link(const char * oldname, con
                 struct dentry *new_dentry;
                 struct nameidata nd, old_nd;
 
-                error = __user_walk(oldname, 0, &old_nd);
+                error = __user_walk(oldname, 0, &old_nd, 0);
                 if (error)
                         goto exit;
                 error = path_lookup(to, LOOKUP_PARENT, &nd);
diff -urNp linux-2.6.5/fs/ioctl.c linux-2.6.5.SUSE/fs/ioctl.c
--- linux-2.6.5/fs/ioctl.c	2004-04-04 05:36:26.000000000 +0200
+++ linux-2.6.5.SUSE/fs/ioctl.c	2004-04-26 16:50:54.000000000 +0200
@@ -8,6 +8,7 @@
 #include <linux/smp_lock.h>
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/security.h>
 
 #include <asm/uaccess.h>
@@ -52,8 +53,11 @@ asmlinkage long sys_ioctl(unsigned int f
 {	
 	struct file * filp;
 	unsigned int flag;
-	int on, error = -EBADF;
+	int on, error;
 
+	FSHOOK_BEGIN(ioctl, error, .fd = fd, .cmd = cmd, .arg.value = arg)
+
+	error = -EBADF;
 	filp = fget(fd);
 	if (!filp)
 		goto out;
@@ -130,5 +134,8 @@ asmlinkage long sys_ioctl(unsigned int f
 	fput(filp);
 
 out:
+
+	FSHOOK_END(ioctl, error)
+
 	return error;
 }
diff -urNp linux-2.6.5/fs/locks.c linux-2.6.5.SUSE/fs/locks.c
--- linux-2.6.5/fs/locks.c	2004-04-26 16:50:40.000000000 +0200
+++ linux-2.6.5.SUSE/fs/locks.c	2004-04-26 16:50:54.000000000 +0200
@@ -117,6 +117,7 @@
 #include <linux/capability.h>
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/security.h>
@@ -1320,6 +1321,8 @@ asmlinkage long sys_flock(unsigned int f
 	int can_sleep, unlock;
 	int error;
 
+	FSHOOK_BEGIN(flock, error, .fd = fd, .cmd = cmd)
+
 	error = -EBADF;
 	filp = fget(fd);
 	if (!filp)
@@ -1362,6 +1365,8 @@ asmlinkage long sys_flock(unsigned int f
  out_putf:
 	fput(filp);
  out:
+	FSHOOK_END(flock, error)
+
 	return error;
 }
 
diff -urNp linux-2.6.5/fs/namei.c linux-2.6.5.SUSE/fs/namei.c
--- linux-2.6.5/fs/namei.c	2004-04-04 05:36:55.000000000 +0200
+++ linux-2.6.5.SUSE/fs/namei.c	2004-04-26 16:50:54.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/namei.h>
 #include <linux/quotaops.h>
 #include <linux/pagemap.h>
@@ -971,15 +972,18 @@ access:
  * that namei follows links, while lnamei does not.
  * SMP-safe
  */
-int fastcall __user_walk(const char __user *name, unsigned flags, struct nameidata *nd)
+int fastcall __user_walk(const char __user *name, unsigned flags, struct nameidata *nd, const char **pname)
 {
 	char *tmp = getname(name);
 	int err = PTR_ERR(tmp);
 
 	if (!IS_ERR(tmp)) {
 		err = path_lookup(tmp, flags, nd);
-		putname(tmp);
+		if (!pname)
+			putname(tmp);
 	}
+	if (pname)
+		*pname = tmp;
 	return err;
 }
 
@@ -1466,6 +1470,8 @@ asmlinkage long sys_mknod(const char __u
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
 
+	FSHOOK_BEGIN(mknod, error, .path = tmp, .mode = mode, .dev = dev)
+
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
@@ -1499,6 +1505,8 @@ asmlinkage long sys_mknod(const char __u
 out:
 	putname(tmp);
 
+	FSHOOK_END(mknod, error)
+
 	return error;
 }
 
@@ -1534,6 +1542,9 @@ asmlinkage long sys_mkdir(const char __u
 	tmp = getname(pathname);
 	error = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(mkdir, error, .dirname = tmp, .mode = mode)
+
 		struct dentry *dentry;
 		struct nameidata nd;
 
@@ -1551,6 +1562,9 @@ asmlinkage long sys_mkdir(const char __u
 		up(&nd.dentry->d_inode->i_sem);
 		path_release(&nd);
 out:
+
+		FSHOOK_END(mkdir, error)
+
 		putname(tmp);
 	}
 
@@ -1634,6 +1648,8 @@ asmlinkage long sys_rmdir(const char __u
 	if(IS_ERR(name))
 		return PTR_ERR(name);
 
+	FSHOOK_BEGIN(rmdir, error, .dirname = name)
+
 	error = path_lookup(name, LOOKUP_PARENT, &nd);
 	if (error)
 		goto exit;
@@ -1660,6 +1676,9 @@ asmlinkage long sys_rmdir(const char __u
 exit1:
 	path_release(&nd);
 exit:
+
+	FSHOOK_END(rmdir, error)
+
 	putname(name);
 	return error;
 }
@@ -1712,6 +1731,8 @@ asmlinkage long sys_unlink(const char __
 	if(IS_ERR(name))
 		return PTR_ERR(name);
 
+	FSHOOK_BEGIN(unlink, error, .filename = name)
+
 	error = path_lookup(name, LOOKUP_PARENT, &nd);
 	if (error)
 		goto exit;
@@ -1736,6 +1757,9 @@ asmlinkage long sys_unlink(const char __
 exit1:
 	path_release(&nd);
 exit:
+
+	FSHOOK_END(unlink, error)
+
 	putname(name);
 
 	if (inode)
@@ -1783,6 +1807,9 @@ asmlinkage long sys_symlink(const char _
 	to = getname(newname);
 	error = PTR_ERR(to);
 	if (!IS_ERR(to)) {
+
+		FSHOOK_BEGIN(symlink, error, .oldpath = from, .newpath = to)
+
 		struct dentry *dentry;
 		struct nameidata nd;
 
@@ -1798,6 +1825,9 @@ asmlinkage long sys_symlink(const char _
 		up(&nd.dentry->d_inode->i_sem);
 		path_release(&nd);
 out:
+
+		FSHOOK_END(symlink, error)
+
 		putname(to);
 	}
 	putname(from);
@@ -1864,9 +1894,13 @@ asmlinkage long sys_link(const char __us
 	if (IS_ERR(to))
 		return PTR_ERR(to);
 
-	error = __user_walk(oldname, 0, &old_nd);
-	if (error)
-		goto exit;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(link,
+		error,
+		oldname,
+		old_nd,
+		oldpath,
+		.newpath = to)
+
 	error = path_lookup(to, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
@@ -1884,7 +1918,9 @@ out_release:
 	path_release(&nd);
 out:
 	path_release(&old_nd);
-exit:
+
+	FSHOOK_END_USER_WALK(link, error, oldpath)
+
 	putname(to);
 
 	return error;
@@ -2126,7 +2162,13 @@ asmlinkage long sys_rename(const char __
 	to = getname(newname);
 	error = PTR_ERR(to);
 	if (!IS_ERR(to)) {
+
+		FSHOOK_BEGIN(rename, error, .oldpath = from, .newpath = to)
+
 		error = do_rename(from,to);
+
+		FSHOOK_END(rename, error)
+
 		putname(to);
 	}
 	putname(from);
diff -urNp linux-2.6.5/fs/namespace.c linux-2.6.5.SUSE/fs/namespace.c
--- linux-2.6.5/fs/namespace.c	2004-04-04 05:37:36.000000000 +0200
+++ linux-2.6.5.SUSE/fs/namespace.c	2004-04-26 16:50:54.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/namei.h>
 #include <linux/security.h>
 #include <linux/mount.h>
+#include <linux/fshooks.h>
 #include <asm/uaccess.h>
 
 extern int __init init_rootfs(void);
@@ -378,9 +379,8 @@ asmlinkage long sys_umount(char __user *
 	struct nameidata nd;
 	int retval;
 
-	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
-	if (retval)
-		goto out;
+	FSHOOK_BEGIN_USER_PATH_WALK(umount, retval, name, nd, dirname, .flags = flags)
+
 	retval = -EINVAL;
 	if (nd.dentry != nd.mnt->mnt_root)
 		goto dput_and_out;
@@ -394,7 +394,9 @@ asmlinkage long sys_umount(char __user *
 	retval = do_umount(nd.mnt, flags);
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(umount, retval, dirname)
+
 	return retval;
 }
 
@@ -906,10 +908,21 @@ asmlinkage long sys_mount(char __user * 
 	if (retval < 0)
 		goto out3;
 
+	FSHOOK_BEGIN(mount,
+		retval,
+		.devname = (char *)dev_page,
+		.dirname = dir_page,
+		.type = (char *)type_page,
+		.flags = flags,
+		.data = (void *)data_page)
+
 	lock_kernel();
 	retval = do_mount((char*)dev_page, dir_page, (char*)type_page,
 			  flags, (void*)data_page);
 	unlock_kernel();
+
+	FSHOOK_END(mount, retval)
+
 	free_page(data_page);
 
 out3:
@@ -1016,23 +1029,45 @@ asmlinkage long sys_pivot_root(const cha
 
 	lock_kernel();
 
-	error = __user_walk(new_root, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd);
+#ifdef CONFIG_FSHOOKS
+	{
+	const char *new_path;
+	int new_error;
+
+	new_error = __user_walk(new_root, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd, &new_path);
+	if (new_error) {
+		if (IS_ERR(new_path)) {
+			error = new_error;
+			goto out0;
+		}
+		memset(&new_nd, 0, sizeof(new_nd));
+	}
+#else
+	error = __user_walk(new_root, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd, 0);
 	if (error)
 		goto out0;
-	error = -EINVAL;
-	if (!check_mnt(new_nd.mnt))
-		goto out1;
+#endif
 
-	error = __user_walk(put_old, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &old_nd);
+	FSHOOK_BEGIN_USER_WALK(pivot_root,
+		error,
+		put_old,
+		LOOKUP_FOLLOW|LOOKUP_DIRECTORY,
+		old_nd,
+		oldpath,
+		.newpath = new_path)
+
+#ifdef CONFIG_FSHOOKS
+	if (new_error)
+		error = new_error;
+	else
+#endif
+	if (!check_mnt(new_nd.mnt))
+		error = -EINVAL;
+	else
+		error = security_sb_pivotroot(&old_nd, &new_nd);
 	if (error)
 		goto out1;
 
-	error = security_sb_pivotroot(&old_nd, &new_nd);
-	if (error) {
-		path_release(&old_nd);
-		goto out1;
-	}
-
 	read_lock(&current->fs->lock);
 	user_nd.mnt = mntget(current->fs->rootmnt);
 	user_nd.dentry = dget(current->fs->root);
@@ -1069,8 +1104,11 @@ asmlinkage long sys_pivot_root(const cha
 		}
 		if (!is_subdir(tmp->mnt_mountpoint, new_nd.dentry))
 			goto out3;
-	} else if (!is_subdir(old_nd.dentry, new_nd.dentry))
-		goto out3;
+	} else if (!is_subdir(old_nd.dentry, new_nd.dentry)) {
+out3:
+		spin_unlock(&vfsmount_lock);
+		goto out2;
+	}
 	detach_mnt(new_nd.mnt, &parent_nd);
 	detach_mnt(user_nd.mnt, &root_parent);
 	attach_mnt(user_nd.mnt, &old_nd);
@@ -1085,15 +1123,19 @@ out2:
 	up(&old_nd.dentry->d_inode->i_sem);
 	up_write(&current->namespace->sem);
 	path_release(&user_nd);
-	path_release(&old_nd);
 out1:
+	path_release(&old_nd);
+
+	FSHOOK_END_USER_WALK(pivot_root, error, oldpath)
+#ifdef CONFIG_FSHOOKS
+	putname(new_path);
+	}
+#endif
+
 	path_release(&new_nd);
 out0:
 	unlock_kernel();
 	return error;
-out3:
-	spin_unlock(&vfsmount_lock);
-	goto out2;
 }
 
 static void __init init_mount_tree(void)
diff -urNp linux-2.6.5/fs/open.c linux-2.6.5.SUSE/fs/open.c
--- linux-2.6.5/fs/open.c	2004-04-26 16:50:39.000000000 +0200
+++ linux-2.6.5.SUSE/fs/open.c	2004-04-26 16:50:54.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/vfs.h>
 #include <asm/uaccess.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/pagemap.h>
 
 int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
@@ -117,14 +118,16 @@ asmlinkage long sys_statfs(const char __
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(path, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(statfs, error, path, nd, path)
+
 		struct statfs tmp;
 		error = vfs_statfs_native(nd.dentry->d_inode->i_sb, &tmp);
 		if (!error && copy_to_user(buf, &tmp, sizeof(tmp)))
 			error = -EFAULT;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(statfs, error, path)
+
 	return error;
 }
 
@@ -136,14 +139,17 @@ asmlinkage long sys_statfs64(const char 
 
 	if (sz != sizeof(*buf))
 		return -EINVAL;
-	error = user_path_walk(path, &nd);
-	if (!error) {
+
+	FSHOOK_BEGIN_USER_PATH_WALK(statfs, error, path, nd, path)
+
 		struct statfs64 tmp;
 		error = vfs_statfs64(nd.dentry->d_inode->i_sb, &tmp);
 		if (!error && copy_to_user(buf, &tmp, sizeof(tmp)))
 			error = -EFAULT;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(statfs, error, path)
+
 	return error;
 }
 
@@ -154,6 +160,8 @@ asmlinkage long sys_fstatfs(unsigned int
 	struct statfs tmp;
 	int error;
 
+	FSHOOK_BEGIN(fstatfs, error, .fd = fd)
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -163,6 +171,9 @@ asmlinkage long sys_fstatfs(unsigned int
 		error = -EFAULT;
 	fput(file);
 out:
+
+	FSHOOK_END(fstatfs, error)
+
 	return error;
 }
 
@@ -172,6 +183,8 @@ asmlinkage long sys_fstatfs64(unsigned i
 	struct statfs64 tmp;
 	int error;
 
+	FSHOOK_BEGIN(fstatfs, error, .fd = fd)
+
 	if (sz != sizeof(*buf))
 		return -EINVAL;
 
@@ -184,6 +197,9 @@ asmlinkage long sys_fstatfs64(unsigned i
 		error = -EFAULT;
 	fput(file);
 out:
+
+	FSHOOK_END(fstatfs, error)
+
 	return error;
 }
 
@@ -216,9 +232,8 @@ static inline long do_sys_truncate(const
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_PATH_WALK(truncate, error, path, nd, filename, .length = length)
+
 	inode = nd.dentry->d_inode;
 
 	/* For directories it's -EISDIR, for other non-regulars - -EINVAL */
@@ -262,6 +277,9 @@ static inline long do_sys_truncate(const
 
 dput_and_out:
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(truncate, error, filename)
+
 out:
 	return error;
 }
@@ -279,6 +297,8 @@ static inline long do_sys_ftruncate(unsi
 	struct file * file;
 	int error;
 
+	FSHOOK_BEGIN(ftruncate, error, .fd = fd, .length = length)
+
 	error = -EINVAL;
 	if (length < 0)
 		goto out;
@@ -312,6 +332,9 @@ static inline long do_sys_ftruncate(unsi
 out_putf:
 	fput(file);
 out:
+
+	FSHOOK_END(ftruncate, error);
+
 	return error;
 }
 
@@ -333,29 +356,25 @@ asmlinkage long sys_ftruncate64(unsigned
 }
 #endif
 
-#if !(defined(__alpha__) || defined(__ia64__))
-
-/*
- * sys_utime() can be implemented in user-level using sys_utimes().
- * Is this for backwards compatibility?  If so, why not move it
- * into the appropriate arch directory (for those architectures that
- * need it).
- */
-
 /* If times==NULL, set access and modification to current time,
  * must be owner or have write permission.
  * Else, update from *times, must be owner or super user.
  */
-asmlinkage long sys_utime(char __user * filename, struct utimbuf __user * times)
+long do_utimes(char __user * filename, struct timeval * times)
 {
 	int error;
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_PATH_WALK(utimes,
+		error,
+		filename,
+		nd,
+		path,
+		.atime = times,
+		.mtime = times + !!times)
+
 	inode = nd.dentry->d_inode;
 
 	error = -EROFS;
@@ -366,20 +385,16 @@ asmlinkage long sys_utime(char __user * 
 	newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
 	if (times) {
 		error = -EPERM;
-		if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-			goto dput_and_out;
-
-		error = get_user(newattrs.ia_atime.tv_sec, &times->actime);
-		newattrs.ia_atime.tv_nsec = 0;
-		if (!error) 
-			error = get_user(newattrs.ia_mtime.tv_sec, &times->modtime);
-		newattrs.ia_mtime.tv_nsec = 0;
-		if (error)
-			goto dput_and_out;
+                if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+                        goto dput_and_out;
 
+		newattrs.ia_atime.tv_sec = times[0].tv_sec;
+		newattrs.ia_atime.tv_nsec = times[0].tv_usec * 1000;
+		newattrs.ia_mtime.tv_sec = times[1].tv_sec;
+		newattrs.ia_mtime.tv_nsec = times[1].tv_usec * 1000;
 		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
 	} else {
-                error = -EACCES;
+		error = -EACCES;
                 if (IS_IMMUTABLE(inode))
                         goto dput_and_out;
 
@@ -392,63 +407,44 @@ asmlinkage long sys_utime(char __user * 
 	up(&inode->i_sem);
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(utimes, error, path)
+
 	return error;
 }
 
-#endif
+#if !(defined(__alpha__) || defined(__ia64__))
+
+/*
+ * sys_utime() can be implemented in user-level using sys_utimes().
+ * Is this for backwards compatibility?  If so, why not move it
+ * into the appropriate arch directory (for those architectures that
+ * need it).
+ */
 
 /* If times==NULL, set access and modification to current time,
  * must be owner or have write permission.
  * Else, update from *times, must be owner or super user.
  */
-long do_utimes(char __user * filename, struct timeval * times)
+asmlinkage long sys_utime(char __user * filename, struct utimbuf __user * utime)
 {
-	int error;
-	struct nameidata nd;
-	struct inode * inode;
-	struct iattr newattrs;
-
-	error = user_path_walk(filename, &nd);
-
-	if (error)
-		goto out;
-	inode = nd.dentry->d_inode;
-
-	error = -EROFS;
-	if (IS_RDONLY(inode))
-		goto dput_and_out;
-
-	/* Don't worry, the checks are done in inode_change_ok() */
-	newattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;
-	if (times) {
-		error = -EPERM;
-                if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-                        goto dput_and_out;
+	struct timeval times[2];
 
-		newattrs.ia_atime.tv_sec = times[0].tv_sec;
-		newattrs.ia_atime.tv_nsec = times[0].tv_usec * 1000;
-		newattrs.ia_mtime.tv_sec = times[1].tv_sec;
-		newattrs.ia_mtime.tv_nsec = times[1].tv_usec * 1000;
-		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
-	} else {
-		error = -EACCES;
-                if (IS_IMMUTABLE(inode))
-                        goto dput_and_out;
+	if (utime) {
+		struct utimbuf ktime;
 
-		if (current->fsuid != inode->i_uid &&
-		    (error = permission(inode,MAY_WRITE,&nd)) != 0)
-			goto dput_and_out;
+		if (copy_from_user(&ktime, utime, sizeof(ktime)))
+			return -EFAULT;
+		times[0].tv_sec = ktime.actime;
+		times[0].tv_usec = 0;
+		times[1].tv_sec = ktime.modtime;
+		times[1].tv_usec = 0;
 	}
-	down(&inode->i_sem);
-	error = notify_change(nd.dentry, &newattrs);
-	up(&inode->i_sem);
-dput_and_out:
-	path_release(&nd);
-out:
-	return error;
+	return do_utimes(filename, utime ? times : NULL);
 }
 
+#endif
+
 asmlinkage long sys_utimes(char __user * filename, struct timeval __user * utimes)
 {
 	struct timeval times[2];
@@ -494,15 +490,25 @@ asmlinkage long sys_access(const char __
 	else
 		current->cap_effective = current->cap_permitted;
 
-	res = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_ACCESS, &nd);
-	if (!res) {
+	FSHOOK_BEGIN_USER_WALK(access,
+		res,
+		filename,
+		LOOKUP_FOLLOW|LOOKUP_ACCESS,
+		nd,
+		path,
+		.mode = mode,
+		.actual.fsuid = old_fsuid,
+		.actual.fsgid = old_fsgid,
+		.actual.pcaps = &old_cap)
+
 		res = permission(nd.dentry->d_inode, mode, &nd);
 		/* SuS v2 requires we report a read only fs too */
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(access, res, path)
 
 	current->fsuid = old_fsuid;
 	current->fsgid = old_fsgid;
@@ -516,9 +522,12 @@ asmlinkage long sys_chdir(const char __u
 	struct nameidata nd;
 	int error;
 
-	error = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_WALK(chdir,
+		error,
+		filename,
+		LOOKUP_FOLLOW|LOOKUP_DIRECTORY,
+		nd,
+		dirname)
 
 	error = permission(nd.dentry->d_inode,MAY_EXEC,&nd);
 	if (error)
@@ -528,7 +537,9 @@ asmlinkage long sys_chdir(const char __u
 
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(chdir, error, dirname)
+
 	return error;
 }
 
@@ -540,6 +551,8 @@ asmlinkage long sys_fchdir(unsigned int 
 	struct vfsmount *mnt;
 	int error;
 
+	FSHOOK_BEGIN(fchdir, error, .fd = fd)
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -559,6 +572,9 @@ asmlinkage long sys_fchdir(unsigned int 
 out_putf:
 	fput(file);
 out:
+
+	FSHOOK_END(fchdir, error)
+
 	return error;
 }
 
@@ -567,9 +583,12 @@ asmlinkage long sys_chroot(const char __
 	struct nameidata nd;
 	int error;
 
-	error = __user_walk(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_WALK(chroot,
+		error,
+		filename,
+		LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT,
+		nd,
+		path)
 
 	error = permission(nd.dentry->d_inode,MAY_EXEC,&nd);
 	if (error)
@@ -584,7 +603,9 @@ asmlinkage long sys_chroot(const char __
 	error = 0;
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(chroot, error, path)
+
 	return error;
 }
 
@@ -593,9 +614,12 @@ asmlinkage long sys_fchmod(unsigned int 
 	struct inode * inode;
 	struct dentry * dentry;
 	struct file * file;
-	int err = -EBADF;
+	int err;
 	struct iattr newattrs;
 
+	FSHOOK_BEGIN(fchmod, err, .fd = fd, .mode = mode)
+
+	err = -EBADF;
 	file = fget(fd);
 	if (!file)
 		goto out;
@@ -620,6 +644,9 @@ asmlinkage long sys_fchmod(unsigned int 
 out_putf:
 	fput(file);
 out:
+
+	FSHOOK_END(fchmod, err)
+
 	return err;
 }
 
@@ -630,9 +657,14 @@ asmlinkage long sys_chmod(const char __u
 	int error;
 	struct iattr newattrs;
 
-	error = user_path_walk(filename, &nd);
-	if (error)
-		goto out;
+	FSHOOK_BEGIN_USER_PATH_WALK(chmod,
+		error,
+		filename,
+		nd,
+		path,
+		.mode = mode,
+		.link = false)
+
 	inode = nd.dentry->d_inode;
 
 	error = -EROFS;
@@ -653,7 +685,9 @@ asmlinkage long sys_chmod(const char __u
 
 dput_and_out:
 	path_release(&nd);
-out:
+
+	FSHOOK_END_USER_WALK(chmod, error, path)
+
 	return error;
 }
 
@@ -697,11 +731,20 @@ asmlinkage long sys_chown(const char __u
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(filename, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(chown,
+		error,
+		filename,
+		nd,
+		path,
+		.uid = user,
+		.gid = group,
+		.link = false)
+
 		error = chown_common(nd.dentry, user, group);
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(chown, error, path)
+
 	return error;
 }
 
@@ -710,11 +753,20 @@ asmlinkage long sys_lchown(const char __
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk_link(filename, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(chown,
+		error,
+		filename,
+		nd,
+		path,
+		.uid = user,
+		.gid = group,
+		.link = true)
+
 		error = chown_common(nd.dentry, user, group);
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(chown, error, path)
+
 	return error;
 }
 
@@ -722,13 +774,19 @@ asmlinkage long sys_lchown(const char __
 asmlinkage long sys_fchown(unsigned int fd, uid_t user, gid_t group)
 {
 	struct file * file;
-	int error = -EBADF;
+	int error;
+
+	FSHOOK_BEGIN(fchown, error, .fd = fd, .uid = user, .gid = group)
 
+	error = -EBADF;
 	file = fget(fd);
 	if (file) {
 		error = chown_common(file->f_dentry, user, group);
 		fput(file);
 	}
+
+	FSHOOK_END(fchown, error)
+
 	return error;
 }
 
@@ -937,7 +995,7 @@ EXPORT_SYMBOL(fd_install);
 asmlinkage long sys_open(const char __user * filename, int flags, int mode)
 {
 	char * tmp;
-	int fd, error;
+	int fd;
 
 #if BITS_PER_LONG != 32
 	flags |= O_LARGEFILE;
@@ -945,23 +1003,26 @@ asmlinkage long sys_open(const char __us
 	tmp = getname(filename);
 	fd = PTR_ERR(tmp);
 	if (!IS_ERR(tmp)) {
+
+		FSHOOK_BEGIN(open, fd, .filename = tmp, .flags = flags, .mode = mode)
+
 		fd = get_unused_fd();
 		if (fd >= 0) {
 			struct file *f = filp_open(tmp, flags, mode);
-			error = PTR_ERR(f);
-			if (IS_ERR(f))
-				goto out_error;
-			fd_install(fd, f);
+
+			if (!IS_ERR(f))
+				fd_install(fd, f);
+			else {
+				put_unused_fd(fd);
+				fd = PTR_ERR(f);
+			}
 		}
-out:
+
+		FSHOOK_END(open, fd)
+
 		putname(tmp);
 	}
 	return fd;
-
-out_error:
-	put_unused_fd(fd);
-	fd = error;
-	goto out;
 }
 EXPORT_SYMBOL_GPL(sys_open);
 
@@ -1017,24 +1078,30 @@ EXPORT_SYMBOL(filp_close);
  */
 asmlinkage long sys_close(unsigned int fd)
 {
-	struct file * filp;
+	struct file * filp = NULL;
 	struct files_struct *files = current->files;
+	int error;
 
+	FSHOOK_BEGIN(close, error, .fd = fd)
+
+	error = -EBADF;
 	spin_lock(&files->file_lock);
-	if (fd >= files->max_fds)
-		goto out_unlock;
-	filp = files->fd[fd];
-	if (!filp)
-		goto out_unlock;
-	files->fd[fd] = NULL;
-	FD_CLR(fd, files->close_on_exec);
-	__put_unused_fd(files, fd);
+	if (fd < files->max_fds) {
+		filp = files->fd[fd];
+		if (filp) {
+			files->fd[fd] = NULL;
+			FD_CLR(fd, files->close_on_exec);
+			__put_unused_fd(files, fd);
+			error = 0;
+		}
+	}
 	spin_unlock(&files->file_lock);
-	return filp_close(filp, files);
+	if (!error)
+		error = filp_close(filp, files);
 
-out_unlock:
-	spin_unlock(&files->file_lock);
-	return -EBADF;
+	FSHOOK_END(close, error)
+
+	return error;
 }
 
 EXPORT_SYMBOL(sys_close);
diff -urNp linux-2.6.5/fs/pipe.c linux-2.6.5.SUSE/fs/pipe.c
--- linux-2.6.5/fs/pipe.c	2004-04-26 16:50:38.000000000 +0200
+++ linux-2.6.5.SUSE/fs/pipe.c	2004-04-26 16:50:54.000000000 +0200
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/mount.h>
 #include <linux/pipe_fs_i.h>
 #include <linux/uio.h>
@@ -671,12 +672,15 @@ fail_inode:
 
 int do_pipe(int *fd)
 {
+	int error;
+
+	FSHOOK_BEGIN(pipe, error, .fds = fd)
+
 	struct qstr this;
 	char name[32];
 	struct dentry *dentry;
 	struct inode * inode;
 	struct file *f1, *f2;
-	int error;
 	int i,j;
 
 	error = -ENFILE;
@@ -733,7 +737,8 @@ int do_pipe(int *fd)
 	fd_install(j, f2);
 	fd[0] = i;
 	fd[1] = j;
-	return 0;
+	error = 0;
+	goto no_files;
 
 close_f12_inode_i_j:
 	put_unused_fd(j);
@@ -749,6 +754,8 @@ close_f12:
 close_f1:
 	put_filp(f1);
 no_files:
+	FSHOOK_END(pipe, error)
+
 	return error;	
 }
 
diff -urNp linux-2.6.5/fs/read_write.c linux-2.6.5.SUSE/fs/read_write.c
--- linux-2.6.5/fs/read_write.c	2004-04-26 16:50:36.000000000 +0200
+++ linux-2.6.5.SUSE/fs/read_write.c	2004-04-26 16:50:54.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/dnotify.h>
 #include <linux/security.h>
 #include <linux/module.h>
+#include <linux/fshooks.h>
 
 #include <asm/uaccess.h>
 
@@ -126,6 +127,14 @@ asmlinkage off_t sys_lseek(unsigned int 
 	off_t retval;
 	struct file * file;
 	int fput_needed;
+	loff_t res;
+
+	FSHOOK_BEGIN(lseek,
+		retval,
+		.fd = fd,
+		.offset = offset,
+		.poffs = &res,
+		.whence = origin)
 
 	retval = -EBADF;
 	file = fget_light(fd, &fput_needed);
@@ -134,13 +143,15 @@ asmlinkage off_t sys_lseek(unsigned int 
 
 	retval = -EINVAL;
 	if (origin <= 2) {
-		loff_t res = llseek(file, offset, origin);
+		res = llseek(file, offset, origin);
 		retval = res;
 		if (res != (loff_t)retval)
 			retval = -EOVERFLOW;	/* LFS: should only happen on 32 bit platforms */
 	}
 	fput_light(file, fput_needed);
 bad:
+	FSHOOK_END(lseek, retval >= 0 ? 0 : retval)
+
 	return retval;
 }
 EXPORT_SYMBOL_GPL(sys_lseek);
@@ -155,6 +166,13 @@ asmlinkage long sys_llseek(unsigned int 
 	loff_t offset;
 	int fput_needed;
 
+	FSHOOK_BEGIN(lseek,
+		retval,
+		.fd = fd,
+		.offset = ((loff_t)offset_high << 32) | offset_low,
+		.poffs = &offset,
+		.whence = origin)
+
 	retval = -EBADF;
 	file = fget_light(fd, &fput_needed);
 	if (!file)
@@ -176,6 +194,8 @@ asmlinkage long sys_llseek(unsigned int 
 out_putf:
 	fput_light(file, fput_needed);
 bad:
+	FSHOOK_END(lseek, retval >= 0 ? 0 : retval)
+
 	return retval;
 }
 #endif
@@ -271,15 +291,20 @@ EXPORT_SYMBOL(vfs_write);
 asmlinkage ssize_t sys_read(unsigned int fd, char __user * buf, size_t count)
 {
 	struct file *file;
-	ssize_t ret = -EBADF;
+	ssize_t ret;
 	int fput_needed;
 
+	FSHOOK_BEGIN(read, ret, .fd = fd, .buffer = buf, .length = count, .plen = &ret)
+
+	ret = -EBADF;
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = vfs_read(file, buf, count, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
 
+	FSHOOK_END(read, ret >= 0 ? 0 : ret)
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(sys_read);
@@ -287,15 +312,20 @@ EXPORT_SYMBOL_GPL(sys_read);
 asmlinkage ssize_t sys_write(unsigned int fd, const char __user * buf, size_t count)
 {
 	struct file *file;
-	ssize_t ret = -EBADF;
+	ssize_t ret;
 	int fput_needed;
 
+	FSHOOK_BEGIN(write, ret, .fd = fd, .buffer = buf, .length = count, .plen = &ret)
+
+	ret = -EBADF;
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = vfs_write(file, buf, count, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
 
+	FSHOOK_END(write, ret >= 0 ? 0 : ret)
+
 	return ret;
 }
 
@@ -303,11 +333,16 @@ asmlinkage ssize_t sys_pread64(unsigned 
 			     size_t count, loff_t pos)
 {
 	struct file *file;
-	ssize_t ret = -EBADF;
+	ssize_t ret;
 	int fput_needed;
 
-	if (pos < 0)
-		return -EINVAL;
+	FSHOOK_BEGIN(pread, ret, .fd = fd, .offset = pos, .buffer = buf, .length = count, .plen = &ret)
+
+	ret = -EBADF;
+	if (pos < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
@@ -315,6 +350,9 @@ asmlinkage ssize_t sys_pread64(unsigned 
 		fput_light(file, fput_needed);
 	}
 
+out:
+	FSHOOK_END(pread, ret >= 0 ? 0 : ret)
+
 	return ret;
 }
 
@@ -322,11 +360,16 @@ asmlinkage ssize_t sys_pwrite64(unsigned
 			      size_t count, loff_t pos)
 {
 	struct file *file;
-	ssize_t ret = -EBADF;
+	ssize_t ret;
 	int fput_needed;
 
-	if (pos < 0)
-		return -EINVAL;
+	FSHOOK_BEGIN(pwrite, ret, .fd = fd, .offset = pos, .buffer = buf, .length = count, .plen = &ret)
+
+	ret = -EBADF;
+	if (pos < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
@@ -334,6 +377,9 @@ asmlinkage ssize_t sys_pwrite64(unsigned
 		fput_light(file, fput_needed);
 	}
 
+out:
+	FSHOOK_END(pwrite, ret >= 0 ? 0 : ret)
+
 	return ret;
 }
 
@@ -509,15 +555,20 @@ asmlinkage ssize_t
 sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen)
 {
 	struct file *file;
-	ssize_t ret = -EBADF;
+	ssize_t ret;
 	int fput_needed;
 
+	FSHOOK_BEGIN(readv, ret, .fd = fd, .vector = vec, .count = vlen, .plen = &ret)
+
+	ret = -EBADF;
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = vfs_readv(file, vec, vlen, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
 
+	FSHOOK_END(readv, ret >= 0 ? 0 : ret)
+
 	return ret;
 }
 
@@ -525,15 +576,20 @@ asmlinkage ssize_t
 sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen)
 {
 	struct file *file;
-	ssize_t ret = -EBADF;
+	ssize_t ret;
 	int fput_needed;
 
+	FSHOOK_BEGIN(writev, ret, .fd = fd, .vector = vec, .count = vlen, .plen = &ret)
+
+	ret = -EBADF;
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = vfs_writev(file, vec, vlen, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
 
+	FSHOOK_END(writev, ret >= 0 ? 0 : ret)
+
 	return ret;
 }
 
@@ -546,6 +602,14 @@ static ssize_t do_sendfile(int out_fd, i
 	ssize_t retval;
 	int fput_needed_in, fput_needed_out;
 
+	FSHOOK_BEGIN(sendfile,
+		retval,
+		.infd = in_fd,
+		.outfd = out_fd,
+		.length = count,
+		.poffs = ppos,
+		.plen = &retval)
+
 	/*
 	 * Get input file, and verify that it is ok..
 	 */
@@ -616,6 +680,8 @@ fput_out:
 fput_in:
 	fput_light(in_file, fput_needed_in);
 out:
+	FSHOOK_END(sendfile, retval >= 0 ? 0 : retval)
+
 	return retval;
 }
 
diff -urNp linux-2.6.5/fs/readdir.c linux-2.6.5.SUSE/fs/readdir.c
--- linux-2.6.5/fs/readdir.c	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5.SUSE/fs/readdir.c	2004-04-26 16:50:54.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/file.h>
 #include <linux/smp_lock.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/dirent.h>
 #include <linux/security.h>
 
@@ -98,6 +99,8 @@ asmlinkage long old_readdir(unsigned int
 	struct file * file;
 	struct readdir_callback buf;
 
+	FSHOOK_BEGIN(readdir, error, .fd = fd, .buffer = dirent, .count = count, .legacy = true)
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -112,6 +115,8 @@ asmlinkage long old_readdir(unsigned int
 
 	fput(file);
 out:
+	FSHOOK_END(readdir, error)
+
 	return error;
 }
 
@@ -178,6 +183,8 @@ asmlinkage long sys_getdents(unsigned in
 	struct getdents_callback buf;
 	int error;
 
+	FSHOOK_BEGIN(readdir, error, .fd = fd, .buffer = dirent, .count = count)
+
 	error = -EFAULT;
 	if (!access_ok(VERIFY_WRITE, dirent, count))
 		goto out;
@@ -207,6 +214,8 @@ asmlinkage long sys_getdents(unsigned in
 out_putf:
 	fput(file);
 out:
+	FSHOOK_END(readdir, error)
+
 	return error;
 }
 
@@ -264,6 +273,8 @@ asmlinkage long sys_getdents64(unsigned 
 	struct getdents_callback64 buf;
 	int error;
 
+	FSHOOK_BEGIN(readdir, error, .fd = fd, .buffer = dirent, .count = count, .large = true)
+
 	error = -EFAULT;
 	if (!access_ok(VERIFY_WRITE, dirent, count))
 		goto out;
@@ -292,5 +303,7 @@ asmlinkage long sys_getdents64(unsigned 
 out_putf:
 	fput(file);
 out:
+	FSHOOK_END(readdir, error)
+
 	return error;
 }
diff -urNp linux-2.6.5/fs/select.c linux-2.6.5.SUSE/fs/select.c
--- linux-2.6.5/fs/select.c	2004-04-26 16:50:38.000000000 +0200
+++ linux-2.6.5.SUSE/fs/select.c	2004-04-26 16:50:54.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/personality.h> /* for STICKY_TIMEOUTS */
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/aio.h>
 
 #include <asm/uaccess.h>
@@ -213,12 +214,14 @@ int do_select(int n, fd_set_bits *fds, l
 	int retval, i;
 	long __timeout = *timeout;
 
+	FSHOOK_BEGIN(select, retval, .n = n, .fds = fds, .timeout = __timeout)
+
  	spin_lock(&current->files->file_lock);
 	retval = max_select_fd(n, fds);
 	spin_unlock(&current->files->file_lock);
 
 	if (retval < 0)
-		return retval;
+		goto out;
 	n = retval;
 
 	poll_initwait(&table);
@@ -297,6 +300,9 @@ int do_select(int n, fd_set_bits *fds, l
 	 * Up-to-date the caller timeout.
 	 */
 	*timeout = __timeout;
+out:
+	FSHOOK_END(select, retval)
+
 	return retval;
 }
 
@@ -464,6 +470,8 @@ static int do_poll(unsigned int nfds,  s
 
 	if (!timeout)
 		pt = NULL;
+
+	FSHOOK_BEGIN(poll, count, .n = nfds, .list = list, .timeout = timeout)
  
 	for (;;) {
 		struct poll_list *walk;
@@ -482,6 +490,9 @@ static int do_poll(unsigned int nfds,  s
 		timeout = schedule_timeout(timeout);
 	}
 	__set_current_state(TASK_RUNNING);
+
+	FSHOOK_END(poll, count)
+
 	return count;
 }
 
diff -urNp linux-2.6.5/fs/stat.c linux-2.6.5.SUSE/fs/stat.c
--- linux-2.6.5/fs/stat.c	2004-04-04 05:36:26.000000000 +0200
+++ linux-2.6.5.SUSE/fs/stat.c	2004-04-26 16:50:54.000000000 +0200
@@ -12,6 +12,7 @@
 #include <linux/smp_lock.h>
 #include <linux/highuid.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/namei.h>
 #include <linux/security.h>
 
@@ -66,11 +67,13 @@ int vfs_stat(char __user *name, struct k
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(name, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK(stat, error, name, nd, path, .link = false)
+
 		error = vfs_getattr(nd.mnt, nd.dentry, stat);
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(stat, error, path)
+
 	return error;
 }
 
@@ -81,11 +84,13 @@ int vfs_lstat(char __user *name, struct 
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk_link(name, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(stat, error, name, nd, path, .link = true)
+
 		error = vfs_getattr(nd.mnt, nd.dentry, stat);
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(stat, error, path)
+
 	return error;
 }
 
@@ -93,13 +98,20 @@ EXPORT_SYMBOL(vfs_lstat);
 
 int vfs_fstat(unsigned int fd, struct kstat *stat)
 {
+	int error;
+
+	FSHOOK_BEGIN(fstat, error, .fd = fd)
+
 	struct file *f = fget(fd);
-	int error = -EBADF;
 
+	error = -EBADF;
 	if (f) {
 		error = vfs_getattr(f->f_vfsmnt, f->f_dentry, stat);
 		fput(f);
 	}
+
+	FSHOOK_END(fstat, error)	
+
 	return error;
 }
 
@@ -264,8 +276,8 @@ asmlinkage long sys_readlink(const char 
 	if (bufsiz <= 0)
 		return -EINVAL;
 
-	error = user_path_walk_link(path, &nd);
-	if (!error) {
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(readlink, error, path, nd, path)
+
 		struct inode * inode = nd.dentry->d_inode;
 
 		error = -EINVAL;
@@ -277,7 +289,9 @@ asmlinkage long sys_readlink(const char 
 			}
 		}
 		path_release(&nd);
-	}
+
+	FSHOOK_END_USER_WALK(readlink, error, path)
+
 	return error;
 }
 
diff -urNp linux-2.6.5/fs/xattr.c linux-2.6.5.SUSE/fs/xattr.c
--- linux-2.6.5/fs/xattr.c	2004-04-04 05:36:57.000000000 +0200
+++ linux-2.6.5.SUSE/fs/xattr.c	2004-04-26 16:50:54.000000000 +0200
@@ -7,6 +7,7 @@
   Copyright (C) 2001 SGI - Silicon Graphics, Inc <linux-xfs@oss.sgi.com>
  */
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/file.h>
@@ -71,11 +72,22 @@ sys_setxattr(char __user *path, char __u
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK(setxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.value = value,
+		.size = size,
+		.flags = flags,
+		.link = false)
+
 	error = setxattr(nd.dentry, name, value, size, flags);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(setxattr, error, path)
+
 	return error;
 }
 
@@ -86,11 +98,22 @@ sys_lsetxattr(char __user *path, char __
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk_link(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(setxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.value = value,
+		.size = size,
+		.flags = flags,
+		.link = true)
+
 	error = setxattr(nd.dentry, name, value, size, flags);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(setxattr, error, path)
+
 	return error;
 }
 
@@ -99,13 +122,26 @@ sys_fsetxattr(int fd, char __user *name,
 	      size_t size, int flags)
 {
 	struct file *f;
-	int error = -EBADF;
+	int error;
+
+	FSHOOK_BEGIN(fsetxattr,
+		error,
+		.fd = fd,
+		.name = name,
+		.value = value,
+		.size = size,
+		.flags = flags)
 
 	f = fget(fd);
-	if (!f)
-		return error;
-	error = setxattr(f->f_dentry, name, value, size, flags);
-	fput(f);
+	if (f) {
+		error = setxattr(f->f_dentry, name, value, size, flags);
+		fput(f);
+	}
+	else
+		error = -EBADF;
+
+	FSHOOK_END(fsetxattr, error)
+
 	return error;
 }
 
@@ -161,11 +197,19 @@ sys_getxattr(char __user *path, char __u
 	struct nameidata nd;
 	ssize_t error;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK(getxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.link = false)
+
 	error = getxattr(nd.dentry, name, value, size);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(getxattr, error, path)
+
 	return error;
 }
 
@@ -176,11 +220,19 @@ sys_lgetxattr(char __user *path, char __
 	struct nameidata nd;
 	ssize_t error;
 
-	error = user_path_walk_link(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(getxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.link = true)
+
 	error = getxattr(nd.dentry, name, value, size);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(getxattr, error, path)
+
 	return error;
 }
 
@@ -188,13 +240,20 @@ asmlinkage ssize_t
 sys_fgetxattr(int fd, char __user *name, void __user *value, size_t size)
 {
 	struct file *f;
-	ssize_t error = -EBADF;
+	ssize_t error;
+
+	FSHOOK_BEGIN(fgetxattr, error, .fd = fd, .name = name)
 
 	f = fget(fd);
-	if (!f)
-		return error;
-	error = getxattr(f->f_dentry, name, value, size);
-	fput(f);
+	if (f) {
+		error = getxattr(f->f_dentry, name, value, size);
+		fput(f);
+	}
+	else
+		error = -EBADF;
+
+	FSHOOK_END(fgetxattr, error)
+
 	return error;
 }
 
@@ -242,11 +301,18 @@ sys_listxattr(char __user *path, char __
 	struct nameidata nd;
 	ssize_t error;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK(listxattr,
+		error,
+		path,
+		nd,
+		path,
+		.link = false)
+
 	error = listxattr(nd.dentry, list, size);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(listxattr, error, path)
+
 	return error;
 }
 
@@ -256,11 +322,18 @@ sys_llistxattr(char __user *path, char _
 	struct nameidata nd;
 	ssize_t error;
 
-	error = user_path_walk_link(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(listxattr,
+		error,
+		path,
+		nd,
+		path,
+		.link = true)
+
 	error = listxattr(nd.dentry, list, size);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(listxattr, error, path)
+
 	return error;
 }
 
@@ -268,13 +341,20 @@ asmlinkage ssize_t
 sys_flistxattr(int fd, char __user *list, size_t size)
 {
 	struct file *f;
-	ssize_t error = -EBADF;
+	ssize_t error;
+
+	FSHOOK_BEGIN(flistxattr, error, .fd = fd)
 
 	f = fget(fd);
-	if (!f)
-		return error;
-	error = listxattr(f->f_dentry, list, size);
-	fput(f);
+	if (f) {
+		error = listxattr(f->f_dentry, list, size);
+		fput(f);
+	}
+	else
+		error = -EBADF;
+
+	FSHOOK_END(flistxattr, error)
+
 	return error;
 }
 
@@ -312,11 +392,19 @@ sys_removexattr(char __user *path, char 
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK(rmxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.link = false)
+
 	error = removexattr(nd.dentry, name);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(rmxattr, error, path)
+
 	return error;
 }
 
@@ -326,11 +414,19 @@ sys_lremovexattr(char __user *path, char
 	struct nameidata nd;
 	int error;
 
-	error = user_path_walk_link(path, &nd);
-	if (error)
-		return error;
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(rmxattr,
+		error,
+		path,
+		nd,
+		path,
+		.name = name,
+		.link = true)
+
 	error = removexattr(nd.dentry, name);
 	path_release(&nd);
+
+	FSHOOK_END_USER_WALK(rmxattr, error, path)
+
 	return error;
 }
 
@@ -338,12 +434,19 @@ asmlinkage long
 sys_fremovexattr(int fd, char __user *name)
 {
 	struct file *f;
-	int error = -EBADF;
+	int error;
+
+	FSHOOK_BEGIN(frmxattr, error, .fd = fd, .name = name)
 
 	f = fget(fd);
-	if (!f)
-		return error;
-	error = removexattr(f->f_dentry, name);
-	fput(f);
+	if (f) {
+		error = removexattr(f->f_dentry, name);
+		fput(f);
+	}
+	else
+		error = -EBADF;
+
+	FSHOOK_END(frmxattr, error)
+
 	return error;
 }
diff -urNp linux-2.6.5/include/linux/fshooks.h linux-2.6.5.SUSE/include/linux/fshooks.h
--- linux-2.6.5/include/linux/fshooks.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/include/linux/fshooks.h	2004-04-26 16:50:54.000000000 +0200
@@ -0,0 +1,481 @@
+#ifndef _LINUX_FSHOOKS_H
+#define _LINUX_FSHOOKS_H
+
+/*
+ * This file has definitions for file system hooks.
+ */
+
+#include <linux/config.h>
+
+#ifdef CONFIG_FSHOOKS
+
+#include <linux/poll.h>
+#include <linux/rwsem.h>
+
+enum FShook {
+#define FSHOOK_DEFINE(type, fields...) FSHOOK_##type,
+#include <linux/fshooks.h>
+	fshook_COUNT /* keep this last */
+};
+
+/* for the lack of a kernel-wide definition */
+typedef enum {
+	false,
+	true
+} boolean_t __attribute__((__mode__(__QI__)));
+
+typedef union fshook_info {
+	struct fshook_generic_info {
+		enum FShook type;
+		int result;
+	} const *gen;
+#define FSHOOK_DEFINE(type, fields...) \
+	struct fshook_##type##_info { \
+		struct fshook_generic_info gen; \
+		fields \
+	} const *type;
+#include <linux/fshooks.h>
+} fshook_info_t __attribute__((__transparent_union__));
+
+typedef int fshook_pre_t(fshook_info_t info, void *ctx);
+typedef void fshook_post_t(fshook_info_t info, void *ctx);
+
+int fshook_register(enum FShook, fshook_pre_t *, fshook_post_t *, void *);
+int fshook_deregister(enum FShook, fshook_pre_t *, fshook_post_t *, void *);
+
+#ifndef MODULE
+
+struct fshook {
+	struct fshook *next;
+	void *ctx;
+	fshook_pre_t *pre;
+	fshook_post_t *post;
+};
+
+struct fshook_list {
+	struct fshook *first;
+	struct fshook *last;
+	struct rw_semaphore lock;
+};
+
+extern struct fshook_list fshooks[fshook_COUNT];
+
+member_type(struct fshook_generic_info, result) fshook_run_pre(enum FShook type, fshook_info_t info);
+void fshook_run_post(fshook_info_t info, member_type(struct fshook_generic_info, result) result);
+
+/* there must not be semicolons after the invocations of FSHOOK_BEGIN/FSHOOK_END */
+#define FSHOOK_BEGIN(type, result, args...) { \
+		struct fshook_##type##_info info = { args }; \
+		\
+		if (!fshooks[FSHOOK_##type].first \
+		   || !(result = (__typeof__(result))fshook_run_pre(FSHOOK_##type, &info))) {
+
+#define FSHOOK_END(type, result, errcode...) \
+			(void)(&info != (struct fshook_##type##_info *)-1L); \
+		} \
+		else { \
+			errcode; \
+		} \
+		if (fshooks[FSHOOK_##type].first) \
+			fshook_run_post(&info, result); \
+	}
+
+#define FSHOOK_BEGIN_USER_WALK_COMMON(type, err, walk, nd, args...) { \
+		struct fshook_##type##_info info = { args }; \
+		if (!(err = walk)) { \
+			if(unlikely(fshooks[FSHOOK_##type].first \
+		        && (err = (__typeof__(err))fshook_run_pre(FSHOOK_##type, &info)) != 0)) \
+				path_release(&nd); \
+			else {
+
+#define FSHOOK_BEGIN_USER_WALK(type, err, path, flags, nd, field, args...) \
+		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk(path, flags, &nd, &info.field), nd, args)
+
+#define FSHOOK_BEGIN_USER_PATH_WALK(type, err, path, nd, field, args...) \
+		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk(path, LOOKUP_FOLLOW, &nd, &info.field), nd, args)
+
+#define FSHOOK_BEGIN_USER_PATH_WALK_LINK(type, err, path, nd, field, args...) \
+		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk(path, 0, &nd, &info.field), nd, args)
+
+#define FSHOOK_END_USER_WALK(type, err, field) \
+				(void)(&info != (struct fshook_##type##_info *)-1L); \
+			} \
+		} \
+		else if (!IS_ERR(info.field) && fshooks[FSHOOK_##type].first) { \
+			__typeof__(err) fshook_err = (__typeof__(err))fshook_run_pre(FSHOOK_##type, &info); \
+			\
+			/* simulate normal (hooks precede path resolution) sequence of operation */ \
+			if (fshook_err) err = fshook_err; \
+		} \
+		if (!IS_ERR(info.field)) { \
+			if (fshooks[FSHOOK_##type].first) \
+				fshook_run_post(&info, err); \
+			putname(info.field); \
+		} \
+	}
+
+#endif /* MODULE */
+
+#else /* ndef CONFIG_FSHOOKS */
+
+#ifndef MODULE
+
+#define FSHOOK_BEGIN(type, result, args...) {
+
+#define FSHOOK_END(type, result, errcode...) ((void)0);}
+
+#define FSHOOK_BEGIN_USER_WALK(type, err, path, flags, nd, field, args...) \
+	if (!(err = __user_walk(path, flags, &nd, 0))) {
+
+#define FSHOOK_BEGIN_USER_PATH_WALK(type, err, path, nd, field, args...) \
+	if (!(err = user_path_walk(path, &nd))) {
+
+#define FSHOOK_BEGIN_USER_PATH_WALK_LINK(type, err, path, nd, field, args...) \
+	if (!(err = user_path_walk_link(path, &nd))) {
+
+#define FSHOOK_END_USER_WALK(type, err, field) ((void)0);}
+
+#endif /* MODULE */
+
+#endif /* CONFIG_FSHOOKS */
+
+#elif defined(FSHOOK_DEFINE)
+
+FSHOOK_DEFINE(access,
+	const char *path;
+	int mode;
+	struct {
+		uid_t fsuid;
+		gid_t fsgid;
+		const kernel_cap_t *pcaps;
+	} actual;
+)
+
+FSHOOK_DEFINE(chdir,
+	const char *dirname;
+)
+
+FSHOOK_DEFINE(chmod,
+	const char *path;
+	mode_t mode;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(chown,
+	const char *path;
+	uid_t uid;
+	gid_t gid;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(chroot,
+	const char *path;
+)
+
+FSHOOK_DEFINE(close,
+	int fd;
+)
+
+FSHOOK_DEFINE(dup,
+	int fd;
+)
+
+FSHOOK_DEFINE(dup2,
+	int oldfd;
+	int newfd;
+)
+
+FSHOOK_DEFINE(fadvise,
+	int fd;
+	loff_t offset;
+	loff_t len;
+	int advice;
+)
+
+FSHOOK_DEFINE(fchdir,
+	int fd;
+)
+
+FSHOOK_DEFINE(fchmod,
+	int fd;
+	mode_t mode;
+)
+
+FSHOOK_DEFINE(fchown,
+	int fd;
+	uid_t uid;
+	gid_t gid;
+)
+
+FSHOOK_DEFINE(fcntl,
+	int fd;
+	unsigned cmd;
+	unsigned long arg;
+)
+
+FSHOOK_DEFINE(fgetxattr,
+	int fd;
+	const char __user *name;
+)
+
+FSHOOK_DEFINE(flistxattr,
+	int fd;
+)
+
+FSHOOK_DEFINE(flock,
+	int fd;
+	unsigned cmd;
+)
+
+FSHOOK_DEFINE(frmxattr,
+	int fd;
+	const char __user *name;
+)
+
+FSHOOK_DEFINE(fsetxattr,
+	int fd;
+	const char __user *name;
+	const void __user *value;
+	size_t size;
+	unsigned flags;
+)
+
+FSHOOK_DEFINE(fstat,
+	int fd;
+)
+
+FSHOOK_DEFINE(fstatfs,
+	int fd;
+)
+
+FSHOOK_DEFINE(fsync,
+	int fd;
+	boolean_t data;
+)
+
+FSHOOK_DEFINE(ftruncate,
+	int fd;
+	loff_t length;
+)
+
+FSHOOK_DEFINE(getxattr,
+	const char *path;
+	const char __user *name;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(ioctl,
+	int fd;
+	unsigned cmd;
+	union {
+		unsigned long value;
+		const void __user *ptr;
+	} arg;
+)
+
+FSHOOK_DEFINE(link,
+	const char *oldpath;
+	const char *newpath;
+)
+
+FSHOOK_DEFINE(listxattr,
+	const char *path;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(lseek,
+	int fd;
+	unsigned whence;
+	loff_t offset;
+	const loff_t *poffs;
+)
+
+FSHOOK_DEFINE(mkdir,
+	const char *dirname;
+	mode_t mode;
+)
+
+FSHOOK_DEFINE(mknod,
+	const char *path;
+	mode_t mode;
+	dev_t dev;
+)
+
+FSHOOK_DEFINE(mmap,
+	const unsigned long *paddr;
+	unsigned long length;
+	unsigned prot;
+	unsigned flags;
+	int fd;
+	loff_t offset;
+)
+
+FSHOOK_DEFINE(mount,
+	const char *devname;
+	const char *dirname;
+	const char *type;
+	unsigned long flags;
+	const void *data;
+)
+
+FSHOOK_DEFINE(open,
+	const char *filename;
+	int flags;
+	int mode;
+)
+
+FSHOOK_DEFINE(pipe,
+	const int *fds;
+)
+
+FSHOOK_DEFINE(pivot_root,
+	const char *oldpath;
+	const char *newpath;
+)
+
+FSHOOK_DEFINE(poll,
+	int n;
+	const struct poll_list *list;
+	long timeout;
+)
+
+FSHOOK_DEFINE(pread,
+	int fd;
+	const void __user *buffer;
+	size_t length;
+	loff_t offset;
+	const ssize_t *plen;
+)
+
+FSHOOK_DEFINE(pwrite,
+	int fd;
+	const void __user *buffer;
+	size_t length;
+	loff_t offset;
+	const ssize_t *plen;
+)
+
+FSHOOK_DEFINE(readahead,
+	int fd;
+	loff_t offset;
+	size_t length;
+)
+
+FSHOOK_DEFINE(read,
+	int fd;
+	const void __user *buffer;
+	size_t length;
+	const ssize_t *plen;
+)
+
+FSHOOK_DEFINE(readdir,
+	int fd;
+	const void __user *buffer;
+	unsigned count;
+	boolean_t large;
+	boolean_t legacy;
+)
+
+FSHOOK_DEFINE(readlink,
+	const char *path;
+)
+
+FSHOOK_DEFINE(readv,
+	int fd;
+	const struct iovec __user *vector;
+	unsigned long count;
+	const ssize_t *plen;
+)
+
+FSHOOK_DEFINE(rename,
+	const char *oldpath;
+	const char *newpath;
+)
+
+FSHOOK_DEFINE(rmdir,
+	const char *dirname;
+)
+
+FSHOOK_DEFINE(rmxattr,
+	const char *path;
+	const char __user *name;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(select,
+	int n;
+	const fd_set_bits *fds;
+	long timeout;
+)
+
+FSHOOK_DEFINE(sendfile,
+	int infd;
+	int outfd;
+	size_t length;
+	const loff_t *poffs;
+	const ssize_t *plen;
+)
+
+FSHOOK_DEFINE(setxattr,
+	const char *path;
+	const char __user *name;
+	const void __user *value;
+	size_t size;
+	unsigned flags;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(stat,
+	const char *path;
+	boolean_t link;
+)
+
+FSHOOK_DEFINE(statfs,
+	const char *path;
+)
+
+FSHOOK_DEFINE(symlink,
+	const char *oldpath;
+	const char *newpath;
+)
+
+FSHOOK_DEFINE(sync,
+)
+
+FSHOOK_DEFINE(truncate,
+	const char *filename;
+	loff_t length;
+)
+
+FSHOOK_DEFINE(umount,
+	const char *dirname;
+	int flags;
+)
+
+FSHOOK_DEFINE(unlink,
+	const char *filename;
+)
+
+FSHOOK_DEFINE(utimes,
+	const char *path;
+	const struct timeval *atime;
+	const struct timeval *mtime;
+)
+
+FSHOOK_DEFINE(write,
+	int fd;
+	const void __user *buffer;
+	size_t length;
+	const ssize_t *plen;
+)
+
+FSHOOK_DEFINE(writev,
+	int fd;
+	const struct iovec __user *vector;
+	unsigned long count;
+	const ssize_t *plen;
+)
+
+#undef FSHOOK_DEFINE
+
+#endif /* _LINUX_FSHOOKS_H / FSHOOK_DEFINE */
diff -urNp linux-2.6.5/include/linux/kernel.h linux-2.6.5.SUSE/include/linux/kernel.h
--- linux-2.6.5/include/linux/kernel.h	2004-04-26 16:50:35.000000000 +0200
+++ linux-2.6.5.SUSE/include/linux/kernel.h	2004-04-26 16:50:54.000000000 +0200
@@ -200,6 +200,15 @@ extern void dump_stack(void);
 
 
 /**
+ * member_type - get the type of a member of a structure
+ *
+ * @type:	the type of the struct.
+ * @member:	the name of the member within the struct.
+ *
+ */
+#define member_type(type, member) __typeof__( ((type *)0)->member )
+
+/**
  * container_of - cast a member of a structure out to the containing structure
  *
  * @ptr:	the pointer to the member.
@@ -208,7 +217,7 @@ extern void dump_stack(void);
  *
  */
 #define container_of(ptr, type, member) ({			\
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        const member_type(type, member) *__mptr = (ptr);	\
         (type *)( (char *)__mptr - offsetof(type,member) );})
 
 /*
diff -urNp linux-2.6.5/include/linux/namei.h linux-2.6.5.SUSE/include/linux/namei.h
--- linux-2.6.5/include/linux/namei.h	2004-04-04 05:36:55.000000000 +0200
+++ linux-2.6.5.SUSE/include/linux/namei.h	2004-04-26 16:50:54.000000000 +0200
@@ -48,11 +48,11 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LA
 #define LOOKUP_CREATE		(0x0200)
 #define LOOKUP_ACCESS		(0x0400)
 
-extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *, const char **));
 #define user_path_walk(name,nd) \
-	__user_walk(name, LOOKUP_FOLLOW, nd)
+	__user_walk(name, LOOKUP_FOLLOW, nd, 0)
 #define user_path_walk_link(name,nd) \
-	__user_walk(name, 0, nd)
+	__user_walk(name, 0, nd, 0)
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
diff -urNp linux-2.6.5/init/main.c linux-2.6.5.SUSE/init/main.c
--- linux-2.6.5/init/main.c	2004-04-26 16:50:40.000000000 +0200
+++ linux-2.6.5.SUSE/init/main.c	2004-04-26 16:50:54.000000000 +0200
@@ -89,6 +89,11 @@ extern void sbus_init(void);
 extern void sysctl_init(void);
 extern void signals_init(void);
 extern void buffer_init(void);
+#ifdef CONFIG_FSHOOKS
+extern void fshooks_init(void);
+#else
+#define fshooks_init() ((void)0)
+#endif
 extern void pidhash_init(void);
 extern void pidmap_init(void);
 extern void anon_vma_init(void);
@@ -517,6 +522,7 @@ asmlinkage void __init start_kernel(void
 	fork_init(num_physpages);
 	proc_caches_init();
 	buffer_init();
+	fshooks_init();
 	unnamed_dev_init();
 	security_scaffolding_startup();
 	vfs_caches_init(num_physpages);
diff -urNp linux-2.6.5/mm/fadvise.c linux-2.6.5.SUSE/mm/fadvise.c
--- linux-2.6.5/mm/fadvise.c	2004-04-04 05:36:56.000000000 +0200
+++ linux-2.6.5.SUSE/mm/fadvise.c	2004-04-26 16:50:54.000000000 +0200
@@ -10,6 +10,7 @@
 #include <linux/kernel.h>
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/mm.h>
 #include <linux/pagemap.h>
 #include <linux/backing-dev.h>
@@ -29,8 +30,12 @@ asmlinkage long sys_fadvise64_64(int fd,
 	pgoff_t end_index;
 	int ret = 0;
 
-	if (!file)
-		return -EBADF;
+	FSHOOK_BEGIN(fadvise, ret, .fd = fd, .offset = offset, .len = len, .advice = advice)
+
+	if (!file) {
+		ret = -EBADF;
+		goto out_no_put;
+	}
 
 	mapping = file->f_mapping;
 	if (!mapping || len < 0) {
@@ -74,6 +79,10 @@ asmlinkage long sys_fadvise64_64(int fd,
 	}
 out:
 	fput(file);
+
+out_no_put:
+	FSHOOK_END(fadvise, ret)
+
 	return ret;
 }
 
diff -urNp linux-2.6.5/mm/filemap.c linux-2.6.5.SUSE/mm/filemap.c
--- linux-2.6.5/mm/filemap.c	2004-04-26 16:50:40.000000000 +0200
+++ linux-2.6.5.SUSE/mm/filemap.c	2004-04-26 16:50:54.000000000 +0200
@@ -14,6 +14,7 @@
 #include <linux/slab.h>
 #include <linux/compiler.h>
 #include <linux/fs.h>
+#include <linux/fshooks.h>
 #include <linux/aio.h>
 #include <linux/kernel_stat.h>
 #include <linux/mm.h>
@@ -1211,6 +1212,8 @@ asmlinkage ssize_t sys_readahead(int fd,
 	ssize_t ret;
 	struct file *file;
 
+	FSHOOK_BEGIN(readahead, ret, .fd = fd, .offset = offset, .length = count)
+
 	ret = -EBADF;
 	file = fget(fd);
 	if (file) {
@@ -1223,6 +1226,9 @@ asmlinkage ssize_t sys_readahead(int fd,
 		}
 		fput(file);
 	}
+
+	FSHOOK_END(readahead, ret)
+
 	return ret;
 }
 
