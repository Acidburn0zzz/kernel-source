Index: linux.t/Documentation/hook/HOWTO
===================================================================
--- linux.t.orig/Documentation/hook/HOWTO	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/Documentation/hook/HOWTO	2004-03-21 11:10:28.578144149 -0500
@@ -0,0 +1,393 @@
+How to use Kernel Hooks?
+
+Author: Richard J Moore, richardj_moore@uk.ibm.com, 
+	Vamsi Krishna S., vamsi_krishna@in.ibm.com,
+	Prasanna S Panchamukhi prasanna@in.ibm.com
+	Linux Technology Centre, IBM Corp.
+
+(C) Copyright 2000 IBM Corporation
+(C) Copyright 2000 IBM UK Ltd
+
+
+Introduction:
+------------
+
+The Kernel Hooks Interface is a generalised facility for placing hooks in 
+arbitrary kernel locations. A hook is a location in the kernel
+that calls out of the kernel to a kernel module routine - a hook exit routine.
+It enables many kernel enhancements, which are otherwise self-contained, to
+become loadable kernel modules and retain a substantial degree of independence
+from the kernel source. This affords advantages for maintenance and
+co-existence with other kernel enhancements. 
+
+Hooks are implemented as fast and slim-line insertions to kernel space code.
+When not active that have practically no overhead to the kernel. They are in
+essence a conditional jmp to the exit dispatching code. 
+
+There are two hook optimizations employed in gkhi, one of which is optional - the
+exclusive hook; the other - the arch-hook - is dependent on the IA32 architecture
+and always used in that environment.
+
+The exclusive hook eliminates some of the generalised processing associated with
+dispatching multiple exits. This can be used where it is known that only one 
+exit would ever register to use a hook. Exclusive hooks are coded as 
+EXCLUSIVE_HOOK, EXCLUSIVE_HOOK_RET etc. You have to use the macro
+DECLARE_EXCLUSIVE_HOOK to declare the exclusive hook.
+
+The arch-hook optimization uses architecturally dependent features. We have 
+provided an implementation for IA32, though could be ported to other 
+architectures without difficulty. The code for the IA32 implementation may 
+be found in include/asm-i386/hook.h. This optimization is always used under IA32. 
+It is implemented by:
+ 
+  1. moving the hook exit dispatching code to a separate section to minimise the
+     icache footprint of the hook code. (This should be applicable
+     to all architectures.)
+  2. changing the test for the conditional jmp to be dependent on a register variable
+     which set by moving a literal constant into the register.
+  3. modifying the literal value in the MOV instruction to activate and deactivate the
+     hook.
+ 
+These actions both minimise the cache hit and the number of instructions required to
+test for an inactive hook.
+
+There is another type of hooks: generic hooks. These are slower than the
+arch-optimized hooks, but they generate no symbols at hook locations and
+could be used to place hooks even in inline functions. Use the macros
+DECLARE_GENERIC_HOOK and GENERIC_HOOK etc. to define generic hooks.
+
+The hook interface allows multiple kernel modules to register their exits for
+a given hook, in order to receive control at that given hook location. Multiple
+hooks may be defined within the kernel and a single kernel module may register
+exits to use multiple hooks.
+
+When hook exits register they may specify co-existence criteria, that is
+whether they can co-exist with other exist for the same hook and their
+dispatching priority.
+
+Hooks may be placed in kernel modules as well as the kernel itself.
+
+A hook exit receives control as if called from the code in which the hook is
+placed. Parameters may be passed to a hook exit and may be modified by an
+exit (subject to being declared for that purpose). The exit may return a
+non-zero result to stop other exits from being dispatched.
+
+There are two type of hook:
+
+	normal.
+	conditional return.
+
+With normal hooks, control returns to the hooked code after any exits are
+dispatched.
+
+With conditional return hooks, an exit may optionally specify that the routine
+in which the hook is coded must return when the exit returns.
+
+Exits are made callable in a two-stage process:
+
+1) Registration - this is used to make the exit known to the hook interface
+and to perform some validation. 
+
+2) Arming - this is used to make a set of exits callable. The arming operation
+is atomic as far as kernel processing is concerned.
+
+These operations may be reversed using disarming and de-registration functions.
+
+Hook interface is implemented in kernel/hook.c which can be compiled into the
+kernel or as a module based on the kernel compilation option specified in
+the "Kernel Hacking" section of the build configuration.
+
+Hooks are defined by coding a DECLARE_HOOK macro to define a hook-head 
+structure. Modules defining hooks may load before or after hook.o when it is 
+compiled as a module, however they have to identify to the hook interface module 
+the existence of a hook before an exit can be register and arm itself.
+
+Hooks are identified by name, which should avoid problems of uniqueness. The
+name specified is used to generate labels for the hook-head structure and the
+hook location.
+
+
+Installation:
+-------------
+
+Apply this patch to the kernel source and say 'Y' or 'M' to "Kernel Hooks 
+Interface" in the "Kernel Hacking" section of the build configuration. Build 
+the kernel and boot with it. If you build the hook interface as a module,
+build and install the module.
+
+-------------------------------------------------------------------------------
+If you want to see a working example then compile khook.c and kexit.c using 
+the following command:
+
+echo "obj-m := khook.o kexit.o" > Makefile   
+make -C /usr/src/linux/ SUBDIRS=$PWD modules
+
+insmod khook.ko
+insmod kexit.ko
+
+khook.c shows how hooks are coded.
+kexit.c shows how hook exits register and arm themselves.
+
+The procedure for defining and using hooks involves the following steps:
+	- add hooks to the kernel/kernel module source
+	- register hook exits
+	- arm hook exits
+and when we are done using the hooks, undo the above:
+	- disarm hook exits
+	- deregister hook exits
+
+-------------------------------------------------------------------------------
+
+Adding Hooks to the Kernel
+--------------------------
+
+Let's say we want to place a hook named hook_trap1_entry in the beginning of the
+trap1 handler then edit arch/i386/traps.c, locate routine do_debug. This is the
+trap1 exception handler. The code begins as follows:
+
+asmlinkage void do_debug(struct pt_regs * regs, long error_code)
+{
+	unsigned int condition;
+	struct task_struct *tsk = current;
+
+	if (regs->eflags & VM_MASK)
+		goto debug_vm86;
+
+	__asm__ __volatile__("movl %%db6,%0" : "=r" (condition));
+
+Suppose we want a hook before the if statement. We add to traps.c:
+
+#include <linux/hook.h>
+#define HOOK_TRAP1_ENTRY hook_trap1_entry /* just a convenient define */
+DECLARE_HOOK(HOOK_TRAP1_ENTRY);
+
+then in do_debug we insert the hook definition:
+asmlinkage void do_debug(struct pt_regs * regs, long error_code)
+{
+	unsigned int condition;
+	struct task_struct *tsk = current;
+
+	HOOK(HOOK_TRAP1_ENTRY);
+
+	if (regs->eflags & VM_MASK)
+		goto debug_vm86;
+
+	__asm__ __volatile__("movl %%db6,%0" : "=r" (condition));
+
+Now recompile the kernel.
+
+For example to pass "condition" from do_debug to a hook exit:
+
+    HOOK(HOOK_TRAP1_ENTRY, condition);
+
+If you want to code a conditional-return hook the use for exmaple:
+
+    HOOK_RET(HOOK_TRAP1_ENTRY, condition);
+
+The kernel now has a dormant hook at the beginning of the trap1 exception
+handler.
+
+Adding Hooks to a Kernel Module
+-------------------------------
+Adding hooks to a kernel module is very similar to adding hooks to kernel.
+In the module that is to have a hook defined code the DECLARE_HOOK macro 
+before the first routine is defined - in other words where external static 
+variables would be defined. For example suppose we wish to define my_hook,
+then code:
+
+#include <linux/hook.h>
+DECLARE_HOOK(my_hook);
+
+Next you'll need to define the hook by coding a HOOK macro in the code path 
+where the hook is to be placed. In this example:
+
+	HOOK(my_hook);
+
+would be coded. This defines a public symbol for the hook location using the
+name my_hook.
+
+Using Hooks - registering and arming hook exits:
+------------------------------------------------
+
+To use this hook from your kernel module you need to perform 3 actions:
+
+1) If hook interface hook.o is built as a module, insert it using:
+	insmod hook.o
+you might need the -f switch if you've changed kernel  versions after
+compiling hook.o
+
+2) You need to register the entry point (the hook exit) in your kernel module
+that will receive control from hook.
+
+You do this by calling hook_exit_register passing a pointer to hook structure 
+(in this example hook_trap1_entry) and a pointer to a hook record structure 
+(defined in hook.h as struct hook_rec). You will need to include linux/hook.h
+into your module's source. Refer to this file for the definition of struct 
+hook_rec, struct hook  and the relavent flags.
+
+Allocate an instance of this structure for each hook exit you wish to
+register. The hook.o interface will use these structures for as long as your
+exits remain registered so allocate them from persistent memory e.g. the
+kernel heap or global memory in you module. Don't allocate them as local
+variables!
+
+You set up your hook record as follows:
+
+1) initialise the entire structure to NULLs.
+
+2) set hook_exit to the address of your hook routine.
+
+3) set the pointer hook_exit_name to the name of exit routine.
+
+4) optionally set hook_flags to one of the following:
+
+
+#define HOOK_PRIORITY_FIRST	0x00000004
+#define HOOK_PRIORITY_LAST	0x00000008
+#define HOOK_QUEUE_LIFO		0x00000010
+
+HOOK_PRIORITY_FIRST inserts your exit at the head of the queue of exits to be 
+dispatched for the particular hook. If another exit has already registered with
+HOOK_PRIORITY_FIRST, then your registration fails.
+
+HOOK_PRIORITY_LAST inserts your exit at the tail of the dispatching
+queue. If another exit has already registered with this priority, then your 
+registration fails.
+
+Set HOOK_QUEUE_LIFO if you want to be inserted at the head of those exits that
+can happily co-exist, but after a HOOK_PRIORITY_FIRST exit if one exists. 
+
+If you leave hook_flag to NULL you'll be inserted at the tail, but above a 
+HOOK_PRIORITY_LAST exit if it exists.
+
+You now call hook_exit_register. If you get a NO_ERROR result then your exit has
+been successfully registered. Note: registration does not cause your exit to be
+called - that only happens after arming you exit. The reason for making this
+distinction is to allow a group of exits to be simultaneously armed, once
+successfully registered.
+
+On successful registration you hook record will have hook_index indicating the
+current position of this exit in the list of all exits registered for this 
+hook, i.e., its dispatching priority (1 being first). Note that it will be 
+updated as more exits register or deregister.
+
+To get a group of exits callable from the hook you need to arm them. 
+Arming is done by calling hook_exit_arm.
+
+Once this is done your exits will be called whenever the kernel executes a
+HOOK statement - unless a higher priority exit set a non-zero return value.
+
+Hook Exit Parameters and Return Values.
+--------------------------------------
+A hook exit receives a variable length parameter list defined as follows:
+
+For normal (unconditional return) hooks:
+
+parm 0: pointer to the hook structure. This is useful if you have the
+	same exit routine registered for multiple hooks, in which case this
+	can be used to determine which hook has caused the exit routine to be
+	called. 
+parm 1 to (n+1): parameters coded on the HOOK macros.
+
+For conditional-return hooks:
+
+parm 0: pointer to the hook structure. This is useful if you have the
+	same exit routine registered for multiple hooks, in which case this
+	can be used to determine which hook has caused the exit routine to be
+	called. 
+parm 1: pointer to the return code (int *) to be set if a forced return of the
+	hooked routine is requested by the exit routine. 
+parm 2 to (n+2): parameters coded on the HOOK macros.
+
+If the exit function's prototype does not match the expected prototype, then
+the kernel could oops.
+
+A hook exit may itself return with the following return values:
+
+HOOK_CONTINUE - allows dispatching of other exits.
+HOOK_TERMINATE - stops further exit dispatching and returns to the hooked code.
+HOOK_RETURN - stops further exit dispatching and for conditional return hooks
+forces the hooked routine to return using parm2 as a return value.
+
+It is possible to write a hook exit function that takes variable number of
+arguments, see kexit.c for an example.
+
+Deregistering and disarming exits
+---------------------------------
+
+Exits may be disarmed and re-armed as often as like. Disarming may be done two
+ways:
+
+1) by calling hook_exit_disarm and passing a pointer to a hook record structure. 
+
+2) by turning off HOOK_ARMED in hook_flags (&=~HOOK_ARMED) from the hook exit.
+
+Exits may be de-registered by calling hook_exit_deregister and passing a 
+pointer to a hook record structure. De-registration will force disarming.
+
+WARNING!!! A kernel module must deregister its exits from its module_cleanup
+routine if that have not already been deregistered. 
+
+/proc interface
+---------------
+When Generalized Kernel Hooks is initialized, a /proc/hooks directory is 
+created. Whenever a hook exit is registered for new hook, a /proc/hooks/<hook_id> 
+subdirectory is created. Whenever a new hook exit is registered, a 
+/proc/hooks/<hook_id>/<hook_exit_name> file is created. This file is writable 
+if hook_exit_register is called with the proc_writable set to 1, otherwise, 
+it is read-only. The file name is taken from hook_exit_name if set in the 
+hook_rec_t structure. If not set, the file name is the exit's memory location. 
+This file contains a boolean value of '1' or '0' to indicate whether the exit 
+is armed or not. It may be written to independently of GKHI to arm or disarm 
+a hook exit, provided that proc_writable flag is set on registration.
+
+Reporting Problems and Discussing GKHI
+--------------------------------------
+email: dprobes@oss.software.ibm.com
+vist: http://oss.software.ibm.com/developerworks/linux
+
+For further information read the USENIX 2000 Annual Linux Showcase paper, and
+the UKUUG Linux2001 Generalised Kernel Hooks paper which may be found at
+http://oss.software.ibm.com/developerworks/linux
+
+License
+-------
+Copyright (C) 2001 IBM Corporation
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+MA 02111-1307, USA.
+
+Change History
+--------------
+0.6	8th November 2000	First public drop
+1.0	14th February 2001	SMP Enablement. Slim-line hooks implemented
+				Thanks to Andrea Arcangeli for suggestions for
+				improvement.
+1.1	12th April 2001		Hooks initialised dynamically.
+				Named hooks supported.
+				Conditonal return hooks supported.
+				Support for hooks in kernel modules added.
+1.2 	3rd July 2001		Bug fixes.
+				Rewrite to confirm to kernel coding style.
+				Make it part of the kernel build process.
+				Seperate out arch-dependent and indepedent
+				parts. Arch-independent hooks and convenient
+				provision to allow arch-specific optimized
+				implementation of hooks. Updated documentation
+				and simplify the sample modules.
+1.3	20th Sept. 2001		/proc interface
+				exclusive hooks
+1.4	4th Oct. 2001		HOOK macros now take variable number of args
+				Bug fix in is_asm_hook()
Index: linux.t/Documentation/hook/Makefile
===================================================================
--- linux.t.orig/Documentation/hook/Makefile	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/Documentation/hook/Makefile	2004-03-21 11:10:28.579144031 -0500
@@ -0,0 +1 @@
+obj-m := khook.o kexit.o
Index: linux.t/Documentation/hook/kexit.c
===================================================================
--- linux.t.orig/Documentation/hook/kexit.c	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/Documentation/hook/kexit.c	2004-03-21 11:10:28.580143912 -0500
@@ -0,0 +1,267 @@
+/*****************************************************************************/
+/* Kernel Hooks Interface.                                                   */
+/* Author: Richard J Moore richardj_moore@uk.ibm.com                         */
+/* 	   Vamsi Krishna S. r1vamsi@in.ibm.com                               */
+/*	   Prasanna S P prasanna@in.ibm.com                                  */
+/*                                                                           */
+/* A sample kernel module registering exits for hooks defined in khook.o.    */
+/*                                                                           */
+/* Refer to Documentation/hook/HOWTO for details.                            */
+/* (C) Copyright IBM Corp. 2003                                              */
+/*****************************************************************************/
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/hook.h>
+
+extern struct hook  test_hook1;
+extern struct hook  test_hook2;
+extern struct hook  test_hook3;
+extern struct hook  test_hook4;
+extern struct hook  test_hook5;
+extern struct hook  ex_test_hook3;
+extern struct hook  ex_test_hook4;
+extern struct hook  ex_test_hook5;
+int exit1(struct hook *, int *);	/* first exit for test_hook1 */
+int exit2(struct hook *);		/* first exit for test_hook2 */
+int exit3(struct hook *, int *);	/* second exit for test_hook1 */
+int exit4(struct hook *);		/* second exit for test_hook2 */
+int exit_var0(struct hook *);
+int exit_var1(struct hook *, int);
+int exit_var2(struct hook *, int, int);
+int exit_var2_mismatch(struct hook *, int);
+
+int ex_exit_var0(struct hook *);
+int ex_exit_var1(struct hook *, int);
+int ex_exit_var2(struct hook *, int, int);
+int exit_var_args(struct hook * hook, ...);
+extern int testhook(void);
+
+struct hook_rec hook1;
+struct hook_rec hook2;
+struct hook_rec hook3;
+struct hook_rec hook4;
+struct hook_rec var0;
+struct hook_rec var1;
+struct hook_rec var2;
+struct hook_rec ex_var0;
+struct hook_rec ex_var1;
+struct hook_rec ex_var2;
+
+int init_module(void)
+{
+	int rc;
+
+	hook1.hook_exit = &exit1;
+	hook1.hook_exit_name = "exit1";
+	rc = hook_exit_register(&test_hook1, &hook1);
+	if (rc) {
+		printk("hook_exit_register exit1 for hook1 returned %u\n", rc);
+		goto err;
+	}
+
+	hook2.hook_exit = &exit2;
+	hook2.hook_exit_name = "exit2";
+	rc = hook_exit_register(&test_hook2, &hook2);
+	if (rc) { 
+		printk("hook_exit_register exit2 for hook2 returned %u\n", rc);
+		goto err1;
+	}
+
+	hook3.hook_exit = &exit3;
+	hook3.hook_exit_name = "exit3";
+	rc = hook_exit_register(&test_hook1, &hook3);
+	if (rc) {
+		goto err2;
+		printk("hook_exit_register exit3 for hook1 returned %u\n", rc);
+	}
+	hook4.hook_exit = &exit4;
+	hook4.hook_exit_name = "exit4";
+	rc = hook_exit_register(&test_hook2, &hook4);
+	if (rc) {
+		printk("hook_exit_register exit4 for hook2 returned %u\n", rc);
+	 	goto err3;
+	}
+
+	var0.hook_exit = &exit_var0;
+	rc = hook_exit_register(&test_hook3, &var0);
+	if (rc) goto err4;
+
+	var1.hook_exit = &exit_var1;
+	rc = hook_exit_register(&test_hook4, &var1);
+	if (rc) goto err5;
+
+	var2.hook_exit = &exit_var2_mismatch;
+	rc = hook_exit_register(&test_hook5, &var2);
+	if (rc) goto err6;
+	ex_var0.hook_exit = &ex_exit_var0;
+	rc = hook_exit_register(&ex_test_hook3, &ex_var0);
+	if (rc) goto err7;
+
+	ex_var1.hook_exit = &ex_exit_var1;
+	rc = hook_exit_register(&ex_test_hook4, &ex_var1);
+	if (rc) goto err8;
+
+	ex_var2.hook_exit = exit_var_args;
+	rc = hook_exit_register(&ex_test_hook5, &ex_var2);
+	if (rc) goto err9;
+	printk("hook exits are registered, but not yet armed.\n");
+
+	testhook();
+
+	hook_exit_arm(&hook1);
+	hook_exit_arm(&hook2);
+	hook_exit_arm(&hook3);
+	hook_exit_arm(&hook4);
+	hook_exit_arm(&var0);
+	hook_exit_arm(&var1);
+	hook_exit_arm(&var2);
+	hook_exit_arm(&ex_var0);
+	hook_exit_arm(&ex_var1);
+	hook_exit_arm(&ex_var2);
+
+	printk("hook exit are now armed.\n");
+
+	testhook();
+
+	printk("disarming exit1 only\n");
+	hook_exit_disarm(&hook1);
+
+	testhook();
+
+	printk("disarming exit2 only\n");
+	hook_exit_disarm(&hook2);
+
+	testhook();
+	return 0;
+	
+err9:	hook_exit_deregister(&ex_var1);
+err8:	hook_exit_deregister(&ex_var0);
+err7:	hook_exit_deregister(&var2);
+err6:	hook_exit_deregister(&var1);
+err5:	hook_exit_deregister(&var0);
+err4:	hook_exit_deregister(&hook4);
+err3:	hook_exit_deregister(&hook3);
+err2:	hook_exit_deregister(&hook2);
+err1:	hook_exit_deregister(&hook1);
+err: 	return rc;
+}
+
+void cleanup_module(void)
+{
+	/* deregister all hook exits*/
+	hook_exit_deregister(&ex_var2);
+	hook_exit_deregister(&ex_var1);
+	hook_exit_deregister(&ex_var0);
+	hook_exit_deregister(&var2);
+	hook_exit_deregister(&var1);
+	hook_exit_deregister(&var0);
+	hook_exit_deregister(&hook4);
+	hook_exit_deregister(&hook3);
+	hook_exit_deregister(&hook2);
+	hook_exit_deregister(&hook1);
+
+	printk("deregistered all hook exits.\n");
+
+	testhook();
+
+	return;
+}
+
+/* exit1 exit to test_hook1 */
+int exit1(struct hook * hook, int *rc)
+{
+	printk("exit1: hook exit1 entered, indicate for testhook to return immediately\n");
+	*rc = 0;
+	printk("exit1: hook exit1 exiting\n");
+	return HOOK_RETURN;
+}
+
+/* exit2 exit to test_hook2 */
+int exit2(struct hook * hook)
+{
+	printk("exit2: hook exit2 entered\n");
+	printk("exit2: hook exit2 exiting\n");
+	return HOOK_CONTINUE;
+}
+
+/* exit3 exit to test_hook1 */
+int exit3(struct hook * hook, int *rc)
+{
+	printk("exit3: hook exit3 entered, allow testhook to continue\n");
+	*rc = 0;
+	printk("exit3: hook exit3 exiting\n");
+	return HOOK_CONTINUE;
+}
+
+/* exit4 exit to test_hook2 */
+int exit4(struct hook * hook)
+{
+	printk("exit4: hook exit4 entered\n");
+	printk("exit4: hook exit4 exiting\n");
+	return HOOK_CONTINUE;
+}
+
+int exit_var0(struct hook *h)
+{
+	printk("exit_var0: entered\n");
+	printk("exit_var0: exiting\n");
+	return HOOK_CONTINUE;
+}
+int exit_var1(struct hook *h, int i)
+{
+	printk("exit_var1: entered, %x\n", i);
+	printk("exit_var1: exiting\n");
+	return HOOK_CONTINUE;
+}
+int exit_var2(struct hook *h, int i, int j)
+{
+	printk("exit_var2: entered %x, %x\n", i, j);
+	printk("exit_var2: exiting\n");
+	return HOOK_CONTINUE;
+}
+
+int exit_var2_mismatch(struct hook *h, int i)
+{
+	printk("exit_var2: entered using only the first arg: %x\n", i);
+	printk("exit_var2: exiting\n");
+	return HOOK_CONTINUE;
+}
+
+int ex_exit_var0(struct hook *h)
+{
+	printk("ex_exit_var0: entered %s\n", h->hook_id);
+	printk("ex_exit_var0: exiting\n");
+	return HOOK_CONTINUE;
+}
+int ex_exit_var1(struct hook *h, int i)
+{
+	printk("ex_exit_var1: entered, %x\n", i);
+	printk("ex_exit_var1: exiting\n");
+	return HOOK_CONTINUE;
+}
+int ex_exit_var2(struct hook *h, int i, int j)
+{
+	printk("ex_exit_var2: entered %x, %x\n", i, j);
+	printk("ex_exit_var2: exiting\n");
+	return HOOK_CONTINUE;
+}
+
+int exit_var_args(struct hook * hook, ...)
+{
+	va_list args;
+	char buf[80];
+	char *fmt;
+	printk("exit_var_args: entered\n");
+	va_start(args, hook);
+	fmt = va_arg(args, char *);
+	vsprintf(buf, fmt, args);
+	printk("vsprintf output=%s\n", buf);
+	va_end(args);
+	printk("exit_var_args: exiting\n");
+	return HOOK_CONTINUE;
+}
+MODULE_LICENSE("GPL");
Index: linux.t/Documentation/hook/khook.c
===================================================================
--- linux.t.orig/Documentation/hook/khook.c	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/Documentation/hook/khook.c	2004-03-21 11:10:28.581143794 -0500
@@ -0,0 +1,72 @@
+/****************************************************************************/
+/* Kernel Hooks Interface.                                    		    */
+/* Author: Richard J Moore richardj_moore@uk.ibm.com                        */
+/* 	   Vamsi Krishna S. r1vamsi@in.ibm.com 				    */
+/*	   Prasanna S P prasanna@in.ibm.com                                 */
+/*                                                                          */
+/* A sample kernel module with hooks in it (in the testhook function).      */
+/*                                                                          */
+/*  (C) Copyright IBM Corp. 2003                                            */
+/* Refer to Documentation/hook/HOWTO for details.                           */
+/****************************************************************************/
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/hook.h>
+
+#define TEST_HOOK1 test_hook1
+#define TEST_HOOK2 test_hook2
+#define TEST_HOOK3 test_hook3
+#define TEST_HOOK4 test_hook4
+#define TEST_HOOK5 test_hook5
+#define EX_TEST_HOOK3 ex_test_hook3
+#define EX_TEST_HOOK4 ex_test_hook4
+#define EX_TEST_HOOK5 ex_test_hook5
+
+DECLARE_HOOK(TEST_HOOK1);
+DECLARE_HOOK(TEST_HOOK2);
+DECLARE_HOOK(TEST_HOOK3);
+DECLARE_HOOK(TEST_HOOK4);
+DECLARE_HOOK(TEST_HOOK5);
+DECLARE_EXCLUSIVE_HOOK(EX_TEST_HOOK3);
+DECLARE_EXCLUSIVE_HOOK(EX_TEST_HOOK4);
+DECLARE_EXCLUSIVE_HOOK(EX_TEST_HOOK5);
+
+int init_module(void)
+{
+	printk("now load kexit.o to test the hook(s)\n");
+	return 0;
+}
+
+void cleanup_module(void)
+{
+
+	return;
+}
+
+/*
+ * this is an example of how the hooks would be coded in the kernel or a
+ * kernel module.
+ */
+int testhook(void)
+{
+	printk("testhook entered\n");
+	
+	HOOK_RET(TEST_HOOK1);
+	HOOK(TEST_HOOK2);
+
+	HOOK(TEST_HOOK3);
+	HOOK(TEST_HOOK4, 4);
+	HOOK(TEST_HOOK5, 5, 0);
+	EXCLUSIVE_HOOK(EX_TEST_HOOK3);
+	EXCLUSIVE_HOOK(EX_TEST_HOOK4, 4);
+	EXCLUSIVE_HOOK(EX_TEST_HOOK5, "%s, %d", "test_hook3", 1);
+	printk("testhook exited\n");
+	return 0;
+}
+
+EXPORT_SYMBOL_NOVERS(testhook);
+MODULE_LICENSE("GPL");
Index: linux.t/arch/alpha/Kconfig
===================================================================
--- linux.t.orig/arch/alpha/Kconfig	2004-03-21 10:55:07.221808135 -0500
+++ linux.t/arch/alpha/Kconfig	2004-03-21 11:10:28.583143557 -0500
@@ -691,6 +691,19 @@ config DEBUG_INFO
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/arm/Kconfig
===================================================================
--- linux.t.orig/arch/arm/Kconfig	2004-03-21 10:55:07.223807903 -0500
+++ linux.t/arch/arm/Kconfig	2004-03-21 11:10:28.585143320 -0500
@@ -762,6 +762,19 @@ config DEBUG_CLPS711X_UART2
 	  output to the second serial port on these devices.  Saying N will
 	  cause the debug messages to appear on the first serial port.
 
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/cris/Kconfig
===================================================================
--- linux.t.orig/arch/cris/Kconfig	2004-03-21 10:55:07.224807787 -0500
+++ linux.t/arch/cris/Kconfig	2004-03-21 11:10:28.586143201 -0500
@@ -212,6 +212,18 @@ config PROFILE_SHIFT
 	depends on PROFILE
 	default "2"
 
+config HOOK
+	tristate "Kernel Hook support"
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/i386/Kconfig
===================================================================
--- linux.t.orig/arch/i386/Kconfig	2004-03-21 10:55:09.929493940 -0500
+++ linux.t/arch/i386/Kconfig	2004-03-21 11:10:28.588142965 -0500
@@ -1445,6 +1445,24 @@ config X86_MPPARSE
 	depends on X86_LOCAL_APIC && !X86_VISWS
 	default y
 
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config ASM_HOOK
+	bool
+	default y
+	depends on DEBUG_KERNEL && HOOK
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+	
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/ia64/Kconfig
===================================================================
--- linux.t.orig/arch/ia64/Kconfig	2004-03-21 10:55:07.229807207 -0500
+++ linux.t/arch/ia64/Kconfig	2004-03-21 11:11:09.310323843 -0500
@@ -664,6 +664,19 @@ config SYSVIPC_COMPAT
 	bool
 	depends on COMPAT && SYSVIPC
 	default y
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/m68k/Kconfig
===================================================================
--- linux.t.orig/arch/m68k/Kconfig	2004-03-21 10:55:07.231806975 -0500
+++ linux.t/arch/m68k/Kconfig	2004-03-21 11:10:28.592142491 -0500
@@ -688,6 +688,19 @@ config DEBUG_INFO
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 	  
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/mips/Kconfig
===================================================================
--- linux.t.orig/arch/mips/Kconfig	2004-03-21 10:54:46.653196012 -0500
+++ linux.t/arch/mips/Kconfig	2004-03-21 11:10:28.594142254 -0500
@@ -1531,6 +1531,19 @@ config DEBUG_HIGHMEM
 	bool "Highmem debugging"
 	depends on DEBUG_KERNEL && HIGHMEM
 
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/parisc/Kconfig
===================================================================
--- linux.t.orig/arch/parisc/Kconfig	2004-03-21 10:55:07.233806743 -0500
+++ linux.t/arch/parisc/Kconfig	2004-03-21 11:10:28.595142135 -0500
@@ -222,6 +222,19 @@ config DEBUG_INFO
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 	  
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/ppc/Kconfig
===================================================================
--- linux.t.orig/arch/ppc/Kconfig	2004-03-21 10:55:07.235806511 -0500
+++ linux.t/arch/ppc/Kconfig	2004-03-21 11:10:28.597141898 -0500
@@ -1229,6 +1229,24 @@ config OCP
 	depends on IBM_OCP
 	default y
 
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config ASM_HOOK
+	bool
+	default y
+	depends on DEBUG_KERNEL && HOOK
+	
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+	
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/ppc64/Kconfig
===================================================================
--- linux.t.orig/arch/ppc64/Kconfig	2004-03-21 10:55:07.236806395 -0500
+++ linux.t/arch/ppc64/Kconfig	2004-03-21 11:10:28.599141661 -0500
@@ -456,7 +456,25 @@ config DEBUG_SPINLOCK_SLEEP
 	help
 	  If you say Y here, various routines which may sleep will become very
 	  noisy if they are called with a spinlock held.
-	  
+
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config ASM_HOOK
+	bool
+	default y
+	depends on DEBUG_KERNEL && HOOK
+	
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+	
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/s390/Kconfig
===================================================================
--- linux.t.orig/arch/s390/Kconfig	2004-03-21 10:55:09.931493708 -0500
+++ linux.t/arch/s390/Kconfig	2004-03-21 11:10:28.600141543 -0500
@@ -430,6 +430,24 @@ config DEBUG_SPINLOCK_SLEEP
 	  If you say Y here, various routines which may sleep will become very
 	  noisy if they are called with a spinlock held.	
 
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config ASM_HOOK
+	bool
+	default y
+	depends on DEBUG_KERNEL && HOOK
+	
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+	
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/sh/Kconfig
===================================================================
--- linux.t.orig/arch/sh/Kconfig	2004-03-21 10:55:07.239806047 -0500
+++ linux.t/arch/sh/Kconfig	2004-03-21 11:10:28.602141306 -0500
@@ -1106,6 +1106,18 @@ config FRAME_POINTER
 	  If you don't debug the kernel, you can say N, but we may not be able
 	  to solve problems without frame pointers.
 
+config HOOK
+	tristate "Kernel Hook support"
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/sparc/Kconfig
===================================================================
--- linux.t.orig/arch/sparc/Kconfig	2004-03-21 10:55:07.241805815 -0500
+++ linux.t/arch/sparc/Kconfig	2004-03-21 11:10:28.603141188 -0500
@@ -448,6 +448,18 @@ config DEBUG_BUGVERBOSE
 	  of the BUG call as well as the EIP and oops trace.  This aids
 	  debugging but costs about 70-100K of memory.
 
+config HOOK
+	tristate "Kernel Hook support"
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/sparc64/Kconfig
===================================================================
--- linux.t.orig/arch/sparc64/Kconfig	2004-03-21 10:55:07.242805699 -0500
+++ linux.t/arch/sparc64/Kconfig	2004-03-21 11:10:28.604141069 -0500
@@ -700,6 +700,19 @@ config MCOUNT
 	depends on STACK_DEBUG
 	default y
 
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/x86_64/Kconfig
===================================================================
--- linux.t.orig/arch/x86_64/Kconfig	2004-03-21 10:55:07.246805235 -0500
+++ linux.t/arch/x86_64/Kconfig	2004-03-21 11:10:28.606140832 -0500
@@ -497,6 +497,19 @@ config IOMMU_LEAK
 #config X86_REMOTE_DEBUG
 #       bool "kgdb debugging stub"
 
+config HOOK
+	tristate "Kernel Hook support"
+	depends on DEBUG_KERNEL 
+	help
+	 The Kernel Hooks Interface is a generalised facility for placing hooks in
+	 arbitrary kernel locations. A hook is a location in the kernel that
+	 calls out of the kernel to a kernel module routine - a hook exit routine.
+	 Read Documentation/hook/HOWTO for more details.
+
+config HOOK_PROCFS
+	bool "/proc interface for hooks" 
+	depends on DEBUG_KERNEL && HOOK
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/include/asm-generic/hook.h
===================================================================
--- linux.t.orig/include/asm-generic/hook.h	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/include/asm-generic/hook.h	2004-03-21 11:10:28.607140714 -0500
@@ -0,0 +1,25 @@
+#ifndef __ASM_GENERIC_HOOK_H
+#define __ASM_GENERIC_HOOK_H
+/*
+ * Kernel Hooks common code for many archs.
+ * 
+ * Authors: Vamsi Krishna S. <vamsi_krishna@in.ibm.com>
+ */
+#include <asm/cacheflush.h>
+
+static inline void deactivate_asm_hook(struct hook *hook)
+{
+	unsigned char *addr = (unsigned char *) (hook->hook_addr);
+	addr[2] = 0;
+	flush_icache_range(addr + 2, addr + 2);
+	return;
+}
+
+static inline void activate_asm_hook(struct hook *hook)
+{
+	unsigned char *addr = (unsigned char *) (hook->hook_addr);
+	addr[2] = 1;
+	flush_icache_range(addr + 2, addr + 2);
+	return;
+}
+#endif /* __ASM_GENERIC_HOOK_H */
Index: linux.t/include/asm-i386/hook.h
===================================================================
--- linux.t.orig/include/asm-i386/hook.h	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/include/asm-i386/hook.h	2004-03-21 11:10:28.608140595 -0500
@@ -0,0 +1,106 @@
+#ifndef __ASM_I386_HOOK_H
+#define __ASM_I386_HOOK_H
+/*
+ * Kernel Hooks optimized for ia32.
+ * 
+ * Authors: Richard J Moore <richardj_moore@uk.ibm.com>
+ *	    Vamsi Krishna S. <vamsi_krishna@in.ibm.com>
+ */
+#include <linux/smp.h>
+#include <asm/cacheflush.h>
+
+#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
+
+#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
+#define _IF_HOOK_ENABLED(h, hk) \
+	register int tmp; \
+	__asm__ __volatile__ (".global "hk"; "hk":movl $0, %0":"=r"(tmp)); \
+	if (unlikely(tmp))
+
+#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
+
+/*
+ * Sanity check the hook location for expected instructions at hook location.
+ * movl $0, %reg, testl %reg, %reg
+ * test doesn't have to follow movl, so don't test for that.
+ */
+#define OPCODE_MOV1			0xb0
+#define OPCODE_MOV1_MASK		0xf0
+#define OPCODE_MOV2_1			0xc6 /* first byte */
+#define OPCODE_MOV2_2			0xc0 /* second byte */
+#define OPCODE_MOV2_1_MASK		0xfe
+#define OPCODE_MOV2_2_MASK		0xf8
+		
+static inline int is_asm_hook(unsigned char *addr)
+{
+	if (!addr)
+		return 0;
+	if((addr[0] & OPCODE_MOV1_MASK) == OPCODE_MOV1) {
+		if (*((unsigned long *)(addr+1)) == 0)
+			return 1;
+	} else if (((addr[0] & OPCODE_MOV2_1_MASK) == OPCODE_MOV2_1) && 
+		    ((addr[1] & OPCODE_MOV2_2_MASK) == OPCODE_MOV2_2)) {
+		if (*((unsigned long *)(addr+2)) == 0)
+			return 1;
+	}
+	return 0;
+}
+ 
+#if defined(CONFIG_SMP)
+/*
+ * This routine loops around a memory flag and once it is set to one, syncronizes the
+ * instruction cache by executing CPUID instruction.
+ */ 
+static void wait_for_memory_flag(atomic_t *memory_flag) 
+{
+	while (!atomic_read(memory_flag))
+		;
+	__asm__ __volatile__ ("cpuid" : : : "ax", "bx", "cx", "dx");
+	return;
+}
+
+#endif
+static inline void deactivate_asm_hook(struct hook *hook)
+{
+	unsigned char *addr = (unsigned char *) (hook->hook_addr);
+/*
+ * Fix for Intel Pentium and P6 family processors E49 errata (Unsyncronized 
+ * cross modifying code). Send an IPI to all CPUs except self and then modify
+ * the contents of hook_addr before other CPUs return from IPI.
+ */
+#if defined(CONFIG_SMP)
+	atomic_set(&hook->hook_deactivate, 0); 
+	mb(); 
+	smp_call_function((void *)wait_for_memory_flag, &hook->hook_deactivate, 1, 0); 
+#endif
+	addr[2] = 0;
+	flush_icache_range(addr + 2, addr + 2);
+#if defined(CONFIG_SMP)
+	atomic_set(&hook->hook_deactivate, 1); 
+	mb(); 
+#endif
+	return;
+}
+
+static inline void activate_asm_hook(struct hook *hook)
+{
+	unsigned char *addr = (unsigned char *) (hook->hook_addr);
+/*
+ * Fix for Intel Pentium and P6 family processors E49 errata (Unsyncronized 
+ * cross modifying code). Send an IPI to all CPUs except self and then modify 
+ * the contents of hook_addr before other CPUs return from IPI.
+ */
+#if defined(CONFIG_SMP)
+	atomic_set(&hook->hook_activate, 0); 
+	mb(); 
+	smp_call_function((void *)wait_for_memory_flag, &hook->hook_activate, 1, 0); 
+#endif
+	addr[2] = 1;
+	flush_icache_range(addr + 2, addr + 2);
+#if defined(CONFIG_SMP)
+	atomic_set(&hook->hook_activate, 1); 
+	mb(); 
+#endif
+	return;
+}
+#endif /* __ASM_I386_HOOK_H */
Index: linux.t/include/asm-ppc/hook.h
===================================================================
--- linux.t.orig/include/asm-ppc/hook.h	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/include/asm-ppc/hook.h	2004-03-21 11:10:28.609140477 -0500
@@ -0,0 +1,47 @@
+#ifndef __ASM_PPC_HOOK_H
+#define __ASM_PPC_HOOK_H
+/*
+ * Kernel Hooks optimized for PPC.
+ * 
+ * Authors: Mike Grundy <grundym@us.ibm.com> s390x
+ */
+#include <asm-generic/hook.h>
+
+#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
+
+#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
+#define _IF_HOOK_ENABLED(h, hk) \
+	register int tmp; \
+	__asm__ __volatile__ (".global "hk"; "hk":li %0, 0x00":"=r"(tmp)); \
+	if (unlikely(tmp))
+
+#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
+
+
+/*
+ * Sanity check the hook location for valid instructions at hook location.
+ * At hook location, we should find these instructions:
+ *	38 00 00 00       	li    	r0,0
+ *	2c 00 00 00            	cmpwi	r0,0
+ *	
+ * We can check for li and cmpwi instructions. As these instructions encode
+ * the register name in the second byte and the register cannot be predicted, 
+ * we mask out the bits corresponding to registers in the opcode before comparing.
+ * PPC opcodes are six bits, hence mask of 0xFC
+ */
+#define OPCODE_MOV1			0x38 /* LI (really an extended mnemonic for addi */   
+#define OPCODE_MOV1_MASK		0xFC
+/* Compiler generates 2c 00 00 00     cmpwi   r0,0 */
+		
+static inline int is_asm_hook(unsigned char * addr)
+{
+	if (!addr)
+		return 0;
+	
+	if((addr[0] & OPCODE_MOV1_MASK) == OPCODE_MOV1) {
+		if (*((unsigned short *)(addr+1)) == 0)
+			return 1;
+	}
+	return 0;
+}
+#endif /* __ASM_PPC_HOOK_H */
Index: linux.t/include/asm-ppc64/hook.h
===================================================================
--- linux.t.orig/include/asm-ppc64/hook.h	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/include/asm-ppc64/hook.h	2004-03-21 11:10:28.610140358 -0500
@@ -0,0 +1,47 @@
+#ifndef __ASM_PPC_HOOK_H
+#define __ASM_PPC_HOOK_H
+/*
+ * Kernel Hooks optimized for PPC64.
+ * 
+ * Authors: Mike Grundy <grundym@us.ibm.com> PPC64
+ */
+#include <asm-generic/hook.h>
+
+#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
+
+#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
+#define _IF_HOOK_ENABLED(h, hk) \
+	register int tmp; \
+	__asm__ __volatile__ (".global "hk"; "hk":li %0, 0x00":"=r"(tmp)); \
+	if (unlikely(tmp))
+
+#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
+
+
+/*
+ * Sanity check the hook location for valid instructions at hook location.
+ * At hook location, we should find these instructions:
+ *	38 00 00 00       	li    	r0,0
+ *	2c 00 00 00            	cmpwi	r0,0
+ *	
+ * We can check for li and cmpwi instructions. As these instructions encode
+ * the register name in the second byte and the register cannot be predicted, 
+ * we mask out the bits corresponding to registers in the opcode before comparing.
+ * PPC opcodes are six bits, hence mask of 0xFC
+ */
+#define OPCODE_MOV1			0x38 /* LI (really an extended mnemonic for addi */   
+#define OPCODE_MOV1_MASK		0xFC
+/* Compiler generates 2c 00 00 00     cmpwi   r0,0 */
+		
+static inline int is_asm_hook(unsigned char * addr)
+{
+	if (!addr)
+		return 0;
+	
+	if((addr[0] & OPCODE_MOV1_MASK) == OPCODE_MOV1) {
+		if (*((unsigned short *)(addr+1)) == 0)
+			return 1;
+	}
+	return 0;
+}
+#endif /* __ASM_PPC_HOOK_H */
Index: linux.t/include/asm-s390/hook.h
===================================================================
--- linux.t.orig/include/asm-s390/hook.h	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/include/asm-s390/hook.h	2004-03-21 11:10:28.611140240 -0500
@@ -0,0 +1,49 @@
+#ifndef __ASM_S390_HOOK_H
+#define __ASM_S390_HOOK_H
+/*
+ * Kernel Hooks optimized for s390.
+ * 
+ * Authors: Mike Grundy <grundym@us.ibm.com> s390
+ */
+#include <asm-generic/hook.h>
+
+#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
+
+#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
+#define _IF_HOOK_ENABLED(h, hk) \
+	register int tmp; \
+	__asm__ __volatile__ (".global "hk"; "hk":lhi %0, 0x00":"=r"(tmp)); \
+	if (unlikely(tmp))
+
+#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
+
+/*
+ * Sanity check the hook location for valid instructions at hook location.
+ * At hook location, we should find these instructions:
+ *  a7 18 00 00             lhi     %r1,0
+ *  12 11                   ltr     %r1,%r1
+ * We can check for the lhi and ltr instructions. As the lhi instruction encodes
+ * the register name in it, and we can't guarantee which register will be used,
+ * we'll mask out the bits corresponding to the target register.
+ */
+#define OPCODE_MOV2_1			0xa7 /* LHI first byte */
+#define OPCODE_MOV2_2			0x08 /* LHI second byte */
+#define OPCODE_MOV2_1_MASK		0xff
+#define OPCODE_MOV2_2_MASK		0x0f
+/* Compiler generates LTR opcode 12, but second op not tested */
+		
+static inline int is_asm_hook(unsigned char * addr)
+{
+	if (!addr){
+		return 0;
+	}
+	if (((addr[0] & OPCODE_MOV2_1_MASK) == OPCODE_MOV2_1) && 
+		    ((addr[1] & OPCODE_MOV2_2_MASK) == OPCODE_MOV2_2)) {
+		/* was checking a 32bit val, need to check 16, cheated with 8+8 */
+		if (addr[2]== 0 && addr[3]== 0){
+			return 1;
+		}
+	}
+	return 0;
+}
+#endif /* __ASM_S390_HOOK_H */
Index: linux.t/include/asm-s390x/hook.h
===================================================================
--- linux.t.orig/include/asm-s390x/hook.h	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/include/asm-s390x/hook.h	2004-03-21 11:10:28.612140121 -0500
@@ -0,0 +1,49 @@
+#ifndef __ASM_S390X_HOOK_H
+#define __ASM_S390X_HOOK_H
+/*
+ * Kernel Hooks optimized for s390x(64bit).
+ * 
+ * Authors: Mike Grundy <grundym@us.ibm.com> s390x
+ */
+#include <asm-generic/hook.h>
+
+#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
+
+#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
+#define _IF_HOOK_ENABLED(h, hk) \
+	register int tmp; \
+	__asm__ __volatile__ (".global "hk"; "hk":lhi %0, 0x00":"=r"(tmp)); \
+	if (unlikely(tmp))
+
+#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
+
+/*
+ * Sanity check the hook location for valid instructions at hook location.
+ * At hook location, we should find these instructions:
+ *  a7 18 00 00             lhi     %r1,0
+ *  12 11                   ltr     %r1,%r1
+ * We can check for the lhi and ltr instructions. As the lhi instruction encodes
+ * the register name in it, and we can't guarantee which register will be used,
+ * we'll mask out the bits corresponding to the target register.
+ */
+#define OPCODE_MOV2_1			0xa7 /* LHI first byte */
+#define OPCODE_MOV2_2			0x08 /* LHI second byte */
+#define OPCODE_MOV2_1_MASK		0xff
+#define OPCODE_MOV2_2_MASK		0x0f
+/* Compiler generates LTR opcode 12, but second op not tested */
+		
+static inline int is_asm_hook(unsigned char * addr)
+{
+	if (!addr){
+		return 0;
+	}
+	if (((addr[0] & OPCODE_MOV2_1_MASK) == OPCODE_MOV2_1) && 
+		    ((addr[1] & OPCODE_MOV2_2_MASK) == OPCODE_MOV2_2)) {
+		/* was checking a 32bit val, need to check 16, cheated with 8+8 */
+		if (addr[2]== 0 && addr[3]== 0){
+			return 1;
+		}
+	}
+	return 0;
+}
+#endif /* __ASM_S390X_HOOK_H */
Index: linux.t/include/linux/hook.h
===================================================================
--- linux.t.orig/include/linux/hook.h	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/include/linux/hook.h	2004-03-21 11:10:28.614139885 -0500
@@ -0,0 +1,238 @@
+#ifndef __LINUX_HOOK_H
+#define __LINUX_HOOK_H
+/*
+ * Kernel Hooks Interface.
+ * 
+ * Authors: Richard J Moore <richardj_moore@uk.ibm.com>
+ *	    Vamsi Krishna S. <vamsi_krishna@in.ibm.com>
+ * (C) Copyright IBM Corp. 2002, 2003
+ */
+#include <linux/compiler.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/list.h>
+
+/* define the user (kernel module) hook structure */
+struct hook_rec;
+struct hook;
+
+struct hook_rec {
+	void *hook_exit;
+	struct list_head exit_list;
+	unsigned int hook_flags;
+	unsigned int hook_index;
+	struct hook *hook_head;
+/*fields required for adding proc entries */
+	char *hook_exit_name;
+	struct proc_dir_entry *proc_entry;
+	int proc_writable;
+};
+
+struct hook {
+	struct list_head exit_list;
+	unsigned int hook_flags;
+	unsigned int hook_index;
+	void *hook_addr;
+	void *hook_ex_exit;
+/*fields required for adding proc entries */
+	struct proc_dir_entry *proc_entry;
+	char *hook_id;
+	atomic_t hook_activate;
+	atomic_t hook_deactivate;
+};
+
+/* hook flags */
+#define HOOK_ARMED		0x00000001
+#define HOOK_PRIORITY_FIRST	0x00000004
+#define HOOK_PRIORITY_LAST	0x00000008
+#define HOOK_QUEUE_LIFO		0x00000010
+
+/* flag groupings */
+#define HOOK_PRIORITY		(HOOK_PRIORITY_FIRST | HOOK_PRIORITY_LAST)
+#define HOOK_QUEUE		HOOK_QUEUE_LIFO
+#define HOOK_VALID_USER_FLAGS	(HOOK_PRIORITY | HOOK_QUEUE)
+
+/*
+ * Use the DECLARE_HOOK macro to define the hook structure in global 
+ * memory of a kernel module that is implementing a hook.
+ */
+#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
+
+#define HOOK_SYM(h) _HOOK_SYM(h)
+#define _HOOK_SYM(h) h##_hook
+
+#define DECLARE_HOOK(name) _DECLARE_HOOK(name, HOOK_SYM(name))
+#define _DECLARE_HOOK(name, hk) \
+extern void hk; \
+struct hook name = { \
+	.hook_addr 	= &(hk), 			  \
+	.exit_list	= LIST_HEAD_INIT(name.exit_list), \
+	.hook_index	= 0,				  \
+	.hook_id	= #name,			  \
+}; \
+EXPORT_SYMBOL(name);
+
+#define DECLARE_EXCLUSIVE_HOOK(name) _DECLARE_EXCLUSIVE_HOOK(name, HOOK_SYM(name))
+#define _DECLARE_EXCLUSIVE_HOOK(name, hk) \
+extern void hk; \
+struct hook name = { \
+	.hook_addr 	= &(hk), 			  \
+	.exit_list	= LIST_HEAD_INIT(name.exit_list), \
+	.hook_flags	= HOOK_EXCLUSIVE,		  \
+	.hook_index	= 0,				  \
+	.hook_id	= #name,			  \
+}; \
+EXPORT_SYMBOL(name);
+
+/*
+ * Generic hooks are the same in all architectures and may be used to
+ * place hooks even in inline functions. They don't define a symbol at hook
+ * location.
+ */ 
+
+#define DECLARE_GENERIC_HOOK(name) _DECLARE_GENERIC_HOOK(name)
+#define _DECLARE_GENERIC_HOOK(name) \
+struct hook name = { \
+	.hook_addr 	= &(name), 			  \
+	.exit_list	= LIST_HEAD_INIT(name.exit_list), \
+	.hook_id	= #name,			  \
+}; \
+EXPORT_SYMBOL(name);
+
+#define USE_HOOK(name) _USE_HOOK(name)
+#define _USE_HOOK(name) extern struct hook name
+
+/* define head record only flags */
+#define HOOK_ACTIVE	0x80000000
+#define HOOK_ASM_HOOK	0x40000000
+#define HOOK_EXCLUSIVE	0x20000000
+
+/* global status flags */
+#define HOOK_INIT       1
+
+typedef int (*hook_fn_t)(struct hook *, ...);
+
+#ifdef CONFIG_ASM_HOOK
+#include <asm/hook.h>
+#else
+static inline int is_asm_hook(unsigned char *addr) {return 0;}
+static inline void activate_asm_hook(struct hook *hook) { }
+static inline void deactivate_asm_hook(struct hook *hook) { }
+#endif
+
+#ifndef IF_HOOK_ENABLED
+#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk) 
+#define _IF_HOOK_ENABLED(h, hk) \
+	__asm__ __volatile__ (".global "hk"; "hk":"); \
+	if (unlikely(h.hook_flags & HOOK_ACTIVE))
+#endif
+
+#define HOOK_TEST(h) \
+	extern struct hook h; \
+	IF_HOOK_ENABLED(h, h##_hook)
+
+#define CALL_EXIT(fn, parm, args...) (((hook_fn_t)(fn))(parm , ##args))
+
+#define DISPATCH_NORMAL(fn, parm, dsprc, args...) \
+	dsprc = CALL_EXIT(fn, parm , ##args);
+
+#define DISPATCH_RET(fn, parm, dsprc, args...) { \
+	int rc; \
+	dsprc = CALL_EXIT(fn, parm, &rc , ##args); \
+	if (dsprc == HOOK_RETURN) \
+		return rc; \
+}
+
+#define DISPATCH_RET_NORC(fn, parm, dsprc, args...) { \
+	dsprc = CALL_EXIT(fn, parm , ##args); \
+	if (dsprc == HOOK_RETURN) \
+		return; \
+}
+
+#define HOOK_DISP_LOOP(h, dispatch, args...) { \
+	register struct hook_rec *rec; \
+	list_for_each_entry(rec, &h.exit_list, exit_list) { \
+		register int dsprc; \
+		if (rec->hook_flags & HOOK_ARMED) { \
+			dispatch(rec->hook_exit, rec->hook_head, dsprc , ##args) \
+			if (dsprc == HOOK_TERMINATE) \
+				break; \
+		} \
+	} \
+}
+
+#define HOOK_DISP_EXCLUSIVE(h, dispatch, args...) { \
+	register int dsprc; \
+	if (h.hook_flags & HOOK_ACTIVE) { \
+		dispatch(h.hook_ex_exit, &h, dsprc , ##args) \
+	} \
+}
+
+#define HOOK(h, args...) { \
+	HOOK_TEST(h) \
+	HOOK_DISP_LOOP(h, DISPATCH_NORMAL , ##args); \
+}
+
+#define HOOK_RET(h, args...) { \
+	HOOK_TEST(h) \
+	HOOK_DISP_LOOP(h, DISPATCH_RET , ##args); \
+}
+
+#define HOOK_RET_NORC(h, args...) { \
+	HOOK_TEST(h) \
+	HOOK_DISP_LOOP(h, DISPATCH_RET_NORC , ##args); \
+}
+
+#define EXCLUSIVE_HOOK(h, args...) { \
+	HOOK_TEST(h) \
+	HOOK_DISP_EXCLUSIVE(h, DISPATCH_NORMAL , ##args); \
+}
+
+#define EXCLUSIVE_HOOK_RET(h, args...) { \
+	HOOK_TEST(h) \
+	HOOK_DISP_EXCLUSIVE(h, DISPATCH_RET , ##args); \
+}
+
+#define EXCLUSIVE_HOOK_RET_NORC(h, args...) { \
+	HOOK_TEST(h) \
+	HOOK_DISP_EXCLUSIVE(h, DISPATCH_RET_NORC , ##args); \
+}
+
+#define GENERIC_HOOK(h, args...) { \
+	extern struct hook h; \
+	if (unlikely(h.hook_flags & HOOK_ACTIVE)) { \
+		HOOK_DISP_LOOP(h, DISPATCH_NORMAL , ##args); \
+	} \
+}
+
+/* exported function prototypes */
+extern int hook_exit_register(struct hook *, struct hook_rec *);
+extern void hook_exit_deregister(struct hook_rec *);
+extern void hook_exit_arm(struct hook_rec *);
+extern void hook_exit_disarm(struct hook_rec *);
+
+/* exported functions error codes */
+#define EPRIORITY	1	/* reqd. priority not possible */
+#define ERROR_HIGHER_PRIORITY_HOOK 		-2
+#define ERROR_LOWER_PRIORITY_HOOK 		-4
+
+/* Return values from Hook Exit routines */
+#define HOOK_CONTINUE 	0
+#define HOOK_TERMINATE 	1
+#define HOOK_RETURN 	-1
+
+#else
+/* dummy macros when hooks are not compiled in */
+#define DECLARE_HOOK(x)
+#define DECLARE_GENERIC_HOOK(x)
+#define USE_HOOK(x)
+#define HOOK(h, args...)
+#define HOOK_RET(h, args...)
+#define HOOK_RET_NORC(h, args...)
+#define EXCLUSIVE_HOOK(h, args...)
+#define EXCLUSIVE_HOOK_RET(h, args...)
+#define EXCLUSIVE_HOOK_RET_NORC(h, args...)
+#define GENERIC_HOOK(h, args...)
+#endif /* !(CONFIG_HOOK || CONFIG_HOOK_MODULE) */
+
+#endif /* __LINUX_HOOK_H */
Index: linux.t/kernel/Makefile
===================================================================
--- linux.t.orig/kernel/Makefile	2004-03-21 10:55:10.243457511 -0500
+++ linux.t/kernel/Makefile	2004-03-21 11:10:28.615139766 -0500
@@ -22,6 +22,7 @@ obj-$(CONFIG_IKCONFIG) += configs.o
 obj-$(CONFIG_IKCONFIG_PROC) += configs.o
 obj-$(CONFIG_STOP_MACHINE) += stop_machine.o
 obj-$(CONFIG_EVLOG) += evlbuf.o evlapi.o evlposix.o
+obj-$(CONFIG_HOOK) += hook.o
 
 ifneq ($(CONFIG_IA64),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
Index: linux.t/kernel/hook.c
===================================================================
--- linux.t.orig/kernel/hook.c	2003-09-23 13:59:22.000000000 -0400
+++ linux.t/kernel/hook.c	2004-03-21 11:10:28.616139648 -0500
@@ -0,0 +1,320 @@
+/*
+ * Kernel Hooks Interface.
+ * 
+ * Authors: Richard J Moore <richardj_moore@uk.ibm.com>
+ *	    Vamsi Krishna S. <vamsi_krishna@in.ibm.com>
+ * 22 Aug 2003 : Added code for /proc entries and hook priority.
+ * 	  Prasanna S Panchamukhi < prasanna@in.ibm.com>
+ * (C) Copyright IBM Corp. 2002, 2003
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/hook.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+static spinlock_t hook_lock = SPIN_LOCK_UNLOCKED;
+
+static int hook_global_status = 0;
+
+static void calculate_indicies(struct hook *hook)
+{
+	struct hook_rec *rec, *rec_prev;
+	list_for_each_entry(rec, &hook->exit_list, exit_list) {
+		rec_prev = list_entry(rec->exit_list.prev, struct hook_rec, exit_list);
+		rec->hook_index = (rec_prev->hook_index) + 1;
+	}
+	return;
+}
+
+static inline void deactivate_hook(struct hook *hook)
+{
+	hook->hook_flags &= ~HOOK_ACTIVE;
+	if(hook->hook_flags & HOOK_ASM_HOOK)
+		deactivate_asm_hook(hook);
+}
+
+static inline void activate_hook(struct hook *hook)
+{
+	hook->hook_flags |= HOOK_ACTIVE;
+	if(hook->hook_flags & HOOK_ASM_HOOK)
+		activate_asm_hook(hook);
+}
+
+static void disarm_one_hook_exit(struct hook_rec *hook_rec)
+{
+	struct hook_rec *rec;
+	hook_rec->hook_flags &= ~HOOK_ARMED;
+	list_for_each_entry(rec, &hook_rec->hook_head->exit_list, exit_list) {
+		if(rec->hook_flags & HOOK_ARMED) {
+			return;
+		}
+	}
+	deactivate_hook(hook_rec->hook_head);
+}
+#ifdef CONFIG_HOOK_PROCFS
+static struct proc_dir_entry *proc_hooks_dir;
+#define PROC_HOOKS_ROOT "hooks"
+
+static int hook_read_proc(char *page, char **start, off_t off, int count, 
+		int *eof, void *data)
+{
+	int len;
+	struct hook_rec *hook_rec = (struct hook_rec *)data;
+	len = sprintf(page, "%d\n", (hook_rec->hook_flags & HOOK_ARMED));
+	return len;
+}
+
+static int hook_write_proc(struct file *file, const char *buffer, 
+		unsigned long count, void *data)
+{
+	struct hook_rec *hook_rec = (struct hook_rec *)data;
+	char input;
+	int armed;
+
+	if (copy_from_user(&input, buffer, 1)) {
+		return -EFAULT;
+	}
+	armed = input - '0';
+	if (armed && !(hook_rec->hook_flags & HOOK_ARMED)) {
+		hook_exit_arm(hook_rec);
+	} else if (!armed && (hook_rec->hook_flags & HOOK_ARMED)) {
+		hook_exit_disarm(hook_rec);
+	}
+	return count;
+}
+
+static void hook_create_proc(struct hook_rec *hook_rec)
+{
+	char *proc_entry_name;
+	struct hook *hook = (struct hook *) (hook_rec->hook_head);
+
+	if (hook->proc_entry) {
+		char tmp[32];
+		proc_entry_name = hook_rec->hook_exit_name;
+		if (!proc_entry_name) {
+			sprintf(tmp, "%p", hook_rec);
+			proc_entry_name = tmp;
+		}
+		
+		if (!hook_rec->proc_writable) {
+		
+			hook_rec->proc_entry = create_proc_read_entry(
+					proc_entry_name, 0444, 
+					hook->proc_entry, 
+					hook_read_proc,
+					hook_rec);
+		} else {
+			hook_rec->proc_entry = create_proc_entry(
+					proc_entry_name, 0644, 
+					hook->proc_entry);
+			if (hook_rec->proc_entry) {
+				hook_rec->proc_entry->data = hook_rec;
+				hook_rec->proc_entry->read_proc = hook_read_proc;
+				hook_rec->proc_entry->write_proc = hook_write_proc;
+			}
+		}
+	}
+}
+
+static inline void create_hook_exit_proc_entry(struct hook_rec *hook_rec)
+{
+	spin_lock(&hook_lock);
+	if (hook_global_status & HOOK_INIT) {
+		hook_create_proc(hook_rec);
+	}
+	spin_unlock(&hook_lock);
+}
+
+static inline void remove_hook_exit_proc_entry(struct hook_rec *hook_rec)
+{
+	char tmp[32];
+	char *proc_entry_name;
+
+	if (hook_rec->proc_entry) {
+		proc_entry_name = hook_rec->hook_exit_name;
+		if (!proc_entry_name) {
+			sprintf(tmp, "%p", hook_rec);
+			proc_entry_name = tmp;
+		}
+		hook_rec->proc_entry->data = NULL;
+		remove_proc_entry(proc_entry_name, hook_rec->hook_head->proc_entry);
+	}
+}
+
+static inline void create_hook_proc_dir(struct hook *hook)
+{
+	spin_lock(&hook_lock);
+	if (hook_global_status & HOOK_INIT) {
+		hook->proc_entry = proc_mkdir(hook->hook_id, proc_hooks_dir);
+	}
+	spin_unlock(&hook_lock);
+}
+
+static inline void remove_hook_proc_dir(struct hook *hook)
+{
+	if (hook->proc_entry) {
+		remove_proc_entry(hook->hook_id, proc_hooks_dir);
+	}
+}
+
+static void __init init_hook_procfs(void)
+{
+	spin_lock(&hook_lock);
+	proc_hooks_dir = proc_mkdir(PROC_HOOKS_ROOT, NULL);
+	spin_unlock(&hook_lock);
+}
+
+static void __exit cleanup_hook_procfs(void)
+{
+	remove_proc_entry(PROC_HOOKS_ROOT, NULL);
+}
+#else
+static inline void hook_create_proc(struct hook_rec *hook_rec) {}
+static inline void create_hook_exit_proc_entry(struct hook_rec *hook_rec) {}
+static inline void remove_hook_exit_proc_entry(struct hook_rec *hook_rec) {}
+static inline void create_hook_proc_dir(struct hook *hook) {}
+static inline void remove_hook_proc_dir(struct hook *hook) {}
+static inline void init_hook_procfs(void) {}
+static inline void cleanup_hook_procfs(void) {}
+#endif /* CONFIG_HOOK_PROCFS */
+
+int hook_exit_register(struct hook *hook, struct hook_rec *hook_rec)
+{
+	unsigned long flags;
+	struct hook_rec *rec_next, *rec_prev, *rec;
+	struct list_head *hook_link;
+
+	/* During the registeration of hook exits, hook entries are also created
+	 * in the /proc. proc entries cannot be created with irq's disabled.
+	 */
+	if (list_empty(&hook->exit_list)) 
+		create_hook_proc_dir(hook);
+
+	spin_lock_irqsave(&hook_lock, flags);
+	if(hook->hook_flags & HOOK_EXCLUSIVE) {
+		if (!list_empty(&hook->exit_list)) {
+			spin_unlock_irqrestore(&hook_lock, flags);
+			return -EPRIORITY;
+		}
+		hook->hook_ex_exit = hook_rec->hook_exit;
+	}
+	hook_link = &hook->exit_list;
+	rec_next = list_entry(hook->exit_list.next, struct hook_rec, exit_list);
+	rec_prev = list_entry(hook->exit_list.prev, struct hook_rec, exit_list);
+	if ((hook_rec->hook_flags) & HOOK_PRIORITY_FIRST) {
+		if ((!list_empty(&hook->exit_list)) && ((rec_next->hook_flags) & HOOK_PRIORITY_FIRST)) {
+			spin_unlock_irqrestore(&hook_lock, flags);
+			return ERROR_HIGHER_PRIORITY_HOOK;
+		} 
+	}
+	
+	if ((hook_rec->hook_flags) & HOOK_PRIORITY_LAST) {
+		if (!list_empty(&hook->exit_list)) {
+			if ((rec_prev->hook_flags) & HOOK_PRIORITY_LAST) {
+				spin_unlock_irqrestore(&hook_lock, flags);
+				return ERROR_LOWER_PRIORITY_HOOK;
+			} else {
+				hook_link = &rec_prev->exit_list;
+			}
+		}
+	}
+
+	if (!((hook_rec->hook_flags) & HOOK_PRIORITY)) {
+		if ((hook_rec->hook_flags) & HOOK_QUEUE_LIFO) {
+			if ((!list_empty(&hook->exit_list)) && ((rec_next->hook_flags) & HOOK_PRIORITY_FIRST)) 
+				hook_link = &rec_next->exit_list;
+		} else if ((!list_empty(&hook->exit_list)) && ((rec_prev->hook_flags) & HOOK_PRIORITY_LAST)) {
+			rec = list_entry(rec_prev->exit_list.prev, struct hook_rec, exit_list);
+			hook_link = &rec->exit_list;
+		} else 
+			hook_link = &rec_prev->exit_list;
+	}
+	
+	list_add(&hook_rec->exit_list, hook_link);
+	hook_rec->hook_head = hook;
+
+	calculate_indicies(hook_rec->hook_head);
+
+	if(is_asm_hook(hook->hook_addr))
+		hook->hook_flags |= HOOK_ASM_HOOK;
+
+	try_module_get(THIS_MODULE);
+	spin_unlock_irqrestore(&hook_lock, flags);
+
+	/* Creates entries in /proc, for hook exits.*/
+	create_hook_exit_proc_entry(hook_rec);
+	return 0;
+}
+
+void hook_exit_deregister(struct hook_rec *rec)
+{
+	unsigned long flags;
+	struct hook *hook;
+
+	spin_lock_irqsave(&hook_lock, flags);
+	if(rec->hook_flags & HOOK_ARMED)
+		disarm_one_hook_exit(rec);
+	if(rec->hook_head->hook_flags & HOOK_EXCLUSIVE)
+		rec->hook_head->hook_ex_exit = NULL;
+	list_del(&rec->exit_list);
+	/* Remove hook exit entries from /proc. */
+	remove_hook_exit_proc_entry(rec);
+	hook = rec->hook_head;
+	calculate_indicies(rec->hook_head);
+
+	/* Remove hook entries from /proc. */
+	if (list_empty(&hook->exit_list))
+		remove_hook_proc_dir(hook);
+		 
+	module_put(THIS_MODULE);
+	spin_unlock_irqrestore(&hook_lock, flags);
+}
+
+void hook_exit_arm(struct hook_rec *rec)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hook_lock, flags);
+	rec->hook_flags |= HOOK_ARMED;
+	if(!(rec->hook_head->hook_flags & HOOK_ACTIVE))
+		activate_hook(rec->hook_head);
+	spin_unlock_irqrestore(&hook_lock, flags);
+}
+
+void hook_exit_disarm(struct hook_rec *rec)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hook_lock, flags);
+	disarm_one_hook_exit(rec);
+	spin_unlock_irqrestore(&hook_lock, flags);
+}
+
+static int __init hook_init_module(void)
+{
+	hook_global_status |= HOOK_INIT;
+	init_hook_procfs();
+	printk(KERN_INFO "Kernel Hooks Interface installed.\n");
+	return 0;
+}
+
+static void __exit hook_cleanup_module(void)
+{
+	cleanup_hook_procfs();
+	printk(KERN_INFO "Kernel Hooks Interface terminated.\n");
+}
+
+module_init(hook_init_module);
+module_exit(hook_cleanup_module);
+
+EXPORT_SYMBOL(hook_exit_deregister);
+EXPORT_SYMBOL(hook_exit_arm);
+EXPORT_SYMBOL(hook_exit_disarm);
+EXPORT_SYMBOL(hook_exit_register);
+
+MODULE_LICENSE("GPL");
