diff -X excl -purNa linux-2.6.1.tmp/include/net/ip6_route.h linux-2.6.1.ipv6-subtree/include/net/ip6_route.h
--- linux-2.6.1.tmp/include/net/ip6_route.h	2004-01-09 07:59:18.000000000 +0100
+++ linux-2.6.1.ipv6-subtree/include/net/ip6_route.h	2004-01-30 12:39:14.000000000 +0100
@@ -64,6 +64,7 @@ extern struct rt6_info		*rt6_lookup(stru
 
 extern struct dst_entry *ndisc_dst_alloc(struct net_device *dev,
 					 struct neighbour *neigh,
+					 struct in6_addr *addr,
 					 int (*output)(struct sk_buff *));
 extern int ndisc_dst_gc(int *more);
 extern void fib6_force_start_gc(void);
diff -X excl -purNa linux-2.6.1.tmp/include/net/ipv6.h linux-2.6.1.ipv6-subtree/include/net/ipv6.h
--- linux-2.6.1.tmp/include/net/ipv6.h	2004-01-29 16:15:41.000000000 +0100
+++ linux-2.6.1.ipv6-subtree/include/net/ipv6.h	2004-01-30 12:35:07.000000000 +0100
@@ -385,6 +385,7 @@ extern int			ip6_dst_lookup(struct sock 
  */
 
 extern int			ip6_output(struct sk_buff *skb);
+extern int			ip6_output2(struct sk_buff *skb);
 extern int			ip6_forward(struct sk_buff *skb);
 extern int			ip6_input(struct sk_buff *skb);
 extern int			ip6_mc_input(struct sk_buff *skb);
diff -X excl -purNa linux-2.6.1.tmp/include/net/ndisc.h linux-2.6.1.ipv6-subtree/include/net/ndisc.h
--- linux-2.6.1.tmp/include/net/ndisc.h	2004-01-29 16:15:34.000000000 +0100
+++ linux-2.6.1.ipv6-subtree/include/net/ndisc.h	2004-01-30 12:35:50.000000000 +0100
@@ -45,6 +45,11 @@ struct nd_msg {
 	__u8		opt[0];
 };
 
+struct rs_msg {
+	struct icmp6hdr	icmph;
+	__u8		opt[0];
+};
+
 struct ra_msg {
         struct icmp6hdr		icmph;
 	__u32			reachable_time;
diff -X excl -purNa linux-2.6.1.tmp/include/net/neighbour.h linux-2.6.1.ipv6-subtree/include/net/neighbour.h
--- linux-2.6.1.tmp/include/net/neighbour.h	2004-01-29 16:15:34.000000000 +0100
+++ linux-2.6.1.ipv6-subtree/include/net/neighbour.h	2004-01-30 11:49:59.000000000 +0100
@@ -46,10 +46,16 @@
 #include <asm/atomic.h>
 #include <linux/skbuff.h>
 
+#include <linux/config.h>
+
 #include <linux/err.h>
 #include <linux/sysctl.h>
 
+#ifdef CONFIG_IPV6_NDISC_NEW
+#define NUD_IN_TIMER	(NUD_INCOMPLETE|NUD_REACHABLE|NUD_DELAY|NUD_PROBE)
+#else
 #define NUD_IN_TIMER	(NUD_INCOMPLETE|NUD_DELAY|NUD_PROBE)
+#endif
 #define NUD_VALID	(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE|NUD_PROBE|NUD_STALE|NUD_DELAY)
 #define NUD_CONNECTED	(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE)
 
@@ -171,6 +177,51 @@ struct neigh_table
 	struct pneigh_entry	*phash_buckets[PNEIGH_HASHMASK+1];
 };
 
+static __inline__ char * neigh_state(int state)
+{
+	switch (state) {
+	case NUD_NONE:		return "NONE";
+	case NUD_INCOMPLETE:	return "INCOMPLETE";
+	case NUD_REACHABLE:	return "REACHABLE";
+	case NUD_STALE:		return "STALE";
+	case NUD_DELAY:		return "DELAY";
+	case NUD_PROBE:		return "PROBE";
+	case NUD_FAILED:	return "FAILED";
+	case NUD_NOARP:		return "NOARP";
+	case NUD_PERMANENT:	return "PERMANENT";
+	default:		return "???";
+	}
+}
+
+/* flags for __neigh_update() */
+#define NEIGH_UPDATE_F_ADMIN			0x00000001
+#define NEIGH_UPDATE_F_ISROUTER			0x00000002
+#define NEIGH_UPDATE_F_OVERRIDE			0x00000004
+#define NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER	0x00000008
+#define NEIGH_UPDATE_F_REUSEADDR		0x00000010
+#define NEIGH_UPDATE_F_REUSESUSPECTSTATE	0x00000020
+#define NEIGH_UPDATE_F_SETUP_ISROUTER		0x00000040
+#define NEIGH_UPDATE_F_SUSPECT_CONNECTED	0x00000080
+
+#define NEIGH_UPDATE_F_IP6NS		(NEIGH_UPDATE_F_SETUP_ISROUTER|\
+					 NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_OVERRIDE)
+#define NEIGH_UPDATE_F_IP6NA		(NEIGH_UPDATE_F_SETUP_ISROUTER|\
+					 NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_SUSPECT_CONNECTED|\
+					 NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER)
+#define NEIGH_UPDATE_F_IP6RS		(NEIGH_UPDATE_F_SETUP_ISROUTER|\
+					 NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_OVERRIDE|\
+					 NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER)
+#define NEIGH_UPDATE_F_IP6RA		(NEIGH_UPDATE_F_SETUP_ISROUTER|\
+					 NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_OVERRIDE|\
+					 NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER|\
+					 NEIGH_UPDATE_F_ISROUTER)
+#define NEIGH_UPDATE_F_IP6REDIRECT	(NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_OVERRIDE)
+
 extern void			neigh_table_init(struct neigh_table *tbl);
 extern int			neigh_table_clear(struct neigh_table *tbl);
 extern struct neighbour *	neigh_lookup(struct neigh_table *tbl,
@@ -181,6 +232,7 @@ extern struct neighbour *	neigh_create(s
 					     struct net_device *dev);
 extern void			neigh_destroy(struct neighbour *neigh);
 extern int			__neigh_event_send(struct neighbour *neigh, struct sk_buff *skb);
+extern int			__neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, u32 flags);
 extern int			neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, int override, int arp);
 extern void			neigh_changeaddr(struct neigh_table *tbl, struct net_device *dev);
 extern int			neigh_ifdown(struct neigh_table *tbl, struct net_device *dev);
@@ -206,6 +258,7 @@ extern int neigh_dump_info(struct sk_buf
 extern int neigh_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg);
 extern int neigh_delete(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg);
 extern void neigh_app_ns(struct neighbour *n);
+extern void neigh_app_notify(struct neighbour *n);
 
 extern int			neigh_sysctl_register(struct net_device *dev, 
 						      struct neigh_parms *p,
@@ -220,18 +273,35 @@ extern void			neigh_sysctl_unregister(st
 
 static inline void neigh_release(struct neighbour *neigh)
 {
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+	printk(KERN_DEBUG "%s(neigh=%p): refcnt=%d\n",
+		__FUNCTION__, neigh, atomic_read(&neigh->refcnt)-1);
+#endif
 	if (atomic_dec_and_test(&neigh->refcnt))
 		neigh_destroy(neigh);
 }
 
 static inline struct neighbour * neigh_clone(struct neighbour *neigh)
 {
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+	printk(KERN_DEBUG "%s(neigh=%p): refcnt=%d\n",
+		__FUNCTION__, neigh, neigh ? atomic_read(&neigh->refcnt)+1 : 0);
+#endif
 	if (neigh)
 		atomic_inc(&neigh->refcnt);
 	return neigh;
 }
 
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+#define neigh_hold(n)	({	\
+	struct neighbour *_n = (n);		\
+	printk(KERN_DEBUG "%s(neigh=%p): refcnt=%d\n", \
+		__FUNCTION__, _n, atomic_read(&_n->refcnt)+1);	\
+	atomic_inc(&_n->refcnt);	\
+})
+#else
 #define neigh_hold(n)	atomic_inc(&(n)->refcnt)
+#endif
 
 static inline void neigh_confirm(struct neighbour *neigh)
 {
@@ -251,10 +321,24 @@ static inline int neigh_is_valid(struct 
 
 static inline int neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)
 {
+	int ret = 0;
+
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+	printk(KERN_DEBUG
+		"%s(neigh=%p, skb=%p): %s, refcnt=%d\n",
+		__FUNCTION__, neigh, skb, neigh_state(neigh->nud_state), atomic_read(&neigh->refcnt));
+#endif
+	write_lock_bh(&neigh->lock);
 	neigh->used = jiffies;
 	if (!(neigh->nud_state&(NUD_CONNECTED|NUD_DELAY|NUD_PROBE)))
-		return __neigh_event_send(neigh, skb);
-	return 0;
+		ret = __neigh_event_send(neigh, skb);
+	write_unlock_bh(&neigh->lock);
+	if (ret < 0) {
+		if (skb)
+			kfree_skb(skb);
+		ret = 1;
+	}
+	return ret;
 }
 
 static inline struct neighbour *
@@ -281,6 +365,23 @@ __neigh_lookup_errno(struct neigh_table 
 	return neigh_create(tbl, pkey, dev);
 }
 
+static inline struct pneigh_entry *pneigh_clone(struct pneigh_entry *pneigh)
+{
+	return pneigh;
+}
+
+static inline void pneigh_refcnt_init(struct pneigh_entry *pneigh) {}
+
+static inline int pneigh_refcnt_dec_and_test(struct pneigh_entry *pneigh)
+{
+	return 1;
+}
+
+static inline int pneigh_alloc_flag(void)
+{
+	return GFP_KERNEL;
+}
+
 #endif
 #endif
 
diff -X excl -purNa linux-2.6.1.tmp/net/core/neighbour.c linux-2.6.1.ipv6-subtree/net/core/neighbour.c
--- linux-2.6.1.tmp/net/core/neighbour.c	2004-01-29 16:15:35.000000000 +0100
+++ linux-2.6.1.ipv6-subtree/net/core/neighbour.c	2004-01-30 11:41:31.000000000 +0100
@@ -30,13 +30,18 @@
 #include <net/sock.h>
 #include <linux/rtnetlink.h>
 
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+#define NEIGH_DEBUG 3
+#else
 #define NEIGH_DEBUG 1
+#endif
 
 #define NEIGH_PRINTK(x...) printk(x)
 #define NEIGH_NOPRINTK(x...) do { ; } while(0)
 #define NEIGH_PRINTK0 NEIGH_PRINTK
 #define NEIGH_PRINTK1 NEIGH_NOPRINTK
 #define NEIGH_PRINTK2 NEIGH_NOPRINTK
+#define NEIGH_PRINTK3 NEIGH_NOPRINTK
 
 #if NEIGH_DEBUG >= 1
 #undef NEIGH_PRINTK1
@@ -46,11 +51,12 @@
 #undef NEIGH_PRINTK2
 #define NEIGH_PRINTK2 NEIGH_PRINTK
 #endif
+#if NEIGH_DEBUG >= 3
+#undef NEIGH_PRINTK3
+#define NEIGH_PRINTK3 NEIGH_PRINTK
+#endif
 
 static void neigh_timer_handler(unsigned long arg);
-#ifdef CONFIG_ARPD
-static void neigh_app_notify(struct neighbour *n);
-#endif
 static int pneigh_ifdown(struct neigh_table *tbl, struct net_device *dev);
 void neigh_changeaddr(struct neigh_table *tbl, struct net_device *dev);
 
@@ -389,10 +395,11 @@ struct pneigh_entry * pneigh_lookup(stru
 	if (!creat)
 		goto out;
 
-	n = kmalloc(sizeof(*n) + key_len, GFP_KERNEL);
+	n = kmalloc(sizeof(*n) + key_len, pneigh_alloc_flag());
 	if (!n)
 		goto out;
 
+	pneigh_refcnt_init(n);
 	memcpy(n->key, pkey, key_len);
 	n->dev = dev;
 
@@ -426,6 +433,9 @@ int pneigh_delete(struct neigh_table *tb
 	for (np = &tbl->phash_buckets[hash_val]; (n = *np) != NULL;
 	     np = &n->next) {
 		if (!memcmp(n->key, pkey, key_len) && n->dev == dev) {
+			if (!pneigh_refcnt_dec_and_test(n)) {
+				return 0;
+			}
 			write_lock_bh(&tbl->lock);
 			*np = n->next;
 			write_unlock_bh(&tbl->lock);
@@ -536,6 +546,7 @@ static void neigh_connect(struct neighbo
 		hh->hh_output = neigh->ops->hh_output;
 }
 
+#ifndef CONFIG_IPV6_NDISC_NEW
 /*
    Transitions NUD_STALE <-> NUD_REACHABLE do not occur
    when fast path is built: we have no timers associated with
@@ -569,6 +580,7 @@ static void neigh_sync(struct neighbour 
 		}
 	}
 }
+#endif
 
 static void neigh_periodic_timer(unsigned long arg)
 {
@@ -619,11 +631,13 @@ static void neigh_periodic_timer(unsigne
 				continue;
 			}
 
+#ifndef CONFIG_IPV6_NDISC_NEW
 			if (n->nud_state & NUD_REACHABLE &&
 			    now - n->confirmed > n->parms->reachable_time) {
 				n->nud_state = NUD_STALE;
 				neigh_suspect(n);
 			}
+#endif
 			write_unlock(&n->lock);
 
 next_elt:
@@ -648,40 +662,94 @@ static __inline__ int neigh_max_probes(s
 
 static void neigh_timer_handler(unsigned long arg)
 {
-	unsigned long now = jiffies;
+	unsigned long now, next;
 	struct neighbour *neigh = (struct neighbour *)arg;
 	unsigned state;
-	int notify = 0;
 
-	write_lock(&neigh->lock);
+	int refcnt;
 
+	write_lock_bh(&neigh->lock);
+	now = jiffies;
+	next = now + HZ;
+	
 	state = neigh->nud_state;
 
 	if (!(state & NUD_IN_TIMER)) {
 #ifndef CONFIG_SMP
 		printk(KERN_WARNING "neigh: timer & !nud_in_timer\n");
 #endif
-		goto out;
+		write_unlock_bh(&neigh->lock);
+		refcnt = atomic_read(&neigh->refcnt) - 1;
+		neigh_release(neigh);
+		NEIGH_PRINTK3(KERN_DEBUG 
+				"%s(): => state=%s, refcnt=%d\n",
+				__FUNCTION__, neigh_state(state), refcnt);
+		return;
 	}
 
+#ifdef CONFIG_IPV6_NDISC_NEW
+	if (state & NUD_REACHABLE) {
+		if (now - neigh->confirmed < neigh->parms->reachable_time) {
+			next = neigh->confirmed + neigh->parms->reachable_time;
+		} else if (now - neigh->used <= neigh->parms->delay_probe_time) {
+			neigh->nud_state = NUD_DELAY;
+			neigh_suspect(neigh);
+			next = now + neigh->parms->delay_probe_time;
+		} else {
+			neigh->nud_state = NUD_STALE;
+			neigh_suspect(neigh);
+		}
+	} else if (state & NUD_DELAY) {
+		if (now - neigh->confirmed <= neigh->parms->delay_probe_time) {
+			neigh->nud_state = NUD_REACHABLE;
+			neigh_connect(neigh);
+			next = neigh->confirmed + neigh->parms->reachable_time;
+		} else {
+			neigh->nud_state = NUD_PROBE;
+			atomic_set(&neigh->probes, 0);
+			next = now + neigh->parms->retrans_time;
+		}
+	} else {
+		/* PROBE,INCOMPLETE */
+		next = now + neigh->parms->retrans_time;
+	}
+#else
 	if ((state & NUD_VALID) &&
 	    now - neigh->confirmed < neigh->parms->reachable_time) {
-		neigh->nud_state = NUD_REACHABLE;
+		state = neigh->nud_state = NUD_REACHABLE;
 		NEIGH_PRINTK2("neigh %p is still alive.\n", neigh);
 		neigh_connect(neigh);
-		goto out;
+		refcnt = atomic_read(&neigh->refcnt) - 1;
+		write_unlock_bh(&neigh->lock);
+		neigh_release(neigh);
+		NEIGH_PRINTK3(KERN_DEBUG 
+				"%s(): => state=%s, refcnt=%d\n",
+				__FUNCTION__, 
+				neigh_state(state), refcnt);
+		return;
 	}
 	if (state == NUD_DELAY) {
 		NEIGH_PRINTK2("neigh %p is probed.\n", neigh);
 		neigh->nud_state = NUD_PROBE;
 		atomic_set(&neigh->probes, 0);
 	}
+#endif
 
-	if (atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {
+	if (
+#ifdef CONFIG_IPV6_NDISC_NEW
+	    (neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE)) &&
+#endif
+	    atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {
 		struct sk_buff *skb;
 
-		neigh->nud_state = NUD_FAILED;
-		notify = 1;
+#ifdef CONFIG_IPV6_NDISC_NEW
+		neigh->updated = now;
+#endif
+		state = neigh->nud_state = NUD_FAILED;
+
+#ifdef CONFIG_IPV6_NDISC_NEW
+		del_timer(&neigh->timer);	/* release neigh later */
+#endif
 		neigh->tbl->stats.res_failed++;
 		NEIGH_PRINTK2("neigh %p is failed.\n", neigh);
 
@@ -692,62 +760,113 @@ static void neigh_timer_handler(unsigned
 		 */
 		while (neigh->nud_state == NUD_FAILED &&
 		       (skb = __skb_dequeue(&neigh->arp_queue)) != NULL) {
-			write_unlock(&neigh->lock);
+			write_unlock_bh(&neigh->lock);
 			neigh->ops->error_report(neigh, skb);
-			write_lock(&neigh->lock);
+			write_lock_bh(&neigh->lock);
 		}
 		skb_queue_purge(&neigh->arp_queue);
-		goto out;
+#ifdef CONFIG_ARPD
+		if (neigh->parms->app_probes) {
+			write_unlock_bh(&neigh->lock);
+			neigh_app_notify(neigh);
+		} else
+#endif
+		refcnt = atomic_read(&neigh->refcnt) - 1;
+		write_unlock_bh(&neigh->lock);
+
+		neigh_release(neigh);
+
+		NEIGH_PRINTK3(KERN_DEBUG 
+				"%s(): => state=%s, refcnt=%d\n",
+				__FUNCTION__, 
+				neigh_state(state), refcnt);
+
+		return;
 	}
 
+#ifdef CONFIG_IPV6_NDISC_NEW
+	if (neigh->nud_state & NUD_IN_TIMER) {
+		neigh_hold(neigh);
+		if (time_before(next, jiffies + HZ/2))
+			next = jiffies + HZ/2;
+		mod_timer(&neigh->timer, next);
+		if (neigh->nud_state&(NUD_INCOMPLETE|NUD_PROBE)) {
+			write_unlock_bh(&neigh->lock);
+			neigh->ops->solicit(neigh, skb_peek(&neigh->arp_queue));
+			atomic_inc(&neigh->probes);
+		} else {
+			write_unlock_bh(&neigh->lock);
+		}
+	} else {
+		del_timer(&neigh->timer);
+		write_unlock_bh(&neigh->lock);
+	}
+	refcnt = atomic_read(&neigh->refcnt) - 1;
+	state = neigh->nud_state;
+	neigh_release(neigh);
+#else
 	neigh->timer.expires = now + neigh->parms->retrans_time;
 	add_timer(&neigh->timer);
-	write_unlock(&neigh->lock);
+
+	refcnt = atomic_read(&neigh->refcnt);
+	state = neigh->nud_state;
+	write_unlock_bh(&neigh->lock);
 
 	neigh->ops->solicit(neigh, skb_peek(&neigh->arp_queue));
 	atomic_inc(&neigh->probes);
-	return;
-
-out:
-	write_unlock(&neigh->lock);
-#ifdef CONFIG_ARPD
-	if (notify && neigh->parms->app_probes)
-		neigh_app_notify(neigh);
 #endif
-	neigh_release(neigh);
+	NEIGH_PRINTK3(KERN_DEBUG 
+			"%s(): => state=%s, refcnt=%d\n",
+			__FUNCTION__, 
+			neigh_state(state), refcnt);
+
+	return;
 }
 
 int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)
 {
-	int rc;
-
-	write_lock_bh(&neigh->lock);
+	int rc = 0;
+	unsigned long now = jiffies;
+	
+	NEIGH_PRINTK3(KERN_DEBUG 
+			"%s(neigh=%p, skb=%p): %s\n",
+			__FUNCTION__, 
+			neigh, skb, neigh_state(neigh->nud_state));
 
-	rc = 0;
 	if (neigh->nud_state & (NUD_CONNECTED | NUD_DELAY | NUD_PROBE))
-		goto out_unlock_bh;
+		goto out;
 
 	if (!(neigh->nud_state & (NUD_STALE | NUD_INCOMPLETE))) {
 		if (neigh->parms->mcast_probes + neigh->parms->app_probes) {
 			atomic_set(&neigh->probes, neigh->parms->ucast_probes);
 			neigh->nud_state     = NUD_INCOMPLETE;
 			neigh_hold(neigh);
-			neigh->timer.expires = jiffies +
+#ifdef CONFIG_IPV6_NDISC_NEW
+			neigh->timer.expires = now;
+#else
+			neigh->timer.expires = now +
 					       neigh->parms->retrans_time;
+#endif
 			add_timer(&neigh->timer);
+#ifndef CONFIG_IPV6_NDISC_NEW
 			write_unlock_bh(&neigh->lock);
 			neigh->ops->solicit(neigh, skb);
 			atomic_inc(&neigh->probes);
 			write_lock_bh(&neigh->lock);
+#endif
 		} else {
 			neigh->nud_state = NUD_FAILED;
-			write_unlock_bh(&neigh->lock);
-
-			if (skb)
-				kfree_skb(skb);
-			return 1;
+			return -1;
 		}
 	}
+#ifdef CONFIG_IPV6_NDISC_NEW
+	else if (neigh->nud_state == NUD_STALE) {
+		neigh_hold(neigh);
+		neigh->nud_state = NUD_DELAY;
+		neigh->timer.expires = now + neigh->parms->delay_probe_time;
+		add_timer(&neigh->timer);
+	}
+#endif
 
 	if (neigh->nud_state == NUD_INCOMPLETE) {
 		if (skb) {
@@ -761,16 +880,18 @@ int __neigh_event_send(struct neighbour 
 			__skb_queue_tail(&neigh->arp_queue, skb);
 		}
 		rc = 1;
-	} else if (neigh->nud_state == NUD_STALE) {
+	}
+#ifndef CONFIG_IPV6_NDISC_NEW
+	else if (neigh->nud_state == NUD_STALE) {
 		NEIGH_PRINTK2("neigh %p is delayed.\n", neigh);
 		neigh_hold(neigh);
 		neigh->nud_state = NUD_DELAY;
-		neigh->timer.expires = jiffies + neigh->parms->delay_probe_time;
+		neigh->timer.expires = now + neigh->parms->delay_probe_time;
 		add_timer(&neigh->timer);
 		rc = 0;
 	}
-out_unlock_bh:
-	write_unlock_bh(&neigh->lock);
+#endif
+out:
 	return rc;
 }
 
@@ -794,32 +915,57 @@ static __inline__ void neigh_update_hhs(
 /* Generic update routine.
    -- lladdr is new lladdr or NULL, if it is not supplied.
    -- new    is new state.
-   -- override == 1 allows to override existing lladdr, if it is different.
-   -- arp == 0 means that the change is administrative.
+   -- flags  specifies details of update
 
    Caller MUST hold reference count on the entry.
+   __neigh_update() is called under write_lock_bh().
+
  */
 
-int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,
-		 int override, int arp)
+int __neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, u32 flags)
 {
 	u8 old;
 	int err;
-#ifdef CONFIG_ARPD
 	int notify = 0;
-#endif
 	struct net_device *dev;
+#ifdef CONFIG_IPV6_NDISC_NEW
+	unsigned long now = jiffies;
+	int hold = 0;
+	int update_isrouter = 0;
 
-	write_lock_bh(&neigh->lock);
+	NEIGH_PRINTK3(KERN_DEBUG
+			"%s(neigh=%p, lladdr=%p, new=%u, flags=%08x): %s\n",
+			__FUNCTION__,
+			neigh, lladdr, new, flags, neigh_state(neigh->nud_state));
+	
+	if (!neigh) {
+		NEIGH_PRINTK1(KERN_WARNING "__neigh_update(): neigh==NULL\n");
+		return -EINVAL;
+	}
 
+	old = neigh->nud_state;
+#endif /* CONFIG_IPV6_NDISC_NEW */
+
+#ifndef CONFIG_IPV6_NDISC_NEW
 	dev    = neigh->dev;
 	old    = neigh->nud_state;
 	err    = -EPERM;
+#else /* CONFIG_IPV6_NDISC_NEW */
+	dev = neigh->dev;
+	if (!dev) {
+		NEIGH_PRINTK1(KERN_WARNING "__neigh_update(): neigh->dev==NULL\n");
+		return -EINVAL;
+	}
+#endif /* CONFIG_IPV6_NDISC_NEW */
 
-	if (arp && (old & (NUD_NOARP | NUD_PERMANENT)))
+	err = -EPERM;
+	if (!(flags & NEIGH_UPDATE_F_ADMIN) && (old & (NUD_NOARP | NUD_PERMANENT)))
 		goto out;
 
 	if (!(new & NUD_VALID)) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+		/* NONE,INCOMPLETE,FAILED */
+#endif /* CONFIG_IPV6_NDISC_NEW */
 		neigh_del_timer(neigh);
 		if (old & NUD_CONNECTED)
 			neigh_suspect(neigh);
@@ -844,8 +990,10 @@ int neigh_update(struct neighbour *neigh
 		if (old & NUD_VALID) {
 			if (!memcmp(lladdr, neigh->ha, dev->addr_len))
 				lladdr = neigh->ha;
-			else if (!override)
+#ifndef CONFIG_IPV6_NDISC_NEW
+			else if (!(flags & NEIGH_UPDATE_F_OVERRIDE))
 				goto out;
+#endif /* not CONFIG_IPV6_NDISC_NEW */
 		}
 	} else {
 		/* No address is supplied; if we know something,
@@ -857,28 +1005,93 @@ int neigh_update(struct neighbour *neigh
 		lladdr = neigh->ha;
 	}
 
+#ifndef CONFIG_IPV6_NDISC_NEW
 	neigh_sync(neigh);
 	old = neigh->nud_state;
 	if (new & NUD_CONNECTED)
 		neigh->confirmed = jiffies;
 	neigh->updated = jiffies;
 
+#endif /* not CONFIG_IPV6_NDISC_NEW */
 	/* If entry was valid and address is not changed,
 	   do not change entry state, if new one is STALE.
 	 */
 	err = 0;
+#ifndef CONFIG_IPV6_NDISC_NEW
 	if ((old & NUD_VALID) && lladdr == neigh->ha &&
 	    (new == old || (new == NUD_STALE && (old & NUD_CONNECTED))))
 		goto out;
+#else /* CONFIG_IPV6_NDISC_NEW */
+	if (old & NUD_VALID) {
+		if (lladdr != neigh->ha &&
+		    !(flags & NEIGH_UPDATE_F_OVERRIDE)) {
+			if ((flags & NEIGH_UPDATE_F_SUSPECT_CONNECTED) &&
+			    (old & NUD_CONNECTED)) {
+				new = NUD_STALE;
+				lladdr = neigh->ha;
+			} else {
+				goto out;
+			}
+		} else {
+			if ((flags & NEIGH_UPDATE_F_REUSEADDR) &&
+			    new == old)
+				lladdr = neigh->ha;
+			else if (lladdr == neigh->ha && new == NUD_STALE) {
+				if ((flags & NEIGH_UPDATE_F_REUSESUSPECTSTATE) ||
+				    (old & NUD_CONNECTED))
+					new = old;
+			}
+			update_isrouter = flags & NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER;
+		}
+	} else {
+		/* INCOMPLETE */
+		update_isrouter = flags&NEIGH_UPDATE_F_SETUP_ISROUTER;
+	}
+#endif /* CONFIG_IPV6_NDISC_NEW */
 
+#ifndef CONFIG_IPV6_NDISC_NEW
 	neigh_del_timer(neigh);
 	neigh->nud_state = new;
+#else /* CONFIG_IPV6_NDISC_NEW */
+	if (new != old) {
+		if (new & NUD_IN_TIMER) {
+			unsigned long next = now;
+			switch(new) {
+			case NUD_REACHABLE:
+				next += neigh->parms->reachable_time;
+				break;
+			default:;
+				/*XXX*/
+			}
+			if (old & NUD_IN_TIMER) {
+				mod_timer(&neigh->timer, next);
+			} else {
+				neigh_hold(neigh);
+				neigh->timer.expires = next;
+				add_timer(&neigh->timer);
+			}
+		} else {
+			neigh_del_timer(neigh);
+		}
+		neigh->nud_state = new;
+	}
+	if ((new != old || lladdr != neigh->ha) &&
+	    new & NUD_CONNECTED)
+		neigh->confirmed = now;
+#endif /* CONFIG_IPV6_NDISC_NEW */
 	if (lladdr != neigh->ha) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+		neigh->updated = now;
+#endif /* CONFIG_IPV6_NDISC_NEW */
 		memcpy(&neigh->ha, lladdr, dev->addr_len);
 		neigh_update_hhs(neigh);
 		if (!(new & NUD_CONNECTED))
+#ifndef CONFIG_IPV6_NDISC_NEW
 			neigh->confirmed = jiffies -
 				      (neigh->parms->base_reachable_time << 1);
+#else /* CONFIG_IPV6_NDISC_NEW */
+			neigh->confirmed = now - (neigh->parms->base_reachable_time<<1);
+#endif /* CONFIG_IPV6_NDISC_NEW */
 #ifdef CONFIG_ARPD
 		notify = 1;
 #endif
@@ -893,6 +1106,13 @@ int neigh_update(struct neighbour *neigh
 		struct sk_buff *skb;
 
 		/* Again: avoid dead loop if something went wrong */
+#ifdef CONFIG_IPV6_NDISC_NEW
+		neigh_hold(neigh);	/* don't release neigh while processing */
+		hold = 1;
+
+		if (new&NUD_VALID)
+			notify = 1;
+#endif /* CONFIG_IPV6_NDISC_NEW */
 
 		while (neigh->nud_state & NUD_VALID &&
 		       (skb = __skb_dequeue(&neigh->arp_queue)) != NULL) {
@@ -907,20 +1127,68 @@ int neigh_update(struct neighbour *neigh
 		skb_queue_purge(&neigh->arp_queue);
 	}
 out:
-	write_unlock_bh(&neigh->lock);
+#ifdef CONFIG_IPV6_NDISC_NEW
+	if (update_isrouter) {
+		neigh->flags = (flags & NEIGH_UPDATE_F_ISROUTER) ?
+				(neigh->flags | NTF_ROUTER) :
+				(neigh->flags & ~NTF_ROUTER);
+	}
+
+	if (hold)
+		neigh_release(neigh);
+#endif /* CONFIG_IPV6_NDISC_NEW */
+
+	NEIGH_PRINTK3(KERN_DEBUG
+			"%s() => %s\n",
+			__FUNCTION__,
+			neigh_state(neigh->nud_state));
+
+	return err ? err : notify;
+}
+
+int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,
+		 int override, int arp)
+{
+	int update;
+
+	NEIGH_PRINTK3(KERN_DEBUG
+			"%s(neigh=%p, lladdr=%p, new=%u, override=%d, arp=%d): %s\n",
+			__FUNCTION__, 
+			neigh, lladdr, new, override, arp,
+			neigh_state(neigh->nud_state));
+
+	neigh_hold(neigh);
+	write_lock_bh(&neigh->lock);
+	update = __neigh_update(neigh, lladdr, new, 
+#ifdef CONFIG_IPV6_NDISC_NEW
+				NEIGH_UPDATE_F_REUSEADDR |
+#endif /* CONFIG_IPV6_NDISC_NEW */
+				(override ? NEIGH_UPDATE_F_OVERRIDE : 0) |
+				(arp ? 0 : NEIGH_UPDATE_F_ADMIN));
 #ifdef CONFIG_ARPD
-	if (notify && neigh->parms->app_probes)
+	if (update > 0 && neigh->parms->app_probes) {
+		write_unlock_bh(&neigh->lock);
 		neigh_app_notify(neigh);
+	} else
 #endif
-	return err;
+	write_unlock_bh(&neigh->lock);
+	neigh_release(neigh);	/*XXX: may invalidate neigh... */
+	return update >= 0 ? 0 : update;
 }
 
 struct neighbour *neigh_event_ns(struct neigh_table *tbl,
 				 u8 *lladdr, void *saddr,
 				 struct net_device *dev)
 {
-	struct neighbour *neigh = __neigh_lookup(tbl, saddr, dev,
-						 lladdr || !dev->addr_len);
+	struct neighbour *neigh;
+
+	NEIGH_PRINTK3(KERN_DEBUG
+			"%s(tbl=%p, lladdr=%p, saddr=%p, dev=%p)\n",
+			__FUNCTION__, 
+			tbl, lladdr, saddr, dev);
+
+	neigh = __neigh_lookup(tbl, saddr, dev,
+			       lladdr || !dev->addr_len);
 	if (neigh)
 		neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
 	return neigh;
@@ -1454,7 +1722,7 @@ void neigh_app_ns(struct neighbour *n)
 	netlink_broadcast(rtnl, skb, 0, RTMGRP_NEIGH, GFP_ATOMIC);
 }
 
-static void neigh_app_notify(struct neighbour *n)
+void neigh_app_notify(struct neighbour *n)
 {
 	struct nlmsghdr *nlh;
 	int size = NLMSG_SPACE(sizeof(struct ndmsg) + 256);
@@ -1736,6 +2004,7 @@ EXPORT_SYMBOL(neigh_rand_reach_time);
 EXPORT_SYMBOL(neigh_resolve_output);
 EXPORT_SYMBOL(neigh_table_clear);
 EXPORT_SYMBOL(neigh_table_init);
+EXPORT_SYMBOL(__neigh_update);
 EXPORT_SYMBOL(neigh_update);
 EXPORT_SYMBOL(neigh_update_hhs);
 EXPORT_SYMBOL(pneigh_enqueue);
@@ -1743,6 +2012,7 @@ EXPORT_SYMBOL(pneigh_lookup);
 
 #ifdef CONFIG_ARPD
 EXPORT_SYMBOL(neigh_app_ns);
+EXPORT_SYMBOL(neigh_app_notify);
 #endif
 #ifdef CONFIG_SYSCTL
 EXPORT_SYMBOL(neigh_sysctl_register);
diff -X excl -purNa linux-2.6.1.tmp/net/ipv6/Kconfig linux-2.6.1.ipv6-subtree/net/ipv6/Kconfig
--- linux-2.6.1.tmp/net/ipv6/Kconfig	2004-01-09 07:59:34.000000000 +0100
+++ linux-2.6.1.ipv6-subtree/net/ipv6/Kconfig	2004-01-30 11:52:08.000000000 +0100
@@ -19,6 +19,10 @@ config IPV6_PRIVACY
 
 	  See <file:Documentation/networking/ip-sysctl.txt> for details.
 
+config IPV6_NDISC_NEW
+	bool
+	default y
+
 config INET6_AH
 	tristate "IPv6: AH transformation"
 	depends on IPV6
diff -X excl -purNa linux-2.6.1.tmp/net/ipv6/ndisc.c linux-2.6.1.ipv6-subtree/net/ipv6/ndisc.c
--- linux-2.6.1.tmp/net/ipv6/ndisc.c	2004-01-29 16:15:41.000000000 +0100
+++ linux-2.6.1.ipv6-subtree/net/ipv6/ndisc.c	2004-01-30 12:39:52.000000000 +0100
@@ -347,6 +347,7 @@ static void pndisc_destructor(struct pne
 
 
 
+#if 0
 static int
 ndisc_build_ll_hdr(struct sk_buff *skb, struct net_device *dev,
 		   struct in6_addr *daddr, struct neighbour *neigh, int len)
@@ -354,6 +355,12 @@ ndisc_build_ll_hdr(struct sk_buff *skb, 
 	unsigned char ha[MAX_ADDR_LEN];
 	unsigned char *h_dest = NULL;
 
+	if (!dev) {
+		printk(KERN_DEBUG "%s:device=%p, neigh=%p\n",
+			__FUNCTION__, dev, neigh);
+		BUG();
+	}
+
 	if (dev->hard_header) {
 		if (ipv6_addr_type(daddr) & IPV6_ADDR_MULTICAST) {
 			ndisc_mc_map(daddr, ha, dev, 1);
@@ -384,12 +391,14 @@ ndisc_build_ll_hdr(struct sk_buff *skb, 
 
 	return 1;
 }
+#endif
 
 
 /*
  *	Send a Neighbour Advertisement
  */
 
+#if 0
 static int ndisc_output(struct sk_buff *skb)
 {
 	if (skb) {
@@ -403,6 +412,7 @@ static int ndisc_output(struct sk_buff *
 	}
 	return -EINVAL;
 }
+#endif
 
 static inline void ndisc_flow_init(struct flowi *fl, u8 type,
 			    struct in6_addr *saddr, struct in6_addr *daddr)
@@ -415,6 +425,21 @@ static inline void ndisc_flow_init(struc
 	fl->fl_icmp_code	= 0;
 }
 
+static void inline ndisc_update(struct neighbour *neigh,
+				u8 *lladdr, u32 flags)
+{
+	int notify;
+	write_lock_bh(&neigh->lock);
+	notify = __neigh_update(neigh, lladdr, NUD_STALE, flags);
+#ifdef CONFIG_ARPD
+	if (notify > 0 && neigh->parms->app_probes) {
+		write_unlock_bh(&neigh->lock);
+		neigh_app_notify(neigh);
+	} else
+#endif
+	write_unlock_bh(&neigh->lock);
+}
+
 static void ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
 		   struct in6_addr *daddr, struct in6_addr *solicited_addr,
 	 	   int router, int solicited, int override, int inc_opt) 
@@ -446,7 +471,7 @@ static void ndisc_send_na(struct net_dev
 
 	ndisc_flow_init(&fl, NDISC_NEIGHBOUR_ADVERTISEMENT, src_addr, daddr);
 
-	dst = ndisc_dst_alloc(dev, neigh, ndisc_output);
+	dst = ndisc_dst_alloc(dev, neigh, daddr, ip6_output2);
 	if (!dst)
 		return;
 
@@ -463,9 +488,8 @@ static void ndisc_send_na(struct net_dev
 			inc_opt = 0;
 	}
 
-	skb = sock_alloc_send_skb(sk, MAX_HEADER + len + dev->hard_header_len + 15,
-				  1, &err);
-
+	skb = sock_alloc_send_skb(sk, MAX_HEADER + len +
+			dev->hard_header_len + dst->header_len + 64 + 15, 1, &err);
 	if (skb == NULL) {
 		ND_PRINTK1("send_na: alloc skb failed\n");
 		dst_release(dst);
@@ -533,7 +557,7 @@ void ndisc_send_ns(struct net_device *de
 
 	ndisc_flow_init(&fl, NDISC_NEIGHBOUR_SOLICITATION, saddr, daddr);
 
-	dst = ndisc_dst_alloc(dev, neigh, ndisc_output);
+	dst = ndisc_dst_alloc(dev, neigh, daddr, ip6_output2);
 	if (!dst)
 		return;
 
@@ -548,8 +572,8 @@ void ndisc_send_ns(struct net_device *de
 	if (send_llinfo)
 		len += NDISC_OPT_SPACE(dev->addr_len);
 
-	skb = sock_alloc_send_skb(sk, MAX_HEADER + len + dev->hard_header_len + 15,
-				  1, &err);
+	skb = sock_alloc_send_skb(sk, MAX_HEADER + len +
+			 dev->hard_header_len + dst->header_len + 64 + 15, 1, &err);
 	if (skb == NULL) {
 		ND_PRINTK1("send_ns: alloc skb failed\n");
 		dst_release(dst);
@@ -605,7 +629,7 @@ void ndisc_send_rs(struct net_device *de
 
 	ndisc_flow_init(&fl, NDISC_ROUTER_SOLICITATION, saddr, daddr);
 
-	dst = ndisc_dst_alloc(dev, NULL, ndisc_output);
+	dst = ndisc_dst_alloc(dev, NULL, daddr, ip6_output2);
 	if (!dst)
 		return;
 
@@ -619,8 +643,8 @@ void ndisc_send_rs(struct net_device *de
 	if (dev->addr_len)
 		len += NDISC_OPT_SPACE(dev->addr_len);
 
-        skb = sock_alloc_send_skb(sk, MAX_HEADER + len + dev->hard_header_len + 15,
-				  1, &err);
+        skb = sock_alloc_send_skb(sk, MAX_HEADER + len + 
+			dev->hard_header_len + dst->header_len + 64 + 15, 1, &err);
 	if (skb == NULL) {
 		ND_PRINTK1("send_ns: alloc skb failed\n");
 		dst_release(dst);
@@ -809,6 +833,15 @@ static void ndisc_recv_ns(struct sk_buff
 			 *	for the source address
 			 */
 
+#ifdef CONFIG_IPV6_NDISC_NEW
+			neigh = __neigh_lookup(&nd_tbl, saddr, skb->dev, !inc || lladdr || !skb->dev->addr_len);
+			if (neigh) {
+				ndisc_update(neigh, lladdr, NEIGH_UPDATE_F_IP6NS);
+				ndisc_send_na(dev, neigh, saddr, &ifp->addr,
+					      ifp->idev->cnf.forwarding, 1, inc, inc);
+				neigh_release(neigh);
+			}
+#else
 			neigh = neigh_event_ns(&nd_tbl, lladdr, saddr, dev);
 
 			if (neigh || !dev->hard_header) {
@@ -818,6 +851,7 @@ static void ndisc_recv_ns(struct sk_buff
 				if (neigh)
 					neigh_release(neigh);
 			}
+#endif
 		}
 		in6_ifa_put(ifp);
 	} else if (ipv6_chk_acast_addr(dev, &msg->target)) {
@@ -852,6 +886,16 @@ static void ndisc_recv_ns(struct sk_buff
 			 *   for the source address
 			 */
 
+#ifdef CONFIG_IPV6_NDISC_NEW
+			neigh = __neigh_lookup(&nd_tbl, saddr, skb->dev, !inc || lladdr || !skb->dev->addr_len);
+			if (neigh) {
+				ndisc_update(neigh, lladdr,
+					     NEIGH_UPDATE_F_IP6NS);
+				ndisc_send_na(dev, neigh, saddr, &msg->target,
+					      idev->cnf.forwarding, 1, 0, inc);
+				neigh_release(neigh);
+			}
+#else
 			neigh = neigh_event_ns(&nd_tbl, lladdr, saddr, skb->dev);
 
 			if (neigh || !dev->hard_header) {
@@ -861,6 +905,7 @@ static void ndisc_recv_ns(struct sk_buff
 				if (neigh)
 					neigh_release(neigh);
 			}
+#endif
 		}
 		in6_dev_put(idev);
 	} else {
@@ -882,9 +927,17 @@ static void ndisc_recv_ns(struct sk_buff
 					nd_tbl.stats.rcv_probes_ucast++;
 					
 				if (addr_type & IPV6_ADDR_UNICAST) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+					neigh = __neigh_lookup(&nd_tbl, saddr, dev,
+							       !inc || lladdr || !dev->addr_len);
+#else
 					neigh = neigh_event_ns(&nd_tbl, lladdr, saddr, dev);
-
+#endif
 					if (neigh) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+						ndisc_update(neigh, lladdr, 
+							     NEIGH_UPDATE_F_IP6NS);
+#endif
 						ndisc_send_na(dev, neigh, saddr, &msg->target,
 							      0, 1, 0, 1);
 						neigh_release(neigh);
@@ -973,6 +1026,36 @@ static void ndisc_recv_na(struct sk_buff
 	neigh = neigh_lookup(&nd_tbl, &msg->target, dev);
 
 	if (neigh) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+		int notify = 0;
+		int was_router = 0;
+
+		write_lock_bh(&neigh->lock);
+		if (!(neigh->nud_state & ~NUD_FAILED))
+			goto ignore;
+
+		was_router = neigh->flags & NTF_ROUTER;
+
+		notify = __neigh_update(neigh, lladdr,
+					msg->icmph.icmp6_solicited ? NUD_REACHABLE : NUD_STALE,
+					(NEIGH_UPDATE_F_IP6NA|
+					 (msg->icmph.icmp6_override ? NEIGH_UPDATE_F_OVERRIDE : 0) |
+					 (msg->icmph.icmp6_router   ? NEIGH_UPDATE_F_ISROUTER : 0)));
+
+		if (was_router && !(neigh->flags & NTF_ROUTER)) {
+			/*
+			 *	Change: router to host
+			 */
+			struct rt6_info *rt;
+			rt = rt6_get_dflt_router(saddr, dev);
+			if (rt) {
+				/* It is safe only because 
+				 * we're in BH */
+				dst_release(&rt->u.dst);
+				ip6_del_rt(rt, NULL, NULL);
+			}
+		}
+#else
 		if (neigh->flags & NTF_ROUTER) {
 			if (msg->icmph.icmp6_router == 0) {
 				/*
@@ -991,10 +1074,80 @@ static void ndisc_recv_na(struct sk_buff
 		neigh_update(neigh, lladdr,
 			     msg->icmph.icmp6_solicited ? NUD_REACHABLE : NUD_STALE,
 			     msg->icmph.icmp6_override, 1);
+#endif
+#ifdef CONFIG_IPV6_NDISC_NEW
+ignore:
+#ifdef CONFIG_ARPD
+		if (notify > 0 && neigh->parms->app_probes) {
+			write_unlock_bh(&neigh->lock);
+			neigh_app_notify(neigh);
+		} else
+#endif
+		write_unlock_bh(&neigh->lock);
+#endif
 		neigh_release(neigh);
 	}
 }
 
+static void ndisc_recv_rs(struct sk_buff *skb)
+{
+	struct rs_msg *rs_msg = (struct rs_msg *) skb->h.raw;
+	unsigned long ndoptlen = skb->len - sizeof(*rs_msg);
+	struct neighbour *neigh;
+	struct inet6_dev *idev;
+	struct in6_addr *saddr = &skb->nh.ipv6h->saddr;
+	struct ndisc_options ndopts;
+	u8 *lladdr = NULL;
+	int lladdrlen = 0;
+
+	if (skb->len < sizeof(*rs_msg))
+		return;
+
+	idev = in6_dev_get(skb->dev);
+	if (!idev) {
+		if (net_ratelimit())
+			ND_PRINTK1("ICMP6 RS: can't find in6 device\n");
+		return;
+	}
+
+	/* Don't accept RS if we're not in router mode */
+	if (!idev->cnf.forwarding || idev->cnf.accept_ra)
+		goto out;
+
+	/*
+	 * Don't update NCE if src = ::;
+	 * this implies that the source node has no ip address assigned yet.
+	 */
+	if (ipv6_addr_any(saddr))
+		goto out;
+
+	/* Parse ND options */
+	if (!ndisc_parse_options(rs_msg->opt, ndoptlen, &ndopts)) {
+		if (net_ratelimit())
+			ND_PRINTK2("ICMP6 NS: invalid ND option, ignored\n");
+		goto out;
+	}
+
+	if (ndopts.nd_opts_src_lladdr) {
+		lladdr = (u8 *)(ndopts.nd_opts_src_lladdr + 1);
+		lladdrlen = ndopts.nd_opts_src_lladdr->nd_opt_len << 3;
+		if (lladdrlen != NDISC_OPT_SPACE(skb->dev->addr_len))
+			goto out;
+	}
+
+	neigh = __neigh_lookup(&nd_tbl, saddr, skb->dev, 1);
+	if (neigh) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+		ndisc_update(neigh, lladdr, NEIGH_UPDATE_F_IP6RS);
+#else
+		neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
+#endif
+		neigh_release(neigh);
+	}
+out:
+	in6_dev_put(idev);
+}
+
 static void ndisc_router_discovery(struct sk_buff *skb)
 {
         struct ra_msg *ra_msg = (struct ra_msg *) skb->h.raw;
@@ -1153,7 +1306,11 @@ static void ndisc_router_discovery(struc
 				goto out;
 			}
 		}
+#ifdef CONFIG_IPV6_NDISC_NEW
+		ndisc_update(neigh, lladdr, NEIGH_UPDATE_F_IP6RA);
+#else
 		neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
+#endif
 	}
 
 	if (ndopts.nd_opts_pi) {
@@ -1282,11 +1439,18 @@ static void ndisc_redirect_rcv(struct sk
 
 	neigh = __neigh_lookup(&nd_tbl, target, skb->dev, 1);
 	if (neigh) {
-		neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
-		if (neigh->nud_state&NUD_VALID)
-			rt6_redirect(dest, &skb->nh.ipv6h->saddr, neigh, on_link);
-		else
+#ifdef CONFIG_IPV6_NDISC_NEW
+		rt6_redirect(dest, &skb->nh.ipv6h->saddr, neigh, on_link);
+#else
+		if (neigh->nud_state&NUD_VALID) {
+			if (!rt6_redirect(dest, &skb->nh.ipv6h->saddr, neigh, NULL, on_link))
+				neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
+		} else {
+			write_lock_bh(&neigh->lock);
 			__neigh_event_send(neigh, NULL);
+			write_unlock_bh(&neigh->lock);
+		}
+#endif
 		neigh_release(neigh);
 	}
 	in6_dev_put(in6_dev);
@@ -1361,8 +1525,8 @@ void ndisc_send_redirect(struct sk_buff 
 	rd_len &= ~0x7;
 	len += rd_len;
 
-	buff = sock_alloc_send_skb(sk, MAX_HEADER + len + dev->hard_header_len + 15,
-				   1, &err);
+	buff = sock_alloc_send_skb(sk, MAX_HEADER + len +
+		 	dev->hard_header_len  + dst->header_len + 64 + 15, 1, &err);
 	if (buff == NULL) {
 		ND_PRINTK1("ndisc_send_redirect: alloc_skb failed\n");
 		return;
@@ -1464,6 +1628,10 @@ int ndisc_rcv(struct sk_buff *skb)
 		ndisc_recv_na(skb);
 		break;
 
+	case NDISC_ROUTER_SOLICITATION:
+		ndisc_recv_rs(skb);
+		break;
+
 	case NDISC_ROUTER_ADVERTISEMENT:
 		ndisc_router_discovery(skb);
 		break;
diff -X excl -purNa linux-2.6.1.tmp/net/ipv6/route.c linux-2.6.1.ipv6-subtree/net/ipv6/route.c
--- linux-2.6.1.tmp/net/ipv6/route.c	2004-01-29 16:15:35.000000000 +0100
+++ linux-2.6.1.ipv6-subtree/net/ipv6/route.c	2004-01-30 12:43:11.000000000 +0100
@@ -563,6 +563,7 @@ static struct dst_entry *ndisc_dst_gc_li
 
 struct dst_entry *ndisc_dst_alloc(struct net_device *dev, 
 				  struct neighbour *neigh,
+				  struct in6_addr *addr,
 				  int (*output)(struct sk_buff *))
 {
 	struct rt6_info *rt = ip6_dst_alloc();
@@ -574,11 +575,13 @@ struct dst_entry *ndisc_dst_alloc(struct
 		dev_hold(dev);
 	if (neigh)
 		neigh_hold(neigh);
+	else
+		neigh = ndisc_get_neigh(dev, addr);
 
 	rt->rt6i_dev	  = dev;
 	rt->rt6i_nexthop  = neigh;
 	rt->rt6i_expires  = 0;
-	rt->rt6i_flags    = RTF_LOCAL | RTF_NDISC;
+	rt->rt6i_flags    = RTF_LOCAL;
 	rt->rt6i_metric   = 0;
 	atomic_set(&rt->u.dst.__refcnt, 1);
 	rt->u.dst.metrics[RTAX_HOPLIMIT-1] = 255;
@@ -832,7 +835,7 @@ int ip6_route_add(struct in6_rtmsg *rtms
 		}
 	}
 
-	rt->rt6i_flags = rtmsg->rtmsg_flags & ~RTF_NDISC;
+	rt->rt6i_flags = rtmsg->rtmsg_flags;
 
 install_route:
 	if (rta && rta[RTA_METRICS-1]) {
