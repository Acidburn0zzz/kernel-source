diff -X excl -purNa linux-2.6.3/include/net/ip6_route.h linux-2.6.3-ndisc/include/net/ip6_route.h
--- linux-2.6.3/include/net/ip6_route.h	2004-02-04 04:43:18.000000000 +0100
+++ linux-2.6.3-ndisc/include/net/ip6_route.h	2004-02-19 17:02:05.000000000 +0100
@@ -64,6 +64,7 @@ extern struct rt6_info		*rt6_lookup(stru
 
 extern struct dst_entry *ndisc_dst_alloc(struct net_device *dev,
 					 struct neighbour *neigh,
+					 struct in6_addr *addr,
 					 int (*output)(struct sk_buff *));
 extern int ndisc_dst_gc(int *more);
 extern void fib6_force_start_gc(void);
diff -X excl -purNa linux-2.6.3/include/net/ipv6.h linux-2.6.3-ndisc/include/net/ipv6.h
--- linux-2.6.3/include/net/ipv6.h	2004-02-19 17:01:32.000000000 +0100
+++ linux-2.6.3-ndisc/include/net/ipv6.h	2004-02-19 17:02:05.000000000 +0100
@@ -385,6 +385,7 @@ extern int			ip6_dst_lookup(struct sock 
  */
 
 extern int			ip6_output(struct sk_buff *skb);
+extern int			ip6_output2(struct sk_buff *skb);
 extern int			ip6_forward(struct sk_buff *skb);
 extern int			ip6_input(struct sk_buff *skb);
 extern int			ip6_mc_input(struct sk_buff *skb);
diff -X excl -purNa linux-2.6.3/include/net/ndisc.h linux-2.6.3-ndisc/include/net/ndisc.h
--- linux-2.6.3/include/net/ndisc.h	2004-02-04 04:44:17.000000000 +0100
+++ linux-2.6.3-ndisc/include/net/ndisc.h	2004-02-19 17:02:05.000000000 +0100
@@ -45,6 +45,11 @@ struct nd_msg {
 	__u8		opt[0];
 };
 
+struct rs_msg {
+	struct icmp6hdr	icmph;
+	__u8		opt[0];
+};
+
 struct ra_msg {
         struct icmp6hdr		icmph;
 	__u32			reachable_time;
diff -X excl -purNa linux-2.6.3/include/net/neighbour.h linux-2.6.3-ndisc/include/net/neighbour.h
--- linux-2.6.3/include/net/neighbour.h	2004-02-04 04:44:55.000000000 +0100
+++ linux-2.6.3-ndisc/include/net/neighbour.h	2004-02-19 17:02:05.000000000 +0100
@@ -46,10 +46,16 @@
 #include <asm/atomic.h>
 #include <linux/skbuff.h>
 
+#include <linux/config.h>
+
 #include <linux/err.h>
 #include <linux/sysctl.h>
 
+#ifdef CONFIG_IPV6_NDISC_NEW
+#define NUD_IN_TIMER	(NUD_INCOMPLETE|NUD_REACHABLE|NUD_DELAY|NUD_PROBE)
+#else
 #define NUD_IN_TIMER	(NUD_INCOMPLETE|NUD_DELAY|NUD_PROBE)
+#endif
 #define NUD_VALID	(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE|NUD_PROBE|NUD_STALE|NUD_DELAY)
 #define NUD_CONNECTED	(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE)
 
@@ -171,6 +177,51 @@ struct neigh_table
 	struct pneigh_entry	*phash_buckets[PNEIGH_HASHMASK+1];
 };
 
+static __inline__ char * neigh_state(int state)
+{
+	switch (state) {
+	case NUD_NONE:		return "NONE";
+	case NUD_INCOMPLETE:	return "INCOMPLETE";
+	case NUD_REACHABLE:	return "REACHABLE";
+	case NUD_STALE:		return "STALE";
+	case NUD_DELAY:		return "DELAY";
+	case NUD_PROBE:		return "PROBE";
+	case NUD_FAILED:	return "FAILED";
+	case NUD_NOARP:		return "NOARP";
+	case NUD_PERMANENT:	return "PERMANENT";
+	default:		return "???";
+	}
+}
+
+/* flags for __neigh_update() */
+#define NEIGH_UPDATE_F_ADMIN			0x00000001
+#define NEIGH_UPDATE_F_ISROUTER			0x00000002
+#define NEIGH_UPDATE_F_OVERRIDE			0x00000004
+#define NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER	0x00000008
+#define NEIGH_UPDATE_F_REUSEADDR		0x00000010
+#define NEIGH_UPDATE_F_REUSESUSPECTSTATE	0x00000020
+#define NEIGH_UPDATE_F_SETUP_ISROUTER		0x00000040
+#define NEIGH_UPDATE_F_SUSPECT_CONNECTED	0x00000080
+
+#define NEIGH_UPDATE_F_IP6NS		(NEIGH_UPDATE_F_SETUP_ISROUTER|\
+					 NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_OVERRIDE)
+#define NEIGH_UPDATE_F_IP6NA		(NEIGH_UPDATE_F_SETUP_ISROUTER|\
+					 NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_SUSPECT_CONNECTED|\
+					 NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER)
+#define NEIGH_UPDATE_F_IP6RS		(NEIGH_UPDATE_F_SETUP_ISROUTER|\
+					 NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_OVERRIDE|\
+					 NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER)
+#define NEIGH_UPDATE_F_IP6RA		(NEIGH_UPDATE_F_SETUP_ISROUTER|\
+					 NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_OVERRIDE|\
+					 NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER|\
+					 NEIGH_UPDATE_F_ISROUTER)
+#define NEIGH_UPDATE_F_IP6REDIRECT	(NEIGH_UPDATE_F_REUSESUSPECTSTATE|\
+					 NEIGH_UPDATE_F_OVERRIDE)
+
 extern void			neigh_table_init(struct neigh_table *tbl);
 extern int			neigh_table_clear(struct neigh_table *tbl);
 extern struct neighbour *	neigh_lookup(struct neigh_table *tbl,
@@ -181,6 +232,7 @@ extern struct neighbour *	neigh_create(s
 					     struct net_device *dev);
 extern void			neigh_destroy(struct neighbour *neigh);
 extern int			__neigh_event_send(struct neighbour *neigh, struct sk_buff *skb);
+extern int			__neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, u32 flags);
 extern int			neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, int override, int arp);
 extern void			neigh_changeaddr(struct neigh_table *tbl, struct net_device *dev);
 extern int			neigh_ifdown(struct neigh_table *tbl, struct net_device *dev);
@@ -206,6 +258,7 @@ extern int neigh_dump_info(struct sk_buf
 extern int neigh_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg);
 extern int neigh_delete(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg);
 extern void neigh_app_ns(struct neighbour *n);
+extern void neigh_app_notify(struct neighbour *n);
 
 extern int			neigh_sysctl_register(struct net_device *dev, 
 						      struct neigh_parms *p,
@@ -220,18 +273,35 @@ extern void			neigh_sysctl_unregister(st
 
 static inline void neigh_release(struct neighbour *neigh)
 {
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+	printk(KERN_DEBUG "%s(neigh=%p): refcnt=%d\n",
+		__FUNCTION__, neigh, atomic_read(&neigh->refcnt)-1);
+#endif
 	if (atomic_dec_and_test(&neigh->refcnt))
 		neigh_destroy(neigh);
 }
 
 static inline struct neighbour * neigh_clone(struct neighbour *neigh)
 {
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+	printk(KERN_DEBUG "%s(neigh=%p): refcnt=%d\n",
+		__FUNCTION__, neigh, neigh ? atomic_read(&neigh->refcnt)+1 : 0);
+#endif
 	if (neigh)
 		atomic_inc(&neigh->refcnt);
 	return neigh;
 }
 
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+#define neigh_hold(n)	({	\
+	struct neighbour *_n = (n);		\
+	printk(KERN_DEBUG "%s(neigh=%p): refcnt=%d\n", \
+		__FUNCTION__, _n, atomic_read(&_n->refcnt)+1);	\
+	atomic_inc(&_n->refcnt);	\
+})
+#else
 #define neigh_hold(n)	atomic_inc(&(n)->refcnt)
+#endif
 
 static inline void neigh_confirm(struct neighbour *neigh)
 {
@@ -251,10 +321,24 @@ static inline int neigh_is_valid(struct 
 
 static inline int neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)
 {
+	int ret = 0;
+
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+	printk(KERN_DEBUG
+		"%s(neigh=%p, skb=%p): %s, refcnt=%d\n",
+		__FUNCTION__, neigh, skb, neigh_state(neigh->nud_state), atomic_read(&neigh->refcnt));
+#endif
+	write_lock_bh(&neigh->lock);
 	neigh->used = jiffies;
 	if (!(neigh->nud_state&(NUD_CONNECTED|NUD_DELAY|NUD_PROBE)))
-		return __neigh_event_send(neigh, skb);
-	return 0;
+		ret = __neigh_event_send(neigh, skb);
+	write_unlock_bh(&neigh->lock);
+	if (ret < 0) {
+		if (skb)
+			kfree_skb(skb);
+		ret = 1;
+	}
+	return ret;
 }
 
 static inline struct neighbour *
@@ -281,6 +365,23 @@ __neigh_lookup_errno(struct neigh_table 
 	return neigh_create(tbl, pkey, dev);
 }
 
+static inline struct pneigh_entry *pneigh_clone(struct pneigh_entry *pneigh)
+{
+	return pneigh;
+}
+
+static inline void pneigh_refcnt_init(struct pneigh_entry *pneigh) {}
+
+static inline int pneigh_refcnt_dec_and_test(struct pneigh_entry *pneigh)
+{
+	return 1;
+}
+
+static inline int pneigh_alloc_flag(void)
+{
+	return GFP_KERNEL;
+}
+
 #endif
 #endif
 
diff -X excl -purNa linux-2.6.3/net/core/neighbour.c linux-2.6.3-ndisc/net/core/neighbour.c
--- linux-2.6.3/net/core/neighbour.c	2004-02-04 04:43:07.000000000 +0100
+++ linux-2.6.3-ndisc/net/core/neighbour.c	2004-02-19 17:02:05.000000000 +0100
@@ -30,13 +30,18 @@
 #include <net/sock.h>
 #include <linux/rtnetlink.h>
 
+#ifdef CONFIG_IPV6_NDISC_DEBUG
+#define NEIGH_DEBUG 3
+#else
 #define NEIGH_DEBUG 1
+#endif
 
 #define NEIGH_PRINTK(x...) printk(x)
 #define NEIGH_NOPRINTK(x...) do { ; } while(0)
 #define NEIGH_PRINTK0 NEIGH_PRINTK
 #define NEIGH_PRINTK1 NEIGH_NOPRINTK
 #define NEIGH_PRINTK2 NEIGH_NOPRINTK
+#define NEIGH_PRINTK3 NEIGH_NOPRINTK
 
 #if NEIGH_DEBUG >= 1
 #undef NEIGH_PRINTK1
@@ -46,11 +51,12 @@
 #undef NEIGH_PRINTK2
 #define NEIGH_PRINTK2 NEIGH_PRINTK
 #endif
+#if NEIGH_DEBUG >= 3
+#undef NEIGH_PRINTK3
+#define NEIGH_PRINTK3 NEIGH_PRINTK
+#endif
 
 static void neigh_timer_handler(unsigned long arg);
-#ifdef CONFIG_ARPD
-static void neigh_app_notify(struct neighbour *n);
-#endif
 static int pneigh_ifdown(struct neigh_table *tbl, struct net_device *dev);
 void neigh_changeaddr(struct neigh_table *tbl, struct net_device *dev);
 
@@ -389,10 +395,11 @@ struct pneigh_entry * pneigh_lookup(stru
 	if (!creat)
 		goto out;
 
-	n = kmalloc(sizeof(*n) + key_len, GFP_KERNEL);
+	n = kmalloc(sizeof(*n) + key_len, pneigh_alloc_flag());
 	if (!n)
 		goto out;
 
+	pneigh_refcnt_init(n);
 	memcpy(n->key, pkey, key_len);
 	n->dev = dev;
 
@@ -426,6 +433,9 @@ int pneigh_delete(struct neigh_table *tb
 	for (np = &tbl->phash_buckets[hash_val]; (n = *np) != NULL;
 	     np = &n->next) {
 		if (!memcmp(n->key, pkey, key_len) && n->dev == dev) {
+			if (!pneigh_refcnt_dec_and_test(n)) {
+				return 0;
+			}
 			write_lock_bh(&tbl->lock);
 			*np = n->next;
 			write_unlock_bh(&tbl->lock);
@@ -536,6 +546,7 @@ static void neigh_connect(struct neighbo
 		hh->hh_output = neigh->ops->hh_output;
 }
 
+#ifndef CONFIG_IPV6_NDISC_NEW
 /*
    Transitions NUD_STALE <-> NUD_REACHABLE do not occur
    when fast path is built: we have no timers associated with
@@ -569,6 +580,7 @@ static void neigh_sync(struct neighbour 
 		}
 	}
 }
+#endif
 
 static void neigh_periodic_timer(unsigned long arg)
 {
@@ -619,11 +631,13 @@ static void neigh_periodic_timer(unsigne
 				continue;
 			}
 
+#ifndef CONFIG_IPV6_NDISC_NEW
 			if (n->nud_state & NUD_REACHABLE &&
 			    now - n->confirmed > n->parms->reachable_time) {
 				n->nud_state = NUD_STALE;
 				neigh_suspect(n);
 			}
+#endif
 			write_unlock(&n->lock);
 
 next_elt:
@@ -648,40 +662,94 @@ static __inline__ int neigh_max_probes(s
 
 static void neigh_timer_handler(unsigned long arg)
 {
-	unsigned long now = jiffies;
+	unsigned long now, next;
 	struct neighbour *neigh = (struct neighbour *)arg;
 	unsigned state;
-	int notify = 0;
 
-	write_lock(&neigh->lock);
+	int refcnt;
 
+	write_lock_bh(&neigh->lock);
+	now = jiffies;
+	next = now + HZ;
+	
 	state = neigh->nud_state;
 
 	if (!(state & NUD_IN_TIMER)) {
 #ifndef CONFIG_SMP
 		printk(KERN_WARNING "neigh: timer & !nud_in_timer\n");
 #endif
-		goto out;
+		write_unlock_bh(&neigh->lock);
+		refcnt = atomic_read(&neigh->refcnt) - 1;
+		neigh_release(neigh);
+		NEIGH_PRINTK3(KERN_DEBUG 
+				"%s(): => state=%s, refcnt=%d\n",
+				__FUNCTION__, neigh_state(state), refcnt);
+		return;
 	}
 
+#ifdef CONFIG_IPV6_NDISC_NEW
+	if (state & NUD_REACHABLE) {
+		if (now - neigh->confirmed < neigh->parms->reachable_time) {
+			next = neigh->confirmed + neigh->parms->reachable_time;
+		} else if (now - neigh->used <= neigh->parms->delay_probe_time) {
+			neigh->nud_state = NUD_DELAY;
+			neigh_suspect(neigh);
+			next = now + neigh->parms->delay_probe_time;
+		} else {
+			neigh->nud_state = NUD_STALE;
+			neigh_suspect(neigh);
+		}
+	} else if (state & NUD_DELAY) {
+		if (now - neigh->confirmed <= neigh->parms->delay_probe_time) {
+			neigh->nud_state = NUD_REACHABLE;
+			neigh_connect(neigh);
+			next = neigh->confirmed + neigh->parms->reachable_time;
+		} else {
+			neigh->nud_state = NUD_PROBE;
+			atomic_set(&neigh->probes, 0);
+			next = now + neigh->parms->retrans_time;
+		}
+	} else {
+		/* PROBE,INCOMPLETE */
+		next = now + neigh->parms->retrans_time;
+	}
+#else
 	if ((state & NUD_VALID) &&
 	    now - neigh->confirmed < neigh->parms->reachable_time) {
-		neigh->nud_state = NUD_REACHABLE;
+		state = neigh->nud_state = NUD_REACHABLE;
 		NEIGH_PRINTK2("neigh %p is still alive.\n", neigh);
 		neigh_connect(neigh);
-		goto out;
+		refcnt = atomic_read(&neigh->refcnt) - 1;
+		write_unlock_bh(&neigh->lock);
+		neigh_release(neigh);
+		NEIGH_PRINTK3(KERN_DEBUG 
+				"%s(): => state=%s, refcnt=%d\n",
+				__FUNCTION__, 
+				neigh_state(state), refcnt);
+		return;
 	}
 	if (state == NUD_DELAY) {
 		NEIGH_PRINTK2("neigh %p is probed.\n", neigh);
 		neigh->nud_state = NUD_PROBE;
 		atomic_set(&neigh->probes, 0);
 	}
+#endif
 
-	if (atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {
+	if (
+#ifdef CONFIG_IPV6_NDISC_NEW
+	    (neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE)) &&
+#endif
+	    atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {
 		struct sk_buff *skb;
 
-		neigh->nud_state = NUD_FAILED;
-		notify = 1;
+#ifdef CONFIG_IPV6_NDISC_NEW
+		neigh->updated = now;
+#endif
+		state = neigh->nud_state = NUD_FAILED;
+
+#ifdef CONFIG_IPV6_NDISC_NEW
+		del_timer(&neigh->timer);	/* release neigh later */
+#endif
 		neigh->tbl->stats.res_failed++;
 		NEIGH_PRINTK2("neigh %p is failed.\n", neigh);
 
@@ -692,62 +760,113 @@ static void neigh_timer_handler(unsigned
 		 */
 		while (neigh->nud_state == NUD_FAILED &&
 		       (skb = __skb_dequeue(&neigh->arp_queue)) != NULL) {
-			write_unlock(&neigh->lock);
+			write_unlock_bh(&neigh->lock);
 			neigh->ops->error_report(neigh, skb);
-			write_lock(&neigh->lock);
+			write_lock_bh(&neigh->lock);
 		}
 		skb_queue_purge(&neigh->arp_queue);
-		goto out;
+#ifdef CONFIG_ARPD
+		if (neigh->parms->app_probes) {
+			write_unlock_bh(&neigh->lock);
+			neigh_app_notify(neigh);
+		} else
+#endif
+		refcnt = atomic_read(&neigh->refcnt) - 1;
+		write_unlock_bh(&neigh->lock);
+
+		neigh_release(neigh);
+
+		NEIGH_PRINTK3(KERN_DEBUG 
+				"%s(): => state=%s, refcnt=%d\n",
+				__FUNCTION__, 
+				neigh_state(state), refcnt);
+
+		return;
 	}
 
+#ifdef CONFIG_IPV6_NDISC_NEW
+	if (neigh->nud_state & NUD_IN_TIMER) {
+		neigh_hold(neigh);
+		if (time_before(next, jiffies + HZ/2))
+			next = jiffies + HZ/2;
+		mod_timer(&neigh->timer, next);
+		if (neigh->nud_state&(NUD_INCOMPLETE|NUD_PROBE)) {
+			write_unlock_bh(&neigh->lock);
+			neigh->ops->solicit(neigh, skb_peek(&neigh->arp_queue));
+			atomic_inc(&neigh->probes);
+		} else {
+			write_unlock_bh(&neigh->lock);
+		}
+	} else {
+		del_timer(&neigh->timer);
+		write_unlock_bh(&neigh->lock);
+	}
+	refcnt = atomic_read(&neigh->refcnt) - 1;
+	state = neigh->nud_state;
+	neigh_release(neigh);
+#else
 	neigh->timer.expires = now + neigh->parms->retrans_time;
 	add_timer(&neigh->timer);
-	write_unlock(&neigh->lock);
+
+	refcnt = atomic_read(&neigh->refcnt);
+	state = neigh->nud_state;
+	write_unlock_bh(&neigh->lock);
 
 	neigh->ops->solicit(neigh, skb_peek(&neigh->arp_queue));
 	atomic_inc(&neigh->probes);
-	return;
-
-out:
-	write_unlock(&neigh->lock);
-#ifdef CONFIG_ARPD
-	if (notify && neigh->parms->app_probes)
-		neigh_app_notify(neigh);
 #endif
-	neigh_release(neigh);
+	NEIGH_PRINTK3(KERN_DEBUG 
+			"%s(): => state=%s, refcnt=%d\n",
+			__FUNCTION__, 
+			neigh_state(state), refcnt);
+
+	return;
 }
 
 int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)
 {
-	int rc;
-
-	write_lock_bh(&neigh->lock);
+	int rc = 0;
+	unsigned long now = jiffies;
+	
+	NEIGH_PRINTK3(KERN_DEBUG 
+			"%s(neigh=%p, skb=%p): %s\n",
+			__FUNCTION__, 
+			neigh, skb, neigh_state(neigh->nud_state));
 
-	rc = 0;
 	if (neigh->nud_state & (NUD_CONNECTED | NUD_DELAY | NUD_PROBE))
-		goto out_unlock_bh;
+		goto out;
 
 	if (!(neigh->nud_state & (NUD_STALE | NUD_INCOMPLETE))) {
 		if (neigh->parms->mcast_probes + neigh->parms->app_probes) {
 			atomic_set(&neigh->probes, neigh->parms->ucast_probes);
 			neigh->nud_state     = NUD_INCOMPLETE;
 			neigh_hold(neigh);
-			neigh->timer.expires = jiffies +
+#ifdef CONFIG_IPV6_NDISC_NEW
+			neigh->timer.expires = now;
+#else
+			neigh->timer.expires = now +
 					       neigh->parms->retrans_time;
+#endif
 			add_timer(&neigh->timer);
+#ifndef CONFIG_IPV6_NDISC_NEW
 			write_unlock_bh(&neigh->lock);
 			neigh->ops->solicit(neigh, skb);
 			atomic_inc(&neigh->probes);
 			write_lock_bh(&neigh->lock);
+#endif
 		} else {
 			neigh->nud_state = NUD_FAILED;
-			write_unlock_bh(&neigh->lock);
-
-			if (skb)
-				kfree_skb(skb);
-			return 1;
+			return -1;
 		}
 	}
+#ifdef CONFIG_IPV6_NDISC_NEW
+	else if (neigh->nud_state == NUD_STALE) {
+		neigh_hold(neigh);
+		neigh->nud_state = NUD_DELAY;
+		neigh->timer.expires = now + neigh->parms->delay_probe_time;
+		add_timer(&neigh->timer);
+	}
+#endif
 
 	if (neigh->nud_state == NUD_INCOMPLETE) {
 		if (skb) {
@@ -761,16 +880,18 @@ int __neigh_event_send(struct neighbour 
 			__skb_queue_tail(&neigh->arp_queue, skb);
 		}
 		rc = 1;
-	} else if (neigh->nud_state == NUD_STALE) {
+	}
+#ifndef CONFIG_IPV6_NDISC_NEW
+	else if (neigh->nud_state == NUD_STALE) {
 		NEIGH_PRINTK2("neigh %p is delayed.\n", neigh);
 		neigh_hold(neigh);
 		neigh->nud_state = NUD_DELAY;
-		neigh->timer.expires = jiffies + neigh->parms->delay_probe_time;
+		neigh->timer.expires = now + neigh->parms->delay_probe_time;
 		add_timer(&neigh->timer);
 		rc = 0;
 	}
-out_unlock_bh:
-	write_unlock_bh(&neigh->lock);
+#endif
+out:
 	return rc;
 }
 
@@ -794,32 +915,57 @@ static __inline__ void neigh_update_hhs(
 /* Generic update routine.
    -- lladdr is new lladdr or NULL, if it is not supplied.
    -- new    is new state.
-   -- override == 1 allows to override existing lladdr, if it is different.
-   -- arp == 0 means that the change is administrative.
+   -- flags  specifies details of update
 
    Caller MUST hold reference count on the entry.
+   __neigh_update() is called under write_lock_bh().
+
  */
 
-int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,
-		 int override, int arp)
+int __neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, u32 flags)
 {
 	u8 old;
 	int err;
-#ifdef CONFIG_ARPD
 	int notify = 0;
-#endif
 	struct net_device *dev;
+#ifdef CONFIG_IPV6_NDISC_NEW
+	unsigned long now = jiffies;
+	int hold = 0;
+	int update_isrouter = 0;
 
-	write_lock_bh(&neigh->lock);
+	NEIGH_PRINTK3(KERN_DEBUG
+			"%s(neigh=%p, lladdr=%p, new=%u, flags=%08x): %s\n",
+			__FUNCTION__,
+			neigh, lladdr, new, flags, neigh_state(neigh->nud_state));
+	
+	if (!neigh) {
+		NEIGH_PRINTK1(KERN_WARNING "__neigh_update(): neigh==NULL\n");
+		return -EINVAL;
+	}
 
+	old = neigh->nud_state;
+#endif /* CONFIG_IPV6_NDISC_NEW */
+
+#ifndef CONFIG_IPV6_NDISC_NEW
 	dev    = neigh->dev;
 	old    = neigh->nud_state;
 	err    = -EPERM;
+#else /* CONFIG_IPV6_NDISC_NEW */
+	dev = neigh->dev;
+	if (!dev) {
+		NEIGH_PRINTK1(KERN_WARNING "__neigh_update(): neigh->dev==NULL\n");
+		return -EINVAL;
+	}
+#endif /* CONFIG_IPV6_NDISC_NEW */
 
-	if (arp && (old & (NUD_NOARP | NUD_PERMANENT)))
+	err = -EPERM;
+	if (!(flags & NEIGH_UPDATE_F_ADMIN) && (old & (NUD_NOARP | NUD_PERMANENT)))
 		goto out;
 
 	if (!(new & NUD_VALID)) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+		/* NONE,INCOMPLETE,FAILED */
+#endif /* CONFIG_IPV6_NDISC_NEW */
 		neigh_del_timer(neigh);
 		if (old & NUD_CONNECTED)
 			neigh_suspect(neigh);
@@ -844,8 +990,10 @@ int neigh_update(struct neighbour *neigh
 		if (old & NUD_VALID) {
 			if (!memcmp(lladdr, neigh->ha, dev->addr_len))
 				lladdr = neigh->ha;
-			else if (!override)
+#ifndef CONFIG_IPV6_NDISC_NEW
+			else if (!(flags & NEIGH_UPDATE_F_OVERRIDE))
 				goto out;
+#endif /* not CONFIG_IPV6_NDISC_NEW */
 		}
 	} else {
 		/* No address is supplied; if we know something,
@@ -857,28 +1005,93 @@ int neigh_update(struct neighbour *neigh
 		lladdr = neigh->ha;
 	}
 
+#ifndef CONFIG_IPV6_NDISC_NEW
 	neigh_sync(neigh);
 	old = neigh->nud_state;
 	if (new & NUD_CONNECTED)
 		neigh->confirmed = jiffies;
 	neigh->updated = jiffies;
 
+#endif /* not CONFIG_IPV6_NDISC_NEW */
 	/* If entry was valid and address is not changed,
 	   do not change entry state, if new one is STALE.
 	 */
 	err = 0;
+#ifndef CONFIG_IPV6_NDISC_NEW
 	if ((old & NUD_VALID) && lladdr == neigh->ha &&
 	    (new == old || (new == NUD_STALE && (old & NUD_CONNECTED))))
 		goto out;
+#else /* CONFIG_IPV6_NDISC_NEW */
+	if (old & NUD_VALID) {
+		if (lladdr != neigh->ha &&
+		    !(flags & NEIGH_UPDATE_F_OVERRIDE)) {
+			if ((flags & NEIGH_UPDATE_F_SUSPECT_CONNECTED) &&
+			    (old & NUD_CONNECTED)) {
+				new = NUD_STALE;
+				lladdr = neigh->ha;
+			} else {
+				goto out;
+			}
+		} else {
+			if ((flags & NEIGH_UPDATE_F_REUSEADDR) &&
+			    new == old)
+				lladdr = neigh->ha;
+			else if (lladdr == neigh->ha && new == NUD_STALE) {
+				if ((flags & NEIGH_UPDATE_F_REUSESUSPECTSTATE) ||
+				    (old & NUD_CONNECTED))
+					new = old;
+			}
+			update_isrouter = flags & NEIGH_UPDATE_F_OVERRIDE_VALID_ISROUTER;
+		}
+	} else {
+		/* INCOMPLETE */
+		update_isrouter = flags&NEIGH_UPDATE_F_SETUP_ISROUTER;
+	}
+#endif /* CONFIG_IPV6_NDISC_NEW */
 
+#ifndef CONFIG_IPV6_NDISC_NEW
 	neigh_del_timer(neigh);
 	neigh->nud_state = new;
+#else /* CONFIG_IPV6_NDISC_NEW */
+	if (new != old) {
+		if (new & NUD_IN_TIMER) {
+			unsigned long next = now;
+			switch(new) {
+			case NUD_REACHABLE:
+				next += neigh->parms->reachable_time;
+				break;
+			default:;
+				/*XXX*/
+			}
+			if (old & NUD_IN_TIMER) {
+				mod_timer(&neigh->timer, next);
+			} else {
+				neigh_hold(neigh);
+				neigh->timer.expires = next;
+				add_timer(&neigh->timer);
+			}
+		} else {
+			neigh_del_timer(neigh);
+		}
+		neigh->nud_state = new;
+	}
+	if ((new != old || lladdr != neigh->ha) &&
+	    new & NUD_CONNECTED)
+		neigh->confirmed = now;
+#endif /* CONFIG_IPV6_NDISC_NEW */
 	if (lladdr != neigh->ha) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+		neigh->updated = now;
+#endif /* CONFIG_IPV6_NDISC_NEW */
 		memcpy(&neigh->ha, lladdr, dev->addr_len);
 		neigh_update_hhs(neigh);
 		if (!(new & NUD_CONNECTED))
+#ifndef CONFIG_IPV6_NDISC_NEW
 			neigh->confirmed = jiffies -
 				      (neigh->parms->base_reachable_time << 1);
+#else /* CONFIG_IPV6_NDISC_NEW */
+			neigh->confirmed = now - (neigh->parms->base_reachable_time<<1);
+#endif /* CONFIG_IPV6_NDISC_NEW */
 #ifdef CONFIG_ARPD
 		notify = 1;
 #endif
@@ -893,6 +1106,13 @@ int neigh_update(struct neighbour *neigh
 		struct sk_buff *skb;
 
 		/* Again: avoid dead loop if something went wrong */
+#ifdef CONFIG_IPV6_NDISC_NEW
+		neigh_hold(neigh);	/* don't release neigh while processing */
+		hold = 1;
+
+		if (new&NUD_VALID)
+			notify = 1;
+#endif /* CONFIG_IPV6_NDISC_NEW */
 
 		while (neigh->nud_state & NUD_VALID &&
 		       (skb = __skb_dequeue(&neigh->arp_queue)) != NULL) {
@@ -907,20 +1127,68 @@ int neigh_update(struct neighbour *neigh
 		skb_queue_purge(&neigh->arp_queue);
 	}
 out:
-	write_unlock_bh(&neigh->lock);
+#ifdef CONFIG_IPV6_NDISC_NEW
+	if (update_isrouter) {
+		neigh->flags = (flags & NEIGH_UPDATE_F_ISROUTER) ?
+				(neigh->flags | NTF_ROUTER) :
+				(neigh->flags & ~NTF_ROUTER);
+	}
+
+	if (hold)
+		neigh_release(neigh);
+#endif /* CONFIG_IPV6_NDISC_NEW */
+
+	NEIGH_PRINTK3(KERN_DEBUG
+			"%s() => %s\n",
+			__FUNCTION__,
+			neigh_state(neigh->nud_state));
+
+	return err ? err : notify;
+}
+
+int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,
+		 int override, int arp)
+{
+	int update;
+
+	NEIGH_PRINTK3(KERN_DEBUG
+			"%s(neigh=%p, lladdr=%p, new=%u, override=%d, arp=%d): %s\n",
+			__FUNCTION__, 
+			neigh, lladdr, new, override, arp,
+			neigh_state(neigh->nud_state));
+
+	neigh_hold(neigh);
+	write_lock_bh(&neigh->lock);
+	update = __neigh_update(neigh, lladdr, new, 
+#ifdef CONFIG_IPV6_NDISC_NEW
+				NEIGH_UPDATE_F_REUSEADDR |
+#endif /* CONFIG_IPV6_NDISC_NEW */
+				(override ? NEIGH_UPDATE_F_OVERRIDE : 0) |
+				(arp ? 0 : NEIGH_UPDATE_F_ADMIN));
 #ifdef CONFIG_ARPD
-	if (notify && neigh->parms->app_probes)
+	if (update > 0 && neigh->parms->app_probes) {
+		write_unlock_bh(&neigh->lock);
 		neigh_app_notify(neigh);
+	} else
 #endif
-	return err;
+	write_unlock_bh(&neigh->lock);
+	neigh_release(neigh);	/*XXX: may invalidate neigh... */
+	return update >= 0 ? 0 : update;
 }
 
 struct neighbour *neigh_event_ns(struct neigh_table *tbl,
 				 u8 *lladdr, void *saddr,
 				 struct net_device *dev)
 {
-	struct neighbour *neigh = __neigh_lookup(tbl, saddr, dev,
-						 lladdr || !dev->addr_len);
+	struct neighbour *neigh;
+
+	NEIGH_PRINTK3(KERN_DEBUG
+			"%s(tbl=%p, lladdr=%p, saddr=%p, dev=%p)\n",
+			__FUNCTION__, 
+			tbl, lladdr, saddr, dev);
+
+	neigh = __neigh_lookup(tbl, saddr, dev,
+			       lladdr || !dev->addr_len);
 	if (neigh)
 		neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
 	return neigh;
@@ -1454,7 +1722,7 @@ void neigh_app_ns(struct neighbour *n)
 	netlink_broadcast(rtnl, skb, 0, RTMGRP_NEIGH, GFP_ATOMIC);
 }
 
-static void neigh_app_notify(struct neighbour *n)
+void neigh_app_notify(struct neighbour *n)
 {
 	struct nlmsghdr *nlh;
 	int size = NLMSG_SPACE(sizeof(struct ndmsg) + 256);
@@ -1736,6 +2004,7 @@ EXPORT_SYMBOL(neigh_rand_reach_time);
 EXPORT_SYMBOL(neigh_resolve_output);
 EXPORT_SYMBOL(neigh_table_clear);
 EXPORT_SYMBOL(neigh_table_init);
+EXPORT_SYMBOL(__neigh_update);
 EXPORT_SYMBOL(neigh_update);
 EXPORT_SYMBOL(neigh_update_hhs);
 EXPORT_SYMBOL(pneigh_enqueue);
@@ -1743,6 +2012,7 @@ EXPORT_SYMBOL(pneigh_lookup);
 
 #ifdef CONFIG_ARPD
 EXPORT_SYMBOL(neigh_app_ns);
+EXPORT_SYMBOL(neigh_app_notify);
 #endif
 #ifdef CONFIG_SYSCTL
 EXPORT_SYMBOL(neigh_sysctl_register);
diff -X excl -purNa linux-2.6.3/net/ipv6/Kconfig linux-2.6.3-ndisc/net/ipv6/Kconfig
--- linux-2.6.3/net/ipv6/Kconfig	2004-02-04 04:43:48.000000000 +0100
+++ linux-2.6.3-ndisc/net/ipv6/Kconfig	2004-02-19 17:02:05.000000000 +0100
@@ -19,6 +19,10 @@ config IPV6_PRIVACY
 
 	  See <file:Documentation/networking/ip-sysctl.txt> for details.
 
+config IPV6_NDISC_NEW
+	bool
+	default y
+
 config INET6_AH
 	tristate "IPv6: AH transformation"
 	depends on IPV6
diff -X excl -purNa linux-2.6.3/net/ipv6/ndisc.c linux-2.6.3-ndisc/net/ipv6/ndisc.c
--- linux-2.6.3/net/ipv6/ndisc.c	2004-02-19 17:01:32.000000000 +0100
+++ linux-2.6.3-ndisc/net/ipv6/ndisc.c	2004-02-19 17:08:18.000000000 +0100
@@ -341,65 +341,10 @@ static void pndisc_destructor(struct pne
 	ipv6_dev_mc_dec(dev, &maddr);
 }
 
-
-
-static int
-ndisc_build_ll_hdr(struct sk_buff *skb, struct net_device *dev,
-		   struct in6_addr *daddr, struct neighbour *neigh, int len)
-{
-	unsigned char ha[MAX_ADDR_LEN];
-	unsigned char *h_dest = NULL;
-
-	if (dev->hard_header) {
-		if (ipv6_addr_is_multicast(daddr)) {
-			ndisc_mc_map(daddr, ha, dev, 1);
-			h_dest = ha;
-		} else if (neigh) {
-			read_lock_bh(&neigh->lock);
-			if (neigh->nud_state&NUD_VALID) {
-				memcpy(ha, neigh->ha, dev->addr_len);
-				h_dest = ha;
-			}
-			read_unlock_bh(&neigh->lock);
-		} else {
-			neigh = neigh_lookup(&nd_tbl, daddr, dev);
-			if (neigh) {
-				read_lock_bh(&neigh->lock);
-				if (neigh->nud_state&NUD_VALID) {
-					memcpy(ha, neigh->ha, dev->addr_len);
-					h_dest = ha;
-				}
-				read_unlock_bh(&neigh->lock);
-				neigh_release(neigh);
-			}
-		}
-
-		if (dev->hard_header(skb, dev, ETH_P_IPV6, h_dest, NULL, len) < 0)
-			return 0;
-	}
-
-	return 1;
-}
-
-
 /*
  *	Send a Neighbour Advertisement
  */
 
-static int ndisc_output(struct sk_buff *skb)
-{
-	if (skb) {
-		struct neighbour *neigh = (skb->dst ? skb->dst->neighbour : NULL);
-		if (ndisc_build_ll_hdr(skb, skb->dev, &skb->nh.ipv6h->daddr, neigh, skb->len) == 0) {
-			kfree_skb(skb);
-			return -EINVAL;
-		}
-		dev_queue_xmit(skb);
-		return 0;
-	}
-	return -EINVAL;
-}
-
 static inline void ndisc_flow_init(struct flowi *fl, u8 type,
 			    struct in6_addr *saddr, struct in6_addr *daddr)
 {
@@ -411,6 +356,21 @@ static inline void ndisc_flow_init(struc
 	fl->fl_icmp_code	= 0;
 }
 
+static void inline ndisc_update(struct neighbour *neigh,
+				u8 *lladdr, u32 flags)
+{
+	int notify;
+	write_lock_bh(&neigh->lock);
+	notify = __neigh_update(neigh, lladdr, NUD_STALE, flags);
+#ifdef CONFIG_ARPD
+	if (notify > 0 && neigh->parms->app_probes) {
+		write_unlock_bh(&neigh->lock);
+		neigh_app_notify(neigh);
+	} else
+#endif
+	write_unlock_bh(&neigh->lock);
+}
+
 static void ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
 		   struct in6_addr *daddr, struct in6_addr *solicited_addr,
 	 	   int router, int solicited, int override, int inc_opt) 
@@ -442,7 +402,7 @@ static void ndisc_send_na(struct net_dev
 
 	ndisc_flow_init(&fl, NDISC_NEIGHBOUR_ADVERTISEMENT, src_addr, daddr);
 
-	dst = ndisc_dst_alloc(dev, neigh, ndisc_output);
+	dst = ndisc_dst_alloc(dev, neigh, daddr, ip6_output2);
 	if (!dst)
 		return;
 
@@ -459,7 +419,7 @@ static void ndisc_send_na(struct net_dev
 			inc_opt = 0;
 	}
 
-	skb = sock_alloc_send_skb(sk, MAX_HEADER + len + LL_RESERVED_SPACE(dev),
+	skb = sock_alloc_send_skb(sk, MAX_HEADER + len + LL_RESERVED_SPACE(dev) + dst->header_len + 64, 
 				  1, &err);
 
 	if (skb == NULL) {
@@ -530,7 +490,7 @@ void ndisc_send_ns(struct net_device *de
 
 	ndisc_flow_init(&fl, NDISC_NEIGHBOUR_SOLICITATION, saddr, daddr);
 
-	dst = ndisc_dst_alloc(dev, neigh, ndisc_output);
+	dst = ndisc_dst_alloc(dev, neigh, daddr, ip6_output2);
 	if (!dst)
 		return;
 
@@ -545,7 +505,7 @@ void ndisc_send_ns(struct net_device *de
 	if (send_llinfo)
 		len += NDISC_OPT_SPACE(dev->addr_len);
 
-	skb = sock_alloc_send_skb(sk, MAX_HEADER + len + LL_RESERVED_SPACE(dev),
+	skb = sock_alloc_send_skb(sk, MAX_HEADER + len + LL_RESERVED_SPACE(dev) + dst->header_len + 64,
 				  1, &err);
 	if (skb == NULL) {
 		ND_PRINTK1("send_ns: alloc skb failed\n");
@@ -603,7 +563,7 @@ void ndisc_send_rs(struct net_device *de
 
 	ndisc_flow_init(&fl, NDISC_ROUTER_SOLICITATION, saddr, daddr);
 
-	dst = ndisc_dst_alloc(dev, NULL, ndisc_output);
+	dst = ndisc_dst_alloc(dev, NULL, daddr, ip6_output2);
 	if (!dst)
 		return;
 
@@ -617,7 +577,7 @@ void ndisc_send_rs(struct net_device *de
 	if (dev->addr_len)
 		len += NDISC_OPT_SPACE(dev->addr_len);
 
-        skb = sock_alloc_send_skb(sk, MAX_HEADER + len + LL_RESERVED_SPACE(dev),
+        skb = sock_alloc_send_skb(sk, MAX_HEADER + len + LL_RESERVED_SPACE(dev) + dst->header_len + 64,
 				  1, &err);
 	if (skb == NULL) {
 		ND_PRINTK1("send_ns: alloc skb failed\n");
@@ -747,7 +707,7 @@ static void ndisc_recv_ns(struct sk_buff
 			return;
 		}
 
-		/* XXX: RFC2461 7.1.1:
+		/* RFC2461 7.1.1:
 	 	 *	If the IP source address is the unspecified address, 
 		 *	there MUST NOT be source link-layer address option 
 		 *	in the message.
@@ -806,7 +766,6 @@ static void ndisc_recv_ns(struct sk_buff
 				 * sender should delay its response 
 				 * by a random time between 0 and 
 				 * MAX_ANYCAST_DELAY_TIME seconds.
-				 * (RFC2461) -- yoshfuji
 				 */
 				struct sk_buff *n = skb_clone(skb, GFP_ATOMIC);
 				if (n)
@@ -821,8 +780,13 @@ static void ndisc_recv_ns(struct sk_buff
 		struct in6_addr maddr;
 
 		ipv6_addr_all_nodes(&maddr);
+#ifdef CONFIG_IPV6_NDISC_NEW
+		ndisc_send_na(dev, NULL, &maddr, &msg->target,
+			      idev->cnf.forwarding, 0, ifp && inc, inc);
+#else
 		ndisc_send_na(dev, NULL, &maddr, &msg->target,
-			      idev->cnf.forwarding, 0, (ifp != NULL), 1);
+			      idev->cnf.forwarding, 0, ifp != NULL, inc);
+#endif
 		goto out;
 	}
 
@@ -835,15 +799,24 @@ static void ndisc_recv_ns(struct sk_buff
 	 *	update / create cache entry
 	 *	for the source address
 	 */
+#ifdef CONFIG_IPV6_NDISC_NEW
+	neigh = __neigh_lookup(&nd_tbl, saddr, skb->dev, !inc || lladdr || !skb->dev->addr_len);
+	if (neigh) {
+		ndisc_update(neigh, lladdr, NEIGH_UPDATE_F_IP6NS);
+		ndisc_send_na(dev, neigh, saddr, &msg->target,
+			      idev->cnf.forwarding, 1, (ifp && inc) , inc);
+		neigh_release(neigh);
+	}
+#else
 	neigh = neigh_event_ns(&nd_tbl, lladdr, saddr, dev);
 
 	if (neigh || !dev->hard_header) {
 		ndisc_send_na(dev, neigh, saddr, &msg->target,
-			      idev->cnf.forwarding, 
-			      1, (ifp != NULL && inc), inc);
+			      idev->cnf.forwarding, 1, ifp != NULL, 1);
 		if (neigh)
 			neigh_release(neigh);
 	}
+#endif
 
 out:
 	if (ifp)
@@ -917,6 +890,32 @@ static void ndisc_recv_na(struct sk_buff
 	neigh = neigh_lookup(&nd_tbl, &msg->target, dev);
 
 	if (neigh) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+		int notify = 0;
+		int was_router = 0;
+
+		write_lock_bh(&neigh->lock);
+		if (!(neigh->nud_state & ~NUD_FAILED))
+			goto ignore;
+
+		was_router = neigh->flags & NTF_ROUTER;
+
+		notify = __neigh_update(neigh, lladdr,
+					msg->icmph.icmp6_solicited ? NUD_REACHABLE : NUD_STALE,
+					(NEIGH_UPDATE_F_IP6NA|
+					 (msg->icmph.icmp6_override ? NEIGH_UPDATE_F_OVERRIDE : 0) |
+					 (msg->icmph.icmp6_router   ? NEIGH_UPDATE_F_ISROUTER : 0)));
+
+		if (was_router && !(neigh->flags & NTF_ROUTER)) {
+			/*
+			 *	Change: router to host
+			 */
+			struct rt6_info *rt;
+			rt = rt6_get_dflt_router(saddr, dev);
+			if (rt)
+				ip6_del_rt(rt, NULL, NULL);
+		}
+#else
 		if (neigh->flags & NTF_ROUTER) {
 			if (msg->icmph.icmp6_router == 0) {
 				/*
@@ -935,10 +934,80 @@ static void ndisc_recv_na(struct sk_buff
 		neigh_update(neigh, lladdr,
 			     msg->icmph.icmp6_solicited ? NUD_REACHABLE : NUD_STALE,
 			     msg->icmph.icmp6_override, 1);
+#endif
+#ifdef CONFIG_IPV6_NDISC_NEW
+ignore:
+#ifdef CONFIG_ARPD
+		if (notify > 0 && neigh->parms->app_probes) {
+			write_unlock_bh(&neigh->lock);
+			neigh_app_notify(neigh);
+		} else
+#endif
+			write_unlock_bh(&neigh->lock);
+#endif
 		neigh_release(neigh);
 	}
 }
 
+static void ndisc_recv_rs(struct sk_buff *skb)
+{
+	struct rs_msg *rs_msg = (struct rs_msg *) skb->h.raw;
+	unsigned long ndoptlen = skb->len - sizeof(*rs_msg);
+	struct neighbour *neigh;
+	struct inet6_dev *idev;
+	struct in6_addr *saddr = &skb->nh.ipv6h->saddr;
+	struct ndisc_options ndopts;
+	u8 *lladdr = NULL;
+	int lladdrlen = 0;
+
+	if (skb->len < sizeof(*rs_msg))
+		return;
+
+	idev = in6_dev_get(skb->dev);
+	if (!idev) {
+		if (net_ratelimit())
+			ND_PRINTK1("ICMP6 RS: can't find in6 device\n");
+		return;
+	}
+
+	/* Don't accept RS if we're not in router mode */
+	if (!idev->cnf.forwarding || idev->cnf.accept_ra)
+		goto out;
+
+	/*
+	 * Don't update NCE if src = ::;
+	 * this implies that the source node has no ip address assigned yet.
+	 */
+	if (ipv6_addr_any(saddr))
+		goto out;
+
+	/* Parse ND options */
+	if (!ndisc_parse_options(rs_msg->opt, ndoptlen, &ndopts)) {
+		if (net_ratelimit())
+			ND_PRINTK2("ICMP6 NS: invalid ND option, ignored\n");
+		goto out;
+	}
+
+	if (ndopts.nd_opts_src_lladdr) {
+		lladdr = (u8 *)(ndopts.nd_opts_src_lladdr + 1);
+		lladdrlen = ndopts.nd_opts_src_lladdr->nd_opt_len << 3;
+		if (lladdrlen != NDISC_OPT_SPACE(skb->dev->addr_len))
+			goto out;
+	}
+
+	neigh = __neigh_lookup(&nd_tbl, saddr, skb->dev, 1);
+	if (neigh) {
+#ifdef CONFIG_IPV6_NDISC_NEW
+		ndisc_update(neigh, lladdr, NEIGH_UPDATE_F_IP6RS);
+#else
+		neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
+#endif
+		neigh_release(neigh);
+	}
+out:
+	in6_dev_put(idev);
+}
+
 static void ndisc_router_discovery(struct sk_buff *skb)
 {
         struct ra_msg *ra_msg = (struct ra_msg *) skb->h.raw;
@@ -1097,7 +1166,11 @@ static void ndisc_router_discovery(struc
 				goto out;
 			}
 		}
+#ifdef CONFIG_IPV6_NDISC_NEW
+		ndisc_update(neigh, lladdr, NEIGH_UPDATE_F_IP6RA);
+#else
 		neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
+#endif
 	}
 
 	if (ndopts.nd_opts_pi) {
@@ -1226,11 +1299,18 @@ static void ndisc_redirect_rcv(struct sk
 
 	neigh = __neigh_lookup(&nd_tbl, target, skb->dev, 1);
 	if (neigh) {
-		neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
-		if (neigh->nud_state&NUD_VALID)
-			rt6_redirect(dest, &skb->nh.ipv6h->saddr, neigh, on_link);
-		else
+#ifdef CONFIG_IPV6_NDISC_NEW
+		rt6_redirect(dest, &skb->nh.ipv6h->saddr, neigh, on_link);
+#else
+		if (neigh->nud_state&NUD_VALID) {
+			if (!rt6_redirect(dest, &skb->nh.ipv6h->saddr, neigh, NULL, on_link))
+				neigh_update(neigh, lladdr, NUD_STALE, 1, 1);
+		} else {
+			write_lock_bh(&neigh->lock);
 			__neigh_event_send(neigh, NULL);
+			write_unlock_bh(&neigh->lock);
+		}
+#endif
 		neigh_release(neigh);
 	}
 	in6_dev_put(in6_dev);
@@ -1305,7 +1385,7 @@ void ndisc_send_redirect(struct sk_buff 
 	rd_len &= ~0x7;
 	len += rd_len;
 
-	buff = sock_alloc_send_skb(sk, MAX_HEADER + len + LL_RESERVED_SPACE(dev),
+	buff = sock_alloc_send_skb(sk, MAX_HEADER + len + LL_RESERVED_SPACE(dev) + dst->header_len + 64,
 				   1, &err);
 	if (buff == NULL) {
 		ND_PRINTK1("ndisc_send_redirect: alloc_skb failed\n");
@@ -1410,6 +1490,10 @@ int ndisc_rcv(struct sk_buff *skb)
 		ndisc_recv_na(skb);
 		break;
 
+	case NDISC_ROUTER_SOLICITATION:
+		ndisc_recv_rs(skb);
+		break;
+
 	case NDISC_ROUTER_ADVERTISEMENT:
 		ndisc_router_discovery(skb);
 		break;
diff -X excl -purNa linux-2.6.3/net/ipv6/route.c linux-2.6.3-ndisc/net/ipv6/route.c
--- linux-2.6.3/net/ipv6/route.c	2004-02-04 04:44:14.000000000 +0100
+++ linux-2.6.3-ndisc/net/ipv6/route.c	2004-02-19 17:02:05.000000000 +0100
@@ -563,6 +563,7 @@ static struct dst_entry *ndisc_dst_gc_li
 
 struct dst_entry *ndisc_dst_alloc(struct net_device *dev, 
 				  struct neighbour *neigh,
+				  struct in6_addr *addr,
 				  int (*output)(struct sk_buff *))
 {
 	struct rt6_info *rt = ip6_dst_alloc();
@@ -574,11 +575,13 @@ struct dst_entry *ndisc_dst_alloc(struct
 		dev_hold(dev);
 	if (neigh)
 		neigh_hold(neigh);
+	else
+		neigh = ndisc_get_neigh(dev, addr);
 
 	rt->rt6i_dev	  = dev;
 	rt->rt6i_nexthop  = neigh;
 	rt->rt6i_expires  = 0;
-	rt->rt6i_flags    = RTF_LOCAL | RTF_NDISC;
+	rt->rt6i_flags    = RTF_LOCAL;
 	rt->rt6i_metric   = 0;
 	atomic_set(&rt->u.dst.__refcnt, 1);
 	rt->u.dst.metrics[RTAX_HOPLIMIT-1] = 255;
@@ -832,7 +835,7 @@ int ip6_route_add(struct in6_rtmsg *rtms
 		}
 	}
 
-	rt->rt6i_flags = rtmsg->rtmsg_flags & ~RTF_NDISC;
+	rt->rt6i_flags = rtmsg->rtmsg_flags;
 
 install_route:
 	if (rta && rta[RTA_METRICS-1]) {
