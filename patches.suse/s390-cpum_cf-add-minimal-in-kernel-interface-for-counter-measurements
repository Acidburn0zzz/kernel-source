From: Hendrik Brueckner <brueckner@linux.ibm.com>
Date: Wed, 8 Aug 2018 10:38:43 +0200
Subject: s390/cpum_cf: Add minimal in-kernel interface for counter measurements
Git-commit: 17bebcc68eeea3e1189f712dcba39809ad0d7a86
Patch-mainline: v5.1-rc1
References: jsc#SLE-6904 FATE#327581

Introduce a minimal interface for doing counter measurements of small
units of work within the kernel.  Use the kernel_cpumcf_begin() function
start a measurement session and, later, stop it with kernel_cpumcf_end().

During the measreument session, you can enable and start/stop counter sets
by using ctr_set_* functions.  To make these changes effective use the
lcctl() function.  You can then use the ecctr() function to extract counters
from the different counter sets.
Please note that you have to check whether the counter sets to be enabled
are authorized.

Note that when a measurement session is active, other users cannot perform
counter measurements.  In such cases, kernel_cpumcf_begin() indicates this
with returning -EBUSY.  If the counter facility is not available,
kernel_cpumcf_begin() returns -ENODEV.

Note that this interface is restricted to the current CPU and, thus,
preemption must be turned off.

Example:

	u32 state, err;
	u64 cycles, insn;

	err = kernel_cpumcf_begin();
	if (err)
		goto out_busy;

	state = 0;
	ctr_set_enable(&state, CPUMF_CTR_SET_BASIC);
	ctr_set_start(&state, CPUMF_CTR_SET_BASIC);

	err = lcctl(state);
	if (err)
		goto ;

	/* ... do your work ... */

	ctr_set_stop(&state, CPUMF_CTR_SET_BASIC);
	err = lcctl(state);
	if (err)
		goto out;

	cycles = insn = 0;
	ecctr(0, &cycles);
	ecctr(1, &insn);

	/* ... */

	kernel_cpumcf_end();
out_busy:

Signed-off-by: Hendrik Brueckner <brueckner@linux.ibm.com>
Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 arch/s390/include/asm/cpu_mcf.h |   14 ++++++++++++++
 1 file changed, 14 insertions(+)

--- a/arch/s390/include/asm/cpu_mcf.h
+++ b/arch/s390/include/asm/cpu_mcf.h
@@ -63,4 +63,18 @@ int __kernel_cpumcf_begin(void);
 unsigned long kernel_cpumcf_alert(int clear);
 void __kernel_cpumcf_end(void);
 
+static inline int kernel_cpumcf_begin(void)
+{
+	if (!cpum_cf_avail())
+		return -ENODEV;
+
+	preempt_disable();
+	return __kernel_cpumcf_begin();
+}
+static inline void kernel_cpumcf_end(void)
+{
+	__kernel_cpumcf_end();
+	preempt_enable();
+}
+
 #endif /* _ASM_S390_CPU_MCF_H */
