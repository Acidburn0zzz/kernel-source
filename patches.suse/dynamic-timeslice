garloff@suse.de

Feature.

Forward port from a 2.4 patch from andrea@suse.de.
This patch allows the user to tune the minimum and maximum timeslices
for normal (SCHED_OTHER) processes.
These can be set via /proc/sys/kernel/min_timeslice and max_timeslice.
Also the HZ (timer tick frequency) value of the kernel is exported.
The timeslices can be tuned to tune for interactive or batch processing
workloads. The boot parameter "desktop" sets shorter timeslices than
the default ones.

diff -U 8 -Nrp linux-2.6.5/include/linux/sched.h linux-2.6.5.dyn-timeslice/include/linux/sched.h
--- linux-2.6.5/include/linux/sched.h	2004-04-04 23:41:48.000000000 +0200
+++ linux-2.6.5.dyn-timeslice/include/linux/sched.h	2004-04-04 23:43:45.000000000 +0200
@@ -171,16 +171,17 @@ extern void update_one_process(struct ta
 			       unsigned long system, int cpu);
 extern void scheduler_tick(int user_tick, int system);
 extern unsigned long cache_decay_ticks;
 
 
 #define	MAX_SCHEDULE_TIMEOUT	LONG_MAX
 extern signed long FASTCALL(schedule_timeout(signed long timeout));
 asmlinkage void schedule(void);
+extern int max_timeslice, min_timeslice;
 
 struct namespace;
 
 /* Maximum number of active map areas.. This is a random (large) number */
 #define DEFAULT_MAX_MAP_COUNT	65536
 
 extern int sysctl_max_map_count;
 
diff -U 8 -Nrp linux-2.6.5/include/linux/sysctl.h linux-2.6.5.dyn-timeslice/include/linux/sysctl.h
--- linux-2.6.5/include/linux/sysctl.h	2004-04-04 23:41:48.000000000 +0200
+++ linux-2.6.5.dyn-timeslice/include/linux/sysctl.h	2004-04-04 23:42:38.000000000 +0200
@@ -129,16 +129,19 @@ enum
 	KERN_HPPA_UNALIGNED=59,	/* int: hppa unaligned-trap enable */
 	KERN_PRINTK_RATELIMIT=60, /* int: tune printk ratelimiting */
 	KERN_PRINTK_RATELIMIT_BURST=61,	/* int: tune printk ratelimiting */
 	KERN_PTY=62,		/* dir: pty driver */
 	KERN_NGROUPS_MAX=63,	/* int: NGROUPS_MAX */
 	KERN_KDB=64,		/* int: kdb on/off */
 	KERN_S390_HZ_TIMER=65,  /* int: hz timer on or off */
 	KERN_DUMP=66,		/* directory: dump parameters */
+	KERN_MAXTIMESLICE=67,	/* int: nice -20 max timeslice */
+	KERN_MINTIMESLICE=68,	/* int: nice +19 min timeslice */
+	KERN_HZ=69,		/* unsigned long: interal kernel HZ */
 };
 
 
 /* CTL_VM names: */
 enum
 {
 	VM_UNUSED1=1,		/* was: struct: Set vm swapping control */
 	VM_UNUSED2=2,		/* was; int: Linear or sqrt() swapout for hogs */
diff -U 8 -Nrp linux-2.6.5/kernel/sched.c linux-2.6.5.dyn-timeslice/kernel/sched.c
--- linux-2.6.5/kernel/sched.c	2004-04-04 23:41:48.000000000 +0200
+++ linux-2.6.5.dyn-timeslice/kernel/sched.c	2004-04-04 23:42:38.000000000 +0200
@@ -75,22 +75,29 @@ EXPORT_SYMBOL(dump_oncpu);
  * Some helpers for converting nanosecond timing to jiffy resolution
  */
 #define NS_TO_JIFFIES(TIME)	((TIME) / (1000000000 / HZ))
 #define JIFFIES_TO_NS(TIME)	((TIME) * (1000000000 / HZ))
 
 /*
  * These are the 'tuning knobs' of the scheduler:
  *
- * Minimum timeslice is 10 msecs, default timeslice is 100 msecs,
- * maximum timeslice is 200 msecs. Timeslices get refilled after
- * they expire.
- */
-#define MIN_TIMESLICE		( 10 * HZ / 1000)
-#define MAX_TIMESLICE		(200 * HZ / 1000)
+ * Minimum timeslice is 10 msecs, default timeslice is 150 msecs,
+ * maximum timeslice is 300 msecs. Timeslices get refilled after
+ * they expire. 
+ */
+#define __MIN_TIMESLICE		  10000
+#define __MAX_TIMESLICE		 300000
+#define __MIN_TIMESLICE_DESKTOP	   2000
+#define __MAX_TIMESLICE_DESKTOP	  60000
+/* the sysctl values are exported in usec units to userspace */
+int max_timeslice = __MAX_TIMESLICE, min_timeslice = __MIN_TIMESLICE;
+#define MAX_TIMESLICE ((max_timeslice * HZ + 999999) / 1000000)
+#define MIN_TIMESLICE ((min_timeslice * HZ + 999999) / 1000000)
+
 #define ON_RUNQUEUE_WEIGHT	 30
 #define CHILD_PENALTY		 95
 #define PARENT_PENALTY		100
 #define EXIT_WEIGHT		  3
 #define PRIO_BONUS_RATIO	 25
 #define MAX_BONUS		(MAX_USER_PRIO * PRIO_BONUS_RATIO / 100)
 #define INTERACTIVE_DELTA	  2
 #define MAX_SLEEP_AVG		(AVG_TIMESLICE * MAX_BONUS)
@@ -3036,8 +3043,18 @@ EXPORT_SYMBOL(__preempt_write_lock);
 #endif /* defined(CONFIG_SMP) && defined(CONFIG_PREEMPT) */
 
 #ifdef	CONFIG_KDB
 task_t *kdb_cpu_curr(int cpu)
 {
 	return(cpu_curr(cpu));
 }
 #endif
+
+static int __init init_desktop(char *str)
+{
+	min_timeslice = __MIN_TIMESLICE_DESKTOP;
+	max_timeslice = __MAX_TIMESLICE_DESKTOP;
+	return 1;
+}
+__setup("desktop", init_desktop);
+
+
diff -U 8 -Nrp linux-2.6.5/kernel/sysctl.c linux-2.6.5.dyn-timeslice/kernel/sysctl.c
--- linux-2.6.5/kernel/sysctl.c	2004-04-04 23:41:48.000000000 +0200
+++ linux-2.6.5.dyn-timeslice/kernel/sysctl.c	2004-04-04 23:42:38.000000000 +0200
@@ -165,16 +165,17 @@ struct file_operations proc_sys_file_ope
 };
 
 extern struct proc_dir_entry *proc_sys_root;
 
 static void register_proc_table(ctl_table *, struct proc_dir_entry *);
 static void unregister_proc_table(ctl_table *, struct proc_dir_entry *);
 #endif
 
+static unsigned int __HZ = HZ;
 /* The default sysctl tables: */
 
 static ctl_table root_table[] = {
 	{
 		.ctl_name	= CTL_KERN,
 		.procname	= "kernel",
 		.mode		= 0555,
 		.child		= kern_table,
@@ -643,16 +644,40 @@ static ctl_table kern_table[] = {
 		.data		= &ngroups_max,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec_minmax,
 		.strategy	= &sysctl_intvec,
 		.extra1		= &min_ngroups,
 		.extra2		= &max_ngroups,
 	},
+	{
+		.ctl_name	= KERN_MAXTIMESLICE, 
+		.procname	= "max-timeslice",
+		.data		=  &max_timeslice,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= KERN_MINTIMESLICE, 
+		.procname	= "min-timeslice",
+		.data		= &min_timeslice,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= KERN_HZ, 
+		.procname	= "HZ",
+		.data		= &__HZ,
+		.maxlen		= sizeof(int),
+		.mode		= 0444,
+		.proc_handler	= &proc_dointvec,
+	},
 	{ .ctl_name = 0 }
 };
 
 /* Constants for minimum and maximum testing in vm_table.
    We use these as one-element integer vectors. */
 static int zero;
 static int one_hundred = 100;
 
