garloff@suse.de

Feature.

Forward port from a 2.4 patch from andrea@suse.de.
This patch allows the user to tune the minimum and maximum timeslices
for normal (SCHED_OTHER) processes.
These can be set via /proc/sys/kernel/min_timeslice and max_timeslice.
Also the HZ (timer tick frequency) value of the kernel is exported.
The timeslices can be tuned to tune for interactive or batch processing
workloads. The boot parameter "desktop" sets shorter timeslices than
the default ones.

Index: linux-2.6.8/include/linux/sched.h
===================================================================
--- linux-2.6.8.orig/include/linux/sched.h
+++ linux-2.6.8/include/linux/sched.h
@@ -174,16 +174,17 @@ extern unsigned long cache_decay_ticks;
 /* Attach to any functions which should be ignored in wchan output. */
 #define __sched		__attribute__((__section__(".sched.text")))
 /* Is this address in the __sched functions? */
 extern int in_sched_functions(unsigned long addr);
 
 #define	MAX_SCHEDULE_TIMEOUT	LONG_MAX
 extern signed long FASTCALL(schedule_timeout(signed long timeout));
 asmlinkage void schedule(void);
+extern int def_timeslice, min_timeslice;
 
 struct namespace;
 
 /* Maximum number of active map areas.. This is a random (large) number */
 #define DEFAULT_MAX_MAP_COUNT	65536
 
 extern int sysctl_max_map_count;
 
Index: linux-2.6.8/include/linux/sysctl.h
===================================================================
--- linux-2.6.8.orig/include/linux/sysctl.h
+++ linux-2.6.8/include/linux/sysctl.h
@@ -130,16 +130,19 @@ enum
 	KERN_PRINTK_RATELIMIT=60, /* int: tune printk ratelimiting */
 	KERN_PRINTK_RATELIMIT_BURST=61,	/* int: tune printk ratelimiting */
 	KERN_PTY=62,		/* dir: pty driver */
 	KERN_NGROUPS_MAX=63,	/* int: NGROUPS_MAX */
 	KERN_SPARC_SCONS_PWROFF=64, /* int: serial console power-off halt */
 	KERN_HZ_TIMER=65,	/* int: hz timer on or off */
 	KERN_UNKNOWN_NMI_PANIC=66, /* int: unknown nmi panic flag */
 	KERN_KDB=67,		/* int: kdb on/off */
+	KERN_DEFTIMESLICE=68,	/* int: nice   0 def timeslice */
+	KERN_MINTIMESLICE=69,	/* int: nice +19 min timeslice */
+	KERN_HZ=70,		/* unsigned long: internal kernel HZ */
 };
 
 
 /* CTL_VM names: */
 enum
 {
 	VM_UNUSED1=1,		/* was: struct: Set vm swapping control */
 	VM_UNUSED2=2,		/* was; int: Linear or sqrt() swapout for hogs */
Index: linux-2.6.8/kernel/sched.c
===================================================================
--- linux-2.6.8.orig/kernel/sched.c
+++ linux-2.6.8/kernel/sched.c
@@ -76,21 +76,34 @@
  */
 #define NS_TO_JIFFIES(TIME)	((TIME) / (1000000000 / HZ))
 #define JIFFIES_TO_NS(TIME)	((TIME) * (1000000000 / HZ))
 
 /*
  * These are the 'tuning knobs' of the scheduler:
  *
  * Minimum timeslice is 5 msecs (or 1 jiffy, whichever is larger),
- * default timeslice is 100 msecs, maximum timeslice is 800 msecs.
+ * default timeslice is 150 msecs, maximum timeslice is 800 msecs.
  * Timeslices get refilled after they expire.
  */
-#define MIN_TIMESLICE		max(5 * HZ / 1000, 1)
-#define DEF_TIMESLICE		(100 * HZ / 1000)
+#if HZ >= 200
+#define __MIN_TIMESLICE		(5 * HZ / 1000)
+#else
+#define __MIN_TIMESLICE		1
+#endif
+#define __DEF_TIMESLICE		(150 * HZ / 1000)
+#if HZ >= 500
+#define __MIN_TIMESLICE_DESKTOP	(2 * HZ / 1000)
+#else
+#define __MIN_TIMESLICE_DESKTOP	1
+#endif
+#define __DEF_TIMESLICE_DESKTOP	(60 * HZ / 1000)
+int def_timeslice = __DEF_TIMESLICE, min_timeslice = __MIN_TIMESLICE;
+#define MIN_TIMESLICE ((min_timeslice * HZ + 999999) / 1000000)
+#define DEF_TIMESLICE ((def_timeslice * HZ + 999999) / 1000000)
 #define ON_RUNQUEUE_WEIGHT	 30
 #define CHILD_PENALTY		 95
 #define PARENT_PENALTY		100
 #define EXIT_WEIGHT		  3
 #define PRIO_BONUS_RATIO	 25
 #define MAX_BONUS		(MAX_USER_PRIO * PRIO_BONUS_RATIO / 100)
 #define INTERACTIVE_DELTA	  2
 #define MAX_SLEEP_AVG		(DEF_TIMESLICE * MAX_BONUS)
@@ -417,16 +430,23 @@ struct sched_domain {
 	.last_balance		= jiffies,		\
 	.balance_interval	= 1,			\
 	.nr_balance_failed	= 0,			\
 }
 #endif
 #endif /* ARCH_HAS_SCHED_TUNE */
 #endif
 
+static int __init init_desktop(char *str)
+{
+	min_timeslice = __MIN_TIMESLICE_DESKTOP;
+	def_timeslice = __DEF_TIMESLICE_DESKTOP;
+	return 1;
+}
+__setup("desktop", init_desktop);
 
 #define for_each_domain(cpu, domain) \
 	for (domain = cpu_rq(cpu)->sd; domain; domain = domain->parent)
 
 #define cpu_rq(cpu)		(&per_cpu(runqueues, (cpu)))
 #define this_rq()		(&__get_cpu_var(runqueues))
 #define task_rq(p)		cpu_rq(task_cpu(p))
 #define cpu_curr(cpu)		(cpu_rq(cpu)->curr)
Index: linux-2.6.8/kernel/sysctl.c
===================================================================
--- linux-2.6.8.orig/kernel/sysctl.c
+++ linux-2.6.8/kernel/sysctl.c
@@ -171,16 +171,17 @@ struct file_operations proc_sys_file_ope
 };
 
 extern struct proc_dir_entry *proc_sys_root;
 
 static void register_proc_table(ctl_table *, struct proc_dir_entry *);
 static void unregister_proc_table(ctl_table *, struct proc_dir_entry *);
 #endif
 
+static unsigned int __HZ = HZ;
 /* The default sysctl tables: */
 
 static ctl_table root_table[] = {
 	{
 		.ctl_name	= CTL_KERN,
 		.procname	= "kernel",
 		.mode		= 0555,
 		.child		= kern_table,
@@ -635,16 +636,40 @@ static ctl_table kern_table[] = {
 		.ctl_name       = KERN_UNKNOWN_NMI_PANIC,
 		.procname       = "unknown_nmi_panic",
 		.data           = &unknown_nmi_panic,
 		.maxlen         = sizeof (int),
 		.mode           = 0644,
 		.proc_handler   = &proc_unknown_nmi_panic,
 	},
 #endif
+	{
+		.ctl_name	= KERN_DEFTIMESLICE, 
+		.procname	= "def-timeslice",
+		.data		=  &def_timeslice,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= KERN_MINTIMESLICE, 
+		.procname	= "min-timeslice",
+		.data		= &min_timeslice,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= KERN_HZ, 
+		.procname	= "HZ",
+		.data		= &__HZ,
+		.maxlen		= sizeof(int),
+		.mode		= 0444,
+		.proc_handler	= &proc_dointvec,
+	},
 	{ .ctl_name = 0 }
 };
 
 /* Constants for minimum and maximum testing in vm_table.
    We use these as one-element integer vectors. */
 static int zero;
 static int one_hundred = 100;
 
