From: Jeff Mahoney <jeffm@suse.com>
Subject: ocfs2: Change o2hb_resource_{get,put} API to return a resource, and free one without lookup

 The current o2hb_resource_get API takes a UUID and returns success
 or failure depending on whether it got a reference. The *put API
 takes a UUID and has to look up the resource before freeing it. This
 works fine when that's the only interest, but the per-resource event
 patch demands that the callback know about the resource. I used to do
 this as part of the setup, which required that the caller know which
 resource it was using. It was a bit cumbersome.

 The new get/put API, already doing the lookup, made it easy to push
 that into the registration instead. Since we need to keep it, _get now
 returns a resource. That's cached in the callback structure until
 it's unregistered. With the caches resource, there's no point in looking
 it up, so we just _put it directly.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

---
 fs/ocfs2/cluster/heartbeat.c |   35 ++++++++++++++++++-----------------
 fs/ocfs2/cluster/heartbeat.h |    4 ++--
 fs/ocfs2/cluster/quorum.c    |    4 ++--
 fs/ocfs2/cluster/tcp.c       |    4 ++--
 fs/ocfs2/dlm/dlmdomain.c     |    4 ++--
 5 files changed, 26 insertions(+), 25 deletions(-)

--- a/fs/ocfs2/cluster/heartbeat.c
+++ b/fs/ocfs2/cluster/heartbeat.c
@@ -271,6 +271,7 @@ void o2hb_setup_callback(struct o2hb_cal
 	hc->hc_priority = priority;
 	hc->hc_type = type;
 	hc->hc_magic = O2HB_CB_MAGIC;
+	hc->hc_res = NULL;
 }
 EXPORT_SYMBOL_GPL(o2hb_setup_callback);
 
@@ -290,7 +291,8 @@ static struct o2hb_heartbeat_resource *o
 	return reg;
 }
 
-static int o2hb_resource_get(const char *region_uuid)
+static struct o2hb_heartbeat_resource *
+o2hb_resource_get(const char *region_uuid)
 {
 	int ret = 0;
 	struct o2hb_heartbeat_resource *reg;
@@ -314,19 +316,13 @@ static int o2hb_resource_get(const char 
 		o2nm_undepend_this_node();
 
 out:
-	return ret;
+	if (ret)
+		return ERR_PTR(ret);
+	return reg;
 }
 
-static void o2hb_resource_put(const char *region_uuid)
+static void o2hb_resource_put(struct o2hb_heartbeat_resource *reg)
 {
-	struct o2hb_heartbeat_resource *reg;
-
-	spin_lock(&o2hb_live_lock);
-
-	reg = o2hb_find_resource(region_uuid);
-
-	spin_unlock(&o2hb_live_lock);
-
 	if (reg) {
 		o2nm_undepend_item(&reg->hr_item);
 		o2nm_undepend_this_node();
@@ -368,6 +364,7 @@ EXPORT_SYMBOL_GPL(o2hb_for_each_resource
 int o2hb_register_callback(const char *region_uuid,
 			   struct o2hb_callback_func *hc)
 {
+	struct o2hb_heartbeat_resource *res = NULL;
 	struct o2hb_callback_func *tmp;
 	struct list_head *iter;
 	struct o2hb_callback *hbcall;
@@ -383,9 +380,12 @@ int o2hb_register_callback(const char *r
 	}
 
 	if (region_uuid) {
-		ret = o2hb_resource_get(region_uuid);
-		if (ret)
+		res = o2hb_resource_get(region_uuid);
+		if (IS_ERR(res)) {
+			ret = PTR_ERR(res);
 			goto out;
+		}
+		hc->hc_res = res;
 	}
 
 	down_write(&o2hb_callback_sem);
@@ -409,8 +409,7 @@ out:
 }
 EXPORT_SYMBOL_GPL(o2hb_register_callback);
 
-void o2hb_unregister_callback(const char *region_uuid,
-			      struct o2hb_callback_func *hc)
+void o2hb_unregister_callback(struct o2hb_callback_func *hc)
 {
 	BUG_ON(hc->hc_magic != O2HB_CB_MAGIC);
 
@@ -421,8 +420,10 @@ void o2hb_unregister_callback(const char
 	if (list_empty(&hc->hc_item))
 		return;
 
-	if (region_uuid)
-		o2hb_resource_put(region_uuid);
+	if (hc->hc_res) {
+		o2hb_resource_put(hc->hc_res);
+		hc->hc_res = NULL;
+	}
 
 	down_write(&o2hb_callback_sem);
 
--- a/fs/ocfs2/cluster/heartbeat.h
+++ b/fs/ocfs2/cluster/heartbeat.h
@@ -85,6 +85,7 @@ struct o2hb_callback_func {
 	void			*hc_data;
 	int			hc_priority;
 	enum o2hb_callback_type hc_type;
+	struct o2hb_heartbeat_resource *hc_res;
 };
 
 struct o2hb_node_event {
@@ -111,8 +112,7 @@ void o2hb_setup_callback(struct o2hb_cal
 			 int priority);
 int o2hb_register_callback(const char *region_uuid,
 			   struct o2hb_callback_func *hc);
-void o2hb_unregister_callback(const char *region_uuid,
-			      struct o2hb_callback_func *hc);
+void o2hb_unregister_callback(struct o2hb_callback_func *hc);
 void o2hb_fill_node_map(unsigned long *map,
 			unsigned bytes);
 void o2hb_init(void);
--- a/fs/ocfs2/cluster/quorum.c
+++ b/fs/ocfs2/cluster/quorum.c
@@ -348,8 +348,8 @@ static struct notifier_block o2quo_net_n
 
 static void o2quo_unregister_hb_callbacks(void)
 {
-	o2hb_unregister_callback(NULL, &o2quo_hb_up_cb);
-	o2hb_unregister_callback(NULL, &o2quo_hb_down_cb);
+	o2hb_unregister_callback(&o2quo_hb_up_cb);
+	o2hb_unregister_callback(&o2quo_hb_down_cb);
 }
 
 static int o2quo_register_hb_callbacks(void)
--- a/fs/ocfs2/cluster/tcp.c
+++ b/fs/ocfs2/cluster/tcp.c
@@ -1619,8 +1619,8 @@ static void o2net_hb_node_up_cb(struct o
 
 void o2net_unregister_hb_callbacks(void)
 {
-	o2hb_unregister_callback(NULL, &o2net_hb_up);
-	o2hb_unregister_callback(NULL, &o2net_hb_down);
+	o2hb_unregister_callback(&o2net_hb_up);
+	o2hb_unregister_callback(&o2net_hb_down);
 }
 
 int o2net_register_hb_callbacks(void)
--- a/fs/ocfs2/dlm/dlmdomain.c
+++ b/fs/ocfs2/dlm/dlmdomain.c
@@ -1253,8 +1253,8 @@ bail:
 
 static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm)
 {
-	o2hb_unregister_callback(NULL, &dlm->dlm_hb_up);
-	o2hb_unregister_callback(NULL, &dlm->dlm_hb_down);
+	o2hb_unregister_callback(&dlm->dlm_hb_up);
+	o2hb_unregister_callback(&dlm->dlm_hb_down);
 	o2net_unregister_handler_list(&dlm->dlm_domain_handlers);
 }
 
