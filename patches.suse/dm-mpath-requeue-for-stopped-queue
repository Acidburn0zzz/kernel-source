From: Hannes Reinecke <hare@suse.de>
Subject: Handle I/O on stopped queues correctly
References: bnc#458393

The current multipath infrastructure has several issues when I/O is
submitted during a table reload.
The make_request_fn must not fail if no table is present, as I/O
will be queued properly in the request queue. But on the other hand
we should not submit queued I/Os if the queue of the underlying
device is stopped; that queue is undergoing reconfiguration
time and may be in all sort of states.

And while we're at it, we should detach any hardware handler
if the multipath table doesn't specify one.

Signed-off-by: Hannes Reinecke <hare@suse.de>

Index: linux-2.6.27/drivers/md/dm-mpath.c
===================================================================
--- linux-2.6.27.orig/drivers/md/dm-mpath.c
+++ linux-2.6.27/drivers/md/dm-mpath.c
@@ -159,9 +159,7 @@ static struct priority_group *alloc_prio
 
 static void free_pgpaths(struct list_head *pgpaths, struct dm_target *ti)
 {
-	unsigned long flags;
 	struct pgpath *pgpath, *tmp;
-	struct multipath *m = ti->private;
 
 	list_for_each_entry_safe(pgpath, tmp, pgpaths, list) {
 		list_del(&pgpath->list);
@@ -436,8 +434,8 @@ static void process_queued_ios(struct wo
 {
 	struct multipath *m =
 		container_of(work, struct multipath, process_queued_ios);
-       struct pgpath *pgpath = NULL, *tmp;
-       unsigned must_queue = 1;
+	struct pgpath *pgpath = NULL, *tmp;
+	unsigned must_queue = 1;
 	unsigned long flags;
 
 	spin_lock_irqsave(&m->lock, flags);
@@ -450,6 +448,12 @@ static void process_queued_ios(struct wo
 
 	pgpath = m->current_pgpath;
 
+	if (pgpath) {
+		struct block_device *bdev = pgpath->path.dev->bdev;
+		if (unlikely(blk_queue_stopped(bdev_get_queue(bdev))))
+			goto out;
+	}
+
 	if ((pgpath && !m->queue_io) ||
 	    (!pgpath && !m->queue_if_no_path))
 		must_queue = 0;
@@ -619,22 +623,27 @@ static struct pgpath *parse_path(struct
 		memcpy(p->path.pdev, p->path.dev->name, 16);
 	}
 
-	if (m->hw_handler_name && p->path.dev) {
+	if (p->path.dev) {
 		struct request_queue *q = bdev_get_queue(p->path.dev->bdev);
 
-		r = scsi_dh_attach(q, m->hw_handler_name);
-		if (r == -EBUSY) {
-			/*
-			 * Already attached to different hw_handler,
-			 * try to reattach with correct one.
-			 */
-			scsi_dh_detach(q);
+		if (m->hw_handler_name) {
 			r = scsi_dh_attach(q, m->hw_handler_name);
-		}
-		if (r < 0) {
-			ti->error = "error attaching hardware handler";
-			dm_put_device(ti, p->path.dev);
-			goto bad;
+			if (r == -EBUSY) {
+				/*
+				 * Already attached to different hw_handler,
+				 * try to reattach with correct one.
+				 */
+				scsi_dh_detach(q);
+				r = scsi_dh_attach(q, m->hw_handler_name);
+			}
+			if (r < 0) {
+				ti->error = "error attaching hardware handler";
+				dm_put_device(ti, p->path.dev);
+				goto bad;
+			}
+		} else {
+			/* Play safe and detach hardware handler */
+			scsi_dh_detach(q);
 		}
 	}
 
@@ -644,6 +653,11 @@ static struct pgpath *parse_path(struct
 		goto bad;
 	}
 
+	if (!p->is_active) {
+		ps->type->fail_path(ps, &p->path);
+		p->fail_count++;
+		m->nr_valid_paths--;
+	}
 	return p;
 
  bad:
Index: linux-2.6.27/drivers/md/dm.c
===================================================================
--- linux-2.6.27.orig/drivers/md/dm.c
+++ linux-2.6.27/drivers/md/dm.c
@@ -1304,7 +1304,11 @@ static int dm_make_request(struct reques
 		return 0;
 	}
 
-	if (unlikely(!md->map)) {
+	/*
+	 * Submitting to a stopped queue with no map is okay;
+	 * might happen during reconfiguration.
+	 */
+	if (unlikely(!md->map) && !blk_queue_stopped(q)) {
 		bio_endio(bio, -EIO);
 		return 0;
 	}
