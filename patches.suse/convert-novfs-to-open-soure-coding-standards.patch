From rgoldwyn@suse.de Tue Jun 10 15:41:39 2008
From: Goldwyn Rodrigues <rgoldwyn@suse.de>
Date: Tue Jun 10 14:22:41 IST 2008
Subject: Convert novfs to open soure coding standards
Message-ID: <1213088555.4964.9.camel@baloo.junglebook>


Convert novfs to open source coding standards. Summary - 
	- convert structures from typedefs to structures
	- change function names 
	- remove unused functions
	- use correct structures in function prototypes instead of void
	  pointers
	- return immediately on error (such as ENOMEM), instead of
	  creating enclosing in if..else code blocks for better
	  understanding.

Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.de>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 fs/novfs/commands.h |  818 ++++++--------
 fs/novfs/daemon.c   | 1031 ++++++------------
 fs/novfs/file.c     |  894 ++++++++-------
 fs/novfs/inode.c    | 2950 ++++++++++++++++++----------------------------------
 fs/novfs/nwcapi.c   | 2888 ++++++++++++++++++++++----------------------------
 fs/novfs/nwcapi.h   | 1019 +----------------
 fs/novfs/proc.c     |   85 -
 fs/novfs/profile.c  |  169 +-
 fs/novfs/scope.c    |  362 +++---
 fs/novfs/vfs.h      |  406 +++----
 10 files changed, 4133 insertions(+), 6489 deletions(-)

--- a/fs/novfs/commands.h
+++ b/fs/novfs/commands.h
@@ -126,11 +126,7 @@
 
 #pragma pack(push, 1)
 
-#ifndef NWHANDLE
-typedef void *NWHANDLE;
-#endif
-
-/*typedef struct _ncl_string
+/*struct _ncl_string
 {
 	unsigned int  	type;
 	unsigned char 	*buffer;
@@ -138,206 +134,127 @@ typedef void *NWHANDLE;
 
 } NclString, *PNclString;
 */
-typedef struct _ncl_string {
+struct ncl_string {
 	unsigned int type;
 	unsigned char *buffer;
 	u32 len;
+};
 
-} NclString, *PNclString;
-
-typedef struct _nwd_string {
+struct nwd_string {
 	unsigned int type;
 	unsigned int len;
 	unsigned int boffset;
+};
 
-} NwdString, *PNwdString;
-
-typedef struct _COMMAND_REQUEST_HEADER {
+struct novfs_command_request_header {
 	unsigned int CommandType;
 	unsigned long SequenceNumber;
-	struct schandle SessionId;
-} COMMAND_REQUEST_HEADER, *PCOMMAND_REQUEST_HEADER;
+	struct novfs_schandle SessionId;
+
+};
 
-typedef struct _COMMAND_REPLY_HEADER {
+struct novfs_command_reply_header {
 	unsigned long Sequence_Number;
 	unsigned int ErrorCode;
 
-} COMMAND_REPLY_HEADER, *PCOMMAND_REPLY_HEADER;
+};
 
-typedef struct _CLOSE_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	NWHANDLE FileHandle;
-} CLOSE_REQUEST, *PCLOSE_REQUEST;
-
-typedef struct _CLOSE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-} CLOSE_REPLY, *PCLOSE_REPLY;
 
-typedef struct _DELETE_FILE_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_delete_file_request {
+	struct novfs_command_request_header Command;
 	unsigned int isDirectory;
 	unsigned int pathlength;
 	unsigned char path[1];
-} DELETE_FILE_REQUEST, *PDELETE_FILE_REQUEST;
+};
 
-typedef struct _DELETE_FILE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-} DELETE_FILE_REPLY, *PDELETE_FILE_REPLY;
-
-typedef struct _FLUSH_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	NWHANDLE FileHandle;
-} FLUSH_REQUEST, *PFLUSH_REQUEST;
-
-typedef struct _FLUSH_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-} FLUSH_REPLY, *PFLUSH_REPLY;
-
-typedef struct _GET_FILEINFO_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	NWHANDLE FileHandle;
-} GET_FILEINFO_REQUEST, *PGET_FILEINFO_REQUEST;
-
-typedef struct _GET_FILEINFO_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-} GET_FILEINFO_REPLY, *PGET_FILEINFO_REPLY;
-
-typedef struct _GET_CONNECTED_SERVER_LIST_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-} GET_CONNECTED_SERVER_LIST_REQUEST, *PGET_CONNECTED_SERVER_LIST_REQUEST;
+struct novfs_delete_file_reply {
+	struct novfs_command_reply_header Reply;
+};
+
+struct novfs_get_connected_server_list {
+	struct novfs_command_request_header Command;
+};
 
-typedef struct _GET_CONNECTED_SERVER_LIST_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_get_connected_server_list_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned char List[1];
-} GET_CONNECTED_SERVER_LIST_REPLY, *PGET_CONNECTED_SERVER_LIST_REPLY;
+};
+
+struct novfs_get_connected_server_list_request_ex {
+	struct novfs_command_request_header Command;
+};
 
-typedef struct _GET_CONNECTED_SERVER_LIST_REQUEST_EX {
-	COMMAND_REQUEST_HEADER Command;
-} GET_CONNECTED_SERVER_LIST_REQUEST_EX, *PGET_CONNECTED_SERVER_LIST_REQUEST_EX;
+struct novfs_get_connected_server_list_reply_ex {
 
-typedef struct _GET_CONNECTED_SERVER_LIST_REPLY_EX {
-	COMMAND_REPLY_HEADER Reply;
+	struct novfs_command_reply_header Reply;
 	unsigned int bufferLen;
 	unsigned char List[1];
 
-} GET_CONNECTED_SERVER_LIST_REPLY_EX, *PGET_CONNECTED_SERVER_LIST_REPLY_EX;
+};
 
-typedef struct _GET_SERVER_VOLUME_LIST_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_get_server_volume_list {
+	struct novfs_command_request_header Command;
 	unsigned int Length;
 	unsigned char Name[1];
-} GET_SERVER_VOLUME_LIST_REQUEST, *PGET_SERVER_VOLUME_LIST_REQUEST;
+};
 
-typedef struct _GET_SERVER_VOLUME_LIST_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_get_server_volume_list_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned char List[1];
-} GET_SERVER_VOLUME_LIST_REPLY, *PGET_SERVER_VOLUME_LIST_REPLY;
-
-typedef struct _OPEN_CONNECTION_BY_ADDR_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	unsigned int address;
-
-} OPEN_CONNECTION_BY_ADDR_REQUEST, *POPEN_CONNECTION_BY_ADDR_REQUEST;
-
-typedef struct _OPEN_CONNECTION_BY_ADDR_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-	unsigned char serverName[64];
-	unsigned char treeName[64];
-	NWHANDLE connHandle;
-
-} OPEN_CONNECTION_BY_ADDR_REPLY, *POPEN_CONNECTION_BY_ADDR_REPLY;
-
-typedef struct _OPEN_CONNECTION_BY_NAME_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	unsigned int NameLen;
-	unsigned char Name[1];
-
-} OPEN_CONNECTION_BY_NAME_REQUEST, *POPEN_CONNECTION_BY_NAME_REQUEST;
+};
 
-typedef struct _OPEN_CONNECTION_BY_NAME_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-	unsigned char treeName[64];
-	NWHANDLE connHandle;
-
-} OPEN_CONNECTION_BY_NAME_REPLY, *POPEN_CONNECTION_BY_NAME_REPLY;
-
-/*
-typedef struct _LOGIN_IDENTITY_REQUEST
-{
-	COMMAND_REQUEST_HEADER Command;
-	unsigned int			treeFlags;
-	unsigned char			treeName[64];
-	unsigned int			serverFlags;
-	unsigned char			serverName[64];
-	unsigned int			userFlags;
-	unsigned char			userName[512];
-	unsigned int			passwordFlags;
-	unsigned char			password[128];
-
-} LOGIN_IDENTITY_REQUEST, *PLOGIN_IDENTITY_REQUEST;
-
-typedef struct _LOGIN_IDENTITY_REPLY
-{
-	COMMAND_REPLY_HEADER Reply;
-	unsigned char			serverName[64];
-	unsigned char			treeName[64];
-	NWHANDLE					connHandle;
-
-} LOGIN_IDENTITY_REPLY, *PLOGIN_IDENTITY_REPLY;
-*/
-
-typedef struct _VERIFY_FILE_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_verify_file_request {
+	struct novfs_command_request_header Command;
 	unsigned int pathLen;
 	unsigned char path[1];
 
-} VERIFY_FILE_REQUEST, *PVERIFY_FILE_REQUEST;
+};
 
-typedef struct _VERIFY_FILE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_verify_file_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned int lastAccessTime;
 	unsigned int modifyTime;
 	unsigned int createTime;
 	unsigned long long fileSize;
 	unsigned int fileMode;
 
-} VERIFY_FILE_REPLY, *PVERIFY_FILE_REPLY;
+};
 
-typedef struct _BEGIN_ENUMERATE_DIRECTORY_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_begin_enumerate_directory_request {
+	struct novfs_command_request_header Command;
 	unsigned int pathLen;
 	unsigned char path[1];
 
-} BEGIN_ENUMERATE_DIRECTORY_REQUEST, *PBEGIN_ENUMERATE_DIRECTORY_REQUEST;
+};
 
-typedef struct _BEGIN_ENUMERATE_DIRECTORY_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-	HANDLE enumerateHandle;
+struct novfs_begin_enumerate_directory_reply {
+	struct novfs_command_reply_header Reply;
+	void *enumerateHandle;
 
-} BEGIN_ENUMERATE_DIRECTORY_REPLY, *PBEGIN_ENUMERATE_DIRECTORY_REPLY;
+};
 
-typedef struct _END_ENUMERATE_DIRECTORY_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE enumerateHandle;
+struct novfs_end_enumerate_directory_request {
+	struct novfs_command_request_header Command;
+	void *enumerateHandle;
 
-} END_ENUMERATE_DIRECTORY_REQUEST, *PEND_ENUMERATE_DIRECTORY_REQUEST;
+};
 
-typedef struct _END_ENUMERATE_DIRECTORY_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_end_enumerate_directory_reply {
+	struct novfs_command_reply_header Reply;
 
-} END_ENUMERATE_DIRECTORY_REPLY, *PEND_ENUMERATE_DIRECTORY_REPLY;
+};
 
-typedef struct _ENUMERATE_DIRECTORY_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE enumerateHandle;
+struct novfs_enumerate_directory_request {
+	struct novfs_command_request_header Command;
+	void *enumerateHandle;
 	unsigned int pathLen;
 	unsigned char path[1];
 
-} ENUMERATE_DIRECTORY_REQUEST, *PENUMERATE_DIRECTORY_REQUEST;
+};
 
-typedef struct _ENUMERATE_DIRECTORY_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-	HANDLE enumerateHandle;
+struct novfs_enumerate_directory_reply {
+	struct novfs_command_reply_header Reply;
+	void *enumerateHandle;
 	unsigned int lastAccessTime;
 	unsigned int modifyTime;
 	unsigned int createTime;
@@ -346,17 +263,17 @@ typedef struct _ENUMERATE_DIRECTORY_REPL
 	unsigned int nameLen;
 	unsigned char name[1];
 
-} ENUMERATE_DIRECTORY_REPLY, *PENUMERATE_DIRECTORY_REPLY;
+};
 
-typedef struct _ENUMERATE_DIRECTORY_EX_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE enumerateHandle;
+struct novfs_enumerate_directory_ex_request {
+	struct novfs_command_request_header Command;
+	void *enumerateHandle;
 	unsigned int pathLen;
 	unsigned char path[1];
 
-} ENUMERATE_DIRECTORY_EX_REQUEST, *PENUMERATE_DIRECTORY_EX_REQUEST;
+};
 
-typedef struct _ENUMERATE_DIRECTORY_EX_DATA {
+struct novfs_enumerate_directory_ex_data {
 	unsigned int length;
 	unsigned int lastAccessTime;
 	unsigned int modifyTime;
@@ -366,143 +283,130 @@ typedef struct _ENUMERATE_DIRECTORY_EX_D
 	unsigned int nameLen;
 	unsigned char name[1];
 
-} ENUMERATE_DIRECTORY_EX_DATA, *PENUMERATE_DIRECTORY_EX_DATA;
+};
 
-typedef struct _ENUMERATE_DIRECTORY_EX_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-	HANDLE enumerateHandle;
+struct novfs_enumerate_directory_ex_reply {
+	struct novfs_command_reply_header Reply;
+	void *enumerateHandle;
 	unsigned int enumCount;
 
-} ENUMERATE_DIRECTORY_EX_REPLY, *PENUMERATE_DIRECTORY_EX_REPLY;
+};
 
-typedef struct _OPEN_FILE_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_open_file_request {
+	struct novfs_command_request_header Command;
 	unsigned int access;	/* File Access */
 	unsigned int mode;	/* Sharing Mode */
 	unsigned int disp;	/* Create Disposition */
 	unsigned int pathLen;
 	unsigned char path[1];
 
-} OPEN_FILE_REQUEST, *POPEN_FILE_REQUEST;
+};
 
-typedef struct _OPEN_FILE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-	HANDLE handle;
+struct novfs_open_file_reply {
+	struct novfs_command_reply_header Reply;
+	void *handle;
 	unsigned int lastAccessTime;
 	unsigned int modifyTime;
 	unsigned int createTime;
 	unsigned int attributes;
 	loff_t size;
 
-} OPEN_FILE_REPLY, *POPEN_FILE_REPLY;
+};
 
-typedef struct _CREATE_FILE_REQUEST {
+struct novfs_create_file_request {
 
-	COMMAND_REQUEST_HEADER Command;
+	struct novfs_command_request_header Command;
 	unsigned int pathlength;
 	unsigned char path[1];
 
-} CREATE_FILE_REQUEST, *PCREATE_FILE_REQUEST;
+};
 
-typedef struct _CREATE_FILE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_create_file_reply {
+	struct novfs_command_reply_header Reply;
 
-} CREATE_FILE_REPLY, *PCREATE_FILE_REPLY;
+};
 
-typedef struct _CLOSE_FILE_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE handle;
+struct novfs_close_file_request {
+	struct novfs_command_request_header Command;
+	void *handle;
 
-} CLOSE_FILE_REQUEST, *PCLOSE_FILE_REQUEST;
+};
 
-typedef struct _CLOSE_FILE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_close_file_reply {
+	struct novfs_command_reply_header Reply;
 
-} CLOSE_FILE_REPLY, *PCLOSE_FILE_REPLY;
+};
 
-typedef struct _READ_FILE_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE handle;
+struct novfs_read_file_request {
+	struct novfs_command_request_header Command;
+	void *handle;
 	loff_t offset;
 	size_t len;
 
-} READ_FILE_REQUEST, *PREAD_FILE_REQUEST;
+};
 
-typedef struct _READ_FILE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_read_file_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned long long bytesRead;
 	unsigned char data[1];
 
-} READ_FILE_REPLY, *PREAD_FILE_REPLY;
+};
 
-typedef struct _WRITE_FILE_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE handle;
+struct novfs_write_file_request {
+	struct novfs_command_request_header Command;
+	void *handle;
 	loff_t offset;
 	size_t len;
 	unsigned char data[1];
 
-} WRITE_FILE_REQUEST, *PWRITE_FILE_REQUEST;
+};
 
-typedef struct _WRITE_FILE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_write_file_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned long long bytesWritten;
-} WRITE_FILE_REPLY, *PWRITE_FILE_REPLY;
+};
 
-typedef struct _READ_STREAM_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE connection;
+struct novfs_read_stream_request {
+	struct novfs_command_request_header Command;
+	void *connection;
 	unsigned char handle[6];
 	loff_t offset;
 	size_t len;
-} READ_STREAM_REQUEST, *PREAD_STREAM_REQUEST;
+};
 
-typedef struct _READ_STREAM_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_read_stream_reply {
+	struct novfs_command_reply_header Reply;
 	size_t bytesRead;
 	unsigned char data[1];
-} READ_STREAM_REPLY, *PREAD_STREAM_REPLY;
+};
 
-typedef struct _WRITE_STREAM_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE connection;
+struct novfs_write_stream_request {
+	struct novfs_command_request_header Command;
+	void *connection;
 	unsigned char handle[6];
 	loff_t offset;
 	size_t len;
 	unsigned char data[1];
-} WRITE_STREAM_REQUEST, *PWRITE_STREAM_REQUEST;
+};
 
-typedef struct _WRITE_STREAM_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_write_stream_reply {
+	struct novfs_command_reply_header Reply;
 	size_t bytesWritten;
-} WRITE_STREAM_REPLY, *PWRITE_STREAM_REPLY;
+};
 
-typedef struct _CLOSE_STREAM_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE connection;
+struct novfs_close_stream_request {
+	struct novfs_command_request_header Command;
+	void *connection;
 	unsigned char handle[6];
-} CLOSE_STREAM_REQUEST, *PCLOSE_STREAM_REQUEST;
+};
 
-typedef struct _CLOSE_STREAM_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_close_stream_reply {
+	struct novfs_command_reply_header Reply;
 
-} CLOSE_STREAM_REPLY, *PCLOSE_STREAM_REPLY;
+};
 
-typedef struct _CREATE_DIRECTORY_REQUEST {
-
-	COMMAND_REQUEST_HEADER Command;
-	unsigned int pathlength;
-	unsigned char path[1];
-
-} CREATE_DIRECTORY_REQUEST, *PCREATE_DIRECTORY_REQUEST;
-
-typedef struct _CREATE_DIRECTORY_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-
-} CREATE_DIRECTORY_REPLY, *PCREATE_DIRECTORY_REPLY;
-
-typedef struct _LOGIN_USER_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_login_user_request {
+	struct novfs_command_request_header Command;
 	unsigned int srvNameType;
 	unsigned int serverLength;
 	unsigned int serverOffset;
@@ -513,46 +417,47 @@ typedef struct _LOGIN_USER_REQUEST {
 	unsigned int passwordLength;
 	unsigned int passwordOffset;
 
-} LOGIN_USER_REQUEST, *PLOGIN_USER_REQUEST;
+};
 
-typedef struct _LOGIN_USER_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_login_user_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned int connectionHandle;
-	HANDLE loginIdentity;
+	void *loginIdentity;
 
-} LOGIN_USER_REPLY, *PLOGIN_USER_REPLY;
+};
 
-typedef struct _LOGOUT_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_logout_request {
+	struct novfs_command_request_header Command;
 	unsigned int length;
 	unsigned char Name[1];
 
-} LOGOUT_REQUEST, *PLOGOUT_REQUEST;
+};
 
-typedef struct _LOGOUT_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_logout_reply {
+	struct novfs_command_reply_header Reply;
 
-} LOGOUT_REPLY, *PLOGOUT_REPLY;
+};
 
-typedef struct _CREATE_CONTEXT_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_create_context_request {
+	struct novfs_command_request_header Command;
 
-} CREATE_CONTEXT_REQUEST, *PCREATE_CONTEXT_REQUEST;
+};
 
-typedef struct _CREATE_CONTEXT_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-	struct schandle SessionId;
-} CREATE_CONTEXT_REPLY, *PCREATE_CONTEXT_REPLY;
+struct novfs_create_context_reply {
+	struct novfs_command_reply_header Reply;
+	struct novfs_schandle SessionId;
 
-typedef struct _DESTROY_CONTEXT_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+};
 
-} DESTROY_CONTEXT_REQUEST, *PDESTROY_CONTEXT_REQUEST;
+struct novfs_destroy_context_request {
+	struct novfs_command_request_header Command;
 
-typedef struct _DESTROY_CONTEXT_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+};
 
-} DESTROY_CONTEXT_REPLY, *PDESTROY_CONTEXT_REPLY;
+struct novfs_destroy_context_reply {
+	struct novfs_command_reply_header Reply;
+
+};
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what
@@ -572,7 +477,7 @@ typedef struct _DESTROY_CONTEXT_REPLY {
 #define ATTR_ATTR_FLAG	1024
 #endif
 
-typedef struct _LNX_FILE_INFO {
+struct novfs_lnx_file_info {
 	unsigned int ia_valid;
 	unsigned int ia_mode;
 	uid_t ia_uid;
@@ -582,126 +487,124 @@ typedef struct _LNX_FILE_INFO {
 	time_t ia_mtime;
 	time_t ia_ctime;
 	unsigned int ia_attr_flags;
+};
 
-} LX_FILE_INFO, *PLX_FILE_INFO;
-
-typedef struct _SET_FILE_INFO_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	LX_FILE_INFO fileInfo;
+struct novfs_set_file_info_request {
+	struct novfs_command_request_header Command;
+	struct novfs_lnx_file_info fileInfo;
 	unsigned int pathlength;
 	char path[1];
+};
 
-} SET_FILE_INFO_REQUEST, *PSET_FILE_INFO_REQUEST;
-
-typedef struct _SET_FILE_INFO_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_set_file_info_reply {
+	struct novfs_command_reply_header Reply;
 
-} SET_FILE_INFO_REPLY, *PSET_FILE_INFO_REPLY;
+};
 
-typedef struct _TRUNCATE_FILE_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_truncate_file_request {
+	struct novfs_command_request_header Command;
 	unsigned int pathLen;
 	char path[1];
 
-} TRUNCATE_FILE_REQUEST, *PTRUNCATE_FILE_REQUEST;
+};
 
-typedef struct _TRUNCATE_FILE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_truncate_file_reply {
+	struct novfs_command_reply_header Reply;
 
-} TRUNCATE_FILE_REPLY, *PTRUNCATE_FILE_REPLY;
+};
 
-typedef struct _GETPWUID_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_getpwuid_request {
+	struct novfs_command_request_header Command;
 	unsigned int uid;
-} GETPWUID_REQUEST, *PGETPWUID_REQUEST;
+};
 
-typedef struct _GETPWUID_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_getpwuid_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned char UserName[1];
-} GETPWUID_REPLY, *PGETPWUID_REPLY;
+};
 
-typedef struct _GET_VERSION_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-} GET_VERSION_REQUEST, *PGET_VERSION_REQUEST;
+struct novfs_get_version_request {
+	struct novfs_command_request_header Command;
+};
 
-typedef struct _GET_VERSION_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_get_version_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned char Version[1];
-} GET_VERSION_REPLY, *PGET_VERSION_REPLY;
+};
 
-typedef struct _SET_MOUNT_PATH {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_set_mount_path {
+	struct novfs_command_request_header Command;
 	unsigned int PathLength;
 	unsigned char Path[1];
-} SET_MOUNT_PATH_REQUEST, *PSET_MOUNT_PATH_REQUEST;
+};
 
-typedef struct _SET_MOUNT_PATH_REPLY {
-	COMMAND_REPLY_HEADER Reply;
-} SET_MOUNT_PATH, *PSET_MOUNT_PATH_REPLY;
-
-typedef struct _GET_USER_SPACE {
-	COMMAND_REQUEST_HEADER Command;
-} GET_USER_SPACE_REQUEST, *PGET_USER_SPACE_REQUEST;
+struct novfs_set_mount_path_reply {
+	struct novfs_command_reply_header Reply;
+};
+
+struct novfs_get_user_space {
+	struct novfs_command_request_header Command;
+};
 
-typedef struct _GET_USER_SPACE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_get_user_space_reply {
+	struct novfs_command_reply_header Reply;
 	uint64_t TotalSpace;
 	uint64_t FreeSpace;
 	uint64_t TotalEnties;
 	uint64_t FreeEnties;
-} GET_USER_SPACE_REPLY, *PGET_USER_SPACE_REPLY;
+};
 
-typedef struct _XPLAT_CALL_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_xplat_call_request {
+	struct novfs_command_request_header Command;
 	unsigned int NwcCommand;
 	unsigned long dataLen;
 	unsigned char data[1];
 
-} XPLAT_CALL_REQUEST, *PXPLAT_CALL_REQUEST;
+};
 
-typedef struct _XPLAT_CALL_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_xplat_call_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned long dataLen;
 	unsigned char data[1];
 
-} XPLAT_CALL_REPLY, *PXPLAT_CALL_REPLY;
+};
 
 /* XPlat NWC structures used by the daemon */
 
-typedef struct _NWD_OPEN_CONN_BY_NAME {
-	HANDLE ConnHandle;
+struct nwd_open_conn_by_name {
+	void *ConnHandle;
 	unsigned int nameLen;
 	unsigned int oName;	/* Ofset to the Name */
 	unsigned int serviceLen;
 	unsigned int oServiceType;	/* Offset to service Type; */
 	unsigned int uConnFlags;
 	unsigned int uTranType;
-	HANDLE newConnHandle;
+	void *newConnHandle;
 
-} NwdCOpenConnByName, *PNwdCOpenConnByName;
+};
 
-typedef struct _NWD_TRAN_ADDR {
+struct nwd_tran_addr {
 	unsigned int uTransportType;
 	unsigned int uAddressLength;
 	unsigned int oAddress;
 
-} NwdCTranAddr, *PNwdCTranAddr;
+};
 
-typedef struct _NWD_OPEN_CONN_BY_ADDR {
-	HANDLE ConnHandle;
+struct nwd_open_conn_by_addr {
+	void *ConnHandle;
 	unsigned int oServiceType;
 	unsigned int uConnFlags;
-	NwdCTranAddr TranAddr;
+	struct nwd_tran_addr TranAddr;
 
-} NwdCOpenConnByAddr, *PNwdCOpenConnByAddr;
+};
 
-typedef struct _NWD_CLOSE_CONN {
-	HANDLE ConnHandle;
+struct nwd_close_conn {
+	void *ConnHandle;
 
-} NwdCCloseConn, *PNwdCCloseConn;
+};
 
-typedef struct _NWD_NCP_REQ {
-	HANDLE ConnHandle;
+struct nwd_ncp_req {
+	void *ConnHandle;
 	unsigned int replyLen;
 	unsigned int requestLen;
 	unsigned int function;
@@ -710,48 +613,37 @@ typedef struct _NWD_NCP_REQ {
 	unsigned int flags;
 	unsigned char data[1];
 
-} NwdCNCPReq, *PNwdCNCPReq;
+};
 
-typedef struct _NWD_NCP_REP {
+struct nwd_ncp_rep {
 	unsigned int replyLen;
 	unsigned char data[1];
 
-} NwdCNCPRep, *PNwdCNCPRep;
+};
 
-typedef struct _NWC_AUTH_WID {
-	HANDLE ConnHandle;
+struct nwc_auth_wid {
+	void *ConnHandle;
 	u32 AuthenticationId;
 
-} NwdCAuthenticateWithId, *PNwdCAuthenticateWithId;
+};
 
-typedef struct _NWC_AUTHENTICATE {
-	HANDLE ConnHandle;
-	unsigned int uAuthenticationType;
-	unsigned int userNameOffset;
-	unsigned int passwordOffset;
-	unsigned int MaxInfoLength;
-	unsigned int InfoLength;
-	unsigned int authenInfoOffset;
-
-} NwdCAuthenticate, *PNwdCAuthenticate;
-
-typedef struct _NWC_UNAUTHENTICATE {
-	HANDLE ConnHandle;
+struct nwc_unauthenticate {
+	void *ConnHandle;
 	unsigned int AuthenticationId;
 
-} NwdCUnauthenticate, *PNwdCUnauthenticate;
+};
 
-typedef struct _NWC_LISC_ID {
-	HANDLE ConnHandle;
+struct nwc_lisc_id {
+	void *ConnHandle;
 
-} NwdCLicenseConn, *PNwdCLicenseConn;
+};
 
-typedef struct _NWC_UNLIC_CONN {
-	HANDLE ConnHandle;
+struct nwc_unlic_conn {
+	void *ConnHandle;
 
-} NwdCUnlicenseConn, *PNwdCUnlicenseConn;
+};
 
-typedef struct _NWC_GET_IDENT_INFO {
+struct nwd_get_id_info {
 	u32 AuthenticationId;
 	unsigned int AuthType;
 	unsigned int NameType;
@@ -762,44 +654,44 @@ typedef struct _NWC_GET_IDENT_INFO {
 	unsigned int objectLen;
 	unsigned int pObjectNameOffset;
 
-} NwdCGetIdentityInfo, *PNwdCGetIdentityInfo;
+};
 
-typedef struct _NWC_LO_ID {
+struct nwc_lo_id {
 	u32 AuthenticationId;
 
-} NwdCLogoutIdentity, *PNwdCLogoutIdentity;
+};
 
-typedef struct _RENAME_FILE_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_rename_file_request {
+	struct novfs_command_request_header Command;
 	int directoryFlag;
 	unsigned int newnameLen;
 	unsigned char newname[256];
 	unsigned int oldnameLen;
 	unsigned char oldname[256];
-} RENAME_FILE_REQUEST, *PRENAME_FILE_REQUEST;
+};
 
-typedef struct _RENAME_FILE_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_rename_file_reply {
+	struct novfs_command_reply_header Reply;
 
-} RENAME_FILE_REPLY, *PRENAME_FILE_REPLY;
+};
 
-typedef struct __NwdServerVersion {
+struct nwd_server_version {
 	unsigned int uMajorVersion;
 	unsigned short int uMinorVersion;
 	unsigned short int uRevision;
+};
 
-} NwdServerVersion, *PNwdServerVersion;
 
 #define	MAX_ADDRESS_LENGTH	32
 
-typedef struct tagNwdTranAddrEx {
+struct tagNwdTranAddrEx {
 	unsigned int uTransportType;
 	unsigned int uAddressLength;
 	unsigned char Buffer[MAX_ADDRESS_LENGTH];
 
-} NwdTranAddr, *PNwdTranAddr;
+};
 
-typedef struct __NWD_CONN_INFO {
+struct __NWD_CONN_INFO {
 	unsigned int uInfoVersion;
 	unsigned int uAuthenticationState;
 	unsigned int uBroadcastState;
@@ -819,33 +711,31 @@ typedef struct __NWD_CONN_INFO {
 	unsigned int uDistance;
 	u32 uAuthId;
 	unsigned int uDisconnected;
-	NwdServerVersion ServerVersion;
-	NwdTranAddr TranAddress;
-
-} NwdConnInfo, *PNwdConnInfo;
+	struct nwd_server_version ServerVersion;
+	struct nwd_tran_addr TranAddress;
+};
 
-typedef struct _nwd_conn_info {
-	HANDLE ConnHandle;
+struct nwd_conn_info {
+	void *ConnHandle;
 	unsigned int uInfoLevel;
 	unsigned int uInfoLength;
+};
 
-} NwdCGetConnInfo, *PNwdCGetConnInfo;
-
-typedef struct nwd_open_conn_by_Ref {
-	HANDLE uConnReference;
+struct nwd_open_conn_by_ref {
+	void *uConnReference;
 	unsigned int uConnFlags;
-	HANDLE ConnHandle;
+	void *ConnHandle;
 
-} NwdCOpenConnByRef, *PNwdCOpenConnByRef;
+};
 
-typedef struct nwd_get_reqversion {
+struct nwd_get_reqversion {
 	unsigned int uMajorVersion;
 	unsigned int uMinorVersion;
 	unsigned int uRevision;
 
-} NwdCGetRequesterVersion, *PNwdCGetRequesterVersion;
+};
 
-typedef struct _nwc_scan_conn_info {
+struct nwd_scan_conn_info {
 	unsigned int uScanIndex;
 	unsigned int uScanInfoLevel;
 	unsigned int uScanInfoLen;
@@ -856,43 +746,43 @@ typedef struct _nwc_scan_conn_info {
 	unsigned int uConnectionReference;
 	unsigned int uReturnConnInfoOffset;
 
-} NwdCScanConnInfo, *PNwdCScanConnInfo;
+};
 
-typedef struct nwc_get_pref_ds_tree {
+struct nwd_get_pref_ds_tree {
 	unsigned int uTreeLength;
 	unsigned int DsTreeNameOffset;
 
-} NwdCGetPreferredDsTree, *PNwdCGetPreferredDsTree;
+};
 
-typedef struct nwc_set_pref_ds_tree {
+struct nwd_set_pref_ds_tree {
 	unsigned int uTreeLength;
 	unsigned int DsTreeNameOffset;
 
-} NwdCSetPreferredDsTree, *PNwdCSetPreferredDsTree;
+};
 
-typedef struct nwc_set_def_name_ctx {
+struct nwd_set_def_name_ctx {
 	unsigned int uTreeLength;
 	unsigned int TreeOffset;
 	unsigned int uNameLength;
 	unsigned int NameContextOffset;
 
-} NwdCSetDefaultNameContext, *PNwdCSetDefaultNameContext;
+};
 
-typedef struct nwc_get_def_name_ctx {
+struct nwd_get_def_name_ctx {
 	unsigned int uTreeLength;
 	unsigned int TreeOffset;
 	unsigned int uNameLength;
 	unsigned int NameContextOffset;
 
-} NwdCGetDefaultNameContext, *PNwdCGetDefaultNameContext;
+};
 
-typedef struct _nwc_get_treemonitored_connref {
-	NwdString TreeName;
-	HANDLE uConnReference;
+struct nwd_get_tree_monitored_conn_ref {
+	struct nwd_string TreeName;
+	void *uConnReference;
 
-} NwdCGetTreeMonitoredConnRef, *PNwdCGetTreeMonitoredConnRef;
+};
 
-typedef struct _nwc_enumerate_identities {
+struct nwd_enum_ids {
 	unsigned int Iterator;
 	unsigned int domainNameLen;
 	unsigned int domainNameOffset;
@@ -904,9 +794,9 @@ typedef struct _nwc_enumerate_identities
 	unsigned int IdentityFlags;
 	u32 AuthenticationId;
 
-} NwdCDEnumerateIdentities, *PNwdCEnumerateIdentities;
+};
 
-typedef struct nwd_change_key {
+struct nwd_change_key {
 	unsigned int domainNameOffset;
 	unsigned int domainNameLen;
 	unsigned int AuthType;
@@ -919,82 +809,43 @@ typedef struct nwd_change_key {
 	unsigned int newPasswordOffset;
 	unsigned int newPasswordLen;
 
-} NwdCChangeKey, *PNwdCChangeKey;
+};
 
-typedef struct _nwd_get_primary_conn {
-	HANDLE uConnReference;
+struct nwd_set_primary_conn {
+	void *ConnHandle;
 
-} NwdCGetPrimaryConnection, *PNwdCGetPrimaryConnection;
+};
 
-typedef struct _nwd_set_primary_conn {
-	HANDLE ConnHandle;
-
-} NwdCSetPrimaryConnection, *PNwdCSetPrimaryConnection;
-
-typedef struct _nwd_map_drive_ex {
-	u32 ConnHandle;
-	u32 localUid;
-	u32 linkOffsetLength;
-	u32 linkOffset;
-	u32 dirPathOffsetLength;
-	u32 dirPathOffset;
-
-} NwdCMapDriveEx, *PNwdCMapDriveEx;
-
-typedef struct _nwd_unmap_drive_ex {
-	unsigned int linkLen;
-	char linkPath[1];
-
-} NwdCUnmapDriveEx, *PNwdCUnmapDriveEx;
-
-typedef struct _nwd_enum_links {
-	unsigned int totalLen;
-	unsigned int linkCount;
-
-} NwdCEnumLinks, *PNwdCEnumLinks;
-
-typedef struct nwd_getbroadcastnotification {
+struct nwd_get_bcast_notification {
 	unsigned int uMessageFlags;
-	HANDLE uConnReference;
+	void *uConnReference;
 	unsigned int messageLen;
 	char message[1];
 
-} NwdCGetBroadcastNotification, *PNwdCGetBroadcastNotification;
-
-typedef struct _enum_entry {
-	unsigned int entryLen;
-	u32 connHdl;
-	char data[0];
-} NwdCEnumEntry, *PNwdCEnumEntry;
+};
 
-typedef struct _nwd_set_conn_info {
-	HANDLE ConnHandle;
+struct nwd_set_conn_info {
+	void *ConnHandle;
 	unsigned int uInfoLevel;
 	unsigned int uInfoLength;
 	unsigned int offsetConnInfo;
 
-} NwdCSetConnInfo, *PNwdCSetConnInfo;
-
-typedef struct _len_string {
-	u32 stLen;
-	char string[1];
+};
 
-} LString, *PLString;
-
-typedef struct _DEBUG_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_debug_request {
+	struct novfs_command_request_header Command;
 	int cmdlen;
 	char dbgcmd[1];
 
-} DEBUG_REQUEST, *PDEBUG_REQUEST;
+};
 
-typedef struct _DEBUG_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_debug_reply {
+	struct novfs_command_reply_header Reply;
 
-} DEBUG_REPLY, *PDEBUG_REPLY;
+};
 
-typedef struct _Nwd_Set_Key {
-	HANDLE ConnHandle;
+struct nwd_set_key {
+	void *ConnHandle;
 	unsigned int AuthenticationId;
 	unsigned int objectNameLen;
 	unsigned int objectNameOffset;
@@ -1002,9 +853,9 @@ typedef struct _Nwd_Set_Key {
 	unsigned int newPasswordLen;
 	unsigned int newPasswordOffset;
 
-} NwdCSetKey, *PNwdCSetKey;
+};
 
-typedef struct _Nwd_Verify_Key {
+struct nwd_verify_key {
 	unsigned int AuthType;
 	unsigned int NameType;
 	unsigned short int ObjectType;
@@ -1015,43 +866,43 @@ typedef struct _Nwd_Verify_Key {
 	unsigned int verifyPasswordLen;
 	unsigned int verifyPasswordOffset;
 
-} NwdCVerifyKey, *PNwdCVerifyKey;
+};
 
-typedef struct _GET_CACHE_FLAG {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_get_cache_flag {
+	struct novfs_command_request_header Command;
 	int pathLen;
 	unsigned char path[0];
 
-} GET_CACHE_FLAG_REQUEST, *PGET_CACHE_FLAG_REQUEST;
+};
 
-typedef struct _GET_CACHE_FLAG_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_get_cache_flag_reply {
+	struct novfs_command_reply_header Reply;
 	int CacheFlag;
 
-} GET_CACHE_FLAG_REPLY, *PGET_CACHE_FLAG_REPLY;
+};
 
-typedef struct _XA_LIST_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_xa_list_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned char *pData;
 
-} XA_LIST_REPLY, *PXA_LIST_REPLY;
+};
 
-typedef struct _XA_GET_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_xa_get_request {
+	struct novfs_command_request_header Command;
 	unsigned int pathLen;
 	unsigned int nameLen;
 	unsigned char data[1];	//hold path, attribute name
 
-} XA_GET_REQUEST, *PXA_GET_REQUEST;
+};
 
-typedef struct _XA_GET_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_xa_get_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned char *pData;
 
-} XA_GET_REPLY, *PXA_GET_REPLY;
+};
 
-typedef struct _XA_SET_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
+struct novfs_xa_set_request {
+	struct novfs_command_request_header Command;
 	unsigned int TtlWriteDataSize;
 	unsigned int WritePosition;
 	int flags;
@@ -1060,27 +911,44 @@ typedef struct _XA_SET_REQUEST {
 	unsigned int valueLen;
 	unsigned char data[1];	//hold path, attribute name, value data
 
-} XA_SET_REQUEST, *PXA_SET_REQUEST;
+};
 
-typedef struct _XA_SET_REPLY {
-	COMMAND_REPLY_HEADER Reply;
+struct novfs_xa_set_reply {
+	struct novfs_command_reply_header Reply;
 	unsigned char *pData;
 
-} XA_SET_REPLY, *PXA_SET_REPLY;
+};
 
-typedef struct _SET_FILE_LOCK_REQUEST {
-	COMMAND_REQUEST_HEADER Command;
-	HANDLE handle;
+struct novfs_set_file_lock_request {
+	struct novfs_command_request_header Command;
+	void *handle;
 	unsigned char fl_type;
 	loff_t fl_start;
 	loff_t fl_len;
 
-} SET_FILE_LOCK_REQUEST, *PSET_FILE_LOCK_REQUEST;
+};
+
+struct novfs_set_file_lock_reply {
+	struct novfs_command_reply_header Reply;
+
+};
 
-typedef struct _SET_FILE_LOCK_REPLY {
-	COMMAND_REPLY_HEADER Reply;
 
-} SET_FILE_LOCK_REPLY, *PSET_FILE_LOCK_REPLY;
+struct novfs_scope_list{
+	struct list_head ScopeList;
+	struct novfs_schandle ScopeId;
+	struct novfs_schandle SessionId;
+	pid_t ScopePid;
+	struct task_struct *ScopeTask;
+	unsigned int ScopeHash;
+	uid_t ScopeUid;
+	uint64_t ScopeUSize;
+	uint64_t ScopeUFree;
+	uint64_t ScopeUTEnties;
+	uint64_t ScopeUAEnties;
+	int ScopeUserNameLength;
+	unsigned char ScopeUserName[32];
+};
 
 #pragma pack(pop)
 
--- a/fs/novfs/daemon.c
+++ b/fs/novfs/daemon.c
@@ -16,7 +16,6 @@
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/slab.h>
-#include <linux/string.h>
 #include <linux/list.h>
 #include <linux/timer.h>
 #include <linux/poll.h>
@@ -44,14 +43,13 @@
 #define DH_TYPE_STREAM       1
 #define DH_TYPE_CONNECTION   2
 
-/*===[ Type definitions ]=================================================*/
-typedef struct _DAEMON_QUEUE {
+struct daemon_queue {
 	struct list_head list;	/* Must be first entry */
 	spinlock_t lock;	/* Used to control access to list */
 	struct semaphore semaphore;	/* Used to signal when data is available */
-} daemon_queue_t;
+};
 
-typedef struct _DAEMON_COMMAND {
+struct daemon_cmd {
 	struct list_head list;	/* Must be first entry */
 	atomic_t reference;
 	unsigned int status;
@@ -65,61 +63,44 @@ typedef struct _DAEMON_COMMAND {
 	int datalen;
 	void *reply;
 	unsigned long replen;
-} daemon_command_t;
+};
 
-typedef struct _DAEMON_HANDLE_ {
+struct daemon_handle {
 	struct list_head list;
 	rwlock_t lock;
-	session_t session;
-} daemon_handle_t;
+	struct novfs_schandle session;
+};
 
-typedef struct _DAEMON_RESOURCE_ {
+struct daemon_resource {
 	struct list_head list;
 	int type;
-	HANDLE connection;
+	void *connection;
 	unsigned char handle[6];
 	mode_t mode;
 	loff_t size;
-} daemon_resource_t;
+};
 
-typedef struct _DRIVE_MAP_ {
+struct drive_map {
 	struct list_head list;	/* Must be first item */
-	session_t session;
+	struct novfs_schandle session;
 	unsigned long hash;
 	int namelen;
 	char name[1];
-} drive_map_t;
+};
+
+static void Queue_get(struct daemon_cmd * Que);
+static void Queue_put(struct daemon_cmd * Que);
+static void RemoveDriveMaps(void);
+static int NwdConvertLocalHandle(struct novfs_xplat *pdata, struct daemon_handle * DHandle);
+static int NwdConvertNetwareHandle(struct novfs_xplat *pdata, struct daemon_handle * DHandle);
+static int set_map_drive(struct novfs_xplat *pdata, struct novfs_schandle Session);
+static int unmap_drive(struct novfs_xplat *pdata, struct novfs_schandle Session);
+static int NwdGetMountPath(struct novfs_xplat *pdata);
+static int local_unlink(const char *pathname);
 
-/*===[ Function prototypes ]==============================================*/
-int Daemon_Close_Control(struct inode *Inode, struct file *File);
-int Daemon_Library_close(struct inode *inode, struct file *file);
-int Daemon_Library_open(struct inode *inode, struct file *file);
-loff_t Daemon_Library_llseek(struct file *file, loff_t offset, int origin);
-int Daemon_Open_Control(struct inode *Inode, struct file *File);
-uint Daemon_Poll(struct file *file, struct poll_table_struct *poll_table);
-int Daemon_Remove_Resource(daemon_handle_t * DHandle, int Type, HANDLE CHandle,
-			   unsigned long FHandle);
-
-int Daemon_SetMountPoint(char *Path);
-void Daemon_Timer(unsigned long data);
-int Daemon_getpwuid(uid_t uid, int unamelen, char *uname);
-int Queue_Daemon_Command(void *request, unsigned long reqlen, void *data, int dlen,
-			 void **reply, unsigned long * replen, int interruptible);
-void Queue_get(daemon_command_t * que);
-void Queue_put(daemon_command_t * que);
-void Uninit_Daemon_Queue(void);
-daemon_command_t *find_queue(unsigned long sequence);
-daemon_command_t *get_next_queue(int Set_Queue_Waiting);
-int NwdConvertNetwareHandle(PXPLAT pdata, daemon_handle_t * DHandle);
-int NwdConvertLocalHandle(PXPLAT pdata, daemon_handle_t * DHandle);
-int NwdGetMountPath(PXPLAT pdata);
-static int NwdSetMapDrive(PXPLAT pdata, session_t Session);
-static int NwdUnMapDrive(PXPLAT pdata, session_t Session);
-void RemoveDriveMaps(void);
-int local_unlink(const char *pathname);
 
 /*===[ Global variables ]=================================================*/
-static daemon_queue_t Daemon_Queue;
+static struct daemon_queue Daemon_Queue;
 
 static DECLARE_WAIT_QUEUE_HEAD(Read_waitqueue);
 
@@ -131,51 +112,24 @@ static unsigned long Daemon_Command_Time
 static DECLARE_MUTEX(DriveMapLock);
 static LIST_HEAD(DriveMapList);
 
-int MaxIoSize = PAGE_SIZE;
+int novfs_max_iosize = PAGE_SIZE;
 
-void Init_Daemon_Queue(void)
+void novfs_daemon_queue_init()
 {
 	INIT_LIST_HEAD(&Daemon_Queue.list);
 	spin_lock_init(&Daemon_Queue.lock);
 	init_MUTEX_LOCKED(&Daemon_Queue.semaphore);
 }
 
-/*++======================================================================*/
-void Uninit_Daemon_Queue(void)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+void novfs_daemon_queue_exit(void)
 {
 	/* Does nothing for now but we maybe should clear the queue. */
 }
 
 /*++======================================================================*/
-void Daemon_Timer(unsigned long data)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+static void novfs_daemon_timer(unsigned long data)
 {
-	daemon_command_t *que = (daemon_command_t *) data;
+	struct daemon_cmd *que = (struct daemon_cmd *) data;
 
 	if (QUEUE_ACKED != que->status) {
 		que->status = QUEUE_TIMEOUT;
@@ -183,14 +137,14 @@ void Daemon_Timer(unsigned long data)
 	up(&que->semaphore);
 }
 
-int Queue_Daemon_Command(void *request, unsigned long reqlen, void *data, int dlen,
+/*++======================================================================*/
+int Queue_Daemon_Command(void *request,
+			 unsigned long reqlen,
+			 void *data,
+			 int dlen,
 			 void **reply, unsigned long * replen, int interruptible)
-/*
- *  Arguments:     void *request - pointer to the request that is to be sent.  Needs to be kernel memory.
- *                 int reqlen - length of the request.
- *========================================================================*/
 {
-	daemon_command_t *que;
+	struct daemon_cmd *que;
 	int retCode = 0;
 	uint64_t ts1, ts2;
 
@@ -201,6 +155,7 @@ int Queue_Daemon_Command(void *request,
 	if (atomic_read(&Daemon_Open_Count)) {
 
 		que = kmalloc(sizeof(*que), GFP_KERNEL);
+
 		DbgPrint("Queue_Daemon_Command: que=0x%p\n", que);
 		if (que) {
 			atomic_set(&que->reference, 0);
@@ -211,7 +166,7 @@ int Queue_Daemon_Command(void *request,
 
 			que->sequence = atomic_inc_return(&Sequence);
 
-			((PCOMMAND_REQUEST_HEADER) request)->SequenceNumber =
+			((struct novfs_command_request_header *) request)->SequenceNumber =
 			    que->sequence;
 
 			/*
@@ -220,7 +175,7 @@ int Queue_Daemon_Command(void *request,
 			init_timer(&que->timer);
 			que->timer.expires = jiffies + (HZ * Daemon_Command_Timeout);
 			que->timer.data = (unsigned long) que;
-			que->timer.function = Daemon_Timer;
+			que->timer.function = novfs_daemon_timer;
 			add_timer(&que->timer);
 
 			/*
@@ -317,41 +272,13 @@ int Queue_Daemon_Command(void *request,
 	return (retCode);
 }
 
-/*++======================================================================*/
-void Queue_get(daemon_command_t * Que)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+static void Queue_get(struct daemon_cmd * Que)
 {
 	DbgPrint("Queue_get: que=0x%p %d\n", Que, atomic_read(&Que->reference));
 	atomic_inc(&Que->reference);
 }
 
-/*++======================================================================*/
-void Queue_put(daemon_command_t * Que)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+static void Queue_put(struct daemon_cmd * Que)
 {
 
 	DbgPrint("Queue_put: que=0x%p %d\n", Que, atomic_read(&Que->reference));
@@ -373,35 +300,21 @@ void Queue_put(daemon_command_t * Que)
 	}
 }
 
-/*++======================================================================*/
-daemon_command_t *get_next_queue(int Set_Queue_Waiting)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+struct daemon_cmd *get_next_queue(int Set_Queue_Waiting)
 {
-	daemon_command_t *que;
+	struct daemon_cmd *que;
 
 	DbgPrint("get_next_queue: que=0x%p\n", Daemon_Queue.list.next);
 
 	spin_lock(&Daemon_Queue.lock);
-	que = (daemon_command_t *) Daemon_Queue.list.next;
+	que = (struct daemon_cmd *) Daemon_Queue.list.next;
 
-	while (que && (que != (daemon_command_t *) & Daemon_Queue.list.next)
+	while (que && (que != (struct daemon_cmd *) & Daemon_Queue.list.next)
 	       && (que->status != QUEUE_SENDING)) {
-		que = (daemon_command_t *) que->list.next;
+		que = (struct daemon_cmd *) que->list.next;
 	}
 
-	if ((NULL == que) || (que == (daemon_command_t *) & Daemon_Queue.list)
+	if ((NULL == que) || (que == (struct daemon_cmd *) & Daemon_Queue.list)
 	    || (que->status != QUEUE_SENDING)) {
 		que = NULL;
 	} else if (Set_Queue_Waiting) {
@@ -418,36 +331,22 @@ daemon_command_t *get_next_queue(int Set
 	return (que);
 }
 
-/*++======================================================================*/
-daemon_command_t *find_queue(unsigned long sequence)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+static struct daemon_cmd *find_queue(unsigned long sequence)
 {
-	daemon_command_t *que;
+	struct daemon_cmd *que;
 
 	DbgPrint("find_queue: 0x%x\n", sequence);
 
 	spin_lock(&Daemon_Queue.lock);
-	que = (daemon_command_t *) Daemon_Queue.list.next;
+	que = (struct daemon_cmd *) Daemon_Queue.list.next;
 
-	while (que && (que != (daemon_command_t *) & Daemon_Queue.list.next)
+	while (que && (que != (struct daemon_cmd *) & Daemon_Queue.list.next)
 	       && (que->sequence != sequence)) {
-		que = (daemon_command_t *) que->list.next;
+		que = (struct daemon_cmd *) que->list.next;
 	}
 
 	if ((NULL == que)
-	    || (que == (daemon_command_t *) & Daemon_Queue.list.next)
+	    || (que == (struct daemon_cmd *) & Daemon_Queue.list.next)
 	    || (que->sequence != sequence)) {
 		que = NULL;
 	}
@@ -462,21 +361,7 @@ daemon_command_t *find_queue(unsigned lo
 	return (que);
 }
 
-/*++======================================================================*/
-int Daemon_Open_Control(struct inode *Inode, struct file *File)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_daemon_open_control(struct inode *Inode, struct file *File)
 {
 	DbgPrint("Daemon_Open_Control: pid=%d Count=%d\n", current->pid,
 		 atomic_read(&Daemon_Open_Count));
@@ -485,23 +370,9 @@ int Daemon_Open_Control(struct inode *In
 	return (0);
 }
 
-/*++======================================================================*/
-int Daemon_Close_Control(struct inode *Inode, struct file *File)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_daemon_close_control(struct inode *Inode, struct file *File)
 {
-	daemon_command_t *que;
+	struct daemon_cmd *que;
 
 	DbgPrint("Daemon_Close_Control: pid=%d Count=%d\n", current->pid,
 		 atomic_read(&Daemon_Open_Count));
@@ -512,39 +383,39 @@ int Daemon_Close_Control(struct inode *I
 		 */
 
 		spin_lock(&Daemon_Queue.lock);
-		que = (daemon_command_t *) Daemon_Queue.list.next;
+		que = (struct daemon_cmd *) Daemon_Queue.list.next;
 
 		while (que
-		       && (que != (daemon_command_t *) & Daemon_Queue.list.next)
+		       && (que != (struct daemon_cmd *) & Daemon_Queue.list.next)
 		       && (que->status != QUEUE_DONE)) {
 			que->status = QUEUE_TIMEOUT;
 			up(&que->semaphore);
 
-			que = (daemon_command_t *) que->list.next;
+			que = (struct daemon_cmd *) que->list.next;
 		}
 		spin_unlock(&Daemon_Queue.lock);
 
 		RemoveDriveMaps();
 
-		Scope_Cleanup();
+		novfs_scope_cleanup();
 	}
 
 	return (0);
 }
 
-ssize_t Daemon_Send_Command(struct file *file, char __user *buf, size_t len, loff_t * off)
+ssize_t novfs_daemon_cmd_send(struct file * file, char *buf, size_t len, loff_t * off)
 {
-	daemon_command_t *que;
+	struct daemon_cmd *que;
 	size_t retValue = 0;
 	int Finished = 0;
-	struct data_list *dlist;
+	struct novfs_data_list *dlist;
 	int i, dcnt, bcnt, ccnt, error;
 	char *vadr;
 	unsigned long cpylen;
 
 	DbgPrint("Daemon_Send_Command: %u %lld\n", len, *off);
-	if (len > MaxIoSize) {
-		MaxIoSize = len;
+	if (len > novfs_max_iosize) {
+		novfs_max_iosize = len;
 	}
 
 	while (!Finished) {
@@ -556,9 +427,9 @@ ssize_t Daemon_Send_Command(struct file
 				retValue = len;
 			}
 			if (retValue > 0x80)
-				mydump(0x80, que->request);
+				novfs_dump(0x80, que->request);
 			else
-				mydump(retValue, que->request);
+				novfs_dump(retValue, que->request);
 
 			cpylen = copy_to_user(buf, que->request, retValue);
 			if (que->datalen && (retValue < len)) {
@@ -599,10 +470,10 @@ ssize_t Daemon_Send_Command(struct file
 							    ("Daemon_Send_Command: Copy %d from 0x%p to 0x%p.\n",
 							     bcnt, vadr, buf);
 							if (bcnt > 0x80)
-								mydump(0x80,
+								novfs_dump(0x80,
 								       vadr);
 							else
-								mydump(bcnt,
+								novfs_dump(bcnt,
 								       vadr);
 
 							if (km_adr) {
@@ -646,14 +517,14 @@ ssize_t Daemon_Send_Command(struct file
 	return (retValue);
 }
 
-ssize_t Daemon_Receive_Reply(struct file *file, const char __user *buf, size_t nbytes, loff_t *ppos)
+ssize_t novfs_daemon_recv_reply(struct file *file, const char *buf, size_t nbytes, loff_t * ppos)
 {
-	daemon_command_t *que;
+	struct daemon_cmd *que;
 	size_t retValue = 0;
 	void *reply;
 	unsigned long sequence, cpylen;
 
-	struct data_list *dlist;
+	struct novfs_data_list *dlist;
 	char *vadr;
 	int i;
 
@@ -727,9 +598,9 @@ ssize_t Daemon_Receive_Reply(struct file
 								   thiscopy);
 
 						if (thiscopy > 0x80)
-							mydump(0x80, vadr);
+							novfs_dump(0x80, vadr);
 						else
-							mydump(thiscopy, vadr);
+							novfs_dump(thiscopy, vadr);
 
 						if (km_adr) {
 							kunmap(dlist->page);
@@ -743,17 +614,20 @@ ssize_t Daemon_Receive_Reply(struct file
 				que->replen = retValue;
 			} else {
 				reply = kmalloc(nbytes, GFP_KERNEL);
-				DbgPrint("Daemon_Receive_Reply: reply=0x%p\n", reply);
+				DbgPrint("Daemon_Receive_Reply: reply=0x%p\n",
+					 reply);
 				if (reply) {
 					retValue = nbytes;
 					que->reply = reply;
 					que->replen = nbytes;
 
-					retValue -= copy_from_user(reply, buf, retValue);
+					retValue -=
+					    copy_from_user(reply, buf,
+							   retValue);
 					if (retValue > 0x80)
-						mydump(0x80, reply);
+						novfs_dump(0x80, reply);
 					else
-						mydump(retValue, reply);
+						novfs_dump(retValue, reply);
 
 				} else {
 					retValue = -ENOMEM;
@@ -775,10 +649,11 @@ ssize_t Daemon_Receive_Reply(struct file
 	return (retValue);
 }
 
-int do_login(NclString *Server, NclString *Username, NclString *Password, HANDLE *lgnId, struct schandle *Session)
+int novfs_do_login(struct ncl_string *Server, struct ncl_string *Username,
+struct ncl_string *Password, void **lgnId, struct novfs_schandle *Session)
 {
-	PLOGIN_USER_REQUEST cmd;
-	PLOGIN_USER_REPLY reply;
+	struct novfs_login_user_request *cmd;
+	struct novfs_login_user_reply *reply;
 	unsigned long replylen = 0;
 	int retCode, cmdlen, datalen;
 	unsigned char *data;
@@ -812,8 +687,8 @@ int do_login(NclString *Server, NclStrin
 	memcpy(data, Password->buffer, Password->len);
 	data += Password->len;
 
-	retCode = Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
-				 &replylen, INTERRUPTIBLE);
+	retCode =	Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+								&replylen, INTERRUPTIBLE);
 	if (reply) {
 		if (reply->Reply.ErrorCode) {
 			retCode = reply->Reply.ErrorCode;
@@ -827,18 +702,18 @@ int do_login(NclString *Server, NclStrin
 	}
 	memset(cmd, 0, cmdlen);
 	kfree(cmd);
-	return retCode;
+	return (retCode);
 
 }
 
-int do_logout(struct qstr *Server, struct schandle *Session)
+int novfs_daemon_logout(struct qstr *Server, struct novfs_schandle *Session)
 {
-	PLOGOUT_REQUEST cmd;
-	PLOGOUT_REPLY reply;
+	struct novfs_logout_request *cmd;
+	struct novfs_logout_reply *reply;
 	unsigned long replylen = 0;
 	int retCode, cmdlen;
 
-	cmdlen = offsetof(LOGOUT_REQUEST, Name) + Server->len;
+	cmdlen = offsetof(struct novfs_logout_request, Name) + Server->len;
 	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
@@ -849,7 +724,8 @@ int do_logout(struct qstr *Server, struc
 	cmd->length = Server->len;
 	memcpy(cmd->Name, Server->name, Server->len);
 
-	retCode = Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
+	retCode =
+		Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
 	if (reply) {
 		if (reply->Reply.ErrorCode) {
 			retCode = -EIO;
@@ -861,24 +737,10 @@ int do_logout(struct qstr *Server, struc
 
 }
 
-/*++======================================================================*/
-int Daemon_getpwuid(uid_t uid, int unamelen, char *uname)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_daemon_getpwuid(uid_t uid, int unamelen, char *uname)
 {
-	GETPWUID_REQUEST cmd;
-	PGETPWUID_REPLY reply;
+	struct novfs_getpwuid_request cmd;
+	struct novfs_getpwuid_reply *reply;
 	unsigned long replylen = 0;
 	int retCode;
 
@@ -896,7 +758,9 @@ int Daemon_getpwuid(uid_t uid, int uname
 		} else {
 			retCode = 0;
 			memset(uname, 0, unamelen);
-			replylen = replylen - offsetof(GETPWUID_REPLY, UserName);
+			replylen =
+			    replylen - offsetof(struct
+					    novfs_getpwuid_reply, UserName);
 			if (replylen) {
 				if (replylen > unamelen) {
 					retCode = -EINVAL;
@@ -911,24 +775,10 @@ int Daemon_getpwuid(uid_t uid, int uname
 
 }
 
-/*++======================================================================*/
-int Daemon_getversion(char *Buf, int length)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_daemon_getversion(char *Buf, int length)
 {
-	GET_VERSION_REQUEST cmd;
-	PGET_VERSION_REPLY reply;
+	struct novfs_get_version_request cmd;
+	struct novfs_get_version_reply *reply;
 	unsigned long replylen = 0;
 	int retVal = 0;
 
@@ -942,7 +792,9 @@ int Daemon_getversion(char *Buf, int len
 		if (reply->Reply.ErrorCode) {
 			retVal = -EIO;
 		} else {
-			retVal = replylen - offsetof(GET_VERSION_REPLY, Version);
+			retVal =
+			    replylen - offsetof(struct
+					    novfs_get_version_reply, Version);
 			if (retVal < length) {
 				memcpy(Buf, reply->Version, retVal);
 				Buf[retVal] = '\0';
@@ -954,13 +806,13 @@ int Daemon_getversion(char *Buf, int len
 
 }
 
-static int daemon_login(struct login *Login, struct schandle *Session)
+static int daemon_login(struct novfs_login *Login, struct novfs_schandle *Session)
 {
 	int retCode = -ENOMEM;
-	struct login lLogin;
-	NclString server;
-	NclString username;
-	NclString password;
+	struct novfs_login lLogin;
+	struct ncl_string server;
+	struct ncl_string username;
+	struct ncl_string password;
 
 	if (!copy_from_user(&lLogin, Login, sizeof(lLogin))) {
 		server.buffer = kmalloc(lLogin.Server.length, GFP_KERNEL);
@@ -968,29 +820,29 @@ static int daemon_login(struct login *Lo
 			server.len = lLogin.Server.length;
 			server.type = NWC_STRING_TYPE_ASCII;
 			if (!copy_from_user((void *)server.buffer, lLogin.Server.data, server.len)) {
-				username.buffer = kmalloc(lLogin.UserName.length, GFP_KERNEL);
+				username.buffer =	kmalloc(lLogin.UserName.length,	GFP_KERNEL);
 				if (username.buffer) {
 					username.len = lLogin.UserName.length;
 					username.type = NWC_STRING_TYPE_ASCII;
 					if (!copy_from_user((void *)username.buffer, lLogin.UserName.data, username.len)) {
-						password.buffer = kmalloc(lLogin.Password.length, GFP_KERNEL);
-						if (password.buffer) {
+						password.buffer =	kmalloc(lLogin.Password.length,	GFP_KERNEL);
+						if (password.buffer)
+						{
 							password.len = lLogin.Password.length;
 							password.type = NWC_STRING_TYPE_ASCII;
 							if (!copy_from_user((void *)password.buffer, lLogin.Password.data, password.len)) {
-								retCode = do_login (&server, &username, &password, NULL, Session);
+								retCode = novfs_do_login (&server, &username, &password, NULL, Session);
 								if (!retCode) {
-									char *name;
-									name = Scope_Get_UserName();
-									if (name)
-										Novfs_Add_to_Root(name);
+									char *username;
+									username = novfs_scope_get_username();
+									if (username) {
+										novfs_add_to_root(username);
+									}
 								}
 							}
-							memset(password.buffer, 0, password.len);
 							kfree(password.buffer);
 						}
 					}
-					memset(username.buffer, 0, username.len);
 					kfree(username.buffer);
 				}
 			}
@@ -1001,32 +853,30 @@ static int daemon_login(struct login *Lo
 	return (retCode);
 }
 
-static int daemon_logout(struct logout *Logout, struct schandle *Session)
+static int daemon_logout(struct novfs_logout *Logout, struct novfs_schandle *Session)
 {
-	struct logout lLogout;
+	struct novfs_logout lLogout;
 	struct qstr server;
-	int retCode = -ENOMEM;
+	int retCode = 0;
 
 	if (copy_from_user(&lLogout, Logout, sizeof(lLogout)))
 		return -EFAULT;
-
 	server.name = kmalloc(lLogout.Server.length, GFP_KERNEL);
 	if (!server.name)
 		return -ENOMEM;
 	server.len = lLogout.Server.length;
 	if (copy_from_user((void *)server.name, lLogout.Server.data, server.len))
 		goto exit;
-
-	retCode = do_logout(&server, Session);
+	retCode = novfs_daemon_logout(&server, Session);
 exit:
 	kfree(server.name);
-	return retCode;
+	return (retCode);
 }
 
-int Daemon_CreateSessionId(struct schandle *SessionId)
+int novfs_daemon_create_sessionId(struct novfs_schandle * SessionId)
 {
-	CREATE_CONTEXT_REQUEST cmd;
-	PCREATE_CONTEXT_REPLY reply;
+	struct novfs_create_context_request cmd;
+	struct novfs_create_context_reply *reply;
 	unsigned long replylen = 0;
 	int retCode = 0;
 
@@ -1041,7 +891,7 @@ int Daemon_CreateSessionId(struct schand
 				 &replylen, INTERRUPTIBLE);
 	if (reply) {
 		if (!reply->Reply.ErrorCode
-		    && replylen > sizeof(COMMAND_REPLY_HEADER)) {
+		    && replylen > sizeof(struct novfs_command_reply_header)) {
 			*SessionId = reply->SessionId;
 			retCode = 0;
 		} else {
@@ -1055,26 +905,26 @@ int Daemon_CreateSessionId(struct schand
 	return (retCode);
 }
 
-int Daemon_DestroySessionId(struct schandle *SessionId)
+int novfs_daemon_destroy_sessionId(struct novfs_schandle SessionId)
 {
-	DESTROY_CONTEXT_REQUEST cmd;
-	PDESTROY_CONTEXT_REPLY reply;
+	struct novfs_destroy_context_request cmd;
+	struct novfs_destroy_context_reply *reply;
 	unsigned long replylen = 0;
 	int retCode = 0;
 
-	DbgPrint("Daemon_DestroySessionId: 0x%p:%p\n",
-		 SessionId->hTypeId, SessionId->hId);
+	DbgPrint("Daemon_DestroySessionId: 0x%p:%p\n", SessionId.hTypeId,
+		 SessionId.hId);
 
 	cmd.Command.CommandType = VFS_COMMAND_DESTROY_CONTEXT;
 	cmd.Command.SequenceNumber = 0;
-	memcpy(&cmd.Command.SessionId, SessionId, sizeof (*SessionId));
+	cmd.Command.SessionId = SessionId;
 
 	retCode =
 	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
 				 &replylen, INTERRUPTIBLE);
 	if (reply) {
 		if (!reply->Reply.ErrorCode) {
-			drive_map_t *dm;
+			struct drive_map *dm;
 			struct list_head *list;
 
 			retCode = 0;
@@ -1085,11 +935,8 @@ int Daemon_DestroySessionId(struct schan
 			 */
 			down(&DriveMapLock);
 			list_for_each(list, &DriveMapList) {
-				struct schandle *temp;
-
-				dm = list_entry(list, drive_map_t, list);
-				temp = &dm->session;
-				if (SC_EQUAL(SessionId, temp)) {
+				dm = list_entry(list, struct drive_map, list);
+				if (SC_EQUAL(SessionId, dm->session)) {
 					local_unlink(dm->name);
 					list = list->prev;
 					list_del(&dm->list);
@@ -1107,21 +954,21 @@ int Daemon_DestroySessionId(struct schan
 	return (retCode);
 }
 
-int Daemon_Get_UserSpace(struct schandle *SessionId, uint64_t * TotalSize,
+int novfs_daemon_get_userspace(struct novfs_schandle SessionId, uint64_t * TotalSize,
 			 uint64_t * Free, uint64_t * TotalEnties,
 			 uint64_t * FreeEnties)
 {
-	GET_USER_SPACE_REQUEST cmd;
-	PGET_USER_SPACE_REPLY reply;
+	struct novfs_get_user_space cmd;
+	struct novfs_get_user_space_reply *reply;
 	unsigned long replylen = 0;
 	int retCode = 0;
 
-	DbgPrint("Daemon_Get_UserSpace: 0x%p:%p\n",
-		 SessionId->hTypeId, SessionId->hId);
+	DbgPrint("Daemon_Get_UserSpace: 0x%p:%p\n", SessionId.hTypeId,
+		 SessionId.hId);
 
 	cmd.Command.CommandType = VFS_COMMAND_GET_USER_SPACE;
 	cmd.Command.SequenceNumber = 0;
-	memcpy(&cmd.Command.SessionId, SessionId, sizeof (*SessionId));
+	cmd.Command.SessionId = SessionId;
 
 	retCode =
 	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
@@ -1151,36 +998,22 @@ int Daemon_Get_UserSpace(struct schandle
 	return (retCode);
 }
 
-/*++======================================================================*/
-int Daemon_SetMountPoint(char *Path)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_daemon_set_mnt_point(char *Path)
 {
-	PSET_MOUNT_PATH_REQUEST cmd;
-	PSET_MOUNT_PATH_REPLY reply;
+	struct novfs_set_mount_path *cmd;
+	struct novfs_set_mount_path_reply *reply;
 	unsigned long replylen, cmdlen;
 	int retCode = -ENOMEM;
 
 	DbgPrint("Daemon_SetMountPoint: %s\n", Path);
 
 	replylen = strlen(Path);
-	cmdlen = sizeof(SET_MOUNT_PATH_REQUEST) + replylen;
+
+	cmdlen = sizeof(struct novfs_set_mount_path) + replylen;
 
 	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
-
 	cmd->Command.CommandType = VFS_COMMAND_SET_MOUNT_PATH;
 	cmd->Command.SequenceNumber = 0;
 	SC_INITIALIZE(cmd->Command.SessionId);
@@ -1190,7 +1023,9 @@ int Daemon_SetMountPoint(char *Path)
 
 	replylen = 0;
 
-	retCode = Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
+	retCode =
+		Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
+				&replylen, INTERRUPTIBLE);
 	if (reply) {
 		if (!reply->Reply.ErrorCode) {
 			retCode = 0;
@@ -1203,27 +1038,13 @@ int Daemon_SetMountPoint(char *Path)
 	return retCode;
 }
 
-/*++======================================================================*/
-int Daemon_SendDebugCmd(char *Command)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	DEBUG_REQUEST cmd;
-	PDEBUG_REPLY reply;
-	DEBUG_REPLY lreply;
+int novfs_daemon_debug_cmd_send(char *Command)
+{
+	struct novfs_debug_request cmd;
+	struct novfs_debug_reply *reply;
+	struct novfs_debug_reply lreply;
 	unsigned long replylen, cmdlen;
-	struct data_list dlist[2];
+	struct novfs_data_list dlist[2];
 
 	int retCode = -ENOMEM;
 
@@ -1239,7 +1060,7 @@ int Daemon_SendDebugCmd(char *Command)
 	dlist[1].len = sizeof(lreply);
 	dlist[1].rwflag = DLWRITE;
 
-	cmdlen = offsetof(DEBUG_REQUEST, dbgcmd);
+	cmdlen = offsetof(struct novfs_debug_request, dbgcmd);
 
 	cmd.Command.CommandType = VFS_COMMAND_DBG;
 	cmd.Command.SequenceNumber = 0;
@@ -1248,7 +1069,9 @@ int Daemon_SendDebugCmd(char *Command)
 
 	replylen = 0;
 
-	retCode = Queue_Daemon_Command(&cmd, cmdlen, dlist, 2, (void *)&reply, &replylen, INTERRUPTIBLE);
+	retCode =
+	    Queue_Daemon_Command(&cmd, cmdlen, dlist, 2, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
 	if (reply) {
 		kfree(reply);
 	}
@@ -1259,21 +1082,20 @@ int Daemon_SendDebugCmd(char *Command)
 	return (retCode);
 }
 
-int Daemon_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+int novfs_daemon_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int retCode = -ENOSYS;
 	unsigned long cpylen;
-	struct schandle session_id;
-
-	session_id = Scope_Get_SessionId(NULL);
+	struct novfs_schandle session_id;
+	session_id = novfs_scope_get_sessionId(NULL);
 
 	switch (cmd) {
 	case IOC_LOGIN:
-		retCode = daemon_login((struct login *)arg, &session_id);
+		retCode = daemon_login((struct novfs_login *) arg, &session_id);
 		break;
 
 	case IOC_LOGOUT:
-		retCode = daemon_logout((struct logout *) arg, &session_id);
+		retCode = daemon_logout((struct novfs_logout *)arg, &session_id);
 		break;
 	case IOC_DEBUGPRINT:
 		{
@@ -1302,7 +1124,7 @@ int Daemon_ioctl(struct inode *inode, st
 
 	case IOC_XPLAT:
 		{
-			XPLAT data;
+			struct novfs_xplat data;
 
 			cpylen =
 			    copy_from_user(&data, (void *)arg, sizeof(data));
@@ -1324,23 +1146,29 @@ int Daemon_ioctl(struct inode *inode, st
 	return (retCode);
 }
 
-int Daemon_Added_Resource(daemon_handle_t *DHandle, int Type, HANDLE CHandle, unsigned char *FHandle, unsigned long Mode, unsigned long Size)
+static int daemon_added_resource(struct daemon_handle * DHandle, int Type, void *CHandle,
+			  unsigned char * FHandle, unsigned long Mode, u_long Size)
 {
-	daemon_resource_t *resource;
+	struct daemon_resource *resource;
 
 	if (FHandle)
-		DbgPrint("Daemon_Added_Resource: DHandle=0x%p Type=%d CHandle=0x%p FHandle=0x%x Mode=0x%x Size=%d\n", DHandle, Type, CHandle, *(u32 *) & FHandle[2], Mode, Size);
+		DbgPrint
+		    ("Daemon_Added_Resource: DHandle=0x%p Type=%d CHandle=0x%p FHandle=0x%x Mode=0x%x Size=%d\n",
+		     DHandle, Type, CHandle, *(u32 *) & FHandle[2], Mode, Size);
 	else
-		DbgPrint("Daemon_Added_Resource: DHandle=0x%p Type=%d CHandle=0x%p\n", DHandle, Type, CHandle);
+		DbgPrint
+		    ("Daemon_Added_Resource: DHandle=0x%p Type=%d CHandle=0x%p\n",
+		     DHandle, Type, CHandle);
 
-	resource = kmalloc(sizeof(daemon_resource_t), GFP_KERNEL);
+	resource = kmalloc(sizeof(struct daemon_resource), GFP_KERNEL);
 	if (!resource)
 		return -ENOMEM;
 
 	resource->type = Type;
 	resource->connection = CHandle;
 	if (FHandle)
-		memcpy(resource->handle, FHandle, sizeof(resource->handle));
+		memcpy(resource->handle, FHandle,
+				sizeof(resource->handle));
 	else
 		memset(resource->handle, 0, sizeof(resource->handle));
 	resource->mode = Mode;
@@ -1348,29 +1176,15 @@ int Daemon_Added_Resource(daemon_handle_
 	write_lock(&DHandle->lock);
 	list_add(&resource->list, &DHandle->list);
 	write_unlock(&DHandle->lock);
-	DbgPrint("Daemon_Added_Resource: Adding resource=0x%p\n", resource);
-
+	DbgPrint("Daemon_Added_Resource: Adding resource=0x%p\n",
+			resource);
 	return 0;
 }
 
-/*++======================================================================*/
-int Daemon_Remove_Resource(daemon_handle_t * DHandle, int Type, HANDLE CHandle,
+static int daemon_remove_resource(struct daemon_handle * DHandle, int Type, void *CHandle,
 			   unsigned long FHandle)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
-	daemon_resource_t *resource;
+	struct daemon_resource *resource;
 	struct list_head *l;
 	int retVal = -ENOMEM;
 
@@ -1381,7 +1195,7 @@ int Daemon_Remove_Resource(daemon_handle
 	write_lock(&DHandle->lock);
 
 	list_for_each(l, &DHandle->list) {
-		resource = list_entry(l, daemon_resource_t, list);
+		resource = list_entry(l, struct daemon_resource, list);
 
 		if ((Type == resource->type) &&
 		    (resource->connection == CHandle)) {
@@ -1400,76 +1214,59 @@ int Daemon_Remove_Resource(daemon_handle
 	return (retVal);
 }
 
-int Daemon_Library_open(struct inode *inode, struct file *file)
+int novfs_daemon_lib_open(struct inode *inode, struct file *file)
 {
-	daemon_handle_t *dh;
+	struct daemon_handle *dh;
 
 	DbgPrint("Daemon_Library_open: inode=0x%p file=0x%p\n", inode, file);
-
-	dh = kmalloc(sizeof(daemon_handle_t), GFP_KERNEL);
+	dh = kmalloc(sizeof(struct daemon_handle), GFP_KERNEL);
 	if (!dh)
 		return -ENOMEM;
-
 	file->private_data = dh;
 	INIT_LIST_HEAD(&dh->list);
 	rwlock_init(&dh->lock);
-	dh->session = Scope_Get_SessionId(NULL);
-
+	dh->session = novfs_scope_get_sessionId(NULL);
 	return 0;
 }
 
-/*++======================================================================*/
-int Daemon_Library_close(struct inode *inode, struct file *file)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_daemon_lib_close(struct inode *inode, struct file *file)
 {
-	daemon_handle_t *dh;
-	daemon_resource_t *resource;
+	struct daemon_handle *dh;
+	struct daemon_resource *resource;
 	struct list_head *l;
 
-	char commanddata[sizeof(XPLAT_CALL_REQUEST) + sizeof(NwdCCloseConn)];
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	PNwdCCloseConn nwdClose;
+	char commanddata[sizeof(struct novfs_xplat_call_request) + sizeof(struct nwd_close_conn)];
+	struct novfs_xplat_call_request *cmd;
+	struct xplat_call_reply *reply;
+	struct nwd_close_conn *nwdClose;
 	unsigned long cmdlen, replylen;
 
 	DbgPrint("Daemon_Library_close: inode=0x%p file=0x%p\n", inode, file);
 	if (file->private_data) {
-		dh = (daemon_handle_t *) file->private_data;
+		dh = (struct daemon_handle *) file->private_data;
 
 		list_for_each(l, &dh->list) {
-			resource = list_entry(l, daemon_resource_t, list);
+			resource = list_entry(l, struct daemon_resource, list);
 
 			if (DH_TYPE_STREAM == resource->type) {
-				Novfs_Close_Stream(resource->connection,
+				novfs_close_stream(resource->connection,
 						   resource->handle,
 						   dh->session);
 			} else if (DH_TYPE_CONNECTION == resource->type) {
-				cmd = (PXPLAT_CALL_REQUEST) commanddata;
+				cmd = (struct novfs_xplat_call_request *) commanddata;
 				cmdlen =
-				    offsetof(XPLAT_CALL_REQUEST,
-					     data) + sizeof(NwdCCloseConn);
+				    offsetof(struct novfs_xplat_call_request,
+					     data) + sizeof(struct nwd_close_conn);
 				cmd->Command.CommandType =
 				    VFS_COMMAND_XPLAT_CALL;
 				cmd->Command.SequenceNumber = 0;
 				cmd->Command.SessionId = dh->session;
 				cmd->NwcCommand = NWC_CLOSE_CONN;
 
-				cmd->dataLen = sizeof(NwdCCloseConn);
-				nwdClose = (PNwdCCloseConn) cmd->data;
+				cmd->dataLen = sizeof(struct nwd_close_conn);
+				nwdClose = (struct nwd_close_conn *) cmd->data;
 				nwdClose->ConnHandle =
-				    (HANDLE) resource->connection;
+				    (void *) resource->connection;
 
 				Queue_Daemon_Command((void *)cmd, cmdlen, NULL,
 						     0, (void **)&reply,
@@ -1488,10 +1285,11 @@ int Daemon_Library_close(struct inode *i
 	return (0);
 }
 
-ssize_t Daemon_Library_read(struct file *file, char __user *buf, size_t len, loff_t *off)
+ssize_t novfs_daemon_lib_read(struct file * file, char *buf, size_t len,
+			    loff_t * off)
 {
-	daemon_handle_t *dh;
-	daemon_resource_t *resource;
+	struct daemon_handle *dh;
+	struct daemon_resource *resource;
 
 	size_t thisread, totalread = 0;
 	loff_t offset = *off;
@@ -1504,12 +1302,12 @@ ssize_t Daemon_Library_read(struct file
 		read_lock(&dh->lock);
 		if (&dh->list != dh->list.next) {
 			resource =
-			    list_entry(dh->list.next, daemon_resource_t, list);
+			    list_entry(dh->list.next, struct daemon_resource, list);
 
 			if (DH_TYPE_STREAM == resource->type) {
 				while (len > 0 && (offset < resource->size)) {
 					thisread = len;
-					if (Novfs_Read_Stream
+					if (novfs_read_stream
 					    (resource->connection,
 					     resource->handle, buf, &thisread,
 					     &offset, 1, dh->session)
@@ -1530,10 +1328,11 @@ ssize_t Daemon_Library_read(struct file
 	return (totalread);
 }
 
-ssize_t Daemon_Library_write(struct file *file, const char __user *buf, size_t len, loff_t *off)
+ssize_t novfs_daemon_lib_write(struct file * file, const char *buf, size_t len,
+			     loff_t * off)
 {
-	daemon_handle_t *dh;
-	daemon_resource_t *resource;
+	struct daemon_handle *dh;
+	struct daemon_resource *resource;
 
 	size_t thiswrite, totalwrite = -EINVAL;
 	loff_t offset = *off;
@@ -1547,14 +1346,14 @@ ssize_t Daemon_Library_write(struct file
 		write_lock(&dh->lock);
 		if (&dh->list != dh->list.next) {
 			resource =
-			    list_entry(dh->list.next, daemon_resource_t, list);
+			    list_entry(dh->list.next, struct daemon_resource, list);
 
 			if ((DH_TYPE_STREAM == resource->type) && (len >= 0)) {
 				totalwrite = 0;
 				do {
 					thiswrite = len;
 					status =
-					    Novfs_Write_Stream(resource->
+					    novfs_write_stream(resource->
 							       connection,
 							       resource->handle,
 							       (void *)buf,
@@ -1590,24 +1389,10 @@ ssize_t Daemon_Library_write(struct file
 	return (totalwrite);
 }
 
-/*++======================================================================*/
-loff_t Daemon_Library_llseek(struct file * file, loff_t offset, int origin)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+loff_t novfs_daemon_lib_llseek(struct file * file, loff_t offset, int origin)
 {
-	daemon_handle_t *dh;
-	daemon_resource_t *resource;
+	struct daemon_handle *dh;
+	struct daemon_resource *resource;
 
 	loff_t retVal = -EINVAL;
 
@@ -1619,7 +1404,7 @@ loff_t Daemon_Library_llseek(struct file
 		read_lock(&dh->lock);
 		if (&dh->list != dh->list.next) {
 			resource =
-			    list_entry(dh->list.next, daemon_resource_t, list);
+			    list_entry(dh->list.next, struct daemon_resource, list);
 
 			if (DH_TYPE_STREAM == resource->type) {
 				switch (origin) {
@@ -1646,11 +1431,11 @@ loff_t Daemon_Library_llseek(struct file
 	return retVal;
 }
 
-int Daemon_Library_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+int novfs_daemon_lib_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int retCode = -ENOSYS;
-	daemon_handle_t *dh;
-	HANDLE handle = NULL;
+	struct daemon_handle *dh;
+	void *handle = NULL;
 	unsigned long cpylen;
 
 	dh = file->private_data;
@@ -1662,11 +1447,11 @@ int Daemon_Library_ioctl(struct inode *i
 
 		switch (cmd) {
 		case IOC_LOGIN:
-			retCode = daemon_login((struct login *)arg, &dh->session);
+			retCode = daemon_login((struct novfs_login *)arg, &dh->session);
 			break;
 
 		case IOC_LOGOUT:
-			retCode = daemon_logout((struct logout *)arg, &dh->session);
+			retCode = daemon_logout((struct novfs_logout *)arg, &dh->session);
 			break;
 
 		case IOC_DEBUGPRINT:
@@ -1681,10 +1466,14 @@ int Daemon_Library_ioctl(struct inode *i
 				    copy_from_user(&io, (void *)arg,
 						   sizeof(io));
 				if (io.length) {
-					buf = kmalloc(io.length + 1, GFP_KERNEL);
+					buf =
+					    kmalloc(io.length + 1,
+							 GFP_KERNEL);
 					if (buf) {
 						buf[0] = 0;
-						cpylen = copy_from_user(buf, io.data, io.length);
+						cpylen =
+						    copy_from_user(buf, io.data,
+								   io.length);
 						buf[io.length] = '\0';
 						DbgPrint("%s", buf);
 						kfree(buf);
@@ -1696,7 +1485,7 @@ int Daemon_Library_ioctl(struct inode *i
 
 		case IOC_XPLAT:
 			{
-				XPLAT data;
+				struct novfs_xplat data;
 
 				cpylen =
 				    copy_from_user(&data, (void *)arg,
@@ -1707,61 +1496,79 @@ int Daemon_Library_ioctl(struct inode *i
 
 				switch (data.xfunction) {
 				case NWC_OPEN_CONN_BY_NAME:
-					DbgPrint("[VFS XPLAT] Call NwOpenConnByName\n");
-					retCode = NwOpenConnByName(&data, &handle, dh->session);
+					DbgPrint
+					    ("[VFS XPLAT] Call NwOpenConnByName\n");
+					retCode =
+					    novfs_open_conn_by_name(&data,
+						    &handle, dh->session);
 					if (!retCode)
-						Daemon_Added_Resource(dh, DH_TYPE_CONNECTION, handle, NULL, 0, 0);
+						daemon_added_resource(dh,
+								      DH_TYPE_CONNECTION,handle, 0, 0, 0);
 					break;
 
 				case NWC_OPEN_CONN_BY_ADDRESS:
-					DbgPrint("[VFS XPLAT] Call NwOpenConnByAddress\n");
-					retCode = NwOpenConnByAddr(&data, &handle, dh->session);
+					DbgPrint
+					    ("[VFS XPLAT] Call NwOpenConnByAddress\n");
+					retCode =
+					    novfs_open_conn_by_addr(&data, &handle,
+							     dh->session);
 					if (!retCode)
-						Daemon_Added_Resource(dh, DH_TYPE_CONNECTION, handle, NULL, 0, 0);
+						daemon_added_resource(dh,
+								      DH_TYPE_CONNECTION,
+								      handle, 0,
+								      0, 0);
 					break;
 
 				case NWC_OPEN_CONN_BY_REFERENCE:
-					DbgPrint("[VFS XPLAT] Call NwOpenConnByReference\n");
-					retCode = NwOpenConnByRef(&data, &handle, dh->session);
+
+					DbgPrint
+					    ("[VFS XPLAT] Call NwOpenConnByReference\n");
+					retCode =
+					    novfs_open_conn_by_ref(&data, &handle,
+							    dh->session);
 					if (!retCode)
-						Daemon_Added_Resource(dh,
+						daemon_added_resource(dh,
 								      DH_TYPE_CONNECTION,
-								      handle, NULL,
+								      handle, 0,
 								      0, 0);
 					break;
 
 				case NWC_SYS_CLOSE_CONN:
 					DbgPrint("[VFS XPLAT] Call NwSysCloseConn\n");
-					retCode = NwSysConnClose(&data, (unsigned long *)&handle, dh->session);
-					Daemon_Remove_Resource(dh, DH_TYPE_CONNECTION, handle, 0);
+					retCode =
+						novfs_sys_conn_close(&data, (unsigned long *)&handle, dh->session);
+					daemon_remove_resource(dh, DH_TYPE_CONNECTION, handle, 0);
 					break;
 
 				case NWC_CLOSE_CONN:
 					DbgPrint
 					    ("[VFS XPLAT] Call NwCloseConn\n");
 					retCode =
-					    NwConnClose(&data, &handle,
+					    novfs_conn_close(&data, &handle,
 							dh->session);
-					Daemon_Remove_Resource(dh,
+					daemon_remove_resource(dh,
 							       DH_TYPE_CONNECTION,
 							       handle, 0);
 					break;
 
 				case NWC_LOGIN_IDENTITY:
-					DbgPrint("[VFS XPLAT] Call NwLoginIdentity\n");
-					retCode = NwLoginIdentity(&data, &dh->session);
+					DbgPrint
+					    ("[VFS XPLAT] Call NwLoginIdentity\n");
+					retCode =
+					    novfs_login_id(&data, dh->session);
 					break;
 
 				case NWC_RAW_NCP_REQUEST:
-					DbgPrint("[VFS XPLAT] Send Raw NCP Request\n");
-					retCode = NwRawSend(&data, dh->session);
+					DbgPrint
+					    ("[VFS XPLAT] Send Raw NCP Request\n");
+					retCode = novfs_raw_send(&data, dh->session);
 					break;
 
 				case NWC_AUTHENTICATE_CONN_WITH_ID:
 					DbgPrint
 					    ("[VFS XPLAT] Authenticate Conn With ID\n");
 					retCode =
-					    NwAuthConnWithId(&data,
+					    novfs_auth_conn(&data,
 							     dh->session);
 					break;
 
@@ -1769,21 +1576,21 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] UnAuthenticate Conn With ID\n");
 					retCode =
-					    NwUnAuthenticate(&data,
+					    novfs_unauthenticate(&data,
 							     dh->session);
 					break;
 
 				case NWC_LICENSE_CONN:
 					DbgPrint("Call NwLicenseConn\n");
 					retCode =
-					    NwLicenseConn(&data, dh->session);
+					    novfs_license_conn(&data, dh->session);
 					break;
 
 				case NWC_LOGOUT_IDENTITY:
 					DbgPrint
 					    ("[VFS XPLAT] Call NwLogoutIdentity\n");
 					retCode =
-					    NwLogoutIdentity(&data,
+					    novfs_logout_id(&data,
 							     dh->session);
 					break;
 
@@ -1791,35 +1598,35 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwUnlicense\n");
 					retCode =
-					    NwUnlicenseConn(&data, dh->session);
+					    novfs_unlicense_conn(&data, dh->session);
 					break;
 
 				case NWC_GET_CONN_INFO:
 					DbgPrint
 					    ("[VFS XPLAT] Call NwGetConnInfo\n");
 					retCode =
-					    NwGetConnInfo(&data, dh->session);
+					    novfs_get_conn_info(&data, dh->session);
 					break;
 
 				case NWC_SET_CONN_INFO:
 					DbgPrint
 					    ("[VFS XPLAT] Call NwGetConnInfo\n");
 					retCode =
-					    NwSetConnInfo(&data, dh->session);
+					    novfs_set_conn_info(&data, dh->session);
 					break;
 
 				case NWC_SCAN_CONN_INFO:
 					DbgPrint
 					    ("[VFS XPLAT] Call NwScanConnInfo\n");
 					retCode =
-					    NwScanConnInfo(&data, dh->session);
+					    novfs_scan_conn_info(&data, dh->session);
 					break;
 
 				case NWC_GET_IDENTITY_INFO:
 					DbgPrint
 					    ("[VFS XPLAT] Call NwGetIdentityInfo\n");
 					retCode =
-					    NwGetIdentityInfo(&data,
+					    novfs_get_id_info(&data,
 							      dh->session);
 					break;
 
@@ -1827,7 +1634,7 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwGetDaemonVersion\n");
 					retCode =
-					    NwGetDaemonVersion(&data,
+					    novfs_get_daemon_ver(&data,
 							       dh->session);
 					break;
 
@@ -1835,7 +1642,7 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcGetPreferredDsTree\n");
 					retCode =
-					    NwcGetPreferredDSTree(&data,
+					    novfs_get_preferred_DS_tree(&data,
 								  dh->session);
 					break;
 
@@ -1843,7 +1650,7 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcSetPreferredDsTree\n");
 					retCode =
-					    NwcSetPreferredDSTree(&data,
+					    novfs_set_preferred_DS_tree(&data,
 								  dh->session);
 					break;
 
@@ -1851,7 +1658,7 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcGetDefaultNameContext\n");
 					retCode =
-					    NwcGetDefaultNameCtx(&data,
+					    novfs_get_default_ctx(&data,
 								 dh->session);
 					break;
 
@@ -1859,7 +1666,7 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcSetDefaultNameContext\n");
 					retCode =
-					    NwcSetDefaultNameCtx(&data,
+					    novfs_set_default_ctx(&data,
 								 dh->session);
 					break;
 
@@ -1867,14 +1674,14 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwQueryFeature\n");
 					retCode =
-					    NwQueryFeature(&data, dh->session);
+					    novfs_query_feature(&data, dh->session);
 					break;
 
 				case NWC_GET_TREE_MONITORED_CONN_REF:
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcGetTreeMonitoredConn\n");
 					retCode =
-					    NwcGetTreeMonitoredConn(&data,
+					    novfs_get_tree_monitored_conn(&data,
 								    dh->
 								    session);
 					break;
@@ -1883,7 +1690,7 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcEnumerateIdentities\n");
 					retCode =
-					    NwcEnumIdentities(&data,
+					    novfs_enum_ids(&data,
 							      dh->session);
 					break;
 
@@ -1891,7 +1698,7 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcChangeAuthKey\n");
 					retCode =
-					    NwcChangeAuthKey(&data,
+					    novfs_change_auth_key(&data,
 							     dh->session);
 					break;
 
@@ -1913,7 +1720,7 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcSetPrimaryConn\n");
 					retCode =
-					    NwcSetPrimaryConn(&data,
+					    novfs_set_pri_conn(&data,
 							      dh->session);
 					break;
 
@@ -1921,26 +1728,29 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcGetPrimaryConn\n");
 					retCode =
-					    NwcGetPrimaryConn(&data,
+					    novfs_get_pri_conn(&data,
 							      dh->session);
 					break;
 
 				case NWC_MAP_DRIVE:
-					DbgPrint("[VFS XPLAT] Call NwcMapDrive\n");
-					retCode = NwdSetMapDrive(&data, dh->session);
+					DbgPrint
+					    ("[VFS XPLAT] Call NwcMapDrive\n");
+					retCode =
+					    set_map_drive(&data, dh->session);
 					break;
 
 				case NWC_UNMAP_DRIVE:
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcUnMapDrive\n");
-					retCode = NwdUnMapDrive(&data, dh->session);
+					retCode =
+					    unmap_drive(&data, dh->session);
 					break;
 
 				case NWC_ENUMERATE_DRIVES:
 					DbgPrint
 					    ("[VFS XPLAT] Call NwcEnumerateDrives\n");
 					retCode =
-					    NwcEnumerateDrives(&data,
+					    novfs_enum_drives(&data,
 							       dh->session);
 					break;
 
@@ -1954,21 +1764,21 @@ int Daemon_Library_ioctl(struct inode *i
 					DbgPrint
 					    ("[VSF XPLAT Call NwdGetBroadcastMessage\n");
 					retCode =
-					    NwcGetBroadcastMessage(&data,
+					    novfs_get_bcast_msg(&data,
 								   dh->session);
 					break;
 
 				case NWC_SET_KEY:
 					DbgPrint("[VSF XPLAT Call NwdSetKey\n");
 					retCode =
-					    NwdSetKeyValue(&data, dh->session);
+					    novfs_set_key_value(&data, dh->session);
 					break;
 
 				case NWC_VERIFY_KEY:
 					DbgPrint
 					    ("[VSF XPLAT Call NwdVerifyKey\n");
 					retCode =
-					    NwdVerifyKeyValue(&data,
+					    novfs_verify_key_value(&data,
 							      dh->session);
 					break;
 
@@ -1991,9 +1801,10 @@ int Daemon_Library_ioctl(struct inode *i
 	return (retCode);
 }
 
-unsigned int Daemon_Poll(struct file *file, struct poll_table_struct *poll_table)
+unsigned int novfs_daemon_poll(struct file *file,
+			 struct poll_table_struct *poll_table)
 {
-	daemon_command_t *que;
+	struct daemon_cmd *que;
 	unsigned int mask = POLLOUT | POLLWRNORM;
 
 	que = get_next_queue(0);
@@ -2002,43 +1813,32 @@ unsigned int Daemon_Poll(struct file *fi
 	return mask;
 }
 
-int NwdConvertNetwareHandle(PXPLAT pdata, daemon_handle_t *DHandle)
+static int NwdConvertNetwareHandle(struct novfs_xplat *pdata, struct daemon_handle * DHandle)
 {
 	int retVal;
-	NwcConvertNetWareHandle nh;
+	struct nwc_convert_netware_handle nh;
 	unsigned long cpylen;
 
 	DbgPrint("NwdConvertNetwareHandle: DHandle=0x%p\n", DHandle);
 
-	cpylen = copy_from_user(&nh, pdata->reqData, sizeof(NwcConvertNetWareHandle));
+	cpylen =
+	    copy_from_user(&nh, pdata->reqData,
+			   sizeof(struct nwc_convert_netware_handle));
+
+	retVal =
+	    daemon_added_resource(DHandle, DH_TYPE_STREAM,
+				  Uint32toHandle(nh.ConnHandle),
+				  nh.NetWareHandle, nh.uAccessMode,
+				  nh.uFileSize);
 
-	retVal = Daemon_Added_Resource(DHandle, DH_TYPE_STREAM,
-				       Uint32toHandle(nh.ConnHandle),
-				       nh.NetWareHandle, nh.uAccessMode,
-				       nh.uFileSize);
-
-	return retVal;
+	return (retVal);
 }
 
-/*++======================================================================*/
-int NwdConvertLocalHandle(PXPLAT pdata, daemon_handle_t * DHandle)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+static int NwdConvertLocalHandle(struct novfs_xplat *pdata, struct daemon_handle * DHandle)
 {
 	int retVal = NWE_REQUESTER_FAILURE;
-	daemon_resource_t *resource;
-	NwcConvertLocalHandle lh;
+	struct daemon_resource *resource;
+	struct nwc_convert_local_handle lh;
 	struct list_head *l;
 	unsigned long cpylen;
 
@@ -2047,7 +1847,7 @@ int NwdConvertLocalHandle(PXPLAT pdata,
 	read_lock(&DHandle->lock);
 
 	list_for_each(l, &DHandle->list) {
-		resource = list_entry(l, daemon_resource_t, list);
+		resource = list_entry(l, struct daemon_resource, list);
 
 		if (DH_TYPE_STREAM == resource->type) {
 			lh.uConnReference =
@@ -2055,10 +1855,10 @@ int NwdConvertLocalHandle(PXPLAT pdata,
 
 //sgled         memcpy(lh.NwWareHandle, resource->handle, sizeof(resource->handle));
 			memcpy(lh.NetWareHandle, resource->handle, sizeof(resource->handle));	//sgled
-			if (pdata->repLen >= sizeof(NwcConvertLocalHandle)) {
+			if (pdata->repLen >= sizeof(struct nwc_convert_local_handle)) {
 				cpylen =
 				    copy_to_user(pdata->repData, &lh,
-						 sizeof(NwcConvertLocalHandle));
+						 sizeof(struct nwc_convert_local_handle));
 				retVal = 0;
 			} else {
 				retVal = NWE_BUFFER_OVERFLOW;
@@ -2072,39 +1872,25 @@ int NwdConvertLocalHandle(PXPLAT pdata,
 	return (retVal);
 }
 
-/*++======================================================================*/
-int NwdGetMountPath(PXPLAT pdata)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+static int NwdGetMountPath(struct novfs_xplat *pdata)
 {
 	int retVal = NWE_REQUESTER_FAILURE;
 	int len;
 	unsigned long cpylen;
-	NwcGetMountPath mp;
+	struct nwc_get_mount_path mp;
 
 	cpylen = copy_from_user(&mp, pdata->reqData, pdata->reqLen);
 
-	if (Novfs_CurrentMount) {
+	if (novfs_current_mnt) {
 
-		len = strlen(Novfs_CurrentMount) + 1;
+		len = strlen(novfs_current_mnt) + 1;
 		if ((len > mp.MountPathLen) && mp.pMountPath) {
 			retVal = NWE_BUFFER_OVERFLOW;
 		} else {
 			if (mp.pMountPath) {
 				cpylen =
 				    copy_to_user(mp.pMountPath,
-						 Novfs_CurrentMount, len);
+						 novfs_current_mnt, len);
 			}
 			retVal = 0;
 		}
@@ -2119,52 +1905,55 @@ int NwdGetMountPath(PXPLAT pdata)
 	return (retVal);
 }
 
-static int NwdSetMapDrive(PXPLAT pdata, session_t Session)
+static int set_map_drive(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
 	int retVal;
-	NwcMapDriveEx symInfo;
+	unsigned long cpylen;
+	struct nwc_map_drive_ex symInfo;
 	char *path;
-	drive_map_t *drivemap, *dm;
+	struct drive_map *drivemap, *dm;
 	struct list_head *list;
 
-	retVal = NwcSetMapDrive(pdata, Session);
+	retVal = novfs_set_map_drive(pdata, Session);
 	if (retVal)
 		return retVal;
-
 	if (copy_from_user(&symInfo, pdata->reqData, sizeof(symInfo)))
 		return -EFAULT;
-
-	drivemap = kmalloc(sizeof(drive_map_t) + symInfo.linkOffsetLength, GFP_KERNEL);
+	drivemap =
+		kmalloc(sizeof(struct drive_map) + symInfo.linkOffsetLength,
+				GFP_KERNEL);
 	if (!drivemap)
 		return -ENOMEM;
 
 	path = (char *)pdata->reqData;
 	path += symInfo.linkOffset;
-	if (copy_from_user(drivemap->name, path, symInfo.linkOffsetLength)) {
-		kfree(drivemap);
-		return -EFAULT;
-	}
+	cpylen =
+		copy_from_user(drivemap->name, path,
+				symInfo.linkOffsetLength);
 
 	drivemap->session = Session;
-	drivemap->hash = full_name_hash(drivemap->name, symInfo.linkOffsetLength - 1);
+	drivemap->hash =
+		full_name_hash(drivemap->name,
+				symInfo.linkOffsetLength - 1);
 	drivemap->namelen = symInfo.linkOffsetLength - 1;
-	DbgPrint("NwdSetMapDrive: hash=0x%x path=%s\n", drivemap->hash, drivemap->name);
+	DbgPrint("NwdSetMapDrive: hash=0x%x path=%s\n",
+			drivemap->hash, drivemap->name);
 
-	dm = (drive_map_t *) & DriveMapList.next;
+	dm = (struct drive_map *) & DriveMapList.next;
 
 	down(&DriveMapLock);
 
 	list_for_each(list, &DriveMapList) {
-		dm = list_entry(list, drive_map_t, list);
+		dm = list_entry(list, struct drive_map, list);
 		DbgPrint("NwdSetMapDrive: dm=0x%p\n"
-			 "   hash:    0x%x\n"
-			 "   namelen: %d\n"
-			 "   name:    %s\n",
-			 dm, dm->hash, dm->namelen, dm->name);
+				"   hash:    0x%x\n"
+				"   namelen: %d\n"
+				"   name:    %s\n",
+				dm, dm->hash, dm->namelen, dm->name);
 
 		if (drivemap->hash == dm->hash) {
 			if (0 ==
-			    strcmp(dm->name, drivemap->name)) {
+					strcmp(dm->name, drivemap->name)) {
 				dm = NULL;
 				break;
 			}
@@ -2174,59 +1963,57 @@ static int NwdSetMapDrive(PXPLAT pdata,
 	}
 
 	if (dm) {
-		if ((dm == (drive_map_t *) & DriveMapList) ||
-		    (dm->hash < drivemap->hash)) {
+		if ((dm == (struct drive_map *) & DriveMapList) ||
+				(dm->hash < drivemap->hash)) {
 			list_add(&drivemap->list, &dm->list);
 		} else {
 			list_add_tail(&drivemap->list,
-				      &dm->list);
+					&dm->list);
 		}
-	} else {
-		kfree(drivemap);
 	}
+	kfree(drivemap);
 	up(&DriveMapLock);
-
 	return (retVal);
 }
 
-static int NwdUnMapDrive(PXPLAT pdata, session_t Session)
+static int unmap_drive(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
 	int retVal = NWE_REQUESTER_FAILURE;
-	NwcUnmapDriveEx symInfo;
+	struct nwc_unmap_drive_ex symInfo;
 	char *path;
-	drive_map_t *dm;
+	struct drive_map *dm;
 	struct list_head *list;
 	unsigned long hash;
 
-	retVal = NwcUnMapDrive(pdata, Session);
+
+	retVal = novfs_unmap_drive(pdata, Session);
 	if (retVal)
 		return retVal;
-
 	if (copy_from_user(&symInfo, pdata->reqData, sizeof(symInfo)))
 		return -EFAULT;
 
 	path = kmalloc(symInfo.linkLen, GFP_KERNEL);
 	if (!path)
 		return -ENOMEM;
-
-	if (copy_from_user(path, ((NwcUnmapDriveEx *)pdata->reqData)->linkData, symInfo.linkLen)) {
+	if (copy_from_user(path,((struct nwc_unmap_drive_ex *) pdata->reqData)->linkData, symInfo.linkLen)) {
 		kfree(path);
 		return -EFAULT;
 	}
 
 	hash = full_name_hash(path, symInfo.linkLen - 1);
-	DbgPrint("NwdUnMapDrive: hash=0x%x path=%s\n", hash, path);
+	DbgPrint("NwdUnMapDrive: hash=0x%x path=%s\n", hash,
+			path);
 
 	dm = NULL;
 
 	down(&DriveMapLock);
 
 	list_for_each(list, &DriveMapList) {
-		dm = list_entry(list, drive_map_t, list);
+		dm = list_entry(list, struct drive_map, list);
 		DbgPrint("NwdUnMapDrive: dm=0x%p %s\n"
-			 "   hash:    0x%x\n"
-			 "   namelen: %d\n",
-			 dm, dm->name, dm->hash, dm->namelen);
+				"   hash:    0x%x\n"
+				"   namelen: %d\n",
+				dm, dm->name, dm->hash, dm->namelen);
 
 		if (hash == dm->hash) {
 			if (0 == strcmp(dm->name, path)) {
@@ -2240,40 +2027,25 @@ static int NwdUnMapDrive(PXPLAT pdata, s
 
 	if (dm) {
 		DbgPrint("NwdUnMapDrive: Remove dm=0x%p %s\n"
-			 "   hash:    0x%x\n"
-			 "   namelen: %d\n",
-			 dm, dm->name, dm->hash, dm->namelen);
+				"   hash:    0x%x\n"
+				"   namelen: %d\n",
+				dm, dm->name, dm->hash, dm->namelen);
 		list_del(&dm->list);
 		kfree(dm);
 	}
 
 	up(&DriveMapLock);
-
-	return retVal;
+	return (retVal);
 }
 
-/*++======================================================================*/
-void RemoveDriveMaps(void)
-/*
- *
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+static void RemoveDriveMaps(void)
 {
-	drive_map_t *dm;
+	struct drive_map *dm;
 	struct list_head *list;
 
 	down(&DriveMapLock);
 	list_for_each(list, &DriveMapList) {
-		dm = list_entry(list, drive_map_t, list);
+		dm = list_entry(list, struct drive_map, list);
 
 		DbgPrint("RemoveDriveMap: dm=0x%p\n"
 			 "   hash:    0x%x\n"
@@ -2288,9 +2060,7 @@ void RemoveDriveMaps(void)
 	up(&DriveMapLock);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
-/*++======================================================================*/
-int local_unlink(const char *pathname)
+static int local_unlink(const char *pathname)
 {
 	int error;
 	struct dentry *dentry;
@@ -2341,60 +2111,3 @@ int local_unlink(const char *pathname)
 	return error;
 }
 
-#else
-/*++======================================================================*/
-int local_unlink(const char *pathname)
-{
-	int error;
-	struct dentry *dentry;
-	struct nameidata nd;
-	struct inode *inode = NULL;
-
-	DbgPrint("local_unlink: %s\n", pathname);
-	error = path_lookup(pathname, LOOKUP_PARENT, &nd);
-	DbgPrint("local_unlink: path_lookup %d\n", error);
-	if (!error) {
-		error = -EISDIR;
-		if (nd.last_type == LAST_NORM) {
-			down(&nd.dentry->d_inode->i_sem);
-			dentry =
-			    lookup_one_len(&nd.last, nd.dentry,
-					   sizeof(nd.last));
-			DbgPrint("local_unlink: lookup_hash 0x%p\n", dentry);
-
-			error = PTR_ERR(dentry);
-			if (!IS_ERR(dentry)) {
-				if (nd.last.name[nd.last.len]) {
-					error =
-					    !dentry->
-					    d_inode ? -ENOENT : S_ISDIR(dentry->
-									d_inode->
-									i_mode)
-					    ? -EISDIR : -ENOTDIR;
-				} else {
-					inode = dentry->d_inode;
-					if (inode) {
-						atomic_inc(&inode->i_count);
-					}
-					error =
-					    vfs_unlink(nd.dentry->d_inode,
-						       dentry);
-					DbgPrint
-					    ("local_unlink: vfs_unlink %d\n",
-					     error);
-				}
-				dput(dentry);
-			}
-			up(&nd.dentry->d_inode->i_sem);
-		}
-		path_release(&nd);
-	}
-
-	if (inode) {
-		iput(inode);	/* truncate the inode here */
-	}
-
-	DbgPrint("local_unlink: error=%d\n", error);
-	return error;
-}
-#endif
--- a/fs/novfs/file.c
+++ b/fs/novfs/file.c
@@ -27,35 +27,11 @@
 #include "commands.h"
 #include "nwerror.h"
 
-/*===[ Function prototypes ]==============================================*/
-int Novfs_get_alltrees(struct dentry *parent);
-ssize_t Novfs_tree_read(struct file *file, char *buf, size_t len, loff_t * off);
-
-int Novfs_Find_Name_In_List(struct qstr *Name, unsigned char * List);
-
-int Novfs_Create(unsigned char * Path, int DirectoryFlag, session_t SessionId);
-int Novfs_Close_File(HANDLE Handle, session_t SessionId);
-int Novfs_Read_File(HANDLE Handle, unsigned char * Buffer, size_t * Bytes,
-		    loff_t * Offset, session_t SessionId);
-int Novfs_Write_File(HANDLE Handle, unsigned char * Buffer, size_t * Bytes,
-		     loff_t * Offset, session_t SessionId);
-int Novfs_Write_Page(HANDLE Handle, struct page *Page, session_t SessionId);
-int Novfs_Read_Stream(HANDLE ConnHandle, unsigned char * Handle, unsigned char * Buffer,
-		      size_t * Bytes, loff_t * Offset, int User,
-		      session_t SessionId);
-int Novfs_Write_Stream(HANDLE ConnHandle, unsigned char * Handle, unsigned char * Buffer,
-		       size_t * Bytes, loff_t * Offset, session_t SessionId);
-int Novfs_Close_Stream(HANDLE ConnHandle, unsigned char * Handle, session_t SessionId);
-int Novfs_Delete(unsigned char * Path, int DirectoryFlag, session_t SessionId);
-int Novfs_Truncate_File(unsigned char * Path, int PathLen, session_t SessionId);
-int Novfs_Truncate_File_Ex(HANDLE Handle, loff_t Offset, session_t SessionId);
-int Novfs_Rename_File(int DirectoryFlag, unsigned char * OldName, int OldLen,
-		      unsigned char * NewName, int NewLen, session_t SessionId);
-int Novfs_Set_Attr(unsigned char * Path, struct iattr *Attr, session_t SessionId);
-int Novfs_Get_File_Cache_Flag(unsigned char * Path, session_t SessionId);
+static ssize_t novfs_tree_read(struct file * file, char *buf, size_t len, loff_t * off);
+extern struct dentry_operations novfs_dentry_operations;
 
-static struct file_operations Novfs_tree_operations = {
-      read:Novfs_tree_read,
+static struct file_operations novfs_tree_operations = {
+      read:novfs_tree_read,
 };
 
 /*
@@ -65,12 +41,12 @@ static struct file_operations Novfs_tree
  */
 static int StripTrailingDots = 1;
 
-int Novfs_get_alltrees(struct dentry *parent)
+int novfs_get_alltrees(struct dentry *parent)
 {
 	unsigned char *p;
-	PCOMMAND_REPLY_HEADER reply = NULL;
+	struct novfs_command_reply_header * reply = NULL;
 	unsigned long replylen = 0;
-	COMMAND_REQUEST_HEADER cmd;
+	struct novfs_command_request_header cmd;
 	int retCode;
 	struct dentry *entry;
 	struct qstr name;
@@ -81,30 +57,30 @@ int Novfs_get_alltrees(struct dentry *pa
 //sg ???   cmd.SessionId = 0x1234;
 	SC_INITIALIZE(cmd.SessionId);
 
-	DbgPrint("Novfs_get_alltrees:\n");
+	DbgPrint("novfs_get_alltrees:\n");
 
 	retCode = Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
-	DbgPrint("Novfs_get_alltrees: relpy=0x%p replylen=%d\n", reply,
+	DbgPrint("novfs_get_alltrees: relpy=0x%p replylen=%d\n", reply,
 		 replylen);
 	if (reply) {
-		mydump(replylen, reply);
+		novfs_dump(replylen, reply);
 		if (!reply->ErrorCode
-		    && (replylen > sizeof(COMMAND_REPLY_HEADER))) {
+		    && (replylen > sizeof(struct novfs_command_reply_header))) {
 			p = (char *)reply + 8;
 			while (*p) {
-				DbgPrint("Novfs_get_alltrees: %s\n", p);
+				DbgPrint("novfs_get_alltrees: %s\n", p);
 				name.len = strlen(p);
 				name.name = p;
 				name.hash = full_name_hash(name.name, name.len);
 				entry = d_lookup(parent, &name);
 				if (NULL == entry) {
-					DbgPrint("Novfs_get_alltrees: adding %s\n", p);
+					DbgPrint("novfs_get_alltrees: adding %s\n", p);
 					entry = d_alloc(parent, &name);
 					if (entry) {
-						entry->d_op = &Novfs_dentry_operations;
-						inode = Novfs_get_inode(parent->d_sb, S_IFREG | 0400, 0, 0, 0, &name);
+						entry->d_op = &novfs_dentry_operations;
+						inode = novfs_get_inode(parent->d_sb, S_IFREG | 0400, 0, 0, 0, &name);
 						if (inode) {
-							inode->i_fop = &Novfs_tree_operations;
+							inode->i_fop = &novfs_tree_operations;
 							d_add(entry, inode);
 						}
 					}
@@ -117,7 +93,7 @@ int Novfs_get_alltrees(struct dentry *pa
 	return (retCode);
 }
 
-ssize_t Novfs_tree_read(struct file * file, char *buf, size_t len, loff_t * off)
+static ssize_t novfs_tree_read(struct file * file, char *buf, size_t len, loff_t * off)
 {
 	if (file->f_pos != 0) {
 		return (0);
@@ -128,24 +104,24 @@ ssize_t Novfs_tree_read(struct file * fi
 	return (5);
 }
 
-int Novfs_Get_Connected_Server_List(unsigned char ** ServerList, struct schandle *SessionId)
+int novfs_get_servers(unsigned char ** ServerList, struct novfs_schandle SessionId)
 {
-	GET_CONNECTED_SERVER_LIST_REQUEST req;
-	PGET_CONNECTED_SERVER_LIST_REPLY reply = NULL;
+	struct novfs_get_connected_server_list req;
+	struct novfs_get_connected_server_list_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode = 0;
 
 	*ServerList = NULL;
 
 	req.Command.CommandType = VFS_COMMAND_GET_CONNECTED_SERVER_LIST;
-	memcpy(&req.Command.SessionId, SessionId, sizeof(*SessionId));
+	req.Command.SessionId = SessionId;
 
 	retCode =
 	    Queue_Daemon_Command(&req, sizeof(req), NULL, 0, (void *)&reply,
 				 &replylen, INTERRUPTIBLE);
 	if (reply) {
-		DbgPrint("Novfs_Get_Connected_Server_List: reply\n");
-		replylen -= sizeof(COMMAND_REPLY_HEADER);
+		DbgPrint("novfs_Get_Connected_Server_List: reply\n");
+		replylen -= sizeof(struct novfs_command_reply_header);
 		if (!reply->Reply.ErrorCode && replylen) {
 			memcpy(reply, reply->List, replylen);
 			*ServerList = (unsigned char *) reply;
@@ -158,30 +134,31 @@ int Novfs_Get_Connected_Server_List(unsi
 	return (retCode);
 }
 
-int Novfs_Get_Server_Volume_List(struct qstr *Server, unsigned char ** VolumeList,
-				 struct schandle *SessionId)
+int novfs_get_vols(struct qstr *Server, unsigned char ** VolumeList,
+				 struct novfs_schandle SessionId)
 {
-	PGET_SERVER_VOLUME_LIST_REQUEST req;
-	PGET_SERVER_VOLUME_LIST_REPLY reply = NULL;
+	struct novfs_get_server_volume_list *req;
+	struct novfs_get_server_volume_list_reply *reply = NULL;
 	unsigned long replylen = 0, reqlen;
 	int retCode;
 
 	*VolumeList = NULL;
-	reqlen = sizeof(GET_SERVER_VOLUME_LIST_REQUEST) + Server->len;
+	reqlen = sizeof(struct novfs_get_server_volume_list) + Server->len;
 	req = kmalloc(reqlen, GFP_KERNEL);
 	if (!req)
 		return -ENOMEM;
 	req->Command.CommandType = VFS_COMMAND_GET_SERVER_VOLUME_LIST;
 	req->Length = Server->len;
 	memcpy(req->Name, Server->name, Server->len);
-	memcpy(&req->Command.SessionId, SessionId, sizeof(*SessionId));
+	req->Command.SessionId = SessionId;
 
-	retCode = Queue_Daemon_Command(req, reqlen, NULL, 0, (void *)&reply,
-					 &replylen, INTERRUPTIBLE);
+	retCode =
+		Queue_Daemon_Command(req, reqlen, NULL, 0, (void *)&reply,
+				&replylen, INTERRUPTIBLE);
 	if (reply) {
-		DbgPrint("Novfs_Get_Server_Volume_List: reply\n");
-		mydump(replylen, reply);
-		replylen -= sizeof(COMMAND_REPLY_HEADER);
+		DbgPrint("novfs_Get_Server_Volume_List: reply\n");
+		novfs_dump(replylen, reply);
+		replylen -= sizeof(struct novfs_command_reply_header);
 
 		if (!reply->Reply.ErrorCode && replylen) {
 			memcpy(reply, reply->List, replylen);
@@ -193,35 +170,19 @@ int Novfs_Get_Server_Volume_List(struct
 		}
 	}
 	kfree(req);
-	return retCode;
-}
-
-int Novfs_Find_Name_In_List(struct qstr *Name, unsigned char * List)
-{
-	int len;
-	int retCode = 0;
-
-	while (*List) {
-		len = strlen(List);
-		if ((len == Name->len) && !strncmp(Name->name, List, len)) {
-			retCode = 1;
-			break;
-		}
-		List += (len + 1);
-	}
 	return (retCode);
 }
 
-int Novfs_Get_File_Info(unsigned char * Path, struct entry_info *Info, struct schandle *SessionId)
+int novfs_get_file_info(unsigned char * Path, struct novfs_entry_info * Info, struct novfs_schandle SessionId)
 {
-	PVERIFY_FILE_REPLY reply = NULL;
+	struct novfs_verify_file_reply *reply = NULL;
 	unsigned long replylen = 0;
-	PVERIFY_FILE_REQUEST cmd;
+	struct novfs_verify_file_request * cmd;
 	int cmdlen;
 	int retCode = -ENOENT;
 	int pathlen;
 
-	DbgPrint("%s: Path = %s\n", __func__, Path);
+	DbgPrint("novfs_Get_File_Info: Path = %s\n", Path);
 
 	Info->mode = S_IFDIR | 0700;
 	Info->uid = current->uid;
@@ -235,12 +196,12 @@ int Novfs_Get_File_Info(unsigned char *
 			if ('.' == Path[pathlen - 1])
 				pathlen--;
 		}
-		cmdlen = offsetof(VERIFY_FILE_REQUEST, path) + pathlen;
-		cmd = (PVERIFY_FILE_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+		cmdlen = offsetof(struct novfs_verify_file_request,path) + pathlen;
+		cmd = kmalloc(cmdlen, GFP_KERNEL);
 		if (cmd) {
 			cmd->Command.CommandType = VFS_COMMAND_VERIFY_FILE;
 			cmd->Command.SequenceNumber = 0;
-			memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+			cmd->Command.SessionId = SessionId;
 			cmd->pathLen = pathlen;
 			memcpy(cmd->path, Path, cmd->pathLen);
 
@@ -279,11 +240,18 @@ int Novfs_Get_File_Info(unsigned char *
 					Info->mtime.tv_nsec = 0;
 					Info->ctime.tv_sec = reply->createTime;
 					Info->ctime.tv_nsec = 0;
-					DbgPrint("%s: replylen=%d sizeof(VERIFY_FILE_REPLY)=%d\n", __func__, replylen, sizeof(VERIFY_FILE_REPLY));
-					if (replylen > sizeof(VERIFY_FILE_REPLY)) {
-						unsigned int *lp = &reply->fileMode;
+					DbgPrint
+					    ("novfs_Get_File_Info: replylen=%d sizeof(VERIFY_FILE_REPLY)=%d\n",
+					     replylen,
+					     sizeof(struct novfs_verify_file_reply));
+					if (replylen >
+					    sizeof(struct novfs_verify_file_reply)) {
+						unsigned int *lp =
+						    &reply->fileMode;
 						lp++;
-						DbgPrint("%s: extra data 0x%x\n", __func__, *lp);
+						DbgPrint
+						    ("novfs_Get_File_Info: extra data 0x%x\n",
+						     *lp);
 						Info->mtime.tv_nsec = *lp;
 					}
 					retCode = 0;
@@ -295,35 +263,37 @@ int Novfs_Get_File_Info(unsigned char *
 		}
 	}
 
-	DbgPrint("%s: return 0x%x\n", __func__, retCode);
+	DbgPrint("novfs_Get_File_Info: return 0x%x\n", retCode);
 	return (retCode);
 }
 
-int Novfs_GetX_File_Info(char *Path, const char *Name, char *buffer,
+int novfs_getx_file_info(char *Path, const char *Name, char *buffer,
 			 ssize_t buffer_size, ssize_t * dataLen,
-			 session_t *SessionId)
+			 struct novfs_schandle SessionId)
 {
-	PXA_GET_REPLY reply = NULL;
+	struct novfs_xa_get_reply *reply = NULL;
 	unsigned long replylen = 0;
-	PXA_GET_REQUEST cmd;
+	struct novfs_xa_get_request *cmd;
 	int cmdlen;
 	int retCode = -ENOENT;
 
 	int namelen = strlen(Name);
 	int pathlen = strlen(Path);
 
-	DbgPrint("%s: xattr: Path = %s, pathlen = %i, Name = %s, namelen = %i\n", __func__, Path, pathlen, Name, namelen);
+	DbgPrint
+	    ("novfs_GetX_File_Info xattr: Path = %s, pathlen = %i, Name = %s, namelen = %i\n",
+	     Path, pathlen, Name, namelen);
 
 	if (namelen > MAX_XATTR_NAME_LEN) {
 		return ENOATTR;
 	}
 
-	cmdlen = offsetof(XA_GET_REQUEST, data) + pathlen + 1 + namelen + 1;	// two '\0'
-	cmd = (PXA_GET_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmdlen = offsetof(struct novfs_xa_get_request, data) + pathlen + 1 + namelen + 1;	// two '\0'
+	cmd = (struct novfs_xa_get_request *) kmalloc(cmdlen, GFP_KERNEL);
 	if (cmd) {
 		cmd->Command.CommandType = VFS_COMMAND_GET_EXTENDED_ATTRIBUTE;
 		cmd->Command.SequenceNumber = 0;
-		memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+		cmd->Command.SessionId = SessionId;
 
 		cmd->pathLen = pathlen;
 		memcpy(cmd->data, Path, cmd->pathLen + 1);	//+ '\0'
@@ -331,14 +301,20 @@ int Novfs_GetX_File_Info(char *Path, con
 		cmd->nameLen = namelen;
 		memcpy(cmd->data + cmd->pathLen + 1, Name, cmd->nameLen + 1);
 
-		DbgPrint("%s xattr: PXA_GET_REQUEST BEGIN\n", __func__);
-		DbgPrint("%s xattr: Queue_Daemon_Command %d\n", __func__, cmd->Command.CommandType);
-		DbgPrint("%s xattr: Command.SessionId = %d\n", __func__, cmd->Command.SessionId);
-		DbgPrint("%s xattr: pathLen = %d\n", __func__, cmd->pathLen);
-		DbgPrint("%s xattr: Path = %s\n", __func__, cmd->data);
-		DbgPrint("%s xattr: nameLen = %d\n", __func__, cmd->nameLen);
-		DbgPrint("%s xattr: name = %s\n", __func__, (cmd->data + cmd->pathLen + 1));
-		DbgPrint("%s xattr: PXA_GET_REQUEST END\n", __func__);
+		DbgPrint("novfs_GetX_File_Info xattr: PXA_GET_REQUEST BEGIN\n");
+		DbgPrint
+		    ("novfs_GetX_File_Info xattr: Queue_Daemon_Command %d\n",
+		     cmd->Command.CommandType);
+		DbgPrint("novfs_GetX_File_Info xattr: Command.SessionId = %d\n",
+			 cmd->Command.SessionId);
+		DbgPrint("novfs_GetX_File_Info xattr: pathLen = %d\n",
+			 cmd->pathLen);
+		DbgPrint("novfs_GetX_File_Info xattr: Path = %s\n", cmd->data);
+		DbgPrint("novfs_GetX_File_Info xattr: nameLen = %d\n",
+			 cmd->nameLen);
+		DbgPrint("novfs_GetX_File_Info xattr: name = %s\n",
+			 (cmd->data + cmd->pathLen + 1));
+		DbgPrint("novfs_GetX_File_Info xattr: PXA_GET_REQUEST END\n");
 
 		retCode =
 		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
@@ -347,8 +323,13 @@ int Novfs_GetX_File_Info(char *Path, con
 		if (reply) {
 
 			if (reply->Reply.ErrorCode) {
-				DbgPrint("%s xattr: reply->Reply.ErrorCode=%d, %X\n", __func__, reply->Reply.ErrorCode, reply->Reply.ErrorCode);
-				DbgPrint("%s xattr: replylen=%d\n", __func__, replylen);
+				DbgPrint
+				    ("novfs_GetX_File_Info xattr: reply->Reply.ErrorCode=%d, %X\n",
+				     reply->Reply.ErrorCode,
+				     reply->Reply.ErrorCode);
+				DbgPrint
+				    ("novfs_GetX_File_Info xattr: replylen=%d\n",
+				     replylen);
 
 				//0xC9 = EA not found (C9), 0xD1 = EA access denied
 				if ((reply->Reply.ErrorCode == 0xC9)
@@ -360,26 +341,32 @@ int Novfs_GetX_File_Info(char *Path, con
 			} else {
 
 				*dataLen =
-				    replylen - sizeof(COMMAND_REPLY_HEADER);
-				DbgPrint("%s xattr: replylen=%u, dataLen=%u\n", __func__, replylen, *dataLen);
+				    replylen - sizeof(struct novfs_command_reply_header);
+				DbgPrint
+				    ("novfs_GetX_File_Info xattr: replylen=%u, dataLen=%u\n",
+				     replylen, *dataLen);
 
 				if (buffer_size >= *dataLen) {
-					DbgPrint("%s xattr: copying to buffer from &reply->pData\n", __func__);
+					DbgPrint
+					    ("novfs_GetX_File_Info xattr: copying to buffer from &reply->pData\n");
 					memcpy(buffer, &reply->pData, *dataLen);
 
 					retCode = 0;
 				} else {
-					DbgPrint("%s xattr: (!!!) buffer is smaller then reply\n", __func__);
+					DbgPrint
+					    ("novfs_GetX_File_Info xattr: (!!!) buffer is smaller then reply\n");
 					retCode = -ERANGE;
 				}
-				DbgPrint("%s xattr: /dumping buffer\n", __func__);
-				mydump(*dataLen, buffer);
-				DbgPrint("%s xattr: \\after dumping buffer\n", __func__);
+				DbgPrint
+				    ("novfs_GetX_File_Info xattr: /dumping buffer\n");
+				novfs_dump(*dataLen, buffer);
+				DbgPrint
+				    ("novfs_GetX_File_Info xattr: \\after dumping buffer\n");
 			}
 
 			kfree(reply);
 		} else {
-			DbgPrint("%s xattr: reply = NULL\n", __func__);
+			DbgPrint("novfs_GetX_File_Info xattr: reply = NULL\n");
 		}
 		kfree(cmd);
 
@@ -388,32 +375,33 @@ int Novfs_GetX_File_Info(char *Path, con
 	return retCode;
 }
 
-int Novfs_SetX_File_Info(char *Path, const char *Name, const void *Value,
+int novfs_setx_file_info(char *Path, const char *Name, const void *Value,
 			 unsigned long valueLen, unsigned long *bytesWritten,
-			 int flags, struct schandle *SessionId)
+			 int flags, struct novfs_schandle SessionId)
 {
-	PXA_SET_REPLY reply = NULL;
+	struct novfs_xa_set_reply *reply = NULL;
 	unsigned long replylen = 0;
-	PXA_SET_REQUEST cmd;
+	struct novfs_xa_set_request *cmd;
 	int cmdlen;
 	int retCode = -ENOENT;
 
 	int namelen = strlen(Name);
 	int pathlen = strlen(Path);
 
-	DbgPrint("%s xattr: Path = %s, pathlen = %i, Name = %s, namelen = %i, value len = %u\n", __func__,
+	DbgPrint
+	    ("novfs_SetX_File_Info xattr: Path = %s, pathlen = %i, Name = %s, namelen = %i, value len = %u\n",
 	     Path, pathlen, Name, namelen, valueLen);
 
 	if (namelen > MAX_XATTR_NAME_LEN) {
 		return ENOATTR;
 	}
 
-	cmdlen = offsetof(XA_SET_REQUEST, data) + pathlen + 1 + namelen + 1 + valueLen;
-	cmd = (PXA_SET_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmdlen = offsetof(struct novfs_xa_set_request, data) + pathlen + 1 + namelen + 1 + valueLen;
+	cmd = (struct novfs_xa_set_request *) kmalloc(cmdlen, GFP_KERNEL);
 	if (cmd) {
 		cmd->Command.CommandType = VFS_COMMAND_SET_EXTENDED_ATTRIBUTE;
 		cmd->Command.SequenceNumber = 0;
-		memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+		cmd->Command.SessionId = SessionId;
 
 		cmd->flags = flags;
 		cmd->pathLen = pathlen;
@@ -426,16 +414,22 @@ int Novfs_SetX_File_Info(char *Path, con
 		memcpy(cmd->data + cmd->pathLen + 1 + cmd->nameLen + 1, Value,
 		       valueLen);
 
-		DbgPrint("%s xattr: PXA_SET_REQUEST BEGIN\n", __func__);
-		DbgPrint("%s xattr: Queue_Daemon_Command %d\n", __func__, cmd->Command.CommandType);
-		DbgPrint("%s xattr: Command.SessionId = %d\n", __func__, cmd->Command.SessionId);
-		DbgPrint("%s xattr: pathLen = %d\n", __func__, cmd->pathLen);
-		DbgPrint("%s xattr: Path = %s\n", __func__, cmd->data);
-		DbgPrint("%s xattr: nameLen = %d\n", __func__, cmd->nameLen);
-		DbgPrint("%s xattr: name = %s\n", __func__, (cmd->data + cmd->pathLen + 1));
-		mydump(valueLen < 16 ? valueLen : 16, (char *)Value);
+		DbgPrint("novfs_SetX_File_Info xattr: PXA_SET_REQUEST BEGIN\n");
+		DbgPrint
+		    ("novfs_SetX_File_Info xattr: Queue_Daemon_Command %d\n",
+		     cmd->Command.CommandType);
+		DbgPrint("novfs_SetX_File_Info xattr: Command.SessionId = %d\n",
+			 cmd->Command.SessionId);
+		DbgPrint("novfs_SetX_File_Info xattr: pathLen = %d\n",
+			 cmd->pathLen);
+		DbgPrint("novfs_SetX_File_Info xattr: Path = %s\n", cmd->data);
+		DbgPrint("novfs_SetX_File_Info xattr: nameLen = %d\n",
+			 cmd->nameLen);
+		DbgPrint("novfs_SetX_File_Info xattr: name = %s\n",
+			 (cmd->data + cmd->pathLen + 1));
+		novfs_dump(valueLen < 16 ? valueLen : 16, (char *)Value);
 
-		DbgPrint("%s xattr: PXA_SET_REQUEST END\n", __func__);
+		DbgPrint("novfs_SetX_File_Info xattr: PXA_SET_REQUEST END\n");
 
 		retCode =
 		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
@@ -444,22 +438,30 @@ int Novfs_SetX_File_Info(char *Path, con
 		if (reply) {
 
 			if (reply->Reply.ErrorCode) {
-				DbgPrint("%s xattr: reply->Reply.ErrorCode=%d, %X\n", __func__, reply->Reply.ErrorCode, reply->Reply.ErrorCode);
-				DbgPrint("%s xattr: replylen=%d\n", __func__, replylen);
+				DbgPrint
+				    ("novfs_SetX_File_Info xattr: reply->Reply.ErrorCode=%d, %X\n",
+				     reply->Reply.ErrorCode,
+				     reply->Reply.ErrorCode);
+				DbgPrint
+				    ("novfs_SetX_File_Info xattr: replylen=%d\n",
+				     replylen);
 
 				retCode = -reply->Reply.ErrorCode;	//-ENOENT;
 			} else {
 
-				DbgPrint("%s xattr: replylen=%u, real len = %u\n", __func__, replylen, replylen - sizeof(COMMAND_REPLY_HEADER));
+				DbgPrint
+				    ("novfs_SetX_File_Info xattr: replylen=%u, real len = %u\n",
+				     replylen,
+				     replylen - sizeof(struct novfs_command_reply_header));
 				memcpy(bytesWritten, &reply->pData,
-				       replylen - sizeof(COMMAND_REPLY_HEADER));
+				       replylen - sizeof(struct novfs_command_reply_header));
 
 				retCode = 0;
 			}
 
 			kfree(reply);
 		} else {
-			DbgPrint("%s xattr: reply = NULL\n", __func__);
+			DbgPrint("novfs_SetX_File_Info xattr: reply = NULL\n");
 		}
 		kfree(cmd);
 
@@ -468,32 +470,41 @@ int Novfs_SetX_File_Info(char *Path, con
 	return retCode;
 }
 
-int Novfs_ListX_File_Info(char *Path, char *buffer, ssize_t buffer_size, ssize_t * dataLen, struct schandle *SessionId)
+int novfs_listx_file_info(char *Path, char *buffer, ssize_t buffer_size,
+			  ssize_t * dataLen, struct novfs_schandle SessionId)
 {
-	PXA_LIST_REPLY reply = NULL;
+	struct novfs_xa_list_reply *reply = NULL;
 	unsigned long replylen = 0;
-	PVERIFY_FILE_REQUEST cmd;
+	struct novfs_verify_file_request *cmd;
 	int cmdlen;
 	int retCode = -ENOENT;
 
 	int pathlen = strlen(Path);
-	DbgPrint("%s xattr: Path = %s, pathlen = %i\n", __func__, Path, pathlen);
+	DbgPrint("novfs_ListX_File_Info xattr: Path = %s, pathlen = %i\n", Path,
+		 pathlen);
 
 	*dataLen = 0;
-	cmdlen = offsetof(VERIFY_FILE_REQUEST, path) + pathlen;
-	cmd = (PVERIFY_FILE_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmdlen = offsetof(struct novfs_verify_file_request, path) + pathlen;
+	cmd = (struct novfs_verify_file_request *) kmalloc(cmdlen, GFP_KERNEL);
 	if (cmd) {
 		cmd->Command.CommandType = VFS_COMMAND_LIST_EXTENDED_ATTRIBUTES;
 		cmd->Command.SequenceNumber = 0;
-		memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+		cmd->Command.SessionId = SessionId;
 		cmd->pathLen = pathlen;
 		memcpy(cmd->path, Path, cmd->pathLen + 1);	//+ '\0'
-		DbgPrint("%s xattr: PVERIFY_FILE_REQUEST BEGIN\n", __func__);
-		DbgPrint("%s xattr: Queue_Daemon_Command %d\n", __func__, cmd->Command.CommandType);
-		DbgPrint("%s xattr: Command.SessionId = %d\n", __func__, cmd->Command.SessionId);
-		DbgPrint("%s xattr: pathLen = %d\n", __func__, cmd->pathLen);
-		DbgPrint("%s xattr: Path = %s\n", __func__, cmd->path);
-		DbgPrint("%s xattr: PVERIFY_FILE_REQUEST END\n", __func__);
+		DbgPrint
+		    ("novfs_ListX_File_Info xattr: PVERIFY_FILE_REQUEST BEGIN\n");
+		DbgPrint
+		    ("novfs_ListX_File_Info xattr: Queue_Daemon_Command %d\n",
+		     cmd->Command.CommandType);
+		DbgPrint
+		    ("novfs_ListX_File_Info xattr: Command.SessionId = %d\n",
+		     cmd->Command.SessionId);
+		DbgPrint("novfs_ListX_File_Info xattr: pathLen = %d\n",
+			 cmd->pathLen);
+		DbgPrint("novfs_ListX_File_Info xattr: Path = %s\n", cmd->path);
+		DbgPrint
+		    ("novfs_ListX_File_Info xattr: PVERIFY_FILE_REQUEST END\n");
 
 		retCode =
 		    Queue_Daemon_Command(cmd, cmdlen, NULL, 0, (void *)&reply,
@@ -502,31 +513,43 @@ int Novfs_ListX_File_Info(char *Path, ch
 		if (reply) {
 
 			if (reply->Reply.ErrorCode) {
-				DbgPrint("%s xattr: reply->Reply.ErrorCode=%d, %X\n", __func__, reply->Reply.ErrorCode, reply->Reply.ErrorCode);
-				DbgPrint("%s xattr: replylen=%d\n", __func__, replylen);
+				DbgPrint
+				    ("novfs_ListX_File_Info xattr: reply->Reply.ErrorCode=%d, %X\n",
+				     reply->Reply.ErrorCode,
+				     reply->Reply.ErrorCode);
+				DbgPrint
+				    ("novfs_ListX_File_Info xattr: replylen=%d\n",
+				     replylen);
 
 				retCode = -ENOENT;
 			} else {
-				*dataLen = replylen - sizeof(COMMAND_REPLY_HEADER);
-				DbgPrint("%s xattr: replylen=%u, dataLen=%u\n", __func__, replylen, *dataLen);
+				*dataLen =
+				    replylen - sizeof(struct novfs_command_reply_header);
+				DbgPrint
+				    ("novfs_ListX_File_Info xattr: replylen=%u, dataLen=%u\n",
+				     replylen, *dataLen);
 
 				if (buffer_size >= *dataLen) {
-					DbgPrint("%s xattr: copying to buffer from &reply->pData\n", __func__);
+					DbgPrint
+					    ("novfs_ListX_File_Info xattr: copying to buffer from &reply->pData\n");
 					memcpy(buffer, &reply->pData, *dataLen);
 				} else {
-					DbgPrint("%s xattr: (!!!) buffer is smaller then reply\n", __func__);
+					DbgPrint
+					    ("novfs_ListX_File_Info xattr: (!!!) buffer is smaller then reply\n");
 					retCode = -ERANGE;
 				}
-				DbgPrint("%s xattr: /dumping buffer\n", __func__);
-				mydump(*dataLen, buffer);
-				DbgPrint("%s xattr: \\after dumping buffer\n", __func__);
+				DbgPrint
+				    ("novfs_ListX_File_Info xattr: /dumping buffer\n");
+				novfs_dump(*dataLen, buffer);
+				DbgPrint
+				    ("novfs_ListX_File_Info xattr: \\after dumping buffer\n");
 
 				retCode = 0;
 			}
 
 			kfree(reply);
 		} else {
-			DbgPrint("%s xattr: reply = NULL\n", __func__);
+			DbgPrint("novfs_ListX_File_Info xattr: reply = NULL\n");
 		}
 		kfree(cmd);
 
@@ -535,21 +558,23 @@ int Novfs_ListX_File_Info(char *Path, ch
 	return retCode;
 }
 
-static int begin_directory_enumerate(unsigned char *Path, int PathLen, HANDLE *EnumHandle, struct schandle *SessionId)
+static int begin_directory_enumerate(unsigned char * Path, int PathLen, void ** EnumHandle,
+			      struct novfs_schandle SessionId)
 {
-	PBEGIN_ENUMERATE_DIRECTORY_REQUEST cmd;
-	PBEGIN_ENUMERATE_DIRECTORY_REPLY reply = NULL;
+	struct novfs_begin_enumerate_directory_request *cmd;
+	struct novfs_begin_enumerate_directory_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode, cmdlen;
 
 	*EnumHandle = 0;
 
-	cmdlen = offsetof(BEGIN_ENUMERATE_DIRECTORY_REQUEST, path) + PathLen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmdlen = offsetof(struct
+			novfs_begin_enumerate_directory_request, path) + PathLen;
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (cmd) {
 		cmd->Command.CommandType = VFS_COMMAND_START_ENUMERATE;
 		cmd->Command.SequenceNumber = 0;
-		memcpy(&cmd->Command.SessionId, SessionId, sizeof(*SessionId));
+		cmd->Command.SessionId = SessionId;
 
 		cmd->pathLen = PathLen;
 		memcpy(cmd->path, Path, PathLen);
@@ -576,16 +601,16 @@ static int begin_directory_enumerate(uns
 	return (retCode);
 }
 
-static int end_directory_enumerate(HANDLE EnumHandle, struct schandle *SessionId)
+static int end_directory_enumerate(void *EnumHandle, struct novfs_schandle SessionId)
 {
-	END_ENUMERATE_DIRECTORY_REQUEST cmd;
-	PEND_ENUMERATE_DIRECTORY_REPLY reply = NULL;
+	struct novfs_end_enumerate_directory_request cmd;
+	struct novfs_end_enumerate_directory_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode;
 
 	cmd.Command.CommandType = VFS_COMMAND_END_ENUMERATE;
 	cmd.Command.SequenceNumber = 0;
-	copy_session_id(&cmd.Command.SessionId, SessionId);
+	cmd.Command.SessionId = SessionId;
 
 	cmd.enumerateHandle = EnumHandle;
 
@@ -603,95 +628,24 @@ static int end_directory_enumerate(HANDL
 	return (retCode);
 }
 
-int directory_enumerate(HANDLE * EnumHandle, struct entry_info *Info,
-			session_t SessionId)
+static int directory_enumerate_ex(void ** EnumHandle, struct novfs_schandle SessionId, int *Count,
+			   struct novfs_entry_info **PInfo, int Interrupt)
 {
-	ENUMERATE_DIRECTORY_REQUEST cmd;
-	PENUMERATE_DIRECTORY_REPLY reply = NULL;
-	unsigned long replylen = 0;
-	int retCode;
-
-	cmd.Command.CommandType = VFS_COMMAND_ENUMERATE_DIRECTORY;
-	cmd.Command.SequenceNumber = 0;
-	cmd.Command.SessionId = SessionId;
-
-	cmd.enumerateHandle = *EnumHandle;
-	cmd.pathLen = 0;
-	cmd.path[0] = '\0';
-
-	retCode =
-	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
-				 &replylen, INTERRUPTIBLE);
-
-	if (reply) {
-		/*
-		 * The VFS_COMMAND_ENUMERATE_DIRECTORY call can return an
-		 * error but there could still be valid data.
-		 */
-		if (!reply->Reply.ErrorCode ||
-		    ((replylen > sizeof(COMMAND_REPLY_HEADER)) &&
-		     (reply->nameLen > 0))) {
-			Info->type = 3;
-			Info->mode = S_IRWXU;
-
-			if (reply->mode & NW_ATTRIBUTE_DIRECTORY) {
-				Info->mode |= S_IFDIR;
-				Info->mode |= S_IXUSR;
-			} else {
-				Info->mode |= S_IFREG;
-			}
-
-			if (reply->mode & NW_ATTRIBUTE_READ_ONLY) {
-				Info->mode &= ~(S_IWUSR);
-			}
-
-			if (reply->mode & NW_ATTRIBUTE_EXECUTE) {
-				Info->mode |= S_IXUSR;
-			}
-
-			Info->uid = current->uid;
-			Info->gid = current->gid;
-			Info->size = reply->size;
-			Info->atime.tv_sec = reply->lastAccessTime;
-			Info->atime.tv_nsec = 0;
-			Info->mtime.tv_sec = reply->modifyTime;
-			Info->mtime.tv_nsec = 0;
-			Info->ctime.tv_sec = reply->createTime;
-			Info->ctime.tv_nsec = 0;
-			Info->namelength = reply->nameLen;
-			memcpy(Info->name, reply->name, reply->nameLen);
-			retCode = 0;
-			if (reply->Reply.ErrorCode) {
-				retCode = -1;	/* Eof of data */
-			}
-			*EnumHandle = reply->enumerateHandle;
-		} else {
-			retCode = -ENODATA;
-		}
-		kfree(reply);
-	}
-
-	return (retCode);
-}
-
-static int directory_enumerate_ex(HANDLE *EnumHandle, struct schandle *SessionId, int *Count, struct entry_info **PInfo, int Interrupt)
-{
-	ENUMERATE_DIRECTORY_EX_REQUEST cmd;
-	PENUMERATE_DIRECTORY_EX_REPLY reply = NULL;
+	struct novfs_enumerate_directory_ex_request cmd;
+	struct novfs_enumerate_directory_ex_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode = 0;
-	struct entry_info *info;
-	PENUMERATE_DIRECTORY_EX_DATA data;
+	struct novfs_entry_info * info;
+	struct novfs_enumerate_directory_ex_data *data;
 	int isize;
 
-	if (PInfo) {
+	if (PInfo)
 		*PInfo = NULL;
-	}
 	*Count = 0;
 
 	cmd.Command.CommandType = VFS_COMMAND_ENUMERATE_DIRECTORY_EX;
 	cmd.Command.SequenceNumber = 0;
-	copy_session_id(&cmd.Command.SessionId, SessionId);
+	cmd.Command.SessionId = SessionId;
 
 	cmd.enumerateHandle = *EnumHandle;
 	cmd.pathLen = 0;
@@ -709,57 +663,92 @@ static int directory_enumerate_ex(HANDLE
 		 */
 
 		if (!reply->Reply.ErrorCode ||
-		    ((replylen > sizeof(COMMAND_REPLY_HEADER)) &&
+		    ((replylen > sizeof(struct novfs_command_reply_header)) &&
 		     (reply->enumCount > 0))) {
 			DbgPrint("directory_enumerate_ex: isize=%d\n",
 				 replylen);
-			data = (PENUMERATE_DIRECTORY_EX_DATA) ((char *)reply + sizeof(ENUMERATE_DIRECTORY_EX_REPLY));
-			isize = replylen - sizeof(PENUMERATE_DIRECTORY_EX_REPLY) - reply->enumCount * offsetof(ENUMERATE_DIRECTORY_EX_DATA, name);
-			isize += (reply->enumCount * offsetof(struct entry_info, name));
+			data =
+			    (struct novfs_enumerate_directory_ex_data *) ((char *)reply +
+							    sizeof
+							    (struct novfs_enumerate_directory_ex_reply));
+			isize =
+			    replylen - sizeof(struct novfs_enumerate_directory_ex_reply *) -
+			    reply->enumCount *
+			    offsetof(struct
+					    novfs_enumerate_directory_ex_data, name);
+			isize +=
+			    (reply->enumCount *
+			     offsetof(struct novfs_entry_info, name));
 
 			if (PInfo) {
-				*PInfo = info = Novfs_Malloc(isize, GFP_KERNEL);
+				*PInfo = info = kmalloc(isize, GFP_KERNEL);
 				if (*PInfo) {
-					DbgPrint("directory_enumerate_ex1: data=0x%p info=0x%p\n", data, info);
+					DbgPrint
+					    ("directory_enumerate_ex1: data=0x%p info=0x%p\n",
+					     data, info);
 					*Count = reply->enumCount;
 					do {
-						DbgPrint("directory_enumerate_ex2: data=0x%p length=%d\n", data);
+						DbgPrint
+						    ("directory_enumerate_ex2: data=0x%p length=%d\n",
+						     data);
 
 						info->type = 3;
 						info->mode = S_IRWXU;
 
-						if (data->mode & NW_ATTRIBUTE_DIRECTORY) {
+						if (data->
+						    mode &
+						    NW_ATTRIBUTE_DIRECTORY) {
 							info->mode |= S_IFDIR;
 							info->mode |= S_IXUSR;
 						} else {
 							info->mode |= S_IFREG;
 						}
 
-						if (data->mode & NW_ATTRIBUTE_READ_ONLY) {
-							info->mode &= ~(S_IWUSR);
+						if (data->
+						    mode &
+						    NW_ATTRIBUTE_READ_ONLY) {
+							info->mode &=
+							    ~(S_IWUSR);
 						}
 
-						if (data->mode & NW_ATTRIBUTE_EXECUTE) {
+						if (data->
+						    mode & NW_ATTRIBUTE_EXECUTE)
+						{
 							info->mode |= S_IXUSR;
 						}
 
 						info->uid = current->euid;
 						info->gid = current->egid;
 						info->size = data->size;
-						info->atime.tv_sec = data->lastAccessTime;
+						info->atime.tv_sec =
+						    data->lastAccessTime;
 						info->atime.tv_nsec = 0;
-						info->mtime.tv_sec = data->modifyTime;
+						info->mtime.tv_sec =
+						    data->modifyTime;
 						info->mtime.tv_nsec = 0;
-						info->ctime.tv_sec = data->createTime;
+						info->ctime.tv_sec =
+						    data->createTime;
 						info->ctime.tv_nsec = 0;
-						info->namelength = data->nameLen;
-						memcpy(info->name, data->name, data->nameLen);
-						data = (PENUMERATE_DIRECTORY_EX_DATA)&data->name[data->nameLen];
-						replylen = (int)((char *)&info->name[info->namelength] - (char *)info);
-						DbgPrint("directory_enumerate_ex3: info=0x%p\n", info);
-						mydump(replylen, info);
-
-						info = (struct entry_info *)&info->name[info->namelength];
+						info->namelength =
+						    data->nameLen;
+						memcpy(info->name, data->name,
+						       data->nameLen);
+						data =
+						    (struct novfs_enumerate_directory_ex_data *)
+						    & data->name[data->nameLen];
+						replylen =
+						    (int)((char *)&info->
+							  name[info->
+							       namelength] -
+							  (char *)info);
+						DbgPrint
+						    ("directory_enumerate_ex3: info=0x%p\n",
+						     info);
+						novfs_dump(replylen, info);
+
+						info =
+						    (struct novfs_entry_info *) & info->
+						    name[info->namelength];
 
 					} while (--reply->enumCount);
 				}
@@ -778,8 +767,9 @@ static int directory_enumerate_ex(HANDLE
 	return (retCode);
 }
 
-int Novfs_Get_Directory_ListEx(unsigned char * Path, HANDLE * EnumHandle, int *Count,
-			       struct entry_info **Info, struct schandle *SessionId)
+int novfs_get_dir_listex(unsigned char * Path, void ** EnumHandle, int *Count,
+			       struct novfs_entry_info **Info,
+			       struct novfs_schandle SessionId)
 {
 	int retCode = -ENOENT;
 
@@ -788,15 +778,20 @@ int Novfs_Get_Directory_ListEx(unsigned
 	if (Info)
 		*Info = NULL;
 
-	if ((HANDLE) - 1 == *EnumHandle) {
+	if ((void *) - 1 == *EnumHandle) {
 		return (-ENODATA);
 	}
 
-	if (0 == *EnumHandle)
-		retCode = begin_directory_enumerate(Path, strlen(Path), EnumHandle, SessionId);
+	if (0 == *EnumHandle) {
+		retCode =
+		    begin_directory_enumerate(Path, strlen(Path), EnumHandle,
+					      SessionId);
+	}
 
 	if (*EnumHandle) {
-		retCode = directory_enumerate_ex(EnumHandle, SessionId, Count, Info, INTERRUPTIBLE);
+		retCode =
+		    directory_enumerate_ex(EnumHandle, SessionId, Count, Info,
+					   INTERRUPTIBLE);
 		if (retCode) {
 			end_directory_enumerate(*EnumHandle, SessionId);
 			if (-1 == retCode) {
@@ -808,11 +803,12 @@ int Novfs_Get_Directory_ListEx(unsigned
 	return (retCode);
 }
 
-int Novfs_Open_File(unsigned char * Path, int Flags, struct entry_info *Info, HANDLE * Handle,
-		    session_t SessionId)
+int novfs_open_file(unsigned char * Path, int Flags, struct novfs_entry_info * Info,
+		void ** Handle,
+		struct novfs_schandle SessionId)
 {
-	POPEN_FILE_REQUEST cmd;
-	POPEN_FILE_REPLY reply;
+	struct novfs_open_file_request *cmd;
+	struct novfs_open_file_reply *reply;
 	unsigned long replylen = 0;
 	int retCode, cmdlen, pathlen;
 
@@ -825,8 +821,8 @@ int Novfs_Open_File(unsigned char * Path
 
 	*Handle = 0;
 
-	cmdlen = offsetof(OPEN_FILE_REQUEST, path) + pathlen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmdlen = offsetof(struct novfs_open_file_request, path) + pathlen;
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (cmd) {
 		cmd->Command.CommandType = VFS_COMMAND_OPEN_FILE;
 		cmd->Command.SequenceNumber = 0;
@@ -903,10 +899,10 @@ int Novfs_Open_File(unsigned char * Path
 	return (retCode);
 }
 
-int Novfs_Create(unsigned char * Path, int DirectoryFlag, session_t SessionId)
+int novfs_create(unsigned char * Path, int DirectoryFlag, struct novfs_schandle SessionId)
 {
-	PCREATE_FILE_REQUEST cmd;
-	PCREATE_FILE_REPLY reply;
+	struct novfs_create_file_request *cmd;
+	struct novfs_create_file_reply *reply;
 	unsigned long replylen = 0;
 	int retCode, cmdlen, pathlen;
 
@@ -917,8 +913,8 @@ int Novfs_Create(unsigned char * Path, i
 			pathlen--;
 	}
 
-	cmdlen = offsetof(CREATE_FILE_REQUEST, path) + pathlen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmdlen = offsetof(struct novfs_create_file_request, path) + pathlen;
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (cmd) {
 		cmd->Command.CommandType = VFS_COMMAND_CREATE_FILE;
 		if (DirectoryFlag) {
@@ -948,10 +944,10 @@ int Novfs_Create(unsigned char * Path, i
 	return (retCode);
 }
 
-int Novfs_Close_File(HANDLE Handle, session_t SessionId)
+int novfs_close_file(void *Handle, struct novfs_schandle SessionId)
 {
-	CLOSE_FILE_REQUEST cmd;
-	PCLOSE_FILE_REPLY reply;
+	struct novfs_close_file_request cmd;
+	struct novfs_close_file_reply *reply;
 	unsigned long replylen = 0;
 	int retCode;
 
@@ -974,11 +970,11 @@ int Novfs_Close_File(HANDLE Handle, sess
 	return (retCode);
 }
 
-int Novfs_Read_File(HANDLE Handle, unsigned char * Buffer, size_t * Bytes,
-		    loff_t * Offset, session_t SessionId)
+int novfs_read_file(void *Handle, unsigned char * Buffer, size_t * Bytes,
+		    loff_t * Offset, struct novfs_schandle SessionId)
 {
-	READ_FILE_REQUEST cmd;
-	PREAD_FILE_REPLY reply = NULL;
+	struct novfs_read_file_request cmd;
+	struct novfs_read_file_reply * reply = NULL;
 	unsigned long replylen = 0;
 	int retCode = 0;
 	size_t len;
@@ -986,8 +982,10 @@ int Novfs_Read_File(HANDLE Handle, unsig
 	len = *Bytes;
 	*Bytes = 0;
 
-	if ((offsetof(READ_FILE_REPLY, data) + len) > MaxIoSize) {
-		len = MaxIoSize - offsetof(READ_FILE_REPLY, data);
+	if (offsetof(struct novfs_read_file_reply, data) + len
+			> novfs_max_iosize) {
+		len = novfs_max_iosize - offsetof(struct
+				novfs_read_file_reply, data);
 		len = (len / PAGE_SIZE) * PAGE_SIZE;
 	}
 
@@ -999,9 +997,12 @@ int Novfs_Read_File(HANDLE Handle, unsig
 	cmd.len = len;
 	cmd.offset = *Offset;
 
-	retCode = Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
 
-	DbgPrint("Novfs_Read_File: Queue_Daemon_Command 0x%x replylen=%d\n", retCode, replylen);
+	DbgPrint("novfs_Read_File: Queue_Daemon_Command 0x%x replylen=%d\n",
+		 retCode, replylen);
 
 	if (!retCode) {
 		if (reply->Reply.ErrorCode) {
@@ -1011,9 +1012,12 @@ int Novfs_Read_File(HANDLE Handle, unsig
 				retCode = -EIO;
 			}
 		} else {
-			replylen -= offsetof(READ_FILE_REPLY, data);
+			replylen -= offsetof(struct
+					novfs_read_file_reply, data);
+
 			if (replylen > 0) {
-				replylen -= copy_to_user(Buffer, reply->data, replylen);
+				replylen -=
+				    copy_to_user(Buffer, reply->data, replylen);
 				*Bytes = replylen;
 			}
 		}
@@ -1023,17 +1027,18 @@ int Novfs_Read_File(HANDLE Handle, unsig
 		kfree(reply);
 	}
 
-	DbgPrint("Novfs_Read_File *Bytes=0x%x retCode=0x%x\n", *Bytes, retCode);
+	DbgPrint("novfs_Read_File *Bytes=0x%x retCode=0x%x\n", *Bytes, retCode);
 
 	return (retCode);
 }
 
-int Novfs_Read_Pages(HANDLE Handle, struct data_list *DList, int DList_Cnt,
-		     size_t * Bytes, loff_t * Offset, session_t SessionId)
+int novfs_read_pages(void *Handle, struct novfs_data_list *DList,
+		int DList_Cnt, size_t * Bytes, loff_t * Offset,
+		struct novfs_schandle SessionId)
 {
-	READ_FILE_REQUEST cmd;
-	PREAD_FILE_REPLY reply = NULL;
-	READ_FILE_REPLY lreply;
+	struct novfs_read_file_request cmd;
+	struct novfs_read_file_reply * reply = NULL;
+	struct novfs_read_file_reply lreply;
 	unsigned long replylen = 0;
 	int retCode = 0;
 	size_t len;
@@ -1042,7 +1047,7 @@ int Novfs_Read_Pages(HANDLE Handle, stru
 	*Bytes = 0;
 
 	DbgPrint
-	    ("Novfs_Read_Pages: Handle=0x%p Dlst=0x%p Dlcnt=%d Bytes=%d Offset=%lld SessionId=0x%p:%p\n",
+	    ("novfs_Read_Pages: Handle=0x%p Dlst=0x%p Dlcnt=%d Bytes=%d Offset=%lld SessionId=0x%p:%p\n",
 	     Handle, DList, DList_Cnt, len, *Offset, SessionId.hTypeId,
 	     SessionId.hId);
 
@@ -1059,14 +1064,14 @@ int Novfs_Read_Pages(HANDLE Handle, stru
 	 */
 	DList[0].page = NULL;
 	DList[0].offset = &lreply;
-	DList[0].len = offsetof(READ_FILE_REPLY, data);
+	DList[0].len = offsetof(struct novfs_read_file_reply, data);
 	DList[0].rwflag = DLWRITE;
 
 	retCode =
 	    Queue_Daemon_Command(&cmd, sizeof(cmd), DList, DList_Cnt,
 				 (void *)&reply, &replylen, INTERRUPTIBLE);
 
-	DbgPrint("Novfs_Read_Pages: Queue_Daemon_Command 0x%x\n", retCode);
+	DbgPrint("novfs_Read_Pages: Queue_Daemon_Command 0x%x\n", retCode);
 
 	if (!retCode) {
 		if (reply) {
@@ -1080,44 +1085,45 @@ int Novfs_Read_Pages(HANDLE Handle, stru
 				retCode = -EIO;
 			}
 		}
-		*Bytes = replylen - offsetof(READ_FILE_REPLY, data);
+		*Bytes = replylen - offsetof(struct
+				novfs_read_file_reply, data);
 	}
 
 	if (reply) {
 		kfree(reply);
 	}
 
-	DbgPrint("Novfs_Read_Pages: retCode=0x%x\n", retCode);
+	DbgPrint("novfs_Read_Pages: retCode=0x%x\n", retCode);
 
 	return (retCode);
 }
 
-int Novfs_Write_File(HANDLE Handle, unsigned char * Buffer, size_t * Bytes,
-		     loff_t * Offset, session_t SessionId)
+int novfs_write_file(void *Handle, unsigned char * Buffer, size_t * Bytes,
+		     loff_t * Offset, struct novfs_schandle SessionId)
 {
-	WRITE_FILE_REQUEST cmd;
-	PWRITE_FILE_REPLY reply = NULL;
+	struct novfs_write_file_request cmd;
+	struct novfs_write_file_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode = 0, cmdlen;
 	size_t len;
 
 	unsigned long boff;
 	struct page **pages;
-	struct data_list *dlist;
+	struct novfs_data_list *dlist;
 	int res = 0, npage, i;
-	WRITE_FILE_REPLY lreply;
+	struct novfs_write_file_reply lreply;
 
 	len = *Bytes;
-	cmdlen = offsetof(WRITE_FILE_REQUEST, data);
+	cmdlen = offsetof(struct novfs_write_file_request, data);
 
 	*Bytes = 0;
 
 	memset(&lreply, 0, sizeof(lreply));
 
-	DbgPrint("Novfs_Write_File cmdlen=%ld len=%ld\n", cmdlen, len);
+	DbgPrint("novfs_Write_File cmdlen=%ld len=%ld\n", cmdlen, len);
 
-	if ((cmdlen + len) > MaxIoSize) {
-		len = MaxIoSize - cmdlen;
+	if ((cmdlen + len) > novfs_max_iosize) {
+		len = novfs_max_iosize - cmdlen;
 		len = (len / PAGE_SIZE) * PAGE_SIZE;
 	}
 	cmd.Command.CommandType = VFS_COMMAND_WRITE_FILE;
@@ -1127,18 +1133,18 @@ int Novfs_Write_File(HANDLE Handle, unsi
 	cmd.len = len;
 	cmd.offset = *Offset;
 
-	DbgPrint("Novfs_Write_File cmdlen=%ld len=%ld\n", cmdlen, len);
+	DbgPrint("novfs_Write_File cmdlen=%ld len=%ld\n", cmdlen, len);
 
 	npage =
 	    (((unsigned long)Buffer & ~PAGE_MASK) + len +
 	     (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 
-	dlist = Novfs_Malloc(sizeof(struct data_list) * (npage + 1), GFP_KERNEL);
+	dlist = kmalloc(sizeof(struct novfs_data_list) * (npage + 1), GFP_KERNEL);
 	if (NULL == dlist) {
 		return (-ENOMEM);
 	}
 
-	pages = Novfs_Malloc(sizeof(struct page *) * npage, GFP_KERNEL);
+	pages = kmalloc(sizeof(struct page *) * npage, GFP_KERNEL);
 
 	if (NULL == pages) {
 		kfree(dlist);
@@ -1153,7 +1159,7 @@ int Novfs_Write_File(HANDLE Handle, unsi
 
 	up_read(&current->mm->mmap_sem);
 
-	DbgPrint("Novfs_Write_File res=%d\n", res);
+	DbgPrint("novfs_Write_File res=%d\n", res);
 
 	if (res > 0) {
 		boff = (unsigned long)Buffer & ~PAGE_MASK;
@@ -1168,12 +1174,12 @@ int Novfs_Write_File(HANDLE Handle, unsi
 			dlist[0].len = len;
 		}
 
-		DbgPrint("Novfs_Write_File0: page=0x%p offset=0x%p len=%d\n",
+		DbgPrint("novfs_Write_File0: page=0x%p offset=0x%p len=%d\n",
 			 dlist[0].page, dlist[0].offset, dlist[0].len);
 
 		boff = dlist[0].len;
 
-		DbgPrint("Novfs_Write_File len=%d boff=%d\n", len, boff);
+		DbgPrint("novfs_Write_File len=%d boff=%d\n", len, boff);
 
 		for (i = 1; (i < res) && (boff < len); i++) {
 			flush_dcache_page(pages[i]);
@@ -1188,7 +1194,7 @@ int Novfs_Write_File(HANDLE Handle, unsi
 
 			boff += dlist[i].len;
 			DbgPrint
-			    ("Novfs_Write_File%d: page=0x%p offset=0x%p len=%d\n",
+			    ("novfs_Write_File%d: page=0x%p offset=0x%p len=%d\n",
 			     i, dlist[i].page, dlist[i].offset, dlist[i].len);
 		}
 
@@ -1198,7 +1204,7 @@ int Novfs_Write_File(HANDLE Handle, unsi
 		dlist[i].rwflag = DLWRITE;
 		res++;
 
-		DbgPrint("Novfs_Write_File Buffer=0x%p boff=0x%x len=%d\n",
+		DbgPrint("novfs_Write_File Buffer=0x%p boff=0x%x len=%d\n",
 			 Buffer, boff, len);
 
 		retCode =
@@ -1211,7 +1217,7 @@ int Novfs_Write_File(HANDLE Handle, unsi
 
 		res = 0;
 
-		kdata = Novfs_Malloc(len, GFP_KERNEL);
+		kdata = kmalloc(len, GFP_KERNEL);
 		if (kdata) {
 			len -= copy_from_user(kdata, Buffer, len);
 			dlist[0].page = NULL;
@@ -1233,7 +1239,7 @@ int Novfs_Write_File(HANDLE Handle, unsi
 		}
 	}
 
-	DbgPrint("Novfs_Write_File retCode=0x%x reply=0x%p\n", retCode, reply);
+	DbgPrint("novfs_Write_File retCode=0x%x reply=0x%p\n", retCode, reply);
 
 	if (!retCode) {
 		switch (lreply.Reply.ErrorCode) {
@@ -1267,7 +1273,7 @@ int Novfs_Write_File(HANDLE Handle, unsi
 	kfree(pages);
 	kfree(dlist);
 
-	DbgPrint("Novfs_Write_File *Bytes=0x%x retCode=0x%x\n", *Bytes,
+	DbgPrint("novfs_Write_File *Bytes=0x%x retCode=0x%x\n", *Bytes,
 		 retCode);
 
 	return (retCode);
@@ -1276,7 +1282,7 @@ int Novfs_Write_File(HANDLE Handle, unsi
 /*
  *  Arguments: HANDLE Handle - novfsd file handle
  *             struct page *Page - Page to be written out
- *             session_t SessionId - novfsd session handle
+ *             struct novfs_schandle SessionId - novfsd session handle
  *
  *  Returns:   0 - Success
  *             -ENOSPC - Out of space on server
@@ -1285,17 +1291,17 @@ int Novfs_Write_File(HANDLE Handle, unsi
  *
  *  Abstract:  Write page to file.
  */
-int Novfs_Write_Page(HANDLE Handle, struct page *Page, session_t SessionId)
+int novfs_write_page(void *Handle, struct page *Page, struct novfs_schandle SessionId)
 {
-	WRITE_FILE_REQUEST cmd;
-	WRITE_FILE_REPLY lreply;
-	PWRITE_FILE_REPLY reply = NULL;
+	struct novfs_write_file_request cmd;
+	struct novfs_write_file_reply lreply;
+	struct novfs_write_file_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode = 0, cmdlen;
-	struct data_list dlst[2];
+	struct novfs_data_list dlst[2];
 
 	DbgPrint
-	    ("Novfs_Write_Page: Handle=0x%p Page=0x%p Index=%lu SessionId=0x%llx\n",
+	    ("novfs_Write_Page: Handle=0x%p Page=0x%p Index=%lu SessionId=0x%llx\n",
 	     Handle, Page, Page->index, SessionId);
 
 	dlst[0].page = NULL;
@@ -1308,7 +1314,7 @@ int Novfs_Write_Page(HANDLE Handle, stru
 	dlst[1].len = PAGE_CACHE_SIZE;
 	dlst[1].rwflag = DLREAD;
 
-	cmdlen = offsetof(WRITE_FILE_REQUEST, data);
+	cmdlen = offsetof(struct novfs_write_file_request, data);
 
 	cmd.Command.CommandType = VFS_COMMAND_WRITE_FILE;
 	cmd.Command.SequenceNumber = 0;
@@ -1348,23 +1354,23 @@ int Novfs_Write_Page(HANDLE Handle, stru
 		kfree(reply);
 	}
 
-	DbgPrint("Novfs_Write_Page retCode=0x%x\n", retCode);
+	DbgPrint("novfs_Write_Page retCode=0x%x\n", retCode);
 
 	return (retCode);
 }
 
-int Novfs_Write_Pages(HANDLE Handle, struct data_list *DList, int DList_Cnt,
-		      size_t Bytes, loff_t Offset, session_t SessionId)
+int novfs_write_pages(void *Handle, struct novfs_data_list *DList, int DList_Cnt,
+		      size_t Bytes, loff_t Offset, struct novfs_schandle SessionId)
 {
-	WRITE_FILE_REQUEST cmd;
-	WRITE_FILE_REPLY lreply;
-	PWRITE_FILE_REPLY reply = NULL;
+	struct novfs_write_file_request cmd;
+	struct novfs_write_file_reply lreply;
+	struct novfs_write_file_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode = 0, cmdlen;
 	size_t len;
 
 	DbgPrint
-	    ("Novfs_Write_Pages: Handle=0x%p Dlst=0x%p Dlcnt=%d Bytes=%d Offset=%lld SessionId=0x%llx\n",
+	    ("novfs_Write_Pages: Handle=0x%p Dlst=0x%p Dlcnt=%d Bytes=%d Offset=%lld SessionId=0x%llx\n",
 	     Handle, DList, DList_Cnt, Bytes, Offset, SessionId);
 
 	DList[0].page = NULL;
@@ -1373,7 +1379,7 @@ int Novfs_Write_Pages(HANDLE Handle, str
 	DList[0].rwflag = DLWRITE;
 
 	len = Bytes;
-	cmdlen = offsetof(WRITE_FILE_REQUEST, data);
+	cmdlen = offsetof(struct novfs_write_file_request, data);
 
 	if (len) {
 		cmd.Command.CommandType = VFS_COMMAND_WRITE_FILE;
@@ -1414,17 +1420,17 @@ int Novfs_Write_Pages(HANDLE Handle, str
 			kfree(reply);
 		}
 	}
-	DbgPrint("Novfs_Write_Pages retCode=0x%x\n", retCode);
+	DbgPrint("novfs_Write_Pages retCode=0x%x\n", retCode);
 
 	return (retCode);
 }
 
-int Novfs_Read_Stream(HANDLE ConnHandle, unsigned char * Handle, unsigned char * Buffer,
+int novfs_read_stream(void *ConnHandle, unsigned char * Handle, u_char * Buffer,
 		      size_t * Bytes, loff_t * Offset, int User,
-		      session_t SessionId)
+		      struct novfs_schandle SessionId)
 {
-	READ_STREAM_REQUEST cmd;
-	PREAD_STREAM_REPLY reply = NULL;
+	struct novfs_read_stream_request cmd;
+	struct novfs_read_stream_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode = 0;
 	size_t len;
@@ -1432,8 +1438,10 @@ int Novfs_Read_Stream(HANDLE ConnHandle,
 	len = *Bytes;
 	*Bytes = 0;
 
-	if ((offsetof(READ_FILE_REPLY, data) + len) > MaxIoSize) {
-		len = MaxIoSize - offsetof(READ_FILE_REPLY, data);
+	if (offsetof(struct novfs_read_file_reply, data) + len
+			> novfs_max_iosize) {
+		len = novfs_max_iosize - offsetof(struct
+				novfs_read_file_reply, data);
 		len = (len / PAGE_SIZE) * PAGE_SIZE;
 	}
 
@@ -1446,60 +1454,70 @@ int Novfs_Read_Stream(HANDLE ConnHandle,
 	cmd.len = len;
 	cmd.offset = *Offset;
 
-	retCode = Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply, &replylen, INTERRUPTIBLE);
+	retCode =
+	    Queue_Daemon_Command(&cmd, sizeof(cmd), NULL, 0, (void *)&reply,
+				 &replylen, INTERRUPTIBLE);
 
-	DbgPrint("Novfs_Read_Stream: Queue_Daemon_Command 0x%x replylen=%d\n", retCode, replylen);
+	DbgPrint("novfs_Read_Stream: Queue_Daemon_Command 0x%x replylen=%d\n",
+		 retCode, replylen);
 
 	if (reply) {
 		retCode = 0;
 		if (reply->Reply.ErrorCode) {
 			retCode = -EIO;
 		} else {
-			replylen -= offsetof(READ_STREAM_REPLY, data);
+			replylen -= offsetof(struct
+					novfs_read_stream_reply, data);
 			if (replylen > 0) {
-				if (User)
-					replylen -= copy_to_user(Buffer, reply->data, replylen);
-				else
+				if (User) {
+					replylen -=
+					    copy_to_user(Buffer, reply->data,
+							 replylen);
+				} else {
 					memcpy(Buffer, reply->data, replylen);
+				}
+
 				*Bytes = replylen;
 			}
 		}
 		kfree(reply);
 	}
 
-	DbgPrint("Novfs_Read_Stream *Bytes=0x%x retCode=0x%x\n", *Bytes, retCode);
+	DbgPrint("novfs_Read_Stream *Bytes=0x%x retCode=0x%x\n", *Bytes,
+		 retCode);
 
 	return (retCode);
 }
 
-int Novfs_Write_Stream(HANDLE ConnHandle, unsigned char * Handle, unsigned char * Buffer,
-		       size_t * Bytes, loff_t * Offset, session_t SessionId)
+int novfs_write_stream(void *ConnHandle, unsigned char * Handle, u_char * Buffer,
+		       size_t * Bytes, loff_t * Offset, struct novfs_schandle SessionId)
 {
-	PWRITE_STREAM_REQUEST cmd;
-	PWRITE_STREAM_REPLY reply = NULL;
+	struct novfs_write_stream_request * cmd;
+	struct novfs_write_stream_reply * reply = NULL;
 	unsigned long replylen = 0;
 	int retCode = 0, cmdlen;
 	size_t len;
 
 	len = *Bytes;
-	cmdlen = len + offsetof(WRITE_STREAM_REQUEST, data);
+	cmdlen = len + offsetof(struct novfs_write_stream_request, data);
 	*Bytes = 0;
 
-	if (cmdlen > MaxIoSize) {
-		cmdlen = MaxIoSize;
-		len = cmdlen - offsetof(WRITE_STREAM_REQUEST, data);
+	if (cmdlen > novfs_max_iosize) {
+		cmdlen = novfs_max_iosize;
+		len = cmdlen - offsetof(struct
+				novfs_write_stream_request, data);
 	}
 
-	DbgPrint("Novfs_Write_Stream cmdlen=%d len=%d\n", cmdlen, len);
+	DbgPrint("novfs_Write_Stream cmdlen=%d len=%d\n", cmdlen, len);
 
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
 	if (cmd) {
 		if (Buffer && len) {
 			len -= copy_from_user(cmd->data, Buffer, len);
 		}
 
-		DbgPrint("Novfs_Write_Stream len=%d\n", len);
+		DbgPrint("novfs_Write_Stream len=%d\n", len);
 
 		cmd->Command.CommandType = VFS_COMMAND_WRITE_STREAM;
 		cmd->Command.SequenceNumber = 0;
@@ -1532,23 +1550,23 @@ int Novfs_Write_Stream(HANDLE ConnHandle
 				break;
 			}
 			DbgPrint
-			    ("Novfs_Write_Stream reply->bytesWritten=0x%lx\n",
+			    ("novfs_Write_Stream reply->bytesWritten=0x%lx\n",
 			     reply->bytesWritten);
 			*Bytes = reply->bytesWritten;
 			kfree(reply);
 		}
 		kfree(cmd);
 	}
-	DbgPrint("Novfs_Write_Stream *Bytes=0x%x retCode=0x%x\n", *Bytes,
+	DbgPrint("novfs_Write_Stream *Bytes=0x%x retCode=0x%x\n", *Bytes,
 		 retCode);
 
 	return (retCode);
 }
 
-int Novfs_Close_Stream(HANDLE ConnHandle, unsigned char * Handle, session_t SessionId)
+int novfs_close_stream(void *ConnHandle, unsigned char * Handle, struct novfs_schandle SessionId)
 {
-	CLOSE_STREAM_REQUEST cmd;
-	PCLOSE_STREAM_REPLY reply;
+	struct novfs_close_stream_request cmd;
+	struct novfs_close_stream_reply *reply;
 	unsigned long replylen = 0;
 	int retCode;
 
@@ -1572,10 +1590,10 @@ int Novfs_Close_Stream(HANDLE ConnHandle
 	return (retCode);
 }
 
-int Novfs_Delete(unsigned char * Path, int DirectoryFlag, session_t SessionId)
+int novfs_delete(unsigned char * Path, int DirectoryFlag, struct novfs_schandle SessionId)
 {
-	PDELETE_FILE_REQUEST cmd;
-	PDELETE_FILE_REPLY reply;
+	struct novfs_delete_file_request *cmd;
+	struct novfs_delete_file_reply *reply;
 	unsigned long replylen = 0;
 	int retCode, cmdlen, pathlen;
 
@@ -1586,8 +1604,8 @@ int Novfs_Delete(unsigned char * Path, i
 			pathlen--;
 	}
 
-	cmdlen = offsetof(DELETE_FILE_REQUEST, path) + pathlen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmdlen = offsetof(struct novfs_delete_file_request, path) + pathlen;
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (cmd) {
 		cmd->Command.CommandType = VFS_COMMAND_DELETE_FILE;
 		cmd->Command.SequenceNumber = 0;
@@ -1618,10 +1636,11 @@ int Novfs_Delete(unsigned char * Path, i
 	return (retCode);
 }
 
-int Novfs_Truncate_File(unsigned char * Path, int PathLen, session_t SessionId)
+int novfs_trunc(unsigned char * Path, int PathLen,
+		struct novfs_schandle SessionId)
 {
-	PTRUNCATE_FILE_REQUEST cmd;
-	PTRUNCATE_FILE_REPLY reply;
+	struct novfs_truncate_file_request *cmd;
+	struct novfs_truncate_file_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode, cmdlen;
 
@@ -1629,8 +1648,9 @@ int Novfs_Truncate_File(unsigned char *
 		if ('.' == Path[PathLen - 1])
 			PathLen--;
 	}
-	cmdlen = offsetof(TRUNCATE_FILE_REQUEST, path) + PathLen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmdlen = offsetof(struct novfs_truncate_file_request, path)
+		+ PathLen;
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (cmd) {
 		cmd->Command.CommandType = VFS_COMMAND_TRUNCATE_FILE;
 		cmd->Command.SequenceNumber = 0;
@@ -1655,17 +1675,18 @@ int Novfs_Truncate_File(unsigned char *
 	return (retCode);
 }
 
-int Novfs_Truncate_File_Ex(HANDLE Handle, loff_t Offset, session_t SessionId)
+int novfs_trunc_ex(void *Handle, loff_t Offset,
+		struct novfs_schandle SessionId)
 {
-	WRITE_FILE_REQUEST cmd;
-	PWRITE_FILE_REPLY reply = NULL;
+	struct novfs_write_file_request cmd;
+	struct novfs_write_file_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode = 0, cmdlen;
 
-	DbgPrint("Novfs_Truncate_File_Ex Handle=0x%p Offset=%lld\n", Handle,
+	DbgPrint("novfs_Truncate_File_Ex Handle=0x%p Offset=%lld\n", Handle,
 		 Offset);
 
-	cmdlen = offsetof(WRITE_FILE_REQUEST, data);
+	cmdlen = offsetof(struct novfs_write_file_request, data);
 
 	cmd.Command.CommandType = VFS_COMMAND_WRITE_FILE;
 	cmd.Command.SequenceNumber = 0;
@@ -1678,7 +1699,7 @@ int Novfs_Truncate_File_Ex(HANDLE Handle
 	    Queue_Daemon_Command(&cmd, cmdlen, NULL, 0, (void *)&reply,
 				 &replylen, INTERRUPTIBLE);
 
-	DbgPrint("Novfs_Truncate_File_Ex retCode=0x%x reply=0x%p\n", retCode,
+	DbgPrint("novfs_Truncate_File_Ex retCode=0x%x reply=0x%p\n", retCode,
 		 reply);
 
 	if (!retCode) {
@@ -1709,20 +1730,21 @@ int Novfs_Truncate_File_Ex(HANDLE Handle
 		kfree(reply);
 	}
 
-	DbgPrint("Novfs_Truncate_File_Ex retCode=%d\n", retCode);
+	DbgPrint("novfs_Truncate_File_Ex retCode=%d\n", retCode);
 
 	return (retCode);
 }
 
-int Novfs_Rename_File(int DirectoryFlag, unsigned char * OldName, int OldLen,
-		      unsigned char * NewName, int NewLen, session_t SessionId)
+int novfs_rename_file(int DirectoryFlag, unsigned char * OldName, int OldLen,
+		      unsigned char * NewName, int NewLen,
+		      struct novfs_schandle SessionId)
 {
-	RENAME_FILE_REQUEST cmd;
-	PRENAME_FILE_REPLY reply;
+	struct novfs_rename_file_request cmd;
+	struct novfs_rename_file_reply *reply;
 	unsigned long replylen = 0;
 	int retCode;
 
-	DbgPrint("Novfs_Rename_File:\n"
+	DbgPrint("novfs_Rename_File:\n"
 		 "   DirectoryFlag: %d\n"
 		 "   OldName:       %.*s\n"
 		 "   NewName:       %.*s\n"
@@ -1761,10 +1783,11 @@ int Novfs_Rename_File(int DirectoryFlag,
 	return (retCode);
 }
 
-int Novfs_Set_Attr(unsigned char * Path, struct iattr *Attr, session_t SessionId)
+int novfs_set_attr(unsigned char * Path, struct iattr *Attr,
+		struct novfs_schandle SessionId)
 {
-	PSET_FILE_INFO_REQUEST cmd;
-	PSET_FILE_INFO_REPLY reply;
+	struct novfs_set_file_info_request *cmd;
+	struct novfs_set_file_info_reply *reply;
 	unsigned long replylen = 0;
 	int retCode, cmdlen, pathlen;
 
@@ -1775,8 +1798,8 @@ int Novfs_Set_Attr(unsigned char * Path,
 			pathlen--;
 	}
 
-	cmdlen = offsetof(SET_FILE_INFO_REQUEST, path) + pathlen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmdlen = offsetof(struct novfs_set_file_info_request,path) + pathlen;
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (cmd) {
 		cmd->Command.CommandType = VFS_COMMAND_SET_FILE_INFO;
 		cmd->Command.SequenceNumber = 0;
@@ -1827,16 +1850,17 @@ int Novfs_Set_Attr(unsigned char * Path,
 	return (retCode);
 }
 
-int Novfs_Get_File_Cache_Flag(unsigned char * Path, session_t SessionId)
+int novfs_get_file_cache_flag(unsigned char * Path,
+		struct novfs_schandle SessionId)
 {
-	PGET_CACHE_FLAG_REQUEST cmd;
-	PGET_CACHE_FLAG_REPLY reply = NULL;
+	struct novfs_get_cache_flag *cmd;
+	struct novfs_get_cache_flag_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int cmdlen;
 	int retCode = 0;
 	int pathlen;
 
-	DbgPrint("Novfs_Get_File_Cache_Flag: Path = %s\n", Path);
+	DbgPrint("novfs_Get_File_Cache_Flag: Path = %s\n", Path);
 
 	if (Path && *Path) {
 		pathlen = strlen(Path);
@@ -1844,8 +1868,10 @@ int Novfs_Get_File_Cache_Flag(unsigned c
 			if ('.' == Path[pathlen - 1])
 				pathlen--;
 		}
-		cmdlen = offsetof(GET_CACHE_FLAG_REQUEST, path) + pathlen;
-		cmd = (PGET_CACHE_FLAG_REQUEST) Novfs_Malloc(cmdlen, GFP_KERNEL);
+		cmdlen = offsetof(struct novfs_get_cache_flag, path) +
+			pathlen;
+		cmd = (struct novfs_get_cache_flag *)
+			kmalloc(cmdlen, GFP_KERNEL);
 		if (cmd) {
 			cmd->Command.CommandType = VFS_COMMAND_GET_CACHE_FLAG;
 			cmd->Command.SequenceNumber = 0;
@@ -1869,7 +1895,7 @@ int Novfs_Get_File_Cache_Flag(unsigned c
 		}
 	}
 
-	DbgPrint("Novfs_Get_File_Cache_Flag: return %d\n", retCode);
+	DbgPrint("novfs_Get_File_Cache_Flag: return %d\n", retCode);
 	return (retCode);
 }
 
@@ -1878,33 +1904,26 @@ int Novfs_Get_File_Cache_Flag(unsigned c
  *      SessionId, file handle, type of lock (read/write or unlock),
  *	    start of lock area, length of lock area
  *
- *  Returns:
- *      0 on success
- *      negative value on error
- *
- *  Abstract:
- *
  *  Notes: lock type - fcntl
  */
-int Novfs_Set_File_Lock(session_t SessionId, HANDLE Handle,
+int novfs_set_file_lock(struct novfs_schandle SessionId, void *Handle,
 			unsigned char fl_type, loff_t fl_start, loff_t fl_len)
 {
-	PSET_FILE_LOCK_REQUEST cmd;
-	PSET_FILE_LOCK_REPLY reply = NULL;
+	struct novfs_set_file_lock_request *cmd;
+	struct novfs_set_file_lock_reply *reply = NULL;
 	unsigned long replylen = 0;
 	int retCode;
 
 	retCode = -1;
 
-	DbgPrint("Novfs_Set_File_Lock:\n"
+	DbgPrint("novfs_Set_File_Lock:\n"
 		 "   SessionId:     0x%llx\n", SessionId);
 
 	cmd =
-	    (PSET_FILE_LOCK_REQUEST) Novfs_Malloc(sizeof(SET_FILE_LOCK_REQUEST),
-						  GFP_KERNEL);
+	    (struct novfs_set_file_lock_request *) kmalloc(sizeof(struct novfs_set_file_lock_request), GFP_KERNEL);
 
 	if (cmd) {
-		DbgPrint("Novfs_Set_File_Lock 2\n");
+		DbgPrint("novfs_Set_File_Lock 2\n");
 
 		cmd->Command.CommandType = VFS_COMMAND_SET_FILE_LOCK;
 		cmd->Command.SequenceNumber = 0;
@@ -1921,32 +1940,32 @@ int Novfs_Set_File_Lock(session_t Sessio
 		cmd->fl_start = fl_start;
 		cmd->fl_len = fl_len;
 
-		DbgPrint("Novfs_Set_File_Lock 3\n");
+		DbgPrint("novfs_Set_File_Lock 3\n");
 
-		DbgPrint("Novfs_Set_File_Lock: BEGIN dump arguments\n");
-		DbgPrint("Novfs_Set_File_Lock: Queue_Daemon_Command %d\n",
+		DbgPrint("novfs_Set_File_Lock: BEGIN dump arguments\n");
+		DbgPrint("novfs_Set_File_Lock: Queue_Daemon_Command %d\n",
 			 cmd->Command.CommandType);
-		DbgPrint("Novfs_Set_File_Lock: cmd->handle   = 0x%p\n",
+		DbgPrint("novfs_Set_File_Lock: cmd->handle   = 0x%p\n",
 			 cmd->handle);
-		DbgPrint("Novfs_Set_File_Lock: cmd->fl_type  = %u\n",
+		DbgPrint("novfs_Set_File_Lock: cmd->fl_type  = %u\n",
 			 cmd->fl_type);
-		DbgPrint("Novfs_Set_File_Lock: cmd->fl_start = 0x%X\n",
+		DbgPrint("novfs_Set_File_Lock: cmd->fl_start = 0x%X\n",
 			 cmd->fl_start);
-		DbgPrint("Novfs_Set_File_Lock: cmd->fl_len   = 0x%X\n",
+		DbgPrint("novfs_Set_File_Lock: cmd->fl_len   = 0x%X\n",
 			 cmd->fl_len);
 		DbgPrint
-		    ("Novfs_Set_File_Lock: sizeof(SET_FILE_LOCK_REQUEST) = %u\n",
-		     sizeof(SET_FILE_LOCK_REQUEST));
-		DbgPrint("Novfs_Set_File_Lock: END dump arguments\n");
+		    ("novfs_Set_File_Lock: sizeof(SET_FILE_LOCK_REQUEST) = %u\n",
+		     sizeof(struct novfs_set_file_lock_request));
+		DbgPrint("novfs_Set_File_Lock: END dump arguments\n");
 
 		retCode =
-		    Queue_Daemon_Command(cmd, sizeof(SET_FILE_LOCK_REQUEST),
+		    Queue_Daemon_Command(cmd, sizeof(struct novfs_set_file_lock_request),
 					 NULL, 0, (void *)&reply, &replylen,
 					 INTERRUPTIBLE);
-		DbgPrint("Novfs_Set_File_Lock 4\n");
+		DbgPrint("novfs_Set_File_Lock 4\n");
 
 		if (reply) {
-			DbgPrint("Novfs_Set_File_Lock 5, ErrorCode = %X\n",
+			DbgPrint("novfs_Set_File_Lock 5, ErrorCode = %X\n",
 				 reply->Reply.ErrorCode);
 
 			if (reply->Reply.ErrorCode) {
@@ -1954,11 +1973,10 @@ int Novfs_Set_File_Lock(session_t Sessio
 			}
 			kfree(reply);
 		}
-
 		kfree(cmd);
 	}
 
-	DbgPrint("Novfs_Set_File_Lock 6\n");
+	DbgPrint("novfs_Set_File_Lock 6\n");
 
 	return (retCode);
 }
--- a/fs/novfs/inode.c
+++ b/fs/novfs/inode.c
@@ -37,14 +37,6 @@
 /*===[ Include files specific to this module ]============================*/
 #include "vfs.h"
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
-#define FSPRIVATE u.generic_ip
-#else
-#define FSPRIVATE i_private
-#endif
-
-
-#define FILE_UPDATE_TIMEOUT   2
 
 struct inode_data {
 	void *Scope;
@@ -54,285 +46,260 @@ struct inode_data {
 	unsigned long cntDC;
 	struct list_head DirCache;
 	struct semaphore DirCacheLock;
-	HANDLE FileHandle;
+	void * FileHandle;
 	int CacheFlag;
 	char Name[1];		/* Needs to be last entry */
 };
 
-// FIXME these are wrong, but fake the compiler out for now until the proper people can be flogged...
-extern void *Scope_Get_ScopefromName(struct qstr *Name);
-extern void *Scope_Get_ScopefromPath(struct dentry *Dentry);
-
-/*===[ Function prototypes ]==============================================*/
-int Novfs_Remove_from_Root(char *RemoveName);
-int Novfs_Add_to_Root(char *);
-char *Novfs_dget_path(struct dentry *d, char *path, unsigned int pathlen);
-int verify_dentry(struct dentry *dentry, int Flags);
-int invalidate_dentry(struct dentry *parent);
-struct dentry *Novfs_d_lookup(struct dentry *Parent, struct qstr *Name);
-int Novfs_d_add(struct dentry *p, struct dentry *d, struct inode *i, int add);
-int Novfs_d_strcmp(struct qstr *s1, struct qstr *s2);
-unsigned long Novfs_internal_hash(struct qstr *name);
+#define FILE_UPDATE_TIMEOUT   2
+
+/*===[ Function prototypes ]=============================================*/
+
+static unsigned long novfs_internal_hash(struct qstr *name);
+static int novfs_d_add(struct dentry *p, struct dentry *d, struct inode *i, int add);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
-int Novfs_get_sb(struct file_system_type *Fstype, int Flags,
+static int novfs_get_sb(struct file_system_type *Fstype, int Flags,
 		 const char *Dev_name, void *Data, struct vfsmount *Mnt);
-#else
-struct super_block *Novfs_get_sb(struct file_system_type *Fstype, int Flags,
-				 const char *Dev_name, void *Data);
-#endif
 
-int Novfs_fill_super(struct super_block *SB, void *Data, int Silent);
+static void novfs_kill_sb(struct super_block *SB);
+
 
 /*
  * Declared dentry_operations
  */
-int Novfs_d_revalidate(struct dentry *, struct nameidata *);
-int Novfs_d_hash(struct dentry *, struct qstr *);
-int Novfs_d_compare(struct dentry *, struct qstr *, struct qstr *);
-int Novfs_d_delete(struct dentry *dentry);
-void Novfs_d_release(struct dentry *dentry);
-void Novfs_d_iput(struct dentry *dentry, struct inode *inode);
+int novfs_d_revalidate(struct dentry *, struct nameidata *);
+int novfs_d_hash(struct dentry *, struct qstr *);
+int novfs_d_compare(struct dentry *, struct qstr *, struct qstr *);
+int novfs_d_delete(struct dentry *dentry);
+void novfs_d_release(struct dentry *dentry);
+void novfs_d_iput(struct dentry *dentry, struct inode *inode);
 
 /*
  * Declared directory operations
  */
-int Novfs_dir_open(struct inode *inode, struct file *file);
-int Novfs_dir_release(struct inode *inode, struct file *file);
-loff_t Novfs_dir_lseek(struct file *file, loff_t offset, int origin);
-ssize_t Novfs_dir_read(struct file *file, char *buf, size_t len, loff_t * off);
+int novfs_dir_open(struct inode *inode, struct file *file);
+int novfs_dir_release(struct inode *inode, struct file *file);
+loff_t novfs_dir_lseek(struct file *file, loff_t offset, int origin);
+ssize_t novfs_dir_read(struct file *file, char *buf, size_t len, loff_t * off);
 void addtodentry(struct dentry *Parent, unsigned char *List, int Level);
-int Novfs_filldir(void *data, const char *name, int namelen, loff_t off,
+int novfs_filldir(void *data, const char *name, int namelen, loff_t off,
 		  ino_t ino, unsigned ftype);
-int Novfs_dir_readdir(struct file *filp, void *dirent, filldir_t filldir);
-int Novfs_dir_fsync(struct file *file, struct dentry *dentry, int datasync);
+int novfs_dir_readdir(struct file *filp, void *dirent, filldir_t filldir);
+int novfs_dir_fsync(struct file *file, struct dentry *dentry, int datasync);
 
 /*
  * Declared address space operations
  */
-int Novfs_a_writepage(struct page *page, struct writeback_control *wbc);
-int Novfs_a_writepages(struct address_space *mapping,
+int novfs_a_writepage(struct page *page, struct writeback_control *wbc);
+int novfs_a_writepages(struct address_space *mapping,
 		       struct writeback_control *wbc);
-int Novfs_a_prepare_write(struct file *file, struct page *page, unsigned from,
+int novfs_a_prepare_write(struct file *file, struct page *page, unsigned from,
 			  unsigned to);
-int Novfs_a_commit_write(struct file *file, struct page *page, unsigned offset,
+int novfs_a_commit_write(struct file *file, struct page *page, unsigned offset,
 			 unsigned to);
-int Novfs_a_readpage(struct file *file, struct page *page);
-int Novfs_a_readpages(struct file *file, struct address_space *mapping,
+int novfs_a_readpage(struct file *file, struct page *page);
+int novfs_a_readpages(struct file *file, struct address_space *mapping,
 		      struct list_head *page_lst, unsigned nr_pages);
-ssize_t Novfs_a_direct_IO(int rw, struct kiocb *kiocb, const struct iovec *iov,
+ssize_t novfs_a_direct_IO(int rw, struct kiocb *kiocb, const struct iovec *iov,
 			  loff_t offset, unsigned long nr_segs);
 
 /*
  * Declared file_operations
  */
-ssize_t Novfs_f_read(struct file *, char *, size_t, loff_t *);
-ssize_t Novfs_f_write(struct file *, const char *, size_t, loff_t *);
-int Novfs_f_readdir(struct file *, void *, filldir_t);
-int Novfs_f_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
-int Novfs_f_mmap(struct file *file, struct vm_area_struct *vma);
-int Novfs_f_open(struct inode *, struct file *);
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,16)
-int Novfs_f_flush(struct file *);
-#else
-int Novfs_f_flush(struct file *, fl_owner_t);
-#endif
-int Novfs_f_release(struct inode *, struct file *);
-int Novfs_f_fsync(struct file *, struct dentry *, int datasync);
-int Novfs_f_lock(struct file *, int, struct file_lock *);
+ssize_t novfs_f_read(struct file *, char *, size_t, loff_t *);
+ssize_t novfs_f_write(struct file *, const char *, size_t, loff_t *);
+int novfs_f_readdir(struct file *, void *, filldir_t);
+int novfs_f_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+int novfs_f_mmap(struct file *file, struct vm_area_struct *vma);
+int novfs_f_open(struct inode *, struct file *);
+int novfs_f_flush(struct file *, fl_owner_t);
+int novfs_f_release(struct inode *, struct file *);
+int novfs_f_fsync(struct file *, struct dentry *, int datasync);
+int novfs_f_lock(struct file *, int, struct file_lock *);
 
 /*
  * Declared inode_operations
  */
-int Novfs_i_create(struct inode *, struct dentry *, int, struct nameidata *);
-struct dentry *Novfs_i_lookup(struct inode *, struct dentry *,
+int novfs_i_create(struct inode *, struct dentry *, int, struct nameidata *);
+struct dentry *novfs_i_lookup(struct inode *, struct dentry *,
 			      struct nameidata *);
-int Novfs_i_mkdir(struct inode *, struct dentry *, int);
-int Novfs_i_unlink(struct inode *dir, struct dentry *dentry);
-int Novfs_i_rmdir(struct inode *, struct dentry *);
-int Novfs_i_mknod(struct inode *, struct dentry *, int, dev_t);
-int Novfs_i_rename(struct inode *, struct dentry *, struct inode *,
+int novfs_i_mkdir(struct inode *, struct dentry *, int);
+int novfs_i_unlink(struct inode *dir, struct dentry *dentry);
+int novfs_i_rmdir(struct inode *, struct dentry *);
+int novfs_i_mknod(struct inode *, struct dentry *, int, dev_t);
+int novfs_i_rename(struct inode *, struct dentry *, struct inode *,
 		   struct dentry *);
-int Novfs_i_permission(struct inode *inode, int mask);
-int Novfs_i_setattr(struct dentry *, struct iattr *);
-int Novfs_i_getattr(struct vfsmount *mnt, struct dentry *, struct kstat *);
-int Novfs_i_revalidate(struct dentry *dentry);
+int novfs_i_setattr(struct dentry *, struct iattr *);
+int novfs_i_getattr(struct vfsmount *mnt, struct dentry *, struct kstat *);
+int novfs_i_revalidate(struct dentry *dentry);
 
 /*
  * Extended attributes operations
  */
 
-int Novfs_i_getxattr(struct dentry *dentry, const char *name, void *buffer,
+int novfs_i_getxattr(struct dentry *dentry, const char *name, void *buffer,
 		     size_t size);
-int Novfs_i_setxattr(struct dentry *dentry, const char *name, const void *value,
+int novfs_i_setxattr(struct dentry *dentry, const char *name, const void *value,
 		     size_t value_size, int flags);
-int Novfs_i_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size);
+int novfs_i_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size);
 
-void update_inode(struct inode *Inode, struct entry_info *Info);
+void update_inode(struct inode *Inode, struct novfs_entry_info *Info);
 
 /*
  * Declared super_operations
  */
-void Novfs_read_inode(struct inode *inode);
-void Novfs_write_inode(struct inode *inode);
-int Novfs_notify_change(struct dentry *dentry, struct iattr *attr);
-void Novfs_clear_inode(struct inode *inode);
-int Novfs_show_options(struct seq_file *s, struct vfsmount *m);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
-int Novfs_statfs(struct dentry *de, struct kstatfs *buf);
-#else
-int Novfs_statfs(struct super_block *sb, struct kstatfs *buf);
-#endif
+void novfs_read_inode(struct inode *inode);
+void novfs_write_inode(struct inode *inode);
+int novfs_notify_change(struct dentry *dentry, struct iattr *attr);
+void novfs_clear_inode(struct inode *inode);
+int novfs_show_options(struct seq_file *s, struct vfsmount *m);
+
+int novfs_statfs(struct dentry *de, struct kstatfs *buf);
 
 /*
  * Declared control interface functions
  */
 ssize_t
-Novfs_Control_read(struct file *file, char *buf, size_t nbytes, loff_t * ppos);
+novfs_control_Read(struct file *file, char *buf, size_t nbytes, loff_t * ppos);
 
 ssize_t
-Novfs_Control_write(struct file *file, const char *buf, size_t nbytes,
+novfs_control_write(struct file *file, const char *buf, size_t nbytes,
 		    loff_t * ppos);
 
-int Novfs_Control_ioctl(struct inode *inode, struct file *file,
+int novfs_control_ioctl(struct inode *inode, struct file *file,
 			unsigned int cmd, unsigned long arg);
 
 int __init init_novfs(void);
 void __exit exit_novfs(void);
 
-int Novfs_lock_inode_cache(struct inode *i);
-void Novfs_unlock_inode_cache(struct inode *i);
-int Novfs_enumerate_inode_cache(struct inode *i, struct list_head **iteration,
-				ino_t * ino, struct entry_info *info);
-int Novfs_get_entry(struct inode *i, struct qstr *name, ino_t * ino,
-		    struct entry_info *info);
-int Novfs_get_entry_by_pos(struct inode *i, loff_t pos, ino_t * ino,
-			   struct entry_info *info);
-int Novfs_get_entry_time(struct inode *i, struct qstr *name, ino_t * ino,
-			 struct entry_info *info, u64 * EntryTime);
-int Novfs_get_remove_entry(struct inode *i, ino_t * ino, struct entry_info *info);
-void Novfs_invalidate_inode_cache(struct inode *i);
-static struct dir_cache *Novfs_lookup_inode_cache(struct inode *i, struct qstr *name, ino_t ino);
-int Novfs_lookup_validate(struct inode *i, struct qstr *name, ino_t ino);
-int Novfs_add_inode_entry(struct inode *i, struct qstr *name, ino_t ino,
-			  struct entry_info *info);
-int Novfs_update_entry(struct inode *i, struct qstr *name, ino_t ino,
-		       struct entry_info *info);
-void Novfs_remove_inode_entry(struct inode *i, struct qstr *name, ino_t ino);
-void Novfs_free_invalid_entries(struct inode *i);
-void Novfs_free_inode_cache(struct inode *i);
+int novfs_lock_inode_cache(struct inode *i);
+void novfs_unlock_inode_cache(struct inode *i);
+int novfs_enumerate_inode_cache(struct inode *i, struct list_head **iteration,
+				ino_t * ino, struct novfs_entry_info *info);
+int novfs_get_entry(struct inode *i, struct qstr *name, ino_t * ino,
+		    struct novfs_entry_info *info);
+int novfs_get_entry_by_pos(struct inode *i, loff_t pos, ino_t * ino,
+			   struct novfs_entry_info *info);
+int novfs_get_entry_time(struct inode *i, struct qstr *name, ino_t * ino,
+			 struct novfs_entry_info *info, u64 * EntryTime);
+int novfs_get_remove_entry(struct inode *i, ino_t * ino, struct novfs_entry_info *info);
+void novfs_invalidate_inode_cache(struct inode *i);
+struct novfs_dir_cache *novfs_lookup_inode_cache(struct inode *i, struct qstr *name,
+				    ino_t ino);
+int novfs_lookup_validate(struct inode *i, struct qstr *name, ino_t ino);
+int novfs_add_inode_entry(struct inode *i, struct qstr *name, ino_t ino,
+			  struct novfs_entry_info *info);
+int novfs_update_entry(struct inode *i, struct qstr *name, ino_t ino,
+		       struct novfs_entry_info *info);
+void novfs_remove_inode_entry(struct inode *i, struct qstr *name, ino_t ino);
+void novfs_free_invalid_entries(struct inode *i);
+void novfs_free_inode_cache(struct inode *i);
 
 /*===[ Global variables ]=================================================*/
-struct dentry_operations Novfs_dentry_operations = {
-	.d_revalidate = Novfs_d_revalidate,
-	.d_hash = Novfs_d_hash,
-	.d_compare = Novfs_d_compare,
-	//.d_delete      = Novfs_d_delete,
-	.d_release = Novfs_d_release,
-	.d_iput = Novfs_d_iput,
+struct dentry_operations novfs_dentry_operations = {
+	.d_revalidate = novfs_d_revalidate,
+	.d_hash = novfs_d_hash,
+	.d_compare = novfs_d_compare,
+	//.d_delete      = novfs_d_delete,
+	.d_release = novfs_d_release,
+	.d_iput = novfs_d_iput,
 };
 
-struct file_operations Novfs_dir_operations = {
+struct file_operations novfs_dir_operations = {
 	.owner = THIS_MODULE,
-	.open = Novfs_dir_open,
-	.release = Novfs_dir_release,
-	.llseek = Novfs_dir_lseek,
-	.read = Novfs_dir_read,
-	.readdir = Novfs_dir_readdir,
-	.fsync = Novfs_dir_fsync,
+	.open = novfs_dir_open,
+	.release = novfs_dir_release,
+	.llseek = novfs_dir_lseek,
+	.read = novfs_dir_read,
+	.readdir = novfs_dir_readdir,
+	.fsync = novfs_dir_fsync,
 };
 
-static struct file_operations Novfs_file_operations = {
+static struct file_operations novfs_file_operations = {
 	.owner = THIS_MODULE,
-	.read = Novfs_f_read,
-	.write = Novfs_f_write,
-	.readdir = Novfs_f_readdir,
-	.ioctl = Novfs_f_ioctl,
-	.mmap = Novfs_f_mmap,
-	.open = Novfs_f_open,
-	.flush = Novfs_f_flush,
-	.release = Novfs_f_release,
-	.fsync = Novfs_f_fsync,
+	.read = novfs_f_read,
+	.write = novfs_f_write,
+	.readdir = novfs_f_readdir,
+	.ioctl = novfs_f_ioctl,
+	.mmap = novfs_f_mmap,
+	.open = novfs_f_open,
+	.flush = novfs_f_flush,
+	.release = novfs_f_release,
+	.fsync = novfs_f_fsync,
 	.llseek = generic_file_llseek,
-	.lock = Novfs_f_lock,
+	.lock = novfs_f_lock,
 };
 
-static struct address_space_operations Novfs_nocache_aops = {
-	.readpage = Novfs_a_readpage,
+static struct address_space_operations novfs_nocache_aops = {
+	.readpage = novfs_a_readpage,
 };
 
-struct backing_dev_info Novfs_backing_dev_info = {
+struct backing_dev_info novfs_backing_dev_info = {
 	.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE,
 	.state = 0,
 	.capabilities = BDI_CAP_NO_WRITEBACK | BDI_CAP_MAP_COPY,
 	.unplug_io_fn = default_unplug_io_fn,
 };
 
-static struct address_space_operations Novfs_aops = {
-	.readpage = Novfs_a_readpage,
-	.readpages = Novfs_a_readpages,
-	.writepage = Novfs_a_writepage,
-	.writepages = Novfs_a_writepages,
-	.prepare_write = Novfs_a_prepare_write,
-	.commit_write = Novfs_a_commit_write,
+static struct address_space_operations novfs_aops = {
+	.readpage = novfs_a_readpage,
+	.readpages = novfs_a_readpages,
+	.writepage = novfs_a_writepage,
+	.writepages = novfs_a_writepages,
+	.prepare_write = novfs_a_prepare_write,
+	.commit_write = novfs_a_commit_write,
 	.set_page_dirty = __set_page_dirty_nobuffers,
-	.direct_IO = Novfs_a_direct_IO,
+	.direct_IO = novfs_a_direct_IO,
 };
 
-static struct inode_operations Novfs_inode_operations = {
-	.create = Novfs_i_create,
-	.lookup = Novfs_i_lookup,
-	.unlink = Novfs_i_unlink,
-	.mkdir = Novfs_i_mkdir,
-	.rmdir = Novfs_i_rmdir,
-	.mknod = Novfs_i_mknod,
-	.rename = Novfs_i_rename,
-	.setattr = Novfs_i_setattr,
-	.getattr = Novfs_i_getattr,
-/*
-	.getxattr = Novfs_i_getxattr,
-	.setxattr = Novfs_i_setxattr,
-	.listxattr = Novfs_i_listxattr,
+static struct inode_operations novfs_inode_operations = {
+	.create = novfs_i_create,
+	.lookup = novfs_i_lookup,
+	.unlink = novfs_i_unlink,
+	.mkdir = novfs_i_mkdir,
+	.rmdir = novfs_i_rmdir,
+	.mknod = novfs_i_mknod,
+	.rename = novfs_i_rename,
+	.setattr = novfs_i_setattr,
+	.getattr = novfs_i_getattr,
+/*
+	.getxattr = novfs_i_getxattr,
+	.setxattr = novfs_i_setxattr,
+	.listxattr = novfs_i_listxattr,
 */
 };
 
-static struct inode_operations Novfs_file_inode_operations = {
-	.setattr = Novfs_i_setattr,
-	.getattr = Novfs_i_getattr,
-/*
-	.getxattr = Novfs_i_getxattr,
-	.setxattr = Novfs_i_setxattr,
-	.listxattr = Novfs_i_listxattr,
+static struct inode_operations novfs_file_inode_operations = {
+	.setattr = novfs_i_setattr,
+	.getattr = novfs_i_getattr,
+/*
+	.getxattr = novfs_i_getxattr,
+	.setxattr = novfs_i_setxattr,
+	.listxattr = novfs_i_listxattr,
 */
 };
 
-static struct super_operations Novfs_ops = {
-	.statfs = Novfs_statfs,
-	.clear_inode = Novfs_clear_inode,
+static struct super_operations novfs_ops = {
+	.statfs = novfs_statfs,
+	.clear_inode = novfs_clear_inode,
 	.drop_inode = generic_delete_inode,
-	.show_options = Novfs_show_options,
+	.show_options = novfs_show_options,
 
 };
 
 /* Not currently used
-static struct file_operations Novfs_Control_operations = {
-   .read    = Novfs_Control_read,
-   .write   = Novfs_Control_write,
-   .ioctl   = Novfs_Control_ioctl,
+static struct file_operations novfs_Control_operations = {
+   .read    = novfs_Control_read,
+   .write   = novfs_Control_write,
+   .ioctl   = novfs_Control_ioctl,
 };
 */
 
-static atomic_t Novfs_Inode_Number = ATOMIC_INIT(0);
-
-struct dentry *Novfs_root = NULL;
+static atomic_t novfs_Inode_Number = ATOMIC_INIT(0);
 
-int Novfs_Version_Major = NOVFS_VFS_MAJOR;
-int Novfs_Version_Minor = NOVFS_VFS_MINOR;
-int Novfs_Version_Sub = NOVFS_VFS_SUB;
-int Novfs_Version_Release = NOVFS_VFS_RELEASE;
 
-char *Novfs_CurrentMount = NULL;
+struct dentry *novfs_root = NULL;
+char *novfs_current_mnt = NULL;
 
 DECLARE_MUTEX(InodeList_lock);
 
@@ -346,18 +313,13 @@ uint64_t inHAXTime;
 int inHAX;
 
 unsigned long InodeCount = 0, DCCount = 0;
-unsigned long File_update_timeout = FILE_UPDATE_TIMEOUT;
-int PageCache = 0;
+unsigned long novfs_update_timeout = FILE_UPDATE_TIMEOUT;
+int novfs_page_cache = 0;
 
-typedef struct _Novfs_List2 {
-	struct list_head list;
-	void *data;
-} Novfs_List2;
-
-typedef struct _File_Private2 {
+struct file_private {
 	int listedall;
-	HANDLE enumHandle;
-} FilePrivate2;
+	void *enumHandle;
+};
 
 static void PRINT_DENTRY(const char *s, struct dentry *d)
 {
@@ -370,8 +332,8 @@ static void PRINT_DENTRY(const char *s,
 		 "      prev:      0x%p\n", &d->d_lru, d->d_lru.next,
 		 d->d_lru.prev);
 	DbgPrint("   d_child:      0x%p\n" "      next:      0x%p\n"
-		 "      prev:      0x%p\n", &d->D_CHILD, d->D_CHILD.next,
-		 d->D_CHILD.prev);
+		 "      prev:      0x%p\n", &d->d_u.d_child,
+		 d->d_u.d_child.next, d->d_u.d_child.prev);
 	DbgPrint("   d_subdirs:    0x%p\n" "      next:      0x%p\n"
 		 "      prev:      0x%p\n", &d->d_subdirs, d->d_subdirs.next,
 		 d->d_subdirs.prev);
@@ -397,144 +359,109 @@ static void PRINT_DENTRY(const char *s,
 }
 
 /*++======================================================================*/
-int Novfs_Remove_from_Root(char *RemoveName)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_remove_from_root(char *RemoveName)
 {
 	struct qstr name;
 	struct dentry *dentry;
 	struct inode *dir;
 
-	DbgPrint("Novfs_Remove_from_Root: %s\n", RemoveName);
+	DbgPrint("novfs_Remove_from_Root: %s\n", RemoveName);
 	name.len = strlen(RemoveName);
 	name.name = RemoveName;
-	Novfs_d_hash(Novfs_root, &name);
+	novfs_d_hash(novfs_root, &name);
 
-	dentry = d_lookup(Novfs_root, &name);
+	dentry = d_lookup(novfs_root, &name);
 	if (dentry) {
-		if (dentry->d_inode && dentry->d_inode->FSPRIVATE) {
-			((struct inode_data *)(dentry->d_inode->FSPRIVATE))->Scope =
-			    NULL;
+		if (dentry->d_inode && dentry->d_inode->i_private) {
+			struct inode_data *n_inode =
+				dentry->d_inode->i_private;
+			n_inode->Scope = NULL;
 		}
 		dput(dentry);
 	}
 
-	dir = Novfs_root->d_inode;
+	dir = novfs_root->d_inode;
 
-	Novfs_lock_inode_cache(dir);
-	Novfs_remove_inode_entry(dir, &name, 0);
-	Novfs_unlock_inode_cache(dir);
+	novfs_lock_inode_cache(dir);
+	novfs_remove_inode_entry(dir, &name, 0);
+	novfs_unlock_inode_cache(dir);
 
 	return (0);
 }
 
 /*++======================================================================*/
-int Novfs_Add_to_Root(char *AddName)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_add_to_root(char *AddName)
 {
 	struct qstr name;
 	struct inode *dir;
-	struct entry_info info;
+	struct novfs_entry_info info;
 	ino_t ino;
 
-	DbgPrint("Novfs_Add_to_Root: %s\n", AddName);
+	DbgPrint("novfs_Add_to_Root: %s\n", AddName);
 	name.len = strlen(AddName);
 	name.name = AddName;
-	Novfs_d_hash(Novfs_root, &name);
+	novfs_d_hash(novfs_root, &name);
 
-	dir = Novfs_root->d_inode;
+	dir = novfs_root->d_inode;
 
-	Novfs_lock_inode_cache(dir);
+	novfs_lock_inode_cache(dir);
 
 	ino = 0;
 
-	if (!Novfs_lookup_inode_cache(dir, &name, 0)) {
+	if (!novfs_lookup_inode_cache(dir, &name, 0)) {
 		info.mode = S_IFDIR | 0700;
 		info.size = 0;
 		info.atime = info.ctime = info.mtime = CURRENT_TIME;
 
-		ino = (ino_t)atomic_inc_return(&Novfs_Inode_Number);
-		Novfs_add_inode_entry(dir, &name, ino, &info);
+		ino = (ino_t)atomic_inc_return(&novfs_Inode_Number);
+		novfs_add_inode_entry(dir, &name, ino, &info);
 	}
 
-	Novfs_unlock_inode_cache(dir);
+	novfs_unlock_inode_cache(dir);
 
 	return (0);
 }
 
 /*++======================================================================*/
-int Novfs_Add_to_Root2(char *AddName)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_Add_to_Root2(char *AddName)
 {
 	struct dentry *entry;
 	struct qstr name;
 	struct inode *inode;
 	void *scope;
 
-	DbgPrint("Novfs_Add_to_Root: %s\n", AddName);
+	DbgPrint("novfs_Add_to_Root: %s\n", AddName);
 	name.len = strlen(AddName);
 	name.name = AddName;
 
-	Novfs_d_hash(Novfs_root, &name);
+	novfs_d_hash(novfs_root, &name);
 
-	entry = Novfs_d_lookup(Novfs_root, &name);
-	DbgPrint("Novfs_Add_to_Root: Novfs_d_lookup 0x%p\n", entry);
+	entry = d_lookup(novfs_root, &name);
+	DbgPrint("novfs_Add_to_Root: novfs_d_lookup 0x%p\n", entry);
 	if (NULL == entry) {
-		scope = Scope_Lookup();
+		scope = novfs_scope_lookup();
 
-		entry = d_alloc(Novfs_root, &name);
-		DbgPrint("Novfs_Add_to_Root: d_alloc 0x%p\n", entry);
+		entry = d_alloc(novfs_root, &name);
+		DbgPrint("novfs_Add_to_Root: d_alloc 0x%p\n", entry);
 		if (entry) {
-			entry->d_op = &Novfs_dentry_operations;
-			entry->d_time = jiffies + (File_update_timeout * HZ);
+			entry->d_op = &novfs_dentry_operations;
+			entry->d_time = jiffies + (novfs_update_timeout * HZ);
 			/*
-			 * done in Novfs_d_add now... entry->d_fsdata = (void *)Novfs_internal_hash( &name );
+			 * done in novfs_d_add now... entry->d_fsdata = (void *)novfs_internal_hash( &name );
 			 */
 			inode =
-			    Novfs_get_inode(Novfs_root->d_sb, S_IFDIR | 0700, 0, Scope_Get_Uid(scope), 0, &name);
-			DbgPrint("Novfs_Add_to_Root: Inode=0x%p\n", inode);
+			    novfs_get_inode(novfs_root->d_sb, S_IFDIR | 0700, 0, novfs_scope_get_uid(scope), 0, &name);
+			DbgPrint("novfs_Add_to_Root: Inode=0x%p\n", inode);
 			if (inode) {
 				inode->i_atime =
 				    inode->i_ctime =
 				    inode->i_mtime = CURRENT_TIME;
-				if (!Novfs_d_add(Novfs_root, entry, inode, 1)) {
-					if (inode->FSPRIVATE) {
-						((struct inode_data *) inode->
-						 FSPRIVATE)->Flags = USER_INODE;
+				if (!novfs_d_add(novfs_root, entry, inode, 1)) {
+					if (inode->i_private) {
+						struct inode_data *n_inode = inode->i_private;
+						n_inode->Flags = USER_INODE;
 					}
-					PRINT_DENTRY("After Novfs_d_add",
+					PRINT_DENTRY("After novfs_d_add",
 						     entry);
 				} else {
 					dput(entry);
@@ -544,27 +471,12 @@ int Novfs_Add_to_Root2(char *AddName)
 		}
 	} else {
 		dput(entry);
-		PRINT_DENTRY("Novfs_Add_to_Root: After dput Dentry", entry);
+		PRINT_DENTRY("novfs_Add_to_Root: After dput Dentry", entry);
 	}
 	return (0);
 }
 
-/*++======================================================================*/
-char *Novfs_dget_path(struct dentry *Dentry, char *Buf, unsigned int Buflen)
-/*
- *  Arguments:   struct dentry *Dentry - starting entry
- *               char *Buf - pointer to memory buffer
- *               unsigned int Buflen - size of memory buffer
- *
- *  Returns:     pointer to path.
- *
- *  Abstract:    Walks the dentry chain building a path.
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+char *novfs_dget_path(struct dentry *Dentry, char *Buf, unsigned int Buflen)
 {
 	char *retval = &Buf[Buflen];
 	struct dentry *p = Dentry;
@@ -591,34 +503,17 @@ char *Novfs_dget_path(struct dentry *Den
 	}
 
 	if (retval)
-		DbgPrint("Novfs_dget_path: %s\n", retval);
+		DbgPrint("novfs_dget_path: %s\n", retval);
 	return (retval);
 }
 
-/*++======================================================================*/
 int verify_dentry(struct dentry *dentry, int Flags)
-/*
- *  Arguments:   struct dentry *dentry - entry to verify
- *
- *  Returns:     zero - Inode cache has been updated.  If not in the cache
- *                      then file doesn't exist.
- *               !zero - Error
- *
- *  Abstract:    This routine will verify if the file that dentry is pointing
- *               at exist and if it does it will put it in the inode cache of
- *               the parent.
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	int retVal = -ENOENT;
 	struct inode *dir;
-	struct entry_info *info = NULL;
+	struct novfs_entry_info *info = NULL;
 	struct inode_data *id;
-	session_t session;
+	struct novfs_schandle session;
 	char *path, *list = NULL, *cp;
 	ino_t ino = 0;
 	struct qstr name;
@@ -633,19 +528,19 @@ int verify_dentry(struct dentry *dentry,
 	}
 
 	if (dentry && dentry->d_parent &&
-	    (dir = dentry->d_parent->d_inode) && (id = dir->FSPRIVATE)) {
+	    (dir = dentry->d_parent->d_inode) && (id = dir->i_private)) {
 		parent = dget_parent(dentry);
 
-		info = Novfs_Malloc(sizeof(struct entry_info) + PATH_LENGTH_BUFFER, GFP_KERNEL);
+		info = kmalloc(sizeof(struct novfs_entry_info) + PATH_LENGTH_BUFFER, GFP_KERNEL);
 
 		if (info) {
-			if (Novfs_lock_inode_cache(dir)) {
+			if (novfs_lock_inode_cache(dir)) {
 				name.len = dentry->d_name.len;
 				name.name = dentry->d_name.name;
-				name.hash = Novfs_internal_hash(&name);
-				if (!Novfs_get_entry_time(dir, &name, &ino, info, &ctime)) {
+				name.hash = novfs_internal_hash(&name);
+				if (!novfs_get_entry_time(dir, &name, &ino, info, &ctime)) {
 					inode = dentry->d_inode;
-					if (inode && inode->FSPRIVATE &&
+					if (inode && inode->i_private &&
 					    ((inode->i_size != info->size) ||
 					     (inode->i_mtime.tv_sec !=
 					      info->mtime.tv_sec)
@@ -654,30 +549,31 @@ int verify_dentry(struct dentry *dentry,
 						/*
 						 * Values don't match so update.
 						 */
-						((struct inode_data *) inode->FSPRIVATE)->Flags |= UPDATE_INODE;
+						struct inode_data *n_inode = inode->i_private;
+						n_inode->Flags |= UPDATE_INODE;
 					}
 
 					ctime = get_jiffies_64() - ctime;
-					if (Flags || ctime < (u64) (File_update_timeout * HZ)) {
+					if (Flags || ctime < (u64) (novfs_update_timeout * HZ)) {
 						retVal = 0;
-						Novfs_unlock_inode_cache(dir);
+						novfs_unlock_inode_cache(dir);
 						dput(parent);
 						kfree(info);
 						return (0);
 					}
 				}
-				Novfs_unlock_inode_cache(dir);
+				novfs_unlock_inode_cache(dir);
 			}
 
 			if (IS_ROOT(dentry->d_parent)) {
-				session = Scope_Get_SessionId(Scope_Get_ScopefromName(&dentry->d_name));
-			} else {
-				session = Scope_Get_SessionId(id->Scope);
-			}
+				session =	novfs_scope_get_sessionId(
+				novfs_get_scope_from_name(&dentry->d_name));
+			} else
+				session = novfs_scope_get_sessionId(id->Scope);
 
 			if (!SC_PRESENT(session)) {
-				id->Scope = Scope_Get_ScopefromPath(dentry);
-				session = Scope_Get_SessionId(id->Scope);
+				id->Scope = novfs_get_scope(dentry);
+				session = novfs_scope_get_sessionId(id->Scope);
 			}
 
 			ino = 0;
@@ -685,62 +581,65 @@ int verify_dentry(struct dentry *dentry,
 
 			if (IS_ROOT(dentry->d_parent)) {
 				DbgPrint("verify_dentry: parent is Root directory\n");
-				list = Scope_Get_ScopeUsers();
+				list = novfs_get_scopeusers();
 
-				iLock = Novfs_lock_inode_cache(dir);
-				Novfs_invalidate_inode_cache(dir);
+				iLock = novfs_lock_inode_cache(dir);
+				novfs_invalidate_inode_cache(dir);
 
 				if (list) {
 					cp = list;
 					while (*cp) {
 						name.name = cp;
 						name.len = strlen(cp);
-						name.hash = Novfs_internal_hash(&name);
+						name.hash = novfs_internal_hash(&name);
 						cp += (name.len + 1);
 						ino = 0;
-						if (Novfs_get_entry(dir, &name, &ino, info)) {
+						if (novfs_get_entry(dir, &name, &ino, info)) {
 							info->mode = S_IFDIR | 0700;
 							info->size = 0;
 							info->atime = info->ctime = info->mtime = CURRENT_TIME;
-							ino = (ino_t)atomic_inc_return(&Novfs_Inode_Number);
-							Novfs_add_inode_entry(dir, &name, ino, info);
+							ino = (ino_t)atomic_inc_return(&novfs_Inode_Number);
+							novfs_add_inode_entry(dir, &name, ino, info);
 						}
 					}
 				}
-				Novfs_free_invalid_entries(dir);
+				novfs_free_invalid_entries(dir);
 			} else {
 
 				path =
-				    Novfs_dget_path(dentry, info->name,
+				    novfs_dget_path(dentry, info->name,
 						    PATH_LENGTH_BUFFER);
 				if (path) {
 					if (dentry->d_name.len <=
 					    NW_MAX_PATH_LENGTH) {
 						name.hash =
-						    Novfs_internal_hash
+						    novfs_internal_hash
 						    (&dentry->d_name);
 						name.len = dentry->d_name.len;
 						name.name = dentry->d_name.name;
 
-						retVal = Novfs_Get_File_Info(path, info, &session);
+						retVal =
+						    novfs_get_file_info(path,
+									info,
+									session);
 						if (0 == retVal) {
 							dentry->d_time =
 							    jiffies +
-							    (File_update_timeout
+							    (novfs_update_timeout
 							     * HZ);
 							iLock =
-							    Novfs_lock_inode_cache
+							    novfs_lock_inode_cache
 							    (dir);
-							if (Novfs_update_entry
+							if (novfs_update_entry
 							    (dir, &name, 0,
 							     info)) {
 								if (dentry->
 								    d_inode) {
 									ino = dentry->d_inode->i_ino;
 								} else {
-									ino = (ino_t)atomic_inc_return(&Novfs_Inode_Number);
+									ino = (ino_t)atomic_inc_return(&novfs_Inode_Number);
 								}
-								Novfs_add_inode_entry
+								novfs_add_inode_entry
 								    (dir, &name,
 								     ino, info);
 							}
@@ -758,14 +657,14 @@ int verify_dentry(struct dentry *dentry,
 								    ~S_DEAD;
 								if (dentry->
 								    d_inode->
-								    FSPRIVATE) {
-									((struct inode_data *) dentry->d_inode->FSPRIVATE)->Scope = id->Scope;
+								    i_private) {
+									((struct inode_data *) dentry->d_inode->i_private)->Scope = id->Scope;
 								}
 							}
 						} else if (-EINTR != retVal) {
 							retVal = 0;
-							iLock = Novfs_lock_inode_cache(dir);
-							Novfs_remove_inode_entry(dir, &name, 0);
+							iLock = novfs_lock_inode_cache(dir);
+							novfs_remove_inode_entry(dir, &name, 0);
 							if (dentry->d_inode
 							    && !(dentry->d_inode->i_flags & S_DEAD)) {
 								dentry->d_inode->i_flags |= S_DEAD;
@@ -789,7 +688,7 @@ int verify_dentry(struct dentry *dentry,
 			retVal = -ENOMEM;
 		}
 		if (iLock) {
-			Novfs_unlock_inode_cache(dir);
+			novfs_unlock_inode_cache(dir);
 		}
 		dput(parent);
 	}
@@ -804,67 +703,37 @@ int verify_dentry(struct dentry *dentry,
 	return (retVal);
 }
 
-/*++======================================================================*/
-struct dentry *Novfs_d_lookup(struct dentry *Parent, struct qstr *Name)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	return (d_lookup(Parent, Name));
-}
 
-/*++======================================================================*/
-int Novfs_d_add(struct dentry *Parent, struct dentry *d, struct inode *i, int a)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+static int novfs_d_add(struct dentry *Parent, struct dentry *d, struct inode *i, int a)
 {
 	void *scope;
 	struct inode_data *id = NULL;
 
 	char *path, *buf;
 
-	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	if (buf) {
-		path = Novfs_dget_path(d, buf, PATH_LENGTH_BUFFER);
+		path = novfs_dget_path(d, buf, PATH_LENGTH_BUFFER);
 		if (path) {
-			DbgPrint("Novfs_d_add: inode=0x%p ino=%d path %s\n", i,
+			DbgPrint("novfs_d_add: inode=0x%p ino=%d path %s\n", i,
 				 i->i_ino, path);
 		}
 		kfree(buf);
 	}
 
-	if (Parent && Parent->d_inode && Parent->d_inode->FSPRIVATE) {
-		id = (struct inode_data *) Parent->d_inode->FSPRIVATE;
+	if (Parent && Parent->d_inode && Parent->d_inode->i_private) {
+		id = (struct inode_data *) Parent->d_inode->i_private;
 	}
 
 	if (id && id->Scope) {
 		scope = id->Scope;
 	} else {
-		scope = Scope_Get_ScopefromPath(d);
+		scope = novfs_get_scope(d);
 	}
 
-	((struct inode_data *) i->FSPRIVATE)->Scope = scope;
+	((struct inode_data *) i->i_private)->Scope = scope;
 
-	d->d_time = jiffies + (File_update_timeout * HZ);
+	d->d_time = jiffies + (novfs_update_timeout * HZ);
 	if (a) {
 		d_add(d, i);
 	} else {
@@ -874,29 +743,14 @@ int Novfs_d_add(struct dentry *Parent, s
 	return (0);
 }
 
-/*++======================================================================*/
-int Novfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
-/*
- *  Arguments:   struct dentry *dentry - pointer to dentry to revalidate.
- *               struct nameidata *nd - pointer to nameidata.
- *
- *  Returns:     zero - dentry is not valid.
- *               !zero - valid entry
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
 {
 	int retCode = 0;
 	struct inode *dir;
 	struct inode_data *id;
 	struct qstr name;
 
-	DbgPrint("Novfs_d_revalidate: 0x%p %.*s\n"
+	DbgPrint("novfs_d_revalidate: 0x%p %.*s\n"
 		 "   d_count: %d\n"
 		 "   d_inode: 0x%p\n",
 		 dentry, dentry->d_name.len, dentry->d_name.name,
@@ -908,7 +762,7 @@ int Novfs_d_revalidate(struct dentry *de
 		if (dentry->d_inode &&
 		    dentry->d_parent &&
 		    (dir = dentry->d_parent->d_inode) &&
-		    (id = dir->FSPRIVATE)) {
+		    (id = dir->i_private)) {
 			/*
 			 * Check timer to see if in valid time limit
 			 */
@@ -919,20 +773,20 @@ int Novfs_d_revalidate(struct dentry *de
 				name.len = dentry->d_name.len;
 				name.name = dentry->d_name.name;
 				name.hash =
-				    Novfs_internal_hash(&dentry->d_name);
+				    novfs_internal_hash(&dentry->d_name);
 				dentry->d_time = 0;
 
 				if (0 == verify_dentry(dentry, 0)) {
-					if (Novfs_lock_inode_cache(dir)) {
-						if (Novfs_lookup_inode_cache
+					if (novfs_lock_inode_cache(dir)) {
+						if (novfs_lookup_inode_cache
 						    (dir, &name, 0)) {
 							dentry->d_time =
 							    jiffies +
-							    (File_update_timeout
+							    (novfs_update_timeout
 							     * HZ);
 							retCode = 1;
 						}
-						Novfs_unlock_inode_cache(dir);
+						novfs_unlock_inode_cache(dir);
 					}
 				}
 			} else {
@@ -949,26 +803,13 @@ int Novfs_d_revalidate(struct dentry *de
 */
 	}
 
-	DbgPrint("Novfs_d_revalidate: return 0x%x %.*s\n", retCode,
+	DbgPrint("novfs_d_revalidate: return 0x%x %.*s\n", retCode,
 		 dentry->d_name.len, dentry->d_name.name);
 
 	return (retCode);
 }
 
-/*++======================================================================*/
-unsigned long Novfs_internal_hash(struct qstr *name)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+static unsigned long novfs_internal_hash(struct qstr *name)
 {
 	unsigned long hash = 0;
 	unsigned int len = name->len;
@@ -984,48 +825,22 @@ unsigned long Novfs_internal_hash(struct
 	return (hash);
 }
 
-/*++======================================================================*/
-int Novfs_d_hash(struct dentry *dentry, struct qstr *name)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_d_hash(struct dentry *dentry, struct qstr *name)
 {
-	DbgPrint("Novfs_d_hash: %.*s\n", name->len, name->name);
+	DbgPrint("novfs_d_hash: %.*s\n", name->len, name->name);
 
-	name->hash = Novfs_internal_hash(name);
+	name->hash = novfs_internal_hash(name);
 
 	return (0);
 }
 
-/*++======================================================================*/
-int Novfs_d_strcmp(struct qstr *s1, struct qstr *s2)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_d_strcmp(struct qstr *s1, struct qstr *s2)
 {
 	int retCode = 1;
 	unsigned char *str1, *str2;
 	unsigned int len;
 
-	DbgPrint("Novfs_d_strcmp: s1=%.*s s2=%.*s\n", s1->len, s1->name,
+	DbgPrint("novfs_d_strcmp: s1=%.*s s2=%.*s\n", s1->len, s1->name,
 		 s2->len, s2->name);
 
 	if (s1->len && (s1->len == s2->len) && (s1->hash == s2->hash)) {
@@ -1042,51 +857,25 @@ int Novfs_d_strcmp(struct qstr *s1, stru
 		}
 	}
 
-	DbgPrint("Novfs_d_strcmp: retCode=0x%x\n", retCode);
+	DbgPrint("novfs_d_strcmp: retCode=0x%x\n", retCode);
 	return (retCode);
 }
 
-/*++======================================================================*/
-int Novfs_d_compare(struct dentry *parent, struct qstr *s1, struct qstr *s2)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_d_compare(struct dentry *parent, struct qstr *s1, struct qstr *s2)
 {
 	int retCode;
 
-	retCode = Novfs_d_strcmp(s1, s2);
+	retCode = novfs_d_strcmp(s1, s2);
 
-	DbgPrint("Novfs_d_compare: retCode=0x%x\n", retCode);
+	DbgPrint("novfs_d_compare: retCode=0x%x\n", retCode);
 	return (retCode);
 }
 
-/*++======================================================================*/
-int Novfs_d_delete(struct dentry *dentry)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_d_delete(struct dentry *dentry)
 {
 	int retVal = 0;
 
-	DbgPrint("Novfs_d_delete: 0x%p %.*s\n"
+	DbgPrint("novfs_d_delete: 0x%p %.*s\n"
 		 "   d_count: %d\n"
 		 "   d_inode: 0x%p\n",
 		 dentry, dentry->d_name.len, dentry->d_name.name,
@@ -1101,42 +890,16 @@ int Novfs_d_delete(struct dentry *dentry
 	return (retVal);
 }
 
-/*++======================================================================*/
-void Novfs_d_release(struct dentry *dentry)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+void novfs_d_release(struct dentry *dentry)
 {
-	DbgPrint("Novfs_d_release: 0x%p %.*s\n", dentry, dentry->d_name.len,
+	DbgPrint("novfs_d_release: 0x%p %.*s\n", dentry, dentry->d_name.len,
 		 dentry->d_name.name);
 }
 
-/*++======================================================================*/
-void Novfs_d_iput(struct dentry *dentry, struct inode *inode)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+void novfs_d_iput(struct dentry *dentry, struct inode *inode)
 {
 	DbgPrint
-	    ("Novfs_d_iput: Inode=0x%p Ino=%d Dentry=0x%p i_state=%d Name=%.*s\n",
+	    ("novfs_d_iput: Inode=0x%p Ino=%d Dentry=0x%p i_state=%d Name=%.*s\n",
 	     inode, inode->i_ino, dentry, inode->i_state, dentry->d_name.len,
 	     dentry->d_name.name);
 
@@ -1144,37 +907,24 @@ void Novfs_d_iput(struct dentry *dentry,
 
 }
 
-/*++======================================================================*/
-int Novfs_dir_open(struct inode *dir, struct file *file)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_dir_open(struct inode *dir, struct file *file)
 {
 	char *path, *buf;
-	FilePrivate2 *file_private = NULL;
+	struct file_private *file_private = NULL;
 
-	DbgPrint("Novfs_dir_open: Inode 0x%p %d Name %.*s\n", dir, dir->i_ino,
+	DbgPrint("novfs_dir_open: Inode 0x%p %d Name %.*s\n", dir, dir->i_ino,
 		 file->f_dentry->d_name.len, file->f_dentry->d_name.name);
 
-	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	if (buf) {
-		path = Novfs_dget_path(file->f_dentry, buf, PATH_LENGTH_BUFFER);
+		path = novfs_dget_path(file->f_dentry, buf, PATH_LENGTH_BUFFER);
 		if (path) {
-			DbgPrint("Novfs_dir_open: path %s\n", path);
+			DbgPrint("novfs_dir_open: path %s\n", path);
 		}
 		kfree(buf);
 	}
 
-	file_private = Novfs_Malloc(sizeof(FilePrivate2), GFP_KERNEL);
+	file_private = kmalloc(sizeof(struct file_private), GFP_KERNEL);
 	file_private->listedall = 0;
 	file_private->enumHandle = NULL;
 
@@ -1183,25 +933,12 @@ int Novfs_dir_open(struct inode *dir, st
 	return (0);
 }
 
-/*++======================================================================*/
-int Novfs_dir_release(struct inode *dir, struct file *file)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_dir_release(struct inode *dir, struct file *file)
 {
-	FilePrivate2 *file_private;
-	file_private = (FilePrivate2 *) file->private_data;
+	struct file_private *file_private;
+	file_private = (struct file_private *) file->private_data;
 
-	DbgPrint("Novfs_dir_release: Inode 0x%p %d Name %.*s\n", dir,
+	DbgPrint("novfs_dir_release: Inode 0x%p %d Name %.*s\n", dir,
 		 dir->i_ino, file->f_dentry->d_name.len,
 		 file->f_dentry->d_name.name);
 
@@ -1213,24 +950,11 @@ int Novfs_dir_release(struct inode *dir,
 	return (0);
 }
 
-/*++======================================================================*/
-loff_t Novfs_dir_lseek(struct file * file, loff_t offset, int origin)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+loff_t novfs_dir_lseek(struct file * file, loff_t offset, int origin)
 {
-	FilePrivate2 *file_private = NULL;
+	struct file_private *file_private = NULL;
 
-	DbgPrint("Novfs_dir_lseek: offset %lld %d Name %.*s\n", offset, origin,
+	DbgPrint("novfs_dir_lseek: offset %lld %d Name %.*s\n", offset, origin,
 		 file->f_dentry->d_name.len, file->f_dentry->d_name.name);
 	//printk("<1> seekdir file = %.*s offset = %i\n", file->f_dentry->d_name.len, file->f_dentry->d_name.name, (int)offset);
 
@@ -1240,7 +964,7 @@ loff_t Novfs_dir_lseek(struct file * fil
 
 	file->f_pos = 0;
 
-	file_private = (FilePrivate2 *) file->private_data;
+	file_private = (struct file_private *) file->private_data;
 	file_private->listedall = 0;
 	file_private->enumHandle = NULL;
 
@@ -1248,25 +972,12 @@ loff_t Novfs_dir_lseek(struct file * fil
 	//return(default_llseek(file, offset, origin));
 }
 
-/*++======================================================================*/
-ssize_t Novfs_dir_read(struct file * file, char *buf, size_t len, loff_t * off)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+ssize_t novfs_dir_read(struct file * file, char *buf, size_t len, loff_t * off)
 {
 /*
    int rlen = 0;
 
-   DbgPrint("Novfs_dir_readdir: dentry path %.*s buf=0x%p len=%d off=%lld\n", file->f_dentry->d_name.len, file->f_dentry->d_name.name, buf, len, *off);
+   DbgPrint("novfs_dir_readdir: dentry path %.*s buf=0x%p len=%d off=%lld\n", file->f_dentry->d_name.len, file->f_dentry->d_name.name, buf, len, *off);
 
    if (0 == *off)
    {
@@ -1276,19 +987,19 @@ ssize_t Novfs_dir_read(struct file * fil
    }
    return(rlen);
 */
-	DbgPrint("Novfs_dir_read: %lld %d Name %.*s\n", *off, len,
+	DbgPrint("novfs_dir_read: %lld %d Name %.*s\n", *off, len,
 		 file->f_dentry->d_name.len, file->f_dentry->d_name.name);
 	return (generic_read_dir(file, buf, len, off));
 }
 
-static void Novfs_Dump_Info(struct entry_info *info)
+static void novfs_Dump_Info(struct novfs_entry_info *info)
 {
 	char atime_buf[32], mtime_buf[32], ctime_buf[32];
 	char namebuf[512];
 	int len = 0;
 
 	if (info == NULL) {
-		DbgPrint("Novfs_dir_readdir : Dump_Info info == NULL\n");
+		DbgPrint("novfs_dir_readdir : Dump_Info info == NULL\n");
 		return;
 	}
 
@@ -1304,42 +1015,29 @@ static void Novfs_Dump_Info(struct entry
 	ctime_r(&info->atime.tv_sec, atime_buf);
 	ctime_r(&info->mtime.tv_sec, mtime_buf);
 	ctime_r(&info->ctime.tv_sec, ctime_buf);
-	DbgPrint("Novfs_dir_readdir : type = %i\n", info->type);
-	DbgPrint("Novfs_dir_readdir : mode = %x\n", info->mode);
-	DbgPrint("Novfs_dir_readdir : uid = %d\n", info->uid);
-	DbgPrint("Novfs_dir_readdir : gid = %d\n", info->gid);
-	DbgPrint("Novfs_dir_readdir : size = %i\n", info->size);
-	DbgPrint("Novfs_dir_readdir : atime = %s\n", atime_buf);
-	DbgPrint("Novfs_dir_readdir : mtime = %s\n", mtime_buf);
-	DbgPrint("Novfs_dir_readdir : ctime = %s\n", ctime_buf);
-	DbgPrint("Novfs_dir_readdir : namelength = %i\n", info->namelength);
-	DbgPrint("Novfs_dir_readdir : name = %s\n", namebuf);
+	DbgPrint("novfs_dir_readdir : type = %i\n", info->type);
+	DbgPrint("novfs_dir_readdir : mode = %x\n", info->mode);
+	DbgPrint("novfs_dir_readdir : uid = %d\n", info->uid);
+	DbgPrint("novfs_dir_readdir : gid = %d\n", info->gid);
+	DbgPrint("novfs_dir_readdir : size = %i\n", info->size);
+	DbgPrint("novfs_dir_readdir : atime = %s\n", atime_buf);
+	DbgPrint("novfs_dir_readdir : mtime = %s\n", mtime_buf);
+	DbgPrint("novfs_dir_readdir : ctime = %s\n", ctime_buf);
+	DbgPrint("novfs_dir_readdir : namelength = %i\n", info->namelength);
+	DbgPrint("novfs_dir_readdir : name = %s\n", namebuf);
 }
 
-/*++======================================================================*/
 void processList(struct file *file, void *dirent, filldir_t filldir, char *list,
-		 int type, session_t SessionId)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+		 int type, struct novfs_schandle SessionId)
 {
 	unsigned char *path, *buf = NULL, *cp;
 	struct qstr name;
-	struct entry_info *pinfo = NULL;
+	struct novfs_entry_info *pinfo = NULL;
 
-	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	path = buf;
 	if (buf) {
-		path = Novfs_dget_path(file->f_dentry, buf, PATH_LENGTH_BUFFER);
+		path = novfs_dget_path(file->f_dentry, buf, PATH_LENGTH_BUFFER);
 		if (path) {
 			strcpy(buf, path);
 		}
@@ -1351,14 +1049,14 @@ void processList(struct file *file, void
 		cp = list;
 		while (*cp) {
 			name.name = cp;
-			DbgPrint("Novfs_dir_readdir : name.name = %s\n",
+			DbgPrint("novfs_dir_readdir : name.name = %s\n",
 				 name.name);
 			name.len = strlen(cp);
-			name.hash = Novfs_internal_hash(&name);
+			name.hash = novfs_internal_hash(&name);
 			cp += (name.len + 1);
 
 			pinfo =
-			    Novfs_Malloc(sizeof(struct entry_info) +
+			    kmalloc(sizeof(struct novfs_entry_info) +
 					 PATH_LENGTH_BUFFER, GFP_KERNEL);
 			pinfo->mode = S_IFDIR | 0700;
 			pinfo->size = 0;
@@ -1367,7 +1065,7 @@ void processList(struct file *file, void
 			strcpy(pinfo->name, name.name);
 			pinfo->namelength = name.len;
 
-			Novfs_Dump_Info(pinfo);
+			novfs_Dump_Info(pinfo);
 
 			filldir(dirent, pinfo->name, pinfo->namelength,
 				file->f_pos, file->f_pos, pinfo->mode >> 12);
@@ -1383,26 +1081,28 @@ void processList(struct file *file, void
 }
 
 int processEntries(struct file *file, void *dirent, filldir_t filldir,
-		   HANDLE * enumHandle, session_t sessionId)
+		   void ** enumHandle, struct novfs_schandle sessionId)
 {
 	unsigned char *path = NULL, *buf = NULL;
 	int count = 0, status = 0;
-	struct entry_info *pinfo = NULL;
-	struct entry_info *pInfoMem = NULL;
+	struct novfs_entry_info *pinfo = NULL;
+	struct novfs_entry_info *pInfoMem = NULL;
 
-	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	if (!buf) {
 		return -ENOMEM;
 	}
 
-	path = Novfs_dget_path(file->f_dentry, buf, PATH_LENGTH_BUFFER);
+	path = novfs_dget_path(file->f_dentry, buf, PATH_LENGTH_BUFFER);
 	if (!path) {
 		kfree(buf);
 		return -ENOMEM;
 	}
 	//NWSearchfiles
 	count = 0;
-	status = Novfs_Get_Directory_ListEx(path, enumHandle, &count, &pinfo, &sessionId);
+	status =
+	    novfs_get_dir_listex(path, enumHandle, &count, &pinfo,
+				       sessionId);
 	pInfoMem = pinfo;
 
 	if ((count == -1) || (count == 0) || (status != 0)) {
@@ -1416,7 +1116,7 @@ int processEntries(struct file *file, vo
 			file->f_pos, pinfo->mode >> 12);
 		file->f_pos += 1;
 
-		pinfo = (struct entry_info *)(pinfo->name + pinfo->namelength);
+		pinfo = (struct novfs_entry_info *) (pinfo->name + pinfo->namelength);
 	}
 
 	kfree(pInfoMem);
@@ -1424,32 +1124,19 @@ int processEntries(struct file *file, vo
 	return 0;
 }
 
-/*++======================================================================*/
-int Novfs_dir_readdir(struct file *file, void *dirent, filldir_t filldir)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_dir_readdir(struct file *file, void *dirent, filldir_t filldir)
 {
 	unsigned char *list = NULL;
 	int status = 0;		//-ENOMEM;
 	struct inode *inode = file->f_dentry->d_inode;
-	session_t sessionId;
+	struct novfs_schandle sessionId;
 	uid_t uid;
 	int type = 0;
-	FilePrivate2 *file_private = NULL;
+	struct file_private *file_private = NULL;
 	int lComm;
 
-	file_private = (FilePrivate2 *) file->private_data;
-	DbgPrint("Novfs_dir_readdir: Name %.*s\n", file->f_dentry->d_name.len,
+	file_private = (struct file_private *) file->private_data;
+	DbgPrint("novfs_dir_readdir: Name %.*s\n", file->f_dentry->d_name.len,
 		 file->f_dentry->d_name.name);
 
 	//printk("<1> file = %.*s\n", file->f_dentry->d_name.len, file->f_dentry->d_name.name);
@@ -1510,16 +1197,18 @@ int Novfs_dir_readdir(struct file *file,
 	}
 
 	inode = file->f_dentry->d_inode;
-	if (inode && inode->FSPRIVATE) {
+	if (inode && inode->i_private) {
 		sessionId =
-		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)-> Scope);
+		    novfs_scope_get_sessionId(((struct inode_data *) inode->i_private)->
+					Scope);
 		if (0 == SC_PRESENT(sessionId)) {
-			((struct inode_data *)inode->FSPRIVATE)->Scope =
-			    Scope_Get_ScopefromPath(file->f_dentry);
+			((struct inode_data *) inode->i_private)->Scope =
+			    novfs_get_scope(file->f_dentry);
 			sessionId =
-			    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+			    novfs_scope_get_sessionId(((struct inode_data *) inode->
+						 i_private)->Scope);
 		}
-		uid = Scope_Get_Uid(((struct inode_data *)inode->FSPRIVATE)->Scope);
+		uid = novfs_scope_get_uid(((struct inode_data *) inode->i_private)->Scope);
 	} else {
 		SC_INITIALIZE(sessionId);
 		uid = current->euid;
@@ -1530,19 +1219,19 @@ int Novfs_dir_readdir(struct file *file,
 	    IS_ROOT(file->f_dentry->d_parent->d_parent))	// Server
 	{
 		if (IS_ROOT(file->f_dentry)) {
-			DbgPrint("Novfs_dir_readdir: Root directory\n");
-			list = Scope_Get_ScopeUsers();
+			DbgPrint("novfs_dir_readdir: Root directory\n");
+			list = novfs_get_scopeusers();
 			type = USER_LIST;
 		} else if (IS_ROOT(file->f_dentry->d_parent)) {
 			DbgPrint
-			    ("Novfs_dir_readdir: Parent is Root directory\n");
-			Novfs_Get_Connected_Server_List(&list, &sessionId);
+			    ("novfs_dir_readdir: Parent is Root directory\n");
+			novfs_get_servers(&list, sessionId);
 			type = SERVER_LIST;
 		} else {
 			DbgPrint
-			    ("Novfs_dir_readdir: Parent-Parent is Root directory\n");
-			Novfs_Get_Server_Volume_List(&file->f_dentry->d_name,
-						     &list, &sessionId);
+			    ("novfs_dir_readdir: Parent-Parent is Root directory\n");
+			novfs_get_vols(&file->f_dentry->d_name,
+						     &list, sessionId);
 			type = VOLUME_LIST;
 		}
 
@@ -1580,76 +1269,46 @@ int Novfs_dir_readdir(struct file *file,
 	return 1;
 }
 
-/*++======================================================================*/
-int Novfs_dir_fsync(struct file *file, struct dentry *dentry, int datasync)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_dir_fsync(struct file *file, struct dentry *dentry, int datasync)
 {
-	DbgPrint("Novfs_dir_fsync: Name %.*s\n", file->f_dentry->d_name.len,
+	DbgPrint("novfs_dir_fsync: Name %.*s\n", file->f_dentry->d_name.len,
 		 file->f_dentry->d_name.name);
 	return (simple_sync_file(file, dentry, datasync));
 }
 
-/*++======================================================================*/
-ssize_t Novfs_f_read(struct file * file, char *buf, size_t len, loff_t * off)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+ssize_t novfs_f_read(struct file * file, char *buf, size_t len, loff_t * off)
 {
 	size_t thisread, totalread = 0;
 	loff_t offset = *off;
 	struct inode *inode;
-	session_t session;
+	struct novfs_schandle session;
 	struct inode_data *id;
 
 	if (file->f_dentry &&
 	    (inode = file->f_dentry->d_inode) &&
-	    (id = (struct inode_data *)inode->FSPRIVATE)) {
+	    (id = (struct inode_data *) inode->i_private)) {
 
-		DbgPrint("Novfs_f_read(0x%p 0x%p %d %lld %.*s)\n",
+		DbgPrint("novfs_f_read(0x%p 0x%p %d %lld %.*s)\n",
 			 file->private_data,
 			 buf, len, offset,
 			 file->f_dentry->d_name.len,
 			 file->f_dentry->d_name.name);
 
-		if (PageCache && !(file->f_flags & O_DIRECT) && id->CacheFlag) {
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
-			totalread = generic_file_read(file, buf, len, off);
-#else
+		if (novfs_page_cache && !(file->f_flags & O_DIRECT) && id->CacheFlag) {
 			totalread = do_sync_read(file, buf, len, off);
-#endif
 		} else {
-			session = Scope_Get_SessionId(id->Scope);
+			session = novfs_scope_get_sessionId(id->Scope);
 			if (0 == SC_PRESENT(session)) {
 				id->Scope =
-				    Scope_Get_ScopefromPath(file->f_dentry);
-				session = Scope_Get_SessionId(id->Scope);
+				    novfs_get_scope(file->f_dentry);
+				session = novfs_scope_get_sessionId(id->Scope);
 			}
 
 			while (len > 0 && (offset < i_size_read(inode))) {
 				int retval;
 				thisread = len;
 				retval =
-				    Novfs_Read_File(file->private_data, buf,
+				    novfs_read_file(file->private_data, buf,
 						    &thisread, &offset,
 						    session);
 				if (retval || !thisread) {
@@ -1658,7 +1317,7 @@ ssize_t Novfs_f_read(struct file * file,
 					}
 					break;
 				}
-				DbgPrint("Novfs_f_read thisread = 0x%x\n",
+				DbgPrint("novfs_f_read thisread = 0x%x\n",
 					 thisread);
 				len -= thisread;
 				buf += thisread;
@@ -1668,77 +1327,60 @@ ssize_t Novfs_f_read(struct file * file,
 			*off = offset;
 		}
 	}
-	DbgPrint("Novfs_f_read return = %d\n", totalread);
+	DbgPrint("novfs_f_read return = %d\n", totalread);
 
 	return (totalread);
 }
 
-/*++======================================================================*/
-ssize_t Novfs_f_write(struct file * file, const char *buf, size_t len,
+ssize_t novfs_f_write(struct file * file, const char *buf, size_t len,
 		      loff_t * off)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	ssize_t thiswrite, totalwrite = 0;
 	loff_t offset = *off;
-	session_t session;
+	struct novfs_schandle session;
 	struct inode *inode;
 	int status;
 	struct inode_data *id;
 
 	if (file->f_dentry &&
 	    (inode = file->f_dentry->d_inode) &&
-	    (id = file->f_dentry->d_inode->FSPRIVATE)) {
-		DbgPrint("Novfs_f_write(0x%p 0x%p 0x%p %d %lld %.*s)\n",
+	    (id = file->f_dentry->d_inode->i_private)) {
+		DbgPrint("novfs_f_write(0x%p 0x%p 0x%p %d %lld %.*s)\n",
 			 file->private_data, inode, id->FileHandle, len, offset,
 			 file->f_dentry->d_name.len,
 			 file->f_dentry->d_name.name);
 
-		if (PageCache &&
+		if (novfs_page_cache &&
 		    !(file->f_flags & O_DIRECT) &&
 		    id->CacheFlag && !(file->f_flags & O_WRONLY)) {
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
-			totalwrite = generic_file_write(file, buf, len, off);
-#else
 			totalwrite = do_sync_write(file, buf, len, off);
-#endif
 		} else {
 			if (file->f_flags & O_APPEND) {
 				offset = i_size_read(inode);
 				DbgPrint
-				    ("Novfs_f_write appending to end %lld %.*s\n",
+				    ("novfs_f_write appending to end %lld %.*s\n",
 				     offset, file->f_dentry->d_name.len,
 				     file->f_dentry->d_name.name);
 			}
 
-			session = Scope_Get_SessionId(id->Scope);
+			session = novfs_scope_get_sessionId(id->Scope);
 			if (0 == SC_PRESENT(session)) {
 				id->Scope =
-				    Scope_Get_ScopefromPath(file->f_dentry);
-				session = Scope_Get_SessionId(id->Scope);
+				    novfs_get_scope(file->f_dentry);
+				session = novfs_scope_get_sessionId(id->Scope);
 			}
 
 			while (len > 0) {
 				thiswrite = len;
 				if ((status =
-				     Novfs_Write_File(file->private_data,
+				     novfs_write_file(file->private_data,
 						      (unsigned char *)buf,
 						      &thiswrite, &offset,
 						      session)) || !thiswrite) {
 					totalwrite = status;
 					break;
 				}
-				DbgPrint("Novfs_f_write thiswrite = 0x%x\n",
+				DbgPrint("novfs_f_write thiswrite = 0x%x\n",
 					 thiswrite);
 				len -= thiswrite;
 				buf += thiswrite;
@@ -1757,69 +1399,43 @@ ssize_t Novfs_f_write(struct file * file
 			*off = offset;
 		}
 	}
-	DbgPrint("Novfs_f_write return = 0x%x\n", totalwrite);
+	DbgPrint("novfs_f_write return = 0x%x\n", totalwrite);
 
 	return (totalwrite);
 }
 
-int Novfs_f_readdir(struct file *file, void *data, filldir_t fill)
+int novfs_f_readdir(struct file *file, void *data, filldir_t fill)
 {
 	return -EISDIR;
 }
 
-int Novfs_f_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+int novfs_f_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
 		  unsigned long arg)
 {
-	DbgPrint("Novfs_f_ioctl: file=0x%p cmd=0x%x arg=0x%p\n", file, cmd,
+	DbgPrint("novfs_f_ioctl: file=0x%p cmd=0x%x arg=0x%p\n", file, cmd,
 		 arg);
 
 	return -ENOSYS;
 }
 
-/*++======================================================================*/
-int Novfs_f_mmap(struct file *file, struct vm_area_struct *vma)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_f_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	int retCode = -EINVAL;
 
-	DbgPrint("Novfs_f_mmap: file=0x%p %.*s\n", file,
+	DbgPrint("novfs_f_mmap: file=0x%p %.*s\n", file,
 		 file->f_dentry->d_name.len, file->f_dentry->d_name.name);
 
 	retCode = generic_file_mmap(file, vma);
 
-	DbgPrint("Novfs_f_mmap: retCode=0x%x\n", retCode);
+	DbgPrint("novfs_f_mmap: retCode=0x%x\n", retCode);
 	return (retCode);
 }
 
-/*++======================================================================*/
-int Novfs_f_open(struct inode *inode, struct file *file)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_f_open(struct inode *inode, struct file *file)
 {
-	struct entry_info *info = NULL;
+	struct novfs_entry_info *info = NULL;
 	int retCode = -ENOENT;
-	session_t session;
+	struct novfs_schandle session;
 	char *path;
 	struct dentry *parent;
 	ino_t ino;
@@ -1827,32 +1443,35 @@ int Novfs_f_open(struct inode *inode, st
 	int errInfo;
 
 	DbgPrint
-	    ("Novfs_f_open: inode=0x%p file=0x%p dentry=0x%p dentry->d_inode=0x%p %.*s\n",
+	    ("novfs_f_open: inode=0x%p file=0x%p dentry=0x%p dentry->d_inode=0x%p %.*s\n",
 	     inode, file, file->f_dentry, file->f_dentry->d_inode,
 	     file->f_dentry->d_name.len, file->f_dentry->d_name.name);
 	if (file->f_dentry) {
 		DbgPrint
-		    ("Novfs_f_open: %.*s f_flags=0%o f_mode=0%o i_mode=0%o\n",
+		    ("novfs_f_open: %.*s f_flags=0%o f_mode=0%o i_mode=0%o\n",
 		     file->f_dentry->d_name.len, file->f_dentry->d_name.name,
 		     file->f_flags, file->f_mode, inode->i_mode);
 	}
 
-	if (inode && inode->FSPRIVATE) {
-		id = (struct inode_data *) file->f_dentry->d_inode->FSPRIVATE;
-		session = Scope_Get_SessionId(id->Scope);
+	if (inode && inode->i_private) {
+		id = (struct inode_data *) file->f_dentry->d_inode->i_private;
+		session = novfs_scope_get_sessionId(id->Scope);
 		if (0 == SC_PRESENT(session)) {
-			id->Scope = Scope_Get_ScopefromPath(file->f_dentry);
-			session = Scope_Get_SessionId(id->Scope);
+			id->Scope = novfs_get_scope(file->f_dentry);
+			session = novfs_scope_get_sessionId(id->Scope);
 		}
 
-		info = Novfs_Malloc(sizeof(struct entry_info) + PATH_LENGTH_BUFFER, GFP_KERNEL);
+		info = kmalloc(sizeof(struct novfs_entry_info) +
+					       PATH_LENGTH_BUFFER, GFP_KERNEL);
 		if (info) {
 			path =
-			    Novfs_dget_path(file->f_dentry, info->name,
+			    novfs_dget_path(file->f_dentry, info->name,
 					    PATH_LENGTH_BUFFER);
 			if (path) {
 				if (file->f_flags & O_TRUNC) {
-					errInfo = Novfs_Get_File_Info(path, info, &session);
+					errInfo =
+					    novfs_get_file_info(path, info,
+								session);
 
 					if (errInfo || info->size == 0) {
 						// clear O_TRUNC flag, bug #275366
@@ -1861,15 +1480,15 @@ int Novfs_f_open(struct inode *inode, st
 					}
 				}
 
-				DbgPrint("Novfs_f_open: %s\n", path);
-				retCode = Novfs_Open_File(path,
+				DbgPrint("novfs_f_open: %s\n", path);
+				retCode = novfs_open_file(path,
 							  file->
 							  f_flags & ~O_EXCL,
 							  info,
 							  &file->private_data,
 							  session);
 
-				DbgPrint("Novfs_f_open: 0x%x 0x%p\n", retCode,
+				DbgPrint("novfs_f_open: 0x%x 0x%p\n", retCode,
 					 file->private_data);
 				if (!retCode) {
 					/*
@@ -1877,28 +1496,31 @@ int Novfs_f_open(struct inode *inode, st
 					 */
 					//id->FileHandle = file->private_data;
 					id->CacheFlag =
-					    Novfs_Get_File_Cache_Flag(path,
+					    novfs_get_file_cache_flag(path,
 								      session);
 
-					if (!Novfs_Get_File_Info(path, info, &session))
+					if (!novfs_get_file_info
+					    (path, info, session)) {
 						update_inode(inode, info);
+					}
 
 					parent = dget_parent(file->f_dentry);
 
 					if (parent && parent->d_inode) {
 						struct inode *dir =
 						    parent->d_inode;
-						Novfs_lock_inode_cache(dir);
+						novfs_lock_inode_cache(dir);
 						ino = 0;
-						if (Novfs_get_entry
+						if (novfs_get_entry
 						    (dir,
 						     &file->f_dentry->d_name,
 						     &ino, info)) {
-							((struct inode_data *)inode->FSPRIVATE)->Flags |=
+							((struct inode_data *) inode->
+							 i_private)->Flags |=
 				       UPDATE_INODE;
 						}
 
-						Novfs_unlock_inode_cache(dir);
+						novfs_unlock_inode_cache(dir);
 					}
 					dput(parent);
 				}
@@ -1906,25 +1528,12 @@ int Novfs_f_open(struct inode *inode, st
 			kfree(info);
 		}
 	}
-	DbgPrint("Novfs_f_open: retCode=0x%x\n", retCode);
+	DbgPrint("novfs_f_open: retCode=0x%x\n", retCode);
 	return (retCode);
 }
 
-/*++======================================================================*/
-int Novfs_flush_mapping(HANDLE Handle, struct address_space *mapping,
-			session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_flush_mapping(void *Handle, struct address_space *mapping,
+			struct novfs_schandle Session)
 {
 	struct pagevec pagevec;
 	unsigned nrpages;
@@ -1944,20 +1553,20 @@ int Novfs_flush_mapping(HANDLE Handle, s
 			struct page *page;
 			int i;
 
-			DbgPrint("Novfs_flush_mapping: %u\n", nrpages);
+			DbgPrint("novfs_flush_mapping: %u\n", nrpages);
 
 			done = 0;
 			for (i = 0; !rc && (i < nrpages); i++) {
 				page = pagevec.pages[i];
 
-				DbgPrint("Novfs_flush_mapping: page 0x%p %lu\n",
+				DbgPrint("novfs_flush_mapping: page 0x%p %lu\n",
 					 page, page->index);
 
 				lock_page(page);
 				page_cache_get(page);
 				if (page->mapping == mapping) {
 					if (clear_page_dirty_for_io(page)) {
-						rc = Novfs_Write_Page(Handle,
+						rc = novfs_write_page(Handle,
 								      page,
 								      Session);
 						if (!rc) {
@@ -1978,61 +1587,44 @@ int Novfs_flush_mapping(HANDLE Handle, s
 		}
 	} while (!rc && !done);
 
-	DbgPrint("Novfs_flush_mapping: return %d\n", rc);
+	DbgPrint("novfs_flush_mapping: return %d\n", rc);
 
 	return (rc);
 }
 
-/*++======================================================================*/
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,16)
-int Novfs_f_flush(struct file *file)
-#else
-int Novfs_f_flush(struct file *file, fl_owner_t ownid)
-#endif
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_f_flush(struct file *file, fl_owner_t ownid)
 {
 
 	int rc = 0;
 #ifdef FLUSH
 	struct inode *inode;
-	session_t session;
+	struct novfs_schandle session;
 	struct inode_data *id;
 
-	DbgPrint("Novfs_f_flush: Called from 0x%p\n",
+	DbgPrint("novfs_f_flush: Called from 0x%p\n",
 		 __builtin_return_address(0));
 	if (file->f_dentry && (inode = file->f_dentry->d_inode)
-	    && (id = file->f_dentry->d_inode->FSPRIVATE)) {
+	    && (id = file->f_dentry->d_inode->i_private)) {
 
 		if ((file->f_flags & O_ACCMODE) != O_RDONLY) {
 			inode = file->f_dentry->d_inode;
 			DbgPrint
-			    ("Novfs_f_flush: %.*s f_flags=0%o f_mode=0%o i_mode=0%o\n",
+			    ("novfs_f_flush: %.*s f_flags=0%o f_mode=0%o i_mode=0%o\n",
 			     file->f_dentry->d_name.len,
 			     file->f_dentry->d_name.name, file->f_flags,
 			     file->f_mode, inode->i_mode);
 
-			session = Scope_Get_SessionId(id->Scope);
+			session = novfs_scope_get_sessionId(id->Scope);
 			if (0 == SC_PRESENT(session)) {
 				id->Scope =
-				    Scope_Get_ScopefromPath(file->f_dentry);
-				session = Scope_Get_SessionId(id->Scope);
+				    novfs_get_scope(file->f_dentry);
+				session = novfs_scope_get_sessionId(id->Scope);
 			}
 
 			if (inode &&
 			    inode->i_mapping && inode->i_mapping->nrpages) {
 
-				DbgPrint("Novfs_f_flush: %.*s pages=%lu\n",
+				DbgPrint("novfs_f_flush: %.*s pages=%lu\n",
 					 file->f_dentry->d_name.len,
 					 file->f_dentry->d_name.name,
 					 inode->i_mapping->nrpages);
@@ -2047,7 +1639,7 @@ int Novfs_f_flush(struct file *file, fl_
 								d_inode->
 								i_mapping);
 				} else {
-					rc = Novfs_flush_mapping(file->
+					rc = novfs_flush_mapping(file->
 								 private_data,
 								 file->
 								 f_dentry->
@@ -2062,46 +1654,33 @@ int Novfs_f_flush(struct file *file, fl_
 	return (rc);
 }
 
-/*++======================================================================*/
-int Novfs_f_release(struct inode *inode, struct file *file)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_f_release(struct inode *inode, struct file *file)
 {
 	int retCode = -EACCES;
-	session_t session;
+	struct novfs_schandle session;
 	struct inode_data *id;
 
-	DbgPrint("Novfs_f_release: path=%.*s handle=%p\n",
+	DbgPrint("novfs_f_release: path=%.*s handle=%p\n",
 		 file->f_dentry->d_name.len,
 		 file->f_dentry->d_name.name, file->private_data);
 
-	if (inode && (id = inode->FSPRIVATE)) {
-		session = Scope_Get_SessionId(id->Scope);
+	if (inode && (id = inode->i_private)) {
+		session = novfs_scope_get_sessionId(id->Scope);
 		if (0 == SC_PRESENT(session)) {
-			id->Scope = Scope_Get_ScopefromPath(file->f_dentry);
-			session = Scope_Get_SessionId(id->Scope);
+			id->Scope = novfs_get_scope(file->f_dentry);
+			session = novfs_scope_get_sessionId(id->Scope);
 		}
 
 		if ((file->f_flags & O_ACCMODE) != O_RDONLY) {
 			DbgPrint
-			    ("Novfs_f_release: %.*s f_flags=0%o f_mode=0%o i_mode=0%o\n",
+			    ("novfs_f_release: %.*s f_flags=0%o f_mode=0%o i_mode=0%o\n",
 			     file->f_dentry->d_name.len,
 			     file->f_dentry->d_name.name, file->f_flags,
 			     file->f_mode, inode->i_mode);
 
 			if (inode->i_mapping && inode->i_mapping->nrpages) {
 
-				DbgPrint("Novfs_f_release: %.*s pages=%lu\n",
+				DbgPrint("novfs_f_release: %.*s pages=%lu\n",
 					 file->f_dentry->d_name.len,
 					 file->f_dentry->d_name.name,
 					 inode->i_mapping->nrpages);
@@ -2111,7 +1690,7 @@ int Novfs_f_release(struct inode *inode,
 					filemap_fdatawrite(file->f_dentry->
 							   d_inode->i_mapping);
 				} else {
-					Novfs_flush_mapping(file->private_data,
+					novfs_flush_mapping(file->private_data,
 							    file->f_dentry->
 							    d_inode->i_mapping,
 							    session);
@@ -2123,40 +1702,27 @@ int Novfs_f_release(struct inode *inode,
 			invalidate_remote_inode(file->f_dentry->d_inode);
 		}
 
-		retCode = Novfs_Close_File(file->private_data, session);
+		retCode = novfs_close_file(file->private_data, session);
 		//id->FileHandle = 0;
 	}
 	return (retCode);
 }
 
-int Novfs_f_fsync(struct file *file, struct dentry *dentry, int datasync)
+int novfs_f_fsync(struct file *file, struct dentry *dentry, int datasync)
 {
 	return 0;
 }
 
-/*++======================================================================*/
-int Novfs_f_llseek(struct file *file, loff_t offset, int origin)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_f_llseek(struct file *file, loff_t offset, int origin)
 {
-	DbgPrint("Novfs_f_llseek: File=0x%p Name=%.*s offset=%lld origin=%d\n",
+	DbgPrint("novfs_f_llseek: File=0x%p Name=%.*s offset=%lld origin=%d\n",
 		 file, file->f_dentry->d_name.len, file->f_dentry->d_name.name,
 		 offset, origin);
 	return (generic_file_llseek(file, offset, origin));
 }
 
 /*++======================================================================*/
-int Novfs_f_lock(struct file *file, int cmd, struct file_lock *lock)
+int novfs_f_lock(struct file *file, int cmd, struct file_lock *lock)
 /*
  *  Arguments:
  *      "file" - pointer to file structure - contains file handle in "file->private_data"
@@ -2179,24 +1745,23 @@ int Novfs_f_lock(struct file *file, int
  *      but xtier functions in novfsd "NCFsdLockFile" and "NCFsdUnlockFile"
  *      receive arguments in u64 type.
  *
- *  Environment:
  *
  *========================================================================*/
 {
 	int err_code;
 
 	struct inode *inode;
-	session_t session;
+	struct novfs_schandle session;
 	struct inode_data *id;
 	loff_t len;
 
-	DbgPrint("Novfs_f_lock(0x%p): begin in Novfs_f_lock 0x%p\n",
+	DbgPrint("novfs_f_lock(0x%p): begin in novfs_f_lock 0x%p\n",
 		 __builtin_return_address(0), file->private_data);
 	DbgPrint
-	    ("Novfs_f_lock: cmd = %d, F_GETLK = %d, F_SETLK = %d, F_SETLKW = %d\n",
+	    ("novfs_f_lock: cmd = %d, F_GETLK = %d, F_SETLK = %d, F_SETLKW = %d\n",
 	     cmd, F_GETLK, F_SETLK, F_SETLKW);
 	DbgPrint
-	    ("Novfs_f_lock: lock->fl_start = 0x%llX, lock->fl_end = 0x%llX\n",
+	    ("novfs_f_lock: lock->fl_start = 0x%llX, lock->fl_end = 0x%llX\n",
 	     lock->fl_start, lock->fl_end);
 
 	err_code = -1;
@@ -2209,17 +1774,17 @@ int Novfs_f_lock(struct file *file, int
 
 		if (file->f_dentry &&
 		    (inode = file->f_dentry->d_inode) &&
-		    (id = (struct inode_data *)inode->FSPRIVATE)) {
-			DbgPrint("Novfs_f_lock: (0x%p 0x%p %.*s)\n",
+		    (id = (struct inode_data *) inode->i_private)) {
+			DbgPrint("novfs_f_lock: (0x%p 0x%p %.*s)\n",
 				 file->private_data, inode,
 				 file->f_dentry->d_name.len,
 				 file->f_dentry->d_name.name);
 
-			session = Scope_Get_SessionId(id->Scope);
+			session = novfs_scope_get_sessionId(id->Scope);
 			if (0 == SC_PRESENT(session)) {
 				id->Scope =
-				    Scope_Get_ScopefromPath(file->f_dentry);
-				session = Scope_Get_SessionId(id->Scope);
+				    novfs_get_scope(file->f_dentry);
+				session = novfs_scope_get_sessionId(id->Scope);
 			}
 
 			/* fl_type = F_RDLCK, F_WRLCK, F_UNLCK */
@@ -2230,7 +1795,7 @@ int Novfs_f_lock(struct file *file, int
 #endif
 
 				err_code =
-				    Novfs_Set_File_Lock(session,
+				    novfs_set_file_lock(session,
 							file->private_data,
 							lock->fl_type,
 							lock->fl_start, len);
@@ -2241,7 +1806,7 @@ int Novfs_f_lock(struct file *file, int
 			case F_SETLKW64:
 #endif
 				err_code =
-				    Novfs_Set_File_Lock(session,
+				    novfs_set_file_lock(session,
 							file->private_data,
 							lock->fl_type,
 							lock->fl_start, len);
@@ -2259,16 +1824,16 @@ int Novfs_f_lock(struct file *file, int
 
 			default:
 				printk
-				    ("<1> novfs in Novfs_f_lock, not implemented cmd = %d\n",
+				    ("<1> novfs in novfs_f_lock, not implemented cmd = %d\n",
 				     cmd);
 				DbgPrint
-				    ("Novfs_f_lock: novfs in Novfs_f_lock, not implemented cmd = %d\n",
+				    ("novfs_f_lock: novfs in novfs_f_lock, not implemented cmd = %d\n",
 				     cmd);
 				break;
 			}
 		}
 
-		DbgPrint("Novfs_f_lock: lock->fl_type = %u, err_code 0x%X\n",
+		DbgPrint("novfs_f_lock: lock->fl_type = %u, err_code 0x%X\n",
 			 lock->fl_type, err_code);
 
 		if ((err_code != 0) && (err_code != -1)
@@ -2283,21 +1848,9 @@ int Novfs_f_lock(struct file *file, int
 }
 
 /*++======================================================================*/
-static void Novfs_copy_cache_pages(struct address_space *mapping,
+static void novfs_copy_cache_pages(struct address_space *mapping,
 				   struct list_head *pages, int bytes_read,
 				   char *data, struct pagevec *plru_pvec)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	struct page *page;
 	char *target;
@@ -2340,30 +1893,17 @@ static void Novfs_copy_cache_pages(struc
 	return;
 }
 
-/*++======================================================================*/
-int Novfs_a_writepage(struct page *page, struct writeback_control *wbc)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_a_writepage(struct page *page, struct writeback_control *wbc)
 {
 	int retCode = -EFAULT;
 	struct inode *inode = page->mapping->host;
-	struct inode_data *id = inode->FSPRIVATE;
+	struct inode_data *id = inode->i_private;
 	loff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT);
-	session_t session;
-	struct data_list dlst[2];
+	struct novfs_schandle session;
+	struct novfs_data_list dlst[2];
 	size_t len = PAGE_CACHE_SIZE;
 
-	session = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+	session = novfs_scope_get_sessionId(((struct inode_data *) inode->i_private)->Scope);
 
 	page_cache_get(page);
 
@@ -2384,7 +1924,7 @@ int Novfs_a_writepage(struct page *page,
 		len = (size_t) (i_size_read(inode) - pos);
 	}
 
-	retCode = Novfs_Write_Pages(id->FileHandle, dlst, 2, len, pos, session);
+	retCode = novfs_write_pages(id->FileHandle, dlst, 2, len, pos, session);
 	if (!retCode) {
 		SetPageUptodate(page);
 	}
@@ -2395,32 +1935,18 @@ int Novfs_a_writepage(struct page *page,
 	return (retCode);
 }
 
-/*++======================================================================*/
-int Novfs_a_writepages(struct address_space *mapping,
+int novfs_a_writepages(struct address_space *mapping,
 		       struct writeback_control *wbc)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	int retCode = 0;
 	struct inode *inode = mapping->host;
-	session_t session;
-	HANDLE fh = 0;
+	struct novfs_schandle session;
+	void *fh = NULL;
 	struct inode_data *id = NULL;
 
-	int max_page_lookup = MaxIoSize / PAGE_CACHE_SIZE;
+	int max_page_lookup = novfs_max_iosize / PAGE_CACHE_SIZE;
 
-	struct data_list *dlist;
-	struct data_list *dlptr;
+	struct novfs_data_list *dlist, *dlptr;
 	struct page **pages;
 
 	int dlist_idx, i = 0;
@@ -2430,31 +1956,32 @@ int Novfs_a_writepages(struct address_sp
 
 	SC_INITIALIZE(session);
 	DbgPrint
-	    ("Novfs_a_writepages: inode=0x%p mapping=0x%p wbc=0x%p nr_to_write=%d\n",
+	    ("novfs_a_writepages: inode=0x%p mapping=0x%p wbc=0x%p nr_to_write=%d\n",
 	     inode, mapping, wbc, wbc->nr_to_write);
 
 	if (inode) {
 		DbgPrint(" Inode=0x%p Ino=%d Id=0x%p\n", inode, inode->i_ino,
-			 inode->FSPRIVATE);
+			 inode->i_private);
 
-		if (NULL != (id = inode->FSPRIVATE)) {
+		if (NULL != (id = inode->i_private)) {
 			session =
-			    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
-			fh = ((struct inode_data *)inode->FSPRIVATE)->FileHandle;
+			    novfs_scope_get_sessionId(((struct inode_data *) inode->
+						 i_private)->Scope);
+			fh = ((struct inode_data *) inode->i_private)->FileHandle;
 		}
 	}
 
-	dlist = Novfs_Malloc(sizeof(struct data_list) * max_page_lookup, GFP_KERNEL);
+	dlist = kmalloc(sizeof(struct novfs_data_list) * max_page_lookup, GFP_KERNEL);
 	pages =
-	    Novfs_Malloc(sizeof(struct page *) * max_page_lookup, GFP_KERNEL);
+	    kmalloc(sizeof(struct page *) * max_page_lookup, GFP_KERNEL);
 
 	if (id)
 		DbgPrint
-		    ("Novfs_a_writepages: inode=0x%p fh=0x%p dlist=0x%p pages=0x%p %s\n",
+		    ("novfs_a_writepages: inode=0x%p fh=0x%p dlist=0x%p pages=0x%p %s\n",
 		     inode, fh, dlist, pages, id->Name);
 	else
 		DbgPrint
-		    ("Novfs_a_writepages: inode=0x%p fh=0x%p dlist=0x%p pages=0x%p\n",
+		    ("novfs_a_writepages: inode=0x%p fh=0x%p dlist=0x%p pages=0x%p\n",
 		     inode, fh, dlist, pages);
 
 	if (dlist && pages) {
@@ -2481,13 +2008,13 @@ int Novfs_a_writepages(struct address_sp
 			dlist_idx = 0;
 			dlptr = &dlist[1];
 
-			DbgPrint("Novfs_a_writepages1: nr_pages=%d\n",
+			DbgPrint("novfs_a_writepages1: nr_pages=%d\n",
 				 nr_pages);
 			if (!nr_pages) {
 				memset(pages, 0,
 				       sizeof(struct page *) * max_page_lookup);
 
-				AS_TREE_LOCK(&mapping->tree_lock);
+				read_lock_irq(&mapping->tree_lock);
 
 				/*
 				 * Need to ask for one less then max_page_lookup or we
@@ -2503,7 +2030,7 @@ int Novfs_a_writepages(struct address_sp
 							       1,
 							       PAGECACHE_TAG_DIRTY);
 
-				DbgPrint("Novfs_a_writepages2: nr_pages=%d\n",
+				DbgPrint("novfs_a_writepages2: nr_pages=%d\n",
 					 nr_pages);
 				/*
 				 * Check to see if there are dirty pages and there is a valid
@@ -2513,7 +2040,7 @@ int Novfs_a_writepages(struct address_sp
 					set_bit(AS_EIO, &mapping->flags);
 					done = 1;
 					DbgPrint
-					    ("Novfs_a_writepage: set_bit AS_EIO\n");
+					    ("novfs_a_writepage: set_bit AS_EIO\n");
 					break;
 				}
 
@@ -2521,7 +2048,7 @@ int Novfs_a_writepages(struct address_sp
 					page_cache_get(pages[i]);
 				}
 
-				AS_TREE_UNLOCK(&mapping->tree_lock);
+				read_unlock_irq(&mapping->tree_lock);
 
 				if (nr_pages) {
 					index = pages[nr_pages - 1]->index + 1;
@@ -2561,7 +2088,7 @@ int Novfs_a_writepages(struct address_sp
 				 */
 
 				DbgPrint
-				    ("Novfs_a_writepages: pos=0x%llx index=%d page->index=%d next_index=%d\n",
+				    ("novfs_a_writepages: pos=0x%llx index=%d page->index=%d next_index=%d\n",
 				     pos, index, page->index, next_index);
 
 				if (page->index != next_index) {
@@ -2588,11 +2115,11 @@ int Novfs_a_writepages(struct address_sp
 				dlptr[dlist_idx].rwflag = DLREAD;
 				dlist_idx++;
 				DbgPrint
-				    ("Novfs_a_writepages: Add page=0x%p index=0x%lx\n",
+				    ("novfs_a_writepages: Add page=0x%p index=0x%lx\n",
 				     page, page->index);
 			}
 
-			DbgPrint("Novfs_a_writepages: dlist_idx=%d\n",
+			DbgPrint("novfs_a_writepages: dlist_idx=%d\n",
 				 dlist_idx);
 			if (dlist_idx) {
 				tsize = dlist_idx * PAGE_CACHE_SIZE;
@@ -2605,7 +2132,7 @@ int Novfs_a_writepages(struct address_sp
 				}
 
 				retCode =
-				    Novfs_Write_Pages(fh, dlist, dlist_idx + 1,
+				    novfs_write_pages(fh, dlist, dlist_idx + 1,
 						      tsize, pos, session);
 				switch (retCode) {
 				case 0:
@@ -2630,7 +2157,7 @@ int Novfs_a_writepages(struct address_sp
 							   dlptr[dlist_idx -
 								 1].page);
 					DbgPrint
-					    ("Novfs_a_writepages: release page=0x%p index=0x%lx\n",
+					    ("novfs_a_writepages: release page=0x%p index=0x%lx\n",
 					     dlptr[dlist_idx - 1].page,
 					     ((struct page *)
 					      dlptr[dlist_idx -
@@ -2649,7 +2176,7 @@ int Novfs_a_writepages(struct address_sp
 		mapping->writeback_index = index;
 
 	} else {
-		DbgPrint("Novfs_a_writepage: set_bit AS_EIO\n");
+		DbgPrint("novfs_a_writepage: set_bit AS_EIO\n");
 		set_bit(AS_EIO, &mapping->flags);
 	}
 	if (dlist)
@@ -2657,25 +2184,12 @@ int Novfs_a_writepages(struct address_sp
 	if (pages)
 		kfree(pages);
 
-	DbgPrint("Novfs_a_writepage: retCode=%d\n", retCode);
+	DbgPrint("novfs_a_writepage: retCode=%d\n", retCode);
 	return (0);
 
 }
 
-/*++======================================================================*/
-int Novfs_a_readpage(struct file *file, struct page *page)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_a_readpage(struct file *file, struct page *page)
 {
 	int retCode = 0;
 	void *pbuf;
@@ -2683,10 +2197,10 @@ int Novfs_a_readpage(struct file *file,
 	struct dentry *dentry = NULL;
 	loff_t offset;
 	size_t len;
-	session_t session;
+	struct novfs_schandle session;
 
 	SC_INITIALIZE(session);
-	DbgPrint("Novfs_a_readpage: File=0x%p Name=%.*s Page=0x%p", file,
+	DbgPrint("novfs_a_readpage: File=0x%p Name=%.*s Page=0x%p", file,
 		 file->f_dentry->d_name.len, file->f_dentry->d_name.name, page);
 
 	dentry = file->f_dentry;
@@ -2702,14 +2216,16 @@ int Novfs_a_readpage(struct file *file,
 	if (inode) {
 		DbgPrint(" Inode=0x%p Ino=%d", inode, inode->i_ino);
 
-		if (inode->FSPRIVATE) {
+		if (inode->i_private) {
 			session =
-			    Scope_Get_SessionId(((struct inode_data *)inode->
-						 FSPRIVATE)->Scope);
+			    novfs_scope_get_sessionId(((struct inode_data *) inode->
+						 i_private)->Scope);
 			if (0 == SC_PRESENT(session)) {
-				((struct inode_data *)inode->FSPRIVATE)->Scope =
-				    Scope_Get_ScopefromPath(file->f_dentry);
-				session = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+				((struct inode_data *) inode->i_private)->Scope =
+				    novfs_get_scope(file->f_dentry);
+				session =
+				    novfs_scope_get_sessionId(((struct inode_data *) inode->
+							 i_private)->Scope);
 			}
 		}
 	}
@@ -2717,7 +2233,7 @@ int Novfs_a_readpage(struct file *file,
 	DbgPrint("\n");
 
 	if (!PageUptodate(page)) {
-		struct data_list dlst[2];
+		struct novfs_data_list dlst[2];
 
 		offset = page->index << PAGE_CACHE_SHIFT;
 		len = PAGE_CACHE_SIZE;
@@ -2730,10 +2246,10 @@ int Novfs_a_readpage(struct file *file,
 		dlst[1].len = PAGE_CACHE_SIZE;
 		dlst[1].rwflag = DLWRITE;
 
-		DbgPrint("Novfs_a_readpage: calling= Novfs_Read_Pages %lld\n",
+		DbgPrint("novfs_a_readpage: calling= novfs_Read_Pages %lld\n",
 			 offset);
 		retCode =
-		    Novfs_Read_Pages(file->private_data, dlst, 2, &len, &offset,
+		    novfs_read_pages(file->private_data, dlst, 2, &len, &offset,
 				     session);
 		if (len && (len < PAGE_CACHE_SIZE)) {
 			pbuf = kmap_atomic(page, KM_USER0);
@@ -2746,31 +2262,18 @@ int Novfs_a_readpage(struct file *file,
 	}
 	unlock_page(page);
 
-	DbgPrint("Novfs_a_readpage: retCode=%d\n", retCode);
+	DbgPrint("novfs_a_readpage: retCode=%d\n", retCode);
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int Novfs_a_readpages(struct file *file, struct address_space *mapping,
+int novfs_a_readpages(struct file *file, struct address_space *mapping,
 		      struct list_head *page_lst, unsigned nr_pages)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	int retCode = 0;
 	struct inode *inode = NULL;
 	struct dentry *dentry = NULL;
-	session_t session;
+	struct novfs_schandle session;
 	loff_t offset;
 	size_t len;
 
@@ -2781,7 +2284,7 @@ int Novfs_a_readpages(struct file *file,
 	char *rbuf, done = 0;
 	SC_INITIALIZE(session);
 
-	DbgPrint("Novfs_a_readpages: File=0x%p Name=%.*s Pages=%d\n", file,
+	DbgPrint("novfs_a_readpages: File=0x%p Name=%.*s Pages=%d\n", file,
 		 file->f_dentry->d_name.len, file->f_dentry->d_name.name,
 		 nr_pages);
 
@@ -2798,21 +2301,21 @@ int Novfs_a_readpages(struct file *file,
 	if (inode) {
 		DbgPrint(" Inode=0x%p Ino=%d\n", inode, inode->i_ino);
 
-		if (inode->FSPRIVATE) {
+		if (inode->i_private) {
 			session =
-			    Scope_Get_SessionId(((struct inode_data *)inode->
-						 FSPRIVATE)->Scope);
+			    novfs_scope_get_sessionId(((struct inode_data *) inode->
+						 i_private)->Scope);
 			if (0 == SC_PRESENT(session)) {
-				((struct inode_data *) inode->FSPRIVATE)->Scope =
-				    Scope_Get_ScopefromPath(file->f_dentry);
+				((struct inode_data *) inode->i_private)->Scope =
+				    novfs_get_scope(file->f_dentry);
 				session =
-				    Scope_Get_SessionId(((struct inode_data *) inode->
-							 FSPRIVATE)->Scope);
+				    novfs_scope_get_sessionId(((struct inode_data *) inode->
+							 i_private)->Scope);
 			}
 		}
 	}
 
-	rbuf = (char *)Novfs_Malloc(MaxIoSize, GFP_KERNEL);
+	rbuf = kmalloc(novfs_max_iosize, GFP_KERNEL);
 	if (rbuf) {
 		pagevec_init(&lru_pvec, 0);
 		for (page_idx = 0; page_idx < nr_pages && !done;) {
@@ -2832,7 +2335,7 @@ int Novfs_a_readpages(struct file *file,
 			 */
 			list_for_each_entry_reverse(tpage, page_lst, lru) {
 				if ((next_index != tpage->index) ||
-				    (len >= MaxIoSize - PAGE_SIZE)) {
+				    (len >= novfs_max_iosize - PAGE_SIZE)) {
 					break;
 				}
 				len += PAGE_SIZE;
@@ -2840,7 +2343,7 @@ int Novfs_a_readpages(struct file *file,
 			}
 
 			if (len && !done) {
-				struct data_list dllst[2];
+				struct novfs_data_list dllst[2];
 
 				dllst[1].page = NULL;
 				dllst[1].offset = rbuf;
@@ -2848,12 +2351,12 @@ int Novfs_a_readpages(struct file *file,
 				dllst[1].rwflag = DLWRITE;
 
 				DbgPrint
-				    ("Novfs_a_readpages: calling Novfs_Read_Pages %lld\n",
+				    ("novfs_a_readpages: calling novfs_Read_Pages %lld\n",
 				     offset);
-				if (!Novfs_Read_Pages
+				if (!novfs_read_pages
 				    (file->private_data, dllst, 2, &len,
 				     &offset, session)) {
-					Novfs_copy_cache_pages(mapping,
+					novfs_copy_cache_pages(mapping,
 							       page_lst, len,
 							       rbuf, &lru_pvec);
 					page_idx += len >> PAGE_CACHE_SHIFT;
@@ -2886,37 +2389,24 @@ int Novfs_a_readpages(struct file *file,
 		retCode = -ENOMEM;
 	}
 
-	DbgPrint("Novfs_a_readpages: retCode=%d\n", retCode);
+	DbgPrint("novfs_a_readpages: retCode=%d\n", retCode);
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int Novfs_a_prepare_write(struct file *file, struct page *page, unsigned from,
+int novfs_a_prepare_write(struct file *file, struct page *page, unsigned from,
 			  unsigned to)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	int retVal = 0;
 	loff_t offset = (loff_t) page->index << PAGE_CACHE_SHIFT;
 	size_t len = PAGE_CACHE_SIZE;
-	session_t session;
-	struct data_list dllst[2];
+	struct novfs_schandle session;
+	struct novfs_data_list dllst[2];
 	struct inode *inode = file->f_dentry->d_inode;
 	SC_INITIALIZE(session);
 
 	DbgPrint
-	    ("Novfs_a_prepare_write: File=0x%p Page=0x%p offset=0x%llx From=%u To=%u filesize=%lld\n",
+	    ("novfs_a_prepare_write: File=0x%p Page=0x%p offset=0x%llx From=%u To=%u filesize=%lld\n",
 	     file, page, offset, from, to,
 	     i_size_read(file->f_dentry->d_inode));
 	if (!PageUptodate(page)) {
@@ -2935,12 +2425,18 @@ int Novfs_a_prepare_write(struct file *f
 			 * Get session.
 			 */
 			if (file->f_dentry && file->f_dentry->d_inode) {
-				if (file->f_dentry->d_inode->FSPRIVATE) {
+				if (file->f_dentry->d_inode->i_private) {
 					session =
-					    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+					    novfs_scope_get_sessionId(((struct inode_data *)
+								 inode->
+								 i_private)->
+								Scope);
 					if (0 == SC_PRESENT(session)) {
-						((struct inode_data *)inode->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(file->f_dentry);
-						session = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+						((struct inode_data *) inode->
+						 i_private)->Scope =
+			       novfs_get_scope(file->f_dentry);
+						session =
+						    novfs_scope_get_sessionId(((struct inode_data *) inode->i_private)->Scope);
 					}
 				}
 			}
@@ -2963,9 +2459,9 @@ int Novfs_a_prepare_write(struct file *f
 				dllst[1].rwflag = DLWRITE;
 
 				DbgPrint
-				    ("Novfs_a_prepare_write: calling Novfs_Read_Pages %lld\n",
+				    ("novfs_a_prepare_write: calling novfs_Read_Pages %lld\n",
 				     offset);
-				Novfs_Read_Pages(file->private_data, dllst, 2,
+				novfs_read_pages(file->private_data, dllst, 2,
 						 &len, &offset, session);
 
 				/*
@@ -2987,50 +2483,37 @@ int Novfs_a_prepare_write(struct file *f
 			memset(adr + to, 0, PAGE_CACHE_SIZE - to);
 			kunmap_atomic(adr, KM_USER0);
 
-			DbgPrint("Novfs_a_prepare_write: memset 0x%p\n", adr);
+			DbgPrint("novfs_a_prepare_write: memset 0x%p\n", adr);
 		}
 		flush_dcache_page(page);
 		SetPageUptodate(page);
 	}
-//   DbgPrint("Novfs_a_prepare_write: return %d\n", retVal);
+//   DbgPrint("novfs_a_prepare_write: return %d\n", retVal);
 	return (retVal);
 }
 
-/*++======================================================================*/
-int Novfs_a_commit_write(struct file *file, struct page *page, unsigned offset,
+int novfs_a_commit_write(struct file *file, struct page *page, unsigned offset,
 			 unsigned to)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	int retCode = 0;
 	struct inode *inode = page->mapping->host;
 	loff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;
-	session_t session;
+	struct novfs_schandle session;
 	struct inode_data *id;
-	struct data_list dlst[1];
+	struct novfs_data_list dlst[1];
 	size_t len = to - offset;
 
 	SC_INITIALIZE(session);
 
 	DbgPrint
-	    ("Novfs_a_commit_write: File=0x%p Page=0x%p offset=0x%x To=%u filesize=%lld\n",
+	    ("novfs_a_commit_write: File=0x%p Page=0x%p offset=0x%x To=%u filesize=%lld\n",
 	     file, page, offset, to, i_size_read(file->f_dentry->d_inode));
 	if (file->f_dentry->d_inode
-	    && (id = file->f_dentry->d_inode->FSPRIVATE)) {
-		session = Scope_Get_SessionId(id->Scope);
+	    && (id = file->f_dentry->d_inode->i_private)) {
+		session = novfs_scope_get_sessionId(id->Scope);
 		if (0 == SC_PRESENT(session)) {
-			id->Scope = Scope_Get_ScopefromPath(file->f_dentry);
-			session = Scope_Get_SessionId(id->Scope);
+			id->Scope = novfs_get_scope(file->f_dentry);
+			session = novfs_scope_get_sessionId(id->Scope);
 		}
 
 		/*
@@ -3055,7 +2538,7 @@ int Novfs_a_commit_write(struct file *fi
 			dlst[0].rwflag = DLREAD;
 
 			retCode =
-			    Novfs_Write_Pages(id->FileHandle, dlst, 1, len, pos,
+			    novfs_write_pages(id->FileHandle, dlst, 1, len, pos,
 					      session);
 
 		} else {
@@ -3067,51 +2550,32 @@ int Novfs_a_commit_write(struct file *fi
 }
 
 /*++======================================================================*/
-ssize_t Novfs_a_direct_IO(int rw, struct kiocb * kiocb,
+ssize_t novfs_a_direct_IO(int rw, struct kiocb * kiocb,
 			  const struct iovec * iov,
 			  loff_t offset, unsigned long nr_segs)
 /*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
  *
  *  Notes:        This is a dummy function so that we can allow a file
- *                to get the direct IO flag set.  Novfs_f_read and
- *                Novfs_f_write will do the work.  Maybe not the best
+ *                to get the direct IO flag set.  novfs_f_read and
+ *                novfs_f_write will do the work.  Maybe not the best
  *                way to do but it was the easiest to implement.
  *
- *  Environment:
- *
  *========================================================================*/
 {
 	return (-EIO);
 }
 
 /*++======================================================================*/
-int Novfs_i_create(struct inode *dir, struct dentry *dentry, int mode,
+int novfs_i_create(struct inode *dir, struct dentry *dentry, int mode,
 		   struct nameidata *nd)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	char *path, *buf;
-	struct entry_info info;
-	HANDLE handle;
-	session_t session;
+	struct novfs_entry_info info;
+	void *handle;
+	struct novfs_schandle session;
 	int retCode = -EACCES;
 
-	DbgPrint("Novfs_i_create: mode=0%o flags=0%o %.*s\n", mode,
+	DbgPrint("novfs_i_create: mode=0%o flags=0%o %.*s\n", mode,
 		 nd->NDOPENFLAGS, dentry->d_name.len, dentry->d_name.name);
 
 	if (IS_ROOT(dentry) ||	/* Root */
@@ -3122,38 +2586,42 @@ int Novfs_i_create(struct inode *dir, st
 	}
 
 	if (mode | S_IFREG) {
-		if (dir->FSPRIVATE) {
+		if (dir->i_private) {
 			session =
-			    Scope_Get_SessionId(((struct inode_data *)dir->FSPRIVATE)->
+			    novfs_scope_get_sessionId(((struct inode_data *) dir->i_private)->
 						Scope);
 			if (0 == SC_PRESENT(session)) {
-				((struct inode_data *) dir->FSPRIVATE)->Scope =
-				    Scope_Get_ScopefromPath(dentry);
-				session = Scope_Get_SessionId(((struct inode_data *)dir->FSPRIVATE)->Scope);
+				((struct inode_data *) dir->i_private)->Scope =
+				    novfs_get_scope(dentry);
+				session =
+				    novfs_scope_get_sessionId(((struct inode_data *) dir->
+							 i_private)->Scope);
 			}
 
-			buf =
-			    (char *)Novfs_Malloc(PATH_LENGTH_BUFFER,
-						 GFP_KERNEL);
+			buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 			if (buf) {
 				path =
-				    Novfs_dget_path(dentry, buf,
+				    novfs_dget_path(dentry, buf,
 						    PATH_LENGTH_BUFFER);
 				if (path) {
 					retCode =
-					    Novfs_Open_File(path,
+					    novfs_open_file(path,
 							    nd->
 							    NDOPENFLAGS |
 							    O_RDWR, &info,
 							    &handle, session);
 					if (!retCode && handle) {
-						Novfs_Close_File(handle,
+						novfs_close_file(handle,
 								 session);
-						if (!Novfs_i_mknod
+						if (!novfs_i_mknod
 						    (dir, dentry,
 						     mode | S_IFREG, 0)) {
 							if (dentry->d_inode) {
-								((struct inode_data *)dentry->d_inode->FSPRIVATE)->Flags |= UPDATE_INODE;
+								((struct inode_data *)
+								 dentry->
+								 d_inode->
+								 i_private)->
+						      Flags |= UPDATE_INODE;
 							}
 						}
 					}
@@ -3165,20 +2633,7 @@ int Novfs_i_create(struct inode *dir, st
 	return (retCode);
 }
 
-/*++======================================================================*/
-void update_inode(struct inode *Inode, struct entry_info *Info)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+void update_inode(struct inode *Inode, struct novfs_entry_info *Info)
 {
 	static char dbuf[128];
 
@@ -3219,35 +2674,24 @@ void update_inode(struct inode *Inode, s
 	Inode->i_mtime = Info->mtime;
 
 	if (Inode->i_size && Inode->i_sb->s_blocksize) {
-		Inode->i_blocks = (unsigned long) (Info->size >> (loff_t) Inode->i_blkbits);
+		Inode->i_blocks =
+		    (unsigned long) (Info->size >> (loff_t) Inode->i_blkbits);
 		Inode->i_bytes = Info->size & (Inode->i_sb->s_blocksize - 1);
 
-		DbgPrint("update_inode: i_sb->s_blocksize=%d\n", Inode->i_sb->s_blocksize);
+		DbgPrint("update_inode: i_sb->s_blocksize=%d\n",
+			 Inode->i_sb->s_blocksize);
 		DbgPrint("update_inode: i_blkbits=%d\n", Inode->i_blkbits);
 		DbgPrint("update_inode: i_blocks=%d\n", Inode->i_blocks);
 		DbgPrint("update_inode: i_bytes=%d\n", Inode->i_bytes);
 	}
 }
 
-/*++======================================================================*/
-struct dentry *Novfs_i_lookup(struct inode *dir, struct dentry *dentry,
+struct dentry *novfs_i_lookup(struct inode *dir, struct dentry *dentry,
 			      struct nameidata *nd)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	struct dentry *retVal = ERR_PTR(-ENOENT);
 	struct dentry *parent;
-	struct entry_info *info = NULL;
+	struct novfs_entry_info *info = NULL;
 	struct inode_data *id;
 	struct inode *inode = NULL;
 	uid_t uid = current->euid;
@@ -3255,49 +2699,49 @@ struct dentry *Novfs_i_lookup(struct ino
 	struct qstr name;
 	char *buf;
 
-	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	if (buf) {
 		char *path;
-		path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+		path = novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
 		if (path) {
 			DbgPrint
-			    ("Novfs_i_lookup: dir 0x%p %d hash %d inode 0x%0p %s\n",
+			    ("novfs_i_lookup: dir 0x%p %d hash %d inode 0x%0p %s\n",
 			     dir, dir->i_ino, dentry->d_name.hash,
 			     dentry->d_inode, path);
 		}
 		kfree(buf);
 	} else {
 		DbgPrint
-		    ("Novfs_i_lookup: dir 0x%p %d name %.*s hash %d inode 0x%0p\n",
+		    ("novfs_i_lookup: dir 0x%p %d name %.*s hash %d inode 0x%0p\n",
 		     dir, dir->i_ino, dentry->d_name.len, dentry->d_name.name,
 		     dentry->d_name.hash, dentry->d_inode);
 	}
 
 	if ((dentry->d_name.len == 7)
 	    && (0 == strncmp(dentry->d_name.name, " !xover", 7))) {
-		dentry->d_op = &Novfs_dentry_operations;
+		dentry->d_op = &novfs_dentry_operations;
 		igrab(dir);
 		d_add(dentry, dir);
 		return NULL;
 	}
 	if ((dentry->d_name.len == 7)
 	    && (0 == strncmp(dentry->d_name.name, "z!xover", 7))) {
-		dentry->d_op = &Novfs_dentry_operations;
+		dentry->d_op = &novfs_dentry_operations;
 		igrab(dir);
 		d_add(dentry, dir);
 		return NULL;
 	}
 
-	if (dir && (id = dir->FSPRIVATE)) {
+	if (dir && (id = dir->i_private)) {
 		retVal = 0;
 		if (IS_ROOT(dentry)) {
-			DbgPrint("Novfs_i_lookup: Root entry=0x%p\n",
-				 Novfs_root);
-			inode = Novfs_root->d_inode;
+			DbgPrint("novfs_i_lookup: Root entry=0x%p\n",
+				 novfs_root);
+			inode = novfs_root->d_inode;
 			return (0);
 		} else {
 			info =
-			    Novfs_Malloc(sizeof(struct entry_info) +
+			    kmalloc(sizeof(struct novfs_entry_info) +
 					 PATH_LENGTH_BUFFER, GFP_KERNEL);
 			if (info) {
 				if (NULL ==
@@ -3305,10 +2749,10 @@ struct dentry *Novfs_i_lookup(struct ino
 				     ERR_PTR(verify_dentry(dentry, 1)))) {
 					name.name = dentry->d_name.name;
 					name.len = dentry->d_name.len;
-					name.hash = Novfs_internal_hash(&name);
+					name.hash = novfs_internal_hash(&name);
 
-					if (Novfs_lock_inode_cache(dir)) {
-						if (!Novfs_get_entry
+					if (novfs_lock_inode_cache(dir)) {
+						if (!novfs_get_entry
 						    (dir, &name, &ino, info)) {
 							inode =
 							    ilookup(dentry->
@@ -3319,21 +2763,21 @@ struct dentry *Novfs_i_lookup(struct ino
 								     info);
 							}
 						}
-						Novfs_unlock_inode_cache(dir);
+						novfs_unlock_inode_cache(dir);
 					}
 
 					if (!inode && ino) {
-						uid = Scope_Get_Uid(id->Scope);
-						if (Novfs_lock_inode_cache(dir)) {
-							inode = Novfs_get_inode (dentry->d_sb, info->mode, 0, uid, ino, &name);
+						uid = novfs_scope_get_uid(id->Scope);
+						if (novfs_lock_inode_cache(dir)) {
+							inode = novfs_get_inode (dentry->d_sb, info->mode, 0, uid, ino, &name);
 							if (inode) {
-								if (!Novfs_get_entry(dir, &dentry->d_name, &ino, info)) {
+								if (!novfs_get_entry(dir, &dentry->d_name, &ino, info)) {
 									update_inode
 									    (inode,
 									     info);
 								}
 							}
-							Novfs_unlock_inode_cache
+							novfs_unlock_inode_cache
 							    (dir);
 						}
 					}
@@ -3343,10 +2787,10 @@ struct dentry *Novfs_i_lookup(struct ino
 	}
 
 	if (!retVal) {
-		dentry->d_op = &Novfs_dentry_operations;
+		dentry->d_op = &novfs_dentry_operations;
 		if (inode) {
 			parent = dget_parent(dentry);
-			Novfs_d_add(dentry->d_parent, dentry, inode, 1);
+			novfs_d_add(dentry->d_parent, dentry, inode, 1);
 			dput(parent);
 		} else {
 			d_add(dentry, inode);
@@ -3357,42 +2801,29 @@ struct dentry *Novfs_i_lookup(struct ino
 		kfree(info);
 
 	DbgPrint
-	    ("Novfs_i_lookup: inode=0x%p dentry->d_inode=0x%p return=0x%p\n",
+	    ("novfs_i_lookup: inode=0x%p dentry->d_inode=0x%p return=0x%p\n",
 	     dir, dentry->d_inode, retVal);
 
 	return (retVal);
 }
 
-/*++======================================================================*/
-int Novfs_i_unlink(struct inode *dir, struct dentry *dentry)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_i_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int retCode = -ENOENT;
 	struct inode *inode;
-	session_t session;
+	struct novfs_schandle session;
 	char *path, *buf;
 	uint64_t t64;
 
-	DbgPrint("Novfs_i_unlink: dir=0x%p dir->i_ino=%d %.*s\n", dir,
+	DbgPrint("novfs_i_unlink: dir=0x%p dir->i_ino=%d %.*s\n", dir,
 		 dir->i_ino, dentry->d_name.len, dentry->d_name.name);
-	DbgPrint("Novfs_i_unlink: IS_ROOT(dentry)=%d\n", IS_ROOT(dentry));
-	DbgPrint("Novfs_i_unlink: IS_ROOT(dentry->d_parent)=%d\n",
+	DbgPrint("novfs_i_unlink: IS_ROOT(dentry)=%d\n", IS_ROOT(dentry));
+	DbgPrint("novfs_i_unlink: IS_ROOT(dentry->d_parent)=%d\n",
 		 IS_ROOT(dentry->d_parent));
-	DbgPrint("Novfs_i_unlink: IS_ROOT(dentry->d_parent->d_parent)=%d\n",
+	DbgPrint("novfs_i_unlink: IS_ROOT(dentry->d_parent->d_parent)=%d\n",
 		 IS_ROOT(dentry->d_parent->d_parent));
 	DbgPrint
-	    ("Novfs_i_unlink: IS_ROOT(dentry->d_parent->d_parent->d_parent)=%d\n",
+	    ("novfs_i_unlink: IS_ROOT(dentry->d_parent->d_parent->d_parent)=%d\n",
 	     IS_ROOT(dentry->d_parent->d_parent->d_parent));
 
 	if (IS_ROOT(dentry) ||	/* Root */
@@ -3405,44 +2836,46 @@ int Novfs_i_unlink(struct inode *dir, st
 	inode = dentry->d_inode;
 	if (inode) {
 		DbgPrint
-		    ("Novfs_i_unlink: dir=0x%p dir->i_ino=%d inode=0x%p ino=%d\n",
+		    ("novfs_i_unlink: dir=0x%p dir->i_ino=%d inode=0x%p ino=%d\n",
 		     dir, dir->i_ino, inode, inode->i_ino);
-		if (inode->FSPRIVATE) {
+		if (inode->i_private) {
 			session =
-			    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+			    novfs_scope_get_sessionId(((struct inode_data *) inode->
+						 i_private)->Scope);
 			if (0 == SC_PRESENT(session)) {
-				((struct inode_data *)inode->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(dentry);
-				session = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+				((struct inode_data *) inode->i_private)->Scope =
+				    novfs_get_scope(dentry);
+				session =
+				    novfs_scope_get_sessionId(((struct inode_data *) inode->
+							 i_private)->Scope);
 			}
 
-			buf =
-			    (char *)Novfs_Malloc(PATH_LENGTH_BUFFER,
-						 GFP_KERNEL);
+			buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 			if (buf) {
 				path =
-				    Novfs_dget_path(dentry, buf,
+				    novfs_dget_path(dentry, buf,
 						    PATH_LENGTH_BUFFER);
 				if (path) {
 					DbgPrint
-					    ("Novfs_i_unlink: path %s mode 0%o\n",
+					    ("novfs_i_unlink: path %s mode 0%o\n",
 					     path, inode->i_mode);
 					if (IS_ROOT(dentry->d_parent->d_parent)) {
-						retCode = do_logout(&dentry->d_name, &session);
+						retCode = novfs_daemon_logout(&dentry->d_name, &session);
 					} else {
 						retCode =
-						    Novfs_Delete(path,
+						    novfs_delete(path,
 								 S_ISDIR(inode->
 									 i_mode),
 								 session);
 					}
 					if (!retCode || IS_DEADDIR(inode)) {
-						Novfs_remove_inode_entry(dir,
+						novfs_remove_inode_entry(dir,
 									 &dentry->
 									 d_name,
 									 0);
 						dentry->d_time = 0;
 						t64 = 0;
-						Scope_Set_UserSpace(&t64, &t64,
+						novfs_scope_set_userspace(&t64, &t64,
 								    &t64, &t64);
 						retCode = 0;
 					}
@@ -3452,33 +2885,20 @@ int Novfs_i_unlink(struct inode *dir, st
 		}
 	}
 
-	DbgPrint("Novfs_i_unlink: retCode 0x%x\n", retCode);
+	DbgPrint("novfs_i_unlink: retCode 0x%x\n", retCode);
 	return (retCode);
 }
 
-/*++======================================================================*/
-int Novfs_i_mkdir(struct inode *dir, struct dentry *dentry, int mode)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_i_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	char *path, *buf;
-	session_t session;
+	struct novfs_schandle session;
 	int retCode = 0;
 	struct inode *inode;
-	struct entry_info info;
+	struct novfs_entry_info info;
 	uid_t uid;
 
-	DbgPrint("Novfs_i_mkdir: dir=0x%p ino=%d dentry=0x%p %.*s mode=0%lo\n",
+	DbgPrint("novfs_i_mkdir: dir=0x%p ino=%d dentry=0x%p %.*s mode=0%lo\n",
 		 dir, dir->i_ino, dentry, dentry->d_name.len,
 		 dentry->d_name.name, mode);
 
@@ -3491,46 +2911,53 @@ int Novfs_i_mkdir(struct inode *dir, str
 
 	mode |= S_IFDIR;
 	mode &= (S_IFMT | S_IRWXU);
-	if (dir->FSPRIVATE) {
+	if (dir->i_private) {
 		session =
-		    Scope_Get_SessionId(((struct inode_data *)dir->FSPRIVATE)->Scope);
+		    novfs_scope_get_sessionId(((struct inode_data *) dir->i_private)->Scope);
 		if (0 == SC_PRESENT(session)) {
-			((struct inode_data *)dir->FSPRIVATE)->Scope =
-			    Scope_Get_ScopefromPath(dentry);
+			((struct inode_data *) dir->i_private)->Scope =
+			    novfs_get_scope(dentry);
 			session =
-			    Scope_Get_SessionId(((struct inode_data *)dir->FSPRIVATE)->Scope);
+			    novfs_scope_get_sessionId(((struct inode_data *) dir->i_private)->
+						Scope);
 		}
 
-		uid = Scope_Get_Uid(((struct inode_data *)dir->FSPRIVATE)->Scope);
-		buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+		uid = novfs_scope_get_uid(((struct inode_data *) dir->i_private)->Scope);
+		buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 		if (buf) {
-			path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+			path = novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
 			if (path) {
-				DbgPrint("Novfs_i_mkdir: path %s\n", path);
+				DbgPrint("novfs_i_mkdir: path %s\n", path);
 				retCode =
-				    Novfs_Create(path, S_ISDIR(mode), session);
+				    novfs_create(path, S_ISDIR(mode), session);
 				if (!retCode) {
-					retCode = Novfs_Get_File_Info(path, &info, &session);
+					retCode =
+					    novfs_get_file_info(path, &info,
+								session);
 					if (!retCode) {
-						retCode = Novfs_i_mknod(dir, dentry, mode, 0);
+						retCode =
+						    novfs_i_mknod(dir, dentry,
+								  mode, 0);
 						inode = dentry->d_inode;
 						if (inode) {
 							update_inode(inode,
 								     &info);
-							((struct inode_data *)inode->FSPRIVATE)->Flags &= ~UPDATE_INODE;
+							((struct inode_data *) inode->
+							 i_private)->Flags &=
+				       ~UPDATE_INODE;
 
 							dentry->d_time =
 							    jiffies +
-							    (File_update_timeout
+							    (novfs_update_timeout
 							     * HZ);
 
-							Novfs_lock_inode_cache
+							novfs_lock_inode_cache
 							    (dir);
-							if (Novfs_update_entry
+							if (novfs_update_entry
 							    (dir,
 							     &dentry->d_name, 0,
 							     &info)) {
-								Novfs_add_inode_entry
+								novfs_add_inode_entry
 								    (dir,
 								     &dentry->
 								     d_name,
@@ -3538,7 +2965,7 @@ int Novfs_i_mkdir(struct inode *dir, str
 								     i_ino,
 								     &info);
 							}
-							Novfs_unlock_inode_cache
+							novfs_unlock_inode_cache
 							    (dir);
 						}
 
@@ -3551,39 +2978,13 @@ int Novfs_i_mkdir(struct inode *dir, str
 
 	return (retCode);
 }
-
-/*++======================================================================*/
-int Novfs_i_rmdir(struct inode *inode, struct dentry *dentry)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+
+int novfs_i_rmdir(struct inode *inode, struct dentry *dentry)
 {
-	return (Novfs_i_unlink(inode, dentry));
+	return (novfs_i_unlink(inode, dentry));
 }
 
-/*++======================================================================*/
-int Novfs_i_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_i_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
 {
 	struct inode *inode = NULL;
 	int retCode = -EACCES;
@@ -3597,44 +2998,44 @@ int Novfs_i_mknod(struct inode *dir, str
 		return (-EACCES);
 	}
 
-	if (((struct inode_data *)dir->FSPRIVATE)) {
-		uid = Scope_Get_Uid(((struct inode_data *)dir->FSPRIVATE)->Scope);
+	if (((struct inode_data *) dir->i_private)) {
+		uid = novfs_scope_get_uid(((struct inode_data *) dir->i_private)->Scope);
 		if (mode & (S_IFREG | S_IFDIR)) {
 			inode =
-			    Novfs_get_inode(dir->i_sb, mode, dev, uid, 0, &dentry->d_name);
+			    novfs_get_inode(dir->i_sb, mode, dev, uid, 0, &dentry->d_name);
 		}
 	}
 	if (inode) {
-		struct entry_info info;
+		struct novfs_entry_info info;
 
-		dentry->d_op = &Novfs_dentry_operations;
+		dentry->d_op = &novfs_dentry_operations;
 		parent = dget_parent(dentry);
-		Novfs_d_add(parent, dentry, inode, 0);
+		novfs_d_add(parent, dentry, inode, 0);
 		memset(&info, 0, sizeof(info));
 		info.mode = inode->i_mode;
-		Novfs_lock_inode_cache(dir);
-		Novfs_add_inode_entry(dir, &dentry->d_name, inode->i_ino,
+		novfs_lock_inode_cache(dir);
+		novfs_add_inode_entry(dir, &dentry->d_name, inode->i_ino,
 				      &info);
-		Novfs_unlock_inode_cache(dir);
+		novfs_unlock_inode_cache(dir);
 
 		dput(parent);
 
 		retCode = 0;
 	}
-	DbgPrint("Novfs_i_mknod: return 0x%x\n", retCode);
+	DbgPrint("novfs_i_mknod: return 0x%x\n", retCode);
 	return retCode;
 }
 
-int Novfs_i_rename(struct inode *odir, struct dentry *od, struct inode *ndir,
+int novfs_i_rename(struct inode *odir, struct dentry *od, struct inode *ndir,
 		   struct dentry *nd)
 {
 	int retCode = -ENOTEMPTY;
 	char *newpath, *newbuf, *newcon;
 	char *oldpath, *oldbuf, *oldcon;
 	struct qstr newname, oldname;
-	struct entry_info *info = NULL;
+	struct novfs_entry_info *info = NULL;
 	int oldlen, newlen;
-	session_t session;
+	struct novfs_schandle session;
 	ino_t ino;
 
 	if (IS_ROOT(od) ||	/* Root */
@@ -3644,29 +3045,29 @@ int Novfs_i_rename(struct inode *odir, s
 		return (-EACCES);
 	}
 
-	DbgPrint("Novfs_i_rename: odir=0x%p ino=%d ndir=0x%p ino=%d\n", odir,
+	DbgPrint("novfs_i_rename: odir=0x%p ino=%d ndir=0x%p ino=%d\n", odir,
 		 odir->i_ino, ndir, ndir->i_ino);
 
-	oldbuf = Novfs_Malloc(PATH_LENGTH_BUFFER * 2, GFP_KERNEL);
+	oldbuf = kmalloc(PATH_LENGTH_BUFFER * 2, GFP_KERNEL);
 	newbuf = oldbuf + PATH_LENGTH_BUFFER;
 	if (oldbuf && newbuf) {
-		oldpath = Novfs_dget_path(od, oldbuf, PATH_LENGTH_BUFFER);
-		newpath = Novfs_dget_path(nd, newbuf, PATH_LENGTH_BUFFER);
+		oldpath = novfs_dget_path(od, oldbuf, PATH_LENGTH_BUFFER);
+		newpath = novfs_dget_path(nd, newbuf, PATH_LENGTH_BUFFER);
 		if (oldpath && newpath) {
 			oldlen = PATH_LENGTH_BUFFER - (int)(oldpath - oldbuf);
 			newlen = PATH_LENGTH_BUFFER - (int)(newpath - newbuf);
 
 			DbgPrint
-			    ("Novfs_i_rename: od=0x%p od->inode=0x%p od->inode->i_ino=%d %s\n",
+			    ("novfs_i_rename: od=0x%p od->inode=0x%p od->inode->i_ino=%d %s\n",
 			     od, od->d_inode, od->d_inode->i_ino, oldpath);
 			if (nd->d_inode) {
 				DbgPrint
-				    ("Novfs_i_rename: nd=0x%p nd->inode=0x%p nd->inode->i_ino=%d %s\n",
+				    ("novfs_i_rename: nd=0x%p nd->inode=0x%p nd->inode->i_ino=%d %s\n",
 				     nd, nd->d_inode, nd->d_inode->i_ino,
 				     newpath);
 			} else {
 				DbgPrint
-				    ("Novfs_i_rename: nd=0x%p nd->inode=0x%p %s\n",
+				    ("novfs_i_rename: nd=0x%p nd->inode=0x%p %s\n",
 				     nd, nd->d_inode, newpath);
 			}
 
@@ -3675,9 +3076,9 @@ int Novfs_i_rename(struct inode *odir, s
 			 */
 			newcon = strchr(newpath + 1, '\\');
 			oldcon = strchr(oldpath + 1, '\\');
-			DbgPrint("Novfs_i_rename: newcon=0x%p newpath=0x%p\n",
+			DbgPrint("novfs_i_rename: newcon=0x%p newpath=0x%p\n",
 				 newcon, newpath);
-			DbgPrint("Novfs_i_rename: oldcon=0x%p oldpath=0x%p\n",
+			DbgPrint("novfs_i_rename: oldcon=0x%p oldpath=0x%p\n",
 				 oldcon, oldpath);
 			retCode = -EXDEV;
 			if (newcon && oldcon
@@ -3685,8 +3086,8 @@ int Novfs_i_rename(struct inode *odir, s
 				(int)(oldcon - oldpath))) {
 				newcon = strchr(newcon + 1, '\\');
 				oldcon = strchr(oldcon + 1, '\\');
-				DbgPrint("Novfs_i_rename2: newcon=0x%p newpath=0x%p\n", newcon, newpath);
-				DbgPrint("Novfs_i_rename2: oldcon=0x%p oldpath=0x%p\n", oldcon, oldpath);
+				DbgPrint("novfs_i_rename2: newcon=0x%p newpath=0x%p\n", newcon, newpath);
+				DbgPrint("novfs_i_rename2: oldcon=0x%p oldpath=0x%p\n", oldcon, oldpath);
 				if (newcon && oldcon &&
 				    ((int)(newcon - newpath) == (int)(oldcon - oldpath))) {
 					newname.name = newpath;
@@ -3696,43 +3097,58 @@ int Novfs_i_rename(struct inode *odir, s
 					oldname.name = oldpath;
 					oldname.len = (int)(oldcon - oldpath);
 					oldname.hash = 0;
-					if (!Novfs_d_strcmp(&newname, &oldname)) {
+					if (!novfs_d_strcmp(&newname, &oldname)) {
 
 						if (od->d_inode
-						    && od->d_inode->FSPRIVATE) {
+						    && od->d_inode->i_private) {
 
-							if ((nd->d_inode) &&
-							    (nd->d_inode->FSPRIVATE)) {
-								session = Scope_Get_SessionId(((struct inode_data *)ndir->FSPRIVATE)->Scope);
-								if (0 == SC_PRESENT(session)) {
-									((struct inode_data *)ndir->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(nd);
-									session = Scope_Get_SessionId(((struct inode_data *)ndir->FSPRIVATE)->Scope);
+							if (nd->d_inode
+							    && nd->d_inode->
+							    i_private) {
+								session =
+								    novfs_scope_get_sessionId
+								    (((struct inode_data *) ndir->i_private)->Scope);
+								if (0 ==
+								    SC_PRESENT
+								    (session)) {
+									((struct inode_data *) ndir->i_private)->Scope = novfs_get_scope(nd);
+									session
+									    =
+									    novfs_scope_get_sessionId
+									    (((struct inode_data *) ndir->i_private)->Scope);
 								}
 
-								retCode = Novfs_Delete(newpath, S_ISDIR(nd->d_inode->i_mode), session);
+								retCode =
+								    novfs_delete
+								    (newpath,
+								     S_ISDIR
+								     (nd->
+								      d_inode->
+								      i_mode),
+								     session);
 							}
 
-							session = Scope_Get_SessionId(((struct inode_data *) ndir->FSPRIVATE)->Scope);
+							session = novfs_scope_get_sessionId(((struct inode_data *) ndir->i_private)->Scope);
 							if (0 == SC_PRESENT(session)) {
-								((struct inode_data *)ndir->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(nd);
-								session = Scope_Get_SessionId(((struct inode_data *) ndir->FSPRIVATE)->Scope);
+								((struct inode_data *)ndir->i_private)->Scope = novfs_get_scope(nd);
+								session = novfs_scope_get_sessionId(((struct inode_data *) ndir->i_private)->Scope);
 							}
-							retCode = Novfs_Rename_File(S_ISDIR(od->d_inode->i_mode), oldpath, oldlen - 1, newpath, newlen - 1, session);
+							retCode = novfs_rename_file(S_ISDIR(od->d_inode->i_mode), oldpath, oldlen - 1, newpath, newlen - 1, session);
 
 							if (!retCode) {
-								info = (struct entry_info *) oldbuf;
+								info = (struct novfs_entry_info *) oldbuf;
 								od->d_time = 0;
-								Novfs_remove_inode_entry(odir, &od->d_name, 0);
-								Novfs_remove_inode_entry(ndir, &nd->d_name, 0);
-								Novfs_Get_File_Info(newpath, info, &session);
-								nd->d_time = jiffies + (File_update_timeout * HZ);
+								novfs_remove_inode_entry(odir, &od->d_name, 0);
+								novfs_remove_inode_entry(ndir, &nd->d_name, 0);
+								novfs_get_file_info(newpath, info, session);
+								nd->d_time = jiffies + (novfs_update_timeout * HZ);
 
 								if (od->d_inode && od->d_inode->i_ino) {
 									ino = od->d_inode-> i_ino;
 								} else {
-									ino = (ino_t)atomic_inc_return(&Novfs_Inode_Number);
+									ino = (ino_t)atomic_inc_return(&novfs_Inode_Number);
 								}
-								Novfs_add_inode_entry(ndir, &nd->d_name, ino, info);
+								novfs_add_inode_entry(ndir, &nd->d_name, ino, info);
 							}
 						}
 					}
@@ -3744,44 +3160,12 @@ int Novfs_i_rename(struct inode *odir, s
 	if (oldbuf)
 		kfree(oldbuf);
 
-	DbgPrint("Novfs_i_rename: return %d\n", retCode);
+	DbgPrint("novfs_i_rename: return %d\n", retCode);
 	return (retCode);
 }
 
-/*++======================================================================*/
-int Novfs_i_permission(struct inode *inode, int mask)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	int retCode = 0;
-
-	return (retCode);
-}
 
-/*++======================================================================*/
-int Novfs_i_setattr(struct dentry *dentry, struct iattr *attr)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_i_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	char *path, *buf;
 	struct inode *inode = dentry->d_inode;
@@ -3789,7 +3173,7 @@ int Novfs_i_setattr(struct dentry *dentr
 	char mtime_buf[32];
 	char ctime_buf[32];
 	unsigned int ia_valid = attr->ia_valid;
-	session_t session;
+	struct novfs_schandle session;
 	int retVal = 0;
 	struct iattr mattr;
 
@@ -3800,20 +3184,21 @@ int Novfs_i_setattr(struct dentry *dentr
 		return (-EACCES);
 	}
 
-	if (inode && inode->FSPRIVATE) {
+	if (inode && inode->i_private) {
 		session =
-		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
+		    novfs_scope_get_sessionId(((struct inode_data *) inode->i_private)->
+					Scope);
 		if (0 == SC_PRESENT(session)) {
-			((struct inode_data *)inode->FSPRIVATE)->Scope =
-			    Scope_Get_ScopefromPath(dentry);
+			((struct inode_data *) inode->i_private)->Scope =
+			    novfs_get_scope(dentry);
 			session =
-			    Scope_Get_SessionId(((struct inode_data *) inode->
-						 FSPRIVATE)->Scope);
+			    novfs_scope_get_sessionId(((struct inode_data *) inode->
+						 i_private)->Scope);
 		}
 
-		buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+		buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 		if (buf) {
-			path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+			path = novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
 			if (path) {
 				strcpy(atime_buf, "Unspecified");
 				strcpy(mtime_buf, "Unspecified");
@@ -3831,7 +3216,7 @@ int Novfs_i_setattr(struct dentry *dentr
 						ctime_buf);
 				}
 				/* Removed for Bug 132374. jlt */
-				DbgPrint("Novfs_i_setattr: %s\n"
+				DbgPrint("novfs_i_setattr: %s\n"
 					 "   ia_valid:      0x%x\n"
 					 "   ia_mode:       0%o\n"
 					 "   ia_uid:        %d\n"
@@ -3855,19 +3240,28 @@ int Novfs_i_setattr(struct dentry *dentr
 					    ~(ATTR_FILE | ATTR_SIZE);
 					attr = &mattr;
 					ia_valid = attr->ia_valid;
-#if 0	// thanks to vfs changes in our tree...
-					retVal = Novfs_Truncate_File_Ex(attr->ia_file->private_data, attr->ia_size, session);
+#if 0   // thanks to vfs changes in our tree...
+					retVal =
+					    novfs_trunc_ex(attr->
+								   ia_file->
+								   private_data,
+								   attr->
+								   ia_size,
+								   session);
 					if (!retVal) {
 						inode->i_size = attr->ia_size;
-						((struct inode_data *)inode->FSPRIVATE)->Flags |= UPDATE_INODE;
+						((struct inode_data *) inode->
+						 i_private)->Flags |=
+			       UPDATE_INODE;
 					}
 #endif
 				}
 
 				if (ia_valid
 				    && !(retVal =
-					 Novfs_Set_Attr(path, attr, session))) {
-					((struct inode_data *)inode->FSPRIVATE)->Flags |= UPDATE_INODE;
+					 novfs_set_attr(path, attr, session))) {
+					((struct inode_data *) inode->i_private)->
+					    Flags |= UPDATE_INODE;
 
 					if (ia_valid & ATTR_ATIME)
 						inode->i_atime = attr->ia_atime;
@@ -3886,26 +3280,13 @@ int Novfs_i_setattr(struct dentry *dentr
 		}
 		kfree(buf);
 	}
-	DbgPrint("Novfs_i_setattr: return 0x%x\n", retVal);
+	DbgPrint("novfs_i_setattr: return 0x%x\n", retVal);
 
 	return (retVal);
 }
 
-/*++======================================================================*/
-int Novfs_i_getattr(struct vfsmount *mnt, struct dentry *dentry,
+int novfs_i_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		    struct kstat *kstat)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	int retCode = 0;
 	char atime_buf[32];
@@ -3913,32 +3294,32 @@ int Novfs_i_getattr(struct vfsmount *mnt
 	char ctime_buf[32];
 	struct inode *inode = dentry->d_inode;
 
-	struct entry_info info;
+	struct novfs_entry_info info;
 	char *path, *buf;
-	session_t session;
+	struct novfs_schandle session;
 	struct inode_data *id;
 
 	if (!IS_ROOT(dentry) && !IS_ROOT(dentry->d_parent)) {
 		SC_INITIALIZE(session);
-		id = dentry->d_inode->FSPRIVATE;
+		id = dentry->d_inode->i_private;
 
 		if (id && (id->Flags & UPDATE_INODE)) {
-			session = Scope_Get_SessionId(id->Scope);
+			session = novfs_scope_get_sessionId(id->Scope);
 
 			if (0 == SC_PRESENT(session)) {
-				id->Scope = Scope_Get_ScopefromPath(dentry);
-				session = Scope_Get_SessionId(id->Scope);
+				id->Scope = novfs_get_scope(dentry);
+				session = novfs_scope_get_sessionId(id->Scope);
 			}
 
-			buf =
-			    (char *)Novfs_Malloc(PATH_LENGTH_BUFFER,
-						 GFP_KERNEL);
+			buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 			if (buf) {
 				path =
-				    Novfs_dget_path(dentry, buf,
+				    novfs_dget_path(dentry, buf,
 						    PATH_LENGTH_BUFFER);
 				if (path) {
-					retCode = Novfs_Get_File_Info(path, &info, &session);
+					retCode =
+					    novfs_get_file_info(path, &info,
+								session);
 					if (!retCode) {
 						update_inode(inode, &info);
 						id->Flags &= ~UPDATE_INODE;
@@ -3969,7 +3350,7 @@ int Novfs_i_getattr(struct vfsmount *mnt
 	ctime_r(&kstat->mtime.tv_sec, mtime_buf);
 	ctime_r(&kstat->ctime.tv_sec, ctime_buf);
 
-	DbgPrint("Novfs_i_getattr: 0x%x 0x%p <%.*s>\n"
+	DbgPrint("novfs_i_getattr: 0x%x 0x%p <%.*s>\n"
 		 "   ino: %d\n"
 		 "   dev: 0x%x\n"
 		 "   mode: 0%o\n"
@@ -3997,24 +3378,11 @@ int Novfs_i_getattr(struct vfsmount *mnt
 	return (retCode);
 }
 
-/*++======================================================================*/
-int Novfs_i_getxattr(struct dentry *dentry, const char *name, void *buffer,
+int novfs_i_getxattr(struct dentry *dentry, const char *name, void *buffer,
 		     size_t buffer_size)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 	struct inode *inode = dentry->d_inode;
-	session_t sessionId;
+	struct novfs_schandle sessionId;
 	char *path, *buf, *bufRead;
 	ssize_t dataLen;
 
@@ -4022,44 +3390,53 @@ int Novfs_i_getxattr(struct dentry *dent
 
 	SC_INITIALIZE(sessionId);
 
-	DbgPrint("Novfs_i_getxattr: Ian\n");	/*%.*s\n", dentry->d_name.len, dentry->d_name.name); */
+	DbgPrint("novfs_i_getxattr: Ian\n");	/*%.*s\n", dentry->d_name.len, dentry->d_name.name); */
 	DbgPrint
-	    ("Novfs_i_getxattr: dentry->d_name.len %u, dentry->d_name.name %s\n",
+	    ("novfs_i_getxattr: dentry->d_name.len %u, dentry->d_name.name %s\n",
 	     dentry->d_name.len, dentry->d_name.name);
-	DbgPrint("Novfs_i_getxattr: name %s\n", name);
-	DbgPrint("Novfs_i_getxattr: size %u\n", buffer_size);
+	DbgPrint("novfs_i_getxattr: name %s\n", name);
+	DbgPrint("novfs_i_getxattr: size %u\n", buffer_size);
 
-	if (inode && inode->FSPRIVATE) {
+	if (inode && inode->i_private) {
 		sessionId =
-		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
-		DbgPrint("Novfs_i_getxattr: SessionId = %u\n", sessionId);
+		    novfs_scope_get_sessionId(((struct inode_data *) inode->i_private)->
+					Scope);
+		DbgPrint("novfs_i_getxattr: SessionId = %u\n", sessionId);
 		//if (0 == sessionId)
 		if (0 == SC_PRESENT(sessionId)) {
-			((struct inode_data *) inode->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(dentry);
-			sessionId = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
-			DbgPrint("Novfs_i_getxattr: SessionId = %u\n",
+			((struct inode_data *) inode->i_private)->Scope =
+			    novfs_get_scope(dentry);
+			sessionId =
+			    novfs_scope_get_sessionId(((struct inode_data *) inode->
+						 i_private)->Scope);
+			DbgPrint("novfs_i_getxattr: SessionId = %u\n",
 				 sessionId);
 		}
 	}
 
 	dataLen = 0;
-	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	if (buf) {
-		path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+		path = novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
 		if (path) {
-			bufRead = (char *)Novfs_Malloc(XA_BUFFER, GFP_KERNEL);
+			bufRead = kmalloc(XA_BUFFER, GFP_KERNEL);
 			if (bufRead) {
-				retxcode = Novfs_GetX_File_Info(path, name, bufRead, XA_BUFFER, &dataLen, &sessionId);
-				DbgPrint("Novfs_i_getxattr: after Novfs_GetX_File_Info retxcode = %d\n", retxcode);
+				retxcode =
+				    novfs_getx_file_info(path, name, bufRead,
+							 XA_BUFFER, &dataLen,
+							 sessionId);
+				DbgPrint
+				    ("novfs_i_getxattr: after novfs_GetX_File_Info retxcode = %d\n",
+				     retxcode);
 				if (!retxcode) {
-					mydump(64, bufRead);
+					novfs_dump(64, bufRead);
 					if (buffer_size != 0) {
 						if (buffer_size >= dataLen) {
 							memcpy(buffer, bufRead,
 							       dataLen);
 						} else {
 							DbgPrint
-							    ("Novfs_i_getxattr: (!!!) not enough buffer_size. buffer_size = %d, dataLen = %d\n",
+							    ("novfs_i_getxattr: (!!!) not enough buffer_size. buffer_size = %d, dataLen = %d\n",
 							     buffer_size,
 							     dataLen);
 							retxcode = -ERANGE;
@@ -4086,25 +3463,12 @@ int Novfs_i_getxattr(struct dentry *dent
 	return (dataLen);
 }
 
-/*++======================================================================*/
-int Novfs_i_setxattr(struct dentry *dentry, const char *name, const void *value,
+int novfs_i_setxattr(struct dentry *dentry, const char *name, const void *value,
 		     size_t value_size, int flags)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
 {
 
 	struct inode *inode = dentry->d_inode;
-	session_t sessionId;
+	struct novfs_schandle sessionId;
 	char *path, *buf;
 	unsigned long bytesWritten = 0;
 	int retError = 0;
@@ -4112,42 +3476,42 @@ int Novfs_i_setxattr(struct dentry *dent
 
 	SC_INITIALIZE(sessionId);
 
-	DbgPrint("Novfs_i_setxattr: Ian\n");	/*%.*s\n", dentry->d_name.len, dentry->d_name.name); */
+	DbgPrint("novfs_i_setxattr: Ian\n");	/*%.*s\n", dentry->d_name.len, dentry->d_name.name); */
 	DbgPrint
-	    ("Novfs_i_setxattr: dentry->d_name.len %u, dentry->d_name.name %s\n",
+	    ("novfs_i_setxattr: dentry->d_name.len %u, dentry->d_name.name %s\n",
 	     dentry->d_name.len, dentry->d_name.name);
-	DbgPrint("Novfs_i_setxattr: name %s\n", name);
-	DbgPrint("Novfs_i_setxattr: value_size %u\n", value_size);
-	DbgPrint("Novfs_i_setxattr: flags %d\n", flags);
+	DbgPrint("novfs_i_setxattr: name %s\n", name);
+	DbgPrint("novfs_i_setxattr: value_size %u\n", value_size);
+	DbgPrint("novfs_i_setxattr: flags %d\n", flags);
 
-	if (inode && inode->FSPRIVATE) {
+	if (inode && inode->i_private) {
 		sessionId =
-		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->
+		    novfs_scope_get_sessionId(((struct inode_data *) inode->i_private)->
 					Scope);
-		DbgPrint("Novfs_i_setxattr: SessionId = %u\n", sessionId);
+		DbgPrint("novfs_i_setxattr: SessionId = %u\n", sessionId);
 		//if (0 == sessionId)
 		if (0 == SC_PRESENT(sessionId)) {
-			((struct inode_data *)inode->FSPRIVATE)->Scope =
-			    Scope_Get_ScopefromPath(dentry);
+			((struct inode_data *) inode->i_private)->Scope =
+			    novfs_get_scope(dentry);
 			sessionId =
-			    Scope_Get_SessionId(((struct inode_data *)inode->
-						 FSPRIVATE)->Scope);
-			DbgPrint("Novfs_i_setxattr: SessionId = %u\n",
+			    novfs_scope_get_sessionId(((struct inode_data *) inode->
+						 i_private)->Scope);
+			DbgPrint("novfs_i_setxattr: SessionId = %u\n",
 				 sessionId);
 		}
 	}
 
-	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	if (buf) {
-		path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+		path = novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
 		if (path) {
 			retxcode =
-			    Novfs_SetX_File_Info(path, name, value, value_size,
+			    novfs_setx_file_info(path, name, value, value_size,
 						 &bytesWritten, flags,
-						 &sessionId);
+						 sessionId);
 			if (!retxcode) {
 				DbgPrint
-				    ("Novfs_i_setxattr: bytesWritten = %u\n",
+				    ("novfs_i_setxattr: bytesWritten = %u\n",
 				     bytesWritten);
 			}
 		}
@@ -4164,53 +3528,59 @@ int Novfs_i_setxattr(struct dentry *dent
 	return (retError);
 }
 
-int Novfs_i_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)
+int novfs_i_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
 	struct inode *inode = dentry->d_inode;
-	session_t sessionId;
+	struct novfs_schandle sessionId;
 	char *path, *buf, *bufList;
 	ssize_t dataLen;
-
 	int retxcode = 0;
 
 	SC_INITIALIZE(sessionId);
 
-	DbgPrint("Novfs_i_listxattr: Ian\n");	//%.*s\n", dentry->d_name.len, dentry->d_name.name);
+	DbgPrint("novfs_i_listxattr: Ian\n");	//%.*s\n", dentry->d_name.len, dentry->d_name.name);
 	DbgPrint
-	    ("Novfs_i_listxattr: dentry->d_name.len %u, dentry->d_name.name %s\n",
+	    ("novfs_i_listxattr: dentry->d_name.len %u, dentry->d_name.name %s\n",
 	     dentry->d_name.len, dentry->d_name.name);
-	DbgPrint("Novfs_i_listxattr: size %u\n", buffer_size);
+	DbgPrint("novfs_i_listxattr: size %u\n", buffer_size);
 
-	if (inode && inode->FSPRIVATE) {
+	if (inode && inode->i_private) {
 		sessionId =
-		    Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)-> Scope);
-		DbgPrint("Novfs_i_listxattr: SessionId = %u\n", sessionId);
+		    novfs_scope_get_sessionId(((struct inode_data *) inode->i_private)->
+					Scope);
+		DbgPrint("novfs_i_listxattr: SessionId = %u\n", sessionId);
 		//if (0 == sessionId)
 		if (0 == SC_PRESENT(sessionId)) {
-			((struct inode_data *)inode->FSPRIVATE)->Scope = Scope_Get_ScopefromPath(dentry);
-			sessionId = Scope_Get_SessionId(((struct inode_data *)inode->FSPRIVATE)->Scope);
-			DbgPrint("Novfs_i_listxattr: SessionId = %u\n",
+			((struct inode_data *) inode->i_private)->Scope =
+			    novfs_get_scope(dentry);
+			sessionId =
+			    novfs_scope_get_sessionId(((struct inode_data *) inode->
+						 i_private)->Scope);
+			DbgPrint("novfs_i_listxattr: SessionId = %u\n",
 				 sessionId);
 		}
 	}
 
 	dataLen = 0;
-	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	if (buf) {
-		path = Novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
+		path = novfs_dget_path(dentry, buf, PATH_LENGTH_BUFFER);
 		if (path) {
-			bufList = (char *)Novfs_Malloc(XA_BUFFER, GFP_KERNEL);
+			bufList = kmalloc(XA_BUFFER, GFP_KERNEL);
 			if (bufList) {
-				retxcode = Novfs_ListX_File_Info(path, bufList, XA_BUFFER, &dataLen, &sessionId);
+				retxcode =
+				    novfs_listx_file_info(path, bufList,
+							  XA_BUFFER, &dataLen,
+							  sessionId);
 
-				mydump(64, bufList);
+				novfs_dump(64, bufList);
 				if (buffer_size != 0) {
 					if (buffer_size >= dataLen) {
 						memcpy(buffer, bufList,
 						       dataLen);
 					} else {
 						DbgPrint
-						    ("Novfs_i_listxattr: (!!!) not enough buffer_size. buffer_size = %d, dataLen = %d\n",
+						    ("novfs_i_listxattr: (!!!) not enough buffer_size. buffer_size = %d, dataLen = %d\n",
 						     buffer_size, dataLen);
 						retxcode = -1;
 					}
@@ -4236,120 +3606,92 @@ int Novfs_i_listxattr(struct dentry *den
 	return (dataLen);
 }
 
-int Novfs_i_revalidate(struct dentry *dentry)
+int novfs_i_revalidate(struct dentry *dentry)
 {
 
-	DbgPrint("Novfs_i_revalidate: name %.*s\n", dentry->d_name.len,
+	DbgPrint("novfs_i_revalidate: name %.*s\n", dentry->d_name.len,
 		 dentry->d_name.name);
 
 	return (0);
 }
 
-void Novfs_read_inode(struct inode *inode)
+void novfs_read_inode(struct inode *inode)
 {
-	DbgPrint("Novfs_read_inode: 0x%p %d\n", inode, inode->i_ino);
+	DbgPrint("novfs_read_inode: 0x%p %d\n", inode, inode->i_ino);
 }
 
-void Novfs_write_inode(struct inode *inode)
+void novfs_write_inode(struct inode *inode)
 {
-	DbgPrint("Novfs_write_inode: Inode=0x%p Ino=%d\n", inode, inode->i_ino);
+	DbgPrint("novfs_write_inode: Inode=0x%p Ino=%d\n", inode, inode->i_ino);
 }
 
-int Novfs_notify_change(struct dentry *dentry, struct iattr *attr)
+int novfs_notify_change(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = dentry->d_inode;
 
 	DbgPrint
-	    ("Novfs_notify_change: Dentry=0x%p Name=%.*s Inode=0x%p Ino=%d ia_valid=0x%x\n",
+	    ("novfs_notify_change: Dentry=0x%p Name=%.*s Inode=0x%p Ino=%d ia_valid=0x%x\n",
 	     dentry, dentry->d_name.len, dentry->d_name.name, inode,
 	     inode->i_ino, attr->ia_valid);
 	return (0);
 }
 
-/*++======================================================================*/
-void Novfs_clear_inode(struct inode *inode)
-/*
- * Arguments:    sb - pointer to the super_block
- *               buf - pointer to the statfs buffer
- *
- *  Returns:      0
- *
- *  Abstract:     Called when statfs(2) system called.
- *
- *  Notes:
- *
- *  Environment:  Superblock operation
- *
- *========================================================================*/
+void novfs_clear_inode(struct inode *inode)
 {
 	InodeCount--;
 
-	if (inode->FSPRIVATE) {
-		struct inode_data *id = inode->FSPRIVATE;
+	if (inode->i_private) {
+		struct inode_data *id = inode->i_private;
 
 		DbgPrint
-		    ("Novfs_clear_inode: inode=0x%p ino=%d Scope=0x%p Name=%s\n",
+		    ("novfs_clear_inode: inode=0x%p ino=%d Scope=0x%p Name=%s\n",
 		     inode, inode->i_ino, id->Scope, id->Name);
 
-		Novfs_free_inode_cache(inode);
+		novfs_free_inode_cache(inode);
 
 		down(&InodeList_lock);
 		list_del(&id->IList);
 		up(&InodeList_lock);
 
-		kfree(inode->FSPRIVATE);
-		inode->FSPRIVATE = NULL;
+		kfree(inode->i_private);
+		inode->i_private = NULL;
 
 		remove_inode_hash(inode);
 
 	} else {
-		DbgPrint("Novfs_clear_inode: inode=0x%p ino=%d\n", inode,
+		DbgPrint("novfs_clear_inode: inode=0x%p ino=%d\n", inode,
 			 inode->i_ino);
 	}
 }
 
-/*++======================================================================*/
-int Novfs_show_options(struct seq_file *s, struct vfsmount *m)
-/*
- * Arguments:
- *
- *  Returns:      0
- *
- *  Abstract:     Called when /proc/mounts is read
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+/* Called when /proc/mounts is read */
+int novfs_show_options(struct seq_file *s, struct vfsmount *m)
 {
 	char *buf, *path, *tmp;
 
-	buf = (char *)Novfs_Malloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	if (buf) {
 		struct path my_path;
 		my_path.mnt = m;
 		my_path.dentry = m->mnt_root;
 		path = d_path(&my_path, buf, PATH_LENGTH_BUFFER);
 		if (path) {
-			if (!Novfs_CurrentMount
-			    || (Novfs_CurrentMount
-				&& strcmp(Novfs_CurrentMount, path))) {
-				DbgPrint("Novfs_show_options: %.*s %.*s %s\n",
+			if (!novfs_current_mnt
+			    || (novfs_current_mnt
+				&& strcmp(novfs_current_mnt, path))) {
+				DbgPrint("novfs_show_options: %.*s %.*s %s\n",
 					 m->mnt_root->d_name.len,
 					 m->mnt_root->d_name.name,
 					 m->mnt_mountpoint->d_name.len,
 					 m->mnt_mountpoint->d_name.name, path);
-				tmp =
-				    (char *)Novfs_Malloc(PATH_LENGTH_BUFFER -
+				tmp = kmalloc(PATH_LENGTH_BUFFER -
 							 (int)(path - buf),
 							 GFP_KERNEL);
 				if (tmp) {
 					strcpy(tmp, path);
-					path = Novfs_CurrentMount;
-					Novfs_CurrentMount = tmp;
-					Daemon_SetMountPoint
-					    (Novfs_CurrentMount);
+					path = novfs_current_mnt;
+					novfs_current_mnt = tmp;
+					novfs_daemon_set_mnt_point(novfs_current_mnt);
 
 					if (path) {
 						kfree(path);
@@ -4362,37 +3704,17 @@ int Novfs_show_options(struct seq_file *
 	return (0);
 }
 
-/*++======================================================================*/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
-int Novfs_statfs(struct dentry *de, struct kstatfs *buf)
-#else
-int Novfs_statfs(struct super_block *sb, struct kstatfs *buf)
-#endif
-/*
- * Arguments:    sb - pointer to the super_block
- *               buf - pointer to the statfs buffer
- *
- *  Returns:      0
- *
- *  Abstract:     Called when statfs(2) system called.
- *
- *  Notes:
- *
- *  Environment:  Superblock operation
- *
- *========================================================================*/
+/*   Called when statfs(2) system called. */
+int novfs_statfs(struct dentry *de, struct kstatfs *buf)
 {
 	uint64_t td, fd, te, fe;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
 	struct super_block *sb = de->d_sb;
-#endif
 
-	DbgPrint("Novfs_statfs:\n");
+	DbgPrint("novfs_statfs:\n");
 
 	td = fd = te = fe = 0;
 
-	Scope_Get_UserSpace(&td, &fd, &te, &fe);
+	novfs_scope_get_userspace(&td, &fd, &te, &fe);
 
 	DbgPrint("td=%llu\n", td);
 	DbgPrint("fd=%llu\n", fd);
@@ -4430,7 +3752,7 @@ int Novfs_statfs(struct super_block *sb,
 	return 0;
 }
 
-struct inode *Novfs_get_inode(struct super_block *sb, int mode, int dev,
+struct inode *novfs_get_inode(struct super_block *sb, int mode, int dev,
 			      uid_t Uid, ino_t ino, struct qstr *name)
 {
 	struct inode *inode = new_inode(sb);
@@ -4440,37 +3762,32 @@ struct inode *Novfs_get_inode(struct sup
 		inode->i_mode = mode;
 		inode->i_uid = Uid;
 		inode->i_gid = 0;
-		/* bug # 340510 tells us to comment this out... */
-//#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
-//		inode->i_blksize = sb->s_blocksize;
-//#else
-//		inode->i_sb->s_blocksize = sb->s_blocksize;
-//#endif
+		inode->i_sb->s_blocksize = sb->s_blocksize;
 		inode->i_blkbits = sb->s_blocksize_bits;
 		inode->i_blocks = 0;
 		inode->i_rdev = 0;
-		inode->i_ino = (ino) ? ino : (ino_t)atomic_inc_return(&Novfs_Inode_Number);
-		if (PageCache) {
-			inode->i_mapping->a_ops = &Novfs_aops;
+		inode->i_ino = (ino) ? ino : (ino_t)atomic_inc_return(&novfs_Inode_Number);
+		if (novfs_page_cache) {
+			inode->i_mapping->a_ops = &novfs_aops;
 		} else {
-			inode->i_mapping->a_ops = &Novfs_nocache_aops;
+			inode->i_mapping->a_ops = &novfs_nocache_aops;
 		}
-		inode->i_mapping->backing_dev_info = &Novfs_backing_dev_info;
+		inode->i_mapping->backing_dev_info = &novfs_backing_dev_info;
 		inode->i_atime.tv_sec = 0;
 		inode->i_atime.tv_nsec = 0;
 		inode->i_mtime = inode->i_ctime = inode->i_atime;
 
-		DbgPrint("Novfs_get_inode: Inode=0x%p I_ino=%d len=%d\n", inode,
+		DbgPrint("novfs_get_inode: Inode=0x%p I_ino=%d len=%d\n", inode,
 			 inode->i_ino, name->len);
 
 		if (NULL !=
-		    (inode->FSPRIVATE =
-		     Novfs_Malloc(sizeof(struct inode_data) + name->len,
+		    (inode->i_private =
+		     kmalloc(sizeof(struct inode_data) + name->len,
 				  GFP_KERNEL))) {
 			struct inode_data *id;
-			id = inode->FSPRIVATE;
+			id = inode->i_private;
 
-			DbgPrint("Novfs_get_inode: FSPRIVATE 0x%p\n", id);
+			DbgPrint("novfs_get_inode: i_private 0x%p\n", id);
 
 			id->Scope = NULL;
 			id->Flags = 0;
@@ -4494,7 +3811,7 @@ struct inode *Novfs_get_inode(struct sup
 			memcpy(id->Name, name->name, name->len);
 			id->Name[name->len] = '\0';
 
-			DbgPrint("Novfs_get_inode: name %s\n", id->Name);
+			DbgPrint("novfs_get_inode: name %s\n", id->Name);
 		}
 
 		insert_inode_hash(inode);
@@ -4502,19 +3819,15 @@ struct inode *Novfs_get_inode(struct sup
 		switch (mode & S_IFMT) {
 
 		case S_IFREG:
-			inode->i_op = &Novfs_file_inode_operations;
-			inode->i_fop = &Novfs_file_operations;
+			inode->i_op = &novfs_file_inode_operations;
+			inode->i_fop = &novfs_file_operations;
 			break;
 
 		case S_IFDIR:
-			inode->i_op = &Novfs_inode_operations;
-			inode->i_fop = &Novfs_dir_operations;
-//  Again bug #340510
-//#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
-//			inode->i_blksize = 0;
-//#else
-//			inode->i_sb->s_blocksize = 0;
-//#endif
+			inode->i_op = &novfs_inode_operations;
+			inode->i_fop = &novfs_dir_operations;
+
+			inode->i_sb->s_blocksize = 0;
 			inode->i_blkbits = 0;
 			break;
 
@@ -4523,63 +3836,63 @@ struct inode *Novfs_get_inode(struct sup
 			break;
 		}
 
-		DbgPrint("Novfs_get_inode: size=%lld\n", inode->i_size);
-		DbgPrint("Novfs_get_inode: mode=0%o\n", inode->i_mode);
-		DbgPrint("Novfs_get_inode: i_sb->s_blocksize=%d\n",
+		DbgPrint("novfs_get_inode: size=%lld\n", inode->i_size);
+		DbgPrint("novfs_get_inode: mode=0%o\n", inode->i_mode);
+		DbgPrint("novfs_get_inode: i_sb->s_blocksize=%d\n",
 			 inode->i_sb->s_blocksize);
-		DbgPrint("Novfs_get_inode: i_blkbits=%d\n", inode->i_blkbits);
-		DbgPrint("Novfs_get_inode: i_blocks=%d\n", inode->i_blocks);
-		DbgPrint("Novfs_get_inode: i_bytes=%d\n", inode->i_bytes);
+		DbgPrint("novfs_get_inode: i_blkbits=%d\n", inode->i_blkbits);
+		DbgPrint("novfs_get_inode: i_blocks=%d\n", inode->i_blocks);
+		DbgPrint("novfs_get_inode: i_bytes=%d\n", inode->i_bytes);
 	}
 
-	DbgPrint("Novfs_get_inode: 0x%p %d\n", inode, inode->i_ino);
+	DbgPrint("novfs_get_inode: 0x%p %d\n", inode, inode->i_ino);
 	return (inode);
 }
 
-int Novfs_fill_super(struct super_block *SB, void *Data, int Silent)
+int novfs_fill_super(struct super_block *SB, void *Data, int Silent)
 {
 	struct inode *inode;
 	struct dentry *server, *tree;
 	struct qstr name;
-	struct entry_info info;
+	struct novfs_entry_info info;
 
 	SB->s_blocksize = PAGE_CACHE_SIZE;
 	SB->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	SB->s_maxbytes = 0xFFFFFFFFFFFFFFFFULL;	/* Max file size */
-	SB->s_op = &Novfs_ops;
+	SB->s_op = &novfs_ops;
 	SB->s_flags |= (MS_NODIRATIME | MS_NODEV | MS_POSIXACL);
 	SB->s_magic = NOVFS_MAGIC;
 
 	name.len = 1;
 	name.name = "/";
 
-	inode = Novfs_get_inode(SB, S_IFDIR | 0777, 0, 0, 0, &name);
+	inode = novfs_get_inode(SB, S_IFDIR | 0777, 0, 0, 0, &name);
 	if (!inode) {
 		return (-ENOMEM);
 	}
 
-	Novfs_root = d_alloc_root(inode);
+	novfs_root = d_alloc_root(inode);
 
-	if (!Novfs_root) {
+	if (!novfs_root) {
 		iput(inode);
 		return (-ENOMEM);
 	}
-	Novfs_root->d_time = jiffies + (File_update_timeout * HZ);
+	novfs_root->d_time = jiffies + (novfs_update_timeout * HZ);
 
 	inode->i_atime = inode->i_ctime = inode->i_mtime = CURRENT_TIME;
 
-	SB->s_root = Novfs_root;
+	SB->s_root = novfs_root;
 
-	DbgPrint("Novfs_fill_super: root 0x%p\n", Novfs_root);
+	DbgPrint("novfs_fill_super: root 0x%p\n", novfs_root);
 
-	if (Novfs_root) {
-		Novfs_root->d_op = &Novfs_dentry_operations;
+	if (novfs_root) {
+		novfs_root->d_op = &novfs_dentry_operations;
 
 		name.name = SERVER_DIRECTORY_NAME;
 		name.len = strlen(SERVER_DIRECTORY_NAME);
-		name.hash = Novfs_internal_hash(&name);
+		name.hash = novfs_internal_hash(&name);
 
-		inode = Novfs_get_inode(SB, S_IFDIR | 0777, 0, 0, 0, &name);
+		inode = novfs_get_inode(SB, S_IFDIR | 0777, 0, 0, 0, &name);
 		if (inode) {
 			info.mode = inode->i_mode;
 			info.namelength = 0;
@@ -4590,14 +3903,14 @@ int Novfs_fill_super(struct super_block
 			    inode->i_ctime = info.ctime =
 			    inode->i_mtime = info.mtime = CURRENT_TIME;
 
-			server = d_alloc(Novfs_root, &name);
+			server = d_alloc(novfs_root, &name);
 			if (server) {
-				server->d_op = &Novfs_dentry_operations;
+				server->d_op = &novfs_dentry_operations;
 				server->d_time = 0xffffffff;
 				d_add(server, inode);
-				DbgPrint("Novfs_fill_super: d_add %s 0x%p\n",
+				DbgPrint("novfs_fill_super: d_add %s 0x%p\n",
 					 SERVER_DIRECTORY_NAME, server);
-				Novfs_add_inode_entry(Novfs_root->d_inode,
+				novfs_add_inode_entry(novfs_root->d_inode,
 						      &name, inode->i_ino,
 						      &info);
 			}
@@ -4605,9 +3918,9 @@ int Novfs_fill_super(struct super_block
 
 		name.name = TREE_DIRECTORY_NAME;
 		name.len = strlen(TREE_DIRECTORY_NAME);
-		name.hash = Novfs_internal_hash(&name);
+		name.hash = novfs_internal_hash(&name);
 
-		inode = Novfs_get_inode(SB, S_IFDIR | 0777, 0, 0, 0, &name);
+		inode = novfs_get_inode(SB, S_IFDIR | 0777, 0, 0, 0, &name);
 		if (inode) {
 			info.mode = inode->i_mode;
 			info.namelength = 0;
@@ -4617,15 +3930,15 @@ int Novfs_fill_super(struct super_block
 			inode->i_atime = info.atime =
 			    inode->i_ctime = info.ctime =
 			    inode->i_mtime = info.mtime = CURRENT_TIME;
-			tree = d_alloc(Novfs_root, &name);
+			tree = d_alloc(novfs_root, &name);
 			if (tree) {
-				tree->d_op = &Novfs_dentry_operations;
+				tree->d_op = &novfs_dentry_operations;
 				tree->d_time = 0xffffffff;
 
 				d_add(tree, inode);
-				DbgPrint("Novfs_fill_super: d_add %s 0x%p\n",
+				DbgPrint("novfs_fill_super: d_add %s 0x%p\n",
 					 TREE_DIRECTORY_NAME, tree);
-				Novfs_add_inode_entry(Novfs_root->d_inode,
+				novfs_add_inode_entry(novfs_root->d_inode,
 						      &name, inode->i_ino,
 						      &info);
 			}
@@ -4635,75 +3948,53 @@ int Novfs_fill_super(struct super_block
 	return (0);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
-int Novfs_get_sb(struct file_system_type *Fstype, int Flags,
+static int novfs_get_sb(struct file_system_type *Fstype, int Flags,
 		 const char *Dev_name, void *Data, struct vfsmount *Mnt)
-#else
-struct super_block *Novfs_get_sb(struct file_system_type *Fstype, int Flags,
-				 const char *Dev_name, void *Data)
-#endif
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
-	int sb;
-#else
-	struct super_block *sb;
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
-	sb = get_sb_nodev(Fstype, Flags, Data, Novfs_fill_super, Mnt);
-#else
-	sb = get_sb_nodev(Fstype, Flags, Data, Novfs_fill_super);
-#endif
-
-	DbgPrint("Novfs_get_sb: sb=0x%p Fstype=0x%x Dev_name=%s\n", sb, Fstype,
-		 Dev_name);
-
-	return (sb);
+	DbgPrint("novfs_get_sb: Fstype=0x%x Dev_name=%s\n", Fstype, Dev_name);
+	return get_sb_nodev(Fstype, Flags, Data, novfs_fill_super, Mnt);
 }
 
 static void novfs_kill_sb(struct super_block *super)
 {
-	/* calling shrink_dcache_sb() fixes novell bugzilla #345179, but I'm
-	 * not so sure about it... */
-	shrink_dcache_sb(super);
 	kill_litter_super(super);
 }
 
-ssize_t Novfs_Control_read(struct file *file, char *buf, size_t nbytes,
+ssize_t novfs_Control_read(struct file *file, char *buf, size_t nbytes,
 			   loff_t * ppos)
 {
 	ssize_t retval = 0;
 
-	DbgPrint("Novfs_Control_read: kernel_locked 0x%x\n", kernel_locked());
+	DbgPrint("novfs_Control_read: kernel_locked 0x%x\n", kernel_locked());
 
 	return retval;
 }
 
-ssize_t Novfs_Control_write(struct file * file, const char *buf, size_t nbytes,
+ssize_t novfs_Control_write(struct file * file, const char *buf, size_t nbytes,
 			    loff_t * ppos)
 {
 	ssize_t retval = 0;
 
-	DbgPrint("Novfs_Control_write: kernel_locked 0x%x\n", kernel_locked());
+	DbgPrint("novfs_Control_write: kernel_locked 0x%x\n", kernel_locked());
 	if (buf && nbytes) {
 	}
 
 	return (retval);
 }
 
-int Novfs_Control_ioctl(struct inode *inode, struct file *file,
+int novfs_Control_ioctl(struct inode *inode, struct file *file,
 			unsigned int cmd, unsigned long arg)
 {
 	int retval = 0;
 
-	DbgPrint("Novfs_Control_ioctl: kernel_locked 0x%x\n", kernel_locked());
+	DbgPrint("novfs_Control_ioctl: kernel_locked 0x%x\n", kernel_locked());
 
 	return (retval);
 }
 
-static struct file_system_type Novfs_fs_type = {
+static struct file_system_type novfs_fs_type = {
 	.name = "novfs",
-	.get_sb = Novfs_get_sb,
+	.get_sb = novfs_get_sb,
 	.kill_sb = novfs_kill_sb,
 	.owner = THIS_MODULE,
 };
@@ -4718,20 +4009,20 @@ int __init init_novfs(void)
 	inHAX = 0;
 	inHAXTime = get_nanosecond_time();
 
-	retCode = Init_Procfs_Interface();
+	retCode = novfs_proc_init();
 
-	init_profile();
+	novfs_profile_init();
 
 	if (!retCode) {
 		DbgPrint("init_novfs: %s %s %s\n", __DATE__, __TIME__,
 			 NOVFS_VERSION_STRING);
-		Init_Daemon_Queue();
-		Scope_Init();
-		retCode = register_filesystem(&Novfs_fs_type);
+		novfs_daemon_queue_init();
+		novfs_scope_init();
+		retCode = register_filesystem(&novfs_fs_type);
 		if (retCode) {
-			Uninit_Procfs_Interface();
-			Uninit_Daemon_Queue();
-			Scope_Uninit();
+			novfs_proc_exit();
+			novfs_daemon_queue_exit();
+			novfs_scope_exit();
 		}
 	}
 	return (retCode);
@@ -4741,80 +4032,52 @@ void __exit exit_novfs(void)
 {
 	printk(KERN_INFO "exit_novfs\n");
 
-	Scope_Uninit();
+	novfs_scope_exit();
 	printk(KERN_INFO "exit_novfs after Scope_Uninit\n");
 
-	Uninit_Daemon_Queue();
+	novfs_daemon_queue_exit();
 	printk(KERN_INFO "exit_novfs after Uninit_Daemon_Queue\n");
 
-	uninit_profile();
-	printk(KERN_INFO "exit_novfs after uninit_profile\n");
+	novfs_profile_exit();
+	printk(KERN_INFO "exit_novfs after profile_exit\n");
 
-	Uninit_Procfs_Interface();
+	novfs_proc_exit();
 	printk(KERN_INFO "exit_novfs Uninit_Procfs_Interface\n");
 
-	unregister_filesystem(&Novfs_fs_type);
+	unregister_filesystem(&novfs_fs_type);
 	printk(KERN_INFO "exit_novfs: Exit\n");
 
-	if (Novfs_CurrentMount) {
-		kfree(Novfs_CurrentMount);
-		Novfs_CurrentMount = NULL;
+	if (novfs_current_mnt) {
+		kfree(novfs_current_mnt);
+		novfs_current_mnt = NULL;
 	}
 }
 
-int Novfs_lock_inode_cache(struct inode *i)
-/*
- *
- *  Arguments:   struct inode *i - pointer to directory inode
- *
- *  Returns:     0 - locked
- *              -1 - not locked
- *
- *  Abstract:    Locks the inode cache.
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_lock_inode_cache(struct inode *i)
 {
 	struct inode_data *id;
 	int retVal = 0;
 
-	DbgPrint("Novfs_lock_inode_cache: 0x%p\n", i);
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	DbgPrint("novfs_lock_inode_cache: 0x%p\n", i);
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		down(&id->DirCacheLock);
 		retVal = 1;
 	}
-	DbgPrint("Novfs_lock_inode_cache: return %d\n", retVal);
+	DbgPrint("novfs_lock_inode_cache: return %d\n", retVal);
 	return (retVal);
 }
 
-/*++======================================================================*/
-void Novfs_unlock_inode_cache(struct inode *i)
-/*
- *  Arguments:   struct inode *i - pointer to directory inode
- *
- *  Returns:     nothing
- *
- *  Abstract:    Unlocks inode cache.
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+void novfs_unlock_inode_cache(struct inode *i)
 {
 	struct inode_data *id;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		up(&id->DirCacheLock);
 	}
 }
 
-/*++======================================================================*/
-int Novfs_enumerate_inode_cache(struct inode *i, struct list_head **iteration,
-				ino_t * ino, struct entry_info *info)
+int novfs_enumerate_inode_cache(struct inode *i, struct list_head **iteration,
+				ino_t * ino, struct novfs_entry_info *info)
 /*
  *  Arguments:   struct inode *i - pointer to directory inode
  *
@@ -4824,17 +4087,14 @@ int Novfs_enumerate_inode_cache(struct i
  *  Abstract:    Unlocks inode cache.
  *
  *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
- *
  *========================================================================*/
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	struct list_head *l = NULL;
 	int retVal = -1;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		if ((NULL == iteration) || (NULL == *iteration)) {
 			l = id->DirCache.next;
 		} else {
@@ -4844,7 +4104,7 @@ int Novfs_enumerate_inode_cache(struct i
 		if (l == &id->DirCache) {
 			l = NULL;
 		} else {
-			dc = list_entry(l, struct dir_cache, list);
+			dc = list_entry(l, struct novfs_dir_cache, list);
 
 			*ino = dc->ino;
 			info->type = 0;
@@ -4865,35 +4125,23 @@ int Novfs_enumerate_inode_cache(struct i
 	return (retVal);
 }
 
-/*++======================================================================*/
-int Novfs_get_entry(struct inode *i, struct qstr *name, ino_t * ino,
-		    struct entry_info *info)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
- *
- *========================================================================*/
+/* DirCacheLock should be held before calling this routine. */
+int novfs_get_entry(struct inode *i, struct qstr *name, ino_t * ino,
+		    struct novfs_entry_info *info)
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	int retVal = -1;
 	char *n = "<NULL>";
 	int nl = 6;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		if (name && name->len) {
 			n = (char *)name->name;
 			nl = name->len;
 		}
 
-		dc = Novfs_lookup_inode_cache(i, name, *ino);
+		dc = novfs_lookup_inode_cache(i, name, *ino);
 		if (dc) {
 			dc->flags |= ENTRY_VALID;
 			retVal = 0;
@@ -4910,36 +4158,25 @@ int Novfs_get_entry(struct inode *i, str
 			retVal = 0;
 		}
 
-		DbgPrint("Novfs_get_entry:\n"
+		DbgPrint("novfs_get_entry:\n"
 			 "   inode: 0x%p\n"
 			 "   name:  %.*s\n" "   ino:   %d\n", i, nl, n, *ino);
 	}
-	DbgPrint("Novfs_get_entry: return %d\n", retVal);
+	DbgPrint("novfs_get_entry: return %d\n", retVal);
 	return (retVal);
 }
 
-int Novfs_get_entry_by_pos(struct inode *i, loff_t pos, ino_t * ino,
-			   struct entry_info *info)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
- *
- *========================================================================*/
+ /*DirCacheLock should be held before calling this routine. */
+int novfs_get_entry_by_pos(struct inode *i, loff_t pos, ino_t * ino,
+			   struct novfs_entry_info *info)
 {
 	int retVal = -1;
 	loff_t count = 0;
 	loff_t i_pos = pos - 2;
 	struct list_head *inter = NULL;
-	while (!Novfs_enumerate_inode_cache(i, &inter, ino, info)) {
+	while (!novfs_enumerate_inode_cache(i, &inter, ino, info)) {
 		DbgPrint
-		    ("Novfs_dir_readdir : Novfs_get_entry_by_pos : info->name = %s\n",
+		    ("novfs_dir_readdir : novfs_get_entry_by_pos : info->name = %s\n",
 		     info->name);
 		if (count == i_pos) {
 			retVal = 0;
@@ -4951,38 +4188,26 @@ int Novfs_get_entry_by_pos(struct inode
 	return retVal;
 }
 
-/*++======================================================================*/
-int Novfs_get_entry_time(struct inode *i, struct qstr *name, ino_t * ino,
-			 struct entry_info *info, u64 * EntryTime)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
- *
- *========================================================================*/
+/* DirCacheLock should be held before calling this routine. */
+int novfs_get_entry_time(struct inode *i, struct qstr *name, ino_t * ino,
+			 struct novfs_entry_info *info, u64 * EntryTime)
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	int retVal = -1;
 	char *n = "<NULL>";
 	int nl = 6;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		if (name && name->len) {
 			n = (char *)name->name;
 			nl = name->len;
 		}
-		DbgPrint("Novfs_get_entry_time:\n"
+		DbgPrint("novfs_get_entry_time:\n"
 			 "   inode: 0x%p\n"
 			 "   name:  %.*s\n" "   ino:   %d\n", i, nl, n, *ino);
 
-		dc = Novfs_lookup_inode_cache(i, name, *ino);
+		dc = novfs_lookup_inode_cache(i, name, *ino);
 		if (dc) {
 			retVal = 0;
 			*ino = dc->ino;
@@ -5001,36 +4226,29 @@ int Novfs_get_entry_time(struct inode *i
 			retVal = 0;
 		}
 	}
-	DbgPrint("Novfs_get_entry_time: return %d\n", retVal);
+	DbgPrint("novfs_get_entry_time: return %d\n", retVal);
 	return (retVal);
 }
 
-/*++======================================================================*/
-int Novfs_get_remove_entry(struct inode *i, ino_t * ino, struct entry_info *info)
 /*
- *  Arguments:
- *
- *  Returns:
- *
  *  Abstract:    This routine will return the first entry on the list
  *               and then remove it.
  *
  *  Notes:       DirCacheLock should be held before calling this routine.
  *
- *  Environment:
- *
- *========================================================================*/
+ */
+int novfs_get_remove_entry(struct inode *i, ino_t * ino, struct novfs_entry_info *info)
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	struct list_head *l = NULL;
 	int retVal = -1;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		l = id->DirCache.next;
 
 		if (l != &id->DirCache) {
-			dc = list_entry(l, struct dir_cache, list);
+			dc = list_entry(l, struct novfs_dir_cache, list);
 
 			*ino = dc->ino;
 			info->type = 0;
@@ -5054,41 +4272,31 @@ int Novfs_get_remove_entry(struct inode
 	return (retVal);
 }
 
-/*++======================================================================*/
-void Novfs_invalidate_inode_cache(struct inode *i)
 /*
- *  Arguments:   struct inode *i - pointer to directory inode
- *
- *  Returns:     nothing
- *
  *  Abstract:    Marks all entries in the directory cache as invalid.
  *
  *  Notes:       DirCacheLock should be held before calling this routine.
  *
- *  Environment:
- *
  *========================================================================*/
+void novfs_invalidate_inode_cache(struct inode *i)
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	struct list_head *l;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		list_for_each(l, &id->DirCache) {
-			dc = list_entry(l, struct dir_cache, list);
+			dc = list_entry(l, struct novfs_dir_cache, list);
 			dc->flags &= ~ENTRY_VALID;
 		}
 	}
 }
 
 /*++======================================================================*/
-static struct dir_cache *Novfs_lookup_inode_cache(struct inode *i, struct qstr *name, ino_t ino)
+struct novfs_dir_cache *novfs_lookup_inode_cache(struct inode *i, struct qstr *name,
+				    ino_t ino)
 /*
- *  Arguments:   struct inode *i - pointer to directory inode
- *               struct qstr *name - pointer to name
- *               ino_t - inode number
- *
- *  Returns:     struct dir_cache entry if match
+ *  Returns:     struct novfs_dir_cache entry if match
  *               NULL - if there is no match.
  *
  *  Abstract:    Checks a inode directory to see if there are any enties
@@ -5097,25 +4305,22 @@ static struct dir_cache *Novfs_lookup_in
  *
  *  Notes:       DirCacheLock should be held before calling this routine.
  *
- *  Environment:
- *
  *========================================================================*/
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
-	struct dir_cache *retVal = NULL;
+	struct novfs_dir_cache *dc, *retVal = NULL;
 	struct list_head *l;
 	char *n = "<NULL>";
 	int nl = 6;
 	int hash = 0;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		if (name && name->name) {
 			nl = name->len;
 			n = (char *)name->name;
 			hash = name->hash;
 		}
-		DbgPrint("Novfs_lookup_inode_cache:\n"
+		DbgPrint("novfs_lookup_inode_cache:\n"
 			 "   inode: 0x%p\n"
 			 "   name:  %.*s\n"
 			 "   hash:  0x%x\n"
@@ -5123,10 +4328,10 @@ static struct dir_cache *Novfs_lookup_in
 			 "   ino:   %d\n", i, nl, n, hash, nl, ino);
 
 		list_for_each(l, &id->DirCache) {
-			dc = list_entry(l, struct dir_cache, list);
+			dc = list_entry(l, struct novfs_dir_cache, list);
 			if (name) {
 
-/*         DbgPrint("Novfs_lookup_inode_cache: 0x%p\n" \
+/*         DbgPrint("novfs_lookup_inode_cache: 0x%p\n" \
                   "   ino:   %d\n" \
                   "   hash:  0x%x\n" \
                   "   len:   %d\n" \
@@ -5149,46 +4354,34 @@ static struct dir_cache *Novfs_lookup_in
 		}
 	}
 
-	DbgPrint("Novfs_lookup_inode_cache: return 0x%p\n", retVal);
+	DbgPrint("novfs_lookup_inode_cache: return 0x%p\n", retVal);
 	return (retVal);
 }
 
-/*++======================================================================*/
-int Novfs_lookup_validate(struct inode *i, struct qstr *name, ino_t ino)
 /*
- *  Arguments:   struct inode *i - pointer to directory inode
- *               struct qstr *name - pointer to name
- *               ino_t - inode number
- *
- *  Returns:     0 if found
- *               !0 if not found
- *
- *  Abstract:    Checks a inode directory to see if there are any enties
- *               matching name or ino.  If entry is found the valid bit
- *               is set.
+ * Checks a inode directory to see if there are any enties matching name
+ * or ino.  If entry is found the valid bit is set.
  *
- *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
- *
- *========================================================================*/
+ * DirCacheLock should be held before calling this routine.
+ */
+int novfs_lookup_validate(struct inode *i, struct qstr *name, ino_t ino)
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	int retVal = -1;
 	char *n = "<NULL>";
 	int nl = 6;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		if (name && name->len) {
 			n = (char *)name->name;
 			nl = name->len;
 		}
-		DbgPrint("Novfs_update_entry:\n"
+		DbgPrint("novfs_update_entry:\n"
 			 "   inode: 0x%p\n"
 			 "   name:  %.*s\n" "   ino:   %d\n", i, nl, n, ino);
 
-		dc = Novfs_lookup_inode_cache(i, name, ino);
+		dc = novfs_lookup_inode_cache(i, name, ino);
 		if (dc) {
 			dc->flags |= ENTRY_VALID;
 			retVal = 0;
@@ -5197,46 +4390,37 @@ int Novfs_lookup_validate(struct inode *
 	return (retVal);
 }
 
-/*++======================================================================*/
-int Novfs_add_inode_entry(struct inode *i,
-			  struct qstr *name, ino_t ino, struct entry_info *info)
 /*
- *  Arguments:
- *
- *  Returns:     -ENOMEM - alloc error.
- *                0 - success.
- *
- *  Abstract:    Added entry to directory cache.
- *
- *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
+ * Added entry to directory cache.
  *
- *========================================================================*/
+ * DirCacheLock should be held before calling this routine.
+ */
+int novfs_add_inode_entry(struct inode *i,
+			  struct qstr *name, ino_t ino, struct novfs_entry_info *info)
 {
 	struct inode_data *id;
-	struct dir_cache *new;
+	struct novfs_dir_cache *new;
 	int retVal = -ENOMEM;
-	struct dir_cache *todel;
+	struct novfs_dir_cache *todel;
 	struct list_head *todeltmp;
 
 	//SClark
-	DbgPrint("Novfs_add_inode_entry:\n" "   i: %u\n", i);
-	if ((id = i->FSPRIVATE)) {
-		DbgPrint("   i->FSPRIVATE: %p\n", id);
+	DbgPrint("novfs_add_inode_entry:\n" "   i: %u\n", i);
+	if ((id = i->i_private)) {
+		DbgPrint("   i->i_private: %p\n", id);
 		if (id->DirCache.next)
 			DbgPrint("   id->DirCache.next: %p\n",
 				 id->DirCache.next);
 	}
 	//SClark
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
-		new = Novfs_Malloc(sizeof(struct dir_cache) + name->len, GFP_KERNEL);
+	if (i && (id = i->i_private) && id->DirCache.next) {
+		new = kmalloc(sizeof(struct novfs_dir_cache) + name->len, GFP_KERNEL);
 		if (new) {
 			id->cntDC++;
 
 			DCCount++;
-			DbgPrint("Novfs_add_inode_entry:\n"
+			DbgPrint("novfs_add_inode_entry:\n"
 				 "   inode: 0x%p\n"
 				 "   id:    0x%p\n"
 				 "   DC:    0x%p\n"
@@ -5265,7 +4449,7 @@ int Novfs_add_inode_entry(struct inode *
 
 			if (id->cntDC > 20) {
 				todeltmp = id->DirCache.prev;
-				todel = list_entry(todeltmp, struct dir_cache, list);
+				todel = list_entry(todeltmp, struct novfs_dir_cache, list);
 
 				list_del(&todel->list);
 
@@ -5274,29 +4458,20 @@ int Novfs_add_inode_entry(struct inode *
 				DCCount--;
 				id->cntDC--;
 			}
+
 		}
 	}
 	return (retVal);
 }
 
-/*++======================================================================*/
-int Novfs_update_entry(struct inode *i, struct qstr *name, ino_t ino,
-		       struct entry_info *info)
 /*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
- *
- *========================================================================*/
+ *  DirCacheLock should be held before calling this routine.
+ */
+int novfs_update_entry(struct inode *i, struct qstr *name, ino_t ino,
+		       struct novfs_entry_info *info)
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	int retVal = -1;
 	char *n = "<NULL>";
 	int nl = 6;
@@ -5304,7 +4479,7 @@ int Novfs_update_entry(struct inode *i,
 	char mtime_buf[32];
 	char ctime_buf[32];
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 
 		if (name && name->len) {
 			n = (char *)name->name;
@@ -5313,7 +4488,7 @@ int Novfs_update_entry(struct inode *i,
 		ctime_r(&info->atime.tv_sec, atime_buf);
 		ctime_r(&info->mtime.tv_sec, mtime_buf);
 		ctime_r(&info->ctime.tv_sec, ctime_buf);
-		DbgPrint("Novfs_update_entry:\n"
+		DbgPrint("novfs_update_entry:\n"
 			 "   inode: 0x%p\n"
 			 "   name:  %.*s\n"
 			 "   ino:   %d\n"
@@ -5324,7 +4499,7 @@ int Novfs_update_entry(struct inode *i,
 			 i, nl, n, ino, info->size, atime_buf, mtime_buf,
 			 ctime_buf);
 
-		dc = Novfs_lookup_inode_cache(i, name, ino);
+		dc = novfs_lookup_inode_cache(i, name, ino);
 		if (dc) {
 			retVal = 0;
 			dc->flags = ENTRY_VALID;
@@ -5338,7 +4513,7 @@ int Novfs_update_entry(struct inode *i,
 			ctime_r(&dc->atime.tv_sec, atime_buf);
 			ctime_r(&dc->mtime.tv_sec, mtime_buf);
 			ctime_r(&dc->ctime.tv_sec, ctime_buf);
-			DbgPrint("Novfs_update_entry entry: 0x%p\n"
+			DbgPrint("novfs_update_entry entry: 0x%p\n"
 				 "   flags:   0x%x\n"
 				 "   jiffies: %lld\n"
 				 "   ino:     %d\n"
@@ -5356,39 +4531,31 @@ int Novfs_update_entry(struct inode *i,
 				 dc->nameLen, dc->name);
 		}
 	}
-	DbgPrint("Novfs_update_entry: return %d\n", retVal);
+	DbgPrint("novfs_update_entry: return %d\n", retVal);
 	return (retVal);
 }
 
-/*++======================================================================*/
-void Novfs_remove_inode_entry(struct inode *i, struct qstr *name, ino_t ino)
 /*
- *  Arguments:
- *
- *  Returns:     nothing
- *
- *  Abstract:    Removes entry from directory cache.  You can specify a name
- *               or an inode number.
- *
- *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
+ *  Removes entry from directory cache.  You can specify a name
+ *  or an inode number.
  *
- *========================================================================*/
+ *  DirCacheLock should be held before calling this routine.
+ */
+void novfs_remove_inode_entry(struct inode *i, struct qstr *name, ino_t ino)
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	char *n = "<NULL>";
 	int nl = 6;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
-		dc = Novfs_lookup_inode_cache(i, name, ino);
+	if (i && (id = i->i_private) && id->DirCache.next) {
+		dc = novfs_lookup_inode_cache(i, name, ino);
 		if (dc) {
 			if (name && name->name) {
 				nl = name->len;
 				n = (char *)name->name;
 			}
-			DbgPrint("Novfs_remove_inode_entry:\n"
+			DbgPrint("novfs_remove_inode_entry:\n"
 				 "   inode: 0x%p\n"
 				 "   id:    0x%p\n"
 				 "   DC:    0x%p\n"
@@ -5411,30 +4578,22 @@ void Novfs_remove_inode_entry(struct ino
 	}
 }
 
-/*++======================================================================*/
-void Novfs_free_invalid_entries(struct inode *i)
 /*
- *  Arguments:   struct inode *i - pointer to directory inode.
- *
- *  Returns:     nothing
- *
- *  Abstract:    Frees all invalid entries in the directory cache.
- *
- *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
+ * Frees all invalid entries in the directory cache.
  *
- *========================================================================*/
+ * DirCacheLock should be held before calling this routine.
+ */
+void novfs_free_invalid_entries(struct inode *i)
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	struct list_head *l;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		list_for_each(l, &id->DirCache) {
-			dc = list_entry(l, struct dir_cache, list);
+			dc = list_entry(l, struct novfs_dir_cache, list);
 			if (0 == (dc->flags & ENTRY_VALID)) {
-				DbgPrint("Novfs_free_invalid_entries:\n"
+				DbgPrint("novfs_free_invalid_entries:\n"
 					 "   inode: 0x%p\n"
 					 "   id:    0x%p\n"
 					 "   entry:    0x%p\n"
@@ -5453,28 +4612,20 @@ void Novfs_free_invalid_entries(struct i
 	}
 }
 
-/*++======================================================================*/
-void Novfs_free_inode_cache(struct inode *i)
 /*
- *  Arguments:   struct inode *i - pointer to directory inode.
- *
- *  Returns:     nothing
- *
- *  Abstract:    Frees all entries in the inode cache.
- *
- *  Notes:       DirCacheLock should be held before calling this routine.
- *
- *  Environment:
+ *  Frees all entries in the inode cache.
  *
- *========================================================================*/
+ *  DirCacheLock should be held before calling this routine.
+ */
+void novfs_free_inode_cache(struct inode *i)
 {
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	struct list_head *l;
 
-	if (i && (id = i->FSPRIVATE) && id->DirCache.next) {
+	if (i && (id = i->i_private) && id->DirCache.next) {
 		list_for_each(l, &id->DirCache) {
-			dc = list_entry(l, struct dir_cache, list);
+			dc = list_entry(l, struct novfs_dir_cache, list);
 			l = l->prev;
 			list_del(&dc->list);
 			kfree(dc);
@@ -5485,12 +4636,12 @@ void Novfs_free_inode_cache(struct inode
 	}
 }
 
-void Novfs_dump_inode(void *pf)
+void novfs_dump_inode(void *pf)
 {
 	struct inode *inode;
 	void (*pfunc) (char *Fmt, ...) = pf;
 	struct inode_data *id;
-	struct dir_cache *dc;
+	struct novfs_dir_cache *dc;
 	struct list_head *il, *l;
 	char atime_buf[32];
 	char mtime_buf[32];
@@ -5517,13 +4668,14 @@ void Novfs_dump_inode(void *pf)
 			pfunc("   count=0%o\n", atomic_read(&inode->i_count));
 		}
 
-		pfunc("   inode_data: 0x%p Name=%s Scope=0x%p\n", id, id->Name,
+		pfunc("   nofs_inode_data: 0x%p Name=%s Scope=0x%p\n", id, id->Name,
 		      id->Scope);
 
 		if (id->DirCache.next) {
 			list_for_each(l, &id->DirCache) {
 				dccnt++;
-				dc = list_entry(l, struct dir_cache, list);
+				dc = list_entry(l, struct novfs_dir_cache,
+						list);
 				ctime_r(&dc->atime.tv_sec, atime_buf);
 				ctime_r(&dc->mtime.tv_sec, mtime_buf);
 				ctime_r(&dc->ctime.tv_sec, ctime_buf);
--- a/fs/novfs/nwcapi.c
+++ b/fs/novfs/nwcapi.c
@@ -27,16 +27,20 @@
 #include "vfs.h"
 #include "commands.h"
 
-static void GetUserData(NwcScanConnInfo *connInfo, PXPLAT_CALL_REQUEST cmd, PXPLAT_CALL_REPLY reply);
-static void GetConnData(NwcGetConnInfo *connInfo, PXPLAT_CALL_REQUEST cmd, PXPLAT_CALL_REPLY reply);
+#ifndef strlen_user
+#define strlen_user(str) strnlen_user(str, ~0UL >> 1)
+#endif
 
+static void GetUserData(struct nwc_scan_conn_info * connInfo, struct novfs_xplat_call_request *cmd, struct novfs_xplat_call_reply *reply);
+static void GetConnData(struct nwc_get_conn_info * connInfo, struct novfs_xplat_call_request *cmd, struct novfs_xplat_call_reply *reply);
 
-int NwOpenConnByName(PXPLAT pdata, HANDLE * Handle, session_t Session)
+/*++======================================================================*/
+int novfs_open_conn_by_name(struct novfs_xplat *pdata, void ** Handle, struct novfs_schandle Session)
 {
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	PNwdCOpenConnByName openConn, connReply;
-	NwcOpenConnByName ocbn;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwd_open_conn_by_name *openConn, *connReply;
+	struct nwc_open_conn_by_name ocbn;
 	int retCode = 0;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 	char *data;
@@ -45,15 +49,17 @@ int NwOpenConnByName(PXPLAT pdata, HANDL
 	datalen = sizeof(*openConn) + strlen_user(ocbn.pName->pString) + strlen_user(ocbn.pServiceType);
 	cmdlen = datalen + sizeof(*cmd);
 	cmd = kmalloc(cmdlen, GFP_KERNEL);
+
 	if (!cmd)
 		return -ENOMEM;
+
 	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
 	cmd->Command.SequenceNumber = 0;
 	cmd->Command.SessionId = Session;
 	cmd->NwcCommand = NWC_OPEN_CONN_BY_NAME;
 
 	cmd->dataLen = datalen;
-	openConn = (PNwdCOpenConnByName) cmd->data;
+	openConn = (struct nwd_open_conn_by_name *) cmd->data;
 
 	openConn->nameLen = strlen_user(ocbn.pName->pString);
 	openConn->serviceLen = strlen_user(ocbn.pServiceType);
@@ -64,24 +70,29 @@ int NwOpenConnByName(PXPLAT pdata, HANDL
 	openConn->oName = sizeof(*openConn);
 
 	openConn->oServiceType = openConn->oName + openConn->nameLen;
-	cpylen = copy_from_user(data, ocbn.pName->pString, openConn->nameLen);
+	cpylen =
+		copy_from_user(data, ocbn.pName->pString,
+				openConn->nameLen);
 	data += openConn->nameLen;
-	cpylen = copy_from_user(data, ocbn.pServiceType, openConn->serviceLen);
+	cpylen =
+		copy_from_user(data, ocbn.pServiceType,
+				openConn->serviceLen);
 
-	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					(void **)&reply, &replylen,
-					INTERRUPTIBLE);
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
 	if (reply) {
 		/*
 		 * we got reply data from the daemon
 		 */
-		connReply = (PNwdCOpenConnByName) reply->data;
+		connReply = (struct nwd_open_conn_by_name *) reply->data;
 		retCode = reply->Reply.ErrorCode;
 		if (!retCode) {
 			/*
 			 * we got valid data.
 			 */
-			connReply = (PNwdCOpenConnByName) reply->data;
+			connReply = (struct nwd_open_conn_by_name *) reply->data;
 			ocbn.RetConnHandle = HandletoUint32(connReply->newConnHandle);
 			*Handle = connReply->newConnHandle;
 
@@ -92,18 +103,17 @@ int NwOpenConnByName(PXPLAT pdata, HANDL
 	}
 
 	kfree(cmd);
-
-	return retCode;
+	return ((int)retCode);
 
 }
 
-int NwOpenConnByAddr(PXPLAT pdata, HANDLE * Handle, session_t Session)
+int novfs_open_conn_by_addr(struct novfs_xplat *pdata, void ** Handle, struct novfs_schandle Session)
 {
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	PNwdCOpenConnByAddr openConn, connReply;
-	NwcOpenConnByAddr ocba;
-	NwcTranAddr tranAddr;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwd_open_conn_by_addr *openConn, *connReply;
+	struct nwc_open_conn_by_addr ocba;
+	struct nwc_tran_addr tranAddr;
 	int retCode = 0;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 	char addr[MAX_ADDRESS_LENGTH];
@@ -112,6 +122,7 @@ int NwOpenConnByAddr(PXPLAT pdata, HANDL
 	datalen = sizeof(*openConn);
 	cmdlen = datalen + sizeof(*cmd);
 	cmd = kmalloc(cmdlen, GFP_KERNEL);
+
 	if (!cmd)
 		return -ENOMEM;
 
@@ -120,69 +131,66 @@ int NwOpenConnByAddr(PXPLAT pdata, HANDL
 	cmd->Command.SessionId = Session;
 	cmd->NwcCommand = NWC_OPEN_CONN_BY_ADDRESS;
 	cmd->dataLen = datalen;
-	openConn = (PNwdCOpenConnByAddr) cmd->data;
+	openConn = (struct nwd_open_conn_by_addr *) cmd->data;
 
-	cpylen = copy_from_user(&tranAddr, ocba.pTranAddr, sizeof(tranAddr));
+	cpylen =
+		copy_from_user(&tranAddr, ocba.pTranAddr, sizeof(tranAddr));
 
 	DbgPrint("NwOpenConnByAddr: tranAddr\n");
-	mydump(sizeof(tranAddr), &tranAddr);
+	novfs_dump(sizeof(tranAddr), &tranAddr);
 
 	openConn->TranAddr.uTransportType = tranAddr.uTransportType;
 	openConn->TranAddr.uAddressLength = tranAddr.uAddressLength;
 	memset(addr, 0xcc, sizeof(addr) - 1);
 
-	cpylen = copy_from_user(addr, tranAddr.puAddress, tranAddr.uAddressLength);
+	cpylen =
+		copy_from_user(addr, tranAddr.puAddress,
+				tranAddr.uAddressLength);
 
 	DbgPrint("NwOpenConnByAddr: addr\n");
-	mydump(sizeof(addr), addr);
+	novfs_dump(sizeof(addr), addr);
 
-	openConn->TranAddr.oAddress = *(unsigned int*) (&addr[2]);
+	openConn->TranAddr.oAddress = *(unsigned int *) (&addr[2]);
 
-	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					(void **)&reply, &replylen,
-					INTERRUPTIBLE);
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
 	if (reply) {
 		/*
 		 * we got reply data from the daemon
 		 */
-		connReply = (PNwdCOpenConnByAddr) reply->data;
+		connReply = (struct nwd_open_conn_by_addr *) reply->data;
 		retCode = reply->Reply.ErrorCode;
 		if (!retCode) {
 			/*
 			 * we got valid data.
 			 */
-			connReply = (PNwdCOpenConnByAddr) reply->data;
-			ocba.ConnHandle = HandletoUint32(connReply->ConnHandle);
+			connReply = (struct nwd_open_conn_by_addr *) reply->data;
+			ocba.ConnHandle =
+				HandletoUint32(connReply->ConnHandle);
 			*Handle = connReply->ConnHandle;
-			cpylen = copy_to_user(pdata->reqData, &ocba, sizeof(ocba));
-			DbgPrint("New Conn Handle = %X\n", connReply->ConnHandle);
+			cpylen =
+				copy_to_user(pdata->reqData, &ocba,
+						sizeof(ocba));
+			DbgPrint("New Conn Handle = %X\n",
+					connReply->ConnHandle);
 		}
 		kfree(reply);
 	}
 
 	kfree(cmd);
-	return retCode;
+
+	return (retCode);
+
 }
 
-/*++======================================================================*/
-int NwOpenConnByRef(PXPLAT pdata, HANDLE * Handle, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	PNwdCOpenConnByRef openConn;
-	NwcOpenConnByReference ocbr;
+int novfs_open_conn_by_ref(struct novfs_xplat *pdata, void ** Handle, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwd_open_conn_by_ref *openConn;
+	struct nwc_open_conn_by_ref ocbr;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 
@@ -198,29 +206,35 @@ int NwOpenConnByRef(PXPLAT pdata, HANDLE
 	cmd->Command.SessionId = Session;
 	cmd->NwcCommand = NWC_OPEN_CONN_BY_REFERENCE;
 	cmd->dataLen = datalen;
-	openConn = (PNwdCOpenConnByRef) cmd->data;
+	openConn = (struct nwd_open_conn_by_ref *) cmd->data;
 
-	openConn->uConnReference = (HANDLE) (unsigned long) ocbr.uConnReference;
+	openConn->uConnReference =
+		(void *) (unsigned long) ocbr.uConnReference;
 	openConn->uConnFlags = ocbr.uConnFlags;
 
-	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					(void **)&reply, &replylen,
-					INTERRUPTIBLE);
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
 	if (reply) {
 		/*
 		 * we got reply data from the daemon
 		 */
-		openConn = (PNwdCOpenConnByRef) reply->data;
+		openConn = (struct nwd_open_conn_by_ref *) reply->data;
 		retCode = reply->Reply.ErrorCode;
 		if (!retCode) {
 			/*
 			 * we got valid data.
 			 */
-			ocbr.ConnHandle = HandletoUint32(openConn->ConnHandle);
+			ocbr.ConnHandle =
+				HandletoUint32(openConn->ConnHandle);
 			*Handle = openConn->ConnHandle;
 
-			cpylen = copy_to_user(pdata->reqData, &ocbr, sizeof(ocbr));
-			DbgPrint("New Conn Handle = %X\n", openConn->ConnHandle);
+			cpylen =
+				copy_to_user(pdata->reqData, &ocbr,
+						sizeof(ocbr));
+			DbgPrint("New Conn Handle = %X\n",
+					openConn->ConnHandle);
 		}
 		kfree(reply);
 	}
@@ -230,19 +244,17 @@ int NwOpenConnByRef(PXPLAT pdata, HANDLE
 
 }
 
-int NwRawSend(PXPLAT pdata, session_t Session)
+int novfs_raw_send(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
-	NwcRequest xRequest;
-	PNwcFrag frag = NULL;
-	PNwcFrag cFrag = NULL;
-	PNwcFrag reqFrag = NULL;
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
+	struct nwc_request xRequest;
+	struct nwc_frag *frag, *cFrag, *reqFrag;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen, totalLen;
 	unsigned int x;
-	PNwdCNCPReq ncpData;
-	PNwdCNCPRep ncpReply;
+	struct nwd_ncp_req *ncpData;
+	struct nwd_ncp_rep *ncpReply;
 	unsigned char *reqData;
 	unsigned long actualReplyLength = 0;
 
@@ -252,13 +264,18 @@ int NwRawSend(PXPLAT pdata, session_t Se
 	/*
 	 * Figure out the length of the request
 	 */
-	frag = kmalloc(xRequest.uNumReplyFrags * sizeof(NwcFrag), GFP_KERNEL);
-	DbgPrint("[XPLAT RawNCP] - Reply Frag Count 0x%X\n", xRequest.uNumReplyFrags);
+	frag =
+	    kmalloc(xRequest.uNumReplyFrags * sizeof(struct nwc_frag), GFP_KERNEL);
+
+	DbgPrint("[XPLAT RawNCP] - Reply Frag Count 0x%X\n",
+		 xRequest.uNumReplyFrags);
 
 	if (!frag)
-		goto exit;
+		return (retCode);
 
-	cpylen = copy_from_user(frag, xRequest.pReplyFrags, xRequest.uNumReplyFrags * sizeof(NwcFrag));
+	cpylen =
+	    copy_from_user(frag, xRequest.pReplyFrags,
+			   xRequest.uNumReplyFrags * sizeof(struct nwc_frag));
 	totalLen = 0;
 
 	cFrag = frag;
@@ -270,11 +287,17 @@ int NwRawSend(PXPLAT pdata, session_t Se
 
 	DbgPrint("[XPLAT - RawNCP] - totalLen = %d\n", totalLen);
 	datalen = 0;
-	reqFrag = kmalloc(xRequest.uNumRequestFrags * sizeof(NwcFrag), GFP_KERNEL);
-	if (!reqFrag)
-		goto exit;
+	reqFrag =
+	    kmalloc(xRequest.uNumRequestFrags * sizeof(struct nwc_frag),
+			 GFP_KERNEL);
+	if (!reqFrag) {
+		kfree(frag);
+		return (retCode);
+	}
 
-	cpylen = copy_from_user(reqFrag, xRequest.pRequestFrags, xRequest.uNumRequestFrags * sizeof(NwcFrag));
+	cpylen =
+	    copy_from_user(reqFrag, xRequest.pRequestFrags,
+			   xRequest.uNumRequestFrags * sizeof(struct nwc_frag));
 	cFrag = reqFrag;
 	for (x = 0; x < xRequest.uNumRequestFrags; x++) {
 		datalen += cFrag->uLength;
@@ -285,12 +308,13 @@ int NwRawSend(PXPLAT pdata, session_t Se
 	 * Allocate the cmd Request
 	 */
 	cmdlen = datalen + sizeof(*cmd) + sizeof(*ncpData);
-	DbgPrint("[XPLAT RawNCP] - Frag Count 0x%X\n", xRequest.uNumRequestFrags);
+	DbgPrint("[XPLAT RawNCP] - Frag Count 0x%X\n",
+		 xRequest.uNumRequestFrags);
 	DbgPrint("[XPLAT RawNCP] - Total Command Data Len = %x\n", cmdlen);
 
 	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (!cmd)
-		goto exit;
+		return -ENOMEM;
 
 	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
 	cmd->Command.SequenceNumber = 0;
@@ -301,10 +325,10 @@ int NwRawSend(PXPLAT pdata, session_t Se
 	 * build the NCP Request
 	 */
 	cmd->dataLen = cmdlen - sizeof(*cmd);
-	ncpData = (PNwdCNCPReq) cmd->data;
+	ncpData = (struct nwd_ncp_req *) cmd->data;
 	ncpData->replyLen = totalLen;
 	ncpData->requestLen = datalen;
-	ncpData->ConnHandle = (HANDLE) (unsigned long) xRequest.ConnHandle;
+	ncpData->ConnHandle = (void *) (unsigned long) xRequest.ConnHandle;
 	ncpData->function = xRequest.uFunction;
 
 	reqData = ncpData->data;
@@ -312,15 +336,16 @@ int NwRawSend(PXPLAT pdata, session_t Se
 
 	for (x = 0; x < xRequest.uNumRequestFrags; x++) {
 		cpylen =
-		    copy_from_user(reqData, cFrag->pData,
-				   cFrag->uLength);
+			copy_from_user(reqData, cFrag->pData,
+					cFrag->uLength);
 		reqData += cFrag->uLength;
 		cFrag++;
 	}
 
-	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					(void **)&reply, &replylen,
-					INTERRUPTIBLE);
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
 	DbgPrint("RawNCP - reply = %x\n", reply);
 	DbgPrint("RawNCP - retCode = %x\n", retCode);
 
@@ -328,11 +353,11 @@ int NwRawSend(PXPLAT pdata, session_t Se
 		/*
 		 * we got reply data from the daemon
 		 */
-		ncpReply = (PNwdCNCPRep) reply->data;
+		ncpReply = (struct nwd_ncp_rep *) reply->data;
 		retCode = reply->Reply.ErrorCode;
 
 		DbgPrint("RawNCP - Reply Frag Count 0x%X\n",
-			 xRequest.uNumReplyFrags);
+				xRequest.uNumReplyFrags);
 
 		/*
 		 * We need to copy the reply frags to the packet.
@@ -344,11 +369,14 @@ int NwRawSend(PXPLAT pdata, session_t Se
 		for (x = 0; x < xRequest.uNumReplyFrags; x++) {
 
 			DbgPrint("RawNCP - Copy Frag %d: 0x%X\n", x,
-				 cFrag->uLength);
+					cFrag->uLength);
 
-			datalen = min((unsigned long)cFrag->uLength, totalLen);
+			datalen =
+				min((unsigned long) cFrag->uLength, totalLen);
 
-			cpylen = copy_to_user(cFrag->pData, reqData, datalen);
+			cpylen =
+				copy_to_user(cFrag->pData, reqData,
+						datalen);
 			totalLen -= datalen;
 			reqData += datalen;
 			actualReplyLength += datalen;
@@ -362,22 +390,21 @@ int NwRawSend(PXPLAT pdata, session_t Se
 	}
 
 	kfree(cmd);
-
 	xRequest.uActualReplyLength = actualReplyLength;
 	cpylen = copy_to_user(pdata->reqData, &xRequest, sizeof(xRequest));
 
-exit:
 	kfree(reqFrag);
 	kfree(frag);
-	return retCode;
+
+	return (retCode);
 }
 
-int NwConnClose(PXPLAT pdata, HANDLE * Handle, session_t Session)
+int novfs_conn_close(struct novfs_xplat *pdata, void ** Handle, struct novfs_schandle Session)
 {
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcCloseConn cc;
-	PNwdCCloseConn nwdClose;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_close_conn cc;
+	struct nwd_close_conn *nwdClose;
 	int retCode = 0;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 
@@ -388,35 +415,36 @@ int NwConnClose(PXPLAT pdata, HANDLE * H
 	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
-
 	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
 	cmd->Command.SequenceNumber = 0;
 	cmd->Command.SessionId = Session;
 	cmd->NwcCommand = NWC_CLOSE_CONN;
 
-	nwdClose = (PNwdCCloseConn) cmd->data;
+	nwdClose = (struct nwd_close_conn *) cmd->data;
 	cmd->dataLen = sizeof(*nwdClose);
 	*Handle = nwdClose->ConnHandle = Uint32toHandle(cc.ConnHandle);
 
 	/*
 	 * send the request
 	 */
-	retCode = Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					(void **)&reply, &replylen, 0);
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen, 0);
 	if (reply) {
 		retCode = reply->Reply.ErrorCode;
 		kfree(reply);
 	}
 	kfree(cmd);
-	return retCode;
+	return (retCode);
+
 }
 
-int NwSysConnClose(PXPLAT pdata, unsigned long *Handle, session_t Session)
+int novfs_sys_conn_close(struct novfs_xplat *pdata, unsigned long *Handle, struct novfs_schandle Session)
 {
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcCloseConn cc;
-	PNwdCCloseConn nwdClose;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_close_conn cc;
+	struct nwd_close_conn *nwdClose;
 	unsigned int retCode = 0;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 
@@ -424,133 +452,87 @@ int NwSysConnClose(PXPLAT pdata, unsigne
 
 	datalen = sizeof(*nwdClose);
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_SYS_CLOSE_CONN;
-
-		nwdClose = (PNwdCCloseConn) cmd->data;
-		cmd->dataLen = sizeof(*nwdClose);
-		nwdClose->ConnHandle = (HANDLE) (unsigned long) cc.ConnHandle;
-		*Handle = (unsigned long) cc.ConnHandle;
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_SYS_CLOSE_CONN;
 
-		/*
-		 * send the request
-		 */
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen, 0);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	nwdClose = (struct nwd_close_conn *) cmd->data;
+	cmd->dataLen = sizeof(*nwdClose);
+	nwdClose->ConnHandle = (void *) (unsigned long) cc.ConnHandle;
+	*Handle = (unsigned long) cc.ConnHandle;
 
+	/*
+	 * send the request
+	 */
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0, (void **)&reply, &replylen, 0);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
-
+	kfree(cmd);
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int NwLoginIdentity(PXPLAT pdata, struct schandle *Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_login_id(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
-	NwcLoginIdentity lgn, *plgn;
+	struct nwc_login_id lgn, *plgn;
 	int retCode = -ENOMEM;
-	NclString server;
-	NclString username;
-	NclString password;
+	struct ncl_string server;
+	struct ncl_string username;
+	struct ncl_string password;
 	unsigned long cpylen;
-	NwcString nwcStr;
+	struct nwc_string nwcStr;
 
 	cpylen = copy_from_user(&lgn, pdata->reqData, sizeof(lgn));
 
 	DbgPrint("NwLoginIdentity:\n");
-	mydump(sizeof(lgn), &lgn);
+	novfs_dump(sizeof(lgn), &lgn);
 
 	cpylen = copy_from_user(&nwcStr, lgn.pDomainName, sizeof(nwcStr));
 	DbgPrint("NwLoginIdentity: DomainName\n");
-	mydump(sizeof(nwcStr), &nwcStr);
+	novfs_dump(sizeof(nwcStr), &nwcStr);
 
-	if ((server.buffer = Novfs_Malloc(nwcStr.DataLen, GFP_KERNEL))) {
+	if ((server.buffer = kmalloc(nwcStr.DataLen, GFP_KERNEL))) {
 		server.type = nwcStr.DataType;
 		server.len = nwcStr.DataLen;
-		if (!copy_from_user
-		    ((void *)server.buffer, nwcStr.pBuffer, server.len)) {
+		if (!copy_from_user((void *)server.buffer, nwcStr.pBuffer, server.len)) {
 			DbgPrint("NwLoginIdentity: Server\n");
-			mydump(server.len, server.buffer);
+			novfs_dump(server.len, server.buffer);
 
-			cpylen =
-			    copy_from_user(&nwcStr, lgn.pObjectName,
-					   sizeof(nwcStr));
+			cpylen = copy_from_user(&nwcStr, lgn.pObjectName, sizeof(nwcStr));
 			DbgPrint("NwLoginIdentity: ObjectName\n");
-			mydump(sizeof(nwcStr), &nwcStr);
+			novfs_dump(sizeof(nwcStr), &nwcStr);
 
-			if ((username.buffer =
-			     Novfs_Malloc(nwcStr.DataLen, GFP_KERNEL))) {
+			if ((username.buffer = kmalloc(nwcStr.DataLen, GFP_KERNEL))) {
 				username.type = nwcStr.DataType;
 				username.len = nwcStr.DataLen;
-				if (!copy_from_user
-				    ((void *)username.buffer, nwcStr.pBuffer,
-				     username.len)) {
+				if (!copy_from_user((void *)username.buffer, nwcStr.pBuffer, username.len)) {
 					DbgPrint("NwLoginIdentity: User\n");
-					mydump(username.len, username.buffer);
+					novfs_dump(username.len, username.buffer);
 
-					cpylen =
-					    copy_from_user(&nwcStr,
-							   lgn.pPassword,
-							   sizeof(nwcStr));
+					cpylen = copy_from_user(&nwcStr, lgn.pPassword, sizeof(nwcStr));
 					DbgPrint("NwLoginIdentity: Password\n");
-					mydump(sizeof(nwcStr), &nwcStr);
+					novfs_dump(sizeof(nwcStr), &nwcStr);
 
-					if ((password.buffer =
-					     Novfs_Malloc(nwcStr.DataLen,
-							  GFP_KERNEL))) {
+					if ((password.buffer = kmalloc(nwcStr.DataLen, GFP_KERNEL))) {
 						password.type = nwcStr.DataType;
 						password.len = nwcStr.DataLen;
-						if (!copy_from_user
-						    ((void *)password.buffer,
-						     nwcStr.pBuffer,
-						     password.len)) {
-							retCode =
-							    do_login(&server,
-								     &username,
-								     &password,
-								     (HANDLE *)&lgn.AuthenticationId,
-								     Session);
+						if (!copy_from_user((void *)password.buffer, nwcStr.pBuffer, password.len)) {
+							retCode =  novfs_do_login(&server, &username, &password, (void **)&lgn.AuthenticationId, &Session);
 							if (retCode) {
 								lgn.AuthenticationId = 0;
 							}
 
-							plgn =
-							    (NwcLoginIdentity *)
-							    pdata->reqData;
-							cpylen =
-							    copy_to_user(&plgn->
-									 AuthenticationId,
-									 &lgn.
-									 AuthenticationId,
-									 sizeof
-									 (plgn->
-									  AuthenticationId));
-
+							plgn = (struct nwc_login_id *)pdata->reqData;
+							cpylen = copy_to_user(&plgn->AuthenticationId, &lgn.AuthenticationId, sizeof(plgn->AuthenticationId));
 						}
-						memset(password.buffer, 0,
-						       password.len);
+						memset(password.buffer, 0, password.len);
 						kfree(password.buffer);
 					}
 				}
@@ -563,633 +545,504 @@ int NwLoginIdentity(PXPLAT pdata, struct
 	return (retCode);
 }
 
-/*++======================================================================*/
-int NwAuthConnWithId(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	NwcAuthenticateWithId pauth;
-	PNwdCAuthenticateWithId pDauth;
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
+int novfs_auth_conn(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct nwc_auth_with_id pauth;
+	struct nwc_auth_wid *pDauth;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 
 	datalen = sizeof(*pDauth);
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_AUTHENTICATE_CONN_WITH_ID;
-
-		cpylen = copy_from_user(&pauth, pdata->reqData, sizeof(pauth));
-
-		pDauth = (PNwdCAuthenticateWithId) cmd->data;
-		cmd->dataLen = datalen;
-		pDauth->AuthenticationId = pauth.AuthenticationId;
-		pDauth->ConnHandle = (HANDLE) (unsigned long) pauth.ConnHandle;
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_AUTHENTICATE_CONN_WITH_ID;
+
+	cpylen = copy_from_user(&pauth, pdata->reqData, sizeof(pauth));
+
+	pDauth = (struct nwc_auth_wid *) cmd->data;
+	cmd->dataLen = datalen;
+	pDauth->AuthenticationId = pauth.AuthenticationId;
+	pDauth->ConnHandle = (void *) (unsigned long) pauth.ConnHandle;
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
 	return (retCode);
 }
 
-/*++======================================================================*/
-int NwLicenseConn(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcLicenseConn lisc;
-	PNwdCLicenseConn pDLisc;
+int novfs_license_conn(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_license_conn lisc;
+	struct nwc_lisc_id * pDLisc;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 
 	datalen = sizeof(*pDLisc);
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_LICENSE_CONN;
-
-		cpylen = copy_from_user(&lisc, pdata->reqData, sizeof(lisc));
-
-		pDLisc = (PNwdCLicenseConn) cmd->data;
-		cmd->dataLen = datalen;
-		pDLisc->ConnHandle = (HANDLE) (unsigned long) lisc.ConnHandle;
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_LICENSE_CONN;
+
+	cpylen = copy_from_user(&lisc, pdata->reqData, sizeof(lisc));
+
+	pDLisc = (struct nwc_lisc_id *) cmd->data;
+	cmd->dataLen = datalen;
+	pDLisc->ConnHandle = (void *) (unsigned long) lisc.ConnHandle;
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
+	kfree(cmd);
 	return (retCode);
 }
 
-/*++======================================================================*/
-int NwLogoutIdentity(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcLogoutIdentity logout;
-	PNwdCLogoutIdentity pDLogout;
+int novfs_logout_id(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_lo_id logout, *pDLogout;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 
 	datalen = sizeof(*pDLogout);
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_LOGOUT_IDENTITY;
+	if (!cmd)
+		return -ENOMEM;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_LOGOUT_IDENTITY;
 
-		cpylen =
-		    copy_from_user(&logout, pdata->reqData, sizeof(logout));
+	cpylen =
+		copy_from_user(&logout, pdata->reqData, sizeof(logout));
 
-		pDLogout = (PNwdCLogoutIdentity) cmd->data;
-		cmd->dataLen = datalen;
-		pDLogout->AuthenticationId = logout.AuthenticationId;
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	pDLogout = (struct nwc_lo_id *) cmd->data;
+	cmd->dataLen = datalen;
+	pDLogout->AuthenticationId = logout.AuthenticationId;
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
+	kfree(cmd);
 	return (retCode);
 }
 
-/*++======================================================================*/
-int NwUnlicenseConn(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	PNwdCUnlicenseConn pUconn;
-	NwcUnlicenseConn ulc;
+int novfs_unlicense_conn(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_unlic_conn *pUconn, ulc;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 
 	cpylen = copy_from_user(&ulc, pdata->reqData, sizeof(ulc));
 	datalen = sizeof(*pUconn);
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_UNLICENSE_CONN;
-		cmd->dataLen = datalen;
-		pUconn = (PNwdCUnlicenseConn) cmd->data;
-
-		pUconn->ConnHandle = (HANDLE) (unsigned long) ulc.ConnHandle;
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			/*
-			 * we got reply data from the daemon
-			 */
-			retCode = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_UNLICENSE_CONN;
+	cmd->dataLen = datalen;
+	pUconn = (struct nwc_unlic_conn *) cmd->data;
 
-		kfree(cmd);
+	pUconn->ConnHandle = (void *) (unsigned long) ulc.ConnHandle;
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		/*
+		 * we got reply data from the daemon
+		 */
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int NwUnAuthenticate(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcUnauthenticate auth;
-	PNwdCUnauthenticate pDAuth;
+int novfs_unauthenticate(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_unauthenticate auth, *pDAuth;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 
 	datalen = sizeof(*pDAuth);
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = (struct novfs_xplat_call_request *)kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_UNAUTHENTICATE_CONN;
-
-		cpylen = copy_from_user(&auth, pdata->reqData, sizeof(auth));
-
-		pDAuth = (PNwdCUnauthenticate) cmd->data;
-		cmd->dataLen = datalen;
-		pDAuth->AuthenticationId = auth.AuthenticationId;
-		pDAuth->ConnHandle = (HANDLE) (unsigned long) auth.ConnHandle;
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	if (!cmd)
+		return -ENOMEM;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_UNAUTHENTICATE_CONN;
+
+	cpylen = copy_from_user(&auth, pdata->reqData, sizeof(auth));
+
+	pDAuth = (struct nwc_unauthenticate *) cmd->data;
+	cmd->dataLen = datalen;
+	pDAuth->AuthenticationId = auth.AuthenticationId;
+	pDAuth->ConnHandle = (void *) (unsigned long) auth.ConnHandle;
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
+	kfree(cmd);
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int NwGetConnInfo(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcGetConnInfo connInfo;
-	PNwdCGetConnInfo pDConnInfo;
+int novfs_get_conn_info(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_get_conn_info connInfo;
+	struct nwd_conn_info *pDConnInfo;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, replylen, cpylen;
 
 	cmdlen = sizeof(*cmd) + sizeof(*pDConnInfo);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	cpylen =
-	    copy_from_user(&connInfo, pdata->reqData, sizeof(NwcGetConnInfo));
+	    copy_from_user(&connInfo, pdata->reqData, sizeof(struct nwc_get_conn_info));
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_GET_CONN_INFO;
-
-		pDConnInfo = (PNwdCGetConnInfo) cmd->data;
-
-		pDConnInfo->ConnHandle = (HANDLE) (unsigned long) connInfo.ConnHandle;
-		pDConnInfo->uInfoLevel = connInfo.uInfoLevel;
-		pDConnInfo->uInfoLength = connInfo.uInfoLength;
-		cmd->dataLen = sizeof(*pDConnInfo);
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			if (!retCode) {
-				GetConnData(&connInfo, cmd, reply);
-			}
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_GET_CONN_INFO;
 
-			kfree(reply);
+	pDConnInfo = (struct nwd_conn_info *) cmd->data;
+
+	pDConnInfo->ConnHandle = (void *) (unsigned long) connInfo.ConnHandle;
+	pDConnInfo->uInfoLevel = connInfo.uInfoLevel;
+	pDConnInfo->uInfoLength = connInfo.uInfoLength;
+	cmd->dataLen = sizeof(*pDConnInfo);
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		if (!retCode) {
+			GetConnData(&connInfo, cmd, reply);
 		}
-		kfree(cmd);
 
+		kfree(reply);
 	}
-
+	kfree(cmd);
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int NwSetConnInfo(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcSetConnInfo connInfo;
-	PNwdCSetConnInfo pDConnInfo;
+int novfs_set_conn_info(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_set_conn_info connInfo;
+	struct nwd_set_conn_info *pDConnInfo;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, replylen, cpylen;
 
 	cmdlen = sizeof(*cmd) + sizeof(*pDConnInfo);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	cpylen =
-	    copy_from_user(&connInfo, pdata->reqData, sizeof(NwcSetConnInfo));
+	    copy_from_user(&connInfo, pdata->reqData, sizeof(struct nwc_set_conn_info));
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_SET_CONN_INFO;
-
-		pDConnInfo = (PNwdCSetConnInfo) cmd->data;
-
-		pDConnInfo->ConnHandle = (HANDLE) (unsigned long) connInfo.ConnHandle;
-		pDConnInfo->uInfoLevel = connInfo.uInfoLevel;
-		pDConnInfo->uInfoLength = connInfo.uInfoLength;
-		cmd->dataLen = sizeof(*pDConnInfo);
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	if (!cmd)
+		return -ENOMEM;
 
-	}
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_SET_CONN_INFO;
 
+	pDConnInfo = (struct nwd_set_conn_info *) cmd->data;
+
+	pDConnInfo->ConnHandle = (void *) (unsigned long) connInfo.ConnHandle;
+	pDConnInfo->uInfoLevel = connInfo.uInfoLevel;
+	pDConnInfo->uInfoLength = connInfo.uInfoLength;
+	cmd->dataLen = sizeof(*pDConnInfo);
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
+	}
+	kfree(cmd);
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int NwGetIdentityInfo(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcGetIdentityInfo qidInfo, *gId;
-	PNwdCGetIdentityInfo idInfo;
-	NwcString xferStr;
+int novfs_get_id_info(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_get_id_info qidInfo, *gId;
+	struct nwd_get_id_info *idInfo;
+	struct nwc_string xferStr;
 	char *str;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, replylen, cpylen;
 
 	cmdlen = sizeof(*cmd) + sizeof(*idInfo);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 	cpylen = copy_from_user(&qidInfo, pdata->reqData, sizeof(qidInfo));
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_GET_IDENTITY_INFO;
-
-		idInfo = (PNwdCGetIdentityInfo) cmd->data;
-
-		idInfo->AuthenticationId = qidInfo.AuthenticationId;
-		cmd->dataLen = sizeof(*idInfo);
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-
-			if (!reply->Reply.ErrorCode) {
-				/*
-				 * Save the return info to the user structure.
-				 */
-				gId = pdata->reqData;
-				idInfo = (PNwdCGetIdentityInfo) reply->data;
-				cpylen =
-				    copy_to_user(&gId->AuthenticationId,
-						 &idInfo->AuthenticationId,
-						 sizeof(idInfo->
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_GET_IDENTITY_INFO;
+
+	idInfo = (struct nwd_get_id_info *) cmd->data;
+
+	idInfo->AuthenticationId = qidInfo.AuthenticationId;
+	cmd->dataLen = sizeof(*idInfo);
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+
+		if (!reply->Reply.ErrorCode) {
+			/*
+			 * Save the return info to the user structure.
+			 */
+			gId = pdata->reqData;
+			idInfo = (struct nwd_get_id_info *) reply->data;
+			cpylen =
+				copy_to_user(&gId->AuthenticationId,
+						&idInfo->AuthenticationId,
+						sizeof(idInfo->
 							AuthenticationId));
-				cpylen =
-				    copy_to_user(&gId->AuthType,
-						 &idInfo->AuthType,
-						 sizeof(idInfo->AuthType));
-				cpylen =
-				    copy_to_user(&gId->IdentityFlags,
-						 &idInfo->IdentityFlags,
-						 sizeof(idInfo->IdentityFlags));
-				cpylen =
-				    copy_to_user(&gId->NameType,
-						 &idInfo->NameType,
-						 sizeof(idInfo->NameType));
-				cpylen =
-				    copy_to_user(&gId->ObjectType,
-						 &idInfo->ObjectType,
-						 sizeof(idInfo->ObjectType));
-
-				cpylen =
-				    copy_from_user(&xferStr, gId->pDomainName,
-						   sizeof(NwcString));
-				str =
-				    (char *)((char *)reply->data +
-					     idInfo->pDomainNameOffset);
-				cpylen =
-				    copy_to_user(xferStr.pBuffer, str,
-						 idInfo->domainLen);
-				xferStr.DataType = NWC_STRING_TYPE_ASCII;
-				xferStr.DataLen = idInfo->domainLen;
-				cpylen =
-				    copy_to_user(gId->pDomainName, &xferStr,
-						 sizeof(NwcString));
-
-				cpylen =
-				    copy_from_user(&xferStr, gId->pObjectName,
-						   sizeof(NwcString));
-				str =
-				    (char *)((char *)reply->data +
-					     idInfo->pObjectNameOffset);
-				cpylen =
-				    copy_to_user(xferStr.pBuffer, str,
-						 idInfo->objectLen);
-				xferStr.DataLen = idInfo->objectLen - 1;
-				xferStr.DataType = NWC_STRING_TYPE_ASCII;
-				cpylen =
-				    copy_to_user(gId->pObjectName, &xferStr,
-						 sizeof(NwcString));
-			}
+			cpylen =
+				copy_to_user(&gId->AuthType,
+						&idInfo->AuthType,
+						sizeof(idInfo->AuthType));
+			cpylen =
+				copy_to_user(&gId->IdentityFlags,
+						&idInfo->IdentityFlags,
+						sizeof(idInfo->IdentityFlags));
+			cpylen =
+				copy_to_user(&gId->NameType,
+						&idInfo->NameType,
+						sizeof(idInfo->NameType));
+			cpylen =
+				copy_to_user(&gId->ObjectType,
+						&idInfo->ObjectType,
+						sizeof(idInfo->ObjectType));
 
-			kfree(reply);
+			cpylen =
+				copy_from_user(&xferStr, gId->pDomainName,
+						sizeof(struct nwc_string));
+			str =
+				(char *)((char *)reply->data +
+						idInfo->pDomainNameOffset);
+			cpylen =
+				copy_to_user(xferStr.pBuffer, str,
+						idInfo->domainLen);
+			xferStr.DataType = NWC_STRING_TYPE_ASCII;
+			xferStr.DataLen = idInfo->domainLen;
+			cpylen =
+				copy_to_user(gId->pDomainName, &xferStr,
+						sizeof(struct nwc_string));
+
+			cpylen =
+				copy_from_user(&xferStr, gId->pObjectName,
+						sizeof(struct nwc_string));
+			str =
+				(char *)((char *)reply->data +
+						idInfo->pObjectNameOffset);
+			cpylen =
+				copy_to_user(xferStr.pBuffer, str,
+						idInfo->objectLen);
+			xferStr.DataLen = idInfo->objectLen - 1;
+			xferStr.DataType = NWC_STRING_TYPE_ASCII;
+			cpylen =
+				copy_to_user(gId->pObjectName, &xferStr,
+						sizeof(struct nwc_string));
 		}
-		kfree(cmd);
 
+		kfree(reply);
 	}
-
+	kfree(cmd);
 	return (retCode);
 }
 
-/*++======================================================================*/
-int NwScanConnInfo(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcScanConnInfo connInfo, *rInfo;
-	PNwdCScanConnInfo pDConnInfo;
+int novfs_scan_conn_info(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_scan_conn_info connInfo, *rInfo;
+	struct nwd_scan_conn_info *pDConnInfo;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, replylen, cpylen;
 	unsigned char *localData;
 
 	cpylen =
-	    copy_from_user(&connInfo, pdata->reqData, sizeof(NwcScanConnInfo));
+	    copy_from_user(&connInfo, pdata->reqData, sizeof(struct nwc_scan_conn_info));
 
 	cmdlen = sizeof(*cmd) + sizeof(*pDConnInfo) + connInfo.uScanInfoLen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_SCAN_CONN_INFO;
-
-		pDConnInfo = (PNwdCScanConnInfo) cmd->data;
-
-		DbgPrint("NwScanConnInfo: Input Data\n");
-		DbgPrint("connInfo.uScanIndex = 0x%X\n", connInfo.uScanIndex);
-		DbgPrint("connInfo.uConnectionReference = 0x%X\n",
-			 connInfo.uConnectionReference);
-		DbgPrint("connInfo.uScanInfoLevel = 0x%X\n",
-			 connInfo.uScanInfoLevel);
-		DbgPrint("connInfo.uScanInfoLen = 0x%X\n",
-			 connInfo.uScanInfoLen);
-		DbgPrint("connInfo.uReturnInfoLength = 0x%X\n",
-			 connInfo.uReturnInfoLength);
-		DbgPrint("connInfo.uReturnInfoLevel = 0x%X\n",
-			 connInfo.uReturnInfoLevel);
-		DbgPrint("connInfo.uScanFlags = 0x%X\n", connInfo.uScanFlags);
-
-		pDConnInfo->uScanIndex = connInfo.uScanIndex;
-		pDConnInfo->uConnectionReference =
-		    connInfo.uConnectionReference;
-		pDConnInfo->uScanInfoLevel = connInfo.uScanInfoLevel;
-		pDConnInfo->uScanInfoLen = connInfo.uScanInfoLen;
-		pDConnInfo->uReturnInfoLength = connInfo.uReturnInfoLength;
-		pDConnInfo->uReturnInfoLevel = connInfo.uReturnInfoLevel;
-		pDConnInfo->uScanFlags = connInfo.uScanFlags;
-
-		if (pDConnInfo->uScanInfoLen) {
-			localData = (unsigned char *) pDConnInfo;
-			pDConnInfo->uScanConnInfoOffset = sizeof(*pDConnInfo);
-			localData += pDConnInfo->uScanConnInfoOffset;
-			cpylen =
-			    copy_from_user(localData, connInfo.pScanConnInfo,
-					   connInfo.uScanInfoLen);
-		} else {
-			pDConnInfo->uScanConnInfoOffset = 0;
-		}
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_SCAN_CONN_INFO;
+
+	pDConnInfo = (struct nwd_scan_conn_info *) cmd->data;
+
+	DbgPrint("NwScanConnInfo: Input Data\n");
+	DbgPrint("connInfo.uScanIndex = 0x%X\n", connInfo.uScanIndex);
+	DbgPrint("connInfo.uConnectionReference = 0x%X\n",
+			connInfo.uConnectionReference);
+	DbgPrint("connInfo.uScanInfoLevel = 0x%X\n",
+			connInfo.uScanInfoLevel);
+	DbgPrint("connInfo.uScanInfoLen = 0x%X\n",
+			connInfo.uScanInfoLen);
+	DbgPrint("connInfo.uReturnInfoLength = 0x%X\n",
+			connInfo.uReturnInfoLength);
+	DbgPrint("connInfo.uReturnInfoLevel = 0x%X\n",
+			connInfo.uReturnInfoLevel);
+	DbgPrint("connInfo.uScanFlags = 0x%X\n", connInfo.uScanFlags);
+
+	pDConnInfo->uScanIndex = connInfo.uScanIndex;
+	pDConnInfo->uConnectionReference =
+		connInfo.uConnectionReference;
+	pDConnInfo->uScanInfoLevel = connInfo.uScanInfoLevel;
+	pDConnInfo->uScanInfoLen = connInfo.uScanInfoLen;
+	pDConnInfo->uReturnInfoLength = connInfo.uReturnInfoLength;
+	pDConnInfo->uReturnInfoLevel = connInfo.uReturnInfoLevel;
+	pDConnInfo->uScanFlags = connInfo.uScanFlags;
+
+	if (pDConnInfo->uScanInfoLen) {
+		localData = (unsigned char *) pDConnInfo;
+		pDConnInfo->uScanConnInfoOffset = sizeof(*pDConnInfo);
+		localData += pDConnInfo->uScanConnInfoOffset;
+		cpylen =
+			copy_from_user(localData, connInfo.pScanConnInfo,
+					connInfo.uScanInfoLen);
+	} else {
+		pDConnInfo->uScanConnInfoOffset = 0;
+	}
+
+	cmd->dataLen = sizeof(*pDConnInfo);
 
-		cmd->dataLen = sizeof(*pDConnInfo);
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		DbgPrint("NwScanConnInfo: Reply recieved\n");
+		DbgPrint("   NextIndex = %x\n", connInfo.uScanIndex);
+		DbgPrint("   ErrorCode = %x\n", reply->Reply.ErrorCode);
+		DbgPrint("   data = %x\n", reply->data);
 
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			DbgPrint("NwScanConnInfo: Reply recieved\n");
-			DbgPrint("   NextIndex = %x\n", connInfo.uScanIndex);
-			DbgPrint("   ErrorCode = %x\n", reply->Reply.ErrorCode);
-			DbgPrint("   data = %x\n", reply->data);
-
-			pDConnInfo = (PNwdCScanConnInfo) reply->data;
-			retCode = (unsigned long) reply->Reply.ErrorCode;
-			if (!retCode) {
-				GetUserData(&connInfo, cmd, reply);
-				rInfo = (NwcScanConnInfo *) pdata->repData;
-				cpylen =
-				    copy_to_user(pdata->repData,
-						 &pDConnInfo->uScanIndex,
-						 sizeof(pDConnInfo->
+		pDConnInfo = (struct nwd_scan_conn_info *) reply->data;
+		retCode = (unsigned long) reply->Reply.ErrorCode;
+		if (!retCode) {
+			GetUserData(&connInfo, cmd, reply);
+			rInfo = (struct nwc_scan_conn_info *) pdata->repData;
+			cpylen =
+				copy_to_user(pdata->repData,
+						&pDConnInfo->uScanIndex,
+						sizeof(pDConnInfo->
 							uScanIndex));
-				cpylen =
-				    copy_to_user(&rInfo->uConnectionReference,
-						 &pDConnInfo->
-						 uConnectionReference,
-						 sizeof(pDConnInfo->
+			cpylen =
+				copy_to_user(&rInfo->uConnectionReference,
+						&pDConnInfo->
+						uConnectionReference,
+						sizeof(pDConnInfo->
 							uConnectionReference));
-			} else {
-				unsigned long x;
+		} else {
+			unsigned long x;
 
-				x = 0;
-				rInfo = (NwcScanConnInfo *) pdata->reqData;
-				cpylen =
-				    copy_to_user(&rInfo->uConnectionReference,
-						 &x,
-						 sizeof(rInfo->
+			x = 0;
+			rInfo = (struct nwc_scan_conn_info *) pdata->reqData;
+			cpylen =
+				copy_to_user(&rInfo->uConnectionReference,
+						&x,
+						sizeof(rInfo->
 							uConnectionReference));
-			}
-
-			kfree(reply);
-		} else {
-			retCode = -EIO;
 		}
-		kfree(cmd);
 
+		kfree(reply);
+	} else {
+		retCode = -EIO;
 	}
-
+	kfree(cmd);
 	return (retCode);
 }
 
-/*++======================================================================*/
-static void GetUserData(NwcScanConnInfo * connInfo, PXPLAT_CALL_REQUEST cmd, PXPLAT_CALL_REPLY reply)
 /*
- *  Abstract:  Copies the user data out of the scan conn info call.
- *
- *========================================================================*/
+ *  Copies the user data out of the scan conn info call.
+ */
+static void GetUserData(struct nwc_scan_conn_info * connInfo, struct novfs_xplat_call_request *cmd, struct novfs_xplat_call_reply *reply)
 {
 	unsigned long uLevel;
-	PNwdCScanConnInfo pDConnInfo;
+	struct nwd_scan_conn_info *pDConnInfo;
 
 	unsigned char *srcData = NULL;
 	unsigned long dataLen = 0, cpylen;
 
-	pDConnInfo = (PNwdCScanConnInfo) reply->data;
+	pDConnInfo = (struct nwd_scan_conn_info *) reply->data;
 	uLevel = pDConnInfo->uReturnInfoLevel;
 	DbgPrint
 	    ("[GetUserData] uLevel = %d, reply = 0x%p, reply->data = 0x%X\n",
@@ -1224,7 +1077,7 @@ static void GetUserData(NwcScanConnInfo
 	case NWC_CONN_INFO_TRAN_ADDR:
 		{
 			unsigned char *dstData = connInfo->pReturnConnInfo;
-			NwcTranAddr tranAddr;
+			struct nwc_tran_addr tranAddr;
 
 			srcData = (unsigned char *) reply->data;
 			dataLen = reply->dataLen;
@@ -1238,20 +1091,20 @@ static void GetUserData(NwcScanConnInfo
 					   sizeof(tranAddr));
 
 			srcData +=
-			    ((PNwdCScanConnInfo) srcData)->
+			    ((struct nwd_scan_conn_info *) srcData)->
 			    uReturnConnInfoOffset;
 
 			tranAddr.uTransportType =
-			    ((PNwdTranAddr) srcData)->uTransportType;
+			    ((struct nwd_tran_addr *)  srcData)->uTransportType;
 			tranAddr.uAddressLength =
-			    ((PNwdTranAddr) srcData)->uAddressLength;
+			    ((struct tagNwdTranAddrEx *) srcData)->uAddressLength;
 
 			cpylen =
 			    copy_to_user(dstData, &tranAddr, sizeof(tranAddr));
 			cpylen =
 			    copy_to_user(tranAddr.puAddress,
-					 ((PNwdTranAddr) srcData)->Buffer,
-					 ((PNwdTranAddr) srcData)->
+					 ((struct tagNwdTranAddrEx *) srcData)->Buffer,
+					 ((struct tagNwdTranAddrEx *) srcData)->
 					 uAddressLength);
 			dataLen = 0;
 			break;
@@ -1276,20 +1129,18 @@ static void GetUserData(NwcScanConnInfo
 	return;
 }
 
-/*++======================================================================*/
-static void GetConnData(NwcGetConnInfo * connInfo, PXPLAT_CALL_REQUEST cmd, PXPLAT_CALL_REPLY reply)
 /*
- *  Abstract:  Copies the user data out of the scan conn info call.
- *
- *========================================================================*/
+ *  Copies the user data out of the scan conn info call.
+ */
+static void GetConnData(struct nwc_get_conn_info * connInfo, struct novfs_xplat_call_request *cmd, struct novfs_xplat_call_reply *reply)
 {
 	unsigned long uLevel;
-	PNwdCGetConnInfo pDConnInfo;
+	struct nwd_conn_info * pDConnInfo;
 
 	unsigned char *srcData = NULL;
 	unsigned long dataLen = 0, cpylen;
 
-	pDConnInfo = (PNwdCGetConnInfo) cmd->data;
+	pDConnInfo = (struct nwd_conn_info *) cmd->data;
 	uLevel = pDConnInfo->uInfoLevel;
 
 	switch (uLevel) {
@@ -1305,7 +1156,7 @@ static void GetConnData(NwcGetConnInfo *
 	case NWC_CONN_INFO_TRAN_ADDR:
 		{
 			unsigned char *dstData = connInfo->pConnInfo;
-			NwcTranAddr tranAddr;
+			struct nwc_tran_addr tranAddr;
 
 			srcData = (unsigned char *) reply->data;
 
@@ -1313,16 +1164,16 @@ static void GetConnData(NwcGetConnInfo *
 			    copy_from_user(&tranAddr, dstData,
 					   sizeof(tranAddr));
 			tranAddr.uTransportType =
-			    ((PNwdTranAddr) srcData)->uTransportType;
+			    ((struct tagNwdTranAddrEx *) srcData)->uTransportType;
 			tranAddr.uAddressLength =
-			    ((PNwdTranAddr) srcData)->uAddressLength;
+			    ((struct tagNwdTranAddrEx *) srcData)->uAddressLength;
 
 			cpylen =
 			    copy_to_user(dstData, &tranAddr, sizeof(tranAddr));
 			cpylen =
 			    copy_to_user(tranAddr.puAddress,
-					 ((PNwdTranAddr) srcData)->Buffer,
-					 ((PNwdTranAddr) srcData)->
+					 ((struct tagNwdTranAddrEx *) srcData)->Buffer,
+					 ((struct tagNwdTranAddrEx *) srcData)->
 					 uAddressLength);
 			dataLen = 0;
 			break;
@@ -1376,343 +1227,282 @@ static void GetConnData(NwcGetConnInfo *
 	return;
 }
 
-/*++======================================================================*/
-int NwGetDaemonVersion(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	PNwdCGetRequesterVersion pDVersion;
+int novfs_get_daemon_ver(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwd_get_reqversion *pDVersion;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 
 	datalen = sizeof(*pDVersion);
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
-
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_GET_REQUESTER_VERSION;
-		cmdlen = sizeof(*cmd);
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			pDVersion = (PNwdCGetRequesterVersion) reply->data;
-			cpylen =
-			    copy_to_user(pDVersion, pdata->reqData,
-					 sizeof(*pDVersion));
-			kfree(reply);
-		}
-		kfree(cmd);
-	}
-	return (retCode);
-
-}
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
 
-/*++======================================================================*/
-int NwcGetPreferredDSTree(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	PNwdCGetPreferredDsTree pDGetTree;
-	NwcGetPreferredDsTree xplatCall, *p;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_GET_REQUESTER_VERSION;
+	cmdlen = sizeof(*cmd);
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		pDVersion = (struct nwd_get_reqversion *) reply->data;
+		cpylen =
+			copy_to_user(pDVersion, pdata->reqData,
+					sizeof(*pDVersion));
+		kfree(reply);
+	}
+	kfree(cmd);
+	return (retCode);
+
+}
+
+int novfs_get_preferred_DS_tree(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwd_get_pref_ds_tree *pDGetTree;
+	struct nwc_get_pref_ds_tree xplatCall, *p;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 	unsigned char *dPtr;
 
 	cpylen =
 	    copy_from_user(&xplatCall, pdata->reqData,
-			   sizeof(NwcGetPreferredDsTree));
+			   sizeof(struct nwc_get_pref_ds_tree));
 	datalen = sizeof(*pDGetTree) + xplatCall.uTreeLength;
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_GET_PREFERRED_DS_TREE;
-		cmdlen = sizeof(*cmd);
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			if (!retCode) {
-				pDGetTree =
-				    (PNwdCGetPreferredDsTree) reply->data;
-				dPtr =
-				    reply->data + pDGetTree->DsTreeNameOffset;
-				p = (NwcGetPreferredDsTree *) pdata->reqData;
-
-				DbgPrint
-				    ("NwcGetPreferredDSTree: Reply recieved\n");
-				DbgPrint("   TreeLen = %x\n",
-					 pDGetTree->uTreeLength);
-				DbgPrint("   TreeName = %s\n", dPtr);
-
-				cpylen =
-				    copy_to_user(p, &pDGetTree->uTreeLength, 4);
-				cpylen =
-				    copy_to_user(xplatCall.pDsTreeName, dPtr,
-						 pDGetTree->uTreeLength);
-			}
-			kfree(reply);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_GET_PREFERRED_DS_TREE;
+	cmdlen = sizeof(*cmd);
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		if (!retCode) {
+			pDGetTree =
+				(struct nwd_get_pref_ds_tree *) reply->data;
+			dPtr =
+				reply->data + pDGetTree->DsTreeNameOffset;
+			p = (struct nwc_get_pref_ds_tree *) pdata->reqData;
+
+			DbgPrint
+				("NwcGetPreferredDSTree: Reply recieved\n");
+			DbgPrint("   TreeLen = %x\n",
+					pDGetTree->uTreeLength);
+			DbgPrint("   TreeName = %s\n", dPtr);
+
+			cpylen =
+				copy_to_user(p, &pDGetTree->uTreeLength, 4);
+			cpylen =
+				copy_to_user(xplatCall.pDsTreeName, dPtr,
+						pDGetTree->uTreeLength);
 		}
-		kfree(cmd);
+		kfree(reply);
 	}
+	kfree(cmd);
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int NwcSetPreferredDSTree(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	PNwdCSetPreferredDsTree pDSetTree;
-	NwcSetPreferredDsTree xplatCall;
+int novfs_set_preferred_DS_tree(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwd_set_pref_ds_tree *pDSetTree;
+	struct nwc_set_pref_ds_tree xplatCall;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 	unsigned char *dPtr;
 
 	cpylen =
 	    copy_from_user(&xplatCall, pdata->reqData,
-			   sizeof(NwcSetPreferredDsTree));
+			   sizeof(struct nwc_set_pref_ds_tree));
 	datalen = sizeof(*pDSetTree) + xplatCall.uTreeLength;
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_SET_PREFERRED_DS_TREE;
-
-		pDSetTree = (PNwdCSetPreferredDsTree) cmd->data;
-		pDSetTree->DsTreeNameOffset = sizeof(*pDSetTree);
-		pDSetTree->uTreeLength = xplatCall.uTreeLength;
+	if (!cmd)
+		return -ENOMEM;
 
-		dPtr = cmd->data + sizeof(*pDSetTree);
-		cpylen =
-		    copy_from_user(dPtr, xplatCall.pDsTreeName,
-				   xplatCall.uTreeLength);
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_SET_PREFERRED_DS_TREE;
 
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	pDSetTree = (struct nwd_set_pref_ds_tree *) cmd->data;
+	pDSetTree->DsTreeNameOffset = sizeof(*pDSetTree);
+	pDSetTree->uTreeLength = xplatCall.uTreeLength;
+
+	dPtr = cmd->data + sizeof(*pDSetTree);
+	cpylen =
+		copy_from_user(dPtr, xplatCall.pDsTreeName,
+				xplatCall.uTreeLength);
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
+	kfree(cmd);
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int NwcSetDefaultNameCtx(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcSetDefaultNameContext xplatCall;
-	PNwdCSetDefaultNameContext pDSet;
+int novfs_set_default_ctx(struct novfs_xplat *pdata,
+		struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_set_def_name_ctx xplatCall;
+	struct nwd_set_def_name_ctx * pDSet;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, datalen, replylen, cpylen;
 	unsigned char *dPtr;
 
 	cpylen =
 	    copy_from_user(&xplatCall, pdata->reqData,
-			   sizeof(NwcSetDefaultNameContext));
+			   sizeof(struct nwc_set_def_name_ctx));
 	datalen =
 	    sizeof(*pDSet) + xplatCall.uTreeLength + xplatCall.uNameLength;
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_SET_DEFAULT_NAME_CONTEXT;
-		cmd->dataLen =
-		    sizeof(NwdCSetDefaultNameContext) + xplatCall.uTreeLength +
-		    xplatCall.uNameLength;
-
-		pDSet = (PNwdCSetDefaultNameContext) cmd->data;
-		dPtr = cmd->data;
-
-		pDSet->TreeOffset = sizeof(NwdCSetDefaultNameContext);
-		pDSet->uTreeLength = xplatCall.uTreeLength;
-		pDSet->NameContextOffset =
-		    pDSet->TreeOffset + xplatCall.uTreeLength;
-		pDSet->uNameLength = xplatCall.uNameLength;
+	if (!cmd)
+		return -ENOMEM;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_SET_DEFAULT_NAME_CONTEXT;
+	cmd->dataLen =
+		sizeof(struct nwd_set_def_name_ctx) +
+		xplatCall.uTreeLength + xplatCall.uNameLength;
+
+	pDSet = (struct nwd_set_def_name_ctx *) cmd->data;
+	dPtr = cmd->data;
+
+	pDSet->TreeOffset = sizeof(struct nwd_set_def_name_ctx);
+	pDSet->uTreeLength = xplatCall.uTreeLength;
+	pDSet->NameContextOffset =
+		pDSet->TreeOffset + xplatCall.uTreeLength;
+	pDSet->uNameLength = xplatCall.uNameLength;
 
-//sgled      cpylen = copy_from_user(dPtr+pDSet->TreeOffset, xplatCall.pTreeName, xplatCall.uTreeLength);
-		cpylen = copy_from_user(dPtr + pDSet->TreeOffset, xplatCall.pDsTreeName, xplatCall.uTreeLength);	//sgled
-		cpylen =
-		    copy_from_user(dPtr + pDSet->NameContextOffset,
-				   xplatCall.pNameContext,
-				   xplatCall.uNameLength);
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	//sgled      cpylen = copy_from_user(dPtr+pDSet->TreeOffset, xplatCall.pTreeName, xplatCall.uTreeLength);
+	cpylen = copy_from_user(dPtr + pDSet->TreeOffset, xplatCall.pDsTreeName, xplatCall.uTreeLength);	//sgled
+	cpylen =
+		copy_from_user(dPtr + pDSet->NameContextOffset,
+				xplatCall.pNameContext,
+				xplatCall.uNameLength);
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
+	kfree(cmd);
 	return (retCode);
 
 }
 
-/*++======================================================================*/
-int NwcGetDefaultNameCtx(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcGetDefaultNameContext xplatCall;
-	PNwdCGetDefaultNameContext pGet;
+int novfs_get_default_ctx(struct novfs_xplat *pdata,
+		struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_get_def_name_ctx xplatCall;
+	struct nwd_get_def_name_ctx * pGet;
 	char *dPtr;
 	int retCode = -ENOMEM;
 	unsigned long cmdlen, replylen, cpylen;
 
 	cpylen =
 	    copy_from_user(&xplatCall, pdata->reqData,
-			   sizeof(NwcGetDefaultNameContext));
+			   sizeof(struct nwc_get_def_name_ctx));
 	cmdlen =
-	    sizeof(*cmd) + sizeof(NwdCGetDefaultNameContext) +
+	    sizeof(*cmd) + sizeof(struct nwd_get_def_name_ctx ) +
 	    xplatCall.uTreeLength;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_GET_DEFAULT_NAME_CONTEXT;
-		cmd->dataLen =
-		    sizeof(NwdCGetDefaultNameContext) + xplatCall.uTreeLength;
-
-		pGet = (PNwdCGetDefaultNameContext) cmd->data;
-		dPtr = cmd->data;
-
-		pGet->TreeOffset = sizeof(NwdCGetDefaultNameContext);
-		pGet->uTreeLength = xplatCall.uTreeLength;
-
-//sgled      cpylen = copy_from_user( dPtr + pGet->TreeOffset, xplatCall.pTreeName, xplatCall.uTreeLength);
-		cpylen = copy_from_user(dPtr + pGet->TreeOffset, xplatCall.pDsTreeName, xplatCall.uTreeLength);	//sgled
-		dPtr[pGet->TreeOffset + pGet->uTreeLength] = 0;
-
-		retCode =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			retCode = reply->Reply.ErrorCode;
-			if (!retCode) {
-				pGet = (PNwdCGetDefaultNameContext) reply->data;
-
-				DbgPrint
-				    ("NwcGetDefaultNameCtx: retCode=0x%x uNameLength1=%d uNameLength2=%d\n",
-				     retCode, pGet->uNameLength,
-				     xplatCall.uNameLength);
-				if (xplatCall.uNameLength < pGet->uNameLength) {
-					pGet->uNameLength =
-					    xplatCall.uNameLength;
-					retCode = NWE_BUFFER_OVERFLOW;
-				}
-				dPtr = (char *)pGet + pGet->NameContextOffset;
-				cpylen =
-				    copy_to_user(xplatCall.pNameContext, dPtr,
-						 pGet->uNameLength);
-			}
+	if (!cmd)
+		return -ENOMEM;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_GET_DEFAULT_NAME_CONTEXT;
+	cmd->dataLen =
+		sizeof(struct nwd_get_def_name_ctx) + xplatCall.uTreeLength;
+
+	pGet = (struct nwd_get_def_name_ctx *) cmd->data;
+	dPtr = cmd->data;
+
+	pGet->TreeOffset = sizeof(struct nwd_get_def_name_ctx );
+	pGet->uTreeLength = xplatCall.uTreeLength;
+
+	//sgled      cpylen = copy_from_user( dPtr + pGet->TreeOffset, xplatCall.pTreeName, xplatCall.uTreeLength);
+	cpylen = copy_from_user(dPtr + pGet->TreeOffset, xplatCall.pDsTreeName, xplatCall.uTreeLength);	//sgled
+	dPtr[pGet->TreeOffset + pGet->uTreeLength] = 0;
+
+	retCode =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		retCode = reply->Reply.ErrorCode;
+		if (!retCode) {
+			pGet = (struct nwd_get_def_name_ctx *) reply->data;
 
-			kfree(reply);
+			DbgPrint
+				("NwcGetDefaultNameCtx: retCode=0x%x uNameLength1=%d uNameLength2=%d\n",
+				 retCode, pGet->uNameLength,
+				 xplatCall.uNameLength);
+			if (xplatCall.uNameLength < pGet->uNameLength) {
+				pGet->uNameLength =
+					xplatCall.uNameLength;
+				retCode = NWE_BUFFER_OVERFLOW;
+			}
+			dPtr = (char *)pGet + pGet->NameContextOffset;
+			cpylen =
+				copy_to_user(xplatCall.pNameContext, dPtr,
+						pGet->uNameLength);
 		}
-		kfree(cmd);
+
+		kfree(reply);
 	}
+	kfree(cmd);
 	return (retCode);
 
 }
 
-int NwQueryFeature(PXPLAT pdata, session_t Session)
+int novfs_query_feature(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
-	NwcQueryFeature xpCall;
+	struct nwc_query_feature xpCall;
 	int status = 0;
 	unsigned long cpylen;
 
 	cpylen =
-	    copy_from_user(&xpCall, pdata->reqData, sizeof(NwcQueryFeature));
+	    copy_from_user(&xpCall, pdata->reqData, sizeof(struct nwc_query_feature));
 	switch (xpCall.Feature) {
 	case NWC_FEAT_NDS:
 	case NWC_FEAT_NDS_MTREE:
@@ -1725,372 +1515,306 @@ int NwQueryFeature(PXPLAT pdata, session
 	return (status);
 }
 
-/*++======================================================================*/
-int NwcGetTreeMonitoredConn(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcGetTreeMonitoredConnRef xplatCall, *p;
-	PNwdCGetTreeMonitoredConnRef pDConnRef;
+int novfs_get_tree_monitored_conn(struct novfs_xplat *pdata,
+		struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_get_tree_monitored_conn_ref xplatCall, *p;
+	struct nwd_get_tree_monitored_conn_ref *pDConnRef;
 	char *dPtr;
 	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
 
 	cpylen =
 	    copy_from_user(&xplatCall, pdata->reqData,
-			   sizeof(NwcGetTreeMonitoredConnRef));
+			   sizeof(struct nwc_get_tree_monitored_conn_ref));
 	datalen = sizeof(*pDConnRef) + xplatCall.pTreeName->DataLen;
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_GET_TREE_MONITORED_CONN_REF;
-
-		pDConnRef = (PNwdCGetTreeMonitoredConnRef) cmd->data;
-		pDConnRef->TreeName.boffset = sizeof(*pDConnRef);
-		pDConnRef->TreeName.len = xplatCall.pTreeName->DataLen;
-		pDConnRef->TreeName.type = xplatCall.pTreeName->DataType;
+	if (!cmd)
+		return -ENOMEM;
 
-		dPtr = cmd->data + sizeof(*pDConnRef);
-		cpylen =
-		    copy_from_user(dPtr, xplatCall.pTreeName->pBuffer,
-				   pDConnRef->TreeName.len);
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			pDConnRef = (PNwdCGetTreeMonitoredConnRef) reply->data;
-			dPtr = reply->data + pDConnRef->TreeName.boffset;
-			p = (NwcGetTreeMonitoredConnRef *) pdata->reqData;
-			cpylen =
-			    copy_to_user(&p->uConnReference,
-					 &pDConnRef->uConnReference, 4);
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_GET_TREE_MONITORED_CONN_REF;
 
-			status = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	pDConnRef = (struct nwd_get_tree_monitored_conn_ref *) cmd->data;
+	pDConnRef->TreeName.boffset = sizeof(*pDConnRef);
+	pDConnRef->TreeName.len = xplatCall.pTreeName->DataLen;
+	pDConnRef->TreeName.type = xplatCall.pTreeName->DataType;
 
-	}
+	dPtr = cmd->data + sizeof(*pDConnRef);
+	cpylen =
+		copy_from_user(dPtr, xplatCall.pTreeName->pBuffer,
+				pDConnRef->TreeName.len);
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		pDConnRef = (struct nwd_get_tree_monitored_conn_ref *) reply->data;
+		dPtr = reply->data + pDConnRef->TreeName.boffset;
+		p = (struct nwc_get_tree_monitored_conn_ref *) pdata->reqData;
+		cpylen =
+			copy_to_user(&p->uConnReference,
+					&pDConnRef->uConnReference, 4);
 
+		status = reply->Reply.ErrorCode;
+		kfree(reply);
+	}
+	kfree(cmd);
 	return (status);
 }
 
-/*++======================================================================*/
-int NwcEnumIdentities(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract:
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcEnumerateIdentities xplatCall, *eId;
-	PNwdCEnumerateIdentities pEnum;
-	NwcString xferStr;
+int novfs_enum_ids(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_enum_ids xplatCall, *eId;
+	struct nwd_enum_ids *pEnum;
+	struct nwc_string xferStr;
 	char *str;
 	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
 
 	cpylen =
 	    copy_from_user(&xplatCall, pdata->reqData,
-			   sizeof(NwcEnumerateIdentities));
+			   sizeof(struct nwc_enum_ids));
 	datalen = sizeof(*pEnum);
 	cmdlen = datalen + sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_ENUMERATE_IDENTITIES;
-
-		DbgPrint("NwcEnumIdentities: Send Request\n");
-		DbgPrint("   iterator = %x\n", xplatCall.Iterator);
-		DbgPrint("   cmdlen = %d\n", cmdlen);
-
-		pEnum = (PNwdCEnumerateIdentities) cmd->data;
-		pEnum->Iterator = xplatCall.Iterator;
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			status = reply->Reply.ErrorCode;
-
-			eId = pdata->repData;
-			pEnum = (PNwdCEnumerateIdentities) reply->data;
-			cpylen =
-			    copy_to_user(&eId->Iterator, &pEnum->Iterator,
-					 sizeof(pEnum->Iterator));
-			DbgPrint("[XPLAT NWCAPI] Found AuthId 0x%X\n",
-				 pEnum->AuthenticationId);
-			cpylen =
-			    copy_to_user(&eId->AuthenticationId,
-					 &pEnum->AuthenticationId,
-					 sizeof(pEnum->AuthenticationId));
-			cpylen =
-			    copy_to_user(&eId->AuthType, &pEnum->AuthType,
-					 sizeof(pEnum->AuthType));
-			cpylen =
-			    copy_to_user(&eId->IdentityFlags,
-					 &pEnum->IdentityFlags,
-					 sizeof(pEnum->IdentityFlags));
-			cpylen =
-			    copy_to_user(&eId->NameType, &pEnum->NameType,
-					 sizeof(pEnum->NameType));
-			cpylen =
-			    copy_to_user(&eId->ObjectType, &pEnum->ObjectType,
-					 sizeof(pEnum->ObjectType));
-
-			if (!status) {
-				cpylen =
-				    copy_from_user(&xferStr, eId->pDomainName,
-						   sizeof(NwcString));
-				str =
-				    (char *)((char *)reply->data +
-					     pEnum->domainNameOffset);
-				DbgPrint("[XPLAT NWCAPI] Found Domain %s\n",
-					 str);
-				cpylen =
-				    copy_to_user(xferStr.pBuffer, str,
-						 pEnum->domainNameLen);
-				xferStr.DataType = NWC_STRING_TYPE_ASCII;
-				xferStr.DataLen = pEnum->domainNameLen - 1;
-				cpylen =
-				    copy_to_user(eId->pDomainName, &xferStr,
-						 sizeof(NwcString));
-
-				cpylen =
-				    copy_from_user(&xferStr, eId->pObjectName,
-						   sizeof(NwcString));
-				str =
-				    (char *)((char *)reply->data +
-					     pEnum->objectNameOffset);
-				DbgPrint("[XPLAT NWCAPI] Found User %s\n", str);
-				cpylen =
-				    copy_to_user(xferStr.pBuffer, str,
-						 pEnum->objectNameLen);
-				xferStr.DataType = NWC_STRING_TYPE_ASCII;
-				xferStr.DataLen = pEnum->objectNameLen - 1;
-				cpylen =
-				    copy_to_user(eId->pObjectName, &xferStr,
-						 sizeof(NwcString));
-			}
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_ENUMERATE_IDENTITIES;
+
+	DbgPrint("NwcEnumIdentities: Send Request\n");
+	DbgPrint("   iterator = %x\n", xplatCall.Iterator);
+	DbgPrint("   cmdlen = %d\n", cmdlen);
 
-			kfree(reply);
+	pEnum = (struct nwd_enum_ids *) cmd->data;
+	pEnum->Iterator = xplatCall.Iterator;
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		status = reply->Reply.ErrorCode;
 
+		eId = pdata->repData;
+		pEnum = (struct nwd_enum_ids *) reply->data;
+		cpylen =
+			copy_to_user(&eId->Iterator, &pEnum->Iterator,
+					sizeof(pEnum->Iterator));
+		DbgPrint("[XPLAT NWCAPI] Found AuthId 0x%X\n",
+				pEnum->AuthenticationId);
+		cpylen =
+			copy_to_user(&eId->AuthenticationId,
+					&pEnum->AuthenticationId,
+					sizeof(pEnum->AuthenticationId));
+		cpylen =
+			copy_to_user(&eId->AuthType, &pEnum->AuthType,
+					sizeof(pEnum->AuthType));
+		cpylen =
+			copy_to_user(&eId->IdentityFlags,
+					&pEnum->IdentityFlags,
+					sizeof(pEnum->IdentityFlags));
+		cpylen =
+			copy_to_user(&eId->NameType, &pEnum->NameType,
+					sizeof(pEnum->NameType));
+		cpylen =
+			copy_to_user(&eId->ObjectType, &pEnum->ObjectType,
+					sizeof(pEnum->ObjectType));
+
+		if (!status) {
+			cpylen =
+				copy_from_user(&xferStr, eId->pDomainName,
+						sizeof(struct nwc_string));
+			str =
+				(char *)((char *)reply->data +
+						pEnum->domainNameOffset);
+			DbgPrint("[XPLAT NWCAPI] Found Domain %s\n",
+					str);
+			cpylen =
+				copy_to_user(xferStr.pBuffer, str,
+						pEnum->domainNameLen);
+			xferStr.DataType = NWC_STRING_TYPE_ASCII;
+			xferStr.DataLen = pEnum->domainNameLen - 1;
+			cpylen =
+				copy_to_user(eId->pDomainName, &xferStr,
+						sizeof(struct nwc_string));
+
+			cpylen =
+				copy_from_user(&xferStr, eId->pObjectName,
+						sizeof(struct nwc_string));
+			str =
+				(char *)((char *)reply->data +
+						pEnum->objectNameOffset);
+			DbgPrint("[XPLAT NWCAPI] Found User %s\n", str);
+			cpylen =
+				copy_to_user(xferStr.pBuffer, str,
+						pEnum->objectNameLen);
+			xferStr.DataType = NWC_STRING_TYPE_ASCII;
+			xferStr.DataLen = pEnum->objectNameLen - 1;
+			cpylen =
+				copy_to_user(eId->pObjectName, &xferStr,
+						sizeof(struct nwc_string));
 		}
-		kfree(cmd);
+
+		kfree(reply);
 
 	}
+	kfree(cmd);
 	return (status);
 }
 
-/*++======================================================================*/
-int NwcChangeAuthKey(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract: Change the password on the server
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcChangeKey xplatCall;
-	PNwdCChangeKey pNewKey;
-	NwcString xferStr;
+int novfs_change_auth_key(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_change_key xplatCall;
+	struct nwd_change_key *pNewKey;
+	struct nwc_string xferStr;
 	char *str;
 	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
 
 	cpylen =
-	    copy_from_user(&xplatCall, pdata->reqData, sizeof(NwcChangeKey));
+	    copy_from_user(&xplatCall, pdata->reqData, sizeof(struct nwc_change_key));
 
 	datalen =
-	    sizeof(NwdCChangeKey) + xplatCall.pDomainName->DataLen +
+	    sizeof(struct nwd_change_key) + xplatCall.pDomainName->DataLen +
 	    xplatCall.pObjectName->DataLen + xplatCall.pNewPassword->DataLen +
 	    xplatCall.pVerifyPassword->DataLen;
 
 	cmdlen = sizeof(*cmd) + datalen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		pNewKey = (PNwdCChangeKey) cmd->data;
-		cmd->dataLen = datalen;
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_CHANGE_KEY;
-
-		pNewKey->NameType = xplatCall.NameType;
-		pNewKey->ObjectType = xplatCall.ObjectType;
-		pNewKey->AuthType = xplatCall.AuthType;
-		str = (char *)pNewKey;
+	if (!cmd)
+		return -ENOMEM;
 
-		/*
-		 * Get the tree name
-		 */
-		str += sizeof(*pNewKey);
-		cpylen =
-		    copy_from_user(&xferStr, xplatCall.pDomainName,
-				   sizeof(NwcString));
-		pNewKey->domainNameOffset = sizeof(*pNewKey);
-		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
-		pNewKey->domainNameLen = xferStr.DataLen;
+	pNewKey = (struct nwd_change_key *) cmd->data;
+	cmd->dataLen = datalen;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_CHANGE_KEY;
 
-		/*
-		 * Get the User Name
-		 */
-		str += pNewKey->domainNameLen;
-		cpylen =
-		    copy_from_user(&xferStr, xplatCall.pObjectName,
-				   sizeof(NwcString));
-		pNewKey->objectNameOffset =
-		    pNewKey->domainNameOffset + pNewKey->domainNameLen;
-		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
-		pNewKey->objectNameLen = xferStr.DataLen;
+	pNewKey->NameType = xplatCall.NameType;
+	pNewKey->ObjectType = xplatCall.ObjectType;
+	pNewKey->AuthType = xplatCall.AuthType;
+	str = (char *)pNewKey;
 
-		/*
-		 * Get the New Password
-		 */
-		str += pNewKey->objectNameLen;
-		cpylen =
-		    copy_from_user(&xferStr, xplatCall.pNewPassword,
-				   sizeof(NwcString));
-		pNewKey->newPasswordOffset =
-		    pNewKey->objectNameOffset + pNewKey->objectNameLen;
-		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
-		pNewKey->newPasswordLen = xferStr.DataLen;
+	/*
+	 * Get the tree name
+	 */
+	str += sizeof(*pNewKey);
+	cpylen =
+		copy_from_user(&xferStr, xplatCall.pDomainName,
+				sizeof(struct nwc_string));
+	pNewKey->domainNameOffset = sizeof(*pNewKey);
+	cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+	pNewKey->domainNameLen = xferStr.DataLen;
 
-		/*
-		 * Get the Verify Password
-		 */
-		str += pNewKey->newPasswordLen;
-		cpylen =
-		    copy_from_user(&xferStr, xplatCall.pVerifyPassword,
-				   sizeof(NwcString));
-		pNewKey->verifyPasswordOffset =
-		    pNewKey->newPasswordOffset + pNewKey->newPasswordLen;
-		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
-		pNewKey->verifyPasswordLen = xferStr.DataLen;
-
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			status = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		memset(cmd, 0, cmdlen);
+	/*
+	 * Get the User Name
+	 */
+	str += pNewKey->domainNameLen;
+	cpylen =
+		copy_from_user(&xferStr, xplatCall.pObjectName,
+				sizeof(struct nwc_string));
+	pNewKey->objectNameOffset =
+		pNewKey->domainNameOffset + pNewKey->domainNameLen;
+	cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+	pNewKey->objectNameLen = xferStr.DataLen;
 
-		kfree(cmd);
+	/*
+	 * Get the New Password
+	 */
+	str += pNewKey->objectNameLen;
+	cpylen =
+		copy_from_user(&xferStr, xplatCall.pNewPassword,
+				sizeof(struct nwc_string));
+	pNewKey->newPasswordOffset =
+		pNewKey->objectNameOffset + pNewKey->objectNameLen;
+	cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+	pNewKey->newPasswordLen = xferStr.DataLen;
+
+	/*
+	 * Get the Verify Password
+	 */
+	str += pNewKey->newPasswordLen;
+	cpylen =
+		copy_from_user(&xferStr, xplatCall.pVerifyPassword,
+				sizeof(struct nwc_string));
+	pNewKey->verifyPasswordOffset =
+		pNewKey->newPasswordOffset + pNewKey->newPasswordLen;
+	cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+	pNewKey->verifyPasswordLen = xferStr.DataLen;
+
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		status = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
+	memset(cmd, 0, cmdlen);
 
+	kfree(cmd);
 	return (status);
 }
 
-/*++======================================================================*/
-int NwcSetPrimaryConn(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract: Set the primary connection Id
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcSetPrimaryConnection xplatCall;
-	PNwdCSetPrimaryConnection pConn;
+int novfs_set_pri_conn(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_set_primary_conn xplatCall;
+	struct nwd_set_primary_conn *pConn;
 	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
 
 	cpylen =
 	    copy_from_user(&xplatCall, pdata->reqData,
-			   sizeof(NwcSetPrimaryConnection));
+			   sizeof(struct nwc_set_primary_conn));
 
-	datalen = sizeof(NwdCSetPrimaryConnection);
+	datalen = sizeof(struct nwd_set_primary_conn);
 	cmdlen = sizeof(*cmd) + datalen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
-	if (cmd) {
-		pConn = (PNwdCSetPrimaryConnection) cmd->data;
-		cmd->dataLen = datalen;
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_SET_PRIMARY_CONN;
-		pConn->ConnHandle = (HANDLE) (unsigned long) xplatCall.ConnHandle;
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-
-		if (reply) {
-			status = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
 
-		kfree(cmd);
-	}
+	pConn = (struct nwd_set_primary_conn *) cmd->data;
+	cmd->dataLen = datalen;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_SET_PRIMARY_CONN;
+	pConn->ConnHandle = (void *) (unsigned long) xplatCall.ConnHandle;
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
 
+	if (reply) {
+		status = reply->Reply.ErrorCode;
+		kfree(reply);
+	}
+	kfree(cmd);
 	return (status);
 }
 
-/*++======================================================================*/
-int NwcGetPrimaryConn(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract: Get the Primary connection
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_get_pri_conn(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
-	XPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
+	struct novfs_xplat_call_request cmd;
+	struct novfs_xplat_call_reply *reply;
 	unsigned long status = -ENOMEM, cmdlen, replylen, cpylen;
 
-	cmdlen = (unsigned long) (&((PXPLAT_CALL_REQUEST) 0)->data);
+	cmdlen = (unsigned long) (&((struct novfs_xplat_call_request *) 0)->data);
 
 	cmd.dataLen = 0;
 	cmd.Command.CommandType = VFS_COMMAND_XPLAT_CALL;
@@ -2099,15 +1823,15 @@ int NwcGetPrimaryConn(PXPLAT pdata, sess
 	cmd.NwcCommand = NWC_GET_PRIMARY_CONN;
 
 	status =
-	    Queue_Daemon_Command((void *)&cmd, cmdlen, NULL, 0, (void **)&reply,
-				 &replylen, INTERRUPTIBLE);
+		Queue_Daemon_Command((void *)&cmd, cmdlen, NULL, 0, (void **)&reply,
+				&replylen, INTERRUPTIBLE);
 
 	if (reply) {
 		status = reply->Reply.ErrorCode;
 		if (!status) {
 			cpylen =
-			    copy_to_user(pdata->repData, reply->data,
-					 sizeof(unsigned long));
+				copy_to_user(pdata->repData, reply->data,
+						sizeof(unsigned long));
 		}
 
 		kfree(reply);
@@ -2116,26 +1840,13 @@ int NwcGetPrimaryConn(PXPLAT pdata, sess
 	return (status);
 }
 
-/*++======================================================================*/
-int NwcSetMapDrive(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract: Get the Primary connection
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_set_map_drive(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
 
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
 	unsigned long status = 0, datalen, cmdlen, replylen, cpylen;
-	NwcMapDriveEx symInfo;
+	struct nwc_map_drive_ex symInfo;
 
 	DbgPrint("Call to NwcSetMapDrive\n");
 	cpylen = copy_from_user(&symInfo, pdata->reqData, sizeof(symInfo));
@@ -2151,53 +1862,41 @@ int NwcSetMapDrive(PXPLAT pdata, session
 	DbgPrint(" symInfo.linkOffsetLength = %d\n", symInfo.linkOffsetLength);
 	DbgPrint(" pdata->datalen = %d\n", pdata->reqLen);
 
-	mydump(sizeof(symInfo), &symInfo);
+	novfs_dump(sizeof(symInfo), &symInfo);
 
 	cmdlen += datalen;
 
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
-	if (cmd) {
-		cmd->dataLen = datalen;
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_MAP_DRIVE;
-
-		cpylen = copy_from_user(cmd->data, pdata->reqData, datalen);
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-
-		if (reply) {
-			status = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->dataLen = datalen;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_MAP_DRIVE;
+
+	cpylen = copy_from_user(cmd->data, pdata->reqData, datalen);
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+
+	if (reply) {
+		status = reply->Reply.ErrorCode;
+		kfree(reply);
 	}
+	kfree(cmd);
 	return (status);
 
 }
 
-/*++======================================================================*/
-int NwcUnMapDrive(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract: Get the Primary connection
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_unmap_drive(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
 	unsigned long status = 0, datalen, cmdlen, replylen, cpylen;
-	NwcUnmapDriveEx symInfo;
+	struct nwc_unmap_drive_ex symInfo;
 
 	DbgPrint("Call to NwcUnMapDrive\n");
 
@@ -2206,47 +1905,34 @@ int NwcUnMapDrive(PXPLAT pdata, session_
 	datalen = sizeof(symInfo) + symInfo.linkLen;
 
 	cmdlen += datalen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
-	if (cmd) {
-		cmd->dataLen = datalen;
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_UNMAP_DRIVE;
-
-		cpylen = copy_from_user(cmd->data, pdata->reqData, datalen);
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-
-		if (reply) {
-			status = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		kfree(cmd);
-	}
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->dataLen = datalen;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_UNMAP_DRIVE;
+
+	cpylen = copy_from_user(cmd->data, pdata->reqData, datalen);
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
 
+	if (reply) {
+		status = reply->Reply.ErrorCode;
+		kfree(reply);
+	}
+	kfree(cmd);
 	return (status);
 }
 
-/*++======================================================================*/
-int NwcEnumerateDrives(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract: Get the Primary connection
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_enum_drives(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
 	unsigned long status = 0, cmdlen, replylen, cpylen;
 	unsigned long offset;
 	char *cp;
@@ -2254,284 +1940,266 @@ int NwcEnumerateDrives(PXPLAT pdata, ses
 	DbgPrint("Call to NwcEnumerateDrives\n");
 
 	cmdlen = sizeof(*cmd);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
-	if (cmd) {
-		cmd->dataLen = 0;
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_ENUMERATE_DRIVES;
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-
-		if (reply) {
-			status = reply->Reply.ErrorCode;
-			DbgPrint("Status Code = 0x%X\n", status);
-			if (!status) {
-				offset =
-				    sizeof(((PNwcGetMappedDrives) pdata->
-					    repData)->MapBuffLen);
-				cp = reply->data;
-				replylen =
-				    ((PNwcGetMappedDrives) pdata->repData)->
-				    MapBuffLen;
-				cpylen =
-				    copy_to_user(pdata->repData, cp, offset);
-				cp += offset;
-				cpylen =
-				    copy_to_user(((PNwcGetMappedDrives) pdata->
-						  repData)->MapBuffer, cp,
-						 min(replylen - offset,
-						     reply->dataLen - offset));
-			}
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
 
-			kfree(reply);
+	cmd->dataLen = 0;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_ENUMERATE_DRIVES;
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+
+	if (reply) {
+		status = reply->Reply.ErrorCode;
+		DbgPrint("Status Code = 0x%X\n", status);
+		if (!status) {
+			offset =
+				sizeof(((struct nwc_get_mapped_drives *) pdata->
+							repData)->MapBuffLen);
+			cp = reply->data;
+			replylen =
+				((struct nwc_get_mapped_drives *) pdata->repData)->
+				MapBuffLen;
+			cpylen =
+				copy_to_user(pdata->repData, cp, offset);
+			cp += offset;
+			cpylen =
+				copy_to_user(((struct nwc_get_mapped_drives *) pdata->
+							repData)->MapBuffer, cp,
+						min(replylen - offset,
+							reply->dataLen - offset));
 		}
-		kfree(cmd);
-	}
 
+		kfree(reply);
+	}
+	kfree(cmd);
 	return (status);
 }
 
-/*++======================================================================*/
-int NwcGetBroadcastMessage(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract: Get the Primary connection
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+int novfs_get_bcast_msg(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
 	unsigned long cmdlen, replylen;
 	int status = 0x8866, cpylen;
-	NwcGetBroadcastNotification msg;
-	PNwdCGetBroadcastNotification dmsg;
+	struct nwc_get_bcast_notification msg;
+	struct nwd_get_bcast_notification *dmsg;
 
 	cmdlen = sizeof(*cmd) + sizeof(*dmsg);
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
-	if (cmd) {
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
 
-		cpylen = copy_from_user(&msg, pdata->reqData, sizeof(msg));
-		cmd->dataLen = sizeof(*dmsg);
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-
-		cmd->NwcCommand = NWC_GET_BROADCAST_MESSAGE;
-		dmsg = (PNwdCGetBroadcastNotification) cmd->data;
-		dmsg->uConnReference = (HANDLE) (unsigned long) msg.uConnReference;
-
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-
-		if (reply) {
-			status = reply->Reply.ErrorCode;
-
-			if (!status) {
-				char *cp = pdata->repData;
-
-				dmsg =
-				    (PNwdCGetBroadcastNotification) reply->data;
-				if (pdata->repLen < dmsg->messageLen) {
-					dmsg->messageLen = pdata->repLen;
-				}
-				msg.messageLen = dmsg->messageLen;
-				cpylen = offsetof(NwcGetBroadcastNotification, message);
-				cp += cpylen;
-				cpylen = copy_to_user(pdata->repData, &msg, cpylen);
-				cpylen = copy_to_user(cp, dmsg->message, msg.messageLen);
-			} else {
-				msg.messageLen = 0;
-				msg.message[0] = 0;
-				cpylen = offsetof(NwcGetBroadcastNotification, message);
-				cpylen = copy_to_user(pdata->repData, &msg, sizeof(msg));
-			}
+	cpylen = copy_from_user(&msg, pdata->reqData, sizeof(msg));
+	cmd->dataLen = sizeof(*dmsg);
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+
+	cmd->NwcCommand = NWC_GET_BROADCAST_MESSAGE;
+	dmsg = (struct nwd_get_bcast_notification *) cmd->data;
+	dmsg->uConnReference = (void *) (unsigned long) msg.uConnReference;
+
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+
+	if (reply) {
+		status = reply->Reply.ErrorCode;
 
-			kfree(reply);
+		if (!status) {
+			char *cp = pdata->repData;
+
+			dmsg =
+				(struct nwd_get_bcast_notification *) reply->data;
+			if (pdata->repLen < dmsg->messageLen) {
+				dmsg->messageLen = pdata->repLen;
+			}
+			msg.messageLen = dmsg->messageLen;
+			cpylen =
+				offsetof(struct
+						nwc_get_bcast_notification,
+						message);
+			cp += cpylen;
+			cpylen =
+				copy_to_user(pdata->repData, &msg, cpylen);
+			cpylen =
+				copy_to_user(cp, dmsg->message,
+						msg.messageLen);
+		} else {
+			msg.messageLen = 0;
+			msg.message[0] = 0;
+			cpylen = offsetof(struct
+					nwc_get_bcast_notification,
+					message);
+			cpylen =
+				copy_to_user(pdata->repData, &msg,
+						sizeof(msg));
 		}
-		kfree(cmd);
+
+		kfree(reply);
 	}
+	kfree(cmd);
 	return (status);
 }
 
-int NwdSetKeyValue(PXPLAT pdata, session_t Session)
+int novfs_set_key_value(struct novfs_xplat *pdata, struct novfs_schandle Session)
 {
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcSetKey xplatCall;
-	PNwdCSetKey pNewKey;
-	NwcString cstrObjectName, cstrPassword;
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_set_key xplatCall;
+	struct nwd_set_key *pNewKey;
+	struct nwc_string cstrObjectName, cstrPassword;
 	char *str;
 	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
 
-	cpylen = copy_from_user(&xplatCall, pdata->reqData, sizeof(NwcSetKey));
+	cpylen = copy_from_user(&xplatCall, pdata->reqData, sizeof(struct nwc_set_key));
 	cpylen =
 	    copy_from_user(&cstrObjectName, xplatCall.pObjectName,
-			   sizeof(NwcString));
+			   sizeof(struct nwc_string));
 	cpylen =
 	    copy_from_user(&cstrPassword, xplatCall.pNewPassword,
-			   sizeof(NwcString));
+			   sizeof(struct nwc_string));
 
 	datalen =
-	    sizeof(NwdCSetKey) + cstrObjectName.DataLen + cstrPassword.DataLen;
+	    sizeof(struct nwd_set_key ) + cstrObjectName.DataLen + cstrPassword.DataLen;
 
 	cmdlen = sizeof(*cmd) + datalen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		pNewKey = (PNwdCSetKey) cmd->data;
-		cmd->dataLen = datalen;
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_SET_KEY;
-
-		pNewKey->ObjectType = xplatCall.ObjectType;
-		pNewKey->AuthenticationId = xplatCall.AuthenticationId;
-		pNewKey->ConnHandle = (HANDLE) (unsigned long) xplatCall.ConnHandle;
-		str = (char *)pNewKey;
+	if (!cmd)
+		return -ENOMEM;
 
-		/*
-		 * Get the User Name
-		 */
-		str += sizeof(NwdCSetKey);
-		cpylen =
-		    copy_from_user(str, cstrObjectName.pBuffer,
-				   cstrObjectName.DataLen);
+	pNewKey = (struct nwd_set_key *) cmd->data;
+	cmd->dataLen = datalen;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_SET_KEY;
 
-		str += pNewKey->objectNameLen = cstrObjectName.DataLen;
-		pNewKey->objectNameOffset = sizeof(NwdCSetKey);
+	pNewKey->ObjectType = xplatCall.ObjectType;
+	pNewKey->AuthenticationId = xplatCall.AuthenticationId;
+	pNewKey->ConnHandle = (void *) (unsigned long) xplatCall.ConnHandle;
+	str = (char *)pNewKey;
 
-		/*
-		 * Get the Verify Password
-		 */
-		cpylen =
-		    copy_from_user(str, cstrPassword.pBuffer,
-				   cstrPassword.DataLen);
+	/*
+	 * Get the User Name
+	 */
+	str += sizeof(struct nwd_set_key );
+	cpylen =
+		copy_from_user(str, cstrObjectName.pBuffer,
+				cstrObjectName.DataLen);
 
-		pNewKey->newPasswordLen = cstrPassword.DataLen;
-		pNewKey->newPasswordOffset =
-		    pNewKey->objectNameOffset + pNewKey->objectNameLen;
-
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			status = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		memset(cmd, 0, cmdlen);
-		kfree(cmd);
-	}
+	str += pNewKey->objectNameLen = cstrObjectName.DataLen;
+	pNewKey->objectNameOffset = sizeof(struct nwd_set_key );
+
+	/*
+	 * Get the Verify Password
+	 */
+	cpylen =
+		copy_from_user(str, cstrPassword.pBuffer,
+				cstrPassword.DataLen);
 
+	pNewKey->newPasswordLen = cstrPassword.DataLen;
+	pNewKey->newPasswordOffset =
+		pNewKey->objectNameOffset + pNewKey->objectNameLen;
+
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		status = reply->Reply.ErrorCode;
+		kfree(reply);
+	}
+	kfree(cmd);
 	return (status);
 }
 
-/*++======================================================================*/
-int NwdVerifyKeyValue(PXPLAT pdata, session_t Session)
-/*
- *  Arguments:
- *
- *  Returns:
- *
- *  Abstract: Change the password on the server
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
-{
-	PXPLAT_CALL_REQUEST cmd;
-	PXPLAT_CALL_REPLY reply;
-	NwcVerifyKey xplatCall;
-	PNwdCVerifyKey pNewKey;
-	NwcString xferStr;
+int novfs_verify_key_value(struct novfs_xplat *pdata, struct novfs_schandle Session)
+{
+	struct novfs_xplat_call_request *cmd;
+	struct novfs_xplat_call_reply *reply;
+	struct nwc_verify_key xplatCall;
+	struct nwd_verify_key *pNewKey;
+	struct nwc_string xferStr;
 	char *str;
 	unsigned long status = -ENOMEM, cmdlen, datalen, replylen, cpylen;
 
 	cpylen =
-	    copy_from_user(&xplatCall, pdata->reqData, sizeof(NwcVerifyKey));
+	    copy_from_user(&xplatCall, pdata->reqData, sizeof(struct nwc_verify_key));
 
 	datalen =
-	    sizeof(NwdCVerifyKey) + xplatCall.pDomainName->DataLen +
+	    sizeof(struct nwd_verify_key) + xplatCall.pDomainName->DataLen +
 	    xplatCall.pObjectName->DataLen + xplatCall.pVerifyPassword->DataLen;
 
 	cmdlen = sizeof(*cmd) + datalen;
-	cmd = Novfs_Malloc(cmdlen, GFP_KERNEL);
+	cmd = (struct novfs_xplat_call_request *)kmalloc(cmdlen, GFP_KERNEL);
 
-	if (cmd) {
-		pNewKey = (PNwdCVerifyKey) cmd->data;
-		cmd->dataLen = datalen;
-		cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
-		cmd->Command.SequenceNumber = 0;
-		cmd->Command.SessionId = Session;
-		cmd->NwcCommand = NWC_VERIFY_KEY;
-
-		pNewKey->NameType = xplatCall.NameType;
-		pNewKey->ObjectType = xplatCall.ObjectType;
-		pNewKey->AuthType = xplatCall.AuthType;
-		str = (char *)pNewKey;
+	if (!cmd)
+		return -ENOMEM;
 
-		/*
-		 * Get the tree name
-		 */
-		str += sizeof(*pNewKey);
-		cpylen =
-		    copy_from_user(&xferStr, xplatCall.pDomainName,
-				   sizeof(NwcString));
-		pNewKey->domainNameOffset = sizeof(*pNewKey);
-		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
-		pNewKey->domainNameLen = xferStr.DataLen;
+	pNewKey = (struct nwd_verify_key *) cmd->data;
+	cmd->dataLen = datalen;
+	cmd->Command.CommandType = VFS_COMMAND_XPLAT_CALL;
+	cmd->Command.SequenceNumber = 0;
+	cmd->Command.SessionId = Session;
+	cmd->NwcCommand = NWC_VERIFY_KEY;
 
-		/*
-		 * Get the User Name
-		 */
-		str += pNewKey->domainNameLen;
-		cpylen =
-		    copy_from_user(&xferStr, xplatCall.pObjectName,
-				   sizeof(NwcString));
-		pNewKey->objectNameOffset =
-		    pNewKey->domainNameOffset + pNewKey->domainNameLen;
-		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
-		pNewKey->objectNameLen = xferStr.DataLen;
+	pNewKey->NameType = xplatCall.NameType;
+	pNewKey->ObjectType = xplatCall.ObjectType;
+	pNewKey->AuthType = xplatCall.AuthType;
+	str = (char *)pNewKey;
 
-		/*
-		 * Get the Verify Password
-		 */
-		str += pNewKey->objectNameLen;
-		cpylen =
-		    copy_from_user(&xferStr, xplatCall.pVerifyPassword,
-				   sizeof(NwcString));
-		pNewKey->verifyPasswordOffset =
-		    pNewKey->objectNameOffset + pNewKey->objectNameLen;
-		cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
-		pNewKey->verifyPasswordLen = xferStr.DataLen;
-
-		status =
-		    Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
-					 (void **)&reply, &replylen,
-					 INTERRUPTIBLE);
-		if (reply) {
-			status = reply->Reply.ErrorCode;
-			kfree(reply);
-		}
-		memset(cmd, 0, cmdlen);
-		kfree(cmd);
-	}
+	/*
+	 * Get the tree name
+	 */
+	str += sizeof(*pNewKey);
+	cpylen =
+		copy_from_user(&xferStr, xplatCall.pDomainName,
+				sizeof(struct nwc_string));
+	pNewKey->domainNameOffset = sizeof(*pNewKey);
+	cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+	pNewKey->domainNameLen = xferStr.DataLen;
+
+	/*
+	 * Get the User Name
+	 */
+	str += pNewKey->domainNameLen;
+	cpylen =
+		copy_from_user(&xferStr, xplatCall.pObjectName,
+				sizeof(struct nwc_string));
+	pNewKey->objectNameOffset =
+		pNewKey->domainNameOffset + pNewKey->domainNameLen;
+	cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+	pNewKey->objectNameLen = xferStr.DataLen;
+
+	/*
+	 * Get the Verify Password
+	 */
+	str += pNewKey->objectNameLen;
+	cpylen =
+		copy_from_user(&xferStr, xplatCall.pVerifyPassword,
+				sizeof(struct nwc_string));
+	pNewKey->verifyPasswordOffset =
+		pNewKey->objectNameOffset + pNewKey->objectNameLen;
+	cpylen = copy_from_user(str, xferStr.pBuffer, xferStr.DataLen);
+	pNewKey->verifyPasswordLen = xferStr.DataLen;
 
+	status =
+		Queue_Daemon_Command((void *)cmd, cmdlen, NULL, 0,
+				(void **)&reply, &replylen,
+				INTERRUPTIBLE);
+	if (reply) {
+		status = reply->Reply.ErrorCode;
+		kfree(reply);
+	}
+	kfree(cmd);
 	return (status);
 }
--- a/fs/novfs/nwcapi.h
+++ b/fs/novfs/nwcapi.h
@@ -109,14 +109,14 @@
 
 #define IOC_XPLAT    0x4a540002
 
-typedef struct _XPLAT_ {
+struct novfs_xplat {
 	int xfunction;
 	unsigned long reqLen;
 	void *reqData;
 	unsigned long repLen;
 	void *repData;
 
-} XPLAT, *PXPLAT;
+};
 
 #if 0
 N_EXTERN_LIBRARY(NWRCODE)
@@ -326,66 +326,30 @@ N_EXTERN_LIBRARY(NWRCODE)
 
 //===[ Type definitions ]==================================================
 
-//
-// Connection Handle returned from all OpenConnByXXXX calls
-//
-
-typedef u32 NW_CONN_HANDLE, *PNW_CONN_HANDLE;
-
-//
-// Authentication Id returned from the NwcCreateAuthenticationId call
-//
-
-typedef u32 AUTHEN_ID, *PAUTHEN_ID;
 
 //
 // Structure for defining what a transport
 // address looks like
 //
 
-typedef struct tagNwcTranAddr {
+struct nwc_tran_addr {
 	u32 uTransportType;
 	u32 uAddressLength;
 	unsigned char *puAddress;
+};
 
-} NwcTranAddr, *PNwcTranAddr;
-
-//
-// Structure for defining what a new transport
-// address looks like
-//
-
-typedef struct tagNwcTranAddrEx {
-	u32 uTransportType;
-	u32 uAddressLength;
-	unsigned char buBuffer[MAX_ADDRESS_LENGTH];
-
-} NwcTranAddrEx, *PNwcTranAddrEx;
 
-typedef struct tagNwcReferral {
-	u32 uAddrCnt;
-	PNwcTranAddrEx pAddrs;
-
-} NwcReferral, *PNwcReferral;
-
-typedef struct tagNwcServerVersion {
-	u32 uMajorVersion;
-	u16 uMinorVersion;
-	u16 uRevision;
-
-} NwcServerVersion, *PNwcServerVersion;
-
-typedef struct tagNwcConnString {
+struct nwc_conn_string {
 	char *pString;
 	u32 uStringType;
 	u32 uNameFormatType;
 
-} NwcConnString, *PNwcConnString;
+};
 
 //#if defined(NTYPES_H)
 //typedef NWCString    NwcString, *PNwcString;
 //#else
-typedef struct tagNwcString {
+struct nwc_string {
 	u32 DataType;
 	u32 BuffSize;
 	u32 DataLen;
@@ -393,36 +357,18 @@ typedef struct tagNwcString {
 	u32 CodePage;
 	u32 CountryCode;
 
-} NwcString, *PNwcString;
+};
 //#endif
 
 //
-// Structure used in NDS Resolve name
-//
-
-#define  RESOLVE_INFO_SVC_V1_00     0x00FE0001
-
-typedef struct tagNwcResolveInfo {
-	u32 uResolveInfoVersion;
-	u32 luFlags;
-	u32 luReqFlags;
-	u32 luReqScope;
-	u32 luResolveType;
-	u32 luRepFlags;
-	u32 luResolvedOffset;
-	u32 luDerefNameLen;
-	u16 *pDerefName;
-} NwcResolveInfo, *PNwcResolveInfo;
-
-//
 // Definition of a fragment for the Raw NCP requests
 //
 
-typedef struct tagNwcFrag {
+struct nwc_frag {
 	void *pData;
 	u32 uLength;
 
-} NwcFrag, *PNwcFrag;
+};
 
 //
 // Current connection information available for
@@ -432,62 +378,6 @@ typedef struct tagNwcFrag {
 #define NW_INFO_BUFFER_SIZE   NW_MAX_TREE_NAME_LEN + \
                               NW_MAX_TREE_NAME_LEN + \
                               NW_MAX_SERVICE_TYPE_LEN
-
-typedef struct tagNwcConnInfo {
-	u32 uInfoVersion;
-	u32 uAuthenticationState;
-	u32 uBroadcastState;
-	u32 uConnectionReference;
-	u32 TreeNameOffset;
-	u32 uSecurityState;
-	u32 uConnectionNumber;
-	u32 uUserId;
-	u32 ServerNameOffset;
-	u32 uNdsState;
-	u32 uMaxPacketSize;
-	u32 uLicenseState;
-	u32 uPublicState;
-	u32 bcastState;
-	u32 ServiceTypeOffset;
-	u32 uDistance;
-	u32 uAuthId;
-	u32 uDisconnected;
-	NwcServerVersion serverVersion;
-	NwcTranAddrEx tranAddress;
-	unsigned char buBuffer[NW_INFO_BUFFER_SIZE];
-
-} NwcConnInfo, *PNwcConnInfo;
-
-//
-// Get Browse Connection References
-//
-
-typedef struct _GetBrowseConnectionsRec {
-
-	u32 recordSize;
-	u32 numConnectionsReturned;
-	u32 numConnectionsAvailable;
-	u32 connReferences[1];
-
-} GetBrowseConnectionRec, *PGetBrowseConnectionRec;
-
-//++=======================================================================
-//  API Name:        NwcClearBroadcastMessage
-//
-//  Arguments In:    NONE
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         STATUS_SUCCESS
-//
-//  Abstract:        This API is clears the broadcast message buffer.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
 //++=======================================================================
 //  API Name:        NwcCloseConn
 //
@@ -514,10 +404,10 @@ typedef struct _GetBrowseConnectionsRec
 //
 //=======================================================================--
 
-typedef struct tagNwcCloseConn {
-	NW_CONN_HANDLE ConnHandle;
+struct nwc_close_conn {
+	u32 ConnHandle;
 
-} NwcCloseConn, *PNwcCloseConn;
+};
 
 //++=======================================================================
 //  API Name:        NwcConvertLocalFileHandle
@@ -548,11 +438,11 @@ typedef struct tagNwcCloseConn {
 //
 //=======================================================================--
 
-typedef struct tagNwcConvertLocalHandle {
+struct nwc_convert_local_handle {
 	u32 uConnReference;
 	unsigned char NetWareHandle[6];
 
-} NwcConvertLocalHandle, *PNwcConvertLocalHandle;
+};
 
 //++=======================================================================
 //  API Name:        NwcConvertNetWareHandle
@@ -592,121 +482,13 @@ typedef struct tagNwcConvertLocalHandle
 //  Environment:     PASSIVE_LEVEL, LINUX
 //
 //=======================================================================--
-typedef struct tagNwcConvertNetWareHandle {
-	NW_CONN_HANDLE ConnHandle;
+struct nwc_convert_netware_handle {
+	u32 ConnHandle;
 	u32 uAccessMode;
 	unsigned char NetWareHandle[6];
 	u32 uFileSize;
-} NwcConvertNetWareHandle, *PNwcConvertNetWareHandle;
+};
 
-//++=======================================================================
-//  API Name:        NwcFragmentRequest
-//
-//  Arguments In:    ConnHandle
-//                      The connection handle the request is being
-//                      directed to.
-//
-//                   uFunction
-//                      The NCP function to be called, should be 104
-//                      for NDS fragger/defragger requests.
-//
-//                   uSubFunction
-//                      The NCP subfunction to be called, should be
-//                      2 for NDS fragger/defragger requests.
-//
-//                   uVerb
-//                      The actual operation to be completed on the
-//                      server backend.
-//
-//                   flags
-//                      Currently not implemented.  Reserved for
-//                      future use.
-//
-//                   uNumRequestFrags
-//                      The number of fragments that the request packet
-//                      has been broken into.
-//
-//                   pRequestFrags
-//                      List of fragments that make up the request packet.
-//                      Each fragment includes the length of the fragment
-//                      data and a pointer to the data.
-//
-//                   uNumReplyFrags
-//                      The number of fragments the reply packet has been
-//                      broken into.
-//
-//  Arguments Out:   pReplyFrags
-//                      List of fragments that make up the reply packet.
-//                      Each fragment includes the length of the fragment
-//                      data and a pointer to the data.
-//
-//                   uActualReplyLength
-//                      Total size of the reply packet after any header
-//                      and tail information is removed.
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_CONN_INVALID
-//
-//  Abstract:        API for sending large NCP/NDS packets that are
-//                   larger than the max MTU size for the underlying
-//                   network.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-typedef struct tagNwcFragmentRequest {
-	NW_CONN_HANDLE ConnHandle;
-	u32 uFunction;
-	u32 uSubFunction;
-	u32 uVerb;
-	u32 flags;
-	u32 uNumRequestFrags;
-	PNwcFrag pRequestFrags;
-	u32 uNumReplyFrags;
-	PNwcFrag pReplyFrags;
-	u32 uActualReplyLength;
-} NwcFragmentRequest, *PNwcFragmentRequest;
-
-//++=======================================================================
-//  API Name:        NwcGetBroadcastMessage
-//
-//  Arguments In:    uMessageFlags - Not currently used.
-//
-//                   uConnReference - connection reference for
-//                   pending message.
-//
-//                   messageLen - length of message buffer.
-//
-//                   message - message buffer
-//
-//  Arguments Out:   messageLen - length of the message
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_NO_MORE_ENTRIES
-//
-//  Abstract:        This API is used for notifying a caller of pending
-//                   broadcast messages on the server.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-/* jlt
-typedef  struct   tagNwcGetBroadcastMessage
-{
-   u32               uMessageFlags;
-   u32               uConnReference;
-   u32               messageLen;
-   unsigned char                message[255];
-
-} NwcGetBroadcastMessage, *PNwcGetBroadcastMessage;
-*/
 
 //++=======================================================================
 //  API Name:        NwcGetConnInfo
@@ -746,13 +528,13 @@ typedef  struct   tagNwcGetBroadcastMess
 //
 //=======================================================================--
 
-typedef struct tagNwcGetConnInfo {
-	NW_CONN_HANDLE ConnHandle;
+struct nwc_get_conn_info {
+	u32 ConnHandle;
 	u32 uInfoLevel;
 	u32 uInfoLength;
 	void *pConnInfo;
 
-} NwcGetConnInfo, *PNwcGetConnInfo;
+};
 
 //++=======================================================================
 //  API Name:        NwcGetDefaultNameContext
@@ -785,14 +567,14 @@ typedef struct tagNwcGetConnInfo {
 //
 //=======================================================================--
 
-typedef struct tagNwcGetDefaultNameContext {
+struct nwc_get_def_name_ctx {
 	u32 uTreeLength;
 	unsigned char *pDsTreeName;
 	u32 uNameLength;
 // unsigned short *pNameContext;
 	unsigned char *pNameContext;
 
-} NwcGetDefaultNameContext, *PNwcGetDefaultNameContext;
+};
 
 //++=======================================================================
 //  API Name:        NwcGetTreeMonitoredConnReference
@@ -817,86 +599,12 @@ typedef struct tagNwcGetDefaultNameConte
 //
 //=======================================================================--
 
-typedef struct tagNwcGetTreeMonitoredConnRef {
-	PNwcString pTreeName;
+struct nwc_get_tree_monitored_conn_ref {
+	struct nwc_string *pTreeName;
 	u32 uConnReference;
 
-} NwcGetTreeMonitoredConnRef, *PNwcGetTreeMonitoredConnRef;
+};
 
-//++=======================================================================
-//  API Name:        NwcGetNumberConns
-//
-//  Arguments In:    NONE
-//
-//  Arguments Out:   uMaxConns - The maximum number of connections
-//                   supported by the redirector.  -1 for dynamic.
-//
-//                   uPublicConns - The current number of public
-//                   connections.
-//
-//                   uTasksPrivateConns - The current number of private
-//                   connections that are owned by the calling process.
-//
-//                   uOtherPrivateConns - The current number of private
-//                   connections that are not owned by the calling
-//                   process.
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_RESOURCE_LOCK
-//
-//  Abstract:        This API returns the current number of connections
-//                   as well as the maximum number of supported
-//                   connections.  If the requester/redirector supports
-//                   a dynamic connection table, -1 will be returned
-//                   in the uMaxConns field.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcGetNumberConns {
-	u32 uMaxConns;
-	u32 uPublicConns;
-	u32 uTasksPrivateConns;
-	u32 uOtherPrivateConns;
-
-} NwcGetNumberConns, *PNwcGetNumberConns;
-
-//++=======================================================================
-//  API Name:        NwcGetPreferredServer
-//
-//  Arguments In:    uServerNameLength - On input, this is the length
-//                   in bytes of the server buffer.  On output, this is
-//                   the actual length of the server name string in bytes.
-//
-//  Arguments Out:   pServerName - The buffer to copy the preferred server
-//                   name into.
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_BUFFER_OVERFLOW
-//                   NWE_OBJECT_NOT_FOUND
-//                   NWE_PARAM_INVALID
-//                   NWE_RESOURCE_LOCK
-//
-//  Abstract:        This API returns the configured preferred bindery
-//                   server previously set either by configuration or
-//                   by calling NwcSetPreferredServer.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcGetPreferredServer {
-	u32 uServerNameLength;
-	char *pServerName;
-
-} NwcGetPreferredServer, *PNwcGetPreferredServer;
 
 //++=======================================================================
 //  API Name:        NwcGetPreferredDsTree
@@ -923,63 +631,10 @@ typedef struct tagNwcGetPreferredServer
 //  Environment:     PASSIVE_LEVEL, LINUX
 //
 //=======================================================================--
-typedef struct tagNwcGetPreferredDsTree {
+struct nwc_get_pref_ds_tree {
 	u32 uTreeLength;
 	unsigned char *pDsTreeName;
-} NwcGetPreferredDsTree, *PNwcGetPreferredDsTree;
-
-//++=======================================================================
-//  API Name:        NwcGetPrimaryConnection
-//
-//  Arguments In:    NONE
-//
-//  Arguments Out:   uConnReference - Reference to the primary connection.
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_CONN_PRIMARY_NOT_SET
-//
-//  Abstract:        This API returns the reference to the current primary
-//                   connection in the redirector.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcGetPrimaryConnection {
-	u32 uConnReference;
-
-} NwcGetPrimaryConnection, *PNwcGetPrimaryConnection;
-
-//++=======================================================================
-//  API Name:        NwcGetRequesterVersion
-//
-//  Arguments In:    NONE
-//
-//  Arguments Out:   uMajorVersion
-//                   uMinorVersion
-//                   uRevision
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//
-//  Abstract:        This API returns the major version, minor version and
-//                   revision of the requester/redirector.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcGetRequesterVersion {
-	u32 uMajorVersion;
-	u32 uMinorVersion;
-	u32 uRevision;
-
-} NwcGetRequesterVersion, *PNwcGetRequesterVersion;
+};
 
 //++=======================================================================
 //  API Name:        NwcLicenseConn
@@ -1007,115 +662,10 @@ typedef struct tagNwcGetRequesterVersion
 //
 //=======================================================================--
 
-typedef struct tagNwcLicenseConn {
-	NW_CONN_HANDLE ConnHandle;
-
-} NwcLicenseConn, *PNwcLicenseConn;
-
-//++=======================================================================
-//  API Name:        NwcMakeConnPermanent
-//
-//  Arguments In:    ConnHandle - An open connection handle associated
-//                   with the connection to be made permanent.
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         NWE_ACCESS_VIOLATION
-//                   NWE_CONN_INVALID
-//                   NWE_INVALID_OWNER
-//
-//  Abstract:        This API is used to keep the connection from being
-//                   destroyed until a NwcSysCloseConn request is made
-//                   on the connection.  This allows the connection to
-//                   remain after all processes that have the
-//                   connection open terminate.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcMakeConnPermanent {
-	NW_CONN_HANDLE ConnHandle;
-
-} NwcMakeConnPermanent, *PNwcMakeConnPermanent;
-
-//++=======================================================================
-//  API Name:        NwcMapDrive
-//
-//  Arguments In:    ConnHandle - The connection handle of the server
-//                   to where the drive is to be mapped.
-//
-//                   LocalUID - Local user ID
-//
-//                   LocalPathLen - Length of local/link directory path string,
-//                   including nul terminator.
-//
-//                   LocalPathOffset - Offset of local directory path that will
-//                   be mapped to NetWare directory path.
-//
-//                   NetWarePathLen - Offset of NetWare directory path,
-//                   including nul terminator.
-//
-//                   NetWarePathOffset - Offset of NetWare directory path in
-//                   structure.
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_CONN_INVALID
-//                   NWE_INSUFFICIENT_RESOURCES
-//                   NWE_STRING_TRANSLATION
-//
-//  Abstract:        This API maps the target drive to the specified
-//                   directory.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcMapDrive {
-	NW_CONN_HANDLE ConnHandle;
-	u32 LocalUID;
-	u32 LinkPathLen;
-	u32 LinkPathOffset;
-	u32 DestPathLen;
-	u32 DestPathOffset;
+struct nwc_license_conn {
+	u32 ConnHandle;
+};
 
-} NwcMapDrive, *PNwcMapDrive;
-
-//++=======================================================================
-//  API Name:        NwcUnmapDrive
-//
-//  Arguments In:    LinkPathLen - Length of local/link path string,
-//                   including nul terminator.
-//
-//                   LinkPath - Local/link path in structure
-//                   to be unmapped
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_PARAM_INVALID
-//
-//  Abstract:        This API deletes a network drive mapping.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcUnmapDrive {
-	u32 LinkPathLen;
-	unsigned char LinkPath[1];
-
-} NwcUnmapDrive, *PNwcUnmapDrive;
 
 //++=======================================================================
 //  API Name:        NWCGetMappedDrives
@@ -1136,26 +686,11 @@ typedef struct tagNwcUnmapDrive {
 //
 //=======================================================================--
 
-typedef struct tagNwcMapDriveElem {
-	u32 ElemLen;		// Lenght of drive element
-	u32 ConnRefernce;	// Connection reference
-	u32 LinkPathLen;	// Local/link dir path, length includes nul
-	unsigned char LinkPath[1];	// LinkPath[LinkPathLen]
-// u32               DirPathLen;       // NetWare dir path, length includes nul (vol:path)
-// unsigned char                DirPath[DirPathLen]; // NetWarePath[DirPathLen]
-} NwcMapDriveElem, *PNwcMapDriveElem;
-
-typedef struct tagNwcMapDriveBuff {
-	u32 MapCount;		// Number of mapped drives
-	NwcMapDriveElem MapDriveElem[1];	// MapDriveElem[MapCount]
-
-} NwcMapDriveBuff, *PNwcMapDriveBuff;
-
-typedef struct tagNwcGetMappedDrives {
+struct nwc_get_mapped_drives {
 	u32 MapBuffLen;		// Buffer length (actual buffer size returned)
-	PNwcMapDriveBuff MapBuffer;	// Pointer to map buffer
+	struct nwc_mapped_drive_buf *MapBuffer;	// Pointer to map buffer
 
-} NwcGetMappedDrives, *PNwcGetMappedDrives;
+};
 
 //++=======================================================================
 //  API Name:        NwcGetMountPath
@@ -1178,39 +713,11 @@ typedef struct tagNwcGetMappedDrives {
 //
 //=======================================================================--
 
-typedef struct tagNwcGetMountPath {
+struct nwc_get_mount_path {
 	u32 MountPathLen;
 	unsigned char *pMountPath;
 
-} NwcGetMountPath, *PNwcGetMountPath;
-
-//++=======================================================================
-//  API Name:        NwcMonitorConn
-//
-//  Arguments In:    ConnHandle - The handle associated with the connection
-//                   that is to be marked as the monitored connection.
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_RESOURCE_LOCK
-//                   NWE_CONN_INVALID
-//
-//
-//  Abstract:        This call marks the connection associated with the
-//                   connection handle as monitored.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcMonitorConn {
-	NW_CONN_HANDLE ConnHandle;
-
-} NwcMonitorConn, *PNwcMonitorConn;
+};
 
 //++=======================================================================
 //  API Name:        NwcOpenConnByAddr
@@ -1244,13 +751,13 @@ typedef struct tagNwcMonitorConn {
 //
 //=======================================================================--
 
-typedef struct tagNwcOpenConnByAddr {
+struct nwc_open_conn_by_addr {
 	char *pServiceType;
 	u32 uConnFlags;
-	PNwcTranAddr pTranAddr;
-	NW_CONN_HANDLE ConnHandle;
+	struct nwc_tran_addr *pTranAddr;
+	u32 ConnHandle;
 
-} NwcOpenConnByAddr, *PNwcOpenConnByAddr;
+};
 
 //++=======================================================================
 //  API Name:        NwcOpenConnByName
@@ -1304,15 +811,15 @@ typedef struct tagNwcOpenConnByAddr {
 //
 //=======================================================================--
 
-typedef struct tagNwcOpenConnByName {
-	NW_CONN_HANDLE ConnHandle;
-	PNwcConnString pName;
+struct nwc_open_conn_by_name {
+	u32 ConnHandle;
+	struct nwc_conn_string *pName;
 	char *pServiceType;
 	u32 uConnFlags;
 	u32 uTranType;
-	NW_CONN_HANDLE RetConnHandle;
+	u32 RetConnHandle;
 
-} NwcOpenConnByName, *PNwcOpenConnByName;
+};
 
 //++=======================================================================
 //  API Name:        NwcOpenConnByReference
@@ -1346,12 +853,12 @@ typedef struct tagNwcOpenConnByName {
 //
 //=======================================================================--
 
-typedef struct tagNwcOpenConnByReference {
+struct nwc_open_conn_by_ref {
 	u32 uConnReference;
 	u32 uConnFlags;
-	NW_CONN_HANDLE ConnHandle;
+	u32 ConnHandle;
 
-} NwcOpenConnByReference, *PNwcOpenConnByReference;
+};
 
 //++=======================================================================
 //  API Name:        NwcRawRequest
@@ -1390,55 +897,16 @@ typedef struct tagNwcOpenConnByReference
 //
 //=======================================================================--
 
-typedef struct tagNwcRequest {
-	NW_CONN_HANDLE ConnHandle;
+struct nwc_request {
+	u32 ConnHandle;
 	u32 uFunction;
 	u32 uNumRequestFrags;
-	PNwcFrag pRequestFrags;
+	struct nwc_frag *pRequestFrags;
 	u32 uNumReplyFrags;
-	PNwcFrag pReplyFrags;
+	struct nwc_frag *pReplyFrags;
 	u32 uActualReplyLength;
 
-} NwcRequest, *PNwcRequest;
-
-//++=======================================================================
-//  API Name:        NwcRawRequestAll
-//
-//  Arguments In:    uFunction - The NCP function that is being called.
-//
-//                   uNumRequestFrags - The number of fragments that the
-//                   request packet has been broken into.
-//
-//                   pRequestFrags - List of fragments that make up the
-//                   request packet.  Each fragment includes the length
-//                   of the fragment data and a pointer to the data.
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_CONN_INVALID
-//
-//  Abstract:        API for sending the given NCP request to all valid
-//                   connections.  If there is a private connection that
-//                   is not owned by the caller of this function, that
-//                   connection will not be included.  Also, if the
-//                   caller has both a private and a public connection
-//                   to the same server, only the private connection
-//                   will receive the request.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcRequestAll {
-	u32 uFunction;
-	u32 uNumRequestFrags;
-	PNwcFrag pRequestFrags;
-
-} NwcRequestAll, *PNwcRequestAll;
+};
 
 //++=======================================================================
 //  API Name:        NwcScanConnInfo
@@ -1544,7 +1012,7 @@ typedef struct tagNwcRequestAll {
 //
 //=======================================================================--
 
-typedef struct tagNwcScanConnInfo {
+struct nwc_scan_conn_info {
 	u32 uScanIndex;
 	u32 uScanInfoLevel;
 	u32 uScanInfoLen;
@@ -1555,7 +1023,7 @@ typedef struct tagNwcScanConnInfo {
 	u32 uConnectionReference;
 	void *pReturnConnInfo;
 
-} NwcScanConnInfo, *PNwcScanConnInfo;
+};
 
 //++=======================================================================
 //  API Name:        NwcSetConnInfo
@@ -1589,13 +1057,13 @@ typedef struct tagNwcScanConnInfo {
 //
 //=======================================================================--
 
-typedef struct tagNwcSetConnInfo {
-	NW_CONN_HANDLE ConnHandle;
+struct nwc_set_conn_info {
+	u32 ConnHandle;
 	u32 uInfoLevel;
 	u32 uInfoLength;
 	void *pConnInfo;
 
-} NwcSetConnInfo, *PNwcSetConnInfo;
+};
 
 //++=======================================================================
 //  API Name:        NwcSetDefaultNameContext
@@ -1626,14 +1094,14 @@ typedef struct tagNwcSetConnInfo {
 //
 //=======================================================================--
 
-typedef struct tagNwcSetDefaultNameContext {
+struct nwc_set_def_name_ctx {
 	u32 uTreeLength;
 	unsigned char *pDsTreeName;
 	u32 uNameLength;
 // unsined short *pNameContext;
 	unsigned char *pNameContext;
 
-} NwcSetDefaultNameContext, *PNwcSetDefaultNameContext;
+};
 
 //++=======================================================================
 //  API Name:        NwcSetPreferredDsTree
@@ -1658,41 +1126,11 @@ typedef struct tagNwcSetDefaultNameConte
 //
 //=======================================================================--
 
-typedef struct tagNwcSetPreferredDsTree {
+struct nwc_set_pref_ds_tree {
 	u32 uTreeLength;
 	unsigned char *pDsTreeName;
 
-} NwcSetPreferredDsTree, *PNwcSetPreferredDsTree;
-
-//++=======================================================================
-//  API Name:        NwcSetPreferredServer
-//
-//  Arguments In:    uServerNameLength - The length in bytes of the
-//                   preferred server string.
-//
-//                   pServerName - a pointer to an ASCIIZ string of the
-//                   preferred bindery server.
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_INSUFFICIENT_RESOURCES
-//                   NWE_RESOURCE_LOCK
-//
-//  Abstract:        This API sets the preferred server name.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcSetPreferredServer {
-	u32 uServerNameLength;
-	char *pServerName;
-
-} NwcSetPreferredServer, *PNwcSetPreferredServer;
+};
 
 //++=======================================================================
 //  API Name:        NwcSetPrimaryConnection
@@ -1716,69 +1154,11 @@ typedef struct tagNwcSetPreferredServer
 //
 //=======================================================================--
 
-typedef struct tagNwcSetPrimaryConnection {
-	NW_CONN_HANDLE ConnHandle;
-
-} NwcSetPrimaryConnection, *PNwcSetPrimaryConnection;
-
-//++=======================================================================
-//  API Name:        NwcSysCloseConn
-//
-//  Arguments In:    ConnHandle - The handle to a connection that is
-//                   to be destroyed.
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_CONN_INVALID
-//
-//  Abstract:        This API is similiar to the NwcCloseConn API, except
-//                   that it forces all handles to the connection closed
-//                   and destroys the service connection.  This is a system
-//                   level request that will cause all processes that are
-//                   accessing this connection to lose access to the
-//                   resources associated to the connection.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcSysCloseConn {
-	NW_CONN_HANDLE ConnHandle;
-
-} NwcSysCloseConn, *PNwcSysCloseConn;
-
-//++=======================================================================
-//  API Name:        NwcUnlicenseConn
-//
-//  Arguments In:    ConnHandle - Open connection handle that will be
-//                   accessing the connection in an unlicensed manner.
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_CONN_INVALID
-//                   NWE_HANDLE_ALREADY_UNLICENSED
-//
-//  Abstract:        This API is used to change the state of a connection
-//                   handle from licensed to unlicensed.  If all handles
-//                   to the connection have been changed to the unlicensed
-//                   state, the unlicensed NCP is sent to the server.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
+struct nwc_set_primary_conn {
+	u32 ConnHandle;
 
-typedef struct tagNwcUnlicenseConn {
-	NW_CONN_HANDLE ConnHandle;
+};
 
-} NwcUnlicenseConn, *PNwcUnlicenseConn;
 
 //++=======================================================================
 //  API Name:        NwcQueryFeature
@@ -1801,10 +1181,10 @@ typedef struct tagNwcUnlicenseConn {
 //
 //=======================================================================--
 
-typedef struct tagNwcQueryFeature {
+struct nwc_query_feature {
 	u32 Feature;
 
-} NwcQueryFeature, *PNwcQueryFeature;
+};
 
 //++=======================================================================
 //  API Name:        NWCChangePassword
@@ -1824,16 +1204,16 @@ typedef struct tagNwcQueryFeature {
 //
 //=======================================================================--
 
-typedef struct tagNwcChangeKey {
-	PNwcString pDomainName;
+struct nwc_change_key {
+	struct nwc_string *pDomainName;
 	u32 AuthType;
-	PNwcString pObjectName;
+	struct nwc_string *pObjectName;
 	u32 NameType;
 	u16 ObjectType;
-	PNwcString pVerifyPassword;
-	PNwcString pNewPassword;
+	struct nwc_string *pVerifyPassword;
+	struct nwc_string *pNewPassword;
 
-} NwcChangeKey, *PNwcChangeKey;
+};
 
 //++=======================================================================
 //  API Name:        NWCEnumerateIdentities            `
@@ -1853,17 +1233,17 @@ typedef struct tagNwcChangeKey {
 //
 //=======================================================================--
 
-typedef struct tagNwcEnumerateIdentities {
+struct nwc_enum_ids {
 	u32 Iterator;
-	PNwcString pDomainName;
+	struct nwc_string *pDomainName;
 	u32 AuthType;
-	PNwcString pObjectName;
+	struct nwc_string *pObjectName;
 	u32 NameType;
 	u16 ObjectType;
 	u32 IdentityFlags;
-	AUTHEN_ID AuthenticationId;
+	u32 AuthenticationId;
 
-} NwcEnumerateIdentities, *PNwcEnumerateIdentities;
+};
 
 //++=======================================================================
 //  API Name:        NWCGetIdentityInfo
@@ -1883,16 +1263,16 @@ typedef struct tagNwcEnumerateIdentities
 //
 //=======================================================================--
 
-typedef struct tagNwcGetIdentityInfo {
-	AUTHEN_ID AuthenticationId;
-	PNwcString pDomainName;
+struct nwc_get_id_info {
+	u32 AuthenticationId;
+	struct nwc_string *pDomainName;
 	u32 AuthType;
-	PNwcString pObjectName;
+	struct nwc_string *pObjectName;
 	u32 NameType;
 	u16 ObjectType;
 	u32 IdentityFlags;
 
-} NwcGetIdentityInfo, *PNwcGetIdentityInfo;
+};
 
 //++=======================================================================
 //  API Name:        NWCLoginIdentity
@@ -1912,41 +1292,18 @@ typedef struct tagNwcGetIdentityInfo {
 //
 //=======================================================================--
 
-typedef struct tagNwcLoginIdentity {
-	PNwcString pDomainName;
+struct nwc_login_id {
+	struct nwc_string *pDomainName;
 	u32 AuthType;
-	PNwcString pObjectName;
+	struct nwc_string *pObjectName;
 	u32 NameType;
 	u16 ObjectType;
 	u32 IdentityFlags;
-	PNwcString pPassword;
-	AUTHEN_ID AuthenticationId;
-
-} NwcLoginIdentity, *PNwcLoginIdentity;
-
-//++=======================================================================
-//  API Name:        NWCLogoutIdentity
-////
-
-//  Arguments In:
-//
-//  Arguments Out:
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//
-//  Abstract:
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
+	struct nwc_string *pPassword;
+	u32 AuthenticationId;
 
-typedef struct tagNwcLogoutIdentity {
-	AUTHEN_ID AuthenticationId;
+};
 
-} NwcLogoutIdentity, *PNwcLogoutIdentity;
 
 //++=======================================================================
 //  API Name:        NWCSetPassword
@@ -1966,14 +1323,14 @@ typedef struct tagNwcLogoutIdentity {
 //
 //=======================================================================--
 
-typedef struct tagNwcSetKey {
-	NW_CONN_HANDLE ConnHandle;
-	AUTHEN_ID AuthenticationId;
-	PNwcString pObjectName;
+struct nwc_set_key {
+	u32 ConnHandle;
+	u32 AuthenticationId;
+	struct nwc_string *pObjectName;
 	u16 ObjectType;
-	PNwcString pNewPassword;
+	struct nwc_string *pNewPassword;
 
-} NwcSetKey, *PNwcSetKey;
+};
 
 //++=======================================================================
 //  API Name:        NWCVerifyPassword
@@ -1993,15 +1350,15 @@ typedef struct tagNwcSetKey {
 //
 //++=======================================================================
 
-typedef struct tagNwcVerifyKey {
-	PNwcString pDomainName;
+struct nwc_verify_key {
+	struct nwc_string *pDomainName;
 	u32 AuthType;
-	PNwcString pObjectName;
+	struct nwc_string *pObjectName;
 	u32 NameType;
 	u16 ObjectType;
-	PNwcString pVerifyPassword;
+	struct nwc_string *pVerifyPassword;
 
-} NwcVerifyKey, *PNwcVerifyKey;
+};
 
 //++=======================================================================
 //  API Name:        NwcAuthenticateWithId
@@ -2026,188 +1383,34 @@ typedef struct tagNwcVerifyKey {
 //
 //=======================================================================--
 
-typedef struct tagNwcAuthenticateWithId {
-	NW_CONN_HANDLE ConnHandle;
-	AUTHEN_ID AuthenticationId;
-
-} NwcAuthenticateWithId, *PNwcAuthenticateWithId;
-
-//++=======================================================================
-//  API Name:        NwcUnauthenticate
-//
-//  Arguments In:    ConnHandle - The connection to unauthenticate.
-//
-//  Arguments Out:   NONE
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_CONN_INVALID
-//                   NWE_INVALID_OWNER
-//                   NWE_RESOURCE_LOCK
-//
-//  Abstract:        This API removes the authentication for the specified
-//                   connection.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcUnauthenticate {
-	NW_CONN_HANDLE ConnHandle;
-	AUTHEN_ID AuthenticationId;
-
-} NwcUnauthenticate, *PNwcUnauthenticate;
-
-//++=======================================================================
-//  API Name:        NwcGetCfgNameServiceProviders
-//
-//  Arguments In:
-//
-//  Arguments Out:
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//
-//  Abstract:
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct {
-	u32 providerCount;
-	u32 providers[MAX_NAME_SERVICE_PROVIDERS];
-
-} NwcGetCfgNameServiceProviders, *PNwcGetCfgNameServiceProviders;
-
-//++=======================================================================
-//  API Name:        NwcNdsResolveNameToId
-//
-//  Arguments In:    connHandle
-//                      Specifies connection to use to resolve name with.
-//
-//                   pName
-//                      Points to the name of the NDS entry to resolve.
-//
-//                   uReqTranType
-//                      Specifies the preferred or required transport to
-//                      be used.
-//
-//                   pResolveInfo
-//                      Points to the NwcNdsResolveInfo structure
-//                      containing information on how the entry is to be
-//                      resolved.
-//
-//  Arguments Out:   pResolveInfo
-//                      Points to the NwcNdsResolveInfo structure
-//                      containing return information on the resolved
-//                      entry.
-//
-//                   pluEntryId
-//                      Points to the resolved name's entry ID.
-//
-//                   pReferral
-//                      Points to the NwcReferral structure which describes
-//                      network addresses that can be used to locate other
-//                      NDS partitions that contain the entry name.
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_CONN_INVALID,
-//                   NWE_BUFFER_OVERFLOW,
-//                   NWE_TRAN_INVALID_TYPE,
-//                   NWE_ACCESS_VIOLATION,
-//                   NWE_UNSUPPORTED_TRAN_TYPE,
-//                   Nds error code
-//
-//  Abstract:        This API resolves a NDS entry name.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
-
-typedef struct tagNwcNdsResolveNameToId {
-	NW_CONN_HANDLE connHandle;
-	PNwcString pName;
-	u32 uReqTranType;
-	PNwcResolveInfo pResolveInfo;
-	u32 entryId;
-	PNwcReferral pReferral;
-
-} NwcNdsResolveNameToId, *PNwcNdsResolveNameToId;
-
-//++=======================================================================
-//  API Name:        NwcOrderedRequest
-//
-//  Arguments In:    uFunction - The NCP function that is being called.
-//
-//                   uNumRequestFrags - The number of fragments that the
-//                   request packet has been broken into.
-//
-//                   pRequestFrags - List of fragments that make up the
-//                   request packet.  Each fragment includes the length
-//                   of the fragment data and a pointer to the data.
-//
-//                   uInverseReqCode - The NCP function that will be called
-//                   if the request fails.
-//
-//                   uNumInverseFrags - The number of fragments the inverse
-//                   request packet has been broken into.
-//
-//                   pReplyFrags - List of fragments that make up the
-//                   inverse request packet.  Each fragment includes the length
-//                   of the fragment data and a pointer to the data.
-//
-//  Returns:         STATUS_SUCCESS
-//                   NWE_ACCESS_VIOLATION
-//                   NWE_CONN_INVALID
-//
-//  Abstract:        API for sending raw NCP packets directly to a server.
-//
-//  Notes:
-//
-//  Environment:     PASSIVE_LEVEL, LINUX
-//
-//=======================================================================--
+struct nwc_auth_with_id {
+	u32 ConnHandle;
+	u32 AuthenticationId;
 
-typedef struct tagNwcOrderedRequest {
-	u32 uReqCode;
-	u32 uNumRequestFrags;
-	PNwcFrag pRequestFrags;
-	u32 uInverseReqCode;
-	u32 uNumInverseFrags;
-	PNwcFrag pInverseFrags;
+};
 
-} NwcOrderedRequest, *PNwcOrderedRequest;
 
-#if 1				//sgled
-typedef struct tagNwcUnmapDriveEx {
+struct nwc_unmap_drive_ex {
 //         unsigned long      connHdl;
 	unsigned int linkLen;
 	char linkData[1];
 
-} NwcUnmapDriveEx, *PNwcUnmapDriveEx;
+};
 
-typedef struct tagNwcMapDriveEx {
-	NW_CONN_HANDLE ConnHandle;
+struct nwc_map_drive_ex {
+	u32 ConnHandle;
 	unsigned int localUid;
 	unsigned int linkOffsetLength;
 	unsigned int linkOffset;
 	unsigned int dirPathOffsetLength;
 	unsigned int dirPathOffset;
-} NwcMapDriveEx, *PNwcMapDriveEx;
+};
 
-typedef struct tagNwcGetBroadcastNotification {
+struct nwc_get_bcast_notification {
 	u32 uMessageFlags;
 	u32 uConnReference;
 	u32 messageLen;
 	char message[1];
-} NwcGetBroadcastNotification, *PNwcGetBroadcastNotification;
+};
 
-#endif
 #endif /* __NWCLNX_H__ */
--- a/fs/novfs/proc.c
+++ b/fs/novfs/proc.c
@@ -20,13 +20,13 @@
 
 #include "vfs.h"
 
-struct proc_dir_entry *Novfs_Procfs_dir;
-static struct proc_dir_entry *Novfs_Control;
-static struct proc_dir_entry *Novfs_Library;
-static struct proc_dir_entry *Novfs_Version;
+struct proc_dir_entry *novfs_procfs_dir;
+struct proc_dir_entry *Novfs_Control;
+struct proc_dir_entry *Novfs_Library;
+struct proc_dir_entry *Novfs_Version;
 
-static struct file_operations Daemon_proc_fops;
-static struct file_operations Library_proc_fops;
+static struct file_operations novfs_daemon_proc_fops;
+static struct file_operations novfs_lib_proc_fops;
 
 /*===[ Code ]=============================================================*/
 
@@ -39,17 +39,17 @@ static int Novfs_Get_Version(char *page,
 		buf = page + off;
 		*start = buf;
 		len = sprintf(buf, "Novfs Version=%s\n", NOVFS_VERSION_STRING);
-		i = Daemon_getversion(tbuf, sizeof(tbuf));
+		i = novfs_daemon_getversion(tbuf, sizeof(tbuf));
 		if ((i > 0) && i < (count - len)) {
 			len += sprintf(buf + len, "Novfsd Version=%s\n", tbuf);
 		}
 
-		if (Novfs_CurrentMount) {
-			i = strlen(Novfs_CurrentMount);
+		if (novfs_current_mnt) {
+			i = strlen(novfs_current_mnt);
 			if ((i > 0) && i < (count - len)) {
 				len +=
 				    sprintf(buf + len, "Novfs mount=%s\n",
-					    Novfs_CurrentMount);
+					    novfs_current_mnt);
 			}
 		}
 		DbgPrint("Novfs_Get_Version:\n%s\n", buf);
@@ -58,39 +58,40 @@ static int Novfs_Get_Version(char *page,
 	return (len);
 }
 
-int Init_Procfs_Interface(void)
+int novfs_proc_init(void)
 {
 	int retCode = 0;
 
-	Novfs_Procfs_dir = proc_mkdir(MODULE_NAME, NULL);
-	if (Novfs_Procfs_dir) {
-		Novfs_Procfs_dir->owner = THIS_MODULE;
+	novfs_procfs_dir = proc_mkdir(MODULE_NAME, NULL);
+	if (novfs_procfs_dir) {
+		novfs_procfs_dir->owner = THIS_MODULE;
 
-		Novfs_Control = create_proc_entry("Control", 0600, Novfs_Procfs_dir);
+		Novfs_Control = create_proc_entry("Control", 0600, novfs_procfs_dir);
 
 		if (Novfs_Control) {
 			Novfs_Control->owner = THIS_MODULE;
 			Novfs_Control->size = 0;
-			memcpy(&Daemon_proc_fops, Novfs_Control->proc_fops,
-			       sizeof(struct file_operations));
+			memcpy(&novfs_daemon_proc_fops,
+					Novfs_Control->proc_fops,
+					sizeof(struct file_operations));
 
 			/*
 			 * Setup our functions
 			 */
-			Daemon_proc_fops.owner = THIS_MODULE;
-			Daemon_proc_fops.open = Daemon_Open_Control;
-			Daemon_proc_fops.release = Daemon_Close_Control;
-			Daemon_proc_fops.read = Daemon_Send_Command;
-			Daemon_proc_fops.write = Daemon_Receive_Reply;
-			Daemon_proc_fops.ioctl = Daemon_ioctl;
+			novfs_daemon_proc_fops.owner = THIS_MODULE;
+			novfs_daemon_proc_fops.open = novfs_daemon_open_control;
+			novfs_daemon_proc_fops.release = novfs_daemon_close_control;
+			novfs_daemon_proc_fops.read = novfs_daemon_cmd_send;
+			novfs_daemon_proc_fops.write = novfs_daemon_recv_reply;
+			novfs_daemon_proc_fops.ioctl = novfs_daemon_ioctl;
 
-			Novfs_Control->proc_fops = &Daemon_proc_fops;
+			Novfs_Control->proc_fops = &novfs_daemon_proc_fops;
 		} else {
 			remove_proc_entry(MODULE_NAME, NULL);
 			return (-ENOENT);
 		}
 
-		Novfs_Library = create_proc_entry("Library", 0666, Novfs_Procfs_dir);
+		Novfs_Library = create_proc_entry("Library", 0666, novfs_procfs_dir);
 		if (Novfs_Library) {
 			Novfs_Library->owner = THIS_MODULE;
 			Novfs_Library->size = 0;
@@ -98,31 +99,31 @@ int Init_Procfs_Interface(void)
 			/*
 			 * Setup our file functions
 			 */
-			memcpy(&Library_proc_fops, Novfs_Library->proc_fops,
+			memcpy(&novfs_lib_proc_fops, Novfs_Library->proc_fops,
 			       sizeof(struct file_operations));
-			Library_proc_fops.owner = THIS_MODULE;
-			Library_proc_fops.open = Daemon_Library_open;
-			Library_proc_fops.release = Daemon_Library_close;
-			Library_proc_fops.read = Daemon_Library_read;
-			Library_proc_fops.write = Daemon_Library_write;
-			Library_proc_fops.llseek = Daemon_Library_llseek;
-			Library_proc_fops.ioctl = Daemon_Library_ioctl;
-			Novfs_Library->proc_fops = &Library_proc_fops;
+			novfs_lib_proc_fops.owner = THIS_MODULE;
+			novfs_lib_proc_fops.open = novfs_daemon_lib_open;
+			novfs_lib_proc_fops.release = novfs_daemon_lib_close;
+			novfs_lib_proc_fops.read = novfs_daemon_lib_read;
+			novfs_lib_proc_fops.write = novfs_daemon_lib_write;
+			novfs_lib_proc_fops.llseek = novfs_daemon_lib_llseek;
+			novfs_lib_proc_fops.ioctl = novfs_daemon_lib_ioctl;
+			Novfs_Library->proc_fops = &novfs_lib_proc_fops;
 		} else {
-			remove_proc_entry("Control", Novfs_Procfs_dir);
+			remove_proc_entry("Control", novfs_procfs_dir);
 			remove_proc_entry(MODULE_NAME, NULL);
 			return (-ENOENT);
 		}
 
 		Novfs_Version =
-		    create_proc_read_entry("Version", 0444, Novfs_Procfs_dir,
+		    create_proc_read_entry("Version", 0444, novfs_procfs_dir,
 					   Novfs_Get_Version, NULL);
 		if (Novfs_Version) {
 			Novfs_Version->owner = THIS_MODULE;
 			Novfs_Version->size = 0;
 		} else {
-			remove_proc_entry("Library", Novfs_Procfs_dir);
-			remove_proc_entry("Control", Novfs_Procfs_dir);
+			remove_proc_entry("Library", novfs_procfs_dir);
+			remove_proc_entry("Control", novfs_procfs_dir);
 			remove_proc_entry(MODULE_NAME, NULL);
 			retCode = -ENOENT;
 		}
@@ -132,17 +133,17 @@ int Init_Procfs_Interface(void)
 	return (retCode);
 }
 
-void Uninit_Procfs_Interface(void)
+void novfs_proc_exit(void)
 {
 
 	DbgPrint("Uninit_Procfs_Interface remove_proc_entry(Version, NULL)\n");
-	remove_proc_entry("Version", Novfs_Procfs_dir);
+	remove_proc_entry("Version", novfs_procfs_dir);
 
 	DbgPrint("Uninit_Procfs_Interface remove_proc_entry(Control, NULL)\n");
-	remove_proc_entry("Control", Novfs_Procfs_dir);
+	remove_proc_entry("Control", novfs_procfs_dir);
 
 	DbgPrint("Uninit_Procfs_Interface remove_proc_entry(Library, NULL)\n");
-	remove_proc_entry("Library", Novfs_Procfs_dir);
+	remove_proc_entry("Library", novfs_procfs_dir);
 
 	DbgPrint("Uninit_Procfs_Interface remove_proc_entry(%s, NULL)\n",
 		 MODULE_NAME);
--- a/fs/novfs/profile.c
+++ b/fs/novfs/profile.c
@@ -17,11 +17,12 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 #include <linux/sched.h>
+#include <asm/uaccess.h>
 #include <linux/vmalloc.h>
 #include <linux/time.h>
+
 #include <linux/profile.h>
 #include <linux/notifier.h>
-#include <asm/uaccess.h>
 
 #include "vfs.h"
 
@@ -41,10 +42,10 @@ struct local_rtc_time {
 	int tm_isdst;
 };
 
-static char *DbgPrintBuffer = NULL;
-static char DbgPrintOn = 0;
-static char DbgSyslogOn = 0;
-static char DbgProfileOn = 0;
+char *DbgPrintBuffer = NULL;
+char DbgPrintOn = 0;
+char DbgSyslogOn = 0;
+char DbgProfileOn = 0;
 
 static unsigned long DbgPrintBufferOffset = 0;
 static unsigned long DbgPrintBufferReadOffset = 0;
@@ -64,23 +65,22 @@ static DECLARE_MUTEX(LocalPrint_lock);
 static ssize_t User_proc_write_DbgBuffer(struct file *file, const char __user *buf, size_t nbytes, loff_t *ppos)
 {
 	ssize_t retval = nbytes;
-	unsigned char *lbuf;
-	unsigned char *p;
+	u_char *lbuf, *p;
 	int i;
+	u_long cpylen;
 
 	lbuf = kmalloc(nbytes + 1, GFP_KERNEL);
 	if (lbuf) {
-		if (copy_from_user(lbuf, buf, nbytes))
-			return -EFAULT;
+		cpylen = copy_from_user(lbuf, buf, nbytes);
 
 		lbuf[nbytes] = 0;
 		DbgPrint("User_proc_write_DbgBuffer: %s\n", lbuf);
 
-		for (i = 0; lbuf[i] && lbuf[i] != '\n'; i++)
-			;
+		for (i = 0; lbuf[i] && lbuf[i] != '\n'; i++) ;
 
-		if ('\n' == lbuf[i])
+		if ('\n' == lbuf[i]) {
 			lbuf[i] = '\0';
+		}
 
 		if (!strcmp("on", lbuf)) {
 			DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
@@ -99,15 +99,15 @@ static ssize_t User_proc_write_DbgBuffer
 					DbgSyslogOn = 0;
 				}
 			} else if (!strcmp("novfsd", lbuf)) {
-				Daemon_SendDebugCmd(p);
+				novfs_daemon_debug_cmd_send(p);
 			} else if (!strcmp("file_update_timeout", lbuf)) {
-				File_update_timeout =
+				novfs_update_timeout =
 				    simple_strtoul(p, NULL, 0);
 			} else if (!strcmp("cache", lbuf)) {
 				if (!strcmp("on", p)) {
-					PageCache = 1;
+					novfs_page_cache = 1;
 				} else if (!strcmp("off", p)) {
-					PageCache = 0;
+					novfs_page_cache = 0;
 				}
 			} else if (!strcmp("profile", lbuf)) {
 				if (!strcmp("on", p)) {
@@ -123,7 +123,7 @@ static ssize_t User_proc_write_DbgBuffer
 	return (retval);
 }
 
-static ssize_t User_proc_read_DbgBuffer(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+static ssize_t User_proc_read_DbgBuffer(struct file *file, char *buf, size_t nbytes, loff_t * ppos)
 {
 	ssize_t retval = 0;
 	size_t count;
@@ -273,7 +273,7 @@ static void doline(unsigned char *b, uns
 	}
 }
 
-void mydump(int size, void *dumpptr)
+void novfs_dump(int size, void *dumpptr)
 {
 	unsigned char *ptr = (unsigned char *)dumpptr;
 	unsigned char *line = NULL, buf[100], *bptr = buf;
@@ -314,7 +314,7 @@ static int month_days[12] = {
 /*
  * This only works for the Gregorian calendar - i.e. after 1752 (in the UK)
  */
-static void Novfs_GregorianDay(struct local_rtc_time *tm)
+static void GregorianDay(struct local_rtc_time *tm)
 {
 	int leapsToDate;
 	int lastYear;
@@ -384,14 +384,17 @@ static void private_to_tm(int tim, struc
 	/*
 	 * Determine the day of week
 	 */
-	Novfs_GregorianDay(tm);
+	GregorianDay(tm);
 }
 
 char *ctime_r(time_t * clock, char *buf)
 {
 	struct local_rtc_time tm;
-	static char *DAYOFWEEK[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
-	static char *MONTHOFYEAR[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
+	static char *DAYOFWEEK[] =
+	    { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
+	static char *MONTHOFYEAR[] =
+	    { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",
+"Oct", "Nov", "Dec" };
 
 	private_to_tm(*clock, &tm);
 
@@ -401,7 +404,7 @@ char *ctime_r(time_t * clock, char *buf)
 	return (buf);
 }
 
-static void profile_dump_dt(struct dentry *parent, void *pf)
+static void dump(struct dentry *parent, void *pf)
 {
 	void (*pfunc) (char *Fmt, ...) = pf;
 	struct l {
@@ -413,9 +416,11 @@ static void profile_dump_dt(struct dentr
 	char *buf, *path, *sd;
 	char inode_number[16];
 
-	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
-	if (!buf)
+	buf = (char *)kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+
+	if (NULL == buf) {
 		return;
+	}
 
 	if (parent) {
 		pfunc("starting 0x%p %.*s\n", parent, parent->d_name.len,
@@ -432,20 +437,25 @@ static void profile_dump_dt(struct dentr
 					p = l->dentry->d_subdirs.next;
 					while (p != &l->dentry->d_subdirs) {
 						d = list_entry(p, struct dentry,
-							       D_CHILD);
+							       d_u.d_child);
 						p = p->next;
 
-						if (d->d_subdirs.next != &d->d_subdirs) {
-							n = kmalloc(sizeof(*n), GFP_KERNEL);
+						if (d->d_subdirs.next !=
+						    &d->d_subdirs) {
+							n = kmalloc(sizeof
+									 (*n),
+									 GFP_KERNEL);
 							if (n) {
-								n->next = l->next;
+								n->next =
+								    l->next;
 								l->next = n;
 								n->dentry = d;
 							}
 						} else {
-							path = Scope_dget_path(d, buf, PATH_LENGTH_BUFFER, 1);
+							path = novfs_scope_dget_path(d, buf, PATH_LENGTH_BUFFER, 1);
 							if (path) {
-								pfunc("1-0x%p %s\n"
+								pfunc
+								    ("1-0x%p %s\n"
 								     "   d_name:    %.*s\n"
 								     "   d_parent:  0x%p\n"
 								     "   d_count:   %d\n"
@@ -453,14 +463,21 @@ static void profile_dump_dt(struct dentr
 								     "   d_subdirs: 0x%p\n"
 								     "   d_inode:   0x%p\n",
 								     d, path,
-								     d->d_name.len,
-								     d->d_name.name,
-								     d->d_parent,
-								     atomic_read(&d->d_count),
+								     d->d_name.
+								     len,
+								     d->d_name.
+								     name,
+								     d->
+								     d_parent,
+								     atomic_read
+								     (&d->
+								      d_count),
 								     d->d_flags,
-								     d->d_subdirs.
+								     d->
+								     d_subdirs.
 								     next,
-								     d->d_inode);
+								     d->
+								     d_inode);
 							}
 						}
 					}
@@ -469,11 +486,16 @@ static void profile_dump_dt(struct dentr
 				l = start;
 				while (l) {
 					d = l->dentry;
-					path = Scope_dget_path(d, buf, PATH_LENGTH_BUFFER, 1);
+					path =
+					    novfs_scope_dget_path(d, buf,
+							    PATH_LENGTH_BUFFER,
+							    1);
 					if (path) {
 						sd = " (None)";
-						if (&d->d_subdirs != d->d_subdirs.next)
+						if (&d->d_subdirs !=
+						    d->d_subdirs.next) {
 							sd = "";
+						}
 						inode_number[0] = '\0';
 						if (d->d_inode) {
 							sprintf(inode_number,
@@ -506,7 +528,7 @@ static void profile_dump_dt(struct dentr
 
 }
 
-static ssize_t profile_common_read(char __user *buf, size_t len, loff_t *off)
+static ssize_t common_read(char *buf, size_t len, loff_t * off)
 {
 	ssize_t retval = 0;
 	size_t count;
@@ -530,7 +552,8 @@ static ssize_t profile_common_read(char
 
 }
 
-static ssize_t profile_inode_read(struct file * file, char __user *buf, size_t len, loff_t *off)
+static ssize_t novfs_profile_read_inode(struct file * file, char *buf, size_t len,
+			   loff_t * off)
 {
 	ssize_t retval = 0;
 	unsigned long offset = *off;
@@ -542,10 +565,11 @@ static ssize_t profile_inode_read(struct
 		DbgPrintOn = 0;
 
 		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
-		Novfs_dump_inode(LocalPrint);
+		novfs_dump_inode(LocalPrint);
 	}
 
-	retval = profile_common_read(buf, len, off);
+
+	retval = common_read(buf, len, off);
 
 	if (0 == retval) {
 		DbgPrintOn = save_DbgPrintOn;
@@ -558,7 +582,8 @@ static ssize_t profile_inode_read(struct
 
 }
 
-static ssize_t profile_dentry_read(struct file *file, char __user *buf, size_t len, loff_t * off)
+static ssize_t novfs_profile_dentry_read(struct file * file, char *buf, size_t len,
+				     loff_t * off)
 {
 	ssize_t retval = 0;
 	unsigned long offset = *off;
@@ -569,10 +594,10 @@ static ssize_t profile_dentry_read(struc
 		save_DbgPrintOn = DbgPrintOn;
 		DbgPrintOn = 0;
 		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
-		profile_dump_dt(Novfs_root, LocalPrint);
+		dump(novfs_root, LocalPrint);
 	}
 
-	retval = profile_common_read(buf, len, off);
+	retval = common_read(buf, len, off);
 
 	if (0 == retval) {
 		DbgPrintBufferOffset = DbgPrintBufferReadOffset = 0;
@@ -585,7 +610,7 @@ static ssize_t profile_dentry_read(struc
 
 }
 
-uint64_t get_nanosecond_time(void)
+uint64_t get_nanosecond_time()
 {
 	struct timespec ts;
 	uint64_t retVal;
@@ -599,15 +624,12 @@ uint64_t get_nanosecond_time(void)
 	return (retVal);
 }
 
-int init_profile(void)
+void novfs_profile_init()
 {
-	int retCode = 0;
-
-	if (Novfs_Procfs_dir) {
-		dbg_dir = Novfs_Procfs_dir;
-	} else {
+	if (novfs_procfs_dir)
+		dbg_dir = novfs_procfs_dir;
+	else
 		dbg_dir = proc_mkdir(MODULE_NAME, NULL);
-	}
 
 	if (dbg_dir) {
 		dbg_dir->owner = THIS_MODULE;
@@ -620,8 +642,10 @@ int init_profile(void)
 			dbg_file->size = DBGBUFFERSIZE;
 			memcpy(&Dbg_proc_file_operations, dbg_file->proc_fops,
 			       sizeof(struct file_operations));
-			Dbg_proc_file_operations.read = User_proc_read_DbgBuffer;
-			Dbg_proc_file_operations.write = User_proc_write_DbgBuffer;
+			Dbg_proc_file_operations.read =
+			    User_proc_read_DbgBuffer;
+			Dbg_proc_file_operations.write =
+			    User_proc_write_DbgBuffer;
 			dbg_file->proc_fops = &Dbg_proc_file_operations;
 		} else {
 			remove_proc_entry(MODULE_NAME, NULL);
@@ -640,7 +664,8 @@ int init_profile(void)
 				       inode_file->proc_fops,
 				       sizeof(struct file_operations));
 				inode_proc_file_ops.owner = THIS_MODULE;
-				inode_proc_file_ops.read = profile_inode_read;
+				inode_proc_file_ops.read =
+					novfs_profile_read_inode;
 				inode_file->proc_fops = &inode_proc_file_ops;
 			}
 
@@ -653,32 +678,30 @@ int init_profile(void)
 				       dentry_file->proc_fops,
 				       sizeof(struct file_operations));
 				dentry_proc_file_ops.owner = THIS_MODULE;
-				dentry_proc_file_ops.read = profile_dentry_read;
+				dentry_proc_file_ops.read = novfs_profile_dentry_read;
 				dentry_file->proc_fops = &dentry_proc_file_ops;
 			}
+
 		} else {
 			vfree(DbgPrintBuffer);
 			DbgPrintBuffer = NULL;
 		}
 	}
-	return (retCode);
 }
 
-void uninit_profile(void)
+void novfs_profile_exit(void)
 {
-	if (dbg_file) {
-		DbgPrint("Calling remove_proc_entry(Debug, NULL)\n");
-		remove_proc_entry("Debug", dbg_dir);
-	}
-	if (inode_file) {
-		DbgPrint("Calling remove_proc_entry(inode, NULL)\n");
-		remove_proc_entry("inode", dbg_dir);
-	}
-	if (dentry_file) {
-		DbgPrint("Calling remove_proc_entry(dentry, NULL)\n");
-		remove_proc_entry("dentry", dbg_dir);
-	}
-	if (dbg_dir && (dbg_dir != Novfs_Procfs_dir)) {
+	if (dbg_file)
+		DbgPrint("Calling remove_proc_entry(Debug, NULL)\n"),
+		    remove_proc_entry("Debug", dbg_dir);
+	if (inode_file)
+		DbgPrint("Calling remove_proc_entry(inode, NULL)\n"),
+		    remove_proc_entry("inode", dbg_dir);
+	if (dentry_file)
+		DbgPrint("Calling remove_proc_entry(dentry, NULL)\n"),
+		    remove_proc_entry("dentry", dbg_dir);
+
+	if (dbg_dir && (dbg_dir != novfs_procfs_dir)) {
 		DbgPrint("Calling remove_proc_entry(%s, NULL)\n", MODULE_NAME);
 		remove_proc_entry(MODULE_NAME, NULL);
 	}
--- a/fs/novfs/scope.c
+++ b/fs/novfs/scope.c
@@ -33,55 +33,40 @@
 #define CLEANUP_INTERVAL      10
 #define MAX_USERNAME_LENGTH   32
 
-struct scope_list {
-	struct list_head entry;
-	struct schandle ScopeId;
-	struct schandle SessionId;
-	pid_t ScopePid;
-	struct task_struct *ScopeTask;
-	unsigned int ScopeHash;
-	uid_t ScopeUid;
-	u64 ScopeUSize;
-	u64 ScopeUFree;
-	u64 ScopeUTEnties;
-	u64 ScopeUAEnties;
-	int ScopeUserNameLength;
-	unsigned char ScopeUserName[MAX_USERNAME_LENGTH];
-};
 
 static struct list_head Scope_List;
 static struct semaphore Scope_Lock;
 static struct semaphore Scope_Thread_Delay;
-static int Scope_Thread_Terminate;
+static int Scope_Thread_Terminate = 0;
 static struct timer_list Scope_Timer;
 static unsigned int Scope_Hash_Val = 1;
 
-static struct scope_list *Scope_Search4Scope(struct schandle *Id, bool Session,
-					     bool Locked)
+static struct novfs_scope_list *Scope_Search4Scope(struct novfs_schandle Id,
+		int Session, int Locked)
 {
-	struct scope_list *scope;
-	struct scope_list *rscope = NULL;
-	struct schandle *cur_scope;
+	struct novfs_scope_list *scope, *rscope = NULL;
+	struct novfs_schandle cur_scope;
 	struct list_head *sl;
 	int offset;
 
-	DbgPrint("Scope_Search4Scope: 0x%p:%p 0x%x 0x%x\n",
-		 Id->hTypeId, Id->hId, Session, Locked);
+	DbgPrint("Scope_Search4Scope: 0x%p:%p 0x%x 0x%x\n", Id.hTypeId, Id.hId,
+		 Session, Locked);
 
 	if (Session)
-		offset = offsetof(struct scope_list, SessionId);
+		offset = offsetof(struct novfs_scope_list, SessionId);
 	else
-		offset = offsetof(struct scope_list, ScopeId);
+		offset = offsetof(struct novfs_scope_list, ScopeId);
 
-	if (!Locked)
+	if (!Locked) {
 		down(&Scope_Lock);
+	}
 
 	sl = Scope_List.next;
 	DbgPrint("Scope_Search4Scope: 0x%p\n", sl);
 	while (sl != &Scope_List) {
-		scope = list_entry(sl, struct scope_list, entry);
+		scope = list_entry(sl, struct novfs_scope_list, ScopeList);
 
-		cur_scope = (session_t *) ((char *)scope + offset);
+		cur_scope = *(struct novfs_schandle *) ((char *)scope + offset);
 		if (SC_EQUAL(Id, cur_scope)) {
 			rscope = scope;
 			break;
@@ -90,19 +75,19 @@ static struct scope_list *Scope_Search4S
 		sl = sl->next;
 	}
 
-	if (!Locked)
+	if (!Locked) {
 		up(&Scope_Lock);
+	}
 
 	DbgPrint("Scope_Search4Scope: return 0x%p\n", rscope);
-	return rscope;
+	return (rscope);
 }
 
-static struct scope_list *Scope_Find_Scope(bool Create)
+static struct novfs_scope_list *Scope_Find_Scope(int Create)
 {
-	struct scope_list *scope = NULL;
-	struct scope_list *pscope = NULL;
+	struct novfs_scope_list *scope = NULL, *pscope = NULL;
 	struct task_struct *task;
-	struct schandle scopeId;
+	struct novfs_schandle scopeId;
 	int addscope = 0;
 
 	task = current;
@@ -110,84 +95,94 @@ static struct scope_list *Scope_Find_Sco
 	DbgPrint("Scope_Find_Scope: %d %d %d %d\n", task->uid, task->euid,
 		 task->suid, task->fsuid);
 
-	/* scopeId = task->euid; */
+	//scopeId = task->euid;
 	UID_TO_SCHANDLE(scopeId, task->euid);
 
-	scope = Scope_Search4Scope(&scopeId, 0, 0);
-	if (scope || (!Create))
-		return scope;
+	scope = Scope_Search4Scope(scopeId, 0, 0);
 
-	scope = kmalloc(sizeof(*pscope), GFP_KERNEL);
-	if (!scope)
-		return NULL;
-	scope->ScopeId = scopeId;
-	SC_INITIALIZE(scope->SessionId);
-	scope->ScopePid = task->pid;
-	scope->ScopeTask = task;
-	scope->ScopeHash = 0;
-	scope->ScopeUid = task->euid;
-	scope->ScopeUserName[0] = '\0';
-
-	if (!Daemon_CreateSessionId(&scope->SessionId)) {
-		DbgPrint("Scope_Find_Scope2: %d %d %d %d\n", task->uid,
-			 task->euid, task->suid, task->fsuid);
-		memset(scope->ScopeUserName, 0, sizeof(scope->ScopeUserName));
-		scope->ScopeUserNameLength = 0;
-		Daemon_getpwuid(task->euid, sizeof(scope->ScopeUserName),
-				scope->ScopeUserName);
-		scope->ScopeUserNameLength = strlen(scope->ScopeUserName);
-		addscope = 1;
-	}
-
-	scope->ScopeHash = Scope_Hash_Val++;
-	DbgPrint("Scope_Find_Scope: Adding 0x%p\n"
-		 "   ScopeId:             0x%p:%p\n"
-		 "   SessionId:           0x%p:%p\n"
-		 "   ScopePid:            %d\n"
-		 "   ScopeTask:           0x%p\n"
-		 "   ScopeHash:           %u\n"
-		 "   ScopeUid:            %u\n"
-		 "   ScopeUserNameLength: %u\n"
-		 "   ScopeUserName:       %s\n",
-		 scope,
-		 scope->ScopeId.hTypeId, scope->ScopeId.hId,
-		 scope->SessionId.hTypeId, scope->SessionId.hId,
-		 scope->ScopePid,
-		 scope->ScopeTask,
-		 scope->ScopeHash,
-		 scope->ScopeUid,
-		 scope->ScopeUserNameLength,
-		 scope->ScopeUserName);
+	if (!scope && Create) {
+		scope = kmalloc(sizeof(*pscope), GFP_KERNEL);
+		if (scope) {
+			scope->ScopeId = scopeId;
+			SC_INITIALIZE(scope->SessionId);
+			scope->ScopePid = task->pid;
+			scope->ScopeTask = task;
+			scope->ScopeHash = 0;
+			scope->ScopeUid = task->euid;
+			scope->ScopeUserName[0] = '\0';
+
+			if (!novfs_daemon_create_sessionId(&scope->SessionId)) {
+				DbgPrint("Scope_Find_Scope2: %d %d %d %d\n",
+					 task->uid, task->euid, task->suid,
+					 task->fsuid);
+				memset(scope->ScopeUserName, 0,
+				       sizeof(scope->ScopeUserName));
+				scope->ScopeUserNameLength = 0;
+				novfs_daemon_getpwuid(task->euid,
+						sizeof(scope->ScopeUserName),
+						scope->ScopeUserName);
+				scope->ScopeUserNameLength =
+				    strlen(scope->ScopeUserName);
+				addscope = 1;
+			}
 
-	if (SC_PRESENT(scope->SessionId)) {
-		down(&Scope_Lock);
-		pscope = Scope_Search4Scope(&scopeId, 0, 1);
-		if (!pscope)
-			list_add(&scope->entry, &Scope_List);
-		up(&Scope_Lock);
+			scope->ScopeHash = Scope_Hash_Val++;
+			DbgPrint("Scope_Find_Scope: Adding 0x%p\n"
+				 "   ScopeId:             0x%p:%p\n"
+				 "   SessionId:           0x%p:%p\n"
+				 "   ScopePid:            %d\n"
+				 "   ScopeTask:           0x%p\n"
+				 "   ScopeHash:           %u\n"
+				 "   ScopeUid:            %u\n"
+				 "   ScopeUserNameLength: %u\n"
+				 "   ScopeUserName:       %s\n",
+				 scope,
+				 scope->ScopeId.hTypeId, scope->ScopeId.hId,
+				 scope->SessionId.hTypeId, scope->SessionId.hId,
+				 scope->ScopePid,
+				 scope->ScopeTask,
+				 scope->ScopeHash,
+				 scope->ScopeUid,
+				 scope->ScopeUserNameLength,
+				 scope->ScopeUserName);
+
+			if (SC_PRESENT(scope->SessionId)) {
+				down(&Scope_Lock);
+				pscope =
+				    Scope_Search4Scope(scopeId, 0, 1);
+
+				if (!pscope) {
+					list_add(&scope->ScopeList,
+						 &Scope_List);
+				}
+				up(&Scope_Lock);
 
-		if (pscope) {
-			printk(KERN_ERR "Scope_Find_Scope scope not added "
-			       "because it was already there...\n");
-			Daemon_DestroySessionId(&scope->SessionId);
-			kfree(scope);
-			scope = pscope;
-			addscope = 0;
+				if (pscope) {
+					printk
+					    ("<6>Scope_Find_Scope scope not added because it was already there...\n");
+					novfs_daemon_destroy_sessionId(scope->
+								SessionId);
+					kfree(scope);
+					scope = pscope;
+					addscope = 0;
+				}
+			} else {
+				kfree(scope);
+				scope = NULL;
+			}
 		}
-	} else {
-		kfree(scope);
-		scope = NULL;
-	}
 
-	if (addscope)
-		Novfs_Add_to_Root(scope->ScopeUserName);
+		if (addscope) {
+			novfs_add_to_root(scope->ScopeUserName);
+		}
+	}
 
-	return scope;
+	return (scope);
 }
 
-static int Scope_Validate_Scope(struct scope_list *Scope)
+static int Scope_Validate_Scope(struct novfs_scope_list *Scope)
 {
-	struct scope_list *s;
+	struct novfs_scope_list *s;
 	struct list_head *sl;
 	int retVal = 0;
 
@@ -197,7 +192,7 @@ static int Scope_Validate_Scope(struct s
 
 	sl = Scope_List.next;
 	while (sl != &Scope_List) {
-		s = list_entry(sl, struct scope_list, entry);
+		s = list_entry(sl, struct novfs_scope_list, ScopeList);
 
 		if (s == Scope) {
 			retVal = 1;
@@ -209,28 +204,24 @@ static int Scope_Validate_Scope(struct s
 
 	up(&Scope_Lock);
 
-	return retVal;
+	return (retVal);
 }
 
-/* FIXME void stuff */
-uid_t Scope_Get_Uid(void *foo)
+uid_t novfs_scope_get_uid(struct novfs_scope_list *scope)
 {
-	struct scope_list *scope = foo;
 	uid_t uid = 0;
-
 	if (!scope)
 		scope = Scope_Find_Scope(1);
 
 	if (scope && Scope_Validate_Scope(scope))
 		uid = scope->ScopeUid;
-
 	return uid;
 }
 
-char *Scope_Get_UserName(void)
+char *novfs_scope_get_username(void)
 {
 	char *name = NULL;
-	struct scope_list *Scope;
+	struct novfs_scope_list *Scope;
 
 	Scope = Scope_Find_Scope(1);
 
@@ -240,12 +231,10 @@ char *Scope_Get_UserName(void)
 	return name;
 }
 
-/* FIXME the void * needs to get fixed... */
-session_t Scope_Get_SessionId(void *foo)
+struct novfs_schandle novfs_scope_get_sessionId(struct novfs_scope_list
+		*Scope)
 {
-	session_t sessionId;
-	struct scope_list *Scope = foo;
-
+	struct novfs_schandle sessionId;
 	DbgPrint("Scope_Get_SessionId: 0x%p\n", Scope);
 	SC_INITIALIZE(sessionId);
 	if (!Scope)
@@ -253,43 +242,43 @@ session_t Scope_Get_SessionId(void *foo)
 
 	if (Scope && Scope_Validate_Scope(Scope))
 		sessionId = Scope->SessionId;
-
 	DbgPrint("Scope_Get_SessionId: return 0x%p:%p\n", sessionId.hTypeId,
 		 sessionId.hId);
-	return sessionId;
+	return (sessionId);
 }
 
-struct scope_list *Scope_Get_ScopefromName(struct qstr *name)
+struct novfs_scope_list *novfs_get_scope_from_name(struct qstr * Name)
 {
-	struct scope_list *scope;
-	struct scope_list *rscope = NULL;
+	struct novfs_scope_list *scope, *rscope = NULL;
 	struct list_head *sl;
 
-	DbgPrint("Scope_Get_ScopefromName: %.*s\n", name->len, name->name);
+	DbgPrint("Scope_Get_ScopefromName: %.*s\n", Name->len, Name->name);
 
 	down(&Scope_Lock);
 
 	sl = Scope_List.next;
 	while (sl != &Scope_List) {
-		scope = list_entry(sl, struct scope_list, entry);
+		scope = list_entry(sl, struct novfs_scope_list, ScopeList);
 
-		if ((name->len == scope->ScopeUserNameLength) &&
-		    (strncmp(scope->ScopeUserName, name->name, name->len) == 0)) {
+		if ((Name->len == scope->ScopeUserNameLength) &&
+		    (0 == strncmp(scope->ScopeUserName, Name->name, Name->len)))
+		{
 			rscope = scope;
 			break;
 		}
+
 		sl = sl->next;
 	}
 
 	up(&Scope_Lock);
 
-	return rscope;
+	return (rscope);
 }
 
-int Scope_Set_UserSpace(u64 *TotalSize, u64 *Free,
-			u64 *TotalEnties, u64 *FreeEnties)
+int novfs_scope_set_userspace(uint64_t * TotalSize, uint64_t * Free,
+			uint64_t * TotalEnties, uint64_t * FreeEnties)
 {
-	struct scope_list *scope;
+	struct novfs_scope_list *scope;
 	int retVal = 0;
 
 	scope = Scope_Find_Scope(1);
@@ -305,24 +294,24 @@ int Scope_Set_UserSpace(u64 *TotalSize,
 			scope->ScopeUAEnties = *FreeEnties;
 	}
 
-	return retVal;
+	return (retVal);
 }
 
-int Scope_Get_UserSpace(u64 *TotalSize, u64 *Free,
-			u64 *TotalEnties, u64 *FreeEnties)
+int novfs_scope_get_userspace(uint64_t * TotalSize, uint64_t * Free,
+			uint64_t * TotalEnties, uint64_t * FreeEnties)
 {
-	struct scope_list *scope;
+	struct novfs_scope_list *scope;
 	int retVal = 0;
 
-	u64 td, fd, te, fe;
+	uint64_t td, fd, te, fe;
 
 	scope = Scope_Find_Scope(1);
 
 	td = fd = te = fe = 0;
 	if (scope) {
 
-		retVal = Daemon_Get_UserSpace(&scope->SessionId,
-					      &td, &fd, &te, &fe);
+		retVal =
+		    novfs_daemon_get_userspace(scope->SessionId, &td, &fd, &te, &fe);
 
 		scope->ScopeUSize = td;
 		scope->ScopeUFree = fd;
@@ -339,18 +328,18 @@ int Scope_Get_UserSpace(u64 *TotalSize,
 	if (FreeEnties)
 		*FreeEnties = fe;
 
-	return retVal;
+	return (retVal);
 }
 
-struct scope_list *Scope_Get_ScopefromPath(struct dentry *dentry)
+struct novfs_scope_list *novfs_get_scope(struct dentry * Dentry)
 {
-	struct scope_list *scope = NULL;
+	struct novfs_scope_list *scope = NULL;
 	char *buf, *path, *cp;
 	struct qstr name;
 
-	buf = kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
+	buf = (char *)kmalloc(PATH_LENGTH_BUFFER, GFP_KERNEL);
 	if (buf) {
-		path = Scope_dget_path(dentry, buf, PATH_LENGTH_BUFFER, 0);
+		path = novfs_scope_dget_path(Dentry, buf, PATH_LENGTH_BUFFER, 0);
 		if (path) {
 			DbgPrint("Scope_Get_ScopefromPath: %s\n", path);
 
@@ -366,29 +355,30 @@ struct scope_list *Scope_Get_ScopefromPa
 				name.hash = 0;
 				name.len = (int)(cp - path);
 				name.name = path;
-				scope = Scope_Get_ScopefromName(&name);
+				scope = novfs_get_scope_from_name(&name);
 			}
 		}
 		kfree(buf);
 	}
 
-	return scope;
+	return (scope);
 }
 
-static char *add_to_list(char *name, char *list, char *endoflist)
+static char *add_to_list(char *Name, char *List, char *EndOfList)
 {
-	while (*name && (list < endoflist))
-		*list++ = *name++;
-
-	if (list < endoflist)
-		*list++ = '\0';
+	while (*Name && (List < EndOfList)) {
+		*List++ = *Name++;
+	}
 
-	return list;
+	if (List < EndOfList) {
+		*List++ = '\0';
+	}
+	return (List);
 }
 
-char *Scope_Get_ScopeUsers(void)
+char *novfs_get_scopeusers(void)
 {
-	struct scope_list *scope;
+	struct novfs_scope_list *scope;
 	struct list_head *sl;
 	int asize = 8 * MAX_USERNAME_LENGTH;
 	char *list, *cp, *ep;
@@ -413,7 +403,7 @@ char *Scope_Get_ScopeUsers(void)
 
 			sl = Scope_List.next;
 			while ((sl != &Scope_List) && (cp < ep)) {
-				scope = list_entry(sl, struct scope_list, entry);
+				scope = list_entry(sl, struct novfs_scope_list, ScopeList);
 
 				DbgPrint("Scope_Get_ScopeUsers found 0x%p %s\n",
 					 scope, scope->ScopeUserName);
@@ -429,6 +419,7 @@ char *Scope_Get_ScopeUsers(void)
 				*cp++ = '\0';
 				asize = 0;
 			} else {	/* Allocation was to small, up size */
+
 				asize *= 4;
 				kfree(list);
 				list = NULL;
@@ -437,12 +428,12 @@ char *Scope_Get_ScopeUsers(void)
 
 			break;
 		}
-	} while (!list);	/* list was to small try again */
+	} while (!list);	/* List was to small try again */
 
-	return list;
+	return (list);
 }
 
-void *Scope_Lookup(void)
+void *novfs_scope_lookup(void)
 {
 	return Scope_Find_Scope(1);
 }
@@ -454,8 +445,7 @@ static void Scope_Timer_Function(unsigne
 
 static int Scope_Cleanup_Thread(void *Args)
 {
-	struct scope_list *scope;
-	struct scope_list *rscope;
+	struct novfs_scope_list *scope, *rscope;
 	struct list_head *sl, cleanup;
 	struct task_struct *task;
 
@@ -468,8 +458,9 @@ static int Scope_Cleanup_Thread(void *Ar
 
 	while (0 == Scope_Thread_Terminate) {
 		DbgPrint("Scope_Cleanup_Thread: looping\n");
-		if (Scope_Thread_Terminate)
+		if (Scope_Thread_Terminate) {
 			break;
+		}
 
 		/*
 		 * Check scope list for any terminated processes
@@ -480,7 +471,7 @@ static int Scope_Cleanup_Thread(void *Ar
 		INIT_LIST_HEAD(&cleanup);
 
 		while (sl != &Scope_List) {
-			scope = list_entry(sl, struct scope_list, entry);
+			scope = list_entry(sl, struct novfs_scope_list, ScopeList);
 			sl = sl->next;
 
 			rscope = NULL;
@@ -495,7 +486,7 @@ static int Scope_Cleanup_Thread(void *Ar
 			rcu_read_unlock();
 
 			if (!rscope) {
-				list_move(&scope->entry, &cleanup);
+				list_move(&scope->ScopeList, &cleanup);
 				DbgPrint("Scope_Cleanup_Thread: Scope=0x%p\n",
 					 rscope);
 			}
@@ -505,7 +496,7 @@ static int Scope_Cleanup_Thread(void *Ar
 
 		sl = cleanup.next;
 		while (sl != &cleanup) {
-			scope = list_entry(sl, struct scope_list, entry);
+			scope = list_entry(sl, struct novfs_scope_list, ScopeList);
 			sl = sl->next;
 
 			DbgPrint("Scope_Cleanup_Thread: Removing 0x%p\n"
@@ -523,9 +514,9 @@ static int Scope_Cleanup_Thread(void *Ar
 				 scope->ScopeTask,
 				 scope->ScopeHash,
 				 scope->ScopeUid, scope->ScopeUserName);
-			if (!Scope_Search4Scope(&scope->SessionId, 1, 0)) {
-				Novfs_Remove_from_Root(scope->ScopeUserName);
-				Daemon_DestroySessionId(&scope->SessionId);
+			if (!Scope_Search4Scope(scope->SessionId, 1, 0)) {
+				novfs_remove_from_root(scope->ScopeUserName);
+				novfs_daemon_destroy_sessionId(scope->SessionId);
 			}
 			kfree(scope);
 		}
@@ -536,21 +527,21 @@ static int Scope_Cleanup_Thread(void *Ar
 		add_timer(&Scope_Timer);
 		DbgPrint("Scope_Cleanup_Thread: sleeping\n");
 
-		if (down_interruptible(&Scope_Thread_Delay))
+		if (down_interruptible(&Scope_Thread_Delay)) {
 			break;
-
+		}
 		del_timer(&Scope_Timer);
 	}
 	Scope_Thread_Terminate = 0;
 
 	printk(KERN_INFO "Scope_Cleanup_Thread: Exit\n");
 	DbgPrint("Scope_Cleanup_Thread: Exit\n");
-	return 0;
+	return (0);
 }
 
-void Scope_Cleanup(void)
+void novfs_scope_cleanup(void)
 {
-	struct scope_list *scope;
+	struct novfs_scope_list *scope;
 	struct list_head *sl;
 
 	DbgPrint("Scope_Cleanup:\n");
@@ -563,10 +554,10 @@ void Scope_Cleanup(void)
 	sl = Scope_List.next;
 
 	while (sl != &Scope_List) {
-		scope = list_entry(sl, struct scope_list, entry);
+		scope = list_entry(sl, struct novfs_scope_list, ScopeList);
 		sl = sl->next;
 
-		list_del(&scope->entry);
+		list_del(&scope->ScopeList);
 
 		DbgPrint("Scope_Cleanup: Removing 0x%p\n"
 			 "   ScopeId:       0x%p:%p\n"
@@ -583,9 +574,9 @@ void Scope_Cleanup(void)
 			 scope->ScopeTask,
 			 scope->ScopeHash,
 			 scope->ScopeUid, scope->ScopeUserName);
-		if (!Scope_Search4Scope(&scope->SessionId, 1, 1)) {
-			Novfs_Remove_from_Root(scope->ScopeUserName);
-			Daemon_DestroySessionId(&scope->SessionId);
+		if (!Scope_Search4Scope(scope->SessionId, 1, 1)) {
+			novfs_remove_from_root(scope->ScopeUserName);
+			novfs_daemon_destroy_sessionId(scope->SessionId);
 		}
 		kfree(scope);
 	}
@@ -595,19 +586,13 @@ void Scope_Cleanup(void)
 }
 
 /*
- *  Arguments:   struct dentry *dentry - starting entry
- *               char *Buf - pointer to memory buffer
- *               unsigned int Buflen - size of memory buffer
- *
- *  Returns:     pointer to path.
- *
- *  Abstract:    Walks the dentry chain building a path.
+ *  Walks the dentry chain building a path.
  */
-char *Scope_dget_path(struct dentry *dentry, char *Buf, unsigned int Buflen,
+char *novfs_scope_dget_path(struct dentry *Dentry, char *Buf, unsigned int Buflen,
 		int Flags)
 {
 	char *retval = &Buf[Buflen];
-	struct dentry *p = dentry;
+	struct dentry *p = Dentry;
 	int len;
 
 	*(--retval) = '\0';
@@ -627,8 +612,9 @@ char *Scope_dget_path(struct dentry *den
 		}
 	} while (!IS_ROOT(p));
 
-	if (IS_ROOT(dentry))
+	if (IS_ROOT(Dentry)) {
 		retval++;
+	}
 
 	if (Flags) {
 		len = strlen(p->d_sb->s_type->name);
@@ -641,19 +627,18 @@ char *Scope_dget_path(struct dentry *den
 		}
 	}
 
-	return retval;
+	return (retval);
 }
 
-void Scope_Init(void)
+void novfs_scope_init(void)
 {
 	INIT_LIST_HEAD(&Scope_List);
 	init_MUTEX(&Scope_Lock);
 	init_MUTEX_LOCKED(&Scope_Thread_Delay);
-
 	kthread_run(Scope_Cleanup_Thread, NULL, "novfs_ST");
 }
 
-void Scope_Uninit(void)
+void novfs_scope_exit(void)
 {
 	unsigned long expires = jiffies + HZ * SHUTDOWN_INTERVAL;
 
@@ -666,7 +651,6 @@ void Scope_Uninit(void)
 	mb();
 	while (Scope_Thread_Terminate && (jiffies < expires))
 		yield();
-
 	/* down(&Scope_Thread_Delay); */
 	printk(KERN_INFO "Scope_Uninit: Exit\n");
 
--- a/fs/novfs/vfs.h
+++ b/fs/novfs/vfs.h
@@ -20,37 +20,31 @@
 
 #include <linux/version.h>
 #include <linux/namei.h>
-#include <linux/string.h>
 
 #include "nwcapi.h"
 
-typedef void *HANDLE;
 
-struct schandle {
-	void *hTypeId;
-	void *hId;
-};
-
-static inline void copy_schandle(struct schandle *dest, struct schandle *source)
-{
-	memcpy(dest, source, sizeof(struct schandle));
-}
-#define copy_session_id	copy_schandle
+#ifndef  XTIER_SCHANDLE
+struct novfs_schandle {
+	void * hTypeId;
+	void * hId;
 
-typedef struct schandle session_t;
+};
 
 #include "commands.h"
 
 #define SC_PRESENT(X)		((X.hTypeId != NULL) || (X.hId != NULL)) ? 1 : 0
-#define SC_EQUAL(X, Y)		((X->hTypeId == Y->hTypeId) && (X->hId == Y->hId)) ? 1 : 0
+#define SC_EQUAL(X, Y)		((X.hTypeId == Y.hTypeId) && (X.hId == Y.hId)) ? 1 : 0
 #define SC_INITIALIZE(X)	{X.hTypeId = X.hId = NULL;}
 
 #define UID_TO_SCHANDLE(hSC, uid)	\
 		{ \
 			hSC.hTypeId = NULL; \
-			hSC.hId = (HANDLE)(unsigned long)(uid); \
+			hSC.hId = (void *)(unsigned long)(uid); \
 		}
 
+#define XTIER_SCHANDLE
+#endif
 
 
 /*===[ Manifest constants ]===============================================*/
@@ -71,16 +65,6 @@ typedef struct schandle session_t;
 #define IOC_SESSION		0x4a540003
 #define IOC_DEBUGPRINT		0x4a540004
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
-#define D_CHILD d_u.d_child
-#define AS_TREE_LOCK(l)   read_lock_irq(l)
-#define AS_TREE_UNLOCK(l) read_unlock_irq(l)
-#else
-#define D_CHILD d_child
-#define AS_TREE_LOCK(l)   spin_lock_irq(l)
-#define AS_TREE_UNLOCK(l) spin_unlock_irq(l)
-#endif
-
 /*
  * NetWare file attributes
  */
@@ -96,7 +80,7 @@ typedef struct schandle session_t;
 #define NW_ATTRIBUTE_SHAREABLE		0x80
 
 /*
- * Define READ/WRITE flag for struct data_list
+ * Define READ/WRITE flag for DATA_LIST
  */
 #define DLREAD		0
 #define DLWRITE		1
@@ -156,7 +140,8 @@ typedef struct schandle session_t;
          DEFINE_TO_STR(NOVFS_VFS_RELEASE) \
          "\0"
 
-struct entry_info {
+/*===[ Type definitions ]=================================================*/
+struct novfs_entry_info {
 	int type;
 	umode_t mode;
 	uid_t uid;
@@ -174,17 +159,17 @@ struct novfs_string {
 	unsigned char *data;
 };
 
-struct login {
+struct novfs_login {
 	struct novfs_string Server;
 	struct novfs_string UserName;
 	struct novfs_string Password;
 };
 
-struct logout {
+struct novfs_logout {
 	struct novfs_string Server;
 };
 
-struct dir_cache {
+struct novfs_dir_cache {
 	struct list_head list;
 	int flags;
 	u64 jiffies;
@@ -199,7 +184,7 @@ struct dir_cache {
 	char name[1];
 };
 
-struct data_list {
+struct novfs_data_list {
 	void *page;
 	void *offset;
 	int len;
@@ -209,227 +194,256 @@ struct data_list {
 
 extern char *ctime_r(time_t * clock, char *buf);
 
-static inline u32 HandletoUint32(HANDLE h)
 /*
- *
- *  Arguments:   HANDLE h - handle value
- *
- *  Returns:     u32 - u32 value
- *
- *  Abstract:    Converts a HANDLE to a u32 type.
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+ *  Converts a HANDLE to a u32 type.
+ */
+static inline u32 HandletoUint32(void * h)
 {
 	return (u32) ((unsigned long) h);
 }
 
-/*++======================================================================*/
-static inline HANDLE Uint32toHandle(u32 ui32)
 /*
- *
- *  Arguments:   u32 ui32
- *
- *  Returns:     HANDLE - Handle type.
- *
- *  Abstract:    Converts a u32 to a HANDLE type.
- *
- *  Notes:
- *
- *  Environment:
- *
- *========================================================================*/
+ * Converts a u32 to a HANDLE type.
+ */
+static inline void *Uint32toHandle(u32 ui32)
 {
-	return ((HANDLE) (unsigned long) ui32);
+	return ((void *) (unsigned long) ui32);
 }
 
 /* Global variables */
 
-extern int Novfs_Version_Major;
-extern int Novfs_Version_Minor;
-extern int Novfs_Version_Sub;
-extern int Novfs_Version_Release;
-extern struct dentry *Novfs_root;
-extern struct proc_dir_entry *Novfs_Procfs_dir;
-extern unsigned long File_update_timeout;
-extern int PageCache;
-extern char *Novfs_CurrentMount;
-extern struct dentry_operations Novfs_dentry_operations;
-extern int MaxIoSize;
+extern struct dentry *novfs_root;
+extern struct proc_dir_entry *novfs_procfs_dir;
+extern unsigned long novfs_update_timeout;
+extern int novfs_page_cache;
+extern char *novfs_current_mnt;
+extern int novfs_max_iosize;
 
 
 /* Global functions */
-extern int Novfs_Remove_from_Root(char *);
-extern void Novfs_dump_inode(void *pf);
+extern int novfs_remove_from_root(char *);
+extern void novfs_dump_inode(void *pf);
 
-extern void mydump(int size, void *dumpptr);
+extern void novfs_dump(int size, void *dumpptr);
 
 extern int Queue_Daemon_Command(void *request, unsigned long reqlen, void *data,
 				int dlen, void **reply, unsigned long * replen,
 				int interruptible);
+extern int novfs_do_login(struct ncl_string * Server, struct ncl_string* Username, struct ncl_string * Password, void **lgnId, struct novfs_schandle *Session);
 
-extern int Init_Procfs_Interface(void);
-extern void Uninit_Procfs_Interface(void);
+extern int novfs_proc_init(void);
+extern void novfs_proc_exit(void);
 
 /*
  * daemon.c functions
  */
-extern void Init_Daemon_Queue(void);
-extern void Uninit_Daemon_Queue(void);
-extern int do_login(NclString * Server, NclString * Username, NclString * Password, HANDLE * lgnId, struct schandle *Session);
-extern int do_logout(struct qstr *Server, struct schandle *Session);
-extern int Daemon_SetMountPoint(char *Path);
-extern int Daemon_CreateSessionId(struct schandle *SessionId);
-extern int Daemon_DestroySessionId(struct schandle *SessionId);
-extern int Daemon_getpwuid(uid_t uid, int unamelen, char *uname);
-extern int Daemon_Get_UserSpace(struct schandle *session_id, u64 *TotalSize,
-				u64 *TotalFree, u64 *TotalDirectoryEnties,
-				u64 *FreeDirectoryEnties);
-extern int Daemon_SendDebugCmd(char *Command);
-extern ssize_t Daemon_Receive_Reply(struct file *file, const char __user *buf, size_t nbytes, loff_t *ppos);
-extern ssize_t Daemon_Send_Command(struct file *file, char __user *buf, size_t len, loff_t *off);
-extern int Daemon_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
-extern int Daemon_Library_close(struct inode *inode, struct file *file);
-extern int Daemon_Library_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
-extern int Daemon_Library_open(struct inode *inode, struct file *file);
-extern ssize_t Daemon_Library_write(struct file *file, const char __user *buf, size_t len, loff_t * off);
-extern ssize_t Daemon_Library_read(struct file *file, char __user *buf, size_t len, loff_t * off);
-extern loff_t Daemon_Library_llseek(struct file *file, loff_t offset, int origin);
-extern int Daemon_Open_Control(struct inode *Inode, struct file *File);
-extern int Daemon_Close_Control(struct inode *Inode, struct file *File);
-extern int Daemon_getversion(char *Buf, int Length);
+extern void novfs_daemon_queue_init(void);
+extern void novfs_daemon_queue_exit(void);
+extern int novfs_daemon_logout(struct qstr *Server, struct novfs_schandle *Session);
+extern int novfs_daemon_set_mnt_point(char *Path);
+extern int novfs_daemon_create_sessionId(struct novfs_schandle * SessionId);
+extern int novfs_daemon_destroy_sessionId(struct novfs_schandle SessionId);
+extern int novfs_daemon_getpwuid(uid_t uid, int unamelen, char *uname);
+extern int novfs_daemon_get_userspace(struct novfs_schandle SessionId,
+		uint64_t * TotalSize, uint64_t * TotalFree,
+		uint64_t * TotalDirectoryEnties,
+		uint64_t * FreeDirectoryEnties);
+extern int novfs_daemon_debug_cmd_send(char *Command);
+extern ssize_t novfs_daemon_recv_reply(struct file *file,
+		const char *buf, size_t nbytes, loff_t * ppos);
+extern ssize_t novfs_daemon_cmd_send(struct file *file, char *buf,
+		size_t len, loff_t * off);
+extern int novfs_daemon_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg);
+extern int novfs_daemon_lib_close(struct inode *inode, struct file *file);
+extern int novfs_daemon_lib_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg);
+extern int novfs_daemon_lib_open(struct inode *inode, struct file *file);
+extern ssize_t novfs_daemon_lib_read(struct file *file, char *buf,
+		size_t len, loff_t * off);
+extern ssize_t novfs_daemon_lib_write(struct file *file, const char *buf,
+		size_t len, loff_t * off);
+extern loff_t novfs_daemon_lib_llseek(struct file *file, loff_t offset,
+		int origin);
+extern int novfs_daemon_open_control(struct inode *Inode, struct file *File);
+extern int novfs_daemon_close_control(struct inode *Inode, struct file *File);
+extern int novfs_daemon_getversion(char *Buf, int Length);
 
 
 /*
  * file.c functions
  */
-extern int Novfs_get_alltrees(struct dentry *parent);
-extern int Novfs_Get_Connected_Server_List(unsigned char **ServerList, struct schandle *SessionId);
-extern int Novfs_Get_Server_Volume_List(struct qstr *Server, unsigned char **VolumeList, struct schandle *SessionId);
-extern int Novfs_Get_File_Info(unsigned char *Path, struct entry_info *Info, struct schandle *SessionId);
-extern int Novfs_GetX_File_Info(char *Path, const char *Name, char *buffer, ssize_t buffer_size, ssize_t *dataLen, struct schandle *SessionId);
-extern int Novfs_ListX_File_Info(char *Path, char *buffer, ssize_t buffer_size, ssize_t * dataLen, struct schandle *SessionId);
-extern int Novfs_SetX_File_Info(char *Path, const char *Name, const void *Value,
+extern int novfs_verify_file(struct qstr *Path, struct novfs_schandle SessionId);
+extern int novfs_get_alltrees(struct dentry *parent);
+extern int novfs_get_servers(unsigned char **ServerList,
+		struct novfs_schandle SessionId);
+extern int novfs_get_vols(struct qstr *Server,
+		unsigned char **VolumeList, struct novfs_schandle SessionId);
+extern int novfs_get_file_info(unsigned char *Path,
+		struct novfs_entry_info *Info, struct novfs_schandle SessionId);
+extern int novfs_getx_file_info(char *Path, const char *Name,
+		char *buffer, ssize_t buffer_size, ssize_t *dataLen,
+		struct novfs_schandle SessionId);
+extern int novfs_listx_file_info(char *Path, char *buffer,
+		ssize_t buffer_size, ssize_t *dataLen,
+		struct novfs_schandle SessionId);
+extern int novfs_setx_file_info(char *Path, const char *Name, const void *Value,
 				unsigned long valueLen,
 				unsigned long *bytesWritten, int flags,
-				struct schandle *SessionId);
+				struct novfs_schandle SessionId);
 
-extern int Novfs_Get_Directory_ListEx(unsigned char *Path, HANDLE *EnumHandle,
-				      int *Count, struct entry_info **Info,
-				      struct schandle *SessionId);
-extern int Novfs_Open_File(unsigned char *Path, int Flags, struct entry_info *info,
-			   HANDLE * Handle, session_t SessionId);
-extern int Novfs_Create(unsigned char *Path, int DirectoryFlag,
-			session_t SessionId);
-extern int Novfs_Close_File(HANDLE Handle, session_t SessionId);
-extern int Novfs_Read_File(HANDLE Handle, unsigned char *Buffer, size_t * Bytes,
-			   loff_t * Offset, session_t SessionId);
-extern int Novfs_Read_Pages(HANDLE Handle, struct data_list *dlist, int DList_Cnt,
-			    size_t * Bytes, loff_t * Offset,
-			    session_t SessionId);
-extern int Novfs_Write_File(HANDLE Handle, unsigned char *Buffer,
+extern int novfs_get_dir_listex(unsigned char *Path, void **EnumHandle,
+	int *Count, struct novfs_entry_info **Info,
+	struct novfs_schandle SessionId);
+extern int novfs_open_file(unsigned char *Path, int Flags,
+		struct novfs_entry_info * Info, void **Handle,
+		struct novfs_schandle SessionId);
+extern int novfs_create(unsigned char *Path, int DirectoryFlag,
+			struct novfs_schandle SessionId);
+extern int novfs_close_file(void * Handle, struct novfs_schandle SessionId);
+extern int novfs_read_file(void * Handle, unsigned char *Buffer,
+		size_t * Bytes, loff_t * Offset,
+		struct novfs_schandle SessionId);
+extern int novfs_read_pages(void * Handle, struct novfs_data_list *DList,
+		int DList_Cnt, size_t * Bytes, loff_t * Offset,
+			    struct novfs_schandle SessionId);
+extern int novfs_write_file(void * Handle, unsigned char *Buffer,
 			    size_t * Bytes, loff_t * Offset,
-			    session_t SessionId);
-extern int Novfs_Write_Page(HANDLE Handle, struct page *Page,
-			    session_t SessionId);
-extern int Novfs_Write_Pages(HANDLE Handle, struct data_list *dlist, int DList_Cnt,
-			     size_t Bytes, loff_t Offset, session_t SessionId);
-extern int Novfs_Delete(unsigned char *Path, int DirectoryFlag,
-			session_t SessionId);
-extern int Novfs_Truncate_File(unsigned char *Path, int PathLen,
-			       session_t SessionId);
-extern int Novfs_Truncate_File_Ex(HANDLE Handle, loff_t Offset,
-				  session_t SessionId);
-extern int Novfs_Rename_File(int DirectoryFlag, unsigned char *OldName,
+			    struct novfs_schandle SessionId);
+extern int novfs_write_page(void * Handle, struct page *Page,
+			    struct novfs_schandle SessionId);
+extern int novfs_write_pages(void * Handle, struct novfs_data_list *DList,
+		int DList_Cnt, size_t Bytes, loff_t Offset,
+		struct novfs_schandle SessionId);
+extern int novfs_delete(unsigned char *Path, int DirectoryFlag,
+			struct novfs_schandle SessionId);
+extern int novfs_trunc(unsigned char *Path, int PathLen,
+		       struct novfs_schandle SessionId);
+extern int novfs_trunc_ex(void * Handle, loff_t Offset,
+				  struct novfs_schandle SessionId);
+extern int novfs_rename_file(int DirectoryFlag, unsigned char *OldName,
 			     int OldLen, unsigned char *NewName, int NewLen,
-			     session_t SessionId);
-extern int Novfs_Set_Attr(unsigned char *Path, struct iattr *Attr,
-			  session_t SessionId);
-extern int Novfs_Get_File_Cache_Flag(unsigned char * Path, session_t SessionId);
-extern int Novfs_Set_File_Lock(session_t SessionId, HANDLE fhandle,
+			     struct novfs_schandle SessionId);
+extern int novfs_set_attr(unsigned char *Path, struct iattr *Attr,
+			  struct novfs_schandle SessionId);
+extern int novfs_get_file_cache_flag(unsigned char * Path,
+		struct novfs_schandle SessionId);
+extern int novfs_set_file_lock(struct novfs_schandle SessionId, void * fhandle,
 			       unsigned char fl_type, loff_t fl_start,
 			       loff_t len);
 
-extern struct inode *Novfs_get_inode(struct super_block *sb, int mode, int dev, uid_t uid, ino_t ino, struct qstr *name);
-extern int Novfs_Read_Stream(HANDLE ConnHandle, unsigned char * Handle,
+extern struct inode *novfs_get_inode(struct super_block *sb, int mode,
+		int dev, uid_t uid, ino_t ino, struct qstr *name);
+extern int novfs_read_stream(void * ConnHandle, unsigned char * Handle,
 			     unsigned char * Buffer, size_t * Bytes, loff_t * Offset,
-			     int User, session_t SessionId);
-extern int Novfs_Write_Stream(HANDLE ConnHandle, unsigned char * Handle,
+			     int User, struct novfs_schandle SessionId);
+extern int novfs_write_stream(void * ConnHandle, unsigned char * Handle,
 			      unsigned char * Buffer, size_t * Bytes, loff_t * Offset,
-			      session_t SessionId);
-extern int Novfs_Close_Stream(HANDLE ConnHandle, unsigned char * Handle,
-			      session_t SessionId);
+			      struct novfs_schandle SessionId);
+extern int novfs_close_stream(void * ConnHandle, unsigned char * Handle,
+			      struct novfs_schandle SessionId);
 
-extern int Novfs_Add_to_Root(char *);
+extern int novfs_add_to_root(char *);
 
 
 /*
  * scope.c functions
  */
-extern void Scope_Init(void);
-extern void Scope_Uninit(void);
-extern void *Scope_Lookup(void);
-extern uid_t Scope_Get_Uid(void *);
-extern session_t Scope_Get_SessionId(void *Scope);
-//extern session_t Scope_Get_SessionId(PSCOPE_LIST Scope);
-extern char *Scope_Get_ScopeUsers(void);
-extern int Scope_Set_UserSpace(u64 *TotalSize, u64 *Free,
-			       u64 *TotalEnties, u64 *FreeEnties);
-extern int Scope_Get_UserSpace(u64 *TotalSize, u64 *Free,
-			       u64 *TotalEnties, u64 *FreeEnties);
-extern char *Scope_dget_path(struct dentry *Dentry, char *Buf,
+extern void novfs_scope_init(void);
+extern void novfs_scope_exit(void);
+extern void *novfs_scope_lookup(void);
+extern uid_t novfs_scope_get_uid(struct novfs_scope_list *);
+extern struct novfs_schandle novfs_scope_get_sessionId(struct
+		novfs_scope_list *);
+extern char *novfs_get_scopeusers(void);
+extern int novfs_scope_set_userspace(uint64_t * TotalSize, uint64_t * Free,
+			       uint64_t * TotalEnties, uint64_t * FreeEnties);
+extern int novfs_scope_get_userspace(uint64_t * TotalSize, uint64_t * Free,
+			       uint64_t * TotalEnties, uint64_t * FreeEnties);
+extern char *novfs_scope_dget_path(struct dentry *Dentry, char *Buf,
 			     unsigned int Buflen, int Flags);
-extern char *Scope_Get_UserName(void);
-extern void Scope_Cleanup(void);
+extern void novfs_scope_cleanup(void);
+extern struct novfs_scope_list *novfs_get_scope_from_name(struct qstr *);
+extern struct novfs_scope_list *novfs_get_scope(struct dentry *);
+extern char *novfs_scope_get_username(void);
 
 /*
  * profile.c functions
  */
 extern u64 get_nanosecond_time(void);
-static inline void *Novfs_Malloc(size_t size, int flags) { return kmalloc(size, flags); }
 extern int DbgPrint(char *Fmt, ...);
-extern int init_profile(void);
-extern void uninit_profile(void);
+extern void novfs_profile_init(void);
+extern void novfs_profile_exit(void);
 
 /*
  * nwcapi.c functions
  */
-extern int NwAuthConnWithId(PXPLAT pdata, session_t Session);
-extern int NwConnClose(PXPLAT pdata, HANDLE * Handle, session_t Session);
-extern int NwGetConnInfo(PXPLAT pdata, session_t Session);
-extern int NwSetConnInfo(PXPLAT pdata, session_t Session);
-extern int NwGetDaemonVersion(PXPLAT pdata, session_t Session);
-extern int NwGetIdentityInfo(PXPLAT pdata, session_t Session);
-extern int NwLicenseConn(PXPLAT pdata, session_t Session);
-extern int NwLoginIdentity(PXPLAT pdata, struct schandle *Session);
-extern int NwLogoutIdentity(PXPLAT pdata, session_t Session);
-extern int NwOpenConnByAddr(PXPLAT pdata, HANDLE * Handle, session_t Session);
-extern int NwOpenConnByName(PXPLAT pdata, HANDLE * Handle, session_t Session);
-extern int NwOpenConnByRef(PXPLAT pdata, HANDLE * Handle, session_t Session);
-extern int NwQueryFeature(PXPLAT pdata, session_t Session);
-extern int NwRawSend(PXPLAT pdata, session_t Session);
-extern int NwScanConnInfo(PXPLAT pdata, session_t Session);
-extern int NwSysConnClose(PXPLAT pdata, unsigned long * Handle, session_t Session);
-extern int NwUnAuthenticate(PXPLAT pdata, session_t Session);
-extern int NwUnlicenseConn(PXPLAT pdata, session_t Session);
-extern int NwcChangeAuthKey(PXPLAT pdata, session_t Session);
-extern int NwcEnumIdentities(PXPLAT pdata, session_t Session);
-extern int NwcGetDefaultNameCtx(PXPLAT pdata, session_t Session);
-extern int NwcGetPreferredDSTree(PXPLAT pdata, session_t Session);
-extern int NwcGetTreeMonitoredConn(PXPLAT pdata, session_t Session);
-extern int NwcSetDefaultNameCtx(PXPLAT pdata, session_t Session);
-extern int NwcSetPreferredDSTree(PXPLAT pdata, session_t Session);
-extern int NwcSetPrimaryConn(PXPLAT pdata, session_t Session);
-extern int NwcGetPrimaryConn(PXPLAT pdata, session_t Session);
-extern int NwcSetMapDrive(PXPLAT pdata, session_t Session);
-extern int NwcUnMapDrive(PXPLAT pdata, session_t Session);
-extern int NwcEnumerateDrives(PXPLAT pdata, session_t Session);
-extern int NwcGetBroadcastMessage(PXPLAT pdata, session_t Session);
-extern int NwdSetKeyValue(PXPLAT pdata, session_t Session);
-extern int NwdVerifyKeyValue(PXPLAT pdata, session_t Session);
+extern int novfs_auth_conn(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_conn_close(struct novfs_xplat *pdata,
+		void **Handle, struct novfs_schandle Session);
+extern int novfs_get_conn_info(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_set_conn_info(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_get_daemon_ver(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_get_id_info(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_license_conn(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_login_id(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_logout_id(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_open_conn_by_addr(struct novfs_xplat *pdata,
+		void **Handle, struct novfs_schandle Session);
+extern int novfs_open_conn_by_name(struct novfs_xplat *pdata,
+		void **Handle, struct novfs_schandle Session);
+extern int novfs_open_conn_by_ref(struct novfs_xplat *pdata,
+		void **Handle, struct novfs_schandle Session);
+extern int novfs_query_feature(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_raw_send(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_scan_conn_info(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_sys_conn_close(struct novfs_xplat *pdata,
+		unsigned long *Handle, struct novfs_schandle Session);
+extern int novfs_unauthenticate(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_unlicense_conn(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_change_auth_key(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_enum_ids(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_get_default_ctx(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_get_preferred_DS_tree(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_get_tree_monitored_conn(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_set_default_ctx(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_set_preferred_DS_tree(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_set_pri_conn(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_get_pri_conn(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_set_map_drive(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_unmap_drive(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_enum_drives(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_get_bcast_msg(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_set_key_value(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
+extern int novfs_verify_key_value(struct novfs_xplat *pdata,
+		struct novfs_schandle Session);
 
 
 #endif	/* __NOVFS_H */
