diff -uNrp linux-2.6.5/drivers/block/ll_rw_blk.c linux-2.6.5.no-lustre-intent/drivers/block/ll_rw_blk.c
--- linux-2.6.5/drivers/block/ll_rw_blk.c	2004-05-26 23:49:27.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/drivers/block/ll_rw_blk.c	2004-05-26 23:52:59.000000000 +0200
@@ -2529,13 +2529,6 @@ end_io:
 		if (test_bit(QUEUE_FLAG_DEAD, &q->queue_flags))
 			goto end_io;
 
-		/* this is cfs's dev_rdonly check */
-		if (bio->bi_rw == WRITE &&
-				dev_check_rdonly(bio->bi_bdev->bd_dev)) {
-			bio_endio(bio, bio->bi_size, 0);
-			break;
-		}
-
 		/*
 		 * If this device has partitions, remap block n
 		 * of partition p to block n+start(p) of the disk.
@@ -3065,58 +3058,6 @@ void swap_io_context(struct io_context *
 	*ioc2 = temp;
 }
 
-#define MAX_RDONLY_DEVS		16
-
-static dev_t rdonly_devs[MAX_RDONLY_DEVS] = {0, };
-
-/*
- * Debug code for turning block devices "read-only" (will discard writes
- * silently).  This is for filesystem crash/recovery testing.
- */
-void dev_set_rdonly(struct block_device *bdev, int no_write)
-{
-	if (no_write >= MAX_RDONLY_DEVS) {
-		printk(KERN_ALERT "%s:%d illegal arg %d (max %d)\n",
-				__FILE__, __LINE__, no_write, MAX_RDONLY_DEVS);
-		return;
-	}
-
-	if (bdev) {
-		printk(KERN_WARNING "Turning device %s read-only at %d\n",
-				bdev->bd_disk ? bdev->bd_disk->disk_name : "?",
-				no_write);
-		rdonly_devs[no_write] = bdev->bd_dev;
-	}
-}
-
-void dev_clear_rdonly(int no_write)
-{
-	if (no_write >= MAX_RDONLY_DEVS) {
-		printk(KERN_ALERT "%s:%d illegal arg %d (max %d)\n",
-				__FILE__, __LINE__, no_write, MAX_RDONLY_DEVS);
-		return;
-	}
-
-	if (rdonly_devs[no_write] == 0)
-		return;
-	
-	printk(KERN_WARNING "Clearing read-only at %d\n", no_write);
-	rdonly_devs[no_write] = 0;
-}
-
-int dev_check_rdonly(dev_t dev)
-{
-	int i;
-
-	for (i = 0; i < MAX_RDONLY_DEVS; i++)
-		if (rdonly_devs[i] == dev)
-			return 1;
-	return 0;
-}
-
-EXPORT_SYMBOL(dev_set_rdonly);
-EXPORT_SYMBOL(dev_clear_rdonly);
-EXPORT_SYMBOL(dev_check_rdonly);
 
 /*
  * sysfs parts below
diff -uNrp linux-2.6.5/drivers/md/dm-path-selector.c linux-2.6.5.no-lustre-intent/drivers/md/dm-path-selector.c
--- linux-2.6.5/drivers/md/dm-path-selector.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/drivers/md/dm-path-selector.c	2004-05-26 23:52:59.000000000 +0200
@@ -129,7 +129,7 @@ struct path_info {
 	struct path *path;
 };
 
-static struct path_info *md_path_lookup(struct list_head *head, struct path *p)
+static struct path_info *path_lookup(struct list_head *head, struct path *p)
 {
 	struct path_info *pi;
 
@@ -235,9 +235,9 @@ static void rr_fail_path(struct path_sel
 	 * mind the expense of these searches.
 	 */
 	spin_lock_irqsave(&s->lock, flags);
-	pi = md_path_lookup(&s->valid_paths, p);
+	pi = path_lookup(&s->valid_paths, p);
 	if (!pi)
-		pi = md_path_lookup(&s->invalid_paths, p);
+		pi = path_lookup(&s->invalid_paths, p);
 
 	if (!pi)
 		DMWARN("asked to change the state of an unknown path");
diff -uNrp linux-2.6.5/fs/block_dev.c linux-2.6.5.no-lustre-intent/fs/block_dev.c
--- linux-2.6.5/fs/block_dev.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/block_dev.c	2004-05-26 23:52:54.000000000 +0200
@@ -834,7 +834,6 @@ struct block_device *lookup_bdev(const c
 	if (!path || !*path)
 		return ERR_PTR(-EINVAL);
 
-	intent_init(&nd.intent, IT_LOOKUP);
 	error = path_lookup(path, LOOKUP_FOLLOW, &nd);
 	if (error)
 		return ERR_PTR(error);
diff -uNrp linux-2.6.5/fs/cifs/dir.c linux-2.6.5.no-lustre-intent/fs/cifs/dir.c
--- linux-2.6.5/fs/cifs/dir.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/cifs/dir.c	2004-05-26 23:52:59.000000000 +0200
@@ -172,22 +172,22 @@ cifs_create(struct inode *inode, struct 
 	}
 
 	if(nd) {
-		if ((nd->intent.it_flags & O_ACCMODE) == O_RDONLY)
+		if ((nd->intent.open.flags & O_ACCMODE) == O_RDONLY)
 			desiredAccess = GENERIC_READ;
-		else if ((nd->intent.it_flags & O_ACCMODE) == O_WRONLY)
+		else if ((nd->intent.open.flags & O_ACCMODE) == O_WRONLY)
 			desiredAccess = GENERIC_WRITE;
-		else if ((nd->intent.it_flags & O_ACCMODE) == O_RDWR) {
+		else if ((nd->intent.open.flags & O_ACCMODE) == O_RDWR) {
 			/* GENERIC_ALL is too much permission to request */
 			/* can cause unnecessary access denied on create */
 			/* desiredAccess = GENERIC_ALL; */
 			desiredAccess = GENERIC_READ | GENERIC_WRITE;
 		}
 
-		if((nd->intent.it_flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
+		if((nd->intent.open.flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
 			disposition = FILE_CREATE;
-		else if((nd->intent.it_flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))
+		else if((nd->intent.open.flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))
 			disposition = FILE_OVERWRITE_IF;
-		else if((nd->intent.it_flags & O_CREAT) == O_CREAT)
+		else if((nd->intent.open.flags & O_CREAT) == O_CREAT)
 			disposition = FILE_OPEN_IF;
 		else {
 			cFYI(1,("Create flag not set in create function"));
@@ -346,7 +346,7 @@ cifs_lookup(struct inode *parent_dir_ino
 	      parent_dir_inode, direntry->d_name.name, direntry));
 
 	if(nd) {  /* BB removeme */
-		cFYI(1,("In lookup nd flags 0x%x open intent flags 0x%x",nd->flags,nd->intent.it_flags));
+		cFYI(1,("In lookup nd flags 0x%x open intent flags 0x%x",nd->flags,nd->intent.open.flags));
 	} /* BB removeme BB */
 	/* BB Add check of incoming data - e.g. frame not longer than maximum SMB - let server check the namelen BB */
 
diff -uNrp linux-2.6.5/fs/dcache.c linux-2.6.5.no-lustre-intent/fs/dcache.c
--- linux-2.6.5/fs/dcache.c	2004-05-26 23:49:22.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/dcache.c	2004-05-26 23:52:59.000000000 +0200
@@ -217,14 +217,7 @@ int d_invalidate(struct dentry * dentry)
 		spin_unlock(&dcache_lock);
 		return 0;
 	}
-
-        /* network invalidation by Lustre */
-	if (dentry->d_flags & DCACHE_LUSTRE_INVALID) {
-		spin_unlock(&dcache_lock);
-		return 0;
-	}
-
-        /*
+	/*
 	 * Check whether to do a partial shrink_dcache
 	 * to get rid of unused child entries.
 	 */
@@ -1117,23 +1110,14 @@ void d_delete(struct dentry * dentry)
  * Adds a dentry to the hash according to its name.
  */
  
-void __d_rehash(struct dentry * entry, int lock)
+void d_rehash(struct dentry * entry)
 {
 	struct hlist_head *list = d_hash(entry->d_parent, entry->d_name.hash);
-	if (lock)
-		spin_lock(&dcache_lock);
+	spin_lock(&dcache_lock);
  	entry->d_vfs_flags &= ~DCACHE_UNHASHED;
 	entry->d_bucket = list;
  	hlist_add_head_rcu(&entry->d_hash, list);
-	if (lock)
-		spin_unlock(&dcache_lock);
-}
-
-EXPORT_SYMBOL(__d_rehash);
-
-void d_rehash(struct dentry * entry)
-{
-	__d_rehash(entry, 1);
+	spin_unlock(&dcache_lock);
 }
 
 #define do_switch(x,y) do { \
@@ -1196,11 +1180,12 @@ static inline void switch_names(struct d
  * dcache entries should not be moved in this way.
  */
 
-void __d_move(struct dentry * dentry, struct dentry * target)
+void d_move(struct dentry * dentry, struct dentry * target)
 {
 	if (!dentry->d_inode)
 		printk(KERN_WARNING "VFS: moving negative dcache entry\n");
 
+	spin_lock(&dcache_lock);
 	write_seqlock(&rename_lock);
 	/*
 	 * XXXX: do we really need to take target->d_lock?
@@ -1253,14 +1238,6 @@ already_unhashed:
 	spin_unlock(&target->d_lock);
 	spin_unlock(&dentry->d_lock);
 	write_sequnlock(&rename_lock);
-}
-
-EXPORT_SYMBOL(__d_move);
-
-void d_move(struct dentry *dentry, struct dentry *target)
-{
-	spin_lock(&dcache_lock);
-	__d_move(dentry, target);
 	spin_unlock(&dcache_lock);
 }
 
diff -uNrp linux-2.6.5/fs/exec.c linux-2.6.5.no-lustre-intent/fs/exec.c
--- linux-2.6.5/fs/exec.c	2004-05-26 23:49:25.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/exec.c	2004-05-26 23:52:59.000000000 +0200
@@ -126,10 +126,9 @@ asmlinkage long sys_uselib(const char __
 	struct nameidata nd;
 	int error;
 
-	intent_init(&nd.intent, IT_OPEN);
+	nd.intent.open.flags = FMODE_READ;
 
-	nd.intent.it_flags = FMODE_READ;
-	FSHOOK_BEGIN_USER_WALK_IT(open,
+	FSHOOK_BEGIN_USER_WALK(open,
 		error,
 		library,
 		LOOKUP_FOLLOW|LOOKUP_OPEN,
@@ -146,7 +145,7 @@ asmlinkage long sys_uselib(const char __
 		goto out;
 	}
 
-	file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &nd.intent);
+	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
 	error = PTR_ERR(file);
 	if (IS_ERR(file))
 		goto out;
@@ -497,9 +496,8 @@ struct file *open_exec(const char *name)
 
 	FSHOOK_BEGIN(open, err, .filename = name, .flags = O_RDONLY)
 
-	intent_init(&nd.intent, IT_OPEN);
-	nd.intent.it_flags = FMODE_READ;
-	err = path_lookup(name, LOOKUP_FOLLOW, &nd);
+	nd.intent.open.flags = FMODE_READ;
+	err = path_lookup(name, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
 	file = ERR_PTR(err);
 
 	if (!err) {
@@ -512,7 +510,7 @@ struct file *open_exec(const char *name)
 				err = -EACCES;
 			file = ERR_PTR(err);
 			if (!err) {
-				file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &nd.intent);
+				file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
 				if (!IS_ERR(file)) {
 					err = deny_write_access(file);
 					if (err) {
@@ -1442,7 +1440,7 @@ int do_coredump(long signr, int exit_cod
 		goto close_fail;
 	if (!file->f_op->write)
 		goto close_fail;
-	if (do_truncate(file->f_dentry, 0, 0) != 0)
+	if (do_truncate(file->f_dentry, 0) != 0)
 		goto close_fail;
 
 	retval = binfmt->core_dump(signr, regs, file);
diff -uNrp linux-2.6.5/fs/filesystems.c linux-2.6.5.no-lustre-intent/fs/filesystems.c
--- linux-2.6.5/fs/filesystems.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/filesystems.c	2004-05-26 23:52:59.000000000 +0200
@@ -27,9 +27,7 @@
  */
 
 static struct file_system_type *file_systems;
-rwlock_t file_systems_lock = RW_LOCK_UNLOCKED;
-
-EXPORT_SYMBOL(file_systems_lock);
+static rwlock_t file_systems_lock = RW_LOCK_UNLOCKED;
 
 /* WARNING: This can be used only if we _already_ own a reference */
 void get_filesystem(struct file_system_type *fs)
diff -uNrp linux-2.6.5/fs/inode.c linux-2.6.5.no-lustre-intent/fs/inode.c
--- linux-2.6.5/fs/inode.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/inode.c	2004-05-26 23:52:59.000000000 +0200
@@ -221,7 +221,6 @@ void __iget(struct inode * inode)
 	inodes_stat.nr_unused--;
 }
 
-EXPORT_SYMBOL(__iget);
 /**
  * clear_inode - clear an inode
  * @inode: inode to clear
diff -uNrp linux-2.6.5/fs/jbd/journal.c linux-2.6.5.no-lustre-intent/fs/jbd/journal.c
--- linux-2.6.5/fs/jbd/journal.c	2004-05-26 23:49:27.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/jbd/journal.c	2004-05-26 23:52:59.000000000 +0200
@@ -71,7 +71,6 @@ EXPORT_SYMBOL(journal_abort);
 EXPORT_SYMBOL(journal_errno);
 EXPORT_SYMBOL(journal_ack_err);
 EXPORT_SYMBOL(journal_clear_err);
-EXPORT_SYMBOL(log_start_commit);
 EXPORT_SYMBOL(log_wait_commit);
 EXPORT_SYMBOL(journal_start_commit);
 EXPORT_SYMBOL(journal_wipe);
diff -uNrp linux-2.6.5/fs/namei.c linux-2.6.5.no-lustre-intent/fs/namei.c
--- linux-2.6.5/fs/namei.c	2004-05-26 23:49:25.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/namei.c	2004-05-26 23:54:09.000000000 +0200
@@ -270,16 +270,6 @@ int deny_write_access(struct file * file
 	return 0;
 }
 
-void intent_release(struct lookup_intent *it)
-{
-	if (!it)
-		return;
-	if (it->it_magic != INTENT_MAGIC)
-		return;
-	if (it->it_op_release)
-		it->it_op_release(it);
-}
-
 int deny_write_access_to_inode(struct inode * inode)
 {
 	spin_lock(&inode->i_lock);
@@ -294,7 +284,6 @@ int deny_write_access_to_inode(struct in
 
 void path_release(struct nameidata *nd)
 {
-	intent_release(&nd->intent);
 	dput(nd->dentry);
 	mntput(nd->mnt);
 }
@@ -371,10 +360,7 @@ static struct dentry * real_lookup(struc
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
-	int counter = 0;
 
-again:
-	counter++;
 	down(&dir->i_sem);
 	/*
 	 * First re-do the cached lookup just in case it was created
@@ -413,10 +399,7 @@ again:
 	if (result->d_op && result->d_op->d_revalidate) {
 		if (!result->d_op->d_revalidate(result, nd) && !d_invalidate(result)) {
 			dput(result);
-			if (counter > 10)
-				result = ERR_PTR(-ESTALE);
-			if (!IS_ERR(result))
-				goto again;
+			result = ERR_PTR(-ENOENT);
 		}
 	}
 	return result;
@@ -593,33 +576,6 @@ fail:
 	return PTR_ERR(dentry);
 }
 
-static int revalidate_special(struct nameidata *nd)
-{
-	struct dentry *dentry = nd->dentry;
-	int err, counter = 0;
-
-	if (!dentry->d_op || !dentry->d_op->d_revalidate)
-		return 0;
- revalidate_again:
-	if (!dentry->d_op->d_revalidate(dentry, nd)) {
-		struct dentry *new;
-		if ((err = permission(dentry->d_parent->d_inode, MAY_EXEC,nd)))
-			return err;
-		new = real_lookup(dentry->d_parent, &dentry->d_name, nd);
-		if (IS_ERR(new))
-			return PTR_ERR(new);
-		d_invalidate(dentry);
-		dput(dentry);
-		nd->dentry = dentry = new;
-		counter++;
-		if (counter < 10)
-			goto revalidate_again;
-		printk("excessive revalidate_it loops\n");
-		return -ESTALE;
-	}
-	return 0;
-}
-
 /*
  * Name resolution.
  *
@@ -720,9 +676,7 @@ int fastcall link_path_walk(const char *
 
 		if (inode->i_op->follow_link) {
 			mntget(next.mnt);
-			nd->flags |= LOOKUP_LINK_NOTLAST;
 			err = do_follow_link(next.dentry, nd);
-			nd->flags &= ~LOOKUP_LINK_NOTLAST;
 			dput(next.dentry);
 			mntput(next.mnt);
 			if (err)
@@ -761,29 +715,14 @@ last_component:
 				inode = nd->dentry->d_inode;
 				/* fallthrough */
 			case 1:
- 				nd->flags |= LOOKUP_LAST;
- 				err = revalidate_special(nd);
- 				nd->flags &= ~LOOKUP_LAST;
-				if (err)
- 					break;
 				goto return_reval;
 		}
-		
-		if (err) {
-			if (!nd->dentry->d_inode)
-				err = -ENOENT;
-			
-			goto return_err;			
-		}
-		
 		if (nd->dentry->d_op && nd->dentry->d_op->d_hash) {
 			err = nd->dentry->d_op->d_hash(nd->dentry, &this);
 			if (err < 0)
 				break;
 		}
-		nd->flags |= LOOKUP_LAST;
 		err = do_lookup(nd, &this, &next);
-		nd->flags &= ~LOOKUP_LAST;
 		if (err)
 			break;
 		follow_mount(&next.mnt, &next.dentry);
@@ -1009,7 +948,7 @@ struct dentry * lookup_hash(struct qstr 
 }
 
 /* SMP-safe */
-struct dentry * lookup_one_len_it(const char * name, struct dentry * base, int len, struct nameidata *nd)
+struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
 {
 	unsigned long hash;
 	struct qstr this;
@@ -1029,16 +968,11 @@ struct dentry * lookup_one_len_it(const 
 	}
 	this.hash = end_name_hash(hash);
 
-	return __lookup_hash(&this, base, nd);
+	return lookup_hash(&this, base);
 access:
 	return ERR_PTR(-EACCES);
 }
 
-struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
-{
-	return lookup_one_len_it(name, base, len, NULL);
-}
-
 /*
  *	namei()
  *
@@ -1050,8 +984,7 @@ struct dentry * lookup_one_len(const cha
  * that namei follows links, while lnamei does not.
  * SMP-safe
  */
-int fastcall __user_walk_it(const char __user *name, unsigned flags,
-			    struct nameidata *nd, const char **pname)
+int fastcall __user_walk(const char __user *name, unsigned flags, struct nameidata *nd, const char **pname)
 {
 	char *tmp = getname(name);
 	int err = PTR_ERR(tmp);
@@ -1066,13 +999,6 @@ int fastcall __user_walk_it(const char _
 	return err;
 }
 
-int fastcall __user_walk(const char __user *name, unsigned flags,
-			 struct nameidata *nd, const char **pname)
-{
-	intent_init(&nd->intent, IT_LOOKUP);
-	return __user_walk_it(name, flags, nd, pname);
-}
-
 /*
  * It's inline, so penalty for filesystems that don't use sticky bit is
  * minimal.
@@ -1304,7 +1230,7 @@ int may_open(struct nameidata *nd, int a
 		if (!error) {
 			DQUOT_INIT(inode);
 			
-			error = do_truncate(dentry, 0, 1);
+			error = do_truncate(dentry, 0);
 		}
 		put_write_access(inode);
 		if (error)
@@ -1345,8 +1271,8 @@ int open_namei(const char * pathname, in
 		acc_mode |= MAY_APPEND;
 
 	/* Fill in the open() intent data */
-	nd->intent.it_flags = flag;
-	nd->intent.it_create_mode = mode;
+	nd->intent.open.flags = flag;
+	nd->intent.open.create_mode = mode;
 
 	/*
 	 * The simplest case - just a plain lookup.
@@ -1361,7 +1287,6 @@ int open_namei(const char * pathname, in
 	/*
 	 * Create - we need to know the parent.
 	 */
-	nd->intent.it_op |= IT_CREAT;
 	error = path_lookup(pathname, LOOKUP_PARENT|LOOKUP_OPEN|LOOKUP_CREATE, nd);
 	if (error)
 		return error;
@@ -1378,9 +1303,7 @@ int open_namei(const char * pathname, in
 	dir = nd->dentry;
 	nd->flags &= ~LOOKUP_PARENT;
 	down(&dir->d_inode->i_sem);
-	nd->flags |= LOOKUP_LAST;
 	dentry = __lookup_hash(&nd->last, nd->dentry, nd);
-	nd->flags &= ~LOOKUP_LAST;
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1485,9 +1408,7 @@ do_link:
 	}
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
-	nd->flags |= LOOKUP_LAST;
 	dentry = __lookup_hash(&nd->last, nd->dentry, nd);
-	nd->flags &= ~LOOKUP_LAST;
 	putname(nd->last.name);
 	goto do_last;
 }
@@ -1554,7 +1475,6 @@ asmlinkage long sys_mknod(const char __u
 	char * tmp;
 	struct dentry * dentry;
 	struct nameidata nd;
-	intent_init(&nd.intent, IT_LOOKUP);
 
 	if (S_ISDIR(mode))
 		return -EPERM;
@@ -1567,15 +1487,6 @@ asmlinkage long sys_mknod(const char __u
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
-
-	if (nd.dentry->d_inode->i_op->mknod_raw) {
-		struct inode_operations *op = nd.dentry->d_inode->i_op;
-		error = op->mknod_raw(&nd, mode, dev);
-		/* the file system wants to use normal vfs path now */
-		if (error != -EOPNOTSUPP)
-			goto out2;
-	}
-
 	dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(dentry);
 
@@ -1602,7 +1513,6 @@ asmlinkage long sys_mknod(const char __u
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
-out2:
 	path_release(&nd);
 out:
 	putname(tmp);
@@ -1649,18 +1559,10 @@ asmlinkage long sys_mkdir(const char __u
 
 		struct dentry *dentry;
 		struct nameidata nd;
-                intent_init(&nd.intent, IT_LOOKUP);
 
 		error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
- 		if (nd.dentry->d_inode->i_op->mkdir_raw) {
- 			struct inode_operations *op = nd.dentry->d_inode->i_op;
- 			error = op->mkdir_raw(&nd, mode);
- 			/* the file system wants to use normal vfs path now */
- 			if (error != -EOPNOTSUPP)
- 				goto out2;
- 		}
 		dentry = lookup_create(&nd, 1);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
@@ -1670,7 +1572,6 @@ asmlinkage long sys_mkdir(const char __u
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
-out2:
 		path_release(&nd);
 out:
 
@@ -1754,7 +1655,6 @@ asmlinkage long sys_rmdir(const char __u
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-        intent_init(&nd.intent, IT_LOOKUP);
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1777,14 +1677,6 @@ asmlinkage long sys_rmdir(const char __u
 			error = -EBUSY;
 			goto exit1;
 	}
- 	if (nd.dentry->d_inode->i_op->rmdir_raw) {
- 		struct inode_operations *op = nd.dentry->d_inode->i_op;
-
- 		error = op->rmdir_raw(&nd);
- 		/* the file system wants to use normal vfs path now */
- 		if (error != -EOPNOTSUPP)
- 			goto exit1;
- 	}
 	down(&nd.dentry->d_inode->i_sem);
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
@@ -1846,7 +1738,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-        intent_init(&nd.intent, IT_LOOKUP);
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1860,13 +1751,6 @@ asmlinkage long sys_unlink(const char __
 	error = -EISDIR;
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
- 	if (nd.dentry->d_inode->i_op->unlink_raw) {
- 		struct inode_operations *op = nd.dentry->d_inode->i_op;
- 		error = op->unlink_raw(&nd);
- 		/* the file system wants to use normal vfs path now */
- 		if (error != -EOPNOTSUPP)
- 			goto exit1;
- 	}
 	down(&nd.dentry->d_inode->i_sem);
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
@@ -1940,18 +1824,10 @@ asmlinkage long sys_symlink(const char _
 
 		struct dentry *dentry;
 		struct nameidata nd;
-                intent_init(&nd.intent, IT_LOOKUP);
 
 		error = path_lookup(to, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
-		if (nd.dentry->d_inode->i_op->symlink_raw) {
-			struct inode_operations *op = nd.dentry->d_inode->i_op;
-			error = op->symlink_raw(&nd, from);
-			/* the file system wants to use normal vfs path now */
-			if (error != -EOPNOTSUPP)
-				goto out2;
-		}
 		dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
@@ -1959,7 +1835,6 @@ asmlinkage long sys_symlink(const char _
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
-out2:
 		path_release(&nd);
 out:
 
@@ -2026,8 +1901,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-        intent_init(&nd.intent, IT_LOOKUP);
-        intent_init(&old_nd.intent, IT_LOOKUP);
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2046,13 +1919,6 @@ asmlinkage long sys_link(const char __us
 	error = -EXDEV;
 	if (old_nd.mnt != nd.mnt)
 		goto out_release;
-        if (nd.dentry->d_inode->i_op->link_raw) {
-                struct inode_operations *op = nd.dentry->d_inode->i_op;
-                error = op->link_raw(&old_nd, &nd);
-                /* the file system wants to use normal vfs path now */
-                if (error != -EOPNOTSUPP)
-                        goto out_release;
-        }
 	new_dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
@@ -2105,7 +1971,7 @@ out:
  *	   locking].
  */
 int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
-                   struct inode *new_dir, struct dentry *new_dentry)
+	       struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error = 0;
 	struct inode *target;
@@ -2150,7 +2016,7 @@ int vfs_rename_dir(struct inode *old_dir
 }
 
 int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
-                     struct inode *new_dir, struct dentry *new_dentry)
+	       struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct inode *target;
 	int error;
@@ -2227,8 +2093,6 @@ static inline int do_rename(const char *
 	struct dentry * old_dentry, *new_dentry;
 	struct dentry * trap;
 	struct nameidata oldnd, newnd;
-        intent_init(&oldnd.intent, IT_LOOKUP);
-        intent_init(&newnd.intent, IT_LOOKUP);
 
 	error = path_lookup(oldname, LOOKUP_PARENT, &oldnd);
 	if (error)
@@ -2251,13 +2115,6 @@ static inline int do_rename(const char *
 	if (newnd.last_type != LAST_NORM)
 		goto exit2;
 
- 	if (old_dir->d_inode->i_op->rename_raw) {
- 		error = old_dir->d_inode->i_op->rename_raw(&oldnd, &newnd);
- 		/* the file system wants to use normal vfs path now */
- 		if (error != -EOPNOTSUPP)
- 			goto exit2;
- 	}
-
 	trap = lock_rename(new_dir, old_dir);
 
 	old_dentry = lookup_hash(&oldnd.last, old_dir);
@@ -2289,7 +2146,8 @@ static inline int do_rename(const char *
 	if (new_dentry == trap)
 		goto exit5;
 
-	error = vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry);
+	error = vfs_rename(old_dir->d_inode, old_dentry,
+				   new_dir->d_inode, new_dentry);
 exit5:
 	dput(new_dentry);
 exit4:
@@ -2350,9 +2208,7 @@ static inline int
 __vfs_follow_link(struct nameidata *nd, const char *link)
 {
 	int res = 0;
-	struct lookup_intent it = nd->intent;
 	char *name;
-
 	if (IS_ERR(link))
 		goto fail;
 
@@ -2362,10 +2218,6 @@ __vfs_follow_link(struct nameidata *nd, 
 			/* weird __emul_prefix() stuff did it */
 			goto out;
 	}
-
-	intent_init(&nd->intent, it.it_op);
-	nd->intent.it_flags = it.it_flags;
-	nd->intent.it_create_mode = it.it_create_mode;
 	res = link_path_walk(link, nd);
 out:
 	if (current->link_count || res || nd->last_type!=LAST_NORM)
diff -uNrp linux-2.6.5/fs/namespace.c linux-2.6.5.no-lustre-intent/fs/namespace.c
--- linux-2.6.5/fs/namespace.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/namespace.c	2004-05-26 23:52:59.000000000 +0200
@@ -108,7 +108,6 @@ static int check_mnt(struct vfsmount *mn
 
 static void detach_mnt(struct vfsmount *mnt, struct nameidata *old_nd)
 {
-	memset(old_nd, 0, sizeof(*old_nd));
 	old_nd->dentry = mnt->mnt_mountpoint;
 	old_nd->mnt = mnt->mnt_parent;
 	mnt->mnt_parent = mnt;
@@ -534,8 +533,6 @@ static int do_loopback(struct nameidata 
 		return err;
 	if (!old_name || !*old_name)
 		return -EINVAL;
-
-	intent_init(&old_nd.intent, IT_LOOKUP);
 	err = path_lookup(old_name, LOOKUP_FOLLOW, &old_nd);
 	if (err)
 		return err;
@@ -604,7 +601,6 @@ static int do_move_mount(struct nameidat
 		return -EPERM;
 	if (!old_name || !*old_name)
 		return -EINVAL;
-	intent_init(&old_nd.intent, IT_LOOKUP);
 	err = path_lookup(old_name, LOOKUP_FOLLOW, &old_nd);
 	if (err)
 		return err;
@@ -754,7 +750,6 @@ long do_mount(char * dev_name, char * di
 	int retval = 0;
 	int mnt_flags = 0;
 
-	intent_init(&nd.intent, IT_LOOKUP);
 	/* Discard magic */
 	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
 		flags &= ~MS_MGC_MSK;
diff -uNrp linux-2.6.5/fs/nfs/dir.c linux-2.6.5.no-lustre-intent/fs/nfs/dir.c
--- linux-2.6.5/fs/nfs/dir.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/nfs/dir.c	2004-05-26 23:52:59.000000000 +0200
@@ -709,7 +709,7 @@ int nfs_is_exclusive_create(struct inode
 		return 0;
 	if (!nd || (nd->flags & LOOKUP_CONTINUE) || !(nd->flags & LOOKUP_CREATE))
 		return 0;
-	return (nd->intent.it_flags & O_EXCL) != 0;
+	return (nd->intent.open.flags & O_EXCL) != 0;
 }
 
 static struct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)
@@ -782,7 +782,7 @@ static int is_atomic_open(struct inode *
 	if (nd->flags & LOOKUP_DIRECTORY)
 		return 0;
 	/* Are we trying to write to a read only partition? */
-	if (IS_RDONLY(dir) && (nd->intent.it_flags & (O_CREAT|O_TRUNC|FMODE_WRITE)))
+	if (IS_RDONLY(dir) && (nd->intent.open.flags & (O_CREAT|O_TRUNC|FMODE_WRITE)))
 		return 0;
 	return 1;
 }
@@ -803,7 +803,7 @@ static struct dentry *nfs_atomic_lookup(
 	dentry->d_op = NFS_PROTO(dir)->dentry_ops;
 
 	/* Let vfs_create() deal with O_EXCL */
-	if (nd->intent.it_flags & O_EXCL)
+	if (nd->intent.open.flags & O_EXCL)
 		goto no_entry;
 
 	/* Open the file on the server */
@@ -811,7 +811,7 @@ static struct dentry *nfs_atomic_lookup(
 	/* Revalidate parent directory attribute cache */
 	nfs_revalidate_inode(NFS_SERVER(dir), dir);
 
-	if (nd->intent.it_flags & O_CREAT) {
+	if (nd->intent.open.flags & O_CREAT) {
 		nfs_begin_data_update(dir);
 		inode = nfs4_atomic_open(dir, dentry, nd);
 		nfs_end_data_update(dir);
@@ -827,7 +827,7 @@ static struct dentry *nfs_atomic_lookup(
 				break;
 			/* This turned out not to be a regular file */
 			case -ELOOP:
-				if (!(nd->intent.it_flags & O_NOFOLLOW))
+				if (!(nd->intent.open.flags & O_NOFOLLOW))
 					goto no_open;
 			/* case -EISDIR: */
 			/* case -EINVAL: */
@@ -861,7 +861,7 @@ static int nfs_open_revalidate(struct de
 	dir = parent->d_inode;
 	if (!is_atomic_open(dir, nd))
 		goto no_open;
-	openflags = nd->intent.it_flags;
+	openflags = nd->intent.open.flags;
 	if (openflags & O_CREAT) {
 		/* If this is a negative dentry, just drop it */
 		if (!inode)
@@ -1026,7 +1026,7 @@ static int nfs_create(struct inode *dir,
 	attr.ia_valid = ATTR_MODE;
 
 	if (nd && (nd->flags & LOOKUP_CREATE))
-		open_flags = nd->intent.it_flags;
+		open_flags = nd->intent.open.flags;
 
 	/*
 	 * The 0 argument passed into the create function should one day
diff -uNrp linux-2.6.5/fs/nfs/nfs4proc.c linux-2.6.5.no-lustre-intent/fs/nfs/nfs4proc.c
--- linux-2.6.5/fs/nfs/nfs4proc.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/nfs/nfs4proc.c	2004-05-26 23:52:59.000000000 +0200
@@ -792,17 +792,17 @@ nfs4_atomic_open(struct inode *dir, stru
 	struct nfs4_state *state;
 
 	if (nd->flags & LOOKUP_CREATE) {
-		attr.ia_mode = nd->intent.it_create_mode;
+		attr.ia_mode = nd->intent.open.create_mode;
 		attr.ia_valid = ATTR_MODE;
 		if (!IS_POSIXACL(dir))
 			attr.ia_mode &= ~current->fs->umask;
 	} else {
 		attr.ia_valid = 0;
-		BUG_ON(nd->intent.it_flags & O_CREAT);
+		BUG_ON(nd->intent.open.flags & O_CREAT);
 	}
 
 	cred = rpcauth_lookupcred(NFS_SERVER(dir)->client->cl_auth, 0);
-	state = nfs4_do_open(dir, &dentry->d_name, nd->intent.it_flags, &attr, cred);
+	state = nfs4_do_open(dir, &dentry->d_name, nd->intent.open.flags, &attr, cred);
 	put_rpccred(cred);
 	if (IS_ERR(state))
 		return (struct inode *)state;
diff -uNrp linux-2.6.5/fs/open.c linux-2.6.5.no-lustre-intent/fs/open.c
--- linux-2.6.5/fs/open.c	2004-05-26 23:49:24.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/open.c	2004-05-26 23:52:59.000000000 +0200
@@ -204,10 +204,9 @@ out:
 	return error;
 }
 
-int do_truncate(struct dentry *dentry, loff_t length, int called_from_open)
+int do_truncate(struct dentry *dentry, loff_t length)
 {
 	int err;
-	struct inode_operations *op = dentry->d_inode->i_op;
 	struct iattr newattrs;
 
 	/* Not pretty: "inode->i_size" shouldn't really be signed. But it is. */
@@ -218,14 +217,7 @@ int do_truncate(struct dentry *dentry, l
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
 	down(&dentry->d_inode->i_sem);
 	down_write(&dentry->d_inode->i_alloc_sem);
-	if (called_from_open)
-		newattrs.ia_valid |= ATTR_FROM_OPEN;
-	if (op->setattr_raw) {
-		newattrs.ia_valid |= ATTR_RAW;
-		newattrs.ia_ctime = CURRENT_TIME;
-		err = op->setattr_raw(dentry->d_inode, &newattrs);
-	} else
-		err = notify_change(dentry, &newattrs);
+	err = notify_change(dentry, &newattrs);
 	up_write(&dentry->d_inode->i_alloc_sem);
 	up(&dentry->d_inode->i_sem);
 	return err;
@@ -236,12 +228,12 @@ static inline long do_sys_truncate(const
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
-	intent_init(&nd.intent, IT_GETATTR);
+
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	FSHOOK_BEGIN_USER_PATH_WALK_IT(truncate, error, path, nd, filename, .length = length)
+	FSHOOK_BEGIN_USER_PATH_WALK(truncate, error, path, nd, filename, .length = length)
 
 	inode = nd.dentry->d_inode;
 
@@ -280,7 +272,7 @@ static inline long do_sys_truncate(const
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
-		error = do_truncate(nd.dentry, length, 0);
+		error = do_truncate(nd.dentry, length);
 	}
 	put_write_access(inode);
 
@@ -337,7 +329,7 @@ static inline long do_sys_ftruncate(unsi
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
-		error = do_truncate(dentry, length, 0);
+		error = do_truncate(dentry, length);
 out_putf:
 	fput(file);
 out:
@@ -411,19 +403,9 @@ long do_utimes(char __user * filename, s
 		    (error = permission(inode,MAY_WRITE,&nd)) != 0)
 			goto dput_and_out;
 	}
-	if (inode->i_op->setattr_raw) {
-		struct inode_operations *op = nd.dentry->d_inode->i_op;
-
-		newattrs.ia_valid |= ATTR_RAW;
-		error = op->setattr_raw(inode, &newattrs);
-		/* the file system wants to use normal vfs path now */
-		if (error != -EOPNOTSUPP)
-			goto dput_and_out;
-	} else {
-                down(&inode->i_sem);
-                error = notify_change(nd.dentry, &newattrs);
-                up(&inode->i_sem);
-        }
+	down(&inode->i_sem);
+	error = notify_change(nd.dentry, &newattrs);
+	up(&inode->i_sem);
 dput_and_out:
 	path_release(&nd);
 
@@ -485,7 +467,6 @@ asmlinkage long sys_access(const char __
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
-	intent_init(&nd.intent, IT_GETATTR);
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -510,7 +491,7 @@ asmlinkage long sys_access(const char __
 	else
 		current->cap_effective = current->cap_permitted;
 
-	FSHOOK_BEGIN_USER_WALK_IT(access,
+	FSHOOK_BEGIN_USER_WALK(access,
 		res,
 		filename,
 		LOOKUP_FOLLOW|LOOKUP_ACCESS,
@@ -526,7 +507,6 @@ asmlinkage long sys_access(const char __
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
-
 		path_release(&nd);
 
 	FSHOOK_END_USER_WALK(access, res, path)
@@ -566,13 +546,11 @@ dput_and_out:
 
 asmlinkage long sys_fchdir(unsigned int fd)
 {
-	struct nameidata nd;
 	struct file *file;
 	struct dentry *dentry;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int error;
-	intent_init(&nd.intent, IT_GETATTR);
 
 	FSHOOK_BEGIN(fchdir, error, .fd = fd)
 
@@ -605,9 +583,8 @@ asmlinkage long sys_chroot(const char __
 {
 	struct nameidata nd;
 	int error;
-	intent_init(&nd.intent, IT_GETATTR);
 
-	FSHOOK_BEGIN_USER_WALK_IT(chroot,
+	FSHOOK_BEGIN_USER_WALK(chroot,
 		error,
 		filename,
 		LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT,
@@ -633,55 +610,39 @@ dput_and_out:
 	return error;
 }
 
-int chmod_common(struct dentry *dentry, mode_t mode)
+asmlinkage long sys_fchmod(unsigned int fd, mode_t mode)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode;
+	struct dentry * dentry;
+	struct file * file;
+	int err;
 	struct iattr newattrs;
-	int error = -EROFS;
 
-	if (IS_RDONLY(inode))
-		goto out;
-	
-	if (inode->i_op->setattr_raw) {
-		struct inode_operations *op = dentry->d_inode->i_op;
-		
-		newattrs.ia_mode = mode;
-		newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
-		newattrs.ia_valid |= ATTR_RAW;
-		error = op->setattr_raw(inode, &newattrs);
-		/* the file system wants to use the normal vfs path now */
-		if (error != -EOPNOTSUPP)
-			goto out;
-	}
+	FSHOOK_BEGIN(fchmod, err, .fd = fd, .mode = mode)
 
-	error = -EPERM;
-	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+	err = -EBADF;
+	file = fget(fd);
+	if (!file)
 		goto out;
 
+	dentry = file->f_dentry;
+	inode = dentry->d_inode;
+
+	err = -EROFS;
+	if (IS_RDONLY(inode))
+		goto out_putf;
+	err = -EPERM;
+	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+		goto out_putf;
 	down(&inode->i_sem);
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
-	error = notify_change(dentry, &newattrs);
+	err = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
 
-out:
-	return error;
-}
-
-asmlinkage long sys_fchmod(unsigned int fd, mode_t mode)
-{
-	struct file * file;
-	int err = -EBADF;
-
-	FSHOOK_BEGIN(fchmod, err, .fd = fd, .mode = mode)
-
-	file = fget(fd);
-	if (!file)
-		goto out;
-
-	err = chmod_common(file->f_dentry, mode);
+out_putf:
 	fput(file);
 out:
 
@@ -693,7 +654,9 @@ out:
 asmlinkage long sys_chmod(const char __user * filename, mode_t mode)
 {
 	struct nameidata nd;
+	struct inode * inode;
 	int error;
+	struct iattr newattrs;
 
 	FSHOOK_BEGIN_USER_PATH_WALK(chmod,
 		error,
@@ -703,7 +666,25 @@ asmlinkage long sys_chmod(const char __u
 		.mode = mode,
 		.link = false)
 
-	error = chmod_common(nd.dentry, mode);
+	inode = nd.dentry->d_inode;
+
+	error = -EROFS;
+	if (IS_RDONLY(inode))
+		goto dput_and_out;
+
+	error = -EPERM;
+	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+		goto dput_and_out;
+
+	down(&inode->i_sem);
+	if (mode == (mode_t) -1)
+		mode = inode->i_mode;
+	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
+	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+	error = notify_change(nd.dentry, &newattrs);
+	up(&inode->i_sem);
+
+dput_and_out:
 	path_release(&nd);
 
 	FSHOOK_END_USER_WALK(chmod, error, path)
@@ -726,18 +707,6 @@ static int chown_common(struct dentry * 
 	if (IS_RDONLY(inode))
 		goto out;
 	error = -EPERM;
-	if (inode->i_op->setattr_raw) {
-		struct inode_operations *op = dentry->d_inode->i_op;
-
-		newattrs.ia_uid = user;
-		newattrs.ia_gid = group;
-		newattrs.ia_valid = ATTR_UID | ATTR_GID;
-		newattrs.ia_valid |= ATTR_RAW;
-		error = op->setattr_raw(inode, &newattrs);
-		/* the file system wants to use normal vfs path now */
-		if (error != -EOPNOTSUPP)
-			return error;
-	}
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
 	newattrs.ia_valid =  ATTR_CTIME;
@@ -751,7 +720,6 @@ static int chown_common(struct dentry * 
 	}
 	if (!S_ISDIR(inode->i_mode))
 		newattrs.ia_valid |= ATTR_KILL_SUID|ATTR_KILL_SGID;
-
 	down(&inode->i_sem);
 	error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
@@ -837,8 +805,27 @@ asmlinkage long sys_fchown(unsigned int 
  * for the internal routines (ie open_namei()/follow_link() etc). 00 is
  * used by symlinks.
  */
-struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt, int flags,
-			    struct lookup_intent *it)
+struct file *filp_open(const char * filename, int flags, int mode)
+{
+	int namei_flags, error;
+	struct nameidata nd;
+
+	namei_flags = flags;
+	if ((namei_flags+1) & O_ACCMODE)
+		namei_flags++;
+	if (namei_flags & O_TRUNC)
+		namei_flags |= 2;
+
+	error = open_namei(filename, namei_flags, mode, &nd);
+	if (!error)
+		return dentry_open(nd.dentry, nd.mnt, flags);
+
+	return ERR_PTR(error);
+}
+
+EXPORT_SYMBOL(filp_open);
+
+struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
 {
 	struct file * f;
 	struct inode *inode;
@@ -850,7 +837,6 @@ struct file *dentry_open_it(struct dentr
 		goto cleanup_dentry;
 	f->f_flags = flags;
 	f->f_mode = (flags+1) & O_ACCMODE;
-	f->f_it = it;
 	inode = dentry->d_inode;
 	if (f->f_mode & FMODE_WRITE) {
 		error = get_write_access(inode);
@@ -869,7 +855,6 @@ struct file *dentry_open_it(struct dentr
 		error = f->f_op->open(inode,f);
 		if (error)
 			goto cleanup_all;
-		intent_release(it);
 	}
 	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);
 
@@ -896,7 +881,6 @@ cleanup_all:
 cleanup_file:
 	put_filp(f);
 cleanup_dentry:
-	intent_release(it);
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
@@ -904,37 +888,6 @@ cleanup_dentry:
 
 EXPORT_SYMBOL(dentry_open);
 
-struct file *filp_open(const char * filename, int flags, int mode)
-{
-	int namei_flags, error;
-	struct file * temp_filp;
-	struct nameidata nd;
-	intent_init(&nd.intent, IT_OPEN);
-
-	namei_flags = flags;
-	if ((namei_flags+1) & O_ACCMODE)
-		namei_flags++;
-	if (namei_flags & O_TRUNC)
-		namei_flags |= 2;
-
-	error = open_namei(filename, namei_flags, mode, &nd);
-	if (!error) {
-		temp_filp = dentry_open_it(nd.dentry, nd.mnt, flags, &nd.intent);
-		return temp_filp;
-	}	
-	return ERR_PTR(error);
-}
-
-EXPORT_SYMBOL(filp_open);
-
-struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
-{
-	struct lookup_intent it;
-	intent_init(&it, IT_LOOKUP);
-
-	return dentry_open_it(dentry, mnt, flags, &it);
-}
-
 /*
  * Find an empty file descriptor entry, and mark it busy.
  */
diff -uNrp linux-2.6.5/fs/stat.c linux-2.6.5.no-lustre-intent/fs/stat.c
--- linux-2.6.5/fs/stat.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/stat.c	2004-05-26 23:52:59.000000000 +0200
@@ -37,7 +37,7 @@ void generic_fillattr(struct inode *inod
 
 EXPORT_SYMBOL(generic_fillattr);
 
-int vfs_getattr_it(struct vfsmount *mnt, struct dentry *dentry, struct lookup_intent *it, struct kstat *stat)
+int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
 	struct inode *inode = dentry->d_inode;
 	int retval;
@@ -46,8 +46,6 @@ int vfs_getattr_it(struct vfsmount *mnt,
 	if (retval)
 		return retval;
 
-	if (inode->i_op->getattr_it)
-		return inode->i_op->getattr_it(mnt, dentry, it, stat);
 	if (inode->i_op->getattr)
 		return inode->i_op->getattr(mnt, dentry, stat);
 
@@ -64,20 +62,14 @@ int vfs_getattr_it(struct vfsmount *mnt,
 
 EXPORT_SYMBOL(vfs_getattr);
 
-int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
-{
-	return vfs_getattr_it(mnt, dentry, NULL, stat);
-}
-
 int vfs_stat(char __user *name, struct kstat *stat)
 {
 	struct nameidata nd;
 	int error;
-	intent_init(&nd.intent, IT_GETATTR);
 
-	FSHOOK_BEGIN_USER_PATH_WALK_IT(stat, error, name, nd, path, .link = false)
+	FSHOOK_BEGIN_USER_PATH_WALK(stat, error, name, nd, path, .link = false)
 
-		error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.intent, stat);
+		error = vfs_getattr(nd.mnt, nd.dentry, stat);
 		path_release(&nd);
 
 	FSHOOK_END_USER_WALK(stat, error, path)
@@ -91,11 +83,10 @@ int vfs_lstat(char __user *name, struct 
 {
 	struct nameidata nd;
 	int error;
-	intent_init(&nd.intent, IT_GETATTR);
 
-	FSHOOK_BEGIN_USER_PATH_WALK_LINK_IT(stat, error, name, nd, path, .link = true)
+	FSHOOK_BEGIN_USER_PATH_WALK_LINK(stat, error, name, nd, path, .link = true)
 
-		error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.intent, stat);
+		error = vfs_getattr(nd.mnt, nd.dentry, stat);
 		path_release(&nd);
 
 	FSHOOK_END_USER_WALK(stat, error, path)
@@ -108,8 +99,6 @@ EXPORT_SYMBOL(vfs_lstat);
 int vfs_fstat(unsigned int fd, struct kstat *stat)
 {
 	int error;
-	struct nameidata nd;
-	intent_init(&nd.intent, IT_GETATTR);
 
 	FSHOOK_BEGIN(fstat, error, .fd = fd)
 
@@ -117,8 +106,7 @@ int vfs_fstat(unsigned int fd, struct ks
 
 	error = -EBADF;
 	if (f) {
-		error = vfs_getattr_it(f->f_vfsmnt, f->f_dentry, &nd.intent, stat);
-		intent_release(&nd.intent);
+		error = vfs_getattr(f->f_vfsmnt, f->f_dentry, stat);
 		fput(f);
 	}
 
diff -uNrp linux-2.6.5/fs/super.c linux-2.6.5.no-lustre-intent/fs/super.c
--- linux-2.6.5/fs/super.c	2004-05-26 23:49:25.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/fs/super.c	2004-05-26 23:52:59.000000000 +0200
@@ -804,8 +804,6 @@ out:
 	return (struct vfsmount *)sb;
 }
 
-EXPORT_SYMBOL(do_kern_mount);
-
 struct vfsmount *kern_mount(struct file_system_type *type)
 {
 	return do_kern_mount(type->name, 0, type->name, NULL);
diff -uNrp linux-2.6.5/include/linux/blockgroup_lock.h linux-2.6.5.no-lustre-intent/include/linux/blockgroup_lock.h
--- linux-2.6.5/include/linux/blockgroup_lock.h	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/include/linux/blockgroup_lock.h	2004-05-26 23:52:59.000000000 +0200
@@ -3,8 +3,6 @@
  *
  * Simple hashed spinlocking.
  */
-#ifndef _LINUX_BLOCKGROUP_LOCK_H
-#define _LINUX_BLOCKGROUP_LOCK_H
 
 #include <linux/config.h>
 #include <linux/spinlock.h>
@@ -57,4 +55,4 @@ static inline void bgl_lock_init(struct 
 #define sb_bgl_lock(sb, block_group) \
 	(&(sb)->s_blockgroup_lock.locks[(block_group) & (NR_BG_LOCKS-1)].lock)
 
-#endif
+
diff -uNrp linux-2.6.5/include/linux/dcache.h linux-2.6.5.no-lustre-intent/include/linux/dcache.h
--- linux-2.6.5/include/linux/dcache.h	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/include/linux/dcache.h	2004-05-26 23:52:59.000000000 +0200
@@ -4,7 +4,6 @@
 #ifdef __KERNEL__
 
 #include <asm/atomic.h>
-#include <linux/string.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/cache.h>
@@ -25,11 +24,6 @@ struct vfsmount;
 
 #define IS_ROOT(x) ((x) == (x)->d_parent)
 
-struct dentry_params {
-	unsigned long   p_inum;
-	void            *p_ptr;
-};
-
 /*
  * "quick string" -- eases parameter passing, but more importantly
  * saves "metadata" about the string (ie length and the hash).
@@ -41,8 +35,6 @@ struct qstr {
 	char name_str[0];
 };
 
-#include <linux/namei.h>
-
 struct dentry_stat_t {
 	int nr_dentry;
 	int nr_unused;
@@ -161,8 +153,6 @@ d_iput:		no		no		yes
 
 #define DCACHE_REFERENCED	0x0008  /* Recently used, don't discard. */
 #define DCACHE_UNHASHED		0x0010	
-#define DCACHE_LUSTRE_INVALID     0x0020  /* Lustre invalidated */
-
 
 extern spinlock_t dcache_lock;
 
@@ -234,7 +224,6 @@ extern int have_submounts(struct dentry 
  * This adds the entry to the hash queues.
  */
 extern void d_rehash(struct dentry *);
-extern void __d_rehash(struct dentry *, int lock);
 
 /**
  * d_add - add dentry to hash queues
@@ -253,7 +242,6 @@ static inline void d_add(struct dentry *
 
 /* used for rename() and baskets */
 extern void d_move(struct dentry *, struct dentry *);
-extern void __d_move(struct dentry *, struct dentry *);
 
 /* appendix may either be NULL or be used for transname suffixes */
 extern struct dentry * d_lookup(struct dentry *, struct qstr *);
diff -uNrp linux-2.6.5/include/linux/ext2_fs_sb.h linux-2.6.5.no-lustre-intent/include/linux/ext2_fs_sb.h
--- linux-2.6.5/include/linux/ext2_fs_sb.h	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/include/linux/ext2_fs_sb.h	2004-05-26 23:52:59.000000000 +0200
@@ -16,11 +16,9 @@
 #ifndef _LINUX_EXT2_FS_SB
 #define _LINUX_EXT2_FS_SB
 
-#ifndef EXT_INCLUDE
-#define EXT_INCLUDE
 #include <linux/blockgroup_lock.h>
 #include <linux/percpu_counter.h>
-#endif
+
 /*
  * second extended-fs super-block data in memory
  */
diff -uNrp linux-2.6.5/include/linux/fs.h linux-2.6.5.no-lustre-intent/include/linux/fs.h
--- linux-2.6.5/include/linux/fs.h	2004-05-26 23:49:28.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/include/linux/fs.h	2004-05-26 23:52:59.000000000 +0200
@@ -250,8 +250,6 @@ typedef void (dio_iodone_t)(struct inode
 #define ATTR_ATTR_FLAG	1024
 #define ATTR_KILL_SUID	2048
 #define ATTR_KILL_SGID	4096
-#define ATTR_RAW       	8192    /* file system, not vfs will massage attrs */
-#define ATTR_FROM_OPEN 	16384    /* called from open path, ie O_TRUNC */
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -322,7 +320,6 @@ struct address_space_operations {
 	int (*releasepage) (struct page *, int);
 	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs);
-	void (*removepage)(struct page *); /* called when page gets removed from the inode */
 };
 
 struct backing_dev_info;
@@ -426,7 +423,6 @@ struct inode {
 	struct block_device	*i_bdev;
 	struct cdev		*i_cdev;
 	int			i_cindex;
-	void			*i_filterdata;
 
 	unsigned long		i_dnotify_mask; /* Directory notify events */
 	struct dnotify_struct	*i_dnotify; /* for directory notifications */
@@ -560,7 +556,6 @@ struct file {
 	spinlock_t		f_ep_lock;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
- 	struct lookup_intent    *f_it;
 };
 extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
@@ -879,28 +874,19 @@ struct inode_operations {
 	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
 	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
-	int (*link_raw) (struct nameidata *,struct nameidata *);
 	int (*unlink) (struct inode *,struct dentry *);
-	int (*unlink_raw) (struct nameidata *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
-	int (*symlink_raw) (struct nameidata *,const char *);
 	int (*mkdir) (struct inode *,struct dentry *,int);
-	int (*mkdir_raw) (struct nameidata *,int);
 	int (*rmdir) (struct inode *,struct dentry *);
-	int (*rmdir_raw) (struct nameidata *);
 	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
-	int (*mknod_raw) (struct nameidata *,int,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
-	int (*rename_raw) (struct nameidata *, struct nameidata *);
 	int (*readlink) (struct dentry *, char __user *,int);
 	int (*follow_link) (struct dentry *, struct nameidata *);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int, struct nameidata *);
 	int (*setattr) (struct dentry *, struct iattr *);
-	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
-	int (*getattr_it) (struct vfsmount *, struct dentry *, struct lookup_intent *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
@@ -1129,7 +1115,6 @@ extern int __register_filesystem(struct 
 extern int unregister_filesystem(struct file_system_type *);
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount(struct vfsmount *);
-struct vfsmount *do_kern_mount(const char *type, int flags, const char *name, void *data);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
 
 extern int vfs_statfs(struct super_block *, struct kstatfs *);
@@ -1191,10 +1176,9 @@ static inline int break_lease(struct ino
 
 /* fs/open.c */
 
-extern int do_truncate(struct dentry *, loff_t start, int called_from_open);
+extern int do_truncate(struct dentry *, loff_t start);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
-extern struct file * dentry_open_it(struct dentry *, struct vfsmount *, int, struct lookup_intent *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
 
@@ -1448,7 +1432,6 @@ static inline ssize_t blockdev_direct_IO
 
 extern struct file_operations generic_ro_fops;
 
-extern rwlock_t file_systems_lock;
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
 
 extern int vfs_readlink(struct dentry *, char __user *, int, const char *);
diff -uNrp linux-2.6.5/include/linux/fshooks.h linux-2.6.5.no-lustre-intent/include/linux/fshooks.h
--- linux-2.6.5/include/linux/fshooks.h	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/include/linux/fshooks.h	2004-05-26 23:52:54.000000000 +0200
@@ -90,18 +90,12 @@ void fshook_run_post(fshook_info_t info,
 
 #define FSHOOK_BEGIN_USER_WALK(type, err, path, flags, nd, field, args...) \
 		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk(path, flags, &nd, &info.field), nd, args)
-#define FSHOOK_BEGIN_USER_WALK_IT(type, err, path, flags, nd, field, args...) \
-		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk_it(path, flags, &nd, &info.field), nd, args)
 
 #define FSHOOK_BEGIN_USER_PATH_WALK(type, err, path, nd, field, args...) \
 		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk(path, LOOKUP_FOLLOW, &nd, &info.field), nd, args)
-#define FSHOOK_BEGIN_USER_PATH_WALK_IT(type, err, path, nd, field, args...) \
-		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk_it(path, LOOKUP_FOLLOW, &nd, &info.field), nd, args)
 
 #define FSHOOK_BEGIN_USER_PATH_WALK_LINK(type, err, path, nd, field, args...) \
 		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk(path, 0, &nd, &info.field), nd, args)
-#define FSHOOK_BEGIN_USER_PATH_WALK_LINK_IT(type, err, path, nd, field, args...) \
-		FSHOOK_BEGIN_USER_WALK_COMMON(type, err, __user_walk_it(path, 0, &nd, &info.field), nd, args)
 
 #define FSHOOK_END_USER_WALK(type, err, field) \
 				(void)(&info != (struct fshook_##type##_info *)-1L); \
@@ -132,18 +126,12 @@ void fshook_run_post(fshook_info_t info,
 
 #define FSHOOK_BEGIN_USER_WALK(type, err, path, flags, nd, field, args...) \
 	if (!(err = __user_walk(path, flags, &nd, 0))) {
-#define FSHOOK_BEGIN_USER_WALK_IT(type, err, path, flags, nd, field, args...) \
-	if (!(err = __user_walk_it(path, flags, &nd, 0))) {
 
 #define FSHOOK_BEGIN_USER_PATH_WALK(type, err, path, nd, field, args...) \
 	if (!(err = user_path_walk(path, &nd))) {
-#define FSHOOK_BEGIN_USER_PATH_WALK_IT(type, err, path, nd, field, args...) \
-	if (!(err = user_path_walk_it(path, &nd))) {
 
 #define FSHOOK_BEGIN_USER_PATH_WALK_LINK(type, err, path, nd, field, args...) \
 	if (!(err = user_path_walk_link(path, &nd))) {
-#define FSHOOK_BEGIN_USER_PATH_WALK_LINK_IT(type, err, path, nd, field, args...) \
-	if (!(err = user_path_walk_link_it(path, &nd))) {
 
 #define FSHOOK_END_USER_WALK(type, err, field) ((void)0);}
 
diff -uNrp linux-2.6.5/include/linux/lustre_version.h linux-2.6.5.no-lustre-intent/include/linux/lustre_version.h
--- linux-2.6.5/include/linux/lustre_version.h	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/include/linux/lustre_version.h	2004-05-26 23:52:59.000000000 +0200
@@ -1 +0,0 @@
-#define LUSTRE_KERNEL_VERSION 36
diff -uNrp linux-2.6.5/include/linux/mm.h linux-2.6.5.no-lustre-intent/include/linux/mm.h
--- linux-2.6.5/include/linux/mm.h	2004-05-26 23:49:27.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/include/linux/mm.h	2004-05-26 23:52:59.000000000 +0200
@@ -577,8 +577,6 @@ static inline unsigned long page_nodenum
 {
 	return (page->flags >> (NODEZONE_SHIFT + ZONES_SHIFT));
 }
-/* truncate.c */
-extern void truncate_complete_page(struct address_space *mapping,struct page *);
 
 struct zone;
 extern struct zone *zone_table[];
diff -uNrp linux-2.6.5/include/linux/namei.h linux-2.6.5.no-lustre-intent/include/linux/namei.h
--- linux-2.6.5/include/linux/namei.h	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/include/linux/namei.h	2004-05-26 23:52:59.000000000 +0200
@@ -2,55 +2,25 @@
 #define _LINUX_NAMEI_H
 
 #include <linux/linkage.h>
-#include <linux/string.h>
 
 struct vfsmount;
-struct nameidata;
 
-/* intent opcodes */
-#define IT_OPEN     (1)
-#define IT_CREAT    (1<<1)
-#define IT_READDIR  (1<<2)
-#define IT_GETATTR  (1<<3)
-#define IT_LOOKUP   (1<<4)
-#define IT_UNLINK   (1<<5)
-#define IT_TRUNC    (1<<6)
-#define IT_GETXATTR (1<<7)
-
-struct lustre_intent_data {
-	int       it_disposition;
-	int       it_status;
-	__u64     it_lock_handle;
-	void     *it_data;
-	int       it_lock_mode;
+struct open_intent {
+	int	flags;
+	int	create_mode;
 };
 
-#define INTENT_MAGIC 0x19620323
-struct lookup_intent {
-	int     it_magic;
-	void    (*it_op_release)(struct lookup_intent *);
-	int     it_op;
-	int	it_flags;
-	int	it_create_mode;
-	union {
-		struct lustre_intent_data lustre;
-	} d;
-};
-
-static inline void intent_init(struct lookup_intent *it, int op)
-{
-	memset(it, 0, sizeof(*it));
-	it->it_magic = INTENT_MAGIC;
-	it->it_op = op;
-}
-
 struct nameidata {
 	struct dentry	*dentry;
 	struct vfsmount *mnt;
 	struct qstr	last;
 	unsigned int	flags;
 	int		last_type;
-	struct lookup_intent intent;
+
+	/* Intent data */
+	union {
+		struct open_intent open;
+	} intent;
 };
 
 /*
@@ -71,9 +41,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LA
 #define LOOKUP_CONTINUE		 4
 #define LOOKUP_PARENT		16
 #define LOOKUP_NOALT		32
-#define LOOKUP_LAST		 (1<<6)
-#define LOOKUP_LINK_NOTLAST	 (1<<7)
-
 /*
  * Intent data
  */
@@ -82,12 +49,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LA
 #define LOOKUP_ACCESS		(0x0400)
 
 extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *, const char **));
-extern int FASTCALL(__user_walk_it(const char __user *, unsigned, struct nameidata *, const char **));
-#define user_path_walk_it(name,nd) \
-	__user_walk_it(name, LOOKUP_FOLLOW, nd, 0)
-#define user_path_walk_link_it(name,nd) \
-	__user_walk_it(name, 0, nd, 0)
-extern void intent_release(struct lookup_intent *);
 #define user_path_walk(name,nd) \
 	__user_walk(name, LOOKUP_FOLLOW, nd, 0)
 #define user_path_walk_link(name,nd) \
@@ -99,6 +60,7 @@ extern void path_release(struct nameidat
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
+
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);
 
diff -uNrp linux-2.6.5/include/linux/percpu_counter.h linux-2.6.5.no-lustre-intent/include/linux/percpu_counter.h
--- linux-2.6.5/include/linux/percpu_counter.h	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/include/linux/percpu_counter.h	2004-05-26 23:52:59.000000000 +0200
@@ -3,8 +3,6 @@
  *
  * WARNING: these things are HUGE.  4 kbytes per counter on 32-way P4.
  */
-#ifndef _LINUX_PERCPU_COUNTER_H
-#define _LINUX_PERCPU_COUNTER_H
 
 #include <linux/config.h>
 #include <linux/spinlock.h>
@@ -103,5 +101,3 @@ static inline void percpu_counter_dec(st
 {
 	percpu_counter_mod(fbc, -1);
 }
-
-#endif /* _LINUX_PERCPU_COUNTER_H */
diff -uNrp linux-2.6.5/kernel/exit.c linux-2.6.5.no-lustre-intent/kernel/exit.c
--- linux-2.6.5/kernel/exit.c	2004-05-26 23:49:27.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/kernel/exit.c	2004-05-26 23:52:59.000000000 +0200
@@ -265,8 +265,6 @@ void reparent_to_init(void)
 	write_unlock_irq(&tasklist_lock);
 }
 
-EXPORT_SYMBOL(reparent_to_init);
-
 void __set_special_pids(pid_t session, pid_t pgrp)
 {
 	struct task_struct *curr = current;
@@ -436,8 +434,6 @@ void exit_files(struct task_struct *tsk)
 	__exit_files(tsk);
 }
 
-EXPORT_SYMBOL(exit_files);
-
 static inline void __put_fs_struct(struct fs_struct *fs)
 {
 	/* No need to hold fs->lock if we are killing it */
diff -uNrp linux-2.6.5/kernel/kallsyms.c linux-2.6.5.no-lustre-intent/kernel/kallsyms.c
--- linux-2.6.5/kernel/kallsyms.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/kernel/kallsyms.c	2004-05-26 23:52:59.000000000 +0200
@@ -323,4 +323,3 @@ __initcall(kallsyms_init);
 
 EXPORT_SYMBOL(kallsyms_lookup);
 EXPORT_SYMBOL(__print_symbol);
-EXPORT_SYMBOL(kernel_text_address);
diff -uNrp linux-2.6.5/mm/filemap.c linux-2.6.5.no-lustre-intent/mm/filemap.c
--- linux-2.6.5/mm/filemap.c	2004-05-26 23:49:28.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/mm/filemap.c	2004-05-26 23:52:59.000000000 +0200
@@ -105,9 +105,6 @@ void __remove_from_page_cache(struct pag
 {
 	struct address_space *mapping = page_mapping(page);
 
-	if (mapping->a_ops->removepage)
-		mapping->a_ops->removepage(page);
-
 	if (likely(!PageSwapCache(page))) {
 		BUG_ON(PageAnon(page));
 		WARN_ON(page->mapcount);
diff -uNrp linux-2.6.5/mm/truncate.c linux-2.6.5.no-lustre-intent/mm/truncate.c
--- linux-2.6.5/mm/truncate.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/mm/truncate.c	2004-05-26 23:52:59.000000000 +0200
@@ -42,7 +42,7 @@ static inline void truncate_partial_page
  * its lock, b) when a concurrent invalidate_inode_pages got there first and
  * c) when tmpfs swizzles a page between a tmpfs inode and swapper_space.
  */
-void
+static void
 truncate_complete_page(struct address_space *mapping, struct page *page)
 {
 	if (page->mapping != mapping)
@@ -57,7 +57,7 @@ truncate_complete_page(struct address_sp
 	remove_from_page_cache(page);
 	page_cache_release(page);	/* pagecache ref */
 }
-EXPORT_SYMBOL_GPL(truncate_complete_page);
+
 /*
  * This is for invalidate_inode_pages().  That function can be called at
  * any time, and is not supposed to throw away dirty pages.  But pages can
diff -uNrp linux-2.6.5/net/unix/af_unix.c linux-2.6.5.no-lustre-intent/net/unix/af_unix.c
--- linux-2.6.5/net/unix/af_unix.c	2004-05-26 23:49:19.000000000 +0200
+++ linux-2.6.5.no-lustre-intent/net/unix/af_unix.c	2004-05-26 23:52:59.000000000 +0200
@@ -676,7 +676,6 @@ static struct sock *unix_find_other(stru
 	int err = 0;
 	
 	if (sunname->sun_path[0]) {
-		intent_init(&nd.intent, IT_LOOKUP);
 		err = path_lookup(sunname->sun_path, LOOKUP_FOLLOW, &nd);
 		if (err)
 			goto fail;
