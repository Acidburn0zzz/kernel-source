From: Jens Axboe <axboe@suse.de>
Subject: Let the filp slab use SLAB_DESTROY_BY_RCU
Patch-mainline: Not yet (going for 2.6.19)
References: 172825

This solves the cache affinity problem with RCU slab objects, since we
can get the hot objects returned before the RCU grace period has ended.

Acked-by: 
Signed-off-by: 

---
 fs/dcache.c     |    3 ++-
 fs/file_table.c |    8 +-------
 2 files changed, 3 insertions(+), 8 deletions(-)

--- linux-2.6.24.orig/fs/dcache.c
+++ linux-2.6.24/fs/dcache.c
@@ -2166,7 +2166,8 @@ void __init vfs_caches_init(unsigned lon
 			SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
 
 	filp_cachep = kmem_cache_create("filp", sizeof(struct file), 0,
-			SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
+			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU,
+			NULL);
 
 	dcache_init();
 	inode_init();
--- linux-2.6.24.orig/fs/file_table.c
+++ linux-2.6.24/fs/file_table.c
@@ -33,16 +33,10 @@ __cacheline_aligned_in_smp DEFINE_SPINLO
 
 static struct percpu_counter nr_files __cacheline_aligned_in_smp;
 
-static inline void file_free_rcu(struct rcu_head *head)
-{
-	struct file *f =  container_of(head, struct file, f_u.fu_rcuhead);
-	kmem_cache_free(filp_cachep, f);
-}
-
 static inline void file_free(struct file *f)
 {
 	percpu_counter_dec(&nr_files);
-	call_rcu(&f->f_u.fu_rcuhead, file_free_rcu);
+	kmem_cache_free(filp_cachep, f);
 }
 
 /*
