diff -Nru --exclude='*SCCS*' a/fs/rcfs/dir.c b/fs/rcfs/dir.c
--- a/fs/rcfs/dir.c	2004-04-26 12:35:37.000000000 -0400
+++ b/fs/rcfs/dir.c	2004-04-28 22:57:32.000000000 -0400
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/namei.h>
+#include <asm/namei.h>
 #include <linux/namespace.h>
 #include <linux/dcache.h>
 #include <linux/seq_file.h>
@@ -40,48 +41,39 @@
 #include <asm/uaccess.h>
 
 #include <linux/rcfs.h>
-#include "magic.h"
 
 
-rbce_eng_callback_t rcfs_eng_callbacks = {
-	NULL, NULL
-};
-/* Helper functions */
 
 #define rcfs_positive(dentry)  ((dentry)->d_inode && !d_unhashed((dentry)))
 
-#if 0
-static
 int rcfs_empty(struct dentry *dentry)
 {
-	struct dentry *child;
-	int ret = 0;
-
-	/* Don't use now - don't know if its safe to take the dcache_lock */
-	return 0 ;
-
-	spin_lock(&dcache_lock);
-	list_for_each_entry(child, &dentry->d_subdirs, d_child) 
-		if (!rcfs_is_magic(child) && rcfs_positive(child))
-			goto out;
-	ret = 1;
+        struct dentry *child;
+        int ret = 0;
+                                                                                               
+        spin_lock(&dcache_lock);
+        list_for_each_entry(child, &dentry->d_subdirs, d_child)
+                if (!rcfs_is_magic(child) && rcfs_positive(child))
+                        goto out;
+        ret = 1;
 out:
-	spin_unlock(&dcache_lock);
-	return ret;
+        spin_unlock(&dcache_lock);
+        return ret;
 }
-#endif
+
+                                                                                               
+
+
+/* Directory inode operations */
 
 
 int 
-rcfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+rcfs_create(struct inode *dir, struct dentry *dentry, int mode, 
+	    struct nameidata *nd)
 {
-	// USEME later when files are only created automagically
-	// return -EPERM;
 	return rcfs_mknod(dir, dentry, mode | S_IFREG, 0);
 }
-
-
-/* Directory inode operations */
+EXPORT_SYMBOL(rcfs_create);
 
 
 /* Symlinks permitted ?? */
@@ -105,23 +97,53 @@
 	}
 	return error;
 }
+EXPORT_SYMBOL(rcfs_symlink);
 
+int
+rcfs_create_coredir(struct inode *dir, struct dentry *dentry)
+{
 
-int 
+	struct rcfs_inode_info *ripar, *ridir;
+	int sz;
+
+	ripar = RCFS_I(dir);
+	ridir = RCFS_I(dentry->d_inode);
+
+	// Inform RC's - do Core operations 
+	if (ckrm_is_core_valid(ripar->core)) {
+		sz = strlen(ripar->name) + strlen(dentry->d_name.name) + 2 ;
+		ridir->name = kmalloc(sz, GFP_KERNEL);
+		if (!ridir->name) {
+			return -ENOMEM;
+		}
+		snprintf(ridir->name, sz,"%s/%s", ripar->name, 
+			 dentry->d_name.name);
+		ridir->core = (*(ripar->core->classtype->alloc))
+			(ripar->core,ridir->name);
+	}
+	else {
+		printk(KERN_ERR "rcfs_mkdir: Invalid parent core %p\n",
+		       ripar->core);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(rcfs_create_coredir);
+
+
+int
 rcfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
-#if 0
-	struct dentry *ldentry;
-	int mfmode,i;
-#endif
-	int retval;
-	struct rcfs_inode_info *ripar,*ridir;
-	struct dentry *pd = list_entry(dir->i_dentry.next, struct dentry, d_alias);
 
-//	printk(KERN_ERR "rcfs_mkdir called with dir=%p dentry=%p mode=%d\n",dir,dentry,mode);
+	int retval = 0;
+	ckrm_classtype_t *clstype;
 
+#if 0
+	struct dentry *pd = list_entry(dir->i_dentry.next, struct dentry, 
+							d_alias);
 	if ((!strcmp(pd->d_name.name, "/") &&
-				!strcmp(dentry->d_name.name, "ce"))) {
+	     !strcmp(dentry->d_name.name, "ce"))) {
 		// Call CE's mkdir if it has registered, else fail.
 		if (rcfs_eng_callbacks.mkdir) {
 			return (*rcfs_eng_callbacks.mkdir)(dir, dentry, mode);
@@ -129,108 +151,51 @@
 			return -EINVAL;
 		}
 	}
-
-
-	// Creation of /rcfs/network reserved for network controllers
-
-	if ((!strcmp(pd->d_name.name, "/") &&
-				!strcmp(dentry->d_name.name, "network"))) {
-		return -EPERM;
-	}
-
-#if 0
-	// Creation in /rcfs/network is not allowed
-	// XXX - would be good to instead add a check with the parent's 
-	// core class
-	{
-		extern struct dentry *rcfs_nwde;
-		
-		if (dir == rcfs_nwde->d_inode)
-			return -EPERM;
-	}
 #endif
 
-
-	retval  = rcfs_mknod(dir, dentry, mode | S_IFDIR, 0);
-	if (retval) {
-		printk(KERN_ERR "rcfs_mkdir: error reaching parent\n");
+	if (_rcfs_mknod(dir, dentry, mode | S_IFDIR, 0)) {
+		printk(KERN_ERR "rcfs_mkdir: error in _rcfs_mknod\n");
 		return retval;
 	}
 
 	dir->i_nlink++;
 
-	ripar = RCFS_I(dir);
-	ridir = RCFS_I(dentry->d_inode);
+	// Inherit parent's ops since _rcfs_mknod assigns noperm ops
+	dentry->d_inode->i_op = dir->i_op;
+	dentry->d_inode->i_fop = dir->i_fop;
 
-	/* Inform RC's - do Core operations */
-	/* On error, goto mkdir_err */
 
-	if (is_core_valid(ripar->core))
-		ridir->core = ckrm_alloc_core_class(
-				(ckrm_core_class_t *)ripar->core, dentry);
-	else {
-		printk(KERN_ERR "rcfs_mkdir: Invalid parent core \n");
-		return -EINVAL;
+ 	retval = rcfs_create_coredir(dir, dentry);
+ 	if (retval) {
+		simple_rmdir(dir,dentry);
+		return retval;
+                // goto mkdir_err;
 	}
-#if 0
-	mfmode = S_IFREG | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;	
-	for (i=0; i < NR_MAGF; i++) {
-		ldentry = 
-			rcfs_create_internal(dentry, magf[i].name, mfmode, 0);
-		if (!ldentry) {
-			printk(KERN_ERR "rcfs_mkdir: error creating magic files. Improve handling\n");
-			goto mkdir_err;
-		}
-		ldentry->d_fsdata = &RCFS_IS_MAGIC;
- 		if (magf[i].i_op)
- 			ldentry->d_inode->i_op = magf[i].i_op;
- 		if (magf[i].i_fop)
- 			ldentry->d_inode->i_fop = magf[i].i_fop;
  
- 		printk(KERN_ERR "rcfs_mkdir: magic entry created(%s, inode %p, dentry %p) created\n",ldentry->d_name.name, ldentry->d_inode, ldentry);
+ 	// create the default set of magic files 
+	clstype = (RCFS_I(dentry->d_inode))->core->classtype;
+	rcfs_create_magic(dentry, &(((struct rcfs_magf*)clstype->mfdesc)[1]), 
+			  clstype->mfcount-1);
 
-	}
-#endif
 	return retval;
 
 //mkdir_err:
 	dir->i_nlink--;
-	return -EINVAL;
+	return retval;
 }
+EXPORT_SYMBOL(rcfs_mkdir);
 
 
 int 
 rcfs_rmdir(struct inode * dir, struct dentry * dentry)
 {
 	struct rcfs_inode_info *ri = RCFS_I(dentry->d_inode);
-	struct dentry *pd = list_entry(dir->i_dentry.next, struct dentry, d_alias);
-
-	
-//	printk(KERN_ERR "dir %p, dentry name %s inode %p, parent name %s inode %p\n", dir, dentry->d_name.name, dentry->d_inode, dentry->d_parent->d_name.name, dentry->d_parent->d_inode);
-	
-
-	/* Class about to be deleted.
-	   Order of operations
-	   - underlying rcfs entry removal (so no new ops initiated from user space)
-	   - Core class removal (should handle CE initiated changes as well)
-	   - rcfs dir removal 
-	*/
-
 
-	/* Ensure following first
-	   a) members/ subdir empty.
-	   b) no subdirs except members, no files except magic (latter not necessary
-	      once we disallow all file creation.
-	   c) remove members/ & magic files
-	   If errors doing any of those, barf.
-	*/
 #if 0
- 	rcfs_clear_magic(dentry);
-#endif
- 	// FIXME - this should be only be removed automagically on CE unregister only
-	
+	struct dentry *pd = list_entry(dir->i_dentry.next, 
+				       struct dentry, d_alias);
 	if ((!strcmp(pd->d_name.name, "/") &&
-				!strcmp(dentry->d_name.name, "ce"))) {
+	     !strcmp(dentry->d_name.name, "ce"))) {
 		// Call CE's mkdir if it has registered, else fail.
 		if (rcfs_eng_callbacks.rmdir) {
 			return (*rcfs_eng_callbacks.rmdir)(dir, dentry);
@@ -238,60 +203,134 @@
 			return simple_rmdir(dir, dentry);
 		}
 	}
+	else if ((!strcmp(pd->d_name.name, "/") &&
+		  !strcmp(dentry->d_name.name, "network"))) {
+		return -EPERM;
+	}
+#endif
+	
+	if (!rcfs_empty(dentry)) {
+		printk(KERN_ERR "rcfs_rmdir: directory not empty\n");
+		goto out;
+	}
 
+	// Core class removal 
 
-	/* Core class removal */
-	// printk(KERN_ERR "About to remove %s ( %p)\n",dentry->d_name.name, ri);
+	if (ri->core == NULL) {
+		printk(KERN_ERR "rcfs_rmdir: core==NULL\n");
+		// likely a race condition
+		return 0;
+	}
 
-	if (ckrm_free_core_class(ri->core)) {
+	if ((*(ri->core->classtype->free))(ri->core)) {
 		printk(KERN_ERR "rcfs_rmdir: ckrm_free_core_class failed\n");
-		goto recreate_magic;
+		goto out;
 	}
-	ri->core = NULL ; /* just to be safe */
+	ri->core = NULL ; // just to be safe 
+
+	// Clear magic files only after core successfully removed 
+ 	rcfs_clear_magic(dentry);
 
-	/*
-	dentry->d_inode->i_nlink--;	
-	*/
 	return simple_rmdir(dir, dentry);
 
-recreate_magic:
-	printk("rcfs_rmdir: should recreate magic files here. Do manually now\n");
-	return -EINVAL;
+out:
+	return -EBUSY;
 }
+EXPORT_SYMBOL(rcfs_rmdir);
+
 
 int
-rcfs_register_engine(rbce_eng_callback_t *rcbs)
+rcfs_unlink(struct inode *dir, struct dentry *dentry)
 {
-	if (!rcbs->mkdir || rcfs_eng_callbacks.mkdir) {
-		return -EINVAL;
-	}
-	rcfs_eng_callbacks = *rcbs;
-	return 0;
+	// -ENOENT and not -ENOPERM to allow rm -rf to work despite 
+	// magic files being present
+	return -ENOENT;
 }
-
+EXPORT_SYMBOL(rcfs_unlink);
+	
+// rename is allowed on directories only
 int
-rcfs_unregister_engine(rbce_eng_callback_t *rcbs)
+rcfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		struct inode *new_dir, struct dentry *new_dentry)
 {
-	if (!rcbs->mkdir || !rcfs_eng_callbacks.mkdir ||
-			(rcbs->mkdir != rcfs_eng_callbacks.mkdir)) {
+	if (S_ISDIR(old_dentry->d_inode->i_mode)) 
+		return simple_rename(old_dir, old_dentry, new_dir, new_dentry);
+	else
 		return -EINVAL;
-	}
-	rcfs_eng_callbacks.mkdir = NULL;
-	rcfs_eng_callbacks.rmdir = NULL;
-	return 0;
 }
+EXPORT_SYMBOL(rcfs_rename);
+
 
 struct inode_operations rcfs_dir_inode_operations = {
 	.create		= rcfs_create,
 	.lookup		= simple_lookup,
 	.link		= simple_link,
-	.unlink		= simple_unlink,
+	.unlink		= rcfs_unlink,
 	.symlink	= rcfs_symlink,
 	.mkdir		= rcfs_mkdir,
 	.rmdir          = rcfs_rmdir,
 	.mknod		= rcfs_mknod,
-	.rename		= simple_rename,
+	.rename		= rcfs_rename,
 };
 
-EXPORT_SYMBOL(rcfs_register_engine);
-EXPORT_SYMBOL(rcfs_unregister_engine);
+
+
+
+
+int 
+rcfs_root_create(struct inode *dir, struct dentry *dentry, int mode, 
+		 struct nameidata *nd)
+{
+	return -EPERM;
+}
+
+
+int  
+rcfs_root_symlink(struct inode * dir, struct dentry *dentry, 
+		  const char * symname)
+{
+	return -EPERM;
+}
+
+int 
+rcfs_root_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	return -EPERM;
+}
+
+int 
+rcfs_root_rmdir(struct inode * dir, struct dentry * dentry)
+{
+	return -EPERM;
+}
+
+int
+rcfs_root_unlink(struct inode *dir, struct dentry *dentry)
+{
+	return -EPERM;
+}
+
+int
+rcfs_root_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+{
+	return -EPERM;
+}
+	
+int
+rcfs_root_rename(struct inode *old_dir, struct dentry *old_dentry,
+		struct inode *new_dir, struct dentry *new_dentry)
+{
+	return -EPERM;
+}
+
+struct inode_operations rcfs_rootdir_inode_operations = {
+	.create		= rcfs_root_create,
+	.lookup		= simple_lookup,
+	.link		= simple_link,
+	.unlink		= rcfs_root_unlink,
+	.symlink	= rcfs_root_symlink,
+	.mkdir		= rcfs_root_mkdir,
+	.rmdir          = rcfs_root_rmdir,
+	.mknod		= rcfs_root_mknod,
+	.rename		= rcfs_root_rename,
+};
diff -Nru --exclude='*SCCS*' a/fs/rcfs/file.c b/fs/rcfs/file.c
--- a/fs/rcfs/file.c	2004-04-26 12:35:37.000000000 -0400
+++ b/fs/rcfs/file.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,110 +0,0 @@
-/* 
- * fs/rcfs/inode.c 
- *
- * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
- *           
- * 
- * Resource class filesystem (rcfs) forming the 
- * user interface to Class-based Kernel Resource Management (CKRM).
- *
- * Latest version, more details at http://ckrm.sf.net
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-/* Changes
- *
- * 05 Mar 2004
- *        Created.
- * 06 Mar 2004
- *        Parsing for shares added
- */
-
-
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/namei.h>
-#include <linux/namespace.h>
-#include <linux/dcache.h>
-#include <linux/seq_file.h>
-#include <linux/pagemap.h>
-#include <linux/highmem.h>
-#include <linux/init.h>
-#include <linux/string.h>
-#include <linux/smp_lock.h>
-#include <linux/backing-dev.h>
-#include <linux/parser.h>
-
-#include <asm/uaccess.h>
-
-#include <linux/rcfs.h>
-#include "magic.h"
-
-
-
-/* Magic file info */
-
-#define MAG_FILE_MODE (S_IFREG | S_IRUGO | S_IWUSR) 
-#define MAG_DIR_MODE  (S_IFDIR | S_IRUGO | S_IXUGO) 
- 	
-
-struct magf_t magf[NR_MAGF] = {
-	{ 
-		.name    =  "target", 
-		.mode    = MAG_FILE_MODE, 
-		.i_fop    = &target_fileops, 
-	},
-	{ 
-		.name    =  "shares", 
-		.mode    = MAG_FILE_MODE, 
-		.i_fop    = &shares_fileops, 
-	},
-	{ 
-		.name    =  "stats", 
-		.mode    = MAG_FILE_MODE, 
-		.i_fop    = &stats_fileops, 
-	},
-	{ 
-		.name    =  "config", 
-		.mode    = MAG_FILE_MODE, 
-		.i_fop    = &config_fileops, 
-	},
-	{ 
-		.name    =  "members", 
-		.mode    = MAG_FILE_MODE, 
-		.i_fop   = &members_fileops,
-	}
-};
-
-
-/* rcfs has no files to handle except magic files  */
-/* So the generic file ops here can be deleted once the code is working */
-
-
-/*******************************Generic file ops ********************/
-
-
-struct address_space_operations rcfs_aops = {
-	.readpage	= simple_readpage,
-	.prepare_write	= simple_prepare_write,
-	.commit_write	= simple_commit_write
-};
-
-struct file_operations rcfs_file_operations = {
-//	.open           = rcfs_open,
-//	.read           = seq_read,
-//	.llseek         = seq_lseek,
-//	.release        = seq_release,
-//	.write          = generic_file_write,
-//	.read		= generic_file_read,
-//	.write		= generic_file_write,
-//	.mmap		= generic_file_mmap,
-//	.fsync		= simple_sync_file,
-//	.sendfile	= generic_file_sendfile,
-//	.llseek		= generic_file_llseek,
-};
-
diff -Nru --exclude='*SCCS*' a/fs/rcfs/inode.c b/fs/rcfs/inode.c
--- a/fs/rcfs/inode.c	2004-04-26 12:35:37.000000000 -0400
+++ b/fs/rcfs/inode.c	2004-04-28 22:57:32.000000000 -0400
@@ -30,6 +30,7 @@
 #include <linux/list.h>
 #include <linux/fs.h>
 #include <linux/namei.h>
+#include <asm/namei.h>
 #include <linux/namespace.h>
 #include <linux/dcache.h>
 #include <linux/seq_file.h>
@@ -40,24 +41,15 @@
 #include <linux/smp_lock.h>
 #include <linux/backing-dev.h>
 #include <linux/parser.h>
-
 #include <asm/uaccess.h>
 
 #include <linux/rcfs.h>
-#include "magic.h"
-
-
-/* Address of variable used as flag to indicate a magic file, value unimportant */
-int RCFS_IS_MAGIC;
-
 
-//static struct magf_t mymagf = { "mymagf", NULL, 100, &rcfs_file_operations };
 
 
-static struct backing_dev_info rcfs_backing_dev_info = {
-	.ra_pages	= 0,	/* No readahead */
-	.memory_backed	= 1,	/* Does not contribute to dirty memory */
-};
+// Address of variable used as flag to indicate a magic file, 
+// ; value unimportant 
+int RCFS_IS_MAGIC;
 
 
 struct inode *rcfs_get_inode(struct super_block *sb, int mode, dev_t dev)
@@ -70,23 +62,24 @@
 		inode->i_gid = current->fsgid;
 		inode->i_blksize = PAGE_CACHE_SIZE;
 		inode->i_blocks = 0;
-		inode->i_mapping->a_ops = &rcfs_aops;
-		inode->i_mapping->backing_dev_info = &rcfs_backing_dev_info;
 		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 		switch (mode & S_IFMT) {
 		default:
 			init_special_inode(inode, mode, dev);
 			break;
 		case S_IFREG:
-			/* Treat as default assignment */
+			// Treat as default assignment */
 			inode->i_op = &rcfs_file_inode_operations;
-			inode->i_fop = &rcfs_file_operations;
+			// inode->i_fop = &rcfs_file_operations;
 			break;
 		case S_IFDIR:
-			inode->i_op = &rcfs_dir_inode_operations;
+			// inode->i_op = &rcfs_dir_inode_operations;
+			inode->i_op = &rcfs_rootdir_inode_operations;
 			inode->i_fop = &simple_dir_operations;
 
-			/* directory inodes start off with i_nlink == 2 (for "." entry) */
+			// directory inodes start off with i_nlink == 2 
+			//  (for "." entry)
+ 
 			inode->i_nlink++;
 			break;
 		case S_IFLNK:
@@ -99,14 +92,16 @@
 
 
 
-int 
+int
 _rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
 {
 	struct inode *inode;
-	int error = -ENOSPC, i=0;
+	int error = -EPERM;
 
-	inode = rcfs_get_inode(dir->i_sb, mode, dev);
+	if (dentry->d_inode)
+		return -EEXIST;
 
+	inode = rcfs_get_inode(dir->i_sb, mode, dev);
 	if (inode) {
 		if (dir->i_mode & S_ISGID) {
 			inode->i_gid = dir->i_gid;
@@ -114,124 +109,53 @@
 				inode->i_mode |= S_ISGID;
 		}
 		d_instantiate(dentry, inode);
-		dget(dentry);	/* Extra count - pin the dentry in core */
+		dget(dentry);	
 		error = 0;
-
-		printk (KERN_INFO "%s being created\n", dentry->d_name.name);
-
-
-		/* Reassign i_op, i_fop for magic files */
-		/* Safe to do here as /rcfs/ce, /rcfs/network shouldn't invoke
-		   rcfs_mknod */
-
-		i=0;
-		while ((i < NR_MAGF) && magf[i].name && 
-		       (strnicmp(dentry->d_name.name,magf[i].name,MAGF_NAMELEN))) 
-			i++;
-		
-		if (i < NR_MAGF) {
-			if (magf[i].i_fop)
-				inode->i_fop = magf[i].i_fop;
-			if (magf[i].i_op)
-				inode->i_op = magf[i].i_op;
-		}
 	}
-	return error;
-}
-
-int
-rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
-{
 
-        // printk(KERN_ERR "rcfs_mknod called with dir=%p dentry=%p mode=%d\n",dir,dentry,mode);
-	// Do not allow creation of files by the user. Only directories i.e.
-	// the classes can be created.
-
-	if ((mode & S_IFMT) == S_IFREG)
-		return -EINVAL;
-	else 
-		return _rcfs_mknod(dir, dentry, mode, dev);
+	return error;
 }
+EXPORT_SYMBOL(_rcfs_mknod);
 
 
-#if 0
 int
-rcfs_create_magic(struct dentry *parent, struct magf_t *magf)
+rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
 {
-	struct qstr qstr;
-	struct dentry *mfdentry ;
-
-
-	if (!(magf && magf->name && magf->mode && (magf->i_op || magf->i_fop)))
+	// User can only create directories, not files
+	if ((mode & S_IFMT) != S_IFDIR)
 		return -EINVAL;
 
-	dget(parent);
-
-	/* Get new dentry for name  */
-	qstr.name = magf->name;
-	qstr.len = strlen(magf->name);
-	qstr.hash = full_name_hash(magf->name,qstr.len);
-	mfdentry = lookup_hash(&qstr,parent);
-
-	if (!IS_ERR(mfdentry)) {
-		int err; 
-
-		down(&parent->d_inode->i_sem);
-		err = rcfs_mknod(parent->d_inode, mfdentry, magf->mode, 0);
-		up(&parent->d_inode->i_sem);
-
-		if (err) {
-			dput(mfdentry);
-			dput(parent);
-			return -EINVAL;
-		}
-
-		if (magf->i_op)
-			mfdentry->d_inode->i_op = magf->i_op;
-		if (magf->i_fop)
-			mfdentry->d_inode->i_fop = magf->i_fop;
-		mfdentry->d_fsdata = &RCFS_IS_MAGIC; // flag for magic file/dir
-	}
-	dput(parent);
-
-	return 0 ;
+	return  dir->i_op->mkdir(dir, dentry, mode);
 }
-#endif
+EXPORT_SYMBOL(rcfs_mknod);
 
-void
-rcfs_make_core(struct dentry *sp, struct ckrm_core_class *core)
-{
-	RCFS_I(sp->d_inode)->core = ckrm_alloc_core_class(core, sp);	
-	return;
-}
-EXPORT_SYMBOL(rcfs_make_core);
 
 struct dentry * 
-rcfs_create_internal(struct dentry *parent, const char *name, int mfmode, 
-			int magic)
+rcfs_create_internal(struct dentry *parent, struct rcfs_magf *magf, int magic)
 {
 	struct qstr qstr;
 	struct dentry *mfdentry ;
 
-	
-	/* Get new dentry for name  */
-	qstr.name = name;
-	qstr.len = strlen(name);
-	qstr.hash = full_name_hash(name,qstr.len);
+	// Get new dentry for name  
+ 	qstr.name = magf->name;
+ 	qstr.len = strlen(magf->name);
+ 	qstr.hash = full_name_hash(magf->name,qstr.len);
 	mfdentry = lookup_hash(&qstr,parent);
 
-	printk(KERN_INFO "parent %p name %s mfdentry is %p\n",parent, name, (void *)mfdentry);
-
 	if (!IS_ERR(mfdentry)) {
 		int err; 
 
 		down(&parent->d_inode->i_sem);
-//		if (magic)
-		if (S_ISDIR(mfmode))
-			err = rcfs_mkdir(parent->d_inode, mfdentry, mfmode);
-		else
-			err = _rcfs_mknod(parent->d_inode, mfdentry, mfmode, 0);
-		parent->d_inode->i_nlink++;
+ 		if (magic && (magf->mode & S_IFDIR))
+ 			err = parent->d_inode->i_op->mkdir(parent->d_inode,
+						   mfdentry, magf->mode);
+		else {
+ 			err =_rcfs_mknod(parent->d_inode,mfdentry,
+					 magf->mode,0);
+			// _rcfs_mknod doesn't increment parent's link count, 
+			// i_op->mkdir does.
+			parent->d_inode->i_nlink++;
+		}
 		up(&parent->d_inode->i_sem);
 
 		if (err) {
@@ -243,6 +167,7 @@
 }
 EXPORT_SYMBOL(rcfs_create_internal);
 
+int 
 rcfs_delete_internal(struct dentry *mfdentry)
 {
 	struct dentry *parent ;
@@ -252,6 +177,9 @@
 	
 	parent = mfdentry->d_parent;
 
+	if (!mfdentry->d_inode) {
+		return 0;
+	}
 	down(&mfdentry->d_inode->i_sem);
 	if (S_ISDIR(mfdentry->d_inode->i_mode))
 		simple_rmdir(parent->d_inode, mfdentry);
@@ -260,27 +188,10 @@
 	up(&mfdentry->d_inode->i_sem);
 
 	d_delete(mfdentry);
-	dput(mfdentry);
-
-	return 0;
-}
 
-int 
-rcfs_clear_magic(struct dentry *parent)
-{
-	struct dentry *mftmp, *mfdentry ;
-	
-	list_for_each_entry_safe(mfdentry, mftmp, &parent->d_subdirs, d_child) {
-		
-		if (!rcfs_is_magic(mfdentry))
-			continue ;
-		
-		if (rcfs_delete_internal(mfdentry)) 
-			printk(KERN_ERR "rcfs_clear_magic: error deleting one\n");
-	}
-	
 	return 0;
 }
+EXPORT_SYMBOL(rcfs_delete_internal);
 
 struct inode_operations rcfs_file_inode_operations = {
 	.getattr	= simple_getattr,
@@ -288,9 +199,6 @@
 		
 
 
-	
-
-
 
 
 
diff -Nru --exclude='*SCCS*' a/fs/rcfs/magic.c b/fs/rcfs/magic.c
--- a/fs/rcfs/magic.c	1969-12-31 19:00:00.000000000 -0500
+++ b/fs/rcfs/magic.c	2004-04-28 22:57:32.000000000 -0400
@@ -0,0 +1,546 @@
+/* 
+ * fs/rcfs/magic.c 
+ *
+ * Copyright (C) Shailabh Nagar,      IBM Corp. 2004
+ *           (C) Vivek Kashyap,       IBM Corp. 2004
+ *           (C) Chandra Seetharaman, IBM Corp. 2004
+ *           (C) Hubertus Franke,     IBM Corp. 2004
+ * 
+ * File operations for common magic files in rcfs, 
+ * the user interface for CKRM. 
+ * 
+ * 
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 23 Apr 2004
+ *        Created from code kept earlier in fs/rcfs/magic_*.c
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <asm/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/parser.h>
+#include <asm/uaccess.h>
+
+#include <linux/rcfs.h>
+
+
+
+
+/******************************************************
+ * Macros
+ *
+ * generic macros to assist in writing magic fileops
+ *
+ *****************************************************/
+
+
+#define MAGIC_SHOW(FUNC)                                               \
+static int                                                             \
+FUNC ## _show(struct seq_file *s, void *v)			       \
+{								       \
+	int rc=0;						       \
+	ckrm_core_class_t *core ;				       \
+								       \
+	core = (ckrm_core_class_t *)                                   \
+		(((struct rcfs_inode_info *)s->private)->core);	       \
+								       \
+	if (!ckrm_is_core_valid(core)) {			       \
+		return -EINVAL;					       \
+        }                                                              \
+                                                                       \
+	if (core->classtype->show_ ## FUNC)			       \
+		rc = (* core->classtype->show_ ## FUNC)(core, s);      \
+								       \
+	return rc;						       \
+};                                                                      
+ 
+
+#define MAGIC_OPEN(FUNC)                                               \
+static int                                                             \
+FUNC ## _open(struct inode *inode, struct file *file)                  \
+{                                                                      \
+	struct rcfs_inode_info *ri;                                    \
+	int ret=-EINVAL;                                               \
+								       \
+	if (file->f_dentry && file->f_dentry->d_parent) {	       \
+								       \
+		ri = RCFS_I(file->f_dentry->d_parent->d_inode);	       \
+		ret = single_open(file,FUNC ## _show, (void *)ri);     \
+	}							       \
+	return ret;						       \
+}								       
+								       
+#define MAGIC_CLOSE(FUNC)                                              \
+static int                                                             \
+FUNC ## _close(struct inode *inode, struct file *file)		       \
+{								       \
+	return single_release(inode,file);			       \
+}
+								       
+
+
+#define MAGIC_PARSE(FUNC)                                              \
+static int                                                             \
+FUNC ## _parse(char *options, char **resstr, char **otherstr)	       \
+{								       \
+	char *p;						       \
+								       \
+	if (!options)						       \
+		return 1;					       \
+								       \
+	while ((p = strsep(&options, ",")) != NULL) {		       \
+		substring_t args[MAX_OPT_ARGS];			       \
+		int token;					       \
+								       \
+		if (!*p)					       \
+			continue;				       \
+								       \
+		token = match_token(p, FUNC##_tokens, args);           \
+		switch (token) {				       \
+		case FUNC ## _res_type:			               \
+			*resstr = match_strdup(args);		       \
+			break;					       \
+		case FUNC ## _str:			               \
+			*otherstr = match_strdup(args);		       \
+			break;					       \
+		default:					       \
+			return 0;				       \
+		}                                                      \
+	}                                                              \
+	return 1;                                                      \
+}
+
+#define MAGIC_WRITE(FUNC,CLSTYPEFUN)                                   \
+static ssize_t                                                         \
+FUNC ## _write(struct file *file, const char __user *buf,	       \
+			   size_t count, loff_t *ppos)		       \
+{								       \
+	struct rcfs_inode_info *ri = 				       \
+		RCFS_I(file->f_dentry->d_parent->d_inode);	       \
+	char *optbuf, *otherstr=NULL, *resname=NULL;		       \
+	int done, rc = 0;					       \
+	ckrm_core_class_t *core ;				       \
+								       \
+	core = ri->core;					       \
+	if (!ckrm_is_core_valid(core)) 				       \
+		return -EINVAL;					       \
+								       \
+	if ((ssize_t) count < 0 				       \
+	    || (ssize_t) count > FUNC ## _max_input_size)              \
+		return -EINVAL;					       \
+								       \
+	if (!access_ok(VERIFY_READ, buf, count))		       \
+		return -EFAULT;					       \
+								       \
+	down(&(ri->vfs_inode.i_sem));				       \
+								       \
+	optbuf = kmalloc(FUNC ## _max_input_size, GFP_KERNEL);         \
+	__copy_from_user(optbuf, buf, count);			       \
+	if (optbuf[count-1] == '\n')				       \
+		optbuf[count-1]='\0';				       \
+								       \
+	done = FUNC ## _parse(optbuf, &resname, &otherstr);            \
+								       \
+	if (!done) {						       \
+		printk(KERN_ERR "Error parsing FUNC \n");	       \
+		goto FUNC ## _write_out;			       \
+	}							       \
+								       \
+	if (core->classtype-> CLSTYPEFUN) {		               \
+		rc = (*core->classtype->CLSTYPEFUN)	               \
+			(core, resname, otherstr);		       \
+		if (rc) {					       \
+			printk(KERN_ERR "FUNC_write: CLSTYPEFUN error\n");   \
+			goto FUNC ## _write_out; 	               \
+		}						       \
+	}							       \
+								       \
+FUNC ## _write_out:						       \
+	up(&(ri->vfs_inode.i_sem));				       \
+	kfree(optbuf);						       \
+	kfree(otherstr);					       \
+	kfree(resname);						       \
+	return rc ? rc : count;					       \
+}
+								       
+								       
+#define MAGIC_RD_FILEOPS(FUNC)                                         \
+struct file_operations FUNC ## _fileops = {                            \
+	.open           = FUNC ## _open,			       \
+	.read           = seq_read,				       \
+	.llseek         = seq_lseek,				       \
+	.release        = FUNC ## _close,			       \
+};                                                                     \
+EXPORT_SYMBOL(FUNC ## _fileops);
+
+								       
+#define MAGIC_RDWR_FILEOPS(FUNC)                                       \
+struct file_operations FUNC ## _fileops = {                            \
+	.open           = FUNC ## _open,			       \
+	.read           = seq_read,				       \
+	.llseek         = seq_lseek,				       \
+	.release        = FUNC ## _close,			       \
+	.write          = FUNC ## _write,	                       \
+};                                                                     \
+EXPORT_SYMBOL(FUNC ## _fileops);
+
+
+/********************************************************************************
+ * Target
+ *
+ * pseudo file for manually reclassifying members to a class
+ *
+ *******************************************************************************/
+
+#define TARGET_MAX_INPUT_SIZE 100
+
+static ssize_t
+target_write(struct file *file, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	struct rcfs_inode_info *ri= RCFS_I(file->f_dentry->d_inode);
+	char *optbuf;
+	int rc = -EINVAL;
+	ckrm_classtype_t *clstype;
+
+
+	if ((ssize_t) count < 0 || (ssize_t) count > TARGET_MAX_INPUT_SIZE)
+		return -EINVAL;
+	
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+	
+	down(&(ri->vfs_inode.i_sem));
+	
+	optbuf = kmalloc(TARGET_MAX_INPUT_SIZE, GFP_KERNEL);
+	__copy_from_user(optbuf, buf, count);
+	if (optbuf[count-1] == '\n')
+		optbuf[count-1]='\0';
+
+	clstype = ri->core->classtype;
+	if (clstype->forced_reclassify)
+		rc = (* clstype->forced_reclassify)(ri->core,optbuf);
+
+	up(&(ri->vfs_inode.i_sem));
+	kfree(optbuf);
+	return !rc ? count : rc;
+
+}
+
+struct file_operations target_fileops = {
+	.write          = target_write,
+};
+EXPORT_SYMBOL(target_fileops);
+
+
+
+/********************************************************************************
+ * Config
+ *
+ * Set/get configuration parameters of a class. 
+ *
+ *******************************************************************************/
+
+/* Currently there are no per-class config parameters defined.
+ * Use existing code as a template
+ */
+								       
+#define config_max_input_size  300
+
+enum config_token_t {
+         config_str, config_res_type, config_err
+};
+
+static match_table_t config_tokens = {
+	{config_res_type,"res=%s"},
+	{config_str, "config=%s"},
+        {config_err, NULL},
+};
+
+
+MAGIC_PARSE(config);
+MAGIC_WRITE(config,set_config);
+MAGIC_SHOW(config);
+MAGIC_OPEN(config);
+MAGIC_CLOSE(config);
+
+MAGIC_RDWR_FILEOPS(config);
+
+
+/********************************************************************************
+ * Members
+ *
+ * List members of a class
+ *
+ *******************************************************************************/
+
+MAGIC_SHOW(members);
+MAGIC_OPEN(members);
+MAGIC_CLOSE(members);
+
+MAGIC_RD_FILEOPS(members);
+
+
+/********************************************************************************
+ * Stats
+ *
+ * Get/reset class statistics
+ * No standard set of stats defined. Each resource controller chooses
+ * its own set of statistics to maintain and export.
+ *
+ *******************************************************************************/
+
+#define stats_max_input_size  50
+
+enum stats_token_t {
+         stats_res_type, stats_str,stats_err
+};
+
+static match_table_t stats_tokens = {
+	{stats_res_type,"res=%s"},
+	{stats_str, NULL},
+        {stats_err, NULL},
+};
+
+
+MAGIC_PARSE(stats);
+MAGIC_WRITE(stats,reset_stats);
+MAGIC_SHOW(stats);
+MAGIC_OPEN(stats);
+MAGIC_CLOSE(stats);
+
+MAGIC_RDWR_FILEOPS(stats);
+
+
+/********************************************************************************
+ * Shares
+ *
+ * Set/get shares of a taskclass.
+ * Share types and semantics are defined by rcfs and ckrm core 
+ * 
+ *******************************************************************************/
+
+
+#define SHARES_MAX_INPUT_SIZE  300
+
+/* The enums for the share types should match the indices expected by
+   array parameter to ckrm_set_resshare */
+
+/* Note only the first NUM_SHAREVAL enums correspond to share types,
+   the remaining ones are for token matching purposes */
+
+enum share_token_t {
+        MY_GUAR, MY_LIM, TOT_GUAR, MAX_LIM, SHARE_RES_TYPE, SHARE_ERR
+};
+
+/* Token matching for parsing input to this magic file */
+static match_table_t shares_tokens = {
+	{SHARE_RES_TYPE, "res=%s"},
+        {MY_GUAR, "guarantee=%d"},
+        {MY_LIM,  "limit=%d"},
+	{TOT_GUAR,"total_guarantee=%d"},
+	{MAX_LIM, "max_limit=%d"},
+        {SHARE_ERR, NULL}
+};
+
+
+static int
+shares_parse(char *options, char **resstr, struct ckrm_shares *shares)
+{
+	char *p;
+	int option;
+
+	if (!options)
+		return 1;
+	
+	while ((p = strsep(&options, ",")) != NULL) {
+		
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		
+		if (!*p)
+			continue;
+
+		token = match_token(p, shares_tokens, args);
+		switch (token) {
+		case SHARE_RES_TYPE:
+			*resstr = match_strdup(args);
+			break;
+		case MY_GUAR:
+			if (match_int(args, &option))
+				return 0;
+			shares->my_guarantee = option;
+			break;
+		case MY_LIM:
+			if (match_int(args, &option))
+				return 0;
+			shares->my_limit = option;
+			break;
+		case TOT_GUAR:
+			if (match_int(args, &option))
+				return 0;
+			shares->total_guarantee = option;
+			break;
+		case MAX_LIM:
+			if (match_int(args, &option))
+				return 0;
+			shares->max_limit = option;
+			break;
+		default:
+			return 0;
+		}
+
+	}
+	return 1;
+}	
+
+
+static ssize_t
+shares_write(struct file *file, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	struct rcfs_inode_info *ri;
+	char *optbuf;
+	int rc = 0;
+	struct ckrm_core_class *core;
+	int done;
+	char *resname;
+
+	struct ckrm_shares newshares = {
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED,
+		CKRM_SHARE_UNCHANGED
+	};
+
+	if ((ssize_t) count < 0 || (ssize_t) count > SHARES_MAX_INPUT_SIZE)
+		return -EINVAL;
+	
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+
+	ri = RCFS_I(file->f_dentry->d_parent->d_inode);
+
+	if (!ri || !ckrm_is_core_valid((ckrm_core_class_t *)(ri->core))) {
+		printk(KERN_ERR "shares_write: Error accessing core class\n");
+		return -EFAULT;
+	}
+	
+	down(&inode->i_sem);
+	
+	core = ri->core; 
+	optbuf = kmalloc(SHARES_MAX_INPUT_SIZE, GFP_KERNEL);
+	__copy_from_user(optbuf, buf, count);
+	if (optbuf[count-1] == '\n')
+		optbuf[count-1]='\0';
+
+	done = shares_parse(optbuf, &resname, &newshares);
+	if (!done) {
+		printk(KERN_ERR "Error parsing shares\n");
+		rc = -EINVAL;
+		goto write_out;
+	}
+
+	if (core->classtype->set_shares) {
+		rc = (*core->classtype->set_shares)(core,resname,&newshares);
+		if (rc) {
+			printk(KERN_ERR "shares_write: resctlr share set error\n");
+			goto write_out;
+		}
+	}
+	
+	printk(KERN_ERR "Set %s shares to %d %d %d %d\n",
+	       resname,
+	       newshares.my_guarantee, 
+	       newshares.my_limit, 
+	       newshares.total_guarantee,
+	       newshares.max_limit);
+      
+	rc = count ;
+
+write_out:	
+
+	up(&inode->i_sem);
+	kfree(optbuf);
+	kfree(resname);
+	return rc;
+}
+
+
+MAGIC_SHOW(shares);
+MAGIC_OPEN(shares);
+MAGIC_CLOSE(shares);
+
+MAGIC_RDWR_FILEOPS(shares);
+
+
+
+/*
+ * magic file creation/deletion
+ *
+ */
+
+
+int 
+rcfs_clear_magic(struct dentry *parent)
+{
+	struct dentry *mftmp, *mfdentry ;
+
+	list_for_each_entry_safe(mfdentry, mftmp, &parent->d_subdirs, d_child) {
+		
+		if (!rcfs_is_magic(mfdentry))
+			continue ;
+
+		if (rcfs_delete_internal(mfdentry)) 
+			printk(KERN_ERR "rcfs_clear_magic: error deleting one\n");
+	}
+
+	return 0;
+  
+}
+EXPORT_SYMBOL(rcfs_clear_magic);
+
+
+int 
+rcfs_create_magic(struct dentry *parent, struct rcfs_magf magf[], int count)
+{
+	int i;
+	struct dentry *mfdentry;
+
+	for (i=0; i<count; i++) {
+		mfdentry = rcfs_create_internal(parent, &magf[i],0);
+		if (IS_ERR(mfdentry)) {
+			rcfs_clear_magic(parent);
+			return -ENOMEM;
+		}
+		RCFS_I(mfdentry->d_inode)->core = RCFS_I(parent->d_inode)->core;
+		mfdentry->d_fsdata = &RCFS_IS_MAGIC;
+		if (magf[i].i_fop)
+			mfdentry->d_inode->i_fop = magf[i].i_fop;
+		if (magf[i].i_op)
+			mfdentry->d_inode->i_op = magf[i].i_op;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(rcfs_create_magic);
diff -Nru --exclude='*SCCS*' a/fs/rcfs/magic_config.c b/fs/rcfs/magic_config.c
--- a/fs/rcfs/magic_config.c	2004-04-26 12:35:37.000000000 -0400
+++ b/fs/rcfs/magic_config.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,213 +0,0 @@
-/* 
- * fs/rcfs/magic_config.c 
- *
- * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
- *           
- * 
- * virtual file for setting/getting configuration values of a 
- * task class. Part of resource class file system (rcfs) 
- * interface to Class-based Kernel Resource Management (CKRM).
- *
- * Latest version, more details at http://ckrm.sf.net
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-/* Changes
- *
- * 08 Mar 2004
- *        Created.
- *
- */
-
-#include <linux/fs.h>
-#include <linux/namei.h>
-#include <linux/namespace.h>
-#include <linux/dcache.h>
-#include <linux/seq_file.h>
-#include <linux/init.h>
-#include <linux/string.h>
-#include <linux/smp_lock.h>
-#include <linux/parser.h>
-#include <asm/uaccess.h>
-
-#include <linux/rcfs.h>
-#include "magic.h"
-
-/* Currently there are no per-class config parameters defined.
- * 
- */
-
-
-#define CONFIG_MAX_INPUT_SIZE  300
-
-enum config_token_t {
-         CONFIG_STR, RES_TYPE, CONFIG_ERR
-};
-
-static match_table_t tokens = {
-	{RES_TYPE, "res=%s"},
-	{CONFIG_STR, "config=%s"},
-        {CONFIG_ERR, NULL},
-};
-
-static int config_parse(char *options, int *resid, char **cfgstr)
-{
-	char *p,resname[CKRM_MAX_RES_NAME];
-
-	if (!options)
-		return 1;
-	
-	//printk(KERN_ERR "options |%s|\n",options);
-	while ((p = strsep(&options, ",")) != NULL) {
-		
-		substring_t args[MAX_OPT_ARGS];
-		int token;
-		
-		//printk(KERN_ERR "p |%s| options |%s|\n",p,options);
-
-		if (!*p)
-			continue;
-
-		token = match_token(p, tokens, args);
-		//printk(KERN_ERR "Token %d\n",token);
-		switch (token) {
-			
-		case RES_TYPE:
-
-			match_strcpy(resname,args);
-			*resid = ckrm_resid_lookup(resname);
-			break;
-			
-		case CONFIG_STR:
-			
-			*cfgstr = match_strdup(args);
-			break;
-
-		default:
-			return 0;
-		}
-
-	}
-	return 1;
-}	
-
-/* Poorly written currently. Strings with spaces will not be accepted */
-/* Parser.c isn't buying us much here. Manual parsing might be better */
-
-static ssize_t
-config_write(struct file *file, const char __user *buf,
-			   size_t count, loff_t *ppos)
-{
-	struct rcfs_inode_info *ri = RCFS_I(file->f_dentry->d_inode);
-	char *optbuf, *cfgstr;
-	int done;
-	int resid ;
-
-	if ((ssize_t) count < 0 || (ssize_t) count > CONFIG_MAX_INPUT_SIZE)
-		return -EINVAL;
-	
-	if (!access_ok(VERIFY_READ, buf, count))
-		return -EFAULT;
-	
-	down(&(ri->vfs_inode.i_sem));
-	
-	optbuf = kmalloc(CONFIG_MAX_INPUT_SIZE, GFP_KERNEL);
-	__copy_from_user(optbuf, buf, count);
-
-	/* cat > shares puts in an extra newline */
-	if (optbuf[count-1] == '\n')
-		optbuf[count-1]='\0';
-
-	done = config_parse(optbuf, &resid, &cfgstr);
-
-	if (!done) {
-		printk(KERN_ERR "Error parsing config \n");
-		goto config_out;
-	}
-
-#if 0
-	/* Error control ? */
-	if (resid && ckrm_isregd(resid)) {
-		if (ckrm_res_ctlrs[resid].set_config)
-			(*ckrm_res_ctlrs[resid].set_config)(ri->core->resclass[resid],cfgstr) ;
-
-	}				
-#endif	
-	
-	printk(KERN_ERR "Set %d's config using %s\n", resid, cfgstr);
-	
-config_out:
-	
-	up(&(ri->vfs_inode.i_sem));
-	kfree(optbuf);
-	kfree(cfgstr);
-	return count;
-}
-
-static int 
-config_show(struct seq_file *s, void *v)
-{
-	int resid;
-
-	// USEME struct rcfs_inode_info *rinfo = RCFS_I(s->private) ;
-
-	/* Get and "display" config data for each registered resource.
-	 * Data from each resource is atomic but not across resources
-	 */
-	
-	for_each_resid(resid) {
-
-/*		if (ckrm_isregd(resid) && 
-		    ckrm_get_res_ctrlrs[resid].get_config) {
-		    if ((*(ckrm_get_res_ctrlrs[resid].get_config)(s)) < 0)
-		           goto show_out;
-                }
-*/
-		seq_printf(s, "Showing configs 1 2 3 for res %d\n",resid);
-	}
-
-	return 0;
-
-//show_out:
-
-	seq_printf(s,"Error retrieving contents of next RC. Aborting\n");
-	return 0;
-}	
-
-static int 
-config_open(struct inode *inode, struct file *file)
-{
-	int ret = single_open(file, config_show, file);
-
-	/* Store inode in seq_file->private to allow  core class retrieval later
-	   in seq_file start
-	   If seq_file not used, inode is directly available on read */
-
-	/* USEME
-	if (ret)
-		((struct seq_file *)(file->private_data))->private = inode;
-	*/
-
-	return ret;
-}
-
-static int 
-config_close(struct inode *inode, struct file *file)
-{
-	return single_release(inode,file);
-}
-
-struct file_operations config_fileops = {
-	.open           = config_open,
-	.read           = seq_read,
-	.llseek         = seq_lseek,
-	.release        = config_close,
-	.write          = config_write,
-};
-
-
diff -Nru --exclude='*SCCS*' a/fs/rcfs/magic.h b/fs/rcfs/magic.h
--- a/fs/rcfs/magic.h	2004-04-26 12:35:35.000000000 -0400
+++ b/fs/rcfs/magic.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,42 +0,0 @@
-#ifndef _LINUX_RCFS_MAGIC_H
-#define _LINUX_RCFS_MAGIC_H
-
-#include <linux/fs.h>
-#include <linux/dcache.h>
-
-#define MAGF_NAMELEN 20
-
-struct magf_t {
-	char name[MAGF_NAMELEN];
-	int mode;
-	struct inode_operations *i_op;
-	struct file_operations *i_fop;
-};
-
-
-/* Simpler to index by enum and initialize directly */
-
-
-
-enum MAGF_IDX {
-	MAGF_TARGET = 0,
-	MAGF_SHARES,
-	MAGF_STATS,
-	MAGF_CONFIG,
-	MAGF_MEMBERS,
-	NR_MAGF,	// always the last. Number of entries.
-};
-
-extern struct magf_t magf[NR_MAGF];
-extern int RCFS_IS_MAGIC;
-
-
-int rcfs_create_magic(struct dentry *parent, struct magf_t *magf);
-int rcfs_delete_all_magic(struct dentry *parent);
-
-
-#define rcfs_is_magic(dentry)  ((dentry)->d_fsdata == &RCFS_IS_MAGIC)
-
-
-
-#endif /* _LINUX_RCFS_MAGIC_H */
diff -Nru --exclude='*SCCS*' a/fs/rcfs/magic_members.c b/fs/rcfs/magic_members.c
--- a/fs/rcfs/magic_members.c	2004-04-26 12:35:37.000000000 -0400
+++ b/fs/rcfs/magic_members.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,117 +0,0 @@
-/* 
- * fs/rcfs/magic_members.c 
- *
- * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
- * Copyright (C) Vivek Kashyap,  IBM Corp. 2004
- *           
- * 
- * virtual file for getting pids belonging to a class
- * Part of resource class file system (rcfs) 
- * interface to Class-based Kernel Resource Management (CKRM).
- *
- * Latest version, more details at http://ckrm.sf.net
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-/* Changes
- *
- * 12 Mar 2004
- *        Created.
- *
- */
-
-#include <linux/fs.h>
-#include <linux/sched.h>
-#include <linux/list.h>
-#include <linux/namei.h>
-#include <linux/namespace.h>
-#include <linux/dcache.h>
-#include <linux/seq_file.h>
-#include <linux/init.h>
-#include <linux/string.h>
-#include <linux/smp_lock.h>
-#include <linux/parser.h>
-#include <asm/uaccess.h>
-
-#include <linux/rcfs.h>
-#include "magic.h"
-
-
-static int 
-members_show(struct seq_file *s, void *v)
-{
-	ckrm_core_class_t *core ;
-	struct list_head *lh;
-	struct task_struct *tsk;
-	struct ckrm_net_struct *ns = NULL;
-
-	/* Get and "display" statistics for each registered resource.
-	 * Data from each resource is "atomic" (depends on RC) 
-	 * but not across resources
-	 */
-
-	core = (ckrm_core_class_t *)
-		(((struct rcfs_inode_info *)s->private)->core);
-
-	if (!is_core_valid(core))
-		return -EINVAL;
-
-	seq_printf(s,"Printing  members of %p\n",core);
-	
-	spin_lock(&core->ckrm_lock);
-	list_for_each(lh, &core->tasklist) {	
-		if (core->class_type == CKRM_TASK_CLASS) {
-			tsk = container_of(lh, struct task_struct, ckrm_link);
-			seq_printf(s,"%ld\n", (long)tsk->pid);
-		}
-		else if (core->class_type == CKRM_NET_CLASS) {
-			ns = container_of(lh, struct ckrm_net_struct,ckrm_link);
-			seq_printf(s, "%x\\%x\n", ns->daddr4,ns->dport);
-			// To be modified to
-			// seq_printf(s, "%s\\%s\n", 
-		        // 		ntoa(ns->daddr),ntoa(ns->dport));
- 		}
-	}
-	spin_unlock(&core->ckrm_lock);
-
-	return 0;
-}	
-
-static int 
-members_open(struct inode *inode, struct file *file)
-{
-	struct rcfs_inode_info *ri;
-	int ret=-EINVAL;
-
-	if (file->f_dentry && file->f_dentry->d_parent) {
-
-		ri = RCFS_I(file->f_dentry->d_parent->d_inode);
-		printk(KERN_ERR "file %s parent %s %p %p\n",
-		       file->f_dentry->d_name.name, 
-		       file->f_dentry->d_parent->d_name.name,
-		       (void *)ri->core, (void *)&ckrm_dflt_class);
-
-		ret = single_open(file, members_show, (void *)ri);
-	}
-	return ret;
-}
-
-
-static int 
-members_close(struct inode *inode, struct file *file)
-{
-	return single_release(inode,file);
-}
-
-struct file_operations members_fileops = {
-	.open           = members_open,
-	.read           = seq_read,
-	.llseek         = seq_lseek,
-	.release        = members_close,
-};
-
diff -Nru --exclude='*SCCS*' a/fs/rcfs/magic_shares.c b/fs/rcfs/magic_shares.c
--- a/fs/rcfs/magic_shares.c	2004-04-26 12:35:37.000000000 -0400
+++ b/fs/rcfs/magic_shares.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,294 +0,0 @@
-/* 
- * fs/rcfs/magic_shares.c 
- *
- * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
- *           
- * 
- * virtual file for setting/getting share values of a 
- * task class. Part of resource class file system (rcfs) 
- * interface to Class-based Kernel Resource Management (CKRM).
- *
- * Latest version, more details at http://ckrm.sf.net
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-/* Changes
- *
- * 06 Mar 2004
- *        Created.
- *
- */
-
-#include <linux/fs.h>
-#include <linux/namei.h>
-#include <linux/namespace.h>
-#include <linux/dcache.h>
-#include <linux/seq_file.h>
-#include <linux/init.h>
-#include <linux/string.h>
-#include <linux/smp_lock.h>
-#include <linux/parser.h>
-#include <asm/uaccess.h>
-
-#include <linux/rcfs.h>
-#include "magic.h"
-
-
-/* Next few are dependent on number of share types */
-
-#define SHARES_MAX_INPUT_SIZE  300
-
-/* The enums for the share types should match the indices expected by
-   array parameter to ckrm_set_resshare */
-
-/* Note only the first NUM_SHAREVAL enums correspond to share types,
-   the remaining ones are for token matching purposes */
-
-enum share_token_t {
-        MY_GUAR, MY_LIM, TOT_GUAR, TOT_LIM, RES_TYPE, SHARE_ERR
-};
-
-/* Token matching for parsing input to this magic file */
-static match_table_t tokens = {
-	{RES_TYPE, "res=%s"},
-        {MY_GUAR, "guarantee=%d"},
-        {MY_LIM,  "limit=%d"},
-	{TOT_GUAR,"tot_guarantee=%d"},
-	{TOT_LIM, "tot_limit=%d"},
-        {SHARE_ERR, NULL}
-};
-
-
-static int shares_parse(char *options, int *resid, struct ckrm_shares *shares)
-{
-	char *p,resname[CKRM_MAX_RES_NAME];
-	int option;
-
-
-	if (!options)
-		return 1;
-	
-	//printk(KERN_ERR "options |%s|\n",options);
-	while ((p = strsep(&options, ",")) != NULL) {
-		
-		substring_t args[MAX_OPT_ARGS];
-		int token;
-		
-		//printk(KERN_ERR "p |%s| options |%s|\n",p,options);
-
-		if (!*p)
-			continue;
-
-		token = match_token(p, tokens, args);
-		//printk(KERN_ERR "Token %d\n",token);
-		switch (token) {
-			
-		case RES_TYPE:
-			
-			match_strcpy(resname,args);
-			printk(KERN_ERR "resname %s tried\n",resname);
-			*resid = ckrm_resid_lookup(resname);
-			break;
-			
-		case MY_GUAR:
-			if (match_int(args, &option))
-				return 0;
-			shares->my_guarantee = option;
-			break;
-		case MY_LIM:
-			if (match_int(args, &option))
-				return 0;
-			shares->my_limit = option;
-			break;
-		case TOT_GUAR:
-			if (match_int(args, &option))
-				return 0;
-			shares->total_guarantee = option;
-			break;
-		case TOT_LIM:
-			if (match_int(args, &option))
-				return 0;
-			shares->total_limit = option;
-			break;
-		default:
-			return 0;
-		}
-
-	}
-	return 1;
-}	
-
-
-static ssize_t
-shares_write(struct file *file, const char __user *buf,
-			   size_t count, loff_t *ppos)
-{
-	struct inode *inode = file->f_dentry->d_inode;
-	struct rcfs_inode_info *ri;
-	char *optbuf;
-	int done, resid, retval;
-
-	struct ckrm_shares newshares = {
-		CKRM_SHARE_UNCHANGED,
-		CKRM_SHARE_UNCHANGED,
-		CKRM_SHARE_UNCHANGED,
-		CKRM_SHARE_UNCHANGED,
-		CKRM_SHARE_UNCHANGED,
-		CKRM_SHARE_UNCHANGED
-	};
-
-	if ((ssize_t) count < 0 || (ssize_t) count > SHARES_MAX_INPUT_SIZE)
-		return -EINVAL;
-	
-	if (!access_ok(VERIFY_READ, buf, count))
-		return -EFAULT;
-
-	ri = RCFS_I(file->f_dentry->d_parent->d_inode);
-
-	if (!ri || !is_core_valid((ckrm_core_class_t *)(ri->core))) {
-		printk(KERN_ERR "shares_write: Error accessing core class\n");
-		return -EFAULT;
-	}
-	
-	down(&inode->i_sem);
-	
-	optbuf = kmalloc(SHARES_MAX_INPUT_SIZE, GFP_KERNEL);
-	__copy_from_user(optbuf, buf, count);
-
-	/* cat > shares puts in an extra newline */
-	if (optbuf[count-1] == '\n')
-		optbuf[count-1]='\0';
-
-	done = shares_parse(optbuf, &resid, &newshares);
-	if (!done) {
-		printk(KERN_ERR "Error parsing shares\n");
-		retval = -EINVAL;
-		goto write_out;
-	}
-	printk(KERN_WARNING "resid is %d is_res_regd is %d\n",resid, is_res_regd(resid));
-
-	if (is_res_regd(resid)) {
-
-#if 1
-		ckrm_res_callback_t *rcbs = &ckrm_res_ctlrs[resid];
-		
-		if (rcbs->set_share_values) {
-			retval = (*rcbs->set_share_values)
-				(((ckrm_core_class_t *)(ri->core))->res_class[resid],&newshares);
-			if (retval) {
-				printk(KERN_ERR "shares_write: resctlr share set error\n");
-				goto write_out;
-			}
-		}
-#endif
-	}
-	
-	printk(KERN_ERR "Set %s shares to %d %d %d %d\n",
-	       ckrm_res_ctlrs[resid].res_name, 
-	       newshares.my_guarantee, 
-	       newshares.my_limit, 
-	       newshares.total_guarantee,
-	       newshares.total_limit);
-      
-	retval = count ;
-
-write_out:	
-
-	up(&inode->i_sem);
-	kfree(optbuf);
-	return count;
-}
-
-
-static int 
-shares_show(struct seq_file *s, void *v)
-{
-	int resid,retval;
-	struct ckrm_shares curshares;
-	struct rcfs_inode_info *ri = s->private;
-
-	/* Get and "display" share data for each registered resource.
-	 * Data from each resource is atomic but not across resources
-	 */
-
-	if (!ri || !is_core_valid((ckrm_core_class_t *)(ri->core))) {
-		printk(KERN_ERR "shares_show: Error accessing core class\n");
-		return -EFAULT;
-	}
-
-
-	for_each_resid(resid) {
-		if (is_res_regd(resid)) {
-
-#if 1
-			ckrm_res_callback_t *rcbs = &ckrm_res_ctlrs[resid];
-			
-			printk(KERN_ERR "Showing %s's shares %p %p\n",rcbs->res_name,ri->core,(void *)((ckrm_core_class_t *)(ri->core))->res_class[resid]);
-		
-			if (rcbs->get_share_values) {
-				/* Copy into curshares can be removed if all RC's 
-				   keep ckrm_shares allocated - getting back the ptr
-				   is sufficient then. 
-				*/
-				retval = (*rcbs->get_share_values)
-					((void *)((ckrm_core_class_t *)(ri->core))->res_class[resid],&curshares);
-				if (retval) {
-					printk(KERN_ERR "shares_show: resctlr share get error\n");
-					goto show_out;
-				}
-				seq_printf(s,"res=%s %d %d %d %d\n",
-					   rcbs->res_name,
-					   curshares.my_guarantee, 
-					   curshares.my_limit, 
-					   curshares.total_guarantee,
-					   curshares.total_limit);
-			}
-#endif
-		} /* is_res_regd(resid) */
-	} /* for_each_resid(resid) */
-
-	return 0;
-
- show_out:
-
-	seq_printf(s,"Error retrieving contents of next RC. Aborting\n");
-	return 0;
-}	
-
-static int 
-shares_open(struct inode *inode, struct file *file)
-{
-	struct rcfs_inode_info *ri;
-	int ret=-EINVAL;
-
-	if (file->f_dentry && file->f_dentry->d_parent) {
-		printk(KERN_ERR "file %s parent %s\n",file->f_dentry->d_name.name, file->f_dentry->d_parent->d_name.name);
-
-		ri = RCFS_I(file->f_dentry->d_parent->d_inode);
-
-		ret = single_open(file, shares_show, (void *)ri);
-	}
-
-	return ret;
-}
-
-static int 
-shares_close(struct inode *inode, struct file *file)
-{
-	return single_release(inode,file);
-}
-
-struct file_operations shares_fileops = {
-	.open           = shares_open,
-	.read           = seq_read,
-	.llseek         = seq_lseek,
-	.release        = shares_close,
-	.write          = shares_write,
-};
-
-
diff -Nru --exclude='*SCCS*' a/fs/rcfs/magic_stats.c b/fs/rcfs/magic_stats.c
--- a/fs/rcfs/magic_stats.c	2004-04-26 12:35:37.000000000 -0400
+++ b/fs/rcfs/magic_stats.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,115 +0,0 @@
-/* 
- * fs/rcfs/magic_stats.c 
- *
- * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
- *           
- * 
- * virtual file for getting all statistics for a task class 
- * in rcfs.
- *
- * Latest version, more details at http://ckrm.sf.net
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-/* Changes
- *
- * 08 Mar 2004
- *        Created.
- *
- */
-
-#include <linux/fs.h>
-#include <linux/namei.h>
-#include <linux/namespace.h>
-#include <linux/dcache.h>
-#include <linux/seq_file.h>
-#include <linux/init.h>
-#include <linux/string.h>
-#include <linux/smp_lock.h>
-#include <linux/parser.h>
-#include <asm/uaccess.h>
-
-#include <linux/rcfs.h>
-#include "magic.h"
-
-static int 
-stats_show(struct seq_file *s, void *v)
-{
-	int resid,retval;
-	struct rcfs_inode_info *ri = s->private;
-
-	/* Get and "display" statistics for each registered resource.
-	 * Data from each resource is "atomic" (depends on RC) 
-	 * but not across resources
-	 */
-
-	if (!ri || !is_core_valid((ckrm_core_class_t *)(ri->core))) {
-		printk(KERN_ERR "stats_show: Error accessing core class\n");
-		return -EFAULT;
-	}
-
-	for_each_resid(resid) {
-		if (is_res_regd(resid)) {
-
-#if 1
-			ckrm_res_callback_t *rcbs = &ckrm_res_ctlrs[resid];
-			
-			printk(KERN_ERR "Showing %s's stats %p %p\n",rcbs->res_name,ri->core,(void *)((ckrm_core_class_t *)(ri->core))->res_class[resid]);
-		
-			if (rcbs->get_stats) {
-				retval = (*rcbs->get_stats)
-					((void *)((ckrm_core_class_t *)(ri->core))->res_class[resid],s);
-				if (retval) {
-					printk(KERN_ERR "stats_show: resctlr share get error\n");
-					goto show_out;
-				}
-			}
-#endif
-		} /* is_res_regd(resid) */
-	} /* for_each_resid(resid) */
-
-	return 0;
-
-show_out:
-
-	seq_printf(s,"Error retrieving stats of next RC. Aborting\n");
-	return 0;
-}	
-
-static int 
-stats_open(struct inode *inode, struct file *file)
-{
-	struct rcfs_inode_info *ri;
-	int ret=-EINVAL;
-
-	if (file->f_dentry && file->f_dentry->d_parent) {
-
-		printk(KERN_ERR "file %s parent %s\n",
-		       file->f_dentry->d_name.name, 
-		       file->f_dentry->d_parent->d_name.name);
-
-		ri = RCFS_I(file->f_dentry->d_parent->d_inode);
-		ret = single_open(file, stats_show, (void *)ri);
-	}
-	return ret;
-}
-
-static int 
-stats_close(struct inode *inode, struct file *file)
-{
-	return single_release(inode,file);
-}
-
-struct file_operations stats_fileops = {
-	.open           = stats_open,
-	.read           = seq_read,
-	.llseek         = seq_lseek,
-	.release        = stats_close,
-};
-
-
diff -Nru --exclude='*SCCS*' a/fs/rcfs/magic_target.c b/fs/rcfs/magic_target.c
--- a/fs/rcfs/magic_target.c	2004-04-26 12:35:37.000000000 -0400
+++ b/fs/rcfs/magic_target.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,209 +0,0 @@
-/* 
- * fs/rcfs/magic_target.c 
- *
- * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
- * Copyright (C) Vivek Kashyap,  IBM Corp. 2004
- *           
- * 
- * virtual file assisting in reclassification in rcfs. 
- * 
- * Writing a pid to a class's target file reclassifies the corresponding
- * task to the class.
- *
- * Latest version, more details at http://ckrm.sf.net
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-/* Changes
- *
- * 06 Mar 2004
- *        Created.
- *
- */
-
-#include <linux/types.h>
-#include <linux/sched.h>
-#include <linux/fs.h>
-#include <linux/seq_file.h>
-#include <linux/init.h>
-#include <linux/string.h>
-#include <linux/parser.h>
-#include <asm/uaccess.h>
-
-#include <linux/rcfs.h>
-#include "magic.h"
-
-
-#define TARGET_MAX_INPUT_SIZE  300
-
-/* The enums for the share types should match the indices expected by
-   array parameter to ckrm_set_resshare */
-
-/* Note only the first NUM_SHAREVAL enums correspond to share types,
-   the remaining ones are for token matching purposes */
-
-enum target_token_t {
-        PID, IPV4, IPV6, RES_TYPE, TARGET_ERR
-};
-
-static match_table_t tokens = {
-        {PID, "pid=%u"},
-	{IPV4, "ipv4=%s"},
-	{IPV6, "ipv6=%s"},
-        {TARGET_ERR, NULL},
-};
-
-
-struct target_data {
-	int flag;
-	pid_t mpid;
-	char addr[64];
-};
-
-static int target_parse(char *options, struct target_data *value)
-{
-	char *p;
-	int option;
-	int flag = TARGET_ERR;
-
-	if (!options)
-		return 1;
-	
-	//printk(KERN_ERR "options |%s|\n",options);
-	while ((p = strsep(&options, ",")) != NULL) {
-		
-		substring_t args[MAX_OPT_ARGS];
-		int token;
-		
-		//printk(KERN_ERR "p |%s| options |%s|\n",p,options);
-
-		if (!*p)
-			continue;
-
-		token = match_token(p, tokens, args);
-		//printk(KERN_ERR "Token %d\n",token);
-		switch (token) {
-			
-		case PID:
-			if (flag == TARGET_ERR)
-				flag = PID;
-			else
-				break;
-			if (match_int(args, &option))
-				return 0;
-			value->mpid = (pid_t)(option);
-			break;
-
-		case IPV4:
-			if (flag == TARGET_ERR)
-				flag = IPV4;
-			else
-				break;
-			match_strcpy(value->addr,args);
-			break;
-
-		case IPV6:
-			printk(KERN_INFO "rcfs: IPV6 not supported yet\n");
-			return 0;	
-		default:
-			return 0;
-		}
-
-	}
-	return 1;
-}	
-
-#if 0
-static int
-magic_aton(char *s)
-{
-	// TODO
-	// Add alpha to IP address conversion.
-	return 1;
-}
-#endif
-
-
-static ssize_t
-target_write(struct file *file, const char __user *buf,
-			   size_t count, loff_t *ppos)
-{
-	struct rcfs_inode_info *ri= RCFS_I(file->f_dentry->d_inode);
-	char *optbuf;
-	int done;
- 	struct target_data value;
-
-	if ((ssize_t) count < 0 || (ssize_t) count > TARGET_MAX_INPUT_SIZE)
-		return -EINVAL;
-	
-	if (!access_ok(VERIFY_READ, buf, count))
-		return -EFAULT;
-	
-	down(&(ri->vfs_inode.i_sem));
-	
-	optbuf = kmalloc(TARGET_MAX_INPUT_SIZE, GFP_KERNEL);
-	__copy_from_user(optbuf, buf, count);
-
-	/* cat > shares puts in an extra newline */
-	if (optbuf[count-1] == '\n')
-		optbuf[count-1]='\0';
-
-	done = target_parse(optbuf, &value);
-
-	if (!done) {
-		printk(KERN_ERR "Error parsing target \n");
-		goto target_out;
-	}
-
-	if (value.flag == PID) {
-		ckrm_forced_reclassify_pid(value.mpid, ri->core);
-	}
-
-#ifdef MAGIC_TARGET_TODO
-	else if (value.flag == IPV4) {
-		// Get the socket. Find the listening socket's back-pointer
-		// to ns (set in lopt when SOCKETAQ option chosen). 
-		// Dissociate from old class and join the new one.
-		
-		u32 daddr;
-		u16 dport;
-
-		memset(&saddr, 0, sizeof(saddr));
-
-		daddr = magic_aton(value.addr);
-		dport = magic_aton(value.port);
-
-		local_bh_disable();
-		sk = find_tcpv4_listener_byaddr(daddr,port);
-		sock_hold(sk);
-		local_bh_enable();
-		lock_sock(sk);
-		__sock_put(sk);	
-		ns = tcp_sk(sk)->tp->lopt->ns;
-		ckrm_forced_reclassify_net(ns, ri->core);
-		release_sock(sk);
-	}
-
-#endif
-	
-	
-
-target_out:	
-
-	up(&(ri->vfs_inode.i_sem));
-	kfree(optbuf);
-	return count;
-}
-
-
-
-struct file_operations target_fileops = {
-	.write          = target_write,
-};
-
-
diff -Nru --exclude='*SCCS*' a/fs/rcfs/Makefile b/fs/rcfs/Makefile
--- a/fs/rcfs/Makefile	2004-04-26 12:35:35.000000000 -0400
+++ b/fs/rcfs/Makefile	2004-04-28 22:57:32.000000000 -0400
@@ -4,4 +4,7 @@
 
 obj-$(CONFIG_RCFS_FS) += rcfs.o
 
-rcfs-objs := super.o inode.o dir.o file.o magic_shares.o magic_stats.o magic_target.o magic_config.o magic_members.o
+rcfs-objs := super.o inode.o dir.o rootdir.o magic.o tc_magic.o socket_fs.o 
+
+rcfs-objs-$(CONFIG_CKRM_TYPE_TASKCLASS) += tc_magic.o
+rcfs-objs-$(CONFIG_CKRM_TYPE_SOCKETCLASS) += socket_fs.o
diff -Nru --exclude='*SCCS*' a/fs/rcfs/rootdir.c b/fs/rcfs/rootdir.c
--- a/fs/rcfs/rootdir.c	1969-12-31 19:00:00.000000000 -0500
+++ b/fs/rcfs/rootdir.c	2004-04-28 22:57:32.000000000 -0400
@@ -0,0 +1,244 @@
+/* 
+ * fs/rcfs/rootdir.c 
+ *
+ * Copyright (C)   Vivek Kashyap,   IBM Corp. 2004
+ *           
+ * 
+ * Functions for creating root directories and magic files 
+ * for classtypes and classification engines under rcfs
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 08 April 2004
+ *        Created.
+ */
+
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <asm/namei.h>
+#include <linux/namespace.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/smp_lock.h>
+#include <linux/backing-dev.h>
+#include <linux/parser.h>
+
+#include <asm/uaccess.h>
+
+#include <linux/rcfs.h>
+
+
+
+rbce_eng_callback_t rcfs_eng_callbacks = {
+	NULL, NULL
+};
+
+int
+rcfs_register_engine(rbce_eng_callback_t *rcbs)
+{
+	if (!rcbs->mkdir || rcfs_eng_callbacks.mkdir) {
+		return -EINVAL;
+	}
+	rcfs_eng_callbacks = *rcbs;
+	return 0;
+}
+EXPORT_SYMBOL(rcfs_register_engine);
+
+
+
+int
+rcfs_unregister_engine(rbce_eng_callback_t *rcbs)
+{
+	if (!rcbs->mkdir || !rcfs_eng_callbacks.mkdir ||
+			(rcbs->mkdir != rcfs_eng_callbacks.mkdir)) {
+		return -EINVAL;
+	}
+	rcfs_eng_callbacks.mkdir = NULL;
+	rcfs_eng_callbacks.rmdir = NULL;
+	return 0;
+}
+EXPORT_SYMBOL(rcfs_unregister_engine);
+
+
+
+
+/* rcfs_mkroot
+ * Create and return a "root" dentry under /rcfs. Also create associated magic files 
+ *
+ * @mfdesc: array of rcfs_magf describing root dir and its magic files
+ * @count: number of entries in mfdesc
+ * @core:  core class to be associated with root
+ * @rootde: output parameter to return the newly created root dentry
+ */
+
+int 
+rcfs_mkroot(struct rcfs_magf *mfdesc, int mfcount, struct dentry **rootde)
+{
+	int sz;
+	struct rcfs_magf *rootdesc = &mfdesc[0];
+	struct dentry *dentry ;
+	struct rcfs_inode_info *rootri;
+
+	if ((mfcount < 0) || (!mfdesc))
+		return -EINVAL;
+	
+	rootdesc = &mfdesc[0];
+	printk("allocating classtype root <%s>\n",rootdesc->name);
+	dentry = rcfs_create_internal(rcfs_rootde, rootdesc,0);
+	
+	if (!dentry) {
+		printk(KERN_ERR "Could not create %s\n",rootdesc->name);
+		return -ENOMEM;
+	} 
+	
+	rootri = RCFS_I(dentry->d_inode);
+	sz = strlen(rootdesc->name) + strlen(RCFS_ROOT) + 2;
+	rootri->name = kmalloc(sz, GFP_KERNEL);
+	if (!rootri->name) {
+		printk(KERN_ERR "Error allocating name for %s\n",
+		       rootdesc->name);
+		rcfs_delete_internal(dentry);
+		return -ENOMEM;
+	}
+	snprintf(rootri->name,sz,"%s/%s",RCFS_ROOT,rootdesc->name);
+	
+	if (rootdesc->i_fop)
+		dentry->d_inode->i_fop = rootdesc->i_fop;
+	if (rootdesc->i_op)
+		dentry->d_inode->i_op = rootdesc->i_op;
+
+	// set output parameters
+	*rootde = dentry;
+
+	return 0;
+}
+EXPORT_SYMBOL(rcfs_mkroot);
+
+
+int 
+rcfs_rmroot(struct dentry *rootde)
+{
+	if (!rootde)
+		return -EINVAL;
+
+	rcfs_clear_magic(rootde);
+	kfree(RCFS_I(rootde->d_inode)->name);
+	rcfs_delete_internal(rootde);
+	return 0;
+}
+EXPORT_SYMBOL(rcfs_rmroot);
+
+
+int 
+rcfs_register_classtype(ckrm_classtype_t *clstype)
+{
+	int rc ;
+	struct rcfs_inode_info *rootri;
+	struct rcfs_magf *mfdesc;
+
+	// Initialize mfdesc, mfcount 
+	clstype->mfdesc = (void *) genmfdesc[clstype->mfidx]->rootmf;
+        clstype->mfcount = genmfdesc[clstype->mfidx]->rootmflen;
+
+	mfdesc = (struct rcfs_magf *)clstype->mfdesc;
+	
+	/* rcfs root entry has the same name as the classtype */
+	strncpy(mfdesc[0].name,clstype->name,RCFS_MAGF_NAMELEN) ;
+
+	rc = rcfs_mkroot(mfdesc,clstype->mfcount,
+				(struct dentry **)&(clstype->rootde));
+	if (rc)
+		return rc;
+
+	rootri = RCFS_I(((struct dentry *)(clstype->rootde))->d_inode);
+	rootri->core = clstype->default_class;
+	clstype->default_class->name = rootri->name;
+	ckrm_core_grab(clstype->default_class);
+	
+	// Create magic files under root 
+	if ((rc = rcfs_create_magic(clstype->rootde, &mfdesc[1], 
+				    clstype->mfcount-1))) {
+		kfree(rootri->name);
+		rcfs_delete_internal(clstype->rootde);
+		return rc;
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(rcfs_register_classtype);
+
+
+int 
+rcfs_deregister_classtype(ckrm_classtype_t *clstype)
+{
+	int rc;
+
+	rc = rcfs_rmroot((struct dentry *)clstype->rootde);
+	if (!rc) {
+		clstype->default_class->name = NULL ;
+		ckrm_core_drop(clstype->default_class);
+	}
+	return rc;
+}
+EXPORT_SYMBOL(rcfs_deregister_classtype);
+
+
+
+// Common root and magic file entries.
+// root name, root permissions, magic file names and magic file permissions are needed by
+// all entities (classtypes and classification engines) existing under the rcfs mount point
+
+// The common sets of these attributes are listed here as a table. Individual classtypes and
+// classification engines can simple specify the index into the table to initialize their
+// magf entries. 
+//
+
+#ifdef CONFIG_CKRM_TYPE_TASKCLASS
+extern struct rcfs_mfdesc tc_mfdesc;
+#endif
+
+#ifdef CONFIG_CKRM_TYPE_TASKCLASS
+extern struct rcfs_mfdesc sock_mfdesc;
+#endif
+
+// extern struct rcfs_magf rbce_mfdesc;
+
+
+struct rcfs_mfdesc *genmfdesc[]={
+#ifdef CONFIG_CKRM_TYPE_TASKCLASS
+	&tc_mfdesc,
+#else
+	NULL,
+#endif
+#ifdef CONFIG_CKRM_TYPE_SOCKETCLASS
+	&sock_mfdesc,
+#else
+	NULL,
+#endif
+// Create similar entry for RBCE ? 
+//#ifdef CONFIG_CKRM_CE
+//	&rbce_mfdesc,
+//#else
+//	NULL,
+//#endif
+
+};
+
+
+
+
diff -Nru --exclude='*SCCS*' a/fs/rcfs/socket_fs.c b/fs/rcfs/socket_fs.c
--- a/fs/rcfs/socket_fs.c	1969-12-31 19:00:00.000000000 -0500
+++ b/fs/rcfs/socket_fs.c	2004-04-28 22:57:32.000000000 -0400
@@ -0,0 +1,338 @@
+/* ckrm_socketaq.c 
+ *
+ * Copyright (C) Vivek Kashyap,      IBM Corp. 2004
+ * 
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ * Initial version
+ */
+
+/*******************************************************************************
+ *  Socket class type
+ *   
+ * Defines the root structure for socket based classes. Currently only inbound
+ * connection control is supported based on prioritized accept queues. 
+ ******************************************************************************/
+
+
+#include <linux/rcfs.h>
+#include <net/tcp.h>
+
+extern int rcfs_create(struct inode *,struct dentry *, int, struct nameidata *);
+extern int rcfs_unlink(struct inode *, struct dentry *);
+extern int  rcfs_symlink(struct inode *, struct dentry *, const char *);
+extern int rcfs_mknod(struct inode *, struct dentry *, int mode, dev_t);
+extern int rcfs_mkdir(struct inode *, struct dentry *, int);
+extern int rcfs_rmdir(struct inode *, struct dentry *);
+extern int rcfs_rename(struct inode *, struct dentry *, struct inode *, 
+		struct dentry *);
+
+extern int rcfs_create_coredir(struct inode *, struct dentry *);
+int sock_mkdir(struct inode *, struct dentry *, int mode);
+int sock_rmdir(struct inode *, struct dentry *);
+
+
+int sock_create_noperm(struct inode *, struct dentry *,int, struct nameidata *);
+int sock_unlink_noperm(struct inode *,struct dentry *);
+int sock_mkdir_noperm(struct inode *,struct dentry *,int);
+int sock_rmdir_noperm(struct inode *,struct dentry *);
+int sock_mknod_noperm(struct inode *,struct dentry *,int, dev_t);
+
+void sock_set_directory(void);
+
+extern struct file_operations config_fileops,
+			members_fileops,
+			shares_fileops,
+			stats_fileops,
+			target_fileops;
+
+
+struct inode_operations my_iops = {
+	        .create         = rcfs_create,
+		.lookup         = simple_lookup,
+		.link           = simple_link,
+		.unlink         = rcfs_unlink,
+		.symlink        = rcfs_symlink,
+		.mkdir          = sock_mkdir,
+		.rmdir          = sock_rmdir,
+		.mknod          = rcfs_mknod,
+		.rename         = rcfs_rename,
+};
+
+struct inode_operations class_iops = {
+	        .create         = sock_create_noperm,
+		.lookup         = simple_lookup,
+		.link           = simple_link,
+		.unlink         = sock_unlink_noperm,
+		.symlink        = rcfs_symlink,
+		.mkdir          = sock_mkdir_noperm,
+		.rmdir          = sock_rmdir_noperm,
+		.mknod          = sock_mknod_noperm,
+		.rename         = rcfs_rename,
+};
+
+struct inode_operations sub_iops = {
+	        .create         = sock_create_noperm,
+		.lookup         = simple_lookup,
+		.link           = simple_link,
+		.unlink         = sock_unlink_noperm,
+		.symlink        = rcfs_symlink,
+		.mkdir          = sock_mkdir_noperm,
+		.rmdir          = sock_rmdir_noperm,
+		.mknod          = sock_mknod_noperm,
+		.rename         = rcfs_rename,
+};
+
+struct rcfs_magf def_magf = {
+	.mode = RCFS_DEFAULT_DIR_MODE,
+	.i_op = &sub_iops,
+	.i_fop = NULL,
+};
+
+struct rcfs_magf sock_rootdesc[] = {
+	{
+	//	.name = should not be set, copy from classtype name,
+		.mode = RCFS_DEFAULT_DIR_MODE,
+		.i_op = &my_iops,
+		//.i_fop   = &simple_dir_operations,
+		.i_fop = NULL,
+	},
+	{
+		.name = "members",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop = &members_fileops,
+	},
+	{
+		.name = "target",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop = &target_fileops,
+	},
+};
+
+struct rcfs_magf sock_magf[] = {
+	{
+		.name = "config",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop = &config_fileops,
+	},
+	{
+		.name = "members",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop =&members_fileops,
+	},
+	{
+		.name = "shares",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop = &shares_fileops,
+	},
+	{
+		.name = "stats",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop = &stats_fileops,
+	},
+	{
+		.name = "target",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop = &target_fileops,
+	},
+};
+
+struct rcfs_magf sub_magf[] = {
+	{
+		.name = "config",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop = &config_fileops,
+	},
+	{
+		.name = "shares",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop = &shares_fileops,
+	},
+	{
+		.name = "stats",
+		.mode = RCFS_DEFAULT_FILE_MODE,
+		.i_op = &my_iops,
+		.i_fop = &stats_fileops,
+	},
+};
+
+struct rcfs_mfdesc sock_mfdesc = {
+	.rootmf		= sock_rootdesc,
+	.rootmflen 	= (sizeof(sock_rootdesc)/sizeof(struct rcfs_magf)),
+};
+
+
+#define SOCK_MAX_MAGF (sizeof(sock_magf)/sizeof(struct rcfs_magf))
+#define LAQ_MAX_SUBMAGF (sizeof(sub_magf)/sizeof(struct rcfs_magf))
+
+int 
+sock_rmdir(struct inode *p, struct dentry *me)
+{
+	struct dentry *mftmp, *mfdentry ;
+
+	// delete all magic sub directories
+	list_for_each_entry_safe(mfdentry, mftmp, &me->d_subdirs, d_child) {
+		if (S_ISDIR(mfdentry->d_inode->i_mode))
+			rcfs_rmdir(me->d_inode, mfdentry);
+	}
+	// delete ourselves
+	rcfs_rmdir(p,me);
+
+	return 0;
+}
+
+#ifdef NUM_ACCEPT_QUEUES
+#define LAQ_NUM_ACCEPT_QUEUES NUM_ACCEPT_QUEUES
+#else
+#define LAQ_NUM_ACCEPT_QUEUES 0
+#endif
+
+int
+sock_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int retval = 0;
+	int i,j;
+	struct dentry *pentry, *mfdentry;
+
+	if (_rcfs_mknod(dir, dentry, mode | S_IFDIR, 0)) {
+		printk(KERN_ERR "rcfs_mkdir: error reaching parent\n");
+		return retval;
+	}
+	
+	// Needed if only _rcfs_mknod is used instead of i_op->mkdir
+	dir->i_nlink++;
+
+	retval = rcfs_create_coredir(dir, dentry);
+	if (retval) 
+		goto mkdir_err;
+
+	/* create the default set of magic files */
+	for (i =0; i < SOCK_MAX_MAGF; i++) {
+		mfdentry = rcfs_create_internal(dentry, &sock_magf[i],0);
+		mfdentry->d_fsdata = &RCFS_IS_MAGIC;
+		RCFS_I(mfdentry->d_inode)->core = 
+				RCFS_I(dentry->d_inode)->core;
+		if (sock_magf[i].i_fop)
+			mfdentry->d_inode->i_fop = sock_magf[i].i_fop;
+		if (sock_magf[i].i_op)
+			mfdentry->d_inode->i_op = sock_magf[i].i_op;
+	}
+	
+	for (i=1; i < LAQ_NUM_ACCEPT_QUEUES; i++) {
+		j = sprintf(def_magf.name, "%d",i);
+		def_magf.name[j] = '\0';
+
+		pentry = rcfs_create_internal(dentry, &def_magf,0);
+		retval = rcfs_create_coredir(dentry->d_inode, pentry);
+		if (retval)
+			goto mkdir_err;
+		for (j=0; j < LAQ_MAX_SUBMAGF; j++) {
+			mfdentry = rcfs_create_internal(pentry, &sub_magf[j],0);
+			mfdentry->d_fsdata = &RCFS_IS_MAGIC;
+			RCFS_I(mfdentry->d_inode)->core = 
+					RCFS_I(pentry->d_inode)->core;
+			if (sub_magf[j].i_fop)
+				mfdentry->d_inode->i_fop = sub_magf[j].i_fop;
+			if (sub_magf[j].i_op)
+				mfdentry->d_inode->i_op = sub_magf[j].i_op;
+		}
+		pentry->d_inode->i_op = &sub_iops;
+	}
+	dentry->d_inode->i_op = &class_iops;
+	return 0;
+
+mkdir_err:
+	// Needed
+	dir->i_nlink--;
+	return retval;
+}
+#ifndef NUM_ACCEPT_QUEUES
+#define NUM_ACCEPT_QUEUES 0
+#endif
+
+char *
+sock_get_name(struct ckrm_core_class *c)
+{
+	char *p = (char *)c->name;
+	
+	while(*p)
+		p++;
+	while( *p != '/' && p != c->name)
+		p--;
+
+	return ++p;
+}
+
+int 
+sock_create_noperm(struct inode *dir,struct dentry *dentry,int mode, struct nameidata *nd)
+{
+	return -EPERM;
+}
+
+int 
+sock_unlink_noperm(struct inode *dir,struct dentry *dentry)
+{
+	return -EPERM;
+}
+
+int 
+sock_mkdir_noperm(struct inode *dir,struct dentry *dentry, int mode)
+{
+	return -EPERM;
+}
+
+int 
+sock_rmdir_noperm(struct inode *dir,struct dentry *dentry)
+{
+	return -EPERM;
+}
+
+int 
+sock_mknod_noperm(struct inode *dir,struct dentry *dentry,int mode, dev_t dev)
+{
+	return -EPERM;
+}
+
+#if 0
+void
+sock_set_directory()
+{
+	struct dentry *pentry, *dentry;
+
+	pentry = rcfs_set_magf_byname("listen_aq", (void *)&my_dir_magf[0]);
+	if (pentry) {
+		dentry = rcfs_create_internal(pentry, &my_dir_magf[1],0);
+		if (my_dir_magf[1].i_fop)
+			dentry->d_inode->i_fop = my_dir_magf[1].i_fop;
+		RCFS_I(dentry->d_inode)->core = 
+				RCFS_I(pentry->d_inode)->core;
+		dentry = rcfs_create_internal(pentry, &my_dir_magf[2],0);
+		if (my_dir_magf[2].i_fop)
+			dentry->d_inode->i_fop = my_dir_magf[2].i_fop;
+		RCFS_I(dentry->d_inode)->core = 
+				RCFS_I(pentry->d_inode)->core;
+	}
+	else  {
+		printk(KERN_ERR "Could not create /rcfs/listen_aq\n"
+				"Perhaps /rcfs needs to be mounted\n");
+	}
+}
+#endif
+
diff -Nru --exclude='*SCCS*' a/fs/rcfs/super.c b/fs/rcfs/super.c
--- a/fs/rcfs/super.c	2004-04-26 12:35:37.000000000 -0400
+++ b/fs/rcfs/super.c	2004-04-28 22:57:32.000000000 -0400
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/namei.h>
+#include <asm/namei.h>
 #include <linux/namespace.h>
 #include <linux/dcache.h>
 #include <linux/seq_file.h>
@@ -40,7 +41,7 @@
 #include <asm/uaccess.h>
 
 #include <linux/rcfs.h>
-
+#include <linux/ckrm.h>
 
 
 static kmem_cache_t *rcfs_inode_cachep;
@@ -50,21 +51,28 @@
 {
 	return container_of(inode, struct rcfs_inode_info, vfs_inode);
 }
+EXPORT_SYMBOL(RCFS_I);
+
 
 
 static struct inode *
 rcfs_alloc_inode(struct super_block *sb)
 {
 	struct rcfs_inode_info *ri;
-	ri = (struct rcfs_inode_info *) kmem_cache_alloc(rcfs_inode_cachep, SLAB_KERNEL);
+	ri = (struct rcfs_inode_info *) kmem_cache_alloc(rcfs_inode_cachep, 
+							 SLAB_KERNEL);
 	if (!ri)
 		return NULL;
+	ri->name = NULL;
 	return &ri->vfs_inode;
 }
 
 static void 
 rcfs_destroy_inode(struct inode *inode)
 {
+	struct rcfs_inode_info *ri = RCFS_I(inode);
+
+	kfree(ri->name);
 	kmem_cache_free(rcfs_inode_cachep, RCFS_I(inode));
 }
 
@@ -97,8 +105,6 @@
 		printk(KERN_INFO "rcfs_inode_cache: not all structures were freed\n");
 }
 
-
-/* exported operations */
 struct super_operations rcfs_super_ops =
 {
 	.alloc_inode	= rcfs_alloc_inode,
@@ -108,24 +114,34 @@
 };
 
 
+struct dentry *rcfs_rootde; /* redundant since one can also get it from sb */
+static struct inode *rcfs_root;
+static struct rcfs_inode_info *rcfs_rootri;
 
-struct dentry *rcfs_rootde, *rcfs_nwde, *rcfs_nw_aqde;
-struct inode *rcfs_root, *rcfs_nw, *rcfs_nw_aq;
-struct rcfs_inode_info *rcfs_rootri, *rcfs_nwri;
+static int rcfs_mounted;
 
 static int rcfs_fill_super(struct super_block * sb, void * data, int silent)
 {
 	struct inode * inode;
 	struct dentry * root;
 	struct rcfs_inode_info *rootri;
+	struct ckrm_classtype *clstype;
+	int i,rc;
+
+	sb->s_fs_info = NULL;
+	if (rcfs_mounted) {
+		return -EPERM;
+	}
+	rcfs_mounted++;
 
 	sb->s_blocksize = PAGE_CACHE_SIZE;
-	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;	
 	sb->s_magic = RCFS_MAGIC;
 	sb->s_op = &rcfs_super_ops;
 	inode = rcfs_get_inode(sb, S_IFDIR | 0755, 0);
 	if (!inode)
 		return -ENOMEM;
+	inode->i_op = &rcfs_rootdir_inode_operations;
 
 	root = d_alloc_root(inode);
 	if (!root) {
@@ -134,63 +150,110 @@
 	}
 	sb->s_root = root;
 
-	/* Link inode and core class */
-
+	
+	// Link inode and core class 
 	rootri = RCFS_I(inode);
-	rootri->core = &ckrm_dflt_class;
-
+	rootri->name = kmalloc(strlen(RCFS_ROOT) + 1, GFP_KERNEL);
+	if (!rootri->name) {
+		d_delete(root);
+		iput(inode);
+		return -ENOMEM;
+	}
+	strcpy(rootri->name, RCFS_ROOT);
+	rootri->core = NULL;
 
 	rcfs_root = inode;
+	sb->s_fs_info = rcfs_root = inode;
 	rcfs_rootde = root ;
 	rcfs_rootri = rootri ;
 
-	ckrm_dflt_class.dentry = rcfs_rootde;
-
-
-	printk("get_alloc_super: root class created (%s, de-%p ri-%p in-%p ri->core-%p ri->core->in-%p",root->d_name.name, root, rootri, inode, rootri->core, ((struct ckrm_core_class *)(rootri->core))->dentry);
-	
-#ifdef CONFIG_CKRM_RES_SOCKETAQ
-
-	// Currently both /rcfs/network and /rcfs/network/socket_aq are configured by 
-	// the same option. 
-
+	// register metatypes
+	for ( i=0; i<CKRM_MAX_CLASSTYPES; i++) {
+		clstype = ckrm_classtypes[i];
+		if (clstype == NULL) 
+			continue;
+		printk("A non null classtype\n");
 
-	// Create the network root
-	// XXX -- add error reporting
-	rcfs_nwde = rcfs_create_internal(rcfs_rootde, "network", 
-							rcfs_root->i_mode, 0);
-	// Link inode and core class
-	rootri = RCFS_I(rcfs_nwde->d_inode);
-	rootri->core = &ckrm_net_root;
-	ckrm_net_root.dentry = rcfs_nwde;
-
-	// Pre-create other top level network directories
-	// At present only the socket_aq direcotry.
-	rcfs_nw_aqde = rcfs_create_internal(rcfs_nwde, "socket_aq", 
-							rcfs_root->i_mode, 0);
-	// Link inode and core class
-	RCFS_I(rcfs_nw_aqde->d_inode)->core = 
-		ckrm_alloc_core_class((ckrm_core_class_t *)&ckrm_net_root,
-						rcfs_nw_aqde);
+		if ((rc = rcfs_register_classtype(clstype)))
+			continue ;  // could return with an error too 
+	}
 
-#endif
+	// register CE's with rcfs 
+	// check if CE loaded
+	// call rcfs_register_engine for each classtype
+	// AND rcfs_mkroot (preferably subsume latter in former) 
 
 	return 0;
-	
 }
 
+
 static struct super_block *rcfs_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
 	return get_sb_nodev(fs_type, flags, data, rcfs_fill_super);
 }
 
+
+void 
+rcfs_kill_sb(struct super_block *sb)
+{
+	int i,rc;
+	struct ckrm_classtype *clstype;
+
+	if (sb->s_fs_info != rcfs_root) {
+		generic_shutdown_super(sb);
+		return;
+	}
+	rcfs_mounted--;
+
+	for ( i=0; i < CKRM_MAX_CLASSTYPES; i++) {
+
+		clstype = ckrm_classtypes[i];
+		if (clstype == NULL || clstype->rootde == NULL) 
+			continue;
+
+		if ((rc = rcfs_deregister_classtype(clstype))) {
+			printk(KERN_ERR "Error removing classtype %s\n",
+			       clstype->name);
+			// return ;   // can also choose to stop here
+		}
+	}
+	
+	// do not remove comment block until ce directory issue resolved
+	// deregister CE with rcfs
+	// Check if loaded
+	// if ce is in  one directory /rcfs/ce, 
+	//       rcfs_deregister_engine for all classtypes within above 
+	//             codebase 
+	//       followed by
+	//       rcfs_rmroot here
+	// if ce in multiple (per-classtype) directories
+	//       call rbce_deregister_engine within ckrm_deregister_classtype
+
+	// following will automatically clear rcfs root entry including its 
+	//  rcfs_inode_info
+
+	generic_shutdown_super(sb);
+
+	// printk(KERN_ERR "Removed all entries\n");
+}	
+
+
 static struct file_system_type rcfs_fs_type = {
 	.name		= "rcfs",
 	.get_sb		= rcfs_get_sb,
-	.kill_sb	= kill_litter_super,
+	.kill_sb	= rcfs_kill_sb,
+};
+
+struct rcfs_functions my_rcfs_fn = {
+	.mkroot               = rcfs_mkroot,
+	.rmroot               = rcfs_rmroot,
+	.register_classtype   = rcfs_register_classtype,
+	.deregister_classtype = rcfs_deregister_classtype,
 };
 
+extern struct rcfs_functions rcfs_fn ;
+
 static int __init init_rcfs_fs(void)
 {
 	int ret;
@@ -202,6 +265,8 @@
 	ret = rcfs_init_inodecache();
 	if (ret)
 		goto init_cache_err;
+
+	rcfs_fn = my_rcfs_fn ;
 	
 	return ret;
 
@@ -220,6 +285,4 @@
 module_init(init_rcfs_fs)
 module_exit(exit_rcfs_fs)
 
-
-EXPORT_SYMBOL(RCFS_I);
 MODULE_LICENSE("GPL");
diff -Nru --exclude='*SCCS*' a/fs/rcfs/tc_magic.c b/fs/rcfs/tc_magic.c
--- a/fs/rcfs/tc_magic.c	1969-12-31 19:00:00.000000000 -0500
+++ b/fs/rcfs/tc_magic.c	2004-04-28 22:57:32.000000000 -0400
@@ -0,0 +1,94 @@
+/* 
+ * fs/rcfs/tc_magic.c 
+ *
+ * Copyright (C) Shailabh Nagar,      IBM Corp. 2004
+ *           (C) Vivek Kashyap,       IBM Corp. 2004
+ *           (C) Chandra Seetharaman, IBM Corp. 2004
+ *           (C) Hubertus Franke,     IBM Corp. 2004
+ *           
+ * 
+ * define magic fileops for taskclass classtype
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 23 Apr 2004
+ *        Created.
+ *
+ */
+
+#include <linux/rcfs.h>
+#include <linux/ckrm_tc.h>
+
+
+/*******************************************************************************
+ * Taskclass general
+ *
+ * Define structures for taskclass root directory and its magic files 
+ * In taskclasses, there is one set of magic files, created automatically under
+ * the taskclass root (upon classtype registration) and each directory (class) 
+ * created subsequently. However, classtypes can also choose to have different 
+ * sets of magic files created under their root and other directories under root
+ * using their mkdir function. RCFS only provides helper functions for creating 
+ * the root directory and its magic files
+ * 
+ *******************************************************************************/
+
+#define TC_FILE_MODE (S_IFREG | S_IRUGO | S_IWUSR) 
+	
+#define NR_TCROOTMF  6
+struct rcfs_magf tc_rootdesc[NR_TCROOTMF] = {
+	/* First entry must be root */
+	{ 
+//		.name    = should not be set, copy from classtype name
+		.mode    = RCFS_DEFAULT_DIR_MODE,
+		.i_op    = &rcfs_dir_inode_operations,
+		.i_fop   = &simple_dir_operations,
+	},
+	/* Rest are root's magic files */
+	{ 
+		.name    =  "target", 
+		.mode    = TC_FILE_MODE, 
+		.i_fop   = &target_fileops,
+		.i_op    = &rcfs_file_inode_operations,
+	},
+	{ 
+		.name    =  "config", 
+		.mode    = TC_FILE_MODE, 
+		.i_fop   = &config_fileops, 
+		.i_op    = &rcfs_file_inode_operations,
+	},
+	{ 
+		.name    =  "members", 
+		.mode    = TC_FILE_MODE, 
+		.i_fop   = &members_fileops,
+		.i_op    = &rcfs_file_inode_operations,
+	},
+	{ 
+		.name    =  "stats", 
+		.mode    = TC_FILE_MODE, 
+		.i_fop   = &stats_fileops, 
+		.i_op    = &rcfs_file_inode_operations,
+	},
+	{ 
+		.name    =  "shares", 
+		.mode    = TC_FILE_MODE,
+		.i_fop   = &shares_fileops, 
+		.i_op    = &rcfs_file_inode_operations,
+	},
+};
+
+struct rcfs_mfdesc tc_mfdesc = {
+	.rootmf          = tc_rootdesc,
+	.rootmflen       = NR_TCROOTMF,
+};
+
+
