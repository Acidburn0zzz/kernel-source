From: Takashi Iwai <tiwai@suse.de>
Subject: [PATCH] Allocate module.ref array dynamically
Patch-mainline: 
References: bnc#425240

This patch makes the module handling code to allocate the ref
array of each module struct dynamically.  It saves both module
disk space and memory footprints when number of CPUs is high
like 4096.

Reference: Novell bnc#425240
	https://bugzilla.novell.com/show_bug.cgi?id=425240

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 include/linux/module.h |    2 +-
 kernel/module.c        |   21 ++++++++++++++++-----
 2 files changed, 17 insertions(+), 6 deletions(-)

Index: linux-2.6.27/kernel/module.c
===================================================================
--- linux-2.6.27.orig/kernel/module.c
+++ linux-2.6.27/kernel/module.c
@@ -557,17 +557,28 @@ static char last_unloaded_module[MODULE_
 
 #ifdef CONFIG_MODULE_UNLOAD
 /* Init the unload section of the module. */
-static void module_unload_init(struct module *mod)
+static int module_unload_init(struct module *mod)
 {
 	unsigned int i;
+	size_t refsize = nr_cpu_ids * sizeof(*mod->ref);
 
 	INIT_LIST_HEAD(&mod->modules_which_use_me);
-	for (i = 0; i < NR_CPUS; i++)
+
+	mod->ref = kzalloc(refsize, GFP_KERNEL);
+	if (!mod->ref) {
+		mod->ref = vmalloc(refsize);
+		if (!mod->ref)
+			return -ENOMEM;
+		memset(mod->ref, 0, refsize);
+	}
+	for (i = 0; i < nr_cpu_ids; i++)
 		local_set(&mod->ref[i].count, 0);
 	/* Hold reference count during initialization. */
 	local_set(&mod->ref[raw_smp_processor_id()].count, 1);
 	/* Backwards compatibility macros put refcount during init. */
 	mod->waiter = current;
+
+	return 0;
 }
 
 /* modules using other modules */
@@ -647,6 +658,10 @@ static void module_unload_free(struct mo
 			}
 		}
 	}
+	if (is_vmalloc_addr(mod->ref))
+		vfree(mod->ref);
+	else
+		kfree(mod->ref);
 }
 
 #ifdef CONFIG_MODULE_FORCE_UNLOAD
@@ -705,7 +720,7 @@ unsigned int module_refcount(struct modu
 {
 	unsigned int i, total = 0;
 
-	for (i = 0; i < NR_CPUS; i++)
+	for (i = 0; i < nr_cpu_ids; i++)
 		total += local_read(&mod->ref[i].count);
 	return total;
 }
@@ -894,8 +909,9 @@ static inline int use_module(struct modu
 	return strong_try_module_get(b) == 0;
 }
 
-static inline void module_unload_init(struct module *mod)
+static inline int module_unload_init(struct module *mod)
 {
+	return 0;
 }
 #endif /* CONFIG_MODULE_UNLOAD */
 
@@ -2108,7 +2124,9 @@ static noinline struct module *load_modu
 	mod = (void *)sechdrs[modindex].sh_addr;
 
 	/* Now we've moved module, initialize linked lists, etc. */
-	module_unload_init(mod);
+	err = module_unload_init(mod);
+	if (err)
+		goto free_unload;
 
 	/* add kobject, so we can reference it. */
 	err = mod_sysfs_init(mod);
Index: linux-2.6.27/include/linux/module.h
===================================================================
--- linux-2.6.27.orig/include/linux/module.h
+++ linux-2.6.27/include/linux/module.h
@@ -343,7 +343,7 @@ struct module
 	void (*exit)(void);
 
 	/* Reference counts */
-	struct module_ref ref[NR_CPUS];
+	struct module_ref *ref;
 #endif
 };
 #ifndef MODULE_ARCH_INIT
