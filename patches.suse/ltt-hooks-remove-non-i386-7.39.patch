diff -urNp linux-2.6.5-7.39/arch/alpha/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/alpha/Kconfig
--- linux-2.6.5-7.39/arch/alpha/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/alpha/Kconfig	2004-05-18 19:53:33.000000000 -0700
@@ -691,38 +691,6 @@ config DEBUG_INFO
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/arm/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/Kconfig
--- linux-2.6.5-7.39/arch/arm/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/Kconfig	2004-05-18 19:53:33.000000000 -0700
@@ -736,45 +736,6 @@ config DEBUG_CLPS711X_UART2
 	  output to the second serial port on these devices.  Saying N will
 	  cause the debug messages to appear on the first serial port.
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/arm/kernel/entry-common.S linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/entry-common.S
--- linux-2.6.5-7.39/arch/arm/kernel/entry-common.S	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/entry-common.S	2004-05-18 19:53:33.000000000 -0700
@@ -39,11 +39,6 @@ ENTRY(__do_softirq)
  */
 ret_fast_syscall:
 	disable_irq r1				@ disable interrupts
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	mov	r7, r0				@ save returned r0
-	bl	SYMBOL_NAME(post_syscall)
-	mov	r0, r7
-#endif
 	ldr	r1, [tsk, #TI_FLAGS]
 	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
@@ -141,15 +136,6 @@ ENTRY(vector_swi)
 #endif
 	enable_irq ip
 
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	/* zzz note that validity of scno is not yet checked.
-	 * zzz The visualizer checks it.
-	 */
-	add	r0, sp, #S_R0			@ pointer to regs
-	bl	SYMBOL_NAME(pre_syscall)
-	add	r0, sp, #S_R0			@ pointer to regs
-	ldmia	r1, {r0 - r3}			@ have to reload r0 - r3
-#endif
 	str	r4, [sp, #-S_OFF]!		@ push fifth arg
 
 	get_thread_info tsk
@@ -189,9 +175,6 @@ __sys_trace:
 
 __sys_trace_return:
 	str	r0, [sp, #S_R0 + S_OFF]!	@ save returned r0
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	bl	SYMBOL_NAME(post_syscall)
-#endif
 	mov	r1, sp
 	mov	r0, #1				@ trace exit [IP = 1]
 	bl	syscall_trace
diff -urNp linux-2.6.5-7.39/arch/arm/kernel/irq.c linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/irq.c
--- linux-2.6.5-7.39/arch/arm/kernel/irq.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/irq.c	2004-05-18 19:53:33.000000000 -0700
@@ -32,7 +32,6 @@
 #include <linux/errno.h>
 #include <linux/list.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/irq.h>
 #include <asm/system.h>
@@ -448,7 +447,6 @@ asmlinkage void asm_do_IRQ(int irq, stru
 {
 	struct irqdesc *desc = irq_desc + irq;
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	/*
 	 * Some hardware gives randomly wrong interrupts.  Rather
 	 * than crashing, do something sensible.
@@ -468,7 +466,6 @@ asmlinkage void asm_do_IRQ(int irq, stru
 
 	spin_unlock(&irq_controller_lock);
 	irq_exit();
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 }
 
 void __set_irq_handler(unsigned int irq, irq_handler_t handle, int is_chained)
diff -urNp linux-2.6.5-7.39/arch/arm/kernel/process.c linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/process.c
--- linux-2.6.5-7.39/arch/arm/kernel/process.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/process.c	2004-05-18 19:53:33.000000000 -0700
@@ -399,7 +399,6 @@ asm(	".align\n"
 pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 {
 	struct pt_regs regs;
-	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 
@@ -409,13 +408,7 @@ pid_t kernel_thread(int (*fn)(void *), v
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
 	regs.ARM_cpsr = SVC_MODE;
 
-	ret = do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (ret > 0)
-		TRIG_EVENT(kthread_hook, ret, (int) fn);
-#endif
-
-	return  ret;
+	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
 
 /*
diff -urNp linux-2.6.5-7.39/arch/arm/kernel/sys_arm.c linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/sys_arm.c
--- linux-2.6.5-7.39/arch/arm/kernel/sys_arm.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/sys_arm.c	2004-05-18 19:53:33.000000000 -0700
@@ -25,7 +25,6 @@
 #include <linux/fs.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -167,7 +166,6 @@ asmlinkage int sys_ipc (uint call, int f
 
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
-	TRIG_EVENT(ipc_call_hook, call, first);
 
 	switch (call) {
 	case SEMOP:
diff -urNp linux-2.6.5-7.39/arch/arm/kernel/traps.c linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/traps.c
--- linux-2.6.5-7.39/arch/arm/kernel/traps.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/kernel/traps.c	2004-05-18 19:53:33.000000000 -0700
@@ -26,7 +26,6 @@
 #include <linux/interrupt.h>
 #include <linux/kallsyms.h>
 #include <linux/init.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/io.h>
@@ -314,10 +313,8 @@ asmlinkage void do_undefinstr(struct pt_
 	info.si_code  = ILL_ILLOPC;
 	info.si_addr  = pc;
 
-	TRIG_EVENT(trap_entry_hook, current->thread.trap_no, (uint32_t)pc);
 	force_sig_info(SIGILL, &info, current);
 
-	TRIG_EVENT(trap_exit_hook);
 	die_if_kernel("Oops - undefined instruction", regs, 0);
 }
 
@@ -430,9 +427,7 @@ asmlinkage int arm_syscall(int no, struc
 
 	case NR(breakpoint): /* SWI BREAK_POINT */
 		regs->ARM_pc -= thumb_mode(regs) ? 2 : 4;
-		TRIG_EVENT(trap_entry_hook, 1, (uint32_t)regs->ARM_pc);
 		ptrace_break(current, regs);
-		TRIG_EVENT(trap_exit_hook);
 		return regs->ARM_r0;
 
 	/*
@@ -531,9 +526,7 @@ baddataabort(int code, unsigned long ins
 	info.si_code  = ILL_ILLOPC;
 	info.si_addr  = (void *)addr;
 
-	TRIG_EVENT(trap_entry_hook, 18, addr);	/* machine check */
 	force_sig_info(SIGILL, &info, current);
-	TRIG_EVENT(trap_exit_hook);
 	die_if_kernel("unknown data abort code", regs, instr);
 }
 
diff -urNp linux-2.6.5-7.39/arch/arm/mm/fault-common.c linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/mm/fault-common.c
--- linux-2.6.5-7.39/arch/arm/mm/fault-common.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/arm/mm/fault-common.c	2004-05-18 19:53:33.000000000 -0700
@@ -17,7 +17,6 @@
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -248,7 +247,6 @@ int do_page_fault(unsigned long addr, un
 	if (in_interrupt() || !mm)
 		goto no_context;
 
-	TRIG_EVENT(trap_entry_hook, 14, instruction_pointer(regs));
 	down_read(&mm->mmap_sem);
 	fault = __do_page_fault(mm, addr, fsr, tsk);
 	up_read(&mm->mmap_sem);
@@ -256,10 +254,8 @@ int do_page_fault(unsigned long addr, un
 	/*
 	 * Handle the "normal" case first
 	 */
-	if (fault > 0) {
-		TRIG_EVENT(trap_exit_hook);
+	if (fault > 0)
 		return 0;
-	}
 
 	/*
 	 * We had some memory, but were unable to
@@ -285,7 +281,6 @@ int do_page_fault(unsigned long addr, un
 	} else
 		__do_user_fault(tsk, addr, fsr, fault == -1 ?
 				SEGV_ACCERR : SEGV_MAPERR, regs);
-	TRIG_EVENT(trap_exit_hook);
 	return 0;
 
 
@@ -310,14 +305,11 @@ do_sigbus:
 #endif
 
 	/* Kernel mode? Handle exceptions or die */
-	if (user_mode(regs)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (user_mode(regs))
 		return 0;
-	}
 
 no_context:
 	__do_kernel_fault(mm, addr, fsr, regs);
-	TRIG_EVENT(trap_exit_hook);
 	return 0;
 }
 
diff -urNp linux-2.6.5-7.39/arch/cris/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/cris/Kconfig
--- linux-2.6.5-7.39/arch/cris/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/cris/Kconfig	2004-05-18 19:53:33.000000000 -0700
@@ -212,37 +212,6 @@ config PROFILE_SHIFT
 	depends on PROFILE
 	default "2"
 
-config HOOK
-	tristate "Kernel Hook support"
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/ia64/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/ia64/Kconfig
--- linux-2.6.5-7.39/arch/ia64/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ia64/Kconfig	2004-05-18 19:53:33.000000000 -0700
@@ -631,39 +631,6 @@ config SYSVIPC_COMPAT
 	bool
 	depends on COMPAT && SYSVIPC
 	default y
-
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/ia64/kernel/process.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ia64/kernel/process.c
--- linux-2.6.5-7.39/arch/ia64/kernel/process.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ia64/kernel/process.c	2004-05-18 19:53:33.000000000 -0700
@@ -22,7 +22,6 @@
 #include <linux/thread_info.h>
 #include <linux/unistd.h>
 #include <linux/efi.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/delay.h>
 #include <asm/elf.h>
@@ -586,7 +585,6 @@ kernel_thread (int (*fn)(void *), void *
 {
 	extern void start_kernel_thread (void);
 	unsigned long *helper_fptr = (unsigned long *) &start_kernel_thread;
-	pid_t ret;
 	struct {
 		struct switch_stack sw;
 		struct pt_regs pt;
@@ -603,13 +601,7 @@ kernel_thread (int (*fn)(void *), void *
 	regs.sw.ar_fpsr = regs.pt.ar_fpsr = ia64_getreg(_IA64_REG_AR_FPSR);
 	regs.sw.ar_bspstore = (unsigned long) current + IA64_RBS_OFFSET;
 
-	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs.pt, 0, NULL, NULL);
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (ret > 0)
-		TRIG_EVENT(kthread_hook, ret, (unsigned long) fn);
-#endif
-
-	return  ret;
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs.pt, 0, NULL, NULL);
 }
 EXPORT_SYMBOL(kernel_thread);
 
diff -urNp linux-2.6.5-7.39/arch/ia64/kernel/time.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ia64/kernel/time.c
--- linux-2.6.5-7.39/arch/ia64/kernel/time.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ia64/kernel/time.c	2004-05-18 19:53:33.000000000 -0700
@@ -20,7 +20,6 @@
 #include <linux/efi.h>
 #include <linux/profile.h>
 #include <linux/timex.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/machvec.h>
 #include <asm/delay.h>
@@ -262,7 +261,6 @@ timer_interrupt (int irq, void *dev_id, 
 		 * fixing that would require updates to all
 		 * platforms.
 		 */
-		TRIG_EVENT(timer_hook, regs);
 		update_process_times(user_mode(regs));
 #endif
 		new_itm += local_cpu_data->itm_delta;
diff -urNp linux-2.6.5-7.39/arch/m68k/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/m68k/Kconfig
--- linux-2.6.5-7.39/arch/m68k/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/m68k/Kconfig	2004-05-18 19:53:33.000000000 -0700
@@ -688,38 +688,6 @@ config DEBUG_INFO
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 	  
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/mips/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/Kconfig
--- linux-2.6.5-7.39/arch/mips/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/Kconfig	2004-05-18 19:53:33.000000000 -0700
@@ -1531,45 +1531,6 @@ config DEBUG_HIGHMEM
 	bool "Highmem debugging"
 	depends on DEBUG_KERNEL && HIGHMEM
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/mips/baget/irq.c linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/baget/irq.c
--- linux-2.6.5-7.39/arch/mips/baget/irq.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/baget/irq.c	2004-05-18 19:53:33.000000000 -0700
@@ -18,7 +18,6 @@
 #include <linux/slab.h>
 #include <linux/random.h>
 #include <linux/delay.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/bitops.h>
 #include <asm/bootinfo.h>
@@ -183,7 +182,6 @@ static void do_IRQ(int irq, struct pt_re
 	struct irqaction *action;
 	int do_random, cpu;
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !user_mode(regs));
 	cpu = smp_processor_id();
 	irq_enter();
 	kstat_cpus(cpu).irqs[irq]++;
@@ -209,7 +207,6 @@ static void do_IRQ(int irq, struct pt_re
 	unmask_irq(irq);
 	irq_exit();
 
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 	/* unmasking and bottom half handling is done magically for us. */
 }
 
diff -urNp linux-2.6.5-7.39/arch/mips/kernel/i8259.c linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/i8259.c
--- linux-2.6.5-7.39/arch/mips/kernel/i8259.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/i8259.c	2004-05-18 19:53:33.000000000 -0700
@@ -15,7 +15,6 @@
 #include <linux/kernel.h>
 #include <linux/spinlock.h>
 #include <linux/sysdev.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/i8259.h>
 #include <asm/io.h>
diff -urNp linux-2.6.5-7.39/arch/mips/kernel/irq.c linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/irq.c
--- linux-2.6.5-7.39/arch/mips/kernel/irq.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/irq.c	2004-05-18 19:53:33.000000000 -0700
@@ -22,7 +22,6 @@
 #include <linux/sched.h>
 #include <linux/seq_file.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/system.h>
@@ -353,7 +352,6 @@ asmlinkage unsigned int do_IRQ(int irq, 
 	struct irqaction * action;
 	unsigned int status;
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !user_mode(regs));
 	irq_enter();
 	kstat_this_cpu.irqs[irq]++;
 	spin_lock(&desc->lock);
@@ -419,7 +417,6 @@ out:
 	spin_unlock(&desc->lock);
 
 	irq_exit();
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 
 	return 1;
 }
diff -urNp linux-2.6.5-7.39/arch/mips/kernel/process.c linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/process.c
--- linux-2.6.5-7.39/arch/mips/kernel/process.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/process.c	2004-05-18 19:53:34.000000000 -0700
@@ -23,7 +23,6 @@
 #include <linux/a.out.h>
 #include <linux/init.h>
 #include <linux/completion.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
@@ -188,10 +187,6 @@ long kernel_thread(int (*fn)(void *), vo
 		: "$2", "$3", "$4", "$5", "$6", "$7", "$8",
 		  "$9","$10","$11","$12","$13","$14","$15","$24","$25","$31");
 
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (retval > 0)
-		TRIG_EVENT(kthread_hook, retval, (int) fn);
-#endif
 	return retval;
 }
 
diff -urNp linux-2.6.5-7.39/arch/mips/kernel/time.c linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/time.c
--- linux-2.6.5-7.39/arch/mips/kernel/time.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/time.c	2004-05-18 19:53:34.000000000 -0700
@@ -24,7 +24,6 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
@@ -552,7 +551,6 @@ irqreturn_t timer_interrupt(int irq, voi
 
 asmlinkage void ll_timer_interrupt(int irq, struct pt_regs *regs)
 {
-	TRIG_EVENT(irq_entry_hook, irq, regs, CAUSE_EPC(regs));
 	irq_enter();
 	kstat_this_cpu.irqs[irq]++;
 
@@ -560,7 +558,6 @@ asmlinkage void ll_timer_interrupt(int i
 	timer_interrupt(irq, NULL, regs);
 
 	irq_exit();
-	TRIG_EVENT(irq_exit_hook, irq, regs);	
 }
 
 asmlinkage void ll_local_timer_interrupt(int irq, struct pt_regs *regs)
diff -urNp linux-2.6.5-7.39/arch/mips/kernel/traps.c linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/traps.c
--- linux-2.6.5-7.39/arch/mips/kernel/traps.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/traps.c	2004-05-18 19:53:34.000000000 -0700
@@ -20,7 +20,6 @@
 #include <linux/smp_lock.h>
 #include <linux/spinlock.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/bootinfo.h>
 #include <asm/branch.h>
@@ -37,7 +36,6 @@
 #include <asm/mmu_context.h>
 #include <asm/watch.h>
 #include <asm/types.h>
-#include <asm/unistd.h>
 
 extern asmlinkage void handle_mod(void);
 extern asmlinkage void handle_tlbl(void);
@@ -342,7 +340,6 @@ asmlinkage void do_be(struct pt_regs *re
 	int data = regs->cp0_cause & 4;
 	int action = MIPS_BE_FATAL;
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	/* XXX For now.  Fixme, this searches the wrong table ...  */
 	if (data && !user_mode(regs))
 		fixup = search_dbe_tables(exception_epc(regs));
@@ -355,12 +352,10 @@ asmlinkage void do_be(struct pt_regs *re
 
 	switch (action) {
 	case MIPS_BE_DISCARD:
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	case MIPS_BE_FIXUP:
 		if (fixup) {
 			regs->cp0_epc = fixup->nextinsn;
-			TRIG_EVENT(trap_exit_hook);
 			return;
 		}
 		break;
@@ -376,7 +371,6 @@ asmlinkage void do_be(struct pt_regs *re
 	       field, regs->cp0_epc, field, regs->regs[31]);
 	die_if_kernel("Oops", regs);
 	force_sig(SIGBUS, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 static inline int get_insn_opcode(struct pt_regs *regs, unsigned int *opcode)
@@ -527,13 +521,11 @@ asmlinkage void do_ov(struct pt_regs *re
 {
 	siginfo_t info;
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	info.si_code = FPE_INTOVF;
 	info.si_signo = SIGFPE;
 	info.si_errno = 0;
 	info.si_addr = (void *)regs->cp0_epc;
 	force_sig_info(SIGFPE, &info, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
@@ -541,7 +533,6 @@ asmlinkage void do_ov(struct pt_regs *re
  */
 asmlinkage void do_fpe(struct pt_regs *regs, unsigned long fcr31)
 {
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	if (fcr31 & FPU_CSR_UNI_X) {
 		int sig;
 
@@ -574,12 +565,10 @@ asmlinkage void do_fpe(struct pt_regs *r
 		if (sig)
 			force_sig(sig, current);
 
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 	force_sig(SIGFPE, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_bp(struct pt_regs *regs)
@@ -589,12 +578,9 @@ asmlinkage void do_bp(struct pt_regs *re
 
 	die_if_kernel("Break instruction in kernel code", regs);
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
-
-	if (get_insn_opcode(regs, &opcode)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (get_insn_opcode(regs, &opcode))
 		return;
-	}
+
 	/*
 	 * There is the ancient bug in the MIPS assemblers that the break
 	 * code starts left to bit 16 instead to bit 6 in the opcode.
@@ -623,7 +609,6 @@ asmlinkage void do_bp(struct pt_regs *re
 	default:
 		force_sig(SIGTRAP, current);
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_tr(struct pt_regs *regs)
@@ -633,12 +618,8 @@ asmlinkage void do_tr(struct pt_regs *re
 
 	die_if_kernel("Trap instruction in kernel code", regs);
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
-
-	if (get_insn_opcode(regs, &opcode)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (get_insn_opcode(regs, &opcode))
 		return;
-	}
 
 	/* Immediate versions don't provide a code.  */
 	if (!(opcode & OPCODE))
@@ -665,22 +646,17 @@ asmlinkage void do_tr(struct pt_regs *re
 	default:
 		force_sig(SIGTRAP, current);
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_ri(struct pt_regs *regs)
 {
 	die_if_kernel("Reserved instruction in kernel code", regs);
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	if (!cpu_has_llsc)
-		if (!simulate_llsc(regs)) {
-			TRIG_EVENT(trap_exit_hook);
+		if (!simulate_llsc(regs))
 			return;
-		}
 
 	force_sig(SIGILL, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_cpu(struct pt_regs *regs)
@@ -689,7 +665,6 @@ asmlinkage void do_cpu(struct pt_regs *r
 
 	die_if_kernel("do_cpu invoked from kernel context!", regs);
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	cpid = (regs->cp0_cause >> CAUSEB_CE) & 3;
 
 	switch (cpid) {
@@ -697,10 +672,8 @@ asmlinkage void do_cpu(struct pt_regs *r
 		if (cpu_has_llsc)
 			break;
 
-		if (!simulate_llsc(regs)) {
-			TRIG_EVENT(trap_exit_hook);
+		if (!simulate_llsc(regs))
 			return;
-		}
 		break;
 
 	case 1:
@@ -719,7 +692,6 @@ asmlinkage void do_cpu(struct pt_regs *r
 				force_sig(sig, current);
 		}
 
-		TRIG_EVENT(trap_exit_hook);
 		return;
 
 	case 2:
@@ -728,7 +700,6 @@ asmlinkage void do_cpu(struct pt_regs *r
 	}
 
 	force_sig(SIGILL, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_mdmx(struct pt_regs *regs)
@@ -738,23 +709,19 @@ asmlinkage void do_mdmx(struct pt_regs *
 
 asmlinkage void do_watch(struct pt_regs *regs)
 {
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	/*
 	 * We use the watch exception where available to detect stack
 	 * overflows.
 	 */
 	dump_tlb_all();
 	show_regs(regs);
-	TRIG_EVENT(trap_exit_hook);
 	panic("Caught WATCH exception - probably caused by stack overflow.");
 }
 
 asmlinkage void do_mcheck(struct pt_regs *regs)
 {
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	show_regs(regs);
 	dump_tlb_all();
-	TRIG_EVENT(trap_exit_hook);
 	/*
 	 * Some chips may have other causes of machine check (e.g. SB1
 	 * graduation timer)
@@ -792,7 +759,6 @@ static inline void parity_protection_ini
 	default:
 		break;
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void cache_parity_error(void)
diff -urNp linux-2.6.5-7.39/arch/mips/kernel/unaligned.c linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/unaligned.c
--- linux-2.6.5-7.39/arch/mips/kernel/unaligned.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/kernel/unaligned.c	2004-05-18 19:53:34.000000000 -0700
@@ -78,7 +78,6 @@
 #include <linux/signal.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/asm.h>
 #include <asm/branch.h>
@@ -498,17 +497,14 @@ asmlinkage void do_ade(struct pt_regs *r
 	mm_segment_t seg;
 	unsigned long pc;
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	/*
 	 * Address errors may be deliberately induced by the FPU emulator to
 	 * retake control of the CPU after executing the instruction in the
 	 * delay slot of an emulated branch.
 	 */
 	/* Terminate if exception was recognized as a delay slot return */
-	if (do_dsemulret(regs)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (do_dsemulret(regs))
 		return;
-	}
 
 	/* Otherwise handle as normal */
 
@@ -542,7 +538,6 @@ asmlinkage void do_ade(struct pt_regs *r
 	}
 	set_fs(seg);
 
-	TRIG_EVENT(trap_exit_hook);
 	return;
 
 sigbus:
@@ -552,5 +547,4 @@ sigbus:
 	/*
 	 * XXX On return from the signal handler we should advance the epc
 	 */
-	TRIG_EVENT(trap_exit_hook);
 }
diff -urNp linux-2.6.5-7.39/arch/mips/mm/fault.c linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/mm/fault.c
--- linux-2.6.5-7.39/arch/mips/mm/fault.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/mips/mm/fault.c	2004-05-18 19:53:34.000000000 -0700
@@ -19,7 +19,6 @@
 #include <linux/smp_lock.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/branch.h>
 #include <asm/hardirq.h>
@@ -28,7 +27,6 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/ptrace.h>
-#include <asm/mipsregs.h>
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -64,7 +62,6 @@ asmlinkage void do_page_fault(struct pt_
 	if (unlikely(address >= VMALLOC_START))
 		goto vmalloc_fault;
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	/*
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
@@ -119,7 +116,6 @@ survive:
 	}
 
 	up_read(&mm->mmap_sem);
-	TRIG_EVENT(trap_exit_hook);
 	return;
 
 /*
@@ -148,7 +144,6 @@ bad_area_nosemaphore:
 		/* info.si_code has been set above */
 		info.si_addr = (void *) address;
 		force_sig_info(SIGSEGV, &info, tsk);
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
@@ -156,7 +151,6 @@ no_context:
 	/* Are we prepared to handle this kernel fault?  */
 	if (fixup_exception(regs)) {
 		current->thread.cp0_baduaddr = address;
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
@@ -207,7 +201,6 @@ do_sigbus:
 	info.si_addr = (void *) address;
 	force_sig_info(SIGBUS, &info, tsk);
 
-	TRIG_EVENT(trap_exit_hook);
 	return;
 
 vmalloc_fault:
@@ -242,5 +235,4 @@ vmalloc_fault:
 			goto no_context;
 		return;
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
diff -urNp linux-2.6.5-7.39/arch/parisc/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/parisc/Kconfig
--- linux-2.6.5-7.39/arch/parisc/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/parisc/Kconfig	2004-05-18 19:53:34.000000000 -0700
@@ -222,38 +222,6 @@ config DEBUG_INFO
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 	  
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/ppc/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/Kconfig
--- linux-2.6.5-7.39/arch/ppc/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/Kconfig	2004-05-18 19:53:34.000000000 -0700
@@ -1225,50 +1225,6 @@ config OCP
 	depends on IBM_OCP
 	default y
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config ASM_HOOK
-	bool
-	default y
-	depends on DEBUG_KERNEL && HOOK
-	
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/ppc/kernel/entry.S linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/entry.S
--- linux-2.6.5-7.39/arch/ppc/kernel/entry.S	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/entry.S	2004-05-18 19:53:34.000000000 -0700
@@ -35,32 +35,6 @@
 #undef SHOW_SYSCALLS
 #undef SHOW_SYSCALLS_TASK
 
-/* syscall hooks for LTT */
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-#define ASM_PRE_SYSCALL	\
-	addi	r3,r1,STACK_FRAME_OVERHEAD;  	/* Put pointer to registers into r3 */	\
-	mflr	r29;				/* Save LR */ \
-	bl	pre_syscall;			/* Call real trace function */ \
-	mtlr	r29;				/* Restore LR */ \
-	lwz	r0,GPR0(r1);			/* Restore original registers */ \
-	lwz	r3,GPR3(r1);	\
-	lwz	r4,GPR4(r1);	\
-	lwz	r5,GPR5(r1);	\
-	lwz	r6,GPR6(r1);	\
-	lwz	r7,GPR7(r1);	\
-	lwz	r8,GPR8(r1);
-#define ASM_POST_SYSCALL \
-	bl	post_syscall;			/* Call real trace function */ \
-	lwz	r0,GPR0(r1);			/* Restore original registers */ \
-	lwz	r3,RESULT(r1); \
-	lwz	r4,GPR4(r1); \
-	lwz	r5,GPR5(r1); \
-	lwz	r6,GPR6(r1); \
-	lwz	r7,GPR7(r1); \
-	lwz	r8,GPR8(r1); \
-	addi	r9,r1,STACK_FRAME_OVERHEAD;
-#endif
-
 /*
  * MSR_KERNEL is > 0x10000 on 4xx since it include MSR_CE.
  */
@@ -211,16 +185,10 @@ syscall_dotrace_cont:
 	bge-	66f
 	lwzx	r10,r10,r0	/* Fetch system call handler [ptr] */
 	mtlr	r10
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	ASM_PRE_SYSCALL ;
-#endif
 	addi	r9,r1,STACK_FRAME_OVERHEAD
 	blrl			/* Call handler */
 	.globl	ret_from_syscall
 ret_from_syscall:
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	ASM_POST_SYSCALL ;
-#endif
 #ifdef SHOW_SYSCALLS
 	bl	do_show_syscall_exit
 #endif
diff -urNp linux-2.6.5-7.39/arch/ppc/kernel/irq.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/irq.c
--- linux-2.6.5-7.39/arch/ppc/kernel/irq.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/irq.c	2004-05-18 19:53:34.000000000 -0700
@@ -46,7 +46,6 @@
 #include <linux/random.h>
 #include <linux/seq_file.h>
 #include <linux/cpumask.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
@@ -432,7 +431,6 @@ void ppc_irq_dispatch_handler(struct pt_
 	struct irqaction *action;
 	irq_desc_t *desc = irq_desc + irq;
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	kstat_this_cpu.irqs[irq]++;
 	spin_lock(&desc->lock);
 	ack_irq(irq);
@@ -510,7 +508,6 @@ out:
 			irq_desc[irq].handler->enable(irq);
 	}
 	spin_unlock(&desc->lock);
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 }
 
 void do_IRQ(struct pt_regs *regs)
diff -urNp linux-2.6.5-7.39/arch/ppc/kernel/misc.S linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/misc.S
--- linux-2.6.5-7.39/arch/ppc/kernel/misc.S	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/misc.S	2004-05-18 19:53:34.000000000 -0700
@@ -1066,11 +1066,7 @@ _GLOBAL(cvt_df)
  * Create a kernel thread
  *   kernel_thread(fn, arg, flags)
  */
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK 
-_GLOBAL(original_kernel_thread)
-#else
 _GLOBAL(kernel_thread)
-#endif /* CONFIG_TRIGEVENT_SYSCALL_HOOK */
 	stwu	r1,-16(r1)
 	stw	r30,8(r1)
 	stw	r31,12(r1)
diff -urNp linux-2.6.5-7.39/arch/ppc/kernel/process.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/process.c
--- linux-2.6.5-7.39/arch/ppc/kernel/process.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/process.c	2004-05-18 19:53:34.000000000 -0700
@@ -35,7 +35,6 @@
 #include <linux/init_task.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -307,19 +306,6 @@ void show_regs(struct pt_regs * regs)
 	show_stack(current, (unsigned long *) regs->gpr[1]);
 }
 
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK 
-long original_kernel_thread(int (*fn) (void *), void* arg, unsigned long flags);
-long kernel_thread(int (*fn) (void *), void* arg, unsigned long flags)
-{
-	long   retval;
-
-	retval = original_kernel_thread(fn, arg, flags);
-	if (retval > 0)
-		TRIG_EVENT(kthread_hook, retval, (int) fn);
-	return retval;
-}
-#endif /* CONFIG_TRIGEVENT_SYSCALL_HOOK */
- 
 void exit_thread(void)
 {
 	if (last_task_used_math == current)
diff -urNp linux-2.6.5-7.39/arch/ppc/kernel/syscalls.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/syscalls.c
--- linux-2.6.5-7.39/arch/ppc/kernel/syscalls.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/syscalls.c	2004-05-18 19:53:34.000000000 -0700
@@ -37,7 +37,6 @@
 #include <linux/file.h>
 #include <linux/unistd.h>
 #include <linux/fshooks.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -61,7 +60,6 @@ sys_ipc (uint call, int first, int secon
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
-	TRIG_EVENT(ipc_call_hook, call, first);
 	ret = -ENOSYS;
 	switch (call) {
 	case SEMOP:
diff -urNp linux-2.6.5-7.39/arch/ppc/kernel/time.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/time.c
--- linux-2.6.5-7.39/arch/ppc/kernel/time.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/time.c	2004-05-18 19:53:34.000000000 -0700
@@ -56,7 +56,6 @@
 #include <linux/mc146818rtc.h>
 #include <linux/time.h>
 #include <linux/init.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
@@ -153,7 +152,6 @@ void timer_interrupt(struct pt_regs * re
 	if (atomic_read(&ppc_n_lost_interrupts) != 0)
 		do_IRQ(regs);
 
-	TRIG_EVENT(trap_entry_hook, regs->trap, instruction_pointer(regs));
 	irq_enter();
 
 	while ((next_dec = tb_ticks_per_jiffy - tb_delta(&jiffy_stamp)) < 0) {
@@ -201,7 +199,6 @@ void timer_interrupt(struct pt_regs * re
 	last_jiffy_stamp(cpu) = jiffy_stamp;
 
 #ifdef CONFIG_SMP
-	TRIG_EVENT(timer_hook, regs);
 	smp_local_timer_interrupt(regs);
 #endif /* CONFIG_SMP */
 
@@ -209,7 +206,6 @@ void timer_interrupt(struct pt_regs * re
 		ppc_md.heartbeat();
 
 	irq_exit();
-	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
diff -urNp linux-2.6.5-7.39/arch/ppc/kernel/traps.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/traps.c
--- linux-2.6.5-7.39/arch/ppc/kernel/traps.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/kernel/traps.c	2004-05-18 19:53:34.000000000 -0700
@@ -30,7 +30,6 @@
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -119,9 +118,7 @@ _exception(int signr, struct pt_regs *re
 	info.si_errno = 0;
 	info.si_code = code;
 	info.si_addr = (void *) addr;
-	TRIG_EVENT(trap_entry_hook, regs->trap, instruction_pointer(regs));
 	force_sig_info(signr, &info, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
diff -urNp linux-2.6.5-7.39/arch/ppc/mm/fault.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/mm/fault.c
--- linux-2.6.5-7.39/arch/ppc/mm/fault.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc/mm/fault.c	2004-05-18 19:53:34.000000000 -0700
@@ -28,7 +28,6 @@
 #include <linux/interrupt.h>
 #include <linux/highmem.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -122,26 +121,21 @@ void do_page_fault(struct pt_regs *regs,
 		is_write = error_code & 0x02000000;
 #endif /* CONFIG_4xx */
 
-	TRIG_EVENT(trap_entry_hook, regs->trap, instruction_pointer(regs));
 #if defined(CONFIG_XMON) || defined(CONFIG_KGDB)
 	if (debugger_fault_handler && TRAP(regs) == 0x300) {
 		debugger_fault_handler(regs);
-		TRIG_EVENT(trap_exit_hook);
 		return 0;
 	}
 #if !defined(CONFIG_4xx)
 	if (error_code & 0x00400000) {
 		/* DABR match */
-		if (debugger_dabr_match(regs)) {
-			TRIG_EVENT(trap_exit_hook);
+		if (debugger_dabr_match(regs))
 			return 0;
-		}
 	}
 #endif /* !CONFIG_4xx */
 #endif /* CONFIG_XMON || CONFIG_KGDB */
 
 	if (in_atomic() || mm == NULL) {
-		TRIG_EVENT(trap_exit_hook);
 		return SIGSEGV;
 	}
 	down_read(&mm->mmap_sem);
@@ -283,7 +277,6 @@ good_area:
 	 * -- Cort
 	 */
 	pte_misses++;
-	TRIG_EVENT(trap_exit_hook);
 	return 0;
 
 bad_area:
@@ -297,11 +290,9 @@ bad_area:
 		info.si_code = code;
 		info.si_addr = (void *) address;
 		force_sig_info(SIGSEGV, &info, current);
-		TRIG_EVENT(trap_exit_hook);
 		return 0;
 	}
 
-	TRIG_EVENT(trap_exit_hook);
 	return SIGSEGV;
 
 /*
@@ -320,6 +311,5 @@ out_of_memory:
 	if (user_mode(regs))
 		do_exit(SIGKILL);
-	TRIG_EVENT(trap_exit_hook);
 	return SIGKILL;
 
 do_sigbus:
@@ -332,11 +322,9 @@ do_sigbus:
 	force_sig_info (SIGBUS, &info, current);
 	if (!user_mode(regs)) {
-		TRIG_EVENT(trap_exit_hook);
 		return SIGBUS;
 	}
 
-	TRIG_EVENT(trap_exit_hook);
 	return 0;
 }
 
 /*
diff -urNp linux-2.6.5-7.39/arch/ppc64/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc64/Kconfig
--- linux-2.6.5-7.39/arch/ppc64/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc64/Kconfig	2004-05-18 19:55:34.000000000 -0700
@@ -538,44 +538,6 @@ config SPINLINE
 
 	  If in doubt, say N.
 
-
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config ASM_HOOK
-	bool
-	default y
-	depends on DEBUG_KERNEL && HOOK
-	
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-	
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/ppc64/kernel/irq.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc64/kernel/irq.c
--- linux-2.6.5-7.39/arch/ppc64/kernel/irq.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc64/kernel/irq.c	2004-05-18 19:53:34.000000000 -0700
@@ -41,7 +41,6 @@
 #include <linux/proc_fs.h>
 #include <linux/random.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
@@ -486,7 +485,6 @@ void ppc_irq_dispatch_handler(struct pt_
 	struct thread_info *curtp, *irqtp;
 #endif
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	kstat_cpu(cpu).irqs[irq]++;
 
 	if (desc->status & IRQ_PER_CPU) {
@@ -588,7 +586,6 @@ out:
 			desc->handler->enable(irq);
 	}
 	spin_unlock(&desc->lock);
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 }
 
 #ifdef CONFIG_PPC_ISERIES
diff -urNp linux-2.6.5-7.39/arch/ppc64/kernel/time.c linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc64/kernel/time.c
--- linux-2.6.5-7.39/arch/ppc64/kernel/time.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/ppc64/kernel/time.c	2004-05-18 19:53:34.000000000 -0700
@@ -49,7 +49,6 @@
 #include <linux/init.h>
 #include <linux/profile.h>
 #include <linux/audit.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
@@ -282,7 +281,6 @@ int timer_interrupt(struct pt_regs * reg
 	while (lpaca->next_jiffy_update_tb <= (cur_tb = get_tb())) {
 
 #ifdef CONFIG_SMP
-		TRIG_EVENT(timer_hook, regs);
 		smp_local_timer_interrupt(regs);
 #endif
 		if (cpu == boot_cpuid) {
diff -urNp linux-2.6.5-7.39/arch/s390/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/Kconfig
--- linux-2.6.5-7.39/arch/s390/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/Kconfig	2004-05-18 19:53:34.000000000 -0700
@@ -432,50 +432,6 @@ config DEBUG_SPINLOCK_SLEEP
 	  If you say Y here, various routines which may sleep will become very
 	  noisy if they are called with a spinlock held.	
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config ASM_HOOK
-	bool
-	default y
-	depends on DEBUG_KERNEL && HOOK
-	
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/s390/kernel/process.c linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/kernel/process.c
--- linux-2.6.5-7.39/arch/s390/kernel/process.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/kernel/process.c	2004-05-18 19:53:34.000000000 -0700
@@ -33,7 +33,6 @@
 #include <linux/delay.h>
 #include <linux/reboot.h>
 #include <linux/init.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -180,7 +179,6 @@ __asm__(".align 4\n"
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
 	struct pt_regs regs;
-	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 	regs.psw.mask = PSW_KERNEL_BITS;
@@ -193,14 +191,8 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.orig_gpr2 = -1;
 
 	/* Ok, create the new process.. */
-	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED,
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED,
 		       0, &regs, 0, NULL, NULL);
-	
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (ret > 0)
-		TRIG_EVENT(kthread_hook, ret, (int) fn);
-#endif
-	return ret;
 }
 
 /*
diff -urNp linux-2.6.5-7.39/arch/s390/kernel/sys_s390.c linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/kernel/sys_s390.c
--- linux-2.6.5-7.39/arch/s390/kernel/sys_s390.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/kernel/sys_s390.c	2004-05-18 19:53:34.000000000 -0700
@@ -30,7 +30,6 @@
 #include <linux/personality.h>
 #endif /* CONFIG_ARCH_S390X */
 #include <linux/fshooks.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -166,7 +165,6 @@ asmlinkage long sys_ipc (uint call, int 
         struct ipc_kludge tmp;
 	int ret;
 
-        TRIG_EVENT(ipc_call_hook, call, first);
         switch (call) {
         case SEMOP:
 		return sys_semtimedop (first, (struct sembuf *) ptr, second,
diff -urNp linux-2.6.5-7.39/arch/s390/kernel/time.c linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/kernel/time.c
--- linux-2.6.5-7.39/arch/s390/kernel/time.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/kernel/time.c	2004-05-18 19:53:34.000000000 -0700
@@ -26,7 +26,6 @@
 #include <linux/types.h>
 #include <linux/timex.h>
 #include <linux/config.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/delay.h>
@@ -301,7 +300,6 @@ void account_ticks(struct pt_regs *regs)
 	 * Spread it over all cpus instead.
 	 */
 	write_seqlock(&xtime_lock);
-	TRIG_EVENT(timer_hook, regs);
 	if (S390_lowcore.jiffy_timer > xtime_cc) {
 		__u32 xticks;
 
diff -urNp linux-2.6.5-7.39/arch/s390/kernel/traps.c linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/kernel/traps.c
--- linux-2.6.5-7.39/arch/s390/kernel/traps.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/kernel/traps.c	2004-05-18 19:53:34.000000000 -0700
@@ -5,7 +5,6 @@
  *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
  *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com),
- *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/kernel/traps.c"
  *    Copyright (C) 1991, 1992 Linus Torvalds
@@ -30,7 +29,6 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -272,17 +270,12 @@ void die(const char * str, struct pt_reg
 static void inline do_trap(long interruption_code, int signr, char *str,
                            struct pt_regs *regs, siginfo_t *info)
 {
-	trapid_t ltt_interruption_code;
-	char * ic_ptr = (char *) &ltt_interruption_code;
 	/*
 	 * We got all needed information from the lowcore and can
 	 * now safely switch on interrupts.
 	 */
         if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+4,&interruption_code,sizeof(interruption_code));
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code, (regs->psw.addr & PSW_ADDR_INSN));
 
         if (regs->psw.mask & PSW_MASK_PSTATE) {
                 struct task_struct *tsk = current;
@@ -313,7 +306,6 @@ static void inline do_trap(long interrup
                 else
                         die(str, regs, interruption_code);
         }
-	TRIG_EVENT(trap_exit_hook);
 }
 
 static inline void *get_check_address(struct pt_regs *regs)
@@ -323,11 +315,6 @@ static inline void *get_check_address(st
 
 int do_debugger_trap(struct pt_regs *regs)
 {
-	trapid_t ltt_interruption_code;
-	char * ic_ptr = (char *) &ltt_interruption_code;
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+6,&S390_lowcore.pgm_code,2); /* copy the interrupt code */
-
 	if ((regs->psw.mask & PSW_MASK_PSTATE) &&
 	    (current->ptrace & PT_PTRACED)) {
 		force_sig(SIGTRAP,current);
@@ -403,8 +390,6 @@ asmlinkage void illegal_op(struct pt_reg
 {
         __u8 opcode[6];
 	__u16 *location;
-        trapid_t ltt_interruption_code;
-        char * ic_ptr = (char *) &ltt_interruption_code;
 	int signal = 0;
 
 	location = (__u16 *) get_check_address(regs);
@@ -416,9 +401,6 @@ asmlinkage void illegal_op(struct pt_reg
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+4,&interruption_code,sizeof(interruption_code));
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code, (regs->psw.addr & PSW_ADDR_INSN));
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		get_user(*((__u16 *) opcode), location);
 	else
@@ -459,7 +441,6 @@ asmlinkage void illegal_op(struct pt_reg
         else if (signal)
 		do_trap(interruption_code, signal,
 			"illegal operation", regs, NULL);
-        TRIG_EVENT(trap_exit_hook);
 }
 
 
@@ -469,8 +450,6 @@ specification_exception(struct pt_regs *
 {
         __u8 opcode[6];
 	__u16 *location = NULL;
-        trapid_t ltt_interruption_code;
-        char * ic_ptr = (char *) &ltt_interruption_code;
 	int signal = 0;
 
 	location = (__u16 *) get_check_address(regs);
@@ -482,9 +461,6 @@ specification_exception(struct pt_regs *
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 		
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+4,&interruption_code,sizeof(interruption_code));
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code, (regs->psw.addr & PSW_ADDR_INSN));
         if (regs->psw.mask & PSW_MASK_PSTATE) {
 		get_user(*((__u16 *) opcode), location);
 		switch (opcode[0]) {
@@ -528,7 +504,6 @@ specification_exception(struct pt_regs *
 		do_trap(interruption_code, signal, 
 			"specification exception", regs, &info);
 	}
-        TRIG_EVENT(trap_exit_hook);
 }
 #else
 DO_ERROR_INFO(SIGILL, "specification exception", specification_exception,
@@ -538,8 +513,6 @@ DO_ERROR_INFO(SIGILL, "specification exc
 asmlinkage void data_exception(struct pt_regs * regs, long interruption_code)
 {
 	__u16 *location;
-        trapid_t ltt_interruption_code;
-        char * ic_ptr = (char *) &ltt_interruption_code;
 	int signal = 0;
 
 	location = (__u16 *) get_check_address(regs);
@@ -551,9 +524,6 @@ asmlinkage void data_exception(struct pt
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+4,&interruption_code,sizeof(interruption_code));
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code, (regs->psw.addr & PSW_ADDR_INSN));
 	if (MACHINE_HAS_IEEE)
 		__asm__ volatile ("stfpc %0\n\t" 
 				  : "=m" (current->thread.fp_regs.fpc));
@@ -629,7 +599,6 @@ asmlinkage void data_exception(struct pt
 		do_trap(interruption_code, signal, 
 			"data exception", regs, &info);
 	}
-        TRIG_EVENT(trap_exit_hook);
 }
 
 
diff -urNp linux-2.6.5-7.39/arch/s390/mm/fault.c linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/mm/fault.c
--- linux-2.6.5-7.39/arch/s390/mm/fault.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/s390/mm/fault.c	2004-05-18 19:53:34.000000000 -0700
@@ -5,7 +5,6 @@
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Hartmut Penner (hp@de.ibm.com)
  *               Ulrich Weigand (uweigand@de.ibm.com)
- *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/mm/fault.c"
  *    Copyright (C) 1995  Linus Torvalds
@@ -26,7 +25,6 @@
 #include <linux/init.h>
 #include <linux/console.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -170,8 +168,6 @@ extern inline void do_exception(struct p
 	int user_address;
 	const struct exception_table_entry *fixup;
 	int si_code = SEGV_MAPERR;
-        trapid_t ltt_interruption_code;                 
-        char * ic_ptr = (char *) &ltt_interruption_code; 
 
         tsk = current;
         mm = tsk->mm;
@@ -219,9 +215,6 @@ extern inline void do_exception(struct p
 	 */
 	local_irq_enable();
 
-        memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-        memcpy(ic_ptr+4,&error_code,sizeof(error_code));
-        TRIG_EVENT(trap_entry_hook, ltt_interruption_code,(regs->psw.addr & PSW_ADDR_INSN));
         down_read(&mm->mmap_sem);
 
         vma = find_vma(mm, address);
@@ -270,7 +263,6 @@ survive:
 	}
 
         up_read(&mm->mmap_sem);
-        TRIG_EVENT(trap_exit_hook);
         return;
 
 /*
@@ -285,7 +277,6 @@ bad_area:
                 tsk->thread.prot_addr = address;
                 tsk->thread.trap_no = error_code;
 		force_sigsegv(regs, error_code, si_code, address);
-                TRIG_EVENT(trap_exit_hook);
                 return;
 	}
 
@@ -294,7 +285,6 @@ no_context:
 	fixup = search_exception_tables(regs->psw.addr & __FIXUP_MASK);
 	if (fixup) {
 		regs->psw.addr = fixup->fixup | PSW_ADDR_AMODE;
-		TRIG_EVENT(trap_exit_hook);
                 return;
         }
 
@@ -342,7 +332,6 @@ do_sigbus:
 	/* Kernel mode? Handle exceptions or die */
 	if (!(regs->psw.mask & PSW_MASK_PSTATE))
 		goto no_context;
-	TRIG_EVENT(trap_exit_hook);
 }
 
 void do_protection_exception(struct pt_regs *regs, unsigned long error_code)
diff -urNp linux-2.6.5-7.39/arch/sh/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/Kconfig
--- linux-2.6.5-7.39/arch/sh/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/Kconfig	2004-05-18 19:53:34.000000000 -0700
@@ -790,44 +790,6 @@ config FRAME_POINTER
 	  If you don't debug the kernel, you can say N, but we may not be able
 	  to solve problems without frame pointers.
 
-config HOOK
-	tristate "Kernel Hook support"
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-	
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/sh/kernel/entry.S linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/entry.S
--- linux-2.6.5-7.39/arch/sh/kernel/entry.S	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/entry.S	2004-05-18 19:53:34.000000000 -0700
@@ -555,19 +555,6 @@ syscall_badsys:			! Bad syscall number
 	 nop
 	!
 good_system_call:		! Good syscall number
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	! TODO: for i386 this code only happens when not ptrace'd
-	mov 	r15, r4     	    	! pass pt_regs* as first arg
-	mov.l	__pre_syscall, r11 	! Call pre_syscall()
-	jsr	@r11	    	    	! (will chomp R[0-7])
-	 nop
-	!   	    	    	    	Reload R4-R7 from kernel stack
-	mov.l	@(OFF_R4,r15), r4   ! arg0
-	mov.l	@(OFF_R5,r15), r5
-	mov.l	@(OFF_R6,r15), r6
-	mov.l	@(OFF_R7,r15), r7   ! arg3
-	mov.l	@(OFF_R3,r15), r3   ! syscall_nr
-#endif
 	mov.l	@(TI_FLAGS,r8), r8
 	mov	#_TIF_SYSCALL_TRACE, r10
 	tst	r10, r8
@@ -583,12 +570,6 @@ syscall_call:
 	mov.l	r0, @(OFF_R0,r15)		! save the return value
 	!
 syscall_exit:
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	! TODO: for i386 this code only happens when not ptrace'd
-	mov.l	__post_syscall, r1 	    	! Call post_syscall()
-	jsr	@r1
-	 nop
-#endif
 	CLI()
 	!
 	GET_THREAD_INFO(r8)
@@ -695,12 +676,6 @@ skip_restore:
 5:	.long	0x00001000	! DSP
 7:	.long	0x30000000
 9:
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-__pre_syscall:
-	.long   SYMBOL_NAME(pre_syscall)
-__post_syscall:
-	.long   SYMBOL_NAME(post_syscall)
-#endif
 __INV_IMASK:
 	.long	0xffffff0f	! ~(IMASK)
 
diff -urNp linux-2.6.5-7.39/arch/sh/kernel/irq.c linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/irq.c
--- linux-2.6.5-7.39/arch/sh/kernel/irq.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/irq.c	2004-05-18 19:53:34.000000000 -0700
@@ -31,7 +31,6 @@
 #include <linux/init.h>
 #include <linux/seq_file.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
@@ -140,11 +139,6 @@ int handle_IRQ_event(unsigned int irq, s
 	int status = 1;	/* Force the "do bottom halves" bit */
 	int retval = 0;
 
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (irq != TIMER_IRQ) { /* avoid double-reporting the timer IRQ */
-		TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
-	}
-#endif
 	if (!(action->flags & SA_INTERRUPT))
 		local_irq_enable();
 
@@ -158,11 +152,6 @@ int handle_IRQ_event(unsigned int irq, s
 		add_interrupt_randomness(irq);
 
 	local_irq_disable();
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (irq != TIMER_IRQ) { /* avoid double-reporting the timer IRQ */
-		TRIG_EVENT(irq_exit_hook, irq, regs);
-	}
-#endif
 	return retval;
 }
 
diff -urNp linux-2.6.5-7.39/arch/sh/kernel/process.c linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/process.c
--- linux-2.6.5-7.39/arch/sh/kernel/process.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/process.c	2004-05-18 19:53:34.000000000 -0700
@@ -20,7 +20,6 @@
 #include <linux/ptrace.h>
 #include <linux/platform.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -148,7 +147,6 @@ __asm__(".align 5\n"
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {	/* Don't use this in BL=1(cli).  Or else, CPU resets! */
 	struct pt_regs regs;
-	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 	regs.regs[4] = (unsigned long) arg;
@@ -158,12 +156,7 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.sr = (1 << 30);
 
 	/* Ok, create the new process.. */
-	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (ret > 0)
-		TRIG_EVENT(kthread_hook, ret, (int) fn);
-#endif
-	return  ret;
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
 
 /*
diff -urNp linux-2.6.5-7.39/arch/sh/kernel/sys_sh.c linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/sys_sh.c
--- linux-2.6.5-7.39/arch/sh/kernel/sys_sh.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/sys_sh.c	2004-05-18 19:53:34.000000000 -0700
@@ -21,7 +21,6 @@
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -167,7 +166,6 @@ asmlinkage int sys_ipc(uint call, int fi
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
-	TRIG_EVENT(ipc_call_hook, call, first);
 	if (call <= SEMCTL)
 		switch (call) {
 		case SEMOP:
diff -urNp linux-2.6.5-7.39/arch/sh/kernel/traps.c linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/traps.c
--- linux-2.6.5-7.39/arch/sh/kernel/traps.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/kernel/traps.c	2004-05-18 19:53:34.000000000 -0700
@@ -27,7 +27,6 @@
 #include <linux/spinlock.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -68,9 +67,7 @@ asmlinkage void do_##name(unsigned long 
 	tsk->thread.error_code = error_code;				\
 	tsk->thread.trap_no = trapnr;					\
         CHK_REMOTE_DEBUG(&regs);					\
-	TRIG_EVENT(trap_entry_hook, trapnr, regs.pc);			\
 	force_sig(signr, tsk);						\
-	TRIG_EVENT(trap_exit_hook);					\
 	die_if_no_fixup(str,&regs,error_code);				\
 }
 
@@ -503,7 +500,6 @@ asmlinkage void do_address_error(struct 
 
 	asm volatile("stc       r2_bank,%0": "=r" (error_code));
 
-	TRIG_EVENT(trap_entry_hook, error_code >> 5, regs->pc);
 	oldfs = get_fs();
 
 	if (user_mode(regs)) {
@@ -527,10 +523,8 @@ asmlinkage void do_address_error(struct 
 		tmp = handle_unaligned_access(instruction, regs);
 		set_fs(oldfs);
 
-		if (tmp==0) {
-			TRIG_EVENT(trap_exit_hook);
+		if (tmp==0)
 			return; /* sorted */
-		}
 
 	uspace_segv:
 		printk(KERN_NOTICE "Killing process \"%s\" due to unaligned access\n", current->comm);
@@ -551,7 +545,6 @@ asmlinkage void do_address_error(struct 
 		handle_unaligned_access(instruction, regs);
 		set_fs(oldfs);
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
 
 #ifdef CONFIG_SH_DSP
diff -urNp linux-2.6.5-7.39/arch/sh/mm/fault.c linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/mm/fault.c
--- linux-2.6.5-7.39/arch/sh/mm/fault.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/sh/mm/fault.c	2004-05-18 19:53:34.000000000 -0700
@@ -21,7 +21,6 @@
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
@@ -55,13 +54,6 @@ asmlinkage void do_page_fault(struct pt_
 	tsk = current;
 	mm = tsk->mm;
 
-#if (CONFIG_TRIGEVENT_HOOKS)
-	{
-		unsigned long trapnr;
-		asm volatile("stc       r2_bank,%0": "=r" (trapnr));
-		TRIG_EVENT(trap_entry_hook, trapnr >> 5, regs->pc);  /* trap 4,5 or 6 */
-	}
-#endif
 	/*
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
@@ -115,7 +107,6 @@ survive:
 	}
 
 	up_read(&mm->mmap_sem);
-	TRIG_EVENT(trap_exit_hook);
 	return;
 
 /*
@@ -129,16 +120,13 @@ bad_area:
 		tsk->thread.address = address;
 		tsk->thread.error_code = writeaccess;
 		force_sig(SIGSEGV, tsk);
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 no_context:
 	/* Are we prepared to handle this kernel fault?  */
-	if (fixup_exception(regs)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (fixup_exception(regs))
 		return;
-	}
 
 /*
  * Oops. The kernel tried to access some bad page. We'll have to
@@ -198,7 +186,6 @@ do_sigbus:
 	/* Kernel mode? Handle exceptions or die */
 	if (!user_mode(regs))
 		goto no_context;
-	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
diff -urNp linux-2.6.5-7.39/arch/sparc/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/sparc/Kconfig
--- linux-2.6.5-7.39/arch/sparc/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/sparc/Kconfig	2004-05-18 19:53:34.000000000 -0700
@@ -448,37 +448,6 @@ config DEBUG_BUGVERBOSE
 	  of the BUG call as well as the EIP and oops trace.  This aids
 	  debugging but costs about 70-100K of memory.
 
-config HOOK
-	tristate "Kernel Hook support"
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/sparc64/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/sparc64/Kconfig
--- linux-2.6.5-7.39/arch/sparc64/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/sparc64/Kconfig	2004-05-18 19:53:34.000000000 -0700
@@ -700,38 +700,6 @@ config MCOUNT
 	depends on STACK_DEBUG
 	default y
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/x86_64/Kconfig linux-2.6.5-7.39-ltt-hooks-modified/arch/x86_64/Kconfig
--- linux-2.6.5-7.39/arch/x86_64/Kconfig	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/x86_64/Kconfig	2004-05-18 19:53:34.000000000 -0700
@@ -569,38 +569,6 @@ config IOMMU_LEAK
 #config X86_REMOTE_DEBUG
 #       bool "kgdb debugging stub"
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
diff -urNp linux-2.6.5-7.39/arch/x86_64/kernel/apic.c linux-2.6.5-7.39-ltt-hooks-modified/arch/x86_64/kernel/apic.c
--- linux-2.6.5-7.39/arch/x86_64/kernel/apic.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/x86_64/kernel/apic.c	2004-05-18 19:53:34.000000000 -0700
@@ -26,7 +26,6 @@
 #include <linux/mc146818rtc.h>
 #include <linux/kernel_stat.h>
 #include <linux/sysdev.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/smp.h>
@@ -858,7 +857,6 @@ void smp_local_timer_interrupt(struct pt
 		}
 
 #ifdef CONFIG_SMP
-		TRIG_EVENT(timer_hook, regs);
 		update_process_times(user_mode(regs));
 #endif
 	}
diff -urNp linux-2.6.5-7.39/arch/x86_64/kernel/irq.c linux-2.6.5-7.39-ltt-hooks-modified/arch/x86_64/kernel/irq.c
--- linux-2.6.5-7.39/arch/x86_64/kernel/irq.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/arch/x86_64/kernel/irq.c	2004-05-18 19:53:34.000000000 -0700
@@ -33,7 +33,6 @@
 #include <linux/irq.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/io.h>
@@ -215,7 +214,6 @@ int handle_IRQ_event(unsigned int irq, s
 {
 	int status = 1; /* Force the "do bottom halves" bit */
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	if (!(action->flags & SA_INTERRUPT))
 		local_irq_enable();
 
@@ -228,7 +226,6 @@ int handle_IRQ_event(unsigned int irq, s
 		add_interrupt_randomness(irq);
 	local_irq_disable();
 
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 	return status;
 }
 
diff -urNp linux-2.6.5-7.39/drivers/s390/s390mach.c linux-2.6.5-7.39-ltt-hooks-modified/drivers/s390/s390mach.c
--- linux-2.6.5-7.39/drivers/s390/s390mach.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/drivers/s390/s390mach.c	2004-05-18 19:53:34.000000000 -0700
@@ -6,15 +6,13 @@
  *    Copyright (C) 2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Ingo Adlung (adlung@de.ibm.com)
  *		 Martin Schwidefsky (schwidefsky@de.ibm.com)
- *	Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  */
 
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/errno.h>
 #include <linux/workqueue.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/lowcore.h>
 
@@ -144,18 +142,8 @@ void
 s390_do_machine_check(void)
 {
 	struct mci *mci;
-	trapid_t ltt_interruption_code;
-	uint32_t ltt_old_psw;
 
 	mci = (struct mci *) &S390_lowcore.mcck_interruption_code;
-	memcpy( &ltt_interruption_code,
-		&S390_lowcore.mcck_interruption_code,
-		sizeof(__u64));
-	memcpy( &ltt_old_psw,
-		&S390_lowcore.mcck_old_psw,
-		sizeof(uint32_t));
-	ltt_old_psw &=  PSW_ADDR_INSN;
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code,ltt_old_psw);
 
 	if (mci->sd)		/* system damage */
 		s390_handle_damage("received system damage machine check\n");
diff -urNp linux-2.6.5-7.39/include/asm-mips/mipsregs.h linux-2.6.5-7.39-ltt-hooks-modified/include/asm-mips/mipsregs.h
--- linux-2.6.5-7.39/include/asm-mips/mipsregs.h	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/include/asm-mips/mipsregs.h	2004-05-18 19:53:34.000000000 -0700
@@ -525,9 +525,6 @@
 
 #ifndef __ASSEMBLY__
 
-#define CAUSE_EXCCODE(x) ((CAUSEF_EXCCODE & (x->cp0_cause)) >> CAUSEB_EXCCODE)
-#define CAUSE_EPC(x) (x->cp0_epc + (((x->cp0_cause & CAUSEF_BD) >> CAUSEB_BD) << 2))
-
 /*
  * Functions to access the r10k performance counter and control registers
  */
diff -urNp linux-2.6.5-7.39/include/asm-ppc/hook.h linux-2.6.5-7.39-ltt-hooks-modified/include/asm-ppc/hook.h
--- linux-2.6.5-7.39/include/asm-ppc/hook.h	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/include/asm-ppc/hook.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,47 +0,0 @@
-#ifndef __ASM_PPC_HOOK_H
-#define __ASM_PPC_HOOK_H
-/*
- * Kernel Hooks optimized for PPC.
- * 
- * Authors: Mike Grundy <grundym@us.ibm.com> s390x
- */
-#include <asm-generic/hook.h>
-
-#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
-
-#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
-#define _IF_HOOK_ENABLED(h, hk) \
-	register int tmp; \
-	__asm__ __volatile__ (".global "hk"; "hk":li %0, 0x00":"=r"(tmp)); \
-	if (unlikely(tmp))
-
-#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
-
-
-/*
- * Sanity check the hook location for valid instructions at hook location.
- * At hook location, we should find these instructions:
- *	38 00 00 00       	li    	r0,0
- *	2c 00 00 00            	cmpwi	r0,0
- *	
- * We can check for li and cmpwi instructions. As these instructions encode
- * the register name in the second byte and the register cannot be predicted, 
- * we mask out the bits corresponding to registers in the opcode before comparing.
- * PPC opcodes are six bits, hence mask of 0xFC
- */
-#define OPCODE_MOV1			0x38 /* LI (really an extended mnemonic for addi */   
-#define OPCODE_MOV1_MASK		0xFC
-/* Compiler generates 2c 00 00 00     cmpwi   r0,0 */
-		
-static inline int is_asm_hook(unsigned char * addr)
-{
-	if (!addr)
-		return 0;
-	
-	if((addr[0] & OPCODE_MOV1_MASK) == OPCODE_MOV1) {
-		if (*((unsigned short *)(addr+1)) == 0)
-			return 1;
-	}
-	return 0;
-}
-#endif /* __ASM_PPC_HOOK_H */
diff -urNp linux-2.6.5-7.39/include/asm-ppc64/hook.h linux-2.6.5-7.39-ltt-hooks-modified/include/asm-ppc64/hook.h
--- linux-2.6.5-7.39/include/asm-ppc64/hook.h	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/include/asm-ppc64/hook.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,47 +0,0 @@
-#ifndef __ASM_PPC_HOOK_H
-#define __ASM_PPC_HOOK_H
-/*
- * Kernel Hooks optimized for PPC64.
- * 
- * Authors: Mike Grundy <grundym@us.ibm.com> PPC64
- */
-#include <asm-generic/hook.h>
-
-#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
-
-#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
-#define _IF_HOOK_ENABLED(h, hk) \
-	register int tmp; \
-	__asm__ __volatile__ (".global "hk"; "hk":li %0, 0x00":"=r"(tmp)); \
-	if (unlikely(tmp))
-
-#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
-
-
-/*
- * Sanity check the hook location for valid instructions at hook location.
- * At hook location, we should find these instructions:
- *	38 00 00 00       	li    	r0,0
- *	2c 00 00 00            	cmpwi	r0,0
- *	
- * We can check for li and cmpwi instructions. As these instructions encode
- * the register name in the second byte and the register cannot be predicted, 
- * we mask out the bits corresponding to registers in the opcode before comparing.
- * PPC opcodes are six bits, hence mask of 0xFC
- */
-#define OPCODE_MOV1			0x38 /* LI (really an extended mnemonic for addi */   
-#define OPCODE_MOV1_MASK		0xFC
-/* Compiler generates 2c 00 00 00     cmpwi   r0,0 */
-		
-static inline int is_asm_hook(unsigned char * addr)
-{
-	if (!addr)
-		return 0;
-	
-	if((addr[0] & OPCODE_MOV1_MASK) == OPCODE_MOV1) {
-		if (*((unsigned short *)(addr+1)) == 0)
-			return 1;
-	}
-	return 0;
-}
-#endif /* __ASM_PPC_HOOK_H */
diff -urNp linux-2.6.5-7.39/include/asm-s390/hook.h linux-2.6.5-7.39-ltt-hooks-modified/include/asm-s390/hook.h
--- linux-2.6.5-7.39/include/asm-s390/hook.h	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/include/asm-s390/hook.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,49 +0,0 @@
-#ifndef __ASM_S390_HOOK_H
-#define __ASM_S390_HOOK_H
-/*
- * Kernel Hooks optimized for s390.
- * 
- * Authors: Mike Grundy <grundym@us.ibm.com> s390
- */
-#include <asm-generic/hook.h>
-
-#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
-
-#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
-#define _IF_HOOK_ENABLED(h, hk) \
-	register int tmp; \
-	__asm__ __volatile__ (".global "hk"; "hk":lhi %0, 0x00":"=r"(tmp)); \
-	if (unlikely(tmp))
-
-#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
-
-/*
- * Sanity check the hook location for valid instructions at hook location.
- * At hook location, we should find these instructions:
- *  a7 18 00 00             lhi     %r1,0
- *  12 11                   ltr     %r1,%r1
- * We can check for the lhi and ltr instructions. As the lhi instruction encodes
- * the register name in it, and we can't guarantee which register will be used,
- * we'll mask out the bits corresponding to the target register.
- */
-#define OPCODE_MOV2_1			0xa7 /* LHI first byte */
-#define OPCODE_MOV2_2			0x08 /* LHI second byte */
-#define OPCODE_MOV2_1_MASK		0xff
-#define OPCODE_MOV2_2_MASK		0x0f
-/* Compiler generates LTR opcode 12, but second op not tested */
-		
-static inline int is_asm_hook(unsigned char * addr)
-{
-	if (!addr){
-		return 0;
-	}
-	if (((addr[0] & OPCODE_MOV2_1_MASK) == OPCODE_MOV2_1) && 
-		    ((addr[1] & OPCODE_MOV2_2_MASK) == OPCODE_MOV2_2)) {
-		/* was checking a 32bit val, need to check 16, cheated with 8+8 */
-		if (addr[2]== 0 && addr[3]== 0){
-			return 1;
-		}
-	}
-	return 0;
-}
-#endif /* __ASM_S390_HOOK_H */
diff -urNp linux-2.6.5-7.39/include/asm-s390x/hook.h linux-2.6.5-7.39-ltt-hooks-modified/include/asm-s390x/hook.h
--- linux-2.6.5-7.39/include/asm-s390x/hook.h	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/include/asm-s390x/hook.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,49 +0,0 @@
-#ifndef __ASM_S390X_HOOK_H
-#define __ASM_S390X_HOOK_H
-/*
- * Kernel Hooks optimized for s390x(64bit).
- * 
- * Authors: Mike Grundy <grundym@us.ibm.com> s390x
- */
-#include <asm-generic/hook.h>
-
-#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
-
-#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
-#define _IF_HOOK_ENABLED(h, hk) \
-	register int tmp; \
-	__asm__ __volatile__ (".global "hk"; "hk":lhi %0, 0x00":"=r"(tmp)); \
-	if (unlikely(tmp))
-
-#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
-
-/*
- * Sanity check the hook location for valid instructions at hook location.
- * At hook location, we should find these instructions:
- *  a7 18 00 00             lhi     %r1,0
- *  12 11                   ltr     %r1,%r1
- * We can check for the lhi and ltr instructions. As the lhi instruction encodes
- * the register name in it, and we can't guarantee which register will be used,
- * we'll mask out the bits corresponding to the target register.
- */
-#define OPCODE_MOV2_1			0xa7 /* LHI first byte */
-#define OPCODE_MOV2_2			0x08 /* LHI second byte */
-#define OPCODE_MOV2_1_MASK		0xff
-#define OPCODE_MOV2_2_MASK		0x0f
-/* Compiler generates LTR opcode 12, but second op not tested */
-		
-static inline int is_asm_hook(unsigned char * addr)
-{
-	if (!addr){
-		return 0;
-	}
-	if (((addr[0] & OPCODE_MOV2_1_MASK) == OPCODE_MOV2_1) && 
-		    ((addr[1] & OPCODE_MOV2_2_MASK) == OPCODE_MOV2_2)) {
-		/* was checking a 32bit val, need to check 16, cheated with 8+8 */
-		if (addr[2]== 0 && addr[3]== 0){
-			return 1;
-		}
-	}
-	return 0;
-}
-#endif /* __ASM_S390X_HOOK_H */
diff -urNp linux-2.6.5-7.39/include/linux/ltt.h linux-2.6.5-7.39-ltt-hooks-modified/include/linux/ltt.h
--- linux-2.6.5-7.39/include/linux/ltt.h	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/include/linux/ltt.h	2004-05-18 19:53:35.000000000 -0700
@@ -273,20 +273,11 @@ typedef struct _trace_syscall_entry {
 } LTT_PACKED_STRUCT trace_syscall_entry;
 
 /*  TRACE_TRAP_ENTRY */
-#ifndef __s390__
 typedef struct _trace_trap_entry {
 	u16 trap_id;		/* Trap number */
 	u32 address;		/* Address where trap occured */
 } LTT_PACKED_STRUCT trace_trap_entry;
 static inline void TRACE_TRAP_ENTRY(u16 trap_id, u32 address)
-#else
-typedef u64 trapid_t;
-typedef struct _trace_trap_entry {
-	trapid_t trap_id;	/* Trap number */
-	u32 address;		/* Address where trap occured */
-} LTT_PACKED_STRUCT trace_trap_entry;
-static inline void TRACE_TRAP_ENTRY(trapid_t trap_id, u32 address)
-#endif
 {
 	trace_trap_entry trap_event;
 
diff -urNp linux-2.6.5-7.39/include/linux/trigevent_hooks.h linux-2.6.5-7.39-ltt-hooks-modified/include/linux/trigevent_hooks.h
--- linux-2.6.5-7.39/include/linux/trigevent_hooks.h	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/include/linux/trigevent_hooks.h	2004-05-18 19:53:35.000000000 -0700
@@ -97,9 +97,4 @@ extern void disable_post_syscall(void);
 #define TRIG_EVENT(name, ...)
 #endif /* CONFIG_TRIGEVENT_HOOKS */
 
-/* this needs to be done properly */
-#ifdef __s390__
-typedef uint64_t trapid_t;
-#endif
-
 #endif /* __LINUX_TRIGEVENT_HOOKS_H */
diff -urNp linux-2.6.5-7.39/kernel/ltt/Makefile linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/Makefile
--- linux-2.6.5-7.39/kernel/ltt/Makefile	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/Makefile	2004-05-18 19:53:35.000000000 -0700
@@ -8,24 +8,9 @@ ltt_driver-objs	:= ltt-core.o ltt-core_h
 
 
 # Optional parts of multipart objects.
-ifeq ($(CONFIG_ARM),y)
-ltt_driver-objs	+= arm_syscall.o
-endif
 ifeq ($(CONFIG_X86),y)
 ltt_driver-objs	+= i386_syscall.o
 endif
-ifeq ($(CONFIG_MIPS32),y)
-ltt_driver-objs	+= mips_syscall.o
-endif
-ifeq ($(CONFIG_PPC32),y)
-ltt_driver-objs	+= ppc_syscall.o
-endif
-ifeq ($(CONFIG_ARCH_S390),y)
-ltt_driver-objs	+= s390_syscall.o
-endif
-ifeq ($(CONFIG_SUPERH),y)
-ltt_driver-objs	+= sh_syscall.o
-endif
 
 obj-$(CONFIG_LTT)	+= ltt_driver.o
 
diff -urNp linux-2.6.5-7.39/kernel/ltt/arm_syscall.c linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/arm_syscall.c
--- linux-2.6.5-7.39/kernel/ltt/arm_syscall.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/arm_syscall.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,74 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* arm */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{
-	int			scno = 0;
-	int			depth = 0;
-	unsigned long           end_code;
-	unsigned long		*fp;			/* frame pointer */
-	unsigned long		lower_bound;
-	unsigned long		lr;			/* link register */
-	unsigned long		*prev_fp;
-	int			seek_depth;
-	unsigned long           start_code;
-	unsigned long           *start_stack;
-	trace_syscall_entry	trace_syscall_event;
-	unsigned long		upper_bound;
-	int			use_bounds;
-	int			use_depth;
-
-	/* TODO: get_scno */
-	trace_syscall_event.syscall_id = (uint8_t)scno;
-	trace_syscall_event.address    = instruction_pointer(regs);
-	
-	if (! (user_mode(regs) ))
-		goto trace_syscall_end;
-
-	if (ltt_get_trace_config(&use_depth,
-			     &use_bounds,
-			     &seek_depth,
-			     (void*)&lower_bound,
-			     (void*)&upper_bound) < 0)
-		goto trace_syscall_end;
-
-	if ((use_depth == 1) || (use_bounds == 1)) {
-		fp          = (unsigned long *)regs->ARM_fp;
-		end_code    = current->mm->end_code;
-		start_code  = current->mm->start_code;
-		start_stack = (unsigned long *)current->mm->start_stack;
-
-		while (!__get_user(lr, (unsigned long *)(fp - 1))) {
-			if ((lr > start_code) && (lr < end_code)) {
-				if (((use_depth == 1) && (depth >= seek_depth)) ||
-				    ((use_bounds == 1) && (lr > lower_bound) && (lr < upper_bound))) {
-					trace_syscall_event.address = lr;
-					goto trace_syscall_end;
-				} else {
-					depth++;
-				}
-			}
-
-			if ((__get_user((unsigned long)prev_fp, (fp - 3))) ||
-			    (prev_fp > start_stack) ||
-			    (prev_fp <= fp)) {
-				goto trace_syscall_end;
-			}
-			fp = prev_fp;
-		}
-	}
-
-trace_syscall_end:
-	ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}
diff -urNp linux-2.6.5-7.39/kernel/ltt/mips_syscall.c linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/mips_syscall.c
--- linux-2.6.5-7.39/kernel/ltt/mips_syscall.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/mips_syscall.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,77 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* mips */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{
-	unsigned long       addr;
-	int                 depth = 0;
-	unsigned long       end_code;
-	unsigned long       lower_bound;
-	int                 seek_depth;
-	unsigned long       *stack;
-	unsigned long       start_code;
-	unsigned long       *start_stack;
-	trace_syscall_entry trace_syscall_event;
-	unsigned long       upper_bound;
-	int                 use_bounds;
-	int                 use_depth;
-
-	/* syscall_id will be negative for SVR4, IRIX5, BSD43, and POSIX
-	 * syscalls -- these are not supported at this point by LTT
-	 */
-	trace_syscall_event.syscall_id = (uint8_t) (regs->regs[2] - __NR_Linux);
-
-	trace_syscall_event.address  = regs->cp0_epc;
-
-	if (!user_mode(regs))
-		goto trace_syscall_end;
-
-	if (ltt_get_trace_config(&use_depth,
-			     &use_bounds,
-			     &seek_depth,
-			     (void*)&lower_bound,
-			     (void*)&upper_bound) < 0)
-		goto trace_syscall_end;
-
-	/* Heuristic that might work:
-	 * (BUT DOESN'T WORK for any of the cases I tested...) zzz
-	 * Search through stack until a value is found that is within the
-	 * range start_code .. end_code.  (This is looking for a return
-	 * pointer to where a shared library was called from.)  If a stack
-	 * variable contains a valid code address then an incorrect
-	 * result will be generated.
-	 */
-	if ((use_depth == 1) || (use_bounds == 1)) {
-		stack       = (unsigned long*) regs->regs[29];
-		end_code    = current->mm->end_code;
-		start_code  = current->mm->start_code;
-		start_stack = (unsigned long *)current->mm->start_stack;
-
-		while ((stack <= start_stack) && (!__get_user(addr, stack))) {
-			if ((addr > start_code) && (addr < end_code)) {
-				if (((use_depth  == 1) && (depth == seek_depth)) ||
-				    ((use_bounds == 1) && (addr > lower_bound) && (addr < upper_bound))) {
-					trace_syscall_event.address = addr;
-					goto trace_syscall_end;
-				} else {
-					depth++;
-				}
-			}
-		stack++;
-		}
-	}
-
-trace_syscall_end:
-	ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}
diff -urNp linux-2.6.5-7.39/kernel/ltt/ppc_syscall.c linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/ppc_syscall.c
--- linux-2.6.5-7.39/kernel/ltt/ppc_syscall.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/ppc_syscall.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,88 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* ppc */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{
-        int                 use_depth;
-	int                 use_bounds;
-	int                 depth = 0;
-        int                 seek_depth;
-        unsigned long       lower_bound;
-        unsigned long       upper_bound;
-	unsigned long       addr;
-	unsigned long*      stack;
-	trace_syscall_entry trace_syscall_event;
-
-        /* Set the syscall ID */
-	trace_syscall_event.syscall_id = (uint8_t) regs->gpr[0];
-
-	/* Set the address in any case */
-	trace_syscall_event.address  = instruction_pointer(regs);
-
-	/* Are we in the kernel (This is a kernel thread)? */
-	if(!user_mode(regs))
-	  /* Don't go digining anywhere */
-	  goto trace_syscall_end;
-
-	/* Get the trace configuration */
-	if(ltt_get_trace_config(&use_depth,
-			    &use_bounds,
-			    &seek_depth,
-			    (void*)&lower_bound,
-			    (void*)&upper_bound) < 0)
-	  goto trace_syscall_end;
-
-	/* Do we have to search for an eip address range */
-	if((use_depth == 1) || (use_bounds == 1))
-	  {
-	  /* Start at the top of the stack (bottom address since stacks grow downward) */
-	  stack = (unsigned long*) regs->gpr[1];
-
-	  /* Skip over first stack frame as the return address isn't valid */
-	  if(get_user(addr, stack))
-	    goto trace_syscall_end;
-	  stack = (unsigned long*) addr;
-
-	  /* Keep on going until we reach the end of the process' stack limit (wherever it may be) */
-	  while(!get_user(addr, stack + 1)) /* "stack + 1", since this is where the IP is */
-	    {
-	    /* Does this LOOK LIKE an address in the program */
-	    if((addr > current->mm->start_code)
-             &&(addr < current->mm->end_code))
-	      {
-	      /* Does this address fit the description */
-	      if(((use_depth == 1) && (depth == seek_depth))
-               ||((use_bounds == 1) && (addr > lower_bound) && (addr < upper_bound)))
-		{
-		/* Set the address */
-		trace_syscall_event.address = addr;
-
-		/* We're done */
-		goto trace_syscall_end;
-		}
-	      else
-		/* We're one depth more */
-		depth++;
-	      }
-	    /* Go on to the next address */
-	    if(get_user(addr, stack))
-	      goto trace_syscall_end;
-	    stack = (unsigned long*) addr;
-	    }
-	  }
-
-trace_syscall_end:
-	/* Trace the event */
-	ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}
diff -urNp linux-2.6.5-7.39/kernel/ltt/s390_syscall.c linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/s390_syscall.c
--- linux-2.6.5-7.39/kernel/ltt/s390_syscall.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/s390_syscall.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,92 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* s390 */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{                                                              
-	int		    use_depth;	                 
-        int                 use_bounds;                        
-        int                 depth = 0;                         
-        int                 seek_depth;                        
-        unsigned long       lower_bound;                       
-        unsigned long       upper_bound;                       
-        unsigned long       addr;                              
-        unsigned long*      stack;
-        unsigned long       temp_stack;
-        trace_syscall_entry trace_syscall_event;               
-        /* Set the syscall ID                               */ 
-        /* Register 8 is setup just prior to the call       */ 
-        /* This instruction is just following linkage       */ 
-        /* so it's ok.  If moved and chance of R8 being     */ 
-        /* clobbered, would need to dig it out of the stack */ 
-        __asm__ volatile(                                      
-        "  stc  8,%0\n\t"                                      
-        : "=m" (trace_syscall_event.syscall_id));              
-        /* get the psw address */                              
-        trace_syscall_event.address  = regs->psw.addr;         
-        /* and off the hi-order bit */                                          
-        trace_syscall_event.address &= PSW_ADDR_INSN;                           
-        if(!(user_mode(regs))) /* if kernel mode, return */                     
-           goto trace_syscall_end;                                              
-        /* Get the trace configuration - if none, return */                     
-        if(ltt_get_trace_config(&use_depth,                                         
-                            &use_bounds,                                        
-                            &seek_depth,                                        
-                            (void*)&lower_bound,                                
-                            (void*)&upper_bound) < 0)                           
-          goto trace_syscall_end;                                               
-        /* Do we have to search for an instruction pointer address range */     
-        if((use_depth == 1) || (use_bounds == 1))                               
-        {                                                                       
-          /* Start at the top of the stack */                                   
-          /* stack pointer is register 15 */                                    
-          stack = (unsigned long*) regs->gprs[15]; /* stack pointer */      
-          /* Keep on going until we reach the end of the process' stack limit */
-          do
-          {
-            get_user(addr,stack+14);  /* get the program address +0x38 */ 
-            /* and off the hi-order bit */
-            addr &= PSW_ADDR_INSN;                                
-            /* Does this LOOK LIKE an address in the program */
-            if ((addr > current->mm->start_code)               
-               &&(addr < current->mm->end_code))               
-            { 
-              /* Does this address fit the description */      
-              if(((use_depth == 1) && (depth == seek_depth))   
-                ||((use_bounds == 1) && (addr > lower_bound)   
-                && (addr < upper_bound)))
-                {
-                  /* Set the address */   
-                  trace_syscall_event.address = addr; 
-                  /* We're done */                             
-                  goto trace_syscall_end;                      
-                }                                              
-              else                                             
-                /* We're one depth more */                     
-                depth++; 
-            }
-            /* Go on to the next address */
-            get_user(temp_stack,stack); /* get contents of stack */
-            temp_stack &= PSW_ADDR_INSN; /* and off hi order bit */
-            stack = (unsigned long *)temp_stack; /* move into stack */
-            /* stack may or may not go to zero when end hit               */
-            /* using 0x7fffffff-_STK_LIM to validate that the address is  */
-            /* within the range of a valid stack address                  */
-            /* If outside that range, exit the loop, stack end must have  */
-            /* been hit.                                                  */
-          } while (stack >= (unsigned long *)(0x7fffffff-_STK_LIM));
-        }                                                         
-trace_syscall_end:                                                
-        /* Trace the event */                                     
-        ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}                                                                 
diff -urNp linux-2.6.5-7.39/kernel/ltt/sh_syscall.c linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/sh_syscall.c
--- linux-2.6.5-7.39/kernel/ltt/sh_syscall.c	2004-05-14 16:10:57.000000000 -0700
+++ linux-2.6.5-7.39-ltt-hooks-modified/kernel/ltt/sh_syscall.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,79 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* sh */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{
-	int                 use_depth;
-	int                 use_bounds;
-	int                 depth = 0;
-	int                 seek_depth;
-	unsigned long       lower_bound;
-	unsigned long       upper_bound;
-	unsigned long       addr;
-	unsigned long*      stack;
-	trace_syscall_entry trace_syscall_event;
-
-	/* Set the syscall ID */
-	trace_syscall_event.syscall_id = (uint8_t) regs->regs[REG_REG0+3];
-
-	/* Set the address in any case */
-	trace_syscall_event.address  = regs->pc;
-
-	/* Are we in the kernel (This is a kernel thread)? */
-	if(!user_mode(regs))
-		/* Don't go digining anywhere */
-		goto trace_syscall_end;
-
-	/* Get the trace configuration */
-	if(ltt_get_trace_config(&use_depth, &use_bounds, &seek_depth,
-	   (void*)&lower_bound, (void*)&upper_bound) < 0)
-		goto trace_syscall_end;
-
-	/* Do we have to search for an eip address range */
-	if((use_depth == 1) || (use_bounds == 1))
-	{
-		/* Start at the top of the stack (bottom address since stacks grow downward) */
-		stack = (unsigned long*) regs->regs[REG_REG15];
-
-		/* Keep on going until we reach the end of the process' stack limit (wherever it may be) */
-		while(!get_user(addr, stack))
-		{
-			/* Does this LOOK LIKE an address in the program */
-			/* TODO: does this work with shared libraries?? - Greg Banks */
-			if((addr > current->mm->start_code) &&(addr < current->mm->end_code))
-			{
-				/* Does this address fit the description */
-				if(((use_depth == 1) && (depth == seek_depth))
-				   ||((use_bounds == 1) && (addr > lower_bound)
-				   && (addr < upper_bound)))
-				{
-					/* Set the address */
-					trace_syscall_event.address = addr;
-
-					/* We're done */
-					goto trace_syscall_end;
-				}
-				else
-					/* We're one depth more */
-					depth++;
-			}
-			/* Go on to the next address */
-			stack++;
-		}
-	}
-
-trace_syscall_end:
-	/* Trace the event */
-	ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}
