Index: linux-2.6.5/arch/alpha/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/alpha/Kconfig
+++ linux-2.6.5/arch/alpha/Kconfig
@@ -690,40 +690,8 @@ config DEBUG_INFO
 	  debugging info resulting in a larger kernel image.
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/arm/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/arm/Kconfig
+++ linux-2.6.5/arch/arm/Kconfig
@@ -735,47 +735,8 @@ config DEBUG_CLPS711X_UART2
 	  Say Y here if you want the debug print routines to direct their
 	  output to the second serial port on these devices.  Saying N will
 	  cause the debug messages to appear on the first serial port.
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/arm/kernel/entry-common.S
===================================================================
--- linux-2.6.5.orig/arch/arm/kernel/entry-common.S
+++ linux-2.6.5/arch/arm/kernel/entry-common.S
@@ -38,13 +38,8 @@ ENTRY(__do_softirq)
  * stack.
  */
 ret_fast_syscall:
 	disable_irq r1				@ disable interrupts
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	mov	r7, r0				@ save returned r0
-	bl	SYMBOL_NAME(post_syscall)
-	mov	r0, r7
-#endif
 	ldr	r1, [tsk, #TI_FLAGS]
 	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
 	fast_restore_user_regs
@@ -140,17 +135,8 @@ ENTRY(vector_swi)
 	mcr	p15, 0, ip, c1, c0		@ update control register
 #endif
 	enable_irq ip
 
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	/* zzz note that validity of scno is not yet checked.
-	 * zzz The visualizer checks it.
-	 */
-	add	r0, sp, #S_R0			@ pointer to regs
-	bl	SYMBOL_NAME(pre_syscall)
-	add	r0, sp, #S_R0			@ pointer to regs
-	ldmia	r1, {r0 - r3}			@ have to reload r0 - r3
-#endif
 	str	r4, [sp, #-S_OFF]!		@ push fifth arg
 
 	get_thread_info tsk
 	ldr	ip, [tsk, #TI_FLAGS]		@ check for syscall tracing
@@ -188,11 +174,8 @@ __sys_trace:
 	b	2b
 
 __sys_trace_return:
 	str	r0, [sp, #S_R0 + S_OFF]!	@ save returned r0
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	bl	SYMBOL_NAME(post_syscall)
-#endif
 	mov	r1, sp
 	mov	r0, #1				@ trace exit [IP = 1]
 	bl	syscall_trace
 	b	ret_slow_syscall
Index: linux-2.6.5/arch/arm/kernel/irq.c
===================================================================
--- linux-2.6.5.orig/arch/arm/kernel/irq.c
+++ linux-2.6.5/arch/arm/kernel/irq.c
@@ -31,9 +31,8 @@
 #include <linux/seq_file.h>
 #include <linux/errno.h>
 #include <linux/list.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/mach/irq.h>
@@ -447,9 +446,8 @@ static void do_pending_irqs(struct pt_re
 asmlinkage void asm_do_IRQ(int irq, struct pt_regs *regs)
 {
 	struct irqdesc *desc = irq_desc + irq;
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	/*
 	 * Some hardware gives randomly wrong interrupts.  Rather
 	 * than crashing, do something sensible.
 	 */
@@ -467,9 +465,8 @@ asmlinkage void asm_do_IRQ(int irq, stru
 		do_pending_irqs(regs);
 
 	spin_unlock(&irq_controller_lock);
 	irq_exit();
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 }
 
 void __set_irq_handler(unsigned int irq, irq_handler_t handle, int is_chained)
 {
Index: linux-2.6.5/arch/arm/kernel/process.c
===================================================================
--- linux-2.6.5.orig/arch/arm/kernel/process.c
+++ linux-2.6.5/arch/arm/kernel/process.c
@@ -398,9 +398,8 @@ asm(	".align\n"
  */
 pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 {
 	struct pt_regs regs;
-	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 
 	regs.ARM_r1 = (unsigned long)arg;
@@ -408,15 +407,9 @@ pid_t kernel_thread(int (*fn)(void *), v
 	regs.ARM_r3 = (unsigned long)do_exit;
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
 	regs.ARM_cpsr = SVC_MODE;
 
-	ret = do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (ret > 0)
-		TRIG_EVENT(kthread_hook, ret, (int) fn);
-#endif
-
-	return  ret;
+	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
 
 /*
  * These bracket the sleeping functions..
Index: linux-2.6.5/arch/arm/kernel/sys_arm.c
===================================================================
--- linux-2.6.5.orig/arch/arm/kernel/sys_arm.c
+++ linux-2.6.5/arch/arm/kernel/sys_arm.c
@@ -24,9 +24,8 @@
 #include <linux/mman.h>
 #include <linux/fs.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 
@@ -166,9 +165,8 @@ asmlinkage int sys_ipc (uint call, int f
 	int version, ret;
 
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
-	TRIG_EVENT(ipc_call_hook, call, first);
 
 	switch (call) {
 	case SEMOP:
 		return sys_semop (first, (struct sembuf *)ptr, second);
Index: linux-2.6.5/arch/arm/kernel/traps.c
===================================================================
--- linux-2.6.5.orig/arch/arm/kernel/traps.c
+++ linux-2.6.5/arch/arm/kernel/traps.c
@@ -25,9 +25,8 @@
 #include <linux/elf.h>
 #include <linux/interrupt.h>
 #include <linux/kallsyms.h>
 #include <linux/init.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/io.h>
 #include <asm/pgalloc.h>
@@ -313,12 +312,10 @@ asmlinkage void do_undefinstr(struct pt_
 	info.si_errno = 0;
 	info.si_code  = ILL_ILLOPC;
 	info.si_addr  = pc;
 
-	TRIG_EVENT(trap_entry_hook, current->thread.trap_no, (uint32_t)pc);
 	force_sig_info(SIGILL, &info, current);
 
-	TRIG_EVENT(trap_exit_hook);
 	die_if_kernel("Oops - undefined instruction", regs, 0);
 }
 
 asmlinkage void do_unexp_fiq (struct pt_regs *regs)
@@ -429,11 +426,9 @@ asmlinkage int arm_syscall(int no, struc
 		return 0;
 
 	case NR(breakpoint): /* SWI BREAK_POINT */
 		regs->ARM_pc -= thumb_mode(regs) ? 2 : 4;
-		TRIG_EVENT(trap_entry_hook, 1, (uint32_t)regs->ARM_pc);
 		ptrace_break(current, regs);
-		TRIG_EVENT(trap_exit_hook);
 		return regs->ARM_r0;
 
 	/*
 	 * Flush a region from virtual address 'r0' to virtual address 'r1'
@@ -530,11 +525,9 @@ baddataabort(int code, unsigned long ins
 	info.si_errno = 0;
 	info.si_code  = ILL_ILLOPC;
 	info.si_addr  = (void *)addr;
 
-	TRIG_EVENT(trap_entry_hook, 18, addr);	/* machine check */
 	force_sig_info(SIGILL, &info, current);
-	TRIG_EVENT(trap_exit_hook);
 	die_if_kernel("unknown data abort code", regs, instr);
 }
 
 volatile void __bug(const char *file, int line, void *data)
Index: linux-2.6.5/arch/arm/mm/fault-common.c
===================================================================
--- linux-2.6.5.orig/arch/arm/mm/fault-common.c
+++ linux-2.6.5/arch/arm/mm/fault-common.c
@@ -16,9 +16,8 @@
 #include <linux/ptrace.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
@@ -247,20 +246,17 @@ int do_page_fault(unsigned long addr, un
 	 */
 	if (in_interrupt() || !mm)
 		goto no_context;
 
-	TRIG_EVENT(trap_entry_hook, 14, instruction_pointer(regs));
 	down_read(&mm->mmap_sem);
 	fault = __do_page_fault(mm, addr, fsr, tsk);
 	up_read(&mm->mmap_sem);
 
 	/*
 	 * Handle the "normal" case first
 	 */
-	if (fault > 0) {
-		TRIG_EVENT(trap_exit_hook);
+	if (fault > 0)
 		return 0;
-	}
 
 	/*
 	 * We had some memory, but were unable to
 	 * successfully fix up this page fault.
@@ -284,9 +280,8 @@ int do_page_fault(unsigned long addr, un
 		do_exit(SIGKILL);
 	} else
 		__do_user_fault(tsk, addr, fsr, fault == -1 ?
 				SEGV_ACCERR : SEGV_MAPERR, regs);
-	TRIG_EVENT(trap_exit_hook);
 	return 0;
 
 
 /*
@@ -309,16 +304,13 @@ do_sigbus:
 	}
 #endif
 
 	/* Kernel mode? Handle exceptions or die */
-	if (user_mode(regs)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (user_mode(regs))
 		return 0;
-	}
 
 no_context:
 	__do_kernel_fault(mm, addr, fsr, regs);
-	TRIG_EVENT(trap_exit_hook);
 	return 0;
 }
 
 /*
Index: linux-2.6.5/arch/cris/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/cris/Kconfig
+++ linux-2.6.5/arch/cris/Kconfig
@@ -211,39 +211,8 @@ config PROFILE_SHIFT
 	int "Profile shift count"
 	depends on PROFILE
 	default "2"
 
-config HOOK
-	tristate "Kernel Hook support"
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/ia64/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/ia64/Kconfig
+++ linux-2.6.5/arch/ia64/Kconfig
@@ -613,41 +613,8 @@ config DEBUG_INFO
 config SYSVIPC_COMPAT
 	bool
 	depends on COMPAT && SYSVIPC
 	default y
-
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/ia64/kernel/process.c
===================================================================
--- linux-2.6.5.orig/arch/ia64/kernel/process.c
+++ linux-2.6.5/arch/ia64/kernel/process.c
@@ -21,9 +21,8 @@
 #include <linux/stddef.h>
 #include <linux/thread_info.h>
 #include <linux/unistd.h>
 #include <linux/efi.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/delay.h>
 #include <asm/elf.h>
 #include <asm/ia32.h>
@@ -589,9 +588,8 @@ pid_t
 kernel_thread (int (*fn)(void *), void *arg, unsigned long flags)
 {
 	extern void start_kernel_thread (void);
 	unsigned long *helper_fptr = (unsigned long *) &start_kernel_thread;
-	pid_t ret;
 	struct {
 		struct switch_stack sw;
 		struct pt_regs pt;
 	} regs;
@@ -606,15 +604,9 @@ kernel_thread (int (*fn)(void *), void *
 	regs.pt.cr_ifs = 1UL << 63;		/* mark as valid, empty frame */
 	regs.sw.ar_fpsr = regs.pt.ar_fpsr = ia64_getreg(_IA64_REG_AR_FPSR);
 	regs.sw.ar_bspstore = (unsigned long) current + IA64_RBS_OFFSET;
 
-	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs.pt, 0, NULL, NULL);
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (ret > 0)
-		TRIG_EVENT(kthread_hook, ret, (unsigned long) fn);
-#endif
-
-	return  ret;
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs.pt, 0, NULL, NULL);
 }
 EXPORT_SYMBOL(kernel_thread);
 
 /* This gets called from kernel_thread() via ia64_invoke_thread_helper().  */
Index: linux-2.6.5/arch/ia64/kernel/time.c
===================================================================
--- linux-2.6.5.orig/arch/ia64/kernel/time.c
+++ linux-2.6.5/arch/ia64/kernel/time.c
@@ -19,9 +19,8 @@
 #include <linux/interrupt.h>
 #include <linux/efi.h>
 #include <linux/profile.h>
 #include <linux/timex.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/machvec.h>
 #include <asm/delay.h>
 #include <asm/hw_irq.h>
@@ -261,9 +260,8 @@ timer_interrupt (int irq, void *dev_id, 
 		 * For UP, this is done in do_timer().  Weird, but
 		 * fixing that would require updates to all
 		 * platforms.
 		 */
-		TRIG_EVENT(timer_hook, regs);
 		update_process_times(user_mode(regs));
 #endif
 		new_itm += local_cpu_data->itm_delta;
 
Index: linux-2.6.5/arch/m68k/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/m68k/Kconfig
+++ linux-2.6.5/arch/m68k/Kconfig
@@ -687,40 +687,8 @@ config DEBUG_INFO
 	  debugging info resulting in a larger kernel image.
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 	  
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/mips/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/mips/Kconfig
+++ linux-2.6.5/arch/mips/Kconfig
@@ -1530,47 +1530,8 @@ config MIPS_UNCACHED
 config DEBUG_HIGHMEM
 	bool "Highmem debugging"
 	depends on DEBUG_KERNEL && HIGHMEM
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/mips/baget/irq.c
===================================================================
--- linux-2.6.5.orig/arch/mips/baget/irq.c
+++ linux-2.6.5/arch/mips/baget/irq.c
@@ -17,9 +17,8 @@
 #include <linux/timex.h>
 #include <linux/slab.h>
 #include <linux/random.h>
 #include <linux/delay.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/bitops.h>
 #include <asm/bootinfo.h>
 #include <asm/io.h>
@@ -182,9 +181,8 @@ static void do_IRQ(int irq, struct pt_re
 {
 	struct irqaction *action;
 	int do_random, cpu;
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !user_mode(regs));
 	cpu = smp_processor_id();
 	irq_enter();
 	kstat_cpus(cpu).irqs[irq]++;
 
@@ -208,9 +206,8 @@ static void do_IRQ(int irq, struct pt_re
 	}
 	unmask_irq(irq);
 	irq_exit();
 
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 	/* unmasking and bottom half handling is done magically for us. */
 }
 
 /*
Index: linux-2.6.5/arch/mips/kernel/i8259.c
===================================================================
--- linux-2.6.5.orig/arch/mips/kernel/i8259.c
+++ linux-2.6.5/arch/mips/kernel/i8259.c
@@ -14,9 +14,8 @@
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/spinlock.h>
 #include <linux/sysdev.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/i8259.h>
 #include <asm/io.h>
 
Index: linux-2.6.5/arch/mips/kernel/irq.c
===================================================================
--- linux-2.6.5.orig/arch/mips/kernel/irq.c
+++ linux-2.6.5/arch/mips/kernel/irq.c
@@ -21,9 +21,8 @@
 #include <linux/random.h>
 #include <linux/sched.h>
 #include <linux/seq_file.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -352,9 +351,8 @@ asmlinkage unsigned int do_IRQ(int irq, 
 	irq_desc_t *desc = irq_desc + irq;
 	struct irqaction * action;
 	unsigned int status;
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !user_mode(regs));
 	irq_enter();
 	kstat_this_cpu.irqs[irq]++;
 	spin_lock(&desc->lock);
 	desc->handler->ack(irq);
@@ -418,9 +416,8 @@ out:
 	desc->handler->end(irq);
 	spin_unlock(&desc->lock);
 
 	irq_exit();
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 
 	return 1;
 }
 
Index: linux-2.6.5/arch/mips/kernel/process.c
===================================================================
--- linux-2.6.5.orig/arch/mips/kernel/process.c
+++ linux-2.6.5/arch/mips/kernel/process.c
@@ -22,9 +22,8 @@
 #include <linux/user.h>
 #include <linux/a.out.h>
 #include <linux/init.h>
 #include <linux/completion.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
 #include <asm/fpu.h>
@@ -187,12 +186,8 @@ long kernel_thread(int (*fn)(void *), vo
 		  */
 		: "$2", "$3", "$4", "$5", "$6", "$7", "$8",
 		  "$9","$10","$11","$12","$13","$14","$15","$24","$25","$31");
 
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (retval > 0)
-		TRIG_EVENT(kthread_hook, retval, (int) fn);
-#endif
 	return retval;
 }
 
 struct mips_frame_info {
Index: linux-2.6.5/arch/mips/kernel/time.c
===================================================================
--- linux-2.6.5.orig/arch/mips/kernel/time.c
+++ linux-2.6.5/arch/mips/kernel/time.c
@@ -23,9 +23,8 @@
 #include <linux/kernel_stat.h>
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
@@ -551,17 +550,15 @@ irqreturn_t timer_interrupt(int irq, voi
 }
 
 asmlinkage void ll_timer_interrupt(int irq, struct pt_regs *regs)
 {
-	TRIG_EVENT(irq_entry_hook, irq, regs, CAUSE_EPC(regs));
 	irq_enter();
 	kstat_this_cpu.irqs[irq]++;
 
 	/* we keep interrupt disabled all the time */
 	timer_interrupt(irq, NULL, regs);
 
 	irq_exit();
-	TRIG_EVENT(irq_exit_hook, irq, regs);	
 }
 
 asmlinkage void ll_local_timer_interrupt(int irq, struct pt_regs *regs)
 {
Index: linux-2.6.5/arch/mips/kernel/traps.c
===================================================================
--- linux-2.6.5.orig/arch/mips/kernel/traps.c
+++ linux-2.6.5/arch/mips/kernel/traps.c
@@ -19,9 +19,8 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/spinlock.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/bootinfo.h>
 #include <asm/branch.h>
 #include <asm/cpu.h>
@@ -36,9 +35,8 @@
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 #include <asm/watch.h>
 #include <asm/types.h>
-#include <asm/unistd.h>
 
 extern asmlinkage void handle_mod(void);
 extern asmlinkage void handle_tlbl(void);
 extern asmlinkage void handle_tlbs(void);
@@ -341,9 +339,8 @@ asmlinkage void do_be(struct pt_regs *re
 	const struct exception_table_entry *fixup = NULL;
 	int data = regs->cp0_cause & 4;
 	int action = MIPS_BE_FATAL;
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	/* XXX For now.  Fixme, this searches the wrong table ...  */
 	if (data && !user_mode(regs))
 		fixup = search_dbe_tables(exception_epc(regs));
 
@@ -354,14 +351,12 @@ asmlinkage void do_be(struct pt_regs *re
 		action = board_be_handler(regs, fixup != 0);
 
 	switch (action) {
 	case MIPS_BE_DISCARD:
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	case MIPS_BE_FIXUP:
 		if (fixup) {
 			regs->cp0_epc = fixup->nextinsn;
-			TRIG_EVENT(trap_exit_hook);
 			return;
 		}
 		break;
 	default:
@@ -375,9 +370,8 @@ asmlinkage void do_be(struct pt_regs *re
 	       data ? "Data" : "Instruction",
 	       field, regs->cp0_epc, field, regs->regs[31]);
 	die_if_kernel("Oops", regs);
 	force_sig(SIGBUS, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 static inline int get_insn_opcode(struct pt_regs *regs, unsigned int *opcode)
 {
@@ -526,23 +520,20 @@ static inline int simulate_llsc(struct p
 asmlinkage void do_ov(struct pt_regs *regs)
 {
 	siginfo_t info;
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	info.si_code = FPE_INTOVF;
 	info.si_signo = SIGFPE;
 	info.si_errno = 0;
 	info.si_addr = (void *)regs->cp0_epc;
 	force_sig_info(SIGFPE, &info, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
  * XXX Delayed fp exceptions when doing a lazy ctx switch XXX
  */
 asmlinkage void do_fpe(struct pt_regs *regs, unsigned long fcr31)
 {
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	if (fcr31 & FPU_CSR_UNI_X) {
 		int sig;
 
 		/*
@@ -573,14 +564,12 @@ asmlinkage void do_fpe(struct pt_regs *r
 		/* If something went wrong, signal */
 		if (sig)
 			force_sig(sig, current);
 
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 	force_sig(SIGFPE, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_bp(struct pt_regs *regs)
 {
@@ -588,14 +577,11 @@ asmlinkage void do_bp(struct pt_regs *re
 	siginfo_t info;
 
 	die_if_kernel("Break instruction in kernel code", regs);
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
-
-	if (get_insn_opcode(regs, &opcode)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (get_insn_opcode(regs, &opcode))
 		return;
-	}
+
 	/*
 	 * There is the ancient bug in the MIPS assemblers that the break
 	 * code starts left to bit 16 instead to bit 6 in the opcode.
 	 * Gas is bug-compatible ...
@@ -622,9 +608,8 @@ asmlinkage void do_bp(struct pt_regs *re
 		break;
 	default:
 		force_sig(SIGTRAP, current);
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_tr(struct pt_regs *regs)
 {
@@ -632,14 +617,10 @@ asmlinkage void do_tr(struct pt_regs *re
 	siginfo_t info;
 
 	die_if_kernel("Trap instruction in kernel code", regs);
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
-
-	if (get_insn_opcode(regs, &opcode)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (get_insn_opcode(regs, &opcode))
 		return;
-	}
 
 	/* Immediate versions don't provide a code.  */
 	if (!(opcode & OPCODE))
 		tcode = ((opcode >> 6) & ((1 << 20) - 1));
@@ -664,44 +645,36 @@ asmlinkage void do_tr(struct pt_regs *re
 		break;
 	default:
 		force_sig(SIGTRAP, current);
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_ri(struct pt_regs *regs)
 {
 	die_if_kernel("Reserved instruction in kernel code", regs);
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	if (!cpu_has_llsc)
-		if (!simulate_llsc(regs)) {
-			TRIG_EVENT(trap_exit_hook);
+		if (!simulate_llsc(regs))
 			return;
-		}
 
 	force_sig(SIGILL, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_cpu(struct pt_regs *regs)
 {
 	unsigned int cpid;
 
 	die_if_kernel("do_cpu invoked from kernel context!", regs);
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	cpid = (regs->cp0_cause >> CAUSEB_CE) & 3;
 
 	switch (cpid) {
 	case 0:
 		if (cpu_has_llsc)
 			break;
 
-		if (!simulate_llsc(regs)) {
-			TRIG_EVENT(trap_exit_hook);
+		if (!simulate_llsc(regs))
 			return;
-		}
 		break;
 
 	case 1:
 		own_fpu();
@@ -718,18 +691,16 @@ asmlinkage void do_cpu(struct pt_regs *r
 			if (sig)
 				force_sig(sig, current);
 		}
 
-		TRIG_EVENT(trap_exit_hook);
 		return;
 
 	case 2:
 	case 3:
 		break;
 	}
 
 	force_sig(SIGILL, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_mdmx(struct pt_regs *regs)
 {
@@ -737,25 +708,21 @@ asmlinkage void do_mdmx(struct pt_regs *
 }
 
 asmlinkage void do_watch(struct pt_regs *regs)
 {
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	/*
 	 * We use the watch exception where available to detect stack
 	 * overflows.
 	 */
 	dump_tlb_all();
 	show_regs(regs);
-	TRIG_EVENT(trap_exit_hook);
 	panic("Caught WATCH exception - probably caused by stack overflow.");
 }
 
 asmlinkage void do_mcheck(struct pt_regs *regs)
 {
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	show_regs(regs);
 	dump_tlb_all();
-	TRIG_EVENT(trap_exit_hook);
 	/*
 	 * Some chips may have other causes of machine check (e.g. SB1
 	 * graduation timer)
 	 */
@@ -791,9 +758,8 @@ static inline void parity_protection_ini
 		break;
 	default:
 		break;
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void cache_parity_error(void)
 {
Index: linux-2.6.5/arch/mips/kernel/unaligned.c
===================================================================
--- linux-2.6.5.orig/arch/mips/kernel/unaligned.c
+++ linux-2.6.5/arch/mips/kernel/unaligned.c
@@ -77,9 +77,8 @@
 #include <linux/module.h>
 #include <linux/signal.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/asm.h>
 #include <asm/branch.h>
 #include <asm/byteorder.h>
@@ -497,19 +496,16 @@ asmlinkage void do_ade(struct pt_regs *r
 	extern int do_dsemulret(struct pt_regs *);
 	mm_segment_t seg;
 	unsigned long pc;
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	/*
 	 * Address errors may be deliberately induced by the FPU emulator to
 	 * retake control of the CPU after executing the instruction in the
 	 * delay slot of an emulated branch.
 	 */
 	/* Terminate if exception was recognized as a delay slot return */
-	if (do_dsemulret(regs)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (do_dsemulret(regs))
 		return;
-	}
 
 	/* Otherwise handle as normal */
 
 	/*
@@ -541,9 +537,8 @@ asmlinkage void do_ade(struct pt_regs *r
 			*regptr = newval;
 	}
 	set_fs(seg);
 
-	TRIG_EVENT(trap_exit_hook);
 	return;
 
 sigbus:
 	die_if_kernel("Kernel unaligned instruction access", regs);
@@ -551,6 +546,5 @@ sigbus:
 
 	/*
 	 * XXX On return from the signal handler we should advance the epc
 	 */
-	TRIG_EVENT(trap_exit_hook);
 }
Index: linux-2.6.5/arch/mips/mm/fault.c
===================================================================
--- linux-2.6.5.orig/arch/mips/mm/fault.c
+++ linux-2.6.5/arch/mips/mm/fault.c
@@ -18,18 +18,16 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/branch.h>
 #include <asm/hardirq.h>
 #include <asm/pgalloc.h>
 #include <asm/mmu_context.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/ptrace.h>
-#include <asm/mipsregs.h>
 
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
@@ -63,9 +61,8 @@ asmlinkage void do_page_fault(struct pt_
 	 */
 	if (unlikely(address >= VMALLOC_START))
 		goto vmalloc_fault;
 
-	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	/*
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
@@ -118,9 +115,8 @@ survive:
 		BUG();
 	}
 
 	up_read(&mm->mmap_sem);
-	TRIG_EVENT(trap_exit_hook);
 	return;
 
 /*
  * Something tried to access memory that isn't in our memory map..
@@ -147,17 +143,15 @@ bad_area_nosemaphore:
 		info.si_errno = 0;
 		/* info.si_code has been set above */
 		info.si_addr = (void *) address;
 		force_sig_info(SIGSEGV, &info, tsk);
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 no_context:
 	/* Are we prepared to handle this kernel fault?  */
 	if (fixup_exception(regs)) {
 		current->thread.cp0_baduaddr = address;
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 	/*
@@ -206,9 +200,8 @@ do_sigbus:
 	info.si_code = BUS_ADRERR;
 	info.si_addr = (void *) address;
 	force_sig_info(SIGBUS, &info, tsk);
 
-	TRIG_EVENT(trap_exit_hook);
 	return;
 
 vmalloc_fault:
 	{
@@ -241,6 +234,5 @@ vmalloc_fault:
 		if (!pte_present(*pte_k))
 			goto no_context;
 		return;
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
Index: linux-2.6.5/arch/parisc/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/parisc/Kconfig
+++ linux-2.6.5/arch/parisc/Kconfig
@@ -221,40 +221,8 @@ config DEBUG_INFO
 	  debugging info resulting in a larger kernel image.
 	  Say Y here only if you plan to use gdb to debug the kernel.
 	  If you don't debug the kernel, you can say N.
 	  
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/ppc/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/ppc/Kconfig
+++ linux-2.6.5/arch/ppc/Kconfig
@@ -1224,52 +1224,8 @@ config OCP
 	bool
 	depends on IBM_OCP
 	default y
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config ASM_HOOK
-	bool
-	default y
-	depends on DEBUG_KERNEL && HOOK
-	
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/ppc/kernel/entry.S
===================================================================
--- linux-2.6.5.orig/arch/ppc/kernel/entry.S
+++ linux-2.6.5/arch/ppc/kernel/entry.S
@@ -34,34 +34,8 @@
 
 #undef SHOW_SYSCALLS
 #undef SHOW_SYSCALLS_TASK
 
-/* syscall hooks for LTT */
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-#define ASM_PRE_SYSCALL	\
-	addi	r3,r1,STACK_FRAME_OVERHEAD;  	/* Put pointer to registers into r3 */	\
-	mflr	r29;				/* Save LR */ \
-	bl	pre_syscall;			/* Call real trace function */ \
-	mtlr	r29;				/* Restore LR */ \
-	lwz	r0,GPR0(r1);			/* Restore original registers */ \
-	lwz	r3,GPR3(r1);	\
-	lwz	r4,GPR4(r1);	\
-	lwz	r5,GPR5(r1);	\
-	lwz	r6,GPR6(r1);	\
-	lwz	r7,GPR7(r1);	\
-	lwz	r8,GPR8(r1);
-#define ASM_POST_SYSCALL \
-	bl	post_syscall;			/* Call real trace function */ \
-	lwz	r0,GPR0(r1);			/* Restore original registers */ \
-	lwz	r3,RESULT(r1); \
-	lwz	r4,GPR4(r1); \
-	lwz	r5,GPR5(r1); \
-	lwz	r6,GPR6(r1); \
-	lwz	r7,GPR7(r1); \
-	lwz	r8,GPR8(r1); \
-	addi	r9,r1,STACK_FRAME_OVERHEAD;
-#endif
-
 /*
  * MSR_KERNEL is > 0x10000 on 4xx since it include MSR_CE.
  */
 #if MSR_KERNEL >= 0x10000
@@ -210,18 +184,12 @@ syscall_dotrace_cont:
 	slwi	r0,r0,2
 	bge-	66f
 	lwzx	r10,r10,r0	/* Fetch system call handler [ptr] */
 	mtlr	r10
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	ASM_PRE_SYSCALL ;
-#endif
 	addi	r9,r1,STACK_FRAME_OVERHEAD
 	blrl			/* Call handler */
 	.globl	ret_from_syscall
 ret_from_syscall:
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	ASM_POST_SYSCALL ;
-#endif
 #ifdef SHOW_SYSCALLS
 	bl	do_show_syscall_exit
 #endif
 	mr	r6,r3
Index: linux-2.6.5/arch/ppc/kernel/irq.c
===================================================================
--- linux-2.6.5.orig/arch/ppc/kernel/irq.c
+++ linux-2.6.5/arch/ppc/kernel/irq.c
@@ -45,9 +45,8 @@
 #include <linux/proc_fs.h>
 #include <linux/random.h>
 #include <linux/seq_file.h>
 #include <linux/cpumask.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
 #include <asm/system.h>
@@ -431,9 +430,8 @@ void ppc_irq_dispatch_handler(struct pt_
 	int status;
 	struct irqaction *action;
 	irq_desc_t *desc = irq_desc + irq;
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	kstat_this_cpu.irqs[irq]++;
 	spin_lock(&desc->lock);
 	ack_irq(irq);
 	/*
@@ -509,9 +507,8 @@ out:
 		else if (irq_desc[irq].handler->enable)
 			irq_desc[irq].handler->enable(irq);
 	}
 	spin_unlock(&desc->lock);
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 }
 
 void do_IRQ(struct pt_regs *regs)
 {
Index: linux-2.6.5/arch/ppc/kernel/misc.S
===================================================================
--- linux-2.6.5.orig/arch/ppc/kernel/misc.S
+++ linux-2.6.5/arch/ppc/kernel/misc.S
@@ -1065,13 +1065,9 @@ _GLOBAL(cvt_df)
 /*
  * Create a kernel thread
  *   kernel_thread(fn, arg, flags)
  */
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK 
-_GLOBAL(original_kernel_thread)
-#else
 _GLOBAL(kernel_thread)
-#endif /* CONFIG_TRIGEVENT_SYSCALL_HOOK */
 	stwu	r1,-16(r1)
 	stw	r30,8(r1)
 	stw	r31,12(r1)
 	mr	r30,r3		/* function */
Index: linux-2.6.5/arch/ppc/kernel/process.c
===================================================================
--- linux-2.6.5.orig/arch/ppc/kernel/process.c
+++ linux-2.6.5/arch/ppc/kernel/process.c
@@ -34,9 +34,8 @@
 #include <linux/prctl.h>
 #include <linux/init_task.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -306,21 +305,8 @@ void show_regs(struct pt_regs * regs)
 	printk("\n");
 	show_stack(current, (unsigned long *) regs->gpr[1]);
 }
 
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK 
-long original_kernel_thread(int (*fn) (void *), void* arg, unsigned long flags);
-long kernel_thread(int (*fn) (void *), void* arg, unsigned long flags)
-{
-	long   retval;
-
-	retval = original_kernel_thread(fn, arg, flags);
-	if (retval > 0)
-		TRIG_EVENT(kthread_hook, retval, (int) fn);
-	return retval;
-}
-#endif /* CONFIG_TRIGEVENT_SYSCALL_HOOK */
- 
 void exit_thread(void)
 {
 	if (last_task_used_math == current)
 		last_task_used_math = NULL;
Index: linux-2.6.5/arch/ppc/kernel/syscalls.c
===================================================================
--- linux-2.6.5.orig/arch/ppc/kernel/syscalls.c
+++ linux-2.6.5/arch/ppc/kernel/syscalls.c
@@ -36,9 +36,8 @@
 #include <linux/utsname.h>
 #include <linux/file.h>
 #include <linux/unistd.h>
 #include <linux/fshooks.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 #include <asm/semaphore.h>
@@ -60,9 +59,8 @@ sys_ipc (uint call, int first, int secon
 
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
-	TRIG_EVENT(ipc_call_hook, call, first);
 	ret = -ENOSYS;
 	switch (call) {
 	case SEMOP:
 		ret = sys_semtimedop (first, (struct sembuf __user *)ptr,
Index: linux-2.6.5/arch/ppc/kernel/time.c
===================================================================
--- linux-2.6.5.orig/arch/ppc/kernel/time.c
+++ linux-2.6.5/arch/ppc/kernel/time.c
@@ -55,9 +55,8 @@
 #include <linux/kernel_stat.h>
 #include <linux/mc146818rtc.h>
 #include <linux/time.h>
 #include <linux/init.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
 #include <asm/nvram.h>
@@ -152,9 +151,8 @@ void timer_interrupt(struct pt_regs * re
 
 	if (atomic_read(&ppc_n_lost_interrupts) != 0)
 		do_IRQ(regs);
 
-	TRIG_EVENT(trap_entry_hook, regs->trap, instruction_pointer(regs));
 	irq_enter();
 
 	while ((next_dec = tb_ticks_per_jiffy - tb_delta(&jiffy_stamp)) < 0) {
 		jiffy_stamp += tb_ticks_per_jiffy;
@@ -200,17 +198,15 @@ void timer_interrupt(struct pt_regs * re
 		set_dec(next_dec);
 	last_jiffy_stamp(cpu) = jiffy_stamp;
 
 #ifdef CONFIG_SMP
-	TRIG_EVENT(timer_hook, regs);
 	smp_local_timer_interrupt(regs);
 #endif /* CONFIG_SMP */
 
 	if (ppc_md.heartbeat && !ppc_md.heartbeat_count--)
 		ppc_md.heartbeat();
 
 	irq_exit();
-	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
  * This version of gettimeofday has microsecond resolution.
Index: linux-2.6.5/arch/ppc/kernel/traps.c
===================================================================
--- linux-2.6.5.orig/arch/ppc/kernel/traps.c
+++ linux-2.6.5/arch/ppc/kernel/traps.c
@@ -29,9 +29,8 @@
 #include <linux/interrupt.h>
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -118,11 +117,9 @@ _exception(int signr, struct pt_regs *re
 	info.si_signo = signr;
 	info.si_errno = 0;
 	info.si_code = code;
 	info.si_addr = (void *) addr;
-	TRIG_EVENT(trap_entry_hook, regs->trap, instruction_pointer(regs));
 	force_sig_info(signr, &info, current);
-	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
  * I/O accesses can cause machine checks on powermacs.
Index: linux-2.6.5/arch/ppc/mm/fault.c
===================================================================
--- linux-2.6.5.orig/arch/ppc/mm/fault.c
+++ linux-2.6.5/arch/ppc/mm/fault.c
@@ -27,9 +27,8 @@
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/highmem.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/mmu.h>
@@ -121,28 +120,23 @@ int do_page_fault(struct pt_regs *regs, 
 	else
 		is_write = error_code & 0x02000000;
 #endif /* CONFIG_4xx */
 
-	TRIG_EVENT(trap_entry_hook, regs->trap, instruction_pointer(regs));
 #if defined(CONFIG_XMON) || defined(CONFIG_KGDB)
 	if (debugger_fault_handler && TRAP(regs) == 0x300) {
 		debugger_fault_handler(regs);
-		TRIG_EVENT(trap_exit_hook);
 		return 0;
 	}
 #if !defined(CONFIG_4xx)
 	if (error_code & 0x00400000) {
 		/* DABR match */
-		if (debugger_dabr_match(regs)) {
-			TRIG_EVENT(trap_exit_hook);
+		if (debugger_dabr_match(regs))
 			return 0;
-		}
 	}
 #endif /* !CONFIG_4xx */
 #endif /* CONFIG_XMON || CONFIG_KGDB */
 
 	if (in_atomic() || mm == NULL) {
-		TRIG_EVENT(trap_exit_hook);
 		return SIGSEGV;
 	}
 
 	down_read(&mm->mmap_sem);
@@ -282,9 +276,8 @@ good_area:
 	 * just need pte's created via handle_mm_fault()
 	 * -- Cort
 	 */
 	pte_misses++;
-	TRIG_EVENT(trap_exit_hook);
 	return 0;
 
 bad_area:
 	up_read(&mm->mmap_sem);
@@ -296,13 +289,11 @@ bad_area:
 		info.si_errno = 0;
 		info.si_code = code;
 		info.si_addr = (void *) address;
 		force_sig_info(SIGSEGV, &info, current);
-		TRIG_EVENT(trap_exit_hook);
 		return 0;
 	}
 
-	TRIG_EVENT(trap_exit_hook);
 	return SIGSEGV;
 
 /*
  * We ran out of memory, or some other thing happened to us that made
@@ -317,9 +308,8 @@ out_of_memory:
 	}
 	printk("VM: killing process %s\n", current->comm);
 	if (user_mode(regs))
 		do_exit(SIGKILL);
-	TRIG_EVENT(trap_exit_hook);
 	return SIGKILL;
 
 do_sigbus:
 	up_read(&mm->mmap_sem);
@@ -328,13 +318,11 @@ do_sigbus:
 	info.si_code = BUS_ADRERR;
 	info.si_addr = (void *)address;
 	force_sig_info (SIGBUS, &info, current);
 	if (!user_mode(regs)) {
-		TRIG_EVENT(trap_exit_hook);
 		return SIGBUS;
 	}
 
-	TRIG_EVENT(trap_exit_hook);
 	return 0;
 }
 
 /*
Index: linux-2.6.5/arch/ppc64/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/ppc64/Kconfig
+++ linux-2.6.5/arch/ppc64/Kconfig
@@ -537,46 +537,8 @@ config SPINLINE
 	  somewhat bigger, but can be useful when profiling the kernel.
 
 	  If in doubt, say N.
 
-
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config ASM_HOOK
-	bool
-	default y
-	depends on DEBUG_KERNEL && HOOK
-	
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-	
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/ppc64/kernel/irq.c
===================================================================
--- linux-2.6.5.orig/arch/ppc64/kernel/irq.c
+++ linux-2.6.5/arch/ppc64/kernel/irq.c
@@ -40,9 +40,8 @@
 #include <linux/irq.h>
 #include <linux/proc_fs.h>
 #include <linux/random.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
 #include <asm/system.h>
@@ -485,9 +484,8 @@ void ppc_irq_dispatch_handler(struct pt_
 #ifdef CONFIG_IRQSTACKS
 	struct thread_info *curtp, *irqtp;
 #endif
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	kstat_cpu(cpu).irqs[irq]++;
 
 	if (desc->status & IRQ_PER_CPU) {
 		/* no locking required for CPU-local interrupts: */
@@ -587,9 +585,8 @@ out:
 		else if (desc->handler->enable)
 			desc->handler->enable(irq);
 	}
 	spin_unlock(&desc->lock);
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 }
 
 #ifdef CONFIG_PPC_ISERIES
 int do_IRQ(struct pt_regs *regs)
Index: linux-2.6.5/arch/ppc64/kernel/time.c
===================================================================
--- linux-2.6.5.orig/arch/ppc64/kernel/time.c
+++ linux-2.6.5/arch/ppc64/kernel/time.c
@@ -48,9 +48,8 @@
 #include <linux/time.h>
 #include <linux/init.h>
 #include <linux/profile.h>
 #include <linux/audit.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
 #include <asm/processor.h>
@@ -281,9 +280,8 @@ int timer_interrupt(struct pt_regs * reg
 
 	while (lpaca->next_jiffy_update_tb <= (cur_tb = get_tb())) {
 
 #ifdef CONFIG_SMP
-		TRIG_EVENT(timer_hook, regs);
 		smp_local_timer_interrupt(regs);
 #endif
 		if (cpu == boot_cpuid) {
 			write_seqlock(&xtime_lock);
Index: linux-2.6.5/arch/s390/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/s390/Kconfig
+++ linux-2.6.5/arch/s390/Kconfig
@@ -431,52 +431,8 @@ config DEBUG_SPINLOCK_SLEEP
 	help
 	  If you say Y here, various routines which may sleep will become very
 	  noisy if they are called with a spinlock held.	
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config ASM_HOOK
-	bool
-	default y
-	depends on DEBUG_KERNEL && HOOK
-	
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/s390/kernel/process.c
===================================================================
--- linux-2.6.5.orig/arch/s390/kernel/process.c
+++ linux-2.6.5/arch/s390/kernel/process.c
@@ -32,9 +32,8 @@
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/reboot.h>
 #include <linux/init.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -179,9 +178,8 @@ __asm__(".align 4\n"
 
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
 	struct pt_regs regs;
-	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 	regs.psw.mask = PSW_KERNEL_BITS;
 	regs.psw.addr = (unsigned long) kernel_thread_starter | PSW_ADDR_AMODE;
@@ -192,16 +190,10 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.gprs[11] = (unsigned long) do_exit;
 	regs.orig_gpr2 = -1;
 
 	/* Ok, create the new process.. */
-	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED,
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED,
 		       0, &regs, 0, NULL, NULL);
-	
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (ret > 0)
-		TRIG_EVENT(kthread_hook, ret, (int) fn);
-#endif
-	return ret;
 }
 
 /*
  * Free current thread data structures etc..
Index: linux-2.6.5/arch/s390/kernel/sys_s390.c
===================================================================
--- linux-2.6.5.orig/arch/s390/kernel/sys_s390.c
+++ linux-2.6.5/arch/s390/kernel/sys_s390.c
@@ -29,9 +29,8 @@
 #ifdef CONFIG_ARCH_S390X
 #include <linux/personality.h>
 #endif /* CONFIG_ARCH_S390X */
 #include <linux/fshooks.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 
@@ -165,9 +164,8 @@ asmlinkage long sys_ipc (uint call, int 
 {
         struct ipc_kludge tmp;
 	int ret;
 
-        TRIG_EVENT(ipc_call_hook, call, first);
         switch (call) {
         case SEMOP:
 		return sys_semtimedop (first, (struct sembuf *) ptr, second,
 				       NULL);
Index: linux-2.6.5/arch/s390/kernel/time.c
===================================================================
--- linux-2.6.5.orig/arch/s390/kernel/time.c
+++ linux-2.6.5/arch/s390/kernel/time.c
@@ -25,9 +25,8 @@
 #include <linux/smp.h>
 #include <linux/types.h>
 #include <linux/timex.h>
 #include <linux/config.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/delay.h>
 #include <asm/s390_ext.h>
@@ -300,9 +299,8 @@ void account_ticks(struct pt_regs *regs)
 	 * Do not rely on the boot cpu to do the calls to do_timer.
 	 * Spread it over all cpus instead.
 	 */
 	write_seqlock(&xtime_lock);
-	TRIG_EVENT(timer_hook, regs);
 	if (S390_lowcore.jiffy_timer > xtime_cc) {
 		__u32 xticks;
 
 		tmp = S390_lowcore.jiffy_timer - xtime_cc;
Index: linux-2.6.5/arch/s390/kernel/traps.c
===================================================================
--- linux-2.6.5.orig/arch/s390/kernel/traps.c
+++ linux-2.6.5/arch/s390/kernel/traps.c
@@ -4,9 +4,8 @@
  *  S390 version
  *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
  *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com),
- *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/kernel/traps.c"
  *    Copyright (C) 1991, 1992 Linus Torvalds
  */
@@ -29,9 +28,8 @@
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -271,19 +269,14 @@ void die(const char * str, struct pt_reg
 
 static void inline do_trap(long interruption_code, int signr, char *str,
                            struct pt_regs *regs, siginfo_t *info)
 {
-	trapid_t ltt_interruption_code;
-	char * ic_ptr = (char *) &ltt_interruption_code;
 	/*
 	 * We got all needed information from the lowcore and can
 	 * now safely switch on interrupts.
 	 */
         if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+4,&interruption_code,sizeof(interruption_code));
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code, (regs->psw.addr & PSW_ADDR_INSN));
 
         if (regs->psw.mask & PSW_MASK_PSTATE) {
                 struct task_struct *tsk = current;
 
@@ -312,9 +305,8 @@ static void inline do_trap(long interrup
                         regs->psw.addr = fixup->fixup | PSW_ADDR_AMODE;
                 else
                         die(str, regs, interruption_code);
         }
-	TRIG_EVENT(trap_exit_hook);
 }
 
 static inline void *get_check_address(struct pt_regs *regs)
 {
@@ -322,13 +314,8 @@ static inline void *get_check_address(st
 }
 
 int do_debugger_trap(struct pt_regs *regs)
 {
-	trapid_t ltt_interruption_code;
-	char * ic_ptr = (char *) &ltt_interruption_code;
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+6,&S390_lowcore.pgm_code,2); /* copy the interrupt code */
-
 	if ((regs->psw.mask & PSW_MASK_PSTATE) &&
 	    (current->ptrace & PT_PTRACED)) {
 		force_sig(SIGTRAP,current);
 		return 0;
@@ -402,10 +389,8 @@ do_fp_trap(struct pt_regs *regs, void *l
 asmlinkage void illegal_op(struct pt_regs * regs, long interruption_code)
 {
         __u8 opcode[6];
 	__u16 *location;
-        trapid_t ltt_interruption_code;
-        char * ic_ptr = (char *) &ltt_interruption_code;
 	int signal = 0;
 
 	location = (__u16 *) get_check_address(regs);
 
@@ -415,11 +400,8 @@ asmlinkage void illegal_op(struct pt_reg
 	 */
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+4,&interruption_code,sizeof(interruption_code));
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code, (regs->psw.addr & PSW_ADDR_INSN));
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		get_user(*((__u16 *) opcode), location);
 	else
 		*((__u16 *)opcode)=*((__u16 *)location);
@@ -458,9 +440,8 @@ asmlinkage void illegal_op(struct pt_reg
                            current->thread.fp_regs.fpc, interruption_code);
         else if (signal)
 		do_trap(interruption_code, signal,
 			"illegal operation", regs, NULL);
-        TRIG_EVENT(trap_exit_hook);
 }
 
 
 #ifdef CONFIG_MATHEMU
@@ -468,10 +449,8 @@ asmlinkage void 
 specification_exception(struct pt_regs * regs, long interruption_code)
 {
         __u8 opcode[6];
 	__u16 *location = NULL;
-        trapid_t ltt_interruption_code;
-        char * ic_ptr = (char *) &ltt_interruption_code;
 	int signal = 0;
 
 	location = (__u16 *) get_check_address(regs);
 
@@ -481,11 +460,8 @@ specification_exception(struct pt_regs *
 	 */
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 		
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+4,&interruption_code,sizeof(interruption_code));
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code, (regs->psw.addr & PSW_ADDR_INSN));
         if (regs->psw.mask & PSW_MASK_PSTATE) {
 		get_user(*((__u16 *) opcode), location);
 		switch (opcode[0]) {
 		case 0x28: /* LDR Rx,Ry   */
@@ -527,9 +503,8 @@ specification_exception(struct pt_regs *
 		info.si_addr = location;
 		do_trap(interruption_code, signal, 
 			"specification exception", regs, &info);
 	}
-        TRIG_EVENT(trap_exit_hook);
 }
 #else
 DO_ERROR_INFO(SIGILL, "specification exception", specification_exception,
 	      ILL_ILLOPN, get_check_address(regs));
@@ -537,10 +512,8 @@ DO_ERROR_INFO(SIGILL, "specification exc
 
 asmlinkage void data_exception(struct pt_regs * regs, long interruption_code)
 {
 	__u16 *location;
-        trapid_t ltt_interruption_code;
-        char * ic_ptr = (char *) &ltt_interruption_code;
 	int signal = 0;
 
 	location = (__u16 *) get_check_address(regs);
 
@@ -550,11 +523,8 @@ asmlinkage void data_exception(struct pt
 	 */
 	if (regs->psw.mask & PSW_MASK_PSTATE)
 		local_irq_enable();
 
-	memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-	memcpy(ic_ptr+4,&interruption_code,sizeof(interruption_code));
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code, (regs->psw.addr & PSW_ADDR_INSN));
 	if (MACHINE_HAS_IEEE)
 		__asm__ volatile ("stfpc %0\n\t" 
 				  : "=m" (current->thread.fp_regs.fpc));
 
@@ -628,9 +598,8 @@ asmlinkage void data_exception(struct pt
 		info.si_addr = location;
 		do_trap(interruption_code, signal, 
 			"data exception", regs, &info);
 	}
-        TRIG_EVENT(trap_exit_hook);
 }
 
 
 
Index: linux-2.6.5/arch/s390/mm/fault.c
===================================================================
--- linux-2.6.5.orig/arch/s390/mm/fault.c
+++ linux-2.6.5/arch/s390/mm/fault.c
@@ -4,9 +4,8 @@
  *  S390 version
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Hartmut Penner (hp@de.ibm.com)
  *               Ulrich Weigand (uweigand@de.ibm.com)
- *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/mm/fault.c"
  *    Copyright (C) 1995  Linus Torvalds
  */
@@ -25,9 +24,8 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/console.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -169,10 +167,8 @@ extern inline void do_exception(struct p
         unsigned long address;
 	int user_address;
 	const struct exception_table_entry *fixup;
 	int si_code = SEGV_MAPERR;
-        trapid_t ltt_interruption_code;                 
-        char * ic_ptr = (char *) &ltt_interruption_code; 
 
         tsk = current;
         mm = tsk->mm;
 	
@@ -218,11 +214,8 @@ extern inline void do_exception(struct p
 	 * interrupts again and then search the VMAs
 	 */
 	local_irq_enable();
 
-        memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
-        memcpy(ic_ptr+4,&error_code,sizeof(error_code));
-        TRIG_EVENT(trap_entry_hook, ltt_interruption_code,(regs->psw.addr & PSW_ADDR_INSN));
         down_read(&mm->mmap_sem);
 
         vma = find_vma(mm, address);
         if (!vma)
@@ -269,9 +262,8 @@ survive:
 		BUG();
 	}
 
         up_read(&mm->mmap_sem);
-        TRIG_EVENT(trap_exit_hook);
         return;
 
 /*
  * Something tried to access memory that isn't in our memory map..
@@ -284,18 +276,16 @@ bad_area:
         if (regs->psw.mask & PSW_MASK_PSTATE) {
                 tsk->thread.prot_addr = address;
                 tsk->thread.trap_no = error_code;
 		force_sigsegv(regs, error_code, si_code, address);
-                TRIG_EVENT(trap_exit_hook);
                 return;
 	}
 
 no_context:
         /* Are we prepared to handle this kernel fault?  */
 	fixup = search_exception_tables(regs->psw.addr & __FIXUP_MASK);
 	if (fixup) {
 		regs->psw.addr = fixup->fixup | PSW_ADDR_AMODE;
-		TRIG_EVENT(trap_exit_hook);
                 return;
         }
 
 /*
@@ -341,9 +331,8 @@ do_sigbus:
 
 	/* Kernel mode? Handle exceptions or die */
 	if (!(regs->psw.mask & PSW_MASK_PSTATE))
 		goto no_context;
-	TRIG_EVENT(trap_exit_hook);
 }
 
 void do_protection_exception(struct pt_regs *regs, unsigned long error_code)
 {
Index: linux-2.6.5/arch/sh/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/sh/Kconfig
+++ linux-2.6.5/arch/sh/Kconfig
@@ -789,46 +789,8 @@ config FRAME_POINTER
 	  and slower, but it will give very useful debugging information.
 	  If you don't debug the kernel, you can say N, but we may not be able
 	  to solve problems without frame pointers.
 
-config HOOK
-	tristate "Kernel Hook support"
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-	
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
-config TRIGEVENT_SYSCALL_HOOK
-	bool " Enable syscall entry/exit hooks"
-	depends on TRIGEVENT_HOOKS
-	help 
-	RAS hooks to enable tracing of system call entry and exit points.
-	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/sh/kernel/entry.S
===================================================================
--- linux-2.6.5.orig/arch/sh/kernel/entry.S
+++ linux-2.6.5/arch/sh/kernel/entry.S
@@ -554,21 +554,8 @@ syscall_badsys:			! Bad syscall number
 	bra	debug_trap
 	 nop
 	!
 good_system_call:		! Good syscall number
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	! TODO: for i386 this code only happens when not ptrace'd
-	mov 	r15, r4     	    	! pass pt_regs* as first arg
-	mov.l	__pre_syscall, r11 	! Call pre_syscall()
-	jsr	@r11	    	    	! (will chomp R[0-7])
-	 nop
-	!   	    	    	    	Reload R4-R7 from kernel stack
-	mov.l	@(OFF_R4,r15), r4   ! arg0
-	mov.l	@(OFF_R5,r15), r5
-	mov.l	@(OFF_R6,r15), r6
-	mov.l	@(OFF_R7,r15), r7   ! arg3
-	mov.l	@(OFF_R3,r15), r3   ! syscall_nr
-#endif
 	mov.l	@(TI_FLAGS,r8), r8
 	mov	#_TIF_SYSCALL_TRACE, r10
 	tst	r10, r8
 	bf	syscall_trace_entry
@@ -582,14 +569,8 @@ syscall_call:
 	 nop
 	mov.l	r0, @(OFF_R0,r15)		! save the return value
 	!
 syscall_exit:
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	! TODO: for i386 this code only happens when not ptrace'd
-	mov.l	__post_syscall, r1 	    	! Call post_syscall()
-	jsr	@r1
-	 nop
-#endif
 	CLI()
 	!
 	GET_THREAD_INFO(r8)
 	mov.l	@(TI_FLAGS,r8), r0		! current_thread_info->flags
@@ -694,14 +675,8 @@ skip_restore:
 4:	.long	do_syscall_trace
 5:	.long	0x00001000	! DSP
 7:	.long	0x30000000
 9:
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-__pre_syscall:
-	.long   SYMBOL_NAME(pre_syscall)
-__post_syscall:
-	.long   SYMBOL_NAME(post_syscall)
-#endif
 __INV_IMASK:
 	.long	0xffffff0f	! ~(IMASK)
 
 ! Exception Vector Base
Index: linux-2.6.5/arch/sh/kernel/irq.c
===================================================================
--- linux-2.6.5.orig/arch/sh/kernel/irq.c
+++ linux-2.6.5/arch/sh/kernel/irq.c
@@ -30,9 +30,8 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/seq_file.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
 #include <asm/bitops.h>
@@ -139,13 +138,8 @@ int handle_IRQ_event(unsigned int irq, s
 {
 	int status = 1;	/* Force the "do bottom halves" bit */
 	int retval = 0;
 
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (irq != TIMER_IRQ) { /* avoid double-reporting the timer IRQ */
-		TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
-	}
-#endif
 	if (!(action->flags & SA_INTERRUPT))
 		local_irq_enable();
 
 	do {
@@ -157,13 +151,8 @@ int handle_IRQ_event(unsigned int irq, s
 	if (status & SA_SAMPLE_RANDOM)
 		add_interrupt_randomness(irq);
 
 	local_irq_disable();
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (irq != TIMER_IRQ) { /* avoid double-reporting the timer IRQ */
-		TRIG_EVENT(irq_exit_hook, irq, regs);
-	}
-#endif
 	return retval;
 }
 
 static void __report_bad_irq(int irq, irq_desc_t *desc, irqreturn_t action_ret)
Index: linux-2.6.5/arch/sh/kernel/process.c
===================================================================
--- linux-2.6.5.orig/arch/sh/kernel/process.c
+++ linux-2.6.5/arch/sh/kernel/process.c
@@ -19,9 +19,8 @@
 #include <linux/a.out.h>
 #include <linux/ptrace.h>
 #include <linux/platform.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -147,9 +146,8 @@ __asm__(".align 5\n"
 
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {	/* Don't use this in BL=1(cli).  Or else, CPU resets! */
 	struct pt_regs regs;
-	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 	regs.regs[4] = (unsigned long) arg;
 	regs.regs[5] = (unsigned long) fn;
@@ -157,14 +155,9 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.pc = (unsigned long) kernel_thread_helper;
 	regs.sr = (1 << 30);
 
 	/* Ok, create the new process.. */
-	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
-#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
-	if (ret > 0)
-		TRIG_EVENT(kthread_hook, ret, (int) fn);
-#endif
-	return  ret;
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
 
 /*
  * Free current thread data structures etc..
Index: linux-2.6.5/arch/sh/kernel/sys_sh.c
===================================================================
--- linux-2.6.5.orig/arch/sh/kernel/sys_sh.c
+++ linux-2.6.5/arch/sh/kernel/sys_sh.c
@@ -20,9 +20,8 @@
 #include <linux/syscalls.h>
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 
@@ -166,9 +165,8 @@ asmlinkage int sys_ipc(uint call, int fi
 
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
-	TRIG_EVENT(ipc_call_hook, call, first);
 	if (call <= SEMCTL)
 		switch (call) {
 		case SEMOP:
 			return sys_semtimedop(first, (struct sembuf __user *)ptr,
Index: linux-2.6.5/arch/sh/kernel/traps.c
===================================================================
--- linux-2.6.5.orig/arch/sh/kernel/traps.c
+++ linux-2.6.5/arch/sh/kernel/traps.c
@@ -26,9 +26,8 @@
 #include <linux/delay.h>
 #include <linux/spinlock.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -67,11 +66,9 @@ asmlinkage void do_##name(unsigned long 
 	local_irq_enable();						\
 	tsk->thread.error_code = error_code;				\
 	tsk->thread.trap_no = trapnr;					\
         CHK_REMOTE_DEBUG(&regs);					\
-	TRIG_EVENT(trap_entry_hook, trapnr, regs.pc);			\
 	force_sig(signr, tsk);						\
-	TRIG_EVENT(trap_exit_hook);					\
 	die_if_no_fixup(str,&regs,error_code);				\
 }
 
 #ifdef CONFIG_CPU_SH2
@@ -502,9 +499,8 @@ asmlinkage void do_address_error(struct 
 	int tmp;
 
 	asm volatile("stc       r2_bank,%0": "=r" (error_code));
 
-	TRIG_EVENT(trap_entry_hook, error_code >> 5, regs->pc);
 	oldfs = get_fs();
 
 	if (user_mode(regs)) {
 		local_irq_enable();
@@ -526,12 +522,10 @@ asmlinkage void do_address_error(struct 
 
 		tmp = handle_unaligned_access(instruction, regs);
 		set_fs(oldfs);
 
-		if (tmp==0) {
-			TRIG_EVENT(trap_exit_hook);
+		if (tmp==0)
 			return; /* sorted */
-		}
 
 	uspace_segv:
 		printk(KERN_NOTICE "Killing process \"%s\" due to unaligned access\n", current->comm);
 		force_sig(SIGSEGV, current);
@@ -550,9 +544,8 @@ asmlinkage void do_address_error(struct 
 
 		handle_unaligned_access(instruction, regs);
 		set_fs(oldfs);
 	}
-	TRIG_EVENT(trap_exit_hook);
 }
 
 #ifdef CONFIG_SH_DSP
 /*
Index: linux-2.6.5/arch/sh/mm/fault.c
===================================================================
--- linux-2.6.5.orig/arch/sh/mm/fault.c
+++ linux-2.6.5/arch/sh/mm/fault.c
@@ -20,9 +20,8 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -54,15 +53,8 @@ asmlinkage void do_page_fault(struct pt_
 
 	tsk = current;
 	mm = tsk->mm;
 
-#if (CONFIG_TRIGEVENT_HOOKS)
-	{
-		unsigned long trapnr;
-		asm volatile("stc       r2_bank,%0": "=r" (trapnr));
-		TRIG_EVENT(trap_entry_hook, trapnr >> 5, regs->pc);  /* trap 4,5 or 6 */
-	}
-#endif
 	/*
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
@@ -114,9 +106,8 @@ survive:
 			BUG();
 	}
 
 	up_read(&mm->mmap_sem);
-	TRIG_EVENT(trap_exit_hook);
 	return;
 
 /*
  * Something tried to access memory that isn't in our memory map..
@@ -128,18 +119,15 @@ bad_area:
 	if (user_mode(regs)) {
 		tsk->thread.address = address;
 		tsk->thread.error_code = writeaccess;
 		force_sig(SIGSEGV, tsk);
-		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 no_context:
 	/* Are we prepared to handle this kernel fault?  */
-	if (fixup_exception(regs)) {
-		TRIG_EVENT(trap_exit_hook);
+	if (fixup_exception(regs))
 		return;
-	}
 
 /*
  * Oops. The kernel tried to access some bad page. We'll have to
  * terminate things with extreme prejudice.
@@ -197,9 +185,8 @@ do_sigbus:
 
 	/* Kernel mode? Handle exceptions or die */
 	if (!user_mode(regs))
 		goto no_context;
-	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
  * Called with interrupt disabled.
Index: linux-2.6.5/arch/sparc/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/sparc/Kconfig
+++ linux-2.6.5/arch/sparc/Kconfig
@@ -447,39 +447,8 @@ config DEBUG_BUGVERBOSE
 	  Say Y here to make BUG() panics output the file name and line number
 	  of the BUG call as well as the EIP and oops trace.  This aids
 	  debugging but costs about 70-100K of memory.
 
-config HOOK
-	tristate "Kernel Hook support"
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/sparc64/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/sparc64/Kconfig
+++ linux-2.6.5/arch/sparc64/Kconfig
@@ -699,40 +699,8 @@ config MCOUNT
 	bool
 	depends on STACK_DEBUG
 	default y
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/x86_64/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/x86_64/Kconfig
+++ linux-2.6.5/arch/x86_64/Kconfig
@@ -568,40 +568,8 @@ config IOMMU_LEAK
        
 #config X86_REMOTE_DEBUG
 #       bool "kgdb debugging stub"
 
-config HOOK
-	tristate "Kernel Hook support"
-	depends on DEBUG_KERNEL 
-	help
-	 The Kernel Hooks Interface is a generalised facility for placing hooks in
-	 arbitrary kernel locations. A hook is a location in the kernel that
-	 calls out of the kernel to a kernel module routine - a hook exit routine.
-	 Read Documentation/hook/HOWTO for more details.
-
-config HOOK_PROCFS
-	bool "/proc interface for hooks" 
-	depends on DEBUG_KERNEL && HOOK
-
-config TRIGEVENT_HOOKS
-	bool "RAS Instrumentation Hooks"
-	depends on HOOK=y 
-	help 
-	RAS Instrumentation Hooks are kernel hooks to trace system calls and
-	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
-	 also.
-
-	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
-	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
-	 routines, Kernel threads create routine, Process Management routines (such as 
-	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
-	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
-	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
-	 routines, Sockets  create, send, receive routines, tasklets, Trap 
-	 entry and exit routines etc.
-
-	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
-
 endmenu
 
 source "security/Kconfig"
 
Index: linux-2.6.5/arch/x86_64/kernel/apic.c
===================================================================
--- linux-2.6.5.orig/arch/x86_64/kernel/apic.c
+++ linux-2.6.5/arch/x86_64/kernel/apic.c
@@ -25,9 +25,8 @@
 #include <linux/interrupt.h>
 #include <linux/mc146818rtc.h>
 #include <linux/kernel_stat.h>
 #include <linux/sysdev.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/smp.h>
 #include <asm/mtrr.h>
@@ -857,9 +856,8 @@ void smp_local_timer_interrupt(struct pt
 				per_cpu(prof_counter, cpu);
 		}
 
 #ifdef CONFIG_SMP
-		TRIG_EVENT(timer_hook, regs);
 		update_process_times(user_mode(regs));
 #endif
 	}
 
Index: linux-2.6.5/arch/x86_64/kernel/irq.c
===================================================================
--- linux-2.6.5.orig/arch/x86_64/kernel/irq.c
+++ linux-2.6.5/arch/x86_64/kernel/irq.c
@@ -32,9 +32,8 @@
 #include <linux/kernel_stat.h>
 #include <linux/irq.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/io.h>
 #include <asm/smp.h>
@@ -214,9 +213,8 @@ inline void synchronize_irq(unsigned int
 int handle_IRQ_event(unsigned int irq, struct pt_regs * regs, struct irqaction * action)
 {
 	int status = 1; /* Force the "do bottom halves" bit */
 
-	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	if (!(action->flags & SA_INTERRUPT))
 		local_irq_enable();
 
 	do {
@@ -227,9 +225,8 @@ int handle_IRQ_event(unsigned int irq, s
 	if (status & SA_SAMPLE_RANDOM)
 		add_interrupt_randomness(irq);
 	local_irq_disable();
 
-	TRIG_EVENT(irq_exit_hook, irq, regs);
 	return status;
 }
 
 /*
Index: linux-2.6.5/drivers/s390/s390mach.c
===================================================================
--- linux-2.6.5.orig/drivers/s390/s390mach.c
+++ linux-2.6.5/drivers/s390/s390mach.c
@@ -5,17 +5,15 @@
  *  S390 version
  *    Copyright (C) 2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Ingo Adlung (adlung@de.ibm.com)
  *		 Martin Schwidefsky (schwidefsky@de.ibm.com)
- *	Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  */
 
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/errno.h>
 #include <linux/workqueue.h>
-#include <linux/trigevent_hooks.h>
 
 #include <asm/lowcore.h>
 
 #include "s390mach.h"
@@ -130,20 +128,10 @@ repeat:
 void
 s390_do_machine_check(void)
 {
 	struct mci *mci;
-	trapid_t ltt_interruption_code;
-	uint32_t ltt_old_psw;
 
 	mci = (struct mci *) &S390_lowcore.mcck_interruption_code;
-	memcpy( &ltt_interruption_code,
-		&S390_lowcore.mcck_interruption_code,
-		sizeof(__u64));
-	memcpy( &ltt_old_psw,
-		&S390_lowcore.mcck_old_psw,
-		sizeof(uint32_t));
-	ltt_old_psw &=  PSW_ADDR_INSN;
-	TRIG_EVENT(trap_entry_hook, ltt_interruption_code,ltt_old_psw);
 
 	if (mci->sd)		/* system damage */
 		s390_handle_damage("received system damage machine check\n");
 
Index: linux-2.6.5/include/asm-mips/mipsregs.h
===================================================================
--- linux-2.6.5.orig/include/asm-mips/mipsregs.h
+++ linux-2.6.5/include/asm-mips/mipsregs.h
@@ -524,11 +524,8 @@
 #define CEB_EXL		1	/* Count events with EXL = 1, ERL = 0 */
 
 #ifndef __ASSEMBLY__
 
-#define CAUSE_EXCCODE(x) ((CAUSEF_EXCCODE & (x->cp0_cause)) >> CAUSEB_EXCCODE)
-#define CAUSE_EPC(x) (x->cp0_epc + (((x->cp0_cause & CAUSEF_BD) >> CAUSEB_BD) << 2))
-
 /*
  * Functions to access the r10k performance counter and control registers
  */
 #define read_r10k_perf_cntr(counter)                            \
Index: linux-2.6.5/include/asm-ppc/hook.h
===================================================================
--- linux-2.6.5.orig/include/asm-ppc/hook.h
+++ /dev/null
@@ -1,47 +0,0 @@
-#ifndef __ASM_PPC_HOOK_H
-#define __ASM_PPC_HOOK_H
-/*
- * Kernel Hooks optimized for PPC.
- * 
- * Authors: Mike Grundy <grundym@us.ibm.com> s390x
- */
-#include <asm-generic/hook.h>
-
-#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
-
-#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
-#define _IF_HOOK_ENABLED(h, hk) \
-	register int tmp; \
-	__asm__ __volatile__ (".global "hk"; "hk":li %0, 0x00":"=r"(tmp)); \
-	if (unlikely(tmp))
-
-#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
-
-
-/*
- * Sanity check the hook location for valid instructions at hook location.
- * At hook location, we should find these instructions:
- *	38 00 00 00       	li    	r0,0
- *	2c 00 00 00            	cmpwi	r0,0
- *	
- * We can check for li and cmpwi instructions. As these instructions encode
- * the register name in the second byte and the register cannot be predicted, 
- * we mask out the bits corresponding to registers in the opcode before comparing.
- * PPC opcodes are six bits, hence mask of 0xFC
- */
-#define OPCODE_MOV1			0x38 /* LI (really an extended mnemonic for addi */   
-#define OPCODE_MOV1_MASK		0xFC
-/* Compiler generates 2c 00 00 00     cmpwi   r0,0 */
-		
-static inline int is_asm_hook(unsigned char * addr)
-{
-	if (!addr)
-		return 0;
-	
-	if((addr[0] & OPCODE_MOV1_MASK) == OPCODE_MOV1) {
-		if (*((unsigned short *)(addr+1)) == 0)
-			return 1;
-	}
-	return 0;
-}
-#endif /* __ASM_PPC_HOOK_H */
Index: linux-2.6.5/include/asm-ppc64/hook.h
===================================================================
--- linux-2.6.5.orig/include/asm-ppc64/hook.h
+++ /dev/null
@@ -1,47 +0,0 @@
-#ifndef __ASM_PPC_HOOK_H
-#define __ASM_PPC_HOOK_H
-/*
- * Kernel Hooks optimized for PPC64.
- * 
- * Authors: Mike Grundy <grundym@us.ibm.com> PPC64
- */
-#include <asm-generic/hook.h>
-
-#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
-
-#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
-#define _IF_HOOK_ENABLED(h, hk) \
-	register int tmp; \
-	__asm__ __volatile__ (".global "hk"; "hk":li %0, 0x00":"=r"(tmp)); \
-	if (unlikely(tmp))
-
-#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
-
-
-/*
- * Sanity check the hook location for valid instructions at hook location.
- * At hook location, we should find these instructions:
- *	38 00 00 00       	li    	r0,0
- *	2c 00 00 00            	cmpwi	r0,0
- *	
- * We can check for li and cmpwi instructions. As these instructions encode
- * the register name in the second byte and the register cannot be predicted, 
- * we mask out the bits corresponding to registers in the opcode before comparing.
- * PPC opcodes are six bits, hence mask of 0xFC
- */
-#define OPCODE_MOV1			0x38 /* LI (really an extended mnemonic for addi */   
-#define OPCODE_MOV1_MASK		0xFC
-/* Compiler generates 2c 00 00 00     cmpwi   r0,0 */
-		
-static inline int is_asm_hook(unsigned char * addr)
-{
-	if (!addr)
-		return 0;
-	
-	if((addr[0] & OPCODE_MOV1_MASK) == OPCODE_MOV1) {
-		if (*((unsigned short *)(addr+1)) == 0)
-			return 1;
-	}
-	return 0;
-}
-#endif /* __ASM_PPC_HOOK_H */
Index: linux-2.6.5/include/asm-s390/hook.h
===================================================================
--- linux-2.6.5.orig/include/asm-s390/hook.h
+++ /dev/null
@@ -1,49 +0,0 @@
-#ifndef __ASM_S390_HOOK_H
-#define __ASM_S390_HOOK_H
-/*
- * Kernel Hooks optimized for s390.
- * 
- * Authors: Mike Grundy <grundym@us.ibm.com> s390
- */
-#include <asm-generic/hook.h>
-
-#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
-
-#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
-#define _IF_HOOK_ENABLED(h, hk) \
-	register int tmp; \
-	__asm__ __volatile__ (".global "hk"; "hk":lhi %0, 0x00":"=r"(tmp)); \
-	if (unlikely(tmp))
-
-#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
-
-/*
- * Sanity check the hook location for valid instructions at hook location.
- * At hook location, we should find these instructions:
- *  a7 18 00 00             lhi     %r1,0
- *  12 11                   ltr     %r1,%r1
- * We can check for the lhi and ltr instructions. As the lhi instruction encodes
- * the register name in it, and we can't guarantee which register will be used,
- * we'll mask out the bits corresponding to the target register.
- */
-#define OPCODE_MOV2_1			0xa7 /* LHI first byte */
-#define OPCODE_MOV2_2			0x08 /* LHI second byte */
-#define OPCODE_MOV2_1_MASK		0xff
-#define OPCODE_MOV2_2_MASK		0x0f
-/* Compiler generates LTR opcode 12, but second op not tested */
-		
-static inline int is_asm_hook(unsigned char * addr)
-{
-	if (!addr){
-		return 0;
-	}
-	if (((addr[0] & OPCODE_MOV2_1_MASK) == OPCODE_MOV2_1) && 
-		    ((addr[1] & OPCODE_MOV2_2_MASK) == OPCODE_MOV2_2)) {
-		/* was checking a 32bit val, need to check 16, cheated with 8+8 */
-		if (addr[2]== 0 && addr[3]== 0){
-			return 1;
-		}
-	}
-	return 0;
-}
-#endif /* __ASM_S390_HOOK_H */
Index: linux-2.6.5/include/asm-s390x/hook.h
===================================================================
--- linux-2.6.5.orig/include/asm-s390x/hook.h
+++ /dev/null
@@ -1,49 +0,0 @@
-#ifndef __ASM_S390X_HOOK_H
-#define __ASM_S390X_HOOK_H
-/*
- * Kernel Hooks optimized for s390x(64bit).
- * 
- * Authors: Mike Grundy <grundym@us.ibm.com> s390x
- */
-#include <asm-generic/hook.h>
-
-#if defined(CONFIG_HOOK) || defined(CONFIG_HOOK_MODULE)
-
-#define IF_HOOK_ENABLED(h, hk) _IF_HOOK_ENABLED(h, #hk)
-#define _IF_HOOK_ENABLED(h, hk) \
-	register int tmp; \
-	__asm__ __volatile__ (".global "hk"; "hk":lhi %0, 0x00":"=r"(tmp)); \
-	if (unlikely(tmp))
-
-#endif /* CONFIG_HOOK || CONFIG_HOOK_MODULE */
-
-/*
- * Sanity check the hook location for valid instructions at hook location.
- * At hook location, we should find these instructions:
- *  a7 18 00 00             lhi     %r1,0
- *  12 11                   ltr     %r1,%r1
- * We can check for the lhi and ltr instructions. As the lhi instruction encodes
- * the register name in it, and we can't guarantee which register will be used,
- * we'll mask out the bits corresponding to the target register.
- */
-#define OPCODE_MOV2_1			0xa7 /* LHI first byte */
-#define OPCODE_MOV2_2			0x08 /* LHI second byte */
-#define OPCODE_MOV2_1_MASK		0xff
-#define OPCODE_MOV2_2_MASK		0x0f
-/* Compiler generates LTR opcode 12, but second op not tested */
-		
-static inline int is_asm_hook(unsigned char * addr)
-{
-	if (!addr){
-		return 0;
-	}
-	if (((addr[0] & OPCODE_MOV2_1_MASK) == OPCODE_MOV2_1) && 
-		    ((addr[1] & OPCODE_MOV2_2_MASK) == OPCODE_MOV2_2)) {
-		/* was checking a 32bit val, need to check 16, cheated with 8+8 */
-		if (addr[2]== 0 && addr[3]== 0){
-			return 1;
-		}
-	}
-	return 0;
-}
-#endif /* __ASM_S390X_HOOK_H */
Index: linux-2.6.5/include/linux/ltt.h
===================================================================
--- linux-2.6.5.orig/include/linux/ltt.h
+++ linux-2.6.5/include/linux/ltt.h
@@ -272,22 +272,13 @@ typedef struct _trace_syscall_entry {
 	u32 address;		/* Address from which call was made */
 } LTT_PACKED_STRUCT trace_syscall_entry;
 
 /*  TRACE_TRAP_ENTRY */
-#ifndef __s390__
 typedef struct _trace_trap_entry {
 	u16 trap_id;		/* Trap number */
 	u32 address;		/* Address where trap occured */
 } LTT_PACKED_STRUCT trace_trap_entry;
 static inline void TRACE_TRAP_ENTRY(u16 trap_id, u32 address)
-#else
-typedef u64 trapid_t;
-typedef struct _trace_trap_entry {
-	trapid_t trap_id;	/* Trap number */
-	u32 address;		/* Address where trap occured */
-} LTT_PACKED_STRUCT trace_trap_entry;
-static inline void TRACE_TRAP_ENTRY(trapid_t trap_id, u32 address)
-#endif
 {
 	trace_trap_entry trap_event;
 
 	trap_event.trap_id = trap_id;
Index: linux-2.6.5/include/linux/trigevent_hooks.h
===================================================================
--- linux-2.6.5.orig/include/linux/trigevent_hooks.h
+++ linux-2.6.5/include/linux/trigevent_hooks.h
@@ -96,10 +96,5 @@ extern void disable_post_syscall(void);
 #else
 #define TRIG_EVENT(name, ...)
 #endif /* CONFIG_TRIGEVENT_HOOKS */
 
-/* this needs to be done properly */
-#ifdef __s390__
-typedef uint64_t trapid_t;
-#endif
-
 #endif /* __LINUX_TRIGEVENT_HOOKS_H */
Index: linux-2.6.5/kernel/ltt/Makefile
===================================================================
--- linux-2.6.5.orig/kernel/ltt/Makefile
+++ linux-2.6.5/kernel/ltt/Makefile
@@ -7,25 +7,10 @@
 ltt_driver-objs	:= ltt-core.o ltt-core_hooks.o
 
 
 # Optional parts of multipart objects.
-ifeq ($(CONFIG_ARM),y)
-ltt_driver-objs	+= arm_syscall.o
-endif
 ifeq ($(CONFIG_X86),y)
 ltt_driver-objs	+= i386_syscall.o
 endif
-ifeq ($(CONFIG_MIPS32),y)
-ltt_driver-objs	+= mips_syscall.o
-endif
-ifeq ($(CONFIG_PPC32),y)
-ltt_driver-objs	+= ppc_syscall.o
-endif
-ifeq ($(CONFIG_ARCH_S390),y)
-ltt_driver-objs	+= s390_syscall.o
-endif
-ifeq ($(CONFIG_SUPERH),y)
-ltt_driver-objs	+= sh_syscall.o
-endif
 
 obj-$(CONFIG_LTT)	+= ltt_driver.o
 
Index: linux-2.6.5/kernel/ltt/arm_syscall.c
===================================================================
--- linux-2.6.5.orig/kernel/ltt/arm_syscall.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* arm */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{
-	int			scno = 0;
-	int			depth = 0;
-	unsigned long           end_code;
-	unsigned long		*fp;			/* frame pointer */
-	unsigned long		lower_bound;
-	unsigned long		lr;			/* link register */
-	unsigned long		*prev_fp;
-	int			seek_depth;
-	unsigned long           start_code;
-	unsigned long           *start_stack;
-	trace_syscall_entry	trace_syscall_event;
-	unsigned long		upper_bound;
-	int			use_bounds;
-	int			use_depth;
-
-	/* TODO: get_scno */
-	trace_syscall_event.syscall_id = (uint8_t)scno;
-	trace_syscall_event.address    = instruction_pointer(regs);
-	
-	if (! (user_mode(regs) ))
-		goto trace_syscall_end;
-
-	if (ltt_get_trace_config(&use_depth,
-			     &use_bounds,
-			     &seek_depth,
-			     (void*)&lower_bound,
-			     (void*)&upper_bound) < 0)
-		goto trace_syscall_end;
-
-	if ((use_depth == 1) || (use_bounds == 1)) {
-		fp          = (unsigned long *)regs->ARM_fp;
-		end_code    = current->mm->end_code;
-		start_code  = current->mm->start_code;
-		start_stack = (unsigned long *)current->mm->start_stack;
-
-		while (!__get_user(lr, (unsigned long *)(fp - 1))) {
-			if ((lr > start_code) && (lr < end_code)) {
-				if (((use_depth == 1) && (depth >= seek_depth)) ||
-				    ((use_bounds == 1) && (lr > lower_bound) && (lr < upper_bound))) {
-					trace_syscall_event.address = lr;
-					goto trace_syscall_end;
-				} else {
-					depth++;
-				}
-			}
-
-			if ((__get_user((unsigned long)prev_fp, (fp - 3))) ||
-			    (prev_fp > start_stack) ||
-			    (prev_fp <= fp)) {
-				goto trace_syscall_end;
-			}
-			fp = prev_fp;
-		}
-	}
-
-trace_syscall_end:
-	ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}
Index: linux-2.6.5/kernel/ltt/mips_syscall.c
===================================================================
--- linux-2.6.5.orig/kernel/ltt/mips_syscall.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* mips */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{
-	unsigned long       addr;
-	int                 depth = 0;
-	unsigned long       end_code;
-	unsigned long       lower_bound;
-	int                 seek_depth;
-	unsigned long       *stack;
-	unsigned long       start_code;
-	unsigned long       *start_stack;
-	trace_syscall_entry trace_syscall_event;
-	unsigned long       upper_bound;
-	int                 use_bounds;
-	int                 use_depth;
-
-	/* syscall_id will be negative for SVR4, IRIX5, BSD43, and POSIX
-	 * syscalls -- these are not supported at this point by LTT
-	 */
-	trace_syscall_event.syscall_id = (uint8_t) (regs->regs[2] - __NR_Linux);
-
-	trace_syscall_event.address  = regs->cp0_epc;
-
-	if (!user_mode(regs))
-		goto trace_syscall_end;
-
-	if (ltt_get_trace_config(&use_depth,
-			     &use_bounds,
-			     &seek_depth,
-			     (void*)&lower_bound,
-			     (void*)&upper_bound) < 0)
-		goto trace_syscall_end;
-
-	/* Heuristic that might work:
-	 * (BUT DOESN'T WORK for any of the cases I tested...) zzz
-	 * Search through stack until a value is found that is within the
-	 * range start_code .. end_code.  (This is looking for a return
-	 * pointer to where a shared library was called from.)  If a stack
-	 * variable contains a valid code address then an incorrect
-	 * result will be generated.
-	 */
-	if ((use_depth == 1) || (use_bounds == 1)) {
-		stack       = (unsigned long*) regs->regs[29];
-		end_code    = current->mm->end_code;
-		start_code  = current->mm->start_code;
-		start_stack = (unsigned long *)current->mm->start_stack;
-
-		while ((stack <= start_stack) && (!__get_user(addr, stack))) {
-			if ((addr > start_code) && (addr < end_code)) {
-				if (((use_depth  == 1) && (depth == seek_depth)) ||
-				    ((use_bounds == 1) && (addr > lower_bound) && (addr < upper_bound))) {
-					trace_syscall_event.address = addr;
-					goto trace_syscall_end;
-				} else {
-					depth++;
-				}
-			}
-		stack++;
-		}
-	}
-
-trace_syscall_end:
-	ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}
Index: linux-2.6.5/kernel/ltt/ppc_syscall.c
===================================================================
--- linux-2.6.5.orig/kernel/ltt/ppc_syscall.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* ppc */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{
-        int                 use_depth;
-	int                 use_bounds;
-	int                 depth = 0;
-        int                 seek_depth;
-        unsigned long       lower_bound;
-        unsigned long       upper_bound;
-	unsigned long       addr;
-	unsigned long*      stack;
-	trace_syscall_entry trace_syscall_event;
-
-        /* Set the syscall ID */
-	trace_syscall_event.syscall_id = (uint8_t) regs->gpr[0];
-
-	/* Set the address in any case */
-	trace_syscall_event.address  = instruction_pointer(regs);
-
-	/* Are we in the kernel (This is a kernel thread)? */
-	if(!user_mode(regs))
-	  /* Don't go digining anywhere */
-	  goto trace_syscall_end;
-
-	/* Get the trace configuration */
-	if(ltt_get_trace_config(&use_depth,
-			    &use_bounds,
-			    &seek_depth,
-			    (void*)&lower_bound,
-			    (void*)&upper_bound) < 0)
-	  goto trace_syscall_end;
-
-	/* Do we have to search for an eip address range */
-	if((use_depth == 1) || (use_bounds == 1))
-	  {
-	  /* Start at the top of the stack (bottom address since stacks grow downward) */
-	  stack = (unsigned long*) regs->gpr[1];
-
-	  /* Skip over first stack frame as the return address isn't valid */
-	  if(get_user(addr, stack))
-	    goto trace_syscall_end;
-	  stack = (unsigned long*) addr;
-
-	  /* Keep on going until we reach the end of the process' stack limit (wherever it may be) */
-	  while(!get_user(addr, stack + 1)) /* "stack + 1", since this is where the IP is */
-	    {
-	    /* Does this LOOK LIKE an address in the program */
-	    if((addr > current->mm->start_code)
-             &&(addr < current->mm->end_code))
-	      {
-	      /* Does this address fit the description */
-	      if(((use_depth == 1) && (depth == seek_depth))
-               ||((use_bounds == 1) && (addr > lower_bound) && (addr < upper_bound)))
-		{
-		/* Set the address */
-		trace_syscall_event.address = addr;
-
-		/* We're done */
-		goto trace_syscall_end;
-		}
-	      else
-		/* We're one depth more */
-		depth++;
-	      }
-	    /* Go on to the next address */
-	    if(get_user(addr, stack))
-	      goto trace_syscall_end;
-	    stack = (unsigned long*) addr;
-	    }
-	  }
-
-trace_syscall_end:
-	/* Trace the event */
-	ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}
Index: linux-2.6.5/kernel/ltt/s390_syscall.c
===================================================================
--- linux-2.6.5.orig/kernel/ltt/s390_syscall.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* s390 */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{                                                              
-	int		    use_depth;	                 
-        int                 use_bounds;                        
-        int                 depth = 0;                         
-        int                 seek_depth;                        
-        unsigned long       lower_bound;                       
-        unsigned long       upper_bound;                       
-        unsigned long       addr;                              
-        unsigned long*      stack;
-        unsigned long       temp_stack;
-        trace_syscall_entry trace_syscall_event;               
-        /* Set the syscall ID                               */ 
-        /* Register 8 is setup just prior to the call       */ 
-        /* This instruction is just following linkage       */ 
-        /* so it's ok.  If moved and chance of R8 being     */ 
-        /* clobbered, would need to dig it out of the stack */ 
-        __asm__ volatile(                                      
-        "  stc  8,%0\n\t"                                      
-        : "=m" (trace_syscall_event.syscall_id));              
-        /* get the psw address */                              
-        trace_syscall_event.address  = regs->psw.addr;         
-        /* and off the hi-order bit */                                          
-        trace_syscall_event.address &= PSW_ADDR_INSN;                           
-        if(!(user_mode(regs))) /* if kernel mode, return */                     
-           goto trace_syscall_end;                                              
-        /* Get the trace configuration - if none, return */                     
-        if(ltt_get_trace_config(&use_depth,                                         
-                            &use_bounds,                                        
-                            &seek_depth,                                        
-                            (void*)&lower_bound,                                
-                            (void*)&upper_bound) < 0)                           
-          goto trace_syscall_end;                                               
-        /* Do we have to search for an instruction pointer address range */     
-        if((use_depth == 1) || (use_bounds == 1))                               
-        {                                                                       
-          /* Start at the top of the stack */                                   
-          /* stack pointer is register 15 */                                    
-          stack = (unsigned long*) regs->gprs[15]; /* stack pointer */      
-          /* Keep on going until we reach the end of the process' stack limit */
-          do
-          {
-            get_user(addr,stack+14);  /* get the program address +0x38 */ 
-            /* and off the hi-order bit */
-            addr &= PSW_ADDR_INSN;                                
-            /* Does this LOOK LIKE an address in the program */
-            if ((addr > current->mm->start_code)               
-               &&(addr < current->mm->end_code))               
-            { 
-              /* Does this address fit the description */      
-              if(((use_depth == 1) && (depth == seek_depth))   
-                ||((use_bounds == 1) && (addr > lower_bound)   
-                && (addr < upper_bound)))
-                {
-                  /* Set the address */   
-                  trace_syscall_event.address = addr; 
-                  /* We're done */                             
-                  goto trace_syscall_end;                      
-                }                                              
-              else                                             
-                /* We're one depth more */                     
-                depth++; 
-            }
-            /* Go on to the next address */
-            get_user(temp_stack,stack); /* get contents of stack */
-            temp_stack &= PSW_ADDR_INSN; /* and off hi order bit */
-            stack = (unsigned long *)temp_stack; /* move into stack */
-            /* stack may or may not go to zero when end hit               */
-            /* using 0x7fffffff-_STK_LIM to validate that the address is  */
-            /* within the range of a valid stack address                  */
-            /* If outside that range, exit the loop, stack end must have  */
-            /* been hit.                                                  */
-          } while (stack >= (unsigned long *)(0x7fffffff-_STK_LIM));
-        }                                                         
-trace_syscall_end:                                                
-        /* Trace the event */                                     
-        ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}                                                                 
Index: linux-2.6.5/kernel/ltt/sh_syscall.c
===================================================================
--- linux-2.6.5.orig/kernel/ltt/sh_syscall.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * drivers/trace/xxx_syscall.c
- *
- * This code is distributed under the GPL license
- *
- * System call tracing.
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/sched.h>
-#include <asm/uaccess.h>
-#include <linux/ltt.h>
-
-/* sh */
-asmlinkage void ltt_pre_syscall(struct pt_regs * regs)
-{
-	int                 use_depth;
-	int                 use_bounds;
-	int                 depth = 0;
-	int                 seek_depth;
-	unsigned long       lower_bound;
-	unsigned long       upper_bound;
-	unsigned long       addr;
-	unsigned long*      stack;
-	trace_syscall_entry trace_syscall_event;
-
-	/* Set the syscall ID */
-	trace_syscall_event.syscall_id = (uint8_t) regs->regs[REG_REG0+3];
-
-	/* Set the address in any case */
-	trace_syscall_event.address  = regs->pc;
-
-	/* Are we in the kernel (This is a kernel thread)? */
-	if(!user_mode(regs))
-		/* Don't go digining anywhere */
-		goto trace_syscall_end;
-
-	/* Get the trace configuration */
-	if(ltt_get_trace_config(&use_depth, &use_bounds, &seek_depth,
-	   (void*)&lower_bound, (void*)&upper_bound) < 0)
-		goto trace_syscall_end;
-
-	/* Do we have to search for an eip address range */
-	if((use_depth == 1) || (use_bounds == 1))
-	{
-		/* Start at the top of the stack (bottom address since stacks grow downward) */
-		stack = (unsigned long*) regs->regs[REG_REG15];
-
-		/* Keep on going until we reach the end of the process' stack limit (wherever it may be) */
-		while(!get_user(addr, stack))
-		{
-			/* Does this LOOK LIKE an address in the program */
-			/* TODO: does this work with shared libraries?? - Greg Banks */
-			if((addr > current->mm->start_code) &&(addr < current->mm->end_code))
-			{
-				/* Does this address fit the description */
-				if(((use_depth == 1) && (depth == seek_depth))
-				   ||((use_bounds == 1) && (addr > lower_bound)
-				   && (addr < upper_bound)))
-				{
-					/* Set the address */
-					trace_syscall_event.address = addr;
-
-					/* We're done */
-					goto trace_syscall_end;
-				}
-				else
-					/* We're one depth more */
-					depth++;
-			}
-			/* Go on to the next address */
-			stack++;
-		}
-	}
-
-trace_syscall_end:
-	/* Trace the event */
-	ltt_log_event(TRACE_EV_SYSCALL_ENTRY, &trace_syscall_event);
-}
