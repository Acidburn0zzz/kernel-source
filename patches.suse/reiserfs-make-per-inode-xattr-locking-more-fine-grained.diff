From: Jeff Mahoney <jeffm@suse.com>
Subject: reiserfs: make per-inode xattr locking more fine grained

 The per-inode locking can be made more fine-grained to surround just the
 interaction with the filesystem itself. This really only applies to protecting
 reads during a write, since concurrent writes are barred with inode->i_mutex
 at the vfs level.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

--
 fs/reiserfs/inode.c            |    2 
 fs/reiserfs/xattr.c            |  172 ++++++++++++++++++++---------------------
 fs/reiserfs/xattr_acl.c        |    7 -
 include/linux/reiserfs_fs_i.h  |    3 
 include/linux/reiserfs_xattr.h |   26 ------
 5 files changed, 88 insertions(+), 122 deletions(-)

--- a/fs/reiserfs/inode.c	2008-03-14 17:14:42.000000000 -0400
+++ b/fs/reiserfs/inode.c	2008-03-14 17:15:33.000000000 -0400
@@ -1131,7 +1131,6 @@ static void init_inode(struct inode *ino
 	mutex_init(&(REISERFS_I(inode)->i_mmap));
 	reiserfs_init_acl_access(inode);
 	reiserfs_init_acl_default(inode);
-	reiserfs_init_xattr_rwsem(inode);
 
 	if (stat_data_v1(ih)) {
 		struct stat_data_v1 *sd =
@@ -1827,7 +1826,6 @@ int reiserfs_new_inode(struct reiserfs_t
 	mutex_init(&(REISERFS_I(inode)->i_mmap));
 	reiserfs_init_acl_access(inode);
 	reiserfs_init_acl_default(inode);
-	reiserfs_init_xattr_rwsem(inode);
 
 	if (old_format_only(sb))
 		make_le_item_head(&ih, NULL, KEY_FORMAT_3_5, SD_OFFSET,
--- a/fs/reiserfs/xattr.c	2008-03-14 17:14:42.000000000 -0400
+++ b/fs/reiserfs/xattr.c	2008-03-14 18:01:08.000000000 -0400
@@ -29,10 +29,8 @@
  * to the inode so that unnecessary lookups are avoided.
  *
  * Locking works like so:
- * The xattr root (/.reiserfs_priv/xattrs) is protected by its i_mutex.
- * The xattr dir (/.reiserfs_priv/xattrs/<oid>.<gen>) is protected by
- * inode->xattr_sem.
- * The xattrs themselves are likewise protected by the xattr_sem.
+ * Every component (xattr root, xattr dir, and the xattrs themselves) are
+ * protected by their i_mutex.
  */
 
 #include <linux/reiserfs_fs.h>
@@ -60,14 +58,15 @@ static struct reiserfs_xattr_handler *fi
 
 #define xattr_may_create(flags)	(!flags || flags & XATTR_CREATE)
 
+/* Returns and possibly creates the xattr dir.
+ * expects parent->d_inode->i_mutex to be locked and doesn't alter it
+ * dentry->d_inode->i_mutex is locked on success */
 static struct dentry *lookup_or_create_dir(struct dentry *parent,
 					    const char *name, int flags)
 {
 	struct dentry *dentry;
 	BUG_ON(!parent);
 
-	mutex_lock_nested(&parent->d_inode->i_mutex, I_MUTEX_XATTR);
-
 	dentry = lookup_one_len(name, parent, strlen(name));
 	if (IS_ERR(dentry)) {
 		mutex_unlock(&parent->d_inode->i_mutex);
@@ -84,40 +83,58 @@ static struct dentry *lookup_or_create_d
 		}
 	}
 
-	mutex_unlock(&parent->d_inode->i_mutex);
+	if (!IS_ERR(dentry))
+		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
+
 	return dentry;
 }
 
+/* returns locked dentry */
 static struct dentry *open_xa_root(struct super_block *sb, int flags)
 {
 	struct dentry *privroot = REISERFS_SB(sb)->priv_root;
+	struct dentry *xaroot;
 	if (!privroot)
 		return ERR_PTR(-ENODATA);
-	return lookup_or_create_dir(privroot, XAROOT_NAME, flags);
+	mutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);
+	xaroot = lookup_or_create_dir(privroot, XAROOT_NAME, flags);
+	mutex_unlock(&privroot->d_inode->i_mutex);
+	return xaroot;
 }
 
+/* opens the xa dir. expects xaroot to be locked and doesn't alter it */
+/* returns locked dentry */
+static struct dentry *__open_xa_dir(const struct inode *inode,
+				    struct dentry *xaroot, int flags)
+{
+	char namebuf[17];
+
+	snprintf(namebuf, sizeof(namebuf), "%X.%X",
+		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
+		 inode->i_generation);
+
+	return lookup_or_create_dir(xaroot, namebuf, flags);
+}
+
+/* returns locked dentry */
 static struct dentry *open_xa_dir(const struct inode *inode, int flags)
 {
 	struct dentry *xaroot, *xadir;
-	char namebuf[17];
 
 	xaroot = open_xa_root(inode->i_sb, flags);
 	if (IS_ERR(xaroot))
 		return xaroot;
 
-	snprintf(namebuf, sizeof(namebuf), "%X.%X",
-		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
-		 inode->i_generation);
-
-	xadir = lookup_or_create_dir(xaroot, namebuf, flags);
+	xadir = __open_xa_dir(inode, xaroot, flags);
+	mutex_unlock(&xaroot->d_inode->i_mutex);
 	dput(xaroot);
 	return xadir;
-
 }
 
 /* Returns a dentry corresponding to a specific extended attribute file
  * for the inode. If flags allow, the file is created. Otherwise, a
  * valid or negative dentry, or an error is returned. */
+/* returns a locked dentry */
 static struct dentry *get_xa_file_dentry(const struct inode *inode,
 					 const char *name, int flags)
 {
@@ -128,12 +145,9 @@ static struct dentry *get_xa_file_dentry
 	if (IS_ERR(xadir))
 		return ERR_CAST(xadir);
 
-	mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
 	xafile = lookup_one_len(name, xadir, strlen(name));
-	if (IS_ERR(xafile)) {
-		err = PTR_ERR(xafile);
+	if (IS_ERR(xafile))
 		goto out;
-	}
 
 	if (xafile->d_inode && (flags & XATTR_CREATE))
 		err = -EEXIST;
@@ -148,7 +162,6 @@ static struct dentry *get_xa_file_dentry
 	if (err)
 		dput(xafile);
 out:
-	mutex_unlock(&xadir->d_inode->i_mutex);
 	dput(xadir);
 	if (err)
 		return ERR_PTR(err);
@@ -317,13 +330,11 @@ static
 int xattr_readdir(struct inode *inode, filldir_t filler, void *buf)
 {
 	int res = -ENOENT;
-	mutex_lock_nested(&inode->i_mutex, I_MUTEX_XATTR);
 	if (!IS_DEADDIR(inode)) {
 		lock_kernel();
 		res = __xattr_readdir(inode, buf, filler);
 		unlock_kernel();
 	}
-	mutex_unlock(&inode->i_mutex);
 	return res;
 }
 
@@ -388,9 +399,8 @@ reiserfs_xattr_set(struct inode *inode,
 	if (get_inode_sd_version(inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	/* Empty xattrs are ok, they're just empty files, no hash */
-	if (buffer && buffer_size)
-		xahash = xattr_hash(buffer, buffer_size);
+	if (!buffer)
+		return reiserfs_xattr_del(inode, name);
 
       open_file:
 	dentry = get_xa_file_dentry(inode, name, flags);
@@ -399,6 +409,7 @@ reiserfs_xattr_set(struct inode *inode,
 		goto out;
 	}
 
+	xahash = xattr_hash(buffer, buffer_size);
 	xinode = dentry->d_inode;
 	REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
@@ -411,13 +422,13 @@ reiserfs_xattr_set(struct inode *inode,
 		/* We just killed the old one, we're not replacing anymore */
 		if (flags & XATTR_REPLACE)
 			flags &= ~XATTR_REPLACE;
+		mutex_unlock(&dentry->d_inode->i_mutex);
 		goto open_file;
 	}
 
 	/* Resize it so we're ok to write there */
 	newattrs.ia_size = buffer_size;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
-	mutex_lock_nested(&xinode->i_mutex, I_MUTEX_XATTR);
 	err = notify_change(dentry, &newattrs);
 	if (err)
 		goto out_filp;
@@ -523,12 +534,12 @@ reiserfs_xattr_get(const struct inode *i
 	/* Just return the size needed */
 	if (buffer == NULL) {
 		err = isize - sizeof(struct reiserfs_xattr_header);
-		goto out_dput;
+		goto out_unlock;
 	}
 
 	if (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {
 		err = -ERANGE;
-		goto out_dput;
+		goto out_unlock;
 	}
 
 	while (file_pos < isize) {
@@ -543,7 +554,7 @@ reiserfs_xattr_get(const struct inode *i
 		page = reiserfs_get_page(xinode, file_pos >> PAGE_CACHE_SHIFT);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
-			goto out_dput;
+			goto out_unlock;
 		}
 
 		lock_page(page);
@@ -562,7 +573,7 @@ reiserfs_xattr_get(const struct inode *i
 						 "associated with %k", name,
 						 INODE_PKEY(inode));
 				err = -EIO;
-				goto out_dput;
+				goto out_unlock;
 			}
 			hash = le32_to_cpu(rxh->h_hash);
 		}
@@ -583,19 +594,22 @@ reiserfs_xattr_get(const struct inode *i
 		err = -EIO;
 	}
 
-      out_dput:
+out_unlock:
+	mutex_unlock(&dentry->d_inode->i_mutex);
 	dput(dentry);
 
-      out:
+out:
 	return err;
 }
 
+/* expects xadir->d_inode->i_mutex to be locked */
 static int
 __reiserfs_xattr_del(struct dentry *xadir, const char *name, int namelen)
 {
 	struct dentry *dentry;
 	struct inode *dir = xadir->d_inode;
 	int err = 0;
+	struct reiserfs_xattr_handler *xah;
 
 	dentry = lookup_one_len(name, xadir, namelen);
 	if (IS_ERR(dentry)) {
@@ -623,6 +637,14 @@ __reiserfs_xattr_del(struct dentry *xadi
 		return -EIO;
 	}
 
+	/* Deletion pre-operation */
+	xah = find_xattr_handler_prefix(name);
+	if (xah && xah->del) {
+		err = xah->del(dentry->d_inode, name);
+		if (err)
+			goto out;
+	}
+
 	err = vfs_unlink(xadir->d_inode, dentry);
 
       out_file:
@@ -644,6 +666,7 @@ int reiserfs_xattr_del(struct inode *ino
 	}
 
 	err = __reiserfs_xattr_del(dir, name, strlen(name));
+	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(dir);
 
 	if (!err) {
@@ -681,42 +704,42 @@ int reiserfs_delete_xattrs(struct inode
 	    !reiserfs_xattrs(inode->i_sb)) {
 		return 0;
 	}
-	dir = open_xa_dir(inode, XATTR_REPLACE);
+
+	/* root becomes locked */
+	root = open_xa_root(inode->i_sb, XATTR_REPLACE);
+	if (IS_ERR(root)) {
+		err = PTR_ERR(root);
+		goto out;
+	}
+
+	/* dir becomes locked */
+	dir = __open_xa_dir(inode, root, XATTR_REPLACE);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
-		goto out;
-	} else if (!dir->d_inode) {
-		dput(dir);
-		return 0;
+		goto out_unlock;
 	}
 
-	lock_kernel();
 	err = xattr_readdir(dir->d_inode, reiserfs_delete_xattrs_filler, dir);
-	if (err) {
-		unlock_kernel();
+	mutex_unlock(&dir->d_inode->i_mutex);
+	if (err)
 		goto out_dir;
-	}
 
-	/* Leftovers besides . and .. -- that's not good. */
-	if (dir->d_inode->i_nlink <= 2) {
-		root = open_xa_root(inode->i_sb, XATTR_REPLACE);
-		mutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_XATTR);
-		err = vfs_rmdir(root->d_inode, dir);
-		mutex_unlock(&root->d_inode->i_mutex);
-		dput(root);
-	} else {
-		reiserfs_warning(inode->i_sb, "jdm-20004",
-				 "Couldn't remove all entries in directory");
-	}
-	unlock_kernel();
+	err = vfs_rmdir(root->d_inode, dir);
 
-      out_dir:
+out_dir:
 	dput(dir);
 
-      out:
+out_unlock:
+	mutex_unlock(&root->d_inode->i_mutex);
+	dput(root);
+
+out:
 	if (!err)
 		REISERFS_I(inode)->i_flags =
 		    REISERFS_I(inode)->i_flags & ~i_has_xattr_dir;
+	else
+		reiserfs_warning(inode->i_sb, "jdm-20004",
+		                 "Couldn't remove some xattrs (%d)\n", err);
 	return err;
 }
 
@@ -764,17 +787,14 @@ int reiserfs_chown_xattrs(struct inode *
 	    !reiserfs_xattrs(inode->i_sb)) {
 		return 0;
 	}
+
 	dir = open_xa_dir(inode, XATTR_REPLACE);
 	if (IS_ERR(dir)) {
 		if (PTR_ERR(dir) != -ENODATA)
 			err = PTR_ERR(dir);
 		goto out;
-	} else if (!dir->d_inode) {
-		dput(dir);
-		goto out;
 	}
 
-	lock_kernel();
 
 	attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
 	buf.xadir = dir;
@@ -782,19 +802,20 @@ int reiserfs_chown_xattrs(struct inode *
 	buf.inode = inode;
 
 	err = xattr_readdir(dir->d_inode, reiserfs_chown_xattrs_filler, &buf);
-	if (err) {
-		unlock_kernel();
+	if (err)
 		goto out_dir;
-	}
 
 	err = notify_change(dir, attrs);
-	unlock_kernel();
 
       out_dir:
+	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(dir);
 
       out:
 	attrs->ia_valid = ia_valid;
+	if (err)
+		reiserfs_warning(inode->i_sb, "jdm-20005",
+				 "Couldn't chown all xattrs (%d)\n", err);
 	return err;
 }
 
@@ -814,9 +835,7 @@ reiserfs_getxattr(struct dentry * dentry
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	reiserfs_read_lock_xattr_i(dentry->d_inode);
 	err = xah->get(dentry->d_inode, name, buffer, size);
-	reiserfs_read_unlock_xattr_i(dentry->d_inode);
 	return err;
 }
 
@@ -836,9 +855,7 @@ reiserfs_setxattr(struct dentry *dentry,
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	reiserfs_write_lock_xattr_i(dentry->d_inode);
 	err = xah->set(dentry->d_inode, name, value, size, flags);
-	reiserfs_write_unlock_xattr_i(dentry->d_inode);
 	return err;
 }
 
@@ -856,21 +873,11 @@ int reiserfs_removexattr(struct dentry *
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	reiserfs_write_lock_xattr_i(dentry->d_inode);
-	/* Deletion pre-operation */
-	if (xah->del) {
-		err = xah->del(dentry->d_inode, name);
-		if (err)
-			goto out;
-	}
-
 	err = reiserfs_xattr_del(dentry->d_inode, name);
 
 	dentry->d_inode->i_ctime = CURRENT_TIME_SEC;
 	mark_inode_dirty(dentry->d_inode);
 
-      out:
-	reiserfs_write_unlock_xattr_i(dentry->d_inode);
 	return err;
 }
 
@@ -932,7 +939,6 @@ ssize_t reiserfs_listxattr(struct dentry
 	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	reiserfs_read_lock_xattr_i(dentry->d_inode);
 	dir = open_xa_dir(dentry->d_inode, XATTR_REPLACE);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
@@ -957,11 +963,11 @@ ssize_t reiserfs_listxattr(struct dentry
 	else
 		err = buf.r_pos;
 
-      out_dir:
+out_dir:
+        mutex_unlock(&dir->d_inode->i_mutex);
 	dput(dir);
 
-      out:
-	reiserfs_read_unlock_xattr_i(dentry->d_inode);
+out:
 	return err;
 }
 
@@ -1165,12 +1171,8 @@ static int reiserfs_check_acl(struct ino
 	struct posix_acl *acl;
 	int error = -EAGAIN; /* do regular unix permission checks by default */
 
-	reiserfs_read_lock_xattr_i(inode);
-
 	acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
 
-	reiserfs_read_unlock_xattr_i(inode);
-
 	if (acl) {
 		if (!IS_ERR(acl)) {
 			error = posix_acl_permission(inode, acl, mask);
--- a/fs/reiserfs/xattr_acl.c	2008-03-14 17:14:42.000000000 -0400
+++ b/fs/reiserfs/xattr_acl.c	2008-03-14 17:15:33.000000000 -0400
@@ -418,9 +418,7 @@ int reiserfs_cache_default_acl(struct in
 	int ret = 0;
 	if (reiserfs_posixacl(inode->i_sb) && !is_reiserfs_priv_object(inode)) {
 		struct posix_acl *acl;
-		reiserfs_read_lock_xattr_i(inode);
 		acl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);
-		reiserfs_read_unlock_xattr_i(inode);
 		ret = (acl && !IS_ERR(acl));
 		if (ret)
 			posix_acl_release(acl);
@@ -452,11 +450,8 @@ int reiserfs_acl_chmod(struct inode *ino
 	if (!clone)
 		return -ENOMEM;
 	error = posix_acl_chmod_masq(clone, inode->i_mode);
-	if (!error) {
-		reiserfs_write_lock_xattr_i(inode);
+	if (!error)
 		error = reiserfs_set_acl(inode, ACL_TYPE_ACCESS, clone);
-		reiserfs_write_unlock_xattr_i(inode);
-	}
 	posix_acl_release(clone);
 	return error;
 }
--- a/include/linux/reiserfs_fs_i.h	2008-03-14 17:12:45.000000000 -0400
+++ b/include/linux/reiserfs_fs_i.h	2008-03-14 17:15:33.000000000 -0400
@@ -58,9 +58,6 @@ struct reiserfs_inode_info {
 	struct posix_acl *i_acl_access;
 	struct posix_acl *i_acl_default;
 #endif
-#ifdef CONFIG_REISERFS_FS_XATTR
-	struct rw_semaphore xattr_sem;
-#endif
 	struct inode vfs_inode;
 };
 
--- a/include/linux/reiserfs_xattr.h	2008-03-14 17:14:42.000000000 -0400
+++ b/include/linux/reiserfs_xattr.h	2008-03-14 17:15:33.000000000 -0400
@@ -68,34 +68,12 @@ extern struct reiserfs_xattr_handler sec
 int reiserfs_xattr_register_handlers(void) __init;
 void reiserfs_xattr_unregister_handlers(void);
 
-static inline void reiserfs_write_lock_xattr_i(struct inode *inode)
-{
-	down_write(&REISERFS_I(inode)->xattr_sem);
-}
-static inline void reiserfs_write_unlock_xattr_i(struct inode *inode)
-{
-	up_write(&REISERFS_I(inode)->xattr_sem);
-}
-static inline void reiserfs_read_lock_xattr_i(struct inode *inode)
-{
-	down_read(&REISERFS_I(inode)->xattr_sem);
-}
-
-static inline void reiserfs_read_unlock_xattr_i(struct inode *inode)
-{
-	up_read(&REISERFS_I(inode)->xattr_sem);
-}
 
 static inline void reiserfs_mark_inode_private(struct inode *inode)
 {
 	inode->i_flags |= S_PRIVATE;
 }
 
-static inline void reiserfs_init_xattr_rwsem(struct inode *inode)
-{
-	init_rwsem(&REISERFS_I(inode)->xattr_sem);
-}
-
 #else
 
 #define is_reiserfs_priv_object(inode) 0
@@ -104,10 +82,6 @@ static inline void reiserfs_init_xattr_r
 #define reiserfs_setxattr NULL
 #define reiserfs_listxattr NULL
 #define reiserfs_removexattr NULL
-#define reiserfs_write_lock_xattrs(sb) do {;} while(0)
-#define reiserfs_write_unlock_xattrs(sb) do {;} while(0)
-#define reiserfs_read_lock_xattrs(sb)
-#define reiserfs_read_unlock_xattrs(sb)
 
 #define reiserfs_permission NULL
 
