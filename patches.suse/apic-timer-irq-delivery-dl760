garloff@suse.de

Workaround

On HP Proliant DL740 G1 / DL760 G2, the timer IRQ is sent to all CPUs,
but should only be sent to one. This causes time warps.
Probably it's a bug in the MP-BIOS as well as the ACPI tables, but we
can work around ...

diff -uNrp linux-2.6.5/arch/i386/kernel/dmi_scan.c linux-2.6.5.Proliant/arch/i386/kernel/dmi_scan.c
--- linux-2.6.5/arch/i386/kernel/dmi_scan.c	2004-06-11 21:33:02.000000000 +0200
+++ linux-2.6.5.Proliant/arch/i386/kernel/dmi_scan.c	2004-06-11 18:23:56.000000000 +0200
@@ -21,6 +21,7 @@ EXPORT_SYMBOL(i8042_dmi_noloop);
 int is_sony_vaio_laptop;
 int is_unsafe_smbus;
 int es7000_plat = 0;
+int need_timer_irq_tweak;
 
 struct dmi_header
 {
@@ -508,6 +509,17 @@ static __init int init_ints_after_s1(str
 	return 0;
 }
 
+/*
+ * HP Proliants DL740/760 need to tweak the IRQ delivery mode for timer IRQ
+ */
+
+static __init int enable_timer_irq_tweak(struct dmi_blacklist *d)
+{
+	printk(KERN_WARNING "Enable tweak for timer IRQ delivery/dest mode.\n");
+	need_timer_irq_tweak = 1;
+	return 0;
+}
+
 #ifdef CONFIG_ACPI_SLEEP
 static __init int reset_videomode_after_s3(struct dmi_blacklist *d)
 {
@@ -1081,6 +1093,21 @@ static __initdata struct dmi_blacklist d
 			NO_MATCH, NO_MATCH }},
 #endif	// CONFIG_ACPI_BOOT
 
+	/*
+	 * Boxes that need to set delivery and dest mode of timer 
+	 * IRQ to 0 to not recieve timer IRQs multiple times.
+	 */
+
+	{ enable_timer_irq_tweak, "HP ProLiant DL740", {
+			MATCH(DMI_BIOS_VENDOR, "HP"),
+			MATCH(DMI_BIOS_VERSION, "P47-"),
+			NO_MATCH, NO_MATCH }},
+
+	{ enable_timer_irq_tweak, "HP ProLiant DL760 G2", {
+			MATCH(DMI_BIOS_VENDOR, "HP"),
+			MATCH(DMI_BIOS_VERSION, "P44-"),
+			NO_MATCH, NO_MATCH }},
+
 #ifdef	CONFIG_ACPI_PCI
 
 	{ hp_ht_bigsmp, "HP ProLiant DL760 G2", {
diff -uNrp linux-2.6.5/arch/i386/kernel/io_apic.c linux-2.6.5.Proliant/arch/i386/kernel/io_apic.c
--- linux-2.6.5/arch/i386/kernel/io_apic.c	2004-06-11 21:33:02.000000000 +0200
+++ linux-2.6.5.Proliant/arch/i386/kernel/io_apic.c	2004-06-11 21:47:16.000000000 +0200
@@ -61,6 +61,9 @@ int sis_apic_bug = -1;
  */
 int nr_ioapic_registers[MAX_IO_APICS];
 
+/* Set by dmi_scan */
+extern int need_timer_irq_tweak;
+
 /*
  * Rough estimation of how many shared IRQs there are, can
  * be changed anytime.
@@ -1282,6 +1285,12 @@ void __init setup_IO_APIC_irqs(void)
 			if (!apic && (irq < 16))
 				disable_8259A_irq(irq);
 		}
+		/* Timer interrupt */
+		if (need_timer_irq_tweak && irq == 0) {
+			entry.delivery_mode = 0;
+			entry.dest_mode = 0;
+			printk("Timer IRQ delivery and dest mode set to 0\n");
+		}
 		spin_lock_irqsave(&ioapic_lock, flags);
 		io_apic_write(apic, 0x11+2*pin, *(((int *)&entry)+1));
 		io_apic_write(apic, 0x10+2*pin, *(((int *)&entry)+0));
@@ -1320,6 +1329,12 @@ void __init setup_ExtINT_IRQ0_pin(unsign
 	entry.trigger = 0;
 	entry.vector = vector;
 
+	if (need_timer_irq_tweak) {
+		entry.delivery_mode = 0;
+		entry.dest_mode = 0;
+		printk("ExtINT_IRQ0_pin: delivery and dest mode set to 0\n");
+	}
+
 	/*
 	 * The timer IRQ doesn't have to know that behind the
 	 * scene we have a 8259A-master in AEOI mode ...
