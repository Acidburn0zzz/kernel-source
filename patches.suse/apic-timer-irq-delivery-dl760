diff -uNrp linux-2.6.5/arch/i386/kernel/dmi_scan.c linux-2.6.5.DL740/arch/i386/kernel/dmi_scan.c
--- linux-2.6.5/arch/i386/kernel/dmi_scan.c	2004-06-05 14:43:39.000000000 +0200
+++ linux-2.6.5.DL740/arch/i386/kernel/dmi_scan.c	2004-06-05 14:48:08.000000000 +0200
@@ -21,6 +21,7 @@ EXPORT_SYMBOL(i8042_dmi_noloop);
 int is_sony_vaio_laptop;
 int is_unsafe_smbus;
 int es7000_plat = 0;
+int need_timer_irq_tweak;
 
 struct dmi_header
 {
@@ -508,6 +509,17 @@ static __init int init_ints_after_s1(str
 	return 0;
 }
 
+/*
+ * HP Proliants DL740/760 need to tweak the IRQ delivery mode for timer IRQ
+ */
+
+static __init int enable_timer_irq_tweak(struct dmi_blacklist *d)
+{
+	printk(KERN_WARNING "Enable tweak for timer IRQ delivery/dest mode.\n");
+	need_timer_irq_tweak = 1;
+	return 0;
+}
+
 #ifdef CONFIG_ACPI_SLEEP
 static __init int reset_videomode_after_s3(struct dmi_blacklist *d)
 {
@@ -1081,6 +1093,21 @@ static __initdata struct dmi_blacklist d
 			NO_MATCH, NO_MATCH }},
 #endif	// CONFIG_ACPI_BOOT
 
+	/*
+	 * Boxes that need to set delivery and dest mode of timer 
+	 * IRQ to 0 to not recieve timer IRQs multiple times.
+	 */
+
+	{ enable_timer_irq_tweak, "HP ProLiant DL740", {
+			MATCH(DMI_BIOS_VENDOR, "HP"),
+			MATCH(DMI_BIOS_VERSION, "P47-"),
+			NO_MATCH, NO_MATCH }},
+
+	{ enable_timer_irq_tweak, "HP ProLiant DL760 G2", {
+			MATCH(DMI_BIOS_VENDOR, "HP"),
+			MATCH(DMI_BIOS_VERSION, "P44-"),
+			NO_MATCH, NO_MATCH }},
+
 #ifdef	CONFIG_ACPI_PCI
 
 	{ hp_ht_bigsmp, "HP ProLiant DL760 G2", {
diff -uNrp linux-2.6.5/arch/i386/kernel/io_apic.c linux-2.6.5.DL740/arch/i386/kernel/io_apic.c
--- linux-2.6.5/arch/i386/kernel/io_apic.c	2004-06-05 14:43:23.000000000 +0200
+++ linux-2.6.5.DL740/arch/i386/kernel/io_apic.c	2004-06-05 14:44:19.000000000 +0200
@@ -61,6 +61,9 @@ int sis_apic_bug = -1;
  */
 int nr_ioapic_registers[MAX_IO_APICS];
 
+/* Set by dmi_scan */
+extern int need_timer_irq_tweak;
+
 /*
  * Rough estimation of how many shared IRQs there are, can
  * be changed anytime.
@@ -1275,6 +1278,11 @@ void __init setup_IO_APIC_irqs(void)
 			if (!apic && (irq < 16))
 				disable_8259A_irq(irq);
 		}
+		/* Timer interrupt */
+		if (need_timer_irq_tweak && irq == 0) {
+			entry.delivery_mode = 0;
+			entry.dest_mode = 0;
+		}
 		spin_lock_irqsave(&ioapic_lock, flags);
 		io_apic_write(apic, 0x11+2*pin, *(((int *)&entry)+1));
 		io_apic_write(apic, 0x10+2*pin, *(((int *)&entry)+0));
