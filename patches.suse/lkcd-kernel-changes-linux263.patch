Index: linux-2.6.5/arch/i386/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/i386/Kconfig	2004-04-16 17:52:55.000000000 +0200
+++ linux-2.6.5/arch/i386/Kconfig	2004-04-16 17:57:45.000000000 +0200
@@ -1208,6 +1208,58 @@
 
 menu "Kernel hacking"
 
+config CRASH_DUMP
+	tristate "Crash dump support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	default n
+	---help---
+	  Say Y here to enable saving an image of system memory when a panic
+	  or other error occurs. Dumps can also be forced with the SysRq+d
+	  key if MAGIC_SYSRQ is enabled.
+
+config CRASH_DUMP_BLOCKDEV
+	tristate "Crash dump block device driver"
+	depends on CRASH_DUMP
+	help
+	  Say Y to allow saving crash dumps directly to a disk device.
+
+config CRASH_DUMP_NETDEV
+	tristate "Crash dump network device driver"
+	depends on CRASH_DUMP
+	help
+	  Say Y to allow saving crash dumps over a network device.
+
+config CRASH_DUMP_MEMDEV
+	bool "Crash dump staged memory driver"
+	depends on CRASH_DUMP
+	help
+	  Say Y to allow intermediate saving crash dumps in spare 
+	  memory pages which would then be written out to disk
+	  later.
+
+config CRASH_DUMP_SOFTBOOT
+	bool "Save crash dump across a soft reboot"
+	depends on CRASH_DUMP_MEMDEV
+	help
+	  Say Y to allow a crash dump to be preserved in memory
+	  pages across a soft reboot and written out to disk
+	  thereafter. For this to work, CRASH_DUMP must be 
+	  configured as part of the kernel (not as a module).
+
+config CRASH_DUMP_COMPRESS_RLE
+	tristate "Crash dump RLE compression"
+	depends on CRASH_DUMP
+	help
+	  Say Y to allow saving dumps with Run Length Encoding compression.
+
+config CRASH_DUMP_COMPRESS_GZIP
+	tristate "Crash dump GZIP compression"
+	select ZLIB_INFLATE
+	select ZLIB_DEFLATE
+	depends on CRASH_DUMP
+	help
+	  Say Y to allow saving dumps with Gnu Zip compression.
+
 config DEBUG_KERNEL
 	bool "Kernel debugging"
 	help
Index: linux-2.6.5/arch/i386/boot/Makefile
===================================================================
--- linux-2.6.5.orig/arch/i386/boot/Makefile	2004-04-04 05:36:57.000000000 +0200
+++ linux-2.6.5/arch/i386/boot/Makefile	2004-04-16 17:57:45.000000000 +0200
@@ -102,3 +102,4 @@
 
 install: $(BOOTIMAGE)
 	sh $(srctree)/$(src)/install.sh $(KERNELRELEASE) $< System.map "$(INSTALL_PATH)"
+	if [ -f init/kerntypes.o ]; then cp init/kerntypes.o $(INSTALL_PATH)/Kerntypes; fi
Index: linux-2.6.5/arch/i386/kernel/i386_ksyms.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/i386_ksyms.c	2004-04-16 17:52:55.000000000 +0200
+++ linux-2.6.5/arch/i386/kernel/i386_ksyms.c	2004-04-16 17:57:45.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/tty.h>
 #include <linux/highmem.h>
 #include <linux/time.h>
+#include <linux/nmi.h>
 
 #include <asm/semaphore.h>
 #include <asm/processor.h>
@@ -33,6 +34,7 @@
 #include <asm/tlbflush.h>
 #include <asm/nmi.h>
 #include <asm/ist.h>
+#include <asm/e820.h>
 
 extern void dump_thread(struct pt_regs *, struct user *);
 extern spinlock_t rtc_lock;
@@ -210,3 +212,20 @@
 #ifdef CONFIG_X86_GENERICARCH
 EXPORT_SYMBOL(genapic);
 #endif
+
+#ifdef CONFIG_CRASH_DUMP_MODULE
+#ifdef CONFIG_SMP
+extern irq_desc_t irq_desc[NR_IRQS];
+extern unsigned long irq_affinity[NR_IRQS];
+extern void stop_this_cpu(void *);
+EXPORT_SYMBOL(irq_desc);
+EXPORT_SYMBOL(irq_affinity);
+EXPORT_SYMBOL(stop_this_cpu);
+EXPORT_SYMBOL(dump_send_ipi);
+#endif
+extern int pfn_is_ram(unsigned long);
+EXPORT_SYMBOL(pfn_is_ram);
+#ifdef ARCH_HAS_NMI_WATCHDOG
+EXPORT_SYMBOL(touch_nmi_watchdog);
+#endif
+#endif
Index: linux-2.6.5/arch/i386/kernel/nmi.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/nmi.c	2004-04-16 17:52:51.000000000 +0200
+++ linux-2.6.5/arch/i386/kernel/nmi.c	2004-04-16 17:57:45.000000000 +0200
@@ -28,6 +28,7 @@
 #ifdef	CONFIG_KDB
 #include <linux/kdb.h>
 #endif	/* CONFIG_KDB */
+#include <linux/dump.h>
 
 #include <asm/smp.h>
 #include <asm/mtrr.h>
@@ -439,6 +440,7 @@
 			bust_spinlocks(1);
 			printk("NMI Watchdog detected LOCKUP on CPU%d, eip %08lx, registers:\n", cpu, regs->eip);
 			show_registers(regs);
+			dump("NMI Watchdog detected LOCKUP", regs);
 			printk("console shuts up ...\n");
 #ifdef	CONFIG_KDB
 			kdb(KDB_REASON_NMI, 0, regs);
Index: linux-2.6.5/arch/i386/kernel/setup.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/setup.c	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5/arch/i386/kernel/setup.c	2004-04-16 17:57:45.000000000 +0200
@@ -484,6 +484,7 @@
 	print_memory_map(who);
 } /* setup_memory_region */
 
+unsigned long crashdump_addr = 0xdeadbeef;
 
 static void __init parse_cmdline_early (char ** cmdline_p)
 {
@@ -629,6 +630,9 @@
 		if (c == ' ' && !memcmp(from, "highmem=", 8))
 			highmem_pages = memparse(from+8, &from) >> PAGE_SHIFT;
 	
+		if (c == ' ' && !memcmp(from, "crashdump=", 10))
+			crashdump_addr = memparse(from+10, &from); 
+			
 		c = *(from++);
 		if (!c)
 			break;
@@ -1078,6 +1082,10 @@
 
 __setup("noreplacement", noreplacement_setup); 
 
+#ifdef CONFIG_CRASH_DUMP_SOFTBOOT
+extern void crashdump_reserve(void);
+#endif
+
 /*
  * Determine if we were loaded by an EFI loader.  If so, then we have also been
  * passed the efi memmap, systab, etc., so we should use these data structures
@@ -1172,6 +1180,10 @@
 #endif
 
 
+#ifdef CONFIG_CRASH_DUMP_SOFTBOOT
+	crashdump_reserve(); /* Preserve crash dump state from prev boot */
+#endif
+
 	dmi_scan_machine();
 
 #ifdef CONFIG_X86_GENERICARCH
Index: linux-2.6.5/arch/i386/kernel/smp.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/smp.c	2004-04-16 17:52:51.000000000 +0200
+++ linux-2.6.5/arch/i386/kernel/smp.c	2004-04-16 17:57:45.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/mc146818rtc.h>
 #include <linux/cache.h>
 #include <linux/interrupt.h>
+#include <linux/dump.h>
 
 #include <asm/mtrr.h>
 #include <asm/pgalloc.h>
@@ -149,6 +150,13 @@
 	 */
 	cfg = __prepare_ICR(shortcut, vector);
 
+	if (vector == DUMP_VECTOR) {
+		/*
+		 * Setup DUMP IPI to be delivered as an NMI
+		 */
+		cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
+	}
+
 #ifdef	CONFIG_KDB
 	if (vector == KDB_VECTOR) {
 		/*
@@ -244,7 +252,13 @@
 				cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
 			}
 #endif	/* CONFIG_KDB */
-			
+		
+			if (vector == DUMP_VECTOR) {
+				/*
+				 * Setup DUMP IPI to be delivered as an NMI
+				 */
+				cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
+			}	
 			/*
 			 * Send the IPI. The write to APIC_ICR fires this off.
 			 */
@@ -499,6 +513,11 @@
 }
 #endif	/* CONFIG_KDB */
 
+void dump_send_ipi(void)
+{
+	send_IPI_allbutself(DUMP_VECTOR);
+}
+
 /*
  * this function sends a 'reschedule' IPI to another CPU.
  * it goes straight through and wastes no time serializing
@@ -577,7 +596,7 @@
 	return 0;
 }
 
-static void stop_this_cpu (void * dummy)
+void stop_this_cpu (void * dummy)
 {
 	/*
 	 * Remove this CPU:
@@ -638,4 +657,3 @@
 		atomic_inc(&call_data->finished);
 	}
 }
-
Index: linux-2.6.5/arch/i386/kernel/traps.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/traps.c	2004-04-16 17:52:51.000000000 +0200
+++ linux-2.6.5/arch/i386/kernel/traps.c	2004-04-16 17:57:45.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/kallsyms.h>
 #include <linux/ptrace.h>
 #include <linux/version.h>
+#include <linux/dump.h>
 
 #ifdef CONFIG_EISA
 #include <linux/ioport.h>
@@ -289,6 +290,7 @@
 	if (nl)
 		printk("\n");
 	show_registers(regs);
+	dump((char *)str, regs);
 	bust_spinlocks(0);
 	spin_unlock_irq(&die_lock);
 #ifdef	CONFIG_KDB
Index: linux-2.6.5/arch/i386/mm/init.c
===================================================================
--- linux-2.6.5.orig/arch/i386/mm/init.c	2004-04-04 05:37:39.000000000 +0200
+++ linux-2.6.5/arch/i386/mm/init.c	2004-04-16 17:57:45.000000000 +0200
@@ -206,6 +206,13 @@
 	return 0;
 }
 
+/* To enable modules to check if a page is in RAM */
+int pfn_is_ram(unsigned long pfn)
+{
+	return (page_is_ram(pfn));
+}
+
+
 #ifdef CONFIG_HIGHMEM
 pte_t *kmap_pte;
 pgprot_t kmap_prot;
Index: linux-2.6.5/arch/s390/Kconfig
===================================================================
--- linux-2.6.5.orig/arch/s390/Kconfig	2004-04-16 17:52:55.000000000 +0200
+++ linux-2.6.5/arch/s390/Kconfig	2004-04-16 17:57:45.000000000 +0200
@@ -371,6 +371,15 @@
 
 menu "Kernel hacking"
 
+config CRASH_DUMP
+	tristate "Crash dump support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	default n
+	---help---
+	  Say Y here to enable saving an image of system memory when a panic
+	  or other error occurs. Dumps can also be forced with the SysRq+d
+	  key if MAGIC_SYSRQ is enabled.
+
 config DEBUG_KERNEL
 	bool "Kernel debugging"
 	help
Index: linux-2.6.5/arch/s390/boot/Makefile
===================================================================
--- linux-2.6.5.orig/arch/s390/boot/Makefile	2004-04-16 17:52:55.000000000 +0200
+++ linux-2.6.5/arch/s390/boot/Makefile	2004-04-16 17:57:45.000000000 +0200
@@ -15,4 +15,4 @@
 
 install: $(CONFIGURE) $(obj)/image
 	sh -x $(obj)/install.sh $(KERNELRELEASE) $(obj)/image \
-	      System.map "$(INSTALL_PATH)"
+	      System.map init/kerntypes.o "$(INSTALL_PATH)"
Index: linux-2.6.5/arch/s390/boot/install.sh
===================================================================
--- linux-2.6.5.orig/arch/s390/boot/install.sh	2004-04-04 05:37:36.000000000 +0200
+++ linux-2.6.5/arch/s390/boot/install.sh	2004-04-16 17:57:45.000000000 +0200
@@ -16,7 +16,8 @@
 #   $1 - kernel version
 #   $2 - kernel image file
 #   $3 - kernel map file
-#   $4 - default install path (blank if root directory)
+#   $4 - kernel type file
+#   $5 - default install path (blank if root directory)
 #
 
 # User may have a custom install script
@@ -26,13 +27,22 @@
 
 # Default install - same as make zlilo
 
-if [ -f $4/vmlinuz ]; then
-	mv $4/vmlinuz $4/vmlinuz.old
+if [ -f $5/vmlinuz ]; then
+	mv $5/vmlinuz $5/vmlinuz.old
 fi
 
-if [ -f $4/System.map ]; then
-	mv $4/System.map $4/System.old
+if [ -f $5/System.map ]; then
+	mv $5/System.map $5/System.old
 fi
 
-cat $2 > $4/vmlinuz
-cp $3 $4/System.map
+if [ -f $5/Kerntypes ]; then
+	mv $5/Kerntypes $5/Kerntypes.old
+fi
+
+cat $2 > $5/vmlinuz
+cp $3 $5/System.map
+
+# copy the kernel type file if it exists
+if [ -f $4 ]; then
+	cp $4 $5/Kerntypes
+fi
Index: linux-2.6.5/drivers/Makefile
===================================================================
--- linux-2.6.5.orig/drivers/Makefile	2004-04-04 05:37:43.000000000 +0200
+++ linux-2.6.5/drivers/Makefile	2004-04-16 17:57:45.000000000 +0200
@@ -50,3 +50,4 @@
 obj-$(CONFIG_EISA)		+= eisa/
 obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-y				+= firmware/
+obj-$(CONFIG_CRASH_DUMP)	+= dump/
Index: linux-2.6.5/include/asm-i386/kmap_types.h
===================================================================
--- linux-2.6.5.orig/include/asm-i386/kmap_types.h	2004-04-16 17:52:51.000000000 +0200
+++ linux-2.6.5/include/asm-i386/kmap_types.h	2004-04-16 17:57:45.000000000 +0200
@@ -25,7 +25,8 @@
 D(12)	KM_SOFTIRQ0,
 D(13)	KM_SOFTIRQ1,
 D(14)	KM_KDB,
-D(15)	KM_TYPE_NR
+D(15)	KM_DUMP,
+D(16)	KM_TYPE_NR
 };
 
 #undef D
Index: linux-2.6.5/include/asm-i386/mach-default/irq_vectors.h
===================================================================
--- linux-2.6.5.orig/include/asm-i386/mach-default/irq_vectors.h	2004-04-16 17:52:51.000000000 +0200
+++ linux-2.6.5/include/asm-i386/mach-default/irq_vectors.h	2004-04-16 17:57:45.000000000 +0200
@@ -49,6 +49,7 @@
 #define INVALIDATE_TLB_VECTOR	0xfd
 #define RESCHEDULE_VECTOR	0xfc
 #define CALL_FUNCTION_VECTOR	0xfb
+#define DUMP_VECTOR		0xfa
 #define KDB_VECTOR		0xf9
 
 #define THERMAL_APIC_VECTOR	0xf0
Index: linux-2.6.5/include/asm-i386/smp.h
===================================================================
--- linux-2.6.5.orig/include/asm-i386/smp.h	2004-04-16 17:52:48.000000000 +0200
+++ linux-2.6.5/include/asm-i386/smp.h	2004-04-16 17:57:45.000000000 +0200
@@ -37,6 +37,7 @@
 extern cpumask_t cpu_sibling_map[];
 
 extern void smp_flush_tlb(void);
+extern void dump_send_ipi(void);
 extern void smp_message_irq(int cpl, void *dev_id, struct pt_regs *regs);
 extern void smp_invalidate_rcv(void);		/* Process an NMI */
 extern void (*mtrr_hook) (void);
Index: linux-2.6.5/include/asm-s390/dump.h
===================================================================
--- linux-2.6.5.orig/include/asm-s390/dump.h	2002-10-21 17:56:58.000000000 +0200
+++ linux-2.6.5/include/asm-s390/dump.h	2004-04-16 17:57:45.000000000 +0200
@@ -0,0 +1,10 @@
+/*
+ * Kernel header file for Linux crash dumps.
+ */
+
+/* Nothing to be done here, we have proper hardware support */
+#ifndef _ASM_DUMP_H
+#define _ASM_DUMP_H
+
+#endif
+
Index: linux-2.6.5/include/linux/miscdevice.h
===================================================================
--- linux-2.6.5.orig/include/linux/miscdevice.h	2004-04-16 17:52:54.000000000 +0200
+++ linux-2.6.5/include/linux/miscdevice.h	2004-04-16 17:57:45.000000000 +0200
@@ -24,6 +24,7 @@
 #define MICROCODE_MINOR		184
 #define MWAVE_MINOR	219		/* ACP/Mwave Modem */
 #define MPT_MINOR	220
+#define CRASH_DUMP_MINOR   230		/* LKCD */
 #define MISC_DYNAMIC_MINOR 255
 
 #define SGI_GRAPHICS_MINOR   146
Index: linux-2.6.5/include/linux/sched.h
===================================================================
--- linux-2.6.5.orig/include/linux/sched.h	2004-04-16 17:52:54.000000000 +0200
+++ linux-2.6.5/include/linux/sched.h	2004-04-16 17:57:45.000000000 +0200
@@ -91,6 +91,7 @@
 extern int nr_threads;
 extern int last_pid;
 DECLARE_PER_CPU(unsigned long, process_counts);
+DECLARE_PER_CPU(struct runqueue, runqueues);
 extern int nr_processes(void);
 extern unsigned long nr_running(void);
 extern unsigned long nr_uninterruptible(void);
@@ -681,6 +682,59 @@
 void yield(void);
 
 /*
+ * These are the runqueue data structures:
+ */
+
+#define BITMAP_SIZE ((((MAX_PRIO+1+7)/8)+sizeof(long)-1)/sizeof(long))
+
+typedef struct runqueue runqueue_t;
+
+struct prio_array {
+	unsigned int nr_active;
+	unsigned long bitmap[BITMAP_SIZE];
+	struct list_head queue[MAX_PRIO];
+};
+
+/*
+ * This is the main, per-CPU runqueue data structure.
+ *
+ * Locking rule: those places that want to lock multiple runqueues
+ * (such as the load balancing or the thread migration code), lock
+ * acquire operations must be ordered by ascending &runqueue.
+ */
+struct runqueue {
+	spinlock_t lock;
+
+	/*
+	 * nr_running and cpu_load should be in the same cacheline because
+	 * remote CPUs use both these fields when doing load calculation.
+	 */
+	unsigned long nr_running;
+#ifdef CONFIG_SMP
+	unsigned long cpu_load;
+#endif
+	unsigned long long nr_switches;
+	unsigned long expired_timestamp, nr_uninterruptible;
+	unsigned long long timestamp_last_tick;
+	task_t *curr, *idle;
+	struct mm_struct *prev_mm;
+	prio_array_t *active, *expired, arrays[2];
+	int best_expired_prio;
+	atomic_t nr_iowait;
+
+#ifdef CONFIG_SMP
+	struct sched_domain *sd;
+
+	/* For active balancing */
+	int active_balance;
+	int push_cpu;
+
+	task_t *migration_thread;
+	struct list_head migration_queue;
+#endif
+};
+
+/*
  * The default (Linux) execution domain.
  */
 extern struct exec_domain	default_exec_domain;
Index: linux-2.6.5/include/linux/sysctl.h
===================================================================
--- linux-2.6.5.orig/include/linux/sysctl.h	2004-04-16 17:52:55.000000000 +0200
+++ linux-2.6.5/include/linux/sysctl.h	2004-04-16 17:57:45.000000000 +0200
@@ -133,6 +133,7 @@
 	KERN_NGROUPS_MAX=63,	/* int: NGROUPS_MAX */
 	KERN_KDB=64,		/* int: kdb on/off */
 	KERN_S390_HZ_TIMER=65,  /* int: hz timer on or off */
+	KERN_DUMP=66,		/* directory: dump parameters */
 };
 
 
Index: linux-2.6.5/init/Makefile
===================================================================
--- linux-2.6.5.orig/init/Makefile	2004-04-04 05:36:57.000000000 +0200
+++ linux-2.6.5/init/Makefile	2004-04-16 17:57:45.000000000 +0200
@@ -9,6 +9,9 @@
 mounts-$(CONFIG_BLK_DEV_INITRD)	+= do_mounts_initrd.o
 mounts-$(CONFIG_BLK_DEV_MD)	+= do_mounts_md.o
 
+extra-$(subst m,y,$(CONFIG_CRASH_DUMP))	+= kerntypes.o
+CFLAGS_kerntypes.o		:= -gstabs
+
 # files to be removed upon make clean
 clean-files := ../include/linux/compile.h
 
@@ -24,3 +27,4 @@
 include/linux/compile.h: FORCE
 	@echo '  CHK     $@'
 	@$(CONFIG_SHELL) $(srctree)/scripts/mkcompile_h $@ "$(UTS_MACHINE)" "$(CONFIG_SMP)" "$(CC) $(CFLAGS)"
+
Index: linux-2.6.5/init/main.c
===================================================================
--- linux-2.6.5.orig/init/main.c	2004-04-16 17:52:55.000000000 +0200
+++ linux-2.6.5/init/main.c	2004-04-16 17:57:45.000000000 +0200
@@ -101,6 +101,16 @@
 int system_state;	/* SYSTEM_BOOTING/RUNNING/SHUTDOWN */
 
 /*
+ * The kernel_magic value represents the address of _end, which allows
+ * namelist tools to "match" each other respectively.  That way a tool
+ * that looks at /dev/mem can verify that it is using the right System.map
+ * file -- if kernel_magic doesn't equal the namelist value of _end,
+ * something's wrong.
+ */
+extern unsigned long _end;
+unsigned long *kernel_magic = &_end;
+
+/*
  * Boot command-line arguments
  */
 #define MAX_INIT_ARGS 32
Index: linux-2.6.5/init/version.c
===================================================================
--- linux-2.6.5.orig/init/version.c	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5/init/version.c	2004-04-16 17:57:45.000000000 +0200
@@ -11,6 +11,7 @@
 #include <linux/uts.h>
 #include <linux/utsname.h>
 #include <linux/version.h>
+#include <linux/stringify.h>
 
 #define version(a) Version_ ## a
 #define version_string(a) version(a)
@@ -31,3 +32,6 @@
 const char *linux_banner = 
 	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
 	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
+
+const char *LINUX_COMPILE_VERSION_ID = __stringify(LINUX_COMPILE_VERSION_ID);
+LINUX_COMPILE_VERSION_ID_TYPE;
Index: linux-2.6.5/kernel/panic.c
===================================================================
--- linux-2.6.5.orig/kernel/panic.c	2004-04-16 17:52:55.000000000 +0200
+++ linux-2.6.5/kernel/panic.c	2004-04-16 17:57:45.000000000 +0200
@@ -19,12 +19,17 @@
 #include <linux/syscalls.h>
 #include <linux/interrupt.h>
 #include <linux/nmi.h>
+#ifdef CONFIG_KEXEC
+#include <linux/kexec.h>
+#endif
 
 int panic_timeout;
 int panic_on_oops;
 int tainted;
+void (*dump_function_ptr)(const char *, const struct pt_regs *) = 0;
 
 EXPORT_SYMBOL(panic_timeout);
+EXPORT_SYMBOL(dump_function_ptr);
 
 struct notifier_block *panic_notifier_list;
 
@@ -70,6 +75,7 @@
 	va_start(args, fmt);
 	vsnprintf(buf, sizeof(buf), fmt, args);
 	va_end(args);
+
 	printk(KERN_EMERG "Kernel panic: %s\n",buf);
 #ifdef __arch_um__
 	if (dump_core)
@@ -83,14 +89,13 @@
 		sys_sync();
 	bust_spinlocks(0);
 
+        notifier_call_chain(&panic_notifier_list, 0, buf);
+	
 #ifdef CONFIG_SMP
 	smp_send_stop();
 #endif
 
-       notifier_call_chain(&panic_notifier_list, 0, buf);
-
-	if (panic_timeout > 0)
-	{
+	if (panic_timeout > 0) {
 		int i;
 		/*
 	 	 * Delay timeout seconds before rebooting the machine. 
@@ -103,6 +108,17 @@
 			(void)splash_verbose();
 		}
 #endif
+#ifdef CONFIG_KEXEC
+{		
+		struct kimage *image;
+		image = xchg(&kexec_image, 0);
+ 		if (image) {
+ 			printk(KERN_EMERG "by starting a new kernel ..\n");
+ 			mdelay(panic_timeout*1000);
+			machine_kexec(image);
+ 		}
+ }
+#endif
 		for (i = 0; i < panic_timeout; i++) {
 			touch_nmi_watchdog();
 			mdelay(1000);
Index: linux-2.6.5/kernel/sched.c
===================================================================
--- linux-2.6.5.orig/kernel/sched.c	2004-04-16 17:52:54.000000000 +0200
+++ linux-2.6.5/kernel/sched.c	2004-04-16 17:58:20.000000000 +0200
@@ -47,6 +47,10 @@
 #define cpu_to_node_mask(cpu) (cpu_online_map)
 #endif
 
+/* used to soft spin in sched while dump is in progress */
+unsigned long dump_oncpu;
+EXPORT_SYMBOL(dump_oncpu);
+
 /*
  * Convert user-nice values [ -20 ... 0 ... 19 ]
  * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
@@ -187,60 +191,7 @@
 
 #define task_hot(p, now, sd) ((now) - (p)->timestamp < (sd)->cache_hot_time)
 
-/*
- * These are the runqueue data structures:
- */
-
-#define BITMAP_SIZE ((((MAX_PRIO+1+7)/8)+sizeof(long)-1)/sizeof(long))
-
-typedef struct runqueue runqueue_t;
-
-struct prio_array {
-	unsigned int nr_active;
-	unsigned long bitmap[BITMAP_SIZE];
-	struct list_head queue[MAX_PRIO];
-};
-
-/*
- * This is the main, per-CPU runqueue data structure.
- *
- * Locking rule: those places that want to lock multiple runqueues
- * (such as the load balancing or the thread migration code), lock
- * acquire operations must be ordered by ascending &runqueue.
- */
-struct runqueue {
-	spinlock_t lock;
-
-	/*
-	 * nr_running and cpu_load should be in the same cacheline because
-	 * remote CPUs use both these fields when doing load calculation.
-	 */
-	unsigned long nr_running;
-#ifdef CONFIG_SMP
-	unsigned long cpu_load;
-#endif
-	unsigned long long nr_switches;
-	unsigned long expired_timestamp, nr_uninterruptible;
-	unsigned long long timestamp_last_tick;
-	task_t *curr, *idle;
-	struct mm_struct *prev_mm;
-	prio_array_t *active, *expired, arrays[2];
-	int best_expired_prio;
-	atomic_t nr_iowait;
-
-#ifdef CONFIG_SMP
-	struct sched_domain *sd;
-
-	/* For active balancing */
-	int active_balance;
-	int push_cpu;
-
-	task_t *migration_thread;
-	struct list_head migration_queue;
-#endif
-};
-
-static DEFINE_PER_CPU(struct runqueue, runqueues);
+DEFINE_PER_CPU(struct runqueue, runqueues);
 
 #define for_each_domain(cpu, domain) \
 	for (domain = cpu_rq(cpu)->sd; domain; domain = domain->parent)
@@ -2055,6 +2006,15 @@
 	unsigned long run_time;
 	int cpu, idx;
 
+ 	/*
+	 * If crash dump is in progress, this other cpu's
+	 * need to wait until it completes.
+	 * NB: this code is optimized away for kernels without
+	 * dumping enabled.
+	 */
+	if (unlikely(dump_oncpu))
+		goto dump_scheduling_disabled;
+
 	/*
 	 * Test if we are atomic.  Since do_exit() needs to call into
 	 * schedule() atomically, we ignore that path for now.
@@ -2178,6 +2138,16 @@
 	preempt_enable_no_resched();
 	if (test_thread_flag(TIF_NEED_RESCHED))
 		goto need_resched;
+
+	return;
+
+ dump_scheduling_disabled:
+	/* allow scheduling only if this is the dumping cpu */
+	if (dump_oncpu != smp_processor_id()+1) {
+		while (dump_oncpu)
+			cpu_relax();
+	}
+	return;
 }
 
 EXPORT_SYMBOL(schedule);
Index: linux-2.6.5/mm/bootmem.c
===================================================================
--- linux-2.6.5.orig/mm/bootmem.c	2004-04-04 05:36:54.000000000 +0200
+++ linux-2.6.5/mm/bootmem.c	2004-04-16 17:57:45.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/bootmem.h>
 #include <linux/mmzone.h>
+#include <linux/module.h>
 #include <asm/dma.h>
 #include <asm/io.h>
 
@@ -25,6 +26,7 @@
  */
 unsigned long max_low_pfn;
 unsigned long min_low_pfn;
+EXPORT_SYMBOL(min_low_pfn);
 unsigned long max_pfn;
 
 /* return the number of _pages_ that will be allocated for the boot bitmap */
Index: linux-2.6.5/mm/page_alloc.c
===================================================================
--- linux-2.6.5.orig/mm/page_alloc.c	2004-04-16 17:52:54.000000000 +0200
+++ linux-2.6.5/mm/page_alloc.c	2004-04-16 17:57:45.000000000 +0200
@@ -46,6 +46,11 @@
 EXPORT_SYMBOL(totalram_pages);
 EXPORT_SYMBOL(nr_swap_pages);
 
+#ifdef CONFIG_CRASH_DUMP_MODULE
+/* This symbol has to be exported to use 'for_each_pgdat' macro by modules. */
+EXPORT_SYMBOL(pgdat_list);
+#endif
+
 /*
  * Used by page_zone() to look up the address of the struct zone whose
  * id is encoded in the upper bits of page->flags
@@ -89,7 +94,8 @@
 	page->mapping = NULL;
 }
 
-#ifndef CONFIG_HUGETLB_PAGE
+#if !defined(CONFIG_HUGETLB_PAGE) && !defined(CONFIG_CRASH_DUMP) \
+	&& !defined(CONFIG_CRASH_DUMP_MODULE)
 #define prep_compound_page(page, order) do { } while (0)
 #define destroy_compound_page(page, order) do { } while (0)
 #else
Index: linux-2.6.5/scripts/mkcompile_h
===================================================================
--- linux-2.6.5.orig/scripts/mkcompile_h	2004-04-16 17:52:55.000000000 +0200
+++ linux-2.6.5/scripts/mkcompile_h	2004-04-16 17:57:45.000000000 +0200
@@ -33,7 +33,7 @@
 
 UTS_LEN=64
 UTS_TRUNCATE="sed -e s/\(.\{1,$UTS_LEN\}\).*/\1/"
-
+LINUX_COMPILE_VERSION_ID="__linux_compile_version_id__`hostname | tr -c '[0-9A-Za-z\n]' '__'`_`LANG=C date | tr -c '[0-9A-Za-z\n]' '_'`"
 # Generate a temporary compile.h
 
 ( echo /\* This file is auto generated, version $VERSION \*/
@@ -48,6 +48,8 @@
   echo \#define LINUX_COMPILE_DOMAIN \"suse.de\"
 
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
+  echo \#define LINUX_COMPILE_VERSION_ID $LINUX_COMPILE_VERSION_ID
+  echo \#define LINUX_COMPILE_VERSION_ID_TYPE typedef char* "$LINUX_COMPILE_VERSION_ID""_t"
 ) > .tmpcompile
 
 # Only replace the real compile.h if the new one is different,
