From: Olaf Kirch <okir@suse.de>
Subject: When looking up a lockd host, pass hostname & length

  This patch adds the peer's hostname (and name length) to
  all calls to nlm*_lookup_host functions. A subsequent patch
  will make use of these.

Signed-off-by: okir@suse.de

Index: 2.6.15/fs/lockd/clntproc.c
===================================================================
--- 2.6.15.orig/fs/lockd/clntproc.c
+++ 2.6.15/fs/lockd/clntproc.c
@@ -206,7 +206,9 @@ nlmclnt_proc(struct inode *inode, int cm
 	/* Retrieve transport protocol from NFS client */
 	proto = NFS_CLIENT(inode)->cl_xprt->prot;
 
-	if (!(host = nlmclnt_lookup_host(NFS_ADDR(inode), proto, vers)))
+	host = nlmclnt_lookup_host(NFS_ADDR(inode), proto, vers,
+				nfssrv->hostname, strlen(nfssrv->hostname));
+	if (host == NULL)
 		return -ENOLCK;
 
 	/* Create RPC client handle if not there, and copy soft
Index: 2.6.15/fs/lockd/host.c
===================================================================
--- 2.6.15.orig/fs/lockd/host.c
+++ 2.6.15/fs/lockd/host.c
@@ -38,19 +38,23 @@ static void			nlm_gc_hosts(void);
  * Find an NLM server handle in the cache. If there is none, create it.
  */
 struct nlm_host *
-nlmclnt_lookup_host(const struct sockaddr_in *sin, int proto, int version)
+nlmclnt_lookup_host(const struct sockaddr_in *sin, int proto, int version,
+			const char *hostname, int hostname_len)
 {
-	return nlm_lookup_host(0, sin, proto, version);
+	return nlm_lookup_host(0, sin, proto, version,
+			       hostname, hostname_len);
 }
 
 /*
  * Find an NLM client handle in the cache. If there is none, create it.
  */
 struct nlm_host *
-nlmsvc_lookup_host(struct svc_rqst *rqstp)
+nlmsvc_lookup_host(struct svc_rqst *rqstp,
+			const char *hostname, int hostname_len)
 {
 	return nlm_lookup_host(1, &rqstp->rq_addr,
-			       rqstp->rq_prot, rqstp->rq_vers);
+			       rqstp->rq_prot, rqstp->rq_vers,
+			       hostname, hostname_len);
 }
 
 /*
@@ -58,14 +62,20 @@ nlmsvc_lookup_host(struct svc_rqst *rqst
  */
 struct nlm_host *
 nlm_lookup_host(int server, const struct sockaddr_in *sin,
-					int proto, int version)
+					int proto, int version,
+					const char *hostname,
+					int hostname_len)
 {
 	struct nlm_host	*host, **hp;
 	u32		addr;
 	int		hash;
 
-	dprintk("lockd: nlm_lookup_host(%08x, p=%d, v=%d)\n",
-			(unsigned)(sin? ntohl(sin->sin_addr.s_addr) : 0), proto, version);
+	dprintk("lockd: nlm_lookup_host(%u.%u.%u.%u, p=%d, v=%d, my role=%s, name=%.*s)\n",
+			NIPQUAD(sin->sin_addr.s_addr), proto, version,
+			server? "server" : "client",
+			hostname_len,
+			hostname? hostname : "<none>");
+
 
 	hash = NLM_ADDRHASH(sin->sin_addr.s_addr);
 
@@ -254,19 +264,22 @@ void nlm_release_host(struct nlm_host *h
 void nlm_host_rebooted(const struct sockaddr_in *sin, const struct nlm_reboot *argp)
 {
 	struct nlm_host *host;
+	int server;
 
 	/* Obtain the host pointer for this NFS server and try to
 	 * reclaim all locks we hold on this server.
 	 */
-	if ((argp->proto & 1)==0) {
+	server = (argp->proto & 1)? 1 : 0;
+	host = nlm_lookup_host(server, sin, argp->proto >> 1, argp->vers,
+			argp->mon, argp->len);
+	if (host == NULL)
+		return;
+
+	if (server == 0) {
 		/* We are client, he's the server: try to reclaim all locks. */
-		if ((host = nlmclnt_lookup_host(sin, argp->proto >> 1, argp->vers)) == NULL)
-			return;
 		nlmclnt_recovery(host, argp->state);
 	} else {
 		/* He's the client, we're the server: delete all locks held by the client */
-		if ((host = nlm_lookup_host(1, sin, argp->proto >> 1, argp->vers)) == NULL)
-			return;
 		nlmsvc_free_host_resources(host);
 	}
 	nlm_release_host(host);
Index: 2.6.15/fs/lockd/svc4proc.c
===================================================================
--- 2.6.15.orig/fs/lockd/svc4proc.c
+++ 2.6.15/fs/lockd/svc4proc.c
@@ -41,7 +41,7 @@ nlm4svc_retrieve_args(struct svc_rqst *r
 		return nlm_lck_denied_nolocks;
 
 	/* Obtain host handle */
-	if (!(host = nlmsvc_lookup_host(rqstp))
+	if (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))
 	 || (argp->monitor && nsm_monitor(host) < 0))
 		goto no_locks;
 	*hostp = host;
@@ -469,7 +469,8 @@ nlm4svc_callback(struct svc_rqst *rqstp,
 		return rpc_system_err;
 
 	host = nlmclnt_lookup_host(&rqstp->rq_addr,
-				rqstp->rq_prot, rqstp->rq_vers);
+				rqstp->rq_prot, rqstp->rq_vers,
+				NULL, 0);
 	if (!host) {
 		kfree(call);
 		return rpc_system_err;
Index: 2.6.15/fs/lockd/svclock.c
===================================================================
--- 2.6.15.orig/fs/lockd/svclock.c
+++ 2.6.15/fs/lockd/svclock.c
@@ -177,7 +177,8 @@ nlmsvc_create_block(struct svc_rqst *rqs
 
 	/* Create host handle for callback */
 	host = nlmclnt_lookup_host(&rqstp->rq_addr,
-				rqstp->rq_prot, rqstp->rq_vers);
+				rqstp->rq_prot, rqstp->rq_vers,
+				lock->caller, lock->len);
 	if (host == NULL)
 		return NULL;
 
@@ -397,6 +398,7 @@ nlmsvc_testlock(struct nlm_file *file, s
 				fl->fl_type, (long long)fl->fl_start,
 				(long long)fl->fl_end);
 		conflock->caller = "somehost";	/* FIXME */
+		conflock->len = strlen(conflock->caller);
 		conflock->oh.len = 0;		/* don't return OH info */
 		conflock->fl = *fl;
 		return nlm_lck_denied;
Index: 2.6.15/fs/lockd/svcproc.c
===================================================================
--- 2.6.15.orig/fs/lockd/svcproc.c
+++ 2.6.15/fs/lockd/svcproc.c
@@ -70,7 +70,7 @@ nlmsvc_retrieve_args(struct svc_rqst *rq
 		return nlm_lck_denied_nolocks;
 
 	/* Obtain host handle */
-	if (!(host = nlmsvc_lookup_host(rqstp))
+	if (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))
 	 || (argp->monitor && nsm_monitor(host) < 0))
 		goto no_locks;
 	*hostp = host;
@@ -495,7 +495,8 @@ nlmsvc_callback(struct svc_rqst *rqstp, 
 		return rpc_system_err;
 
 	host = nlmclnt_lookup_host(&rqstp->rq_addr,
-				rqstp->rq_prot, rqstp->rq_vers);
+				rqstp->rq_prot, rqstp->rq_vers,
+				NULL, 0);
 	if (!host) {
 		kfree(call);
 		return rpc_system_err;
Index: 2.6.15/include/linux/lockd/lockd.h
===================================================================
--- 2.6.15.orig/include/linux/lockd/lockd.h
+++ 2.6.15/include/linux/lockd/lockd.h
@@ -159,9 +159,9 @@ void		  nlmclnt_freegrantargs(struct nlm
 /*
  * Host cache
  */
-struct nlm_host * nlmclnt_lookup_host(const struct sockaddr_in *, int, int);
-struct nlm_host * nlmsvc_lookup_host(struct svc_rqst *);
-struct nlm_host * nlm_lookup_host(int server, const struct sockaddr_in *, int, int);
+struct nlm_host * nlmclnt_lookup_host(const struct sockaddr_in *, int, int, const char *, int);
+struct nlm_host * nlmsvc_lookup_host(struct svc_rqst *, const char *, int);
+struct nlm_host * nlm_lookup_host(int server, const struct sockaddr_in *, int, int, const char *, int);
 struct rpc_clnt * nlm_bind_host(struct nlm_host *);
 void		  nlm_rebind_host(struct nlm_host *);
 struct nlm_host * nlm_get_host(struct nlm_host *);
