Index: drivers/char/keyboard.c
===================================================================
--- .orig/drivers/char/keyboard.c
+++ /drivers/char/keyboard.c
@@ -1058,6 +1058,14 @@ void kbd_keycode(unsigned int keycode, i
 			if (keycode < BTN_MISC)
 				printk(KERN_WARNING "keyboard.c: can't emulate rawmode for keycode %d\n", keycode);
 
+#ifdef CONFIG_BOOTSPLASH
+	/* This code has to be redone for some non-x86 platforms */
+	if (down == 1 && (keycode == 0x3c || keycode == 0x01)) {	/* F2 and ESC on PC keyboard */
+		extern int splash_verbose(void);
+		if (splash_verbose())
+			return;
+	}
+#endif
 #ifdef CONFIG_MAGIC_SYSRQ	       /* Handle the SysRq Hack */
 	if (keycode == KEY_SYSRQ && (sysrq_down || (down == 1 && sysrq_alt))) {
 		sysrq_down = down;
Index: drivers/char/n_tty.c
===================================================================
--- .orig/drivers/char/n_tty.c
+++ /drivers/char/n_tty.c
@@ -989,6 +989,16 @@ do_it_again:
 		return -EIO;
 	}
 
+#ifdef CONFIG_BOOTSPLASH
+        if (file->f_dentry->d_inode->i_rdev == MKDEV(TTY_MAJOR,0) ||
+            file->f_dentry->d_inode->i_rdev == MKDEV(TTY_MAJOR,1) ||
+            file->f_dentry->d_inode->i_rdev == MKDEV(TTYAUX_MAJOR,0) ||
+            file->f_dentry->d_inode->i_rdev == MKDEV(TTYAUX_MAJOR,1)) {
+                extern int splash_verbose(void);
+                (void)splash_verbose();
+        }               
+#endif
+
 	/* Job control check -- must be done at start and after
 	   every sleep (POSIX.1 7.1.1.4). */
 	/* NOTE: not yet done after every sleep pending a thorough
Index: drivers/char/vt.c
===================================================================
--- .orig/drivers/char/vt.c
+++ /drivers/char/vt.c
@@ -3267,6 +3267,31 @@ static int pm_con_request(struct pm_dev 
 	return 0;
 }
 
+#ifdef CONFIG_BOOTSPLASH
+void con_remap_def_color(int currcons, int new_color)
+{
+       unsigned short *sbuf = screenbuf;
+       unsigned c, len = screenbuf_size >> 1;
+       int old_color;
+
+       if (sbuf) {
+	       old_color = def_color << 8;
+	       new_color <<= 8;
+	       while(len--) {
+		       c = *sbuf;
+		       if (((c ^ old_color) & 0xf000) == 0)
+			       *sbuf ^= (old_color ^ new_color) & 0xf000;
+		       if (((c ^ old_color) & 0x0f00) == 0)
+			       *sbuf ^= (old_color ^ new_color) & 0x0f00;
+		       sbuf++;
+	       }
+	       new_color >>= 8;
+       }
+       def_color = color = new_color;
+       update_attr(currcons);
+}
+#endif
+
 /*
  *	Visible symbols for modules
  */
Index: drivers/video/Kconfig
===================================================================
--- .orig/drivers/video/Kconfig
+++ /drivers/video/Kconfig
@@ -1002,5 +1002,9 @@ if FB || SGI_NEWPORT_CONSOLE
 	source "drivers/video/logo/Kconfig"
 endif
 
+if FB
+	source "drivers/video/bootsplash/Kconfig"
+endif
+
 endmenu
 
Index: drivers/video/Makefile
===================================================================
--- .orig/drivers/video/Makefile
+++ /drivers/video/Makefile
@@ -6,6 +6,7 @@
 
 obj-$(CONFIG_VT)		  += console/
 obj-$(CONFIG_LOGO)		  += logo/
+obj-$(CONFIG_BOOTSPLASH)	  += bootsplash/
 
 obj-$(CONFIG_FB)                  += fbmem.o fbmon.o fbcmap.o fbsysfs.o modedb.o softcursor.o
 # Only include macmodes.o if we have FB support and are PPC
Index: drivers/video/bootsplash/Kconfig
===================================================================
--- .orig/drivers/video/bootsplash/Kconfig
+++ /drivers/video/bootsplash/Kconfig
@@ -0,0 +1,17 @@
+#
+# Bootsplash configuration
+#
+
+menu "Bootsplash configuration"
+
+config BOOTSPLASH
+	bool "Bootup splash screen"
+	depends on FRAMEBUFFER_CONSOLE && FB_VESA
+	default n
+        ---help---
+          This option enables the Linux bootsplash screen. For more 
+          information on the bootsplash screen have a look at 
+          http://www.bootsplash.org/.
+          If you are unsure, say N
+endmenu
+
Index: drivers/video/bootsplash/Makefile
===================================================================
--- .orig/drivers/video/bootsplash/Makefile
+++ /drivers/video/bootsplash/Makefile
@@ -0,0 +1,5 @@
+# Makefile for the Linux bootsplash
+
+obj-$(CONFIG_BOOTSPLASH)		+= bootsplash.o
+obj-$(CONFIG_BOOTSPLASH)		+= decode-jpg.o
+obj-$(CONFIG_BOOTSPLASH)		+= render.o
Index: drivers/video/bootsplash/bootsplash.c
===================================================================
--- .orig/drivers/video/bootsplash/bootsplash.c
+++ /drivers/video/bootsplash/bootsplash.c
@@ -0,0 +1,923 @@
+/* 
+ *           linux/drivers/video/bootsplash/bootsplash.c - 
+ *                 splash screen handling functions.
+ *	
+ *	(w) 2001-2004 by Volker Poplawski, <volker@poplawski.de>,
+ * 		    Stefan Reinauer, <stepan@suse.de>,
+ * 		    Steffen Winterfeldt, <snwint@suse.de>,
+ *                  Michael Schroeder <mls@suse.de>
+ * 		    
+ *        Ideas & SuSE screen work by Ken Wimer, <wimer@suse.de>
+ *
+ *  For more information on this code check http://www.bootsplash.org/
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/vt_kern.h>
+#include <linux/vmalloc.h>
+#include <linux/unistd.h>
+#include <linux/syscalls.h>
+
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include "../console/fbcon.h"
+#include "bootsplash.h"
+#include "decode-jpg.h"
+
+extern struct fb_ops vesafb_ops;
+
+#define SPLASH_VERSION "3.1.6-2004/03/31"
+
+/* These errors have to match fbcon-jpegdec.h */
+static unsigned char *jpg_errors[] = {
+	"no SOI found", 
+	"not 8 bit", 
+	"height mismatch", 
+	"width mismatch",
+	"bad width or height", 
+	"too many COMPPs", 
+	"illegal HV", 
+	"quant table selector",
+	"picture is not YCBCR 221111",
+	"unknow CID in scan",
+	"dct not sequential",
+	"wrong marker",
+	"no EOI",
+	"bad tables",
+	"depth mismatch"
+};
+
+static struct jpeg_decdata *decdata = 0; /* private decoder data */
+
+static int splash_registered = 0;
+static int splash_usesilent = 0;	/* shall we display the silentjpeg? */
+int splash_default = 0xf01;
+
+static int splash_check_jpeg(unsigned char *jpeg, int width, int height, int depth);
+
+static int __init splash_setup(char *options)
+{
+	if(!strncmp("silent", options, 6)) {
+		printk(KERN_INFO "bootsplash: silent mode.\n");
+		splash_usesilent = 1;
+		/* skip "silent," */
+		if (strlen(options) == 6)
+			return 0;
+		options += 7;
+	}
+	if(!strncmp("verbose", options, 7)) {
+		printk(KERN_INFO "bootsplash: verbose mode.\n");
+		splash_usesilent = 0;
+		return 0;
+	}
+	splash_default = simple_strtoul(options, NULL, 0);
+	return 0;
+}
+
+__setup("splash=", splash_setup);
+
+
+static int splash_hasinter(unsigned char *buf, int num)
+{
+    unsigned char *bufend = buf + num * 12;
+    while(buf < bufend) {
+	if (buf[1] > 127)		/* inter? */
+	    return 1;
+	buf += buf[3] > 127 ? 24 : 12;	/* blend? */
+    }
+    return 0;
+}
+
+static int boxextract(unsigned char *buf, unsigned short *dp, unsigned char *cols, int *blendp)
+{
+    dp[0] = buf[0] | buf[1] << 8;
+    dp[1] = buf[2] | buf[3] << 8;
+    dp[2] = buf[4] | buf[5] << 8;
+    dp[3] = buf[6] | buf[7] << 8;
+    *(unsigned int *)(cols + 0) =
+	*(unsigned int *)(cols + 4) =
+	*(unsigned int *)(cols + 8) =
+	*(unsigned int *)(cols + 12) = *(unsigned int *)(buf + 8);
+    if (dp[1] > 32767) {
+	dp[1] = ~dp[1];
+	*(unsigned int *)(cols + 4) = *(unsigned int *)(buf + 12);
+	*(unsigned int *)(cols + 8) = *(unsigned int *)(buf + 16);
+	*(unsigned int *)(cols + 12) = *(unsigned int *)(buf + 20);
+	*blendp = 1;
+	return 24;
+    }
+    return 12;
+}
+
+static void boxit(unsigned char *pic, int bytes, unsigned char *buf, int num, int percent, int overpaint)
+{
+    int x, y, i, p, doblend, r, g, b, a, add;
+    unsigned short data1[4];
+    unsigned char cols1[16];
+    unsigned short data2[4];
+    unsigned char cols2[16];
+    unsigned char *bufend;
+    unsigned short *picp;
+    unsigned int stipple[32], sti, stin, stinn, stixs, stixe, stiys, stiye;
+    int xs, xe, ys, ye, xo, yo;
+
+    if (num == 0)
+	return;
+    bufend = buf + num * 12;
+    stipple[0] = 0xffffffff;
+    stin = 1;
+    stinn = 0;
+    stixs = stixe = 0;
+    stiys = stiye = 0;
+    while(buf < bufend) {
+	doblend = 0;
+	buf += boxextract(buf, data1, cols1, &doblend);
+	if (data1[0] == 32767 && data1[1] == 32767) {
+	    /* box stipple */
+	    if (stinn == 32)
+		continue;
+	    if (stinn == 0) {
+		stixs = data1[2];
+		stixe = data1[3];
+		stiys = stiye = 0;
+	    } else if (stinn == 4) {
+		stiys = data1[2];
+		stiye = data1[3];
+	    }
+	    stipple[stinn++] = (cols1[ 0] << 24) | (cols1[ 1] << 16) | (cols1[ 2] << 8) | cols1[ 3] ;
+	    stipple[stinn++] = (cols1[ 4] << 24) | (cols1[ 5] << 16) | (cols1[ 6] << 8) | cols1[ 7] ;
+	    stipple[stinn++] = (cols1[ 8] << 24) | (cols1[ 9] << 16) | (cols1[10] << 8) | cols1[11] ;
+	    stipple[stinn++] = (cols1[12] << 24) | (cols1[13] << 16) | (cols1[14] << 8) | cols1[15] ;
+	    stin = stinn;
+	    continue;
+	}
+	stinn = 0;
+	if (data1[0] > 32767)
+	    buf += boxextract(buf, data2, cols2, &doblend);
+	if (data1[0] == 32767 && data1[1] == 32766) {
+	    /* box copy */
+	    i = 12 * (short)data1[3];
+	    doblend = 0;
+	    i += boxextract(buf + i, data1, cols1, &doblend);
+	    if (data1[0] > 32767)
+		boxextract(buf + i, data2, cols2, &doblend);
+	}
+	if (data1[0] == 32767)
+	    continue;
+	if (data1[2] > 32767) {
+	    if (overpaint)
+		continue;
+	    data1[2] = ~data1[2];
+	}
+	if (data1[3] > 32767) {
+	    if (percent == 65536)
+		continue;
+	    data1[3] = ~data1[3];
+	}
+	if (data1[0] > 32767) {
+	    data1[0] = ~data1[0];
+	    for (i = 0; i < 4; i++)
+		data1[i] = (data1[i] * (65536 - percent) + data2[i] * percent) >> 16;
+	    for (i = 0; i < 16; i++)
+		cols1[i] = (cols1[i] * (65536 - percent) + cols2[i] * percent) >> 16;
+	}
+	*(unsigned int *)cols2 = *(unsigned int *)cols1;
+	a = cols2[3];
+	if (a == 0 && !doblend)
+	    continue;
+
+	if (stixs >= 32768) {
+	    xo = xs = (stixs ^ 65535) + data1[0];
+	    xe = stixe ? stixe + data1[0] : data1[2];
+	} else if (stixe >= 32768) {
+	    xs = stixs ? data1[2] - stixs : data1[0];
+	    xe = data1[2] - (stixe ^ 65535);
+	    xo = xe + 1;
+	} else {
+	    xo = xs = stixs;
+	    xe = stixe ? stixe : data1[2];
+	}
+	if (stiys >= 32768) {
+	    yo = ys = (stiys ^ 65535) + data1[1];
+	    ye = stiye ? stiye + data1[1] : data1[3];
+	} else if (stiye >= 32768) {
+	    ys = stiys ? data1[3] - stiys : data1[1];
+	    ye = data1[3] - (stiye ^ 65535);
+	    yo = ye + 1;
+	} else {
+	    yo = ys = stiys;
+	    ye = stiye ? stiye : data1[3];
+	}
+	xo = 32 - (xo & 31);
+	yo = stin - (yo % stin);
+	if (xs < data1[0])
+	    xs = data1[0];
+	if (xe > data1[2])
+	    xe = data1[2];
+	if (ys < data1[1])
+	    ys = data1[1];
+	if (ye > data1[3])
+	    ye = data1[3];
+
+	for (y = ys; y <= ye; y++) {
+	    sti = stipple[(y + yo) % stin];
+	    x = (xs + xo) & 31;
+	    if (x)
+		sti = (sti << x) | (sti >> (32 - x));
+	    if (doblend) {
+		if ((p = data1[3] - data1[1]) != 0)
+		    p = ((y - data1[1]) << 16) / p;
+		for (i = 0; i < 8; i++)
+		    cols2[i + 8] = (cols1[i] * (65536 - p) + cols1[i + 8] * p) >> 16;
+	    }
+	    add = (xs & 1);
+	    add ^= (add ^ y) & 1 ? 1 : 3;		/* 2x2 ordered dithering */
+	    picp = (unsigned short *)(pic + xs * 2 + y * bytes);
+	    for (x = xs; x <= xe; x++) {
+		if (!(sti & 0x80000000)) {
+		    sti <<= 1;
+		    picp++;
+		    add ^= 3;
+		    continue;
+		}
+		sti = (sti << 1) | 1;
+		if (doblend) {
+		    if ((p = data1[2] - data1[0]) != 0)
+			p = ((x - data1[0]) << 16) / p;
+		    for (i = 0; i < 4; i++)
+			cols2[i] = (cols2[i + 8] * (65536 - p) + cols2[i + 12] * p) >> 16;
+		    a = cols2[3];
+		}
+		r = cols2[0];
+		g = cols2[1];
+		b = cols2[2];
+		if (a != 255) {
+		    i = *picp;
+		    r = ((i >> 8 & 0xf8) * (255 - a) + r * a) / 255;
+		    g = ((i >> 3 & 0xfc) * (255 - a) + g * a) / 255;
+		    b = ((i << 3 & 0xf8) * (255 - a) + b * a) / 255;
+		}
+  #define CLAMP(x) ((x) >= 256 ? 255 : (x))
+		i = ((CLAMP(r + add*2+1) & 0xf8) <<  8) |
+		    ((CLAMP(g + add    ) & 0xfc) <<  3) |
+		    ((CLAMP(b + add*2+1)       ) >>  3);
+		*picp++ = i;
+		add ^= 3;
+	    }
+	}
+    }
+}
+
+static int splash_check_jpeg(unsigned char *jpeg, int width, int height, int depth)
+{
+    int size, err;
+    unsigned char *mem;
+
+    size = ((width + 15) & ~15) * ((height + 15) & ~15) * (depth >> 3);
+    mem = vmalloc(size);
+    if (!mem) {
+	printk(KERN_INFO "bootsplash: no memory for decoded picture.\n");
+	return -1;
+    }
+    if (!decdata)
+	decdata = vmalloc(sizeof(*decdata));
+    if ((err = jpeg_decode(jpeg, mem, ((width + 15) & ~15), ((height + 15) & ~15), depth, decdata)))
+	  printk(KERN_INFO "bootsplash: error while decompressing picture: %s (%d)\n",jpg_errors[err - 1], err);
+    vfree(mem);
+    return err ? -1 : 0;
+}
+
+static void splash_free(struct vc_data *vc, struct fb_info *info)
+{
+    if (!vc->vc_splash_data)
+	return;
+    if (info->silent_screen_base)
+	    info->screen_base = info->silent_screen_base;
+    info->silent_screen_base = 0;
+    if (vc->vc_splash_data->splash_silentjpeg)
+	    vfree(vc->vc_splash_data->splash_sboxes);
+    vfree(vc->vc_splash_data);
+    vc->vc_splash_data = 0;
+    info->splash_data = 0;
+}
+
+static int splash_mkpenguin(struct splash_data *data, int pxo, int pyo, int pwi, int phe, int pr, int pg, int pb)
+{
+    unsigned char *buf;
+    int i;
+
+    if (pwi ==0 || phe == 0)
+	return 0;
+    buf = (unsigned char *)data + sizeof(*data);
+    pwi += pxo - 1;
+    phe += pyo - 1;
+    *buf++ = pxo;
+    *buf++ = pxo >> 8;
+    *buf++ = pyo;
+    *buf++ = pyo >> 8;
+    *buf++ = pwi;
+    *buf++ = pwi >> 8;
+    *buf++ = phe;
+    *buf++ = phe >> 8;
+    *buf++ = pr;
+    *buf++ = pg;
+    *buf++ = pb;
+    *buf++ = 0;
+    for (i = 0; i < 12; i++, buf++)
+	*buf = buf[-12];
+    buf[-24] ^= 0xff;
+    buf[-23] ^= 0xff;
+    buf[-1] = 0xff;
+    return 2;
+}
+
+static const int splash_offsets[3][16] = {
+    /* len, unit, size, state, fgcol, col, xo, yo, wi, he
+       boxcnt, ssize, sboxcnt, percent, overok, palcnt */
+    /* V1 */
+    {   20,   -1,   16,    -1,    -1,  -1,  8, 10, 12, 14,
+           -1,    -1,      -1,      -1,     -1,     -1 },
+    /* V2 */
+    {   35,    8,   12,     9,    10,  11, 16, 18, 20, 22,
+           -1,    -1,      -1,      -1,     -1,     -1 },
+    /* V3 */
+    {   38,    8,   12,     9,    10,  11, 16, 18, 20, 22,
+           24,    28,      32,      34,     36,     37 },
+};
+
+#define SPLASH_OFF_LEN     offsets[0]
+#define SPLASH_OFF_UNIT    offsets[1]
+#define SPLASH_OFF_SIZE    offsets[2]
+#define SPLASH_OFF_STATE   offsets[3]
+#define SPLASH_OFF_FGCOL   offsets[4]
+#define SPLASH_OFF_COL     offsets[5]
+#define SPLASH_OFF_XO      offsets[6]
+#define SPLASH_OFF_YO      offsets[7]
+#define SPLASH_OFF_WI      offsets[8]
+#define SPLASH_OFF_HE      offsets[9]
+#define SPLASH_OFF_BOXCNT  offsets[10]
+#define SPLASH_OFF_SSIZE   offsets[11]
+#define SPLASH_OFF_SBOXCNT offsets[12]
+#define SPLASH_OFF_PERCENT offsets[13]
+#define SPLASH_OFF_OVEROK  offsets[14]
+#define SPLASH_OFF_PALCNT  offsets[15]
+
+static inline int splash_getb(unsigned char *pos, int off)
+{
+    return off == -1 ? 0 : pos[off];
+}
+
+static inline int splash_gets(unsigned char *pos, int off)
+{
+    return off == -1 ? 0 : pos[off] | pos[off + 1] << 8;
+}
+
+static inline int splash_geti(unsigned char *pos, int off)
+{
+    return off == -1 ? 0 :
+           pos[off] | pos[off + 1] << 8 | pos[off + 2] << 16 | pos[off + 3] << 24;
+}
+
+static int splash_getraw(unsigned char *start, unsigned char *end)
+{
+    unsigned char *ndata;
+    int version;
+    int splash_size;
+    int unit;
+    int width, height;
+    int silentsize;
+    int boxcnt;
+    int sboxcnt;
+    int palcnt;
+    int i, len;
+    const int *offsets;
+    struct vc_data *vc;
+    struct fb_info *info;
+    struct splash_data *sd;
+
+    printk(KERN_INFO "bootsplash %s: looking for picture...", SPLASH_VERSION);
+
+    for (ndata = start; ndata < end; ndata++) {
+	if (ndata[0] != 'B' || ndata[1] != 'O' || ndata[2] != 'O' || ndata[3] != 'T')
+	    continue;
+	if (ndata[4] != 'S' || ndata[5] != 'P' || ndata[6] != 'L' || ndata[7] < '1' || ndata[7] > '3')
+	    continue;
+	printk(".");
+	version = ndata[7] - '0';
+	offsets = splash_offsets[version - 1];
+	len = SPLASH_OFF_LEN;
+	unit = splash_getb(ndata, SPLASH_OFF_UNIT);
+	if (unit >= MAX_NR_CONSOLES)
+	    continue;
+	if (unit) {
+		acquire_console_sem();
+		vc_allocate(unit);
+		release_console_sem();
+	}
+	vc = vc_cons[unit].d;
+	info = registered_fb[(int)con2fb_map[unit]];
+	width = info->var.xres;
+	height = info->var.yres;
+	splash_size = splash_geti(ndata, SPLASH_OFF_SIZE);
+	if (splash_size == (int)0xffffffff && version > 1) {
+	    printk(" found, updating values.\n");
+	    if ((sd = vc->vc_splash_data) != 0) {
+		i = splash_getb(ndata, SPLASH_OFF_STATE);
+		if (i != 255)
+		    sd->splash_state = i;
+		i = splash_getb(ndata, SPLASH_OFF_FGCOL);
+		if (i != 255)
+		    sd->splash_fg_color = i;
+		i = splash_getb(ndata, SPLASH_OFF_COL);
+		if (i != 255)
+		    sd->splash_color = i;
+	    }
+	    return unit;
+	}
+	if (splash_size == 0) {
+	    printk(" found, freeing memory.\n");
+	    if (vc->vc_splash_data)
+		splash_free(vc, info);
+	    return unit;
+	}
+	boxcnt = splash_gets(ndata, SPLASH_OFF_BOXCNT);
+	palcnt = 3 * splash_getb(ndata, SPLASH_OFF_PALCNT);
+	if (ndata + len + splash_size > end) {
+	    printk(" found, but truncated!\n");
+	    return -1;
+	}
+	if (!jpeg_check_size(ndata + len + boxcnt * 12 + palcnt, width, height)) {
+	    ndata += len + splash_size - 1;
+	    continue;
+	}
+	if (splash_check_jpeg(ndata + len + boxcnt * 12 + palcnt, width, height, info->var.bits_per_pixel))
+	    return -1;
+	silentsize = splash_geti(ndata, SPLASH_OFF_SSIZE);
+	if (silentsize)
+	    printk(" silentjpeg size %d bytes,", silentsize);
+	if (silentsize >= splash_size) {
+	    printk(" bigger than splashsize!\n");
+	    return -1;
+	}
+	splash_size -= silentsize;
+	if (!splash_usesilent)
+	    silentsize = 0;
+	else if (height * 2 * info->fix.line_length > info->fix.smem_len) {
+	    printk(" does not fit into framebuffer.\n");
+	    silentsize = 0;
+	}
+	sboxcnt = splash_gets(ndata, SPLASH_OFF_SBOXCNT);
+	if (silentsize) {
+	    unsigned char *simage = ndata + len + splash_size + 12 * sboxcnt;
+	    if (!jpeg_check_size(simage, width, height) ||
+		splash_check_jpeg(simage, width, height, info->var.bits_per_pixel)) {
+		    printk(" error in silent jpeg.\n");
+		    silentsize = 0;
+		}
+	}
+	if (vc->vc_splash_data)
+	    splash_free(vc, info);
+	vc->vc_splash_data = sd = vmalloc(sizeof(*sd) + splash_size + (version < 3 ? 2 * 12 : 0));
+	if (!sd)
+	    break;
+	sd->splash_silentjpeg = 0;
+	sd->splash_sboxes = 0;
+	sd->splash_sboxcount = 0;
+	if (silentsize) {
+	    sd->splash_silentjpeg = vmalloc(silentsize);
+	    if (sd->splash_silentjpeg) {
+		memcpy(sd->splash_silentjpeg, ndata + len + splash_size, silentsize);
+		sd->splash_sboxes = vc->vc_splash_data->splash_silentjpeg;
+		sd->splash_silentjpeg += 12 * sboxcnt;
+		sd->splash_sboxcount = sboxcnt;
+	    }
+	}
+	sd->splash_state = splash_getb(ndata, SPLASH_OFF_STATE);
+	sd->splash_fg_color = splash_getb(ndata, SPLASH_OFF_FGCOL);
+	sd->splash_color = splash_getb(ndata, SPLASH_OFF_COL);
+	sd->splash_overpaintok = splash_getb(ndata, SPLASH_OFF_OVEROK);
+	sd->splash_text_xo = splash_gets(ndata, SPLASH_OFF_XO);
+	sd->splash_text_yo = splash_gets(ndata, SPLASH_OFF_YO);
+	sd->splash_text_wi = splash_gets(ndata, SPLASH_OFF_WI);
+	sd->splash_text_he = splash_gets(ndata, SPLASH_OFF_HE);
+	sd->splash_percent = splash_gets(ndata, SPLASH_OFF_PERCENT);
+	if (version == 1) {
+	    sd->splash_text_xo *= 8;
+	    sd->splash_text_wi *= 8;
+	    sd->splash_text_yo *= 16;
+	    sd->splash_text_he *= 16;
+	    sd->splash_color    = (splash_default >> 8) & 0x0f;
+	    sd->splash_fg_color = (splash_default >> 4) & 0x0f;
+	    sd->splash_state    = splash_default & 1;
+	}
+	if (sd->splash_text_xo + sd->splash_text_wi > width || sd->splash_text_yo + sd->splash_text_he > height) {
+	    splash_free(vc, info);
+	    printk(" found, but has oversized text area!\n");
+	    return -1;
+	}
+	if (!vc_cons[unit].d || info->fbops != &vesafb_ops) {
+	    splash_free(vc, info);
+	    printk(" found, but framebuffer can't handle it!\n");
+	    return -1;
+	}
+	printk(" found (%dx%d, %d bytes, v%d).\n", width, height, splash_size, version);
+	if (version == 1) {
+	    printk(KERN_WARNING "bootsplash: Using deprecated v1 header. Updating your splash utility recommended.\n");
+	    printk(KERN_INFO    "bootsplash: Find the latest version at http://www.bootsplash.org/\n");
+	}
+
+	/* fake penguin box for older formats */
+	if (version == 1)
+	    boxcnt = splash_mkpenguin(sd, sd->splash_text_xo + 10, sd->splash_text_yo + 10, sd->splash_text_wi - 20, sd->splash_text_he - 20, 0xf0, 0xf0, 0xf0);
+	else if (version == 2)
+	    boxcnt = splash_mkpenguin(sd, splash_gets(ndata, 24), splash_gets(ndata, 26), splash_gets(ndata, 28), splash_gets(ndata, 30), splash_getb(ndata, 32), splash_getb(ndata, 33), splash_getb(ndata, 34));
+
+	memcpy((char *)sd + sizeof(*sd) + (version < 3 ? boxcnt * 12 : 0), ndata + len, splash_size);
+	sd->splash_boxcount = boxcnt;
+	sd->splash_boxes = (unsigned char *)sd + sizeof(*sd);
+	sd->splash_palette = sd->splash_boxes + boxcnt * 12;
+	sd->splash_jpeg = sd->splash_palette + palcnt;
+	sd->splash_palcnt = palcnt / 3;
+	sd->splash_dosilent = sd->splash_silentjpeg != 0;
+	return unit;
+    }
+    printk(" no good signature found.\n");
+    return -1;
+}
+
+int splash_verbose(void) 
+{
+    struct vc_data *vc;
+    struct fb_info *info;
+
+    if (!splash_usesilent)
+        return 0;
+
+    vc = vc_cons[0].d;
+
+    if (!vc || !vc->vc_splash_data || !vc->vc_splash_data->splash_state)
+	return 0;
+    if (fg_console != vc->vc_num)
+	return 0;
+    if (!vc->vc_splash_data->splash_silentjpeg || !vc->vc_splash_data->splash_dosilent)
+	return 0;
+    vc->vc_splash_data->splash_dosilent = 0;
+    info = registered_fb[(int)con2fb_map[0]];
+    if (!info->silent_screen_base)
+	return 0;
+    splashcopy(info->silent_screen_base, info->screen_base, info->var.yres, info->var.xres, info->fix.line_length, info->fix.line_length);
+    info->screen_base = info->silent_screen_base;
+    info->silent_screen_base = 0;
+    return 1;
+}
+
+static void splash_off(struct fb_info *info)
+{
+	if (info->silent_screen_base)
+		info->screen_base = info->silent_screen_base;
+	info->silent_screen_base = 0;
+	info->splash_data = 0;
+	if (info->splash_pic)
+		vfree(info->splash_pic);
+	info->splash_pic = 0;
+	info->splash_pic_size = 0;
+}
+
+int splash_prepare(struct vc_data *vc, struct fb_info *info)
+{
+	int err;
+        int width, height, depth, size, sbytes;
+
+	if (!vc->vc_splash_data || !vc->vc_splash_data->splash_state) {
+		if (decdata)
+			vfree(decdata);
+		decdata = 0;
+		splash_off(info);
+		return -1;
+	}
+
+        width = info->var.xres;
+        height = info->var.yres;
+        depth = info->var.bits_per_pixel;
+	if (depth != 16) {	/* Other targets might need fixing */
+		splash_off(info);
+		return -2;
+	}
+
+	sbytes = ((width + 15) & ~15) * (depth >> 3);
+	size = sbytes * ((height + 15) & ~15);
+	if (size != info->splash_pic_size)
+		splash_off(info);
+	if (!info->splash_pic)
+		info->splash_pic = vmalloc(size);
+
+	if (!info->splash_pic) {
+		printk(KERN_INFO "bootsplash: not enough memory.\n");
+		splash_off(info);
+		return -3;
+	}
+
+	if (!decdata)
+		decdata = vmalloc(sizeof(*decdata));
+
+	if (vc->vc_splash_data->splash_silentjpeg && vc->vc_splash_data->splash_dosilent) {
+		/* fill area after framebuffer with other jpeg */
+		if ((err = jpeg_decode(vc->vc_splash_data->splash_silentjpeg, info->splash_pic, 
+			 ((width + 15) & ~15), ((height + 15) & ~15), depth, decdata))) {
+			printk(KERN_INFO "bootsplash: error while decompressing silent picture: %s (%d)\n", jpg_errors[err - 1], err);
+			if (info->silent_screen_base)
+				info->screen_base = info->silent_screen_base;
+			vc->vc_splash_data->splash_dosilent = 0;
+		} else {
+			if (vc->vc_splash_data->splash_sboxcount)
+				boxit(info->splash_pic, sbytes, vc->vc_splash_data->splash_sboxes, 
+					vc->vc_splash_data->splash_sboxcount, vc->vc_splash_data->splash_percent, 0);
+
+			if (!info->silent_screen_base)
+				info->silent_screen_base = info->screen_base;
+			splashcopy(info->silent_screen_base, info->splash_pic, info->var.yres, info->var.xres, info->fix.line_length, sbytes);
+			info->screen_base = info->silent_screen_base + info->fix.line_length * info->var.yres;
+		}
+	} else if (info->silent_screen_base)
+		info->screen_base = info->silent_screen_base;
+
+	if ((err = jpeg_decode(vc->vc_splash_data->splash_jpeg, info->splash_pic, 
+		 ((width + 15) & ~15), ((height + 15) & ~15), depth, decdata))) {
+		printk(KERN_INFO "bootsplash: error while decompressing picture: %s (%d) .\n", jpg_errors[err - 1], err);
+		splash_off(info);
+		return -4;
+	}
+	info->splash_pic_size = size;
+	info->splash_bytes = sbytes;
+	if (vc->vc_splash_data->splash_boxcount)
+		boxit(info->splash_pic, sbytes, vc->vc_splash_data->splash_boxes, vc->vc_splash_data->splash_boxcount, vc->vc_splash_data->splash_percent, 0);
+	if (vc->vc_splash_data->splash_state)
+		info->splash_data = vc->vc_splash_data;
+	else
+		splash_off(info);
+	return 0;
+}
+
+
+#ifdef CONFIG_PROC_FS
+
+#include <linux/proc_fs.h>
+
+static int splash_read_proc(char *buffer, char **start, off_t offset, int size,
+			int *eof, void *data);
+static int splash_write_proc(struct file *file, const char *buffer,
+			unsigned long count, void *data);
+static int splash_status(struct vc_data *vc);
+static int splash_recolor(struct vc_data *vc);
+static int splash_proc_register(void);
+
+static struct proc_dir_entry *proc_splash;
+
+static int splash_recolor(struct vc_data *vc)
+{
+	if (!vc->vc_splash_data)
+	    return -1;
+	if (!vc->vc_splash_data->splash_state)
+	    return 0;
+	con_remap_def_color(vc->vc_num, vc->vc_splash_data->splash_color << 4 | vc->vc_splash_data->splash_fg_color);
+	if (fg_console == vc->vc_num) {
+		update_region(fg_console,
+			      vc->vc_origin + vc->vc_size_row * vc->vc_top,
+			      vc->vc_size_row * (vc->vc_bottom - vc->vc_top) / 2);
+	}
+	return 0;
+}
+
+static int splash_status(struct vc_data *vc)
+{
+	struct fb_info *info;
+	printk(KERN_INFO "bootsplash: status on console %d changed to %s\n", vc->vc_num, vc->vc_splash_data && vc->vc_splash_data->splash_state ? "on" : "off");
+
+	info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	if (fg_console == vc->vc_num)
+		splash_prepare(vc, info);
+	if (vc->vc_splash_data && vc->vc_splash_data->splash_state) {
+		con_remap_def_color(vc->vc_num, vc->vc_splash_data->splash_color << 4 | vc->vc_splash_data->splash_fg_color);
+		acquire_console_sem();
+		/* vc_resize also calls con_switch which resets yscroll */
+		vc_resize(vc->vc_num, vc->vc_splash_data->splash_text_wi / vc->vc_font.width, vc->vc_splash_data->splash_text_he / vc->vc_font.height);
+		if (fg_console == vc->vc_num) {
+			update_region(fg_console,
+				      vc->vc_origin + vc->vc_size_row * vc->vc_top,
+				      vc->vc_size_row * (vc->vc_bottom - vc->vc_top) / 2);
+			splash_clear_margins(vc->vc_splash_data, vc, info, 0);
+		}
+		release_console_sem();
+	} else {
+	  	/* Switch bootsplash off */
+		con_remap_def_color(vc->vc_num, 0x07);
+		acquire_console_sem();
+		vc_resize(vc->vc_num, info->var.xres / vc->vc_font.width, info->var.yres / vc->vc_font.height);
+		release_console_sem();
+	}
+	return 0;
+}
+
+static int splash_read_proc(char *buffer, char **start, off_t offset, int size,
+			int *eof, void *data)
+{
+	int len = 0;
+	off_t begin = 0;
+	struct vc_data *vc = vc_cons[0].d;
+	struct fb_info *info = registered_fb[(int)con2fb_map[0]];
+	int color = vc->vc_splash_data ? vc->vc_splash_data->splash_color << 4 |
+			vc->vc_splash_data->splash_fg_color : splash_default >> 4;
+	int status = vc->vc_splash_data ? vc->vc_splash_data->splash_state & 1 : 0;
+	len += sprintf(buffer + len, "Splash screen v%s (0x%02x, %dx%d%s): %s\n",
+		        SPLASH_VERSION, color, info->var.xres, info->var.yres,
+			(vc->vc_splash_data ?  vc->vc_splash_data->splash_dosilent : 0)? ", silent" : "",
+					status ? "on" : "off");
+	if (offset >= begin + len)
+		return 0;
+
+	*start = buffer + (begin - offset);
+
+	return (size < begin + len - offset ? size : begin + len - offset);
+}
+
+static int splash_write_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+        int new, unit;
+	struct vc_data *vc;
+	
+	if (!buffer || !splash_default)
+		return count;
+
+	if (!strncmp(buffer, "show", 4) || !strncmp(buffer, "hide", 4)) {
+		int pe, oldpe;
+
+		vc = vc_cons[0].d;
+		if (buffer[4] == ' ' && buffer[5] == 'p')
+			pe = 0;
+		else if (buffer[4] == '\n')
+			pe = 65535;
+		else
+			pe = simple_strtoul(buffer + 5, NULL, 0);
+		if (pe < 0)
+			pe = 0;
+		if (pe > 65535)
+			pe = 65535;
+		if (*buffer == 'h')
+			pe = 65535 - pe;
+		pe += pe > 32767;
+		if (vc->vc_splash_data && vc->vc_splash_data->splash_percent != pe) {
+			struct fb_info *info;
+
+			oldpe = vc->vc_splash_data->splash_percent;
+			vc->vc_splash_data->splash_percent = pe;
+			if (fg_console != 0 || !vc->vc_splash_data->splash_state)
+			    return count;
+			info = registered_fb[(int) con2fb_map[vc->vc_num]];
+			if (!vc->vc_splash_data->splash_overpaintok || pe == 65536 || pe < oldpe) {
+				if (splash_hasinter(vc->vc_splash_data->splash_boxes, vc->vc_splash_data->splash_boxcount))
+					splash_status(vc);
+				else
+					splash_prepare(vc, info);
+			} else {
+				if (vc->vc_splash_data->splash_silentjpeg && vc->vc_splash_data->splash_dosilent && info->silent_screen_base)
+					boxit(info->silent_screen_base, info->fix.line_length, vc->vc_splash_data->splash_sboxes, vc->vc_splash_data->splash_sboxcount, vc->vc_splash_data->splash_percent, 1);
+				boxit(info->screen_base, info->fix.line_length, vc->vc_splash_data->splash_boxes, vc->vc_splash_data->splash_boxcount, vc->vc_splash_data->splash_percent, 1);
+			}
+		}
+		return count;
+	}
+	if (!strncmp(buffer,"silent\n",7) || !strncmp(buffer,"verbose\n",8)) {
+		vc = vc_cons[0].d;
+		if (vc->vc_splash_data && vc->vc_splash_data->splash_silentjpeg) {
+		    if (vc->vc_splash_data->splash_dosilent != (buffer[0] == 's')) {
+			vc->vc_splash_data->splash_dosilent = buffer[0] == 's';
+			splash_status(vc);
+		    }
+		}
+		return count;
+	}
+	if (!strncmp(buffer,"freesilent\n",11)) {
+		vc = vc_cons[0].d;
+		if (vc->vc_splash_data && vc->vc_splash_data->splash_silentjpeg) {
+		    printk(KERN_INFO "bootsplash: freeing silent jpeg\n");
+		    vc->vc_splash_data->splash_silentjpeg = 0;
+		    vfree(vc->vc_splash_data->splash_sboxes);
+		    vc->vc_splash_data->splash_sboxes = 0;
+		    vc->vc_splash_data->splash_sboxcount = 0;
+		    if (vc->vc_splash_data->splash_dosilent)
+			splash_status(vc);
+		    vc->vc_splash_data->splash_dosilent = 0;
+		}
+		return count;
+	}
+
+	if (!strncmp(buffer, "BOOTSPL", 7)) {
+	    unit = splash_getraw((unsigned char *)buffer, (unsigned char *)buffer + count);
+	    if (unit >= 0) {
+		vc = vc_cons[unit].d;
+		splash_status(vc);
+	    }
+	    return count;
+	}
+	vc = vc_cons[0].d;
+	if (!vc->vc_splash_data)
+		return count;
+	if (buffer[0] == 't') {
+	        vc->vc_splash_data->splash_state ^= 1;
+		splash_status(vc);
+		return count;
+	}
+	new = simple_strtoul(buffer, NULL, 0);
+	if (new > 1) {
+		/* expert user */
+		vc->vc_splash_data->splash_color    = new >> 8 & 0xff;
+		vc->vc_splash_data->splash_fg_color = new >> 4 & 0x0f;
+	}
+	if ((new & 1) == vc->vc_splash_data->splash_state)
+		splash_recolor(vc);
+	else {
+		vc->vc_splash_data->splash_state = new & 1;
+		splash_status(vc);
+	}
+	return count;
+}
+
+static int splash_proc_register(void)
+{
+	if ((proc_splash = create_proc_entry("splash", 0, 0))) {
+		proc_splash->read_proc = splash_read_proc;
+		proc_splash->write_proc = splash_write_proc;
+		return 0;
+	}
+	return 1;
+}
+
+# if 0
+static int splash_proc_unregister(void)
+{
+	if (proc_splash)
+		remove_proc_entry("splash", 0);
+	return 0;
+}
+# endif
+#endif	/* CONFIG_PROC_FS */
+
+void splash_init(void)
+{
+	struct fb_info *info;
+	struct vc_data *vc;
+	int isramfs = 1;
+	int fd;
+	int len;
+	int max_len = 1024*1024*2;
+	char *mem;
+
+	if (splash_registered)
+		return;
+	vc = vc_cons[0].d;
+	info = registered_fb[0];
+	if (!vc || !info || info->var.bits_per_pixel != 16)
+		return;
+#ifdef CONFIG_PROC_FS
+	splash_proc_register();
+#endif
+	splash_registered = 1;
+	if (vc->vc_splash_data)
+		return;
+	if ((fd = sys_open("/bootsplash", O_RDONLY, 0)) < 0) {
+		isramfs = 0;
+		fd = sys_open("/initrd.image", O_RDONLY, 0);
+	}
+	if (fd < 0)
+		return;
+	if ((len = (int)sys_lseek(fd, (off_t)0, 2)) <= 0) {
+		sys_close(fd);
+		return;
+	}
+	/* Don't look for more than the last 2MB */
+	if (len > max_len) {
+		printk( KERN_INFO "bootsplash: scanning last %dMB of initrd for signature\n",
+				max_len>>20);
+		sys_lseek(fd, (off_t)(len - max_len), 0);
+		len = max_len;
+	} else {
+		sys_lseek(fd, (off_t)0, 0);
+	}
+
+	mem = vmalloc(len);
+	if (mem) {
+		if ((int)sys_read(fd, mem, len) == len && splash_getraw((unsigned char *)mem, (unsigned char *)mem + len) == 0 && vc->vc_splash_data)
+			vc->vc_splash_data->splash_state = splash_default & 1;
+		vfree(mem);
+	}
+	sys_close(fd);
+	if (isramfs)
+		sys_unlink("/bootsplash");
+	return;
+}
+
Index: drivers/video/bootsplash/bootsplash.h
===================================================================
--- .orig/drivers/video/bootsplash/bootsplash.h
+++ /drivers/video/bootsplash/bootsplash.h
@@ -0,0 +1,44 @@
+/* 
+ *    linux/drivers/video/bootsplash/bootsplash.h - splash screen definition.
+ *	
+ *	(w) 2001-2003 by Volker Poplawski, <volker@poplawski.de>
+ * 		    Stefan Reinauer, <stepan@suse.de>
+ * 		    
+ * 		    
+ * 	idea and SuSE screen work by Ken Wimer, <wimer@suse.de>
+ */
+
+#ifndef __BOOTSPLASH_H
+#define __BOOTSPLASH_H
+
+struct fb_info;
+
+/* splash.c */
+extern int splash_prepare(struct vc_data *, struct fb_info *);
+extern void splash_init(void);
+
+/* splash_render.c */
+extern void splash_putcs(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			const unsigned short *s, int count, int ypos, int xpos);
+extern void splash_putc(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			int c, int ypos, int xpos);
+extern void splashcopy(u8 *dst, u8 *src, int height, int width, int dstbytes, int srcbytes);
+extern void splash_clear(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int sy,
+			int sx, int height, int width);
+extern void splash_bmove(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int sy, 
+			int sx, int dy, int dx, int height, int width);
+extern void splash_clear_margins(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			int bottom_only);
+extern void splash_cursor(struct splash_data *sd, struct fb_info *info, struct fb_cursor *cursor);
+extern void splash_bmove_redraw(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			int y, int sx, int dx, int width);
+extern void splash_blank(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			int blank);
+
+/* vt.c */
+extern void con_remap_def_color(int currcons, int new_color);
+
+extern void acquire_console_sem(void);
+extern void release_console_sem(void);
+
+#endif
Index: drivers/video/bootsplash/decode-jpg.c
===================================================================
--- .orig/drivers/video/bootsplash/decode-jpg.c
+++ /drivers/video/bootsplash/decode-jpg.c
@@ -0,0 +1,958 @@
+/* 
+ *    linux/drivers/video/bootsplash/decode-jpg.c - a tiny jpeg decoder.
+ *      
+ *      (w) August 2001 by Michael Schroeder, <mls@suse.de>
+ *                  
+ */
+
+#include <linux/config.h>
+#include <linux/string.h>
+#include <asm/byteorder.h>
+
+#include "decode-jpg.h"
+
+#define ISHIFT 11
+
+#define IFIX(a) ((int)((a) * (1 << ISHIFT) + .5))
+#define IMULT(a, b) (((a) * (b)) >> ISHIFT)
+#define ITOINT(a) ((a) >> ISHIFT)
+
+#ifndef __P
+# define __P(x) x
+#endif
+
+/* special markers */
+#define M_BADHUFF	-1
+#define M_EOF		0x80
+
+struct in {
+	unsigned char *p;
+	unsigned int bits;
+	int left;
+	int marker;
+
+	int (*func) __P((void *));
+	void *data;
+};
+
+/*********************************/
+struct dec_hufftbl;
+struct enc_hufftbl;
+
+union hufftblp {
+	struct dec_hufftbl *dhuff;
+	struct enc_hufftbl *ehuff;
+};
+
+struct scan {
+	int dc;			/* old dc value */
+
+	union hufftblp hudc;
+	union hufftblp huac;
+	int next;		/* when to switch to next scan */
+
+	int cid;		/* component id */
+	int hv;			/* horiz/vert, copied from comp */
+	int tq;			/* quant tbl, copied from comp */
+};
+
+/*********************************/
+
+#define DECBITS 10		/* seems to be the optimum */
+
+struct dec_hufftbl {
+	int maxcode[17];
+	int valptr[16];
+	unsigned char vals[256];
+	unsigned int llvals[1 << DECBITS];
+};
+
+static void decode_mcus __P((struct in *, int *, int, struct scan *, int *));
+static int dec_readmarker __P((struct in *));
+static void dec_makehuff __P((struct dec_hufftbl *, int *, unsigned char *));
+
+static void setinput __P((struct in *, unsigned char *));
+/*********************************/
+
+#undef PREC
+#define PREC int
+
+static void idctqtab __P((unsigned char *, PREC *));
+static void idct __P((int *, int *, PREC *, PREC, int));
+static void scaleidctqtab __P((PREC *, PREC));
+
+/*********************************/
+
+static void initcol __P((PREC[][64]));
+
+static void col221111 __P((int *, unsigned char *, int));
+static void col221111_16 __P((int *, unsigned char *, int));
+
+/*********************************/
+
+#define M_SOI	0xd8
+#define M_APP0	0xe0
+#define M_DQT	0xdb
+#define M_SOF0	0xc0
+#define M_DHT   0xc4
+#define M_DRI	0xdd
+#define M_SOS	0xda
+#define M_RST0	0xd0
+#define M_EOI	0xd9
+#define M_COM	0xfe
+
+static unsigned char *datap;
+
+static int getbyte(void)
+{
+	return *datap++;
+}
+
+static int getword(void)
+{
+	int c1, c2;
+	c1 = *datap++;
+	c2 = *datap++;
+	return c1 << 8 | c2;
+}
+
+struct comp {
+	int cid;
+	int hv;
+	int tq;
+};
+
+#define MAXCOMP 4
+struct jpginfo {
+	int nc;			/* number of components */
+	int ns;			/* number of scans */
+	int dri;		/* restart interval */
+	int nm;			/* mcus til next marker */
+	int rm;			/* next restart marker */
+};
+
+static struct jpginfo info;
+static struct comp comps[MAXCOMP];
+
+static struct scan dscans[MAXCOMP];
+
+static unsigned char quant[4][64];
+
+static struct dec_hufftbl dhuff[4];
+
+#define dec_huffdc (dhuff + 0)
+#define dec_huffac (dhuff + 2)
+
+static struct in in;
+
+static int readtables(int till)
+{
+	int m, l, i, j, lq, pq, tq;
+	int tc, th, tt;
+
+	for (;;) {
+		if (getbyte() != 0xff)
+			return -1;
+		if ((m = getbyte()) == till)
+			break;
+
+		switch (m) {
+		case 0xc2:
+			return 0;
+
+		case M_DQT:
+			lq = getword();
+			while (lq > 2) {
+				pq = getbyte();
+				tq = pq & 15;
+				if (tq > 3)
+					return -1;
+				pq >>= 4;
+				if (pq != 0)
+					return -1;
+				for (i = 0; i < 64; i++)
+					quant[tq][i] = getbyte();
+				lq -= 64 + 1;
+			}
+			break;
+
+		case M_DHT:
+			l = getword();
+			while (l > 2) {
+				int hufflen[16], k;
+				unsigned char huffvals[256];
+
+				tc = getbyte();
+				th = tc & 15;
+				tc >>= 4;
+				tt = tc * 2 + th;
+				if (tc > 1 || th > 1)
+					return -1;
+				for (i = 0; i < 16; i++)
+					hufflen[i] = getbyte();
+				l -= 1 + 16;
+				k = 0;
+				for (i = 0; i < 16; i++) {
+					for (j = 0; j < hufflen[i]; j++)
+						huffvals[k++] = getbyte();
+					l -= hufflen[i];
+				}
+				dec_makehuff(dhuff + tt, hufflen,
+					     huffvals);
+			}
+			break;
+
+		case M_DRI:
+			l = getword();
+			info.dri = getword();
+			break;
+
+		default:
+			l = getword();
+			while (l-- > 2)
+				getbyte();
+			break;
+		}
+	}
+	return 0;
+}
+
+static void dec_initscans(void)
+{
+	int i;
+
+	info.nm = info.dri + 1;
+	info.rm = M_RST0;
+	for (i = 0; i < info.ns; i++)
+		dscans[i].dc = 0;
+}
+
+static int dec_checkmarker(void)
+{
+	int i;
+
+	if (dec_readmarker(&in) != info.rm)
+		return -1;
+	info.nm = info.dri;
+	info.rm = (info.rm + 1) & ~0x08;
+	for (i = 0; i < info.ns; i++)
+		dscans[i].dc = 0;
+	return 0;
+}
+
+int jpeg_check_size(unsigned char *buf, int width, int height)
+{
+  	datap = buf;
+	getbyte(); 
+	getbyte(); 
+	readtables(M_SOF0);
+	getword();
+	getbyte();
+        if (height != getword() || width != getword())
+		return 0;
+        return 1;
+}
+
+int jpeg_decode(buf, pic, width, height, depth, decdata)
+unsigned char *buf, *pic;
+int width, height, depth;
+struct jpeg_decdata *decdata;
+{
+	int i, j, m, tac, tdc;
+	int mcusx, mcusy, mx, my;
+	int max[6];
+
+	if (!decdata)
+		return -1;
+	datap = buf;
+	if (getbyte() != 0xff)
+		return ERR_NO_SOI;
+	if (getbyte() != M_SOI)
+		return ERR_NO_SOI;
+	if (readtables(M_SOF0))
+		return ERR_BAD_TABLES;
+	getword();
+	i = getbyte();
+	if (i != 8)
+		return ERR_NOT_8BIT;
+	if (((getword() + 15) & ~15) != height)
+		return ERR_HEIGHT_MISMATCH;
+	if (((getword() + 15) & ~15) != width)
+		return ERR_WIDTH_MISMATCH;
+	if ((height & 15) || (width & 15))
+		return ERR_BAD_WIDTH_OR_HEIGHT;
+	info.nc = getbyte();
+	if (info.nc > MAXCOMP)
+		return ERR_TOO_MANY_COMPPS;
+	for (i = 0; i < info.nc; i++) {
+		int h, v;
+		comps[i].cid = getbyte();
+		comps[i].hv = getbyte();
+		v = comps[i].hv & 15;
+		h = comps[i].hv >> 4;
+		comps[i].tq = getbyte();
+		if (h > 3 || v > 3)
+			return ERR_ILLEGAL_HV;
+		if (comps[i].tq > 3)
+			return ERR_QUANT_TABLE_SELECTOR;
+	}
+	if (readtables(M_SOS))
+		return ERR_BAD_TABLES;
+	getword();
+	info.ns = getbyte();
+	if (info.ns != 3)
+		return ERR_NOT_YCBCR_221111;
+	for (i = 0; i < 3; i++) {
+		dscans[i].cid = getbyte();
+		tdc = getbyte();
+		tac = tdc & 15;
+		tdc >>= 4;
+		if (tdc > 1 || tac > 1)
+			return ERR_QUANT_TABLE_SELECTOR;
+		for (j = 0; j < info.nc; j++)
+			if (comps[j].cid == dscans[i].cid)
+				break;
+		if (j == info.nc)
+			return ERR_UNKNOWN_CID_IN_SCAN;
+		dscans[i].hv = comps[j].hv;
+		dscans[i].tq = comps[j].tq;
+		dscans[i].hudc.dhuff = dec_huffdc + tdc;
+		dscans[i].huac.dhuff = dec_huffac + tac;
+	}
+	
+	i = getbyte();
+	j = getbyte();
+	m = getbyte();
+	
+	if (i != 0 || j != 63 || m != 0)
+		return ERR_NOT_SEQUENTIAL_DCT;
+	
+	if (dscans[0].cid != 1 || dscans[1].cid != 2 || dscans[2].cid != 3)
+		return ERR_NOT_YCBCR_221111;
+
+	if (dscans[0].hv != 0x22 || dscans[1].hv != 0x11 || dscans[2].hv != 0x11)
+		return ERR_NOT_YCBCR_221111;
+
+	mcusx = width >> 4;
+	mcusy = height >> 4;
+
+
+	idctqtab(quant[dscans[0].tq], decdata->dquant[0]);
+	idctqtab(quant[dscans[1].tq], decdata->dquant[1]);
+	idctqtab(quant[dscans[2].tq], decdata->dquant[2]);
+	initcol(decdata->dquant);
+	setinput(&in, datap);
+
+#if 0
+	/* landing zone */
+	img[len] = 0;
+	img[len + 1] = 0xff;
+	img[len + 2] = M_EOF;
+#endif
+
+	dec_initscans();
+
+	dscans[0].next = 6 - 4;
+	dscans[1].next = 6 - 4 - 1;
+	dscans[2].next = 6 - 4 - 1 - 1;	/* 411 encoding */
+	for (my = 0; my < mcusy; my++) {
+		for (mx = 0; mx < mcusx; mx++) {
+			if (info.dri && !--info.nm)
+				if (dec_checkmarker())
+					return ERR_WRONG_MARKER;
+			
+			decode_mcus(&in, decdata->dcts, 6, dscans, max);
+			idct(decdata->dcts, decdata->out, decdata->dquant[0], IFIX(128.5), max[0]);
+			idct(decdata->dcts + 64, decdata->out + 64, decdata->dquant[0], IFIX(128.5), max[1]);
+			idct(decdata->dcts + 128, decdata->out + 128, decdata->dquant[0], IFIX(128.5), max[2]);
+			idct(decdata->dcts + 192, decdata->out + 192, decdata->dquant[0], IFIX(128.5), max[3]);
+			idct(decdata->dcts + 256, decdata->out + 256, decdata->dquant[1], IFIX(0.5), max[4]);
+			idct(decdata->dcts + 320, decdata->out + 320, decdata->dquant[2], IFIX(0.5), max[5]);
+
+			switch (depth) {
+			case 24:
+				col221111(decdata->out, pic + (my * 16 * mcusx + mx) * 16 * 3, mcusx * 16 * 3);
+				break;
+			case 16:
+				col221111_16(decdata->out, pic + (my * 16 * mcusx + mx) * (16 * 2), mcusx * (16 * 2));
+				break;
+			default:
+				return ERR_DEPTH_MISMATCH;
+				break;
+			}
+		}
+	}
+	
+	m = dec_readmarker(&in);
+	if (m != M_EOI)
+		return ERR_NO_EOI;
+
+	return 0;
+}
+
+/****************************************************************/
+/**************       huffman decoder             ***************/
+/****************************************************************/
+
+static int fillbits __P((struct in *, int, unsigned int));
+static int dec_rec2
+__P((struct in *, struct dec_hufftbl *, int *, int, int));
+
+static void setinput(in, p)
+struct in *in;
+unsigned char *p;
+{
+	in->p = p;
+	in->left = 0;
+	in->bits = 0;
+	in->marker = 0;
+}
+
+static int fillbits(in, le, bi)
+struct in *in;
+int le;
+unsigned int bi;
+{
+	int b, m;
+
+	if (in->marker) {
+		if (le <= 16)
+			in->bits = bi << 16, le += 16;
+		return le;
+	}
+	while (le <= 24) {
+		b = *in->p++;
+		if (b == 0xff && (m = *in->p++) != 0) {
+			if (m == M_EOF) {
+				if (in->func && (m = in->func(in->data)) == 0)
+					continue;
+			}
+			in->marker = m;
+			if (le <= 16)
+				bi = bi << 16, le += 16;
+			break;
+		}
+		bi = bi << 8 | b;
+		le += 8;
+	}
+	in->bits = bi;		/* tmp... 2 return values needed */
+	return le;
+}
+
+static int dec_readmarker(in)
+struct in *in;
+{
+	int m;
+
+	in->left = fillbits(in, in->left, in->bits);
+	if ((m = in->marker) == 0)
+		return 0;
+	in->left = 0;
+	in->marker = 0;
+	return m;
+}
+
+#define LEBI_DCL	int le, bi
+#define LEBI_GET(in)	(le = in->left, bi = in->bits)
+#define LEBI_PUT(in)	(in->left = le, in->bits = bi)
+
+#define GETBITS(in, n) (					\
+  (le < (n) ? le = fillbits(in, le, bi), bi = in->bits : 0),	\
+  (le -= (n)),							\
+  bi >> le & ((1 << (n)) - 1)					\
+)
+
+#define UNGETBITS(in, n) (	\
+  le += (n)			\
+)
+
+
+static int dec_rec2(in, hu, runp, c, i)
+struct in *in;
+struct dec_hufftbl *hu;
+int *runp;
+int c, i;
+{
+	LEBI_DCL;
+
+	LEBI_GET(in);
+	if (i) {
+		UNGETBITS(in, i & 127);
+		*runp = i >> 8 & 15;
+		i >>= 16;
+	} else {
+		for (i = DECBITS; (c = ((c << 1) | GETBITS(in, 1))) >= (hu->maxcode[i]); i++);
+		if (i >= 16) {
+			in->marker = M_BADHUFF;
+			return 0;
+		}
+		i = hu->vals[hu->valptr[i] + c - hu->maxcode[i - 1] * 2];
+		*runp = i >> 4;
+		i &= 15;
+	}
+	if (i == 0) {		/* sigh, 0xf0 is 11 bit */
+		LEBI_PUT(in);
+		return 0;
+	}
+	/* receive part */
+	c = GETBITS(in, i);
+	if (c < (1 << (i - 1)))
+		c += (-1 << i) + 1;
+	LEBI_PUT(in);
+	return c;
+}
+
+#define DEC_REC(in, hu, r, i)	 (	\
+  r = GETBITS(in, DECBITS),		\
+  i = hu->llvals[r],			\
+  i & 128 ?				\
+    (					\
+      UNGETBITS(in, i & 127),		\
+      r = i >> 8 & 15,			\
+      i >> 16				\
+    )					\
+  :					\
+    (					\
+      LEBI_PUT(in),			\
+      i = dec_rec2(in, hu, &r, r, i),	\
+      LEBI_GET(in),			\
+      i					\
+    )					\
+)
+
+static void decode_mcus(in, dct, n, sc, maxp)
+struct in *in;
+int *dct;
+int n;
+struct scan *sc;
+int *maxp;
+{
+	struct dec_hufftbl *hu;
+	int i, r, t;
+	LEBI_DCL;
+
+	memset(dct, 0, n * 64 * sizeof(*dct));
+	LEBI_GET(in);
+	while (n-- > 0) {
+		hu = sc->hudc.dhuff;
+		*dct++ = (sc->dc += DEC_REC(in, hu, r, t));
+
+		hu = sc->huac.dhuff;
+		i = 63;
+		while (i > 0) {
+			t = DEC_REC(in, hu, r, t);
+			if (t == 0 && r == 0) {
+				dct += i;
+				break;
+			}
+			dct += r;
+			*dct++ = t;
+			i -= r + 1;
+		}
+		*maxp++ = 64 - i;
+		if (n == sc->next)
+			sc++;
+	}
+	LEBI_PUT(in);
+}
+
+static void dec_makehuff(hu, hufflen, huffvals)
+struct dec_hufftbl *hu;
+int *hufflen;
+unsigned char *huffvals;
+{
+	int code, k, i, j, d, x, c, v;
+	for (i = 0; i < (1 << DECBITS); i++)
+		hu->llvals[i] = 0;
+
+/*
+ * llvals layout:
+ *
+ * value v already known, run r, backup u bits:
+ *  vvvvvvvvvvvvvvvv 0000 rrrr 1 uuuuuuu
+ * value unknown, size b bits, run r, backup u bits:
+ *  000000000000bbbb 0000 rrrr 0 uuuuuuu
+ * value and size unknown:
+ *  0000000000000000 0000 0000 0 0000000
+ */
+	code = 0;
+	k = 0;
+	for (i = 0; i < 16; i++, code <<= 1) {	/* sizes */
+		hu->valptr[i] = k;
+		for (j = 0; j < hufflen[i]; j++) {
+			hu->vals[k] = *huffvals++;
+			if (i < DECBITS) {
+				c = code << (DECBITS - 1 - i);
+				v = hu->vals[k] & 0x0f;	/* size */
+				for (d = 1 << (DECBITS - 1 - i); --d >= 0;) {
+					if (v + i < DECBITS) {	/* both fit in table */
+						x = d >> (DECBITS - 1 - v -
+							  i);
+						if (v && x < (1 << (v - 1)))
+							x += (-1 << v) + 1;
+						x = x << 16 | (hu-> vals[k] & 0xf0) << 4 |
+							(DECBITS - (i + 1 + v)) | 128;
+					} else
+						x = v << 16 | (hu-> vals[k] & 0xf0) << 4 |
+						        (DECBITS - (i + 1));
+					hu->llvals[c | d] = x;
+				}
+			}
+			code++;
+			k++;
+		}
+		hu->maxcode[i] = code;
+	}
+	hu->maxcode[16] = 0x20000;	/* always terminate decode */
+}
+
+/****************************************************************/
+/**************             idct                  ***************/
+/****************************************************************/
+
+#define ONE ((PREC)IFIX(1.))
+#define S2  ((PREC)IFIX(0.382683432))
+#define C2  ((PREC)IFIX(0.923879532))
+#define C4  ((PREC)IFIX(0.707106781))
+
+#define S22 ((PREC)IFIX(2 * 0.382683432))
+#define C22 ((PREC)IFIX(2 * 0.923879532))
+#define IC4 ((PREC)IFIX(1 / 0.707106781))
+
+#define C3IC1 ((PREC)IFIX(0.847759065))	/* c3/c1 */
+#define C5IC1 ((PREC)IFIX(0.566454497))	/* c5/c1 */
+#define C7IC1 ((PREC)IFIX(0.198912367))	/* c7/c1 */
+
+#define XPP(a,b) (t = a + b, b = a - b, a = t)
+#define XMP(a,b) (t = a - b, b = a + b, a = t)
+#define XPM(a,b) (t = a + b, b = b - a, a = t)
+
+#define ROT(a,b,s,c) (	t = IMULT(a + b, s),	\
+			a = IMULT(a, c - s) + t,	\
+			b = IMULT(b, c + s) - t)
+
+#define IDCT		\
+(			\
+  XPP(t0, t1),		\
+  XMP(t2, t3),		\
+  t2 = IMULT(t2, IC4) - t3,	\
+  XPP(t0, t3),		\
+  XPP(t1, t2),		\
+  XMP(t4, t7),		\
+  XPP(t5, t6),		\
+  XMP(t5, t7),		\
+  t5 = IMULT(t5, IC4),	\
+  ROT(t4, t6, S22, C22),\
+  t6 -= t7,		\
+  t5 -= t6,		\
+  t4 -= t5,		\
+  XPP(t0, t7),		\
+  XPP(t1, t6),		\
+  XPP(t2, t5),		\
+  XPP(t3, t4)		\
+)
+
+static unsigned char zig2[64] = {
+	0, 2, 3, 9, 10, 20, 21, 35,
+	14, 16, 25, 31, 39, 46, 50, 57,
+	5, 7, 12, 18, 23, 33, 37, 48,
+	27, 29, 41, 44, 52, 55, 59, 62,
+	15, 26, 30, 40, 45, 51, 56, 58,
+	1, 4, 8, 11, 19, 22, 34, 36,
+	28, 42, 43, 53, 54, 60, 61, 63,
+	6, 13, 17, 24, 32, 38, 47, 49
+};
+
+void idct(in, out, quant, off, max)
+int *in;
+int *out;
+PREC *quant;
+PREC off;
+int max;
+{
+	PREC t0, t1, t2, t3, t4, t5, t6, t7, t;
+	PREC tmp[64], *tmpp;
+	int i, j;
+	unsigned char *zig2p;
+
+	t0 = off;
+	if (max == 1) {
+		t0 += in[0] * quant[0];
+		for (i = 0; i < 64; i++)
+			out[i] = ITOINT(t0);
+		return;
+	}
+	zig2p = zig2;
+	tmpp = tmp;
+	for (i = 0; i < 8; i++) {
+		j = *zig2p++;
+		t0 += in[j] * quant[j];
+		j = *zig2p++;
+		t5 = in[j] * quant[j];
+		j = *zig2p++;
+		t2 = in[j] * quant[j];
+		j = *zig2p++;
+		t7 = in[j] * quant[j];
+		j = *zig2p++;
+		t1 = in[j] * quant[j];
+		j = *zig2p++;
+		t4 = in[j] * quant[j];
+		j = *zig2p++;
+		t3 = in[j] * quant[j];
+		j = *zig2p++;
+		t6 = in[j] * quant[j];
+		IDCT;
+		tmpp[0 * 8] = t0;
+		tmpp[1 * 8] = t1;
+		tmpp[2 * 8] = t2;
+		tmpp[3 * 8] = t3;
+		tmpp[4 * 8] = t4;
+		tmpp[5 * 8] = t5;
+		tmpp[6 * 8] = t6;
+		tmpp[7 * 8] = t7;
+		tmpp++;
+		t0 = 0;
+	}
+	for (i = 0; i < 8; i++) {
+		t0 = tmp[8 * i + 0];
+		t1 = tmp[8 * i + 1];
+		t2 = tmp[8 * i + 2];
+		t3 = tmp[8 * i + 3];
+		t4 = tmp[8 * i + 4];
+		t5 = tmp[8 * i + 5];
+		t6 = tmp[8 * i + 6];
+		t7 = tmp[8 * i + 7];
+		IDCT;
+		out[8 * i + 0] = ITOINT(t0);
+		out[8 * i + 1] = ITOINT(t1);
+		out[8 * i + 2] = ITOINT(t2);
+		out[8 * i + 3] = ITOINT(t3);
+		out[8 * i + 4] = ITOINT(t4);
+		out[8 * i + 5] = ITOINT(t5);
+		out[8 * i + 6] = ITOINT(t6);
+		out[8 * i + 7] = ITOINT(t7);
+	}
+}
+
+static unsigned char zig[64] = {
+	0, 1, 5, 6, 14, 15, 27, 28,
+	2, 4, 7, 13, 16, 26, 29, 42,
+	3, 8, 12, 17, 25, 30, 41, 43,
+	9, 11, 18, 24, 31, 40, 44, 53,
+	10, 19, 23, 32, 39, 45, 52, 54,
+	20, 22, 33, 38, 46, 51, 55, 60,
+	21, 34, 37, 47, 50, 56, 59, 61,
+	35, 36, 48, 49, 57, 58, 62, 63
+};
+
+static PREC aaidct[8] = {
+	IFIX(0.3535533906), IFIX(0.4903926402),
+	IFIX(0.4619397663), IFIX(0.4157348062),
+	IFIX(0.3535533906), IFIX(0.2777851165),
+	IFIX(0.1913417162), IFIX(0.0975451610)
+};
+
+
+static void idctqtab(qin, qout)
+unsigned char *qin;
+PREC *qout;
+{
+	int i, j;
+
+	for (i = 0; i < 8; i++)
+		for (j = 0; j < 8; j++)
+			qout[zig[i * 8 + j]] = qin[zig[i * 8 + j]] * 
+			  			IMULT(aaidct[i], aaidct[j]);
+}
+
+static void scaleidctqtab(q, sc)
+PREC *q;
+PREC sc;
+{
+	int i;
+
+	for (i = 0; i < 64; i++)
+		q[i] = IMULT(q[i], sc);
+}
+
+/****************************************************************/
+/**************          color decoder            ***************/
+/****************************************************************/
+
+#define ROUND
+
+/*
+ * YCbCr Color transformation:
+ *
+ * y:0..255   Cb:-128..127   Cr:-128..127
+ *
+ *      R = Y                + 1.40200 * Cr
+ *      G = Y - 0.34414 * Cb - 0.71414 * Cr
+ *      B = Y + 1.77200 * Cb
+ *
+ * =>
+ *      Cr *= 1.40200;
+ *      Cb *= 1.77200;
+ *      Cg = 0.19421 * Cb + .50937 * Cr;
+ *      R = Y + Cr;
+ *      G = Y - Cg;
+ *      B = Y + Cb;
+ *
+ * =>
+ *      Cg = (50 * Cb + 130 * Cr + 128) >> 8;
+ */
+
+static void initcol(q)
+PREC q[][64];
+{
+	scaleidctqtab(q[1], IFIX(1.77200));
+	scaleidctqtab(q[2], IFIX(1.40200));
+}
+
+/* This is optimized for the stupid sun SUNWspro compiler. */
+#define STORECLAMP(a,x)				\
+(						\
+  (a) = (x),					\
+  (unsigned int)(x) >= 256 ? 			\
+    ((a) = (x) < 0 ? 0 : 255)			\
+  :						\
+    0						\
+)
+
+#define CLAMP(x) ((unsigned int)(x) >= 256 ? ((x) < 0 ? 0 : 255) : (x))
+
+#ifdef ROUND
+
+#define CBCRCG(yin, xin)			\
+(						\
+  cb = outc[0 +yin*8+xin],			\
+  cr = outc[64+yin*8+xin],			\
+  cg = (50 * cb + 130 * cr + 128) >> 8		\
+)
+
+#else
+
+#define CBCRCG(yin, xin)			\
+(						\
+  cb = outc[0 +yin*8+xin],			\
+  cr = outc[64+yin*8+xin],			\
+  cg = (3 * cb + 8 * cr) >> 4			\
+)
+
+#endif
+
+#define PIC(yin, xin, p, xout)			\
+(						\
+  y = outy[(yin) * 8 + xin],			\
+  STORECLAMP(p[(xout) * 3 + 0], y + cr),	\
+  STORECLAMP(p[(xout) * 3 + 1], y - cg),	\
+  STORECLAMP(p[(xout) * 3 + 2], y + cb)		\
+)
+
+#ifdef __LITTLE_ENDIAN
+#define PIC_16(yin, xin, p, xout, add)		 \
+(                                                \
+  y = outy[(yin) * 8 + xin],                     \
+  y = ((CLAMP(y + cr + add*2+1) & 0xf8) <<  8) | \
+      ((CLAMP(y - cg + add    ) & 0xfc) <<  3) | \
+      ((CLAMP(y + cb + add*2+1)       ) >>  3),  \
+  p[(xout) * 2 + 0] = y & 0xff,                  \
+  p[(xout) * 2 + 1] = y >> 8                     \
+)
+#else
+#ifdef CONFIG_PPC
+#define PIC_16(yin, xin, p, xout, add)		 \
+(                                                \
+  y = outy[(yin) * 8 + xin],                     \
+  y = ((CLAMP(y + cr + add*2+1) & 0xf8) <<  7) | \
+      ((CLAMP(y - cg + add*2+1) & 0xf8) <<  2) | \
+      ((CLAMP(y + cb + add*2+1)       ) >>  3),  \
+  p[(xout) * 2 + 0] = y >> 8,                    \
+  p[(xout) * 2 + 1] = y & 0xff                   \
+)
+#else
+#define PIC_16(yin, xin, p, xout, add)	 	 \
+(                                                \
+  y = outy[(yin) * 8 + xin],                     \
+  y = ((CLAMP(y + cr + add*2+1) & 0xf8) <<  8) | \
+      ((CLAMP(y - cg + add    ) & 0xfc) <<  3) | \
+      ((CLAMP(y + cb + add*2+1)       ) >>  3),  \
+  p[(xout) * 2 + 0] = y >> 8,                    \
+  p[(xout) * 2 + 1] = y & 0xff                   \
+)
+#endif
+#endif
+
+#define PIC221111(xin)						\
+(								\
+  CBCRCG(0, xin),						\
+  PIC(xin / 4 * 8 + 0, (xin & 3) * 2 + 0, pic0, xin * 2 + 0),	\
+  PIC(xin / 4 * 8 + 0, (xin & 3) * 2 + 1, pic0, xin * 2 + 1),	\
+  PIC(xin / 4 * 8 + 1, (xin & 3) * 2 + 0, pic1, xin * 2 + 0),	\
+  PIC(xin / 4 * 8 + 1, (xin & 3) * 2 + 1, pic1, xin * 2 + 1)	\
+)
+
+#define PIC221111_16(xin)                                               \
+(                                                               	\
+  CBCRCG(0, xin),                                               	\
+  PIC_16(xin / 4 * 8 + 0, (xin & 3) * 2 + 0, pic0, xin * 2 + 0, 3),     \
+  PIC_16(xin / 4 * 8 + 0, (xin & 3) * 2 + 1, pic0, xin * 2 + 1, 0),     \
+  PIC_16(xin / 4 * 8 + 1, (xin & 3) * 2 + 0, pic1, xin * 2 + 0, 1),     \
+  PIC_16(xin / 4 * 8 + 1, (xin & 3) * 2 + 1, pic1, xin * 2 + 1, 2)      \
+)
+
+static void col221111(out, pic, width)
+int *out;
+unsigned char *pic;
+int width;
+{
+	int i, j, k;
+	unsigned char *pic0, *pic1;
+	int *outy, *outc;
+	int cr, cg, cb, y;
+
+	pic0 = pic;
+	pic1 = pic + width;
+	outy = out;
+	outc = out + 64 * 4;
+	for (i = 2; i > 0; i--) {
+		for (j = 4; j > 0; j--) {
+			for (k = 0; k < 8; k++) {
+				PIC221111(k);
+			}
+			outc += 8;
+			outy += 16;
+			pic0 += 2 * width;
+			pic1 += 2 * width;
+		}
+		outy += 64 * 2 - 16 * 4;
+	}
+}
+
+static void col221111_16(out, pic, width)
+int *out;
+unsigned char *pic;
+int width;
+{
+	int i, j, k;
+	unsigned char *pic0, *pic1;
+	int *outy, *outc;
+	int cr, cg, cb, y;
+
+	pic0 = pic;
+	pic1 = pic + width;
+	outy = out;
+	outc = out + 64 * 4;
+	for (i = 2; i > 0; i--) {
+		for (j = 4; j > 0; j--) {
+			for (k = 0; k < 8; k++) {
+			    PIC221111_16(k);
+			}
+			outc += 8;
+			outy += 16;
+			pic0 += 2 * width;
+			pic1 += 2 * width;
+		}
+		outy += 64 * 2 - 16 * 4;
+	}
+}
Index: drivers/video/bootsplash/decode-jpg.h
===================================================================
--- .orig/drivers/video/bootsplash/decode-jpg.h
+++ /drivers/video/bootsplash/decode-jpg.h
@@ -0,0 +1,35 @@
+/*
+ *    linux/drivers/video/bootsplash/decode-jpg.h - a tiny jpeg decoder.
+ *
+ *      (w) August 2001 by Michael Schroeder, <mls@suse.de>
+ */
+
+#ifndef __DECODE_JPG_H
+#define __DECODE_JPG_H
+
+#define ERR_NO_SOI 1
+#define ERR_NOT_8BIT 2
+#define ERR_HEIGHT_MISMATCH 3
+#define ERR_WIDTH_MISMATCH 4
+#define ERR_BAD_WIDTH_OR_HEIGHT 5
+#define ERR_TOO_MANY_COMPPS 6
+#define ERR_ILLEGAL_HV 7
+#define ERR_QUANT_TABLE_SELECTOR 8
+#define ERR_NOT_YCBCR_221111 9
+#define ERR_UNKNOWN_CID_IN_SCAN 10
+#define ERR_NOT_SEQUENTIAL_DCT 11
+#define ERR_WRONG_MARKER 12
+#define ERR_NO_EOI 13
+#define ERR_BAD_TABLES 14
+#define ERR_DEPTH_MISMATCH 15
+
+struct jpeg_decdata {
+	int dcts[6 * 64 + 16];
+	int out[64 * 6];
+	int dquant[3][64];
+};
+
+extern int jpeg_decode(unsigned char *, unsigned char *, int, int, int, struct jpeg_decdata *);
+extern int jpeg_check_size(unsigned char *, int, int);
+
+#endif
Index: drivers/video/bootsplash/render.c
===================================================================
--- .orig/drivers/video/bootsplash/render.c
+++ /drivers/video/bootsplash/render.c
@@ -0,0 +1,330 @@
+/* 
+ *    linux/drivers/video/bootsplash/render.c - splash screen render functions.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/vt_kern.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include "../console/fbcon.h"
+#include "bootsplash.h"
+
+void splash_putcs(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+			const unsigned short *s, int count, int ypos, int xpos)
+{
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int fgshift = (vc->vc_hi_font_mask) ? 9 : 8;
+	u8 *src;
+        u8 *dst, *splashsrc;
+	unsigned int d, x, y;
+	u32 dd, fgx, bgx;
+	u16 c = scr_readw(s);
+
+	int fg_color, bg_color, transparent;
+        fg_color = attr_fgcol(fgshift, c);
+        bg_color = attr_bgcol(bgshift, c);
+	transparent = sd->splash_color == bg_color;
+	xpos = xpos * vc->vc_font.width + sd->splash_text_xo;
+	ypos = ypos * vc->vc_font.height + sd->splash_text_yo;
+        splashsrc = (u8 *)(info->splash_pic + ypos * info->splash_bytes + xpos * 2);
+        dst = (u8 *)(info->screen_base + ypos * info->fix.line_length + xpos * 2);
+
+	fgx = ((u32 *)info->pseudo_palette)[fg_color];
+	if (transparent && sd->splash_color == 15) {
+	    if (fgx == 0xffea)
+		fgx = 0xfe4a;
+	    else if (fgx == 0x57ea)
+		fgx = 0x0540;
+	    else if (fgx == 0xffff)
+		fgx = 0x52aa;
+	}
+	bgx = ((u32 *)info->pseudo_palette)[bg_color];
+	d = 0;
+
+	while (count--) {
+	    c = scr_readw(s++);
+	    src = vc->vc_font.data + (c & charmask) * vc->vc_font.height * ((vc->vc_font.width + 7) >> 3);
+
+	    for (y = 0; y < vc->vc_font.height; y++) {
+		for (x = 0; x < vc->vc_font.width; x += 2) {
+		    if ((x & 7) == 0)
+			d = *src++;
+		    if (d & 0x80)
+			dd = fgx;
+		    else
+			dd = transparent ? *(u16 *)splashsrc : bgx;
+		    splashsrc += 2;
+		    if (d & 0x40)
+			dd |= fgx << 16;
+		    else
+			dd |= (transparent ? *(u16 *)splashsrc : bgx) << 16;
+		    splashsrc += 2;
+		    d <<= 2;
+		    fb_writel(dd, dst);
+		    dst += 4;
+		}
+		dst += info->fix.line_length - vc->vc_font.width * 2;
+		splashsrc += info->splash_bytes - vc->vc_font.width * 2;
+	    }
+	    dst -= info->fix.line_length * vc->vc_font.height - vc->vc_font.width * 2;
+	    splashsrc -= info->splash_bytes * vc->vc_font.height - vc->vc_font.width * 2;
+	}
+}
+
+static void splash_renderc(struct splash_data *sd, struct fb_info *info, int fg_color, int bg_color, u8 *src, int ypos, int xpos, int height, int width)
+{
+	int transparent = sd->splash_color == bg_color;
+	u32 dd, fgx, bgx;
+	u8 *dst, *splashsrc;
+	unsigned int d, x, y;
+
+	splashsrc = (u8 *)(info->splash_pic + ypos * info->splash_bytes + xpos * 2);
+	dst = (u8 *)(info->screen_base + ypos * info->fix.line_length + xpos * 2);
+	fgx = ((u32 *)info->pseudo_palette)[fg_color];
+	if (transparent && sd->splash_color == 15) {
+	    if (fgx == 0xffea)
+		fgx = 0xfe4a;
+	    else if (fgx == 0x57ea)
+		fgx = 0x0540;
+	    else if (fgx == 0xffff)
+		fgx = 0x52aa;
+	}
+	bgx = ((u32 *)info->pseudo_palette)[bg_color];
+	d = 0;
+	for (y = 0; y < height; y++) {
+	    for (x = 0; x < width; x += 2) {
+		if ((x & 7) == 0)
+		    d = *src++;
+		if (d & 0x80)
+		    dd = fgx;
+		else
+		    dd = transparent ? *(u16 *)splashsrc : bgx;
+		splashsrc += 2;
+		if (d & 0x40)
+		    dd |= fgx << 16;
+		else
+		    dd |= (transparent ? *(u16 *)splashsrc : bgx) << 16;
+		splashsrc += 2;
+		d <<= 2;
+		fb_writel(dd, dst);
+		dst += 4;
+	    }
+	    dst += info->fix.line_length - width * 2;
+	    splashsrc += info->splash_bytes - width * 2;
+	}
+}
+
+void splash_putc(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+                      int c, int ypos, int xpos)
+{
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int fgshift = (vc->vc_hi_font_mask) ? 9 : 8;
+	u8 *src = vc->vc_font.data + (c & charmask) * vc->vc_font.height * ((vc->vc_font.width + 7) >> 3);
+	xpos = xpos * vc->vc_font.width + sd->splash_text_xo;
+	ypos = ypos * vc->vc_font.height + sd->splash_text_yo;
+	splash_renderc(sd, info, attr_fgcol(fgshift, c), attr_bgcol(bgshift, c), src, ypos, xpos, vc->vc_font.height, vc->vc_font.width);
+}
+
+void splashcopy(u8 *dst, u8 *src, int height, int width, int dstbytes, int srcbytes)
+{
+	int i;
+
+	while (height-- > 0) {
+	    u32 *p = (u32 *)dst;
+	    u32 *q = (u32 *)src;
+	    for (i=0; i < width/4; i++) {
+		fb_writel(*q++,p++);
+		fb_writel(*q++,p++);
+	    }
+	    if (width & 2)
+		fb_writel(*q++,p++);
+	    if (width & 1)
+		fb_writew(*(u16*)q,(u16*)p);
+	    dst += dstbytes;
+	    src += srcbytes;
+	}
+}
+
+static void splashset(u8 *dst, int height, int width, int dstbytes, u32 bgx) {
+	int i;
+
+	bgx |= bgx << 16;
+	while (height-- > 0) {
+	    u32 *p = (u32 *)dst;
+	    for (i=0; i < width/4; i++) {
+		fb_writel(bgx,p++);
+		fb_writel(bgx,p++);
+	    }
+	    if (width & 2)
+		fb_writel(bgx,p++);
+	    if (width & 1)
+		fb_writew(bgx,(u16*)p);
+	    dst += dstbytes;
+	}
+}
+
+static void splashfill(struct fb_info *info, int sy, int sx, int height, int width) {
+	splashcopy((u8 *)(info->screen_base + sy * info->fix.line_length + sx * 2), (u8 *)(info->splash_pic + sy * info->splash_bytes + sx * 2), height, width, info->fix.line_length, info->splash_bytes);
+}
+
+void splash_clear(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int sy,
+			int sx, int height, int width)
+{
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int bg_color = attr_bgcol_ec(bgshift, vc);
+	int transparent = sd->splash_color == bg_color;
+	u32 bgx;
+	u8 *dst;
+
+	sy = sy * vc->vc_font.height + sd->splash_text_yo;
+	sx = sx * vc->vc_font.width + sd->splash_text_xo;
+	height *= vc->vc_font.height;
+	width *= vc->vc_font.width;
+	if (transparent) {
+		splashfill(info, sy, sx, height, width);
+		return;
+	}
+        dst = (u8 *)(info->screen_base + sy * info->fix.line_length + sx * 2);
+	bgx = ((u32 *)info->pseudo_palette)[bg_color];
+	splashset(dst, height, width, info->fix.line_length, bgx);
+}
+
+void splash_bmove(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int sy, 
+		int sx, int dy, int dx, int height, int width)
+{
+	struct fb_copyarea area;
+
+	area.sx = sx * vc->vc_font.width;
+	area.sy = sy * vc->vc_font.height;
+	area.dx = dx * vc->vc_font.width;
+	area.dy = dy * vc->vc_font.height;
+	area.sx += sd->splash_text_xo;
+	area.sy += sd->splash_text_yo;
+	area.dx += sd->splash_text_xo;
+	area.dy += sd->splash_text_yo;
+	area.height = height * vc->vc_font.height;
+	area.width = width * vc->vc_font.width;
+
+	info->fbops->fb_copyarea(info, &area);
+}
+
+void splash_clear_margins(struct splash_data *sd, struct vc_data *vc, struct fb_info *info,
+				int bottom_only)
+{
+	unsigned int tw = vc->vc_cols*vc->vc_font.width;
+	unsigned int th = vc->vc_rows*vc->vc_font.height;
+	
+	if (!bottom_only) {
+		/* top margin */
+		splashfill(info, 0, 0, sd->splash_text_yo, info->var.xres);
+		/* left margin */
+		splashfill(info, sd->splash_text_yo, 0, th, sd->splash_text_xo);
+		/* right margin */
+		splashfill(info, sd->splash_text_yo, sd->splash_text_xo + tw, th, info->var.xres - sd->splash_text_xo - tw);
+
+	}
+	splashfill(info, sd->splash_text_yo + th, 0, info->var.yres - sd->splash_text_yo - th, info->var.xres);
+}
+
+void splash_cursor(struct splash_data *sd, struct fb_info *info, struct fb_cursor *cursor)
+{
+	int i;
+	unsigned int dsize, s_pitch;
+
+	if (cursor->set & FB_CUR_SETSIZE) {
+                info->cursor.image.height = cursor->image.height;
+                info->cursor.image.width = cursor->image.width;
+        }
+        if (cursor->set & FB_CUR_SETPOS) {
+                info->cursor.image.dx = cursor->image.dx;
+                info->cursor.image.dy = cursor->image.dy;
+        }
+        if (cursor->set & FB_CUR_SETHOT)
+                info->cursor.hot = cursor->hot;
+        if (cursor->set & FB_CUR_SETCMAP) {
+                if (cursor->image.depth == 1) {
+                        info->cursor.image.bg_color = cursor->image.bg_color;
+                        info->cursor.image.fg_color = cursor->image.fg_color;
+                } else {
+                        if (cursor->image.cmap.len)
+                                fb_copy_cmap(&cursor->image.cmap, &info->cursor.image.cmap, 0);
+                }
+                info->cursor.image.depth = cursor->image.depth;
+        }
+	s_pitch = (info->cursor.image.width + 7) >> 3;
+        dsize = s_pitch * info->cursor.image.height;
+        if (info->cursor.enable) {
+                switch (info->cursor.rop) {
+                case ROP_XOR:
+                        for (i = 0; i < dsize; i++)
+                                info->fb_cursordata[i] = cursor->image.data[i] ^ info->cursor.mask[i];
+                        break;
+                case ROP_COPY:
+                default:
+                        for (i = 0; i < dsize; i++)
+                                info->fb_cursordata[i] = cursor->image.data[i] & info->cursor.mask[i];
+                        break;
+                }
+        } else if (info->fb_cursordata != cursor->image.data)
+                memcpy(info->fb_cursordata, cursor->image.data, dsize);
+	info->cursor.image.data = info->fb_cursordata;
+	splash_renderc(sd, info, info->cursor.image.fg_color, info->cursor.image.bg_color, (u8 *)info->fb_cursordata, info->cursor.image.dy + sd->splash_text_yo, info->cursor.image.dx + sd->splash_text_xo, info->cursor.image.height, info->cursor.image.width);
+}
+
+void splash_bmove_redraw(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int y, int sx, int dx, int width)
+{
+	unsigned short *d = (unsigned short *) (vc->vc_origin + vc->vc_size_row * y + dx * 2);
+	unsigned short *s = d + (dx - sx);
+	unsigned short *start = d;
+	unsigned short *ls = d;
+	unsigned short *le = d + width;
+	unsigned short c;
+	int x = dx;
+	unsigned short attr = 1;
+
+	do {
+		c = scr_readw(d);
+		if (attr != (c & 0xff00)) {
+			attr = c & 0xff00;
+			if (d > start) {
+				splash_putcs(sd, vc, info, start, d - start, y, x);
+				x += d - start;
+				start = d;
+			}
+		}
+		if (s >= ls && s < le && c == scr_readw(s)) {
+			if (d > start) {
+				splash_putcs(sd, vc, info, start, d - start, y, x);
+				x += d - start + 1;
+				start = d + 1;
+			} else {
+				x++;
+				start++;
+			}
+		}
+		s++;
+		d++;
+	} while (d < le);
+	if (d > start)
+		splash_putcs(sd, vc, info, start, d - start, y, x);
+}
+
+void splash_blank(struct splash_data *sd, struct vc_data *vc, struct fb_info *info, int blank)
+{
+	if (blank) {
+		if (info->silent_screen_base)
+		    splashset((u8 *)info->silent_screen_base, info->var.yres, info->var.xres, info->fix.line_length, 0);
+		splashset((u8 *)info->screen_base, info->var.yres, info->var.xres, info->fix.line_length, 0);
+	} else {
+		if (info->silent_screen_base)
+			splash_prepare(vc, info);
+		update_screen(vc->vc_num);
+		splash_clear_margins(vc->vc_splash_data, vc, info, 0);
+	}
+}
Index: drivers/video/console/fbcon.c
===================================================================
--- .orig/drivers/video/console/fbcon.c
+++ /drivers/video/console/fbcon.c
@@ -93,6 +93,9 @@
 #endif
 
 #include "fbcon.h"
+#ifdef CONFIG_BOOTSPLASH
+#include "../bootsplash/bootsplash.h"
+#endif
 
 #ifdef FBCONDEBUG
 #  define DPRINTK(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
@@ -210,8 +213,14 @@ static void fb_flashcursor(void *private
 	    info->cursor.rop == ROP_COPY || !vc || !CON_IS_VISIBLE(vc)
 	    || registered_fb[(int) con2fb_map[vc->vc_num]] != info)
 		return;
-	acquire_console_sem();
 	info->cursor.enable ^= 1;
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_cursor(info->splash_data, info, &info->cursor);
+		return;
+	}
+#endif
+	acquire_console_sem();
 	info->fbops->fb_cursor(info, &info->cursor);
 	release_console_sem();
 }
@@ -410,6 +419,14 @@ void accel_bmove(struct vc_data *vc, str
 {
 	struct fb_copyarea area;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_bmove(info->splash_data, vc, info, 
+				sy, sx, dy, dx, height, width);
+		return;
+	}
+#endif
+
 	area.sx = sx * vc->vc_font.width;
 	area.sy = sy * vc->vc_font.height;
 	area.dx = dx * vc->vc_font.width;
@@ -426,6 +443,13 @@ void accel_clear(struct vc_data *vc, str
 	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
 	struct fb_fillrect region;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_clear(info->splash_data, vc, info,
+					 sy, sx, height, width);
+		return;
+	}
+#endif
 	region.color = attr_bgcol_ec(bgshift, vc);
 	region.dx = sx * vc->vc_font.width;
 	region.dy = sy * vc->vc_font.height;
@@ -458,6 +482,13 @@ void accel_putcs(struct vc_data *vc, str
 	struct fb_image image;
 	u8 *src, *dst;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_putcs(info->splash_data, vc, info, s, count, yy, xx);
+		return;
+	}
+#endif
+
 	image.fg_color = attr_fgcol((vc->vc_hi_font_mask) ? 9 : 8,
 				    scr_readw(s));
 	image.bg_color = attr_bgcol((vc->vc_hi_font_mask) ? 13 : 12,
@@ -526,6 +557,13 @@ void accel_clear_margins(struct vc_data 
 	unsigned int bs = info->var.yres - bh;
 	struct fb_fillrect region;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_clear_margins(info->splash_data, vc, info, bottom_only);
+		return;
+	}
+#endif
+
 	region.color = attr_bgcol_ec(bgshift, vc);
 	region.rop = ROP_COPY;
 
@@ -746,6 +784,12 @@ static void fbcon_init(struct vc_data *v
 		if (vc->vc_can_do_color)
 			vc->vc_complement_mask <<= 1;
 	}
+#ifdef CONFIG_BOOTSPLASH
+	if(vc->vc_splash_data && vc->vc_splash_data->splash_state) {
+		con_remap_def_color(vc->vc_num, vc->vc_splash_data->splash_color << 4 | vc->vc_splash_data->splash_fg_color);
+	}
+#endif 
+
 	cols = vc->vc_cols;
 	rows = vc->vc_rows;
 	new_cols = info->var.xres / vc->vc_font.width;
@@ -778,6 +822,14 @@ static void fbcon_init(struct vc_data *v
 		vc->vc_rows = new_rows;
 	}
 
+#ifdef CONFIG_BOOTSPLASH
+	if (vc->vc_splash_data && vc->vc_splash_data->splash_state) {
+		nr_cols = vc->vc_splash_data->splash_text_wi / vc->vc_font.width;
+		nr_rows = vc->vc_splash_data->splash_text_he / vc->vc_font.height;
+		logo = 0;
+	}
+#endif
+
 	if (logo) {
 		/* Need to make room for the logo */
 		int cnt;
@@ -948,6 +1000,13 @@ static void fbcon_putc(struct vc_data *v
 	if (vt_cons[vc->vc_num]->vc_mode != KD_TEXT)
 		return;
 
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_putc(info->splash_data, vc, info, c, ypos, xpos);
+		return;
+	}
+#endif
+	
 	image.dx = xpos * vc->vc_font.width;
 	image.dy = real_y(p, ypos) * vc->vc_font.height;
 	image.width = vc->vc_font.width;
@@ -1025,6 +1084,12 @@ static void fbcon_cursor(struct vc_data 
 		if (info->cursor.rop == ROP_XOR) {
 			info->cursor.enable = 0;
 			info->cursor.rop = ROP_COPY;
+#ifdef CONFIG_BOOTSPLASH
+			if (info->splash_data) {
+				splash_cursor(info->splash_data, info, &cursor);
+				break;
+			}
+#endif
 			info->fbops->fb_cursor(info, &cursor);
 		}	
 		break;
@@ -1101,6 +1166,13 @@ static void fbcon_cursor(struct vc_data 
 				mask[i++] = 0xff;
 		}
         	info->cursor.rop = ROP_XOR;
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data) {
+			splash_cursor(info->splash_data, info, &cursor);
+			vbl_cursor_cnt = CURSOR_DRAW_DELAY;
+			break;
+		}
+#endif
 		info->fbops->fb_cursor(info, &cursor);
 		vbl_cursor_cnt = CURSOR_DRAW_DELAY;
 		break;
@@ -1540,6 +1612,10 @@ static int fbcon_scroll(struct vc_data *
 			fbcon_softback_note(vc, t, count);
 		if (logo_shown >= 0)
 			goto redraw_up;
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data)
+			goto redraw_up;
+#endif
 		switch (p->scrollmode) {
 		case SCROLL_MOVE:
 			accel_bmove(vc, info, t + count, 0, t, 0,
@@ -1625,6 +1701,10 @@ static int fbcon_scroll(struct vc_data *
 	case SM_DOWN:
 		if (count > vc->vc_rows)	/* Maximum realistic size */
 			count = vc->vc_rows;
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data)
+			goto redraw_down;
+#endif
 		switch (p->scrollmode) {
 		case SCROLL_MOVE:
 			accel_bmove(vc, info, t, 0, t + count, 0,
@@ -1767,6 +1847,13 @@ static void fbcon_bmove_rec(struct vc_da
 		}
 		return;
 	}
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data && sy == dy && height == 1) {
+		/* must use slower redraw bmove to keep background pic intact */
+		splash_bmove_redraw(info->splash_data, vc, info, sy, sx, dx, width);
+		return;
+	}
+#endif
 	accel_bmove(vc, info, real_y(p, sy), sx, real_y(p, dy), dx,
 			height, width);
 }
@@ -1849,6 +1936,10 @@ static int fbcon_switch(struct vc_data *
 	struct display *p = &fb_display[vc->vc_num];
 	int i;
 
+#ifdef CONFIG_BOOTSPLASH
+	splash_prepare(vc, info);
+#endif
+
 	if (softback_top) {
 		int l = fbcon_softback_size / vc->vc_size_row;
 		if (softback_lines)
@@ -1966,6 +2057,12 @@ static int fbcon_blank(struct vc_data *v
 	fbcon_cursor(vc, blank ? CM_ERASE : CM_DRAW);
 
 	if (!info->fbops->fb_blank) {
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data) {
+			splash_blank(info->splash_data, vc, info, blank);
+			return 0;
+		}
+#endif
 		if (blank) {
 			unsigned short oldc;
 			u_int height;
@@ -2134,9 +2231,16 @@ static int fbcon_do_set_font(struct vc_d
 	}
 
 	if (resize) {
+		u32 xres = info->var.xres, yres = info->var.yres;
 		/* reset wrap/pan */
 		info->var.xoffset = info->var.yoffset = p->yscroll = 0;
-		vc_resize(vc->vc_num, info->var.xres / w, info->var.yres / h);
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data) {
+			xres = info->splash_data->splash_text_wi;
+			yres = info->splash_data->splash_text_he;
+		}
+#endif
+		vc_resize(vc->vc_num, xres / w, yres / h);
 		if (CON_IS_VISIBLE(vc) && softback_buf) {
 			int l = fbcon_softback_size / vc->vc_size_row;
 			if (l > 5)
@@ -2607,7 +2711,6 @@ int fb_console_init(void)
 
 	if (!num_registered_fb)
 		return -ENODEV;
-
 	if (info_idx == -1) {
 		for (i = 0; i < FB_MAX; i++) {
 			if (registered_fb[i] != NULL) {
@@ -2618,6 +2721,10 @@ int fb_console_init(void)
 	}
 	for (i = first_fb_vc; i <= last_fb_vc; i++)
 		con2fb_map[i] = info_idx;
+#ifdef CONFIG_BOOTSPLASH
+	splash_init();
+#endif
+
 	err = take_over_console(&fb_con, first_fb_vc, last_fb_vc,
 				fbcon_is_default);
 	if (err) {
Index: drivers/video/console/fbcon.c~25306
===================================================================
--- .orig/drivers/video/console/fbcon.c~25306
+++ /drivers/video/console/fbcon.c~25306
@@ -0,0 +1,2739 @@
+/*
+ *  linux/drivers/video/fbcon.c -- Low level frame buffer based console driver
+ *
+ *	Copyright (C) 1995 Geert Uytterhoeven
+ *
+ *
+ *  This file is based on the original Amiga console driver (amicon.c):
+ *
+ *	Copyright (C) 1993 Hamish Macdonald
+ *			   Greg Harp
+ *	Copyright (C) 1994 David Carter [carter@compsci.bristol.ac.uk]
+ *
+ *	      with work by William Rucklidge (wjr@cs.cornell.edu)
+ *			   Geert Uytterhoeven
+ *			   Jes Sorensen (jds@kom.auc.dk)
+ *			   Martin Apel
+ *
+ *  and on the original Atari console driver (atacon.c):
+ *
+ *	Copyright (C) 1993 Bjoern Brauel
+ *			   Roman Hodek
+ *
+ *	      with work by Guenther Kelleter
+ *			   Martin Schaller
+ *			   Andreas Schwab
+ *
+ *  Hardware cursor support added by Emmanuel Marty (core@ggi-project.org)
+ *  Smart redraw scrolling, arbitrary font width support, 512char font support
+ *  and software scrollback added by 
+ *                         Jakub Jelinek (jj@ultra.linux.cz)
+ *
+ *  Random hacking by Martin Mares <mj@ucw.cz>
+ *
+ *	2001 - Documented with DocBook
+ *	- Brad Douglas <brad@neruo.com>
+ *
+ *  The low level operations for the various display memory organizations are
+ *  now in separate source files.
+ *
+ *  Currently the following organizations are supported:
+ *
+ *    o afb			Amiga bitplanes
+ *    o cfb{2,4,8,16,24,32}	Packed pixels
+ *    o ilbm			Amiga interleaved bitplanes
+ *    o iplan2p[248]		Atari interleaved bitplanes
+ *    o mfb			Monochrome
+ *    o vga			VGA characters/attributes
+ *
+ *  To do:
+ *
+ *    - Implement 16 plane mode (iplan2p16)
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#undef FBCONDEBUG
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>	/* MSch: for IRQ probe */
+#include <linux/tty.h>
+#include <linux/console.h>
+#include <linux/string.h>
+#include <linux/kd.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/vt_kern.h>
+#include <linux/selection.h>
+#include <linux/font.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#ifdef CONFIG_ATARI
+#include <asm/atariints.h>
+#endif
+#ifdef CONFIG_MAC
+#include <asm/macints.h>
+#endif
+#if defined(__mc68000__) || defined(CONFIG_APUS)
+#include <asm/machdep.h>
+#include <asm/setup.h>
+#endif
+
+#include "fbcon.h"
+#ifdef CONFIG_BOOTSPLASH
+#include "../bootsplash/bootsplash.h"
+#endif
+
+#ifdef FBCONDEBUG
+#  define DPRINTK(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
+#else
+#  define DPRINTK(fmt, args...)
+#endif
+
+struct display fb_display[MAX_NR_CONSOLES];
+signed char con2fb_map[MAX_NR_CONSOLES];
+static int logo_height;
+static int logo_lines;
+static int logo_shown = -1;
+/* Software scrollback */
+int fbcon_softback_size = 32768;
+static unsigned long softback_buf, softback_curr;
+static unsigned long softback_in;
+static unsigned long softback_top, softback_end;
+static int softback_lines;
+/* console mappings */
+static int first_fb_vc;
+static int last_fb_vc = MAX_NR_CONSOLES - 1;
+static int fbcon_is_default = 1; 
+/* font data */
+static char fontname[40];
+
+/* current fb_info */
+static int info_idx =  -1;
+
+#define REFCOUNT(fd)	(((int *)(fd))[-1])
+#define FNTSIZE(fd)	(((int *)(fd))[-2])
+#define FNTCHARCNT(fd)	(((int *)(fd))[-3])
+#define FNTSUM(fd)	(((int *)(fd))[-4])
+#define FONT_EXTRA_WORDS 4
+
+#define CM_SOFTBACK	(8)
+
+#define advance_row(p, delta) (unsigned short *)((unsigned long)(p) + (delta) * vc->vc_size_row)
+
+static void fbcon_free_font(struct display *);
+static int fbcon_set_origin(struct vc_data *);
+
+#define CURSOR_DRAW_DELAY		(1)
+
+/* # VBL ints between cursor state changes */
+#define ARM_CURSOR_BLINK_RATE		(10)
+#define ATARI_CURSOR_BLINK_RATE		(42)
+#define MAC_CURSOR_BLINK_RATE		(32)
+#define DEFAULT_CURSOR_BLINK_RATE	(20)
+
+static int vbl_cursor_cnt;
+
+#define divides(a, b)	((!(a) || (b)%(a)) ? 0 : 1)
+
+/*
+ *  Interface used by the world
+ */
+
+static const char *fbcon_startup(void);
+static void fbcon_init(struct vc_data *vc, int init);
+static void fbcon_deinit(struct vc_data *vc);
+static void fbcon_clear(struct vc_data *vc, int sy, int sx, int height,
+			int width);
+static void fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos);
+static void fbcon_putcs(struct vc_data *vc, const unsigned short *s,
+			int count, int ypos, int xpos);
+static void fbcon_cursor(struct vc_data *vc, int mode);
+static int fbcon_scroll(struct vc_data *vc, int t, int b, int dir,
+			int count);
+static void fbcon_bmove(struct vc_data *vc, int sy, int sx, int dy, int dx,
+			int height, int width);
+static int fbcon_switch(struct vc_data *vc);
+static int fbcon_blank(struct vc_data *vc, int blank, int mode_switch);
+static int fbcon_set_palette(struct vc_data *vc, unsigned char *table);
+static int fbcon_scrolldelta(struct vc_data *vc, int lines);
+void accel_clear_margins(struct vc_data *vc, struct fb_info *info,
+			 int bottom_only);
+
+
+/*
+ *  Internal routines
+ */
+static __inline__ int real_y(struct display *p, int ypos);
+static __inline__ void ywrap_up(struct vc_data *vc, int count);
+static __inline__ void ywrap_down(struct vc_data *vc, int count);
+static __inline__ void ypan_up(struct vc_data *vc, int count);
+static __inline__ void ypan_down(struct vc_data *vc, int count);
+static void fbcon_bmove_rec(struct vc_data *vc, struct display *p, int sy, int sx,
+			    int dy, int dx, int height, int width, u_int y_break);
+static void fbcon_set_disp(struct fb_info *info, struct vc_data *vc);
+static void fbcon_redraw_move(struct vc_data *vc, struct display *p,
+			      int line, int count, int dy);
+
+#ifdef CONFIG_MAC
+/*
+ * On the Macintoy, there may or may not be a working VBL int. We need to probe
+ */
+static int vbl_detected;
+
+static irqreturn_t fb_vbl_detect(int irq, void *dummy, struct pt_regs *fp)
+{
+	vbl_detected++;
+	return IRQ_HANDLED;
+}
+#endif
+
+static void fb_flashcursor(void *private)
+{
+	struct fb_info *info = (struct fb_info *) private;
+	struct vc_data *vc = NULL;
+
+	if (info->currcon != -1)
+		vc = vc_cons[info->currcon].d;
+
+	if (info->state != FBINFO_STATE_RUNNING ||
+	    info->cursor.rop == ROP_COPY || !vc || !CON_IS_VISIBLE(vc)
+	    || registered_fb[(int) con2fb_map[vc->vc_num]] != info)
+		return;
+	info->cursor.enable ^= 1;
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_cursor(info->splash_data, info, &info->cursor);
+		return;
+	}
+#endif
+	acquire_console_sem();
+	info->fbops->fb_cursor(info, &info->cursor);
+	release_console_sem();
+}
+
+#if (defined(__arm__) && defined(IRQ_VSYNCPULSE)) || defined(CONFIG_ATARI) || defined(CONFIG_MAC)
+static int cursor_blink_rate;
+static irqreturn_t fb_vbl_handler(int irq, void *dev_id, struct pt_regs *fp)
+{
+	struct fb_info *info = dev_id;
+
+	if (vbl_cursor_cnt && --vbl_cursor_cnt == 0) {
+		schedule_work(&info->queue);	
+		vbl_cursor_cnt = cursor_blink_rate; 
+	}
+	return IRQ_HANDLED;
+}
+#endif
+	
+static void cursor_timer_handler(unsigned long dev_addr)
+{
+	struct fb_info *info = (struct fb_info *) dev_addr;
+	
+	schedule_work(&info->queue);
+	mod_timer(&info->cursor_timer, jiffies + HZ/5);
+}
+
+int __init fb_console_setup(char *this_opt)
+{
+	char *options;
+	int i, j;
+
+	if (!this_opt || !*this_opt)
+		return 0;
+
+	while ((options = strsep(&this_opt, ",")) != NULL) {
+		if (!strncmp(options, "font:", 5))
+			strcpy(fontname, options + 5);
+		
+		if (!strncmp(options, "scrollback:", 11)) {
+			options += 11;
+			if (*options) {
+				fbcon_softback_size = simple_strtoul(options, &options, 0);
+				if (*options == 'k' || *options == 'K') {
+					fbcon_softback_size *= 1024;
+					options++;
+				}
+				if (*options != ',')
+					return 0;
+				options++;
+			} else
+				return 0;
+		}
+		
+		if (!strncmp(options, "map:", 4)) {
+			options += 4;
+			if (*options)
+				for (i = 0, j = 0; i < MAX_NR_CONSOLES; i++) {
+					if (!options[j])
+						j = 0;
+					con2fb_map[i] = (options[j++]-'0') % FB_MAX;
+				}
+			return 0;
+		}
+
+		if (!strncmp(options, "vc:", 3)) {
+			options += 3;
+			if (*options)
+				first_fb_vc = simple_strtoul(options, &options, 10) - 1;
+			if (first_fb_vc < 0)
+				first_fb_vc = 0;
+			if (*options++ == '-')
+				last_fb_vc = simple_strtoul(options, &options, 10) - 1;
+			fbcon_is_default = 0; 
+		}	
+	}
+	return 0;
+}
+
+__setup("fbcon=", fb_console_setup);
+
+static int search_fb_in_map(int idx)
+{
+	int i;
+
+	for (i = 0; i < MAX_NR_CONSOLES; i++) {
+		if (con2fb_map[i] == idx)
+			return 1;
+	}
+	return 0;
+}
+
+static int search_for_mapped_con(void)
+{
+	int i;
+
+	for (i = 0; i < MAX_NR_CONSOLES; i++) {
+		if (con2fb_map[i] != -1)
+			return 1;
+	}
+	return 0;
+}
+
+/**
+ *	set_con2fb_map - map console to frame buffer device
+ *	@unit: virtual console number to map
+ *	@newidx: frame buffer index to map virtual console to
+ *
+ *	Maps a virtual console @unit to a frame buffer device
+ *	@newidx.
+ */
+int set_con2fb_map(int unit, int newidx)
+{
+	struct vc_data *vc = vc_cons[unit].d;
+	int oldidx = con2fb_map[unit];
+	struct fb_info *info = registered_fb[newidx];
+	struct fb_info *oldinfo = NULL;
+	int found;
+
+	if (oldidx == newidx)
+		return 0;
+
+	if (!vc)
+	    return -ENODEV;
+
+	if (!search_for_mapped_con()) {
+		info_idx = newidx;
+		fb_console_init();
+		return 0;
+	}
+
+	if (oldidx != -1)
+		oldinfo = registered_fb[oldidx];
+
+	found = search_fb_in_map(newidx);
+
+	acquire_console_sem();
+	con2fb_map[unit] = newidx;
+	if (!found) {
+		if (!try_module_get(info->fbops->owner)) {
+			con2fb_map[unit] = oldidx;
+			release_console_sem();
+			return -ENODEV;
+		}
+		if (info->fbops->fb_open && info->fbops->fb_open(info, 0)) {
+			module_put(info->fbops->owner);
+			con2fb_map[unit] = oldidx;
+			release_console_sem();
+			return -ENODEV;
+		}
+	}
+
+	/*
+	 * If old fb is not mapped to any of the consoles,
+	 * fbcon should release it.
+	 */
+	if (oldinfo && !search_fb_in_map(oldidx)) {
+		if (oldinfo->fbops->fb_release &&
+		    oldinfo->fbops->fb_release(oldinfo, 0)) {
+			con2fb_map[unit] = oldidx;
+			if (!found && info->fbops->fb_release)
+				info->fbops->fb_release(info, 0);
+			if (!found)
+				module_put(info->fbops->owner);
+			release_console_sem();
+			return -ENODEV;
+		}
+		if (oldinfo->queue.func == fb_flashcursor)
+			del_timer_sync(&oldinfo->cursor_timer);
+		module_put(oldinfo->fbops->owner);
+	}
+	info->currcon = -1;
+	if (!found) {
+		if (!info->queue.func || info->queue.func == fb_flashcursor) {
+			if (!info->queue.func)
+				INIT_WORK(&info->queue, fb_flashcursor, info);
+
+			init_timer(&info->cursor_timer);
+			info->cursor_timer.function = cursor_timer_handler;
+			info->cursor_timer.expires = jiffies + HZ / 5;
+			info->cursor_timer.data = (unsigned long ) info;
+			add_timer(&info->cursor_timer);
+		}
+	}
+	if (info->fbops->fb_set_par)
+		info->fbops->fb_set_par(info);
+	fbcon_set_disp(info, vc);
+	release_console_sem();
+	return 0;
+}
+
+/*
+ * Accelerated handlers.
+ */
+void accel_bmove(struct vc_data *vc, struct fb_info *info, int sy, 
+		int sx, int dy, int dx, int height, int width)
+{
+	struct fb_copyarea area;
+
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_bmove(info->splash_data, vc, info, 
+				sy, sx, dy, dx, height, width);
+		return;
+	}
+#endif
+
+	area.sx = sx * vc->vc_font.width;
+	area.sy = sy * vc->vc_font.height;
+	area.dx = dx * vc->vc_font.width;
+	area.dy = dy * vc->vc_font.height;
+	area.height = height * vc->vc_font.height;
+	area.width = width * vc->vc_font.width;
+
+	info->fbops->fb_copyarea(info, &area);
+}
+
+void accel_clear(struct vc_data *vc, struct fb_info *info, int sy,
+			int sx, int height, int width)
+{
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	struct fb_fillrect region;
+
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_clear(info->splash_data, vc, info,
+					 sy, sx, height, width);
+		return;
+	}
+#endif
+	region.color = attr_bgcol_ec(bgshift, vc);
+	region.dx = sx * vc->vc_font.width;
+	region.dy = sy * vc->vc_font.height;
+	region.width = width * vc->vc_font.width;
+	region.height = height * vc->vc_font.height;
+	region.rop = ROP_COPY;
+
+	info->fbops->fb_fillrect(info, &region);
+}	
+
+void accel_putcs(struct vc_data *vc, struct fb_info *info,
+		 const unsigned short *s, int count, int yy, int xx)
+{
+	void (*move_unaligned)(struct fb_info *info, struct fb_pixmap *buf,
+			       u8 *dst, u32 d_pitch, u8 *src, u32 idx,
+			       u32 height, u32 shift_high, u32 shift_low,
+			       u32 mod);
+	void (*move_aligned)(struct fb_info *info, struct fb_pixmap *buf,
+			     u8 *dst, u32 d_pitch, u8 *src, u32 s_pitch,
+			     u32 height);
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	unsigned int width = (vc->vc_font.width + 7) >> 3;
+	unsigned int cellsize = vc->vc_font.height * width;
+	unsigned int maxcnt = info->pixmap.size/cellsize;
+	unsigned int scan_align = info->pixmap.scan_align - 1;
+	unsigned int buf_align = info->pixmap.buf_align - 1;
+	unsigned int shift_low = 0, mod = vc->vc_font.width % 8;
+	unsigned int shift_high = 8, pitch, cnt, size, k;
+	unsigned int idx = vc->vc_font.width >> 3;
+	struct fb_image image;
+	u8 *src, *dst;
+
+	image.fg_color = attr_fgcol((vc->vc_hi_font_mask) ? 9 : 8,
+				    scr_readw(s));
+	image.bg_color = attr_bgcol((vc->vc_hi_font_mask) ? 13 : 12,
+				    scr_readw(s));
+	image.dx = xx * vc->vc_font.width;
+	image.dy = yy * vc->vc_font.height;
+	image.height = vc->vc_font.height;
+	image.depth = 1;
+
+	if (info->pixmap.outbuf && info->pixmap.inbuf) {
+		move_aligned = fb_iomove_buf_aligned;
+		move_unaligned = fb_iomove_buf_unaligned;
+	} else {
+		move_aligned = fb_sysmove_buf_aligned;
+		move_unaligned = fb_sysmove_buf_unaligned;
+	}
+	while (count) {
+		if (count > maxcnt)
+			cnt = k = maxcnt;
+		else
+			cnt = k = count;
+
+		image.width = vc->vc_font.width * cnt;
+		pitch = ((image.width + 7) >> 3) + scan_align;
+		pitch &= ~scan_align;
+		size = pitch * image.height + buf_align;
+		size &= ~buf_align;
+		dst = fb_get_buffer_offset(info, &info->pixmap, size);
+		image.data = dst;
+		if (mod) {
+			while (k--) {
+				src = vc->vc_font.data + (scr_readw(s++)&
+							  charmask)*cellsize;
+				move_unaligned(info, &info->pixmap, dst, pitch,
+					       src, idx, image.height,
+					       shift_high, shift_low, mod);
+				shift_low += mod;
+				dst += (shift_low >= 8) ? width : width - 1;
+				shift_low &= 7;
+				shift_high = 8 - shift_low;
+			}
+		} else {
+			while (k--) {
+				src = vc->vc_font.data + (scr_readw(s++)&
+							  charmask)*cellsize;
+				move_aligned(info, &info->pixmap, dst, pitch,
+					     src, idx, image.height);
+				dst += width;
+			}
+		}
+		info->fbops->fb_imageblit(info, &image);
+		image.dx += cnt * vc->vc_font.width;
+		count -= cnt;
+	}
+}
+
+void accel_clear_margins(struct vc_data *vc, struct fb_info *info,
+				int bottom_only)
+{
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	unsigned int cw = vc->vc_font.width;
+	unsigned int ch = vc->vc_font.height;
+	unsigned int rw = info->var.xres - (vc->vc_cols*cw);
+	unsigned int bh = info->var.yres - (vc->vc_rows*ch);
+	unsigned int rs = info->var.xres - rw;
+	unsigned int bs = info->var.yres - bh;
+	struct fb_fillrect region;
+
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_clear_margins(info->splash_data, vc, info, bottom_only);
+		return;
+	}
+#endif
+
+	region.color = attr_bgcol_ec(bgshift, vc);
+	region.rop = ROP_COPY;
+
+	if (rw && !bottom_only) {
+		region.dx = info->var.xoffset + rs;
+		region.dy = 0;
+		region.width = rw;
+		region.height = info->var.yres_virtual;
+		info->fbops->fb_fillrect(info, &region);
+	}
+
+	if (bh) {
+		region.dx = info->var.xoffset;
+		region.dy = info->var.yoffset + bs;
+		region.width = rs;
+		region.height = bh;
+		info->fbops->fb_fillrect(info, &region);
+	}	
+}	
+
+/*
+ *  Low Level Operations
+ */
+/* NOTE: fbcon cannot be __init: it may be called from take_over_console later */
+static const char *fbcon_startup(void)
+{
+	const char *display_desc = "frame buffer device";
+	struct display *p = &fb_display[fg_console];
+	struct vc_data *vc = vc_cons[fg_console].d;
+	struct font_desc *font = NULL;
+	struct module *owner;
+	struct fb_info *info = NULL;
+	int rows, cols;
+	int irqres;
+
+	irqres = 1;
+	/*
+	 *  If num_registered_fb is zero, this is a call for the dummy part.
+	 *  The frame buffer devices weren't initialized yet.
+	 */
+	if (!num_registered_fb || info_idx == -1)
+		return display_desc;
+	/*
+	 * Instead of blindly using registered_fb[0], we use info_idx, set by
+	 * fb_console_init();
+	 */
+	info = registered_fb[info_idx];
+	if (!info)
+		return NULL;
+	info->currcon = -1;
+	
+	owner = info->fbops->owner;
+	if (!try_module_get(owner))
+		return NULL;
+	if (info->fbops->fb_open && info->fbops->fb_open(info, 0)) {
+		module_put(owner);
+		return NULL;
+	}
+	if (info->fix.type != FB_TYPE_TEXT) {
+		if (fbcon_softback_size) {
+			if (!softback_buf) {
+				softback_buf =
+				    (unsigned long)
+				    kmalloc(fbcon_softback_size,
+					    GFP_KERNEL);
+				if (!softback_buf) {
+					fbcon_softback_size = 0;
+					softback_top = 0;
+				}
+			}
+		} else {
+			if (softback_buf) {
+				kfree((void *) softback_buf);
+				softback_buf = 0;
+				softback_top = 0;
+			}
+		}
+		if (softback_buf)
+			softback_in = softback_top = softback_curr =
+			    softback_buf;
+		softback_lines = 0;
+	}
+
+	/* Setup default font */
+	if (!p->fontdata) {
+		if (!fontname[0] || !(font = find_font(fontname)))
+			font = get_default_font(info->var.xres,
+						   info->var.yres);
+		vc->vc_font.width = font->width;
+		vc->vc_font.height = font->height;
+		vc->vc_font.data = p->fontdata = font->data;
+		vc->vc_font.charcount = 256; /* FIXME  Need to support more fonts */
+	}
+
+	cols = info->var.xres / vc->vc_font.width;
+	rows = info->var.yres / vc->vc_font.height;
+	vc_resize(vc->vc_num, cols, rows);
+
+	DPRINTK("mode:   %s\n", info->fix.id);
+	DPRINTK("visual: %d\n", info->fix.visual);
+	DPRINTK("res:    %dx%d-%d\n", info->var.xres,
+		info->var.yres,
+		info->var.bits_per_pixel);
+	con_set_default_unimap(vc->vc_num);
+
+#ifdef CONFIG_ATARI
+	if (MACH_IS_ATARI) {
+		cursor_blink_rate = ATARI_CURSOR_BLINK_RATE;
+		irqres =
+		    request_irq(IRQ_AUTO_4, fb_vbl_handler,
+				IRQ_TYPE_PRIO, "framebuffer vbl",
+				info);
+	}
+#endif				/* CONFIG_ATARI */
+
+#ifdef CONFIG_MAC
+	/*
+	 * On a Macintoy, the VBL interrupt may or may not be active. 
+	 * As interrupt based cursor is more reliable and race free, we 
+	 * probe for VBL interrupts.
+	 */
+	if (MACH_IS_MAC) {
+		int ct = 0;
+		/*
+		 * Probe for VBL: set temp. handler ...
+		 */
+		irqres = request_irq(IRQ_MAC_VBL, fb_vbl_detect, 0,
+				     "framebuffer vbl", info);
+		vbl_detected = 0;
+
+		/*
+		 * ... and spin for 20 ms ...
+		 */
+		while (!vbl_detected && ++ct < 1000)
+			udelay(20);
+
+		if (ct == 1000)
+			printk
+			    ("fbcon_startup: No VBL detected, using timer based cursor.\n");
+
+		free_irq(IRQ_MAC_VBL, fb_vbl_detect);
+
+		if (vbl_detected) {
+			/*
+			 * interrupt based cursor ok
+			 */
+			cursor_blink_rate = MAC_CURSOR_BLINK_RATE;
+			irqres =
+			    request_irq(IRQ_MAC_VBL, fb_vbl_handler, 0,
+					"framebuffer vbl", info);
+		} else {
+			/*
+			 * VBL not detected: fall through, use timer based cursor
+			 */
+			irqres = 1;
+		}
+	}
+#endif				/* CONFIG_MAC */
+
+#if defined(__arm__) && defined(IRQ_VSYNCPULSE)
+	cursor_blink_rate = ARM_CURSOR_BLINK_RATE;
+	irqres = request_irq(IRQ_VSYNCPULSE, fb_vbl_handler, SA_SHIRQ,
+			     "framebuffer vbl", info);
+#endif
+	/* Initialize the work queue. If the driver provides its
+	 * own work queue this means it will use something besides 
+	 * default timer to flash the cursor. */
+	if (!info->queue.func) {
+		INIT_WORK(&info->queue, fb_flashcursor, info);
+
+		init_timer(&info->cursor_timer);
+		info->cursor_timer.function = cursor_timer_handler;
+		info->cursor_timer.expires = jiffies + HZ / 5;
+		info->cursor_timer.data = (unsigned long ) info;
+		add_timer(&info->cursor_timer);
+	}
+	return display_desc;
+}
+
+static void fbcon_init(struct vc_data *vc, int init)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct vc_data **default_mode = vc->vc_display_fg;
+	struct display *t, *p = &fb_display[vc->vc_num];
+	int display_fg = (*default_mode)->vc_num;
+	int logo = 1, new_rows, new_cols, rows, cols, charcnt = 256;
+	unsigned short *save = NULL, *r, *q;
+	int cap = info->flags;
+
+	if (info_idx == -1 || info == NULL)
+	    return;
+	if (vc->vc_num != display_fg || (info->flags & FBINFO_MODULE) ||
+	    (info->fix.type == FB_TYPE_TEXT))
+		logo = 0;
+
+	info->var.xoffset = info->var.yoffset = p->yscroll = 0;	/* reset wrap/pan */
+
+	/* If we are not the first console on this
+	   fb, copy the font from that console */
+	t = &fb_display[display_fg];
+	if (!vc->vc_font.data) {
+		vc->vc_font.data = p->fontdata = t->fontdata;
+		vc->vc_font.width = (*default_mode)->vc_font.width;
+		vc->vc_font.height = (*default_mode)->vc_font.height;
+		p->userfont = t->userfont;
+		if (p->userfont)
+			REFCOUNT(p->fontdata)++;
+		con_copy_unimap(vc->vc_num, display_fg);
+	}
+	if (p->userfont)
+		charcnt = FNTCHARCNT(p->fontdata);
+	vc->vc_can_do_color = info->var.bits_per_pixel != 1;
+	vc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;
+	if (charcnt == 256) {
+		vc->vc_hi_font_mask = 0;
+	} else {
+		vc->vc_hi_font_mask = 0x100;
+		if (vc->vc_can_do_color)
+			vc->vc_complement_mask <<= 1;
+	}
+	cols = vc->vc_cols;
+	rows = vc->vc_rows;
+	new_cols = info->var.xres / vc->vc_font.width;
+	new_rows = info->var.yres / vc->vc_font.height;
+	vc_resize(vc->vc_num, new_cols, new_rows);
+	/*
+	 * We must always set the mode. The mode of the previous console
+	 * driver could be in the same resolution but we are using different
+	 * hardware so we have to initialize the hardware.
+	 *
+	 * We need to do it in fbcon_init() to prevent screen corruption.
+	 */
+	if (CON_IS_VISIBLE(vc) && info->fbops->fb_set_par)
+		info->fbops->fb_set_par(info);
+
+
+	if ((cap & FBINFO_HWACCEL_COPYAREA) &&
+	    !(cap & FBINFO_HWACCEL_DISABLED))
+		p->scrollmode = SCROLL_MOVE;
+	else /* default to something safe */
+		p->scrollmode = SCROLL_REDRAW;
+
+	/*
+	 *  ++guenther: console.c:vc_allocate() relies on initializing
+	 *  vc_{cols,rows}, but we must not set those if we are only
+	 *  resizing the console.
+	 */
+	if (!init) {
+		vc->vc_cols = new_cols;
+		vc->vc_rows = new_rows;
+	}
+
+#ifdef CONFIG_BOOTSPLASH
+	if (vc->vc_splash_data && vc->vc_splash_data->splash_state) {
+		nr_cols = vc->vc_splash_data->splash_text_wi / vc->vc_font.width;
+		nr_rows = vc->vc_splash_data->splash_text_he / vc->vc_font.height;
+		logo = 0;
+	}
+#endif
+
+	if (logo) {
+		/* Need to make room for the logo */
+		int cnt;
+		int step;
+
+		logo_height = fb_prepare_logo(info);
+		logo_lines = (logo_height + vc->vc_font.height - 1) /
+			     vc->vc_font.height;
+		q = (unsigned short *) (vc->vc_origin +
+					vc->vc_size_row * rows);
+		step = logo_lines * cols;
+		for (r = q - logo_lines * cols; r < q; r++)
+			if (scr_readw(r) != vc->vc_video_erase_char)
+				break;
+		if (r != q && new_rows >= rows + logo_lines) {
+			save = kmalloc(logo_lines * new_cols * 2, GFP_KERNEL);
+			if (save) {
+				int i = cols < new_cols ? cols : new_cols;
+				scr_memsetw(save, vc->vc_video_erase_char,
+					    logo_lines * new_cols * 2);
+				r = q - step;
+				for (cnt = 0; cnt < logo_lines; cnt++, r += i)
+					scr_memcpyw(save + cnt * new_cols, r, 2 * i);
+				r = q;
+			}
+		}
+		if (r == q) {
+			/* We can scroll screen down */
+			r = q - step - cols;
+			for (cnt = rows - logo_lines; cnt > 0; cnt--) {
+				scr_memcpyw(r + step, r, vc->vc_size_row);
+				r -= cols;
+			}
+			if (!save) {
+				vc->vc_y += logo_lines;
+				vc->vc_pos += logo_lines * vc->vc_size_row;
+			}
+		}
+		scr_memsetw((unsigned short *) vc->vc_origin,
+			    vc->vc_video_erase_char,
+			    vc->vc_size_row * logo_lines);
+
+		if (CON_IS_VISIBLE(vc) && vt_cons[vc->vc_num]->vc_mode == KD_TEXT) {
+			accel_clear_margins(vc, info, 0);
+			update_screen(vc->vc_num);
+		}
+		if (save) {
+			q = (unsigned short *) (vc->vc_origin +
+						vc->vc_size_row *
+						rows);
+			scr_memcpyw(q, save, logo_lines * new_cols * 2);
+			vc->vc_y += logo_lines;
+			vc->vc_pos += logo_lines * vc->vc_size_row;
+			kfree(save);
+		}
+		if (logo_lines > vc->vc_bottom) {
+			logo_shown = -1;
+			printk(KERN_INFO
+			       "fbcon_init: disable boot-logo (boot-logo bigger than screen).\n");
+		} else {
+			logo_shown = -2;
+			vc->vc_top = logo_lines;
+		}
+	}
+
+	if (vc->vc_num == display_fg && softback_buf) {
+		int l = fbcon_softback_size / vc->vc_size_row;
+		if (l > 5)
+			softback_end = softback_buf + l * vc->vc_size_row;
+		else {
+			/* Smaller scrollback makes no sense, and 0 would screw
+			   the operation totally */
+			softback_top = 0;
+		}
+	}
+}
+
+static void fbcon_deinit(struct vc_data *vc)
+{
+	struct display *p = &fb_display[vc->vc_num];
+
+	if (info_idx != -1)
+	    return;
+	fbcon_free_font(p);
+}
+
+/* ====================================================================== */
+
+/*  fbcon_XXX routines - interface used by the world
+ *
+ *  This system is now divided into two levels because of complications
+ *  caused by hardware scrolling. Top level functions:
+ *
+ *	fbcon_bmove(), fbcon_clear(), fbcon_putc()
+ *
+ *  handles y values in range [0, scr_height-1] that correspond to real
+ *  screen positions. y_wrap shift means that first line of bitmap may be
+ *  anywhere on this display. These functions convert lineoffsets to
+ *  bitmap offsets and deal with the wrap-around case by splitting blits.
+ *
+ *	fbcon_bmove_physical_8()    -- These functions fast implementations
+ *	fbcon_clear_physical_8()    -- of original fbcon_XXX fns.
+ *	fbcon_putc_physical_8()	    -- (font width != 8) may be added later
+ *
+ *  WARNING:
+ *
+ *  At the moment fbcon_putc() cannot blit across vertical wrap boundary
+ *  Implies should only really hardware scroll in rows. Only reason for
+ *  restriction is simplicity & efficiency at the moment.
+ */
+
+static __inline__ int real_y(struct display *p, int ypos)
+{
+	int rows = p->vrows;
+
+	ypos += p->yscroll;
+	return ypos < rows ? ypos : ypos - rows;
+}
+
+
+static void fbcon_clear(struct vc_data *vc, int sy, int sx, int height,
+			int width)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	
+	struct display *p = &fb_display[vc->vc_num];
+	u_int y_break;
+
+	if (!info->fbops->fb_blank && console_blanked)
+		return;
+	if (info->state != FBINFO_STATE_RUNNING)
+		return;
+
+	if (!height || !width)
+		return;
+
+	/* Split blits that cross physical y_wrap boundary */
+
+	y_break = p->vrows - p->yscroll;
+	if (sy < y_break && sy + height - 1 >= y_break) {
+		u_int b = y_break - sy;
+		accel_clear(vc, info, real_y(p, sy), sx, b, width);
+		accel_clear(vc, info, real_y(p, sy + b), sx, height - b,
+				 width);
+	} else
+		accel_clear(vc, info, real_y(p, sy), sx, height, width);
+}
+
+static void fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	unsigned int scan_align = info->pixmap.scan_align - 1;
+	unsigned int buf_align = info->pixmap.buf_align - 1;
+	unsigned int width = (vc->vc_font.width + 7) >> 3;
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int fgshift = (vc->vc_hi_font_mask) ? 9 : 8;
+	struct display *p = &fb_display[vc->vc_num];
+	unsigned int size, pitch;
+	struct fb_image image;
+	u8 *src, *dst;
+
+	if (!info->fbops->fb_blank && console_blanked)
+		return;
+	if (info->state != FBINFO_STATE_RUNNING)
+		return;
+
+	if (vt_cons[vc->vc_num]->vc_mode != KD_TEXT)
+		return;
+
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data) {
+		splash_putc(info->splash_data, vc, info, c, ypos, xpos);
+		return;
+	}
+#endif
+	
+	image.dx = xpos * vc->vc_font.width;
+	image.dy = real_y(p, ypos) * vc->vc_font.height;
+	image.width = vc->vc_font.width;
+	image.height = vc->vc_font.height;
+	image.fg_color = attr_fgcol(fgshift, c);
+	image.bg_color = attr_bgcol(bgshift, c);
+	image.depth = 1;
+
+	src = vc->vc_font.data + (c & charmask) * vc->vc_font.height * width;
+
+	pitch = width + scan_align;
+	pitch &= ~scan_align;
+	size = pitch * vc->vc_font.height;
+	size += buf_align;
+	size &= ~buf_align;
+
+	dst = fb_get_buffer_offset(info, &info->pixmap, size);
+	image.data = dst;
+
+	if (info->pixmap.outbuf)
+		fb_iomove_buf_aligned(info, &info->pixmap, dst, pitch, src, width, image.height);
+	else
+		fb_sysmove_buf_aligned(info, &info->pixmap, dst, pitch, src, width, image.height);
+
+	info->fbops->fb_imageblit(info, &image);
+}
+
+static void fbcon_putcs(struct vc_data *vc, const unsigned short *s,
+			int count, int ypos, int xpos)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+
+	if (!info->fbops->fb_blank && console_blanked)
+		return;
+	if (info->state != FBINFO_STATE_RUNNING)
+		return;
+
+	if (vt_cons[vc->vc_num]->vc_mode != KD_TEXT)
+		return;
+
+	accel_putcs(vc, info, s, count, real_y(p, ypos), xpos);
+}
+
+static void fbcon_cursor(struct vc_data *vc, int mode)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	int bgshift = (vc->vc_hi_font_mask) ? 13 : 12;
+	int fgshift = (vc->vc_hi_font_mask) ? 9 : 8;
+	struct display *p = &fb_display[vc->vc_num];
+	int w = (vc->vc_font.width + 7) >> 3, c;
+	int y = real_y(p, vc->vc_y);
+	struct fb_cursor cursor;
+	
+	if (mode & CM_SOFTBACK) {
+		mode &= ~CM_SOFTBACK;
+		if (softback_lines) {
+			if (y + softback_lines >= vc->vc_rows)
+				mode = CM_ERASE;
+			else
+				y += softback_lines;
+		}
+	} else if (softback_lines)
+		fbcon_set_origin(vc);
+
+ 	c = scr_readw((u16 *) vc->vc_pos);
+
+	cursor.image.data = vc->vc_font.data + ((c & charmask) * (w * vc->vc_font.height));
+	cursor.set = FB_CUR_SETCUR;
+	cursor.image.depth = 1;
+	
+	switch (mode) {
+	case CM_ERASE:
+		if (info->cursor.rop == ROP_XOR) {
+			info->cursor.enable = 0;
+			info->cursor.rop = ROP_COPY;
+#ifdef CONFIG_BOOTSPLASH
+			if (info->splash_data) {
+				splash_cursor(info->splash_data, info, &cursor);
+				break;
+			}
+#endif
+			info->fbops->fb_cursor(info, &cursor);
+		}	
+		break;
+	case CM_MOVE:
+	case CM_DRAW:
+		info->cursor.enable = 1;
+		
+		if (info->cursor.image.fg_color != attr_fgcol(fgshift, c) ||
+	    	    info->cursor.image.bg_color != attr_bgcol(bgshift, c)) {
+			cursor.image.fg_color = attr_fgcol(fgshift, c);
+			cursor.image.bg_color = attr_bgcol(bgshift, c);
+			cursor.set |= FB_CUR_SETCMAP;
+		}
+		
+		if ((info->cursor.image.dx != (vc->vc_font.width * vc->vc_x)) ||
+		    (info->cursor.image.dy != (vc->vc_font.height * y))) {
+			cursor.image.dx = vc->vc_font.width * vc->vc_x;
+			cursor.image.dy = vc->vc_font.height * y;
+			cursor.set |= FB_CUR_SETPOS;
+		}
+
+		if (info->cursor.image.height != vc->vc_font.height ||
+		    info->cursor.image.width != vc->vc_font.width) {
+			cursor.image.height = vc->vc_font.height;
+			cursor.image.width = vc->vc_font.width;
+			cursor.set |= FB_CUR_SETSIZE;
+		}
+
+		if (info->cursor.hot.x || info->cursor.hot.y) {
+			cursor.hot.x = cursor.hot.y = 0;
+			cursor.set |= FB_CUR_SETHOT;
+		}
+
+		if ((cursor.set & FB_CUR_SETSIZE) || ((vc->vc_cursor_type & 0x0f) != p->cursor_shape)
+		    || info->cursor.mask == NULL) {
+			char *mask = kmalloc(w*vc->vc_font.height, GFP_ATOMIC);
+			int cur_height, size, i = 0;
+
+			if (!mask)	return;	
+		
+			if (info->cursor.mask)
+				kfree(info->cursor.mask);
+			info->cursor.mask = mask;
+	
+			p->cursor_shape = vc->vc_cursor_type & 0x0f;
+			cursor.set |= FB_CUR_SETSHAPE;
+
+			switch (vc->vc_cursor_type & 0x0f) {
+			case CUR_NONE:
+				cur_height = 0;
+				break;
+			case CUR_UNDERLINE:
+				cur_height = (vc->vc_font.height < 10) ? 1 : 2;
+				break;
+			case CUR_LOWER_THIRD:
+				cur_height = vc->vc_font.height/3;
+				break;
+			case CUR_LOWER_HALF:
+				cur_height = vc->vc_font.height >> 1;
+				break;
+			case CUR_TWO_THIRDS:
+				cur_height = (vc->vc_font.height << 1)/3;
+				break;
+			case CUR_BLOCK:
+			default:
+				cur_height = vc->vc_font.height;
+				break;
+			}
+			size = (vc->vc_font.height - cur_height) * w;
+			while (size--)
+				mask[i++] = 0;
+			size = cur_height * w;
+			while (size--)
+				mask[i++] = 0xff;
+		}
+        	info->cursor.rop = ROP_XOR;
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data) {
+			splash_cursor(info->splash_data, info, &cursor);
+			vbl_cursor_cnt = CURSOR_DRAW_DELAY;
+			break;
+		}
+#endif
+		info->fbops->fb_cursor(info, &cursor);
+		vbl_cursor_cnt = CURSOR_DRAW_DELAY;
+		break;
+	}
+}
+
+static int scrollback_phys_max = 0;
+static int scrollback_max = 0;
+static int scrollback_current = 0;
+
+int update_var(int con, struct fb_info *info)
+{
+	if (con == info->currcon) 
+		return fb_pan_display(info, &info->var);
+	return 0;
+}
+
+static void fbcon_set_disp(struct fb_info *info, struct vc_data *vc)
+{
+	struct display *p = &fb_display[vc->vc_num], *t;
+	struct vc_data **default_mode = vc->vc_display_fg;
+	int display_fg = (*default_mode)->vc_num;
+	int rows, cols, charcnt = 256;
+
+	info->var.xoffset = info->var.yoffset = p->yscroll = 0;
+	t = &fb_display[display_fg];
+	if (!vc->vc_font.data) {
+		vc->vc_font.data = p->fontdata = t->fontdata;
+		vc->vc_font.width = (*default_mode)->vc_font.width;
+		vc->vc_font.height = (*default_mode)->vc_font.height;
+		p->userfont = t->userfont;
+		if (p->userfont)
+			REFCOUNT(p->fontdata)++;
+		con_copy_unimap(vc->vc_num, display_fg);
+	}
+	if (p->userfont)
+		charcnt = FNTCHARCNT(p->fontdata);
+
+	vc->vc_can_do_color = info->var.bits_per_pixel != 1;
+	vc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;
+	if (charcnt == 256) {
+		vc->vc_hi_font_mask = 0;
+	} else {
+		vc->vc_hi_font_mask = 0x100;
+		if (vc->vc_can_do_color)
+			vc->vc_complement_mask <<= 1;
+	}
+	cols = info->var.xres / vc->vc_font.width;
+	rows = info->var.yres / vc->vc_font.height;
+	vc_resize(vc->vc_num, cols, rows);
+	if (CON_IS_VISIBLE(vc)) {
+		update_screen(vc->vc_num);
+		if (softback_buf) {
+			int l = fbcon_softback_size / vc->vc_size_row;
+
+			if (l > 5)
+				softback_end = softback_buf + l *
+					vc->vc_size_row;
+			else {
+				/* Smaller scrollback makes no sense, and 0
+				   would screw the operation totally */
+				softback_top = 0;
+			}
+		}
+	}
+	switch_screen(fg_console);
+}
+
+static __inline__ void ywrap_up(struct vc_data *vc, int count)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	
+	p->yscroll += count;
+	if (p->yscroll >= p->vrows)	/* Deal with wrap */
+		p->yscroll -= p->vrows;
+	info->var.xoffset = 0;
+	info->var.yoffset = p->yscroll * vc->vc_font.height;
+	info->var.vmode |= FB_VMODE_YWRAP;
+	update_var(vc->vc_num, info);
+	scrollback_max += count;
+	if (scrollback_max > scrollback_phys_max)
+		scrollback_max = scrollback_phys_max;
+	scrollback_current = 0;
+}
+
+static __inline__ void ywrap_down(struct vc_data *vc, int count)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	
+	p->yscroll -= count;
+	if (p->yscroll < 0)	/* Deal with wrap */
+		p->yscroll += p->vrows;
+	info->var.xoffset = 0;
+	info->var.yoffset = p->yscroll * vc->vc_font.height;
+	info->var.vmode |= FB_VMODE_YWRAP;
+	update_var(vc->vc_num, info);
+	scrollback_max -= count;
+	if (scrollback_max < 0)
+		scrollback_max = 0;
+	scrollback_current = 0;
+}
+
+static __inline__ void ypan_up(struct vc_data *vc, int count)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	
+	p->yscroll += count;
+	if (p->yscroll > p->vrows - vc->vc_rows) {
+		accel_bmove(vc, info, p->vrows - vc->vc_rows, 
+			 	0, 0, 0, vc->vc_rows, vc->vc_cols);
+		p->yscroll -= p->vrows - vc->vc_rows;
+	}
+	info->var.xoffset = 0;
+	info->var.yoffset = p->yscroll * vc->vc_font.height;
+	info->var.vmode &= ~FB_VMODE_YWRAP;
+	update_var(vc->vc_num, info);
+	accel_clear_margins(vc, info, 1);
+	scrollback_max += count;
+	if (scrollback_max > scrollback_phys_max)
+		scrollback_max = scrollback_phys_max;
+	scrollback_current = 0;
+}
+
+static __inline__ void ypan_up_redraw(struct vc_data *vc, int t, int count)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	int redraw = 0;
+
+	p->yscroll += count;
+	if (p->yscroll > p->vrows - vc->vc_rows) {
+		p->yscroll -= p->vrows - vc->vc_rows;
+		redraw = 1;
+	}
+
+	info->var.xoffset = 0;
+	info->var.yoffset = p->yscroll * vc->vc_font.height;
+	info->var.vmode &= ~FB_VMODE_YWRAP;
+	if (redraw)
+		fbcon_redraw_move(vc, p, t + count, vc->vc_rows - count, t);
+	update_var(vc->vc_num, info);
+	accel_clear_margins(vc, info, 1);
+	scrollback_max += count;
+	if (scrollback_max > scrollback_phys_max)
+		scrollback_max = scrollback_phys_max;
+	scrollback_current = 0;
+}
+
+static __inline__ void ypan_down(struct vc_data *vc, int count)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	
+	p->yscroll -= count;
+	if (p->yscroll < 0) {
+		accel_bmove(vc, info, 0, 0, p->vrows - vc->vc_rows,
+			 	0, vc->vc_rows, vc->vc_cols);
+		p->yscroll += p->vrows - vc->vc_rows;
+	}
+	info->var.xoffset = 0;
+	info->var.yoffset = p->yscroll * vc->vc_font.height;
+	info->var.vmode &= ~FB_VMODE_YWRAP;
+	update_var(vc->vc_num, info);
+	accel_clear_margins(vc, info, 1);
+	scrollback_max -= count;
+	if (scrollback_max < 0)
+		scrollback_max = 0;
+	scrollback_current = 0;
+}
+
+static __inline__ void ypan_down_redraw(struct vc_data *vc, int t, int count)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	int redraw = 0;
+
+	p->yscroll -= count;
+	if (p->yscroll < 0) {
+		p->yscroll += p->vrows - vc->vc_rows;
+		redraw = 1;
+	}
+	info->var.xoffset = 0;
+	info->var.yoffset = p->yscroll * vc->vc_font.height;
+	info->var.vmode &= ~FB_VMODE_YWRAP;
+	if (redraw)
+		fbcon_redraw_move(vc, p, t, vc->vc_rows - count, t + count);
+	update_var(vc->vc_num, info);
+	accel_clear_margins(vc, info, 1);
+	scrollback_max -= count;
+	if (scrollback_max < 0)
+		scrollback_max = 0;
+	scrollback_current = 0;
+}
+
+static void fbcon_redraw_softback(struct vc_data *vc, struct display *p,
+				  long delta)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	int count = vc->vc_rows;
+	unsigned short *d, *s;
+	unsigned long n;
+	int line = 0;
+
+	d = (u16 *) softback_curr;
+	if (d == (u16 *) softback_in)
+		d = (u16 *) vc->vc_origin;
+	n = softback_curr + delta * vc->vc_size_row;
+	softback_lines -= delta;
+	if (delta < 0) {
+		if (softback_curr < softback_top && n < softback_buf) {
+			n += softback_end - softback_buf;
+			if (n < softback_top) {
+				softback_lines -=
+				    (softback_top - n) / vc->vc_size_row;
+				n = softback_top;
+			}
+		} else if (softback_curr >= softback_top
+			   && n < softback_top) {
+			softback_lines -=
+			    (softback_top - n) / vc->vc_size_row;
+			n = softback_top;
+		}
+	} else {
+		if (softback_curr > softback_in && n >= softback_end) {
+			n += softback_buf - softback_end;
+			if (n > softback_in) {
+				n = softback_in;
+				softback_lines = 0;
+			}
+		} else if (softback_curr <= softback_in && n > softback_in) {
+			n = softback_in;
+			softback_lines = 0;
+		}
+	}
+	if (n == softback_curr)
+		return;
+	softback_curr = n;
+	s = (u16 *) softback_curr;
+	if (s == (u16 *) softback_in)
+		s = (u16 *) vc->vc_origin;
+	while (count--) {
+		unsigned short *start;
+		unsigned short *le;
+		unsigned short c;
+		int x = 0;
+		unsigned short attr = 1;
+
+		start = s;
+		le = advance_row(s, 1);
+		do {
+			c = scr_readw(s);
+			if (attr != (c & 0xff00)) {
+				attr = c & 0xff00;
+				if (s > start) {
+					accel_putcs(vc, info, start, s - start,
+						    real_y(p, line), x);
+					x += s - start;
+					start = s;
+				}
+			}
+			if (c == scr_readw(d)) {
+				if (s > start) {
+					accel_putcs(vc, info, start, s - start,
+						    real_y(p, line), x);
+					x += s - start + 1;
+					start = s + 1;
+				} else {
+					x++;
+					start++;
+				}
+			}
+			s++;
+			d++;
+		} while (s < le);
+		if (s > start)
+			accel_putcs(vc, info, start, s - start,
+				    real_y(p, line), x);
+		line++;
+		if (d == (u16 *) softback_end)
+			d = (u16 *) softback_buf;
+		if (d == (u16 *) softback_in)
+			d = (u16 *) vc->vc_origin;
+		if (s == (u16 *) softback_end)
+			s = (u16 *) softback_buf;
+		if (s == (u16 *) softback_in)
+			s = (u16 *) vc->vc_origin;
+	}
+}
+
+static void fbcon_redraw_move(struct vc_data *vc, struct display *p,
+			      int line, int count, int dy)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	unsigned short *s = (unsigned short *)
+		(vc->vc_origin + vc->vc_size_row * line);
+
+	while (count--) {
+		unsigned short *start = s;
+		unsigned short *le = advance_row(s, 1);
+		unsigned short c;
+		int x = 0;
+		unsigned short attr = 1;
+
+		do {
+			c = scr_readw(s);
+			if (attr != (c & 0xff00)) {
+				attr = c & 0xff00;
+				if (s > start) {
+					accel_putcs(vc, info, start, s - start,
+						    real_y(p, dy), x);
+					x += s - start;
+					start = s;
+				}
+			}
+			console_conditional_schedule();
+			s++;
+		} while (s < le);
+		if (s > start)
+			accel_putcs(vc, info, start, s - start,
+				    real_y(p, dy), x);
+		console_conditional_schedule();
+		dy++;
+	}
+}
+
+static void fbcon_redraw(struct vc_data *vc, struct display *p,
+			 int line, int count, int offset)
+{
+	unsigned short *d = (unsigned short *)
+	    (vc->vc_origin + vc->vc_size_row * line);
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	unsigned short *s = d + offset;
+
+	while (count--) {
+		unsigned short *start = s;
+		unsigned short *le = advance_row(s, 1);
+		unsigned short c;
+		int x = 0;
+		unsigned short attr = 1;
+
+		do {
+			c = scr_readw(s);
+			if (attr != (c & 0xff00)) {
+				attr = c & 0xff00;
+				if (s > start) {
+					accel_putcs(vc, info, start, s - start,
+						    real_y(p, line), x);
+					x += s - start;
+					start = s;
+				}
+			}
+			if (c == scr_readw(d)) {
+				if (s > start) {
+					accel_putcs(vc, info, start, s - start,
+						    real_y(p, line), x);
+					x += s - start + 1;
+					start = s + 1;
+				} else {
+					x++;
+					start++;
+				}
+			}
+			scr_writew(c, d);
+			console_conditional_schedule();
+			s++;
+			d++;
+		} while (s < le);
+		if (s > start)
+			accel_putcs(vc, info, start, s - start,
+				    real_y(p, line), x);
+		console_conditional_schedule();
+		if (offset > 0)
+			line++;
+		else {
+			line--;
+			/* NOTE: We subtract two lines from these pointers */
+			s -= vc->vc_size_row;
+			d -= vc->vc_size_row;
+		}
+	}
+}
+
+static inline void fbcon_softback_note(struct vc_data *vc, int t,
+				       int count)
+{
+	unsigned short *p;
+
+	if (vc->vc_num != fg_console)
+		return;
+	p = (unsigned short *) (vc->vc_origin + t * vc->vc_size_row);
+
+	while (count) {
+		scr_memcpyw((u16 *) softback_in, p, vc->vc_size_row);
+		count--;
+		p = advance_row(p, 1);
+		softback_in += vc->vc_size_row;
+		if (softback_in == softback_end)
+			softback_in = softback_buf;
+		if (softback_in == softback_top) {
+			softback_top += vc->vc_size_row;
+			if (softback_top == softback_end)
+				softback_top = softback_buf;
+		}
+	}
+	softback_curr = softback_in;
+}
+
+static int fbcon_scroll(struct vc_data *vc, int t, int b, int dir,
+			int count)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	int scroll_partial = info->flags & FBINFO_PARTIAL_PAN_OK;
+
+	if (!info->fbops->fb_blank && console_blanked)
+		return 0;
+
+	if (!count || vt_cons[vc->vc_num]->vc_mode != KD_TEXT)
+		return 0;
+
+	fbcon_cursor(vc, CM_ERASE);
+
+	/*
+	 * ++Geert: Only use ywrap/ypan if the console is in text mode
+	 * ++Andrew: Only use ypan on hardware text mode when scrolling the
+	 *           whole screen (prevents flicker).
+	 */
+
+	switch (dir) {
+	case SM_UP:
+		if (count > vc->vc_rows)	/* Maximum realistic size */
+			count = vc->vc_rows;
+		if (softback_top)
+			fbcon_softback_note(vc, t, count);
+		if (logo_shown >= 0)
+			goto redraw_up;
+		switch (p->scrollmode) {
+		case SCROLL_MOVE:
+			accel_bmove(vc, info, t + count, 0, t, 0,
+					 b - t - count, vc->vc_cols);
+			accel_clear(vc, info, b - count, 0, count,
+					 vc->vc_cols);
+			break;
+
+		case SCROLL_WRAP_MOVE:
+			if (b - t - count > 3 * vc->vc_rows >> 2) {
+				if (t > 0)
+					fbcon_bmove(vc, 0, 0, count, 0, t,
+						    vc->vc_cols);
+				ywrap_up(vc, count);
+				if (vc->vc_rows - b > 0)
+					fbcon_bmove(vc, b - count, 0, b, 0,
+						    vc->vc_rows - b,
+						    vc->vc_cols);
+			} else if (info->flags & FBINFO_READS_FAST)
+				fbcon_bmove(vc, t + count, 0, t, 0,
+					    b - t - count, vc->vc_cols);
+			else
+				goto redraw_up;
+			fbcon_clear(vc, b - count, 0, count, vc->vc_cols);
+			break;
+
+		case SCROLL_PAN_REDRAW:
+			if ((p->yscroll + count <=
+			     2 * (p->vrows - vc->vc_rows))
+			    && ((!scroll_partial && (b - t == vc->vc_rows))
+				|| (scroll_partial
+				    && (b - t - count >
+					3 * vc->vc_rows >> 2)))) {
+				if (t > 0)
+					fbcon_redraw_move(vc, p, 0, t, count);
+				ypan_up_redraw(vc, t, count);
+				if (vc->vc_rows - b > 0)
+					fbcon_redraw_move(vc, p, b - count,
+							  vc->vc_rows - b, b);
+			} else
+				fbcon_redraw_move(vc, p, t + count, b - t - count, t);
+			fbcon_clear(vc, b - count, 0, count, vc->vc_cols);
+			break;
+
+		case SCROLL_PAN_MOVE:
+			if ((p->yscroll + count <=
+			     2 * (p->vrows - vc->vc_rows))
+			    && ((!scroll_partial && (b - t == vc->vc_rows))
+				|| (scroll_partial
+				    && (b - t - count >
+					3 * vc->vc_rows >> 2)))) {
+				if (t > 0)
+					fbcon_bmove(vc, 0, 0, count, 0, t,
+						    vc->vc_cols);
+				ypan_up(vc, count);
+				if (vc->vc_rows - b > 0)
+					fbcon_bmove(vc, b - count, 0, b, 0,
+						    vc->vc_rows - b,
+						    vc->vc_cols);
+			} else if (info->flags & FBINFO_READS_FAST)
+				fbcon_bmove(vc, t + count, 0, t, 0,
+					    b - t - count, vc->vc_cols);
+			else
+				goto redraw_up;
+			fbcon_clear(vc, b - count, 0, count, vc->vc_cols);
+			break;
+
+		case SCROLL_REDRAW:
+		      redraw_up:
+			fbcon_redraw(vc, p, t, b - t - count,
+				     count * vc->vc_cols);
+			accel_clear(vc, info, real_y(p, b - count), 0,
+					 count, vc->vc_cols);
+			scr_memsetw((unsigned short *) (vc->vc_origin +
+							vc->vc_size_row *
+							(b - count)),
+				    vc->vc_video_erase_char,
+				    vc->vc_size_row * count);
+			return 1;
+		}
+		break;
+
+	case SM_DOWN:
+		if (count > vc->vc_rows)	/* Maximum realistic size */
+			count = vc->vc_rows;
+		switch (p->scrollmode) {
+		case SCROLL_MOVE:
+			accel_bmove(vc, info, t, 0, t + count, 0,
+					 b - t - count, vc->vc_cols);
+			accel_clear(vc, info, t, 0, count, vc->vc_cols);
+			break;
+
+		case SCROLL_WRAP_MOVE:
+			if (b - t - count > 3 * vc->vc_rows >> 2) {
+				if (vc->vc_rows - b > 0)
+					fbcon_bmove(vc, b, 0, b - count, 0,
+						    vc->vc_rows - b,
+						    vc->vc_cols);
+				ywrap_down(vc, count);
+				if (t > 0)
+					fbcon_bmove(vc, count, 0, 0, 0, t,
+						    vc->vc_cols);
+			} else if (info->flags & FBINFO_READS_FAST)
+				fbcon_bmove(vc, t, 0, t + count, 0,
+					    b - t - count, vc->vc_cols);
+			else
+				goto redraw_down;
+			fbcon_clear(vc, t, 0, count, vc->vc_cols);
+			break;
+
+		case SCROLL_PAN_MOVE:
+			if ((count - p->yscroll <= p->vrows - vc->vc_rows)
+			    && ((!scroll_partial && (b - t == vc->vc_rows))
+				|| (scroll_partial
+				    && (b - t - count >
+					3 * vc->vc_rows >> 2)))) {
+				if (vc->vc_rows - b > 0)
+					fbcon_bmove(vc, b, 0, b - count, 0,
+						    vc->vc_rows - b,
+						    vc->vc_cols);
+				ypan_down(vc, count);
+				if (t > 0)
+					fbcon_bmove(vc, count, 0, 0, 0, t,
+						    vc->vc_cols);
+			} else if (info->flags & FBINFO_READS_FAST)
+				fbcon_bmove(vc, t, 0, t + count, 0,
+					    b - t - count, vc->vc_cols);
+			else
+				goto redraw_down;
+			fbcon_clear(vc, t, 0, count, vc->vc_cols);
+			break;
+
+		case SCROLL_PAN_REDRAW:
+			if ((count - p->yscroll <= p->vrows - vc->vc_rows)
+			    && ((!scroll_partial && (b - t == vc->vc_rows))
+				|| (scroll_partial
+				    && (b - t - count >
+					3 * vc->vc_rows >> 2)))) {
+				if (vc->vc_rows - b > 0)
+					fbcon_redraw_move(vc, p, b, vc->vc_rows - b,
+							  b - count);
+				ypan_down_redraw(vc, t, count);
+				if (t > 0)
+					fbcon_redraw_move(vc, p, count, t, 0);
+			} else
+				fbcon_redraw_move(vc, p, t, b - t - count, t + count);
+			fbcon_clear(vc, t, 0, count, vc->vc_cols);
+			break;
+
+		case SCROLL_REDRAW:
+		      redraw_down:
+			fbcon_redraw(vc, p, b - 1, b - t - count,
+				     -count * vc->vc_cols);
+			accel_clear(vc, info, real_y(p, t), 0, count,
+					 vc->vc_cols);
+			scr_memsetw((unsigned short *) (vc->vc_origin +
+							vc->vc_size_row *
+							t),
+				    vc->vc_video_erase_char,
+				    vc->vc_size_row * count);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+
+static void fbcon_bmove(struct vc_data *vc, int sy, int sx, int dy, int dx,
+			int height, int width)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	
+	if (!info->fbops->fb_blank && console_blanked)
+		return;
+
+	if (!width || !height)
+		return;
+
+	/*  Split blits that cross physical y_wrap case.
+	 *  Pathological case involves 4 blits, better to use recursive
+	 *  code rather than unrolled case
+	 *
+	 *  Recursive invocations don't need to erase the cursor over and
+	 *  over again, so we use fbcon_bmove_rec()
+	 */
+	fbcon_bmove_rec(vc, p, sy, sx, dy, dx, height, width,
+			p->vrows - p->yscroll);
+}
+
+static void fbcon_bmove_rec(struct vc_data *vc, struct display *p, int sy, int sx, 
+			    int dy, int dx, int height, int width, u_int y_break)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	u_int b;
+
+	if (sy < y_break && sy + height > y_break) {
+		b = y_break - sy;
+		if (dy < sy) {	/* Avoid trashing self */
+			fbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,
+					y_break);
+			fbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,
+					height - b, width, y_break);
+		} else {
+			fbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,
+					height - b, width, y_break);
+			fbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,
+					y_break);
+		}
+		return;
+	}
+
+	if (dy < y_break && dy + height > y_break) {
+		b = y_break - dy;
+		if (dy < sy) {	/* Avoid trashing self */
+			fbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,
+					y_break);
+			fbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,
+					height - b, width, y_break);
+		} else {
+			fbcon_bmove_rec(vc, p, sy + b, sx, dy + b, dx,
+					height - b, width, y_break);
+			fbcon_bmove_rec(vc, p, sy, sx, dy, dx, b, width,
+					y_break);
+		}
+		return;
+	}
+#ifdef CONFIG_BOOTSPLASH
+	if (info->splash_data && sy == dy && height == 1) {
+		/* must use slower redraw bmove to keep background pic intact */
+		splash_bmove_redraw(info->splash_data, vc, info, sy, sx, dx, width);
+		return;
+	}
+#endif
+	accel_bmove(vc, info, real_y(p, sy), sx, real_y(p, dy), dx,
+			height, width);
+}
+
+static __inline__ void updatescrollmode(struct display *p, struct fb_info *info,
+					struct vc_data *vc)
+{
+	int fh = vc->vc_font.height;
+	int cap = info->flags;
+	int good_pan = (cap & FBINFO_HWACCEL_YPAN)
+		 && divides(info->fix.ypanstep, vc->vc_font.height)
+		 && info->var.yres_virtual > info->var.yres;
+	int good_wrap = (cap & FBINFO_HWACCEL_YWRAP)
+		 && divides(info->fix.ywrapstep, vc->vc_font.height)
+		 && divides(vc->vc_font.height, info->var.yres_virtual);
+	int reading_fast = cap & FBINFO_READS_FAST;
+	int fast_copyarea = (cap & FBINFO_HWACCEL_COPYAREA) && !(cap & FBINFO_HWACCEL_DISABLED);
+	int fast_imageblit = (cap & FBINFO_HWACCEL_IMAGEBLIT) && !(cap & FBINFO_HWACCEL_DISABLED);
+
+	p->vrows = info->var.yres_virtual/fh;
+	if (info->var.yres > (fh * (vc->vc_rows + 1)))
+		p->vrows -= (info->var.yres - (fh * vc->vc_rows)) / fh;
+	if ((info->var.yres % fh) && (info->var.yres_virtual % fh <
+				      info->var.yres % fh))
+		p->vrows--;
+
+	if (good_wrap || good_pan) {
+		if (reading_fast || fast_copyarea)
+			p->scrollmode = good_wrap ? SCROLL_WRAP_MOVE : SCROLL_PAN_MOVE;
+		else
+			p->scrollmode = good_wrap ? SCROLL_REDRAW :
+				SCROLL_PAN_REDRAW;
+	} else {
+		if (reading_fast || (fast_copyarea && !fast_imageblit))
+			p->scrollmode = SCROLL_MOVE;
+		else
+			p->scrollmode = SCROLL_REDRAW;
+	}
+}
+
+static int fbcon_resize(struct vc_data *vc, unsigned int width, 
+			unsigned int height)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	struct fb_var_screeninfo var = info->var;
+	int err; int x_diff, y_diff;
+	int fw = vc->vc_font.width;
+	int fh = vc->vc_font.height;
+
+	var.xres = width * fw;
+	var.yres = height * fh;
+	x_diff = info->var.xres - var.xres;
+	y_diff = info->var.yres - var.yres;
+	if (x_diff < 0 || x_diff > fw || (y_diff < 0 || y_diff > fh)) {
+		char mode[40];
+
+		DPRINTK("attempting resize %ix%i\n", var.xres, var.yres);
+		snprintf(mode, 40, "%ix%i", var.xres, var.yres);
+		err = fb_find_mode(&var, info, mode, info->monspecs.modedb,
+				   info->monspecs.modedb_len, NULL,
+				   info->var.bits_per_pixel);
+		if (!err || width > var.xres/fw || height > var.yres/fh)
+			return -EINVAL;
+		DPRINTK("resize now %ix%i\n", var.xres, var.yres);
+		if (CON_IS_VISIBLE(vc)) {
+			var.activate = FB_ACTIVATE_NOW |
+				FB_ACTIVATE_FORCE;
+			fb_set_var(info, &var);
+			info->flags &= ~FBINFO_MISC_MODESWITCH;
+		}
+	}
+	updatescrollmode(p, info, vc);
+	return 0;
+}
+
+static int fbcon_switch(struct vc_data *vc)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	int i;
+
+#ifdef CONFIG_BOOTSPLASH
+	splash_prepare(vc, info);
+#endif
+
+	if (softback_top) {
+		int l = fbcon_softback_size / vc->vc_size_row;
+		if (softback_lines)
+			fbcon_set_origin(vc);
+		softback_top = softback_curr = softback_in = softback_buf;
+		softback_lines = 0;
+
+		if (l > 5)
+			softback_end = softback_buf + l * vc->vc_size_row;
+		else {
+			/* Smaller scrollback makes no sense, and 0 would screw
+			   the operation totally */
+			softback_top = 0;
+		}
+	}
+	if (logo_shown >= 0) {
+		struct vc_data *conp2 = vc_cons[logo_shown].d;
+
+		if (conp2->vc_top == logo_lines
+		    && conp2->vc_bottom == conp2->vc_rows)
+			conp2->vc_top = 0;
+		logo_shown = -1;
+	}
+	if (info)
+		info->var.yoffset = p->yscroll = 0;
+
+	/*
+	 * FIXME: If we have multiple fbdev's loaded, we need to
+	 * update all info->currcon.  Perhaps, we can place this
+	 * in a centralized structure, but this might break some
+	 * drivers.
+	 *
+	 * info->currcon = vc->vc_num;
+	 */
+	for (i = 0; i < FB_MAX; i++) {
+		if (registered_fb[i] != NULL)
+			registered_fb[i]->currcon = vc->vc_num;
+	}
+
+ 	fbcon_resize(vc, vc->vc_cols, vc->vc_rows);
+
+	if (info->flags & FBINFO_MISC_MODESWITCH) {
+		if (info->fbops->fb_set_par)
+			info->fbops->fb_set_par(info);
+		info->flags &= ~FBINFO_MISC_MODESWITCH;
+	}
+
+	switch (p->scrollmode) {
+	case SCROLL_WRAP_MOVE:
+		scrollback_phys_max = p->vrows - vc->vc_rows;
+		break;
+	case SCROLL_PAN_MOVE:
+	case SCROLL_PAN_REDRAW:
+		scrollback_phys_max = p->vrows - 2 * vc->vc_rows;
+		if (scrollback_phys_max < 0)
+			scrollback_phys_max = 0;
+		break;
+	default:
+		scrollback_phys_max = 0;
+		break;
+	}
+	scrollback_max = 0;
+	scrollback_current = 0;
+
+	update_var(vc->vc_num, info);
+	fbcon_set_palette(vc, color_table); 	
+
+	if (vt_cons[vc->vc_num]->vc_mode == KD_TEXT)
+		accel_clear_margins(vc, info, 0);
+	if (logo_shown == -2) {
+		logo_shown = fg_console;
+		/* This is protected above by initmem_freed */
+		fb_show_logo(info);
+		update_region(fg_console,
+			      vc->vc_origin + vc->vc_size_row * vc->vc_top,
+			      vc->vc_size_row * (vc->vc_bottom -
+						 vc->vc_top) / 2);
+		return 0;
+	}
+	return 1;
+}
+
+static int fbcon_blank(struct vc_data *vc, int blank, int mode_switch)
+{
+	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+
+	if (mode_switch) {
+		struct fb_var_screeninfo var = info->var;
+
+/*
+ * HACK ALERT: Some hardware will require reinitializion at this stage,
+ *             others will require it to be done as late as possible.
+ *             For now, we differentiate this with the
+ *             FBINFO_MISC_MODESWITCHLATE bitflag.  Worst case will be
+ *             hardware that requires it here and another one later.
+ *             A definitive solution may require fixing X or the VT
+ *             system.
+ */
+		if (info->flags & FBINFO_MISC_MODESWITCHLATE)
+			info->flags |= FBINFO_MISC_MODESWITCH;
+
+		if (blank) {
+			fbcon_cursor(vc, CM_ERASE);
+			return 0;
+		}
+
+		if (!(info->flags & FBINFO_MISC_MODESWITCHLATE)) {
+			var.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
+			fb_set_var(info, &var);
+		}
+	}
+
+	fbcon_cursor(vc, blank ? CM_ERASE : CM_DRAW);
+
+	if (!info->fbops->fb_blank) {
+#ifdef CONFIG_BOOTSPLASH
+		if (info->splash_data) {
+			splash_blank(info->splash_data, vc, info, blank);
+			return 0;
+		}
+#endif
+		if (blank) {
+			unsigned short oldc;
+			u_int height;
+			u_int y_break;
+
+			oldc = vc->vc_video_erase_char;
+			vc->vc_video_erase_char &= charmask;
+			height = vc->vc_rows;
+			y_break = p->vrows - p->yscroll;
+			if (height > y_break) {
+				accel_clear(vc, info, real_y(p, 0),
+					    0, y_break, vc->vc_cols);
+				accel_clear(vc, info, real_y(p, y_break),
+					    0, height - y_break, 
+					    vc->vc_cols);
+			} else
+				accel_clear(vc, info, real_y(p, 0),
+					    0, height, vc->vc_cols);
+			vc->vc_video_erase_char = oldc;
+		} else
+			update_screen(vc->vc_num);
+		return 0;
+	} else
+		return fb_blank(info, blank);
+}
+
+static void fbcon_free_font(struct display *p)
+{
+	if (p->userfont && p->fontdata && (--REFCOUNT(p->fontdata) == 0))
+		kfree(p->fontdata - FONT_EXTRA_WORDS * sizeof(int));
+	p->fontdata = NULL;
+	p->userfont = 0;
+}
+
+static int fbcon_get_font(struct vc_data *vc, struct console_font *font)
+{
+	u8 *fontdata = vc->vc_font.data;
+	u8 *data = font->data;
+	int i, j;
+
+	font->width = vc->vc_font.width;
+	font->height = vc->vc_font.height;
+	font->charcount = vc->vc_hi_font_mask ? 512 : 256;
+	if (!font->data)
+		return 0;
+
+	if (font->width <= 8) {
+		j = vc->vc_font.height;
+		for (i = 0; i < font->charcount; i++) {
+			memcpy(data, fontdata, j);
+			memset(data + j, 0, 32 - j);
+			data += 32;
+			fontdata += j;
+		}
+	} else if (font->width <= 16) {
+		j = vc->vc_font.height * 2;
+		for (i = 0; i < font->charcount; i++) {
+			memcpy(data, fontdata, j);
+			memset(data + j, 0, 64 - j);
+			data += 64;
+			fontdata += j;
+		}
+	} else if (font->width <= 24) {
+		for (i = 0; i < font->charcount; i++) {
+			for (j = 0; j < vc->vc_font.height; j++) {
+				*data++ = fontdata[0];
+				*data++ = fontdata[1];
+				*data++ = fontdata[2];
+				fontdata += sizeof(u32);
+			}
+			memset(data, 0, 3 * (32 - j));
+			data += 3 * (32 - j);
+		}
+	} else {
+		j = vc->vc_font.height * 4;
+		for (i = 0; i < font->charcount; i++) {
+			memcpy(data, fontdata, j);
+			memset(data + j, 0, 128 - j);
+			data += 128;
+			fontdata += j;
+		}
+	}
+	return 0;
+}
+
+static int fbcon_do_set_font(struct vc_data *vc, int w, int h,
+			     u8 * data, int userfont)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct display *p = &fb_display[vc->vc_num];
+	int resize;
+	int cnt;
+	char *old_data = NULL;
+
+	if (CON_IS_VISIBLE(vc) && softback_lines)
+		fbcon_set_origin(vc);
+
+	resize = (w != vc->vc_font.width) || (h != vc->vc_font.height);
+	if (p->userfont)
+		old_data = vc->vc_font.data;
+	if (userfont)
+		cnt = FNTCHARCNT(data);
+	else
+		cnt = 256;
+	vc->vc_font.data = p->fontdata = data;
+	if ((p->userfont = userfont))
+		REFCOUNT(data)++;
+	vc->vc_font.width = w;
+	vc->vc_font.height = h;
+	if (vc->vc_hi_font_mask && cnt == 256) {
+		vc->vc_hi_font_mask = 0;
+		if (vc->vc_can_do_color) {
+			vc->vc_complement_mask >>= 1;
+			vc->vc_s_complement_mask >>= 1;
+		}
+			
+		/* ++Edmund: reorder the attribute bits */
+		if (vc->vc_can_do_color) {
+			unsigned short *cp =
+			    (unsigned short *) vc->vc_origin;
+			int count = vc->vc_screenbuf_size / 2;
+			unsigned short c;
+			for (; count > 0; count--, cp++) {
+				c = scr_readw(cp);
+				scr_writew(((c & 0xfe00) >> 1) |
+					   (c & 0xff), cp);
+			}
+			c = vc->vc_video_erase_char;
+			vc->vc_video_erase_char =
+			    ((c & 0xfe00) >> 1) | (c & 0xff);
+			vc->vc_attr >>= 1;
+		}
+	} else if (!vc->vc_hi_font_mask && cnt == 512) {
+		vc->vc_hi_font_mask = 0x100;
+		if (vc->vc_can_do_color) {
+			vc->vc_complement_mask <<= 1;
+			vc->vc_s_complement_mask <<= 1;
+		}
+			
+		/* ++Edmund: reorder the attribute bits */
+		{
+			unsigned short *cp =
+			    (unsigned short *) vc->vc_origin;
+			int count = vc->vc_screenbuf_size / 2;
+			unsigned short c;
+			for (; count > 0; count--, cp++) {
+				unsigned short newc;
+				c = scr_readw(cp);
+				if (vc->vc_can_do_color)
+					newc =
+					    ((c & 0xff00) << 1) | (c &
+								   0xff);
+				else
+					newc = c & ~0x100;
+				scr_writew(newc, cp);
+			}
+			c = vc->vc_video_erase_char;
+			if (vc->vc_can_do_color) {
+				vc->vc_video_erase_char =
+				    ((c & 0xff00) << 1) | (c & 0xff);
+				vc->vc_attr <<= 1;
+			} else
+				vc->vc_video_erase_char = c & ~0x100;
+		}
+
+	}
+
+	if (resize) {
+		/* reset wrap/pan */
+		info->var.xoffset = info->var.yoffset = p->yscroll = 0;
+		vc_resize(vc->vc_num, info->var.xres / w, info->var.yres / h);
+		if (CON_IS_VISIBLE(vc) && softback_buf) {
+			int l = fbcon_softback_size / vc->vc_size_row;
+			if (l > 5)
+				softback_end =
+				    softback_buf + l * vc->vc_size_row;
+			else {
+				/* Smaller scrollback makes no sense, and 0 would screw
+				   the operation totally */
+				softback_top = 0;
+			}
+		}
+	} else if (CON_IS_VISIBLE(vc)
+		   && vt_cons[vc->vc_num]->vc_mode == KD_TEXT) {
+		accel_clear_margins(vc, info, 0);
+		update_screen(vc->vc_num);
+	}
+
+	if (old_data && (--REFCOUNT(old_data) == 0))
+		kfree(old_data - FONT_EXTRA_WORDS * sizeof(int));
+	return 0;
+}
+
+static int fbcon_copy_font(struct vc_data *vc, int con)
+{
+	struct display *od = &fb_display[con];
+	struct console_font *f = &vc->vc_font;
+
+	if (od->fontdata == f->data)
+		return 0;	/* already the same font... */
+	return fbcon_do_set_font(vc, f->width, f->height, od->fontdata, od->userfont);
+}
+
+/*
+ *  User asked to set font; we are guaranteed that
+ *	a) width and height are in range 1..32
+ *	b) charcount does not exceed 512
+ */
+
+static int fbcon_set_font(struct vc_data *vc, struct console_font *font, unsigned flags)
+{
+	unsigned charcount = font->charcount;
+	int w = font->width;
+	int h = font->height;
+	int size = h;
+	int i, k;
+	u8 *new_data, *data = font->data, *p;
+
+	if (charcount != 256 && charcount != 512)
+		return -EINVAL;
+
+	if (w > 8) {
+		if (w <= 16)
+			size *= 2;
+		else
+			size *= 4;
+	}
+	size *= charcount;
+
+	new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);
+
+	if (!new_data)
+		return -ENOMEM;
+
+	new_data += FONT_EXTRA_WORDS * sizeof(int);
+	FNTSIZE(new_data) = size;
+	FNTCHARCNT(new_data) = charcount;
+	REFCOUNT(new_data) = 0;	/* usage counter */
+	p = new_data;
+	if (w <= 8) {
+		for (i = 0; i < charcount; i++) {
+			memcpy(p, data, h);
+			data += 32;
+			p += h;
+		}
+	} else if (w <= 16) {
+		h *= 2;
+		for (i = 0; i < charcount; i++) {
+			memcpy(p, data, h);
+			data += 64;
+			p += h;
+		}
+	} else if (w <= 24) {
+		for (i = 0; i < charcount; i++) {
+			int j;
+			for (j = 0; j < h; j++) {
+				memcpy(p, data, 3);
+				p[3] = 0;
+				data += 3;
+				p += sizeof(u32);
+			}
+			data += 3 * (32 - h);
+		}
+	} else {
+		h *= 4;
+		for (i = 0; i < charcount; i++) {
+			memcpy(p, data, h);
+			data += 128;
+			p += h;
+		}
+	}
+	/* we can do it in u32 chunks because of charcount is 256 or 512, so
+	   font length must be multiple of 256, at least. And 256 is multiple
+	   of 4 */
+	k = 0;
+	while (p > new_data) {
+		p = (u8 *)((u32 *)p - 1);
+		k += *(u32 *) p;
+	}
+	FNTSUM(new_data) = k;
+	/* Check if the same font is on some other console already */
+	for (i = 0; i < MAX_NR_CONSOLES; i++) {
+		struct vc_data *tmp = vc_cons[i].d;
+		
+		if (fb_display[i].userfont &&
+		    fb_display[i].fontdata &&
+		    FNTSUM(fb_display[i].fontdata) == k &&
+		    FNTSIZE(fb_display[i].fontdata) == size &&
+		    tmp->vc_font.width == w &&
+		    !memcmp(fb_display[i].fontdata, new_data, size)) {
+			kfree(new_data - FONT_EXTRA_WORDS * sizeof(int));
+			new_data = fb_display[i].fontdata;
+			break;
+		}
+	}
+	return fbcon_do_set_font(vc, font->width, font->height, new_data, 1);
+}
+
+static int fbcon_set_def_font(struct vc_data *vc, struct console_font *font, char *name)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	struct font_desc *f;
+
+	if (!name)
+		f = get_default_font(info->var.xres, info->var.yres);
+	else if (!(f = find_font(name)))
+		return -ENOENT;
+
+	font->width = f->width;
+	font->height = f->height;
+	return fbcon_do_set_font(vc, f->width, f->height, f->data, 0);
+}
+
+static u16 palette_red[16];
+static u16 palette_green[16];
+static u16 palette_blue[16];
+
+static struct fb_cmap palette_cmap = {
+	0, 16, palette_red, palette_green, palette_blue, NULL
+};
+
+static int fbcon_set_palette(struct vc_data *vc, unsigned char *table)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+	int i, j, k;
+	u8 val;
+
+	if (!vc->vc_can_do_color
+	    || (!info->fbops->fb_blank && console_blanked))
+		return -EINVAL;
+	for (i = j = 0; i < 16; i++) {
+		k = table[i];
+		val = vc->vc_palette[j++];
+		palette_red[k] = (val << 8) | val;
+		val = vc->vc_palette[j++];
+		palette_green[k] = (val << 8) | val;
+		val = vc->vc_palette[j++];
+		palette_blue[k] = (val << 8) | val;
+	}
+	if (info->var.bits_per_pixel <= 4)
+		palette_cmap.len = 1 << info->var.bits_per_pixel;
+	else
+		palette_cmap.len = 16;
+	palette_cmap.start = 0;
+	return fb_set_cmap(&palette_cmap, info);
+}
+
+static u16 *fbcon_screen_pos(struct vc_data *vc, int offset)
+{
+	unsigned long p;
+	int line;
+	
+	if (vc->vc_num != fg_console || !softback_lines)
+		return (u16 *) (vc->vc_origin + offset);
+	line = offset / vc->vc_size_row;
+	if (line >= softback_lines)
+		return (u16 *) (vc->vc_origin + offset -
+				softback_lines * vc->vc_size_row);
+	p = softback_curr + offset;
+	if (p >= softback_end)
+		p += softback_buf - softback_end;
+	return (u16 *) p;
+}
+
+static unsigned long fbcon_getxy(struct vc_data *vc, unsigned long pos,
+				 int *px, int *py)
+{
+	unsigned long ret;
+	int x, y;
+
+	if (pos >= vc->vc_origin && pos < vc->vc_scr_end) {
+		unsigned long offset = (pos - vc->vc_origin) / 2;
+
+		x = offset % vc->vc_cols;
+		y = offset / vc->vc_cols;
+		if (vc->vc_num == fg_console)
+			y += softback_lines;
+		ret = pos + (vc->vc_cols - x) * 2;
+	} else if (vc->vc_num == fg_console && softback_lines) {
+		unsigned long offset = pos - softback_curr;
+
+		if (pos < softback_curr)
+			offset += softback_end - softback_buf;
+		offset /= 2;
+		x = offset % vc->vc_cols;
+		y = offset / vc->vc_cols;
+		ret = pos + (vc->vc_cols - x) * 2;
+		if (ret == softback_end)
+			ret = softback_buf;
+		if (ret == softback_in)
+			ret = vc->vc_origin;
+	} else {
+		/* Should not happen */
+		x = y = 0;
+		ret = vc->vc_origin;
+	}
+	if (px)
+		*px = x;
+	if (py)
+		*py = y;
+	return ret;
+}
+
+/* As we might be inside of softback, we may work with non-contiguous buffer,
+   that's why we have to use a separate routine. */
+static void fbcon_invert_region(struct vc_data *vc, u16 * p, int cnt)
+{
+	while (cnt--) {
+		u16 a = scr_readw(p);
+		if (!vc->vc_can_do_color)
+			a ^= 0x0800;
+		else if (vc->vc_hi_font_mask == 0x100)
+			a = ((a) & 0x11ff) | (((a) & 0xe000) >> 4) |
+			    (((a) & 0x0e00) << 4);
+		else
+			a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) |
+			    (((a) & 0x0700) << 4);
+		scr_writew(a, p++);
+		if (p == (u16 *) softback_end)
+			p = (u16 *) softback_buf;
+		if (p == (u16 *) softback_in)
+			p = (u16 *) vc->vc_origin;
+	}
+}
+
+static int fbcon_scrolldelta(struct vc_data *vc, int lines)
+{
+	struct fb_info *info = registered_fb[(int) con2fb_map[fg_console]];
+	struct display *p = &fb_display[fg_console];
+	int offset, limit, scrollback_old;
+
+	if (softback_top) {
+		if (vc->vc_num != fg_console)
+			return 0;
+		if (vt_cons[vc->vc_num]->vc_mode != KD_TEXT || !lines)
+			return 0;
+		if (logo_shown >= 0) {
+			struct vc_data *conp2 = vc_cons[logo_shown].d;
+
+			if (conp2->vc_top == logo_lines
+			    && conp2->vc_bottom == conp2->vc_rows)
+				conp2->vc_top = 0;
+			if (logo_shown == vc->vc_num) {
+				unsigned long p, q;
+				int i;
+
+				p = softback_in;
+				q = vc->vc_origin +
+				    logo_lines * vc->vc_size_row;
+				for (i = 0; i < logo_lines; i++) {
+					if (p == softback_top)
+						break;
+					if (p == softback_buf)
+						p = softback_end;
+					p -= vc->vc_size_row;
+					q -= vc->vc_size_row;
+					scr_memcpyw((u16 *) q, (u16 *) p,
+						    vc->vc_size_row);
+				}
+				softback_in = p;
+				update_region(vc->vc_num, vc->vc_origin,
+					      logo_lines * vc->vc_cols);
+			}
+			logo_shown = -1;
+		}
+		fbcon_cursor(vc, CM_ERASE | CM_SOFTBACK);
+		fbcon_redraw_softback(vc, p, lines);
+		fbcon_cursor(vc, CM_DRAW | CM_SOFTBACK);
+		return 0;
+	}
+
+	if (!scrollback_phys_max)
+		return -ENOSYS;
+
+	scrollback_old = scrollback_current;
+	scrollback_current -= lines;
+	if (scrollback_current < 0)
+		scrollback_current = 0;
+	else if (scrollback_current > scrollback_max)
+		scrollback_current = scrollback_max;
+	if (scrollback_current == scrollback_old)
+		return 0;
+
+	if (!info->fbops->fb_blank &&
+	    (console_blanked || vt_cons[vc->vc_num]->vc_mode != KD_TEXT
+	     || !lines))
+		return 0;
+	fbcon_cursor(vc, CM_ERASE);
+
+	offset = p->yscroll - scrollback_current;
+	limit = p->vrows;
+	switch (p->scrollmode) {
+	case SCROLL_WRAP_MOVE:
+		info->var.vmode |= FB_VMODE_YWRAP;
+		break;
+	case SCROLL_PAN_MOVE:
+	case SCROLL_PAN_REDRAW:
+		limit -= vc->vc_rows;
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+		break;
+	}
+	if (offset < 0)
+		offset += limit;
+	else if (offset >= limit)
+		offset -= limit;
+	info->var.xoffset = 0;
+	info->var.yoffset = offset * vc->vc_font.height;
+	update_var(vc->vc_num, info);
+	if (!scrollback_current)
+		fbcon_cursor(vc, CM_DRAW);
+	return 0;
+}
+
+static int fbcon_set_origin(struct vc_data *vc)
+{
+	if (softback_lines && !console_blanked)
+		fbcon_scrolldelta(vc, softback_lines);
+	return 0;
+}
+
+static void fbcon_suspended(struct fb_info *info)
+{
+	/* Clear cursor, restore saved data */
+	info->cursor.enable = 0;
+	info->fbops->fb_cursor(info, &info->cursor);
+}
+
+static void fbcon_resumed(struct fb_info *info)
+{
+	struct vc_data *vc;
+
+	if (info->currcon < 0)
+		return;
+	vc = vc_cons[info->currcon].d;
+
+	update_screen(vc->vc_num);
+}
+
+static void fbcon_modechanged(struct fb_info *info)
+{
+	struct vc_data *vc = vc_cons[info->currcon].d;
+	struct display *p;
+	int rows, cols;
+
+	if (info->currcon < 0 || vt_cons[info->currcon]->vc_mode !=
+	    KD_TEXT)
+		return;
+	p = &fb_display[vc->vc_num];
+
+	info->var.xoffset = info->var.yoffset = p->yscroll = 0;
+	vc->vc_can_do_color = info->var.bits_per_pixel != 1;
+	vc->vc_complement_mask = vc->vc_can_do_color ? 0x7700 : 0x0800;
+
+	if (CON_IS_VISIBLE(vc)) {
+		cols = info->var.xres / vc->vc_font.width;
+		rows = info->var.yres / vc->vc_font.height;
+		vc_resize(vc->vc_num, cols, rows);
+		updatescrollmode(p, info, vc);
+		scrollback_max = 0;
+		scrollback_current = 0;
+		update_var(vc->vc_num, info);
+		fbcon_set_palette(vc, color_table);
+		update_screen(vc->vc_num);
+		if (softback_buf) {
+			int l = fbcon_softback_size / vc->vc_size_row;
+			if (l > 5)
+				softback_end = softback_buf + l * vc->vc_size_row;
+			else {
+				/* Smaller scrollback makes no sense, and 0
+				   would screw the operation totally */
+				softback_top = 0;
+			}
+		}
+	}
+}
+
+static int fbcon_event_notify(struct notifier_block *self, 
+			      unsigned long action, void *data)
+{
+	struct fb_info *info = (struct fb_info *) data;
+
+	switch(action) {
+	case FB_EVENT_SUSPEND:
+		fbcon_suspended(info);
+		break;
+	case FB_EVENT_RESUME:
+		fbcon_resumed(info);
+		break;
+	case FB_EVENT_MODE_CHANGE:
+		fbcon_modechanged(info);
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ *  The console `switch' structure for the frame buffer based console
+ */
+
+const struct consw fb_con = {
+	.owner			= THIS_MODULE,
+	.con_startup 		= fbcon_startup,
+	.con_init 		= fbcon_init,
+	.con_deinit 		= fbcon_deinit,
+	.con_clear 		= fbcon_clear,
+	.con_putc 		= fbcon_putc,
+	.con_putcs 		= fbcon_putcs,
+	.con_cursor 		= fbcon_cursor,
+	.con_scroll 		= fbcon_scroll,
+	.con_bmove 		= fbcon_bmove,
+	.con_switch 		= fbcon_switch,
+	.con_blank 		= fbcon_blank,
+	.con_font_set 		= fbcon_set_font,
+	.con_font_get 		= fbcon_get_font,
+	.con_font_default	= fbcon_set_def_font,
+	.con_font_copy 		= fbcon_copy_font,
+	.con_set_palette 	= fbcon_set_palette,
+	.con_scrolldelta 	= fbcon_scrolldelta,
+	.con_set_origin 	= fbcon_set_origin,
+	.con_invert_region 	= fbcon_invert_region,
+	.con_screen_pos 	= fbcon_screen_pos,
+	.con_getxy 		= fbcon_getxy,
+	.con_resize             = fbcon_resize,
+};
+
+static struct notifier_block fbcon_event_notifier = {
+	.notifier_call	= fbcon_event_notify,
+};
+static int fbcon_event_notifier_registered;
+
+/* can't be __init as it can be called by set_con2fb_map() later */
+int fb_console_init(void)
+{
+	int err, i;
+
+	for (i = 0; i < MAX_NR_CONSOLES; i++)
+		con2fb_map[i] = -1;
+
+	if (!num_registered_fb)
+		return -ENODEV;
+
+	if (info_idx == -1) {
+		for (i = 0; i < FB_MAX; i++) {
+			if (registered_fb[i] != NULL) {
+				info_idx = i;
+				break;
+			}
+		}
+	}
+	for (i = first_fb_vc; i <= last_fb_vc; i++)
+		con2fb_map[i] = info_idx;
+	err = take_over_console(&fb_con, first_fb_vc, last_fb_vc,
+				fbcon_is_default);
+	if (err) {
+		for (i = first_fb_vc; i <= last_fb_vc; i++) {
+			con2fb_map[i] = -1;
+		}
+		return err;
+	}
+	acquire_console_sem();
+	if (!fbcon_event_notifier_registered) {
+		fb_register_client(&fbcon_event_notifier);
+		fbcon_event_notifier_registered = 1;
+	} 
+	release_console_sem();
+	return 0;
+}
+
+#ifdef MODULE
+
+void __exit fb_console_exit(void)
+{
+	acquire_console_sem();
+	if (fbcon_event_notifier_registered) {
+		fb_unregister_client(&fbcon_event_notifier);
+		fbcon_event_notifier_registered = 0;
+	}
+	release_console_sem();
+	give_up_console(&fb_con);
+}	
+
+module_init(fb_console_init);
+module_exit(fb_console_exit);
+
+#endif
+
+/*
+ *  Visible symbols for modules
+ */
+
+EXPORT_SYMBOL(fb_display);
+EXPORT_SYMBOL(fb_con);
+
+MODULE_LICENSE("GPL");
Index: drivers/video/console/fbcon.h
===================================================================
--- .orig/drivers/video/console/fbcon.h
+++ /drivers/video/console/fbcon.h
@@ -23,6 +23,34 @@
     *    low-level frame buffer device
     */
 
+#ifdef CONFIG_BOOTSPLASH
+struct splash_data {
+    int splash_state;			/* show splash? */
+    int splash_color;			/* transparent color */
+    int splash_fg_color;		/* foreground color */
+    int splash_width;			/* width of image */
+    int splash_height;			/* height of image */
+    int splash_text_xo;			/* text area origin */
+    int splash_text_yo;
+    int splash_text_wi;			/* text area size */ 
+    int splash_text_he;
+    int splash_showtext;		/* silent/verbose mode */
+    int splash_boxcount;
+    int splash_percent;
+    int splash_overpaintok;		/* is it ok to overpaint boxes */
+    int splash_palcnt;
+    char *oldscreen_base;		/* pointer to top of virtual screen */
+    unsigned char *splash_boxes;
+    unsigned char *splash_jpeg;		/* jpeg */
+    unsigned char *splash_palette;	/* palette for 8-bit */
+
+    int splash_dosilent;		/* show silent jpeg */
+    unsigned char *splash_silentjpeg;
+    unsigned char *splash_sboxes;
+    int splash_sboxcount;
+};
+#endif
+    
 struct display {
     /* Filled in by the frame buffer device */
     u_short inverse;                /* != 0 text black on white as default */
Index: drivers/video/vesafb.c
===================================================================
--- .orig/drivers/video/vesafb.c
+++ /drivers/video/vesafb.c
@@ -171,7 +171,10 @@ static int vesafb_setcolreg(unsigned reg
     return 0;
 }
 
-static struct fb_ops vesafb_ops = {
+#ifndef CONFIG_BOOTSPLASH
+static
+#endif
+struct fb_ops vesafb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_setcolreg	= vesafb_setcolreg,
 	.fb_pan_display	= vesafb_pan_display,
Index: include/linux/console_struct.h
===================================================================
--- .orig/include/linux/console_struct.h
+++ /include/linux/console_struct.h
@@ -87,6 +87,9 @@ struct vc_data {
 	struct vc_data **vc_display_fg;		/* [!] Ptr to var holding fg console for this display */
 	unsigned long	vc_uni_pagedir;
 	unsigned long	*vc_uni_pagedir_loc;  /* [!] Location of uni_pagedir variable for this console */
+#ifdef CONFIG_BOOTSPLASH
+	struct splash_data *vc_splash_data;
+#endif
 	/* additional information is in vt_kern.h */
 };
 
Index: include/linux/fb.h
===================================================================
--- .orig/include/linux/fb.h
+++ /include/linux/fb.h
@@ -591,6 +591,15 @@ struct fb_info {
 
 	/* From here on everything is device dependent */
 	void *par;	
+#ifdef CONFIG_BOOTSPLASH
+	struct splash_data *splash_data;
+	unsigned char *splash_pic;
+	int splash_pic_size;
+	int splash_bytes;
+	char *silent_screen_base;       /* real screen base */
+	char fb_cursordata[64];
+#endif
+
 };
 
 #ifdef MODULE
Index: kernel/panic.c
===================================================================
--- .orig/kernel/panic.c
+++ /kernel/panic.c
@@ -82,6 +82,12 @@ NORET_TYPE void panic(const char * fmt, 
 		 * We can't use the "normal" timers since we just panicked..
 	 	 */
 		printk(KERN_EMERG "Rebooting in %d seconds..",panic_timeout);
+#ifdef CONFIG_BOOTSPLASH
+		{
+			extern int splash_verbose(void);
+			(void)splash_verbose();
+		}
+#endif
 		for (i = 0; i < panic_timeout; i++) {
 			touch_nmi_watchdog();
 			mdelay(1000);
@@ -105,6 +111,12 @@ NORET_TYPE void panic(const char * fmt, 
         disabled_wait(caller);
 #endif
 	local_irq_enable();
+#ifdef CONFIG_BOOTSPLASH
+	{
+		extern int splash_verbose(void);
+		(void)splash_verbose();
+	}
+#endif
 	for (;;)
 		;
 }
