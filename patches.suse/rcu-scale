From: SGI
Subject: slow down rcu processing on big machines
References: 181202
Patch-mainline: obsolete

Acked-by: mason@suse.com

diff -r 3c3bbe24d60c arch/ia64/sn/kernel/setup.c
--- a/arch/ia64/sn/kernel/setup.c	Sun Jun 04 16:14:27 2006 -0400
+++ b/arch/ia64/sn/kernel/setup.c	Sun Jun 04 16:15:29 2006 -0400
@@ -678,6 +678,18 @@ void __init sn_cpu_init(void)
 		    (volatile unsigned long *)GLOBAL_MMR_ADDR(nasid,
 							      SH1_PI_CAM_CONTROL);
 	}
+
+/*
+ * This is a hack to fix a RCU scaling problems on insanely large systems. This fix
+ * is specific to 2.6.16-based kernel.
+ */
+        {
+                extern int rcu_mask;
+                if (cpuid == 512)
+                        rcu_mask = 1;
+                else if (cpuid == 768)
+                        rcu_mask = 3;
+        }
 }
 
 /*
diff -r 3c3bbe24d60c include/linux/sysctl.h
--- a/include/linux/sysctl.h	Sun Jun 04 16:14:27 2006 -0400
+++ b/include/linux/sysctl.h	Sun Jun 04 16:15:29 2006 -0400
@@ -152,6 +152,7 @@ enum
 	KERN_KDB=74,		/* int: kdb on/off */
 	KERN_DUMP=75,		/* directory: dump parameters */
 	KERN_HZ=76,		/* unsigned long: internal kernel HZ */
+	KERN_RCU_MASK=77,       /* int: mask for slow rcu callback processing */
 };
 
 
diff -r 3c3bbe24d60c kernel/rcupdate.c
--- a/kernel/rcupdate.c	Sun Jun 04 16:14:27 2006 -0400
+++ b/kernel/rcupdate.c	Sun Jun 04 16:15:29 2006 -0400
@@ -47,6 +47,7 @@
 #include <linux/notifier.h>
 #include <linux/rcupdate.h>
 #include <linux/cpu.h>
+#include <linux/jiffies.h>
 
 /* Definition for rcupdate control block. */
 struct rcu_ctrlblk rcu_ctrlblk = {
@@ -64,6 +65,19 @@ struct rcu_ctrlblk rcu_bh_ctrlblk = {
 
 DEFINE_PER_CPU(struct rcu_data, rcu_data) = { 0L };
 DEFINE_PER_CPU(struct rcu_data, rcu_bh_data) = { 0L };
+
+/*
+ * Set the following to 1, 3, 7, 15, ... to slow down the rate at which RCU
+ * callbacks are processed. WARNING - make sure the value is 2**n-1
+ */
+int rcu_mask = 0;
+
+/* Is it time to process a batch on this cpu */
+static inline int rcu_time(int cpu)
+{
+	return (((jiffies - cpu) & rcu_mask) == 0);
+}
+
 
 /* Fake initialization required by compiler */
 static DEFINE_PER_CPU(struct tasklet_struct, rcu_tasklet) = {NULL};
@@ -812,6 +826,9 @@ int rcu_needs_cpu(int cpu)
 
 void rcu_check_callbacks(int cpu, int user)
 {
+	if (!rcu_time(cpu))
+		return;
+
 	if (user || 
 	    (idle_cpu(cpu) && !in_softirq() && 
 				hardirq_count() <= (1 << HARDIRQ_SHIFT))) {
diff -r 3c3bbe24d60c kernel/sysctl.c
--- a/kernel/sysctl.c	Sun Jun 04 16:14:27 2006 -0400
+++ b/kernel/sysctl.c	Sun Jun 04 16:15:29 2006 -0400
@@ -159,6 +159,8 @@ int sysctl_legacy_va_layout;
 int sysctl_legacy_va_layout;
 #endif
 
+extern int rcu_mask;
+
 /* /proc declarations: */
 
 #ifdef CONFIG_PROC_FS
@@ -709,6 +711,14 @@ static ctl_table kern_table[] = {
 		.data		= &__HZ,
 		.maxlen		= sizeof(int),
 		.mode		= 0444,
+		.proc_handler	= &proc_dointvec,
+	},
+	{
+		.ctl_name	= KERN_RCU_MASK,
+		.procname	= "rcu_mask",
+		.data		= &rcu_mask,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
 	{ .ctl_name = 0 }
