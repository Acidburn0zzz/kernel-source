From: SGI
Subject: slow down rcu processing on big machines
References: 181202
Patch-mainline: obsolete

Acked-by: mason@suse.com

---
 arch/ia64/sn/kernel/setup.c |   12 ++++++++++++
 include/linux/sysctl.h      |    1 +
 kernel/rcupdate.c           |   17 +++++++++++++++++
 kernel/sysctl.c             |   10 ++++++++++
 4 files changed, 40 insertions(+)

--- linux-2.6.17.orig/arch/ia64/sn/kernel/setup.c
+++ linux-2.6.17/arch/ia64/sn/kernel/setup.c
@@ -684,6 +684,18 @@ void __init sn_cpu_init(void)
 		    (volatile unsigned long *)GLOBAL_MMR_ADDR(nasid,
 							      SH1_PI_CAM_CONTROL);
 	}
+
+/*
+ * This is a hack to fix a RCU scaling problems on insanely large systems. This fix
+ * is specific to 2.6.16-based kernel.
+ */
+        {
+                extern int rcu_mask;
+                if (cpuid == 512)
+                        rcu_mask = 1;
+                else if (cpuid == 768)
+                        rcu_mask = 3;
+        }
 }
 
 /*
--- linux-2.6.17.orig/include/linux/sysctl.h
+++ linux-2.6.17/include/linux/sysctl.h
@@ -149,6 +149,7 @@ enum
 	KERN_MAX_LOCK_DEPTH=74,
 	KERN_UNSUPPORTED=75,	/* int: allow loading of unsupported modules */
 	KERN_KDB=76,		/* int: kdb on/off */
+	KERN_RCU_MASK=77,       /* int: mask for slow rcu callback processing */
 };
 
 
--- linux-2.6.17.orig/kernel/rcupdate.c
+++ linux-2.6.17/kernel/rcupdate.c
@@ -48,6 +48,7 @@
 #include <linux/rcupdate.h>
 #include <linux/cpu.h>
 #include <linux/mutex.h>
+#include <linux/jiffies.h>
 
 /* Definition for rcupdate control block. */
 static struct rcu_ctrlblk rcu_ctrlblk = {
@@ -66,6 +67,19 @@ static struct rcu_ctrlblk rcu_bh_ctrlblk
 DEFINE_PER_CPU(struct rcu_data, rcu_data) = { 0L };
 DEFINE_PER_CPU(struct rcu_data, rcu_bh_data) = { 0L };
 
+/*
+ * Set the following to 1, 3, 7, 15, ... to slow down the rate at which RCU
+ * callbacks are processed. WARNING - make sure the value is 2**n-1
+ */
+int rcu_mask = 0;
+
+/* Is it time to process a batch on this cpu */
+static inline int rcu_time(int cpu)
+{
+	return (((jiffies - cpu) & rcu_mask) == 0);
+}
+
+
 /* Fake initialization required by compiler */
 static DEFINE_PER_CPU(struct tasklet_struct, rcu_tasklet) = {NULL};
 /* Tasklet for processing rcu callbacks remotely */
@@ -821,6 +835,9 @@ int rcu_needs_cpu(int cpu)
 
 void rcu_check_callbacks(int cpu, int user)
 {
+	if (!rcu_time(cpu))
+		return;
+
 	if (user || 
 	    (idle_cpu(cpu) && !in_softirq() && 
 				hardirq_count() <= (1 << HARDIRQ_SHIFT))) {
--- linux-2.6.17.orig/kernel/sysctl.c
+++ linux-2.6.17/kernel/sysctl.c
@@ -163,6 +163,8 @@ extern ctl_table inotify_table[];
 int sysctl_legacy_va_layout;
 #endif
 
+extern int rcu_mask;
+
 /* /proc declarations: */
 
 #ifdef CONFIG_PROC_FS
@@ -307,6 +309,14 @@ static ctl_table kern_table[] = {
 		.mode		= 0444,
 		.proc_handler	= &proc_dointvec,
 	},
+	{
+		.ctl_name	= KERN_RCU_MASK,
+		.procname	= "rcu_mask",
+		.data		= &rcu_mask,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 #ifdef CONFIG_MODULES
 	{
 		.ctl_name	= KERN_UNSUPPORTED,
