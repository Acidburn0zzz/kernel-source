From: olh@suse.de
Subject: update to build with 2.6.13

 drivers/macintosh/mol/sheep.c |   18 +++++++++---------
 1 files changed, 9 insertions(+), 9 deletions(-)

Index: linux-2.6.12/drivers/macintosh/mol/sheep.c
===================================================================
--- linux-2.6.12.orig/drivers/macintosh/mol/sheep.c
+++ linux-2.6.12/drivers/macintosh/mol/sheep.c
@@ -72,7 +72,7 @@ struct SheepVars {
  */
 
 #ifdef LINUX_26
-#define compat_sk_alloc(a,b,c)	sk_alloc( (a), (b), (c), NULL )
+#define compat_sk_alloc(a,b,c)	sk_alloc( (a), (b), NULL, (c))
 #define skt_set_dead(skt)	do {} while(0)
 #define wmem_alloc		sk_wmem_alloc
 #else
@@ -151,7 +151,7 @@ demasquerade( struct sk_buff *skb, struc
 static int 
 sheep_net_receiver( struct sk_buff *skb, struct net_device *dev, struct packet_type *pt )
 {
-	int multicast = (skb->mac.ethernet->h_dest[0] & ETH_ADDR_MULTICAST);
+	int multicast = (eth_hdr(skb)->h_dest[0] & ETH_ADDR_MULTICAST);
 	const char *laddr = dev->dev_addr;
 	struct sk_buff *skb2;
 	struct SheepVars *v = (struct SheepVars*)pt;
@@ -165,7 +165,7 @@ sheep_net_receiver( struct sk_buff *skb,
 
 		if( !multicast ) {
 			// Drop, unless this is a localhost -> MOL transmission */
-			if( addrcmp((char*)&skb->mac.ethernet->h_dest, v->fake_addr) )
+			if( addrcmp((char*)&eth_hdr(skb)->h_dest, v->fake_addr) )
 				goto drop;
 
 			/* XXX: If it were possible, we would prevent the packet from beeing sent out
@@ -176,16 +176,16 @@ sheep_net_receiver( struct sk_buff *skb,
 			 * the controller. This way, the packet ought to be discarded by
 			 * switches.
 			 */
-			cpyaddr( &skb->mac.ethernet->h_dest[0], laddr );
+			cpyaddr( &eth_hdr(skb)->h_dest[0], laddr );
 		}
 	} else {
 		// is this a packet to the local host from MOL?
-		if( !addrcmp((char*)&skb->mac.ethernet->h_source, v->fake_addr) )
+		if( !addrcmp((char*)&eth_hdr(skb)->h_source, v->fake_addr) )
 			goto drop;
 		
 		if( !multicast ) {
 			// if the packet is not meant for this host, discard it
-			if( addrcmp((char*)&skb->mac.ethernet->h_dest, laddr) )
+			if( addrcmp((char*)&eth_hdr(skb)->h_dest, laddr) )
 				goto drop;
 
 			// filter IP-traffic
@@ -213,7 +213,7 @@ sheep_net_receiver( struct sk_buff *skb,
 	skb = skb2;
 
 	if( !multicast )
-		cpyaddr( &skb->mac.ethernet->h_dest[0], v->fake_addr );
+		cpyaddr( &eth_hdr(skb)->h_dest[0], v->fake_addr );
 
 	// We also want the Ethernet header
 	skb_push( skb, skb->data - skb->mac.raw );
@@ -247,7 +247,7 @@ sheep_net_open( struct inode *inode, str
 		return -EPERM;
 
 	// Allocate private variables
-	if( !(v=(struct SheepVars *)f->private_data=kmalloc(sizeof(*v), GFP_USER)) )
+	if( !(v=f->private_data=kmalloc(sizeof(*v), GFP_USER)) )
 		return -ENOMEM;
 	memset( v, 0, sizeof(*v) );
 	memcpy( v->fake_addr, fake_addr_, 6 );
@@ -394,7 +394,7 @@ sheep_net_writev( struct file *f, const 
 	skb->mac.raw = skb->data;
 
 	// Base the IP-filter on the IP address of outgoing ARPs
-	if( skb->mac.ethernet->h_proto == htons(ETH_P_ARP) ) {
+	if( eth_hdr(skb)->h_proto == htons(ETH_P_ARP) ) {
 		char *s = &skb->data[14+14];	/* source IP-address */
 		int n[4];
 		if( *(long*)s != v->ipfilter ) {
