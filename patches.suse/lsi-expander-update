diff --git a/drivers/message/fusion/Makefile b/drivers/message/fusion/Makefile
index 33ace37..51740b3 100644
--- a/drivers/message/fusion/Makefile
+++ b/drivers/message/fusion/Makefile
@@ -4,6 +4,7 @@
 #EXTRA_CFLAGS += -DMPT_DEBUG_MSG_FRAME
 #EXTRA_CFLAGS += -DMPT_DEBUG_SG
 #EXTRA_CFLAGS += -DMPT_DEBUG_EVENTS
+#EXTRA_CFLAGS += -DMPT_DEBUG_VERBOSE_EVENTS
 #EXTRA_CFLAGS += -DMPT_DEBUG_INIT
 #EXTRA_CFLAGS += -DMPT_DEBUG_EXIT
 #EXTRA_CFLAGS += -DMPT_DEBUG_FAIL
diff --git a/drivers/message/fusion/lsi/mpi_log_sas.h b/drivers/message/fusion/lsi/mpi_log_sas.h
index 9259d1a..a9c14ad 100644
--- a/drivers/message/fusion/lsi/mpi_log_sas.h
+++ b/drivers/message/fusion/lsi/mpi_log_sas.h
@@ -3,38 +3,11 @@
  *                                                                         *
  *  Copyright 2003 LSI Logic Corporation.  All rights reserved.            *
  *                                                                         *
- *  This file is confidential and a trade secret of LSI Logic.  The        *
- *  receipt of or possession of this file does not convey any rights to    *
- *  reproduce or disclose its contents or to manufacture, use, or sell     *
- *  anything it may describe, in whole, or in part, without the specific   *
- *  written consent of LSI Logic Corporation.                              *
+ * Description                                                             *
+ * ------------                                                            *
+ * This include file contains SAS firmware interface IOC Log Info codes    *
  *                                                                         *
- ***************************************************************************
- *
- *           Name:  iopiIocLogInfo.h
- *          Title:  SAS Firmware IOP Interface IOC Log Info Definitions
- *     Programmer:  Guy Kendall
- *  Creation Date:  September 24, 2003
- *
- *  Version History
- *  ---------------
- *
- *  Last Updated
- *  -------------
- *  Version         %version: 22 %
- *  Date Updated    %date_modified: %
- *  Programmer      %created_by: nperucca %
- *
- *  Date      Who   Description
- *  --------  ---   -------------------------------------------------------
- *  09/24/03  GWK   Initial version
- *
- *
- * Description
- * ------------
- * This include file contains SAS firmware interface IOC Log Info codes
- *
- *-------------------------------------------------------------------------
+ *-------------------------------------------------------------------------*
  */
 
 #ifndef IOPI_IOCLOGINFO_H_INCLUDED
@@ -57,6 +30,8 @@
 #define IOC_LOGINFO_ORIGINATOR_PL                       (0x01000000)
 #define IOC_LOGINFO_ORIGINATOR_IR                       (0x02000000)
 
+#define IOC_LOGINFO_ORIGINATOR_MASK                     (0x0F000000)
+
 /****************************************************************************/
 /* LOGINFO_CODE defines                                                     */
 /****************************************************************************/
@@ -78,11 +53,27 @@
 #define IOP_LOGINFO_CODE_CONFIG_INVALID_PAGE_DEFAULT    (0x00030700) /* Default Page not found */
 #define IOP_LOGINFO_CODE_TASK_TERMINATED                (0x00050000)
 
+#define IOP_LOGINFO_CODE_ENCL_MGMT_READ_ACTION_ERR0R    (0x00060001) /* Read Action not supported for SEP msg */
+#define IOP_LOGINFO_CODE_ENCL_MGMT_INVALID_BUS_ID_ERR0R (0x00060002) /* Invalid Bus/ID in SEP msg */
+
+#define IOP_LOGINFO_CODE_TARGET_ASSIST_TERMINATED       (0x00070001)
+#define IOP_LOGINFO_CODE_TARGET_STATUS_SEND_TERMINATED  (0x00070002)
+#define IOP_LOGINFO_CODE_TARGET_MODE_ABORT_ALL_IO       (0x00070003)
+#define IOP_LOGINFO_CODE_TARGET_MODE_ABORT_EXACT_IO     (0x00070004)
+#define IOP_LOGINFO_CODE_TARGET_MODE_ABORT_EXACT_IO_REQ (0x00070005)
 
 /****************************************************************************/
 /* PL LOGINFO_CODE defines, valid if IOC_LOGINFO_ORIGINATOR = PL            */
 /****************************************************************************/
 #define PL_LOGINFO_CODE_OPEN_FAILURE                        (0x00010000)
+#define PL_LOG_INFO_CODE_OPEN_FAILURE_NO_DEST_TIME_OUT      (0x00010001)
+#define PL_LOGINFO_CODE_OPEN_FAILURE_BAD_DESTINATION        (0x00010011)
+#define PL_LOGINFO_CODE_OPEN_FAILURE_PROTOCOL_NOT_SUPPORTED (0x00010013)
+#define PL_LOGINFO_CODE_OPEN_FAILURE_STP_RESOURCES_BSY      (0x00010018)
+#define PL_LOGINFO_CODE_OPEN_FAILURE_WRONG_DESTINATION      (0x00010019)
+#define PL_LOGINFO_CODE_OPEN_FAILURE_ORR_TIMEOUT            (0X0001001A)
+#define PL_LOGINFO_CODE_OPEN_FAILURE_PATHWAY_BLOCKED        (0x0001001B)
+#define PL_LOGINFO_CODE_OPEN_FAILURE_AWT_MAXED              (0x0001001C)
 #define PL_LOGINFO_CODE_INVALID_SGL                         (0x00020000)
 #define PL_LOGINFO_CODE_WRONG_REL_OFF_OR_FRAME_LENGTH       (0x00030000)
 #define PL_LOGINFO_CODE_FRAME_XFER_ERROR                    (0x00040000)
@@ -97,6 +88,7 @@
 #define PL_LOGINFO_CODE_SATA_LINK_DOWN                      (0x000D0000)
 #define PL_LOGINFO_CODE_DISCOVERY_SATA_INIT_W_IOS           (0x000E0000)
 #define PL_LOGINFO_CODE_CONFIG_INVALID_PAGE                 (0x000F0000)
+#define PL_LOGINFO_CODE_CONFIG_PL_NOT_INITIALIZED           (0x000F0001) /* PL not yet initialized, can't do config page req. */
 #define PL_LOGINFO_CODE_CONFIG_INVALID_PAGE_PT              (0x000F0100) /* Invalid Page Type */
 #define PL_LOGINFO_CODE_CONFIG_INVALID_PAGE_NUM_PHYS        (0x000F0200) /* Invalid Number of Phys */
 #define PL_LOGINFO_CODE_CONFIG_INVALID_PAGE_NOT_IMP         (0x000F0300) /* Case Not Handled */
@@ -105,11 +97,23 @@
 #define PL_LOGINFO_CODE_CONFIG_INVALID_PAGE_PHY             (0x000F0600) /* Invalid Phy */
 #define PL_LOGINFO_CODE_CONFIG_INVALID_PAGE_NO_OWNER        (0x000F0700) /* No Owner Found */
 #define PL_LOGINFO_CODE_DSCVRY_SATA_INIT_TIMEOUT            (0x00100000)
-#define PL_LOGINFO_CODE_RESET                               (0x00110000)
-#define PL_LOGINFO_CODE_ABORT                               (0x00120000)
+#define PL_LOGINFO_CODE_RESET                               (0x00110000) /* See Sub-Codes below */
+#define PL_LOGINFO_CODE_ABORT                               (0x00120000) /* See Sub-Codes below */
 #define PL_LOGINFO_CODE_IO_NOT_YET_EXECUTED                 (0x00130000)
 #define PL_LOGINFO_CODE_IO_EXECUTED                         (0x00140000)
+#define PL_LOGINFO_CODE_PERS_RESV_OUT_NOT_AFFIL_OWNER       (0x00150000)
+#define PL_LOGINFO_CODE_OPEN_TXDMA_ABORT                    (0x00160000)
 #define PL_LOGINFO_SUB_CODE_OPEN_FAILURE                    (0x00000100)
+#define PL_LOGINFO_SUB_CODE_OPEN_FAILURE_NO_DEST_TIMEOUT    (0x00000101)
+#define PL_LOGINFO_SUB_CODE_OPEN_FAILURE_ORR_TIMEOUT        (0x0000011A) /* Open Reject (Retry) Timeout */
+#define PL_LOGINFO_SUB_CODE_OPEN_FAILURE_PATHWAY_BLOCKED    (0x0000011B)
+#define PL_LOGINFO_SUB_CODE_OPEN_FAILURE_AWT_MAXED          (0x0000011C) /* Arbitration Wait Timer Maxed */
+
+#define PL_LOGINFO_SUB_CODE_TARGET_BUS_RESET                (0x00000120)
+#define PL_LOGINFO_SUB_CODE_TRANSPORT_LAYER                 (0x00000130)  /* Leave lower nibble (1-f) reserved. */
+#define PL_LOGINFO_SUB_CODE_PORT_LAYER                      (0x00000140)  /* Leave lower nibble (1-f) reserved. */
+
+
 #define PL_LOGINFO_SUB_CODE_INVALID_SGL                     (0x00000200)
 #define PL_LOGINFO_SUB_CODE_WRONG_REL_OFF_OR_FRAME_LENGTH   (0x00000300)
 #define PL_LOGINFO_SUB_CODE_FRAME_XFER_ERROR                (0x00000400)
@@ -123,26 +127,39 @@
 #define PL_LOGINFO_SUB_CODE_RX_FM_CURRENT_FRAME_ERROR       (0x00000C00)
 #define PL_LOGINFO_SUB_CODE_SATA_LINK_DOWN                  (0x00000D00)
 #define PL_LOGINFO_SUB_CODE_DISCOVERY_SATA_INIT_W_IOS       (0x00000E00)
+#define PL_LOGINFO_SUB_CODE_DISCOVERY_REMOTE_SEP_RESET      (0x00000E01)
+#define PL_LOGINFO_SUB_CODE_SECOND_OPEN                     (0x00000F00)
 #define PL_LOGINFO_SUB_CODE_DSCVRY_SATA_INIT_TIMEOUT        (0x00001000)
 
 
 #define PL_LOGINFO_CODE_ENCL_MGMT_SMP_FRAME_FAILURE         (0x00200000) /* Can't get SMP Frame */
-#define PL_LOGINFO_CODE_ENCL_MGMT_SMP_READ_ERROR            (0x00200001) /* Error occured on SMP Read */
-#define PL_LOGINFO_CODE_ENCL_MGMT_SMP_WRITE_ERROR           (0x00200002) /* Error occured on SMP Write */
-#define PL_LOGINFO_CODE_ENCL_MGMT_NOT_SUPPORTED_ON_ENCL     (0x00200004) /* Encl Mgmt services not available for this WWID */
-#define PL_LOGINFO_CODE_ENCL_MGMT_ADDR_MODE_NOT_SUPPORTED   (0x00200005) /* Address Mode not suppored */
-#define PL_LOGINFO_CODE_ENCL_MGMT_BAD_SLOT_NUM              (0x00200006) /* Invalid Slot Number in SEP Msg */
-#define PL_LOGINFO_CODE_ENCL_MGMT_SGPIO_NOT_PRESENT         (0x00200007) /* SGPIO not present/enabled */
+#define PL_LOGINFO_CODE_ENCL_MGMT_SMP_READ_ERROR            (0x00200010) /* Error occured on SMP Read */
+#define PL_LOGINFO_CODE_ENCL_MGMT_SMP_WRITE_ERROR           (0x00200020) /* Error occured on SMP Write */
+#define PL_LOGINFO_CODE_ENCL_MGMT_NOT_SUPPORTED_ON_ENCL     (0x00200040) /* Encl Mgmt services not available for this WWID */
+#define PL_LOGINFO_CODE_ENCL_MGMT_ADDR_MODE_NOT_SUPPORTED   (0x00200050) /* Address Mode not suppored */
+#define PL_LOGINFO_CODE_ENCL_MGMT_BAD_SLOT_NUM              (0x00200060) /* Invalid Slot Number in SEP Msg */
+#define PL_LOGINFO_CODE_ENCL_MGMT_SGPIO_NOT_PRESENT         (0x00200070) /* SGPIO not present/enabled */
+#define PL_LOGINFO_CODE_ENCL_MGMT_GPIO_NOT_CONFIGURED       (0x00200080) /* GPIO not configured */
+#define PL_LOGINFO_CODE_ENCL_MGMT_GPIO_FRAME_ERROR          (0x00200090) /* GPIO can't allocate a frame */
+#define PL_LOGINFO_CODE_ENCL_MGMT_GPIO_CONFIG_PAGE_ERROR    (0x002000A0) /* GPIO failed config page request */
+#define PL_LOGINFO_CODE_ENCL_MGMT_SES_FRAME_ALLOC_ERROR     (0x002000B0) /* Can't get frame for SES command */
+#define PL_LOGINFO_CODE_ENCL_MGMT_SES_IO_ERROR              (0x002000C0) /* I/O execution error */
+#define PL_LOGINFO_CODE_ENCL_MGMT_SES_RETRIES_EXHAUSTED     (0x002000D0) /* SEP I/O retries exhausted */
+#define PL_LOGINFO_CODE_ENCL_MGMT_SMP_FRAME_ALLOC_ERROR     (0x002000E0) /* Can't get frame for SMP command */
 
 #define PL_LOGINFO_DA_SEP_NOT_PRESENT                       (0x00200100) /* SEP not present when msg received */
 #define PL_LOGINFO_DA_SEP_SINGLE_THREAD_ERROR               (0x00200101) /* Can only accept 1 msg at a time */
 #define PL_LOGINFO_DA_SEP_ISTWI_INTR_IN_IDLE_STATE          (0x00200102) /* ISTWI interrupt recvd. while IDLE */
 #define PL_LOGINFO_DA_SEP_RECEIVED_NACK_FROM_SLAVE          (0x00200103) /* SEP NACK'd, it is busy */
-#define PL_LOGINFO_DA_SEP_BAD_STATUS_HDR_CHKSUM             (0x00200104) /* SEP stopped or sent bad chksum in Hdr */
-#define PL_LOGINFO_DA_SEP_UNSUPPORTED_SCSI_STATUS_1         (0x00200105) /* SEP returned unknown scsi status */
-#define PL_LOGINFO_DA_SEP_UNSUPPORTED_SCSI_STATUS_2         (0x00200106) /* SEP returned unknown scsi status */
-#define PL_LOGINFO_DA_SEP_CHKSUM_ERROR_AFTER_STOP           (0x00200107) /* SEP returned bad chksum after STOP */
-#define PL_LOGINFO_DA_SEP_CHKSUM_ERROR_AFTER_STOP_GETDATA   (0x00200108) /* SEP returned bad chksum after STOP while gettin data*/
+#define PL_LOGINFO_DA_SEP_DID_NOT_RECEIVE_ACK               (0x00200104) /* SEP didn't rcv. ACK (Last Rcvd Bit = 1) */
+#define PL_LOGINFO_DA_SEP_BAD_STATUS_HDR_CHKSUM             (0x00200105) /* SEP stopped or sent bad chksum in Hdr */
+#define PL_LOGINFO_DA_SEP_STOP_ON_DATA                      (0x00200106) /* SEP stopped while transfering data */
+#define PL_LOGINFO_DA_SEP_STOP_ON_SENSE_DATA                (0x00200107) /* SEP stopped while transfering sense data */
+#define PL_LOGINFO_DA_SEP_UNSUPPORTED_SCSI_STATUS_1         (0x00200108) /* SEP returned unknown scsi status */
+#define PL_LOGINFO_DA_SEP_UNSUPPORTED_SCSI_STATUS_2         (0x00200109) /* SEP returned unknown scsi status */
+#define PL_LOGINFO_DA_SEP_CHKSUM_ERROR_AFTER_STOP           (0x0020010A) /* SEP returned bad chksum after STOP */
+#define PL_LOGINFO_DA_SEP_CHKSUM_ERROR_AFTER_STOP_GETDATA   (0x0020010B) /* SEP returned bad chksum after STOP while gettin data*/
+#define PL_LOGINFO_DA_SEP_UNSUPPORTED_COMMAND               (0x0020010C) /* SEP doesn't support CDB opcode */
 
 
 /****************************************************************************/
diff --git a/drivers/message/fusion/mptbase.c b/drivers/message/fusion/mptbase.c
index f2721ea..266414c 100644
--- a/drivers/message/fusion/mptbase.c
+++ b/drivers/message/fusion/mptbase.c
@@ -180,6 +180,7 @@ static void	mpt_sp_ioc_info(MPT_ADAPTER 
 static void	mpt_fc_log_info(MPT_ADAPTER *ioc, u32 log_info);
 static void	mpt_spi_log_info(MPT_ADAPTER *ioc, u32 log_info);
 static void	mpt_sas_log_info(MPT_ADAPTER *ioc, u32 log_info);
+static int	mpt_read_ioc_pg_3(MPT_ADAPTER *ioc);
 
 /* module entry point */
 static int  __init    fusion_init  (void);
@@ -428,7 +429,7 @@ mpt_base_reply(MPT_ADAPTER *ioc, MPT_FRA
 		results = ProcessEventNotification(ioc, pEvReply, &evHandlers);
 		if (results != evHandlers) {
 			/* CHECKME! Any special handling needed here? */
-			devtprintk((MYIOC_s_WARN_FMT "Called %d event handlers, sum results = %d\n",
+			devtverboseprintk((MYIOC_s_WARN_FMT "Called %d event handlers, sum results = %d\n",
 					ioc->name, evHandlers, results));
 		}
 
@@ -438,10 +439,10 @@ mpt_base_reply(MPT_ADAPTER *ioc, MPT_FRA
 		 */
 		if (pEvReply->MsgFlags & MPI_MSGFLAGS_CONTINUATION_REPLY) {
 			freereq = 0;
-			devtprintk((MYIOC_s_WARN_FMT "EVENT_NOTIFICATION reply %p does not return Request frame\n",
+			devtverboseprintk((MYIOC_s_WARN_FMT "EVENT_NOTIFICATION reply %p does not return Request frame\n",
 				ioc->name, pEvReply));
 		} else {
-			devtprintk((MYIOC_s_WARN_FMT "EVENT_NOTIFICATION reply %p returns Request frame\n",
+			devtverboseprintk((MYIOC_s_WARN_FMT "EVENT_NOTIFICATION reply %p returns Request frame\n",
 				ioc->name, pEvReply));
 		}
 
@@ -4871,7 +4872,7 @@ done_and_free:
 	return rc;
 }
 
-int
+static int
 mpt_read_ioc_pg_3(MPT_ADAPTER *ioc)
 {
 	IOCPage3_t		*pIoc3;
@@ -5079,13 +5080,13 @@ SendEventNotification(MPT_ADAPTER *ioc, 
 
 	evnp = (EventNotification_t *) mpt_get_msg_frame(mpt_base_index, ioc);
 	if (evnp == NULL) {
-		devtprintk((MYIOC_s_WARN_FMT "Unable to allocate event request frame!\n",
+		devtverboseprintk((MYIOC_s_WARN_FMT "Unable to allocate event request frame!\n",
 				ioc->name));
 		return 0;
 	}
 	memset(evnp, 0, sizeof(*evnp));
 
-	devtprintk((MYIOC_s_INFO_FMT "Sending EventNotification (%d) request %p\n", ioc->name, EvSwitch, evnp));
+	devtverboseprintk((MYIOC_s_INFO_FMT "Sending EventNotification (%d) request %p\n", ioc->name, EvSwitch, evnp));
 
 	evnp->Function = MPI_FUNCTION_EVENT_NOTIFICATION;
 	evnp->ChainOffset = 0;
@@ -5840,24 +5841,27 @@ EventDescriptionStr(u8 event, u32 evData
 		break;
 	case MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:
 	{
+		char buf[50];
+		u8 id = (u8)(evData0);
 		u8 ReasonCode = (u8)(evData0 >> 16);
 		switch (ReasonCode) {
 		case MPI_EVENT_SAS_DEV_STAT_RC_ADDED:
-			ds = "SAS Device Status Change: Added";
+			sprintf(buf,"SAS Device Status Change: Added: id=%d", id);
 			break;
 		case MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING:
-			ds = "SAS Device Status Change: Deleted";
+			sprintf(buf,"SAS Device Status Change: Deleted: id=%d", id);
 			break;
 		case MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA:
-			ds = "SAS Device Status Change: SMART Data";
+			sprintf(buf,"SAS Device Status Change: SMART Data: id=%d", id);
 			break;
 		case MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED:
-			ds = "SAS Device Status Change: No Persistancy Added";
+			sprintf(buf,"SAS Device Status Change: No Persistancy Added: id=%d", id);
 			break;
 		default:
-			ds = "SAS Device Status Change: Unknown";
+			sprintf(buf,"SAS Device Status Change: Unknown: id=%d", id);
 		break;
 		}
+		ds = buf;
 		break;
 	}
 	case MPI_EVENT_ON_BUS_TIMER_EXPIRED:
@@ -5873,11 +5877,97 @@ EventDescriptionStr(u8 event, u32 evData
 		ds = "Persistent Table Full";
 		break;
 	case MPI_EVENT_SAS_PHY_LINK_STATUS:
-		ds = "SAS PHY Link Status";
+	{
+		char buf[50];
+		u8 LinkRates = (u8)(evData0 >> 8);
+		u8 PhyNumber = (u8)(evData0);
+		LinkRates = (LinkRates & MPI_EVENT_SAS_PLS_LR_CURRENT_MASK) >>
+			MPI_EVENT_SAS_PLS_LR_CURRENT_SHIFT;
+		switch (LinkRates) {
+		case MPI_EVENT_SAS_PLS_LR_RATE_UNKNOWN:
+			sprintf(buf,"SAS PHY Link Status: Phy=%d:"
+			   " Rate Unknown",PhyNumber);
+			break;
+		case MPI_EVENT_SAS_PLS_LR_RATE_PHY_DISABLED:
+			sprintf(buf,"SAS PHY Link Status: Phy=%d:"
+			   " Phy Disabled",PhyNumber);
+			break;
+		case MPI_EVENT_SAS_PLS_LR_RATE_FAILED_SPEED_NEGOTIATION:
+			sprintf(buf,"SAS PHY Link Status: Phy=%d:"
+			   " Failed Speed Nego",PhyNumber);
+			break;
+		case MPI_EVENT_SAS_PLS_LR_RATE_SATA_OOB_COMPLETE:
+			sprintf(buf,"SAS PHY Link Status: Phy=%d:"
+			   " Sata OOB Completed",PhyNumber);
+			break;
+		case MPI_EVENT_SAS_PLS_LR_RATE_1_5:
+			sprintf(buf,"SAS PHY Link Status: Phy=%d:"
+			   " Rate 1.5 Gbps",PhyNumber);
+			break;
+		case MPI_EVENT_SAS_PLS_LR_RATE_3_0:
+			sprintf(buf,"SAS PHY Link Status: Phy=%d:"
+			   " Rate 3.0 Gpbs",PhyNumber);
+			break;
+		default:
+			sprintf(buf,"SAS PHY Link Status: Phy=%d", PhyNumber);
+			break;
+		}
+		ds = buf;
 		break;
+	}
 	case MPI_EVENT_SAS_DISCOVERY_ERROR:
 		ds = "SAS Discovery Error";
 		break;
+	case MPI_EVENT_IR_RESYNC_UPDATE:
+	{
+		u8 resync_complete = (u8)(evData0 >> 16);
+		char buf[40];
+		sprintf(buf,"IR Resync Update: Complete = %d:",resync_complete);
+		ds = buf;
+		break;
+	}
+	case MPI_EVENT_IR2:
+	{
+		u8 ReasonCode = (u8)(evData0 >> 16);
+		switch (ReasonCode) {
+		case MPI_EVENT_IR2_RC_LD_STATE_CHANGED:
+			ds = "IR2: LD State Changed";
+			break;
+		case MPI_EVENT_IR2_RC_PD_STATE_CHANGED:
+			ds = "IR2: PD State Changed";
+			break;
+		case MPI_EVENT_IR2_RC_BAD_BLOCK_TABLE_FULL:
+			ds = "IR2: Bad Block Table Full";
+			break;
+		case MPI_EVENT_IR2_RC_PD_INSERTED:
+			ds = "IR2: PD Inserted";
+			break;
+		case MPI_EVENT_IR2_RC_PD_REMOVED:
+			ds = "IR2: PD Removed";
+			break;
+		case MPI_EVENT_IR2_RC_FOREIGN_CFG_DETECTED:
+			ds = "IR2: Foreign CFG Detected";
+			break;
+		case MPI_EVENT_IR2_RC_REBUILD_MEDIUM_ERROR:
+			ds = "IR2: Rebuild Medium Error";
+			break;
+		default:
+			ds = "IR2";
+		break;
+		}
+		break;
+	}
+	case MPI_EVENT_SAS_DISCOVERY:
+	{
+		if (evData0)
+			ds = "SAS Discovery: Start";
+		else
+			ds = "SAS Discovery: Stop";
+		break;
+	}
+	case MPI_EVENT_LOG_ENTRY_ADDED:
+		ds = "SAS Log Entry Added";
+		break;
 
 	/*
 	 *  MPT base "custom" events may be added here...
@@ -5922,12 +6012,12 @@ ProcessEventNotification(MPT_ADAPTER *io
 	}
 
 	EventDescriptionStr(event, evData0, evStr);
-	devtprintk((MYIOC_s_INFO_FMT "MPT event (%s=%02Xh) detected!\n",
+	devtprintk((MYIOC_s_INFO_FMT "MPT event:(%02Xh) : %s\n",
 			ioc->name,
-			evStr,
-			event));
+			event,
+			evStr));
 
-#if defined(MPT_DEBUG) || defined(MPT_DEBUG_EVENTS)
+#if defined(MPT_DEBUG) || defined(MPT_DEBUG_VERBOSE_EVENTS)
 	printk(KERN_INFO MYNAM ": Event data:\n" KERN_INFO);
 	for (ii = 0; ii < evDataLen; ii++)
 		printk(" %08x", le32_to_cpu(pEventReply->Data[ii]));
@@ -5986,7 +6076,7 @@ ProcessEventNotification(MPT_ADAPTER *io
 	 */
 	for (ii=MPT_MAX_PROTOCOL_DRIVERS-1; ii; ii--) {
 		if (MptEvHandlers[ii]) {
-			devtprintk((MYIOC_s_INFO_FMT "Routing Event to event handler #%d\n",
+			devtverboseprintk((MYIOC_s_INFO_FMT "Routing Event to event handler #%d\n",
 					ioc->name, ii));
 			r += (*(MptEvHandlers[ii]))(ioc, pEventReply);
 			handlers++;
@@ -5998,10 +6088,10 @@ ProcessEventNotification(MPT_ADAPTER *io
 	 *  If needed, send (a single) EventAck.
 	 */
 	if (pEventReply->AckRequired == MPI_EVENT_NOTIFICATION_ACK_REQUIRED) {
-		devtprintk((MYIOC_s_WARN_FMT
+		devtverboseprintk((MYIOC_s_WARN_FMT
 			"EventAck required\n",ioc->name));
 		if ((ii = SendEventAck(ioc, pEventReply)) != 0) {
-			devtprintk((MYIOC_s_WARN_FMT "SendEventAck returned %d\n",
+			devtverboseprintk((MYIOC_s_WARN_FMT "SendEventAck returned %d\n",
 					ioc->name, ii));
 		}
 	}
@@ -6138,8 +6228,8 @@ mpt_spi_log_info(MPT_ADAPTER *ioc, u32 l
 		"Abort",					/* 12h */
 		"IO Not Yet Executed",				/* 13h */
 		"IO Executed",					/* 14h */
-		NULL,						/* 15h */
-		NULL,						/* 16h */
+		"Persistant Reservation Out Not Affiliation Owner", /* 15h */
+		"Open Transmit DMA Abort",			/* 16h */
 		NULL,						/* 17h */
 		NULL,						/* 18h */
 		NULL,						/* 19h */
@@ -6364,7 +6454,6 @@ EXPORT_SYMBOL(mpt_stm_index);
 EXPORT_SYMBOL(mpt_HardResetHandler);
 EXPORT_SYMBOL(mpt_config);
 EXPORT_SYMBOL(mpt_findImVolumes);
-EXPORT_SYMBOL(mpt_read_ioc_pg_3);
 EXPORT_SYMBOL(mpt_alloc_fw_memory);
 EXPORT_SYMBOL(mpt_free_fw_memory);
 EXPORT_SYMBOL(mptbase_sas_persist_operation);
diff --git a/drivers/message/fusion/mptbase.h b/drivers/message/fusion/mptbase.h
index f4197a9..be7e850 100644
--- a/drivers/message/fusion/mptbase.h
+++ b/drivers/message/fusion/mptbase.h
@@ -76,8 +76,8 @@
 #define COPYRIGHT	"Copyright (c) 1999-2005 " MODULEAUTHOR
 #endif
 
-#define MPT_LINUX_VERSION_COMMON	"3.03.07"
-#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-3.03.07"
+#define MPT_LINUX_VERSION_COMMON	"3.03.08"
+#define MPT_LINUX_PACKAGE_NAME		"@(#)mptlinux-3.03.08"
 #define WHAT_MAGIC_STRING		"@" "(" "#" ")"
 
 #define show_mptmod_ver(s,ver)  \
@@ -347,10 +347,7 @@ typedef struct _VirtTarget {
 } VirtTarget;
 
 typedef struct _VirtDevice {
-	VirtTarget	 	*vtarget;
-	u8			 ioc_id;
-	u8			 bus_id;
-	u8			 target_id;
+	VirtTarget		*vtarget;
 	u8			 configured_lun;
 	u32			 lun;
 } VirtDevice;
@@ -622,6 +619,10 @@ typedef struct _MPT_ADAPTER
 	struct net_device	*netdev;
 	struct list_head	 sas_topology;
 	struct mutex		 sas_topology_mutex;
+	struct mutex		 sas_discovery_mutex;
+	u8			 sas_discovery_runtime;
+	u8			 sas_discovery_ignore_events;
+	int			 sas_index; /* index refrencing */
 	MPT_SAS_MGMT		 sas_mgmt;
 	int			 num_ports;
 	struct work_struct	 mptscsih_persistTask;
@@ -719,12 +720,18 @@ typedef struct _mpt_sge {
 #define dhsprintk(x)
 #endif
 
-#ifdef MPT_DEBUG_EVENTS
+#if defined(MPT_DEBUG_EVENTS) || defined(MPT_DEBUG_VERBOSE_EVENTS)
 #define devtprintk(x)  printk x
 #else
 #define devtprintk(x)
 #endif
 
+#ifdef MPT_DEBUG_VERBOSE_EVENTS
+#define devtverboseprintk(x)  printk x
+#else
+#define devtverboseprintk(x)
+#endif
+
 #ifdef MPT_DEBUG_RESET
 #define drsprintk(x)  printk x
 #else
@@ -1021,7 +1028,6 @@ extern int	 mpt_config(MPT_ADAPTER *ioc,
 extern void	 mpt_alloc_fw_memory(MPT_ADAPTER *ioc, int size);
 extern void	 mpt_free_fw_memory(MPT_ADAPTER *ioc);
 extern int	 mpt_findImVolumes(MPT_ADAPTER *ioc);
-extern int	 mpt_read_ioc_pg_3(MPT_ADAPTER *ioc);
 extern int	 mptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode);
 extern int	 mptbase_GetFcPortPage0(MPT_ADAPTER *ioc, int portnum);
 
diff --git a/drivers/message/fusion/mptctl.c b/drivers/message/fusion/mptctl.c
index 9b64e07..b4967bb 100644
--- a/drivers/message/fusion/mptctl.c
+++ b/drivers/message/fusion/mptctl.c
@@ -140,7 +140,7 @@ static int  mptctl_ioc_reset(MPT_ADAPTER
  * Event Handler function
  */
 static int mptctl_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply);
-struct fasync_struct *async_queue=NULL;
+static struct fasync_struct *async_queue=NULL;
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
@@ -497,7 +497,7 @@ mptctl_event_process(MPT_ADAPTER *ioc, E
 	 if (event == 0x21 ) {
 		ioc->aen_event_read_flag=1;
 		dctlprintk(("Raised SIGIO to application\n"));
-		devtprintk(("Raised SIGIO to application\n"));
+		devtverboseprintk(("Raised SIGIO to application\n"));
 		kill_fasync(&async_queue, SIGIO, POLL_IN);
 		return 1;
 	 }
@@ -515,7 +515,7 @@ mptctl_event_process(MPT_ADAPTER *ioc, E
 	if (ioc->events && (ioc->eventTypes & ( 1 << event))) {
 		ioc->aen_event_read_flag=1;
 		dctlprintk(("Raised SIGIO to application\n"));
-		devtprintk(("Raised SIGIO to application\n"));
+		devtverboseprintk(("Raised SIGIO to application\n"));
 		kill_fasync(&async_queue, SIGIO, POLL_IN);
 	}
 	return 1;
@@ -2968,7 +2968,7 @@ static int __init mptctl_init(void)
 	}
 
 	if (mpt_event_register(mptctl_id, mptctl_event_process) == 0) {
-		devtprintk((KERN_INFO MYNAM
+		devtverboseprintk((KERN_INFO MYNAM
 		  ": Registered for IOC event notifications\n"));
 	}
 
diff --git a/drivers/message/fusion/mptfc.c b/drivers/message/fusion/mptfc.c
index 8ea12ea..b343f2a 100644
--- a/drivers/message/fusion/mptfc.c
+++ b/drivers/message/fusion/mptfc.c
@@ -349,24 +349,6 @@ mptfc_generate_rport_ids(FCDevicePage0_t
 }
 
 static void
-mptfc_remap_sdev(struct scsi_device *sdev, void *arg)
-{
-	VirtDevice		*vdev;
-	VirtTarget		*vtarget;
-	struct scsi_target	*starget;
-
-	starget = scsi_target(sdev);
-	if (starget->hostdata == arg) {
-		vtarget = arg;
-		vdev = sdev->hostdata;
-		if (vdev) {
-			vdev->bus_id = vtarget->bus_id;
-			vdev->target_id = vtarget->target_id;
-		}
-	}
-}
-
-static void
 mptfc_register_dev(MPT_ADAPTER *ioc, int channel, FCDevicePage0_t *pg0)
 {
 	struct fc_rport_identifiers rport_ids;
@@ -423,8 +405,6 @@ mptfc_register_dev(MPT_ADAPTER *ioc, int
 				if (vtarget) {
 					vtarget->target_id = pg0->CurrentTargetID;
 					vtarget->bus_id = pg0->CurrentBus;
-					starget_for_each_device(ri->starget,
-						vtarget,mptfc_remap_sdev);
 				}
 				ri->remap_needed = 0;
 			}
@@ -432,7 +412,7 @@ mptfc_register_dev(MPT_ADAPTER *ioc, int
 				"mptfc_reg_dev.%d: %x, %llx / %llx, tid %d, "
 				"rport tid %d, tmo %d\n",
 					ioc->name,
-					oc->sh->host_no,
+					ioc->sh->host_no,
 					pg0->PortIdentifier,
 					pg0->WWNN,
 					pg0->WWPN,
@@ -553,23 +533,26 @@ mptfc_slave_alloc(struct scsi_device *sd
 	}
 
 	vdev->vtarget = vtarget;
-	vdev->ioc_id = hd->ioc->id;
 	vdev->lun = sdev->lun;
-	vdev->target_id = vtarget->target_id;
-	vdev->bus_id = vtarget->bus_id;
 
 	spin_unlock_irqrestore(&hd->ioc->fc_rport_lock,flags);
 
 	vtarget->num_luns++;
 
+#ifdef DMPT_DEBUG_FC
+	 {
+	struct mptfc_rport_info *ri;
+	ri = *((struct mptfc_rport_info **)rport->dd_data);
 	dfcprintk ((MYIOC_s_INFO_FMT
 		"mptfc_slv_alloc.%d: num_luns %d, sdev.id %d, "
 	        "CurrentTargetID %d, %x %llx %llx\n",
-		ioc->name,
+		hd->ioc->name,
 		sdev->host->host_no,
 		vtarget->num_luns,
 		sdev->id, ri->pg0.CurrentTargetID,
 		ri->pg0.PortIdentifier, ri->pg0.WWPN, ri->pg0.WWNN));
+	}
+#endif
 
 	return 0;
 }
@@ -941,7 +924,7 @@ mptfc_init(void)
 	mptfcInternalCtx = mpt_register(mptscsih_scandv_complete, MPTFC_DRIVER);
 
 	if (mpt_event_register(mptfcDoneCtx, mptscsih_event_process) == 0) {
-		devtprintk((KERN_INFO MYNAM
+		devtverboseprintk((KERN_INFO MYNAM
 		  ": Registered for IOC event notifications\n"));
 	}
 
diff --git a/drivers/message/fusion/mptsas.c b/drivers/message/fusion/mptsas.c
index 74f4368..be4eb8a 100644
--- a/drivers/message/fusion/mptsas.c
+++ b/drivers/message/fusion/mptsas.c
@@ -104,6 +104,13 @@ struct mptsas_hotplug_event {
 	u16			handle;
 	u16			parent_handle;
 	u8			phy_id;
+	u8			phys_disk_num;
+	u8			phys_disk_num_valid;
+};
+
+struct mptsas_discovery_event {
+	struct work_struct	work;
+	MPT_ADAPTER		*ioc;
 };
 
 /*
@@ -139,6 +146,7 @@ struct mptsas_phyinfo {
 	struct mptsas_devinfo attached;	/* point to attached device info */
 	struct sas_phy *phy;
 	struct sas_rphy *rphy;
+	struct scsi_target *starget;
 };
 
 struct mptsas_portinfo {
@@ -269,6 +277,27 @@ static inline MPT_ADAPTER *rphy_to_ioc(s
 	return ((MPT_SCSI_HOST *)shost->hostdata)->ioc;
 }
 
+/*
+ * mptsas_find_portinfo_by_handle
+ *
+ * This function should be called with the sas_topology_mutex already held
+ */
+static struct mptsas_portinfo *
+mptsas_find_portinfo_by_handle(MPT_ADAPTER *ioc, u16 handle)
+{
+	struct mptsas_portinfo *port_info, *rc=NULL;
+	int i;
+
+	list_for_each_entry(port_info, &ioc->sas_topology, list)
+		for (i = 0; i < port_info->num_phys; i++)
+			if (port_info->phy_info[i].identify.handle == handle) {
+				rc = port_info;
+				goto out;
+			}
+ out:
+	return rc;
+}
+
 static int
 mptsas_sas_enclosure_pg0(MPT_ADAPTER *ioc, struct mptsas_enclosure *enclosure,
 		u32 form, u32 form_specific)
@@ -334,6 +363,14 @@ mptsas_sas_enclosure_pg0(MPT_ADAPTER *io
 	return error;
 }
 
+static int
+mptsas_slave_configure(struct scsi_device *sdev)
+{
+	sas_read_port_mode_page(sdev);
+
+	return mptscsih_slave_configure(sdev);
+}
+
 /*
  * This is pretty ugly.  We will be able to seriously clean it up
  * once the DV code in mptscsih goes away and we can properly
@@ -349,6 +386,7 @@ mptsas_slave_alloc(struct scsi_device *s
 	VirtTarget		*vtarget;
 	VirtDevice		*vdev;
 	struct scsi_target 	*starget;
+	u32			target_id;
 	int i;
 
 	vdev = kzalloc(sizeof(VirtDevice), GFP_KERNEL);
@@ -357,10 +395,10 @@ mptsas_slave_alloc(struct scsi_device *s
 				hd->ioc->name, sizeof(VirtDevice));
 		return -ENOMEM;
 	}
-	vdev->ioc_id = hd->ioc->id;
 	sdev->hostdata = vdev;
 	starget = scsi_target(sdev);
 	vtarget = starget->hostdata;
+	vtarget->ioc_id = hd->ioc->id;
 	vdev->vtarget = vtarget;
 	if (vtarget->num_luns == 0) {
 		vtarget->tflags = MPT_TARGET_FLAGS_Q_YES|MPT_TARGET_FLAGS_VALID_INQUIRY;
@@ -371,8 +409,8 @@ mptsas_slave_alloc(struct scsi_device *s
 	  RAID volumes placed beyond the last expected port.
 	*/
 	if (sdev->channel == hd->ioc->num_ports) {
-		vdev->target_id = sdev->id;
-		vdev->bus_id = 0;
+		target_id = sdev->id;
+		vtarget->bus_id = 0;
 		vdev->lun = 0;
 		goto out;
 	}
@@ -383,11 +421,21 @@ mptsas_slave_alloc(struct scsi_device *s
 		for (i = 0; i < p->num_phys; i++) {
 			if (p->phy_info[i].attached.sas_address ==
 					rphy->identify.sas_address) {
-				vdev->target_id =
-					p->phy_info[i].attached.id;
-				vdev->bus_id = p->phy_info[i].attached.channel;
+				target_id = p->phy_info[i].attached.id;
+				vtarget->bus_id = p->phy_info[i].attached.channel;
 				vdev->lun = sdev->lun;
- 	mutex_unlock(&hd->ioc->sas_topology_mutex);
+				p->phy_info[i].starget = sdev->sdev_target;
+				/*
+				 * Exposing hidden disk (RAID)
+				 */
+				if (mptscsih_is_phys_disk(hd->ioc, target_id)) {
+					target_id = mptscsih_raid_id_to_num(hd,
+							target_id);
+					vdev->vtarget->tflags |=
+					    MPT_TARGET_FLAGS_RAID_COMPONENT;
+					sdev->no_uld_attach = 1;
+				}
+				mutex_unlock(&hd->ioc->sas_topology_mutex);
 				goto out;
 			}
 		}
@@ -398,9 +446,7 @@ mptsas_slave_alloc(struct scsi_device *s
 	return -ENXIO;
 
  out:
-	vtarget->ioc_id = vdev->ioc_id;
-	vtarget->target_id = vdev->target_id;
-	vtarget->bus_id = vdev->bus_id;
+	vtarget->target_id = target_id;
 	vtarget->num_luns++;
 	return 0;
 }
@@ -410,41 +456,17 @@ mptsas_slave_destroy(struct scsi_device 
 {
 	struct Scsi_Host *host = sdev->host;
 	MPT_SCSI_HOST *hd = (MPT_SCSI_HOST *)host->hostdata;
-	struct sas_rphy *rphy;
-	struct mptsas_portinfo *p;
-	int i;
 	VirtDevice *vdev;
 
 	/*
-	 * Handle hotplug removal case.
-	 * We need to clear out attached data structure.
-	 */
-	rphy = dev_to_rphy(sdev->sdev_target->dev.parent);
-
-	mutex_lock(&hd->ioc->sas_topology_mutex);
-	list_for_each_entry(p, &hd->ioc->sas_topology, list) {
-		for (i = 0; i < p->num_phys; i++) {
-			if (p->phy_info[i].attached.sas_address ==
-					rphy->identify.sas_address) {
-				memset(&p->phy_info[i].attached, 0,
-				    sizeof(struct mptsas_devinfo));
-				p->phy_info[i].rphy = NULL;
-				goto out;
-			}
-		}
-	}
-
- out:
-	mutex_unlock(&hd->ioc->sas_topology_mutex);
-	/*
 	 * Issue target reset to flush firmware outstanding commands.
 	 */
 	vdev = sdev->hostdata;
 	if (vdev->configured_lun){
 		if (mptscsih_TMHandler(hd,
 		     MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,
-		     vdev->bus_id,
-		     vdev->target_id,
+		     vdev->vtarget->bus_id,
+		     vdev->vtarget->target_id,
 		     0, 0, 5 /* 5 second timeout */)
 		     < 0){
 
@@ -454,7 +476,7 @@ mptsas_slave_destroy(struct scsi_device 
 			printk(MYIOC_s_WARN_FMT
 		       "Error processing TaskMgmt id=%d TARGET_RESET\n",
 				hd->ioc->name,
-				vdev->target_id);
+				vdev->vtarget->target_id);
 
 			hd->tmPending = 0;
 			hd->tmState = TM_STATE_NONE;
@@ -472,7 +494,7 @@ static struct scsi_host_template mptsas_
 	.queuecommand			= mptscsih_qcmd,
 	.target_alloc			= mptscsih_target_alloc,
 	.slave_alloc			= mptsas_slave_alloc,
-	.slave_configure		= mptscsih_slave_configure,
+	.slave_configure		= mptsas_slave_configure,
 	.target_destroy			= mptscsih_target_destroy,
 	.slave_destroy			= mptsas_slave_destroy,
 	.change_queue_depth 		= mptscsih_change_queue_depth,
@@ -751,6 +772,9 @@ mptsas_sas_io_unit_pg0(MPT_ADAPTER *ioc,
 		goto out_free_consistent;
 	}
 
+	if (port_info->num_phys)
+		port_info->handle =
+		    le16_to_cpu(buffer->PhyData[0].ControllerDevHandle);
 	for (i = 0; i < port_info->num_phys; i++) {
 		mptsas_print_phy_data(&buffer->PhyData[i]);
 		port_info->phy_info[i].phy_id = i;
@@ -857,6 +881,7 @@ mptsas_sas_device_pg0(MPT_ADAPTER *ioc, 
 	cfg.dir = 0;	/* read */
 	cfg.timeout = 10;
 
+	memset(device_info, 0, sizeof(struct mptsas_devinfo));
 	error = mpt_config(ioc, &cfg);
 	if (error)
 		goto out;
@@ -927,6 +952,7 @@ mptsas_sas_expander_pg0(MPT_ADAPTER *ioc
 	cfg.dir = 0;	/* read */
 	cfg.timeout = 10;
 
+	memset(port_info, 0, sizeof(struct mptsas_portinfo));
 	error = mpt_config(ioc, &cfg);
 	if (error)
 		goto out;
@@ -1027,7 +1053,6 @@ mptsas_sas_expander_pg1(MPT_ADAPTER *ioc
 	phy_info->identify.handle = le16_to_cpu(buffer->OwnerDevHandle);
 	phy_info->attached.handle = le16_to_cpu(buffer->AttachedDevHandle);
 
-
  out_free_consistent:
 	pci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,
 			    buffer, dma_handle);
@@ -1117,12 +1142,19 @@ mptsas_parse_device_info(struct sas_iden
 static int mptsas_probe_one_phy(struct device *dev,
 		struct mptsas_phyinfo *phy_info, int index, int local)
 {
+	MPT_ADAPTER *ioc;
 	struct sas_phy *phy;
 	int error;
 
-	phy = sas_phy_alloc(dev, index);
-	if (!phy)
-		return -ENOMEM;
+	if (!dev)
+		return -ENODEV;
+
+	if (!phy_info->phy) {
+		phy = sas_phy_alloc(dev, index);
+		if (!phy)
+			return -ENOMEM;
+	} else
+		phy = phy_info->phy;
 
 	phy->port_identifier = phy_info->port_id;
 	mptsas_parse_device_info(&phy->identify, &phy_info->identify);
@@ -1208,24 +1240,54 @@ static int mptsas_probe_one_phy(struct d
 		break;
 	}
 
-	if (local)
-		phy->local_attached = 1;
+	if (!phy_info->phy) {
 
-	error = sas_phy_add(phy);
-	if (error) {
-		sas_phy_free(phy);
-		return error;
+		if (local)
+			phy->local_attached = 1;
+
+		error = sas_phy_add(phy);
+		if (error) {
+			sas_phy_free(phy);
+			return error;
+		}
+		phy_info->phy = phy;
 	}
-	phy_info->phy = phy;
 
-	if (phy_info->attached.handle) {
+	if ((phy_info->attached.handle) &&
+	    (!phy_info->rphy)) {
+
 		struct sas_rphy *rphy;
+		struct sas_identify identify;
 
-		rphy = sas_rphy_alloc(phy);
+		ioc = phy_to_ioc(phy_info->phy);
+
+		/*
+		 * Let the hotplug_work thread handle processing
+		 * the adding/removing of devices that occur
+		 * after start of day.
+		 */
+		if (ioc->sas_discovery_runtime &&
+			mptsas_is_end_device(&phy_info->attached))
+			return 0;
+
+		mptsas_parse_device_info(&identify, &phy_info->attached);
+		switch (identify.device_type) {
+		case SAS_END_DEVICE:
+			rphy = sas_end_device_alloc(phy);
+			break;
+		case SAS_EDGE_EXPANDER_DEVICE:
+		case SAS_FANOUT_EXPANDER_DEVICE:
+			rphy = sas_expander_alloc(phy, identify.device_type);
+			break;
+		default:
+			rphy = NULL;
+			break;
+		}
 		if (!rphy)
 			return 0; /* non-fatal: an rphy can be added later */
 
-		mptsas_parse_device_info(&rphy->identify, &phy_info->attached);
+		rphy->identify = identify;
+
 		error = sas_rphy_add(rphy);
 		if (error) {
 			sas_rphy_free(rphy);
@@ -1239,24 +1301,37 @@ static int mptsas_probe_one_phy(struct d
 }
 
 static int
-mptsas_probe_hba_phys(MPT_ADAPTER *ioc, int *index)
+mptsas_probe_hba_phys(MPT_ADAPTER *ioc)
 {
-	struct mptsas_portinfo *port_info;
+	struct mptsas_portinfo *port_info, *hba;
 	u32 handle = 0xFFFF;
 	int error = -ENOMEM, i;
 
-	port_info = kzalloc(sizeof(*port_info), GFP_KERNEL);
-	if (!port_info)
+	hba = kzalloc(sizeof(*port_info), GFP_KERNEL);
+	if (! hba)
 		goto out;
 
-	error = mptsas_sas_io_unit_pg0(ioc, port_info);
+	error = mptsas_sas_io_unit_pg0(ioc, hba);
 	if (error)
 		goto out_free_port_info;
 
-	ioc->num_ports = port_info->num_phys;
 	mutex_lock(&ioc->sas_topology_mutex);
-	list_add_tail(&port_info->list, &ioc->sas_topology);
+	port_info = mptsas_find_portinfo_by_handle(ioc, hba->handle);
+	if (!port_info) {
+		port_info = hba;
+		list_add_tail(&port_info->list, &ioc->sas_topology);
+	} else {
+		port_info->handle = hba->handle;
+		for (i = 0; i < hba->num_phys; i++)
+			port_info->phy_info[i].negotiated_link_rate =
+				hba->phy_info[i].negotiated_link_rate;
+		if (hba->phy_info)
+			kfree(hba->phy_info);
+		kfree(hba);
+		hba = NULL;
+	}
 	mutex_unlock(&ioc->sas_topology_mutex);
+	ioc->num_ports = port_info->num_phys;
 
 	for (i = 0; i < port_info->num_phys; i++) {
 		mptsas_sas_phy_pg0(ioc, &port_info->phy_info[i],
@@ -1279,38 +1354,49 @@ mptsas_probe_hba_phys(MPT_ADAPTER *ioc, 
 		}
 
 		mptsas_probe_one_phy(&ioc->sh->shost_gendev,
-				     &port_info->phy_info[i], *index, 1);
-		(*index)++;
+		    &port_info->phy_info[i], ioc->sas_index, 1);
+		ioc->sas_index++;
 	}
 
 	return 0;
 
  out_free_port_info:
-	kfree(port_info);
+	if (hba)
+		kfree(hba);
  out:
 	return error;
 }
 
 static int
-mptsas_probe_expander_phys(MPT_ADAPTER *ioc, u32 *handle, int *index)
+mptsas_probe_expander_phys(MPT_ADAPTER *ioc, u32 *handle)
 {
-	struct mptsas_portinfo *port_info, *p;
+	struct mptsas_portinfo *port_info, *p, *ex;
 	int error = -ENOMEM, i, j;
 
-	port_info = kzalloc(sizeof(*port_info), GFP_KERNEL);
-	if (!port_info)
+	ex = kzalloc(sizeof(*port_info), GFP_KERNEL);
+	if (!ex)
 		goto out;
 
-	error = mptsas_sas_expander_pg0(ioc, port_info,
+	error = mptsas_sas_expander_pg0(ioc, ex,
 		(MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<
 		 MPI_SAS_EXPAND_PGAD_FORM_SHIFT), *handle);
 	if (error)
 		goto out_free_port_info;
 
-	*handle = port_info->handle;
+	*handle = ex->handle;
 
 	mutex_lock(&ioc->sas_topology_mutex);
-	list_add_tail(&port_info->list, &ioc->sas_topology);
+	port_info = mptsas_find_portinfo_by_handle(ioc, *handle);
+	if (!port_info) {
+		port_info = ex;
+		list_add_tail(&port_info->list, &ioc->sas_topology);
+	} else {
+		port_info->handle = ex->handle;
+		if (ex->phy_info)
+			kfree(ex->phy_info);
+		kfree(ex);
+		ex = NULL;
+	}
 	mutex_unlock(&ioc->sas_topology_mutex);
 
 	for (i = 0; i < port_info->num_phys; i++) {
@@ -1336,6 +1422,8 @@ mptsas_probe_expander_phys(MPT_ADAPTER *
 				(MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<
 				 MPI_SAS_DEVICE_PGAD_FORM_SHIFT),
 				port_info->phy_info[i].attached.handle);
+			port_info->phy_info[i].attached.phy_id =
+			    port_info->phy_info[i].phy_id;
 		}
 
 		/*
@@ -1355,27 +1443,137 @@ mptsas_probe_expander_phys(MPT_ADAPTER *
 		mutex_unlock(&ioc->sas_topology_mutex);
 
 		mptsas_probe_one_phy(parent, &port_info->phy_info[i],
-				     *index, 0);
-		(*index)++;
+		    ioc->sas_index, 0);
+		ioc->sas_index++;
 	}
 
 	return 0;
 
  out_free_port_info:
-	kfree(port_info);
+	if (ex) {
+		if (ex->phy_info)
+			kfree(ex->phy_info);
+		kfree(ex);
+	}
  out:
 	return error;
 }
 
+/*
+ * mptsas_delete_expander_phys
+ *
+ *
+ * This will traverse topology, and remove expanders
+ * that are no longer present
+ */
+static void
+mptsas_delete_expander_phys(MPT_ADAPTER *ioc)
+{
+	struct mptsas_portinfo buffer;
+	struct mptsas_portinfo *port_info, *n, *parent;
+	int i;
+
+	mutex_lock(&ioc->sas_topology_mutex);
+	list_for_each_entry_safe(port_info, n, &ioc->sas_topology, list) {
+
+		if (port_info->phy_info &&
+		    (!(port_info->phy_info[0].identify.device_info &
+		    MPI_SAS_DEVICE_INFO_SMP_TARGET)))
+			continue;
+
+		if (mptsas_sas_expander_pg0(ioc, &buffer,
+		     (MPI_SAS_EXPAND_PGAD_FORM_HANDLE <<
+		     MPI_SAS_EXPAND_PGAD_FORM_SHIFT), port_info->handle)) {
+
+			/*
+			 * Obtain the port_info instance to the parent port
+			 */
+			parent = mptsas_find_portinfo_by_handle(ioc,
+			    port_info->phy_info[0].identify.handle_parent);
+
+			if (!parent)
+				goto next_port;
+
+			/*
+			 * Delete rphys in the parent that point
+			 * to this expander.  The transport layer will
+			 * cleanup all the children.
+			 */
+			for (i = 0; i < parent->num_phys; i++) {
+				if ((!parent->phy_info[i].rphy) ||
+				    (parent->phy_info[i].attached.sas_address !=
+				   port_info->phy_info[i].identify.sas_address))
+					continue;
+				sas_rphy_delete(parent->phy_info[i].rphy);
+				memset(&parent->phy_info[i].attached, 0,
+				    sizeof(struct mptsas_devinfo));
+				parent->phy_info[i].rphy = NULL;
+				parent->phy_info[i].starget = NULL;
+			}
+ next_port:
+			list_del(&port_info->list);
+			if (port_info->phy_info)
+				kfree(port_info->phy_info);
+			kfree(port_info);
+		}
+		/*
+		* Free this memory allocated from inside
+		* mptsas_sas_expander_pg0
+		*/
+		if (buffer.phy_info)
+			kfree(buffer.phy_info);
+	}
+	mutex_unlock(&ioc->sas_topology_mutex);
+}
+
+/*
+ * Start of day discovery
+ */
 static void
 mptsas_scan_sas_topology(MPT_ADAPTER *ioc)
 {
 	u32 handle = 0xFFFF;
-	int index = 0;
+	int i;
+
+	mutex_lock(&ioc->sas_discovery_mutex);
+	mptsas_probe_hba_phys(ioc);
+	while (!mptsas_probe_expander_phys(ioc, &handle))
+		;
+	/*
+	  Reporting RAID volumes.
+	*/
+	if (!ioc->raid_data.pIocPg2)
+		goto out;
+	if (!ioc->raid_data.pIocPg2->NumActiveVolumes)
+		goto out;
+	for (i=0; i<ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {
+		scsi_add_device(ioc->sh, ioc->num_ports,
+		    ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID, 0);
+	}
+ out:
+	mutex_unlock(&ioc->sas_discovery_mutex);
+}
+
+/*
+ * Work queue thread to handle Runtime discovery
+ * Mere purpose is the hot add/delete of expanders
+ */
+static void
+mptscsih_discovery_work(void * arg)
+{
+	struct mptsas_discovery_event *ev = arg;
+	MPT_ADAPTER *ioc = ev->ioc;
+	u32 handle = 0xFFFF;
 
-	mptsas_probe_hba_phys(ioc, &index);
-	while (!mptsas_probe_expander_phys(ioc, &handle, &index))
+	mutex_lock(&ioc->sas_discovery_mutex);
+	ioc->sas_discovery_runtime=1;
+	mptsas_delete_expander_phys(ioc);
+	mptsas_probe_hba_phys(ioc);
+	while (!mptsas_probe_expander_phys(ioc, &handle))
 		;
+	kfree(ev);
+	ioc->sas_discovery_runtime=0;
+	mutex_unlock(&ioc->sas_discovery_mutex);
 }
 
 static struct mptsas_phyinfo *
@@ -1393,10 +1591,8 @@ mptsas_find_phyinfo_by_parent(MPT_ADAPTE
 		(MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<
 		 MPI_SAS_DEVICE_PGAD_FORM_SHIFT),
 		parent_handle);
-	if (error) {
-		printk("mptsas: failed to retrieve device page\n");
+	if (error)
 		return NULL;
-	}
 
 	/*
 	 * The phy_info structures are never deallocated during lifetime of
@@ -1443,6 +1639,35 @@ mptsas_find_phyinfo_by_target(MPT_ADAPTE
 	return phy_info;
 }
 
+/*
+ * Work queue thread to clear the persitency table
+ */
+static void
+mptscsih_sas_persist_clear_table(void * arg)
+{
+	MPT_ADAPTER *ioc = (MPT_ADAPTER *)arg;
+
+	mptbase_sas_persist_operation(ioc, MPI_SAS_OP_CLEAR_NOT_PRESENT);
+}
+
+static void
+mptsas_reprobe_lun(struct scsi_device *sdev, void *data)
+{
+	sdev->no_uld_attach = data ? 1 : 0;
+	scsi_device_reprobe(sdev);
+}
+
+static void
+mptsas_reprobe_target(struct scsi_target *starget, int uld_attach)
+{
+	starget_for_each_device(starget, uld_attach ? (void *)1 : NULL,
+			mptsas_reprobe_lun);
+}
+
+
+/*
+ * Work queue thread to handle SAS hotplug events
+ */
 static void
 mptsas_hotplug_work(void *arg)
 {
@@ -1451,17 +1676,40 @@ mptsas_hotplug_work(void *arg)
 	struct mptsas_phyinfo *phy_info;
 	struct sas_rphy *rphy;
 	struct scsi_device *sdev;
+	struct sas_identify identify;
 	char *ds = NULL;
 	struct mptsas_devinfo sas_device;
+	VirtTarget *vtarget;
+
+	mutex_lock(&ioc->sas_discovery_mutex);
 
 	switch (ev->event_type) {
 	case MPTSAS_DEL_DEVICE:
 
 		phy_info = mptsas_find_phyinfo_by_target(ioc, ev->id);
+
+		/*
+		 * Sanity checks, for non-existing phys and remote rphys.
+		 */
 		if (!phy_info)
 			break;
 		if (!phy_info->rphy)
 			break;
+		if (phy_info->starget) {
+			vtarget = phy_info->starget->hostdata;
+
+			if (!vtarget)
+				break;
+			/*
+			 * Handling  RAID components
+			 */
+			if (ev->phys_disk_num_valid) {
+				vtarget->target_id = ev->phys_disk_num;
+				vtarget->tflags |= MPT_TARGET_FLAGS_RAID_COMPONENT;
+				mptsas_reprobe_target(vtarget->starget, 1);
+				break;
+			}
+		}
 
 		if (phy_info->attached.device_info & MPI_SAS_DEVICE_INFO_SSP_TARGET)
 			ds = "ssp";
@@ -1477,6 +1725,7 @@ mptsas_hotplug_work(void *arg)
 		sas_rphy_delete(phy_info->rphy);
 		memset(&phy_info->attached, 0, sizeof(struct mptsas_devinfo));
 		phy_info->rphy = NULL;
+		phy_info->starget = NULL;
 		break;
 	case MPTSAS_ADD_DEVICE:
 
@@ -1490,16 +1739,55 @@ mptsas_hotplug_work(void *arg)
 
 		phy_info = mptsas_find_phyinfo_by_parent(ioc,
 				sas_device.handle_parent, sas_device.phy_id);
+
 		if (!phy_info) {
-			printk("mptsas: add event for non-existant PHY.\n");
-			break;
+			u32 handle = 0xFFFF;
+
+			/*
+			* Its possible when an expander has been hot added
+			* containing attached devices, the sas firmware
+			* may send a RC_ADDED event prior to the
+			* DISCOVERY STOP event. If that occurs, our
+			* view of the topology in the driver in respect to this
+			* expander might of not been setup, and we hit this
+			* condition.
+			* Therefore, this code kicks off discovery to
+			* refresh the data.
+			* Then again, we check whether the parent phy has
+			* been created.
+			*/
+			ioc->sas_discovery_runtime=1;
+			mptsas_delete_expander_phys(ioc);
+			mptsas_probe_hba_phys(ioc);
+			while (!mptsas_probe_expander_phys(ioc, &handle))
+				;
+			ioc->sas_discovery_runtime=0;
+
+			phy_info = mptsas_find_phyinfo_by_parent(ioc,
+				sas_device.handle_parent, sas_device.phy_id);
+			if (!phy_info)
+				break;
 		}
 
-		if (phy_info->rphy) {
-			printk("mptsas: trying to add existing device.\n");
+		if (phy_info->starget) {
+			vtarget = phy_info->starget->hostdata;
+
+			if (!vtarget)
+				break;
+			/*
+			 * Handling  RAID components
+			 */
+			if (vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT) {
+				vtarget->tflags &= ~MPT_TARGET_FLAGS_RAID_COMPONENT;
+				vtarget->target_id = ev->id;
+				mptsas_reprobe_target(phy_info->starget, 0);
+			}
 			break;
 		}
 
+		if (phy_info->rphy)
+			break;
+
 		memcpy(&phy_info->attached, &sas_device,
 		    sizeof(struct mptsas_devinfo));
 
@@ -1514,12 +1802,23 @@ mptsas_hotplug_work(void *arg)
 		       "attaching %s device, channel %d, id %d, phy %d\n",
 		       ioc->name, ds, ev->channel, ev->id, ev->phy_id);
 
-
-		rphy = sas_rphy_alloc(phy_info->phy);
+		mptsas_parse_device_info(&identify, &phy_info->attached);
+		switch (identify.device_type) {
+		case SAS_END_DEVICE:
+			rphy = sas_end_device_alloc(phy_info->phy);
+			break;
+		case SAS_EDGE_EXPANDER_DEVICE:
+		case SAS_FANOUT_EXPANDER_DEVICE:
+			rphy = sas_expander_alloc(phy_info->phy, identify.device_type);
+			break;
+		default:
+			rphy = NULL;
+			break;
+		}
 		if (!rphy)
 			break; /* non-fatal: an rphy can be added later */
 
-		mptsas_parse_device_info(&rphy->identify, &phy_info->attached);
+		rphy->identify = identify;
 		if (sas_rphy_add(rphy)) {
 			sas_rphy_free(rphy);
 			break;
@@ -1538,7 +1837,7 @@ mptsas_hotplug_work(void *arg)
 			break;
 		}
 		printk(MYIOC_s_INFO_FMT
-		       "attaching device, channel %d, id %d\n",
+		       "attaching raid volume, channel %d, id %d\n",
 		       ioc->name, ioc->num_ports, ev->id);
 		scsi_add_device(ioc->sh,
 			ioc->num_ports,
@@ -1555,7 +1854,7 @@ mptsas_hotplug_work(void *arg)
 		if (!sdev)
 			break;
 		printk(MYIOC_s_INFO_FMT
-		       "removing device, channel %d, id %d\n",
+		       "removing raid volume, channel %d, id %d\n",
 		       ioc->name, ioc->num_ports, ev->id);
 		scsi_remove_device(sdev);
 		scsi_device_put(sdev);
@@ -1564,6 +1863,7 @@ mptsas_hotplug_work(void *arg)
 	}
 
 	kfree(ev);
+	mutex_unlock(&ioc->sas_discovery_mutex);
 }
 
 static void
@@ -1580,35 +1880,51 @@ mptscsih_send_sas_event(MPT_ADAPTER *ioc
 	      MPI_SAS_DEVICE_INFO_SATA_DEVICE )) == 0)
 		return;
 
-	if ((sas_event_data->ReasonCode &
-	     (MPI_EVENT_SAS_DEV_STAT_RC_ADDED |
-	      MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING)) == 0)
-		return;
+	switch (sas_event_data->ReasonCode) {
+	case MPI_EVENT_SAS_DEV_STAT_RC_ADDED:
+	case MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING:
+		ev = kmalloc(sizeof(*ev), GFP_ATOMIC);
+		if (!ev) {
+			printk(KERN_WARNING "mptsas: lost hotplug event\n");
+			break;
+		}
 
-	ev = kmalloc(sizeof(*ev), GFP_ATOMIC);
-	if (!ev) {
-		printk(KERN_WARNING "mptsas: lost hotplug event\n");
-		return;
+		INIT_WORK(&ev->work, mptsas_hotplug_work, ev);
+		ev->ioc = ioc;
+		ev->handle = le16_to_cpu(sas_event_data->DevHandle);
+		ev->parent_handle =
+		    le16_to_cpu(sas_event_data->ParentDevHandle);
+		ev->channel = sas_event_data->Bus;
+		ev->id = sas_event_data->TargetID;
+		ev->phy_id = sas_event_data->PhyNum;
+		memcpy(&sas_address, &sas_event_data->SASAddress,
+		    sizeof(__le64));
+		ev->sas_address = le64_to_cpu(sas_address);
+		ev->device_info = device_info;
+
+		if (sas_event_data->ReasonCode &
+		    MPI_EVENT_SAS_DEV_STAT_RC_ADDED)
+			ev->event_type = MPTSAS_ADD_DEVICE;
+		else
+			ev->event_type = MPTSAS_DEL_DEVICE;
+		schedule_work(&ev->work);
+		break;
+	case MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED:
+	/*
+	 * Persistent table is full.
+	 */
+		INIT_WORK(&ioc->mptscsih_persistTask,
+		    mptscsih_sas_persist_clear_table,
+		    (void *)ioc);
+		schedule_work(&ioc->mptscsih_persistTask);
+		break;
+	case MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA:
+	/* TODO */
+	case MPI_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:
+	/* TODO */
+	default:
+		break;
 	}
-
-
-	INIT_WORK(&ev->work, mptsas_hotplug_work, ev);
-	ev->ioc = ioc;
-	ev->handle = le16_to_cpu(sas_event_data->DevHandle);
-	ev->parent_handle = le16_to_cpu(sas_event_data->ParentDevHandle);
-	ev->channel = sas_event_data->Bus;
-	ev->id = sas_event_data->TargetID;
-	ev->phy_id = sas_event_data->PhyNum;
-	memcpy(&sas_address, &sas_event_data->SASAddress, sizeof(__le64));
-	ev->sas_address = le64_to_cpu(sas_address);
-	ev->device_info = device_info;
-
-	if (sas_event_data->ReasonCode & MPI_EVENT_SAS_DEV_STAT_RC_ADDED)
-		ev->event_type = MPTSAS_ADD_DEVICE;
-	else
-		ev->event_type = MPTSAS_DEL_DEVICE;
-
-	schedule_work(&ev->work);
 }
 
 static void
@@ -1637,6 +1953,9 @@ mptscsih_send_raid_event(MPT_ADAPTER *io
 		ev->event_type = MPTSAS_ADD_DEVICE;
 		break;
 	case MPI_EVENT_RAID_RC_PHYSDISK_CREATED:
+		ioc->raid_data.isRaid = 1;
+		ev->phys_disk_num_valid = 1;
+		ev->phys_disk_num = raid_event_data->PhysDiskNum;
 		ev->event_type = MPTSAS_DEL_DEVICE;
 		break;
 	case MPI_EVENT_RAID_RC_VOLUME_DELETED:
@@ -1658,15 +1977,31 @@ mptscsih_send_raid_event(MPT_ADAPTER *io
 	schedule_work(&ev->work);
 }
 
-/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
-/* work queue thread to clear the persitency table */
 static void
-mptscsih_sas_persist_clear_table(void * arg)
+mptscsih_send_discovery(MPT_ADAPTER *ioc,
+	EVENT_DATA_SAS_DISCOVERY *discovery_data)
 {
-	MPT_ADAPTER *ioc = (MPT_ADAPTER *)arg;
+	struct mptsas_discovery_event *ev;
+
+	/*
+	 * DiscoveryStatus
+	 *
+	 * This flag will be non-zero when firmware
+	 * kicks off discovery, and return to zero
+	 * once its completed.
+	 */
+	if (discovery_data->DiscoveryStatus)
+		return;
+
+	ev = kmalloc(sizeof(*ev), GFP_ATOMIC);
+	if (!ev)
+		return;
+	memset(ev,0,sizeof(struct mptsas_discovery_event));
+	INIT_WORK(&ev->work, mptscsih_discovery_work, ev);
+	ev->ioc = ioc;
+	schedule_work(&ev->work);
+};
 
-	mptbase_sas_persist_operation(ioc, MPI_SAS_OP_CLEAR_NOT_PRESENT);
-}
 
 static int
 mptsas_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *reply)
@@ -1677,6 +2012,17 @@ mptsas_event_process(MPT_ADAPTER *ioc, E
 	if (!ioc->sh)
 		goto out;
 
+	/*
+	 * sas_discovery_ignore_events
+	 *
+	 * This flag is to prevent anymore processing of
+	 * sas events once mptsas_remove function is called.
+	 */
+	if (ioc->sas_discovery_ignore_events) {
+		rc = mptscsih_event_process(ioc, reply);
+		goto out;
+	}
+
 	switch (event) {
 	case MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:
 		mptscsih_send_sas_event(ioc,
@@ -1692,6 +2038,10 @@ mptsas_event_process(MPT_ADAPTER *ioc, E
 		    (void *)ioc);
 		schedule_work(&ioc->mptscsih_persistTask);
 		break;
+	 case MPI_EVENT_SAS_DISCOVERY:
+		mptscsih_send_discovery(ioc,
+			(EVENT_DATA_SAS_DISCOVERY *)reply->Data);
+		break;
 	default:
 		rc = mptscsih_event_process(ioc, reply);
 		break;
@@ -1793,7 +2143,7 @@ mptsas_probe(struct pci_dev *pdev, const
 
 	INIT_LIST_HEAD(&ioc->sas_topology);
 	mutex_init(&ioc->sas_topology_mutex);
-
+	mutex_init(&ioc->sas_discovery_mutex);
 	mutex_init(&ioc->sas_mgmt.mutex);
 	init_completion(&ioc->sas_mgmt.done);
 
@@ -1906,20 +2256,6 @@ mptsas_probe(struct pci_dev *pdev, const
 
 	mptsas_scan_sas_topology(ioc);
 
-	/*
-	  Reporting RAID volumes.
-	*/
-	if (!ioc->raid_data.pIocPg2)
-		return 0;
-	if (!ioc->raid_data.pIocPg2->NumActiveVolumes)
-		return 0;
-	for (ii=0;ii<ioc->raid_data.pIocPg2->NumActiveVolumes;ii++) {
-		scsi_add_device(sh,
-			ioc->num_ports,
-			ioc->raid_data.pIocPg2->RaidVolume[ii].VolumeID,
-			0);
-	}
-
 	return 0;
 
 out_mptsas_probe:
@@ -1933,11 +2269,14 @@ static void __devexit mptsas_remove(stru
 	MPT_ADAPTER *ioc = pci_get_drvdata(pdev);
 	struct mptsas_portinfo *p, *n;
 
+	ioc->sas_discovery_ignore_events=1;
 	sas_remove_host(ioc->sh);
 
 	mutex_lock(&ioc->sas_topology_mutex);
 	list_for_each_entry_safe(p, n, &ioc->sas_topology, list) {
 		list_del(&p->list);
+		if (p->phy_info)
+			kfree(p->phy_info);
 		kfree(p);
 	}
 	mutex_unlock(&ioc->sas_topology_mutex);
@@ -1992,7 +2331,7 @@ mptsas_init(void)
 	mptsasMgmtCtx = mpt_register(mptsas_mgmt_done, MPTSAS_DRIVER);
 
 	if (mpt_event_register(mptsasDoneCtx, mptsas_event_process) == 0) {
-		devtprintk((KERN_INFO MYNAM
+		devtverboseprintk((KERN_INFO MYNAM
 		  ": Registered for IOC event notifications\n"));
 	}
 
diff --git a/drivers/message/fusion/mptscsih.c b/drivers/message/fusion/mptscsih.c
index a218310..3729062 100644
--- a/drivers/message/fusion/mptscsih.c
+++ b/drivers/message/fusion/mptscsih.c
@@ -887,7 +887,7 @@ mptscsih_search_running_cmds(MPT_SCSI_HO
 			dsprintk(( "search_running: found (sc=%p, mf = %p) target %d, lun %d \n",
 					hd->ScsiLookup[ii], mf, mf->TargetID, mf->LUN[1]));
 
-			if ((mf->TargetID != ((u8)vdevice->target_id)) || (mf->LUN[1] != ((u8) vdevice->lun)))
+			if ((mf->TargetID != ((u8)vdevice->vtarget->target_id)) || (mf->LUN[1] != ((u8) vdevice->lun)))
 				continue;
 
 			/* Cleanup
@@ -1235,6 +1235,14 @@ mptscsih_qcmd(struct scsi_cmnd *SCpnt, v
 		return SCSI_MLQUEUE_HOST_BUSY;
	}
 
+	if ((hd->ioc->bus_type == SPI) &&
+	    vdev->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT &&
+	    mptscsih_raid_id_to_num(hd, SCpnt->device->id) < 0) {
+		SCpnt->result = DID_NO_CONNECT << 16;
+		done(SCpnt);
+		return 0;
+	}
+
 	/*
 	 *  Put together a MPT SCSI request...
 	 */
@@ -1285,10 +1286,13 @@ mptscsih_qcmd(struct scsi_cmnd *SCpnt, v
 
 	/* Use the above information to set up the message frame
 	 */
-	pScsiReq->TargetID = (u8) vdev->target_id;
-	pScsiReq->Bus = vdev->bus_id;
+	pScsiReq->TargetID = (u8) vdev->vtarget->target_id;
+	pScsiReq->Bus = vdev->vtarget->bus_id;
 	pScsiReq->ChainOffset = 0;
-	pScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
+	if (vdev->vtarget->tflags &  MPT_TARGET_FLAGS_RAID_COMPONENT)
+		pScsiReq->Function = MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;
+	else
+		pScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;
 	pScsiReq->CDBLength = SCpnt->cmd_len;
 	pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
 	pScsiReq->Reserved = 0;
@@ -1701,7 +1702,7 @@ mptscsih_abort(struct scsi_cmnd * SCpnt)
 
 	vdev = SCpnt->device->hostdata;
 	retval = mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK,
-		vdev->bus_id, vdev->target_id, vdev->lun,
+		vdev->vtarget->bus_id, vdev->vtarget->target_id, vdev->lun,
 		ctx2abort, mptscsih_get_tm_timeout(ioc));
 
 	printk (KERN_WARNING MYNAM ": %s: task abort: %s (sc=%p)\n",
@@ -1752,7 +1753,7 @@ mptscsih_dev_reset(struct scsi_cmnd * SC
 
 	vdev = SCpnt->device->hostdata;
 	retval = mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,
-		vdev->bus_id, vdev->target_id,
+		vdev->vtarget->bus_id, vdev->vtarget->target_id,
 		0, 0, mptscsih_get_tm_timeout(hd->ioc));
 
 	printk (KERN_WARNING MYNAM ": %s: target reset: %s (sc=%p)\n",
@@ -1803,7 +1804,7 @@ mptscsih_bus_reset(struct scsi_cmnd * SC
 
 	vdev = SCpnt->device->hostdata;
 	retval = mptscsih_TMHandler(hd, MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,
-		vdev->bus_id, 0, 0, 0, mptscsih_get_tm_timeout(hd->ioc));
+		vdev->vtarget->bus_id, 0, 0, 0, mptscsih_get_tm_timeout(hd->ioc));
 
 	printk (KERN_WARNING MYNAM ": %s: bus reset: %s (sc=%p)\n",
 		hd->ioc->name,
@@ -2103,6 +2104,42 @@ mptscsih_bios_param(struct scsi_device *
 	return 0;
 }
 
+/* Search IOC page 3 to determine if this is hidden physical disk
+ *
+ */
+int
+mptscsih_is_phys_disk(MPT_ADAPTER *ioc, int id)
+{
+	int i;
+
+	if (!ioc->raid_data.isRaid || !ioc->raid_data.pIocPg3)
+		return 0;
+	for (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {
+                if (id == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskID)
+                        return 1;
+        }
+        return 0;
+}
+EXPORT_SYMBOL(mptscsih_is_phys_disk);
+
+int
+mptscsih_raid_id_to_num(MPT_SCSI_HOST *hd, uint physdiskid)
+{
+	int i;
+
+	if (!hd->ioc->raid_data.isRaid || !hd->ioc->raid_data.pIocPg3)
+		return -ENXIO;
+
+	for (i = 0; i < hd->ioc->raid_data.pIocPg3->NumPhysDisks; i++) {
+		if (physdiskid ==
+		    hd->ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskID)
+			return hd->ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum;
+	}
+
+	return -ENXIO;
+}
+EXPORT_SYMBOL(mptscsih_raid_id_to_num);
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /*
  *	OS entry point to allow host driver to alloc memory
@@ -2162,9 +2181,6 @@ mptscsih_slave_alloc(struct scsi_device 
 		return -ENOMEM;
 	}
 
-	vdev->ioc_id = hd->ioc->id;
-	vdev->target_id = sdev->id;
-	vdev->bus_id = sdev->channel;
 	vdev->lun = sdev->lun;
 	sdev->hostdata = vdev;
 
@@ -2531,7 +2547,7 @@ mptscsih_event_process(MPT_ADAPTER *ioc,
 	int work_count;
 	unsigned long flags;
 
-	devtprintk((MYIOC_s_INFO_FMT "MPT event (=%02Xh) routed to SCSI host driver!\n",
+	devtverboseprintk((MYIOC_s_INFO_FMT "MPT event (=%02Xh) routed to SCSI host driver!\n",
 			ioc->name, event));
 
 	if (ioc->sh == NULL ||
@@ -3366,8 +3382,8 @@ mptscsih_synchronize_cache(MPT_SCSI_HOST
 	iocmd.data_dma = -1;
 	iocmd.size = 0;
 	iocmd.rsvd = iocmd.rsvd2 = 0;
-	iocmd.bus = vdevice->bus_id;
-	iocmd.id = vdevice->target_id;
+	iocmd.bus = vdevice->vtarget->bus_id;
+	iocmd.id = vdevice->vtarget->target_id;
 	iocmd.lun = (u8)vdevice->lun;
 
 	if ((vdevice->vtarget->type == TYPE_DISK) &&
diff --git a/drivers/message/fusion/mptscsih.h b/drivers/message/fusion/mptscsih.h
index 2447a20..14a5b6c 100644
--- a/drivers/message/fusion/mptscsih.h
+++ b/drivers/message/fusion/mptscsih.h
@@ -100,4 +100,5 @@ extern int mptscsih_change_queue_depth(s
 extern void mptscsih_timer_expired(unsigned long data);
 extern int mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 target, u8 lun, int ctx2abort, ulong timeout);
 extern void mptscsih_poll(struct scsi_device *sdev);
-
+extern int mptscsih_raid_id_to_num(MPT_SCSI_HOST *hd, uint physdiskid);
+extern int mptscsih_is_phys_disk(MPT_ADAPTER *ioc, int id);
diff --git a/drivers/message/fusion/mptspi.c b/drivers/message/fusion/mptspi.c
index 437189f..09c745b 100644
--- a/drivers/message/fusion/mptspi.c
+++ b/drivers/message/fusion/mptspi.c
@@ -1057,7 +1057,7 @@ mptspi_init(void)
 	mptspiInternalCtx = mpt_register(mptscsih_scandv_complete, MPTSPI_DRIVER);
 
 	if (mpt_event_register(mptspiDoneCtx, mptscsih_event_process) == 0) {
-		devtprintk((KERN_INFO MYNAM
+		devtverboseprintk((KERN_INFO MYNAM
 		  ": Registered for IOC event notifications\n"));
 	}
 
