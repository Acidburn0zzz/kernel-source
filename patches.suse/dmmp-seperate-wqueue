From: mikenc@us.ibm.com
References: 54260 LTC7788
Subject: dm-multipath uses default workqueue but sleeps causing other users problems
Patch-mainline: unknown

Get a lot of IO to fail on the same dm multipath device and continue to
send new IO, so that the underlying device queue hits the nr_request and
batching limits and ends up blocking.

If the generic_make_requesst call that ends up blocking comes from
dm-mpath.c's dispatch_failed_ios() then it will end up blocking all the
users of the defualt workqueue on that processor.

A simple fix would be to just have dm-multipath use its own workqueue.

Acked-by: Jens Axboe <axboe@suse.de>

--- linux-2.6.5-6/drivers/md/dm-mpath.c.orig	2004-04-08 07:30:39.000000000 -0700
+++ linux-2.6.5-6/drivers/md/dm-mpath.c	2004-04-20 17:46:43.558950808 -0700
@@ -92,6 +92,7 @@ struct mpath_io {
 #define MIN_IOS 256
 static kmem_cache_t *_details_cache;
 
+struct workqueue_struct *kmultipathd;
 static void dispatch_failed_ios(void *data);
 static void trigger_event(void *data);
 
@@ -566,7 +567,7 @@ static int do_end_io(struct multipath *m
 		bio_list_add(&m->failed_ios, bio);
 		spin_unlock(&m->lock);
 
-		schedule_work(&m->dispatch_failed);
+		queue_work(kmultipathd, &m->dispatch_failed);
 		return 1;	/* io not complete */
 	}
 
@@ -685,6 +686,13 @@ int __init dm_multipath_init(void)
 		return r;
 	}
 
+	kmultipathd = create_workqueue("kmpathd");
+	if (!kmultipathd) {
+		dm_unregister_path_selectors();
+		dm_unregister_target(&multipath_target);
+		kmem_cache_destroy(_details_cache);
+	}
+
 	DMINFO("dm_multipath v0.2.0");
 	return r;
 }
@@ -693,6 +701,7 @@ void __exit dm_multipath_exit(void)
 {
 	int r;
 
+	destroy_workqueue(kmultipathd);
 	dm_unregister_path_selectors();
 	r = dm_unregister_target(&multipath_target);
 	if (r < 0)
