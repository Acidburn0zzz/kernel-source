From: okir@suse.de
Subject: Add /proc/sys/fs/nfs sysctls to nfsd module

  This patch adds the plumbing for adding nfs-specific sysctls to fs/nfs,
  and makes the max size of a readdirplus reply tunable.

  The reason for this is that we found that some clients do not seem
  to grok readdirplus replies larger than 4K. Rather than reducing the
  overall number this sysctl allows admins to work around these clients.

Signed-off-by: Olaf Kirch <okir@suse.de>

 fs/nfsd/nfs3xdr.c         |    5 ++++-
 fs/nfsd/nfsctl.c          |   28 ++++++++++++++++++++++++++++
 include/linux/nfsd/xdr3.h |    4 ++++
 3 files changed, 36 insertions(+), 1 deletion(-)

Index: build/fs/nfsd/nfsctl.c
===================================================================
--- build.orig/fs/nfsd/nfsctl.c
+++ build/fs/nfsd/nfsctl.c
@@ -30,6 +30,7 @@
 #include <linux/nfsd/nfsd.h>
 #include <linux/nfsd/cache.h>
 #include <linux/nfsd/xdr.h>
+#include <linux/nfsd/xdr3.h>
 #include <linux/nfsd/syscall.h>
 #include <linux/nfsd/interface.h>
 
@@ -506,8 +507,28 @@ static struct file_system_type nfsd_fs_t
 	.kill_sb	= kill_litter_super,
 };
 
+ /*
+ * NFS sysctls
+ */
+static struct ctl_table_header *nfsd_sysctl_table;
+
+static ctl_table nfsd_sysctls[] = {
+	{
+		.ctl_name	= -2,
+		.procname	= "nfsd_readdirplus_max",
+		.data		= &nfsd_readdirplus_max,
+		.maxlen		= sizeof(nfsd_readdirplus_max),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &nfsd_readdirplus_max_lb,
+		.extra2		= &nfsd_readdirplus_max_ub,
+	},
+	{ .ctl_name = 0 }
+};
+
 static int __init init_nfsd(void)
 {
+	struct ctl_path ctl_path[] = { { CTL_FS, "fs", 0555 }, { -2, "nfs", 0555 }, { 0 } };
 	int retval;
 	printk(KERN_INFO "Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\n");
 
@@ -517,6 +538,7 @@ static int __init init_nfsd(void)
 	nfsd_lockd_init();	/* lockd->nfsd callbacks */
 	nfs4_state_init();	/* NFSv4 locking state */
 	nfsd_idmap_init();      /* Name to ID mapping */
+	nfsd_sysctl_table = register_sysctl_table_path(nfsd_sysctls, ctl_path);
 	if (proc_mkdir("fs/nfs", NULL)) {
 		struct proc_dir_entry *entry;
 		entry = create_proc_entry("fs/nfs/exports", 0, NULL);
@@ -531,6 +553,9 @@ static int __init init_nfsd(void)
 		remove_proc_entry("fs/nfs", NULL);
 		nfsd_stat_shutdown();
 		nfsd_lockd_shutdown();
+		if (nfsd_sysctl_table)
+			unregister_sysctl_table(nfsd_sysctl_table);
+		nfsd_sysctl_table = NULL;
 	}
 	return retval;
 }
@@ -545,6 +570,9 @@ static void __exit exit_nfsd(void)
 	nfsd_lockd_shutdown();
 	nfsd_idmap_shutdown();
 	unregister_filesystem(&nfsd_fs_type);
+	if (nfsd_sysctl_table)
+		unregister_sysctl_table(nfsd_sysctl_table);
+	nfsd_sysctl_table = NULL;
 }
 
 MODULE_AUTHOR("Olaf Kirch <okir@monad.swb.de>");
Index: build/fs/nfsd/nfs3xdr.c
===================================================================
--- build.orig/fs/nfsd/nfs3xdr.c
+++ build/fs/nfsd/nfs3xdr.c
@@ -28,6 +28,9 @@
 # define inline
 #endif
 
+unsigned int	nfsd_readdirplus_max = NFSSVC_MAXBLKSIZE;
+unsigned int	nfsd_readdirplus_max_lb = 512;
+unsigned int	nfsd_readdirplus_max_ub = NFSSVC_MAXBLKSIZE;
 
 /*
  * Mapping of S_IF* types to NFS file types
@@ -573,7 +576,7 @@ nfs3svc_decode_readdirplusargs(struct sv
 	args->dircount = ntohl(*p++);
 	args->count    = ntohl(*p++);
 
-	len = (args->count > NFSSVC_MAXBLKSIZE) ? NFSSVC_MAXBLKSIZE :
+	len = (args->count > nfsd_readdirplus_max) ? nfsd_readdirplus_max :
 						  args->count;
 	args->count = len;
 
Index: build/include/linux/nfsd/xdr3.h
===================================================================
--- build.orig/include/linux/nfsd/xdr3.h
+++ build/include/linux/nfsd/xdr3.h
@@ -268,6 +268,10 @@ union nfsd3_xdrstore {
 
 #define NFS3_SVC_XDRSIZE		sizeof(union nfsd3_xdrstore)
 
+extern unsigned int			nfsd_readdirplus_max;
+extern unsigned int			nfsd_readdirplus_max_ub;
+extern unsigned int			nfsd_readdirplus_max_lb;
+
 int nfs3svc_decode_fhandle(struct svc_rqst *, u32 *, struct nfsd_fhandle *);
 int nfs3svc_decode_sattrargs(struct svc_rqst *, u32 *,
 				struct nfsd3_sattrargs *);
