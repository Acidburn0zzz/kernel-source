# 04/04/23	akpm@osdl.org	1.1371.757.1
# [PATCH] writeback livelock fix
# 
# If a filesystem's ->writepage implementation repeatedly refuses to write the
# page (it keeps on redirtying it instead) (reiserfs seems to do this) then the
# writeback logic can get stuck repeately trying to write the same page.
# 
# Fix that up by correctly setting wbc->pages_skipped, to tell the writeback
# logic that things aren't working out.
# --------------------------------------------
#
Index: linux.t/fs/buffer.c
===================================================================
--- linux.t.orig/fs/buffer.c	2004-06-02 09:05:34.000000000 -0400
+++ linux.t/fs/buffer.c	2004-06-02 10:00:13.032850144 -0400
@@ -1898,7 +1898,7 @@ static int __block_write_full_page(struc
 		if (wbc->sync_mode != WB_SYNC_NONE || !wbc->nonblocking) {
 			lock_buffer(bh);
 		} else if (test_set_buffer_locked(bh)) {
-			__set_page_dirty_nobuffers(page);
+			redirty_page_for_writepage(wbc, page);
 			continue;
 		}
 		if (test_clear_buffer_dirty(bh)) {
Index: linux.t/fs/ext3/inode.c
===================================================================
--- linux.t.orig/fs/ext3/inode.c	2004-06-02 09:05:20.000000000 -0400
+++ linux.t/fs/ext3/inode.c	2004-06-02 10:00:13.028850752 -0400
@@ -1400,7 +1400,7 @@ static int ext3_ordered_writepage(struct
 	return ret;
 
 out_fail:
-	__set_page_dirty_nobuffers(page);
+	redirty_page_for_writepage(wbc, page);
 	unlock_page(page);
 	return ret;
 }
@@ -1429,7 +1429,7 @@ static int ext3_writeback_writepage(stru
 	return ret;
 
 out_fail:
-	__set_page_dirty_nobuffers(page);
+	redirty_page_for_writepage(wbc, page);
 	unlock_page(page);
 	return ret;
 }
@@ -1485,7 +1485,7 @@ out:
 	return ret;
 
 no_write:
-	__set_page_dirty_nobuffers(page);
+	redirty_page_for_writepage(wbc, page);
 out_unlock:
 	unlock_page(page);
 	goto out;
Index: linux.t/fs/ntfs/aops.c
===================================================================
--- linux.t.orig/fs/ntfs/aops.c	2004-06-02 09:05:20.000000000 -0400
+++ linux.t/fs/ntfs/aops.c	2004-06-02 09:08:18.000000000 -0400
@@ -458,7 +458,7 @@ err_out:
  *
  * Based on ntfs_read_block() and __block_write_full_page().
  */
-static int ntfs_write_block(struct page *page)
+static int ntfs_write_block(struct writeback_control *wbc, struct page *page)
 {
 	VCN vcn;
 	LCN lcn;
@@ -499,10 +499,7 @@ static int ntfs_write_block(struct page 
 		 * Put the page back on mapping->dirty_pages, but leave its
 		 * buffer's dirty state as-is.
 		 */
-		// FIXME: Once Andrew's -EAGAIN patch goes in, remove the
-		// __set_page_dirty_nobuffers(page) and return -EAGAIN instead
-		// of zero.
-		__set_page_dirty_nobuffers(page);
+		redirty_page_for_writepage(wbc, page);
 		unlock_page(page);
 		return 0;
 	}
@@ -733,10 +730,7 @@ lock_retry_remap:
 			 * Put the page back on mapping->dirty_pages, but
 			 * leave its buffer's dirty state as-is.
 			 */
-			// FIXME: Once Andrew's -EAGAIN patch goes in, remove
-			// the __set_page_dirty_nobuffers(page) and set err to
-			// -EAGAIN instead of zero.
-			__set_page_dirty_nobuffers(page);
+			redirty_page_for_writepage(wbc, page);
 			err = 0;
 		} else
 			SetPageError(page);
@@ -869,7 +863,7 @@ static int ntfs_writepage(struct page *p
 		}
 
 		/* Normal data stream. */
-		return ntfs_write_block(page);
+		return ntfs_write_block(wbc, page);
 	}
 
 	/*
@@ -986,10 +980,7 @@ err_out:
 		 * Put the page back on mapping->dirty_pages, but leave its
 		 * buffer's dirty state as-is.
 		 */
-		// FIXME: Once Andrew's -EAGAIN patch goes in, remove the
-		// __set_page_dirty_nobuffers(page) and set err to -EAGAIN
-		// instead of zero.
-		__set_page_dirty_nobuffers(page);
+		redirty_page_for_writepage(wbc, page);
 		err = 0;
 	} else {
 		ntfs_error(vi->i_sb, "Resident attribute write failed with "
Index: linux.t/fs/reiserfs/inode.c
===================================================================
--- linux.t.orig/fs/reiserfs/inode.c	2004-06-02 09:05:40.000000000 -0400
+++ linux.t/fs/reiserfs/inode.c	2004-06-02 10:00:13.030850448 -0400
@@ -2311,7 +2311,7 @@ static int reiserfs_write_full_page(stru
 	    lock_buffer(bh);
 	} else {
 	    if (test_set_buffer_locked(bh)) {
-		__set_page_dirty_nobuffers(page);
+		redirty_page_for_writepage(wbc, page);
 		continue;
 	    }
 	}
Index: linux.t/include/linux/mm.h
===================================================================
--- linux.t.orig/include/linux/mm.h	2004-06-02 09:05:38.000000000 -0400
+++ linux.t/include/linux/mm.h	2004-06-02 09:08:18.000000000 -0400
@@ -702,6 +702,8 @@ extern long do_mprotect(struct mm_struct
 
 int __set_page_dirty_buffers(struct page *page);
 int __set_page_dirty_nobuffers(struct page *page);
+int redirty_page_for_writepage(struct writeback_control *wbc,
+				struct page *page);
 int set_page_dirty_lock(struct page *page);
 int FASTCALL(set_page_dirty(struct page *page));
 int clear_page_dirty_for_io(struct page *page);
Index: linux.t/mm/page-writeback.c
===================================================================
--- linux.t.orig/mm/page-writeback.c	2004-06-02 09:05:24.000000000 -0400
+++ linux.t/mm/page-writeback.c	2004-06-02 09:08:18.000000000 -0400
@@ -573,6 +573,18 @@ int __set_page_dirty_nobuffers(struct pa
 EXPORT_SYMBOL(__set_page_dirty_nobuffers);
 
 /*
+ * When a writepage implementation decides that it doesn't want to write this
+ * page for some reason, it should redirty the locked page via
+ * redirty_page_for_writepage() and it should then unlock the page and return 0
+ */
+int redirty_page_for_writepage(struct writeback_control *wbc, struct page *page)
+{
+	wbc->pages_skipped++;
+	return __set_page_dirty_nobuffers(page);
+}
+EXPORT_SYMBOL(redirty_page_for_writepage);
+
+/*
  * If the mapping doesn't provide a set_page_dirty a_op, then
  * just fall through and assume that it wants buffer_heads.
  * FIXME: make the method unconditional.
