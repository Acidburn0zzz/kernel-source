Date: Thu, 1 Apr 2004 15:10:16 +0200
From: Andrea Arcangeli <andrea@suse.de>
Subject: [kernel] disable-cap-mlock

Oracle needs this sysctl, I designed it and Ken Chen implemented it,
#37123 for details.

Can you checkin into CVS after a short review? I prefer this than the
mlock-rlimits, it's an order of magnitude simpler and it should be more
efficient too. google will certainly appreciate this too (more than the
rlimit thing).

Index: linux-2.6.4/fs/hugetlbfs/inode.c
===================================================================
--- linux-2.6.4.orig/fs/hugetlbfs/inode.c
+++ linux-2.6.4/fs/hugetlbfs/inode.c
@@ -707,7 +707,7 @@ struct file *hugetlb_zero_setup(size_t s
 	struct qstr quick_string;
 	char buf[16];
 
-	if (!capable(CAP_IPC_LOCK))
+	if (!disable_cap_mlock && !capable(CAP_IPC_LOCK))
 		return ERR_PTR(-EPERM);
 
 	if (!is_hugepage_mem_enough(size))
Index: linux-2.6.4/include/linux/capability.h
===================================================================
--- linux-2.6.4.orig/include/linux/capability.h
+++ linux-2.6.4/include/linux/capability.h
@@ -316,6 +316,8 @@ extern kernel_cap_t cap_bset;
 #define cap_lower(c, flag)   (cap_t(c) &= ~CAP_TO_MASK(flag))
 #define cap_raised(c, flag)  (cap_t(c) & CAP_TO_MASK(flag))
 
+extern int disable_cap_mlock;
+
 static inline kernel_cap_t cap_combine(kernel_cap_t a, kernel_cap_t b)
 {
      kernel_cap_t dest;
Index: linux-2.6.4/include/linux/sysctl.h
===================================================================
--- linux-2.6.4.orig/include/linux/sysctl.h
+++ linux-2.6.4/include/linux/sysctl.h
@@ -166,6 +166,7 @@ enum
 	VM_MIN_FREE_KBYTES=21,	/* Minimum free kilobytes to maintain */
 	VM_LAPTOP_MODE=22,      /* vm laptop mode */
 	VM_BLOCK_DUMP=23,       /* block dump mode */
+	VM_DISABLE_CAP_MLOCK=24,/* disable CAP_IPC_LOCK checking */
 };
 
 
Index: linux-2.6.4/ipc/shm.c
===================================================================
--- linux-2.6.4.orig/ipc/shm.c
+++ linux-2.6.4/ipc/shm.c
@@ -503,7 +503,7 @@ asmlinkage long sys_shmctl (int shmid, i
 /* Allow superuser to lock segment in memory */
 /* Should the pages be faulted in here or leave it to user? */
 /* need to determine interaction with current->swappable */
-		if (!capable(CAP_IPC_LOCK)) {
+		if (!disable_cap_mlock && !capable(CAP_IPC_LOCK)) {
 			err = -EPERM;
 			goto out;
 		}
Index: linux-2.6.4/kernel/capability.c
===================================================================
--- linux-2.6.4.orig/kernel/capability.c
+++ linux-2.6.4/kernel/capability.c
@@ -14,6 +14,7 @@
 
 unsigned securebits = SECUREBITS_DEFAULT; /* systemwide security settings */
 kernel_cap_t cap_bset = CAP_INIT_EFF_SET;
+int disable_cap_mlock = 0;
 
 EXPORT_SYMBOL(securebits);
 EXPORT_SYMBOL(cap_bset);
Index: linux-2.6.4/kernel/sysctl.c
===================================================================
--- linux-2.6.4.orig/kernel/sysctl.c
+++ linux-2.6.4/kernel/sysctl.c
@@ -814,6 +814,14 @@ static ctl_table vm_table[] = {
 		.strategy	= &sysctl_intvec,
 		.extra1		= &zero,
 	},
+	{
+		.ctl_name	= VM_DISABLE_CAP_MLOCK,
+		.procname	= "disable_cap_mlock",
+		.data		= &disable_cap_mlock,
+		.maxlen		= sizeof(disable_cap_mlock),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 	{ .ctl_name = 0 }
 };
 
Index: linux-2.6.4/mm/mlock.c
===================================================================
--- linux-2.6.4.orig/mm/mlock.c
+++ linux-2.6.4/mm/mlock.c
@@ -57,7 +57,7 @@ static int do_mlock(unsigned long start,
 	struct vm_area_struct * vma, * next;
 	int error;
 
-	if (on && !capable(CAP_IPC_LOCK))
+	if (on && !disable_cap_mlock && !capable(CAP_IPC_LOCK))
 		return -EPERM;
 	len = PAGE_ALIGN(len);
 	end = start + len;
@@ -139,7 +139,7 @@ static int do_mlockall(int flags)
 	unsigned int def_flags;
 	struct vm_area_struct * vma;
 
-	if (!capable(CAP_IPC_LOCK))
+	if (!disable_cap_mlock && !capable(CAP_IPC_LOCK))
 		return -EPERM;
 
 	def_flags = 0;
Index: linux-2.6.4/mm/mmap.c
===================================================================
--- linux-2.6.4.orig/mm/mmap.c
+++ linux-2.6.4/mm/mmap.c
@@ -569,7 +569,7 @@ unsigned long __do_mmap_pgoff(struct mm_
 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
 	if (flags & MAP_LOCKED) {
-		if (!capable(CAP_IPC_LOCK))
+		if (!disable_cap_mlock && !capable(CAP_IPC_LOCK))
 			return -EPERM;
 		vm_flags |= VM_LOCKED;
 	}
