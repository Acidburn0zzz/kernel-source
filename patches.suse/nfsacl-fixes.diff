From: Andreas Gruenbacher <agruen@suse.de>
Subject: Device special files and permission cache fix
References: 48477

The nfsacl patch for the nfs client did not check permissions of device
files correctly, so ACLs of device files on NFS did not work.  The
trivial and obvious fix it to add the nfs_permission function to
nfs_special_inode_operations.

The cache for nfs_permission() access checks was not invalidated after a
SETACL RPC, so the old permissions were still used for local access
decisions until the cache timed out (in 3 seconds by default). The fix
is obvious enough as well.

Index: linux-2.6.5/fs/nfs/inode.c
===================================================================
--- linux-2.6.5.orig/fs/nfs/inode.c
+++ linux-2.6.5/fs/nfs/inode.c
@@ -716,6 +716,7 @@ nfs_init_locked(struct inode *inode, voi
 
 #ifdef CONFIG_NFS_ACL
 static struct inode_operations nfs_special_inode_operations = {
+	.permission =	nfs_permission,
 	.getattr =	nfs_getattr,
 	.setattr =	nfs_setattr,
 	.listxattr =	nfs_listxattr,
@@ -826,6 +827,16 @@ out_no_inode:
 	goto out;
 }
 
+void
+nfs_invalidate_access_cache(struct inode *inode)
+{
+	struct rpc_cred **cred = &NFS_I(inode)->cache_access.cred;
+	if (*cred) {
+		put_rpccred(*cred);
+		*cred = NULL;
+	}
+}
+
 #define NFS_VALID_ATTRS (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_SIZE|ATTR_ATIME|ATTR_ATIME_SET|ATTR_MTIME|ATTR_MTIME_SET)
 
 int
@@ -871,13 +882,8 @@ nfs_setattr(struct dentry *dentry, struc
 			vmtruncate(inode, attr->ia_size);
 		}
 	}
-	if ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0) {
-		struct rpc_cred **cred = &NFS_I(inode)->cache_access.cred;
-		if (*cred) {
-			put_rpccred(*cred);
-			*cred = NULL;
-		}
-	}
+	if ((attr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0)
+		nfs_invalidate_access_cache(inode);
 	nfs_end_data_update(inode);
 	unlock_kernel();
 	return error;
Index: linux-2.6.5/fs/nfs/nfs3proc.c
===================================================================
--- linux-2.6.5.orig/fs/nfs/nfs3proc.c
+++ linux-2.6.5/fs/nfs/nfs3proc.c
@@ -910,6 +910,7 @@ nfs3_proc_setacls(struct inode *inode, s
 		} else if (status == -ENOTSUPP)
 			status = -EOPNOTSUPP;
 	} else {
+		nfs_invalidate_access_cache(inode);
 		/* Force an attribute cache update if the file mode
 		 * has changed. */
 		if (inode->i_mode != fattr.mode)
Index: linux-2.6.5/include/linux/nfs_fs.h
===================================================================
--- linux-2.6.5.orig/include/linux/nfs_fs.h
+++ linux-2.6.5/include/linux/nfs_fs.h
@@ -270,6 +270,7 @@ extern void nfs_set_mmcred(struct inode 
 extern int nfs_open(struct inode *, struct file *);
 extern int nfs_release(struct inode *, struct file *);
 extern int __nfs_revalidate_inode(struct nfs_server *, struct inode *);
+extern void nfs_invalidate_access_cache(struct inode *inode);
 extern int nfs_setattr(struct dentry *, struct iattr *);
 extern void nfs_begin_attr_update(struct inode *);
 extern void nfs_end_attr_update(struct inode *);
