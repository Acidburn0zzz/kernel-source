diff -urp /opt/kernel/linux-2.6.5/drivers/md/linear.c linux-2.6.5/drivers/md/linear.c
--- /opt/kernel/linux-2.6.5/drivers/md/linear.c	2004-04-19 12:41:06.269838881 +0200
+++ linux-2.6.5/drivers/md/linear.c	2004-04-19 12:46:26.508285662 +0200
@@ -47,6 +47,27 @@ static inline dev_info_t *which_dev(mdde
 		return hash->dev0;
 }
 
+static int linear_issue_flush(request_queue_t *q, struct gendisk *disk,
+			      sector_t *error_sector)
+{
+	mddev_t *mddev = q->queuedata;
+	linear_conf_t *conf = mddev_to_conf(mddev);
+	int i, ret = 0;
+
+	for (i=0; i < mddev->raid_disks; i++) {
+		struct block_device *bdev = conf->disks[i].rdev->bdev;
+		request_queue_t *r_queue = bdev_get_queue(bdev);
+
+		if (!r_queue->issue_flush_fn) {
+			ret = -EOPNOTSUPP;
+			break;
+		}
+		ret = r_queue->issue_flush_fn(r_queue, bdev->bd_disk, error_sector);
+		if (ret)
+			break;
+	}
+	return ret;
+}
 
 /**
  *	linear_mergeable_bvec -- tell bio layer if a two requests can be merged
@@ -185,6 +206,7 @@ static int linear_run (mddev_t *mddev)
 		BUG();
 
 	blk_queue_merge_bvec(mddev->queue, linear_mergeable_bvec);
+	mddev->queue->issue_flush_fn = linear_issue_flush;
 	return 0;
 
 out:
diff -urp /opt/kernel/linux-2.6.5/drivers/md/md.c linux-2.6.5/drivers/md/md.c
--- /opt/kernel/linux-2.6.5/drivers/md/md.c	2004-04-19 12:41:06.269838881 +0200
+++ linux-2.6.5/drivers/md/md.c	2004-04-19 12:41:43.297843807 +0200
@@ -160,6 +160,39 @@ static int md_fail_request (request_queu
 	return 0;
 }
 
+int md_flush_mddev(mddev_t *mddev, sector_t *error_sector)
+{
+	struct list_head *tmp;
+	mdk_rdev_t *rdev;
+	int ret = 0;
+
+	/*
+	 * this list iteration is done without any locking in md?!
+	 */
+	ITERATE_RDEV(mddev, rdev, tmp) {
+		request_queue_t *r_queue = bdev_get_queue(rdev->bdev);
+		int err;
+
+		if (!r_queue->unplug_fn)
+			err = -EOPNOTSUPP;
+		else
+			err = r_queue->issue_flush_fn(r_queue, rdev->bdev->bd_disk, error_sector);
+
+		if (!ret)
+			ret = err;
+	}
+
+	return ret;
+}
+
+static int md_flush_all(request_queue_t *q, struct gendisk *disk,
+			 sector_t *error_sector)
+{
+	mddev_t *mddev = q->queuedata;
+
+	return md_flush_mddev(mddev, error_sector);
+}
+
 void md_unplug_mddev(mddev_t *mddev)
 {
 	struct list_head *tmp;
@@ -1671,6 +1704,7 @@ static int do_md_run(mddev_t * mddev)
 	mddev->queue->queuedata = mddev;
 	mddev->queue->make_request_fn = mddev->pers->make_request;
 	mddev->queue->unplug_fn = md_unplug_all;
+	mddev->queue->issue_flush_fn = md_flush_all;
 
 	mddev->changed = 1;
 	return 0;
diff -urp /opt/kernel/linux-2.6.5/drivers/md/multipath.c linux-2.6.5/drivers/md/multipath.c
--- /opt/kernel/linux-2.6.5/drivers/md/multipath.c	2004-04-19 12:41:06.289836724 +0200
+++ linux-2.6.5/drivers/md/multipath.c	2004-04-19 12:46:26.509285554 +0200
@@ -206,6 +206,31 @@ static void multipath_status (struct seq
 	seq_printf (seq, "]");
 }
 
+static int multipath_issue_flush(request_queue_t *q, struct gendisk *disk,
+				 sector_t *error_sector)
+{
+	mddev_t *mddev = q->queuedata;
+	multipath_conf_t *conf = mddev_to_conf(mddev);
+	int i, ret = 0;
+
+	for (i=0; i<mddev->raid_disks; i++) {
+		mdk_rdev_t *rdev = conf->multipaths[i].rdev;
+		if (rdev && !rdev->faulty) {
+			struct block_device *bdev = rdev->bdev;
+			request_queue_t *r_queue = bdev_get_queue(bdev);
+
+			if (!r_queue->issue_flush_fn) {
+				ret = -EOPNOTSUPP;
+				break;
+			}
+
+			ret = r_queue->issue_flush_fn(r_queue, bdev->bd_disk, error_sector);
+			if (ret)
+				break;
+		}
+	}
+	return ret;
+}
 
 /*
  * Careful, this can execute in IRQ contexts as well!
@@ -419,6 +444,8 @@ static int multipath_run (mddev_t *mddev
 	}
 	memset(conf->multipaths, 0, sizeof(struct multipath_info)*mddev->raid_disks);
 
+	mddev->queue->issue_flush_fn = multipath_issue_flush;
+
 	conf->working_disks = 0;
 	ITERATE_RDEV(mddev,rdev,tmp) {
 		disk_idx = rdev->raid_disk;
diff -urp /opt/kernel/linux-2.6.5/drivers/md/raid0.c linux-2.6.5/drivers/md/raid0.c
--- /opt/kernel/linux-2.6.5/drivers/md/raid0.c	2004-04-19 12:41:06.291836508 +0200
+++ linux-2.6.5/drivers/md/raid0.c	2004-04-19 12:46:26.510285446 +0200
@@ -25,6 +25,31 @@
 #define MD_DRIVER
 #define MD_PERSONALITY
 
+static int raid0_issue_flush(request_queue_t *q, struct gendisk *disk,
+			     sector_t *error_sector)
+{
+	mddev_t *mddev = q->queuedata;
+	raid0_conf_t *conf = mddev_to_conf(mddev);
+	mdk_rdev_t **devlist = conf->strip_zone[0].dev;
+	int i, ret = 0;
+
+	for (i=0; i<mddev->raid_disks; i++) {
+		struct block_device *bdev = devlist[i]->bdev;
+		request_queue_t *r_queue = bdev_get_queue(bdev);
+
+		if (!r_queue->issue_flush_fn) {
+			ret = -EOPNOTSUPP;
+			break;
+		}
+
+		ret =r_queue->issue_flush_fn(r_queue, bdev->bd_disk, error_sector);
+		if (ret)
+			break;
+	}
+	return ret;
+}
+
+
 static int create_strip_zones (mddev_t *mddev)
 {
 	int i, c, j;
@@ -202,6 +227,8 @@ static int create_strip_zones (mddev_t *
 			conf->hash_spacing = sz;
 	}
 
+	mddev->queue->issue_flush_fn = raid0_issue_flush;
+
 	printk("raid0: done.\n");
 	return 0;
  abort:
diff -urp /opt/kernel/linux-2.6.5/drivers/md/raid1.c linux-2.6.5/drivers/md/raid1.c
--- /opt/kernel/linux-2.6.5/drivers/md/raid1.c	2004-04-19 12:41:06.290836616 +0200
+++ linux-2.6.5/drivers/md/raid1.c	2004-04-19 12:46:26.511285338 +0200
@@ -443,6 +443,32 @@ rb_out:
 	return new_disk;
 }
 
+static int raid1_issue_flush(request_queue_t *q, struct gendisk *disk,
+			     sector_t *error_sector)
+{
+	mddev_t *mddev = q->queuedata;
+	conf_t *conf = mddev_to_conf(mddev);
+	unsigned long flags;
+	int i, ret = 0;
+
+	spin_lock_irqsave(&conf->device_lock, flags);
+	for (i=0; i<mddev->raid_disks; i++) {
+		mdk_rdev_t *rdev = conf->mirrors[i].rdev;
+		if (rdev && !rdev->faulty) {
+			struct block_device *bdev = rdev->bdev;
+			request_queue_t *r_queue = bdev_get_queue(bdev);
+
+			if (r_queue->issue_flush_fn) {
+				ret = r_queue->issue_flush_fn(r_queue, bdev->bd_disk, error_sector);
+				if (ret)
+					break;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&conf->device_lock, flags);
+	return ret;
+}
+
 /*
  * Throttle resync depth, so that we can both get proper overlapping of
  * requests, but are still able to handle normal requests quickly.
@@ -1105,6 +1131,7 @@ static int run(mddev_t *mddev)
 		goto out_free_conf;
 	}
 
+	mddev->queue->issue_flush_fn = raid1_issue_flush;
 
 	ITERATE_RDEV(mddev, rdev, tmp) {
 		disk_idx = rdev->raid_disk;
diff -urp /opt/kernel/linux-2.6.5/drivers/md/raid5.c linux-2.6.5/drivers/md/raid5.c
--- /opt/kernel/linux-2.6.5/drivers/md/raid5.c	2004-04-19 12:41:06.248841147 +0200
+++ linux-2.6.5/drivers/md/raid5.c	2004-04-19 12:46:26.513285122 +0200
@@ -1308,6 +1308,39 @@ static void raid5_unplug_device(request_
 	spin_unlock_irqrestore(&conf->device_lock, flags);
 }
 
+static int raid5_issue_flush(request_queue_t *q, struct gendisk *disk,
+			     sector_t *error_sector)
+{
+	mddev_t *mddev = q->queuedata;
+	raid5_conf_t *conf = mddev_to_conf(mddev);
+	int i, ret = 0;
+
+	for (i=0; i<mddev->raid_disks; i++) {
+		mdk_rdev_t *rdev = conf->disks[i].rdev;
+		if (rdev && !rdev->faulty) {
+			struct block_device *bdev = rdev->bdev;
+			request_queue_t *r_queue;
+
+			if (!bdev)
+				continue;
+
+			r_queue = bdev_get_queue(bdev);
+			if (!r_queue)
+				continue;
+
+			if (!r_queue->issue_flush_fn) {
+				ret = -EOPNOTSUPP;
+				break;
+			}
+
+			ret = r_queue->issue_flush_fn(r_queue, bdev->bd_disk, error_sector);
+			if (ret)
+				break;
+		}
+	}
+	return ret;
+}
+
 static inline void raid5_plug_device(raid5_conf_t *conf)
 {
 	spin_lock_irq(&conf->device_lock);
@@ -1511,6 +1544,7 @@ static int run (mddev_t *mddev)
 	atomic_set(&conf->preread_active_stripes, 0);
 
 	mddev->queue->unplug_fn = raid5_unplug_device;
+	mddev->queue->issue_flush_fn = raid5_issue_flush;
 
 	PRINTK("raid5: run(%s) called.\n", mdname(mddev));
 
diff -urp /opt/kernel/linux-2.6.5/drivers/md/raid6main.c linux-2.6.5/drivers/md/raid6main.c
--- /opt/kernel/linux-2.6.5/drivers/md/raid6main.c	2004-04-19 12:41:06.239842118 +0200
+++ linux-2.6.5/drivers/md/raid6main.c	2004-04-19 12:46:26.515284907 +0200
@@ -1469,6 +1469,39 @@ static void raid6_unplug_device(request_
 	spin_unlock_irqrestore(&conf->device_lock, flags);
 }
 
+static int raid6_issue_flush(request_queue_t *q, struct gendisk *disk,
+			     sector_t *error_sector)
+{
+	mddev_t *mddev = q->queuedata;
+	raid6_conf_t *conf = mddev_to_conf(mddev);
+	int i, ret = 0;
+
+	for (i=0; i<mddev->raid_disks; i++) {
+		mdk_rdev_t *rdev = conf->disks[i].rdev;
+		if (rdev && !rdev->faulty) {
+			struct block_device *bdev = rdev->bdev;
+			request_queue_t *r_queue;
+
+			if (!bdev)
+				continue;
+
+			r_queue = bdev_get_queue(bdev);
+			if (!r_queue)
+				continue;
+
+			if (!r_queue->issue_flush_fn) {
+				ret = -EOPNOTSUPP;
+				break;
+			}
+
+			ret = r_queue->issue_flush_fn(r_queue, bdev->bd_disk, error_sector);
+			if (ret)
+				break;
+		}
+	}
+	return ret;
+}
+
 static inline void raid6_plug_device(raid6_conf_t *conf)
 {
 	spin_lock_irq(&conf->device_lock);
@@ -1672,6 +1705,7 @@ static int run (mddev_t *mddev)
 	atomic_set(&conf->preread_active_stripes, 0);
 
 	mddev->queue->unplug_fn = raid6_unplug_device;
+	mddev->queue->issue_flush_fn = raid6_issue_flush;
 
 	PRINTK("raid6: run(%s) called.\n", mdname(mddev));
 
