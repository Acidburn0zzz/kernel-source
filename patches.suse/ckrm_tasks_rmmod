BUG 40660 disallows removal of ckrm task module

diff -Naur l1/include/linux/ckrm_tsk.h l2/include/linux/ckrm_tsk.h
--- l1/include/linux/ckrm_tsk.h	2004-05-16 10:55:39.214071104 -0700
+++ l2/include/linux/ckrm_tsk.h	2004-05-16 10:56:57.176219056 -0700
@@ -24,18 +24,11 @@
 
 #include <linux/ckrm_rc.h>
 
-#ifdef CONFIG_CKRM_RES_NUMTASKS
+typedef int (*get_ref_t) (void *, int);
+typedef void (*put_ref_t) (void *);
 
 extern int numtasks_get_ref(void *, int);
-extern int numtasks_get_ref_resid(void *, int, int);
 extern void numtasks_put_ref(void *);
-
-#else
-
-#define numtasks_get_ref(a, b)		1
-#define numtasks_get_ref_resid(a, b, c)		1
-#define numtasks_put_ref(a)
-
-#endif
+extern void ckrm_numtasks_register(get_ref_t, put_ref_t);
 
 #endif // _LINUX_CKRM_RES_H
diff -Naur l1/kernel/ckrm/Makefile l2/kernel/ckrm/Makefile
--- l1/kernel/ckrm/Makefile	2004-05-16 10:31:55.152561360 -0700
+++ l2/kernel/ckrm/Makefile	2004-05-16 10:31:42.071549976 -0700
@@ -3,7 +3,7 @@
 #
 
 ifeq ($(CONFIG_CKRM),y)
-	obj-y = ckrm.o ckrmutils.o 
+	obj-y = ckrm.o ckrmutils.o ckrm_tasks_stub.o
 endif
 
 obj-$(CONFIG_CKRM_TYPE_TASKCLASS) += ckrm_tc.o 
diff -Naur l1/kernel/ckrm/ckrm.c l2/kernel/ckrm/ckrm.c
--- l1/kernel/ckrm/ckrm.c	2004-05-16 10:31:55.167559080 -0700
+++ l2/kernel/ckrm/ckrm.c	2004-05-16 10:31:42.126541616 -0700
@@ -478,7 +478,6 @@
 	 * Free a resource class only if the resource controller has
 	 * registered with core 
 	 */
-
 	if (core->res_class[resid]) {
 		ckrm_res_ctlr_t *rcbs;
 		struct ckrm_classtype *clstype = core->classtype;
@@ -489,10 +488,10 @@
 		if (rcbs->res_free) {
 			(*rcbs->res_free)(core->res_class[resid]);
 			atomic_dec(&clstype->nr_resusers[resid]); // for inc in alloc
-			core->res_class[resid] = NULL;	
 		}
 		atomic_dec(&clstype->nr_resusers[resid]);
 	}
+	core->res_class[resid] = NULL;
 }
 
 
@@ -655,16 +654,26 @@
 ckrm_unregister_res_ctlr(struct ckrm_res_ctlr *rcbs)
 {	
 	struct ckrm_classtype *clstype = rcbs->classtype;
+	struct ckrm_core_class *core = NULL;
 	int resid = rcbs->resid;
 
-	if ((clstype == NULL) || (resid < 0))
+	if ((clstype == NULL) || (resid < 0)) {
 		return -EINVAL;
-	
-	if (atomic_read(&clstype->nr_resusers[resid]))
-		return -EBUSY;
+	}
 	
 	// FIXME: probably need to also call deregistration function
 
+	read_lock(&ckrm_class_lock);
+	// free up this resource from all the classes
+	list_for_each_entry(core, &clstype->classes, clslist) {
+		ckrm_free_res_class(core, resid);
+	}
+	read_unlock(&ckrm_class_lock);
+
+	if (atomic_read(&clstype->nr_resusers[resid])) {
+		return -EBUSY;
+	}
+	
 	spin_lock(&clstype->res_ctlrs_lock);
 	clstype->res_ctlrs[resid] = NULL;
 	clear_bit(resid, &clstype->bit_res_ctlrs);	
diff -Naur l1/kernel/ckrm/ckrm_tasks.c l2/kernel/ckrm/ckrm_tasks.c
--- l1/kernel/ckrm/ckrm_tasks.c	2004-05-16 10:31:55.172558320 -0700
+++ l2/kernel/ckrm/ckrm_tasks.c	2004-05-16 10:34:12.299711824 -0700
@@ -30,6 +30,7 @@
 #include <linux/ckrm.h>
 #include <linux/ckrm_rc.h>
 #include <linux/ckrm_tc.h>
+#include <linux/ckrm_tsk.h>
 
 #define TOTAL_NUM_TASKS (131072) // 128 K
 #define NUMTASKS_DEBUG
@@ -116,8 +117,8 @@
 }
 #endif
 
-int
-numtasks_get_ref(void *arg, int force)
+static int
+numtasks_get_ref_local(void *arg, int force)
 {
 	int rc, resid = numtasks_rcbs.resid;
 	ckrm_numtasks_t *res;
@@ -142,7 +143,7 @@
 			res->limit_failures++;
 			res->tot_limit_failures++;
 		} else if (res->parent != NULL) {
-			if ((rc = numtasks_get_ref(res->parent, force)) == 1) {
+			if ((rc = numtasks_get_ref_local(res->parent, force)) == 1) {
 				atomic_inc(&res->cnt_borrowed);
 				res->borrow_sucesses++;
 				res->tot_borrow_sucesses++;
@@ -177,8 +178,8 @@
 	return rc;
 }
 
-void
-numtasks_put_ref(void *arg)
+static void
+numtasks_put_ref_local(void *arg)
 {
 	int resid = numtasks_rcbs.resid;
 	ckrm_numtasks_t *res;
@@ -194,7 +195,7 @@
 	atomic_dec(&res->cnt_cur_alloc);
 	if (atomic_read(&res->cnt_borrowed) > 0) {
 		atomic_dec(&res->cnt_borrowed);
-		numtasks_put_ref(res->parent);
+		numtasks_put_ref_local(res->parent);
 	}
 	return;
 }
@@ -218,6 +219,7 @@
 			res->cnt_unused =  TOTAL_NUM_TASKS;
 			res->cnt_limit = TOTAL_NUM_TASKS;
 		}
+		try_module_get(THIS_MODULE);
 	} else {
 		printk(KERN_ERR "numtasks_res_alloc: failed GFP_ATOMIC alloc\n");
 	}
@@ -247,7 +249,7 @@
 		printk(KERN_ERR "numtasks_res_free: resource still alloc'd %p\n", res);
 		if ((borrowed = atomic_read(&res->cnt_borrowed)) > 0) {
 			for (i = 0; i < borrowed; i++) {
-				numtasks_put_ref(parres->core);
+				numtasks_put_ref_local(parres->core);
 			}
 		}
 	}
@@ -272,6 +274,7 @@
 
 	spin_unlock(&parres->cnt_lock);
 	kfree(res);
+	module_put(THIS_MODULE);
 	return;
 }
 /*
@@ -452,10 +455,10 @@
 			oldres = ckrm_get_res_class(old_core, numtasks_rcbs.resid,
 					ckrm_numtasks_t);
 		}
-		numtasks_put_ref(oldres->core);
+		numtasks_put_ref_local(oldres->core);
 	}
 	if (newres) {
-		(void) numtasks_get_ref(newres->core, 1);
+		(void) numtasks_get_ref_local(newres->core, 1);
 	}
 }
 
@@ -488,6 +491,11 @@
 	if (resid == -1) {
 		resid = ckrm_register_res_ctlr(clstype,&numtasks_rcbs);
 		printk("........init_ckrm_numtasks_res -> %d\n",resid);
+		if (resid != -1) {
+			ckrm_numtasks_register(numtasks_get_ref_local,
+							numtasks_put_ref_local);
+			numtasks_rcbs.classtype = clstype;
+		}
 	}
 	return 0;
 }	
@@ -495,6 +503,9 @@
 void __exit
 exit_ckrm_numtasks_res(void)
 {
+	if (numtasks_rcbs.resid != -1) {
+		ckrm_numtasks_register(NULL, NULL);
+	}
 	ckrm_unregister_res_ctlr(&numtasks_rcbs);
 	numtasks_rcbs.resid = -1;
 }
@@ -502,8 +513,5 @@
 module_init(init_ckrm_numtasks_res)
 module_exit(exit_ckrm_numtasks_res)
 
-EXPORT_SYMBOL(numtasks_get_ref);
-EXPORT_SYMBOL(numtasks_put_ref);
-
 MODULE_LICENSE("GPL");
 
diff -Naur l1/kernel/ckrm/ckrm_tasks_stub.c l2/kernel/ckrm/ckrm_tasks_stub.c
--- l1/kernel/ckrm/ckrm_tasks_stub.c	1969-12-31 16:00:00.000000000 -0800
+++ l2/kernel/ckrm/ckrm_tasks_stub.c	2004-05-16 10:59:00.279504512 -0700
@@ -0,0 +1,63 @@
+/* ckrm_tasks_stub.c - Stub file for ckrm_tasks modules
+ *
+ * Copyright (C) Chandra Seetharaman,  IBM Corp. 2004
+ * 
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ * 
+ * 16 May 2004: Created
+ * 
+ */
+
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/ckrm_tsk.h>
+
+static spinlock_t stub_lock = SPIN_LOCK_UNLOCKED;
+
+static get_ref_t real_get_ref = NULL;
+static put_ref_t real_put_ref = NULL;
+
+void
+ckrm_numtasks_register(get_ref_t gr, put_ref_t pr)
+{
+	spin_lock(&stub_lock);
+	real_get_ref = gr;
+	real_put_ref = pr;
+	spin_unlock(&stub_lock);
+}
+
+int
+numtasks_get_ref(void *arg, int force)
+{
+	int ret = 1;
+	spin_lock(&stub_lock);
+	if (real_get_ref) {
+		ret = (*real_get_ref) (arg, force);
+	}
+	spin_unlock(&stub_lock);
+	return ret;
+}
+
+void
+numtasks_put_ref(void *arg)
+{
+	spin_lock(&stub_lock);
+	if (real_put_ref) {
+		(*real_put_ref) (arg);
+	}
+	spin_unlock(&stub_lock);
+}
+
+
+EXPORT_SYMBOL(ckrm_numtasks_register);
+EXPORT_SYMBOL(numtasks_get_ref);
+EXPORT_SYMBOL(numtasks_put_ref);
