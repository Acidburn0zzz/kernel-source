From: Olaf Kirch <okir@suse.de>
Subject: Kernel statd patches

This patch implements the kernel statd. Instead of making RPC upcalls
to rpc.statd in user land, the kernel keeps track of monitor information
itself, and runs its own statd to process NOTIFY messages.

Index: linux.merge/fs/Kconfig
===================================================================
--- linux.merge.orig/fs/Kconfig	2005-01-20 17:15:16.000000000 -0500
+++ linux.merge/fs/Kconfig	2005-01-20 17:15:23.000000000 -0500
@@ -1556,6 +1556,10 @@ config ROOT_NFS
 
 config LOCKD
 	tristate
+	select STATD
+
+config STATD
+	bool
 
 config LOCKD_V4
 	bool
Index: linux.merge/fs/buffer.c
===================================================================
--- linux.merge.orig/fs/buffer.c	2005-01-20 16:52:48.000000000 -0500
+++ linux.merge/fs/buffer.c	2005-01-20 17:15:23.000000000 -0500
@@ -183,6 +183,7 @@ int fsync_super(struct super_block *sb)
 
 	return sync_blockdev(sb->s_bdev);
 }
+EXPORT_SYMBOL(fsync_super);
 
 /*
  * Write out and wait upon all dirty data associated with this
Index: linux.merge/fs/lockd/Makefile
===================================================================
--- linux.merge.orig/fs/lockd/Makefile	2005-01-04 16:57:17.000000000 -0500
+++ linux.merge/fs/lockd/Makefile	2005-01-20 17:15:23.000000000 -0500
@@ -7,4 +7,5 @@ obj-$(CONFIG_LOCKD) += lockd.o
 lockd-objs-y := clntlock.o clntproc.o host.o svc.o svclock.o svcshare.o \
 	        svcproc.o svcsubs.o mon.o xdr.o
 lockd-objs-$(CONFIG_LOCKD_V4) += xdr4.o svc4proc.o
+lockd-objs-$(CONFIG_STATD)    += statd.o
 lockd-objs		      := $(lockd-objs-y)
Index: linux.merge/fs/lockd/clntlock.c
===================================================================
--- linux.merge.orig/fs/lockd/clntlock.c	2004-12-17 07:45:59.000000000 -0500
+++ linux.merge/fs/lockd/clntlock.c	2005-01-20 17:15:23.000000000 -0500
@@ -161,7 +161,6 @@ void nlmclnt_mark_reclaim(struct nlm_hos
 static inline
 void nlmclnt_prepare_reclaim(struct nlm_host *host, u32 newstate)
 {
-	host->h_monitored = 0;
 	host->h_nsmstate = newstate;
 	host->h_state++;
 	host->h_nextrebind = 0;
Index: linux.merge/fs/lockd/clntproc.c
===================================================================
--- linux.merge.orig/fs/lockd/clntproc.c	2005-01-04 16:57:18.000000000 -0500
+++ linux.merge/fs/lockd/clntproc.c	2005-01-20 17:15:23.000000000 -0500
@@ -543,7 +543,7 @@ nlmclnt_lock(struct nlm_rqst *req, struc
 	struct nlm_res	*resp = &req->a_res;
 	int		status;
 
-	if (!host->h_monitored && nsm_monitor(host) < 0) {
+	if (nsm_monitor(host) < 0) {
 		printk(KERN_NOTICE "lockd: failed to monitor %s\n",
 					host->h_name);
 		status = -ENOLCK;
Index: linux.merge/fs/lockd/host.c
===================================================================
--- linux.merge.orig/fs/lockd/host.c	2005-01-04 16:57:18.000000000 -0500
+++ linux.merge/fs/lockd/host.c	2005-01-20 17:15:23.000000000 -0500
@@ -32,6 +32,13 @@ static unsigned long		next_gc;
 static int			nrhosts;
 static DECLARE_MUTEX(nlm_host_sema);
 
+/*
+ * Function pointers - will reference either the
+ * "standard" statd functions that do upcalls to user land,
+ * or the kernel statd functions.
+ */
+int				(*nsm_monitor)(struct nlm_host *);
+int				(*nsm_unmonitor)(struct nlm_host *);
 
 static void			nlm_gc_hosts(void);
 
@@ -62,6 +69,7 @@ nlm_lookup_host(int server, struct socka
 					int proto, int version)
 {
 	struct nlm_host	*host, **hp;
+	struct nsm_handle *nsm = NULL;
 	u32		addr;
 	int		hash;
 
@@ -77,6 +85,13 @@ nlm_lookup_host(int server, struct socka
 		nlm_gc_hosts();
 
 	for (hp = &nlm_hosts[hash]; (host = *hp) != 0; hp = &host->h_next) {
+		if (!nlm_cmp_addr(&host->h_addr, sin))
+			continue;
+
+		/* See if we have an NSM handle for this client */
+		if (!nsm && (nsm = host->h_nsmhandle) != 0)
+			atomic_inc(&nsm->sm_count);
+
 		if (host->h_proto != proto)
 			continue;
 		if (host->h_version != version)
@@ -84,22 +99,21 @@ nlm_lookup_host(int server, struct socka
 		if (host->h_server != server)
 			continue;
 
-		if (nlm_cmp_addr(&host->h_addr, sin)) {
-			if (hp != nlm_hosts + hash) {
-				*hp = host->h_next;
-				host->h_next = nlm_hosts[hash];
-				nlm_hosts[hash] = host;
-			}
-			nlm_get_host(host);
-			up(&nlm_host_sema);
-			return host;
+		if (hp != nlm_hosts + hash) {
+			*hp = host->h_next;
+			host->h_next = nlm_hosts[hash];
+			nlm_hosts[hash] = host;
 		}
+		nlm_get_host(host);
+		goto out;
 	}
 
 	/* Ooops, no host found, create it */
 	dprintk("lockd: creating host entry\n");
 
-	if (!(host = (struct nlm_host *) kmalloc(sizeof(*host), GFP_KERNEL)))
+	/* Allocate NLM struct and NSM handle. */
+	if ((!nsm && !(nsm = nsm_alloc(sin)))
+	 || !(host = (struct nlm_host *) kmalloc(sizeof(*host), GFP_KERNEL)))
 		goto nohost;
 	memset(host, 0, sizeof(*host));
 
@@ -119,6 +133,7 @@ nlm_lookup_host(int server, struct socka
 	init_waitqueue_head(&host->h_gracewait);
 	host->h_state      = 0;			/* pseudo NSM state */
 	host->h_nsmstate   = 0;			/* real NSM state */
+	host->h_nsmhandle  = nsm;
 	host->h_server	   = server;
 	host->h_next       = nlm_hosts[hash];
 	nlm_hosts[hash]    = host;
@@ -128,25 +143,33 @@ nlm_lookup_host(int server, struct socka
 	if (++nrhosts > NLM_HOST_MAX)
 		next_gc = 0;
 
-nohost:
+out:
 	up(&nlm_host_sema);
 	return host;
+
+nohost:
+	if (host) {
+		kfree(host);
+		host = NULL;
+	}
+	nsm_release(nsm);
+	goto out;
 }
 
 struct nlm_host *
 nlm_find_client(void)
 {
-	/* find a nlm_host for a client for which h_killed == 0.
-	 * and return it
+	/* Find the next NLM client host and remove it from the
+	 * list. The caller is supposed to release all resources
+	 * held by this client, and release the nlm_host afterwards.
 	 */
 	int hash;
 	down(&nlm_host_sema);
 	for (hash = 0 ; hash < NLM_HOST_NRHASH; hash++) {
 		struct nlm_host *host, **hp;
 		for (hp = &nlm_hosts[hash]; (host = *hp) != 0; hp = &host->h_next) {
-			if (host->h_server &&
-			    host->h_killed == 0) {
-				nlm_get_host(host);
+			if (host->h_server) {
+			    	*hp = host->h_next;
 				up(&nlm_host_sema);
 				return host;
 			}
@@ -252,6 +275,59 @@ void nlm_release_host(struct nlm_host *h
 }
 
 /*
+ * Given an IP address, initiate recovery and ditch all locks.
+ */
+void
+nlm_host_rebooted(struct sockaddr_in *sin, u32 new_state)
+{
+	struct nlm_host	*host, **hp;
+	int		hash;
+
+	dprintk("lockd: nlm_host_rebooted(%u.%u.%u.%u)\n",
+			NIPQUAD(sin->sin_addr));
+
+	hash = NLM_ADDRHASH(sin->sin_addr.s_addr);
+
+	/* Lock hash table */
+	down(&nlm_host_sema);
+	for (hp = &nlm_hosts[hash]; (host = *hp); hp = &host->h_next) {
+		if (nlm_cmp_addr(&host->h_addr, sin)) {
+			if (host->h_nsmhandle)
+				host->h_nsmhandle->sm_monitored = 0;
+			host->h_rebooted = 1;
+		}
+	}
+
+again:
+	for (hp = &nlm_hosts[hash]; (host = *hp); hp = &host->h_next) {
+		if (nlm_cmp_addr(&host->h_addr, sin) && host->h_rebooted) {
+			host->h_rebooted = 0;
+			atomic_inc(&host->h_count);
+			up(&nlm_host_sema);
+
+			/* If we're server for this guy, just ditch
+			 * all the locks he held.
+			 * If he's the server, initiate lock recovery.
+			 */
+			if (host->h_server) {
+				nlmsvc_free_host_resources(host);
+			} else {
+				nlmclnt_recovery(host, new_state);
+			}
+
+			down(&nlm_host_sema);
+			nlm_release_host(host);
+
+			/* Host table may have changed in the meanwhile,
+			 * start over */
+			goto again;
+		}
+	}
+
+	up(&nlm_host_sema);
+}
+
+/*
  * Shut down the hosts module.
  * Note that this routine is called only at server shutdown time.
  */
@@ -323,9 +399,12 @@ nlm_gc_hosts(void)
 			}
 			dprintk("lockd: delete host %s\n", host->h_name);
 			*q = host->h_next;
-			/* Don't unmonitor hosts that have been invalidated */
-			if (host->h_monitored && !host->h_killed)
-				nsm_unmonitor(host);
+
+			/* Release the NSM handle. Unmonitor unless
+			 * host was invalidated (i.e. lockd restarted)
+			 */
+			nsm_unmonitor(host);
+
 			if ((clnt = host->h_rpcclnt) != NULL) {
 				if (atomic_read(&clnt->cl_users)) {
 					printk(KERN_WARNING
@@ -344,3 +423,32 @@ nlm_gc_hosts(void)
 	next_gc = jiffies + NLM_HOST_COLLECT;
 }
 
+/*
+ * Allocate an NSM handle
+ */
+struct nsm_handle *
+nsm_alloc(struct sockaddr_in *sin)
+{
+	struct nsm_handle *nsm;
+
+	nsm = (struct nsm_handle *) kmalloc(sizeof(*nsm), GFP_KERNEL);
+	if (nsm == NULL)
+		return NULL;
+
+	memset(nsm, 0, sizeof(*nsm));
+	memcpy(&nsm->sm_addr, sin, sizeof(nsm->sm_addr));
+	atomic_set(&nsm->sm_count, 1);
+
+	return nsm;
+}
+
+/*
+ * Release an NSM handle
+ */
+void
+nsm_release(struct nsm_handle *nsm)
+{
+	if (nsm && atomic_dec_and_test(&nsm->sm_count))
+		kfree(nsm);
+}
+
Index: linux.merge/fs/lockd/mon.c
===================================================================
--- linux.merge.orig/fs/lockd/mon.c	2005-01-20 16:52:49.000000000 -0500
+++ linux.merge/fs/lockd/mon.c	2005-01-20 17:16:43.000000000 -0500
@@ -3,6 +3,10 @@
  *
  * The kernel statd client.
  *
+ * When using the kernel statd implementation, none of the
+ * stuff inside this file is used. 
+ * Instead look at statd.c
+ *
  * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>
  */
 
@@ -14,19 +18,32 @@
 #include <linux/lockd/lockd.h>
 #include <linux/lockd/sm_inter.h>
 
-
 #define NLMDBG_FACILITY		NLMDBG_MONITOR
 
 static struct rpc_clnt *	nsm_create(void);
+static int			__nsm_monitor(struct nlm_host *host);
+static int			__nsm_unmonitor(struct nlm_host *host);
 
 static struct rpc_program	nsm_program;
 
 /*
- * Local NSM state
+ * Local NSM state.
+ * This should really be initialized somehow.
  */
 u32				nsm_local_state;
 
 /*
+ * Initialize lockd for RPC statd upcalls
+ */
+int
+nsm_statd_upcalls_init()
+{
+	nsm_monitor = __nsm_monitor;
+	nsm_unmonitor = __nsm_unmonitor;
+	return 0;
+}
+
+/*
  * Common procedure for SM_MON/SM_UNMON calls
  */
 static int
@@ -62,39 +79,53 @@ nsm_mon_unmon(struct nlm_host *host, u32
 /*
  * Set up monitoring of a remote host
  */
-int
-nsm_monitor(struct nlm_host *host)
+static int
+__nsm_monitor(struct nlm_host *host)
 {
+	struct nsm_handle *nsm;
 	struct nsm_res	res;
 	int		status;
 
 	dprintk("lockd: nsm_monitor(%s)\n", host->h_name);
+	if ((nsm = host->h_nsmhandle) == NULL)
+		BUG();
 
-	status = nsm_mon_unmon(host, SM_MON, &res);
+	if (nsm->sm_monitored)
+		return 0;
 
+	status = nsm_mon_unmon(host, SM_MON, &res);
 	if (status < 0 || res.status != 0)
 		printk(KERN_NOTICE "lockd: cannot monitor %s\n", host->h_name);
 	else
-		host->h_monitored = 1;
+		nsm->sm_monitored = 1;
 	return status;
 }
 
 /*
  * Cease to monitor remote host
  */
-int
-nsm_unmonitor(struct nlm_host *host)
+static int
+__nsm_unmonitor(struct nlm_host *host)
 {
+	struct nsm_handle *nsm;
 	struct nsm_res	res;
-	int		status;
+	int		status = 0;
 
-	dprintk("lockd: nsm_unmonitor(%s)\n", host->h_name);
+	nsm = host->h_nsmhandle;
+	host->h_nsmhandle = NULL;
 
-	status = nsm_mon_unmon(host, SM_UNMON, &res);
-	if (status < 0)
-		printk(KERN_NOTICE "lockd: cannot unmonitor %s\n", host->h_name);
-	else
-		host->h_monitored = 0;
+	if (nsm && atomic_read(&nsm->sm_count) == 1
+	 && nsm->sm_monitored && !nsm->sm_sticky) {
+		dprintk("lockd: nsm_unmonitor(%s)\n", host->h_name);
+		status = nsm_mon_unmon(host, SM_UNMON, &res);
+		if (status < 0) {
+			printk(KERN_NOTICE "lockd: cannot unmonitor %s\n",
+				       	host->h_name);
+		} else {
+			nsm->sm_monitored = 0;
+		}
+	}
+	nsm_release(nsm);
 	return status;
 }
 
Index: linux.merge/fs/lockd/statd.c
===================================================================
--- linux.merge.orig/fs/lockd/statd.c	2004-04-06 09:27:52.000000000 -0400
+++ linux.merge/fs/lockd/statd.c	2005-01-20 17:15:23.000000000 -0500
@@ -0,0 +1,379 @@
+/*
+ * linux/fs/lockd/nsmproc.c
+ *
+ * Kernel-based status monitor. This is an alternative to
+ * the code in mon.c.
+ *
+ * When asked to monitor a host, we add it to /var/lib/nsm/sm
+ * ourselves, and that's it. In order to catch SM_NOTIFY calls
+ * we implement a minimal statd.
+ *
+ * Minimal user space requirements for this implementation:
+ *  /var/lib/nfs/state
+ *	must exist, and must contain the NSM state as a 32bit
+ *	binary counter.
+ * /var/lib/nfs/sm
+ *	must exist
+ *
+ * Copyright (C) 2004, Olaf Kirch <okir@suse.de>
+ */
+
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/slab.h>
+#include <linux/in.h>
+#include <linux/sunrpc/svc.h>
+#include <linux/sunrpc/clnt.h>
+#include <linux/nfsd/nfsd.h>
+#include <linux/lockd/lockd.h>
+#include <linux/lockd/share.h>
+#include <linux/lockd/sm_inter.h>
+#include <linux/file.h>
+#include <linux/namei.h>
+#include <asm/uaccess.h>
+#include <linux/buffer_head.h>
+
+
+/* XXX make this a module parameter? */
+#define NSM_BASE_PATH		"/var/lib/nfs"
+#define NSM_SM_PATH		NSM_BASE_PATH "/sm"
+#define NSM_STATE_PATH		NSM_BASE_PATH "/state"
+
+#define NLMDBG_FACILITY		NLMDBG_CLIENT
+
+static int	__nsm_monitor(struct nlm_host *host);
+static int	__nsm_unmonitor(struct nlm_host *host);
+
+/*
+ * Initialize local NSM state variable
+ */
+int
+nsm_kernel_statd_init(void)
+{
+	struct file	*filp;
+	char		buffer[32];
+	mm_segment_t	fs;
+	int		res;
+
+	dprintk("lockd: nsm_init()\n");
+	filp = filp_open(NSM_STATE_PATH, O_RDONLY, 0444);
+	if (IS_ERR(filp)) {
+		res = PTR_ERR(filp);
+		printk(KERN_NOTICE "lockd: failed to open %s: err=%d\n",
+				NSM_STATE_PATH, res);
+		return res;
+	}
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	res = vfs_read(filp, buffer, sizeof(buffer), &filp->f_pos);
+	set_fs(fs);
+	filp_close(filp, NULL);
+
+	if (res < 0)
+		return res;
+	if (res == 4)
+		nsm_local_state = *(u32 *) buffer;
+	else
+		nsm_local_state = simple_strtol(buffer, NULL, 10);
+
+	nsm_monitor = __nsm_monitor;
+	nsm_unmonitor = __nsm_unmonitor;
+	return 0;
+}
+
+/*
+ * Build the path name for this lockd peer.
+ *
+ * We keep it extremely simple. Since we can have more
+ * than one nlm_host object peer (depending on whether
+ * it's server or client, and what proto/version of NLM
+ * we use to communicate), we cannot create a file named
+ * $IPADDR and remove it when the nlm_host is unmonitored.
+ * Besides, unlink() is tricky (there's no kernel_syscall
+ * for it), so we just create the file and leave it.
+ *
+ * When we reboot, the notifier should sort the IPs by
+ * descending mtime so that the most recent hosts get
+ * notified first.
+ */
+static char *
+nsm_filename(struct in_addr addr)
+{
+	char		*name;
+
+	name = (char *) __get_free_page(GFP_KERNEL);
+	if (name == NULL)
+		return NULL;
+
+	/* FIXME IPV6 */
+	snprintf(name, PAGE_SIZE, "%s/%u.%u.%u.%u",
+			NSM_SM_PATH, NIPQUAD(addr));
+	return name;
+}
+
+/*
+ * Create the NSM monitor file
+ */
+static int
+nsm_create(struct in_addr addr)
+{
+	struct file	*filp;
+	char		*name;
+	int		res = 0;
+
+	if (!(name = nsm_filename(addr)))
+		return -ENOMEM;
+
+	dprintk("lockd: creating statd monitor file %s\n", name);
+	filp = filp_open(name, O_CREAT|O_SYNC|O_RDWR, 0644);
+	if (IS_ERR(filp)) {
+		res = PTR_ERR(filp);
+		printk(KERN_NOTICE
+			"lockd/statd: failed to create %s: err=%d\n",
+			name, res);
+	} else {
+		fsync_super(filp->f_dentry->d_inode->i_sb);
+		filp_close(filp, NULL);
+	}
+
+	free_page((long) name);
+	return res;
+}
+
+static int
+nsm_unlink(struct in_addr addr)
+{
+	struct nameidata nd;
+	struct inode	*inode = NULL;
+	struct dentry	*dentry;
+	char		*name;
+	int		res = 0;
+
+	if (!(name = nsm_filename(addr)))
+		return -ENOMEM;
+
+	if ((res = path_lookup(name, LOOKUP_PARENT, &nd)) != 0)
+		goto exit;
+
+	if (nd.last_type == LAST_NORM && !nd.last.name[nd.last.len]) {
+		down(&nd.dentry->d_inode->i_sem);
+
+		dentry = lookup_hash(&nd.last, nd.dentry);
+		if (!IS_ERR(dentry)) {
+			if ((inode = dentry->d_inode) != NULL)
+				atomic_inc(&inode->i_count);
+			res = vfs_unlink(nd.dentry->d_inode, dentry);
+			dput(dentry);
+		} else {
+			res = PTR_ERR(dentry);
+		}
+		up(&nd.dentry->d_inode->i_sem);
+	} else {
+		res = -EISDIR;
+	}
+	path_release(&nd);
+
+exit:
+	if (res < 0) {
+		printk(KERN_NOTICE
+			"lockd/statd: failed to unlink %s: err=%d\n",
+			name, res);
+	}
+
+	free_page((long) name);
+	if (inode)
+		iput(inode);
+	return res;
+}
+
+/*
+ * Call nsm_create/nsm_unlink with CAP_DAC_OVERRIDE
+ */
+static int
+with_privilege(int (*func)(struct in_addr), struct sockaddr_in *sin)
+{
+	kernel_cap_t	cap = current->cap_effective;
+	int		res = 0, mask;
+
+	/* If we're unprivileged, a call to capable() will set the
+	 * SUPERPRIV flag */
+	mask = ~(current->flags) & PF_SUPERPRIV;
+
+	/* Raise capability to that we're able to create/unlink the file */
+	cap_raise(current->cap_effective, CAP_DAC_OVERRIDE);
+
+	res = func(sin->sin_addr);
+
+	/* drop privileges */
+	current->cap_effective = cap;
+
+	/* Clear PF_SUPERPRIV unless it was set to begin with */
+	current->flags &= ~mask;
+
+	return res;
+}
+
+/*
+ * Set up monitoring of a remote host
+ * Note we hold the semaphore for the host table while
+ * we're here.
+ */
+static int
+__nsm_monitor(struct nlm_host *host)
+{
+	struct nsm_handle *nsm;
+	int		res = 0;
+
+	dprintk("lockd: nsm_monitor(%s)\n", host->h_name);
+	if ((nsm = host->h_nsmhandle) == NULL)
+		BUG();
+
+	res = with_privilege(nsm_create, &nsm->sm_addr);
+	if (res >= 0)
+		nsm->sm_monitored = 1;
+	return res;
+}
+
+/*
+ * Cease to monitor remote host
+ * Code stolen from sys_unlink.
+ */
+static int
+__nsm_unmonitor(struct nlm_host *host)
+{
+	struct nsm_handle *nsm;
+	int res = 0;
+
+	nsm = host->h_nsmhandle;
+	host->h_nsmhandle = NULL;
+
+	/* If the host was invalidated due to lockd restart/shutdown,
+	 * don't unmonitor it.
+	 * (Strictly speaking, we would have to keep the SM file
+	 * until the next reboot. The only way to achieve that
+	 * would be to link the monitor file to sm.bak now.)
+	 */
+	if (nsm && atomic_read(&nsm->sm_count) == 1
+	 && nsm->sm_monitored && !nsm->sm_sticky) {
+		dprintk("lockd: nsm_unmonitor(%s)\n", host->h_name);
+
+		res = with_privilege(nsm_unlink, &host->h_addr);
+	}
+
+	nsm_release(nsm);
+	return res;
+}
+
+/*
+ * NSM server implementation starts here
+ */
+
+/*
+ * NULL: Test for presence of service
+ */
+static int
+nsmsvc_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)
+{
+	dprintk("statd: NULL          called\n");
+	return rpc_success;
+}
+
+/*
+ * NOTIFY: receive notification that remote host rebooted
+ */
+static int
+nsmsvc_proc_notify(struct svc_rqst *rqstp, struct nsm_args *argp,
+				           struct nsm_res  *resp)
+{
+	struct sockaddr_in	saddr = rqstp->rq_addr;
+
+	dprintk("statd: NOTIFY        called\n");
+
+	/* FIXME - shouldn't we walk all nsm handles and compare
+	 * the mon_id instead of just using the address? */
+	nlm_host_rebooted(&saddr, argp->state);
+	return rpc_success;
+}
+
+/*
+ * All other operations: return failure
+ */
+static int
+nsmsvc_proc_fail(struct svc_rqst *rqstp, struct nsm_args *argp,
+				         struct nsm_res  *resp)
+{
+	dprintk("statd: proc %u        called\n", rqstp->rq_proc);
+	resp->status = 0;
+	resp->state = -1;
+	return rpc_success;
+}
+
+/*
+ * NSM XDR routines
+ */
+static int
+nsmsvc_decode_void(struct svc_rqst *rqstp, u32 *p, void *dummy)
+{
+	return xdr_argsize_check(rqstp, p);
+}
+
+static int
+nsmsvc_encode_void(struct svc_rqst *rqstp, u32 *p, void *dummy)
+{
+	return xdr_ressize_check(rqstp, p);
+}
+
+static int
+nsmsvc_decode_stat_chge(struct svc_rqst *rqstp, u32 *p, struct nsm_args *argp)
+{
+	char	*mon_name;
+	__u32	mon_name_len;
+
+	/* Skip over the client's mon_name */
+	p = xdr_decode_string_inplace(p, &mon_name, &mon_name_len, SM_MAXSTRLEN);
+	if (p == NULL)
+		return 0;
+
+	argp->state = ntohl(*p++);
+	return xdr_argsize_check(rqstp, p);
+}
+
+static int
+nsmsvc_encode_res(struct svc_rqst *rqstp, u32 *p, struct nsm_res *resp)
+{
+	*p++ = resp->status;
+	return xdr_ressize_check(rqstp, p);
+}
+
+static int
+nsmsvc_encode_stat_res(struct svc_rqst *rqstp, u32 *p, struct nsm_res *resp)
+{
+	*p++ = resp->status;
+	*p++ = resp->state;
+	return xdr_ressize_check(rqstp, p);
+}
+
+struct nsm_void			{ int dummy; };
+
+#define PROC(name, xargt, xrest, argt, rest, respsize)	\
+ { .pc_func	= (svc_procfunc) nsmsvc_proc_##name,	\
+   .pc_decode	= (kxdrproc_t) nsmsvc_decode_##xargt,	\
+   .pc_encode	= (kxdrproc_t) nsmsvc_encode_##xrest,	\
+   .pc_release	= NULL,					\
+   .pc_argsize	= sizeof(struct nsm_##argt),		\
+   .pc_ressize	= sizeof(struct nsm_##rest),		\
+   .pc_xdrressize = respsize,				\
+ }
+
+struct svc_procedure		nsmsvc_procedures[] = {
+  PROC(null,		void,		void,		void,	void, 1),
+  PROC(fail,		void,		stat_res,	void,	res, 2),
+  PROC(fail,		void,		stat_res,	void,	res, 2),
+  PROC(fail,		void,		res,		void,	res, 1),
+  PROC(fail,		void,		res,		void,	res, 1),
+  PROC(fail,		void,		res,		void,	res, 1),
+  PROC(notify,		stat_chge,	void,		args,	void, 1)
+};
Index: linux.merge/fs/lockd/svc.c
===================================================================
--- linux.merge.orig/fs/lockd/svc.c	2005-01-20 16:52:49.000000000 -0500
+++ linux.merge/fs/lockd/svc.c	2005-01-20 17:16:48.000000000 -0500
@@ -32,6 +32,7 @@
 #include <linux/sunrpc/svc.h>
 #include <linux/sunrpc/svcsock.h>
 #include <linux/lockd/lockd.h>
+#include <linux/lockd/sm_inter.h>
 #include <linux/nfs.h>
 
 #define NLMDBG_FACILITY		NLMDBG_SVC
@@ -39,6 +40,7 @@
 #define ALLOWED_SIGS		(sigmask(SIGKILL))
 
 static struct svc_program	nlmsvc_program;
+extern struct svc_program	nsmsvc_program;
 
 struct nlmsvc_binding *		nlmsvc_ops;
 EXPORT_SYMBOL(nlmsvc_ops);
@@ -59,6 +61,7 @@ static DECLARE_WAIT_QUEUE_HEAD(lockd_exi
 static unsigned long		nlm_grace_period;
 static unsigned long		nlm_timeout = LOCKD_DFLT_TIMEO;
 static int			nlm_udpport, nlm_tcpport;
+static int			nlm_use_kstatd = 1;
 
 /*
  * Constants needed for the sysctl interface.
@@ -116,13 +119,25 @@ lockd(struct svc_rqst *rqstp)
 
 	daemonize("lockd");
 
+	/* Set up statd */
+#ifdef CONFIG_STATD
+	if (!nlm_use_kstatd || nsm_kernel_statd_init() < 0)
+		nsm_statd_upcalls_init();
+#else
+	nsm_statd_upcalls_init();
+#endif
+
 	/* Process request with signals blocked, but allow SIGKILL.  */
 	allow_signal(SIGKILL);
 
 	/* kick rpciod */
 	rpciod_up();
 
+#ifndef CONFIG_STATD
 	dprintk("NFS locking service started (ver " LOCKD_VERSION ").\n");
+#else
+	dprintk("NFS lockd/statd started (ver " LOCKD_VERSION ").\n");
+#endif
 
 	if (!nlm_timeout)
 		nlm_timeout = LOCKD_DFLT_TIMEO;
@@ -210,6 +225,7 @@ int
 lockd_up(void)
 {
 	static int		warned;
+	struct svc_program *	prog;
 	struct svc_serv *	serv;
 	int			error = 0;
 
@@ -233,8 +249,14 @@ lockd_up(void)
 		printk(KERN_WARNING
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
+	/* Register NLM program and possibly NSM (if using kstatd) */
 	error = -ENOMEM;
-	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE);
+	prog = &nlmsvc_program;
+#ifdef CONFIG_STATD
+	if (nlm_use_kstatd)
+		prog = &nsmsvc_program;
+#endif
+	serv = svc_create(prog, LOCKD_BUFSIZE);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		goto out;
@@ -365,6 +387,16 @@ static ctl_table nlm_sysctls[] = {
 		.extra1		= (int *) &nlm_port_min,
 		.extra2		= (int *) &nlm_port_max,
 	},
+#ifdef CONFIG_STATD
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nlm_use_kstatd",
+		.data		= &nlm_use_kstatd,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
 	{ .ctl_name = 0 }
 };
 
@@ -484,3 +516,32 @@ static struct svc_program	nlmsvc_program
 	.pg_class		= "nfsd",		/* share authentication with nfsd */
 	.pg_stats		= &nlmsvc_stats,	/* stats table */
 };
+
+#ifdef CONFIG_STATD
+/*
+ * Define NSM program and procedures
+ */
+static struct svc_version	nsmsvc_version1 = {
+		.vs_vers	= 1,
+		.vs_nproc	= 7,
+		.vs_proc	= nsmsvc_procedures,
+		.vs_xdrsize	= SMSVC_XDRSIZE,
+};
+static struct svc_version *	nsmsvc_version[] = {
+	[1] = &nsmsvc_version1,
+};
+
+static struct svc_stat		nsmsvc_stats;
+
+#define SM_NRVERS	(sizeof(nsmsvc_version)/sizeof(nsmsvc_version[0]))
+struct svc_program	nsmsvc_program = {
+	.pg_next	= &nlmsvc_program,
+	.pg_prog	= SM_PROGRAM,		/* program number */
+	.pg_nvers	= SM_NRVERS,		/* number of entries in nlmsvc_version */
+	.pg_vers	= nsmsvc_version,	/* version table */
+	.pg_name	= "statd",		/* service name */
+	.pg_class	= "nfsd",		/* share authentication with nfsd */
+	.pg_stats	= &nsmsvc_stats,	/* stats table */
+};
+#endif
+
Index: linux.merge/fs/lockd/svc4proc.c
===================================================================
--- linux.merge.orig/fs/lockd/svc4proc.c	2005-01-04 16:57:18.000000000 -0500
+++ linux.merge/fs/lockd/svc4proc.c	2005-01-20 17:15:23.000000000 -0500
@@ -42,7 +42,7 @@ nlm4svc_retrieve_args(struct svc_rqst *r
 
 	/* Obtain host handle */
 	if (!(host = nlmsvc_lookup_host(rqstp))
-	 || (argp->monitor && !host->h_monitored && nsm_monitor(host) < 0))
+	 || (argp->monitor && nsm_monitor(host) < 0))
 		goto no_locks;
 	*hostp = host;
 
Index: linux.merge/fs/lockd/svcproc.c
===================================================================
--- linux.merge.orig/fs/lockd/svcproc.c	2005-01-04 16:57:18.000000000 -0500
+++ linux.merge/fs/lockd/svcproc.c	2005-01-20 17:15:23.000000000 -0500
@@ -71,7 +71,7 @@ nlmsvc_retrieve_args(struct svc_rqst *rq
 
 	/* Obtain host handle */
 	if (!(host = nlmsvc_lookup_host(rqstp))
-	 || (argp->monitor && !host->h_monitored && nsm_monitor(host) < 0))
+	 || (argp->monitor && nsm_monitor(host) < 0))
 		goto no_locks;
 	*hostp = host;
 
Index: linux.merge/fs/lockd/svcsubs.c
===================================================================
--- linux.merge.orig/fs/lockd/svcsubs.c	2004-12-17 07:45:59.000000000 -0500
+++ linux.merge/fs/lockd/svcsubs.c	2005-01-20 17:15:23.000000000 -0500
@@ -303,7 +303,16 @@ nlmsvc_invalidate_all(void)
 	while ((host = nlm_find_client()) != NULL) {
 		nlmsvc_free_host_resources(host);
 		host->h_expires = 0;
-		host->h_killed = 1;
+		/* Do not unmonitor the host */
+		if (host->h_nsmhandle)
+			host->h_nsmhandle->sm_sticky = 1;
+		if (atomic_read(&host->h_count) != 1) {
+			/* Whatever is holding references to this host,
+			 * it seems likely we're going to leak memory
+			 * or worse */
+			printk(KERN_WARNING "lockd: host still in use "
+				"after nlmsvc_free_host_resources!");
+		}
 		nlm_release_host(host);
 	}
 }
Index: linux.merge/include/linux/lockd/lockd.h
===================================================================
--- linux.merge.orig/include/linux/lockd/lockd.h	2004-12-17 07:46:06.000000000 -0500
+++ linux.merge/include/linux/lockd/lockd.h	2005-01-20 17:15:23.000000000 -0500
@@ -47,8 +47,7 @@ struct nlm_host {
 	unsigned short		h_reclaiming : 1,
 				h_server     : 1, /* server side, not client side */
 				h_inuse      : 1,
-				h_killed     : 1,
-				h_monitored  : 1;
+				h_rebooted   : 1;
 	wait_queue_head_t	h_gracewait;	/* wait while reclaiming */
 	u32			h_state;	/* pseudo-state counter */
 	u32			h_nsmstate;	/* true remote NSM state */
@@ -59,6 +58,17 @@ struct nlm_host {
 	unsigned long		h_expires;	/* eligible for GC */
 	struct list_head	h_lockowners;	/* Lockowners for the client */
 	spinlock_t		h_lock;
+	struct nsm_handle *	h_nsmhandle;	/* for kernel statd */
+};
+
+/*
+ * NSM handle - used to track status of monitored hosts
+ */
+struct nsm_handle {
+	atomic_t		sm_count;
+	struct sockaddr_in	sm_addr;
+	unsigned int		sm_monitored : 1,
+				sm_sticky : 1;	/* don't unmonitor */
 };
 
 /*
@@ -136,6 +146,9 @@ extern struct svc_procedure	nlmsvc_proce
 #ifdef CONFIG_LOCKD_V4
 extern struct svc_procedure	nlmsvc_procedures4[];
 #endif
+#ifdef CONFIG_STATD
+extern struct svc_procedure	nsmsvc_procedures[];
+#endif
 extern int			nlmsvc_grace_period;
 extern unsigned long		nlmsvc_timeout;
 
@@ -165,7 +178,9 @@ struct nlm_host * nlm_get_host(struct nl
 void		  nlm_release_host(struct nlm_host *);
 void		  nlm_shutdown_hosts(void);
 extern struct nlm_host *nlm_find_client(void);
-
+extern void	  nlm_host_rebooted(struct sockaddr_in *, u32);
+struct nsm_handle *nsm_alloc(struct sockaddr_in *);
+void		  nsm_release(struct nsm_handle *);
 
 /*
  * Server-side lock handling
Index: linux.merge/include/linux/lockd/sm_inter.h
===================================================================
--- linux.merge.orig/include/linux/lockd/sm_inter.h	2004-01-09 01:59:42.000000000 -0500
+++ linux.merge/include/linux/lockd/sm_inter.h	2005-01-20 17:15:23.000000000 -0500
@@ -19,6 +19,7 @@
 #define SM_NOTIFY	6
 
 #define SM_MAXSTRLEN	1024
+#define SMSVC_XDRSIZE	sizeof(struct nsm_args)
 
 /*
  * Arguments for all calls to statd
@@ -29,6 +30,7 @@ struct nsm_args {
 	u32		vers;
 	u32		proc;
 	u32		proto;		/* protocol (udp/tcp) plus server/client flag */
+	u32		state;		/* in NOTIFY calls */
 };
 
 /*
@@ -39,8 +41,12 @@ struct nsm_res {
 	u32		state;
 };
 
-int		nsm_monitor(struct nlm_host *);
-int		nsm_unmonitor(struct nlm_host *);
+extern int	nsm_statd_upcalls_init(void);
+#ifdef CONFIG_STATD
+extern int	nsm_kernel_statd_init(void);
+#endif
+extern int	(*nsm_monitor)(struct nlm_host *);
+extern int	(*nsm_unmonitor)(struct nlm_host *);
 extern u32	nsm_local_state;
 
 #endif /* LINUX_LOCKD_SM_INTER_H */
Index: linux.merge/net/sunrpc/svc.c
===================================================================
--- linux.merge.orig/net/sunrpc/svc.c	2005-01-20 17:15:16.000000000 -0500
+++ linux.merge/net/sunrpc/svc.c	2005-01-20 17:15:23.000000000 -0500
@@ -223,22 +223,27 @@ svc_register(struct svc_serv *serv, int 
 
 	progp = serv->sv_program;
 
-	dprintk("RPC: svc_register(%s, %s, %d)\n",
-		progp->pg_name, proto == IPPROTO_UDP? "udp" : "tcp", port);
-
 	if (!port)
 		clear_thread_flag(TIF_SIGPENDING);
 
-	for (i = 0; i < progp->pg_nvers; i++) {
-		if (progp->pg_vers[i] == NULL)
-			continue;
-		error = rpc_register(progp->pg_prog, i, proto, port, &dummy);
-		if (error < 0)
-			break;
-		if (port && !dummy) {
-			error = -EACCES;
-			break;
+	while (progp) {
+		dprintk("RPC: svc_register(%s, %s, %d)\n",
+			progp->pg_name,
+			proto == IPPROTO_UDP?  "udp" : "tcp",
+			port);
+
+		for (i = 0; i < progp->pg_nvers; i++) {
+			if (progp->pg_vers[i] == NULL)
+				continue;
+			error = rpc_register(progp->pg_prog, i, proto, port, &dummy);
+			if (error < 0)
+				break;
+			if (port && !dummy) {
+				error = -EACCES;
+				break;
+			}
 		}
+		progp = progp->pg_next;
 	}
 
 	if (!port) {
