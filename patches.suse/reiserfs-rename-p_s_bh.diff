From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH 26/40] reiserfs: rename p_s_bh to bh

 This patch is a simple s/p_s_bh/bh/g to the reiserfs code. This is the second
 in a series of patches to rip out some of the awful variable naming in
 reiserfs.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

---

 fs/reiserfs/fix_node.c      |   88 ++++++++++++++++++++++----------------------
 fs/reiserfs/stree.c         |   62 +++++++++++++++----------------
 include/linux/reiserfs_fs.h |   36 +++++++++---------
 3 files changed, 93 insertions(+), 93 deletions(-)

--- a/fs/reiserfs/fix_node.c	2007-06-11 14:49:39.000000000 -0400
+++ b/fs/reiserfs/fix_node.c	2007-06-11 14:50:03.000000000 -0400
@@ -1885,7 +1885,7 @@ static int check_balance(int mode,
 /* Check whether parent at the path is the really parent of the current node.*/
 static int get_direct_parent(struct tree_balance *p_s_tb, int n_h)
 {
-	struct buffer_head *p_s_bh;
+	struct buffer_head *bh;
 	struct treepath *p_s_path = p_s_tb->tb_path;
 	int n_position,
 	    n_path_offset = PATH_H_PATH_OFFSET(p_s_tb->tb_path, n_h);
@@ -1907,21 +1907,21 @@ static int get_direct_parent(struct tree
 	}
 
 	if (!B_IS_IN_TREE
-	    (p_s_bh = PATH_OFFSET_PBUFFER(p_s_path, n_path_offset - 1)))
+	    (bh = PATH_OFFSET_PBUFFER(p_s_path, n_path_offset - 1)))
 		return REPEAT_SEARCH;	/* Parent in the path is not in the tree. */
 
 	if ((n_position =
 	     PATH_OFFSET_POSITION(p_s_path,
-				  n_path_offset - 1)) > B_NR_ITEMS(p_s_bh))
+				  n_path_offset - 1)) > B_NR_ITEMS(bh))
 		return REPEAT_SEARCH;
 
-	if (B_N_CHILD_NUM(p_s_bh, n_position) !=
+	if (B_N_CHILD_NUM(bh, n_position) !=
 	    PATH_OFFSET_PBUFFER(p_s_path, n_path_offset)->b_blocknr)
 		/* Parent in the path is not parent of the current node in the tree. */
 		return REPEAT_SEARCH;
 
-	if (buffer_locked(p_s_bh)) {
-		__wait_on_buffer(p_s_bh);
+	if (buffer_locked(bh)) {
+		__wait_on_buffer(bh);
 		if (FILESYSTEM_CHANGED_TB(p_s_tb))
 			return REPEAT_SEARCH;
 	}
@@ -1941,29 +1941,29 @@ static int get_neighbors(struct tree_bal
 	    n_path_offset = PATH_H_PATH_OFFSET(p_s_tb->tb_path, n_h + 1);
 	unsigned long n_son_number;
 	struct super_block *sb = p_s_tb->tb_sb;
-	struct buffer_head *p_s_bh;
+	struct buffer_head *bh;
 
 	PROC_INFO_INC(sb, get_neighbors[n_h]);
 
 	if (p_s_tb->lnum[n_h]) {
 		/* We need left neighbor to balance S[n_h]. */
 		PROC_INFO_INC(sb, need_l_neighbor[n_h]);
-		p_s_bh = PATH_OFFSET_PBUFFER(p_s_tb->tb_path, n_path_offset);
+		bh = PATH_OFFSET_PBUFFER(p_s_tb->tb_path, n_path_offset);
 
-		RFALSE(p_s_bh == p_s_tb->FL[n_h] &&
+		RFALSE(bh == p_s_tb->FL[n_h] &&
 		       !PATH_OFFSET_POSITION(p_s_tb->tb_path, n_path_offset),
 		       "PAP-8270: invalid position in the parent");
 
 		n_child_position =
-		    (p_s_bh ==
+		    (bh ==
 		     p_s_tb->FL[n_h]) ? p_s_tb->lkey[n_h] : B_NR_ITEMS(p_s_tb->
 								       FL[n_h]);
 		n_son_number = B_N_CHILD_NUM(p_s_tb->FL[n_h], n_child_position);
-		p_s_bh = sb_bread(sb, n_son_number);
-		if (!p_s_bh)
+		bh = sb_bread(sb, n_son_number);
+		if (!bh)
 			return IO_ERROR;
 		if (FILESYSTEM_CHANGED_TB(p_s_tb)) {
-			brelse(p_s_bh);
+			brelse(bh);
 			PROC_INFO_INC(sb, get_neighbors_restart[n_h]);
 			return REPEAT_SEARCH;
 		}
@@ -1971,48 +1971,48 @@ static int get_neighbors(struct tree_bal
 		RFALSE(!B_IS_IN_TREE(p_s_tb->FL[n_h]) ||
 		       n_child_position > B_NR_ITEMS(p_s_tb->FL[n_h]) ||
 		       B_N_CHILD_NUM(p_s_tb->FL[n_h], n_child_position) !=
-		       p_s_bh->b_blocknr, "PAP-8275: invalid parent");
-		RFALSE(!B_IS_IN_TREE(p_s_bh), "PAP-8280: invalid child");
+		       bh->b_blocknr, "PAP-8275: invalid parent");
+		RFALSE(!B_IS_IN_TREE(bh), "PAP-8280: invalid child");
 		RFALSE(!n_h &&
-		       B_FREE_SPACE(p_s_bh) !=
-		       MAX_CHILD_SIZE(p_s_bh) -
+		       B_FREE_SPACE(bh) !=
+		       MAX_CHILD_SIZE(bh) -
 		       dc_size(B_N_CHILD(p_s_tb->FL[0], n_child_position)),
 		       "PAP-8290: invalid child size of left neighbor");
 
 		brelse(p_s_tb->L[n_h]);
-		p_s_tb->L[n_h] = p_s_bh;
+		p_s_tb->L[n_h] = bh;
 	}
 
 	if (p_s_tb->rnum[n_h]) {	/* We need right neighbor to balance S[n_path_offset]. */
 		PROC_INFO_INC(sb, need_r_neighbor[n_h]);
-		p_s_bh = PATH_OFFSET_PBUFFER(p_s_tb->tb_path, n_path_offset);
+		bh = PATH_OFFSET_PBUFFER(p_s_tb->tb_path, n_path_offset);
 
-		RFALSE(p_s_bh == p_s_tb->FR[n_h] &&
+		RFALSE(bh == p_s_tb->FR[n_h] &&
 		       PATH_OFFSET_POSITION(p_s_tb->tb_path,
 					    n_path_offset) >=
-		       B_NR_ITEMS(p_s_bh),
+		       B_NR_ITEMS(bh),
 		       "PAP-8295: invalid position in the parent");
 
 		n_child_position =
-		    (p_s_bh == p_s_tb->FR[n_h]) ? p_s_tb->rkey[n_h] + 1 : 0;
+		    (bh == p_s_tb->FR[n_h]) ? p_s_tb->rkey[n_h] + 1 : 0;
 		n_son_number = B_N_CHILD_NUM(p_s_tb->FR[n_h], n_child_position);
-		p_s_bh = sb_bread(sb, n_son_number);
-		if (!p_s_bh)
+		bh = sb_bread(sb, n_son_number);
+		if (!bh)
 			return IO_ERROR;
 		if (FILESYSTEM_CHANGED_TB(p_s_tb)) {
-			brelse(p_s_bh);
+			brelse(bh);
 			PROC_INFO_INC(sb, get_neighbors_restart[n_h]);
 			return REPEAT_SEARCH;
 		}
 		brelse(p_s_tb->R[n_h]);
-		p_s_tb->R[n_h] = p_s_bh;
+		p_s_tb->R[n_h] = bh;
 
 		RFALSE(!n_h
-		       && B_FREE_SPACE(p_s_bh) !=
-		       MAX_CHILD_SIZE(p_s_bh) -
+		       && B_FREE_SPACE(bh) !=
+		       MAX_CHILD_SIZE(bh) -
 		       dc_size(B_N_CHILD(p_s_tb->FR[0], n_child_position)),
 		       "PAP-8300: invalid child size of right neighbor (%d != %d - %d)",
-		       B_FREE_SPACE(p_s_bh), MAX_CHILD_SIZE(p_s_bh),
+		       B_FREE_SPACE(bh), MAX_CHILD_SIZE(bh),
 		       dc_size(B_N_CHILD(p_s_tb->FR[0], n_child_position)));
 
 	}
@@ -2088,51 +2088,51 @@ static int get_mem_for_virtual_node(stru
 
 #ifdef CONFIG_REISERFS_CHECK
 static void tb_buffer_sanity_check(struct super_block *sb,
-				   struct buffer_head *p_s_bh,
+				   struct buffer_head *bh,
 				   const char *descr, int level)
 {
-	if (p_s_bh) {
-		if (atomic_read(&(p_s_bh->b_count)) <= 0) {
+	if (bh) {
+		if (atomic_read(&(bh->b_count)) <= 0) {
 
 			reiserfs_panic(sb, "jmacd-1", "negative or zero "
 			               "reference counter for buffer %s[%d] "
-				       "(%b)", descr, level, p_s_bh);
+				       "(%b)", descr, level, bh);
 		}
 
-		if (!buffer_uptodate(p_s_bh)) {
+		if (!buffer_uptodate(bh)) {
 			reiserfs_panic(sb, "jmacd-2", "buffer is not up "
 			               "to date %s[%d] (%b)",
-				       descr, level, p_s_bh);
+				       descr, level, bh);
 		}
 
-		if (!B_IS_IN_TREE(p_s_bh)) {
+		if (!B_IS_IN_TREE(bh)) {
 			reiserfs_panic(sb, "jmacd-3", "buffer is not "
 			               "in tree %s[%d] (%b)",
-				       descr, level, p_s_bh);
+				       descr, level, bh);
 		}
 
-		if (p_s_bh->b_bdev != sb->s_bdev) {
+		if (bh->b_bdev != sb->s_bdev) {
 			reiserfs_panic(sb, "jmacd-4", "buffer has wrong "
 			               "device %s[%d] (%b)",
-				       descr, level, p_s_bh);
+				       descr, level, bh);
 		}
 
-		if (p_s_bh->b_size != sb->s_blocksize) {
+		if (bh->b_size != sb->s_blocksize) {
 			reiserfs_panic(sb, "jmacd-5", "buffer has wrong "
 			               "blocksize %s[%d] (%b)",
-				       descr, level, p_s_bh);
+				       descr, level, bh);
 		}
 
-		if (p_s_bh->b_blocknr > SB_BLOCK_COUNT(sb)) {
+		if (bh->b_blocknr > SB_BLOCK_COUNT(sb)) {
 			reiserfs_panic(sb, "jmacd-6", "buffer block "
 			               "number too high %s[%d] (%b)",
-				       descr, level, p_s_bh);
+				       descr, level, bh);
 		}
 	}
 }
 #else
 static void tb_buffer_sanity_check(struct super_block *sb,
-				   struct buffer_head *p_s_bh,
+				   struct buffer_head *bh,
 				   const char *descr, int level)
 {;
 }
--- a/fs/reiserfs/stree.c	2007-06-11 14:49:39.000000000 -0400
+++ b/fs/reiserfs/stree.c	2007-06-11 14:50:03.000000000 -0400
@@ -56,13 +56,13 @@
 #include <linux/quotaops.h>
 
 /* Does the buffer contain a disk block which is in the tree. */
-inline int B_IS_IN_TREE(const struct buffer_head *p_s_bh)
+inline int B_IS_IN_TREE(const struct buffer_head *bh)
 {
 
-	RFALSE(B_LEVEL(p_s_bh) > MAX_HEIGHT,
-	       "PAP-1010: block (%b) has too big level (%z)", p_s_bh, p_s_bh);
+	RFALSE(B_LEVEL(bh) > MAX_HEIGHT,
+	       "PAP-1010: block (%b) has too big level (%z)", bh, bh);
 
-	return (B_LEVEL(p_s_bh) != FREE_LEVEL);
+	return (B_LEVEL(bh) != FREE_LEVEL);
 }
 
 //
@@ -579,7 +579,7 @@ int search_by_key(struct super_block *sb
 {
 	int n_block_number;
 	int expected_level;
-	struct buffer_head *p_s_bh;
+	struct buffer_head *bh;
 	struct path_element *p_s_last_element;
 	int n_node_level, n_retval;
 	int right_neighbor_of_leaf_node;
@@ -626,15 +626,15 @@ int search_by_key(struct super_block *sb
 
 		/* Read the next tree node, and set the last element in the path to
 		   have a pointer to it. */
-		if ((p_s_bh = p_s_last_element->pe_buffer =
+		if ((bh = p_s_last_element->pe_buffer =
 		     sb_getblk(sb, n_block_number))) {
-			if (!buffer_uptodate(p_s_bh) && reada_count > 1) {
+			if (!buffer_uptodate(bh) && reada_count > 1) {
 				search_by_key_reada(sb, reada_bh,
 						    reada_blocks, reada_count);
 			}
-			ll_rw_block(READ, 1, &p_s_bh);
-			wait_on_buffer(p_s_bh);
-			if (!buffer_uptodate(p_s_bh))
+			ll_rw_block(READ, 1, &bh);
+			wait_on_buffer(bh);
+			if (!buffer_uptodate(bh))
 				goto io_error;
 		} else {
 		      io_error:
@@ -651,8 +651,8 @@ int search_by_key(struct super_block *sb
 		   to search is still in the tree rooted from the current buffer. If
 		   not then repeat search from the root. */
 		if (fs_changed(fs_gen, sb) &&
-		    (!B_IS_IN_TREE(p_s_bh) ||
-		     B_LEVEL(p_s_bh) != expected_level ||
+		    (!B_IS_IN_TREE(bh) ||
+		     B_LEVEL(bh) != expected_level ||
 		     !key_in_buffer(p_s_search_path, p_s_key, sb))) {
 			PROC_INFO_INC(sb, search_by_key_fs_changed);
 			PROC_INFO_INC(sb, search_by_key_restarted);
@@ -686,25 +686,25 @@ int search_by_key(struct super_block *sb
 
 		// make sure, that the node contents look like a node of
 		// certain level
-		if (!is_tree_node(p_s_bh, expected_level)) {
+		if (!is_tree_node(bh, expected_level)) {
 			reiserfs_error(sb, "vs-5150",
 			               "invalid format found in block %ld. "
-			               "Fsck?", p_s_bh->b_blocknr);
+			               "Fsck?", bh->b_blocknr);
 			pathrelse(p_s_search_path);
 			return IO_ERROR;
 		}
 
 		/* ok, we have acquired next formatted node in the tree */
-		n_node_level = B_LEVEL(p_s_bh);
+		n_node_level = B_LEVEL(bh);
 
-		PROC_INFO_BH_STAT(sb, p_s_bh, n_node_level - 1);
+		PROC_INFO_BH_STAT(sb, bh, n_node_level - 1);
 
 		RFALSE(n_node_level < n_stop_level,
 		       "vs-5152: tree level (%d) is less than stop level (%d)",
 		       n_node_level, n_stop_level);
 
-		n_retval = bin_search(p_s_key, B_N_PITEM_HEAD(p_s_bh, 0),
-				      B_NR_ITEMS(p_s_bh),
+		n_retval = bin_search(p_s_key, B_N_PITEM_HEAD(bh, 0),
+				      B_NR_ITEMS(bh),
 				      (n_node_level ==
 				       DISK_LEAF_NODE_LEVEL) ? IH_SIZE :
 				      KEY_SIZE,
@@ -726,13 +726,13 @@ int search_by_key(struct super_block *sb
 		   an internal node.  Now we calculate child block number by
 		   position in the node. */
 		n_block_number =
-		    B_N_CHILD_NUM(p_s_bh, p_s_last_element->pe_position);
+		    B_N_CHILD_NUM(bh, p_s_last_element->pe_position);
 
 		/* if we are going to read leaf nodes, try for read ahead as well */
 		if ((p_s_search_path->reada & PATH_READA) &&
 		    n_node_level == DISK_LEAF_NODE_LEVEL + 1) {
 			int pos = p_s_last_element->pe_position;
-			int limit = B_NR_ITEMS(p_s_bh);
+			int limit = B_NR_ITEMS(bh);
 			struct reiserfs_key *le_key;
 
 			if (p_s_search_path->reada & PATH_READA_BACK)
@@ -741,7 +741,7 @@ int search_by_key(struct super_block *sb
 				if (pos == limit)
 					break;
 				reada_blocks[reada_count++] =
-				    B_N_CHILD_NUM(p_s_bh, pos);
+				    B_N_CHILD_NUM(bh, pos);
 				if (p_s_search_path->reada & PATH_READA_BACK)
 					pos--;
 				else
@@ -750,7 +750,7 @@ int search_by_key(struct super_block *sb
 				/*
 				 * check to make sure we're in the same object
 				 */
-				le_key = B_N_PDELIM_KEY(p_s_bh, pos);
+				le_key = B_N_PDELIM_KEY(bh, pos);
 				if (le32_to_cpu(le_key->k_objectid) !=
 				    p_s_key->on_disk_key.k_objectid) {
 					break;
@@ -851,15 +851,15 @@ int search_for_position_by_key(struct su
 /* Compare given item and item pointed to by the path. */
 int comp_items(const struct item_head *stored_ih, const struct treepath *p_s_path)
 {
-	struct buffer_head *p_s_bh;
+	struct buffer_head *bh;
 	struct item_head *ih;
 
 	/* Last buffer at the path is not in the tree. */
-	if (!B_IS_IN_TREE(p_s_bh = PATH_PLAST_BUFFER(p_s_path)))
+	if (!B_IS_IN_TREE(bh = PATH_PLAST_BUFFER(p_s_path)))
 		return 1;
 
 	/* Last path position is invalid. */
-	if (PATH_LAST_POSITION(p_s_path) >= B_NR_ITEMS(p_s_bh))
+	if (PATH_LAST_POSITION(p_s_path) >= B_NR_ITEMS(bh))
 		return 1;
 
 	/* we need only to know, whether it is the same item */
@@ -959,7 +959,7 @@ static char prepare_for_delete_or_cut(st
 {
 	struct super_block *sb = inode->i_sb;
 	struct item_head *p_le_ih = PATH_PITEM_HEAD(p_s_path);
-	struct buffer_head *p_s_bh = PATH_PLAST_BUFFER(p_s_path);
+	struct buffer_head *bh = PATH_PLAST_BUFFER(p_s_path);
 
 	BUG_ON(!th->t_trans_id);
 
@@ -1003,7 +1003,7 @@ static char prepare_for_delete_or_cut(st
 	    do {
 		need_re_search = 0;
 		*p_n_cut_size = 0;
-		p_s_bh = PATH_PLAST_BUFFER(p_s_path);
+		bh = PATH_PLAST_BUFFER(p_s_path);
 		copy_item_head(&s_ih, PATH_PITEM_HEAD(p_s_path));
 		pos = I_UNFM_NUM(&s_ih);
 
@@ -1018,13 +1018,13 @@ static char prepare_for_delete_or_cut(st
 			break;
 		    }
 
-		    unfm = (__u32 *)B_I_PITEM(p_s_bh, &s_ih) + pos - 1;
+		    unfm = (__u32 *)B_I_PITEM(bh, &s_ih) + pos - 1;
 		    block = get_block_num(unfm, 0);
 
 		    if (block != 0) {
-			reiserfs_prepare_for_journal(sb, p_s_bh, 1);
+			reiserfs_prepare_for_journal(sb, bh, 1);
 			put_block_num(unfm, 0, 0);
-			journal_mark_dirty (th, sb, p_s_bh);
+			journal_mark_dirty (th, sb, bh);
 			reiserfs_free_block(th, inode, block, 1);
 		    }
 
@@ -1048,7 +1048,7 @@ static char prepare_for_delete_or_cut(st
 		/* a trick.  If the buffer has been logged, this will do nothing.  If
 		** we've broken the loop without logging it, it will restore the
 		** buffer */
-		reiserfs_restore_prepared_buffer(sb, p_s_bh);
+		reiserfs_restore_prepared_buffer(sb, bh);
 	    } while (need_re_search &&
 		     search_for_position_by_key(sb, p_s_item_key, p_s_path) == POSITION_FOUND);
 	    pos_in_item(p_s_path) = pos * UNFM_P_SIZE;
--- a/include/linux/reiserfs_fs.h	2007-06-11 14:49:39.000000000 -0400
+++ b/include/linux/reiserfs_fs.h	2007-06-11 14:50:03.000000000 -0400
@@ -731,25 +731,25 @@ struct block_head {
 #define DISK_LEAF_NODE_LEVEL  1	/* Leaf node level. */
 
 /* Given the buffer head of a formatted node, resolve to the block head of that node. */
-#define B_BLK_HEAD(p_s_bh)            ((struct block_head *)((p_s_bh)->b_data))
+#define B_BLK_HEAD(bh)            ((struct block_head *)((bh)->b_data))
 /* Number of items that are in buffer. */
-#define B_NR_ITEMS(p_s_bh)            (blkh_nr_item(B_BLK_HEAD(p_s_bh)))
-#define B_LEVEL(p_s_bh)               (blkh_level(B_BLK_HEAD(p_s_bh)))
-#define B_FREE_SPACE(p_s_bh)          (blkh_free_space(B_BLK_HEAD(p_s_bh)))
-
-#define PUT_B_NR_ITEMS(p_s_bh,val)    do { set_blkh_nr_item(B_BLK_HEAD(p_s_bh),val); } while (0)
-#define PUT_B_LEVEL(p_s_bh,val)       do { set_blkh_level(B_BLK_HEAD(p_s_bh),val); } while (0)
-#define PUT_B_FREE_SPACE(p_s_bh,val)  do { set_blkh_free_space(B_BLK_HEAD(p_s_bh),val); } while (0)
+#define B_NR_ITEMS(bh)            (blkh_nr_item(B_BLK_HEAD(bh)))
+#define B_LEVEL(bh)               (blkh_level(B_BLK_HEAD(bh)))
+#define B_FREE_SPACE(bh)          (blkh_free_space(B_BLK_HEAD(bh)))
+
+#define PUT_B_NR_ITEMS(bh,val)    do { set_blkh_nr_item(B_BLK_HEAD(bh),val); } while (0)
+#define PUT_B_LEVEL(bh,val)       do { set_blkh_level(B_BLK_HEAD(bh),val); } while (0)
+#define PUT_B_FREE_SPACE(bh,val)  do { set_blkh_free_space(B_BLK_HEAD(bh),val); } while (0)
 
 /* Get right delimiting key. -- little endian */
-#define B_PRIGHT_DELIM_KEY(p_s_bh)   (&(blk_right_delim_key(B_BLK_HEAD(p_s_bh))))
+#define B_PRIGHT_DELIM_KEY(bh)   (&(blk_right_delim_key(B_BLK_HEAD(bh))))
 
 /* Does the buffer contain a disk leaf. */
-#define B_IS_ITEMS_LEVEL(p_s_bh)     (B_LEVEL(p_s_bh) == DISK_LEAF_NODE_LEVEL)
+#define B_IS_ITEMS_LEVEL(bh)     (B_LEVEL(bh) == DISK_LEAF_NODE_LEVEL)
 
 /* Does the buffer contain a disk internal node */
-#define B_IS_KEYS_LEVEL(p_s_bh)      (B_LEVEL(p_s_bh) > DISK_LEAF_NODE_LEVEL \
-                                            && B_LEVEL(p_s_bh) <= MAX_HEIGHT)
+#define B_IS_KEYS_LEVEL(bh)      (B_LEVEL(bh) > DISK_LEAF_NODE_LEVEL \
+                                            && B_LEVEL(bh) <= MAX_HEIGHT)
 
 /***************************************************************************/
 /*                             STAT DATA                                   */
@@ -1099,12 +1099,12 @@ struct disk_child {
 #define put_dc_size(dc_p, val)   do { (dc_p)->dc_size = cpu_to_le16(val); } while(0)
 
 /* Get disk child by buffer header and position in the tree node. */
-#define B_N_CHILD(p_s_bh,n_pos)  ((struct disk_child *)\
-((p_s_bh)->b_data+BLKH_SIZE+B_NR_ITEMS(p_s_bh)*KEY_SIZE+DC_SIZE*(n_pos)))
+#define B_N_CHILD(bh,n_pos)  ((struct disk_child *)\
+((bh)->b_data+BLKH_SIZE+B_NR_ITEMS(bh)*KEY_SIZE+DC_SIZE*(n_pos)))
 
 /* Get disk child number by buffer header and position in the tree node. */
-#define B_N_CHILD_NUM(p_s_bh,n_pos) (dc_block_number(B_N_CHILD(p_s_bh,n_pos)))
-#define PUT_B_N_CHILD_NUM(p_s_bh,n_pos, val) (put_dc_block_number(B_N_CHILD(p_s_bh,n_pos), val ))
+#define B_N_CHILD_NUM(bh,n_pos) (dc_block_number(B_N_CHILD(bh,n_pos)))
+#define PUT_B_N_CHILD_NUM(bh,n_pos, val) (put_dc_block_number(B_N_CHILD(bh,n_pos), val ))
 
  /* maximal value of field child_size in structure disk_child */
  /* child size is the combined size of all items and their headers */
@@ -1827,7 +1827,7 @@ int search_by_key(struct super_block *, 
 int search_for_position_by_key(struct super_block *sb,
 			       const struct cpu_key *p_s_cpu_key,
 			       struct treepath *p_s_search_path);
-extern void decrement_bcount(struct buffer_head *p_s_bh);
+extern void decrement_bcount(struct buffer_head *bh);
 void decrement_counters_in_path(struct treepath *p_s_search_path);
 void pathrelse(struct treepath *p_s_search_path);
 int reiserfs_check_path(struct treepath *p);
@@ -1972,7 +1972,7 @@ int reiserfs_global_version_in_proc(char
 #define PROC_INFO_MAX( sb, field, value ) VOID_V
 #define PROC_INFO_INC( sb, field ) VOID_V
 #define PROC_INFO_ADD( sb, field, val ) VOID_V
-#define PROC_INFO_BH_STAT( sb, p_s_bh, n_node_level ) VOID_V
+#define PROC_INFO_BH_STAT( sb, bh, n_node_level ) VOID_V
 #endif
 
 /* dir.c */
