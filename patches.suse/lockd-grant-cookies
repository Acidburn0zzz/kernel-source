From: Olaf Kirch <okir@suse.de>
Subject: [lockd] match GRANTED_RES replies using cookies

 When we send a GRANTED_MSG call, we current copy the NLM cookie
 provided in the original LOCK call - because in 1996, some broken
 clients seemed to rely on this bug. However, this means the cookies
 are not unique, so that when the client's GRANTED_RES message comes
 back, we cannot simply match it based on the cookie, but have to
 use the client's IP address in addition. Which breaks when you have
 a multi-homed NFS client.
 
 The X/Open spec explicitly mentions that clients should not expect the
 same cookie; so one may hope that any clients that were broken in 1996
 have either been fixed or rendered obsolete.

Signed-off-by: Olaf Kirch <okir@suse.de>

 fs/lockd/svclock.c |   36 ++++++++++++++++--------------------
 1 files changed, 16 insertions(+), 20 deletions(-)

Index: 2.6.15/fs/lockd/svclock.c
===================================================================
--- 2.6.15.orig/fs/lockd/svclock.c
+++ 2.6.15/fs/lockd/svclock.c
@@ -142,18 +142,16 @@ static inline int nlm_cookie_match(struc
  * Find a block with a given NLM cookie.
  */
 static inline struct nlm_block *
-nlmsvc_find_block(struct nlm_cookie *cookie,  struct sockaddr_in *sin)
+nlmsvc_find_block(struct nlm_cookie *cookie)
 {
 	struct nlm_block *block;
 
 	for (block = nlm_blocked; block; block = block->b_next) {
-		dprintk("cookie: head of blocked queue %p, block %p\n", 
-			nlm_blocked, block);
-		if (nlm_cookie_match(&block->b_call.a_args.cookie,cookie)
-				&& nlm_cmp_addr(sin, &block->b_host->h_addr))
+		if (nlm_cookie_match(&block->b_call.a_args.cookie, cookie))
 			break;
 	}
 
+	dprintk("nlmsvc_find_block(%s): block=%p\n", nlmdbg_cookie2a(cookie), block);
 	return block;
 }
 
@@ -166,6 +164,11 @@ nlmsvc_find_block(struct nlm_cookie *coo
  * request, but (as I found out later) that's because some implementations
  * do just this. Never mind the standards comittees, they support our
  * logging industries.
+ *
+ * 10 years later: I hope can can safely ignore these old and broken
+ * clients by now. Let's fix this so we can uniquely identify an incoming
+ * GRANTED_RES message by cookie, without having to rely on the client's IP
+ * address. --okir
  */
 static inline struct nlm_block *
 nlmsvc_create_block(struct svc_rqst *rqstp, struct nlm_file *file,
@@ -194,7 +197,7 @@ nlmsvc_create_block(struct svc_rqst *rqs
 
 	/* Set notifier function for VFS, and init args */
 	block->b_call.a_args.lock.fl.fl_lmops = &nlmsvc_lock_operations;
-	block->b_call.a_args.cookie = *cookie;	/* see above */
+	nlmclnt_next_cookie(&block->b_call.a_args.cookie);
 
 	dprintk("lockd: created block %p...\n", block);
 
@@ -583,16 +586,10 @@ nlmsvc_grant_callback(struct rpc_task *t
 	unsigned long		timeout;
 	struct sockaddr_in	*peer_addr = RPC_PEERADDR(task->tk_client);
 
-	dprintk("lockd: GRANT_MSG RPC callback\n");
-	dprintk("callback: looking for cookie %s, host (%u.%u.%u.%u)\n",
-		nlmdbg_cookie2a(&call->a_args.cookie),
-		NIPQUAD(peer_addr->sin_addr.s_addr));
-	if (!(block = nlmsvc_find_block(&call->a_args.cookie, peer_addr))) {
-		dprintk("lockd: no block for cookie %s, host (%u.%u.%u.%u)\n",
-			nlmdbg_cookie2a(&call->a_args.cookie),
-			NIPQUAD(peer_addr->sin_addr.s_addr));
+	dprintk("lockd: GRANT_MSG RPC callback from %u.%u.%u.%u\n",
+ 			NIPQUAD(peer_addr->sin_addr.s_addr));
+	if (!(block = nlmsvc_find_block(&call->a_args.cookie)))
 		return;
-	}
 
 	/* Technically, we should down the file semaphore here. Since we
 	 * move the block towards the head of the queue only, no harm
@@ -624,16 +621,15 @@ nlmsvc_grant_reply(struct svc_rqst *rqst
 	struct nlm_block	*block;
 	struct nlm_file		*file;
 
-	dprintk("grant_reply: looking for cookie %x, host (%08x), s=%d \n", 
-		*(unsigned int *)(cookie->data), 
-		ntohl(rqstp->rq_addr.sin_addr.s_addr), status);
-	if (!(block = nlmsvc_find_block(cookie, &rqstp->rq_addr)))
+	dprintk("lockd: GRANT_RES RPC callback from %u.%u.%u.%u; status=%u\n",
+			NIPQUAD(rqstp->rq_addr.sin_addr.s_addr), status);
+	if (!(block = nlmsvc_find_block(cookie)))
 		return;
 	file = block->b_file;
 
 	file->f_count++;
 	down(&file->f_sema);
-	if ((block = nlmsvc_find_block(cookie,&rqstp->rq_addr)) != NULL) {
+	if ((block = nlmsvc_find_block(cookie)) != NULL) {
 		if (status == NLM_LCK_DENIED_GRACE_PERIOD) {
 			/* Try again in a couple of seconds */
 			nlmsvc_insert_block(block, 10 * HZ);
