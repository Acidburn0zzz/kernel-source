# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/03/31 16:10:12-05:00 nagar@elinux03.watson.ibm.com 
#   ckrm-E5.rcfs
# 
# include/linux/rcfs.h
#   2004/03/31 16:10:11-05:00 nagar@elinux03.watson.ibm.com +56 -0
# 
# include/linux/rcfs.h
#   2004/03/31 16:10:11-05:00 nagar@elinux03.watson.ibm.com +0 -0
#   BitKeeper file /home/BK/v3/sles9/sles9-cvs-ckrm/include/linux/rcfs.h
# 
# fs/rcfs/super.c
#   2004/03/31 16:10:11-05:00 nagar@elinux03.watson.ibm.com +13 -43
#   ckrm-E5.rcfs
# 
# fs/rcfs/magic_target.c
#   2004/03/31 16:10:11-05:00 nagar@elinux03.watson.ibm.com +69 -30
#   ckrm-E5.rcfs
# 
# fs/rcfs/magic_stats.c
#   2004/03/31 16:10:11-05:00 nagar@elinux03.watson.ibm.com +1 -2
#   ckrm-E5.rcfs
# 
# fs/rcfs/magic_shares.c
#   2004/03/31 16:10:11-05:00 nagar@elinux03.watson.ibm.com +5 -23
#   ckrm-E5.rcfs
# 
# fs/rcfs/magic_members.c
#   2004/03/31 16:10:11-05:00 nagar@elinux03.watson.ibm.com +18 -10
#   ckrm-E5.rcfs
# 
# fs/rcfs/magic_config.c
#   2004/03/31 16:10:10-05:00 nagar@elinux03.watson.ibm.com +4 -5
#   ckrm-E5.rcfs
# 
# fs/rcfs/inode.c
#   2004/03/31 16:10:10-05:00 nagar@elinux03.watson.ibm.com +43 -42
#   ckrm-E5.rcfs
# 
# fs/rcfs/file.c
#   2004/03/31 16:10:10-05:00 nagar@elinux03.watson.ibm.com +1 -13
#   ckrm-E5.rcfs
# 
# fs/rcfs/dir.c
#   2004/03/31 16:10:10-05:00 nagar@elinux03.watson.ibm.com +45 -38
#   ckrm-E5.rcfs
# 
# BitKeeper/deleted/.del-MOVETOCORE.h~2c10f5b52222aacd
#   2004/03/31 16:08:51-05:00 nagar@elinux03.watson.ibm.com +0 -0
#   Delete: fs/rcfs/MOVETOCORE.h
# 
# BitKeeper/deleted/.del-rcfs.h~76678d2e24586990
#   2004/03/31 16:06:55-05:00 nagar@elinux03.watson.ibm.com +0 -0
#   Delete: fs/rcfs/rcfs.h
# 
diff -Nru a/fs/rcfs/MOVETOCORE.h b/fs/rcfs/MOVETOCORE.h
--- a/fs/rcfs/MOVETOCORE.h	Wed Mar 31 16:53:21 2004
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,4 +0,0 @@
-#ifndef _LINUX_MOVETOCORE_H
-#define _LINUX_MOVETOCORE_H
-
-#endif /* _LINUX_MOVETOCORE_H */
diff -Nru a/fs/rcfs/dir.c b/fs/rcfs/dir.c
--- a/fs/rcfs/dir.c	Wed Mar 31 16:53:21 2004
+++ b/fs/rcfs/dir.c	Wed Mar 31 16:53:21 2004
@@ -39,7 +39,7 @@
 
 #include <asm/uaccess.h>
 
-#include "rcfs.h"
+#include <linux/rcfs.h>
 #include "magic.h"
 
 
@@ -50,6 +50,7 @@
 
 #define rcfs_positive(dentry)  ((dentry)->d_inode && !d_unhashed((dentry)))
 
+#if 0
 static
 int rcfs_empty(struct dentry *dentry)
 {
@@ -68,7 +69,7 @@
 	spin_unlock(&dcache_lock);
 	return ret;
 }
-
+#endif
 
 
 int 
@@ -109,10 +110,11 @@
 int 
 rcfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
-	extern struct dentry *rcfs_nwde;
+#if 0
 	struct dentry *ldentry;
+	int mfmode,i;
+#endif
 	int retval;
-	int mfmode,i,j;
 	struct rcfs_inode_info *ripar,*ridir;
 	struct dentry *pd = list_entry(dir->i_dentry.next, struct dentry, d_alias);
 
@@ -127,11 +129,26 @@
 			return -EINVAL;
 		}
 	}
+
+
+	// Creation of /rcfs/network reserved for network controllers
+
+	if ((!strcmp(pd->d_name.name, "/") &&
+				!strcmp(dentry->d_name.name, "network"))) {
+		return -EPERM;
+	}
+
+#if 0
 	// Creation in /rcfs/network is not allowed
 	// XXX - would be good to instead add a check with the parent's 
 	// core class
-	if (dir == rcfs_nwde->d_inode)
-		return -EPERM;
+	{
+		extern struct dentry *rcfs_nwde;
+		
+		if (dir == rcfs_nwde->d_inode)
+			return -EPERM;
+	}
+#endif
 
 
 	retval  = rcfs_mknod(dir, dentry, mode | S_IFDIR, 0);
@@ -149,45 +166,34 @@
 	/* On error, goto mkdir_err */
 
 	if (is_core_valid(ripar->core))
-		ridir->core = ckrm_alloc_core_class((ckrm_core_class_t *)ripar->core, 
-						    dentry);
+		ridir->core = ckrm_alloc_core_class(
+				(ckrm_core_class_t *)ripar->core, dentry);
 	else {
 		printk(KERN_ERR "rcfs_mkdir: Invalid parent core \n");
 		return -EINVAL;
 	}
-
 #if 0
 	mfmode = S_IFREG | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;	
 	for (i=0; i < NR_MAGF; i++) {
 		ldentry = 
 			rcfs_create_internal(dentry, magf[i].name, mfmode, 0);
-		if (!ldentry)
-			break;
+		if (!ldentry) {
+			printk(KERN_ERR "rcfs_mkdir: error creating magic files. Improve handling\n");
+			goto mkdir_err;
+		}
 		ldentry->d_fsdata = &RCFS_IS_MAGIC;
-	}
-
-	printk(KERN_ERR "rcfs_mkdir: core cls(%s, inode %p, ri %p, core %p) created\n",
-	       dentry->d_name.name, dentry->d_inode, ridir, ridir->core);
+ 		if (magf[i].i_op)
+ 			ldentry->d_inode->i_op = magf[i].i_op;
+ 		if (magf[i].i_fop)
+ 			ldentry->d_inode->i_fop = magf[i].i_fop;
+ 
+ 		printk(KERN_ERR "rcfs_mkdir: magic entry created(%s, inode %p, dentry %p) created\n",ldentry->d_name.name, ldentry->d_inode, ldentry);
 
-
-	/* Create magic files, directories */
-	
-//
-//	for (i=0; i<NR_MAGF; i++) {
-//	        if (rcfs_create_magic(dentry, &magf[i]))
-//			break;
-//	}
-
-	if (i != NR_MAGF) { /* Error creating any magic file */
-		printk(KERN_ERR "Error creating magic files %d\n",i);
-		rcfs_delete_all_magic(dentry);
-		goto mkdir_err ;
 	}
 #endif
-		
 	return retval;
 
-mkdir_err:
+//mkdir_err:
 	dir->i_nlink--;
 	return -EINVAL;
 }
@@ -196,8 +202,6 @@
 int 
 rcfs_rmdir(struct inode * dir, struct dentry * dentry)
 {
-	int i;
-	int retval;
 	struct rcfs_inode_info *ri = RCFS_I(dentry->d_inode);
 	struct dentry *pd = list_entry(dir->i_dentry.next, struct dentry, d_alias);
 
@@ -220,13 +224,10 @@
 	   c) remove members/ & magic files
 	   If errors doing any of those, barf.
 	*/
-
 #if 0
-	rcfs_delete_all_magic(dentry);
+ 	rcfs_clear_magic(dentry);
 #endif
-
-	/* Core class removal */
-	//printk(KERN_ERR "About to remove %s ( %p)\n",dentry->d_name.name, ri);
+ 	// FIXME - this should be only be removed automagically on CE unregister only
 	
 	if ((!strcmp(pd->d_name.name, "/") &&
 				!strcmp(dentry->d_name.name, "ce"))) {
@@ -237,18 +238,24 @@
 			return simple_rmdir(dir, dentry);
 		}
 	}
+
+
+	/* Core class removal */
+	// printk(KERN_ERR "About to remove %s ( %p)\n",dentry->d_name.name, ri);
+
 	if (ckrm_free_core_class(ri->core)) {
 		printk(KERN_ERR "rcfs_rmdir: ckrm_free_core_class failed\n");
 		goto recreate_magic;
 	}
 	ri->core = NULL ; /* just to be safe */
 
+	/*
 	dentry->d_inode->i_nlink--;	
+	*/
 	return simple_rmdir(dir, dentry);
 
 recreate_magic:
 	printk("rcfs_rmdir: should recreate magic files here. Do manually now\n");
-rmdir_err:
 	return -EINVAL;
 }
 
diff -Nru a/fs/rcfs/file.c b/fs/rcfs/file.c
--- a/fs/rcfs/file.c	Wed Mar 31 16:53:21 2004
+++ b/fs/rcfs/file.c	Wed Mar 31 16:53:21 2004
@@ -41,8 +41,7 @@
 
 #include <asm/uaccess.h>
 
-#include "rcfs.h"
-#include "MOVETOCORE.h"
+#include <linux/rcfs.h>
 #include "magic.h"
 
 
@@ -87,17 +86,6 @@
 
 
 /*******************************Generic file ops ********************/
-
-
-static struct seq_operations rcfile_seq_ops;
-
-static int rcfs_open(struct inode *inode, struct file *file)
-{
-	return -EPERM;
-//	return seq_open(file, &rcfile_seq_ops);
-}
-
-
 
 
 struct address_space_operations rcfs_aops = {
diff -Nru a/fs/rcfs/inode.c b/fs/rcfs/inode.c
--- a/fs/rcfs/inode.c	Wed Mar 31 16:53:21 2004
+++ b/fs/rcfs/inode.c	Wed Mar 31 16:53:21 2004
@@ -43,7 +43,7 @@
 
 #include <asm/uaccess.h>
 
-#include "rcfs.h"
+#include <linux/rcfs.h>
 #include "magic.h"
 
 
@@ -142,19 +142,15 @@
 int
 rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
 {
-	struct inode *inode;
-	int err = -ENOSPC, i = 0;
 
         // printk(KERN_ERR "rcfs_mknod called with dir=%p dentry=%p mode=%d\n",dir,dentry,mode);
 	// Do not allow creation of files by the user. Only directories i.e.
 	// the classes can be created.
 
-	/*
 	if ((mode & S_IFMT) == S_IFREG)
 		return -EINVAL;
 	else 
-	*/
-	return _rcfs_mknod(dir, dentry, mode, dev);
+		return _rcfs_mknod(dir, dentry, mode, dev);
 }
 
 
@@ -202,6 +198,14 @@
 }
 #endif
 
+void
+rcfs_make_core(struct dentry *sp, struct ckrm_core_class *core)
+{
+	RCFS_I(sp->d_inode)->core = ckrm_alloc_core_class(core, sp);	
+	return;
+}
+EXPORT_SYMBOL(rcfs_make_core);
+
 struct dentry * 
 rcfs_create_internal(struct dentry *parent, const char *name, int mfmode, 
 			int magic)
@@ -216,13 +220,15 @@
 	qstr.hash = full_name_hash(name,qstr.len);
 	mfdentry = lookup_hash(&qstr,parent);
 
-	printk(KERN_INFO "parent %p name %s mfdentry is %x\n",parent, name, mfdentry);
+	printk(KERN_INFO "parent %p name %s mfdentry is %p\n",parent, name, (void *)mfdentry);
+
 	if (!IS_ERR(mfdentry)) {
 		int err; 
 
 		down(&parent->d_inode->i_sem);
-		if (magic)
-			err = rcfs_mkdir(parent->d_inode, mfdentry, mfmode, 0);
+//		if (magic)
+		if (S_ISDIR(mfmode))
+			err = rcfs_mkdir(parent->d_inode, mfdentry, mfmode);
 		else
 			err = _rcfs_mknod(parent->d_inode, mfdentry, mfmode, 0);
 		parent->d_inode->i_nlink++;
@@ -237,52 +243,47 @@
 }
 EXPORT_SYMBOL(rcfs_create_internal);
 
-int 
-rcfs_delete_all_magic(struct dentry *parent)
+rcfs_delete_internal(struct dentry *mfdentry)
 {
-	struct dentry *mftmp, *mfdentry ;
-	umode_t mfmode;
+	struct dentry *parent ;
 
-//	if (!(magf && magf->name))
-//		return NULL;
+	if (!mfdentry || !mfdentry->d_parent)
+		return -EINVAL;
 	
-	down(&parent->d_inode->i_sem);
+	parent = mfdentry->d_parent;
+
+	down(&mfdentry->d_inode->i_sem);
+	if (S_ISDIR(mfdentry->d_inode->i_mode))
+		simple_rmdir(parent->d_inode, mfdentry);
+	else
+		simple_unlink(parent->d_inode, mfdentry);
+	up(&mfdentry->d_inode->i_sem);
 
-	//dget(parent);
+	d_delete(mfdentry);
+	dput(mfdentry);
 
+	return 0;
+}
+
+int 
+rcfs_clear_magic(struct dentry *parent)
+{
+	struct dentry *mftmp, *mfdentry ;
+	
 	list_for_each_entry_safe(mfdentry, mftmp, &parent->d_subdirs, d_child) {
-		int x=0;
+		
 		if (!rcfs_is_magic(mfdentry))
 			continue ;
-
-		mfmode =  (mfdentry->d_inode->i_mode);
-			
-		if (mfmode & S_IFREG)
-			simple_unlink(parent->d_inode, mfdentry);
-		if (mfmode & S_IFDIR)
-			simple_rmdir(parent->d_inode, mfdentry);
-
-		d_delete(mfdentry);
-		dput(mfdentry);
-	}
-	up(&parent->d_inode->i_sem);		
 		
-#if 0
-	if (!parent || (parent->d_inode != dir))
-		return -EINVAL;
-//	down(&parent->d_inode->i_sem);
-	d_delete(magf->dentry);
-	simple_unlink(parent->d_inode, magf->dentry);
-	dput(magf->dentry);
-//	up(&parent->d_inode->i_sem);
-#endif
-
+		if (rcfs_delete_internal(mfdentry)) 
+			printk(KERN_ERR "rcfs_clear_magic: error deleting one\n");
+	}
+	
 	return 0;
 }
 
-
 struct inode_operations rcfs_file_inode_operations = {
-//	.getattr	= simple_getattr,
+	.getattr	= simple_getattr,
 };
 		
 
diff -Nru a/fs/rcfs/magic_config.c b/fs/rcfs/magic_config.c
--- a/fs/rcfs/magic_config.c	Wed Mar 31 16:53:21 2004
+++ b/fs/rcfs/magic_config.c	Wed Mar 31 16:53:21 2004
@@ -35,9 +35,8 @@
 #include <linux/parser.h>
 #include <asm/uaccess.h>
 
-#include "rcfs.h"
-#include "MOVETOCORE.h"
-
+#include <linux/rcfs.h>
+#include "magic.h"
 
 /* Currently there are no per-class config parameters defined.
  * 
@@ -166,7 +165,7 @@
 /*		if (ckrm_isregd(resid) && 
 		    ckrm_get_res_ctrlrs[resid].get_config) {
 		    if ((*(ckrm_get_res_ctrlrs[resid].get_config)(s)) < 0)
-		           goto config_out;
+		           goto show_out;
                 }
 */
 		seq_printf(s, "Showing configs 1 2 3 for res %d\n",resid);
@@ -174,7 +173,7 @@
 
 	return 0;
 
-show_out:
+//show_out:
 
 	seq_printf(s,"Error retrieving contents of next RC. Aborting\n");
 	return 0;
diff -Nru a/fs/rcfs/magic_members.c b/fs/rcfs/magic_members.c
--- a/fs/rcfs/magic_members.c	Wed Mar 31 16:53:21 2004
+++ b/fs/rcfs/magic_members.c	Wed Mar 31 16:53:21 2004
@@ -2,6 +2,7 @@
  * fs/rcfs/magic_members.c 
  *
  * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ * Copyright (C) Vivek Kashyap,  IBM Corp. 2004
  *           
  * 
  * virtual file for getting pids belonging to a class
@@ -37,38 +38,45 @@
 #include <linux/parser.h>
 #include <asm/uaccess.h>
 
-#include "rcfs.h"
-
+#include <linux/rcfs.h>
+#include "magic.h"
 
 
 static int 
 members_show(struct seq_file *s, void *v)
 {
-	int retval;
 	ckrm_core_class_t *core ;
 	struct list_head *lh;
 	struct task_struct *tsk;
+	struct ckrm_net_struct *ns = NULL;
 
 	/* Get and "display" statistics for each registered resource.
 	 * Data from each resource is "atomic" (depends on RC) 
 	 * but not across resources
 	 */
 
-	core = (ckrm_core_class_t *)(((struct rcfs_inode_info *)s->private)->core);
+	core = (ckrm_core_class_t *)
+		(((struct rcfs_inode_info *)s->private)->core);
 
 	if (!is_core_valid(core))
 		return -EINVAL;
 
-	seq_printf(s,"Printing tasks in members of %p\n",core);
+	seq_printf(s,"Printing  members of %p\n",core);
 	
 	spin_lock(&core->ckrm_lock);
-//	read_lock(&tasklist_lock);
-//	for_each_process(tsk) {
 	list_for_each(lh, &core->tasklist) {	
-		tsk = container_of(lh, struct task_struct, ckrm_link);
-		seq_printf(s,"%ld\n", (long)tsk->pid);
+		if (core->class_type == CKRM_TASK_CLASS) {
+			tsk = container_of(lh, struct task_struct, ckrm_link);
+			seq_printf(s,"%ld\n", (long)tsk->pid);
+		}
+		else if (core->class_type == CKRM_NET_CLASS) {
+			ns = container_of(lh, struct ckrm_net_struct,ckrm_link);
+			seq_printf(s, "%x\\%x\n", ns->daddr4,ns->dport);
+			// To be modified to
+			// seq_printf(s, "%s\\%s\n", 
+		        // 		ntoa(ns->daddr),ntoa(ns->dport));
+ 		}
 	}
-//	read_unlock(&tasklist_lock);
 	spin_unlock(&core->ckrm_lock);
 
 	return 0;
diff -Nru a/fs/rcfs/magic_shares.c b/fs/rcfs/magic_shares.c
--- a/fs/rcfs/magic_shares.c	Wed Mar 31 16:53:21 2004
+++ b/fs/rcfs/magic_shares.c	Wed Mar 31 16:53:21 2004
@@ -35,18 +35,12 @@
 #include <linux/parser.h>
 #include <asm/uaccess.h>
 
-#include "rcfs.h"
-#include "MOVETOCORE.h"
+#include <linux/rcfs.h>
 #include "magic.h"
 
 
-/* Token matching for parsing input to this magic file */
-
-//NOTNEEDED #define SHARE_UNCHANGED -1
-
 /* Next few are dependent on number of share types */
 
-//NOTNEEDED #define NUM_SHAREVAL 4
 #define SHARES_MAX_INPUT_SIZE  300
 
 /* The enums for the share types should match the indices expected by
@@ -59,6 +53,7 @@
         MY_GUAR, MY_LIM, TOT_GUAR, TOT_LIM, RES_TYPE, SHARE_ERR
 };
 
+/* Token matching for parsing input to this magic file */
 static match_table_t tokens = {
 	{RES_TYPE, "res=%s"},
         {MY_GUAR, "guarantee=%d"},
@@ -136,9 +131,8 @@
 	struct inode *inode = file->f_dentry->d_inode;
 	struct rcfs_inode_info *ri;
 	char *optbuf;
-	int i,done, resid, retval;
+	int done, resid, retval;
 
-	//newval[NUM_SHAREVAL]; ;
 	struct ckrm_shares newshares = {
 		CKRM_SHARE_UNCHANGED,
 		CKRM_SHARE_UNCHANGED,
@@ -170,18 +164,15 @@
 	if (optbuf[count-1] == '\n')
 		optbuf[count-1]='\0';
 
-	/* Set default values */
-	//for (i=0; i<NUM_SHAREVAL; i++)
-	//	newval[i] = SHARE_UNCHANGED;
-
 	done = shares_parse(optbuf, &resid, &newshares);
 	if (!done) {
 		printk(KERN_ERR "Error parsing shares\n");
 		retval = -EINVAL;
 		goto write_out;
 	}
+	printk(KERN_WARNING "resid is %d is_res_regd is %d\n",resid, is_res_regd(resid));
 
-	if (resid && is_res_regd(resid)) {
+	if (is_res_regd(resid)) {
 
 #if 1
 		ckrm_res_callback_t *rcbs = &ckrm_res_ctlrs[resid];
@@ -221,8 +212,6 @@
 	struct ckrm_shares curshares;
 	struct rcfs_inode_info *ri = s->private;
 
-	// USEME struct rcfs_inode_info *rinfo = RCFS_I(s->private) ;
-
 	/* Get and "display" share data for each registered resource.
 	 * Data from each resource is atomic but not across resources
 	 */
@@ -260,7 +249,6 @@
 					   curshares.total_limit);
 			}
 #endif
-//			seq_printf(s,"Fake res output for %d\n",resid);
 		} /* is_res_regd(resid) */
 	} /* for_each_resid(resid) */
 
@@ -285,12 +273,6 @@
 
 		ret = single_open(file, shares_show, (void *)ri);
 	}
-
-	/* Allow core class retrieval using seq_file */
-	/*
-	if (ret)
-		((struct seq_file *)(file->private_data))->private = RCFS_I(file->f_dentry->d_parent->d_inode);
-	*/
 
 	return ret;
 }
diff -Nru a/fs/rcfs/magic_stats.c b/fs/rcfs/magic_stats.c
--- a/fs/rcfs/magic_stats.c	Wed Mar 31 16:53:21 2004
+++ b/fs/rcfs/magic_stats.c	Wed Mar 31 16:53:21 2004
@@ -34,8 +34,7 @@
 #include <linux/parser.h>
 #include <asm/uaccess.h>
 
-#include "rcfs.h"
-#include "MOVETOCORE.h"
+#include <linux/rcfs.h>
 #include "magic.h"
 
 static int 
diff -Nru a/fs/rcfs/magic_target.c b/fs/rcfs/magic_target.c
--- a/fs/rcfs/magic_target.c	Wed Mar 31 16:53:21 2004
+++ b/fs/rcfs/magic_target.c	Wed Mar 31 16:53:21 2004
@@ -2,6 +2,7 @@
  * fs/rcfs/magic_target.c 
  *
  * Copyright (C) Shailabh Nagar,  IBM Corp. 2004
+ * Copyright (C) Vivek Kashyap,  IBM Corp. 2004
  *           
  * 
  * virtual file assisting in reclassification in rcfs. 
@@ -34,8 +35,7 @@
 #include <linux/parser.h>
 #include <asm/uaccess.h>
 
-#include "rcfs.h"
-#include "MOVETOCORE.h"
+#include <linux/rcfs.h>
 #include "magic.h"
 
 
@@ -48,20 +48,28 @@
    the remaining ones are for token matching purposes */
 
 enum target_token_t {
-        PID, RES_TYPE, TARGET_ERR
+        PID, IPV4, IPV6, RES_TYPE, TARGET_ERR
 };
 
 static match_table_t tokens = {
         {PID, "pid=%u"},
+	{IPV4, "ipv4=%s"},
+	{IPV6, "ipv6=%s"},
         {TARGET_ERR, NULL},
 };
 
 
-static int target_parse(char *options, pid_t *mpid )
+struct target_data {
+	int flag;
+	pid_t mpid;
+	char addr[64];
+};
+
+static int target_parse(char *options, struct target_data *value)
 {
 	char *p;
 	int option;
-
+	int flag = TARGET_ERR;
 
 	if (!options)
 		return 1;
@@ -82,10 +90,26 @@
 		switch (token) {
 			
 		case PID:
+			if (flag == TARGET_ERR)
+				flag = PID;
+			else
+				break;
 			if (match_int(args, &option))
 				return 0;
-			*mpid = (pid_t)(option);
+			value->mpid = (pid_t)(option);
+			break;
+
+		case IPV4:
+			if (flag == TARGET_ERR)
+				flag = IPV4;
+			else
+				break;
+			match_strcpy(value->addr,args);
 			break;
+
+		case IPV6:
+			printk(KERN_INFO "rcfs: IPV6 not supported yet\n");
+			return 0;	
 		default:
 			return 0;
 		}
@@ -94,6 +118,16 @@
 	return 1;
 }	
 
+#if 0
+static int
+magic_aton(char *s)
+{
+	// TODO
+	// Add alpha to IP address conversion.
+	return 1;
+}
+#endif
+
 
 static ssize_t
 target_write(struct file *file, const char __user *buf,
@@ -102,9 +136,7 @@
 	struct rcfs_inode_info *ri= RCFS_I(file->f_dentry->d_inode);
 	char *optbuf;
 	int done;
-	pid_t mpid;
-	struct task_struct *mtsk;
-	
+ 	struct target_data value;
 
 	if ((ssize_t) count < 0 || (ssize_t) count > TARGET_MAX_INPUT_SIZE)
 		return -EINVAL;
@@ -121,37 +153,44 @@
 	if (optbuf[count-1] == '\n')
 		optbuf[count-1]='\0';
 
-	done = target_parse(optbuf, &mpid);
+	done = target_parse(optbuf, &value);
 
 	if (!done) {
 		printk(KERN_ERR "Error parsing target \n");
 		goto target_out;
 	}
 
-	/* USEMELATER */
-	   
-	mtsk = find_task_by_pid(mpid);
-	if (!mtsk) {
-		printk(KERN_ERR "No such pid \n");
-		goto target_out;
+	if (value.flag == PID) {
+		ckrm_forced_reclassify_pid(value.mpid, ri->core);
+	}
+
+#ifdef MAGIC_TARGET_TODO
+	else if (value.flag == IPV4) {
+		// Get the socket. Find the listening socket's back-pointer
+		// to ns (set in lopt when SOCKETAQ option chosen). 
+		// Dissociate from old class and join the new one.
+		
+		u32 daddr;
+		u16 dport;
+
+		memset(&saddr, 0, sizeof(saddr));
+
+		daddr = magic_aton(value.addr);
+		dport = magic_aton(value.port);
+
+		local_bh_disable();
+		sk = find_tcpv4_listener_byaddr(daddr,port);
+		sock_hold(sk);
+		local_bh_enable();
+		lock_sock(sk);
+		__sock_put(sk);	
+		ns = tcp_sk(sk)->tp->lopt->ns;
+		ckrm_forced_reclassify_net(ns, ri->core);
+		release_sock(sk);
 	}
 
-#if 0
-	/* Error control ? */
-	if (callbacks_active)
-		if (ckrm_eng_callbacks.relinquish_tsk)
-			(*ckrm_eng_callbacks.relinquish_tsk)(mtsk) ;
-				
-	/* Error control ? */
-	/* Do manual reclassification after CE relinquishes control to
-	   avoid races with other operations which might reclassify task
-	 */
-	ckrm_reclassify_task(mtsk, ri->core);
 #endif
 	
-	
-	printk(KERN_ERR "Reclassifying task pid %d cmd %s \n",
-	       (int) mpid, mtsk->comm);
 	
 
 target_out:	
diff -Nru a/fs/rcfs/rcfs.h b/fs/rcfs/rcfs.h
--- a/fs/rcfs/rcfs.h	Wed Mar 31 16:53:21 2004
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,49 +0,0 @@
-#ifndef _LINUX_RCFS_H
-#define _LINUX_RCFS_H
-
-#include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/ckrm.h>
-#include <linux/ckrm_rc.h>
-#include <linux/ckrm_res.h>
-#include <linux/ckrm_ce.h>
-
-
-
-/* The following declarations cannot be included in any of ckrm*.h files without 
-   jumping hoops. Remove later when rearrangements done */
-
-extern ckrm_res_callback_t ckrm_res_ctlrs[CKRM_MAX_RES_CTLRS];
-
-#define RCFS_MAGIC	0x4feedbac
-
-
-typedef struct rcfs_inode_info {
-	/* USEME ckrm_core_class_t *core */
-	void *core;
-	struct inode vfs_inode;
-} rcfs_inode_info_t;
-
-
-inline struct rcfs_inode_info *RCFS_I(struct inode *inode);
-
-
-struct inode *rcfs_get_inode(struct super_block *sb, int mode, dev_t dev);
-int rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev);
-struct dentry * rcfs_create_internal(struct dentry *parent, const char *name, 
-				     int mfmode, int magic);
-
-extern struct super_operations rcfs_super_ops;
-extern struct address_space_operations rcfs_aops;
-
-extern struct inode_operations rcfs_dir_inode_operations;
-extern struct inode_operations rcfs_file_inode_operations;
-
-extern struct file_operations target_fileops;
-extern struct file_operations shares_fileops;
-extern struct file_operations stats_fileops;
-extern struct file_operations config_fileops;
-extern struct file_operations members_fileops;
-extern struct file_operations rcfs_file_operations;
-
-#endif /* _LINUX_RCFS_H */ 
diff -Nru a/fs/rcfs/super.c b/fs/rcfs/super.c
--- a/fs/rcfs/super.c	Wed Mar 31 16:53:21 2004
+++ b/fs/rcfs/super.c	Wed Mar 31 16:53:21 2004
@@ -39,8 +39,7 @@
 
 #include <asm/uaccess.h>
 
-#include "rcfs.h"
-#include "MOVETOCORE.h"
+#include <linux/rcfs.h>
 
 
 
@@ -93,32 +92,23 @@
 
 void rcfs_destroy_inodecache(void)
 {
+	printk(KERN_WARNING "destroy inodecache was called\n");
 	if (kmem_cache_destroy(rcfs_inode_cachep))
 		printk(KERN_INFO "rcfs_inode_cache: not all structures were freed\n");
 }
 
+
 /* exported operations */
 struct super_operations rcfs_super_ops =
 {
 	.alloc_inode	= rcfs_alloc_inode,
 	.destroy_inode	= rcfs_destroy_inode,
-//	.clear_inode	= rcfs_clear_inode,
 	.statfs		= simple_statfs,
 	.drop_inode     = generic_delete_inode,
 };
 
 
 
-/*
-static 
-int res_initialize(void)
-{
-
-	printk (KERN_ERR "initialized res_ctrlr data in rcfs\n");
-	return 0;
-}
-*/
-
 struct dentry *rcfs_rootde, *rcfs_nwde, *rcfs_nw_aqde;
 struct inode *rcfs_root, *rcfs_nw, *rcfs_nw_aq;
 struct rcfs_inode_info *rcfs_rootri, *rcfs_nwri;
@@ -128,8 +118,6 @@
 	struct inode * inode;
 	struct dentry * root;
 	struct rcfs_inode_info *rootri;
-	struct ckrm_core_class *core ;
-	struct task_struct *tsk;
 
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
@@ -150,16 +138,23 @@
 
 	rootri = RCFS_I(inode);
 	rootri->core = &ckrm_dflt_class;
-	ckrm_dflt_class.dentry = rcfs_rootde;
 
 
 	rcfs_root = inode;
 	rcfs_rootde = root ;
 	rcfs_rootri = rootri ;
 
+	ckrm_dflt_class.dentry = rcfs_rootde;
+
 
 	printk("get_alloc_super: root class created (%s, de-%p ri-%p in-%p ri->core-%p ri->core->in-%p",root->d_name.name, root, rootri, inode, rootri->core, ((struct ckrm_core_class *)(rootri->core))->dentry);
 	
+#ifdef CONFIG_CKRM_RES_SOCKETAQ
+
+	// Currently both /rcfs/network and /rcfs/network/socket_aq are configured by 
+	// the same option. 
+
+
 	// Create the network root
 	// XXX -- add error reporting
 	rcfs_nwde = rcfs_create_internal(rcfs_rootde, "network", 
@@ -178,33 +173,8 @@
 		ckrm_alloc_core_class((ckrm_core_class_t *)&ckrm_net_root,
 						rcfs_nw_aqde);
 
-#if 0
-	core = &ckrm_dflt_class ;
-	spin_lock(&core->ckrm_lock);
-
-	
-	read_lock(&tasklist_lock);
-	for_each_process(tsk) {
-		
-		/* Should take a task lock here but its too early for any other
-		   CKRM component to touch the element. So safe to modify directly.
-		*/
-		task_lock(tsk);
-		tsk->ckrm_core = core;
-		INIT_LIST_HEAD(&tsk->ckrm_link);
-		list_add(&tsk->ckrm_link, &core->tasklist);
-		printk("ckrm_init: Added %ld to %p\n",(long)tsk->pid,core);
-		task_unlock(tsk);
-	}
-	read_unlock(&tasklist_lock);
-
-	spin_unlock(&core->ckrm_lock);	
 #endif
-	
-	// Other post-mount initializations here */
-	//if (res_initialize())
-	//	return -EINVAL;
-	
+
 	return 0;
 	
 }
@@ -247,9 +217,9 @@
 	unregister_filesystem(&rcfs_fs_type);
 }
 
-
 module_init(init_rcfs_fs)
 module_exit(exit_rcfs_fs)
 
 
+EXPORT_SYMBOL(RCFS_I);
 MODULE_LICENSE("GPL");
diff -Nru a/include/linux/rcfs.h b/include/linux/rcfs.h
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/include/linux/rcfs.h	Wed Mar 31 16:53:21 2004
@@ -0,0 +1,56 @@
+#ifndef _LINUX_RCFS_H
+#define _LINUX_RCFS_H
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/ckrm.h>
+#include <linux/ckrm_rc.h>
+#include <linux/ckrm_res.h>
+#include <linux/ckrm_ce.h>
+
+
+
+/* The following declarations cannot be included in any of ckrm*.h files without 
+   jumping hoops. Remove later when rearrangements done */
+
+extern ckrm_res_callback_t ckrm_res_ctlrs[CKRM_MAX_RES_CTLRS];
+
+#define RCFS_MAGIC	0x4feedbac
+
+
+typedef struct rcfs_inode_info {
+	/* USEME ckrm_core_class_t *core */
+	void *core;
+	struct inode vfs_inode;
+} rcfs_inode_info_t;
+
+
+inline struct rcfs_inode_info *RCFS_I(struct inode *inode);
+
+
+struct inode *rcfs_get_inode(struct super_block *sb, int mode, dev_t dev);
+int rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev);
+int rcfs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+struct dentry * rcfs_create_internal(struct dentry *parent, const char *name, int mfmode, 
+				     int magic);
+void rcfs_make_core(struct dentry *sp, struct ckrm_core_class *core);
+
+
+int rcfs_delete_internal(struct dentry *mfdentry);
+int rcfs_clear_magic(struct dentry *parent);
+
+
+extern struct super_operations rcfs_super_ops;
+extern struct address_space_operations rcfs_aops;
+
+extern struct inode_operations rcfs_dir_inode_operations;
+extern struct inode_operations rcfs_file_inode_operations;
+
+extern struct file_operations target_fileops;
+extern struct file_operations shares_fileops;
+extern struct file_operations stats_fileops;
+extern struct file_operations config_fileops;
+extern struct file_operations members_fileops;
+extern struct file_operations rcfs_file_operations;
+
+#endif /* _LINUX_RCFS_H */ 
