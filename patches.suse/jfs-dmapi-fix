Index: linux-2.6.5/fs/jfs/dmapi/dmapi_jfs.c
===================================================================
--- linux-2.6.5.orig/fs/jfs/dmapi/dmapi_jfs.c
+++ linux-2.6.5/fs/jfs/dmapi/dmapi_jfs.c
@@ -40,6 +40,10 @@
 #include <linux/buffer_head.h>
 #include <linux/mm.h>
 #include <linux/security.h>
+#ifdef CONFIG_COMPAT
+#include <linux/ioctl.h>
+#include <linux/ioctl32.h>
+#endif
 #include "dmapi_private.h"
 #include "jfs_debug.h"
 #include "jfs_incore.h"
@@ -52,12 +56,12 @@
 /* Here's what's left to be done:
  * Figure out locktype in jfs_dm_send_data_event()
  * Figure out how to get name of mounted dir for mount event without stupid 
- *   mount option
+ *   mount option (mtpt=)
  * Add jfs_dm_get_bulkattr (although unused by TSM)
  * Add DM_EVENT_NOSPACE (VERY intrusive to JFS code)
- * Finish up dt_change (may not cover all yet)
- * ? Whazzup with the dump under debug spinlock?
- * ? Whazzup with unmount hang under debug spinlock?
+ * Finish up dt_change (may not cover all cases yet)
+ * ? Whazzup with the dump under sleep-inside-spinlock checking?
+ * ? Whazzup with unmount hang under spinlock debugging?
  */
 
 /* XFS bugs fixed from original port
@@ -158,7 +162,7 @@ STATIC	dm_size_t  dm_min_dio_xfer = 0; /
 #define DM_MAX_ATTR_BYTES_ON_DESTROY	256
 
 #define DM_STAT_SIZE(mask, namelen)	\
-	(sizeof(dm_stat_t) + \
+	(sizeof(dm_stat32_t) + \
 	 (((mask) & DM_AT_HANDLE) ? sizeof(jfs_handle_t) : 0) + (namelen))
 #define MAX_DIRENT_SIZE		(sizeof(dirent_t) + JFS_NAME_MAX + 1)
 
@@ -461,7 +465,7 @@ STATIC void
 jfs_ip_to_stat(
 	struct inode	*ip,
 	u_int		mask,
-	dm_stat_t	*buf)
+	dm_stat32_t	*buf)
 {
 	int		filetype;
 	struct jfs_inode_info *jfs_ip = JFS_IP(ip);
@@ -549,11 +553,11 @@ jfs_dm_bulkstat_one(
 	int		*res)		/* bulkstat result code */
 {
 	struct inode	*ip;
-	dm_stat_t	*buf;
+	dm_stat32_t	*buf;
 	jfs_handle_t	handle;
 	u_int		statstruct_sz;
 
-	buf = (dm_stat_t *)buffer;
+	buf = (dm_stat32_t *)buffer;
 
 	ip = iget(mp->i_sb, ino);
 	if (!ip) {
@@ -587,8 +591,8 @@ jfs_dm_bulkstat_one(
 		dm_ip_to_handle(ip, &handle);
 		memcpy(buf+1, &handle, sizeof(handle));	/* handle follows stat struct */
 
-		buf->dt_handle.vd_offset = (ssize_t) sizeof(dm_stat_t);
-		buf->dt_handle.vd_length = (size_t) JFS_HSIZE(handle);
+		buf->dt_handle.vd_offset = (int) sizeof(dm_stat_t);
+		buf->dt_handle.vd_length = (unsigned int) JFS_HSIZE(handle);
 
 		statstruct_sz = (statstruct_sz+(DM_STAT_ALIGN-1)) & ~(DM_STAT_ALIGN-1);
 	} else {
@@ -709,7 +713,7 @@ jfs_dirents_to_stats(
 	size_t		*offlastlinkp)  /* offset of last stat's _link */
 {
 	struct jfs_dirent *p;
-	dm_stat_t	*statp;
+	dm_stat32_t	*statp;
 	size_t		reclen;
 	size_t		namelen;
 	size_t		spaceleft;
@@ -737,7 +741,7 @@ jfs_dirents_to_stats(
 	 * is full.
 	 */
 	p = direntp;
-	statp = (dm_stat_t *) bufp;
+	statp = (dm_stat32_t *) bufp;
 	for (reclen = (size_t) sizeof(struct jfs_dirent) + p->name_len + 1; 
 					*direntbufsz > 0;
 					*direntbufsz -= reclen,
@@ -763,7 +767,7 @@ jfs_dirents_to_stats(
 			return(0);
 		}
 
-		statp = (dm_stat_t *) bufp;
+		statp = (dm_stat32_t *) bufp;
 
 		(void)jfs_dm_bulkstat_one(ip, mask, 0, p->ino, statp, &res);
 		if (res != BULKSTAT_RV_DIDONE)
@@ -1132,7 +1136,7 @@ jfs_dm_rdwr(
 			 * undo that because this I/O was supposed to be invisible.
                          */
 			struct timespec save_atime = ip->i_atime;
-			xfer = generic_file_read(&file, bufp, len, &off);
+			xfer = generic_file_read(&file, bufp, len, (loff_t *)&off);
 			ip->i_atime = save_atime;
 	                mark_inode_dirty(ip);
 	} else {
@@ -1142,7 +1146,7 @@ jfs_dm_rdwr(
 			 */
 			struct timespec save_mtime = ip->i_mtime;
 			struct timespec save_ctime = ip->i_ctime;
-			xfer = generic_file_write(&file, bufp, len, &off);
+			xfer = generic_file_write(&file, bufp, len, (loff_t *)&off);
 			ip->i_mtime = save_mtime;
 			ip->i_ctime = save_ctime;
 	                mark_inode_dirty(ip);
@@ -1515,7 +1519,7 @@ jfs_dm_get_bulkattr_rvp(
 
 	nelems = buflen / statstruct_sz;
 	if (nelems < 1) {
-		if (put_user( statstruct_sz, rlenp ))
+		if (put_user( statstruct_sz, (size32_t *)rlenp ))
 			return(-EFAULT);
 		return(-E2BIG);
 	}
@@ -1533,7 +1537,7 @@ jfs_dm_get_bulkattr_rvp(
 		*rvalp = 0;
 	}
 
-	if (put_user( statstruct_sz * nelems, rlenp ))
+	if (put_user( statstruct_sz * nelems, (size32_t *)rlenp ))
 		return(-EFAULT);
 
 	if (copy_to_user( locp, &loc, sizeof(loc)))
@@ -1764,7 +1768,8 @@ jfs_dm_get_dirattrs_rvp(
 	int		*rvp)
 {
 	size_t		direntbufsz, statbufsz;
-	size_t		nread, spaceleft, nwritten=0, totnwritten=0;
+	size_t		nread, spaceleft, nwritten=0;
+	size32_t	totnwritten=0;
 	void		*direntp, *statbufp;
 	int		error;
 	dm_attrloc_t	loc, dirloc;
@@ -1900,7 +1905,7 @@ jfs_dm_get_dirattrs_rvp(
 	kmem_free(statbufp, statbufsz);
 	kmem_free(direntp, direntbufsz);
 	if (!error){
-		if (put_user(totnwritten, rlenp))
+		if (put_user(totnwritten, (size32_t *)rlenp))
 			return(-EFAULT);
 	}
 
@@ -1978,7 +1983,7 @@ jfs_dm_get_dmattr(
 	if (!error && copy_to_user(bufp, value, value_len))
 		error = -EFAULT;
 	if (!error || error == -E2BIG) {
-		if (put_user(value_len, rlenp))
+		if (put_user(value_len, (size32_t *)rlenp))
 			error = -EFAULT;
 	}
 
@@ -2016,7 +2021,7 @@ jfs_dm_get_fileattr(
 	u_int		mask,		/* not used; always return everything */
 	dm_stat_t	*statp)
 {
-	dm_stat_t	stat;
+	dm_stat32_t	stat;
 
 	if (right < DM_RIGHT_SHARED)
 		return(-EACCES);
@@ -2029,9 +2034,10 @@ jfs_dm_get_fileattr(
 	   field so user will see it didn't change as there is no error 
 	   indication returned */
 	if ((mask & DM_AT_DTIME) && (!jfs_dmattr_exist(ip))) {
+		dm_stat32_t *stat32p = (dm_stat32_t *)statp;
 		mask = mask & (~DM_AT_DTIME);
 		if (copy_from_user(&stat.dt_dtime,
-				   &statp->dt_dtime,
+				   &stat32p->dt_dtime,
 				   sizeof(stat.dt_dtime)))
 			return(-EFAULT);
 	}
@@ -2209,7 +2215,7 @@ jfs_dm_getall_dmattr(
 		   keep track of the number of bytes for the user's
 		   next call.
 		*/
-		size_needed = sizeof(*ulist) + ea->valuelen;
+		size_needed = sizeof(*ulist) + le16_to_cpu(ea->valuelen);
 		size_needed = (size_needed + alignment) & ~alignment;
 
 		req_size += size_needed;
@@ -2244,13 +2250,13 @@ jfs_dm_getall_dmattr(
 		   keep track of the number of bytes for the user's
 		   next call.
 		*/
-		size_needed = sizeof(*ulist) + ea->valuelen;
+		size_needed = sizeof(*ulist) + le16_to_cpu(ea->valuelen);
 		size_needed = (size_needed + alignment) & ~alignment;
 
 		strncpy((char *)ulist->al_name.an_chars, user_name,
 				DM_ATTR_NAME_SIZE);
 		ulist->al_data.vd_offset = sizeof(*ulist);
-		ulist->al_data.vd_length = ea->valuelen;
+		ulist->al_data.vd_length = le16_to_cpu(ea->valuelen);
 		ulist->_link =	size_needed;
 		last_link = &ulist->_link;
 
@@ -2262,7 +2268,7 @@ jfs_dm_getall_dmattr(
 
 		memcpy((void *)(ulist + 1),
 		       (char *)ea + sizeof(ea) + ea->namelen + 1,
-		       ea->valuelen);
+		       le16_to_cpu(ea->valuelen));
 
 		ulist = (dm_attrlist_t *)((char *)ulist + ulist->_link);
 	}
@@ -2279,7 +2285,7 @@ error_return:	
 	up_read(&JFS_IP(ip)->xattr_sem);
 
 	if (!error || error == -E2BIG) {
-		if (put_user(req_size, rlenp))
+		if (put_user(req_size, (size32_t *)rlenp))
 			error = -EFAULT;
 	}
 
@@ -2908,7 +2914,7 @@ jfs_dm_set_fileattr(
 	u_int		mask,
 	dm_fileattr_t	*statp)
 {
-	dm_fileattr_t	stat;
+	dm_fileattr32_t	stat;
 	struct iattr	at;
 	int		error;
 
@@ -3490,14 +3496,101 @@ jfs_dm_send_mmap_event(
 	return ret;
 }
 
+#ifdef CONFIG_COMPAT
+static struct {
+	unsigned int cmd;
+	int          reg;
+} ioctl32_cmds[] = {
+	{ .cmd = JFS_DM_IOC_CLEAR_INHERIT },
+	{ .cmd = JFS_DM_IOC_CREATE_BY_HANDLE },
+	{ .cmd = JFS_DM_IOC_CREATE_SESSION },
+	{ .cmd = JFS_DM_IOC_CREATE_USEREVENT },
+	{ .cmd = JFS_DM_IOC_DESTROY_SESSION },
+	{ .cmd = JFS_DM_IOC_DOWNGRADE_RIGHT },
+	{ .cmd = JFS_DM_IOC_FD_TO_HANDLE },
+	{ .cmd = JFS_DM_IOC_FIND_EVENTMSG },
+	{ .cmd = JFS_DM_IOC_GET_ALLOCINFO },
+	{ .cmd = JFS_DM_IOC_GET_BULKALL },
+	{ .cmd = JFS_DM_IOC_GET_BULKATTR },
+	{ .cmd = JFS_DM_IOC_GET_CONFIG },
+	{ .cmd = JFS_DM_IOC_GET_CONFIG_EVENTS },
+	{ .cmd = JFS_DM_IOC_GET_DIRATTRS },
+	{ .cmd = JFS_DM_IOC_GET_DMATTR },
+	{ .cmd = JFS_DM_IOC_GET_EVENTLIST },
+	{ .cmd = JFS_DM_IOC_GET_EVENTS },
+	{ .cmd = JFS_DM_IOC_GET_FILEATTR },
+	{ .cmd = JFS_DM_IOC_GET_MOUNTINFO },
+	{ .cmd = JFS_DM_IOC_GET_REGION },
+	{ .cmd = JFS_DM_IOC_GETALL_DISP },
+	{ .cmd = JFS_DM_IOC_GETALL_DMATTR },
+	{ .cmd = JFS_DM_IOC_GETALL_INHERIT },
+	{ .cmd = JFS_DM_IOC_GETALL_SESSIONS },
+	{ .cmd = JFS_DM_IOC_GETALL_TOKENS },
+	{ .cmd = JFS_DM_IOC_INIT_ATTRLOC },
+	{ .cmd = JFS_DM_IOC_MKDIR_BY_HANDLE },
+	{ .cmd = JFS_DM_IOC_MOVE_EVENT },
+	{ .cmd = JFS_DM_IOC_OBJ_REF_HOLD },
+	{ .cmd = JFS_DM_IOC_OBJ_REF_QUERY },
+	{ .cmd = JFS_DM_IOC_OBJ_REF_RELE },
+	{ .cmd = JFS_DM_IOC_PATH_TO_FSHANDLE },
+	{ .cmd = JFS_DM_IOC_PATH_TO_HANDLE },
+	{ .cmd = JFS_DM_IOC_PENDING },
+	{ .cmd = JFS_DM_IOC_PROBE_HOLE },
+	{ .cmd = JFS_DM_IOC_PUNCH_HOLE },
+	{ .cmd = JFS_DM_IOC_QUERY_RIGHT },
+	{ .cmd = JFS_DM_IOC_QUERY_SESSION },
+	{ .cmd = JFS_DM_IOC_READ_INVIS },
+	{ .cmd = JFS_DM_IOC_RELEASE_RIGHT },
+	{ .cmd = JFS_DM_IOC_REMOVE_DMATTR },
+	{ .cmd = JFS_DM_IOC_REQUEST_RIGHT },
+	{ .cmd = JFS_DM_IOC_RESPOND_EVENT },
+	{ .cmd = JFS_DM_IOC_SEND_MSG },
+	{ .cmd = JFS_DM_IOC_SET_DISP },
+	{ .cmd = JFS_DM_IOC_SET_DMATTR },
+	{ .cmd = JFS_DM_IOC_SET_EVENTLIST },
+	{ .cmd = JFS_DM_IOC_SET_FILEATTR },
+	{ .cmd = JFS_DM_IOC_SET_INHERIT },
+	{ .cmd = JFS_DM_IOC_SET_REGION },
+	{ .cmd = JFS_DM_IOC_SET_RETURN_ON_DESTROY },
+	{ .cmd = JFS_DM_IOC_SYMLINK_BY_HANDLE },
+	{ .cmd = JFS_DM_IOC_SYNC_BY_HANDLE },
+	{ .cmd = JFS_DM_IOC_UPGRADE_RIGHT },
+	{ .cmd = JFS_DM_IOC_WRITE_INVIS },
+	{ .cmd = JFS_DM_IOC_OPEN_BY_HANDLE },
+	{ .cmd = JFS_DM_IOC_HANDLE_TO_PATH },
+};
+#endif
+
 void __init
 jfs_dm_init(void)
 {
+#ifdef CONFIG_COMPAT
+	unsigned int i;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(ioctl32_cmds); i++) {
+		err = register_ioctl32_conversion(ioctl32_cmds[i].cmd, NULL);
+		if (err >= 0)
+			ioctl32_cmds[i].reg++;
+		else
+			printk(KERN_ERR "jfs_dm_init: unable to register ioctl %x, err = %d\n", ioctl32_cmds[i].cmd, err);
+	}
+#endif
 }
 
 void __exit
 jfs_dm_exit(void)
 {
+#ifdef CONFIG_COMPAT
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(ioctl32_cmds); i++) {
+		if (ioctl32_cmds[i].reg) {
+			unregister_ioctl32_conversion(ioctl32_cmds[i].cmd);
+			ioctl32_cmds[i].reg--;
+		}
+	}
+#endif
 }
 
 /*
Index: linux-2.6.5/fs/jfs/dmapi/dmapi_kern.h
===================================================================
--- linux-2.6.5.orig/fs/jfs/dmapi/dmapi_kern.h
+++ linux-2.6.5/fs/jfs/dmapi/dmapi_kern.h
@@ -47,7 +47,24 @@ struct sys_dmapi_args {
 typedef struct sys_dmapi_args sys_dmapi_args_t;
 
 #define DM_Uarg(uap,i)	uap->uarg##i.u
-#define DM_Parg(uap,i)	uap->uarg##i.p
+/* The original XFS code used uap->uarg##i.p for pointers, but this caused a 
+   problem on 64-bit platforms because the DMAPI library is 32-bits so there
+   was a conflict in sizeof(void *) between user and kernel space.  This has
+   been fixed by overloading uap->uarg##i.u - in this manner the 32-bit user
+   space address will be stored in the low DWORD of u while the high DWORD
+   will be zero, thus creating a 64-bit address that can be accessed by the
+   kernel.
+*/
+#ifdef __KERNEL__
+  #ifdef CONFIG_COMPAT
+    #define DM_Parg(uap,i)      uap->uarg##i.u
+  #else
+    #define DM_Parg(uap,i)      (__u32)uap->uarg##i.u
+  #endif
+#else
+    #define DM_Parg(uap,i)      uap->uarg##i.u
+#endif
+
 
 #ifdef __KERNEL__
 
@@ -487,7 +504,69 @@ typedef struct dm_fcntl_mapevent dm_fcnt
 */
 
 #define DM_MAX_HANDLE_SIZE	56	/* maximum size for a file handle */
+typedef char dm_handle_t[DM_MAX_HANDLE_SIZE];
+typedef __u32 size32_t;
+struct dm_fileattr32 {
+	dm_mode_t       fa_mode;
+	uid_t           fa_uid;
+	gid_t           fa_gid;
+	u_int           fa_atime;
+	u_int           fa_mtime;
+	u_int           fa_ctime;
+	u_int           fa_dtime;
+	unsigned int    fa_pad1;                /* reserved; do not reference */
+	dm_off_t        fa_size;
+};
+typedef struct dm_fileattr32 dm_fileattr32_t;
 
+struct dm_stat32 {
+	int		_link;
+	dm_vardata_t	dt_handle;
+	dm_vardata_t	dt_compname;
+	int		dt_nevents;
+	dm_eventset_t	dt_emask;
+	int		dt_pers;
+	int		dt_pmanreg;
+	u_int		dt_dtime;
+	unsigned int	dt_change;
+	unsigned int	dt_pad1;		/* reserved; do not reference */
+	dm_dev_t	dt_dev;
+	dm_ino_t	dt_ino;
+	dm_mode_t	dt_mode;
+	dm_nlink_t	dt_nlink;
+	uid_t		dt_uid;
+	gid_t		dt_gid;
+	dm_dev_t	dt_rdev;
+	unsigned int	dt_pad2;		/* reserved; do not reference */
+	dm_off_t	dt_size;
+	u_int		dt_atime;
+	u_int		dt_mtime;
+	u_int		dt_ctime;
+	unsigned int	dt_blksize;
+	dm_size_t	dt_blocks;
+
+	/* Non-standard filesystem-specific fields.
+	*/
+
+	__u64	dt_pad3;	/* reserved; do not reference */
+	int		dt_fstype;	/* filesystem index; see sysfs(2) */
+	union	{
+		struct	{
+			dm_igen_t	igen;
+			unsigned int	xflags;
+			unsigned int	extsize;
+			unsigned int	extents;
+			unsigned short	aextents;
+			unsigned short	dmstate;
+		} sgi_xfs;
+	} fsys_dep;
+};
+typedef struct dm_stat32 dm_stat32_t;
+struct	dm_timestruct32 {
+	u_int		dm_tv_sec;
+	int		dm_tv_nsec;
+};
+typedef struct dm_timestruct32 dm_timestruct32_t;
 
 /*
  *  Opcodes for dmapi ioctl.
@@ -551,4 +630,120 @@ typedef struct dm_fcntl_mapevent dm_fcnt
 #define DM_OPEN_BY_HANDLE	56
 #define DM_HANDLE_TO_PATH	57				// XFS BUG #12
 
+#define JFS_DM_IOCTL_TYPE 0xDB
+
+#define JFS_DM_IOC_CLEAR_INHERIT \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_CLEAR_INHERIT, dm_attrname_t)
+#define JFS_DM_IOC_CREATE_BY_HANDLE \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_CREATE_BY_HANDLE, dm_handle_t)
+#define JFS_DM_IOC_CREATE_SESSION \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_CREATE_SESSION, dm_sessid_t)
+#define JFS_DM_IOC_CREATE_USEREVENT \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_CREATE_USEREVENT, dm_token_t)
+#define JFS_DM_IOC_DESTROY_SESSION \
+	_IO(JFS_DM_IOCTL_TYPE, DM_DESTROY_SESSION)
+#define JFS_DM_IOC_DOWNGRADE_RIGHT \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_DOWNGRADE_RIGHT, dm_handle_t)
+#define JFS_DM_IOC_FD_TO_HANDLE \
+	_IOR(JFS_DM_IOCTL_TYPE, DM_FD_TO_HANDLE, dm_handle_t)
+#define JFS_DM_IOC_FIND_EVENTMSG \
+	_IOR(JFS_DM_IOCTL_TYPE, DM_FIND_EVENTMSG, dm_eventmsg_t)
+#define JFS_DM_IOC_GET_ALLOCINFO \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_ALLOCINFO, dm_extent_t)
+#define JFS_DM_IOC_GET_BULKALL \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_BULKALL, dm_stat32_t)
+#define JFS_DM_IOC_GET_BULKATTR \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_BULKATTR, dm_stat32_t)
+#define JFS_DM_IOC_GET_CONFIG \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_CONFIG, dm_size_t)
+#define JFS_DM_IOC_GET_CONFIG_EVENTS \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_CONFIG_EVENTS, dm_eventset_t)
+#define JFS_DM_IOC_GET_DIRATTRS \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_DIRATTRS, dm_stat32_t)
+#define JFS_DM_IOC_GET_DMATTR \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_DMATTR, size32_t)
+#define JFS_DM_IOC_GET_EVENTLIST \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_EVENTLIST, dm_eventset_t)
+#define JFS_DM_IOC_GET_EVENTS \
+	_IOR(JFS_DM_IOCTL_TYPE, DM_GET_EVENTS, dm_eventmsg_t)
+#define JFS_DM_IOC_GET_FILEATTR \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_FILEATTR, dm_stat32_t)
+#define JFS_DM_IOC_GET_MOUNTINFO \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_MOUNTINFO, dm_mount_event_t)
+#define JFS_DM_IOC_GET_REGION \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GET_REGION, dm_region_t)
+#define JFS_DM_IOC_GETALL_DISP \
+	_IOR(JFS_DM_IOCTL_TYPE, DM_GETALL_DISP, dm_dispinfo_t)
+#define JFS_DM_IOC_GETALL_DMATTR \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GETALL_DMATTR, dm_attrlist_t)
+#define JFS_DM_IOC_GETALL_INHERIT \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_GETALL_INHERIT, dm_inherit_t)
+#define JFS_DM_IOC_GETALL_SESSIONS \
+	_IOR(JFS_DM_IOCTL_TYPE, DM_GETALL_SESSIONS, dm_sessid_t)
+#define JFS_DM_IOC_GETALL_TOKENS \
+	_IOR(JFS_DM_IOCTL_TYPE, DM_GETALL_TOKENS, dm_token_t)
+#define JFS_DM_IOC_INIT_ATTRLOC \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_INIT_ATTRLOC, dm_attrloc_t)
+#define JFS_DM_IOC_MKDIR_BY_HANDLE \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_MKDIR_BY_HANDLE, dm_handle_t)
+#define JFS_DM_IOC_MOVE_EVENT \
+	_IOR(JFS_DM_IOCTL_TYPE, DM_MOVE_EVENT, dm_token_t)
+#define JFS_DM_IOC_OBJ_REF_HOLD \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_OBJ_REF_HOLD, dm_handle_t)
+#define JFS_DM_IOC_OBJ_REF_QUERY \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_OBJ_REF_QUERY, dm_handle_t)
+#define JFS_DM_IOC_OBJ_REF_RELE \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_OBJ_REF_RELE, dm_handle_t)
+#define JFS_DM_IOC_PATH_TO_FSHANDLE \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_PATH_TO_FSHANDLE, dm_handle_t)
+#define JFS_DM_IOC_PATH_TO_HANDLE \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_PATH_TO_HANDLE, dm_handle_t)
+#define JFS_DM_IOC_PENDING \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_PENDING, dm_timestruct32_t)
+#define JFS_DM_IOC_PROBE_HOLE \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_PROBE_HOLE, dm_off_t)
+#define JFS_DM_IOC_PUNCH_HOLE \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_PUNCH_HOLE, dm_handle_t)
+#define JFS_DM_IOC_QUERY_RIGHT \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_QUERY_RIGHT, dm_right_t)
+#define JFS_DM_IOC_QUERY_SESSION \
+	_IOR(JFS_DM_IOCTL_TYPE, DM_QUERY_SESSION, size32_t)
+#define JFS_DM_IOC_READ_INVIS \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_READ_INVIS, dm_handle_t)
+#define JFS_DM_IOC_RELEASE_RIGHT \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_RELEASE_RIGHT, dm_handle_t)
+#define JFS_DM_IOC_REMOVE_DMATTR \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_REMOVE_DMATTR, dm_attrname_t)
+#define JFS_DM_IOC_REQUEST_RIGHT \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_REQUEST_RIGHT, dm_handle_t)
+#define JFS_DM_IOC_RESPOND_EVENT \
+	_IO(JFS_DM_IOCTL_TYPE, DM_RESPOND_EVENT)
+#define JFS_DM_IOC_SEND_MSG \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_SEND_MSG, char)
+#define JFS_DM_IOC_SET_DISP \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_SET_DISP, dm_eventset_t)
+#define JFS_DM_IOC_SET_DMATTR \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_SET_DMATTR, dm_attrname_t)
+#define JFS_DM_IOC_SET_EVENTLIST \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_SET_EVENTLIST, dm_eventset_t)
+#define JFS_DM_IOC_SET_FILEATTR \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_SET_FILEATTR, dm_fileattr32_t)
+#define JFS_DM_IOC_SET_INHERIT \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_SET_INHERIT, dm_attrname_t)
+#define JFS_DM_IOC_SET_REGION \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_SET_REGION, dm_boolean_t)
+#define JFS_DM_IOC_SET_RETURN_ON_DESTROY \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_SET_RETURN_ON_DESTROY, dm_attrname_t)
+#define JFS_DM_IOC_SYMLINK_BY_HANDLE \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_SYMLINK_BY_HANDLE, dm_handle_t)
+#define JFS_DM_IOC_SYNC_BY_HANDLE \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_SYNC_BY_HANDLE, dm_handle_t)
+#define JFS_DM_IOC_UPGRADE_RIGHT \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_UPGRADE_RIGHT, dm_handle_t)
+#define JFS_DM_IOC_WRITE_INVIS \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_WRITE_INVIS, dm_handle_t)
+#define JFS_DM_IOC_OPEN_BY_HANDLE \
+	_IOW(JFS_DM_IOCTL_TYPE, DM_OPEN_BY_HANDLE, dm_handle_t)
+#define JFS_DM_IOC_HANDLE_TO_PATH \
+	_IOWR(JFS_DM_IOCTL_TYPE, DM_HANDLE_TO_PATH, size32_t)
 #endif /* __DMAPI_KERN_H__ */
Index: linux-2.6.5/fs/jfs/dmapi/dmapi_register.c
===================================================================
--- linux-2.6.5.orig/fs/jfs/dmapi/dmapi_register.c
+++ linux-2.6.5/fs/jfs/dmapi/dmapi_register.c
@@ -873,7 +873,7 @@ dm_path_to_hdl(
 
 	if (copy_to_user(hanp, &handle, (int)hlen))
 		return(-EFAULT);
-	if (put_user(hlen,hlenp))
+	if (put_user(hlen,(size32_t *)hlenp))
 		return(-EFAULT);
 	return(0);
 }
@@ -990,7 +990,7 @@ dm_hdl_to_path(
 
 	/* Copy information back to user space */
 	if ((copy_to_user(pathbufp, totpath, pathlen)) ||
-	    (copy_to_user(rlenp, &pathlen, sizeof(pathlen)))) {
+	    (put_user(pathlen, (size32_t *)rlenp))) {
 		error = -EFAULT;
 		goto free_name2;
 	}		
@@ -1077,7 +1077,7 @@ dm_path_to_fshdl(
 	hlen = FSHSIZE;
 	if(copy_to_user(hanp, &handle, (int)hlen))
 		return(-EFAULT);
-	if (put_user(hlen,hlenp))
+	if (put_user(hlen,(size32_t *)hlenp))
 		return(-EFAULT);
 	return(0);
 }
@@ -1119,7 +1119,7 @@ dm_fd_to_hdl(
 	if (copy_to_user(hanp, &handle, (int)hlen))
 		return(-EFAULT);
 	fput(filep);
-	if (put_user(hlen,hlenp))
+	if (put_user(hlen,(size32_t *)hlenp))
 		return(-EFAULT);
 	return(0);
 }
@@ -1468,7 +1468,7 @@ dm_get_mountinfo(
 
 	/* Copy the message into the user's buffer and update his 'rlenp'. */
 
-	if (put_user(fsrp->fr_msgsize, rlenp)) {
+	if (put_user(fsrp->fr_msgsize, (size32_t *)rlenp)) {
 		error = -EFAULT;
 	} else if (fsrp->fr_msgsize > buflen) { /* user buffer not big enough */
 		error = -E2BIG;
@@ -1535,7 +1535,7 @@ dm_getall_disp(
 	for (;;) {
 		if ((fsyscnt = dm_fsys_cnt) == 0) {
 			/*if (dm_cpoutsizet(rlenp, 0))*/
-			if (put_user(0,rlenp))
+			if (put_user(0,(size32_t *)rlenp))
 				return(-EFAULT);
 			return(0);
 		}
@@ -1602,7 +1602,7 @@ dm_getall_disp(
 	mutex_spinunlock(&s->sn_qlock, lc2);	/* reverse cookie order */
 	mutex_spinunlock(&dm_reg_lock, lc1);
 
-	if (put_user(totalsize, rlenp)) {
+	if (put_user(totalsize, (size32_t *)rlenp)) {
 		error = -EFAULT;
 	} else if (totalsize > buflen) {	/* no more room */
 		error = -E2BIG;
Index: linux-2.6.5/fs/jfs/dmapi/dmapi_session.c
===================================================================
--- linux-2.6.5.orig/fs/jfs/dmapi/dmapi_session.c
+++ linux-2.6.5/fs/jfs/dmapi/dmapi_session.c
@@ -714,7 +714,7 @@ dm_query_session(
 
 	/* Now that the mutex is released, copy the sessinfo to the user. */
 
-	if (put_user(len, rlenp)) {
+	if (put_user(len, (size32_t *)rlenp)) {
 		error = -EFAULT;
 	} else if (len > buflen) {
 		error = -E2BIG;
@@ -858,7 +858,7 @@ dm_find_eventmsg(
 
 	/* Now copy the data to the user. */
 
-	if (put_user(msgsize,rlenp)) {
+	if (put_user(msgsize,(size32_t *)rlenp)) {
 		error = -EFAULT;
 	} else if (msgsize > buflen) {		/* user buffer not big enough */
 		error = -E2BIG;
@@ -942,13 +942,13 @@ dm_pending(
 	dm_tokevent_t	*tevp;
 	int		error;
 	unsigned long	lc;		/* lock cookie */
-	dm_timestruct_t localdelay;				// XFS BUG #38
+	dm_timestruct32_t localdelay;				// XFS BUG #38
 
 	if ((error = dm_find_msg_and_lock(sid, token, &tevp, &lc)) != 0)
 		return(error);
 
 	// XFS BUG #38 START
-	if (copy_from_user(&localdelay, delay, sizeof(dm_timestruct_t))) {
+	if (copy_from_user(&localdelay, delay, sizeof(dm_timestruct32_t))) {
 		mutex_spinunlock(&tevp->te_lock, lc);
 		return(-EFAULT);
 	}
@@ -1069,7 +1069,7 @@ dm_get_events(
 
 		if (totalsize > buflen) {	/* no more room */
 			error = -E2BIG;
-		} else if (put_user(totalsize, rlenp)) {
+		} else if (put_user(totalsize, (size32_t *)rlenp)) {
 			error = -EFAULT;
 		} else if (copy_to_user(bufp, &tevp->te_msg, msgsize)) {
 			error = -EFAULT;
@@ -1098,7 +1098,7 @@ dm_get_events(
 			mutex_spinunlock(&s->sn_qlock, lc1);
 			if (prevmsg)
 				return(0);
-			if (error == -E2BIG && put_user(totalsize,rlenp))
+			if (error == -E2BIG && put_user(totalsize,(size32_t *)rlenp))
 				error = -EFAULT;
 			return(error);
 		}
Index: linux-2.6.5/fs/jfs/dmapi/dmapi_sysent.c
===================================================================
--- linux-2.6.5.orig/fs/jfs/dmapi/dmapi_sysent.c
+++ linux-2.6.5/fs/jfs/dmapi/dmapi_sysent.c
@@ -72,7 +72,7 @@ dmapi_ioctl(struct inode *inode, struct 
 			   sizeof(sys_dmapi_args_t) ) )
 		return -EFAULT;
 
-	switch (cmd) {
+	switch (_IOC_NR(cmd)) {
 	case DM_CLEAR_INHERIT:
 		error = dm_clear_inherit(
 				(dm_sessid_t)	DM_Uarg(uap,1), /* sid */
