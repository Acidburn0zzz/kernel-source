From: Andreas Gruenbacher <agruen@suse.de>
Subject: Fix bug in error path

Signed-off-by: Andreas Gruenbacher <agruen@suse.de>

---
 fs/ext3/nfs4acl.c       |   21 ++++++++-------------
 fs/nfs4acl_base.c       |    2 +-
 fs/nfs4acl_xattr.c      |    4 ++--
 include/linux/nfs4acl.h |   16 ++++++++--------
 4 files changed, 19 insertions(+), 24 deletions(-)

--- linux-2.6.19.orig/fs/ext3/nfs4acl.c
+++ linux-2.6.19/fs/ext3/nfs4acl.c
@@ -95,32 +95,27 @@ int
 ext3_nfs4acl_init(handle_t *handle, struct inode *inode, struct inode *dir)
 {
 	struct nfs4acl *dir_acl, *acl;
-	int retval = 0;
+	int retval;
 
 	BUG_ON(!test_opt(inode->i_sb, NFS4ACL));
 
 	dir_acl = ext3_get_nfs4acl(dir);
-	retval = PTR_ERR(dir_acl);
-	if (!dir_acl || IS_ERR(dir_acl))
-		goto out;
+	if (!dir_acl || IS_ERR(dir_acl)) {
+		retval = PTR_ERR(dir_acl);
+		inode->i_mode &= ~current->fs->umask;
+		return retval;
+	}
 	acl = nfs4acl_inherit(dir_acl, inode->i_mode,
 			      test_opt(inode->i_sb, NFS4ACL_MAX));
 	nfs4acl_free(dir_acl);
 
-	if (IS_ERR(acl))
-		return PTR_ERR(acl);
-	else if (acl) {
+	retval = PTR_ERR(acl);
+	if (acl && !IS_ERR(acl)) {
 		retval = ext3_set_nfs4acl(handle, inode, acl);
 		inode->i_mode = (inode->i_mode & ~S_IRWXUGO) |
 				nfs4acl_masks_to_mode(acl);
 		nfs4acl_free(acl);
-		return retval;
 	}
-
-out:
-	if (!retval)
-		inode->i_mode &= ~current->fs->umask;
-
 	return retval;
 }
 
--- linux-2.6.19.orig/fs/nfs4acl_base.c
+++ linux-2.6.19/fs/nfs4acl_base.c
@@ -188,7 +188,7 @@ static int
 __nfs4acl_permission(struct inode *inode, const struct nfs4acl *acl,
 		     unsigned int mask, int *in_group_class)
 {
-	struct nfs4ace *ace;
+	const struct nfs4ace *ace;
 	int retval = -EACCES;
 
 	nfs4acl_for_each_entry(ace, acl) {
--- linux-2.6.19.orig/fs/nfs4acl_xattr.c
+++ linux-2.6.19/fs/nfs4acl_xattr.c
@@ -105,7 +105,7 @@ size_t
 nfs4acl_xattr_size(const struct nfs4acl *acl)
 {
 	size_t size = sizeof(struct nfs4acl_xattr);
-	struct nfs4ace *ace;
+	const struct nfs4ace *ace;
 
 	nfs4acl_for_each_entry(ace, acl) {
 		size += sizeof(struct nfs4ace_xattr) +
@@ -121,7 +121,7 @@ nfs4acl_to_xattr(const struct nfs4acl *a
 {
 	struct nfs4acl_xattr *xattr_acl = buffer;
 	struct nfs4ace_xattr *xattr_ace;
-	struct nfs4ace *ace;
+	const struct nfs4ace *ace;
 
 	xattr_acl->a_version = ACL4_XATTR_VERSION;
 	xattr_acl->a_flags = 0;
--- linux-2.6.19.orig/include/linux/nfs4acl.h
+++ linux-2.6.19/include/linux/nfs4acl.h
@@ -98,40 +98,40 @@ extern const char *nfs4ace_group_who;
 extern const char *nfs4ace_everyone_who;
 
 static inline int
-nfs4ace_is_owner(struct nfs4ace *ace)
+nfs4ace_is_owner(const struct nfs4ace *ace)
 {
 	return (ace->e_flags & ACE4_SPECIAL_WHO) &&
 	       ace->u.e_who == nfs4ace_owner_who;
 }
 
 static inline int
-nfs4ace_is_group(struct nfs4ace *ace)
+nfs4ace_is_group(const struct nfs4ace *ace)
 {
 	return (ace->e_flags & ACE4_SPECIAL_WHO) &&
 	       ace->u.e_who == nfs4ace_group_who;
 }
 
 static inline int
-nfs4ace_is_everyone(struct nfs4ace *ace)
+nfs4ace_is_everyone(const struct nfs4ace *ace)
 {
 	return (ace->e_flags & ACE4_SPECIAL_WHO) &&
 	       ace->u.e_who == nfs4ace_everyone_who;
 }
 
 static inline int
-nfs4ace_is_unix_id(struct nfs4ace *ace)
+nfs4ace_is_unix_id(const struct nfs4ace *ace)
 {
 	return !(ace->e_flags & ACE4_SPECIAL_WHO);
 }
 
 static inline int
-nfs4ace_is_inherit_only(struct nfs4ace *ace)
+nfs4ace_is_inherit_only(const struct nfs4ace *ace)
 {
 	return ace->e_flags & ACE4_INHERIT_ONLY_ACE;
 }
 
 static inline int
-nfs4ace_is_inheritable(struct nfs4ace *ace)
+nfs4ace_is_inheritable(const struct nfs4ace *ace)
 {
 	return ace->e_flags & (ACE4_FILE_INHERIT_ACE |
 			       ACE4_DIRECTORY_INHERIT_ACE);
@@ -147,13 +147,13 @@ nfs4ace_clear_inheritance_flags(struct n
 }
 
 static inline int
-nfs4ace_is_allow(struct nfs4ace *ace)
+nfs4ace_is_allow(const struct nfs4ace *ace)
 {
 	return ace->e_type == ACE4_ACCESS_ALLOWED_ACE_TYPE;
 }
 
 static inline int
-nfs4ace_is_deny(struct nfs4ace *ace)
+nfs4ace_is_deny(const struct nfs4ace *ace)
 {
 	return ace->e_type == ACE4_ACCESS_DENIED_ACE_TYPE;
 }
