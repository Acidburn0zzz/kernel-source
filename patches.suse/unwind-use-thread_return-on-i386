From: Jeff Mahoney <jeffm@suse.com>
Subject: unwind: use thread_return on i386
Patch-mainline: Depends on patches.suse/DWARF-EH-frame-based-stack-unwinding.patch
References: fixes build failure during merge

thread_struct doesn't have ip on i386 either, so let's use the
thread_return global the same way x86_64 does.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 arch/x86/entry/entry_32.S     |    5 +++++
 arch/x86/include/asm/unwind.h |   10 +---------
 2 files changed, 6 insertions(+), 9 deletions(-)

--- a/arch/x86/entry/entry_32.S
+++ b/arch/x86/entry/entry_32.S
@@ -252,6 +252,11 @@ ENTRY(__switch_to_asm)
 	popl	%ebp
 
 	jmp	__switch_to
+/* The stack unwind code needs this but it pollutes traces otherwise */
+#ifdef CONFIG_UNWIND_INFO
+.globl thread_return
+thread_return:
+#endif
 END(__switch_to_asm)
 
 /*
--- a/arch/x86/include/asm/unwind.h
+++ b/arch/x86/include/asm/unwind.h
@@ -196,7 +196,6 @@ static inline void arch_unw_init_frame_i
 
 static inline void arch_unw_init_blocked(struct unwind_state *info)
 {
-#ifdef CONFIG_X86_64
 	extern const char thread_return[];
 
 	memset(&info->u.regs, 0, sizeof(info->u.regs));
@@ -206,14 +205,7 @@ static inline void arch_unw_init_blocked
 			info->u.regs.bp);
 	info->u.regs.sp = info->task->thread.sp;
 	info->u.regs.ss = __KERNEL_DS;
-#else
-	memset(&info->u.regs, 0, sizeof(info->u.regs));
-	info->u.regs.ip = info->task->thread.ip;
-	info->u.regs.cs = __KERNEL_CS;
-	probe_kernel_address((unsigned long *)info->task->thread.sp,
-			info->u.regs.bp);
-	info->u.regs.sp = info->task->thread.sp;
-	info->u.regs.ss = __KERNEL_DS;
+#ifndef CONFIG_X86_64
 	info->u.regs.ds = __USER_DS;
 	info->u.regs.es = __USER_DS;
 #endif
