Subject: Read DSDT from initrd or initramfs
From: Thomas Renninger <trenn@suse.de>
Patch-mainline: never

Searches and reads in the root of initramfs a DSDT.aml file.
If not found the initrd is scanned for a DSDT signature
("INITRDDSDT123DSDT123"). Once a DSDT in the initramfs or
initrd is found the DSDT provided by BIOS is replaced.

In order for the data to be available, populate_rootfs()
should be called prior to acpi_early_init(). Then, 
the ACPI code can just call sys_open() to get the DSDT.

diff -ruNpX dontdiff linux-2.6.17/drivers/acpi/Kconfig linux-2.6.17.acpi/drivers/acpi/Kconfig
--- linux-2.6.17/drivers/acpi/Kconfig	2006-08-29 11:47:54.000000000 -0400
+++ linux-2.6.17.acpi/drivers/acpi/Kconfig	2006-08-29 11:48:45.000000000 -0400
@@ -362,6 +362,19 @@ config ACPI_SBS
 	  A "Smart Battery" is quite old and quite rare compared
 	  to today's ACPI "Control Method" battery.
 
+config ACPI_INITRD
+	bool "Read DSDT from initrd or initramfs"
+	depends on ACPI && BLK_DEV_INITRD && !ACPI_CUSTOM_DSDT
+	default n
+	help
+	  The DSDT (Differentiated System Description Table) often needs to be
+	  overridden because of broken BIOS implementations. If you want to use
+	  a customized DSDT, please use the mkinitrd tool (mkinitrd package) to
+	  attach the DSDT to the initrd or initramfs
+	  (see http://gaugusch.at/kernel.shtml for details)
+	  If there is no DSDT found in the initrd, the DSDT from the BIOS is
+	  used. It is safe to say yes here.
+
 endif	# ACPI
 
 endmenu
diff -ruNpX dontdiff linux-2.6.17/drivers/acpi/osl.c linux-2.6.17.acpi/drivers/acpi/osl.c
--- linux-2.6.17/drivers/acpi/osl.c	2006-08-29 11:48:01.000000000 -0400
+++ linux-2.6.17.acpi/drivers/acpi/osl.c	2006-08-29 11:48:45.000000000 -0400
@@ -43,6 +43,8 @@
 #include <asm/uaccess.h>
 
 #include <linux/efi.h>
+#include <linux/initrd.h>
+#include <linux/syscalls.h>
 
 #define _COMPONENT		ACPI_OS_SERVICES
 ACPI_MODULE_NAME("osl")
@@ -218,6 +220,79 @@ acpi_os_predefined_override(const struct
 
 	return AE_OK;
 }
+#ifdef CONFIG_ACPI_INITRD
+static const char signature[] = "INITRDDSDT123DSDT123";
+static char ramfs_dsdt_name[] = "/DSDT.aml";
+
+static char *acpi_find_dsdt_initrd(void)
+{
+	char *dsdt_start = NULL;
+	char *dsdt_buffer = NULL;
+	unsigned long len = 0, len2 = 0;
+	int fd;
+	struct kstat stat;
+
+	/* try to get dsdt from tail of initrd */
+	if ((fd = sys_open(ramfs_dsdt_name, O_RDONLY, 0)) < 0) {
+		if (initrd_start) {
+			char *data = (char *)initrd_start;
+
+			printk(KERN_INFO PREFIX "Looking for DSDT in initrd...");
+
+			/* Search for the start signature */
+			while (data < (char *)initrd_end - sizeof(signature) - 4) {
+				if (!memcmp(data, signature, sizeof(signature))) {
+					data += sizeof(signature);
+					if (!memcmp(data, "DSDT", 4))
+						dsdt_start = data;
+					break;
+				}
+				data++;
+			}
+
+			if (dsdt_start){
+				printk(" found at offset %zu",
+				       dsdt_start - (char *)initrd_start);
+				len = (char*) initrd_end - dsdt_start;
+				printk(", size: %lu bytes\n", len);
+				dsdt_buffer = ACPI_ALLOCATE(len + 1);
+				memcpy(dsdt_buffer, dsdt_start, len);
+				*(dsdt_buffer + len + 1)= '\0';
+			} else
+				printk(" not found!\n");
+		}
+	} else {
+		printk(KERN_INFO PREFIX "Looking for DSDT in initramfs...");
+		if (vfs_stat(ramfs_dsdt_name, &stat) < 0){
+			printk ("error getting stats for file %s\n", ramfs_dsdt_name);
+			return NULL;
+		}
+
+		len = stat.size;
+		dsdt_buffer = ACPI_ALLOCATE(len + 1);
+		if (!dsdt_buffer) {
+			printk("Could not allocate %lu bytes of memory\n", len);
+			return NULL;
+		}
+		printk (" found %s ...", ramfs_dsdt_name);
+
+		len2 = sys_read (fd, (char __user *) dsdt_buffer, len);
+		if (len2 < len ){
+			printk("\n" PREFIX "Error trying to read %lu bytes from %s\n",
+			       len, ramfs_dsdt_name);
+			ACPI_FREE (dsdt_buffer);
+			dsdt_buffer = NULL;
+		} else {
+			printk(" successfully read %lu bytes from %s\n",
+			       len, ramfs_dsdt_name);
+			*(dsdt_buffer + len + 1) = '\0';
+		}
+	}
+	if (!dsdt_buffer)
+		printk(" not found!\n");
+	return dsdt_buffer;
+}
+#endif
 
 acpi_status
 acpi_os_table_override(struct acpi_table_header * existing_table,
@@ -226,14 +301,16 @@ acpi_os_table_override(struct acpi_table
 	if (!existing_table || !new_table)
 		return AE_BAD_PARAMETER;
 
-#ifdef CONFIG_ACPI_CUSTOM_DSDT
+	*new_table = NULL;
 	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
 		*new_table = (struct acpi_table_header *)AmlCode;
-	else
-		*new_table = NULL;
-#else
-	*new_table = NULL;
+#elif defined(CONFIG_ACPI_INITRD)
+		*new_table = (struct acpi_table_header*)acpi_find_dsdt_initrd();
 #endif
+	if (*new_table)
+		printk(KERN_INFO PREFIX "Using customized DSDT\n");
+
 	return AE_OK;
 }
 
diff -ruNpX dontdiff linux-2.6.17/init/main.c linux-2.6.17.acpi/init/main.c
--- linux-2.6.17/init/main.c	2006-08-29 11:48:02.000000000 -0400
+++ linux-2.6.17.acpi/init/main.c	2006-08-29 11:48:45.000000000 -0400
@@ -613,8 +613,6 @@ asmlinkage void __init start_kernel(void
 
 	check_bugs();
 
-	acpi_early_init(); /* before LAPIC and SMP init */
-
 	/* Do the rest non-__init'ed, we're now alive */
 	rest_init();
 }
@@ -731,6 +729,14 @@ static int init(void * unused)
 	 */
 	child_reaper = current;
 
+	/*
+	 * Do this before initcalls, because some drivers want to access
+	 * firmware files.
+	 */
+	populate_rootfs();
+
+	acpi_early_init(); /* before LAPIC and SMP init */
+
 	smp_prepare_cpus(max_cpus);
 
 	do_pre_smp_initcalls();
@@ -740,12 +746,6 @@ static int init(void * unused)
 
 	cpuset_init_smp();
 
-	/*
-	 * Do this before initcalls, because some drivers want to access
-	 * firmware files.
-	 */
-	populate_rootfs();
-
 	do_basic_setup();
 
 	/*
