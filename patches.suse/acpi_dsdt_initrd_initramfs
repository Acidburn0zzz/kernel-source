Subject: Read DSDT from initrd or initramfs
From: Thomas Renninger <trenn@suse.de>

Searches and reads in the root of initramfs a DSDT.aml file.
If not found the initrd is scanned for a DSDT signature
("INITRDDSDT123DSDT123"). Once a DSDT in the initramfs or
initrd is found the DSDT provided by BIOS is replaced.

 drivers/acpi/Kconfig |   14 ++++++++
 drivers/acpi/osl.c   |   87 ++++++++++++++++++++++++++++++++++++++++++++++++---
 2 files changed, 96 insertions(+), 5 deletions(-)

Index: linux-2.6.13/drivers/acpi/Kconfig
===================================================================
--- linux-2.6.13.orig/drivers/acpi/Kconfig
+++ linux-2.6.13/drivers/acpi/Kconfig
@@ -339,6 +339,20 @@ config ACPI_HOTPLUG_MEMORY
 	  If one selects "m," this driver can be loaded using the following
 	  command: 
 		$>modprobe acpi_memhotplug 
+
+config ACPI_INITRD
+	bool "Read DSDT from initrd or initramfs"
+	depends on ACPI && BLK_DEV_INITRD && !ACPI_CUSTOM_DSDT
+	default n
+	help
+	  The DSDT (Differentiated System Description Table) often needs to be
+	  overridden because of broken BIOS implementations. If you want to use
+	  a customized DSDT, please use the mkinitrd tool (mkinitrd package) to
+	  attach the DSDT to the initrd or initramfs
+	  (see http://gaugusch.at/kernel.shtml for details)
+	  If there is no DSDT found in the initrd, the DSDT from the BIOS is
+	  used. It is safe to say yes here.
+
 endif	# ACPI
 
 endmenu
Index: linux-2.6.13/drivers/acpi/osl.c
===================================================================
--- linux-2.6.13.orig/drivers/acpi/osl.c
+++ linux-2.6.13/drivers/acpi/osl.c
@@ -44,6 +44,8 @@
 #include <asm/uaccess.h>
 
 #include <linux/efi.h>
+#include <linux/initrd.h>
+#include <linux/syscalls.h>
 
 #define _COMPONENT		ACPI_OS_SERVICES
 ACPI_MODULE_NAME("osl")
@@ -243,6 +245,79 @@ acpi_os_predefined_override(const struct
 
 	return AE_OK;
 }
+#ifdef CONFIG_ACPI_INITRD
+static const char signature[] = "INITRDDSDT123DSDT123";
+static char ramfs_dsdt_name[] = "/DSDT.aml";
+
+static char *acpi_find_dsdt_initrd(void)
+{
+	char *dsdt_start = NULL;
+	char *dsdt_buffer = NULL;
+	unsigned long len = 0, len2 = 0;
+	int fd;
+	struct kstat stat;
+
+	/* try to get dsdt from tail of initrd */
+	if ((fd = sys_open(ramfs_dsdt_name, O_RDONLY, 0)) < 0) {
+		if (initrd_start) {
+			char *data = (char *)initrd_start;
+
+			printk(KERN_INFO PREFIX "Looking for DSDT in initrd...");
+
+			/* Search for the start signature */
+			while (data < (char *)initrd_end - sizeof(signature) - 4) {
+				if (!memcmp(data, signature, sizeof(signature))) {
+					data += sizeof(signature);
+					if (!memcmp(data, "DSDT", 4))
+						dsdt_start = data;
+					break;
+				}
+				data++;
+			}
+
+			if (dsdt_start){
+				printk(" found at offset %zu",
+				       dsdt_start - (char *)initrd_start);
+				len = (char*) initrd_end - dsdt_start;
+				printk(", size: %lu bytes\n", len);
+				dsdt_buffer = ACPI_MEM_ALLOCATE(len + 1);
+				memcpy(dsdt_buffer, dsdt_start, len);
+				*(dsdt_buffer + len + 1)= '\0';
+			} else
+				printk(" not found!\n");
+		}
+	} else {
+		printk(KERN_INFO PREFIX "Looking for DSDT in initramfs...");
+		if (vfs_stat(ramfs_dsdt_name, &stat) < 0){
+			printk ("error getting stats for file %s\n", ramfs_dsdt_name);
+			return NULL;
+		}
+
+		len = stat.size;
+		dsdt_buffer = ACPI_MEM_ALLOCATE(len + 1);
+		if (!dsdt_buffer) {
+			printk("Could not allocate %lu bytes of memory\n", len);
+			return NULL;
+		}
+		printk (" found %s ...", ramfs_dsdt_name);
+
+		len2 = sys_read (fd, (char __user *) dsdt_buffer, len);
+		if (len2 < len ){
+			printk("\n" PREFIX "Error trying to read %lu bytes from %s\n",
+			       len, ramfs_dsdt_name);
+			ACPI_MEM_FREE (dsdt_buffer);
+			dsdt_buffer = NULL;
+		} else {
+			printk(" successfully read %lu bytes from %s\n",
+			       len, ramfs_dsdt_name);
+			*(dsdt_buffer + len + 1) = '\0';
+		}
+	}
+	if (!dsdt_buffer)
+		printk(" not found!\n");
+	return dsdt_buffer;
+}
+#endif
 
 acpi_status
 acpi_os_table_override(struct acpi_table_header * existing_table,
@@ -251,14 +326,16 @@ acpi_os_table_override(struct acpi_table
 	if (!existing_table || !new_table)
 		return AE_BAD_PARAMETER;
 
-#ifdef CONFIG_ACPI_CUSTOM_DSDT
+	*new_table = NULL;
 	if (strncmp(existing_table->signature, "DSDT", 4) == 0)
+#ifdef CONFIG_ACPI_CUSTOM_DSDT
 		*new_table = (struct acpi_table_header *)AmlCode;
-	else
-		*new_table = NULL;
-#else
-	*new_table = NULL;
+#elif defined(CONFIG_ACPI_INITRD)
+		*new_table = (struct acpi_table_header*)acpi_find_dsdt_initrd();
 #endif
+	if (*new_table)
+		printk(KERN_INFO PREFIX "Using customized DSDT\n");
+
 	return AE_OK;
 }
 
