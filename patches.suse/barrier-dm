diff -urp /mnt/kscratch/linux-2.6.5/drivers/md/dm.c linux-2.6.5-SUSE-20040406/drivers/md/dm.c
--- /mnt/kscratch/linux-2.6.5/drivers/md/dm.c	2004-04-06 09:59:14.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/drivers/md/dm.c	2004-04-06 10:11:58.984388298 +0200
@@ -593,6 +593,21 @@ static int dm_request(request_queue_t *q
 	return 0;
 }
 
+static int dm_flush_all(request_queue_t *q, struct gendisk *disk,
+			sector_t *error_sector)
+{
+	struct mapped_device *md = q->queuedata;
+	struct dm_table *map = dm_get_table(md);
+	int ret = -ENXIO;
+
+	if (map) {
+		ret = dm_table_flush_all(md->map);
+		dm_table_put(map);
+	}
+
+	return ret;
+}
+
 static void dm_unplug_all(request_queue_t *q)
 {
 	struct mapped_device *md = q->queuedata;
@@ -703,6 +718,7 @@ static struct mapped_device *alloc_dev(u
 	md->queue->backing_dev_info.congested_data = md;
 	blk_queue_make_request(md->queue, dm_request);
 	md->queue->unplug_fn = dm_unplug_all;
+	md->queue->issue_flush_fn = dm_flush_all;
 
 	md->io_pool = mempool_create(MIN_IOS, mempool_alloc_slab,
 				     mempool_free_slab, _io_cache);
diff -urp /mnt/kscratch/linux-2.6.5/drivers/md/dm.h linux-2.6.5-SUSE-20040406/drivers/md/dm.h
--- /mnt/kscratch/linux-2.6.5/drivers/md/dm.h	2004-04-06 09:59:14.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/drivers/md/dm.h	2004-04-06 10:11:58.984388298 +0200
@@ -117,6 +117,7 @@ void dm_table_suspend_targets(struct dm_
 void dm_table_resume_targets(struct dm_table *t);
 int dm_table_any_congested(struct dm_table *t, int bdi_bits);
 void dm_table_unplug_all(struct dm_table *t);
+int dm_table_flush_all(struct dm_table *t);
 
 /*-----------------------------------------------------------------
  * A registry of target types.
diff -urp /mnt/kscratch/linux-2.6.5/drivers/md/dm-table.c linux-2.6.5-SUSE-20040406/drivers/md/dm-table.c
--- /mnt/kscratch/linux-2.6.5/drivers/md/dm-table.c	2004-04-06 09:59:14.000000000 +0200
+++ linux-2.6.5-SUSE-20040406/drivers/md/dm-table.c	2004-04-06 10:11:58.985388189 +0200
@@ -900,6 +900,29 @@ void dm_table_unplug_all(struct dm_table
 	}
 }
 
+int dm_table_flush_all(struct dm_table *t)
+{
+	struct list_head *d, *devices = dm_table_get_devices(t);
+	int ret = 0;
+
+	for (d = devices->next; d != devices; d = d->next) {
+		struct dm_dev *dd = list_entry(d, struct dm_dev, list);
+		request_queue_t *q = bdev_get_queue(dd->bdev);
+		int err;
+
+		if (!q->issue_flush_fn)
+			err = -EOPNOTSUPP;
+		else
+			err = q->issue_flush_fn(q, dd->bdev->bd_disk, NULL);
+
+		if (!ret)
+			ret = err;
+	}
+
+	return ret;
+}
+
+EXPORT_SYMBOL(dm_table_flush_all);
 EXPORT_SYMBOL(dm_table_unplug_all);
 EXPORT_SYMBOL(dm_vcalloc);
 EXPORT_SYMBOL(dm_get_device);

