Date: Thu, 5 Feb 2004 14:34:35 +0000
From: Christoph Hellwig <hch@infradead.org>
To: Andreas Gruenbacher <agruen@suse.de>
Cc: Dean Roehrich <roehrich@sgi.com>, Nathan Scott <nathans@sgi.com>
Subject: Re: HSM with XFS
Message-ID: <20040205143435.A603@infradead.org>
References: <200402042005.i14K5c9i4770677@clink.americas.sgi.com>
	 <1075946886.2267.178.camel@nb.suse.de>
	 <20040205131833.A32227@infradead.org>
Mime-Version: 1.0
Content-Disposition: inline
User-Agent: Mutt/1.2.5.1i
In-Reply-To: <20040205131833.A32227@infradead.org>; from hch@infradead.org on Thu, Feb 05, 2004 at 01:18:33PM +0000
X-Spam-Checker-Version: SpamAssassin 2.63 (2004-01-11) on wotan.suse.de
X-Spam-Level: 
X-Spam-Status: No, hits=-3.8 required=5.0 tests=AWL,BAYES_00,DOMAIN_BODY 
	autolearn=no version=2.63
Content-Type: text/plain; CHARSET=us-ascii
X-Evolution-Source: imap://agruen@imap.suse.de/
Content-Transfer-Encoding: 8bit


Here's a patch that makes dmapi compile on 2.6 (you need the previous
build system patch, too).  No further guarantees (i.e. it might not compile
with any config I didn't test and will most certainly not work or even burn
your house..)

Index: linux-2.6.2.orig/fs/xfs/dmapi/dmapi_register.c
===================================================================
--- linux-2.6.2.orig/fs/xfs/dmapi/dmapi_register.c
+++ linux-2.6.2/fs/xfs/dmapi/dmapi_register.c
@@ -30,15 +30,25 @@
  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/
  */
 
+#include <linux/version.h>
 #include <linux/mm.h>
 #include <linux/proc_fs.h>
 #include <linux/module.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/mount.h>
+#include <linux/namei.h>
+#endif
 #include "xfs.h"
 #include "dmapi.h"
 #include "dmapi_kern.h"
 #include "dmapi_private.h"
 #include "xfs_sb.h"
 
+/* LOOKUP_POSTIVE was removed in Linux 2.6 */
+#ifndef LOOKUP_POSITIVE
+#define LOOKUP_POSITIVE	0
+#endif
+
 dm_fsreg_t	*dm_registers;	/* head of filesystem registration list */
 int		dm_fsys_cnt;	/* number of filesystems on dm_registers list */
 lock_t		dm_reg_lock = SPIN_LOCK_UNLOCKED;/* lock for dm_registers */
Index: linux-2.6.2.orig/fs/xfs/dmapi/dmapi_sysent.c
===================================================================
--- linux-2.6.2.orig/fs/xfs/dmapi/dmapi_sysent.c
+++ linux-2.6.2/fs/xfs/dmapi/dmapi_sysent.c
@@ -42,6 +42,7 @@
 #include <linux/init.h>
 #include <linux/proc_fs.h>
 #include <linux/module.h>
+#include <linux/devfs_fs_kernel.h>
 
 #include <asm/uaccess.h>
 
@@ -623,20 +624,21 @@ dmapi_dump(struct file *file, char *buf,
 }
 
 static struct file_operations dmapi_fops = {
-	open:		dmapi_open,
-	ioctl:		dmapi_ioctl,
-	read:		dmapi_dump,
-	release:	dmapi_release
+	.open		= dmapi_open,
+	.ioctl		= dmapi_ioctl,
+	.read		= dmapi_dump,
+	.release	= dmapi_release,
 };
 
 static struct miscdevice dmapi_dev = {
-	minor:	MISC_DYNAMIC_MINOR,
-	name:	"dmapi",
-	fops:	&dmapi_fops
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= "xfs_dmapi",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	.devfs_name	= "xfs_dmapi",
+#endif
+	.fops		= &dmapi_fops
 };
 
-
-
 #ifdef CONFIG_PROC_FS
 static int
 dmapi_summary(char *buffer, char **start, off_t offset,
@@ -676,13 +678,10 @@ dmapi_summary(char *buffer, char **start
 
 	return len;
 }
-#endif
-
 
 static void __init
-dmapi_init_procfs(int dmapi_minor)
+dmapi_init_procfs(void)
 {
-#ifdef CONFIG_PROC_FS
 	struct proc_dir_entry *entry;
 
 	if ((entry = proc_mkdir( DMAPI_DBG_PROCFS, 0)) == NULL )
@@ -701,26 +700,29 @@ dmapi_init_procfs(int dmapi_minor)
 	entry = create_proc_read_entry( DMAPI_DBG_PROCFS "/summary", 0, 0, dmapi_summary, NULL);
 	entry->owner = THIS_MODULE;
 
-	entry = proc_mknod( DMAPI_PROCFS, S_IFCHR | S_IRUSR | S_IWUSR,
-			   NULL, mk_kdev(MISC_MAJOR,dmapi_minor));
-	if( entry == NULL )
+	/*
+	 * Old versions of libdm expect the dmapi dev in /proc--put a
+	 * symlink there so the old libdm can still work.
+	 */
+	entry = proc_symlink(DMAPI_PROCFS, NULL, "/dev/xfs_dmapi");
+	if (entry == NULL)
 		return;
 	entry->owner = THIS_MODULE;
-#endif
 }
 
 static void __exit
 dmapi_cleanup_procfs(void)
 {
-#ifdef CONFIG_PROC_FS
 	remove_proc_entry( DMAPI_PROCFS, NULL);
 	remove_proc_entry( DMAPI_DBG_PROCFS "/summary", NULL);
 	remove_proc_entry( DMAPI_DBG_PROCFS "/fsreg", NULL);
 	remove_proc_entry( DMAPI_DBG_PROCFS "/sessions", NULL);
 	remove_proc_entry( DMAPI_DBG_PROCFS, NULL);
-#endif
 }
-
+#else
+# define dmapi_init_procfs()		do { } while (0)
+# define dmapi_cleanup_procfs()		do { } while (0)
+#endif /* CONFIG_PROC_FS */
 
 int __init dmapi_init(void)
 {
@@ -749,7 +751,7 @@ int __init dmapi_init(void)
 	ret = misc_register(&dmapi_dev);
 	if( ret != 0 )
 		printk(KERN_ERR "dmapi_init: misc_register returned %d\n", ret);
-	dmapi_init_procfs(dmapi_dev.minor);
+	dmapi_init_procfs();
 	xfs_dm_init();
 	return(0);
 }
Index: linux-2.6.2.orig/fs/xfs/dmapi/dmapi_xfs.c
===================================================================
--- linux-2.6.2.orig/fs/xfs/dmapi/dmapi_xfs.c
+++ linux-2.6.2/fs/xfs/dmapi/dmapi_xfs.c
@@ -30,11 +30,13 @@
  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/
  */
 
+#include <linux/version.h>
 #include <linux/init.h>
-#include <linux/iobuf.h>
 #include <linux/spinlock.h>
 #include <linux/seq_file.h>
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/iobuf.h>
+#endif
 
 #include "xfs.h"
 #include "xfs_fs.h"
@@ -75,6 +77,38 @@
 	xbdp = vn_bhv_lookup(VN_BHV_HEAD(vp), &xfs_vnodeops); \
 	ASSERT(xbdp);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define MAX_DIO_SIZE(mp)	(64 * PAGE_CACHE_SIZE)
+#define XFS_TO_LINUX_DEVT(dev)	(MKDEV(sysv_major(dev) & 0x1ff, sysv_minor(dev)))
+#else
+#define MAX_DIO_SIZE(mp)	XFS_B_TO_FSBT((mp), KIO_MAX_ATOMIC_IO << 10)
+#define XFS_TO_LINUX_DEVT(dev)	(kdev_t_to_nr(XFS_DEV_TO_KDEVT(dev)))
+
+static inline int
+open_private_file(struct file *file, struct dentry *dentry, int oflags)
+{
+	mode_t fmode = (oflags+1) & O_ACCMODE;
+	int error = init_private_file(file, dentry, fmode);
+
+	if (error == -EFBIG) {
+		/* try again */
+		file->f_flags = oflags;
+		error = file.f_op->open(dentry->d_inode, file);
+	}
+
+	if (!error)
+		 file->f_flags = oflags;
+	return error;
+}
+
+static inline void
+close_private_file(struct file *file)
+{
+	if (file->f_op->release)
+		file->f_op->release(file->f_dentry->d_inode, file);
+}
+#endif
+
 /* Structure used to hold the on-disk version of a dm_attrname_t.  All
    on-disk attribute names start with the 8-byte string "SGI_DMI_".
 */
@@ -166,26 +200,30 @@ STATIC int
 prohibited_mr_events(
 	vnode_t		*vp)
 {
-	struct address_space *mapping;
+	struct address_space *mapping = LINVFS_GET_IP(vp)->i_mapping;
+	int prohibited = (1 << DM_EVENT_READ);
 	struct vm_area_struct *vma;
-	int		prohibited;
-
-	if(!VN_MAPPED(vp))
-		return 0;
-
-	prohibited = 1 << DM_EVENT_READ;
-	mapping = LINVFS_GET_IP(vp)->i_mapping;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	down(&mapping->i_shared_sem);
+	list_for_each_entry(vma, &mapping->i_mmap_shared, shared) {
+		if (!(vma->vm_flags & VM_DENYWRITE)) {
+			prohibited |= (1 << DM_EVENT_WRITE);
+			break;
+		}
+	}
+	up(&mapping->i_shared_sem);
+#else
 	spin_lock(&mapping->i_shared_lock);
-	if (mapping->i_mmap_shared) {
-		for (vma = mapping->i_mmap_shared; vma; vma = vma->vm_next) {
-			if (!(vma->vm_flags & VM_DENYWRITE)) {
-				prohibited |= 1 << DM_EVENT_WRITE;
-				break;
-			}
+	for (vma = mapping->i_mmap_shared; vma; vma = vma->vm_next) {
+		if (!(vma->vm_flags & VM_DENYWRITE)) {
+			prohibited |= (1 << DM_EVENT_WRITE);
+			break;
 		}
 	}
 	spin_unlock(&mapping->i_shared_lock);
+#endif
+
 	return prohibited;
 }
 
@@ -293,7 +331,7 @@ xfs_ip_to_stat(
 	if ((vp->v_type == VREG) || (vp->v_type == VDIR)) {
 		buf->dt_rdev = 0;
 	} else if ((vp->v_type == VCHR) || (vp->v_type == VBLK) ) {
-		buf->dt_rdev = kdev_t_to_nr(XFS_DEV_TO_KDEVT(ip->i_df.if_u2.if_rdev));
+		buf->dt_rdev = XFS_TO_LINUX_DEVT(ip->i_df.if_u2.if_rdev);
 	} else {
 		buf->dt_rdev = 0;	/* not a b/c spec. */
 	}
@@ -965,20 +1003,11 @@ xfs_dm_rdwr(
 		}
 	}
 
-	error = init_private_file( &file, dentry, fmode );
-	if(error){
-		if (error == -EFBIG) {
-			/* try again */
-			oflags |= O_LARGEFILE;
-			file.f_flags = oflags;
-			error = file.f_op->open( dentry->d_inode, &file );
-		}
-		if (error) {
-			error = EINVAL;
-			goto put_access;
-		}
+	error = open_private_file(&file, dentry, oflags);
+	if (error){
+		error = EINVAL;
+		goto put_access;
 	}
-	file.f_flags = oflags;
 	file.f_op = &linvfs_invis_file_operations;
 
 	if (fmode & FMODE_READ) {
@@ -995,12 +1024,10 @@ xfs_dm_rdwr(
 		error = -(int)xfer;
 	}
 
-	if (file.f_op->release)
-		file.f_op->release(ip, &file);
+	close_private_file(&file);
  put_access:
 	if (fmode & FMODE_WRITE)
 		put_write_access(ip);
-
  dput:
 	dput(dentry);
 	return error;
@@ -1599,8 +1626,7 @@ xfs_dm_get_dioinfo(
 	 * avoid having to do block zeroing on short writes.
 	 */
 	dio.d_miniosz = mp->m_sb.sb_blocksize;
-	dio.d_maxiosz = XFS_FSB_TO_B(mp,
-			    XFS_B_TO_FSBT(mp, KIO_MAX_ATOMIC_IO << 10));
+	dio.d_maxiosz = MAX_DIO_SIZE(mp);
 	dio.d_mem = mp->m_sb.sb_blocksize;
 
 	if (ip->i_d.di_flags & XFS_DIFLAG_REALTIME) {

