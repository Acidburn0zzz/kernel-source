lmb@suse.de
jacob berkman (ClusterFS Inc)

Feature

Patches needed to integrate LUSTRE into the SLES kernel,
mainly the intent stuff.

Index: linux-2.6.5/drivers/block/ll_rw_blk.c
===================================================================
--- linux-2.6.5.orig/drivers/block/ll_rw_blk.c	2004-05-25 12:35:38.000000000 +0200
+++ linux-2.6.5/drivers/block/ll_rw_blk.c	2004-05-25 12:35:46.000000000 +0200
@@ -2523,6 +2523,13 @@
 		if (test_bit(QUEUE_FLAG_DEAD, &q->queue_flags))
 			goto end_io;
 
+		/* this is cfs's dev_rdonly check */
+		if (bio->bi_rw == WRITE &&
+				dev_check_rdonly(bio->bi_bdev->bd_dev)) {
+			bio_endio(bio, bio->bi_size, 0);
+			break;
+		}
+
 		/*
 		 * If this device has partitions, remap block n
 		 * of partition p to block n+start(p) of the disk.
@@ -3052,6 +3059,58 @@
 	*ioc2 = temp;
 }
 
+#define MAX_RDONLY_DEVS		16
+
+static dev_t rdonly_devs[MAX_RDONLY_DEVS] = {0, };
+
+/*
+ * Debug code for turning block devices "read-only" (will discard writes
+ * silently).  This is for filesystem crash/recovery testing.
+ */
+void dev_set_rdonly(struct block_device *bdev, int no_write)
+{
+	if (no_write >= MAX_RDONLY_DEVS) {
+		printk(KERN_ALERT "%s:%d illegal arg %d (max %d)\n",
+				__FILE__, __LINE__, no_write, MAX_RDONLY_DEVS);
+		return;
+	}
+
+	if (bdev) {
+		printk(KERN_WARNING "Turning device %s read-only at %d\n",
+				bdev->bd_disk ? bdev->bd_disk->disk_name : "?",
+				no_write);
+		rdonly_devs[no_write] = bdev->bd_dev;
+	}
+}
+
+void dev_clear_rdonly(int no_write)
+{
+	if (no_write >= MAX_RDONLY_DEVS) {
+		printk(KERN_ALERT "%s:%d illegal arg %d (max %d)\n",
+				__FILE__, __LINE__, no_write, MAX_RDONLY_DEVS);
+		return;
+	}
+
+	if (rdonly_devs[no_write] == 0)
+		return;
+	
+	printk(KERN_WARNING "Clearing read-only at %d\n", no_write);
+	rdonly_devs[no_write] = 0;
+}
+
+int dev_check_rdonly(dev_t dev)
+{
+	int i;
+
+	for (i = 0; i < MAX_RDONLY_DEVS; i++)
+		if (rdonly_devs[i] == dev)
+			return 1;
+	return 0;
+}
+
+EXPORT_SYMBOL(dev_set_rdonly);
+EXPORT_SYMBOL(dev_clear_rdonly);
+EXPORT_SYMBOL(dev_check_rdonly);
 
 /*
  * sysfs parts below
Index: linux-2.6.5/drivers/md/dm-path-selector.c
===================================================================
--- linux-2.6.5.orig/drivers/md/dm-path-selector.c	2004-05-25 12:35:35.000000000 +0200
+++ linux-2.6.5/drivers/md/dm-path-selector.c	2004-05-25 12:35:46.000000000 +0200
@@ -129,7 +129,7 @@
 	struct path *path;
 };
 
-static struct path_info *path_lookup(struct list_head *head, struct path *p)
+static struct path_info *md_path_lookup(struct list_head *head, struct path *p)
 {
 	struct path_info *pi;
 
@@ -235,9 +235,9 @@
 	 * mind the expense of these searches.
 	 */
 	spin_lock_irqsave(&s->lock, flags);
-	pi = path_lookup(&s->valid_paths, p);
+	pi = md_path_lookup(&s->valid_paths, p);
 	if (!pi)
-		pi = path_lookup(&s->invalid_paths, p);
+		pi = md_path_lookup(&s->invalid_paths, p);
 
 	if (!pi)
 		DMWARN("asked to change the state of an unknown path");
Index: linux-2.6.5/fs/cifs/dir.c
===================================================================
--- linux-2.6.5.orig/fs/cifs/dir.c	2004-05-25 12:35:34.000000000 +0200
+++ linux-2.6.5/fs/cifs/dir.c	2004-05-25 12:37:16.000000000 +0200
@@ -172,22 +172,22 @@
 	}
 
 	if(nd) {
-		if ((nd->intent.open.flags & O_ACCMODE) == O_RDONLY)
+		if ((nd->intent.it_flags & O_ACCMODE) == O_RDONLY)
 			desiredAccess = GENERIC_READ;
-		else if ((nd->intent.open.flags & O_ACCMODE) == O_WRONLY)
+		else if ((nd->intent.it_flags & O_ACCMODE) == O_WRONLY)
 			desiredAccess = GENERIC_WRITE;
-		else if ((nd->intent.open.flags & O_ACCMODE) == O_RDWR) {
+		else if ((nd->intent.it_flags & O_ACCMODE) == O_RDWR) {
 			/* GENERIC_ALL is too much permission to request */
 			/* can cause unnecessary access denied on create */
 			/* desiredAccess = GENERIC_ALL; */
 			desiredAccess = GENERIC_READ | GENERIC_WRITE;
 		}
 
-		if((nd->intent.open.flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
+		if((nd->intent.it_flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
 			disposition = FILE_CREATE;
-		else if((nd->intent.open.flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))
+		else if((nd->intent.it_flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))
 			disposition = FILE_OVERWRITE_IF;
-		else if((nd->intent.open.flags & O_CREAT) == O_CREAT)
+		else if((nd->intent.it_flags & O_CREAT) == O_CREAT)
 			disposition = FILE_OPEN_IF;
 		else {
 			cFYI(1,("Create flag not set in create function"));
@@ -346,7 +346,7 @@
 	      parent_dir_inode, direntry->d_name.name, direntry));
 
 	if(nd) {  /* BB removeme */
-		cFYI(1,("In lookup nd flags 0x%x open intent flags 0x%x",nd->flags,nd->intent.open.flags));
+		cFYI(1,("In lookup nd flags 0x%x open intent flags 0x%x",nd->flags,nd->intent.it_flags));
 	} /* BB removeme BB */
 	/* BB Add check of incoming data - e.g. frame not longer than maximum SMB - let server check the namelen BB */
 
Index: linux-2.6.5/fs/dcache.c
===================================================================
--- linux-2.6.5.orig/fs/dcache.c	2004-05-25 12:35:30.000000000 +0200
+++ linux-2.6.5/fs/dcache.c	2004-05-25 12:35:46.000000000 +0200
@@ -217,7 +217,14 @@
 		spin_unlock(&dcache_lock);
 		return 0;
 	}
-	/*
+
+        /* network invalidation by Lustre */
+	if (dentry->d_flags & DCACHE_LUSTRE_INVALID) {
+		spin_unlock(&dcache_lock);
+		return 0;
+	}
+
+        /*
 	 * Check whether to do a partial shrink_dcache
 	 * to get rid of unused child entries.
 	 */
@@ -1111,14 +1118,23 @@
  * Adds a dentry to the hash according to its name.
  */
  
-void d_rehash(struct dentry * entry)
+void __d_rehash(struct dentry * entry, int lock)
 {
 	struct hlist_head *list = d_hash(entry->d_parent, entry->d_name.hash);
-	spin_lock(&dcache_lock);
+	if (lock)
+		spin_lock(&dcache_lock);
  	entry->d_vfs_flags &= ~DCACHE_UNHASHED;
 	entry->d_bucket = list;
  	hlist_add_head_rcu(&entry->d_hash, list);
-	spin_unlock(&dcache_lock);
+	if (lock)
+		spin_unlock(&dcache_lock);
+}
+
+EXPORT_SYMBOL(__d_rehash);
+
+void d_rehash(struct dentry * entry)
+{
+	__d_rehash(entry, 1);
 }
 
 #define do_switch(x,y) do { \
Index: linux-2.6.5/fs/exec.c
===================================================================
--- linux-2.6.5.orig/fs/exec.c	2004-05-25 12:35:38.000000000 +0200
+++ linux-2.6.5/fs/exec.c	2004-05-25 12:35:46.000000000 +0200
@@ -124,9 +124,9 @@
 	struct file * file;
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_OPEN);
 
-	nd.intent.open.flags = FMODE_READ;
-
+	nd.intent.it_flags = O_RDONLY;
 	FSHOOK_BEGIN_USER_WALK(open,
 		error,
 		library,
@@ -144,7 +144,7 @@
 		goto out;
 	}
 
-	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
+	file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &nd.intent);
 	error = PTR_ERR(file);
 	if (IS_ERR(file))
 		goto out;
@@ -495,8 +495,9 @@
 
 	FSHOOK_BEGIN(open, err, .filename = name, .flags = O_RDONLY)
 
-	nd.intent.open.flags = FMODE_READ;
-	err = path_lookup(name, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
+	intent_init(&nd.intent, IT_OPEN);
+	nd.intent.it_flags = O_RDONLY;
+	err = path_lookup(name, LOOKUP_FOLLOW, &nd);
 	file = ERR_PTR(err);
 
 	if (!err) {
@@ -509,7 +510,7 @@
 				err = -EACCES;
 			file = ERR_PTR(err);
 			if (!err) {
-				file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
+				file = dentry_open_it(nd.dentry, nd.mnt, O_RDONLY, &nd.intent);
 				if (!IS_ERR(file)) {
 					err = deny_write_access(file);
 					if (err) {
@@ -1436,7 +1437,7 @@
 		goto close_fail;
 	if (!file->f_op->write)
 		goto close_fail;
-	if (do_truncate(file->f_dentry, 0) != 0)
+	if (do_truncate(file->f_dentry, 0, 0) != 0)
 		goto close_fail;
 
 	retval = binfmt->core_dump(signr, regs, file);
Index: linux-2.6.5/fs/filesystems.c
===================================================================
--- linux-2.6.5.orig/fs/filesystems.c	2004-05-25 12:35:28.000000000 +0200
+++ linux-2.6.5/fs/filesystems.c	2004-05-25 12:35:46.000000000 +0200
@@ -27,7 +27,9 @@
  */
 
 static struct file_system_type *file_systems;
-static rwlock_t file_systems_lock = RW_LOCK_UNLOCKED;
+rwlock_t file_systems_lock = RW_LOCK_UNLOCKED;
+
+EXPORT_SYMBOL(file_systems_lock);
 
 /* WARNING: This can be used only if we _already_ own a reference */
 void get_filesystem(struct file_system_type *fs)
Index: linux-2.6.5/fs/inode.c
===================================================================
--- linux-2.6.5.orig/fs/inode.c	2004-05-25 12:35:37.000000000 +0200
+++ linux-2.6.5/fs/inode.c	2004-05-25 12:35:46.000000000 +0200
@@ -221,6 +221,7 @@
 	inodes_stat.nr_unused--;
 }
 
+EXPORT_SYMBOL(__iget);
 /**
  * clear_inode - clear an inode
  * @inode: inode to clear
Index: linux-2.6.5/fs/jbd/journal.c
===================================================================
--- linux-2.6.5.orig/fs/jbd/journal.c	2004-05-25 12:35:37.000000000 +0200
+++ linux-2.6.5/fs/jbd/journal.c	2004-05-25 12:35:46.000000000 +0200
@@ -71,6 +71,7 @@
 EXPORT_SYMBOL(journal_errno);
 EXPORT_SYMBOL(journal_ack_err);
 EXPORT_SYMBOL(journal_clear_err);
+EXPORT_SYMBOL(log_start_commit);
 EXPORT_SYMBOL(log_wait_commit);
 EXPORT_SYMBOL(journal_start_commit);
 EXPORT_SYMBOL(journal_wipe);
Index: linux-2.6.5/fs/namei.c
===================================================================
--- linux-2.6.5.orig/fs/namei.c	2004-05-25 12:35:38.000000000 +0200
+++ linux-2.6.5/fs/namei.c	2004-05-25 12:35:46.000000000 +0200
@@ -270,8 +270,19 @@
 	return 0;
 }
 
+void intent_release(struct lookup_intent *it)
+{
+	if (!it)
+		return;
+	if (it->it_magic != INTENT_MAGIC)
+		return;
+	if (it->it_op_release)
+		it->it_op_release(it);
+}
+
 void path_release(struct nameidata *nd)
 {
+	intent_release(&nd->intent);
 	dput(nd->dentry);
 	mntput(nd->mnt);
 }
@@ -348,7 +359,10 @@
 {
 	struct dentry * result;
 	struct inode *dir = parent->d_inode;
+	int counter = 0;
 
+again:
+	counter++;
 	down(&dir->i_sem);
 	/*
 	 * First re-do the cached lookup just in case it was created
@@ -387,7 +401,10 @@
 	if (result->d_op && result->d_op->d_revalidate) {
 		if (!result->d_op->d_revalidate(result, nd) && !d_invalidate(result)) {
 			dput(result);
-			result = ERR_PTR(-ENOENT);
+			if (counter > 10)
+				result = ERR_PTR(-ESTALE);
+			if (!IS_ERR(result))
+				goto again;
 		}
 	}
 	return result;
@@ -564,6 +581,33 @@
 	return PTR_ERR(dentry);
 }
 
+static int revalidate_special(struct nameidata *nd)
+{
+	struct dentry *dentry = nd->dentry;
+	int err, counter = 0;
+
+	if (!dentry->d_op || !dentry->d_op->d_revalidate)
+		return 0;
+ revalidate_again:
+	if (!dentry->d_op->d_revalidate(dentry, nd)) {
+		struct dentry *new;
+		if ((err = permission(dentry->d_parent->d_inode, MAY_EXEC,nd)))
+			return err;
+		new = real_lookup(dentry->d_parent, &dentry->d_name, nd);
+		if (IS_ERR(new))
+			return PTR_ERR(new);
+		d_invalidate(dentry);
+		dput(dentry);
+		nd->dentry = dentry = new;
+		counter++;
+		if (counter < 10)
+			goto revalidate_again;
+		printk("excessive revalidate_it loops\n");
+		return -ESTALE;
+	}
+	return 0;
+}
+
 /*
  * Name resolution.
  *
@@ -664,7 +708,9 @@
 
 		if (inode->i_op->follow_link) {
 			mntget(next.mnt);
+			nd->flags |= LOOKUP_LINK_NOTLAST;
 			err = do_follow_link(next.dentry, nd);
+			nd->flags &= ~LOOKUP_LINK_NOTLAST;
 			dput(next.dentry);
 			mntput(next.mnt);
 			if (err)
@@ -703,14 +749,29 @@
 				inode = nd->dentry->d_inode;
 				/* fallthrough */
 			case 1:
+ 				nd->flags |= LOOKUP_LAST;
+ 				err = revalidate_special(nd);
+ 				nd->flags &= ~LOOKUP_LAST;
+				if (err)
+ 					break;
 				goto return_reval;
 		}
+		
+		if (err) {
+			if (!nd->dentry->d_inode)
+				err = -ENOENT;
+			
+			goto return_err;			
+		}
+		
 		if (nd->dentry->d_op && nd->dentry->d_op->d_hash) {
 			err = nd->dentry->d_op->d_hash(nd->dentry, &this);
 			if (err < 0)
 				break;
 		}
+		nd->flags |= LOOKUP_LAST;
 		err = do_lookup(nd, &this, &next);
+		nd->flags &= ~LOOKUP_LAST;
 		if (err)
 			break;
 		follow_mount(&next.mnt, &next.dentry);
@@ -936,7 +997,7 @@
 }
 
 /* SMP-safe */
-struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+struct dentry * lookup_one_len_it(const char * name, struct dentry * base, int len, struct nameidata *nd)
 {
 	unsigned long hash;
 	struct qstr this;
@@ -956,11 +1017,16 @@
 	}
 	this.hash = end_name_hash(hash);
 
-	return lookup_hash(&this, base);
+	return __lookup_hash(&this, base, nd);
 access:
 	return ERR_PTR(-EACCES);
 }
 
+struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
+{
+	return lookup_one_len_it(name, base, len, NULL);
+}
+
 /*
  *	namei()
  *
@@ -972,7 +1038,8 @@
  * that namei follows links, while lnamei does not.
  * SMP-safe
  */
-int fastcall __user_walk(const char __user *name, unsigned flags, struct nameidata *nd, const char **pname)
+int fastcall __user_walk_it(const char __user *name, unsigned flags,
+			    struct nameidata *nd, const char **pname)
 {
 	char *tmp = getname(name);
 	int err = PTR_ERR(tmp);
@@ -987,6 +1054,13 @@
 	return err;
 }
 
+int fastcall __user_walk(const char __user *name, unsigned flags,
+			 struct nameidata *nd, const char **pname)
+{
+	intent_init(&nd->intent, IT_LOOKUP);
+	return __user_walk_it(name, flags, nd, pname);
+}
+
 /*
  * It's inline, so penalty for filesystems that don't use sticky bit is
  * minimal.
@@ -1218,7 +1292,7 @@
 		if (!error) {
 			DQUOT_INIT(inode);
 			
-			error = do_truncate(dentry, 0);
+			error = do_truncate(dentry, 0, 1);
 		}
 		put_write_access(inode);
 		if (error)
@@ -1259,8 +1333,8 @@
 		acc_mode |= MAY_APPEND;
 
 	/* Fill in the open() intent data */
-	nd->intent.open.flags = flag;
-	nd->intent.open.create_mode = mode;
+	nd->intent.it_flags = flag;
+	nd->intent.it_create_mode = mode;
 
 	/*
 	 * The simplest case - just a plain lookup.
@@ -1275,6 +1349,7 @@
 	/*
 	 * Create - we need to know the parent.
 	 */
+	nd->intent.it_op |= IT_CREAT;
 	error = path_lookup(pathname, LOOKUP_PARENT|LOOKUP_OPEN|LOOKUP_CREATE, nd);
 	if (error)
 		return error;
@@ -1291,7 +1366,9 @@
 	dir = nd->dentry;
 	nd->flags &= ~LOOKUP_PARENT;
 	down(&dir->d_inode->i_sem);
+	nd->flags |= LOOKUP_LAST;
 	dentry = __lookup_hash(&nd->last, nd->dentry, nd);
+	nd->flags &= ~LOOKUP_LAST;
 
 do_last:
 	error = PTR_ERR(dentry);
@@ -1396,7 +1473,9 @@
 	}
 	dir = nd->dentry;
 	down(&dir->d_inode->i_sem);
+	nd->flags |= LOOKUP_LAST;
 	dentry = __lookup_hash(&nd->last, nd->dentry, nd);
+	nd->flags &= ~LOOKUP_LAST;
 	putname(nd->last.name);
 	goto do_last;
 }
@@ -1463,6 +1542,7 @@
 	char * tmp;
 	struct dentry * dentry;
 	struct nameidata nd;
+	intent_init(&nd.intent, IT_LOOKUP);
 
 	if (S_ISDIR(mode))
 		return -EPERM;
@@ -1475,6 +1555,15 @@
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
 		goto out;
+
+	if (nd.dentry->d_inode->i_op->mknod_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+		error = op->mknod_raw(&nd, mode, dev);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto out2;
+	}
+
 	dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(dentry);
 
@@ -1501,6 +1590,7 @@
 		dput(dentry);
 	}
 	up(&nd.dentry->d_inode->i_sem);
+out2:
 	path_release(&nd);
 out:
 	putname(tmp);
@@ -1547,10 +1637,18 @@
 
 		struct dentry *dentry;
 		struct nameidata nd;
+                intent_init(&nd.intent, IT_LOOKUP);
 
 		error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
+ 		if (nd.dentry->d_inode->i_op->mkdir_raw) {
+ 			struct inode_operations *op = nd.dentry->d_inode->i_op;
+ 			error = op->mkdir_raw(&nd, mode);
+ 			/* the file system wants to use normal vfs path now */
+ 			if (error != -EOPNOTSUPP)
+ 				goto out2;
+ 		}
 		dentry = lookup_create(&nd, 1);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
@@ -1560,6 +1658,7 @@
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+out2:
 		path_release(&nd);
 out:
 
@@ -1643,6 +1742,7 @@
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+        intent_init(&nd.intent, IT_LOOKUP);
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1665,6 +1765,14 @@
 			error = -EBUSY;
 			goto exit1;
 	}
+ 	if (nd.dentry->d_inode->i_op->rmdir_raw) {
+ 		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+ 		error = op->rmdir_raw(&nd);
+ 		/* the file system wants to use normal vfs path now */
+ 		if (error != -EOPNOTSUPP)
+ 			goto exit1;
+ 	}
 	down(&nd.dentry->d_inode->i_sem);
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
@@ -1726,6 +1834,7 @@
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
+        intent_init(&nd.intent, IT_LOOKUP);
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1739,6 +1848,13 @@
 	error = -EISDIR;
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
+ 	if (nd.dentry->d_inode->i_op->unlink_raw) {
+ 		struct inode_operations *op = nd.dentry->d_inode->i_op;
+ 		error = op->unlink_raw(&nd);
+ 		/* the file system wants to use normal vfs path now */
+ 		if (error != -EOPNOTSUPP)
+ 			goto exit1;
+ 	}
 	down(&nd.dentry->d_inode->i_sem);
 	dentry = lookup_hash(&nd.last, nd.dentry);
 	error = PTR_ERR(dentry);
@@ -1812,10 +1928,18 @@
 
 		struct dentry *dentry;
 		struct nameidata nd;
+                intent_init(&nd.intent, IT_LOOKUP);
 
 		error = path_lookup(to, LOOKUP_PARENT, &nd);
 		if (error)
 			goto out;
+		if (nd.dentry->d_inode->i_op->symlink_raw) {
+			struct inode_operations *op = nd.dentry->d_inode->i_op;
+			error = op->symlink_raw(&nd, from);
+			/* the file system wants to use normal vfs path now */
+			if (error != -EOPNOTSUPP)
+				goto out2;
+		}
 		dentry = lookup_create(&nd, 0);
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
@@ -1823,6 +1947,7 @@
 			dput(dentry);
 		}
 		up(&nd.dentry->d_inode->i_sem);
+out2:
 		path_release(&nd);
 out:
 
@@ -1889,6 +2014,8 @@
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
+        intent_init(&nd.intent, IT_LOOKUP);
+        intent_init(&old_nd.intent, IT_LOOKUP);
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -1907,6 +2034,13 @@
 	error = -EXDEV;
 	if (old_nd.mnt != nd.mnt)
 		goto out_release;
+        if (nd.dentry->d_inode->i_op->link_raw) {
+                struct inode_operations *op = nd.dentry->d_inode->i_op;
+                error = op->link_raw(&old_nd, &nd);
+                /* the file system wants to use normal vfs path now */
+                if (error != -EOPNOTSUPP)
+                        goto out_release;
+        }
 	new_dentry = lookup_create(&nd, 0);
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
@@ -1959,7 +2093,7 @@
  *	   locking].
  */
 int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+                   struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error = 0;
 	struct inode *target;
@@ -2004,7 +2138,7 @@
 }
 
 int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
-	       struct inode *new_dir, struct dentry *new_dentry)
+                     struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct inode *target;
 	int error;
@@ -2081,6 +2215,8 @@
 	struct dentry * old_dentry, *new_dentry;
 	struct dentry * trap;
 	struct nameidata oldnd, newnd;
+        intent_init(&oldnd.intent, IT_LOOKUP);
+        intent_init(&newnd.intent, IT_LOOKUP);
 
 	error = path_lookup(oldname, LOOKUP_PARENT, &oldnd);
 	if (error)
@@ -2103,6 +2239,13 @@
 	if (newnd.last_type != LAST_NORM)
 		goto exit2;
 
+ 	if (old_dir->d_inode->i_op->rename_raw) {
+ 		error = old_dir->d_inode->i_op->rename_raw(&oldnd, &newnd);
+ 		/* the file system wants to use normal vfs path now */
+ 		if (error != -EOPNOTSUPP)
+ 			goto exit2;
+ 	}
+
 	trap = lock_rename(new_dir, old_dir);
 
 	old_dentry = lookup_hash(&oldnd.last, old_dir);
@@ -2134,8 +2277,7 @@
 	if (new_dentry == trap)
 		goto exit5;
 
-	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+	error = vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry);
 exit5:
 	dput(new_dentry);
 exit4:
@@ -2196,7 +2338,9 @@
 __vfs_follow_link(struct nameidata *nd, const char *link)
 {
 	int res = 0;
+	struct lookup_intent it = nd->intent;
 	char *name;
+
 	if (IS_ERR(link))
 		goto fail;
 
@@ -2206,6 +2350,10 @@
 			/* weird __emul_prefix() stuff did it */
 			goto out;
 	}
+
+	intent_init(&nd->intent, it.it_op);
+	nd->intent.it_flags = it.it_flags;
+	nd->intent.it_create_mode = it.it_create_mode;
 	res = link_path_walk(link, nd);
 out:
 	if (current->link_count || res || nd->last_type!=LAST_NORM)
Index: linux-2.6.5/fs/namespace.c
===================================================================
--- linux-2.6.5.orig/fs/namespace.c	2004-05-25 12:35:38.000000000 +0200
+++ linux-2.6.5/fs/namespace.c	2004-05-25 12:35:46.000000000 +0200
@@ -108,6 +108,7 @@
 
 static void detach_mnt(struct vfsmount *mnt, struct nameidata *old_nd)
 {
+	memset(old_nd, 0, sizeof(*old_nd));
 	old_nd->dentry = mnt->mnt_mountpoint;
 	old_nd->mnt = mnt->mnt_parent;
 	mnt->mnt_parent = mnt;
@@ -750,6 +751,7 @@
 	int retval = 0;
 	int mnt_flags = 0;
 
+	intent_init(&nd.intent, IT_LOOKUP);
 	/* Discard magic */
 	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
 		flags &= ~MS_MGC_MSK;
Index: linux-2.6.5/fs/nfs/dir.c
===================================================================
--- linux-2.6.5.orig/fs/nfs/dir.c	2004-05-25 12:35:28.000000000 +0200
+++ linux-2.6.5/fs/nfs/dir.c	2004-05-25 12:35:46.000000000 +0200
@@ -709,7 +709,7 @@
 		return 0;
 	if (!nd || (nd->flags & LOOKUP_CONTINUE) || !(nd->flags & LOOKUP_CREATE))
 		return 0;
-	return (nd->intent.open.flags & O_EXCL) != 0;
+	return (nd->intent.it_flags & O_EXCL) != 0;
 }
 
 static struct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)
@@ -782,7 +782,7 @@
 	if (nd->flags & LOOKUP_DIRECTORY)
 		return 0;
 	/* Are we trying to write to a read only partition? */
-	if (IS_RDONLY(dir) && (nd->intent.open.flags & (O_CREAT|O_TRUNC|FMODE_WRITE)))
+	if (IS_RDONLY(dir) && (nd->intent.it_flags & (O_CREAT|O_TRUNC|FMODE_WRITE)))
 		return 0;
 	return 1;
 }
@@ -803,7 +803,7 @@
 	dentry->d_op = NFS_PROTO(dir)->dentry_ops;
 
 	/* Let vfs_create() deal with O_EXCL */
-	if (nd->intent.open.flags & O_EXCL)
+	if (nd->intent.it_flags & O_EXCL)
 		goto no_entry;
 
 	/* Open the file on the server */
@@ -811,7 +811,7 @@
 	/* Revalidate parent directory attribute cache */
 	nfs_revalidate_inode(NFS_SERVER(dir), dir);
 
-	if (nd->intent.open.flags & O_CREAT) {
+	if (nd->intent.it_flags & O_CREAT) {
 		nfs_begin_data_update(dir);
 		inode = nfs4_atomic_open(dir, dentry, nd);
 		nfs_end_data_update(dir);
@@ -827,7 +827,7 @@
 				break;
 			/* This turned out not to be a regular file */
 			case -ELOOP:
-				if (!(nd->intent.open.flags & O_NOFOLLOW))
+				if (!(nd->intent.it_flags & O_NOFOLLOW))
 					goto no_open;
 			/* case -EISDIR: */
 			/* case -EINVAL: */
@@ -861,7 +861,7 @@
 	dir = parent->d_inode;
 	if (!is_atomic_open(dir, nd))
 		goto no_open;
-	openflags = nd->intent.open.flags;
+	openflags = nd->intent.it_flags;
 	if (openflags & O_CREAT) {
 		/* If this is a negative dentry, just drop it */
 		if (!inode)
@@ -1026,7 +1026,7 @@
 	attr.ia_valid = ATTR_MODE;
 
 	if (nd && (nd->flags & LOOKUP_CREATE))
-		open_flags = nd->intent.open.flags;
+		open_flags = nd->intent.it_flags;
 
 	/*
 	 * The 0 argument passed into the create function should one day
Index: linux-2.6.5/fs/nfs/nfs4proc.c
===================================================================
--- linux-2.6.5.orig/fs/nfs/nfs4proc.c	2004-04-04 05:37:39.000000000 +0200
+++ linux-2.6.5/fs/nfs/nfs4proc.c	2004-05-25 12:35:46.000000000 +0200
@@ -792,17 +792,17 @@
 	struct nfs4_state *state;
 
 	if (nd->flags & LOOKUP_CREATE) {
-		attr.ia_mode = nd->intent.open.create_mode;
+		attr.ia_mode = nd->intent.it_create_mode;
 		attr.ia_valid = ATTR_MODE;
 		if (!IS_POSIXACL(dir))
 			attr.ia_mode &= ~current->fs->umask;
 	} else {
 		attr.ia_valid = 0;
-		BUG_ON(nd->intent.open.flags & O_CREAT);
+		BUG_ON(nd->intent.it_flags & O_CREAT);
 	}
 
 	cred = rpcauth_lookupcred(NFS_SERVER(dir)->client->cl_auth, 0);
-	state = nfs4_do_open(dir, &dentry->d_name, nd->intent.open.flags, &attr, cred);
+	state = nfs4_do_open(dir, &dentry->d_name, nd->intent.it_flags, &attr, cred);
 	put_rpccred(cred);
 	if (IS_ERR(state))
 		return (struct inode *)state;
Index: linux-2.6.5/fs/open.c
===================================================================
--- linux-2.6.5.orig/fs/open.c	2004-05-25 12:35:38.000000000 +0200
+++ linux-2.6.5/fs/open.c	2004-05-25 12:35:46.000000000 +0200
@@ -203,9 +203,10 @@
 	return error;
 }
 
-int do_truncate(struct dentry *dentry, loff_t length)
+int do_truncate(struct dentry *dentry, loff_t length, int called_from_open)
 {
 	int err;
+	struct inode_operations *op = dentry->d_inode->i_op;
 	struct iattr newattrs;
 
 	/* Not pretty: "inode->i_size" shouldn't really be signed. But it is. */
@@ -216,7 +217,14 @@
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
 	down(&dentry->d_inode->i_sem);
 	down_write(&dentry->d_inode->i_alloc_sem);
-	err = notify_change(dentry, &newattrs);
+	if (called_from_open)
+		newattrs.ia_valid |= ATTR_FROM_OPEN;
+	if (op->setattr_raw) {
+		newattrs.ia_valid |= ATTR_RAW;
+		newattrs.ia_ctime = CURRENT_TIME;
+		err = op->setattr_raw(dentry->d_inode, &newattrs);
+	} else
+		err = notify_change(dentry, &newattrs);
 	up_write(&dentry->d_inode->i_alloc_sem);
 	up(&dentry->d_inode->i_sem);
 	return err;
@@ -227,7 +235,7 @@
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
-
+	intent_init(&nd.intent, IT_GETATTR);
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
@@ -271,7 +279,7 @@
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
-		error = do_truncate(nd.dentry, length);
+		error = do_truncate(nd.dentry, length, 0);
 	}
 	put_write_access(inode);
 
@@ -328,7 +336,7 @@
 
 	error = locks_verify_truncate(inode, file, length);
 	if (!error)
-		error = do_truncate(dentry, length);
+		error = do_truncate(dentry, length, 0);
 out_putf:
 	fput(file);
 out:
@@ -402,9 +410,19 @@
 		    (error = permission(inode,MAY_WRITE,&nd)) != 0)
 			goto dput_and_out;
 	}
-	down(&inode->i_sem);
-	error = notify_change(nd.dentry, &newattrs);
-	up(&inode->i_sem);
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = nd.dentry->d_inode->i_op;
+
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto dput_and_out;
+	} else {
+                down(&inode->i_sem);
+                error = notify_change(nd.dentry, &newattrs);
+                up(&inode->i_sem);
+        }
 dput_and_out:
 	path_release(&nd);
 
@@ -466,6 +484,7 @@
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
@@ -506,6 +525,7 @@
 		if(!res && (mode & S_IWOTH) && IS_RDONLY(nd.dentry->d_inode)
 		   && !special_file(nd.dentry->d_inode->i_mode))
 			res = -EROFS;
+
 		path_release(&nd);
 
 	FSHOOK_END_USER_WALK(access, res, path)
@@ -545,11 +565,13 @@
 
 asmlinkage long sys_fchdir(unsigned int fd)
 {
+	struct nameidata nd;
 	struct file *file;
 	struct dentry *dentry;
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	FSHOOK_BEGIN(fchdir, error, .fd = fd)
 
@@ -582,6 +604,7 @@
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	FSHOOK_BEGIN_USER_WALK(chroot,
 		error,
@@ -609,39 +632,55 @@
 	return error;
 }
 
-asmlinkage long sys_fchmod(unsigned int fd, mode_t mode)
+int chmod_common(struct dentry *dentry, mode_t mode)
 {
-	struct inode * inode;
-	struct dentry * dentry;
-	struct file * file;
-	int err;
+	struct inode * inode = dentry->d_inode;
 	struct iattr newattrs;
+	int error = -EROFS;
 
-	FSHOOK_BEGIN(fchmod, err, .fd = fd, .mode = mode)
-
-	err = -EBADF;
-	file = fget(fd);
-	if (!file)
+	if (IS_RDONLY(inode))
 		goto out;
+	
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = dentry->d_inode->i_op;
+		
+		newattrs.ia_mode = mode;
+		newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use the normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			goto out;
+	}
 
-	dentry = file->f_dentry;
-	inode = dentry->d_inode;
-
-	err = -EROFS;
-	if (IS_RDONLY(inode))
-		goto out_putf;
-	err = -EPERM;
+	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
-		goto out_putf;
+		goto out;
+
 	down(&inode->i_sem);
 	if (mode == (mode_t) -1)
 		mode = inode->i_mode;
 	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
 	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
-	err = notify_change(dentry, &newattrs);
+	error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
 
-out_putf:
+out:
+	return error;
+}
+
+asmlinkage long sys_fchmod(unsigned int fd, mode_t mode)
+{
+	struct file * file;
+	int err = -EBADF;
+
+	FSHOOK_BEGIN(fchmod, err, .fd = fd, .mode = mode)
+
+	file = fget(fd);
+	if (!file)
+		goto out;
+
+	err = chmod_common(file->f_dentry, mode);
 	fput(file);
 out:
 
@@ -653,9 +692,7 @@
 asmlinkage long sys_chmod(const char __user * filename, mode_t mode)
 {
 	struct nameidata nd;
-	struct inode * inode;
 	int error;
-	struct iattr newattrs;
 
 	FSHOOK_BEGIN_USER_PATH_WALK(chmod,
 		error,
@@ -665,25 +702,7 @@
 		.mode = mode,
 		.link = false)
 
-	inode = nd.dentry->d_inode;
-
-	error = -EROFS;
-	if (IS_RDONLY(inode))
-		goto dput_and_out;
-
-	error = -EPERM;
-	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
-		goto dput_and_out;
-
-	down(&inode->i_sem);
-	if (mode == (mode_t) -1)
-		mode = inode->i_mode;
-	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
-	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
-	error = notify_change(nd.dentry, &newattrs);
-	up(&inode->i_sem);
-
-dput_and_out:
+	error = chmod_common(nd.dentry, mode);
 	path_release(&nd);
 
 	FSHOOK_END_USER_WALK(chmod, error, path)
@@ -706,6 +725,18 @@
 	if (IS_RDONLY(inode))
 		goto out;
 	error = -EPERM;
+	if (inode->i_op->setattr_raw) {
+		struct inode_operations *op = dentry->d_inode->i_op;
+
+		newattrs.ia_uid = user;
+		newattrs.ia_gid = group;
+		newattrs.ia_valid = ATTR_UID | ATTR_GID;
+		newattrs.ia_valid |= ATTR_RAW;
+		error = op->setattr_raw(inode, &newattrs);
+		/* the file system wants to use normal vfs path now */
+		if (error != -EOPNOTSUPP)
+			return error;
+	}
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
 	newattrs.ia_valid =  ATTR_CTIME;
@@ -719,6 +750,7 @@
 	}
 	if (!S_ISDIR(inode->i_mode))
 		newattrs.ia_valid |= ATTR_KILL_SUID|ATTR_KILL_SGID;
+
 	down(&inode->i_sem);
 	error = notify_change(dentry, &newattrs);
 	up(&inode->i_sem);
@@ -804,27 +836,8 @@
  * for the internal routines (ie open_namei()/follow_link() etc). 00 is
  * used by symlinks.
  */
-struct file *filp_open(const char * filename, int flags, int mode)
-{
-	int namei_flags, error;
-	struct nameidata nd;
-
-	namei_flags = flags;
-	if ((namei_flags+1) & O_ACCMODE)
-		namei_flags++;
-	if (namei_flags & O_TRUNC)
-		namei_flags |= 2;
-
-	error = open_namei(filename, namei_flags, mode, &nd);
-	if (!error)
-		return dentry_open(nd.dentry, nd.mnt, flags);
-
-	return ERR_PTR(error);
-}
-
-EXPORT_SYMBOL(filp_open);
-
-struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+struct file *dentry_open_it(struct dentry *dentry, struct vfsmount *mnt, int flags,
+			    struct lookup_intent *it)
 {
 	struct file * f;
 	struct inode *inode;
@@ -836,6 +849,7 @@
 		goto cleanup_dentry;
 	f->f_flags = flags;
 	f->f_mode = (flags+1) & O_ACCMODE;
+	f->f_it = it;
 	inode = dentry->d_inode;
 	if (f->f_mode & FMODE_WRITE) {
 		error = get_write_access(inode);
@@ -855,6 +869,7 @@
 		error = f->f_op->open(inode,f);
 		if (error)
 			goto cleanup_all;
+		intent_release(it);
 	}
 	f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);
 
@@ -879,6 +894,7 @@
 cleanup_file:
 	put_filp(f);
 cleanup_dentry:
+	intent_release(it);
 	dput(dentry);
 	mntput(mnt);
 	return ERR_PTR(error);
@@ -886,6 +902,37 @@
 
 EXPORT_SYMBOL(dentry_open);
 
+struct file *filp_open(const char * filename, int flags, int mode)
+{
+	int namei_flags, error;
+	struct file * temp_filp;
+	struct nameidata nd;
+	intent_init(&nd.intent, IT_OPEN);
+
+	namei_flags = flags;
+	if ((namei_flags+1) & O_ACCMODE)
+		namei_flags++;
+	if (namei_flags & O_TRUNC)
+		namei_flags |= 2;
+
+	error = open_namei(filename, namei_flags, mode, &nd);
+	if (!error) {
+		temp_filp = dentry_open_it(nd.dentry, nd.mnt, flags, &nd.intent);
+		return temp_filp;
+	}	
+	return ERR_PTR(error);
+}
+
+EXPORT_SYMBOL(filp_open);
+
+struct file *dentry_open(struct dentry *dentry, struct vfsmount *mnt, int flags)
+{
+	struct lookup_intent it;
+	intent_init(&it, IT_LOOKUP);
+
+	return dentry_open_it(dentry, mnt, flags, &it);
+}
+
 /*
  * Find an empty file descriptor entry, and mark it busy.
  */
Index: linux-2.6.5/fs/stat.c
===================================================================
--- linux-2.6.5.orig/fs/stat.c	2004-05-25 12:35:38.000000000 +0200
+++ linux-2.6.5/fs/stat.c	2004-05-25 12:35:46.000000000 +0200
@@ -37,7 +37,7 @@
 
 EXPORT_SYMBOL(generic_fillattr);
 
-int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+int vfs_getattr_it(struct vfsmount *mnt, struct dentry *dentry, struct lookup_intent *it, struct kstat *stat)
 {
 	struct inode *inode = dentry->d_inode;
 	int retval;
@@ -46,6 +46,8 @@
 	if (retval)
 		return retval;
 
+	if (inode->i_op->getattr_it)
+		return inode->i_op->getattr_it(mnt, dentry, it, stat);
 	if (inode->i_op->getattr)
 		return inode->i_op->getattr(mnt, dentry, stat);
 
@@ -62,14 +64,20 @@
 
 EXPORT_SYMBOL(vfs_getattr);
 
+int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+	return vfs_getattr_it(mnt, dentry, NULL, stat);
+}
+
 int vfs_stat(char __user *name, struct kstat *stat)
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	FSHOOK_BEGIN_USER_PATH_WALK(stat, error, name, nd, path, .link = false)
 
-		error = vfs_getattr(nd.mnt, nd.dentry, stat);
+	  error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.intent, stat);
 		path_release(&nd);
 
 	FSHOOK_END_USER_WALK(stat, error, path)
@@ -83,10 +91,11 @@
 {
 	struct nameidata nd;
 	int error;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	FSHOOK_BEGIN_USER_PATH_WALK_LINK(stat, error, name, nd, path, .link = true)
 
-		error = vfs_getattr(nd.mnt, nd.dentry, stat);
+		error = vfs_getattr_it(nd.mnt, nd.dentry, &nd.intent, stat);
 		path_release(&nd);
 
 	FSHOOK_END_USER_WALK(stat, error, path)
@@ -99,6 +108,8 @@
 int vfs_fstat(unsigned int fd, struct kstat *stat)
 {
 	int error;
+	struct nameidata nd;
+	intent_init(&nd.intent, IT_GETATTR);
 
 	FSHOOK_BEGIN(fstat, error, .fd = fd)
 
@@ -106,7 +117,8 @@
 
 	error = -EBADF;
 	if (f) {
-		error = vfs_getattr(f->f_vfsmnt, f->f_dentry, stat);
+		error = vfs_getattr_it(f->f_vfsmnt, f->f_dentry, &nd.intent, stat);
+		intent_release(&nd.intent);
 		fput(f);
 	}
 
Index: linux-2.6.5/fs/super.c
===================================================================
--- linux-2.6.5.orig/fs/super.c	2004-05-25 12:35:37.000000000 +0200
+++ linux-2.6.5/fs/super.c	2004-05-25 12:35:46.000000000 +0200
@@ -789,6 +789,8 @@
 	return (struct vfsmount *)sb;
 }
 
+EXPORT_SYMBOL(do_kern_mount);
+
 struct vfsmount *kern_mount(struct file_system_type *type)
 {
 	return do_kern_mount(type->name, 0, type->name, NULL);
Index: linux-2.6.5/include/linux/blockgroup_lock.h
===================================================================
--- linux-2.6.5.orig/include/linux/blockgroup_lock.h	2004-04-04 05:36:26.000000000 +0200
+++ linux-2.6.5/include/linux/blockgroup_lock.h	2004-05-25 12:35:46.000000000 +0200
@@ -3,6 +3,8 @@
  *
  * Simple hashed spinlocking.
  */
+#ifndef _LINUX_BLOCKGROUP_LOCK_H
+#define _LINUX_BLOCKGROUP_LOCK_H
 
 #include <linux/config.h>
 #include <linux/spinlock.h>
@@ -55,4 +57,4 @@
 #define sb_bgl_lock(sb, block_group) \
 	(&(sb)->s_blockgroup_lock.locks[(block_group) & (NR_BG_LOCKS-1)].lock)
 
-
+#endif
Index: linux-2.6.5/include/linux/dcache.h
===================================================================
--- linux-2.6.5.orig/include/linux/dcache.h	2004-05-25 12:35:30.000000000 +0200
+++ linux-2.6.5/include/linux/dcache.h	2004-05-25 12:35:46.000000000 +0200
@@ -4,6 +4,7 @@
 #ifdef __KERNEL__
 
 #include <asm/atomic.h>
+#include <linux/string.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <linux/cache.h>
@@ -24,6 +25,11 @@
 
 #define IS_ROOT(x) ((x) == (x)->d_parent)
 
+struct dentry_params {
+	unsigned long   p_inum;
+	void            *p_ptr;
+};
+
 /*
  * "quick string" -- eases parameter passing, but more importantly
  * saves "metadata" about the string (ie length and the hash).
@@ -35,6 +41,8 @@
 	char name_str[0];
 };
 
+#include <linux/namei.h>
+
 struct dentry_stat_t {
 	int nr_dentry;
 	int nr_unused;
@@ -153,6 +161,8 @@
 
 #define DCACHE_REFERENCED	0x0008  /* Recently used, don't discard. */
 #define DCACHE_UNHASHED		0x0010	
+#define DCACHE_LUSTRE_INVALID     0x0020  /* Lustre invalidated */
+
 
 extern spinlock_t dcache_lock;
 
Index: linux-2.6.5/include/linux/ext2_fs_sb.h
===================================================================
--- linux-2.6.5.orig/include/linux/ext2_fs_sb.h	2004-04-04 05:38:13.000000000 +0200
+++ linux-2.6.5/include/linux/ext2_fs_sb.h	2004-05-25 12:35:46.000000000 +0200
@@ -16,9 +16,11 @@
 #ifndef _LINUX_EXT2_FS_SB
 #define _LINUX_EXT2_FS_SB
 
+#ifndef EXT_INCLUDE
+#define EXT_INCLUDE
 #include <linux/blockgroup_lock.h>
 #include <linux/percpu_counter.h>
-
+#endif
 /*
  * second extended-fs super-block data in memory
  */
Index: linux-2.6.5/include/linux/fs.h
===================================================================
--- linux-2.6.5.orig/include/linux/fs.h	2004-05-25 12:35:37.000000000 +0200
+++ linux-2.6.5/include/linux/fs.h	2004-05-25 12:35:46.000000000 +0200
@@ -250,6 +250,8 @@
 #define ATTR_ATTR_FLAG	1024
 #define ATTR_KILL_SUID	2048
 #define ATTR_KILL_SGID	4096
+#define ATTR_RAW       	8192    /* file system, not vfs will massage attrs */
+#define ATTR_FROM_OPEN 	16384    /* called from open path, ie O_TRUNC */
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -320,6 +322,7 @@
 	int (*releasepage) (struct page *, int);
 	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs);
+	void (*removepage)(struct page *); /* called when page gets removed from the inode */
 };
 
 struct backing_dev_info;
@@ -423,6 +426,7 @@
 	struct block_device	*i_bdev;
 	struct cdev		*i_cdev;
 	int			i_cindex;
+	void			*i_filterdata;
 
 	unsigned long		i_dnotify_mask; /* Directory notify events */
 	struct dnotify_struct	*i_dnotify; /* for directory notifications */
@@ -556,6 +560,7 @@
 	spinlock_t		f_ep_lock;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
+ 	struct lookup_intent    *f_it;
 };
 extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
@@ -874,19 +879,28 @@
 	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
 	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
+	int (*link_raw) (struct nameidata *,struct nameidata *);
 	int (*unlink) (struct inode *,struct dentry *);
+	int (*unlink_raw) (struct nameidata *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
+	int (*symlink_raw) (struct nameidata *,const char *);
 	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*mkdir_raw) (struct nameidata *,int);
 	int (*rmdir) (struct inode *,struct dentry *);
+	int (*rmdir_raw) (struct nameidata *);
 	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
+	int (*mknod_raw) (struct nameidata *,int,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename_raw) (struct nameidata *, struct nameidata *);
 	int (*readlink) (struct dentry *, char __user *,int);
 	int (*follow_link) (struct dentry *, struct nameidata *);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int, struct nameidata *);
 	int (*setattr) (struct dentry *, struct iattr *);
+	int (*setattr_raw) (struct inode *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
+	int (*getattr_it) (struct vfsmount *, struct dentry *, struct lookup_intent *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
@@ -1114,6 +1128,7 @@
 extern int unregister_filesystem(struct file_system_type *);
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount(struct vfsmount *);
+struct vfsmount *do_kern_mount(const char *type, int flags, const char *name, void *data);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
 
 extern int vfs_statfs(struct super_block *, struct kstatfs *);
@@ -1175,9 +1190,10 @@
 
 /* fs/open.c */
 
-extern int do_truncate(struct dentry *, loff_t start);
+extern int do_truncate(struct dentry *, loff_t start, int called_from_open);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+extern struct file * dentry_open_it(struct dentry *, struct vfsmount *, int, struct lookup_intent *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
 
@@ -1430,6 +1446,7 @@
 
 extern struct file_operations generic_ro_fops;
 
+extern rwlock_t file_systems_lock;
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
 
 extern int vfs_readlink(struct dentry *, char __user *, int, const char *);
Index: linux-2.6.5/include/linux/lustre_version.h
===================================================================
--- linux-2.6.5.orig/include/linux/lustre_version.h	2002-10-21 17:56:58.000000000 +0200
+++ linux-2.6.5/include/linux/lustre_version.h	2004-05-25 12:35:46.000000000 +0200
@@ -0,0 +1 @@
+#define LUSTRE_KERNEL_VERSION 36
Index: linux-2.6.5/include/linux/mm.h
===================================================================
--- linux-2.6.5.orig/include/linux/mm.h	2004-05-25 12:35:36.000000000 +0200
+++ linux-2.6.5/include/linux/mm.h	2004-05-25 12:35:46.000000000 +0200
@@ -557,6 +557,8 @@
 {
 	return (page->flags >> (NODEZONE_SHIFT + ZONES_SHIFT));
 }
+/* truncate.c */
+extern void truncate_complete_page(struct address_space *mapping,struct page *);
 
 struct zone;
 extern struct zone *zone_table[];
Index: linux-2.6.5/include/linux/namei.h
===================================================================
--- linux-2.6.5.orig/include/linux/namei.h	2004-05-25 12:35:38.000000000 +0200
+++ linux-2.6.5/include/linux/namei.h	2004-05-25 12:35:46.000000000 +0200
@@ -2,25 +2,55 @@
 #define _LINUX_NAMEI_H
 
 #include <linux/linkage.h>
+#include <linux/string.h>
 
 struct vfsmount;
+struct nameidata;
 
-struct open_intent {
-	int	flags;
-	int	create_mode;
+/* intent opcodes */
+#define IT_OPEN     (1)
+#define IT_CREAT    (1<<1)
+#define IT_READDIR  (1<<2)
+#define IT_GETATTR  (1<<3)
+#define IT_LOOKUP   (1<<4)
+#define IT_UNLINK   (1<<5)
+#define IT_TRUNC    (1<<6)
+#define IT_GETXATTR (1<<7)
+
+struct lustre_intent_data {
+	int       it_disposition;
+	int       it_status;
+	__u64     it_lock_handle;
+	void     *it_data;
+	int       it_lock_mode;
 };
 
+#define INTENT_MAGIC 0x19620323
+struct lookup_intent {
+	int     it_magic;
+	int     it_op;
+	void    (*it_op_release)(struct lookup_intent *);
+	int	it_flags;
+	int	it_create_mode;
+	union {
+		struct lustre_intent_data lustre;
+	} d;
+};
+
+static inline void intent_init(struct lookup_intent *it, int op)
+{
+	memset(it, 0, sizeof(*it));
+	it->it_magic = INTENT_MAGIC;
+	it->it_op = op;
+}
+
 struct nameidata {
 	struct dentry	*dentry;
 	struct vfsmount *mnt;
 	struct qstr	last;
 	unsigned int	flags;
 	int		last_type;
-
-	/* Intent data */
-	union {
-		struct open_intent open;
-	} intent;
+	struct lookup_intent intent;
 };
 
 /*
@@ -41,6 +71,9 @@
 #define LOOKUP_CONTINUE		 4
 #define LOOKUP_PARENT		16
 #define LOOKUP_NOALT		32
+#define LOOKUP_LAST		 (1<<6)
+#define LOOKUP_LINK_NOTLAST	 (1<<7)
+
 /*
  * Intent data
  */
@@ -49,6 +82,12 @@
 #define LOOKUP_ACCESS		(0x0400)
 
 extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *, const char **));
+extern int FASTCALL(__user_walk_it(const char __user *, unsigned, struct nameidata *, const char **));
+#define user_path_walk_it(name,nd) \
+	__user_walk_it(name, LOOKUP_FOLLOW, nd, 0)
+#define user_path_walk_link_it(name,nd) \
+	__user_walk_it(name, 0, nd, 0)
+extern void intent_release(struct lookup_intent *);
 #define user_path_walk(name,nd) \
 	__user_walk(name, LOOKUP_FOLLOW, nd, 0)
 #define user_path_walk_link(name,nd) \
@@ -60,7 +99,6 @@
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
-
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);
 
Index: linux-2.6.5/include/linux/percpu_counter.h
===================================================================
--- linux-2.6.5.orig/include/linux/percpu_counter.h	2004-04-04 05:37:23.000000000 +0200
+++ linux-2.6.5/include/linux/percpu_counter.h	2004-05-25 12:35:46.000000000 +0200
@@ -3,6 +3,8 @@
  *
  * WARNING: these things are HUGE.  4 kbytes per counter on 32-way P4.
  */
+#ifndef _LINUX_PERCPU_COUNTER_H
+#define _LINUX_PERCPU_COUNTER_H
 
 #include <linux/config.h>
 #include <linux/spinlock.h>
@@ -101,3 +103,5 @@
 {
 	percpu_counter_mod(fbc, -1);
 }
+
+#endif /* _LINUX_PERCPU_COUNTER_H */
Index: linux-2.6.5/kernel/exit.c
===================================================================
--- linux-2.6.5.orig/kernel/exit.c	2004-05-25 12:35:38.000000000 +0200
+++ linux-2.6.5/kernel/exit.c	2004-05-25 12:35:46.000000000 +0200
@@ -259,6 +259,8 @@
 	write_unlock_irq(&tasklist_lock);
 }
 
+EXPORT_SYMBOL(reparent_to_init);
+
 void __set_special_pids(pid_t session, pid_t pgrp)
 {
 	struct task_struct *curr = current;
@@ -428,6 +430,8 @@
 	__exit_files(tsk);
 }
 
+EXPORT_SYMBOL(exit_files);
+
 static inline void __put_fs_struct(struct fs_struct *fs)
 {
 	/* No need to hold fs->lock if we are killing it */
Index: linux-2.6.5/kernel/kallsyms.c
===================================================================
--- linux-2.6.5.orig/kernel/kallsyms.c	2004-05-25 12:35:27.000000000 +0200
+++ linux-2.6.5/kernel/kallsyms.c	2004-05-25 12:35:46.000000000 +0200
@@ -323,3 +323,4 @@
 
 EXPORT_SYMBOL(kallsyms_lookup);
 EXPORT_SYMBOL(__print_symbol);
+EXPORT_SYMBOL(kernel_text_address);
Index: linux-2.6.5/mm/filemap.c
===================================================================
--- linux-2.6.5.orig/mm/filemap.c	2004-05-25 12:35:38.000000000 +0200
+++ linux-2.6.5/mm/filemap.c	2004-05-25 12:35:46.000000000 +0200
@@ -103,6 +103,9 @@
 {
 	struct address_space *mapping = page_mapping(page);
 
+	if (mapping->a_ops->removepage)
+		mapping->a_ops->removepage(page);
+
 	if (likely(!PageSwapCache(page))) {
 		BUG_ON(PageAnon(page));
 		WARN_ON(page->mapcount);
Index: linux-2.6.5/mm/truncate.c
===================================================================
--- linux-2.6.5.orig/mm/truncate.c	2004-05-25 12:35:35.000000000 +0200
+++ linux-2.6.5/mm/truncate.c	2004-05-25 12:35:46.000000000 +0200
@@ -42,7 +42,7 @@
  * its lock, b) when a concurrent invalidate_inode_pages got there first and
  * c) when tmpfs swizzles a page between a tmpfs inode and swapper_space.
  */
-static void
+void
 truncate_complete_page(struct address_space *mapping, struct page *page)
 {
 	if (page->mapping != mapping)
@@ -57,7 +57,7 @@
 	remove_from_page_cache(page);
 	page_cache_release(page);	/* pagecache ref */
 }
-
+EXPORT_SYMBOL_GPL(truncate_complete_page);
 /*
  * This is for invalidate_inode_pages().  That function can be called at
  * any time, and is not supposed to throw away dirty pages.  But pages can
Index: linux-2.6.5/net/unix/af_unix.c
===================================================================
--- linux-2.6.5.orig/net/unix/af_unix.c	2004-04-04 05:37:36.000000000 +0200
+++ linux-2.6.5/net/unix/af_unix.c	2004-05-25 12:35:46.000000000 +0200
@@ -676,6 +676,7 @@
 	int err = 0;
 	
 	if (sunname->sun_path[0]) {
+		intent_init(&nd.intent, IT_LOOKUP);
 		err = path_lookup(sunname->sun_path, LOOKUP_FOLLOW, &nd);
 		if (err)
 			goto fail;
