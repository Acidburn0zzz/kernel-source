
	This hunk from the USAGI CVS makes sure that we don't fragment too early.
	Otherwise doing a "ping6 -s 1452" against a Linux box would (for some NICs)
	cause fragmented echo replies, even though the packet is exactly 1500
	bytes. This breaks some TAHI tests.

--- test/linux-2.6.3/net/ipv6/ip6_output.c	2004-02-19 11:36:37.000000000 +0100
+++ linux-2.6.3/net/ipv6/ip6_output.c	2004-02-26 17:21:58.000000000 +0100
@@ -847,7 +847,6 @@
 	hh_len = LL_RESERVED_SPACE(rt->u.dst.dev);
 
 	fragheaderlen = sizeof(struct ipv6hdr) + (opt ? opt->opt_nflen : 0);
-	maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);
 
 	if (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {
 		if (inet->cork.length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {
@@ -856,6 +855,11 @@
 		}
 	}
 
+	if (fragheaderlen + inet->cork.length + length <= mtu)
+		maxfraglen = mtu;
+	else
+		maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);
+
 	inet->cork.length += length;
 
 	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)
@@ -867,8 +871,10 @@
 			unsigned int datalen;
 			unsigned int fraglen;
 			unsigned int alloclen;
+			struct sk_buff *skb_prev;
 			BUG_TRAP(copy == 0);
 alloc_new_skb:
+			skb_prev = skb;
 			datalen = maxfraglen - fragheaderlen;
 			if (datalen > length)
 				datalen = length;
@@ -877,7 +883,15 @@
 			    !(rt->u.dst.dev->features&NETIF_F_SG))
 				alloclen = maxfraglen;
 			else
-				alloclen = fraglen;
+				alloclen = datalen + fragheaderlen;
+
+			/* The last fragment gets additional space at tail.
+			 * Note, with MSG_MORE we overallocate on fragments,
+			 * because we have no idea what fragment will be
+			 * the last.
+			 */
+			if (datalen == length)
+				alloclen += rt->u.dst.trailer_len;
 			alloclen += sizeof(struct frag_hdr);
 			if (transhdrlen) {
 				skb = sock_alloc_send_skb(sk,
