
	This hunk from the USAGI CVS makes sure that we don't fragment too early.
	Otherwise doing a "ping6 -s 1452" against a Linux box would (for some NICs)
	cause fragmented echo replies, even though the packet is exactly 1500
	bytes. This breaks some TAHI tests.

Index: linux-2.6.8/net/ipv6/ip6_output.c
===================================================================
--- linux-2.6.8.orig/net/ipv6/ip6_output.c
+++ linux-2.6.8/net/ipv6/ip6_output.c
@@ -866,9 +866,8 @@ int ip6_append_data(struct sock *sk, int
 
 	hh_len = LL_RESERVED_SPACE(rt->u.dst.dev);
 
 	fragheaderlen = sizeof(struct ipv6hdr) + (opt ? opt->opt_nflen : 0);
-	maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);
 
 	if (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {
 		if (inet->cork.length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {
 			ipv6_local_error(sk, EMSGSIZE, fl, mtu-exthdrlen);
@@ -891,8 +890,13 @@ int ip6_append_data(struct sock *sk, int
 	 *        are too large.
 	 * --yoshfuji 
 	 */
 
+	if (fragheaderlen + inet->cork.length + length <= mtu)
+		maxfraglen = mtu;
+	else
+		maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);
+
 	inet->cork.length += length;
 
 	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)
 		goto alloc_new_skb;
