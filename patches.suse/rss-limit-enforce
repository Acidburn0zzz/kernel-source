
The patch below implements RSS ulimit enforcement for 2.6.8-rc3-mm1.
It works in a very simple way: if a process has more resident memory
than its RSS limit allows, we pretend it didn't access any of its
pages, making it easy for the pageout code to evict the pages.

In addition to this, we don't allow a process that exceeds its RSS
limit to have the swapout protection token.

I have tested the patch on my system here and it appears to be working
fine.

Signed-off-by: Rik van Riel <riel@redhat.com>

Index: linux-2.6.8/include/linux/init_task.h
===================================================================
--- linux-2.6.8.orig/include/linux/init_task.h	2004-08-15 01:48:30.400760738 +0200
+++ linux-2.6.8/include/linux/init_task.h	2004-08-15 01:52:25.552747211 +0200
@@ -2,6 +2,7 @@
 #define _LINUX__INIT_TASK_H
 
 #include <linux/file.h>
+#include <asm/resource.h>
 
 #define INIT_FILES \
 { 							\
@@ -42,6 +43,7 @@
 	.mmlist		= LIST_HEAD_INIT(name.mmlist),		\
 	.cpu_vm_mask	= CPU_MASK_ALL,				\
 	.default_kioctx = INIT_KIOCTX(name.default_kioctx, name),	\
+	.rlimit_rss	= RLIM_INFINITY,			\
 }
 
 #define INIT_SIGNALS(sig) {	\
Index: linux-2.6.8/include/linux/sched.h
===================================================================
--- linux-2.6.8.orig/include/linux/sched.h	2004-08-15 01:48:30.400760738 +0200
+++ linux-2.6.8/include/linux/sched.h	2004-08-15 01:52:00.282973286 +0200
@@ -210,7 +210,7 @@
 	unsigned long start_code, end_code, start_data, end_data;
 	unsigned long start_brk, brk, start_stack;
 	unsigned long arg_start, arg_end, env_start, env_end;
-	unsigned long rss, total_vm, locked_vm;
+	unsigned long rlimit_rss, rss, total_vm, locked_vm;
 	unsigned long def_flags;
 
 	unsigned long saved_auxv[40]; /* for /proc/PID/auxv */
Index: linux-2.6.8/fs/exec.c
===================================================================
--- linux-2.6.8.orig/fs/exec.c	2004-08-15 01:48:30.399760866 +0200
+++ linux-2.6.8/fs/exec.c	2004-08-15 01:52:00.284973031 +0200
@@ -1107,6 +1107,11 @@
 	retval = init_new_context(current, bprm.mm);
 	if (retval < 0)
 		goto out_mm;
+	if (likely(current->mm)) {
+		bprm.mm->rlimit_rss = current->mm->rlimit_rss;
+	} else {
+		bprm.mm->rlimit_rss = init_mm.rlimit_rss;
+	}
 
 	bprm.argc = count(argv, bprm.p / sizeof(void *));
 	if ((retval = bprm.argc) < 0)
Index: linux-2.6.8/kernel/sys.c
===================================================================
--- linux-2.6.8.orig/kernel/sys.c	2004-08-15 01:48:30.399760866 +0200
+++ linux-2.6.8/kernel/sys.c	2004-08-15 01:52:00.286972775 +0200
@@ -1521,6 +1521,14 @@
 	if (retval)
 		return retval;
 
+	/* The rlimit is specified in bytes, convert to pages for mm. */
+	if (resource == RLIMIT_RSS && current->mm) {
+		unsigned long pages = RLIM_INFINITY;
+		if (new_rlim.rlim_cur != RLIM_INFINITY)
+			pages = new_rlim.rlim_cur >> PAGE_SHIFT;
+		current->mm->rlimit_rss = pages;
+	}
+
 	*old_rlim = new_rlim;
 	return 0;
 }
Index: linux-2.6.8/mm/rmap.c
===================================================================
--- linux-2.6.8.orig/mm/rmap.c	2004-08-15 01:48:30.399760866 +0200
+++ linux-2.6.8/mm/rmap.c	2004-08-15 01:52:00.287972648 +0200
@@ -230,6 +230,9 @@
 	if (ptep_clear_flush_young(vma, address, pte))
 		referenced++;
 
+	if (mm->rss > mm->rlimit_rss)
+		referenced = 0;
+
 	(*mapcount)--;
 
 out_unmap:
