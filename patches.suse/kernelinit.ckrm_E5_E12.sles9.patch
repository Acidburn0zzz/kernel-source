--- a/init/main.c	2004-04-26 12:35:37.000000000 -0400
+++ b/init/main.c	2004-04-28 23:35:15.000000000 -0400
@@ -47,7 +47,6 @@
 #include <asm/bugs.h>
 
 #include <linux/ckrm.h>
-#include <linux/ckrm_res.h>
 
 /*
  * This is one of the first .c files built. Error out early
--- a/kernel/exit.c	2004-04-26 12:35:37.000000000 -0400
+++ b/kernel/exit.c	2004-04-28 23:39:27.000000000 -0400
@@ -26,6 +26,7 @@
 #include <linux/kdb.h>
 #endif
 #include <linux/ckrm.h>
+#include <linux/ckrm_tsk.h>
 #include <linux/audit.h>
 
 #include <asm/uaccess.h>
@@ -802,6 +803,7 @@
 		module_put(tsk->binfmt->module);
 
 	tsk->exit_code = code;
+	numtasks_put_ref(tsk->taskclass);
 	exit_notify(tsk);
 	schedule();
 	BUG();
--- a/kernel/fork.c	2004-04-26 12:35:37.000000000 -0400
+++ b/kernel/fork.c	2004-04-28 23:43:21.000000000 -0400
@@ -35,6 +35,7 @@
 #include <linux/audit.h>
 
 #include <linux/ckrm.h>
+#include <linux/ckrm_tsk.h>
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -269,7 +270,7 @@
 	tsk->thread_info = ti;
 	ti->task = tsk;
 
-	ckrm_new_task(tsk);
+	ckrm_cb_newtask(tsk);
 	/* One for us, one for whoever does the "release_task()" (usually parent) */
 	atomic_set(&tsk->usage,2);
 	return tsk;
@@ -1196,6 +1197,10 @@
 			clone_flags |= CLONE_PTRACE;
 	}
 
+	if (numtasks_get_ref(current->taskclass, 0) == 0) {
+		return -ENOMEM;
+	}
+
 	p = copy_process(clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr);
 	/*
 	 * Do this prior waking up the new thread - the thread pointer
@@ -1263,6 +1268,8 @@
 			 * COW overhead when the child exec()s afterwards.
 			 */
 			set_need_resched();
+	} else {
+		numtasks_put_ref(current->taskclass);
 	}
 	return pid;
 }
--- a/include/linux/sched.h	2004-04-26 12:35:37.000000000 -0400
+++ b/include/linux/sched.h	2004-04-29 00:17:12.000000000 -0400
@@ -514,10 +514,14 @@
  * to a stack based synchronous wait) if its doing sync IO.
  */
 	wait_queue_t *io_wait;
+
 #ifdef CONFIG_CKRM
-	void *ckrm_core;
-	struct list_head ckrm_link;
-	void *ce_data;
+	spinlock_t  ckrm_tsklock; 
+	void       *ce_data;
+#ifdef CONFIG_CKRM_TYPE_TASKCLASS
+	struct ckrm_task_class *taskclass;
+	struct list_head        taskclass_link;
+#endif // CONFIG_CKRM_TYPE_TASKCLASS
 #endif // CONFIG_CKRM
 
 	/* this is empty if CONFIG_DELAY_ACCT is not set */
