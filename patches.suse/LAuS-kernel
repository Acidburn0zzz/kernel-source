diff -urNp linux-2.6.5/arch/i386/kernel/ioport.c linux-2.6.5.SUSE/arch/i386/kernel/ioport.c
--- linux-2.6.5/arch/i386/kernel/ioport.c	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5.SUSE/arch/i386/kernel/ioport.c	2004-04-22 16:11:15.000000000 +0200
@@ -15,6 +15,7 @@
 #include <linux/stddef.h>
 #include <linux/slab.h>
 #include <linux/thread_info.h>
+#include <linux/audit.h>
 
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, unsigned int base, unsigned int extent, int new_value)
@@ -60,10 +61,12 @@ asmlinkage long sys_ioperm(unsigned long
 	struct tss_struct * tss;
 	unsigned long *bitmap;
 
+	audit_intercept(AUDIT_ioperm, from, num, turn_on);
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
-		return -EINVAL;
+		return audit_result(-EINVAL);
 	if (turn_on && !capable(CAP_SYS_RAWIO))
-		return -EPERM;
+		return audit_result(-EPERM);
 
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
@@ -73,7 +76,7 @@ asmlinkage long sys_ioperm(unsigned long
 	if (!t->io_bitmap_ptr) {
 		bitmap = kmalloc(IO_BITMAP_BYTES, GFP_KERNEL);
 		if (!bitmap)
-			return -ENOMEM;
+			return audit_result(-ENOMEM);
 
 		memset(bitmap, 0xff, IO_BITMAP_BYTES);
 		t->io_bitmap_ptr = bitmap;
@@ -91,7 +94,7 @@ asmlinkage long sys_ioperm(unsigned long
 		tss->io_bitmap_base = IO_BITMAP_OFFSET; /* Activate it in the TSS */
 	}
 	put_cpu();
-	return 0;
+	return audit_result(0);
 }
 
 /*
@@ -111,15 +114,17 @@ asmlinkage long sys_iopl(unsigned long u
 	unsigned int level = regs->ebx;
 	unsigned int old = (regs->eflags >> 12) & 3;
 
+	audit_intercept(AUDIT_iopl, level);
+
 	if (level > 3)
-		return -EINVAL;
+		return audit_result(-EINVAL);
 	/* Trying to gain more privileges? */
 	if (level > old) {
 		if (!capable(CAP_SYS_RAWIO))
-			return -EPERM;
+			return audit_result(-EPERM);
 	}
 	regs->eflags = (regs->eflags &~ 0x3000UL) | (level << 12);
 	/* Make sure we return the long way (not sysenter) */
 	set_thread_flag(TIF_IRET);
-	return 0;
+	return audit_result(0);
 }
diff -urNp linux-2.6.5/arch/i386/kernel/ptrace.c linux-2.6.5.SUSE/arch/i386/kernel/ptrace.c
--- linux-2.6.5/arch/i386/kernel/ptrace.c	2004-04-22 16:10:51.000000000 +0200
+++ linux-2.6.5.SUSE/arch/i386/kernel/ptrace.c	2004-04-22 16:11:15.000000000 +0200
@@ -14,6 +14,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -240,6 +241,8 @@ asmlinkage int sys_ptrace(long request, 
 	struct user * dummy = NULL;
 	int i, ret;
 
+	audit_intercept(AUDIT_ptrace, request, pid, addr, data);
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
@@ -569,7 +572,7 @@ out_tsk:
 	put_task_struct(child);
 out:
 	unlock_kernel();
-	return ret;
+	return audit_result(ret);
 }
 
 /* notification of system call entry/exit
diff -urNp linux-2.6.5/arch/ia64/ia32/sys_ia32.c linux-2.6.5.SUSE/arch/ia64/ia32/sys_ia32.c
--- linux-2.6.5/arch/ia64/ia32/sys_ia32.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ia64/ia32/sys_ia32.c	2004-04-22 16:11:15.000000000 +0200
@@ -49,6 +49,7 @@
 #include <linux/ipc.h>
 #include <linux/compat.h>
 #include <linux/vfs.h>
+#include <linux/audit.h>
 
 #include <asm/intrinsics.h>
 #include <asm/semaphore.h>
@@ -1445,12 +1446,21 @@ sys32_ptrace (int request, pid_t pid, un
 	unsigned int value, tmp;
 	long i, ret;
 
-	lock_kernel();
-	if (request == PTRACE_TRACEME) {
-		ret = sys_ptrace(request, pid, addr, data, arg4, arg5, arg6, arg7, stack);
-		goto out;
+	switch (request) {
+	      case PTRACE_TRACEME:
+	      case PTRACE_ATTACH:
+	      case PTRACE_SYSCALL:
+	      case PTRACE_CONT:
+	      case PTRACE_KILL:
+	      case PTRACE_SINGLESTEP:
+	      case PTRACE_DETACH:
+		return sys_ptrace(request, pid, addr, data, arg4, arg5, arg6, arg7, stack);
 	}
 
+	audit_intercept(AUDIT_ptrace, request, pid, addr, data);
+
+	lock_kernel();
+
 	ret = -ESRCH;
 	read_lock(&tasklist_lock);
 	child = find_task_by_pid(pid);
@@ -1463,11 +1473,6 @@ sys32_ptrace (int request, pid_t pid, un
 	if (pid == 1)		/* no messing around with init! */
 		goto out_tsk;
 
-	if (request == PTRACE_ATTACH) {
-		ret = sys_ptrace(request, pid, addr, data, arg4, arg5, arg6, arg7, stack);
-		goto out_tsk;
-	}
-
 	ret = ptrace_check_attach(child, request == PTRACE_KILL);
 	if (ret < 0)
 		goto out_tsk;
@@ -1547,14 +1552,6 @@ sys32_ptrace (int request, pid_t pid, un
 		ret = restore_ia32_fpxstate(child, (struct ia32_user_fxsr_struct *) A(data));
 		break;
 
-	      case PTRACE_SYSCALL:	/* continue, stop after next syscall */
-	      case PTRACE_CONT:		/* restart after signal. */
-	      case PTRACE_KILL:
-	      case PTRACE_SINGLESTEP:	/* execute chile for one instruction */
-	      case PTRACE_DETACH:	/* detach a process */
-		ret = sys_ptrace(request, pid, addr, data, arg4, arg5, arg6, arg7, stack);
-		break;
-
 	      default:
 		ret = ptrace_request(child, request, addr, data);
 		break;
@@ -1564,7 +1561,7 @@ sys32_ptrace (int request, pid_t pid, un
 	put_task_struct(child);
   out:
 	unlock_kernel();
-	return ret;
+	return audit_result(ret);
 }
 
 /*
@@ -1582,23 +1579,25 @@ sys32_iopl (int level)
 	unsigned long addr;
 	mm_segment_t old_fs = get_fs ();
 
+	audit_intercept(AUDIT_iopl, level);
+
 	if (level != 3)
-		return(-EINVAL);
+		return audit_result(-EINVAL);
 	/* Trying to gain more privileges? */
 	old = ia64_getreg(_IA64_REG_AR_EFLAG);
 	if ((unsigned int) level > ((old >> 12) & 3)) {
 		if (!capable(CAP_SYS_RAWIO))
-			return -EPERM;
+			return audit_result(-EPERM);
 	}
 	set_fs(KERNEL_DS);
 	fd = sys_open("/dev/mem", O_SYNC | O_RDWR, 0);
 	set_fs(old_fs);
 	if (fd < 0)
-		return fd;
+		return audit_result(fd);
 	file = fget(fd);
 	if (file == NULL) {
 		sys_close(fd);
-		return(-EFAULT);
+		return audit_result(-EFAULT);
 	}
 
 	down_write(&current->mm->mmap_sem);
@@ -1614,7 +1613,7 @@ sys32_iopl (int level)
 
 	fput(file);
 	sys_close(fd);
-	return 0;
+	return audit_result(0);
 }
 
 asmlinkage long
@@ -1867,20 +1866,23 @@ sys32_setgroups16 (int gidsetsize, short
 	int retval;
 
 	if (!capable(CAP_SETGID))
-		return -EPERM;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-EPERM);
 	if ((unsigned)gidsetsize > NGROUPS_MAX)
-		return -EINVAL;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-EINVAL);
 
 	group_info = groups_alloc(gidsetsize);
 	if (!group_info)
-		return -ENOMEM;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-ENOMEM);
 	retval = groups16_from_user(group_info, grouplist);
 	if (retval) {
 		put_group_info(group_info);
-		return retval;
+		audit_intercept(AUDIT_setgroups, NULL);
+		return audit_result(retval);
 	}
 
-	retval = set_current_groups(group_info);
+	audit_intercept(AUDIT_setgroups, group_info);
+
+	(void)audit_result(retval = set_current_groups(group_info));
 	put_group_info(group_info);
 
 	return retval;
diff -urNp linux-2.6.5/arch/ia64/kernel/ptrace.c linux-2.6.5.SUSE/arch/ia64/kernel/ptrace.c
--- linux-2.6.5/arch/ia64/kernel/ptrace.c	2004-04-04 05:38:22.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ia64/kernel/ptrace.c	2004-04-22 16:11:15.000000000 +0200
@@ -17,6 +17,7 @@
 #include <linux/smp_lock.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
@@ -1281,6 +1282,8 @@ sys_ptrace (long request, pid_t pid, uns
 	struct switch_stack *sw;
 	long ret;
 
+	audit_intercept(AUDIT_ptrace, request, pid, addr, data);
+
 	lock_kernel();
 	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
@@ -1444,7 +1447,7 @@ sys_ptrace (long request, pid_t pid, uns
 	put_task_struct(child);
   out:
 	unlock_kernel();
-	return ret;
+	return audit_result(ret);
 }
 
 /* "asmlinkage" so the input arguments are preserved... */
diff -urNp linux-2.6.5/arch/ia64/kernel/sys_ia64.c linux-2.6.5.SUSE/arch/ia64/kernel/sys_ia64.c
--- linux-2.6.5/arch/ia64/kernel/sys_ia64.c	2004-04-22 16:10:49.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ia64/kernel/sys_ia64.c	2004-04-22 16:11:15.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/syscalls.h>
 #include <linux/highuid.h>
 #include <linux/hugetlb.h>
+#include <linux/audit.h>
 
 #include <asm/shmparam.h>
 #include <asm/uaccess.h>
@@ -117,6 +118,8 @@ ia64_brk (unsigned long brk)
 	 * check and the clearing of r8.  However, we can't call sys_brk() because we need
 	 * to acquire the mmap_sem before we can do the test...
 	 */
+	audit_intercept(AUDIT_brk, brk);
+
 	down_write(&mm->mmap_sem);
 
 	if (brk < mm->end_code)
@@ -155,7 +158,7 @@ out:
 	retval = mm->brk;
 	up_write(&mm->mmap_sem);
 	force_successful_syscall_return();
-	return retval;
+	return audit_lresult(retval);
 }
 
 /*
diff -urNp linux-2.6.5/arch/ppc/kernel/ptrace.c linux-2.6.5.SUSE/arch/ppc/kernel/ptrace.c
--- linux-2.6.5/arch/ppc/kernel/ptrace.c	2004-04-04 05:36:52.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ppc/kernel/ptrace.c	2004-04-22 16:11:15.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -176,6 +177,8 @@ int sys_ptrace(long request, long pid, l
 	struct task_struct *child;
 	int ret = -EPERM;
 
+	audit_intercept(AUDIT_ptrace, request, pid, addr, data);
+
 	lock_kernel();
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
@@ -369,7 +372,7 @@ out_tsk:
 	put_task_struct(child);
 out:
 	unlock_kernel();
-	return ret;
+	return audit_result(ret);
 }
 
 void do_syscall_trace(void)
diff -urNp linux-2.6.5/arch/ppc64/kernel/ptrace.c linux-2.6.5.SUSE/arch/ppc64/kernel/ptrace.c
--- linux-2.6.5/arch/ppc64/kernel/ptrace.c	2004-04-04 05:37:59.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ppc64/kernel/ptrace.c	2004-04-22 16:11:15.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -54,6 +55,8 @@ int sys_ptrace(long request, long pid, l
 	struct task_struct *child;
 	int ret = -EPERM;
 
+	audit_intercept(AUDIT_ptrace, request, pid, addr, data);
+
 	lock_kernel();
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
@@ -283,7 +286,7 @@ out_tsk:
 	put_task_struct(child);
 out:
 	unlock_kernel();
-	return ret;
+	return audit_result(ret);
 }
 
 void do_syscall_trace(void)
diff -urNp linux-2.6.5/arch/ppc64/kernel/ptrace32.c linux-2.6.5.SUSE/arch/ppc64/kernel/ptrace32.c
--- linux-2.6.5/arch/ppc64/kernel/ptrace32.c	2004-04-04 05:37:23.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ppc64/kernel/ptrace32.c	2004-04-22 16:11:15.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -43,6 +44,8 @@ int sys32_ptrace(long request, long pid,
 	struct task_struct *child;
 	int ret = -EPERM;
 
+	audit_intercept(AUDIT_ptrace, request, pid, addr, data);
+
 	lock_kernel();
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
@@ -420,5 +423,5 @@ out_tsk:
 	put_task_struct(child);
 out:
 	unlock_kernel();
-	return ret;
+	return audit_result(ret);
 }
diff -urNp linux-2.6.5/arch/ppc64/kernel/sys_ppc32.c linux-2.6.5.SUSE/arch/ppc64/kernel/sys_ppc32.c
--- linux-2.6.5/arch/ppc64/kernel/sys_ppc32.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ppc64/kernel/sys_ppc32.c	2004-04-22 16:11:15.000000000 +0200
@@ -61,6 +61,7 @@
 #include <linux/compat.h>
 #include <linux/ptrace.h>
 #include <linux/aio_abi.h>
+#include <linux/audit.h>
 
 #include <asm/types.h>
 #include <asm/ipc.h>
@@ -1825,9 +1826,12 @@ static int do_execve32(char * filename, 
 
 	file = open_exec(filename);
 
+	/* don't do this prior to open_exec, as that will invoke an FS hook */
+	audit_intercept(AUDIT_execve|AUDIT_32, filename, argv, envp);
+
 	retval = PTR_ERR(file);
 	if (IS_ERR(file))
-		return retval;
+		return audit_result(retval);
 
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
 	memset(bprm.page, 0, MAX_ARG_PAGES * sizeof(bprm.page[0]));
@@ -1881,7 +1885,7 @@ static int do_execve32(char * filename, 
 	if (retval >= 0) {
 		/* execve success */
 		security_bprm_free(&bprm);
-		return retval;
+		return audit_result(retval);
 	}
 
 out:
@@ -1904,7 +1908,7 @@ out_file:
 		allow_write_access(bprm.file);
 		fput(bprm.file);
 	}
-	return retval;
+	return audit_result(retval);
 }
 
 long sys32_execve(unsigned long a0, unsigned long a1, unsigned long a2,
diff -urNp linux-2.6.5/arch/ppc64/kernel/time.c linux-2.6.5.SUSE/arch/ppc64/kernel/time.c
--- linux-2.6.5/arch/ppc64/kernel/time.c	2004-04-04 05:38:16.000000000 +0200
+++ linux-2.6.5.SUSE/arch/ppc64/kernel/time.c	2004-04-22 16:11:15.000000000 +0200
@@ -48,6 +48,7 @@
 #include <linux/time.h>
 #include <linux/init.h>
 #include <linux/profile.h>
+#include <linux/audit.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
@@ -436,7 +437,7 @@ long ppc64_sys32_stime(int* tptr)
 	struct timespec myTimeval;
 
 	if (!capable(CAP_SYS_TIME))
-		return -EPERM;
+		return audit_intercept(AUDIT_settimeofday, NULL, NULL), audit_result(-EPERM);
 
 	if (get_user(value, tptr))
 		return -EFAULT;
@@ -444,9 +445,10 @@ long ppc64_sys32_stime(int* tptr)
 	myTimeval.tv_sec = value;
 	myTimeval.tv_nsec = 0;
 
+	audit_intercept(AUDIT_settimeofday, &myTimeval, NULL);
 	do_settimeofday(&myTimeval);
 
-	return 0;
+	return audit_result(0);
 }
 
 /*
@@ -461,7 +463,7 @@ long ppc64_sys_stime(long* tptr)
 	struct timespec myTimeval;
 
 	if (!capable(CAP_SYS_TIME))
-		return -EPERM;
+		return audit_intercept(AUDIT_settimeofday, NULL, NULL), audit_result(-EPERM);
 
 	if (get_user(value, tptr))
 		return -EFAULT;
@@ -469,9 +471,10 @@ long ppc64_sys_stime(long* tptr)
 	myTimeval.tv_sec = value;
 	myTimeval.tv_nsec = 0;
 
+	audit_intercept(AUDIT_settimeofday, &myTimeval, NULL);
 	do_settimeofday(&myTimeval);
 
-	return 0;
+	return audit_result(0);
 }
 
 void __init time_init(void)
diff -urNp linux-2.6.5/arch/s390/kernel/compat_linux.c linux-2.6.5.SUSE/arch/s390/kernel/compat_linux.c
--- linux-2.6.5/arch/s390/kernel/compat_linux.c	2004-04-04 05:37:42.000000000 +0200
+++ linux-2.6.5.SUSE/arch/s390/kernel/compat_linux.c	2004-04-22 16:11:15.000000000 +0200
@@ -58,6 +58,7 @@
 #include <linux/compat.h>
 #include <linux/vfs.h>
 #include <linux/ptrace.h>
+#include <linux/audit.h>
 
 #include <asm/types.h>
 #include <asm/ipc.h>
@@ -235,20 +236,23 @@ asmlinkage long sys32_setgroups16(int gi
 	int retval;
 
 	if (!capable(CAP_SETGID))
-		return -EPERM;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-EPERM);
 	if ((unsigned)gidsetsize > NGROUPS_MAX)
-		return -EINVAL;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-EINVAL);
 
 	group_info = groups_alloc(gidsetsize);
 	if (!group_info)
-		return -ENOMEM;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-ENOMEM);
 	retval = groups16_from_user(group_info, grouplist);
 	if (retval) {
 		put_group_info(group_info);
-		return retval;
+		audit_intercept(AUDIT_setgroups, NULL);
+		return audit_result(retval);
 	}
 
-	retval = set_current_groups(group_info);
+	audit_intercept(AUDIT_setgroups, group_info);
+
+	(void)audit_result(retval = set_current_groups(group_info));
 	put_group_info(group_info);
 
 	return retval;
@@ -1146,9 +1150,12 @@ do_execve32(char * filename, u32 * argv,
 
 	file = open_exec(filename);
 
+	/* don't do this prior to open_exec, as that will invoke an FS hook */
+	audit_intercept(AUDIT_execve|AUDIT_32, filename, argv, envp);
+
 	retval = PTR_ERR(file);
 	if (IS_ERR(file))
-		return retval;
+		return audit_result(retval);
 
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
 	memset(bprm.page, 0, MAX_ARG_PAGES * sizeof(bprm.page[0]));
@@ -1199,7 +1206,7 @@ do_execve32(char * filename, u32 * argv,
 	if (retval >= 0) {
 		/* execve success */
 		security_bprm_free(&bprm);
-		return retval;
+		return audit_result(retval);
 	}
 
 out:
@@ -1223,7 +1230,7 @@ out_file:
 		fput(bprm.file);
 	}
 
-	return retval;
+	return audit_result(retval);
 }
 
 /*
diff -urNp linux-2.6.5/arch/s390/kernel/ptrace.c linux-2.6.5.SUSE/arch/s390/kernel/ptrace.c
--- linux-2.6.5/arch/s390/kernel/ptrace.c	2004-04-04 05:38:14.000000000 +0200
+++ linux-2.6.5.SUSE/arch/s390/kernel/ptrace.c	2004-04-22 16:11:15.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 
 #include <asm/segment.h>
 #include <asm/page.h>
@@ -653,6 +654,8 @@ sys_ptrace(long request, long pid, long 
 	struct task_struct *child;
 	int ret;
 
+	audit_intercept(AUDIT_ptrace, request, pid, addr, data);
+
 	lock_kernel();
 
 	if (request == PTRACE_TRACEME) {
@@ -686,7 +689,7 @@ sys_ptrace(long request, long pid, long 
 	put_task_struct(child);
 out:
 	unlock_kernel();
-	return ret;
+	return audit_result(ret);
 }
 
 asmlinkage void
diff -urNp linux-2.6.5/arch/x86_64/ia32/ptrace32.c linux-2.6.5.SUSE/arch/x86_64/ia32/ptrace32.c
--- linux-2.6.5/arch/x86_64/ia32/ptrace32.c	2004-04-04 05:36:54.000000000 +0200
+++ linux-2.6.5.SUSE/arch/x86_64/ia32/ptrace32.c	2004-04-22 16:11:15.000000000 +0200
@@ -17,6 +17,7 @@
 #include <linux/syscalls.h>
 #include <linux/unistd.h>
 #include <linux/mm.h>
+#include <linux/audit.h>
 #include <asm/ptrace.h>
 #include <asm/uaccess.h>
 #include <asm/user32.h>
@@ -252,9 +253,11 @@ asmlinkage long sys32_ptrace(long reques
 		
 	} 
 
+	audit_intercept(AUDIT_ptrace, request, pid, addr, data);
+
 	child = find_target(request, pid, &ret);
 	if (!child)
-		return ret;
+		return audit_result(ret);
 
 	childregs = (struct pt_regs *)(child->thread.rsp0 - sizeof(struct pt_regs)); 
 
@@ -368,6 +371,6 @@ asmlinkage long sys32_ptrace(long reques
 	}
 
 	put_task_struct(child);
-	return ret;
+	return audit_result(ret);
 }
 
diff -urNp linux-2.6.5/arch/x86_64/ia32/sys_ia32.c linux-2.6.5.SUSE/arch/x86_64/ia32/sys_ia32.c
--- linux-2.6.5/arch/x86_64/ia32/sys_ia32.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/arch/x86_64/ia32/sys_ia32.c	2004-04-22 16:11:15.000000000 +0200
@@ -62,6 +62,7 @@
 #include <linux/ptrace.h>
 #include <linux/highuid.h>
 #include <linux/vmalloc.h>
+#include <linux/audit.h>
 #include <asm/mman.h>
 #include <asm/types.h>
 #include <asm/uaccess.h>
@@ -1837,16 +1838,19 @@ long sys32_vm86_warning(void)
 	return -ENOSYS;
 } 
 
-long sys32_quotactl(void)
+long sys32_quotactl(unsigned int cmd, const char *special, qid_t id, caddr_t addr)
 { 
 	struct task_struct *me = current;
 	static char lastcomm[8];
+
+	audit_intercept(AUDIT_quotactl, cmd, NULL, id, addr);
+
 	if (strcmp(lastcomm, me->comm)) {
 		printk(KERN_INFO "%s: 32bit quotactl not supported on 64 bit kernel\n",
 		       me->comm);
 		strcpy(lastcomm, me->comm); 
 	} 
-	return -ENOSYS;
+	return audit_result(-ENOSYS);
 } 
 
 cond_syscall(sys32_ipc)
diff -urNp linux-2.6.5/arch/x86_64/kernel/ioport.c linux-2.6.5.SUSE/arch/x86_64/kernel/ioport.c
--- linux-2.6.5/arch/x86_64/kernel/ioport.c	2004-04-04 05:36:45.000000000 +0200
+++ linux-2.6.5.SUSE/arch/x86_64/kernel/ioport.c	2004-04-22 16:11:15.000000000 +0200
@@ -15,6 +15,7 @@
 #include <linux/stddef.h>
 #include <linux/slab.h>
 #include <linux/thread_info.h>
+#include <linux/audit.h>
 
 /* Set EXTENT bits starting at BASE in BITMAP to value TURN_ON. */
 static void set_bitmap(unsigned long *bitmap, unsigned int base, unsigned int extent, int new_value)
@@ -38,10 +39,12 @@ asmlinkage long sys_ioperm(unsigned long
 	struct tss_struct * tss;
 	unsigned long *bitmap;
 
+	audit_intercept(AUDIT_ioperm, from, num, turn_on);
+
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
-		return -EINVAL;
+		return audit_result(-EINVAL);
 	if (turn_on && !capable(CAP_SYS_RAWIO))
-		return -EPERM;
+		return audit_result(-EPERM);
 
 	/*
 	 * If it's the first ioperm() call in this thread's lifetime, set the
@@ -51,7 +54,7 @@ asmlinkage long sys_ioperm(unsigned long
 	if (!t->io_bitmap_ptr) {
 		bitmap = kmalloc(IO_BITMAP_BYTES, GFP_KERNEL);
 		if (!bitmap)
-			return -ENOMEM;
+			return audit_result(-ENOMEM);
 
 		memset(bitmap, 0xff, IO_BITMAP_BYTES);
 		t->io_bitmap_ptr = bitmap;
@@ -69,7 +72,7 @@ asmlinkage long sys_ioperm(unsigned long
 		tss->io_bitmap_base = IO_BITMAP_OFFSET; /* Activate it in the TSS */
 	}
 	put_cpu();
-	return 0;
+	return audit_result(0);
 }
 
 /*
@@ -87,13 +90,15 @@ asmlinkage long sys_iopl(unsigned int le
 {
 	unsigned int old = (regs.eflags >> 12) & 3;
 
+	audit_intercept(AUDIT_iopl, level);
+
 	if (level > 3)
-		return -EINVAL;
+		return audit_result(-EINVAL);
 	/* Trying to gain more privileges? */
 	if (level > old) {
 		if (!capable(CAP_SYS_RAWIO))
-			return -EPERM;
+			return audit_result(-EPERM);
 	}
 	regs.eflags = (regs.eflags &~ 0x3000UL) | (level << 12);
-	return 0;
+	return audit_result(0);
 }
diff -urNp linux-2.6.5/arch/x86_64/kernel/ptrace.c linux-2.6.5.SUSE/arch/x86_64/kernel/ptrace.c
--- linux-2.6.5/arch/x86_64/kernel/ptrace.c	2004-04-04 05:36:54.000000000 +0200
+++ linux-2.6.5.SUSE/arch/x86_64/kernel/ptrace.c	2004-04-22 16:11:15.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -184,6 +185,8 @@ asmlinkage long sys_ptrace(long request,
 	long i, ret;
 	unsigned ui;
 
+	audit_intercept(AUDIT_ptrace, request, pid, addr, data);
+
 	/* This lock_kernel fixes a subtle race with suid exec */
 	lock_kernel();
 	ret = -EPERM;
@@ -483,7 +486,7 @@ out_tsk:
 	put_task_struct(child);
 out:
 	unlock_kernel();
-	return ret;
+	return audit_result(ret);
 }
 
 asmlinkage void syscall_trace(struct pt_regs *regs)
diff -urNp linux-2.6.5/drivers/Kconfig linux-2.6.5.SUSE/drivers/Kconfig
--- linux-2.6.5/drivers/Kconfig	2004-04-04 05:38:17.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/Kconfig	2004-04-22 16:11:15.000000000 +0200
@@ -52,4 +52,6 @@ source "sound/Kconfig"
 
 source "drivers/usb/Kconfig"
 
+source "drivers/audit/Kconfig"
+
 endmenu
diff -urNp linux-2.6.5/drivers/Makefile linux-2.6.5.SUSE/drivers/Makefile
--- linux-2.6.5/drivers/Makefile	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/drivers/Makefile	2004-04-22 16:11:15.000000000 +0200
@@ -52,3 +52,6 @@ obj-$(CONFIG_EISA)		+= eisa/
 obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-y				+= firmware/
 obj-$(CONFIG_CRASH_DUMP)	+= dump/
+ifneq (,$(findstring $(CONFIG_AUDIT),y m))
+obj-y				+= audit/
+endif
diff -urNp linux-2.6.5/drivers/audit/Kconfig linux-2.6.5.SUSE/drivers/audit/Kconfig
--- linux-2.6.5/drivers/audit/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/Kconfig	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,6 @@
+config AUDIT
+	tristate "Auditing subsystem"
+	depends on FSHOOKS
+	default y
+	---help---
+	  //todo.
diff -urNp linux-2.6.5/drivers/audit/Makefile linux-2.6.5.SUSE/drivers/audit/Makefile
--- linux-2.6.5/drivers/audit/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/Makefile	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,15 @@
+AUDIT_OBJS := control.o message.o args.o fileset.o filter.o syscall.o \
+	sysctl.o
+ifeq ($(CONFIG_COMPAT),y)
+AUDIT_OBJS += ioctl.o
+endif
+
+ifeq ($(CONFIG_AUDIT),y)
+obj-y      := $(AUDIT_OBJS) stubs.o
+endif
+
+ifeq ($(CONFIG_AUDIT),m)
+audit-objs := $(AUDIT_OBJS)
+obj-y      := stubs.o
+obj-m      := audit.o
+endif
diff -urNp linux-2.6.5/drivers/audit/args.c linux-2.6.5.SUSE/drivers/audit/args.c
--- linux-2.6.5/drivers/audit/args.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/args.c	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,850 @@
+/*
+ * args.c
+ *
+ * Linux Audit Subsystem, argument handling
+ *
+ * Copyright (C) 2003 SuSE Linux AG
+ *
+ * Written by okir@suse.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/mount.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/namei.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/skbuff.h>
+#include <linux/mman.h>
+#include <net/sock.h>
+
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+
+#include <linux/audit.h>
+
+#include "audit-private.h"
+
+#undef DEBUG_MEMORY
+
+#define AUDIT_MAX_ARGV	32	/* Max # of argv entries copied for execve() */
+
+static int		__audit_copy_arg(struct aud_syscall_data *, const struct sysarg *,
+	       				struct sysarg_data *, uint64_t);
+static void		__audit_release_arg(struct sysarg_data *);
+#ifdef DEBUG_MEMORY
+static void *		mem_alloc(size_t, int);
+static void		mem_free(void *);
+#else
+#define mem_alloc	kmalloc
+#define mem_free	kfree
+#endif
+
+/*
+ * Copy argument from user space
+ */
+static int
+do_copy_from_user(struct sysarg_data *target, void *arg, size_t len)
+{
+	if (target->at_flags & AUD_ARG_USER) {
+
+		if (copy_from_user(target->at_data.ptr, arg, len))
+			return -EFAULT;
+	}
+	else
+		memcpy(target->at_data.ptr, arg, len);
+
+	return 0;
+}
+
+/*
+ * Perform a realpath() sort of pathname resolution.
+ * The buffer pointed to by target->path.name must be
+ * allocated with __getname().
+ *
+ * XXX: need to lock path down to target
+ */
+static int
+do_realpath(struct sysarg_data *target, void *arg, int arg_flags)
+{
+	struct nameidata nd;
+	unsigned int	name_len, pathsize;
+	int		error, flags, len;
+	char		*pathbuf, *slash, *str;
+
+	/* strnlen_user includes the NUL character */
+	len = unlikely(target->at_flags & AUD_ARG_USER) ? strnlen_user(arg, PATH_MAX) : strnlen(arg, PATH_MAX) + 1;
+	if (len > PATH_MAX)
+		len = PATH_MAX;
+	else if (len < 1)
+		return len < 0 ? len : -EFAULT;
+
+	if ((error = do_copy_from_user(target, arg, len)) < 0)
+		return error;
+
+	pathbuf  = target->at_path.name;
+	pathsize = target->at_path.len;
+	pathbuf[--len] = '\0';
+
+	target->at_path.len = len;
+	if (len == 0)
+		return 0;
+
+	DPRINTF("resolving [0x%p] \"%*.*s\"\n", arg, len, len, pathbuf);
+
+	if ((target->at_flags & AUD_ARG_DIRNAME) || (arg_flags & O_NOFOLLOW))
+		flags = LOOKUP_PARENT;
+	else
+		flags = LOOKUP_FOLLOW;
+
+	slash = NULL;
+	while (1) {
+		struct vfsmount *mnt;
+
+		memset(&nd, 0, sizeof(nd));
+		error = -ENOBUFS;
+		if (!audit_path_init(pathbuf, flags, &nd))
+			break;
+
+		/* Keep the dentry for matching purposes */
+		mnt = mntget(nd.mnt);
+		target->at_path.dentry = dget(nd.dentry);
+
+		error = path_walk(pathbuf, &nd);
+		if (error != -ENOENT) {
+			mntput(mnt);
+			dput(target->at_path.dentry);
+			target->at_path.dentry = !error ? dget(nd.dentry) : NULL;
+			BUG_ON(error > 0);
+			break;
+		}
+
+		/* Shorten the path by one component */
+		if (!(str = strrchr(pathbuf, '/'))) {
+			/* path_walk did path_release(&nd) already */
+			memset(&nd, 0, sizeof(nd));
+			nd.mnt = mnt;
+			nd.dentry = dget(target->at_path.dentry);
+			error = 0;
+			if (slash)
+				*slash = '/';
+			slash = pathbuf - 1; /* note that this points to a virtual slash */
+			break;
+		}
+		mntput(mnt);
+		dput(target->at_path.dentry);
+		while (str > pathbuf && str[-1] == '/')
+			--str;
+		if (str == pathbuf)
+			break;
+
+		if (slash)
+			*slash = '/';
+		*(slash = str) = '\0';
+
+		/* No need to do a path_release; path_walk does that
+		 * for us in case of an error */
+		flags = LOOKUP_FOLLOW;
+	}
+
+	if (error < 0)
+		return error;
+
+	target->at_path.exists = (slash == NULL);
+
+	if (nd.last.len)
+		slash = (char *) nd.last.name - 1;
+
+	/* If the file doesn't exist, we had to look up
+	 * a parent directory instead. Move the trailing
+	 * components out of the way so they don't get
+	 * clobbered by the d_path call below. */
+	if (slash) {
+		name_len = strlen(slash + 1);
+		pathsize -= name_len + 1;
+		memmove(pathbuf + pathsize + 1, slash + 1, name_len++);
+		*(slash = pathbuf + pathsize) = '/';
+	}
+	else
+		name_len = 0;
+
+	str = d_path(nd.dentry, nd.mnt, pathbuf, pathsize);
+	if (IS_ERR(str)) {
+		DPRINTF("d_path returns error %ld\n", PTR_ERR(str));
+		path_release(&nd);
+		dput(target->at_path.dentry);
+		target->at_path.dentry = NULL;
+		return PTR_ERR(str);
+	}
+
+	len = strlen(str);
+	if (str != pathbuf)
+		memmove(pathbuf, str, len+1);
+	DPRINTF("dir=%s\n", pathbuf);
+
+	/* Attach the last path component (we've already made
+	 * sure above that the buffer space is sufficient) */
+	if (name_len) {
+		DPRINTF("last=%.*s\n", name_len, slash);
+		memcpy(pathbuf + len, slash, name_len);
+		len += name_len;
+		pathbuf[len] = '\0';
+	}
+	target->at_path.len = len;
+
+	path_release(&nd);
+	return len;
+}
+
+/*
+ * Copying this argument failed... try to deal with it.
+ */
+static int
+__audit_fail_argument(struct sysarg_data *target, int error)
+{
+	/* Release any memory we may already have allocated to
+	 * this argument. */
+	__audit_release_arg(target);
+
+	memset(target, 0, sizeof(*target));
+	target->at_type = AUDIT_ARG_ERROR;
+	target->at_intval = -error;
+	return 0;
+}
+
+/*
+ * Copy path name argument from user space and perform realpath()
+ * on it
+ */
+static int
+__audit_copy_pathname(struct sysarg_data *target, caddr_t value, int flags)
+{
+	char	*pathname;
+
+	/* For pathnames, we want to perform a realpath()
+	 * call here
+	 */
+	if (!(pathname = __getname()))
+		return -1;
+	target->at_path.name = pathname;
+	target->at_path.len = PATH_MAX;
+	target->at_path.dentry = NULL;
+
+	if (do_realpath(target, value, flags) >= 0)
+		return 0;
+
+	memset(&target->at_path, 0, sizeof(target->at_path));
+	putname(pathname);
+	return -1;
+}
+
+/*
+ * Copy file descriptor argument and try to get the path name
+ * associated with it
+ */
+static int
+__audit_copy_filedesc(struct sysarg_data *target, long value)
+{
+	char		*pathname = NULL, *str;
+	struct file	*filp = NULL;
+	struct inode	*inode;
+	int		len, err = 0;
+
+	filp = fget(value);
+	if (!filp || !filp->f_dentry)
+		goto bad_filedesc;
+
+	if (!(pathname = __getname())) {
+		err = -ENOBUFS;
+		goto out;
+	}
+
+	target->at_path.name = pathname;
+	target->at_type = AUDIT_ARG_PATH;
+	target->at_path.len = PATH_MAX;
+	target->at_path.dentry = NULL;
+
+	inode = filp->f_dentry->d_inode;
+	if (inode->i_sock) {
+		struct socket   *sock = SOCKET_I(inode);
+
+		snprintf(pathname, PATH_MAX, "[sock:af=%d,type=%d]",
+				sock->ops->family, sock->type);
+		len = strlen(pathname);
+	} else {
+		if (!filp->f_vfsmnt)
+			goto bad_filedesc;
+		str = d_path(filp->f_dentry, filp->f_vfsmnt, pathname, PATH_MAX);
+		if (IS_ERR(str)) {
+			err = PTR_ERR(str);
+			goto out;
+		}
+		len = strlen(str);
+		if (str != pathname)
+			memmove(pathname, str, len+1);
+	}
+
+	DPRINTF("dir=%s\n", pathname);
+	target->at_path.dentry = dget(filp->f_dentry);
+	target->at_path.len = len;
+
+out:	if (err < 0 && pathname)
+	{
+		putname(pathname);
+	}
+	if (filp)
+		fput(filp);
+	return err;
+
+bad_filedesc:
+	/* Bad filedesc - this is nothing to worry about,
+	 * just flag it */
+	target->at_type = AUDIT_ARG_ERROR;
+	target->at_intval = EBADF;
+	goto out;
+}
+
+/*
+ * Copy arguments from user space
+ */
+static int
+__audit_copy_from_user(struct aud_syscall_data *sc, const struct sysarg *sysarg,
+			struct sysarg_data *target, uint64_t value)
+{
+	caddr_t		pvalue;
+	size_t		len;
+
+	memset(target, 0, sizeof(*target));
+	target->at_flags = sysarg->sa_flags;
+	switch (target->at_type = sysarg->sa_type) {
+	case AUDIT_ARG_IMMEDIATE:
+		target->at_intval = value;
+		return 0;
+	case AUDIT_ARG_FILEDESC:
+		return __audit_copy_filedesc(target, value);
+	default:
+		break;
+	}
+
+	/* Pointer valued argument. First, check for NULL pointer */
+	if (value == 0) {
+		target->at_type = AUDIT_ARG_NULL;
+		target->at_data.ptr = NULL;
+		target->at_data.len = 0;
+		return 0;
+	}
+	/* Interpret value as a pointer */
+	pvalue = (caddr_t) (long) value;
+
+	switch (target->at_type) {
+	/* Path names are special; we copy the string _and_
+	 * perform a realpath() on it */
+	case AUDIT_ARG_PATH: 
+		if (__audit_copy_pathname(target, pvalue, sc->major != AUDIT_open ? 0 : sc->raw_args[1]) >= 0)
+			return 0;
+		/* Failed; treat it as string */
+		memset(target, 0, sizeof(*target));
+		target->at_flags = sysarg->sa_flags;
+		target->at_type = AUDIT_ARG_STRING;
+	case AUDIT_ARG_STRING:
+		/* strnlen_user includes the NUL character.
+		 * We want to keep it, because we need to copy it
+		 * to our scratch VM in case we decide the
+		 * argument needs to be locked.
+		 * We'll discard it later in encode_arguments
+		 * when copying it to auditd. */
+		len = unlikely(sysarg->sa_flags & AUD_ARG_USER) ? strnlen_user(pvalue, PATH_MAX) : strnlen(pvalue, PATH_MAX) + 1;
+		if (len > PATH_MAX)
+			len = PATH_MAX;
+		break;
+
+	case AUDIT_ARG_POINTER:
+		len = sysarg->sa_size;
+		break;
+
+	case AUDIT_ARG_GROUP_INFO:
+		/* Convert the structure to a flat array */
+		len = ((struct group_info *)pvalue)->ngroups * sizeof(gid_t);
+		target->at_type = AUDIT_ARG_POINTER;
+		break;
+
+	case AUDIT_ARG_IPC_MSG:
+		/* Flatten the structure */
+		len = sizeof(struct msgbuf) + ((struct msg_msg *)pvalue)->m_ts;
+		target->at_type = AUDIT_ARG_POINTER;
+		break;
+
+	case AUDIT_ARG_ARRAY: {
+			/* Arrays are pointers, with another
+			 * syscall argument specifying the number
+			 * of elements */
+			unsigned int nitems = sc->raw_args[sysarg->sa_ref];
+
+			if (nitems > sysarg->sa_max)
+				nitems = sysarg->sa_max;
+			target->at_type = AUDIT_ARG_POINTER;
+			len  = nitems * sysarg->sa_size;
+		}
+		break;
+
+	default:
+		DPRINTF("unknown arg type %d\n", target->at_type);
+		return -EINVAL;
+	}
+
+	if (len != 0) {
+		int	err;
+
+		target->at_data.ptr = mem_alloc(len, GFP_KERNEL);
+		target->at_data.len = len;
+		if (!target->at_data.ptr)
+			return -ENOBUFS;
+
+		switch (sysarg->sa_type) {
+		case AUDIT_ARG_GROUP_INFO: {
+				const struct group_info *info = (struct group_info *)pvalue;
+				unsigned i, n;
+
+				for (i = 0, n = info->ngroups; i < info->nblocks; ++i, n -= NGROUPS_PER_BLOCK) {
+					memcpy((gid_t *)target->at_data.ptr + i * NGROUPS_PER_BLOCK,
+						info->blocks[i],
+						min((unsigned)NGROUPS_PER_BLOCK, n) * sizeof(gid_t));
+				}
+				err = 0;
+			}
+			break;
+		case AUDIT_ARG_IPC_MSG: {
+				const struct msg_msg *msg = (struct msg_msg *)pvalue;
+				struct msgbuf *buf = (struct msgbuf *)target->at_data.ptr;
+
+				buf->mtype = msg->m_type;
+				if (msg->m_ts <= PAGE_SIZE - sizeof(*msg))
+					memcpy(buf->mtext, msg + 1, msg->m_ts);
+				else {
+					struct msgseg { struct msgseg *next; } *seg = (void *)msg->next;
+					size_t l = PAGE_SIZE - sizeof(*msg);
+	
+					memcpy(buf->mtext, msg + 1, l);
+					while (msg->m_ts - l >= PAGE_SIZE - sizeof(seg)) {
+						memcpy(buf->mtext + l, seg + 1, PAGE_SIZE - sizeof(seg));
+						l += PAGE_SIZE - sizeof(seg);
+						seg = seg->next;
+					}
+					memcpy(buf->mtext + l, seg + 1, msg->m_ts - l);
+				}
+				err = 0;
+			}
+			break;
+		default:
+			err = do_copy_from_user(target, pvalue, len);
+			break;
+		}
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+/*
+ * Special case - copy argv[] type vector from user space
+ */
+static int
+__audit_copy_vector(struct aud_syscall_data *sc, const struct sysarg *sysarg,
+			struct sysarg_data *target, uint64_t value)
+{
+	struct sysarg_data *element;
+	struct sysarg	elem_def;
+	unsigned int	word_size, count;
+	caddr_t		pvalue;
+	size_t		total_size = 0;
+
+	/* This must be set at run-time because the process
+	 * could be either 32 or 64 bit */
+	word_size = audit_syscall_word_size(sc) >> 3;
+
+	/* Interpret value as a pointer */
+	pvalue = (caddr_t) (long) value;
+
+	/* Allocate memory for vector */
+	count = AUDIT_MAX_ARGV * sizeof(element[0]);
+	element = (struct sysarg_data *) kmalloc(count, GFP_KERNEL);
+	if (!element)
+		return -ENOMEM;
+	memset(element, 0, count);
+
+	/* Set up type info for the elements */
+	memset(&elem_def, 0, sizeof(elem_def));
+	elem_def.sa_type = sysarg->sa_ref;
+	elem_def.sa_size = word_size;
+	elem_def.sa_flags = sysarg->sa_flags & AUD_ARG_USER;
+
+	for (count = 0; count < AUDIT_MAX_ARGV; count++) {
+		struct sysarg_data *elem_target = &element[count];
+		uint64_t	elem_value;
+		int		r;
+
+		/* For architectures that don't do 32/64 emulation,
+		 * one of the branches should be optimized away */
+		if (word_size == 4) {
+			uint32_t	raw32;
+
+			r = copy_from_user(&raw32, pvalue + 4 * count, 4);
+			elem_value = raw32;
+		} else  {
+			r = copy_from_user(&elem_value, pvalue + 8 * count, 8);
+		}
+
+		if (r != 0) {
+			__audit_fail_argument(elem_target, -EFAULT);
+			break;
+		}
+		if (elem_value == 0)
+			break;
+
+		__audit_copy_arg(sc, &elem_def, elem_target, elem_value);
+		if (elem_target->at_type == AUDIT_ARG_STRING) {
+			total_size += elem_target->at_data.len;
+			if (total_size >= 2048)
+				break;
+		}
+	}
+
+	target->at_type = AUDIT_ARG_VECTOR;
+	target->at_vector.elements = element;
+	target->at_vector.count = count;
+	return 0;
+}
+
+static int
+__audit_copy_arg(struct aud_syscall_data *sc, const struct sysarg *sysarg,
+			struct sysarg_data *target, uint64_t value)
+{
+	int	r;
+
+	/* See if we already have copied that argument */
+	if (target->at_type != 0)
+		return 0;
+
+	if (sysarg->sa_type == AUDIT_ARG_VECTOR)
+		r = __audit_copy_vector(sc, sysarg, target, value);
+	else
+		r = __audit_copy_from_user(sc, sysarg, target, value);
+	if (r < 0)
+		r = __audit_fail_argument(target, r);
+	return r;
+}
+
+static int
+audit_copy_arg(struct aud_syscall_data *sc, unsigned int n)
+{
+	const struct sysent	*entry;
+
+	if (!(entry = sc->entry) || n >= entry->sy_narg)
+		return -EINVAL;
+
+	return __audit_copy_arg(sc, &entry->sy_args[n],
+			&sc->args[n], sc->raw_args[n]);
+}
+
+struct sysarg_data *
+audit_get_argument(struct aud_syscall_data *sc,
+	       	   unsigned int n)
+{
+	int	err;
+
+	err = audit_copy_arg(sc, n);
+	if (err < 0)
+		return ERR_PTR(err);
+	return &sc->args[n];
+}
+
+int
+audit_copy_arguments(struct aud_syscall_data *sc)
+{
+	unsigned int	n;
+	int		err = 0;
+
+	if (!sc || !sc->entry)
+		return 0;
+
+	for (n = 0; n < sc->entry->sy_narg && err >= 0; n++)
+		err = audit_copy_arg(sc, n);
+	return err;
+}
+
+static void
+__audit_release_arg(struct sysarg_data *target)
+{
+	switch (target->at_type) {
+	case AUDIT_ARG_PATH:
+		if (target->at_path.name)
+			putname(target->at_path.name);
+		if (target->at_path.dentry)
+			dput(target->at_path.dentry);
+		break;
+	case AUDIT_ARG_STRING:
+	case AUDIT_ARG_POINTER:
+		if (target->at_data.ptr)
+			mem_free(target->at_data.ptr);
+		break;
+	case AUDIT_ARG_VECTOR:
+		if (target->at_vector.elements) {
+			struct sysarg_data *element = target->at_vector.elements;
+			unsigned int	count = target->at_vector.count;
+
+			while (count--)
+				__audit_release_arg(&element[count]);
+			kfree(element);
+		}
+		break;
+	default:
+		break;
+	}
+
+	memset(target, 0, sizeof(*target));
+}
+
+void
+audit_release_arguments(struct aud_process *pinfo)
+{
+	struct aud_syscall_data *sc = &pinfo->syscall;
+	unsigned int	n;
+
+	/* Release memory allocated to hold arguments */
+	if (sc && sc->entry) {
+		for (n = sc->entry->sy_narg; n--; )
+			__audit_release_arg(&sc->args[n]);;
+	}
+}
+
+/* Forward decl */
+static int __audit_encode_one(caddr_t, size_t,
+	       		struct sysarg_data *, const struct aud_syscall_data *);
+
+/*
+ * Encode elements of a vector
+ */
+static int
+__audit_encode_vector(caddr_t dst, size_t dst_room,
+			struct sysarg_data *target,
+			const struct aud_syscall_data *sc)
+{
+	unsigned int	len = 0, num;
+	int		r;
+
+	for (num = 0; num < target->at_vector.count; num++) {
+		r = __audit_encode_one(dst,
+				dst_room - 8 - len,
+				&target->at_vector.elements[num], sc);
+		if (r < 0)
+			return r;
+		if (dst)
+			dst += r;
+		len += r;
+	}
+
+	return len;
+}
+
+/*
+ * Encode a single argument
+ */
+static int
+__audit_encode_one(caddr_t dst, size_t dst_room, 
+			struct sysarg_data *target,
+			const struct aud_syscall_data *sc)
+{
+	uint32_t	type, len;
+	void		*src;
+	int		r;
+
+	type = target->at_type;
+	switch (type) {
+	case AUDIT_ARG_IMMEDIATE:
+	case AUDIT_ARG_ERROR:
+		src = &target->at_intval;
+		len = sizeof(target->at_intval);
+		break;
+
+	case AUDIT_ARG_PATH:
+		src = target->at_path.name;
+		len = target->at_path.len;
+		break;
+
+	case AUDIT_ARG_STRING:
+		src = target->at_data.ptr;
+		len = target->at_data.len;
+		/* Do not copy the NUL byte to user space */
+		if (len && ((char *) src)[len-1] == '\0')
+			len--;
+		break;
+
+	case AUDIT_ARG_POINTER:
+		src = target->at_data.ptr;
+		len = target->at_data.len;
+		break;
+
+	case AUDIT_ARG_VECTOR:
+		r = __audit_encode_vector(dst ? dst + 8 : NULL, dst_room - 8, target, sc);
+		if (r < 0)
+			return r;
+		src = NULL; /* elements already copied */
+		len = r;
+		break;
+
+	default:
+		src = NULL;
+		len = 0;
+	}
+
+	if (dst) {
+		if (len + 8 > dst_room)
+			return -ENOBUFS;
+
+		memcpy(dst, &type, 4); dst += 4;
+		memcpy(dst, &len,  4); dst += 4;
+		DPRINTF("    copy %p len %u\n", src, len);
+		if (src && len)
+			memcpy(dst, src, len);
+	}
+
+	return len + 8;
+}
+
+/*
+ * Encode all arguments
+ */
+int
+audit_encode_args(void *data, size_t length,
+			struct aud_syscall_data *sc)
+{
+	const struct sysent	*entry = sc->entry;
+	caddr_t	 	dst = (caddr_t) data;
+	unsigned int	n, count = 0;
+	int		len, error = 0;
+
+	for (n = 0; n < entry->sy_narg; n++) {
+		struct sysarg_data *target = &sc->args[n];
+
+		if ((error = audit_copy_arg(sc, n)) < 0) {
+			return error;
+		}
+
+		/* 8 is the room we need for the end marker */
+		len = __audit_encode_one(dst, length - 8 - count, target, sc);
+		if (len < 0)
+			return len;
+
+		if (audit_debug > 1)
+			DPRINTF("arg[%d]: type %d len %d\n",
+				       	n, target->at_type, len);
+
+		count += len;
+		if (dst)
+			dst += len;
+	}
+
+	/* Add the AUDIT_ARG_END marker */
+	if (dst)
+		memset(dst, 0, 8);
+	count += 8;
+
+	return count;
+}
+
+#ifdef DEBUG_MEMORY
+
+#define MI_MAGIC	0xfeeb1e
+
+struct mem_info {
+	int		magic;
+	list_t		entry;
+	int		syscall;
+	int		pid;
+	unsigned long	when;
+};
+
+static spinlock_t mem_lock = SPIN_LOCK_UNLOCKED;
+static LIST_HEAD(mem_list);
+static unsigned long	mem_time;
+
+static void *
+mem_alloc(size_t len, int gfp)
+{
+	struct aud_process	*pinfo = (struct aud_process *) current->audit;
+	struct mem_info		*mi;
+
+	len += sizeof(*mi);
+	if (!(mi = (struct mem_info *) kmalloc(len, gfp)))
+		return NULL;
+
+	mi->magic = MI_MAGIC;
+	mi->syscall =  pinfo? pinfo->syscall.major : 0;
+	mi->pid = current->pid;
+	mi->when = jiffies + HZ / 10;
+
+	spin_lock(&mem_lock);
+	list_add(&mi->entry, &mem_list);
+	spin_unlock(&mem_lock);
+
+	return mi + 1;
+}
+
+void
+mem_free(void *p)
+{
+	struct mem_info	*mi = ((struct mem_info *) p) - 1;
+
+	BUG_ON(mi->magic != MI_MAGIC);
+	spin_lock(&mem_lock);
+	list_del_init(&mi->entry);
+	p = mi;
+
+	if (mem_time < jiffies) {
+		list_t		*pos;
+		unsigned long	cutoff = jiffies - HZ;
+		int		count = 0;
+
+		mem_time = jiffies + 30 * HZ;
+
+		list_for_each(pos, &mem_list) {
+			mi = list_entry(pos, struct mem_info, entry);
+
+			if (mi->when > cutoff)
+				continue;
+			if (!count++)
+				printk(KERN_NOTICE "--- Memory not freed ---\n");
+			printk(KERN_NOTICE "  %p pid %5d, syscall %5d, age %ldsec\n",
+					mi + 1, mi->pid, mi->syscall,
+					(jiffies - mi->when) / HZ);
+			if (count > 32)
+				break;
+		}
+	}
+
+	spin_unlock(&mem_lock);
+	kfree(p);
+}
+#endif
diff -urNp linux-2.6.5/drivers/audit/audit-private.h linux-2.6.5.SUSE/drivers/audit/audit-private.h
--- linux-2.6.5/drivers/audit/audit-private.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/audit-private.h	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,336 @@
+/*
+ * audit-private.h
+ *
+ * Copyright (C) 2003 SuSE Linux AG
+ * Written by okir@suse.de, based on ideas from systrace, by
+ * Niels Provos (OpenBSD) and ported to Linux by Marius Aamodt Eriksen.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef AUDITPRIVATE_H
+#define AUDITPRIVATE_H
+
+#include <linux/audit.h>
+#include <linux/list.h>
+#include <linux/sys.h>
+#include <linux/init.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <stdarg.h>
+
+struct inode;
+struct poll_table_struct;
+
+/* Lock debugging will go away if all the SMP bugs are gone */
+#ifndef DONT_DEBUG_LOCKS
+# undef AUDIT_DEBUG_LOCKS
+#endif
+#include "debug-locks.h"
+
+#undef DEBUG_FILTER
+
+#define DPRINTF(fmt, args...) \
+	(unlikely(audit_debug) ? printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ##args) : (void)0)
+
+/*
+ * Audit policy for system calls and other events.
+ * You can either set an action unconditionally, or
+ * attach an additional filter
+ */
+struct aud_policy {
+	unsigned int		action;
+	struct aud_filter *	filter;
+};
+
+/*
+ * State attached to an open audit file handle
+ */
+struct aud_context {
+	unsigned int		reader;
+};
+
+struct aud_msg_head {
+	struct list_head	list;
+	struct aud_message	body;
+};
+
+/*
+ * System call table, and information on system
+ * call arguments.
+ */
+
+#define AUDIT_MAXARGS           8
+#define AUD_ARG_DIRNAME		0x0001
+#define AUD_ARG_SIGNED		0x0002
+#define AUD_ARG_INOUT		0x0004
+#define AUD_ARG_USER		0x0008
+
+struct sysarg {
+	int		sa_type;
+	size_t		sa_size;
+
+	/* For ARRAY type arguments, sa_ref is the index
+	 * of the argument containing the number of array
+	 * items (must be of type IMMEDIATE).
+	 * sa_max contains the max number of items in this array.
+	 *
+	 * For VECTOR type arguments, sa_ref is the type
+	 * of the vector elements.
+	 */
+	unsigned int	sa_ref;
+	unsigned int	sa_max;
+
+	/* Various flags */
+	unsigned int	sa_flags;
+};
+
+/* After copying arguments to kernel space, we store
+ * them in this struct.
+ * Note that pointers must be the first item in every
+ * struct within union u.
+ */
+struct sysarg_data {
+	enum audit_arg	at_type;
+	unsigned int		at_flags;
+	union {
+		uint64_t		integer;
+		struct {
+			char *		ptr;
+			size_t		len;
+		} data;
+		struct {
+			char *		name;
+			size_t		len;
+			struct dentry *	dentry;
+			unsigned char	exists : 1;
+		} path;
+		struct {
+			struct sysarg_data *elements;
+			size_t		count;
+		} vector;
+	} u;
+};
+#define at_intval	u.integer
+#define at_strval	u.data.ptr
+#define at_data		u.data
+#define at_path		u.path
+#define at_vector	u.vector
+
+
+struct sysent {
+	unsigned int	sy_narg;
+	struct sysarg	sy_args[AUDIT_MAXARGS];
+};
+
+/*
+ * This struct contains all information on a system
+ * call.
+ */
+struct aud_syscall_data {
+	int			personality;
+	int			arch;
+	int			major, minor;
+	long			result;
+	int			flags;
+	const struct sysent * entry;
+	uint64_t		raw_args[AUDIT_MAXARGS];
+	struct sysarg_data	args[AUDIT_MAXARGS];
+};
+
+struct aud_event_data {
+	char			name[AUD_MAX_EVNAME];
+	struct aud_syscall_data	*syscall;
+	struct sk_buff *	netconf;
+	int			exit_status;
+};
+
+struct aud_process {
+	struct list_head	list;
+
+	uid_t			audit_uid;
+	unsigned int		audit_id;
+
+	unsigned long		flags;
+	/* Auditing suspended? */
+	unsigned char		suspended;
+
+	/* Data on system call currently in progress */
+	struct aud_syscall_data	syscall;
+};
+
+#define AUD_F_ATTACHED		0x0001
+
+extern int		audit_debug;
+extern int		audit_all_processes;
+extern unsigned int	audit_max_messages;
+extern int		audit_allow_suspend;
+extern int		audit_message_enabled;
+extern int		audit_paranoia;
+
+/* VFS interface */
+int			auditf_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+ssize_t			auditf_read(struct file *, char *, size_t, loff_t *);
+ssize_t			auditf_write(struct file *, const char *, size_t, loff_t *);
+int			auditf_open(struct inode *, struct file *);
+int			auditf_release(struct inode *, struct file *);
+unsigned int		auditf_poll(struct file *, struct poll_table_struct *);
+
+/* Policy handling */
+int			audit_policy_clear(void);
+int			audit_policy_set(const struct audit_policy __user *);
+int			audit_policy_check(int, struct aud_event_data *);
+int			audit_policy_ignore(int);
+
+/* Message utility functions */
+int			audit_msg_enable(void);
+void			audit_msg_disable(void);
+struct aud_msg_head * audit_msg_new(struct aud_process *, int, const char *, size_t);
+struct aud_msg_head * audit_msg_get(int, size_t);
+int			audit_msg_poll(struct file *,
+					struct poll_table_struct *);
+void			audit_msg_release(struct aud_msg_head *);
+void			audit_msg_insert(struct aud_msg_head *);
+int			audit_msg_fork(struct aud_process *, pid_t);
+int			audit_msg_exit(struct aud_process *, const char *,
+	       				long);
+int			audit_msg_syscall(struct aud_process *, const char *,
+					struct aud_syscall_data *);
+int			audit_msg_result(struct aud_process *, const char *,
+	       				int);
+int			audit_msg_login(struct aud_process *, const char *,
+	       				const struct audit_login *);
+int			audit_msg_netlink(struct aud_process *, const char *,
+					const struct sk_buff *, int);
+
+int			audit_attach(int);
+int			audit_detach(void);
+int			audit_suspend(void);
+int			audit_resume(void);
+int			audit_setauditid(void);
+int			audit_login(const struct audit_login __user *);
+int			audit_user_message(const struct audit_message __user *);
+
+void			audit_init_syscalls(void);
+int			audit_fshook_adjust(enum audit_call, signed adjust);
+int			audit_get_args(enum audit_call, va_list,
+				struct aud_syscall_data *);
+struct sysarg_data * audit_get_argument(struct aud_syscall_data *,
+				unsigned int);
+int			audit_copy_arguments(struct aud_syscall_data *);
+void			audit_release_arguments(struct aud_process *);
+int			audit_encode_args(void *, size_t,
+				struct aud_syscall_data *);
+
+int			audit_filter_add(const struct audit_filter __user *);
+int			audit_filter_eval(const struct aud_filter *,
+				struct aud_event_data *);
+struct aud_filter * audit_filter_get(unsigned int);
+void			audit_filter_put(struct aud_filter *);
+int			audit_filter_clear(void);
+
+struct aud_file_object * audit_fileset_add(const char *);
+void			audit_fileset_release(struct aud_file_object *);
+int			audit_fileset_match(struct aud_file_object *,
+				struct sysarg_data *);
+void			audit_fileset_unlock(int invalidate);
+
+extern int		audit_sysctl_register(void);
+extern void		audit_sysctl_unregister(void);
+
+#ifdef CONFIG_COMPAT
+extern int		audit_register_ioctl_converters(void);
+extern int		audit_unregister_ioctl_converters(void);
+#else
+#define audit_register_ioctl_converters() 0
+#define audit_unregister_ioctl_converters() 0
+#endif
+
+struct nameidata;
+int			audit_path_init(const char *, unsigned int, struct nameidata *);
+
+int audit_check(const char*filename, int line);
+#define audit_check() audit_check(__FILE__, __LINE__)
+
+/*
+ * Function hooks
+ */
+#ifdef CONFIG_AUDIT_MODULE
+struct audit_hooks {
+	int		(*intercept)(enum audit_call, va_list);
+	long		(*result)(long);
+	void		(*fork)(struct task_struct *, struct task_struct *);
+	void		(*exit)(struct task_struct *, long);
+	void		(*netlink_msg)(struct sk_buff *, int);
+};
+
+extern int		audit_register(const struct audit_hooks *);
+extern void		audit_unregister(void);
+#endif
+
+/*
+ * Kill a process.
+ * This is called when for some reason we were unable to audit a
+ * system call (e.g. because the address was bad).
+ *
+ * This is roughly the equivalent of sig_exit
+ */
+static __inline__ void
+audit_kill_process(int error)
+{
+	printk(KERN_NOTICE "audit_intercept: error %d, killing task %d\n", -error, current->pid);
+	sigaddset(&current->pending.signal, SIGKILL);
+	recalc_sigpending();
+	current->flags |= PF_SIGNALED;
+	complete_and_exit(NULL, SIGKILL);
+}
+
+#if defined(CONFIG_X86)
+#define AUDIT_ARCH AUDIT_ARCH_I386
+#elif defined(CONFIG_X86)
+#define AUDIT_ARCH AUDIT_ARCH_PPC
+#elif defined(CONFIG_PPC)
+#define AUDIT_ARCH AUDIT_ARCH_PPC64
+#define AUDIT_ARCH32 AUDIT_ARCH_PPC
+#elif defined(CONFIG_X86_64)
+#define AUDIT_ARCH AUDIT_ARCH_X86_64
+#define AUDIT_ARCH32 AUDIT_ARCH_I386
+#elif defined(CONFIG_S390)
+#define AUDIT_ARCH AUDIT_ARCH_S390
+#elif defined(CONFIG_S390X)
+#define AUDIT_ARCH AUDIT_ARCH_S390X
+#define AUDIT_ARCH32 AUDIT_ARCH_S390
+#elif defined(CONFIG_IA64)
+#define AUDIT_ARCH AUDIT_ARCH_IA64
+#define AUDIT_ARCH32 AUDIT_ARCH_I386
+#endif
+#ifndef AUDIT_ARCH32
+#define AUDIT_ARCH32 AUDIT_ARCH
+#endif
+
+/*
+ * See if the process doing this call is 32bit or 64bit
+ */
+static __inline__ unsigned int
+audit_syscall_word_size(struct aud_syscall_data *sc)
+{
+#if BITS_PER_LONG == 64
+	return sc->arch == AUDIT_ARCH ? 64 : 32;
+#else
+	return 32;
+#endif
+}
+
+#endif /* AUDITPRIVATE_H */
diff -urNp linux-2.6.5/drivers/audit/control.c linux-2.6.5.SUSE/drivers/audit/control.c
--- linux-2.6.5/drivers/audit/control.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/control.c	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,1137 @@
+/*
+ * control.c
+ *
+ * Linux Audit Subsystem
+ *
+ * Copyright (C) 2003 SuSE Linux AG
+ *
+ * Written by okir@suse.de, based on ideas from systrace, by
+ * Niels Provos (OpenBSD) and ported to Linux by Marius Aamodt Eriksen.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include "audit-private.h"
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/sys.h>
+#include <linux/miscdevice.h>
+#include <linux/personality.h>
+#include <linux/poll.h>
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+
+#define AUDIT_VERSION		"0.2"
+#define AUDIT_MINOR		224
+
+static unsigned int		audit_id;
+static struct aud_policy	audit_policy[__AUD_MAX_POLICY];
+
+static DECLARE_RWSEM(audit_lock);
+
+/* These are accessible through sysctl */
+int				audit_debug = 0;
+int				audit_all_processes = 0;
+int				audit_allow_suspend = 1;
+int				audit_paranoia = 0;
+
+static int	__audit_attach(struct task_struct *, int, struct aud_process *);
+static void	audit_attach_all(void);
+static void	audit_detach_all(void);
+
+static struct file_operations audit_fops = {
+	.owner =   THIS_MODULE,
+	.read =    &auditf_read,
+	.write =   &auditf_write,
+	.ioctl =   &auditf_ioctl,
+	.release = &auditf_release,
+	.open =    &auditf_open,
+	.poll =    &auditf_poll
+};
+
+static struct miscdevice audit_dev = {
+	AUDIT_MINOR,
+	"audit",
+	&audit_fops
+};
+
+
+#ifdef MODULE
+static int	__audit_vintercept(enum audit_call, va_list);
+static void	__audit_fork(struct task_struct *, struct task_struct *);
+static void	__audit_exit(struct task_struct *, long code);
+static void	__audit_netlink_msg(struct sk_buff *, int);
+
+#define audit_exit	__audit_exit
+#define audit_fork	__audit_fork
+#define audit_netlink_msg __audit_netlink_msg
+
+static const struct audit_hooks audit_hooks = {
+	__audit_vintercept,
+	audit_lresult,
+	__audit_fork,
+	__audit_exit,
+	__audit_netlink_msg,
+};
+#endif
+
+
+static int __init
+init_audit(void)
+{
+	audit_init_syscalls();
+
+	if (misc_register(&audit_dev) < 0) {
+		printk(KERN_INFO "audit: unable to register device\n");
+		return -EIO;
+	}
+
+	if (audit_sysctl_register() < 0)
+		goto fail_unregister;
+
+	if (audit_register_ioctl_converters() < 0)
+		goto fail_unregister;
+
+#ifdef MODULE
+	if (audit_register(&audit_hooks) < 0)
+		goto fail_unregister;
+#endif
+
+	printk(KERN_INFO "audit subsystem ver %s initialized\n",
+		AUDIT_VERSION);
+
+	return 0;
+
+fail_unregister:
+	(void)audit_unregister_ioctl_converters();
+	audit_sysctl_unregister();
+	misc_deregister(&audit_dev);
+	return -EIO;
+}
+
+module_init(init_audit);
+
+#ifdef MODULE
+
+static void __exit 
+exit_audit(void)
+{
+	/* Detach all audited processes */
+	audit_detach_all();
+
+	audit_unregister();
+
+	(void)audit_unregister_ioctl_converters();
+	audit_sysctl_unregister();
+	misc_deregister(&audit_dev);
+
+	audit_policy_clear();
+	audit_filter_clear();
+}
+
+module_exit(exit_audit);
+
+#endif
+
+int
+auditf_open(struct inode *inode, struct file *file)
+{
+	struct aud_context *ctx;
+	int error = 0;
+
+	DPRINTF("opened by pid %d\n", current->pid);
+	if ((ctx = kmalloc(sizeof(*ctx), GFP_KERNEL)) == NULL) {
+		printk(KERN_ERR "audit: Failed to allocate kernel memory.\n");
+		return -ENOBUFS;
+	}
+
+	memset(ctx, 0, sizeof(*ctx));
+	file->private_data = ctx;
+
+	return (error);
+}
+
+int
+auditf_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	struct aud_context *ctx = (struct aud_context *) file->private_data;
+	int error = 0;
+
+	if (cmd == AUIOCVERSION)
+		return AUDIT_API_VERSION;
+
+	DPRINTF("ctx=%p, cmd=0x%x\n", ctx, cmd);
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	switch (cmd) {
+	case AUIOCIAMAUDITD:
+		down_write(&audit_lock);
+		error = audit_msg_enable();
+		if (error >= 0) {
+			printk(KERN_NOTICE
+				"Audit daemon registered (process %d)\n",
+				current->pid);
+			/* Suspend auditing for this process */
+			if (current->audit)
+				((struct aud_process *) current->audit)->suspended++;
+			ctx->reader = 1;
+		}
+		if (audit_all_processes)
+			audit_attach_all();
+		up_write(&audit_lock);
+		break;
+	case AUIOCATTACH:
+		down_write(&audit_lock);
+		/* Attach process. If we're the audit daemon,
+		 * suspend auditing for us. */
+		error = audit_attach(ctx->reader);
+		up_write(&audit_lock);
+		break;
+	case AUIOCDETACH:
+		down_write(&audit_lock);
+		error = audit_detach();
+		up_write(&audit_lock);
+		break;
+	case AUIOCSUSPEND:
+		down_write(&audit_lock);
+		error = audit_suspend();
+		up_write(&audit_lock);
+		break;
+	case AUIOCRESUME:
+		down_write(&audit_lock);
+		error = audit_resume();
+		up_write(&audit_lock);
+		break;
+	case AUIOCCLRPOLICY:
+		down_write(&audit_lock);
+		error = audit_policy_clear();
+		up_write(&audit_lock);
+		break;
+	case AUIOCCLRFILTER:
+		down_write(&audit_lock);
+		error = audit_filter_clear();
+		up_write(&audit_lock);
+		break;
+	case AUIOCSETFILTER:
+		down_write(&audit_lock);
+		error = audit_filter_add((const void __user *) arg);
+		up_write(&audit_lock);
+		break;
+	case AUIOCSETPOLICY:
+		down_write(&audit_lock);
+		error = audit_policy_set((const void __user *) arg);
+		up_write(&audit_lock);
+		break;
+	case AUIOCSETAUDITID:
+		down_write(&audit_lock);
+		error = audit_setauditid();
+		up_write(&audit_lock);
+		break;
+	case AUIOCLOGIN:
+		down_read(&audit_lock);
+		error = audit_login((const void __user *) arg);
+		up_read(&audit_lock);
+		break;
+	case AUIOCUSERMESSAGE:
+		down_read(&audit_lock);
+		error = audit_user_message((const void __user *) arg);
+		up_read(&audit_lock);
+		break;
+	case AUIOCRESET:
+		down_write(&audit_lock);
+		audit_detach_all();
+		error = audit_policy_clear();
+		if (error >= 0)
+			error = audit_filter_clear();
+		up_write(&audit_lock);
+		break;
+
+	default:
+		error = -EINVAL;
+		break;
+	}
+
+	DPRINTF("done, result=%d\n", error);
+	return (error);
+}
+
+unsigned int
+auditf_poll(struct file *file, struct poll_table_struct *wait)
+{
+	if (audit_msg_poll(file, wait))
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+/*
+ * Compute statistics
+ */
+ssize_t
+auditf_read(struct file *filp, char *buf, size_t count, loff_t *off)
+{
+	struct aud_context *ctx = (struct aud_context *) filp->private_data;
+	size_t max_len, copied;
+	int block, nmsgs;
+
+	DPRINTF("called.\n");
+	if (!ctx->reader)
+		return -EPERM;
+
+	/* Get messages from the message queue.
+	 * The first time around, extract the first message, no
+	 * matter its size.
+	 * For subsequent messages, make sure it fits into the buffer.
+	 */
+	block = !(filp->f_flags & O_NONBLOCK);
+	max_len = copied = 0;
+	nmsgs = 0;
+
+	while (copied < count) {
+		struct aud_msg_head * msgh = audit_msg_get(block, max_len);
+
+		if (IS_ERR(msgh)) {
+			if (copied)
+				break;
+			return PTR_ERR(msgh);
+		}
+
+		if (msgh->body.msg_size > count - copied) {
+			printk(KERN_NOTICE "auditf_read: truncated audit message (%zu > %zu; max_len=%zu)\n",
+				msgh->body.msg_size, count - copied, max_len);
+			msgh->body.msg_size = count - copied;
+		}
+
+		if (audit_debug > 1) {
+			DPRINTF("copying msg %u type %d size %zu\n",
+				msgh->body.msg_seqnr, msgh->body.msg_type, msgh->body.msg_size);
+		}
+		if (copy_to_user(buf + copied, &msgh->body, msgh->body.msg_size)) {
+			printk(KERN_ERR "Dropped audit message when copying to audit daemon\n");
+			audit_msg_release(msgh);
+			return -EFAULT;
+		}
+		copied += msgh->body.msg_size;
+		audit_msg_release(msgh);
+
+		block = 0;
+		max_len = count - copied;
+		nmsgs++;
+	}
+
+	DPRINTF("copied %d messages, %zu bytes total\n", nmsgs, copied);
+	return copied;
+}
+
+ssize_t
+auditf_write(struct file *filp, const char *buf, size_t count, loff_t *off)
+{
+	return (-ENOTSUPP);
+}
+
+int
+auditf_release(struct inode *inode, struct file *filp)
+{
+	struct aud_context *ctx = filp->private_data;
+
+	DPRINTF("called.\n");
+
+	if (ctx->reader) {
+		struct aud_msg_head	*msgh;
+
+		DPRINTF("Audit daemon closed audit file; auditing disabled\n");
+		audit_msg_disable();
+
+		/* Drop all messages already queued */
+		while (1) {
+			msgh = audit_msg_get(0, 0);
+			if (IS_ERR(msgh))
+				break;
+			audit_msg_release(msgh);
+		}
+
+		/* When we announced being auditd, our
+		 * suspend count was bumped */
+		audit_resume();
+	}
+
+	filp->private_data = NULL;
+	kfree(ctx);
+
+	return (0);
+}
+
+/*
+ * Process intercepted system call and result
+ */
+static void
+__audit_syscall_return(struct aud_process *pinfo, long result)
+{
+	struct aud_event_data	ev;
+	struct aud_syscall_data *sc = &pinfo->syscall;
+	int			action, error;
+
+	/* System call ignored, or not supported */
+	if (sc->entry == NULL)
+		return;
+
+	sc->result = result;
+
+	memset(&ev, 0, sizeof(ev));
+	ev.syscall = sc;
+	action = audit_policy_check(sc->major, &ev);
+
+	if ((action & AUDIT_LOG) && audit_message_enabled) {
+		sc->flags = action;
+		error = audit_msg_syscall(pinfo, ev.name, sc);
+		/* ENODEV means the audit daemon has gone away.
+		 * continue as if we weren't auditing */
+		if (error < 0 && error != -ENODEV) {
+			printk("audit: error %d when processing syscall %d\n",
+					error, sc->major);
+		}
+	}
+
+	/* If we copied any system call arguments to user
+	 * space, release them now.
+	 */
+	audit_release_arguments(pinfo);
+
+	/* For now, we always invalidate the fileset's cached
+	 * dentry pointers.
+	 * We could optimize this (e.g. open(2) without O_CREAT
+	 * does not change the file system)
+	 */
+	audit_fileset_unlock(1);
+
+	memset(sc, 0, sizeof(*sc));
+}
+
+
+/*
+ * This function is executed in the context of the parent
+ * process, with the child process still sleeping
+ */
+void
+audit_fork(struct task_struct *parent, struct task_struct *child)
+{
+	struct aud_process *parent_info;
+
+	DPRINTF("called.\n");
+
+	task_lock(parent);
+	if ((parent_info = parent->audit) != NULL) {
+		if (__audit_attach(child, 0, parent_info) == 0) {
+			struct aud_process *pinfo = child->audit;
+
+			pinfo->audit_id = parent_info->audit_id;
+			pinfo->audit_uid = parent_info->audit_uid;
+		}
+		else
+			printk(KERN_ERR "audit: failed to enable auditing for child process!\n");
+	}
+	task_unlock(parent);
+}
+
+void
+audit_exit(struct task_struct *p, long code)
+{
+	struct aud_process *pinfo;
+	int		action;
+
+	/* Notify auditd that we're gone */
+	if ((pinfo = p->audit) != NULL) {
+		DPRINTF("process exiting, code=%ld\n", code);
+		if (!pinfo->suspended) {
+			struct aud_event_data	ev;
+
+			__audit_syscall_return(pinfo, 0);
+
+			memset(&ev, 0, sizeof(ev));
+			ev.exit_status = code;
+			action = audit_policy_check(AUD_POLICY_EXIT, &ev);
+			if (action & AUDIT_LOG)
+				audit_msg_exit(pinfo, ev.name, code);
+		}
+		audit_detach();
+	}
+}
+
+/*
+ * Intercept system call
+ */
+void
+audit_intercept(enum audit_call code, ...)
+{
+	va_list varg;
+#ifdef MODULE
+	int error;
+
+	va_start(varg, code);
+	error = __audit_vintercept(code, varg);
+	if (unlikely(error < 0))
+		audit_kill_process(error);
+}
+
+int
+__audit_vintercept(enum audit_call code, va_list varg)
+{
+#define return(retval) return retval
+#else
+#define return(retval) return
+#endif
+	struct aud_syscall_data *sc;
+	struct aud_process *pinfo;
+	int error;
+
+	/* process attached? */
+	if ((pinfo = current->audit) == NULL)
+		return(0);
+
+	/* Check if we have system call data we haven't processed
+	 * yet, in case there was no call to audit_result.
+	 * This happens e.g. for execve(). */
+	//todo This breaks for recursive system call invocations.
+	__audit_syscall_return(pinfo, 0);
+
+	if (!(pinfo->flags & AUD_F_ATTACHED) || pinfo->suspended || !audit_message_enabled)
+		return(0);
+
+	/* Don't dig any deeper if we're not interested in this call */
+	if (audit_policy_ignore(code & ~AUDIT_32))
+		return(0);
+
+	sc = &pinfo->syscall;
+	sc->arch = !(code & AUDIT_32) ? AUDIT_ARCH : AUDIT_ARCH32;
+	code &= ~AUDIT_32;
+	sc->personality = personality(current->personality);
+#ifndef MODULE
+	va_start(varg, code);
+#endif
+	error = audit_get_args(code, varg, sc);
+	va_end(varg);
+
+#if 0//todo remove or replace by copy-now-and-verify-unchanged-after-call logic
+	/* This doesn't work anymore when not sitting directly in the
+	   system call path, because there is no way to replace the
+	   arguments passed to the system call. */
+	/* Raw, unoptimized -
+	 *
+	 * We need to protect against two-man con games here,
+	 * where one thread enters audit_intercept with say
+	 * a pathname of "/ftc/bar", which we don't audit, and
+	 * a second thread modifies that to "/etc/bar" before
+	 * we actually call the real syscall.
+	 *
+	 * This is where the "auditing by system call intercept"
+	 * concept breaks down quite badly; but that is the price
+	 * you pay for an unintrusive patch.
+	 */
+	if (error >= 0 && audit_paranoia) {
+		switch (code) {
+		/* While we list the dangerous calls here, most of them do not
+		   actually have arguments that still live in user land when the
+		   call reaches us. */
+		case AUDIT_shmat:
+		case AUDIT_shmdt:
+		case AUDIT_mmap:
+		case AUDIT_munmap:
+		case AUDIT_mremap:
+		case AUDIT_mprotect:
+		case AUDIT_io_setup:
+		case AUDIT_madvise:
+		case AUDIT_mlock:
+		case AUDIT_mlockall:
+		case AUDIT_munlock:
+		case AUDIT_execve:
+			/* These calls mess with the process VM.
+			 * Make sure no other thread sharing this VM is
+			 * doing any audited call at this time. */
+			error = audit_lock_arguments(sc, AUD_F_VM_LOCKED_W);
+ 			break;
+		default:
+			error = audit_lock_arguments(sc, AUD_F_VM_LOCKED_R);
+			break;
+		}
+	}
+#endif
+	if (error >= 0) {
+		/* For some system calls, we need to copy one or more arguments
+		 * before the call itself:
+		 * execve	Never returns, and by the time we get around to
+		 *		assembling the audit message, the process image
+		 *		is gone.
+		 * unlink	Resolve pathnames before file is gone
+		 * rename	First pathname needs to be resolved before
+		 *		the call; afterwards it's gone already.
+		 * chroot	Pathname must be interpreted relative to
+		 *		original fs->root.
+		 * adjtimex	argument is in/out.
+		 */
+		switch (code) {
+			void *p;
+
+		case AUDIT_adjtimex:
+		case AUDIT_execve:
+		case AUDIT_unlink:
+		case AUDIT_chroot:
+			error = audit_copy_arguments(sc);
+			break;
+		case AUDIT_rename:
+			p = audit_get_argument(sc, 0);
+			if (IS_ERR(p)) error = PTR_ERR(p);
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (unlikely(error < 0)) {
+		/* An error occurred while copying arguments from user
+		 * space. This could either be a simple address fault
+		 * (which is alright in some cases, and should just elicit
+		 * an error), or it's an internal problem of the audit
+		 * subsystem.
+		 */
+		/* For now, we choose to kill the task. If audit is a module,
+		 * we return and let the stub handler do this (because we
+		 * need to release the stub lock first)
+		 */
+#ifndef MODULE
+		audit_kill_process(error);
+		/* NOTREACHED */
+#endif
+	}
+	return(error);
+#undef return
+}
+
+/*
+ * Intercept system call result
+ */
+long
+audit_lresult(long result)
+{
+	struct aud_process *pinfo;
+
+	if (!audit_message_enabled)
+		return result;
+
+	if ((pinfo = current->audit) == NULL)
+		return result;
+
+	/* report return value to audit daemon */
+	__audit_syscall_return(pinfo, result);
+
+	return result;
+}
+
+/*
+ * Netlink message - probably network configuration change
+ */
+void
+audit_netlink_msg(struct sk_buff *skb, int res)
+{
+	struct nlmsghdr		*nlh;
+	struct aud_event_data	ev;
+	struct aud_process	*pinfo;
+	int			action;
+
+	DPRINTF("called.\n");
+
+	if (!audit_message_enabled)
+		return;
+
+	/* Ignore netlink replies for now */
+	nlh = (struct nlmsghdr *) skb->data;
+	if (!(nlh->nlmsg_flags & NLM_F_REQUEST))
+		return;
+
+	if (!(pinfo = current->audit) || pinfo->suspended)
+		return;
+
+	memset(&ev, 0, sizeof(ev));
+	ev.netconf = skb;
+
+	action = audit_policy_check(AUD_POLICY_NETLINK, &ev);
+
+	if (action & AUDIT_LOG)
+		audit_msg_netlink(pinfo, ev.name, skb, res);
+}
+
+/*
+ * Clear the audit policy table.
+ * We hold the audit_lock when we get here.
+ */
+int
+audit_policy_clear(void)
+{
+	struct aud_policy *policy = audit_policy;
+	unsigned i;
+
+	for (i = 0; i < __AUD_MAX_POLICY; i++, policy++) {
+		audit_filter_put(policy->filter);
+		policy->action = AUDIT_IGNORE;
+		policy->filter = NULL;
+		if (i < audit_NUM_CALLS)
+			audit_fshook_adjust(i, -1);
+	}
+	return 0;
+}
+
+/*
+ * Set an audit policy
+ * We hold the audit_lock when we get here.
+ */
+int
+audit_policy_set(const struct audit_policy __user *arg)
+{
+	struct aud_policy *policy;
+	struct audit_policy	pol;
+	struct aud_filter *f = NULL;
+
+	if (!arg)
+		return -EINVAL;
+	if (copy_from_user(&pol, arg, sizeof(pol)))
+		return -EFAULT;
+	DPRINTF("code %u, action %u, filter %u\n", pol.code, pol.action, pol.filter);
+	if (pol.code >= __AUD_MAX_POLICY)
+		return -EINVAL;
+
+	if (pol.filter > 0 && !(f = audit_filter_get(pol.filter)))
+		return -EINVAL;
+
+	policy = audit_policy + pol.code;
+	audit_filter_put(policy->filter);
+	if (pol.code < audit_NUM_CALLS) {
+		audit_fshook_adjust(pol.code,
+			(pol.action != AUDIT_IGNORE || f) - (policy->action != AUDIT_IGNORE || policy->filter));
+	}
+	policy->action = pol.action;
+	policy->filter = f;
+	return 0;
+}
+
+/*
+ * Check whether we ignore this system call.
+ * Called to find out whether we should bother with
+ * decoding arguments etc.
+ */
+int
+audit_policy_ignore(int code)
+{
+	int result = 1;
+
+	if (0 <= code && code < __AUD_MAX_POLICY) {
+		const struct aud_policy *policy = audit_policy + code;
+
+		down_read(&audit_lock);
+		if (policy->filter
+		 || policy->action != AUDIT_IGNORE)
+			result = 0;
+
+		up_read(&audit_lock);
+	}
+
+	return result;
+}
+
+/*
+ * Check policy
+ */
+static int
+__audit_policy_check(int code, struct aud_event_data *ev)
+{
+	int result = AUDIT_IGNORE;
+
+	if (0 <= code && code < __AUD_MAX_POLICY) {
+		const struct aud_policy *policy = audit_policy + code;
+		if (policy->filter)
+			result = audit_filter_eval(policy->filter, ev);
+		else
+			result = policy->action;
+	}
+
+	return result;
+}
+
+int
+audit_policy_check(int code, struct aud_event_data *ev)
+{
+	int result;
+
+	down_read(&audit_lock);
+	result = __audit_policy_check(code, ev);
+	up_read(&audit_lock);
+
+	return result;
+}
+
+/*
+ * Attach/detach audit context to process
+ */
+static int
+__audit_attach(struct task_struct *task, int suspended, struct aud_process *parent)
+{
+	struct aud_process *pinfo, *pnew;
+	int		res = 0;
+
+	pnew = audit_alloc();
+	task_lock(task);
+	if (!(pinfo = task->audit)) {
+		task->audit = pinfo = pnew;
+		pnew = NULL;
+	}
+	if (unlikely(!pinfo)) {
+		DPRINTF("No memory to attach process %d\n", task->pid);
+		res = -ENOMEM;
+	}
+	else if (unlikely(pinfo->flags & AUD_F_ATTACHED)) {
+		DPRINTF("Cannot attach process %d; auditing already enabled\n", task->pid);
+		res = -EBUSY;
+	}
+	else {
+		DPRINTF("Attaching process %d\n", task->pid);
+		pinfo->flags |= AUD_F_ATTACHED;
+		pinfo->suspended = suspended;
+	}
+	task_unlock(task);
+	audit_free(pnew);
+	return res;
+}
+
+int
+audit_attach(int suspended)
+{
+	/* Don't allow attach if auditd is not there
+	 *
+	 * XXX: For more robustness, shouldn't we allow the attach to
+	 * succeed even if the daemon isn't running? This may happen
+	 * if it was restarted due to a crash.
+	 */
+	if (!audit_message_enabled)
+		return -ENODEV;
+
+	return __audit_attach(current, suspended, NULL);
+}
+
+static int
+__audit_detach(task_t *task, int permanent)
+{
+	struct aud_process *pinfo;
+	int		res = 0;
+
+	task_lock(task);
+	if (!(pinfo = task->audit)) {
+		task_unlock(task);
+		res = -EUNATCH;
+	} else {
+		/* turn off system call intercept */
+		if (permanent)
+			task->audit = NULL;
+		else {
+			pinfo->flags &= ~AUD_F_ATTACHED;
+			pinfo->audit_uid = (uid_t) -1;
+			pinfo->suspended = 1;
+		}
+		task_unlock(task);
+
+		/* Free any memory we may have allocated for
+	   	 * argument data */
+		audit_release_arguments(pinfo);
+		if (permanent)
+			kfree(pinfo);
+	}
+	return res;
+}
+
+int
+audit_detach(void)
+{
+	DPRINTF("detaching process %d\n", current->pid);
+	return __audit_detach(current, 1);
+}
+
+/*
+ * Attach/detach all processes
+ */
+void
+audit_attach_all(void)
+{
+	task_t	*p;
+
+	read_lock(&tasklist_lock);
+	for_each_process(p) {
+		if (p != current
+		    && p->mm != NULL /*todo this is insufficient to identify kernel threads */
+		    && p->pid != 1)
+			__audit_attach(p, 0, NULL);
+	}
+	read_unlock(&tasklist_lock);
+}
+
+void
+audit_detach_all(void)
+{
+	task_t	*p;
+
+	read_lock(&tasklist_lock);
+	for_each_process(p) {
+		__audit_detach(p, 0);
+	}
+	read_unlock(&tasklist_lock);
+}
+
+/*
+ * Suspend system call auditing for this process
+ */
+int
+audit_suspend(void)
+{
+	struct aud_process *pinfo;
+
+	DPRINTF("process %d suspends auditing\n", current->pid);
+	if ((pinfo = current->audit) == NULL)
+		return -EUNATCH;
+	if (!audit_allow_suspend)
+		return -EACCES;
+	pinfo->suspended++;
+	return 0;
+}
+
+/*
+ * Resume auditing
+ */
+int
+audit_resume(void)
+{
+	struct aud_process *pinfo;
+
+	DPRINTF("process %d resumes auditing\n", current->pid);
+	if ((pinfo = current->audit) == NULL)
+		return -EUNATCH;
+	pinfo->suspended--;
+	return 0;
+}
+
+/*
+ * Assign an audit ID
+ */
+int
+audit_setauditid(void)
+{
+	struct aud_process 	*pinfo;
+
+	if (!(pinfo = current->audit))
+		return -EUNATCH;
+
+	if (pinfo->audit_id)
+		return -EACCES;
+
+	do {
+		pinfo->audit_id = ++audit_id;
+	} while (!pinfo->audit_id);
+
+	DPRINTF("process %d assigned audit id %u\n",
+		       	current->pid, pinfo->audit_id);
+	return 0;
+}
+
+/*
+ * Process login message from user land
+ */
+int
+audit_login(const struct audit_login __user *arg)
+{
+	struct aud_process	*pinfo;
+	struct audit_login	*login;
+	struct aud_event_data	ev;
+	int			action, err;
+
+	if (!(pinfo = current->audit))
+		return -EUNATCH;
+
+	/* Make sure LOGIN works just once */
+	if (pinfo->audit_uid != (uid_t) -1)
+		return -EACCES;
+
+	if (!(login = kmalloc(sizeof(*login), GFP_KERNEL)))
+		return -ENOBUFS;
+
+	err = -EFAULT;
+	if (copy_from_user(login, arg, sizeof(*login)))
+		goto out;
+
+	err = -EINVAL;
+	if (login->uid == (uid_t) -1)
+		goto out;
+
+	/* Copy the login uid and keep it */
+	pinfo->audit_uid = login->uid;
+
+	/* Notify audit daemon */
+	memset(&ev, 0, sizeof(ev));
+	strcpy(ev.name, "AUDIT_login");
+
+	action = __audit_policy_check(AUD_POLICY_LOGIN, &ev);
+	if (action & AUDIT_LOG)
+		err = audit_msg_login(pinfo, ev.name, login);
+	else
+		err = 0;
+
+out:
+	kfree(login);
+	return err;
+}
+
+/*
+ * Pass an audit message generated by user space, and fill in
+ * the blanks
+ */
+int
+audit_user_message(const struct audit_message __user *arg)
+{
+	struct aud_process	*pinfo;
+	struct aud_msg_head	*msgh;
+	struct audit_message	user_msg;
+	struct aud_event_data	ev;
+	int			action;
+
+	/* Beware, may be NULL. We still want to allow
+	 * un-audited processes to log audit messages. */
+	pinfo = current->audit;
+
+	if (copy_from_user(&user_msg, arg, sizeof(user_msg)))
+		return -EFAULT;
+
+	if (user_msg.msg_type < AUDIT_MSG_USERBASE)
+		return -EACCES;
+
+	memset(&ev, 0, sizeof(ev));
+	strncpy(ev.name, user_msg.msg_evname, sizeof(ev.name)-1);
+
+	action = __audit_policy_check(AUD_POLICY_USERMSG, &ev);
+	if (!(action & AUDIT_LOG))
+		return 0;
+
+	msgh = audit_msg_new(pinfo, user_msg.msg_type,
+				user_msg.msg_evname,
+				user_msg.msg_size);
+	if (IS_ERR(msgh))
+		return PTR_ERR(msgh);
+
+	if (copy_from_user(msgh->body.msg_data, user_msg.msg_data, user_msg.msg_size)) {
+		audit_msg_release(msgh);
+		return -EFAULT;
+	}
+
+	audit_msg_insert(msgh);
+	return 0;
+}
+
+/*
+ * Debugging stuff
+ */
+#ifdef AUDIT_DEBUG_LOCKS
+void
+_debug_locks(char *ltype, char *var, int lock)
+{
+	#define NLOCKS 6
+	static spinlock_t _debug_lock = SPIN_LOCK_UNLOCKED;
+	static int max_cpu = 0;
+	static char locks[NR_CPUS][NLOCKS];
+	static char out[NR_CPUS * NLOCKS + NR_CPUS];
+	int locknum, cpu, p;
+
+	do_spin_lock(&_debug_lock);
+
+	cpu = current->cpu;
+	if (cpu > max_cpu) max_cpu = cpu;
+
+	/* get lock state before update */
+	for (p=0; p <= max_cpu; ++p) {
+		int l;
+		for (l=0; l<NLOCKS; ++l) {
+			int c;
+
+			c = locks[p][l];
+			if (!c) c='.';
+
+			out[p * (NLOCKS+1) + l] = c;
+		}
+		out[p*(NLOCKS+1)+NLOCKS] = '|';
+	}
+	out[max_cpu * NLOCKS + max_cpu - 1] = 0;
+
+	if (!strcmp(var, "&audit_lock")) {
+		locknum = 0;
+	} else if (!strcmp(var, "&audit_message_lock")) {
+		locknum = 1;
+	} else if (!strcmp(var, "&hook_lock")) {
+		locknum = 2;
+	} else if (!strcmp(var, "&tasklist_lock")) {
+		locknum = 3;
+	} else if (!strcmp(var, "task")) {
+		locknum = 4;
+	} else {
+		locknum = 5;
+		printk(KERN_DEBUG "unknown lock %s %s %d\n", ltype, var, lock);
+	}
+
+	/* mark changed lock w/ capital letter */
+	if (lock) {
+		int c='l';
+		int cp='L';
+
+		if (locks[cpu][locknum]) printk(KERN_DEBUG "double lock?\n");
+
+		if        (!strcmp(ltype, "read")) {
+			c='r'; cp='R';
+		} else if (!strcmp(ltype, "write")) {
+			c='w'; cp='W';
+		} else if (!strcmp(ltype, "spin")) {
+			c='s'; cp='S';
+		} else if (!strcmp(ltype, "task")) {
+			c='t'; cp='T';
+		}
+		
+		locks[cpu][locknum] = c;
+		out[cpu * (NLOCKS+1) + locknum] = cp;
+	} else {
+		if (!locks[cpu][locknum]) printk(KERN_DEBUG "double unlock?\n");
+		locks[cpu][locknum] = 0;
+		out[cpu * (NLOCKS+1) + locknum] = '-';
+	}
+
+	printk(KERN_DEBUG "lock state: [%s]\n", out);
+	do_spin_unlock(&_debug_lock);
+}
+#endif
+
+MODULE_DESCRIPTION("Auditing subsystem");
+MODULE_LICENSE("GPL");
diff -urNp linux-2.6.5/drivers/audit/debug-locks.h linux-2.6.5.SUSE/drivers/audit/debug-locks.h
--- linux-2.6.5/drivers/audit/debug-locks.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/debug-locks.h	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ * Debug locks
+ *
+ */
+
+#ifndef DEBUG_LOCKS_H
+#define DEBUG_LOCKS_H
+
+#ifdef AUDIT_DEBUG_LOCKS
+
+extern void		_debug_locks(char *type, char *var, int lock);
+
+static inline void	do_read_lock(rwlock_t *lk) { read_lock(lk); }
+static inline void	do_read_unlock(rwlock_t *lk) { read_unlock(lk); }
+static inline void	do_write_lock(rwlock_t *lk) { write_lock(lk); }
+static inline void	do_write_unlock(rwlock_t *lk) { write_unlock(lk); }
+static inline void	do_spin_lock(spinlock_t *lk) { spin_lock(lk); }
+static inline void	do_spin_unlock(spinlock_t *lk) { spin_unlock(lk); }
+static inline void	do_down_read(struct rw_semaphore *lk) { down_read(lk); }
+static inline void	do_up_read(struct rw_semaphore *lk) { up_read(lk); }
+static inline void	do_down_write(struct rw_semaphore *lk) { down_write(lk); }
+static inline void	do_up_write(struct rw_semaphore *lk) { up_write(lk); }
+
+#define wrap_lock(f, lk) do { \
+		printk(KERN_DEBUG "[%d,%d] / " #f "(" #lk "): %s:%s:%d\n", \
+			current->cpu, current->pid, \
+			__FILE__, __FUNCTION__, __LINE__); \
+		_debug_locks(#f, #lk, 1); \
+		do_##f(lk); \
+		printk(KERN_DEBUG "[%d,%d] \\ " #f "(" #lk "): %s:%s:%d\n", \
+			current->cpu, current->pid, \
+			__FILE__, __FUNCTION__, __LINE__); \
+	} while (0)
+#define wrap_unlock(f, lk) do { \
+		printk(KERN_DEBUG "[%d,%d] - " #f "(" #lk "): %s:%s:%d\n", \
+			current->cpu, current->pid, \
+			__FILE__, __FUNCTION__, __LINE__); \
+		_debug_locks(#f, #lk, 0); \
+		do_##f(lk); \
+	} while (0)
+
+#undef read_lock
+#undef read_unlock
+#undef write_lock
+#undef write_unlock
+#undef spin_lock
+#undef spin_unlock
+
+#define read_lock(lk)		wrap_lock(read_lock, lk)
+#define read_unlock(lk)		wrap_unlock(read_unlock, lk)
+#define write_lock(lk)		wrap_lock(write_lock, lk)
+#define write_unlock(lk)	wrap_unlock(write_unlock, lk)
+#define spin_lock(lk)		wrap_lock(spin_lock, lk)
+#define spin_unlock(lk)		wrap_unlock(spin_unlock, lk)
+
+#endif /* AUDIT_DEBUG_LOCKS */
+
+#endif /* DEBUG_LOCKS_H */
diff -urNp linux-2.6.5/drivers/audit/fileset.c linux-2.6.5.SUSE/drivers/audit/fileset.c
--- linux-2.6.5/drivers/audit/fileset.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/fileset.c	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,260 @@
+/*
+ * fileset.c - handle set of files we're supposed to monitor
+ *
+ * Copyright (C) 2003 SuSE Linux AG
+ *
+ * Written by okir@suse.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/sys.h>
+#include <linux/miscdevice.h>
+#include <linux/audit.h>
+
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+
+#include "audit-private.h"
+
+#undef DEBUG_FILESET
+#ifdef DEBUG_FILTER
+# define DEBUG_FILESET
+#endif
+
+struct aud_file_object {
+	struct list_head	link;
+	atomic_t		refcnt;
+	unsigned int		seq;
+	const char *		name;
+	struct vfsmount *	vfsmnt;
+	struct dentry *		dentry;
+};
+
+static LIST_HEAD(audit_fileset);
+static DECLARE_MUTEX(fileset_lock);
+static struct task_struct *	lock_holder;
+
+static void			audit_fileset_invalidate(void);
+
+/*
+ * Lock the fileset
+ */
+int
+audit_fileset_lock(void)
+{
+	if (lock_holder == current)
+		return 0;
+	down(&fileset_lock);
+	lock_holder = current;
+	return 1;
+}
+
+void
+audit_fileset_unlock(int invalidate)
+{
+	if (lock_holder != current)
+		return;
+	if (invalidate)
+		audit_fileset_invalidate();
+	lock_holder = NULL;
+	up(&fileset_lock);
+}
+
+struct aud_file_object *
+audit_fileset_add(const char *path)
+{
+	struct aud_file_object	*obj;
+
+	obj = (struct aud_file_object *) kmalloc(sizeof(*obj), GFP_KERNEL);
+	if (obj == NULL)
+		return NULL;
+
+	memset(obj, 0, sizeof(*obj));
+	INIT_LIST_HEAD(&obj->link);
+	atomic_set(&obj->refcnt, 1);
+	obj->name = path;
+
+	list_add(&obj->link, &audit_fileset);
+
+	return obj;
+}
+
+void
+audit_fileset_release(struct aud_file_object *obj)
+{
+	if (atomic_dec_and_test(&obj->refcnt) != 0)
+		return;
+	list_del(&obj->link);
+	kfree(obj->name);
+	kfree(obj);
+}
+
+int
+audit_fileset_match(struct aud_file_object *obj, struct sysarg_data *tgt)
+{
+	struct dentry	*dp = tgt->at_path.dentry;
+	const char	*path = tgt->at_path.name;
+	int		need_to_unlock, match = 0;
+
+#ifdef DEBUG_FILESET
+	DPRINTF("obj=%s, path=%s, dp=%p\n", obj->name, path, dp);
+#endif
+	need_to_unlock = audit_fileset_lock();
+	if (dp == NULL)
+		return 1;
+	if (obj->dentry == NULL) {
+		struct nameidata	nd;
+
+		memset(&nd, 0, sizeof(nd));
+		if (!audit_path_init(obj->name, 0, &nd))
+			goto out;
+		if (path_walk(obj->name, &nd) < 0)
+			goto out;
+		obj->vfsmnt = mntget(nd.mnt);
+		obj->dentry = dget(nd.dentry);
+		path_release(&nd);
+	}
+
+#ifdef DEBUG_FILESET
+	DPRINTF("obj->dentry=%p, obj->inode=%p, dp->inode=%p\n",
+			obj->dentry,
+			obj->dentry->d_inode,
+			dp->d_inode);
+#endif
+
+	/* See if the name matches */
+	if (path && !strcmp(obj->name, path)) {
+		match = 1;
+		goto out;
+	} else if (obj->dentry->d_inode == dp->d_inode) {
+		/* This is a hard link. Replace the name we log
+		 * with the real name */
+
+#ifdef DEBUG_FILESET
+		DPRINTF("is a hardlink, replacing %s -> %s\n", path, obj->name);
+#endif
+
+		/* We're lucky - we know that the path buffer
+		 * has a size of PATH_MAX */
+		strncpy(tgt->at_path.name, obj->name, PATH_MAX-1);
+		tgt->at_path.name[PATH_MAX-1] = '\0';
+		tgt->at_path.len = strlen(tgt->at_path.name);
+
+		match = 1;
+		goto out;
+	}
+
+	/* See if the name of any parent directory
+	 * matches the filter entry. */
+       	while (!match && dp && dp->d_parent != dp) {
+		dp = dp->d_parent;
+		match = (obj->dentry == dp);
+	}
+
+out:	if (need_to_unlock && !match)
+		audit_fileset_unlock(0);
+	return match;
+}
+
+void
+audit_fileset_invalidate(void)
+{
+	struct aud_file_object	*obj;
+	struct list_head	*pos;
+
+	list_for_each(pos, &audit_fileset) {
+		obj = list_entry(pos, struct aud_file_object, link);
+		if (obj->dentry)
+			dput(obj->dentry);
+		obj->dentry = NULL;
+		if (obj->vfsmnt)
+			mntput(obj->vfsmnt);
+		obj->vfsmnt = NULL;
+	}
+}
+
+/*todo This is bad - we shouldn't have this cloned code here, since when the
+       base implementation (path_init and __emul_lookup_dentry) changes, we
+       may be in trouble */
+int
+audit_path_init(const char *name, unsigned int flags, struct nameidata *nd) {
+	nd->last_type = LAST_ROOT; /* if there are only slashes... */
+	nd->flags = flags;
+
+	read_lock(&current->fs->lock);
+	if (*name=='/') {
+		if (current->fs->altroot && !(flags & LOOKUP_NOALT)) {
+			nd->mnt = mntget(current->fs->altrootmnt);
+			nd->dentry = dget(current->fs->altroot);
+			read_unlock(&current->fs->lock);
+
+			/* __emul_lookup_dentry start */
+			if (path_walk(name, nd))
+				return 0;		/* something went wrong... */
+
+			if (!nd->dentry->d_inode || S_ISDIR(nd->dentry->d_inode->i_mode)) {
+				struct nameidata nd_root;
+
+				/*
+				 * NAME was not found in alternate root or it's a directory.  Try to find
+				 * it in the normal root:
+				 */
+				nd_root.last_type = LAST_ROOT;
+				nd_root.flags = nd->flags;
+				memcpy(&nd_root.intent, &nd->intent, sizeof(nd_root.intent));
+				read_lock(&current->fs->lock);
+				nd_root.mnt = mntget(current->fs->rootmnt);
+				nd_root.dentry = dget(current->fs->root);
+				read_unlock(&current->fs->lock);
+				if (!path_walk(name, &nd_root)) {
+					if (nd_root.dentry->d_inode) {
+						path_release(nd);
+						nd->dentry = nd_root.dentry;
+						nd->mnt = nd_root.mnt;
+						nd->last = nd_root.last;
+					}
+					else
+						path_release(&nd_root);
+				}
+			}
+			/* __emul_lookup_dentry end */
+
+			read_lock(&current->fs->lock);
+		}
+		nd->mnt = mntget(current->fs->rootmnt);
+		nd->dentry = dget(current->fs->root);
+	}
+	else {
+		nd->mnt = mntget(current->fs->pwdmnt);
+		nd->dentry = dget(current->fs->pwd);
+	}
+	read_unlock(&current->fs->lock);
+	return 1;
+}
diff -urNp linux-2.6.5/drivers/audit/filter.c linux-2.6.5.SUSE/drivers/audit/filter.c
--- linux-2.6.5/drivers/audit/filter.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/filter.c	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,817 @@
+/*
+ * filter.c - system call filtering for the audit subsystem
+ *
+ * For all functions in this file, the caller must hold the global
+ * audit_lock, either read locked (for audit_filter_eval), or write
+ * locked (for all other calls).
+ *
+ * Copyright (C) 2003 SuSE Linux AG
+ *
+ * Written by okir@suse.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/sys.h>
+#include <linux/miscdevice.h>
+#include <linux/audit.h>
+#include <linux/poll.h>
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <net/sock.h>
+
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+
+#include "audit-private.h"
+
+struct aud_filter {
+	struct list_head	af_link;
+	atomic_t		af_refcnt;
+
+	unsigned short		af_num;
+	unsigned short		af_op;
+
+	char *			af_evname;
+
+	union {
+		struct f_apply {
+			unsigned int		target;
+			struct aud_filter *	predicate;
+		} apply;
+		struct f_bool {
+			struct aud_filter *	left;
+			struct aud_filter *	right;
+		} boolean;
+		struct f_return {
+			unsigned int		action;
+		} freturn;
+		struct f_intop {
+			uint64_t		value, mask;
+		} intop;
+		struct f_strop {
+			char *			value;
+			int			len;
+		} strop;
+		struct f_fileop {
+			struct aud_file_object *file;
+		} fileop;
+	} u;
+};
+#define af_left		u.boolean.left
+#define af_right	u.boolean.right
+#define af_target	u.apply.target
+#define af_predicate	u.apply.predicate
+#define af_action	u.freturn.action
+#define af_intval	u.intop.value
+#define af_intmask	u.intop.mask
+#define af_strval	u.strop.value
+#define af_strlen	u.strop.len
+#define af_file		u.fileop.file
+
+static LIST_HEAD(filter_list);
+
+
+static void	__audit_filter_free(struct aud_filter *f);
+
+/*
+ * Find an audit filter and bump the reference count.
+ * Must be locked when we get here
+ */
+static struct aud_filter *
+__audit_filter_find(unsigned int num)
+{
+	struct aud_filter	*f;
+	struct list_head	*pos;
+
+	list_for_each(pos, &filter_list) {
+		f = list_entry(pos, struct aud_filter, af_link);
+		if (f->af_num == num)
+			return f;
+	}
+	return NULL;
+}
+
+/*
+ * Find an audit filter and bump the reference count.
+ * Must be locked when we get here
+ */
+struct aud_filter *
+audit_filter_get(unsigned int num)
+{
+	struct aud_filter	*f;
+
+	if ((f = __audit_filter_find(num)) != NULL)
+		atomic_inc(&f->af_refcnt);
+	return f;
+}
+
+/*
+ * Release a reference on a filter object
+ */
+static void
+__audit_filter_put(struct aud_filter *f, struct list_head *free_list)
+{
+	if (f && atomic_dec_and_test(&f->af_refcnt)) {
+		/* Remove from linked list */
+		list_del_init(&f->af_link);
+		if (free_list) {
+			list_add(&f->af_link, free_list);
+		} else {
+			__audit_filter_free(f);
+		}
+	}
+}
+
+void
+audit_filter_put(struct aud_filter *f)
+{
+	__audit_filter_put(f, NULL);
+}
+
+/*
+ * Free a filter object, recursively.
+ */
+static void
+__audit_filter_free(struct aud_filter *f)
+{
+	LIST_HEAD(free_list);
+
+	do {
+		switch (f->af_op) {
+		case AUD_FILT_OP_AND:
+		case AUD_FILT_OP_OR:
+			__audit_filter_put(f->af_right, &free_list);
+			/* fallthru */
+		case AUD_FILT_OP_NOT:
+			__audit_filter_put(f->af_left, &free_list);
+			break;
+		case AUD_FILT_OP_APPLY:
+			__audit_filter_put(f->af_predicate, &free_list);
+			break;
+		case AUD_FILT_OP_STREQ:
+			if (f->af_strval)
+				kfree(f->af_strval);
+			break;
+		case AUD_FILT_OP_PREFIX:
+			if (f->af_file)
+				audit_fileset_release(f->af_file);
+			break;
+		}
+
+		memset(f, 0, sizeof(*f));
+		kfree(f);
+
+		/* See if detaching filter sub-expressions
+		 * released the last reference as well. If so,
+		 * delete these sub-expressions too. */
+		if (!list_empty(&free_list)) {
+			f = list_entry(free_list.next, struct aud_filter, af_link);
+			list_del_init(&f->af_link);
+		} else {
+			f = NULL;
+		}
+	} while (f != NULL);
+}
+
+/*
+ * Create a new filter object, given the user
+ * supplied data
+ */
+int
+audit_filter_add(const struct audit_filter __user *data)
+{
+	struct audit_filter	copy;
+	struct aud_filter	*f = NULL;
+	char			*string = NULL;
+	size_t			namelen;
+	int			err, n;
+
+	if (copy_from_user(&copy, data, sizeof(*data)))
+		return -EFAULT;
+	data = &copy;
+
+	err = -EEXIST;
+	if (__audit_filter_find(data->num))
+		goto err;
+
+	err = -ENOBUFS;
+	if ((namelen = strnlen(data->event, sizeof(data->event))) != 0)
+		namelen++;
+	if (!(f = kmalloc(sizeof(*f) + namelen, GFP_KERNEL)))
+		goto err;
+
+	memset(f, 0, sizeof(*f));
+	f->af_num = data->num;
+	f->af_op  = data->op;
+	if (namelen) {
+		f->af_evname = (char *) f + sizeof(*f);
+		memcpy(f->af_evname, data->event, namelen);
+	}
+
+	err = -EINVAL;
+	switch (f->af_op) {
+	case AUD_FILT_OP_AND:
+	case AUD_FILT_OP_OR:
+		if (!(f->af_left  = audit_filter_get(data->u.boolean.filt1))
+		 || !(f->af_right = audit_filter_get(data->u.boolean.filt2)))
+			goto err;
+		break;
+	case AUD_FILT_OP_NOT:
+		if (!(f->af_left  = audit_filter_get(data->u.boolean.filt1)))
+			goto err;
+		break;
+	case AUD_FILT_OP_APPLY:
+		f->af_target = data->u.apply.target;
+		f->af_predicate = audit_filter_get(data->u.apply.filter);
+		if (!f->af_predicate)
+			goto err;
+		break;
+	case AUD_FILT_OP_RETURN:
+		f->af_action = data->u.freturn.action;
+		break;
+	case AUD_FILT_OP_TRUE:
+	case AUD_FILT_OP_FALSE:
+	case AUD_FILT_OP_EQ:
+	case AUD_FILT_OP_NE:
+	case AUD_FILT_OP_GT:
+	case AUD_FILT_OP_GE:
+	case AUD_FILT_OP_LE:
+	case AUD_FILT_OP_LT:
+		f->af_intval = data->u.integer.value;
+		break;
+	case AUD_FILT_OP_MASK:
+		f->af_intval = data->u.integer.value;
+		f->af_intmask = data->u.integer.mask;
+		break;
+	case AUD_FILT_OP_STREQ:
+	case AUD_FILT_OP_PREFIX:
+		n = strnlen_user(data->u.string.value, PATH_MAX);
+		err = -ENOBUFS;
+		if (n > PATH_MAX || !(string = kmalloc(n, GFP_KERNEL)))
+			goto err;
+		err = -EFAULT;
+		if (copy_from_user(string, data->u.string.value, n))
+			goto err_stringfree;
+		if (f->af_op == AUD_FILT_OP_STREQ) {
+			f->af_strval = string;
+			f->af_strlen = n-1;
+		} else {
+			err = -ENOBUFS;
+			f->af_file = audit_fileset_add(string);
+			if (!f->af_file)
+				goto err_stringfree;
+		}
+		break;
+	default:
+		goto err;
+	}
+
+	list_add(&f->af_link, &filter_list);
+	atomic_inc(&f->af_refcnt);
+	return 0;
+
+err_stringfree:
+	kfree(string);
+
+err:	if (f)
+		__audit_filter_free(f);
+	return err;
+}
+
+int
+audit_filter_clear(void)
+{
+	struct list_head	*pos, *next;
+	struct aud_filter	*f;
+
+	list_for_each_safe(pos, next, &filter_list) {
+		f = list_entry(pos, struct aud_filter, af_link);
+		list_del_init(&f->af_link);
+		audit_filter_put(f);
+	}
+	return 0;
+}
+
+/*
+ * Check if the given operation is a predicate
+ */
+static inline int
+__is_predicate(const struct aud_filter *f)
+{
+	if (!f)
+		return 0;
+	switch (f->af_op) {
+	case AUD_FILT_OP_AND:
+	case AUD_FILT_OP_OR:
+	case AUD_FILT_OP_NOT:
+	case AUD_FILT_OP_APPLY:
+		return 0;
+	}
+	return 1;
+}
+
+/*
+ * Make sure the data is type compatible with the predicate
+ */
+static inline int
+__audit_predicate_type_compatible(unsigned int op, unsigned int type)
+{
+	if (AUD_FILT_ARGTYPE_INT(op)
+	 && type != AUDIT_ARG_IMMEDIATE
+	 && type != AUDIT_ARG_NULL)
+		return 0;
+
+	if (AUD_FILT_ARGTYPE_STR(op)
+	 && type != AUDIT_ARG_STRING
+	 && type != AUDIT_ARG_PATH)
+		return 0;
+
+	return 1;
+}
+
+/*
+ * Fill in the specified target
+ */
+static struct sysarg_data *
+__audit_get_target(unsigned int n,
+			const struct aud_event_data *ev,
+		       	struct sysarg_data *tgt,
+			const struct sysarg_data *parent_target)
+{
+	/* Most common case by far */
+	tgt->at_type = AUDIT_ARG_IMMEDIATE;
+	tgt->at_flags = 0;
+
+	/* Process attributes */
+	if (AUD_FILT_TGT_PROCESS_ATTR(n)) {
+		switch (n) {
+		case AUD_FILT_TGT_UID:
+			tgt->at_intval = current->uid;
+			break;
+		case AUD_FILT_TGT_GID:
+			tgt->at_intval = current->gid;
+			break;
+		case AUD_FILT_TGT_DUMPABLE:
+#ifdef is_dumpable
+			tgt->at_intval = is_dumpable(current);
+#else
+			tgt->at_intval = current->mm && current->mm->dumpable;
+#endif
+			break;
+		case AUD_FILT_TGT_EXIT_CODE:
+			tgt->at_intval = ev->exit_status;
+			tgt->at_flags |= AUD_ARG_SIGNED;
+			break;
+		case AUD_FILT_TGT_LOGIN_UID:
+			task_lock(current);
+			if (current->audit == NULL) {
+				task_unlock(current);
+				goto invalid;
+			}
+			tgt->at_intval = ((struct aud_process *) current->audit)->audit_uid;
+			task_unlock(current);
+			break;
+		default:
+			goto invalid;
+		}
+		return tgt;
+	}
+
+	/* System call attributes */
+	if (AUD_FILT_TGT_SYSCALL_ATTR(n)) {
+		struct aud_syscall_data	*sc;
+
+		if ((sc = ev->syscall) == NULL)
+			goto invalid;
+		if (n == AUD_FILT_TGT_MINOR_CODE) {
+			tgt->at_intval = sc->minor;
+		} else
+		if (n == AUD_FILT_TGT_RETURN_CODE) {
+			tgt->at_flags = AUD_ARG_SIGNED;
+			tgt->at_intval = sc->result;
+		} else
+		if (n == AUD_FILT_TGT_USERMSG_EVNAME) {
+			if (ev->name == NULL)
+				goto invalid;
+			tgt->at_type = AUDIT_ARG_STRING;
+			tgt->at_strval = (char *)ev->name;
+		} else {
+			tgt = audit_get_argument(sc, n);
+		}
+		return tgt;
+	}
+
+	/* File attributes */
+	if (AUD_FILT_TGT_FILE_ATTR(n)) {
+		struct dentry	*dentry, *up;
+		struct inode	*inode;
+
+		if (parent_target == NULL
+		 || parent_target->at_type != AUDIT_ARG_PATH)
+			goto invalid;
+
+		dentry = parent_target->at_path.dentry;
+		while (!(inode = dentry->d_inode)) {
+			up = dentry->d_parent;
+			if (dentry == up)
+				goto invalid;
+			dentry = up;
+		}
+
+		switch (n) {
+		case AUD_FILT_TGT_FILE_DEV:
+			tgt->at_intval = inode->i_sb->s_dev;
+			break;
+		case AUD_FILT_TGT_FILE_INO:
+			tgt->at_intval = inode->i_ino;
+			break;
+		case AUD_FILT_TGT_FILE_MODE:
+			tgt->at_intval = inode->i_mode;
+			break;
+		case AUD_FILT_TGT_FILE_UID:
+			tgt->at_intval = inode->i_uid;
+			break;
+		case AUD_FILT_TGT_FILE_GID:
+			tgt->at_intval = inode->i_gid;
+			break;
+		case AUD_FILT_TGT_FILE_RDEV_MAJOR:
+			if (!S_ISCHR(inode->i_mode) && !S_ISBLK(inode->i_mode))
+				break;
+			tgt->at_intval = MAJOR(inode->i_rdev);
+			break;
+		case AUD_FILT_TGT_FILE_RDEV_MINOR:
+			if (!S_ISCHR(inode->i_mode) && !S_ISBLK(inode->i_mode))
+				break;
+			tgt->at_intval = MINOR(inode->i_rdev);
+			break;
+		default:
+			goto invalid;
+		}
+		return tgt;
+	}
+
+	/* Socket attributes */
+	if (AUD_FILT_TGT_SOCK_ATTR(n)) {
+		struct dentry	*dentry;
+		struct inode	*inode;
+		struct socket	*sock;
+
+		if (parent_target) {
+			dentry = parent_target->at_path.dentry;
+			DPRINTF("sock attr: type=%d, dentry=%p, inode=%p\n",
+				parent_target->at_type,
+				dentry,
+				dentry ? dentry->d_inode : NULL);
+		}
+		if (parent_target == NULL
+		 || parent_target->at_type != AUDIT_ARG_PATH
+		 || !(dentry = parent_target->at_path.dentry)
+		 || !(inode = dentry->d_inode)
+		 || !inode->i_sock)
+			goto invalid;
+
+		sock = SOCKET_I(inode);
+		if (!sock->ops)
+			goto invalid;
+
+		switch (n) {
+		case AUD_FILT_TGT_SOCK_FAMILY:
+			tgt->at_intval = sock->ops->family;
+			break;
+		case AUD_FILT_TGT_SOCK_TYPE:
+			tgt->at_intval = sock->type;
+			break;
+		default:
+			goto invalid;
+		}
+		return tgt;
+	}
+
+	/* rtnetlink attributes */
+	if (AUD_FILT_TGT_NETLINK_ATTR(n)) {
+		struct sk_buff	*skb;
+		struct nlmsghdr	*nlh;
+
+		if ((skb = ev->netconf) == NULL
+		 || (skb->len < NLMSG_LENGTH(sizeof(struct rtgenmsg))))
+			goto invalid;
+
+		nlh = (struct nlmsghdr *) skb->data;
+		switch (n) {
+		case AUD_FILT_TGT_NETLINK_TYPE:
+			tgt->at_intval = nlh->nlmsg_type;
+			break;
+		case AUD_FILT_TGT_NETLINK_FLAGS:
+			tgt->at_intval = nlh->nlmsg_flags;
+			break;
+		case AUD_FILT_TGT_NETLINK_FAMILY:
+			tgt->at_intval = ((struct rtgenmsg *)NLMSG_DATA(nlh))->rtgen_family;
+			break;
+		default:
+			goto invalid;
+		}
+		return tgt;
+	}
+
+invalid:
+	return ERR_PTR(-EINVAL);
+}
+
+/*
+ * Print target value
+ */
+#ifdef DEBUG_FILTER
+static void
+__audit_print_target(const struct sysarg_data *tgt)
+{
+	if (!audit_debug)
+		return;
+
+	switch (tgt->at_type) {
+	case AUDIT_ARG_IMMEDIATE:
+		if (tgt->at_flags & AUD_ARG_SIGNED)
+			DPRINTF("  value is [signed] %lld\n", tgt->at_intval);
+		else
+			DPRINTF("  value is [unsigned] %llu\n", tgt->at_intval);
+		break;
+	case AUDIT_ARG_STRING:
+		DPRINTF("  value is [string] %s\n", tgt->at_path.name);
+		break;
+	case AUDIT_ARG_PATH:
+		DPRINTF("  value is [path] %s\n", tgt->at_strval);
+		break;
+	case AUDIT_ARG_POINTER:
+		DPRINTF("  value is [pointer] size=%u\n", tgt->at_data.len);
+		break;
+	case AUDIT_ARG_NULL:
+		DPRINTF("  value is [null]\n");
+		break;
+	default:
+		DPRINTF("  value is [unknown]\n");
+	}
+}
+#endif
+
+/*
+ * Comparison operation
+ */
+#define __audit_compare(tgt, op, f) \
+do { \
+	if ((tgt)->at_flags & AUD_ARG_SIGNED) \
+		return (long) ((tgt)->at_intval) op (long) ((f)->af_intval); \
+	else \
+		return ((tgt)->at_intval) op ((f)->af_intval); \
+} while (0)
+
+/*
+ * Evaluate predicate
+ */
+static int
+__audit_predicate_eval(const struct aud_filter *f,
+	       		const struct aud_event_data *ev,
+			struct sysarg_data *tgt)
+{
+	char	*str;
+
+	if (f->af_op == AUD_FILT_OP_TRUE)
+		return AUDIT_LOG;
+	if (f->af_op == AUD_FILT_OP_FALSE)
+		return 0;
+	if (f->af_op == AUD_FILT_OP_RETURN)
+		return f->af_action;
+
+	if (tgt == NULL)
+		return -EINVAL;
+
+	if (!__audit_predicate_type_compatible(f->af_op, tgt->at_type))
+		return -EINVAL;
+
+	switch (f->af_op) {
+	case AUD_FILT_OP_EQ: __audit_compare(tgt, ==, f);
+	case AUD_FILT_OP_NE: __audit_compare(tgt, !=, f);
+	case AUD_FILT_OP_LT: __audit_compare(tgt, <,  f);
+	case AUD_FILT_OP_LE: __audit_compare(tgt, <=, f);
+	case AUD_FILT_OP_GE: __audit_compare(tgt, >=, f);
+	case AUD_FILT_OP_GT: __audit_compare(tgt, >,  f);
+	case AUD_FILT_OP_MASK:
+		return ((tgt->at_intval & f->af_intmask) == f->af_intval);
+	case AUD_FILT_OP_STREQ:
+		str = tgt->at_strval;
+		return !strcmp(str, f->af_strval);
+	case AUD_FILT_OP_PREFIX:
+		return audit_fileset_match(f->af_file, tgt);
+	}
+
+	DPRINTF("Unsupported filter op %d\n", f->af_op);
+	return -EINVAL;
+}
+
+/*
+ * Recursively evaluate a filter expression
+ *
+ * If the user space did its job correctly, operations on a set
+ * of values get stored so that the left term of the OR expression
+ * is the comparison, so we don't have to recurse.
+ */
+#define DEF_VISITOR_STACK	8
+#define DEF_TARGET_STACK	8
+struct visitor {
+	struct visitor *	prev;
+	const struct aud_filter * node;
+	struct sysarg_data *	target;
+	const char *		tag;
+};
+
+int
+audit_filter_eval(const struct aud_filter *filt, struct aud_event_data *ev)
+{
+	struct sysarg_data tstack[DEF_TARGET_STACK], *tstack_top, *tgt = NULL;
+	struct visitor	vstack[DEF_VISITOR_STACK], *vstack_top;
+	unsigned int	nvisitors = 0, ntargets = 0;
+	struct visitor	*v = NULL, *vnew;
+	struct aud_filter *next;
+	const char	*tag = NULL;
+	int		r, res = 0, flags = 0;
+
+	tstack_top = tstack + DEF_TARGET_STACK;
+	vstack_top = vstack + DEF_VISITOR_STACK;
+
+	while (filt) {
+		/* Special case for expanded sets */
+		while (filt->af_op == AUD_FILT_OP_OR && __is_predicate(filt->af_left)) {
+			if ((r = __audit_predicate_eval(filt->af_left, ev, tgt)) < 0)
+				goto error;
+			flags |= r;
+			if (r & AUDIT_LOG) {
+				if (!tag)
+					tag = filt->af_evname;
+				goto up;
+			}
+			filt = filt->af_right;
+		}
+
+		switch (filt->af_op) {
+		case AUD_FILT_OP_APPLY:
+			/* Apply predicate to target */
+			if (ntargets >= DEF_TARGET_STACK) {
+				printk(KERN_NOTICE "%s: Too many nested "
+					       "targets in filter expression\n",
+					       __FUNCTION__);
+				goto einval;
+			}
+			tgt = __audit_get_target(filt->af_target, ev,
+						&tstack[ntargets], tgt);
+
+			if (IS_ERR(tgt)) {
+				r = PTR_ERR(tgt);
+				if (r == -EINVAL) {
+					printk(KERN_NOTICE
+						"Filter target 0x%x not known or not "
+						"supported in this context\n",
+					       	filt->af_target);
+				}
+				goto error;
+			}
+			if (tgt == &tstack[ntargets])
+				ntargets++;
+			next = filt->af_predicate;
+#ifdef DEBUG_FILTER
+			__audit_print_target(tgt);
+#endif
+			goto push_node;
+
+		case AUD_FILT_OP_AND:
+		case AUD_FILT_OP_OR:
+		case AUD_FILT_OP_NOT:
+			/* First, we need to push the current node onto the
+			 * visitor stack, then we continue evaluating the left
+			 * term.
+			 */
+			next = filt->af_left;
+
+		push_node:
+			/* Copy the node's tag in case it matches */
+			if (!tag)
+				tag = filt->af_evname;
+			if (nvisitors < DEF_VISITOR_STACK) {
+				vnew = &vstack[nvisitors++];
+			} else
+			if (!(vnew = (struct visitor *) kmalloc(sizeof(*v), GFP_KERNEL)))
+				goto enomem;
+			memset(vnew, 0, sizeof(*vnew));
+			vnew->prev = v;
+			vnew->node = filt;
+			vnew->target = tgt;
+			vnew->tag = tag;
+			v = vnew;
+
+			filt = next;
+			tag = NULL;
+			continue;
+
+		default:
+			/* We have a predicate. Evaluate */
+			if ((r = __audit_predicate_eval(filt, ev, tgt)) < 0)
+				goto error;
+			flags |= r;
+			if ((r & AUDIT_LOG) && !tag)
+				tag = filt->af_evname;
+			break;
+		}
+
+up:
+		/* Combine with result of parent node */
+		filt = NULL;
+		while (v != NULL && filt == NULL) {
+			if (!(r & AUDIT_LOG))
+				tag = NULL;
+
+			switch (v->node->af_op) {
+			case AUD_FILT_OP_NOT:
+				tag = NULL;
+				r ^= AUDIT_LOG;
+				break;
+			case AUD_FILT_OP_OR:
+				/* Left hand term evaluated to false,
+				 * try right hand */
+				if (!(r & AUDIT_LOG))
+					filt = v->node->af_right;
+				break;
+			case AUD_FILT_OP_AND:
+				/* Left hand term evaluated to true,
+				 * try right hand as well */
+				if (r & AUDIT_LOG)
+					filt = v->node->af_right;
+				break;
+			case AUD_FILT_OP_APPLY:
+				break;
+			}
+
+			/* This node _may_ evaluate to true. Keep the tag.
+			 * If it's false, we'll dump the tag later */
+			if (tag == NULL)
+				tag = v->tag;
+
+			/* Pop the visitor node */
+			vnew = v->prev;
+			if (vstack <= v && v < vstack_top) {
+				nvisitors--;
+			} else {
+				kfree(v);
+			}
+			v = vnew;
+
+			/* If the target goes out of scope, release it */
+			if (v && v->target != tgt && tstack <= tgt && tgt < tstack_top) {
+				tgt = v->target;
+				ntargets--;
+			}
+		}
+
+		res = r;
+	}
+
+	if (tag)
+		strncpy(ev->name, tag, sizeof(ev->name));
+	return res;
+
+enomem:	r = -ENOMEM;
+	goto error;
+einval:	r = -EINVAL;
+
+error:	/* Unwind the stack of visitors */
+	while (v) {
+		vnew = v->prev;
+		if (vstack <= v && v < vstack_top)
+			break;
+		kfree(v);
+		v = vnew;
+	}
+	return r;
+}
diff -urNp linux-2.6.5/drivers/audit/ioctl.c linux-2.6.5.SUSE/drivers/audit/ioctl.c
--- linux-2.6.5/drivers/audit/ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/ioctl.c	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,281 @@
+/*
+ * ioctl.c
+ *
+ * Perform 32->64 ioctl conversion
+ *
+ * Copyright (C) 2003 SuSE Linux AG
+ * Copyright (C) 2003, International Business Machines Corp.
+ *
+ * Written by Jerone Young.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/sys.h>
+#include <linux/audit.h>
+#include <linux/ioctl.h>
+#include <linux/ioctl32.h>
+
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+
+#include "audit-private.h"
+
+static int	do_audit_usermsg_ioctl(unsigned int fd, unsigned int cmd, 
+				unsigned long arg, struct file * file);
+static int	do_audit_filter_ioctl(unsigned int fd, unsigned int cmd, 
+				unsigned long arg, struct file * file);
+static int	do_audit_policy_ioctl(unsigned int fd, unsigned int cmd, 
+				unsigned long arg, struct file * file);
+static int	do_audit_login_ioctl(unsigned int fd, unsigned int cmd, 
+				unsigned long arg, struct file * file);
+
+
+struct audit_message32 {
+	uint32_t	msg_type;
+	char	msg_evname[AUD_MAX_EVNAME];
+	uint32_t	msg_data;
+	uint32_t	msg_size;
+};
+
+struct audit_filter32 {
+	unsigned short  num;
+	unsigned short  op;
+	char event[AUD_MAX_EVNAME];
+	union {
+		struct {
+			unsigned short	target;
+			unsigned short	filter;
+		} apply;
+		struct {
+			unsigned short filt1,filt2;
+		} boolean;
+		struct {
+			uint32_t action;
+		} freturn;
+		struct {
+			uint64_t value;
+			uint64_t mask;
+		} integer;
+		struct {
+			uint32_t value;
+		} string;
+	} u;
+};
+
+#define AUIOCUSERMESSAGE_32        _IOR(AUD_MAGIC, 111, struct audit_message32)
+
+static int 
+do_audit_usermsg_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg, 
+			struct file * file)
+{
+	int ret, i;
+	mm_segment_t old_fs;
+	struct audit_message aum;
+	struct audit_message32 copy;
+
+	if (copy_from_user(&copy, (struct audit_message32 *) arg, 
+			sizeof(struct audit_message32)))
+		return -EFAULT;
+		
+	aum.msg_type = copy.msg_type;
+	for (i = 0; i < AUD_MAX_EVNAME; i++) 
+		aum.msg_evname[i] = copy.msg_evname[i];
+	aum.msg_data = (void *)(unsigned long) copy.msg_data;
+	aum.msg_size = copy.msg_size;
+
+	/* Make sure the pointer is good. */
+	if (!access_ok(VERIFY_READ, aum.msg_data, aum.msg_size))
+		return -EFAULT;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_ioctl(fd, AUIOCUSERMESSAGE, (unsigned long) &aum);
+	set_fs(old_fs);
+
+	return ret;
+}
+
+static int 
+do_audit_filter_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg, 
+			struct file * file)
+{
+	int ret, i;
+	mm_segment_t old_fs;
+	struct audit_filter auf;
+	struct audit_filter32 copy;
+
+	if (copy_from_user(&copy, (struct audit_filter32 *) arg, 
+			sizeof(struct audit_filter32)))
+		return -EFAULT;
+	
+	auf.num = copy.num;
+	auf.op = copy.op;
+	for (i = 0; i < AUD_MAX_EVNAME; i++) 
+		auf.event[i] = copy.event[i];
+	switch (copy.op) {
+	case AUD_FILT_OP_AND:
+	case AUD_FILT_OP_OR:
+	case AUD_FILT_OP_NOT:
+		auf.u.boolean.filt1 = copy.u.boolean.filt1;
+		auf.u.boolean.filt2 = copy.u.boolean.filt2;
+		break;
+	case AUD_FILT_OP_APPLY:
+		auf.u.apply.target = copy.u.apply.target;
+		auf.u.apply.filter = copy.u.apply.filter;
+		break;
+	case AUD_FILT_OP_RETURN:
+		auf.u.freturn.action = copy.u.freturn.action;
+		break;
+	case AUD_FILT_OP_EQ:
+	case AUD_FILT_OP_NE:
+	case AUD_FILT_OP_GT:
+	case AUD_FILT_OP_GE:
+	case AUD_FILT_OP_LE:
+	case AUD_FILT_OP_LT:
+	case AUD_FILT_OP_MASK:
+		auf.u.integer.value = copy.u.integer.value;
+		auf.u.integer.mask = copy.u.integer.mask;
+		break;
+	case AUD_FILT_OP_STREQ:
+	case AUD_FILT_OP_PREFIX:
+		auf.u.string.value = (char *)(unsigned long) copy.u.string.value;
+		break;
+	default:
+		break;
+	}
+	
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_ioctl(fd, cmd, (unsigned long) &auf);
+	set_fs(old_fs);
+
+	return ret;
+}
+
+static int 
+do_audit_policy_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg, 
+			struct file * file)
+{	
+	int ret;
+	mm_segment_t old_fs;
+	struct audit_policy pol;
+	
+	if (copy_from_user(&pol, (struct audit_policy *) arg, 
+			sizeof(struct audit_policy)))
+		return -EFAULT;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_ioctl(fd, cmd, (unsigned long) &pol);
+	set_fs(old_fs);
+	
+	return ret;
+}
+
+static int 
+do_audit_login_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg,
+			struct file * file)
+{
+	int ret;
+	mm_segment_t old_fs;
+	struct audit_login lg;
+
+	if (copy_from_user(&lg, (struct audit_login *) arg, 
+			sizeof(struct audit_login)))
+		return -EFAULT;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_ioctl(fd, cmd, (unsigned long) &lg);
+	set_fs(old_fs);
+
+	return ret;	
+}
+
+static const struct {
+	int		code;
+	int		(*handler)(unsigned int,
+				   unsigned int,
+				   unsigned long,
+				   struct file *);
+} converters[] = {
+	/* compatible */
+	{ AUIOCATTACH,		NULL },
+	{ AUIOCDETACH,		NULL },
+	{ AUIOCSUSPEND,		NULL },
+	{ AUIOCRESUME,		NULL },
+	{ AUIOCCLRPOLICY,	NULL },
+	{ AUIOCIAMAUDITD,	NULL },
+	{ AUIOCSETAUDITID,	NULL },
+	{ AUIOCCLRFILTER,	NULL },
+	{ AUIOCVERSION,		NULL },
+	{ AUIOCRESET,		NULL },
+
+	/* need handler */
+	{ AUIOCLOGIN,		do_audit_login_ioctl },
+	{ AUIOCSETPOLICY,	do_audit_policy_ioctl },
+	{ AUIOCUSERMESSAGE,	do_audit_usermsg_ioctl },
+	{ AUIOCUSERMESSAGE_32,	do_audit_usermsg_ioctl },
+	{ AUIOCSETFILTER,	do_audit_filter_ioctl },
+
+	{ -1 }
+};
+
+/*
+ * Register ioctl converters
+ */
+int
+audit_register_ioctl_converters(void)
+{
+	int	i, err = 0;
+
+	for (i = 0; err >= 0 && converters[i].code != -1; i++) {
+		err = register_ioctl32_conversion(converters[i].code,
+				converters[i].handler);
+	}
+
+	if (err < 0)
+		printk(KERN_ERR "audit: Failed to register ioctl32 "
+				"conversion handlers\n");
+	return err;
+}
+
+/*
+ * Unregister ioctl converters
+ */
+int
+audit_unregister_ioctl_converters(void)
+{
+	int	i, err = 0;
+
+	for (i = 0; err >= 0 && converters[i].code != -1; i++) {
+		err = unregister_ioctl32_conversion(converters[i].code);
+	}
+
+	if (err < 0)
+		printk(KERN_ERR "audit: Failed to unregister ioctl32 "
+				"conversion handlers\n");
+	return err;
+}
diff -urNp linux-2.6.5/drivers/audit/message.c linux-2.6.5.SUSE/drivers/audit/message.c
--- linux-2.6.5/drivers/audit/message.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/message.c	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,443 @@
+/*
+ * message.c
+ *
+ * Linux Audit Subsystem, message passing stuff
+ *
+ *
+ * Copyright (C) 2003 SuSE Linux AG
+ *
+ * Written by okir@suse.de, based on ideas from systrace, by
+ * Niels Provos (OpenBSD) and ported to Linux by Marius Aamodt Eriksen.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/skbuff.h>
+#include <linux/rtnetlink.h>
+
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+
+#include <linux/audit.h>
+
+#include "audit-private.h"
+
+/* This looks a lot like wait_queue handling, but I couldn't
+ * get add_wait_queue_exclusive() to work... */
+struct audit_writer {
+	struct list_head	entry;
+	task_t *	task;
+	int		status;
+};
+
+int				audit_message_enabled;
+unsigned int			audit_max_messages = 1024;
+static spinlock_t		audit_message_lock = SPIN_LOCK_UNLOCKED;
+static unsigned int		audit_message_count;
+static unsigned int		audit_message_seq;
+static DECLARE_WAIT_QUEUE_HEAD(audit_reader_wait);
+static LIST_HEAD(audit_messages);
+static LIST_HEAD(audit_writers);
+
+/*
+ * Enable/disable audit messages
+ */
+int
+audit_msg_enable(void)
+{
+	int	res = -EBUSY;
+
+	spin_lock(&audit_message_lock);
+	if (!audit_message_enabled) {
+		audit_message_enabled = 1;
+		res = 0;
+		mb();
+	}
+	spin_unlock(&audit_message_lock);
+	return res;
+}
+
+/*
+ * Wake up the first writer
+ */
+static inline int
+__audit_wake_writer(int res)
+{
+	struct audit_writer *w;
+
+	if (list_empty(&audit_writers))
+		return 0;
+
+	w = list_entry(audit_writers.next, struct audit_writer, entry);
+	DPRINTF("wakeup %p\n", w);
+	w->status = res;
+	list_del_init(&w->entry);
+	wake_up_process(w->task);
+
+	return 1;
+}
+
+void
+audit_msg_disable(void)
+{
+	spin_lock(&audit_message_lock);
+	audit_message_enabled = 0;
+
+	/* Inform all processes waiting to deliver
+	 * messages to the audit daemon that we're
+	 * no longer interested */
+	while (__audit_wake_writer(-ENODEV))
+		;
+
+	spin_unlock(&audit_message_lock);
+	mb();
+
+	/* There shouldn't be any processes left on the
+	 * reader queue, but we wake them up anyway */
+	wake_up(&audit_reader_wait);
+}
+
+/*
+ * Allocate a new audit message head
+ *
+ * Beware - pinfo may be NULL when called from
+ * audit_user_message().
+ */
+struct aud_msg_head *
+audit_msg_new(struct aud_process *pinfo, int type,
+	       const char *evname, size_t size)
+{
+	struct aud_msg_head *msgh;
+	struct aud_message *msg;
+	unsigned int seqno;
+
+	spin_lock(&audit_message_lock);
+	if (audit_message_count < audit_max_messages) {
+		audit_message_count++;
+	} else {
+		struct audit_writer writer;
+
+		if (!audit_message_enabled) {
+			spin_unlock(&audit_message_lock);
+			return ERR_PTR(-ENODEV);
+		}
+		DPRINTF("%p waiting for wakeup (%u, pid=%d)\n", &writer, audit_message_count, current->pid);
+		writer.task = current;
+		list_add_tail(&writer.entry, &audit_writers);
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+
+		spin_unlock(&audit_message_lock);
+		schedule();
+
+		if (writer.status < 0)
+			return ERR_PTR(writer.status);
+
+		spin_lock(&audit_message_lock);
+
+		/* When we get here, we know we are permitted
+		 * to allocate a message.
+		 * audit_message_count has already been adjusted. */
+	}
+
+	if (audit_message_count > audit_max_messages)
+		printk(KERN_WARNING "Oops, too many audit messages\n");
+
+	seqno = audit_message_seq++;
+	spin_unlock(&audit_message_lock);
+
+	while (1) {
+		msgh = kmalloc(sizeof(*msgh) + size, GFP_KERNEL);
+		if (msgh != NULL)
+			break;
+		schedule_timeout(HZ / 2);
+	}
+
+	INIT_LIST_HEAD(&msgh->list);
+	memset(&msgh->body, 0, sizeof(msgh->body));
+
+	msg = &msgh->body;
+	msg->msg_pid		= current->pid;
+	msg->msg_type		= type;
+	msg->msg_size		= sizeof(msgh->body) + size;
+	msg->msg_seqnr		= seqno;
+	msg->msg_timestamp	= CURRENT_TIME.tv_sec;
+	msg->msg_arch		= AUDIT_ARCH;
+
+	msg->msg_audit_id	= pinfo? pinfo->audit_id : -1;
+	msg->msg_login_uid	= pinfo? pinfo->audit_uid : -1;
+	msg->msg_euid		= current->euid;
+	msg->msg_ruid		= current->uid;
+	msg->msg_suid		= current->suid;
+	msg->msg_fsuid		= current->fsuid;
+	msg->msg_egid		= current->egid;
+	msg->msg_rgid		= current->gid;
+	msg->msg_sgid		= current->sgid;
+	msg->msg_fsgid		= current->fsgid;
+
+	if (evname && *evname)
+		strncpy(msg->msg_evname, evname, sizeof(msg->msg_evname));
+
+	return msgh;
+}
+
+void
+audit_msg_insert(struct aud_msg_head *msgh)
+{
+	spin_lock(&audit_message_lock);
+	list_add_tail(&msgh->list, &audit_messages);
+	spin_unlock(&audit_message_lock);
+
+	/* Wake up the next reader in the queue */
+	wake_up(&audit_reader_wait);
+}
+
+int
+audit_msg_poll(struct file *file, struct poll_table_struct *wait)
+{
+	unsigned int ret = 0;
+
+	poll_wait(file, &audit_reader_wait, wait);
+
+	spin_lock(&audit_message_lock);
+	if (!list_empty(&audit_messages))
+		ret = 1;
+	spin_unlock(&audit_message_lock);
+
+	return (ret);
+}
+
+/*
+ * Get the next message from the queue
+ */
+struct aud_msg_head *
+audit_msg_get(int block, size_t max_len)
+{
+	struct aud_msg_head *msgh;
+	DECLARE_WAITQUEUE(wait, current);
+
+	/* Wait non-exclusively */
+	add_wait_queue(&audit_reader_wait, &wait);
+	spin_lock(&audit_message_lock);
+	while (1) {
+		msgh = list_empty(&audit_messages)
+		       ? ERR_PTR(-EAGAIN)
+		       : list_entry(audit_messages.next, struct aud_msg_head, list);
+		if (!IS_ERR(msgh)) {
+			if (max_len == 0 || msgh->body.msg_size < max_len) {
+				list_del_init(&msgh->list);
+				break;
+			}
+			msgh = ERR_PTR(-EAGAIN);
+		}
+
+		if (!block)
+			break;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_unlock(&audit_message_lock);
+		schedule();
+		spin_lock(&audit_message_lock);
+
+		msgh = ERR_PTR(-ERESTARTSYS);
+		if (signal_pending(current))
+			break;
+	}
+	spin_unlock(&audit_message_lock);
+
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&audit_reader_wait, &wait);
+
+	return msgh;
+}
+
+void
+audit_msg_release(struct aud_msg_head *msgh)
+{
+	spin_lock(&audit_message_lock);
+	if (msgh)
+		list_del(&msgh->list);
+
+	/* Wake up the next writer in the queue */
+	if (!__audit_wake_writer(0))
+		audit_message_count--;
+
+	spin_unlock(&audit_message_lock);
+
+
+	if (msgh)
+		kfree(msgh);
+}
+
+/*
+ * Send a login message
+ */
+int
+audit_msg_login(struct aud_process *pinfo, const char *evname,
+	       	const struct audit_login *login)
+{
+	struct aud_msg_head	*msgh;
+	struct aud_msg_login	*login_msg;
+
+	msgh = audit_msg_new(pinfo, AUDIT_MSG_LOGIN, evname,
+		       	sizeof(*login_msg));
+	if (IS_ERR(msgh))
+		return PTR_ERR(msgh);
+
+	login_msg = (struct aud_msg_login *) msgh->body.msg_data;
+	memset(login_msg, 0, sizeof(*login_msg));
+	login_msg->uid = login->uid;
+	memcpy(login_msg->hostname, login->hostname, sizeof(login->hostname));
+	memcpy(login_msg->address, login->address, sizeof(login->address));
+	memcpy(login_msg->terminal, login->terminal, sizeof(login->terminal));
+
+	/* fill in the executable name */
+	if (current->mm) {
+		struct vm_area_struct	*mmap;
+		struct file		*file;
+		char			*str;
+		int			len;
+
+		down_read(&current->mm->mmap_sem);
+		if ((mmap = current->mm->mmap)
+		 && (file = mmap->vm_file)
+		 && file->f_dentry) {
+			str = d_path(file->f_dentry, file->f_vfsmnt,
+					login_msg->executable,
+					sizeof(login_msg->executable));
+
+			if (str && str != login_msg->executable) {
+				len = strlen(str);
+				memmove(login_msg->executable, str, len+1);
+			}
+		}
+		up_read(&current->mm->mmap_sem);
+	}
+
+	audit_msg_insert(msgh);
+	return 0;
+}
+
+/*
+ * Send an exit event to user land
+ */
+int
+audit_msg_exit(struct aud_process *pinfo, const char *evname, long code)
+{
+	struct aud_msg_head	*msgh;
+	struct aud_msg_exit	*exit_msg;
+
+	msgh = audit_msg_new(pinfo, AUDIT_MSG_EXIT,
+		       		evname, sizeof(*exit_msg));
+	if (IS_ERR(msgh))
+		return PTR_ERR(msgh);
+
+	exit_msg = (struct aud_msg_exit *) msgh->body.msg_data;
+	exit_msg->code = code;
+
+	audit_msg_insert(msgh);
+	return 0;
+}
+
+/*
+ * Log a system call, along with all arguments
+ */
+int
+audit_msg_syscall(struct aud_process *pinfo,
+                  const char *evname,
+                  struct aud_syscall_data *syscall)
+{
+	struct aud_msg_head	*msgh;
+	struct aud_msg_syscall	*syscall_msg;
+	int			len;
+
+	DPRINTF("called, syscall %d/%d, pid %d\n",
+		 syscall->major, syscall->minor, current->pid);
+
+	len = audit_encode_args(NULL, 0, syscall);
+	if (len < 0)
+		return len;
+
+	/* Allocate aud_process with message buffer and
+	 * additional space for arguments. */
+	msgh = audit_msg_new(pinfo, AUDIT_MSG_SYSCALL,
+				evname, sizeof(*syscall_msg)+len);
+	if (IS_ERR(msgh)) {
+		DPRINTF("audit_msg_new failed, err=%ld\n", PTR_ERR(msgh));
+		return PTR_ERR(msgh);
+	}
+
+	msgh->body.msg_arch = syscall->arch;
+	syscall_msg = (struct aud_msg_syscall *) msgh->body.msg_data;
+	syscall_msg->personality = syscall->personality;
+	syscall_msg->major = syscall->major;
+	syscall_msg->minor = syscall->minor;
+	syscall_msg->result = syscall->result;
+	syscall_msg->length = len;
+
+	/* Encode arguments now */
+	len = audit_encode_args(syscall_msg->data, len, syscall);
+	if (len < 0) {
+		DPRINTF("Failed to encode args (pass #2, err=%d)\n", len);
+		audit_msg_release(msgh);
+		return len;
+	}
+
+	audit_msg_insert(msgh);
+	return 0;
+}
+
+/*
+ * Log an rtnetlink call
+ */
+int
+audit_msg_netlink(struct aud_process *pinfo, const char *evname,
+	       		const struct sk_buff *skb, int result)
+{
+	struct aud_msg_head	*msgh;
+	struct aud_msg_netlink	*netlink_msg;
+	unsigned int		len;
+
+	DPRINTF("called.\n");
+
+	len = skb->len;
+	msgh = audit_msg_new(pinfo, AUDIT_MSG_NETLINK, evname,
+				sizeof(*netlink_msg) + len);
+	if (IS_ERR(msgh)) {
+		DPRINTF("audit_msg_new failed, err=%ld\n", PTR_ERR(msgh));
+		return PTR_ERR(msgh);
+	}
+
+	netlink_msg = (struct aud_msg_netlink *) msgh->body.msg_data;
+	skb_copy_bits(skb, 0, netlink_msg->data, len);
+	netlink_msg->groups = NETLINK_CB(skb).groups;
+	netlink_msg->dst_groups = NETLINK_CB(skb).dst_groups;
+	netlink_msg->result = result;
+	netlink_msg->length = len;
+
+	audit_msg_insert(msgh);
+	return 0;
+}
diff -urNp linux-2.6.5/drivers/audit/stubs.c linux-2.6.5.SUSE/drivers/audit/stubs.c
--- linux-2.6.5/drivers/audit/stubs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/stubs.c	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,131 @@
+/*
+ * Audit subsystem module hooks
+ *
+ * Copyright (C) 2003, SuSE Linux AG
+ * Written by okir@suse.de
+ */
+
+#define __NO_VERSION__
+#define DONT_DEBUG_LOCKS
+#include "audit-private.h"
+
+struct aud_process *audit_alloc(void)
+{
+	struct aud_process *pinfo = kmalloc(sizeof(*pinfo), GFP_KERNEL);
+
+	if (pinfo) {
+		memset(pinfo, 0, sizeof(*pinfo));
+		pinfo->audit_uid = (uid_t) -1;
+		pinfo->suspended = 1;
+	}
+	return pinfo;
+}
+
+#ifdef CONFIG_AUDIT_MODULE
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/wait.h>
+#include <linux/sys.h>
+#include <asm/semaphore.h>
+
+EXPORT_SYMBOL(audit_alloc);
+
+static struct audit_hooks audit;
+static DECLARE_RWSEM(hook_lock);
+
+int
+audit_register(const struct audit_hooks *hooks)
+{
+	int	res = 0;
+
+	if (!hooks->intercept
+	 || !hooks->result
+	 || !hooks->fork
+	 || !hooks->exit)
+		return -EINVAL;
+
+	down_write(&hook_lock);
+	if (audit.intercept) {
+		res = -EEXIST;
+	} else {
+		audit = *hooks;
+	}
+	mb();
+	up_write(&hook_lock);
+
+	return res;
+}
+
+EXPORT_SYMBOL(audit_register);
+
+void
+audit_unregister(void)
+{
+	down_write(&hook_lock);
+	memset(&audit, 0, sizeof(audit));
+	mb();
+	up_write(&hook_lock);
+}
+
+EXPORT_SYMBOL(audit_unregister);
+
+void
+audit_intercept(enum audit_call code, ...)
+{
+	int res = 0;
+
+	down_read(&hook_lock);
+	if (audit.intercept) {
+		va_list varg;
+
+		va_start(varg, code);
+		res = audit.intercept(code, varg);
+	}
+	up_read(&hook_lock);
+	if (res < 0)
+		audit_kill_process(res);
+}
+
+long
+audit_lresult(long result)
+{
+	down_read(&hook_lock);
+	if (audit.result)
+		result = audit.result(result);
+	up_read(&hook_lock);
+	return result;
+}
+
+void
+audit_fork(struct task_struct *parent, struct task_struct *child)
+{
+	down_read(&hook_lock);
+	if (audit.fork)
+		audit.fork(parent, child);
+	up_read(&hook_lock);
+}
+
+void
+audit_exit(struct task_struct *task, long code)
+{
+	down_read(&hook_lock);
+	if (audit.exit)
+		audit.exit(task, code);
+	up_read(&hook_lock);
+}
+
+void
+audit_netlink_msg(struct sk_buff *skb, int res)
+{
+	down_read(&hook_lock);
+	if (audit.netlink_msg)
+		audit.netlink_msg(skb, res);
+	up_read(&hook_lock);
+}
+
+#endif /* CONFIG_AUDIT_MODULE */
diff -urNp linux-2.6.5/drivers/audit/syscall.c linux-2.6.5.SUSE/drivers/audit/syscall.c
--- linux-2.6.5/drivers/audit/syscall.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/syscall.c	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,626 @@
+/*
+ * syscall.c
+ *
+ * Common system call information for the audit daemon.
+ *
+ * Copyright (C) 2003 SuSE Linux AG
+ * Written by okir@suse.de.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include "audit-private.h"
+
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/fshooks.h>
+#include <linux/wait.h>
+#include <linux/sys.h>
+#include <linux/utsname.h>
+#include <linux/sysctl.h>
+#include <linux/sockios.h>
+#include <linux/if.h>
+#include <linux/if_arp.h>
+#include <linux/if_frad.h>
+#include <linux/route.h>
+
+#include <asm/uaccess.h>
+#include <asm/semaphore.h>
+
+static int		audit_get_ioctlargs(struct aud_syscall_data *);
+
+#define MAX_SOCKETCALL	20
+#define MAX_IPCCALL	24
+
+/*
+ * Maximum of bytes we copy when logging ioctl's third argument
+ */
+#define MAX_IOCTL_COPY	256
+
+#define T_void		{ AUDIT_ARG_END }
+#define T_immediate(T)	{ AUDIT_ARG_IMMEDIATE, sizeof(T), .sa_flags = (T)-1 < 0 ? AUD_ARG_SIGNED : 0 }
+#define T_pointer(T)	{ AUDIT_ARG_POINTER, sizeof(T) }
+#define T_pointer_rw(T)	{ AUDIT_ARG_POINTER, sizeof(T), .sa_flags = AUD_ARG_INOUT }
+#define T_string	{ AUDIT_ARG_STRING }
+#define U_string	{ AUDIT_ARG_STRING, .sa_flags = AUD_ARG_USER }
+#define T_path		{ AUDIT_ARG_PATH }
+#define T_path_parent	{ AUDIT_ARG_PATH, .sa_flags = AUD_ARG_DIRNAME }
+#define T_filedesc	{ AUDIT_ARG_FILEDESC }
+#define T_int		T_immediate(int)
+#define T_uint		T_immediate(unsigned int)
+#define T_long		T_immediate(long)
+#define T_ulong		T_immediate(unsigned long)
+#define T_loff_t	T_immediate(loff_t)
+#define T_mode_t	T_immediate(mode_t)
+#define T_size_t	T_immediate(size_t)
+#define T_dev_t		T_immediate(dev_t)
+#define T_pid_t		T_immediate(pid_t)
+#define T_uid_t		T_immediate(uid_t)
+#define T_gid_t		T_immediate(gid_t)
+#define T_s32_t		T_immediate(int32_t)
+#define T_u32_t		T_immediate(uint32_t)
+#define T_s64_t		T_immediate(int64_t)
+#define T_u64_t		T_immediate(uint64_t)
+#define T_any_ptr	{ AUDIT_ARG_POINTER, 0 }
+#define U_any_ptr	{ AUDIT_ARG_POINTER, 0, .sa_flags = AUD_ARG_USER }
+#define socklen_t	uint32_t	/* socklen_t is a user land thing */
+#define T_socklen_t	T_immediate(socklen_t)
+#define T_array(itype, index, max) \
+			{ AUDIT_ARG_ARRAY, sizeof(itype), index, max }
+#define U_array(itype, index, max) \
+			{ AUDIT_ARG_ARRAY, sizeof(itype), index, max, .sa_flags = AUD_ARG_USER }
+#define T_opaque_t(idx)	{ AUDIT_ARG_ARRAY, 1, idx, 256 }
+#define U_argv		{ AUDIT_ARG_VECTOR, sizeof(char *), .sa_ref = AUDIT_ARG_STRING, .sa_flags = AUD_ARG_USER }
+#define T_group_info	{ AUDIT_ARG_GROUP_INFO }
+#define T_ipc_msg	{ AUDIT_ARG_IPC_MSG }
+
+/*
+ * Note - using [__NR_xxx] to initialize the array makes us more
+ * hardware independent. Platform specific syscalls can easily
+ * be included in #ifdef __NR_foobar/#endif.
+ * The only remaining problem is platforms with more than one
+ * exec domain by default.
+ */
+#define f(name, args...) [AUDIT_##name] = { 0, { args, { AUDIT_ARG_END } } }
+
+static struct sysent linux_sysent[audit_NUM_CALLS] = {
+f(clone,	T_uint),
+f(execve,	T_path, U_argv, U_any_ptr),
+f(ptrace,	T_uint, T_pid_t, U_any_ptr, U_any_ptr),
+f(kill,		T_pid_t, T_int),
+f(tkill,	T_pid_t, T_int),
+f(tgkill,	T_pid_t, T_pid_t, T_int),
+
+/*
+ * Calls related to process privilege
+ */
+f(setuid,	T_uid_t),
+f(setgid,	T_gid_t),
+f(setreuid,	T_uid_t, T_uid_t),
+f(setregid,	T_gid_t, T_gid_t),
+f(setresuid,	T_uid_t, T_uid_t, T_uid_t),
+f(setresgid,	T_gid_t, T_gid_t, T_gid_t),
+f(setfsuid,	T_uid_t),
+f(setfsgid,	T_gid_t),
+f(setgroups,	T_group_info),
+f(capset,	T_u32_t, T_pid_t, T_pointer(kernel_cap_t), T_pointer(kernel_cap_t), T_pointer(kernel_cap_t)),
+
+/*
+ * Other per-process state
+ */
+f(umask,	T_mode_t),
+f(chroot,	T_path),
+f(chdir,	T_path),
+f(fchdir,	T_filedesc),
+f(setrlimit,	T_uint, T_pointer(struct rlimit)),
+f(setpriority,	T_int, T_int, T_int),
+f(setpgid,	T_pid_t, T_pid_t),
+f(setsid,	T_void),
+
+/*
+ * Calls related to global machine state
+ */
+f(settimeofday,	T_pointer(struct timespec), T_pointer(struct timezone)),
+f(adjtimex,	T_pointer_rw(struct timex)),
+f(sethostname,	T_array(char, 1, __NEW_UTS_LEN), T_size_t),
+f(setdomainname, T_array(char, 1, __NEW_UTS_LEN), T_size_t),
+f(reboot,	T_int, T_int, T_uint, T_any_ptr),
+f(init_module,	T_any_ptr, T_ulong, U_string),
+f(delete_module, T_string),
+f(mount,	T_string, T_path, T_string, T_ulong, T_any_ptr),
+f(umount,	T_path, T_int),
+f(swapon,	T_path, T_int),
+f(swapoff,	T_path),
+f(ioperm,	T_ulong, T_ulong, T_int),
+f(iopl,		T_uint),
+f(syslog,	T_int, U_any_ptr, T_int),
+f(acct,	T_path),
+f(quotactl,	T_uint, T_string, T_immediate(qid_t), U_any_ptr),
+
+/*
+ * File system operations
+ */
+f(open,		T_path, T_int, T_mode_t),
+f(access,	T_path, T_int),
+f(mkdir,	T_path_parent, T_mode_t),
+f(mknod,	T_path_parent, T_mode_t, T_dev_t),
+f(link,		T_path, T_path_parent),
+f(symlink,	T_string, T_path_parent),
+f(rename,	T_path_parent, T_path_parent),
+f(unlink,	T_path_parent),
+f(rmdir,	T_path_parent),
+f(utimes,	T_path, T_pointer(struct timeval), T_pointer(struct timeval)),
+f(chmod,	T_path, T_mode_t),
+f(chown,	T_path, T_uid_t, T_gid_t),
+f(lchmod,	T_path_parent, T_mode_t),
+f(lchown,	T_path_parent, T_uid_t, T_gid_t),
+f(fchmod,	T_filedesc, T_mode_t),
+f(fchown,	T_filedesc, T_uid_t, T_gid_t),
+f(truncate,	T_path, T_loff_t),
+f(ftruncate,	T_filedesc, T_loff_t),
+f(setxattr,	T_path, U_string, U_array(char, 3, 2046), T_size_t, T_int),
+f(lsetxattr,	T_path_parent, U_string, U_array(char, 3, 2046), T_size_t, T_int),
+f(fsetxattr,	T_filedesc, U_string, U_array(char, 3, 2046), T_size_t, T_int),
+f(removexattr,	T_path, U_string),
+f(lremovexattr,	T_path_parent, U_string),
+f(fremovexattr,	T_filedesc, U_string),
+
+/*
+ * Network stuff
+ */
+f(bind,		T_filedesc, T_opaque_t(2), T_socklen_t),
+f(socket,	T_int, T_int, T_int),
+
+/*
+ * SysV IPC
+ */
+f(shmget,	T_int, T_int, T_int),
+f(shmat,	T_int, U_any_ptr, T_int),
+f(shmdt,	U_any_ptr),
+f(shmctl,	T_int, T_int, U_any_ptr),
+f(semget,	T_int, T_int, T_int),
+f(semop,	T_int, T_array(struct sembuf, 2, SEMOPM), T_uint),
+f(semtimedop,	T_int, T_array(struct sembuf, 2, SEMOPM), T_uint, T_pointer(struct timespec)),
+f(semctl,	T_int, T_int, T_int, U_any_ptr),
+f(msgget,	T_int, T_int),
+f(msgsnd,	T_int, T_ipc_msg, T_size_t, T_int),
+f(msgrcv,	T_int, U_any_ptr, T_size_t, T_long, T_int),
+f(msgctl,	T_int, T_int, U_any_ptr),
+
+/*
+ * ioctl.
+ * The third ioctl argument is frobbed in audit_get_ioctlargs below
+ */
+f(ioctl,	T_filedesc, T_uint, U_any_ptr),
+
+};
+
+static int
+audit_fshook_pre(fshook_info_t info, void *ctx)
+{
+	if (!AUDITING(current))
+		return 0;
+
+	switch(info.gen->type) {
+	case FSHOOK_access:
+		audit_intercept(AUDIT_access, info.access->path, info.access->mode);
+		break;
+	case FSHOOK_chdir:
+		audit_intercept(AUDIT_chdir, info.chdir->dirname);
+		break;
+	case FSHOOK_chmod:
+		audit_intercept(info.chmod->link ? AUDIT_lchmod : AUDIT_chmod,
+			info.chmod->path,
+			info.chmod->mode);
+		break;
+	case FSHOOK_chown:
+		audit_intercept(info.chown->link ? AUDIT_lchown : AUDIT_chown,
+			info.chown->path,
+			info.chown->uid,
+			info.chown->gid);
+		break;
+	case FSHOOK_chroot:
+		audit_intercept(AUDIT_chroot, info.chroot->path);
+		break;
+	case FSHOOK_fchdir:
+		audit_intercept(AUDIT_fchdir, info.fchdir->fd);
+		break;
+	case FSHOOK_fchmod:
+		audit_intercept(AUDIT_fchmod, info.fchmod->fd, info.fchmod->mode);
+		break;
+	case FSHOOK_fchown:
+		audit_intercept(AUDIT_fchown, info.fchown->fd, info.fchown->uid, info.fchown->gid);
+		break;
+	case FSHOOK_frmxattr:
+		audit_intercept(AUDIT_fremovexattr, info.frmxattr->fd, info.frmxattr->name);
+		break;
+	case FSHOOK_fsetxattr:
+		audit_intercept(AUDIT_fsetxattr,
+			info.fsetxattr->fd,
+			info.fsetxattr->name,
+			info.fsetxattr->value,
+			info.fsetxattr->size,
+			info.fsetxattr->flags);
+		break;
+	case FSHOOK_ftruncate:
+		audit_intercept(AUDIT_ftruncate, info.ftruncate->fd, info.ftruncate->length);
+		break;
+	case FSHOOK_ioctl:
+		audit_intercept(AUDIT_ioctl, info.ioctl->fd, info.ioctl->cmd, info.ioctl->arg.ptr);
+		break;
+	case FSHOOK_link:
+		audit_intercept(AUDIT_link, info.link->oldpath, info.link->newpath);
+		break;
+	case FSHOOK_mkdir:
+		audit_intercept(AUDIT_mkdir, info.mkdir->dirname);
+		break;
+	case FSHOOK_mknod:
+		audit_intercept(AUDIT_mknod, info.mknod->path, info.mknod->mode, info.mknod->dev);
+		break;
+	case FSHOOK_mount:
+		audit_intercept(AUDIT_mount,
+			info.mount->devname,
+			info.mount->dirname,
+			info.mount->type,
+			info.mount->flags,
+			info.mount->data);
+		break;
+	case FSHOOK_open:
+		audit_intercept(AUDIT_open, info.open->filename, info.open->flags, info.open->mode);
+		break;
+	case FSHOOK_rename:
+		audit_intercept(AUDIT_rename, info.rename->oldpath, info.rename->newpath);
+		break;
+	case FSHOOK_rmdir:
+		audit_intercept(AUDIT_rmdir, info.rmdir->dirname);
+		break;
+	case FSHOOK_rmxattr:
+		audit_intercept(info.rmxattr->link ? AUDIT_lremovexattr : AUDIT_removexattr,
+			info.rmxattr->path,
+			info.rmxattr->name);
+		break;
+	case FSHOOK_setxattr:
+		audit_intercept(info.setxattr->link ? AUDIT_lsetxattr : AUDIT_setxattr,
+			info.setxattr->path,
+			info.setxattr->name,
+			info.setxattr->value,
+			info.setxattr->size,
+			info.setxattr->flags);
+		break;
+	case FSHOOK_symlink:
+		audit_intercept(AUDIT_symlink, info.symlink->oldpath, info.symlink->newpath);
+		break;
+	case FSHOOK_truncate:
+		audit_intercept(AUDIT_truncate, info.truncate->filename, info.truncate->length);
+		break;
+	case FSHOOK_umount:
+		audit_intercept(AUDIT_umount, info.umount->dirname, info.umount->flags);
+		break;
+	case FSHOOK_unlink:
+		audit_intercept(AUDIT_unlink, info.unlink->filename);
+		break;
+	case FSHOOK_utimes:
+		audit_intercept(AUDIT_utimes, info.utimes->path, info.utimes->atime, info.utimes->mtime);
+		break;
+/*
+	case FSHOOK_:
+		audit_intercept(AUDIT_, info.->, info.->, info.->);
+		break;
+*/
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void
+audit_fshook_post(fshook_info_t info, void *ctx)
+{
+	if (AUDITING(current))
+		audit_result(info.gen->result);
+}
+
+int
+audit_fshook_adjust(enum audit_call code, signed adjust)
+{
+#define AUDIT_rmxattr AUDIT_removexattr
+#define AUDIT_frmxattr AUDIT_fremovexattr
+#define AUDIT_lrmxattr AUDIT_lremovexattr
+	static struct hookXlat {
+		enum { invalid = -1, unhooked, hooked, failed, link } state:8;
+		unsigned count:8;
+		enum FShook hook:16;
+	} hookXlat[audit_NUM_CALLS] = {
+		[0 ... (audit_NUM_CALLS - 1)] = { invalid },
+#define HOOK(name) [AUDIT_##name] = { .state = unhooked, .hook = FSHOOK_##name }
+#define LINK(name) HOOK(name), [AUDIT_l##name] = { .state = link, .hook = AUDIT_##name }
+		HOOK(access),
+		HOOK(chdir),
+		LINK(chmod),
+		LINK(chown),
+		HOOK(chroot),
+		HOOK(fchdir),
+		HOOK(fchmod),
+		HOOK(fchown),
+		HOOK(frmxattr),
+		HOOK(fsetxattr),
+		HOOK(ftruncate),
+		HOOK(ioctl),
+		HOOK(link),
+		HOOK(mkdir),
+		HOOK(mknod),
+		HOOK(mount),
+		HOOK(rename),
+		HOOK(rmdir),
+		LINK(rmxattr),
+		LINK(setxattr),
+		HOOK(symlink),
+		HOOK(open),
+		HOOK(umount),
+		HOOK(unlink),
+		HOOK(utimes),
+		HOOK(truncate)
+#undef LINK
+#undef HOOK
+	};
+#undef AUDIT_lrmxattr
+#undef AUDIT_frmxattr
+#undef AUDIT_rmxattr
+	struct hookXlat *xlat = hookXlat + code;
+	int err = 0;
+
+	if (code < 0 || code >= audit_NUM_CALLS)
+		return -EINVAL;
+	if (xlat->state == link) {
+		xlat = hookXlat + xlat->hook;
+		BUG_ON(xlat->state == link);
+	}
+	if (xlat->state == invalid)
+		return 0;
+	switch (adjust) {
+	case -1:
+		if (unlikely(!xlat->count))
+			err = -EPERM;
+		else if (!--xlat->count) {
+			if (xlat->state == hooked) {
+				err = fshook_deregister(xlat->hook, audit_fshook_pre, audit_fshook_post, NULL);
+				if (unlikely(err))
+					printk(KERN_ERR "audit: unable to de-register fshook %u\n", xlat->hook);
+				else {
+					DPRINTF("de-registered fshook %u\n", xlat->hook);
+					xlat->state = unhooked;
+				}
+			}
+			else
+				xlat->state = unhooked;
+		}
+		break;
+	case 0:
+		if (xlat->state != failed)
+			break;
+		BUG_ON(!xlat->count);
+	case 1:
+		if (xlat->state != hooked) {
+			err = fshook_register(xlat->hook, audit_fshook_pre, audit_fshook_post, NULL);
+			if (unlikely(err)) {
+				printk(KERN_ERR "audit: unable to register fshook %u\n", xlat->hook);
+				xlat->state = failed;
+			}
+			else {
+				DPRINTF("registered fshook %u\n", xlat->hook);
+				xlat->state = hooked;
+			}
+		}
+		xlat->count += adjust;
+		BUG_ON(!xlat->count);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	return err;
+}
+
+/*
+ * Initialize system call handling
+ */
+void
+audit_init_syscalls(void)
+{
+	unsigned int m, n;
+
+	/* Loop over list of syscalls and fill in the number of
+	 * arguments */
+	for (m = 0; m < audit_NUM_CALLS; m++) {
+		struct sysent *entry = &linux_sysent[m];
+
+		for (n = 0; n < AUDIT_MAXARGS; n++) {
+			if (entry->sy_args[n].sa_type == AUDIT_ARG_END)
+				break;
+		}
+		entry->sy_narg = n;
+	}
+}
+
+/*
+ * Get syscall arguments
+ */
+int
+audit_get_args(enum audit_call code, va_list varg, struct aud_syscall_data *sc)
+{
+	const struct sysent *entry;
+	unsigned i;
+
+	if (code < 0 || code >= audit_NUM_CALLS)
+		return -ENOSYS;
+
+	sc->entry = entry = linux_sysent + (sc->major = code);
+	for (i = 0; i < entry->sy_narg; ++i) {
+#ifndef __ILP64__
+		typedef char assert_int_32bits[(int)sizeof(int) - 4];
+#else
+		typedef char assert_int_64bits[(int)sizeof(int) - 8];
+#endif
+
+		switch(entry->sy_args[i].sa_type) {
+		case AUDIT_ARG_IMMEDIATE:
+			if (unlikely(entry->sy_args[i].sa_size <= 0)) {
+				printk(KERN_ERR "audit: internal inconsistency: immediate argument of non-positive size\n");
+				return -ENODATA;
+			}
+			if (entry->sy_args[i].sa_size < sizeof(int)) {
+		case AUDIT_ARG_FILEDESC:
+				sc->raw_args[i] = va_arg(varg, int);
+				continue;
+			}
+			if (entry->sy_args[i].sa_flags & AUD_ARG_SIGNED) {
+				switch (entry->sy_args[i].sa_size) {
+				case sizeof(int):
+					sc->raw_args[i] = va_arg(varg, int);
+					continue;
+#ifndef __ILP64__
+				case sizeof(int64_t):
+					sc->raw_args[i] = va_arg(varg, int64_t);
+					continue;
+#endif
+				}
+			}
+			else {
+				switch (entry->sy_args[i].sa_size) {
+				case sizeof(unsigned int):
+					sc->raw_args[i] = va_arg(varg, unsigned int);
+					continue;
+#ifndef __ILP64__
+				case sizeof(uint64_t):
+					sc->raw_args[i] = va_arg(varg, uint64_t);
+					continue;
+#endif
+				}
+			}
+			printk(KERN_ERR "audit: internal inconsistency: argument of size %zu\n", entry->sy_args[i].sa_size);
+			return -ENODATA;
+		case AUDIT_ARG_POINTER:
+		case AUDIT_ARG_STRING:
+		case AUDIT_ARG_PATH:
+		case AUDIT_ARG_ARRAY:
+		case AUDIT_ARG_VECTOR:
+		case AUDIT_ARG_GROUP_INFO:
+		case AUDIT_ARG_IPC_MSG:
+			sc->raw_args[i] = (unsigned long)va_arg(varg, void *);
+			continue;
+		}
+		printk(KERN_ERR "audit: internal inconsistency: argument of type %u\n", entry->sy_args[i].sa_type);
+		return -EINVAL;
+	}
+
+	return code != AUDIT_ioctl ? 0 : audit_get_ioctlargs(sc);
+}
+
+/*
+ * Get ioctl arguments (well, basically we want the third argument's size,
+ * and whether it's a read or write ioctl
+ */
+static const struct ioctl_info {
+	unsigned		cmd;
+	size_t		size;
+} ioctl_info[] = {
+      { SIOCSIFNAME,		sizeof(struct ifreq) },
+
+      { SIOCSIFFLAGS,		sizeof(struct ifreq) },
+      { SIOCSIFADDR,		sizeof(struct ifreq) },
+      { SIOCSIFDSTADDR,		sizeof(struct ifreq) },
+      { SIOCSIFBRDADDR,		sizeof(struct ifreq) },
+      { SIOCSIFNETMASK,		sizeof(struct ifreq) },
+      { SIOCSIFMETRIC,		sizeof(struct ifreq) },
+      { SIOCSIFMTU,		sizeof(struct ifreq) },
+      { SIOCADDMULTI,		sizeof(struct ifreq) },
+      { SIOCDELMULTI,		sizeof(struct ifreq) },
+      { SIOCADDRT,		sizeof(struct rtentry) },
+      { SIOCDELRT,		sizeof(struct rtentry) },
+
+      { SIOCSIFHWADDR,		sizeof(struct ifreq) },
+#ifdef SIOCSIFHWBROADCAST
+      { SIOCSIFHWBROADCAST,	sizeof(struct ifreq) },
+#endif
+      { SIOCSIFMAP,		sizeof(struct ifreq) },
+      { SIOCSIFMEM,		sizeof(struct ifreq) },
+      { SIOCSIFENCAP,		sizeof(struct ifreq) },
+      { SIOCSIFSLAVE,		sizeof(struct ifreq) },
+      { SIOCSIFPFLAGS,		sizeof(struct ifreq) },
+      { SIOCDIFADDR,		sizeof(struct ifreq) },
+      { SIOCSIFBR,		3 * sizeof(long) },
+      { SIOCGIFBR,		3 * sizeof(long) },
+
+      { SIOCSARP,		sizeof(struct arpreq) },
+      { SIOCDARP,		sizeof(struct arpreq) },
+
+      /* SIOCDRARP, SIOCSRARP obsolete */
+#ifdef CONFIG_DLCI
+      { SIOCADDDLCI,		sizeof(struct dlci_add) },
+      { SIOCDELDLCI,		sizeof(struct dlci_add) },
+#endif
+
+      /* SIOCSIFLINK obsolete? */
+      { SIOCSIFLINK,		0 },
+      { SIOCSIFTXQLEN,		sizeof(struct ifreq) },
+      { SIOCBONDENSLAVE,	sizeof(struct ifreq) },
+      { SIOCBONDRELEASE,	sizeof(struct ifreq) },
+      { SIOCBONDSETHWADDR,	sizeof(struct ifreq) },
+      { SIOCBONDCHANGEACTIVE,	sizeof(struct ifreq) },
+      { SIOCETHTOOL,		sizeof(struct ifreq) },
+      { SIOCSMIIREG,		sizeof(struct ifreq) },
+};
+
+int
+audit_get_ioctlargs(struct aud_syscall_data *sc)
+{
+	const struct ioctl_info	*iop;
+	unsigned			cmd;
+	void			*arg, *p;
+	size_t			len = 0;
+
+	cmd = sc->raw_args[1];
+	arg = (void *) (unsigned long) sc->raw_args[2];
+
+	if (arg == NULL)
+		return 0;
+
+	for (iop = ioctl_info; iop < ioctl_info + ARRAY_SIZE(ioctl_info); iop++) {
+		if (iop->cmd == cmd) {
+			len = iop->size;
+			break;
+		}
+	}
+
+	if (len == 0 && (_IOC_DIR(cmd) & _IOC_WRITE)) 
+		len = _IOC_SIZE(cmd);
+
+	if (len > 0 && len < MAX_IOCTL_COPY) {
+		struct sysarg_data	*tgt = &sc->args[2];
+
+		if ((p = kmalloc(len, GFP_USER)) == NULL)
+			return -ENOBUFS;
+		if (copy_from_user(p, arg, len)) {
+			kfree(p);
+			return -EFAULT;
+		}
+		tgt->at_type = AUDIT_ARG_POINTER;
+		tgt->at_data.ptr = p;
+		tgt->at_data.len = len;
+	}
+	return 0;
+}
diff -urNp linux-2.6.5/drivers/audit/sysctl.c linux-2.6.5.SUSE/drivers/audit/sysctl.c
--- linux-2.6.5/drivers/audit/sysctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/drivers/audit/sysctl.c	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,82 @@
+/*
+ * sysctl.c
+ *
+ * Linux Audit Subsystem, handle sysctl's.
+ *
+ * Copyright (C) 2003 SuSE Linux AG
+ *
+ * Written by okir@suse.de, based on ideas from systrace, by
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/fs.h>
+#include <linux/sysctl.h>
+#include <linux/audit.h>
+
+#include "audit-private.h"
+
+static ctl_table	audit_table[] = {
+	{ 1, "attach-all",
+	  &audit_all_processes,
+	  sizeof(audit_all_processes),
+	  0600, NULL, &proc_dointvec, NULL, },
+	{ 2, "allow-suspend",
+	  &audit_allow_suspend,
+	  sizeof(audit_allow_suspend),
+	  0600, NULL,  &proc_dointvec, NULL, },
+	{ 3, "max-messages",
+	  &audit_max_messages,
+	  sizeof(audit_max_messages),
+	  0600, NULL,  &proc_dointvec, NULL, },
+	{ 4, "paranoia",
+	  &audit_paranoia,
+	  sizeof(audit_paranoia),
+	  0600, NULL,  &proc_dointvec, NULL, },
+	{ 5, "debug",
+	  &audit_debug,
+	  sizeof(audit_debug),
+	  0600, NULL,  &proc_dointvec, NULL, },
+	{ 0 },
+};
+
+static ctl_table	audit_root[] = {
+	{ 1, "audit", NULL, 0, 0555, audit_table },
+	{ 0 }
+};
+
+static ctl_table	dev_root[] = {
+	{ CTL_KERN, "dev", NULL, 0, 0555, audit_root },
+	{ 0 }
+};
+
+static struct ctl_table_header *	sysctl_header = NULL;
+
+int
+audit_sysctl_register(void)
+{
+	sysctl_header = register_sysctl_table(dev_root, 0);
+	return 0;
+}
+
+void
+audit_sysctl_unregister(void)
+{
+	if (sysctl_header)
+		unregister_sysctl_table(sysctl_header);
+	sysctl_header = NULL;
+}
diff -urNp linux-2.6.5/fs/compat.c linux-2.6.5.SUSE/fs/compat.c
--- linux-2.6.5/fs/compat.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/fs/compat.c	2004-04-22 16:11:15.000000000 +0200
@@ -35,6 +35,7 @@
 #include <linux/syscalls.h>
 #include <linux/ctype.h>
 #include <linux/module.h>
+#include <linux/audit.h>
 #include <net/sock.h>		/* siocdevprivate_ioctl */
 
 #include <asm/uaccess.h>
@@ -425,8 +426,11 @@ asmlinkage long compat_sys_ioctl(unsigne
 	struct ioctl_trans *t;
 
 	filp = fget(fd);
-	if(!filp)
+	if(!filp) {
+		audit_intercept(AUDIT_ioctl, fd, cmd, arg);
+		(void)audit_result(error);
 		goto out2;
+	}
 
 	if (!filp->f_op || !filp->f_op->ioctl) {
 		error = sys_ioctl (fd, cmd, arg);
@@ -448,6 +452,7 @@ asmlinkage long compat_sys_ioctl(unsigne
 		error = siocdevprivate_ioctl(fd, cmd, arg);
 	} else {
 		static int count;
+		audit_intercept(AUDIT_ioctl, fd, cmd, arg);
 		if (++count <= 50) { 
 			char buf[10];
 			char *path = (char *)__get_free_page(GFP_KERNEL), *fn = "?"; 
@@ -469,7 +474,7 @@ asmlinkage long compat_sys_ioctl(unsigne
 			if (path) 
 				free_page((unsigned long)path); 
 		}
-		error = -EINVAL;
+		error = audit_result(-EINVAL);
 	}
 out:
 	fput(filp);
diff -urNp linux-2.6.5/fs/exec.c linux-2.6.5.SUSE/fs/exec.c
--- linux-2.6.5/fs/exec.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/fs/exec.c	2004-04-22 16:11:15.000000000 +0200
@@ -48,6 +48,7 @@
 #include <linux/syscalls.h>
 #include <linux/objrmap.h>
 #include <linux/ckrm.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -1118,9 +1119,12 @@ int do_execve(char * filename,
 
 	file = open_exec(filename);
 
+	/* don't do this prior to open_exec, as that will invoke an FS hook */
+	audit_intercept(AUDIT_execve, filename, argv, envp);
+
 	retval = PTR_ERR(file);
 	if (IS_ERR(file))
-		return retval;
+		return audit_result(retval);
 
 	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
 	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0]));
@@ -1178,7 +1182,7 @@ int do_execve(char * filename,
 
 		/* execve success */
 		security_bprm_free(&bprm);
-		return retval;
+		return audit_result(retval);
 	}
 
 out:
@@ -1201,7 +1205,7 @@ out_file:
 		allow_write_access(bprm.file);
 		fput(bprm.file);
 	}
-	return retval;
+	return audit_result(retval);
 }
 
 EXPORT_SYMBOL(do_execve);
diff -urNp linux-2.6.5/fs/quota.c linux-2.6.5.SUSE/fs/quota.c
--- linux-2.6.5/fs/quota.c	2004-04-04 05:38:20.000000000 +0200
+++ linux-2.6.5.SUSE/fs/quota.c	2004-04-22 16:11:15.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/smp_lock.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 
 /* Check validity of quotactl */
 static int check_quotactl_valid(struct super_block *sb, int type, int cmd, qid_t id)
@@ -268,8 +269,8 @@ asmlinkage long sys_quotactl(unsigned in
 	uint cmds, type;
 	struct super_block *sb = NULL;
 	struct block_device *bdev;
-	char *tmp;
-	int ret;
+	char *tmp = NULL;
+	int ret = 0;
 
 	cmds = cmd >> SUBCMDSHIFT;
 	type = cmd & SUBCMDMASK;
@@ -279,20 +280,29 @@ asmlinkage long sys_quotactl(unsigned in
 		if (IS_ERR(tmp))
 			return PTR_ERR(tmp);
 		bdev = lookup_bdev(tmp);
-		putname(tmp);
 		if (IS_ERR(bdev))
-			return PTR_ERR(bdev);
-		sb = get_super(bdev);
-		bdput(bdev);
-		if (!sb)
-			return -ENODEV;
+			ret = PTR_ERR(bdev);
+		else {
+			sb = get_super(bdev);
+			bdput(bdev);
+			if (!sb)
+				ret = -ENODEV;
+		}
 	}
 
-	ret = check_quotactl_valid(sb, type, cmds, id);
-	if (ret >= 0)
-		ret = do_quotactl(sb, type, cmds, id, addr);
+	audit_intercept(AUDIT_quotactl, cmd, tmp, id, addr);
+
+	if (!ret) {
+		ret = check_quotactl_valid(sb, type, cmds, id);
+		if (ret >= 0)
+			ret = do_quotactl(sb, type, cmds, id, addr);
+	}
 	if (sb)
 		drop_super(sb);
 
+	(void)audit_result(ret);
+
+	if (tmp)
+		putname(tmp);
 	return ret;
 }
diff -urNp linux-2.6.5/include/linux/audit.h linux-2.6.5.SUSE/include/linux/audit.h
--- linux-2.6.5/include/linux/audit.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5.SUSE/include/linux/audit.h	2004-04-22 16:11:15.000000000 +0200
@@ -0,0 +1,456 @@
+/*
+ * audit.h
+ *
+ * Copyright (c) 2003 SuSE Linux AG
+ * Written by okir@suse.de, based on ideas from systrace, written by
+ * Niels Provos (OpenBSD) and ported to Linux by Marius Aamodt Eriksen.
+ *
+ * GPL goes here
+ */
+
+#ifndef _AUDIT_H
+#define _AUDIT_H
+
+#ifdef __KERNEL__
+# include <linux/config.h>
+#endif
+
+#if !defined(__KERNEL__) || defined(CONFIG_AUDIT) || defined(CONFIG_AUDIT_MODULE)
+
+# ifdef __KERNEL__
+#  include <linux/limits.h>
+#  include <linux/slab.h>
+#  include <linux/sys.h>
+#  include <linux/time.h>
+#  include <asm/semaphore.h>
+# else
+#  include <limits.h>
+#  include <stdint.h>
+# endif
+
+# define AUDIT_API_VERSION	0x20040305
+
+# define AUD_MAX_HOSTNAME	256
+# define AUD_MAX_ADDRESS		256
+# define AUD_MAX_TERMINAL	256
+# define AUD_MAX_EVNAME		16
+
+/*
+ * System call intercept policy
+ */
+struct audit_policy {
+	unsigned int	code;
+	unsigned int	action;
+	unsigned int	filter;
+};
+
+# define AUDIT_IGNORE		0x0000
+# define AUDIT_LOG		0x0001
+/* Policy flags that can be set in filter rules using
+ * the return() predicate
+ */
+# define AUDIT_VERBOSE		0x0002
+
+
+/*
+ * Values for aud_msg_syscall.major and audit_policy.code
+ */
+enum audit_call {
+	AUDIT_invalid = -1,
+	AUDIT_access,
+	AUDIT_acct,
+	AUDIT_adjtimex,
+	AUDIT_brk,
+	AUDIT_bind,
+	AUDIT_capset,
+	AUDIT_chdir,
+	AUDIT_chmod,
+	AUDIT_chown,
+	AUDIT_chroot,
+	AUDIT_clone,
+	AUDIT_delete_module,
+	AUDIT_execve,
+	AUDIT_fchdir,
+	AUDIT_fchmod,
+	AUDIT_fchown,
+	AUDIT_fremovexattr,
+	AUDIT_fsetxattr,
+	AUDIT_ftruncate,
+	AUDIT_init_module,
+	AUDIT_ioctl,
+	AUDIT_ioperm,
+	AUDIT_iopl,
+	AUDIT_kill,
+	AUDIT_lchmod,
+	AUDIT_lchown,
+	AUDIT_link,
+	AUDIT_lremovexattr,
+	AUDIT_lsetxattr,
+	AUDIT_mkdir,
+	AUDIT_mknod,
+	AUDIT_mount,
+	AUDIT_msgctl,
+	AUDIT_msgget,
+	AUDIT_msgrcv,
+	AUDIT_msgsnd,
+	AUDIT_open,
+	AUDIT_ptrace,
+	AUDIT_quotactl,
+	AUDIT_reboot,
+	AUDIT_removexattr,
+	AUDIT_rename,
+	AUDIT_rmdir,
+	AUDIT_semctl,
+	AUDIT_semget,
+	AUDIT_semop,
+	AUDIT_semtimedop,
+	AUDIT_setdomainname,
+	AUDIT_setfsgid,
+	AUDIT_setfsuid,
+	AUDIT_setgid,
+	AUDIT_setgroups,
+	AUDIT_sethostname,
+	AUDIT_setpgid,
+	AUDIT_setpriority,
+	AUDIT_setregid,
+	AUDIT_setresgid,
+	AUDIT_setresuid,
+	AUDIT_setreuid,
+	AUDIT_setrlimit,
+	AUDIT_setsid,
+	AUDIT_settimeofday,
+	AUDIT_setuid,
+	AUDIT_setxattr,
+	AUDIT_shmat,
+	AUDIT_shmctl,
+	AUDIT_shmdt,
+	AUDIT_shmget,
+	AUDIT_socket,
+	AUDIT_swapoff,
+	AUDIT_swapon,
+	AUDIT_symlink,
+	AUDIT_syslog,
+	AUDIT_tgkill,
+	AUDIT_tkill,
+	AUDIT_truncate,
+	AUDIT_umask,
+	AUDIT_umount,
+	AUDIT_unlink,
+	AUDIT_utimes,
+	audit_NUM_CALLS,
+# ifdef __KERNEL__
+#  if BITS_PER_LONG == 64
+	AUDIT_32 = 0x4000,
+#  elif BITS_PER_LONG == 32
+	AUDIT_32 = 0,
+#  else
+#   error Unsupported!
+#  endif
+# endif
+};
+
+/*
+ * Special values for audit_policy.code
+ */
+enum {
+	__AUD_POLICY_LAST_SYSCALL = 299,
+	AUD_POLICY_FORK,
+	AUD_POLICY_EXIT,
+	AUD_POLICY_NETLINK,
+	AUD_POLICY_LOGIN,
+	AUD_POLICY_USERMSG,
+
+	__AUD_MAX_POLICY
+};
+
+/*
+ * Filter setup.
+ */
+struct audit_filter {
+	unsigned short	num;
+	unsigned short	op;
+	char		event[AUD_MAX_EVNAME];
+	union {
+		struct {
+			unsigned short	target;
+			unsigned short	filter;
+		} apply;
+		struct {
+			unsigned short	filt1, filt2;
+		} boolean;
+		struct {
+			unsigned int	action;
+		} freturn;
+		struct {
+			uint64_t	value;
+			uint64_t	mask;
+		} integer;
+		struct {
+			char *		value;
+		} string;
+	} u;
+};
+
+enum {
+	/* Boolean operations */
+	AUD_FILT_OP_AND = 0,		/* pair of filters */
+	AUD_FILT_OP_OR,			/* pair of filters */
+	AUD_FILT_OP_NOT,		/* single filter */
+	AUD_FILT_OP_APPLY,		/* target + predicate filter */
+	AUD_FILT_OP_RETURN,		/* return immediately */
+	AUD_FILT_OP_TRUE,		/* always true */
+	AUD_FILT_OP_FALSE,		/* always false */
+
+	/* Filter predicates, taking one argument */
+	AUD_FILT_OP_EQ = 0x10,		/* int */
+	AUD_FILT_OP_NE,			/* int */
+	AUD_FILT_OP_GT,			/* int */
+	AUD_FILT_OP_GE,			/* int */
+	AUD_FILT_OP_LE,			/* int */
+	AUD_FILT_OP_LT,			/* int */
+	AUD_FILT_OP_MASK,		/* int */
+	AUD_FILT_OP_STREQ = 0x20,	/* string */
+	AUD_FILT_OP_PREFIX,		/* path */
+};
+# define AUD_FILT_ARGTYPE_INT(op)	(((op) >> 4) == 1)
+# define AUD_FILT_ARGTYPE_STR(op)	(((op) >> 4) == 2)
+
+enum {
+	/* target values < 128 denote syscall arguments 0 .. 127
+	 * (in case anyone ever comes up with a system call
+	 * taking 127 arguments :)
+	 */
+	AUD_FILT_TGT_USERMSG_EVNAME = 0xFD,
+	AUD_FILT_TGT_MINOR_CODE = 0xFE,
+	AUD_FILT_TGT_RETURN_CODE = 0xFF,
+
+	AUD_FILT_TGT_UID = 0x100,
+	AUD_FILT_TGT_GID,
+	AUD_FILT_TGT_DUMPABLE,
+	AUD_FILT_TGT_EXIT_CODE,
+	AUD_FILT_TGT_LOGIN_UID,
+
+	AUD_FILT_TGT_FILE_MODE = 0x200,
+	AUD_FILT_TGT_FILE_DEV,
+	AUD_FILT_TGT_FILE_INO,
+	AUD_FILT_TGT_FILE_UID,
+	AUD_FILT_TGT_FILE_GID,
+	AUD_FILT_TGT_FILE_RDEV_MAJOR,
+	AUD_FILT_TGT_FILE_RDEV_MINOR,
+
+	AUD_FILT_TGT_SOCK_FAMILY = 0x300,
+	AUD_FILT_TGT_SOCK_TYPE,
+
+	AUD_FILT_TGT_NETLINK_TYPE = 0x400,
+	AUD_FILT_TGT_NETLINK_FLAGS,
+	AUD_FILT_TGT_NETLINK_FAMILY,
+};
+# define AUD_FILT_TGT_SYSCALL_ATTR(x)	(((x) >> 8) == 0)
+# define AUD_FILT_TGT_PROCESS_ATTR(x)	(((x) >> 8) == 1)
+# define AUD_FILT_TGT_FILE_ATTR(x)	(((x) >> 8) == 2)
+# define AUD_FILT_TGT_SOCK_ATTR(x)	(((x) >> 8) == 3)
+# define AUD_FILT_TGT_NETLINK_ATTR(x)	(((x) >> 8) == 4)
+
+
+/*
+ * Login data
+ */
+struct audit_login {
+	uid_t		uid;
+	char		hostname[AUD_MAX_HOSTNAME];
+	char		address[AUD_MAX_ADDRESS];
+	char		terminal[AUD_MAX_TERMINAL];
+};
+
+/*
+ * Message passing from user space
+ */
+struct audit_message {
+	unsigned int	msg_type;
+	char		msg_evname[AUD_MAX_EVNAME];
+	void *		msg_data;
+	size_t		msg_size;
+};
+
+/*
+ * IOCTLs to configure the audit subsystem
+ */
+# define AUD_MAGIC '@'
+
+/* The _IOR's are in fact wrong; they should be _IOW's :-( */
+# define AUIOCATTACH		_IO(AUD_MAGIC, 101)
+# define AUIOCDETACH		_IO(AUD_MAGIC, 102)
+# define AUIOCSUSPEND		_IO(AUD_MAGIC, 103)
+# define AUIOCRESUME		_IO(AUD_MAGIC, 104)
+# define AUIOCCLRPOLICY		_IO(AUD_MAGIC, 105)
+# define AUIOCSETPOLICY		_IOR(AUD_MAGIC, 106, struct audit_policy)
+# define AUIOCIAMAUDITD		_IO(AUD_MAGIC, 107)
+# define AUIOCSETAUDITID		_IO(AUD_MAGIC, 108)
+# define AUIOCLOGIN		_IOR(AUD_MAGIC, 110, struct audit_login)
+# define AUIOCUSERMESSAGE	_IOR(AUD_MAGIC, 111, struct audit_message)
+# define AUIOCCLRFILTER		_IO(AUD_MAGIC, 112)
+# define AUIOCSETFILTER		_IOR(AUD_MAGIC, 113, struct audit_filter)
+# define AUIOCVERSION		_IO(AUD_MAGIC, 114)
+# define AUIOCRESET		_IO(AUD_MAGIC, 115)
+
+/* Pass as ioctl(fd, AUIOCIAMAUDITD, AUDIT_TRACE_ALL) */
+# define AUDIT_TRACE_ALL		1
+
+/*
+ * This message is generated when a process forks
+ * or exits, to help auditd with book-keeping.
+ */
+struct aud_msg_child {
+        pid_t			new_pid;
+};
+
+/*
+ * This message reports system call arguments.
+ *
+ * personality	execution domain (see linux/personality.h)
+ * code		the system call code
+ * result	return value of system call
+ * length	length of data field
+ * data field	contains all arguments, TLV encoded as follows:
+ *
+ *   type	4 octets	(AUDIT_ARG_xxx)
+ *   length	4 octets	length of argument
+ *   ...	N octets	argument data
+ *
+ * Note that path name arguments are subjected to a realpath()
+ * style operation prior to sending them up to user land.
+ */
+struct aud_msg_syscall {
+	int		personality;
+
+	/* System call codes can have major/minor number.
+	 * for instance in the socketcall() case, major
+	 * would be __NR_socketcall, and minor would be
+	 * SYS_ACCEPT (or whatever the specific call is).
+	 */
+	int		major, minor;
+
+	int		result;
+	unsigned int	length;
+	unsigned char	data[0];
+};
+
+/*
+ * The LOGIN message is generated by the kernel when
+ * a user application performs an AUIOCLOGIN ioctl.
+ */
+struct aud_msg_login {
+	unsigned int	uid;
+	char		hostname[AUD_MAX_HOSTNAME];
+	char		address[AUD_MAX_ADDRESS];
+	char		terminal[AUD_MAX_TERMINAL];
+	char		executable[PATH_MAX];
+};
+
+/*
+ * Exit message
+ */
+struct aud_msg_exit {
+	long		code;
+};
+
+/*
+ * Network config (rtnetlink) call
+ */
+struct aud_msg_netlink {
+	unsigned int	groups, dst_groups;
+	int		result;
+	unsigned int	length;
+	unsigned char	data[0];
+};
+
+/* Values for msg_type */
+# define AUDIT_MSG_LOGIN		1
+# define AUDIT_MSG_SYSCALL	2
+# define AUDIT_MSG_EXIT		3
+# define AUDIT_MSG_NETLINK	4
+# define AUDIT_MSG_USERBASE	256	/* user land messages start here */
+
+/* Values for msg_arch */
+enum {
+	AUDIT_ARCH_I386,
+	AUDIT_ARCH_PPC,
+	AUDIT_ARCH_PPC64,
+	AUDIT_ARCH_S390,
+	AUDIT_ARCH_S390X,
+	AUDIT_ARCH_X86_64,
+	AUDIT_ARCH_IA64,
+};
+
+
+struct aud_message {
+	uint32_t	msg_seqnr;
+	uint16_t	msg_type;
+	uint16_t	msg_arch;	
+
+	pid_t		msg_pid;
+	size_t		msg_size;
+	unsigned long	msg_timestamp;
+
+	unsigned int	msg_audit_id;
+	unsigned int	msg_login_uid;
+	unsigned int	msg_euid, msg_ruid, msg_suid, msg_fsuid;
+	unsigned int	msg_egid, msg_rgid, msg_sgid, msg_fsgid;
+
+	/* Event name */
+	char		msg_evname[AUD_MAX_EVNAME];
+
+	unsigned char	msg_data[0];
+};
+
+/*
+ * Encoding of arguments passed up to auditd
+ */
+enum audit_arg {
+	AUDIT_ARG_END,
+	AUDIT_ARG_IMMEDIATE,
+	AUDIT_ARG_POINTER,
+	AUDIT_ARG_STRING,
+	AUDIT_ARG_PATH,
+	AUDIT_ARG_NULL,
+	AUDIT_ARG_ERROR,
+	AUDIT_ARG_VECTOR,	/* for execve */
+
+# ifdef __KERNEL__
+	/* Internal use only */
+	AUDIT_ARG_ARRAY = 100,
+	AUDIT_ARG_FILEDESC,
+	AUDIT_ARG_GROUP_INFO,
+	AUDIT_ARG_IPC_MSG
+# endif
+
+};
+
+# ifdef __KERNEL__
+
+struct sk_buff;
+struct aud_process;
+
+extern struct aud_process *audit_alloc(void);
+static void __inline__ audit_free(struct aud_process *pinfo) { if (pinfo) kfree(pinfo); }
+extern void audit_intercept(enum audit_call, ...);
+extern long audit_lresult(long);
+#  define audit_result(result) ((int)audit_lresult(result))
+extern void audit_fork(struct task_struct *, struct task_struct *);
+extern void audit_exit(struct task_struct *, long);
+extern void audit_netlink_msg(struct sk_buff *, int);
+
+#  define AUDITING(tsk) ((tsk)->audit != 0)
+
+# endif /* __KERNEL__ */
+
+#elif defined(__KERNEL__) /* with auditing disabled */
+
+# define AUDITING(tsk) 0
+# define audit_intercept(code, args...) ((void)0)
+# define audit_result(result) (result)
+# define audit_lresult(result) (result)
+
+#endif /* auditing enabled */
+
+#endif /* _AUDIT_H */
diff -urNp linux-2.6.5/include/linux/sched.h linux-2.6.5.SUSE/include/linux/sched.h
--- linux-2.6.5/include/linux/sched.h	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/include/linux/sched.h	2004-04-22 16:12:03.000000000 +0200
@@ -364,6 +364,9 @@ int set_current_groups(struct group_info
 #define GROUP_AT(gi, i) \
     ((gi)->blocks[(i)/NGROUPS_PER_BLOCK][(i)%NGROUPS_PER_BLOCK])
 
+#if defined(CONFIG_AUDIT) || defined(CONFIG_AUDIT_MODULE)
+struct aud_process;
+#endif
 
 struct task_struct {
 	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
@@ -520,6 +523,9 @@ struct task_struct {
 
 	struct mempolicy *mempolicy;
 	short il_next;		/* could be shared with used_math */
+#if defined(CONFIG_AUDIT) || defined(CONFIG_AUDIT_MODULE)
+	struct aud_process *audit;
+#endif
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
diff -urNp linux-2.6.5/ipc/msg.c linux-2.6.5.SUSE/ipc/msg.c
--- linux-2.6.5/ipc/msg.c	2004-04-04 05:36:13.000000000 +0200
+++ linux-2.6.5.SUSE/ipc/msg.c	2004-04-22 16:11:15.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/list.h>
 #include <linux/security.h>
 #include <linux/sched.h>
+#include <linux/audit.h>
 #include <asm/current.h>
 #include <asm/uaccess.h>
 #include "util.h"
@@ -305,6 +306,8 @@ asmlinkage long sys_msgget (key_t key, i
 {
 	int id, ret = -EPERM;
 	struct msg_queue *msq;
+
+	audit_intercept(AUDIT_msgget, key, msgflg);
 	
 	down(&msg_ids.sem);
 	if (key == IPC_PRIVATE) 
@@ -331,7 +334,7 @@ asmlinkage long sys_msgget (key_t key, i
 		msg_unlock(msq);
 	}
 	up(&msg_ids.sem);
-	return ret;
+	return audit_result(ret);
 }
 
 static inline unsigned long copy_msqid_to_user(void *buf, struct msqid64_ds *in, int version)
@@ -431,9 +434,11 @@ asmlinkage long sys_msgctl (int msqid, i
 	struct msg_queue *msq;
 	struct msq_setbuf setbuf;
 	struct kern_ipc_perm *ipcp;
-	
+
+	audit_intercept(AUDIT_msgctl, msqid, cmd, buf);
+
 	if (msqid < 0 || cmd < 0)
-		return -EINVAL;
+		return audit_result(-EINVAL);
 
 	version = ipc_parse_version(&cmd);
 
@@ -444,16 +449,15 @@ asmlinkage long sys_msgctl (int msqid, i
 		struct msginfo msginfo;
 		int max_id;
 		if (!buf)
-			return -EFAULT;
+			return audit_result(-EFAULT);
+		err = security_msg_queue_msgctl(NULL, cmd);
+		if (err)
+			return audit_result(err);
+
 		/* We must not return kernel stack data.
 		 * due to padding, it's not enough
 		 * to set all member fields.
 		 */
-
-		err = security_msg_queue_msgctl(NULL, cmd);
-		if (err)
-			return err;
-
 		memset(&msginfo,0,sizeof(msginfo));	
 		msginfo.msgmni = msg_ctlmni;
 		msginfo.msgmax = msg_ctlmax;
@@ -473,8 +477,8 @@ asmlinkage long sys_msgctl (int msqid, i
 		max_id = msg_ids.max_id;
 		up(&msg_ids.sem);
 		if (copy_to_user (buf, &msginfo, sizeof(struct msginfo)))
-			return -EFAULT;
-		return (max_id < 0) ? 0: max_id;
+			return audit_result(-EFAULT);
+		return audit_result((max_id < 0) ? 0: max_id);
 	}
 	case MSG_STAT:
 	case IPC_STAT:
@@ -482,15 +486,15 @@ asmlinkage long sys_msgctl (int msqid, i
 		struct msqid64_ds tbuf;
 		int success_return;
 		if (!buf)
-			return -EFAULT;
+			return audit_result(-EFAULT);
 		if(cmd == MSG_STAT && msqid >= msg_ids.size)
-			return -EINVAL;
+			return audit_result(-EINVAL);
 
 		memset(&tbuf,0,sizeof(tbuf));
 
 		msq = msg_lock(msqid);
 		if (msq == NULL)
-			return -EINVAL;
+			return audit_result(-EINVAL);
 
 		if(cmd == MSG_STAT) {
 			success_return = msg_buildid(msqid, msq->q_perm.seq);
@@ -519,19 +523,17 @@ asmlinkage long sys_msgctl (int msqid, i
 		tbuf.msg_lrpid  = msq->q_lrpid;
 		msg_unlock(msq);
 		if (copy_msqid_to_user(buf, &tbuf, version))
-			return -EFAULT;
-		return success_return;
+			return audit_result(-EFAULT);
+		return audit_result(success_return);
 	}
 	case IPC_SET:
-		if (!buf)
-			return -EFAULT;
-		if (copy_msqid_from_user (&setbuf, buf, version))
-			return -EFAULT;
+		if (!buf || copy_msqid_from_user (&setbuf, buf, version))
+			return audit_result(-EFAULT);
 		break;
 	case IPC_RMID:
 		break;
 	default:
-		return  -EINVAL;
+		return audit_result(-EINVAL);
 	}
 
 	down(&msg_ids.sem);
@@ -586,13 +588,13 @@ asmlinkage long sys_msgctl (int msqid, i
 	err = 0;
 out_up:
 	up(&msg_ids.sem);
-	return err;
+	return audit_result(err);
 out_unlock_up:
 	msg_unlock(msq);
 	goto out_up;
 out_unlock:
 	msg_unlock(msq);
-	return err;
+	return audit_result(err);
 }
 
 static int testmsg(struct msg_msg* msg,long type,int mode)
@@ -652,19 +654,21 @@ asmlinkage long sys_msgsnd (int msqid, s
 	int err;
 	
 	if (msgsz > msg_ctlmax || (long) msgsz < 0 || msqid < 0)
-		return -EINVAL;
+		return audit_intercept(AUDIT_msgsnd, msqid, NULL, msgflg), audit_result(-EINVAL);
 	if (get_user(mtype, &msgp->mtype))
-		return -EFAULT; 
+		return audit_intercept(AUDIT_msgsnd, msqid, NULL, msgflg), audit_result(-EFAULT);
 	if (mtype < 1)
-		return -EINVAL;
+		return audit_intercept(AUDIT_msgsnd, msqid, NULL, msgflg), audit_result(-EINVAL);
 
 	msg = load_msg(msgp->mtext, msgsz);
 	if(IS_ERR(msg))
-		return PTR_ERR(msg);
+		return audit_intercept(AUDIT_msgsnd, msqid, NULL, msgflg), audit_result(PTR_ERR(msg));
 
 	msg->m_type = mtype;
 	msg->m_ts = msgsz;
 
+	audit_intercept(AUDIT_msgsnd, msqid, msg, msgsz, msgflg);
+
 	msq = msg_lock(msqid);
 	err=-EINVAL;
 	if(msq==NULL)
@@ -726,6 +730,7 @@ retry:
 out_unlock_free:
 	msg_unlock(msq);
 out_free:
+	(void)audit_result(err);
 	if(msg!=NULL)
 		free_msg(msg);
 	return err;
@@ -760,13 +765,15 @@ asmlinkage long sys_msgrcv (int msqid, s
 	int err;
 	int mode;
 
+	audit_intercept(AUDIT_msgrcv, msqid, msgp, msgsz, msgtyp, msgflg);
+
 	if (msqid < 0 || (long) msgsz < 0)
-		return -EINVAL;
+		return audit_result(-EINVAL);
 	mode = convert_mode(&msgtyp,msgflg);
 
 	msq = msg_lock(msqid);
 	if(msq==NULL)
-		return -EINVAL;
+		return audit_result(-EINVAL);
 retry:
 	err = -EIDRM;
 	if (msg_checkid(msq,msqid))
@@ -815,7 +822,7 @@ out_success:
 			    msgsz = -EFAULT;
 		}
 		free_msg(msg);
-		return msgsz;
+		return audit_result(msgsz);
 	} else
 	{
 		/* no message waiting. Prepare for pipelined
@@ -877,7 +884,7 @@ out_success:
 out_unlock:
 	if(msq)
 		msg_unlock(msq);
-	return err;
+	return audit_result(err);
 }
 
 #ifdef CONFIG_PROC_FS
diff -urNp linux-2.6.5/ipc/sem.c linux-2.6.5.SUSE/ipc/sem.c
--- linux-2.6.5/ipc/sem.c	2004-04-04 05:36:56.000000000 +0200
+++ linux-2.6.5.SUSE/ipc/sem.c	2004-04-22 16:11:15.000000000 +0200
@@ -71,6 +71,7 @@
 #include <linux/time.h>
 #include <linux/smp_lock.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 #include <asm/uaccess.h>
 #include "util.h"
 
@@ -207,8 +208,10 @@ asmlinkage long sys_semget (key_t key, i
 	int id, err = -EINVAL;
 	struct sem_array *sma;
 
+	audit_intercept(AUDIT_semget, key, nsems, semflg);
+
 	if (nsems < 0 || nsems > sc_semmsl)
-		return -EINVAL;
+		return audit_result(-EINVAL);
 	down(&sem_ids.sem);
 	
 	if (key == IPC_PRIVATE) {
@@ -238,7 +241,7 @@ asmlinkage long sys_semget (key_t key, i
 	}
 
 	up(&sem_ids.sem);
-	return err;
+	return audit_result(err);
 }
 
 /* doesn't acquire the sem_lock on error! */
@@ -833,8 +836,10 @@ asmlinkage long sys_semctl (int semid, i
 	int err = -EINVAL;
 	int version;
 
+	audit_intercept(AUDIT_semctl, semid, semnum, cmd, arg);
+
 	if (semid < 0)
-		return -EINVAL;
+		return audit_result(-EINVAL);
 
 	version = ipc_parse_version(&cmd);
 
@@ -843,7 +848,7 @@ asmlinkage long sys_semctl (int semid, i
 	case SEM_INFO:
 	case SEM_STAT:
 		err = semctl_nolock(semid,semnum,cmd,version,arg);
-		return err;
+		return audit_result(err);
 	case GETALL:
 	case GETVAL:
 	case GETPID:
@@ -853,15 +858,15 @@ asmlinkage long sys_semctl (int semid, i
 	case SETVAL:
 	case SETALL:
 		err = semctl_main(semid,semnum,cmd,version,arg);
-		return err;
+		return audit_result(err);
 	case IPC_RMID:
 	case IPC_SET:
 		down(&sem_ids.sem);
 		err = semctl_down(semid,semnum,cmd,version,arg);
 		up(&sem_ids.sem);
-		return err;
+		return audit_result(err);
 	default:
-		return -EINVAL;
+		return audit_result(-EINVAL);
 	}
 }
 
@@ -1022,26 +1027,35 @@ asmlinkage long sys_semtimedop(int semid
 	int undos = 0, decrease = 0, alter = 0, max;
 	struct sem_queue queue;
 	unsigned long jiffies_left = 0;
+	struct timespec _timeout;
 
-	if (nsops < 1 || semid < 0)
-		return -EINVAL;
-	if (nsops > sc_semopm)
-		return -E2BIG;
+	if (nsops < 1 || semid < 0) {
+		audit_intercept(timeout ? AUDIT_semtimedop : AUDIT_semop, semid, NULL, nsops, NULL);
+		return audit_result(-EINVAL);
+	}
+	if (nsops > sc_semopm) {
+		audit_intercept(timeout ? AUDIT_semtimedop : AUDIT_semop, semid, NULL, nsops, NULL);
+		return audit_result(-E2BIG);
+	}
 	if(nsops > SEMOPM_FAST) {
 		sops = kmalloc(sizeof(*sops)*nsops,GFP_KERNEL);
-		if(sops==NULL)
-			return -ENOMEM;
+		if(sops==NULL) {
+			audit_intercept(timeout ? AUDIT_semtimedop : AUDIT_semop, semid, NULL, nsops, NULL);
+			return audit_result(-ENOMEM);
+		}
 	}
 	if (copy_from_user (sops, tsops, nsops * sizeof(*tsops))) {
 		error=-EFAULT;
+		audit_intercept(timeout ? AUDIT_semtimedop : AUDIT_semop, semid, NULL, nsops, NULL);
 		goto out_free;
 	}
 	if (timeout) {
-		struct timespec _timeout;
 		if (copy_from_user(&_timeout, timeout, sizeof(*timeout))) {
 			error = -EFAULT;
+			audit_intercept(AUDIT_semtimedop, semid, sops, nsops, NULL);
 			goto out_free;
 		}
+		audit_intercept(AUDIT_semtimedop, semid, sops, nsops, &_timeout);
 		if (_timeout.tv_sec < 0 || _timeout.tv_nsec < 0 ||
 			_timeout.tv_nsec >= 1000000000L) {
 			error = -EINVAL;
@@ -1049,6 +1063,8 @@ asmlinkage long sys_semtimedop(int semid
 		}
 		jiffies_left = timespec_to_jiffies(&_timeout);
 	}
+	else
+		audit_intercept(AUDIT_semop, semid, sops, nsops);
 	max = 0;
 	for (sop = sops; sop < sops + nsops; sop++) {
 		if (sop->sem_num >= max)
@@ -1171,6 +1187,7 @@ update:
 out_unlock_free:
 	sem_unlock(sma);
 out_free:
+	(void)audit_result(error);
 	if(sops != fast_sops)
 		kfree(sops);
 	return error;
diff -urNp linux-2.6.5/ipc/shm.c linux-2.6.5.SUSE/ipc/shm.c
--- linux-2.6.5/ipc/shm.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/ipc/shm.c	2004-04-22 16:11:15.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/proc_fs.h>
 #include <linux/shmem_fs.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 #include <asm/uaccess.h>
 
 #include "util.h"
@@ -241,6 +242,8 @@ asmlinkage long sys_shmget (key_t key, s
 	struct shmid_kernel *shp;
 	int err, id = 0;
 
+	audit_intercept(AUDIT_shmget, key, size, shmflg);
+
 	down(&shm_ids.sem);
 	if (key == IPC_PRIVATE) {
 		err = newseg(key, shmflg, size);
@@ -269,7 +272,7 @@ asmlinkage long sys_shmget (key_t key, s
 	}
 	up(&shm_ids.sem);
 
-	return err;
+	return audit_result(err);
 }
 
 static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)
@@ -399,6 +402,8 @@ asmlinkage long sys_shmctl (int shmid, i
 	struct shmid_kernel *shp;
 	int err, version;
 
+	audit_intercept(AUDIT_shmctl, shmid, cmd, buf);
+
 	if (cmd < 0 || shmid < 0) {
 		err = -EINVAL;
 		goto out;
@@ -413,7 +418,7 @@ asmlinkage long sys_shmctl (int shmid, i
 
 		err = security_shm_shmctl(NULL, cmd);
 		if (err)
-			return err;
+			return audit_result(err);
 
 		memset(&shminfo,0,sizeof(shminfo));
 		shminfo.shmmni = shminfo.shmseg = shm_ctlmni;
@@ -422,7 +427,7 @@ asmlinkage long sys_shmctl (int shmid, i
 
 		shminfo.shmmin = SHMMIN;
 		if(copy_shminfo_to_user (buf, &shminfo, version))
-			return -EFAULT;
+			return audit_result(-EFAULT);
 		/* reading a integer is always atomic */
 		err= shm_ids.max_id;
 		if(err<0)
@@ -435,7 +440,7 @@ asmlinkage long sys_shmctl (int shmid, i
 
 		err = security_shm_shmctl(NULL, cmd);
 		if (err)
-			return err;
+			return audit_result(err);
 
 		memset(&shm_info,0,sizeof(shm_info));
 		down(&shm_ids.sem);
@@ -584,6 +589,7 @@ asmlinkage long sys_shmctl (int shmid, i
 			err = -EFAULT;
 			goto out;
 		}
+
 		down(&shm_ids.sem);
 		shp = shm_lock(shmid);
 		err=-EINVAL;
@@ -625,7 +631,7 @@ out_up:
 out_unlock:
 	shm_unlock(shp);
 out:
-	return err;
+	return audit_result(err);
 }
 
 /*
@@ -648,23 +654,25 @@ long do_shmat(int shmid, char __user *sh
 	int acc_mode;
 	void *user_addr;
 
+	audit_intercept(AUDIT_shmat, shmid, shmaddr, shmflg);
+
 	if (shmid < 0) {
 		err = -EINVAL;
 		goto out;
 	} else if ((addr = (ulong)shmaddr)) {
 		if (addr & (SHMLBA-1)) {
-			if (shmflg & SHM_RND)
+ 			if (shmflg & SHM_RND)
 				addr &= ~(SHMLBA-1);	   /* round down */
 			else
 #ifndef __ARCH_FORCE_SHMLBA
 				if (addr & ~PAGE_MASK)
 #endif
-					return -EINVAL;
+					return audit_result(-EINVAL);
 		}
 		flags = MAP_SHARED | MAP_FIXED;
 	} else {
 		if ((shmflg & SHM_REMAP))
-			return -EINVAL;
+			return audit_result(-EINVAL);
 
 		flags = MAP_SHARED;
 	}
@@ -702,7 +710,7 @@ long do_shmat(int shmid, char __user *sh
 	err = security_shm_shmat(shp, shmaddr, shmflg);
 	if (err) {
 		shm_unlock(shp);
-		return err;
+		return audit_result(err);
 	}
 		
 	file = shp->shm_file;
@@ -745,7 +753,7 @@ invalid:
 	if (IS_ERR(user_addr))
 		err = PTR_ERR(user_addr);
 out:
-	return err;
+	return audit_result(err);
 }
 
 /*
@@ -760,6 +768,8 @@ asmlinkage long sys_shmdt(char __user *s
 	loff_t size = 0;
 	int retval = -EINVAL;
 
+	audit_intercept(AUDIT_shmdt, shmaddr);
+
 	down_write(&mm->mmap_sem);
 
 	/*
@@ -828,7 +838,7 @@ asmlinkage long sys_shmdt(char __user *s
 	}
 
 	up_write(&mm->mmap_sem);
-	return retval;
+	return audit_result(retval);
 }
 
 #ifdef CONFIG_PROC_FS
diff -urNp linux-2.6.5/kernel/acct.c linux-2.6.5.SUSE/kernel/acct.c
--- linux-2.6.5/kernel/acct.c	2004-04-04 05:37:23.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/acct.c	2004-04-22 16:11:15.000000000 +0200
@@ -53,6 +53,7 @@
 #include <linux/vfs.h>
 #include <linux/jiffies.h>
 #include <linux/times.h>
+#include <linux/audit.h>
 #include <asm/uaccess.h>
 #include <asm/div64.h>
 #include <linux/blkdev.h> /* sector_div */
@@ -206,47 +207,54 @@ void acct_file_reopen(struct file *file)
  */
 asmlinkage long sys_acct(const char *name)
 {
-	struct file *file = NULL;
+	struct file *file;
 	char *tmp;
-	int error;
+	int error = 0;
 
 	if (!capable(CAP_SYS_PACCT))
-		return -EPERM;
+		return audit_intercept(AUDIT_acct, NULL), audit_result(-EPERM);
 
 	if (name) {
 		tmp = getname(name);
 		if (IS_ERR(tmp)) {
 			return (PTR_ERR(tmp));
 		}
+
+		audit_intercept(AUDIT_acct, tmp);
+
 		/* Difference from BSD - they don't do O_APPEND */
 		file = filp_open(tmp, O_WRONLY|O_APPEND, 0);
-		putname(tmp);
 		if (IS_ERR(file)) {
-			return (PTR_ERR(file));
-		}
-		if (!S_ISREG(file->f_dentry->d_inode->i_mode)) {
-			filp_close(file, NULL);
-			return (-EACCES);
+			error = PTR_ERR(file);
+			file = NULL;
 		}
+		else if (!S_ISREG(file->f_dentry->d_inode->i_mode))
+			error = -EACCES;
+		else if (!file->f_op->write)
+			error = -EIO;
+	}
+	else {
+		tmp = NULL;
+		file = NULL;
+		audit_intercept(AUDIT_acct, NULL);
+	}
+
+	if (!error)
+		error = security_acct(file);
+	if (error && file)
+		filp_close(file, NULL);
 
-		if (!file->f_op->write) {
-			filp_close(file, NULL);
-			return (-EIO);
-		}
-	}
+	(void)audit_result(error);
+	if (tmp)
+		putname(tmp);
 
-	error = security_acct(file);
-	if (error) {
-		if (file)
-			filp_close(file, NULL);
-		return error;
+	if (!error) {
+		spin_lock(&acct_globals.lock);
+		acct_file_reopen(file);
+		spin_unlock(&acct_globals.lock);
 	}
 
-	spin_lock(&acct_globals.lock);
-	acct_file_reopen(file);
-	spin_unlock(&acct_globals.lock);
-
-	return (0);
+	return error;
 }
 
 /*
diff -urNp linux-2.6.5/kernel/capability.c linux-2.6.5.SUSE/kernel/capability.c
--- linux-2.6.5/kernel/capability.c	2004-04-22 16:10:54.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/capability.c	2004-04-22 16:11:15.000000000 +0200
@@ -10,6 +10,7 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 #include <asm/uaccess.h>
 
 unsigned securebits = SECUREBITS_DEFAULT; /* systemwide security settings */
@@ -150,13 +151,15 @@ asmlinkage long sys_capset(cap_user_head
 	     return -EFAULT; 
 
      if (pid && !capable(CAP_SETPCAP))
-             return -EPERM;
+             return audit_intercept(AUDIT_capset, version, pid, NULL, NULL, NULL), audit_result(-EPERM);
 
      if (copy_from_user(&effective, &data->effective, sizeof(effective)) ||
 	 copy_from_user(&inheritable, &data->inheritable, sizeof(inheritable)) ||
 	 copy_from_user(&permitted, &data->permitted, sizeof(permitted)))
 	     return -EFAULT; 
 
+     audit_intercept(AUDIT_capset, version, pid, &effective, &inheritable, &permitted);
+
      spin_lock(&task_capability_lock);
      read_lock(&tasklist_lock);
 
@@ -205,5 +208,5 @@ out:
      read_unlock(&tasklist_lock);
      spin_unlock(&task_capability_lock);
 
-     return ret;
+     return audit_result(ret);
 }
diff -urNp linux-2.6.5/kernel/compat.c linux-2.6.5.SUSE/kernel/compat.c
--- linux-2.6.5/kernel/compat.c	2004-04-04 05:37:07.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/compat.c	2004-04-22 16:11:15.000000000 +0200
@@ -20,6 +20,7 @@
 #include <linux/futex.h>	/* for FUTEX_WAIT */
 #include <linux/syscalls.h>
 #include <linux/unistd.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 
@@ -234,7 +235,7 @@ asmlinkage long compat_sys_setrlimit(uns
 	mm_segment_t old_fs = get_fs ();
 
 	if (resource >= RLIM_NLIMITS) 
-		return -EINVAL;	
+		return audit_intercept(AUDIT_setrlimit, resource, NULL), audit_result(-EINVAL);
 
 	if (!access_ok(VERIFY_READ, rlim, sizeof(*rlim)) ||
 	    __get_user(r.rlim_cur, &rlim->rlim_cur) ||
diff -urNp linux-2.6.5/kernel/exit.c linux-2.6.5.SUSE/kernel/exit.c
--- linux-2.6.5/kernel/exit.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/exit.c	2004-04-22 16:11:15.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/kdb.h>
 #endif
 #include <linux/ckrm.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -779,6 +780,11 @@ asmlinkage NORET_TYPE void do_exit(long 
 	}
 
 	acct_process(code);
+#if defined(CONFIG_AUDIT) || defined(CONFIG_AUDIT_MODULE)
+	if (AUDITING(tsk))
+		audit_exit(tsk, code);
+	audit_free(tsk->audit);
+#endif
 	__exit_mm(tsk);
 
 	exit_sem(tsk);
diff -urNp linux-2.6.5/kernel/fork.c linux-2.6.5.SUSE/kernel/fork.c
--- linux-2.6.5/kernel/fork.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/fork.c	2004-04-22 16:11:15.000000000 +0200
@@ -32,6 +32,7 @@
 #include <linux/ptrace.h>
 #include <linux/mount.h>
 #include <linux/objrmap.h>
+#include <linux/audit.h>
 
 #include <linux/ckrm.h>
 #include <asm/pgtable.h>
@@ -473,6 +474,8 @@ void mmput(struct mm_struct *mm)
 	}
 }
 
+EXPORT_SYMBOL(mmput);
+
 /*
  * Checks if the use count of an mm is non-zero and if so
  * returns a reference to it after bumping up the use count.
@@ -902,6 +905,16 @@ struct task_struct *copy_process(unsigne
 	if (!p)
 		goto fork_out;
 
+#if defined(CONFIG_AUDIT) || defined(CONFIG_AUDIT_MODULE)
+	if (AUDITING(current)) {
+		p->audit = audit_alloc();
+		if (!p->audit)
+			goto bad_fork_free_task;
+	}
+	else
+		p->audit = NULL;
+#endif
+
 	retval = -EAGAIN;
 	if (atomic_read(&p->user->processes) >=
 			p->rlim[RLIMIT_NPROC].rlim_cur) {
@@ -1135,6 +1148,10 @@ bad_fork_cleanup_count:
 	atomic_dec(&p->user->processes);
 	free_uid(p->user);
 bad_fork_free:
+#if defined(CONFIG_AUDIT) || defined(CONFIG_AUDIT_MODULE)
+	audit_free(p->audit);
+bad_fork_free_task:
+#endif
 	free_task(p);
 	goto fork_out;
 }
@@ -1172,6 +1189,8 @@ long do_fork(unsigned long clone_flags,
 	int trace = 0;
 	long pid;
 
+	audit_intercept(AUDIT_clone, clone_flags);
+
 	if (unlikely(current->ptrace)) {
 		trace = fork_traceflag (clone_flags);
 		if (trace)
@@ -1185,6 +1204,8 @@ long do_fork(unsigned long clone_flags,
 	 */
 	pid = IS_ERR(p) ? PTR_ERR(p) : p->pid;
 
+	(void)audit_lresult(pid);
+
 	if (!IS_ERR(p)) {
 		struct completion vfork;
 
@@ -1203,6 +1224,11 @@ long do_fork(unsigned long clone_flags,
 			set_tsk_thread_flag(p, TIF_SIGPENDING);
 		}
 
+#if defined(CONFIG_AUDIT) || defined(CONFIG_AUDIT_MODULE)
+	        if (AUDITING(current))
+        	      audit_fork(current, p);
+#endif
+
 		if (!(clone_flags & CLONE_STOPPED))
 			wake_up_forked_process(p);	/* do this last */
 		else
diff -urNp linux-2.6.5/kernel/module.c linux-2.6.5.SUSE/kernel/module.c
--- linux-2.6.5/kernel/module.c	2004-04-22 16:10:50.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/module.c	2004-04-22 16:11:15.000000000 +0200
@@ -34,6 +34,7 @@
 #include <linux/vermagic.h>
 #include <linux/notifier.h>
 #include <linux/stop_machine.h>
+#include <linux/audit.h>
 #include <asm/uaccess.h>
 #include <asm/semaphore.h>
 #include <asm/pgalloc.h>
@@ -546,14 +547,16 @@ sys_delete_module(const char __user *nam
 	int ret, forced = 0;
 
 	if (!capable(CAP_SYS_MODULE))
-		return -EPERM;
+		return audit_intercept(AUDIT_delete_module, NULL, flags), audit_result(-EPERM);
 
 	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
 		return -EFAULT;
 	name[MODULE_NAME_LEN-1] = '\0';
 
+	audit_intercept(AUDIT_delete_module, name, flags);
+
 	if (down_interruptible(&module_mutex) != 0)
-		return -EINTR;
+		return audit_result(-EINTR);
 
 	mod = find_module(name);
 	if (!mod) {
@@ -605,7 +608,7 @@ sys_delete_module(const char __user *nam
 
  out:
 	up(&module_mutex);
-	return ret;
+	return audit_result(ret);
 }
 
 static void print_unload_info(struct seq_file *m, struct module *mod)
@@ -686,7 +689,8 @@ static inline void module_unload_init(st
 asmlinkage long
 sys_delete_module(const char *name_user, unsigned int flags)
 {
-	return -ENOSYS;
+	audit_intercept(AUDIT_delete_module, NULL, flags);
+	return audit_result(-ENOSYS);
 }
 
 #endif /* CONFIG_MODULE_UNLOAD */
@@ -1591,19 +1595,21 @@ sys_init_module(void __user *umod,
 	struct module *mod;
 	int ret;
 
+	audit_intercept(AUDIT_init_module, umod, len, uargs);
+
 	/* Must have permission */
 	if (!capable(CAP_SYS_MODULE))
-		return -EPERM;
+		return audit_result(-EPERM);
 
 	/* Only one module load at a time, please */
 	if (down_interruptible(&module_mutex) != 0)
-		return -EINTR;
+		return audit_result(-EINTR);
 
 	/* Do all the hard work */
 	mod = load_module(umod, len, uargs);
 	if (IS_ERR(mod)) {
 		up(&module_mutex);
-		return PTR_ERR(mod);
+		return audit_result(PTR_ERR(mod));
 	}
 
 	/* Flush the instruction cache, since we've played with text */
@@ -1643,7 +1649,7 @@ sys_init_module(void __user *umod,
 			free_module(mod);
 			up(&module_mutex);
 		}
-		return ret;
+		return audit_result(ret);
 	}
 
 	/* Now it's a first class citizen! */
@@ -1657,7 +1663,7 @@ sys_init_module(void __user *umod,
 	mod->init_text_size = 0;
 	up(&module_mutex);
 
-	return 0;
+	return audit_result(0);
 }
 
 static inline int within(unsigned long addr, void *start, unsigned long size)
diff -urNp linux-2.6.5/kernel/printk.c linux-2.6.5.SUSE/kernel/printk.c
--- linux-2.6.5/kernel/printk.c	2004-04-22 16:10:54.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/printk.c	2004-04-22 16:11:15.000000000 +0200
@@ -30,6 +30,7 @@
 #include <linux/smp.h>
 #include <linux/security.h>
 #include <linux/bootmem.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 
@@ -256,9 +257,11 @@ int do_syslog(int type, char __user * bu
 	char c;
 	int error = 0;
 
+	audit_intercept(AUDIT_syslog, type, buf, len);
+
 	error = security_syslog(type);
 	if (error)
-		return error;
+		return audit_result(error);
 
 	switch (type) {
 	case 0:		/* Close log */
@@ -383,7 +386,7 @@ int do_syslog(int type, char __user * bu
 		break;
 	}
 out:
-	return error;
+	return audit_result(error);
 }
 
 #ifdef	CONFIG_KDB
diff -urNp linux-2.6.5/kernel/signal.c linux-2.6.5.SUSE/kernel/signal.c
--- linux-2.6.5/kernel/signal.c	2004-04-22 16:10:50.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/signal.c	2004-04-22 16:11:15.000000000 +0200
@@ -21,6 +21,7 @@
 #include <linux/binfmts.h>
 #include <linux/security.h>
 #include <linux/ptrace.h>
+#include <linux/audit.h>
 #include <asm/param.h>
 #include <asm/uaccess.h>
 #include <asm/siginfo.h>
@@ -2145,13 +2146,15 @@ sys_kill(int pid, int sig)
 {
 	struct siginfo info;
 
+	audit_intercept(AUDIT_kill, pid, sig);
+
 	info.si_signo = sig;
 	info.si_errno = 0;
 	info.si_code = SI_USER;
 	info.si_pid = current->tgid;
 	info.si_uid = current->uid;
 
-	return kill_something_info(sig, &info, pid);
+	return audit_lresult(kill_something_info(sig, &info, pid));
 }
 
 /**
@@ -2170,9 +2173,11 @@ asmlinkage long sys_tgkill(int tgid, int
 	int error;
 	struct task_struct *p;
 
+	audit_intercept(AUDIT_tgkill, tgid, pid, sig);
+
 	/* This is only valid for single tasks */
 	if (pid <= 0 || tgid <= 0)
-		return -EINVAL;
+		return audit_lresult(-EINVAL);
 
 	info.si_signo = sig;
 	info.si_errno = 0;
@@ -2197,7 +2202,7 @@ asmlinkage long sys_tgkill(int tgid, int
 		}
 	}
 	read_unlock(&tasklist_lock);
-	return error;
+	return audit_lresult(error);
 }
 
 /*
@@ -2210,9 +2215,11 @@ sys_tkill(int pid, int sig)
 	int error;
 	struct task_struct *p;
 
+	audit_intercept(AUDIT_tkill, pid, sig);
+
 	/* This is only valid for single tasks */
 	if (pid <= 0)
-		return -EINVAL;
+		return audit_lresult(-EINVAL);
 
 	info.si_signo = sig;
 	info.si_errno = 0;
@@ -2237,7 +2244,7 @@ sys_tkill(int pid, int sig)
 		}
 	}
 	read_unlock(&tasklist_lock);
-	return error;
+	return audit_lresult(error);
 }
 
 asmlinkage long
diff -urNp linux-2.6.5/kernel/sys.c linux-2.6.5.SUSE/kernel/sys.c
--- linux-2.6.5/kernel/sys.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/sys.c	2004-04-22 16:11:15.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/dcookies.h>
 #include <linux/suspend.h>
 #include <linux/ckrm.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -303,6 +304,8 @@ asmlinkage long sys_setpriority(int whic
 	struct list_head *l;
 	int error = -EINVAL;
 
+	audit_intercept(AUDIT_setpriority, which, who, niceval);
+
 	if (which > 2 || which < 0)
 		goto out;
 
@@ -346,7 +349,8 @@ asmlinkage long sys_setpriority(int whic
 out_unlock:
 	read_unlock(&tasklist_lock);
 out:
-	return error;
+
+	return audit_result(error);
 }
 
 /*
@@ -424,9 +428,11 @@ asmlinkage long sys_reboot(int magic1, i
 {
 	char buffer[256];
 
+	audit_intercept(AUDIT_reboot, magic1, magic2, cmd, arg);
+
 	/* We only trust the superuser with rebooting the system. */
 	if (!capable(CAP_SYS_BOOT))
-		return -EPERM;
+		return audit_result(-EPERM);
 
 	/* For safety, we require "magic" arguments. */
 	if (magic1 != LINUX_REBOOT_MAGIC1 ||
@@ -434,7 +440,7 @@ asmlinkage long sys_reboot(int magic1, i
 	                magic2 != LINUX_REBOOT_MAGIC2A &&
 			magic2 != LINUX_REBOOT_MAGIC2B &&
 	                magic2 != LINUX_REBOOT_MAGIC2C))
-		return -EINVAL;
+		return audit_result(-EINVAL);
 
 	lock_kernel();
 	switch (cmd) {
@@ -477,7 +483,7 @@ asmlinkage long sys_reboot(int magic1, i
 	case LINUX_REBOOT_CMD_RESTART2:
 		if (strncpy_from_user(&buffer[0], arg, sizeof(buffer) - 1) < 0) {
 			unlock_kernel();
-			return -EFAULT;
+			return audit_result(-EFAULT);
 		}
 		buffer[sizeof(buffer) - 1] = '\0';
 
@@ -493,16 +499,16 @@ asmlinkage long sys_reboot(int magic1, i
 		{
 			int ret = software_suspend();
 			unlock_kernel();
-			return ret;
+			return audit_result(ret);
 		}
 #endif
 
 	default:
 		unlock_kernel();
-		return -EINVAL;
+		return audit_result(-EINVAL);
 	}
 	unlock_kernel();
-	return 0;
+	return audit_result(0);
 }
 
 static void deferred_cad(void *dummy)
@@ -553,9 +559,11 @@ asmlinkage long sys_setregid(gid_t rgid,
 	int new_egid = old_egid;
 	int retval;
 
+	audit_intercept(AUDIT_setregid, rgid, egid);
+
 	retval = security_task_setgid(rgid, egid, (gid_t)-1, LSM_SETID_RE);
 	if (retval)
-		return retval;
+		return audit_result(retval);
 
 	if (rgid != (gid_t) -1) {
 		if ((old_rgid == rgid) ||
@@ -563,7 +571,7 @@ asmlinkage long sys_setregid(gid_t rgid,
 		    capable(CAP_SETGID))
 			new_rgid = rgid;
 		else
-			return -EPERM;
+			return audit_result(-EPERM);
 	}
 	if (egid != (gid_t) -1) {
 		if ((old_rgid == egid) ||
@@ -572,7 +580,7 @@ asmlinkage long sys_setregid(gid_t rgid,
 		    capable(CAP_SETGID))
 			new_egid = egid;
 		else {
-			return -EPERM;
+			return audit_result(-EPERM);
 		}
 	}
 	if (new_egid != old_egid)
@@ -589,7 +597,7 @@ asmlinkage long sys_setregid(gid_t rgid,
 
 	ckrm_cb_gid();
 
-	return 0;
+	return audit_result(0);
 }
 
 /*
@@ -602,9 +610,11 @@ asmlinkage long sys_setgid(gid_t gid)
 	int old_egid = current->egid;
 	int retval;
 
+	audit_intercept(AUDIT_setgid, gid);
+
 	retval = security_task_setgid(gid, (gid_t)-1, (gid_t)-1, LSM_SETID_ID);
 	if (retval)
-		return retval;
+		return audit_result(retval);
 
 	if (capable(CAP_SETGID))
 	{
@@ -625,11 +635,11 @@ asmlinkage long sys_setgid(gid_t gid)
 		current->egid = current->fsgid = gid;
 	}
 	else
-		return -EPERM;
+		return audit_result(-EPERM);
 
 	ckrm_cb_gid();
 
-	return 0;
+	return audit_result(0);
 }
   
 static int set_user(uid_t new_ruid, int dumpclear)
@@ -678,9 +688,11 @@ asmlinkage long sys_setreuid(uid_t ruid,
 	int old_ruid, old_euid, old_suid, new_ruid, new_euid;
 	int retval;
 
+	audit_intercept(AUDIT_setreuid, ruid, euid);
+
 	retval = security_task_setuid(ruid, euid, (uid_t)-1, LSM_SETID_RE);
 	if (retval)
-		return retval;
+		return audit_result(retval);
 
 	new_ruid = old_ruid = current->uid;
 	new_euid = old_euid = current->euid;
@@ -691,7 +703,7 @@ asmlinkage long sys_setreuid(uid_t ruid,
 		if ((old_ruid != ruid) &&
 		    (current->euid != ruid) &&
 		    !capable(CAP_SETUID))
-			return -EPERM;
+			return audit_result(-EPERM);
 	}
 
 	if (euid != (uid_t) -1) {
@@ -700,11 +712,11 @@ asmlinkage long sys_setreuid(uid_t ruid,
 		    (current->euid != euid) &&
 		    (current->suid != euid) &&
 		    !capable(CAP_SETUID))
-			return -EPERM;
+			return audit_result(-EPERM);
 	}
 
 	if (new_ruid != old_ruid && set_user(new_ruid, new_euid != old_euid) < 0)
-		return -EAGAIN;
+		return audit_result(-EAGAIN);
 
 	if (new_euid != old_euid)
 	{
@@ -719,7 +731,7 @@ asmlinkage long sys_setreuid(uid_t ruid,
 
 	ckrm_cb_uid();
 
-	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RE);
+	return audit_result(security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RE));
 }
 
 
@@ -741,9 +753,11 @@ asmlinkage long sys_setuid(uid_t uid)
 	int old_ruid, old_suid, new_ruid, new_suid;
 	int retval;
 
+	audit_intercept(AUDIT_setuid, uid);
+
 	retval = security_task_setuid(uid, (uid_t)-1, (uid_t)-1, LSM_SETID_ID);
 	if (retval)
-		return retval;
+		return audit_result(retval);
 
 	old_ruid = new_ruid = current->uid;
 	old_suid = current->suid;
@@ -751,10 +765,10 @@ asmlinkage long sys_setuid(uid_t uid)
 	
 	if (capable(CAP_SETUID)) {
 		if (uid != old_ruid && set_user(uid, old_euid != uid) < 0)
-			return -EAGAIN;
+			return audit_result(-EAGAIN);
 		new_suid = uid;
 	} else if ((uid != current->uid) && (uid != new_suid))
-		return -EPERM;
+		return audit_result(-EPERM);
 
 	if (old_euid != uid)
 	{
@@ -766,7 +780,7 @@ asmlinkage long sys_setuid(uid_t uid)
 
 	ckrm_cb_uid();
 
-	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_ID);
+	return audit_result(security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_ID));
 }
 
 
@@ -781,24 +795,26 @@ asmlinkage long sys_setresuid(uid_t ruid
 	int old_suid = current->suid;
 	int retval;
 
+	audit_intercept(AUDIT_setresuid, ruid, euid, suid);
+
 	retval = security_task_setuid(ruid, euid, suid, LSM_SETID_RES);
 	if (retval)
-		return retval;
+		return audit_result(retval);
 
 	if (!capable(CAP_SETUID)) {
 		if ((ruid != (uid_t) -1) && (ruid != current->uid) &&
 		    (ruid != current->euid) && (ruid != current->suid))
-			return -EPERM;
+			return audit_result(-EPERM);
 		if ((euid != (uid_t) -1) && (euid != current->uid) &&
 		    (euid != current->euid) && (euid != current->suid))
-			return -EPERM;
+			return audit_result(-EPERM);
 		if ((suid != (uid_t) -1) && (suid != current->uid) &&
 		    (suid != current->euid) && (suid != current->suid))
-			return -EPERM;
+			return audit_result(-EPERM);
 	}
 	if (ruid != (uid_t) -1) {
 		if (ruid != current->uid && set_user(ruid, euid != current->euid) < 0)
-			return -EAGAIN;
+			return audit_result(-EAGAIN);
 	}
 	if (euid != (uid_t) -1) {
 		if (euid != current->euid)
@@ -814,7 +830,7 @@ asmlinkage long sys_setresuid(uid_t ruid
 
 	ckrm_cb_uid();
 
-	return security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RES);
+	return audit_result(security_task_post_setuid(old_ruid, old_euid, old_suid, LSM_SETID_RES));
 }
 
 asmlinkage long sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid)
@@ -835,20 +851,22 @@ asmlinkage long sys_setresgid(gid_t rgid
 {
 	int retval;
 
+	audit_intercept(AUDIT_setresgid, rgid, egid, sgid);
+
 	retval = security_task_setgid(rgid, egid, sgid, LSM_SETID_RES);
 	if (retval)
-		return retval;
+		return audit_result(retval);
 
 	if (!capable(CAP_SETGID)) {
 		if ((rgid != (gid_t) -1) && (rgid != current->gid) &&
 		    (rgid != current->egid) && (rgid != current->sgid))
-			return -EPERM;
+			return audit_result(-EPERM);
 		if ((egid != (gid_t) -1) && (egid != current->gid) &&
 		    (egid != current->egid) && (egid != current->sgid))
-			return -EPERM;
+			return audit_result(-EPERM);
 		if ((sgid != (gid_t) -1) && (sgid != current->gid) &&
 		    (sgid != current->egid) && (sgid != current->sgid))
-			return -EPERM;
+			return audit_result(-EPERM);
 	}
 	if (egid != (gid_t) -1) {
 		if (egid != current->egid)
@@ -866,7 +884,7 @@ asmlinkage long sys_setresgid(gid_t rgid
 
 	ckrm_cb_gid();
 
-	return 0;
+	return audit_result(0);
 }
 
 asmlinkage long sys_getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid)
@@ -891,9 +909,11 @@ asmlinkage long sys_setfsuid(uid_t uid)
 {
 	int old_fsuid;
 
+	audit_intercept(AUDIT_setfsuid, uid);
+
 	old_fsuid = current->fsuid;
 	if (security_task_setuid(uid, (uid_t)-1, (uid_t)-1, LSM_SETID_FS))
-		return old_fsuid;
+		return (void)audit_result(-EPERM), old_fsuid;
 
 	if (uid == current->uid || uid == current->euid ||
 	    uid == current->suid || uid == current->fsuid || 
@@ -909,6 +929,8 @@ asmlinkage long sys_setfsuid(uid_t uid)
 
 	security_task_post_setuid(old_fsuid, (uid_t)-1, (uid_t)-1, LSM_SETID_FS);
 
+	(void)audit_result(current->fsuid == uid ? 0 : -EPERM);
+
 	return old_fsuid;
 }
 
@@ -919,9 +941,11 @@ asmlinkage long sys_setfsgid(gid_t gid)
 {
 	int old_fsgid;
 
+	audit_intercept(AUDIT_setfsgid, gid);
+
 	old_fsgid = current->fsgid;
 	if (security_task_setgid(gid, (gid_t)-1, (gid_t)-1, LSM_SETID_FS))
-		return old_fsgid;
+		return (void)audit_result(-EPERM), old_fsgid;
 
 	if (gid == current->gid || gid == current->egid ||
 	    gid == current->sgid || gid == current->fsgid || 
@@ -934,6 +958,9 @@ asmlinkage long sys_setfsgid(gid_t gid)
 		}
 		current->fsgid = gid;
 	}
+
+	(void)audit_result(current->fsgid == gid ? 0 : -EPERM);
+
 	return old_fsgid;
 }
 
@@ -975,12 +1002,14 @@ asmlinkage long sys_setpgid(pid_t pid, p
 	struct task_struct *p;
 	int err = -EINVAL;
 
+	audit_intercept(AUDIT_setpgid, pid, pgid);
+
 	if (!pid)
 		pid = current->pid;
 	if (!pgid)
 		pgid = pid;
 	if (pgid < 0)
-		return -EINVAL;
+		return audit_result(-EINVAL);
 
 	/* From this point forward we keep holding onto the tasklist lock
 	 * so that our parent does not change from under us. -DaveM
@@ -1039,7 +1068,7 @@ ok_pgid:
 out:
 	/* All paths lead to here, thus we are safe. -DaveM */
 	write_unlock_irq(&tasklist_lock);
-	return err;
+	return audit_result(err);
 }
 
 asmlinkage long sys_getpgid(pid_t pid)
@@ -1097,8 +1126,10 @@ asmlinkage long sys_setsid(void)
 	struct pid *pid;
 	int err = -EPERM;
 
+	audit_intercept(AUDIT_setsid);
+
 	if (!thread_group_leader(current))
-		return -EINVAL;
+		return audit_result(-EINVAL);
 
 	write_lock_irq(&tasklist_lock);
 
@@ -1113,7 +1144,7 @@ asmlinkage long sys_setsid(void)
 	err = process_group(current);
 out:
 	write_unlock_irq(&tasklist_lock);
-	return err;
+	return audit_result(err);
 }
 
 /*
@@ -1327,20 +1358,23 @@ asmlinkage long sys_setgroups(int gidset
 	int retval;
 
 	if (!capable(CAP_SETGID))
-		return -EPERM;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-EPERM);
 	if ((unsigned)gidsetsize > NGROUPS_MAX)
-		return -EINVAL;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-EINVAL);
 
 	group_info = groups_alloc(gidsetsize);
 	if (!group_info)
-		return -ENOMEM;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-ENOMEM);
 	retval = groups_from_user(group_info, grouplist);
 	if (retval) {
 		put_group_info(group_info);
-		return retval;
+		audit_intercept(AUDIT_setgroups, NULL);
+		return audit_result(retval);
 	}
 
-	retval = set_current_groups(group_info);
+	audit_intercept(AUDIT_setgroups, group_info);
+
+	(void)audit_result(retval = set_current_groups(group_info));
 	put_group_info(group_info);
 
 	return retval;
@@ -1396,18 +1430,21 @@ asmlinkage long sys_sethostname(char __u
 	char tmp[__NEW_UTS_LEN];
 
 	if (!capable(CAP_SYS_ADMIN))
-		return -EPERM;
-	if (len < 0 || len > __NEW_UTS_LEN)
-		return -EINVAL;
-	down_write(&uts_sem);
-	errno = -EFAULT;
-	if (!copy_from_user(tmp, name, len)) {
-		memcpy(system_utsname.nodename, tmp, len);
-		system_utsname.nodename[len] = 0;
-		errno = 0;
+		errno = -EPERM;
+	else if (len < 0 || len > __NEW_UTS_LEN)
+		errno = -EINVAL;
+	else {
+		down_write(&uts_sem);
+		errno = -EFAULT;
+		if (!copy_from_user(tmp, name, len)) {
+			memcpy(system_utsname.nodename, tmp, len);
+			system_utsname.nodename[len] = 0;
+			errno = 0;
+		}
+		up_write(&uts_sem);
 	}
-	up_write(&uts_sem);
-	return errno;
+	audit_intercept(AUDIT_sethostname, errno ? NULL : tmp, len);
+	return audit_result(errno);
 }
 
 asmlinkage long sys_gethostname(char __user *name, int len)
@@ -1437,19 +1474,21 @@ asmlinkage long sys_setdomainname(char _
 	char tmp[__NEW_UTS_LEN];
 
 	if (!capable(CAP_SYS_ADMIN))
-		return -EPERM;
-	if (len < 0 || len > __NEW_UTS_LEN)
-		return -EINVAL;
-
-	down_write(&uts_sem);
-	errno = -EFAULT;
-	if (!copy_from_user(tmp, name, len)) {
-		memcpy(system_utsname.domainname, tmp, len);
-		system_utsname.domainname[len] = 0;
-		errno = 0;
+		errno = -EPERM;
+	else if (len < 0 || len > __NEW_UTS_LEN)
+		errno = -EINVAL;
+	else {
+		down_write(&uts_sem);
+		errno = -EFAULT;
+		if (!copy_from_user(tmp, name, len)) {
+			memcpy(system_utsname.domainname, tmp, len);
+			system_utsname.domainname[len] = 0;
+			errno = 0;
+		}
+		up_write(&uts_sem);
 	}
-	up_write(&uts_sem);
-	return errno;
+	audit_intercept(AUDIT_setdomainname, errno ? NULL : tmp, len);
+	return audit_result(errno);
 }
 
 asmlinkage long sys_getrlimit(unsigned int resource, struct rlimit __user *rlim)
@@ -1489,27 +1528,28 @@ asmlinkage long sys_setrlimit(unsigned i
 	int retval;
 
 	if (resource >= RLIM_NLIMITS)
-		return -EINVAL;
+		return audit_intercept(AUDIT_setrlimit, resource, NULL), audit_result(-EINVAL);
 	if(copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
 		return -EFAULT;
-       if (new_rlim.rlim_cur > new_rlim.rlim_max)
-               return -EINVAL;
+
+	audit_intercept(AUDIT_setrlimit, resource, &new_rlim);
+
+	if (new_rlim.rlim_cur > new_rlim.rlim_max)
+		return audit_result(-EINVAL);
 	old_rlim = current->rlim + resource;
 	if (((new_rlim.rlim_cur > old_rlim->rlim_max) ||
 	     (new_rlim.rlim_max > old_rlim->rlim_max)) &&
 	    !capable(CAP_SYS_RESOURCE))
-		return -EPERM;
+		return audit_result(-EPERM);
 	if (resource == RLIMIT_NOFILE) {
 		if (new_rlim.rlim_cur > NR_OPEN || new_rlim.rlim_max > NR_OPEN)
-			return -EPERM;
+			return audit_result(-EPERM);
 	}
 
 	retval = security_task_setrlimit(resource, &new_rlim);
-	if (retval)
-		return retval;
-
-	*old_rlim = new_rlim;
-	return 0;
+	if (!retval)
+		*old_rlim = new_rlim;
+	return audit_result(retval);
 }
 
 /*
@@ -1573,8 +1613,9 @@ asmlinkage long sys_getrusage(int who, s
 
 asmlinkage long sys_umask(int mask)
 {
+	audit_intercept(AUDIT_umask, mask);
 	mask = xchg(&current->fs->umask, mask & S_IRWXUGO);
-	return mask;
+	return audit_result(mask);
 }
     
 asmlinkage long sys_prctl(int option, unsigned long arg2, unsigned long arg3,
diff -urNp linux-2.6.5/kernel/time.c linux-2.6.5.SUSE/kernel/time.c
--- linux-2.6.5/kernel/time.c	2004-04-22 16:10:48.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/time.c	2004-04-22 16:11:15.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/timex.h>
 #include <linux/errno.h>
 #include <linux/smp_lock.h>
+#include <linux/audit.h>
 #include <asm/uaccess.h>
 
 /* 
@@ -75,13 +76,14 @@ asmlinkage long sys_stime(time_t *tptr)
 	struct timespec tv;
 
 	if (!capable(CAP_SYS_TIME))
-		return -EPERM;
+		return audit_intercept(AUDIT_settimeofday, NULL, NULL), audit_result(-EPERM);
 	if (get_user(tv.tv_sec, tptr))
 		return -EFAULT;
 
 	tv.tv_nsec = 0;
+	audit_intercept(AUDIT_settimeofday, &tv, NULL);
 	do_settimeofday(&tv);
-	return 0;
+	return audit_result(0);
 }
 
 #endif
@@ -142,8 +144,10 @@ int do_sys_settimeofday(struct timespec 
 {
 	static int firsttime = 1;
 
+	audit_intercept(AUDIT_settimeofday, tv, tz);
+
 	if (!capable(CAP_SYS_TIME))
-		return -EPERM;
+		return audit_result(-EPERM);
 		
 	if (tz) {
 		/* SMP safe, global irq locking makes it work. */
@@ -159,9 +163,9 @@ int do_sys_settimeofday(struct timespec 
 		/* SMP safe, again the code in arch/foo/time.c should
 		 * globally block out interrupts when it runs.
 		 */
-		return do_settimeofday(tv);
+		return audit_result(do_settimeofday(tv));
 	}
-	return 0;
+	return audit_result(0);
 }
 
 asmlinkage long sys_settimeofday(struct timeval __user *tv,
@@ -211,27 +215,29 @@ int do_adjtimex(struct timex *txc)
         long ltemp, mtemp, save_adjust;
 	int result;
 
+	audit_intercept(AUDIT_adjtimex, txc);
+
 	/* In order to modify anything, you gotta be super-user! */
 	if (txc->modes && !capable(CAP_SYS_TIME))
-		return -EPERM;
+		return audit_result(-EPERM);
 		
 	/* Now we validate the data before disabling interrupts */
 
 	if ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT)
 	  /* singleshot must not be used with any other mode bits */
 		if (txc->modes != ADJ_OFFSET_SINGLESHOT)
-			return -EINVAL;
+			return audit_result(-EINVAL);
 
 	if (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))
 	  /* adjustment Offset limited to +- .512 seconds */
 		if (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )
-			return -EINVAL;	
+			return audit_result(-EINVAL);	
 
 	/* if the quartz is off by more than 10% something is VERY wrong ! */
 	if (txc->modes & ADJ_TICK)
 		if (txc->tick <  900000/USER_HZ ||
 		    txc->tick > 1100000/USER_HZ)
-			return -EINVAL;
+			return audit_result(-EINVAL);
 
 	write_seqlock_irq(&xtime_lock);
 	result = time_state;	/* mostly `TIME_OK' */
@@ -386,7 +392,7 @@ leave:	if ((time_status & (STA_UNSYNC|ST
 	txc->stbcnt	   = pps_stbcnt;
 	write_sequnlock_irq(&xtime_lock);
 	do_gettimeofday(&txc->time);
-	return(result);
+	return audit_result(result);
 }
 
 asmlinkage long sys_adjtimex(struct timex __user *txc_p)
diff -urNp linux-2.6.5/kernel/uid16.c linux-2.6.5.SUSE/kernel/uid16.c
--- linux-2.6.5/kernel/uid16.c	2004-04-04 05:37:07.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/uid16.c	2004-04-22 16:11:15.000000000 +0200
@@ -14,6 +14,7 @@
 #include <linux/highuid.h>
 #include <linux/security.h>
 #include <linux/syscalls.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 
@@ -156,20 +157,23 @@ asmlinkage long sys_setgroups16(int gids
 	int retval;
 
 	if (!capable(CAP_SETGID))
-		return -EPERM;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-EPERM);
 	if ((unsigned)gidsetsize > NGROUPS_MAX)
-		return -EINVAL;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-EINVAL);
 
 	group_info = groups_alloc(gidsetsize);
 	if (!group_info)
-		return -ENOMEM;
+		return audit_intercept(AUDIT_setgroups, NULL), audit_result(-ENOMEM);
 	retval = groups16_from_user(group_info, grouplist);
 	if (retval) {
 		put_group_info(group_info);
-		return retval;
+		audit_intercept(AUDIT_setgroups, NULL);
+		return audit_result(retval);
 	}
 
-	retval = set_current_groups(group_info);
+	audit_intercept(AUDIT_setgroups, group_info);
+
+	(void)audit_result(retval = set_current_groups(group_info));
 	put_group_info(group_info);
 
 	return retval;
diff -urNp linux-2.6.5/mm/mmap.c linux-2.6.5.SUSE/mm/mmap.c
--- linux-2.6.5/mm/mmap.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/mm/mmap.c	2004-04-22 16:11:15.000000000 +0200
@@ -32,6 +32,7 @@
 #include <linux/module.h>
 #include <linux/mount.h>
 #include <linux/objrmap.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -123,6 +124,8 @@ asmlinkage unsigned long sys_brk(unsigne
 	unsigned long newbrk, oldbrk;
 	struct mm_struct *mm = current->mm;
 
+	audit_intercept(AUDIT_brk, brk);
+
 	down_write(&mm->mmap_sem);
 
 	if (brk < mm->end_code)
@@ -156,7 +159,7 @@ set_brk:
 out:
 	retval = mm->brk;
 	up_write(&mm->mmap_sem);
-	return retval;
+	return audit_lresult(retval);
 }
 
 #ifdef DEBUG_MM_RB
diff -urNp linux-2.6.5/mm/nommu.c linux-2.6.5.SUSE/mm/nommu.c
--- linux-2.6.5/mm/nommu.c	2004-04-22 16:10:54.000000000 +0200
+++ linux-2.6.5.SUSE/mm/nommu.c	2004-04-22 16:11:15.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/blkdev.h>
+#include <linux/audit.h>
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -204,24 +205,26 @@ asmlinkage unsigned long sys_brk(unsigne
 {
 	struct mm_struct *mm = current->mm;
 
+	audit_intercept(AUDIT_brk, brk);
+
 	if (brk < mm->end_code || brk < mm->start_brk || brk > mm->context.end_brk)
-		return mm->brk;
+		return audit_lresult(mm->brk);
 
 	if (mm->brk == brk)
-		return mm->brk;
+		return audit_lresult(mm->brk);
 
 	/*
 	 * Always allow shrinking brk
 	 */
 	if (brk <= mm->brk) {
 		mm->brk = brk;
-		return brk;
+		return audit_lresult(brk);
 	}
 
 	/*
 	 * Ok, looks good - let it rip.
 	 */
-	return mm->brk = brk;
+	return audit_lresult(mm->brk = brk);
 }
 
 /*
diff -urNp linux-2.6.5/mm/swapfile.c linux-2.6.5.SUSE/mm/swapfile.c
--- linux-2.6.5/mm/swapfile.c	2004-04-22 16:10:55.000000000 +0200
+++ linux-2.6.5.SUSE/mm/swapfile.c	2004-04-22 16:11:15.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/objrmap.h>
 #include <linux/security.h>
 #include <linux/backing-dev.h>
+#include <linux/audit.h>
 
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
@@ -1073,12 +1074,13 @@ asmlinkage long sys_swapoff(const char _
 	int err;
 	
 	if (!capable(CAP_SYS_ADMIN))
-		return -EPERM;
+		return audit_intercept(AUDIT_swapoff, NULL), audit_result(-EPERM);
 
 	pathname = getname(specialfile);
-	err = PTR_ERR(pathname);
 	if (IS_ERR(pathname))
-		goto out;
+		return PTR_ERR(pathname);
+
+	audit_intercept(AUDIT_swapoff, pathname);
 
 	victim = filp_open(pathname, O_RDWR, 0);
 	putname(pathname);
@@ -1170,6 +1172,7 @@ asmlinkage long sys_swapoff(const char _
 out_dput:
 	filp_close(victim, NULL);
 out:
+	(void)audit_result(err);
 	return err;
 }
 
@@ -1292,7 +1295,7 @@ asmlinkage long sys_swapon(const char __
 	int did_down = 0;
 
 	if (!capable(CAP_SYS_ADMIN))
-		return -EPERM;
+		return audit_intercept(AUDIT_swapon, NULL, swap_flags), audit_result(-EPERM);
 	swap_list_lock();
 	p = swap_info;
 	for (type = 0 ; type < nr_swapfiles ; type++,p++)
@@ -1313,6 +1316,7 @@ asmlinkage long sys_swapon(const char __
 	 */
 	if (type > swp_type(pte_to_swp_entry(swp_entry_to_pte(swp_entry(~0UL,0))))) {
 		swap_list_unlock();
+		audit_intercept(AUDIT_swapon, NULL, swap_flags);
 		goto out;
 	}
 	if (type >= nr_swapfiles)
@@ -1338,10 +1342,11 @@ asmlinkage long sys_swapon(const char __
 	swap_list_unlock();
 	name = getname(specialfile);
 	error = PTR_ERR(name);
-	if (IS_ERR(name)) {
+	if (IS_ERR(name))
 		name = NULL;
+	audit_intercept(AUDIT_swapon, name, swap_flags);
+	if (!name)
 		goto bad_swap_2;
-	}
 	swap_file = filp_open(name, O_RDWR, 0);
 	error = PTR_ERR(swap_file);
 	if (IS_ERR(swap_file)) {
@@ -1544,13 +1549,14 @@ bad_swap_2:
 	destroy_swap_extents(p);
 	if (swap_map)
 		vfree(swap_map);
-	if (swap_file && !IS_ERR(swap_file))
+	if (swap_file)
 		filp_close(swap_file, NULL);
 out:
 	if (page && !IS_ERR(page)) {
 		kunmap(page);
 		page_cache_release(page);
 	}
+	(void)audit_result(error);
 	if (name)
 		putname(name);
 	if (error && did_down)
diff -urNp linux-2.6.5/net/core/rtnetlink.c linux-2.6.5.SUSE/net/core/rtnetlink.c
--- linux-2.6.5/net/core/rtnetlink.c	2004-04-04 05:38:28.000000000 +0200
+++ linux-2.6.5.SUSE/net/core/rtnetlink.c	2004-04-22 16:11:15.000000000 +0200
@@ -36,6 +36,7 @@
 #include <linux/skbuff.h>
 #include <linux/init.h>
 #include <linux/security.h>
+#include <linux/audit.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -468,6 +469,7 @@ static inline int rtnetlink_rcv_skb(stru
 		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
 		if (rlen > skb->len)
 			rlen = skb->len;
+		err = 0;
 		if (rtnetlink_rcv_msg(skb, nlh, &err)) {
 			/* Not error, but we must interrupt processing here:
 			 *   Note, that in this case we do not pull message
@@ -478,6 +480,11 @@ static inline int rtnetlink_rcv_skb(stru
 			netlink_ack(skb, nlh, err);
 		} else if (nlh->nlmsg_flags&NLM_F_ACK)
 			netlink_ack(skb, nlh, 0);
+
+#if defined(CONFIG_AUDIT) || defined(CONFIG_AUDIT_MODULE)
+		audit_netlink_msg(skb, err);
+#endif
+
 		skb_pull(skb, rlen);
 	}
 
diff -urNp linux-2.6.5/net/socket.c linux-2.6.5.SUSE/net/socket.c
--- linux-2.6.5/net/socket.c	2004-04-04 05:36:56.000000000 +0200
+++ linux-2.6.5.SUSE/net/socket.c	2004-04-22 16:11:15.000000000 +0200
@@ -81,6 +81,7 @@
 #include <linux/syscalls.h>
 #include <linux/compat.h>
 #include <linux/kmod.h>
+#include <linux/audit.h>
 
 #ifdef CONFIG_NET_RADIO
 #include <linux/wireless.h>		/* Note : will define WIRELESS_EXT */
@@ -1092,6 +1093,8 @@ asmlinkage long sys_socket(int family, i
 	int retval;
 	struct socket *sock;
 
+	audit_intercept(AUDIT_socket, family, type, protocol);
+
 	retval = sock_create(family, type, protocol, &sock);
 	if (retval < 0)
 		goto out;
@@ -1102,11 +1105,11 @@ asmlinkage long sys_socket(int family, i
 
 out:
 	/* It may be already another descriptor 8) Not kernel problem. */
-	return retval;
+	return audit_result(retval);
 
 out_release:
 	sock_release(sock);
-	return retval;
+	return audit_result(retval);
 }
 
 /*
@@ -1192,16 +1195,21 @@ asmlinkage long sys_bind(int fd, struct 
 	if((sock = sockfd_lookup(fd,&err))!=NULL)
 	{
 		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
+			audit_intercept(AUDIT_bind, fd, address, addrlen);
 			err = security_socket_bind(sock, (struct sockaddr *)address, addrlen);
 			if (err) {
 				sockfd_put(sock);
-				return err;
+				return audit_result(err);
 			}
 			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
 		}
+		else
+			audit_intercept(AUDIT_bind, fd, NULL, addrlen);
 		sockfd_put(sock);
-	}			
-	return err;
+	}
+	else
+		audit_intercept(AUDIT_bind, fd, NULL, 0);
+	return audit_result(err);
 }
 
 
