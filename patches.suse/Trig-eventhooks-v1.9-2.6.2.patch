Index: linux.t/fs/exec.c
===================================================================
--- linux.t.orig/fs/exec.c	2004-03-22 20:22:54.997201327 -0500
+++ linux.t/fs/exec.c	2004-03-22 20:24:38.807596685 -0500
@@ -47,6 +47,7 @@
 #include <linux/syscalls.h>
 #include <linux/objrmap.h>
 #include <linux/ckrm.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -1151,6 +1152,9 @@ int do_execve(char * filename,
 
 	retval = search_binary_handler(&bprm,regs);
 	if (retval >= 0) {
+		TRIG_EVENT(exec_hook, file->f_dentry->d_name.len,
+			file->f_dentry->d_name.name, regs);
+
 		free_arg_pages(&bprm);
 
 		ckrm_cb_exec(filename);
Index: linux.t/fs/open.c
===================================================================
--- linux.t.orig/fs/open.c	2004-03-22 20:22:27.008450679 -0500
+++ linux.t/fs/open.c	2004-03-22 20:23:56.952937024 -0500
@@ -22,6 +22,7 @@
 #include <asm/uaccess.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
+#include <linux/trigevent_hooks.h>
 
 int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
 {
@@ -944,6 +945,9 @@ asmlinkage long sys_open(const char __us
 			error = PTR_ERR(f);
 			if (IS_ERR(f))
 				goto out_error;
+			TRIG_EVENT(open_hook, fd,
+				  f->f_dentry->d_name.len,
+				  f->f_dentry->d_name.name); 
 			fd_install(fd, f);
 		}
 out:
@@ -1019,6 +1023,7 @@ asmlinkage long sys_close(unsigned int f
 	filp = files->fd[fd];
 	if (!filp)
 		goto out_unlock;
+	TRIG_EVENT(close_hook, fd);
 	files->fd[fd] = NULL;
 	FD_CLR(fd, files->close_on_exec);
 	__put_unused_fd(files, fd);
Index: linux.t/fs/select.c
===================================================================
--- linux.t.orig/fs/select.c	2004-03-22 20:22:22.229859771 -0500
+++ linux.t/fs/select.c	2004-03-22 20:23:56.953936729 -0500
@@ -22,6 +22,7 @@
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/aio.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 
@@ -254,6 +255,7 @@ int do_select(int n, fd_set_bits *fds, l
 					continue;
 				file = fget(i);
 				if (file) {
+					TRIG_EVENT(select_hook, i, __timeout);
 					f_op = file->f_op;
 					mask = DEFAULT_POLLMASK;
 					if (f_op && f_op->poll)
@@ -441,6 +443,7 @@ static void do_pollfd(unsigned int num, 
 			struct file * file = fget(fd);
 			mask = POLLNVAL;
 			if (file != NULL) {
+				TRIG_EVENT(poll_hook, fd);
 				mask = DEFAULT_POLLMASK;
 				if (file->f_op && file->f_op->poll)
 					mask = file->f_op->poll(file, *pwait);
Index: linux.t/fs/buffer.c
===================================================================
--- linux.t.orig/fs/buffer.c	2004-03-22 20:22:28.252083943 -0500
+++ linux.t/fs/buffer.c	2004-03-22 20:23:56.947938497 -0500
@@ -37,6 +37,8 @@
 #include <linux/bio.h>
 #include <linux/notifier.h>
 #include <linux/cpu.h>
+#include <linux/trigevent_hooks.h>
+
 #include <asm/bitops.h>
 
 static void invalidate_bh_lrus(void);
@@ -130,6 +132,7 @@ void __wait_on_buffer(struct buffer_head
 		buffer_error();
 
 	do {
+		TRIG_EVENT(buf_wait_start_hook, bh);
 		prepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);
 		if (buffer_locked(bh)) {
 			struct block_device *bd;
@@ -140,6 +143,7 @@ void __wait_on_buffer(struct buffer_head
 			io_schedule();
 		}
 	} while (buffer_locked(bh));
+	TRIG_EVENT(buf_wait_end_hook, bh);
 	finish_wait(wqh, &wait);
 }
 
Index: linux.t/fs/ioctl.c
===================================================================
--- linux.t.orig/fs/ioctl.c	2004-02-05 16:56:29.000000000 -0500
+++ linux.t/fs/ioctl.c	2004-03-22 20:23:56.950937613 -0500
@@ -9,6 +9,7 @@
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/security.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
@@ -64,6 +65,7 @@ asmlinkage long sys_ioctl(unsigned int f
                 goto out;
         }
 
+	TRIG_EVENT(ioctl_hook, fd, cmd);
 	lock_kernel();
 	switch (cmd) {
 		case FIOCLEX:
Index: linux.t/fs/read_write.c
===================================================================
--- linux.t.orig/fs/read_write.c	2004-03-22 20:22:19.832566636 -0500
+++ linux.t/fs/read_write.c	2004-03-22 20:23:56.953936729 -0500
@@ -13,6 +13,7 @@
 #include <linux/dnotify.h>
 #include <linux/security.h>
 #include <linux/module.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 
@@ -140,6 +141,7 @@ asmlinkage off_t sys_lseek(unsigned int 
 			retval = -EOVERFLOW;	/* LFS: should only happen on 32 bit platforms */
 	}
 	fput_light(file, fput_needed);
+	TRIG_EVENT(lseek_hook, fd, offset);
 bad:
 	return retval;
 }
@@ -167,6 +169,8 @@ asmlinkage long sys_llseek(unsigned int 
 	offset = llseek(file, ((loff_t) offset_high << 32) | offset_low,
 			origin);
 
+	TRIG_EVENT(llseek_hook, fd, offset);
+
 	retval = (int)offset;
 	if (offset >= 0) {
 		retval = -EFAULT;
@@ -276,6 +280,7 @@ asmlinkage ssize_t sys_read(unsigned int
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
+		TRIG_EVENT(read_hook, fd, count);
 		ret = vfs_read(file, buf, count, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
@@ -292,6 +297,7 @@ asmlinkage ssize_t sys_write(unsigned in
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
+		TRIG_EVENT(write_hook, fd, count);
 		ret = vfs_write(file, buf, count, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
@@ -311,6 +317,7 @@ asmlinkage ssize_t sys_pread64(unsigned 
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
+		TRIG_EVENT(read_hook, fd, count);
 		ret = vfs_read(file, buf, count, &pos);
 		fput_light(file, fput_needed);
 	}
@@ -330,6 +337,7 @@ asmlinkage ssize_t sys_pwrite64(unsigned
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
+		TRIG_EVENT(write_hook, fd, count);
 		ret = vfs_write(file, buf, count, &pos);
 		fput_light(file, fput_needed);
 	}
@@ -514,6 +522,7 @@ sys_readv(unsigned long fd, const struct
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
+		TRIG_EVENT(read_hook, fd, vlen);
 		ret = vfs_readv(file, vec, vlen, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
@@ -530,6 +539,7 @@ sys_writev(unsigned long fd, const struc
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
+		TRIG_EVENT(write_hook, fd, vlen);
 		ret = vfs_writev(file, vec, vlen, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
Index: linux.t/mm/filemap.c
===================================================================
--- linux.t.orig/mm/filemap.c	2004-03-22 20:22:28.275077162 -0500
+++ linux.t/mm/filemap.c	2004-03-22 20:23:56.980928774 -0500
@@ -27,6 +27,8 @@
 #include <linux/pagevec.h>
 #include <linux/blkdev.h>
 #include <linux/security.h>
+#include <linux/trigevent_hooks.h>
+
 /*
  * This is needed for the following functions:
  *  - try_to_release_page
@@ -325,6 +327,7 @@ int fastcall wait_on_page_bit_wq(struct 
 	if (!wait)
 		wait = &local_wait; /* default to a sync wait entry */
 
+	TRIG_EVENT(page_wait_start_hook, page);
 	do {
 		prepare_to_wait(waitqueue, wait, TASK_UNINTERRUPTIBLE);
 		if (test_bit(bit_nr, &page->flags)) {
@@ -342,6 +345,7 @@ int fastcall wait_on_page_bit_wq(struct 
 		}
 	} while (test_bit(bit_nr, &page->flags));
 	finish_wait(waitqueue, wait);
+	TRIG_EVENT(page_wait_end_hook, page);
 
 	return 0;
 }
Index: linux.t/mm/page_io.c
===================================================================
--- linux.t.orig/mm/page_io.c	2004-03-22 20:22:28.290072740 -0500
+++ linux.t/mm/page_io.c	2004-03-22 20:23:56.986927006 -0500
@@ -19,6 +19,8 @@
 #include <linux/buffer_head.h>	/* for block_sync_page() */
 #include <linux/mpage.h>
 #include <linux/writeback.h>
+#include <linux/trigevent_hooks.h>
+
 #include <asm/pgtable.h>
 
 static struct bio *
@@ -103,6 +105,9 @@ int swap_writepage(struct page *page, st
 		ret = -ENOMEM;
 		goto out;
 	}
+
+	TRIG_EVENT(mm_swap_out_hook, page);
+
 	inc_page_state(pswpout);
 	set_page_writeback(page);
 	unlock_page(page);
Index: linux.t/mm/page_alloc.c
===================================================================
--- linux.t.orig/mm/page_alloc.c	2004-03-22 20:22:28.289073035 -0500
+++ linux.t/mm/page_alloc.c	2004-03-22 20:23:56.986927006 -0500
@@ -31,6 +31,7 @@
 #include <linux/topology.h>
 #include <linux/sysctl.h>
 #include <linux/cpu.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/tlbflush.h>
 
@@ -282,6 +283,8 @@ void __free_pages_ok(struct page *page, 
 	LIST_HEAD(list);
 	int i;
 
+	TRIG_EVENT(mm_page_free_hook, order);
+
 	arch_free_page(page, order);
 
 	mod_page_state(pgfree, 1 << order);
@@ -761,6 +764,7 @@ fastcall unsigned long __get_free_pages(
 	page = alloc_pages(gfp_mask, order);
 	if (!page)
 		return 0;
+	TRIG_EVENT(mm_page_alloc_hook, order);
 	return (unsigned long) page_address(page);
 }
 
Index: linux.t/mm/mmap.c
===================================================================
--- linux.t.orig/mm/mmap.c	2004-03-22 20:22:28.280075688 -0500
+++ linux.t/mm/mmap.c	2004-03-22 20:23:56.984927595 -0500
@@ -32,6 +32,7 @@
 #include <linux/module.h>
 #include <linux/mount.h>
 #include <linux/objrmap.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -284,6 +285,7 @@ __vma_link(struct mm_struct *mm, struct 
 	__vma_link_rb(mm, vma, rb_link, rb_parent);
 	__vma_link_file(vma);
 	__anon_vma_link(vma);
+	TRIG_EVENT(mmap_hook, vma);
 }
 
 static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,
Index: linux.t/mm/memory.c
===================================================================
--- linux.t.orig/mm/memory.c	2004-03-22 20:23:24.539491191 -0500
+++ linux.t/mm/memory.c	2004-03-22 20:23:56.982928184 -0500
@@ -47,6 +47,8 @@
 #include <linux/module.h>
 #include <linux/init.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
 #include <asm/tlb.h>
@@ -1239,6 +1241,7 @@ static int do_swap_page(struct mm_struct
 	ret = VM_FAULT_MINOR;
 	page = lookup_swap_cache(entry);
 	if (!page) {
+	        TRIG_EVENT(mm_swap_in_hook, address);
 		swapin_readahead(entry);
 		page = read_swap_cache_async(entry);
 		if (!page) {
Index: linux.t/ipc/msg.c
===================================================================
--- linux.t.orig/ipc/msg.c	2004-02-05 16:56:36.000000000 -0500
+++ linux.t/ipc/msg.c	2004-03-22 20:23:56.958935256 -0500
@@ -28,6 +28,8 @@
 #include <asm/uaccess.h>
 #include "util.h"
 
+#include <linux/trigevent_hooks.h>
+
 /* sysctl: */
 int msg_ctlmax = MSGMAX;
 int msg_ctlmnb = MSGMNB;
@@ -331,6 +333,7 @@ asmlinkage long sys_msgget (key_t key, i
 		msg_unlock(msq);
 	}
 	up(&msg_ids.sem);
+	TRIG_EVENT(ipc_msg_create_hook, ret, msgflg);
 	return ret;
 }
 
Index: linux.t/ipc/sem.c
===================================================================
--- linux.t.orig/ipc/sem.c	2004-03-22 20:22:10.893202242 -0500
+++ linux.t/ipc/sem.c	2004-03-22 20:23:56.960934667 -0500
@@ -74,6 +74,7 @@
 #include <asm/uaccess.h>
 #include "util.h"
 
+#include <linux/trigevent_hooks.h>
 
 #define sem_lock(id)	((struct sem_array*)ipc_lock(&sem_ids,id))
 #define sem_unlock(sma)	ipc_unlock(&(sma)->sem_perm)
@@ -238,6 +239,7 @@ asmlinkage long sys_semget (key_t key, i
 	}
 
 	up(&sem_ids.sem);
+	TRIG_EVENT(ipc_sem_create_hook, err, semflg);
 	return err;
 }
 
Index: linux.t/ipc/shm.c
===================================================================
--- linux.t.orig/ipc/shm.c	2004-03-22 20:22:26.321653205 -0500
+++ linux.t/ipc/shm.c	2004-03-22 20:23:56.961934372 -0500
@@ -26,6 +26,8 @@
 #include <linux/proc_fs.h>
 #include <linux/shmem_fs.h>
 #include <linux/security.h>
+#include <linux/trigevent_hooks.h>
+
 #include <asm/uaccess.h>
 
 #include "util.h"
@@ -267,6 +269,7 @@ asmlinkage long sys_shmget (key_t key, s
 	}
 	up(&shm_ids.sem);
 
+	TRIG_EVENT(ipc_shm_create_hook, err, shmflg);
 	return err;
 }
 
Index: linux.t/net/core/dev.c
===================================================================
--- linux.t.orig/net/core/dev.c	2004-03-22 20:22:25.790809742 -0500
+++ linux.t/net/core/dev.c	2004-03-22 20:23:56.990925827 -0500
@@ -111,6 +111,8 @@
 #include <linux/wireless.h>		/* Note : will define WIRELESS_EXT */
 #include <net/iw_handler.h>
 #endif	/* CONFIG_NET_RADIO */
+#include <linux/trigevent_hooks.h>
+
 #include <asm/current.h>
 
 /* This define, if set, will randomly drop a packet when congestion
@@ -1313,6 +1315,8 @@ int dev_queue_xmit(struct sk_buff *skb)
 			goto out;
 	}
 
+	TRIG_EVENT(net_pkt_out_hook, skb->protocol);
+
 	/* Grab device queue */
 	spin_lock_bh(&dev->queue_lock);
 	q = dev->qdisc;
@@ -1714,6 +1718,8 @@ int netif_receive_skb(struct sk_buff *sk
 
 	skb_bond(skb);
 
+	TRIG_EVENT(net_pkt_in_hook, skb->protocol);
+
 	__get_cpu_var(netdev_rx_stat).total++;
 
 #ifdef CONFIG_NET_FASTROUTE
Index: linux.t/net/socket.c
===================================================================
--- linux.t.orig/net/socket.c	2004-03-11 14:13:22.000000000 -0500
+++ linux.t/net/socket.c	2004-03-22 20:23:56.993924943 -0500
@@ -81,6 +81,7 @@
 #include <linux/syscalls.h>
 #include <linux/compat.h>
 #include <linux/kmod.h>
+#include <linux/trigevent_hooks.h>
 
 #ifdef CONFIG_NET_RADIO
 #include <linux/wireless.h>		/* Note : will define WIRELESS_EXT */
@@ -549,6 +550,9 @@ int sock_sendmsg(struct socket *sock, st
 	int ret;
 
 	init_sync_kiocb(&iocb, NULL);
+
+	TRIG_EVENT(sk_send_hook, sock->type, size);
+
 	ret = __sock_sendmsg(&iocb, sock, msg, size);
 	if (-EIOCBQUEUED == ret)
 		ret = wait_on_sync_kiocb(&iocb);
@@ -582,6 +586,9 @@ int sock_recvmsg(struct socket *sock, st
 	int ret;
 
         init_sync_kiocb(&iocb, NULL);
+
+	TRIG_EVENT(sk_receive_hook, sock->type, size);
+
 	ret = __sock_recvmsg(&iocb, sock, msg, size, flags);
 	if (-EIOCBQUEUED == ret)
 		ret = wait_on_sync_kiocb(&iocb);
@@ -1100,6 +1107,8 @@ asmlinkage long sys_socket(int family, i
 	if (retval < 0)
 		goto out_release;
 
+	TRIG_EVENT(sk_create_hook, retval, type);
+
 out:
 	/* It may be already another descriptor 8) Not kernel problem. */
 	return retval;
@@ -1817,6 +1826,8 @@ asmlinkage long sys_socketcall(int call,
 		
 	a0=a[0];
 	a1=a[1];
+
+	TRIG_EVENT(sk_call_hook, call, a0);
 	
 	switch(call) 
 	{
Index: linux.t/arch/sh/mm/fault.c
===================================================================
--- linux.t.orig/arch/sh/mm/fault.c	2004-02-18 15:20:36.000000000 -0500
+++ linux.t/arch/sh/mm/fault.c	2004-03-22 20:23:56.937941443 -0500
@@ -22,6 +22,8 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/system.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -54,6 +56,14 @@ asmlinkage void do_page_fault(struct pt_
 	tsk = current;
 	mm = tsk->mm;
 
+#if (CONFIG_TRIGEVENT_HOOKS)
+	{
+		unsigned long trapnr;
+		asm volatile("stc       r2_bank,%0": "=r" (trapnr));
+		TRIG_EVENT(trap_entry_hook, trapnr >> 5, regs->pc);  /* trap 4,5 or 6 */
+	}
+#endif
+
 	/*
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
@@ -107,6 +117,7 @@ survive:
 	}
 
 	up_read(&mm->mmap_sem);
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 /*
@@ -120,13 +131,16 @@ bad_area:
 		tsk->thread.address = address;
 		tsk->thread.error_code = writeaccess;
 		force_sig(SIGSEGV, tsk);
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 no_context:
 	/* Are we prepared to handle this kernel fault?  */
-	if (fixup_exception(regs))
+	if (fixup_exception(regs)) {
+		TRIG_EVENT(trap_exit_hook);
 		return;
+	}
 
 /*
  * Oops. The kernel tried to access some bad page. We'll have to
@@ -186,6 +200,8 @@ do_sigbus:
 	/* Kernel mode? Handle exceptions or die */
 	if (!user_mode(regs))
 		goto no_context;
+
+	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
Index: linux.t/arch/sh/Kconfig
===================================================================
--- linux.t.orig/arch/sh/Kconfig	2004-03-22 20:23:56.796982989 -0500
+++ linux.t/arch/sh/Kconfig	2004-03-22 20:23:56.931943211 -0500
@@ -1118,6 +1118,32 @@ config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
 
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
+config TRIGEVENT_SYSCALL_HOOK
+	bool " Enable syscall entry/exit hooks"
+	depends on TRIGEVENT_HOOKS
+	help 
+	RAS hooks to enable tracing of system call entry and exit points.
+	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/sh/kernel/irq.c
===================================================================
--- linux.t.orig/arch/sh/kernel/irq.c	2004-02-18 15:20:36.000000000 -0500
+++ linux.t/arch/sh/kernel/irq.c	2004-03-22 20:23:56.933942622 -0500
@@ -32,6 +32,8 @@
 #include <linux/seq_file.h>
 #include <linux/kallsyms.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/system.h>
 #include <asm/io.h>
 #include <asm/bitops.h>
@@ -139,6 +141,12 @@ int handle_IRQ_event(unsigned int irq, s
 	int status = 1;	/* Force the "do bottom halves" bit */
 	int retval = 0;
 
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	if (irq != TIMER_IRQ) { /* avoid double-reporting the timer IRQ */
+		TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
+	}
+#endif
+
 	if (!(action->flags & SA_INTERRUPT))
 		local_irq_enable();
 
@@ -152,6 +160,13 @@ int handle_IRQ_event(unsigned int irq, s
 		add_interrupt_randomness(irq);
 
 	local_irq_disable();
+
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	if (irq != TIMER_IRQ) { /* avoid double-reporting the timer IRQ */
+		TRIG_EVENT(irq_exit_hook, irq, regs);
+	}
+#endif
+
 	return retval;
 }
 
Index: linux.t/arch/sh/kernel/entry.S
===================================================================
--- linux.t.orig/arch/sh/kernel/entry.S	2004-02-18 15:20:36.000000000 -0500
+++ linux.t/arch/sh/kernel/entry.S	2004-03-22 20:23:56.932942917 -0500
@@ -555,6 +555,19 @@ syscall_badsys:			! Bad syscall number
 	 nop
 	!
 good_system_call:		! Good syscall number
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	! TODO: for i386 this code only happens when not ptrace'd
+	mov 	r15, r4     	    	! pass pt_regs* as first arg
+	mov.l	__pre_syscall, r11 	! Call pre_syscall()
+	jsr	@r11	    	    	! (will chomp R[0-7])
+	 nop
+	!   	    	    	    	Reload R4-R7 from kernel stack
+	mov.l	@(OFF_R4,r15), r4   ! arg0
+	mov.l	@(OFF_R5,r15), r5
+	mov.l	@(OFF_R6,r15), r6
+	mov.l	@(OFF_R7,r15), r7   ! arg3
+	mov.l	@(OFF_R3,r15), r3   ! syscall_nr
+#endif
 	mov.l	@(TI_FLAGS,r8), r8
 	mov	#_TIF_SYSCALL_TRACE, r10
 	tst	r10, r8
@@ -570,6 +583,12 @@ syscall_call:
 	mov.l	r0, @(OFF_R0,r15)		! save the return value
 	!
 syscall_exit:
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	! TODO: for i386 this code only happens when not ptrace'd
+	mov.l	__post_syscall, r1 	    	! Call post_syscall()
+	jsr	@r1
+	 nop
+#endif
 	CLI()
 	!
 	GET_THREAD_INFO(r8)
@@ -676,6 +695,13 @@ skip_restore:
 5:	.long	0x00001000	! DSP
 7:	.long	0x30000000
 9:
+
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+__pre_syscall:
+	.long	SYMBOL_NAME(pre_syscall)
+__post_syscall:
+	.long	SYMBOL_NAME(post_syscall)
+#endif
 __INV_IMASK:
 	.long	0xffffff0f	! ~(IMASK)
 
Index: linux.t/arch/sh/kernel/traps.c
===================================================================
--- linux.t.orig/arch/sh/kernel/traps.c	2004-02-05 16:56:17.000000000 -0500
+++ linux.t/arch/sh/kernel/traps.c	2004-03-22 20:23:56.936941738 -0500
@@ -28,6 +28,8 @@
 #include <linux/module.h>
 #include <linux/kallsyms.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -67,10 +69,12 @@ asmlinkage void do_##name(unsigned long 
 	tsk->thread.error_code = error_code;				\
 	tsk->thread.trap_no = trapnr;					\
         CHK_REMOTE_DEBUG(&regs);					\
+	TRIG_EVENT(trap_entry_hook, trapnr, regs.pc);			\
 	force_sig(signr, tsk);						\
+	TRIG_EVENT(trap_exit_hook);					\
 	die_if_no_fixup(str,&regs,error_code);				\
 }
-
+  
 #ifdef CONFIG_CPU_SH2
 #define TRAP_RESERVED_INST	4
 #define TRAP_ILLEGAL_SLOT_INST	6
@@ -500,6 +504,8 @@ asmlinkage void do_address_error(struct 
 
 	asm volatile("stc       r2_bank,%0": "=r" (error_code));
 
+	TRIG_EVENT(trap_entry_hook, error_code >> 5, regs->pc);
+
 	oldfs = get_fs();
 
 	if (user_mode(regs)) {
@@ -523,8 +529,10 @@ asmlinkage void do_address_error(struct 
 		tmp = handle_unaligned_access(instruction, regs);
 		set_fs(oldfs);
 
-		if (tmp==0)
-			return; /* sorted */
+		if (tmp==0) {
+			TRIG_EVENT(trap_exit_hook);
+ 			return; /* sorted */
+		}
 
 	uspace_segv:
 		printk(KERN_NOTICE "Killing process \"%s\" due to unaligned access\n", current->comm);
@@ -545,6 +553,7 @@ asmlinkage void do_address_error(struct 
 		handle_unaligned_access(instruction, regs);
 		set_fs(oldfs);
 	}
+	TRIG_EVENT(trap_exit_hook);
 }
 
 #ifdef CONFIG_SH_DSP
Index: linux.t/arch/sh/kernel/sys_sh.c
===================================================================
--- linux.t.orig/arch/sh/kernel/sys_sh.c	2004-03-11 14:13:07.000000000 -0500
+++ linux.t/arch/sh/kernel/sys_sh.c	2004-03-22 20:23:56.935942033 -0500
@@ -22,6 +22,8 @@
 #include <linux/file.h>
 #include <linux/utsname.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 
@@ -140,6 +142,8 @@ asmlinkage int sys_ipc(uint call, int fi
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
+	TRIG_EVENT(ipc_call_hook, call, first);
+
 	if (call <= SEMCTL)
 		switch (call) {
 		case SEMOP:
Index: linux.t/arch/sh/kernel/process.c
===================================================================
--- linux.t.orig/arch/sh/kernel/process.c	2004-02-18 15:20:36.000000000 -0500
+++ linux.t/arch/sh/kernel/process.c	2004-03-22 20:23:56.934942327 -0500
@@ -20,6 +20,7 @@
 #include <linux/ptrace.h>
 #include <linux/platform.h>
 #include <linux/kallsyms.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -147,6 +148,7 @@ __asm__(".align 5\n"
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {	/* Don't use this in BL=1(cli).  Or else, CPU resets! */
 	struct pt_regs regs;
+	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 	regs.regs[4] = (unsigned long) arg;
@@ -156,7 +158,13 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.sr = (1 << 30);
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+
+	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	if (ret > 0)
+		TRIG_EVENT(kthread_hook, ret, (int) fn);
+#endif
+	return  ret;
 }
 
 /*
Index: linux.t/arch/arm/mm/fault-common.c
===================================================================
--- linux.t.orig/arch/arm/mm/fault-common.c	2004-03-22 20:22:06.586471860 -0500
+++ linux.t/arch/arm/mm/fault-common.c	2004-03-22 20:23:56.882957649 -0500
@@ -17,6 +17,7 @@
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -247,6 +248,7 @@ int do_page_fault(unsigned long addr, un
 	if (in_interrupt() || !mm)
 		goto no_context;
 
+	TRIG_EVENT(trap_entry_hook, 14, instruction_pointer(regs));
 	down_read(&mm->mmap_sem);
 	fault = __do_page_fault(mm, addr, fsr, tsk);
 	up_read(&mm->mmap_sem);
@@ -254,8 +256,10 @@ int do_page_fault(unsigned long addr, un
 	/*
 	 * Handle the "normal" case first
 	 */
-	if (fault > 0)
+	if (fault > 0) {
+		TRIG_EVENT(trap_exit_hook);
 		return 0;
+	}
 
 	/*
 	 * We had some memory, but were unable to
@@ -281,6 +285,7 @@ int do_page_fault(unsigned long addr, un
 	} else
 		__do_user_fault(tsk, addr, fsr, fault == -1 ?
 				SEGV_ACCERR : SEGV_MAPERR, regs);
+	TRIG_EVENT(trap_exit_hook);
 	return 0;
 
 
@@ -305,11 +310,14 @@ do_sigbus:
 #endif
 
 	/* Kernel mode? Handle exceptions or die */
-	if (user_mode(regs))
+	if (user_mode(regs)) {
+		TRIG_EVENT(trap_exit_hook);
 		return 0;
+	}
 
 no_context:
 	__do_kernel_fault(mm, addr, fsr, regs);
+	TRIG_EVENT(trap_exit_hook);
 	return 0;
 }
 
Index: linux.t/arch/arm/Kconfig
===================================================================
--- linux.t.orig/arch/arm/Kconfig	2004-03-22 20:23:56.783986819 -0500
+++ linux.t/arch/arm/Kconfig	2004-03-22 20:23:56.877959122 -0500
@@ -775,6 +775,32 @@ config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
 
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
+config TRIGEVENT_SYSCALL_HOOK
+	bool " Enable syscall entry/exit hooks"
+	depends on TRIGEVENT_HOOKS
+	help 
+	RAS hooks to enable tracing of system call entry and exit points.
+	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/arm/kernel/sys_arm.c
===================================================================
--- linux.t.orig/arch/arm/kernel/sys_arm.c	2004-03-11 14:13:04.000000000 -0500
+++ linux.t/arch/arm/kernel/sys_arm.c	2004-03-22 20:23:56.881957944 -0500
@@ -25,6 +25,7 @@
 #include <linux/fs.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -166,6 +167,7 @@ asmlinkage int sys_ipc (uint call, int f
 
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
+	TRIG_EVENT(ipc_call_hook, call, first);
 
 	switch (call) {
 	case SEMOP:
Index: linux.t/arch/arm/kernel/irq.c
===================================================================
--- linux.t.orig/arch/arm/kernel/irq.c	2004-03-11 14:13:04.000000000 -0500
+++ linux.t/arch/arm/kernel/irq.c	2004-03-22 20:23:56.879958533 -0500
@@ -32,6 +32,7 @@
 #include <linux/errno.h>
 #include <linux/list.h>
 #include <linux/kallsyms.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/irq.h>
 #include <asm/system.h>
@@ -447,6 +448,7 @@ asmlinkage void asm_do_IRQ(int irq, stru
 {
 	struct irqdesc *desc = irq_desc + irq;
 
+	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	/*
 	 * Some hardware gives randomly wrong interrupts.  Rather
 	 * than crashing, do something sensible.
@@ -466,6 +468,7 @@ asmlinkage void asm_do_IRQ(int irq, stru
 
 	spin_unlock(&irq_controller_lock);
 	irq_exit();
+	TRIG_EVENT(irq_exit_hook, irq, regs);
 }
 
 void __set_irq_handler(unsigned int irq, irq_handler_t handle, int is_chained)
Index: linux.t/arch/arm/kernel/traps.c
===================================================================
--- linux.t.orig/arch/arm/kernel/traps.c	2004-03-22 20:22:06.584472449 -0500
+++ linux.t/arch/arm/kernel/traps.c	2004-03-22 20:23:56.881957944 -0500
@@ -26,6 +26,7 @@
 #include <linux/interrupt.h>
 #include <linux/kallsyms.h>
 #include <linux/init.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/io.h>
@@ -313,8 +314,10 @@ asmlinkage void do_undefinstr(struct pt_
 	info.si_code  = ILL_ILLOPC;
 	info.si_addr  = pc;
 
+	TRIG_EVENT(trap_entry_hook, current->thread.trap_no, (uint32_t)pc);
 	force_sig_info(SIGILL, &info, current);
 
+	TRIG_EVENT(trap_exit_hook);
 	die_if_kernel("Oops - undefined instruction", regs, 0);
 }
 
@@ -427,7 +430,9 @@ asmlinkage int arm_syscall(int no, struc
 
 	case NR(breakpoint): /* SWI BREAK_POINT */
 		regs->ARM_pc -= thumb_mode(regs) ? 2 : 4;
+		TRIG_EVENT(trap_entry_hook, 1, (uint32_t)regs->ARM_pc);
 		ptrace_break(current, regs);
+		TRIG_EVENT(trap_exit_hook);
 		return regs->ARM_r0;
 
 	/*
@@ -526,7 +531,9 @@ baddataabort(int code, unsigned long ins
 	info.si_code  = ILL_ILLOPC;
 	info.si_addr  = (void *)addr;
 
+	TRIG_EVENT(trap_entry_hook, 18, addr);	/* machine check */
 	force_sig_info(SIGILL, &info, current);
+	TRIG_EVENT(trap_exit_hook);
 	die_if_kernel("unknown data abort code", regs, instr);
 }
 
Index: linux.t/arch/arm/kernel/process.c
===================================================================
--- linux.t.orig/arch/arm/kernel/process.c	2004-02-18 15:20:35.000000000 -0500
+++ linux.t/arch/arm/kernel/process.c	2004-03-22 20:23:56.880958238 -0500
@@ -399,6 +399,7 @@ asm(	".align\n"
 pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 {
 	struct pt_regs regs;
+	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 
@@ -408,7 +409,13 @@ pid_t kernel_thread(int (*fn)(void *), v
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
 	regs.ARM_cpsr = SVC_MODE;
 
-	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	ret = do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	if (ret > 0)
+		TRIG_EVENT(kthread_hook, ret, (int) fn);
+#endif
+
+	return  ret;
 }
 
 /*
Index: linux.t/arch/arm/kernel/entry-common.S
===================================================================
--- linux.t.orig/arch/arm/kernel/entry-common.S	2004-01-09 01:59:04.000000000 -0500
+++ linux.t/arch/arm/kernel/entry-common.S	2004-03-22 20:23:56.878958828 -0500
@@ -39,6 +39,11 @@ ENTRY(__do_softirq)
  */
 ret_fast_syscall:
 	disable_irq r1				@ disable interrupts
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	mov	r7, r0				@ save returned r0
+	bl	SYMBOL_NAME(post_syscall)
+	mov	r0, r7
+#endif
 	ldr	r1, [tsk, #TI_FLAGS]
 	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
@@ -136,6 +141,15 @@ ENTRY(vector_swi)
 #endif
 	enable_irq ip
 
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	/* zzz note that validity of scno is not yet checked.
+	 * zzz The visualizer checks it.
+	 */
+	add	r0, sp, #S_R0			@ pointer to regs
+	bl	SYMBOL_NAME(pre_syscall)
+	add	r0, sp, #S_R0			@ pointer to regs
+	ldmia	r1, {r0 - r3}			@ have to reload r0 - r3
+#endif
 	str	r4, [sp, #-S_OFF]!		@ push fifth arg
 
 	get_thread_info tsk
@@ -175,6 +189,9 @@ __sys_trace:
 
 __sys_trace_return:
 	str	r0, [sp, #S_R0 + S_OFF]!	@ save returned r0
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	bl	SYMBOL_NAME(post_syscall)
+#endif
 	mov	r1, sp
 	mov	r0, #1				@ trace exit [IP = 1]
 	bl	syscall_trace
Index: linux.t/arch/ppc/mm/fault.c
===================================================================
--- linux.t.orig/arch/ppc/mm/fault.c	2004-01-09 01:59:19.000000000 -0500
+++ linux.t/arch/ppc/mm/fault.c	2004-03-22 20:23:56.917947336 -0500
@@ -29,6 +29,8 @@
 #include <linux/highmem.h>
 #include <linux/module.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/mmu.h>
@@ -121,22 +123,28 @@ void do_page_fault(struct pt_regs *regs,
 		is_write = error_code & 0x02000000;
 #endif /* CONFIG_4xx */
 
+	TRIG_EVENT(trap_entry_hook, regs->trap, instruction_pointer(regs));
+
 #if defined(CONFIG_XMON) || defined(CONFIG_KGDB)
 	if (debugger_fault_handler && TRAP(regs) == 0x300) {
 		debugger_fault_handler(regs);
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 #if !defined(CONFIG_4xx)
 	if (error_code & 0x00400000) {
 		/* DABR match */
-		if (debugger_dabr_match(regs))
+		if (debugger_dabr_match(regs)) {
+			TRIG_EVENT(trap_exit_hook);
 			return;
+		}
 	}
 #endif /* !CONFIG_4xx */
 #endif /* CONFIG_XMON || CONFIG_KGDB */
 
 	if (in_atomic() || mm == NULL) {
 		bad_page_fault(regs, address, SIGSEGV);
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 	down_read(&mm->mmap_sem);
@@ -277,6 +285,7 @@ good_area:
 	 * -- Cort
 	 */
 	pte_misses++;
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 bad_area:
@@ -290,10 +299,12 @@ bad_area:
 		info.si_code = code;
 		info.si_addr = (void *) address;
 		force_sig_info(SIGSEGV, &info, current);
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 	bad_page_fault(regs, address, SIGSEGV);
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 /*
@@ -311,6 +322,7 @@ out_of_memory:
 	if (user_mode(regs))
 		do_exit(SIGKILL);
 	bad_page_fault(regs, address, SIGKILL);
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 do_sigbus:
@@ -322,6 +334,7 @@ do_sigbus:
 	force_sig_info (SIGBUS, &info, current);
 	if (!user_mode(regs))
 		bad_page_fault(regs, address, SIGBUS);
+	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
Index: linux.t/arch/ppc/Kconfig
===================================================================
--- linux.t.orig/arch/ppc/Kconfig	2004-03-22 20:23:56.793983873 -0500
+++ linux.t/arch/ppc/Kconfig	2004-03-22 20:23:56.909949694 -0500
@@ -1246,7 +1246,33 @@ config ASM_HOOK
 config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
-	
+
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
+config TRIGEVENT_SYSCALL_HOOK
+	bool " Enable syscall entry/exit hooks"
+	depends on TRIGEVENT_HOOKS
+	help 
+	RAS hooks to enable tracing of system call entry and exit points.
+	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/ppc/kernel/irq.c
===================================================================
--- linux.t.orig/arch/ppc/kernel/irq.c	2004-03-11 14:13:07.000000000 -0500
+++ linux.t/arch/ppc/kernel/irq.c	2004-03-22 20:23:56.911949104 -0500
@@ -47,6 +47,8 @@
 #include <linux/seq_file.h>
 #include <linux/cpumask.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
 #include <asm/system.h>
@@ -431,6 +433,8 @@ void ppc_irq_dispatch_handler(struct pt_
 	struct irqaction *action;
 	irq_desc_t *desc = irq_desc + irq;
 
+	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
+
 	kstat_this_cpu.irqs[irq]++;
 	spin_lock(&desc->lock);
 	ack_irq(irq);
@@ -508,6 +512,8 @@ out:
 			irq_desc[irq].handler->enable(irq);
 	}
 	spin_unlock(&desc->lock);
+
+	TRIG_EVENT(irq_exit_hook, irq, regs);
 }
 
 void do_IRQ(struct pt_regs *regs)
Index: linux.t/arch/ppc/kernel/entry.S
===================================================================
--- linux.t.orig/arch/ppc/kernel/entry.S	2004-02-18 15:20:35.000000000 -0500
+++ linux.t/arch/ppc/kernel/entry.S	2004-03-22 20:23:56.910949399 -0500
@@ -35,6 +35,32 @@
 #undef SHOW_SYSCALLS
 #undef SHOW_SYSCALLS_TASK
 
+/* syscall hooks for LTT */
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+#define ASM_PRE_SYSCALL	\
+	addi	r3,r1,STACK_FRAME_OVERHEAD;  	/* Put pointer to registers into r3 */	\
+	mflr	r29;				/* Save LR */ \
+	bl	pre_syscall;			/* Call real trace function */ \
+	mtlr	r29;				/* Restore LR */ \
+	lwz	r0,GPR0(r1);			/* Restore original registers */ \
+	lwz	r3,GPR3(r1);	\
+	lwz	r4,GPR4(r1);	\
+	lwz	r5,GPR5(r1);	\
+	lwz	r6,GPR6(r1);	\
+	lwz	r7,GPR7(r1);	\
+	lwz	r8,GPR8(r1);
+#define ASM_POST_SYSCALL \
+	bl	post_syscall;			/* Call real trace function */ \
+	lwz	r0,GPR0(r1);			/* Restore original registers */ \
+	lwz	r3,RESULT(r1); \
+	lwz	r4,GPR4(r1); \
+	lwz	r5,GPR5(r1); \
+	lwz	r6,GPR6(r1); \
+	lwz	r7,GPR7(r1); \
+	lwz	r8,GPR8(r1); \
+	addi	r9,r1,STACK_FRAME_OVERHEAD;
+#endif
+
 /*
  * MSR_KERNEL is > 0x10000 on 4xx since it include MSR_CE.
  */
@@ -184,10 +210,16 @@ syscall_dotrace_cont:
 	bge-	66f
 	lwzx	r10,r10,r0	/* Fetch system call handler [ptr] */
 	mtlr	r10
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	ASM_PRE_SYSCALL ;
+#endif
 	addi	r9,r1,STACK_FRAME_OVERHEAD
 	blrl			/* Call handler */
 	.globl	ret_from_syscall
 ret_from_syscall:
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	ASM_POST_SYSCALL ;
+#endif
 #ifdef SHOW_SYSCALLS
 	bl	do_show_syscall_exit
 #endif
Index: linux.t/arch/ppc/kernel/traps.c
===================================================================
--- linux.t.orig/arch/ppc/kernel/traps.c	2004-03-22 20:22:06.745425002 -0500
+++ linux.t/arch/ppc/kernel/traps.c	2004-03-22 20:23:56.916947631 -0500
@@ -31,6 +31,8 @@
 #include <linux/init.h>
 #include <linux/module.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -118,7 +120,9 @@ _exception(int signr, struct pt_regs *re
 	info.si_errno = 0;
 	info.si_code = code;
 	info.si_addr = (void *) addr;
+	TRIG_EVENT(trap_entry_hook, regs->trap, instruction_pointer(regs));
 	force_sig_info(signr, &info, current);
+	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
@@ -401,7 +405,6 @@ check_bug_trap(struct pt_regs *regs)
 	       bug->function, bug->file, bug->line);
 	return 0;
 }
-
 void
 ProgramCheckException(struct pt_regs *regs)
 {
Index: linux.t/arch/ppc/kernel/misc.S
===================================================================
--- linux.t.orig/arch/ppc/kernel/misc.S	2004-03-22 20:22:06.743425592 -0500
+++ linux.t/arch/ppc/kernel/misc.S	2004-03-22 20:23:56.913948515 -0500
@@ -1066,7 +1066,11 @@ _GLOBAL(cvt_df)
  * Create a kernel thread
  *   kernel_thread(fn, arg, flags)
  */
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK 
+_GLOBAL(original_kernel_thread)
+#else
 _GLOBAL(kernel_thread)
+#endif /* CONFIG_TRIGEVENT_SYSCALL_HOOK */
 	stwu	r1,-16(r1)
 	stw	r30,8(r1)
 	stw	r31,12(r1)
Index: linux.t/arch/ppc/kernel/time.c
===================================================================
--- linux.t.orig/arch/ppc/kernel/time.c	2004-03-11 14:13:07.000000000 -0500
+++ linux.t/arch/ppc/kernel/time.c	2004-03-22 20:23:56.915947926 -0500
@@ -56,6 +56,7 @@
 #include <linux/mc146818rtc.h>
 #include <linux/time.h>
 #include <linux/init.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
@@ -152,6 +153,8 @@ void timer_interrupt(struct pt_regs * re
 	if (atomic_read(&ppc_n_lost_interrupts) != 0)
 		do_IRQ(regs);
 
+	TRIG_EVENT(trap_entry_hook, regs->trap, instruction_pointer(regs));
+
 	irq_enter();
 
 	while ((next_dec = tb_ticks_per_jiffy - tb_delta(&jiffy_stamp)) < 0) {
@@ -199,6 +202,7 @@ void timer_interrupt(struct pt_regs * re
 	last_jiffy_stamp(cpu) = jiffy_stamp;
 
 #ifdef CONFIG_SMP
+	TRIG_EVENT(timer_hook, regs);
 	smp_local_timer_interrupt(regs);
 #endif /* CONFIG_SMP */
 
@@ -206,6 +210,8 @@ void timer_interrupt(struct pt_regs * re
 		ppc_md.heartbeat();
 
 	irq_exit();
+
+	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
Index: linux.t/arch/ppc/kernel/process.c
===================================================================
--- linux.t.orig/arch/ppc/kernel/process.c	2004-03-22 20:22:15.475851181 -0500
+++ linux.t/arch/ppc/kernel/process.c	2004-03-22 20:23:56.914948220 -0500
@@ -35,6 +35,7 @@
 #include <linux/init_task.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -299,6 +300,19 @@ void show_regs(struct pt_regs * regs)
 	show_stack(current, (unsigned long *) regs->gpr[1]);
 }
 
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK 
+long original_kernel_thread(int (*fn) (void *), void* arg, unsigned long flags);
+long kernel_thread(int (*fn) (void *), void* arg, unsigned long flags)
+{
+	long   retval;
+
+	retval = original_kernel_thread(fn, arg, flags);
+	if (retval > 0)
+		TRIG_EVENT(kthread_hook, retval, (int) fn);
+	return retval;
+}
+#endif /* CONFIG_TRIGEVENT_SYSCALL_HOOK */
+ 
 void exit_thread(void)
 {
 	if (last_task_used_math == current)
Index: linux.t/arch/ppc/kernel/syscalls.c
===================================================================
--- linux.t.orig/arch/ppc/kernel/syscalls.c	2004-03-11 14:13:07.000000000 -0500
+++ linux.t/arch/ppc/kernel/syscalls.c	2004-03-22 20:23:56.915947926 -0500
@@ -37,6 +37,8 @@
 #include <linux/file.h>
 #include <linux/unistd.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 #include <asm/semaphore.h>
@@ -59,6 +61,8 @@ sys_ipc (uint call, int first, int secon
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
 
+	TRIG_EVENT(ipc_call_hook, call, first);
+
 	ret = -ENOSYS;
 	switch (call) {
 	case SEMOP:
Index: linux.t/arch/i386/mm/fault.c
===================================================================
--- linux.t.orig/arch/i386/mm/fault.c	2004-01-09 01:59:02.000000000 -0500
+++ linux.t/arch/i386/mm/fault.c	2004-03-22 20:23:56.894954113 -0500
@@ -21,6 +21,7 @@
 #include <linux/vt_kern.h>		/* For unblank_screen() */
 #include <linux/highmem.h>
 #include <linux/module.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -230,6 +231,7 @@ asmlinkage void do_page_fault(struct pt_
 
 	info.si_code = SEGV_MAPERR;
 
+	TRIG_EVENT(trap_entry_hook, 14, regs->eip);
 	/*
 	 * We fault-in kernel-space virtual memory on-demand. The
 	 * 'reference' page table is init_mm.pgd.
@@ -339,6 +341,7 @@ good_area:
 			tsk->thread.screen_bitmap |= 1 << bit;
 	}
 	up_read(&mm->mmap_sem);
+        TRIG_EVENT(trap_exit_hook);
 	return;
 
 /*
@@ -367,6 +370,7 @@ bad_area_nosemaphore:
 		/* info.si_code has been set above */
 		info.si_addr = (void *)address;
 		force_sig_info(SIGSEGV, &info, tsk);
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
@@ -381,6 +385,7 @@ bad_area_nosemaphore:
 
 		if (nr == 6) {
 			do_invalid_op(regs, 0);
+			TRIG_EVENT(trap_exit_hook);
 			return;
 		}
 	}
@@ -388,16 +393,20 @@ bad_area_nosemaphore:
 
 no_context:
 	/* Are we prepared to handle this kernel fault?  */
-	if (fixup_exception(regs))
+	if (fixup_exception(regs)) {
+		TRIG_EVENT(trap_exit_hook);
 		return;
+	}
 
 	/* 
 	 * Valid to do another page fault here, because if this fault
 	 * had been triggered by is_prefetch fixup_exception would have 
 	 * handled it.
 	 */
- 	if (is_prefetch(regs, address))
+ 	if (is_prefetch(regs, address)) {
+		TRIG_EVENT(trap_exit_hook);
  		return;
+	}
 
 /*
  * Oops. The kernel tried to access some bad page. We'll have to
@@ -458,8 +467,10 @@ do_sigbus:
 		goto no_context;
 
 	/* User space => ok to do another page fault */
-	if (is_prefetch(regs, address))
+	if (is_prefetch(regs, address)) {
+		TRIG_EVENT(trap_exit_hook);
 		return;
+	}
 
 	tsk->thread.cr2 = address;
 	tsk->thread.error_code = error_code;
@@ -469,6 +480,7 @@ do_sigbus:
 	info.si_code = BUS_ADRERR;
 	info.si_addr = (void *)address;
 	force_sig_info(SIGBUS, &info, tsk);
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 vmalloc_fault:
@@ -506,6 +518,8 @@ vmalloc_fault:
 		pte_k = pte_offset_kernel(pmd_k, address);
 		if (!pte_present(*pte_k))
 			goto no_context;
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
+	TRIG_EVENT(trap_exit_hook);
 }
Index: linux.t/arch/i386/Kconfig
===================================================================
--- linux.t.orig/arch/i386/Kconfig	2004-03-22 20:23:56.785986230 -0500
+++ linux.t/arch/i386/Kconfig	2004-03-22 20:23:56.885956765 -0500
@@ -1463,6 +1463,32 @@ config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
 	
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
+config TRIGEVENT_SYSCALL_HOOK
+	bool " Enable syscall entry/exit hooks"
+	depends on TRIGEVENT_HOOKS
+	help 
+	RAS hooks to enable tracing of system call entry and exit points.
+	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/i386/kernel/irq.c
===================================================================
--- linux.t.orig/arch/i386/kernel/irq.c	2004-03-11 14:13:04.000000000 -0500
+++ linux.t/arch/i386/kernel/irq.c	2004-03-22 20:23:56.889955587 -0500
@@ -34,6 +34,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/kallsyms.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/io.h>
@@ -219,6 +220,7 @@ int handle_IRQ_event(unsigned int irq,
 	int status = 1;	/* Force the "do bottom halves" bit */
 	int retval = 0;
 
+	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
 	if (!(action->flags & SA_INTERRUPT))
 		local_irq_enable();
 
@@ -230,6 +232,7 @@ int handle_IRQ_event(unsigned int irq,
 	if (status & SA_SAMPLE_RANDOM)
 		add_interrupt_randomness(irq);
 	local_irq_disable();
+	TRIG_EVENT(irq_exit_hook, irq, regs);
 	return retval;
 }
 
Index: linux.t/arch/i386/kernel/sys_i386.c
===================================================================
--- linux.t.orig/arch/i386/kernel/sys_i386.c	2004-03-22 20:22:18.228039729 -0500
+++ linux.t/arch/i386/kernel/sys_i386.c	2004-03-22 20:23:56.891954997 -0500
@@ -19,6 +19,7 @@
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -135,6 +136,7 @@ asmlinkage int sys_ipc (uint call, int f
 
 	version = call >> 16; /* hack for backward compatibility */
 	call &= 0xffff;
+	TRIG_EVENT(ipc_call_hook, call, first);
 
 	switch (call) {
 	case SEMOP:
Index: linux.t/arch/i386/kernel/entry.S
===================================================================
--- linux.t.orig/arch/i386/kernel/entry.S	2004-03-22 20:22:16.456562034 -0500
+++ linux.t/arch/i386/kernel/entry.S	2004-03-22 20:23:56.888955881 -0500
@@ -302,9 +302,29 @@ ENTRY(system_call)
 	testb $_TIF_SYSCALL_TRACE,TI_FLAGS(%ebp)
 	jnz syscall_trace_entry
 syscall_call:
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	movl pre_syscall_enabled, %eax
+	testl %eax, %eax
+	jz pre_syscall_done
+	movl %esp, %eax                 # copy the stack pointer
+	pushl %eax                      # pass the stack pointer copy
+	call pre_syscall
+	addl $4,%esp                    # return stack to state before pass
+pre_syscall_done:
+	movl ORIG_EAX(%esp),%eax	# restore eax to it's original content
+#endif
 	call *sys_call_table(,%eax,4)
 	movl %eax,EAX(%esp)		# store the return value
 syscall_exit:
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	pushl %ebx
+	movl post_syscall_enabled, %eax
+	testl %eax, %eax                   # are we tracing system call exits
+	jz post_syscall_done
+	call post_syscall
+post_syscall_done:
+	popl %ebx	
+#endif
 	cli				# make sure we don't miss an interrupt
 					# setting need_resched or sigpending
 					# between sampling and the iret
Index: linux.t/arch/i386/kernel/apic.c
===================================================================
--- linux.t.orig/arch/i386/kernel/apic.c	2004-03-22 20:22:12.744656407 -0500
+++ linux.t/arch/i386/kernel/apic.c	2004-03-22 20:23:56.886956470 -0500
@@ -26,6 +26,7 @@
 #include <linux/mc146818rtc.h>
 #include <linux/kernel_stat.h>
 #include <linux/sysdev.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/smp.h>
@@ -1064,6 +1065,7 @@ inline void smp_local_timer_interrupt(st
 		}
 
 #ifdef CONFIG_SMP
+		TRIG_EVENT(timer_hook, regs);
 		update_process_times(user_mode(regs));
 #endif
 	}
Index: linux.t/arch/i386/kernel/traps.c
===================================================================
--- linux.t.orig/arch/i386/kernel/traps.c	2004-03-22 20:22:25.564876365 -0500
+++ linux.t/arch/i386/kernel/traps.c	2004-03-22 20:23:56.893954408 -0500
@@ -32,6 +32,7 @@
 #include <linux/ioport.h>
 #include <linux/eisa.h>
 #endif
+#include <linux/trigevent_hooks.h>
 
 #ifdef CONFIG_MCA
 #include <linux/mca.h>
@@ -327,6 +328,7 @@ static inline unsigned long get_cr2(void
 static inline void do_trap(int trapnr, int signr, char *str, int vm86,
 			   struct pt_regs * regs, long error_code, siginfo_t *info)
 {
+	TRIG_EVENT(trap_entry_hook, trapnr, regs->eip);
 	if (regs->eflags & VM_MASK) {
 		if (vm86)
 			goto vm86_trap;
@@ -344,20 +346,24 @@ static inline void do_trap(int trapnr, i
 			force_sig_info(signr, info, tsk);
 		else
 			force_sig(signr, tsk);
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 	kernel_trap: {
 		if (!fixup_exception(regs))
 			die(str, regs, error_code);
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 	vm86_trap: {
 		int ret = handle_vm86_trap((struct kernel_vm86_regs *) regs, error_code, trapnr);
 		if (ret) goto trap_signal;
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
+	TRIG_EVENT(trap_exit_hook);
 }
 
 #define DO_ERROR(trapnr, signr, str, name) \
@@ -420,12 +426,16 @@ asmlinkage void do_general_protection(st
 
 	current->thread.error_code = error_code;
 	current->thread.trap_no = 13;
+	TRIG_EVENT(trap_entry_hook, 13, regs->eip);
 	force_sig(SIGSEGV, current);
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 gp_in_vm86:
 	local_irq_enable();
+	TRIG_EVENT(trap_entry_hook, 13, regs->eip);
 	handle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 gp_in_kernel:
@@ -535,6 +545,10 @@ asmlinkage void do_nmi(struct pt_regs * 
 {
 	int cpu;
 
+#ifndef CONFIG_X86_LOCAL_APIC /* On an machine with APIC enabled NMIs are used to implement a
+				watchdog and will hang the machine if traced. */
+	TRIG_EVENT(trap_entry_hook, 2, regs->eip);
+#endif
 	nmi_enter();
 
 	cpu = smp_processor_id();
@@ -544,6 +558,7 @@ asmlinkage void do_nmi(struct pt_regs * 
 		default_do_nmi(regs);
 
 	nmi_exit();
+	TRIG_EVENT(trap_exit_hook);
 }
 
 void set_nmi_callback(nmi_callback_t callback)
@@ -636,7 +651,9 @@ asmlinkage void do_debug(struct pt_regs 
 	 */
 	info.si_addr = ((regs->xcs & 3) == 0) ? (void *)tsk->thread.eip : 
 	                                        (void *)regs->eip;
+        TRIG_EVENT(trap_entry_hook, 1, regs->eip);
 	force_sig_info(SIGTRAP, &info, tsk);
+        TRIG_EVENT(trap_exit_hook);
 
 	/* Disable additional traps. They'll be re-enabled when
 	 * the signal is delivered.
@@ -648,7 +665,9 @@ clear_dr7:
 	return;
 
 debug_vm86:
+        TRIG_EVENT(trap_entry_hook, 1, regs->eip);
 	handle_vm86_trap((struct kernel_vm86_regs *) regs, error_code, 1);
+        TRIG_EVENT(trap_exit_hook);
 	return;
 
 clear_TF_reenable:
@@ -810,10 +829,12 @@ asmlinkage void do_simd_coprocessor_erro
 asmlinkage void do_spurious_interrupt_bug(struct pt_regs * regs,
 					  long error_code)
 {
+        TRIG_EVENT(trap_entry_hook, 16, regs->eip);
 #if 0
 	/* No need to warn about this any longer. */
 	printk("Ignoring P6 Local APIC Spurious Interrupt Bug...\n");
 #endif
+        TRIG_EVENT(trap_exit_hook);	
 }
 
 /*
@@ -844,8 +865,10 @@ asmlinkage void math_emulate(long arg)
 {
 	printk("math-emulation not enabled and no coprocessor found.\n");
 	printk("killing %s.\n",current->comm);
+        TRIG_EVENT(trap_entry_hook, 7, 0);
 	force_sig(SIGFPE,current);
 	schedule();
+        TRIG_EVENT(trap_exit_hook);
 }
 
 #endif /* CONFIG_MATH_EMULATION */
Index: linux.t/arch/i386/kernel/process.c
===================================================================
--- linux.t.orig/arch/i386/kernel/process.c	2004-03-22 20:22:06.625460366 -0500
+++ linux.t/arch/i386/kernel/process.c	2004-03-22 20:23:56.890955292 -0500
@@ -36,6 +36,7 @@
 #include <linux/module.h>
 #include <linux/kallsyms.h>
 #include <linux/ptrace.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -267,6 +268,7 @@ __asm__(".section .text\n"
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
 	struct pt_regs regs;
+	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 
@@ -281,7 +283,12 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.eflags = 0x286;
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	if (ret > 0)
+		TRIG_EVENT(kthread_hook, ret, (int) fn);
+#endif
+	return  ret;
 }
 
 /*
Index: linux.t/arch/ia64/kernel/time.c
===================================================================
--- linux.t.orig/arch/ia64/kernel/time.c	2004-02-05 16:56:17.000000000 -0500
+++ linux.t/arch/ia64/kernel/time.c	2004-03-22 20:23:56.895953819 -0500
@@ -257,6 +257,7 @@ timer_interrupt (int irq, void *dev_id, 
 	while (1) {
 
 #ifdef CONFIG_SMP
+		TRIG_EVENT(timer_hook, regs);
 		smp_do_timer(regs);
 #endif
 		new_itm += local_cpu_data->itm_delta;
Index: linux.t/arch/mips/mm/fault.c
===================================================================
--- linux.t.orig/arch/mips/mm/fault.c	2004-03-11 14:13:06.000000000 -0500
+++ linux.t/arch/mips/mm/fault.c	2004-03-22 20:23:56.906950578 -0500
@@ -19,6 +19,7 @@
 #include <linux/smp_lock.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
 #include <linux/module.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/branch.h>
 #include <asm/hardirq.h>
@@ -27,6 +28,7 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/ptrace.h>
+#include <asm/mipsregs.h>
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -62,6 +64,8 @@ asmlinkage void do_page_fault(struct pt_
 	if (unlikely(address >= VMALLOC_START))
 		goto vmalloc_fault;
 
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
+
 	/*
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
@@ -116,6 +120,7 @@ survive:
 	}
 
 	up_read(&mm->mmap_sem);
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 /*
@@ -144,6 +149,7 @@ bad_area_nosemaphore:
 		/* info.si_code has been set above */
 		info.si_addr = (void *) address;
 		force_sig_info(SIGSEGV, &info, tsk);
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
@@ -201,6 +207,7 @@ do_sigbus:
 	info.si_addr = (void *) address;
 	force_sig_info(SIGBUS, &info, tsk);
 
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 vmalloc_fault:
@@ -235,4 +242,5 @@ vmalloc_fault:
 			goto no_context;
 		return;
 	}
+	TRIG_EVENT(trap_exit_hook);
 }
Index: linux.t/arch/mips/baget/irq.c
===================================================================
--- linux.t.orig/arch/mips/baget/irq.c	2004-01-09 01:59:45.000000000 -0500
+++ linux.t/arch/mips/baget/irq.c	2004-03-22 20:23:56.898952935 -0500
@@ -18,6 +18,7 @@
 #include <linux/slab.h>
 #include <linux/random.h>
 #include <linux/delay.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/bitops.h>
 #include <asm/bootinfo.h>
@@ -182,6 +183,7 @@ static void do_IRQ(int irq, struct pt_re
 	struct irqaction *action;
 	int do_random, cpu;
 
+	TRIG_EVENT(irq_entry_hook, irq, regs, !user_mode(regs));
 	cpu = smp_processor_id();
 	irq_enter();
 	kstat_cpus(cpu).irqs[irq]++;
@@ -207,6 +209,7 @@ static void do_IRQ(int irq, struct pt_re
 	unmask_irq(irq);
 	irq_exit();
 
+	TRIG_EVENT(irq_exit_hook, irq, regs);
 	/* unmasking and bottom half handling is done magically for us. */
 }
 
Index: linux.t/arch/mips/Kconfig
===================================================================
--- linux.t.orig/arch/mips/Kconfig	2004-03-22 20:23:56.790984757 -0500
+++ linux.t/arch/mips/Kconfig	2004-03-22 20:23:56.897953229 -0500
@@ -1544,6 +1544,32 @@ config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
 
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
+config TRIGEVENT_SYSCALL_HOOK
+	bool " Enable syscall entry/exit hooks"
+	depends on TRIGEVENT_HOOKS
+	help 
+	RAS hooks to enable tracing of system call entry and exit points.
+	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/mips/kernel/i8259.c
===================================================================
--- linux.t.orig/arch/mips/kernel/i8259.c	2004-03-11 14:13:06.000000000 -0500
+++ linux.t/arch/mips/kernel/i8259.c	2004-03-22 20:23:56.899952640 -0500
@@ -15,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/spinlock.h>
 #include <linux/sysdev.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/i8259.h>
 #include <asm/io.h>
@@ -145,6 +146,8 @@ static inline int i8259A_irq_real(unsign
 	outb(0x0B,0xA0);		/* ISR register */
 	value = inb(0xA0) & (irqmask >> 8);
 	outb(0x0A,0xA0);		/* back to the IRR register */
+	TRIG_EVENT(irq_entry_hook, irq, regs, !user_mode(regs));
+	TRIG_EVENT(irq_exit_hook, irq, regs);
 	return value;
 }
 
Index: linux.t/arch/mips/kernel/irq.c
===================================================================
--- linux.t.orig/arch/mips/kernel/irq.c	2004-03-11 14:13:06.000000000 -0500
+++ linux.t/arch/mips/kernel/irq.c	2004-03-22 20:23:56.900952345 -0500
@@ -22,6 +22,7 @@
 #include <linux/sched.h>
 #include <linux/seq_file.h>
 #include <linux/kallsyms.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/system.h>
@@ -352,6 +353,7 @@ asmlinkage unsigned int do_IRQ(int irq, 
 	struct irqaction * action;
 	unsigned int status;
 
+	TRIG_EVENT(irq_entry_hook, irq, regs, !user_mode(regs));
 	irq_enter();
 	kstat_this_cpu.irqs[irq]++;
 	spin_lock(&desc->lock);
@@ -417,6 +419,7 @@ out:
 	spin_unlock(&desc->lock);
 
 	irq_exit();
+	TRIG_EVENT(irq_exit_hook, irq, regs);
 
 	return 1;
 }
Index: linux.t/arch/mips/kernel/traps.c
===================================================================
--- linux.t.orig/arch/mips/kernel/traps.c	2004-03-11 14:13:06.000000000 -0500
+++ linux.t/arch/mips/kernel/traps.c	2004-03-22 20:23:56.904951167 -0500
@@ -20,6 +20,7 @@
 #include <linux/smp_lock.h>
 #include <linux/spinlock.h>
 #include <linux/kallsyms.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/bootinfo.h>
 #include <asm/branch.h>
@@ -36,6 +37,7 @@
 #include <asm/mmu_context.h>
 #include <asm/watch.h>
 #include <asm/types.h>
+#include <asm/unistd.h>
 
 extern asmlinkage void handle_mod(void);
 extern asmlinkage void handle_tlbl(void);
@@ -340,6 +342,8 @@ asmlinkage void do_be(struct pt_regs *re
 	int data = regs->cp0_cause & 4;
 	int action = MIPS_BE_FATAL;
 
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
+
 	/* XXX For now.  Fixme, this searches the wrong table ...  */
 	if (data && !user_mode(regs))
 		fixup = search_dbe_tables(exception_epc(regs));
@@ -352,10 +356,12 @@ asmlinkage void do_be(struct pt_regs *re
 
 	switch (action) {
 	case MIPS_BE_DISCARD:
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	case MIPS_BE_FIXUP:
 		if (fixup) {
 			regs->cp0_epc = fixup->nextinsn;
+			TRIG_EVENT(trap_exit_hook);
 			return;
 		}
 		break;
@@ -371,6 +377,8 @@ asmlinkage void do_be(struct pt_regs *re
 	       field, regs->cp0_epc, field, regs->regs[31]);
 	die_if_kernel("Oops", regs);
 	force_sig(SIGBUS, current);
+	TRIG_EVENT(trap_exit_hook);
+
 }
 
 static inline int get_insn_opcode(struct pt_regs *regs, unsigned int *opcode)
@@ -521,11 +529,13 @@ asmlinkage void do_ov(struct pt_regs *re
 {
 	siginfo_t info;
 
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	info.si_code = FPE_INTOVF;
 	info.si_signo = SIGFPE;
 	info.si_errno = 0;
 	info.si_addr = (void *)regs->cp0_epc;
 	force_sig_info(SIGFPE, &info, current);
+	TRIG_EVENT(trap_exit_hook);
 }
 
 /*
@@ -533,6 +543,7 @@ asmlinkage void do_ov(struct pt_regs *re
  */
 asmlinkage void do_fpe(struct pt_regs *regs, unsigned long fcr31)
 {
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	if (fcr31 & FPU_CSR_UNI_X) {
 		int sig;
 
@@ -565,10 +576,12 @@ asmlinkage void do_fpe(struct pt_regs *r
 		if (sig)
 			force_sig(sig, current);
 
+		TRIG_EVENT(trap_exit_hook);
 		return;
 	}
 
 	force_sig(SIGFPE, current);
+	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_bp(struct pt_regs *regs)
@@ -578,9 +591,12 @@ asmlinkage void do_bp(struct pt_regs *re
 
 	die_if_kernel("Break instruction in kernel code", regs);
 
-	if (get_insn_opcode(regs, &opcode))
-		return;
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 
+	if (get_insn_opcode(regs, &opcode)) {
+		TRIG_EVENT(trap_exit_hook);
+		return;
+	}
 	/*
 	 * There is the ancient bug in the MIPS assemblers that the break
 	 * code starts left to bit 16 instead to bit 6 in the opcode.
@@ -609,6 +625,7 @@ asmlinkage void do_bp(struct pt_regs *re
 	default:
 		force_sig(SIGTRAP, current);
 	}
+	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_tr(struct pt_regs *regs)
@@ -618,8 +635,12 @@ asmlinkage void do_tr(struct pt_regs *re
 
 	die_if_kernel("Trap instruction in kernel code", regs);
 
-	if (get_insn_opcode(regs, &opcode))
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
+
+	if (get_insn_opcode(regs, &opcode)) {
+		TRIG_EVENT(trap_exit_hook);
 		return;
+	}
 
 	/* Immediate versions don't provide a code.  */
 	if (!(opcode & OPCODE))
@@ -646,17 +667,22 @@ asmlinkage void do_tr(struct pt_regs *re
 	default:
 		force_sig(SIGTRAP, current);
 	}
+	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_ri(struct pt_regs *regs)
 {
 	die_if_kernel("Reserved instruction in kernel code", regs);
 
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	if (!cpu_has_llsc)
-		if (!simulate_llsc(regs))
+		if (!simulate_llsc(regs)) {
+			TRIG_EVENT(trap_exit_hook);
 			return;
+		}
 
 	force_sig(SIGILL, current);
+	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_cpu(struct pt_regs *regs)
@@ -665,6 +691,8 @@ asmlinkage void do_cpu(struct pt_regs *r
 
 	die_if_kernel("do_cpu invoked from kernel context!", regs);
 
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
+
 	cpid = (regs->cp0_cause >> CAUSEB_CE) & 3;
 
 	switch (cpid) {
@@ -672,8 +700,10 @@ asmlinkage void do_cpu(struct pt_regs *r
 		if (cpu_has_llsc)
 			break;
 
-		if (!simulate_llsc(regs))
+		if (!simulate_llsc(regs)) {
+			TRIG_EVENT(trap_exit_hook);
 			return;
+		}
 		break;
 
 	case 1:
@@ -692,6 +722,7 @@ asmlinkage void do_cpu(struct pt_regs *r
 				force_sig(sig, current);
 		}
 
+		TRIG_EVENT(trap_exit_hook);
 		return;
 
 	case 2:
@@ -700,6 +731,7 @@ asmlinkage void do_cpu(struct pt_regs *r
 	}
 
 	force_sig(SIGILL, current);
+	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void do_mdmx(struct pt_regs *regs)
@@ -709,19 +741,24 @@ asmlinkage void do_mdmx(struct pt_regs *
 
 asmlinkage void do_watch(struct pt_regs *regs)
 {
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
+
 	/*
 	 * We use the watch exception where available to detect stack
 	 * overflows.
 	 */
 	dump_tlb_all();
 	show_regs(regs);
+	TRIG_EVENT(trap_exit_hook);
 	panic("Caught WATCH exception - probably caused by stack overflow.");
 }
 
 asmlinkage void do_mcheck(struct pt_regs *regs)
 {
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
 	show_regs(regs);
 	dump_tlb_all();
+	TRIG_EVENT(trap_exit_hook);
 	/*
 	 * Some chips may have other causes of machine check (e.g. SB1
 	 * graduation timer)
@@ -759,6 +796,7 @@ static inline void parity_protection_ini
 	default:
 		break;
 	}
+	TRIG_EVENT(trap_exit_hook);
 }
 
 asmlinkage void cache_parity_error(void)
Index: linux.t/arch/mips/kernel/time.c
===================================================================
--- linux.t.orig/arch/mips/kernel/time.c	2004-03-11 14:13:06.000000000 -0500
+++ linux.t/arch/mips/kernel/time.c	2004-03-22 20:23:56.902951756 -0500
@@ -24,6 +24,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
@@ -551,6 +552,7 @@ irqreturn_t timer_interrupt(int irq, voi
 
 asmlinkage void ll_timer_interrupt(int irq, struct pt_regs *regs)
 {
+	TRIG_EVENT(irq_entry_hook, irq, regs, CAUSE_EPC(regs));
 	irq_enter();
 	kstat_this_cpu.irqs[irq]++;
 
@@ -558,6 +560,7 @@ asmlinkage void ll_timer_interrupt(int i
 	timer_interrupt(irq, NULL, regs);
 
 	irq_exit();
+	TRIG_EVENT(irq_exit_hook, irq, regs);	
 }
 
 asmlinkage void ll_local_timer_interrupt(int irq, struct pt_regs *regs)
Index: linux.t/arch/mips/kernel/process.c
===================================================================
--- linux.t.orig/arch/mips/kernel/process.c	2004-03-11 14:13:06.000000000 -0500
+++ linux.t/arch/mips/kernel/process.c	2004-03-22 20:23:56.901952051 -0500
@@ -23,6 +23,7 @@
 #include <linux/a.out.h>
 #include <linux/init.h>
 #include <linux/completion.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
@@ -187,6 +188,10 @@ long kernel_thread(int (*fn)(void *), vo
 		: "$2", "$3", "$4", "$5", "$6", "$7", "$8",
 		  "$9","$10","$11","$12","$13","$14","$15","$24","$25","$31");
 
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	if (retval > 0)
+		TRIG_EVENT(kthread_hook, retval, (int) fn);
+#endif
 	return retval;
 }
 
Index: linux.t/arch/mips/kernel/unaligned.c
===================================================================
--- linux.t.orig/arch/mips/kernel/unaligned.c	2004-03-11 14:13:06.000000000 -0500
+++ linux.t/arch/mips/kernel/unaligned.c	2004-03-22 20:23:56.905950872 -0500
@@ -78,6 +78,7 @@
 #include <linux/signal.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/asm.h>
 #include <asm/branch.h>
@@ -497,14 +498,18 @@ asmlinkage void do_ade(struct pt_regs *r
 	mm_segment_t seg;
 	unsigned long pc;
 
+	TRIG_EVENT(trap_entry_hook, CAUSE_EXCCODE(regs), CAUSE_EPC(regs));
+
 	/*
 	 * Address errors may be deliberately induced by the FPU emulator to
 	 * retake control of the CPU after executing the instruction in the
 	 * delay slot of an emulated branch.
 	 */
 	/* Terminate if exception was recognized as a delay slot return */
-	if (do_dsemulret(regs))
+	if (do_dsemulret(regs)) {
+		TRIG_EVENT(trap_exit_hook);
 		return;
+	}
 
 	/* Otherwise handle as normal */
 
@@ -538,6 +543,7 @@ asmlinkage void do_ade(struct pt_regs *r
 	}
 	set_fs(seg);
 
+	TRIG_EVENT(trap_exit_hook);
 	return;
 
 sigbus:
@@ -547,4 +553,5 @@ sigbus:
 	/*
 	 * XXX On return from the signal handler we should advance the epc
 	 */
+	TRIG_EVENT(trap_exit_hook);
 }
Index: linux.t/arch/s390/mm/fault.c
===================================================================
--- linux.t.orig/arch/s390/mm/fault.c	2004-02-05 16:56:17.000000000 -0500
+++ linux.t/arch/s390/mm/fault.c	2004-03-22 20:23:56.929943801 -0500
@@ -5,6 +5,7 @@
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Hartmut Penner (hp@de.ibm.com)
  *               Ulrich Weigand (uweigand@de.ibm.com)
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/mm/fault.c"
  *    Copyright (C) 1995  Linus Torvalds
@@ -25,6 +26,7 @@
 #include <linux/init.h>
 #include <linux/console.h>
 #include <linux/module.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -166,6 +168,8 @@ extern inline void do_exception(struct p
 	int user_address;
 	const struct exception_table_entry *fixup;
 	int si_code = SEGV_MAPERR;
+        trapid_t ltt_interruption_code;                 
+        char * ic_ptr = (char *) &ltt_interruption_code; 
 
         tsk = current;
         mm = tsk->mm;
@@ -213,6 +217,9 @@ extern inline void do_exception(struct p
 	 */
 	local_irq_enable();
 
+        memset(&ltt_interruption_code,0,sizeof(ltt_interruption_code));
+        memcpy(ic_ptr+4,&error_code,sizeof(error_code));
+        TRIG_EVENT(trap_entry_hook, ltt_interruption_code,(regs->psw.addr & PSW_ADDR_INSN));
         down_read(&mm->mmap_sem);
 
         vma = find_vma(mm, address);
@@ -261,6 +268,7 @@ survive:
 	}
 
         up_read(&mm->mmap_sem);
+        TRIG_EVENT(trap_exit_hook);
         return;
 
 /*
@@ -275,6 +283,7 @@ bad_area:
                 tsk->thread.prot_addr = address;
                 tsk->thread.trap_no = error_code;
 		force_sigsegv(regs, error_code, si_code, address);
+                TRIG_EVENT(trap_exit_hook);
                 return;
 	}
 
@@ -283,6 +292,7 @@ no_context:
 	fixup = search_exception_tables(regs->psw.addr & __FIXUP_MASK);
 	if (fixup) {
 		regs->psw.addr = fixup->fixup | PSW_ADDR_AMODE;
+		TRIG_EVENT(trap_exit_hook);
                 return;
         }
 
@@ -330,6 +340,8 @@ do_sigbus:
 	/* Kernel mode? Handle exceptions or die */
 	if (!(regs->psw.mask & PSW_MASK_PSTATE))
 		goto no_context;
+
+	TRIG_EVENT(trap_exit_hook);
 }
 
 void do_protection_exception(struct pt_regs *regs, unsigned long error_code)
Index: linux.t/arch/s390/Kconfig
===================================================================
--- linux.t.orig/arch/s390/Kconfig	2004-03-22 20:23:56.795983283 -0500
+++ linux.t/arch/s390/Kconfig	2004-03-22 20:23:56.921946158 -0500
@@ -447,7 +447,33 @@ config ASM_HOOK
 config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
-	
+
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
+config TRIGEVENT_SYSCALL_HOOK
+	bool " Enable syscall entry/exit hooks"
+	depends on TRIGEVENT_HOOKS
+	help 
+	RAS hooks to enable tracing of system call entry and exit points.
+	 To enable RAS Syscall Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/s390/kernel/entry.S
===================================================================
--- linux.t.orig/arch/s390/kernel/entry.S	2004-03-22 20:22:11.455036607 -0500
+++ linux.t/arch/s390/kernel/entry.S	2004-03-22 20:23:56.923945569 -0500
@@ -7,6 +7,7 @@
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
  *               Hartmut Penner (hp@de.ibm.com),
  *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com),
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  */
 
 #include <linux/sys.h>
@@ -184,6 +185,14 @@ system_call:
 	lh	%r7,0x8a	  # get svc number from lowcore
         stosm   24(%r15),0x03     # reenable interrupts
         GET_THREAD_INFO           # load pointer to task_struct to R9
+/* call to ltt trace done here.  R8 has the syscall (svc) number to trace */
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK /* tjh - ltt port */              
+        /* add call to pre_syscall */                          
+	la      %r2,SP_PTREGS(%r15)   # load pt_regs as first parameter     
+	l       %r1,BASED(.Lpresyscall)                                    
+	basr    %r14,%r1                                                    
+	lm      %r0,%r6,SP_R0(%r15) /* restore call clobbered regs tjh */   
+#endif
 	sla	%r7,2             # *4 and test for svc 0
 	bnz	BASED(sysc_do_restart)  # svc number > 0
 	# svc 0: system call number in %r1
@@ -200,6 +209,13 @@ sysc_do_restart:
                                   # ATTENTION: check sys_execve_glue before
                                   # changing anything here !!
 
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK /* tjh - ltt port *            
+        /* add call to post_syscall */ 
+        la      %r2,SP_PTREGS(%r15)   # load pt_regs as first parameter  
+        l       %r1,BASED(.Lpostsyscall)                                 
+        basr    %r14,%r1                                                 
+        lm      %r0,%r6,SP_R0(%r15) /* restore call clobbered regs */
+#endif                                                                   
 sysc_return:
 	stnsm   24(%r15),0xfc     # disable I/O and ext. interrupts
 	tm	SP_PSW+1(%r15),0x01	# returning to user ?
@@ -710,6 +726,9 @@ restart_go:
 .Lsigaltstack: .long  sys_sigaltstack
 .Ltrace:       .long  syscall_trace
 .Lvfork:       .long  sys_vfork
+.Lpresyscall:  .long  pre_syscall
+.Lpostsyscall: .long  post_syscall 
+
 .Lschedtail:   .long  schedule_tail
 
 
Index: linux.t/arch/s390/kernel/sys_s390.c
===================================================================
--- linux.t.orig/arch/s390/kernel/sys_s390.c	2004-03-22 20:22:11.460035133 -0500
+++ linux.t/arch/s390/kernel/sys_s390.c	2004-03-22 20:23:56.925944979 -0500
@@ -28,6 +28,7 @@
 #ifdef CONFIG_ARCH_S390X
 #include <linux/personality.h>
 #endif /* CONFIG_ARCH_S390X */
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -188,6 +189,8 @@ asmlinkage __SYS_RETTYPE sys_ipc (uint c
         struct ipc_kludge tmp;
 	int ret;
 
+        TRIG_EVENT(ipc_call_hook, call, first);
+
         switch (call) {
         case SEMOP:
 		return sys_semtimedop (first, (struct sembuf *) ptr, second,
Index: linux.t/arch/s390/kernel/traps.c
===================================================================
--- linux.t.orig/arch/s390/kernel/traps.c	2004-03-22 20:22:24.877079183 -0500
+++ linux.t/arch/s390/kernel/traps.c	2004-03-22 20:23:56.927944390 -0500
@@ -5,6 +5,7 @@
  *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
  *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com),
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  *
  *  Derived from "arch/i386/kernel/traps.c"
  *    Copyright (C) 1991, 1992 Linus Torvalds
@@ -30,6 +31,8 @@
 #include <linux/module.h>
 #include <linux/kallsyms.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -104,551 +107,3 @@ void show_trace(struct task_struct *task
 	}
 	printk("\n");
 }
-
-void show_trace_task(struct task_struct *tsk)
-{
-	/*
-	 * We can't print the backtrace of a running process. It is
-	 * unreliable at best and can cause kernel oopses.
-	 */
-	if (tsk->state == TASK_RUNNING)
-		return;
-	show_trace(tsk, (unsigned long *) tsk->thread.ksp);
-}
-
-void show_stack(struct task_struct *task, unsigned long *sp)
-{
-	unsigned long *stack;
-	int i;
-
-	// debugging aid: "show_stack(NULL);" prints the
-	// back trace for this cpu.
-
-	if (!sp) {
-		if (task)
-			sp = (unsigned long *) task->thread.ksp;
-		else
-			sp = *stack_pointer;
-	}
-
-	stack = sp;
-	for (i = 0; i < kstack_depth_to_print; i++) {
-		if (((addr_t) stack & (THREAD_SIZE-1)) == 0)
-			break;
-		if (i && ((i * sizeof (long) % 32) == 0))
-			printk("\n       ");
-		printk("%p ", (void *)*stack++);
-	}
-	printk("\n");
-	show_trace(task, sp);
-}
-
-/*
- * The architecture-independent dump_stack generator
- */
-void dump_stack(void)
-{
-	show_stack(0, 0);
-}
-
-EXPORT_SYMBOL(dump_stack);
-
-void show_registers(struct pt_regs *regs)
-{
-	mm_segment_t old_fs;
-	char *mode;
-	int i;
-
-	mode = (regs->psw.mask & PSW_MASK_PSTATE) ? "User" : "Krnl";
-	printk("%s PSW : %p %p",
-	       mode, (void *) regs->psw.mask,
-	       (void *) regs->psw.addr);
-	print_symbol(" (%s)\n", regs->psw.addr & PSW_ADDR_INSN);
-	printk("%s GPRS: " FOURLONG, mode,
-	       regs->gprs[0], regs->gprs[1], regs->gprs[2], regs->gprs[3]);
-	printk("           " FOURLONG,
-	       regs->gprs[4], regs->gprs[5], regs->gprs[6], regs->gprs[7]);
-	printk("           " FOURLONG,
-	       regs->gprs[8], regs->gprs[9], regs->gprs[10], regs->gprs[11]);
-	printk("           " FOURLONG,
-	       regs->gprs[12], regs->gprs[13], regs->gprs[14], regs->gprs[15]);
-
-	printk("%s ACRS: %08x %08x %08x %08x\n", mode,
-	       regs->acrs[0], regs->acrs[1], regs->acrs[2], regs->acrs[3]);
-	printk("           %08x %08x %08x %08x\n",
-	       regs->acrs[4], regs->acrs[5], regs->acrs[6], regs->acrs[7]);
-	printk("           %08x %08x %08x %08x\n",
-	       regs->acrs[8], regs->acrs[9], regs->acrs[10], regs->acrs[11]);
-	printk("           %08x %08x %08x %08x\n",
-	       regs->acrs[12], regs->acrs[13], regs->acrs[14], regs->acrs[15]);
-
-	/*
-	 * Print the first 20 byte of the instruction stream at the
-	 * time of the fault.
-	 */
-	old_fs = get_fs();
-	if (regs->psw.mask & PSW_MASK_PSTATE)
-		set_fs(USER_DS);
-	else
-		set_fs(KERNEL_DS);
-	printk("%s Code: ", mode);
-	for (i = 0; i < 20; i++) {
-		unsigned char c;
-		if (__get_user(c, (char *)(regs->psw.addr + i))) {
-			printk(" Bad PSW.");
-			break;
-		}
-		printk("%02x ", c);
-	}
-	set_fs(old_fs);
-
-	printk("\n");
-}	
-
-/* This is called from fs/proc/array.c */
-char *task_show_regs(struct task_struct *task, char *buffer)
-{
-	struct pt_regs *regs;
-
-	regs = __KSTK_PTREGS(task);
-	buffer += sprintf(buffer, "task: %p, ksp: %p\n",
-		       task, (void *)task->thread.ksp);
-	buffer += sprintf(buffer, "User PSW : %p %p\n",
-		       (void *) regs->psw.mask, (void *)regs->psw.addr);
-
-	buffer += sprintf(buffer, "User GPRS: " FOURLONG,
-			  regs->gprs[0], regs->gprs[1],
-			  regs->gprs[2], regs->gprs[3]);
-	buffer += sprintf(buffer, "           " FOURLONG,
-			  regs->gprs[4], regs->gprs[5],
-			  regs->gprs[6], regs->gprs[7]);
-	buffer += sprintf(buffer, "           " FOURLONG,
-			  regs->gprs[8], regs->gprs[9],
-			  regs->gprs[10], regs->gprs[11]);
-	buffer += sprintf(buffer, "           " FOURLONG,
-			  regs->gprs[12], regs->gprs[13],
-			  regs->gprs[14], regs->gprs[15]);
-	buffer += sprintf(buffer, "User ACRS: %08x %08x %08x %08x\n",
-			  regs->acrs[0], regs->acrs[1],
-			  regs->acrs[2], regs->acrs[3]);
-	buffer += sprintf(buffer, "           %08x %08x %08x %08x\n",
-			  regs->acrs[4], regs->acrs[5],
-			  regs->acrs[6], regs->acrs[7]);
-	buffer += sprintf(buffer, "           %08x %08x %08x %08x\n",
-			  regs->acrs[8], regs->acrs[9],
-			  regs->acrs[10], regs->acrs[11]);
-	buffer += sprintf(buffer, "           %08x %08x %08x %08x\n",
-			  regs->acrs[12], regs->acrs[13],
-			  regs->acrs[14], regs->acrs[15]);
-	return buffer;
-}
-
-spinlock_t die_lock = SPIN_LOCK_UNLOCKED;
-
-void die(const char * str, struct pt_regs * regs, long err)
-{
-	static int die_counter;
-        console_verbose();
-        spin_lock_irq(&die_lock);
-	bust_spinlocks(1);
-	printk("%s: %04lx [#%d]\n", str, err & 0xffff, ++die_counter);
-        show_regs(regs);
-	bust_spinlocks(0);
-        spin_unlock_irq(&die_lock);
-	if (in_interrupt())
-		panic("Fatal exception in interrupt");
-	if (panic_on_oops)
-		panic("Fatal exception: panic_on_oops");
-        do_exit(SIGSEGV);
-}
-
-static void inline do_trap(long interruption_code, int signr, char *str,
-                           struct pt_regs *regs, siginfo_t *info)
-{
-	/*
-	 * We got all needed information from the lowcore and can
-	 * now safely switch on interrupts.
-	 */
-        if (regs->psw.mask & PSW_MASK_PSTATE)
-		local_irq_enable();
-
-        if (regs->psw.mask & PSW_MASK_PSTATE) {
-                struct task_struct *tsk = current;
-
-                tsk->thread.trap_no = interruption_code & 0xffff;
-		if (info)
-			force_sig_info(signr, info, tsk);
-		else
-                	force_sig(signr, tsk);
-#ifndef CONFIG_SYSCTL
-#ifdef CONFIG_PROCESS_DEBUG
-                printk("User process fault: interruption code 0x%lX\n",
-                       interruption_code);
-                show_regs(regs);
-#endif
-#else
-		if (sysctl_userprocess_debug) {
-			printk("User process fault: interruption code 0x%lX\n",
-			       interruption_code);
-			show_regs(regs);
-		}
-#endif
-        } else {
-                const struct exception_table_entry *fixup;
-                fixup = search_exception_tables(regs->psw.addr & PSW_ADDR_INSN);
-                if (fixup)
-                        regs->psw.addr = fixup->fixup | PSW_ADDR_AMODE;
-                else
-                        die(str, regs, interruption_code);
-        }
-}
-
-static inline void *get_check_address(struct pt_regs *regs)
-{
-	return (void *)((regs->psw.addr-S390_lowcore.pgm_ilc) & PSW_ADDR_INSN);
-}
-
-int do_debugger_trap(struct pt_regs *regs)
-{
-	if ((regs->psw.mask & PSW_MASK_PSTATE) &&
-	    (current->ptrace & PT_PTRACED)) {
-		force_sig(SIGTRAP,current);
-		return 0;
-	}
-	return 1;
-}
-
-#define DO_ERROR(signr, str, name) \
-asmlinkage void name(struct pt_regs * regs, long interruption_code) \
-{ \
-	do_trap(interruption_code, signr, str, regs, NULL); \
-}
-
-#define DO_ERROR_INFO(signr, str, name, sicode, siaddr) \
-asmlinkage void name(struct pt_regs * regs, long interruption_code) \
-{ \
-        siginfo_t info; \
-        info.si_signo = signr; \
-        info.si_errno = 0; \
-        info.si_code = sicode; \
-        info.si_addr = (void *)siaddr; \
-        do_trap(interruption_code, signr, str, regs, &info); \
-}
-
-DO_ERROR(SIGSEGV, "Unknown program exception", default_trap_handler)
-
-DO_ERROR_INFO(SIGBUS, "addressing exception", addressing_exception,
-	      BUS_ADRERR, get_check_address(regs))
-DO_ERROR_INFO(SIGILL,  "execute exception", execute_exception,
-	      ILL_ILLOPN, get_check_address(regs))
-DO_ERROR_INFO(SIGFPE,  "fixpoint divide exception", divide_exception,
-	      FPE_INTDIV, get_check_address(regs))
-DO_ERROR_INFO(SIGILL,  "operand exception", operand_exception,
-	      ILL_ILLOPN, get_check_address(regs))
-DO_ERROR_INFO(SIGILL,  "privileged operation", privileged_op,
-	      ILL_PRVOPC, get_check_address(regs))
-DO_ERROR_INFO(SIGILL,  "special operation exception", special_op_exception,
-	      ILL_ILLOPN, get_check_address(regs))
-DO_ERROR_INFO(SIGILL,  "translation exception", translation_exception,
-	      ILL_ILLOPN, get_check_address(regs))
-
-static inline void
-do_fp_trap(struct pt_regs *regs, void *location,
-           int fpc, long interruption_code)
-{
-	siginfo_t si;
-
-	si.si_signo = SIGFPE;
-	si.si_errno = 0;
-	si.si_addr = location;
-	si.si_code = 0;
-	/* FPC[2] is Data Exception Code */
-	if ((fpc & 0x00000300) == 0) {
-		/* bits 6 and 7 of DXC are 0 iff IEEE exception */
-		if (fpc & 0x8000) /* invalid fp operation */
-			si.si_code = FPE_FLTINV;
-		else if (fpc & 0x4000) /* div by 0 */
-			si.si_code = FPE_FLTDIV;
-		else if (fpc & 0x2000) /* overflow */
-			si.si_code = FPE_FLTOVF;
-		else if (fpc & 0x1000) /* underflow */
-			si.si_code = FPE_FLTUND;
-		else if (fpc & 0x0800) /* inexact */
-			si.si_code = FPE_FLTRES;
-	}
-	current->thread.ieee_instruction_pointer = (addr_t) location;
-	do_trap(interruption_code, SIGFPE,
-		"floating point exception", regs, &si);
-}
-
-asmlinkage void illegal_op(struct pt_regs * regs, long interruption_code)
-{
-        __u8 opcode[6];
-	__u16 *location;
-	int signal = 0;
-
-	location = (__u16 *) get_check_address(regs);
-
-	/*
-	 * We got all needed information from the lowcore and can
-	 * now safely switch on interrupts.
-	 */
-	if (regs->psw.mask & PSW_MASK_PSTATE)
-		local_irq_enable();
-
-	if (regs->psw.mask & PSW_MASK_PSTATE)
-		get_user(*((__u16 *) opcode), location);
-	else
-		*((__u16 *)opcode)=*((__u16 *)location);
-	if (*((__u16 *)opcode)==S390_BREAKPOINT_U16)
-        {
-		if(do_debugger_trap(regs))
-			signal = SIGILL;
-	}
-#ifdef CONFIG_MATHEMU
-        else if (regs->psw.mask & PSW_MASK_PSTATE)
-	{
-		if (opcode[0] == 0xb3) {
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_b3(opcode, regs);
-                } else if (opcode[0] == 0xed) {
-			get_user(*((__u32 *) (opcode+2)),
-				 (__u32 *)(location+1));
-			signal = math_emu_ed(opcode, regs);
-		} else if (*((__u16 *) opcode) == 0xb299) {
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_srnm(opcode, regs);
-		} else if (*((__u16 *) opcode) == 0xb29c) {
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_stfpc(opcode, regs);
-		} else if (*((__u16 *) opcode) == 0xb29d) {
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_lfpc(opcode, regs);
-		} else
-			signal = SIGILL;
-        }
-#endif 
-	else
-		signal = SIGILL;
-        if (signal == SIGFPE)
-		do_fp_trap(regs, location,
-                           current->thread.fp_regs.fpc, interruption_code);
-        else if (signal)
-		do_trap(interruption_code, signal,
-			"illegal operation", regs, NULL);
-}
-
-
-#ifdef CONFIG_MATHEMU
-asmlinkage void 
-specification_exception(struct pt_regs * regs, long interruption_code)
-{
-        __u8 opcode[6];
-	__u16 *location = NULL;
-	int signal = 0;
-
-	location = (__u16 *) get_check_address(regs);
-
-	/*
-	 * We got all needed information from the lowcore and can
-	 * now safely switch on interrupts.
-	 */
-	if (regs->psw.mask & PSW_MASK_PSTATE)
-		local_irq_enable();
-		
-        if (regs->psw.mask & PSW_MASK_PSTATE) {
-		get_user(*((__u16 *) opcode), location);
-		switch (opcode[0]) {
-		case 0x28: /* LDR Rx,Ry   */
-			signal = math_emu_ldr(opcode);
-			break;
-		case 0x38: /* LER Rx,Ry   */
-			signal = math_emu_ler(opcode);
-			break;
-		case 0x60: /* STD R,D(X,B) */
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_std(opcode, regs);
-			break;
-		case 0x68: /* LD R,D(X,B) */
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_ld(opcode, regs);
-			break;
-		case 0x70: /* STE R,D(X,B) */
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_ste(opcode, regs);
-			break;
-		case 0x78: /* LE R,D(X,B) */
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_le(opcode, regs);
-			break;
-		default:
-			signal = SIGILL;
-			break;
-                }
-        } else
-		signal = SIGILL;
-        if (signal == SIGFPE)
-		do_fp_trap(regs, location,
-                           current->thread.fp_regs.fpc, interruption_code);
-        else if (signal) {
-		siginfo_t info;
-		info.si_signo = signal;
-		info.si_errno = 0;
-		info.si_code = ILL_ILLOPN;
-		info.si_addr = location;
-		do_trap(interruption_code, signal, 
-			"specification exception", regs, &info);
-	}
-}
-#else
-DO_ERROR_INFO(SIGILL, "specification exception", specification_exception,
-	      ILL_ILLOPN, get_check_address(regs));
-#endif
-
-asmlinkage void data_exception(struct pt_regs * regs, long interruption_code)
-{
-	__u16 *location;
-	int signal = 0;
-
-	location = (__u16 *) get_check_address(regs);
-
-	/*
-	 * We got all needed information from the lowcore and can
-	 * now safely switch on interrupts.
-	 */
-	if (regs->psw.mask & PSW_MASK_PSTATE)
-		local_irq_enable();
-
-	if (MACHINE_HAS_IEEE)
-		__asm__ volatile ("stfpc %0\n\t" 
-				  : "=m" (current->thread.fp_regs.fpc));
-
-#ifdef CONFIG_MATHEMU
-        else if (regs->psw.mask & PSW_MASK_PSTATE) {
-        	__u8 opcode[6];
-		get_user(*((__u16 *) opcode), location);
-		switch (opcode[0]) {
-		case 0x28: /* LDR Rx,Ry   */
-			signal = math_emu_ldr(opcode);
-			break;
-		case 0x38: /* LER Rx,Ry   */
-			signal = math_emu_ler(opcode);
-			break;
-		case 0x60: /* STD R,D(X,B) */
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_std(opcode, regs);
-			break;
-		case 0x68: /* LD R,D(X,B) */
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_ld(opcode, regs);
-			break;
-		case 0x70: /* STE R,D(X,B) */
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_ste(opcode, regs);
-			break;
-		case 0x78: /* LE R,D(X,B) */
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_le(opcode, regs);
-			break;
-		case 0xb3:
-			get_user(*((__u16 *) (opcode+2)), location+1);
-			signal = math_emu_b3(opcode, regs);
-			break;
-                case 0xed:
-			get_user(*((__u32 *) (opcode+2)),
-				 (__u32 *)(location+1));
-			signal = math_emu_ed(opcode, regs);
-			break;
-	        case 0xb2:
-			if (opcode[1] == 0x99) {
-				get_user(*((__u16 *) (opcode+2)), location+1);
-				signal = math_emu_srnm(opcode, regs);
-			} else if (opcode[1] == 0x9c) {
-				get_user(*((__u16 *) (opcode+2)), location+1);
-				signal = math_emu_stfpc(opcode, regs);
-			} else if (opcode[1] == 0x9d) {
-				get_user(*((__u16 *) (opcode+2)), location+1);
-				signal = math_emu_lfpc(opcode, regs);
-			} else
-				signal = SIGILL;
-			break;
-		default:
-			signal = SIGILL;
-			break;
-                }
-        }
-#endif 
-	if (current->thread.fp_regs.fpc & FPC_DXC_MASK)
-		signal = SIGFPE;
-	else
-		signal = SIGILL;
-        if (signal == SIGFPE)
-		do_fp_trap(regs, location,
-                           current->thread.fp_regs.fpc, interruption_code);
-        else if (signal) {
-		siginfo_t info;
-		info.si_signo = signal;
-		info.si_errno = 0;
-		info.si_code = ILL_ILLOPN;
-		info.si_addr = location;
-		do_trap(interruption_code, signal, 
-			"data exception", regs, &info);
-	}
-}
-
-
-
-/* init is done in lowcore.S and head.S */
-
-void __init trap_init(void)
-{
-        int i;
-
-        for (i = 0; i < 128; i++)
-          pgm_check_table[i] = &default_trap_handler;
-        pgm_check_table[1] = &illegal_op;
-        pgm_check_table[2] = &privileged_op;
-        pgm_check_table[3] = &execute_exception;
-        pgm_check_table[4] = &do_protection_exception;
-        pgm_check_table[5] = &addressing_exception;
-        pgm_check_table[6] = &specification_exception;
-        pgm_check_table[7] = &data_exception;
-        pgm_check_table[9] = &divide_exception;
-        pgm_check_table[0x10] = &do_segment_exception;
-        pgm_check_table[0x11] = &do_page_exception;
-        pgm_check_table[0x12] = &translation_exception;
-        pgm_check_table[0x13] = &special_op_exception;
-#ifndef CONFIG_ARCH_S390X
- 	pgm_check_table[0x14] = &do_pseudo_page_fault;
-#else /* CONFIG_ARCH_S390X */
-        pgm_check_table[0x38] = &addressing_exception;
-        pgm_check_table[0x3B] = &do_region_exception;
-#endif /* CONFIG_ARCH_S390X */
-        pgm_check_table[0x15] = &operand_exception;
-        pgm_check_table[0x1C] = &privileged_op;
-#if defined(CONFIG_VIRT_TIMER) || defined(CONFIG_NO_IDLE_HZ)
-	pgm_check_table[0x40] = &do_monitor_call;
-#endif
-	if (MACHINE_IS_VM) {
-		/*
-		 * First try to get pfault pseudo page faults going.
-		 * If this isn't available turn on pagex page faults.
-		 */
-#ifdef CONFIG_PFAULT
-		/* request the 0x2603 external interrupt */
-		if (register_early_external_interrupt(0x2603, pfault_interrupt,
-						      &ext_int_pfault) != 0)
-			panic("Couldn't request external interrupt 0x2603");
-
-		if (pfault_init() == 0) 
-			return;
-		
-		/* Tough luck, no pfault. */
-		unregister_early_external_interrupt(0x2603, pfault_interrupt,
-						    &ext_int_pfault);
-#endif
-#ifndef CONFIG_ARCH_S390X
-		cpcmd("SET PAGEX ON", NULL, 0);
-#endif
-	}
-}
Index: linux.t/arch/s390/kernel/time.c
===================================================================
--- linux.t.orig/arch/s390/kernel/time.c	2004-03-22 20:22:24.876079478 -0500
+++ linux.t/arch/s390/kernel/time.c	2004-03-22 20:23:56.926944685 -0500
@@ -26,6 +26,7 @@
 #include <linux/types.h>
 #include <linux/timex.h>
 #include <linux/config.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/delay.h>
@@ -299,6 +300,7 @@ void account_ticks(struct pt_regs *regs)
 	 * Spread it over all cpus instead.
 	 */
 	write_seqlock(&xtime_lock);
+	TRIG_EVENT(timer_hook, regs);
 	if (S390_lowcore.jiffy_timer > xtime_cc) {
 		__u32 xticks;
 
Index: linux.t/arch/s390/kernel/process.c
===================================================================
--- linux.t.orig/arch/s390/kernel/process.c	2004-03-22 20:22:24.874080067 -0500
+++ linux.t/arch/s390/kernel/process.c	2004-03-22 20:23:56.924945274 -0500
@@ -179,6 +179,7 @@ __asm__(".align 4\n"
 int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
 {
 	struct pt_regs regs;
+	int ret = 0;
 
 	memset(&regs, 0, sizeof(regs));
 	regs.psw.mask = PSW_KERNEL_BITS;
@@ -191,8 +192,15 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.orig_gpr2 = -1;
 
 	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED,
+
+	ret = do_fork(flags | CLONE_VM | CLONE_UNTRACED,
 		       0, &regs, 0, NULL, NULL);
+	
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+	if (ret > 0)
+		TRIG_EVENT(kthread_hook, ret, (int) fn);
+#endif
+	return ret;
 }
 
 /*
Index: linux.t/arch/alpha/Kconfig
===================================================================
--- linux.t.orig/arch/alpha/Kconfig	2004-03-22 20:23:56.781987408 -0500
+++ linux.t/arch/alpha/Kconfig	2004-03-22 20:23:56.875959712 -0500
@@ -704,6 +704,25 @@ config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
 
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/ppc64/kernel/irq.c
===================================================================
--- linux.t.orig/arch/ppc64/kernel/irq.c	2004-03-22 20:22:15.862737115 -0500
+++ linux.t/arch/ppc64/kernel/irq.c	2004-03-22 20:23:56.919946747 -0500
@@ -42,6 +42,8 @@
 #include <linux/random.h>
 #include <linux/kallsyms.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
 #include <asm/system.h>
@@ -487,6 +489,8 @@ void ppc_irq_dispatch_handler(struct pt_
 	irq_desc_t *desc = get_irq_desc(irq);
 	irqreturn_t action_ret;
 
+	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
+	
 	kstat_cpu(cpu).irqs[irq]++;
 
 	if (desc->status & IRQ_PER_CPU) {
@@ -494,6 +498,7 @@ void ppc_irq_dispatch_handler(struct pt_
 		ack_irq(irq);
 		action_ret = handle_irq_event(irq, regs, desc->action);
 		desc->handler->end(irq);
+		TRIG_EVENT(irq_exit_hook, irq, regs);
 		return;
 	}
 
@@ -573,6 +578,8 @@ out:
 			desc->handler->enable(irq);
 	}
 	spin_unlock(&desc->lock);
+	
+	TRIG_EVENT(irq_exit_hook, irq, regs);
 }
 
 #ifdef CONFIG_PPC_ISERIES
Index: linux.t/arch/ppc64/kernel/time.c
===================================================================
--- linux.t.orig/arch/ppc64/kernel/time.c	2004-03-11 14:13:07.000000000 -0500
+++ linux.t/arch/ppc64/kernel/time.c	2004-03-22 20:23:56.920946452 -0500
@@ -48,6 +48,7 @@
 #include <linux/time.h>
 #include <linux/init.h>
 #include <linux/profile.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
@@ -280,6 +281,7 @@ int timer_interrupt(struct pt_regs * reg
 	while (lpaca->next_jiffy_update_tb <= (cur_tb = get_tb())) {
 
 #ifdef CONFIG_SMP
+		TRIG_EVENT(timer_hook, regs);
 		smp_local_timer_interrupt(regs);
 #endif
 		if (cpu == boot_cpuid) {
Index: linux.t/arch/sparc/Kconfig
===================================================================
--- linux.t.orig/arch/sparc/Kconfig	2004-03-22 20:23:56.797982694 -0500
+++ linux.t/arch/sparc/Kconfig	2004-03-22 20:23:56.938941149 -0500
@@ -460,6 +460,25 @@ config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
 
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/sparc64/Kconfig
===================================================================
--- linux.t.orig/arch/sparc64/Kconfig	2004-03-22 20:23:56.799982105 -0500
+++ linux.t/arch/sparc64/Kconfig	2004-03-22 20:23:56.939940854 -0500
@@ -713,6 +713,25 @@ config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
 
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/parisc/Kconfig
===================================================================
--- linux.t.orig/arch/parisc/Kconfig	2004-03-22 20:23:56.791984462 -0500
+++ linux.t/arch/parisc/Kconfig	2004-03-22 20:23:56.907950283 -0500
@@ -235,6 +235,25 @@ config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
 
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/x86_64/Kconfig
===================================================================
--- linux.t.orig/arch/x86_64/Kconfig	2004-03-22 20:23:56.800981810 -0500
+++ linux.t/arch/x86_64/Kconfig	2004-03-22 20:23:56.940940560 -0500
@@ -510,6 +510,25 @@ config HOOK_PROCFS
 	bool "/proc interface for hooks" 
 	depends on DEBUG_KERNEL && HOOK
 
+config TRIGEVENT_HOOKS
+	bool "RAS Instrumentation Hooks"
+	depends on HOOK=y 
+	help 
+	RAS Instrumentation Hooks are kernel hooks to trace system calls and
+	 events used by Linux Trace Toolkit. These hooks may be used by other tools 
+	 also.
+
+	 RAS hooks trace Interprocess communication routines (sys_ipc, sys_msgget, 
+	 sys_semget, sys_shmget etc), IRQ's entry and exit points, Kernel timer 
+	 routines, Kernel threads create routine, Process Management routines (such as 
+	 fork, exec, exit, wait etc), Process Scheduling switch and dispatch routines, 
+	 Signals, Memory Management routines(such as __get_free_pages, __free_pages_ok, 
+	 do_swap_page, swap_writepage etc), Network packets transmit and receive 
+	 routines, Sockets  create, send, receive routines, tasklets, Trap 
+	 entry and exit routines etc.
+
+	 To enable RAS Instrumentation Hooks, say Y. If in doubt, Say N.	
+
 endmenu
 
 source "security/Kconfig"
Index: linux.t/arch/x86_64/kernel/irq.c
===================================================================
--- linux.t.orig/arch/x86_64/kernel/irq.c	2004-03-11 14:13:08.000000000 -0500
+++ linux.t/arch/x86_64/kernel/irq.c	2004-03-22 20:23:56.943939676 -0500
@@ -34,6 +34,8 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/atomic.h>
 #include <asm/io.h>
 #include <asm/smp.h>
@@ -214,6 +216,8 @@ int handle_IRQ_event(unsigned int irq, s
 {
 	int status = 1; /* Force the "do bottom halves" bit */
 
+	TRIG_EVENT(irq_entry_hook, irq, regs, !(user_mode(regs)));
+
 	if (!(action->flags & SA_INTERRUPT))
 		local_irq_enable();
 
@@ -226,6 +230,8 @@ int handle_IRQ_event(unsigned int irq, s
 		add_interrupt_randomness(irq);
 	local_irq_disable();
 
+	TRIG_EVENT(irq_exit_hook, irq, regs);
+	
 	return status;
 }
 
Index: linux.t/arch/x86_64/kernel/apic.c
===================================================================
--- linux.t.orig/arch/x86_64/kernel/apic.c	2004-03-11 14:13:08.000000000 -0500
+++ linux.t/arch/x86_64/kernel/apic.c	2004-03-22 20:23:56.942939970 -0500
@@ -26,6 +26,7 @@
 #include <linux/mc146818rtc.h>
 #include <linux/kernel_stat.h>
 #include <linux/sysdev.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/atomic.h>
 #include <asm/smp.h>
@@ -857,6 +858,7 @@ void smp_local_timer_interrupt(struct pt
 		}
 
 #ifdef CONFIG_SMP
+		TRIG_EVENT(timer_hook, regs);
 		update_process_times(user_mode(regs));
 #endif
 	}
Index: linux.t/drivers/s390/s390mach.c
===================================================================
--- linux.t.orig/drivers/s390/s390mach.c	2004-03-11 14:13:15.000000000 -0500
+++ linux.t/drivers/s390/s390mach.c	2004-03-22 20:23:56.944939381 -0500
@@ -6,12 +6,14 @@
  *    Copyright (C) 2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Ingo Adlung (adlung@de.ibm.com)
  *		 Martin Schwidefsky (schwidefsky@de.ibm.com)
+ *  Portions added by T. Halloran: (C) Copyright 2002 IBM Poughkeepsie, IBM Corporation
  */
 
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/errno.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/lowcore.h>
 
@@ -142,8 +144,18 @@ void
 s390_do_machine_check(void)
 {
 	struct mci *mci;
+	trapid_t ltt_interruption_code;
+	uint32_t ltt_old_psw;
 
 	mci = (struct mci *) &S390_lowcore.mcck_interruption_code;
+	memcpy( &ltt_interruption_code,
+		&S390_lowcore.mcck_interruption_code,
+		sizeof(__u64));
+	memcpy( &ltt_old_psw,
+		&S390_lowcore.mcck_old_psw,
+		sizeof(uint32_t));
+	ltt_old_psw &=  PSW_ADDR_INSN;
+	TRIG_EVENT(trap_entry_hook, ltt_interruption_code,ltt_old_psw);
 
 	if (mci->sd)		/* system damage */
 		s390_handle_damage("received system damage machine check\n");
Index: linux.t/kernel/Makefile
===================================================================
--- linux.t.orig/kernel/Makefile	2004-03-22 20:23:56.807979748 -0500
+++ linux.t/kernel/Makefile	2004-03-22 20:23:56.962934077 -0500
@@ -23,6 +23,7 @@ obj-$(CONFIG_IKCONFIG_PROC) += configs.o
 obj-$(CONFIG_STOP_MACHINE) += stop_machine.o
 obj-$(CONFIG_EVLOG) += evlbuf.o evlapi.o evlposix.o
 obj-$(CONFIG_HOOK) += hook.o
+obj-$(CONFIG_TRIGEVENT_HOOKS) += trigevent_hooks.o
 
 ifneq ($(CONFIG_IA64),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
Index: linux.t/kernel/signal.c
===================================================================
--- linux.t.orig/kernel/signal.c	2004-03-22 20:22:16.360590330 -0500
+++ linux.t/kernel/signal.c	2004-03-22 20:23:56.974930542 -0500
@@ -21,6 +21,8 @@
 #include <linux/binfmts.h>
 #include <linux/security.h>
 #include <linux/ptrace.h>
+#include <linux/trigevent_hooks.h>
+
 #include <asm/param.h>
 #include <asm/uaccess.h>
 #include <asm/siginfo.h>
@@ -1185,6 +1187,9 @@ send_sig_info(int sig, struct siginfo *i
 	 */
 	read_lock(&tasklist_lock);  
 	spin_lock_irqsave(&p->sighand->siglock, flags);
+
+	TRIG_EVENT(signal_hook, sig, p->pid);
+
 	ret = specific_send_sig_info(sig, info, p);
 	spin_unlock_irqrestore(&p->sighand->siglock, flags);
 	read_unlock(&tasklist_lock);
Index: linux.t/kernel/sched.c
===================================================================
--- linux.t.orig/kernel/sched.c	2004-03-22 20:23:24.543490012 -0500
+++ linux.t/kernel/sched.c	2004-03-22 20:23:56.972931131 -0500
@@ -40,6 +40,7 @@
 #include <linux/cpu.h>
 #include <linux/percpu.h>
 #include <linux/kthread.h>
+#include <linux/trigevent_hooks.h>
 
 #ifdef CONFIG_NUMA
 #define cpu_to_node_mask(cpu) node_to_cpumask(cpu_to_node(cpu))
@@ -440,6 +441,8 @@ static inline void activate_task(task_t 
 
 	recalc_task_prio(p, now);
 
+	TRIG_EVENT(process_wakeup_hook, p->pid, p->state);
+
 	/*
 	 * This checks to make sure it's not an uninterruptible task
 	 * that is now waking up.
@@ -1703,6 +1706,8 @@ switch_tasks:
 		prepare_arch_switch(rq, next);
 		prev = context_switch(rq, prev, next);
 		barrier();
+		
+		TRIG_EVENT(sched_switch_hook, prev, next);
 
 		finish_task_switch(prev);
 	} else
@@ -1710,6 +1715,9 @@ switch_tasks:
 
 	reacquire_kernel_lock(current);
 	preempt_enable_no_resched();
+	
+	TRIG_EVENT(sched_dispatch_hook, prev, next);
+
 	if (test_thread_flag(TIF_NEED_RESCHED))
 		goto need_resched;
 
Index: linux.t/kernel/module.c
===================================================================
--- linux.t.orig/kernel/module.c	2004-03-22 20:22:16.357591214 -0500
+++ linux.t/kernel/module.c	2004-03-22 20:23:56.969932015 -0500
@@ -34,6 +34,8 @@
 #include <linux/vermagic.h>
 #include <linux/notifier.h>
 #include <linux/stop_machine.h>
+#include <linux/trigevent_hooks.h>
+
 #include <asm/uaccess.h>
 #include <asm/semaphore.h>
 #include <asm/pgalloc.h>
@@ -945,6 +947,8 @@ static unsigned long resolve_symbol(Elf_
 /* Free a module, remove from lists, etc (must hold module mutex). */
 static void free_module(struct module *mod)
 {
+	TRIG_EVENT(free_module_hook, mod);
+
 	/* Delete from various lists */
 	spin_lock_irq(&modlist_lock);
 	list_del(&mod->list);
@@ -1625,6 +1629,8 @@ sys_init_module(void __user *umod,
 	notifier_call_chain(&module_notify_list, MODULE_STATE_COMING, mod);
 	up(&notify_mutex);
 
+	TRIG_EVENT(module_init_hook, mod);
+
 	/* Start the module */
 	ret = mod->init();
 	if (ret < 0) {
@@ -1641,6 +1647,7 @@ sys_init_module(void __user *umod,
 			free_module(mod);
 			up(&module_mutex);
 		}
+		TRIG_EVENT(module_init_failed_hook, mod);
 		return ret;
 	}
 
Index: linux.t/kernel/softirq.c
===================================================================
--- linux.t.orig/kernel/softirq.c	2004-03-22 20:22:16.826452976 -0500
+++ linux.t/kernel/softirq.c	2004-03-22 20:23:56.975930247 -0500
@@ -15,6 +15,7 @@
 #include <linux/percpu.h>
 #include <linux/cpu.h>
 #include <linux/kthread.h>
+#include <linux/trigevent_hooks.h>
 
 #ifdef CONFIG_KDB
 #include <linux/kdb.h>
@@ -103,8 +104,10 @@ restart:
 		h = softirq_vec;
 
 		do {
-			if (pending & 1)
+		        if (pending & 1) {
+		                TRIG_EVENT(softirq_hook, (h - softirq_vec));
 				h->action(h);
+			}
 			h++;
 			pending >>= 1;
 		} while (pending);
@@ -231,6 +234,9 @@ static void tasklet_action(struct softir
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+
+				TRIG_EVENT(tasklet_action_hook, (unsigned long) (t->func));
+
 				t->func(t->data);
 				tasklet_unlock(t);
 				continue;
@@ -264,6 +270,9 @@ static void tasklet_hi_action(struct sof
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+
+				TRIG_EVENT(tasklet_hi_action_hook, (unsigned long) (t->func));
+
 				t->func(t->data);
 				tasklet_unlock(t);
 				continue;
Index: linux.t/kernel/timer.c
===================================================================
--- linux.t.orig/kernel/timer.c	2004-03-22 20:22:24.884077119 -0500
+++ linux.t/kernel/timer.c	2004-03-22 20:23:56.977929658 -0500
@@ -31,6 +31,7 @@
 #include <linux/time.h>
 #include <linux/jiffies.h>
 #include <linux/cpu.h>
+#include <linux/trigevent_hooks.h>
 
 #include <asm/uaccess.h>
 #include <asm/div64.h>
@@ -870,8 +871,9 @@ EXPORT_SYMBOL(xtime_lock);
  */
 static void run_timer_softirq(struct softirq_action *h)
 {
-	tvec_base_t *base = &__get_cpu_var(tvec_bases);
+	TRIG_EVENT(kernel_timer_hook, NULL);
 
+	tvec_base_t *base = &__get_cpu_var(tvec_bases);
 	if (time_after_eq(jiffies, base->timer_jiffies))
 		__run_timers(base);
 }
@@ -912,6 +914,7 @@ void do_timer(struct pt_regs *regs)
 #ifndef CONFIG_SMP
 	/* SMP process accounting uses the local APIC timer */
 
+	TRIG_EVENT(timer_hook, regs);
 	update_process_times(user_mode(regs));
 #endif
 	update_times();
@@ -1035,6 +1038,7 @@ asmlinkage long sys_getegid(void)
 
 static void process_timeout(unsigned long __data)
 {
+	TRIG_EVENT(timer_expired_hook, (task_t *)__data);
 	wake_up_process((task_t *)__data);
 }
 
@@ -1099,6 +1103,8 @@ fastcall signed long schedule_timeout(si
 		}
 	}
 
+	TRIG_EVENT(settimeout_hook, timeout);
+
 	expire = timeout + jiffies;
 
 	init_timer(&timer);
Index: linux.t/kernel/exit.c
===================================================================
--- linux.t.orig/kernel/exit.c	2004-03-22 20:23:03.476701697 -0500
+++ linux.t/kernel/exit.c	2004-03-22 20:23:56.964933488 -0500
@@ -27,6 +27,8 @@
 #endif
 #include <linux/ckrm.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
@@ -781,6 +783,8 @@ asmlinkage NORET_TYPE void do_exit(long 
 	acct_process(code);
 	__exit_mm(tsk);
 
+	TRIG_EVENT(process_exit_hook, tsk->pid);
+
 	exit_sem(tsk);
 	__exit_files(tsk);
 	__exit_fs(tsk);
@@ -1087,6 +1091,8 @@ asmlinkage long sys_wait4(pid_t pid,unsi
 	if (options & ~(WNOHANG|WUNTRACED|__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
 
+	TRIG_EVENT(process_wait_hook, pid);
+
 	add_wait_queue(&current->wait_chldexit,&wait);
 repeat:
 	flag = 0;
Index: linux.t/kernel/fork.c
===================================================================
--- linux.t.orig/kernel/fork.c	2004-03-22 20:23:16.259932724 -0500
+++ linux.t/kernel/fork.c	2004-03-22 20:25:08.667797087 -0500
@@ -34,6 +34,8 @@
 #include <linux/objrmap.h>
 
 #include <linux/ckrm.h>
+#include <linux/trigevent_hooks.h>
+
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -1184,6 +1186,9 @@ long do_fork(unsigned long clone_flags,
 			set_tsk_thread_flag(p, TIF_SIGPENDING);
 		}
 
+		/* Trace the event  */
+		TRIG_EVENT(fork_hook, clone_flags, p, pid);
+
 		if (!(clone_flags & CLONE_STOPPED))
 			wake_up_forked_process(p);	/* do this last */
 		else
Index: linux.t/kernel/itimer.c
===================================================================
--- linux.t.orig/kernel/itimer.c	2004-01-09 01:59:26.000000000 -0500
+++ linux.t/kernel/itimer.c	2004-03-22 20:23:56.966932899 -0500
@@ -11,6 +11,8 @@
 #include <linux/interrupt.h>
 #include <linux/time.h>
 
+#include <linux/trigevent_hooks.h>
+
 #include <asm/uaccess.h>
 
 int do_getitimer(int which, struct itimerval *value)
@@ -68,6 +70,8 @@ void it_real_fn(unsigned long __data)
 	struct task_struct * p = (struct task_struct *) __data;
 	unsigned long interval;
 
+	TRIG_EVENT(timer_expired_hook, p);
+
 	send_group_sig_info(SIGALRM, SEND_SIG_PRIV, p);
 	interval = p->it_real_incr;
 	if (interval) {
@@ -87,6 +91,7 @@ int do_setitimer(int which, struct itime
 	j = timeval_to_jiffies(&value->it_value);
 	if (ovalue && (k = do_getitimer(which, ovalue)) < 0)
 		return k;
+	TRIG_EVENT(setitimer_hook, which, i, j);
 	switch (which) {
 		case ITIMER_REAL:
 			del_timer_sync(&current->real_timer);
Index: linux.t/kernel/trigevent_hooks.c
===================================================================
--- linux.t.orig/kernel/trigevent_hooks.c	2003-09-23 18:19:32.000000000 -0400
+++ linux.t/kernel/trigevent_hooks.c	2004-03-22 20:23:56.977929658 -0500
@@ -0,0 +1,130 @@
+/*
+ * RAS Instrumentation hooks.
+ *
+ * Most of these hooks are for Linux Trace Toolkit. They may also be
+ * used by any other tool.
+ * 
+ * Author: Vamsi Krishna S. <vamsi_krishna@in.ibm.com>
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/hook.h>
+#include <linux/trigevent_hooks.h>
+#include <linux/ptrace.h>
+
+DECLARE_TRIG_EVENT(ipc_call_hook);
+DECLARE_TRIG_EVENT(ipc_msg_create_hook);
+DECLARE_TRIG_EVENT(ipc_sem_create_hook);
+DECLARE_TRIG_EVENT(ipc_shm_create_hook);
+
+DECLARE_TRIG_EVENT(irq_entry_hook);
+DECLARE_TRIG_EVENT(irq_exit_hook);
+
+DECLARE_TRIG_EVENT(kernel_timer_hook);
+
+DECLARE_TRIG_EVENT(kthread_hook);
+DECLARE_TRIG_EVENT(exec_hook);
+DECLARE_TRIG_EVENT(fork_hook);
+DECLARE_TRIG_EVENT(process_exit_hook);
+DECLARE_TRIG_EVENT(process_wait_hook);
+DECLARE_TRIG_EVENT(process_wakeup_hook);
+DECLARE_TRIG_EVENT(sched_switch_hook);
+DECLARE_TRIG_EVENT(sched_dispatch_hook);
+DECLARE_TRIG_EVENT(signal_hook);
+
+DECLARE_TRIG_EVENT(open_hook);
+DECLARE_TRIG_EVENT(close_hook);
+DECLARE_TRIG_EVENT(llseek_hook);
+DECLARE_TRIG_EVENT(lseek_hook);
+DECLARE_TRIG_EVENT(ioctl_hook);
+DECLARE_TRIG_EVENT(poll_hook);
+DECLARE_TRIG_EVENT(select_hook);
+DECLARE_TRIG_EVENT(read_hook);
+DECLARE_TRIG_EVENT(write_hook);
+DECLARE_TRIG_EVENT(buf_wait_end_hook);
+DECLARE_TRIG_EVENT(buf_wait_start_hook);
+
+
+DECLARE_TRIG_EVENT(mmap_hook);
+DECLARE_TRIG_EVENT(mm_page_alloc_hook);
+DECLARE_TRIG_EVENT(mm_page_free_hook);
+DECLARE_TRIG_EVENT(mm_swap_in_hook);
+DECLARE_TRIG_EVENT(mm_swap_out_hook);
+DECLARE_TRIG_EVENT(page_wait_end_hook);
+DECLARE_TRIG_EVENT(page_wait_start_hook);
+
+DECLARE_TRIG_EVENT(net_pkt_in_hook);
+DECLARE_TRIG_EVENT(net_pkt_out_hook);
+
+DECLARE_TRIG_EVENT(sk_call_hook);
+DECLARE_TRIG_EVENT(sk_create_hook);
+DECLARE_TRIG_EVENT(sk_receive_hook);
+DECLARE_TRIG_EVENT(sk_send_hook);
+
+DECLARE_TRIG_EVENT(softirq_hook);
+DECLARE_TRIG_EVENT(tasklet_action_hook);
+DECLARE_TRIG_EVENT(tasklet_hi_action_hook);
+DECLARE_TRIG_EVENT(bh_hook);
+
+DECLARE_TRIG_EVENT(timer_expired_hook);
+DECLARE_TRIG_EVENT(setitimer_hook);
+DECLARE_TRIG_EVENT(settimeout_hook);
+
+DECLARE_TRIG_EVENT(trap_entry_hook);
+DECLARE_TRIG_EVENT(trap_exit_hook);
+
+DECLARE_TRIG_EVENT(timer_hook);
+
+#ifdef CONFIG_MODULES
+DECLARE_TRIG_EVENT(module_init_hook);
+DECLARE_TRIG_EVENT(module_init_failed_hook);
+DECLARE_TRIG_EVENT(free_module_hook);
+#endif
+
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+DECLARE_TRIG_EVENT(pre_syscall_hook);
+DECLARE_TRIG_EVENT(post_syscall_hook);
+/* 
+ * as syscalls are very sensitive, we have extra steps to enable 
+ * pre/post syscall hooks. Besides registering and arming hooks
+ * one has to call enable/disable_pre/post_syscall_hook().
+ */
+int pre_syscall_enabled;
+int post_syscall_enabled;
+
+void enable_pre_syscall(void)
+{
+	pre_syscall_enabled = 1;
+}
+EXPORT_SYMBOL(enable_pre_syscall);
+
+void enable_post_syscall(void)
+{
+	post_syscall_enabled = 1;
+}
+EXPORT_SYMBOL(enable_post_syscall);
+
+void disable_pre_syscall(void)
+{
+	pre_syscall_enabled = 0;
+}
+EXPORT_SYMBOL(disable_pre_syscall);
+
+void disable_post_syscall(void)
+{
+	post_syscall_enabled = 0;
+}
+EXPORT_SYMBOL(disable_post_syscall);
+
+asmlinkage void pre_syscall(struct pt_regs * regs)
+{
+	TRIG_EVENT(pre_syscall_hook, regs);
+}
+
+asmlinkage void post_syscall(void)
+{
+	TRIG_EVENT(post_syscall_hook);
+}
+#endif /* CONFIG_TRIGEVENT_SYSCALL_HOOK */
Index: linux.t/include/linux/hook.h
===================================================================
--- linux.t.orig/include/linux/hook.h	2004-03-22 20:23:56.806980042 -0500
+++ linux.t/include/linux/hook.h	2004-03-22 20:23:56.956935845 -0500
@@ -131,7 +131,7 @@ static inline void deactivate_asm_hook(s
 	extern struct hook h; \
 	IF_HOOK_ENABLED(h, h##_hook)
 
-#define CALL_EXIT(fn, parm, args...) (((hook_fn_t)(fn))(parm , ##args))
+#define CALL_EXIT(fn, parm, args ...) (((hook_fn_t)(fn))(parm , ##args))
 
 #define DISPATCH_NORMAL(fn, parm, dsprc, args...) \
 	dsprc = CALL_EXIT(fn, parm , ##args);
Index: linux.t/include/linux/trigevent_hooks.h
===================================================================
--- linux.t.orig/include/linux/trigevent_hooks.h	2003-09-23 18:19:32.000000000 -0400
+++ linux.t/include/linux/trigevent_hooks.h	2004-03-22 20:23:56.957935551 -0500
@@ -0,0 +1,105 @@
+#ifndef __LINUX_TRIGEVENT_HOOKS_H
+#define __LINUX_TRIGEVENT_HOOKS_H
+/*
+ * Kernel Hooks Interface.
+ * 
+ * Authors: Richard J Moore <richardj_moore@uk.ibm.com>
+ *	    Vamsi Krishna S. <vamsi_krishna@in.ibm.com>
+ */
+#include <linux/hook.h>
+#include <linux/module.h>
+
+#ifdef CONFIG_TRIGEVENT_HOOKS
+#define TRIG_EVENT(name, args...) GENERIC_HOOK(name , ##args)
+#define DECLARE_TRIG_EVENT(name)	DECLARE_GENERIC_HOOK(name)
+
+USE_HOOK(ipc_call_hook);
+USE_HOOK(ipc_msg_create_hook);
+USE_HOOK(ipc_sem_create_hook);
+USE_HOOK(ipc_shm_create_hook);
+
+USE_HOOK(irq_entry_hook);
+USE_HOOK(irq_exit_hook);
+
+USE_HOOK(kernel_timer_hook);
+
+USE_HOOK(kthread_hook);
+USE_HOOK(exec_hook);
+USE_HOOK(fork_hook);
+USE_HOOK(process_exit_hook);
+USE_HOOK(process_wait_hook);
+USE_HOOK(process_wakeup_hook);
+USE_HOOK(sched_switch_hook);
+USE_HOOK(sched_dispatch_hook);
+USE_HOOK(signal_hook);
+
+USE_HOOK(open_hook);
+USE_HOOK(close_hook);
+USE_HOOK(llseek_hook);
+USE_HOOK(lseek_hook);
+USE_HOOK(ioctl_hook);
+USE_HOOK(poll_hook);
+USE_HOOK(select_hook);
+USE_HOOK(read_hook);
+USE_HOOK(write_hook);
+USE_HOOK(buf_wait_end_hook);
+USE_HOOK(buf_wait_start_hook);
+
+USE_HOOK(mmap_hook);
+USE_HOOK(mm_page_alloc_hook);
+USE_HOOK(mm_page_free_hook);
+USE_HOOK(mm_swap_in_hook);
+USE_HOOK(mm_swap_out_hook);
+USE_HOOK(page_wait_end_hook);
+USE_HOOK(page_wait_start_hook);
+
+USE_HOOK(net_pkt_in_hook);
+USE_HOOK(net_pkt_out_hook);
+
+USE_HOOK(sk_call_hook);
+USE_HOOK(sk_create_hook);
+USE_HOOK(sk_receive_hook);
+USE_HOOK(sk_send_hook);
+
+USE_HOOK(softirq_hook);
+USE_HOOK(tasklet_action_hook);
+USE_HOOK(tasklet_hi_action_hook);
+USE_HOOK(bh_hook);
+
+USE_HOOK(timer_expired_hook);
+USE_HOOK(setitimer_hook);
+USE_HOOK(settimeout_hook);
+
+USE_HOOK(trap_entry_hook);
+USE_HOOK(trap_exit_hook);
+
+USE_HOOK(timer_hook);
+
+#ifdef CONFIG_MODULES
+USE_HOOK(module_init_hook);
+USE_HOOK(module_init_failed_hook);
+USE_HOOK(free_module_hook);
+#endif
+
+#ifdef CONFIG_TRIGEVENT_SYSCALL_HOOK
+USE_HOOK(pre_syscall_hook);
+USE_HOOK(post_syscall_hook);
+
+extern int pre_syscall_enabled;
+extern int post_syscall_enabled;
+
+extern void enable_pre_syscall(void);
+extern void enable_post_syscall(void);
+extern void disable_pre_syscall(void);
+extern void disable_post_syscall(void);
+#endif /* CONFIG_TRIGEVENT_SYSCALL_HOOK */
+#else
+#define TRIG_EVENT(name, ...)
+#endif /* CONFIG_TRIGEVENT_HOOKS */
+
+/* this needs to be done properly */
+#ifdef __s390__
+typedef uint64_t trapid_t;
+#endif
+
+#endif /* __LINUX_TRIGEVENT_HOOKS_H */
Index: linux.t/include/asm-mips/mipsregs.h
===================================================================
--- linux.t.orig/include/asm-mips/mipsregs.h	2004-03-11 14:13:19.000000000 -0500
+++ linux.t/include/asm-mips/mipsregs.h	2004-03-22 20:23:56.955936140 -0500
@@ -525,6 +525,9 @@
 
 #ifndef __ASSEMBLY__
 
+#define CAUSE_EXCCODE(x) ((CAUSEF_EXCCODE & (x->cp0_cause)) >> CAUSEB_EXCCODE)
+#define CAUSE_EPC(x) (x->cp0_epc + (((x->cp0_cause & CAUSEF_BD) >> CAUSEB_BD) << 2))
+
 /*
  * Functions to access the r10k performance counter and control registers
  */
