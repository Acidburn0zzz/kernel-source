Subject: mol build fix
From: schwab@suse.de

---
 drivers/macintosh/mol/context.c               |    4 -
 drivers/macintosh/mol/emu.c                   |    2 
 drivers/macintosh/mol/fault.c                 |   20 +++----
 drivers/macintosh/mol/include/asmdbg.h        |    2 
 drivers/macintosh/mol/include/asmdefs.h       |    2 
 drivers/macintosh/mol/include/mac_registers.h |   20 +++----
 drivers/macintosh/mol/include/processor.h     |   66 +++++++++++++-------------
 drivers/macintosh/mol/mmu_fb.c                |    2 
 drivers/macintosh/mol/mmu_io.c                |    6 +-
 drivers/macintosh/mol/mtable.c                |   12 ++--
 drivers/macintosh/mol/ptaccess.c              |    6 +-
 11 files changed, 71 insertions(+), 71 deletions(-)

--- a/drivers/macintosh/mol/context.c
+++ b/drivers/macintosh/mol/context.c
@@ -37,9 +37,9 @@ flush_all_PTEs( kernel_vars_t *kv )
 
 	for( pte=ptehash.base, i=0; i<npte; i++, pte+=2 ) {
 		v = *pte;
-		if( !(v & BIT(0)) )	/* test V-bit */
+		if( !(v & MOL_BIT(0)) )	/* test V-bit */
 			continue;
-		v = (v & ~BIT(0)) >> 7;
+		v = (v & ~MOL_BIT(0)) >> 7;
 		v = (v - ((v & 0xf) * MUNGE_ESID_ADD)) * MUNGE_MUL_INVERSE;
 		v = (v>>4) & CTX_MASK;
 
--- a/drivers/macintosh/mol/emu.c
+++ b/drivers/macintosh/mol/emu.c
@@ -60,7 +60,7 @@ do_mtsdr1( kernel_vars_t *kv, ulong valu
 	/* the mask must be a valid one; we hade better make sure we are
 	 * not tricked by a bogus sdr1 value
 	 */
-	for( mask=BIT(23); mask && !(mask & value) ; mask=mask>>1 )
+	for( mask=MOL_BIT(23); mask && !(mask & value) ; mask=mask>>1 )
 		;
 	mask = mask? ((mask | (mask-1)) << 16) | 0xffff : 0xffff;
 	mbase = value & ~mask;
--- a/drivers/macintosh/mol/fault.c
+++ b/drivers/macintosh/mol/fault.c
@@ -31,10 +31,10 @@
 #include "hash.h"
 
 /* exception bits (srr1/dsisr and a couple of mol defined bits) */
-#define		EBIT_PAGE_FAULT		BIT(1)		/* I/D, PTE missing */
-#define		EBIT_NO_EXEC		BIT(3)		/* I,   no-execute or guarded */
-#define		EBIT_PROT_VIOL		BIT(4)		/* I/D, protection violation */
-#define		EBIT_IS_WRITE		BIT(6)		/* D    */
+#define		EBIT_PAGE_FAULT		MOL_BIT(1)		/* I/D, PTE missing */
+#define		EBIT_NO_EXEC		MOL_BIT(3)		/* I,   no-execute or guarded */
+#define		EBIT_PROT_VIOL		MOL_BIT(4)		/* I/D, protection violation */
+#define		EBIT_IS_WRITE		MOL_BIT(6)		/* D    */
 #define		EBIT_IS_DSI		1		/* D,   virtual bit */
 #define		EBIT_USE_MMU		2		/* I/D, virtual bit */
 
@@ -135,7 +135,7 @@ lookup_603_pte( kernel_vars_t *kv, ulong
 	MREGS.spr[S_HASH2] = MMU.hash_mbase + (pteg ^ (mask << 6));
 
 	/* construct compare word */
-	cmp = BIT(0) | (vsid <<7) | (cmp_ea >> 22);
+	cmp = MOL_BIT(0) | (vsid <<7) | (cmp_ea >> 22);
 	if( is_dsi ) {
 		MREGS.spr[S_DCMP] = cmp;
 		MREGS.spr[S_DMISS] = ea;
@@ -167,7 +167,7 @@ lookup_mac_pte( kernel_vars_t *kv, ulong
 	pteg = ((phash & mask) << 6);
 
 	/* construct compare word */
-	cmp = BIT(0) | (vsid <<7) | ((ea&0x0fffffff)>>22);
+	cmp = MOL_BIT(0) | (vsid <<7) | ((ea&0x0fffffff)>>22);
 
 	/* look in primary PTEG */
 	p = (ulong*)((ulong)MMU.hash_base + pteg);
@@ -177,7 +177,7 @@ lookup_mac_pte( kernel_vars_t *kv, ulong
 
 	/* look in secondary PTEG */
 	p = (ulong*)( (ulong)MMU.hash_base + (pteg ^ (mask << 6)) );
-	cmp |= BIT(25);
+	cmp |= MOL_BIT(25);
 
 	for( i=0; i<8; i++,p+=2 )
 		if( cmp == *p )
@@ -300,7 +300,7 @@ find_pte_slot( ulong ea, ulong *pte0, in
 
 		/* look in secondary PTEG */
 		p = secondary;
-		cmp |= BIT(25);
+		cmp |= MOL_BIT(25);
 		for( i=0; i<8; i++, p+=2 )
 			if( cmp == *p ) {
 				*pte0 |= PTE0_H;
@@ -314,12 +314,12 @@ find_pte_slot( ulong ea, ulong *pte0, in
 
 	/* free slot in primary PTEG? */
 	for( p=primary, i=0; i<8; i++, p+=2 )
-		if( !(*p & BIT(0)) )
+		if( !(*p & MOL_BIT(0)) )
 			return p;
 
 	/* free slot in secondary PTEG? */
 	for( p=secondary, i=0; i<8; i++, p+=2 )
-		if( !(*p & BIT(0)) ) {
+		if( !(*p & MOL_BIT(0)) ) {
 			*pte0 |= PTE0_H;
 			return p;
 		}
--- a/drivers/macintosh/mol/include/asmdbg.h
+++ b/drivers/macintosh/mol/include/asmdbg.h
@@ -124,7 +124,7 @@ MACRO(PERF_MONITOR_GET, [
 	lwz	r5,xDEBUG_SCR1(r1)
 ])
 MACRO(PERF_MONITOR_SETUP, [scr], [
-	LOADI	_scr,BIT(2) | BIT(3) | BIT(31)	// count in SV-mode if PM is zero.
+	LOADI	_scr,MOL_BIT(2) | MOL_BIT(3) | MOL_BIT(31)	// count in SV-mode if PM is zero.
 	mtspr	S_MMCR0,_scr
 	li	_scr,0
 	mtspr	S_MMCR1,_scr
--- a/drivers/macintosh/mol/include/asmdefs.h
+++ b/drivers/macintosh/mol/include/asmdefs.h
@@ -391,7 +391,7 @@ MACRO(ori_, [reg1, reg2, value], [
 #define EXTERN( name )		_##name
 #endif
 
-#define	BIT(n)		(1<<(31-(n)))
+#define	MOL_BIT(n)		(1<<(31-(n)))
 
 #endif   /* _H_ASMDEFS */
 
--- a/drivers/macintosh/mol/include/mac_registers.h
+++ b/drivers/macintosh/mol/include/mac_registers.h
@@ -111,7 +111,7 @@ typedef struct mac_regs {			/* this stru
 
 #define NUM_MREGS_PAGES		((sizeof(mac_regs_t)+0xfff)/0x1000)
 
-#define	BIT(n)			(1U<<(31-(n)))	/* bit 0 is MSB */
+#define	MOL_BIT(n)			(1U<<(31-(n)))	/* bit 0 is MSB */
 
 #ifndef __KERNEL__
 extern mac_regs_t *mregs;
@@ -152,17 +152,17 @@ extern mac_regs_t *mregs;
 
 
 #ifdef __KERNEL__
-#define fb_DbgTrace		BIT( FBIT_DbgTrace )
-#define fb_Trace		BIT( FBIT_Trace )
-#define fb_PrepareSplitmode	BIT( FBIT_PrepareSplitmode )
-#define fb_InSplitmode		BIT( FBIT_InSplitmode )
-#define fb_LoadSegreg		BIT( FBIT_LoadSegreg )
+#define fb_DbgTrace		MOL_BIT( FBIT_DbgTrace )
+#define fb_Trace		MOL_BIT( FBIT_Trace )
+#define fb_PrepareSplitmode	MOL_BIT( FBIT_PrepareSplitmode )
+#define fb_InSplitmode		MOL_BIT( FBIT_InSplitmode )
+#define fb_LoadSegreg		MOL_BIT( FBIT_LoadSegreg )
 #endif
-#define fb_MsrModified		BIT( FBIT_MsrModified )
-#define fb_RecalcDecInt		BIT( FBIT_RecalcDecInt )
-#define fb_IRQPending		BIT( FBIT_IRQPending )
+#define fb_MsrModified		MOL_BIT( FBIT_MsrModified )
+#define fb_RecalcDecInt		MOL_BIT( FBIT_RecalcDecInt )
+#define fb_IRQPending		MOL_BIT( FBIT_IRQPending )
 #ifdef EMULATE_603
-#define fb_603_AltGPR		BIT( FBIT_603_AltGPR )
+#define fb_603_AltGPR		MOL_BIT( FBIT_603_AltGPR )
 #endif
 
 #endif /* _MAC_REGISTERS_H */
--- a/drivers/macintosh/mol/include/processor.h
+++ b/drivers/macintosh/mol/include/processor.h
@@ -18,16 +18,16 @@
 
 
 #define PTE0_VSID(s)	(((s)>>7) & 0xffffff)
-#define PTE0_V		BIT(0)
-#define PTE0_H		BIT(25)
+#define PTE0_V		MOL_BIT(0)
+#define PTE0_H		MOL_BIT(25)
 #define PTE0_API	0x3f
 
-#define PTE1_R		BIT(23)
-#define PTE1_C		BIT(24)
-#define PTE1_W		BIT(25)
-#define PTE1_I		BIT(26)
-#define PTE1_M		BIT(27)
-#define PTE1_G		BIT(28)
+#define PTE1_R		MOL_BIT(23)
+#define PTE1_C		MOL_BIT(24)
+#define PTE1_W		MOL_BIT(25)
+#define PTE1_I		MOL_BIT(26)
+#define PTE1_M		MOL_BIT(27)
+#define PTE1_G		MOL_BIT(28)
 #ifdef CONFIG_AMIGAONE
 /* Memory coherence locks up A1 compatible systems. */
 #define PTE1_WIMG	(PTE1_W | PTE1_I | PTE1_G)
@@ -37,9 +37,9 @@
 #define PTE1_PP		0x3
 #define PTE1_RPN	(~0xfffUL)
 
-#define VSID_Ks		BIT(1)
-#define VSID_Kp		BIT(2)
-#define VSID_N		BIT(3)
+#define VSID_Ks		MOL_BIT(1)
+#define VSID_Kp		MOL_BIT(2)
+#define VSID_N		MOL_BIT(3)
 
 
 
@@ -236,30 +236,30 @@
 #define	HID0_BHT	(1<<2)		/* Branch History Table Enable */
 #define	HID0_BTCD	(1<<1)		/* Branch target cache disable */
 
-#define L2CR_L2E	BIT(0)		/* L2 enable */
-#define L2CR_L2PE	BIT(1)		/* L2 data parity generation and checking */
-#define L2CR_L2SIZ_512K	BIT(2)
-#define L2CR_L2SIZ_256K	BIT(3)
-#define L2CR_L2SIZ_1MB	(BIT(2)|BIT(3))
-#define L2CR_L2CLK_1	BIT(6)		/* L2 clock ration */
-#define L2CR_L2CLK_15	(BIT(6)*2)
-#define L2CR_L2CLK_2	(BIT(6)*4)
-#define L2CR_L2CLK_25	(BIT(6)*5)
-#define L2CR_L2CLK_3	(BIT(6)*6)
+#define L2CR_L2E	MOL_BIT(0)		/* L2 enable */
+#define L2CR_L2PE	MOL_BIT(1)		/* L2 data parity generation and checking */
+#define L2CR_L2SIZ_512K	MOL_BIT(2)
+#define L2CR_L2SIZ_256K	MOL_BIT(3)
+#define L2CR_L2SIZ_1MB	(MOL_BIT(2)|MOL_BIT(3))
+#define L2CR_L2CLK_1	MOL_BIT(6)		/* L2 clock ration */
+#define L2CR_L2CLK_15	(MOL_BIT(6)*2)
+#define L2CR_L2CLK_2	(MOL_BIT(6)*4)
+#define L2CR_L2CLK_25	(MOL_BIT(6)*5)
+#define L2CR_L2CLK_3	(MOL_BIT(6)*6)
 #define L2CR_L2RAM_FT	0		/* flow-through (reg-buf) synchronous SRAM */
-#define L2CR_L2RAM_PB	BIT(7)		/* Piplined (reg-reg) synchronous burst SRAM */
-#define L2CR_L2RAM_PLW	(BIT(7)|BIT(8))	/* Piplined (reg-reg) synchronous late-write */
-#define L2CR_L2DO	BIT(9)		/* L2 data-only */
-#define L2CR_L2I	BIT(10)		/* L2 global invalidate */
-#define L2CR_L2CTL	BIT(11)		/* L2 RAM control (ZZ enable, low-power mode) */
-#define L2CR_L2WT	BIT(12)		/* L2 write-through */
-#define L2CR_L2TS	BIT(13)		/* L2 test support */
+#define L2CR_L2RAM_PB	MOL_BIT(7)		/* Piplined (reg-reg) synchronous burst SRAM */
+#define L2CR_L2RAM_PLW	(MOL_BIT(7)|MOL_BIT(8))	/* Piplined (reg-reg) synchronous late-write */
+#define L2CR_L2DO	MOL_BIT(9)		/* L2 data-only */
+#define L2CR_L2I	MOL_BIT(10)		/* L2 global invalidate */
+#define L2CR_L2CTL	MOL_BIT(11)		/* L2 RAM control (ZZ enable, low-power mode) */
+#define L2CR_L2WT	MOL_BIT(12)		/* L2 write-through */
+#define L2CR_L2TS	MOL_BIT(13)		/* L2 test support */
 #define L2CR_L2OH_05	0		/* L2 output hold 0.5 nS */
-#define L2CR_L2OH_10	BIT(15)		/* L2 output hold 1.0 nS */
-#define L2CR_L2SL	BIT(16)		/* L2 DLL slow (use if bus freq < 150 MHz) */
-#define L2CR_L2DF	BIT(17)		/* L2 differential clock */
-#define L2CR_L2BYP	BIT(18)		/* L2 DLL bypass */
-#define L2CR_L2IP	BIT(31)		/* L2 global invalidate in progress */
+#define L2CR_L2OH_10	MOL_BIT(15)		/* L2 output hold 1.0 nS */
+#define L2CR_L2SL	MOL_BIT(16)		/* L2 DLL slow (use if bus freq < 150 MHz) */
+#define L2CR_L2DF	MOL_BIT(17)		/* L2 differential clock */
+#define L2CR_L2BYP	MOL_BIT(18)		/* L2 DLL bypass */
+#define L2CR_L2IP	MOL_BIT(31)		/* L2 global invalidate in progress */
 
 /* SPR_THRM1 */
 #define THRM1_TIN	(1 << 31)
--- a/drivers/macintosh/mol/mmu_fb.c
+++ b/drivers/macintosh/mol/mmu_fb.c
@@ -160,7 +160,7 @@ get_dirty_fb_lines( kernel_vars_t *kv, s
 				p->slot = NULL;
 				p->dirty = 1;
 				__tlbie( p->ea );
-			} else if( p->slot[1] & BIT(24) ) {  /* C-BIT */
+			} else if( p->slot[1] & MOL_BIT(24) ) {  /* C-BIT */
 				p->dirty = 1;
 				__store_PTE( p->ea, p->slot, p->pte0, p->pte1 );
 				BUMP(fb_ptec_flush);
--- a/drivers/macintosh/mol/mmu_io.c
+++ b/drivers/macintosh/mol/mmu_io.c
@@ -129,13 +129,13 @@ bat_align( int flags, ulong ea, ulong lp
 	bat[1] = (lphys & ~(s-1)) | 2;	/* pp=10, R/W */
 
 #ifndef CONFIG_AMIGAONE
-	bat[1] |= BIT(27);		/* [M] (memory coherence) */
+	bat[1] |= MOL_BIT(27);		/* [M] (memory coherence) */
 #endif
 
 	if( !(flags & MAPPING_FORCE_CACHE) ) {
-		bat[1] |= BIT(26);	/* [I] (inhibit cache) */
+		bat[1] |= MOL_BIT(26);	/* [I] (inhibit cache) */
 	} else {
-		bat[1] |= BIT(25);	/* [W] (write through) */
+		bat[1] |= MOL_BIT(25);	/* [W] (write through) */
 	}
 	return 0;
 }
--- a/drivers/macintosh/mol/mtable.c
+++ b/drivers/macintosh/mol/mtable.c
@@ -45,10 +45,10 @@ struct pterec {
 	uint		pent;			/* defined below */
 };
 
-#define PENT_LV_HEAD	BIT(0)			/* Resident - do not put on free list */
-#define PENT_UNUSED	BIT(1)			/* (lvhead) PTE index is not valid */
-#define PENT_EA_BIT14	BIT(2)			/* for the partial ea used by tlbie */
-#define PENT_EA_LAST	BIT(3)			/* next entry is the pelist pointer */
+#define PENT_LV_HEAD	MOL_BIT(0)			/* Resident - do not put on free list */
+#define PENT_UNUSED	MOL_BIT(1)			/* (lvhead) PTE index is not valid */
+#define PENT_EA_BIT14	MOL_BIT(2)			/* for the partial ea used by tlbie */
+#define PENT_EA_LAST	MOL_BIT(3)			/* next entry is the pelist pointer */
 #define PENT_TOPEA_MASK	0x0f800000		/* bit 4-8 of ea */
 #define PENT_SV_BIT	0x00400000		/* PTE uses vsid_sv */
 #define PENT_INDEX_MASK	0x003fffff		/* PTE index (there can be at most 2^22 PTEs) */
@@ -675,7 +675,7 @@ pte_inserted( kernel_vars_t *kv, ulong e
 
 		/* get_free_pent inserts the entry into the lvring and sets a few pent bits */
 		pr = get_free_pent(vi, lvrange, lvptr);
-		pr->pent |= PTE_TO_IND(pte) | pent_cmp | ((ea & BIT(14)) ? PENT_EA_BIT14 : 0);
+		pr->pent |= PTE_TO_IND(pte) | pent_cmp | ((ea & MOL_BIT(14)) ? PENT_EA_BIT14 : 0);
 
 		/* insert in (non-empty) ea ring */
 		pr->ea_next = *pp;
@@ -684,7 +684,7 @@ pte_inserted( kernel_vars_t *kv, ulong e
 		/* ea ring was empty */
 		pr = *pp = get_free_pent(vi, lvrange, lvptr);
 		pr->pent |= PENT_EA_LAST | PTE_TO_IND(pte) | pent_cmp
-				| ((ea & BIT(14)) ? PENT_EA_BIT14 : 0);
+				| ((ea & MOL_BIT(14)) ? PENT_EA_BIT14 : 0);
 		pr->ea_next = (pterec_t*)pp;
 	}
  out:
--- a/drivers/macintosh/mol/ptaccess.c
+++ b/drivers/macintosh/mol/ptaccess.c
@@ -39,7 +39,7 @@ do_intercept_tlbie( kernel_vars_t *kv, u
 		clear_bit_mol( pteoffs >> 3, MMU.pthash_inuse_bits );
 
 	v = (pteoffs >> 6);
-	if( pte0 & BIT(25) )	/* secondary hash? */
+	if( pte0 & MOL_BIT(25) )	/* secondary hash? */
 		v = ~v;
 	v ^= (pte0 >> 7);
 	v = ((pte0 << 10) & 0xfc00) | (v & 0x3ff);
@@ -93,7 +93,7 @@ do_tlbli( kernel_vars_t *kv, ulong ea )
 	mPTE_t *p;
 
 	//printk("do_tlbli %08lX : %08lX %08lX\n", ea, MREGS.spr[S_ICMP], MREGS.spr[S_RPA] );
-	if( MREGS.spr[S_SRR1] & BIT(14) )
+	if( MREGS.spr[S_SRR1] & MOL_BIT(14) )
 		ind += 32;
 
 	p = &MMU.ptes_i_603[ind];
@@ -114,7 +114,7 @@ do_tlbld( kernel_vars_t *kv, ulong ea )
 
 	//printk("do_tlbld %08lX\n", ea );
 
-	if( MREGS.spr[S_SRR1] & BIT(14) )
+	if( MREGS.spr[S_SRR1] & MOL_BIT(14) )
 		ind += 32;
 
 	p = &MMU.ptes_d_603[ind];
