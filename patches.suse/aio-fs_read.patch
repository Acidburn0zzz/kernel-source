
From: Suparna Bhattacharya <suparna@in.ibm.com>

Filesystem aio read

Converts the wait for page to become uptodate (wait for page lock)
after readahead/readpage (in do_generic_mapping_read) to a retry
exit.


 filemap.c |   21 ++++++++++++++++++---
 1 files changed, 18 insertions(+), 3 deletions(-)

Index: linux.t/mm/filemap.c
===================================================================
--- linux.t.orig/mm/filemap.c	2004-08-13 10:12:40.762010416 -0400
+++ linux.t/mm/filemap.c	2004-08-13 10:28:34.539014272 -0400
@@ -779,7 +779,12 @@ page_ok:
 
 page_not_up_to_date:
 		/* Get exclusive access to the page ... */
-		lock_page(page);
+
+		if (lock_page_wq(page, current->io_wait)) {
+			pr_debug("queued lock page \n");
+			error = -EIOCBRETRY;
+			goto readpage_error;
+		}
 
 		/* Did it get unhashed before we got the lock? */
 		if (!page->mapping) {
@@ -802,7 +807,11 @@ readpage:
 			goto readpage_error;
 
 		if (!PageUptodate(page)) {
-			wait_on_page_locked(page);
+			if (wait_on_page_locked_wq(page, current->io_wait)) {
+				pr_debug("queued wait_on_page \n");
+				error = -EIOCBRETRY;
+				goto readpage_error;
+			}
 			if (!PageUptodate(page)) {
 				error = -EIO;
 				goto readpage_error;
@@ -826,7 +835,11 @@ readpage:
 		goto page_ok;
 
 readpage_error:
-		/* UHHUH! A synchronous read error occurred. Report it */
+		/* We don't have uptodate data in the page yet
+		 * Could be due to an error or because we need to
+		 * retry when we get an async i/o notification.
+		 * Report the reason.
+		 */
 		desc->error = error;
 		page_cache_release(page);
 		goto out;
