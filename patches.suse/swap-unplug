diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/drivers/block/ll_rw_blk.c sles1/drivers/block/ll_rw_blk.c
--- sles-ref/drivers/block/ll_rw_blk.c	2004-05-13 02:31:22.000000000 +0200
+++ sles1/drivers/block/ll_rw_blk.c	2004-05-13 02:41:58.000000000 +0200
@@ -1199,7 +1199,8 @@ void generic_unplug_device(request_queue
 
 EXPORT_SYMBOL(generic_unplug_device);
 
-static inline void blk_backing_dev_unplug(struct backing_dev_info *bdi)
+static inline void blk_backing_dev_unplug(struct backing_dev_info *bdi,
+					  struct page * page)
 {
 	request_queue_t *q = bdi->unplug_io_data;
 
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/fs/buffer.c sles1/fs/buffer.c
--- sles-ref/fs/buffer.c	2004-05-13 02:31:18.000000000 +0200
+++ sles1/fs/buffer.c	2004-05-13 02:48:32.000000000 +0200
@@ -3022,10 +3022,7 @@ EXPORT_SYMBOL(try_to_free_buffers);
 
 int block_sync_page(struct page *page)
 {
-	struct address_space *mapping;
-	smp_mb();
-	mapping = page_mapping(page);
-	blk_run_address_space(mapping);
+	blk_run_page(page);
 	return 0;
 }
 
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/include/linux/backing-dev.h sles1/include/linux/backing-dev.h
--- sles-ref/include/linux/backing-dev.h	2004-05-13 02:30:56.000000000 +0200
+++ sles1/include/linux/backing-dev.h	2004-05-13 02:41:30.000000000 +0200
@@ -28,12 +28,12 @@ struct backing_dev_info {
 	int memory_backed;	/* Cannot clean pages with writepage */
 	congested_fn *congested_fn; /* Function pointer if device is md/dm */
 	void *congested_data;	/* Pointer to aux data for congested func */
-	void (*unplug_io_fn)(struct backing_dev_info *);
+	void (*unplug_io_fn)(struct backing_dev_info *, struct page *);
 	void *unplug_io_data;
 };
 
 extern struct backing_dev_info default_backing_dev_info;
-void default_unplug_io_fn(struct backing_dev_info *bdi);
+void default_unplug_io_fn(struct backing_dev_info *bdi, struct page *page);
 
 int writeback_acquire(struct backing_dev_info *bdi);
 int writeback_in_progress(struct backing_dev_info *bdi);
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/include/linux/blkdev.h sles1/include/linux/blkdev.h
--- sles-ref/include/linux/blkdev.h	2004-05-13 02:31:22.000000000 +0200
+++ sles1/include/linux/blkdev.h	2004-05-13 02:57:15.000000000 +0200
@@ -541,16 +541,27 @@ static inline request_queue_t *bdev_get_
 	return bdev->bd_disk->queue;
 }
 
-static inline void blk_run_backing_dev(struct backing_dev_info *bdi)
+static inline void blk_run_backing_dev(struct backing_dev_info *bdi,
+				       struct page *page)
 {
 	if (bdi && bdi->unplug_io_fn)
-		bdi->unplug_io_fn(bdi);
+		bdi->unplug_io_fn(bdi, page);
 }
 
 static inline void blk_run_address_space(struct address_space *mapping)
 {
 	if (mapping)
-		blk_run_backing_dev(mapping->backing_dev_info);
+		blk_run_backing_dev(mapping->backing_dev_info, NULL);
+}
+
+static inline void blk_run_page(struct page *page)
+{
+	struct address_space *mapping;
+
+	smp_mb();
+	mapping = page_mapping(page);
+	if (mapping)
+		blk_run_backing_dev(mapping->backing_dev_info, page);
 }
 
 /*
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/include/linux/swap.h sles1/include/linux/swap.h
--- sles-ref/include/linux/swap.h	2004-05-13 02:31:05.024662504 +0200
+++ sles1/include/linux/swap.h	2004-05-13 03:56:52.010201768 +0200
@@ -218,7 +218,7 @@ extern struct swap_info_struct *get_swap
 extern int can_share_swap_page(struct page *);
 extern int remove_exclusive_swap_page(struct page *);
 struct backing_dev_info;
-extern void swap_unplug_io_fn(struct backing_dev_info *);
+extern void swap_unplug_io_fn(struct backing_dev_info *, struct page * page);
 
 extern struct swap_list_t swap_list;
 extern spinlock_t swaplock;
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/mm/readahead.c sles1/mm/readahead.c
--- sles-ref/mm/readahead.c	2004-05-13 02:30:58.000000000 +0200
+++ sles1/mm/readahead.c	2004-05-13 02:41:30.000000000 +0200
@@ -15,7 +15,7 @@
 #include <linux/backing-dev.h>
 #include <linux/pagevec.h>
 
-void default_unplug_io_fn(struct backing_dev_info *bdi)
+void default_unplug_io_fn(struct backing_dev_info *bdi, struct page *page)
 {
 }
 EXPORT_SYMBOL(default_unplug_io_fn);
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/mm/swapfile.c sles1/mm/swapfile.c
--- sles-ref/mm/swapfile.c	2004-05-13 02:31:19.000000000 +0200
+++ sles1/mm/swapfile.c	2004-05-13 04:05:20.056966920 +0200
@@ -47,61 +47,38 @@ struct swap_list_t swap_list = {-1, -1};
 struct swap_info_struct swap_info[MAX_SWAPFILES];
 
 /*
- * Array of backing blockdevs, for swap_unplug_fn.  We need this because the
- * bdev->unplug_fn can sleep and we cannot hold swap_list_lock while calling
- * the unplug_fn.  And swap_list_lock cannot be turned into a semaphore.
+ * We need this because the bdev->unplug_fn can sleep and we cannot
+ * hold swap_list_lock while calling the unplug_fn. And swap_list_lock
+ * cannot be turned into a semaphore.
  */
-static DECLARE_MUTEX(swap_bdevs_sem);
-static struct block_device *swap_bdevs[MAX_SWAPFILES];
+static DECLARE_RWSEM(swap_unplug_sem);
 
 #define SWAPFILE_CLUSTER 256
 
-/*
- * Caller holds swap_bdevs_sem
- */
-static void install_swap_bdev(struct block_device *bdev)
-{
-	int i;
-
-	for (i = 0; i < MAX_SWAPFILES; i++) {
-		if (swap_bdevs[i] == NULL) {
-			swap_bdevs[i] = bdev;
-			return;
-		}
-	}
-	BUG();
-}
-
-static void remove_swap_bdev(struct block_device *bdev)
-{
-	int i;
-
-	for (i = 0; i < MAX_SWAPFILES; i++) {
-		if (swap_bdevs[i] == bdev) {
-			memcpy(&swap_bdevs[i], &swap_bdevs[i + 1],
-				(MAX_SWAPFILES - i - 1) * sizeof(*swap_bdevs));
-			swap_bdevs[MAX_SWAPFILES - 1] = NULL;
-			return;
-		}
-	}
-	BUG();
-}
-
-void swap_unplug_io_fn(struct backing_dev_info *unused_bdi)
+void swap_unplug_io_fn(struct backing_dev_info *unused_bdi, struct page * page)
 {
-	int i;
+	swp_entry_t entry;
 
-	down(&swap_bdevs_sem);
-	for (i = 0; i < MAX_SWAPFILES; i++) {
-		struct block_device *bdev = swap_bdevs[i];
+	down_read(&swap_unplug_sem);
+	entry.val = page->private;
+	if (PageSwapCache(page)) {
+		struct block_device *bdev = swap_info[swp_type(entry)].bdev;
 		struct backing_dev_info *bdi;
 
-		if (bdev == NULL)
-			break;
+		/*
+		 * if the page is removed from swapcache from under us (with a
+		 * racy try_to_unuse/swapoff) we need an additional reference count
+		 * to avoid reading garbage from page->private above. If the
+		 * WARN_ON triggers during a swapoff it maybe the race condition and
+		 * it's harmless. However if it triggers without swapoff it signals
+		 * a problem.
+		 */
+		WARN_ON(page_count(page) <= 1);
+
 		bdi = bdev->bd_inode->i_mapping->backing_dev_info;
-		(*bdi->unplug_io_fn)(bdi);
+		bdi->unplug_io_fn(bdi, page);
 	}
-	up(&swap_bdevs_sem);
+	up_read(&swap_unplug_sem);
 }
 
 static inline int scan_swap_map(struct swap_info_struct *si)
@@ -1127,6 +1104,11 @@ asmlinkage long sys_swapoff(const char _
 	current->flags |= PF_SWAPOFF;
 	err = try_to_unuse(type);
 	current->flags &= ~PF_SWAPOFF;
+
+	/* wait for any unplug function to finish */
+	down_write(&swap_unplug_sem);
+	up_write(&swap_unplug_sem);
+
 	if (err) {
 		/* re-insert swap space back into swap_list */
 		swap_list_lock();
@@ -1144,7 +1126,6 @@ asmlinkage long sys_swapoff(const char _
 		swap_list_unlock();
 		goto out_dput;
 	}
-	down(&swap_bdevs_sem);
 	swap_list_lock();
 	swap_device_lock(p);
 	swap_file = p->swap_file;
@@ -1156,8 +1137,6 @@ asmlinkage long sys_swapoff(const char _
 	destroy_swap_extents(p);
 	swap_device_unlock(p);
 	swap_list_unlock();
-	remove_swap_bdev(p->bdev);
-	up(&swap_bdevs_sem);
 	vfree(swap_map);
 	if (S_ISBLK(mapping->host->i_mode)) {
 		struct block_device *bdev = I_BDEV(mapping->host);
@@ -1502,7 +1481,6 @@ asmlinkage long sys_swapon(const char __
 	if (error)
 		goto bad_swap;
 
-	down(&swap_bdevs_sem);
 	swap_list_lock();
 	swap_device_lock(p);
 	p->flags = SWP_ACTIVE;
@@ -1528,8 +1506,6 @@ asmlinkage long sys_swapon(const char __
 	}
 	swap_device_unlock(p);
 	swap_list_unlock();
-	install_swap_bdev(p->bdev);
-	up(&swap_bdevs_sem);
 	error = 0;
 	goto out;
 bad_swap:
