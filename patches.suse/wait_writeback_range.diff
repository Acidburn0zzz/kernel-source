wait_on_page_writeback_range_wq had a race where page->index might not
be valid for the address space we're waiting on.  This might lead to
incorrectly deciding we've waited on the entire range requested by the
caller.

For aio, this might mean trying to complete the write before it is
really done, leading to a debugging oops in the aio code.

--- linux.t2/mm/filemap.c	2004-05-25 10:29:55.462625704 -0400
+++ linux.t/mm/filemap.c	2004-05-25 10:32:41.034454960 -0400
@@ -238,22 +238,13 @@
 			if (page->index > end) {
 				continue;
 			}
-			/* 
-			 * the page can't be freed, we've got a reference
-			 * to it.  But the mapping can go null due to 
-			 * truncates and other fun things.
-			 *
-			 * We also know that fresh new pages with a
-			 * bad page->index shouldn't be here, since they
-			 * won't have been tagged as writeback.
-			 *
-			 * so instead of locking the page, we just
-			 * check for page->mapping.
-			 */
-			smp_mb();
-			if (!page->mapping)
+			spin_lock_irq(&mapping->tree_lock);
+			if (page->mapping != mapping) {
+				spin_unlock_irq(&mapping->tree_lock);
 				continue;
+			}
 			curr = page->index;
+			spin_unlock_irq(&mapping->tree_lock);
 			ret = wait_on_page_writeback_wq(page, wait);
 			if (ret == -EIOCBRETRY) {
 				if (curr > start)
