From: sles8
Subject: change the start of mmap

x

Signed-off-by: Andrea Arcangeli <andrea@suse.de>

Index: linux-2.6.15/fs/proc/base.c
===================================================================
--- linux-2.6.15.orig/fs/proc/base.c
+++ linux-2.6.15/fs/proc/base.c
@@ -104,8 +104,9 @@ enum pid_directory_inos {
 	PROC_TGID_MAPS,
 	PROC_TGID_NUMA_MAPS,
 	PROC_TGID_MOUNTS,
 	PROC_TGID_WCHAN,
++ 	PROC_TGID_MAPBASE,
 #ifdef CONFIG_MMU
 	PROC_TGID_SMAPS,
 #endif
 #ifdef CONFIG_SCHEDSTATS
@@ -200,8 +201,11 @@ static struct pid_entry tgid_base_stuff[
 	E(PROC_TGID_CWD,       "cwd",     S_IFLNK|S_IRWXUGO),
 	E(PROC_TGID_ROOT,      "root",    S_IFLNK|S_IRWXUGO),
 	E(PROC_TGID_EXE,       "exe",     S_IFLNK|S_IRWXUGO),
 	E(PROC_TGID_MOUNTS,    "mounts",  S_IFREG|S_IRUGO),
+#ifdef __HAS_ARCH_PROC_MAPPED_BASE
+   	E(PROC_TGID_MAPBASE,	"mapped_base",	S_IFREG|S_IRUSR|S_IWUSR),
+#endif
 #ifdef CONFIG_MMU
 	E(PROC_TGID_SMAPS,     "smaps",   S_IFREG|S_IRUGO),
 #endif
 #ifdef CONFIG_SECURITY
@@ -942,8 +946,58 @@ static struct file_operations proc_oom_a
 	.read		= oom_adjust_read,
 	.write		= oom_adjust_write,
 };
 
+#ifdef __HAS_ARCH_PROC_MAPPED_BASE
+static ssize_t mapbase_read(struct file * file, char * buf,
+			size_t count, loff_t *ppos)
+{
+	struct task_struct *task = proc_task(file->f_dentry->d_inode);
+	char buffer[64];
+	size_t len;
+	loff_t __ppos = *ppos;
+
+	len = sprintf(buffer, "%li\n", task->map_base);
+	if (__ppos >= len)
+		return 0;
+	if (count > len-__ppos)
+		count = len-__ppos;
+	if (copy_to_user(buf, buffer + __ppos, count)) 
+		return -EFAULT;
+	*ppos = __ppos + count;
+	return count;
+}
+
+static ssize_t mapbase_write(struct file * file, const char * buf,
+			 size_t count, loff_t *ppos)
+{
+	struct task_struct *task = proc_task(file->f_dentry->d_inode);
+	char buffer[64], *end;
+	unsigned long newbase;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	memset(buffer, 0, 64);	
+	if (count > 62)
+		count = 62;
+	if (copy_from_user(buffer, buf, count)) 
+		return -EFAULT;
+	newbase = simple_strtoul(buffer, &end, 0);
+	if (*end == '\n')
+		end++;
+	if (newbase > 0)
+		task->map_base = newbase;
+	if (end - buffer == 0) 
+		return -EIO;
+	return end - buffer;
+}
+
+static struct file_operations proc_mapbase_operations = {
+	read:		mapbase_read,
+	write:		mapbase_write,
+};
+#endif /* __HAS_ARCH_PROC_MAPPED_BASE */
+
 static struct inode_operations proc_mem_inode_operations = {
 	.permission	= proc_permission,
 };
 
@@ -1702,8 +1756,13 @@ static struct dentry *proc_pident_lookup
 		case PROC_TID_MAPS:
 		case PROC_TGID_MAPS:
 			inode->i_fop = &proc_maps_operations;
 			break;
+#ifdef __HAS_ARCH_PROC_MAPPED_BASE
+ 		case PROC_TGID_MAPBASE:
+ 			inode->i_fop = &proc_mapbase_operations;
+ 			break;
+#endif
 #ifdef CONFIG_NUMA
 		case PROC_TID_NUMA_MAPS:
 		case PROC_TGID_NUMA_MAPS:
 			inode->i_fop = &proc_numa_maps_operations;
Index: linux-2.6.15/include/asm-i386/processor.h
===================================================================
--- linux-2.6.15.orig/include/asm-i386/processor.h
+++ linux-2.6.15/include/asm-i386/processor.h
@@ -322,9 +322,10 @@ extern int bootloader_type;
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))
+#define TASK_UNMAPPED_BASE	(current->map_base)
+#define __TASK_UNMAPPED_BASE PAGE_ALIGN(TASK_SIZE/3)
 
 #define HAVE_ARCH_PICK_MMAP_LAYOUT
 
 /*
Index: linux-2.6.15/include/asm-um/processor-generic.h
===================================================================
--- linux-2.6.15.orig/include/asm-um/processor-generic.h
+++ linux-2.6.15/include/asm-um/processor-generic.h
@@ -113,9 +113,10 @@ extern unsigned long task_size;
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_BASE	(0x40000000)
+#define __TASK_UNMAPPED_BASE	(0x40000000)
+#define TASK_UNMAPPED_BASE	(current->map_base)
 
 extern void start_thread(struct pt_regs *regs, unsigned long entry, 
 			 unsigned long stack);
 
Index: linux-2.6.15/include/asm-x86_64/processor.h
===================================================================
--- linux-2.6.15.orig/include/asm-x86_64/processor.h
+++ linux-2.6.15/include/asm-x86_64/processor.h
@@ -165,15 +165,24 @@ static inline void clear_in_cr4 (unsigne
 #define TASK_SIZE64	(0x800000000000UL - 4096)
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
+ *
+ * /proc/pid/unmap_base is only supported for 32bit processes without
+ * 3GB personality for now.
  */
 #define IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
 
 #define TASK_SIZE 		(test_thread_flag(TIF_IA32) ? IA32_PAGE_OFFSET : TASK_SIZE64)
 #define TASK_SIZE_OF(child) 	((test_tsk_thread_flag(child, TIF_IA32)) ? IA32_PAGE_OFFSET : TASK_SIZE64)
 
-#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE/3)
+/* FIXME: Used in initializer, do we need to check for 64bit here? */
+#define __TASK_UNMAPPED_BASE (PAGE_ALIGN(0xffffe000 / 3))
+#define TASK_UNMAPPED_32 ((current->personality & ADDR_LIMIT_3GB) ? \
+ 	PAGE_ALIGN(0xc0000000 / 3) : PAGE_ALIGN(current->map_base))
+#define TASK_UNMAPPED_64 PAGE_ALIGN(TASK_SIZE64/3)
+#define TASK_UNMAPPED_BASE	\
+	(test_thread_flag(TIF_IA32) ? TASK_UNMAPPED_32 : TASK_UNMAPPED_64)
 
 /*
  * Size of io_bitmap.
  */
Index: linux-2.6.15/include/linux/sched.h
===================================================================
--- linux-2.6.15.orig/include/linux/sched.h
+++ linux-2.6.15/include/linux/sched.h
@@ -628,8 +628,11 @@ struct sched_domain {
 	unsigned long ttwu_wake_remote;
 	unsigned long ttwu_move_affine;
 	unsigned long ttwu_move_balance;
 #endif
+
+/* TASK_UNMAPPED_BASE */
+	unsigned long map_base;
 };
 
 extern void partition_sched_domains(cpumask_t *partition1,
 				    cpumask_t *partition2);
@@ -656,8 +659,14 @@ struct group_info {
 	int nblocks;
 	gid_t *blocks[0];
 };
 
+#ifndef __TASK_UNMAPPED_BASE
+#define __TASK_UNMAPPED_BASE 0UL
+#else
+#define __HAS_ARCH_PROC_MAPPED_BASE
+#endif
+
 /*
  * get_group_info() must be called with the owning task locked (via task_lock())
  * when task != current.  The reason being that the vast majority of callers are
  * looking at current->group_info, which can not be changed except by the
Index: linux-2.6.15/include/linux/init_task.h
===================================================================
--- linux-2.6.15.orig/include/linux/init_task.h
+++ linux-2.6.15/include/linux/init_task.h
@@ -118,8 +118,9 @@ extern struct group_info init_groups;
 	.blocked	= {{0}},					\
 	.alloc_lock	= SPIN_LOCK_UNLOCKED,				\
 	.proc_lock	= SPIN_LOCK_UNLOCKED,				\
 	.journal_info	= NULL,						\
+	.map_base	= __TASK_UNMAPPED_BASE,				\
 	.cpu_timers	= INIT_CPU_TIMERS(tsk.cpu_timers),		\
 	.fs_excl	= ATOMIC_INIT(0),				\
 }
 
Index: linux-2.6.15/include/asm-powerpc/processor.h
===================================================================
--- linux-2.6.15.orig/include/asm-powerpc/processor.h
+++ linux-2.6.15/include/asm-powerpc/processor.h
@@ -138,10 +138,13 @@ extern struct task_struct *last_task_use
 		TASK_SIZE_USER32 : TASK_SIZE_USER64)
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
+ *
+ * /proc/pid/unmap_base is only supported for 32bit processes for now.
  */
-#define TASK_UNMAPPED_BASE_USER32 (PAGE_ALIGN(TASK_SIZE_USER32 / 4))
+#define __TASK_UNMAPPED_BASE (PAGE_ALIGN(STACK_TOP_USER32 / 4))
+#define TASK_UNMAPPED_BASE_USER32 (PAGE_ALIGN(current->map_base))
 #define TASK_UNMAPPED_BASE_USER64 (PAGE_ALIGN(TASK_SIZE_USER64 / 4))
 
 #define TASK_UNMAPPED_BASE ((test_thread_flag(TIF_32BIT)) ? \
 		TASK_UNMAPPED_BASE_USER32 : TASK_UNMAPPED_BASE_USER64 )
