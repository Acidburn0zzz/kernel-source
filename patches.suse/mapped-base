diff -u linux/include/asm-x86_64/processor.h-BASE linux/include/asm-x86_64/processor.h
--- linux/include/asm-x86_64/processor.h-BASE	2004-02-19 14:39:28.000000000 +0100
+++ linux/include/asm-x86_64/processor.h	2004-02-19 14:59:28.000000000 +0100
@@ -171,9 +171,14 @@
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
+ * 
+ * /proc/pid/unmap_base is only supported for 32bit processes without
+ * 3GB personality for now.
  */
 #define IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
-#define TASK_UNMAPPED_32 (PAGE_ALIGN(0xc5000000))
+#define __TASK_UNMAPPED_BASE (PAGE_ALIGN(0xffffe000 / 3))
+#define TASK_UNMAPPED_32 ((current->personality & ADDR_LIMIT_3GB) ? \
+	PAGE_ALIGN(0xc0000000 / 3) : current->map_base)
 #define TASK_UNMAPPED_64 PAGE_ALIGN(TASK_SIZE/3) 
 #define TASK_UNMAPPED_BASE	\
 	(test_thread_flag(TIF_IA32) ? TASK_UNMAPPED_32 : TASK_UNMAPPED_64)  
diff -u linux/include/linux/sched.h-BASE linux/include/linux/sched.h
--- linux/include/linux/sched.h-BASE	2004-02-19 14:39:11.000000000 +0100
+++ linux/include/linux/sched.h	2004-02-19 15:02:55.000000000 +0100
@@ -454,7 +454,7 @@
 
 /* journalling filesystem info */
 	void *journal_info;
-
+	
 /* VM state */
 	struct reclaim_state *reclaim_state;
 
@@ -472,6 +472,9 @@
  * to a stack based synchronous wait) if its doing sync IO.
  */
 	wait_queue_t *io_wait;
+
+/* TASK_UNMAPPED_BASE */
+	unsigned long map_base;
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
@@ -484,6 +487,12 @@
 #define put_task_struct(tsk) \
 do { if (atomic_dec_and_test(&(tsk)->usage)) __put_task_struct(tsk); } while(0)
 
+#ifndef __TASK_UNMAPPED_BASE
+#define __TASK_UNMAPPED_BASE 0UL
+#else
+#define __HAS_ARCH_PROC_MAPPED_BASE
+#endif
+
 /*
  * Per process flags
  */
diff -u linux/include/linux/init_task.h-BASE linux/include/linux/init_task.h
--- linux/include/linux/init_task.h-BASE	2004-02-19 14:39:11.000000000 +0100
+++ linux/include/linux/init_task.h	2004-02-19 15:04:17.000000000 +0100
@@ -109,6 +109,7 @@
 	.proc_lock	= SPIN_LOCK_UNLOCKED,				\
 	.switch_lock	= SPIN_LOCK_UNLOCKED,				\
 	.journal_info	= NULL,						\
+	.map_base	= __TASK_UNMAPPED_BASE,				\
 	.io_wait	= NULL,						\
 }
 
diff -u linux/include/asm-um/processor-generic.h-BASE linux/include/asm-um/processor-generic.h
--- linux/include/asm-um/processor-generic.h-BASE	2004-02-19 14:39:05.000000000 +0100
+++ linux/include/asm-um/processor-generic.h	2004-02-19 14:39:28.000000000 +0100
@@ -118,7 +118,8 @@
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_BASE	(0x40000000)
+#define __TASK_UNMAPPED_BASE	(0x40000000)
+#define TASK_UNMAPPED_BASE	(current->map_base)
 
 extern void start_thread(struct pt_regs *regs, unsigned long entry, 
 			 unsigned long stack);
diff -u linux/include/asm-s390/processor.h-BASE linux/include/asm-s390/processor.h
--- linux/include/asm-s390/processor.h-BASE	2004-02-11 22:06:44.000000000 +0100
+++ linux/include/asm-s390/processor.h	2004-02-19 14:55:48.000000000 +0100
@@ -62,7 +62,9 @@
 #ifndef __s390x__
 
 # define TASK_SIZE		(0x80000000UL)
-# define TASK_UNMAPPED_BASE	(TASK_SIZE / 2)
+# define TASK_UNMAPPED_BASE (current->map_base)
+# define __TASK_UNMAPPED_BASE	(TASK_SIZE / 2)
+
 
 #else /* __s390x__ */
 
diff -u linux/include/asm-i386/processor.h-BASE linux/include/asm-i386/processor.h
--- linux/include/asm-i386/processor.h-BASE	2004-02-19 14:39:06.000000000 +0100
+++ linux/include/asm-i386/processor.h	2004-02-19 14:55:49.000000000 +0100
@@ -299,7 +299,8 @@
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap's.
  */
-#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))
+#define TASK_UNMAPPED_BASE	(current->map_base)
+#define __TASK_UNMAPPED_BASE PAGE_ALIGN(TASK_SIZE/3)
 
 /*
  * Size of io_bitmap, covering ports 0 to 0x3ff.
diff -u linux/fs/proc/base.c-BASE linux/fs/proc/base.c
--- linux/fs/proc/base.c-BASE	2004-02-19 14:32:21.000000000 +0100
+++ linux/fs/proc/base.c	2004-02-19 16:16:13.000000000 +0100
@@ -60,6 +60,7 @@
 	PROC_TGID_MAPS,
 	PROC_TGID_MOUNTS,
 	PROC_TGID_WCHAN,
+	PROC_TGID_MAPBASE,
 #ifdef CONFIG_SECURITY
 	PROC_TGID_ATTR,
 	PROC_TGID_ATTR_CURRENT,
@@ -117,6 +118,9 @@
 	E(PROC_TGID_ROOT,      "root",    S_IFLNK|S_IRWXUGO),
 	E(PROC_TGID_EXE,       "exe",     S_IFLNK|S_IRWXUGO),
 	E(PROC_TGID_MOUNTS,    "mounts",  S_IFREG|S_IRUGO),
+#ifdef __HAS_ARCH_PROC_MAPPED_BASE
+   	E(PROC_TGID_MAPBASE,	"map_base",	S_IFREG|S_IRUSR|S_IWUSR),
+#endif
 #ifdef CONFIG_SECURITY
 	E(PROC_TGID_ATTR,      "attr",    S_IFDIR|S_IRUGO|S_IXUGO),
 #endif
@@ -689,6 +693,55 @@
 	.open		= mem_open,
 };
 
+#ifdef __HAS_ARCH_PROC_MAPPED_BASE
+static ssize_t mapbase_read(struct file * file, char * buf,
+			size_t count, loff_t *ppos)
+{
+	struct task_struct *task = proc_task(file->f_dentry->d_inode);
+	char buffer[64];
+	size_t len;
+
+	len = sprintf(buffer, "%li\n", task->map_base) + 1;
+	if (*ppos >= len)
+		return 0;
+	if (count > len-*ppos)
+		count = len-*ppos;
+	if (copy_to_user(buf, buffer + *ppos, count)) 
+		return -EFAULT;
+	*ppos += count;
+	return count;
+}
+
+static ssize_t mapbase_write(struct file * file, const char * buf,
+			 size_t count, loff_t *ppos)
+{
+	struct task_struct *task = proc_task(file->f_dentry->d_inode);
+	char buffer[64], *end;
+	unsigned long newbase;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	memset(buffer, 0, 64);	
+	if (count > 62)
+		count = 62;
+	if (copy_from_user(buffer, buf, count)) 
+		return -EFAULT;
+	newbase = simple_strtoul(buffer, &end, 0);
+	if (*end == '\n')
+		end++;
+	if (newbase > 0)
+		task->map_base = newbase;
+	if (end - buffer == 0) 
+		return -EIO;
+	return end - buffer;
+}
+
+static struct file_operations proc_mapbase_operations = {
+	read:		mapbase_read,
+	write:		mapbase_write,
+};
+#endif /* __HAS_ARCH_PROC_MAPPED_BASE */
+
 static struct inode_operations proc_mem_inode_operations = {
 	.permission	= proc_permission,
 };
@@ -1353,6 +1406,11 @@
 		case PROC_TGID_MAPS:
 			inode->i_fop = &proc_maps_operations;
 			break;
+#ifdef __HAS_ARCH_PROC_MAPPED_BASE
+ 		case PROC_TGID_MAPBASE:
+ 			inode->i_fop = &proc_mapbase_operations;
+ 			break;
+#endif
 		case PROC_TID_MEM:
 		case PROC_TGID_MEM:
 			inode->i_op = &proc_mem_inode_operations;
