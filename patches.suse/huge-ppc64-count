diff -u linux-2.6.5/arch/ppc64/mm/hugetlbpage.c-PPC linux-2.6.5/arch/ppc64/mm/hugetlbpage.c
--- linux-2.6.5/arch/ppc64/mm/hugetlbpage.c-PPC	2004-05-12 13:08:00.447986156 +0200
+++ linux-2.6.5/arch/ppc64/mm/hugetlbpage.c	2004-05-12 13:09:39.299254446 +0200
@@ -998,6 +998,12 @@
 			HPAGE_SIZE/1024);
 }
 
+/* dummy right now. Fix when you have real NUMA policy here. */
+int __is_hugepage_mem_enough(struct mempolicy *pol, size_t size)
+{
+	return is_hugepage_mem_enough(size);
+}
+
 /* This is advisory only, so we can get away with accesing
  * htlbpage_free without taking the lock. */
 int is_hugepage_mem_enough(size_t size)
@@ -1012,6 +1018,26 @@
 }
 EXPORT_SYMBOL(hugetlb_total_pages);
 
+/* Count allocated huge pages in a range */
+unsigned long huge_count_pages(unsigned long addr, unsigned long end)
+{
+	unsigned long pages = 0;
+	while (addr < end) {
+		struct page *p;
+		hugepte_t *pte;
+		pgd_t *pgd = pgd_offset(current->mm, addr);
+		if (pgd_none(*pgd)) {
+			addr = (addr + PGDIR_SIZE) & PGDIR_MASK;
+			continue;
+		}
+		pte = (hugepte_t *)pmd_offset(pgd, addr);
+		if (!hugepte_none(*pte))
+			pages++;
+		addr += HPAGE_SIZE;
+	}
+	return pages;
+}
+
 /*
  * We cannot handle pagefaults against hugetlb pages at all.  They cause
  * handle_mm_fault() to try to instantiate regular-sized pages in the
