Index: linux.aio/fs/aio.c
===================================================================
--- linux.aio.orig/fs/aio.c	2004-02-15 14:53:51.000000000 -0500
+++ linux.aio/fs/aio.c	2004-02-15 15:50:50.000000000 -0500
@@ -918,6 +918,13 @@
 	if (iocb->ki_run_list.prev && !list_empty(&iocb->ki_run_list))
 		list_del_init(&iocb->ki_run_list);
 
+	/*
+	 * cancelled requests don't get events, userland was given one
+	 * when the event got cancelled.
+	 */ 
+	if (kiocbIsCancelled(iocb))
+		goto put_rq;
+
 	ring = kmap_atomic(info->ring_pages[0], KM_IRQ1);
 
 	tail = info->tail;
@@ -950,7 +957,7 @@
 		iocb->ki_retried,
 		iocb->ki_nbytes - iocb->ki_left, iocb->ki_nbytes,
 		iocb->ki_kicked, iocb->ki_queued, aio_run, aio_wakeups);
-
+put_rq:
 	/* everything turned out well, dispose of the aiocb. */
 	ret = __aio_put_req(ctx, iocb);
 
@@ -1604,6 +1611,7 @@
 	if (kiocb && kiocb->ki_cancel) {
 		cancel = kiocb->ki_cancel;
 		kiocb->ki_users ++;
+		kiocbSetCancelled(kiocb);
 	} else
 		cancel = NULL;
 	spin_unlock_irq(&ctx->ctx_lock);
