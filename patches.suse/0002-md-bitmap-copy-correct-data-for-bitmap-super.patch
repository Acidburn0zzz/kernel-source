From: NeilBrown <neilb@suse.com>
Subject: REVERT:  md/bitmap: copy correct data for bitmap super
Patch-mainline: not yet, under discussion.
References: bsc#1062597

The below patch fixes a problem with badly-configured RAID5
and introduces a problem on arch with 64K PAGE_SIZE.
So revert it.  A better fix is comming

x-From: Shaohua Li <shli@fb.com>
x-Date: Thu, 17 Aug 2017 10:35:11 -0700
x-Subject: [PATCH] md/bitmap: copy correct data for bitmap super
x-Git-commit: 8031c3ddc70ab93099e7d1814382dba39f57b43e
x-Patch-mainline: md/4.14

raid5 cache could write bitmap superblock before bitmap superblock is
initialized. The bitmap superblock is less than 512B. The current code will
only copy the superblock to a new page and write the whole 512B, which will
zero the the data after the superblock. Unfortunately the data could include
bitmap, which we should preserve. The patch will make superblock read do 4k
chunk and we always copy the 4k data to new page, so the superblock write will
old data to disk and we don't change the bitmap.

Reported-by: Song Liu <songliubraving@fb.com>
Reviewed-by: Song Liu <songliubraving@fb.com>
Cc: stable@vger.kernel.org (4.10+)
Signed-off-by: Shaohua Li <shli@fb.com>
Acked-by: NeilBrown <neilb@suse.com>

---
 drivers/md/bitmap.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@ -625,7 +625,7 @@ re_read:
 		err = read_sb_page(bitmap->mddev,
 				   offset,
 				   sb_page,
-				   0, PAGE_SIZE);
+				   0, sizeof(bitmap_super_t));
 	}
 	if (err)
 		return err;
@@ -2123,7 +2123,7 @@ int bitmap_resize(struct bitmap *bitmap,
 	if (store.sb_page && bitmap->storage.sb_page)
 		memcpy(page_address(store.sb_page),
 		       page_address(bitmap->storage.sb_page),
-		       PAGE_SIZE);
+		       sizeof(bitmap_super_t));
 	bitmap_file_unmap(&bitmap->storage);
 	bitmap->storage = store;
 
