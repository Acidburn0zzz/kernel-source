bug 41325

When filling holes via DIRECT_IO, we fall back to normal buffered
io.  For this to work properly, the direct io funcs have to return
a value of zero to the file write functions, so the file
write functions know where to start writing.  

In some cases, dio->result was getting returned by direct_io_worker,
and that wasn't always zero, causing some data not to be written.

There is a nicer fix for this somewhere, but this one is obvious.

Index: linux.t/fs/direct-io.c
===================================================================
--- linux.t.orig/fs/direct-io.c	2004-05-28 09:54:35.000000000 -0400
+++ linux.t/fs/direct-io.c	2004-05-28 09:55:43.000000000 -0400
@@ -909,6 +909,7 @@ direct_io_worker(int rw, struct kiocb *i
 	ssize_t ret = 0;
 	ssize_t ret2;
 	size_t bytes;
+	int enotblk = 0;
 
 	dio->bio = NULL;
 	dio->inode = inode;
@@ -990,6 +991,7 @@ direct_io_worker(int rw, struct kiocb *i
 		 * be handled by buffered I/O when we return
 		 */
 		ret = 0;
+		enotblk = 1;
 	}
 	/*
 	 * There may be some unwritten disk at the end of a part-written
@@ -1085,6 +1087,8 @@ direct_io_worker(int rw, struct kiocb *i
 			aio_complete(iocb, ret, 0);
 		kfree(dio);
 	}
+	if (enotblk && ret > 0)
+		ret = 0;
 	return ret;
 }
 
