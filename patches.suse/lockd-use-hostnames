From: Olaf Kirch <okir@suse.de>
Subject: lockd: optionally use hostnames for identifying peers

  This patch adds the nsm_use_hostnames sysctl. If set, lockd will use
  the client's name (as given in the NLM arguments) to find the NSM
  handle. This makes recovery work when the NFS peer is multi-homed, and
  the reboot notification arrives from a different IP than the original
  lock calls.

Signed-off-by: Olaf Kirch <okir@suse.de>

 fs/lockd/host.c                |    5 +++++
 fs/lockd/mon.c                 |   12 +++++++++---
 fs/lockd/svc.c                 |    9 +++++++++
 include/linux/lockd/lockd.h    |    1 +
 include/linux/lockd/sm_inter.h |    2 ++
 5 files changed, 26 insertions(+), 3 deletions(-)

--- linux-2.6.18.orig/fs/lockd/host.c
+++ linux-2.6.18/fs/lockd/host.c
@@ -498,6 +498,11 @@ __nsm_find(const struct sockaddr_in *sin
 	list_for_each(pos, &nsm_handles) {
 		nsm = list_entry(pos, struct nsm_handle, sm_link);
 
+		if (hostname && nsm_use_hostnames) {
+			if (strlen(nsm->sm_name) != hostname_len
+			 || memcmp(nsm->sm_name, hostname, hostname_len))
+				continue;
+		} else
 		if (!nlm_cmp_addr(&nsm->sm_addr, sin))
 			continue;
 		atomic_inc(&nsm->sm_count);
--- linux-2.6.18.orig/fs/lockd/mon.c
+++ linux-2.6.18/fs/lockd/mon.c
@@ -47,6 +47,7 @@ nsm_mon_unmon(struct nsm_handle *nsm, u3
 	}
 
 	memset(&args, 0, sizeof(args));
+	args.mon_name = nsm->sm_name;
 	args.addr = nsm->sm_addr.sin_addr.s_addr;
 	args.prog = NLM_PROGRAM;
 	args.vers = 3;
@@ -157,7 +158,7 @@ out_err:
 static u32 *
 xdr_encode_common(struct rpc_rqst *rqstp, u32 *p, struct nsm_args *argp)
 {
-	char	buffer[20];
+	char	buffer[20], *name;
 
 	/*
 	 * Use the dotted-quad IP address of the remote host as
@@ -165,8 +166,13 @@ xdr_encode_common(struct rpc_rqst *rqstp
 	 * hostname first for whatever remote hostname it receives,
 	 * so this works alright.
 	 */
-	sprintf(buffer, "%u.%u.%u.%u", NIPQUAD(argp->addr));
-	if (!(p = xdr_encode_string(p, buffer))
+	if (nsm_use_hostnames) {
+		name = argp->mon_name;
+	} else {
+		sprintf(buffer, "%u.%u.%u.%u", NIPQUAD(argp->addr));
+		name = buffer;
+	}
+	if (!(p = xdr_encode_string(p, name))
 	 || !(p = xdr_encode_string(p, system_utsname.nodename)))
 		return ERR_PTR(-EIO);
 	*p++ = htonl(argp->prog);
--- linux-2.6.18.orig/fs/lockd/svc.c
+++ linux-2.6.18/fs/lockd/svc.c
@@ -60,6 +60,7 @@ static unsigned long		nlm_grace_period;
 static unsigned long		nlm_timeout = LOCKD_DFLT_TIMEO;
 static int			nlm_udpport, nlm_tcpport;
 int				nlm_max_hosts = 256;
+int				nsm_use_hostnames = 0;
 
 /*
  * Constants needed for the sysctl interface.
@@ -376,6 +377,14 @@ static ctl_table nlm_sysctls[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nsm_use_hostnames",
+		.data		= &nsm_use_hostnames,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 
 	{ .ctl_name = 0 }
 };
--- linux-2.6.18.orig/include/linux/lockd/lockd.h
+++ linux-2.6.18/include/linux/lockd/lockd.h
@@ -143,6 +143,7 @@ extern struct svc_procedure	nlmsvc_proce
 extern int			nlmsvc_grace_period;
 extern unsigned long		nlmsvc_timeout;
 extern int			nlm_max_hosts;
+extern int			nsm_use_hostnames;
 
 /*
  * Lockd client functions
--- linux-2.6.18.orig/include/linux/lockd/sm_inter.h
+++ linux-2.6.18/include/linux/lockd/sm_inter.h
@@ -28,6 +28,8 @@ struct nsm_args {
 	u32		prog;		/* RPC callback info */
 	u32		vers;
 	u32		proc;
+
+	char *		mon_name;
 };
 
 /*
