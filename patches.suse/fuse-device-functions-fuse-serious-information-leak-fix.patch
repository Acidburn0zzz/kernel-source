From: Miklos Szeredi <miklos@szeredi.hu>
Subject: [FUSE] Fix serious information leak
Patch-mainline: 2.6.12-rc-mm

In certain situations the user can read out previous contents of pages.  To
do this, create a filesystem that returns a short count on a read request. 
Then issue a read for a file.  If there are pages to be read, that are not
touched at all, these will not be zeroed.

The fix is to zero out all pages that are not touched.

Thanks to Sven Tantau for the bug report.

Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---

 fs/fuse/dev.c |    2 +-
 1 files changed, 1 insertion(+), 1 deletion(-)

diff -puN fs/fuse/dev.c~fuse-device-functions-fuse-serious-information-leak-fix fs/fuse/dev.c
--- 25/fs/fuse/dev.c~fuse-device-functions-fuse-serious-information-leak-fix	Thu Jun  2 16:48:17 2005
+++ 25-akpm/fs/fuse/dev.c	Thu Jun  2 16:48:33 2005
@@ -532,7 +532,7 @@ static int fuse_copy_pages(struct fuse_c
 	unsigned offset = req->page_offset;
 	unsigned count = min(nbytes, (unsigned) PAGE_SIZE - offset);
 
-	for (i = 0; i < req->num_pages && nbytes; i++) {
+	for (i = 0; i < req->num_pages && (nbytes || zeroing); i++) {
 		struct page *page = req->pages[i];
 		int err = fuse_copy_page(cs, page, offset, count, zeroing);
 		if (err)
_
