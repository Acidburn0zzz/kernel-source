dm.c: Use waitqueue_active() to save a couple of cycles.

I couldn't think of a reason why event_callback() was using
wake_up_interruptible() rather than plain old wake_up(), so changed
it.
Index: linux.t/drivers/md/dm.c
===================================================================
--- linux.t.orig/drivers/md/dm.c	2004-03-16 11:42:39.345379024 -0500
+++ linux.t/drivers/md/dm.c	2004-03-16 11:54:40.783703728 -0500
@@ -271,13 +271,20 @@ struct dm_table *dm_get_table(struct map
  */
 static inline void dec_pending(struct dm_io *io, int error)
 {
+	wait_queue_head_t *wq;
+
 	if (error)
 		io->error = error;
 
 	if (atomic_dec_and_test(&io->io_count)) {
-		if (atomic_dec_and_test(&io->md->pending))
+		if (atomic_dec_and_test(&io->md->pending)) {
+			wq = &io->md->wait;
+
 			/* nudge anyone waiting on suspend queue */
-			wake_up(&io->md->wait);
+			smp_mb();
+			if (waitqueue_active(wq))
+			    wake_up(wq);
+		}
 
 		bio_endio(io->bio, io->bio->bi_size, io->error);
 		free_io(io->md, io);
@@ -749,7 +756,9 @@ static void event_callback(void *context
 
 	down_write(&md->lock);
 	md->event_nr++;
-	wake_up_interruptible(&md->eventq);
+	smp_mb();
+	if (waitqueue_active(&md->eventq))
+		wake_up(&md->eventq);
 	up_write(&md->lock);
 }
 
