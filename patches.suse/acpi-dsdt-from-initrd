Index: linux-2.6.8/drivers/acpi/osl.c
===================================================================
--- linux-2.6.8.orig/drivers/acpi/osl.c
+++ linux-2.6.8/drivers/acpi/osl.c
@@ -34,6 +34,7 @@
 #include <linux/interrupt.h>
 #include <linux/kmod.h>
 #include <linux/delay.h>
+#include <linux/initrd.h>
 #include <linux/workqueue.h>
 #include <linux/nmi.h>
 #include <acpi/acpi.h>
@@ -234,6 +235,50 @@ acpi_os_predefined_override (const struc
 	return AE_OK;
 }
 
+#ifdef CONFIG_ACPI_INITRD
+static char *
+acpi_find_dsdt_initrd(void)
+{
+	static const char start_signature[] = "INITRDDSDT123DSDT123";
+	static const char end_signature[] =   "INITRDDSDT321DSDT321";
+	char *dsdt_start = NULL;
+
+	if (initrd_start) {
+		char *dsdt_end = (char *)initrd_end - sizeof(end_signature);
+		char *data;
+
+		printk(KERN_INFO PREFIX "Looking for DSDT in initrd...");
+
+		/* Search for the start signature */
+		for (data = (char *)initrd_start; data < dsdt_end; data++) {
+			if (!memcmp(data, start_signature, 
+				    sizeof(start_signature) - 1)) {
+				data += sizeof(start_signature);
+				if (!memcmp(data, "DSDT", 4))
+					dsdt_start = data;
+				break;
+			}
+		}
+		if (dsdt_start != NULL) {
+			/* search for end signature in initrd
+			   This search is useful only for debug now that acpi 
+			   handle by itself the size of the table -eric */
+			while (dsdt_end > dsdt_start) {
+				if (!memcmp(dsdt_end, end_signature,
+					    sizeof(end_signature) - 1))
+					break;
+				dsdt_end--;
+			}
+			printk(" found at offset %zu with %zu bytes!\n",
+			       dsdt_start - (char *)initrd_start,
+			       dsdt_end - dsdt_start);
+		} else
+			printk(" not found!\n");
+	}
+	return dsdt_start;
+}
+#endif
+
 acpi_status
 acpi_os_table_override (struct acpi_table_header *existing_table,
 			struct acpi_table_header **new_table)
@@ -242,6 +287,13 @@ acpi_os_table_override (struct acpi_tabl
 		return AE_BAD_PARAMETER;
 
 	*new_table = NULL;
+#ifdef CONFIG_ACPI_INITRD
+	if (!strncmp(existing_table->signature, "DSDT", 4)) {
+		*new_table = (struct acpi_table_header*)acpi_find_dsdt_initrd();
+		if (*new_table)
+			printk(KERN_INFO PREFIX "Using customized DSDT\n");
+	}
+#endif
 	return AE_OK;
 }
 
Index: linux-2.6.8/drivers/acpi/Kconfig
===================================================================
--- linux-2.6.8.orig/drivers/acpi/Kconfig
+++ linux-2.6.8/drivers/acpi/Kconfig
@@ -270,5 +270,19 @@ config X86_PM_TIMER
 	  kernel logs, and/or you are using this on a notebook which
 	  does not yet have an HPET, you should say "Y" here.
 
+config ACPI_INITRD
+	bool "Read DSDT from initrd"
+	depends on ACPI && BLK_DEV_INITRD
+	default y
+	help
+	  The DSDT (Differentiated System Description Table) often needs to be
+	  overridden because of broken BIOS implementations. If you want to use
+	  a customized DSDT, please use the mkinitrd tool (mkinitrd package) to 
+	  attach the  DSDT to the initrd) or see http://gaugusch.at/kernel.shtml 
+	  for instructions on using an existing initrd with ACPI. If there is no 
+	  one found in the initrd, the DSDT from the BIOS is used. Even you do not 
+	  need a new one at the moment, you may want to use a better implemented 
+	  DSDT later. It is save to say yes here
+
 endmenu
 
