From: Olaf Kirch <okir@suse.de>
Subject: lockd: Make nlm_host_rebooted use the nsm_handle

  This patch makes the SM_NOTIFY handling understand and use
  the nsm_handle.

Signed-off-by: Olaf Kirch <okir@suse.de>

Index: 2.6.15/fs/lockd/clntlock.c
===================================================================
--- 2.6.15.orig/fs/lockd/clntlock.c
+++ 2.6.15/fs/lockd/clntlock.c
@@ -168,33 +168,24 @@ void nlmclnt_mark_reclaim(struct nlm_hos
 }
 
 /*
- * Someone has sent us an SM_NOTIFY. Ensure we bind to the new port number,
- * that we mark locks for reclaiming, and that we bump the pseudo NSM state.
+ * Reclaim all locks on server host. We do this by spawning a separate
+ * reclaimer thread.
  */
-static inline
-void nlmclnt_prepare_reclaim(struct nlm_host *host, u32 newstate)
+void
+nlmclnt_recovery(struct nlm_host *host)
 {
-	host->h_nsmstate = newstate;
-	host->h_state++;
+	dprintk("lockd: reclaiming locks for host %s", host->h_name);
+
+	/* Force a portmapp getport - the peer's lockd will
+	 * most likely end up on a different port.
+	 */
 	host->h_nextrebind = 0;
 	nlm_rebind_host(host);
+
+	/* Mark locks for reclaim */
 	nlmclnt_mark_reclaim(host);
-	dprintk("NLM: reclaiming locks for host %s", host->h_name);
-}
 
-/*
- * Reclaim all locks on server host. We do this by spawning a separate
- * reclaimer thread.
- */
-void
-nlmclnt_recovery(struct nlm_host *host, u32 newstate)
-{
-	if (host->h_reclaiming++) {
-		if (host->h_nsmstate == newstate)
-			return;
-		nlmclnt_prepare_reclaim(host, newstate);
-	} else {
-		nlmclnt_prepare_reclaim(host, newstate);
+	if (!host->h_reclaiming++) {
 		nlm_get_host(host);
 		__module_get(THIS_MODULE);
 		if (kernel_thread(reclaimer, host, CLONE_KERNEL) < 0)
Index: 2.6.15/fs/lockd/host.c
===================================================================
--- 2.6.15.orig/fs/lockd/host.c
+++ 2.6.15/fs/lockd/host.c
@@ -277,28 +277,57 @@ void nlm_release_host(struct nlm_host *h
  * has rebooted.
  * Release all resources held by that peer.
  */
-void nlm_host_rebooted(const struct sockaddr_in *sin, const struct nlm_reboot *argp)
-{
-	struct nlm_host *host;
-	int server;
+void nlm_host_rebooted(const struct sockaddr_in *sin,
+				const char *hostname, int hostname_len,
+				u32 new_state)
+{
+	struct nsm_handle *nsm;
+	struct nlm_host	*host, **hp;
+	int		hash;
 
-	/* Obtain the host pointer for this NFS server and try to
-	 * reclaim all locks we hold on this server.
-	 */
-	server = (argp->proto & 1)? 1 : 0;
-	host = nlm_lookup_host(server, sin, argp->proto >> 1, argp->vers,
-			argp->mon, argp->len);
-	if (host == NULL)
+	dprintk("lockd: nlm_host_rebooted(%s, %u.%u.%u.%u)\n",
+			hostname, NIPQUAD(sin->sin_addr));
+
+	/* Find the NSM handle for this peer */
+	if (!(nsm = __nsm_find(sin, hostname, hostname_len, 0)))
 		return;
 
-	if (server == 0) {
-		/* We are client, he's the server: try to reclaim all locks. */
-		nlmclnt_recovery(host, argp->state);
-	} else {
-		/* He's the client, we're the server: delete all locks held by the client */
-		nlmsvc_free_host_resources(host);
+	/* When reclaiming locks on this peer, make sure that
+	 * we set up a new notification */
+	nsm->sm_monitored = 0;
+
+	/* Mark all hosts tied to this NSM state as having rebooted.
+	 * We run the loop repeatedly, because we drop the host table
+	 * lock for this.
+	 * To avoid processing a host several times, we match the nsmstate.
+	 */
+again:	down(&nlm_host_sema);
+	for (hash = 0; hash < NLM_HOST_NRHASH; hash++) {
+		for (hp = &nlm_hosts[hash]; (host = *hp); hp = &host->h_next) {
+			if (host->h_nsmhandle == nsm
+			 && host->h_nsmstate != new_state) {
+				host->h_nsmstate = new_state;
+				host->h_state++;
+
+				nlm_get_host(host);
+				up(&nlm_host_sema);
+
+				if (host->h_server) {
+					/* We're server for this guy, just ditch
+					 * all the locks he held. */
+					nlmsvc_free_host_resources(host);
+				} else {
+					/* He's the server, initiate lock recovery. */
+					nlmclnt_recovery(host);
+				}
+
+				nlm_release_host(host);
+				goto again;
+			}
+		}
 	}
-	nlm_release_host(host);
+
+	up(&nlm_host_sema);
 }
 
 /*
Index: 2.6.15/fs/lockd/svc4proc.c
===================================================================
--- 2.6.15.orig/fs/lockd/svc4proc.c
+++ 2.6.15/fs/lockd/svc4proc.c
@@ -433,7 +433,7 @@ nlm4svc_proc_sm_notify(struct svc_rqst *
 	 */
 	memset(&saddr, 0, sizeof(saddr));
 	saddr.sin_addr.s_addr = argp->addr;
-	nlm_host_rebooted(&saddr, argp);
+	nlm_host_rebooted(&saddr, argp->mon, argp->len, argp->state);
 
 	return rpc_success;
 }
Index: 2.6.15/fs/lockd/svcproc.c
===================================================================
--- 2.6.15.orig/fs/lockd/svcproc.c
+++ 2.6.15/fs/lockd/svcproc.c
@@ -461,7 +461,7 @@ nlmsvc_proc_sm_notify(struct svc_rqst *r
 	 */
 	memset(&saddr, 0, sizeof(saddr));
 	saddr.sin_addr.s_addr = argp->addr;
-	nlm_host_rebooted(&saddr, argp);
+	nlm_host_rebooted(&saddr, argp->mon, argp->len, argp->state);
 
 	return rpc_success;
 }
Index: 2.6.15/include/linux/lockd/lockd.h
===================================================================
--- 2.6.15.orig/include/linux/lockd/lockd.h
+++ 2.6.15/include/linux/lockd/lockd.h
@@ -161,7 +161,7 @@ void		  nlmclnt_finish_block(struct nlm_
 long		  nlmclnt_block(struct nlm_rqst *req, long timeout);
 int		  nlmclnt_cancel(struct nlm_host *, struct file_lock *);
 u32		  nlmclnt_grant(struct nlm_lock *);
-void		  nlmclnt_recovery(struct nlm_host *, u32);
+void		  nlmclnt_recovery(struct nlm_host *);
 int		  nlmclnt_reclaim(struct nlm_host *, struct file_lock *);
 int		  nlmclnt_setgrantargs(struct nlm_rqst *, struct nlm_lock *);
 void		  nlmclnt_freegrantargs(struct nlm_rqst *);
@@ -178,7 +178,7 @@ struct nlm_host * nlm_get_host(struct nl
 void		  nlm_release_host(struct nlm_host *);
 void		  nlm_shutdown_hosts(void);
 extern struct nlm_host *nlm_find_client(void);
-extern void	  nlm_host_rebooted(const struct sockaddr_in *, const struct nlm_reboot *);
+extern void	  nlm_host_rebooted(const struct sockaddr_in *, const char *, int, u32);
 struct nsm_handle *nsm_find(const struct sockaddr_in *, const char *, int);
 void		  nsm_release(struct nsm_handle *);
 
