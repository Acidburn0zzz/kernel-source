Fixes some bugs in the ckrm socket classes.  The bugs could cause
random memory corruption and the use of uninitialized variables

diff -urN a/kernel/ckrm/ckrm_sockc.c b/kernel/ckrm/ckrm_sockc.c
--- a/kernel/ckrm/ckrm_sockc.c	2004-05-03 11:57:17.000000000 -0700
+++ b/kernel/ckrm/ckrm_sockc.c	2004-05-12 01:04:56.000000000 -0700
@@ -117,7 +117,6 @@
 {
         if (atomic_dec_and_test(&ns->ns_refcnt))
                 kfree(ns);
-
         return;
 }
 /*
@@ -201,8 +200,9 @@
 	if (!ns)
 		return;
 
-	memset(ns,0, sizeof(ns));
+	memset(ns,0, sizeof(*ns));
 	INIT_LIST_HEAD(&ns->ckrm_link);
+	ckrm_ns_hold(ns);
 
 	ns->ns_family = sk->sk_family;
 	if (ns->ns_family == IPPROTO_IPV6)	// IPv6 not supported yet.
@@ -213,7 +213,6 @@
 		
 	ns->ns_pid = current->pid;
 	ns->ns_tgid = current->tgid;
-
 	ce_protect(&CT_sockclass);
 	CE_CLASSIFY_RET(newcls,&CT_sockclass,CKRM_EVENT_LISTEN_START,ns,current);
 	ce_release(&CT_sockclass);
@@ -225,7 +224,6 @@
 
 	class_lock(class_core(newcls));
 	list_add(&ns->ckrm_link, &class_core(newcls)->objlist);
-	ckrm_ns_put(ns);
 	ns->core = newcls;
 	class_unlock(class_core(newcls));
 	
@@ -269,8 +267,8 @@
 		class_lock(class_core(newcls));
 		list_del(&ns->ckrm_link);
 		INIT_LIST_HEAD(&ns->ckrm_link);
-		ckrm_core_drop(class_core(newcls));
 		class_unlock(class_core(newcls));
+		ckrm_core_drop(class_core(newcls));
 	}
 
 	// the socket is already locked
@@ -469,9 +467,10 @@
 			p2 = v4toi(p2, '\\',&(v4addr));
 			ns.ns_daddrv4 = htonl(v4addr);
 			ns.ns_family = 4; //IPPROTO_IPV4
-			p2 = v4toi(++p2, ':',&tmp); ns.ns_dport = (__u16)tmp;
-			p2 = v4toi(++p2,'\0',&ns.ns_pid);
-			
+			p2 = v4toi(++p2, ':',&tmp); 
+			ns.ns_dport = (__u16)tmp;
+			if (*p2) 
+				p2 = v4toi(++p2,'\0',&ns.ns_pid);
 			sock_forced_reclassify_ns(&ns,target);
 			break;
 
