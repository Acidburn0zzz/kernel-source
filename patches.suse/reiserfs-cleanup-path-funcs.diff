From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH 22/37] reiserfs: cleanup path functions

 This patch cleans up some redundancies in the reiserfs tree path code.

 decrement_bcount() is essentially the same function as brelse(), so we use
 that instead.

 decrement_counters_in_path() is exactly the same function as pathrelse(), so
 we kill that and use pathrelse() instead.

 There's also a bit of cleanup that makes the code a bit more readable.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

---

 fs/reiserfs/fix_node.c |   58 ++++++++++++++++++++++++------------------------
 fs/reiserfs/stree.c    |   59 ++++++++++---------------------------------------
 2 files changed, 43 insertions(+), 74 deletions(-)

--- a/fs/reiserfs/fix_node.c	2007-05-10 07:58:25.000000000 -0400
+++ b/fs/reiserfs/fix_node.c	2007-05-10 07:58:28.000000000 -0400
@@ -753,20 +753,21 @@ static void free_buffers_in_tb(struct tr
 {
 	int n_counter;
 
-	decrement_counters_in_path(p_s_tb->tb_path);
+	pathrelse(p_s_tb->tb_path);
 
 	for (n_counter = 0; n_counter < MAX_HEIGHT; n_counter++) {
-		decrement_bcount(p_s_tb->L[n_counter]);
+		brelse(p_s_tb->L[n_counter]);
+		brelse(p_s_tb->R[n_counter]);
+		brelse(p_s_tb->FL[n_counter]);
+		brelse(p_s_tb->FR[n_counter]);
+		brelse(p_s_tb->CFL[n_counter]);
+		brelse(p_s_tb->CFR[n_counter]);
+
 		p_s_tb->L[n_counter] = NULL;
-		decrement_bcount(p_s_tb->R[n_counter]);
 		p_s_tb->R[n_counter] = NULL;
-		decrement_bcount(p_s_tb->FL[n_counter]);
 		p_s_tb->FL[n_counter] = NULL;
-		decrement_bcount(p_s_tb->FR[n_counter]);
 		p_s_tb->FR[n_counter] = NULL;
-		decrement_bcount(p_s_tb->CFL[n_counter]);
 		p_s_tb->CFL[n_counter] = NULL;
-		decrement_bcount(p_s_tb->CFR[n_counter]);
 		p_s_tb->CFR[n_counter] = NULL;
 	}
 }
@@ -1020,7 +1021,7 @@ static int get_far_parent(struct tree_ba
 	if (buffer_locked(*pp_s_com_father)) {
 		__wait_on_buffer(*pp_s_com_father);
 		if (FILESYSTEM_CHANGED_TB(p_s_tb)) {
-			decrement_bcount(*pp_s_com_father);
+			brelse(*pp_s_com_father);
 			return REPEAT_SEARCH;
 		}
 	}
@@ -1048,8 +1049,8 @@ static int get_far_parent(struct tree_ba
 		return IO_ERROR;
 
 	if (FILESYSTEM_CHANGED_TB(p_s_tb)) {
-		decrement_counters_in_path(&s_path_to_neighbor_father);
-		decrement_bcount(*pp_s_com_father);
+		pathrelse(&s_path_to_neighbor_father);
+		brelse(*pp_s_com_father);
 		return REPEAT_SEARCH;
 	}
 
@@ -1061,7 +1062,7 @@ static int get_far_parent(struct tree_ba
 	       FIRST_PATH_ELEMENT_OFFSET, "PAP-8192: path length is too small");
 
 	s_path_to_neighbor_father.path_length--;
-	decrement_counters_in_path(&s_path_to_neighbor_father);
+	pathrelse(&s_path_to_neighbor_father);
 	return CARRY_ON;
 }
 
@@ -1084,10 +1085,10 @@ static int get_parents(struct tree_balan
 	if (n_path_offset <= FIRST_PATH_ELEMENT_OFFSET) {
 		/* The root can not have parents.
 		   Release nodes which previously were obtained as parents of the current node neighbors. */
-		decrement_bcount(p_s_tb->FL[n_h]);
-		decrement_bcount(p_s_tb->CFL[n_h]);
-		decrement_bcount(p_s_tb->FR[n_h]);
-		decrement_bcount(p_s_tb->CFR[n_h]);
+		brelse(p_s_tb->FL[n_h]);
+		brelse(p_s_tb->CFL[n_h]);
+		brelse(p_s_tb->FR[n_h]);
+		brelse(p_s_tb->CFR[n_h]);
 		p_s_tb->FL[n_h] = p_s_tb->CFL[n_h] = p_s_tb->FR[n_h] =
 		    p_s_tb->CFR[n_h] = NULL;
 		return CARRY_ON;
@@ -1113,9 +1114,9 @@ static int get_parents(struct tree_balan
 			return n_ret_value;
 	}
 
-	decrement_bcount(p_s_tb->FL[n_h]);
+	brelse(p_s_tb->FL[n_h]);
 	p_s_tb->FL[n_h] = p_s_curf;	/* New initialization of FL[n_h]. */
-	decrement_bcount(p_s_tb->CFL[n_h]);
+	brelse(p_s_tb->CFL[n_h]);
 	p_s_tb->CFL[n_h] = p_s_curcf;	/* New initialization of CFL[n_h]. */
 
 	RFALSE((p_s_curf && !B_IS_IN_TREE(p_s_curf)) ||
@@ -1143,10 +1144,10 @@ static int get_parents(struct tree_balan
 		p_s_tb->rkey[n_h] = n_position;
 	}
 
-	decrement_bcount(p_s_tb->FR[n_h]);
+	brelse(p_s_tb->FR[n_h]);
 	p_s_tb->FR[n_h] = p_s_curf;	/* New initialization of FR[n_path_offset]. */
 
-	decrement_bcount(p_s_tb->CFR[n_h]);
+	brelse(p_s_tb->CFR[n_h]);
 	p_s_tb->CFR[n_h] = p_s_curcf;	/* New initialization of CFR[n_path_offset]. */
 
 	RFALSE((p_s_curf && !B_IS_IN_TREE(p_s_curf)) ||
@@ -1962,7 +1963,7 @@ static int get_neighbors(struct tree_bal
 		if (!p_s_bh)
 			return IO_ERROR;
 		if (FILESYSTEM_CHANGED_TB(p_s_tb)) {
-			decrement_bcount(p_s_bh);
+			brelse(p_s_bh);
 			PROC_INFO_INC(p_s_sb, get_neighbors_restart[n_h]);
 			return REPEAT_SEARCH;
 		}
@@ -1978,7 +1979,7 @@ static int get_neighbors(struct tree_bal
 		       dc_size(B_N_CHILD(p_s_tb->FL[0], n_child_position)),
 		       "PAP-8290: invalid child size of left neighbor");
 
-		decrement_bcount(p_s_tb->L[n_h]);
+		brelse(p_s_tb->L[n_h]);
 		p_s_tb->L[n_h] = p_s_bh;
 	}
 
@@ -1999,11 +2000,11 @@ static int get_neighbors(struct tree_bal
 		if (!p_s_bh)
 			return IO_ERROR;
 		if (FILESYSTEM_CHANGED_TB(p_s_tb)) {
-			decrement_bcount(p_s_bh);
+			brelse(p_s_bh);
 			PROC_INFO_INC(p_s_sb, get_neighbors_restart[n_h]);
 			return REPEAT_SEARCH;
 		}
-		decrement_bcount(p_s_tb->R[n_h]);
+		brelse(p_s_tb->R[n_h]);
 		p_s_tb->R[n_h] = p_s_bh;
 
 		RFALSE(!n_h
@@ -2509,16 +2510,17 @@ int fix_nodes(int n_op_mode, struct tree
 			}
 
 			brelse(p_s_tb->L[i]);
-			p_s_tb->L[i] = NULL;
 			brelse(p_s_tb->R[i]);
-			p_s_tb->R[i] = NULL;
 			brelse(p_s_tb->FL[i]);
-			p_s_tb->FL[i] = NULL;
 			brelse(p_s_tb->FR[i]);
-			p_s_tb->FR[i] = NULL;
 			brelse(p_s_tb->CFL[i]);
-			p_s_tb->CFL[i] = NULL;
 			brelse(p_s_tb->CFR[i]);
+
+			p_s_tb->L[i] = NULL;
+			p_s_tb->R[i] = NULL;
+			p_s_tb->FL[i] = NULL;
+			p_s_tb->FR[i] = NULL;
+			p_s_tb->CFL[i] = NULL;
 			p_s_tb->CFR[i] = NULL;
 		}
 
--- a/fs/reiserfs/stree.c	2007-05-10 07:58:26.000000000 -0400
+++ b/fs/reiserfs/stree.c	2007-05-10 07:58:28.000000000 -0400
@@ -23,7 +23,6 @@
  * get_rkey
  * key_in_buffer
  * decrement_bcount
- * decrement_counters_in_path
  * reiserfs_check_path
  * pathrelse_and_restore
  * pathrelse
@@ -360,36 +359,6 @@ static inline int key_in_buffer(struct t
 	return 1;
 }
 
-inline void decrement_bcount(struct buffer_head *p_s_bh)
-{
-	if (p_s_bh) {
-		if (atomic_read(&(p_s_bh->b_count))) {
-			put_bh(p_s_bh);
-			return;
-		}
-		reiserfs_panic(NULL, "PAP-5070",
-		               "trying to free free buffer %b", p_s_bh);
-	}
-}
-
-/* Decrement b_count field of the all buffers in the path. */
-void decrement_counters_in_path(struct treepath *p_s_search_path)
-{
-	int n_path_offset = p_s_search_path->path_length;
-
-	RFALSE(n_path_offset < ILLEGAL_PATH_ELEMENT_OFFSET ||
-	       n_path_offset > EXTENDED_MAX_HEIGHT - 1,
-	       "PAP-5080: invalid path offset of %d", n_path_offset);
-
-	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {
-		struct buffer_head *bh;
-
-		bh = PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--);
-		decrement_bcount(bh);
-	}
-	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
-}
-
 int reiserfs_check_path(struct treepath *p)
 {
 	RFALSE(p->path_length != ILLEGAL_PATH_ELEMENT_OFFSET,
@@ -397,12 +366,11 @@ int reiserfs_check_path(struct treepath 
 	return 0;
 }
 
-/* Release all buffers in the path. Restore dirty bits clean
-** when preparing the buffer for the log
-**
-** only called from fix_nodes()
-*/
-void pathrelse_and_restore(struct super_block *s, struct treepath *p_s_search_path)
+/* Drop the reference to each buffer in a path and restore
+ * dirty bits clean when preparing the buffer for the log.
+ * This version should only be called from fix_nodes() */
+void pathrelse_and_restore(struct super_block *sb,
+                           struct treepath *p_s_search_path)
 {
 	int n_path_offset = p_s_search_path->path_length;
 
@@ -410,16 +378,15 @@ void pathrelse_and_restore(struct super_
 	       "clm-4000: invalid path offset");
 
 	while (n_path_offset > ILLEGAL_PATH_ELEMENT_OFFSET) {
-		reiserfs_restore_prepared_buffer(s,
-						 PATH_OFFSET_PBUFFER
-						 (p_s_search_path,
-						  n_path_offset));
-		brelse(PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--));
+		struct buffer_head *bh;
+		bh = PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--);
+		reiserfs_restore_prepared_buffer(sb, bh);
+		brelse(bh);
 	}
 	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
 }
 
-/* Release all buffers in the path. */
+/* Drop the reference to each buffer in a path */
 void pathrelse(struct treepath *p_s_search_path)
 {
 	int n_path_offset = p_s_search_path->path_length;
@@ -632,7 +599,7 @@ int search_by_key(struct super_block *p_
 	   we must be careful to release all nodes in a path before we either
 	   discard the path struct or re-use the path struct, as we do here. */
 
-	decrement_counters_in_path(p_s_search_path);
+	pathrelse(p_s_search_path);
 
 	right_neighbor_of_leaf_node = 0;
 
@@ -692,7 +659,7 @@ int search_by_key(struct super_block *p_
 			PROC_INFO_INC(p_s_sb, search_by_key_restarted);
 			PROC_INFO_INC(p_s_sb,
 				      sbk_restarted[expected_level - 1]);
-			decrement_counters_in_path(p_s_search_path);
+			pathrelse(p_s_search_path);
 
 			/* Get the root block number so that we can repeat the search
 			   starting from the root. */
@@ -1872,7 +1839,7 @@ int reiserfs_do_truncate(struct reiserfs
 		if (journal_transaction_should_end(th, 0) ||
 		    reiserfs_transaction_free_space(th) <= JOURNAL_FOR_FREE_BLOCK_AND_UPDATE_SD) {
 			int orig_len_alloc = th->t_blocks_allocated;
-			decrement_counters_in_path(&s_search_path);
+			pathrelse(&s_search_path);
 
 			if (update_timestamps) {
 				p_s_inode->i_mtime = p_s_inode->i_ctime =
