From: Jeff Mahoney <jeffm@suse.com>
Subject: novfs: 2.6.39 API update
Patch-mainline: probably never

 This patch updates novfs for the following API changes:
 - get_sb -> mount
 - BLK removal
 - path_lookup(.., PATH_PARENT, ...) -> kern_path_parent
 - dentry->d_count no longer being atomic

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/novfs/daemon.c  |   23 +++++------------------
 fs/novfs/inode.c   |   13 +++++--------
 fs/novfs/proc.c    |    1 -
 fs/novfs/profile.c |    8 ++++----
 fs/novfs/scope.c   |    1 -
 5 files changed, 14 insertions(+), 32 deletions(-)

--- a/fs/novfs/daemon.c
+++ b/fs/novfs/daemon.c
@@ -21,8 +21,8 @@
 #include <linux/timer.h>
 #include <linux/poll.h>
 #include <linux/pagemap.h>
-#include <linux/smp_lock.h>
 #include <linux/semaphore.h>
+#include <linux/sched.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 #include <linux/time.h>
@@ -1028,8 +1028,6 @@ long novfs_daemon_ioctl(struct file *fil
 	unsigned long cpylen;
 	struct novfs_schandle session_id;
 
-	lock_kernel(); /* needed? */
-
 	session_id = novfs_scope_get_sessionId(NULL);
 
 	switch (cmd) {
@@ -1049,10 +1047,8 @@ long novfs_daemon_ioctl(struct file *fil
 			char *buf;
 			io.length = 0;
 			cpylen = copy_from_user(&io, (char *)arg, sizeof(io));
-			if (io.length <= 0 || io.length > 1024) {
-				unlock_kernel();
+			if (io.length <= 0 || io.length > 1024)
 				return -EINVAL;
-			}
 			if (io.length) {
 				buf = kmalloc(io.length + 1, GFP_KERNEL);
 				if (buf) {
@@ -1086,9 +1082,6 @@ long novfs_daemon_ioctl(struct file *fil
 		}
 
 	}
-
-	unlock_kernel();
-
 	return (retCode);
 }
 
@@ -1352,8 +1345,6 @@ long novfs_daemon_lib_ioctl(struct file
 	void *handle = NULL;
 	unsigned long cpylen;
 
-	lock_kernel(); /* needed? */
-
 	dh = file->private_data;
 
 	DbgPrint("file=0x%p 0x%x 0x%p dh=0x%p", file, cmd, arg, dh);
@@ -1378,10 +1369,8 @@ long novfs_daemon_lib_ioctl(struct file
 				char *buf;
 				io.length = 0;
 				cpylen = copy_from_user(&io, (void *)arg, sizeof(io));
-				if (io.length <= 0 || io.length > 1024) {
-					unlock_kernel();
+				if (io.length <= 0 || io.length > 1024)
 					return -EINVAL;
-				}
 				if (io.length) {
 					buf = kmalloc(io.length + 1, GFP_KERNEL);
 					if (buf) {
@@ -1608,8 +1597,6 @@ long novfs_daemon_lib_ioctl(struct file
 		}
 	}
 
-	unlock_kernel();
-
 	return (retCode);
 }
 
@@ -1857,8 +1844,8 @@ static long local_unlink(const char *pat
 	struct nameidata nd;
 	struct inode *inode = NULL;
 
-	error = path_lookup(pathname, LOOKUP_PARENT, &nd);
-	DbgPrint("path_lookup %s error: %d\n", pathname, error);
+	error = kern_path_parent(pathname, &nd);
+	DbgPrint("kern_path_parent %s error: %d\n", pathname, error);
 	if (error)
 		return error;
 
--- a/fs/novfs/inode.c
+++ b/fs/novfs/inode.c
@@ -20,7 +20,6 @@
 #include <linux/mount.h>
 #include <linux/pagemap.h>
 #include <linux/string.h>
-#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/unistd.h>
 #include <asm/statfs.h>
@@ -56,8 +55,6 @@ struct inode_data {
 static unsigned long novfs_internal_hash(struct qstr *name);
 static int novfs_d_add(struct dentry *p, struct dentry *d, struct inode *i, int add);
 
-static int novfs_get_sb(struct file_system_type *Fstype, int Flags, const char *Dev_name, void *Data, struct vfsmount *Mnt);
-
 static void novfs_kill_sb(struct super_block *SB);
 
 /*
@@ -213,7 +210,6 @@ struct backing_dev_info novfs_backing_de
 	.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE,
 	.state = 0,
 	.capabilities = BDI_CAP_NO_WRITEBACK | BDI_CAP_MAP_COPY,
-	.unplug_io_fn = default_unplug_io_fn,
 };
 
 static struct address_space_operations novfs_aops = {
@@ -3431,10 +3427,11 @@ int novfs_fill_super(struct super_block
 	return (0);
 }
 
-static int novfs_get_sb(struct file_system_type *Fstype, int Flags, const char *Dev_name, void *Data, struct vfsmount *Mnt)
+static struct dentry *novfs_mount(struct file_system_type *fs_type, int flags,
+		       const char *dev_name, void *data)
 {
-	DbgPrint("Fstype=0x%x Dev_name=%s", Fstype, Dev_name);
-	return get_sb_nodev(Fstype, Flags, Data, novfs_fill_super, Mnt);
+	DbgPrint("Fstype=0x%x Dev_name=%s", fs_type, dev_name);
+	return mount_nodev(fs_type, flags, data, novfs_fill_super);
 }
 
 static void novfs_kill_sb(struct super_block *super)
@@ -3470,7 +3467,7 @@ ssize_t novfs_Control_write(struct file
 
 static struct file_system_type novfs_fs_type = {
 	.name = "novfs",
-	.get_sb = novfs_get_sb,
+	.mount = novfs_mount,
 	.kill_sb = novfs_kill_sb,
 	.owner = THIS_MODULE,
 };
--- a/fs/novfs/proc.c
+++ b/fs/novfs/proc.c
@@ -16,7 +16,6 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/proc_fs.h>
-#include <linux/smp_lock.h>
 
 #include "vfs.h"
 
--- a/fs/novfs/profile.c
+++ b/fs/novfs/profile.c
@@ -439,8 +439,7 @@ static void dump(struct dentry *parent,
 								     d->d_name.len,
 								     d->d_name.name,
 								     d->d_parent,
-								     atomic_read
-								     (&d->d_count), d->d_flags, d->d_subdirs.next, d->d_inode);
+								     d->d_count, d->d_flags, d->d_subdirs.next, d->d_inode);
 							}
 						}
 					}
@@ -466,8 +465,9 @@ static void dump(struct dentry *parent,
 						      "   d_subdirs: 0x%p%s\n"
 						      "   d_inode:   0x%p%s\n",
 						      d, path, d->d_parent,
-						      atomic_read(&d->d_count),
-						      d->d_flags, d->d_subdirs.next, sd, d->d_inode, inode_number);
+						      d->d_count, d->d_flags,
+						      d->d_subdirs.next, sd,
+						      d->d_inode, inode_number);
 					}
 
 					n = l;
--- a/fs/novfs/scope.c
+++ b/fs/novfs/scope.c
@@ -22,7 +22,6 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/synclink.h>
-#include <linux/smp_lock.h>
 #include <linux/semaphore.h>
 #include <linux/security.h>
 #include <linux/syscalls.h>
