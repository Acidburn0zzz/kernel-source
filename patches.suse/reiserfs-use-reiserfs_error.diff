From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH 16/35] reiserfs: use reiserfs_error()

 This patch makes many paths that are currently using warnings to handle
 the error.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

--

 fs/reiserfs/bitmap.c          |   57 +++++++++++++++++++++---------------------
 fs/reiserfs/file.c            |   14 +++++-----
 fs/reiserfs/inode.c           |   43 ++++++++++++++-----------------
 fs/reiserfs/lbalance.c        |   20 +++++++-------
 fs/reiserfs/namei.c           |   24 ++++++++---------
 fs/reiserfs/objectid.c        |    4 +-
 fs/reiserfs/stree.c           |   26 +++++++++----------
 fs/reiserfs/super.c           |   15 +++++------
 fs/reiserfs/tail_conversion.c |    6 ++--
 fs/reiserfs/xattr.c           |   21 +++++++--------
 10 files changed, 113 insertions(+), 117 deletions(-)

--- linux-2.6.22.orig/fs/reiserfs/bitmap.c
+++ linux-2.6.22/fs/reiserfs/bitmap.c
@@ -64,9 +64,9 @@ int is_reusable(struct super_block *s, b
 	unsigned int bmap_count = reiserfs_bmap_count(s);
 
 	if (block == 0 || block >= SB_BLOCK_COUNT(s)) {
-		reiserfs_warning(s, "vs-4010",
-		                 "block number is out of range %lu (%u)",
-				 block, SB_BLOCK_COUNT(s));
+		reiserfs_error(s, "vs-4010",
+		               "block number is out of range %lu (%u)",
+			       block, SB_BLOCK_COUNT(s));
 		return 0;
 	}
 
@@ -79,30 +79,30 @@ int is_reusable(struct super_block *s, b
 		b_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;
 		if (block >= bmap1 &&
 		    block <= bmap1 + bmap_count) {
-			reiserfs_warning(s, "vs-4019", "bitmap block %lu(%u) "
-			                 "can't be freed or reused",
-					 block, bmap_count);
+			reiserfs_error(s, "vs-4019", "bitmap block %lu(%u) "
+			               "can't be freed or reused",
+			               block, bmap_count);
 			return 0;
 		}
 	} else {
 		if (offset == 0) {
-			reiserfs_warning(s, "vs-4020", "bitmap block %lu(%u) "
-			                 "can't be freed or reused",
-					 block, bmap_count);
+			reiserfs_error(s, "vs-4020", "bitmap block %lu(%u) "
+			               "can't be freed or reused",
+			               block, bmap_count);
 			return 0;
 		}
 	}
 
 	if (bmap >= bmap_count) {
-		reiserfs_warning(s, "vs-4030", "bitmap for requested block "
-		                 "is out of range: block=%lu, bitmap_nr=%u",
-				 block, bmap);
+		reiserfs_error(s, "vs-4030", "bitmap for requested block "
+		               "is out of range: block=%lu, bitmap_nr=%u",
+		               block, bmap);
 		return 0;
 	}
 
 	if (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {
-		reiserfs_warning(s, "vs-4050", "this is root block (%u), "
-				 "it must be busy", SB_ROOT_BLOCK(s));
+		reiserfs_error(s, "vs-4050", "this is root block (%u), "
+		               "it must be busy", SB_ROOT_BLOCK(s));
 		return 0;
 	}
 
@@ -153,8 +153,8 @@ static int scan_bitmap_block(struct reis
 /* - I mean `a window of zero bits' as in description of this function - Zam. */
 
 	if (!bi) {
-		reiserfs_warning(s, "jdm-4055", "NULL bitmap info pointer "
-		                 "for bitmap %d", bmap_n);
+		reiserfs_error(s, "jdm-4055", "NULL bitmap info pointer "
+		               "for bitmap %d", bmap_n);
 		return 0;
 	}
 
@@ -402,8 +402,8 @@ static void _reiserfs_free_block(struct 
 	get_bit_address(s, block, &nr, &offset);
 
 	if (nr >= reiserfs_bmap_count(s)) {
-		reiserfs_warning(s, "vs-4075", "block %lu is out of range",
-		                 block);
+		reiserfs_error(s, "vs-4075", "block %lu is out of range",
+		               block);
 		return;
 	}
 
@@ -415,8 +415,8 @@ static void _reiserfs_free_block(struct 
 
 	/* clear bit for the given block in bit map */
 	if (!reiserfs_test_and_clear_le_bit(offset, bmbh->b_data)) {
-		reiserfs_warning(s, "vs-4080",
-		                 "block %lu: bit already cleared", block);
+		reiserfs_error(s, "vs-4080",
+		               "block %lu: bit already cleared", block);
 	}
 	apbi[nr].free_count++;
 	journal_mark_dirty(th, s, bmbh);
@@ -443,7 +443,7 @@ void reiserfs_free_block(struct reiserfs
 		return;
 
 	if (block > sb_block_count(REISERFS_SB(s)->s_rs)) {
-		reiserfs_panic(th->t_super, "bitmap-4072",
+		reiserfs_error(th->t_super, "bitmap-4072",
 		               "Trying to free block outside file system "
 			       "boundaries (%lu > %lu)",
 			       block, sb_block_count(REISERFS_SB(s)->s_rs));
@@ -475,8 +475,8 @@ static void __discard_prealloc(struct re
 	BUG_ON(!th->t_trans_id);
 #ifdef CONFIG_REISERFS_CHECK
 	if (ei->i_prealloc_count < 0)
-		reiserfs_warning(th->t_super, "zam-4001",
-		                 "inode has negative prealloc blocks count.");
+		reiserfs_error(th->t_super, "zam-4001",
+		               "inode has negative prealloc blocks count.");
 #endif
 	while (ei->i_prealloc_count > 0) {
 		reiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);
@@ -512,9 +512,9 @@ void reiserfs_discard_all_prealloc(struc
 				i_prealloc_list);
 #ifdef CONFIG_REISERFS_CHECK
 		if (!ei->i_prealloc_count) {
-			reiserfs_warning(th->t_super, "zam-4001",
-			                 "inode is in prealloc list but has "
-					 "no preallocated blocks.");
+			reiserfs_error(th->t_super, "zam-4001",
+			               "inode is in prealloc list but has "
+			               "no preallocated blocks.");
 		}
 #endif
 		__discard_prealloc(th, ei);
@@ -1291,8 +1291,9 @@ void reiserfs_cache_bitmap_metadata(stru
 			}
 		}
 	}
-	/* The first bit must ALWAYS be 1 */
-	BUG_ON(info->first_zero_hint == 0);
+	if (info->first_zero_hint == 0)
+		reiserfs_error(sb, "reiserfs-2025", "bitmap block %lu is "
+		               "corrupted: first bit must be 1", bh->b_blocknr);
 }
 
 struct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,
--- linux-2.6.22.orig/fs/reiserfs/file.c
+++ linux-2.6.22/fs/reiserfs/file.c
@@ -395,7 +395,7 @@ static int reiserfs_allocate_blocks_for_
 					if (res != ITEM_NOT_FOUND) {
 						/* item should not exist, otherwise we have error */
 						if (res != -ENOSPC) {
-							reiserfs_warning(inode->
+							reiserfs_error(inode->
 									 i_sb,
 									 "green-9008",
 									 "search_by_key (%K) returned %d",
@@ -412,7 +412,7 @@ static int reiserfs_allocate_blocks_for_
 								 inode,
 								 (char *)zeros);
 				} else {
-					reiserfs_panic(inode->i_sb,
+					reiserfs_error(inode->i_sb,
 					               "green-9011",
 						       "Unexpected key type %K",
 						       &key);
@@ -600,11 +600,11 @@ static int reiserfs_allocate_blocks_for_
 				/* Well, if we have found such item already, or some error
 				   occured, we need to warn user and return error */
 				if (res != -ENOSPC) {
-					reiserfs_warning(inode->i_sb,
-							 "green-9009",
-							 "search_by_key (%K) "
-							 "returned %d", &key,
-							 res);
+					reiserfs_error(inode->i_sb,
+					               "green-9009",
+					               "search_by_key (%K) "
+					               "returned %d", &key,
+					               res);
 				}
 				res = -EIO;
 				goto error_exit_free_blocks;
--- linux-2.6.22.orig/fs/reiserfs/inode.c
+++ linux-2.6.22/fs/reiserfs/inode.c
@@ -837,11 +837,11 @@ int reiserfs_get_block(struct inode *ino
 							  tail_offset);
 				if (retval) {
 					if (retval != -ENOSPC)
-						reiserfs_warning(inode->i_sb,
-								 "clm-6004",
-								 "convert tail failed inode %lu, error %d",
-								 inode->i_ino,
-								 retval);
+						reiserfs_error(inode->i_sb,
+						               "clm-6004",
+						               "convert tail failed inode %lu, error %d",
+						               inode->i_ino,
+						               retval);
 					if (allocated_block_nr) {
 						/* the bitmap, the super, and the stat data == 3 */
 						if (!th)
@@ -1327,10 +1327,9 @@ void reiserfs_update_sd_size(struct reis
 		/* look for the object's stat data */
 		retval = search_item(inode->i_sb, &key, &path);
 		if (retval == IO_ERROR) {
-			reiserfs_warning(inode->i_sb, "vs-13050",
-					 "i/o failure occurred trying to "
-					 "update %K stat data",
-					 &key);
+			reiserfs_error(inode->i_sb, "vs-13050",
+			               "i/o failure occurred trying to "
+			               "update %K stat data", &key);
 			return;
 		}
 		if (retval == ITEM_NOT_FOUND) {
@@ -1419,9 +1418,9 @@ void reiserfs_read_locked_inode(struct i
 	/* look for the object's stat data */
 	retval = search_item(inode->i_sb, &key, &path_to_sd);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(inode->i_sb, "vs-13070",
-				 "i/o failure occurred trying to find "
-				 "stat data of %K", &key);
+		reiserfs_error(inode->i_sb, "vs-13070",
+		               "i/o failure occurred trying to find "
+		               "stat data of %K", &key);
 		reiserfs_make_bad_inode(inode);
 		return;
 	}
@@ -1690,8 +1689,8 @@ static int reiserfs_new_directory(struct
 	/* look for place in the tree for new item */
 	retval = search_item(sb, &key, path);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(sb, "vs-13080",
-				 "i/o failure occurred creating new directory");
+		reiserfs_error(sb, "vs-13080",
+		               "i/o failure occurred creating new directory");
 		return -EIO;
 	}
 	if (retval == ITEM_FOUND) {
@@ -1730,8 +1729,8 @@ static int reiserfs_new_symlink(struct r
 	/* look for place in the tree for new item */
 	retval = search_item(sb, &key, path);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(sb, "vs-13080",
-				 "i/o failure occurred creating new symlink");
+		reiserfs_error(sb, "vs-13080",
+		               "i/o failure occurred creating new symlink");
 		return -EIO;
 	}
 	if (retval == ITEM_FOUND) {
@@ -2051,10 +2050,8 @@ static int grab_tail_page(struct inode *
 		 ** I've screwed up the code to find the buffer, or the code to
 		 ** call prepare_write
 		 */
-		reiserfs_warning(p_s_inode->i_sb, "clm-6000",
-		                 "error reading block %lu on dev %s",
-				 bh->b_blocknr,
-				 reiserfs_bdevname(p_s_inode->i_sb));
+		reiserfs_error(p_s_inode->i_sb, "clm-6000",
+		               "error reading block %lu", bh->b_blocknr);
 		error = -EIO;
 		goto unlock;
 	}
@@ -2096,9 +2093,9 @@ int reiserfs_truncate_file(struct inode 
 			// and get_block_create_0 could not find a block to read in,
 			// which is ok.
 			if (error != -ENOENT)
-				reiserfs_warning(p_s_inode->i_sb, "clm-6001",
-				                 "grab_tail_page failed %d",
-						 error);
+				reiserfs_error(p_s_inode->i_sb, "clm-6001",
+				               "grab_tail_page failed %d",
+				               error);
 			page = NULL;
 			bh = NULL;
 		}
--- linux-2.6.22.orig/fs/reiserfs/lbalance.c
+++ linux-2.6.22/fs/reiserfs/lbalance.c
@@ -1291,17 +1291,17 @@ void leaf_paste_entries(struct buffer_in
 			prev = (i != 0) ? deh_location(&(deh[i - 1])) : 0;
 
 			if (prev && prev <= deh_location(&(deh[i])))
-				reiserfs_warning(NULL, "vs-10240",
-				                 "directory item (%h) "
-						 "corrupted (prev %a, "
-						 "cur(%d) %a)",
-						 ih, deh + i - 1, i, deh + i);
+				reiserfs_error(sb_from_bi(bi), "vs-10240",
+				               "directory item (%h) "
+				               "corrupted (prev %a, "
+				               "cur(%d) %a)",
+				               ih, deh + i - 1, i, deh + i);
 			if (next && next >= deh_location(&(deh[i])))
-				reiserfs_warning(NULL, "vs-10250",
-				                 "directory item (%h) "
-						 "corrupted (cur(%d) %a, "
-						 "next %a)",
-						 ih, i, deh + i, deh + i + 1);
+				reiserfs_error(sb_from_bi(bi), "vs-10250",
+				               "directory item (%h) "
+				               "corrupted (cur(%d) %a, "
+				               "next %a)",
+				               ih, i, deh + i, deh + i + 1);
 		}
 	}
 #endif
--- linux-2.6.22.orig/fs/reiserfs/namei.c
+++ linux-2.6.22/fs/reiserfs/namei.c
@@ -120,8 +120,8 @@ int search_by_entry_key(struct super_blo
 	switch (retval) {
 	case ITEM_NOT_FOUND:
 		if (!PATH_LAST_POSITION(path)) {
-			reiserfs_warning(sb, "vs-7000", "search_by_key "
-			                 "returned item position == 0");
+			reiserfs_error(sb, "vs-7000", "search_by_key "
+			               "returned item position == 0");
 			pathrelse(path);
 			return IO_ERROR;
 		}
@@ -135,7 +135,7 @@ int search_by_entry_key(struct super_blo
 
 	default:
 		pathrelse(path);
-		reiserfs_warning(sb, "vs-7002", "no path to here");
+		reiserfs_error(sb, "vs-7002", "no path to here");
 		return IO_ERROR;
 	}
 
@@ -298,7 +298,7 @@ static int reiserfs_find_entry(struct in
 		    search_by_entry_key(dir->i_sb, &key_to_search,
 					path_to_entry, de);
 		if (retval == IO_ERROR) {
-			reiserfs_warning(dir->i_sb, "zam-7001", "io error");
+			reiserfs_error(dir->i_sb, "zam-7001", "io error");
 			return IO_ERROR;
 		}
 
@@ -490,9 +490,9 @@ static int reiserfs_add_entry(struct rei
 		}
 
 		if (retval != NAME_FOUND) {
-			reiserfs_warning(dir->i_sb, "zam-7002",
-			                 "reiserfs_find_entry() returned "
-					 "unexpected value (%d)", retval);
+			reiserfs_error(dir->i_sb, "zam-7002",
+			               "reiserfs_find_entry() returned "
+			               "unexpected value (%d)", retval);
 		}
 
 		return -EEXIST;
@@ -902,9 +902,9 @@ static int reiserfs_rmdir(struct inode *
 		goto end_rmdir;
 
 	if (inode->i_nlink != 2 && inode->i_nlink != 1)
-		reiserfs_warning(inode->i_sb, "reiserfs-7040",
-		                 "empty directory has nlink != 2 (%d)",
-				 inode->i_nlink);
+		reiserfs_error(inode->i_sb, "reiserfs-7040",
+		               "empty directory has nlink != 2 (%d)",
+		               inode->i_nlink);
 
 	clear_nlink(inode);
 	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;
@@ -1495,8 +1495,8 @@ static int reiserfs_rename(struct inode 
 	if (reiserfs_cut_from_item
 	    (&th, &old_entry_path, &(old_de.de_entry_key), old_dir, NULL,
 	     0) < 0)
-		reiserfs_warning(old_dir->i_sb, "vs-7060",
-		                 "couldn't not cut old name. Fsck later?");
+		reiserfs_error(old_dir->i_sb, "vs-7060",
+		               "couldn't not cut old name. Fsck later?");
 
 	old_dir->i_size -= DEH_SIZE + old_de.de_entrylen;
 
--- linux-2.6.22.orig/fs/reiserfs/objectid.c
+++ linux-2.6.22/fs/reiserfs/objectid.c
@@ -160,8 +160,8 @@ void reiserfs_release_objectid(struct re
 		i += 2;
 	}
 
-	reiserfs_warning(s, "vs-15011", "tried to free free object id (%lu)",
-			 (long unsigned)objectid_to_release);
+	reiserfs_error(s, "vs-15011", "tried to free free object id (%lu)",
+	               (long unsigned)objectid_to_release);
 }
 
 int reiserfs_convert_objectid_map_v1(struct super_block *s)
--- linux-2.6.22.orig/fs/reiserfs/stree.c
+++ linux-2.6.22/fs/reiserfs/stree.c
@@ -720,9 +720,9 @@ int search_by_key(struct super_block *p_
 		// make sure, that the node contents look like a node of
 		// certain level
 		if (!is_tree_node(p_s_bh, expected_level)) {
-			reiserfs_warning(p_s_sb, "vs-5150",
-					 "invalid format found in block %ld. "
-					 "Fsck?", p_s_bh->b_blocknr);
+			reiserfs_error(p_s_sb, "vs-5150",
+			               "invalid format found in block %ld. "
+			               "Fsck?", p_s_bh->b_blocknr);
 			pathrelse(p_s_search_path);
 			return IO_ERROR;
 		}
@@ -1335,9 +1335,9 @@ void reiserfs_delete_solid_item(struct r
 	while (1) {
 		retval = search_item(th->t_super, &cpu_key, &path);
 		if (retval == IO_ERROR) {
-			reiserfs_warning(th->t_super, "vs-5350",
-					 "i/o failure occurred trying "
-					 "to delete %K", &cpu_key);
+			reiserfs_error(th->t_super, "vs-5350",
+			               "i/o failure occurred trying "
+			               "to delete %K", &cpu_key);
 			break;
 		}
 		if (retval != ITEM_FOUND) {
@@ -1740,7 +1740,7 @@ static void truncate_directory(struct re
 {
 	BUG_ON(!th->t_trans_id);
 	if (inode->i_nlink)
-		reiserfs_warning(inode->i_sb, "vs-5655", "link count != 0");
+		reiserfs_error(inode->i_sb, "vs-5655", "link count != 0");
 
 	set_le_key_k_offset(KEY_FORMAT_3_5, INODE_PKEY(inode), DOT_OFFSET);
 	set_le_key_k_type(KEY_FORMAT_3_5, INODE_PKEY(inode), TYPE_DIRENTRY);
@@ -1793,16 +1793,16 @@ int reiserfs_do_truncate(struct reiserfs
 	    search_for_position_by_key(p_s_inode->i_sb, &s_item_key,
 				       &s_search_path);
 	if (retval == IO_ERROR) {
-		reiserfs_warning(p_s_inode->i_sb, "vs-5657",
-				 "i/o failure occurred trying to truncate %K",
-				 &s_item_key);
+		reiserfs_error(p_s_inode->i_sb, "vs-5657",
+		               "i/o failure occurred trying to truncate %K",
+		               &s_item_key);
 		err = -EIO;
 		goto out;
 	}
 	if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
-		reiserfs_warning(p_s_inode->i_sb, "PAP-5660",
-				 "wrong result %d of search for %K", retval,
-				 &s_item_key);
+		reiserfs_error(p_s_inode->i_sb, "PAP-5660",
+		               "wrong result %d of search for %K", retval,
+		               &s_item_key);
 
 		err = -EIO;
 		goto out;
--- linux-2.6.22.orig/fs/reiserfs/super.c
+++ linux-2.6.22/fs/reiserfs/super.c
@@ -190,9 +190,8 @@ static int finish_unfinished(struct supe
 	while (!retval) {
 		retval = search_item(s, &max_cpu_key, &path);
 		if (retval != ITEM_NOT_FOUND) {
-			reiserfs_warning(s, "vs-2140",
-			                 "search_by_key returned %d",
-					 retval);
+			reiserfs_error(s, "vs-2140",
+			               "search_by_key returned %d", retval);
 			break;
 		}
 
@@ -362,9 +361,9 @@ void add_save_link(struct reiserfs_trans
 	retval = search_item(inode->i_sb, &key, &path);
 	if (retval != ITEM_NOT_FOUND) {
 		if (retval != -ENOSPC)
-			reiserfs_warning(inode->i_sb, "vs-2100",
-					 "search_by_key (%K) returned %d", &key,
-					 retval);
+			reiserfs_error(inode->i_sb, "vs-2100",
+			               "search_by_key (%K) returned %d", &key,
+			               retval);
 		pathrelse(&path);
 		return;
 	}
@@ -377,8 +376,8 @@ void add_save_link(struct reiserfs_trans
 	    reiserfs_insert_item(th, &path, &key, &ih, NULL, (char *)&link);
 	if (retval) {
 		if (retval != -ENOSPC)
-			reiserfs_warning(inode->i_sb, "vs-2120",
-			                 "insert_item returned %d", retval);
+			reiserfs_error(inode->i_sb, "vs-2120",
+			               "insert_item returned %d", retval);
 	} else {
 		if (truncate)
 			REISERFS_I(inode)->i_flags |=
--- linux-2.6.22.orig/fs/reiserfs/tail_conversion.c
+++ linux-2.6.22/fs/reiserfs/tail_conversion.c
@@ -48,9 +48,9 @@ int direct2indirect(struct reiserfs_tran
 
 	// FIXME: we could avoid this 
 	if (search_for_position_by_key(sb, &end_key, path) == POSITION_FOUND) {
-		reiserfs_warning(sb, "PAP-14030",
-				 "pasted or inserted byte exists in "
-				 "the tree %K. Use fsck to repair.", &end_key);
+		reiserfs_error(sb, "PAP-14030",
+		               "pasted or inserted byte exists in "
+		               "the tree %K. Use fsck to repair.", &end_key);
 		pathrelse(path);
 		return -EIO;
 	}
--- linux-2.6.22.orig/fs/reiserfs/xattr.c
+++ linux-2.6.22/fs/reiserfs/xattr.c
@@ -278,8 +278,8 @@ static int __xattr_readdir(struct file *
 		ih = de.de_ih;
 
 		if (!is_direntry_le_ih(ih)) {
-			reiserfs_warning(inode->i_sb, "jdm-20000",
-			                 "not direntry %h", ih);
+			reiserfs_error(inode->i_sb, "jdm-20000",
+			               "not direntry %h", ih);
 			break;
 		}
 		copy_item_head(&tmp_ih, ih);
@@ -674,15 +674,14 @@ __reiserfs_xattr_del(struct dentry *xadi
 		goto out_file;
 
 	if (!is_reiserfs_priv_object(dentry->d_inode)) {
-		reiserfs_warning(dir->i_sb, "jdm-20003",
-		                 "OID %08x [%.*s/%.*s] doesn't have "
-				 "priv flag set [parent is %sset].",
-				 le32_to_cpu(INODE_PKEY(dentry->d_inode)->
-					     k_objectid), xadir->d_name.len,
-				 xadir->d_name.name, namelen, name,
-				 is_reiserfs_priv_object(xadir->
-							 d_inode) ? "" :
-				 "not ");
+		reiserfs_error(dir->i_sb, "jdm-20003",
+		               "OID %08x [%.*s/%.*s] doesn't have "
+		               "priv flag set [parent is %sset].",
+		               le32_to_cpu(INODE_PKEY(dentry->d_inode)->
+		                           k_objectid), xadir->d_name.len,
+		               xadir->d_name.name, namelen, name,
+		               is_reiserfs_priv_object(xadir-> d_inode) ? "" :
+		               "not ");
 		dput(dentry);
 		return -EIO;
 	}
