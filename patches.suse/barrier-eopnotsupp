Sometimes barriers fail asynchronously (after the submit_bh call).
This patch changes both ext3 and reiserfs to handle that without
mistaking the barrier failures for io errors.

Index: linux.t/fs/buffer.c
===================================================================
--- linux.t.orig/fs/buffer.c	2004-08-11 15:53:19.241908696 -0400
+++ linux.t/fs/buffer.c	2004-08-11 15:54:56.935057080 -0400
@@ -2885,6 +2885,10 @@ int sync_dirty_buffer(struct buffer_head
 		bh->b_end_io = end_buffer_write_sync;
 		ret = submit_bh(WRITE, bh);
 		wait_on_buffer(bh);
+		if (buffer_eopnotsupp(bh)) {
+			clear_buffer_eopnotsupp(bh);
+			ret = -EOPNOTSUPP;
+		}
 		if (!ret && !buffer_uptodate(bh))
 			ret = -EIO;
 	} else {
Index: linux.t/fs/jbd/commit.c
===================================================================
--- linux.t.orig/fs/jbd/commit.c	2004-08-11 15:53:19.246907936 -0400
+++ linux.t/fs/jbd/commit.c	2004-08-11 15:54:56.937056776 -0400
@@ -658,6 +658,7 @@ wait_for_iobuf:
 
 			/* And try again, without the barrier */
 			clear_buffer_ordered(bh);
+			set_buffer_uptodate(bh);
 			set_buffer_dirty(bh);
 			ret = sync_dirty_buffer(bh);
 		}
Index: linux.t/fs/reiserfs/journal.c
===================================================================
--- linux.t.orig/fs/reiserfs/journal.c	2004-08-11 15:49:40.606146384 -0400
+++ linux.t/fs/reiserfs/journal.c	2004-08-11 15:59:10.178558216 -0400
@@ -655,6 +655,17 @@ static int submit_barrier_buffer(struct 
     return submit_bh(WRITE_BARRIER, bh) ;
 }
 
+static void check_barrier_completion(struct super_block *s, 
+                                     struct buffer_head *bh) {
+    if (buffer_eopnotsupp(bh)) {
+	clear_buffer_eopnotsupp(bh);
+	disable_barrier(s);
+	set_buffer_uptodate(bh);
+	set_buffer_dirty(bh);
+	sync_dirty_buffer(bh);
+    }
+}
+
 #define CHUNK_SIZE 32
 struct buffer_chunk {
     struct buffer_head *bh[CHUNK_SIZE];
@@ -1032,6 +1043,8 @@ static int flush_commit_list(struct supe
   } else
       wait_on_buffer(jl->j_commit_bh);
 
+  check_barrier_completion(s, jl->j_commit_bh);
+
   if (!buffer_uptodate(jl->j_commit_bh)) {
     reiserfs_panic(s, "journal-615: buffer write failed\n") ;
   }
@@ -1142,6 +1155,7 @@ static int _update_journal_header_block(
 	    goto sync;
 	}
 	wait_on_buffer(SB_JOURNAL(p_s_sb)->j_header_bh);
+	check_barrier_completion(p_s_sb, SB_JOURNAL(p_s_sb)->j_header_bh);
     } else {
 sync:
 	set_buffer_dirty(SB_JOURNAL(p_s_sb)->j_header_bh) ;
Index: linux.t/include/linux/buffer_head.h
===================================================================
--- linux.t.orig/include/linux/buffer_head.h	2004-08-11 15:53:19.248907632 -0400
+++ linux.t/include/linux/buffer_head.h	2004-08-11 15:54:56.945055560 -0400
@@ -114,6 +114,7 @@ BUFFER_FNS(Delay, delay)
 BUFFER_FNS(Boundary, boundary)
 BUFFER_FNS(Write_EIO, write_io_error)
 BUFFER_FNS(Ordered, ordered)
+BUFFER_FNS(Eopnotsupp, eopnotsupp)
 
 #define bh_offset(bh)		((unsigned long)(bh)->b_data & ~PAGE_MASK)
 #define touch_buffer(bh)	mark_page_accessed(bh->b_page)
