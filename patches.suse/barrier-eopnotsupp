Sometimes barriers fail asynchronously (after the submit_bh call).
This patch changes both ext3 and reiserfs to handle that without
mistaking the barrier failures for io errors.

Index: linux.t/fs/buffer.c
===================================================================
--- linux.t.orig/fs/buffer.c	2004-06-08 14:14:43.000000000 -0400
+++ linux.t/fs/buffer.c	2004-06-09 16:34:53.000000000 -0400
@@ -2905,6 +2905,10 @@ int sync_dirty_buffer(struct buffer_head
 		bh->b_end_io = end_buffer_write_sync;
 		ret = submit_bh(WRITE, bh);
 		wait_on_buffer(bh);
+		if (buffer_eopnotsupp(bh)) {
+			clear_buffer_eopnotsupp(bh);
+			ret = -EOPNOTSUPP;
+		}
 		if (!ret && !buffer_uptodate(bh))
 			ret = -EIO;
 	} else {
Index: linux.t/fs/jbd/commit.c
===================================================================
--- linux.t.orig/fs/jbd/commit.c	2004-06-08 14:14:36.000000000 -0400
+++ linux.t/fs/jbd/commit.c	2004-06-09 16:41:48.000000000 -0400
@@ -667,6 +667,7 @@ wait_for_iobuf:
 
 			/* And try again, without the barrier */
 			clear_buffer_ordered(bh);
+			set_buffer_uptodate(bh);
 			set_buffer_dirty(bh);
 			ret = sync_dirty_buffer(bh);
 		}
Index: linux.t/fs/reiserfs/journal.c
===================================================================
--- linux.t.orig/fs/reiserfs/journal.c	2004-06-08 14:14:49.000000000 -0400
+++ linux.t/fs/reiserfs/journal.c	2004-06-09 16:34:54.000000000 -0400
@@ -641,6 +641,17 @@ static int submit_barrier_buffer(struct 
     return submit_bh(WRITE_BARRIER, bh) ;
 }
 
+static void check_barrier_completion(struct super_block *s, 
+                                     struct buffer_head *bh) {
+    if (buffer_eopnotsupp(bh)) {
+	clear_buffer_eopnotsupp(bh);
+	disable_barrier(s);
+	set_buffer_uptodate(bh);
+	set_buffer_dirty(bh);
+	sync_dirty_buffer(bh);
+    }
+}
+
 #define CHUNK_SIZE 32
 struct buffer_chunk {
     struct buffer_head *bh[CHUNK_SIZE];
@@ -1033,6 +1044,8 @@ static int flush_commit_list(struct supe
   } else
       wait_on_buffer(jl->j_commit_bh);
 
+  check_barrier_completion(s, jl->j_commit_bh);
+
   /* If there was a write error in the journal - we can't commit this
    * transaction - it will be invalid and, if successful, will just end
    * up propogating the write error out to the filesystem. */
@@ -1164,6 +1177,7 @@ static int _update_journal_header_block(
 	    goto sync;
 	}
 	wait_on_buffer(journal->j_header_bh);
+	check_barrier_completion(p_s_sb, journal->j_header_bh);
     } else {
 sync:
 	set_buffer_dirty(journal->j_header_bh) ;
Index: linux.t/include/linux/buffer_head.h
===================================================================
--- linux.t.orig/include/linux/buffer_head.h	2004-06-08 14:14:36.000000000 -0400
+++ linux.t/include/linux/buffer_head.h	2004-06-09 16:34:54.000000000 -0400
@@ -121,6 +121,7 @@ BUFFER_FNS(Delay, delay)
 BUFFER_FNS(Boundary, boundary)
 BUFFER_FNS(Write_EIO, write_io_error)
 BUFFER_FNS(Ordered, ordered)
+BUFFER_FNS(Eopnotsupp, eopnotsupp)
 
 #define bh_offset(bh)		((unsigned long)(bh)->b_data & ~PAGE_MASK)
 #define touch_buffer(bh)	mark_page_accessed(bh->b_page)
