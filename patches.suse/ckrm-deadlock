bug 40084, fixes a deadlock and some performance overheads in ckrm

Index: linux.t/include/linux/ckrm_rc.h
===================================================================
--- linux.t.orig/include/linux/ckrm_rc.h	2004-05-12 22:39:10.667112824 -0400
+++ linux.t/include/linux/ckrm_rc.h	2004-05-12 22:39:12.861779184 -0400
@@ -194,7 +194,7 @@
 typedef struct ckrm_core_class {
 	struct ckrm_classtype *classtype; // what type does this core class belong to
         void* res_class[CKRM_MAX_RES_CTLRS];                 // pointer to array of resource classes
-  	spinlock_t ckrm_lock;             // to protect the list and the array above
+  	spinlock_t class_lock;             // to protect the list and the array above
 	struct list_head objlist;         // generic list for any object list to be maintained by class
 	struct list_head clslist;         // to link up all classes in a single list type wrt to type
 	struct dentry  *dentry;           // dentry of inode in the RCFS
@@ -203,14 +203,15 @@
 	rwlock_t hnode_rwlock; // rw_clock protecting the hnode above.
 	atomic_t refcnt;
 	const char *name;
+	int delayed;                      // core deletion delayed because of race conditions
 } ckrm_core_class_t;
 
 /* type coerce between derived class types and ckrm core class type */
 #define class_type(type,coreptr)   container_of(coreptr,type,core)
 #define class_core(clsptr)         (&(clsptr)->core)
 /* locking classes */
-#define class_lock(coreptr)        spin_lock(&(coreptr)->ckrm_lock)
-#define class_unlock(coreptr)      spin_unlock(&(coreptr)->ckrm_lock)
+#define class_lock(coreptr)        spin_lock(&(coreptr)->class_lock)
+#define class_unlock(coreptr)      spin_unlock(&(coreptr)->class_lock)
 /* what type is a class of ISA */
 #define class_isa(clsptr)          (class_core(clsptr)->classtype)
 
Index: linux.t/kernel/ckrm/ckrm.c
===================================================================
--- linux.t.orig/kernel/ckrm/ckrm.c	2004-05-12 22:39:10.664113280 -0400
+++ linux.t/kernel/ckrm/ckrm.c	2004-05-12 22:39:12.863778880 -0400
@@ -58,6 +58,7 @@
 struct rcfs_functions rcfs_fn ;
 EXPORT_SYMBOL(rcfs_fn);
 
+
 /**************************************************************************
  *                   Helper Functions                                     *
  **************************************************************************/
@@ -246,7 +247,7 @@
 		return;
 	}
 	
-	spin_lock(&child->ckrm_lock);
+	class_lock(child);
 	INIT_LIST_HEAD(&cnode->children);
 	INIT_LIST_HEAD(&cnode->siblings);
 
@@ -265,7 +266,7 @@
 		}
 	}
 	cnode->parent = parent;
-	spin_unlock(&child->ckrm_lock);
+	class_unlock(child);
 	return;
 }
 
@@ -291,17 +292,17 @@
 
 	pnode = &parent->hnode;
 
-	spin_lock(&child->ckrm_lock);
+	class_lock(child);
 	/* ensure that the node does not have children */
 	if (!list_empty(&cnode->children)) {
-		spin_unlock(&child->ckrm_lock);
+		class_unlock(child);
 		return 0;
 	}
 	write_lock(&parent->hnode_rwlock);
 	list_del(&cnode->siblings);
 	write_unlock(&parent->hnode_rwlock);
 	cnode->parent = NULL;
-	spin_unlock(&child->ckrm_lock);
+	class_unlock(child);
 	return 1;
 }
 
@@ -413,6 +414,9 @@
  *
  */
 
+#define CLS_DEBUG(fmt, args...) do { /* printk("%s: " fmt, __FUNCTION__ , ## args); */ } while (0)
+
+
 int
 ckrm_init_core_class(struct ckrm_classtype  *clstype,
 		     struct ckrm_core_class *dcore,
@@ -424,7 +428,7 @@
 
 	// Hubertus .. how is this used in initialization 
 
-	printk("ckrm_init_core_class: name %s => %p\n", name?name:"default",dcore);
+	CLS_DEBUG("name %s => %p\n", name?name:"default",dcore);
 	
 	if ((dcore != clstype->default_class) && ( !ckrm_is_core_valid(parent))) {
 		printk("error not a valid parent %p\n", parent);
@@ -444,8 +448,9 @@
 	dcore->classtype    = clstype;
 	dcore->magic        = CKRM_CORE_MAGIC;
 	dcore->name         = name;
-	dcore->ckrm_lock    = SPIN_LOCK_UNLOCKED;
+	dcore->class_lock   = SPIN_LOCK_UNLOCKED;
 	dcore->hnode_rwlock = RW_LOCK_UNLOCKED;
+	dcore->delayed      = 0;
 
 	atomic_set(&dcore->refcnt, 0);
 	write_lock(&ckrm_class_lock);
@@ -510,8 +515,8 @@
 	struct ckrm_classtype *clstype = core->classtype;
 	struct ckrm_core_class *parent = core->hnode.parent;
 	
-	printk("%s: core=%p:%s parent=%p:%s\n",__FUNCTION__,core,core->name,parent,parent->name);
-	if (core->magic == 0) {
+	CLS_DEBUG("core=%p:%s parent=%p:%s\n",core,core->name,parent,parent->name);
+	if (core->delayed) {
 		/* this core was marked as late */
 		printk("class <%s> finally deleted %lu\n",core->name,jiffies);
 	}
@@ -556,9 +561,9 @@
 
 	/* need to make sure that the classgot really dropped */
 	if (atomic_read(&core->refcnt) != 1) {
-		printk("class <%s> deletion delayed refcnt=%d jif=%ld\n",
-		       core->name,atomic_read(&core->refcnt),jiffies);
-		core->magic = 0;  /* just so we have a ref point */
+		CLS_DEBUG("class <%s> deletion delayed refcnt=%d jif=%ld\n",
+				core->name,atomic_read(&core->refcnt),jiffies);
+		core->delayed = 1;  /* just so we have a ref point */
 	}
 	ckrm_core_drop(core);
 	return 0;
@@ -968,7 +973,6 @@
 	printk("CKRM Initialization done\n");
 }
 
-
 EXPORT_SYMBOL(ckrm_register_engine);
 EXPORT_SYMBOL(ckrm_unregister_engine);
 
Index: linux.t/kernel/ckrm/ckrm_sockc.c
===================================================================
--- linux.t.orig/kernel/ckrm/ckrm_sockc.c	2004-05-12 22:39:10.666112976 -0400
+++ linux.t/kernel/ckrm/ckrm_sockc.c	2004-05-12 22:40:20.818448200 -0400
@@ -168,12 +168,12 @@
 	if ((resid < 0) || (resid >= CKRM_MAX_RES_CTLRS) || ((rcbs = core->classtype->res_ctlrs[resid]) == NULL)) 
 		return;
 
-	spin_lock(&core->ckrm_lock);
+	class_lock(core);
 	list_for_each_entry(ns, &core->objlist, ckrm_link) {
 		if (rcbs->change_resclass)
 			(*rcbs->change_resclass)(ns, NULL, core->res_class[resid]);
 	}
-	spin_unlock(&core->ckrm_lock);
+	class_unlock(core);
 }
 
 
Index: linux.t/kernel/ckrm/ckrm_tc.c
===================================================================
--- linux.t.orig/kernel/ckrm/ckrm_tc.c	2004-05-12 22:39:10.665113128 -0400
+++ linux.t/kernel/ckrm/ckrm_tc.c	2004-05-12 22:39:12.867778272 -0400
@@ -50,6 +50,11 @@
 
 #include <linux/ckrm_tc.h>
 
+
+
+#define TC_DEBUG(fmt, args...) do { /* printk("%s: " fmt, __FUNCTION__ , ## args); */ } while (0)
+
+
 static struct ckrm_task_class  taskclass_dflt_class = {
 };
 
@@ -155,8 +160,8 @@
 		ckrm_task_unlock(tsk);
 		if (newcls) {
 			/* compensate for previous grab */
-			printk("ckrm_set_taskclass(%s:%d): Race-condition caught <%s> %d\n",
-				tsk->comm,tsk->pid,class_core(newcls)->name,event);
+			TC_DEBUG("(%s:%d): Race-condition caught <%s> %d\n",
+				 tsk->comm,tsk->pid,class_core(newcls)->name,event);
 			ckrm_core_drop(class_core(newcls));
 		}
 		return;
@@ -201,14 +206,18 @@
 	ckrm_task_unlock(tsk);
 
 	clstype = class_isa(newcls);                      // Hubertus .. can hardcode ckrm_CT_taskclass
-	for (i = 0; i < clstype->max_resid; i++) {
-		atomic_inc(&clstype->nr_resusers[i]);
-		old_res_class = curcls ? class_core(curcls)->res_class[i] : NULL;
-		new_res_class = newcls ? class_core(newcls)->res_class[i] : NULL;
-		rcbs = clstype->res_ctlrs[i];
-		if (rcbs && rcbs->change_resclass && (old_res_class != new_res_class)) 
-			(*rcbs->change_resclass)(tsk, old_res_class, new_res_class);
-		atomic_dec(&clstype->nr_resusers[i]);
+	if (clstype->bit_res_ctlrs) {   // avoid running through the entire list if non is registered
+		for (i = 0; i < clstype->max_resid; i++) {
+			if (clstype->res_ctlrs[i] == NULL) 
+				continue;
+			atomic_inc(&clstype->nr_resusers[i]);
+			old_res_class = curcls ? class_core(curcls)->res_class[i] : NULL;
+			new_res_class = newcls ? class_core(newcls)->res_class[i] : NULL;
+			rcbs = clstype->res_ctlrs[i];
+			if (rcbs && rcbs->change_resclass && (old_res_class != new_res_class)) 
+				(*rcbs->change_resclass)(tsk, old_res_class, new_res_class);
+			atomic_dec(&clstype->nr_resusers[i]);
+		}
 	}
 
  out:
@@ -229,12 +238,12 @@
 	if ((resid < 0) || (resid >= CKRM_MAX_RES_CTLRS) || ((rcbs = core->classtype->res_ctlrs[resid]) == NULL)) 
 		return;
 
-	spin_lock(&core->ckrm_lock);
+	class_lock(core);
 	list_for_each_entry(tsk, &core->objlist, taskclass_link) {
 		if (rcbs->change_resclass)
 			(*rcbs->change_resclass)(tsk, (void *) -1, core->res_class[resid]);
 	}
-	spin_unlock(&core->ckrm_lock);
+	class_unlock(core);
 }
 
 
@@ -522,14 +531,14 @@
 	int ce_regd;
 	struct ckrm_hnode *cnode;
 	struct ckrm_task_class *parcls;
+	int num = 0;
 
 	if (!ckrm_validate_and_grab_core(&cls->core))
 		return;
 
 	down(&async_serializer);   // protect again race condition
-
-
-	printk("\t%s: start %p:%s:%d\n",__FUNCTION__,cls,cls->core.name, atomic_read(&cls->core.refcnt));
+	TC_DEBUG("start %p:%s:%d:%d\n",cls,cls->core.name,
+		atomic_read(&cls->core.refcnt),atomic_read(&cls->core.hnode.parent->refcnt));
 	// If no CE registered for this classtype, following will be needed repeatedly;
 	ce_regd =  class_core(cls)->classtype->ce_regd;
 	cnode = &(class_core(cls)->hnode);
@@ -547,25 +556,27 @@
 		class_unlock(class_core(cls));
 
 		if (ce_regd) {
-			CE_CLASSIFY_RET(newcls,&CT_taskclass,CKRM_EVENT_RECLASSIFY,tsk); 
-		} else {
+			CE_CLASSIFY_RET(newcls,&CT_taskclass,CKRM_EVENT_RECLASSIFY,tsk);
+			if (cls == newcls) {
+				// don't allow reclassifying to the same class
+				// as we are in the process of cleaning up this class
+				ckrm_core_drop(class_core(newcls)); // to compensate CE's grab
+				newcls = NULL;
+			}
+		}
+		if (newcls == NULL) {
 			newcls = parcls;
 			ckrm_core_grab(class_core(newcls));
 		}
-
-		if (cls == newcls) {
-			// don't allow reclassifying to the same class
-			// as we are in the process of cleaning up this class
-			ckrm_core_drop(class_core(newcls)); // to compensate CE's grab
-			newcls = NULL;
-		}
 		ckrm_set_taskclass(tsk, newcls, cls, CKRM_EVENT_RECLASSIFY);
 		put_task_struct(tsk);
+		num++;
 		goto next_task;
 	}
-	printk("\t%s: stop  %p:%s:%d\n",__FUNCTION__,cls,cls->core.name, atomic_read(&cls->core.refcnt));
-	ckrm_core_drop(class_core(cls));
+	TC_DEBUG("stop  %p:%s:%d:%d   %d\n",cls,cls->core.name,
+		atomic_read(&cls->core.refcnt),atomic_read(&cls->core.hnode.parent->refcnt),num);
 	class_unlock(class_core(cls));
+	ckrm_core_drop(class_core(cls));
 
 	up(&async_serializer);
 
@@ -587,6 +598,7 @@
 	read_lock(&tasklist_lock);
 	if ((tsk = find_task_by_pid(pid)) == NULL) {
 		read_unlock(&tasklist_lock);
+		ckrm_core_drop(class_core(cls));
 		return -EINVAL;
 	}
 	get_task_struct(tsk);
@@ -636,8 +648,9 @@
 		core->name = dflt_taskclass_name;
  		return 0;
 	}
-
-	printk("%s: stop  %p:%s:%d\n",__FUNCTION__,core,core->name, atomic_read(&core->refcnt));
+	
+	TC_DEBUG("%p:%s:%d\n",core,core->name,atomic_read(&core->refcnt));
+	 
 	taskcls = class_type(struct ckrm_task_class, core);
 
 	ce_protect(&CT_taskclass);
@@ -677,12 +690,12 @@
 	struct list_head *lh;
 	struct task_struct *tsk;
 
-	spin_lock(&core->ckrm_lock);
+	class_lock(core);
 	list_for_each(lh, &core->objlist) {	
 		tsk = container_of(lh, struct task_struct, taskclass_link);
 		seq_printf(seq,"%ld\n", (long)tsk->pid);
 	}
-	spin_unlock(&core->ckrm_lock);
+	class_unlock(core);
 
 	return 0;
 }
