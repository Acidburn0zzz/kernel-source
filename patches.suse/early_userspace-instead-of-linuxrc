
From: Olaf Hering <olh@suse.de>

initramfs can not be used in current 2.6 kernels, the files will never be
executed because prepare_namespace doesn't care about them.  The only way to
workaround that limitation is a root=0:0 cmdline option to force rootfs as
root filesystem.  This will break further booting because rootfs is not the
final root filesystem.

This patch checks for the presence of /init which comes from the cpio archive
(and thats the only way to store files into the rootfs).  This binary/script
has to do all the work of prepare_namespace().



---

 25-akpm/Documentation/early-userspace/README |   26 ++++++++++++++++++++++++++
 25-akpm/init/main.c                          |    7 +++++++
 2 files changed, 33 insertions(+)

diff -purN /trashcan/olaf/linux-2.6.5-rc2/init/main.c linux-2.6.5-rc2/init/main.c
--- /trashcan/olaf/linux-2.6.5-rc2/init/main.c	2004-03-16 10:10:35.000000000 +0000
+++ linux-2.6.5-rc2/init/main.c	2004-03-20 12:52:12.000000000 +0000
@@ -581,6 +581,29 @@ static void run_init_process(char *init_
 	execve(init_filename, argv_init, envp_init);
 }
 
+static int free_initmem_on_exec_helper(void *data)
+{
+	int *fd = data; 
+	char c;
+
+	sys_close(fd[1]);
+	sys_read(fd[0], &c, 1);
+	free_initmem();
+	return 0;
+}
+
+static void free_initmem_on_exec(void)
+{
+	int fd[2]; 
+
+	do_pipe(fd);
+	kernel_thread(free_initmem_on_exec_helper, &fd, SIGCHLD);
+
+	sys_dup2(fd[1], 255);   /* to get it out of the way */
+	sys_close(fd[0]);
+	sys_close(fd[1]);
+	sys_fcntl(255, F_SETFD, 1);
+}                                                                                                                                                                   
 extern void prepare_namespace(void);
 
 static int init(void * unused)
@@ -604,17 +627,23 @@ static int init(void * unused)
 	smp_init();
 	do_basic_setup();
 
-	prepare_namespace();
-
 	/*
 	 * Ok, we have completed the initial bootup, and
 	 * we're essentially up and running. Get rid of the
 	 * initmem segments and start the user-mode stuff..
 	 */
-	free_initmem();
+	free_initmem_on_exec();
 	unlock_kernel();
 	system_running = 1;
 
+       /*
+        * check if there is an early userspace init, if yes
+        * let it do all the things prepare_namespace() would do.
+        */
+	run_init_process("/init");
+
+	prepare_namespace();
+
 	if (sys_open("/dev/console", O_RDWR, 0) < 0)
 		printk("Warning: unable to open an initial console.\n");
 
diff -puN Documentation/early-userspace/README~initramfs-search-for-init Documentation/early-userspace/README
--- 25/Documentation/early-userspace/README~initramfs-search-for-init	Thu Feb 26 16:14:59 2004
+++ 25-akpm/Documentation/early-userspace/README	Thu Feb 26 16:14:59 2004
@@ -71,5 +71,31 @@ custom initramfs images that meet your n
 For questions and help, you can sign up for the early userspace
 mailing list at http://www.zytor.com/mailman/listinfo/klibc
 
+How does it work?
+=================
+
+The kernel has currently 3 ways to mount the root filesystem:
+
+a) all required device and filesystem drivers compiled into the kernel, no
+   initrd.  init/main.c:init() will call prepare_namespace() to mount the
+   final root filesystem, based on the root= option and optional init= to run
+   some other init binary than listed at the end of init/main.c:init().
+
+b) some device and filesystem drivers built as modules and stored in an
+   initrd.  The initrd must contain a binary '/linuxrc' which is supposed to
+   load these driver modules.  It is also possible to mount the final root
+   filesystem via linuxrc and use the pivot_root syscall.  The initrd is
+   mounted and executed via prepare_namespace().
+
+c) using initramfs.  The call to prepare_namespace() must be skipped.
+   This means that a binary must do all the work.  Said binary can be stored
+   into initramfs either via modifying usr/gen_init_cpio.c or via the new
+   initrd format, an cpio archive.  It must be called "/init".  This binary
+   is responsible to do all the things prepare_namespace() would do.
+
+   To remain backwards compatibility, the /init binary will only run if it
+   comes via an initramfs cpio archive.  If this is not the case,
+   init/main.c:init() will run prepare_namespace() to mount the final root
+   and exec one of the predefined init binaries.
 
 Bryan O'Sullivan <bos@serpentine.com>

_
