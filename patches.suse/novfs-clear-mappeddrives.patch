From: Goldwyn Rodrigues <rgoldwyn@suse.de>
Subject: Unlink mapped drives on exit
References: bnc#449451

Mapped drives were not being unlinked properly because 
of ABI change in the kernel. Fixed local_unlink function 
to correctly unlink files.

---
 fs/novfs/daemon.c |   93 +++++++++++++++++++++++++++++++-----------------------
 fs/novfs/nwcapi.c |    2 -
 2 files changed, 56 insertions(+), 39 deletions(-)

--- a/fs/novfs/daemon.c
+++ b/fs/novfs/daemon.c
@@ -15,6 +15,7 @@
 
 #include <linux/module.h>
 #include <linux/fs.h>
+#include <linux/mount.h>
 #include <linux/slab.h>
 #include <linux/list.h>
 #include <linux/timer.h>
@@ -96,7 +97,7 @@ static int NwdConvertNetwareHandle(struc
 static int set_map_drive(struct novfs_xplat *pdata, struct novfs_schandle Session);
 static int unmap_drive(struct novfs_xplat *pdata, struct novfs_schandle Session);
 static int NwdGetMountPath(struct novfs_xplat *pdata);
-static int local_unlink(const char *pathname);
+static long local_unlink(const char *pathname);
 
 
 /*===[ Global variables ]=================================================*/
@@ -2017,52 +2018,68 @@ static void RemoveDriveMaps(void)
 	up(&DriveMapLock);
 }
 
-static int local_unlink(const char *pathname)
+/* As picked from do_unlinkat() */
+
+static long local_unlink(const char *pathname)
 {
 	int error;
 	struct dentry *dentry;
+	char *name, *c;
 	struct nameidata nd;
 	struct inode *inode = NULL;
 
-	DbgPrint("%s", pathname);
 	error = path_lookup(pathname, LOOKUP_PARENT, &nd);
-	DbgPrint("path_lookup %d", error);
-	if (!error) {
-		error = -EISDIR;
-		if (nd.last_type == LAST_NORM) {
-			dentry = lookup_create(&nd, 1);
-			DbgPrint("lookup_hash 0x%p", dentry);
-
-			error = PTR_ERR(dentry);
-			if (!IS_ERR(dentry)) {
-				if (nd.last.name[nd.last.len]) {
-					error =
-					    !dentry->
-					    d_inode ? -ENOENT : S_ISDIR(dentry->
-									d_inode->
-									i_mode)
-					    ? -EISDIR : -ENOTDIR;
-				} else {
-					inode = dentry->d_inode;
-					if (inode) {
-						atomic_inc(&inode->i_count);
-					}
-					error = vfs_unlink(nd.path.dentry->d_inode, dentry);
-					DbgPrint("vfs_unlink %d", error);
-				}
-				dput(dentry);
-			}
-			mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
-
-		}
-		path_put(&nd.path);
+	DbgPrint("path_lookup %s error: %d\n", pathname, error);
+	if (error)
+		return error;
+
+	error = -EISDIR;
+	if (nd.last_type != LAST_NORM)
+		goto exit1;
+	mutex_lock(&nd.path.dentry->d_inode->i_mutex);
+	/* Get the filename of pathname */
+	name=c=(char *)pathname;
+	while (*c!='\0') {
+		if (*c=='/')
+			name=++c;
+		c++;
+	}
+	dentry = lookup_one_len(name, nd.path.dentry, strlen(name));
+	error = PTR_ERR(dentry);
+	DbgPrint("dentry %p", dentry);
+	if (!(dentry->d_inode->i_mode & S_IFLNK)) {
+		DbgPrint("%s not a link", name);
+		error=-ENOENT;
+		goto exit1;
+	}
+
+	if (!IS_ERR(dentry)) {
+		/* Why not before? Because we want correct error value */
+		if (nd.last.name[nd.last.len])
+			goto slashes;
+		inode = dentry->d_inode;
+		if (inode)
+			atomic_inc(&inode->i_count);
+		error = mnt_want_write(nd.path.mnt);
+		DbgPrint("inode %p mnt_want_write error %d", inode, error);
+		if (error)
+			goto exit2;
+		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
+		mnt_drop_write(nd.path.mnt);
+	exit2:
+		dput(dentry);
 	}
-
-	if (inode) {
+	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
+	if (inode)
 		iput(inode);	/* truncate the inode here */
-	}
-
-	DbgPrint("error=%d", error);
+exit1:
+	path_put(&nd.path);
+	DbgPrint("returning error %d", error);
 	return error;
+
+slashes:
+	error = !dentry->d_inode ? -ENOENT :
+		S_ISDIR(dentry->d_inode->i_mode) ? -EISDIR : -ENOTDIR;
+	goto exit2;
 }
 
--- a/fs/novfs/nwcapi.c
+++ b/fs/novfs/nwcapi.c
@@ -991,7 +991,7 @@ int novfs_scan_conn_info(struct novfs_xp
 		DbgPrint("Reply recieved");
 		__DbgPrint("   NextIndex = %x\n", connInfo.uScanIndex);
 		__DbgPrint("   ErrorCode = %x\n", reply->Reply.ErrorCode);
-		__DbgPrint("   data = %x\n", reply->data);
+		__DbgPrint("   data = %p\n", reply->data);
 
 		pDConnInfo = (struct nwd_scan_conn_info *) reply->data;
 		retCode = (unsigned long) reply->Reply.ErrorCode;
