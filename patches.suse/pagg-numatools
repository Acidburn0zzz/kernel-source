From: Greg Edwards <edwardsg@sgi.com>
Subject: exports for numatools kernel module
Patch-mainline: obsolete
References: 142118

Acked-by: Nick Piggin <npiggin@novell.com>
Acked-by: Raymund Will <rw@suse.de>

###################################################################
exports for numatools

 arch/ia64/mm/hugetlbpage.c |    2 ++
 kernel/cpuset.c            |    1 +
 2 files changed, 3 insertions(+)

Acked-by: 
Signed-off-by: 

Index: linux-2.6.14/arch/ia64/mm/hugetlbpage.c
===================================================================
--- linux-2.6.14.orig/arch/ia64/mm/hugetlbpage.c	2005-10-27 19:02:08.000000000 -0500
+++ linux-2.6.14/arch/ia64/mm/hugetlbpage.c	2006-01-06 15:39:47.652326686 -0600
@@ -12,6 +12,7 @@
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <linux/mm.h>
+#include <linux/module.h>
 #include <linux/hugetlb.h>
 #include <linux/pagemap.h>
 #include <linux/smp_lock.h>
@@ -23,6 +24,7 @@
 #include <asm/tlbflush.h>
 
 unsigned int hpage_shift=HPAGE_SHIFT_DEFAULT;
+EXPORT_SYMBOL_GPL(hpage_shift);
 
 pte_t *
 huge_pte_alloc (struct mm_struct *mm, unsigned long addr)
Index: linux-2.6.14/kernel/cpuset.c
===================================================================
--- linux-2.6.14.orig/kernel/cpuset.c	2006-01-06 15:38:27.046986592 -0600
+++ linux-2.6.14/kernel/cpuset.c	2006-01-06 15:40:46.880866949 -0600
@@ -1679,6 +1679,7 @@ cpumask_t cpuset_cpus_allowed(const stru
 
 	return mask;
 }
+EXPORT_SYMBOL_GPL(cpuset_cpus_allowed);
 
 void cpuset_init_current_mems_allowed(void)
 {
###################################################################
add pagg_list_emtpy macro

 include/linux/pagg.h |   17 ++++++++++++++---
 1 files changed, 14 insertions(+), 3 deletions(-)

Index: linux-2.6.15/include/linux/pagg.h
===================================================================
--- linux-2.6.15.orig/include/linux/pagg.h	2006-01-18 16:43:37.420825987 -0600
+++ linux-2.6.15/include/linux/pagg.h	2006-01-18 21:55:18.651708284 -0600
@@ -133,6 +133,16 @@ extern void __pagg_detach(struct task_st
 extern int __pagg_exec(struct task_struct *task);
 
 /**
+ * pagg_list_empty - Check to see if the task's pagg_list is empty.
+ * @task: The task in question
+ *
+ */
+static inline int pagg_list_empty(const struct task_struct *task)
+{
+	return list_empty(&task->pagg_list);
+}
+
+/**
  * pagg_attach - child inherits attachment to pagg containers of its parent
  * @child: child task - to inherit
  * @parent: parenet task - child inherits pagg containers from this parent
@@ -145,7 +155,7 @@ static inline int pagg_attach(struct tas
 			      struct task_struct *parent)
 {
 	INIT_PAGG_LIST(child);
-	if (!list_empty(&parent->pagg_list))
+	if (!pagg_list_empty(parent))
 		return __pagg_attach(child, parent);
 
 	return 0;
@@ -159,7 +169,7 @@ static inline int pagg_attach(struct tas
  */
 static inline void pagg_detach(struct task_struct *task)
 {
-	if (!list_empty(&task->pagg_list))
+	if (!pagg_list_empty(task))
 		__pagg_detach(task);
 }
 
@@ -170,7 +180,7 @@ static inline void pagg_detach(struct ta
  */
 static inline void pagg_exec(struct task_struct *task)
 {
-	if (!list_empty(&task->pagg_list))
+	if (!pagg_list_empty(task))
 		__pagg_exec(task);
 }
 
@@ -197,6 +207,7 @@ static inline void pagg_exec(struct task
 #define pagg_attach(ct, pt)  (0)
 #define pagg_detach(t)  do {  } while(0)
 #define pagg_exec(t)  do {  } while(0)
+#define pagg_list_empty(t) (1)
 
 #endif /* CONFIG_PAGG */
 
###################################################################
don't reset cpus_allowed for pagg users

 kernel/fork.c |    7 ++++++-
 1 files changed, 6 insertions(+), 1 deletion(-)

Index: linux-2.6.15/kernel/fork.c
===================================================================
--- linux-2.6.15.orig/kernel/fork.c	2006-01-18 21:45:00.833637873 -0600
+++ linux-2.6.15/kernel/fork.c	2006-01-18 21:55:58.567752186 -0600
@@ -1063,8 +1063,13 @@ static task_t *copy_process(unsigned lon
 	 * copied first time - so re-copy it here, then check the child's CPU
 	 * to ensure it is on a valid CPU (and if not, just force it back to
 	 * parent's CPU). This avoids alot of nasty races.
+	 *
+	 * Some PAGG users set the cpus_allowed mask, so only reset it if the
+	 * pagg_list is empty or if the mask contains offline cpus.
 	 */
-	p->cpus_allowed = current->cpus_allowed;
+	if (pagg_list_empty(p) ||
+			unlikely(!cpus_subset(p->cpus_allowed,cpu_online_map)))
+		p->cpus_allowed = current->cpus_allowed;
 	if (unlikely(!cpu_isset(task_cpu(p), p->cpus_allowed) ||
 			!cpu_online(task_cpu(p))))
 		set_task_cpu(p, smp_processor_id());
