Backport from kdb v4.4.  Select GFP_ATOMIC or GFP_KERNEL , depending on
whether KDB is running in interrupt context or not.

Index: linux-2.6.5-7.51/include/linux/kdbprivate.h
===================================================================
--- linux-2.6.5-7.51.orig/include/linux/kdbprivate.h	2004-05-28 14:56:23.879838352 +1000
+++ linux-2.6.5-7.51/include/linux/kdbprivate.h	2004-05-28 14:56:23.023968464 +1000
@@ -357,4 +357,6 @@ extern task_t *kdb_cpu_curr(int cpu);
 #define	kdb_do_each_thread(g, p) do_each_thread(g, p)
 #define	kdb_while_each_thread(g, p) while_each_thread(g, p)
 
+#define GFP_KDB (in_interrupt() ? GFP_ATOMIC : GFP_KERNEL)
+
 #endif	/* !_KDBPRIVATE_H */
Index: linux-2.6.5-7.51/kdb/kdbmain.c
===================================================================
--- linux-2.6.5-7.51.orig/kdb/kdbmain.c	2004-05-28 14:56:23.879838352 +1000
+++ linux-2.6.5-7.51/kdb/kdbmain.c	2004-05-28 18:34:32.377136616 +1000
@@ -729,14 +729,14 @@ kdb_defcmd2(const char *cmdstr, const ch
 	}
 	if (!s->usable)
 		return KDB_NOTIMP;
-	s->command = kmalloc((s->count + 1) * sizeof(*(s->command)), GFP_KERNEL);
+	s->command = kmalloc((s->count + 1) * sizeof(*(s->command)), GFP_KDB);
 	if (!s->command) {
 		kdb_printf("Could not allocate new kdb_defcmd table for %s\n", cmdstr);
 		s->usable = 0;
 		return KDB_NOTIMP;
 	}
 	memcpy(s->command, save_command, s->count * sizeof(*(s->command)));
-	s->command[s->count++] = kdb_strdup(cmdstr, GFP_KERNEL);
+	s->command[s->count++] = kdb_strdup(cmdstr, GFP_KDB);
 	kfree(save_command);
 	return 0;
 }
@@ -751,7 +751,7 @@ kdb_defcmd(int argc, const char **argv, 
 		kdb_printf("kdb: nested defcmd detected, assuming missing endefcmd\n");
 		kdb_defcmd2("endefcmd", "endefcmd");
 	}
-	defcmd_set = kmalloc((defcmd_set_count + 1) * sizeof(*defcmd_set), GFP_KERNEL);
+	defcmd_set = kmalloc((defcmd_set_count + 1) * sizeof(*defcmd_set), GFP_KDB);
 	if (!defcmd_set) {
 		kdb_printf("Could not allocate new defcmd_set entry for %s\n", argv[1]);
 		defcmd_set = save_defcmd_set;
@@ -762,9 +762,9 @@ kdb_defcmd(int argc, const char **argv, 
 	s = defcmd_set + defcmd_set_count;
 	memset(s, 0, sizeof(*s));
 	s->usable = 1;
-	s->name = kdb_strdup(argv[1], GFP_KERNEL);
-	s->usage = kdb_strdup(argv[2], GFP_KERNEL);
-	s->help = kdb_strdup(argv[3], GFP_KERNEL);
+	s->name = kdb_strdup(argv[1], GFP_KDB);
+	s->usage = kdb_strdup(argv[2], GFP_KDB);
+	s->help = kdb_strdup(argv[3], GFP_KDB);
 	if (s->usage[0] == '"') {
 		strcpy(s->usage, s->usage+1);
 		s->usage[strlen(s->usage)-1] = '\0';
@@ -3053,7 +3053,7 @@ kdb_ll(int argc, const char **argv, cons
 	 */
 
 	va = addr;
-	if (!(command = kdb_strdup(argv[3], GFP_KERNEL))) {
+	if (!(command = kdb_strdup(argv[3], GFP_KDB))) {
 		kdb_printf("%s: cannot duplicate command\n", __FUNCTION__);
 		return 0;
 	}
@@ -3228,7 +3228,7 @@ kdb_register_repeat(char *cmd,
 	}
 
 	if (i >= kdb_max_commands) {
-		kdbtab_t *new = kmalloc((kdb_max_commands + kdb_command_extend) * sizeof(*new), GFP_KERNEL);
+		kdbtab_t *new = kmalloc((kdb_max_commands + kdb_command_extend) * sizeof(*new), GFP_KDB);
 		if (!new) {
 			kdb_printf("Could not allocate new kdb_command table\n");
 			return 1;
