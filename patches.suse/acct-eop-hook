From: Jay Lan <jlan@sgi.com>
Subject: Continue including Enhanced Acct patches (aka CSA)
Patch-mainline: no
References: 141530

We are requesting that the Enhanced Acct patches to be
carried over for SLES10 (and refreshed to the latest version).

Some big SGI customers depend on this feature to do CSA accounting on
their systems.  This feature is really a must-have for these customers 
and for SGI.

UPSTREAMS STATUS:
  There were three patches included to SLES9: acct_io, acct_mm, and acct_eop.
  Both acct_io and acct_mm have been accepted in Linus tree. We are requesting
  to include acct_eop, which provides a callback for the csa kernel module.

  The reason for acct_eop has not been accepted upstreams was because CSA 
  kernel module is waiting for PAGG (or its replacement) to be included
  upstreams.


Acked-by: okir@suse.de
Acked-by: rw@suse.de

Index: linux/kernel/exit.c
===================================================================
--- linux.orig/kernel/exit.c	2006-01-05 13:32:05.113218596 -0800
+++ linux/kernel/exit.c	2006-01-05 14:22:30.086948372 -0800
@@ -847,8 +847,8 @@ fastcall NORET_TYPE void do_exit(long co
 	if (group_dead) {
  		del_timer_sync(&tsk->signal->real_timer);
 		exit_itimers(tsk->signal);
-		acct_process(code);
 	}
+	acct_process(tsk, code, group_dead);
 	exit_mm(tsk);
 
 	exit_sem(tsk);
Index: linux/include/linux/acct.h
===================================================================
--- linux.orig/include/linux/acct.h	2006-01-02 19:21:10.000000000 -0800
+++ linux/include/linux/acct.h	2006-01-05 14:29:26.931411150 -0800
@@ -123,13 +123,13 @@ struct vfsmount;
 struct super_block;
 extern void acct_auto_close_mnt(struct vfsmount *m);
 extern void acct_auto_close(struct super_block *sb);
-extern void acct_process(long exitcode);
+extern void acct_process(struct task_struct *tsk, long exitcode, int last_thread);
 extern void acct_update_integrals(struct task_struct *tsk);
 extern void acct_clear_integrals(struct task_struct *tsk);
 #else
 #define acct_auto_close_mnt(x)	do { } while (0)
 #define acct_auto_close(x)	do { } while (0)
-#define acct_process(x)		do { } while (0)
+#define acct_process(tsk,exitcode,last_thread)		do { } while (0)
 #define acct_update_integrals(x)		do { } while (0)
 #define acct_clear_integrals(task)	do { } while (0)
 #endif
@@ -201,6 +201,13 @@ static inline u64 nsec_to_AHZ(u64 x)
 	return x;
 }
 
+/*
+ * extern declaration that provides the hook needed for processing of
+ * end-of-process accounting record
+ *
+ */
+extern void (*do_eop_acct) (int, struct task_struct *);
+
 #endif  /* __KERNEL */
 
 #endif	/* _LINUX_ACCT_H */
Index: linux/kernel/posix-timers.c
===================================================================
--- linux.orig/kernel/posix-timers.c	2006-01-02 19:21:10.000000000 -0800
+++ linux/kernel/posix-timers.c	2006-01-05 14:05:04.542123920 -0800
@@ -1219,6 +1219,7 @@ int do_posix_clock_monotonic_gettime(str
 {
 	return do_posix_clock_monotonic_get(CLOCK_MONOTONIC, tp);
 }
+EXPORT_SYMBOL_GPL(do_posix_clock_monotonic_gettime);
 
 int do_posix_clock_nosettime(clockid_t clockid, struct timespec *tp)
 {
Index: linux/kernel/acct.c
===================================================================
--- linux.orig/kernel/acct.c	2006-01-02 19:21:10.000000000 -0800
+++ linux/kernel/acct.c	2006-01-05 14:22:02.295624398 -0800
@@ -59,6 +59,9 @@
 #include <asm/div64.h>
 #include <linux/blkdev.h> /* sector_div */
 
+void (*do_eop_acct) (int, struct task_struct *) = NULL;
+EXPORT_SYMBOL_GPL(do_eop_acct);
+
 /*
  * These constants control the amount of freespace that suspend and
  * resume the process accounting system, and the time delay between
@@ -549,10 +552,16 @@ static void do_acct_process(long exitcod
  *
  * handles process accounting for an exiting task
  */
-void acct_process(long exitcode)
+void acct_process(struct task_struct *tsk, long exitcode, int last_thread)
 {
 	struct file *file = NULL;
 
+	if (do_eop_acct)
+		do_eop_acct(exitcode, tsk);
+
+	if (!last_thread)
+		return;
+
 	/*
 	 * accelerate the common fastpath:
 	 */
