From: IBM
Subject: Enable schedstats and delay accounting
References: 141936 - LTC20517 - LDP11943 - FATE 300393

Acked-by: okir@suse.de
 
 Documentation/kernel-parameters.txt |    4 
 fs/buffer.c                         |    4 
 fs/read_write.c                     |    7 +
 include/linux/delayacct.h           |   76 ++++++++++++++++
 include/linux/sched.h               |   22 ++++
 include/linux/sysctl.h              |    2 
 include/linux/time.h                |   15 +++
 init/Kconfig                        |   13 ++
 init/main.c                         |    2 
 kernel/Makefile                     |    1 
 kernel/delayacct.c                  |  169 ++++++++++++++++++++++++++++++++++++
 kernel/exit.c                       |    3 
 kernel/fork.c                       |    2 
 kernel/sched.c                      |   76 +++++++++++++++-
 kernel/sysctl.c                     |   21 ++++
 lib/Kconfig.debug                   |    2 
 mm/filemap.c                        |    7 +
 mm/memory.c                         |   15 ++-
 18 files changed, 431 insertions(+), 10 deletions(-)

Index: linux-2.6.15/include/linux/time.h
===================================================================
--- linux-2.6.15.orig/include/linux/time.h
+++ linux-2.6.15/include/linux/time.h
@@ -144,12 +144,27 @@ extern struct timespec ns_to_timespec(co
  * @nsec:	the nanoseconds value to be converted
  *
  * Returns the timeval representation of the nsec parameter.
  */
 extern struct timeval ns_to_timeval(const nsec_t nsec);
 
+/*
+ * timespec_diff_ns - Return difference of two timestamps in nanoseconds
+ * In the rare case of @end being earlier than @start, return zero
+ */
+static inline unsigned long long
+timespec_diff_ns(struct timespec *start, struct timespec *end)
+{
+	long long ret;
+
+	ret = end->tv_sec*(1000000000) + end->tv_nsec;
+	ret -= start->tv_sec*(1000000000) + start->tv_nsec;
+	if (ret < 0)
+		return 0;
+	return ret;
+}
 #endif /* __KERNEL__ */
 
 #define NFDBITS			__NFDBITS
 
 #define FD_SETSIZE		__FD_SETSIZE
 #define FD_SET(fd,fdsetp)	__FD_SET(fd,fdsetp)
Index: linux-2.6.15/init/Kconfig
===================================================================
--- linux-2.6.15.orig/init/Kconfig
+++ linux-2.6.15/init/Kconfig
@@ -160,12 +160,25 @@ config PAGG
 	help
 	  Say Y here if you will be loading modules which provide support
 	  for process aggregate containers.  Examples of such modules include the
 	  Linux Jobs module and the Linux Array Sessions module.  If you will not
 	  be using such modules, say N.
 
+config TASK_DELAY_ACCT
+	bool "Enable per-task delay accounting (EXPERIMENTAL)"
+	help
+	  Collect information on time spent by a task waiting for system
+	  resources like cpu, synchronous block I/O completion and swapping
+	  in pages. Such statistics can help in setting a task's priorities
+	  relative to other tasks for cpu, io, rss limits etc.
+
+	  Unlike BSD process accounting, this information is available
+	  continuously during the lifetime of a task.
+
+	  Say N if unsure.
+
 config SYSCTL
 	bool "Sysctl support"
 	---help---
 	  The sysctl interface provides a means of dynamically changing
 	  certain kernel parameters and variables on the fly without requiring
 	  a recompile of the kernel or reboot of the system.  The primary
Index: linux-2.6.15/include/linux/sched.h
===================================================================
--- linux-2.6.15.orig/include/linux/sched.h
+++ linux-2.6.15/include/linux/sched.h
@@ -12,12 +12,13 @@
 #include <linux/jiffies.h>
 #include <linux/rbtree.h>
 #include <linux/thread_info.h>
 #include <linux/cpumask.h>
 #include <linux/errno.h>
 #include <linux/nodemask.h>
+#include <linux/sysctl.h>
 
 #include <asm/system.h>
 #include <asm/semaphore.h>
 #include <asm/page.h>
 #include <asm/ptrace.h>
 #include <asm/mmu.h>
@@ -524,12 +525,15 @@ extern struct user_struct root_user;
 
 typedef struct prio_array prio_array_t;
 struct backing_dev_info;
 struct reclaim_state;
 
 #ifdef CONFIG_SCHEDSTATS
+extern int schedstats_sysctl;
+extern int schedstats_sysctl_handler(ctl_table *, int, struct file *,
+			void __user *, size_t *, loff_t *);
 struct sched_info {
 	/* cumulative counters */
 	unsigned long	cpu_time,	/* time spent on the cpu */
 			run_delay,	/* time spent waiting on a runqueue */
 			pcnt;		/* # of timeslices run on this cpu */
 
@@ -538,12 +542,27 @@ struct sched_info {
 			last_queued;	/* when we were last queued to run */
 };
 
 extern struct file_operations proc_schedstat_operations;
 #endif
 
+#ifdef CONFIG_TASK_DELAY_ACCT
+struct task_delay_info {
+	spinlock_t	lock;
+
+	/* timestamp recording variables (to reduce stack usage) */
+	struct timespec start, end;
+
+	/* Add stats in pairs: u64 delay, u32 count, aligned properly */
+	u64 blkio_delay;	/* wait for sync block io completion */
+	u64 swapin_delay;	/* wait for pages to be swapped in */
+	u32 blkio_count;
+	u32 swapin_count;
+};
+#endif
+
 enum idle_type
 {
 	SCHED_IDLE,
 	NOT_IDLE,
 	NEWLY_IDLE,
 	MAX_IDLE_TYPES
@@ -883,12 +902,15 @@ struct task_struct {
 	struct rcu_head rcu;
 #ifdef CONFIG_PAGG
 /* List of pagg (process aggregate) attachments */
 	struct list_head pagg_list;
 	struct rw_semaphore pagg_sem;
 #endif
+#ifdef	CONFIG_TASK_DELAY_ACCT
+	struct task_delay_info *delays;
+#endif
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
 {
 	return tsk->signal->pgrp;
 }
Index: linux-2.6.15/kernel/fork.c
===================================================================
--- linux-2.6.15.orig/kernel/fork.c
+++ linux-2.6.15/kernel/fork.c
@@ -42,12 +42,13 @@
 #include <linux/audit.h>
 #include <linux/profile.h>
 #include <linux/rmap.h>
 #include <linux/acct.h>
 #include <linux/cn_proc.h>
 #include <linux/pagg.h>
+#include <linux/delayacct.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 #include <asm/cacheflush.h>
@@ -971,12 +972,13 @@ static task_t *copy_process(unsigned lon
 	if (!try_module_get(task_thread_info(p)->exec_domain->module))
 		goto bad_fork_cleanup_count;
 
 	if (p->binfmt && !try_module_get(p->binfmt->module))
 		goto bad_fork_cleanup_put_domain;
 
+	delayacct_tsk_init(p);	/* Must remain after dup_task_struct() */
 	p->did_exec = 0;
 	copy_flags(clone_flags, p);
 	p->pid = pid;
 	retval = -EFAULT;
 	if (clone_flags & CLONE_PARENT_SETTID)
 		if (put_user(p->pid, parent_tidptr))
Index: linux-2.6.15/include/linux/delayacct.h
===================================================================
--- /dev/null
+++ linux-2.6.15/include/linux/delayacct.h
@@ -0,0 +1,76 @@
+/* delayacct.h - per-task delay accounting
+ *
+ * Copyright (C) Shailabh Nagar, IBM Corp. 2005
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2.1 of the GNU Lesser General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _LINUX_TASKDELAYS_H
+#define _LINUX_TASKDELAYS_H
+
+#include <linux/sched.h>
+#include <linux/sysctl.h>
+
+#ifdef CONFIG_TASK_DELAY_ACCT
+extern int delayacct_on;	/* Delay accounting turned on/off */
+extern kmem_cache_t *delayacct_cache;
+extern int delayacct_sysctl_handler(ctl_table *, int , struct file *,
+			     void __user *, size_t *, loff_t *);
+extern int delayacct_init(void);
+extern void __delayacct_tsk_init(struct task_struct *tsk);
+extern void __delayacct_tsk_exit(struct task_struct *tsk);
+extern void __delayacct_blkio(void);
+extern void __delayacct_swapin(void);
+
+static inline void delayacct_tsk_init(struct task_struct *tsk)
+{
+	/* reinitialize in case parent's non-null pointer was dup'ed*/
+	tsk->delays = NULL;
+	if (unlikely(delayacct_on))
+		__delayacct_tsk_init(tsk);
+}
+
+static inline void delayacct_tsk_exit(struct task_struct *tsk)
+{
+	if (unlikely(tsk->delays))
+		__delayacct_tsk_exit(tsk);
+}
+
+static inline void delayacct_timestamp_start(void)
+{
+	if (unlikely(current->delays && delayacct_on))
+		do_posix_clock_monotonic_gettime(&current->delays->start);
+}
+
+static inline void delayacct_blkio(void)
+{
+	if (unlikely(current->delays && delayacct_on))
+		__delayacct_blkio();
+}
+
+static inline void delayacct_swapin(void)
+{
+	if (unlikely(current->delays && delayacct_on))
+		__delayacct_swapin();
+}
+#else
+static inline void delayacct_tsk_init(struct task_struct *tsk)
+{}
+static inline void delayacct_tsk_exit(struct task_struct *tsk)
+{}
+static inline void delayacct_timestamp_start(void)
+{}
+static inline void delayacct_blkio(void)
+{}
+static inline void delayacct_swapin(void)
+{}
+static inline int delayacct_init(void)
+{ return 0; }
+#endif /* CONFIG_TASK_DELAY_ACCT */
+#endif /* _LINUX_TASKDELAYS_H */
Index: linux-2.6.15/Documentation/kernel-parameters.txt
===================================================================
--- linux-2.6.15.orig/Documentation/kernel-parameters.txt
+++ linux-2.6.15/Documentation/kernel-parameters.txt
@@ -413,12 +413,14 @@ running once the system is up.
 	debug		[KNL] Enable kernel debugging (events log level).
 
 	decnet=		[HW,NET]
 			Format: <area>[,<node>]
 			See also Documentation/networking/decnet.txt.
 
+	delayacct	[KNL] Enable per-task delay accounting
+
 	devfs=		[DEVFS]
 			See Documentation/filesystems/devfs/boot-options.
 
 	dhash_entries=	[KNL]
 			Set number of hash buckets for dentry cache.
 
@@ -1338,12 +1340,14 @@ running once the system is up.
 			See a comment before function sbpcd_setup() in
 			drivers/cdrom/sbpcd.c.
 
 	sc1200wdt=	[HW,WDT] SC1200 WDT (watchdog) driver
 			Format: <io>[,<timeout>[,<isapnp>]]
 
+	schedstats	[KNL] Collect CPU scheduler statistics
+
 	scsi_debug_*=	[SCSI]
 			See drivers/scsi/scsi_debug.c.
 
 	scsi_default_dev_flags=
 			[SCSI] SCSI default device flags
 			Format: <integer>
Index: linux-2.6.15/kernel/Makefile
===================================================================
--- linux-2.6.15.orig/kernel/Makefile
+++ linux-2.6.15/kernel/Makefile
@@ -32,12 +32,13 @@ obj-$(CONFIG_KPROBES) += kprobes.o
 obj-$(CONFIG_SYSFS) += ksysfs.o
 obj-$(CONFIG_DETECT_SOFTLOCKUP) += softlockup.o
 obj-$(CONFIG_GENERIC_HARDIRQS) += irq/
 obj-$(CONFIG_SECCOMP) += seccomp.o
 obj-$(CONFIG_RCU_TORTURE_TEST) += rcutorture.o
 obj-$(CONFIG_PAGG) += pagg.o
+obj-$(CONFIG_TASK_DELAY_ACCT) += delayacct.o
 
 ifneq ($(CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
 # needed for x86 only.  Why this used to be enabled for all architectures is beyond
 # me.  I suspect most platforms don't need this, but until we know that for sure
 # I turn this off for IA-64 only.  Andreas Schwab says it's also needed on m68k
Index: linux-2.6.15/kernel/delayacct.c
===================================================================
--- /dev/null
+++ linux-2.6.15/kernel/delayacct.c
@@ -0,0 +1,169 @@
+/* delayacct.c - per-task delay accounting
+ *
+ * Copyright (C) Shailabh Nagar, IBM Corp. 2005
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2.1 of the GNU Lesser General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/sysctl.h>
+#include <linux/delayacct.h>
+
+int delayacct_on = 0;		/* Delay accounting turned on/off */
+kmem_cache_t *delayacct_cache;
+
+static int __init delayacct_setup_enable(char *str)
+{
+	delayacct_on = 1;
+	return 1;
+}
+__setup("delayacct", delayacct_setup_enable);
+
+int delayacct_init(void)
+{
+	delayacct_cache = kmem_cache_create("delayacct_cache",
+					    sizeof(struct task_delay_info),
+					    0,
+					    SLAB_PANIC,
+					    NULL, NULL);
+	if (!delayacct_cache)
+		return -ENOMEM;
+	delayacct_tsk_init(&init_task);
+	return 0;
+}
+
+void __delayacct_tsk_init(struct task_struct *tsk)
+{
+	tsk->delays = kmem_cache_alloc(delayacct_cache, SLAB_KERNEL);
+	if (tsk->delays) {
+		memset(tsk->delays, 0, sizeof(*tsk->delays));
+		spin_lock_init(&tsk->delays->lock);
+	}
+}
+
+void __delayacct_tsk_exit(struct task_struct *tsk)
+{
+	kmem_cache_free(delayacct_cache, tsk->delays);
+	tsk->delays = NULL;
+}
+
+static inline unsigned long long delayacct_measure(void)
+{
+	do_posix_clock_monotonic_gettime(&current->delays->end);
+	return timespec_diff_ns(&current->delays->start, &current->delays->end);
+}
+
+void __delayacct_blkio(void)
+{
+	unsigned long long delay;
+
+	delay = delayacct_measure();
+
+	spin_lock(&current->delays->lock);
+	current->delays->blkio_delay += delay;
+	current->delays->blkio_count++;
+	spin_unlock(&current->delays->lock);
+}
+
+void __delayacct_swapin(void)
+{
+	unsigned long long delay;
+
+	delay = delayacct_measure();
+
+	spin_lock(&current->delays->lock);
+	current->delays->swapin_delay += delay;
+	current->delays->swapin_count++;
+	spin_unlock(&current->delays->lock);
+}
+
+/* Allocate task_delay_info for all tasks without one */
+static int alloc_delays(void)
+{
+	int cnt=0, i;
+	struct task_struct *g, *t;
+	struct task_delay_info **delayp;
+
+	read_lock(&tasklist_lock);
+	do_each_thread(g, t) {
+		if (!t->delays)
+			cnt++;
+	} while_each_thread(g, t);
+	read_unlock(&tasklist_lock);
+
+	if (!cnt)
+		return 0;
+
+	delayp = kmalloc(cnt *sizeof(struct task_delay_info *), GFP_KERNEL);
+	if (!delayp)
+		return -ENOMEM;
+	for (i = 0; i < cnt; i++) {
+		delayp[i] = kmem_cache_alloc(delayacct_cache, SLAB_KERNEL);
+		if (!delayp[i])
+			goto out;
+		memset(delayp[i], 0, sizeof(*delayp[i]));
+		spin_lock_init(&delayp[i]->lock);
+	}
+
+	read_lock(&tasklist_lock);
+	do_each_thread(g, t) {
+		if (t->delays)
+			continue;
+		t->delays = delayp[--i];
+		if (i<0)
+			break;
+	} while_each_thread(g, t);
+	read_unlock(&tasklist_lock);
+
+	if (i)
+		BUG();
+	return 0;
+out:
+	--i;
+	while (i >= 0)
+		kmem_cache_free(delayacct_cache, delayp[--i]);
+	return -ENOMEM;
+}
+
+/* Reset task_delay_info structs for all tasks */
+static void reset_delays(void)
+{
+	struct task_struct *g, *t;
+
+	read_lock(&tasklist_lock);
+	do_each_thread(g, t) {
+		if (!t->delays)
+			BUG();
+		memset(t->delays, 0, sizeof(struct task_delay_info));
+		spin_lock_init(&t->delays->lock);
+	} while_each_thread(g, t);
+	read_unlock(&tasklist_lock);
+}
+
+int delayacct_sysctl_handler(ctl_table *table, int write, struct file *filp,
+			      void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	int ret, prev;
+
+	prev = delayacct_on;
+	ret = proc_dointvec(table, write, filp, buffer, lenp, ppos);
+	if (ret || (prev == delayacct_on))
+		return ret;
+
+	if (delayacct_on)
+		ret = alloc_delays();
+	else
+		reset_delays();
+	if (ret)
+		delayacct_on = prev;
+	return ret;
+}
+
Index: linux-2.6.15/kernel/exit.c
===================================================================
--- linux-2.6.15.orig/kernel/exit.c
+++ linux-2.6.15/kernel/exit.c
@@ -32,12 +32,13 @@
 #include <linux/cpuset.h>
 #include <linux/syscalls.h>
 #include <linux/signal.h>
 #include <linux/cn_proc.h>
 #include <linux/mutex.h>
 #include <linux/pagg.h>
+#include <linux/delayacct.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
@@ -843,12 +844,14 @@ fastcall NORET_TYPE void do_exit(long co
 	if (unlikely(in_atomic()))
 		printk(KERN_INFO "note: %s[%d] exited with preempt_count %d\n",
 				current->comm, current->pid,
 				preempt_count());
 
 	acct_update_integrals(tsk);
+	delayacct_tsk_exit(tsk);
+
 	if (tsk->mm) {
 		update_hiwater_rss(tsk->mm);
 		update_hiwater_vm(tsk->mm);
 	}
 	group_dead = atomic_dec_and_test(&tsk->signal->live);
 	if (group_dead) {
Index: linux-2.6.15/init/main.c
===================================================================
--- linux-2.6.15.orig/init/main.c
+++ linux-2.6.15/init/main.c
@@ -44,12 +44,13 @@
 #include <linux/cpuset.h>
 #include <linux/efi.h>
 #include <linux/unistd.h>
 #include <linux/rmap.h>
 #include <linux/mempolicy.h>
 #include <linux/key.h>
+#include <linux/delayacct.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
 #include <asm/setup.h>
 #include <asm/sections.h>
 #include <asm/cacheflush.h>
@@ -575,12 +576,13 @@ asmlinkage void __init start_kernel(void
 	/* rootfs populating might need page-writeback */
 	page_writeback_init();
 #ifdef CONFIG_PROC_FS
 	proc_root_init();
 #endif
 	cpuset_init();
+	delayacct_init();
 
 	check_bugs();
 
 	/* Do the rest non-__init'ed, we're now alive */
 	rest_init();
 }
Index: linux-2.6.15/fs/read_write.c
===================================================================
--- linux-2.6.15.orig/fs/read_write.c
+++ linux-2.6.15/fs/read_write.c
@@ -12,12 +12,14 @@
 #include <linux/smp_lock.h>
 #include <linux/fsnotify.h>
 #include <linux/security.h>
 #include <linux/module.h>
 #include <linux/syscalls.h>
 #include <linux/pagemap.h>
+#include <linux/time.h>
+#include <linux/delayacct.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
 struct file_operations generic_ro_fops = {
 	.llseek		= generic_file_llseek,
@@ -233,14 +235,17 @@ ssize_t do_sync_read(struct file *filp, 
 	init_sync_kiocb(&kiocb, filp);
 	kiocb.ki_pos = *ppos;
 	while (-EIOCBRETRY ==
 		(ret = filp->f_op->aio_read(&kiocb, buf, len, kiocb.ki_pos)))
 		wait_on_retry_sync_kiocb(&kiocb);
 
-	if (-EIOCBQUEUED == ret)
+	if (-EIOCBQUEUED == ret) {
+		delayacct_timestamp_start();
 		ret = wait_on_sync_kiocb(&kiocb);
+		delayacct_blkio();
+	}
 	*ppos = kiocb.ki_pos;
 	return ret;
 }
 
 EXPORT_SYMBOL(do_sync_read);
 
Index: linux-2.6.15/mm/filemap.c
===================================================================
--- linux-2.6.15.orig/mm/filemap.c
+++ linux-2.6.15/mm/filemap.c
@@ -26,12 +26,14 @@
 #include <linux/hash.h>
 #include <linux/writeback.h>
 #include <linux/pagevec.h>
 #include <linux/blkdev.h>
 #include <linux/security.h>
 #include <linux/syscalls.h>
+#include <linux/time.h>
+#include <linux/delayacct.h>
 #include "filemap.h"
 /*
  * FIXME: remove all knowledge of the buffer layer from the core VM
  */
 #include <linux/buffer_head.h> /* for generic_osync_inode */
 
@@ -1081,14 +1083,17 @@ generic_file_read(struct file *filp, cha
 	struct iovec local_iov = { .iov_base = buf, .iov_len = count };
 	struct kiocb kiocb;
 	ssize_t ret;
 
 	init_sync_kiocb(&kiocb, filp);
 	ret = __generic_file_aio_read(&kiocb, &local_iov, 1, ppos);
-	if (-EIOCBQUEUED == ret)
+	if (-EIOCBQUEUED == ret) {
+		delayacct_timestamp_start();
 		ret = wait_on_sync_kiocb(&kiocb);
+		delayacct_blkio();
+	}
 	return ret;
 }
 
 EXPORT_SYMBOL(generic_file_read);
 
 int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size)
Index: linux-2.6.15/mm/memory.c
===================================================================
--- linux-2.6.15.orig/mm/memory.c
+++ linux-2.6.15/mm/memory.c
@@ -45,12 +45,14 @@
 #include <linux/swap.h>
 #include <linux/highmem.h>
 #include <linux/pagemap.h>
 #include <linux/rmap.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/time.h>
+#include <linux/delayacct.h>
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
 #include <asm/tlb.h>
 #include <asm/tlbflush.h>
 #include <asm/pgtable.h>
@@ -2206,24 +2208,33 @@ static inline int handle_pte_fault(struc
 	pte_t entry;
 	pte_t old_entry;
 	spinlock_t *ptl;
 
 	old_entry = entry = *pte;
 	if (!pte_present(entry)) {
+		int ret;
+
+		delayacct_timestamp_start();
 		if (pte_none(entry)) {
 			if (!vma->vm_ops || !vma->vm_ops->nopage)
 				return do_anonymous_page(mm, vma, address,
 					pte, pmd, write_access);
-			return do_no_page(mm, vma, address,
+
+			ret = do_no_page(mm, vma, address,
 					pte, pmd, write_access);
+			if (vma->vm_file)
+				delayacct_blkio();
+			return ret;
 		}
 		if (pte_file(entry))
 			return do_file_page(mm, vma, address,
 					pte, pmd, write_access, entry);
-		return do_swap_page(mm, vma, address,
+		ret = do_swap_page(mm, vma, address,
 					pte, pmd, write_access, entry);
+ 		delayacct_swapin();
+		return ret;
 	}
 
 	ptl = pte_lockptr(mm, pmd);
 	spin_lock(ptl);
 	if (unlikely(!pte_same(*pte, entry)))
 		goto unlock;
Index: linux-2.6.15/fs/buffer.c
===================================================================
--- linux-2.6.15.orig/fs/buffer.c
+++ linux-2.6.15/fs/buffer.c
@@ -39,12 +39,14 @@
 #include <linux/bio.h>
 #include <linux/notifier.h>
 #include <linux/cpu.h>
 #include <linux/bitops.h>
 #include <linux/mpage.h>
 #include <linux/bit_spinlock.h>
+#include <linux/time.h>
+#include <linux/delayacct.h>
 
 static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);
 static void invalidate_bh_lrus(void);
 
 #define BH_ENTRY(list) list_entry((list), struct buffer_head, b_assoc_buffers)
 
@@ -342,12 +344,13 @@ static long do_fsync(unsigned int fd, in
 	ret = -EINVAL;
 	if (!file->f_op || !file->f_op->fsync) {
 		/* Why?  We can still call filemap_fdatawrite */
 		goto out_putf;
 	}
 
+	delayacct_timestamp_start();
 	mapping = file->f_mapping;
 
 	current->flags |= PF_SYNCWRITE;
 	ret = filemap_fdatawrite(mapping);
 
 	/*
@@ -364,12 +367,13 @@ static long do_fsync(unsigned int fd, in
 		ret = err;
 	current->flags &= ~PF_SYNCWRITE;
 
 out_putf:
 	fput(file);
 out:
+	delayacct_blkio();
 	return ret;
 }
 
 asmlinkage long sys_fsync(unsigned int fd)
 {
 	return do_fsync(fd, 0);
Index: linux-2.6.15/include/linux/sysctl.h
===================================================================
--- linux-2.6.15.orig/include/linux/sysctl.h
+++ linux-2.6.15/include/linux/sysctl.h
@@ -148,12 +148,14 @@ enum
 	KERN_SPIN_RETRY=70,	/* int: number of spinlock retries */
 	KERN_ACPI_VIDEO_FLAGS=71, /* int: flags for setting up video after ACPI sleep */
 	KERN_IA64_UNALIGNED=72, /* int: ia64 unaligned userland trap enable */
 	KERN_UNSUPPORTED=73,	/* int: allow loading of unsupported modules */
 	KERN_KDB=74,		/* int: kdb on/off */
 	KERN_DUMP=75,		/* directory: dump parameters */
+	KERN_DELAYACCT=76,	/* int: Per-task delay accounting on/off */
+	KERN_SCHEDSTATS=77,	/* int: Schedstats on/off */
 };
 
 
 /* CTL_VM names: */
 enum
 {
Index: linux-2.6.15/kernel/sysctl.c
===================================================================
--- linux-2.6.15.orig/kernel/sysctl.c
+++ linux-2.6.15/kernel/sysctl.c
@@ -43,12 +43,13 @@
 #include <linux/times.h>
 #include <linux/limits.h>
 #include <linux/dcache.h>
 #include <linux/syscalls.h>
 #include <linux/nfs_fs.h>
 #include <linux/acpi.h>
+#include <linux/delayacct.h>
 
 #include <asm/uaccess.h>
 #include <asm/processor.h>
 
 #if defined(CONFIG_SYSCTL)
 
@@ -688,12 +689,32 @@ static ctl_table kern_table[] = {
 		.data		= &no_unaligned_warning,
 		.maxlen		= sizeof (int),
 	 	.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
 #endif
+#if defined(CONFIG_TASK_DELAY_ACCT)
+	{
+		.ctl_name	= KERN_DELAYACCT,
+		.procname	= "delayacct",
+		.data		= &delayacct_on,
+		.maxlen		= sizeof (int),
+		.mode		= 0644,
+		.proc_handler	= &delayacct_sysctl_handler,
+	},
+#endif
+#if defined(CONFIG_SCHEDSTATS)
+	{
+		.ctl_name	= KERN_SCHEDSTATS,
+		.procname	= "schedstats",
+		.data		= &schedstats_sysctl,
+		.maxlen		= sizeof (int),
+		.mode		= 0644,
+		.proc_handler	= &schedstats_sysctl_handler,
+	},
+#endif
 	{ .ctl_name = 0 }
 };
 
 /* Constants for minimum and maximum testing in vm_table.
    We use these as one-element integer vectors. */
 static int zero;
Index: linux-2.6.15/kernel/sched.c
===================================================================
--- linux-2.6.15.orig/kernel/sched.c
+++ linux-2.6.15/kernel/sched.c
@@ -305,24 +305,74 @@ static inline void task_rq_unlock(runque
 	__releases(rq->lock)
 {
 	spin_unlock_irqrestore(&rq->lock, *flags);
 }
 
 #ifdef CONFIG_SCHEDSTATS
+int schedstats_sysctl = 0;
+static DEFINE_PER_CPU(int, schedstats) = 0;
+			/* schedstats turned off by default */
+static void
+schedstats_set(int val)
+{
+	int i;
+	static spinlock_t schedstats_lock = SPIN_LOCK_UNLOCKED;
+
+	spin_lock(&schedstats_lock);
+	schedstats_sysctl = val;
+	for (i = 0; i < NR_CPUS; i++)
+		per_cpu(schedstats, i) = val;
+	spin_unlock(&schedstats_lock);
+}
+
+static int __init schedstats_setup_enable(char *str)
+{
+	schedstats_sysctl = 1;
+	schedstats_set(schedstats_sysctl);
+	return 1;
+}
+
+__setup("schedstats", schedstats_setup_enable);
+
+int
+schedstats_sysctl_handler(ctl_table *table, int write, struct file *filp,
+		void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	int ret, prev = schedstats_sysctl;
+	struct task_struct *g, *t;
+
+	ret = proc_dointvec(table, write, filp, buffer, lenp, ppos);
+	if ((ret != 0) || (prev == schedstats_sysctl))
+		return ret;
+	if (schedstats_sysctl) {
+		read_lock(&tasklist_lock);
+		do_each_thread(g, t) {
+			memset(&t->sched_info, 0, sizeof(t->sched_info));
+		} while_each_thread(g, t);
+		read_unlock(&tasklist_lock);
+	}
+	schedstats_set(schedstats_sysctl);
+	return ret;
+}
+
 /*
  * bump this up when changing the output format or the meaning of an existing
  * format, so that tools can adapt (or abort)
  */
-#define SCHEDSTAT_VERSION 12
+#define SCHEDSTAT_VERSION 13
 
 static int show_schedstat(struct seq_file *seq, void *v)
 {
 	int cpu;
 
 	seq_printf(seq, "version %d\n", SCHEDSTAT_VERSION);
 	seq_printf(seq, "timestamp %lu\n", jiffies);
+	if (!schedstats_sysctl) {
+		seq_printf(seq, "State Off\n");
+		return 0;
+	}
 	for_each_online_cpu(cpu) {
 		runqueue_t *rq = cpu_rq(cpu);
 #ifdef CONFIG_SMP
 		struct sched_domain *sd;
 		int dcnt = 0;
 #endif
@@ -395,14 +445,23 @@ struct file_operations proc_schedstat_op
 	.open    = schedstat_open,
 	.read    = seq_read,
 	.llseek  = seq_lseek,
 	.release = single_release,
 };
 
-# define schedstat_inc(rq, field)	do { (rq)->field++; } while (0)
-# define schedstat_add(rq, field, amt)	do { (rq)->field += (amt); } while (0)
+#define schedstats_on	(per_cpu(schedstats, smp_processor_id()) != 0)
+# define schedstat_inc(rq, field)	\
+do {					\
+	if (unlikely(schedstats_on))	\
+		(rq)->field++;		\
+} while (0)
+# define schedstat_add(rq, field, amt)	\
+do {					\
+	if (unlikely(schedstats_on))	\
+		(rq)->field += (amt);	\
+} while (0)
 #else /* !CONFIG_SCHEDSTATS */
 # define schedstat_inc(rq, field)	do { } while (0)
 # define schedstat_add(rq, field, amt)	do { } while (0)
 #endif
 
 /*
@@ -479,13 +538,13 @@ static void sched_info_arrive(task_t *t)
  * This function is only called from enqueue_task(), but also only updates
  * the timestamp if it is already not set.  It's assumed that
  * sched_info_dequeued() will clear that stamp when appropriate.
  */
 static inline void sched_info_queued(task_t *t)
 {
-	if (!t->sched_info.last_queued)
+	if (unlikely(schedstats_on && !t->sched_info.last_queued))
 		t->sched_info.last_queued = jiffies;
 }
 
 /*
  * Called when a process ceases being the active-running process, either
  * voluntarily or involuntarily.  Now we can calculate how long we ran.
@@ -503,13 +562,13 @@ static inline void sched_info_depart(tas
 
 /*
  * Called when tasks are switched involuntarily due, typically, to expiring
  * their time slice.  (This may also be called when switching to or from
  * the idle task.)  We are only called when prev != next.
  */
-static inline void sched_info_switch(task_t *prev, task_t *next)
+static inline void __sched_info_switch(task_t *prev, task_t *next)
 {
 	struct runqueue *rq = task_rq(prev);
 
 	/*
 	 * prev now departs the cpu.  It's not interesting to record
 	 * stats about how efficient we were at scheduling the idle
@@ -518,12 +577,19 @@ static inline void sched_info_switch(tas
 	if (prev != rq->idle)
 		sched_info_depart(prev);
 
 	if (next != rq->idle)
 		sched_info_arrive(next);
 }
+
+static inline void sched_info_switch(task_t *prev, task_t *next)
+{
+	if (unlikely(schedstats_on))
+		__sched_info_switch(prev, next);
+}
+
 #else
 #define sched_info_queued(t)		do { } while (0)
 #define sched_info_switch(t, next)	do { } while (0)
 #endif /* CONFIG_SCHEDSTATS */
 
 /*
Index: linux-2.6.15/lib/Kconfig.debug
===================================================================
--- linux-2.6.15.orig/lib/Kconfig.debug
+++ linux-2.6.15/lib/Kconfig.debug
@@ -64,13 +64,13 @@ config DETECT_SOFTLOCKUP
 	  (Note that "hard lockups" are separate type of bugs that
 	   can be detected via the NMI-watchdog, on platforms that
 	   support it.)
 
 config SCHEDSTATS
 	bool "Collect scheduler statistics"
-	depends on DEBUG_KERNEL && PROC_FS
+	depends on PROC_FS
 	help
 	  If you say Y here, additional code will be inserted into the
 	  scheduler and related routines to collect statistics about
 	  scheduler behavior and provide them in /proc/schedstat.  These
 	  stats may be useful for both tuning and debugging the scheduler
 	  If you aren't debugging the scheduler or trying to tune a specific
