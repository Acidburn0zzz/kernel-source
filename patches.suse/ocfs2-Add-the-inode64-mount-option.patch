From: Joel Becker <joel.becker@oracle.com>
Subject: ocfs2: Add the 'inode64' mount option.
Patch-mainline: 2.6.28?
References: FATE302877

Now that ocfs2 limits inode numbers to 32bits, add a mount option to
disable the limit.  This parallels XFS.  64bit systems can handle the
larger inode numbers.

[ Added description of inode64 mount option in ocfs2.txt. --Mark ]

Signed-off-by: Joel Becker <joel.becker@oracle.com>
Signed-off-by: Mark Fasheh <mfasheh@suse.com>
---
 Documentation/filesystems/ocfs2.txt |    4 ++++
 fs/ocfs2/ocfs2.h                    |    1 +
 fs/ocfs2/suballoc.c                 |    5 +++--
 fs/ocfs2/super.c                    |   17 +++++++++++++++++
 4 files changed, 25 insertions(+), 2 deletions(-)

Index: linux-2.6.26/Documentation/filesystems/ocfs2.txt
===================================================================
--- linux-2.6.26.orig/Documentation/filesystems/ocfs2.txt
+++ linux-2.6.26/Documentation/filesystems/ocfs2.txt
@@ -76,3 +76,7 @@ localalloc=8(*)		Allows custom localallo
 			large, the fs will silently revert it to the default.
 			Localalloc is not enabled for local mounts.
 localflocks		This disables cluster aware flock.
+inode64			Indicates that Ocfs2 is allowed to create inodes at
+			any location in the filesystem, including those which
+			will result in inode numbers occupying more than 32
+			bits of significance.
Index: linux-2.6.26/fs/ocfs2/ocfs2.h
===================================================================
--- linux-2.6.26.orig/fs/ocfs2/ocfs2.h
+++ linux-2.6.26/fs/ocfs2/ocfs2.h
@@ -185,6 +185,7 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_DATA_WRITEBACK = 1 << 4, /* No data ordering */
 	OCFS2_MOUNT_LOCALFLOCKS = 1 << 5, /* No cluster aware user file locks */
 	OCFS2_MOUNT_NOUSERXATTR = 1 << 6, /* No user xattr */
+	OCFS2_MOUNT_INODE64 = 1 << 7,	/* Allow inode numbers > 2^32 */
 };
 
 #define OCFS2_OSB_SOFT_RO	0x0001
Index: linux-2.6.26/fs/ocfs2/suballoc.c
===================================================================
--- linux-2.6.26.orig/fs/ocfs2/suballoc.c
+++ linux-2.6.26/fs/ocfs2/suballoc.c
@@ -601,9 +601,10 @@ int ocfs2_reserve_new_inode(struct ocfs2
 	/*
 	 * stat(2) can't handle i_ino > 32bits, so we tell the
 	 * lower levels not to allocate us a block group past that
-	 * limit.
+	 * limit.  The 'inode64' mount option avoids this behavior.
 	 */
-	(*ac)->ac_max_block = (u32)~0U;
+	if (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64))
+		(*ac)->ac_max_block = (u32)~0U;
 
 	/*
 	 * slot is set when we successfully steal inode from other nodes.
Index: linux-2.6.26/fs/ocfs2/super.c
===================================================================
--- linux-2.6.26.orig/fs/ocfs2/super.c
+++ linux-2.6.26/fs/ocfs2/super.c
@@ -157,6 +157,7 @@ enum {
 	Opt_stack,
 	Opt_user_xattr,
 	Opt_nouser_xattr,
+	Opt_inode64,
 	Opt_err,
 };
 
@@ -178,6 +179,7 @@ static match_table_t tokens = {
 	{Opt_stack, "cluster_stack=%s"},
 	{Opt_user_xattr, "user_xattr"},
 	{Opt_nouser_xattr, "nouser_xattr"},
+	{Opt_inode64, "inode64"},
 	{Opt_err, NULL}
 };
 
@@ -411,6 +413,15 @@ static int ocfs2_remount(struct super_bl
 		goto out;
 	}
 
+	/* Probably don't want this on remount; it might
+	 * mess with other nodes */
+	if (!(osb->s_mount_opt & OCFS2_MOUNT_INODE64) &&
+	    (parsed_options.mount_opt & OCFS2_MOUNT_INODE64)) {
+		ret = -EINVAL;
+		mlog(ML_ERROR, "Cannot enable inode64 on remount\n");
+		goto out;
+	}
+
 	/* We're going to/from readonly mode. */
 	if ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY)) {
 		/* Lock here so the check of HARD_RO and the potential
@@ -929,6 +940,9 @@ static int ocfs2_parse_options(struct su
 			       OCFS2_STACK_LABEL_LEN);
 			mopt->cluster_stack[OCFS2_STACK_LABEL_LEN] = '\0';
 			break;
+		case Opt_inode64:
+			mopt->mount_opt |= OCFS2_MOUNT_INODE64;
+			break;
 		default:
 			mlog(ML_ERROR,
 			     "Unrecognized mount option \"%s\" "
@@ -996,6 +1010,9 @@ static int ocfs2_show_options(struct seq
 	else
 		seq_printf(s, ",user_xattr");
 
+	if (opts & OCFS2_MOUNT_INODE64)
+		seq_printf(s, ",inode64");
+
 	return 0;
 }
 
