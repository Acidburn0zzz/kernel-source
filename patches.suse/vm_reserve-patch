diff -ur linux-2.6.4-7.org/Documentation/kernel-parameters.txt linux-2.6.4-7.clean/Documentation/kernel-parameters.txt
--- linux-2.6.4-7.org/Documentation/kernel-parameters.txt	2004-03-16 15:10:57.000000000 +0100
+++ linux-2.6.4-7.clean/Documentation/kernel-parameters.txt	2004-03-22 16:28:37.108614488 +0100
@@ -1210,6 +1210,11 @@
 			This is actually a boot loader parameter; the value is
 			passed to the kernel using a special protocol.
 
+	vm_reserve=nn[KM]
+			[KNL,BOOT,IA-32] force use of a specific amount of
+			virtual memory for vmalloc and ioremap allocations
+			minimum 32 MB maximum 800 MB
+
 	vmhalt=		[KNL,S390]
 
 	vmpoff=		[KNL,S390] 
diff -ur linux-2.6.4-7.org/arch/i386/boot/setup.S linux-2.6.4-7.clean/arch/i386/boot/setup.S
--- linux-2.6.4-7.org/arch/i386/boot/setup.S	2004-03-16 15:10:11.000000000 +0100
+++ linux-2.6.4-7.clean/arch/i386/boot/setup.S	2004-03-22 16:28:37.150608104 +0100
@@ -166,7 +166,7 @@
 					# can be located anywhere in
 					# low memory 0x10000 or higher.
 
-ramdisk_max:	.long MAXMEM-1		# (Header version 0x0203 or later)
+ramdisk_max:	.long __MAXMEM-1	# (Header version 0x0203 or later)
 					# The highest safe address for
 					# the contents of an initrd
 
diff -ur linux-2.6.4-7.org/arch/i386/boot98/setup.S linux-2.6.4-7.clean/arch/i386/boot98/setup.S
--- linux-2.6.4-7.org/arch/i386/boot98/setup.S	2004-03-16 15:10:11.000000000 +0100
+++ linux-2.6.4-7.clean/arch/i386/boot98/setup.S	2004-03-22 16:28:37.164605976 +0100
@@ -169,7 +169,7 @@
 					# can be located anywhere in
 					# low memory 0x10000 or higher.
 
-ramdisk_max:	.long MAXMEM-1		# (Header version 0x0203 or later)
+ramdisk_max:	.long __MAXMEM-1	# (Header version 0x0203 or later)
 					# The highest safe address for
 					# the contents of an initrd
 
diff -ur linux-2.6.4-7.org/arch/i386/kernel/setup.c linux-2.6.4-7.clean/arch/i386/kernel/setup.c
--- linux-2.6.4-7.org/arch/i386/kernel/setup.c	2004-03-16 15:10:12.000000000 +0100
+++ linux-2.6.4-7.clean/arch/i386/kernel/setup.c	2004-03-22 16:44:10.226758968 +0100
@@ -97,6 +97,11 @@
 /* For PCI or other memory-mapped resources */
 unsigned long pci_mem_start = 0x10000000;
 
+/* reserved mapping space for vmalloc and ioremap */
+unsigned long vmalloc_reserve = __VMALLOC_RESERVE_DEFAULT;
+EXPORT_SYMBOL(vmalloc_reserve);
+static unsigned long vm_reserve __initdata = -1;
+
 /* user-defined highmem size */
 static unsigned int highmem_pages = -1;
 
@@ -607,6 +612,14 @@
 	
 		if (c == ' ' && !memcmp(from, "crashdump=", 10))
 			crashdump_addr = memparse(from+10, &from); 
+		/*
+		 * vm_reserve=size forces to reserve 'size' bytes for vmalloc and
+		 * ioremap areas minimum is 32 MB maximum is 800 MB
+		 * the default without vm_reserve depends on the total amount of
+		 * memory the minimum default is 128 MB
+		 */
+		if (c == ' ' && !memcmp(from, "vm_reserve=", 11))
+			vm_reserve = memparse(from+11, &from);
 			
 		c = *(from++);
 		if (!c)
@@ -801,7 +814,28 @@
 	start_pfn = PFN_UP(init_pg_tables_end);
 
 	find_max_pfn();
+	
+	/* 
+	 * calculate the default size of vmalloc/ioremap area
+	 * overwrite with the value of the vm_reserve= option
+	 * if set
+	 */
 
+	if (max_pfn >= PFN_UP(KERNEL_MAXMEM - __VMALLOC_RESERVE_DEFAULT))
+		vmalloc_reserve = __VMALLOC_RESERVE_DEFAULT;
+	else
+		vmalloc_reserve = KERNEL_MAXMEM - PFN_PHYS(max_pfn);
+	if (vm_reserve != -1) {
+		if (vm_reserve < __VMALLOC_RESERVE_MIN)
+			vm_reserve = __VMALLOC_RESERVE_MIN;
+		if (vm_reserve > __VMALLOC_RESERVE_MAX)
+			vm_reserve = __VMALLOC_RESERVE_MAX;
+		vmalloc_reserve = vm_reserve;
+	}
+	
+        printk(KERN_NOTICE "%ldMB vmalloc/ioremap area available.\n",
+                        vmalloc_reserve>>20);
+                        	
 	max_low_pfn = find_max_low_pfn();
 
 #ifdef CONFIG_HIGHMEM
diff -ur linux-2.6.4-7.org/arch/i386/mm/discontig.c linux-2.6.4-7.clean/arch/i386/mm/discontig.c
--- linux-2.6.4-7.org/arch/i386/mm/discontig.c	2004-03-16 15:10:11.000000000 +0100
+++ linux-2.6.4-7.clean/arch/i386/mm/discontig.c	2004-03-22 16:28:37.186602632 +0100
@@ -240,6 +240,19 @@
 	system_start_pfn = min_low_pfn = PFN_UP(init_pg_tables_end);
 
 	find_max_pfn();
+	
+	/* Added 2004-03-02, <garloff@suse.de>, copied from i386/setup.c
+	 * but leave out automatic vmalloc size increase ... */
+	if (vm_reserve != -1) {
+		if (vm_reserve < __VMALLOC_RESERVE_MIN)
+			vm_reserve = __VMALLOC_RESERVE_MIN;
+		if (vm_reserve > __VMALLOC_RESERVE_MAX)
+			vm_reserve = __VMALLOC_RESERVE_MAX;
+		vmalloc_reserve = vm_reserve;
+	}
+        printk(KERN_NOTICE "%ldMB vmalloc/ioremap area available.\n",
+                        vmalloc_reserve>>20);
+	 
 	system_max_low_pfn = max_low_pfn = find_max_low_pfn();
 #ifdef CONFIG_HIGHMEM
 	highstart_pfn = highend_pfn = max_pfn;
diff -ur linux-2.6.4-7.org/include/asm-i386/page.h linux-2.6.4-7.clean/include/asm-i386/page.h
--- linux-2.6.4-7.org/include/asm-i386/page.h	2004-03-16 15:11:06.000000000 +0100
+++ linux-2.6.4-7.clean/include/asm-i386/page.h	2004-03-22 16:28:37.217597920 +0100
@@ -94,10 +94,15 @@
  * This much address space is reserved for vmalloc() and iomap()
  * as well as fixmap mappings.
  */
-#define __VMALLOC_RESERVE	(128 << 20)
+#define __VMALLOC_RESERVE_MIN		(32 << 20)
+#define __VMALLOC_RESERVE_DEFAULT	(128 << 20)
+#define __VMALLOC_RESERVE_MAX		(800 << 20)
+#define __RESERVED_AREA			(10 << 20)
 
 #ifndef __ASSEMBLY__
 
+extern unsigned long vmalloc_reserve;
+
 /* Pure 2^n version of get_order */
 static __inline__ int get_order(unsigned long size)
 {
@@ -122,11 +127,14 @@
 
 
 #define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
-#define VMALLOC_RESERVE		((unsigned long)__VMALLOC_RESERVE)
-#define MAXMEM			(-__PAGE_OFFSET-__VMALLOC_RESERVE)
+#define KERNEL_MEMORY		((unsigned long)(FIXADDR_START - __PAGE_OFFSET))
+#define RESERVED_AREA		((unsigned long)__RESERVED_AREA) 
+#define KERNEL_MAXMEM		((unsigned long)(KERNEL_MEMORY - RESERVED_AREA))
+#define __MAXMEM		(-__PAGE_OFFSET-__VMALLOC_RESERVE_MAX)
+#define MAXMEM			((unsigned long)(-PAGE_OFFSET-vmalloc_reserve))
 #define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
 #define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
-#define pfn_to_kaddr(pfn)      __va((pfn) << PAGE_SHIFT)
+#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
 #ifndef CONFIG_DISCONTIGMEM
 #define pfn_to_page(pfn)	(mem_map + (pfn))
 #define page_to_pfn(page)	((unsigned long)((page) - mem_map))
