Index: linux.t/drivers/dump/Makefile
===================================================================
--- linux.t.orig/drivers/dump/Makefile	2004-04-28 13:55:16.000000000 -0400
+++ linux.t/drivers/dump/Makefile	2004-04-28 20:25:46.857792867 -0400
@@ -3,9 +3,14 @@
 #
 
 dump-y					:= dump_setup.o dump_fmt.o dump_filters.o dump_scheme.o dump_execute.o
+ifeq ($(CONFIG_X86_64),)
+ifeq ($(CONFIG_X86),y)
 dump-$(CONFIG_X86)			+= dump_i386.o
+endif
+endif
 dump-$(CONFIG_ARM)			+= dump_arm.o
 dump-$(CONFIG_PPC64)                    += dump_ppc64.o
+dump-$(CONFIG_X86_64)			+= dump_x8664.o
 dump-$(CONFIG_CRASH_DUMP_MEMDEV)	+= dump_memdev.o dump_overlay.o
 dump-objs				+= $(dump-y)
 
Index: linux.t/drivers/dump/dump_memdev.c
===================================================================
--- linux.t.orig/drivers/dump/dump_memdev.c	2004-04-28 13:55:16.000000000 -0400
+++ linux.t/drivers/dump/dump_memdev.c	2004-04-28 20:25:25.443108111 -0400
@@ -103,21 +103,37 @@ void dump_early_reserve_map(struct dump_
 	map1= (unsigned long *)dev->indirect_map_root;
 
 	while (map1 && (off < last)) {
+#ifdef CONFIG_X86_64
+		reserve_bootmem_node(NODE_DATA(0), virt_to_phys((void *)map1),
+				 PAGE_SIZE);
+#else
 		reserve_bootmem(virt_to_phys((void *)map1), PAGE_SIZE);
+#endif
 		for (i=0;  (i < DUMP_MAP_SZ - 1) && map1[i] && (off < last); 
 			i++, off += DUMP_MAP_SZ) {
 			pr_debug("indirect map[%d] = 0x%lx\n", i, map1[i]);
 			if (map1[i] >= max_low_pfn)
 				continue;
+#ifdef CONFIG_X86_64
+			reserve_bootmem_node(NODE_DATA(0), 
+					map1[i] << PAGE_SHIFT, PAGE_SIZE);
+#else
 			reserve_bootmem(map1[i] << PAGE_SHIFT, PAGE_SIZE);
+#endif
 			map2 = pfn_to_kaddr(map1[i]);
 			for (j = 0 ; (j < DUMP_MAP_SZ) && map2[j] && 
 				(off + j < last); j++) {
 				pr_debug("\t map[%d][%d] = 0x%lx\n", i, j, 
 					map2[j]);
 				if (map2[j] < max_low_pfn) {
+#ifdef CONFIG_X86_64
+					reserve_bootmem_node(NODE_DATA(0),
+						map2[j] << PAGE_SHIFT,
+						PAGE_SIZE);
+#else
 					reserve_bootmem(map2[j] << PAGE_SHIFT,
 						PAGE_SIZE);
+#endif
 				}
 			}
 		}
Index: linux.t/drivers/dump/dump_overlay.c
===================================================================
--- linux.t.orig/drivers/dump/dump_overlay.c	2004-04-28 13:55:16.000000000 -0400
+++ linux.t/drivers/dump/dump_overlay.c	2004-04-28 20:25:25.444107816 -0400
@@ -135,8 +135,14 @@ void crashdump_reserve(void)
 			
 	printk("Dump may be available from previous boot\n");
 
+#ifdef CONFIG_X86_64
+	reserve_bootmem_node(NODE_DATA(0), 
+		virt_to_phys((void *)crashdump_addr), 
+		PAGE_ALIGN(sizeof(struct dump_config_block)));
+#else
 	reserve_bootmem(virt_to_phys((void *)crashdump_addr), 
 		PAGE_ALIGN(sizeof(struct dump_config_block)));
+#endif
 	dump_early_reserve_map(&dump_saved_config->memdev);
 
 }
Index: linux.t/drivers/dump/dump_setup.c
===================================================================
--- linux.t.orig/drivers/dump/dump_setup.c	2004-04-28 13:55:25.000000000 -0400
+++ linux.t/drivers/dump/dump_setup.c	2004-04-28 20:25:25.445107521 -0400
@@ -106,6 +106,8 @@
 #include <linux/reboot.h>
 #include <linux/fs.h>
 #include <linux/dump.h>
+#include <linux/ioctl32.h>
+#include <linux/syscalls.h>
 #include "dump_methods.h"
 #include <linux/proc_fs.h>
 #include <linux/module.h>
@@ -159,6 +161,10 @@ struct __dump_compress dump_none_compres
 static int dump_ioctl(struct inode *i, struct file *f,
 	unsigned int cmd, unsigned long arg);
 
+#ifdef CONFIG_COMPAT
+static int dw_long(unsigned int, unsigned int, unsigned long, struct file*);
+#endif
+
 static struct file_operations dump_fops = {
 	.owner	= THIS_MODULE,
 	.ioctl	= dump_ioctl,
@@ -660,6 +666,23 @@ proc_doulonghex(ctl_table *ctl, int writ
  * -----------------------------------------------------------------------
  */
 
+#ifdef CONFIG_COMPAT
+static int dw_long(unsigned int fd, unsigned int cmd, unsigned long arg,
+                struct file *f)
+{
+        mm_segment_t old_fs = get_fs();
+        int err;
+        unsigned long val;
+
+        set_fs (KERNEL_DS);
+        err = sys_ioctl(fd, cmd, (u64)&val);
+        set_fs (old_fs);
+        if (!err && put_user((unsigned int) val, (u32 *)arg))
+               return -EFAULT;
+        return err;
+}
+#endif
+
 /*
  * These register and unregister routines are exported for modules
  * to register their dump drivers (like block, net etc)
@@ -788,6 +811,30 @@ dump_init(void)
 
 	__dump_init((u64)PAGE_OFFSET);
 
+#ifdef CONFIG_COMPAT
+       err = register_ioctl32_conversion(DIOSDUMPDEV, NULL);
+       err |= register_ioctl32_conversion(DIOGDUMPDEV, NULL);
+       err |= register_ioctl32_conversion(DIOSDUMPLEVEL, NULL);
+       err |= register_ioctl32_conversion(DIOGDUMPLEVEL, dw_long);
+       err |= register_ioctl32_conversion(DIOSDUMPFLAGS, NULL);
+       err |= register_ioctl32_conversion(DIOGDUMPFLAGS, dw_long);
+       err |= register_ioctl32_conversion(DIOSDUMPCOMPRESS, NULL);
+       err |= register_ioctl32_conversion(DIOGDUMPCOMPRESS, dw_long);
+       err |= register_ioctl32_conversion(DIOSTARGETIP, NULL);
+       err |= register_ioctl32_conversion(DIOGTARGETIP, NULL);
+       err |= register_ioctl32_conversion(DIOSTARGETPORT, NULL);
+       err |= register_ioctl32_conversion(DIOGTARGETPORT, NULL);
+       err |= register_ioctl32_conversion(DIOSSOURCEPORT, NULL);
+       err |= register_ioctl32_conversion(DIOGSOURCEPORT, NULL);
+       err |= register_ioctl32_conversion(DIOSETHADDR, NULL);
+       err |= register_ioctl32_conversion(DIOGETHADDR, NULL);
+       err |= register_ioctl32_conversion(DIOGDUMPOKAY, dw_long);
+       err |= register_ioctl32_conversion(DIOSDUMPTAKE, NULL);
+       if (err) {
+                printk(KERN_ERR "LKCD: registering ioctl32 translations failed\
+");
+       }
+#endif
 	/* set the dump_compression_list structure up */
 	dump_register_compression(&dump_none_compression);
 
@@ -810,6 +857,7 @@ dump_init(void)
 static void __exit
 dump_cleanup(void)
 {
+	int err;
 	dump_okay = 0;
 
 	if (dump_config.dumper)
@@ -818,6 +866,30 @@ dump_cleanup(void)
 	/* arch-specific cleanup routine */
 	__dump_cleanup();
 
+#ifdef CONFIG_COMPAT
+	err = unregister_ioctl32_conversion(DIOSDUMPDEV);
+	err |= unregister_ioctl32_conversion(DIOGDUMPDEV);
+	err |= unregister_ioctl32_conversion(DIOSDUMPLEVEL);
+	err |= unregister_ioctl32_conversion(DIOGDUMPLEVEL);
+	err |= unregister_ioctl32_conversion(DIOSDUMPFLAGS);
+	err |= unregister_ioctl32_conversion(DIOGDUMPFLAGS);
+	err |= unregister_ioctl32_conversion(DIOSDUMPCOMPRESS);
+	err |= unregister_ioctl32_conversion(DIOGDUMPCOMPRESS);
+	err |= unregister_ioctl32_conversion(DIOSTARGETIP);
+	err |= unregister_ioctl32_conversion(DIOGTARGETIP);
+	err |= unregister_ioctl32_conversion(DIOSTARGETPORT);
+	err |= unregister_ioctl32_conversion(DIOGTARGETPORT);
+	err |= unregister_ioctl32_conversion(DIOSSOURCEPORT);
+	err |= unregister_ioctl32_conversion(DIOGSOURCEPORT);
+	err |= unregister_ioctl32_conversion(DIOSETHADDR);
+	err |= unregister_ioctl32_conversion(DIOGETHADDR);
+	err |= unregister_ioctl32_conversion(DIOGDUMPOKAY);
+	err |= unregister_ioctl32_conversion(DIOSDUMPTAKE);
+	if (err) {
+		printk(KERN_ERR "LKCD: Unregistering ioctl32 translations failed\n");
+	}
+#endif
+
 	/* ignore errors while unregistering -- since can't do anything */
 	unregister_sysctl_table(sysctl_header);
 	misc_deregister(&dump_miscdev);
Index: linux.t/drivers/dump/dump_x8664.c
===================================================================
--- linux.t.orig/drivers/dump/dump_x8664.c	2003-09-23 18:19:32.000000000 -0400
+++ linux.t/drivers/dump/dump_x8664.c	2004-04-28 20:25:25.446107226 -0400
@@ -0,0 +1,318 @@
+/*
+ * Architecture specific (x86-64) functions for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ *
+ * Copyright 1999 Silicon Graphics, Inc. All rights reserved.
+ *
+ * 2.3 kernel modifications by: Matt D. Robinson (yakker@turbolinux.com)
+ * Copyright 2000 TurboLinux, Inc.  All rights reserved.
+ *
+ * x86-64 port Copyright 2002 Andi Kleen, SuSE Labs
+ * x86-64 port Sachin Sant ( sachinp@in.ibm.com )
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/*
+ * The hooks for dumping the kernel virtual memory to disk are in this
+ * file.  Any time a modification is made to the virtual memory mechanism,
+ * these routines must be changed to use the new mechanisms.
+ */
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/smp.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/dump.h>
+#include "dump_methods.h"
+#include <linux/mm.h>
+#include <asm/processor.h>
+#include <asm/hardirq.h>
+#include <asm/kdebug.h>
+#include <asm/uaccess.h>
+#include <asm/nmi.h>
+
+static __s32 	saved_irq_count; /* saved preempt_count() flag */
+
+void (*dump_trace_ptr)(struct pt_regs *);
+
+static int alloc_dha_stack(void)
+{
+	int i;
+	void *ptr;
+	
+	if (dump_header_asm.dha_stack[0])
+		return 0;
+
+       	ptr = vmalloc(THREAD_SIZE * num_online_cpus());
+	if (!ptr) {
+		printk("vmalloc for dha_stacks failed\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < num_online_cpus(); i++) {
+		dump_header_asm.dha_stack[i] = 
+			(uint64_t)((unsigned long)ptr + (i * THREAD_SIZE));
+	}
+	return 0;
+}
+
+static int free_dha_stack(void) 
+{
+	if (dump_header_asm.dha_stack[0]) {
+		vfree((void *)dump_header_asm.dha_stack[0]);	
+		dump_header_asm.dha_stack[0] = 0;
+	}	
+	return 0;
+}
+
+void
+__dump_save_regs(struct pt_regs* dest_regs, const struct pt_regs* regs)
+{
+	if (regs)
+		memcpy(dest_regs, regs, sizeof(struct pt_regs));
+}
+
+#ifdef CONFIG_SMP
+extern unsigned long irq_affinity[];
+extern irq_desc_t irq_desc[];
+extern void dump_send_ipi(void);
+static int dump_expect_ipi[NR_CPUS];
+static atomic_t waiting_for_dump_ipi;
+static unsigned long saved_affinity[NR_IRQS];
+
+extern void stop_this_cpu(void *);
+
+static int
+dump_nmi_callback(struct pt_regs *regs, int cpu) 
+{
+	if (!dump_expect_ipi[cpu]) {
+		return 0;
+	}
+	
+	dump_expect_ipi[cpu] = 0;
+
+	dump_save_this_cpu(regs);
+	atomic_dec(&waiting_for_dump_ipi);
+
+level_changed:
+
+	switch (dump_silence_level) {
+        case DUMP_HARD_SPIN_CPUS:       /* Spin until dump is complete */
+                while (dump_oncpu) {
+                        barrier();      /* paranoia */
+                        if (dump_silence_level != DUMP_HARD_SPIN_CPUS)
+                                goto level_changed;
+
+                        cpu_relax();    /* kill time nicely */
+                }
+                break;
+
+        case DUMP_HALT_CPUS:            /* Execute halt */
+                stop_this_cpu(NULL);
+                break;
+
+        case DUMP_SOFT_SPIN_CPUS:
+                /* Mark the task so it spins in schedule */
+                set_tsk_thread_flag(current, TIF_NEED_RESCHED);
+                break;
+        }
+
+	return 1;
+}
+
+/* save registers on other processors */
+void 
+__dump_save_other_cpus(void) 
+{
+	int i, cpu = smp_processor_id();
+	int other_cpus = num_online_cpus() - 1;
+
+	if (other_cpus > 0) {
+		atomic_set(&waiting_for_dump_ipi, other_cpus);
+
+		for (i = 0; i < NR_CPUS; i++)
+			dump_expect_ipi[i] = (i != cpu && cpu_online(i));
+		
+		set_nmi_callback(dump_nmi_callback);
+		wmb();
+
+		dump_send_ipi();
+
+		/* may be we dont need to wait for NMI to be processed. 
+		   just write out the header at the end of dumping, if
+		   this IPI is not processed untill then, there probably
+		   is a problem and we just fail to capture state of 
+		   other cpus. */
+		while(atomic_read(&waiting_for_dump_ipi) > 0)
+			cpu_relax();
+
+		unset_nmi_callback();
+	}
+	return;
+}
+/*
+ * Routine to save the old irq affinities and change affinities of all irqs to
+ * the dumping cpu.
+ */
+static void
+set_irq_affinity(void)
+{
+	int i;
+	int cpu = smp_processor_id();
+
+	memcpy(saved_affinity, irq_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		irq_affinity[i] = 1UL << cpu;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, irq_affinity[i]);
+	}
+}
+
+/*
+ * Restore old irq affinities.
+ */
+static void
+reset_irq_affinity(void)
+{
+	int i;
+
+	memcpy(irq_affinity, saved_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, saved_affinity[i]);
+	}
+}
+
+#else /* !CONFIG_SMP */
+#define set_irq_affinity()	do { } while (0)
+#define reset_irq_affinity()	do { } while (0)
+#define save_other_cpu_states() do { } while (0)
+#endif /* !CONFIG_SMP */
+
+static inline void
+irq_bh_save(void)
+{
+	saved_irq_count = irq_count();
+	preempt_count() &= ~(HARDIRQ_MASK|SOFTIRQ_MASK);
+}
+
+static inline void
+irq_bh_restore(void)
+{
+	preempt_count() |= saved_irq_count;
+}
+
+/*
+ * Name: __dump_irq_enable
+ * Func: Reset system so interrupts are enabled.
+ *       This is used for dump methods that require interrupts
+ *       Eventually, all methods will have interrupts disabled
+ *       and this code can be removed.
+ *
+ *     Change irq affinities
+ *     Re-enable interrupts
+ */
+int
+__dump_irq_enable(void)
+{
+        set_irq_affinity();
+        irq_bh_save();
+        local_irq_enable();
+	return 0;
+}
+
+/*
+ * Name: __dump_irq_restore
+ * Func: Resume the system state in an architecture-speeific way.
+ *
+ */
+void
+__dump_irq_restore(void)
+{
+        local_irq_disable();
+        reset_irq_affinity();
+        irq_bh_restore();
+}
+
+/*
+ * Name: __dump_configure_header()
+ * Func: Configure the dump header with all proper values.
+ */
+int
+__dump_configure_header(const struct pt_regs *regs)
+{
+	/* Dummy function - return */
+	return (0);
+}
+
+/*
+ * Name: __dump_init()
+ * Func: Initialize the dumping routine process.  This is in case
+ *       it's necessary in the future.
+ */
+void
+__dump_init(uint64_t local_memory_start)
+{
+	/* return */
+	return;
+}
+
+/*
+ * Name: __dump_open()
+ * Func: Open the dump device (architecture specific).  This is in
+ *       case it's necessary in the future.
+ */
+void
+__dump_open(void)
+{
+	alloc_dha_stack();
+	/* return */
+	return;
+}
+
+/*
+ * Name: __dump_cleanup()
+ * Func: Free any architecture specific data structures. This is called
+ *       when the dump module is being removed.
+ */
+void
+__dump_cleanup(void)
+{
+	free_dha_stack();
+	return;
+}
+
+extern int page_is_ram(unsigned long);
+
+/*
+ * Name: __dump_page_valid()
+ * Func: Check if page is valid to dump.
+ */
+int
+__dump_page_valid(unsigned long index)
+{
+	if (!pfn_valid(index))
+		return 0;
+
+	return page_is_ram(index);
+}
+
+/*
+ * Name: manual_handle_crashdump()
+ * Func: Interface for the lkcd dump command. Calls dump_execute()
+ */
+int
+manual_handle_crashdump(void) {
+
+        struct pt_regs regs;
+
+        get_current_regs(&regs);
+        dump_execute("manual", &regs);
+        return 0;
+}
