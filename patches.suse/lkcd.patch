From: SGI
Subject: lkcd
Patch-mainline: never
References: 142097

Acked-by: Chris Mason <mason@suse.com>

 arch/i386/Kconfig.debug                     |   40 +
 arch/i386/kernel/i386_ksyms.c               |   20 
 arch/i386/kernel/smp.c                      |   27 
 arch/i386/kernel/traps.c                    |    4 
 arch/ia64/Kconfig.debug                     |   40 +
 arch/ia64/kernel/ia64_ksyms.c               |   17 
 arch/ia64/kernel/smp.c                      |   30 
 arch/ia64/kernel/traps.c                    |    8 
 arch/powerpc/Kconfig.debug                  |   39 +
 arch/powerpc/kernel/ppc_ksyms.c             |   12 
 arch/powerpc/kernel/smp.c                   |   25 
 arch/powerpc/kernel/traps.c                 |    2 
 arch/powerpc/mm/lmb.c                       |   28 
 arch/powerpc/platforms/pseries/xics.c       |    2 
 arch/s390/Kconfig.debug                     |    9 
 arch/s390/boot/install.sh                   |   15 
 arch/x86_64/Kconfig.debug                   |   41 +
 arch/x86_64/kernel/nmi.c                    |    1 
 arch/x86_64/kernel/smp.c                    |   19 
 arch/x86_64/kernel/traps.c                  |    3 
 arch/x86_64/kernel/x8664_ksyms.c            |   15 
 block/ll_rw_blk.c                           |    6 
 drivers/Makefile                            |    1 
 drivers/dump/Makefile                       |   21 
 drivers/dump/dump_blockdev.c                |  880 ++++++++++++++++++++++++++++
 drivers/dump/dump_execute.c                 |  139 ++++
 drivers/dump/dump_filters.c                 |  146 ++++
 drivers/dump/dump_fmt.c                     |  396 ++++++++++++
 drivers/dump/dump_gzip.c                    |  173 +++++
 drivers/dump/dump_i386.c                    |  386 ++++++++++++
 drivers/dump/dump_ia64.c                    |  468 ++++++++++++++
 drivers/dump/dump_methods.h                 |  339 ++++++++++
 drivers/dump/dump_netdev.c                  |  576 ++++++++++++++++++
 drivers/dump/dump_ppc64.c                   |  420 +++++++++++++
 drivers/dump/dump_rle.c                     |  176 +++++
 drivers/dump/dump_scheme.c                  |  428 +++++++++++++
 drivers/dump/dump_setup.c                   |  844 ++++++++++++++++++++++++++
 drivers/dump/dump_x8664.c                   |  376 +++++++++++
 drivers/message/fusion/mptbase.c            |   21 
 drivers/message/fusion/mptbase.h            |   24 
 drivers/message/fusion/mptfc.c              |    1 
 drivers/message/fusion/mptscsih.c           |   25 
 drivers/message/fusion/mptscsih.h           |    2 
 drivers/message/fusion/mptspi.c             |    1 
 drivers/net/Kconfig                         |    2 
 drivers/scsi/Kconfig                        |   12 
 drivers/scsi/Makefile                       |    2 
 drivers/scsi/qla1280.c                      |   27 
 drivers/scsi/qla2xxx/qla_os.c               |   17 
 drivers/scsi/sata_vsc.c                     |   32 +
 drivers/scsi/scsi.c                         |    4 
 drivers/scsi/scsi_dump.c                    |  438 +++++++++++++
 drivers/scsi/scsi_error.c                   |    6 
 drivers/scsi/scsi_priv.h                    |    1 
 include/asm-alpha/kerntypes.h               |   21 
 include/asm-arm/kerntypes.h                 |   21 
 include/asm-arm26/kerntypes.h               |   21 
 include/asm-cris/kerntypes.h                |   21 
 include/asm-generic/kerntypes.h             |   20 
 include/asm-h8300/kerntypes.h               |   21 
 include/asm-i386/dump.h                     |   92 ++
 include/asm-i386/kerntypes.h                |   21 
 include/asm-i386/kmap_types.h               |    3 
 include/asm-i386/mach-default/irq_vectors.h |    1 
 include/asm-ia64/dump.h                     |  206 ++++++
 include/asm-ia64/kerntypes.h                |   21 
 include/asm-m68k/kerntypes.h                |   21 
 include/asm-m68knommu/kerntypes.h           |   21 
 include/asm-mips/kerntypes.h                |   21 
 include/asm-mips64/kerntypes.h              |   21 
 include/asm-parisc/kerntypes.h              |   21 
 include/asm-powerpc/dump.h                  |  117 +++
 include/asm-powerpc/kerntypes.h             |   21 
 include/asm-powerpc/kmap_types.h            |    3 
 include/asm-ppc/kerntypes.h                 |   21 
 include/asm-s390/dump.h                     |   12 
 include/asm-s390/kerntypes.h                |   46 +
 include/asm-sh/kerntypes.h                  |   21 
 include/asm-sparc/kerntypes.h               |   21 
 include/asm-sparc64/kerntypes.h             |   21 
 include/asm-um/kerntypes.h                  |   21 
 include/asm-v850/kerntypes.h                |   21 
 include/asm-x86_64/dump.h                   |   94 ++
 include/asm-x86_64/hw_irq.h                 |    7 
 include/asm-x86_64/ipi.h                    |   18 
 include/asm-x86_64/kerntypes.h              |   21 
 include/asm-x86_64/kmap_types.h             |    3 
 include/linux/diskdump.h                    |  103 +++
 include/linux/dump.h                        |  443 ++++++++++++++
 include/linux/dump_netdev.h                 |   80 ++
 include/linux/dumpdev.h                     |  167 +++++
 include/linux/interrupt.h                   |    3 
 include/linux/miscdevice.h                  |    1 
 include/linux/sched.h                       |   83 ++
 include/linux/sysctl.h                      |    1 
 include/linux/timer.h                       |    3 
 include/linux/workqueue.h                   |    3 
 include/scsi/scsi_eh.h                      |    1 
 include/scsi/scsi_host.h                    |   32 +
 init/Makefile                               |   13 
 init/kerntypes.c                            |   40 +
 init/main.c                                 |    9 
 init/version.c                              |    4 
 kernel/panic.c                              |    5 
 kernel/sched.c                              |  110 ---
 kernel/softirq.c                            |   32 +
 kernel/timer.c                              |   43 +
 kernel/workqueue.c                          |   36 +
 mm/bootmem.c                                |    1 
 mm/page_alloc.c                             |    6 
 scripts/mkcompile_h                         |    4 
 111 files changed, 8933 insertions(+), 119 deletions(-)

Index: linux-2.6.15/arch/i386/Kconfig.debug
===================================================================
--- linux-2.6.15.orig/arch/i386/Kconfig.debug	2006-02-12 16:58:07.205970048 +0100
+++ linux-2.6.15/arch/i386/Kconfig.debug	2006-02-12 16:58:13.781952568 +0100
@@ -2,6 +2,46 @@ menu "Kernel hacking"
 
 source "lib/Kconfig.debug"
 
+config LKCD_DUMP
+	tristate "LKCD crash dump support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	default n
+	---help---
+	  Say Y here to enable saving an image of system memory when a panic
+	  or other error occurs. Dumps can also be forced with the SysRq+d
+	  key if MAGIC_SYSRQ is enabled.
+
+config KERNTYPES
+	bool
+	depends on LKCD_DUMP
+	default y
+
+config LKCD_DUMP_BLOCKDEV
+	tristate "LKCD crash dump block device driver"
+	depends on LKCD_DUMP
+	help
+	  Say Y to allow saving crash dumps directly to a disk device.
+
+config LKCD_DUMP_NETDEV
+	tristate "LKCD crash dump network device driver"
+	depends on LKCD_DUMP
+	help
+	  Say Y to allow saving crash dumps over a network device.
+
+config LKCD_DUMP_COMPRESS_RLE
+	tristate "LKCD crash dump RLE compression"
+	depends on LKCD_DUMP
+	help
+	  Say Y to allow saving dumps with Run Length Encoding compression.
+
+config LKCD_DUMP_COMPRESS_GZIP
+	tristate "LKCD crash dump GZIP compression"
+	select ZLIB_INFLATE
+	select ZLIB_DEFLATE
+	depends on LKCD_DUMP
+	help
+	  Say Y to allow saving dumps with Gnu Zip compression.
+
 config EARLY_PRINTK
 	bool "Early printk" if EMBEDDED && DEBUG_KERNEL
 	default y
Index: linux-2.6.15/arch/i386/kernel/i386_ksyms.c
===================================================================
--- linux-2.6.15.orig/arch/i386/kernel/i386_ksyms.c	2006-02-12 16:57:41.114039591 +0100
+++ linux-2.6.15/arch/i386/kernel/i386_ksyms.c	2006-02-12 16:58:13.781952568 +0100
@@ -1,5 +1,7 @@
 #include <linux/config.h>
 #include <linux/module.h>
+#include <linux/nmi.h>
+#include <linux/irq.h>
 #include <asm/checksum.h>
 #include <asm/desc.h>
 
@@ -32,3 +34,21 @@ EXPORT_SYMBOL(__read_lock_failed);
 #endif
 
 EXPORT_SYMBOL(csum_partial);
+
+#ifdef CONFIG_LKCD_DUMP_MODULE
+#ifdef CONFIG_SMP
+extern irq_desc_t irq_desc[NR_IRQS];
+extern cpumask_t irq_affinity[NR_IRQS];
+extern void stop_this_cpu(void *);
+extern void dump_send_ipi(void);
+EXPORT_SYMBOL_GPL(irq_desc);
+EXPORT_SYMBOL_GPL(irq_affinity);
+EXPORT_SYMBOL_GPL(stop_this_cpu);
+EXPORT_SYMBOL_GPL(dump_send_ipi);
+#endif
+extern int page_is_ram(unsigned long);
+EXPORT_SYMBOL_GPL(page_is_ram);
+#ifdef ARCH_HAS_NMI_WATCHDOG
+EXPORT_SYMBOL_GPL(touch_nmi_watchdog);
+#endif
+#endif
Index: linux-2.6.15/arch/i386/kernel/smp.c
===================================================================
--- linux-2.6.15.orig/arch/i386/kernel/smp.c	2006-02-12 16:58:07.249969931 +0100
+++ linux-2.6.15/arch/i386/kernel/smp.c	2006-02-12 16:58:13.781952568 +0100
@@ -20,6 +20,7 @@
 #include <linux/interrupt.h>
 #include <linux/cpu.h>
 #include <linux/module.h>
+#include <linux/dump.h>
 
 #include <asm/mtrr.h>
 #include <asm/tlbflush.h>
@@ -148,6 +149,14 @@ void __send_IPI_shortcut(unsigned int sh
 	 */
 	cfg = __prepare_ICR(shortcut, vector);
 
+	if (vector == DUMP_VECTOR) {
+		/*
+		 * Setup DUMP IPI to be delivered as an NMI
+		 */
+		cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
+	}
+
+
 #ifdef	CONFIG_KDB
 	if (vector == KDB_VECTOR) {
 		/*
@@ -243,7 +252,15 @@ void send_IPI_mask_sequence(cpumask_t ma
 				cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
 			}
 #endif	/* CONFIG_KDB */
-			
+
+
+			if (vector == DUMP_VECTOR) {
+				/*
+				 * Setup DUMP IPI to be delivered as an NMI
+				 */
+				cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
+			}
+
 			/*
 			 * Send the IPI. The write to APIC_ICR fires this off.
 			 */
@@ -538,6 +555,11 @@ void unlock_ipi_call_lock(void)
 
 static struct call_data_struct * call_data;
 
+void dump_send_ipi(void)
+{
+	send_IPI_allbutself(DUMP_VECTOR);
+}
+
 /*
  * this function sends a 'generic call function' IPI to all other CPUs
  * in the system.
@@ -598,7 +620,7 @@ int smp_call_function (void (*func) (voi
 }
 EXPORT_SYMBOL(smp_call_function);
 
-static void stop_this_cpu (void * dummy)
+void stop_this_cpu (void * dummy)
 {
 	/*
 	 * Remove this CPU:
@@ -659,4 +681,3 @@ fastcall void smp_call_function_interrup
 		atomic_inc(&call_data->finished);
 	}
 }
-
Index: linux-2.6.15/arch/i386/kernel/traps.c
===================================================================
--- linux-2.6.15.orig/arch/i386/kernel/traps.c	2006-02-12 16:58:10.985959998 +0100
+++ linux-2.6.15/arch/i386/kernel/traps.c	2006-02-12 16:58:13.785952557 +0100
@@ -28,6 +28,7 @@
 #include <linux/utsname.h>
 #include <linux/kprobes.h>
 #include <linux/kexec.h>
+#include <linux/dump.h>
 
 #ifdef CONFIG_EISA
 #include <linux/ioport.h>
@@ -392,6 +393,8 @@ void die(const char * str, struct pt_reg
 	if (kexec_should_crash(current))
 		crash_kexec(regs);
 
+	dump((char *)str, regs);
+
 	if (in_interrupt())
 		panic("Fatal exception in interrupt");
 
@@ -637,6 +640,7 @@ void die_nmi (struct pt_regs *regs, cons
 	kdb(KDB_REASON_NMI, 0, regs);
 #endif	/* CONFIG_KDB */
 	printk(KERN_EMERG "console shuts up ...\n");
+	dump((char *)msg, regs);
 	console_silent();
 	spin_unlock(&nmi_print_lock);
 	bust_spinlocks(0);
Index: linux-2.6.15/arch/ia64/Kconfig.debug
===================================================================
--- linux-2.6.15.orig/arch/ia64/Kconfig.debug	2006-02-12 16:58:07.317969750 +0100
+++ linux-2.6.15/arch/ia64/Kconfig.debug	2006-02-12 16:58:13.785952557 +0100
@@ -2,6 +2,46 @@ menu "Kernel hacking"
 
 source "lib/Kconfig.debug"
 
+config LKCD_DUMP
+       tristate "LKCD crash dump support (EXPERIMENTAL)"
+       depends on EXPERIMENTAL
+       default n
+       ---help---
+         Say Y here to enable saving an image of system memory when a panic
+         or other error occurs. Dumps can also be forced with the SysRq+d
+         key if MAGIC_SYSRQ is enabled.
+
+config KERNTYPES
+        bool
+        depends on LKCD_DUMP
+        default y
+
+config LKCD_DUMP_BLOCKDEV
+       tristate "LKCD crash dump block device driver"
+       depends on LKCD_DUMP
+       help
+         Say Y to allow saving crash dumps directly to a disk device.
+
+config LKCD_DUMP_NETDEV
+       tristate "LKCD crash dump network device driver"
+       depends on LKCD_DUMP
+       help
+        Say Y to allow saving crash dumps over a network device.
+
+config LKCD_DUMP_COMPRESS_RLE
+       tristate "LKCD crash dump RLE compression"
+       depends on LKCD_DUMP
+       help
+         Say Y to allow saving dumps with Run Length Encoding compression.
+
+config LKCD_DUMP_COMPRESS_GZIP
+       tristate "LKCD crash dump GZIP compression"
+       select ZLIB_INFLATE
+       select ZLIB_DEFLATE
+       depends on LKCD_DUMP
+       help
+         Say Y to allow saving dumps with Gnu Zip compression.
+
 choice
 	prompt "Physical memory granularity"
 	default IA64_GRANULE_64MB
Index: linux-2.6.15/arch/ia64/kernel/ia64_ksyms.c
===================================================================
--- linux-2.6.15.orig/arch/ia64/kernel/ia64_ksyms.c	2006-02-12 16:57:41.250039228 +0100
+++ linux-2.6.15/arch/ia64/kernel/ia64_ksyms.c	2006-02-12 17:03:50.269082781 +0100
@@ -42,7 +42,6 @@ EXPORT_SYMBOL(clear_page);
 
 #ifdef CONFIG_VIRTUAL_MEM_MAP
 #include <linux/bootmem.h>
-EXPORT_SYMBOL(min_low_pfn);	/* defined by bootmem.c, but not exported by generic code */
 EXPORT_SYMBOL(max_low_pfn);	/* defined by bootmem.c, but not exported by generic code */
 #endif
 
@@ -123,3 +122,19 @@ EXPORT_SYMBOL(ia64_spinlock_contention);
 
 extern char ia64_ivt[];
 EXPORT_SYMBOL(ia64_ivt);
+
+#include <asm/hw_irq.h>
+
+#ifdef CONFIG_LKCD_DUMP_MODULE
+#ifdef CONFIG_SMP
+extern cpumask_t irq_affinity[NR_IRQS];
+extern void stop_this_cpu(void *);
+extern int (*dump_ipi_function_ptr)(struct pt_regs *);
+extern void dump_send_ipi(void);
+EXPORT_SYMBOL_GPL(irq_desc);
+EXPORT_SYMBOL_GPL(irq_affinity);
+EXPORT_SYMBOL_GPL(stop_this_cpu);
+EXPORT_SYMBOL_GPL(dump_send_ipi);
+EXPORT_SYMBOL_GPL(dump_ipi_function_ptr);
+#endif
+#endif
Index: linux-2.6.15/arch/ia64/kernel/smp.c
===================================================================
--- linux-2.6.15.orig/arch/ia64/kernel/smp.c	2006-02-12 16:58:07.433969442 +0100
+++ linux-2.6.15/arch/ia64/kernel/smp.c	2006-02-12 16:58:13.785952557 +0100
@@ -31,6 +31,10 @@
 #include <linux/efi.h>
 #include <linux/bitops.h>
 
+#if defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
+#include <linux/dump.h>
+#endif
+
 #include <asm/atomic.h>
 #include <asm/current.h>
 #include <asm/delay.h>
@@ -75,6 +79,11 @@ static volatile struct call_data_struct 
 #define IPI_KDB_INTERRUPT	2
 #endif	/* CONFIG_KDB */
 
+#if defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
+#define IPI_DUMP_INTERRUPT      4
+	int (*dump_ipi_function_ptr)(struct pt_regs *) = NULL;
+#endif
+
 /* This needs to be cacheline aligned because it is written to by *other* CPUs.  */
 static DEFINE_PER_CPU(u64, ipi_operation) ____cacheline_aligned;
 
@@ -92,7 +101,9 @@ unlock_ipi_calllock(void)
 	spin_unlock_irq(&call_lock);
 }
 
-static void
+
+/*changed static void stop_this_cpu -> void stop_this_cpu */
+void
 stop_this_cpu (void)
 {
 	/*
@@ -163,6 +174,15 @@ handle_IPI (int irq, void *dev_id, struc
 			      case IPI_CPU_STOP:
 				stop_this_cpu();
 				break;
+#if defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
+			case IPI_DUMP_INTERRUPT:
+                        if( dump_ipi_function_ptr != NULL ) {
+                                if (!dump_ipi_function_ptr(regs)) {
+                                         printk(KERN_ERR "(*dump_ipi_function_ptr)(): rejected IPI_DUMP_INTERRUPT\n");
+                                }
+                        }
+                        break;
+#endif
 
 #ifdef CONFIG_KDB
 			      case IPI_KDB_INTERRUPT:
@@ -386,6 +406,7 @@ smp_send_stop (void)
 {
 	send_IPI_allbutself(IPI_CPU_STOP);
 }
+EXPORT_SYMBOL_GPL(smp_send_stop);
 
 int __init
 setup_profiling_timer (unsigned int multiplier)
@@ -401,3 +422,10 @@ smp_kdb_stop(void)
 		send_IPI_allbutself(IPI_KDB_INTERRUPT);
 }
 #endif	/* CONFIG_KDB */
+
+#if defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
+void dump_send_ipi(void)
+{
+	send_IPI_allbutself(IPI_DUMP_INTERRUPT);
+}
+#endif
Index: linux-2.6.15/arch/ia64/kernel/traps.c
===================================================================
--- linux-2.6.15.orig/arch/ia64/kernel/traps.c	2006-02-12 16:58:07.433969442 +0100
+++ linux-2.6.15/arch/ia64/kernel/traps.c	2006-02-12 16:58:13.785952557 +0100
@@ -19,6 +19,7 @@
 #include <linux/hardirq.h>
 #include <linux/kprobes.h>
 #include <linux/delay.h>		/* for ssleep() */
+#include <linux/dump.h>
 
 #include <asm/fpswa.h>
 #include <asm/ia32.h>
@@ -113,15 +114,16 @@ die (const char *str, struct pt_regs *re
 			current->comm, current->pid, str, err, ++die_counter);
 		(void) notify_die(DIE_OOPS, (char *)str, regs, err, 255, SIGSEGV);
 		show_regs(regs);
+#ifdef	CONFIG_KDB
+		(void)kdb(KDB_REASON_OOPS, err, regs);
+#endif	/* CONFIG_KDB */
+		dump((char *)str, regs);
   	} else
 		printk(KERN_ERR "Recursive die() failure, output suppressed\n");
 
 	bust_spinlocks(0);
 	die.lock_owner = -1;
 	spin_unlock_irq(&die.lock);
-#ifdef	CONFIG_KDB
-	(void)kdb(KDB_REASON_OOPS, err, regs);
-#endif	/* CONFIG_KDB */
 
 	if (panic_on_oops) {
 		printk(KERN_EMERG "Fatal exception: panic in 5 seconds\n");
Index: linux-2.6.15/arch/powerpc/Kconfig.debug
===================================================================
--- linux-2.6.15.orig/arch/powerpc/Kconfig.debug	2006-02-12 16:58:06.813971091 +0100
+++ linux-2.6.15/arch/powerpc/Kconfig.debug	2006-02-12 16:58:13.785952557 +0100
@@ -2,6 +2,45 @@ menu "Kernel hacking"
 
 source "lib/Kconfig.debug"
 
+config KERNTYPES
+	bool
+	depends on LKCD_DUMP
+	default y
+
+config LKCD_DUMP
+	tristate "LKCD crash dump support"
+	default n
+	---help---
+	   Say Y here to enable saving an image of system memory when a panic
+	   or other error occurs. Dumps can also be forced with the SysRq+d
+	   key if MAGIC_SYSRQ is enabled.
+
+config LKCD_DUMP_BLOCKDEV
+	tristate "LKCD crash dump block device driver"
+	depends on LKCD_DUMP
+	help
+	  Say Y to allow saving crash dumps directly to a disk device.
+
+config LKCD_DUMP_NETDEV
+	tristate "LKCD crash dump network device driver"
+	depends on LKCD_DUMP
+	help
+	  Say Y to allow saving crash dumps over a network device.
+
+config LKCD_DUMP_COMPRESS_RLE
+	tristate "LKCD crash dump RLE compression"
+	depends on LKCD_DUMP
+	help
+	  Say Y to allow saving dumps with Run Length Encoding compression.
+
+config LKCD_DUMP_COMPRESS_GZIP
+	tristate "LKCD crash dump GZIP compression"
+	select ZLIB_INFLATE
+	select ZLIB_DEFLATE
+	depends on LKCD_DUMP
+	help
+	  Say Y to allow saving dumps with Gnu Zip compression.
+
 config DEBUG_STACKOVERFLOW
 	bool "Check for stack overflows"
 	depends on DEBUG_KERNEL && PPC64
Index: linux-2.6.15/arch/powerpc/kernel/ppc_ksyms.c
===================================================================
--- linux-2.6.15.orig/arch/powerpc/kernel/ppc_ksyms.c	2006-02-12 16:57:41.914037455 +0100
+++ linux-2.6.15/arch/powerpc/kernel/ppc_ksyms.c	2006-02-12 16:58:13.785952557 +0100
@@ -254,3 +254,15 @@ EXPORT_SYMBOL(intercept_table);
 EXPORT_SYMBOL(__mtdcr);
 EXPORT_SYMBOL(__mfdcr);
 #endif
+
+#ifdef CONFIG_LKCD_DUMP_MODULE
+extern int dump_page_is_ram(unsigned long);
+EXPORT_SYMBOL_GPL(dump_page_is_ram);
+#ifdef CONFIG_SMP
+EXPORT_SYMBOL_GPL(irq_affinity);
+extern void stop_this_cpu(void *);
+extern void dump_send_ipi(int (*dump_ipi_callback)(struct pt_regs *));
+EXPORT_SYMBOL_GPL(stop_this_cpu);
+EXPORT_SYMBOL_GPL(dump_send_ipi);
+#endif
+#endif
Index: linux-2.6.15/arch/powerpc/kernel/smp.c
===================================================================
--- linux-2.6.15.orig/arch/powerpc/kernel/smp.c	2006-02-12 16:58:04.565977071 +0100
+++ linux-2.6.15/arch/powerpc/kernel/smp.c	2006-02-12 16:58:13.785952557 +0100
@@ -28,6 +28,7 @@
 #include <linux/spinlock.h>
 #include <linux/cache.h>
 #include <linux/err.h>
+#include <linux/dump.h>
 #include <linux/sysdev.h>
 #include <linux/cpu.h>
 #include <linux/notifier.h>
@@ -71,6 +72,7 @@ EXPORT_SYMBOL(cpu_possible_map);
 struct smp_ops_t *smp_ops;
 
 static volatile unsigned int cpu_callin_map[NR_CPUS];
+static int (*dump_ipi_function_ptr)(struct pt_regs *) = NULL;
 
 void smp_call_function_interrupt(void);
 
@@ -126,16 +128,22 @@ void smp_message_recv(int msg, struct pt
 		/* XXX Do we have to do this? */
 		set_need_resched();
 		break;
+#if defined(CONFIG_DEBUGGER) || defined(CONFIG_LKCD_DUMP) \
+		|| defined(CONFIG_LKCD_DUMP_MODULE)
 	case PPC_MSG_DEBUGGER_BREAK:
 		if (crash_ipi_function_ptr) {
 			crash_ipi_function_ptr(regs);
 			break;
 		}
+		if (dump_ipi_function_ptr) {
+			dump_ipi_function_ptr(regs);
+		}
 #ifdef CONFIG_DEBUGGER
-		debugger_ipi(regs);
-		break;
+		else
+			debugger_ipi(regs);
 #endif /* CONFIG_DEBUGGER */
-		/* FALLTHROUGH */
+		break;
+#endif
 	default:
 		printk("SMP %d: smp_message_recv(): unknown msg %d\n",
 		       smp_processor_id(), msg);
@@ -166,7 +174,16 @@ void crash_send_ipi(void (*crash_ipi_cal
 }
 #endif
 
-static void stop_this_cpu(void *dummy)
+void dump_send_ipi(int (*dump_ipi_callback)(struct pt_regs *))
+{
+	dump_ipi_function_ptr = dump_ipi_callback;
+	if (dump_ipi_callback) {
+		mb();
+		smp_ops->message_pass(MSG_ALL_BUT_SELF, PPC_MSG_DEBUGGER_BREAK);
+	}
+}
+
+void stop_this_cpu(void *dummy)
 {
 	local_irq_disable();
 	while (1)
Index: linux-2.6.15/arch/powerpc/kernel/traps.c
===================================================================
--- linux-2.6.15.orig/arch/powerpc/kernel/traps.c	2006-02-12 16:58:06.045973133 +0100
+++ linux-2.6.15/arch/powerpc/kernel/traps.c	2006-02-12 16:58:13.789952547 +0100
@@ -32,6 +32,7 @@
 #include <linux/delay.h>
 #include <linux/kprobes.h>
 #include <linux/kexec.h>
+#include <linux/dump.h>
 
 #include <asm/kdebug.h>
 #include <asm/pgtable.h>
@@ -157,6 +158,7 @@ int die(const char *str, struct pt_regs 
 		printk("\n");
 	print_modules();
 	show_regs(regs);
+	dump((char *)str, regs);
 	bust_spinlocks(0);
 
 	if (!crash_dump_start && kexec_should_crash(current)) {
Index: linux-2.6.15/arch/powerpc/mm/lmb.c
===================================================================
--- linux-2.6.15.orig/arch/powerpc/mm/lmb.c	2006-02-12 16:58:04.569977060 +0100
+++ linux-2.6.15/arch/powerpc/mm/lmb.c	2006-02-12 16:58:13.789952547 +0100
@@ -301,3 +301,31 @@ void __init lmb_enforce_memory_limit(uns
 		break;
 	}
 }
+
+
+/*
+ * This is the copy of page_is_ram (mm/init.c). The difference is
+ * it identifies all memory holes.
+ */
+int dump_page_is_ram(unsigned long pfn)
+{
+        int i;
+	unsigned long paddr = (pfn << PAGE_SHIFT);
+
+	for (i=0; i < lmb.memory.cnt ;i++) {
+		unsigned long base;
+
+#ifdef CONFIG_MSCHUNKS
+		base = lmb.memory.region[i].physbase;
+#else
+		base = lmb.memory.region[i].base;
+#endif
+		if ((paddr >= base) &&
+			(paddr < (base + lmb.memory.region[i].size))) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
Index: linux-2.6.15/arch/powerpc/platforms/pseries/xics.c
===================================================================
--- linux-2.6.15.orig/arch/powerpc/platforms/pseries/xics.c	2006-02-12 16:57:42.138036856 +0100
+++ linux-2.6.15/arch/powerpc/platforms/pseries/xics.c	2006-02-12 16:58:13.789952547 +0100
@@ -407,7 +407,7 @@ static irqreturn_t xics_ipi_action(int i
 			smp_message_recv(PPC_MSG_MIGRATE_TASK, regs);
 		}
 #endif
-#if defined(CONFIG_DEBUGGER) || defined(CONFIG_KEXEC)
+#if defined(CONFIG_DEBUGGER) || defined(CONFIG_KEXEC) || defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
 		if (test_and_clear_bit(PPC_MSG_DEBUGGER_BREAK,
 				       &xics_ipi_message[cpu].value)) {
 			mb();
Index: linux-2.6.15/arch/s390/Kconfig.debug
===================================================================
--- linux-2.6.15.orig/arch/s390/Kconfig.debug	2006-02-08 22:01:36.000000000 +0100
+++ linux-2.6.15/arch/s390/Kconfig.debug	2006-02-12 16:58:13.797952525 +0100
@@ -2,4 +2,13 @@ menu "Kernel hacking"
 
 source "lib/Kconfig.debug"
 
+config KERNTYPES
+	bool "Kerntypes debugging information"
+	default y
+	---help---
+	  Say Y here to save additional kernel debugging information in the
+	  file init/kerntypes.o. This information is used by crash analysis
+	  tools such as lcrash to assign structures to kernel addresses.
+
+
 endmenu
Index: linux-2.6.15/arch/s390/boot/install.sh
===================================================================
--- linux-2.6.15.orig/arch/s390/boot/install.sh	2006-02-08 22:01:36.000000000 +0100
+++ linux-2.6.15/arch/s390/boot/install.sh	2006-02-12 16:58:13.797952525 +0100
@@ -16,7 +16,8 @@
 #   $1 - kernel version
 #   $2 - kernel image file
 #   $3 - kernel map file
-#   $4 - default install path (blank if root directory)
+#   $4 - kernel type file
+#   $5 - default install path (blank if root directory)
 #
 
 # User may have a custom install script
@@ -26,13 +27,13 @@ if [ -x /sbin/${CROSS_COMPILE}installker
 
 # Default install - same as make zlilo
 
-if [ -f $4/vmlinuz ]; then
-	mv $4/vmlinuz $4/vmlinuz.old
+if [ -f $5/vmlinuz ]; then
+	mv $5/vmlinuz $5/vmlinuz.old
 fi
 
-if [ -f $4/System.map ]; then
-	mv $4/System.map $4/System.old
+if [ -f $5/System.map ]; then
+	mv $5/System.map $5/System.old
 fi
 
-cat $2 > $4/vmlinuz
-cp $3 $4/System.map
+cat $2 > $5/vmlinuz
+cp $3 $5/System.map
Index: linux-2.6.15/arch/x86_64/Kconfig.debug
===================================================================
--- linux-2.6.15.orig/arch/x86_64/Kconfig.debug	2006-02-12 16:58:07.473969335 +0100
+++ linux-2.6.15/arch/x86_64/Kconfig.debug	2006-02-12 16:58:13.841952409 +0100
@@ -2,6 +2,47 @@ menu "Kernel hacking"
 
 source "lib/Kconfig.debug"
 
+config LKCD_DUMP
+       tristate "LKCD crash dump support (EXPERIMENTAL)"
+       depends on EXPERIMENTAL
+       default n
+       ---help---
+         Say Y here to enable saving an image of system memory when a panic
+         or other error occurs. Dumps can also be forced with the SysRq+d
+         key if MAGIC_SYSRQ is enabled.
+
+config KERNTYPES
+	bool
+	depends on LKCD_DUMP
+	default y
+
+config LKCD_DUMP_BLOCKDEV
+       tristate "LKCD crash dump block device driver"
+       depends on LKCD_DUMP
+       help
+         Say Y to allow saving crash dumps directly to a disk device.
+
+config LKCD_DUMP_NETDEV
+       tristate "LKCD crash dump network device driver"
+       depends on LKCD_DUMP
+       help
+         Say Y to allow saving crash dumps over a network device.
+
+config LKCD_DUMP_COMPRESS_RLE
+       tristate "LKCD crash dump RLE compression"
+       depends on LKCD_DUMP
+       help
+         Say Y to allow saving dumps with Run Length Encoding compression.
+
+
+config LKCD_DUMP_COMPRESS_GZIP
+       tristate "LKCD crash dump GZIP compression"
+       select ZLIB_INFLATE
+       select ZLIB_DEFLATE
+       depends on LKCD_DUMP
+       help
+         Say Y to allow saving dumps with Gnu Zip compression.
+
 config DEBUG_RODATA
        bool "Write protect kernel read-only data structures"
        depends on DEBUG_KERNEL
Index: linux-2.6.15/arch/x86_64/kernel/nmi.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/kernel/nmi.c	2006-02-12 16:58:06.081973038 +0100
+++ linux-2.6.15/arch/x86_64/kernel/nmi.c	2006-02-12 16:58:13.841952409 +0100
@@ -25,6 +25,7 @@
 #include <linux/nmi.h>
 #include <linux/sysctl.h>
 #include <linux/kprobes.h>
+#include <linux/dump.h>
 
 #include <asm/smp.h>
 #include <asm/mtrr.h>
Index: linux-2.6.15/arch/x86_64/kernel/smp.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/kernel/smp.c	2006-02-12 16:57:43.046034431 +0100
+++ linux-2.6.15/arch/x86_64/kernel/smp.c	2006-02-12 16:58:13.841952409 +0100
@@ -19,6 +19,7 @@
 #include <linux/kernel_stat.h>
 #include <linux/mc146818rtc.h>
 #include <linux/interrupt.h>
+#include <linux/dump.h>
 
 #include <asm/mtrr.h>
 #include <asm/pgalloc.h>
@@ -281,6 +282,12 @@ void flush_tlb_all(void)
 	on_each_cpu(do_flush_tlb_all, NULL, 1, 1);
 }
 
+/* void dump_send_ipi(int (*dump_ipi_handler)(struct pt_regs *)); */
+void dump_send_ipi(void)
+{
+	send_IPI_allbutself(DUMP_VECTOR);
+}
+
 /*
  * this function sends a 'reschedule' IPI to another CPU.
  * it goes straight through and wastes no time serializing
@@ -444,6 +451,18 @@ int smp_call_function (void (*func) (voi
 	return 0;
 }
 
+void stop_this_cpu(void* dummy)
+{
+	/*
+	 * Remove this CPU:
+	 */
+	cpu_clear(smp_processor_id(), cpu_online_map);
+	local_irq_disable();
+	disable_local_APIC();
+	for (;;)
+		asm("hlt");
+}
+
 void smp_stop_cpu(void)
 {
 	unsigned long flags;
Index: linux-2.6.15/arch/x86_64/kernel/traps.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/kernel/traps.c	2006-02-12 16:58:10.985959998 +0100
+++ linux-2.6.15/arch/x86_64/kernel/traps.c	2006-02-12 16:58:13.841952409 +0100
@@ -27,6 +27,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/dump.h>
 #include <linux/moduleparam.h>
 #include <linux/nmi.h>
 #include <linux/kprobes.h>
@@ -417,6 +418,7 @@ void __kprobes __die(const char * str, s
 	sysfs_printk_last_file();
 	notify_die(DIE_OOPS, str, regs, err, current->thread.trap_no, SIGSEGV);
 	show_registers(regs);
+	dump((char *)str, regs);
 	/* Executive summary in case the oops scrolled away */
 	printk(KERN_ALERT "RIP ");
 	printk_address(regs->rip); 
@@ -445,6 +447,7 @@ void __kprobes die_nmi(char *str, struct
 	show_registers(regs);
 	if (panic_on_timeout || panic_on_oops)
 		panic("nmi watchdog");
+	dump(str ,regs);
 	printk("console shuts up ...\n");
 	oops_end(flags);
 	do_exit(SIGSEGV);
Index: linux-2.6.15/arch/x86_64/kernel/x8664_ksyms.c
===================================================================
--- linux-2.6.15.orig/arch/x86_64/kernel/x8664_ksyms.c	2006-02-12 16:58:04.689976741 +0100
+++ linux-2.6.15/arch/x86_64/kernel/x8664_ksyms.c	2006-02-12 16:58:13.841952409 +0100
@@ -162,6 +162,21 @@ EXPORT_SYMBOL(init_level4_pgt);
 extern unsigned long __supported_pte_mask;
 EXPORT_SYMBOL(__supported_pte_mask);
 
+#ifdef CONFIG_LKCD_DUMP_MODULE
+#ifdef CONFIG_SMP
+extern irq_desc_t irq_desc[NR_IRQS];
+extern cpumask_t irq_affinity[NR_IRQS];
+extern void stop_this_cpu(void *);
+extern void dump_send_ipi(void);
+EXPORT_SYMBOL_GPL(irq_desc);
+EXPORT_SYMBOL_GPL(irq_affinity);
+EXPORT_SYMBOL_GPL(dump_send_ipi);
+EXPORT_SYMBOL_GPL(stop_this_cpu);
+#endif
+extern int page_is_ram(unsigned long);
+EXPORT_SYMBOL_GPL(page_is_ram);
+#endif
+
 #ifdef CONFIG_SMP
 EXPORT_SYMBOL(flush_tlb_page);
 #endif
Index: linux-2.6.15/block/ll_rw_blk.c
===================================================================
--- linux-2.6.15.orig/block/ll_rw_blk.c	2006-02-12 16:58:12.793955193 +0100
+++ linux-2.6.15/block/ll_rw_blk.c	2006-02-12 17:02:32.000000000 +0100
@@ -28,6 +28,7 @@
 #include <linux/writeback.h>
 #include <linux/interrupt.h>
 #include <linux/cpu.h>
+#include <linux/dump.h>
 
 /*
  * for max sense size
@@ -2952,7 +2953,10 @@ void generic_make_request(struct bio *bi
 	sector_t maxsector;
 	int ret, nr_sectors = bio_sectors(bio);
 
-	might_sleep();
+#if defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
+	if (likely(!dump_oncpu))
+#endif
+	    might_sleep();
 	/* Test device or partition size, when known. */
 	maxsector = bio->bi_bdev->bd_inode->i_size >> 9;
 	if (maxsector) {
Index: linux-2.6.15/drivers/Makefile
===================================================================
--- linux-2.6.15.orig/drivers/Makefile	2006-02-12 16:58:09.425964145 +0100
+++ linux-2.6.15/drivers/Makefile	2006-02-12 17:02:28.000000000 +0100
@@ -74,4 +74,5 @@ obj-y				+= firmware/
 obj-$(CONFIG_CRYPTO)		+= crypto/
 obj-$(CONFIG_SUPERH)		+= sh/
 obj-$(CONFIG_DMA_ENGINE)	+= dma/
+obj-$(CONFIG_LKCD_DUMP)		+= dump/
 
Index: linux-2.6.15/drivers/message/fusion/mptbase.c
===================================================================
--- linux-2.6.15.orig/drivers/message/fusion/mptbase.c	2006-02-12 16:58:09.709963390 +0100
+++ linux-2.6.15/drivers/message/fusion/mptbase.c	2006-02-12 16:58:13.849952387 +0100
@@ -3309,7 +3309,7 @@ mpt_diag_reset(MPT_ADAPTER *ioc, int ign
 		 *
 		 */
 		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_DISABLE_ARM);
-		mdelay(1);
+		MPT_MDELAY(1);
 
 		/*
 		 * Now hit the reset bit in the Diagnostic register
@@ -6402,6 +6402,23 @@ mpt_sp_ioc_info(MPT_ADAPTER *ioc, u32 io
 }
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/**
+ *	mpt_poll_interrupt - Check if the adapter has raised an interrupt and
+ *	if so, call the interrupt handler.
+ *	@ioc: Pointer to MPT_ADAPTER structure
+ */
+void
+mpt_poll_interrupt(MPT_ADAPTER *ioc)
+{
+	u32 intstat;
+
+	intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
+
+	if (intstat & MPI_HIS_REPLY_MESSAGE_INTERRUPT)
+		mpt_interrupt(0, ioc, NULL);
+}
+
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 EXPORT_SYMBOL(mpt_attach);
 EXPORT_SYMBOL(mpt_detach);
 #ifdef CONFIG_PM
@@ -6499,5 +6516,7 @@ fusion_exit(void)
 #endif
 }
 
+EXPORT_SYMBOL_GPL(mpt_poll_interrupt);
+
 module_init(fusion_init);
 module_exit(fusion_exit);
Index: linux-2.6.15/drivers/message/fusion/mptbase.h
===================================================================
--- linux-2.6.15.orig/drivers/message/fusion/mptbase.h	2006-02-12 16:58:09.709963390 +0100
+++ linux-2.6.15/drivers/message/fusion/mptbase.h	2006-02-12 16:58:13.853952377 +0100
@@ -1034,6 +1034,7 @@ extern int	 mpt_read_ioc_pg_3(MPT_ADAPTE
 extern int	 mptbase_sas_persist_operation(MPT_ADAPTER *ioc, u8 persist_opcode);
 extern int	 mptbase_GetFcPortPage0(MPT_ADAPTER *ioc, int portnum);
 extern int	 mpt_alt_ioc_wait(MPT_ADAPTER *ioc);
+extern void	 mpt_poll_interrupt(MPT_ADAPTER *ioc);
 
 /*
  *  Public data decl's...
@@ -1044,6 +1045,29 @@ extern struct proc_dir_entry	*mpt_proc_r
 extern int		  mpt_lan_index;	/* needed by mptlan.c */
 extern int		  mpt_stm_index;	/* needed by mptstm.c */
 
+/*
+ *  Dump stuff...
+ */
+#include <linux/diskdump.h>
+
+#define MPT_HOST_LOCK(host_lock)		\
+	if (lkcd_dump_mode()) 			\
+		spin_lock(host_lock);		\
+	else					\
+		spin_lock_irq(host_lock);
+
+#define MPT_HOST_UNLOCK(host_lock)		\
+	if (lkcd_dump_mode())			\
+		spin_unlock(host_lock);		\
+	else					\
+		spin_unlock_irq(host_lock);
+
+#define MPT_MDELAY(n)				\
+	if (lkcd_dump_mode())			\
+		diskdump_mdelay(n);		\
+	else					\
+		mdelay(n);
+
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 #endif		/* } __KERNEL__ */
 
Index: linux-2.6.15/drivers/message/fusion/mptfc.c
===================================================================
--- linux-2.6.15.orig/drivers/message/fusion/mptfc.c	2006-02-12 16:58:02.273983170 +0100
+++ linux-2.6.15/drivers/message/fusion/mptfc.c	2006-02-12 16:58:13.857952366 +0100
@@ -125,6 +125,7 @@ static struct scsi_host_template mptfc_d
 	.max_sectors			= 8192,
 	.cmd_per_lun			= 7,
 	.use_clustering			= ENABLE_CLUSTERING,
+	.dump_poll			= mptscsih_poll,
 };
 
 /****************************************************************************
Index: linux-2.6.15/drivers/message/fusion/mptscsih.c
===================================================================
--- linux-2.6.15.orig/drivers/message/fusion/mptscsih.c	2006-02-12 16:58:09.769963230 +0100
+++ linux-2.6.15/drivers/message/fusion/mptscsih.c	2006-02-12 16:58:13.857952366 +0100
@@ -2388,6 +2388,27 @@ mptscsih_change_queue_depth(struct scsi_
 	return sdev->queue_depth;
 }
 
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+/*
+ *	OS entry point to poll whether the adapter has raised an interrupt,
+ *	and if so, handle it.  Called repeatedly after I/O commands are
+ *	issued to this adapter.
+ */
+void
+mptscsih_poll(struct scsi_device *sdev)
+{
+	MPT_SCSI_HOST  *hd;
+
+	hd = (MPT_SCSI_HOST *) sdev->host->hostdata;
+	if (!hd)
+		return;
+
+	/* check interrupt pending */
+	mpt_poll_interrupt(hd->ioc);
+}
+/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
+
+
 /*
  *	OS entry point to adjust the queue_depths on a per-device basis.
  *	Called once per device the bus scan. Use it to force the queue_depth
@@ -4071,6 +4092,9 @@ mptscsih_domainValidation(void *arg)
 	}
 	spin_unlock_irqrestore(&dvtaskQ_lock, flags);
 
+	if (lkcd_dump_mode())
+		return;
+
 	/* For this ioc, loop through all devices and do dv to each device.
 	 * When complete with this ioc, search through the ioc list, and
 	 * for each scsi ioc found, do dv for all devices. Exit when no
@@ -5672,5 +5696,6 @@ EXPORT_SYMBOL(mptscsih_ioc_reset);
 EXPORT_SYMBOL(mptscsih_change_queue_depth);
 EXPORT_SYMBOL(mptscsih_timer_expired);
 EXPORT_SYMBOL(mptscsih_TMHandler);
+EXPORT_SYMBOL(mptscsih_poll);
 
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
Index: linux-2.6.15/drivers/message/fusion/mptscsih.h
===================================================================
--- linux-2.6.15.orig/drivers/message/fusion/mptscsih.h	2006-02-12 16:58:02.285983138 +0100
+++ linux-2.6.15/drivers/message/fusion/mptscsih.h	2006-02-12 16:58:13.861952355 +0100
@@ -109,3 +109,5 @@ extern int mptscsih_ioc_reset(MPT_ADAPTE
 extern int mptscsih_change_queue_depth(struct scsi_device *sdev, int qdepth);
 extern void mptscsih_timer_expired(unsigned long data);
 extern int mptscsih_TMHandler(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 target, u8 lun, int ctx2abort, ulong timeout);
+extern void mptscsih_poll(struct scsi_device *sdev);
+
Index: linux-2.6.15/drivers/message/fusion/mptspi.c
===================================================================
--- linux-2.6.15.orig/drivers/message/fusion/mptspi.c	2006-02-12 16:58:02.285983138 +0100
+++ linux-2.6.15/drivers/message/fusion/mptspi.c	2006-02-12 16:58:13.861952355 +0100
@@ -126,6 +126,7 @@ static struct scsi_host_template mptspi_
 	.max_sectors			= 8192,
 	.cmd_per_lun			= 7,
 	.use_clustering			= ENABLE_CLUSTERING,
+	.dump_poll			= mptscsih_poll,
 };
 
 
Index: linux-2.6.15/drivers/net/Kconfig
===================================================================
--- linux-2.6.15.orig/drivers/net/Kconfig	2006-02-12 16:58:04.945976060 +0100
+++ linux-2.6.15/drivers/net/Kconfig	2006-02-12 16:58:13.861952355 +0100
@@ -2716,7 +2716,7 @@ config NETCONSOLE
 	See <file:Documentation/networking/netconsole.txt> for details.
 
 config NETPOLL
-	def_bool NETCONSOLE
+	def_bool NETCONSOLE || LKCD_DUMP_NETDEV
 
 config NETPOLL_RX
 	bool "Netpoll support for trapping incoming packets"
Index: linux-2.6.15/drivers/scsi/Kconfig
===================================================================
--- linux-2.6.15.orig/drivers/scsi/Kconfig	2006-02-12 16:58:10.921960168 +0100
+++ linux-2.6.15/drivers/scsi/Kconfig	2006-02-12 16:58:13.861952355 +0100
@@ -61,6 +61,18 @@ config BLK_DEV_SD
 	  In this case, do not compile the driver for your SCSI host adapter
 	  (below) as a module either.
 
+config SCSI_DUMP
+	tristate "SCSI dump support"
+	depends on LKCD_DUMP_BLOCKDEV && SCSI
+	help
+	   If you want to be able to use LKCD to write crash dumps to
+	   SCSI disks using polling I/O (i.e. with interrupts disabled),
+	   say Y here.
+
+	   This option is only useful if your low-level disk driver supports
+	   polling I/O.  If it doesn't, LKCD will fall back to ordinary
+	   interrupt-driven I/O.
+
 config CHR_DEV_ST
 	tristate "SCSI tape support"
 	depends on SCSI
Index: linux-2.6.15/drivers/scsi/Makefile
===================================================================
--- linux-2.6.15.orig/drivers/scsi/Makefile	2006-02-12 16:58:10.925960157 +0100
+++ linux-2.6.15/drivers/scsi/Makefile	2006-02-12 16:58:13.865952345 +0100
@@ -150,6 +150,8 @@ obj-$(CONFIG_BLK_DEV_SR)	+= sr_mod.o
 obj-$(CONFIG_CHR_DEV_SG)	+= sg.o
 obj-$(CONFIG_CHR_DEV_SCH)	+= ch.o
 
+obj-$(CONFIG_SCSI_DUMP)		+= scsi_dump.o
+
 scsi_mod-y			+= scsi.o hosts.o scsi_ioctl.o constants.o \
 				   scsicam.o scsi_error.o scsi_lib.o \
 				   scsi_scan.o scsi_sysfs.o \
Index: linux-2.6.15/drivers/scsi/qla1280.c
===================================================================
--- linux-2.6.15.orig/drivers/scsi/qla1280.c	2006-02-12 16:58:02.953981360 +0100
+++ linux-2.6.15/drivers/scsi/qla1280.c	2006-02-12 16:58:13.865952345 +0100
@@ -4258,6 +4258,32 @@ qla1280_get_token(char *str)
 }
 
 
+/**************************************************************************
+ *   qla1280_dump_poll
+ *     Handle pending interrupts and complete commands, if any.  LKCD uses
+ *     this to perform crash dump I/O while interrupts are disabled.
+ **************************************************************************/
+static void
+qla1280_dump_poll(struct scsi_device *device)
+{
+	struct scsi_qla_host *ha;
+	struct device_reg *reg;
+	u16 data;
+
+	ha = (struct scsi_qla_host *)device->host->hostdata;
+	reg = ha->iobase;
+
+	/* Check for pending interrupts. */
+	data = qla1280_debounce_register(&reg->istatus);
+	if (data & RISC_INT) {
+		qla1280_isr(ha, &ha->done_q);
+	}
+	if (!list_empty(&ha->done_q))
+		qla1280_done(ha);
+}
+
+
+
 static struct scsi_host_template qla1280_driver_template = {
 	.module			= THIS_MODULE,
 	.proc_name		= "qla1280",
@@ -4275,6 +4301,7 @@ static struct scsi_host_template qla1280
 	.sg_tablesize		= SG_ALL,
 	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
+	.dump_poll		= qla1280_dump_poll,
 };
 
 
Index: linux-2.6.15/drivers/scsi/qla2xxx/qla_os.c
===================================================================
--- linux-2.6.15.orig/drivers/scsi/qla2xxx/qla_os.c	2006-02-12 16:58:09.805963134 +0100
+++ linux-2.6.15/drivers/scsi/qla2xxx/qla_os.c	2006-02-12 16:58:13.869952334 +0100
@@ -93,6 +93,7 @@ static int qla2xxx_eh_bus_reset(struct s
 static int qla2xxx_eh_host_reset(struct scsi_cmnd *);
 static int qla2x00_loop_reset(scsi_qla_host_t *ha);
 static int qla2x00_device_reset(scsi_qla_host_t *, fc_port_t *);
+static void qla2x00_dump_poll(struct scsi_device *sdev);
 
 static int qla2x00_change_queue_depth(struct scsi_device *, int);
 static int qla2x00_change_queue_type(struct scsi_device *, int);
@@ -124,6 +125,7 @@ static struct scsi_host_template qla2x00
 	 */
 	.max_sectors		= 0xFFFF,
 	.shost_attrs		= qla2x00_host_attrs,
+	.dump_poll		= qla2x00_dump_poll,
 };
 
 static struct scsi_host_template qla24xx_driver_template = {
@@ -2140,6 +2142,21 @@ qla2x00_free_sp_pool( scsi_qla_host_t *h
 	}
 }
 
+/*
+ * qla2x00_dump_poll
+ *	Used by LKCD to complete I/O during a crash dump.
+ *
+ * Input:
+ *	sdev = device to which we're dumping.
+ */
+static void
+qla2x00_dump_poll(struct scsi_device *sdev)
+{
+	scsi_qla_host_t *ha = to_qla_host(sdev->host);
+
+	qla2x00_poll(ha);
+}
+
 /**************************************************************************
 * qla2x00_do_dpc
 *   This kernel thread is a task that is schedule by the interrupt handler
Index: linux-2.6.15/drivers/scsi/sata_vsc.c
===================================================================
--- linux-2.6.15.orig/drivers/scsi/sata_vsc.c	2006-02-12 16:57:49.534017117 +0100
+++ linux-2.6.15/drivers/scsi/sata_vsc.c	2006-02-12 17:02:35.000000000 +0100
@@ -43,6 +43,7 @@
 #include <linux/interrupt.h>
 #include <linux/dma-mapping.h>
 #include <linux/device.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <linux/libata.h>
 
@@ -217,6 +218,34 @@ static irqreturn_t vsc_sata_interrupt (i
 	return IRQ_RETVAL(handled);
 }
 
+static int
+vsc_dump_quiesce(struct scsi_device *device)
+{
+	struct ata_port *ap = (struct ata_port *) device->host->hostdata;
+	struct ata_host_set *host_set = ap->host_set;
+
+	/*
+	 * Give the device 1 second to finish whatever it might be doing,
+	 * then deal with any pending interrupts.
+	 */
+	mdelay(1000);
+	vsc_sata_interrupt(0, host_set, NULL);
+
+	ap->qactive = 0;
+	ap->active_tag = ATA_TAG_POISON;
+
+	return 0;
+}
+
+static void
+vsc_dump_poll(struct scsi_device *device)
+{
+	struct ata_port *ap = (struct ata_port *) device->host->hostdata;
+	struct ata_host_set *host_set = ap->host_set;
+
+	vsc_sata_interrupt(0, host_set, NULL);
+}
+
 
 static struct scsi_host_template vsc_sata_sht = {
 	.module			= THIS_MODULE,
@@ -235,6 +264,9 @@ static struct scsi_host_template vsc_sat
 	.dma_boundary		= ATA_DMA_BOUNDARY,
 	.slave_configure	= ata_scsi_slave_config,
 	.bios_param		= ata_std_bios_param,
+	.dump_quiesce		= vsc_dump_quiesce,
+	.dump_poll		= vsc_dump_poll,
+
 };
 
 
Index: linux-2.6.15/drivers/scsi/scsi.c
===================================================================
--- linux-2.6.15.orig/drivers/scsi/scsi.c	2006-02-12 16:58:05.045975794 +0100
+++ linux-2.6.15/drivers/scsi/scsi.c	2006-02-12 16:58:13.869952334 +0100
@@ -65,6 +65,7 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
 #include <scsi/scsi_request.h>
+#include <linux/diskdump.h>
 
 #include "scsi_priv.h"
 #include "scsi_logging.h"
@@ -754,6 +755,9 @@ void __scsi_done(struct scsi_cmnd *cmd)
 {
 	struct request *rq = cmd->request;
 
+	if (lkcd_dump_mode())
+		return;
+
 	/*
 	 * Set the serial numbers back to zero
 	 */
Index: linux-2.6.15/drivers/scsi/scsi_error.c
===================================================================
--- linux-2.6.15.orig/drivers/scsi/scsi_error.c	2006-02-12 16:58:10.141962241 +0100
+++ linux-2.6.15/drivers/scsi/scsi_error.c	2006-02-12 16:58:13.873952324 +0100
@@ -24,6 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
+#include <linux/diskdump.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_dbg.h>
@@ -423,6 +424,9 @@ static int scsi_eh_completed_normally(st
  **/
 static void scsi_eh_done(struct scsi_cmnd *scmd)
 {
+	 if (lkcd_dump_mode())
+                return;
+
 	struct completion     *eh_action;
 
 	SCSI_LOG_ERROR_RECOVERY(3,
@@ -1320,6 +1324,8 @@ int scsi_decide_disposition(struct scsi_
 	}
 }
 
+EXPORT_SYMBOL_GPL(scsi_decide_disposition);
+
 /**
  * scsi_eh_lock_door - Prevent medium removal for the specified device
  * @sdev:	SCSI device to prevent medium removal
Index: linux-2.6.15/drivers/scsi/scsi_priv.h
===================================================================
--- linux-2.6.15.orig/drivers/scsi/scsi_priv.h	2006-02-12 16:57:49.554017063 +0100
+++ linux-2.6.15/drivers/scsi/scsi_priv.h	2006-02-12 16:58:13.873952324 +0100
@@ -62,7 +62,6 @@ extern void scsi_add_timer(struct scsi_c
 extern int scsi_delete_timer(struct scsi_cmnd *);
 extern void scsi_times_out(struct scsi_cmnd *cmd);
 extern int scsi_error_handler(void *host);
-extern int scsi_decide_disposition(struct scsi_cmnd *cmd);
 extern void scsi_eh_wakeup(struct Scsi_Host *shost);
 extern int scsi_eh_scmd_add(struct scsi_cmnd *, int);
 
Index: linux-2.6.15/include/asm-i386/kmap_types.h
===================================================================
--- linux-2.6.15.orig/include/asm-i386/kmap_types.h	2006-02-12 16:58:07.301969793 +0100
+++ linux-2.6.15/include/asm-i386/kmap_types.h	2006-02-12 16:58:13.873952324 +0100
@@ -24,7 +24,8 @@ D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
 D(13)	KM_KDB,
-D(14)	KM_TYPE_NR
+D(14)	KM_DUMP,
+D(15)	KM_TYPE_NR
 };
 
 #undef D
Index: linux-2.6.15/include/asm-i386/mach-default/irq_vectors.h
===================================================================
--- linux-2.6.15.orig/include/asm-i386/mach-default/irq_vectors.h	2006-02-12 16:58:07.301969793 +0100
+++ linux-2.6.15/include/asm-i386/mach-default/irq_vectors.h	2006-02-12 16:58:13.873952324 +0100
@@ -49,6 +49,7 @@
 #define INVALIDATE_TLB_VECTOR	0xfd
 #define RESCHEDULE_VECTOR	0xfc
 #define CALL_FUNCTION_VECTOR	0xfb
+#define DUMP_VECTOR		0xfa
 #define KDB_VECTOR		0xf9
 
 #define THERMAL_APIC_VECTOR	0xf0
Index: linux-2.6.15/include/asm-powerpc/kmap_types.h
===================================================================
--- linux-2.6.15.orig/include/asm-powerpc/kmap_types.h	2006-02-08 22:01:36.000000000 +0100
+++ linux-2.6.15/include/asm-powerpc/kmap_types.h	2006-02-12 16:58:13.873952324 +0100
@@ -26,7 +26,8 @@ enum km_type {
 	KM_SOFTIRQ1,
 	KM_PPC_SYNC_PAGE,
 	KM_PPC_SYNC_ICACHE,
-	KM_TYPE_NR
+	KM_TYPE_NR,
+	KM_DUMP
 };
 
 #endif	/* __KERNEL__ */
Index: linux-2.6.15/include/asm-x86_64/hw_irq.h
===================================================================
--- linux-2.6.15.orig/include/asm-x86_64/hw_irq.h	2006-02-12 16:57:55.354001600 +0100
+++ linux-2.6.15/include/asm-x86_64/hw_irq.h	2006-02-12 16:58:13.873952324 +0100
@@ -35,11 +35,16 @@ struct hw_interrupt_type;
 
 #define IA32_SYSCALL_VECTOR	0x80
 
-
 /*
  * Vectors 0x20-0x2f are used for ISA interrupts.
  */
 
+/* FIXME: LKCD We are out of free vectors 0xf0-0xf9, was using 0xf9
+ * for now and because I don't know any better I'm going to
+ * hijack a ISA vector.
+ */
+#define DUMP_VECTOR			0x20
+
 /*
  * Special IRQ vectors used by the SMP architecture, 0xf0-0xff
  *
Index: linux-2.6.15/include/asm-x86_64/ipi.h
===================================================================
--- linux-2.6.15.orig/include/asm-x86_64/ipi.h	2006-02-12 16:57:55.358001589 +0100
+++ linux-2.6.15/include/asm-x86_64/ipi.h	2006-02-12 16:58:13.873952324 +0100
@@ -69,7 +69,14 @@ static inline void __send_IPI_shortcut(u
 	 * No need to touch the target chip field
 	 */
 	cfg = __prepare_ICR(shortcut, vector, dest);
-
+#ifdef DUMP_VECTOR
+	if (vector == DUMP_VECTOR) {
+		/*
+		 * Setup DUMP IPI to be delivered as an NMI
+		 */
+		cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
+	}
+#endif
 	/*
 	 * Send the IPI. The write to APIC_ICR fires this off.
 	 */
@@ -106,6 +113,15 @@ static inline void send_IPI_mask_sequenc
 		 */
 		cfg = __prepare_ICR(0, vector, APIC_DEST_PHYSICAL);
 
+#ifdef DUMP_VECTOR
+		if (vector == DUMP_VECTOR) {
+			/*
+			 * Setup DUMP IPI to be delivered as an NMI
+			 */
+			cfg = (cfg&~APIC_VECTOR_MASK)|APIC_DM_NMI;
+		}
+#endif
+
 		/*
 		 * Send the IPI. The write to APIC_ICR fires this off.
 		 */
Index: linux-2.6.15/include/asm-x86_64/kmap_types.h
===================================================================
--- linux-2.6.15.orig/include/asm-x86_64/kmap_types.h	2006-02-08 22:01:36.000000000 +0100
+++ linux-2.6.15/include/asm-x86_64/kmap_types.h	2006-02-12 16:58:13.873952324 +0100
@@ -13,7 +13,8 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
-	KM_TYPE_NR
+	KM_DUMP,
+	KM_TYPE_NR,
 };
 
 #endif
Index: linux-2.6.15/include/linux/interrupt.h
===================================================================
--- linux-2.6.15.orig/include/linux/interrupt.h	2006-02-12 16:57:55.462001312 +0100
+++ linux-2.6.15/include/linux/interrupt.h	2006-02-12 16:58:13.873952324 +0100
@@ -292,4 +292,7 @@ extern int probe_irq_off(unsigned long);
 extern unsigned int probe_irq_mask(unsigned long);	/* returns mask of ISA interrupts */
 #endif
 
+extern void dump_clear_tasklet(void);
+extern void dump_run_tasklet(void);
+
 #endif
Index: linux-2.6.15/include/linux/miscdevice.h
===================================================================
--- linux-2.6.15.orig/include/linux/miscdevice.h	2006-02-08 22:01:36.000000000 +0100
+++ linux-2.6.15/include/linux/miscdevice.h	2006-02-12 16:58:13.873952324 +0100
@@ -25,6 +25,7 @@
 #define MICROCODE_MINOR		184
 #define MWAVE_MINOR	219		/* ACP/Mwave Modem */
 #define MPT_MINOR	220
+#define LKCD_DUMP_MINOR   230		/* LKCD */
 #define MISC_DYNAMIC_MINOR 255
 
 #define TUN_MINOR	     200
Index: linux-2.6.15/include/linux/sched.h
===================================================================
--- linux-2.6.15.orig/include/linux/sched.h	2006-02-12 16:58:12.453956097 +0100
+++ linux-2.6.15/include/linux/sched.h	2006-02-12 16:58:13.877952313 +0100
@@ -96,6 +96,7 @@ extern unsigned long total_forks;
 extern int nr_threads;
 extern int last_pid;
 DECLARE_PER_CPU(unsigned long, process_counts);
+DECLARE_PER_CPU(struct runqueue, runqueues);
 extern int nr_processes(void);
 extern unsigned long nr_running(void);
 extern unsigned long nr_uninterruptible(void);
@@ -1004,6 +1005,88 @@ extern void set_curr_task(int cpu, task_
 void yield(void);
 
 /*
+ * These are the runqueue data structures:
+ */
+
+#define BITMAP_SIZE ((((MAX_PRIO+1+7)/8)+sizeof(long)-1)/sizeof(long))
+
+typedef struct runqueue runqueue_t;
+
+struct prio_array {
+	unsigned int nr_active;
+	unsigned long bitmap[BITMAP_SIZE];
+	struct list_head queue[MAX_PRIO];
+};
+
+/*
+ * This is the main, per-CPU runqueue data structure.
+ *
+ * Locking rule: those places that want to lock multiple runqueues
+ * (such as the load balancing or the thread migration code), lock
+ * acquire operations must be ordered by ascending &runqueue.
+ */
+struct runqueue {
+	spinlock_t lock;
+
+	/*
+	 * nr_running and cpu_load should be in the same cacheline because
+	 * remote CPUs use both these fields when doing load calculation.
+	 */
+	unsigned long nr_running;
+#ifdef CONFIG_SMP
+	unsigned long cpu_load[3];
+#endif
+	unsigned long long nr_switches;
+
+	/*
+	 * This is part of a global counter where only the total sum
+	 * over all CPUs matters. A task can increase this counter on
+	 * one CPU and if it got migrated afterwards it may decrease
+	 * it on another CPU. Always updated under the runqueue lock:
+	 */
+	unsigned long nr_uninterruptible;
+
+	unsigned long expired_timestamp;
+	unsigned long long timestamp_last_tick;
+	task_t *curr, *idle;
+	struct mm_struct *prev_mm;
+	prio_array_t *active, *expired, arrays[2];
+	int best_expired_prio;
+	atomic_t nr_iowait;
+
+#ifdef CONFIG_SMP
+	struct sched_domain *sd;
+
+	/* For active balancing */
+	int active_balance;
+	int push_cpu;
+
+	task_t *migration_thread;
+	struct list_head migration_queue;
+#endif
+
+#ifdef CONFIG_SCHEDSTATS
+	/* latency stats */
+	struct sched_info rq_sched_info;
+
+	/* sys_sched_yield() stats */
+	unsigned long yld_exp_empty;
+	unsigned long yld_act_empty;
+	unsigned long yld_both_empty;
+	unsigned long yld_cnt;
+
+	/* schedule() stats */
+	unsigned long sched_switch;
+	unsigned long sched_cnt;
+	unsigned long sched_goidle;
+
+	/* try_to_wake_up() stats */
+	unsigned long ttwu_cnt;
+	unsigned long ttwu_local;
+#endif
+};
+
+/*
  * The default (Linux) execution domain.
  */
 extern struct exec_domain	default_exec_domain;
Index: linux-2.6.15/include/linux/sysctl.h
===================================================================
--- linux-2.6.15.orig/include/linux/sysctl.h	2006-02-12 16:58:09.501963943 +0100
+++ linux-2.6.15/include/linux/sysctl.h	2006-02-12 16:58:13.881952302 +0100
@@ -148,6 +148,7 @@ enum
 	KERN_SPIN_RETRY=70,	/* int: number of spinlock retries */
 	KERN_UNSUPPORTED=71,	/* int: allow loading of unsupported modules */
 	KERN_KDB=72,		/* int: kdb on/off */
+	KERN_DUMP=73,		/* directory: dump parameters */
 };
 
 
Index: linux-2.6.15/include/linux/timer.h
===================================================================
--- linux-2.6.15.orig/include/linux/timer.h	2006-02-12 16:57:56.113999575 +0100
+++ linux-2.6.15/include/linux/timer.h	2006-02-12 16:58:13.881952302 +0100
@@ -98,4 +98,7 @@ extern void init_timers(void);
 extern void run_local_timers(void);
 extern int it_real_fn(void *);
 
+extern void dump_clear_timers(void);
+extern void dump_run_timers(void);
+
 #endif
Index: linux-2.6.15/include/linux/workqueue.h
===================================================================
--- linux-2.6.15.orig/include/linux/workqueue.h	2006-02-12 16:58:09.833963060 +0100
+++ linux-2.6.15/include/linux/workqueue.h	2006-02-12 16:58:13.881952302 +0100
@@ -91,4 +91,7 @@ static inline int cancel_delayed_work(st
 	return ret;
 }
 
+extern void dump_clear_workqueue(void);
+extern void dump_run_workqueue(void);
+
 #endif
Index: linux-2.6.15/include/scsi/scsi_eh.h
===================================================================
--- linux-2.6.15.orig/include/scsi/scsi_eh.h	2006-02-08 22:01:36.000000000 +0100
+++ linux-2.6.15/include/scsi/scsi_eh.h	2006-02-12 16:58:13.881952302 +0100
@@ -38,6 +38,7 @@ static inline int scsi_sense_valid(struc
 extern void scsi_report_bus_reset(struct Scsi_Host *, int);
 extern void scsi_report_device_reset(struct Scsi_Host *, int, int);
 extern int scsi_block_when_processing_errors(struct scsi_device *);
+extern int scsi_decide_disposition(struct scsi_cmnd *);
 extern int scsi_normalize_sense(const u8 *sense_buffer, int sb_len,
 		struct scsi_sense_hdr *sshdr);
 extern int scsi_request_normalize_sense(struct scsi_request *sreq,
Index: linux-2.6.15/include/scsi/scsi_host.h
===================================================================
--- linux-2.6.15.orig/include/scsi/scsi_host.h	2006-02-12 16:58:03.773979178 +0100
+++ linux-2.6.15/include/scsi/scsi_host.h	2006-02-12 16:58:13.881952302 +0100
@@ -433,6 +433,38 @@ struct scsi_host_template {
 	 * module_init/module_exit.
 	 */
 	struct list_head legacy_hosts;
+
+	/* operations for dump */
+
+	/*
+	 * Called to set up the device at the beginning of a crash dump.
+	 * Can be used to perform a host reset, purge any outstanding
+	 * commands so dump I/O can begin, etc.
+	 *
+	 * Status: OPTIONAL
+	 */
+	int (* dump_quiesce)(struct scsi_device *);
+
+	/*
+	 * Called after a crash dump is completed.  Can be used to
+	 * synchronize caches if applicable.
+	 *
+	 * Status: OPTIONAL
+	 */
+	int (* dump_shutdown)(struct scsi_device *);
+
+	/*
+	 * Called during a crash dump after each command is issued
+	 * (repeatedly, until the command completes).  Typically calls
+	 * the interrupt handler so that any pending interrupts will get
+	 * processed despite irqs being disabled.
+	 *
+	 * Any driver which wants to support crash dumps using polling I/O
+	 * needs to implement this method.
+	 *
+	 * Status: OPTIONAL
+	 */
+	void (* dump_poll)(struct scsi_device *);
 };
 
 /*
Index: linux-2.6.15/init/Makefile
===================================================================
--- linux-2.6.15.orig/init/Makefile	2006-02-08 22:01:36.000000000 +0100
+++ linux-2.6.15/init/Makefile	2006-02-12 16:58:13.881952302 +0100
@@ -11,12 +11,23 @@ mounts-$(CONFIG_BLK_DEV_RAM)	+= do_mount
 mounts-$(CONFIG_BLK_DEV_INITRD)	+= do_mounts_initrd.o
 mounts-$(CONFIG_BLK_DEV_MD)	+= do_mounts_md.o
 
+extra-$(CONFIG_KERNTYPES)	+= kerntypes.o
+#For IA64, compile kerntypes in dwarf-2 format.
+ifeq ($(CONFIG_IA64),y)
+cc-option = $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null -xc /dev/null \
+             > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi ;)
+CFLAGS_kerntypes.o             := -gdwarf-2
+CFLAGS_kerntypes.o             += $(call cc-option, -fno-eliminate-unused-debug-types)
+else
+CFLAGS_kerntypes.o             := -gstabs
+endif
+
 # files to be removed upon make clean
 clean-files := ../include/linux/compile.h
 
 # dependencies on generated files need to be listed explicitly
 
-$(obj)/version.o: include/linux/compile.h
+$(obj)/version.o $(obj)/kerntypes.o: include/linux/compile.h
 
 # compile.h changes depending on hostname, generation number, etc,
 # so we regenerate it always.
Index: linux-2.6.15/init/main.c
===================================================================
--- linux-2.6.15.orig/init/main.c	2006-02-12 16:58:07.637968899 +0100
+++ linux-2.6.15/init/main.c	2006-02-12 16:58:13.881952302 +0100
@@ -109,6 +109,15 @@ enum system_states system_state;
 EXPORT_SYMBOL(system_state);
 
 /*
+ * The kernel_magic value represents the address of _end, which allows
+ * namelist tools to "match" each other respectively.  That way a tool
+ * that looks at /dev/mem can verify that it is using the right System.map
+ * file -- if kernel_magic doesn't equal the namelist value of _end,
+ * something's wrong.
+ */
+unsigned long *kernel_magic = (unsigned long *)&_end;
+
+/*
  * Boot command-line arguments
  */
 #define MAX_INIT_ARGS CONFIG_INIT_ENV_ARG_LIMIT
Index: linux-2.6.15/init/version.c
===================================================================
--- linux-2.6.15.orig/init/version.c	2006-02-08 22:01:36.000000000 +0100
+++ linux-2.6.15/init/version.c	2006-02-12 16:58:13.881952302 +0100
@@ -11,6 +11,7 @@
 #include <linux/uts.h>
 #include <linux/utsname.h>
 #include <linux/version.h>
+#include <linux/stringify.h>
 
 #define version(a) Version_ ## a
 #define version_string(a) version(a)
@@ -31,3 +32,6 @@ EXPORT_SYMBOL(system_utsname);
 const char linux_banner[] =
 	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
 	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
+
+const char *LINUX_COMPILE_VERSION_ID = __stringify(LINUX_COMPILE_VERSION_ID);
+LINUX_COMPILE_VERSION_ID_TYPE;
Index: linux-2.6.15/kernel/panic.c
===================================================================
--- linux-2.6.15.orig/kernel/panic.c	2006-02-12 16:58:12.197956777 +0100
+++ linux-2.6.15/kernel/panic.c	2006-02-12 16:58:13.885952292 +0100
@@ -23,8 +23,10 @@
 int panic_timeout;
 int panic_on_oops;
 int tainted;
+void (*dump_function_ptr)(const char *, const struct pt_regs *) = 0;
 
 EXPORT_SYMBOL(panic_timeout);
+EXPORT_SYMBOL_GPL(dump_function_ptr);
 
 struct notifier_block *panic_notifier_list;
 
@@ -78,6 +80,8 @@ NORET_TYPE void panic(const char * fmt, 
 	printk(KERN_EMERG "Kernel panic - not syncing: %s\n",buf);
 	bust_spinlocks(0);
 
+	notifier_call_chain(&panic_notifier_list, 0, buf);
+
 	/*
 	 * If we have crashed and we have a crash kernel loaded let it handle
 	 * everything else.
@@ -94,7 +98,6 @@ NORET_TYPE void panic(const char * fmt, 
 	smp_send_stop();
 #endif
 
-	notifier_call_chain(&panic_notifier_list, 0, buf);
 
 	if (!panic_blink)
 		panic_blink = no_blink;
Index: linux-2.6.15/kernel/sched.c
===================================================================
--- linux-2.6.15.orig/kernel/sched.c	2006-02-12 16:58:07.157970176 +0100
+++ linux-2.6.15/kernel/sched.c	2006-02-12 17:02:32.000000000 +0100
@@ -53,6 +53,14 @@
 
 #include <asm/unistd.h>
 
+#if defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
+/* used to soft spin in sched while dump is in progress */
+unsigned long dump_oncpu;
+EXPORT_SYMBOL_GPL(dump_oncpu);
+unsigned long dump_polling_oncpu;
+EXPORT_SYMBOL_GPL(dump_polling_oncpu);
+#endif
+
 /*
  * Convert user-nice values [ -20 ... 0 ... 19 ]
  * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
@@ -185,89 +193,7 @@ void __put_task_struct_cb(struct rcu_hea
 
 EXPORT_SYMBOL_GPL(__put_task_struct_cb);
 
-/*
- * These are the runqueue data structures:
- */
-
-#define BITMAP_SIZE ((((MAX_PRIO+1+7)/8)+sizeof(long)-1)/sizeof(long))
-
-typedef struct runqueue runqueue_t;
-
-struct prio_array {
-	unsigned int nr_active;
-	unsigned long bitmap[BITMAP_SIZE];
-	struct list_head queue[MAX_PRIO];
-};
-
-/*
- * This is the main, per-CPU runqueue data structure.
- *
- * Locking rule: those places that want to lock multiple runqueues
- * (such as the load balancing or the thread migration code), lock
- * acquire operations must be ordered by ascending &runqueue.
- */
-struct runqueue {
-	spinlock_t lock;
-
-	/*
-	 * nr_running and cpu_load should be in the same cacheline because
-	 * remote CPUs use both these fields when doing load calculation.
-	 */
-	unsigned long nr_running;
-#ifdef CONFIG_SMP
-	unsigned long cpu_load[3];
-#endif
-	unsigned long long nr_switches;
-
-	/*
-	 * This is part of a global counter where only the total sum
-	 * over all CPUs matters. A task can increase this counter on
-	 * one CPU and if it got migrated afterwards it may decrease
-	 * it on another CPU. Always updated under the runqueue lock:
-	 */
-	unsigned long nr_uninterruptible;
-
-	unsigned long expired_timestamp;
-	unsigned long long timestamp_last_tick;
-	task_t *curr, *idle;
-	struct mm_struct *prev_mm;
-	prio_array_t *active, *expired, arrays[2];
-	int best_expired_prio;
-	atomic_t nr_iowait;
-
-#ifdef CONFIG_SMP
-	struct sched_domain *sd;
-
-	/* For active balancing */
-	int active_balance;
-	int push_cpu;
-
-	task_t *migration_thread;
-	struct list_head migration_queue;
-#endif
-
-#ifdef CONFIG_SCHEDSTATS
-	/* latency stats */
-	struct sched_info rq_sched_info;
-
-	/* sys_sched_yield() stats */
-	unsigned long yld_exp_empty;
-	unsigned long yld_act_empty;
-	unsigned long yld_both_empty;
-	unsigned long yld_cnt;
-
-	/* schedule() stats */
-	unsigned long sched_switch;
-	unsigned long sched_cnt;
-	unsigned long sched_goidle;
-
-	/* try_to_wake_up() stats */
-	unsigned long ttwu_cnt;
-	unsigned long ttwu_local;
-#endif
-};
-
-static DEFINE_PER_CPU(struct runqueue, runqueues);
+DEFINE_PER_CPU(struct runqueue, runqueues);
 
 /*
  * The domain tree (rq->sd) is protected by RCU's quiescent state transition.
@@ -2883,6 +2809,22 @@ asmlinkage void __sched schedule(void)
 	unsigned long run_time;
 	int cpu, idx, new_prio;
 
+#if defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
+	/*
+	 * If a crash dump is in progress, schedule()
+	 * is a no-op for the dumping cpu, and all
+	 * other cpus are forced to wait until the dump
+	 * completes.
+	 */
+	if (unlikely(dump_oncpu)) {
+		if (dump_oncpu == smp_processor_id()+1)
+			return;
+		else
+			while (dump_oncpu)
+				cpu_relax();
+	}
+#endif
+
 	/*
 	 * Test if we are atomic.  Since do_exit() needs to call into
 	 * schedule() atomically, we ignore that path for now.
@@ -3053,6 +2995,8 @@ switch_tasks:
 	preempt_enable_no_resched();
 	if (unlikely(test_thread_flag(TIF_NEED_RESCHED)))
 		goto need_resched;
+
+	return;
 }
 
 EXPORT_SYMBOL(schedule);
Index: linux-2.6.15/kernel/softirq.c
===================================================================
--- linux-2.6.15.orig/kernel/softirq.c	2006-02-08 22:01:36.000000000 +0100
+++ linux-2.6.15/kernel/softirq.c	2006-02-12 16:58:13.905952239 +0100
@@ -341,6 +341,38 @@ void tasklet_kill(struct tasklet_struct 
 
 EXPORT_SYMBOL(tasklet_kill);
 
+struct tasklet_head saved_tasklet;
+
+void dump_clear_tasklet(void)
+{
+	saved_tasklet.list = __get_cpu_var(tasklet_vec).list;
+	__get_cpu_var(tasklet_vec).list = NULL;
+}
+
+EXPORT_SYMBOL_GPL(dump_clear_tasklet);
+
+void dump_run_tasklet(void)
+{
+	struct tasklet_struct *list;
+
+	list = __get_cpu_var(tasklet_vec).list;
+	__get_cpu_var(tasklet_vec).list = NULL;
+
+	while (list) {
+		struct tasklet_struct *t = list;
+		list = list->next;
+
+		if (!atomic_read(&t->count) &&
+		    (test_and_clear_bit(TASKLET_STATE_SCHED, &t->state)))
+				t->func(t->data);
+
+		t->next = __get_cpu_var(tasklet_vec).list;
+		__get_cpu_var(tasklet_vec).list = t;
+	}
+}
+
+EXPORT_SYMBOL_GPL(dump_run_tasklet);
+
 void __init softirq_init(void)
 {
 	open_softirq(TASKLET_SOFTIRQ, tasklet_action, NULL);
Index: linux-2.6.15/kernel/timer.c
===================================================================
--- linux-2.6.15.orig/kernel/timer.c	2006-02-12 16:58:05.349974985 +0100
+++ linux-2.6.15/kernel/timer.c	2006-02-12 17:02:35.000000000 +0100
@@ -32,6 +32,8 @@
 #include <linux/jiffies.h>
 #include <linux/posix-timers.h>
 #include <linux/cpu.h>
+#include <linux/delay.h>
+#include <linux/diskdump.h>
 #include <linux/syscalls.h>
 #include <linux/delay.h>
 
@@ -430,8 +432,9 @@ static int cascade(tvec_base_t *base, tv
 static inline void __run_timers(tvec_base_t *base)
 {
 	struct timer_list *timer;
+	unsigned long flags;
 
-	spin_lock_irq(&base->t_base.lock);
+	spin_lock_irqsave(&base->t_base.lock, flags);
 	while (time_after_eq(jiffies, base->timer_jiffies)) {
 		struct list_head work_list = LIST_HEAD_INIT(work_list);
 		struct list_head *head = &work_list;
@@ -457,7 +460,7 @@ static inline void __run_timers(tvec_bas
 
 			set_running_timer(base, timer);
 			detach_timer(timer, 1);
-			spin_unlock_irq(&base->t_base.lock);
+			spin_unlock_irqrestore(&base->t_base.lock, flags);
 			{
 				int preempt_count = preempt_count();
 				fn(data);
@@ -474,7 +477,7 @@ static inline void __run_timers(tvec_bas
 		}
 	}
 	set_running_timer(base, NULL);
-	spin_unlock_irq(&base->t_base.lock);
+	spin_unlock_irqrestore(&base->t_base.lock, flags);
 }
 
 #ifdef CONFIG_NO_IDLE_HZ
@@ -1052,6 +1055,12 @@ fastcall signed long __sched schedule_ti
 	struct timer_list timer;
 	unsigned long expire;
 
+	if (lkcd_dump_mode()) {
+		diskdump_mdelay(timeout);
+		set_current_state(TASK_RUNNING);
+		return timeout;
+	}
+
 	switch (timeout)
 	{
 	case MAX_SCHEDULE_TIMEOUT:
@@ -1209,7 +1218,7 @@ asmlinkage long sys_sysinfo(struct sysin
 	return 0;
 }
 
-static void __devinit init_timers_cpu(int cpu)
+static void /* __devinit */ init_timers_cpu(int cpu)
 {
 	int j;
 	tvec_base_t *base;
@@ -1228,6 +1237,27 @@ static void __devinit init_timers_cpu(in
 	base->timer_jiffies = jiffies;
 }
 
+static tvec_base_t saved_tvec_base;
+
+void dump_clear_timers(void)
+{
+	tvec_base_t *base = &per_cpu(tvec_bases, smp_processor_id());
+
+	memcpy(&saved_tvec_base, base, sizeof(saved_tvec_base));
+	init_timers_cpu(smp_processor_id());
+}
+
+EXPORT_SYMBOL_GPL(dump_clear_timers);
+
+void dump_run_timers(void)
+{
+	tvec_base_t *base = &__get_cpu_var(tvec_bases);
+
+	__run_timers(base);
+}
+
+EXPORT_SYMBOL_GPL(dump_run_timers);
+
 #ifdef CONFIG_HOTPLUG_CPU
 static void migrate_timer_list(tvec_base_t *new_base, struct list_head *head)
 {
@@ -1502,6 +1532,11 @@ void msleep(unsigned int msecs)
 {
 	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
 
+	if (lkcd_dump_mode()) {
+		while (msecs--) udelay(1000);
+		return;
+	}
+
 	while (timeout)
 		timeout = schedule_timeout_uninterruptible(timeout);
 }
Index: linux-2.6.15/kernel/workqueue.c
===================================================================
--- linux-2.6.15.orig/kernel/workqueue.c	2006-02-12 16:58:09.833963060 +0100
+++ linux-2.6.15/kernel/workqueue.c	2006-02-12 16:58:13.905952239 +0100
@@ -555,6 +555,39 @@ int current_is_keventd(void)
 
 }
 
+static struct cpu_workqueue_struct saved_cwq;
+
+void dump_clear_workqueue(void)
+{
+	int cpu = smp_processor_id();
+	struct cpu_workqueue_struct *cwq;
+
+	cwq = per_cpu_ptr(keventd_wq->cpu_wq, cpu);
+	memcpy(&saved_cwq, cwq, sizeof(saved_cwq));
+	spin_lock_init(&cwq->lock);
+	INIT_LIST_HEAD(&cwq->worklist);
+	init_waitqueue_head(&cwq->more_work);
+	init_waitqueue_head(&cwq->work_done);
+}
+
+void dump_run_workqueue(void)
+{
+	int cpu = smp_processor_id();
+	struct cpu_workqueue_struct *cwq;
+
+	cwq = per_cpu_ptr(keventd_wq->cpu_wq, cpu);
+	while (!list_empty(&cwq->worklist)) {
+		struct work_struct *work = list_entry(cwq->worklist.next,
+						struct work_struct, entry);
+		void (*f) (void *) = work->func;
+		void *data = work->data;
+
+		list_del_init(cwq->worklist.next);
+		clear_bit(0, &work->pending);
+		f(data);
+	}
+}
+
 #ifdef CONFIG_HOTPLUG_CPU
 /* Take the work from this (downed) CPU. */
 static void take_over_work(struct workqueue_struct *wq, unsigned int cpu)
@@ -644,3 +677,6 @@ EXPORT_SYMBOL(schedule_work);
 EXPORT_SYMBOL(schedule_delayed_work);
 EXPORT_SYMBOL(schedule_delayed_work_on);
 EXPORT_SYMBOL(flush_scheduled_work);
+
+EXPORT_SYMBOL_GPL(dump_clear_workqueue);
+EXPORT_SYMBOL_GPL(dump_run_workqueue);
Index: linux-2.6.15/mm/bootmem.c
===================================================================
--- linux-2.6.15.orig/mm/bootmem.c	2006-02-12 16:57:56.401998808 +0100
+++ linux-2.6.15/mm/bootmem.c	2006-02-12 16:58:13.905952239 +0100
@@ -27,6 +27,7 @@
  */
 unsigned long max_low_pfn;
 unsigned long min_low_pfn;
+EXPORT_SYMBOL_GPL(min_low_pfn);
 unsigned long max_pfn;
 
 EXPORT_SYMBOL(max_pfn);		/* This is exported so
Index: linux-2.6.15/mm/page_alloc.c
===================================================================
--- linux-2.6.15.orig/mm/page_alloc.c	2006-02-12 16:58:12.349956373 +0100
+++ linux-2.6.15/mm/page_alloc.c	2006-02-12 17:02:26.000000000 +0100
@@ -1132,6 +1132,12 @@ unsigned int nr_free_pages(void)
 
 EXPORT_SYMBOL(nr_free_pages);
 
+#ifdef CONFIG_LKCD_DUMP_MODULE
+/* This symbol has to be exported to use 'for_each_pgdat' macro by modules. */
+EXPORT_SYMBOL_GPL(pgdat_list);
+#endif
+
+
 #ifdef CONFIG_NUMA
 unsigned int nr_free_pages_pgdat(pg_data_t *pgdat)
 {
Index: linux-2.6.15/scripts/mkcompile_h
===================================================================
--- linux-2.6.15.orig/scripts/mkcompile_h	2006-02-12 16:58:05.821973729 +0100
+++ linux-2.6.15/scripts/mkcompile_h	2006-02-12 17:02:35.000000000 +0100
@@ -41,7 +41,7 @@ UTS_VERSION="$UTS_VERSION $CONFIG_FLAGS 
 
 UTS_LEN=64
 UTS_TRUNCATE="sed -e s/\(.\{1,$UTS_LEN\}\).*/\1/"
-
+LINUX_COMPILE_VERSION_ID="__linux_compile_version_id__`hostname | tr -c '[0-9A-Za-z\n]' '__'`_`LANG=C date | tr -c '[0-9A-Za-z\n]' '_'`"
 # Generate a temporary compile.h
 
 ( echo /\* This file is auto generated, version $VERSION \*/
@@ -57,6 +57,8 @@ UTS_TRUNCATE="sed -e s/\(.\{1,$UTS_LEN\}
   echo \#define LINUX_COMPILE_DOMAIN \"suse.de\"
 
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
+  echo \#define LINUX_COMPILE_VERSION_ID $LINUX_COMPILE_VERSION_ID
+  echo \#define LINUX_COMPILE_VERSION_ID_TYPE typedef char* "$LINUX_COMPILE_VERSION_ID""_t"
 ) > .tmpcompile
 
 # Only replace the real compile.h if the new one is different,
Index: linux-2.6.15/drivers/dump/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/Makefile	2006-02-12 16:58:13.909952228 +0100
@@ -0,0 +1,21 @@
+#
+# Makefile for the dump device drivers.
+#
+
+dump-y					:= dump_setup.o dump_fmt.o dump_filters.o dump_scheme.o dump_execute.o
+ifeq ($(CONFIG_X86_64),)
+ifeq ($(CONFIG_X86),y)
+dump-$(CONFIG_X86)			+= dump_i386.o
+endif
+endif
+dump-$(CONFIG_ARM)			+= dump_arm.o
+dump-$(CONFIG_PPC64)                    += dump_ppc64.o
+dump-$(CONFIG_X86_64)			+= dump_x8664.o
+dump-$(CONFIG_IA64)			+= dump_ia64.o
+dump-objs				+= $(dump-y)
+
+obj-$(CONFIG_LKCD_DUMP)		+= dump.o
+obj-$(CONFIG_LKCD_DUMP_BLOCKDEV)	+= dump_blockdev.o
+obj-$(CONFIG_LKCD_DUMP_NETDEV)		+= dump_netdev.o
+obj-$(CONFIG_LKCD_DUMP_COMPRESS_RLE)	+= dump_rle.o
+obj-$(CONFIG_LKCD_DUMP_COMPRESS_GZIP)	+= dump_gzip.o
Index: linux-2.6.15/drivers/dump/dump_blockdev.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_blockdev.c	2006-02-12 16:58:13.913952217 +0100
@@ -0,0 +1,880 @@
+/*
+ * Implements the dump driver interface for saving a dump to
+ * a block device through the kernel's generic low level block I/O
+ * routines, or through polling I/O.
+ *
+ * Started: June 2002 - Mohamed Abbas <mohamed.abbas@intel.com>
+ * 	Moved original lkcd kiobuf dump i/o code from dump_base.c
+ * 	to use generic dump device interfaces
+ *
+ * Sept 2002 - Bharata B. Rao <bharata@in.ibm.com>
+ * 	Convert dump i/o to directly use bio instead of kiobuf for 2.5
+ *
+ * Oct 2002  - Suparna Bhattacharya <suparna@in.ibm.com>
+ * 	Rework to new dumpdev.h structures, implement open/close/
+ * 	silence, misc fixes (blocknr removal, bio_add_page usage)
+ * Oct 2004 - Mar 2005 - Mohamed Abbas <mohamed.abbas@intel.com>
+ *                       Jason Uhlenkott <jasonuhl@sgi.com>
+ *	Implement polling I/O (adapted from lkdump, with thanks
+ *	to Nobuhiro Tachino).
+ *
+ * Copyright (C) 1999 - 2005 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 2001 - 2002 Matt D. Robinson.  All rights reserved.
+ * Copyright (C) 2002 International Business Machines Corp.
+ * Copyright (C) 2004 FUJITSU LIMITED
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/bio.h>
+#include <linux/diskdump.h>
+#include <linux/dump.h>
+#include <linux/delay.h>
+#include <asm/dump.h>
+#include <asm/hardirq.h>
+#include "dump_methods.h"
+
+
+/* ----- Support functions for interrupt-driven dumps ----- */
+
+
+extern void *dump_page_buf;
+
+/* The end_io callback for dump i/o completion */
+static int
+dump_bio_end_io(struct bio *bio, unsigned int bytes_done, int error)
+{
+	struct dump_blockdev *dump_bdev;
+
+	if (bio->bi_size) {
+		/* some bytes still left to transfer */
+		return 1; /* not complete */
+	}
+
+	dump_bdev = (struct dump_blockdev *)bio->bi_private;
+	if (error) {
+		printk("LKCD: IO error while writing the dump, aborting\n");
+	}
+
+	dump_bdev->err = error;
+
+	/* no wakeup needed, since caller polls for completion */
+	return 0;
+}
+
+/* Check if the dump bio is already mapped to the specified buffer */
+static int
+dump_block_map_valid(struct dump_blockdev *dev, struct page *page,
+	int len)
+{
+	struct bio *bio = dev->bio;
+	unsigned long bsize = 0;
+
+	if (!bio->bi_vcnt)
+		return 0; /* first time, not mapped */
+
+
+	if ((bio_page(bio) != page) || (len > bio->bi_vcnt << PAGE_SHIFT))
+		return 0; /* buffer not mapped */
+
+	bsize = bdev_hardsect_size(bio->bi_bdev);
+	if ((len & (PAGE_SIZE - 1)) || (len & bsize))
+		return 0; /* alignment checks needed */
+
+	/* quick check to decide if we need to redo bio_add_page */
+	if (bdev_get_queue(bio->bi_bdev)->merge_bvec_fn)
+		return 0; /* device may have other restrictions */
+
+	return 1; /* already mapped */
+}
+
+/*
+ * Set up the dump bio for i/o from the specified buffer
+ * Return value indicates whether the full buffer could be mapped or not
+ */
+static int
+dump_block_map(struct dump_blockdev *dev, void *buf, int len)
+{
+	struct page *page = virt_to_page(buf);
+	struct bio *bio = dev->bio;
+	unsigned long bsize = 0;
+
+	bio->bi_bdev = dev->bdev;
+	bio->bi_sector = (dev->start_offset + dev->ddev.curr_offset) >> 9;
+	bio->bi_idx = 0; /* reset index to the beginning */
+
+	if (dump_block_map_valid(dev, page, len)) {
+		/* already mapped and usable rightaway */
+		bio->bi_size = len; /* reset size to the whole bio */
+		bio->bi_vcnt = (len + PAGE_SIZE - 1) / PAGE_SIZE; /* Set the proper vector cnt */
+	} else {
+		/* need to map the bio */
+		bio->bi_size = 0;
+		bio->bi_vcnt = 0;
+		bsize = bdev_hardsect_size(bio->bi_bdev);
+
+		/* first a few sanity checks */
+		if (len < bsize) {
+			printk("LKCD: map: len less than hardsect size \n");
+			return -EINVAL;
+		}
+
+		if ((unsigned long)buf & bsize) {
+			printk("LKCD: map: not aligned\n");
+			return -EINVAL;
+		}
+
+		/* assume contig. page aligned low mem buffer( no vmalloc) */
+		if ((page_address(page) != buf) || (len & (PAGE_SIZE - 1))) {
+			printk("LKCD: map: invalid buffer alignment!\n");
+			return -EINVAL;
+		}
+		/* finally we can go ahead and map it */
+		while (bio->bi_size < len)
+			if (bio_add_page(bio, page++, PAGE_SIZE, 0) == 0) {
+				break;
+			}
+
+		bio->bi_end_io = dump_bio_end_io;
+		bio->bi_private = dev;
+	}
+
+	if (bio->bi_size != len) {
+		printk("LKCD: map: bio size = %d not enough for len = %d!\n",
+			bio->bi_size, len);
+		return -E2BIG;
+	}
+	return 0;
+}
+
+static void
+dump_free_bio(struct bio *bio)
+{
+	if (bio)
+		kfree(bio->bi_io_vec);
+	kfree(bio);
+}
+
+
+/* ----- Support functions for polling I/O based dumps ----- */
+
+static DECLARE_MUTEX(disk_dump_mutex);
+static LIST_HEAD(disk_dump_types);
+static struct disk_dump_device dump_device;
+static struct disk_dump_partition dump_part;
+static unsigned long long timestamp_base;
+static unsigned long timestamp_hz;
+static unsigned long flags_global;
+static int polling_mode;
+static void dump_blockdev_unconfigure(void);
+
+void diskdump_setup_timestamp(void)
+{
+        unsigned long long t=0;
+
+        platform_timestamp(timestamp_base);
+        udelay(1000000/HZ);
+        platform_timestamp(t);
+        timestamp_hz = (unsigned long)(t - timestamp_base);
+        diskdump_update();
+}
+
+void diskdump_update(void)
+{
+        unsigned long long t=0;
+
+        touch_nmi_watchdog();
+
+        /* update jiffies */
+        platform_timestamp(t);
+        while (t > timestamp_base + timestamp_hz) {
+                timestamp_base += timestamp_hz;
+                jiffies++;
+                platform_timestamp(t);
+        }
+
+        dump_run_timers();
+        dump_run_tasklet();
+        dump_run_workqueue();
+}
+EXPORT_SYMBOL_GPL(diskdump_update);
+
+static void *find_real_device(struct device *dev,
+                              struct disk_dump_type **_dump_type)
+{
+        void *real_device;
+        struct disk_dump_type *dump_type;
+
+        list_for_each_entry(dump_type, &disk_dump_types, list) {
+		real_device = dump_type->probe(dev);
+		if (real_device) {
+                        *_dump_type = dump_type;
+                        return real_device;
+                }
+	}
+	return NULL;
+}
+
+static int register_disk_dump_device(struct device *dev, struct block_device *bdev)
+{
+        struct disk_dump_type *dump_type = NULL;
+        void *real_device;
+        int ret = 0;
+
+	if (!bdev->bd_part)
+		return -EINVAL;
+
+	down(&disk_dump_mutex);
+
+	real_device = find_real_device(dev, &dump_type);
+	if (!real_device) {
+		ret = -ENXIO;
+		goto err;
+        }
+
+	if (dump_device.device == real_device) {
+		ret = -EEXIST;
+		goto err;
+	} else if (dump_device.device) {
+		BUG();
+	}
+
+	dump_device.device = real_device;
+
+	ret = dump_type->add_device(&dump_device);
+	if (ret < 0) {
+		dump_device.device = NULL;
+		goto err;
+	}
+
+	dump_device.dump_type = dump_type;
+	dump_part.device = &dump_device;
+	dump_part.bdev = bdev;
+	dump_part.nr_sects   = bdev->bd_part->nr_sects;
+	dump_part.start_sect = bdev->bd_part->start_sect;
+
+err:
+	up(&disk_dump_mutex);
+	return ret;
+}
+
+static void unregister_disk_dump_device(struct block_device *bdev)
+{
+	struct disk_dump_type *dump_type;
+
+	down(&disk_dump_mutex);
+
+	if(!dump_part.device) {
+		up(&disk_dump_mutex);
+		return;
+	}
+
+	BUG_ON(dump_part.device != &dump_device);
+	BUG_ON(dump_part.bdev != bdev);
+
+	dump_part.device = NULL;
+	dump_part.bdev = NULL;
+
+	dump_type = dump_device.dump_type;
+	dump_type->remove_device(&dump_device);
+	dump_device.device = NULL;
+	dump_device.dump_type = NULL;
+
+	up(&disk_dump_mutex);
+}
+
+int register_disk_dump_type(struct disk_dump_type *dump_type)
+{
+	down(&disk_dump_mutex);
+	list_add(&dump_type->list, &disk_dump_types);
+	up(&disk_dump_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(register_disk_dump_type);
+
+int unregister_disk_dump_type(struct disk_dump_type *dump_type)
+{
+	lock_kernel(); /* guard against the dump ioctl */
+
+	if (dump_device.dump_type == dump_type)
+		dump_blockdev_unconfigure();
+
+	down(&disk_dump_mutex);
+	list_del(&dump_type->list);
+	up(&disk_dump_mutex);
+
+	unlock_kernel();
+	return 0;
+}
+EXPORT_SYMBOL_GPL(unregister_disk_dump_type);
+
+
+/* --------------------------------------------------- */
+
+
+static int
+dump_block_intr_open(struct dump_dev *dev, unsigned long arg)
+{
+	struct dump_blockdev *dump_bdev = DUMP_BDEV(dev);
+	struct block_device *bdev;
+	int retval = 0;
+	struct bio_vec *bvec;
+
+	/* make sure this is a valid block device */
+	if (!arg) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	/* Convert it to the new dev_t format */
+	arg = MKDEV((arg >> OLDMINORBITS), (arg & OLDMINORMASK));
+
+	/* get a corresponding block_dev struct for this */
+	bdev = bdget((dev_t)arg);
+	if (!bdev) {
+		retval = -ENODEV;
+		goto err;
+	}
+
+	/* get the block device opened */
+	if ((retval = blkdev_get(bdev, O_RDWR | O_LARGEFILE, 0))) {
+		goto err1;
+	}
+
+	if ((dump_bdev->bio = kmalloc(sizeof(struct bio), GFP_KERNEL))
+		== NULL) {
+		printk("LKCD: Cannot allocate bio\n");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	bio_init(dump_bdev->bio);
+
+	if ((bvec = kmalloc(sizeof(struct bio_vec) *
+		(DUMP_BUFFER_SIZE >> PAGE_SHIFT), GFP_KERNEL)) == NULL) {
+		retval = -ENOMEM;
+		goto err3;
+	}
+
+	/* assign the new dump dev structure */
+	dump_bdev->dev_id = (dev_t)arg;
+	dump_bdev->bdev = bdev;
+
+	/* make a note of the limit */
+	dump_bdev->limit = bdev->bd_inode->i_size;
+
+	/* now make sure we can map the dump buffer */
+	dump_bdev->bio->bi_io_vec = bvec;
+	dump_bdev->bio->bi_max_vecs = DUMP_BUFFER_SIZE >> PAGE_SHIFT;
+
+	retval = dump_block_map(dump_bdev, dump_config.dumper->dump_buf,
+		DUMP_BUFFER_SIZE);
+
+	if (retval) {
+		printk("LKCD: open: dump_block_map failed, ret %d\n", retval);
+		goto err3;
+	}
+
+	printk("LKCD: Block device (%d,%d) successfully configured for dumping\n",
+	       MAJOR(dump_bdev->dev_id),
+	       MINOR(dump_bdev->dev_id));
+
+
+	/* after opening the block device, return */
+	return retval;
+
+err3:	dump_free_bio(dump_bdev->bio);
+	dump_bdev->bio = NULL;
+err2:	if (bdev) blkdev_put(bdev);
+		goto err;
+err1:	if (bdev) bdput(bdev);
+	dump_bdev->bdev = NULL;
+err:	return retval;
+}
+
+static int
+dump_block_poll_open(struct dump_dev *dev, unsigned long arg)
+{
+	struct dump_blockdev *dump_bdev = DUMP_BDEV(dev);
+	struct block_device *bdev;
+	int retval = 0;
+        struct device *target = NULL;
+
+	/* make sure this is a valid block device */
+	if (!arg) {
+		retval = -EINVAL;
+		goto err;
+	}
+
+	/* Convert it to the new dev_t format */
+	arg = MKDEV((arg >> OLDMINORBITS), (arg & OLDMINORMASK));
+
+	/* get a corresponding block_dev struct for this */
+	bdev = bdget((dev_t)arg);
+	if (!bdev) {
+		retval = -ENODEV;
+		goto err;
+	}
+
+	/* get the block device opened */
+	if ((retval = blkdev_get(bdev, O_RDWR | O_LARGEFILE, 0))) {
+		goto err1;
+	}
+
+	dump_bdev->bio = 0;
+	dump_bdev->dev_id = (dev_t)arg;
+	dump_bdev->bdev = bdev;
+
+	/* make a note of the limit */
+	dump_bdev->limit = bdev->bd_inode->i_size;
+
+	target = get_device(bdev->bd_disk->driverfs_dev);
+	if (!target) {
+		retval = -EINVAL;
+		goto err2;
+	}
+	retval = register_disk_dump_device(target,bdev);
+	if (retval == -EEXIST)
+		retval = 0;
+	else if (retval < 0)
+		goto err2;
+
+        printk("LKCD: Block device (%d,%d) successfully configured for dumping using polling I/O\n",
+		MAJOR((dev_t)arg), MINOR((dev_t)arg));
+
+	/* after opening the block device, return */
+	return retval;
+
+err2:	if (bdev) blkdev_put(bdev);
+		goto err;
+err1:	if (bdev) bdput(bdev);
+err:	return retval;
+}
+
+/*
+ * Prepares the dump device so we can take a dump later.
+ * The caller is expected to have filled up the dev_id field in the
+ * block dump dev structure.
+ *
+ * At dump time when dump_block_write() is invoked it will be too
+ * late to recover, so as far as possible make sure obvious errors
+ * get caught right here and reported back to the caller.
+ */
+static int
+dump_block_open(struct dump_dev *dev, const char *arg)
+{
+	unsigned long devid;
+
+	if ((sscanf(arg, "%lx", &devid)) != 1)
+		return -EINVAL;
+
+	if (devid < 0)
+		return -EINVAL;
+
+	if (dump_config.polling){
+		polling_mode = 1;
+		if (!dump_block_poll_open(dev, devid)) {
+			return 0;
+		} else {
+			/*
+			 * If polling I/O isn't supported by this
+			 * device, fall back to interrupt-driven mode.
+			 */
+			dump_config.polling = 0;
+		}
+	}
+
+	polling_mode = 0;
+	return dump_block_intr_open(dev, devid);
+}
+
+/*
+ * Close the dump device and release associated resources.
+ * Invoked when unconfiguring the dump device.
+ */
+static int
+dump_block_release(struct dump_dev *dev)
+{
+	struct dump_blockdev *dump_bdev = DUMP_BDEV(dev);
+
+	/* release earlier bdev if present */
+	if (dump_bdev->bdev) {
+		unregister_disk_dump_device(dump_bdev->bdev);
+		blkdev_put(dump_bdev->bdev);
+		dump_bdev->bdev = NULL;
+	}
+
+	if (dump_bdev->bio) {
+		dump_free_bio(dump_bdev->bio);
+		dump_bdev->bio = NULL;
+	}
+
+	return 0;
+}
+
+static int
+dump_block_intr_silence(struct dump_dev *dev)
+{
+	struct dump_blockdev *dump_bdev = DUMP_BDEV(dev);
+	struct request_queue *q = bdev_get_queue(dump_bdev->bdev);
+	int ret;
+
+	/* If we can't get request queue lock, refuse to take the dump */
+	if (!spin_trylock(q->queue_lock))
+		return -EBUSY;
+
+	ret = elv_queue_empty(q);
+	spin_unlock(q->queue_lock);
+
+	/* For now we assume we have the device to ourselves */
+	/* Just a quick sanity check */
+	if (!ret) {
+		/* Warn the user and move on */
+		printk("LKCD: Warning: Non-empty request queue\n");
+		printk("LKCD: I/O requests in flight at dump time\n");
+	}
+
+	/*
+	 * Move to a softer level of silencing where no spin_lock_irqs
+	 * are held on other cpus
+	 */
+	dump_silence_level = DUMP_SOFT_SPIN_CPUS;
+
+	ret = __dump_irq_enable();
+	if (ret) {
+		return ret;
+	}
+
+	printk("LKCD: Dumping to block device (%d,%d) on CPU %d ...\n",
+	       MAJOR(dump_bdev->dev_id), MINOR(dump_bdev->dev_id),
+	       smp_processor_id());
+
+	return 0;
+}
+
+static int
+dump_block_poll_silence(struct dump_dev *dev)
+{
+	struct dump_blockdev *dump_bdev = DUMP_BDEV(dev);
+	int ret;
+
+	local_irq_save(flags_global);
+	preempt_disable();
+
+	touch_nmi_watchdog();
+
+	if (down_trylock(&disk_dump_mutex))
+		return -EBUSY;
+
+	dump_polling_oncpu = smp_processor_id() + 1;
+
+	/*
+	 * Setup timer/tasklet
+	 */
+	dump_clear_timers();
+	dump_clear_tasklet();
+	dump_clear_workqueue();
+
+	diskdump_setup_timestamp();
+
+	BUG_ON(dump_part.bdev != dump_bdev->bdev);
+
+	/*
+	 * Move to a softer level of silencing where no spin_lock_irqs
+	 * are held on other cpus
+	 */
+	dump_silence_level = DUMP_SOFT_SPIN_CPUS;
+
+	touch_nmi_watchdog();
+
+	if (dump_device.ops.quiesce)
+		if ((ret = dump_device.ops.quiesce(&dump_device)) < 0) {
+			printk("LKCD: Quiesce failed. error %d\n", ret);
+			return ret;
+		}
+	touch_nmi_watchdog();
+	printk("LKCD: Dumping to block device (%d,%d) on CPU %d using polling I/O ...\n",
+	       MAJOR(dump_bdev->dev_id), MINOR(dump_bdev->dev_id),
+	       smp_processor_id());
+
+	return 0;
+}
+
+/*
+ * Prepare the dump device for use (silence any ongoing activity
+ * and quiesce state) when the system crashes.
+ */
+static int
+dump_block_silence(struct dump_dev *dev)
+{
+	if (polling_mode)
+		return dump_block_poll_silence(dev);
+	else
+		return dump_block_intr_silence(dev);
+}
+
+
+static int
+dump_block_intr_resume(struct dump_dev *dev)
+{
+	__dump_irq_restore();
+	return 0;
+}
+
+static int
+dump_block_poll_resume(struct dump_dev *dev)
+{
+	struct dump_blockdev *dump_bdev = DUMP_BDEV(dev);
+
+	BUG_ON(dump_part.bdev != dump_bdev->bdev);
+
+	if (dump_device.device && dump_device.ops.shutdown)
+		if (dump_device.ops.shutdown(&dump_device))
+			printk("LKCD: polling dev: adapter shutdown failed.\n");
+
+	dump_polling_oncpu = 0;
+	preempt_enable_no_resched();
+	local_irq_restore(flags_global);
+	up(&disk_dump_mutex);
+	return 0;
+}
+
+/*
+ * Invoked when dumping is done. This is the time to put things back
+ * (i.e. undo the effects of dump_block_silence) so the device is
+ * available for normal use.
+ */
+static int
+dump_block_resume(struct dump_dev *dev)
+{
+	if (polling_mode)
+		return dump_block_poll_resume(dev);
+	else
+		return dump_block_intr_resume(dev);
+}
+
+
+/*
+ * Seek to the specified offset in the dump device.
+ * Makes sure this is a valid offset, otherwise returns an error.
+ */
+static int
+dump_block_seek(struct dump_dev *dev, loff_t off)
+{
+	struct dump_blockdev *dump_bdev = DUMP_BDEV(dev);
+	loff_t offset = off + dump_bdev->start_offset;
+
+	if (offset & ( PAGE_SIZE - 1)) {
+		printk("LKCD: seek: non-page aligned\n");
+		return -EINVAL;
+	}
+
+	if (offset & (bdev_hardsect_size(dump_bdev->bdev) - 1)) {
+		printk("LKCD: seek: not sector aligned \n");
+		return -EINVAL;
+	}
+
+	if (offset > dump_bdev->limit) {
+		printk("LKCD: seek: not enough space left on device!\n");
+		return -ENOSPC;
+	}
+	dev->curr_offset = off;
+	return 0;
+}
+
+
+static int
+dump_block_intr_write(struct dump_dev *dev, void *buf,
+	unsigned long len)
+{
+	struct dump_blockdev *dump_bdev = DUMP_BDEV(dev);
+	loff_t offset = dev->curr_offset + dump_bdev->start_offset;
+	int retval = -ENOSPC;
+
+	if (offset >= dump_bdev->limit) {
+		printk("LKCD: write: not enough space left on device!\n");
+		goto out;
+	}
+
+	/* don't write more blocks than our max limit */
+	if (offset + len > dump_bdev->limit)
+		len = dump_bdev->limit - offset;
+
+
+	retval = dump_block_map(dump_bdev, buf, len);
+	if (retval){
+		printk("LKCD: write: dump_block_map failed! err %d\n", retval);
+		goto out;
+	}
+
+	/*
+	 * Write out the data to disk.
+	 * Assumes the entire buffer mapped to a single bio, which we can
+	 * submit and wait for io completion. In the future, may consider
+	 * increasing the dump buffer size and submitting multiple bio s
+	 * for better throughput.
+	 */
+	dump_bdev->err = -EAGAIN;
+	submit_bio(WRITE, dump_bdev->bio);
+
+	dump_bdev->ddev.curr_offset += len;
+	retval = len;
+ out:
+	return retval;
+}
+
+static int
+dump_block_poll_write(struct dump_dev *dev, void *buf,
+	unsigned long len)
+{
+	struct dump_blockdev *dump_bdev = DUMP_BDEV(dev);
+	loff_t offset = dev->curr_offset + dump_bdev->start_offset;
+	int retval = -ENOSPC;
+	int ret;
+
+	if (offset >= dump_bdev->limit) {
+		printk("LKCD: write: not enough space left on device!\n");
+		goto out;
+	}
+
+	/* don't write more blocks than our max limit */
+	if (offset + len > dump_bdev->limit)
+		len = dump_bdev->limit - offset;
+
+	if (dump_part.bdev != dump_bdev->bdev) {
+		return -EBUSY;
+		goto out;
+	}
+
+	local_irq_disable();
+	touch_nmi_watchdog();
+	ret = dump_device.ops.rw_block(&dump_part, WRITE, offset >> DUMP_PAGE_SHIFT,
+		buf, len >> DUMP_PAGE_SHIFT);
+	if (ret < 0) {
+		printk("LKCD: write error\n");
+		goto out;
+	}
+
+	retval = len;
+out:
+	return retval;
+}
+
+/*
+ * Write out a buffer after checking the device limitations,
+ * sector sizes, etc. Assumes the buffer is in directly mapped
+ * kernel address space (not vmalloc'ed).
+ *
+ * Returns: number of bytes written or -ERRNO.
+ */
+static int
+dump_block_write(struct dump_dev *dev, void *buf,
+	unsigned long len)
+{
+	if (polling_mode)
+		return dump_block_poll_write(dev, buf, len);
+	else
+		return dump_block_intr_write(dev, buf, len);
+}
+
+
+/*
+ * Name: dump_block_ready()
+ * Func: check if the last dump i/o is over and ready for next request
+ */
+static int
+dump_block_ready(struct dump_dev *dev, void *buf)
+{
+	struct dump_blockdev *dump_bdev;
+	request_queue_t *q;
+
+	if (polling_mode)
+		return 0;
+
+	dump_bdev = DUMP_BDEV(dev);
+	q = bdev_get_queue(dump_bdev->bio->bi_bdev);
+
+	/* check for io completion */
+	if (dump_bdev->err == -EAGAIN) {
+		q->unplug_fn(q);
+		return -EAGAIN;
+	}
+
+	if (dump_bdev->err) {
+		printk("LKCD: dump i/o err\n");
+		return dump_bdev->err;
+	}
+
+	return 0;
+}
+
+
+struct dump_dev_ops dump_blockdev_ops = {
+	.open 		= dump_block_open,
+	.release	= dump_block_release,
+	.silence	= dump_block_silence,
+	.resume 	= dump_block_resume,
+	.seek		= dump_block_seek,
+	.write		= dump_block_write,
+	/* .read not implemented */
+	.ready		= dump_block_ready
+};
+
+static struct dump_blockdev default_dump_blockdev = {
+	.ddev = {.type = 1, .ops = &dump_blockdev_ops,
+			.curr_offset = 0},
+	/*
+	 * leave enough room for the longest swap header possibly written
+	 * written by mkswap (likely the largest page size supported by
+	 * the arch
+	 */
+	.start_offset 	= DUMP_HEADER_OFFSET,
+	.err 		= 0
+	/* assume the rest of the fields are zeroed by default */
+};
+
+struct dump_blockdev *dump_blockdev = &default_dump_blockdev;
+
+/*
+ * Unregister and reregister ourselves.  This has the side effect
+ * of unconfiguring the current dump device.
+ */
+static void
+dump_blockdev_unconfigure(void)
+{
+	dump_unregister_device(&dump_blockdev->ddev);
+	if (dump_register_device(&dump_blockdev->ddev) < 0)
+		printk("LKCD: block device driver registration failed\n");
+}
+
+static int __init
+dump_blockdev_init(void)
+{
+	if (dump_register_device(&dump_blockdev->ddev) < 0) {
+		printk("LKCD: block device driver registration failed\n");
+		return -1;
+	}
+
+	printk("LKCD: block device driver registered\n");
+	return 0;
+}
+
+static void __exit
+dump_blockdev_cleanup(void)
+{
+	dump_unregister_device(&dump_blockdev->ddev);
+	printk("LKCD: block device driver unregistered\n");
+}
+
+MODULE_AUTHOR("LKCD Development Team <lkcd-devel@lists.sourceforge.net>");
+MODULE_DESCRIPTION("Block Dump Driver for Linux Kernel Crash Dump (LKCD)");
+MODULE_LICENSE("GPL");
+
+module_init(dump_blockdev_init);
+module_exit(dump_blockdev_cleanup);
Index: linux-2.6.15/drivers/dump/dump_execute.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_execute.c	2006-02-12 16:58:13.913952217 +0100
@@ -0,0 +1,139 @@
+/*
+ * The file has the common/generic dump execution code
+ *
+ * Started: Oct 2002 -  Suparna Bhattacharya <suparna@in.ibm.com>
+ * 	Split and rewrote high level dump execute code to make use
+ * 	of dump method interfaces.
+ *
+ * Derived from original code in dump_base.c created by
+ * 	Matt Robinson <yakker@sourceforge.net>)
+ *
+ * Copyright (C) 1999 - 2002 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 2001 - 2002 Matt D. Robinson.  All rights reserved.
+ * Copyright (C) 2002 International Business Machines Corp.
+ *
+ * Assumes dumper and dump config settings are in place
+ * (invokes corresponding dumper specific routines as applicable)
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+#include <linux/kernel.h>
+#include <linux/notifier.h>
+#include <linux/dump.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+#include "dump_methods.h"
+
+struct notifier_block *dump_notifier_list; /* dump started/ended callback */
+
+extern int panic_timeout;
+
+/* Dump progress indicator */
+void
+dump_speedo(int i)
+{
+	static const char twiddle[4] =  { '|', '\\', '-', '/' };
+	printk("%c\b", twiddle[i&3]);
+}
+
+/* Make the device ready and write out the header */
+int dump_begin(void)
+{
+	int err = 0;
+
+	/* dump_dev = dump_config.dumper->dev; */
+	dumper_reset();
+	if ((err = dump_dev_silence())) {
+		/* quiesce failed, can't risk continuing */
+		/* Todo/Future: switch to alternate dump scheme if possible */
+		printk("LKCD: dump silence dev failed ! error %d\n", err);
+		return err;
+	}
+
+	printk("LKCD: Writing dump header\n");
+	if ((err = dump_update_header())) {
+		printk("LKCD: dump update header failed ! error %d\n", err);
+		dump_dev_resume();
+		return err;
+	}
+
+	dump_config.dumper->curr_offset = DUMP_BUFFER_SIZE;
+
+	return 0;
+}
+
+/*
+ * Write the dump terminator, a final header update and let go of
+ * exclusive use of the device for dump.
+ */
+int dump_complete(void)
+{
+	int ret = 0;
+
+	if (dump_config.level != DUMP_LEVEL_HEADER) {
+		if ((ret = dump_update_end_marker())) {
+			printk("LKCD: dump update end marker error %d\n", ret);
+		}
+		if ((ret = dump_update_header())) {
+			printk("LKCD: dump update header error %d\n", ret);
+		}
+	}
+	ret = dump_dev_resume();
+
+	return ret;
+}
+
+/* Saves all dump data */
+int dump_execute_savedump(void)
+{
+	int ret = 0, err = 0;
+
+	if ((ret = dump_begin()))  {
+		return ret;
+	}
+
+	if (dump_config.level != DUMP_LEVEL_HEADER) {
+		ret = dump_sequencer();
+	}
+	if ((err = dump_complete())) {
+		printk("LKCD: Dump complete failed. Error %d\n", err);
+	}
+
+	return ret;
+}
+
+extern void dump_calc_bootmap_pages(void);
+
+/* Does all the real work:  Capture and save state */
+int dump_generic_execute(const char *panic_str, const struct pt_regs *regs)
+{
+	int ret = 0;
+
+#ifdef CONFIG_DISCONTIGMEM
+        printk("LKCD: Reconfiguring memory bank information....\n");
+        printk("LKCD: This may take a while....\n");
+        dump_reconfigure_mbanks();
+#endif
+
+	if ((ret = dump_configure_header(panic_str, regs))) {
+		printk("LKCD: dump config header failed ! error %d\n", ret);
+		return ret;
+	}
+
+	dump_calc_bootmap_pages();
+	/* tell interested parties that a dump is about to start */
+	notifier_call_chain(&dump_notifier_list, DUMP_BEGIN,
+		&dump_config.dump_device);
+
+	if (dump_config.level != DUMP_LEVEL_NONE)
+		ret = dump_execute_savedump();
+
+	printk("LKCD: dumped %ld blocks of %d bytes each\n",
+		dump_config.dumper->count, DUMP_BUFFER_SIZE);
+
+	/* tell interested parties that a dump has completed */
+	notifier_call_chain(&dump_notifier_list, DUMP_END,
+		&dump_config.dump_device);
+
+	return ret;
+}
Index: linux-2.6.15/drivers/dump/dump_filters.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_filters.c	2006-02-12 16:58:13.913952217 +0100
@@ -0,0 +1,146 @@
+/*
+ * Default filters to select data to dump for various passes.
+ *
+ * Started: Oct 2002 -  Suparna Bhattacharya <suparna@in.ibm.com>
+ * 	Split and rewrote default dump selection logic to generic dump
+ * 	method interfaces
+ * Derived from a portion of dump_base.c created by
+ * 	Matt Robinson <yakker@sourceforge.net>)
+ *
+ * Copyright (C) 1999 - 2002 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 2001 - 2002 Matt D. Robinson.  All rights reserved.
+ * Copyright (C) 2002 International Business Machines Corp.
+ *
+ * Used during single-stage dumping and during stage 1 of the 2-stage scheme
+ * (Stage 2 of the 2-stage scheme uses the fully transparent filters
+ * i.e. passthru filters in dump_overlay.c)
+ *
+ * Future: Custom selective dump may involve a different set of filters.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+#include <linux/kernel.h>
+#include <linux/bootmem.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/dump.h>
+#include "dump_methods.h"
+
+#define DUMP_PFN_SAFETY_MARGIN  1024  /* 4 MB */
+static unsigned long bootmap_pages;
+
+/* Copied from mm/bootmem.c - FIXME */
+/* return the number of _pages_ that will be allocated for the boot bitmap */
+void dump_calc_bootmap_pages (void)
+{
+	unsigned long mapsize;
+	unsigned long pages = num_physpages;
+
+	mapsize = (pages+7)/8;
+	mapsize = (mapsize + ~PAGE_MASK) & PAGE_MASK;
+	mapsize >>= PAGE_SHIFT;
+	bootmap_pages = mapsize + DUMP_PFN_SAFETY_MARGIN + 1;
+}
+
+
+/* temporary */
+extern unsigned long min_low_pfn;
+
+
+int dump_low_page(struct page *p)
+{
+	return ((page_to_pfn(p) >= min_low_pfn) &&
+		(page_to_pfn(p) < (min_low_pfn + bootmap_pages)));
+}
+
+static inline int kernel_page(struct page *p)
+{
+	return (PageReserved(p) && !PageInuse(p)) ||
+		(!PageLRU(p) && !PageCompound(p) && PageInuse(p));
+}
+
+static inline int user_page(struct page *p)
+{
+	return PageInuse(p) && !PageReserved(p) &&
+		(PageLRU(p) ||
+		(PageCompound(p) && ((struct page *)p->private)->mapping));
+}
+
+static inline int unreferenced_page(struct page *p)
+{
+	return (!PageInuse(p) && !PageReserved(p)) ||
+		(PageCompound(p) && !((struct page *)p->private)->mapping);
+}
+
+
+/* loc marks the beginning of a range of pages */
+int dump_filter_kernpages(int pass, unsigned long loc, unsigned long sz)
+{
+	struct page *page = (struct page *)loc;
+	/* if any of the pages is a kernel page, select this set */
+	while (sz) {
+		if (dump_low_page(page) || kernel_page(page))
+			return 1;
+		sz -= PAGE_SIZE;
+		page++;
+	}
+	return 0;
+}
+
+
+/* loc marks the beginning of a range of pages */
+int dump_filter_userpages(int pass, unsigned long loc, unsigned long sz)
+{
+	struct page *page = (struct page *)loc;
+	int ret = 0;
+	/* select if the set has any user page, and no kernel pages  */
+	while (sz) {
+		if (user_page(page) && !dump_low_page(page)) {
+			ret = 1;
+		} else if (kernel_page(page) || dump_low_page(page)) {
+			return 0;
+		}
+		page++;
+		sz -= PAGE_SIZE;
+	}
+	return ret;
+}
+
+
+
+/* loc marks the beginning of a range of pages */
+int dump_filter_unusedpages(int pass, unsigned long loc, unsigned long sz)
+{
+	struct page *page = (struct page *)loc;
+
+	/* select if the set does not have any used pages  */
+	while (sz) {
+		if (!unreferenced_page(page) || dump_low_page(page)) {
+			return 0;
+		}
+		page++;
+		sz -= PAGE_SIZE;
+	}
+	return 1;
+}
+
+/* dummy: last (non-existent) pass */
+int dump_filter_none(int pass, unsigned long loc, unsigned long sz)
+{
+	return 0;
+}
+
+/* TBD: resolve level bitmask ? */
+struct dump_data_filter dump_filter_table[] = {
+	{ .name = "kern", .selector = dump_filter_kernpages,
+		.level_mask = DUMP_MASK_KERN},
+	{ .name = "user", .selector = dump_filter_userpages,
+		.level_mask = DUMP_MASK_USED},
+	{ .name = "unused", .selector = dump_filter_unusedpages,
+		.level_mask = DUMP_MASK_UNUSED},
+	{ .name = "none", .selector = dump_filter_none,
+		.level_mask = DUMP_MASK_REST},
+	{ .name = "", .selector = NULL, .level_mask = 0}
+};
+
Index: linux-2.6.15/drivers/dump/dump_fmt.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_fmt.c	2006-02-12 16:58:13.917952207 +0100
@@ -0,0 +1,396 @@
+/*
+ * Implements the routines which handle the format specific
+ * aspects of dump for the default dump format.
+ *
+ * Used in single stage dumping and stage 1 of soft-boot based dumping
+ * Saves data in LKCD (lcrash) format
+ *
+ * Previously a part of dump_base.c
+ *
+ * Started: Oct 2002 -  Suparna Bhattacharya <suparna@in.ibm.com>
+ *	Split off and reshuffled LKCD dump format code around generic
+ *	dump method interfaces.
+ *
+ * Derived from original code created by
+ * 	Matt Robinson <yakker@sourceforge.net>)
+ *
+ * Contributions from SGI, IBM, HP, MCL, and others.
+ *
+ * Copyright (C) 1999 - 2002 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 2000 - 2002 TurboLinux, Inc.  All rights reserved.
+ * Copyright (C) 2001 - 2002 Matt D. Robinson.  All rights reserved.
+ * Copyright (C) 2002 International Business Machines Corp.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/time.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/utsname.h>
+#include <linux/dump.h>
+#include <asm/dump.h>
+#include "dump_methods.h"
+
+#define DUMP_DEBUG 0
+/*
+ * SYSTEM DUMP LAYOUT
+ *
+ * System dumps are currently the combination of a dump header and a set
+ * of data pages which contain the system memory.  The layout of the dump
+ * (for full dumps) is as follows:
+ *
+ *             +-----------------------------+
+ *             |     generic dump header     |
+ *             +-----------------------------+
+ *             |   architecture dump header  |
+ *             +-----------------------------+
+ *             |         page header         |
+ *             +-----------------------------+
+ *             |          page data          |
+ *             +-----------------------------+
+ *             |         page header         |
+ *             +-----------------------------+
+ *             |          page data          |
+ *             +-----------------------------+
+ *             |              |              |
+ *             |              |              |
+ *             |              |              |
+ *             |              |              |
+ *             |              V              |
+ *             +-----------------------------+
+ *             |        PAGE_END header      |
+ *             +-----------------------------+
+ *
+ * There are two dump headers, the first which is architecture
+ * independent, and the other which is architecture dependent.  This
+ * allows different architectures to dump different data structures
+ * which are specific to their chipset, CPU, etc.
+ *
+ * After the dump headers come a succession of dump page headers along
+ * with dump pages.  The page header contains information about the page
+ * size, any flags associated with the page (whether it's compressed or
+ * not), and the address of the page.  After the page header is the page
+ * data, which is either compressed (or not).  Each page of data is
+ * dumped in succession, until the final dump header (PAGE_END) is
+ * placed at the end of the dump, assuming the dump device isn't out
+ * of space.
+ *
+ * This mechanism allows for multiple compression types, different
+ * types of data structures, different page ordering, etc., etc., etc.
+ * It's a very straightforward mechanism for dumping system memory.
+ */
+
+struct __dump_header dump_header;  /* the primary dump header              */
+struct __dump_header_asm dump_header_asm; /* the arch-specific dump header */
+
+/*
+ *  Set up common header fields (mainly the arch indep section)
+ *  Per-cpu state is handled by lcrash_save_context
+ *  Returns the size of the header in bytes.
+ */
+static int lcrash_init_dump_header(const char *panic_str)
+{
+	struct timeval dh_time;
+	u64 temp_memsz = dump_header.dh_memory_size;
+
+	/* make sure the dump header isn't TOO big */
+	if ((sizeof(struct __dump_header) +
+		sizeof(struct __dump_header_asm)) > DUMP_BUFFER_SIZE) {
+			printk("LKCD: combined "
+				"headers larger than DUMP_BUFFER_SIZE!\n");
+			return -E2BIG;
+	}
+
+	/* initialize the dump headers to zero */
+	/* save dha_stack pointer because it may contains pointer for stack! */
+	memset(&dump_header, 0, sizeof(dump_header));
+	memset(&dump_header_asm, 0,
+		offsetof(struct __dump_header_asm, dha_stack));
+	memset(&dump_header_asm.dha_stack+1, 0,
+		sizeof(dump_header_asm) -
+		offsetof(struct __dump_header_asm, dha_stack) -
+		sizeof(dump_header_asm.dha_stack));
+	dump_header.dh_memory_size = temp_memsz;
+
+	/* configure dump header values */
+	dump_header.dh_magic_number = DUMP_MAGIC_NUMBER;
+	dump_header.dh_version = DUMP_VERSION_NUMBER;
+	dump_header.dh_memory_start = PAGE_OFFSET;
+	dump_header.dh_memory_end = DUMP_MAGIC_NUMBER;
+	dump_header.dh_header_size = sizeof(struct __dump_header);
+	dump_header.dh_page_size = PAGE_SIZE;
+	dump_header.dh_dump_level = dump_config.level;
+	dump_header.dh_current_task = (unsigned long) current;
+	dump_header.dh_dump_compress = dump_config.dumper->compress->
+		compress_type;
+	dump_header.dh_dump_polling = dump_config.polling;
+	dump_header.dh_dump_device = dump_config.dumper->dev->device_id;
+	dump_header.dh_dump_buffer_size = DUMP_BUFFER_SIZE;
+
+#if DUMP_DEBUG >= 6
+	dump_header.dh_num_bytes = 0;
+#endif
+	dump_header.dh_num_dump_pages = 0;
+	do_gettimeofday(&dh_time);
+	dump_header.dh_time.tv_sec = dh_time.tv_sec;
+	dump_header.dh_time.tv_usec = dh_time.tv_usec;
+
+	memcpy((void *)&(dump_header.dh_utsname_sysname),
+		(const void *)&(system_utsname.sysname), __NEW_UTS_LEN + 1);
+	memcpy((void *)&(dump_header.dh_utsname_nodename),
+		(const void *)&(system_utsname.nodename), __NEW_UTS_LEN + 1);
+	memcpy((void *)&(dump_header.dh_utsname_release),
+		(const void *)&(system_utsname.release), __NEW_UTS_LEN + 1);
+	memcpy((void *)&(dump_header.dh_utsname_version),
+		(const void *)&(system_utsname.version), __NEW_UTS_LEN + 1);
+	memcpy((void *)&(dump_header.dh_utsname_machine),
+		(const void *)&(system_utsname.machine), __NEW_UTS_LEN + 1);
+	memcpy((void *)&(dump_header.dh_utsname_domainname),
+		(const void *)&(system_utsname.domainname), __NEW_UTS_LEN + 1);
+
+	if (panic_str) {
+		memcpy((void *)&(dump_header.dh_panic_string),
+			(const void *)panic_str, DUMP_PANIC_LEN);
+	}
+
+        dump_header_asm.dha_magic_number = DUMP_ASM_MAGIC_NUMBER;
+        dump_header_asm.dha_version = DUMP_ASM_VERSION_NUMBER;
+        dump_header_asm.dha_header_size = sizeof(dump_header_asm);
+
+	dump_header_asm.dha_smp_num_cpus = num_online_cpus();
+	printk("LKCD: smp_num_cpus in header %d\n",
+		dump_header_asm.dha_smp_num_cpus);
+
+	dump_header_asm.dha_dumping_cpu = smp_processor_id();
+
+	return sizeof(dump_header) + sizeof(dump_header_asm);
+}
+
+
+int dump_lcrash_configure_header(const char *panic_str,
+	const struct pt_regs *regs)
+{
+	int retval = 0;
+
+	dump_config.dumper->header_len = lcrash_init_dump_header(panic_str);
+
+	/* capture register states for all processors */
+	dump_save_this_cpu(regs);
+	__dump_save_other_cpus(); /* side effect:silence cpus */
+
+	/* configure architecture-specific dump header values */
+	if ((retval = __dump_configure_header(regs)))
+		return retval;
+
+	dump_config.dumper->header_dirty++;
+	return 0;
+}
+/* save register and task context */
+void dump_lcrash_save_context(int cpu, const struct pt_regs *regs,
+	struct task_struct *tsk)
+{
+	/* This level of abstraction might be redundantly redundant */
+	__dump_save_context(cpu, regs, tsk);
+}
+
+/* write out the header */
+int dump_write_header(void)
+{
+	int retval = 0, size;
+	void *buf = dump_config.dumper->dump_buf;
+
+	/* accounts for DUMP_HEADER_OFFSET if applicable */
+	if ((retval = dump_dev_seek(0))) {
+		printk("LKCD: Unable to seek to dump header offset: %d\n",
+			retval);
+		return retval;
+	}
+
+	memcpy(buf, (void *)&dump_header, sizeof(dump_header));
+	size = sizeof(dump_header);
+	memcpy(buf + size, (void *)&dump_header_asm, sizeof(dump_header_asm));
+	size += sizeof(dump_header_asm);
+	size = PAGE_ALIGN(size);
+	retval = dump_ll_write(buf , size);
+
+	if (retval < size)
+		return (retval >= 0) ? ENOSPC : retval;
+	return 0;
+}
+
+int dump_generic_update_header(void)
+{
+	int err = 0;
+
+	if (dump_config.dumper->header_dirty) {
+		if ((err = dump_write_header())) {
+			printk("LKCD: dump write header failed !err %d\n", err);
+		} else {
+			dump_config.dumper->header_dirty = 0;
+		}
+	}
+
+	return err;
+}
+
+static inline int is_curr_stack_page(struct page *page, unsigned long size)
+{
+	unsigned long thread_addr = (unsigned long)current_thread_info();
+	unsigned long addr = (unsigned long)page_address(page);
+
+	return !PageHighMem(page) && (addr < thread_addr + THREAD_SIZE)
+		&& (addr + size > thread_addr);
+}
+
+static inline int is_dump_page(struct page *page, unsigned long size)
+{
+	unsigned long addr = (unsigned long)page_address(page);
+	unsigned long dump_buf = (unsigned long)dump_config.dumper->dump_buf;
+
+	return !PageHighMem(page) && (addr < dump_buf + DUMP_BUFFER_SIZE)
+		&& (addr + size > dump_buf);
+}
+
+int dump_allow_compress(struct page *page, unsigned long size)
+{
+	/*
+	 * Don't compress the page if any part of it overlaps
+	 * with the current stack or dump buffer (since the contents
+	 * in these could be changing while compression is going on)
+	 */
+	return !is_curr_stack_page(page, size) && !is_dump_page(page, size);
+}
+
+void lcrash_init_pageheader(struct __dump_page *dp, struct page *page,
+	unsigned long sz)
+{
+	memset(dp, sizeof(struct __dump_page), 0);
+	dp->dp_flags = 0;
+	dp->dp_size = 0;
+	if (sz > 0)
+		dp->dp_address = (loff_t)page_to_pfn(page) << PAGE_SHIFT;
+
+#if DUMP_DEBUG > 6
+	dp->dp_page_index = dump_header.dh_num_dump_pages;
+	dp->dp_byte_offset = dump_header.dh_num_bytes + DUMP_BUFFER_SIZE
+		+ DUMP_HEADER_OFFSET; /* ?? */
+#endif /* DUMP_DEBUG */
+}
+
+int dump_lcrash_add_data(unsigned long loc, unsigned long len)
+{
+	struct page *page = (struct page *)loc;
+	void *addr, *buf = dump_config.dumper->curr_buf;
+	struct __dump_page *dp = (struct __dump_page *)buf;
+	int bytes, size;
+
+	if (buf > dump_config.dumper->dump_buf + DUMP_BUFFER_SIZE)
+		return -ENOMEM;
+
+	lcrash_init_pageheader(dp, page, len);
+	buf += sizeof(struct __dump_page);
+
+	while (len) {
+		addr = kmap_atomic(page, KM_DUMP);
+		size = bytes = (len > PAGE_SIZE) ? PAGE_SIZE : len;
+		/* check for compression */
+		if (dump_allow_compress(page, bytes)) {
+			size = dump_compress_data((char *)addr, bytes,
+				(char *)buf, loc);
+		}
+		/* set the compressed flag if the page did compress */
+		if (size && (size < bytes)) {
+			dp->dp_flags |= DUMP_DH_COMPRESSED;
+		} else {
+			/* compression failed -- default to raw mode */
+			dp->dp_flags |= DUMP_DH_RAW;
+			memcpy(buf, addr, bytes);
+			size = bytes;
+		}
+		/* memset(buf, 'A', size); temporary: testing only !! */
+		kunmap_atomic(addr, KM_DUMP);
+		dp->dp_size += size;
+		buf += size;
+		len -= bytes;
+		page++;
+	}
+
+	/* now update the header */
+#if DUMP_DEBUG > 6
+	dump_header.dh_num_bytes += dp->dp_size + sizeof(*dp);
+#endif
+	dump_header.dh_num_dump_pages++;
+	dump_config.dumper->header_dirty++;
+
+	dump_config.dumper->curr_buf = buf;
+
+	return len;
+}
+
+int dump_lcrash_update_end_marker(void)
+{
+	struct __dump_page *dp =
+		(struct __dump_page *)dump_config.dumper->curr_buf;
+	unsigned long left;
+	int ret = 0;
+
+	lcrash_init_pageheader(dp, NULL, 0);
+	dp->dp_flags |= DUMP_DH_END; /* tbd: truncation test ? */
+
+	/* now update the header */
+#if DUMP_DEBUG > 6
+	dump_header.dh_num_bytes += sizeof(*dp);
+#endif
+	dump_config.dumper->curr_buf += sizeof(*dp);
+	left = dump_config.dumper->curr_buf - dump_config.dumper->dump_buf;
+
+	printk("\n");
+
+	while (left) {
+		if ((ret = dump_dev_seek(dump_config.dumper->curr_offset))) {
+			printk("LKCD: Seek failed at offset 0x%llx\n",
+			dump_config.dumper->curr_offset);
+			return ret;
+		}
+
+		if (DUMP_BUFFER_SIZE > left)
+			memset(dump_config.dumper->curr_buf, 'm',
+				DUMP_BUFFER_SIZE - left);
+
+		if ((ret = dump_ll_write(dump_config.dumper->dump_buf,
+			DUMP_BUFFER_SIZE)) < DUMP_BUFFER_SIZE) {
+			return (ret < 0) ? ret : -ENOSPC;
+		}
+
+		dump_config.dumper->curr_offset += DUMP_BUFFER_SIZE;
+
+		if (left > DUMP_BUFFER_SIZE) {
+			left -= DUMP_BUFFER_SIZE;
+			memcpy(dump_config.dumper->dump_buf,
+			dump_config.dumper->dump_buf + DUMP_BUFFER_SIZE, left);
+			dump_config.dumper->curr_buf -= DUMP_BUFFER_SIZE;
+		} else {
+			left = 0;
+		}
+	}
+	return 0;
+}
+
+
+/* Default Formatter (lcrash) */
+struct dump_fmt_ops dump_fmt_lcrash_ops = {
+	.configure_header	= dump_lcrash_configure_header,
+	.update_header		= dump_generic_update_header,
+	.save_context		= dump_lcrash_save_context,
+	.add_data		= dump_lcrash_add_data,
+	.update_end_marker	= dump_lcrash_update_end_marker
+};
+
+struct dump_fmt dump_fmt_lcrash = {
+	.name	= "lcrash",
+	.ops	= &dump_fmt_lcrash_ops
+};
+
Index: linux-2.6.15/drivers/dump/dump_gzip.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_gzip.c	2006-02-12 16:58:13.917952207 +0100
@@ -0,0 +1,173 @@
+/*
+ * GZIP Compression functions for kernel crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sourceforge.net)
+ * Copyright 2001 Matt D. Robinson.  All rights reserved.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/* header files */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/dump.h>
+#include <linux/zlib.h>
+#include <linux/vmalloc.h>
+
+static void *deflate_workspace;
+static unsigned long workspace_paddr[2];
+
+static u8 *safety_buffer;
+
+/*
+ * Name: dump_compress_gzip()
+ * Func: Compress a DUMP_PAGE_SIZE page using gzip-style algorithms (the.
+ *       deflate functions similar to what's used in PPP).
+ */
+static u32
+dump_compress_gzip(const u8 *old, u32 oldsize, u8 *new, u32 newsize,
+		unsigned long loc)
+{
+	/* error code and dump stream */
+	int err;
+	z_stream dump_stream;
+	struct page *pg = (struct page *)loc;
+	unsigned long paddr =  page_to_pfn(pg) << PAGE_SHIFT;
+	static int warning = 0;
+
+	dump_stream.workspace = deflate_workspace;
+	if ((paddr == workspace_paddr[0]) || (paddr == workspace_paddr[1])) {
+		/*
+		 * This page belongs to deflate_workspace used as temporary
+		 * buffer for compression. Hence, dump them without compression.
+		 */
+		return(0);
+	}
+	if ((err = zlib_deflateInit(&dump_stream, dump_compress_level)) != Z_OK) {
+		printk("LKCD: dump_compress_gzip(): zlib_deflateInit() "
+			"failed (%d)!\n", err);
+		return 0;
+	}
+
+	/* copy the old page to the safety buffer */
+	if (oldsize <= DUMP_PAGE_SIZE) {
+		memcpy(safety_buffer, old, oldsize);
+		dump_stream.next_in = (u8 *) safety_buffer;
+	} else {
+		if (!warning) {
+			printk("LKCD: dump_compress_gzip oversize input: %d\n",
+					oldsize);
+			warning++;
+		}
+		dump_stream.next_in = (u8 *) old;
+	}
+
+	/* use old (page of memory) and size (DUMP_PAGE_SIZE) as in-streams */
+	dump_stream.avail_in = oldsize;
+
+	/* out streams are new (dpcpage) and new size (DUMP_DPC_PAGE_SIZE) */
+	dump_stream.next_out = new;
+	dump_stream.avail_out = newsize;
+
+	/* deflate the page -- check for error */
+	err = zlib_deflate(&dump_stream, Z_FINISH);
+	if (err != Z_STREAM_END) {
+		/* zero is return code here */
+		(void)zlib_deflateEnd(&dump_stream);
+		printk("LKCD: dump_compress_gzip(): zlib_deflate() failed (%d)!\n",
+			err);
+		return 0;
+	}
+
+	/* let's end the deflated compression stream */
+	if ((err = zlib_deflateEnd(&dump_stream)) != Z_OK) {
+		printk("LKCD: dump_compress_gzip(): zlib_deflateEnd() "
+			"failed (%d)!\n", err);
+	}
+
+	/* return the compressed byte total (if it's smaller) */
+	if (dump_stream.total_out >= oldsize) {
+		return oldsize;
+	}
+	return dump_stream.total_out;
+}
+
+/* setup the gzip compression functionality */
+static struct __dump_compress dump_gzip_compression = {
+	.compress_type = DUMP_COMPRESS_GZIP,
+	.compress_func = dump_compress_gzip,
+	.compress_name = "GZIP",
+};
+
+/*
+ * Name: dump_compress_gzip_init()
+ * Func: Initialize gzip as a compression mechanism.
+ */
+static int __init
+dump_compress_gzip_init(void)
+{
+	struct page *pg;
+
+	deflate_workspace = vmalloc(zlib_deflate_workspacesize());
+	if (!deflate_workspace) {
+		printk("LKCD: dump_compress_gzip_init(): Failed to "
+			"alloc %d bytes for deflate workspace\n",
+			zlib_deflate_workspacesize());
+		return -ENOMEM;
+	}
+	/*
+	 * Need to find pages (workspace) that are used for compression.
+	 * Even though zlib_deflate_workspacesize() is 64 pages (approximately)
+	 * depends on the arch, we used only 2 pages. Hence, get the physical
+	 * addresses for these 2 pages and used them to not to compress those
+	 * pages.
+	 */
+	pg = vmalloc_to_page(deflate_workspace);
+	workspace_paddr[0] = page_to_pfn(pg) << PAGE_SHIFT;
+	pg = vmalloc_to_page(deflate_workspace + DUMP_PAGE_SIZE);
+	workspace_paddr[1] = page_to_pfn(pg) << PAGE_SHIFT;
+
+	/* Eliminate the possibility of real data getting a compression
+	 * failure.
+	 */
+
+	if (!(safety_buffer = (void *)__get_free_pages(GFP_KERNEL,
+					get_order(DUMP_PAGE_SIZE))))
+		return -ENOMEM;
+
+	printk("LKCD: dump gzip safety buffer: %p, %d\n", safety_buffer,
+			(int)DUMP_PAGE_SIZE);
+
+	dump_register_compression(&dump_gzip_compression);
+	return 0;
+}
+
+/*
+ * Name: dump_compress_gzip_cleanup()
+ * Func: Remove gzip as a compression mechanism.
+ */
+static void __exit
+dump_compress_gzip_cleanup(void)
+{
+	vfree(deflate_workspace);
+	if (safety_buffer) {
+		free_pages((unsigned long)safety_buffer,
+				get_order(DUMP_PAGE_SIZE));
+		safety_buffer = NULL;
+	}
+
+	dump_unregister_compression(DUMP_COMPRESS_GZIP);
+}
+
+/* module initialization */
+module_init(dump_compress_gzip_init);
+module_exit(dump_compress_gzip_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("LKCD Development Team <lkcd-devel@lists.sourceforge.net>");
+MODULE_DESCRIPTION("Gzip compression module for crash dump driver");
Index: linux-2.6.15/drivers/dump/dump_i386.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_i386.c	2006-02-12 16:58:13.917952207 +0100
@@ -0,0 +1,386 @@
+/*
+ * Architecture specific (i386) functions for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ *
+ * Copyright 1999 Silicon Graphics, Inc. All rights reserved.
+ *
+ * 2.3 kernel modifications by: Matt D. Robinson (yakker@turbolinux.com)
+ * Copyright 2000 TurboLinux, Inc.  All rights reserved.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/*
+ * The hooks for dumping the kernel virtual memory to disk are in this
+ * file.  Any time a modification is made to the virtual memory mechanism,
+ * these routines must be changed to use the new mechanisms.
+ */
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/smp.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/dump.h>
+#include "dump_methods.h"
+#include <linux/irq.h>
+
+#include <asm/processor.h>
+#include <asm/e820.h>
+#include <asm/hardirq.h>
+#include <asm/nmi.h>
+
+static __s32 	     saved_irq_count;	/* saved preempt_count() flags */
+
+static int
+alloc_dha_stack(void)
+{
+	int i;
+	void *ptr;
+
+	if (dump_header_asm.dha_stack[0])
+		return 0;
+
+	ptr = vmalloc(THREAD_SIZE * num_online_cpus());
+	if (!ptr) {
+		printk("LKCD: vmalloc for dha_stacks failed\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < num_online_cpus(); i++) {
+		dump_header_asm.dha_stack[i] = (u32)((unsigned long)ptr +
+				(i * THREAD_SIZE));
+	}
+	return 0;
+}
+
+static int
+free_dha_stack(void)
+{
+	if (dump_header_asm.dha_stack[0]) {
+		vfree((void *)dump_header_asm.dha_stack[0]);
+		dump_header_asm.dha_stack[0] = 0;
+	}
+	return 0;
+}
+
+
+void
+__dump_save_regs(struct pt_regs *dest_regs, const struct pt_regs *regs)
+{
+	*dest_regs = *regs;
+
+	/* In case of panic dumps, we collects regs on entry to panic.
+	 * so, we shouldn't 'fix' ssesp here again. But it is hard to
+	 * tell just looking at regs whether ssesp need fixing. We make
+	 * this decision by looking at xss in regs. If we have better
+	 * means to determine that ssesp are valid (by some flag which
+	 * tells that we are here due to panic dump), then we can use
+	 * that instead of this kludge.
+	 */
+	if (!user_mode(regs)) {
+		if ((0xffff & regs->xss) == __KERNEL_DS)
+			/* already fixed up */
+			return;
+		dest_regs->esp = (unsigned long)&(regs->esp);
+		__asm__ __volatile__ ("movw %%ss, %%ax;"
+			:"=a"(dest_regs->xss));
+	}
+}
+
+void
+__dump_save_context(int cpu, const struct pt_regs *regs,
+	struct task_struct *tsk)
+{
+	dump_header_asm.dha_smp_current_task[cpu] = (unsigned long)tsk;
+	__dump_save_regs(&dump_header_asm.dha_smp_regs[cpu], regs);
+
+	/* take a snapshot of the stack */
+	/* doing this enables us to tolerate slight drifts on this cpu */
+
+	if (dump_header_asm.dha_stack[cpu]) {
+		memcpy((void *)dump_header_asm.dha_stack[cpu],
+				STACK_START_POSITION(tsk),
+				THREAD_SIZE);
+	}
+	dump_header_asm.dha_stack_ptr[cpu] = (unsigned long)(tsk->thread_info);
+}
+
+#ifdef CONFIG_SMP
+extern cpumask_t irq_affinity[];
+extern irq_desc_t irq_desc[];
+extern void dump_send_ipi(void);
+
+static int dump_expect_ipi[NR_CPUS];
+static atomic_t waiting_for_dump_ipi;
+static cpumask_t saved_affinity[NR_IRQS];
+
+extern void stop_this_cpu(void *); /* exported by i386 kernel */
+
+static int
+dump_nmi_callback(struct pt_regs *regs, int cpu)
+{
+	if (!dump_expect_ipi[cpu])
+		return 0;
+
+	dump_expect_ipi[cpu] = 0;
+
+	dump_save_this_cpu(regs);
+	atomic_dec(&waiting_for_dump_ipi);
+
+ level_changed:
+	switch (dump_silence_level) {
+	case DUMP_HARD_SPIN_CPUS:	/* Spin until dump is complete */
+		while (dump_oncpu) {
+			barrier();    	/* paranoia */
+			if (dump_silence_level != DUMP_HARD_SPIN_CPUS)
+				goto level_changed;
+
+			cpu_relax();	/* kill time nicely */
+		}
+		break;
+
+	case DUMP_HALT_CPUS:		/* Execute halt */
+		stop_this_cpu(NULL);
+		break;
+
+	case DUMP_SOFT_SPIN_CPUS:
+		/* Mark the task so it spins in schedule */
+		set_tsk_thread_flag(current, TIF_NEED_RESCHED);
+		break;
+	}
+
+	return 1;
+}
+
+/* save registers on other processors */
+void
+__dump_save_other_cpus(void)
+{
+	int i, cpu = smp_processor_id();
+	int other_cpus = num_online_cpus()-1;
+
+	if (other_cpus > 0) {
+		atomic_set(&waiting_for_dump_ipi, other_cpus);
+
+		for (i = 0; i < NR_CPUS; i++) {
+			dump_expect_ipi[i] = (i != cpu && cpu_online(i));
+		}
+
+		/* short circuit normal NMI handling temporarily */
+		set_nmi_callback(dump_nmi_callback);
+		wmb();
+
+		dump_send_ipi();
+		/* may be we dont need to wait for NMI to be processed.
+		   just write out the header at the end of dumping, if
+		   this IPI is not processed until then, there probably
+		   is a problem and we just fail to capture state of
+		   other cpus. */
+		while(atomic_read(&waiting_for_dump_ipi) > 0) {
+			cpu_relax();
+		}
+
+		unset_nmi_callback();
+	}
+}
+
+/*
+ * Routine to save the old irq affinities and change affinities of all irqs to
+ * the dumping cpu.
+ */
+static void
+set_irq_affinity(void)
+{
+	int i;
+	cpumask_t cpu = CPU_MASK_NONE;
+
+	cpu_set(smp_processor_id(), cpu);
+	memcpy(saved_affinity, irq_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		irq_affinity[i] = cpu;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, irq_affinity[i]);
+	}
+}
+
+/*
+ * Restore old irq affinities.
+ */
+static void
+reset_irq_affinity(void)
+{
+	int i;
+
+	memcpy(irq_affinity, saved_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, saved_affinity[i]);
+	}
+}
+
+#else /* !CONFIG_SMP */
+#define set_irq_affinity()	do { } while (0)
+#define reset_irq_affinity()	do { } while (0)
+#define save_other_cpu_states() do { } while (0)
+#endif /* !CONFIG_SMP */
+
+/*
+ * Kludge - dump from interrupt context is unreliable (Fixme)
+ *
+ * We do this so that softirqs initiated for dump i/o
+ * get processed and we don't hang while waiting for i/o
+ * to complete or in any irq synchronization attempt.
+ *
+ * This is not quite legal of course, as it has the side
+ * effect of making all interrupts & softirqs triggered
+ * while dump is in progress complete before currently
+ * pending softirqs and the currently executing interrupt
+ * code.
+ */
+static inline void
+irq_bh_save(void)
+{
+	saved_irq_count = irq_count();
+	preempt_count() &= ~(HARDIRQ_MASK|SOFTIRQ_MASK);
+}
+
+static inline void
+irq_bh_restore(void)
+{
+	preempt_count() |= saved_irq_count;
+}
+
+/*
+ * Name: __dump_irq_enable
+ * Func: Reset system so interrupts are enabled.
+ *	 This is used for dump methods that require interrupts
+ *	 Eventually, all methods will have interrupts disabled
+ *	 and this code can be removed.
+ *
+ *     Change irq affinities
+ *     Re-enable interrupts
+ */
+int
+__dump_irq_enable(void)
+{
+	set_irq_affinity();
+	irq_bh_save();
+	local_irq_enable();
+	return 0;
+}
+
+/*
+ * Name: __dump_irq_restore
+ * Func: Resume the system state in an architecture-specific way.
+
+ */
+void
+__dump_irq_restore(void)
+{
+	local_irq_disable();
+	reset_irq_affinity();
+	irq_bh_restore();
+}
+
+/*
+ * Name: __dump_kernel_addr()
+ * Func: Return physical kernel load address.
+ */
+unsigned long
+__dump_kernel_addr(void)
+{
+	/* Unsatisfactory - arch/i386/kernel/vmlinux.lds.S hard codes the
+	 * offset to the start of the text.  It should be a global arch
+	 * specific define.
+	 */
+	return virt_to_phys((void *)(0xC0000000 + 0x100000));
+}
+
+/*
+ * Name: __dump_configure_header()
+ * Func: Meant to fill in arch specific header fields except per-cpu state
+ * already captured via __dump_save_context for all CPUs.
+ */
+int
+__dump_configure_header(const struct pt_regs *regs)
+{
+	return (0);
+}
+
+/*
+ * Name: __dump_init()
+ * Func: Initialize the dumping routine process.
+ */
+void
+__dump_init(uint64_t local_memory_start)
+{
+	return;
+}
+
+/*
+ * Name: __dump_open()
+ * Func: Open the dump device (architecture specific).
+ */
+void
+__dump_open(void)
+{
+	alloc_dha_stack();
+}
+
+/*
+ * Name: __dump_cleanup()
+ * Func: Free any architecture specific data structures. This is called
+ *       when the dump module is being removed.
+ */
+void
+__dump_cleanup(void)
+{
+	free_dha_stack();
+}
+
+extern int page_is_ram(unsigned long);
+
+/*
+ * Name: __dump_page_valid()
+ * Func: Check if page is valid to dump.
+ */
+int
+__dump_page_valid(unsigned long index)
+{
+	if (!pfn_valid(index))
+		return 0;
+
+	return page_is_ram(index);
+}
+
+/*
+ * Name: manual_handle_crashdump()
+ * Func: Interface for the lkcd dump command. Calls dump_execute()
+ */
+int
+manual_handle_crashdump(void) {
+
+	struct pt_regs regs;
+
+	get_current_regs(&regs);
+	dump_execute("manual", &regs);
+	return 0;
+}
+
+/*
+ * Name: __dump_clean_irq_state()
+ * Func: Clean up from the previous IRQ handling state. Such as oops from
+ *       interrupt handler or bottom half.
+ */
+void
+__dump_clean_irq_state(void)
+{
+    return;
+}
Index: linux-2.6.15/drivers/dump/dump_ia64.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_ia64.c	2006-02-12 16:58:13.917952207 +0100
@@ -0,0 +1,468 @@
+/*
+ * Architecture specific (ia64) functions for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ * Contributions from SGI, IBM, and others.
+ *
+ * 2.4  kernel modifications by:  Matt D. Robinson (yakker@alacritech.com)
+ * ia64 kernel modifications by: Piet Delaney (piet@www.piet.net)
+ *
+ * Copyright (C) 2001 - 2002 Matt D. Robinson (yakker@alacritech.com)
+ * Copyright (C) 2002 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 2002 Free Software Foundation, Inc. All rights reserved.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/*
+ * The hooks for dumping the kernel virtual memory to disk are in this
+ * file.  Any time a modification is made to the virtual memory mechanism,
+ * these routines must be changed to use the new mechanisms.
+ */
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/smp.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/dump.h>
+#include "dump_methods.h"
+#include <linux/mm.h>
+#include <asm/processor.h>
+#include <asm-ia64/dump.h>
+#include <asm/hardirq.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+static __s32         saved_irq_count;   /* saved preempt_count() flags */
+
+
+static int alloc_dha_stack(void)
+{
+	int i;
+	void *ptr;
+
+	if (dump_header_asm.dha_stack[0])
+	{
+		return 0;
+	}
+       	ptr = vmalloc(THREAD_SIZE * num_online_cpus());
+       	if (!ptr) {
+		printk("LKCD: vmalloc for dha_stacks failed\n");
+		return -ENOMEM;
+	}
+	bzero(ptr,THREAD_SIZE );
+
+	for (i = 0; i < num_online_cpus(); i++) {
+		dump_header_asm.dha_stack[i] = (uint64_t)((unsigned long)ptr + (i * THREAD_SIZE));
+	}
+	return 0;
+}
+
+static int free_dha_stack(void)
+{
+	if (dump_header_asm.dha_stack[0])
+	{
+		vfree((void*)dump_header_asm.dha_stack[0]);
+		dump_header_asm.dha_stack[0] = 0;
+	}
+	return 0;
+}
+
+/* a structure to get arguments into the following callback routine */
+struct unw_args {
+	int cpu;
+	struct task_struct *tsk;
+};
+
+static void
+do_save_sw(struct unw_frame_info *info, void *arg)
+{
+	struct unw_args *uwargs = (struct unw_args *)arg;
+	int cpu = uwargs->cpu;
+	struct task_struct *tsk = uwargs->tsk;
+
+	dump_header_asm.dha_stack_ptr[cpu] = (uint64_t)info->sw;
+
+	if (tsk && dump_header_asm.dha_stack[cpu]) {
+		memcpy((void *)dump_header_asm.dha_stack[cpu],
+				STACK_START_POSITION(tsk),
+				THREAD_SIZE);
+	}
+}
+
+void
+__dump_save_context(int cpu, const struct pt_regs *regs,
+	struct task_struct *tsk)
+{
+	struct unw_args uwargs;
+
+	dump_header_asm.dha_smp_current_task[cpu] = (unsigned long)tsk;
+
+	if (regs) {
+		dump_header_asm.dha_smp_regs[cpu] = *regs;
+	}
+
+	/* save a snapshot of the stack in a nice state for unwinding */
+	uwargs.cpu = cpu;
+	uwargs.tsk = tsk;
+
+	unw_init_running(do_save_sw, (void *)&uwargs);
+}
+
+#ifdef CONFIG_SMP
+
+extern cpumask_t irq_affinity[];
+extern irq_desc_t irq_desc[];
+extern void dump_send_ipi(void);
+static cpumask_t saved_affinity[NR_IRQS];
+
+/*
+ * Routine to save the old irq affinities and change affinities of all irqs to
+ * the dumping cpu.
+ */
+static void
+set_irq_affinity(void)
+{
+        int i;
+	cpumask_t cpu = CPU_MASK_NONE;
+
+	cpu_set(smp_processor_id(), cpu);
+        memcpy(saved_affinity, irq_affinity, NR_IRQS * sizeof(unsigned long));
+        for (i = 0; i < NR_IRQS; i++) {
+                if (irq_desc[i].handler == NULL)
+                        continue;
+		irq_affinity[i] = cpu;
+                if (irq_desc[i].handler->set_affinity != NULL)
+                        irq_desc[i].handler->set_affinity(i, irq_affinity[i]);
+        }
+}
+
+/*
+ * Restore old irq affinities.
+ */
+static void
+reset_irq_affinity(void)
+{
+        int i;
+
+        memcpy(irq_affinity, saved_affinity, NR_IRQS * sizeof(unsigned long));
+        for (i = 0; i < NR_IRQS; i++) {
+                if (irq_desc[i].handler == NULL)
+                        continue;
+                if (irq_desc[i].handler->set_affinity != NULL)
+                        irq_desc[i].handler->set_affinity(i, saved_affinity[i]);
+        }
+}
+
+#else /* !CONFIG_SMP */
+#define set_irq_affinity()      do { } while (0)
+#define reset_irq_affinity()    do { } while (0)
+#define save_other_cpu_states() do { } while (0)
+#endif /* !CONFIG_SMP */
+
+#ifdef CONFIG_SMP
+static int dump_expect_ipi[NR_CPUS];
+static atomic_t waiting_for_dump_ipi;
+static int wait_for_dump_ipi = 2000; /* wait 2000 ms for ipi to be handled */
+extern void (*dump_trace_ptr)(struct pt_regs *);
+
+
+extern void stop_this_cpu(void);
+
+static int
+dump_nmi_callback(struct pt_regs *regs, int cpu)
+{
+        if (!dump_expect_ipi[cpu])
+                return 0;
+
+        dump_expect_ipi[cpu] = 0;
+
+        dump_save_this_cpu(regs);
+        atomic_dec(&waiting_for_dump_ipi);
+
+ level_changed:
+        switch (dump_silence_level) {
+        case DUMP_HARD_SPIN_CPUS:       /* Spin until dump is complete */
+                while (dump_oncpu) {
+                        barrier();      /* paranoia */
+                        if (dump_silence_level != DUMP_HARD_SPIN_CPUS)
+                                goto level_changed;
+
+                        cpu_relax();    /* kill time nicely */
+                }
+                break;
+
+        case DUMP_HALT_CPUS:            /* Execute halt */
+                stop_this_cpu();
+                break;
+
+        case DUMP_SOFT_SPIN_CPUS:
+                /* Mark the task so it spins in schedule */
+                set_tsk_thread_flag(current, TIF_NEED_RESCHED);
+                break;
+        }
+
+        return 1;
+}
+
+int IPI_handler(struct pt_regs *regs)
+{
+	int cpu;
+	cpu = task_cpu(current);
+	return(dump_nmi_callback(regs, cpu));
+}
+
+/* save registers on other processors */
+void
+__dump_save_other_cpus(void)
+{
+        int i, cpu = smp_processor_id();
+        int other_cpus = num_online_cpus()-1;
+	int wait_time = wait_for_dump_ipi;
+
+        if (other_cpus > 0) {
+                atomic_set(&waiting_for_dump_ipi, other_cpus);
+
+                for (i = 0; i < NR_CPUS; i++) {
+                        dump_expect_ipi[i] = (i != cpu && cpu_online(i));
+                }
+
+		dump_ipi_function_ptr = IPI_handler;
+
+                wmb();
+
+                dump_send_ipi();
+                /* may be we dont need to wait for IPI to be processed.
+                 * just write out the header at the end of dumping, if
+                 * this IPI is not processed until then, there probably
+                 * is a problem and we just fail to capture state of
+                 * other cpus. */
+                while(wait_time-- && (atomic_read(&waiting_for_dump_ipi) > 0)) {
+			barrier();
+			mdelay(1);
+                }
+		if (wait_time <= 0) {
+			printk("LKCD: dump ipi timeout, proceeding...\n");
+		}
+        }
+}
+#endif
+/*
+ * Kludge - dump from interrupt context is unreliable (Fixme)
+ *
+ * We do this so that softirqs initiated for dump i/o
+ * get processed and we don't hang while waiting for i/o
+ * to complete or in any irq synchronization attempt.
+ *
+ * This is not quite legal of course, as it has the side
+ * effect of making all interrupts & softirqs triggered
+ * while dump is in progress complete before currently
+ * pending softirqs and the currently executing interrupt
+ * code.
+ */
+static inline void
+irq_bh_save(void)
+{
+        saved_irq_count = irq_count();
+        preempt_count() &= ~(HARDIRQ_MASK|SOFTIRQ_MASK);
+}
+
+static inline void
+irq_bh_restore(void)
+{
+        preempt_count() |= saved_irq_count;
+}
+
+/*
+ * Name: __dump_kernel_addr()
+ * Func: Return physical kernel load address.
+ */
+unsigned long
+__dump_kernel_addr(void)
+{
+	return ia64_tpa(KERNEL_START);
+}
+
+/*
+ * Name: __dump_configure_header()
+ * Func: Configure the dump header with all proper values.
+ */
+int
+__dump_configure_header(const struct pt_regs *regs)
+{
+	dump_header_asm.dha_kernel_addr = __dump_kernel_addr();
+	return (0);
+}
+
+
+#define dim(x) (sizeof(x)/sizeof(*(x)))
+
+/*
+ * Name: __dump_irq_enable
+ * Func: Reset system so interrupts are enabled.
+ *       This is used for dump methods that require interrupts
+ *       Eventually, all methods will have interrupts disabled
+ *       and this code can be removed.
+ *
+ *     Change irq affinities
+ *     Re-enable interrupts
+ */
+int
+__dump_irq_enable(void)
+{
+        set_irq_affinity();
+        irq_bh_save();
+	ia64_srlz_d();
+	/*
+	 * reduce the task priority level
+  	 * to get disk interrupts
+	 */
+	ia64_setreg(_IA64_REG_CR_TPR, 0);
+	ia64_srlz_d();
+        local_irq_enable();
+	return 0;
+}
+
+/*
+ * Name: __dump_irq_restore
+ * Func: Resume the system state in an architecture-specific way.
+
+ */
+void
+__dump_irq_restore(void)
+{
+        local_irq_disable();
+        reset_irq_affinity();
+        irq_bh_restore();
+}
+
+/*
+ * Name: __dump_page_valid()
+ * Func: Check if page is valid to dump.
+ */
+int
+__dump_page_valid(unsigned long index)
+{
+        if (!pfn_valid(index))
+	{
+                return 0;
+	}
+        return 1;
+}
+
+/*
+ * Name: __dump_init()
+ * Func: Initialize the dumping routine process.  This is in case
+ *       it's necessary in the future.
+ */
+void
+__dump_init(uint64_t local_memory_start)
+{
+	return;
+}
+
+/*
+ * Name: __dump_open()
+ * Func: Open the dump device (architecture specific).  This is in
+ *       case it's necessary in the future.
+ */
+void
+__dump_open(void)
+{
+	alloc_dha_stack();
+	return;
+}
+
+
+/*
+ * Name: __dump_cleanup()
+ * Func: Free any architecture specific data structures. This is called
+ *       when the dump module is being removed.
+ */
+void
+__dump_cleanup(void)
+{
+	free_dha_stack();
+
+	return;
+}
+
+
+
+int __dump_memcpy_mc_expected = 0;		/* Doesn't help yet */
+
+/*
+ * An ia64 version of memcpy() that trys to avoid machine checks.
+ *
+ * NB:
+ * 	By itself __dump_memcpy_mc_expected() ins't providing any
+ *	protection against Machine Checks. We are looking into the
+ *	possability of adding code to the arch/ia64/kernel/mca.c fuction
+ *	ia64_mca_ucmc_handler() to restore state so that a IA64_MCA_CORRECTED
+ *	can be returned to the firmware. Curently it always returns
+ *	IA64_MCA_COLD_BOOT and reboots the machine.
+ */
+/*
+void * __dump_memcpy(void * dest, const void *src, size_t count)
+{
+	void *vp;
+
+	if (__dump_memcpy_mc_expected) {
+		ia64_pal_mc_expected((u64) 1, 0);
+	}
+
+	vp = memcpy(dest, src, count);
+
+	if (__dump_memcpy_mc_expected) {
+		ia64_pal_mc_expected((u64) 0, 0);
+	}
+	return(vp);
+}
+*/
+/*
+ * Name: manual_handle_crashdump()
+ * Func: Interface for the lkcd dump command. Calls dump_execute()
+ */
+int
+manual_handle_crashdump(void) {
+
+        struct pt_regs regs;
+
+        get_current_regs(&regs);
+        dump_execute("manual", &regs);
+        return 0;
+}
+
+/*
+ * Name: __dump_clean_irq_state()
+ * Func: Clean up from the previous IRQ handling state. Such as oops from
+ *       interrupt handler or bottom half.
+ */
+void
+__dump_clean_irq_state(void)
+{
+    	unsigned long saved_tpr;
+	unsigned long TPR_MASK = 0xFFFFFFFFFFFEFF0F;
+
+
+	/* Get the processors task priority register */
+	saved_tpr = ia64_getreg(_IA64_REG_CR_TPR);
+	/* clear the mmi and mic bit's of the TPR to unmask interrupts */
+	saved_tpr = saved_tpr & TPR_MASK;
+	ia64_setreg(_IA64_REG_CR_TPR, saved_tpr);
+	ia64_srlz_d();
+
+	/* Tell the processor we're done with the interrupt
+	 * that got us here.
+	 */
+
+	ia64_eoi();
+
+	/* local implementation of irq_exit(); */
+	preempt_count() -= IRQ_EXIT_OFFSET;
+	preempt_enable_no_resched();
+
+	return;
+}
+
Index: linux-2.6.15/drivers/dump/dump_methods.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_methods.h	2006-02-12 16:58:13.925952185 +0100
@@ -0,0 +1,339 @@
+/*
+ * Generic interfaces for flexible system dump
+ *
+ * Started: Oct 2002 -  Suparna Bhattacharya (suparna@in.ibm.com)
+ *
+ * Copyright (C) 2002 International Business Machines Corp.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+#ifndef _LINUX_DUMP_METHODS_H
+#define _LINUX_DUMP_METHODS_H
+
+/*
+ * Inspired by Matt Robinson's suggestion of introducing dump
+ * methods as a way to enable different crash dump facilities to
+ * coexist where each employs its own scheme or dumping policy.
+ *
+ * The code here creates a framework for flexible dump by defining
+ * a set of methods and providing associated helpers that differentiate
+ * between the underlying mechanism (how to dump), overall scheme
+ * (sequencing of stages and data dumped and associated quiescing),
+ * output format (what the dump output looks like), target type
+ * (where to save the dump; see dumpdev.h), and selection policy
+ * (state/data to dump).
+ *
+ * These sets of interfaces can be mixed and matched to build a
+ * dumper suitable for a given situation, allowing for
+ * flexibility as well appropriate degree of code reuse.
+ * For example all features and options of lkcd (including
+ * granular selective dumping in the near future) should be
+ * available even when say, the 2 stage soft-boot based mechanism
+ * is used for taking disruptive dumps.
+ *
+ * Todo: Additionally modules or drivers may supply their own
+ * custom dumpers which extend dump with module specific
+ * information or hardware state, and can even tweak the
+ * mechanism when it comes to saving state relevant to
+ * them.
+ */
+
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/highmem.h>
+#include <linux/dumpdev.h>
+#include <asm/page.h>	/* get_order */
+
+#define MAX_PASSES 	6
+#define MAX_DEVS	4
+
+
+/* To customise selection of pages to be dumped in a given pass/group */
+struct dump_data_filter{
+	char name[32];
+	int (*selector)(int, unsigned long, unsigned long);
+	ulong level_mask; /* dump level(s) for which this filter applies */
+	loff_t start[MAX_NUMNODES], end[MAX_NUMNODES]; /* location range applicable */
+	ulong num_mbanks;  /* Number of memory banks. Greater than one for discontig memory (NUMA) */
+};
+
+
+/*
+ * Determined by the kind of dump mechanism and appropriate
+ * overall scheme
+ */
+struct dump_scheme_ops {
+	/* sets aside memory, inits data structures etc */
+	int (*configure)(const char *devid);
+	/* releases  resources */
+	int (*unconfigure)(void);
+
+	/* ordering of passes, invoking iterator */
+	int (*sequencer)(void);
+        /* iterates over system data, selects and acts on data to dump */
+	int (*iterator)(int, int (*)(unsigned long, unsigned long),
+		struct dump_data_filter *);
+        /* action when data is selected for dump */
+	int (*save_data)(unsigned long, unsigned long);
+        /* action when data is to be excluded from dump */
+	int (*skip_data)(unsigned long, unsigned long);
+	/* policies for space, multiple dump devices etc */
+	int (*write_buffer)(void *, unsigned long);
+};
+
+struct dump_scheme {
+	/* the name serves as an anchor to locate the scheme after reboot */
+	char name[32];
+	struct dump_scheme_ops *ops;
+	struct list_head list;
+};
+
+/* Quiescing/Silence levels (controls IPI callback behaviour) */
+extern enum dump_silence_levels {
+	DUMP_SOFT_SPIN_CPUS	= 1,
+	DUMP_HARD_SPIN_CPUS	= 2,
+	DUMP_HALT_CPUS		= 3,
+} dump_silence_level;
+
+/* determined by the dump (file) format */
+struct dump_fmt_ops {
+	/* build header */
+	int (*configure_header)(const char *, const struct pt_regs *);
+	int (*update_header)(void); /* update header and write it out */
+	/* save curr context  */
+	void (*save_context)(int, const struct pt_regs *,
+		struct task_struct *);
+	/* typically called by the save_data action */
+	/* add formatted data to the dump buffer */
+	int (*add_data)(unsigned long, unsigned long);
+	int (*update_end_marker)(void);
+};
+
+struct dump_fmt {
+	unsigned long magic;
+	char name[32];  /* lcrash, crash, elf-core etc */
+	struct dump_fmt_ops *ops;
+	struct list_head list;
+};
+
+/*
+ * Modules will be able add their own data capture schemes by
+ * registering their own dumpers. Typically they would use the
+ * primary dumper as a template and tune it with their routines.
+ * Still Todo.
+ */
+
+/* The combined dumper profile (mechanism, scheme, dev, fmt) */
+struct dumper {
+	char name[32]; /* singlestage, overlay (stg1), passthru(stg2), pull */
+	struct dump_scheme *scheme;
+	struct dump_fmt *fmt;
+	struct __dump_compress *compress;
+	struct dump_data_filter *filter;
+	struct dump_dev *dev;
+	/* state valid only for active dumper(s) - per instance */
+	/* run time state/context */
+	int curr_pass;
+	unsigned long count;
+	loff_t curr_offset; /* current logical offset into dump device */
+	loff_t curr_loc; /* current memory location */
+	void *curr_buf; /* current position in the dump buffer */
+	void *dump_buf; /* starting addr of dump buffer */
+	int header_dirty; /* whether the header needs to be written out */
+	int header_len;
+	struct list_head dumper_list; /* links to other dumpers */
+};
+
+/* Starting point to get to the current configured state */
+struct dump_config {
+	ulong level;
+	int polling;
+	int reboot;
+	int comp_flag;
+	int comp_val;
+	struct dumper *dumper;
+	char *dump_device;
+	unsigned long dump_addr; /* relevant only for in-memory dumps */
+	struct list_head dump_dev_list;
+};
+
+extern struct dump_config dump_config;
+
+/* Wrappers that invoke the methods for the current (active) dumper */
+
+/* Scheme operations */
+
+static inline int dump_sequencer(void)
+{
+	return dump_config.dumper->scheme->ops->sequencer();
+}
+
+static inline int dump_iterator(int pass, int (*action)(unsigned long,
+	unsigned long), struct dump_data_filter *filter)
+{
+	return dump_config.dumper->scheme->ops->iterator(pass, action, filter);
+}
+
+#define dump_save_data dump_config.dumper->scheme->ops->save_data
+#define dump_skip_data dump_config.dumper->scheme->ops->skip_data
+
+static inline int dump_write_buffer(void *buf, unsigned long len)
+{
+	return dump_config.dumper->scheme->ops->write_buffer(buf, len);
+}
+
+static inline int dump_configure(const char *devid)
+{
+	return dump_config.dumper->scheme->ops->configure(devid);
+}
+
+static inline int dump_unconfigure(void)
+{
+	return dump_config.dumper->scheme->ops->unconfigure();
+}
+
+/* Format operations */
+
+static inline int dump_configure_header(const char *panic_str,
+	const struct pt_regs *regs)
+{
+	return dump_config.dumper->fmt->ops->configure_header(panic_str, regs);
+}
+
+static inline void dump_save_context(int cpu, const struct pt_regs *regs,
+		struct task_struct *tsk)
+{
+	dump_config.dumper->fmt->ops->save_context(cpu, regs, tsk);
+}
+
+static inline int dump_save_this_cpu(const struct pt_regs *regs)
+{
+	int cpu = smp_processor_id();
+
+	dump_save_context(cpu, regs, current);
+	return 1;
+}
+
+static inline int dump_update_header(void)
+{
+	return dump_config.dumper->fmt->ops->update_header();
+}
+
+static inline int dump_update_end_marker(void)
+{
+	return dump_config.dumper->fmt->ops->update_end_marker();
+}
+
+static inline int dump_add_data(unsigned long loc, unsigned long sz)
+{
+	return dump_config.dumper->fmt->ops->add_data(loc, sz);
+}
+
+/* Compression operation */
+static inline int dump_compress_data(char *src, int slen, char *dst,
+		unsigned long loc)
+{
+	return dump_config.dumper->compress->compress_func(src, slen,
+		dst, DUMP_DPC_PAGE_SIZE, loc);
+}
+
+
+/* Prototypes of some default implementations of dump methods */
+
+extern struct __dump_compress dump_none_compression;
+
+/* Default scheme methods (dump_scheme.c) */
+
+extern int dump_generic_sequencer(void);
+extern int dump_page_iterator(int pass, int (*action)(unsigned long, unsigned
+	long), struct dump_data_filter *filter);
+extern int dump_generic_save_data(unsigned long loc, unsigned long sz);
+extern int dump_generic_skip_data(unsigned long loc, unsigned long sz);
+extern int dump_generic_write_buffer(void *buf, unsigned long len);
+extern int dump_generic_configure(const char *);
+extern int dump_generic_unconfigure(void);
+#ifdef CONFIG_DISCONTIGMEM
+extern void dump_reconfigure_mbanks(void);
+#endif
+
+/* Default scheme template */
+extern struct dump_scheme dump_scheme_singlestage;
+
+/* Default dump format methods */
+
+extern int dump_lcrash_configure_header(const char *panic_str,
+	const struct pt_regs *regs);
+extern void dump_lcrash_save_context(int  cpu, const struct pt_regs *regs,
+	struct task_struct *tsk);
+extern int dump_generic_update_header(void);
+extern int dump_lcrash_add_data(unsigned long loc, unsigned long sz);
+extern int dump_lcrash_update_end_marker(void);
+
+/* Default format (lcrash) template */
+extern struct dump_fmt dump_fmt_lcrash;
+
+/* Default dump selection filter table */
+
+/*
+ * Entries listed in order of importance and correspond to passes
+ * The last entry (with a level_mask of zero) typically reflects data that
+ * won't be dumped  -- this may for example be used to identify data
+ * that will be skipped for certain so the corresponding memory areas can be
+ * utilized as scratch space.
+ */
+extern struct dump_data_filter dump_filter_table[];
+
+/* Some pre-defined dumpers */
+extern struct dumper dumper_singlestage;
+extern struct dumper dumper_stage1;
+extern struct dumper dumper_stage2;
+
+/* These are temporary */
+#define DUMP_MASK_HEADER	DUMP_LEVEL_HEADER
+#define DUMP_MASK_KERN		DUMP_LEVEL_KERN
+#define DUMP_MASK_USED		DUMP_LEVEL_USED
+#define DUMP_MASK_UNUSED	DUMP_LEVEL_ALL_RAM
+#define DUMP_MASK_REST		0 /* dummy for now */
+
+/* Helpers - move these to dump.h later ? */
+
+int dump_generic_execute(const char *panic_str, const struct pt_regs *regs);
+extern int dump_ll_write(void *buf, unsigned long len);
+
+static inline void dumper_reset(void)
+{
+	dump_config.dumper->curr_buf = dump_config.dumper->dump_buf;
+	dump_config.dumper->curr_loc = 0;
+	dump_config.dumper->curr_offset = 0;
+	dump_config.dumper->count = 0;
+	dump_config.dumper->curr_pass = 0;
+}
+
+/*
+ * May later be moulded to perform boot-time allocations so we can dump
+ * earlier during bootup
+ */
+static inline void *dump_alloc_mem(unsigned long size)
+{
+	return (void *) __get_free_pages(GFP_KERNEL, get_order(size));
+}
+
+static inline void dump_free_mem(void *buf)
+{
+	struct page *page;
+
+	/* ignore reserved pages (e.g. post soft boot stage) */
+	if (buf && (page = virt_to_page(buf))) {
+		if (PageReserved(page))
+			return;
+	}
+	/*
+	 * Allocated using __get_free_pages().
+	 */
+	free_pages((unsigned long)buf,
+		get_order(DUMP_BUFFER_SIZE + 3 * DUMP_PAGE_SIZE));
+}
+
+
+#endif /*  _LINUX_DUMP_METHODS_H */
Index: linux-2.6.15/drivers/dump/dump_netdev.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_netdev.c	2006-02-12 17:02:35.000000000 +0100
@@ -0,0 +1,576 @@
+/*
+ * Implements the dump driver interface for saving a dump via network
+ * interface.
+ *
+ * Some of this code has been taken/adapted from Ingo Molnar's netconsole
+ * code. LKCD team expresses its thanks to Ingo.
+ *
+ * Started: June 2002 - Mohamed Abbas <mohamed.abbas@intel.com>
+ * 	Adapted netconsole code to implement LKCD dump over the network.
+ *
+ * Nov 2002 - Bharata B. Rao <bharata@in.ibm.com>
+ * 	Innumerable code cleanups, simplification and some fixes.
+ *	Netdump configuration done by ioctl instead of using module parameters.
+ * Oct 2003 - Prasanna S Panchamukhi <prasanna@in.ibm.com>
+ *	Netdump code modified to use Netpoll API's.
+ *
+ * Copyright (C) 2001  Ingo Molnar <mingo@redhat.com>
+ * Copyright (C) 2002 International Business Machines Corp.
+ *
+ *  This code is released under version 2 of the GNU GPL.
+ */
+
+#include <net/tcp.h>
+#include <net/udp.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/random.h>
+#include <linux/module.h>
+#include <linux/dump.h>
+#include <linux/dump_netdev.h>
+
+#include <asm/unaligned.h>
+
+static int startup_handshake;
+static int page_counter;
+static unsigned long flags_global;
+static int netdump_in_progress;
+
+/*
+ * security depends on the trusted path between the netconsole
+ * server and netconsole client, since none of the packets are
+ * encrypted. The random magic number protects the protocol
+ * against spoofing.
+ */
+static u64 dump_magic;
+
+/*
+ * We maintain a small pool of fully-sized skbs,
+ * to make sure the message gets out even in
+ * extreme OOM situations.
+ */
+
+static void rx_hook(struct netpoll *np, int port, char *msg, int size);
+int new_req = 0;
+static req_t req;
+
+static void rx_hook(struct netpoll *np, int port, char *msg, int size)
+{
+	req_t * __req = (req_t *) msg;
+	/*
+	 * First check if were are dumping or doing startup handshake, if
+	 * not quickly return.
+	 */
+
+	if (!netdump_in_progress)
+		return ;
+
+	if ((ntohl(__req->command) != COMM_GET_MAGIC) &&
+	    (ntohl(__req->command) != COMM_HELLO) &&
+	    (ntohl(__req->command) != COMM_START_WRITE_NETDUMP_ACK) &&
+	    (ntohl(__req->command) != COMM_START_NETDUMP_ACK) &&
+	    (memcmp(&__req->magic, &dump_magic, sizeof(dump_magic)) != 0))
+		goto out;
+
+	req.magic = ntohl(__req->magic);
+	req.command = ntohl(__req->command);
+	req.from = ntohl(__req->from);
+	req.to = ntohl(__req->to);
+	req.nr = ntohl(__req->nr);
+	new_req = 1;
+out:
+	return ;
+}
+static char netdump_membuf[1024 + HEADER_LEN + 1];
+/*
+ * Fill the netdump_membuf with the header information from reply_t structure
+ * and send it down to netpoll_send_udp() routine.
+ */
+static void
+netdump_send_packet(struct netpoll *np, reply_t *reply, size_t data_len) {
+	char *b;
+
+	b = &netdump_membuf[1];
+	netdump_membuf[0] = NETCONSOLE_VERSION;
+	put_unaligned(htonl(reply->nr), (u32 *) b);
+	put_unaligned(htonl(reply->code), (u32 *) (b + sizeof(reply->code)));
+	put_unaligned(htonl(reply->info), (u32 *) (b + sizeof(reply->code) +
+		sizeof(reply->info)));
+	netpoll_send_udp(np, netdump_membuf, data_len + HEADER_LEN);
+}
+
+static void
+dump_send_mem(struct netpoll *np, req_t *req, const char* buff, size_t len)
+{
+	int i;
+
+	int nr_chunks = len/1024;
+	reply_t reply;
+
+	reply.nr = req->nr;
+	reply.code = REPLY_MEM;
+        if ( nr_chunks <= 0)
+		 nr_chunks = 1;
+	for (i = 0; i < nr_chunks; i++) {
+		uint64_t offset = ((uint64_t) i) * 1024;
+
+		/* We put the high 24 bits of the offset into the top
+		   of reply.code. */
+
+		reply.info = offset;
+		reply.code |= (offset >> 24) & 0xffffff00;
+		memcpy((netdump_membuf + HEADER_LEN), (buff + offset), 1024);
+		netdump_send_packet(np, &reply, 1024);
+	}
+}
+
+/*
+ * This function waits for the client to acknowledge the receipt
+ * of the netdump startup reply, with the possibility of packets
+ * getting lost. We resend the startup packet if no ACK is received,
+ * after a 1 second delay.
+ *
+ * (The client can test the success of the handshake via the HELLO
+ * command, and send ACKs until we enter netdump mode.)
+ */
+static int
+dump_handshake(struct dump_dev *net_dev)
+{
+	reply_t reply;
+	int i, j;
+	size_t str_len;
+
+	if (startup_handshake) {
+		sprintf((netdump_membuf + HEADER_LEN),
+			"NETDUMP start, waiting for start-ACK.\n");
+		reply.code = REPLY_START_NETDUMP;
+		reply.nr = 0;
+		reply.info = 0;
+	} else {
+		sprintf((netdump_membuf + HEADER_LEN),
+			"NETDUMP start, waiting for start-ACK.\n");
+		reply.code = REPLY_START_WRITE_NETDUMP;
+		reply.nr = net_dev->curr_offset;
+		reply.info = net_dev->curr_offset;
+	}
+	str_len = strlen(netdump_membuf + HEADER_LEN);
+
+	/* send 300 handshake packets before declaring failure */
+	for (i = 0; i < 300; i++) {
+		netdump_send_packet(&net_dev->np, &reply, str_len);
+
+		/* wait 1 sec */
+		for (j = 0; j < 10000; j++) {
+			udelay(100);
+			netpoll_poll(&net_dev->np);
+			if (new_req)
+				break;
+		}
+
+		/*
+		 * if there is no new request, try sending the handshaking
+		 * packet again
+		 */
+		if (!new_req)
+			continue;
+
+		/*
+		 * check if the new request is of the expected type,
+		 * if so, return, else try sending the handshaking
+		 * packet again
+		 */
+		if (startup_handshake) {
+			if (req.command == COMM_HELLO || req.command ==
+				COMM_START_NETDUMP_ACK) {
+				return 0;
+			} else {
+				new_req = 0;
+				continue;
+			}
+		} else {
+			if (req.command == COMM_SEND_MEM) {
+				return 0;
+			} else {
+				new_req = 0;
+				continue;
+			}
+		}
+	}
+	return -1;
+}
+
+static ssize_t
+do_netdump(struct dump_dev *net_dev, const char* buff, size_t len)
+{
+	reply_t reply;
+	ssize_t  ret = 0;
+	int repeatCounter, counter, total_loop;
+	size_t str_len;
+
+	netdump_in_progress = 1;
+
+	if (dump_handshake(net_dev) < 0) {
+		printk("LKCD: network dump failed due to handshake failure\n");
+		goto out;
+	}
+
+	/*
+	 * Ideally startup handshake should be done during dump configuration,
+	 * i.e., in dump_net_open(). This will be done when I figure out
+	 * the dependency between startup handshake, subsequent write and
+	 * various commands wrt to net-server.
+	 */
+	if (startup_handshake)
+		startup_handshake = 0;
+
+        counter = 0;
+	repeatCounter = 0;
+	total_loop = 0;
+	while (1) {
+                if (!new_req) {
+			netpoll_poll(&net_dev->np);
+		}
+		if (!new_req) {
+			repeatCounter++;
+
+			if (repeatCounter > 5) {
+				counter++;
+				if (counter > 10000) {
+					if (total_loop >= 100000) {
+						printk("LKCD: Time OUT LEAVE NOW\n");
+						goto out;
+					} else {
+						total_loop++;
+						printk("LKCD: Try number %d out of "
+							"10 before Time Out\n",
+							total_loop);
+					}
+				}
+				mdelay(1);
+				repeatCounter = 0;
+			}
+			continue;
+		}
+		repeatCounter = 0;
+		counter = 0;
+		total_loop = 0;
+		new_req = 0;
+		switch (req.command) {
+		case COMM_NONE:
+			break;
+
+		case COMM_SEND_MEM:
+			dump_send_mem(&net_dev->np, &req, buff, len);
+			break;
+
+		case COMM_EXIT:
+                case COMM_START_WRITE_NETDUMP_ACK:
+			ret = len;
+			goto out;
+
+		case COMM_HELLO:
+			sprintf((netdump_membuf + HEADER_LEN),
+				"Hello, this is netdump version " "0.%02d\n",
+				 NETCONSOLE_VERSION);
+			str_len = strlen(netdump_membuf + HEADER_LEN);
+			reply.code = REPLY_HELLO;
+			reply.nr = req.nr;
+                        reply.info = net_dev->curr_offset;
+			netdump_send_packet(&net_dev->np, &reply, str_len);
+			break;
+
+		case COMM_GET_PAGE_SIZE:
+			sprintf((netdump_membuf + HEADER_LEN),
+				"PAGE_SIZE: %ld\n", PAGE_SIZE);
+			str_len = strlen(netdump_membuf + HEADER_LEN);
+			reply.code = REPLY_PAGE_SIZE;
+			reply.nr = req.nr;
+			reply.info = PAGE_SIZE;
+			netdump_send_packet(&net_dev->np, &reply, str_len);
+			break;
+
+		case COMM_GET_NR_PAGES:
+			reply.code = REPLY_NR_PAGES;
+			reply.nr = req.nr;
+			reply.info = num_physpages;
+			reply.info = page_counter;
+			sprintf((netdump_membuf + HEADER_LEN),
+				"Number of pages: %ld\n", num_physpages);
+			str_len = strlen(netdump_membuf + HEADER_LEN);
+			netdump_send_packet(&net_dev->np, &reply, str_len);
+			break;
+
+		case COMM_GET_MAGIC:
+			reply.code = REPLY_MAGIC;
+			reply.nr = req.nr;
+			reply.info = NETCONSOLE_VERSION;
+			sprintf((netdump_membuf + HEADER_LEN),
+				(char *)&dump_magic, sizeof(dump_magic));
+			str_len = strlen(netdump_membuf + HEADER_LEN);
+			netdump_send_packet(&net_dev->np, &reply, str_len);
+			break;
+
+		default:
+			reply.code = REPLY_ERROR;
+			reply.nr = req.nr;
+			reply.info = req.command;
+			sprintf((netdump_membuf + HEADER_LEN),
+				"Got unknown command code %d!\n", req.command);
+			str_len = strlen(netdump_membuf + HEADER_LEN);
+			netdump_send_packet(&net_dev->np, &reply, str_len);
+			break;
+		}
+	}
+out:
+	netdump_in_progress = 0;
+	return ret;
+}
+
+static int
+dump_validate_config(struct netpoll *np)
+{
+	if (!np->local_ip) {
+		printk("LKCD: network device %s has no local address, "
+				"aborting.\n", np->name);
+		return -1;
+	}
+
+#define IP(x) ((unsigned char *)&np->local_ip)[x]
+	printk("LKCD: Source %d.%d.%d.%d ", IP(0), IP(1), IP(2), IP(3));
+#undef IP
+
+	if (!np->local_port) {
+		printk("LKCD: source_port parameter not specified, aborting.\n");
+		return -1;
+	}
+
+	if (!np->remote_ip) {
+		printk("LKCD: target_ip parameter not specified, aborting.\n");
+		return -1;
+	}
+
+	np->remote_ip = ntohl(np->remote_ip);
+#define IP(x) ((unsigned char *)&np->remote_ip)[x]
+	printk("LKCD: Target %d.%d.%d.%d ", IP(0), IP(1), IP(2), IP(3));
+#undef IP
+
+	if (!np->remote_port) {
+		printk("LKCD: target_port parameter not specified, aborting.\n");
+		return -1;
+	}
+	printk("LKCD: Target Ethernet Address %02x:%02x:%02x:%02x:%02x:%02x",
+		np->remote_mac[0], np->remote_mac[1], np->remote_mac[2],
+		np->remote_mac[3], np->remote_mac[4], np->remote_mac[5]);
+
+	if ((np->remote_mac[0] & np->remote_mac[1] & np->remote_mac[2] &
+		np->remote_mac[3] & np->remote_mac[4] & np->remote_mac[5]) == 255)
+		printk("LKCD: (Broadcast)");
+	printk("\n");
+	return 0;
+}
+
+/*
+ * Prepares the dump device so we can take a dump later.
+ * Validates the netdump configuration parameters.
+ *
+ * TODO: Network connectivity check should be done here.
+ */
+static int
+dump_net_open(struct dump_dev *net_dev, const char *arg)
+{
+	int retval = 0;
+	char *p, *larg;
+	char *larg_orig;
+	u64 tmp;
+
+	if (!(larg = kmalloc(strlen(arg), GFP_KERNEL)))
+		return -ENOMEM;
+
+	strcpy(larg, arg);
+	larg_orig = larg;
+
+	if ((p = strchr(larg, ',')) != NULL)
+		*p = '\0';
+	strcpy(net_dev->np.dev_name, larg);
+	larg = p + 1;
+
+	if ((p = strchr(larg, ',')) != NULL)
+		*p = '\0';
+	net_dev->np.remote_ip = simple_strtol(larg, &p, 16);
+
+	larg = p + 1;
+	if ((p = strchr(larg, ',')) != NULL)
+		*p = '\0';
+	net_dev->np.remote_port = simple_strtol(larg, &p, 16);
+
+	larg = p + 1;
+	if ((p = strchr(larg, ',')) != NULL)
+		*p = '\0';
+	net_dev->np.local_port = simple_strtol(larg, &p, 16);
+	larg = p + 1;
+
+	tmp = simple_strtoull(larg, NULL, 16);
+	net_dev->np.remote_mac[0] = (char) ((tmp & 0x0000ff0000000000LL) >> 40);
+	net_dev->np.remote_mac[1] = (char) ((tmp & 0x000000ff00000000LL) >> 32);
+	net_dev->np.remote_mac[2] = (char) ((tmp & 0x00000000ff000000LL) >> 24);
+	net_dev->np.remote_mac[3] = (char) ((tmp & 0x0000000000ff0000LL) >> 16);
+	net_dev->np.remote_mac[4] = (char) ((tmp & 0x000000000000ff00LL) >> 8);
+	net_dev->np.remote_mac[5] = (char) ((tmp & 0x00000000000000ffLL));
+
+	net_dev->np.rx_hook = rx_hook;
+	retval = netpoll_setup(&net_dev->np);
+
+	dump_validate_config(&net_dev->np);
+	net_dev->curr_offset = 0;
+	printk("LKCD: Network device %s successfully configured for dumping\n",
+			net_dev->np.dev_name);
+
+	kfree(larg_orig);
+	return retval;
+}
+
+/*
+ * Close the dump device and release associated resources
+ * Invoked when unconfiguring the dump device.
+ */
+static int
+dump_net_release(struct dump_dev *net_dev)
+{
+	netpoll_cleanup(&net_dev->np);
+	return 0;
+}
+
+/*
+ * Prepare the dump device for use (silence any ongoing activity
+ * and quiesce state) when the system crashes.
+ */
+static int
+dump_net_silence(struct dump_dev *net_dev)
+{
+	netpoll_set_trap(1);
+	local_irq_save(flags_global);
+        startup_handshake = 1;
+	net_dev->curr_offset = 0;
+	printk("LKCD: Dumping to network device %s on CPU %d ...\n", net_dev->np.name,
+			smp_processor_id());
+	return 0;
+}
+
+/*
+ * Invoked when dumping is done. This is the time to put things back
+ * (i.e. undo the effects of dump_block_silence) so the device is
+ * available for normal use.
+ */
+static int
+dump_net_resume(struct dump_dev *net_dev)
+{
+	int indx;
+	size_t str_len;
+	reply_t reply;
+
+	sprintf((netdump_membuf + HEADER_LEN), "NETDUMP end.\n");
+	str_len = strlen(netdump_membuf + HEADER_LEN);
+	for( indx = 0; indx < 6; indx++) {
+		reply.code = REPLY_END_NETDUMP;
+		reply.nr = 0;
+		reply.info = 0;
+		netdump_send_packet(&net_dev->np, &reply, str_len);
+	}
+	printk("LKCD: NETDUMP END!\n");
+	local_irq_restore(flags_global);
+	netpoll_set_trap(0);
+	startup_handshake = 0;
+	return 0;
+}
+
+/*
+ * Seek to the specified offset in the dump device.
+ * Makes sure this is a valid offset, otherwise returns an error.
+ */
+static  int
+dump_net_seek(struct dump_dev *net_dev, loff_t off)
+{
+	net_dev->curr_offset = off;
+	return 0;
+}
+
+/*
+ *
+ */
+static int
+dump_net_write(struct dump_dev *net_dev, void *buf, unsigned long len)
+{
+	int cnt, i, off;
+	ssize_t ret;
+
+	cnt = len/ PAGE_SIZE;
+
+	for (i = 0; i < cnt; i++) {
+		off = i* PAGE_SIZE;
+		ret = do_netdump(net_dev, buf+off, PAGE_SIZE);
+		if (ret <= 0)
+			return -1;
+		net_dev->curr_offset = net_dev->curr_offset + PAGE_SIZE;
+	}
+	return len;
+}
+
+/*
+ * check if the last dump i/o is over and ready for next request
+ */
+static int
+dump_net_ready(struct dump_dev *net_dev, void *buf)
+{
+	return 0;
+}
+
+struct dump_dev_ops dump_netdev_ops = {
+	.open 		= dump_net_open,
+	.release	= dump_net_release,
+	.silence	= dump_net_silence,
+	.resume 	= dump_net_resume,
+	.seek		= dump_net_seek,
+	.write		= dump_net_write,
+	/* .read not implemented */
+	.ready		= dump_net_ready,
+};
+
+static struct dump_dev default_dump_netdev = {
+	.type = 2,
+	.ops = &dump_netdev_ops,
+	.curr_offset = 0,
+	.np.name = "netdump",
+	.np.dev_name = "eth0",
+	.np.rx_hook = rx_hook,
+	.np.local_port = 6688,
+	.np.remote_port = 6688,
+	.np.remote_mac = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
+};
+
+static int __init
+dump_netdev_init(void)
+{
+	default_dump_netdev.curr_offset = 0;
+
+	if (dump_register_device(&default_dump_netdev) < 0) {
+		printk("LKCD: network dump device driver registration failed\n");
+		return -1;
+	}
+	printk("LKCD: network device driver for LKCD registered\n");
+
+	get_random_bytes(&dump_magic, sizeof(dump_magic));
+	return 0;
+}
+
+static void __exit
+dump_netdev_cleanup(void)
+{
+	dump_unregister_device(&default_dump_netdev);
+}
+
+MODULE_AUTHOR("LKCD Development Team <lkcd-devel@lists.sourceforge.net>");
+MODULE_DESCRIPTION("Network Dump Driver for Linux Kernel Crash Dump (LKCD)");
+MODULE_LICENSE("GPL");
+
+module_init(dump_netdev_init);
+module_exit(dump_netdev_cleanup);
Index: linux-2.6.15/drivers/dump/dump_ppc64.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_ppc64.c	2006-02-12 16:58:13.929952175 +0100
@@ -0,0 +1,420 @@
+/*
+ * Architecture specific (ppc64) functions for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ *
+ * Copyright 1999 Silicon Graphics, Inc. All rights reserved.
+ *
+ * 2.3 kernel modifications by: Matt D. Robinson (yakker@turbolinux.com)
+ * Copyright 2000 TurboLinux, Inc.  All rights reserved.
+ * Copyright 2003, 2004 IBM Corporation
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/*
+ * The hooks for dumping the kernel virtual memory to disk are in this
+ * file.  Any time a modification is made to the virtual memory mechanism,
+ * these routines must be changed to use the new mechanisms.
+ */
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/dump.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/syscalls.h>
+#include <asm/hardirq.h>
+#include "dump_methods.h"
+#include <linux/irq.h>
+#include <asm/machdep.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+#if defined(CONFIG_KDB) && !defined(CONFIG_DUMP_MODULE)
+#include <linux/kdb.h>
+#endif
+
+extern cpumask_t irq_affinity[];
+
+static cpumask_t saved_affinity[NR_IRQS];
+
+static __s32         saved_irq_count;   /* saved preempt_count() flags */
+
+static int alloc_dha_stack(void)
+{
+        int i;
+        void *ptr;
+
+        if (dump_header_asm.dha_stack[0])
+                return 0;
+
+        ptr = (void *)vmalloc(THREAD_SIZE * num_possible_cpus());
+        if (!ptr) {
+                return -ENOMEM;
+        }
+
+        for (i = 0; i < num_possible_cpus(); i++) {
+                dump_header_asm.dha_stack[i] =
+			(uint64_t)((unsigned long)ptr + (i * THREAD_SIZE));
+	}
+	return 0;
+}
+
+static int free_dha_stack(void)
+{
+        if (dump_header_asm.dha_stack[0]) {
+                vfree((void*)dump_header_asm.dha_stack[0]);
+		dump_header_asm.dha_stack[0] = 0;
+	}
+        return 0;
+}
+#ifdef CONFIG_SMP
+static int dump_expect_ipi[NR_CPUS];
+static atomic_t waiting_for_dump_ipi;
+
+extern void stop_this_cpu(void *);
+static int
+dump_ipi_handler(struct pt_regs *regs)
+{
+	int cpu = smp_processor_id();
+
+	if (!dump_expect_ipi[cpu])
+		return 0;
+	dump_save_this_cpu(regs);
+	atomic_dec(&waiting_for_dump_ipi);
+
+ level_changed:
+	switch (dump_silence_level) {
+	case DUMP_HARD_SPIN_CPUS:       /* Spin until dump is complete */
+		while (dump_oncpu) {
+			barrier();      /* paranoia */
+			if (dump_silence_level != DUMP_HARD_SPIN_CPUS)
+				goto level_changed;
+			cpu_relax();    /* kill time nicely */
+		}
+		break;
+
+	case DUMP_HALT_CPUS:            /* Execute halt */
+		stop_this_cpu(NULL);
+		break;
+
+	case DUMP_SOFT_SPIN_CPUS:
+		/* Mark the task so it spins in schedule */
+		set_tsk_thread_flag(current, TIF_NEED_RESCHED);
+		break;
+	}
+
+	return 1;
+}
+
+/* save registers on other processors
+ * If the other cpus don't respond we simply do not get their states.
+ */
+void
+__dump_save_other_cpus(void)
+{
+	int i, cpu = smp_processor_id();
+	int other_cpus = num_online_cpus()-1;
+
+	if (other_cpus > 0) {
+		atomic_set(&waiting_for_dump_ipi, other_cpus);
+		for (i = 0; i < NR_CPUS; i++)
+			dump_expect_ipi[i] = (i != cpu && cpu_online(i));
+
+		printk("LKCD: sending IPI to other cpus...\n");
+		dump_send_ipi(dump_ipi_handler);
+		/*
+		 * may be we dont need to wait for IPI to be processed.
+		 * just write out the header at the end of dumping, if
+		 * this IPI is not processed until then, there probably
+		 * is a problem and we just fail to capture state of
+		 * other cpus.
+		 * However, we will wait 10 secs for other CPUs to respond.
+		 * If not, proceed the dump process even though we failed
+		 * to capture other CPU states.
+		 */
+		i = 10000; /* wait max of 10 seconds */
+		while ((atomic_read(&waiting_for_dump_ipi) > 0) && (--i > 0)) {
+			barrier();
+			mdelay(1);
+		}
+		printk("LKCD: done waiting: %d cpus not responding\n",
+		       atomic_read(&waiting_for_dump_ipi));
+		dump_send_ipi(NULL);	/* clear handler */
+	}
+}
+
+/*
+ * Restore old irq affinities.
+ */
+static void
+__dump_reset_irq_affinity(void)
+{
+	int i;
+	irq_desc_t *irq_d;
+
+	memcpy(irq_affinity, saved_affinity, NR_IRQS * sizeof(unsigned long));
+
+	for_each_irq(i) {
+		irq_d = get_irq_desc(i);
+		if (irq_d->handler == NULL) {
+			continue;
+		}
+		if (irq_d->handler->set_affinity != NULL) {
+			irq_d->handler->set_affinity(i, saved_affinity[i]);
+		}
+	}
+}
+
+/*
+ * Routine to save the old irq affinities and change affinities of all irqs to
+ * the dumping cpu.
+ *
+ * NB: Need to be expanded to multiple nodes.
+ */
+static void
+__dump_set_irq_affinity(void)
+{
+	int i;
+	cpumask_t cpu = CPU_MASK_NONE;
+	irq_desc_t *irq_d;
+
+	cpu_set(smp_processor_id(), cpu);
+
+	memcpy(saved_affinity, irq_affinity, NR_IRQS * sizeof(unsigned long));
+
+	for_each_irq(i) {
+		irq_d = get_irq_desc(i);
+		if (irq_d->handler == NULL) {
+			continue;
+		}
+		irq_affinity[i] = cpu;
+		if (irq_d->handler->set_affinity != NULL) {
+			irq_d->handler->set_affinity(i, irq_affinity[i]);
+		}
+	}
+}
+#else /* !CONFIG_SMP */
+#define __dump_save_other_cpus() do { } while (0)
+#define __dump_set_irq_affinity()      do { } while (0)
+#define __dump_reset_irq_affinity()    do { } while (0)
+#endif /* !CONFIG_SMP */
+
+void
+__dump_save_regs(struct pt_regs *dest_regs, const struct pt_regs *regs)
+{
+	if (regs) {
+		memcpy(dest_regs, regs, sizeof(struct pt_regs));
+	}
+}
+
+void
+__dump_save_context(int cpu, const struct pt_regs *regs,
+	struct task_struct *tsk)
+{
+	dump_header_asm.dha_smp_current_task[cpu] = (unsigned long)tsk;
+	__dump_save_regs(&dump_header_asm.dha_smp_regs[cpu], regs);
+
+	/* take a snapshot of the stack */
+	/* doing this enables us to tolerate slight drifts on this cpu */
+
+	if (dump_header_asm.dha_stack[cpu]) {
+		memcpy((void *)dump_header_asm.dha_stack[cpu],
+				STACK_START_POSITION(tsk),
+				THREAD_SIZE);
+	}
+	dump_header_asm.dha_stack_ptr[cpu] = (unsigned long)(tsk->thread_info);
+}
+
+/*
+ * Name: __dump_kernel_addr()
+ * Func: Return physical kernel load address.
+ */
+unsigned long
+__dump_kernel_addr(void)
+{
+	return 0 /* FIXME */ ;
+}
+
+/*
+ * Name: __dump_configure_header()
+ * Func: Configure the dump header with all proper values.
+ */
+int
+__dump_configure_header(const struct pt_regs *regs)
+{
+	return (0);
+}
+
+#if defined(CONFIG_KDB) && !defined(CONFIG_DUMP_MODULE)
+int
+kdb_sysdump(int argc, const char **argv, const char **envp, struct pt_regs *regs)
+{
+	kdb_printf("Dumping to disk...\n");
+	dump("dump from kdb", regs);
+	kdb_printf("Dump Complete\n");
+	return 0;
+}
+#endif
+
+/*
+ * Name: __dump_init()
+ * Func: Initialize the dumping routine process.  This is in case
+ *       it's necessary in the future.
+ */
+void
+__dump_init(uint64_t local_memory_start)
+{
+#if defined(FIXME) && defined(CONFIG_KDB) && !defined(CONFIG_DUMP_MODULE)
+	/* This won't currently work because interrupts are off in kdb
+	 * and the dump process doesn't understand how to recover.
+	 */
+	/* ToDo: add a command to query/set dump configuration */
+	kdb_register_repeat("sysdump", kdb_sysdump, "", "use lkcd to dump the system to disk (if configured)", 0, KDB_REPEAT_NONE);
+#endif
+
+	/* return */
+	return;
+}
+
+/*
+ * Name: __dump_open()
+ * Func: Open the dump device (architecture specific).  This is in
+ *       case it's necessary in the future.
+ */
+void
+__dump_open(void)
+{
+	alloc_dha_stack();
+}
+
+
+/*
+ * Name: __dump_cleanup()
+ * Func: Free any architecture specific data structures. This is called
+ *       when the dump module is being removed.
+ */
+void
+__dump_cleanup(void)
+{
+	free_dha_stack();
+}
+
+/*
+ * Kludge - dump from interrupt context is unreliable (Fixme)
+ *
+ * We do this so that softirqs initiated for dump i/o
+ * get processed and we don't hang while waiting for i/o
+ * to complete or in any irq synchronization attempt.
+ *
+ * This is not quite legal of course, as it has the side
+ * effect of making all interrupts & softirqs triggered
+ * while dump is in progress complete before currently
+ * pending softirqs and the currently executing interrupt
+ * code.
+ */
+static inline void
+irq_bh_save(void)
+{
+	saved_irq_count = irq_count();
+	preempt_count() &= ~(HARDIRQ_MASK|SOFTIRQ_MASK);
+}
+
+static inline void
+irq_bh_restore(void)
+{
+	preempt_count() |= saved_irq_count;
+}
+
+/*
+ * Name: __dump_irq_enable
+ * Func: Reset system so interrupts are enabled.
+ * This is used for dump methods that require interrupts
+ * Eventually, all methods will have interrupts disabled
+ * and this code can be removed.
+ *
+ * Change irq affinities
+ * Re-enable interrupts
+ */
+int
+__dump_irq_enable(void)
+{
+	__dump_set_irq_affinity();
+	irq_bh_save();
+	local_irq_enable();
+	return 0;
+}
+
+/*
+ * Name: __dump_irq_restore
+ * Func: Resume the system state in an architecture-specific way.
+ */
+void
+__dump_irq_restore(void)
+{
+	local_irq_disable();
+	__dump_reset_irq_affinity();
+	irq_bh_restore();
+}
+
+#if 0
+/* Cheap progress hack.  It estimates pages to write and
+ * assumes all pages will go -- so it may get way off.
+ * As the progress is not displayed for other architectures, not used at this
+ * moment.
+ */
+void
+__dump_progress_add_page(void)
+{
+	unsigned long total_pages = nr_free_pages() + nr_inactive_pages + nr_active_pages;
+	unsigned int percent = (dump_header.dh_num_dump_pages * 100) / total_pages;
+	char buf[30];
+
+	if (percent > last_percent && percent <= 100) {
+		sprintf(buf, "Dump %3d%%     ", percent);
+		ppc64_dump_msg(0x2, buf);
+		last_percent = percent;
+	}
+
+}
+#endif
+
+extern int dump_page_is_ram(unsigned long);
+/*
+ * Name: __dump_page_valid()
+ * Func: Check if page is valid to dump.
+ */
+int
+__dump_page_valid(unsigned long index)
+{
+	if (!pfn_valid(index))
+		return 0;
+
+	return dump_page_is_ram(index);
+}
+
+/*
+ * Name: manual_handle_crashdump()
+ * Func: Interface for the lkcd dump command. Calls dump_execute()
+ */
+int
+manual_handle_crashdump(void)
+{
+	struct pt_regs regs;
+
+	get_current_regs(&regs);
+	dump_execute("manual", &regs);
+	return 0;
+}
+
+/*
+ * Name: __dump_clean_irq_state()
+ * Func: Clean up from the previous IRQ handling state. Such as oops from
+ *       interrupt handler or bottom half.
+ */
+void
+__dump_clean_irq_state(void)
+{
+    return;
+}
Index: linux-2.6.15/drivers/dump/dump_rle.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_rle.c	2006-02-12 16:58:13.929952175 +0100
@@ -0,0 +1,176 @@
+/*
+ * RLE Compression functions for kernel crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sourceforge.net)
+ * Copyright 2001 Matt D. Robinson.  All rights reserved.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/* header files */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/init.h>
+#include <linux/dump.h>
+
+/*
+ * Name: dump_compress_rle()
+ * Func: Compress a DUMP_PAGE_SIZE (hardware) page down to something more
+ *       reasonable, if possible.  This is the same routine we use in IRIX.
+ */
+static u32
+dump_compress_rle(const u8 *old, u32 oldsize, u8 *new, u32 newsize,
+		unsigned long loc)
+{
+	u16 ri, wi, count = 0;
+	u_char value = 0, cur_byte;
+
+	/*
+	 * If the block should happen to "compress" to larger than the
+	 * buffer size, allocate a larger one and change cur_buf_size.
+	 */
+
+	wi = ri = 0;
+
+	while (ri < oldsize) {
+		if (!ri) {
+			cur_byte = value = old[ri];
+			count = 0;
+		} else {
+			if (count == 255) {
+				if (wi + 3 > oldsize) {
+					return oldsize;
+				}
+				new[wi++] = 0;
+				new[wi++] = count;
+				new[wi++] = value;
+				value = cur_byte = old[ri];
+				count = 0;
+			} else {
+				if ((cur_byte = old[ri]) == value) {
+					count++;
+				} else {
+					if (count > 1) {
+						if (wi + 3 > oldsize) {
+							return oldsize;
+						}
+						new[wi++] = 0;
+						new[wi++] = count;
+						new[wi++] = value;
+					} else if (count == 1) {
+						if (value == 0) {
+							if (wi + 3 > oldsize) {
+								return oldsize;
+							}
+							new[wi++] = 0;
+							new[wi++] = 1;
+							new[wi++] = 0;
+						} else {
+							if (wi + 2 > oldsize) {
+								return oldsize;
+							}
+							new[wi++] = value;
+							new[wi++] = value;
+						}
+					} else { /* count == 0 */
+						if (value == 0) {
+							if (wi + 2 > oldsize) {
+								return oldsize;
+							}
+							new[wi++] = value;
+							new[wi++] = value;
+						} else {
+							if (wi + 1 > oldsize) {
+								return oldsize;
+							}
+							new[wi++] = value;
+						}
+					} /* if count > 1 */
+
+					value = cur_byte;
+					count = 0;
+
+				} /* if byte == value */
+
+			} /* if count == 255 */
+
+		} /* if ri == 0 */
+		ri++;
+
+	}
+	if (count > 1) {
+		if (wi + 3 > oldsize) {
+			return oldsize;
+		}
+		new[wi++] = 0;
+		new[wi++] = count;
+		new[wi++] = value;
+	} else if (count == 1) {
+		if (value == 0) {
+			if (wi + 3 > oldsize)
+				return oldsize;
+			new[wi++] = 0;
+			new[wi++] = 1;
+			new[wi++] = 0;
+		} else {
+			if (wi + 2 > oldsize)
+				return oldsize;
+			new[wi++] = value;
+			new[wi++] = value;
+		}
+	} else { /* count == 0 */
+		if (value == 0) {
+			if (wi + 2 > oldsize)
+				return oldsize;
+			new[wi++] = value;
+			new[wi++] = value;
+		} else {
+			if (wi + 1 > oldsize)
+				return oldsize;
+			new[wi++] = value;
+		}
+	} /* if count > 1 */
+
+	value = cur_byte;
+	count = 0;
+	return wi;
+}
+
+/* setup the rle compression functionality */
+static struct __dump_compress dump_rle_compression = {
+	.compress_type = DUMP_COMPRESS_RLE,
+	.compress_func = dump_compress_rle,
+	.compress_name = "RLE",
+};
+
+/*
+ * Name: dump_compress_rle_init()
+ * Func: Initialize rle compression for dumping.
+ */
+static int __init
+dump_compress_rle_init(void)
+{
+	dump_register_compression(&dump_rle_compression);
+	return 0;
+}
+
+/*
+ * Name: dump_compress_rle_cleanup()
+ * Func: Remove rle compression for dumping.
+ */
+static void __exit
+dump_compress_rle_cleanup(void)
+{
+	dump_unregister_compression(DUMP_COMPRESS_RLE);
+}
+
+/* module initialization */
+module_init(dump_compress_rle_init);
+module_exit(dump_compress_rle_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("LKCD Development Team <lkcd-devel@lists.sourceforge.net>");
+MODULE_DESCRIPTION("RLE compression module for crash dump driver");
Index: linux-2.6.15/drivers/dump/dump_scheme.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_scheme.c	2006-02-12 16:58:13.933952164 +0100
@@ -0,0 +1,428 @@
+/*
+ * Default single stage dump scheme methods
+ *
+ * Previously a part of dump_base.c
+ *
+ * Started: Oct 2002 -  Suparna Bhattacharya <suparna@in.ibm.com>
+ * 	Split and rewrote LKCD dump scheme to generic dump method
+ * 	interfaces
+ * Derived from original code created by
+ * 	Matt Robinson <yakker@sourceforge.net>)
+ *
+ * Contributions from SGI, IBM, HP, MCL, and others.
+ *
+ * Copyright (C) 1999 - 2002 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 2001 - 2002 Matt D. Robinson.  All rights reserved.
+ * Copyright (C) 2002 International Business Machines Corp.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/*
+ * Implements the default dump scheme, i.e. single-stage gathering and
+ * saving of dump data directly to the target device, which operates in
+ * a push mode, where the dumping system decides what data it saves
+ * taking into account pre-specified dump config options.
+ *
+ * Aside: The 2-stage dump scheme, where there is a soft-reset between
+ * the gathering and saving phases, also reuses some of these
+ * default routines (see dump_overlay.c)
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+#include <linux/nmi.h>
+#include <linux/dump.h>
+#include "dump_methods.h"
+
+extern int panic_timeout;  /* time before reboot */
+
+extern void dump_speedo(int);
+
+/* Default sequencer used during single stage dumping */
+/* Also invoked during stage 2 of soft-boot based dumping */
+int dump_generic_sequencer(void)
+{
+	struct dump_data_filter *filter = dump_config.dumper->filter;
+	int pass = 0, err = 0, save = 0;
+	int (*action)(unsigned long, unsigned long);
+
+	/*
+	 * We want to save the more critical data areas first in
+	 * case we run out of space, encounter i/o failures, or get
+	 * interrupted otherwise and have to give up midway
+	 * So, run through the passes in increasing order
+	 */
+	for (;filter->selector; filter++, pass++)
+	{
+		/* Assumes passes are exclusive (even across dumpers) */
+		/* Requires care when coding the selection functions */
+		if ((save = filter->level_mask & dump_config.level))
+			action = dump_save_data;
+		else
+			action = dump_skip_data;
+
+		if ((err = dump_iterator(pass, action, filter)) < 0)
+			break;
+
+		printk("LKCD: \n %d dump pages %s of %d each in pass %d\n",
+		err, save ? "saved" : "skipped", (int)DUMP_PAGE_SIZE, pass);
+
+	}
+
+	return (err < 0) ? err : 0;
+}
+
+static inline struct page *dump_get_page(loff_t loc)
+{
+
+	unsigned long page_index = loc >> PAGE_SHIFT;
+
+	/* todo: complete this  to account for ia64/discontig mem */
+	/* todo: and to check for validity, ram page, no i/o mem etc */
+	/* need to use pfn/physaddr equiv of kern_addr_valid */
+
+	/* Important:
+	 *   On ARM/XScale system, the physical address starts from
+	 *   PHYS_OFFSET, and it maybe the situation that PHYS_OFFSET != 0.
+	 *   For example on Intel's PXA250, PHYS_OFFSET = 0xa0000000. And the
+	 *   page index starts from PHYS_PFN_OFFSET. When configuring
+ 	 *   filter, filter->start is assigned to 0 in dump_generic_configure.
+	 *   Here we want to adjust it by adding PHYS_PFN_OFFSET to it!
+	 */
+
+	if (__dump_page_valid(page_index))
+		return pfn_to_page(page_index);
+	else
+		return NULL;
+
+}
+
+/* Default iterator: for singlestage and stage 1 of soft-boot dumping */
+/* Iterates over range of physical memory pages in DUMP_PAGE_SIZE increments */
+int dump_page_iterator(int pass, int (*action)(unsigned long, unsigned long),
+	struct dump_data_filter *filter)
+{
+	/* Todo : fix unit, type */
+	loff_t loc, start, end;
+	int i, count = 0, err = 0;
+	struct page *page;
+
+	/* Todo: Add membanks code */
+	/* TBD: Check if we need to address DUMP_PAGE_SIZE < PAGE_SIZE */
+
+	for (i = 0; i < filter->num_mbanks; i++) {
+		start = filter->start[i];
+		end = filter->end[i];
+		for (loc = start; loc < end; loc += DUMP_PAGE_SIZE) {
+			dump_config.dumper->curr_loc = loc;
+			page = dump_get_page(loc);
+			if (page && filter->selector(pass,
+				(unsigned long) page, DUMP_PAGE_SIZE)) {
+				if ((err = action((unsigned long)page,
+					DUMP_PAGE_SIZE))) {
+					printk("LKCD: dump_page_iterator: err %d"
+						"for loc 0x%llx, in pass %d\n",
+						err, loc, pass);
+					return err ? err : count;
+				} else
+					count++;
+			}
+		}
+	}
+
+	return err ? err : count;
+}
+
+/*
+ * Base function that saves the selected block of data in the dump
+ * Action taken when iterator decides that data needs to be saved
+ */
+int dump_generic_save_data(unsigned long loc, unsigned long sz)
+{
+	void *buf;
+	void *dump_buf = dump_config.dumper->dump_buf;
+	int left, bytes, ret;
+
+	if ((ret = dump_add_data(loc, sz))) {
+		return ret;
+	}
+	buf = dump_config.dumper->curr_buf;
+
+	/* If we've filled up the buffer write it out */
+	if ((left = buf - dump_buf) >= DUMP_BUFFER_SIZE) {
+		bytes = dump_write_buffer(dump_buf, DUMP_BUFFER_SIZE);
+		if (bytes < DUMP_BUFFER_SIZE) {
+			printk("LKCD: dump_write_buffer failed %d\n", bytes);
+			return bytes ? -ENOSPC : bytes;
+		}
+
+		left -= bytes;
+
+		/* -- A few chores to do from time to time -- */
+		dump_config.dumper->count++;
+
+		if (!(dump_config.dumper->count & 0x3f)) {
+			/* Update the header every one in a while */
+			memset((void *)dump_buf, 'b', DUMP_BUFFER_SIZE);
+			if ((ret = dump_update_header()) < 0) {
+				/* issue warning */
+				return ret;
+			}
+			printk(".");
+
+			touch_nmi_watchdog();
+		} else if (!(dump_config.dumper->count & 0x7)) {
+			/* Show progress so the user knows we aren't hung */
+			dump_speedo(dump_config.dumper->count >> 3);
+		}
+		/* Todo: Touch/Refresh watchdog */
+
+		/* --- Done with periodic chores -- */
+
+		/*
+		 * extra bit of copying to simplify verification
+		 * in the second kernel boot based scheme
+		 */
+		memcpy(dump_buf - DUMP_PAGE_SIZE, dump_buf +
+			DUMP_BUFFER_SIZE - DUMP_PAGE_SIZE, DUMP_PAGE_SIZE);
+
+		/* now adjust the leftover bits back to the top of the page */
+		/* this case would not arise during stage 2 (passthru) */
+		memset(dump_buf, 'z', DUMP_BUFFER_SIZE);
+		if (left) {
+			memcpy(dump_buf, dump_buf + DUMP_BUFFER_SIZE, left);
+		}
+		buf -= DUMP_BUFFER_SIZE;
+		dump_config.dumper->curr_buf = buf;
+	}
+
+	return 0;
+}
+
+int dump_generic_skip_data(unsigned long loc, unsigned long sz)
+{
+	/* dummy by default */
+	return 0;
+}
+
+/*
+ * Common low level routine to write a buffer to current dump device
+ * Expects checks for space etc to have been taken care of by the caller
+ * Operates serially at the moment for simplicity.
+ * TBD/Todo: Consider batching for improved throughput
+ */
+int dump_ll_write(void *buf, unsigned long len)
+{
+	long transferred = 0, last_transfer = 0;
+	int ret = 0;
+
+	/* make sure device is ready */
+	while ((ret = dump_dev_ready(NULL)) == -EAGAIN);
+	if  (ret < 0) {
+		printk("LKCD: dump_dev_ready failed !err %d\n", ret);
+		return ret;
+	}
+
+	while (len) {
+		if ((last_transfer = dump_dev_write(buf, len)) <= 0)  {
+			ret = last_transfer;
+			printk("LKCD: dump_dev_write failed !err %d\n",
+			ret);
+			break;
+		}
+		/* wait till complete */
+		while ((ret = dump_dev_ready(buf)) == -EAGAIN)
+			cpu_relax();
+
+		if  (ret < 0) {
+			printk("LKCD: i/o failed !err %d\n", ret);
+			break;
+		}
+
+		len -= last_transfer;
+		buf += last_transfer;
+		transferred += last_transfer;
+	}
+	return (ret < 0) ? ret : transferred;
+}
+
+/* default writeout routine for single dump device */
+/* writes out the dump data ensuring enough space is left for the end marker */
+int dump_generic_write_buffer(void *buf, unsigned long len)
+{
+	long written = 0;
+	int err = 0;
+
+	/* check for space */
+	if ((err = dump_dev_seek(dump_config.dumper->curr_offset + len +
+			2*DUMP_BUFFER_SIZE)) < 0) {
+		printk("LKCD: dump_write_buffer: insuff space after offset 0x%llx\n",
+			dump_config.dumper->curr_offset);
+		return err;
+	}
+	/* alignment check would happen as a side effect of this */
+	if ((err = dump_dev_seek(dump_config.dumper->curr_offset)) < 0)
+		return err;
+
+	written = dump_ll_write(buf, len);
+
+	/* all or none */
+
+	if (written < len)
+		written = written ? -ENOSPC : written;
+	else
+		dump_config.dumper->curr_offset += len;
+
+	return written;
+}
+
+int dump_generic_configure(const char *devid)
+{
+	struct dump_dev *dev = dump_config.dumper->dev;
+	struct dump_data_filter *filter;
+	void *buf;
+	int ret = 0;
+
+	/* Allocate the dump buffer and initialize dumper state */
+	/* Assume that we get aligned addresses */
+	if (!(buf = dump_alloc_mem(DUMP_BUFFER_SIZE + 3 * DUMP_PAGE_SIZE)))
+		return -ENOMEM;
+
+	if ((unsigned long)buf & (PAGE_SIZE - 1)) {
+		/* sanity check for page aligned address */
+		dump_free_mem(buf);
+		return -ENOMEM; /* fixme: better error code */
+	}
+
+	/* Initialize the rest of the fields */
+	dump_config.dumper->dump_buf = buf + DUMP_PAGE_SIZE;
+	dumper_reset();
+
+	/* Open the dump device */
+	if (!dev)
+		return -ENODEV;
+
+	if ((ret = dev->ops->open(dev, devid))) {
+	       return ret;
+	}
+
+	/* Initialise the memory ranges in the dump filter */
+	for (filter = dump_config.dumper->filter ;filter->selector; filter++) {
+		if (!filter->start[0] && !filter->end[0]) {
+			pg_data_t *pgdat;
+			int i = 0;
+			for_each_pgdat(pgdat) {
+				filter->start[i] =
+					(loff_t)pgdat->node_start_pfn << PAGE_SHIFT;
+				filter->end[i] =
+					(loff_t)(pgdat->node_start_pfn + pgdat->node_spanned_pages) << PAGE_SHIFT;
+				i++;
+			}
+			filter->num_mbanks = i;
+		}
+	}
+
+	return 0;
+}
+
+int dump_generic_unconfigure(void)
+{
+	struct dump_dev *dev = dump_config.dumper->dev;
+	void *buf = dump_config.dumper->dump_buf;
+	int ret = 0;
+
+	printk("LKCD: Generic unconfigure\n");
+	/* Close the dump device */
+	if (dev && (ret = dev->ops->release(dev)))
+		return ret;
+
+	printk("LKCD: Closed dump device\n");
+
+	if (buf)
+		dump_free_mem((buf - DUMP_PAGE_SIZE));
+
+	dump_config.dumper->curr_buf = dump_config.dumper->dump_buf = NULL;
+	printk("LKCD: Released dump buffer\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_DISCONTIGMEM
+
+void dump_reconfigure_mbanks(void)
+{
+        pg_data_t *pgdat;
+        loff_t start, end, loc, loc_end;
+        int i=0;
+        struct dump_data_filter *filter = dump_config.dumper->filter;
+
+        for_each_pgdat(pgdat) {
+
+                start = (loff_t)(pgdat->node_start_pfn << PAGE_SHIFT);
+                end = ((loff_t)(pgdat->node_start_pfn + pgdat->node_spanned_pages) << PAGE_SHIFT);
+		for(loc = start; loc < end; loc += (DUMP_PAGE_SIZE)) {
+
+                        if(!(__dump_page_valid(loc >> PAGE_SHIFT)))
+                                continue;
+
+                        /* We found a valid page. This is the start */
+                        filter->start[i] = loc;
+
+                        /* Now loop here till you find the end */
+                        for(loc_end = loc; loc_end < end; loc_end += (DUMP_PAGE_SIZE)) {
+
+				if(__dump_page_valid(loc_end >> PAGE_SHIFT)) {
+                                /* This page could very well be the last page */
+                                        filter->end[i] = loc_end;
+                                        continue;
+                                }
+                                break;
+                        }
+                        i++;
+                        loc = loc_end;
+                }
+        }
+        filter->num_mbanks = i;
+
+        /* Propagate memory bank information to other filters */
+        for (filter = dump_config.dumper->filter, filter++ ;filter->selector; filter++) {
+                for(i = 0; i < dump_config.dumper->filter->num_mbanks; i++) {
+                        filter->start[i] = dump_config.dumper->filter->start[i];
+                        filter->end[i] = dump_config.dumper->filter->end[i];
+                        filter->num_mbanks = dump_config.dumper->filter->num_mbanks;
+                }
+        }
+}
+#endif
+
+/* Set up the default dump scheme */
+
+struct dump_scheme_ops dump_scheme_singlestage_ops = {
+	.configure	= dump_generic_configure,
+	.unconfigure	= dump_generic_unconfigure,
+	.sequencer	= dump_generic_sequencer,
+	.iterator	= dump_page_iterator,
+	.save_data	= dump_generic_save_data,
+	.skip_data	= dump_generic_skip_data,
+	.write_buffer	= dump_generic_write_buffer,
+};
+
+struct dump_scheme dump_scheme_singlestage = {
+	.name		= "single-stage",
+	.ops		= &dump_scheme_singlestage_ops
+};
+
+/* The single stage dumper comprising all these */
+struct dumper dumper_singlestage = {
+	.name		= "single-stage",
+	.scheme		= &dump_scheme_singlestage,
+	.fmt		= &dump_fmt_lcrash,
+	.compress 	= &dump_none_compression,
+	.filter		= dump_filter_table,
+	.dev		= NULL,
+};
+
Index: linux-2.6.15/drivers/dump/dump_setup.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_setup.c	2006-02-12 17:02:35.000000000 +0100
@@ -0,0 +1,844 @@
+/*
+ * Standard kernel function entry points for Linux crash dumps.
+ *
+ * Copyright (C) 1999 - 2005 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 2004 - 2005 Hewlett-Packard Development Company, L.P.
+ * Copyright (C) 2000 - 2002 TurboLinux, Inc.  All rights reserved.
+ * Copyright (C) 2001 - 2002 Matt D. Robinson.  All rights reserved.
+ * Copyright (C) 2002 Free Software Foundation, Inc. All rights reserved.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+#include <linux/kernel.h>
+#include <linux/dump.h>
+#include <linux/sysrq.h>
+#include <linux/reboot.h>
+
+#include "dump_methods.h"
+
+
+#define LKCD_VERSION 	"7.0.1"
+#define LKCD_DATE	"2005-06-01"
+#define DUMP_MAJOR 0	/* dynamic major by default */
+
+MODULE_AUTHOR("LKCD development team <lkcd-devel@lists.sourceforge.net>");
+MODULE_DESCRIPTION("Linux Kernel Crash Dump (LKCD) driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(LKCD_VERSION);
+
+/*
+ * -----------------------------------------------------------------------
+ *                         V A R I A B L E S
+ * -----------------------------------------------------------------------
+ */
+
+/* Dump tunables */
+struct dump_config dump_config = {
+	.level 		= 0,
+	.polling	= 1,
+	.reboot		= 1,
+	.comp_flag	= 0,
+	.comp_val	= 0,
+	.dump_device	= NULL,
+	.dump_addr	= 0,
+	.dumper 	= NULL
+};
+
+/* forward declorations */
+static int dump_target_init(int);
+static int dumper_setup(const char *);
+static int dump_compress_init(int compression_type);
+
+/* sysfs input protection semaphore */
+static DECLARE_MUTEX(dump_sysfs_mutex);
+
+/* degree of system freeze when dumping */
+enum dump_silence_levels dump_silence_level = DUMP_HARD_SPIN_CPUS;
+
+/* Other global fields */
+extern struct __dump_header dump_header;
+struct dump_dev *dump_dev = NULL;  /* Active dump device */
+struct dump_dev_driver *dump_dev_driver = NULL;  /* acutall driver device */
+static int dump_compress = 0;
+int dump_compress_level = 1;
+
+static u32 dump_compress_none(const u8 *old, u32 oldsize, u8 *new, u32 newsize,
+		unsigned long loc);
+struct __dump_compress dump_none_compression = {
+	.compress_type	= DUMP_COMPRESS_NONE,
+	.compress_func	= dump_compress_none,
+	.compress_name  = "none",
+};
+
+/* static variables */
+static int dump_okay = 0;
+static spinlock_t dump_lock = SPIN_LOCK_UNLOCKED;
+
+/* used for dump compressors */
+static struct list_head dump_compress_list = LIST_HEAD_INIT(
+		dump_compress_list);
+
+/* list of registered dump targets */
+static struct list_head dump_target_list = LIST_HEAD_INIT(dump_target_list);
+
+/* lkcd info structure -- this is used by lcrash for basic system data */
+	struct __lkcdinfo lkcdinfo = {
+		.ptrsz		= (sizeof(void *) * 8),
+#if defined(__LITTLE_ENDIAN)
+		.byte_order	= __LITTLE_ENDIAN,
+#else
+		.byte_order	= __BIG_ENDIAN,
+#endif
+		.page_shift	= PAGE_SHIFT,
+		.page_size	= PAGE_SIZE,
+		.page_mask	= PAGE_MASK,
+		.page_offset	= PAGE_OFFSET,
+	};
+
+struct dump_attribute {
+	struct attribute	attr;
+	ssize_t (*show) (struct dump_dev_driver *ddev, char *buf);
+	ssize_t (*store)(struct dump_dev_driver *ddev, const char *buf,
+			size_t count);
+};
+
+#define DUMPVAR_ATTR(_name, _mode, _show, _store) \
+	struct dump_attribute dump_attr_##_name = { \
+		.attr = {.name = __stringify(_name), \
+			.mode = _mode, \
+			.owner = THIS_MODULE}, \
+		.show = _show, \
+		.store = _store, \
+	};
+
+#define to_dump_attr(_attr) container_of(_attr,struct dump_attribute,attr)
+#define to_dump_dev_driver(obj) container_of(obj,struct dump_dev_driver,kobj)
+
+ssize_t dump_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	struct dump_dev_driver *dev = to_dump_dev_driver(kobj);
+	struct dump_attribute *dump_attr = to_dump_attr(attr);
+	ssize_t ret = 0;
+
+	if (!dump_config.dumper)
+		/* dump device must be configured first */
+		return -ENODEV;
+
+	down_interruptible(&dump_sysfs_mutex);
+	if (dump_attr->show)
+		ret = dump_attr->show(dev, buf);
+	up(&dump_sysfs_mutex);
+
+	return ret;
+}
+
+ssize_t dump_attr_store(struct kobject *kobj, struct attribute *attr,
+		const char *buf, size_t count)
+{
+	struct dump_dev_driver *dev = to_dump_dev_driver(kobj);
+	struct dump_attribute *dump_attr = to_dump_attr(attr);
+	ssize_t ret = 0;
+
+	if (!dump_config.dumper)
+		/* dump device must be configured first */
+		return -ENODEV;
+
+	if (dump_attr->store)
+		ret = dump_attr->store(dev, buf, count);
+	return ret;
+}
+
+static struct sysfs_ops dump_attr_ops = {
+	.show = dump_attr_show,
+	.store = dump_attr_store,
+};
+
+ssize_t show_version(struct dump_dev_driver *ddev, char *buf)
+{
+	return sprintf(buf, "%s\n%s\n", LKCD_VERSION, LKCD_DATE);
+}
+
+ssize_t show_polling(struct dump_dev_driver *ddev, char *buf)
+{
+	return sprintf(buf, "%d\n", dump_config.polling);
+}
+
+ssize_t store_polling(struct dump_dev_driver *ddev, const char *buf,
+		size_t count)
+{
+	ulong tmp;
+
+	if (buf == NULL)
+		return -EINVAL;
+
+	if ((sscanf(buf, "%lx", &tmp)) != 1)
+		return -EINVAL;
+
+	if ((tmp < 0) | (tmp > 1))
+		return -EINVAL;
+
+	dump_config.polling = tmp;
+
+	/* If dump_device has already been initalized and we
+	 * want to change the polling status we need to
+	 * re-init dumpdev with the new polling value.
+	 */
+	if (dump_config.dump_device)
+		dumper_setup(dump_config.dump_device);
+
+	return count;
+}
+
+ssize_t show_dumpdev(struct dump_dev_driver *ddev, char *buf)
+{
+	return sprintf(buf, "%s\n", dump_config.dump_device);
+}
+
+ssize_t store_dumpdev(struct dump_dev_driver *ddev, const char *buf,
+		size_t count)
+{
+	int err, type;
+	printk("LKCD: Configuring dump device\n");
+
+	if (buf == NULL)
+		return -EINVAL;
+
+	if ((strncmp(buf, "eth", 3) == 0) |
+			(strncmp(buf, "ath", 3) == 0) |
+			(strncmp(buf, "wlan", 4) == 0)){
+
+		type = DUMP_TYPE_NETDEV;
+	} else
+				type = DUMP_TYPE_BLOCKDEV;
+
+	if (dump_target_init(type) < 0)
+		return -EINVAL;
+
+	__dump_open();
+
+	err = dumper_setup(buf);
+	if (err)
+		return -EINVAL;
+
+	/* do we have a compress value that was set
+	 * before we had a dump dump_dev that needs
+	 * to be initalized?
+	 */
+	if (dump_config.comp_flag) {
+		dump_compress_init((int)dump_config.comp_val);
+		dump_config.comp_flag = 0;
+	}
+
+	return count;
+}
+
+ssize_t show_level(struct dump_dev_driver *ddev, char *buf)
+{
+	return sprintf(buf, "0x%lx\n", dump_config.level);
+}
+
+ssize_t store_level(struct dump_dev_driver *ddev, const char *buf,
+		size_t count)
+{
+	ulong tmp;
+
+	if (buf == NULL)
+		return -EINVAL;
+
+	if ( ( sscanf(buf, "%lx", &tmp)) != 1)
+		return -EINVAL;
+
+	if (tmp < 0)
+		return -EINVAL;
+
+	dump_config.level = 0;
+
+	/* FIXME this is terrible and make it impossible for
+	 * the user to see what they set. I'm leaving it only for
+	 * the first rev and will fix this soon! -- troyh
+	 */
+	switch ((int)tmp){
+		case DUMP_LEVEL_ALL:
+		case DUMP_LEVEL_ALL_RAM:
+			dump_config.level |= DUMP_MASK_UNUSED;
+		case DUMP_LEVEL_USED:
+			dump_config.level |= DUMP_MASK_USED;
+		case DUMP_LEVEL_KERN:
+			dump_config.level |= DUMP_MASK_KERN;
+		case DUMP_LEVEL_HEADER:
+			dump_config.level |= DUMP_MASK_HEADER;
+		case DUMP_LEVEL_NONE:
+			break;
+		default:
+			return (-EINVAL);
+	}
+	printk("LKCD: Dump Level 0x%lx\n", dump_config.level);
+
+	return count;
+}
+
+
+ssize_t show_compress(struct dump_dev_driver *ddev, char *buf)
+{
+
+	if (dump_config.comp_flag)
+		return sprintf(buf, "%d\n", dump_config.comp_val);
+	else
+		return sprintf(buf, "%d\n", dump_compress);
+}
+
+ssize_t store_compress(struct dump_dev_driver *ddev, const char *buf,
+		size_t count)
+{
+	ulong tmp;
+
+	if (buf == NULL)
+		return -EINVAL;
+
+	if ((sscanf(buf, "%lx", &tmp)) != 1)
+		return -EINVAL;
+
+	if ((tmp < 0) | (tmp > 2))
+		return -EINVAL;
+
+	/* dump_config.dump_device must valid first to establish
+	 * the compression type. Will take the parameter now and
+	 * delay the compress_init until we have a dump_device.
+	 */
+	if (dump_config.dump_device == 0){
+		dump_config.comp_flag = 1;
+		dump_config.comp_val = tmp;
+	} else {
+		dump_compress_init((int)tmp);
+	}
+
+	return count;
+}
+
+ssize_t show_compress_level(struct dump_dev_driver *ddev, char *buf)
+{
+	return sprintf(buf, "%d\n", dump_compress_level);
+}
+
+ssize_t store_compress_level(struct dump_dev_driver *ddev, const char *buf, size_t count)
+{
+	int tmp;
+
+	if (buf == NULL)
+		return -EINVAL;
+
+	if (sscanf(buf, "%d", &tmp) != 1)
+		return -EINVAL;
+
+	/* Small kludge:  We allow levels 1-9 here because that's what
+	 * makes sense for gzip, which is currently the only compression
+	 * type to make use of multiple levels.
+	 */
+	if (tmp < 1 || tmp > 9)
+		return -EINVAL;
+
+	dump_compress_level = tmp;
+
+	return count;
+}
+
+ssize_t show_reboot(struct dump_dev_driver *ddev, char *buf)
+{
+	return sprintf(buf, "%d\n", dump_config.reboot);
+}
+
+ssize_t store_reboot(struct dump_dev_driver *ddev, const char *buf,
+		size_t count)
+{
+	ulong tmp;
+
+	if (buf == NULL)
+		return -EINVAL;
+
+	if ((sscanf(buf, "%lx", &tmp)) != 1)
+		return -EINVAL;
+
+	if ((tmp < 0) | (tmp > 1))
+		return -EINVAL;
+
+	dump_config.reboot = tmp;
+
+	return count;
+}
+
+
+
+static DUMPVAR_ATTR(polling, 0664, show_polling, store_polling);
+static DUMPVAR_ATTR(dumpdev, 0664, show_dumpdev, store_dumpdev);
+static DUMPVAR_ATTR(level, 0664, show_level, store_level);
+static DUMPVAR_ATTR(compress, 0664, show_compress, store_compress);
+static DUMPVAR_ATTR(compress_level, 0664, show_compress_level, store_compress_level);
+static DUMPVAR_ATTR(reboot, 0664, show_reboot, store_reboot);
+static DUMPVAR_ATTR(version, 0444, show_version, NULL);
+
+/* These are default attributes for the dump device
+ * There are none.
+ */
+static struct attribute *def_attrs[] = {
+	NULL,
+};
+
+static struct dump_attribute *dump_attrs[] = {
+	&dump_attr_polling,
+	&dump_attr_dumpdev,
+	&dump_attr_level,
+	&dump_attr_compress,
+	&dump_attr_compress_level,
+	&dump_attr_reboot,
+	&dump_attr_version,
+	NULL,
+};
+
+/**
+ *	dump_release - free dump structure
+ *	@kobj:	kobject of dump structure
+ *
+ *	This is called when the refcount of the dump structure
+ *	reaches 0. This should happen right after we unregister,
+ *	but just in case, we use the release callback anyway.
+ */
+
+static void dump_release(struct kobject *kobj)
+{
+	struct dump_dev_driver *dev = to_dump_dev_driver(kobj);
+	kfree(dev);
+}
+
+static struct kobj_type ktype_dump = {
+	.release	= dump_release,
+	.sysfs_ops	= &dump_attr_ops,
+	.default_attrs	= def_attrs,
+};
+
+static decl_subsys(dump, &ktype_dump, NULL);
+
+
+/*
+ * -----------------------------------------------------------------------
+ *              C O M P R E S S I O N   F U N C T I O N S
+ * -----------------------------------------------------------------------
+ */
+
+/*
+ * Name: dump_compress_none()
+ * Func: Don't do any compression, period.
+ */
+	static u32
+dump_compress_none(const u8 *old, u32 oldsize, u8 *new, u32 newsize,
+		unsigned long loc)
+{
+	/* just return the old size */
+	return oldsize;
+}
+
+/*
+ * Name: dump_execute()
+ * Func: Execute the dumping process.  This makes sure all the appropriate
+ *       fields are updated correctly, and calls dump_execute_memdump(),
+ *       which does the real work.
+ */
+void dump_execute(const char *panic_str, const struct pt_regs *regs)
+{
+	int state = -1;
+	unsigned long flags;
+	int loglevel_save = console_loglevel;
+
+	if (console_loglevel < 6) /* KERN_INFO */
+		console_loglevel = 6;
+
+	/* make sure we can dump */
+	if (!dump_okay) {
+		pr_info("LKCD: not yet configured, can't take dump now\n");
+		return;
+	}
+
+	/* Exclude multiple dumps at the same time,
+	 * and disable interrupts,  some drivers may re-enable
+	 * interrupts in with silence()
+	 *
+	 * Try and acquire spin lock. If successful, leave preempt
+	 * and interrupts disabled.  See spin_lock_irqsave in spinlock.h
+	 */
+	local_irq_save(flags);
+	if (!spin_trylock(&dump_lock)) {
+		local_irq_restore(flags);
+		pr_info("LKCD: dump already in progress\n");
+		return;
+	}
+
+	/* What state are interrupts really in? */
+	if (in_interrupt()) {
+		if(in_irq())
+			printk("LKCD: Dumping from interrupt handler!\n");
+		else
+			printk("LKCD: Dumping from bottom half!\n");
+
+		/*
+		 * If we are not doing polling I/O then we should attempt
+		 * to clean up the irq state.
+		 *
+		 * If polling I/O falls back to interrupt-driven mode then
+		 * it will need to clean the IRQ state
+		 */
+		if (!(dump_config.polling))
+			__dump_clean_irq_state();
+	}
+
+	/* Bring system into the strictest level of quiescing for min drift
+	 * dump drivers can soften this as required in dev->ops->silence()
+	 */
+	dump_oncpu = smp_processor_id() + 1;
+	dump_silence_level = DUMP_HARD_SPIN_CPUS;
+
+	state = dump_generic_execute(panic_str, regs);
+
+	dump_oncpu = 0;
+	spin_unlock_irqrestore(&dump_lock, flags);
+
+	if (state < 0) {
+		printk("LKCD: Dump Incomplete or failed!\n");
+	} else {
+		printk("LKCD: Dump Complete; %d dump pages saved.\n",
+				dump_header.dh_num_dump_pages);
+	}
+
+	console_loglevel = loglevel_save;
+
+	if (dump_config.reboot)
+		emergency_restart();
+
+}
+
+/*
+ * Name: dump_register_compression()
+ * Func: Register a dump compression mechanism.
+ */
+void dump_register_compression(struct __dump_compress *item)
+{
+	if (item)
+		list_add(&(item->list), &dump_compress_list);
+}
+
+/*
+ * Name: dump_unregister_compression()
+ * Func: Remove a dump compression mechanism, and re-assign the dump
+ *       compression pointer if necessary.
+ */
+void dump_unregister_compression(int compression_type)
+{
+	struct list_head *tmp;
+	struct __dump_compress *dc;
+
+	/* let's make sure our list is valid */
+	if (compression_type == DUMP_COMPRESS_NONE)
+		return;
+	list_for_each(tmp, &dump_compress_list) {
+		dc = list_entry(tmp, struct __dump_compress, list);
+		if (dc->compress_type == compression_type) {
+			/*
+			 * If we're currently configured to dump using
+			 * the compression mechanism we're removing,
+			 * unconfigure ourselves.
+			 */
+			if (dump_config.dumper &&
+					dump_config.dumper->compress == dc) {
+				dump_okay = 0;
+				dump_unconfigure();
+				dump_dev = NULL;
+				dump_config.dumper = NULL;
+			}
+			list_del(&(dc->list));
+			break;
+		}
+	}
+}
+
+/*
+ * Name: dump_compress_init()
+ * Func: Initialize (or re-initialize) compression scheme.
+ */
+static int dump_compress_init(int compression_type)
+{
+	struct list_head *tmp;
+	struct __dump_compress *dc;
+
+	list_for_each(tmp, &dump_compress_list) {
+		dc = list_entry(tmp, struct __dump_compress, list);
+		if (dc->compress_type == compression_type) {
+			dump_config.dumper->compress = dc;
+			dump_compress = compression_type;
+			printk("LKCD: %s compression initalized\n",
+					dc->compress_name);
+			return 0;
+		}
+	}
+
+	printk("LKCD: compression_type:%d not found\n", compression_type);
+	return -ENODATA;
+}
+
+static int dumper_setup(const char *devid)
+{
+	int ret = 0;
+
+	/* unconfigure old dumper if it exists */
+	dump_okay = 0;
+	if (dump_config.dumper) {
+		printk("LKCD: Unconfiguring current dumper\n");
+		dump_unconfigure();
+	}
+	/* set up new dumper */
+	dump_config.dumper = &dumper_singlestage;
+
+	dump_config.dumper->dev = dump_dev;
+
+	if (dump_config.dump_device)
+		kfree(dump_config.dump_device);
+
+	if (!(dump_config.dump_device = kmalloc(strlen(devid), GFP_KERNEL)))
+		return -ENOMEM;
+
+	strcpy(dump_config.dump_device, devid);
+
+	ret = dump_configure(devid);
+	if (!ret) {
+		dump_okay = 1;
+		printk("LKCD: %s dumper set up for dev %s\n",
+				dump_config.dumper->name,
+				dump_config.dump_device);
+	} else {
+		printk("LKCD: %s dumper set up failed for dev %s\n",
+				dump_config.dumper->name,
+				dump_config.dump_device);
+		dump_config.dumper = NULL;
+	}
+	return ret;
+}
+
+static int dump_target_init(int type)
+{
+	struct list_head *tmp;
+	struct dump_dev *dev;
+
+	list_for_each(tmp, &dump_target_list) {
+		dev = list_entry(tmp, struct dump_dev, list);
+		if (type == dev->type) {
+			dump_dev = dev;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+
+
+/*
+ * -----------------------------------------------------------------------
+ *                     I N I T   F U N C T I O N S
+ * -----------------------------------------------------------------------
+ */
+
+static void dump_populate_dir(struct dump_dev_driver * ddev)
+{
+	struct dump_attribute *attr;
+	int err = 0, i;
+
+	for (i = 0; (attr = dump_attrs[i]) && !err; i++) {
+		if (attr->show)
+			err = sysfs_create_file(&dump_subsys.kset.kobj,
+					&attr->attr);
+	}
+}
+
+/*
+ * These register and unregister routines are exported for modules
+ * to register their dump drivers (like block, net etc)
+ */
+int dump_register_device(struct dump_dev *ddev)
+{
+	struct list_head *tmp;
+	struct dump_dev *dev;
+
+	list_for_each(tmp, &dump_target_list) {
+		dev = list_entry(tmp, struct dump_dev, list);
+		if (dev->type == dev->type) {
+			printk("LKCD: Target type %d already registered\n",
+					dev->type);
+			return -1; /* return proper error */
+		}
+	}
+	list_add(&(ddev->list), &dump_target_list);
+
+	return 0;
+}
+
+void dump_unregister_device(struct dump_dev *ddev)
+{
+	list_del(&(ddev->list));
+	if (ddev != dump_dev)
+		return;
+
+	dump_okay = 0;
+
+	if (dump_config.dumper)
+		dump_unconfigure();
+
+	dump_okay = 0;
+	dump_dev = NULL;
+	dump_config.dumper = NULL;
+}
+
+static int panic_event(struct notifier_block *this, unsigned long event,
+		void *ptr)
+{
+	struct pt_regs regs;
+
+	get_current_regs(&regs);
+	dump_execute((const char *)ptr, &regs);
+	return 0;
+}
+
+extern struct notifier_block *panic_notifier_list;
+static int panic_event(struct notifier_block *, unsigned long, void *);
+static struct notifier_block panic_block = {
+	.notifier_call = panic_event,
+};
+
+#ifdef CONFIG_MAGIC_SYSRQ
+/* Sysrq handler */
+static void sysrq_handle_crashdump(int key, struct pt_regs *pt_regs,
+		struct tty_struct *tty) {
+	if (!pt_regs) {
+		struct pt_regs regs;
+		get_current_regs(&regs);
+		dump_execute("sysrq", &regs);
+
+	} else {
+		dump_execute("sysrq", pt_regs);
+	}
+}
+
+static struct sysrq_key_op sysrq_crashdump_op = {
+	.handler	=	sysrq_handle_crashdump,
+	.help_msg	=	"Dump",
+	.action_msg	=	"Starting crash dump",
+};
+#endif
+
+static inline void dump_sysrq_register(void)
+{
+#ifdef CONFIG_MAGIC_SYSRQ
+	register_sysrq_key(DUMP_SYSRQ_KEY, &sysrq_crashdump_op);
+#endif
+}
+
+static inline void dump_sysrq_unregister(void)
+{
+#ifdef CONFIG_MAGIC_SYSRQ
+	unregister_sysrq_key(DUMP_SYSRQ_KEY, &sysrq_crashdump_op);
+#endif
+}
+
+/*
+ * Name: dump_init()
+ * Func: Initialize the dump process.  This will set up any architecture
+ *       dependent code.
+ */
+static int __init dump_init(void)
+{
+	struct sysinfo info;
+	int err;
+
+	err = subsystem_register(&dump_subsys);
+	if (err)
+		return err;
+
+
+	dump_dev_driver = kmalloc(sizeof(struct dump_dev_driver), GFP_KERNEL);
+	if (!dump_dev_driver) {
+		subsystem_unregister(&dump_subsys);
+		return -ENOMEM;
+	}
+
+	memset(dump_dev_driver, 0, sizeof(struct dump_dev_driver));
+
+	kobject_set_name(&dump_dev_driver->kobj, "dump_dev_driver");
+	kobj_set_kset_s(dump_dev_driver, dump_subsys);
+
+	/* initalize but do not register the kobject
+	 * that represents the dump device, we only want
+	 * if for refcount, the important attributes are
+	 * assigned to the dump_subsys kobject anyway.
+	 */
+	kobject_init(&dump_dev_driver->kobj);
+
+	dump_populate_dir(dump_dev_driver);
+
+	__dump_init((u64) PAGE_OFFSET);
+
+	/* set the dump_compression_list structure up */
+	dump_register_compression(&dump_none_compression);
+
+	/* grab the total memory size now (not if/when we crash) */
+	si_meminfo(&info);
+
+	/* set the memory size */
+	dump_header.dh_memory_size = (u64) info.totalram;
+
+	dump_sysrq_register();
+
+	notifier_chain_register(&panic_notifier_list, &panic_block);
+	dump_function_ptr = dump_execute;
+
+	pr_info("LKCD: Crash dump driver initialized.\n");
+	return 0;
+}
+
+static inline void dump_device_driver_unregister(struct dump_dev_driver *dev)
+{
+	kobject_unregister(&dev->kobj);
+}
+
+static void __exit dump_cleanup(void)
+{
+	subsystem_unregister(&dump_subsys);
+
+	if (dump_dev_driver) {
+		dump_device_driver_unregister(dump_dev_driver);
+	}
+
+	dump_okay = 0;
+
+	if (dump_config.dumper)
+		dump_unconfigure();
+
+	/* arch-specific cleanup routine */
+	__dump_cleanup();
+
+	/* ignore errors while unregistering -- since can't do anything */
+	dump_sysrq_unregister();
+	notifier_chain_unregister(&panic_notifier_list, &panic_block);
+	dump_function_ptr = NULL;
+
+	pr_info("LKCD: Crash dump driver unloaded.\n");
+}
+
+EXPORT_SYMBOL_GPL(dump_register_compression);
+EXPORT_SYMBOL_GPL(dump_unregister_compression);
+EXPORT_SYMBOL_GPL(dump_register_device);
+EXPORT_SYMBOL_GPL(dump_unregister_device);
+EXPORT_SYMBOL_GPL(dump_config);
+EXPORT_SYMBOL_GPL(dump_compress_level);
+EXPORT_SYMBOL_GPL(dump_silence_level);
+EXPORT_SYMBOL_GPL(__dump_irq_enable);
+EXPORT_SYMBOL_GPL(__dump_irq_restore);
+
+module_init(dump_init);
+module_exit(dump_cleanup);
Index: linux-2.6.15/drivers/dump/dump_x8664.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/dump/dump_x8664.c	2006-02-12 16:58:13.937952154 +0100
@@ -0,0 +1,376 @@
+/*
+ * Architecture specific (x86-64) functions for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ *
+ * Copyright 1999 Silicon Graphics, Inc. All rights reserved.
+ *
+ * 2.3 kernel modifications by: Matt D. Robinson (yakker@turbolinux.com)
+ * Copyright 2000 TurboLinux, Inc.  All rights reserved.
+ *
+ * x86-64 port Copyright 2002 Andi Kleen, SuSE Labs
+ * x86-64 port Sachin Sant ( sachinp@in.ibm.com )
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/*
+ * The hooks for dumping the kernel virtual memory to disk are in this
+ * file.  Any time a modification is made to the virtual memory mechanism,
+ * these routines must be changed to use the new mechanisms.
+ */
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/smp.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/dump.h>
+#include "dump_methods.h"
+#include <linux/mm.h>
+#include <linux/rcupdate.h>
+#include <asm/processor.h>
+#include <asm/hardirq.h>
+#include <asm/kdebug.h>
+#include <asm/uaccess.h>
+#include <asm/nmi.h>
+#include <asm/kdebug.h>
+
+static __s32 	saved_irq_count; /* saved preempt_count() flag */
+
+void (*dump_trace_ptr)(struct pt_regs *);
+
+static int alloc_dha_stack(void)
+{
+	int i;
+	void *ptr;
+
+	if (dump_header_asm.dha_stack[0])
+		return 0;
+
+       	ptr = vmalloc(THREAD_SIZE * num_online_cpus());
+	if (!ptr) {
+		printk("LKCD: vmalloc for dha_stacks failed\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < num_online_cpus(); i++) {
+		dump_header_asm.dha_stack[i] =
+			(uint64_t)((unsigned long)ptr + (i * THREAD_SIZE));
+	}
+	return 0;
+}
+
+static int free_dha_stack(void)
+{
+	if (dump_header_asm.dha_stack[0]) {
+		vfree((void *)dump_header_asm.dha_stack[0]);
+		dump_header_asm.dha_stack[0] = 0;
+	}
+	return 0;
+}
+
+void
+__dump_save_regs(struct pt_regs* dest_regs, const struct pt_regs* regs)
+{
+	if (regs)
+		memcpy(dest_regs, regs, sizeof(struct pt_regs));
+}
+
+void
+__dump_save_context(int cpu, const struct pt_regs *regs,
+	struct task_struct *tsk)
+{
+	dump_header_asm.dha_smp_current_task[cpu] = (unsigned long)tsk;
+	__dump_save_regs(&dump_header_asm.dha_smp_regs[cpu], regs);
+
+	/* take a snapshot of the stack */
+	/* doing this enables us to tolerate slight drifts on this cpu */
+
+	if (dump_header_asm.dha_stack[cpu]) {
+		memcpy((void *)dump_header_asm.dha_stack[cpu],
+				STACK_START_POSITION(tsk),
+				THREAD_SIZE);
+	}
+	dump_header_asm.dha_stack_ptr[cpu] = (unsigned long)(tsk->thread_info);
+}
+
+#ifdef CONFIG_SMP
+extern cpumask_t irq_affinity[];
+extern irq_desc_t irq_desc[];
+extern void dump_send_ipi(void);
+static int dump_expect_ipi[NR_CPUS];
+static atomic_t waiting_for_dump_ipi;
+static cpumask_t saved_affinity[NR_IRQS];
+
+extern void stop_this_cpu(void *);
+
+static int
+dump_nmi_callback(struct pt_regs *regs, int cpu)
+{
+	if (!dump_expect_ipi[cpu]) {
+		return 0;
+	}
+
+	dump_expect_ipi[cpu] = 0;
+
+	dump_save_this_cpu(regs);
+	atomic_dec(&waiting_for_dump_ipi);
+
+level_changed:
+
+	switch (dump_silence_level) {
+        case DUMP_HARD_SPIN_CPUS:       /* Spin until dump is complete */
+                while (dump_oncpu) {
+                        barrier();      /* paranoia */
+                        if (dump_silence_level != DUMP_HARD_SPIN_CPUS)
+                                goto level_changed;
+
+                        cpu_relax();    /* kill time nicely */
+                }
+                break;
+
+        case DUMP_HALT_CPUS:            /* Execute halt */
+                stop_this_cpu(NULL);
+                break;
+
+        case DUMP_SOFT_SPIN_CPUS:
+                /* Mark the task so it spins in schedule */
+                set_tsk_thread_flag(current, TIF_NEED_RESCHED);
+                break;
+        }
+
+	return 1;
+}
+
+/* save registers on other processors */
+void
+__dump_save_other_cpus(void)
+{
+	int i, cpu = smp_processor_id();
+	int other_cpus = num_online_cpus() - 1;
+
+	if (other_cpus > 0) {
+		atomic_set(&waiting_for_dump_ipi, other_cpus);
+
+		for (i = 0; i < NR_CPUS; i++)
+			dump_expect_ipi[i] = (i != cpu && cpu_online(i));
+
+		set_nmi_callback(dump_nmi_callback);
+		wmb();
+
+		dump_send_ipi();
+
+		/* may be we dont need to wait for NMI to be processed.
+		   just write out the header at the end of dumping, if
+		   this IPI is not processed untill then, there probably
+		   is a problem and we just fail to capture state of
+		   other cpus. */
+		while(atomic_read(&waiting_for_dump_ipi) > 0)
+			cpu_relax();
+
+		unset_nmi_callback();
+	}
+	return;
+}
+
+/*
+ * Routine to save the old irq affinities and change affinities of all irqs to
+ * the dumping cpu.
+ */
+static void
+set_irq_affinity(void)
+{
+	int i;
+	cpumask_t cpu = CPU_MASK_NONE;
+
+	cpu_set(smp_processor_id(), cpu);
+	memcpy(saved_affinity, irq_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		irq_affinity[i] = cpu;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, irq_affinity[i]);
+	}
+}
+
+/*
+ * Restore old irq affinities.
+ */
+static void
+reset_irq_affinity(void)
+{
+	int i;
+
+	memcpy(irq_affinity, saved_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, saved_affinity[i]);
+	}
+}
+
+#else /* !CONFIG_SMP */
+#define set_irq_affinity()	do { } while (0)
+#define reset_irq_affinity()	do { } while (0)
+#define save_other_cpu_states() do { } while (0)
+#endif /* !CONFIG_SMP */
+
+static inline void
+irq_bh_save(void)
+{
+	saved_irq_count = irq_count();
+	preempt_count() &= ~(HARDIRQ_MASK|SOFTIRQ_MASK);
+}
+
+static inline void
+irq_bh_restore(void)
+{
+	preempt_count() |= saved_irq_count;
+}
+
+/*
+ * Name: __dump_irq_enable
+ * Func: Reset system so interrupts are enabled.
+ *       This is used for dump methods that require interrupts
+ *       Eventually, all methods will have interrupts disabled
+ *       and this code can be removed.
+ *
+ *     Change irq affinities
+ *     Re-enable interrupts
+ */
+int
+__dump_irq_enable(void)
+{
+        set_irq_affinity();
+        irq_bh_save();
+        local_irq_enable();
+	return 0;
+}
+
+/*
+ * Name: __dump_irq_restore
+ * Func: Resume the system state in an architecture-speeific way.
+ *
+ */
+void
+__dump_irq_restore(void)
+{
+        local_irq_disable();
+        reset_irq_affinity();
+        irq_bh_restore();
+}
+
+/*
+ * Name: __dump_kernel_addr()
+ * Func: Return physical kernel load address.
+ */
+unsigned long
+__dump_kernel_addr(void)
+{
+	/* Unsatisfactory - arch/x86_64/kernel/vmlinux.lds.S hard codes the
+	 * offset to the start of the text.  It should be a global arch
+	 * specific define.
+	 */
+	return virt_to_phys((void *)0xffffffff80100000UL);
+}
+
+/*
+ * Name: __dump_configure_header()
+ * Func: Configure the dump header with all proper values.
+ */
+int
+__dump_configure_header(const struct pt_regs *regs)
+{
+	/* Dummy function - return */
+	return (0);
+}
+
+static int notify(struct notifier_block *nb, unsigned long code, void *data)
+{
+	if (code == DIE_NMI_IPI && dump_oncpu)
+		return NOTIFY_BAD;
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block dump_notifier = {
+	.notifier_call = notify,
+};
+
+/*
+ * Name: __dump_init()
+ * Func: Initialize the dumping routine process.
+ */
+void
+__dump_init(uint64_t local_memory_start)
+{
+	notifier_chain_register(&die_chain, &dump_notifier);
+}
+
+/*
+ * Name: __dump_open()
+ * Func: Open the dump device (architecture specific).  This is in
+ *       case it's necessary in the future.
+ */
+void
+__dump_open(void)
+{
+	alloc_dha_stack();
+	/* return */
+	return;
+}
+
+/*
+ * Name: __dump_cleanup()
+ * Func: Free any architecture specific data structures. This is called
+ *       when the dump module is being removed.
+ */
+void
+__dump_cleanup(void)
+{
+	free_dha_stack();
+	notifier_chain_unregister(&die_chain, &dump_notifier);
+	synchronize_kernel();
+	return;
+}
+
+extern int page_is_ram(unsigned long);
+
+/*
+ * Name: __dump_page_valid()
+ * Func: Check if page is valid to dump.
+ */
+int
+__dump_page_valid(unsigned long index)
+{
+	if (!pfn_valid(index))
+		return 0;
+
+	return page_is_ram(index);
+}
+
+/*
+ * Name: manual_handle_crashdump()
+ * Func: Interface for the lkcd dump command. Calls dump_execute()
+ */
+int
+manual_handle_crashdump(void) {
+
+        struct pt_regs regs;
+
+        get_current_regs(&regs);
+        dump_execute("manual", &regs);
+        return 0;
+}
+
+/*
+ * Name: __dump_clean_irq_state()
+ * Func: Clean up from the previous IRQ handling state. Such as oops from
+ *       interrupt handler or bottom half.
+ */
+void
+__dump_clean_irq_state(void)
+{
+    return;
+}
Index: linux-2.6.15/drivers/scsi/scsi_dump.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/drivers/scsi/scsi_dump.c	2006-02-12 16:58:13.937952154 +0100
@@ -0,0 +1,438 @@
+/*
+ *  linux/drivers/scsi/scsi_dump.c
+ *
+ *  Copyright (C) 2004  FUJITSU LIMITED
+ *  Written by Nobuhiro Tachino (ntachino@jp.fujitsu.com)
+ *
+ * Some codes are derived from drivers/scsi/sd.c
+ *
+ * Oct 05, 2004 Enhanced cmd_result() by Jim Keniston(jkenisto@us.ibm.com)
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+#include <linux/blkdev.h>
+#include <linux/blkpg.h>
+
+#include <linux/genhd.h>
+#include <linux/utsname.h>
+#include <linux/delay.h>
+#include <linux/diskdump.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_ioctl.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_eh.h>
+
+#define MAX_RETRIES 5
+#define SD_TIMEOUT (60 * HZ)
+
+#define Dbg(x, ...)	pr_debug("scsi_dump: " x "\n", ## __VA_ARGS__)
+#define Err(x, ...)	pr_err  ("scsi_dump: " x "\n", ## __VA_ARGS__)
+#define Warn(x, ...)	pr_warn ("scsi_dump: " x "\n", ## __VA_ARGS__)
+#define Info(x, ...)	pr_info ("scsi_dump: " x "\n", ## __VA_ARGS__)
+
+/* blocks to 512byte sectors */
+#define BLOCK_SECTOR(s)	((s) << (DUMP_BLOCK_SHIFT - 9))
+
+static struct scsi_cmnd scsi_dump_cmnd;
+static struct request scsi_dump_req;
+
+static void rw_intr(struct scsi_cmnd * scmd)
+{
+	del_timer(&scmd->eh_timeout);
+	scmd->done = NULL;
+}
+
+static void eh_timeout(unsigned long data)
+{
+}
+
+/*
+ * Common code to make Scsi_Cmnd
+ */
+static void init_scsi_command(struct scsi_device *sdev, struct scsi_cmnd *scmd,
+		 	      void *buf, int len, unsigned char direction,
+			      int set_lun)
+{
+	scmd->request   = &scsi_dump_req;
+	scmd->device	= sdev;
+	scmd->buffer	= scmd->request_buffer = buf;
+	scmd->bufflen	= scmd->request_bufflen = len;
+
+
+	scmd->sc_data_direction = direction;
+
+	memcpy(scmd->data_cmnd, scmd->cmnd, sizeof(scmd->cmnd));
+	scmd->cmd_len = COMMAND_SIZE(scmd->cmnd[0]);
+	scmd->old_cmd_len = scmd->cmd_len;
+
+
+	if (set_lun)
+		scmd->cmnd[1] |= (sdev->scsi_level <= SCSI_2) ?
+				  ((sdev->lun << 5) & 0xe0) : 0;
+
+	scmd->transfersize = sdev->sector_size;
+	if (direction == DMA_TO_DEVICE)
+		scmd->underflow = len;
+
+	scmd->allowed = MAX_RETRIES;
+	scmd->timeout_per_command = SD_TIMEOUT;
+
+	/*
+	 * This is the completion routine we use.  This is matched in terms
+	 * of capability to this function.
+	 */
+	scmd->done = rw_intr;
+
+	/*
+	 * Some low driver put eh_timeout into the timer list.
+	 */
+	init_timer(&scmd->eh_timeout);
+	scmd->eh_timeout.data		= (unsigned long)scmd;
+	scmd->eh_timeout.function	= eh_timeout;
+}
+
+/* SYNCHRONIZE CACHE */
+static void init_sync_command(struct scsi_device *sdev, struct scsi_cmnd * scmd)
+{
+	memset(scmd, 0, sizeof(*scmd));
+	scmd->cmnd[0] = SYNCHRONIZE_CACHE;
+
+	init_scsi_command(sdev, scmd, NULL, 0, DMA_NONE, 0);
+}
+
+/* READ/WRITE */
+static int init_rw_command(struct disk_dump_partition *dump_part,
+			   struct scsi_device *sdev, struct scsi_cmnd * scmd,
+			   int rw, int block, void *buf, unsigned int len)
+{
+	int this_count = len >> 9;
+
+	memset(scmd, 0, sizeof(*scmd));
+
+	if (block + this_count > dump_part->nr_sects) {
+		Err("scsi_dump: block number %d is larger than %lu",
+				block + this_count, dump_part->nr_sects);
+		return -EFBIG;
+	}
+
+	block += dump_part->start_sect;
+
+	/*
+	 * If we have a 1K hardware sectorsize, prevent access to single
+	 * 512 byte sectors.  In theory we could handle this - in fact
+	 * the scsi cdrom driver must be able to handle this because
+	 * we typically use 1K blocksizes, and cdroms typically have
+	 * 2K hardware sectorsizes.  Of course, things are simpler
+	 * with the cdrom, since it is read-only.  For performance
+	 * reasons, the filesystems should be able to handle this
+	 * and not force the scsi disk driver to use bounce buffers
+	 * for this.
+	 */
+	if (sdev->sector_size == 1024) {
+		block = block >> 1;
+		this_count = this_count >> 1;
+	}
+	if (sdev->sector_size == 2048) {
+		block = block >> 2;
+		this_count = this_count >> 2;
+	}
+	if (sdev->sector_size == 4096) {
+		block = block >> 3;
+		this_count = this_count >> 3;
+	}
+	switch (rw) {
+	case WRITE:
+		if (!sdev->writeable) {
+			Err("scsi_dump: writable media");
+			return 0;
+		}
+		scmd->cmnd[0] = WRITE_10;
+		break;
+	case READ:
+		scmd->cmnd[0] = READ_10;
+		break;
+	default:
+		Err("scsi_dump: Unknown command %d", rw);
+		return -EINVAL;
+	}
+
+	if (this_count > 0xffff)
+		this_count = 0xffff;
+
+	scmd->cmnd[2] = (unsigned char) (block >> 24) & 0xff;
+	scmd->cmnd[3] = (unsigned char) (block >> 16) & 0xff;
+	scmd->cmnd[4] = (unsigned char) (block >> 8) & 0xff;
+	scmd->cmnd[5] = (unsigned char) block & 0xff;
+	scmd->cmnd[7] = (unsigned char) (this_count >> 8) & 0xff;
+	scmd->cmnd[8] = (unsigned char) this_count & 0xff;
+
+	init_scsi_command(sdev, scmd, buf, len,
+			(rw == WRITE ? DMA_TO_DEVICE : DMA_FROM_DEVICE), 1);
+	return 0;
+}
+
+/*
+ * Check the status of scsi command and determine whether it is
+ * success, fail, or retriable.
+ *
+ * Return code
+ * 	> 0: should retry
+ * 	= 0: success
+ * 	< 0: fail
+ */
+static int cmd_result(struct scsi_cmnd *scmd)
+{
+	int status;
+
+	status = status_byte(scmd->result);
+
+	switch (scsi_decide_disposition(scmd)) {
+	case FAILED:
+		break;
+	case NEEDS_RETRY:
+	case ADD_TO_MLQUEUE:
+		return 1 /* retry */;
+	case SUCCESS:
+		if (host_byte(scmd->result) == DID_RESET) {
+			Err("scsi_dump: host_byte(scmd->result) set to : DID_RESET");
+			return 1;  /* retry */
+		} else if ((status == CHECK_CONDITION) &&
+			   (scmd->sense_buffer[2] == UNIT_ATTENTION)) {
+			/*
+			 * if we are expecting a cc/ua because of a bus reset
+			 * that we performed, treat this just as a retry.
+			 * otherwise this is information that we should pass up
+			 * to the upper-level driver so that we can deal with
+			 * it there.
+			 */
+			Err("scsi_dump: CHECK_CONDITION and UNIT_ATTENTION");
+			if (scmd->device->expecting_cc_ua) {
+				Err("scsi_dump: expecting_cc_ua is set. setting it to zero");
+				scmd->device->expecting_cc_ua = 0;
+				return 1; /* retry */
+			}
+			/*
+			 * if the device is in the process of becoming ready, we
+			 * should retry.
+			 */
+			if ((scmd->sense_buffer[12] == 0x04) &&
+			    (scmd->sense_buffer[13] == 0x01)) {
+				Err("scsi_dump: device is in the process of becoming ready..");
+				return 1; /* retry */
+			}
+			/*
+			 * if the device is not started, we need to wake
+			 * the error handler to start the motor
+			 */
+			if (scmd->device->allow_restart &&
+			    (scmd->sense_buffer[12] == 0x04) &&
+			    (scmd->sense_buffer[13] == 0x02)) {
+				Err("scsi_dump: the device is not started..");
+				break;
+			}
+		} else if (host_byte(scmd->result) != DID_OK) {
+			Err("csi_dump: ome undefined error");
+			Err("host_byte(scmd->result) : %d", host_byte(scmd->result));
+			break;
+		}
+
+		if (status == GOOD ||
+		    status == CONDITION_GOOD ||
+		    status == INTERMEDIATE_GOOD ||
+		    status == INTERMEDIATE_C_GOOD)
+			return 0;
+		if (status == CHECK_CONDITION &&
+		    scmd->sense_buffer[2] == RECOVERED_ERROR)
+			return 0;
+		break;
+	default:
+		Err("scsi_dump: bad disposition: %d", scmd->result);
+		return -EIO;
+	}
+
+	Err("scsi_dump: command %x failed with 0x%x", scmd->cmnd[0], scmd->result);
+	return -EIO;
+}
+
+static int send_command(struct scsi_cmnd *scmd)
+{
+	struct Scsi_Host *host = scmd->device->host;
+	struct scsi_device *sdev = scmd->device;
+	int ret;
+
+	do {
+		if (!scsi_device_online(sdev)) {
+			Err("scsi_dump: Scsi disk is not online");
+			return -EIO;
+		}
+		if (sdev->changed) {
+			Err("scsi_dump: SCSI disk has been changed. Prohibiting further I/O");
+			return -EIO;
+		}
+
+		spin_lock(host->host_lock);
+		host->hostt->queuecommand(scmd, rw_intr);
+		spin_unlock(host->host_lock);
+
+		while (scmd->done != NULL) {
+			host->hostt->dump_poll(scmd->device);
+			udelay(100);
+			diskdump_update();
+		}
+		scmd->done = rw_intr;
+	} while ((ret = cmd_result(scmd)) > 0);
+
+	return ret;
+}
+
+static int
+scsi_dump_quiesce(struct disk_dump_device *dump_device)
+{
+	struct scsi_device *sdev = dump_device->device;
+	struct Scsi_Host *host = sdev->host;
+
+	if (host->hostt->dump_quiesce)
+		return host->hostt->dump_quiesce(sdev);
+
+	return 0;
+}
+
+static int scsi_dump_rw_block(struct disk_dump_partition *dump_part, int rw,
+			      unsigned long dump_block_nr, void *buf, int len)
+{
+	struct disk_dump_device *dump_device = dump_part->device;
+	struct scsi_device *sdev = dump_device->device;
+	int block_nr = BLOCK_SECTOR(dump_block_nr);
+	int ret;
+
+	ret = init_rw_command(dump_part, sdev, &scsi_dump_cmnd, rw,
+					block_nr, buf, DUMP_BLOCK_SIZE * len);
+	if (ret < 0) {
+		Err("scsi_dump: scsi_dump: init_rw_command failed");
+		return ret;
+	}
+	return send_command(&scsi_dump_cmnd);
+}
+
+static int
+scsi_dump_shutdown(struct disk_dump_device *dump_device)
+{
+	struct scsi_device *sdev = dump_device->device;
+	struct Scsi_Host *host = sdev->host;
+	int ret;
+
+	if (sdev->scsi_level >= SCSI_2) {
+		init_sync_command(sdev, &scsi_dump_cmnd);
+		ret = send_command(&scsi_dump_cmnd);
+		if (ret < 0)
+			Warn("SYNCHRONIZE_CACHE failed.");
+	}
+
+	if (host->hostt->dump_shutdown)
+		return host->hostt->dump_shutdown(sdev);
+
+	return 0;
+}
+
+struct disk_dump_device_ops scsi_dump_device_ops = {
+	.rw_block	= scsi_dump_rw_block,
+	.quiesce	= scsi_dump_quiesce,
+	.shutdown	= scsi_dump_shutdown,
+};
+
+static void *scsi_dump_probe(struct device *dev)
+{
+	struct scsi_device *sdev;
+
+	if ((dev->bus == NULL) || (dev->bus->name == NULL) ||
+	    strncmp(dev->bus->name, "scsi", 4))
+		return NULL;
+
+	sdev = to_scsi_device(dev);
+	if (!sdev->host->hostt->dump_poll)
+		return NULL;
+
+	return sdev;
+}
+
+static int scsi_dump_add_device(struct disk_dump_device *dump_device)
+{
+	struct scsi_device *sdev;
+	int error;
+
+	sdev = dump_device->device;
+	if (!sdev->host->hostt->dump_poll)
+		return -ENOTSUPP;
+
+	if ((error = scsi_device_get(sdev)) != 0)
+		return error;
+
+	memcpy(&dump_device->ops, &scsi_dump_device_ops,
+		sizeof(scsi_dump_device_ops));
+	if (sdev->host->max_sectors) {
+		dump_device->max_blocks =
+			(sdev->sector_size * sdev->host->max_sectors)
+			  >> DUMP_BLOCK_SHIFT;
+	}
+	return 0;
+}
+
+static void scsi_dump_remove_device(struct disk_dump_device *dump_device)
+{
+	struct scsi_device *sdev = dump_device->device;
+
+	scsi_device_put(sdev);
+}
+
+static struct disk_dump_type scsi_dump_type = {
+	.probe		= scsi_dump_probe,
+	.add_device	= scsi_dump_add_device,
+	.remove_device	= scsi_dump_remove_device,
+	.owner		= THIS_MODULE,
+};
+
+static int init_scsi_dump(void)
+{
+	int ret;
+
+	if ((ret = register_disk_dump_type(&scsi_dump_type)) < 0) {
+		Err("scsi_dump: register failed");
+		return ret;
+	}
+	return ret;
+}
+
+static void cleanup_scsi_dump(void)
+{
+	if (unregister_disk_dump_type(&scsi_dump_type) < 0)
+		Err("scsi_dump: unregister failed");
+}
+
+module_init(init_scsi_dump);
+module_exit(cleanup_scsi_dump);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.15/include/asm-alpha/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-alpha/kerntypes.h	2006-02-12 16:58:13.937952154 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-alpha/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* Alpha-specific header files */
+#ifndef _ALPHA_KERNTYPES_H
+#define _ALPHA_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _ALPHA_KERNTYPES_H */
Index: linux-2.6.15/include/asm-arm/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-arm/kerntypes.h	2006-02-12 16:58:13.937952154 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-arm/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* ARM-specific header files */
+#ifndef _ARM_KERNTYPES_H
+#define _ARM_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _ARM_KERNTYPES_H */
Index: linux-2.6.15/include/asm-arm26/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-arm26/kerntypes.h	2006-02-12 16:58:13.937952154 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-arm26/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* ARM26-specific header files */
+#ifndef _ARM26_KERNTYPES_H
+#define _ARM26_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _ARM26_KERNTYPES_H */
Index: linux-2.6.15/include/asm-cris/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-cris/kerntypes.h	2006-02-12 16:58:13.937952154 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-cris/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* CRIS-specific header files */
+#ifndef _CRIS_KERNTYPES_H
+#define _CRIS_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _CRIS_KERNTYPES_H */
Index: linux-2.6.15/include/asm-generic/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-generic/kerntypes.h	2006-02-12 16:58:13.937952154 +0100
@@ -0,0 +1,20 @@
+/*
+ * asm-generic/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* Arch-independent header files */
+#ifndef _GENERIC_KERNTYPES_H
+#define _GENERIC_KERNTYPES_H
+
+#include <linux/pci.h>
+
+#endif /* _GENERIC_KERNTYPES_H */
Index: linux-2.6.15/include/asm-h8300/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-h8300/kerntypes.h	2006-02-12 16:58:13.941952143 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-h8300/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* H8300-specific header files */
+#ifndef _H8300_KERNTYPES_H
+#define _H8300_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _H8300_KERNTYPES_H */
Index: linux-2.6.15/include/asm-i386/dump.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-i386/dump.h	2006-02-12 16:58:13.941952143 +0100
@@ -0,0 +1,92 @@
+/*
+ * Kernel header file for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ *
+ * Copyright 1999 Silicon Graphics, Inc. All rights reserved.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/* This header file holds the architecture specific crash dump header */
+#ifndef _ASM_DUMP_H
+#define _ASM_DUMP_H
+
+/* necessary header files */
+#include <asm/ptrace.h>
+#include <asm/page.h>
+#include <linux/threads.h>
+#include <linux/mm.h>
+
+/* definitions */
+#define DUMP_ASM_MAGIC_NUMBER	0xdeaddeadULL	/* magic number            */
+#define DUMP_ASM_VERSION_NUMBER	0x3	/* version number          */
+
+#define platform_timestamp(x) rdtscll(x)
+
+/*
+ * Structure: __dump_header_asm
+ *  Function: This is the header for architecture-specific stuff.  It
+ *            follows right after the dump header.
+ */
+struct __dump_header_asm {
+	/* the dump magic number -- unique to verify dump is valid */
+	u64		dha_magic_number;
+
+	/* the version number of this dump */
+	u32		dha_version;
+
+	/* the size of this header (in case we can't read it) */
+	u32		dha_header_size;
+
+	/* the esp for i386 systems */
+	u32		dha_esp;
+
+	/* the eip for i386 systems */
+	u32		dha_eip;
+
+	/* the dump registers */
+	struct pt_regs	dha_regs;
+
+	/* smp specific */
+	u32		dha_smp_num_cpus;
+	u32		dha_dumping_cpu;
+	struct pt_regs	dha_smp_regs[NR_CPUS];
+	u32		dha_smp_current_task[NR_CPUS];
+	u32		dha_stack[NR_CPUS];
+	u32		dha_stack_ptr[NR_CPUS];
+} __attribute__((packed));
+
+#ifdef __KERNEL__
+
+extern struct __dump_header_asm dump_header_asm;
+
+#ifdef CONFIG_SMP
+extern cpumask_t irq_affinity[];
+extern int (*dump_ipi_function_ptr)(struct pt_regs *);
+extern void dump_send_ipi(void);
+#else
+#define dump_send_ipi() do { } while(0)
+#endif
+
+static inline void get_current_regs(struct pt_regs *regs)
+{
+	__asm__ __volatile__("movl %%ebx,%0" : "=m"(regs->ebx));
+	__asm__ __volatile__("movl %%ecx,%0" : "=m"(regs->ecx));
+	__asm__ __volatile__("movl %%edx,%0" : "=m"(regs->edx));
+	__asm__ __volatile__("movl %%esi,%0" : "=m"(regs->esi));
+	__asm__ __volatile__("movl %%edi,%0" : "=m"(regs->edi));
+	__asm__ __volatile__("movl %%ebp,%0" : "=m"(regs->ebp));
+	__asm__ __volatile__("movl %%eax,%0" : "=m"(regs->eax));
+	__asm__ __volatile__("movl %%esp,%0" : "=m"(regs->esp));
+	__asm__ __volatile__("movw %%ss, %%ax;" :"=a"(regs->xss));
+	__asm__ __volatile__("movw %%cs, %%ax;" :"=a"(regs->xcs));
+	__asm__ __volatile__("movw %%ds, %%ax;" :"=a"(regs->xds));
+	__asm__ __volatile__("movw %%es, %%ax;" :"=a"(regs->xes));
+	__asm__ __volatile__("pushfl; popl %0" :"=m"(regs->eflags));
+	regs->eip = (unsigned long)current_text_addr();
+}
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_DUMP_H */
Index: linux-2.6.15/include/asm-i386/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-i386/kerntypes.h	2006-02-12 16:58:13.941952143 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-i386/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* ix86-specific header files */
+#ifndef _I386_KERNTYPES_H
+#define _I386_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _I386_KERNTYPES_H */
Index: linux-2.6.15/include/asm-ia64/dump.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-ia64/dump.h	2006-02-12 16:58:13.945952132 +0100
@@ -0,0 +1,206 @@
+/*
+ * Kernel header file for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ *
+ * Copyright 1999 - 2002 Silicon Graphics, Inc. All rights reserved.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/* This header file holds the architecture specific crash dump header */
+#ifndef _ASM_DUMP_H
+#define _ASM_DUMP_H
+
+/* definitions */
+#define DUMP_ASM_MAGIC_NUMBER     0xdeaddeadULL  /* magic number            */
+#define DUMP_ASM_VERSION_NUMBER   0x5            /* version number          */
+
+#define platform_timestamp(x) ({ x = ia64_get_itc(); })
+
+#ifdef __KERNEL__
+#include <linux/efi.h>
+#include <asm/pal.h>
+#include <asm/ptrace.h>
+
+#ifdef CONFIG_SMP
+extern cpumask_t irq_affinity[];
+extern int (*dump_ipi_function_ptr)(struct pt_regs *);
+extern void dump_send_ipi(void);
+#else /* !CONFIG_SMP */
+#define dump_send_ipi() do { } while(0)
+#endif
+
+#else  /* !__KERNEL__ */
+/* necessary header files */
+#include <asm/ptrace.h>                          /* for pt_regs             */
+#include <linux/threads.h>
+#endif /* __KERNEL__ */
+
+/*
+ * mkswap.c calls getpagesize() to get the system page size,
+ * which is not  necessarily the same as the hardware page size.
+ *
+ * For ia64 the kernel PAGE_SIZE can be configured from 4KB ... 16KB.
+ *
+ * The physical memory is layed out out in the hardware/minimal pages.
+ * This is the size we need to use for dumping physical pages.
+ *
+ * Note ths hardware/minimal page size being use in;
+ *      arch/ia64/kernel/efi.c`efi_memmap_walk():
+ *	    curr.end   = curr.start + (md->num_pages << 12);
+ *
+ * Since the system page size could change between the kernel we boot
+ * on the the kernel that cause the core dume we may want to have something
+ * more constant like the maximum system page size (See include/asm-ia64/page.h).
+ */
+/* IA64 manages the stack in differnt manner as compared to other architectures.
+ * task_struct lies at the bottom of stack.
+ */
+#undef STACK_START_POSITION
+#define STACK_START_POSITION(tsk)		(tsk)
+#define DUMP_MIN_PAGE_SHIFT                 	12
+#define DUMP_MIN_PAGE_SIZE                  	(1UL << DUMP_MIN_PAGE_SHIFT)
+#define DUMP_MIN_PAGE_MASK                  	(~(DUMP_MIN_PAGE_SIZE - 1))
+#define DUMP_MIN_PAGE_ALIGN(addr)           	(((addr) + DUMP_MIN_PAGE_SIZE - 1) & DUMP_MIN_PAGE_MASK)
+
+#define DUMP_MAX_PAGE_SHIFT                 	16
+#define DUMP_MAX_PAGE_SIZE                  	(1UL << DUMP_MAX_PAGE_SHIFT)
+#define DUMP_MAX_PAGE_MASK                  	(~(DUMP_MAX_PAGE_SIZE - 1))
+#define DUMP_MAX_PAGE_ALIGN(addr)           	(((addr) + DUMP_MAX_PAGE_SIZE - 1) & DUMP_MAX_PAGE_MASK)
+
+#define DUMP_EF_PAGE_SHIFT			DUMP_MIN_PAGE_SHIFT
+
+extern int _end,_start;
+
+/*
+ * Structure: dump_header_asm_t
+ *  Function: This is the header for architecture-specific stuff.  It
+ *            follows right after the dump header.
+ */
+/*typedef struct _dump_header_asm {*/
+
+typedef struct __dump_header_asm {
+
+        /* the dump magic number -- unique to verify dump is valid */
+        uint64_t             dha_magic_number;
+
+        /* the version number of this dump */
+        uint32_t             dha_version;
+
+        /* the size of this header (in case we can't read it) */
+        uint32_t             dha_header_size;
+
+        /* pointer to pt_regs, (OLD: (struct pt_regs *, NEW: (uint64_t)) */
+	uint64_t             dha_pt_regs;
+
+	/* the dump registers */
+	struct pt_regs       dha_regs;
+
+        /* the rnat register saved after flushrs */
+        uint64_t             dha_rnat;
+
+	/* the pfs register saved after flushrs */
+	uint64_t             dha_pfs;
+
+	/* the bspstore register saved after flushrs */
+	uint64_t             dha_bspstore;
+
+	/* smp specific */
+	uint32_t	     dha_smp_num_cpus;
+	uint32_t	     dha_dumping_cpu;
+	struct pt_regs	     dha_smp_regs[NR_CPUS];
+	uint64_t	     dha_smp_current_task[NR_CPUS];
+	uint64_t	     dha_stack[NR_CPUS];
+	uint64_t	     dha_stack_ptr[NR_CPUS];
+
+	/* load address of kernel */
+        uint64_t             dha_kernel_addr;
+
+} __attribute__((packed)) dump_header_asm_t;
+
+
+extern struct __dump_header_asm dump_header_asm;
+
+#ifdef __KERNEL__
+static inline void get_current_regs(struct pt_regs *regs)
+{
+	/*
+	 * REMIND: Looking at functions/Macros like:
+	 *		 DO_SAVE_SWITCH_STACK
+	 *		 ia64_switch_to()
+	 *		 ia64_save_extra()
+	 *		 switch_to()
+	 *	   to implement this new feature that Matt seem to have added
+	 *	   to panic.c; seems all platforms are now expected to provide
+	 *	   this function to dump the current registers into the pt_regs
+	 *	   structure.
+	 */
+	volatile unsigned long rsc_value;/*for storing the rsc value*/
+	volatile unsigned long ic_value;
+
+	__asm__ __volatile__("mov %0=b6;;":"=r"(regs->b6));
+	__asm__ __volatile__("mov %0=b7;;":"=r"(regs->b7));
+
+        __asm__ __volatile__("mov %0=ar.csd;;":"=r"(regs->ar_csd));
+	__asm__ __volatile__("mov %0=ar.ssd;;":"=r"(regs->ar_ssd));
+	__asm__ __volatile__("mov %0=psr;;":"=r"(ic_value));
+	if(ic_value & 0x1000)/*Within an interrupt*/
+	{
+		__asm__ __volatile__("mov %0=cr.ipsr;;":"=r"(regs->cr_ipsr));
+		__asm__ __volatile__("mov %0=cr.iip;;":"=r"(regs->cr_iip));
+		__asm__ __volatile__("mov %0=cr.ifs;;":"=r"(regs->cr_ifs));
+	}
+	else
+	{
+		regs->cr_ipsr=regs->cr_iip=regs->cr_ifs=(unsigned long)-1;
+	}
+	__asm__ __volatile__("mov %0=ar.unat;;":"=r"(regs->ar_unat));
+	__asm__ __volatile__("mov %0=ar.pfs;;":"=r"(regs->ar_pfs));
+	__asm__ __volatile__("mov %0=ar.rsc;;":"=r"(rsc_value));
+	regs->ar_rsc = rsc_value;
+	/*loadrs is from 16th bit to 29th bit of rsc*/
+	regs->loadrs =  rsc_value >> 16 & (unsigned long)0x3fff;
+	/*setting the rsc.mode value to 0 (rsc.mode is the last two bits of rsc)*/
+	__asm__ __volatile__("mov ar.rsc=%0;;"::"r"(rsc_value & (unsigned long)(~3)));
+	__asm__ __volatile__("mov %0=ar.rnat;;":"=r"(regs->ar_rnat));
+	__asm__ __volatile__("mov %0=ar.bspstore;;":"=r"(regs->ar_bspstore));
+	/*copying the original value back*/
+	__asm__ __volatile__("mov ar.rsc=%0;;"::"r"(rsc_value));
+	__asm__ __volatile__("mov %0=pr;;":"=r"(regs->pr));
+	__asm__ __volatile__("mov %0=ar.fpsr;;":"=r"(regs->ar_fpsr));
+	__asm__ __volatile__("mov %0=ar.ccv;;":"=r"(regs->ar_ccv));
+
+	__asm__ __volatile__("mov %0=r2;;":"=r"(regs->r2));
+        __asm__ __volatile__("mov %0=r3;;":"=r"(regs->r3));
+        __asm__ __volatile__("mov %0=r8;;":"=r"(regs->r8));
+        __asm__ __volatile__("mov %0=r9;;":"=r"(regs->r9));
+        __asm__ __volatile__("mov %0=r10;;":"=r"(regs->r10));
+	__asm__ __volatile__("mov %0=r11;;":"=r"(regs->r11));
+        __asm__ __volatile__("mov %0=r12;;":"=r"(regs->r12));
+	__asm__ __volatile__("mov %0=r13;;":"=r"(regs->r13));
+	__asm__ __volatile__("mov %0=r14;;":"=r"(regs->r14));
+	__asm__ __volatile__("mov %0=r15;;":"=r"(regs->r15));
+	__asm__ __volatile__("mov %0=r16;;":"=r"(regs->r16));
+	__asm__ __volatile__("mov %0=r17;;":"=r"(regs->r17));
+	__asm__ __volatile__("mov %0=r18;;":"=r"(regs->r18));
+	__asm__ __volatile__("mov %0=r19;;":"=r"(regs->r19));
+	__asm__ __volatile__("mov %0=r20;;":"=r"(regs->r20));
+	__asm__ __volatile__("mov %0=r21;;":"=r"(regs->r21));
+	__asm__ __volatile__("mov %0=r22;;":"=r"(regs->r22));
+	__asm__ __volatile__("mov %0=r23;;":"=r"(regs->r23));
+	__asm__ __volatile__("mov %0=r24;;":"=r"(regs->r24));
+	__asm__ __volatile__("mov %0=r25;;":"=r"(regs->r25));
+	__asm__ __volatile__("mov %0=r26;;":"=r"(regs->r26));
+	__asm__ __volatile__("mov %0=r27;;":"=r"(regs->r27));
+	__asm__ __volatile__("mov %0=r28;;":"=r"(regs->r28));
+	__asm__ __volatile__("mov %0=r29;;":"=r"(regs->r29));
+	__asm__ __volatile__("mov %0=r30;;":"=r"(regs->r30));
+	__asm__ __volatile__("mov %0=r31;;":"=r"(regs->r31));
+}
+
+/* Perhaps added to Common Arch Specific Functions and moved to dump.h some day */
+extern void * __dump_memcpy(void *, const void *, size_t);
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_DUMP_H */
Index: linux-2.6.15/include/asm-ia64/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-ia64/kerntypes.h	2006-02-12 16:58:13.945952132 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-ia64/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* IA64-specific header files */
+#ifndef _IA64_KERNTYPES_H
+#define _IA64_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _IA64_KERNTYPES_H */
Index: linux-2.6.15/include/asm-m68k/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-m68k/kerntypes.h	2006-02-12 16:58:13.945952132 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-m68k/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* m68k-specific header files */
+#ifndef _M68K_KERNTYPES_H
+#define _M68K_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _M68K_KERNTYPES_H */
Index: linux-2.6.15/include/asm-m68knommu/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-m68knommu/kerntypes.h	2006-02-12 16:58:13.945952132 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-m68knommu/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* m68k/no-MMU-specific header files */
+#ifndef _M68KNOMMU_KERNTYPES_H
+#define _M68KNOMMU_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _M68KNOMMU_KERNTYPES_H */
Index: linux-2.6.15/include/asm-mips/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-mips/kerntypes.h	2006-02-12 16:58:13.945952132 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-mips/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* MIPS-specific header files */
+#ifndef _MIPS_KERNTYPES_H
+#define _MIPS_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _MIPS_KERNTYPES_H */
Index: linux-2.6.15/include/asm-mips64/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-mips64/kerntypes.h	2006-02-12 16:58:13.945952132 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-mips64/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* MIPS64-specific header files */
+#ifndef _MIPS64_KERNTYPES_H
+#define _MIPS64_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _MIPS64_KERNTYPES_H */
Index: linux-2.6.15/include/asm-parisc/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-parisc/kerntypes.h	2006-02-12 16:58:13.945952132 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-parisc/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* PA-RISC-specific header files */
+#ifndef _PARISC_KERNTYPES_H
+#define _PARISC_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _PARISC_KERNTYPES_H */
Index: linux-2.6.15/include/asm-powerpc/dump.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-powerpc/dump.h	2006-02-12 16:58:13.945952132 +0100
@@ -0,0 +1,117 @@
+/*
+ * Kernel header file for Linux crash dumps.
+ *
+ * Created by: Todd Inglett <tinglett@vnet.ibm.com>
+ *
+ * Copyright 2002 - 2004 International Business Machines
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/* This header file holds the architecture specific crash dump header */
+#ifndef _ASM_DUMP_H
+#define _ASM_DUMP_H
+
+/* necessary header files */
+#include <asm/ptrace.h>                          /* for pt_regs             */
+#include <asm/kmap_types.h>
+#include <linux/threads.h>
+
+/* definitions */
+#define DUMP_ASM_MAGIC_NUMBER     0xdeaddeadULL  /* magic number            */
+#define DUMP_ASM_VERSION_NUMBER   0x5            /* version number          */
+
+#define platform_timestamp(x) (x = get_tb())
+
+/*
+ * Structure: __dump_header_asm
+ *  Function: This is the header for architecture-specific stuff.  It
+ *            follows right after the dump header.
+ */
+struct __dump_header_asm {
+
+        /* the dump magic number -- unique to verify dump is valid */
+        uint64_t             dha_magic_number;
+
+        /* the version number of this dump */
+        uint32_t             dha_version;
+
+        /* the size of this header (in case we can't read it) */
+        uint32_t             dha_header_size;
+
+	/* the dump registers */
+	struct pt_regs       dha_regs;
+
+	/* smp specific */
+	uint32_t	     dha_smp_num_cpus;
+	int		     dha_dumping_cpu;
+	struct pt_regs	     dha_smp_regs[NR_CPUS];
+	uint64_t	     dha_smp_current_task[NR_CPUS];
+	uint64_t	     dha_stack[NR_CPUS];
+	uint64_t     	     dha_stack_ptr[NR_CPUS];
+} __attribute__((packed));
+
+#ifdef __KERNEL__
+static inline void get_current_regs(struct pt_regs *regs)
+{
+	unsigned long tmp1, tmp2;
+
+	__asm__ __volatile__ (
+		"std	0,0(%2)\n"
+		"std	1,8(%2)\n"
+		"std	2,16(%2)\n"
+		"std	3,24(%2)\n"
+		"std	4,32(%2)\n"
+		"std	5,40(%2)\n"
+		"std	6,48(%2)\n"
+		"std	7,56(%2)\n"
+		"std	8,64(%2)\n"
+		"std	9,72(%2)\n"
+		"std	10,80(%2)\n"
+		"std	11,88(%2)\n"
+		"std	12,96(%2)\n"
+		"std	13,104(%2)\n"
+		"std	14,112(%2)\n"
+		"std	15,120(%2)\n"
+		"std	16,128(%2)\n"
+		"std	17,136(%2)\n"
+		"std	18,144(%2)\n"
+		"std	19,152(%2)\n"
+		"std	20,160(%2)\n"
+		"std	21,168(%2)\n"
+		"std	22,176(%2)\n"
+		"std	23,184(%2)\n"
+		"std	24,192(%2)\n"
+		"std	25,200(%2)\n"
+		"std	26,208(%2)\n"
+		"std	27,216(%2)\n"
+		"std	28,224(%2)\n"
+		"std	29,232(%2)\n"
+		"std	30,240(%2)\n"
+		"std	31,248(%2)\n"
+		"mfmsr	%0\n"
+		"std	%0, 264(%2)\n"
+		"mfctr	%0\n"
+		"std	%0, 280(%2)\n"
+		"mflr	%0\n"
+		"std	%0, 288(%2)\n"
+		"bl	1f\n"
+	"1:	 mflr	%1\n"
+		"std	%1, 256(%2)\n"
+		"mtlr	%0\n"
+		"mfxer	%0\n"
+		"std	%0, 296(%2)\n"
+		: "=&r" (tmp1), "=&r" (tmp2)
+		: "b" (regs));
+}
+
+extern struct __dump_header_asm dump_header_asm;
+
+#ifdef CONFIG_SMP
+extern void dump_send_ipi(int (*dump_ipi_callback)(struct pt_regs *));
+#else
+#define dump_send_ipi() do { } while(0)
+#endif
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_DUMP_H */
Index: linux-2.6.15/include/asm-powerpc/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-powerpc/kerntypes.h	2006-02-12 16:58:13.945952132 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-ppc64/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* PPC64-specific header files */
+#ifndef _PPC64_KERNTYPES_H
+#define _PPC64_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _PPC64_KERNTYPES_H */
Index: linux-2.6.15/include/asm-ppc/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-ppc/kerntypes.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-ppc/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* PowerPC-specific header files */
+#ifndef _PPC_KERNTYPES_H
+#define _PPC_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _PPC_KERNTYPES_H */
Index: linux-2.6.15/include/asm-s390/dump.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-s390/dump.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,12 @@
+/*
+ * Kernel header file for Linux crash dumps.
+ */
+
+/* Nothing to be done here, we have proper hardware support */
+#ifndef _ASM_DUMP_H
+#define _ASM_DUMP_H
+
+#define platform_timestamp(x) do { (x) = 0; } while (0)
+
+#endif
+
Index: linux-2.6.15/include/asm-s390/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-s390/kerntypes.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,46 @@
+/*
+ * asm-s390/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* S/390 specific header files */
+#ifndef _S390_KERNTYPES_H
+#define _S390_KERNTYPES_H
+
+#include <asm/lowcore.h>
+#include <asm/debug.h>
+#include <asm/ccwdev.h>
+#include <asm/ccwgroup.h>
+#include <asm/qdio.h>
+
+/* channel subsystem driver */
+#include "../../drivers/s390/cio/cio.h"
+#include "../../drivers/s390/cio/chsc.h"
+#include "../../drivers/s390/cio/css.h"
+#include "../../drivers/s390/cio/device.h"
+#include "../../drivers/s390/cio/qdio.h"
+
+/* dasd device driver */
+#include "../../drivers/s390/block/dasd_int.h"
+#include "../../drivers/s390/block/dasd_diag.h"
+#include "../../drivers/s390/block/dasd_eckd.h"
+#include "../../drivers/s390/block/dasd_fba.h"
+
+/* networking drivers */
+#include "../../drivers/s390/net/fsm.h"
+#include "../../drivers/s390/net/iucv.h"
+#include "../../drivers/s390/net/lcs.h"
+
+/* zfcp device driver */
+#include "../../drivers/s390/scsi/zfcp_def.h"
+#include "../../drivers/s390/scsi/zfcp_fsf.h"
+
+#endif /* _S390_KERNTYPES_H */
Index: linux-2.6.15/include/asm-sh/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-sh/kerntypes.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-sh/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* Super-H-specific header files */
+#ifndef _SH_KERNTYPES_H
+#define _SH_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _SH_KERNTYPES_H */
Index: linux-2.6.15/include/asm-sparc/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-sparc/kerntypes.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-sparc/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* SPARC-specific header files */
+#ifndef _SPARC_KERNTYPES_H
+#define _SPARC_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _SPARC_KERNTYPES_H */
Index: linux-2.6.15/include/asm-sparc64/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-sparc64/kerntypes.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-sparc64/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* SPARC64-specific header files */
+#ifndef _SPARC64_KERNTYPES_H
+#define _SPARC64_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _SPARC64_KERNTYPES_H */
Index: linux-2.6.15/include/asm-um/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-um/kerntypes.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-um/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* Usermode-Linux-specific header files */
+#ifndef _UM_KERNTYPES_H
+#define _UM_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _UM_KERNTYPES_H */
Index: linux-2.6.15/include/asm-v850/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-v850/kerntypes.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-v850/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* V850-specific header files */
+#ifndef _V850_KERNTYPES_H
+#define _V850_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _V850_KERNTYPES_H */
Index: linux-2.6.15/include/asm-x86_64/dump.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-x86_64/dump.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,94 @@
+/*
+ * Kernel header file for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ *
+ * Copyright 1999 Silicon Graphics, Inc. All rights reserved.
+ * x86_64 lkcd port Sachin Sant ( sachinp@in.ibm.com)
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/* This header file holds the architecture specific crash dump header */
+#ifndef _ASM_DUMP_H
+#define _ASM_DUMP_H
+
+/* necessary header files */
+#include <asm/ptrace.h>                          /* for pt_regs             */
+#include <linux/threads.h>
+
+/* definitions */
+#define DUMP_ASM_MAGIC_NUMBER     0xdeaddeadULL  /* magic number            */
+#define DUMP_ASM_VERSION_NUMBER   0x2            /* version number          */
+
+#define platform_timestamp(x) rdtscll(x)
+
+/*
+ * Structure: dump_header_asm_t
+ *  Function: This is the header for architecture-specific stuff.  It
+ *            follows right after the dump header.
+ */
+struct __dump_header_asm {
+
+        /* the dump magic number -- unique to verify dump is valid */
+        uint64_t             dha_magic_number;
+
+        /* the version number of this dump */
+        uint32_t             dha_version;
+
+        /* the size of this header (in case we can't read it) */
+        uint32_t             dha_header_size;
+
+	/* the dump registers */
+	struct pt_regs       dha_regs;
+
+	/* smp specific */
+	uint32_t	     dha_smp_num_cpus;
+	int		     dha_dumping_cpu;
+	struct pt_regs	     dha_smp_regs[NR_CPUS];
+	uint64_t	     dha_smp_current_task[NR_CPUS];
+	uint64_t	     dha_stack[NR_CPUS];
+	uint64_t	     dha_stack_ptr[NR_CPUS];
+} __attribute__((packed));
+
+#ifdef __KERNEL__
+static inline void get_current_regs(struct pt_regs *regs)
+{
+	unsigned seg;
+	__asm__ __volatile__("movq %%r15,%0" : "=m"(regs->r15));
+	__asm__ __volatile__("movq %%r14,%0" : "=m"(regs->r14));
+	__asm__ __volatile__("movq %%r13,%0" : "=m"(regs->r13));
+	__asm__ __volatile__("movq %%r12,%0" : "=m"(regs->r12));
+	__asm__ __volatile__("movq %%r11,%0" : "=m"(regs->r11));
+	__asm__ __volatile__("movq %%r10,%0" : "=m"(regs->r10));
+	__asm__ __volatile__("movq %%r9,%0" : "=m"(regs->r9));
+	__asm__ __volatile__("movq %%r8,%0" : "=m"(regs->r8));
+	__asm__ __volatile__("movq %%rbx,%0" : "=m"(regs->rbx));
+	__asm__ __volatile__("movq %%rcx,%0" : "=m"(regs->rcx));
+	__asm__ __volatile__("movq %%rdx,%0" : "=m"(regs->rdx));
+	__asm__ __volatile__("movq %%rsi,%0" : "=m"(regs->rsi));
+	__asm__ __volatile__("movq %%rdi,%0" : "=m"(regs->rdi));
+	__asm__ __volatile__("movq %%rbp,%0" : "=m"(regs->rbp));
+	__asm__ __volatile__("movq %%rax,%0" : "=m"(regs->rax));
+	__asm__ __volatile__("movq %%rsp,%0" : "=m"(regs->rsp));
+	__asm__ __volatile__("movl %%ss, %0" :"=r"(seg));
+	regs->ss = (unsigned long)seg;
+	__asm__ __volatile__("movl %%cs, %0" :"=r"(seg));
+	regs->cs = (unsigned long)seg;
+	__asm__ __volatile__("pushfq; popq %0" :"=m"(regs->eflags));
+	regs->rip = (unsigned long)current_text_addr();
+
+}
+
+extern volatile int dump_in_progress;
+extern struct __dump_header_asm dump_header_asm;
+
+#ifdef CONFIG_SMP
+
+
+extern void dump_send_ipi(void);
+#else
+#define dump_send_ipi() do { } while(0)
+#endif
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_DUMP_H */
Index: linux-2.6.15/include/asm-x86_64/kerntypes.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/asm-x86_64/kerntypes.h	2006-02-12 16:58:13.949952122 +0100
@@ -0,0 +1,21 @@
+/*
+ * asm-x86_64/kerntypes.h
+ *
+ * Arch-dependent header file that includes headers for all arch-specific
+ * types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under the GNU GPL.
+ */
+
+/* x86_64-specific header files */
+#ifndef _X86_64_KERNTYPES_H
+#define _X86_64_KERNTYPES_H
+
+/* Use the default */
+#include <asm-generic/kerntypes.h>
+
+#endif /* _X86_64_KERNTYPES_H */
Index: linux-2.6.15/include/linux/diskdump.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/linux/diskdump.h	2006-02-12 16:58:13.953952111 +0100
@@ -0,0 +1,103 @@
+#ifndef _LINUX_DISKDUMP_H
+#define _LINUX_DISKDUMP_H
+
+/*
+ * linux/include/linux/diskdump.h
+ *
+ * Copyright (c) 2004 FUJITSU LIMITED
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/list.h>
+#include <linux/blkdev.h>
+#include <linux/utsname.h>
+#include <linux/device.h>
+#include <linux/nmi.h>
+#include <linux/dump.h>
+
+/* The minimum dump I/O unit.  Must be the same as PAGE_SIZE. */
+#define DUMP_BLOCK_SIZE		PAGE_SIZE
+#define DUMP_BLOCK_SHIFT	PAGE_SHIFT
+
+#define pr_err(fmt,arg...) \
+	printk(KERN_ERR fmt,##arg)
+
+#define pr_warn(fmt,arg...) \
+	printk(KERN_WARNING fmt,##arg)
+
+#if defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
+#define lkcd_dump_mode()       unlikely(dump_polling_oncpu)
+#else
+#define lkcd_dump_mode()	0
+#endif
+
+extern unsigned long dump_polling_oncpu;
+
+
+struct disk_dump_partition;
+struct disk_dump_device;
+
+struct disk_dump_type {
+	void *(*probe)(struct device *);
+	int (*add_device)(struct disk_dump_device *);
+	void (*remove_device)(struct disk_dump_device *);
+	struct module *owner;
+	struct list_head list;
+};
+
+struct disk_dump_device_ops {
+	int (*quiesce)(struct disk_dump_device *);
+	int (*shutdown)(struct disk_dump_device *);
+	int (*rw_block)(struct disk_dump_partition *, int rw, unsigned long block_nr, void *buf, int len);
+};
+
+struct disk_dump_device {
+	struct disk_dump_device_ops ops;
+	struct disk_dump_type *dump_type;
+	void *device;
+	unsigned int max_blocks;
+};
+
+struct disk_dump_partition {
+	struct disk_dump_device *device;
+	struct block_device *bdev;
+	unsigned long start_sect;
+	unsigned long nr_sects;
+};
+
+int register_disk_dump_type(struct disk_dump_type *);
+int unregister_disk_dump_type(struct disk_dump_type *);
+
+void diskdump_update(void);
+
+#define diskdump_mdelay(n) 						\
+({									\
+	unsigned long __ms=(n); 					\
+	while (__ms--) {						\
+		udelay(1000);						\
+		touch_nmi_watchdog();					\
+	}								\
+})
+
+extern enum disk_dump_states {
+	DISK_DUMP_INITIAL,
+	DISK_DUMP_RUNNING,
+	DISK_DUMP_SUCCESS,
+	DISK_DUMP_FAILURE,
+}  disk_dump_state;
+
+#endif /* _LINUX_DISKDUMP_H */
Index: linux-2.6.15/include/linux/dump.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/linux/dump.h	2006-02-12 17:02:35.000000000 +0100
@@ -0,0 +1,443 @@
+/*
+ * Kernel header file for Linux crash dumps.
+ *
+ * Created by: Matt Robinson (yakker@sgi.com)
+ * Copyright 1999 - 2002 Silicon Graphics, Inc. All rights reserved.
+ *
+ * vmdump.h to dump.h by: Matt D. Robinson (yakker@sourceforge.net)
+ * Copyright 2001 - 2002 Matt D. Robinson.  All rights reserved.
+ * Copyright (C) 2002 Free Software Foundation, Inc. All rights reserved.
+ *
+ * Most of this is the same old stuff from vmdump.h, except now we're
+ * actually a stand-alone driver plugged into the block layer interface,
+ * with the exception that we now allow for compression modes externally
+ * loaded (e.g., someone can come up with their own).
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+/* This header file includes all structure definitions for crash dumps. */
+#ifndef _DUMP_H
+#define _DUMP_H
+
+#if defined(CONFIG_LKCD_DUMP) || defined (CONFIG_LKCD_DUMP_MODULE)
+
+#include <linux/list.h>
+#include <linux/notifier.h>
+#include <linux/dumpdev.h>
+#include <asm/ioctl.h>
+#include <linux/autoconf.h>
+
+/*
+ * Predefine default DUMP_PAGE constants, asm header may override.
+ *
+ * On ia64 discontinuous memory systems it's possible for the memory
+ * banks to stop at 2**12 page alignments, the smallest possible page
+ * size. But the system page size, PAGE_SIZE, is in fact larger.
+ */
+#define DUMP_PAGE_SHIFT 	PAGE_SHIFT
+#define DUMP_PAGE_MASK		PAGE_MASK
+#define DUMP_PAGE_ALIGN(addr)	PAGE_ALIGN(addr)
+
+/*
+ * Dump offset changed from 4Kb to 64Kb to support multiple PAGE_SIZE
+ * (kernel page size). Assumption goes that 64K is the highest page size
+ * supported
+ */
+
+#define DUMP_HEADER_OFFSET	(1ULL << 16)
+
+#define OLDMINORBITS	8
+#define OLDMINORMASK	((1U << OLDMINORBITS) -1)
+
+/* Making DUMP_PAGE_SIZE = PAGE_SIZE, to support dumping on architectures
+ * which support page sizes (PAGE_SIZE) greater than 4KB.
+ * Will it affect ia64 discontinuous memory systems ????
+ */
+#define DUMP_PAGE_SIZE		PAGE_SIZE
+
+/* thread_info lies at the bottom of stack, (Except IA64). */
+#define STACK_START_POSITION(tsk)               (tsk->thread_info)
+/*
+ * Predefined default memcpy() to use when copying memory to the dump buffer.
+ *
+ * On ia64 there is a heads up function that can be called to let the prom
+ * machine check monitor know that the current activity is risky and it should
+ * ignore the fault (nofault). In this case the ia64 header will redefine this
+ * macro to __dump_memcpy() and use it's arch specific version.
+ */
+#define DUMP_memcpy		memcpy
+#define bzero(a,b)              memset(a, 0, b)
+
+/* necessary header files */
+#include <asm/dump.h>			/* for architecture-specific header */
+
+/*
+ * Size of the buffer that's used to hold:
+ *
+ *	1. the dump header (padded to fill the complete buffer)
+ *	2. the possibly compressed page headers and data
+ *
+ *  = 256k for page size >= 64k
+ *  = 64k  for page size < 64k
+ *  If DUMP_BUFFER_SIZE_MIN (defined in drivers/dump/Makefile) is larger than
+ *  DUMP_BUFFER_SIZE then use DUMP_BUFFER_SIZE_MIN instead.
+ */
+
+#ifdef CONFIG_NR_CPUS
+  #define CONFIG_NR__CPUS CONFIG_NR_CPUS
+#elif CONFIG_SMP
+  #define CONFIG_NR__CPUS (32)
+#else
+  #define CONFIG_NR__CPUS (1)
+#endif
+
+#ifdef CONFIG_IA64
+#ifdef CONFIG_IA64_PAGE_SIZE_8KB
+  #define  CONFIG_PAGESIZE  (8 * 1024)
+#elif CONFIG_IA64_PAGE_SIZE_16KB
+  #define  CONFIG_PAGESIZE  (16 * 1024)
+#elif CONFIG_IA64_PAGE_SIZE_64KB
+  #define  CONFIG_PAGESIZE  (64 * 1024)
+#endif
+#else
+  #define  CONFIG_PAGESIZE  (4 * 1024)
+#endif
+
+// ia64 asm header needs ~160 bytes + sizeof(struct pt_regs) per cpu.  Call it
+// 900 bytes to be safe.
+#define DUMP_BUFFER_SIZE_MIN (((CONFIG_NR__CPUS*900+CONFIG_PAGESIZE-1)/CONFIG_PAGESIZE)*CONFIG_PAGESIZE)
+
+
+#if (PAGE_SHIFT >= 16)
+#undef	DUMP_BUFFER_SIZE
+#define DUMP_BUFFER_SIZE	(256 * 1024)  /* size of dump buffer         */
+#else
+#define DUMP_BUFFER_SIZE	(64 * 1024)  /* size of dump buffer         */
+#endif
+#if DUMP_BUFFER_SIZE < DUMP_BUFFER_SIZE_MIN
+#undef	DUMP_BUFFER_SIZE
+#define	DUMP_BUFFER_SIZE DUMP_BUFFER_SIZE_MIN
+#endif
+
+#define DUMP_HEADER_SIZE	DUMP_BUFFER_SIZE
+
+/* standard header definitions */
+#define DUMP_MAGIC_NUMBER	0xa8190173618f23edULL  /* dump magic number */
+#define DUMP_MAGIC_LIVE		0xa8190173618f23cdULL  /* live magic number */
+#define DUMP_VERSION_NUMBER	0x9	/* dump version number              */
+#define DUMP_PANIC_LEN		0x100	/* dump panic string length         */
+
+/* dump levels - type specific stuff added later -- add as necessary */
+#define DUMP_LEVEL_NONE		0x0	/* no dumping at all -- just bail   */
+#define DUMP_LEVEL_HEADER	0x1	/* kernel dump header only          */
+#define DUMP_LEVEL_KERN		0x2	/* dump header and kernel pages     */
+#define DUMP_LEVEL_USED		0x4	/* dump header, kernel/user pages   */
+#define DUMP_LEVEL_ALL_RAM	0x8	/* dump header, all RAM pages       */
+#define DUMP_LEVEL_ALL		0x10	/* dump all memory RAM and firmware */
+
+
+/* dump compression options -- add as necessary */
+#define DUMP_COMPRESS_NONE	0x0	/* don't compress this dump         */
+#define DUMP_COMPRESS_RLE	0x1	/* use RLE compression              */
+#define DUMP_COMPRESS_GZIP	0x2	/* use GZIP compression             */
+
+/* dump types -- add as necessary */
+#define DUMP_TYPE_BLOCKDEV	0x1	/* disk based dump    */
+#define DUMP_TYPE_NETDEV	0x2	/* network based dump */
+#define DUMP_TYPE_RELOAD	0x9	/* reload the current dump type*/
+
+/* dump header flags -- add as necessary */
+#define DUMP_DH_FLAGS_NONE	0x0	/* no flags set (error condition!)  */
+#define DUMP_DH_RAW		0x1	/* raw page (no compression)        */
+#define DUMP_DH_COMPRESSED	0x2	/* page is compressed               */
+#define DUMP_DH_END		0x4	/* end marker on a full dump        */
+#define DUMP_DH_TRUNCATED	0x8	/* dump is incomplete               */
+#define DUMP_DH_TEST_PATTERN	0x10	/* dump page is a test pattern      */
+#define DUMP_DH_NOT_USED	0x20	/* 1st bit not used in flags        */
+
+/* names for various dump parameters in /proc/kernel */
+#define DUMP_ROOT_NAME		"sys/dump"
+#define DUMP_DEVICE_NAME	"device"
+#define DUMP_COMPRESS_NAME	"compress"
+#define DUMP_LEVEL_NAME		"level"
+#define DUMP_FLAGS_NAME		"flags"
+#define DUMP_ADDR_NAME		"addr"
+
+#define DUMP_SYSRQ_KEY		'd'	/* key to use for MAGIC_SYSRQ key   */
+
+/* CTL_DUMP names: */
+enum
+{
+	CTL_DUMP_DEVICE=1,
+	CTL_DUMP_COMPRESS=3,
+	CTL_DUMP_LEVEL=3,
+	CTL_DUMP_FLAGS=4,
+	CTL_DUMP_ADDR=5,
+	CTL_DUMP_TEST=6,
+};
+
+
+/* page size for gzip compression -- buffered slightly beyond hardware PAGE_SIZE used by DUMP */
+#define DUMP_DPC_PAGE_SIZE	(DUMP_PAGE_SIZE + 512)
+
+/* dump ioctl() control options */
+#define DIOSDUMPDEV     _IOW('p', 0xA0, unsigned int)  /* set the dump device              */
+#define DIOGDUMPDEV     _IOR('p', 0xA1, unsigned int)  /* get the dump device              */
+#define DIOSDUMPLEVEL   _IOW('p', 0xA2, unsigned int)  /* set the dump level               */
+#define DIOGDUMPLEVEL   _IOR('p', 0xA3, unsigned int)  /* get the dump level               */
+#define DIOSDUMPFLAGS   _IOW('p', 0xA4, unsigned int)  /* set the dump flag parameters     */
+#define DIOGDUMPFLAGS   _IOR('p', 0xA5, unsigned int)  /* get the dump flag parameters     */
+#define DIOSDUMPCOMPRESS _IOW('p', 0xA6, unsigned int) /* set the dump compress level      */
+#define DIOGDUMPCOMPRESS _IOR('p', 0xA7, unsigned int) /* get the dump compress level      */
+
+/* these ioctls are used only by netdump module */
+#define DIOSTARGETIP    _IOW('p', 0xA8, unsigned int)  /* set the target m/c's ip           */
+#define DIOGTARGETIP    _IOR('p', 0xA9, unsigned int)  /* get the target m/c's ip           */
+#define DIOSTARGETPORT  _IOW('p', 0xAA, unsigned int) /* set the target m/c's port          */
+#define DIOGTARGETPORT  _IOR('p', 0xAB, unsigned int) /* get the target m/c's port          */
+#define DIOSSOURCEPORT  _IOW('p', 0xAC, unsigned int) /* set the source m/c's port          */
+#define DIOGSOURCEPORT  _IOR('p', 0xAD, unsigned int) /* get the source m/c's port          */
+#define DIOSETHADDR     _IOW('p', 0xAE, unsigned int) /* set ethernet address      */
+#define DIOGETHADDR     _IOR('p', 0xAF, unsigned int) /* get ethernet address       */
+#define DIOGDUMPOKAY	_IOR('p', 0xB0, unsigned int) /* check if dump is configured      */
+#define DIOSDUMPTAKE    _IOW('p', 0xB1, unsigned int) /* Take a manual dump               */
+#define DIOGKERNELADDR	_IOR('p', 0xB2, unsigned int) /* get the physical kernel load address */
+
+/*
+ * Structure: __dump_header
+ *  Function: This is the header dumped at the top of every valid crash
+ *            dump.
+ */
+struct __dump_header {
+	/* the dump magic number -- unique to verify dump is valid */
+	u64	dh_magic_number;
+
+	/* the version number of this dump */
+	u32	dh_version;
+
+	/* the size of this header (in case we can't read it) */
+	u32	dh_header_size;
+
+	/* the level of this dump (just a header?) */
+	u32	dh_dump_level;
+
+	/*
+	 * We assume dump_page_size to be 4K in every case.
+	 * Store here the configurable system page size (4K, 8K, 16K, etc.)
+	 */
+	u32	dh_page_size;
+
+	/* the size of all physical memory */
+	u64	dh_memory_size;
+
+	/* the start of physical memory */
+	u64	dh_memory_start;
+
+	/* the end of physical memory */
+	u64	dh_memory_end;
+
+	/* the number of hardware/physical pages in this dump specifically */
+	u32	dh_num_dump_pages;
+
+	/* the panic string, if available */
+	char	dh_panic_string[DUMP_PANIC_LEN];
+
+	/* timeval depends on architecture, two long values */
+	struct {
+		u64 tv_sec;
+		u64 tv_usec;
+	} dh_time; /* the time of the system crash */
+
+	/* the NEW utsname (uname) information -- in character form */
+	/* we do this so we don't have to include utsname.h         */
+	/* plus it helps us be more architecture independent        */
+	/* now maybe one day soon they'll make the [65] a #define!  */
+	char	dh_utsname_sysname[65];
+	char	dh_utsname_nodename[65];
+	char	dh_utsname_release[65];
+	char	dh_utsname_version[65];
+	char	dh_utsname_machine[65];
+	char	dh_utsname_domainname[65];
+
+	/* the address of current task (OLD = void *, NEW = u64) */
+	u64	dh_current_task;
+
+	/* what type of compression we're using in this dump (if any) */
+	u32	dh_dump_compress;
+
+	/* polling */
+	u32	dh_dump_polling;
+
+	/* any additional flags */
+	u32	dh_dump_device;
+
+	/* size of dump buffer */
+	u64	dh_dump_buffer_size;
+} __attribute__((packed));
+
+/*
+ * Structure: __dump_page
+ *  Function: To act as the header associated to each physical page of
+ *            memory saved in the system crash dump.  This allows for
+ *            easy reassembly of each crash dump page.  The address bits
+ *            are split to make things easier for 64-bit/32-bit system
+ *            conversions.
+ *
+ * dp_byte_offset and dp_page_index are landmarks that are helpful when
+ * looking at a hex dump of /dev/vmdump,
+ */
+struct __dump_page {
+	/* the address of this dump page */
+	u64	dp_address;
+
+	/* the size of this dump page */
+	u32	dp_size;
+
+	/* flags (currently DUMP_COMPRESSED, DUMP_RAW or DUMP_END) */
+	u32	dp_flags;
+} __attribute__((packed));
+
+/*
+ * Structure: __lkcdinfo
+ * Function:  This structure contains information needed for the lkcdutils
+ *            package (particularly lcrash) to determine what information is
+ *            associated to this kernel, specifically.
+ */
+struct __lkcdinfo {
+	int	arch;
+	int	ptrsz;
+	int	byte_order;
+	int	linux_release;
+	int	page_shift;
+	int	page_size;
+	u64	page_mask;
+	u64	page_offset;
+	int	stack_offset;
+};
+
+#ifdef __KERNEL__
+
+/*
+ * Structure: __dump_compress
+ *  Function: This is what an individual compression mechanism can use
+ *            to plug in their own compression techniques.  It's always
+ *            best to build these as individual modules so that people
+ *            can put in whatever they want.
+ */
+struct __dump_compress {
+	/* the list_head structure for list storage */
+	struct list_head list;
+
+	/* the type of compression to use (DUMP_COMPRESS_XXX) */
+	int compress_type;
+	const char *compress_name;
+
+	/* the compression function to call */
+	u32 (*compress_func)(const u8 *, u32, u8 *, u32, unsigned long);
+};
+
+/* functions for dump compression registration */
+extern void dump_register_compression(struct __dump_compress *);
+extern void dump_unregister_compression(int);
+
+extern int dump_compress_level;
+
+/*
+ * Structure dump_mbank[]:
+ *
+ * For CONFIG_DISCONTIGMEM systems this array specifies the
+ * memory banks/chunks that need to be dumped after a panic.
+ *
+ * For classic systems it specifies a single set of pages from
+ * 0 to max_mapnr.
+ */
+struct __dump_mbank {
+	u64 	start;
+	u64 	end;
+	int	type;
+	int	pad1;
+	long	pad2;
+};
+
+#define DUMP_MBANK_TYPE_CONVENTIONAL_MEMORY		1
+#define DUMP_MBANK_TYPE_OTHER				2
+
+#define MAXCHUNKS 256
+extern int dump_mbanks;
+extern struct __dump_mbank dump_mbank[MAXCHUNKS];
+
+/* notification event codes */
+#define DUMP_BEGIN		0x0001	/* dump beginning */
+#define DUMP_END		0x0002	/* dump ending */
+
+/* Scheduler soft spin control.
+ *
+ * 0 - no dump in progress
+ * 1 - cpu0 is dumping, ...
+ */
+extern unsigned long dump_oncpu;
+extern void dump_execute(const char *, const struct pt_regs *);
+
+/*
+ *	Notifier list for kernel code which wants to be called
+ *	at kernel dump.
+ */
+extern struct notifier_block *dump_notifier_list;
+static inline int register_dump_notifier(struct notifier_block *nb)
+{
+	return notifier_chain_register(&dump_notifier_list, nb);
+}
+static inline int unregister_dump_notifier(struct notifier_block * nb)
+{
+	return notifier_chain_unregister(&dump_notifier_list, nb);
+}
+
+extern void (*dump_function_ptr)(const char *, const struct pt_regs *);
+static inline void dump(char * str, struct pt_regs * regs)
+{
+	if (dump_function_ptr)
+		dump_function_ptr(str, regs);
+}
+
+/*
+ * Common Arch Specific Functions should be declared here.
+ * This allows the C compiler to detect discrepancies.
+ */
+extern void	__dump_open(void);
+extern void	__dump_cleanup(void);
+extern void	__dump_clean_irq_state(void);
+extern void	__dump_init(u64);
+extern void	__dump_save_regs(struct pt_regs *, const struct pt_regs *);
+extern void	__dump_save_context(int cpu, const struct pt_regs *, struct task_struct *tsk);
+extern int	__dump_configure_header(const struct pt_regs *);
+extern int	__dump_irq_enable(void);
+extern void	__dump_irq_restore(void);
+extern int	__dump_page_valid(unsigned long index);
+#ifdef CONFIG_SMP
+extern void 	__dump_save_other_cpus(void);
+#else
+#define 	__dump_save_other_cpus()
+#endif
+extern unsigned long __dump_kernel_addr(void);
+
+extern int manual_handle_crashdump(void);
+
+/* to track all used (compound + zero order) pages */
+#define PageInuse(p)   (PageCompound(p) || page_count(p))
+
+#endif /* __KERNEL__ */
+
+#else	/* !CONFIG_LKCD_DUMP */
+
+/* If not configured then make code disappear! */
+#define register_dump_watchdog(x) 	do { } while(0)
+#define unregister_dump_watchdog(x) 	do { } while(0)
+#define register_dump_notifier(x)	do { } while(0)
+#define unregister_dump_notifier(x)	do { } while(0)
+#define dump_in_progress() 		0
+#define dump(x, y)			do { } while(0)
+
+#endif	/* !CONFIG_LKCD_DUMP */
+
+#endif /* _DUMP_H */
Index: linux-2.6.15/include/linux/dump_netdev.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/linux/dump_netdev.h	2006-02-12 16:58:13.953952111 +0100
@@ -0,0 +1,80 @@
+/*
+ *  linux/drivers/net/netconsole.h
+ *
+ *  Copyright (C) 2001  Ingo Molnar <mingo@redhat.com>
+ *
+ *  This file contains the implementation of an IRQ-safe, crash-safe
+ *  kernel console implementation that outputs kernel messages to the
+ *  network.
+ *
+ * Modification history:
+ *
+ * 2001-09-17    started by Ingo Molnar.
+ */
+
+/****************************************************************
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2, or (at your option)
+ *      any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ ****************************************************************/
+
+#define NETCONSOLE_VERSION 0x03
+
+enum netdump_commands {
+	COMM_NONE = 0,
+	COMM_SEND_MEM = 1,
+	COMM_EXIT = 2,
+	COMM_REBOOT = 3,
+	COMM_HELLO = 4,
+	COMM_GET_NR_PAGES = 5,
+	COMM_GET_PAGE_SIZE = 6,
+	COMM_START_NETDUMP_ACK = 7,
+	COMM_GET_REGS = 8,
+	COMM_GET_MAGIC = 9,
+	COMM_START_WRITE_NETDUMP_ACK = 10,
+};
+
+typedef struct netdump_req_s {
+	u64 magic;
+	u32 nr;
+	u32 command;
+	u32 from;
+	u32 to;
+} req_t;
+
+enum netdump_replies {
+	REPLY_NONE = 0,
+	REPLY_ERROR = 1,
+	REPLY_LOG = 2,
+	REPLY_MEM = 3,
+	REPLY_RESERVED = 4,
+	REPLY_HELLO = 5,
+	REPLY_NR_PAGES = 6,
+	REPLY_PAGE_SIZE = 7,
+	REPLY_START_NETDUMP = 8,
+	REPLY_END_NETDUMP = 9,
+	REPLY_REGS = 10,
+	REPLY_MAGIC = 11,
+	REPLY_START_WRITE_NETDUMP = 12,
+};
+
+typedef struct netdump_reply_s {
+	u32 nr;
+	u32 code;
+	u32 info;
+} reply_t;
+
+#define HEADER_LEN (1 + sizeof(reply_t))
+
+
Index: linux-2.6.15/include/linux/dumpdev.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/include/linux/dumpdev.h	2006-02-12 16:58:13.953952111 +0100
@@ -0,0 +1,167 @@
+/*
+ * Generic dump device interfaces for flexible system dump
+ * (Enables variation of dump target types e.g disk, network, memory)
+ *
+ * These interfaces have evolved based on discussions on lkcd-devel.
+ * Eventually the intent is to support primary and secondary or
+ * alternate targets registered at the same time, with scope for
+ * situation based failover or multiple dump devices used for parallel
+ * dump i/o.
+ *
+ * Started: Oct 2002 - Suparna Bhattacharya (suparna@in.ibm.com)
+ *
+ * Copyright (C) 2001 - 2002 Matt D. Robinson.  All rights reserved.
+ * Copyright (C) 2002 International Business Machines Corp.
+ *
+ * This code is released under version 2 of the GNU GPL.
+ */
+
+#ifndef _LINUX_DUMPDEV_H
+#define _LINUX_DUMPDEV_H
+
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/netpoll.h>
+#include <linux/bio.h>
+
+/* Determined by the dump target (device) type */
+
+struct dump_dev_driver {
+	struct kobject kobj;
+};
+
+struct dump_dev;
+
+struct dump_dev_ops {
+	int (*open)(struct dump_dev *, const char *); /* configure */
+	int (*release)(struct dump_dev *); /* unconfigure */
+	int (*silence)(struct dump_dev *); /* when dump starts */
+	int (*resume)(struct dump_dev *); /* when dump is over */
+	int (*seek)(struct dump_dev *, loff_t);
+	/* trigger a write (async in nature typically) */
+	int (*write)(struct dump_dev *, void *, unsigned long);
+	/* not usually used during dump, but option available */
+	int (*read)(struct dump_dev *, void *, unsigned long);
+	/* use to poll for completion */
+	int (*ready)(struct dump_dev *, void *);
+	int (*ioctl)(struct dump_dev *, unsigned int, unsigned long);
+};
+
+struct dump_dev {
+	int type; /* 1 = blockdev, 2 = netdev */
+	unsigned long device_id; /* interpreted differently for various types */
+	struct dump_dev_ops *ops;
+	struct list_head list;
+	loff_t curr_offset;
+	struct netpoll np;
+};
+
+/*
+ * dump_dev type variations:
+ */
+
+/* block */
+struct dump_blockdev {
+	struct dump_dev ddev;
+	dev_t dev_id;
+	struct block_device *bdev;
+	struct bio *bio;
+	loff_t start_offset;
+	loff_t limit;
+	int err;
+};
+
+static inline struct dump_blockdev *DUMP_BDEV(struct dump_dev *dev)
+{
+	return container_of(dev, struct dump_blockdev, ddev);
+}
+
+
+/* mem  - for internal use by soft-boot based dumper */
+struct dump_memdev {
+	struct dump_dev ddev;
+	unsigned long indirect_map_root;
+	unsigned long nr_free;
+	struct page *curr_page;
+	unsigned long *curr_map;
+	unsigned long curr_map_offset;
+	unsigned long last_offset;
+	unsigned long last_used_offset;
+	unsigned long last_bs_offset;
+};
+
+static inline struct dump_memdev *DUMP_MDEV(struct dump_dev *dev)
+{
+	return container_of(dev, struct dump_memdev, ddev);
+}
+
+/* Todo/future - meant for raw dedicated interfaces e.g. mini-ide driver */
+struct dump_rdev {
+	struct dump_dev ddev;
+	char name[32];
+	int (*reset)(struct dump_rdev *, unsigned int,
+		unsigned long);
+	/* ... to do ... */
+};
+
+/* just to get the size right when saving config across a soft-reboot */
+struct dump_anydev {
+	union {
+		struct dump_blockdev bddev;
+		/* .. add other types here .. */
+	};
+};
+
+
+
+/* Dump device / target operation wrappers */
+/* These assume that dump_dev is initiatized to dump_config.dumper->dev */
+
+extern struct dump_dev *dump_dev;
+
+static inline int dump_dev_open(const char *arg)
+{
+	return dump_dev->ops->open(dump_dev, arg);
+}
+
+static inline int dump_dev_release(void)
+{
+	return dump_dev->ops->release(dump_dev);
+}
+
+static inline int dump_dev_silence(void)
+{
+	return dump_dev->ops->silence(dump_dev);
+}
+
+static inline int dump_dev_resume(void)
+{
+	return dump_dev->ops->resume(dump_dev);
+}
+
+static inline int dump_dev_seek(loff_t offset)
+{
+	return dump_dev->ops->seek(dump_dev, offset);
+}
+
+static inline int dump_dev_write(void *buf, unsigned long len)
+{
+	return dump_dev->ops->write(dump_dev, buf, len);
+}
+
+static inline int dump_dev_ready(void *buf)
+{
+	return dump_dev->ops->ready(dump_dev, buf);
+}
+
+static inline int dump_dev_ioctl(unsigned int cmd, unsigned long arg)
+{
+	if (!dump_dev || !dump_dev->ops->ioctl)
+		return -EINVAL;
+	return dump_dev->ops->ioctl(dump_dev, cmd, arg);
+}
+
+extern int dump_register_device(struct dump_dev *);
+extern void dump_unregister_device(struct dump_dev *);
+
+#endif /*  _LINUX_DUMPDEV_H */
Index: linux-2.6.15/init/kerntypes.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.15/init/kerntypes.c	2006-02-12 16:58:13.953952111 +0100
@@ -0,0 +1,40 @@
+/*
+ * kerntypes.c
+ *
+ * Copyright (C) 2000 Tom Morano (tjm@sgi.com) and
+ *                    Matt D. Robinson (yakker@alacritech.com)
+ *
+ * Dummy module that includes headers for all kernel types of interest.
+ * The kernel type information is used by the lcrash utility when
+ * analyzing system crash dumps or the live system. Using the type
+ * information for the running system, rather than kernel header files,
+ * makes for a more flexible and robust analysis tool.
+ *
+ * This source code is released under version 2 of the GNU GPL.
+ */
+
+#include <linux/compile.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/config.h>
+#include <linux/utsname.h>
+#include <linux/kernel_stat.h>
+#include <linux/dump.h>
+
+#include <asm/kerntypes.h>
+
+#ifdef LINUX_COMPILE_VERSION_ID_TYPE
+/* Define version type for version validation of dump and kerntypes */
+LINUX_COMPILE_VERSION_ID_TYPE;
+#endif
+#if defined(CONFIG_SMP) && defined(CONFIG_LKCD_DUMP)
+extern struct runqueue runqueues;
+struct runqueue rn;
+#endif
+
+struct new_utsname *p;
+void
+kerntypes_dummy(void)
+{
+}
