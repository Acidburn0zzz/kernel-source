From: Jeff Mahoney <jeffm@suse.de>
Subject: Pass struct nameidata to subfs instead of NULL
SUSE-Bugzilla: 104657

Belongs together with patches.suse/lookup_create_nameidata.diff.

Jeff writes:

> Just an FYI, I'm going to have to update subfs again before release. It
> turns out that there are way too many places where lookup_hash() gets
> called where subfs can receive the call.
>
> I had modified subfs to not cache the vfsmount any longer, instead using
> the nameidata passed down in ->open and ->lookup. Unfortunately,
> lookup_hash calls __lookup_hash (..., NULL), which makes subfs oops when
> it gets the call.

[...]

> I just did a quick review to see how many spots there actually _are_
> that would need modifying to make subfs work correctly without caching
> the vfsmount (ie: correctly). Since NFS will refuse to export a subfs
> filesystem, NFS doesn't need to be accounted for. Other callers are
> internal to filesystems, and also don't need to be accounted for.
>
> That leaves standard namei calls, binding to a unix socket, and a lookup
> in a subdomain (which admittedly I don't know enough about to tell if
> it's required or not).
>
> In any case, all the places I want to change are of the format:
>
> dentry = lookup_hash(&nd.last, nd.dentry);
>
> ... which means that a nameidata is already initialized and changing it to:
>
> dentry = __lookup_hash(&nd.last, nd.dentry, &nd);
>
> This has zero net effect for every other filesystem.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff -ruNpX dontdiff linux-2.6.12/fs/namei.c linux-2.6.12.nameidata/fs/namei.c
--- linux-2.6.12/fs/namei.c	2005-08-15 10:17:17.462389312 -0400
+++ linux-2.6.12.nameidata/fs/namei.c	2005-08-15 10:18:17.919795543 -0400
@@ -1052,7 +1052,7 @@ out:
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-static struct dentry * __lookup_hash(struct qstr *name, struct dentry * base, struct nameidata *nd)
+struct dentry * __lookup_hash(struct qstr *name, struct dentry * base, struct nameidata *nd)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -1091,11 +1091,6 @@ out:
 	return dentry;
 }
 
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
-{
-	return __lookup_hash(name, base, NULL);
-}
-
 /* SMP-safe */
 struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
 {
@@ -1596,7 +1591,7 @@ struct dentry *lookup_create(struct name
 	/*
 	 * Do the final lookup.
 	 */
-	dentry = lookup_hash(&nd->last, nd->dentry);
+	dentry = __lookup_hash(&nd->last, nd->dentry, nd);
 	if (IS_ERR(dentry))
 		goto fail;
 
@@ -1835,7 +1830,7 @@ asmlinkage long sys_rmdir(const char __u
 			goto exit1;
 	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = __lookup_hash(&nd.last, nd.dentry, &nd);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1904,7 +1899,7 @@ asmlinkage long sys_unlink(const char __
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = __lookup_hash(&nd.last, nd.dentry, &nd);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -2254,7 +2249,7 @@ static inline int do_rename(const char *
 
 	trap = lock_rename(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = __lookup_hash(&oldnd.last, old_dir, &oldnd);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -2274,7 +2269,7 @@ static inline int do_rename(const char *
 	error = -EINVAL;
 	if (old_dentry == trap)
 		goto exit4;
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	new_dentry = __lookup_hash(&newnd.last, new_dir, &oldnd);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
@@ -2467,7 +2462,7 @@ EXPORT_SYMBOL(follow_up);
 EXPORT_SYMBOL(get_write_access); /* binfmt_aout */
 EXPORT_SYMBOL(getname);
 EXPORT_SYMBOL(lock_rename);
-EXPORT_SYMBOL(lookup_hash);
+EXPORT_SYMBOL(__lookup_hash);
 EXPORT_SYMBOL(lookup_one_len);
 EXPORT_SYMBOL(page_follow_link_light);
 EXPORT_SYMBOL(page_put_link);
diff -ruNpX dontdiff linux-2.6.12/include/linux/namei.h linux-2.6.12.nameidata/include/linux/namei.h
--- linux-2.6.12/include/linux/namei.h	2005-08-15 10:10:02.021314028 -0400
+++ linux-2.6.12.nameidata/include/linux/namei.h	2005-08-15 10:17:48.879726845 -0400
@@ -66,7 +66,11 @@ extern void path_release(struct nameidat
 extern void path_release_on_umount(struct nameidata *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
-extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
+extern struct dentry * __lookup_hash(struct qstr *, struct dentry *, struct nameidata *);
+static inline struct dentry * lookup_hash(struct qstr *name, struct dentry *base)
+{
+	return __lookup_hash(name, base, NULL);
+}
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);
diff -ruNpX dontdiff linux-2.6.12/security/subdomain/main.c linux-2.6.12.nameidata/security/subdomain/main.c
--- linux-2.6.12/security/subdomain/main.c	2005-08-15 10:17:25.018065545 -0400
+++ linux-2.6.12.nameidata/security/subdomain/main.c	2005-08-15 10:17:48.882725922 -0400
@@ -1151,7 +1151,7 @@ int sd_symlink(struct dentry *link, cons
 	if (error)
 		goto out;
 
-	target = lookup_hash(&nd.last, nd.dentry);
+	target = __lookup_hash(&nd.last, nd.dentry, &nd);
 	if (IS_ERR(target)) {
 		error = PTR_ERR(target);
 		goto out_release;
