From: Jeff Mahoney <jeffm@suse.de>
Subject: Pass struct nameidata to subfs instead of NULL

Belongs together with patches.suse/lookup_create_nameidata.diff.

Jeff writes:

> Just an FYI, I'm going to have to update subfs again before release. It
> turns out that there are way too many places where lookup_hash() gets
> called where subfs can receive the call.
> 
> I had modified subfs to not cache the vfsmount any longer, instead using
> the nameidata passed down in ->open and ->lookup. Unfortunately,
> lookup_hash calls __lookup_hash (..., NULL), which makes subfs oops when
> it gets the call.
 
[...]

> I just did a quick review to see how many spots there actually _are_
> that would need modifying to make subfs work correctly without caching
> the vfsmount (ie: correctly). Since NFS will refuse to export a subfs
> filesystem, NFS doesn't need to be accounted for. Other callers are
> internal to filesystems, and also don't need to be accounted for.
> 
> That leaves standard namei calls, binding to a unix socket, and a lookup
> in a subdomain (which admittedly I don't know enough about to tell if
> it's required or not).
> 
> In any case, all the places I want to change are of the format:
> 
> dentry = lookup_hash(&nd.last, nd.dentry);
> 
> ... which means that a nameidata is already initialized and changing it to:
> 
> dentry = __lookup_hash(&nd.last, nd.dentry, &nd);
> 
> This has zero net effect for every other filesystem.

Signed-off-by: Andreas Gruenbacher <agruen@suse.de>

Index: linux-2.6.11/fs/namei.c
===================================================================
--- linux-2.6.11.orig/fs/namei.c
+++ linux-2.6.11/fs/namei.c
@@ -992,7 +992,7 @@ int fastcall path_lookup(const char *nam
  * needs parent already locked. Doesn't follow mounts.
  * SMP-safe.
  */
-static struct dentry * __lookup_hash(struct qstr *name, struct dentry * base, struct nameidata *nd)
+struct dentry * __lookup_hash(struct qstr *name, struct dentry * base, struct nameidata *nd)
 {
 	struct dentry * dentry;
 	struct inode *inode;
@@ -1031,11 +1031,6 @@ out:
 	return dentry;
 }
 
-struct dentry * lookup_hash(struct qstr *name, struct dentry * base)
-{
-	return __lookup_hash(name, base, NULL);
-}
-
 /* SMP-safe */
 struct dentry * lookup_one_len(const char * name, struct dentry * base, int len)
 {
@@ -1760,7 +1755,7 @@ asmlinkage long sys_rmdir(const char __u
 			goto exit1;
 	}
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = __lookup_hash(&nd.last, nd.dentry, &nd);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1829,7 +1824,7 @@ asmlinkage long sys_unlink(const char __
 	if (nd.last_type != LAST_NORM)
 		goto exit1;
 	down(&nd.dentry->d_inode->i_sem);
-	dentry = lookup_hash(&nd.last, nd.dentry);
+	dentry = __lookup_hash(&nd.last, nd.dentry, &nd);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
@@ -2178,7 +2173,7 @@ static inline int do_rename(const char *
 
 	trap = lock_rename(new_dir, old_dir);
 
-	old_dentry = lookup_hash(&oldnd.last, old_dir);
+	old_dentry = __lookup_hash(&oldnd.last, old_dir, &oldnd);
 	error = PTR_ERR(old_dentry);
 	if (IS_ERR(old_dentry))
 		goto exit3;
@@ -2198,7 +2193,7 @@ static inline int do_rename(const char *
 	error = -EINVAL;
 	if (old_dentry == trap)
 		goto exit4;
-	new_dentry = lookup_hash(&newnd.last, new_dir);
+	new_dentry = __lookup_hash(&newnd.last, new_dir, &oldnd);
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto exit4;
@@ -2391,7 +2386,7 @@ EXPORT_SYMBOL(follow_up);
 EXPORT_SYMBOL(get_write_access); /* binfmt_aout */
 EXPORT_SYMBOL(getname);
 EXPORT_SYMBOL(lock_rename);
-EXPORT_SYMBOL(lookup_hash);
+EXPORT_SYMBOL(__lookup_hash);
 EXPORT_SYMBOL(lookup_one_len);
 EXPORT_SYMBOL(page_follow_link_light);
 EXPORT_SYMBOL(page_put_link);
Index: linux-2.6.11/include/linux/namei.h
===================================================================
--- linux-2.6.11.orig/include/linux/namei.h
+++ linux-2.6.11/include/linux/namei.h
@@ -64,7 +64,11 @@ extern void path_release(struct nameidat
 extern void path_release_on_umount(struct nameidata *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
-extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
+extern struct dentry * __lookup_hash(struct qstr *, struct dentry *, struct nameidata *);
+static inline struct dentry * lookup_hash(struct qstr *name, struct dentry *base)
+{
+	return __lookup_hash(name, base, NULL);
+}
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);
Index: linux-2.6.11/net/unix/af_unix.c
===================================================================
--- linux-2.6.11.orig/net/unix/af_unix.c
+++ linux-2.6.11/net/unix/af_unix.c
@@ -776,7 +776,7 @@ static int unix_bind(struct socket *sock
 		/*
 		 * Do the final lookup.
 		 */
-		dentry = lookup_hash(&nd.last, nd.dentry);
+		dentry = __lookup_hash(&nd.last, nd.dentry, &nd);
 		err = PTR_ERR(dentry);
 		if (IS_ERR(dentry))
 			goto out_mknod_unlock;
Index: linux-2.6.11/security/subdomain/main.c
===================================================================
--- linux-2.6.11.orig/security/subdomain/main.c
+++ linux-2.6.11/security/subdomain/main.c
@@ -1470,7 +1470,7 @@ int sd_symlink(struct dentry *link, cons
 	if (error)
 		goto out;
 
-	target = lookup_hash(&nd.last, nd.dentry);
+	target = __lookup_hash(&nd.last, nd.dentry, &nd);
 	if (IS_ERR(target)) {
 		error = PTR_ERR(target);
 		goto out_release;
