Index: linux.t/kernel/ckrm/ckrm.c
===================================================================
--- linux.t.orig/kernel/ckrm/ckrm.c	2004-04-29 12:45:42.711133868 -0400
+++ linux.t/kernel/ckrm/ckrm.c	2004-04-29 13:18:11.829680912 -0400
@@ -557,7 +557,7 @@ ckrm_release_core_class(struct ckrm_core
 	/* need to make sure that the classgot really dropped */
 	if (atomic_read(&core->refcnt) != 1) {
 		printk("class <%s> deletion delayed refcnt=%d jif=%ld\n",
-		       core->name,core->refcnt,jiffies);
+		       core->name,atomic_read(&core->refcnt),jiffies);
 		core->magic = 0;  /* just so we have a ref point */
 	}
 	ckrm_core_drop(core);
Index: linux.t/kernel/ckrm/ckrm_tc.c
===================================================================
--- linux.t.orig/kernel/ckrm/ckrm_tc.c	2004-04-29 12:45:42.724132286 -0400
+++ linux.t/kernel/ckrm/ckrm_tc.c	2004-04-29 13:19:12.156421845 -0400
@@ -529,7 +529,7 @@ ckrm_reclassify_class_tasks(struct ckrm_
 	down(&async_serializer);   // protect again race condition
 
 
-	printk("\t%s: start %p:%s:%d\n",__FUNCTION__,cls,cls->core.name, cls->core.refcnt);
+	printk("\t%s: start %p:%s:%d\n",__FUNCTION__,cls,cls->core.name, atomic_read(&cls->core.refcnt));
 	// If no CE registered for this classtype, following will be needed repeatedly;
 	ce_regd =  class_core(cls)->classtype->ce_regd;
 	cnode = &(class_core(cls)->hnode);
@@ -563,7 +563,7 @@ next_task:
 		put_task_struct(tsk);
 		goto next_task;
 	}
-	printk("\t%s: stop  %p:%s:%d\n",__FUNCTION__,cls,cls->core.name, cls->core.refcnt);
+	printk("\t%s: stop  %p:%s:%d\n",__FUNCTION__,cls,cls->core.name, atomic_read(&cls->core.refcnt));
 	ckrm_core_drop(class_core(cls));
 	class_unlock(class_core(cls));
 
@@ -637,7 +637,7 @@ ckrm_free_task_class(struct ckrm_core_cl
  		return 0;
 	}
 
-	printk("%s: stop  %p:%s:%d\n",__FUNCTION__,core,core->name, core->refcnt);
+	printk("%s: stop  %p:%s:%d\n",__FUNCTION__,core,core->name, atomic_read(&core->refcnt));
 	taskcls = class_type(struct ckrm_task_class, core);
 
 	ce_protect(&CT_taskclass);
