Date: Thu, 05 Aug 2004 14:00:10 +0200
From: olh@suse.de
Subject: Prevent legacy io access on pmac
Patch-mainline: never

The ppc32 common config runs also on PReP/CHRP, which uses PC style IO
devices.  The probing is bogus, it crashes or floods dmesg.

ppc can boot one single binary on prep, chrp and pmac boards.
ppc64 can boot one single binary on pseries and G5 boards.
pmac has no legacy io, probing for PC style legacy hardware leads to a
hard crash.
Several patches exist to prevent serial, floppy, ps2, parport and other
drivers from probing these io ports in the legacy IO space.
I think the simplest fix for 2.6 is a request_region of the problematic
areas.

Another thing is the co-existance of 8250 and pmac_zilog.
Both try to claim ttyS0. 8250 comes first and zilog init fails.
The right fix would be a rewrite of the tty devnode handling with dynamic
minor assignment.
http://bugzilla.kernel.org/show_bug.cgi?id=1529

Signed-off-by: Olaf Hering <olh@suse.de>

 arch/powerpc/platforms/powermac/pci.c |   18 ++++++++++++++++++
 drivers/serial/8250.c                 |    9 +++++++++
 include/asm-powerpc/io.h              |    4 ++++
 include/asm-ppc/io.h                  |    5 +++++
 4 files changed, 36 insertions(+)

Index: linux-2.6.16/arch/powerpc/platforms/powermac/pci.c
===================================================================
--- linux-2.6.16.orig/arch/powerpc/platforms/powermac/pci.c
+++ linux-2.6.16/arch/powerpc/platforms/powermac/pci.c
@@ -976,9 +976,27 @@ static void __init pcibios_fixup_OF_inte
 		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
 	}
 }
+/*
+ * if both serial drivers exists, 8250 will be inited first
+ * it claims ttyS0 and pmac_zilog init fails
+ */
+#ifdef CONFIG_SERIAL_8250
+int do_not_try_pc_legacy_8250;
+EXPORT_SYMBOL(do_not_try_pc_legacy_8250);
+#endif
 
 void __init pmac_pcibios_fixup(void)
 {
+#ifdef CONFIG_ISAPNP
+	/* avoid a warning during boot */
+	extern int isapnp_disable;
+	isapnp_disable = 1;
+#endif
+#if defined(CONFIG_SERIAL_8250) && defined(CONFIG_SERIAL_PMACZILOG)
+	do_not_try_pc_legacy_8250 = 1;
+#endif
+	request_region(0x0UL, 0x10000UL, "reserved legacy io");
+
 	/* Fixup interrupts according to OF tree */
 	pcibios_fixup_OF_interrupts();
 }
Index: linux-2.6.16/drivers/serial/8250.c
===================================================================
--- linux-2.6.16.orig/drivers/serial/8250.c
+++ linux-2.6.16/drivers/serial/8250.c
@@ -47,6 +47,10 @@
 
 #include "8250.h"
 
+#ifndef NO_PC_LEGACY_SERIAL_8250
+#define do_not_try_pc_legacy_8250 (0)
+#endif
+
 /*
  * Configuration:
  *   share_irqs - whether we pass SA_SHIRQ to request_irq().  This option
@@ -2271,6 +2275,8 @@ static struct console serial8250_console
 
 static int __init serial8250_console_init(void)
 {
+	if (do_not_try_pc_legacy_8250)
+		return -ENODEV;
 	serial8250_isa_init_ports();
 	register_console(&serial8250_console);
 	return 0;
@@ -2581,6 +2587,9 @@ static int __init serial8250_init(void)
 {
 	int ret, i;
 
+	if (do_not_try_pc_legacy_8250)
+		return -ENODEV;
+
 	if (nr_uarts > UART_NR)
 		nr_uarts = UART_NR;
 
Index: linux-2.6.16/include/asm-powerpc/io.h
===================================================================
--- linux-2.6.16.orig/include/asm-powerpc/io.h
+++ linux-2.6.16/include/asm-powerpc/io.h
@@ -440,6 +440,10 @@ out:
 /* Check of existence of legacy devices */
 extern int check_legacy_ioport(unsigned long base_port);
 
+#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_SERIAL_8250)
+#define NO_PC_LEGACY_SERIAL_8250 1
+extern int do_not_try_pc_legacy_8250;
+#endif
 
 /*
  * Convert a physical pointer to a virtual kernel pointer for /dev/mem
Index: linux-2.6.16/include/asm-ppc/io.h
===================================================================
--- linux-2.6.16.orig/include/asm-ppc/io.h
+++ linux-2.6.16/include/asm-ppc/io.h
@@ -564,6 +564,11 @@ extern void pci_iounmap(struct pci_dev *
 
 #endif
 
+#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_SERIAL_8250)
+#define NO_PC_LEGACY_SERIAL_8250 1
+extern int do_not_try_pc_legacy_8250;
+#endif
+
 /*
  * Convert a physical pointer to a virtual kernel pointer for /dev/mem
  * access
