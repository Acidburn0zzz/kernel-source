From: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
Date: Tue, 2 Oct 2018 23:46:28 +0200
Subject: cpuidle: menu: Avoid computations for very close timers
Patch-mainline: v4.20-rc1
Git-commit: 8b007ebec9a5d120d25c00d9b771aadf45ac5177
References: bsc#1121513

If the next timer event (not including the tick) is closer than the
target residency of the second state or the PM QoS latency constraint
is below its exit latency, state[0] will be used regardless of any
other factors, so skip the computations in menu_select() then and
return 0 straight away from it.

Still, do that after the bucket has been determined to avoid
updating the correction factor for a stale bucket.

Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Acked-by: Giovanni Gherdovich <ggherdovich@suse.cz>
---
 drivers/cpuidle/governors/menu.c |   11 +++++++++++
 1 file changed, 11 insertions(+)

--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@ -312,6 +312,17 @@ static int menu_select(struct cpuidle_dr
 	get_iowait_load(&nr_iowaiters, &cpu_load);
 	data->bucket = which_bucket(data->next_timer_us, nr_iowaiters);
 
+	if (unlikely(drv->state_count <= 1) ||
+	    ((data->next_timer_us < drv->states[1].target_residency ||
+	      latency_req < drv->states[1].exit_latency) &&
+	     !drv->states[0].disabled && !dev->states_usage[0].disable)) {
+		/*
+		 * In this case state[0] will be used no matter what, so return
+		 * it right away.
+		 */
+		return 0;
+	}
+
 	/*
 	 * Force the result of multiplication to be 64 bits even if both
 	 * operands are 32 bits.
