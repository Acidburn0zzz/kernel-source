From: Ilya Dryomov <idryomov@gmail.com>
Date: Wed, 30 May 2018 14:58:25 +0200
Subject: libceph: don't abort reads in ceph_osdc_abort_on_full()
Git-commit: 690f951d7eb8c0529f8a367a3db9cfbfde624db4
Patch-mainline: v4.18-rc1
References: FATE#324714

Don't consider reads for aborting and use ->base_oloc instead of
->target_oloc, as done in __submit_request().

Strictly speaking, we shouldn't be aborting FULL_TRY/FULL_FORCE writes
either.  But, there is an inconsistency in FULL_TRY/FULL_FORCE handling
on the OSD side [1], so given that neither of these is used in the
kernel client, leave it for when the OSD behaviour is sorted out.

[1] http://tracker.ceph.com/issues/24339

Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Acked-by: Jeff Layton <jlayton@redhat.com>
Reviewed-by: "Yan, Zheng" <zyan@redhat.com>
Acked-by: Luis Henriques <lhenriques@suse.com>
---
 net/ceph/osd_client.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -2381,8 +2381,9 @@ static int abort_on_full_fn(struct ceph_
 	bool *victims = arg;
 
 	if (req->r_abort_on_full &&
+	    (req->r_flags & CEPH_OSD_FLAG_WRITE) &&
 	    (ceph_osdmap_flag(osdc, CEPH_OSDMAP_FULL) ||
-	     pool_full(osdc, req->r_t.target_oloc.pool))) {
+	     pool_full(osdc, req->r_t.base_oloc.pool))) {
 		if (!*victims) {
 			update_epoch_barrier(osdc, osdc->osdmap->epoch);
 			*victims = true;
