From: tonyj@suse.de
Subject: SubDomain (AppArmor)
Patch-mainline: no

SubDomain (AppArmor) security module
Patch is not in mainline -- pending AppArmor code submission to lkml


Index: linux-2.6.14/security/Kconfig
===================================================================
--- linux-2.6.14.orig/security/Kconfig
+++ linux-2.6.14/security/Kconfig
@@ -87,6 +87,7 @@ config SECURITY_SECLVL
 	  If you are unsure how to answer this question, answer N.
 
 source security/selinux/Kconfig
+source security/subdomain/Kconfig
 
 endmenu
 
Index: linux-2.6.14/security/Makefile
===================================================================
--- linux-2.6.14.orig/security/Makefile
+++ linux-2.6.14/security/Makefile
@@ -4,6 +4,7 @@
 
 obj-$(CONFIG_KEYS)			+= keys/
 subdir-$(CONFIG_SECURITY_SELINUX)	+= selinux
+subdir-$(CONFIG_SECURITY_SUBDOMAIN)	+= subdomain
 
 # We always need commoncap as it's default
 obj-y		+= commoncap.o
Index: linux-2.6.14/security/subdomain/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/Makefile
@@ -0,0 +1,11 @@
+# Makefile for SubDomain Linux Security Module
+#
+
+SUBDOMAINVER=2.0-16.43r5891
+
+EXTRA_CFLAGS += -DSUBDOMAIN_VERSION=\"${SUBDOMAINVER}\" -Werror -Wwrite-strings
+
+subdir-$(CONFIG_SECURITY_SUBDOMAIN) += sdmatch
+obj-$(CONFIG_SECURITY_SUBDOMAIN) += subdomain.o
+
+subdomain-y := main.o list.o procattr.o lsm.o subdomainfs.o capabilities.o module_interface.o subdomain_version.o
Index: linux-2.6.14/security/subdomain/capabilities.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/capabilities.c
@@ -0,0 +1,54 @@
+/*
+ *	Copyright (C) 2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	SubDomain capability definitions
+ */
+
+#include "subdomain.h"
+
+static const char *capnames[] = {
+	"chown",
+	"dac_override",
+	"dac_read_search",
+	"fowner",
+	"fsetid",
+	"kill",
+	"setgid",
+	"setuid",
+	"setpcap",
+	"linux_immutable",
+	"net_bind_service",
+	"net_broadcast",
+	"net_admin",
+	"net_raw",
+	"ipc_lock",
+	"ipc_owner",
+	"sys_module",
+	"sys_rawio",
+	"sys_chroot",
+	"sys_ptrace",
+	"sys_pacct",
+	"sys_admin",
+	"sys_boot",
+	"sys_nice",
+	"sys_resource",
+	"sys_time",
+	"sys_tty_config",
+	"mknod",
+	"lease"
+};
+
+const char *capability_to_name(unsigned int cap)
+{
+	const char *capname;
+
+	capname = (cap < (sizeof(capnames) / sizeof(char *))
+		   ? capnames[cap] : "invalid-capability");
+
+	return capname;
+}
Index: linux-2.6.14/security/subdomain/immunix.h
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/immunix.h
@@ -0,0 +1,77 @@
+/*
+ *	Copyright (C) 2000, 2001, 2004, 2005 Novell/SUSE
+ *
+ *	Immunix AppArmor LSM
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ */
+
+#ifndef _IMMUNIX_H
+#define _IMMUNIX_H
+
+/* start of system offsets */
+#define POS_SD_FILE_MIN			0
+#define POS_SD_MAY_EXEC			POS_SD_FILE_MIN
+#define POS_SD_MAY_WRITE		(POS_SD_MAY_EXEC + 1)
+#define POS_SD_MAY_READ			(POS_SD_MAY_WRITE + 1)
+/* not used by Subdomain */
+#define POS_SD_MAY_APPEND		(POS_SD_MAY_READ + 1)
+/* end of system offsets */
+
+#define POS_SD_MAY_LINK			(POS_SD_MAY_APPEND + 1)
+#define POS_SD_EXEC_INHERIT		(POS_SD_MAY_LINK + 1)
+#define POS_SD_EXEC_UNCONSTRAINED	(POS_SD_EXEC_INHERIT + 1)
+#define POS_SD_EXEC_PROFILE		(POS_SD_EXEC_UNCONSTRAINED + 1)
+#define POS_SD_FILE_MAX			POS_SD_EXEC_PROFILE
+
+#define POS_SD_NET_MIN			(POS_SD_FILE_MAX + 1)
+#define POS_SD_TCP_CONNECT		POS_SD_NET_MIN
+#define POS_SD_TCP_ACCEPT		(POS_SD_TCP_CONNECT + 1)
+#define POS_SD_TCP_CONNECTED		(POS_SD_TCP_ACCEPT + 1)
+#define POS_SD_TCP_ACCEPTED		(POS_SD_TCP_CONNECTED + 1)
+#define POS_SD_UDP_SEND			(POS_SD_TCP_ACCEPTED + 1)
+#define POS_SD_UDP_RECEIVE		(POS_SD_UDP_SEND + 1)
+#define POS_SD_NET_MAX			POS_SD_UDP_RECEIVE
+
+/* logging only */
+#define POS_SD_LOGTCP_SEND		(POS_SD_NET_MAX + 1)
+#define POS_SD_LOGTCP_RECEIVE		(POS_SD_LOGTCP_SEND + 1)
+
+/* Modeled after MAY_READ, MAY_WRITE, MAY_EXEC def'ns */
+#define SD_MAY_EXEC			(0x01 << POS_SD_MAY_EXEC)
+#define SD_MAY_WRITE			(0x01 << POS_SD_MAY_WRITE)
+#define SD_MAY_READ			(0x01 << POS_SD_MAY_READ)
+#define SD_MAY_LINK			(0x01 << POS_SD_MAY_LINK)
+#define SD_EXEC_INHERIT			(0x01 << POS_SD_EXEC_INHERIT)
+#define SD_EXEC_UNCONSTRAINED		(0x01 << POS_SD_EXEC_UNCONSTRAINED)
+#define SD_EXEC_PROFILE			(0x01 << POS_SD_EXEC_PROFILE)
+#define SD_EXEC_MODIFIERS(X)		(X & (SD_EXEC_INHERIT | \
+					 SD_EXEC_UNCONSTRAINED | \
+					 SD_EXEC_PROFILE))
+/* Network subdomain extensions.  */
+#define SD_TCP_CONNECT			(0x01 << POS_SD_TCP_CONNECT)
+#define SD_TCP_ACCEPT			(0x01 << POS_SD_TCP_ACCEPT)
+#define SD_TCP_CONNECTED		(0x01 << POS_SD_TCP_CONNECTED)
+#define SD_TCP_ACCEPTED			(0x01 << POS_SD_TCP_ACCEPTED)
+#define SD_UDP_SEND			(0x01 << POS_SD_UDP_SEND)
+#define SD_UDP_RECEIVE			(0x01 << POS_SD_UDP_RECEIVE)
+
+#define SD_LOGTCP_SEND			(0x01 << POS_SD_LOGTCP_SEND)
+#define SD_LOGTCP_RECEIVE		(0x01 << POS_SD_LOGTCP_RECEIVE)
+
+#define SD_HAT_SIZE	975		/* Maximum size of a subdomain
+					 * ident (hat) */
+
+enum entry_t {
+	sd_entry_literal,
+	sd_entry_tailglob,
+	sd_entry_pattern,
+	sd_entry_invalid
+};
+
+#endif				/* ! _IMMUNIX_H */
+
+/*======================================================================*/
Index: linux-2.6.14/security/subdomain/inline.h
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/inline.h
@@ -0,0 +1,333 @@
+/*
+ *	Copyright (C) 2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ */
+
+#ifndef __INLINE_H
+#define __INLINE_H
+
+#include <linux/namespace.h>
+
+static __INLINE__ int __sd_is_confined(struct subdomain *sd)
+{
+	int rc = 0;
+
+	if (sd && sd->sd_magic == SD_ID_MAGIC && sd->profile) {
+		BUG_ON(!sd->active);
+		rc = 1;
+	}
+
+	return rc;
+}
+
+/**
+ *  sd_is_confined - is process confined
+ *  @sd: subdomain
+ *
+ *  Check if @sd contains a valid profile.
+ *  Return 1 if confined, 0 otherwise.
+ */
+static __INLINE__ int sd_is_confined(void)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(current->security);
+	return __sd_is_confined(sd);
+}
+
+/**
+ * sd_sub_defined - check if there is at least one subprofile defined
+ *
+ * Return 1 if there is at least one SubDomain subprofile defined,
+ * 0 otherwise.
+ *Used to obtain
+ */
+static __INLINE__ int __sd_sub_defined(struct subdomain *sd)
+{
+	if (__sd_is_confined(sd) && !list_empty(&sd->profile->sub))
+		return 1;
+
+	return 0;
+}
+
+static __INLINE__ int sd_sub_defined(void)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(current->security);
+	return __sd_sub_defined(sd);
+}
+
+static __INLINE__ struct sdprofile *get_sdprofile(struct sdprofile *p)
+{
+	if (p)
+		atomic_inc(&p->count);
+	return p;
+}
+
+static __INLINE__ void put_sdprofile(struct sdprofile *p)
+{
+	if (p)
+		if (atomic_dec_and_test(&p->count))
+			free_sdprofile(p);
+}
+
+static __INLINE__ void sd_switch(struct subdomain *sd,
+		      		 struct sdprofile *profile,
+				 struct sdprofile *active)
+{
+	/* noop if NULL */
+	put_sdprofile(sd->profile);
+	put_sdprofile(sd->active);
+
+	sd->profile = get_sdprofile(profile);
+	sd->active = get_sdprofile(active);
+}
+
+static __INLINE__ void sd_switch_unconfined(struct subdomain *sd)
+{
+	sd_switch(sd, NULL, NULL);
+
+	/* reset magic in case we were in a subhat before */
+	sd->sd_hat_magic = 0;
+}
+
+/* simple struct subdomain alloc/free wrappers */
+static __INLINE__ struct subdomain *alloc_subdomain(struct task_struct *tsk)
+{
+	struct subdomain *sd;
+
+	sd = kmalloc(sizeof(struct subdomain), GFP_KERNEL);
+	if (!sd)
+		goto out;
+
+	/* zero it first */
+	memset(sd, 0, sizeof(struct subdomain));
+	sd->sd_magic = SD_ID_MAGIC;
+
+	/* back pointer to task */
+	sd->task = tsk;
+
+	/* any readers of the list must make sure that they can handle
+	 * case where sd->profile and sd->active are not yet set (null)
+	 */
+	sd_subdomainlist_add(sd);
+
+out:
+	return sd;
+}
+
+static __INLINE__ void free_subdomain(struct subdomain *sd)
+{
+	sd_subdomainlist_remove(sd);
+	kfree(sd);
+}
+
+/**
+ * alloc_sdprofile - allocate new empty profile
+ *
+ * This routine allocates, initializes, and returns a new zeored
+ * profile structure. Returns NULL on failure.
+ */
+static __INLINE__ struct sdprofile *alloc_sdprofile(void)
+{
+	struct sdprofile *profile;
+
+	profile = (struct sdprofile *)kmalloc(sizeof(struct sdprofile),
+					      GFP_KERNEL);
+	SD_DEBUG("%s(%p)\n", __FUNCTION__, profile);
+	if (profile) {
+		int i;
+		memset(profile, 0, sizeof(struct sdprofile));
+		INIT_LIST_HEAD(&profile->list);
+		INIT_LIST_HEAD(&profile->sub);
+		INIT_LIST_HEAD(&profile->file_entry);
+		for (i = 0; i <= POS_SD_FILE_MAX; i++) {
+			INIT_LIST_HEAD(&profile->file_entryp[i]);
+		}
+	}
+	return profile;
+}
+
+/**
+ * sd_put_name - release name (really just free_page)
+ * @name: name to release.
+ */
+static __INLINE__ void sd_put_name(char *name)
+{
+	free_page((unsigned long)name);
+}
+
+static __INLINE__ struct sdprofile *__sd_find_profile(const char *name,
+						      struct list_head *head)
+{
+	struct list_head *lh;
+
+	if (!name || !head)
+		return NULL;
+
+	SD_DEBUG("%s: finding profile %s\n", __FUNCTION__, name);
+	list_for_each(lh, head) {
+		struct sdprofile *p = list_entry(lh, struct sdprofile, list);
+		if (!strcmp(p->name, name)) {
+			/* return refcounted object */
+			p = get_sdprofile(p);
+			return p;
+		} else {
+			SD_DEBUG("%s: skipping %s\n", __FUNCTION__, p->name);
+		}
+	}
+	return NULL;
+}
+
+static __INLINE__ struct subdomain *__get_sdcopy(struct subdomain *new,
+						 struct task_struct *tsk)
+{
+	struct subdomain *old, *temp = NULL;
+
+	old = SD_SUBDOMAIN(tsk->security);
+
+	if (old) {
+		new->sd_magic = old->sd_magic;
+		new->sd_hat_magic = old->sd_hat_magic;
+
+		new->active = get_sdprofile(old->active);
+
+		if (old->profile == old->active) {
+			new->profile = new->active;
+		} else {
+			new->profile = get_sdprofile(old->profile);
+		}
+
+		temp = new;
+	}
+
+	return temp;
+}
+
+static __INLINE__ struct subdomain *get_sdcopy(struct subdomain *new)
+{
+	struct subdomain *temp;
+
+	SD_RLOCK;
+
+	temp = __get_sdcopy(new, current);
+
+	SD_RUNLOCK;
+
+	return temp;
+}
+
+static __INLINE__ void put_sdcopy(struct subdomain *temp)
+{
+	if (temp) {
+		put_sdprofile(temp->active);
+		if (temp->active != temp->profile) {
+			(void)put_sdprofile(temp->profile);
+		}
+	}
+}
+
+/* sd_path_begin2
+ * Setup data for iterating over paths to dentry (sd_path_getname)
+ * @rdentry is used to obtain the filesystem root dentry
+ * @dentry is the actual dentry object we want to obtain pathnames to.
+ */
+static __INLINE__ void sd_path_begin2(struct dentry *rdentry,
+				      struct dentry *dentry,
+				      struct sd_path_data *data)
+{
+	data->dentry = dentry;
+	data->root = dget(rdentry->d_sb->s_root);
+	data->namespace = current->namespace;
+	data->head = &data->namespace->list;
+	data->pos = data->head->next;
+	prefetch(data->pos->next);
+	data->errno = 0;
+
+	down_read(&data->namespace->sem);
+}
+
+/* sd_path_begin
+ * Setup data for iterating over paths to dentry (sd_path_getname)
+ * @dentry is used both for obtaining the filesystem root
+ *  and also for the actual dentry object we want to obtain pathnames to.
+ */
+static __INLINE__ void sd_path_begin(struct dentry *dentry,
+				     struct sd_path_data *data)
+{
+	sd_path_begin2(dentry, dentry, data);
+}
+
+/* sd_path_getname
+ * Return the next pathname that dentry (from sd_path_begin) may be reached
+ * through.  If no more paths exists or in the case of error, NULL is returned.
+ */
+static __INLINE__ char *sd_path_getname(struct sd_path_data *data)
+{
+	char *name = NULL;
+	struct vfsmount *mnt;
+
+	while (data->pos != data->head) {
+		mnt = list_entry(data->pos, struct vfsmount, mnt_list);
+
+		/* advance to next -- so that it is done before we break */
+		data->pos = data->pos->next;
+		prefetch(data->pos->next);
+
+		if (mnt->mnt_root == data->root) {
+			name = __sd_get_name(data->dentry, mnt);
+			if (!name) {
+				data->errno = -ENOMEM;
+			}
+			break;
+		}
+	}
+
+	return name;
+}
+
+/* sd_path_getmnt
+ * Return the next mountpoint which has the same root dentry as was passed
+ * to sd_path_begin2. If no more mount points exist, NULL is returned.
+ */
+static __INLINE__ struct vfsmount *sd_path_getmnt(struct sd_path_data *data)
+{
+	struct vfsmount *mnt = NULL;
+
+	while (data->pos != data->head) {
+		mnt = list_entry(data->pos, struct vfsmount, mnt_list);
+
+		/* advance to next -- so that it is done before we break */
+		data->pos = data->pos->next;
+		prefetch(data->pos->next);
+
+		if (mnt->mnt_root == data->root) {
+			mntget(mnt);
+			break;
+		}
+	}
+
+	return mnt;
+}
+
+/* sd_path_end
+ * end iterating over the namespace
+ * release all dentries and semaphores that were allocated by sd_path_begin
+ * If an error occured in a previous sd_path_getmnt it is returned.
+ * Otherwise 0 is returned
+ */
+static __INLINE__ int sd_path_end(struct sd_path_data *data)
+{
+	up_read(&data->namespace->sem);
+	dput(data->root);
+
+	return data->errno;
+}
+
+static __INLINE__ int isblank(unsigned char c)
+{
+	return c == ' ' || c == '\t';
+}
+
+#endif				/* __INLINE_H__ */
Index: linux-2.6.14/security/subdomain/list.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/list.c
@@ -0,0 +1,287 @@
+/*
+ *	Copyright (C) 1998-2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	SubDomain Profile List Management
+ */
+
+#include <linux/seq_file.h>
+#include "subdomain.h"
+#include "inline.h"
+
+/* list of all profiles */
+static LIST_HEAD(profile_list);
+// profile list spin lock
+static rwlock_t profile_lock = RW_LOCK_UNLOCKED;
+#define LIST_RLOCK	read_lock(&profile_lock)
+#define LIST_RUNLOCK	read_unlock(&profile_lock)
+#define LIST_WLOCK	write_lock(&profile_lock)
+#define LIST_WUNLOCK	write_unlock(&profile_lock)
+
+/* list of all subdomains */
+static LIST_HEAD(subdomain_list);
+// subdomain list spin lock
+static rwlock_t subdomain_lock = RW_LOCK_UNLOCKED;
+#define SDLIST_RLOCK	read_lock(&subdomain_lock)
+#define SDLIST_RUNLOCK	read_unlock(&subdomain_lock)
+#define SDLIST_WLOCK	write_lock(&subdomain_lock)
+#define SDLIST_WUNLOCK	write_unlock(&subdomain_lock)
+
+/**
+ * sd_profilelist_find - search for subdomain profile by name
+ * @name: profile name (program name)
+ *
+ * Search the profile list for profile @name.  Return refcounted profile on
+ * success, NULL on failure.
+ */
+struct sdprofile *sd_profilelist_find(const char *name)
+{
+	struct sdprofile *p = NULL;
+	if (name) {
+		LIST_RLOCK;
+		p = __sd_find_profile(name, &profile_list);
+		LIST_RUNLOCK;
+	}
+	return p;
+}
+
+/**
+ * sd_profilelist_add - add new profile to profile_list
+ * @profile: new profile to add to list
+ *
+ * Add new profile to list.  Reference count on profile is
+ * incremented.
+ */
+void sd_profilelist_add(struct sdprofile *profile)
+{
+	if (!profile) {
+		SD_INFO("%s: bad profile\n", __FUNCTION__);
+		return;
+	}
+
+	profile = get_sdprofile(profile);
+	LIST_WLOCK;
+	list_add(&profile->list, &profile_list);
+	LIST_WUNLOCK;
+}
+
+/**
+ * sd_profilelist_remove - remove profile from profile_list
+ * @name: name of profile to be removed
+ *
+ * Remove profile from list.  Reference count on profile is
+ * decremented.
+ */
+int sd_profilelist_remove(const char *name)
+{
+	struct sdprofile *profile = NULL;
+	struct list_head *lh, *tmp;
+	int error = -ENOENT;
+
+	if (!name)
+		goto out;
+
+	LIST_WLOCK;
+	list_for_each_safe(lh, tmp, &profile_list) {
+		struct sdprofile *p = list_entry(lh, struct sdprofile, list);
+		if (!strcmp(p->name, name)) {
+			list_del_init(&p->list);
+			profile = p;
+			break;
+		}
+	}
+	LIST_WUNLOCK;
+	if (!profile)
+		goto out;
+
+	put_sdprofile(profile);
+	error = 0;
+out:
+	return error;
+}
+
+/**
+ * sd_profilelist_replace - replace profile by name
+ * @profile - new profile
+ *
+ * Replace a profile on the profile list.  Find the old profile by name in
+ * the list, and replace it with the new profile.  This is an atomic
+ * list operation.  Returns the old profile (which is still refcounted) if
+ * there was one, or NULL.
+ */
+struct sdprofile *sd_profilelist_replace(struct sdprofile *profile)
+{
+	struct sdprofile *oldprofile;
+
+	LIST_WLOCK;
+	oldprofile = __sd_find_profile(profile->name, &profile_list);
+	if (oldprofile) {
+		list_del_init(&oldprofile->list);
+
+		/* __sd_find_profile incremented count, so adjust down */
+		put_sdprofile(oldprofile);
+	}
+	profile = get_sdprofile(profile);
+	list_add(&profile->list, &profile_list);
+	LIST_WUNLOCK;
+
+	return oldprofile;
+}
+
+/**
+ * sd_profilelist_release - remove all profiles from profile_list
+ */
+void sd_profilelist_release(void)
+{
+	struct list_head *lh, *tmp;
+
+	LIST_WLOCK;
+	list_for_each_safe(lh, tmp, &profile_list) {
+		struct sdprofile *profile = list_entry(lh, struct sdprofile, list);
+		list_del_init(&profile->list);
+		put_sdprofile(profile);
+	}
+	LIST_WUNLOCK;
+}
+
+/**
+ * sd_subdomainlist_add - add new subdomain to subdomain_list
+ * @sd: new subdomain to add to list
+ */
+void sd_subdomainlist_add(struct subdomain *sd)
+{
+	if (!sd) {
+		SD_INFO("%s: bad subdomain\n", __FUNCTION__);
+		return;
+	}
+
+	SDLIST_WLOCK;
+	list_add(&sd->list, &subdomain_list);
+	SDLIST_WUNLOCK;
+}
+
+/**
+ * sd_subdomainlist_remove - remove subdomain from subdomain_list
+ * @sd: subdomain to be removed
+ */
+int sd_subdomainlist_remove(struct subdomain *sd)
+{
+	struct list_head *lh, *tmp;
+	int error = -ENOENT;
+
+	if (!sd)
+		goto out;
+
+	SDLIST_WLOCK;
+	list_for_each_safe(lh, tmp, &subdomain_list) {
+		struct subdomain *node = list_entry(lh, struct subdomain, list);
+		if (node == sd) {
+			list_del_init(&node->list);
+			error = 0;
+			break;
+		}
+	}
+	SDLIST_WUNLOCK;
+
+out:
+	return error;
+}
+
+/**
+ * sd_subdomainlist_iterate - Iterate over subdomain_list.
+ * stop when sd_iter func returns non zero
+ * @func: method to be called for each element
+ */
+void sd_subdomainlist_iterate(sd_iter func, void *cookie)
+{
+	struct list_head *lh;
+	int ret = 0;
+
+	SDLIST_RLOCK;
+	list_for_each(lh, &subdomain_list) {
+		struct subdomain *node = list_entry(lh, struct subdomain, list);
+		ret = (*func) (node, cookie);
+		if (ret != 0) {
+			break;
+		}
+	}
+	SDLIST_RUNLOCK;
+}
+
+/**
+ * sd_subdomainlist_iterateremove - Iterate over subdomain_list.
+ * remove element when sd_iter func returns non zero
+ * @func: method to be called for each element
+ */
+void sd_subdomainlist_iterateremove(sd_iter func, void *cookie)
+{
+	struct list_head *lh, *tmp;
+	int ret = 0;
+
+	SDLIST_WLOCK;
+	list_for_each_safe(lh, tmp, &subdomain_list) {
+		struct subdomain *node = list_entry(lh, struct subdomain, list);
+		ret = (*func) (node, cookie);
+		if (ret != 0) {
+			list_del_init(lh);
+		}
+	}
+	SDLIST_WUNLOCK;
+}
+
+/**
+ * sd_subdomainlist_release - remove all subdomains from subdomain_list
+ */
+void sd_subdomainlist_release()
+{
+	struct list_head *lh, *tmp;
+
+	SDLIST_WLOCK;
+	list_for_each_safe(lh, tmp, &subdomain_list) {
+		list_del_init(lh);
+	}
+	SDLIST_WUNLOCK;
+}
+
+static void *p_start(struct seq_file *f, loff_t *pos)
+{
+	struct list_head *lh;
+	loff_t l = *pos;
+
+	LIST_RLOCK;
+	list_for_each(lh, &profile_list)
+		if (!l--)
+			return list_entry(lh, struct sdprofile, list);
+	return NULL;
+}
+
+static void *p_next(struct seq_file *f, void *p, loff_t *pos)
+{
+	struct list_head *lh = ((struct sdprofile *)p)->list.next;
+	(*pos)++;
+	return lh == &profile_list ? NULL : list_entry(lh, struct sdprofile, list);
+}
+
+static void p_stop(struct seq_file *f, void *v)
+{
+	LIST_RUNLOCK;
+}
+
+static int seq_show_profile(struct seq_file *f, void *v)
+{
+	struct sdprofile *profile = (struct sdprofile *)v;
+	seq_printf(f, "%s (%s)\n", profile->name,
+		   PROFILE_COMPLAIN(profile) ? "complain" : "enforce");
+	return 0;
+}
+
+struct seq_operations subdomainfs_profiles_op = {
+	.start =	p_start,
+	.next =		p_next,
+	.stop =		p_stop,
+	.show =		seq_show_profile,
+};
Index: linux-2.6.14/security/subdomain/lsm.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/lsm.c
@@ -0,0 +1,867 @@
+/*
+ *	Copyright (C) 2002-2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	Immunix SubDomain LSM interface
+ */
+
+#include <linux/security.h>
+#include <linux/module.h>
+
+/* superblock types */
+
+/* PIPEFS_MAGIC */
+#include <linux/pipe_fs_i.h>
+/* from net/socket.c */
+#define SOCKFS_MAGIC 0x534F434B
+/* from inotify.c  */
+#define INOTIFYFS_MAGIC 0xBAD1DEA
+
+#define VALID_FSTYPE(inode) ((inode)->i_sb->s_magic != PIPEFS_MAGIC && \
+                             (inode)->i_sb->s_magic != SOCKFS_MAGIC && \
+                             (inode)->i_sb->s_magic != INOTIFYFS_MAGIC)
+
+#include <asm/mman.h>
+
+#include "subdomain.h"
+#include "inline.h"
+
+/* main SD lock, manipulated by SD_[RW]LOCK and SD_[RW]UNLOCK (see subdomain.h) */
+rwlock_t sd_lock = RW_LOCK_UNLOCKED;
+
+/* Flag values, also controllable via subdomainfs/control. We
+ * explicitly do not allow these to be modifiable when exported via
+ * /sys/modules/parameters, as we want to do additional mediation and
+ * don't want to add special path code. */
+
+/* Complain mode (used to be 'bitch' mode) */
+int subdomain_complain = 0;
+/* Debug mode */
+int subdomain_debug = 0;
+/* Audit mode */
+int subdomain_audit = 0;
+
+module_param_named(complain, subdomain_complain, int, S_IRUSR);
+MODULE_PARM_DESC(subdomain_complain, "Toggle SubDomain Complain Mode");
+module_param_named(debug, subdomain_debug, int, S_IRUSR);
+MODULE_PARM_DESC(subdomain_debug, "Toggle SubDomain Debug Mode");
+module_param_named(audit, subdomain_audit, int, S_IRUSR);
+MODULE_PARM_DESC(subdomain_audit, "Toggle SubDomain Audit Mode");
+#ifndef MODULE
+static int __init sd_complainmode(char *str)
+{
+	get_option(&str, &subdomain_complain);
+	return 1;
+}
+
+__setup("subdomain_complain=", sd_complainmode);
+
+static int __init sd_debugmode(char *str)
+{
+	get_option(&str, &subdomain_debug);
+	return 1;
+}
+
+__setup("subdomain_debug=", sd_debugmode);
+
+static int __init sd_auditmode(char *str)
+{
+	get_option(&str, &subdomain_audit);
+	return 1;
+}
+
+__setup("subdomain_audit=", sd_auditmode);
+#endif
+
+static int subdomain_ptrace(struct task_struct *parent,
+			    struct task_struct *child)
+{
+	/* XXX This only protects TRACEME and ATTACH.  We used to guard
+	 * all of sys_ptrace(2)...
+	 */
+	int error;
+	struct subdomain *sd;
+
+	error = cap_ptrace(parent, child);
+
+	SD_RLOCK;
+
+	sd = SD_SUBDOMAIN(current->security);
+
+	if (!error && __sd_is_confined(sd)) {
+		SD_WARN("REJECTING access to syscall 'ptrace' (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+		error = -EPERM;
+	}
+
+	SD_RUNLOCK;
+
+	return error;
+}
+
+static int subdomain_capget(struct task_struct *target,
+			    kernel_cap_t * effective,
+			    kernel_cap_t * inheritable,
+			    kernel_cap_t * permitted)
+{
+	return cap_capget(target, effective, inheritable, permitted);
+}
+
+static int subdomain_capset_check(struct task_struct *target,
+				  kernel_cap_t *effective,
+				  kernel_cap_t *inheritable,
+				  kernel_cap_t *permitted)
+{
+	return cap_capset_check(target, effective, inheritable, permitted);
+}
+
+static void subdomain_capset_set(struct task_struct *target,
+				 kernel_cap_t *effective,
+				 kernel_cap_t *inheritable,
+				 kernel_cap_t *permitted)
+{
+	cap_capset_set(target, effective, inheritable, permitted);
+	return;
+}
+
+static int subdomain_capable(struct task_struct *tsk, int cap)
+{
+	int error;
+
+	/* cap_capable returns 0 on success, else -EPERM */
+	error = cap_capable(tsk, cap);
+
+	if (error == 0) {
+		struct subdomain *sd, sdcopy;
+
+		SD_RLOCK;
+		sd = __get_sdcopy(&sdcopy, tsk);
+		SD_RUNLOCK;
+
+		error = sd_capability(sd, cap);
+
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_sysctl(struct ctl_table *table, int op)
+{
+	int error = 0;
+	struct subdomain *sd;
+
+	SD_RLOCK;
+
+	sd = SD_SUBDOMAIN(current->security);
+
+	if ((op & 002) && __sd_is_confined(sd) && !capable(CAP_SYS_ADMIN)) {
+		SD_WARN("REJECTING access to syscall 'sysctl (write)' (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+		error = -EPERM;
+	}
+
+	SD_RUNLOCK;
+
+	return error;
+}
+
+static int subdomain_syslog(int type)
+{
+	return cap_syslog(type);
+}
+
+static int subdomain_netlink_send(struct sock *sk, struct sk_buff *skb)
+{
+	return cap_netlink_send(sk, skb);
+}
+
+static int subdomain_netlink_recv(struct sk_buff *skb)
+{
+	return cap_netlink_recv(skb);
+}
+
+static void subdomain_bprm_apply_creds(struct linux_binprm *bprm, int unsafe)
+{
+	cap_bprm_apply_creds(bprm, unsafe);
+	return;
+}
+
+static int subdomain_bprm_set_security(struct linux_binprm *bprm)
+{
+	/* handle capability bits with setuid, etc */
+	cap_bprm_set_security(bprm);
+	/* already set based on script name */
+	if (bprm->sh_bang)
+		return 0;
+	return sd_register(bprm->file);
+}
+
+static int subdomain_sb_mount(char *dev_name, struct nameidata *nd, char *type,
+			      unsigned long flags, void *data)
+{
+	int error = 0;
+	struct subdomain *sd;
+
+	SD_RLOCK;
+
+	sd = SD_SUBDOMAIN(current->security);
+
+	if (__sd_is_confined(sd)) {
+		SD_WARN("REJECTING access to syscall 'mount' (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+		error = -EPERM;
+	}
+
+	SD_RUNLOCK;
+
+	return error;
+}
+
+static int subdomain_umount(struct vfsmount *mnt, int flags)
+{
+	int error = 0;
+	struct subdomain *sd;
+
+	SD_RLOCK;
+
+	sd = SD_SUBDOMAIN(current->security);
+
+	if (__sd_is_confined(sd)) {
+		SD_WARN("REJECTING access to syscall 'umount' (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+		error = -EPERM;
+	}
+
+	SD_RUNLOCK;
+
+	return error;
+}
+
+static int subdomain_inode_mkdir(struct inode *inode, struct dentry *dentry,
+				 int mask)
+{
+	struct subdomain sdcopy, *sd;
+	int error;
+
+	sd = get_sdcopy(&sdcopy);
+
+	error = sd_perm_dentry(sd, dentry, MAY_WRITE);
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_rmdir(struct inode *inode, struct dentry *dentry)
+{
+	struct subdomain sdcopy, *sd;
+	int error;
+
+	sd = get_sdcopy(&sdcopy);
+
+	error = sd_perm_dentry(sd, dentry, MAY_WRITE | SD_MAY_LINK);
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_create(struct inode *inode, struct dentry *dentry,
+				  int mask)
+{
+	struct subdomain sdcopy, *sd;
+	int error;
+
+	sd = get_sdcopy(&sdcopy);
+
+	/* At a minimum, need write perm to create */
+	error = sd_perm_dentry(sd, dentry, MAY_WRITE);
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_link(struct dentry *old_dentry, struct inode *inode,
+				struct dentry *new_dentry)
+{
+	int error = 0;
+	struct subdomain sdcopy, *sd;
+
+	sd = get_sdcopy(&sdcopy);
+	error = sd_link(sd, new_dentry, old_dentry);
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_unlink(struct inode *inode, struct dentry *dentry)
+{
+	struct subdomain sdcopy, *sd;
+	int error;
+
+	sd = get_sdcopy(&sdcopy);
+
+	error = sd_perm_dentry(sd, dentry, MAY_WRITE | SD_MAY_LINK);
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_mknod(struct inode *inode, struct dentry *dentry,
+				 int mode, dev_t dev)
+{
+	struct subdomain sdcopy, *sd;
+	int error = 0;
+
+	sd = get_sdcopy(&sdcopy);
+
+	error = sd_perm_dentry(sd, dentry, MAY_WRITE);
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_rename(struct inode *old_inode,
+				  struct dentry *old_dentry,
+				  struct inode *new_inode,
+				  struct dentry *new_dentry)
+{
+	struct subdomain sdcopy, *sd;
+	int error = 0;
+
+	sd = get_sdcopy(&sdcopy);
+
+	error = sd_perm_dentry(sd, old_dentry,
+			       MAY_READ | MAY_WRITE | SD_MAY_LINK);
+
+	if (!error) {
+		error = sd_perm_dentry(sd, new_dentry, MAY_WRITE);
+	}
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_permission(struct inode *inode, int mask,
+				      struct nameidata *nd)
+{
+	int error = 0;
+
+	/* Do not perform check on pipes or sockets
+	 * Same as subdomain_file_permission
+	 */
+	if (VALID_FSTYPE(inode)) {
+		struct subdomain sdcopy, *sd;
+
+		sd = get_sdcopy(&sdcopy);
+		error = sd_perm_nameidata(sd, nd, mask);
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_inode_setattr(struct dentry *dentry, struct iattr *iattr)
+{
+	struct subdomain sdcopy, *sd;
+	int error = 0;
+
+	if (VALID_FSTYPE(dentry->d_inode)) {
+
+		sd = get_sdcopy(&sdcopy);
+
+		/*
+		 * Mediate any attempt to change attributes of a file
+		 * (chmod, chown, chgrp, etc)
+		 */
+		error = sd_attr(sd, dentry, iattr);
+
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_inode_setxattr(struct dentry *dentry, char *name,
+				    void *value, size_t size, int flags)
+{
+	int error = 0;
+
+	if (VALID_FSTYPE(dentry->d_inode)) {
+		struct subdomain sdcopy, *sd;
+
+		sd = get_sdcopy(&sdcopy);
+		error = sd_xattr(sd, dentry, name, MAY_WRITE);
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_inode_getxattr(struct dentry *dentry, char *name)
+{
+	int error = 0;
+
+	if (VALID_FSTYPE(dentry->d_inode)) {
+		struct subdomain sdcopy, *sd;
+
+		sd = get_sdcopy(&sdcopy);
+		error = sd_xattr(sd, dentry, name, MAY_READ);
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+static int subdomain_inode_listxattr(struct dentry *dentry)
+{
+	int error = 0;
+
+	if (VALID_FSTYPE(dentry->d_inode)) {
+		struct subdomain sdcopy, *sd;
+
+		sd = get_sdcopy(&sdcopy);
+		error = sd_xattr(sd, dentry, NULL, MAY_READ);
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_inode_removexattr(struct dentry *dentry, char *name)
+{
+	int error = 0;
+
+	if (VALID_FSTYPE(dentry->d_inode)) {
+		struct subdomain sdcopy, *sd;
+
+		sd = get_sdcopy(&sdcopy);
+		error = sd_xattr(sd, dentry, name, MAY_WRITE);
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_file_permission(struct file *file, int mask)
+{
+	struct subdomain sdcopy, *sd;
+	struct sdprofile *f_profile;
+	int error = 0;
+
+	sd = get_sdcopy(&sdcopy);
+
+	f_profile = SD_PROFILE(file->f_security);
+
+	if (__sd_is_confined(sd) && f_profile && f_profile != sd->active &&
+	    VALID_FSTYPE(file->f_dentry->d_inode))
+		error = sd_perm(sd, file->f_dentry, file->f_vfsmnt,
+				mask & (MAY_EXEC | MAY_WRITE | MAY_READ));
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_file_alloc_security(struct file *file)
+{
+	struct subdomain sdcopy, *sd;
+
+	sd = get_sdcopy(&sdcopy);
+
+	if (__sd_is_confined(sd)) {
+		file->f_security = get_sdprofile(sd->active);
+	}
+
+	put_sdcopy(sd);
+
+	return 0;
+}
+
+static void subdomain_file_free_security(struct file *file)
+{
+	struct sdprofile *p = SD_PROFILE(file->f_security);
+	put_sdprofile(p);
+}
+
+static int subdomain_file_mmap (struct file *file, unsigned long reqprot,
+ 				unsigned long prot, unsigned long flags)
+{
+	int error = 0, mask = 0;
+	struct subdomain sdcopy, *sd;
+	struct sdprofile *f_profile;
+
+	sd = get_sdcopy(&sdcopy);
+
+	f_profile = file ? SD_PROFILE(file->f_security) : NULL;
+
+	if (prot & PROT_READ)
+		mask |= MAY_READ;
+	if (prot & PROT_WRITE)
+		mask |= MAY_WRITE;
+	if (prot & PROT_EXEC)
+		mask |= MAY_EXEC;
+
+	SD_DEBUG("%s: 0x%x\n", __FUNCTION__, mask);
+
+	/* Don't check if no subdomain's, profiles haven't changed, or
+	 * mapping in the executable
+	 */
+	if (file && __sd_sub_defined(sd) &&
+	    f_profile != sd->active &&
+	    !(flags & MAP_EXECUTABLE))
+		error = sd_perm(sd, file->f_dentry, file->f_vfsmnt, mask);
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_task_alloc_security(struct task_struct *p)
+{
+	return sd_fork(p);
+}
+
+static void subdomain_task_free_security(struct task_struct *p)
+{
+	sd_release(p);
+}
+
+static int subdomain_task_post_setuid(uid_t id0, uid_t id1, uid_t id2,
+				      int flags)
+{
+	return cap_task_post_setuid(id0, id1, id2, flags);
+}
+
+static void subdomain_task_reparent_to_init(struct task_struct *p)
+{
+	cap_task_reparent_to_init(p);
+	return;
+}
+
+static int subdomain_getprocattr(struct task_struct *p, char *name, void *value,
+				 size_t size)
+{
+	int error;
+	struct subdomain sdcopy, *sd;
+	char *str = value;
+
+	/* Subdomain only supports the "current" process attribute */
+	if (strcmp(name, "current") != 0) {
+		error = -EINVAL;
+		goto out;
+	}
+
+	if (!size) {
+		error = -ERANGE;
+		goto out;
+	}
+
+	/* must be task querying itself or admin */
+	if (current != p && !capable(CAP_SYS_ADMIN)) {
+		error = -EPERM;
+		goto out;
+	}
+
+	SD_RLOCK;
+
+	sd = __get_sdcopy(&sdcopy, p);
+
+	SD_RUNLOCK;
+
+	error = sd_getprocattr(sd, str, size);
+	put_sdcopy(sd);
+
+out:
+	return error;
+}
+
+static int subdomain_setprocattr(struct task_struct *p, char *name, void *value,
+				 size_t size)
+{
+	const char *cmd_changehat = "changehat ",
+		   *cmd_setprofile = "setprofile ";
+
+	int error = -EACCES;	/* default to a perm denied */
+	char *cmd = (char *)value;
+
+	/* only support messages to current */
+	if (strcmp(name, "current") != 0) {
+		error = -EINVAL;
+		goto out;
+	}
+
+	if (!size) {
+		error = -ERANGE;
+		goto out;
+	}
+
+	/* CHANGE HAT */
+	if (size > strlen(cmd_changehat) &&
+	    strncmp(cmd, cmd_changehat, strlen(cmd_changehat)) == 0) {
+		char *hatinfo = cmd + strlen(cmd_changehat);
+		size_t infosize = size - strlen(cmd_changehat);
+
+		/* Only the current process may change it's hat */
+		if (current != p) {
+			SD_WARN("%s: Attempt by foreign task %s(%d) [user %d] to changehat of task %s(%d)\n",
+				__FUNCTION__,
+				current->comm,
+				current->pid,
+				current->uid,
+				p->comm,
+				p->pid);
+
+			error = -EACCES;
+			goto out;
+		}
+
+		error = sd_setprocattr_changehat(hatinfo, infosize);
+		if (error == 0) {
+			/* success, set return to #bytes in orig request */
+			error = size;
+		}
+
+	/* SET NEW PROFILE */
+	} else if (size > strlen(cmd_setprofile) &&
+		   strncmp(cmd, cmd_setprofile, strlen(cmd_setprofile)) == 0) {
+		int confined;
+
+		/* only an unconfined process with admin capabilities
+		 * may change the profile of another task
+		 */
+
+		if (!capable(CAP_SYS_ADMIN)) {
+			SD_WARN("%s: Unprivileged attempt by task %s(%d) [user %d] to assign new profile to task %s(%d)\n",
+				__FUNCTION__,
+				current->comm,
+				current->pid,
+				current->uid,
+				p->comm,
+				p->pid);
+			error = -EACCES;
+			goto out;
+		}
+
+		SD_RLOCK;
+		confined = sd_is_confined();
+		SD_RUNLOCK;
+
+		if (!confined) {
+			char *profile = cmd + strlen(cmd_setprofile);
+			size_t profilesize = size - strlen(cmd_setprofile);
+
+			error = sd_setprocattr_setprofile(p, profile, profilesize);
+			if (error == 0) {
+				/* success,
+				 * set return to #bytes in orig request
+				 */
+				error = size;
+			}
+		} else {
+			SD_WARN("%s: Attempt by confined task %s(%d) [user %d] to assign new profile to task %s(%d)\n",
+				__FUNCTION__,
+				current->comm,
+				current->pid,
+				current->uid,
+				p->comm,
+				p->pid);
+
+			error = -EACCES;
+		}
+	} else {
+		/* unknown operation */
+		SD_WARN("%s: Unknown setprocattr command '%.*s' by task %s(%d) [user %d] for task %s(%d)\n",
+			__FUNCTION__,
+			size < 16 ? (int)size : 16,
+			cmd,
+			current->comm,
+			current->pid,
+			current->uid,
+			p->comm,
+			p->pid);
+
+		error = -EINVAL;
+	}
+
+out:
+	return error;
+}
+
+struct security_operations subdomain_ops = {
+	.ptrace =			subdomain_ptrace,
+	.capget =			subdomain_capget,
+	.capset_check =			subdomain_capset_check,
+	.capset_set =			subdomain_capset_set,
+	.sysctl =			subdomain_sysctl,
+	.capable =			subdomain_capable,
+	.syslog =			subdomain_syslog,
+
+	.netlink_send =			subdomain_netlink_send,
+	.netlink_recv =			subdomain_netlink_recv,
+
+	.bprm_apply_creds =		subdomain_bprm_apply_creds,
+	.bprm_set_security =		subdomain_bprm_set_security,
+
+	.sb_mount =			subdomain_sb_mount,
+	.sb_umount =			subdomain_umount,
+
+	.inode_mkdir =			subdomain_inode_mkdir,
+	.inode_rmdir =			subdomain_inode_rmdir,
+	.inode_create =			subdomain_inode_create,
+	.inode_link =			subdomain_inode_link,
+	.inode_unlink =			subdomain_inode_unlink,
+	.inode_mknod =			subdomain_inode_mknod,
+	.inode_rename =			subdomain_inode_rename,
+	.inode_permission =		subdomain_inode_permission,
+	.inode_setattr =		subdomain_inode_setattr,
+	.inode_setxattr =		subdomain_inode_setxattr,
+	.inode_getxattr =		subdomain_inode_getxattr,
+	.inode_listxattr =		subdomain_inode_listxattr,
+	.inode_removexattr =		subdomain_inode_removexattr,
+	.file_permission =		subdomain_file_permission,
+	.file_alloc_security =		subdomain_file_alloc_security,
+	.file_free_security =		subdomain_file_free_security,
+	.file_mmap =			subdomain_file_mmap,
+
+	.task_alloc_security =		subdomain_task_alloc_security,
+	.task_free_security =		subdomain_task_free_security,
+	.task_post_setuid =		subdomain_task_post_setuid,
+	.task_reparent_to_init =	subdomain_task_reparent_to_init,
+
+	.getprocattr =			subdomain_getprocattr,
+	.setprocattr =			subdomain_setprocattr,
+};
+
+static int __init subdomain_init(void)
+{
+	int error = 0;
+	const char *complainmsg = ": complainmode enabled";
+
+	/*
+	 * CREATE SUBDOMAINFS
+	 */
+	if (!create_subdomainfs()) {
+		SD_ERROR("Unable to activate SubDomain filesystem\n");
+		error = -ENOENT;
+		goto createfs_out;
+	}
+
+	/*
+	 * CREATE NULL PROFILES
+	 */
+	null_profile = alloc_sdprofile();
+	null_complain_profile = alloc_sdprofile();
+	if (!null_profile || !null_complain_profile) {
+		SD_ERROR("Unable to allocate null profiles\n");
+		error = -ENOMEM;
+		goto dealloc_out;
+	}
+
+	null_profile->name = kstrdup("null-profile", GFP_KERNEL);
+	null_complain_profile->name = kstrdup("null-complain-profile", GFP_KERNEL);
+	if (!null_profile->name || !null_complain_profile->name) {
+		error = -ENOMEM;
+		goto dealloc_out;
+	}
+
+	get_sdprofile(null_profile);
+	get_sdprofile(null_complain_profile);
+	null_complain_profile->flags.complain = 1;
+
+	/*
+	 * REGISTER SubDomain WITH LSM
+	 */
+	if ((error = register_security(&subdomain_ops))) {
+		SD_WARN("Unable to load SubDomain\n");
+		goto dealloc_out;
+	}
+	SD_INFO("SubDomain (version %s) initialized%s\n",
+		subdomain_version(),
+		subdomain_complain ? complainmsg : "");
+
+	/* DONE */
+	return error;
+
+dealloc_out:
+	if (!null_complain_profile) {
+		free_sdprofile(null_complain_profile);
+		null_complain_profile = NULL;
+	}
+
+	if (!null_profile) {
+		free_sdprofile(null_profile);
+		null_profile = NULL;
+	}
+	(void)destroy_subdomainfs();
+
+createfs_out:
+	return error;
+
+}
+
+static int subdomain_exit_removeall_iter(struct subdomain *sd, void *cookie)
+{
+	/* SD_WLOCK held here */
+
+	if (__sd_is_confined(sd)) {
+		SD_DEBUG("%s: Dropping profiles %s(%d) profile %s(%p) active %s(%p)\n",
+			 __FUNCTION__,
+			 sd->task->comm, sd->task->pid,
+			 sd->profile->name, sd->profile,
+			 sd->active->name, sd->active);
+		sd_switch_unconfined(sd);
+	}
+
+	return 0;
+}
+
+static void __exit subdomain_exit(void)
+{
+	/* Remove profiles from the global profile list.
+	 * This is just for tidyness as there is no way to reference this
+	 * list once the SubDomain lsm hooks are detached (below)
+	 */
+	sd_profilelist_release();
+
+	/* Remove profiles from active tasks
+	 * If this is not done,  if module is reloaded after being removed,
+	 * old profiles (still refcounted in memory) will become 'magically'
+	 * reattached
+	 */
+
+	SD_WLOCK;
+	sd_subdomainlist_iterate(subdomain_exit_removeall_iter, NULL);
+	SD_WUNLOCK;
+
+	/* Free up list of active subdomain */
+	sd_subdomainlist_release();
+
+	put_sdprofile(null_complain_profile);
+	put_sdprofile(null_profile);
+	if (!destroy_subdomainfs())
+		SD_WARN("Unable to properly deactivate SubDomain fs\n");
+
+	if (unregister_security(&subdomain_ops))
+		SD_WARN("Unable to properly unregister SubDomain\n");
+	SD_INFO("SubDomain protection removed\n");
+}
+
+security_initcall(subdomain_init);
+module_exit(subdomain_exit);
+
+MODULE_DESCRIPTION("SubDomain process confinement");
+MODULE_AUTHOR("SuSE/Novell <apparmor-general@forge.novell.com>");
+MODULE_LICENSE("GPL");
Index: linux-2.6.14/security/subdomain/main.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/main.c
@@ -0,0 +1,1493 @@
+/*
+ *	Copyright (C) 2002-2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	SubDomain Core
+ */
+
+#include <linux/security.h>
+#include <linux/namei.h>
+
+#include "immunix.h"
+#include "subdomain.h"
+#include "sdmatch/match.h"
+
+#include "inline.h"
+
+/* NULL profile
+ *
+ * Used when an attempt is made to changehat into a non-existant
+ * subhat.   In the NULL profile,  no file access is allowed
+ * (currently full network access is allowed).  Using a NULL
+ * profile ensures that active is always non zero.
+ *
+ * Leaving the NULL profile is by either successfully changehatting
+ * into a sibling hat, or changehatting back to the parent (NULL hat).
+ */
+struct sdprofile *null_profile;
+
+/* NULL complain profile
+ *
+ * Used when in complain mode, to emit Permitting messages for non-existant
+ * profiles and hats.  This is necessary because of selective mode, in which
+ * case we need a complain null_profile and enforce null_profile
+ *
+ * The null_complain_profile cannot be statically allocated, because it
+ * can be associated to files which keep their reference even if subdomain is
+ * unloaded
+ */
+struct sdprofile *null_complain_profile;
+
+/* temp define for syslog workaround */
+#define SYSLOG_TEMPFIX
+
+/***************************
+ * PRIVATE UTILITY FUNCTIONS
+ **************************/
+
+#ifdef SYSLOG_TEMPFIX
+/* Horrible hack
+ * Syslog (not syslog-ng) has a bug where it escapes uneven numbers of %
+ * symbols.  So we force an enen number here by escaping.
+ * This code will GO AWAY once syslog bug is fixed
+ */
+static __INLINE__ const char *_escape_percent(const char *name)
+{
+	int count = 0, len = 0;
+	const char *sptr;
+	char *dptr, *newname = (char *)name;
+
+	sptr = name;
+	while (*sptr) {
+		if (*sptr == '%')
+			count++;
+
+		len++;
+		sptr++;
+	}
+
+	if (count) {
+		newname = kmalloc(len + count + 1, GFP_KERNEL);
+		if (newname) {
+			sptr = name;
+			dptr = newname;
+
+			while (*sptr) {
+				if (*sptr == '%') {
+					*dptr++ = '%';
+				}
+
+				*dptr++ = *sptr++;
+			}
+			*dptr = 0;
+		}
+	}
+
+	return (const char *)newname;
+}
+#endif // SYSLOG_TEMPFIX
+
+/*
+ * sd_taskattr_access:
+ * @name: name of file to check permission
+ * @mask: permission mask requested for file
+ *
+ * Determine if request is for write access to /proc/self/attr/current
+ */
+static __INLINE__ int sd_taskattr_access(const char *procrelname)
+{
+/*
+ * assumes a 32bit pid, which requires max 10 decimal digits to represent
+ * sizeof includes trailing \0
+ */
+	char buf[sizeof("/attr/current") + 10];
+	const int maxbuflen = sizeof(buf);
+
+	snprintf(buf, maxbuflen, "%d/attr/current", current->pid);
+	buf[maxbuflen - 1] = 0;
+
+	return strcmp(buf, procrelname) == 0;
+}
+
+/**
+ * sd_file_mode - get full mode for file entry from profile
+ * @profile: profile
+ * @name: filename
+ */
+static __INLINE__ int sd_file_mode(struct sdprofile *profile, const char *name)
+{
+	struct list_head *lh;
+	int mode = 0;
+
+	SD_DEBUG("%s: %s\n", __FUNCTION__, name);
+	if (!name) {
+		SD_DEBUG("%s: no name\n", __FUNCTION__);
+		goto out;
+	}
+
+	if (!profile) {
+		SD_DEBUG("%s: no profile\n", __FUNCTION__);
+		goto out;
+	}
+	list_for_each(lh, &profile->file_entry) {
+		struct sd_entry *entry = list_entry(lh, struct sd_entry, list);
+
+		if (sdmatch_match(name, entry->filename,
+				  entry->entry_type, entry->extradata))
+			mode |= entry->mode;
+	}
+out:
+	return mode;
+}
+
+/*
+ * sd_get_execmode - calculate what qualifier to apply to an exec
+ * @sd: subdomain to search
+ * @name: name of file to exec
+ * @xmod: pointer to a execution mode bit for the rule that was matched
+ *         if the rule has no execuition qualifier {pui} then
+ *         SD_MAY_EXEC is returned indicating a naked x
+ *         if the has an exec qualifier then only the qualifier bit {pui}
+ *         is returned (SD_MAY_EXEC) is not set.
+ *
+ * Returns 0 (false):
+ *    if unable to find profile or there are conflicting pattern matches.
+ *       *xmod - is not modified
+ *
+ * Returns 1 (true):
+ *    if not confined
+ *       *xmod = SD_MAY_EXEC
+ *    if exec rule matched
+ *       if the rule has an execution mode qualifier {pui} then
+ *          *xmod = the execution qualifier of the rule {pui}
+ *       else
+ *          *xmod = SD_MAY_EXEC
+ */
+static __INLINE__ int sd_get_execmode(struct subdomain *sd, const char *name,
+				      int *xmod)
+{
+	struct sdprofile *profile;
+	struct list_head *lh;
+	struct sd_entry *match = NULL;
+
+	int pattern_match_invalid = 0, rc = 0;
+
+	/* not confined */
+	if (!__sd_is_confined(sd)) {
+		SD_DEBUG("%s: not confined\n", __FUNCTION__);
+		goto not_confined;
+	}
+
+	profile = sd->active;
+
+	/* search list of profiles with 'x' permission
+	 * this will also include entries with 'p', 'u' and 'i'
+	 * qualifiers.
+	 *
+	 * If we find a pattern match we will keep looking for an exact match
+	 * If we find conflicting pattern matches we will flag (while still
+	 * looking for an exact match).  If all we have is a conflict, FALSE
+	 * is returned.
+	 */
+
+	list_for_each(lh, &profile->file_entryp[POS_SD_MAY_EXEC]) {
+		struct sd_entry *entry;
+		entry = list_entry(lh, struct sd_entry,
+				   listp[POS_SD_MAY_EXEC]);
+		if (!pattern_match_invalid &&
+		    entry->entry_type == sd_entry_pattern &&
+		    sdmatch_match(name, entry->filename,
+				  entry->entry_type, entry->extradata)) {
+			if (match &&
+			    SD_EXEC_MASK(entry->mode) != SD_EXEC_MASK(match->mode)) {
+				pattern_match_invalid = 1;
+			} else {
+				/* got a pattern match, keep searching for an
+				 * exact match
+				 */
+				match = entry;
+			}
+		} else if ((entry->entry_type == sd_entry_literal ||
+			    (!pattern_match_invalid &&
+			     entry->entry_type == sd_entry_tailglob)) &&
+			    sdmatch_match(name, entry->filename,
+					  entry->entry_type,
+					  entry->extradata)) {
+			if (entry->entry_type == sd_entry_literal) {
+				/* got an exact match -- there can be only
+				 * one, asserted a profile load time
+				 */
+				match = entry;
+				pattern_match_invalid = 0;
+				break;
+			} else {
+				if (match &&
+				    SD_EXEC_MASK(entry->mode) != SD_EXEC_MASK(match->mode)) {
+					pattern_match_invalid = 1;
+				} else {
+					/* got a tailglob match, keep searching
+					 * for an exact match
+					 */
+					match = entry;
+				}
+			}
+		}
+
+	}
+
+	rc = match && !pattern_match_invalid;
+
+	if (rc) {
+		int mode = SD_EXEC_MASK(match->mode);
+
+		/* check for qualifiers, if present
+		 * we just return the qualifier
+		 */
+		if (mode & ~SD_MAY_EXEC) {
+			mode = mode & ~SD_MAY_EXEC;
+		}
+
+		*xmod = mode;
+	} else if (!match) {
+		SD_DEBUG("%s: Unable to find execute entry in profile for image '%s'\n",
+			 __FUNCTION__,
+			 name);
+	} else if (pattern_match_invalid) {
+		SD_WARN("%s: Inconsistency in profile %s. Two (or more) patterns specify conflicting exec qualifiers ('u', 'i' or 'p') for image %s\n",
+			__FUNCTION__,
+			sd->active->name,
+			name);
+	}
+
+	return rc;
+
+not_confined:
+	*xmod = SD_MAY_EXEC;
+	return 1;
+}
+
+/**
+ * sd_filter_mask
+ * @mask: requested mask
+ * @inode: potential directory inode
+ *
+ * This fn performs pre-verification of the requested mask
+ * We ignore append. Previously we required 'w' on a dir to add a file.
+ * No longer. Now we require 'w' on just the file itself. Traversal 'x' is
+ * also ignored for directories.
+ *
+ * Returned value of 0 indicates no need to perform a perm check.
+ */
+static __INLINE__ int sd_filter_mask(int mask, struct inode *inode)
+{
+	if (mask) {
+		int elim=MAY_APPEND;
+
+		if (inode && S_ISDIR(inode->i_mode))
+			elim |= (MAY_EXEC | MAY_WRITE);
+
+		mask &= ~elim;
+	}
+
+	return mask;
+}
+
+/****************************
+ * INTERNAL TRACING FUNCTIONS
+ ***************************/
+
+/**
+ * sd_attr_trace - trace attempt to change file attributes
+ * @sd: SubDomain to check against
+ * @name: file requested
+ * @iattr: requested new modes
+ * @error: error flag
+ *
+ * Prints out the status of the attribute change request.  Only prints
+ * accepted when in audit mode.
+ */
+static __INLINE__ void sd_attr_trace(struct subdomain *sd, const char *name,
+				     struct iattr *iattr, int error)
+{
+	const char *status = "AUDITING";
+#ifdef SYSLOG_TEMPFIX
+	const char *newname;
+#endif
+
+	if (error) {
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+	} else if (!SUBDOMAIN_AUDIT(sd)) {
+		return;
+	}
+#ifdef SYSLOG_TEMPFIX
+	newname = _escape_percent(name);
+
+	SD_WARN("%s%s attribute (%s%s%s%s%s%s%s) change to %s (%s(%d) profile %s active %s)\n",
+		status,
+		newname != name ? "-SYSLOGFIX" : "",
+		iattr->ia_valid & ATTR_MODE ? "mode," : "",
+		iattr->ia_valid & ATTR_UID ? "uid," : "",
+		iattr->ia_valid & ATTR_GID ? "gid," : "",
+		iattr->ia_valid & ATTR_SIZE ? "size," : "",
+		((iattr->ia_valid & ATTR_ATIME_SET)
+		 || (iattr->ia_valid & ATTR_ATIME)) ? "atime," : "",
+		((iattr->ia_valid & ATTR_MTIME_SET)
+		 || (iattr->ia_valid & ATTR_MTIME)) ? "mtime," : "",
+		iattr->ia_valid & ATTR_CTIME ? "ctime," : "",
+		newname ? newname : "KMALLOC-ERROR",
+		current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+
+	if (newname != name)
+		kfree(newname);
+#else
+	SD_WARN("%s attribute (%s%s%s%s%s%s%s) change to %s (%s(%d) profile %s active %s)\n",
+		status,
+		iattr->ia_valid & ATTR_MODE ? "mode," : "",
+		iattr->ia_valid & ATTR_UID ? "uid," : "",
+		iattr->ia_valid & ATTR_GID ? "gid," : "",
+		iattr->ia_valid & ATTR_SIZE ? "size," : "",
+		((iattr->ia_valid & ATTR_ATIME_SET)
+		 || (iattr->ia_valid & ATTR_ATIME)) ? "atime," : "",
+		((iattr->ia_valid & ATTR_MTIME_SET)
+		 || (iattr->ia_valid & ATTR_MTIME)) ? "mtime," : "",
+		iattr->ia_valid & ATTR_CTIME ? "ctime," : "",
+		name, current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+#endif
+}
+
+/**
+ * sd_xattr_trace - trace attempt to change file attributes
+ * @sd: SubDomain to check against
+ * @name: file requested
+ * @iattr: requested new modes
+ * @error: error flag
+ *
+ * Prints out the status of the attribute change request.  Only prints
+ * accepted when in audit mode.
+ */
+static __INLINE__ void sd_xattr_trace(struct subdomain *sd, const char *name,
+				      const char *xattr, int mask, int error)
+{
+	const char *status = "AUDITING";
+
+	if (error) {
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+	} else if (!SUBDOMAIN_AUDIT(sd)) {
+		return;
+	}
+
+	SD_WARN("%s %s%s access to %s extended attribute %s (%s(%d) profile %s active %s)\n",
+		status,
+		mask & SD_MAY_READ  ? "r" : "",
+		mask & SD_MAY_WRITE ? "w" : "",
+		name, xattr,
+		current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+}
+
+/**
+ * sd_file_perm_trace - trace permission
+ * @sd: SubDomain to check against
+ * @name: file requested
+ * @mask: requested permission
+ * @error: error flag
+ *
+ * Prints out the status of the permission request.  Only prints
+ * accepted when in audit mode.
+ */
+static __INLINE__ void sd_file_perm_trace(struct subdomain *sd,
+					  const char *name, int mask, int error)
+{
+	const char *status = "AUDITING";
+#ifdef SYSLOG_TEMPFIX
+	const char *newname;
+#endif
+
+	if (error) {
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+	} else if (!SUBDOMAIN_AUDIT(sd)) {
+		return;
+	}
+#ifdef SYSLOG_TEMPFIX
+	newname = _escape_percent(name);
+
+	SD_WARN("%s%s %s%s%s%s access to %s (%s(%d) profile %s active %s)\n",
+		status,
+		newname != name ? "-SYSLOGFIX"  : "",
+		mask & SD_MAY_READ  ? "r" : "",
+		mask & SD_MAY_WRITE ? "w" : "",
+		mask & SD_MAY_EXEC  ? "x" : "",
+		mask & SD_MAY_LINK  ? "l" : "",
+		newname ? newname : "KMALLOC-ERROR",
+		current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+
+	if (newname != name)
+		kfree(newname);
+#else
+	SD_WARN("%s %s%s%s%s access to %s (%s(%d) profile %s active %s)\n",
+		status,
+		mask & SD_MAY_READ  ? "r" : "",
+		mask & SD_MAY_WRITE ? "w" : "",
+		mask & SD_MAY_EXEC  ? "x" : "",
+		mask & SD_MAY_LINK  ? "l" : "",
+		name, current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+#endif
+}
+
+/**
+ * sd_link_perm_trace - trace link permission
+ * @sd: current SubDomain
+ * @lname: name requested as new link
+ * @tname: name requested as new link's target
+ * @error: error status
+ *
+ * Prints out the status of the permission request.  Only prints
+ * accepted when in audit mode.
+ */
+static __INLINE__ void sd_link_perm_trace(struct subdomain *sd,
+					  const char *lname, const char *tname,
+					  int error)
+{
+	const char *status = "AUDITING";
+#ifdef SYSLOG_TEMPFIX
+	const char *newlname,
+	     	   *newtname;
+#endif
+
+	if (error) {
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+	} else if (!SUBDOMAIN_AUDIT(sd)) {
+		return;
+	}
+#ifdef SYSLOG_TEMPFIX
+	newlname = _escape_percent(lname);
+	newtname = _escape_percent(tname);
+
+	SD_WARN("%s%s link access from %s to %s (%s(%d) profile %s active %s)\n",
+		status,
+		newlname != lname || newtname != tname ? "-SYSLOGFIX" : "",
+		newlname ? newlname : "KMALLOC-ERROR",
+		newtname ? newtname : "KMALLOC-ERROR",
+		current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+
+	if (newlname != lname)
+		kfree(newlname);
+
+	if (newtname != tname)
+		kfree(newtname);
+#else
+	SD_WARN("%s link access from %s to %s (%s(%d) profile %s active %s)\n",
+		status, lname, tname, current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+#endif
+}
+
+/*************************
+ * MAIN INTERNAL FUNCTIONS
+ ************************/
+
+/**
+ * sd_link_perm - test permission to link to a file
+ * @sd: current SubDomain
+ * @link: name of link being created
+ * @target: name of target to be linked to
+ *
+ * Look up permission mode on both @link and @target.  @link must have same
+ * permission mode as @target.  At least @link must have the link bit enabled.
+ * Return 0 on success, error otherwise.
+ */
+static int sd_link_perm(struct subdomain *sd,
+			const char *link, const char *target)
+{
+	int l_mode, t_mode, error = -EPERM;
+	struct sdprofile *profile = sd->active;
+
+	error = -EPERM;
+	l_mode = sd_file_mode(profile, link);
+	if (!(l_mode & SD_MAY_LINK))
+		goto out;
+	/* ok, mask off link bit */
+	l_mode &= ~SD_MAY_LINK;
+
+	t_mode = sd_file_mode(profile, target);
+	t_mode &= ~SD_MAY_LINK;
+
+	if (l_mode == t_mode)
+		error = 0;
+
+out:
+	sd_link_perm_trace(sd, link, target, error);
+	if (SUBDOMAIN_COMPLAIN(sd)) {
+		error = 0;
+	}
+	return error;
+}
+
+/**************************
+ * GLOBAL UTILITY FUNCTIONS
+ *************************/
+
+/**
+ * __sd_get_name - retrieve fully qualified path name
+ * @dentry: relative path element
+ * @mnt: where in tree
+ *
+ * Returns fully qualified path name on sucess, NULL on failure.
+ * sd_put_name must be used to free allocated buffer.
+ */
+char *__sd_get_name(struct dentry *dentry, struct vfsmount *mnt)
+{
+	char *page, *name = NULL;
+
+	page = (char *)__get_free_page(GFP_KERNEL);
+	if (!page)
+		goto out;
+
+	name = d_path(dentry, mnt, page, PAGE_SIZE);
+
+	/* check for (deleted) that d_path appends to pathnames if the dentry
+	 * has been removed from the cache.
+	 * The size > deleted_size and strcmp checks are redundant safe guards.
+	 */
+	if (name) {
+		const char deleted_str[] = " (deleted)";
+		const size_t deleted_size = sizeof(deleted_str) - 1;
+		size_t size;
+		size = strlen(name);
+		if (!IS_ROOT(dentry) && d_unhashed(dentry) &&
+		    size > deleted_size &&
+		    strcmp(name + size - deleted_size, deleted_str) == 0)
+			name[size - deleted_size] = '\0';
+	}
+	SD_DEBUG("%s: full_path=%s\n", __FUNCTION__, name);
+out:
+	return name;
+}
+
+/***********************************
+ * GLOBAL PERMISSION CHECK FUNCTIONS
+ ***********************************/
+
+/*
+ * sd_file_perm - calculate access mode for file
+ * @subdomain: current subdomain
+ * @name: name of file to calculate mode for
+ * @mask: permission mask requested for file
+ * @log:  log errors
+ *
+ * Search the sd_entry list in @profile.
+ * Search looking to verify all permissions passed in mask.
+ * Perform the search by looking at the partitioned list of entries, one
+ * partition per permission bit.
+ * Return 0 on access allowed, < 0 on error.
+ */
+int sd_file_perm(struct subdomain *sd, const char *name, int mask, int log)
+{
+	struct sdprofile *profile;
+	int i, error, mode;
+
+#define PROCPFX "/proc/"
+#define PROCLEN sizeof(PROCPFX) - 1
+
+	SD_DEBUG("%s: %s 0x%x\n", __FUNCTION__, name, mask);
+
+	error = 0;
+
+	// should not enter with other than R/W/X/L
+	BUG_ON(mask & ~(SD_MAY_READ | SD_MAY_WRITE | SD_MAY_EXEC | SD_MAY_LINK));
+
+	/* not confined */
+	if (!__sd_is_confined(sd)) {
+		/* exit with access allowed */
+		SD_DEBUG("%s: not confined\n", __FUNCTION__);
+		goto done_notrace;
+	}
+
+	/* Special case access to /proc/self/attr/current
+	 * Currently we only allow access if opened O_WRONLY
+	 */
+	if (mask == MAY_WRITE && strncmp(PROCPFX, name, PROCLEN) == 0 &&
+	    (!list_empty(&sd->profile->sub) || SUBDOMAIN_COMPLAIN(sd)) &&
+	    sd_taskattr_access(name + PROCLEN)) {
+		goto done_notrace;
+	}
+
+	error = -EACCES;
+
+	profile = sd->active;
+
+	mode = 0;
+
+	/* iterate over partition, one permission bit at a time */
+	for (i = 0; i <= POS_SD_FILE_MAX; i++) {
+		struct list_head *lh;
+
+		/* do we have to accumulate this bit?
+		 * or have we already accumulated it (shortcut below)? */
+		if (!(mask & (1 << i)) || mode & (1 << i)) {
+			continue;
+		}
+
+		list_for_each(lh, &profile->file_entryp[i]) {
+			struct sd_entry *entry;
+			entry = list_entry(lh, struct sd_entry, listp[i]);
+
+			if (sdmatch_match(name, entry->filename,
+				entry->entry_type, entry->extradata)) {
+				/* Shortcut, accumulate all bits present */
+				mode |= entry->mode;
+
+				/*
+				 * Mask bits are overloaded
+				 * MAY_{EXEC,WRITE,READ,APPEND} are used by
+				 * kernel, other values are used locally only.
+				 */
+				if ((mode & mask) == mask) {
+					SD_DEBUG("MATCH! %s=0x%x [total mode=0x%x]\n",
+						 name, mask, mode);
+
+					error = 0;
+					goto done;
+				}
+			}
+		}
+	}
+	/* error: only log permissions that weren't granted */
+	mask &= ~mode;
+
+done:
+	if (log) {
+		sd_file_perm_trace(sd, name, mask, error);
+
+		if (SUBDOMAIN_COMPLAIN(sd)) {
+			error = 0;
+		}
+	}
+
+done_notrace:
+	return error;
+}
+
+/**
+ * sd_attr - check whether attribute change allowed
+ * @sd: SubDomain to check against to check against
+ * @dentry: file to check
+ * @iattr: attribute changes requested
+ *
+ * This function is a replica of sd_perm. In fact, calling sd_perm(MAY_WRITE)
+ * will achieve the same access control, but logging would appear to indicate
+ * success/failure of a "w" rather than an attribute change.  Also, this way we
+ * can log a single message indicating success/failure and also what attribite
+ * changes were attempted.
+ */
+int sd_attr(struct subdomain *sd, struct dentry *dentry, struct iattr *iattr)
+{
+	int error = 0, sdpath_error;
+	struct sd_path_data data;
+	char *name;
+
+	/* if not confined or empty mask permission granted */
+	if (!__sd_is_confined(sd) || !iattr)
+		goto out;
+
+	/* search all paths to dentry */
+
+	sd_path_begin(dentry, &data);
+	do {
+		name = sd_path_getname(&data);
+		if (name) {
+			error = sd_file_perm(sd, name, MAY_WRITE, 0);
+
+			/* access via any path is enough */
+			if (error) {
+				sd_attr_trace(sd, name, iattr, error);
+			}
+
+			sd_put_name(name);
+
+			if (!error) {
+				break;
+			}
+		}
+
+	} while (name);
+
+	if ((sdpath_error = sd_path_end(&data)) != 0) {
+		SD_ERROR("%s: An error occured while translating dentry %p inode# %lu to a pathname. Error %d\n",
+			 __FUNCTION__,
+			 dentry,
+			 dentry->d_inode->i_ino,
+			 sdpath_error);
+
+		error = sdpath_error;
+	}
+
+	if (SUBDOMAIN_COMPLAIN(sd)) {
+		error = 0;
+	}
+
+out:
+	return error;
+}
+
+int sd_xattr(struct subdomain *sd, struct dentry *dentry, const char *attr,
+	     int flags)
+{
+	int error = 0, sdpath_error;
+	struct sd_path_data data;
+	char *name;
+
+	/* if not confined or empty mask permission granted */
+	if (!__sd_is_confined(sd))
+		goto out;
+
+	/* search all paths to dentry */
+
+	sd_path_begin(dentry, &data);
+	do {
+		name = sd_path_getname(&data);
+		if (name) {
+			error = sd_file_perm(sd, name, flags, 0);
+
+			/* access via any path is enough */
+			if (error)
+				sd_xattr_trace(sd, name, attr, flags, error);
+
+			sd_put_name(name);
+
+			if (!error)
+				break;
+		}
+
+	} while (name);
+
+	if ((sdpath_error = sd_path_end(&data)) != 0) {
+		SD_ERROR("%s: An error occured while translating dentry %p inode# %lu to a pathname. Error %d\n",
+			 __FUNCTION__,
+			 dentry,
+			 dentry->d_inode->i_ino,
+			 sdpath_error);
+
+		error = sdpath_error;
+	}
+
+	if (SUBDOMAIN_COMPLAIN(sd))
+		error = 0;
+
+out:
+	return error;
+}
+
+/**
+ * sd_perm - basic SubDomain permissions check
+ * @sd: SubDomain to check against
+ * @dentry: dentry
+ * @mnt: mountpoint
+ * @mask: access mode requested
+ *
+ * This checks that the @inode is in the current subdomain, @sd, and
+ * that it can be accessed in the mode requested by @mask.  Returns 0 on
+ * success.
+ */
+int sd_perm(struct subdomain *sd, struct dentry *dentry, struct vfsmount *mnt,
+	    int mask)
+{
+	char *name = NULL;
+	int error = 0;
+
+	if (!__sd_is_confined(sd))
+		goto out;
+
+	if ((mask = sd_filter_mask(mask, dentry->d_inode)) == 0)
+		goto out;
+
+	error = -ENOMEM;
+
+	name = __sd_get_name(dentry, mnt);
+	if (name) {
+		error = sd_file_perm(sd, name, mask, 1);
+		sd_put_name(name);
+	}
+
+out:
+	return error;
+}
+
+/**
+ * sd_perm_nameidata: interface to sd_perm accepting nameidata
+ * @sd: SubDomain to check against
+ * @nd: namespace data (for vfsmnt and dentry)
+ * @mask: access mode requested
+ */
+int sd_perm_nameidata(struct subdomain *sd, struct nameidata *nd, int mask)
+{
+	int error = 0;
+
+	if (nd)
+		error = sd_perm(sd, nd->dentry, nd->mnt, mask);
+
+	return error;
+}
+
+int sd_perm_dentry(struct subdomain *sd, struct dentry *dentry, int mask)
+{
+	char *name;
+	struct sd_path_data data;
+	int error = 0, sdpath_error;
+
+	if (!__sd_is_confined(sd))
+		goto out;
+
+	if ((mask = sd_filter_mask(mask, dentry->d_inode)) == 0)
+		goto out;
+
+	/* search all paths to dentry */
+
+	sd_path_begin(dentry, &data);
+	do {
+		name = sd_path_getname(&data);
+		if (name) {
+			error = sd_file_perm(sd, name, mask, 1);
+			sd_put_name(name);
+
+			/* access via any path is enough */
+			if (!error)
+				break;
+		}
+	} while (name);
+
+	if ((sdpath_error = sd_path_end(&data)) != 0) {
+		SD_ERROR("%s: An error occured while translating dentry %p inode# %lu to a pathname. Error %d\n",
+			 __FUNCTION__,
+			 dentry,
+			 dentry->d_inode->i_ino,
+			 sdpath_error);
+
+		error = sdpath_error;
+	}
+
+out:
+	return error;
+}
+
+/**
+ * sd_capability - test permission to use capability
+ * @sd: SubDomain to check against
+ * @cap: capability to be tested
+ *
+ * Look up capability in active profile capability set.
+ * Return 0 if valid, -EPERM if invalid
+ */
+
+int sd_capability(struct subdomain *sd, int cap)
+{
+	int error = 0;
+
+	if (__sd_is_confined(sd)) {
+		const char *status;
+
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+
+		error = cap_raised(sd->active->capabilities, cap) ? 0 : -EPERM;
+
+		if (error || SUBDOMAIN_AUDIT(sd)) {
+			if (error == 0) {	/* AUDIT */
+				status = "AUDITING";
+			}
+
+			SD_WARN("%s access to capability '%s' (%s(%d) profile %s active %s)\n",
+				status,
+				capability_to_name(cap),
+				current->comm, current->pid,
+				sd->profile->name, sd->active->name);
+
+			if (SUBDOMAIN_COMPLAIN(sd)) {
+				error = 0;
+			}
+		}
+	}
+
+	return error;
+}
+
+/**
+ * sd_link - hard link check
+ * @link: dentry for link being created
+ * @target: dentry for link target
+ * @sd: SubDomain to check against
+ *
+ * Checks link permissions for all possible name combinations.  This is
+ * particularly ugly.  Returns 0 on sucess, error otherwise.
+ */
+int sd_link(struct subdomain *sd, struct dentry *link, struct dentry *target)
+{
+	char *iname, *oname;
+	struct sd_path_data idata, odata;
+	int error = 0, sdpath_error, done;
+
+	if (!__sd_is_confined(sd))
+		goto out;
+
+	/* Perform nested lookup for names.
+	 * This is necessary in the case where /dev/block is mounted
+	 * multiple times,  i.e /dev/block->/a and /dev/block->/b
+	 * This allows us to detect links where src/dest are on different
+	 * mounts.   N.B no support yet for links across bind mounts of
+	 * the form mount -bind /mnt/subpath /mnt2
+	 */
+
+	done = 0;
+	sd_path_begin2(target, link, &odata);
+	do {
+		oname = sd_path_getname(&odata);
+
+		if (oname) {
+			sd_path_begin(target, &idata);
+			do {
+				iname = sd_path_getname(&idata);
+				if (iname) {
+					error = sd_link_perm(sd, oname, iname);
+					sd_put_name(iname);
+
+					/* access via any path is enough */
+					if (!error) {
+						done = 1;
+					}
+				}
+			} while (!done && iname);
+
+			if ((sdpath_error = sd_path_end(&idata)) != 0) {
+				SD_ERROR("%s: An error occured while translating inner dentry %p inode %lu to a pathname. Error %d\n",
+					 __FUNCTION__,
+					 target,
+					 target->d_inode->i_ino,
+					 sdpath_error);
+
+				(void)sd_path_end(&odata);
+				error = sdpath_error;
+				goto out;
+			}
+			sd_put_name(oname);
+
+		} // name
+
+	} while (!done && oname);
+
+	if ((sdpath_error = sd_path_end(&odata)) != 0) {
+		SD_ERROR("%s: An error occured while translating outer dentry %p inode %lu to a pathname. Error %d\n",
+			 __FUNCTION__,
+			 link,
+			 link->d_inode->i_ino,
+			 sdpath_error);
+
+		error = sdpath_error;
+	}
+
+out:
+	return error;
+}
+
+/**********************************
+ * GLOBAL PROCESS RELATED FUNCTIONS
+ *********************************/
+
+/**
+ * sd_fork - create a new subdomain
+ * @p: new process
+ *
+ * Create a new subdomain struct for the newly created process @p.
+ * Copy parent info to child.  If parent has no subdomain, child
+ * will get one with NULL values.  Return 0 on sucess.
+ */
+
+int sd_fork(struct task_struct *p)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(current->security);
+	struct subdomain *newsd = alloc_subdomain(p);
+
+	SD_DEBUG("%s\n", __FUNCTION__);
+
+	if (!newsd)
+		return -ENOMEM;
+
+	if (sd) {
+		/* Can get away with a read rather than write lock here
+		 * as we just allocated newsd above, so we can guarantee
+		 * that it's active/profile are null and therefore a replace
+		 * cannot happen.
+		 */
+		SD_RLOCK;
+		sd_switch(newsd, sd->profile, sd->active);
+		newsd->sd_hat_magic = sd->sd_hat_magic;
+		SD_RUNLOCK;
+
+		if (SUBDOMAIN_COMPLAIN(sd) && sd->active == null_complain_profile) {
+			SD_WARN("LOGPROF-HINT fork pid=%d child=%d\n",
+				current->pid, p->pid);
+		}
+	}
+	p->security = newsd;
+	return 0;
+}
+
+/**
+ * sd_register - register a new program
+ * @filp: file of program being registered
+ *
+ * Try to register a new program during execve().  This should give the
+ * new program a valid SubDomain.
+ *
+ * This _used_ to be a really simple piece of code :-(
+ *
+ */
+int sd_register(struct file *filp)
+{
+	char *filename;
+	struct subdomain *sd, sdcopy;
+	struct sdprofile *newprofile = NULL, unconstrained_flag;
+	int 	error = -ENOMEM,
+		findprofile = 0,
+		findprofile_mandatory = 0,
+		issdcopy = 1,
+		complain = 0;
+
+	SD_DEBUG("%s\n", __FUNCTION__);
+
+	sd = get_sdcopy(&sdcopy);
+
+	/* Must have a SubDomain:
+	 * XXX  tony 10/2003
+	 * XXX  How is it possible to get here without a Subdomain?
+	 */
+	if (sd) {
+		complain = SUBDOMAIN_COMPLAIN(sd);
+	} else {
+		issdcopy = 0;
+
+		sd = alloc_subdomain(current);
+		if (!sd) {
+			SD_WARN("%s: Failed to allocate SubDomain\n",
+				__FUNCTION__);
+			goto out;
+		}
+
+		current->security = sd;
+	}
+
+	filename = __sd_get_name(filp->f_dentry, filp->f_vfsmnt);
+	if (!filename) {
+		SD_WARN("%s: Failed to get filename\n", __FUNCTION__);
+		goto out;
+	}
+
+	error = 0;
+
+	/* determine what mode inherit, unconstrained or mandatory
+	 * an image is to be loaded in
+	 */
+	if (__sd_is_confined(sd)) {
+		int exec_mode = 0;
+
+		if (sd_get_execmode(sd, filename, &exec_mode)) {
+			switch (exec_mode) {
+			case SD_EXEC_INHERIT:
+				/* do nothing - setting of profile
+				 * already handed in sd_fork
+				 */
+				SD_DEBUG("%s: INHERIT %s\n",
+					 __FUNCTION__,
+					 filename);
+				break;
+
+			case SD_EXEC_UNCONSTRAINED:
+				SD_DEBUG("%s: UNCONSTRAINED %s\n",
+					 __FUNCTION__,
+					 filename);
+
+				/* unload profile */
+				newprofile = &unconstrained_flag;
+				break;
+
+			case SD_EXEC_PROFILE:
+				SD_DEBUG("%s: PROFILE %s\n",
+					 __FUNCTION__,
+					 filename);
+
+				findprofile = 1;
+				findprofile_mandatory = 1;
+				break;
+
+			case SD_MAY_EXEC:
+				/* this should not happen, entries
+				 * with just EXEC only should be
+				 * rejected at profile load time
+				 */
+				SD_ERROR("%s: Rejecting exec(2) of image '%s'. Mode SD_MAY_EXEC without exec qualifier is invalid (internal error) (%s(%d) profile %s active %s\n",
+					 __FUNCTION__,
+					 filename,
+					 current->comm, current->pid,
+					 sd->profile->name, sd->active->name);
+				error = -EPERM;
+				break;
+
+			default:
+				SD_ERROR("%s: Rejecting exec(2) of image '%s'. Unknown exec qualifier %x (internal error) (%s (pid %d) profile %s active %s)\n",
+					 __FUNCTION__,
+					 filename,
+					 exec_mode,
+					 current->comm, current->pid,
+					 sd->profile->name, sd->active->name);
+				error = -EPERM;
+				break;
+			}
+
+		} else {	/* !sd_get_execmode(sd, filename, &exec_mode) */
+
+			if (complain) {
+				/* There was no entry in calling profile
+				 * describing mode to execute image in.
+				 * Drop into null-profile
+				 */
+				newprofile = get_sdprofile(null_complain_profile);
+			} else {
+				SD_WARN("%s: Rejecting exec(2) of image '%s', Unable to determine exec qualifier (%s (pid %d) profile %s active %s)\n",
+					__FUNCTION__,
+					filename,
+					current->comm, current->pid,
+					sd->profile->name, sd->active->name);
+				error = -EPERM;
+			}
+		}
+
+	} else { /* __sd_is_confined(sd) */
+
+		/* unconfined task, load profile if it exists */
+		findprofile = 1;
+	}
+
+	/* mode has been determined,  try to locate profile if necessary */
+
+find_profile:
+
+	if (findprofile) {
+		newprofile = sd_profilelist_find(filename);
+		if (newprofile) {
+			SD_DEBUG("%s: setting profile %s\n",
+				 __FUNCTION__, newprofile->name);
+		} else if (findprofile_mandatory) {
+			/* Profile (mandatory) could not be found */
+
+			if (complain) {
+				SD_WARN("LOGPROF-HINT missing_mandatory_profile image=%s pid=%d profile=%s active=%s\n",
+					filename,
+					current->pid,
+					sd->profile->name,
+					sd->active->name);
+
+				newprofile = get_sdprofile(null_complain_profile);
+			} else {
+				SD_WARN("REJECTING exec(2) of image '%s', Profile mandatory (exec qualifier 'p' specified) and not found (%s(%d) profile %s active %s)\n",
+					filename,
+					current->comm, current->pid,
+					sd->profile->name, sd->active->name);
+				error = -EPERM;
+			}
+		} else {
+			/* Profile (non-mandatory) could not be found */
+
+			/* Only way we can get into this code is if task
+			 * is unconstrained.
+			 */
+
+			BUG_ON(__sd_is_confined(sd));
+
+			SD_DEBUG("%s: No profile found for exec image %s\n",
+				 __FUNCTION__,
+				 filename);
+		} /* profile */
+	} /* findprofile */
+
+	/* Apply profile if necessary */
+	if (newprofile) {
+		struct subdomain *latest_sd;
+
+		if (newprofile == &unconstrained_flag) {
+			newprofile = NULL;
+		}
+
+		/* grab a write lock
+		 *
+		 * Several things may have changed since the code above
+		 *
+		 * - If we are a confined process, sd is a refcounted copy of
+		 *   the SubDomain (get_sdcopy) and not the actual SubDomain.
+		 *   This allows us to not have to hold a read lock around
+		 *   all this code.  However, we need to change the actual
+		 *   SubDomain, not the copy.  Also, if profile replacement
+		 *   has taken place, our sd->profile may be inaccurate
+		 *   so we need to undo the copy and reverse the refcounting.
+		 *
+		 * - If newprofile points to an actual profile (result of
+		 *   sd_profilelist_find above), this profile may have been
+		 *   replaced.  We need to fix it up.  Doing this to avoid
+		 *   having to hold a write lock around all this code.
+		 */
+
+		SD_WLOCK;
+
+		/* task is guaranteed to have a SubDomain (->security)
+		 * by this point
+		 */
+		latest_sd = SD_SUBDOMAIN(current->security);
+
+		/* Determine if profile we found earlier is stale.
+		 * If so, reobtain it.  N.B stale flag should never be
+		 * set on null_complain profile.
+		 */
+		if (newprofile && unlikely(newprofile->isstale)) {
+			BUG_ON(newprofile == null_complain_profile);
+
+			/* drop refcnt obtained from earlier get_sdprofile */
+			put_sdprofile(newprofile);
+
+			newprofile = sd_profilelist_find(filename);
+
+			if (!newprofile) {
+				/* Race, profile was removed, not replaced.
+				 * Redo with error checking
+				 */
+				SD_WUNLOCK;
+				goto find_profile;
+			}
+		}
+
+		/* need to drop reference counts we obtained in get_sdcopy
+		 * above.  Need to do it before overwriting latest_sd, in
+		 * case latest_sd == sd (no async replacement has taken place).
+		 */
+		if (issdcopy) {
+			put_sdcopy(sd);
+			issdcopy = 0;
+		}
+
+		sd_switch(latest_sd, newprofile, newprofile);
+		put_sdprofile(newprofile);
+
+		if (complain && newprofile == null_complain_profile) {
+			SD_WARN("LOGPROF-HINT changing_profile pid=%d\n",
+				current->pid);
+		}
+
+		SD_WUNLOCK;
+	}
+
+	sd_put_name(filename);
+
+	if (issdcopy) {
+		put_sdcopy(sd);
+	}
+
+out:
+	return error;
+}
+
+/**
+ * sd_release - release the task's SubDomain
+ * @p: task being released
+ *
+ * This is called after a task has exited and the parent has reaped it.
+ * @p->security blob is freed.
+ */
+void sd_release(struct task_struct *p)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(p->security);
+	if (sd) {
+		p->security = NULL;
+
+		sd_subdomainlist_remove(sd);
+
+		/* release profiles */
+		put_sdprofile(sd->profile);
+		put_sdprofile(sd->active);
+
+		kfree(sd);
+	}
+}
+
+/*****************************
+ * GLOBAL SUBPROFILE FUNCTIONS
+ ****************************/
+
+/**
+ * do_change_hat - actually switch hats
+ * @name: name of hat to swtich to
+ * @sd: current SubDomain
+ *
+ * Switch to a new hat.  Return 0 on success, error otherwise.
+ */
+static __INLINE__ int do_change_hat(const char *hat_name, struct subdomain *sd)
+{
+	struct sdprofile *sub;
+	struct sdprofile *p = sd->active;
+	int error = 0;
+
+	sub = __sd_find_profile(hat_name, &sd->profile->sub);
+
+	if (sub) {
+		/* change hat */
+		sd->active = sub;
+	} else {
+		/* There is no such subprofile change to a NULL profile.
+		 * The NULL profile grants no file access.
+		 *
+		 * This feature is used by changehat_apache.
+		 *
+		 * N.B from the null-profile the task can still changehat back
+		 * out to the parent profile (assuming magic != NULL)
+		 */
+		if (SUBDOMAIN_COMPLAIN(sd)) {
+			SD_WARN("LOGPROF-HINT unknown_hat %s pid=%d profile=%s active=%s\n",
+				hat_name,
+				current->pid,
+				sd->profile->name,
+				sd->active->name);
+			sd->active = get_sdprofile(null_complain_profile);
+		} else {
+			SD_DEBUG("%s: Unknown hatname '%s'. Changing to NULL profile (%s(%d) profile %s active %s)\n",
+				 __FUNCTION__,
+				 hat_name,
+				 current->comm, current->pid,
+				 sd->profile->name, sd->active->name);
+
+			sd->active = get_sdprofile(null_profile);
+			error = -EACCES;
+		}
+	}
+	put_sdprofile(p);
+
+	return error;
+}
+
+/**
+ * sd_change_hat - change hat to/from subprofile
+ * @hat_name: specifies hat to change to
+ * @hat_magic: token to validate hat change
+ *
+ * Change to new @hat_name when current hat is top level profile, and store
+ * the @hat_magic in the current SubDomain.  If the new @hat_name is
+ * NULL, and the @hat_magic matches that stored in the current SubDomain
+ * return to original top level profile.  Returns 0 on success, error
+ * otherwise.
+ */
+#define IN_SUBPROFILE(sd)	((sd)->profile != (sd)->active)
+int sd_change_hat(const char *hat_name, __u32 hat_magic)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(current->security);
+	int error = 0;
+
+	SD_DEBUG("%s: %p, 0x%x (pid %d)\n",
+		 __FUNCTION__,
+		 hat_name, hat_magic,
+		 current->pid);
+
+	/* Dump out above debugging in WARN mode if we are in AUDIT mode */
+	if (SUBDOMAIN_AUDIT(sd)) {
+		SD_WARN("%s: %s, 0x%x (pid %d)\n",
+			__FUNCTION__, hat_name ? hat_name : "NULL",
+			hat_magic, current->pid);
+	}
+
+	/* no SubDomains: changehat into the null_profile, since the process
+	   has no SubDomains do_change_hat won't find a match which will cause
+	   a changehat to null_profile.  We could short circuit this but since
+	   the subdprofile (hat) list is empty we would save very little. */
+
+	/* check to see if an unconfined process is doing a changehat. */
+	if (!__sd_is_confined(sd)) {
+		error = -EACCES;
+		goto out;
+	}
+
+	/* Check whether current domain is parent or one of the sibling children */
+	if (sd->profile == sd->active) {
+		/*
+		 * parent
+		 */
+		if (hat_name) {
+			SD_DEBUG("%s: switching to %s, 0x%x\n",
+				 __FUNCTION__,
+				 hat_name,
+				 hat_magic);
+
+			/*
+			 * N.B hat_magic == 0 has a special meaning
+			 * this indicates that the task may never changehat
+			 * back to it's parent, it will stay in this subhat
+			 * (or null-profile, if the hat doesn't exist) until
+			 * the task terminates
+			 */
+			sd->sd_hat_magic = hat_magic;
+			error = do_change_hat(hat_name, sd);
+		} else {
+			/* Got here via changehat(NULL, magic)
+			 *
+			 * We used to simply update the magic cookie.
+			 * That's an odd behaviour, so just do nothing.
+			 */
+		}
+	} else {
+		/*
+		 * child -- check to make sure magic is same as what was
+		 * passed when we switched into this profile,
+		 * Handle special casing of NULL magic which confines task
+		 * to subprofile and prohibits further changehats
+		 */
+		if (hat_magic == sd->sd_hat_magic && sd->sd_hat_magic) {
+			if (!hat_name) {
+				/*
+				 * Got here via changehat(NULL, magic)
+				 * Return from subprofile, back to parent
+				 */
+				put_sdprofile(sd->active);
+				sd->active = get_sdprofile(sd->profile);
+
+				/* Reset hat_magic to zero.
+				 * New value will be passed on next changehat
+				 */
+				sd->sd_hat_magic = 0;
+			} else {
+				/* change to another (sibling) profile */
+				error = do_change_hat(hat_name, sd);
+			}
+		} else if (sd->sd_hat_magic) {	/* hat_magic != sd->sd_hat_magic */
+			SD_ERROR("KILLING process %s(%d) Invalid change_hat() magic# 0x%x (hatname %s profile %s active %s)\n",
+				 current->comm, current->pid,
+				 hat_magic,
+				 hat_name ? hat_name : "NULL",
+				 sd->profile->name, sd->active->name);
+
+			/* terminate current process */
+			(void)send_sig_info(SIGKILL, NULL, current);
+		} else {	/* sd->sd_hat_magic == NULL */
+			SD_ERROR("KILLING process %s(%d) Task was confined to current subprofile (profile %s active %s)\n",
+				 current->comm, current->pid,
+				 sd->profile->name, sd->active->name);
+
+			/* terminate current process */
+			(void)send_sig_info(SIGKILL, NULL, current);
+		}
+
+	}
+
+out:
+	return error;
+}
Index: linux-2.6.14/security/subdomain/module_interface.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/module_interface.c
@@ -0,0 +1,793 @@
+/*
+ *	Copyright (C) 1998-2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	SubDomain userspace policy interface
+ */
+
+#include "subdomain.h"
+#include "immunix.h"
+#include "inline.h"
+#include "module_interface.h"
+#include "sdmatch/match.h"
+
+/* sd_code defined in module_interface.h */
+
+const int sdcode_size[] = { 1, 2, 4, 8, 2, 2, 4, 0, 0, 0, 0, 0, 0 };
+
+const char *sd_code_names[] = {
+	"SD_U8",
+	"SD_U16",
+	"SD_U32",
+	"SD_U64",
+	"SD_NAME",
+	"SD_STRING",
+	"SD_BLOB",
+	"SD_STRUCT",
+	"SD_STRUCTEND",
+	"SD_LIST",
+	"SD_LISTEND",
+	"SD_OFFSET"
+};
+
+struct sd_taskreplace_data {
+	struct sdprofile *old_profile;
+	struct sdprofile *new_profile;
+};
+
+/* inlines must be forward of there use in newer version of gcc,
+   just forward declaring with a prototype won't work anymore */
+
+/**
+ * put_name - release name obtained by get_name
+ * @name: pointer to memory allocated for name by get_name
+ *
+ * Simple wrapper for kfree.
+ */
+static __INLINE__ void put_name(char *name)
+{
+	if (name) {
+		kfree(name);
+	}
+}
+
+static __INLINE__ void put_sd_entry(struct sd_entry *entry)
+{
+	if (entry) {
+		put_name(entry->filename);
+		sdmatch_free(entry->extradata);
+		kfree(entry);
+	}
+}
+
+/**
+ * alloc_sd_entry - create new empty sd_entry
+ *
+ * This routine allocates, initializes, and returns a new SubDomain
+ * file entry structure.  Structure is zeroed.  Returns new structure on
+ * success, NULL on failure.
+ */
+static __INLINE__ struct sd_entry *alloc_sd_entry(void)
+{
+	struct sd_entry *entry;
+
+	SD_DEBUG("%s\n", __FUNCTION__);
+	entry = kmalloc(sizeof(struct sd_entry), GFP_KERNEL);
+	if (entry) {
+		int i;
+		memset(entry, 0, sizeof(struct sd_entry));
+		INIT_LIST_HEAD(&entry->list);
+		for (i = 0; i <= POS_SD_FILE_MAX; i++) {
+			INIT_LIST_HEAD(&entry->listp[i]);
+		}
+	}
+	return entry;
+}
+
+/**
+ * put_iface - free interface name (simple kfree() wrapper)
+ * @iface: pointer to interface name
+ */
+static __INLINE__ void put_iface(char *iface)
+{
+	if (iface) {
+		kfree(iface);
+	}
+}
+
+/**
+ * free_sdprofile - free sdprofile structure
+ */
+void free_sdprofile(struct sdprofile *profile)
+{
+	struct sd_entry *sdent;
+	struct list_head *lh, *tmp;
+
+	SD_DEBUG("%s(%p)\n", __FUNCTION__, profile);
+
+	if (!profile)
+		return;
+
+	/* profile is still on global profile list -- invalid */
+	if (!list_empty(&profile->list)) {
+		SD_ERROR("%s: internal error, profile '%s' still on global list\n",
+			 __FUNCTION__,
+			 profile->name);
+		BUG();
+	}
+
+	list_for_each_safe(lh, tmp, &profile->file_entry) {
+		sdent = list_entry(lh, struct sd_entry, list);
+		if (sdent->filename)
+			SD_DEBUG("freeing sd_entry: %p %s\n",
+				 sdent->filename, sdent->filename);
+		list_del_init(&sdent->list);
+		put_sd_entry(sdent);
+	}
+
+	list_for_each_safe(lh, tmp, &profile->sub) {
+		struct sdprofile *p = list_entry(lh, struct sdprofile, list);
+		list_del_init(&p->list);
+		put_sdprofile(p);
+	}
+
+	if (profile->sub_name) {
+		SD_DEBUG("%s: %s %s\n", __FUNCTION__, profile->name,
+			 profile->sub_name);
+		kfree(profile->sub_name);
+	}
+
+	if (profile->name) {
+		SD_DEBUG("%s: %s\n", __FUNCTION__, profile->name);
+		kfree(profile->name);
+	}
+
+	kfree(profile);
+}
+
+/** task_remove
+ *
+ * remove profile in a task's subdomain leaving the task unconfined
+ *
+ * @sd: task's subdomain
+ */
+static __INLINE__ void task_remove(struct subdomain *sd)
+{
+	/* SD_WLOCK held here */
+	SD_DEBUG("%s: removing profile from task %s(%d) profile %s active %s\n",
+		 __FUNCTION__,
+		 sd->task->comm,
+		 sd->task->pid,
+		 sd->profile->name,
+		 sd->active->name);
+
+	sd_switch_unconfined(sd);
+}
+
+/** taskremove_iter
+ *
+ * Iterate over all subdomains.
+ *
+ * If any matches old_profile,  then call task_remove to remove it.
+ * This leaves the task (subdomain) unconfined.
+ */
+static int taskremove_iter(struct subdomain *sd, void *cookie)
+{
+	struct sdprofile *old_profile = (struct sdprofile *)cookie;
+	int remove = 0;
+
+	SD_WLOCK;
+
+	if (__sd_is_confined(sd) && sd->profile == old_profile) {
+		remove = 1;	/* remove item from list */
+		task_remove(sd);
+	}
+
+	SD_WUNLOCK;
+
+	return remove;
+}
+
+/** task_replace
+ *
+ * replace profile in a task's subdomain with newly loaded profile
+ *
+ * @sd: task's subdomain
+ * @new: old profile
+ */
+static __INLINE__ void task_replace(struct subdomain *sd, struct sdprofile *new)
+{
+	struct sdprofile *nactive = NULL;
+
+	SD_DEBUG("%s: replacing profile for task %s(%d) profile=%s (%p) active=%s (%p)\n",
+		 __FUNCTION__,
+		 sd->task->comm, sd->task->pid,
+		 sd->profile->name, sd->profile,
+		 sd->active->name, sd->active);
+
+	if (sd->profile == sd->active)
+		nactive = get_sdprofile(new);
+	else if (sd->active) {
+		/* old in hat, new profile has hats */
+		nactive = __sd_find_profile(sd->active->name, &new->sub);
+
+		if (!nactive) {
+			if (new->flags.complain) {
+				nactive = get_sdprofile(null_complain_profile);
+			} else {
+				nactive = get_sdprofile(null_profile);
+			}
+		}
+	}
+	sd_switch(sd, new, nactive);
+
+	put_sdprofile(nactive);
+}
+
+/** taskreplace_iter
+ *
+ * Iterate over all subdomains.
+ *
+ * If any matches old_profile,  then call task_replace to replace with
+ * new_profile
+ */
+static int taskreplace_iter(struct subdomain *sd, void *cookie)
+{
+	struct sd_taskreplace_data *data = (struct sd_taskreplace_data *)cookie;
+
+	SD_WLOCK;
+
+	if (__sd_is_confined(sd) && sd->profile == data->old_profile) {
+		task_replace(sd, data->new_profile);
+	}
+
+	SD_WUNLOCK;
+
+	return 0;
+}
+
+static inline u16 convert16(char *data)
+{
+	u16 tmp;
+	memcpy(&tmp, data, sizeof(tmp));
+	return le16_to_cpu(tmp);
+}
+
+static inline u32 convert32(char *data)
+{
+	u32 tmp;
+	memcpy(&tmp, data, sizeof(tmp));
+	return le32_to_cpu(tmp);
+}
+
+static inline u64 convert64(char *data)
+{
+	u64 tmp;
+	memcpy(&tmp, data, sizeof(tmp));
+	return le64_to_cpu(tmp);
+}
+
+
+static __INLINE__ int sd_inbounds(struct sd_ext *e, size_t size)
+{
+	return (e->pos + size <= e->end);
+}
+
+/**
+ * sdconvert - for codes that have a trailing value, convert that value
+ *             and put it in dest.
+ *             if a code does not have a trailing value nop
+ * @code: type code
+ * @dest: pointer to object to receive the converted value
+ * @src:  pointer to value to convert
+ */
+static void sdconvert(enum sd_code code, void *dest, void *src)
+{
+	switch (code) {
+	case SD_U8:
+		*(u8 *)dest = *(u8 *) src;
+		break;
+	case SD_U16:
+	case SD_NAME:
+	case SD_DYN_STRING:
+		*(u16 *)dest = convert16(src);
+		break;
+	case SD_U32:
+	case SD_STATIC_BLOB:
+		*(u32 *)dest = convert32(src);
+		break;
+	case SD_U64:
+		*(u64 *)dest = convert64(src);
+		break;
+	default:
+		/* nop - all other type codes do not have a trailing value */
+		;
+	}
+}
+
+/**
+ * sd_is_X - check if the next element is of type X and if it is within
+ *           bounds.  If it is put the associated value in data.
+ * @e: extent information
+ * @code: type code
+ * @data: object located at @e->pos (of type @code) is written into @data
+ *        if @data is non-null.  if data is null it means skip this
+ *        entry
+ * return the size of bytes associated with the returned data
+ *        for complex object like blob and string a pointer to the allocated
+ *        data is returned in data, but the size of the blob or string is
+ *        returned.
+ */
+static u32 sd_is_X(struct sd_ext *e, enum sd_code code, void *data)
+{
+	void *pos = e->pos;
+	int ret = 0;
+	if (!sd_inbounds(e, SD_CODE_BYTE + sdcode_size[code]))
+		goto fail;
+	if (code != *(u8 *)e->pos)
+		goto out;
+	e->pos += SD_CODE_BYTE;
+	if (code == SD_NAME) {
+		u16 size;
+		/* name codes are followed by X bytes */
+		size = convert16(e->pos);
+		if (!sd_inbounds(e, (size_t) size))
+			goto fail;
+		if (data)
+			*(u16 *)data = size;
+		e->pos += sdcode_size[code];
+		ret = 1 + sdcode_size[code];
+	} else if (code == SD_DYN_STRING) {
+		u16 size;
+		char *str;
+		/* strings codes are followed by X bytes */
+		size = convert16(e->pos);
+		e->pos += sdcode_size[code];
+		if (!sd_inbounds(e, (size_t) size))
+			goto fail;
+		if (data) {
+			* (char **)data = NULL;
+			str = kmalloc(size, GFP_KERNEL);
+			if (!str)
+				goto fail;
+			memcpy(str, e->pos, (size_t) size);
+			str[size-1] = '\0';
+			* (char **)data = str;
+		}
+		e->pos += size;
+		ret = size;
+	} else if (code == SD_STATIC_BLOB) {
+		u32 size;
+		/* blobs are followed by X bytes, that can be 2^32 */
+		size = convert32(e->pos);
+		e->pos += sdcode_size[code];
+		if (!sd_inbounds(e, (size_t) size))
+			goto fail;
+		if (data)
+			memcpy(data, e->pos, (size_t) size);
+		e->pos += size;
+		ret = size;
+	} else {
+		if (data)
+			sdconvert(code, data, e->pos);
+		e->pos += sdcode_size[code];
+		ret = 1 + sdcode_size[code];
+	}
+out:
+	return ret;
+fail:
+	e->pos = pos;
+	return 0;
+}
+
+/* sd_is_nameX - check is the next element is X, and its tag is name.
+ * if the code matches and name (if specified) matches then the packed data
+ * is unpacked into *data.  (Note for strings this is the size, and the next
+ * data in the stream is the string data)
+ * returns 0 if either match failes
+ */
+static int sd_is_nameX(struct sd_ext *e, enum sd_code code, void *data,
+		       const char *name)
+{
+	void *pos = e->pos;
+	u16 size;
+	u32 ret;
+	/* check for presence of a tagname, and if present name size
+	 * SD_NAME tag value is a u16 */
+	if (sd_is_X(e, SD_NAME, &size)) {
+		/* if a name is specified it must match. otherwise skip tag */
+		if (name && ((strlen(name) != size-1) ||
+			     strncmp(name, (char *)e->pos, (size_t)size-1)))
+			goto fail;
+		e->pos += size;
+	}
+	/* now check if data actually matches */
+	ret = sd_is_X(e, code, data);
+	if (!ret)
+		goto fail;
+	return ret;
+
+fail:
+	e->pos = pos;
+	return 0;
+}
+
+/* macro to wrap error case to make a block of reads look nicer */
+#define SD_READ_X(E, C, D, N) \
+	do { \
+		u32 __ret; \
+		__ret = sd_is_nameX((E), (C), (D), (N)); \
+		if (!__ret) \
+			goto fail; \
+	} while (0)
+
+/**
+ * sd_activate_net_entry - ignores/skips net entries if the they are present
+ * in the data stream.
+ * @e: extent information
+ */
+static __INLINE__ int sd_activate_net_entry(struct sd_ext *e)
+{
+	SD_READ_X(e, SD_STRUCT, NULL, "ne");
+	SD_READ_X(e, SD_U32, NULL, NULL);
+	SD_READ_X(e, SD_U32, NULL, NULL);
+	SD_READ_X(e, SD_U32, NULL, NULL);
+	SD_READ_X(e, SD_U16, NULL, NULL);
+	SD_READ_X(e, SD_U16, NULL, NULL);
+	SD_READ_X(e, SD_U32, NULL, NULL);
+	SD_READ_X(e, SD_U32, NULL, NULL);
+	SD_READ_X(e, SD_U16, NULL, NULL);
+	SD_READ_X(e, SD_U16, NULL, NULL);
+	/* interface name is optional so just ignore return code */
+	sd_is_nameX(e, SD_DYN_STRING, NULL, NULL);
+	SD_READ_X(e, SD_STRUCTEND, NULL, NULL);
+
+	return 1;
+fail:
+	return 0;
+}
+
+static __INLINE__ struct sd_entry *sd_activate_file_entry(struct sd_ext *e)
+{
+	struct sd_entry *entry = NULL;
+
+	if (!(entry = alloc_sd_entry()))
+		goto fail;
+
+	SD_READ_X(e, SD_STRUCT, NULL, "fe");
+	SD_READ_X(e, SD_DYN_STRING, &entry->filename, NULL);
+	SD_READ_X(e, SD_U32, &entry->mode, "file.mode");
+	SD_READ_X(e, SD_U32, &entry->entry_type, "file.pattern_type");
+
+	entry->extradata = sdmatch_alloc(entry->entry_type);
+	if (IS_ERR(entry->extradata)) {
+		entry->extradata = NULL;
+		goto fail;
+	}
+
+	if (entry->extradata &&
+	    sdmatch_serialize(entry->extradata, e, sd_is_nameX) != 0) {
+		goto fail;
+	}
+	SD_READ_X(e, SD_STRUCTEND, NULL, NULL);
+
+	switch (entry->entry_type) {
+	case sd_entry_literal:
+		SD_DEBUG("%s: %s [no pattern] mode=0x%x\n",
+			 __FUNCTION__,
+			 entry->filename,
+			 entry->mode);
+		break;
+	case sd_entry_tailglob:
+		SD_DEBUG("%s: %s [tailglob] mode=0x%x\n",
+			 __FUNCTION__,
+			 entry->filename,
+			 entry->mode);
+		break;
+	case sd_entry_pattern:
+		SD_DEBUG("%s: %s mode=0x%x\n",
+			 __FUNCTION__,
+			 entry->filename,
+			 entry->mode);
+		break;
+	default:
+		SD_WARN("%s: INVALID entry_type %d\n",
+			__FUNCTION__,
+			(int)entry->entry_type);
+		goto fail;
+	}
+
+	return entry;
+
+fail:
+	sdmatch_free(entry->extradata);
+	put_sd_entry(entry);
+	return NULL;
+}
+
+static __INLINE__ int check_rule_and_add(struct sd_entry *file_entry,
+					 struct sdprofile *profile,
+					 const char **message)
+{
+	/* verify consistency of x, px, ix, ux for entry against
+	   possible duplicates for this entry */
+	int mode = SD_EXEC_MODIFIER_MASK(file_entry->mode);
+	int i;
+
+	if (mode && !(SD_MAY_EXEC & file_entry->mode)) {
+		*message = "inconsistent rule, x modifiers without x";
+		goto out;
+	}
+
+	/* check that only 1 of the modifiers is set */
+	if (mode && (mode & (mode - 1))) {
+		*message = "inconsistent rule, multiple x modifiers";
+		goto out;
+	}
+
+	list_add(&file_entry->list, &profile->file_entry);
+	profile->num_file_entries++;
+
+	mode = file_entry->mode;
+
+	/* Handle partitioned lists
+	 * Chain entries onto sublists based on individual
+	 * permission bits. This allows more rapid searching.
+	 */
+	for (i = 0; i <= POS_SD_FILE_MAX; i++) {
+		if (mode & (1 << i)) {
+			/* profile->file_entryp[i] initially set to
+			 * NULL in alloc_sdprofile() */
+			list_add(&file_entry->listp[i],
+				 &profile->file_entryp[i]);
+		}
+	}
+
+	return 1;
+
+out:
+	put_sd_entry(file_entry);
+	return 0;
+}
+
+#define SD_ENTRY_LIST(NAME) \
+	do { \
+	if (sd_is_nameX(e, SD_LIST, NULL, (NAME))) { \
+		rulename = ""; \
+		error_string = "Invalid file entry"; \
+		while (!sd_is_nameX(e, SD_LISTEND, NULL, NULL)) { \
+			struct sd_entry *file_entry; \
+			file_entry = sd_activate_file_entry(e); \
+			if (!file_entry) \
+				goto fail; \
+			if (!check_rule_and_add(file_entry, profile, \
+						&error_string)) { \
+				rulename = file_entry->filename; \
+				goto fail; \
+			} \
+		} \
+	} \
+	} while (0)
+
+struct sdprofile *sd_activate_profile(struct sd_ext *e, ssize_t *error)
+{
+	struct sdprofile *profile = NULL;
+	const char *rulename = "";
+	const char *error_string = "Invalid Profile";
+
+	*error = -EPROTO;
+
+	profile = alloc_sdprofile();
+	if (!profile) {
+		error_string = "Could not allocate profile";
+		*error = -ENOMEM;
+		goto fail;
+	}
+
+	/* check that we have the right struct being passed */
+	SD_READ_X(e, SD_STRUCT, NULL, "profile");
+	SD_READ_X(e, SD_DYN_STRING, &profile->name, NULL);
+
+	error_string = "Invalid flags";
+	/* per profile debug flags (debug, complain, audit) */
+	SD_READ_X(e, SD_STRUCT, NULL, "flags");
+	SD_READ_X(e, SD_U32, &(profile->flags.debug), "profile.flags.debug");
+	SD_READ_X(e, SD_U32, &(profile->flags.complain),
+		  "profile.flags.complain");
+	SD_READ_X(e, SD_U32, &(profile->flags.audit), "profile.flags.audit");
+	SD_READ_X(e, SD_STRUCTEND, NULL, NULL);
+
+	error_string = "Invalid capabilities";
+	SD_READ_X(e, SD_U32, &(profile->capabilities), "profile.capabilities");
+
+	/* get the file entries. */
+	SD_ENTRY_LIST("pgent");		/* pcre rules */
+	SD_ENTRY_LIST("sgent");		/* simple globs */
+	SD_ENTRY_LIST("fent");		/* regular file entries */
+
+	/* get the net entries */
+	if (sd_is_nameX(e, SD_LIST, NULL, "net")) {
+		error_string = "Invalid net entry";
+		while (!sd_is_nameX(e, SD_LISTEND, NULL, NULL)) {
+			if (!sd_activate_net_entry(e))
+				goto fail;
+		}
+	}
+	rulename = "";
+
+	/* get subprofiles */
+	if (sd_is_nameX(e, SD_LIST, NULL, "hats")) {
+		error_string = "Invalid profile hat";
+		while (!sd_is_nameX(e, SD_LISTEND, NULL, NULL)) {
+			struct sdprofile *subprofile;
+			subprofile = sd_activate_profile(e, error);
+			if (!subprofile)
+				goto fail;
+			get_sdprofile(subprofile);
+			list_add(&subprofile->list, &profile->sub);
+		}
+	}
+
+	error_string = "Invalid end of profile";
+	SD_READ_X(e, SD_STRUCTEND, NULL, NULL);
+
+	return profile;
+
+fail:
+	SD_WARN("%s: %s %s in profile %s\n", INTERFACE_ID, rulename,
+		error_string, profile && profile->name ? profile->name
+		: "unknown");
+
+	if (profile) {
+		free_sdprofile(profile);
+		profile = NULL;
+	}
+
+	return NULL;
+}
+
+void *sd_activate_top_profile(struct sd_ext *e, ssize_t *error)
+{
+	/* get the interface version */
+	if (!sd_is_nameX(e, SD_U32, &e->version, "version")) {
+		SD_WARN("%s: version missing\n", INTERFACE_ID);
+		*error = -EPROTONOSUPPORT;
+		goto out;
+	}
+
+	/* check that the interface version is currently supported */
+	if (e->version != 2) {
+		SD_WARN("%s: unsupported interface version (%d)\n",
+			INTERFACE_ID, e->version);
+		*error = -EPROTONOSUPPORT;
+		goto out;
+	}
+
+	return sd_activate_profile(e, error);
+out:
+	return NULL;
+}
+
+ssize_t sd_file_prof_add(void *data, size_t size)
+{
+	struct sdprofile *profile = NULL, *old_profile = NULL;
+
+	struct sd_ext e = { data, data + size, data };
+	ssize_t error;
+
+	profile = sd_activate_top_profile(&e, &error);
+	if (!profile) {
+		SD_DEBUG("couldn't activate profile\n");
+		return error;
+	}
+
+	old_profile = sd_profilelist_find(profile->name);
+
+	if (old_profile) {
+		SD_WARN("%s: trying to add profile (%s) that "
+			"already exists.\n", __FUNCTION__, profile->name);
+		put_sdprofile(old_profile);
+		free_sdprofile(profile);
+		return -EEXIST;
+	}
+
+	sd_profilelist_add(profile);
+
+	return size;
+}
+
+ssize_t sd_file_prof_repl(void *udata, size_t size)
+{
+	struct sd_taskreplace_data data;
+	struct sd_ext e = { udata, udata + size, udata };
+	ssize_t error;
+
+	data.new_profile = sd_activate_top_profile(&e, &error);
+	if (!data.new_profile) {
+		SD_DEBUG("couldn't activate profile\n");
+		return error;
+	}
+	/* Grab reference to close race window (see comment below) */
+	get_sdprofile(data.new_profile);
+
+	/* Replace the profile on the global profile list.
+	 * This list is used by all new exec's to find the correct profile.
+	 * If there was a previous profile, it is returned, else NULL.
+	 *
+	 * N.B sd_profilelist_replace does not drop the refcnt on
+	 * old_profile when removing it from the global list, otherwise it
+	 * could reach zero and be automatically free'd. We nust manually
+	 * drop it at the end of this function when we are finished with it.
+	 */
+	data.old_profile = sd_profilelist_replace(data.new_profile);
+
+	/* RACE window here.
+	 * At this point another task could preempt us trying to replace
+	 * the SAME profile. If it makes it to this point,  it has removed
+	 * the original tasks new_profile from the global list and holds a
+	 * reference of 1 to it in it's old_profile.  If the new task
+	 * reaches the end of the function it will put old_profile causing
+	 * the profile to be deleted.
+	 * When the original task is rescheduled it will continue calling
+	 * sd_subdomainlist_iterate relabelling tasks with a profile
+	 * which points to free'd memory.
+	 */
+
+	/* If there was an old profile,  find all currently executing tasks
+	 * using this profile and replace the old profile with the new.
+	 */
+	if (data.old_profile) {
+		SD_DEBUG("%s: try to replace profile (%p)%s\n",
+			 __FUNCTION__,
+			 data.old_profile,
+			 data.old_profile->name);
+
+		sd_subdomainlist_iterate(taskreplace_iter, (void *)&data);
+
+		/* mark old profile as stale */
+		data.old_profile->isstale = 1;
+
+		/* it's off global list, and we are done replacing */
+		put_sdprofile(data.old_profile);
+	}
+
+	/* Free reference obtained above */
+	put_sdprofile(data.new_profile);
+
+	return size;
+}
+
+ssize_t sd_file_prof_remove(const char *name, size_t size)
+{
+	struct sdprofile *old_profile;
+
+	/* Do this step to get a guaranteed reference to profile
+	 * as sd_profilelist_remove may drop it to zero which would
+	 * made subsequent attempt to iterate using it unsafe
+	 */
+	old_profile = sd_profilelist_find(name);
+
+	if (old_profile) {
+		if (sd_profilelist_remove(name) != 0) {
+			SD_WARN("%s: race trying to remove profile (%s)\n",
+				__FUNCTION__, name);
+		}
+
+		/* remove profile from any tasks using it */
+		sd_subdomainlist_iterateremove(taskremove_iter,
+					       (void *)old_profile);
+
+		/* drop reference obtained by sd_profilelist_find */
+		put_sdprofile(old_profile);
+	} else {
+		SD_WARN("%s: trying to remove profile (%s) that "
+			"doesn't exist - skipping.\n", __FUNCTION__, name);
+		return -ENOENT;
+	}
+
+	return size;
+}
Index: linux-2.6.14/security/subdomain/subdomain.h
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/subdomain.h
@@ -0,0 +1,211 @@
+/*
+ *	Copyright (C) 1998-2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	SubDomain internal prototypes
+ */
+
+#ifndef __SUBDOMAIN_H
+#define __SUBDOMAIN_H
+
+#define __INLINE__ inline
+
+/* defn of iattr */
+#include <linux/fs.h>
+
+#include "immunix.h"
+
+extern int subdomain_debug;	/* 0 or 1 */
+extern int subdomain_complain;	/* 0 or 1 */
+extern int subdomain_audit;	/* 0 or 1 */
+
+#define SD_UNCONSTRAINED "unconstrained"
+/* $ echo -n subdomain.o | md5sum | cut -c -8 */
+#define  SD_ID_MAGIC		0x8c235e38
+
+#define PROFILE_COMPLAIN(_profile) (subdomain_complain == 1 || ((_profile) && (_profile)->flags.complain))
+
+#define SUBDOMAIN_COMPLAIN(_sd) (subdomain_complain == 1 || ((_sd) && (_sd)->active && (_sd)->active->flags.complain))
+
+#define SUBDOMAIN_AUDIT(_sd) (subdomain_audit == 1 || ((_sd) && (_sd)->active && (_sd)->active->flags.audit))
+
+/*
+ * DEBUG remains global (no per profile flag) since it is mostly used in sysctl
+ * which is not related to profile accesses.
+ */
+
+#define SD_DEBUG(fmt, args...)						\
+	do {								\
+		if (subdomain_debug)					\
+			printk(KERN_DEBUG "SubDomain: " fmt, ##args);	\
+	} while (0)
+#define SD_INFO(fmt, args...)	printk(KERN_INFO "SubDomain: " fmt, ##args)
+#define SD_WARN(fmt, args...)	printk(KERN_WARNING "SubDomain: " fmt, ##args)
+#define SD_ERROR(fmt, args...)	printk(KERN_ERR "SubDomain: " fmt, ##args)
+
+// Lock protecting access to 'struct subdomain' accesses
+extern rwlock_t sd_lock;
+#define SD_RLOCK read_lock(&sd_lock)
+#define SD_RUNLOCK read_unlock(&sd_lock)
+#define SD_WLOCK write_lock(&sd_lock)
+#define SD_WUNLOCK write_unlock(&sd_lock)
+
+/* basic SubDomain data structures */
+
+struct flagval {
+	int debug;
+	int complain;
+	int audit;
+};
+
+/**
+ * sd_entry - file ACL *
+ * Each SubDomain entry describes a file and an allowed access mode.
+ */
+struct sd_entry {
+	char *filename;
+	int mode;		/* mode is 'or' of READ, WRITE, EXECUTE,
+				 * INHERIT, UNCONSTRAINED, and LIBRARY
+				 * (meaning don't prefetch). */
+
+	enum entry_t entry_type;
+	void *extradata;
+
+	struct list_head list;
+	struct list_head listp[POS_SD_FILE_MAX + 1];
+};
+
+#define SD_EXEC_MODIFIER_MASK(mask) ((mask) & (SD_EXEC_UNCONSTRAINED |\
+		      		    SD_EXEC_INHERIT |\
+		      		    SD_EXEC_PROFILE))
+
+#define SD_EXEC_MASK(mask) ((mask) & (SD_MAY_EXEC |\
+		      		    SD_EXEC_UNCONSTRAINED |\
+		      		    SD_EXEC_INHERIT |\
+		      		    SD_EXEC_PROFILE))
+
+/**
+ * sdprofile - basic confinement data
+ *
+ * The SubDomain profile contains the basic confinement data.  Each profile
+ * has a name and potentially a list of SubDomain and NetDomain entries
+ * (files and network access control information).  The profiles are
+ * connected in a list
+ */
+struct sdprofile {
+	char *name;			/* profile name */
+	char *sub_name;			/* XXX WTF? */
+
+	struct list_head file_entry;	/* file ACL */
+	struct list_head file_entryp[POS_SD_FILE_MAX + 1];
+	struct list_head list;		/* list of profiles */
+	struct list_head sub;		/* sub profiles, for change_hat */
+	struct flagval flags;		/* per profile debug flags */
+
+	int isstale;			/* is profile stale */
+
+	int num_file_entries;
+	int num_file_pentries[POS_SD_FILE_MAX + 1];
+
+	kernel_cap_t capabilities;
+
+	atomic_t count;			/* reference count */
+};
+
+/**
+ * subdomain - a task's subdomain
+ *
+ * Contains the original profile obtained from execve() as well as the
+ * current active profile (which could change due to change_hat).  Plus
+ * the hat_magic needed during change_hat.
+ */
+struct subdomain {
+	__u32 sd_magic;			/* magic value to distinguish blobs */
+	struct sdprofile *profile;	/* The profile obtained from execve() */
+	struct sdprofile *active;	/* The current active profile */
+	__u32 sd_hat_magic;		/* used with change_hat */
+	struct list_head list;		/* list of subdomains */
+	struct task_struct *task;
+};
+
+typedef int (*sd_iter) (struct subdomain *, void *);
+
+/* sd_path_data
+ * temp (cookie) data used by sd_path_* functions, see inline.h
+ */
+struct sd_path_data {
+	struct dentry *root, *dentry;
+	struct namespace *namespace;
+	struct list_head *head, *pos;
+	int errno;
+};
+
+#define SD_SUBDOMAIN(sec)	((struct subdomain*)(sec))
+#define SD_PROFILE(sec)		((struct sdprofile*)(sec))
+
+extern struct sdprofile *null_profile;
+extern struct sdprofile *null_complain_profile;
+
+/* main.c */
+extern char *__sd_get_name(struct dentry *dentry, struct vfsmount *mnt);
+extern int sd_attr(struct subdomain *sd, struct dentry *dentry,
+		   struct iattr *iattr);
+extern int sd_xattr(struct subdomain *sd, struct dentry *dentry,
+		    const char *attr, int flags);
+extern int sd_capability(struct subdomain *sd, int cap);
+extern int sd_perm(struct subdomain *sd, struct dentry *dentry,
+		   struct vfsmount *mnt, int mask);
+extern int sd_perm_nameidata(struct subdomain *sd, struct nameidata *nd,
+			     int mask);
+extern int sd_perm_dentry(struct subdomain *sd, struct dentry *dentry,
+			  int mask);
+extern int sd_file_perm(struct subdomain *sd, const char *name,
+			int mask, int log);
+extern int sd_link(struct subdomain *sd,
+		   struct dentry *link, struct dentry *target);
+extern int sd_fork(struct task_struct *p);
+extern int sd_register(struct file *file);
+extern void sd_release(struct task_struct *p);
+extern int sd_change_hat(const char *id, __u32 hat_magic);
+extern int sd_associate_filp(struct file *filp);
+
+/* list.c */
+extern struct sdprofile *sd_profilelist_find(const char *name);
+extern void sd_profilelist_add(struct sdprofile *profile);
+extern int sd_profilelist_remove(const char *name);
+extern void sd_profilelist_release(void);
+extern struct sdprofile *sd_profilelist_replace(struct sdprofile *profile);
+extern void sd_profile_dump(struct sdprofile *);
+extern void sd_profilelist_dump(void);
+extern void sd_subdomainlist_add(struct subdomain *);
+extern int sd_subdomainlist_remove(struct subdomain *);
+extern void sd_subdomainlist_iterate(sd_iter, void *);
+extern void sd_subdomainlist_iterateremove(sd_iter, void *);
+extern void sd_subdomainlist_release(void);
+
+/* subdomain_interface.c */
+extern void free_sdprofile(struct sdprofile *profile);
+extern int sd_sys_security(unsigned int id, unsigned call, unsigned long *args);
+
+/* procattr.c */
+extern size_t sd_getprocattr(struct subdomain *sd, char *str, size_t size);
+extern int sd_setprocattr_changehat(char *hatinfo, size_t infosize);
+extern int sd_setprocattr_setprofile(struct task_struct *p, char *profilename,
+				     size_t profilesize);
+
+/* subdomainfs.c */
+extern int create_subdomainfs(void);
+extern int destroy_subdomainfs(void);
+
+/* capabilities.c */
+extern const char *capability_to_name(unsigned int cap);
+
+/* subdomain_version.c */
+extern const char *subdomain_version(void);
+extern const char *subdomain_version_nl(void);
+
+#endif				// __SUBDOMAIN_H
Index: linux-2.6.14/security/subdomain/subdomain_version.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/subdomain_version.c
@@ -0,0 +1,41 @@
+/*
+ *	Copyright (C) 2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	SubDomain version definition
+ */
+
+#ifndef SUBDOMAIN_VERSION
+#error "-DSUBDOMAIN_VERSION must be specified when compiling this file"
+#endif
+
+#define SUBDOMAIN_VERSION_STR_PFX "SUBDOMAIN_VERSION="
+
+#include <linux/module.h>
+MODULE_VERSION(SUBDOMAIN_VERSION);
+
+/* subdomain_version_str exists to allow a strings on module to
+ * see SUBDOMAIN_VERSION= prefix
+ */
+static const char *subdomain_version_str = SUBDOMAIN_VERSION_STR_PFX SUBDOMAIN_VERSION;
+
+/* subdomain_version_str_nl exists to allow an easy way to get a newline
+ * terminated string without having to do dynamic memory allocation
+ */
+static const char *subdomain_version_str_nl = SUBDOMAIN_VERSION "\n";
+
+const char *subdomain_version(void)
+{
+	const int len = sizeof(SUBDOMAIN_VERSION_STR_PFX) - 1;
+
+	return subdomain_version_str + len;
+}
+
+const char *subdomain_version_nl(void)
+{
+	return subdomain_version_str_nl;
+}
Index: linux-2.6.14/security/subdomain/subdomainfs.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/subdomainfs.c
@@ -0,0 +1,456 @@
+/*
+ *	Copyright (C) 2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	SubDomain filesystem (part of securityfs)
+ */
+
+#include <linux/security.h>
+#include <linux/vmalloc.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+
+#include "subdomain.h"
+#include "inline.h"
+
+#define SECFS_SD "subdomain"
+static struct dentry *sdfs_dentry = NULL;
+
+/* profile */
+extern struct seq_operations subdomainfs_profiles_op;
+static int sd_prof_open(struct inode *inode, struct file *file);
+static int sd_prof_release(struct inode *inode, struct file *file);
+
+static struct file_operations subdomainfs_profiles_fops = {
+	.open =		sd_prof_open,
+	.read =		seq_read,
+	.llseek =	seq_lseek,
+	.release =	sd_prof_release,
+};
+
+/* version */
+static ssize_t sd_version_read(struct file *file, char __user *buf,
+			       size_t size, loff_t *ppos);
+
+static struct file_operations subdomainfs_version_fops = {
+	.read = 	sd_version_read,
+};
+
+/* interface */
+extern ssize_t sd_file_prof_add(void *, size_t);
+extern ssize_t sd_file_prof_repl(void *, size_t);
+extern ssize_t sd_file_prof_remove(const char *, int);
+
+static ssize_t sd_profile_load(struct file *f, const char __user *buf,
+			       size_t size, loff_t *pos);
+static ssize_t sd_profile_replace(struct file *f, const char __user *buf,
+				  size_t size, loff_t *pos);
+static ssize_t sd_profile_remove(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos);
+
+static struct file_operations subdomainfs_profile_load = {
+	.write = sd_profile_load
+};
+
+static struct file_operations subdomainfs_profile_replace = {
+	.write = sd_profile_replace
+};
+
+static struct file_operations subdomainfs_profile_remove = {
+	.write = sd_profile_remove
+};
+
+
+/* control */
+static u64 sd_control_get(void *data);
+static void sd_control_set(void *data, u64 val);
+
+DEFINE_SIMPLE_ATTRIBUTE(subdomainfs_control_fops, sd_control_get,
+			sd_control_set, "%lld\n");
+
+
+
+/* table of static entries */
+
+static struct root_entry {
+	const char *name;
+	int mode;
+	int access;
+	struct file_operations *fops;
+	void *data;
+
+	/* internal fields */
+	struct dentry *dentry;
+	int parent_index;
+} root_entries[] = {
+	/* our root, normally /sys/kernel/security/subdomain */
+	{SECFS_SD, 	S_IFDIR, 0550},	/* DO NOT EDIT/MOVE */
+
+	/* interface for obtaining list of profiles currently loaded */
+	{"profiles", 	S_IFREG, 0440, &subdomainfs_profiles_fops,
+				       NULL},
+
+	/* interface for obtaining version# of subdomain */
+	{"version",  	S_IFREG, 0440, &subdomainfs_version_fops,
+				       NULL},
+
+	/* interface for loading/removing/replacing profiles */
+	{".load",    	S_IFREG, 0640, &subdomainfs_profile_load,
+				       NULL},
+	{".replace", 	S_IFREG, 0640, &subdomainfs_profile_replace,
+				       NULL},
+	{".remove",  	S_IFREG, 0640, &subdomainfs_profile_remove,
+				       NULL},
+
+	/* interface for setting binary config values */
+	{"control",  	S_IFDIR, 0550},
+	{"complain", 	S_IFREG, 0640, &subdomainfs_control_fops,
+				       &subdomain_complain},
+	{"audit",    	S_IFREG, 0640, &subdomainfs_control_fops,
+				       &subdomain_audit},
+	{"debug",    	S_IFREG, 0640, &subdomainfs_control_fops,
+				       &subdomain_debug},
+	{NULL,       	S_IFDIR, 0},
+
+	/* root end */
+	{NULL,       	S_IFDIR, 0}
+};
+
+#define SDFS_DENTRY root_entries[0].dentry
+
+static const unsigned int num_entries =
+	sizeof(root_entries) / sizeof(struct root_entry);
+
+
+
+static int sd_prof_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &subdomainfs_profiles_op);
+}
+
+
+static int sd_prof_release(struct inode *inode, struct file *file)
+{
+	return seq_release(inode, file);
+}
+
+static ssize_t sd_version_read(struct file *file, char __user *buf,
+			       size_t size, loff_t *ppos)
+{
+	const char *version = subdomain_version_nl();
+	size_t maxlen = strlen(version);
+	loff_t offset = *ppos;
+	int err;
+
+	/* loff_t is signed */
+	if (offset < 0)
+		return -EFAULT;
+
+	if (offset >= maxlen)
+		return 0;
+
+	size = min(maxlen - (size_t) offset, size);
+
+	err = copy_to_user(buf, version + offset, size);
+
+	if (err) {
+		return -EFAULT;
+	}
+
+	*ppos += size;
+
+	return size;
+}
+
+static ssize_t sd_profile_load(struct file *f, const char __user *buf,
+			       size_t size, loff_t *pos)
+{
+	void *data;
+	ssize_t error = -EFAULT;
+
+	if (*pos != 0) {
+		/* only writes from pos 0, that is complete writes */
+		return -ESPIPE;
+	}
+
+	/* Don't allow confined processes to load profiles.
+	 * No sane person would add rules allowing this to a profile
+	 * but we enforce the restriction anyways.
+	 */
+	if (sd_is_confined()) {
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile addition (%s(%d) "
+			"profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	data = vmalloc(size);
+	if (data == NULL)
+		return -ENOMEM;
+
+	if (copy_from_user(data, buf, size)) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	error = sd_file_prof_add(data, size);
+
+out:
+	vfree(data);
+	return error;
+}
+
+static ssize_t sd_profile_replace(struct file *f, const char __user *buf,
+				  size_t size, loff_t *pos)
+{
+	void *data;
+	ssize_t error = -EFAULT;
+
+	if (*pos != 0) {
+		/* only writes from pos 0, that is complete writes */
+		return -ESPIPE;
+	}
+
+	/* Don't allow confined processes to replace profiles */
+	if (sd_is_confined()) {
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile replacement (%s(%d) "
+			"profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	data = vmalloc(size);
+	if (data == NULL)
+		return -ENOMEM;
+
+	if (copy_from_user(data, buf, size)) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	error = sd_file_prof_repl(data, size);
+
+out:
+	vfree(data);
+	return error;
+}
+
+static ssize_t sd_profile_remove(struct file *f, const char __user *buf,
+				  size_t size, loff_t *pos)
+{
+	char *data;
+	ssize_t error = -EFAULT;
+
+	if (*pos != 0) {
+		/* only writes from pos 0, that is complete writes */
+		return -ESPIPE;
+	}
+
+	/* Don't allow confined processes to remove profiles */
+	if (sd_is_confined()) {
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile removal (%s(%d) "
+			"profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	data = (char *)vmalloc(size + 1);
+	if (data == NULL)
+		return -ENOMEM;
+
+	data[size] = 0;
+	if (copy_from_user(data, buf, size)) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	error = sd_file_prof_remove((char *)data, size);
+
+out:
+	vfree(data);
+	return error;
+}
+
+static u64 sd_control_get(void *data)
+{
+	return *(int *)data;
+}
+
+static void sd_control_set(void *data, u64 val)
+{
+	if (val > 1)
+		val = 1;
+
+	*(int*)data = (int)val;
+}
+
+static void clear_subdomainfs(void)
+{
+	unsigned int i;
+
+	for (i=0; i < num_entries;i++) {
+		unsigned int index;
+
+		if (root_entries[i].mode == S_IFDIR) {
+			if (root_entries[i].name) {
+				// defer dir free till all sub-entries freed
+				continue;
+			} else {
+				// cleanup parent
+				index = root_entries[i].parent_index;
+			}
+		} else {
+			index = i;
+		}
+
+		if (root_entries[index].dentry) {
+			securityfs_remove(root_entries[index].dentry);
+
+			SD_DEBUG("%s: deleted subdomainfs entry name=%s "
+				 "dentry=%p\n",
+				__FUNCTION__,
+				root_entries[index].name,
+				root_entries[index].dentry);
+
+			root_entries[index].dentry = NULL;
+			root_entries[index].parent_index = 0;
+		}
+	}
+}
+
+static int populate_subdomainfs(struct dentry *root)
+{
+	unsigned int i, parent_index, depth;
+
+#define ENT root_entries[i]
+
+	for (i = 0; i < num_entries; i++) {
+		root_entries[i].dentry = NULL;
+		root_entries[i].parent_index = 0;
+	}
+
+	/* 1. Verify entry 0 is valid [sanity check] */
+	if (num_entries == 0 ||
+	    !root_entries[0].name ||
+	    strcmp(root_entries[0].name, SECFS_SD) != 0 ||
+	    root_entries[0].mode != S_IFDIR) {
+		SD_ERROR("%s: root entry 0 is not SECFS_SD/dir\n",
+			__FUNCTION__);
+		goto error;
+	}
+
+	/* 2. Verify table structure */
+	parent_index = 0;
+	depth = 1;
+
+	for (i = 1; i < num_entries; i++) {
+		ENT.parent_index = parent_index;
+
+		if (ENT.name && ENT.mode == S_IFDIR) {
+			depth++;
+			parent_index = i;
+		} else if (!ENT.name) {
+			if (ENT.mode != S_IFDIR || depth == 0) {
+				SD_ERROR("%s: root_entry %d invalid (%u %d)",
+					 __FUNCTION__, i,
+					 ENT.mode, ENT.parent_index);
+				goto error;
+			}
+
+			depth--;
+			parent_index = root_entries[parent_index].parent_index;
+		}
+	}
+
+	if (depth != 0) {
+		SD_ERROR("%s: root_entry table not correctly terminated\n",
+			__FUNCTION__);
+		goto error;
+	}
+
+	/* 3. Create root (parent=NULL) */
+	i=0;
+
+	ENT.dentry = securityfs_create_file(ENT.name,
+					ENT.mode | ENT.access,
+					NULL, NULL, NULL);
+
+	if (ENT.dentry)
+		SD_DEBUG("%s: created securityfs/subdomain [dentry=%p]\n",
+			__FUNCTION__, ENT.dentry);
+	else
+		goto error;
+
+
+	/* 4. create remaining nodes */
+	for (i = 1; i < num_entries; i++) {
+		struct dentry *parent;
+
+		/* end of directory ? */
+		if (!ENT.name) {
+			continue;
+		}
+
+		parent = root_entries[ENT.parent_index].dentry;
+
+		ENT.dentry = securityfs_create_file(ENT.name,
+					ENT.mode | ENT.access,
+					parent,
+					ENT.mode != S_IFDIR ? ENT.data : NULL,
+					ENT.mode != S_IFDIR ? ENT.fops : NULL);
+
+		if (!ENT.dentry)
+			goto cleanup_error;
+
+		SD_DEBUG("%s: added subdomainfs entry name=%s mode=%x dentry=%p [parent %p]\n",
+			__FUNCTION__, ENT.name, ENT.mode|ENT.access,
+			ENT.dentry, parent);
+	}
+
+	return 1;
+
+cleanup_error:
+	clear_subdomainfs();
+
+error:
+	return 0;
+}
+
+int create_subdomainfs(void)
+{
+	if (SDFS_DENTRY) {
+		SD_ERROR("%s: Subdomain securityfs already exists\n",
+			__FUNCTION__);
+	} else if (!populate_subdomainfs(sdfs_dentry)) {
+		SD_ERROR("%s: Error populating Subdomain securityfs\n",
+			__FUNCTION__);
+	}
+
+	return (SDFS_DENTRY != NULL);
+}
+
+int destroy_subdomainfs(void)
+{
+	if (SDFS_DENTRY) {
+		clear_subdomainfs();
+	}
+
+	return 1;
+}
Index: linux-2.6.14/security/subdomain/module_interface.h
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/module_interface.h
@@ -0,0 +1,37 @@
+#ifndef __MODULEINTERFACE_H
+#define __MODULEINTERFACE_H
+
+/* Codes of the types of basic structures that are understood */
+#define SD_CODE_BYTE (sizeof(u8))
+#define INTERFACE_ID "INTERFACE"
+
+#define SUBDOMAIN_INTERFACE_VERSION 2
+
+enum sd_code {
+	SD_U8,
+	SD_U16,
+	SD_U32,
+	SD_U64,
+	SD_NAME,		/* same as string except it is items name */
+	SD_DYN_STRING,
+	SD_STATIC_BLOB,
+	SD_STRUCT,
+	SD_STRUCTEND,
+	SD_LIST,
+	SD_LISTEND,
+	SD_OFFSET,
+	SD_BAD
+};
+
+/* sd_ext tracks the kernel buffer and read position in it.  The interface
+ * data is copied into a kernel buffer in subdomainfs and then handed off to
+ * the activate routines.
+ */
+struct sd_ext {
+	void *start;
+	void *end;
+	void *pos;	/* pointer to current position in the buffer */
+	u32 version;
+};
+
+#endif /* __MODULEINTERFACE_H */
Index: linux-2.6.14/security/subdomain/procattr.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/procattr.c
@@ -0,0 +1,301 @@
+/*
+ *	Copyright (C) 2005 Novell/SUSE
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2 of the
+ *	License.
+ *
+ *	SubDomain /proc/pid/attr handling
+ */
+
+#include "subdomain.h"
+#include "immunix.h"
+#include "inline.h"
+
+size_t sd_getprocattr(struct subdomain *sd, char *str, size_t size)
+{
+	int error = -EACCES;	/* default to a perm denied */
+	size_t len;
+
+	if (__sd_is_confined(sd)) {
+		size_t lena, lenm, lenp = 0;
+		const char *enforce_str = " (enforce)";
+		const char *complain_str = " (complain)";
+		const char *mode_str = SUBDOMAIN_COMPLAIN(sd) ? complain_str : enforce_str;
+
+		lenm = strlen(mode_str);
+
+		lena = strlen(sd->active->name);
+
+		len = lena;
+		if (sd->active != sd->profile) {
+			lenp = strlen(sd->profile->name);
+			len += (lenp + 1);	/* +1 for ^ */
+		}
+		/* DONT null terminate strings we output via proc */
+		len += (lenm + 1);	/* for \n */
+
+		if (len <= size) {
+			if (lenp) {
+				memcpy(str, sd->profile->name, lenp);
+				str += lenp;
+				*str++ = '^';
+			}
+
+			memcpy(str, sd->active->name, lena);
+			str += lena;
+			memcpy(str, mode_str, lenm);
+			str += lenm;
+			*str++ = '\n';
+			error = len;
+		} else {
+			error = -ERANGE;
+		}
+	} else {
+		const char *unconstrained_str = SD_UNCONSTRAINED "\n";
+		len = strlen(unconstrained_str);
+
+		/* DONT null terminate strings we output via proc */
+		if (len <= size) {
+			memcpy(str, unconstrained_str, len);
+			error = len;
+		} else {
+			error = -ERANGE;
+		}
+	}
+
+	return error;
+
+}
+int sd_setprocattr_changehat(char *hatinfo, size_t infosize)
+{
+	int error = -EINVAL;
+	char *token = NULL, *hat, *smagic, *tmp;
+	__u32 magic;
+	int rc, len, consumed;
+
+	SD_DEBUG("%s: %p %zd\n", __FUNCTION__, hatinfo, infosize);
+
+	/* strip leading white space */
+	while (infosize && isblank(*hatinfo)) {
+		hatinfo++;
+		infosize--;
+	}
+
+	if (infosize == 0) {
+		goto out;
+	}
+
+	/*
+	 * Copy string to a new buffer so we can play with it
+	 * It may be zero terminated but we add a trailing 0
+	 * for 100% safety
+	 */
+	token = kmalloc(infosize + 1, GFP_KERNEL);
+
+	if (!token) {
+		error = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(token, hatinfo, infosize);
+	token[infosize] = 0;
+
+	/* error is INVAL until we have at least parsed something */
+	error = -EINVAL;
+
+	tmp = token;
+	while (*tmp && *tmp != '^') {
+		tmp++;
+	}
+
+	if (!*tmp || tmp == token) {
+		SD_WARN("%s: Invalid input '%s'\n", __FUNCTION__, token);
+		goto out;
+	}
+
+	/* split magic and hat into two strings */
+	*tmp = 0;
+	smagic = token;
+
+	/*
+	 * Initially set consumed=strlen(magic), as if sscanf
+	 * consumes all input via the %x it will not process the %n
+	 * directive. Otherwise, if sscanf does not consume all the
+	 * input it will process the %n and update consumed.
+	 */
+	consumed = len = strlen(smagic);
+
+	rc = sscanf(smagic, "%x%n", &magic, &consumed);
+
+	if (rc != 1 || consumed != len) {
+		SD_WARN("%s: Invalid hex magic %s\n",
+			__FUNCTION__,
+			smagic);
+		goto out;
+	}
+
+	hat = tmp + 1;
+
+	if (!*hat) {
+		hat = NULL;
+	}
+
+	if (!hat && !magic) {
+		SD_WARN("%s: Invalid input, NULL hat and NULL magic\n",
+			__FUNCTION__);
+		goto out;
+	}
+
+	SD_DEBUG("%s: Magic 0x%x Hat '%s'\n",
+		 __FUNCTION__, magic, hat ? hat : NULL);
+
+	SD_WLOCK;
+	error = sd_change_hat(hat, magic);
+	SD_WUNLOCK;
+
+out:
+	if (token) {
+		memset(token, 0, infosize);
+		kfree(token);
+	}
+
+	return error;
+}
+
+int sd_setprocattr_setprofile(struct task_struct *p, char *profilename,
+			      size_t profilesize)
+{
+	int error = -EINVAL;
+	struct sdprofile *profile;
+	char *name = NULL;
+
+	SD_DEBUG("%s: current %s(%d)\n",
+		 __FUNCTION__, current->comm, current->pid);
+
+	/* strip leading white space */
+	while (profilesize && isblank(*profilename)) {
+		profilename++;
+		profilesize--;
+	}
+
+	if (profilesize == 0) {
+		goto out;
+	}
+
+	/*
+	 * Copy string to a new buffer so we guarantee it is zero
+	 * terminated
+	 */
+	name = kmalloc(profilesize + 1, GFP_KERNEL);
+
+	if (!name) {
+		error = -ENOMEM;
+		goto out;
+	}
+
+	strncpy(name, profilename, profilesize);
+	name[profilesize] = 0;
+
+	if (strcmp(name, SD_UNCONSTRAINED) == 0) {
+		profile = null_profile;
+	} else {
+		profile = sd_profilelist_find(name);
+	}
+
+	if (profile) {
+		struct subdomain *sd;
+
+		SD_WLOCK;
+
+		sd = SD_SUBDOMAIN(p->security);
+
+		/* switch to unconstrained */
+		if (profile == null_profile) {
+			if (__sd_is_confined(sd)) {
+				SD_WARN("%s: Unconstraining task %s(%d) profile %s active %s\n",
+					__FUNCTION__,
+					p->comm, p->pid,
+					sd->profile->name,
+					sd->active->name);
+
+				sd_switch_unconfined(sd);
+			} else {
+				SD_WARN("%s: task %s(%d) is already unconstrained\n",
+					__FUNCTION__, p->comm, p->pid);
+			}
+		} else {
+			if (!sd) {
+				/* this task was created before module was
+				 * loaded, allocate a subdomain
+				 */
+				SD_WARN("%s: task %s(%d) has no subdomain\n",
+					__FUNCTION__, p->comm, p->pid);
+
+				SD_WUNLOCK; /* so we can safely GFP_KERNEL */
+
+				sd = alloc_subdomain(p);
+				if (!sd) {
+					SD_WARN("%s: Unable to allocate subdomain for task %s(%d). Cannot confine task to profile %s\n",
+						__FUNCTION__,
+						p->comm, p->pid,
+						name);
+
+					error = -ENOMEM;
+					put_sdprofile(profile);
+
+					goto out;
+				}
+
+				SD_WLOCK;
+				if (!SD_SUBDOMAIN(p->security)) {
+					p->security = sd;
+				} else { /* race */
+					free_subdomain(sd);
+					sd = SD_SUBDOMAIN(p->security);
+				}
+			}
+
+			/* we do not do a normal task replace since we are not
+			 * replacing with the same profile.
+			 * If existing process is in a hat, it will be moved
+			 * into the new parent profile, even if this new
+			 * profile has a identical named hat.
+			 */
+
+			SD_WARN("%s: Switching task %s(%d) profile %s active %s to new profile %s\n",
+				__FUNCTION__,
+				p->comm, p->pid,
+				sd->profile ? sd->profile->name : SD_UNCONSTRAINED,
+				sd->active ? sd->profile->name : SD_UNCONSTRAINED,
+				name);
+
+			sd_switch(sd, profile, profile);
+
+			put_sdprofile(profile); /* drop ref we obtained above
+						 * from sd_profilelist_find
+						 */
+
+			/* Reset magic in case we were in a subhat before
+			 * This is the only case where we zero the magic after
+			 * calling sd_switch
+			 */
+			sd->sd_hat_magic = 0;
+		}
+
+		SD_WUNLOCK;
+	} else {
+		SD_WARN("%s: Unable to switch task %s(%d) to profile '%s'. No such profile.\n",
+			__FUNCTION__,
+			p->comm, p->pid,
+			name);
+
+		error = -EINVAL;
+	}
+
+out:
+	kfree(name);
+
+	return error;
+}
Index: linux-2.6.14/security/subdomain/sdmatch/match.h
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/sdmatch/match.h
@@ -0,0 +1,125 @@
+#ifndef __MATCH_H
+#define __MATCH_H
+
+#include "../module_interface.h"
+#include "../subdomain.h"
+
+/* The following functions implement an interface used by the primary
+ * SubDomain module to perform name matching.
+
+ * sdmatch_alloc
+ * sdmatch_free
+ * sdmatch_features
+ * sdmatch_serialize
+ * sdmatch_match
+ *
+ * The intent is for the primary module to export (via virtual fs entries)
+ * the features provided by the submodule (sdmatch_features) so that the
+ * parser may only load policy that can be supported.
+ *
+ * The primary module will call sdmatch_serialize to allow the submodule
+ * to consume submodule specific data from parser data stream and will call
+ * sdmatch_match to determine if a pathname matches an sd_entry.
+ */
+
+typedef int (*sdmatch_serializecb)
+	(struct sd_ext *, enum sd_code, void *, const char *);
+
+/**
+ * sdmatch_alloc: allocate extradata (if necessary)
+ * @entry_type: type of entry being allocated
+ * Return value: NULL indicates no data was allocated (ERR_PTR(x) on error)
+ */
+extern void* sdmatch_alloc(enum entry_t entry_type);
+
+/**
+ * sdmatch_free: release data allocated by sdmatch_alloc
+ * @entry_extradata: data previously allocated by sdmatch_alloc
+ */
+extern void sdmatch_free(void *entry_extradata);
+
+/**
+ * sdmatch_features: return match types supported
+ * Return value: space seperated string (of types supported - use type=value
+ * to indicate variants of a type)
+ */
+extern const char* sdmatch_features(void);
+
+/**
+ * sdmatch_serialize: serialize extradata
+ * @entry_extradata: data previously allocated by sdmatch_alloc
+ * @e: input stream
+ * @cb: callback fn (consume incoming data stream)
+ * Return value: 0 success, -ve error
+ */
+extern int sdmatch_serialize(void *entry_extradata, struct sd_ext *e,
+			     sdmatch_serializecb cb);
+
+/**
+ * sdmatch_match: determine if pathname matches entry
+ * @pathname: pathname to verify
+ * @entry_name: entry name
+ * @entry_type: type of entry
+ * @entry_extradata: data previously allocated by sdmatch_alloc
+ * Return value: 1 match, 0 othersise
+ */
+extern unsigned int sdmatch_match(const char *pathname, const char *entry_name,
+				  enum entry_t entry_type,
+				  void *entry_extradata);
+
+
+/**
+ * sd_getentry_type - return string representation of entry_t
+ * @etype: entry type
+ */
+static __INLINE__ const char *sd_getentry_type(enum entry_t etype)
+{
+	const char *etype_names[] = {
+		"sd_entry_literal",
+		"sd_entry_tailglob",
+		"sd_entry_pattern",
+		"sd_entry_invalid"
+	};
+
+	if (etype >= sd_entry_invalid) {
+		etype = sd_entry_invalid;
+	}
+
+	return etype_names[etype];
+}
+
+/**
+ * sdmatch_match_common - helper function to check if a pathname matches
+ * a literal/tailglob
+ * @path: path requested to search for
+ * @entry_name: name from sd_entry
+ * @etype: type of entry
+ */
+static __INLINE__ int sdmatch_match_common(const char *path,
+					   const char *entry_name,
+			   		   enum entry_t etype)
+{
+	int retval;
+
+	/* literal, no pattern matching characters */
+	if (etype == sd_entry_literal) {
+		retval = (strcmp(entry_name, path) == 0);
+	/* trailing ** glob pattern */
+	} else if (etype == sd_entry_tailglob) {
+		retval = (strncmp(entry_name, path,
+				  strlen(entry_name) - 2) == 0);
+	} else {
+		SD_WARN("%s: Invalid entry_t %d\n", __FUNCTION__, etype);
+		retval = 0;
+	}
+
+#if 0
+	SD_DEBUG("%s(%d): %s %s [%s]\n",
+		__FUNCTION__, retval, path, entry_name,
+		sd_getentry_type(etype));
+#endif
+
+	return retval;
+}
+
+#endif /* __MATCH_H */
Index: linux-2.6.14/security/subdomain/sdmatch/match_pcre.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/sdmatch/match_pcre.c
@@ -0,0 +1,144 @@
+#include <linux/module.h>
+#include "match.h"
+#include "pcre_exec.h"
+#include "pcre_tables.h"
+
+static const char *features="literal tailglob pattern=pcre";
+
+struct sdmatch_entry
+{
+	char *pattern;
+	pcre *compiled;
+};
+
+void* sdmatch_alloc(enum entry_t entry_type)
+{
+void *ptr=NULL;
+
+	if (entry_type == sd_entry_pattern) {
+		ptr = kmalloc(sizeof(struct sdmatch_entry), GFP_KERNEL);
+
+		if (!ptr)
+			ptr=ERR_PTR(-ENOMEM);
+	} else if (entry_type != sd_entry_literal &&
+		   entry_type != sd_entry_tailglob) {
+		ptr = ERR_PTR(-EINVAL);
+	}
+
+	return ptr;
+}
+
+void sdmatch_free(void *ptr)
+{
+	kfree(ptr);
+}
+
+const char *sdmatch_features(void)
+{
+	return features;
+}
+
+int sdmatch_serialize(void *entry_extradata, struct sd_ext *e,
+		      sdmatch_serializecb cb)
+{
+#define SD_READ_X(E, C, D, N) \
+	do { \
+		if (!cb((E), (C), (D), (N))) { \
+			error = -EINVAL; \
+			goto done; \
+		}\
+	} while (0)
+
+	int error = 0;
+	u32 size, magic, opts;
+	u8 t_char;
+	struct sdmatch_entry *ed = (struct sdmatch_entry *) entry_extradata;
+
+	if (ed == NULL)
+		goto done;
+
+	SD_READ_X(e, SD_DYN_STRING, &ed->pattern, NULL);
+
+	/* size determines the real size of the pcre struct,
+	   it is size_t - sizeof(pcre) on user side.
+	   uschar must be the same in user and kernel space */
+	/* check that we are processing the correct structure */
+	SD_READ_X(e, SD_STRUCT, NULL, "pcre");
+	SD_READ_X(e, SD_U32, &size, "pattern.size");
+	SD_READ_X(e, SD_U32, &magic, "pattern.magic");
+
+	/* the allocation of pcre is delayed because it depends on the size
+	 * of the pattern */
+	ed->compiled = (pcre *) kmalloc(size + sizeof(pcre), GFP_KERNEL);
+	if (!ed->compiled) {
+		error = -ENOMEM;
+		goto done;
+	}
+
+	memset(ed->compiled, 0, size + sizeof(pcre));
+	ed->compiled->magic_number = magic;
+	ed->compiled->size = size + sizeof(pcre);
+
+	SD_READ_X(e, SD_U32, &opts, "pattern.options");
+	ed->compiled->options = opts;
+	SD_READ_X(e, SD_U16, &ed->compiled->top_bracket, "pattern.top_bracket");
+	SD_READ_X(e, SD_U16, &ed->compiled->top_backref, "pattern.top_backref");
+	SD_READ_X(e, SD_U8, &t_char, "pattern.first_char");
+	ed->compiled->first_char = t_char;
+	SD_READ_X(e, SD_U8, &t_char, "pattern.req_char");
+	ed->compiled->req_char = t_char;
+	SD_READ_X(e, SD_U8, &t_char, "pattern.code[0]");
+	ed->compiled->code[0] = t_char;
+
+	SD_READ_X(e, SD_STATIC_BLOB, &ed->compiled->code[1], NULL);
+
+	SD_READ_X(e, SD_STRUCTEND, NULL, NULL);
+
+	/* stitch in pcre patterns, it was NULLed out by parser
+	 * pcre_default_tables defined in pcre_tables.h */
+	ed->compiled->tables = pcre_default_tables;
+
+done:
+	if (error != 0 && ed) {
+		kfree(ed->compiled);
+		ed->compiled = NULL;
+	}
+
+	return error;
+}
+
+unsigned int sdmatch_match(const char *pathname, const char *entry_name,
+			   enum entry_t entry_type, void *entry_extradata)
+{
+	int ret;
+
+	if (entry_type == sd_entry_pattern) {
+		int pcreret;
+		struct sdmatch_entry *ed =
+			(struct sdmatch_entry *) entry_extradata;
+
+        	pcreret = pcre_exec(ed->compiled, NULL,
+				    pathname, strlen(pathname),
+			    	    0, 0, NULL, 0);
+
+        	ret = (pcreret >= 0);
+
+		// XXX - this needs access to subdomain_debug,  hmmm
+        	//SD_DEBUG("%s(%d): %s %s %d\n", __FUNCTION__,
+		//	 ret, pathname, ed->pattern, pcreret);
+	} else {
+		ret = sdmatch_match_common(pathname, entry_name, entry_type);
+	}
+
+        return ret;
+}
+
+EXPORT_SYMBOL_GPL(sdmatch_alloc);
+EXPORT_SYMBOL_GPL(sdmatch_free);
+EXPORT_SYMBOL_GPL(sdmatch_features);
+EXPORT_SYMBOL_GPL(sdmatch_serialize);
+EXPORT_SYMBOL_GPL(sdmatch_match);
+
+MODULE_DESCRIPTION("SubDomain sd_match module [pcre]");
+MODULE_AUTHOR("SuSE/Novell <apparmor-general@forge.novell.com>");
+MODULE_LICENSE("GPL");
Index: linux-2.6.14/security/subdomain/sdmatch/pcre_exec.c
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/sdmatch/pcre_exec.c
@@ -0,0 +1,1945 @@
+/*
+ *  This is a modified version of pcre.c containing only the code/data
+ *  required to support pcre_exec()
+ */
+
+
+/*************************************************
+*      Perl-Compatible Regular Expressions       *
+*************************************************/
+
+/*
+This is a library of functions to support regular expressions whose syntax
+and semantics are as close as possible to those of the Perl 5 language. See
+the file Tech.Notes for some information on the internals.
+
+Written by: Philip Hazel <ph10@cam.ac.uk>
+
+           Copyright (c) 1997-2001 University of Cambridge
+
+-----------------------------------------------------------------------------
+Permission is granted to anyone to use this software for any purpose on any
+computer system, and to redistribute it freely, subject to the following
+restrictions:
+
+1. This software is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+2. The origin of this software must not be misrepresented, either by
+   explicit claim or by omission.
+
+3. Altered versions must be plainly marked as such, and must not be
+   misrepresented as being the original software.
+
+4. If PCRE is embedded in any software that is released under the GNU
+   General Purpose Licence (GPL), then the terms of that licence shall
+   supersede any condition above with which it is incompatible.
+-----------------------------------------------------------------------------
+*/
+
+
+/* Define DEBUG to get debugging output on stdout. */
+
+/* #define DEBUG */
+
+/* Use a macro for debugging printing, 'cause that eliminates the use of #ifdef
+inline, and there are *still* stupid compilers about that don't like indented
+pre-processor statements. I suppose it's only been 10 years... */
+
+#ifdef DEBUG
+#define DPRINTF(p) PCRE_PRINTF p
+#else
+#define DPRINTF(p) /*nothing*/
+#endif
+
+/* Include the internals header, which itself includes Standard C headers plus
+the external pcre header. */
+
+#include "pcre_exec.h"
+
+
+/* ----  CODE DELETED ---- */
+
+
+/* Min and max values for the common repeats; for the maxima, 0 => infinity */
+
+static const char rep_min[] = { 0, 0, 1, 1, 0, 0 };
+static const char rep_max[] = { 0, 0, 0, 0, 1, 1 };
+
+
+/* ----  CODE DELETED ---- */
+
+
+/* Structure for building a chain of data that actually lives on the
+ * stack, for holding the values of the subject pointer at the start of each
+ * subpattern, so as to detect when an empty string has been matched by a
+ * subpattern - to break infinite loops. */
+
+typedef struct eptrblock {
+	  struct eptrblock *prev;
+	    const uschar *saved_eptr;
+} eptrblock;
+
+/* Flag bits for the match() function */
+
+#define match_condassert   0x01    /* Called to check a condition assertion */
+#define match_isgroup      0x02    /* Set if start of bracketed group */
+
+
+/* ----  CODE DELETED ---- */
+
+
+/*************************************************
+ * *               Global variables                 *
+ * *************************************************/
+
+/* PCRE is thread-clean and doesn't use any global variables in the normal
+ * sense. However, it calls memory allocation and free functions via the two
+ * indirections below, which are can be changed by the caller, but are shared
+ * between all threads. */
+
+#ifdef __KERNEL__
+static void *kern_malloc(size_t sz)
+{
+	        return kmalloc(sz, GFP_KERNEL);
+}
+void  *(*pcre_malloc)(size_t) = kern_malloc;
+void  (*pcre_free)(const void *) = kfree;
+#else
+void  *(*pcre_malloc)(size_t) = malloc;
+void  (*pcre_free)(const void *) = free;
+#endif
+
+
+/*************************************************
+ * *    Macros and tables for character handling    *
+ * *************************************************/
+
+/* When UTF-8 encoding is being used, a character is no longer just a single
+ * byte. The macros for character handling generate simple sequences when used in
+ * byte-mode, and more complicated ones for UTF-8 characters. */
+
+#ifndef SUPPORT_UTF8
+#define GETCHARINC(c, eptr) c = *eptr++;
+#define GETCHARLEN(c, eptr, len) c = *eptr;
+#define BACKCHAR(eptr)
+#endif
+
+/* ----  CODE DELETED ---- */
+
+#ifdef DEBUG
+/*************************************************
+*        Debugging function to print chars       *
+*************************************************/
+
+/* Print a sequence of chars in printable format, stopping at the end of the
+subject if the requested.
+
+Arguments:
+  p           points to characters
+  length      number to print
+  is_subject  TRUE if printing from within md->start_subject
+  md          pointer to matching data block, if is_subject is TRUE
+
+Returns:     nothing
+*/
+
+static void
+pchars(const uschar *p, int length, BOOL is_subject, match_data *md)
+{
+int c;
+if (is_subject && length > md->end_subject - p) length = md->end_subject - p;
+while (length-- > 0)
+  if (isprint(c = *(p++))) PCRE_PRINTF("%c", c); else PCRE_PRINTF("\\x%02x", c);
+}
+#endif /* DEBUG */
+
+/* ----  CODE DELETED ---- */
+
+
+/*************************************************
+*          Match a back-reference                *
+*************************************************/
+
+/* If a back reference hasn't been set, the length that is passed is greater
+than the number of characters left in the string, so the match fails.
+
+Arguments:
+  offset      index into the offset vector
+  eptr        points into the subject
+  length      length to be matched
+  md          points to match data block
+  ims         the ims flags
+
+Returns:      TRUE if matched
+*/
+
+static BOOL
+match_ref(int offset, register const uschar *eptr, int length, match_data *md,
+  unsigned long int ims)
+{
+const uschar *p = md->start_subject + md->offset_vector[offset];
+
+#ifdef DEBUG
+if (eptr >= md->end_subject)
+  PCRE_PRINTF("matching subject <null>");
+else
+  {
+  PCRE_PRINTF("matching subject ");
+  pchars(eptr, length, TRUE, md);
+  }
+PCRE_PRINTF(" against backref ");
+pchars(p, length, FALSE, md);
+PCRE_PRINTF("\n");
+#endif
+
+/* Always fail if not enough characters left */
+
+if (length > md->end_subject - eptr) return FALSE;
+
+/* Separate the caselesss case for speed */
+
+if ((ims & PCRE_CASELESS) != 0)
+  {
+  while (length-- > 0)
+    if (md->lcc[*p++] != md->lcc[*eptr++]) return FALSE;
+  }
+else
+  { while (length-- > 0) if (*p++ != *eptr++) return FALSE; }
+
+return TRUE;
+}
+
+
+/*************************************************
+*         Match from current position            *
+*************************************************/
+
+/* On entry ecode points to the first opcode, and eptr to the first character
+in the subject string, while eptrb holds the value of eptr at the start of the
+last bracketed group - used for breaking infinite loops matching zero-length
+strings.
+
+Arguments:
+   eptr        pointer in subject
+   ecode       position in code
+   offset_top  current top pointer
+   md          pointer to "static" info for the match
+   ims         current /i, /m, and /s options
+   eptrb       pointer to chain of blocks containing eptr at start of
+                 brackets - for testing for empty matches
+   flags       can contain
+                 match_condassert - this is an assertion condition
+                 match_isgroup - this is the start of a bracketed group
+
+Returns:       TRUE if matched
+*/
+
+static BOOL
+match(register const uschar *eptr, register const uschar *ecode,
+  int offset_top, match_data *md, unsigned long int ims, eptrblock *eptrb,
+  int flags)
+{
+unsigned long int original_ims = ims;   /* Save for resetting on ')' */
+eptrblock newptrb;
+
+/* At the start of a bracketed group, add the current subject pointer to the
+stack of such pointers, to be re-instated at the end of the group when we hit
+the closing ket. When match() is called in other circumstances, we don't add to
+the stack. */
+
+if ((flags & match_isgroup) != 0)
+  {
+  newptrb.prev = eptrb;
+  newptrb.saved_eptr = eptr;
+  eptrb = &newptrb;
+  }
+
+/* Now start processing the operations. */
+
+for (;;)
+  {
+  int op = (int)*ecode;
+  int min, max, ctype;
+  register int i;
+  register int c;
+  BOOL minimize = FALSE;
+
+  /* Opening capturing bracket. If there is space in the offset vector, save
+  the current subject position in the working slot at the top of the vector. We
+  mustn't change the current values of the data slot, because they may be set
+  from a previous iteration of this group, and be referred to by a reference
+  inside the group.
+
+  If the bracket fails to match, we need to restore this value and also the
+  values of the final offsets, in case they were set by a previous iteration of
+  the same bracket.
+
+  If there isn't enough space in the offset vector, treat this as if it were a
+  non-capturing bracket. Don't worry about setting the flag for the error case
+  here; that is handled in the code for KET. */
+
+  if (op > OP_BRA)
+    {
+    int offset;
+    int number = op - OP_BRA;
+
+    /* For extended extraction brackets (large number), we have to fish out the
+    number from a dummy opcode at the start. */
+
+    if (number > EXTRACT_BASIC_MAX) number = (ecode[4] << 8) | ecode[5];
+    offset = number << 1;
+
+#ifdef DEBUG
+    PCRE_PRINTF("start bracket %d subject=", number);
+    pchars(eptr, 16, TRUE, md);
+    PCRE_PRINTF("\n");
+#endif
+
+    if (offset < md->offset_max)
+      {
+      int save_offset1 = md->offset_vector[offset];
+      int save_offset2 = md->offset_vector[offset+1];
+      int save_offset3 = md->offset_vector[md->offset_end - number];
+
+      DPRINTF(("saving %d %d %d\n", save_offset1, save_offset2, save_offset3));
+      md->offset_vector[md->offset_end - number] = eptr - md->start_subject;
+
+      do
+        {
+        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup))
+          return TRUE;
+        ecode += (ecode[1] << 8) + ecode[2];
+        }
+      while (*ecode == OP_ALT);
+
+      DPRINTF(("bracket %d failed\n", number));
+
+      md->offset_vector[offset] = save_offset1;
+      md->offset_vector[offset+1] = save_offset2;
+      md->offset_vector[md->offset_end - number] = save_offset3;
+
+      return FALSE;
+      }
+
+    /* Insufficient room for saving captured contents */
+
+    else op = OP_BRA;
+    }
+
+  /* Other types of node can be handled by a switch */
+
+  switch(op)
+    {
+    case OP_BRA:     /* Non-capturing bracket: optimized */
+    DPRINTF(("start bracket 0\n"));
+    do
+      {
+      if (match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup))
+        return TRUE;
+      ecode += (ecode[1] << 8) + ecode[2];
+      }
+    while (*ecode == OP_ALT);
+    DPRINTF(("bracket 0 failed\n"));
+    return FALSE;
+
+    /* Conditional group: compilation checked that there are no more than
+    two branches. If the condition is false, skipping the first branch takes us
+    past the end if there is only one branch, but that's OK because that is
+    exactly what going to the ket would do. */
+
+    case OP_COND:
+    if (ecode[3] == OP_CREF)         /* Condition is extraction test */
+      {
+      int offset = (ecode[4] << 9) | (ecode[5] << 1); /* Doubled ref number */
+      return match(eptr,
+        ecode + ((offset < offset_top && md->offset_vector[offset] >= 0)?
+          6 : 3 + (ecode[1] << 8) + ecode[2]),
+        offset_top, md, ims, eptrb, match_isgroup);
+      }
+
+    /* The condition is an assertion. Call match() to evaluate it - setting
+    the final argument TRUE causes it to stop at the end of an assertion. */
+
+    else
+      {
+      if (match(eptr, ecode+3, offset_top, md, ims, NULL,
+          match_condassert | match_isgroup))
+        {
+        ecode += 3 + (ecode[4] << 8) + ecode[5];
+        while (*ecode == OP_ALT) ecode += (ecode[1] << 8) + ecode[2];
+        }
+      else ecode += (ecode[1] << 8) + ecode[2];
+      return match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup);
+      }
+    /* Control never reaches here */
+
+    /* Skip over conditional reference or large extraction number data if
+    encountered. */
+
+    case OP_CREF:
+    case OP_BRANUMBER:
+    ecode += 3;
+    break;
+
+    /* End of the pattern. If PCRE_NOTEMPTY is set, fail if we have matched
+    an empty string - recursion will then try other alternatives, if any. */
+
+    case OP_END:
+    if (md->notempty && eptr == md->start_match) return FALSE;
+    md->end_match_ptr = eptr;          /* Record where we ended */
+    md->end_offset_top = offset_top;   /* and how many extracts were taken */
+    return TRUE;
+
+    /* Change option settings */
+
+    case OP_OPT:
+    ims = ecode[1];
+    ecode += 2;
+    DPRINTF(("ims set to %02lx\n", ims));
+    break;
+
+    /* Assertion brackets. Check the alternative branches in turn - the
+    matching won't pass the KET for an assertion. If any one branch matches,
+    the assertion is true. Lookbehind assertions have an OP_REVERSE item at the
+    start of each branch to move the current point backwards, so the code at
+    this level is identical to the lookahead case. */
+
+    case OP_ASSERT:
+    case OP_ASSERTBACK:
+    do
+      {
+      if (match(eptr, ecode+3, offset_top, md, ims, NULL, match_isgroup)) break;
+      ecode += (ecode[1] << 8) + ecode[2];
+      }
+    while (*ecode == OP_ALT);
+    if (*ecode == OP_KET) return FALSE;
+
+    /* If checking an assertion for a condition, return TRUE. */
+
+    if ((flags & match_condassert) != 0) return TRUE;
+
+    /* Continue from after the assertion, updating the offsets high water
+    mark, since extracts may have been taken during the assertion. */
+
+    do ecode += (ecode[1] << 8) + ecode[2]; while (*ecode == OP_ALT);
+    ecode += 3;
+    offset_top = md->end_offset_top;
+    continue;
+
+    /* Negative assertion: all branches must fail to match */
+
+    case OP_ASSERT_NOT:
+    case OP_ASSERTBACK_NOT:
+    do
+      {
+      if (match(eptr, ecode+3, offset_top, md, ims, NULL, match_isgroup))
+        return FALSE;
+      ecode += (ecode[1] << 8) + ecode[2];
+      }
+    while (*ecode == OP_ALT);
+
+    if ((flags & match_condassert) != 0) return TRUE;
+
+    ecode += 3;
+    continue;
+
+    /* Move the subject pointer back. This occurs only at the start of
+    each branch of a lookbehind assertion. If we are too close to the start to
+    move back, this match function fails. When working with UTF-8 we move
+    back a number of characters, not bytes. */
+
+    case OP_REVERSE:
+#ifdef SUPPORT_UTF8
+    c = (ecode[1] << 8) + ecode[2];
+    for (i = 0; i < c; i++)
+      {
+      eptr--;
+      BACKCHAR(eptr)
+      }
+#else
+    eptr -= (ecode[1] << 8) + ecode[2];
+#endif
+
+    if (eptr < md->start_subject) return FALSE;
+    ecode += 3;
+    break;
+
+    /* Recursion matches the current regex, nested. If there are any capturing
+    brackets started but not finished, we have to save their starting points
+    and reinstate them after the recursion. However, we don't know how many
+    such there are (offset_top records the completed total) so we just have
+    to save all the potential data. There may be up to 99 such values, which
+    is a bit large to put on the stack, but using malloc for small numbers
+    seems expensive. As a compromise, the stack is used when there are fewer
+    than 16 values to store; otherwise malloc is used. A problem is what to do
+    if the malloc fails ... there is no way of returning to the top level with
+    an error. Save the top 15 values on the stack, and accept that the rest
+    may be wrong. */
+
+    case OP_RECURSE:
+      {
+      BOOL rc;
+      int *save;
+      int stacksave[15];
+
+      c = md->offset_max;
+
+      if (c < 16) save = stacksave; else
+        {
+        save = (int *)(pcre_malloc)((c+1) * sizeof(int));
+        if (save == NULL)
+          {
+          save = stacksave;
+          c = 15;
+          }
+        }
+
+      for (i = 1; i <= c; i++)
+        save[i] = md->offset_vector[md->offset_end - i];
+      rc = match(eptr, md->start_pattern, offset_top, md, ims, eptrb,
+        match_isgroup);
+      for (i = 1; i <= c; i++)
+        md->offset_vector[md->offset_end - i] = save[i];
+      if (save != stacksave) (pcre_free)(save);
+      if (!rc) return FALSE;
+
+      /* In case the recursion has set more capturing values, save the final
+      number, then move along the subject till after the recursive match,
+      and advance one byte in the pattern code. */
+
+      offset_top = md->end_offset_top;
+      eptr = md->end_match_ptr;
+      ecode++;
+      }
+    break;
+
+    /* "Once" brackets are like assertion brackets except that after a match,
+    the point in the subject string is not moved back. Thus there can never be
+    a move back into the brackets. Check the alternative branches in turn - the
+    matching won't pass the KET for this kind of subpattern. If any one branch
+    matches, we carry on as at the end of a normal bracket, leaving the subject
+    pointer. */
+
+    case OP_ONCE:
+      {
+      const uschar *prev = ecode;
+      const uschar *saved_eptr = eptr;
+
+      do
+        {
+        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup))
+          break;
+        ecode += (ecode[1] << 8) + ecode[2];
+        }
+      while (*ecode == OP_ALT);
+
+      /* If hit the end of the group (which could be repeated), fail */
+
+      if (*ecode != OP_ONCE && *ecode != OP_ALT) return FALSE;
+
+      /* Continue as from after the assertion, updating the offsets high water
+      mark, since extracts may have been taken. */
+
+      do ecode += (ecode[1] << 8) + ecode[2]; while (*ecode == OP_ALT);
+
+      offset_top = md->end_offset_top;
+      eptr = md->end_match_ptr;
+
+      /* For a non-repeating ket, just continue at this level. This also
+      happens for a repeating ket if no characters were matched in the group.
+      This is the forcible breaking of infinite loops as implemented in Perl
+      5.005. If there is an options reset, it will get obeyed in the normal
+      course of events. */
+
+      if (*ecode == OP_KET || eptr == saved_eptr)
+        {
+        ecode += 3;
+        break;
+        }
+
+      /* The repeating kets try the rest of the pattern or restart from the
+      preceding bracket, in the appropriate order. We need to reset any options
+      that changed within the bracket before re-running it, so check the next
+      opcode. */
+
+      if (ecode[3] == OP_OPT)
+        {
+        ims = (ims & ~PCRE_IMS) | ecode[4];
+        DPRINTF(("ims set to %02lx at group repeat\n", ims));
+        }
+
+      if (*ecode == OP_KETRMIN)
+        {
+        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, 0) ||
+            match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup))
+              return TRUE;
+        }
+      else  /* OP_KETRMAX */
+        {
+        if (match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup) ||
+            match(eptr, ecode+3, offset_top, md, ims, eptrb, 0)) return TRUE;
+        }
+      }
+    return FALSE;
+
+    /* An alternation is the end of a branch; scan along to find the end of the
+    bracketed group and go to there. */
+
+    case OP_ALT:
+    do ecode += (ecode[1] << 8) + ecode[2]; while (*ecode == OP_ALT);
+    break;
+
+    /* BRAZERO and BRAMINZERO occur just before a bracket group, indicating
+    that it may occur zero times. It may repeat infinitely, or not at all -
+    i.e. it could be ()* or ()? in the pattern. Brackets with fixed upper
+    repeat limits are compiled as a number of copies, with the optional ones
+    preceded by BRAZERO or BRAMINZERO. */
+
+    case OP_BRAZERO:
+      {
+      const uschar *next = ecode+1;
+      if (match(eptr, next, offset_top, md, ims, eptrb, match_isgroup))
+        return TRUE;
+      do next += (next[1] << 8) + next[2]; while (*next == OP_ALT);
+      ecode = next + 3;
+      }
+    break;
+
+    case OP_BRAMINZERO:
+      {
+      const uschar *next = ecode+1;
+      do next += (next[1] << 8) + next[2]; while (*next == OP_ALT);
+      if (match(eptr, next+3, offset_top, md, ims, eptrb, match_isgroup))
+        return TRUE;
+      ecode++;
+      }
+    break;
+
+    /* End of a group, repeated or non-repeating. If we are at the end of
+    an assertion "group", stop matching and return TRUE, but record the
+    current high water mark for use by positive assertions. Do this also
+    for the "once" (not-backup up) groups. */
+
+    case OP_KET:
+    case OP_KETRMIN:
+    case OP_KETRMAX:
+      {
+      const uschar *prev = ecode - (ecode[1] << 8) - ecode[2];
+      const uschar *saved_eptr = eptrb->saved_eptr;
+
+      eptrb = eptrb->prev;    /* Back up the stack of bracket start pointers */
+
+      if (*prev == OP_ASSERT || *prev == OP_ASSERT_NOT ||
+          *prev == OP_ASSERTBACK || *prev == OP_ASSERTBACK_NOT ||
+          *prev == OP_ONCE)
+        {
+        md->end_match_ptr = eptr;      /* For ONCE */
+        md->end_offset_top = offset_top;
+        return TRUE;
+        }
+
+      /* In all other cases except a conditional group we have to check the
+      group number back at the start and if necessary complete handling an
+      extraction by setting the offsets and bumping the high water mark. */
+
+      if (*prev != OP_COND)
+        {
+        int offset;
+        int number = *prev - OP_BRA;
+
+        /* For extended extraction brackets (large number), we have to fish out
+        the number from a dummy opcode at the start. */
+
+        if (number > EXTRACT_BASIC_MAX) number = (prev[4] << 8) | prev[5];
+        offset = number << 1;
+
+#ifdef DEBUG
+        PCRE_PRINTF("end bracket %d", number);
+        PCRE_PRINTF("\n");
+#endif
+
+        if (number > 0)
+          {
+          if (offset >= md->offset_max) md->offset_overflow = TRUE; else
+            {
+            md->offset_vector[offset] =
+              md->offset_vector[md->offset_end - number];
+            md->offset_vector[offset+1] = eptr - md->start_subject;
+            if (offset_top <= offset) offset_top = offset + 2;
+            }
+          }
+        }
+
+      /* Reset the value of the ims flags, in case they got changed during
+      the group. */
+
+      ims = original_ims;
+      DPRINTF(("ims reset to %02lx\n", ims));
+
+      /* For a non-repeating ket, just continue at this level. This also
+      happens for a repeating ket if no characters were matched in the group.
+      This is the forcible breaking of infinite loops as implemented in Perl
+      5.005. If there is an options reset, it will get obeyed in the normal
+      course of events. */
+
+      if (*ecode == OP_KET || eptr == saved_eptr)
+        {
+        ecode += 3;
+        break;
+        }
+
+      /* The repeating kets try the rest of the pattern or restart from the
+      preceding bracket, in the appropriate order. */
+
+      if (*ecode == OP_KETRMIN)
+        {
+        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, 0) ||
+            match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup))
+              return TRUE;
+        }
+      else  /* OP_KETRMAX */
+        {
+        if (match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup) ||
+            match(eptr, ecode+3, offset_top, md, ims, eptrb, 0)) return TRUE;
+        }
+      }
+    return FALSE;
+
+    /* Start of subject unless notbol, or after internal newline if multiline */
+
+    case OP_CIRC:
+    if (md->notbol && eptr == md->start_subject) return FALSE;
+    if ((ims & PCRE_MULTILINE) != 0)
+      {
+      if (eptr != md->start_subject && eptr[-1] != NEWLINE) return FALSE;
+      ecode++;
+      break;
+      }
+    /* ... else fall through */
+
+    /* Start of subject assertion */
+
+    case OP_SOD:
+    if (eptr != md->start_subject) return FALSE;
+    ecode++;
+    break;
+
+    /* Assert before internal newline if multiline, or before a terminating
+    newline unless endonly is set, else end of subject unless noteol is set. */
+
+    case OP_DOLL:
+    if ((ims & PCRE_MULTILINE) != 0)
+      {
+      if (eptr < md->end_subject) { if (*eptr != NEWLINE) return FALSE; }
+        else { if (md->noteol) return FALSE; }
+      ecode++;
+      break;
+      }
+    else
+      {
+      if (md->noteol) return FALSE;
+      if (!md->endonly)
+        {
+        if (eptr < md->end_subject - 1 ||
+           (eptr == md->end_subject - 1 && *eptr != NEWLINE)) return FALSE;
+
+        ecode++;
+        break;
+        }
+      }
+    /* ... else fall through */
+
+    /* End of subject assertion (\z) */
+
+    case OP_EOD:
+    if (eptr < md->end_subject) return FALSE;
+    ecode++;
+    break;
+
+    /* End of subject or ending \n assertion (\Z) */
+
+    case OP_EODN:
+    if (eptr < md->end_subject - 1 ||
+       (eptr == md->end_subject - 1 && *eptr != NEWLINE)) return FALSE;
+    ecode++;
+    break;
+
+    /* Word boundary assertions */
+
+    case OP_NOT_WORD_BOUNDARY:
+    case OP_WORD_BOUNDARY:
+      {
+      BOOL prev_is_word = (eptr != md->start_subject) &&
+        ((md->ctypes[eptr[-1]] & ctype_word) != 0);
+      BOOL cur_is_word = (eptr < md->end_subject) &&
+        ((md->ctypes[*eptr] & ctype_word) != 0);
+      if ((*ecode++ == OP_WORD_BOUNDARY)?
+           cur_is_word == prev_is_word : cur_is_word != prev_is_word)
+        return FALSE;
+      }
+    break;
+
+    /* Match a single character type; inline for speed */
+
+    case OP_ANY:
+    if ((ims & PCRE_DOTALL) == 0 && eptr < md->end_subject && *eptr == NEWLINE)
+      return FALSE;
+    if (eptr++ >= md->end_subject) return FALSE;
+#ifdef SUPPORT_UTF8
+    if (md->utf8)
+      while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+#endif
+    ecode++;
+    break;
+
+    case OP_NOT_DIGIT:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_digit) != 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_DIGIT:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_digit) == 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_NOT_WHITESPACE:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_space) != 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_WHITESPACE:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_space) == 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_NOT_WORDCHAR:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_word) != 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_WORDCHAR:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_word) == 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    /* Match a back reference, possibly repeatedly. Look past the end of the
+    item to see if there is repeat information following. The code is similar
+    to that for character classes, but repeated for efficiency. Then obey
+    similar code to character type repeats - written out again for speed.
+    However, if the referenced string is the empty string, always treat
+    it as matched, any number of times (otherwise there could be infinite
+    loops). */
+
+    case OP_REF:
+      {
+      int length;
+      int offset = (ecode[1] << 9) | (ecode[2] << 1); /* Doubled ref number */
+      ecode += 3;                                     /* Advance past item */
+
+      /* If the reference is unset, set the length to be longer than the amount
+      of subject left; this ensures that every attempt at a match fails. We
+      can't just fail here, because of the possibility of quantifiers with zero
+      minima. */
+
+      length = (offset >= offset_top || md->offset_vector[offset] < 0)?
+        md->end_subject - eptr + 1 :
+        md->offset_vector[offset+1] - md->offset_vector[offset];
+
+      /* Set up for repetition, or handle the non-repeated case */
+
+      switch (*ecode)
+        {
+        case OP_CRSTAR:
+        case OP_CRMINSTAR:
+        case OP_CRPLUS:
+        case OP_CRMINPLUS:
+        case OP_CRQUERY:
+        case OP_CRMINQUERY:
+        c = *ecode++ - OP_CRSTAR;
+        minimize = (c & 1) != 0;
+        min = rep_min[c];                 /* Pick up values from tables; */
+        max = rep_max[c];                 /* zero for max => infinity */
+        if (max == 0) max = INT_MAX;
+        break;
+
+        case OP_CRRANGE:
+        case OP_CRMINRANGE:
+        minimize = (*ecode == OP_CRMINRANGE);
+        min = (ecode[1] << 8) + ecode[2];
+        max = (ecode[3] << 8) + ecode[4];
+        if (max == 0) max = INT_MAX;
+        ecode += 5;
+        break;
+
+        default:               /* No repeat follows */
+        if (!match_ref(offset, eptr, length, md, ims)) return FALSE;
+        eptr += length;
+        continue;              /* With the main loop */
+        }
+
+      /* If the length of the reference is zero, just continue with the
+      main loop. */
+
+      if (length == 0) continue;
+
+      /* First, ensure the minimum number of matches are present. We get back
+      the length of the reference string explicitly rather than passing the
+      address of eptr, so that eptr can be a register variable. */
+
+      for (i = 1; i <= min; i++)
+        {
+        if (!match_ref(offset, eptr, length, md, ims)) return FALSE;
+        eptr += length;
+        }
+
+      /* If min = max, continue at the same level without recursion.
+      They are not both allowed to be zero. */
+
+      if (min == max) continue;
+
+      /* If minimizing, keep trying and advancing the pointer */
+
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || !match_ref(offset, eptr, length, md, ims))
+            return FALSE;
+          eptr += length;
+          }
+        /* Control never gets here */
+        }
+
+      /* If maximizing, find the longest string and work backwards */
+
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (!match_ref(offset, eptr, length, md, ims)) break;
+          eptr += length;
+          }
+        while (eptr >= pp)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          eptr -= length;
+          }
+        return FALSE;
+        }
+      }
+    /* Control never gets here */
+
+
+
+    /* Match a character class, possibly repeatedly. Look past the end of the
+    item to see if there is repeat information following. Then obey similar
+    code to character type repeats - written out again for speed. */
+
+    case OP_CLASS:
+      {
+      const uschar *data = ecode + 1;  /* Save for matching */
+      ecode += 33;                     /* Advance past the item */
+
+      switch (*ecode)
+        {
+        case OP_CRSTAR:
+        case OP_CRMINSTAR:
+        case OP_CRPLUS:
+        case OP_CRMINPLUS:
+        case OP_CRQUERY:
+        case OP_CRMINQUERY:
+        c = *ecode++ - OP_CRSTAR;
+        minimize = (c & 1) != 0;
+        min = rep_min[c];                 /* Pick up values from tables; */
+        max = rep_max[c];                 /* zero for max => infinity */
+        if (max == 0) max = INT_MAX;
+        break;
+
+        case OP_CRRANGE:
+        case OP_CRMINRANGE:
+        minimize = (*ecode == OP_CRMINRANGE);
+        min = (ecode[1] << 8) + ecode[2];
+        max = (ecode[3] << 8) + ecode[4];
+        if (max == 0) max = INT_MAX;
+        ecode += 5;
+        break;
+
+        default:               /* No repeat follows */
+        min = max = 1;
+        break;
+        }
+
+      /* First, ensure the minimum number of matches are present. */
+
+      for (i = 1; i <= min; i++)
+        {
+        if (eptr >= md->end_subject) return FALSE;
+        GETCHARINC(c, eptr)         /* Get character; increment eptr */
+
+#ifdef SUPPORT_UTF8
+        /* We do not yet support class members > 255 */
+        if (c > 255) return FALSE;
+#endif
+
+        if ((data[c/8] & (1 << (c&7))) != 0) continue;
+        return FALSE;
+        }
+
+      /* If max == min we can continue with the main loop without the
+      need to recurse. */
+
+      if (min == max) continue;
+
+      /* If minimizing, keep testing the rest of the expression and advancing
+      the pointer while it matches the class. */
+
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject) return FALSE;
+          GETCHARINC(c, eptr)       /* Get character; increment eptr */
+
+#ifdef SUPPORT_UTF8
+          /* We do not yet support class members > 255 */
+          if (c > 255) return FALSE;
+#endif
+          if ((data[c/8] & (1 << (c&7))) != 0) continue;
+          return FALSE;
+          }
+        /* Control never gets here */
+        }
+
+      /* If maximizing, find the longest possible run, then work backwards. */
+
+      else
+        {
+        const uschar *pp = eptr;
+        int len = 1;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject) break;
+          GETCHARLEN(c, eptr, len)  /* Get character, set length if UTF-8 */
+
+#ifdef SUPPORT_UTF8
+          /* We do not yet support class members > 255 */
+          if (c > 255) break;
+#endif
+          if ((data[c/8] & (1 << (c&7))) == 0) break;
+          eptr += len;
+          }
+
+        while (eptr >= pp)
+          {
+          if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+
+#ifdef SUPPORT_UTF8
+          BACKCHAR(eptr)
+#endif
+          }
+        return FALSE;
+        }
+      }
+    /* Control never gets here */
+
+    /* Match a run of characters */
+
+    case OP_CHARS:
+      {
+      register int length = ecode[1];
+      ecode += 2;
+
+#ifdef DEBUG    /* Sigh. Some compilers never learn. */
+      if (eptr >= md->end_subject)
+        PCRE_PRINTF("matching subject <null> against pattern ");
+      else
+        {
+        PCRE_PRINTF("matching subject ");
+        pchars(eptr, length, TRUE, md);
+        PCRE_PRINTF(" against pattern ");
+        }
+      pchars(ecode, length, FALSE, md);
+      PCRE_PRINTF("\n");
+#endif
+
+      if (length > md->end_subject - eptr) return FALSE;
+      if ((ims & PCRE_CASELESS) != 0)
+        {
+        while (length-- > 0)
+          if (md->lcc[*ecode++] != md->lcc[*eptr++])
+            return FALSE;
+        }
+      else
+        {
+        while (length-- > 0) if (*ecode++ != *eptr++) return FALSE;
+        }
+      }
+    break;
+
+    /* Match a single character repeatedly; different opcodes share code. */
+
+    case OP_EXACT:
+    min = max = (ecode[1] << 8) + ecode[2];
+    ecode += 3;
+    goto REPEATCHAR;
+
+    case OP_UPTO:
+    case OP_MINUPTO:
+    min = 0;
+    max = (ecode[1] << 8) + ecode[2];
+    minimize = *ecode == OP_MINUPTO;
+    ecode += 3;
+    goto REPEATCHAR;
+
+    case OP_STAR:
+    case OP_MINSTAR:
+    case OP_PLUS:
+    case OP_MINPLUS:
+    case OP_QUERY:
+    case OP_MINQUERY:
+    c = *ecode++ - OP_STAR;
+    minimize = (c & 1) != 0;
+    min = rep_min[c];                 /* Pick up values from tables; */
+    max = rep_max[c];                 /* zero for max => infinity */
+    if (max == 0) max = INT_MAX;
+
+    /* Common code for all repeated single-character matches. We can give
+    up quickly if there are fewer than the minimum number of characters left in
+    the subject. */
+
+    REPEATCHAR:
+    if (min > md->end_subject - eptr) return FALSE;
+    c = *ecode++;
+
+    /* The code is duplicated for the caseless and caseful cases, for speed,
+    since matching characters is likely to be quite common. First, ensure the
+    minimum number of matches are present. If min = max, continue at the same
+    level without recursing. Otherwise, if minimizing, keep trying the rest of
+    the expression and advancing one matching character if failing, up to the
+    maximum. Alternatively, if maximizing, find the maximum number of
+    characters and work backwards. */
+
+    DPRINTF(("matching %c{%d,%d} against subject %.*s\n", c, min, max,
+      max, eptr));
+
+    if ((ims & PCRE_CASELESS) != 0)
+      {
+      c = md->lcc[c];
+      for (i = 1; i <= min; i++)
+        if (c != md->lcc[*eptr++]) return FALSE;
+      if (min == max) continue;
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject ||
+              c != md->lcc[*eptr++])
+            return FALSE;
+          }
+        /* Control never gets here */
+        }
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || c != md->lcc[*eptr]) break;
+          eptr++;
+          }
+        while (eptr >= pp)
+          if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+        return FALSE;
+        }
+      /* Control never gets here */
+      }
+
+    /* Caseful comparisons */
+
+    else
+      {
+      for (i = 1; i <= min; i++) if (c != *eptr++) return FALSE;
+      if (min == max) continue;
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject || c != *eptr++) return FALSE;
+          }
+        /* Control never gets here */
+        }
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || c != *eptr) break;
+          eptr++;
+          }
+        while (eptr >= pp)
+         if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+           return TRUE;
+        return FALSE;
+        }
+      }
+    /* Control never gets here */
+
+    /* Match a negated single character */
+
+    case OP_NOT:
+    if (eptr >= md->end_subject) return FALSE;
+    ecode++;
+    if ((ims & PCRE_CASELESS) != 0)
+      {
+      if (md->lcc[*ecode++] == md->lcc[*eptr++]) return FALSE;
+      }
+    else
+      {
+      if (*ecode++ == *eptr++) return FALSE;
+      }
+    break;
+
+    /* Match a negated single character repeatedly. This is almost a repeat of
+    the code for a repeated single character, but I haven't found a nice way of
+    commoning these up that doesn't require a test of the positive/negative
+    option for each character match. Maybe that wouldn't add very much to the
+    time taken, but character matching *is* what this is all about... */
+
+    case OP_NOTEXACT:
+    min = max = (ecode[1] << 8) + ecode[2];
+    ecode += 3;
+    goto REPEATNOTCHAR;
+
+    case OP_NOTUPTO:
+    case OP_NOTMINUPTO:
+    min = 0;
+    max = (ecode[1] << 8) + ecode[2];
+    minimize = *ecode == OP_NOTMINUPTO;
+    ecode += 3;
+    goto REPEATNOTCHAR;
+
+    case OP_NOTSTAR:
+    case OP_NOTMINSTAR:
+    case OP_NOTPLUS:
+    case OP_NOTMINPLUS:
+    case OP_NOTQUERY:
+    case OP_NOTMINQUERY:
+    c = *ecode++ - OP_NOTSTAR;
+    minimize = (c & 1) != 0;
+    min = rep_min[c];                 /* Pick up values from tables; */
+    max = rep_max[c];                 /* zero for max => infinity */
+    if (max == 0) max = INT_MAX;
+
+    /* Common code for all repeated single-character matches. We can give
+    up quickly if there are fewer than the minimum number of characters left in
+    the subject. */
+
+    REPEATNOTCHAR:
+    if (min > md->end_subject - eptr) return FALSE;
+    c = *ecode++;
+
+    /* The code is duplicated for the caseless and caseful cases, for speed,
+    since matching characters is likely to be quite common. First, ensure the
+    minimum number of matches are present. If min = max, continue at the same
+    level without recursing. Otherwise, if minimizing, keep trying the rest of
+    the expression and advancing one matching character if failing, up to the
+    maximum. Alternatively, if maximizing, find the maximum number of
+    characters and work backwards. */
+
+    DPRINTF(("negative matching %c{%d,%d} against subject %.*s\n", c, min, max,
+      max, eptr));
+
+    if ((ims & PCRE_CASELESS) != 0)
+      {
+      c = md->lcc[c];
+      for (i = 1; i <= min; i++)
+        if (c == md->lcc[*eptr++]) return FALSE;
+      if (min == max) continue;
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject ||
+              c == md->lcc[*eptr++])
+            return FALSE;
+          }
+        /* Control never gets here */
+        }
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || c == md->lcc[*eptr]) break;
+          eptr++;
+          }
+        while (eptr >= pp)
+          if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+        return FALSE;
+        }
+      /* Control never gets here */
+      }
+
+    /* Caseful comparisons */
+
+    else
+      {
+      for (i = 1; i <= min; i++) if (c == *eptr++) return FALSE;
+      if (min == max) continue;
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject || c == *eptr++) return FALSE;
+          }
+        /* Control never gets here */
+        }
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || c == *eptr) break;
+          eptr++;
+          }
+        while (eptr >= pp)
+         if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+           return TRUE;
+        return FALSE;
+        }
+      }
+    /* Control never gets here */
+
+    /* Match a single character type repeatedly; several different opcodes
+    share code. This is very similar to the code for single characters, but we
+    repeat it in the interests of efficiency. */
+
+    case OP_TYPEEXACT:
+    min = max = (ecode[1] << 8) + ecode[2];
+    minimize = TRUE;
+    ecode += 3;
+    goto REPEATTYPE;
+
+    case OP_TYPEUPTO:
+    case OP_TYPEMINUPTO:
+    min = 0;
+    max = (ecode[1] << 8) + ecode[2];
+    minimize = *ecode == OP_TYPEMINUPTO;
+    ecode += 3;
+    goto REPEATTYPE;
+
+    case OP_TYPESTAR:
+    case OP_TYPEMINSTAR:
+    case OP_TYPEPLUS:
+    case OP_TYPEMINPLUS:
+    case OP_TYPEQUERY:
+    case OP_TYPEMINQUERY:
+    c = *ecode++ - OP_TYPESTAR;
+    minimize = (c & 1) != 0;
+    min = rep_min[c];                 /* Pick up values from tables; */
+    max = rep_max[c];                 /* zero for max => infinity */
+    if (max == 0) max = INT_MAX;
+
+    /* Common code for all repeated single character type matches */
+
+    REPEATTYPE:
+    ctype = *ecode++;      /* Code for the character type */
+
+    /* First, ensure the minimum number of matches are present. Use inline
+    code for maximizing the speed, and do the type test once at the start
+    (i.e. keep it out of the loop). Also we can test that there are at least
+    the minimum number of bytes before we start, except when doing '.' in
+    UTF8 mode. Leave the test in in all cases; in the special case we have
+    to test after each character. */
+
+    if (min > md->end_subject - eptr) return FALSE;
+    if (min > 0) switch(ctype)
+      {
+      case OP_ANY:
+#ifdef SUPPORT_UTF8
+      if (md->utf8)
+        {
+        for (i = 1; i <= min; i++)
+          {
+          if (eptr >= md->end_subject ||
+             (*eptr++ == NEWLINE && (ims & PCRE_DOTALL) == 0))
+            return FALSE;
+          while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+          }
+        break;
+        }
+#endif
+      /* Non-UTF8 can be faster */
+      if ((ims & PCRE_DOTALL) == 0)
+        { for (i = 1; i <= min; i++) if (*eptr++ == NEWLINE) return FALSE; }
+      else eptr += min;
+      break;
+
+      case OP_NOT_DIGIT:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_digit) != 0) return FALSE;
+      break;
+
+      case OP_DIGIT:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_digit) == 0) return FALSE;
+      break;
+
+      case OP_NOT_WHITESPACE:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_space) != 0) return FALSE;
+      break;
+
+      case OP_WHITESPACE:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_space) == 0) return FALSE;
+      break;
+
+      case OP_NOT_WORDCHAR:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_word) != 0)
+          return FALSE;
+      break;
+
+      case OP_WORDCHAR:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_word) == 0)
+          return FALSE;
+      break;
+      }
+
+    /* If min = max, continue at the same level without recursing */
+
+    if (min == max) continue;
+
+    /* If minimizing, we have to test the rest of the pattern before each
+    subsequent match. */
+
+    if (minimize)
+      {
+      for (i = min;; i++)
+        {
+        if (match(eptr, ecode, offset_top, md, ims, eptrb, 0)) return TRUE;
+        if (i >= max || eptr >= md->end_subject) return FALSE;
+
+        c = *eptr++;
+        switch(ctype)
+          {
+          case OP_ANY:
+          if ((ims & PCRE_DOTALL) == 0 && c == NEWLINE) return FALSE;
+#ifdef SUPPORT_UTF8
+          if (md->utf8)
+            while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+#endif
+          break;
+
+          case OP_NOT_DIGIT:
+          if ((md->ctypes[c] & ctype_digit) != 0) return FALSE;
+          break;
+
+          case OP_DIGIT:
+          if ((md->ctypes[c] & ctype_digit) == 0) return FALSE;
+          break;
+
+          case OP_NOT_WHITESPACE:
+          if ((md->ctypes[c] & ctype_space) != 0) return FALSE;
+          break;
+
+          case OP_WHITESPACE:
+          if  ((md->ctypes[c] & ctype_space) == 0) return FALSE;
+          break;
+
+          case OP_NOT_WORDCHAR:
+          if ((md->ctypes[c] & ctype_word) != 0) return FALSE;
+          break;
+
+          case OP_WORDCHAR:
+          if ((md->ctypes[c] & ctype_word) == 0) return FALSE;
+          break;
+          }
+        }
+      /* Control never gets here */
+      }
+
+    /* If maximizing it is worth using inline code for speed, doing the type
+    test once at the start (i.e. keep it out of the loop). */
+
+    else
+      {
+      const uschar *pp = eptr;
+      switch(ctype)
+        {
+        case OP_ANY:
+
+        /* Special code is required for UTF8, but when the maximum is unlimited
+        we don't need it. */
+
+#ifdef SUPPORT_UTF8
+        if (md->utf8 && max < INT_MAX)
+          {
+          if ((ims & PCRE_DOTALL) == 0)
+            {
+            for (i = min; i < max; i++)
+              {
+              if (eptr >= md->end_subject || *eptr++ == NEWLINE) break;
+              while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+              }
+            }
+          else
+            {
+            for (i = min; i < max; i++)
+              {
+              eptr++;
+              while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+              }
+            }
+          break;
+          }
+#endif
+        /* Non-UTF8 can be faster */
+        if ((ims & PCRE_DOTALL) == 0)
+          {
+          for (i = min; i < max; i++)
+            {
+            if (eptr >= md->end_subject || *eptr == NEWLINE) break;
+            eptr++;
+            }
+          }
+        else
+          {
+          c = max - min;
+          if (c > md->end_subject - eptr) c = md->end_subject - eptr;
+          eptr += c;
+          }
+        break;
+
+        case OP_NOT_DIGIT:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) != 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_DIGIT:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) == 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_NOT_WHITESPACE:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) != 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_WHITESPACE:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) == 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_NOT_WORDCHAR:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) != 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_WORDCHAR:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) == 0)
+            break;
+          eptr++;
+          }
+        break;
+        }
+
+      while (eptr >= pp)
+        {
+        if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+          return TRUE;
+#ifdef SUPPORT_UTF8
+        if (md->utf8)
+          while (eptr > pp && (*eptr & 0xc0) == 0x80) eptr--;
+#endif
+        }
+      return FALSE;
+      }
+    /* Control never gets here */
+
+    /* There's been some horrible disaster. */
+
+    default:
+    DPRINTF(("Unknown opcode %d\n", *ecode));
+    md->errorcode = PCRE_ERROR_UNKNOWN_NODE;
+    return FALSE;
+    }
+
+  /* Do not stick any code in here without much thought; it is assumed
+  that "continue" in the code above comes out to here to repeat the main
+  loop. */
+
+  }             /* End of main loop */
+/* Control never reaches here */
+}
+
+
+/*************************************************
+*         Execute a Regular Expression           *
+*************************************************/
+
+/* This function applies a compiled re to a subject string and picks out
+portions of the string if it matches. Two elements in the vector are set for
+each substring: the offsets to the start and end of the substring.
+
+Arguments:
+  external_re     points to the compiled expression
+  external_extra  points to "hints" from pcre_study() or is NULL
+  subject         points to the subject string
+  length          length of subject string (may contain binary zeros)
+  start_offset    where to start in the subject string
+  options         option bits
+  offsets         points to a vector of ints to be filled in with offsets
+  offsetcount     the number of elements in the vector
+
+Returns:          > 0 => success; value is the number of elements filled in
+                  = 0 => success, but offsets is not big enough
+                   -1 => failed to match
+                 < -1 => some kind of unexpected problem
+*/
+
+int
+pcre_exec(const pcre *external_re, const pcre_extra *external_extra,
+  const char *subject, int length, int start_offset, int options, int *offsets,
+  int offsetcount)
+{
+int resetcount, ocount;
+int first_char = -1;
+int req_char = -1;
+int req_char2 = -1;
+unsigned long int ims = 0;
+match_data match_block;
+const uschar *start_bits = NULL;
+const uschar *start_match = (const uschar *)subject + start_offset;
+const uschar *end_subject;
+const uschar *req_char_ptr = start_match - 1;
+const real_pcre *re = (const real_pcre *)external_re;
+const real_pcre_extra *extra = (const real_pcre_extra *)external_extra;
+BOOL using_temporary_offsets = FALSE;
+BOOL anchored;
+BOOL startline;
+
+if ((options & ~PUBLIC_EXEC_OPTIONS) != 0) return PCRE_ERROR_BADOPTION;
+
+if (re == NULL || subject == NULL ||
+   (offsets == NULL && offsetcount > 0)) return PCRE_ERROR_NULL;
+if (re->magic_number != MAGIC_NUMBER) return PCRE_ERROR_BADMAGIC;
+
+anchored = ((re->options | options) & PCRE_ANCHORED) != 0;
+startline = (re->options & PCRE_STARTLINE) != 0;
+
+match_block.start_pattern = re->code;
+match_block.start_subject = (const uschar *)subject;
+match_block.end_subject = match_block.start_subject + length;
+end_subject = match_block.end_subject;
+
+match_block.endonly = (re->options & PCRE_DOLLAR_ENDONLY) != 0;
+match_block.utf8 = (re->options & PCRE_UTF8) != 0;
+
+match_block.notbol = (options & PCRE_NOTBOL) != 0;
+match_block.noteol = (options & PCRE_NOTEOL) != 0;
+match_block.notempty = (options & PCRE_NOTEMPTY) != 0;
+
+match_block.errorcode = PCRE_ERROR_NOMATCH;     /* Default error */
+
+match_block.lcc = re->tables + lcc_offset;
+match_block.ctypes = re->tables + ctypes_offset;
+
+/* The ims options can vary during the matching as a result of the presence
+of (?ims) items in the pattern. They are kept in a local variable so that
+restoring at the exit of a group is easy. */
+
+ims = re->options & (PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL);
+
+/* If the expression has got more back references than the offsets supplied can
+hold, we get a temporary bit of working store to use during the matching.
+Otherwise, we can use the vector supplied, rounding down its size to a multiple
+of 3. */
+
+ocount = offsetcount - (offsetcount % 3);
+
+if (re->top_backref > 0 && re->top_backref >= ocount/3)
+  {
+  ocount = re->top_backref * 3 + 3;
+  match_block.offset_vector = (int *)(pcre_malloc)(ocount * sizeof(int));
+  if (match_block.offset_vector == NULL) return PCRE_ERROR_NOMEMORY;
+  using_temporary_offsets = TRUE;
+  DPRINTF(("Got memory to hold back references\n"));
+  }
+else match_block.offset_vector = offsets;
+
+match_block.offset_end = ocount;
+match_block.offset_max = (2*ocount)/3;
+match_block.offset_overflow = FALSE;
+
+/* Compute the minimum number of offsets that we need to reset each time. Doing
+this makes a huge difference to execution time when there aren't many brackets
+in the pattern. */
+
+resetcount = 2 + re->top_bracket * 2;
+if (resetcount > offsetcount) resetcount = ocount;
+
+/* Reset the working variable associated with each extraction. These should
+never be used unless previously set, but they get saved and restored, and so we
+initialize them to avoid reading uninitialized locations. */
+
+if (match_block.offset_vector != NULL)
+  {
+  register int *iptr = match_block.offset_vector + ocount;
+  register int *iend = iptr - resetcount/2 + 1;
+  while (--iptr >= iend) *iptr = -1;
+  }
+
+/* Set up the first character to match, if available. The first_char value is
+never set for an anchored regular expression, but the anchoring may be forced
+at run time, so we have to test for anchoring. The first char may be unset for
+an unanchored pattern, of course. If there's no first char and the pattern was
+studied, there may be a bitmap of possible first characters. */
+
+if (!anchored)
+  {
+  if ((re->options & PCRE_FIRSTSET) != 0)
+    {
+    first_char = re->first_char;
+    if ((ims & PCRE_CASELESS) != 0) first_char = match_block.lcc[first_char];
+    }
+  else
+    if (!startline && extra != NULL &&
+      (extra->options & PCRE_STUDY_MAPPED) != 0)
+        start_bits = extra->start_bits;
+  }
+
+/* For anchored or unanchored matches, there may be a "last known required
+character" set. If the PCRE_CASELESS is set, implying that the match starts
+caselessly, or if there are any changes of this flag within the regex, set up
+both cases of the character. Otherwise set the two values the same, which will
+avoid duplicate testing (which takes significant time). This covers the vast
+majority of cases. It will be suboptimal when the case flag changes in a regex
+and the required character in fact is caseful. */
+
+if ((re->options & PCRE_REQCHSET) != 0)
+  {
+  req_char = re->req_char;
+  req_char2 = ((re->options & (PCRE_CASELESS | PCRE_ICHANGED)) != 0)?
+    (re->tables + fcc_offset)[req_char] : req_char;
+  }
+
+/* Loop for handling unanchored repeated matching attempts; for anchored regexs
+the loop runs just once. */
+
+do
+  {
+  int rc;
+  register int *iptr = match_block.offset_vector;
+  register int *iend = iptr + resetcount;
+
+  /* Reset the maximum number of extractions we might see. */
+
+  while (iptr < iend) *iptr++ = -1;
+
+  /* Advance to a unique first char if possible */
+
+  if (first_char >= 0)
+    {
+    if ((ims & PCRE_CASELESS) != 0)
+      while (start_match < end_subject &&
+             match_block.lcc[*start_match] != first_char)
+        start_match++;
+    else
+      while (start_match < end_subject && *start_match != first_char)
+        start_match++;
+    }
+
+  /* Or to just after \n for a multiline match if possible */
+
+  else if (startline)
+    {
+    if (start_match > match_block.start_subject + start_offset)
+      {
+      while (start_match < end_subject && start_match[-1] != NEWLINE)
+        start_match++;
+      }
+    }
+
+  /* Or to a non-unique first char after study */
+
+  else if (start_bits != NULL)
+    {
+    while (start_match < end_subject)
+      {
+      register int c = *start_match;
+      if ((start_bits[c/8] & (1 << (c&7))) == 0) start_match++; else break;
+      }
+    }
+
+#ifdef DEBUG  /* Sigh. Some compilers never learn. */
+  PCRE_PRINTF(">>>> Match against: ");
+  pchars(start_match, end_subject - start_match, TRUE, &match_block);
+  PCRE_PRINTF("\n");
+#endif
+
+  /* If req_char is set, we know that that character must appear in the subject
+  for the match to succeed. If the first character is set, req_char must be
+  later in the subject; otherwise the test starts at the match point. This
+  optimization can save a huge amount of backtracking in patterns with nested
+  unlimited repeats that aren't going to match. We don't know what the state of
+  case matching may be when this character is hit, so test for it in both its
+  cases if necessary. However, the different cased versions will not be set up
+  unless PCRE_CASELESS was given or the casing state changes within the regex.
+  Writing separate code makes it go faster, as does using an autoincrement and
+  backing off on a match. */
+
+  if (req_char >= 0)
+    {
+    register const uschar *p = start_match + ((first_char >= 0)? 1 : 0);
+
+    /* We don't need to repeat the search if we haven't yet reached the
+    place we found it at last time. */
+
+    if (p > req_char_ptr)
+      {
+      /* Do a single test if no case difference is set up */
+
+      if (req_char == req_char2)
+        {
+        while (p < end_subject)
+          {
+          if (*p++ == req_char) { p--; break; }
+          }
+        }
+
+      /* Otherwise test for either case */
+
+      else
+        {
+        while (p < end_subject)
+          {
+          register int pp = *p++;
+          if (pp == req_char || pp == req_char2) { p--; break; }
+          }
+        }
+
+      /* If we can't find the required character, break the matching loop */
+
+      if (p >= end_subject) break;
+
+      /* If we have found the required character, save the point where we
+      found it, so that we don't search again next time round the loop if
+      the start hasn't passed this character yet. */
+
+      req_char_ptr = p;
+      }
+    }
+
+  /* When a match occurs, substrings will be set for all internal extractions;
+  we just need to set up the whole thing as substring 0 before returning. If
+  there were too many extractions, set the return code to zero. In the case
+  where we had to get some local store to hold offsets for backreferences, copy
+  those back references that we can. In this case there need not be overflow
+  if certain parts of the pattern were not used. */
+
+  match_block.start_match = start_match;
+  if (!match(start_match, re->code, 2, &match_block, ims, NULL, match_isgroup))
+    continue;
+
+  /* Copy the offset information from temporary store if necessary */
+
+  if (using_temporary_offsets)
+    {
+    if (offsetcount >= 4)
+      {
+      memcpy(offsets + 2, match_block.offset_vector + 2,
+        (offsetcount - 2) * sizeof(int));
+      DPRINTF(("Copied offsets from temporary memory\n"));
+      }
+    if (match_block.end_offset_top > offsetcount)
+      match_block.offset_overflow = TRUE;
+
+    DPRINTF(("Freeing temporary memory\n"));
+    (pcre_free)(match_block.offset_vector);
+    }
+
+  rc = match_block.offset_overflow? 0 : match_block.end_offset_top/2;
+
+  if (offsetcount < 2) rc = 0; else
+    {
+    offsets[0] = start_match - match_block.start_subject;
+    offsets[1] = match_block.end_match_ptr - match_block.start_subject;
+    }
+
+  DPRINTF((">>>> returning %d\n", rc));
+  return rc;
+  }
+
+/* This "while" is the end of the "do" above */
+
+while (!anchored &&
+       match_block.errorcode == PCRE_ERROR_NOMATCH &&
+       start_match++ < end_subject);
+
+if (using_temporary_offsets)
+  {
+  DPRINTF(("Freeing temporary memory\n"));
+  (pcre_free)(match_block.offset_vector);
+  }
+
+DPRINTF((">>>> returning %d\n", match_block.errorcode));
+
+return match_block.errorcode;
+}
+
+/* End of pcre.c */
Index: linux-2.6.14/security/subdomain/sdmatch/pcre_exec.h
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/sdmatch/pcre_exec.h
@@ -0,0 +1,308 @@
+/*
+ *  This is a modified header file containing the definitions from
+ *  pcre.h and internal.h required to support pcre_exec()
+ */
+
+
+/*************************************************
+*       Perl-Compatible Regular Expressions      *
+*************************************************/
+
+/* Copyright (c) 1997-2001 University of Cambridge */
+
+#ifndef _PCRE_H
+#define _PCRE_H
+
+/* ----- CODE ADDED ---- */
+
+#ifdef __KERNEL__
+#include <linux/slab.h>	// for kmalloc/kfree
+#endif
+
+#ifdef __KERNEL__
+#define PCRE_PRINTF printk
+#define isprint(x) ((unsigned char)(x) >= 128 && (unsigned char)(x) <= 255)
+#else
+#define PCRE_PRINTF printf
+#endif
+
+/* The value of NEWLINE determines the newline character. The default is to
+ * leave it up to the compiler, but some sites want to force a particular value.
+ * On Unix systems, "configure" can be used to override this default. */
+
+#ifndef NEWLINE
+#define NEWLINE '\n'
+#endif
+
+/* ----  CODE DELETED ---- */
+
+/* Options */
+
+#define PCRE_CASELESS        0x0001
+#define PCRE_MULTILINE       0x0002
+#define PCRE_DOTALL          0x0004
+#define PCRE_EXTENDED        0x0008
+#define PCRE_ANCHORED        0x0010
+#define PCRE_DOLLAR_ENDONLY  0x0020
+#define PCRE_EXTRA           0x0040
+#define PCRE_NOTBOL          0x0080
+#define PCRE_NOTEOL          0x0100
+#define PCRE_UNGREEDY        0x0200
+#define PCRE_NOTEMPTY        0x0400
+#define PCRE_UTF8            0x0800
+
+/* Exec-time and get-time error codes */
+
+#define PCRE_ERROR_NOMATCH        (-1)
+#define PCRE_ERROR_NULL           (-2)
+#define PCRE_ERROR_BADOPTION      (-3)
+#define PCRE_ERROR_BADMAGIC       (-4)
+#define PCRE_ERROR_UNKNOWN_NODE   (-5)
+#define PCRE_ERROR_NOMEMORY       (-6)
+#define PCRE_ERROR_NOSUBSTRING    (-7)
+
+/* ----  CODE DELETED ---- */
+
+/* Types */
+
+struct real_pcre;        /* declaration; the definition is private  */
+struct real_pcre_extra;  /* declaration; the definition is private */
+
+typedef struct real_pcre pcre;
+typedef struct real_pcre_extra pcre_extra;
+
+/* ----  CODE DELETED ---- */
+
+extern int pcre_exec(const pcre *, const pcre_extra *,
+		     const char *, int, int, int, int *,
+		     int);
+
+/* ----  CODE ADDED (from internal.h) ---- */
+
+/* These are the public options that can change during matching. */
+
+#define PCRE_IMS (PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL)
+
+/* Private options flags start at the most significant end of the four bytes,
+but skip the top bit so we can use ints for convenience without getting tangled
+with negative values. The public options defined in pcre.h start at the least
+significant end. Make sure they don't overlap, though now that we have expanded
+to four bytes there is plenty of space. */
+
+#define PCRE_FIRSTSET      0x40000000  /* first_char is set */
+#define PCRE_REQCHSET      0x20000000  /* req_char is set */
+#define PCRE_STARTLINE     0x10000000  /* start after \n for multiline */
+#define PCRE_ICHANGED      0x04000000  /* i option changes within regex */
+
+/* Options for the "extra" block produced by pcre_study(). */
+
+#define PCRE_STUDY_MAPPED   0x01     /* a map of starting chars exists */
+
+/* Masks for identifying the public options which are permitted at compile
+time, run time or study time, respectively. */
+
+#define PUBLIC_EXEC_OPTIONS \
+    (PCRE_ANCHORED|PCRE_NOTBOL|PCRE_NOTEOL|PCRE_NOTEMPTY)
+
+/* Magic number to provide a small check against being handed junk. */
+
+#define MAGIC_NUMBER  0x50435245UL   /* 'PCRE' */
+
+typedef int BOOL;
+
+#define FALSE   0
+#define TRUE    1
+
+/* Opcode table: OP_BRA must be last, as all values >= it are used for brackets
+that extract substrings. Starting from 1 (i.e. after OP_END), the values up to
+OP_EOD must correspond in order to the list of escapes immediately above. */
+
+enum {
+  OP_END,            /* End of pattern */
+
+  /* Values corresponding to backslashed metacharacters */
+
+  OP_SOD,            /* Start of data: \A */
+  OP_NOT_WORD_BOUNDARY,  /* \B */
+  OP_WORD_BOUNDARY,      /* \b */
+  OP_NOT_DIGIT,          /* \D */
+  OP_DIGIT,              /* \d */
+  OP_NOT_WHITESPACE,     /* \S */
+  OP_WHITESPACE,         /* \s */
+  OP_NOT_WORDCHAR,       /* \W */
+  OP_WORDCHAR,           /* \w */
+  OP_EODN,           /* End of data or \n at end of data: \Z. */
+  OP_EOD,            /* End of data: \z */
+
+  OP_OPT,            /* Set runtime options */
+  OP_CIRC,           /* Start of line - varies with multiline switch */
+  OP_DOLL,           /* End of line - varies with multiline switch */
+  OP_ANY,            /* Match any character */
+  OP_CHARS,          /* Match string of characters */
+  OP_NOT,            /* Match anything but the following char */
+
+  OP_STAR,           /* The maximizing and minimizing versions of */
+  OP_MINSTAR,        /* all these opcodes must come in pairs, with */
+  OP_PLUS,           /* the minimizing one second. */
+  OP_MINPLUS,        /* This first set applies to single characters */
+  OP_QUERY,
+  OP_MINQUERY,
+  OP_UPTO,           /* From 0 to n matches */
+  OP_MINUPTO,
+  OP_EXACT,          /* Exactly n matches */
+
+  OP_NOTSTAR,        /* The maximizing and minimizing versions of */
+  OP_NOTMINSTAR,     /* all these opcodes must come in pairs, with */
+  OP_NOTPLUS,        /* the minimizing one second. */
+  OP_NOTMINPLUS,     /* This first set applies to "not" single characters */
+  OP_NOTQUERY,
+  OP_NOTMINQUERY,
+  OP_NOTUPTO,        /* From 0 to n matches */
+  OP_NOTMINUPTO,
+  OP_NOTEXACT,       /* Exactly n matches */
+
+  OP_TYPESTAR,       /* The maximizing and minimizing versions of */
+  OP_TYPEMINSTAR,    /* all these opcodes must come in pairs, with */
+  OP_TYPEPLUS,       /* the minimizing one second. These codes must */
+  OP_TYPEMINPLUS,    /* be in exactly the same order as those above. */
+  OP_TYPEQUERY,      /* This set applies to character types such as \d */
+  OP_TYPEMINQUERY,
+  OP_TYPEUPTO,       /* From 0 to n matches */
+  OP_TYPEMINUPTO,
+  OP_TYPEEXACT,      /* Exactly n matches */
+
+  OP_CRSTAR,         /* The maximizing and minimizing versions of */
+  OP_CRMINSTAR,      /* all these opcodes must come in pairs, with */
+  OP_CRPLUS,         /* the minimizing one second. These codes must */
+  OP_CRMINPLUS,      /* be in exactly the same order as those above. */
+  OP_CRQUERY,        /* These are for character classes and back refs */
+  OP_CRMINQUERY,
+  OP_CRRANGE,        /* These are different to the three seta above. */
+  OP_CRMINRANGE,
+
+  OP_CLASS,          /* Match a character class */
+  OP_REF,            /* Match a back reference */
+  OP_RECURSE,        /* Match this pattern recursively */
+
+  OP_ALT,            /* Start of alternation */
+  OP_KET,            /* End of group that doesn't have an unbounded repeat */
+  OP_KETRMAX,        /* These two must remain together and in this */
+  OP_KETRMIN,        /* order. They are for groups the repeat for ever. */
+
+  /* The assertions must come before ONCE and COND */
+
+  OP_ASSERT,         /* Positive lookahead */
+  OP_ASSERT_NOT,     /* Negative lookahead */
+  OP_ASSERTBACK,     /* Positive lookbehind */
+  OP_ASSERTBACK_NOT, /* Negative lookbehind */
+  OP_REVERSE,        /* Move pointer back - used in lookbehind assertions */
+
+  /* ONCE and COND must come after the assertions, with ONCE first, as there's
+  a test for >= ONCE for a subpattern that isn't an assertion. */
+
+  OP_ONCE,           /* Once matched, don't back up into the subpattern */
+  OP_COND,           /* Conditional group */
+  OP_CREF,           /* Used to hold an extraction string number (cond ref) */
+
+  OP_BRAZERO,        /* These two must remain together and in this */
+  OP_BRAMINZERO,     /* order. */
+
+  OP_BRANUMBER,      /* Used for extracting brackets whose number is greater
+                        than can fit into an opcode. */
+
+  OP_BRA             /* This and greater values are used for brackets that
+                        extract substrings up to a basic limit. After that,
+                        use is made of OP_BRANUMBER. */
+};
+
+/* The highest extraction number before we have to start using additional
+bytes. (Originally PCRE didn't have support for extraction counts highter than
+this number.) The value is limited by the number of opcodes left after OP_BRA,
+i.e. 255 - OP_BRA. We actually set it a bit lower to leave room for additional
+opcodes. */
+
+#define EXTRACT_BASIC_MAX  150
+
+/* All character handling must be done as unsigned characters. Otherwise there
+are problems with top-bit-set characters and functions such as isspace().
+However, we leave the interface to the outside world as char *, because that
+should make things easier for callers. We define a short type for unsigned char
+to save lots of typing. I tried "uchar", but it causes problems on Digital
+Unix, where it is defined in sys/types, so use "uschar" instead. */
+
+typedef unsigned char uschar;
+
+/* The real format of the start of the pcre block; the actual code vector
+runs on as long as necessary after the end. */
+
+typedef struct real_pcre {
+  unsigned long int magic_number;
+  size_t size;
+  const unsigned char *tables;
+  unsigned long int options;
+  unsigned short int top_bracket;
+  unsigned short int top_backref;
+  uschar first_char;
+  uschar req_char;
+  uschar code[1];
+} real_pcre;
+
+/* The real format of the extra block returned by pcre_study(). */
+
+typedef struct real_pcre_extra {
+  uschar options;
+  uschar start_bits[32];
+} real_pcre_extra;
+
+/* Structure for passing "static" information around between the functions
+doing the matching, so that they are thread-safe. */
+
+typedef struct match_data {
+  int    errorcode;             /* As it says */
+  int   *offset_vector;         /* Offset vector */
+  int    offset_end;            /* One past the end */
+  int    offset_max;            /* The maximum usable for return data */
+  const uschar *lcc;            /* Points to lower casing table */
+  const uschar *ctypes;         /* Points to table of type maps */
+  BOOL   offset_overflow;       /* Set if too many extractions */
+  BOOL   notbol;                /* NOTBOL flag */
+  BOOL   noteol;                /* NOTEOL flag */
+  BOOL   utf8;                  /* UTF8 flag */
+  BOOL   endonly;               /* Dollar not before final \n */
+  BOOL   notempty;              /* Empty string match not wanted */
+  const uschar *start_pattern;  /* For use when recursing */
+  const uschar *start_subject;  /* Start of the subject string */
+  const uschar *end_subject;    /* End of the subject string */
+  const uschar *start_match;    /* Start of this match attempt */
+  const uschar *end_match_ptr;  /* Subject position at end match */
+  int    end_offset_top;        /* Highwater mark at end of match */
+} match_data;
+
+/* Bit definitions for entries in the pcre_ctypes table. */
+
+#define ctype_space   0x01
+#define ctype_letter  0x02
+#define ctype_digit   0x04
+#define ctype_xdigit  0x08
+#define ctype_word    0x10   /* alphameric or '_' */
+#define ctype_meta    0x80   /* regexp meta char or zero (end pattern) */
+
+/* Offsets for the bitmap tables in pcre_cbits. Each table contains a set
+of bits for a class map. Some classes are built by combining these tables. */
+
+#define cbit_length  320      /* Length of the cbits table */
+
+/* Offsets of the various tables from the base tables pointer, and
+total length. */
+
+#define lcc_offset      0
+#define fcc_offset    256
+
+#define fcc_offset    256
+#define cbits_offset  512
+#define ctypes_offset (cbits_offset + cbit_length)
+
+/* ----- CODE ADDED ---- */
+
+#endif // _PCRE_H
+ /* End of pcre.h */
Index: linux-2.6.14/security/subdomain/sdmatch/pcre_tables.h
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/sdmatch/pcre_tables.h
@@ -0,0 +1,184 @@
+
+/*************************************************
+*      Perl-Compatible Regular Expressions       *
+*************************************************/
+
+/* This file is automatically written by the dftables auxiliary
+program. If you edit it by hand, you might like to edit the Makefile to
+prevent its ever being regenerated.
+
+This file is #included in the compilation of pcre.c to build the default
+character tables which are used when no tables are passed to the compile
+function. */
+
+static unsigned char pcre_default_tables[] = {
+
+/* This table is a lower casing table. */
+
+    0,  1,  2,  3,  4,  5,  6,  7,
+    8,  9, 10, 11, 12, 13, 14, 15,
+   16, 17, 18, 19, 20, 21, 22, 23,
+   24, 25, 26, 27, 28, 29, 30, 31,
+   32, 33, 34, 35, 36, 37, 38, 39,
+   40, 41, 42, 43, 44, 45, 46, 47,
+   48, 49, 50, 51, 52, 53, 54, 55,
+   56, 57, 58, 59, 60, 61, 62, 63,
+   64, 97, 98, 99,100,101,102,103,
+  104,105,106,107,108,109,110,111,
+  112,113,114,115,116,117,118,119,
+  120,121,122, 91, 92, 93, 94, 95,
+   96, 97, 98, 99,100,101,102,103,
+  104,105,106,107,108,109,110,111,
+  112,113,114,115,116,117,118,119,
+  120,121,122,123,124,125,126,127,
+  128,129,130,131,132,133,134,135,
+  136,137,138,139,140,141,142,143,
+  144,145,146,147,148,149,150,151,
+  152,153,154,155,156,157,158,159,
+  160,161,162,163,164,165,166,167,
+  168,169,170,171,172,173,174,175,
+  176,177,178,179,180,181,182,183,
+  184,185,186,187,188,189,190,191,
+  192,193,194,195,196,197,198,199,
+  200,201,202,203,204,205,206,207,
+  208,209,210,211,212,213,214,215,
+  216,217,218,219,220,221,222,223,
+  224,225,226,227,228,229,230,231,
+  232,233,234,235,236,237,238,239,
+  240,241,242,243,244,245,246,247,
+  248,249,250,251,252,253,254,255,
+
+/* This table is a case flipping table. */
+
+    0,  1,  2,  3,  4,  5,  6,  7,
+    8,  9, 10, 11, 12, 13, 14, 15,
+   16, 17, 18, 19, 20, 21, 22, 23,
+   24, 25, 26, 27, 28, 29, 30, 31,
+   32, 33, 34, 35, 36, 37, 38, 39,
+   40, 41, 42, 43, 44, 45, 46, 47,
+   48, 49, 50, 51, 52, 53, 54, 55,
+   56, 57, 58, 59, 60, 61, 62, 63,
+   64, 97, 98, 99,100,101,102,103,
+  104,105,106,107,108,109,110,111,
+  112,113,114,115,116,117,118,119,
+  120,121,122, 91, 92, 93, 94, 95,
+   96, 65, 66, 67, 68, 69, 70, 71,
+   72, 73, 74, 75, 76, 77, 78, 79,
+   80, 81, 82, 83, 84, 85, 86, 87,
+   88, 89, 90,123,124,125,126,127,
+  128,129,130,131,132,133,134,135,
+  136,137,138,139,140,141,142,143,
+  144,145,146,147,148,149,150,151,
+  152,153,154,155,156,157,158,159,
+  160,161,162,163,164,165,166,167,
+  168,169,170,171,172,173,174,175,
+  176,177,178,179,180,181,182,183,
+  184,185,186,187,188,189,190,191,
+  192,193,194,195,196,197,198,199,
+  200,201,202,203,204,205,206,207,
+  208,209,210,211,212,213,214,215,
+  216,217,218,219,220,221,222,223,
+  224,225,226,227,228,229,230,231,
+  232,233,234,235,236,237,238,239,
+  240,241,242,243,244,245,246,247,
+  248,249,250,251,252,253,254,255,
+
+/* This table contains bit maps for various character classes.
+Each map is 32 bytes long and the bits run from the least
+significant end of each byte. The classes that have their own
+maps are: space, xdigit, digit, upper, lower, word, graph
+print, punct, and cntrl. Other classes are built from combinations. */
+
+  0x00,0x3e,0x00,0x00,0x01,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,
+  0x7e,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0xfe,0xff,0xff,0x07,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0x07,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,
+  0xfe,0xff,0xff,0x87,0xfe,0xff,0xff,0x07,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0xfe,0xff,0x00,0xfc,
+  0x01,0x00,0x00,0xf8,0x01,0x00,0x00,0x78,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+/* This table identifies various classes of character by individual bits:
+  0x01   white space character
+  0x02   letter
+  0x04   decimal digit
+  0x08   hexadecimal digit
+  0x10   alphanumeric or '_'
+  0x80   regular expression metacharacter or binary zero
+*/
+
+  0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*   0-  7 */
+  0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00, /*   8- 15 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  16- 23 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  24- 31 */
+  0x01,0x00,0x00,0x00,0x80,0x00,0x00,0x00, /*    - '  */
+  0x80,0x80,0x80,0x80,0x00,0x00,0x80,0x00, /*  ( - /  */
+  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c, /*  0 - 7  */
+  0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,0x80, /*  8 - ?  */
+  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  @ - G  */
+  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  H - O  */
+  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  P - W  */
+  0x12,0x12,0x12,0x80,0x00,0x00,0x80,0x10, /*  X - _  */
+  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  ` - g  */
+  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  h - o  */
+  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  p - w  */
+  0x12,0x12,0x12,0x80,0x80,0x00,0x00,0x00, /*  x -127 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 128-135 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 136-143 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 144-151 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 152-159 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 160-167 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 168-175 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 176-183 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 184-191 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 192-199 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 200-207 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 208-215 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 216-223 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 224-231 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 232-239 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 240-247 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/* 248-255 */
+
+/* End of chartables.c */
Index: linux-2.6.14/security/subdomain/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/Kconfig
@@ -0,0 +1,3 @@
+config SECURITY_SUBDOMAIN
+	tristate "Subdomain support"
+	depends on SECURITY!=n
Index: linux-2.6.14/security/subdomain/sdmatch/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.14/security/subdomain/sdmatch/Makefile
@@ -0,0 +1,8 @@
+# Makefile for SubDomain sdmatch submodule
+#
+
+EXTRA_CFLAGS += -Werror -Wwrite-strings
+
+obj-$(CONFIG_SECURITY_SUBDOMAIN) += sdmatch_pcre.o
+
+sdmatch_pcre-y := match_pcre.o pcre_exec.o
