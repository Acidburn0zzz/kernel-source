From: Steve Beattie <steve@wirex.net>
Subject: add subdomain support

Add subdomain support
As per mail from Crispin from Dec 6 2004, this module is 
under the GPL.

Acked-by: draht@suse.de

diff -uNrp linux-2.6.11/security/Kconfig linux-2.6.11.subd-new/security/Kconfig
--- linux-2.6.11/security/Kconfig	2005-03-17 22:29:23.000000000 +0100
+++ linux-2.6.11.subd-new/security/Kconfig	2005-03-17 22:15:35.000000000 +0100
@@ -86,6 +86,7 @@ config SECURITY_SECLVL
 	  If you are unsure how to answer this question, answer N.
 
 source security/selinux/Kconfig
+source security/subdomain/Kconfig
 
 endmenu
 
diff -uNrp linux-2.6.11/security/Makefile linux-2.6.11.subd-new/security/Makefile
--- linux-2.6.11/security/Makefile	2005-03-17 22:29:23.000000000 +0100
+++ linux-2.6.11.subd-new/security/Makefile	2005-03-17 22:15:35.000000000 +0100
@@ -4,6 +4,7 @@
 
 obj-$(CONFIG_KEYS)			+= keys/
 subdir-$(CONFIG_SECURITY_SELINUX)	+= selinux
+subdir-$(CONFIG_SECURITY_SUBDOMAIN)	+= subdomain
 
 # We always need commoncap as it's default
 obj-y		+= commoncap.o
diff -uNrp linux-2.6.11/security/subdomain/Kconfig linux-2.6.11.subd-new/security/subdomain/Kconfig
--- linux-2.6.11/security/subdomain/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/Kconfig	2005-03-17 22:15:35.000000000 +0100
@@ -0,0 +1,3 @@
+config SECURITY_SUBDOMAIN
+	tristate "Subdomain support"
+	depends on SECURITY!=n
diff -uNrp linux-2.6.11/security/subdomain/Makefile linux-2.6.11.subd-new/security/subdomain/Makefile
--- linux-2.6.11/security/subdomain/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/Makefile	2005-03-17 22:32:30.000000000 +0100
@@ -0,0 +1,15 @@
+# $Id: Makefile,v 1.31 2004/10/01 17:28:37 tony Exp $
+#
+# Makefile for SubDomain Linux Security Module
+#
+
+__NETDOMAIN_CFLAG=
+#__NETDOMAIN_CFLAG=-DNETDOMAIN -DNETDOMAIN_SKUSERS
+
+SD_CFLAGS=-DSUBDOMAIN_PROCATTR -DSUBDOMAIN_FS -DPRINTK_TEMPFIX ${__NETDOMAIN_CFLAG}
+
+EXTRA_CFLAGS += -DSUBDOMAIN_VERSION=\"${SUBDOMAINVER}\" ${SD_CFLAGS} -DSD_26_INTERFACE
+
+obj-$(CONFIG_SECURITY_SUBDOMAIN) += subdomain.o
+
+subdomain-objs := main.o list.o sysctl.o lsm.o subdomainfs.o pcre_exec.o capabilities.o subdomain_version.o
diff -uNrp linux-2.6.11/security/subdomain/capabilities.c linux-2.6.11.subd-new/security/subdomain/capabilities.c
--- linux-2.6.11/security/subdomain/capabilities.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/capabilities.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,41 @@
+static char *capnames[]={
+	"chown",
+	"dac_override",
+	"dac_read_search",
+	"fowner",
+	"fsetid",
+	"kill",
+	"setgid",
+	"setuid",
+	"setpcap",
+	"linux_immutable",
+	"net_bind_service",
+	"net_broadcast",
+	"net_admin",
+	"net_raw",
+	"ipc_lock",
+	"ipc_owner",
+	"sys_module",
+	"sys_rawio",
+	"sys_chroot",
+	"sys_ptrace",
+	"sys_pacct",
+	"sys_admin",
+	"sys_boot",
+	"sys_nice",
+	"sys_resource",
+	"sys_time",
+	"sys_tty_config",
+	"mknod",
+	"lease"
+};
+
+char * capability_to_name(int cap)
+{
+	char *capname;
+
+	capname = (cap < (sizeof(capnames) / sizeof(char *)) 
+		? capnames[cap] : "invalid-capability");
+
+	return capname;
+}
diff -uNrp linux-2.6.11/security/subdomain/immunix.h linux-2.6.11.subd-new/security/subdomain/immunix.h
--- linux-2.6.11/security/subdomain/immunix.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/immunix.h	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,224 @@
+/*======================================================================*/
+/*									*/
+/*  Immunix CoDomain / CryptoMark Toolkit:				*/
+/*  Copyright 2000, 2001 Wirex Communications, Inc. 			*/
+/*									*/
+/*	Written by Steve Beattie <steve@wirex.net>			*/
+/*	and Greg Kroah-Hartman <greg@wirex.com>				*/
+/*									*/
+/*  linux/include/linux/immunix.h:					*/
+/*									*/
+/*======================================================================*/
+
+#ifndef _IMMUNIX_H
+#define _IMMUNIX_H
+
+#ifdef __KERNEL__
+#include <linux/in.h>
+#else
+#include <netinet/in.h>
+#endif
+
+#ifdef __KERNEL__
+#include "pcre_exec.h"
+#else
+#include "pcre/internal.h"
+#endif
+
+#define IMMUNIX_SCAFFOLD_VERSION	"0.2.6"
+
+/*======================================================================
+ *
+ *  SubDomain specific things
+ *
+ *======================================================================*/
+
+#define KERN_COD_ADD		1
+#define KERN_COD_DELETE		2
+#define KERN_COD_REPLACE	3
+
+#define SD_ADD_PROFILE		1
+#define SD_DELETE_PROFILE	2
+#define SD_REPLACE_PROFILE	3
+#define SD_DEBUG_PROFILE	4
+
+#define SD_CHANGE_HAT		10
+
+/* $ echo -n subdomain.o | md5sum | cut -c -8 */
+#define SD_ID_MAGIC		0x8c235e38
+
+// start of system offsets 
+#define POS_KERN_COD_FILE_MIN		0
+#define POS_KERN_COD_MAY_EXEC		POS_KERN_COD_FILE_MIN
+#define POS_KERN_COD_MAY_WRITE		(POS_KERN_COD_MAY_EXEC + 1)
+#define POS_KERN_COD_MAY_READ		(POS_KERN_COD_MAY_WRITE + 1)
+// not used by Subdomain
+#define POS_KERN_COD_MAY_APPEND		(POS_KERN_COD_MAY_READ + 1)
+// end of system offsets 
+
+#define POS_KERN_COD_MAY_LINK		(POS_KERN_COD_MAY_APPEND + 1)
+#define POS_KERN_COD_EXEC_INHERIT	(POS_KERN_COD_MAY_LINK + 1)
+#define POS_KERN_COD_EXEC_UNCONSTRAINED (POS_KERN_COD_EXEC_INHERIT + 1)
+#define POS_KERN_COD_EXEC_PROFILE	(POS_KERN_COD_EXEC_UNCONSTRAINED + 1)
+#define POS_KERN_COD_FILE_MAX		POS_KERN_COD_EXEC_PROFILE
+
+#define POS_KERN_COD_NET_MIN		(POS_KERN_COD_FILE_MAX + 1)
+#define POS_KERN_COD_TCP_CONNECT	POS_KERN_COD_NET_MIN
+#define POS_KERN_COD_TCP_ACCEPT		(POS_KERN_COD_TCP_CONNECT + 1)
+#define POS_KERN_COD_TCP_CONNECTED	(POS_KERN_COD_TCP_ACCEPT + 1)
+#define POS_KERN_COD_TCP_ACCEPTED	(POS_KERN_COD_TCP_CONNECTED + 1)
+#define POS_KERN_COD_UDP_SEND		(POS_KERN_COD_TCP_ACCEPTED + 1)
+#define POS_KERN_COD_UDP_RECEIVE	(POS_KERN_COD_UDP_SEND + 1)
+#define POS_KERN_COD_NET_MAX		POS_KERN_COD_UDP_RECEIVE
+
+/* logging only */
+#define POS_KERN_COD_LOGTCP_SEND	(POS_KERN_COD_NET_MAX + 1)
+#define POS_KERN_COD_LOGTCP_RECEIVE	(POS_KERN_COD_LOGTCP_SEND + 1)
+
+/* Absolute MAX/MIN */
+#define POS_KERN_COD_MIN		(POS_KERN_COD_FILE_MIN
+#define POS_KERN_COD_MAX		(POS_KERN_COD_NET_MAX
+
+/* Modeled after MAY_READ, MAY_WRITE, MAY_EXEC def'ns */
+#define KERN_COD_MAY_EXEC    	(0x01 << POS_KERN_COD_MAY_EXEC)
+#define KERN_COD_MAY_WRITE   	(0x01 << POS_KERN_COD_MAY_WRITE)
+#define KERN_COD_MAY_READ    	(0x01 << POS_KERN_COD_MAY_READ)
+#define KERN_COD_MAY_LINK	(0x01 << POS_KERN_COD_MAY_LINK) 
+#define KERN_COD_EXEC_INHERIT 	(0x01 << POS_KERN_COD_EXEC_INHERIT)
+#define KERN_COD_EXEC_UNCONSTRAINED	(0x01 << POS_KERN_COD_EXEC_UNCONSTRAINED) 
+#define KERN_COD_EXEC_PROFILE	(0x01 << POS_KERN_COD_EXEC_PROFILE) 
+#define KERN_EXEC_MODIFIERS(X)	(X & (KERN_COD_EXEC_INHERIT | \
+				      KERN_COD_EXEC_UNCONSTRAINED | \
+				      KERN_COD_EXEC_PROFILE))
+/* Network subdomain extensions.  */
+#define KERN_COD_TCP_CONNECT    (0x01 << POS_KERN_COD_TCP_CONNECT)
+#define KERN_COD_TCP_ACCEPT     (0x01 << POS_KERN_COD_TCP_ACCEPT)
+#define KERN_COD_TCP_CONNECTED  (0x01 << POS_KERN_COD_TCP_CONNECTED)
+#define KERN_COD_TCP_ACCEPTED   (0x01 << POS_KERN_COD_TCP_ACCEPTED)
+#define KERN_COD_UDP_SEND       (0x01 << POS_KERN_COD_UDP_SEND)
+#define KERN_COD_UDP_RECEIVE    (0x01 << POS_KERN_COD_UDP_RECEIVE)
+
+#define KERN_COD_LOGTCP_SEND    (0x01 << POS_KERN_COD_LOGTCP_SEND)	
+#define KERN_COD_LOGTCP_RECEIVE (0x01 << POS_KERN_COD_LOGTCP_RECEIVE)
+
+#define KERN_COD_HAT_SIZE	975	/* Maximum size of a subdomain
+					 * ident (hat) */
+#ifdef __KERNEL__
+typedef __u32 i_addr;
+#else
+typedef unsigned int i_addr;
+#endif
+
+/* Number of (unsigned) bytes in a digital signature - md5 is 16 bytes */
+/* XXX not really used, needed for comilation */
+#define IMMUNIX_DIGI_SIG_SIZE	16
+struct immunix_digital_sig {
+	unsigned char	md5[IMMUNIX_DIGI_SIG_SIZE];
+};
+
+typedef enum{
+	ePatternBasic,
+	ePatternTailGlob,
+	ePatternRegex,
+	ePatternInvalid,
+} pattern_t;
+
+struct cod_pattern {
+	char *regex;		// posix regex
+	pcre *compiled;		// compiled regex, size is compiled->size
+};
+
+struct flagval{
+	int debug;
+	int complain;
+	int audit;
+};
+
+struct cod_entry_user {
+	char * name ;
+	struct codomain_user * codomain ; 	/* Special codomain defined
+						 * just for this executable */
+	int mode ;	/* mode is 'or' of KERN_COD_* bits */
+	int deny ;	/* TRUE or FALSE */
+
+	pattern_t pattern_type;
+	struct cod_pattern pat;
+
+	struct immunix_digital_sig sig;
+	struct cod_entry_user * next;
+};
+
+struct cod_net_entry_user {
+	struct in_addr *saddr, *smask;
+	struct in_addr *daddr, *dmask;
+	unsigned short src_port[2], dst_port[2];
+	char * iface;
+	int mode;
+	struct codomain_user * codomain ;
+	struct cod_net_entry_user * next;
+};
+
+struct codomain_user {
+	char * name ;				/* codomain name */
+	char * sub_name ;			/* subdomain name or NULL */
+	int default_deny ;			/* TRUE or FALSE */
+
+	struct flagval flags;
+
+	unsigned int capabilities;
+
+	struct cod_entry_user * entries ;
+	struct cod_net_entry_user * net_entries;
+	struct codomain_user * subdomain ;
+	struct codomain_user * next ;
+} ;
+
+struct cod_global_entry_user {
+	struct cod_entry_user *entry;
+	struct cod_net_entry_user *net_entry;
+	struct codomain_user * hats ;
+	unsigned int capabilities;
+};
+
+/* Rev this every time the codomain_sysctl structure
+ * and it's substructures change 
+ */
+#define CODOMAIN_SYSCTL_VERSION	0x00000211	
+
+struct codomain_sysctl {
+	int			version;
+	int			action;		/* KERN_COD_[ADD|DEL|REPL] */
+	struct codomain_user	*codomain;
+} ;
+
+struct sd_hat {
+	char *hat_name;
+	unsigned int hat_magic;
+};
+
+
+#ifdef __KERNEL__
+
+/*======================================================================
+ *
+ *  Place holder for sysctl value
+ *
+ *======================================================================*/
+extern struct codomain_struct * codomain_sysctl_val ;
+
+
+/*======================================================================
+ *
+ *  codomain_paranoid - if TRUE, every process that starts must have a
+ *  			codomain defined. Can be set through sysctl
+ *  			KERN_COD_PARANOID and through
+ *  			/proc/kernel/codomain_paranoid.
+ *
+ *======================================================================*/
+extern int codomain_paranoid;
+
+#endif /* __KERNEL__ */
+
+#endif /* ! _IMMUNIX_H */
+
+/*======================================================================*/
diff -uNrp linux-2.6.11/security/subdomain/inline.h linux-2.6.11.subd-new/security/subdomain/inline.h
--- linux-2.6.11/security/subdomain/inline.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/inline.h	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,389 @@
+#ifndef __INLINE_H
+#define __INLINE_H
+
+#include <linux/version.h>
+#include <net/sock.h>
+#include <linux/list.h>
+#include <linux/namespace.h>
+
+#ifdef NETDOMAIN
+static inline int nd_is_valid(struct netdomain *nd)
+{
+int rc=0;
+
+	if (nd && nd->nd_magic == ND_ID_MAGIC){
+		rc=1;
+	}
+
+	return rc;
+}
+
+static inline int nd_is_confined(struct netdomain *nd)
+{
+	return nd_is_valid(nd) && 
+		nd->active && 
+		nd->active->num_net_entries;
+}
+
+static inline char* get_ifname(struct sock *sk, ifname_t name)
+{
+char *ifname = NULL;
+struct dst_entry *dst;
+
+	dst = sk_dst_get(sk);
+
+	if (dst){
+	       	if (dst->dev){
+			memcpy(name, dst->dev->name, sizeof(ifname_t));
+			ifname=name;
+			ND_DEBUG("%s: interface name = %s\n", 
+				__FUNCTION__,
+				ifname);
+
+		}
+
+		dst_release(dst);
+	}
+
+	return ifname;
+}
+
+static inline struct task_struct* get_waitingtask(struct sock *sk)
+{
+/* WARNING:
+ * a) We are in soft interrupt context when this is called
+ * b) read lock on tasklist spinlock should be held around this 
+ *    call and any manipulation of the returned task_struct
+ * c) Doing this has been described as a misuse of the data
+ *    structure.  It's also been called ugly.
+ */
+
+struct task_struct *tsk = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+wait_queue_head_t *wqh = sk->sk_sleep;
+#define WQ_LOCK spin_lock_irqsave
+#define WQ_UNLOCK spin_unlock_irqrestore
+#else
+wait_queue_head_t *wqh = sk->sleep;
+#define WQ_LOCK wq_read_lock_irqsave
+#define WQ_UNLOCK wq_read_unlock_irqrestore
+#endif
+unsigned long flags;
+
+	if (wqh){
+		WQ_LOCK(&wqh->lock, flags);
+
+		if (!list_empty(&wqh->task_list)){
+			/* any waiting task is fine
+		 	* which one would get data is upto scheduler
+		 	* so just pick the head/first
+		 	*/
+			wait_queue_t *wq; 
+
+			/* get via containing record */
+			wq=list_entry(wqh->task_list.next, 
+					wait_queue_t, task_list);
+
+			tsk=wq->task;
+		}
+	
+		WQ_UNLOCK(&wqh->lock, flags);
+	}
+
+	return tsk;
+#undef WA_LOCK
+#undef WA_UNLOCK
+}
+#endif // NETDOMAIN
+
+static inline int __sd_is_confined(struct subdomain *sd)
+{
+int rc=0;
+
+	if (sd && sd->sd_magic == SD_ID_MAGIC && sd->profile){
+		BUG_ON(!sd->active);
+		rc=1;
+	}
+
+	return rc;
+}
+
+static inline int __sd_is_ndconfined(struct subdomain *sd)
+{
+	return __sd_is_confined(sd) && 
+		sd->profile->num_net_entries;
+}
+
+/**
+ *  sd_is_confined - is process confined
+ *  @sd: subdomain
+ *
+ *  Check if @sd contains a valid profile.
+ *  Return 1 if confined, 0 otherwise.
+ */
+static inline int sd_is_confined(void)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(current->security);
+	return __sd_is_confined(sd);
+}
+
+/**
+ * sd_sub_defined - check if there is at least one subprofile defined
+ *
+ * Return 1 if there is at least one SubDomain subprofile defined,
+ * 0 otherwise.
+ *Used to obtain 
+ */
+static inline int __sd_sub_defined(struct subdomain *sd)
+{
+	 if (__sd_is_confined(sd) && !list_empty(&sd->profile->sub))
+		 return 1;
+
+	 return 0;
+}
+static inline int sd_sub_defined(void)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(current->security);
+	return __sd_sub_defined(sd);
+}
+
+static inline struct sdprofile * get_sdprofile(struct sdprofile *p)
+{
+	if (p)
+		atomic_inc(&p->count);
+	return p;
+}
+
+static inline void put_sdprofile(struct sdprofile *p)
+{
+	if (p) 
+		if (atomic_dec_and_test(&p->count))
+				free_sdprofile(p);
+}
+
+/* simple struct subdomain alloc/free wrappers */
+static inline struct subdomain * alloc_subdomain(struct task_struct *tsk)
+{
+	struct subdomain *sd = kmalloc(sizeof(struct subdomain), GFP_KERNEL);
+	/* zero it first */
+	if (sd) {
+		memset(sd, 0, sizeof(struct subdomain));
+		sd->sd_magic = SD_ID_MAGIC;
+	}
+
+	/* back pointer to task */
+	sd->task = tsk;
+
+	/* any readers of the list must make sure that they can handle 
+	 * case where sd->profile and sd->active are not yet set (null)
+	 */
+	sd_subdomainlist_add(sd);
+
+	return sd;
+}
+static inline void free_subdomain(struct subdomain *sd)
+{
+	sd_subdomainlist_remove(sd);
+	kfree(sd);
+}
+
+/**
+ * alloc_sdprofile - allocate new empty profile
+ *
+ * This routine allocates, initializes, and returns a new zeored
+ * profile structure. Returns NULL on failure.
+ */
+static inline struct sdprofile * alloc_sdprofile(void) 
+{
+	struct sdprofile *profile;
+
+	profile = (struct sdprofile *) kmalloc(sizeof(struct sdprofile),
+						     GFP_KERNEL);
+	SD_DEBUG("%s(%p)\n", __FUNCTION__, profile);
+	if (profile) {
+		memset(profile, 0, sizeof(struct sdprofile));
+		INIT_LIST_HEAD(&profile->list);
+		INIT_LIST_HEAD(&profile->sub);
+#if defined NETDOMAIN && defined NETDOMAIN_SKUSERS
+		INIT_LIST_HEAD(&profile->sk_users);
+#endif
+	}
+	return profile;
+}
+
+/**
+ * sd_put_name - release name (really just free_page)
+ * @name: name to release.
+ */
+static inline void sd_put_name(char *name)
+{
+	free_page((unsigned long)name);
+}
+
+static inline struct sdprofile * __sd_find_profile(const char *name, struct list_head *head)
+{
+	struct list_head *lh;
+
+	if (!name || !head)
+		return NULL;
+
+	SD_DEBUG("%s: finding profile %s\n", __FUNCTION__, name);
+	list_for_each(lh, head) {
+		struct sdprofile *p = list_entry(lh, struct sdprofile, list);
+		if (!strcmp(p->name, name)) {
+			/* return refcounted object */
+			p = get_sdprofile(p);
+			return p;
+		}else{
+			SD_DEBUG("%s: skipping %s\n", __FUNCTION__, p->name);
+		}
+	}
+	return NULL;
+}
+
+static inline struct subdomain * __get_sdcopy(struct subdomain *new,
+				 	      struct task_struct *tsk)
+{
+	struct subdomain *old, 
+			 *temp = NULL;
+
+       	old = SD_SUBDOMAIN(tsk->security);
+
+	if (old){
+		new->sd_magic = old->sd_magic;
+		new->sd_hat_magic = old->sd_hat_magic;
+
+		new->active = get_sdprofile(old->active);
+
+		if (old->profile == old->active){
+			new->profile = new->active;
+		}else{
+			new->profile = get_sdprofile(old->profile);
+		}
+
+		temp=new;
+	}
+
+	return temp;
+}
+
+static inline struct subdomain *get_sdcopy(struct subdomain *new)
+{
+	struct subdomain *temp;
+
+	SD_RLOCK;
+
+	temp=__get_sdcopy(new, current);
+
+	SD_RUNLOCK;
+
+	return temp;
+}
+
+static inline void put_sdcopy(struct subdomain *temp)
+{
+	if (temp){
+		put_sdprofile(temp->active);
+		if (temp->active != temp->profile){
+			(void)put_sdprofile(temp->profile);
+		}
+	}
+}
+
+/* sd_path_begin2
+ * Setup data for iterating over paths to dentry (sd_path_getname)
+ * @rdentry is used to obtain the filesystem root dentry
+ * @dentry is the actual dentry object we want to obtain pathnames to.
+ */
+static inline void sd_path_begin2(struct dentry *rdentry, struct dentry *dentry, struct sd_path_data *data)
+{
+	data->dentry = dentry;
+	data->root = dget(rdentry->d_sb->s_root);
+	data->namespace = current->namespace;
+	data->head = &data->namespace->list; 
+	data->pos = data->head->next; prefetch(data->pos->next);
+	data->errno = 0;
+
+	down_read(&data->namespace->sem);
+}
+
+/* sd_path_begin
+ * Setup data for iterating over paths to dentry (sd_path_getname)
+ * @dentry is used both for obtaining the filesystem root 
+ *  and also for the actual dentry object we want to obtain pathnames to.
+ */
+static inline void sd_path_begin(struct dentry *dentry, struct sd_path_data *data)
+{
+	sd_path_begin2(dentry, dentry, data);
+}
+
+/* sd_path_getname
+ * Return the next pathname that dentry (from sd_path_begin) may be reached
+ * through.  If no more paths exists or in the case of error, NULL is returned.
+ */
+static inline char *sd_path_getname(struct sd_path_data *data)
+{
+char *name = NULL;
+struct vfsmount *mnt;
+
+	while (data->pos != data->head){
+		mnt = list_entry(data->pos, struct vfsmount, mnt_list);
+
+		/* advance to next -- so that it is done before we break */
+		data->pos = data->pos->next; prefetch(data->pos->next);
+		
+		if (mnt->mnt_root == data->root){
+			name=__sd_get_name(data->dentry, mnt);
+			if (!name){
+				data->errno = -ENOMEM;
+			}
+			break;
+		}
+	}
+
+	return name;
+}
+
+/* sd_path_getmnt
+ * Return the next mountpoint which has the same root dentry as was passed
+ * to sd_path_begin2. If no more mount points exist, NULL is returned.
+ */
+static inline struct vfsmount *sd_path_getmnt(struct sd_path_data *data)
+{
+struct vfsmount *mnt = NULL;
+
+	while (data->pos != data->head){
+		mnt = list_entry(data->pos, struct vfsmount, mnt_list);
+
+		/* advance to next -- so that it is done before we break */
+		data->pos = data->pos->next; prefetch(data->pos->next);
+ 
+		if (mnt->mnt_root == data->root){
+			mntget(mnt);
+			break;
+		}
+	}
+
+	return mnt;
+} 
+
+/* sd_path_end
+ * end iterating over the namespace
+ * release all dentries and semaphores that were allocated by sd_path_begin
+ * If an error occured in a previous sd_path_getmnt it is returned.
+ * Otherwise 0 is returned
+ */
+static inline int sd_path_end(struct sd_path_data *data)
+{
+	up_read(&data->namespace->sem);
+	dput(data->root);
+
+	return data->errno;
+}
+
+static inline int isblank(unsigned char c)
+{
+	return c == ' ' || c == '\t';
+}
+
+#endif  /* __INLINE_H__ */
diff -uNrp linux-2.6.11/security/subdomain/list.c linux-2.6.11.subd-new/security/subdomain/list.c
--- linux-2.6.11/security/subdomain/list.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/list.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,349 @@
+/*
+ * Immunix SubDomain Profile List Management
+ *
+ *  Original 2.2 work
+ *  Copyright 1998, 1999, 2000, 2001 Wirex Communications &
+ *			Oregon Graduate Institute
+ * 
+ * 	Written by Steve Beattie <steve@wirex.net>
+ *
+ *  Updated 2.4/5 work
+ *  Copyright (C) 2002 WireX Communications, Inc.
+ *
+ *  Ported from 2.2 by Chris Wright <chris@wirex.com>
+ *
+ *  Ported to 2.6 by Tony Jones <tony@immunix.com>
+ *  Copyright (C) 2003-2004 Immunix, Inc
+ */
+
+#include <linux/config.h>
+#ifdef SDLISTLOCK_SEM
+#include <linux/rwsem.h>
+#else
+#include <linux/spinlock.h>
+#endif
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/seq_file.h>
+#include "subdomain.h"
+#include "inline.h"
+
+/* list of all profiles */
+static LIST_HEAD(profile_list);
+// profile list spin lock
+static rwlock_t profile_lock = RW_LOCK_UNLOCKED; 
+#define LIST_RLOCK	read_lock(&profile_lock)
+#define LIST_RUNLOCK	read_unlock(&profile_lock)
+#define LIST_WLOCK	write_lock(&profile_lock)
+#define LIST_WUNLOCK	write_unlock(&profile_lock)
+
+/* list of all subdomains */
+static LIST_HEAD(subdomain_list);
+// subdomain list spin lock
+static rwlock_t subdomain_lock = RW_LOCK_UNLOCKED; 
+#define SDLIST_RLOCK	read_lock(&subdomain_lock)
+#define SDLIST_RUNLOCK	read_unlock(&subdomain_lock)
+#define SDLIST_WLOCK	write_lock(&subdomain_lock)
+#define SDLIST_WUNLOCK	write_unlock(&subdomain_lock)
+
+/**
+ * sd_profilelist_find - search for subdomain profile by name
+ * @name: profile name (program name)
+ *
+ * Search the profile list for profile @name.  Return refcounted profile on
+ * success, NULL on failure.
+ */
+struct sdprofile * sd_profilelist_find(const char *name)
+{
+	struct sdprofile *p = NULL;
+	if (name) {
+		LIST_RLOCK;
+		p = __sd_find_profile(name, &profile_list);
+		LIST_RUNLOCK;
+	}
+	return p;
+}
+
+/**
+ * sd_profilelist_add - add new profile to profile_list
+ * @profile: new profile to add to list
+ *
+ * Add new profile to list.  Reference count on profile is
+ * incremented.
+ */
+void sd_profilelist_add(struct sdprofile *profile)
+{
+	if (!profile) {
+		SD_INFO("%s: bad profile\n", __FUNCTION__);
+		return;
+	}
+
+	profile = get_sdprofile(profile);
+	LIST_WLOCK;
+	list_add(&profile->list, &profile_list);
+	LIST_WUNLOCK;
+}
+
+/**
+ * sd_profilelist_remove - remove profile from profile_list
+ * @name: name of profile to be removed
+ *
+ * Remove profile from list.  Reference count on profile is
+ * decremented.
+ */
+int sd_profilelist_remove(const char *name)
+{
+	struct sdprofile *profile = NULL;
+	struct list_head *lh, *tmp;
+	int error = -ENOENT;
+
+	if (!name)
+		goto out;
+
+	LIST_WLOCK;
+	list_for_each_safe(lh, tmp, &profile_list) {
+		struct sdprofile *p = list_entry(lh, struct sdprofile, list);
+		if (!strcmp(p->name, name)) {
+			list_del_init(&p->list);
+			profile = p;
+			break;
+		}
+	}
+	LIST_WUNLOCK;
+	if (!profile)
+		goto out;
+
+	put_sdprofile(profile);
+	error = 0;
+out:
+	return error;
+}
+
+/**
+ * sd_profilelist_replace - replace profile by name
+ * @profile - new profile
+ *
+ * Replace a profile on the profile list.  Find the old profile by name in
+ * the list, and replace it with the new profile.  This is an atomic
+ * list operation.  Returns the old profile (which is still refcounted) if
+ * there was one, or NULL.
+ */
+struct sdprofile *sd_profilelist_replace(struct sdprofile *profile)
+{
+	struct sdprofile *oldprofile;
+
+	LIST_WLOCK;
+	oldprofile = __sd_find_profile(profile->name, &profile_list);
+	if (oldprofile) {
+		list_del_init(&oldprofile->list);
+
+		/* __sd_find_profile incremented count, so adjust down */
+		put_sdprofile(oldprofile);
+	}
+	profile = get_sdprofile(profile);
+	list_add(&profile->list, &profile_list);
+	LIST_WUNLOCK;
+
+	return oldprofile;
+}
+
+/**
+ * sd_profilelist_release - remove all profiles from profile_list
+ */
+void sd_profilelist_release(void) 
+{
+	struct list_head *lh, *tmp;
+
+	LIST_WLOCK;
+	list_for_each_safe(lh, tmp, &profile_list) {
+		struct sdprofile *profile=list_entry(lh,struct sdprofile,list);
+		list_del_init(&profile->list);	
+		put_sdprofile(profile);
+	}
+	LIST_WUNLOCK;
+}
+
+/**
+ * sd_profile_dump - dump a profile
+ * @profile: profile to dump
+ */
+static inline void sd_profile_dump_lvl(struct sdprofile *profile, int sub)
+{
+	struct sd_entry *sdent;
+
+	SD_DEBUG("dumping profile: %s%s(%d) %s\n", 
+		sub ? "^" : "", 
+		profile->name,
+		atomic_read(&profile->count),
+		profile->sub_name ?
+		profile->sub_name : "");
+	for (sdent = profile->file_entry; sdent; sdent = sdent->next) {
+		SD_DEBUG("\t%d\t%s\n", sdent->mode, sdent->filename);
+	}
+}
+
+void sd_profile_dump(struct sdprofile *profile)
+{
+	struct list_head *slh;
+
+	sd_profile_dump_lvl(profile, 0);
+
+	list_for_each(slh, &profile->sub) {
+		struct sdprofile *sub;
+		sub = list_entry(slh, struct sdprofile, list);
+		sd_profile_dump_lvl(sub, 1);
+	}
+}
+
+/**
+ * sd_profilelist_dump - dump profile list for debugging
+ */
+void sd_profilelist_dump(void)
+{
+	struct list_head *lh;
+
+	SD_DEBUG("%s\n", __FUNCTION__);
+	LIST_RLOCK;
+	list_for_each(lh, &profile_list) {
+		struct sdprofile *profile=list_entry(lh,struct sdprofile,list);
+		sd_profile_dump(profile);
+	}
+	LIST_RUNLOCK;
+}
+
+/**
+ * sd_subdomainlist_add - add new subdomain to subdomain_list
+ * @sd: new subdomain to add to list
+ */
+void sd_subdomainlist_add(struct subdomain *sd)
+{
+	if (!sd) {
+		SD_INFO("%s: bad subdomain\n", __FUNCTION__);
+		return;
+	}
+
+	SDLIST_WLOCK;
+	list_add(&sd->list, &subdomain_list);
+	SDLIST_WUNLOCK;
+}
+
+/**
+ * sd_subdomainlist_remove - remove subdomain from subdomain_list
+ * @sd: subdomain to be removed
+ */
+int sd_subdomainlist_remove(struct subdomain *sd)
+{
+	struct list_head *lh, *tmp;
+	int error = -ENOENT;
+
+	if (!sd)
+		goto out;
+
+	SDLIST_WLOCK;
+	list_for_each_safe(lh, tmp, &subdomain_list) {
+		struct subdomain *node = list_entry(lh, struct subdomain, list);
+		if (node == sd){
+			list_del_init(&node->list);
+			error = 0;
+			break;
+		}
+	}
+	SDLIST_WUNLOCK;
+
+out:
+	return error;
+}
+
+/**
+ * sd_subdomainlist_iterate - Iterate over subdomain_list.
+ * stop when sd_iter func returns non zero
+ * @func: method to be called for each element
+ */
+void sd_subdomainlist_iterate(sd_iter func, void *cookie)
+{
+	struct list_head *lh;
+	int ret=0;
+
+	SDLIST_RLOCK;
+	list_for_each(lh, &subdomain_list) {
+		struct subdomain *node = list_entry(lh, struct subdomain, list);
+		ret=(*func)(node, cookie);
+		if (ret != 0){
+			break;
+		}
+	}
+	SDLIST_RUNLOCK;
+}
+
+/**
+ * sd_subdomainlist_iterateremove - Iterate over subdomain_list.
+ * remove element when sd_iter func returns non zero
+ * @func: method to be called for each element
+ */
+void sd_subdomainlist_iterateremove(sd_iter func, void *cookie)
+{
+	struct list_head *lh, *tmp;
+	int ret=0;
+
+	SDLIST_WLOCK;
+	list_for_each_safe(lh, tmp, &subdomain_list) {
+		struct subdomain *node = list_entry(lh, struct subdomain, list);
+		ret=(*func)(node, cookie);
+		if (ret != 0){
+			list_del_init(lh);
+		}
+	}
+	SDLIST_WUNLOCK;
+}
+
+/**
+ * sd_profilelist_release - remove all subdomains from subdomain_list
+ */
+void sd_subdomainlist_release()
+{
+	struct list_head *lh, *tmp;
+
+	SDLIST_WLOCK;
+	list_for_each_safe(lh, tmp, &subdomain_list) {
+		list_del_init(lh);
+	}
+	SDLIST_WUNLOCK;
+}
+
+static void * p_start(struct seq_file *f, loff_t *pos)
+{
+	struct list_head *lh;
+	loff_t l = *pos;
+
+	LIST_RLOCK;
+	list_for_each(lh, &profile_list)
+		if (!l--)
+			return list_entry(lh, struct sdprofile, list);
+	return NULL;
+}
+
+static void * p_next(struct seq_file *f, void *p, loff_t *pos)
+{
+	struct list_head *lh = ((struct sdprofile *)p)->list.next;
+	(*pos)++;
+	return lh==&profile_list ? NULL : list_entry(lh, struct sdprofile, list);
+}
+
+static void p_stop(struct seq_file *f, void *v)
+{
+	LIST_RUNLOCK;
+}
+
+static int seq_show_profile(struct seq_file *f, void *v)
+{
+	struct sdprofile *profile = (struct sdprofile *)v;
+	seq_printf(f, "%s (%s)\n", profile->name, PROFILE_COMPLAIN(profile) ? "complain" : "enforce");
+	return 0;
+}
+
+struct seq_operations subdomainfs_profiles_op = {
+	.start =	p_start,
+	.next =		p_next,
+	.stop =		p_stop,
+	.show =		seq_show_profile,
+};
diff -uNrp linux-2.6.11/security/subdomain/lsm.c linux-2.6.11.subd-new/security/subdomain/lsm.c
--- linux-2.6.11/security/subdomain/lsm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/lsm.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,1270 @@
+/*
+ * Immunix SubDomain LSM interface 
+ * 
+ * Copyright (C) 2002 WireX Communications, Inc
+ *
+ * Chris Wright <chris@wirex.com>
+ * 
+ * Copyright (C) 2003-2004 Immunix, Inc
+ * 
+ * Tony Jones <tony@immunix.com>
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/security.h>
+#include <linux/skbuff.h>
+#include <linux/netlink.h>
+#include <linux/netdevice.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+
+/* Needed for pipefs superblock PIPEFS_MAGIC */
+#include <linux/pipe_fs_i.h>
+
+/* Ugh, cut-n-paste from net/socket.c */
+#define SOCKFS_MAGIC 0x534F434B
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/namei.h>
+#include <linux/statfs.h>
+#endif
+
+#include <asm/mman.h>
+
+#include "subdomain.h"
+#include "inline.h"
+
+#ifdef NETDOMAIN
+#include "netdomain.c"
+#endif
+
+// main SD lock, manipulated by SD_[RW]LOCK and SD_[RW]UNLOCK (see subdomain.h)
+rwlock_t sd_lock = RW_LOCK_UNLOCKED;
+
+/* Flag values, also controllable via subdomainfs/control */
+
+/* Complain mode (used to be 'bitch' mode) */
+int subdomain_complain=0;
+/* Debug mode */
+int subdomain_debug=0;
+/* Audit mode */
+int subdomain_audit=0;
+/* OWLSM mode */
+int subdomain_owlsm=1;
+
+#ifdef NETDOMAIN
+int netdomain_enabled=1;
+#else
+int netdomain_enabled=0;
+#endif
+
+#ifdef MODULE
+MODULE_PARM(subdomain_complain, "i");
+MODULE_PARM_DESC(subdomain_complain, "Toggle SubDomain Complain Mode");
+MODULE_PARM(subdomain_debug, "i");
+MODULE_PARM_DESC(subdomain_debug, "Toggle SubDomain Debug Mode");
+MODULE_PARM(subdomain_audit, "i");
+MODULE_PARM_DESC(subdomain_audit, "Toggle SubDomain Audit Mode");
+MODULE_PARM(subdomain_owlsm, "i");
+MODULE_PARM_DESC(subdomain_owlsm, "Toggle SubDomain OWLSM Mode");
+#else
+static int __init sd_complainmode(char *str)
+{
+	get_option(&str, &subdomain_complain);
+	return 1;
+}
+__setup("subdomain_complain=", sd_complainmode);
+static int __init sd_debugmode(char *str)
+{
+	get_option(&str, &subdomain_debug);
+	return 1;
+}
+__setup("subdomain_debug=", sd_debugmode);
+static int __init sd_auditmode(char *str)
+{
+	get_option(&str, &subdomain_audit);
+	return 1;
+}
+__setup("subdomain_owlsm=", sd_owlsmmode);
+static int __init sd_owlsmmode(char *str)
+{
+	get_option(&str, &subdomain_owlsm);
+	return 1;
+}
+#endif
+
+static int subdomain_ptrace (struct task_struct *parent, struct task_struct *child)
+{
+	/* XXX This only protects TRACEME and ATTACH.  We used to guard
+	 * all of sys_ptrace(2)...
+	 */
+	int error;
+	struct subdomain *sd;
+
+	error = cap_ptrace(parent, child);
+
+	SD_RLOCK;
+
+       	sd = SD_SUBDOMAIN(current->security);
+
+	if (!error && __sd_is_confined(sd)){
+		SD_WARN("REJECTING access to syscall 'ptrace' (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+		error = -EPERM;
+	}
+
+	SD_RUNLOCK; 
+
+	return error;
+}
+
+static int subdomain_capget (struct task_struct *target, kernel_cap_t * effective,
+			 kernel_cap_t * inheritable, kernel_cap_t * permitted)
+{
+	return cap_capget(target, effective, inheritable, permitted);
+}
+
+static int subdomain_capset_check (struct task_struct *target,
+			       kernel_cap_t * effective,
+			       kernel_cap_t * inheritable,
+			       kernel_cap_t * permitted)
+{
+	return cap_capset_check(target, effective, inheritable, permitted);
+}
+
+static void subdomain_capset_set (struct task_struct *target,
+			      kernel_cap_t * effective,
+			      kernel_cap_t * inheritable,
+			      kernel_cap_t * permitted)
+{
+	cap_capset_set(target, effective, inheritable, permitted);
+	return;
+}
+
+static int subdomain_capable (struct task_struct *tsk, int cap)
+{
+	int error;
+
+	/* cap_capable returns 0 on success, else -EPERM */
+	error = cap_capable(tsk, cap);
+
+	if (error == 0){
+		struct subdomain *sd, sdcopy;
+		
+		SD_RLOCK;
+       		sd = __get_sdcopy(&sdcopy, tsk);
+		SD_RUNLOCK;
+
+		error = sd_capability(cap, sd);
+
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_sysctl (ctl_table * table, int op)
+{
+	int error = 0;
+	struct subdomain *sd;
+
+	SD_RLOCK;
+
+       	sd = SD_SUBDOMAIN(current->security);
+
+	if ((op & 002) && __sd_is_confined(sd) && !capable(CAP_SYS_ADMIN)){
+		SD_WARN("REJECTING access to syscall 'sysctl (write)' (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+		error = -EPERM;
+	}
+
+	SD_RUNLOCK; 
+
+	return error;
+}
+
+static int subdomain_syslog (int type)
+{
+	return cap_syslog(type);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
+static int subdomain_netlink_send (struct sock *sk, struct sk_buff *skb)
+{
+	return cap_netlink_send(sk, skb);
+}
+#else
+static int subdomain_netlink_send (struct sk_buff *skb)
+{
+	return cap_netlink_send(skb);
+}
+#endif
+
+static int subdomain_netlink_recv (struct sk_buff *skb)
+{
+	return cap_netlink_recv(skb);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,6)
+static void subdomain_bprm_apply_creds (struct linux_binprm *bprm, int unsafe)
+{
+	cap_bprm_apply_creds(bprm, unsafe);
+	return;
+}
+#else
+static void subdomain_bprm_compute_creds (struct linux_binprm *bprm)
+{
+	cap_bprm_compute_creds(bprm);
+	return;
+}
+#endif
+
+static int subdomain_bprm_set_security (struct linux_binprm *bprm)
+{
+	/* handle capability bits with setuid, etc */
+	cap_bprm_set_security(bprm);
+	/* already set based on script name */
+	if (bprm->sh_bang)
+		return 0;
+	return sd_register(bprm->file);
+}
+
+static int subdomain_sb_mount (char *dev_name, struct nameidata *nd, char *type,
+			unsigned long flags, void *data)
+{
+	int error = 0;
+	struct subdomain *sd;
+
+	SD_RLOCK;
+
+       	sd = SD_SUBDOMAIN(current->security);
+
+	if (__sd_is_confined(sd)){
+		SD_WARN("REJECTING access to syscall 'mount' (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+		error = -EPERM;
+	}
+
+	SD_RUNLOCK; 
+
+	return error;
+}
+
+static int subdomain_umount (struct vfsmount *mnt, int flags)
+{
+	int error = 0;
+	struct subdomain *sd;
+
+	SD_RLOCK;
+
+       	sd = SD_SUBDOMAIN(current->security);
+
+	if (__sd_is_confined(sd)){
+		SD_WARN("REJECTING access to syscall 'umount' (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+		error = -EPERM;
+	}
+
+	SD_RUNLOCK; 
+
+	return error;
+}
+
+static int subdomain_inode_create (struct inode *inode, struct dentry *dentry,
+			       int mask)
+{
+	struct subdomain sdcopy,
+			 *sd;
+	int error;
+
+	sd = get_sdcopy(&sdcopy);
+
+	error=sd_perm_dentry(dentry, sd, MAY_WRITE);
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+/*
+ * Don't allow users to create hard links to files they don't own,
+ * unless they have CAP_FOWNER. 
+ *      
+ * The last two checks are here as a workaround for atd(8), to be
+ * removed one day. 
+ */
+static inline int do_owlsm_link(struct dentry *old_dentry, struct inode *inode,
+                                struct dentry *new_dentry)
+{   
+	struct inode* i = old_dentry->d_inode;
+
+	if (current->fsuid != i->i_uid && !capable(CAP_FOWNER) &&
+	    current->uid != i->i_uid && current->uid) {
+		struct sd_path_data data;
+		char *name;
+
+		sd_path_begin(old_dentry, &data);
+
+		name = sd_path_getname(&data);
+		if (name){
+			SD_WARN("REJECTING hard link to %s inode# %lu (owner %d.%d) by uid %d euid %d (%s(%d)) [owlsm]\n",
+				name,
+				old_dentry->d_inode->i_ino,
+				i->i_uid, i->i_gid,
+				current->uid, current->euid,
+				current->comm, current->pid);
+
+			sd_put_name(name);
+			
+			do {
+				name = sd_path_getname(&data);
+				if (name){
+					SD_WARN("Inode# %lu is also reachable via path %s [owlsm]\n",
+						old_dentry->d_inode->i_ino,
+						name);
+
+					sd_put_name(name);
+				}
+			}while (name);
+		}
+
+		if (sd_path_end(&data) != 0){
+			SD_ERROR("%s: An error occured while translating dentry %p inode# %lu to a pathname. Error %d\n",
+				__FUNCTION__,
+				old_dentry,
+				old_dentry->d_inode->i_ino,
+				data.errno);
+		}
+
+		return -EPERM;
+	}
+	return 0;
+
+}
+
+static int subdomain_inode_link (struct dentry *old_dentry, struct inode *inode,
+			     struct dentry *new_dentry)
+{
+	int error = 0;
+
+	if (subdomain_owlsm){
+		error = do_owlsm_link(old_dentry, inode, new_dentry);
+	}
+
+	if (error == 0){
+		struct subdomain sdcopy,
+		       *sd;
+
+		sd = get_sdcopy(&sdcopy);
+		error = sd_link(new_dentry, old_dentry, sd);
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_inode_unlink (struct inode *inode, struct dentry *dentry)
+{
+	struct subdomain sdcopy,
+			 *sd;
+	int error;
+
+	sd = get_sdcopy(&sdcopy);
+
+	error = sd_perm_dentry(dentry, sd, MAY_WRITE|KERN_COD_MAY_LINK);
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_symlink (struct inode *inode, struct dentry *dentry,
+				    const char *name)
+{
+	struct subdomain sdcopy,
+			 *sd;
+	int error = 0;
+
+	sd = get_sdcopy(&sdcopy);
+
+	error=sd_symlink(dentry, name, sd);
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_mknod (struct inode *inode, struct dentry *dentry,
+			      int mode, dev_t dev)
+{
+	struct subdomain sdcopy,
+			 *sd;
+	int error = 0;
+
+	sd = get_sdcopy(&sdcopy);
+
+	if (__sd_is_confined(sd) && (S_ISCHR(mode) || S_ISBLK(mode))){
+		SD_WARN("REJECTING access to syscall 'mknod' type:%c (%s(%d) profile %s active %s)\n",
+			S_ISCHR(mode) ? 'c' : 'b',
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+		error = -EPERM;
+	}else if (S_ISFIFO(mode) || S_ISSOCK(mode)){
+		error = sd_perm_dentry(dentry, sd, MAY_WRITE);
+	}
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_inode_rename (struct inode *old_inode,
+			       struct dentry *old_dentry,
+			       struct inode *new_inode,
+			       struct dentry *new_dentry)
+{
+	struct subdomain sdcopy,
+			 *sd;
+	int error = 0;
+
+	sd = get_sdcopy(&sdcopy);
+
+	error = sd_perm_dentry(old_dentry, sd, 
+			MAY_READ|MAY_WRITE|KERN_COD_MAY_LINK);
+
+	if (!error){
+		error = sd_perm_dentry(new_dentry, sd, MAY_WRITE);
+	}
+	
+	put_sdcopy(sd);
+
+	return error;
+}
+
+/*
+ * Don't follow links that we don't own in +t
+ * directories, unless the link is owned by the
+ * owner of the directory.
+ */
+static inline int do_owlsm_follow_link(struct dentry *dentry,
+				   struct nameidata *nameidata)
+{
+	struct inode *inode = dentry->d_inode;
+	struct inode *parent = dentry->d_parent->d_inode;
+	if (S_ISLNK(inode->i_mode) &&
+		(parent->i_mode & S_ISVTX) &&
+		inode->i_uid != parent->i_uid &&
+		current->fsuid != inode->i_uid) {
+			char *name=NULL;
+
+			if (nameidata){
+				name=__sd_get_name(dentry, nameidata->mnt);
+			}
+					
+			SD_WARN("REJECTING follow of symlink %s (owner %d.%d) by uid %d euid %d (%s(%d)) [owlsm]\n",
+				name ? name : "",
+				inode->i_uid, inode->i_gid,
+				current->uid, current->euid,
+				current->comm, current->pid);
+
+			if (name){
+				sd_put_name(name);
+			}
+				
+			return -EPERM;
+	}
+	return 0;
+}
+
+static int subdomain_inode_follow_link (struct dentry *dentry, 
+					struct nameidata *nameidata)
+{       
+	int error = 0;
+
+	if (subdomain_owlsm){
+		error = do_owlsm_follow_link(dentry, nameidata);
+	}
+		
+	return error;
+}
+
+static int subdomain_inode_permission (struct inode *inode, int mask,
+					struct nameidata *nd)
+{
+	int error = 0;
+
+	/* Do not perform check on pipes or sockets
+	 * Same as subdomain_file_permission
+	 */
+	if (inode->i_sb->s_magic != PIPEFS_MAGIC &&
+            inode->i_sb->s_magic != SOCKFS_MAGIC) {
+		struct subdomain sdcopy, 
+			 	 *sd;
+
+		sd = get_sdcopy(&sdcopy);
+		error = sd_perm(inode, sd, nd, mask);
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_inode_setattr (struct dentry *dentry, struct iattr *iattr)
+{
+struct subdomain sdcopy,
+		 *sd;
+int error = 0;
+
+	if (dentry->d_inode->i_sb->s_magic != PIPEFS_MAGIC &&
+	    dentry->d_inode->i_sb->s_magic != SOCKFS_MAGIC) {
+
+		sd = get_sdcopy(&sdcopy);
+
+		/* 
+	 	 * Mediate any attempt to change attributes of a file 
+		 * (chmod, chown, chgrp, etc)
+	 	 */
+		error = sd_attr(dentry, sd, iattr);
+
+		put_sdcopy(sd);
+	}
+
+	return error;
+}
+
+static int subdomain_file_permission (struct file *file, int mask)
+{
+	struct subdomain sdcopy, *sd;
+	struct sdprofile *f_profile;
+	int error = 0;
+
+#if defined (PRINTK_TEMPFIX) && ( defined (CONFIG_SMP) || defined (CONFIG_PREEMPT))
+	/* ugly hack.  This is slightly racey, but lets us not have
+	 * grab a spin lock just to test if there is data.  The
+         * worst thing that can happen is we call dump_sdprintk,
+	 * and doesn't have any data to print, which is ok
+	 */
+	if (unlikely(sd_log_buf_has_data))
+		dump_sdprintk();
+#endif
+
+	sd = get_sdcopy(&sdcopy);
+
+	f_profile = SD_PROFILE(file->f_security);
+
+	if (__sd_is_confined(sd) && f_profile && f_profile != sd->active) {
+		char *name;
+		if (file->f_dentry->d_inode->i_sb->s_magic != PIPEFS_MAGIC &&
+		    file->f_dentry->d_inode->i_sb->s_magic != SOCKFS_MAGIC) {
+			name = __sd_get_name(file->f_dentry, file->f_vfsmnt);
+			error = -ENOMEM;
+			if (name) {
+				/* subdomain overloads permission bits for
+				 * internal use, we don't want to expose those
+				 * to possible external access,
+			  	 * We allow only exec, write or read 
+			 	 */
+				error = sd_file_perm(name , sd, 
+					mask & (MAY_EXEC|MAY_WRITE|MAY_READ), 
+					TRUE);
+				sd_put_name(name);
+			}
+		} else
+			error = 0;
+	}
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_file_alloc_security (struct file *file)
+{
+struct subdomain sdcopy,
+		 *sd;
+
+	sd = get_sdcopy(&sdcopy);
+
+	if (__sd_is_confined(sd)){
+		file->f_security = get_sdprofile(sd->active);
+	}
+
+	put_sdcopy(sd);
+
+	return 0;
+}
+
+static void subdomain_file_free_security (struct file *file)
+{
+	struct sdprofile *p = SD_PROFILE(file->f_security);
+	put_sdprofile(p);
+}
+
+static int subdomain_file_mmap (struct file *file, unsigned long prot,
+			    unsigned long flags)
+{
+int error = 0, 
+    mask = 0;
+
+struct subdomain sdcopy,
+		 *sd;
+
+struct sdprofile *f_profile;
+
+	sd = get_sdcopy(&sdcopy);
+
+	f_profile = file ? SD_PROFILE(file->f_security) : NULL;
+
+	if (prot & PROT_READ)
+		mask |= MAY_READ;
+	if (prot & PROT_WRITE)
+		mask |= MAY_WRITE;
+	if (prot & PROT_EXEC)
+		mask |= MAY_EXEC;
+
+	SD_DEBUG("%s: 0x%x\n" , __FUNCTION__, mask);
+
+	/* Don't check if no subdomain's, profiles haven't changed, or
+	 * mapping in the executable
+	 */
+	if (file && __sd_sub_defined(sd) && 
+    	    f_profile != sd->active &&
+	    !(flags & MAP_EXECUTABLE)) {
+		char *name = __sd_get_name(file->f_dentry, file->f_vfsmnt);
+		SD_DEBUG("%s: name %s 0x%lx, 0x%lx\n", 
+			__FUNCTION__,
+			name ? name : "NULL", 
+			prot, flags);
+		error = -ENOMEM;
+		if (name) {
+			error = sd_file_perm(name, sd, 
+				mask,
+				TRUE);
+
+			sd_put_name(name);
+		}
+	}
+
+	put_sdcopy(sd);
+
+	return error;
+}
+
+static int subdomain_task_alloc_security (struct task_struct *p)
+{
+	return sd_fork(p);
+}
+
+static void subdomain_task_free_security (struct task_struct *p)
+{
+	sd_release(p);
+}
+
+static int subdomain_task_post_setuid (uid_t id0, uid_t id1, uid_t id2, int flags)
+{
+	return cap_task_post_setuid(id0, id1, id2, flags);
+}
+
+static void subdomain_task_reparent_to_init (struct task_struct *p)
+{
+	cap_task_reparent_to_init(p);
+	/* shouldn't be necessary anymore */
+	// p->euid = p->fsuid = 0;
+	return;
+}
+
+#ifdef SUBDOMAIN_PROCATTR
+static int subdomain_getprocattr(struct task_struct *p, char *name, void *value, size_t size)
+{
+	int error = -EACCES; /* default to a perm denied */
+	struct subdomain sdcopy,
+			 *sd;
+	char *str=value;
+	int len;
+
+	if (strcmp(name, "current") != 0){
+		/* 
+	 	 * Subdomain only supports the "current" process attribute
+		 */
+		error = -EINVAL;
+		goto out;
+	}
+
+	if (!size){
+		error = -ERANGE;
+		goto out;
+	}
+
+	/* must be task querying itself or admin */
+	if (current != p && !capable(CAP_SYS_ADMIN)){
+		error = -EPERM;
+		goto out;
+	}
+
+	SD_RLOCK;
+
+       	sd = __get_sdcopy(&sdcopy, p);
+
+	SD_RUNLOCK;
+
+	if (__sd_is_confined(sd)){
+		int lena, lenm, lenp=0;
+		const char *enforce_str = " (enforce)";
+		const char *complain_str = " (complain)";
+		const char *mode_str = SUBDOMAIN_COMPLAIN(sd) ? complain_str : enforce_str;
+
+		lenm=strlen(mode_str);
+
+		lena = strlen(sd->active->name);
+
+		len = lena;
+		if (sd->active != sd->profile){
+			lenp = strlen(sd->profile->name);
+			len += (lenp + 1);	/* +1 for ^ */
+		}
+		len+= (lenm + 2); /* for \n\0 */
+
+		if (len <= size){
+			if (lenp){
+				memcpy(str, sd->profile->name, lenp);
+				str+=lenp;
+				*str++='^';
+			}
+
+			memcpy(str, sd->active->name, lena);
+			str+=lena;
+			memcpy(str, mode_str, lenm);
+			str+=lenm;
+			*str++='\n';
+			*str++=0;
+			error = len;
+		}else{
+			error = -ERANGE;
+		}
+	}else{
+		const char *unconstrained_str = SD_UNCONSTRAINED "\n";
+		int lenu = strlen(unconstrained_str);
+
+		len=lenu + 1;
+
+		if (len <= size){
+			memcpy(str, unconstrained_str, lenu);
+			str[lenu] = 0;
+			error = len;
+		}else{
+			error = -ERANGE;
+		}
+	}
+			
+	put_sdcopy(sd);
+
+out:
+	return error;
+}
+
+static int subdomain_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
+{
+const char *cmd_changehat = "changehat ",
+	   *cmd_setprofile = "setprofile ";
+
+	int error = -EACCES; /* default to a perm denied */
+	char *cmd = (char *)value;
+	
+	/* only support messages to current */
+	if (strcmp(name, "current") != 0){
+		error = -EINVAL;
+		goto out;
+	}
+
+	if (!size){
+		error = -ERANGE;
+		goto out;
+	}
+
+	/* CHANGE HAT */
+	if (size > strlen(cmd_changehat) &&
+	    strncmp(cmd, cmd_changehat, strlen(cmd_changehat)) == 0){
+		char *hatinfo = cmd + strlen(cmd_changehat);
+		int infosize = size - strlen(cmd_changehat);
+
+		/* Only the current process may change it's hat */
+		if (current != p){
+			SD_WARN("%s: Attempt by foreign task %s(%d) [user %d] to changehat of task %s(%d)\n",
+				__FUNCTION__,
+				current->comm,
+				current->pid,
+				current->uid,
+				p->comm,
+				p->pid);
+
+			error = -EACCES;
+			goto out;
+		}
+
+		error = sd_setprocattr_changehat(hatinfo, infosize);
+		if (error == 0){
+			/* success, 
+			 * set return to #bytes in orig request
+			 */
+			error = size;
+		}else{
+			error = -EACCES;
+		}
+
+	/* SET NEW PROFILE */
+	}else if (size > strlen(cmd_setprofile) &&
+		  strncmp(cmd, cmd_setprofile, strlen(cmd_setprofile)) == 0){
+		int confined;
+
+		/* only an unconfined process with admin capabilities
+		 * may change the profile of another task
+		 */
+
+		if (!capable(CAP_SYS_ADMIN)){
+			SD_WARN("%s: Unpriviliged attempt by task %s(%d) [user %d] to assign new profile to task %s(%d)\n",
+				__FUNCTION__,
+				current->comm,
+				current->pid,
+				current->uid,
+				p->comm,
+				p->pid);
+			error = -EACCES;
+			goto out;
+		}
+		
+		SD_RLOCK;
+		confined = sd_is_confined();
+		SD_RUNLOCK;
+
+		if (!confined){
+			char *profile = cmd + strlen(cmd_setprofile);
+			int profilesize = size - strlen(cmd_setprofile);
+
+			error = sd_setprocattr_setprofile(p, profile, profilesize);
+			if (error == 0){
+				/* success, 
+			 	 * set return to #bytes in orig request
+			 	 */
+				error = size;
+			}
+		}else{
+			SD_WARN("%s: Attempt by confined task %s(%d) [user %d] to assign new profile to task %s(%d)\n",
+				__FUNCTION__,
+				current->comm,
+				current->pid,
+				current->uid,
+				p->comm,
+				p->pid);
+
+			error = -EACCES;
+		}
+	}else{
+		/* unknown operation */
+		SD_WARN("%s: Unknown setprocattr command by task %s(%d) [user %d] for task %s(%d)\n",
+			__FUNCTION__,
+			current->comm,
+			current->pid,
+			current->uid,
+			p->comm,
+			p->pid);
+
+		error = -EINVAL;
+	}
+
+out:
+	return error;
+}
+#endif // SUBDOMAIN_PROCATTR
+
+#ifdef NETDOMAIN
+static int subdomain_sk_alloc_security(struct sock *sk, int family, int priority)
+{
+	return nd_alloc(sk, family, priority);
+}
+
+static void subdomain_sk_free_security(struct sock * sk)
+{
+	nd_free(sk);
+}
+
+static int subdomain_socket_create(int family, int type, int protocol)
+{
+	int error = 0;
+	struct subdomain *sd;
+                                                                                
+        ND_DEBUG("%s: %d %d %d\n" ,
+                __FUNCTION__,
+                family, type, protocol);
+                                                                                
+        SD_RLOCK;
+                                                                                
+        sd = SD_SUBDOMAIN(current->security);
+                                                                                
+        /* restrict raw sockets if profile is netdomain confined */
+        if (type == SOCK_RAW && __sd_is_ndconfined(sd) && !capable(CAP_NET_RAW)){
+                SD_WARN("REJECTING access to raw socket (%s(%d) profile %s active %s)\n",
+                        current->comm, current->pid,
+                        sd->profile->name, sd->active->name);
+                error = -EPERM;
+        }
+                                                                                
+        SD_RUNLOCK;
+                                                                                
+        return error;
+}
+
+void subdomain_socket_post_create(struct socket * sock, int family,
+	                          int type, int protocol)
+{
+	return nd_create(sock, family, type, protocol);
+}
+
+static int subdomain_socket_connect(struct socket *sock, 
+				    struct sockaddr *address,
+				    int addrlen)
+{
+	return nd_connect(sock, address, addrlen);
+}
+
+static int subdomain_socket_accept(struct socket *sock, struct socket *newsock)
+{
+        return nd_accept(sock, newsock);
+}
+
+static void subdomain_socket_post_accept(struct socket *sock, struct socket *newsock)
+{
+        return nd_post_accept(sock, newsock);
+}
+
+static int subdomain_socket_listen(struct socket * sock, int backlog)
+{
+	return nd_listen(sock, backlog);
+}
+
+static int subdomain_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+				    int size)
+{
+	return nd_sendmsg(sock, msg, size);
+}
+
+static int subdomain_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+				    int size, int flags)
+{
+	return nd_recvmsg(sock, msg, size, flags);
+}
+
+static int subdomain_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+/* WARNING:  this entry point is in 'soft interrupt' NOT process context */
+
+	return nd_rcv(sk, skb);
+}
+#endif /* NETDOMAIN */
+
+struct security_operations subdomain_ops = {
+	.ptrace =			subdomain_ptrace,
+	.capget =			subdomain_capget,
+	.capset_check =			subdomain_capset_check,
+	.capset_set =			subdomain_capset_set,
+	.sysctl =			subdomain_sysctl,
+	.capable =			subdomain_capable,
+	.syslog =			subdomain_syslog,
+	
+	.netlink_send =			subdomain_netlink_send,
+	.netlink_recv =			subdomain_netlink_recv,
+	
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,6)
+	.bprm_apply_creds =		subdomain_bprm_apply_creds,
+#else
+	.bprm_compute_creds =		subdomain_bprm_compute_creds,
+#endif
+	.bprm_set_security =		subdomain_bprm_set_security,
+
+	.sb_mount =			subdomain_sb_mount,
+	.sb_umount =			subdomain_umount,
+	
+	.inode_create =			subdomain_inode_create,
+	.inode_link =			subdomain_inode_link,
+	.inode_unlink =			subdomain_inode_unlink,
+	.inode_symlink =		subdomain_inode_symlink,
+	.inode_mknod =			subdomain_inode_mknod,
+	.inode_rename =			subdomain_inode_rename,
+	.inode_follow_link = 		subdomain_inode_follow_link,
+	.inode_permission =		subdomain_inode_permission,
+	.inode_setattr =		subdomain_inode_setattr,
+
+	.file_permission =		subdomain_file_permission,
+	.file_alloc_security =		subdomain_file_alloc_security,
+	.file_free_security =		subdomain_file_free_security,
+	.file_mmap =			subdomain_file_mmap,
+
+	.task_alloc_security =		subdomain_task_alloc_security,
+	.task_free_security =		subdomain_task_free_security,
+	.task_post_setuid =		subdomain_task_post_setuid,
+	.task_reparent_to_init =	subdomain_task_reparent_to_init,
+
+#ifdef SUBDOMAIN_PROCATTR
+	.getprocattr =			subdomain_getprocattr,
+	.setprocattr =			subdomain_setprocattr,
+#endif
+	
+#ifdef NETDOMAIN
+	.socket_create =		subdomain_socket_create,
+	.socket_post_create = 		subdomain_socket_post_create,
+	.socket_connect =		subdomain_socket_connect,
+	.socket_accept =		subdomain_socket_accept,
+	.socket_post_accept =		subdomain_socket_post_accept,
+	.socket_listen =		subdomain_socket_listen,
+	.socket_sendmsg =		subdomain_socket_sendmsg,
+	.socket_recvmsg =		subdomain_socket_recvmsg,
+	.socket_sock_rcv_skb =		subdomain_socket_sock_rcv_skb,
+	.sk_alloc_security =		subdomain_sk_alloc_security,
+	.sk_free_security =		subdomain_sk_free_security,
+#endif /* NETDOMAIN */
+};
+
+#ifdef SUBDOMAIN_FS
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static int sd_statfs(struct super_block *sb, struct kstatfs *buf)
+#else
+static int sd_statfs(struct super_block *sb, struct statfs *buf)
+#endif
+{
+	buf->f_type = SD_ID_MAGIC;
+	buf->f_bsize = PAGE_CACHE_SIZE;
+	buf->f_namelen = 255;
+	return 0;
+}
+
+static struct super_operations sdfs_ops = {
+	.statfs =	sd_statfs,
+};
+
+static int sd_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct dentry *root;
+	struct inode *inode;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = SD_ID_MAGIC;
+	sb->s_op = &sdfs_ops;
+	inode = sd_new_inode(sb, S_IFDIR | 0751, 2);
+
+	root = d_alloc_root(inode);
+	if (!root) {
+		iput(inode);
+		return -ENOMEM ;
+	}
+	sb->s_root = root;
+	if (sd_fill_root(root)) {
+	//	d_genocide(root);
+		dput(root);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static struct super_block *sd_get_sb(struct file_system_type *fs_type,
+                                     int flags, const char *dev_name, 
+				     void *data)
+{
+        return get_sb_single(fs_type, flags, data, sd_fill_super);
+}
+#else
+struct super_block * sd_read_super(struct super_block *sb, void *data, int silent)      
+{       
+	struct dentry *root;
+	struct inode *inode;
+	
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = SD_ID_MAGIC;
+	sb->s_op = &sdfs_ops;
+	inode = sd_new_inode(sb, S_IFDIR | 0755, 2);
+	
+	root = d_alloc_root(inode);
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	sb->s_root = root;
+	if (sd_fill_root(root)) {
+	//      d_genocide(root);
+		dput(root);
+		return NULL;
+	}
+	return sb;      
+}
+#endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0
+
+
+static struct file_system_type sd_fs_type = {
+	.name =		"subdomainfs",
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	.get_sb =	sd_get_sb,
+	.kill_sb = 	kill_litter_super,
+#else
+	.read_super =   sd_read_super,
+	.fs_flags =     FS_SINGLE|FS_LITTER,
+#endif
+	.owner =	THIS_MODULE,
+};
+
+#endif /* SUBDOMAIN_FS */
+
+static int __init subdomain_init(void)
+{
+	int error=0;
+	char *complainmsg = ": complainmode enabled";
+
+	/*
+	 * CREATE SUBDOMAINFS
+	 */
+#ifdef SUBDOMAIN_FS
+ 	if ((error = register_filesystem(&sd_fs_type))) {
+ 		SD_ERROR("Unable to activate SubDomain filesystem\n");
+		goto registerfs_out;
+ 	}
+#else
+#error SUBDOMAIN_FS must be enabled
+#endif
+
+	
+
+	/*
+	 * CREATE NULL COMPLAIN PROFILE 
+	 */
+	null_complain_profile = alloc_sdprofile();
+	if (!null_complain_profile) {
+		SD_ERROR("Unable to allocate null-complain-profile\n");
+		error = -ENOMEM;
+		goto complain1_out;
+	}
+	null_complain_profile->name = kmalloc(strlen("null-complain-profile")+1, GFP_KERNEL);
+	if (!null_complain_profile->name) {
+		error = -ENOMEM;
+		goto complain2_out;
+	}
+	strcpy(null_complain_profile->name, "null-complain-profile");
+	get_sdprofile(null_complain_profile);
+	null_complain_profile->flags.complain = 1;
+
+#ifdef NETDOMAIN
+	/*
+	 * HOOK INTO IPV4/IPV6 HANDLERS
+	 */
+	nd_set_handlers();
+#endif
+
+	/*
+	 * REGISTER SubDomain WITH LSM
+	 */
+	if ((error = register_security(&subdomain_ops))) {
+		SD_WARN("Unable to load SubDomain\n");
+		goto register_out;
+	}
+	SD_INFO("SubDomain (version %s%s) initialized%s\n", 
+		subdomain_version(),
+		netdomain_enabled ? " Netdomain" : "",
+		subdomain_complain ? complainmsg : "");
+
+	/* DONE */
+	return error;
+
+register_out:
+#ifdef NETDOMAIN
+	nd_restore_handlers();	
+#endif
+
+complain2_out:
+	free_sdprofile(null_complain_profile);
+	null_complain_profile=NULL;
+
+complain1_out:
+#ifdef SUBDOMAIN_FS
+	(void)unregister_filesystem(&sd_fs_type);
+#endif
+
+registerfs_out:
+	return error;
+
+}
+
+static int subdomain_exit_removeall_iter(struct subdomain *sd, void *cookie)
+{
+	/* SD_WLOCK held here */
+
+	if (__sd_is_confined(sd)){
+		SD_DEBUG("%s: Dropping profiles %s(%d) profile %s(%p) active %s(%p)\n", 
+			__FUNCTION__,
+			sd->task->comm, sd->task->pid,
+			sd->profile->name, sd->profile,
+			sd->active->name, sd->active);
+		put_sdprofile(sd->profile);
+		put_sdprofile(sd->active);
+#if defined NETDOMAIN && defined NETDOMAIN_SKUSERS
+		nd_skusers_exch(sd->profile, NULL, 1);
+#endif
+		sd->profile = sd->active = NULL;
+	}
+
+	return 0;
+}
+
+static void __exit subdomain_exit(void)
+{
+	/* Remove profiles from the global profile list.
+	 * This is just for tidyness as there is no way to reference this
+	 * list once the SubDomain lsm hooks are detached (below)
+	 */
+	sd_profilelist_release();
+
+	/* Remove profiles from active tasks
+	 * If this is not done,  if module is reloaded after being removed,
+	 * old profiles (still refcounted in memory) will become 'magically'
+	 * reattached
+	 */
+	
+	SD_WLOCK;
+	sd_subdomainlist_iterate(subdomain_exit_removeall_iter, NULL);
+	SD_WUNLOCK;
+
+	/* Free up list of active subdomain */
+	sd_subdomainlist_release();
+
+	put_sdprofile(null_complain_profile);
+#ifdef SUBDOMAIN_FS
+	if (unregister_filesystem(&sd_fs_type))
+		SD_WARN("Unable to properly deactivate SubDomain fs\n");
+#endif
+
+#ifdef NETDOMAIN
+	nd_restore_handlers();	
+#endif
+
+	if (unregister_security(&subdomain_ops))
+		SD_WARN("Unable to properly unregister SubDomain\n");
+	SD_INFO("SubDomain protection removed\n");
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+security_initcall(subdomain_init);
+#else
+module_init(subdomain_init);
+#endif
+module_exit(subdomain_exit);
+
+MODULE_DESCRIPTION("SubDomain process confinement");
+MODULE_AUTHOR("Immunix");
+MODULE_LICENSE("GPL");
diff -uNrp linux-2.6.11/security/subdomain/main.c linux-2.6.11.subd-new/security/subdomain/main.c
--- linux-2.6.11/security/subdomain/main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/main.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,2046 @@
+/*
+ * Immunix SubDomain Core
+ * 
+ * Copyright (C) 2002 WireX Communications, Inc
+ *
+ * Ported from 2.2 by Chris Wright <chris@wirex.com>
+ *
+ * Copyright (C) 2003-2004 Immunix, Inc
+ *
+ * Ported to 2.6 by Tony Jones <tony@immunix.com>
+ */
+
+#include <linux/version.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/security.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/namei.h>
+#endif
+#include <linux/namespace.h>
+#include <linux/string.h>
+
+#include "subdomain.h"
+#include "immunix.h"
+
+#include "inline.h"
+
+#include "pcre_exec.h"
+
+/* temp define for syslog workaround */
+#define SYSLOG_TEMPFIX
+
+/***************************
+ * PRIVATE UTILITY FUNCTIONS
+ **************************/
+
+#ifdef SYSLOG_TEMPFIX
+/* Horrible hack
+ * Syslog (not syslog-ng) has a bug where it escapes uneven numbers of %
+ * symbols.  So we force an enen number here by escaping.
+ * This code will GO AWAY once syslog bug is fixed
+ */
+static inline 
+const char* _escape_percent(const char *name)
+{
+int count = 0, len = 0;
+const char *sptr;
+char *dptr, *newname = (char*)name;
+
+	sptr = name;
+	while (*sptr){
+		if (*sptr == '%')
+			count++;
+
+		len++;
+		sptr++;
+	}
+
+	if (count){
+		newname=kmalloc(len+count+1, GFP_KERNEL);
+		if (newname){
+			sptr = name;
+			dptr = newname;
+
+			while (*sptr){
+				if (*sptr =='%'){
+					*dptr++ = '%';
+				}
+
+				*dptr++ = *sptr++;
+			}
+			*dptr = 0;
+		}
+	}
+					
+	return (const char*)newname;
+}		
+#endif // SYSLOG_TEMPFIX
+
+#if defined (PRINTK_TEMPFIX) && ( defined (CONFIG_SMP) || defined (CONFIG_PREEMPT))
+/* A local buffer to get around printk in sys_setscheduler problems */
+#define __LOG_BUF_LEN 4096
+
+static char __log_buf[__LOG_BUF_LEN];
+static volatile int log_start = 0;
+static volatile int log_end = 0;
+static volatile int log_dumping = 0;
+static volatile int log_overflow = 0;
+/* this is used for fast testing in LSM.c */
+volatile int sd_log_buf_has_data = 0;
+
+#define LOG_MASK(idx) ((idx) & (__LOG_BUF_LEN - 1))
+#define LOG_BUF(idx) (__log_buf[(idx)])
+
+static spinlock_t logbuf_lock = SPIN_LOCK_UNLOCKED;
+
+void dump_sdprintk()
+{
+	/* check to see if there is any data and  */
+	unsigned long flags;
+	int start;
+	int end;
+	int overflow;
+
+	spin_lock_irqsave(&logbuf_lock, flags);
+	start = log_start;
+	end = log_end;
+	if (start == end) goto done;
+	if (log_dumping) goto done;
+	overflow = log_overflow;
+	log_dumping = 1;
+	spin_unlock_irqrestore(&logbuf_lock, flags);
+
+	/* printk can not be called with the logbuf_lock held, on systems with the
+         * printk scheduler locking bug (sd_printk isn't needed on systems without this
+         * bug).
+         * IF dump_sdprintk held the logbuf_lock around the printk, then there would
+         * be a race condition that could deadlock on SMP systems.
+         * 1. CPU1 dump_sdprintk takes the logbuf_lock
+         * 2. CPU2 another cpu calls set_priority or set_scheduler taking the scheduler lock
+         *    the task is confined and subdomain goes to generate a reject message
+         *    thus attempting to take the logbuf_lock (spins)
+	 * 3. CPU1 printk finish and invokes the scheduler which tries to take the
+         *    scheduler lock (spins)
+         * 4. Deadlock
+	 */
+
+	if (start < end) {
+		printk("%.*s", end-start, &__log_buf[start]);
+	} else {
+		/* wrapped around */
+		printk("%.*s%.*s", __LOG_BUF_LEN-start, &__log_buf[start],
+		       end, __log_buf);
+	}
+	if (overflow) {
+		SD_WARN("Overflow in sd_printk buffer\n");
+	}
+
+	spin_lock_irqsave(&logbuf_lock, flags);
+	if (overflow) {
+		log_overflow = 0;
+	}
+	log_start = end;
+	log_dumping = 0;
+ done:
+	if (end == log_end)
+		sd_log_buf_has_data = 0;
+	spin_unlock_irqrestore(&logbuf_lock, flags);
+}
+
+static asmlinkage int sd_printk(const char *fmt, ...)
+{
+	va_list args;
+	unsigned long flags;
+	int printed_len;
+	static char printk_buf[512];
+	char *p = printk_buf;
+	int start;
+	int end;
+	int i;
+
+	/* emit to temporary buffer */
+	va_start(args, fmt);
+	printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);
+	if (printed_len > sizeof(printk_buf)) printed_len = sizeof(printk_buf);
+	va_end(args);
+
+	spin_lock_irqsave(&logbuf_lock, flags);
+
+	start = log_start;
+	end = log_end;
+
+	/* copy output into sd's log_buf */
+	for ( i=0; i<printed_len ; i++) {
+		LOG_BUF(end) = *p;
+		end = LOG_MASK(end+1);
+		p++;
+		if (end == start) {
+			log_overflow = 1;
+			end = LOG_MASK(end-1);
+			i--;
+			break;
+		}
+	}
+	log_end = end;
+	sd_log_buf_has_data = 1;
+
+	spin_unlock_irqrestore(&logbuf_lock, flags);
+
+	return i;
+}
+#endif /* PRINTK_TEMPFIX */
+
+static inline 
+const char* sd_getpattern_type(pattern_t ptype)
+{
+const char *ptype_names[] = {
+	"ePatternBasic",
+	"ePatternTailGlob",
+	"ePatternRegex",
+	"ePatternInvalid"
+	};
+
+	if (ptype >= ePatternInvalid){
+		ptype = ePatternInvalid;
+	}
+
+	return ptype_names[ptype];
+}
+
+/*
+ * sd_taskattr_access:
+ * @name: name of file to check permission
+ * @mask: permission mask requested for file
+ *
+ * Determine if request is for write access to /proc/self/attr/current
+ */
+static inline 
+int sd_taskattr_access(const char *procrelname)
+{
+/* 
+ * assumes a 32bit pid, which requires max 10 decimal digits to represent
+ * sizeof includes trailing \0
+ */
+char buf[sizeof("/attr/current") + 10];
+const int maxbuflen=sizeof(buf);
+
+	snprintf(buf, maxbuflen, "%d/attr/current", current->pid);
+	buf[maxbuflen-1] = 0;
+
+	return strcmp(buf, procrelname) == 0;
+}
+
+/**
+ * sd_pattern_match - check if pathnames matches regex
+ * @name: name from sd_entry
+ * @pathname: path requested to serach for
+ *
+ * This compares two pathnames and accounts for globbing name from the
+ * sd_entry.  Returns 1 on match, 0 otherwise.
+ */
+static inline 
+int sd_pattern_match(const char *regex, pcre *compiled, const char *name)
+{
+int pcreret;
+int retval;
+
+	pcreret = pcre_exec(compiled, NULL, name, strlen(name), 0, 0, NULL, 0);
+
+	retval = (pcreret >= 0);
+
+	SD_DEBUG("%s(%d): %s %s %d\n", __FUNCTION__, retval, name, regex, pcreret);
+
+	return retval;
+}
+
+
+/**
+ * sd_path_match - check if pathnames match
+ * @name: name from sd_entry
+ * @pathname: path requested to serach for
+ *
+ * This compares two pathnames and accounts for globbing name from the
+ * sd_entry.  Returns 1 on match, 0 otherwise.
+ */
+static inline 
+int sd_path_match(const char *name, const char *pathname, pattern_t ptype)
+{
+	int retval;
+
+	/* basic pattern,  no regular expression characters */
+	if (ptype == ePatternBasic){
+		retval = (strcmp(name, pathname) == 0);
+
+	/* trailing glob pattern */
+	}else if (ptype == ePatternTailGlob){
+		const char      *p = pathname,
+				*pattp = name;
+
+       		while (*p && *pattp){
+                	if (unlikely(*pattp == '*')){
+				retval=1;
+                        	goto done;
+                	}else if (*p != *pattp){
+                        	retval=0;
+				goto done;
+                	}else{
+                        	++p;
+                        	++pattp;
+                	}
+        	}
+
+		retval = (*p == 0 && (*pattp == 0 || *pattp == '*'));
+	}else{
+		SD_WARN("%s: Invalid pattern_t %d\n", 
+			__FUNCTION__, ptype);
+		retval=0;
+	}
+
+done:
+	SD_DEBUG("%s(%d): %s %s [%s]\n", 
+		__FUNCTION__, retval, name, pathname,
+		sd_getpattern_type(ptype));
+
+	return retval;
+}
+
+/**
+ * sd_file_mode - get full mode for file entry from profile
+ * @name: filename
+ * @profile: profile
+ */
+static inline 
+int sd_file_mode(const char *name, struct sdprofile *profile)
+{
+	struct sd_entry *entry;
+	int mode = 0;
+
+	SD_DEBUG("%s: %s\n", __FUNCTION__, name);
+	if (!name) {
+		SD_DEBUG("%s: no name\n", __FUNCTION__);
+		goto out;
+	}
+
+	if (!profile) {
+		SD_DEBUG("%s: no profile\n", __FUNCTION__);
+		goto out;
+	}
+	for (entry = profile->file_entry; entry; entry = entry->next) {
+		if ((entry->pattern_type == ePatternRegex && 
+		     sd_pattern_match(entry->regex, entry->compiled, name)) || 
+		    (entry->pattern_type != ePatternRegex && 
+		     sd_path_match(entry->filename, name, entry->pattern_type))) {
+			mode |= entry->mode;
+		}
+	}
+out:
+	return mode;
+}
+
+/**
+ * find_mnt - find first possible mnt that dentry could be mounted on
+ * @d: dentry to use for lookup
+ *
+ * This returns a refcounted vfsmount that matches via looking at
+ * all mountpoints and returning the first match.  NULL on no match.
+ */
+static inline
+struct vfsmount *find_mnt(struct dentry *d)
+{
+	struct sd_path_data data;
+	struct vfsmount *mnt = NULL;
+
+	sd_path_begin(d, &data);
+	mnt=sd_path_getmnt(&data);
+	(void)sd_path_end(&data);
+
+	return mnt;
+}
+
+/*
+ * sd_get_execmode - calculate what qualifier to apply to an exec
+ * @name: name of file to exec
+ * @profile: profile to search
+ * @xbits: pointer to a execution mode bit for the rule that was matched
+ *         if the rule has no execuition qualifier {pui} then
+ *         KERN_COD_MAY_EXEC is returned indicating a naked x
+ *         if the has an exec qualifier then only the qualifier bit {pui}
+ *         is returned (KERN_COD_MAY_EXEC) is not set.
+ *
+ * Returns FALSE:
+ *    if unable to find profile or there are conflicting regular expressions.  
+ *       *xmod - is not modified
+ *
+ * Returns TRUE:
+ *    if not confined
+ *       *xmod = KERN_COD_MAY_EXEC
+ *    if exec rule matched
+ *       if the rule has an execution mode qualifier {pui} then
+ *          *xmod = the execution qualifier of the rule {pui}
+ *       else
+ *          *xmod = KERN_COD_MAY_EXEC
+ */
+static inline
+int sd_get_execmode(const char *name, struct subdomain *sd, int *xmod)
+{
+	struct sdprofile *profile;
+	struct sd_entry *entry, *match = NULL;
+
+	int regexp_match_invalid = FALSE,
+	    rc = FALSE;
+
+	/* not confined */
+	if (!__sd_is_confined(sd)){
+		SD_DEBUG("%s: not confined\n", __FUNCTION__);
+		goto not_confined;
+	}
+
+	profile = sd->active;
+	
+	/* search list of profiles with 'x' permission
+	 * this will also include entries with 'p', 'u' and 'i' 
+	 * qualifiers.
+	 *
+	 * If we find a regexp match we will keep looking for an exact match
+	 * If we find conflicting regexp matches we will flag (while still
+	 * looking for an exact match).  If all we have is a conflict, FALSE
+	 * is returned.
+	 */
+
+	entry = profile->file_entryp[POS_KERN_COD_MAY_EXEC];
+
+	while (entry){
+		if (!regexp_match_invalid &&
+		    entry->pattern_type == ePatternRegex && 
+		    sd_pattern_match(entry->regex, entry->compiled, name)){
+			
+			if (match && 
+			    SD_EXEC_MASK(entry->mode) != SD_EXEC_MASK(match->mode)){
+				regexp_match_invalid = TRUE;
+			}else{
+				/* got a regexp match, keep searching for an
+				 * exact match
+				 */
+				match = entry;
+			}
+		}else if ((entry->pattern_type == ePatternBasic ||
+			  (!regexp_match_invalid &&
+			   entry->pattern_type == ePatternTailGlob)) &&
+		     	  sd_path_match(entry->filename, name, entry->pattern_type)) {
+			if (entry->pattern_type == ePatternBasic){
+				/* got an exact match -- there can be only
+				 * one, asserted a profile load time 
+				 */
+				match = entry;
+				regexp_match_invalid = FALSE;
+				break;
+			}else{ /* entry->pattern_type == ePatternTailGlob */
+				if (match &&
+				    SD_EXEC_MASK(entry->mode) != SD_EXEC_MASK(match->mode)){
+					regexp_match_invalid = TRUE;
+				}else{
+					/* got a tailglob match, keep searching
+					 * for an exact match
+					 */
+					match = entry;
+				}
+			}
+		}
+
+		entry = entry->nextp[POS_KERN_COD_MAY_EXEC];
+	}
+
+	rc = match && !regexp_match_invalid;
+
+	if (rc){
+		int mode = SD_EXEC_MASK(match->mode);
+
+		/* check for qualifiers, if present 
+		 * we just return the qualifier
+		 */
+		if (mode & ~KERN_COD_MAY_EXEC){
+			mode = mode & ~KERN_COD_MAY_EXEC;
+		}
+
+		*xmod = mode;
+	}else if (!match){
+		SD_DEBUG("%s: Unable to find execute entry in profile for image '%s'\n",
+			__FUNCTION__,
+			name);
+	}else if (regexp_match_invalid){
+		SD_WARN("%s: Inconsistency in profile %s. Two (or more) regular expressions specify conflicting exec qualifiers ('u', 'i' or 'p') for image %s\n",
+			__FUNCTION__,
+			sd->active->name,
+			name);
+	}
+
+	return rc;
+
+not_confined:
+	*xmod = KERN_COD_MAY_EXEC;
+	return TRUE;
+}
+
+
+/****************************
+ * INTERNAL TRACING FUNCTIONS
+ ***************************/
+
+/**
+ * sd_attr_trace - trace attempt to change file attributes
+ * @name: file requested
+ * @sd: current subdomain
+ * @iattr: requested new modes
+ * @error: error flag
+ *
+ * Prints out the status of the attribute change request.  Only prints
+ * accepted when in audit mode.
+ */
+static inline
+void sd_attr_trace(const char *name, struct subdomain *sd, struct iattr *iattr, int error)
+{
+	char *status = "AUDITING";
+#ifdef SYSLOG_TEMPFIX
+	const char *newname = _escape_percent(name);
+#endif
+
+	if (error){
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+	}else if (!SUBDOMAIN_AUDIT(sd)){
+		return;
+	}
+
+#ifdef SYSLOG_TEMPFIX
+	SD_WARN("%s%s attribute (%s%s%s%s%s%s) change to %s (%s(%d) profile %s active %s)\n",
+		status,
+		newname != name ? "-SYSLOGFIX" : "",
+		iattr->ia_valid & ATTR_MODE ? "mode," : "",
+		iattr->ia_valid & ATTR_UID ? "uid," : "",
+		iattr->ia_valid & ATTR_GID ? "gid," : "",
+		iattr->ia_valid & ATTR_SIZE ? "size," : "",
+		iattr->ia_valid & ATTR_ATIME_SET ? "atime," : "",
+		iattr->ia_valid & ATTR_MTIME_SET ? "mtime," : "",
+		newname ? newname : "KMALLOC-ERROR",
+		current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+
+	if (newname != name)
+		kfree(newname);
+#else
+	SD_WARN("%s attribute (%s%s%s%s%s%s) change to %s (%s(%d) profile %s active %s)\n",
+		status,
+		iattr->ia_valid & ATTR_MODE ? "mode," : "",
+		iattr->ia_valid & ATTR_UID ? "uid," : "",
+		iattr->ia_valid & ATTR_GID ? "gid," : "",
+		iattr->ia_valid & ATTR_SIZE ? "size," : "",
+		iattr->ia_valid & ATTR_ATIME_SET ? "atime," : "",
+		iattr->ia_valid & ATTR_MTIME_SET ? "mtime," : "",
+		name, current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+#endif
+}
+
+/**
+ * sd_perm_trace - trace permission
+ * @name: file requested
+ * @sd: current subdomain
+ * @mask: requested permission
+ * @error: error flag
+ *
+ * Prints out the status of the permission request.  Only prints
+ * accepted when in audit mode.
+ */
+static inline
+void sd_perm_trace(const char *name, struct subdomain *sd, int mask, int error)
+{
+	char *status = "AUDITING";
+#ifdef SYSLOG_TEMPFIX
+	const char *newname = _escape_percent(name);
+#endif
+
+	if (error){
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+	}else if (!SUBDOMAIN_AUDIT(sd)){
+		return;
+	}
+
+#ifdef SYSLOG_TEMPFIX
+	SD_WARN("%s%s %s%s%s%s access to %s (%s(%d) profile %s active %s)\n",
+		status,
+		newname != name ? "-SYSLOGFIX" : "",
+		mask & KERN_COD_MAY_READ  ? "r": "" ,
+		mask & KERN_COD_MAY_WRITE ? "w": "" ,
+		mask & KERN_COD_MAY_EXEC  ? "x": "" ,
+		mask & KERN_COD_MAY_LINK  ? "l": "" ,
+		newname ? newname : "KMALLOC-ERROR",
+		current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+
+	if (newname != name)
+		kfree(newname);
+#else
+	SD_WARN("%s %s%s%s%s access to %s (%s(%d) profile %s active %s)\n",
+		status,
+		mask & KERN_COD_MAY_READ  ? "r": "" ,
+		mask & KERN_COD_MAY_WRITE ? "w": "" ,
+		mask & KERN_COD_MAY_EXEC  ? "x": "" ,
+		mask & KERN_COD_MAY_LINK  ? "l": "" ,
+		name, current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+#endif
+}
+
+#ifdef NETDOMAIN
+/**
+ * nd_perm_trace - trace permission
+ *
+ * @tsk: task
+ * @saddr: source (local) IP address
+ * @daddr: destination (remote) IP address
+ * @sport: source (local) port in network byte order
+ * @dport: destination (remote) port in network bute order
+ * @ifname: interface name (or NULL)
+ * @sd: current subdomain (or NULL if not confined)
+ * @mode: requested permission  (unlike sd_file_perm, this is not a mask)
+ * @error: error flag
+ *
+ * Prints out the status of the permission request.  Only prints
+ * accepted when in audit mode.
+ */
+static inline
+void nd_perm_trace(struct task_struct *tsk,
+		   __u32 saddr, __u32 daddr, __u16 sport, __u16 dport, 
+		   char *ifname, struct subdomain* sd, int mode, int error)
+{
+	char *status = "AUDITING";
+	__u32 _saddr, _daddr;
+	__u16 _sport, _dport;
+
+	if (error){
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+	}else if (!SUBDOMAIN_AUDIT(sd)){
+		return;
+	}
+
+	if (mode == KERN_COD_TCP_ACCEPT || mode == KERN_COD_UDP_RECEIVE ||
+	    mode == KERN_COD_LOGTCP_RECEIVE){
+
+		/* reverse source and dest to be more human readable */
+		_saddr = daddr;
+		_sport = dport;
+		_daddr = saddr;
+		_dport = sport;
+	}else{
+		_saddr = saddr;
+		_sport = sport;
+		_daddr = daddr;
+		_dport = dport;
+	}
+
+	ND_WARN("%s %s%s%s%s%s%s from source %u.%u.%u.%u:%hu to destination %u.%u.%u.%u:%hu via iface %s (%s(%d) profile %s active %s)\n",
+		status,
+		mode & KERN_COD_TCP_ACCEPT	? "tcp_accept" : "",
+		mode & KERN_COD_TCP_CONNECT	? "tcp_connect" : "",
+		mode & KERN_COD_UDP_SEND	? "udp_send" : "",
+		mode & KERN_COD_UDP_RECEIVE	? "udp_receive": "",
+		mode & KERN_COD_LOGTCP_SEND	? "tcp_send" : "",
+		mode & KERN_COD_LOGTCP_RECEIVE	? "tcp_receive" : "",
+		NIPQUAD(_saddr), ntohs(_sport), 
+		NIPQUAD(_daddr), ntohs(_dport), 
+		ifname ? ifname : "n/a",
+		tsk ? tsk->comm : "comm n/a",
+		tsk ? tsk->pid : -1,
+		sd->profile->name, sd->active->name);
+}
+#endif // NETDOMAIN
+
+/**
+ * sd_link_perm_trace - trace link permission
+ * @lname: name requested as new link
+ * @tname: name requested as new link's target
+ * @sd: current SubDomain
+ * @error: error status
+ *
+ * Prints out the status of the permission request.  Only prints
+ * accepted when in audit mode.
+ */
+static inline
+void sd_link_perm_trace(const char *lname, const char *tname, 
+					struct subdomain *sd,  int error)
+{
+	char *status = "AUDITING";
+#ifdef SYSLOG_TEMPFIX
+	const char *newlname = _escape_percent(lname),
+	     	   *newtname = _escape_percent(tname);
+#endif
+
+	if (error){
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+	}else if (!SUBDOMAIN_AUDIT(sd)){
+		return;
+	}
+
+#ifdef SYSLOG_TEMPFIX
+	SD_WARN("%s%s link access from %s to %s (%s(%d) profile %s active %s)\n",
+		status, 
+		newlname != lname || newtname != tname ? "-SYSLOGFIX" : "",
+		newlname ? newlname : "KMALLOC-ERROR",
+		newtname ? newtname : "KMALLOC-ERROR",
+		current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+
+	if (newlname != lname)
+		kfree(newlname);
+
+	if (newtname != tname)
+		kfree(newtname);
+#else
+	SD_WARN("%s link access from %s to %s (%s(%d) profile %s active %s)\n",
+		status, lname, tname, current->comm, current->pid,
+		sd->profile->name, sd->active->name);
+#endif
+}
+
+
+/*************************
+ * MAIN INTERNAL FUNCTIONS
+ ************************/
+
+/**
+ * sd_link_perm - test permission to link to a file
+ * @link: name of link being created
+ * @target: name of target to be linked to
+ * @sd: current SubDomain
+ * 
+ * Look up permission mode on both @link and @target.  @link must have same
+ * permission mode as @target.  At least @link must have the link bit enabled.
+ * Return 0 on success, error otherwise.
+ */
+static int 
+sd_link_perm(const char *link, const char *target, struct subdomain *sd)
+{
+	int l_mode, t_mode, error = -EPERM;
+	struct sdprofile *profile = sd->active;
+
+	error = -EPERM;
+	l_mode = sd_file_mode(link, profile);
+	if (!(l_mode & KERN_COD_MAY_LINK))
+		goto out;
+	/* ok, mask off link bit */
+	l_mode &= ~KERN_COD_MAY_LINK;
+
+	t_mode = sd_file_mode(target, profile);
+	t_mode &= ~KERN_COD_MAY_LINK;
+
+	if (l_mode == t_mode)
+		error = 0;
+
+out:
+	sd_link_perm_trace(link, target, sd, error);
+	if (SUBDOMAIN_COMPLAIN(sd)){
+		error = 0;
+	}
+	return error;
+}
+
+/**************************
+ * GLOBAL UTILITY FUNCTIONS
+ *************************/
+
+/**
+ * __sd_get_name - retrieve fully qualified path name
+ * @dentry: relative path element
+ * @mnt: where in tree
+ *
+ * Returns fully qualified path name on sucess, NULL on failure.
+ * sd_put_name must be used to free allocated buffer.
+ */
+char * __sd_get_name(struct dentry *dentry, struct vfsmount *mnt)
+{
+	char *page, *name = NULL;
+
+	page = (char *)__get_free_page(GFP_KERNEL);
+	if (!page)
+		goto out;
+
+	name = d_path(dentry, mnt, page, PAGE_SIZE);
+	SD_DEBUG("%s: full_path=%s\n", __FUNCTION__, name);
+out:
+	return name;
+}
+
+
+/***********************************
+ * GLOBAL PERMISSION CHECK FUNCTIONS
+ ***********************************/
+
+#ifdef NETDOMAIN
+/*
+ * __nd_network_perm
+ * 	Netdomain permissions check. 
+ * 	Returns 0 on access allowed and < 0 on failure.  
+ * 	In order to pass we must find a matching rule then	
+ *	check the permissions for the rule.
+ *
+ * @tsk: task
+ * @sd: current subdomain (or NULL if not confined)
+ * @saddr: source (local) IP address
+ * @daddr: destination (remote) IP address
+ * @sport: source (local) port in network byte order
+ * @dport: destination (remote) port in network bute order
+ * @ifname: interface name (or NULL)
+ * @mode: requested permission
+ */
+int 
+__nd_network_perm (struct task_struct *tsk,
+		   struct subdomain *sd, 
+		   __u32 saddr,  __u16 sport, 
+		   __u32 daddr, __u16 dport, 
+		   char * ifname, int mode)
+{
+	struct sdprofile *profile;
+	struct nd_entry *net_entry;
+	int error, index, logmode, i;
+	
+	/* If we are not confined:
+	 * 	- no profile 
+	 * 	- [opposite of subdomain] no netdomain rules in the profile 
+	 * then access is allowed.  
+	 * Otherwise access is denied.
+	 */
+
+	error = 0;
+
+	if (!__sd_is_ndconfined(sd)){
+		/* exit with access allowed */
+		ND_DEBUG("%s: not confined\n", __FUNCTION__);
+		goto done_notrace;
+	}
+
+	/* from here on, return an error unless we match a rule */
+	error = -EACCES;
+
+
+	/* now that we know sd is valid, do some basic logging */
+
+	ND_DEBUG("%s: active %s(%p) profile %s(%p) comm %s(%d)\n",
+		__FUNCTION__,
+		sd->active ? sd->active->name : "NULL",	
+		sd->active,
+		sd->profile ? sd->profile->name : "NULL",
+		sd->profile,
+		tsk ? tsk->comm : "n/a",
+		tsk ? tsk->pid : -1);
+
+	ND_DEBUG("%s: src=%u.%u.%u.%u:%hu dest=%u.%u.%u.%u:%hu iface=%s mode=0x%x\n", 
+		__FUNCTION__, 
+		NIPQUAD(saddr), ntohs(sport),
+		NIPQUAD(daddr), ntohs(dport),
+		ifname ? ifname : "n/a",
+		mode);
+
+
+	/* KERN_COD_LOGTCP_SEND and KERN_COD_LOGTCP_RECEIVE are not true 
+	 * permissions.  Check for them here and mask them out
+	 * Value is used for logging only
+	 */
+	if (mode & KERN_COD_LOGTCP_SEND){	
+		logmode = KERN_COD_LOGTCP_SEND;
+		mode = mode & ~KERN_COD_LOGTCP_SEND;
+	}else if (mode & KERN_COD_LOGTCP_RECEIVE){
+		logmode = KERN_COD_LOGTCP_RECEIVE;
+		mode = mode & ~KERN_COD_LOGTCP_RECEIVE;
+	}else{
+		logmode = mode;
+	}
+
+	index = -1;
+	for (i=POS_KERN_COD_NET_MIN;i<=POS_KERN_COD_NET_MAX;i++){
+		/* only one permission allowed per node for netdomain */
+		if (mode == (1<<i)){
+			index=NET_POS_TO_INDEX(i);
+			break;
+		}
+	}
+
+	if (index == -1){
+		ND_WARN("%s: invalid mode 0x%x\n",
+			__FUNCTION__,
+			mode);
+		goto done_notrace;
+	}
+
+	profile = sd->profile;
+
+	net_entry = profile->net_entryp[index];
+
+	/* No netdomain entries for this rule but __sd_is_ndconfined test 
+	 * above indicates we have at least one netdomain rule so EACCES
+	 * here
+	 */
+	if (!net_entry){
+		ND_DEBUG("%s: no entries for mode %d index %d\n", 
+			__FUNCTION__, mode, index);
+		goto done;
+	}
+
+	for (; net_entry; net_entry = net_entry->nextp[index]) {
+		/* N.B if net_entry->saddr or net_entry->daddr are ommited
+		 * from the profile, the parser passes a value of 0.
+		 * It should of course use INADDR_NONE which is 0xffffffff.
+		 *
+		 * To make this clear, we use a literla 0 rather than 
+		 * INADDR_ANY (which is also #defined to 0) when checking 
+		 * saddr/daddr.
+		 */
+
+		ND_DEBUG("%s: entry src=%u.%u.%u.%u:%hu-%hu smask=%08x dest=%u.%u.%u.%u:%hu-%hu dmask=%08x iface=%s mode=0x%x\n", 
+			__FUNCTION__, 
+			NIPQUAD(net_entry->saddr), 
+				net_entry->src_port[0],
+				net_entry->src_port[1],
+			net_entry->smask,
+			NIPQUAD(net_entry->daddr), 
+				net_entry->dst_port[0],
+				net_entry->dst_port[1],
+			net_entry->dmask,
+			net_entry->iface ? net_entry->iface : "n/a",
+			net_entry->mode);
+
+		/* Check source address:
+		 * Lazy matching:  proceeds if passed saddr is INADDR_ANY or
+		 * if stored net_entry saddr is INADDR_ANY
+		 */
+		if (saddr != INADDR_ANY && 
+		    net_entry->saddr != 0 &&
+		    (saddr & net_entry->smask) != net_entry->saddr) {
+			/* source address does not match */
+			ND_DEBUG("%s: saddr did not match\n", __FUNCTION__);
+			continue;
+		}
+
+		/* Check dest address:
+		 * Lazy matching:  proceeds if passed daddr is INADDR_ANY or
+		 * if stored net_entry daddr is INADDR_ANY
+		 */
+		if (daddr != INADDR_ANY &&
+		    net_entry->daddr != 0 &&
+	    	    (daddr & net_entry->dmask) != net_entry->daddr) {
+			/* destination address does not match */
+			ND_DEBUG("%s: daddr did not match\n", __FUNCTION__);
+			continue;
+		}
+
+		/* Check source port:
+		 * Lazy matching:  proceeds if passed sport is 0 or
+		 * if stored net_entry src_port[0] is 0
+		 */
+		if (sport != 0 && 
+		    net_entry->src_port[0] != 0 &&
+		    (ntohs(sport) < net_entry->src_port[0] || 
+		     ntohs(sport) > net_entry->src_port[1])) {
+			/* source port does not match */
+			ND_DEBUG("%s: sport did not match\n", __FUNCTION__);
+			continue;
+		}
+
+		/* Check dest port:
+		 * Lazy matching:  proceeds if passed dport is 0 or
+		 * if stored net_entry dst_port[0] is 0
+		 */
+		if (dport != 0 &&
+		    net_entry->dst_port[0] != 0 && 
+		    (ntohs(dport) < net_entry->dst_port[0] || 
+		     ntohs(dport) > net_entry->dst_port[1])) {
+			/* dest port does not match */
+			ND_DEBUG("%s: dport did not match\n", __FUNCTION__);
+			continue;
+		}
+
+		/* Check interface name:
+		 * Lazy matching:  proceeds if passed dport is NULL or
+		 * if stored net_entry iface is NULL
+		 */
+		if (ifname &&
+		    net_entry->iface &&
+		    strcmp(ifname, net_entry->iface) != 0){
+			/* interface does not match */
+			ND_DEBUG("%s: iface did not match\n", __FUNCTION__);
+			continue;
+		}
+
+		/* Check requested mode (permission):
+		 * Unlike subdomain, this is not a mask, as only
+		 * one operation is implied per node.
+		 * No lazy matching is allowed.
+		 */
+
+		if (net_entry->mode != mode) {
+			/* mode does not match */
+			ND_DEBUG("%s: mode did not match\n", __FUNCTION__);
+			continue;
+		}
+
+		/* MATCH */
+		ND_DEBUG("%s: MATCH!\n", __FUNCTION__);
+		error = 0;
+		break;
+
+	} /* for_each */
+
+done:
+	nd_perm_trace(tsk, saddr, daddr, sport, dport, 
+		      ifname, sd, logmode, error);
+
+	if (SUBDOMAIN_COMPLAIN(sd)){
+		error=0;
+	}
+
+done_notrace:
+ 	return error;
+}
+
+/*
+ * nd_network_perm
+ *
+ * @sd: current subdomain (or NULL if not confined)
+ * @saddr: source (local) IP address
+ * @daddr: destination (remote) IP address
+ * @sport: source (local) port in network byte order
+ * @dport: destination (remote) port in network bute order
+ * @ifname: interface name (or NULL)
+ * @mode: requested permission
+ */
+int 
+nd_network_perm (struct subdomain *sd, 
+		 __u32 saddr, __u16 sport,
+		 __u32 daddr, __u16 dport, 
+		 char * ifname, int mode)
+{
+	return __nd_network_perm(current, sd, 
+				 saddr, sport, 
+				 daddr, dport, 
+				 ifname, mode);
+}
+#endif /* NETDOMAIN */
+
+/*
+ * sd_file_perm - calculate access mode for file
+ * @name: name of file to calculate mode for
+ * @profile: profile to search
+ * @mask: permission mask requested for file
+ *
+ * Search the sd_entry list in @profile.  
+ * Search looking to verify all permissions passed in mask.
+ * Perform the search by looking at the partitioned list of entries, one 
+ * partition per permission bit.
+ * Return 0 on access allowed, < 0 on error.
+ */
+int sd_file_perm(const char *name, struct subdomain *sd, int mask, int log)
+{
+	struct sd_entry *entry;
+	struct sdprofile *profile;
+	int i, error, mode;
+
+#define PROCPFX "/proc/"
+#define PROCLEN sizeof(PROCPFX) - 1
+
+	SD_DEBUG("%s: %s 0x%x\n", __FUNCTION__, name, mask);
+
+	error = 0;
+
+	// should not enter with other than R/W/X/L
+	BUG_ON(mask & ~(KERN_COD_MAY_READ|KERN_COD_MAY_WRITE|KERN_COD_MAY_EXEC|KERN_COD_MAY_LINK));
+
+	/* not confined */
+	if (!__sd_is_confined(sd)){
+		/* exit with access allowed */
+		SD_DEBUG("%s: not confined\n", __FUNCTION__);
+		goto done_notrace;
+	}
+
+	/* 
+	 * Ugh :-(
+	 * Special case access to /proc/self/attr/current
+	 *
+	 * Alternative would be to add /proc/self/attr/current to each
+	 * profile whenever a profile is loaded but issue is complicated by
+	 * the statically shared null-profile.
+	 */
+	if (strncmp(PROCPFX, name, PROCLEN) == 0 && (!list_empty(&sd->profile->sub) ||  SUBDOMAIN_COMPLAIN(sd))){
+		if (mask == MAY_WRITE && sd_taskattr_access(name+PROCLEN)){
+			log=0;
+			goto done;
+		}
+	}
+
+	error = -EACCES;
+
+	profile = sd->active;
+
+	mode = 0;
+
+	/* iterate over partition, one permission bit at a time */
+	for (i=0; i<=POS_KERN_COD_FILE_MAX; i++){
+
+		/* do we have to accumulate this bit? 
+		 * or have we already accumulated it (shortcut below)? */
+		if (!(mask & (1<<i)) || mode & (1<<i)){
+			continue;
+		}
+
+
+		for (entry = profile->file_entryp[i]; entry; entry = entry->nextp[i]) {
+			if ((entry->pattern_type == ePatternRegex && 
+		     		sd_pattern_match(entry->regex, entry->compiled, name)) || 
+		    	    (entry->pattern_type != ePatternRegex && 
+		     		sd_path_match(entry->filename, name, entry->pattern_type))) {
+				/* 
+				 * even though we are searching each bit 
+				 * partition at a time, accumulate all bits
+				 * present at this entry as a shortcut 
+				 */
+				mode |= entry->mode;
+
+				/* 
+			 	* mask bits are overloaded.
+				* values 1, 2, 4 and 8 (MAY_EXEC, MAY_WRITE, 
+				* MAY_READ and MAY_APPEND) are used by entire 
+				* kernel, other values are local.
+				*
+				* lsm.c (external interface into subdomain --
+				* subdomain_file_permission) masks kernel
+				* provided masks with 
+				* MAY_EXEC|MAY_WRITE|MAY_READ 
+			 	* before calling this function to prevent 
+				* external visibility of these subdomain 
+				* extentions.
+				*
+				* Subdomain internally calls into this function
+				* with bits other than the above.
+			 	*/
+				if ((mode & mask) == mask) {
+					SD_DEBUG("MATCH! %s=0x%x [total mode=0x%x]\n", 
+						name, mask, mode);
+						
+					error=0;
+					goto done;
+				}
+			}
+		}
+	}
+
+done:
+	if (log){
+		sd_perm_trace(name, sd, mask, error);
+
+		if (SUBDOMAIN_COMPLAIN(sd)){
+			error = 0;
+		}
+	}
+
+done_notrace:
+	return error;
+}
+
+/**
+ * sd_attr - check whether attribute change allowed
+ * @dentry: file to check
+ * @sd: current subdomain to check against
+ * @mask: access mode requested
+ *
+ * This function is a replica of sd_perm. In fact, calling sd_perm(MAY_WRITE)
+ * will achieve the same access control, but logging would appear to indicate
+ * success/failure of a "w" rather than an attribute change.  Also, this way we
+ * can log a single message indicating success/failure and also what attribite 
+ * changes were attempted.  
+ */
+int sd_attr(struct dentry *dentry, struct subdomain *sd, struct iattr *iattr)
+{
+	int error = 0, sdpath_error;
+	struct sd_path_data data;
+	char *name;
+
+	/* if not confined or empty mask permission granted */
+	if (!__sd_is_confined(sd) || !iattr)
+		goto out;
+
+
+	/* search all paths to dentry */
+
+	sd_path_begin(dentry, &data);
+	do{
+		name = sd_path_getname(&data);
+		if (name){
+			error = sd_file_perm(name, sd, MAY_WRITE, FALSE);
+			
+			/* access via any path is enough */
+			if (error){
+				sd_attr_trace(name, sd, iattr, error);
+			}
+
+			sd_put_name(name);
+
+			if (!error){
+				break;
+			}	
+		}
+
+	}while (name);
+	
+	if ((sdpath_error = sd_path_end(&data)) != 0){
+		SD_ERROR("%s: An error occured while translating dentry %p inode# %lu to a pathname. Error %d\n",
+			 __FUNCTION__,
+			dentry,
+			dentry->d_inode->i_ino,
+			sdpath_error);
+
+		error = sdpath_error;
+	}
+	
+	if (SUBDOMAIN_COMPLAIN(sd)){
+		error = 0;
+	}
+
+out:
+	return error;
+}
+
+/**
+ * sd_perm - basic SubDomain permissions check
+ * @inode: file to check
+ * @sd: current subdomain to check against
+ * @mask: access mode requested
+ *
+ * This checks that the @inode is in the current subdomain, @sd, and
+ * that it can be accessed in the mode requested by @mask.  Returns 0 on
+ * success.
+ */
+int sd_perm(struct inode *inode, struct subdomain *sd, struct nameidata *nd,
+		int mask)
+{
+	char *name = NULL;
+	int error = 0;
+
+	if (!nd){
+		goto out;
+	}
+
+	/* if not confined or empty mask permission granted */
+	if (!__sd_is_confined(sd) || !mask)
+		goto out;
+	/* we don't care about MAY_APPEND */
+	mask &= ~MAY_APPEND;
+
+	/* we only require MAY_WRITE for write to a dir */
+	if (nd->dentry->d_inode && S_ISDIR(nd->dentry->d_inode->i_mode))
+		if ((mask & (MAY_EXEC|MAY_WRITE)) == mask)
+			//mask = MAY_WRITE;
+			goto out;
+
+	name = __sd_get_name(nd->dentry, nd->mnt);
+	if (!name) {
+		error = -ENOMEM;
+	}else{
+		error = sd_file_perm(name, sd, mask, TRUE);
+		sd_put_name(name);
+	}
+out:
+	return error;
+}
+
+int sd_perm_dentry(struct dentry *dentry, struct subdomain *sd, int mask)
+{
+        char *name;
+	struct sd_path_data data;
+        int error = 0, sdpath_error;
+
+        /* if not confined or empty mask permission granted */
+        if (!__sd_is_confined(sd) || !mask)
+                goto out;
+
+        /* we don't care about MAY_APPEND */
+        mask &= ~MAY_APPEND;
+
+        /* we only require MAY_WRITE for write to a dir */
+        if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
+                if ((mask & (MAY_EXEC|MAY_WRITE)) == mask)
+                        //mask = MAY_WRITE;
+                        goto out;
+
+        /* search all paths to dentry */
+
+	sd_path_begin(dentry, &data);
+	do{
+		name = sd_path_getname(&data);
+		if (name){
+			error = sd_file_perm(name, sd, mask, TRUE);
+			sd_put_name(name);
+
+			/* access via any path is enough */
+			if (!error)
+				break;
+		}
+	}while (name);
+
+	if ((sdpath_error = sd_path_end(&data)) != 0){
+		SD_ERROR("%s: An error occured while translating dentry %p inode# %lu to a pathname. Error %d\n",
+			__FUNCTION__,
+			dentry,
+			dentry->d_inode->i_ino,
+			sdpath_error);
+
+		error = sdpath_error;
+	}
+
+out:
+        return error;
+}
+
+/**
+ * sd_capability - test permission to use capability
+ * @cap: capability to be tested
+ * 
+ * Look up capability in active profile capability set.
+ * Return 0 if valid, -EPERM if invalid
+ */
+
+int sd_capability(int cap, struct subdomain *sd)
+{
+int error = 0;
+
+	if (__sd_is_confined(sd)){
+		char *status;
+
+		status = SUBDOMAIN_COMPLAIN(sd) ? "PERMITTING" : "REJECTING";
+
+		error = cap_raised(sd->active->capabilities, cap) ? 0 : -EPERM;
+
+		if (error || SUBDOMAIN_AUDIT(sd)){
+			if (error == 0){ /* AUDIT */
+				status = "AUDITING";
+			}
+
+#if defined (PRINTK_TEMPFIX) && ( defined (CONFIG_SMP) || defined (CONFIG_PREEMPT))
+
+			/* ugly hack to work around a SMP scheduler bug,
+			 * related to calling printk from sys_setscheduler */
+			if (cap == CAP_SYS_NICE) 
+				sd_printk(KERN_WARNING "SubDomain: %s access to capability '%s' (%s(%d) profile %s active %s)\n",
+					  status,
+					  capability_to_name(cap),
+					  current->comm, current->pid,
+					  sd->profile->name, sd->active->name);
+			else 
+#endif
+				SD_WARN("%s access to capability '%s' (%s(%d) profile %s active %s)\n",
+					status,
+					capability_to_name(cap),
+					current->comm, current->pid,
+					sd->profile->name, sd->active->name);
+			if (SUBDOMAIN_COMPLAIN(sd)){
+				error = 0;
+			}
+		}
+	}
+
+	return error;
+}
+
+/**
+ * sd_link - hard link check
+ * @link: dentry for link being created
+ * @target: dentry for link target
+ * @sd: SubDomain to check against
+ *
+ * Checks link permissions for all possible name combinations.  This is
+ * particularly ugly.  Returns 0 on sucess, error otherwise.
+ */
+int sd_link(struct dentry *link, struct dentry *target, struct subdomain *sd)
+{
+	char *iname, *oname;
+	struct sd_path_data idata, odata;
+	int error = 0, sdpath_error, done;
+
+	if (!__sd_is_confined(sd))
+	       goto out;
+
+	/* Perform nested lookup for names.
+	 * This is necessary in the case where /dev/block is mounted 
+	 * multiple times,  i.e /dev/block->/a and /dev/block->/b
+	 * This allows us to detect links where src/dest are on different 
+	 * mounts.   N.B no support yet for links across bind mounts of
+	 * the form mount -bind /mnt/subpath /mnt2
+	 */
+
+	done=0;
+	sd_path_begin2(target, link, &odata);
+	do{
+		oname = sd_path_getname(&odata);
+
+		if (oname){
+			sd_path_begin(target, &idata);
+			do{
+				iname = sd_path_getname(&idata);
+				if (iname){
+					error = sd_link_perm(oname, iname, sd); 
+					sd_put_name(iname);
+				
+					/* access via any path is enough */
+					if (!error){
+						done=1;
+					}
+				}
+			}while(!done && iname);
+
+			if ((sdpath_error = sd_path_end(&idata)) != 0){
+				SD_ERROR("%s: An error occured while translating inner dentry %p inode %lu to a pathname. Error %d\n",
+					__FUNCTION__,
+					target,
+					target->d_inode->i_ino,
+					sdpath_error);
+
+				(void)sd_path_end(&odata);
+				error = sdpath_error;
+				goto out;
+			}
+			sd_put_name(oname);
+
+		} // name
+
+	}while(!done && oname);
+
+	if ((sdpath_error = sd_path_end(&odata)) != 0){
+		SD_ERROR("%s: An error occured while translating outer dentry %p inode %lu to a pathname. Error %d\n",
+			__FUNCTION__,
+			link,
+			link->d_inode->i_ino,
+			sdpath_error);
+
+		error = sdpath_error;
+	}
+
+out:
+	return error;
+}
+
+/**
+ * sd_symlink - symlink check
+ * @link: dentry for link being created
+ * @name: name of target
+ * @sd: SubDomain to check against
+ *
+ * This resolves the pathname for the target (and will fail if at least
+ * the parent dir (`dirname name`) of the target doesn't exist.  Then it
+ * cycles through all possible names for @link and checks link
+ * permissions.  Returns 0 on success, error otherwise.
+ */
+int sd_symlink(struct dentry *link, const char *name, struct subdomain *sd)
+{
+	struct nameidata nd;
+	struct dentry *target = NULL;
+	char *lname, *tname;
+	int error=0, sdpath_error;
+	struct sd_path_data data;
+
+
+	if (!__sd_is_confined(sd))
+	       goto out;
+
+	if (*name == '/')
+		error = path_lookup(name, LOOKUP_PARENT, &nd);
+	else {
+		/* XXX need to resolve pathname relative to link
+		 * this is ugly because we have the link dentry
+		 * but not the link vfsmount.  for now we assume flat
+		 * namespace.  code stolen from path_init.
+		 */
+		nd.last_type = LAST_ROOT; /* if there are only slashes... */
+		nd.flags = LOOKUP_PARENT;
+		nd.dentry = dget(link->d_parent); /* relative to link parent */
+		nd.mnt = find_mnt(link); /* only finds the first mnt match */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,8)
+		nd.depth = 0;
+#endif
+		error = path_walk(name, &nd);
+	}
+	if (error)
+		goto out;
+
+	target = lookup_hash(&nd.last, nd.dentry);
+	if (IS_ERR(target)) {
+		error = PTR_ERR(target);
+		goto out_release;
+	}
+
+	error = -ENOMEM;
+
+	tname = __sd_get_name(target, nd.mnt);
+	if (!tname)
+		goto out_dput;
+
+
+	/* search all paths to dentry */
+
+	sd_path_begin(link, &data);
+	do{
+		lname = sd_path_getname(&data);
+		if (lname){
+			error = sd_link_perm(lname, tname, sd);
+			sd_put_name(lname);
+			
+			/* access via any path is enough */
+			if (!error)
+				break;
+		}
+
+	}while (lname);
+	
+	if ((sdpath_error = sd_path_end(&data)) != 0){
+		SD_ERROR("%s: An error occured while translating dentry %p inode# %lu to a pathname. Error %d\n",
+			 __FUNCTION__,
+			link,
+			link->d_inode->i_ino,
+			sdpath_error);
+
+		error = sdpath_error;
+	}
+
+	sd_put_name(tname);
+
+out_dput:
+	dput(target);
+
+out_release:
+	path_release(&nd);
+
+out:
+	return error;
+	
+}
+
+
+/**********************************
+ * GLOBAL PROCESS RELATED FUNCTIONS
+ *********************************/
+
+/**
+ * sd_fork - create a new subdomain
+ * @p: new process
+ *
+ * Create a new subdomain struct for the newly created process @p.
+ * Copy parent info to child.  If parent has no subdomain, child
+ * will get one with NULL values.  Return 0 on sucess.
+ */
+
+int sd_fork(struct task_struct *p)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(current->security);
+	struct subdomain *newsd = alloc_subdomain(p);
+
+	SD_DEBUG("%s\n", __FUNCTION__);
+
+	if (!newsd)
+		return -ENOMEM;
+
+	if (sd) {
+		/* Can get away with a read rather than write lock here
+		 * as we just allocated newsd above, so we can guarantee 
+		 * that it's active/profile are null and therefore a replace
+		 * cannot happen.
+		 */
+		SD_RLOCK;
+		newsd->profile = get_sdprofile(sd->profile);
+		newsd->active = get_sdprofile(sd->active);
+		newsd->sd_hat_magic = sd->sd_hat_magic;
+
+		if (SUBDOMAIN_COMPLAIN(sd) && newsd->profile && newsd->active) {
+			SD_WARN("LOGPROF-HINT fork pid=%d child=%d profile=%s active=%s\n",
+				current->pid, p->pid, newsd->profile->name, newsd->active->name);
+		}
+
+		SD_RUNLOCK;
+	}
+	p->security = newsd;
+	return 0;
+}
+
+/**
+ * sd_register - register a new program
+ * @filp: file of program being registered
+ *
+ * Try to register a new program during execve().  This should give the
+ * new program a valid SubDomain.
+ *
+ * This _used_ to be a really simple piece of code :-(
+ *
+ */
+int sd_register(struct file *filp)
+{
+	char *filename;
+	struct subdomain *sd, sdcopy;
+	struct sdprofile *newprofile = NULL,
+			 unconstrained_flag;
+	int 	error = -ENOMEM,
+		findprofile=0,
+		findprofile_mandatory=0,
+		issdcopy=1,
+		complain=0;
+
+	SD_DEBUG("%s\n", __FUNCTION__);
+
+	sd=get_sdcopy(&sdcopy);
+
+	/* Must have a SubDomain:
+	 * XXX  tony 10/2003
+	 * XXX  How is it possible to get here without a Subdomain?
+	 */
+	if (sd) {
+		complain=SUBDOMAIN_COMPLAIN(sd);
+	}else{
+		issdcopy=0;
+
+		sd = alloc_subdomain(current);
+		if (!sd){
+			SD_WARN("%s: Failed to allocate SubDomain\n", 
+				__FUNCTION__);
+			goto out;
+		}
+
+		current->security = sd;
+	}
+
+	filename = __sd_get_name(filp->f_dentry, filp->f_vfsmnt);
+	if (!filename){
+		SD_WARN("%s: Failed to get filename\n", 
+			__FUNCTION__);
+		goto out;
+	}
+
+	error = 0;
+
+	/* determine what mode inherit, unconstrained or mandatory
+	 * an image is to be loaded in
+	 */
+	if (__sd_is_confined(sd)){
+		int exec_mode=0;
+
+		if (sd_get_execmode(filename, sd, &exec_mode)){
+			switch (exec_mode){
+				case KERN_COD_EXEC_INHERIT:
+					/* do nothing - setting of profile
+					 * already handed in sd_fork
+					 */
+					SD_DEBUG("%s: INHERIT %s\n", 
+						__FUNCTION__,
+						filename);
+					break;
+
+				case KERN_COD_EXEC_UNCONSTRAINED:
+					SD_DEBUG("%s: UNCONSTRAINED %s\n", 
+						 __FUNCTION__,
+						filename);
+
+					/* unload profile */
+					newprofile=&unconstrained_flag;
+					break;
+
+				case KERN_COD_EXEC_PROFILE:
+					SD_DEBUG("%s: PROFILE %s\n", 
+						 __FUNCTION__,
+						filename);
+
+					findprofile=1;
+					findprofile_mandatory=1;
+					break;
+					
+				case KERN_COD_MAY_EXEC:
+					/* this should not happen, entries
+					 * with just EXEC only should be 
+					 * rejected at profile load time
+					 */
+					SD_ERROR("%s: Rejecting exec(2) of image '%s'. Mode KERN_COD_MAY_EXEC without exec qualifier is invalid (internal error) (%s(%d) profile %s active %s\n", 
+						__FUNCTION__,
+						filename,
+						current->comm, current->pid,
+						sd->profile->name, sd->active->name);
+					error=-EPERM;
+					break;
+
+				default:
+					SD_ERROR("%s: Rejecting exec(2) of image '%s'. Unknown exec qualifier %x (internal error) (%s (pid %d) profile %s active %s)\n", 
+						__FUNCTION__,
+						filename,
+						exec_mode,
+						current->comm, current->pid,
+						sd->profile->name, sd->active->name);
+					error=-EPERM;
+					break;
+			}
+
+
+		}else{ /* !sd_get_execmode(filename, sd, &exec_mode) */
+
+			if (complain) {
+				/* There was no entry in calling profile 
+				 * describing mode to execute image in.
+				 * Drop into null-profile
+				 */
+				newprofile=get_sdprofile(null_complain_profile);
+			} else {
+				SD_WARN("%s: Rejecting exec(2) of image '%s', Unable to determine exec qualifier (%s (pid %d) profile %s active %s)\n", 
+					__FUNCTION__,
+					filename,
+					current->comm, current->pid,
+					sd->profile->name, sd->active->name);
+				error = -EPERM;
+			}
+		}
+
+	}else{ /* __sd_is_confined(sd) */
+
+		/* unconfined task, load profile if it exists */
+		findprofile=1;
+	}
+
+
+
+	/* mode has been determined,  try to locate profile if necessary */
+
+find_profile:
+
+	if (findprofile){
+		newprofile = sd_profilelist_find(filename);
+		if (newprofile) {
+			SD_DEBUG("%s: setting profile %s\n", 
+				 __FUNCTION__, newprofile->name);
+		}else if (findprofile_mandatory){
+			/* Profile (mandatory) could not be found */
+
+			if (complain) {
+				SD_WARN("LOGPROF-HINT missing_mandatory_profile image=%s pid=%d profile=%s active=%s\n",
+				    filename,
+				    current->pid,
+				    sd->profile->name, 
+				    sd->active->name);
+
+				newprofile=get_sdprofile(null_complain_profile);
+			}else{
+				SD_WARN("REJECTING exec(2) of image '%s', Profile mandatory (exec qualifier 'p' specified) and not found (%s(%d) profile %s active %s)\n",
+					filename,
+					current->comm, current->pid,
+					sd->profile->name, sd->active->name);
+				error = -EPERM;
+			}
+		}else{	
+			/* Profile (non-mandatory) could not be found */
+
+			/* Only way we can get into this code is if task
+			 * is unconstrained.
+			 */
+
+			BUG_ON(__sd_is_confined(sd));
+
+			SD_DEBUG("%s: No profile found for exec image %s\n", 
+				__FUNCTION__,
+				filename);
+		} /* profile */
+	} /* findprofile */
+
+
+	/* Apply profile if necessary */
+
+	if (newprofile){
+		struct subdomain *latest_sd;
+
+		if (newprofile == &unconstrained_flag){
+			newprofile=NULL;
+		}
+
+		/* grab a write lock
+		 *
+		 * Several things may have changed since the code above
+		 *
+		 * - If we are a confined process, sd is a refcounted copy of 
+		 *   the SubDomain (get_sdcopy) and not the actual SubDomain.
+		 *   This allows us to not have to hold a read lock around
+		 *   all this code.  However, we need to change the actual
+		 *   SubDomain, not the copy.  Also, if profile replacement
+		 *   has taken place, our sd->profile may be inaccurate
+		 *   so we need to undo the copy and reverse the refcounting.
+		 *
+		 * - If newprofile points to an actual profile (result of
+		 *   sd_profilelist_find above), this profile may have been
+		 *   replaced.  We need to fix it up.  Doing this to avoid
+		 *   having to hold a write lock around all this code.
+		 */
+		 
+		SD_WLOCK;
+
+		/* task is guaranteed to have a SubDomain (->security)
+		 * by this point 
+		 */
+		latest_sd = SD_SUBDOMAIN(current->security);
+
+		/* Determine if profile we found earlier is stale.
+		 * If so, reobtain it.  N.B stale flag should never be 
+		 * set on null_complain profile.
+		 */
+		if (newprofile && unlikely(newprofile->isstale)){
+			BUG_ON(newprofile == null_complain_profile);
+
+			/* drop refcnt obtained from earlier get_sdprofile */
+			put_sdprofile(newprofile);
+
+			newprofile = sd_profilelist_find(filename);
+	
+			if (!newprofile){
+				/* Race, profile was removed, not replaced.
+				 * Redo with error checking
+				 */
+				SD_WUNLOCK;
+				goto find_profile;
+			}
+		}
+
+		put_sdprofile(latest_sd->profile);
+		put_sdprofile(latest_sd->active);
+
+		/* need to drop reference counts we obtained in get_sdcopy
+		 * above.  Need to do it before overwriting latest_sd, in 
+		 * case latest_sd == sd (no async replacement has taken place).
+		 */
+		if (issdcopy){
+			put_sdcopy(sd);
+			issdcopy=0;
+		}
+			
+		latest_sd->profile = newprofile; /* already refcounted */
+		latest_sd->active = get_sdprofile(newprofile);
+
+		if (complain) {
+			SD_WARN("LOGPROF-HINT changing_profile pid=%d newprofile=%s\n",
+				current->pid,
+				newprofile ? newprofile->name : SD_UNCONSTRAINED);
+		}
+
+		SD_WUNLOCK;
+	}
+
+	sd_put_name(filename);
+
+	if (issdcopy){
+		put_sdcopy(sd);
+	}
+
+out:
+	return error;
+}
+
+/**
+ * sd_release - release the task's SubDomain
+ * @p: task being released
+ *
+ * This is called after a task has exited and the parent has reaped it.
+ * @p->security blob is freed.
+ */
+void sd_release(struct task_struct *p)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(p->security);
+	if (sd) {
+		p->security = NULL;
+
+		sd_subdomainlist_remove(sd);
+
+		/* release profiles */
+		put_sdprofile(sd->profile);
+		put_sdprofile(sd->active);
+
+		kfree(sd);
+	}
+}
+
+/*****************************
+ * GLOBAL SUBPROFILE FUNCTIONS
+ ****************************/
+
+/**
+ * do_change_hat - actually switch hats
+ * @name: name of hat to swtich to
+ * @sd: current SubDomain
+ *
+ * Switch to a new hat.  Return 0 on success, error otherwise.
+ */
+static inline 
+int do_change_hat(const char *hat_name, struct subdomain *sd)
+{
+	struct sdprofile *sub;
+	struct sdprofile *p = sd->active;
+	int error = 0;
+
+	sub = __sd_find_profile(hat_name, &sd->profile->sub);
+
+	if (sub) {
+		/* change hat */
+		sd->active = sub;
+	} else {
+		/* There is no such subprofile change to a NULL profile.
+		 * The NULL profile grants no file access.
+		 *
+		 * 'null_profile' declared in sysctl.c
+		 *
+		 * This feature is used by changehat_apache.
+		 * 
+		 * N.B from the null-profile the task can still changehat back 
+		 * out to the parent profile (assuming magic != NULL)
+		 */
+		if (SUBDOMAIN_COMPLAIN(sd)) {
+			sd->active = get_sdprofile(null_complain_profile);
+			SD_WARN("LOGPROF-HINT unknown_hat %s pid=%d profile=%s active=%s\n",
+				 hat_name,
+				 current->pid,
+				 sd->profile->name, 
+				 sd->active->name);
+			
+		} else {
+			SD_DEBUG("%s: Unknown hatname '%s'. Changing to NULL profile (%s(%d) profile %s active %s)\n", 
+				 __FUNCTION__,
+				 hat_name,
+				 current->comm, current->pid,
+				 sd->profile->name, sd->active->name);
+
+			sd->active = get_sdprofile(&null_profile);
+			error = -EACCES;
+		}
+	}
+	put_sdprofile(p);
+
+	return error;
+}
+
+
+/**
+ * sd_change_hat - change hat to/from subprofile
+ * @hat_name: specifies hat to change to
+ * @hat_magic: token to validate hat change
+ *
+ * Change to new @hat_name when current hat is top level profile, and store
+ * the @hat_magic in the current SubDomain.  If the new @hat_name is
+ * NULL, and the @hat_magic matches that stored in the current SubDomain
+ * return to original top level profile.  Returns 0 on success, error
+ * otherwise.
+ */
+#define IN_SUBPROFILE(sd)	((sd)->profile != (sd)->active)
+int sd_change_hat(const char *hat_name, __u32 hat_magic)
+{
+	struct subdomain *sd = SD_SUBDOMAIN(current->security);
+	int error = 0;
+
+	SD_DEBUG("%s: %p, 0x%x (pid %d)\n", 
+		__FUNCTION__, 
+		hat_name, hat_magic,
+		current->pid);
+
+	/* Dump out above debugging in WARN mode if we are in AUDIT mode */
+	if (SUBDOMAIN_AUDIT(sd)){
+		SD_WARN("%s: %s, 0x%x (pid %d)\n", 
+			__FUNCTION__, hat_name ? hat_name : "NULL", 
+			hat_magic, current->pid);
+	}
+
+	/* no SubDomains: changehat into the null_profile, since the process
+	   has no SubDomains do_change_hat won't find a match which will cause
+	   a changehat to null_profile.  We could short circuit this but since
+	   the subdprofile (hat) list is empty we would save very little. */
+
+#if 0 	
+	/* This is the old behaviour. Bailing does not result in task being
+	 * put into the null-profile.
+	 */
+	if (!__sd_sub_defined(sd))
+		goto out;
+#endif
+
+	/* check to see if an unconfined process is doing a changehat. */
+	if (!__sd_is_confined(sd)) {
+		error = -EACCES;
+		goto out;
+	}
+
+	/* Check whether current domain is parent or one of the sibling children */
+	if (sd->profile == sd->active) {
+		/* 
+		 * parent 
+		 */
+		if (hat_name) {
+			SD_DEBUG("%s: switching to %s, 0x%x\n", 
+				__FUNCTION__, 
+				hat_name,
+				hat_magic);
+
+			/*
+			 * N.B hat_magic == 0 has a special meaning
+			 * this indicates that the task may never changehat
+			 * back to it's parent, it will stay in this subhat
+			 * (or null-profile, if the hat doesn't exist) until
+			 * the task terminates
+			 */
+			sd->sd_hat_magic = hat_magic;
+			error = do_change_hat(hat_name, sd);
+		} else {
+			/* Got here via changehat(NULL, magic)
+			 *
+			 * We used to simply update the magic cookie.
+			 * That's an odd behaviour, so just do nothing.
+			 */
+		}
+	} else {
+		/* 
+		 * child -- check to make sure magic is same as what was 
+		 * passed when we switched into this profile,
+		 * Handle special casing of NULL magic which confines task
+		 * to subprofile and prohibits further changehats
+		 */
+		if (hat_magic == sd->sd_hat_magic && sd->sd_hat_magic) {
+			if (!hat_name) {
+				/* 
+				 * Got here via changehat(NULL, magic)
+			 	 * Return from subprofile, back to parent  
+				 */
+				put_sdprofile(sd->active);
+				sd->active = get_sdprofile(sd->profile);
+
+				/* Reset hat_magic to zero.
+				 * New value will be passed on next changehat
+				 */
+				sd->sd_hat_magic = 0;
+			} else {
+				/* change to another (sibling) profile */
+				error = do_change_hat(hat_name, sd);
+			}
+		} else if (sd->sd_hat_magic){ /* hat_magic != sd->sd_hat_magic */
+		    SD_ERROR("KILLING process %s(%d) Invalid change_hat() magic# 0x%x (hatname %s profile %s active %s)\n", 
+			     current->comm, current->pid,
+			     hat_magic,
+			     hat_name ? hat_name : "NULL", 
+			     sd->profile->name, sd->active->name);
+
+		    /* terminate current process */
+		    (void)send_sig_info(SIGKILL, NULL, current);
+		}else{ /* sd->sd_hat_magic == NULL */
+		    SD_ERROR("KILLING process %s(%d) Task was confined to current subprofile (profile %s active %s)\n", 
+			     current->comm, current->pid,
+			     sd->profile->name, sd->active->name);
+		    
+		    /* terminate current process */
+		    (void)send_sig_info(SIGKILL, NULL, current);
+		}
+
+	}
+
+ out:
+	return error;
+}
diff -uNrp linux-2.6.11/security/subdomain/module_interface.c linux-2.6.11.subd-new/security/subdomain/module_interface.c
--- linux-2.6.11/security/subdomain/module_interface.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/module_interface.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,968 @@
+/* Codes of the types of basic structures that are understood */
+#define SD_CODE_SIZE (sizeof(__u8))
+#define SD_STR_LEN (sizeof(__u16))
+#define MATCHENTRY(A,B) (strcmp(A->filename,B->filename)==0)
+#define INTERFACE_ID "INTERFACE"
+
+#define SUBDOMAIN_INTERFACE_VERSION 2
+
+enum sd_code
+{
+	SD_U8,
+	SD_U16,
+	SD_U32,
+	SD_U64,
+	SD_NAME,		/* same as string except it is items name */
+	SD_STRING,
+	SD_BLOB,
+	SD_STRUCT,
+	SD_STRUCTEND,
+	SD_LIST,
+	SD_LISTEND,
+	SD_OFFSET,
+	SD_BAD};
+
+const char *sd_code_names[] = { "SD_U8",
+				"SD_U16",
+				"SD_U32",
+				"SD_U64",
+				"SD_NAME",
+				"SD_STRING",
+				"SD_BLOB",
+				"SD_STRUCT",
+				"SD_STRUCTEND",
+				"SD_LIST",
+				"SD_LISTEND",
+				"SD_OFFSET"};
+
+typedef struct {
+	void *start;
+	void *end;
+	u32  version;
+} sd_ext;
+
+static inline int
+sd_inbounds (void *p, sd_ext *e, int size)
+{
+	return (p+size <= e->end);
+}
+
+static inline void *
+sd_inc(void *p, sd_ext *e, int size)
+{
+	if (sd_inbounds(p, e, size))
+		return p+size;
+	SD_DEBUG("%s: requested inc of %d bytes out of bounds (start %p, extent %p, pos %p\n", INTERFACE_ID, size, e->start, e->end, p);
+	return 0;
+}
+
+static inline void *
+sd_is_X (void *p, sd_ext *e, enum sd_code code, int required)
+{
+	__u8 *b = (__u8 *) p;
+	__u8 conv;
+	if (sd_inbounds(p, e, SD_CODE_SIZE)) {
+		conv = *b;
+		if ((conv == code))
+			return sd_inc(p, e, SD_CODE_SIZE);
+		if (required)
+			SD_DEBUG("%s: type code incorrect @%d, got %s(%d) expected %s(%d)\n", INTERFACE_ID, (int) (p-e->start), conv<SD_BAD ? sd_code_names[conv] : "unknown", conv, sd_code_names[code], code);
+
+	}
+	return 0;
+}
+
+static inline void *
+sd_read8 (void *p, sd_ext *e, __u8 *b)
+{
+	__u8 *c = (__u8 *) p;
+	if (!sd_inbounds(p, e, 1)) return 0;
+	*b = *c;
+	return sd_inc(p, e, 1);
+}
+
+static inline void *
+sd_read16 (void *p, sd_ext *e, __u16 *b)
+{
+	__u16 *c = (__u16 *) p;
+	if (!sd_inbounds(p, e, 2)) return 0;
+	*b = le16_to_cpu(*c);
+	return sd_inc(p, e, 2);
+}
+
+static inline void *
+sd_read32 (void *p, sd_ext *e, __u32 *b)
+{
+	__u32 *c = (__u32 *) p;
+	if (!sd_inbounds(p, e, 4)) return 0;
+	*b = le32_to_cpu(*c);
+	return sd_inc(p, e, 4);
+}
+
+void *
+sd_match_name (void *p, sd_ext *e, char *name, int required)
+{
+	void *c;
+	__u16 size;
+	char *str;
+	char *message=NULL;
+
+	if (!(c = sd_is_X(p, e, SD_NAME, (name!=NULL)*required))) {
+		if (name) {
+			message = "missing required tag name";
+			goto fail;
+		}
+		/* no name trivially matches no name entry */
+		return p;
+	}
+	if (!(c = sd_read16(c, e, &size))) {
+		message = "unable to read tag name size";
+		goto fail;
+	}
+	if (!sd_inbounds(c, e, size)) {
+		message = "tag name size out of bounds";
+		goto fail;
+	}
+	str = (char *) c;
+
+	/* null name matches any */
+	if ((name && strncmp(name, str, size) == 0) ||
+            (name == 0))
+		return sd_inc(c, e, size);
+	
+ fail:
+	if (required)
+		SD_DEBUG("%s: %s, expected %s\n", INTERFACE_ID, message, name);
+	return 0;
+}
+
+void *
+sd_is_X_name (void *p, sd_ext *e, enum sd_code code, char *name, int required)
+{
+	void *c=p;
+
+	if ((c = sd_match_name(c, e, name, required)) &&
+	    (c = sd_is_X(c, e, code, required))) {
+		return c;
+	}
+	if (required && !c && name) 
+		SD_DEBUG("%s: bad type for tag %s\n", INTERFACE_ID, name);
+	return 0;
+}
+
+/* len includes terminating 0 */
+void *
+sd_is_string (void *p, sd_ext *e, char *name, __u32 *len)
+{
+	void *c;
+	__u16 size;
+	if (!(c = sd_is_X_name(p, e, SD_STRING, name, name!=NULL))) goto fail;
+	if (!sd_inbounds(c, e, 2) || !(c = sd_read16(c, e, &size))) goto fail;
+	if (!sd_inbounds(c, e, size)) goto fail;
+	*len = size;
+	return c;
+ fail:
+	return 0;
+}
+
+void *
+sd_is_blob (void *p, sd_ext *e, char *name, __u32 *len)
+{
+	void *c;
+	__u32 size;
+	if (!(c = sd_is_X_name(p, e, SD_BLOB, name, name!=NULL))) goto fail;
+	if (!sd_inbounds(c, e, 4) || !(c = sd_read32(c, e, &size))) goto fail;
+	if (!sd_inbounds(c, e, size)) goto fail;
+	*len = size;
+	return c;
+ fail:
+	*len = 0;
+	return 0;
+}
+
+static inline void *
+sd_read8_t (void *p, sd_ext *e, __u8 *b, char *name)
+{
+	void *c;
+	if (!(c = sd_is_X_name(p, e, SD_U8, NULL, 1))) goto fail;
+	if (!(c = sd_read8(c, e, b))) goto fail;
+	return c;
+
+ fail:
+	SD_DEBUG("%s: could not read 8 bit element %s\n", INTERFACE_ID, name);
+	return 0;
+}
+
+static inline void *
+sd_read16_t (void *p, sd_ext *e, __u16 *b, char *name)
+{
+	void *c;
+	if (!(c = sd_is_X_name(p, e, SD_U16, NULL, 1))) goto fail;
+	if (!(c = sd_read16(c, e, b))) goto fail;
+	return c;
+ fail:
+	SD_DEBUG("%s: could not read 16 bit element %s\n", INTERFACE_ID, name);
+	return 0;
+}
+
+static inline void *
+sd_read32_t (void *p, sd_ext *e, __u32 *b, char *name)
+{
+	void *c;
+	if (!(c = sd_is_X_name(p, e, SD_U32, NULL, 1))) goto fail;
+	if (!(c = sd_read32(c, e, b))) goto fail;
+	return c;
+ fail:
+	SD_DEBUG("%s: could not read 32 bit element %s\n", INTERFACE_ID, name);
+	return 0;
+}
+
+void *
+sd_read_blob (void *p, sd_ext *e, char *name, void *buf, int size)
+{
+	__u32 len;
+	void *c;
+	if ((c = sd_is_blob (p, e, name, &len)) &&
+	    len <= size) {
+		memcpy(buf, c, len);
+		return sd_inc(c, e, len);
+	}
+	return 0;
+}
+
+inline void *
+sd_read_structhead(void *p, sd_ext *e, char *name)
+{
+	return sd_is_X_name(p, e, SD_STRUCT, name, name!=NULL);
+}
+
+inline void *
+sd_read_structend(void *p, sd_ext *e)
+{
+	return sd_is_X(p, e, SD_STRUCTEND, 1);
+}
+
+inline void *
+sd_read_listhead(void *p, sd_ext *e, char *name)
+{
+	return sd_is_X_name(p, e, SD_LIST, name, name!=NULL);
+}
+
+inline void *
+sd_read_listend(void *p, sd_ext *e)
+{
+	return sd_is_X(p, e, SD_LISTEND, 1);
+}
+
+/* use in place of get_name, still use put name */
+void *
+sd_get_string(void *p, sd_ext *e, int maxsize, char *name, char **string)
+{
+	void *c;
+	char *str;
+	__u32 len;
+
+	if (!(c = sd_is_string(p, e, name, &len))) goto fail;
+	if (len > maxsize) goto fail;
+
+	str = (char *) kmalloc(len, GFP_KERNEL);
+	if (!str) goto fail;
+	memcpy(str, c, len);
+	str[len-1] = 0;		/* force expect 0 termination */
+
+	*string = str;
+	return sd_inc(c, e, len);
+
+ fail:
+	return 0;
+}
+
+static inline void *
+sd_activate_net_entry(void *p, sd_ext *e, struct nd_entry **r_entry)
+{
+	char *iface = NULL;
+	struct nd_entry *entry = NULL;
+
+	void *c = p;
+
+	__u32 p_saddr, p_smask, p_daddr, p_dmask;
+  
+	ND_DEBUG("%s: BEGIN\n", 
+		 __FUNCTION__);
+
+	if (!(entry = alloc_nd_entry())) goto out;
+
+	if (!(c = sd_read_structhead(c, e, "ne"))) goto out;
+
+	/* values in entry are zeroed by alloc_nd_entry 
+	 * N.B for in_addr values, 0 == INADDR_ANY 
+	 * */
+
+	if (!(c = sd_read32_t(c, e, &(entry->mode), "net.mode"))) goto out;
+
+	ND_DEBUG ("%s: mode: %x\n", 
+		  __FUNCTION__,
+		  entry->mode);
+
+	/* N.B
+	 * The parser and the kernel have an opposite view of
+	 * addresses.
+	 * 
+	 * As far as we (the kernel) are concerned:
+	 * "tcp_accept from"  specifies a remote address (daddr)
+	 * "tcp_connect from" specifies a local address (saddr)
+	 * And so on (inversely) for "to"
+	 *
+	 * The parser considers <from> to always be a source
+	 * and <to> to always specify a remote regardless of
+	 * the mode (accept, connect etc)
+	 *
+	 * We'll switch them around here
+	 */
+	if (entry->mode == KERN_COD_TCP_CONNECT ||
+	    entry->mode == KERN_COD_TCP_CONNECTED ||
+	    entry->mode == KERN_COD_UDP_SEND){
+		if (!(c = sd_read32_t(c, e, &p_saddr, "net.p_saddr"))) goto out;
+		if (!(c = sd_read32_t(c, e, &p_smask, "net.p_smask"))) goto out;
+		if (!(c = sd_read16_t(c, e, &entry->src_port[0], "net.src_port[0]"))) goto out;
+		if (!(c = sd_read16_t(c, e, &entry->src_port[1], "net.src_port[1]"))) goto out;
+		if (!(c = sd_read32_t(c, e, &p_daddr, "net.p_daddr"))) goto out;
+		if (!(c = sd_read32_t(c, e, &p_dmask, "net.p_dmask"))) goto out;
+		if (!(c = sd_read16_t(c, e, &entry->dst_port[0], "net.dst_port[0]"))) goto out;
+		if (!(c = sd_read16_t(c, e, &entry->dst_port[1], "net.dst_port[1]"))) goto out;
+	}else if (entry->mode == KERN_COD_TCP_ACCEPT ||
+		  entry->mode == KERN_COD_TCP_ACCEPTED ||
+		  entry->mode == KERN_COD_UDP_RECEIVE) {
+		if (!(c = sd_read32_t(c, e, &p_daddr, "net.p_daddr"))) goto out;
+		if (!(c = sd_read32_t(c, e, &p_dmask, "net.p_dmask"))) goto out;
+		if (!(c = sd_read16_t(c, e, &entry->dst_port[0], "net.dst_port[0]"))) goto out;
+		if (!(c = sd_read16_t(c, e, &entry->dst_port[1], "net.dst_port[1]"))) goto out;
+		if (!(c = sd_read32_t(c, e, &p_saddr, "net.p_saddr"))) goto out;
+		if (!(c = sd_read32_t(c, e, &p_smask, "net.p_smask"))) goto out;
+		if (!(c = sd_read16_t(c, e, &entry->src_port[0], "net.src_port[0]"))) goto out;
+		if (!(c = sd_read16_t(c, e, &entry->src_port[1], "net.src_port[1]"))) goto out;
+	}else{
+		ND_DEBUG("%s: INVALID mode %x\n", 
+			__FUNCTION__,
+			entry->mode);
+		goto out;
+	}
+	if (p_saddr) {
+		entry->saddr = p_saddr;
+		ND_DEBUG ("%s: saddr: %u.%u.%u.%u\n", 
+			  __FUNCTION__, NIPQUAD(entry->saddr));
+	} 
+	if (p_smask) {
+		entry->smask = p_smask;
+		ND_DEBUG ("%s: smask: %u.%u.%u.%u\n", 
+			  __FUNCTION__, NIPQUAD(entry->smask));
+	} 
+	if (p_daddr) { 
+		entry->daddr = p_daddr;
+		ND_DEBUG ("%s: daddr: %u.%u.%u.%u\n", 
+			  __FUNCTION__, NIPQUAD(entry->daddr));
+	} 
+	if (p_dmask) {
+		entry->dmask = p_dmask;
+		ND_DEBUG ("%s: dmask: %u.%u.%u.%u\n", 
+	      __FUNCTION__, NIPQUAD(entry->dmask));
+	}
+	
+	
+	ND_DEBUG ("%s: sport: %u - %u  dport: %u - %u\n",
+		  __FUNCTION__, 
+		  entry->src_port[0], entry->src_port[1],
+		  entry->dst_port[0], entry->dst_port[1]);
+	
+	if (sd_is_X(c, e, SD_STRING, 0)) {
+		if (!(c = sd_get_string(c, e, IFNAMSIZ, NULL, &iface))) goto out;
+		entry->iface = iface;
+	}
+	
+	if (!(c = sd_read_structend(c, e))) goto out;
+	
+	ND_DEBUG ("%s: iface: %s\n", 
+		  __FUNCTION__,
+		  entry->iface ? entry->iface : "NULL");
+	
+	ND_DEBUG ("%s: EBD 0x%p\n", 
+		  __FUNCTION__,
+		  entry);
+	
+	*r_entry = entry;
+	return c;
+	
+ out:
+	put_iface(iface);
+	free_nd_entry(entry);
+	
+	*r_entry = NULL;
+	return 0;
+}
+
+/* use in place of get_pattern */
+static inline void *
+sd_activate_pattern(void *p, sd_ext *e, pcre **r_pcre)
+{
+	pcre *pattern_k = NULL;
+	__u32 size, magic, opts;
+	__u8 t_char;
+	void *c = p;
+	/* size determines the real size of the pcre struct,
+	   it is size_t - sizeof(pcre) on user side.
+	   uschar must be the same in user and kernel space */
+	/* check that we are processing the correct structure */
+	if (!(c = sd_read_structhead(c, e, "pcre"))) goto out;
+	if (!(c = sd_read32_t(c, e, &size, "pattern.size"))) goto out;
+	if (!(c = sd_read32_t(c, e, &magic, "pattern.magic"))) goto out;
+	if (!(pattern_k = (pcre *) kmalloc(size+sizeof(pcre), GFP_KERNEL))) goto out;
+	memset(pattern_k, 0, size+sizeof(pcre));
+
+	pattern_k->magic_number = magic;
+	pattern_k->size = size+sizeof(pcre);
+	if (!(c = sd_read32_t(c, e, &opts, "pattern.options"))) goto out;
+	pattern_k->options = opts;
+	if (!(c = sd_read16_t(c, e, &pattern_k->top_bracket, "pattern.top_bracket"))) goto out;
+	if (!(c = sd_read16_t(c, e, &pattern_k->top_backref, "pattern.top_backref"))) goto out;
+	if (!(c = sd_read8_t(c, e, &t_char, "pattern.fist_char"))) goto out;
+	pattern_k->first_char = t_char;
+	if (!(c = sd_read8_t(c, e, &t_char, "pattern.req_char"))) goto out;
+	pattern_k->req_char = t_char;
+	if (!(c = sd_read8_t(c, e, &t_char, "pattern.code[0]"))) goto out;
+	pattern_k->code[0] = t_char;
+	if (!(c = sd_read_blob(c, e, NULL, &pattern_k->code[1], size))) goto out;
+	
+	if (!(c = sd_read_structend(c, e))) goto out;
+	
+	/* stitch in pcre patterns, it was NULLed out by parser */
+	// pcre_default_tables defined in pcre_tables.h */
+	pattern_k->tables=pcre_default_tables;
+	
+	*r_pcre = pattern_k;
+	return c;
+	
+ out:
+	put_pattern(pattern_k);
+	*r_pcre = NULL;
+	return 0;
+}
+
+static inline void *
+sd_activate_file_entry(void *p, sd_ext *e, struct sd_entry **r_entry)
+{
+	char *name = NULL,
+	     *regex = NULL;
+	pcre *compiled = NULL;
+	struct sd_entry *entry = NULL;
+	void *c = p;
+
+	if (!(entry = alloc_sd_entry())) goto out;
+	/* check that we have the right struct being processed */
+	if (!(c = sd_read_structhead(c, e, "fe"))) goto out;
+
+	/* get the name */
+	if (!(c = sd_get_string(c, e, PATH_MAX, NULL, &name))) goto out;
+	entry->filename = name;
+
+	/* get the mode */
+	if (!(c = sd_read32_t(c, e, &entry->mode, "file.mode"))) goto out;
+
+	/* get the pattern type */
+	if (!(c = sd_read32_t(c, e, &entry->pattern_type, "file.pattern_type"))) goto out;
+
+	entry->regex = NULL;
+	entry->compiled = NULL;
+
+	if (entry->pattern_type == ePatternRegex) {
+		/* get PCRE pattern if regexp */
+		if (!(c = sd_get_string(c, e, PATH_MAX, NULL, &regex))) goto out;
+		entry->regex = regex;
+		if (!(c = sd_activate_pattern(c, e, &compiled))) goto out;
+		entry->compiled = compiled;
+	}
+	
+	if (!(c = sd_read_structend(c, e))) goto out;
+
+	switch (entry->pattern_type) {
+	case ePatternBasic:
+		SD_DEBUG("%s: %s [no pattern] mode=0x%x\n", 
+			 __FUNCTION__,
+			 entry->filename,
+			 entry->mode);
+		break;
+	case ePatternTailGlob:
+		SD_DEBUG("%s: %s [tailglob] mode=0x%x\n", 
+			 __FUNCTION__,
+			 entry->filename,
+			 entry->mode);
+		break;
+	case ePatternRegex:
+		SD_DEBUG("%s: %s regex='%s' pattern_length=%d mode=0x%x\n", 
+			 __FUNCTION__,
+			 entry->filename,
+			 entry->regex,
+			 (unsigned int) entry->compiled->size,
+			 entry->mode);
+		break;
+	default:
+		SD_WARN("%s: INVALID pattern_type %d\n", 
+			__FUNCTION__,
+			(int)entry->pattern_type);
+		goto out;
+	}
+	*r_entry = entry;
+	return c;
+ 
+ out:
+	free_sd_entry(entry);
+	put_name(name);
+	put_name(regex);
+	put_pattern(compiled);
+	*r_entry = NULL;
+	return 0;
+}
+
+static inline int
+check_rule_and_add(struct sd_entry *file_entry, struct sdprofile *profile,
+		   char **message)
+{
+	/* verify consistency of x, px, ix, ux for entry against
+	   possible duplicates for this entry */
+	int mode = SD_EXEC_MODIFIER_MASK(file_entry->mode);
+	//struct sd_entry *lentry;
+	int i;
+
+	if (mode && !(KERN_COD_MAY_EXEC & file_entry->mode)) {
+		*message = "inconsistent rule, x modifiers without x";
+		goto out;
+	}
+			
+	/* check that only 1 of the modifiers is set */
+	if (mode && (mode & (mode-1))) {
+		*message = "inconsistent rule, multiple x modifiers";
+		goto out;
+	}
+			
+	file_entry->next = profile->file_entry;
+	profile->file_entry = file_entry;
+	mode = file_entry->mode;
+
+	/* 
+	 * Handle partitioned lists
+	 * Chain entries onto sublists based on individual 
+	 * permission bits. This allows more rapid searching.
+	 */
+	for (i=0; i<=POS_KERN_COD_FILE_MAX; i++){
+		if (mode & (1<<i)){
+			/* profile->file_entryp[i] initially set to
+			 * NULL in alloc_sdprofile() */
+			file_entry->nextp[i]=profile->file_entryp[i];
+			profile->file_entryp[i]=file_entry;
+		}
+	}
+
+	return 1;
+
+ out:
+	put_sd_entry(file_entry);
+	return 0;
+}
+
+static inline int
+check_netrule_and_add(struct nd_entry *net_entry, struct sdprofile *profile,
+		      char **message)
+{
+	int i;
+	
+	net_entry->next = profile->net_entry;
+	profile->net_entry = net_entry;
+	
+	/* 
+	 * Handle partitioned lists
+	 * Chain entries onto sublists based on individual 
+	 * permission bits. This allows more rapid searching.
+	 */
+	for (i=POS_KERN_COD_NET_MIN; i<=POS_KERN_COD_NET_MAX; i++){
+		int j;
+		j=NET_POS_TO_INDEX(i);
+		
+		if (net_entry->mode & (1<<i)){
+			/* profile->net_entryp[i] initially set to
+			 * NULL in alloc_sdprofile() */
+			net_entry->nextp[j]=profile->net_entryp[j];
+			profile->net_entryp[j]=net_entry;
+		}
+	}
+
+	/* currently no failure case */
+	return 1;
+}
+
+void *
+sd_activate_profile(void *p, sd_ext *e, struct sdprofile *parent,
+		    struct sdprofile **r_profile, ssize_t *error)
+{
+	struct sdprofile *profile = NULL, *subprofile = NULL;
+	char *name = NULL;
+	char *rulename = "";
+	int count = 0;
+	char *error_string = "Invalid Profile";
+	void *c = p;
+
+	*error = -EPROTO;
+
+	profile = alloc_sdprofile();
+	if (!profile) {
+		error_string = "Could not allocate profile";
+		*error = -ENOMEM;
+		goto out;
+	}
+
+	/* check that we have the right struct being passed */
+	if (!(c = sd_read_structhead(c, e, "profile"))) goto out;
+	/* get the profile name, if this is a subprofile, the name
+	   will be that of the subprofile */
+	if (!(c = sd_get_string(c, e, PATH_MAX, NULL, &name))) goto out;
+	profile->name = name;
+
+	SD_DEBUG("%s: %s\n", __FUNCTION__ , name);
+
+	error_string = "Invalid flags";
+	/* per profile debug flags (debug, complain, audit) */
+	if (!(c = sd_read_structhead(c, e, "flags"))) goto out;
+	if (!(c = sd_read32_t(c, e, &(profile->flags.debug), "profile.flags.debug"))) goto out;
+	if (!(c = sd_read32_t(c, e, &(profile->flags.complain), "profile.flags.complain"))) goto out;
+	if (!(c = sd_read32_t(c, e, &(profile->flags.audit), "profile.flags.audit"))) goto out;
+	if (!(c = sd_read_structend(c, e))) goto out;
+
+	error_string = "Invalid capabilities";
+	/* per profile capabilities (are &ed with tasks effective) */
+	if (!(c = sd_read32_t(c, e, &(profile->capabilities), "profile.capabilities"))) goto out;
+
+	/* get the file entries. */  
+	if (sd_is_X_name(c, e, SD_LIST, "pgent", 0)) {
+		rulename = "";
+		error_string = "Invalid pcre file entry";
+		if (!(c = sd_read_listhead(c, e, "pgent"))) goto out;
+		while (!sd_is_X(c, e, SD_LISTEND, 0)) {
+			struct sd_entry *file_entry = NULL;
+			c = sd_activate_file_entry(c, e, &file_entry);
+			if (!file_entry) goto out;
+			if (!check_rule_and_add(file_entry, profile,
+						&error_string)) {
+				rulename = file_entry->filename;
+				goto out;
+			}
+
+	        } /* while */
+		if (!(c = sd_read_listend(c, e))) goto out;
+		count_entries(profile);
+	}
+
+
+	/* get the simple globbing file entries. */  
+	if (sd_is_X_name(c, e, SD_LIST, "sgent", 0)) {
+		rulename = "";
+		error_string = "Invalid tail glob file entry";
+		if (!(c = sd_read_listhead(c, e, "sgent"))) goto out;
+		while (!sd_is_X(c, e, SD_LISTEND, 0)) {
+			struct sd_entry *file_entry = NULL;
+			c = sd_activate_file_entry(c, e, &file_entry);
+			if (!file_entry) goto out;
+			if (!check_rule_and_add(file_entry, profile,
+						&error_string)) {
+				rulename = file_entry->filename;
+				goto out;
+			}
+
+	        } /* while */
+		if (!(c = sd_read_listend(c, e))) goto out;
+		count_entries(profile);
+	}
+
+
+	/* get the basic file entries. */  
+	if (sd_is_X_name(c, e, SD_LIST, "fent", 0)) {
+		rulename = "";
+		error_string = "Invalid file entry";
+		if (!(c = sd_read_listhead(c, e, "fent"))) goto out;
+		while (!sd_is_X(c, e, SD_LISTEND, 0)) {
+			struct sd_entry *file_entry = NULL;
+			c = sd_activate_file_entry(c, e, &file_entry);
+			if (!file_entry) goto out;
+			if (!check_rule_and_add(file_entry, profile,
+						&error_string)) {
+				rulename = file_entry->filename;
+				goto out;
+			}
+
+	        } /* while */
+		if (!(c = sd_read_listend(c, e))) goto out;
+		count_entries(profile);
+	}
+
+	/* get the net entries */
+	if (sd_is_X_name(c, e, SD_LIST, "net", 0)) {
+		rulename = "";
+		error_string = "Invalid net entry";
+		if (!(c = sd_read_listhead(c, e, "net"))) goto out;
+		count = 0;
+		while (!sd_is_X(c, e, SD_LISTEND, 0)) {
+			struct nd_entry *net_entry = NULL;
+			c = sd_activate_net_entry(c, e, &net_entry);
+			if (!net_entry) goto out;
+			count++;
+			if (!parent) {
+				/* No parent profile, allow the net entries */
+				if (!check_netrule_and_add(net_entry, profile,
+							   &error_string)) {
+					goto out;
+				}
+			} else {
+				/* ignore net rules in sub_profiles (hats) */
+				if (count == 1)
+					SD_WARN("%s: Ignoring network entries for subprofile %s^%s. There is currently no kernel Netdomain support for changehat.\n",
+						__FUNCTION__,
+						parent->name, profile->name);
+			}
+		} /* while */
+		if (!(c = sd_read_listend(c, e))) goto out;
+		count_net_entries(profile);
+	}
+	rulename = "";
+
+	/* get subprofiles */
+	if (sd_is_X_name(c, e, SD_LIST, "hats", 0)) {
+		error_string = "Invalid profile hat";
+		if (!(c = sd_read_listhead(c, e, "hats"))) goto out;
+		count = 0;
+		
+		while (!sd_is_X(c, e, SD_LISTEND, 0)) {
+			c = sd_activate_profile(c, e, profile, &subprofile, error);
+			if (!subprofile) goto out;
+			get_sdprofile(subprofile);
+			list_add(&subprofile->list, &profile->sub);
+		} /* while */
+		if (!(c = sd_read_listend(c, e))) goto out;
+	}
+
+	error_string = "Invalid end of profile";
+	if (!(c = sd_read_structend(c, e))) goto out;
+
+	*r_profile = profile;
+	return c;
+	
+ out:
+	if (profile) {
+		free_sdprofile(profile);
+		profile = NULL;
+	}
+
+	*r_profile = NULL;
+	if (name) {
+		SD_WARN("%s: %s %s in profile %s\n", INTERFACE_ID, rulename, error_string, name);
+	} else {
+		SD_WARN("%s: %s\n", INTERFACE_ID, error_string);
+	}
+	return c;
+
+}
+
+void *
+sd_activate_top_profile(void *p, sd_ext *e,
+		    struct sdprofile **r_profile, ssize_t *error)
+{
+	void *c = p;
+	
+	/* get the interface version */
+	if (!(c = sd_read32_t(c, e, &e->version, "version"))) {
+		SD_WARN("%s: version missing\n", INTERFACE_ID);
+		*error = -EPROTONOSUPPORT;
+		*r_profile = NULL;
+		goto out;
+	}
+
+	/* check that the interface version is currently supported*/
+	if (e->version != 2) {
+		SD_WARN("%s: unsupported interface version (%d)\n",
+			INTERFACE_ID, e->version);
+		*error = -EPROTONOSUPPORT;
+		*r_profile = NULL;
+		return 0;
+	}
+
+	c = sd_activate_profile(c, e, NULL, r_profile, error);
+ out:
+	return c;
+}
+
+ssize_t
+sd_file_prof_add(void *data, size_t size)
+{
+	struct sdprofile *profile = NULL, *old_profile = NULL;
+	
+	sd_ext e = {data, data+size};
+	void *c = data;
+	ssize_t error;
+
+	c = sd_activate_top_profile (c, &e, &profile, &error);
+	if (!profile) {
+		SD_DEBUG("could'nt activate profile\n");
+		return error;
+
+	}
+
+	old_profile = sd_profilelist_find(profile->name);
+
+	if (old_profile) {
+		SD_WARN("%s: trying to add profile (%s) that "
+			"already exists.\n", __FUNCTION__, profile->name);
+		put_sdprofile(old_profile);
+		free_sdprofile(profile);
+		return -EEXIST;
+	}
+
+	sd_profilelist_add(profile);
+	/* XXX */
+	return size;
+}       
+
+
+ssize_t
+sd_file_prof_repl (void *udata, size_t size)
+{
+	struct sd_taskreplace_data data;
+	sd_ext e = {udata, udata+size};
+	void *c = udata;
+	ssize_t error;
+
+	sd_activate_top_profile (c, &e, &data.new_profile, &error);	
+	if (!data.new_profile) {
+		SD_DEBUG("could'nt activate profile\n");
+		return error;
+	}
+
+	 
+	// Grab reference to close race window (see comment below)
+	get_sdprofile(data.new_profile);
+
+	/* Replace the profile on the global profile list.
+	 * This list is used by all new exec's to find the correct profile.
+	 * If there was a previous profile, it is returned, else NULL.
+	 *
+	 * N.B sd_profilelist_replace does not drop the refcnt on 
+	 * old_profile when removing it from the global list, otherwise it 
+	 * could reach zero and be automatically free'd. We nust manually 
+	 * drop it at the end of this function when we are finished with it.
+	 */
+	data.old_profile = sd_profilelist_replace(data.new_profile);
+
+
+	/* RACE window here.
+	 * At this point another task could preempt us trying to replace
+	 * the SAME profile. If it makes it to this point,  it has removed
+	 * the original tasks new_profile from the global list and holds a 
+	 * reference of 1 to it in it's old_profile.  If the new task 
+	 * reaches the end of the function it will put old_profile causing 
+	 * the profile to be deleted.
+	 * When the original task is rescheduled it will continue calling
+	 * sd_subdomainlist_iterate relabelling tasks with a profile 
+	 * which points to free'd memory. 
+	 */
+
+
+	/* If there was an old profile,  find all currently executing tasks
+	 * using this profile and replace the old profile with the new.
+	 */
+	if (data.old_profile) {
+		SD_DEBUG("%s: try to replace profile (%p)%s\n", 
+			__FUNCTION__,
+			data.old_profile, 
+			data.old_profile->name);
+
+		sd_subdomainlist_iterate(taskreplace_iter, (void*)&data);
+
+#if defined NETDOMAIN && defined NETDOMAIN_SKUSERS
+		/* Change any sockets (soft intr context) using old profile
+		 * to use new profile
+		 */
+		nd_skusers_exch(data.old_profile, data.new_profile, 0);
+#endif
+
+		/* mark old profile as stale */
+		data.old_profile->isstale=1;
+
+		/* it's off global list, and we are done replacing */
+		put_sdprofile(data.old_profile);
+	} 
+
+	/* Free reference obtained above */
+	put_sdprofile(data.new_profile);
+
+	return size;
+}
+
+
+ssize_t
+sd_file_prof_remove (const char *name, size_t size)
+{
+	struct sdprofile *old_profile;
+
+	/* Do this step to get a guaranteed reference to profile
+	 * as sd_profilelist_remove may drop it to zero which would
+	 * made subsequent attempt to iterate using it unsafe
+	 */
+	old_profile=sd_profilelist_find(name);
+
+	if (old_profile){
+		if (sd_profilelist_remove(name) != 0) {
+			SD_WARN("%s: race trying to remove profile (%s)\n",
+				__FUNCTION__, name) ;
+		}
+
+		/* remove profile from any tasks using it */
+		sd_subdomainlist_iterateremove(taskremove_iter, (void*)old_profile);
+
+#if defined NETDOMAIN && defined NETDOMAIN_SKUSERS
+		/* drop all netdomains using this profile */
+		nd_skusers_exch(old_profile, NULL, 1);
+#endif
+
+		/* drop reference obtained by sd_profilelist_find */
+		put_sdprofile(old_profile);
+	}else{
+		SD_WARN("%s: trying to remove profile (%s) that "
+			"doesn't exist - skipping.\n",
+			__FUNCTION__, name ) ;
+		return -ENOENT;
+	}
+
+	/* XXX */
+	return size;
+}       
+
+
+ssize_t
+sd_file_prof_debug(void *data, size_t size)
+{
+	struct sdprofile *profile = NULL;
+
+	sd_ext e = {data, data+size};
+	void *c = data;
+	ssize_t error;
+
+	c = sd_activate_top_profile (c, &e, &profile, &error);
+	if (!profile) {
+		return error;
+
+	}
+
+	sd_profile_dump(profile);
+	
+	free_sdprofile(profile);
+
+	sd_profilelist_dump();
+	return size;
+
+}       
+
diff -uNrp linux-2.6.11/security/subdomain/module_old_interface.c linux-2.6.11.subd-new/security/subdomain/module_old_interface.c
--- linux-2.6.11/security/subdomain/module_old_interface.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/module_old_interface.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,786 @@
+#ifdef SD_OLD_INTERFACE
+
+/* Routines for the 2.4 kernel sys_security profile interface */
+
+/**
+ * get_name - copy name from user space
+ * @name_u: user space name pointer.
+ * @maxlen: max length of name.
+ */
+static inline char * 
+get_name (char *name_u, int maxlen)
+{
+	char *name = NULL;
+	int len, retval;
+
+	/* strnlen_user() includes \0 in it's value */
+	len = strnlen_user(name_u, maxlen); 
+	if ((len <= 0) || (len > maxlen))
+		return NULL;
+
+	name = (char *)kmalloc(len, GFP_KERNEL);
+	if (!name)
+		return NULL;
+
+	retval = strncpy_from_user(name ,name_u ,len);
+	if (retval != (len - 1)) {
+		kfree(name);
+		return NULL;
+	}
+	return name;
+}       
+
+/**
+ * get_pattern - copy compiled pcre pattern from user space
+ * @name_u: user space name pointer.
+ * @maxlen: max length of name.
+ */
+static inline pcre * 
+get_pattern (pcre *pattern_u)
+{
+pcre tdata, *pattern_k;
+
+	size_t len;
+
+	if (copy_from_user(&tdata, pattern_u, sizeof(pcre))){
+		return NULL;
+	}
+
+	/* actual size of pcre structure */
+	len=tdata.size;
+	
+	if (!(pattern_k=(pcre*)kmalloc(len, GFP_KERNEL))){
+		return NULL;
+	}
+
+	(void)memcpy(pattern_k, &tdata, sizeof(pcre));
+
+	if (copy_from_user(((uschar*)pattern_k)+sizeof(pcre), ((uschar*)pattern_u)+sizeof(pcre),
+	    		len-sizeof(pcre))){
+		kfree(pattern_k);
+		return NULL;
+	}
+
+	/* stitch in pcre patterns, it was NULLed out by parser */
+	// pcre_default_tables defined in pcre_tables.h */
+
+	pattern_k->tables=pcre_default_tables;
+
+	return pattern_k;
+}
+
+/**
+ * get_iface - copy interface name from user space
+ * @iface_u: user space interface name pointer
+ */
+static inline char * get_iface(char * iface_u) 
+{
+	char * iface = NULL;
+	int u_len, u_ret;
+
+	u_len = strnlen_user ( iface_u, IFNAMSIZ );
+
+	/* cmw: should this be u_len <= 0 ??? */
+	if ( ( u_len <= 0)  || ( u_len > IFNAMSIZ) ) 
+		return NULL; 
+
+ 	iface = (char *)kmalloc(u_len, GFP_KERNEL);
+ 	if (!iface)
+ 		return NULL;
+ 		
+	u_ret = strncpy_from_user(iface, iface_u, IFNAMSIZ);
+	if (u_ret != (u_len - 1)) {
+		kfree (iface);
+		return NULL;
+	}
+	return iface;
+}
+
+/**
+ * copy_entry_from_user - copy sd entry from user
+ * @entry_u: user space entry
+ */
+
+static inline
+struct sd_entry * copy_entry_from_user(struct cod_entry_user *entry_u)
+{
+	char *name = NULL,
+	     *regex = NULL;
+	pcre *compiled = NULL;
+	struct sd_entry *entry = NULL;
+
+	if (!(name = get_name(entry_u->name, PATH_MAX))){
+		goto error;
+	}
+
+	/* is there a regex pattern present? */
+	if (entry_u->pattern_type == ePatternRegex)
+	{
+		if (!(regex = get_name(entry_u->pat.regex, PATH_MAX))){
+			goto error;
+		}
+
+		if (!(compiled = get_pattern(entry_u->pat.compiled))){
+			goto error;
+		}
+	}	
+
+	if ((entry = alloc_sd_entry())){
+		entry->filename = name;
+
+		/* exec alone without qualifier is no longer allowed */
+		if (SD_EXEC_MASK(entry_u->mode) == KERN_COD_MAY_EXEC){
+			SD_ERROR("%s: Invalid mode while parsing entry %s.  KERN_COD_MAY_EXEC must now be combined with an exec qualifier (inherit, uncontrained or profile). Please verify that kernel and subdomain_parser versions are compatible\n",
+				__FUNCTION__,
+				entry->filename);
+			goto error;
+		}else{
+			entry->mode = entry_u->mode;
+		}
+
+		entry->pattern_type = entry_u->pattern_type;
+		if (entry->pattern_type == ePatternRegex){
+			entry->regex=regex;
+			entry->compiled=compiled;
+		}else{
+			entry->regex=NULL;
+			entry->compiled=NULL;
+		}
+	} else {
+		goto error;
+	}
+
+	switch (entry->pattern_type){
+		case ePatternBasic:
+			SD_DEBUG("%s: %s [no pattern] mode=0x%x\n", 
+				__FUNCTION__,
+				entry->filename,
+				entry->mode);
+			break;
+		case ePatternTailGlob:
+			SD_DEBUG("%s: %s [tailglob] mode=0x%x\n", 
+				__FUNCTION__,
+				entry->filename,
+				entry->mode);
+			break;
+		case ePatternRegex:
+			SD_DEBUG("%s: %s [regex] regex='%s' pattern_length=%d mode=0x%x\n", 
+				__FUNCTION__,
+				entry->filename,
+				entry->regex,
+				(unsigned int) entry->compiled->size,
+				entry->mode);
+			break;
+		default:
+			SD_WARN("%s: INVALID pattern_type %d\n", 
+				__FUNCTION__,
+				(int)entry->pattern_type);
+			goto error;
+	}
+
+	return entry;
+
+error:
+	free_sd_entry(entry);
+	put_name(name);
+	put_name(regex);
+	put_pattern(compiled);
+
+	return NULL;
+}
+
+
+/************************************************************************/
+/*                                                                      */
+/* copy_net_entry_from_user                                             */
+/*                                                                      */
+/*                                                                      */
+/************************************************************************/
+
+
+static inline struct nd_entry *
+copy_net_entry_from_user(struct cod_net_entry_user *net_entry_u) 
+{
+	char *iface;
+	struct nd_entry *entry = NULL;
+
+	struct in_addr *p_saddr, *p_smask, *p_daddr, *p_dmask;
+	unsigned short *p_sport, *p_dport;
+
+	SD_DEBUG("%s: BEGIN\n", 
+		__FUNCTION__);
+
+	/* interface not required, may be NULL */
+	iface = get_iface(net_entry_u->iface);
+	
+	entry = alloc_nd_entry();
+
+	if (!entry) {
+		SD_DEBUG("%s: No entry\n", __FUNCTION__);
+		goto error;
+	}
+
+	/* values in entry are zeroed by alloc_nd_entry 
+	 * N.B for in_addr values, 0 == INADDR_ANY 
+	 * */
+
+
+	entry->mode = net_entry_u->mode;
+
+	ND_DEBUG ("%s: mode: %x\n", 
+		__FUNCTION__,
+		entry->mode);
+
+	/* N.B
+	 * The parser and the kernel have an opposite view of
+	 * addresses.
+	 * 
+	 * As far as we (the kernel) are concerned:
+	 * "tcp_accept from"  specifies a remote address (daddr)
+	 * "tcp_connect from" specifies a local address (saddr)
+	 * And so on (inversely) for "to"
+	 *
+	 * The parser considers <from> to always be a source
+	 * and <to> to always specify a remote regardless of
+	 * the mode (accept, connect etc)
+	 *
+	 * We'll switch them around here
+	 */
+
+	if (entry->mode == KERN_COD_TCP_CONNECT ||
+	    entry->mode == KERN_COD_UDP_SEND){
+
+		p_saddr = net_entry_u->saddr;
+		p_smask = net_entry_u->smask;
+		p_sport = net_entry_u->src_port;
+		p_daddr = net_entry_u->daddr;
+		p_dmask = net_entry_u->dmask;
+		p_dport = net_entry_u->dst_port;
+
+	}else if (entry->mode == KERN_COD_TCP_ACCEPT ||
+	    entry->mode == KERN_COD_UDP_RECEIVE){
+
+		p_saddr = net_entry_u->daddr;
+		p_smask = net_entry_u->dmask;
+		p_sport = net_entry_u->dst_port;
+		p_daddr = net_entry_u->saddr;
+		p_dmask = net_entry_u->smask;
+		p_dport = net_entry_u->src_port;
+	}else{
+		SD_WARN("%s: INVALID mode %x\n", 
+			__FUNCTION__,
+			entry->mode);
+		goto error;
+	}
+
+	if (net_entry_u->saddr) {
+		entry->saddr = p_saddr->s_addr;
+		ND_DEBUG ("%s: saddr: %u.%u.%u.%u\n", 
+			__FUNCTION__, NIPQUAD(entry->saddr));
+	} 
+	if (net_entry_u->smask) {
+		entry->smask = p_smask->s_addr;
+		ND_DEBUG ("%s: smask: %u.%u.%u.%u\n", 
+			__FUNCTION__, NIPQUAD(entry->smask));
+	} 
+	if (net_entry_u->daddr) { 
+		entry->daddr = p_daddr->s_addr;
+		ND_DEBUG ("%s: daddr: %u.%u.%u.%u\n", 
+			__FUNCTION__, NIPQUAD(entry->daddr));
+	} 
+	if (net_entry_u->dmask) {
+		entry->dmask = p_dmask->s_addr;
+		ND_DEBUG ("%s: dmask: %u.%u.%u.%u\n", 
+			__FUNCTION__, NIPQUAD(entry->dmask));
+	}
+	
+	entry->src_port[0] = p_sport[0];
+	entry->src_port[1] = p_sport[1];
+	entry->dst_port[0] = p_dport[0];
+	entry->dst_port[1] = p_dport[1];
+
+	ND_DEBUG ("%s: sport: %u - %u  dport: %u - %u\n",
+		__FUNCTION__, 
+		entry->src_port[0], entry->src_port[1],
+		entry->dst_port[0], entry->dst_port[1]);
+
+	entry->iface = iface;
+
+	ND_DEBUG ("%s: iface: %s\n", 
+		__FUNCTION__,
+		entry->iface ? entry->iface : "NULL");
+
+
+	ND_DEBUG ("%s: EBD 0x%p\n", 
+		__FUNCTION__,
+		entry);
+
+	return entry;
+
+error:
+	put_iface(iface);
+	free_nd_entry(entry);
+
+	return NULL;
+}
+
+/**
+ * copy_profile_from_user - copy profile from user space
+ * @profile_u: user profile
+ * @parent: parent profile
+ */
+static struct sdprofile *
+copy_profile_from_user(struct codomain_user *codomain_u,
+				struct sdprofile *parent)
+{
+	char *name = NULL, *sub_name = NULL; 
+	struct sdprofile *profile = NULL, *subprofile = NULL;
+	struct codomain_user *sub_u = NULL, sub_k;
+	struct cod_entry_user *file_u = NULL, entry_k;
+	struct cod_net_entry_user *net_u = NULL, net_k;
+
+	name = get_name(codomain_u->name, PATH_MAX);
+	if (!name){
+		goto error;
+	}
+
+	SD_DEBUG("%s: %s\n", __FUNCTION__ , name);
+
+	if (codomain_u->sub_name != NULL) {
+		sub_name = get_name(codomain_u->sub_name, KERN_COD_HAT_SIZE);
+		if (!sub_name)
+			goto nosub;
+	}
+
+	profile = alloc_sdprofile();
+	if (!profile){
+		goto noprof;
+	}
+
+	profile->name = name;
+	/* XXX Hack to handle subprofiles */
+	if (parent) {
+		profile->name = sub_name;
+		put_name(name);
+		name=NULL;
+	}
+
+	/* copy per profile debug flags (debug, complain, audit) */
+	profile->flags = codomain_u->flags;
+
+	/* copy per profile capabilities (are &ed with tasks effective) */
+	profile->capabilities = (kernel_cap_t)codomain_u->capabilities;
+
+	//profile->sub_name = sub_name;
+	//profile->parent = parent;
+
+	/* 
+	 * Warning, make these as non-recursive as possible. 
+	 * Otherwise, the kernel stack will get blown out.
+	 */
+	file_u = codomain_u->entries;
+	while (file_u) {
+		struct sd_entry *file_entry = NULL;
+		int i;
+
+		if (copy_from_user(&entry_k, file_u, sizeof(struct cod_entry_user))){
+			goto error;
+		}
+		file_entry = copy_entry_from_user(&entry_k);
+		if (!file_entry){
+			goto error;
+		}
+
+		/* profile->file_entry initially set to NULL 
+		 * in alloc_sdprofile() */
+		file_entry->next = profile->file_entry;
+		profile->file_entry = file_entry;
+
+		/* 
+		 * Handle partitioned lists
+		 * Chain entries onto sublists based on individual 
+		 * permission bits. This allows more rapid searching.
+		 */
+		for (i=0; i<=POS_KERN_COD_FILE_MAX; i++){
+			if (file_entry->mode & (1<<i)){
+				/* profile->file_entryp[i] initially set to
+				 * NULL in alloc_sdprofile() */
+				file_entry->nextp[i]=profile->file_entryp[i];
+				profile->file_entryp[i]=file_entry;
+			}
+		}
+
+		file_u = entry_k.next;
+	}
+	count_entries(profile);
+
+	net_u = codomain_u->net_entries;
+
+	if (parent) {
+		if (net_u){
+			SD_WARN("%s: Ignoring network entries for subprofile %s^%s. There is currently no kernel Netdomain support for changehat.\n",
+				__FUNCTION__,
+				parent->name, profile->name);
+		}
+	}else{
+		while (net_u) {
+			struct nd_entry *net_entry = NULL;
+			int i;
+	
+			if (copy_from_user(&net_k, net_u, sizeof(struct cod_net_entry_user))){
+				goto error;
+			}
+			net_entry = copy_net_entry_from_user(&net_k);
+			if (!net_entry){
+				goto error;
+			}
+			net_entry->next = profile->net_entry;
+			profile->net_entry = net_entry;
+	
+			/* 
+			 * Handle partitioned lists
+			 * Chain entries onto sublists based on individual 
+			 * permission bits. This allows more rapid searching.
+			 */
+			for (i=POS_KERN_COD_NET_MIN; i<=POS_KERN_COD_NET_MAX; i++){
+				int j;
+	
+				j=NET_POS_TO_INDEX(i);
+	
+				if (net_entry->mode & (1<<i)){
+					/* profile->net_entryp[i] initially set to
+					 * NULL in alloc_sdprofile() */
+					net_entry->nextp[j]=profile->net_entryp[j];
+					profile->net_entryp[j]=net_entry;
+				}
+			}
+	
+			net_u = net_k.next;
+		} 
+		count_net_entries(profile);
+	}
+	
+	sub_u = codomain_u->subdomain; 
+	while (sub_u) {
+		if (copy_from_user(&sub_k, sub_u, sizeof(struct codomain_user))){
+			goto error;
+		}
+		subprofile = copy_profile_from_user(&sub_k, profile);
+		if (!subprofile){
+			goto error;
+		}
+		get_sdprofile(subprofile);
+		list_add(&subprofile->list, &profile->sub);
+		sub_u = sub_k.next ;
+	}
+
+	/* DONE */
+	return profile;
+
+error:
+	if (profile){
+		free_sdprofile(profile);
+		profile=NULL;
+	}
+		
+	/* name/sub_name will be released by above free_sdprofile
+	 * if necessary
+	 */
+	return NULL;
+
+noprof:
+	put_name(sub_name);
+	/* fall thru */
+nosub:
+	put_name(name);
+	return NULL;
+}
+
+/**
+ * sysctl_add - add new profile
+ * @codomain_u: user space profile
+ */
+static inline int sysctl_add(struct codomain_user *codomain_u)
+{
+	struct sdprofile *profile = NULL, *old_profile = NULL;
+
+	if (sd_is_confined()){
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile addition (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	profile = copy_profile_from_user(codomain_u, NULL);
+	if (!profile)
+		return -ENOMEM;
+
+	old_profile = sd_profilelist_find(profile->name);
+	if (old_profile) {
+		SD_WARN("%s: trying to add profile (%s) that "
+			"already exists.\n", __FUNCTION__, profile->name);
+		put_sdprofile(old_profile);
+		free_sdprofile(profile);
+		return -EINVAL ;
+	}
+
+	sd_profilelist_add(profile);
+
+	/* XXX */
+	return 1;
+}       
+
+/**
+ * sysctl_del - remove profile
+ * @codomain_u: user space codomain
+ */
+static inline int sysctl_del(struct codomain_user *codomain_u)
+{
+	struct sdprofile *profile = NULL,
+			 *old_profile;
+
+	if (sd_is_confined()){
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile deletion (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	profile = copy_profile_from_user(codomain_u, NULL);
+	if (!profile)
+		return -ENOMEM;
+
+
+	/* Do this step to get a guaranteed reference to profile
+	 * as sd_profilelist_remove may drop it to zero which would
+	 * made subsequent attempt to iterate using it unsafe
+	 */
+	old_profile=sd_profilelist_find(profile->name);
+
+	if (old_profile){
+		if (sd_profilelist_remove(profile->name) != 0) {
+			SD_WARN("%s: race trying to remove profile (%s)\n",
+				__FUNCTION__, profile->name) ;
+		}
+
+		/* remove profile from any tasks using it */
+		sd_subdomainlist_iterateremove(taskremove_iter, (void*)old_profile);
+
+#if defined NETDOMAIN && defined NETDOMAIN_SKUSERS
+		/* drop all netdomains using this profile */
+		nd_skusers_exch(old_profile, NULL, 1);
+#endif
+
+		/* drop reference obtained by sd_profilelist_find */
+		put_sdprofile(old_profile);
+	}else{
+		SD_WARN("%s: trying to remove profile (%s) that "
+			"doesn't exist - skipping.\n",
+			__FUNCTION__, profile->name ) ;
+	}
+
+	/* The entire copy_profile_from_user step above was performed
+	 * to simply get profile_name.  Copying in an entire profile to
+	 * just get the name is very inefficient, but this is the way it's
+	 * done.
+	 *
+	 * Since we no longer need the profile, we must delete it
+	 */
+	free_sdprofile(profile);
+
+	/* XXX */
+	return 1;
+}       
+
+/**
+ * sysctl_repl - replace a profile
+ * @codomain_u: user supplied profile
+ */
+
+static inline int sysctl_repl(struct codomain_user *codomain_u)
+{
+	struct sd_taskreplace_data data;
+
+	struct sdprofile *old_profile = NULL;
+
+	if (sd_is_confined()){
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile replacement (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	data.new_profile = copy_profile_from_user(codomain_u, NULL);
+	if (!data.new_profile)
+		return -ENOMEM;
+
+	/* prevent race (see comment in module_new_interface.c) */
+	get_sdprofile(data.new_profile);
+
+	/* Replace the profile on the global profile list.
+	 * This list is used by all new exec's to find the correct profile.
+	 * If there was a previous profile, it is returned, else NULL.
+	 *
+	 * N.B The old profile released still has a reference so it must
+	 * be put when no longer required.
+	 */
+	data.old_profile = sd_profilelist_replace(data.new_profile);
+
+	/* If there was an old profile,  find all currently executing tasks
+	 * using this profile and replace the old profile with the new.
+	 */
+	if (data.old_profile) {
+		SD_DEBUG("%s: try to replace profile (%p)%s\n", 
+			__FUNCTION__,
+			data.old_profile, 
+			data.old_profile->name);
+
+		sd_subdomainlist_iterate(taskreplace_iter, (void*)&data);
+
+#if defined NETDOMAIN && defined NETDOMAIN_SKUSERS
+		/* Change any sockets (soft intr context) using old profile
+		 * to use new profile
+		 */
+		nd_skusers_exch(data.old_profile, data.new_profile, 0);
+#endif
+
+		/* mark old profile as stale */
+		data.old_profile->isstale=1;
+
+		/* it's off global list, and we are done replacing */
+		put_sdprofile(data.old_profile);
+	} else {
+		SD_WARN("%s: trying to replace profile %s that doesn't exist\n", __FUNCTION__, data.new_profile->name);
+		free_sdprofile(data.new_profile);
+		return -EINVAL;
+	}
+
+	put_sdprofile(data.new_profile);
+
+	return 1;
+}       
+
+/**
+ * sysctl_dbg - debugging interface
+ * @codomain_u: user supplied profile
+ *
+ * Dumps the supplied profile, then dumps the profile list
+ */
+static inline int sysctl_dbg(struct codomain_user *codomain_u)
+{
+	if (codomain_u) {
+		struct sdprofile *profile = NULL;
+
+		profile = copy_profile_from_user(codomain_u, NULL);
+
+		if (!profile)
+			return -ENOMEM;
+
+		sd_profile_dump(profile);
+
+		free_sdprofile(profile);
+	}
+
+	sd_profilelist_dump();
+	return 0;
+}
+
+static inline int dump_mount_info(void)
+{
+	struct namespace *namespace;
+	struct list_head *lh;
+	char *page, *path;
+
+	SD_DEBUG("%s\n", __FUNCTION__);
+	task_lock(current);
+	namespace = current->namespace;
+	task_unlock(current);
+	if (!namespace)
+		return -ENOENT;
+	page = (char *)__get_free_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+	list_for_each(lh, &namespace->list) {
+		struct vfsmount *mnt=list_entry(lh, struct vfsmount, mnt_list);
+		path = d_path(mnt->mnt_root, mnt, page, PAGE_SIZE);
+		SD_INFO("(%p->%p)%s:%s\n", mnt, mnt->mnt_root, mnt->mnt_devname, path);
+#if 0
+		/* should always be "/" */
+		path = d_path(mnt->mnt_root, mnt->mnt_parent, page, PAGE_SIZE);
+		SD_INFO("(%p)%s:%s\n", mnt, mnt->mnt_devname, path);
+		/* junk... "/home/home" */
+		path = d_path(mnt->mnt_mountpoint, mnt, page, PAGE_SIZE);
+		SD_INFO("(%p)%s:%s\n", mnt, mnt->mnt_devname, path);
+#endif
+		path = d_path(mnt->mnt_mountpoint, mnt->mnt_parent, page, PAGE_SIZE);
+		SD_INFO("(%p->%p)%s:%s\n", mnt->mnt_parent, mnt->mnt_parent->mnt_mountpoint, mnt->mnt_parent->mnt_devname, path);
+	}
+	free_page((unsigned long)page);
+	return 0;
+}
+
+int sd_sys_security(unsigned int id, unsigned int call, unsigned long *args)
+{
+	struct codomain_user cod_k;
+	int error = -EINVAL;
+
+	SD_DEBUG("%s: 0x%x %d\n", __FUNCTION__, id, call);
+
+	if (id != SD_ID_MAGIC)
+		goto out;
+
+	switch (call) {
+	case SD_ADD_PROFILE:
+		error = -EFAULT;
+		if (!copy_from_user(&cod_k, args,
+				sizeof(struct codomain_user)))
+			error = sysctl_add(&cod_k);
+		break;
+
+	case SD_DELETE_PROFILE:
+		error = -EFAULT;
+		if (!copy_from_user(&cod_k, args,
+				sizeof(struct codomain_user)))
+			error = sysctl_del(&cod_k);
+		break;
+
+	case SD_REPLACE_PROFILE:
+		error = -EFAULT;
+		if (!copy_from_user(&cod_k, args,
+				sizeof(struct codomain_user)))
+			error = sysctl_repl(&cod_k);
+		break;
+
+	case SD_DEBUG_PROFILE:
+		if (args) {
+			if (!copy_from_user(&cod_k, args,
+				sizeof(struct codomain_user)))
+				error = sysctl_dbg(&cod_k);
+		}
+		else
+			error = sysctl_dbg(NULL);
+		break;
+
+	case 5:
+		error = dump_mount_info();
+		break;
+
+	default:
+		error = -EINVAL;
+		break;
+	}
+
+out:
+	return error;
+}
+
+#endif //SD_OLD_INTERFACE
diff -uNrp linux-2.6.11/security/subdomain/pcre_exec.c linux-2.6.11.subd-new/security/subdomain/pcre_exec.c
--- linux-2.6.11/security/subdomain/pcre_exec.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/pcre_exec.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,1945 @@
+/*  
+ *  This is a modified version of pcre.c containing only the code/data
+ *  required to support pcre_exec()
+ */
+
+
+/*************************************************
+*      Perl-Compatible Regular Expressions       *
+*************************************************/
+
+/*
+This is a library of functions to support regular expressions whose syntax
+and semantics are as close as possible to those of the Perl 5 language. See
+the file Tech.Notes for some information on the internals.
+
+Written by: Philip Hazel <ph10@cam.ac.uk>
+
+           Copyright (c) 1997-2001 University of Cambridge
+
+-----------------------------------------------------------------------------
+Permission is granted to anyone to use this software for any purpose on any
+computer system, and to redistribute it freely, subject to the following
+restrictions:
+
+1. This software is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+2. The origin of this software must not be misrepresented, either by
+   explicit claim or by omission.
+
+3. Altered versions must be plainly marked as such, and must not be
+   misrepresented as being the original software.
+
+4. If PCRE is embedded in any software that is released under the GNU
+   General Purpose Licence (GPL), then the terms of that licence shall
+   supersede any condition above with which it is incompatible.
+-----------------------------------------------------------------------------
+*/
+
+
+/* Define DEBUG to get debugging output on stdout. */
+
+/* #define DEBUG */
+
+/* Use a macro for debugging printing, 'cause that eliminates the use of #ifdef
+inline, and there are *still* stupid compilers about that don't like indented
+pre-processor statements. I suppose it's only been 10 years... */
+
+#ifdef DEBUG
+#define DPRINTF(p) PCRE_PRINTF p
+#else
+#define DPRINTF(p) /*nothing*/
+#endif
+
+/* Include the internals header, which itself includes Standard C headers plus
+the external pcre header. */
+
+#include "pcre_exec.h"
+
+
+/* ----  CODE DELETED ---- */
+
+
+/* Min and max values for the common repeats; for the maxima, 0 => infinity */
+
+static const char rep_min[] = { 0, 0, 1, 1, 0, 0 };
+static const char rep_max[] = { 0, 0, 0, 0, 1, 1 };
+
+
+/* ----  CODE DELETED ---- */
+
+
+/* Structure for building a chain of data that actually lives on the
+ * stack, for holding the values of the subject pointer at the start of each
+ * subpattern, so as to detect when an empty string has been matched by a
+ * subpattern - to break infinite loops. */
+
+typedef struct eptrblock {
+	  struct eptrblock *prev;
+	    const uschar *saved_eptr;
+} eptrblock;
+
+/* Flag bits for the match() function */
+
+#define match_condassert   0x01    /* Called to check a condition assertion */
+#define match_isgroup      0x02    /* Set if start of bracketed group */
+
+
+/* ----  CODE DELETED ---- */
+
+
+/*************************************************
+ * *               Global variables                 *
+ * *************************************************/
+
+/* PCRE is thread-clean and doesn't use any global variables in the normal
+ * sense. However, it calls memory allocation and free functions via the two
+ * indirections below, which are can be changed by the caller, but are shared
+ * between all threads. */
+
+#ifdef __KERNEL__
+static void *kern_malloc(size_t sz)
+{
+	        return kmalloc(sz, GFP_KERNEL);
+}
+void  *(*pcre_malloc)(size_t) = kern_malloc;
+void  (*pcre_free)(const void *) = kfree;
+#else
+void  *(*pcre_malloc)(size_t) = malloc;
+void  (*pcre_free)(const void *) = free;
+#endif
+
+
+/*************************************************
+ * *    Macros and tables for character handling    *
+ * *************************************************/
+
+/* When UTF-8 encoding is being used, a character is no longer just a single
+ * byte. The macros for character handling generate simple sequences when used in
+ * byte-mode, and more complicated ones for UTF-8 characters. */
+
+#ifndef SUPPORT_UTF8
+#define GETCHARINC(c, eptr) c = *eptr++;
+#define GETCHARLEN(c, eptr, len) c = *eptr;
+#define BACKCHAR(eptr)
+#endif
+
+/* ----  CODE DELETED ---- */
+
+#ifdef DEBUG
+/*************************************************
+*        Debugging function to print chars       *
+*************************************************/
+
+/* Print a sequence of chars in printable format, stopping at the end of the
+subject if the requested.
+
+Arguments:
+  p           points to characters
+  length      number to print
+  is_subject  TRUE if printing from within md->start_subject
+  md          pointer to matching data block, if is_subject is TRUE
+
+Returns:     nothing
+*/
+
+static void
+pchars(const uschar *p, int length, BOOL is_subject, match_data *md)
+{
+int c;
+if (is_subject && length > md->end_subject - p) length = md->end_subject - p;
+while (length-- > 0)
+  if (isprint(c = *(p++))) PCRE_PRINTF("%c", c); else PCRE_PRINTF("\\x%02x", c);
+}
+#endif /* DEBUG */
+
+/* ----  CODE DELETED ---- */
+
+
+/*************************************************
+*          Match a back-reference                *
+*************************************************/
+
+/* If a back reference hasn't been set, the length that is passed is greater
+than the number of characters left in the string, so the match fails.
+
+Arguments:
+  offset      index into the offset vector
+  eptr        points into the subject
+  length      length to be matched
+  md          points to match data block
+  ims         the ims flags
+
+Returns:      TRUE if matched
+*/
+
+static BOOL
+match_ref(int offset, register const uschar *eptr, int length, match_data *md,
+  unsigned long int ims)
+{
+const uschar *p = md->start_subject + md->offset_vector[offset];
+
+#ifdef DEBUG
+if (eptr >= md->end_subject)
+  PCRE_PRINTF("matching subject <null>");
+else
+  {
+  PCRE_PRINTF("matching subject ");
+  pchars(eptr, length, TRUE, md);
+  }
+PCRE_PRINTF(" against backref ");
+pchars(p, length, FALSE, md);
+PCRE_PRINTF("\n");
+#endif
+
+/* Always fail if not enough characters left */
+
+if (length > md->end_subject - eptr) return FALSE;
+
+/* Separate the caselesss case for speed */
+
+if ((ims & PCRE_CASELESS) != 0)
+  {
+  while (length-- > 0)
+    if (md->lcc[*p++] != md->lcc[*eptr++]) return FALSE;
+  }
+else
+  { while (length-- > 0) if (*p++ != *eptr++) return FALSE; }
+
+return TRUE;
+}
+
+
+/*************************************************
+*         Match from current position            *
+*************************************************/
+
+/* On entry ecode points to the first opcode, and eptr to the first character
+in the subject string, while eptrb holds the value of eptr at the start of the
+last bracketed group - used for breaking infinite loops matching zero-length
+strings.
+
+Arguments:
+   eptr        pointer in subject
+   ecode       position in code
+   offset_top  current top pointer
+   md          pointer to "static" info for the match
+   ims         current /i, /m, and /s options
+   eptrb       pointer to chain of blocks containing eptr at start of
+                 brackets - for testing for empty matches
+   flags       can contain
+                 match_condassert - this is an assertion condition
+                 match_isgroup - this is the start of a bracketed group
+
+Returns:       TRUE if matched
+*/
+
+static BOOL
+match(register const uschar *eptr, register const uschar *ecode,
+  int offset_top, match_data *md, unsigned long int ims, eptrblock *eptrb,
+  int flags)
+{
+unsigned long int original_ims = ims;   /* Save for resetting on ')' */
+eptrblock newptrb;
+
+/* At the start of a bracketed group, add the current subject pointer to the
+stack of such pointers, to be re-instated at the end of the group when we hit
+the closing ket. When match() is called in other circumstances, we don't add to
+the stack. */
+
+if ((flags & match_isgroup) != 0)
+  {
+  newptrb.prev = eptrb;
+  newptrb.saved_eptr = eptr;
+  eptrb = &newptrb;
+  }
+
+/* Now start processing the operations. */
+
+for (;;)
+  {
+  int op = (int)*ecode;
+  int min, max, ctype;
+  register int i;
+  register int c;
+  BOOL minimize = FALSE;
+
+  /* Opening capturing bracket. If there is space in the offset vector, save
+  the current subject position in the working slot at the top of the vector. We
+  mustn't change the current values of the data slot, because they may be set
+  from a previous iteration of this group, and be referred to by a reference
+  inside the group.
+
+  If the bracket fails to match, we need to restore this value and also the
+  values of the final offsets, in case they were set by a previous iteration of
+  the same bracket.
+
+  If there isn't enough space in the offset vector, treat this as if it were a
+  non-capturing bracket. Don't worry about setting the flag for the error case
+  here; that is handled in the code for KET. */
+
+  if (op > OP_BRA)
+    {
+    int offset;
+    int number = op - OP_BRA;
+
+    /* For extended extraction brackets (large number), we have to fish out the
+    number from a dummy opcode at the start. */
+
+    if (number > EXTRACT_BASIC_MAX) number = (ecode[4] << 8) | ecode[5];
+    offset = number << 1;
+
+#ifdef DEBUG
+    PCRE_PRINTF("start bracket %d subject=", number);
+    pchars(eptr, 16, TRUE, md);
+    PCRE_PRINTF("\n");
+#endif
+
+    if (offset < md->offset_max)
+      {
+      int save_offset1 = md->offset_vector[offset];
+      int save_offset2 = md->offset_vector[offset+1];
+      int save_offset3 = md->offset_vector[md->offset_end - number];
+
+      DPRINTF(("saving %d %d %d\n", save_offset1, save_offset2, save_offset3));
+      md->offset_vector[md->offset_end - number] = eptr - md->start_subject;
+
+      do
+        {
+        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup))
+          return TRUE;
+        ecode += (ecode[1] << 8) + ecode[2];
+        }
+      while (*ecode == OP_ALT);
+
+      DPRINTF(("bracket %d failed\n", number));
+
+      md->offset_vector[offset] = save_offset1;
+      md->offset_vector[offset+1] = save_offset2;
+      md->offset_vector[md->offset_end - number] = save_offset3;
+
+      return FALSE;
+      }
+
+    /* Insufficient room for saving captured contents */
+
+    else op = OP_BRA;
+    }
+
+  /* Other types of node can be handled by a switch */
+
+  switch(op)
+    {
+    case OP_BRA:     /* Non-capturing bracket: optimized */
+    DPRINTF(("start bracket 0\n"));
+    do
+      {
+      if (match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup))
+        return TRUE;
+      ecode += (ecode[1] << 8) + ecode[2];
+      }
+    while (*ecode == OP_ALT);
+    DPRINTF(("bracket 0 failed\n"));
+    return FALSE;
+
+    /* Conditional group: compilation checked that there are no more than
+    two branches. If the condition is false, skipping the first branch takes us
+    past the end if there is only one branch, but that's OK because that is
+    exactly what going to the ket would do. */
+
+    case OP_COND:
+    if (ecode[3] == OP_CREF)         /* Condition is extraction test */
+      {
+      int offset = (ecode[4] << 9) | (ecode[5] << 1); /* Doubled ref number */
+      return match(eptr,
+        ecode + ((offset < offset_top && md->offset_vector[offset] >= 0)?
+          6 : 3 + (ecode[1] << 8) + ecode[2]),
+        offset_top, md, ims, eptrb, match_isgroup);
+      }
+
+    /* The condition is an assertion. Call match() to evaluate it - setting
+    the final argument TRUE causes it to stop at the end of an assertion. */
+
+    else
+      {
+      if (match(eptr, ecode+3, offset_top, md, ims, NULL,
+          match_condassert | match_isgroup))
+        {
+        ecode += 3 + (ecode[4] << 8) + ecode[5];
+        while (*ecode == OP_ALT) ecode += (ecode[1] << 8) + ecode[2];
+        }
+      else ecode += (ecode[1] << 8) + ecode[2];
+      return match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup);
+      }
+    /* Control never reaches here */
+
+    /* Skip over conditional reference or large extraction number data if
+    encountered. */
+
+    case OP_CREF:
+    case OP_BRANUMBER:
+    ecode += 3;
+    break;
+
+    /* End of the pattern. If PCRE_NOTEMPTY is set, fail if we have matched
+    an empty string - recursion will then try other alternatives, if any. */
+
+    case OP_END:
+    if (md->notempty && eptr == md->start_match) return FALSE;
+    md->end_match_ptr = eptr;          /* Record where we ended */
+    md->end_offset_top = offset_top;   /* and how many extracts were taken */
+    return TRUE;
+
+    /* Change option settings */
+
+    case OP_OPT:
+    ims = ecode[1];
+    ecode += 2;
+    DPRINTF(("ims set to %02lx\n", ims));
+    break;
+
+    /* Assertion brackets. Check the alternative branches in turn - the
+    matching won't pass the KET for an assertion. If any one branch matches,
+    the assertion is true. Lookbehind assertions have an OP_REVERSE item at the
+    start of each branch to move the current point backwards, so the code at
+    this level is identical to the lookahead case. */
+
+    case OP_ASSERT:
+    case OP_ASSERTBACK:
+    do
+      {
+      if (match(eptr, ecode+3, offset_top, md, ims, NULL, match_isgroup)) break;
+      ecode += (ecode[1] << 8) + ecode[2];
+      }
+    while (*ecode == OP_ALT);
+    if (*ecode == OP_KET) return FALSE;
+
+    /* If checking an assertion for a condition, return TRUE. */
+
+    if ((flags & match_condassert) != 0) return TRUE;
+
+    /* Continue from after the assertion, updating the offsets high water
+    mark, since extracts may have been taken during the assertion. */
+
+    do ecode += (ecode[1] << 8) + ecode[2]; while (*ecode == OP_ALT);
+    ecode += 3;
+    offset_top = md->end_offset_top;
+    continue;
+
+    /* Negative assertion: all branches must fail to match */
+
+    case OP_ASSERT_NOT:
+    case OP_ASSERTBACK_NOT:
+    do
+      {
+      if (match(eptr, ecode+3, offset_top, md, ims, NULL, match_isgroup))
+        return FALSE;
+      ecode += (ecode[1] << 8) + ecode[2];
+      }
+    while (*ecode == OP_ALT);
+
+    if ((flags & match_condassert) != 0) return TRUE;
+
+    ecode += 3;
+    continue;
+
+    /* Move the subject pointer back. This occurs only at the start of
+    each branch of a lookbehind assertion. If we are too close to the start to
+    move back, this match function fails. When working with UTF-8 we move
+    back a number of characters, not bytes. */
+
+    case OP_REVERSE:
+#ifdef SUPPORT_UTF8
+    c = (ecode[1] << 8) + ecode[2];
+    for (i = 0; i < c; i++)
+      {
+      eptr--;
+      BACKCHAR(eptr)
+      }
+#else
+    eptr -= (ecode[1] << 8) + ecode[2];
+#endif
+
+    if (eptr < md->start_subject) return FALSE;
+    ecode += 3;
+    break;
+
+    /* Recursion matches the current regex, nested. If there are any capturing
+    brackets started but not finished, we have to save their starting points
+    and reinstate them after the recursion. However, we don't know how many
+    such there are (offset_top records the completed total) so we just have
+    to save all the potential data. There may be up to 99 such values, which
+    is a bit large to put on the stack, but using malloc for small numbers
+    seems expensive. As a compromise, the stack is used when there are fewer
+    than 16 values to store; otherwise malloc is used. A problem is what to do
+    if the malloc fails ... there is no way of returning to the top level with
+    an error. Save the top 15 values on the stack, and accept that the rest
+    may be wrong. */
+
+    case OP_RECURSE:
+      {
+      BOOL rc;
+      int *save;
+      int stacksave[15];
+
+      c = md->offset_max;
+
+      if (c < 16) save = stacksave; else
+        {
+        save = (int *)(pcre_malloc)((c+1) * sizeof(int));
+        if (save == NULL)
+          {
+          save = stacksave;
+          c = 15;
+          }
+        }
+
+      for (i = 1; i <= c; i++)
+        save[i] = md->offset_vector[md->offset_end - i];
+      rc = match(eptr, md->start_pattern, offset_top, md, ims, eptrb,
+        match_isgroup);
+      for (i = 1; i <= c; i++)
+        md->offset_vector[md->offset_end - i] = save[i];
+      if (save != stacksave) (pcre_free)(save);
+      if (!rc) return FALSE;
+
+      /* In case the recursion has set more capturing values, save the final
+      number, then move along the subject till after the recursive match,
+      and advance one byte in the pattern code. */
+
+      offset_top = md->end_offset_top;
+      eptr = md->end_match_ptr;
+      ecode++;
+      }
+    break;
+
+    /* "Once" brackets are like assertion brackets except that after a match,
+    the point in the subject string is not moved back. Thus there can never be
+    a move back into the brackets. Check the alternative branches in turn - the
+    matching won't pass the KET for this kind of subpattern. If any one branch
+    matches, we carry on as at the end of a normal bracket, leaving the subject
+    pointer. */
+
+    case OP_ONCE:
+      {
+      const uschar *prev = ecode;
+      const uschar *saved_eptr = eptr;
+
+      do
+        {
+        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, match_isgroup))
+          break;
+        ecode += (ecode[1] << 8) + ecode[2];
+        }
+      while (*ecode == OP_ALT);
+
+      /* If hit the end of the group (which could be repeated), fail */
+
+      if (*ecode != OP_ONCE && *ecode != OP_ALT) return FALSE;
+
+      /* Continue as from after the assertion, updating the offsets high water
+      mark, since extracts may have been taken. */
+
+      do ecode += (ecode[1] << 8) + ecode[2]; while (*ecode == OP_ALT);
+
+      offset_top = md->end_offset_top;
+      eptr = md->end_match_ptr;
+
+      /* For a non-repeating ket, just continue at this level. This also
+      happens for a repeating ket if no characters were matched in the group.
+      This is the forcible breaking of infinite loops as implemented in Perl
+      5.005. If there is an options reset, it will get obeyed in the normal
+      course of events. */
+
+      if (*ecode == OP_KET || eptr == saved_eptr)
+        {
+        ecode += 3;
+        break;
+        }
+
+      /* The repeating kets try the rest of the pattern or restart from the
+      preceding bracket, in the appropriate order. We need to reset any options
+      that changed within the bracket before re-running it, so check the next
+      opcode. */
+
+      if (ecode[3] == OP_OPT)
+        {
+        ims = (ims & ~PCRE_IMS) | ecode[4];
+        DPRINTF(("ims set to %02lx at group repeat\n", ims));
+        }
+
+      if (*ecode == OP_KETRMIN)
+        {
+        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, 0) ||
+            match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup))
+              return TRUE;
+        }
+      else  /* OP_KETRMAX */
+        {
+        if (match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup) ||
+            match(eptr, ecode+3, offset_top, md, ims, eptrb, 0)) return TRUE;
+        }
+      }
+    return FALSE;
+
+    /* An alternation is the end of a branch; scan along to find the end of the
+    bracketed group and go to there. */
+
+    case OP_ALT:
+    do ecode += (ecode[1] << 8) + ecode[2]; while (*ecode == OP_ALT);
+    break;
+
+    /* BRAZERO and BRAMINZERO occur just before a bracket group, indicating
+    that it may occur zero times. It may repeat infinitely, or not at all -
+    i.e. it could be ()* or ()? in the pattern. Brackets with fixed upper
+    repeat limits are compiled as a number of copies, with the optional ones
+    preceded by BRAZERO or BRAMINZERO. */
+
+    case OP_BRAZERO:
+      {
+      const uschar *next = ecode+1;
+      if (match(eptr, next, offset_top, md, ims, eptrb, match_isgroup))
+        return TRUE;
+      do next += (next[1] << 8) + next[2]; while (*next == OP_ALT);
+      ecode = next + 3;
+      }
+    break;
+
+    case OP_BRAMINZERO:
+      {
+      const uschar *next = ecode+1;
+      do next += (next[1] << 8) + next[2]; while (*next == OP_ALT);
+      if (match(eptr, next+3, offset_top, md, ims, eptrb, match_isgroup))
+        return TRUE;
+      ecode++;
+      }
+    break;
+
+    /* End of a group, repeated or non-repeating. If we are at the end of
+    an assertion "group", stop matching and return TRUE, but record the
+    current high water mark for use by positive assertions. Do this also
+    for the "once" (not-backup up) groups. */
+
+    case OP_KET:
+    case OP_KETRMIN:
+    case OP_KETRMAX:
+      {
+      const uschar *prev = ecode - (ecode[1] << 8) - ecode[2];
+      const uschar *saved_eptr = eptrb->saved_eptr;
+
+      eptrb = eptrb->prev;    /* Back up the stack of bracket start pointers */
+
+      if (*prev == OP_ASSERT || *prev == OP_ASSERT_NOT ||
+          *prev == OP_ASSERTBACK || *prev == OP_ASSERTBACK_NOT ||
+          *prev == OP_ONCE)
+        {
+        md->end_match_ptr = eptr;      /* For ONCE */
+        md->end_offset_top = offset_top;
+        return TRUE;
+        }
+
+      /* In all other cases except a conditional group we have to check the
+      group number back at the start and if necessary complete handling an
+      extraction by setting the offsets and bumping the high water mark. */
+
+      if (*prev != OP_COND)
+        {
+        int offset;
+        int number = *prev - OP_BRA;
+
+        /* For extended extraction brackets (large number), we have to fish out
+        the number from a dummy opcode at the start. */
+
+        if (number > EXTRACT_BASIC_MAX) number = (prev[4] << 8) | prev[5];
+        offset = number << 1;
+
+#ifdef DEBUG
+        PCRE_PRINTF("end bracket %d", number);
+        PCRE_PRINTF("\n");
+#endif
+
+        if (number > 0)
+          {
+          if (offset >= md->offset_max) md->offset_overflow = TRUE; else
+            {
+            md->offset_vector[offset] =
+              md->offset_vector[md->offset_end - number];
+            md->offset_vector[offset+1] = eptr - md->start_subject;
+            if (offset_top <= offset) offset_top = offset + 2;
+            }
+          }
+        }
+
+      /* Reset the value of the ims flags, in case they got changed during
+      the group. */
+
+      ims = original_ims;
+      DPRINTF(("ims reset to %02lx\n", ims));
+
+      /* For a non-repeating ket, just continue at this level. This also
+      happens for a repeating ket if no characters were matched in the group.
+      This is the forcible breaking of infinite loops as implemented in Perl
+      5.005. If there is an options reset, it will get obeyed in the normal
+      course of events. */
+
+      if (*ecode == OP_KET || eptr == saved_eptr)
+        {
+        ecode += 3;
+        break;
+        }
+
+      /* The repeating kets try the rest of the pattern or restart from the
+      preceding bracket, in the appropriate order. */
+
+      if (*ecode == OP_KETRMIN)
+        {
+        if (match(eptr, ecode+3, offset_top, md, ims, eptrb, 0) ||
+            match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup))
+              return TRUE;
+        }
+      else  /* OP_KETRMAX */
+        {
+        if (match(eptr, prev, offset_top, md, ims, eptrb, match_isgroup) ||
+            match(eptr, ecode+3, offset_top, md, ims, eptrb, 0)) return TRUE;
+        }
+      }
+    return FALSE;
+
+    /* Start of subject unless notbol, or after internal newline if multiline */
+
+    case OP_CIRC:
+    if (md->notbol && eptr == md->start_subject) return FALSE;
+    if ((ims & PCRE_MULTILINE) != 0)
+      {
+      if (eptr != md->start_subject && eptr[-1] != NEWLINE) return FALSE;
+      ecode++;
+      break;
+      }
+    /* ... else fall through */
+
+    /* Start of subject assertion */
+
+    case OP_SOD:
+    if (eptr != md->start_subject) return FALSE;
+    ecode++;
+    break;
+
+    /* Assert before internal newline if multiline, or before a terminating
+    newline unless endonly is set, else end of subject unless noteol is set. */
+
+    case OP_DOLL:
+    if ((ims & PCRE_MULTILINE) != 0)
+      {
+      if (eptr < md->end_subject) { if (*eptr != NEWLINE) return FALSE; }
+        else { if (md->noteol) return FALSE; }
+      ecode++;
+      break;
+      }
+    else
+      {
+      if (md->noteol) return FALSE;
+      if (!md->endonly)
+        {
+        if (eptr < md->end_subject - 1 ||
+           (eptr == md->end_subject - 1 && *eptr != NEWLINE)) return FALSE;
+
+        ecode++;
+        break;
+        }
+      }
+    /* ... else fall through */
+
+    /* End of subject assertion (\z) */
+
+    case OP_EOD:
+    if (eptr < md->end_subject) return FALSE;
+    ecode++;
+    break;
+
+    /* End of subject or ending \n assertion (\Z) */
+
+    case OP_EODN:
+    if (eptr < md->end_subject - 1 ||
+       (eptr == md->end_subject - 1 && *eptr != NEWLINE)) return FALSE;
+    ecode++;
+    break;
+
+    /* Word boundary assertions */
+
+    case OP_NOT_WORD_BOUNDARY:
+    case OP_WORD_BOUNDARY:
+      {
+      BOOL prev_is_word = (eptr != md->start_subject) &&
+        ((md->ctypes[eptr[-1]] & ctype_word) != 0);
+      BOOL cur_is_word = (eptr < md->end_subject) &&
+        ((md->ctypes[*eptr] & ctype_word) != 0);
+      if ((*ecode++ == OP_WORD_BOUNDARY)?
+           cur_is_word == prev_is_word : cur_is_word != prev_is_word)
+        return FALSE;
+      }
+    break;
+
+    /* Match a single character type; inline for speed */
+
+    case OP_ANY:
+    if ((ims & PCRE_DOTALL) == 0 && eptr < md->end_subject && *eptr == NEWLINE)
+      return FALSE;
+    if (eptr++ >= md->end_subject) return FALSE;
+#ifdef SUPPORT_UTF8
+    if (md->utf8)
+      while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+#endif
+    ecode++;
+    break;
+
+    case OP_NOT_DIGIT:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_digit) != 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_DIGIT:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_digit) == 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_NOT_WHITESPACE:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_space) != 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_WHITESPACE:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_space) == 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_NOT_WORDCHAR:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_word) != 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    case OP_WORDCHAR:
+    if (eptr >= md->end_subject ||
+       (md->ctypes[*eptr++] & ctype_word) == 0)
+      return FALSE;
+    ecode++;
+    break;
+
+    /* Match a back reference, possibly repeatedly. Look past the end of the
+    item to see if there is repeat information following. The code is similar
+    to that for character classes, but repeated for efficiency. Then obey
+    similar code to character type repeats - written out again for speed.
+    However, if the referenced string is the empty string, always treat
+    it as matched, any number of times (otherwise there could be infinite
+    loops). */
+
+    case OP_REF:
+      {
+      int length;
+      int offset = (ecode[1] << 9) | (ecode[2] << 1); /* Doubled ref number */
+      ecode += 3;                                     /* Advance past item */
+
+      /* If the reference is unset, set the length to be longer than the amount
+      of subject left; this ensures that every attempt at a match fails. We
+      can't just fail here, because of the possibility of quantifiers with zero
+      minima. */
+
+      length = (offset >= offset_top || md->offset_vector[offset] < 0)?
+        md->end_subject - eptr + 1 :
+        md->offset_vector[offset+1] - md->offset_vector[offset];
+
+      /* Set up for repetition, or handle the non-repeated case */
+
+      switch (*ecode)
+        {
+        case OP_CRSTAR:
+        case OP_CRMINSTAR:
+        case OP_CRPLUS:
+        case OP_CRMINPLUS:
+        case OP_CRQUERY:
+        case OP_CRMINQUERY:
+        c = *ecode++ - OP_CRSTAR;
+        minimize = (c & 1) != 0;
+        min = rep_min[c];                 /* Pick up values from tables; */
+        max = rep_max[c];                 /* zero for max => infinity */
+        if (max == 0) max = INT_MAX;
+        break;
+
+        case OP_CRRANGE:
+        case OP_CRMINRANGE:
+        minimize = (*ecode == OP_CRMINRANGE);
+        min = (ecode[1] << 8) + ecode[2];
+        max = (ecode[3] << 8) + ecode[4];
+        if (max == 0) max = INT_MAX;
+        ecode += 5;
+        break;
+
+        default:               /* No repeat follows */
+        if (!match_ref(offset, eptr, length, md, ims)) return FALSE;
+        eptr += length;
+        continue;              /* With the main loop */
+        }
+
+      /* If the length of the reference is zero, just continue with the
+      main loop. */
+
+      if (length == 0) continue;
+
+      /* First, ensure the minimum number of matches are present. We get back
+      the length of the reference string explicitly rather than passing the
+      address of eptr, so that eptr can be a register variable. */
+
+      for (i = 1; i <= min; i++)
+        {
+        if (!match_ref(offset, eptr, length, md, ims)) return FALSE;
+        eptr += length;
+        }
+
+      /* If min = max, continue at the same level without recursion.
+      They are not both allowed to be zero. */
+
+      if (min == max) continue;
+
+      /* If minimizing, keep trying and advancing the pointer */
+
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || !match_ref(offset, eptr, length, md, ims))
+            return FALSE;
+          eptr += length;
+          }
+        /* Control never gets here */
+        }
+
+      /* If maximizing, find the longest string and work backwards */
+
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (!match_ref(offset, eptr, length, md, ims)) break;
+          eptr += length;
+          }
+        while (eptr >= pp)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          eptr -= length;
+          }
+        return FALSE;
+        }
+      }
+    /* Control never gets here */
+
+
+
+    /* Match a character class, possibly repeatedly. Look past the end of the
+    item to see if there is repeat information following. Then obey similar
+    code to character type repeats - written out again for speed. */
+
+    case OP_CLASS:
+      {
+      const uschar *data = ecode + 1;  /* Save for matching */
+      ecode += 33;                     /* Advance past the item */
+
+      switch (*ecode)
+        {
+        case OP_CRSTAR:
+        case OP_CRMINSTAR:
+        case OP_CRPLUS:
+        case OP_CRMINPLUS:
+        case OP_CRQUERY:
+        case OP_CRMINQUERY:
+        c = *ecode++ - OP_CRSTAR;
+        minimize = (c & 1) != 0;
+        min = rep_min[c];                 /* Pick up values from tables; */
+        max = rep_max[c];                 /* zero for max => infinity */
+        if (max == 0) max = INT_MAX;
+        break;
+
+        case OP_CRRANGE:
+        case OP_CRMINRANGE:
+        minimize = (*ecode == OP_CRMINRANGE);
+        min = (ecode[1] << 8) + ecode[2];
+        max = (ecode[3] << 8) + ecode[4];
+        if (max == 0) max = INT_MAX;
+        ecode += 5;
+        break;
+
+        default:               /* No repeat follows */
+        min = max = 1;
+        break;
+        }
+
+      /* First, ensure the minimum number of matches are present. */
+
+      for (i = 1; i <= min; i++)
+        {
+        if (eptr >= md->end_subject) return FALSE;
+        GETCHARINC(c, eptr)         /* Get character; increment eptr */
+
+#ifdef SUPPORT_UTF8
+        /* We do not yet support class members > 255 */
+        if (c > 255) return FALSE;
+#endif
+
+        if ((data[c/8] & (1 << (c&7))) != 0) continue;
+        return FALSE;
+        }
+
+      /* If max == min we can continue with the main loop without the
+      need to recurse. */
+
+      if (min == max) continue;
+
+      /* If minimizing, keep testing the rest of the expression and advancing
+      the pointer while it matches the class. */
+
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject) return FALSE;
+          GETCHARINC(c, eptr)       /* Get character; increment eptr */
+
+#ifdef SUPPORT_UTF8
+          /* We do not yet support class members > 255 */
+          if (c > 255) return FALSE;
+#endif
+          if ((data[c/8] & (1 << (c&7))) != 0) continue;
+          return FALSE;
+          }
+        /* Control never gets here */
+        }
+
+      /* If maximizing, find the longest possible run, then work backwards. */
+
+      else
+        {
+        const uschar *pp = eptr;
+        int len = 1;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject) break;
+          GETCHARLEN(c, eptr, len)  /* Get character, set length if UTF-8 */
+
+#ifdef SUPPORT_UTF8
+          /* We do not yet support class members > 255 */
+          if (c > 255) break;
+#endif
+          if ((data[c/8] & (1 << (c&7))) == 0) break;
+          eptr += len;
+          }
+
+        while (eptr >= pp)
+          {
+          if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+
+#ifdef SUPPORT_UTF8
+          BACKCHAR(eptr)
+#endif
+          }
+        return FALSE;
+        }
+      }
+    /* Control never gets here */
+
+    /* Match a run of characters */
+
+    case OP_CHARS:
+      {
+      register int length = ecode[1];
+      ecode += 2;
+
+#ifdef DEBUG    /* Sigh. Some compilers never learn. */
+      if (eptr >= md->end_subject)
+        PCRE_PRINTF("matching subject <null> against pattern ");
+      else
+        {
+        PCRE_PRINTF("matching subject ");
+        pchars(eptr, length, TRUE, md);
+        PCRE_PRINTF(" against pattern ");
+        }
+      pchars(ecode, length, FALSE, md);
+      PCRE_PRINTF("\n");
+#endif
+
+      if (length > md->end_subject - eptr) return FALSE;
+      if ((ims & PCRE_CASELESS) != 0)
+        {
+        while (length-- > 0)
+          if (md->lcc[*ecode++] != md->lcc[*eptr++])
+            return FALSE;
+        }
+      else
+        {
+        while (length-- > 0) if (*ecode++ != *eptr++) return FALSE;
+        }
+      }
+    break;
+
+    /* Match a single character repeatedly; different opcodes share code. */
+
+    case OP_EXACT:
+    min = max = (ecode[1] << 8) + ecode[2];
+    ecode += 3;
+    goto REPEATCHAR;
+
+    case OP_UPTO:
+    case OP_MINUPTO:
+    min = 0;
+    max = (ecode[1] << 8) + ecode[2];
+    minimize = *ecode == OP_MINUPTO;
+    ecode += 3;
+    goto REPEATCHAR;
+
+    case OP_STAR:
+    case OP_MINSTAR:
+    case OP_PLUS:
+    case OP_MINPLUS:
+    case OP_QUERY:
+    case OP_MINQUERY:
+    c = *ecode++ - OP_STAR;
+    minimize = (c & 1) != 0;
+    min = rep_min[c];                 /* Pick up values from tables; */
+    max = rep_max[c];                 /* zero for max => infinity */
+    if (max == 0) max = INT_MAX;
+
+    /* Common code for all repeated single-character matches. We can give
+    up quickly if there are fewer than the minimum number of characters left in
+    the subject. */
+
+    REPEATCHAR:
+    if (min > md->end_subject - eptr) return FALSE;
+    c = *ecode++;
+
+    /* The code is duplicated for the caseless and caseful cases, for speed,
+    since matching characters is likely to be quite common. First, ensure the
+    minimum number of matches are present. If min = max, continue at the same
+    level without recursing. Otherwise, if minimizing, keep trying the rest of
+    the expression and advancing one matching character if failing, up to the
+    maximum. Alternatively, if maximizing, find the maximum number of
+    characters and work backwards. */
+
+    DPRINTF(("matching %c{%d,%d} against subject %.*s\n", c, min, max,
+      max, eptr));
+
+    if ((ims & PCRE_CASELESS) != 0)
+      {
+      c = md->lcc[c];
+      for (i = 1; i <= min; i++)
+        if (c != md->lcc[*eptr++]) return FALSE;
+      if (min == max) continue;
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject ||
+              c != md->lcc[*eptr++])
+            return FALSE;
+          }
+        /* Control never gets here */
+        }
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || c != md->lcc[*eptr]) break;
+          eptr++;
+          }
+        while (eptr >= pp)
+          if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+        return FALSE;
+        }
+      /* Control never gets here */
+      }
+
+    /* Caseful comparisons */
+
+    else
+      {
+      for (i = 1; i <= min; i++) if (c != *eptr++) return FALSE;
+      if (min == max) continue;
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject || c != *eptr++) return FALSE;
+          }
+        /* Control never gets here */
+        }
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || c != *eptr) break;
+          eptr++;
+          }
+        while (eptr >= pp)
+         if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+           return TRUE;
+        return FALSE;
+        }
+      }
+    /* Control never gets here */
+
+    /* Match a negated single character */
+
+    case OP_NOT:
+    if (eptr >= md->end_subject) return FALSE;
+    ecode++;
+    if ((ims & PCRE_CASELESS) != 0)
+      {
+      if (md->lcc[*ecode++] == md->lcc[*eptr++]) return FALSE;
+      }
+    else
+      {
+      if (*ecode++ == *eptr++) return FALSE;
+      }
+    break;
+
+    /* Match a negated single character repeatedly. This is almost a repeat of
+    the code for a repeated single character, but I haven't found a nice way of
+    commoning these up that doesn't require a test of the positive/negative
+    option for each character match. Maybe that wouldn't add very much to the
+    time taken, but character matching *is* what this is all about... */
+
+    case OP_NOTEXACT:
+    min = max = (ecode[1] << 8) + ecode[2];
+    ecode += 3;
+    goto REPEATNOTCHAR;
+
+    case OP_NOTUPTO:
+    case OP_NOTMINUPTO:
+    min = 0;
+    max = (ecode[1] << 8) + ecode[2];
+    minimize = *ecode == OP_NOTMINUPTO;
+    ecode += 3;
+    goto REPEATNOTCHAR;
+
+    case OP_NOTSTAR:
+    case OP_NOTMINSTAR:
+    case OP_NOTPLUS:
+    case OP_NOTMINPLUS:
+    case OP_NOTQUERY:
+    case OP_NOTMINQUERY:
+    c = *ecode++ - OP_NOTSTAR;
+    minimize = (c & 1) != 0;
+    min = rep_min[c];                 /* Pick up values from tables; */
+    max = rep_max[c];                 /* zero for max => infinity */
+    if (max == 0) max = INT_MAX;
+
+    /* Common code for all repeated single-character matches. We can give
+    up quickly if there are fewer than the minimum number of characters left in
+    the subject. */
+
+    REPEATNOTCHAR:
+    if (min > md->end_subject - eptr) return FALSE;
+    c = *ecode++;
+
+    /* The code is duplicated for the caseless and caseful cases, for speed,
+    since matching characters is likely to be quite common. First, ensure the
+    minimum number of matches are present. If min = max, continue at the same
+    level without recursing. Otherwise, if minimizing, keep trying the rest of
+    the expression and advancing one matching character if failing, up to the
+    maximum. Alternatively, if maximizing, find the maximum number of
+    characters and work backwards. */
+
+    DPRINTF(("negative matching %c{%d,%d} against subject %.*s\n", c, min, max,
+      max, eptr));
+
+    if ((ims & PCRE_CASELESS) != 0)
+      {
+      c = md->lcc[c];
+      for (i = 1; i <= min; i++)
+        if (c == md->lcc[*eptr++]) return FALSE;
+      if (min == max) continue;
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject ||
+              c == md->lcc[*eptr++])
+            return FALSE;
+          }
+        /* Control never gets here */
+        }
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || c == md->lcc[*eptr]) break;
+          eptr++;
+          }
+        while (eptr >= pp)
+          if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+        return FALSE;
+        }
+      /* Control never gets here */
+      }
+
+    /* Caseful comparisons */
+
+    else
+      {
+      for (i = 1; i <= min; i++) if (c == *eptr++) return FALSE;
+      if (min == max) continue;
+      if (minimize)
+        {
+        for (i = min;; i++)
+          {
+          if (match(eptr, ecode, offset_top, md, ims, eptrb, 0))
+            return TRUE;
+          if (i >= max || eptr >= md->end_subject || c == *eptr++) return FALSE;
+          }
+        /* Control never gets here */
+        }
+      else
+        {
+        const uschar *pp = eptr;
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || c == *eptr) break;
+          eptr++;
+          }
+        while (eptr >= pp)
+         if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+           return TRUE;
+        return FALSE;
+        }
+      }
+    /* Control never gets here */
+
+    /* Match a single character type repeatedly; several different opcodes
+    share code. This is very similar to the code for single characters, but we
+    repeat it in the interests of efficiency. */
+
+    case OP_TYPEEXACT:
+    min = max = (ecode[1] << 8) + ecode[2];
+    minimize = TRUE;
+    ecode += 3;
+    goto REPEATTYPE;
+
+    case OP_TYPEUPTO:
+    case OP_TYPEMINUPTO:
+    min = 0;
+    max = (ecode[1] << 8) + ecode[2];
+    minimize = *ecode == OP_TYPEMINUPTO;
+    ecode += 3;
+    goto REPEATTYPE;
+
+    case OP_TYPESTAR:
+    case OP_TYPEMINSTAR:
+    case OP_TYPEPLUS:
+    case OP_TYPEMINPLUS:
+    case OP_TYPEQUERY:
+    case OP_TYPEMINQUERY:
+    c = *ecode++ - OP_TYPESTAR;
+    minimize = (c & 1) != 0;
+    min = rep_min[c];                 /* Pick up values from tables; */
+    max = rep_max[c];                 /* zero for max => infinity */
+    if (max == 0) max = INT_MAX;
+
+    /* Common code for all repeated single character type matches */
+
+    REPEATTYPE:
+    ctype = *ecode++;      /* Code for the character type */
+
+    /* First, ensure the minimum number of matches are present. Use inline
+    code for maximizing the speed, and do the type test once at the start
+    (i.e. keep it out of the loop). Also we can test that there are at least
+    the minimum number of bytes before we start, except when doing '.' in
+    UTF8 mode. Leave the test in in all cases; in the special case we have
+    to test after each character. */
+
+    if (min > md->end_subject - eptr) return FALSE;
+    if (min > 0) switch(ctype)
+      {
+      case OP_ANY:
+#ifdef SUPPORT_UTF8
+      if (md->utf8)
+        {
+        for (i = 1; i <= min; i++)
+          {
+          if (eptr >= md->end_subject ||
+             (*eptr++ == NEWLINE && (ims & PCRE_DOTALL) == 0))
+            return FALSE;
+          while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+          }
+        break;
+        }
+#endif
+      /* Non-UTF8 can be faster */
+      if ((ims & PCRE_DOTALL) == 0)
+        { for (i = 1; i <= min; i++) if (*eptr++ == NEWLINE) return FALSE; }
+      else eptr += min;
+      break;
+
+      case OP_NOT_DIGIT:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_digit) != 0) return FALSE;
+      break;
+
+      case OP_DIGIT:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_digit) == 0) return FALSE;
+      break;
+
+      case OP_NOT_WHITESPACE:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_space) != 0) return FALSE;
+      break;
+
+      case OP_WHITESPACE:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_space) == 0) return FALSE;
+      break;
+
+      case OP_NOT_WORDCHAR:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_word) != 0)
+          return FALSE;
+      break;
+
+      case OP_WORDCHAR:
+      for (i = 1; i <= min; i++)
+        if ((md->ctypes[*eptr++] & ctype_word) == 0)
+          return FALSE;
+      break;
+      }
+
+    /* If min = max, continue at the same level without recursing */
+
+    if (min == max) continue;
+
+    /* If minimizing, we have to test the rest of the pattern before each
+    subsequent match. */
+
+    if (minimize)
+      {
+      for (i = min;; i++)
+        {
+        if (match(eptr, ecode, offset_top, md, ims, eptrb, 0)) return TRUE;
+        if (i >= max || eptr >= md->end_subject) return FALSE;
+
+        c = *eptr++;
+        switch(ctype)
+          {
+          case OP_ANY:
+          if ((ims & PCRE_DOTALL) == 0 && c == NEWLINE) return FALSE;
+#ifdef SUPPORT_UTF8
+          if (md->utf8)
+            while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+#endif
+          break;
+
+          case OP_NOT_DIGIT:
+          if ((md->ctypes[c] & ctype_digit) != 0) return FALSE;
+          break;
+
+          case OP_DIGIT:
+          if ((md->ctypes[c] & ctype_digit) == 0) return FALSE;
+          break;
+
+          case OP_NOT_WHITESPACE:
+          if ((md->ctypes[c] & ctype_space) != 0) return FALSE;
+          break;
+
+          case OP_WHITESPACE:
+          if  ((md->ctypes[c] & ctype_space) == 0) return FALSE;
+          break;
+
+          case OP_NOT_WORDCHAR:
+          if ((md->ctypes[c] & ctype_word) != 0) return FALSE;
+          break;
+
+          case OP_WORDCHAR:
+          if ((md->ctypes[c] & ctype_word) == 0) return FALSE;
+          break;
+          }
+        }
+      /* Control never gets here */
+      }
+
+    /* If maximizing it is worth using inline code for speed, doing the type
+    test once at the start (i.e. keep it out of the loop). */
+
+    else
+      {
+      const uschar *pp = eptr;
+      switch(ctype)
+        {
+        case OP_ANY:
+
+        /* Special code is required for UTF8, but when the maximum is unlimited
+        we don't need it. */
+
+#ifdef SUPPORT_UTF8
+        if (md->utf8 && max < INT_MAX)
+          {
+          if ((ims & PCRE_DOTALL) == 0)
+            {
+            for (i = min; i < max; i++)
+              {
+              if (eptr >= md->end_subject || *eptr++ == NEWLINE) break;
+              while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+              }
+            }
+          else
+            {
+            for (i = min; i < max; i++)
+              {
+              eptr++;
+              while (eptr < md->end_subject && (*eptr & 0xc0) == 0x80) eptr++;
+              }
+            }
+          break;
+          }
+#endif
+        /* Non-UTF8 can be faster */
+        if ((ims & PCRE_DOTALL) == 0)
+          {
+          for (i = min; i < max; i++)
+            {
+            if (eptr >= md->end_subject || *eptr == NEWLINE) break;
+            eptr++;
+            }
+          }
+        else
+          {
+          c = max - min;
+          if (c > md->end_subject - eptr) c = md->end_subject - eptr;
+          eptr += c;
+          }
+        break;
+
+        case OP_NOT_DIGIT:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) != 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_DIGIT:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) == 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_NOT_WHITESPACE:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) != 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_WHITESPACE:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) == 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_NOT_WORDCHAR:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) != 0)
+            break;
+          eptr++;
+          }
+        break;
+
+        case OP_WORDCHAR:
+        for (i = min; i < max; i++)
+          {
+          if (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) == 0)
+            break;
+          eptr++;
+          }
+        break;
+        }
+
+      while (eptr >= pp)
+        {
+        if (match(eptr--, ecode, offset_top, md, ims, eptrb, 0))
+          return TRUE;
+#ifdef SUPPORT_UTF8
+        if (md->utf8)
+          while (eptr > pp && (*eptr & 0xc0) == 0x80) eptr--;
+#endif
+        }
+      return FALSE;
+      }
+    /* Control never gets here */
+
+    /* There's been some horrible disaster. */
+
+    default:
+    DPRINTF(("Unknown opcode %d\n", *ecode));
+    md->errorcode = PCRE_ERROR_UNKNOWN_NODE;
+    return FALSE;
+    }
+
+  /* Do not stick any code in here without much thought; it is assumed
+  that "continue" in the code above comes out to here to repeat the main
+  loop. */
+
+  }             /* End of main loop */
+/* Control never reaches here */
+}
+
+
+/*************************************************
+*         Execute a Regular Expression           *
+*************************************************/
+
+/* This function applies a compiled re to a subject string and picks out
+portions of the string if it matches. Two elements in the vector are set for
+each substring: the offsets to the start and end of the substring.
+
+Arguments:
+  external_re     points to the compiled expression
+  external_extra  points to "hints" from pcre_study() or is NULL
+  subject         points to the subject string
+  length          length of subject string (may contain binary zeros)
+  start_offset    where to start in the subject string
+  options         option bits
+  offsets         points to a vector of ints to be filled in with offsets
+  offsetcount     the number of elements in the vector
+
+Returns:          > 0 => success; value is the number of elements filled in
+                  = 0 => success, but offsets is not big enough
+                   -1 => failed to match
+                 < -1 => some kind of unexpected problem
+*/
+
+int
+pcre_exec(const pcre *external_re, const pcre_extra *external_extra,
+  const char *subject, int length, int start_offset, int options, int *offsets,
+  int offsetcount)
+{
+int resetcount, ocount;
+int first_char = -1;
+int req_char = -1;
+int req_char2 = -1;
+unsigned long int ims = 0;
+match_data match_block;
+const uschar *start_bits = NULL;
+const uschar *start_match = (const uschar *)subject + start_offset;
+const uschar *end_subject;
+const uschar *req_char_ptr = start_match - 1;
+const real_pcre *re = (const real_pcre *)external_re;
+const real_pcre_extra *extra = (const real_pcre_extra *)external_extra;
+BOOL using_temporary_offsets = FALSE;
+BOOL anchored;
+BOOL startline;
+
+if ((options & ~PUBLIC_EXEC_OPTIONS) != 0) return PCRE_ERROR_BADOPTION;
+
+if (re == NULL || subject == NULL ||
+   (offsets == NULL && offsetcount > 0)) return PCRE_ERROR_NULL;
+if (re->magic_number != MAGIC_NUMBER) return PCRE_ERROR_BADMAGIC;
+
+anchored = ((re->options | options) & PCRE_ANCHORED) != 0;
+startline = (re->options & PCRE_STARTLINE) != 0;
+
+match_block.start_pattern = re->code;
+match_block.start_subject = (const uschar *)subject;
+match_block.end_subject = match_block.start_subject + length;
+end_subject = match_block.end_subject;
+
+match_block.endonly = (re->options & PCRE_DOLLAR_ENDONLY) != 0;
+match_block.utf8 = (re->options & PCRE_UTF8) != 0;
+
+match_block.notbol = (options & PCRE_NOTBOL) != 0;
+match_block.noteol = (options & PCRE_NOTEOL) != 0;
+match_block.notempty = (options & PCRE_NOTEMPTY) != 0;
+
+match_block.errorcode = PCRE_ERROR_NOMATCH;     /* Default error */
+
+match_block.lcc = re->tables + lcc_offset;
+match_block.ctypes = re->tables + ctypes_offset;
+
+/* The ims options can vary during the matching as a result of the presence
+of (?ims) items in the pattern. They are kept in a local variable so that
+restoring at the exit of a group is easy. */
+
+ims = re->options & (PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL);
+
+/* If the expression has got more back references than the offsets supplied can
+hold, we get a temporary bit of working store to use during the matching.
+Otherwise, we can use the vector supplied, rounding down its size to a multiple
+of 3. */
+
+ocount = offsetcount - (offsetcount % 3);
+
+if (re->top_backref > 0 && re->top_backref >= ocount/3)
+  {
+  ocount = re->top_backref * 3 + 3;
+  match_block.offset_vector = (int *)(pcre_malloc)(ocount * sizeof(int));
+  if (match_block.offset_vector == NULL) return PCRE_ERROR_NOMEMORY;
+  using_temporary_offsets = TRUE;
+  DPRINTF(("Got memory to hold back references\n"));
+  }
+else match_block.offset_vector = offsets;
+
+match_block.offset_end = ocount;
+match_block.offset_max = (2*ocount)/3;
+match_block.offset_overflow = FALSE;
+
+/* Compute the minimum number of offsets that we need to reset each time. Doing
+this makes a huge difference to execution time when there aren't many brackets
+in the pattern. */
+
+resetcount = 2 + re->top_bracket * 2;
+if (resetcount > offsetcount) resetcount = ocount;
+
+/* Reset the working variable associated with each extraction. These should
+never be used unless previously set, but they get saved and restored, and so we
+initialize them to avoid reading uninitialized locations. */
+
+if (match_block.offset_vector != NULL)
+  {
+  register int *iptr = match_block.offset_vector + ocount;
+  register int *iend = iptr - resetcount/2 + 1;
+  while (--iptr >= iend) *iptr = -1;
+  }
+
+/* Set up the first character to match, if available. The first_char value is
+never set for an anchored regular expression, but the anchoring may be forced
+at run time, so we have to test for anchoring. The first char may be unset for
+an unanchored pattern, of course. If there's no first char and the pattern was
+studied, there may be a bitmap of possible first characters. */
+
+if (!anchored)
+  {
+  if ((re->options & PCRE_FIRSTSET) != 0)
+    {
+    first_char = re->first_char;
+    if ((ims & PCRE_CASELESS) != 0) first_char = match_block.lcc[first_char];
+    }
+  else
+    if (!startline && extra != NULL &&
+      (extra->options & PCRE_STUDY_MAPPED) != 0)
+        start_bits = extra->start_bits;
+  }
+
+/* For anchored or unanchored matches, there may be a "last known required
+character" set. If the PCRE_CASELESS is set, implying that the match starts
+caselessly, or if there are any changes of this flag within the regex, set up
+both cases of the character. Otherwise set the two values the same, which will
+avoid duplicate testing (which takes significant time). This covers the vast
+majority of cases. It will be suboptimal when the case flag changes in a regex
+and the required character in fact is caseful. */
+
+if ((re->options & PCRE_REQCHSET) != 0)
+  {
+  req_char = re->req_char;
+  req_char2 = ((re->options & (PCRE_CASELESS | PCRE_ICHANGED)) != 0)?
+    (re->tables + fcc_offset)[req_char] : req_char;
+  }
+
+/* Loop for handling unanchored repeated matching attempts; for anchored regexs
+the loop runs just once. */
+
+do
+  {
+  int rc;
+  register int *iptr = match_block.offset_vector;
+  register int *iend = iptr + resetcount;
+
+  /* Reset the maximum number of extractions we might see. */
+
+  while (iptr < iend) *iptr++ = -1;
+
+  /* Advance to a unique first char if possible */
+
+  if (first_char >= 0)
+    {
+    if ((ims & PCRE_CASELESS) != 0)
+      while (start_match < end_subject &&
+             match_block.lcc[*start_match] != first_char)
+        start_match++;
+    else
+      while (start_match < end_subject && *start_match != first_char)
+        start_match++;
+    }
+
+  /* Or to just after \n for a multiline match if possible */
+
+  else if (startline)
+    {
+    if (start_match > match_block.start_subject + start_offset)
+      {
+      while (start_match < end_subject && start_match[-1] != NEWLINE)
+        start_match++;
+      }
+    }
+
+  /* Or to a non-unique first char after study */
+
+  else if (start_bits != NULL)
+    {
+    while (start_match < end_subject)
+      {
+      register int c = *start_match;
+      if ((start_bits[c/8] & (1 << (c&7))) == 0) start_match++; else break;
+      }
+    }
+
+#ifdef DEBUG  /* Sigh. Some compilers never learn. */
+  PCRE_PRINTF(">>>> Match against: ");
+  pchars(start_match, end_subject - start_match, TRUE, &match_block);
+  PCRE_PRINTF("\n");
+#endif
+
+  /* If req_char is set, we know that that character must appear in the subject
+  for the match to succeed. If the first character is set, req_char must be
+  later in the subject; otherwise the test starts at the match point. This
+  optimization can save a huge amount of backtracking in patterns with nested
+  unlimited repeats that aren't going to match. We don't know what the state of
+  case matching may be when this character is hit, so test for it in both its
+  cases if necessary. However, the different cased versions will not be set up
+  unless PCRE_CASELESS was given or the casing state changes within the regex.
+  Writing separate code makes it go faster, as does using an autoincrement and
+  backing off on a match. */
+
+  if (req_char >= 0)
+    {
+    register const uschar *p = start_match + ((first_char >= 0)? 1 : 0);
+
+    /* We don't need to repeat the search if we haven't yet reached the
+    place we found it at last time. */
+
+    if (p > req_char_ptr)
+      {
+      /* Do a single test if no case difference is set up */
+
+      if (req_char == req_char2)
+        {
+        while (p < end_subject)
+          {
+          if (*p++ == req_char) { p--; break; }
+          }
+        }
+
+      /* Otherwise test for either case */
+
+      else
+        {
+        while (p < end_subject)
+          {
+          register int pp = *p++;
+          if (pp == req_char || pp == req_char2) { p--; break; }
+          }
+        }
+
+      /* If we can't find the required character, break the matching loop */
+
+      if (p >= end_subject) break;
+
+      /* If we have found the required character, save the point where we
+      found it, so that we don't search again next time round the loop if
+      the start hasn't passed this character yet. */
+
+      req_char_ptr = p;
+      }
+    }
+
+  /* When a match occurs, substrings will be set for all internal extractions;
+  we just need to set up the whole thing as substring 0 before returning. If
+  there were too many extractions, set the return code to zero. In the case
+  where we had to get some local store to hold offsets for backreferences, copy
+  those back references that we can. In this case there need not be overflow
+  if certain parts of the pattern were not used. */
+
+  match_block.start_match = start_match;
+  if (!match(start_match, re->code, 2, &match_block, ims, NULL, match_isgroup))
+    continue;
+
+  /* Copy the offset information from temporary store if necessary */
+
+  if (using_temporary_offsets)
+    {
+    if (offsetcount >= 4)
+      {
+      memcpy(offsets + 2, match_block.offset_vector + 2,
+        (offsetcount - 2) * sizeof(int));
+      DPRINTF(("Copied offsets from temporary memory\n"));
+      }
+    if (match_block.end_offset_top > offsetcount)
+      match_block.offset_overflow = TRUE;
+
+    DPRINTF(("Freeing temporary memory\n"));
+    (pcre_free)(match_block.offset_vector);
+    }
+
+  rc = match_block.offset_overflow? 0 : match_block.end_offset_top/2;
+
+  if (offsetcount < 2) rc = 0; else
+    {
+    offsets[0] = start_match - match_block.start_subject;
+    offsets[1] = match_block.end_match_ptr - match_block.start_subject;
+    }
+
+  DPRINTF((">>>> returning %d\n", rc));
+  return rc;
+  }
+
+/* This "while" is the end of the "do" above */
+
+while (!anchored &&
+       match_block.errorcode == PCRE_ERROR_NOMATCH &&
+       start_match++ < end_subject);
+
+if (using_temporary_offsets)
+  {
+  DPRINTF(("Freeing temporary memory\n"));
+  (pcre_free)(match_block.offset_vector);
+  }
+
+DPRINTF((">>>> returning %d\n", match_block.errorcode));
+
+return match_block.errorcode;
+}
+
+/* End of pcre.c */
diff -uNrp linux-2.6.11/security/subdomain/pcre_exec.h linux-2.6.11.subd-new/security/subdomain/pcre_exec.h
--- linux-2.6.11/security/subdomain/pcre_exec.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/pcre_exec.h	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,309 @@
+/*  
+ *  This is a modified header file containing the definitions from
+ *  pcre.h and internal.h required to support pcre_exec() 
+ */
+
+
+/*************************************************
+*       Perl-Compatible Regular Expressions      *
+*************************************************/
+
+/* Copyright (c) 1997-2001 University of Cambridge */
+
+#ifndef _PCRE_H
+#define _PCRE_H
+
+/* ----- CODE ADDED ---- */
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/slab.h>	// for kmalloc/kfree
+#endif
+
+#ifdef __KERNEL__
+#define PCRE_PRINTF printk
+#define isprint(x) ((unsigned char)(x) >= 128 && (unsigned char)(x) <= 255)
+#else
+#define PCRE_PRINTF printf
+#endif
+
+/* The value of NEWLINE determines the newline character. The default is to
+ * leave it up to the compiler, but some sites want to force a particular value.
+ * On Unix systems, "configure" can be used to override this default. */
+
+#ifndef NEWLINE
+#define NEWLINE '\n'
+#endif
+
+/* ----  CODE DELETED ---- */
+
+/* Options */
+
+#define PCRE_CASELESS        0x0001
+#define PCRE_MULTILINE       0x0002
+#define PCRE_DOTALL          0x0004
+#define PCRE_EXTENDED        0x0008
+#define PCRE_ANCHORED        0x0010
+#define PCRE_DOLLAR_ENDONLY  0x0020
+#define PCRE_EXTRA           0x0040
+#define PCRE_NOTBOL          0x0080
+#define PCRE_NOTEOL          0x0100
+#define PCRE_UNGREEDY        0x0200
+#define PCRE_NOTEMPTY        0x0400
+#define PCRE_UTF8            0x0800
+
+/* Exec-time and get-time error codes */
+
+#define PCRE_ERROR_NOMATCH        (-1)
+#define PCRE_ERROR_NULL           (-2)
+#define PCRE_ERROR_BADOPTION      (-3)
+#define PCRE_ERROR_BADMAGIC       (-4)
+#define PCRE_ERROR_UNKNOWN_NODE   (-5)
+#define PCRE_ERROR_NOMEMORY       (-6)
+#define PCRE_ERROR_NOSUBSTRING    (-7)
+
+/* ----  CODE DELETED ---- */
+
+/* Types */
+
+struct real_pcre;        /* declaration; the definition is private  */
+struct real_pcre_extra;  /* declaration; the definition is private */
+
+typedef struct real_pcre pcre;
+typedef struct real_pcre_extra pcre_extra;
+
+/* ----  CODE DELETED ---- */
+
+extern int pcre_exec(const pcre *, const pcre_extra *,
+		     const char *, int, int, int, int *,
+		     int);
+
+/* ----  CODE ADDED (from internal.h) ---- */
+
+/* These are the public options that can change during matching. */
+
+#define PCRE_IMS (PCRE_CASELESS|PCRE_MULTILINE|PCRE_DOTALL)
+
+/* Private options flags start at the most significant end of the four bytes,
+but skip the top bit so we can use ints for convenience without getting tangled
+with negative values. The public options defined in pcre.h start at the least
+significant end. Make sure they don't overlap, though now that we have expanded
+to four bytes there is plenty of space. */
+
+#define PCRE_FIRSTSET      0x40000000  /* first_char is set */
+#define PCRE_REQCHSET      0x20000000  /* req_char is set */
+#define PCRE_STARTLINE     0x10000000  /* start after \n for multiline */
+#define PCRE_ICHANGED      0x04000000  /* i option changes within regex */
+
+/* Options for the "extra" block produced by pcre_study(). */
+
+#define PCRE_STUDY_MAPPED   0x01     /* a map of starting chars exists */
+
+/* Masks for identifying the public options which are permitted at compile
+time, run time or study time, respectively. */
+
+#define PUBLIC_EXEC_OPTIONS \
+    (PCRE_ANCHORED|PCRE_NOTBOL|PCRE_NOTEOL|PCRE_NOTEMPTY)
+
+/* Magic number to provide a small check against being handed junk. */
+
+#define MAGIC_NUMBER  0x50435245UL   /* 'PCRE' */
+
+typedef int BOOL;
+
+#define FALSE   0
+#define TRUE    1
+
+/* Opcode table: OP_BRA must be last, as all values >= it are used for brackets
+that extract substrings. Starting from 1 (i.e. after OP_END), the values up to
+OP_EOD must correspond in order to the list of escapes immediately above. */
+
+enum {
+  OP_END,            /* End of pattern */
+
+  /* Values corresponding to backslashed metacharacters */
+
+  OP_SOD,            /* Start of data: \A */
+  OP_NOT_WORD_BOUNDARY,  /* \B */
+  OP_WORD_BOUNDARY,      /* \b */
+  OP_NOT_DIGIT,          /* \D */
+  OP_DIGIT,              /* \d */
+  OP_NOT_WHITESPACE,     /* \S */
+  OP_WHITESPACE,         /* \s */
+  OP_NOT_WORDCHAR,       /* \W */
+  OP_WORDCHAR,           /* \w */
+  OP_EODN,           /* End of data or \n at end of data: \Z. */
+  OP_EOD,            /* End of data: \z */
+
+  OP_OPT,            /* Set runtime options */
+  OP_CIRC,           /* Start of line - varies with multiline switch */
+  OP_DOLL,           /* End of line - varies with multiline switch */
+  OP_ANY,            /* Match any character */
+  OP_CHARS,          /* Match string of characters */
+  OP_NOT,            /* Match anything but the following char */
+
+  OP_STAR,           /* The maximizing and minimizing versions of */
+  OP_MINSTAR,        /* all these opcodes must come in pairs, with */
+  OP_PLUS,           /* the minimizing one second. */
+  OP_MINPLUS,        /* This first set applies to single characters */
+  OP_QUERY,
+  OP_MINQUERY,
+  OP_UPTO,           /* From 0 to n matches */
+  OP_MINUPTO,
+  OP_EXACT,          /* Exactly n matches */
+
+  OP_NOTSTAR,        /* The maximizing and minimizing versions of */
+  OP_NOTMINSTAR,     /* all these opcodes must come in pairs, with */
+  OP_NOTPLUS,        /* the minimizing one second. */
+  OP_NOTMINPLUS,     /* This first set applies to "not" single characters */
+  OP_NOTQUERY,
+  OP_NOTMINQUERY,
+  OP_NOTUPTO,        /* From 0 to n matches */
+  OP_NOTMINUPTO,
+  OP_NOTEXACT,       /* Exactly n matches */
+
+  OP_TYPESTAR,       /* The maximizing and minimizing versions of */
+  OP_TYPEMINSTAR,    /* all these opcodes must come in pairs, with */
+  OP_TYPEPLUS,       /* the minimizing one second. These codes must */
+  OP_TYPEMINPLUS,    /* be in exactly the same order as those above. */
+  OP_TYPEQUERY,      /* This set applies to character types such as \d */
+  OP_TYPEMINQUERY,
+  OP_TYPEUPTO,       /* From 0 to n matches */
+  OP_TYPEMINUPTO,
+  OP_TYPEEXACT,      /* Exactly n matches */
+
+  OP_CRSTAR,         /* The maximizing and minimizing versions of */
+  OP_CRMINSTAR,      /* all these opcodes must come in pairs, with */
+  OP_CRPLUS,         /* the minimizing one second. These codes must */
+  OP_CRMINPLUS,      /* be in exactly the same order as those above. */
+  OP_CRQUERY,        /* These are for character classes and back refs */
+  OP_CRMINQUERY,
+  OP_CRRANGE,        /* These are different to the three seta above. */
+  OP_CRMINRANGE,
+
+  OP_CLASS,          /* Match a character class */
+  OP_REF,            /* Match a back reference */
+  OP_RECURSE,        /* Match this pattern recursively */
+
+  OP_ALT,            /* Start of alternation */
+  OP_KET,            /* End of group that doesn't have an unbounded repeat */
+  OP_KETRMAX,        /* These two must remain together and in this */
+  OP_KETRMIN,        /* order. They are for groups the repeat for ever. */
+
+  /* The assertions must come before ONCE and COND */
+
+  OP_ASSERT,         /* Positive lookahead */
+  OP_ASSERT_NOT,     /* Negative lookahead */
+  OP_ASSERTBACK,     /* Positive lookbehind */
+  OP_ASSERTBACK_NOT, /* Negative lookbehind */
+  OP_REVERSE,        /* Move pointer back - used in lookbehind assertions */
+
+  /* ONCE and COND must come after the assertions, with ONCE first, as there's
+  a test for >= ONCE for a subpattern that isn't an assertion. */
+
+  OP_ONCE,           /* Once matched, don't back up into the subpattern */
+  OP_COND,           /* Conditional group */
+  OP_CREF,           /* Used to hold an extraction string number (cond ref) */
+
+  OP_BRAZERO,        /* These two must remain together and in this */
+  OP_BRAMINZERO,     /* order. */
+
+  OP_BRANUMBER,      /* Used for extracting brackets whose number is greater
+                        than can fit into an opcode. */
+
+  OP_BRA             /* This and greater values are used for brackets that
+                        extract substrings up to a basic limit. After that,
+                        use is made of OP_BRANUMBER. */
+};
+
+/* The highest extraction number before we have to start using additional
+bytes. (Originally PCRE didn't have support for extraction counts highter than
+this number.) The value is limited by the number of opcodes left after OP_BRA,
+i.e. 255 - OP_BRA. We actually set it a bit lower to leave room for additional
+opcodes. */
+
+#define EXTRACT_BASIC_MAX  150
+
+/* All character handling must be done as unsigned characters. Otherwise there
+are problems with top-bit-set characters and functions such as isspace().
+However, we leave the interface to the outside world as char *, because that
+should make things easier for callers. We define a short type for unsigned char
+to save lots of typing. I tried "uchar", but it causes problems on Digital
+Unix, where it is defined in sys/types, so use "uschar" instead. */
+
+typedef unsigned char uschar;
+
+/* The real format of the start of the pcre block; the actual code vector
+runs on as long as necessary after the end. */
+
+typedef struct real_pcre {
+  unsigned long int magic_number;
+  size_t size;
+  const unsigned char *tables;
+  unsigned long int options;
+  unsigned short int top_bracket;
+  unsigned short int top_backref;
+  uschar first_char;
+  uschar req_char;
+  uschar code[1];
+} real_pcre;
+
+/* The real format of the extra block returned by pcre_study(). */
+
+typedef struct real_pcre_extra {
+  uschar options;
+  uschar start_bits[32];
+} real_pcre_extra;
+
+/* Structure for passing "static" information around between the functions
+doing the matching, so that they are thread-safe. */
+
+typedef struct match_data {
+  int    errorcode;             /* As it says */
+  int   *offset_vector;         /* Offset vector */
+  int    offset_end;            /* One past the end */
+  int    offset_max;            /* The maximum usable for return data */
+  const uschar *lcc;            /* Points to lower casing table */
+  const uschar *ctypes;         /* Points to table of type maps */
+  BOOL   offset_overflow;       /* Set if too many extractions */
+  BOOL   notbol;                /* NOTBOL flag */
+  BOOL   noteol;                /* NOTEOL flag */
+  BOOL   utf8;                  /* UTF8 flag */
+  BOOL   endonly;               /* Dollar not before final \n */
+  BOOL   notempty;              /* Empty string match not wanted */
+  const uschar *start_pattern;  /* For use when recursing */
+  const uschar *start_subject;  /* Start of the subject string */
+  const uschar *end_subject;    /* End of the subject string */
+  const uschar *start_match;    /* Start of this match attempt */
+  const uschar *end_match_ptr;  /* Subject position at end match */
+  int    end_offset_top;        /* Highwater mark at end of match */
+} match_data;
+
+/* Bit definitions for entries in the pcre_ctypes table. */
+
+#define ctype_space   0x01
+#define ctype_letter  0x02
+#define ctype_digit   0x04
+#define ctype_xdigit  0x08
+#define ctype_word    0x10   /* alphameric or '_' */
+#define ctype_meta    0x80   /* regexp meta char or zero (end pattern) */
+
+/* Offsets for the bitmap tables in pcre_cbits. Each table contains a set
+of bits for a class map. Some classes are built by combining these tables. */
+
+#define cbit_length  320      /* Length of the cbits table */
+
+/* Offsets of the various tables from the base tables pointer, and
+total length. */
+
+#define lcc_offset      0
+#define fcc_offset    256
+
+#define fcc_offset    256
+#define cbits_offset  512
+#define ctypes_offset (cbits_offset + cbit_length)
+
+/* ----- CODE ADDED ---- */
+
+#endif // _PCRE_H
+ /* End of pcre.h */
diff -uNrp linux-2.6.11/security/subdomain/pcre_tables.h linux-2.6.11.subd-new/security/subdomain/pcre_tables.h
--- linux-2.6.11/security/subdomain/pcre_tables.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/pcre_tables.h	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,184 @@
+
+/*************************************************
+*      Perl-Compatible Regular Expressions       *
+*************************************************/
+
+/* This file is automatically written by the dftables auxiliary 
+program. If you edit it by hand, you might like to edit the Makefile to 
+prevent its ever being regenerated.
+
+This file is #included in the compilation of pcre.c to build the default
+character tables which are used when no tables are passed to the compile
+function. */
+
+static unsigned char pcre_default_tables[] = {
+
+/* This table is a lower casing table. */
+
+    0,  1,  2,  3,  4,  5,  6,  7,
+    8,  9, 10, 11, 12, 13, 14, 15,
+   16, 17, 18, 19, 20, 21, 22, 23,
+   24, 25, 26, 27, 28, 29, 30, 31,
+   32, 33, 34, 35, 36, 37, 38, 39,
+   40, 41, 42, 43, 44, 45, 46, 47,
+   48, 49, 50, 51, 52, 53, 54, 55,
+   56, 57, 58, 59, 60, 61, 62, 63,
+   64, 97, 98, 99,100,101,102,103,
+  104,105,106,107,108,109,110,111,
+  112,113,114,115,116,117,118,119,
+  120,121,122, 91, 92, 93, 94, 95,
+   96, 97, 98, 99,100,101,102,103,
+  104,105,106,107,108,109,110,111,
+  112,113,114,115,116,117,118,119,
+  120,121,122,123,124,125,126,127,
+  128,129,130,131,132,133,134,135,
+  136,137,138,139,140,141,142,143,
+  144,145,146,147,148,149,150,151,
+  152,153,154,155,156,157,158,159,
+  160,161,162,163,164,165,166,167,
+  168,169,170,171,172,173,174,175,
+  176,177,178,179,180,181,182,183,
+  184,185,186,187,188,189,190,191,
+  192,193,194,195,196,197,198,199,
+  200,201,202,203,204,205,206,207,
+  208,209,210,211,212,213,214,215,
+  216,217,218,219,220,221,222,223,
+  224,225,226,227,228,229,230,231,
+  232,233,234,235,236,237,238,239,
+  240,241,242,243,244,245,246,247,
+  248,249,250,251,252,253,254,255,
+
+/* This table is a case flipping table. */
+
+    0,  1,  2,  3,  4,  5,  6,  7,
+    8,  9, 10, 11, 12, 13, 14, 15,
+   16, 17, 18, 19, 20, 21, 22, 23,
+   24, 25, 26, 27, 28, 29, 30, 31,
+   32, 33, 34, 35, 36, 37, 38, 39,
+   40, 41, 42, 43, 44, 45, 46, 47,
+   48, 49, 50, 51, 52, 53, 54, 55,
+   56, 57, 58, 59, 60, 61, 62, 63,
+   64, 97, 98, 99,100,101,102,103,
+  104,105,106,107,108,109,110,111,
+  112,113,114,115,116,117,118,119,
+  120,121,122, 91, 92, 93, 94, 95,
+   96, 65, 66, 67, 68, 69, 70, 71,
+   72, 73, 74, 75, 76, 77, 78, 79,
+   80, 81, 82, 83, 84, 85, 86, 87,
+   88, 89, 90,123,124,125,126,127,
+  128,129,130,131,132,133,134,135,
+  136,137,138,139,140,141,142,143,
+  144,145,146,147,148,149,150,151,
+  152,153,154,155,156,157,158,159,
+  160,161,162,163,164,165,166,167,
+  168,169,170,171,172,173,174,175,
+  176,177,178,179,180,181,182,183,
+  184,185,186,187,188,189,190,191,
+  192,193,194,195,196,197,198,199,
+  200,201,202,203,204,205,206,207,
+  208,209,210,211,212,213,214,215,
+  216,217,218,219,220,221,222,223,
+  224,225,226,227,228,229,230,231,
+  232,233,234,235,236,237,238,239,
+  240,241,242,243,244,245,246,247,
+  248,249,250,251,252,253,254,255,
+
+/* This table contains bit maps for various character classes.
+Each map is 32 bytes long and the bits run from the least
+significant end of each byte. The classes that have their own
+maps are: space, xdigit, digit, upper, lower, word, graph
+print, punct, and cntrl. Other classes are built from combinations. */
+
+  0x00,0x3e,0x00,0x00,0x01,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,
+  0x7e,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0xfe,0xff,0xff,0x07,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0x07,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x03,
+  0xfe,0xff,0xff,0x87,0xfe,0xff,0xff,0x07,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
+  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0x00,0x00,0x00,0x00,0xfe,0xff,0x00,0xfc,
+  0x01,0x00,0x00,0xf8,0x01,0x00,0x00,0x78,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+  0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+/* This table identifies various classes of character by individual bits:
+  0x01   white space character
+  0x02   letter
+  0x04   decimal digit
+  0x08   hexadecimal digit
+  0x10   alphanumeric or '_'
+  0x80   regular expression metacharacter or binary zero
+*/
+
+  0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*   0-  7 */
+  0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00, /*   8- 15 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  16- 23 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /*  24- 31 */
+  0x01,0x00,0x00,0x00,0x80,0x00,0x00,0x00, /*    - '  */
+  0x80,0x80,0x80,0x80,0x00,0x00,0x80,0x00, /*  ( - /  */
+  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c, /*  0 - 7  */
+  0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,0x80, /*  8 - ?  */
+  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  @ - G  */
+  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  H - O  */
+  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  P - W  */
+  0x12,0x12,0x12,0x80,0x00,0x00,0x80,0x10, /*  X - _  */
+  0x00,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x12, /*  ` - g  */
+  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  h - o  */
+  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12, /*  p - w  */
+  0x12,0x12,0x12,0x80,0x80,0x00,0x00,0x00, /*  x -127 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 128-135 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 136-143 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 144-151 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 152-159 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 160-167 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 168-175 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 176-183 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 184-191 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 192-199 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 200-207 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 208-215 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 216-223 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 224-231 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 232-239 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* 240-247 */
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/* 248-255 */
+
+/* End of chartables.c */
diff -uNrp linux-2.6.11/security/subdomain/subdomain.h linux-2.6.11.subd-new/security/subdomain/subdomain.h
--- linux-2.6.11/security/subdomain/subdomain.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/subdomain.h	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,293 @@
+/*
+ * Immunix SubDomain
+ *
+ *  Original 2.2 work
+ *  Copyright 1998, 1999, 2000, 2001 Wirex Communications &
+ *			Oregon Graduate Institute
+ * 
+ * 	Written by Steve Beattie <steve@wirex.net>
+ *
+ * Updated 2.4/5 work
+ * Copyright (C) 2002 WireX Communications, Inc.
+ *
+ * Ported from 2.2 by Chris Wright <chris@wirex.com>
+ *
+ */
+
+#ifndef __SUBDOMAIN_H
+#define __SUBDOMAIN_H
+
+// #define SUBDOMAIN_FS
+
+/* for IFNAMSIZ */
+#include <linux/if.h>
+#include <linux/fs.h>
+
+#include "immunix.h"
+#include "pcre_exec.h"
+
+extern int subdomain_debug;	/* 0 or 1 */
+extern int subdomain_complain;  /* 0 or 1 */
+extern int subdomain_audit;	/* 0 or 1 */
+extern int subdomain_owlsm;	/* 0 or 1 */
+
+
+#define SD_UNCONSTRAINED "unconstrained"
+
+typedef char ifname_t[IFNAMSIZ];
+
+#define PROFILE_COMPLAIN(_profile) (subdomain_complain == 1 || ((_profile) && (_profile)->flags.complain))
+
+#define SUBDOMAIN_COMPLAIN(_sd) (subdomain_complain == 1 || ((_sd) && (_sd)->active && (_sd)->active->flags.complain))
+
+#define SUBDOMAIN_AUDIT(_sd) (subdomain_audit == 1 || ((_sd) && (_sd)->active && (_sd)->active->flags.audit))
+
+/* 
+ * DEBUG remains global (no per profile flag) since it is mostly used in sysctl
+ * which is not related to profile accesses.
+ */
+
+#define SD_DEBUG(fmt, args...)						\
+	do {								\
+		if (subdomain_debug)					\
+			printk(KERN_DEBUG "SubDomain: " fmt, ##args);	\
+	} while (0)
+#define SD_INFO(fmt, args...)	printk(KERN_INFO "SubDomain: " fmt, ##args)
+#define SD_WARN(fmt, args...)	printk(KERN_WARNING "SubDomain: " fmt, ##args)
+#define SD_ERROR(fmt, args...)	printk(KERN_ERR "SubDomain: " fmt, ##args)
+
+#define ND_DEBUG(fmt, args...)						\
+	do {								\
+		if (subdomain_debug)					\
+			printk(KERN_DEBUG "NetDomain: " fmt, ##args);	\
+	} while (0)
+#define ND_INFO(fmt, args...)	printk(KERN_INFO "NetDomain: " fmt, ##args)
+#define ND_WARN(fmt, args...)	printk(KERN_WARNING "NetDomain: " fmt, ##args)
+#define ND_ERROR(fmt, args...)	printk(KERN_ERR "NetDomain: " fmt, ##args)
+
+// Lock protecting access to 'struct subdomain' accesses
+extern rwlock_t sd_lock;
+#define SD_RLOCK read_lock(&sd_lock)
+#define SD_RUNLOCK read_unlock(&sd_lock)
+#define SD_WLOCK write_lock(&sd_lock)
+#define SD_WUNLOCK write_unlock(&sd_lock)
+
+/* basic SubDomain data structures */
+
+/**
+ * sd_entry - file ACL *
+ * Each SubDomain entry describes a file and an allowed access mode.
+ */
+struct sd_entry {
+	char		*filename;
+	int		mode;	/* mode is 'or' of READ, WRITE, EXECUTE,
+			 	 * INHERIT, UNCONSTRAINED, and LIBRARY
+			 	 * (meaning don't prefetch). */
+
+	pattern_t 	pattern_type;
+	char		*regex;
+	pcre		*compiled;
+
+	struct sd_entry	*next;
+	struct sd_entry *nextp[POS_KERN_COD_FILE_MAX + 1];
+};
+
+#define SD_EXEC_MODIFIER_MASK(mask) ((mask) & (KERN_COD_EXEC_UNCONSTRAINED |\
+		      		    KERN_COD_EXEC_INHERIT |\
+		      		    KERN_COD_EXEC_PROFILE))
+
+#define SD_EXEC_MASK(mask) ((mask) & (KERN_COD_MAY_EXEC |\
+		      		    KERN_COD_EXEC_UNCONSTRAINED |\
+		      		    KERN_COD_EXEC_INHERIT |\
+		      		    KERN_COD_EXEC_PROFILE))
+
+/**
+ * nd_entry - network ACL
+ *
+ * Each NetDomain entry decribes a network based ACL.  An entry is
+ * similar to an ipchains entry.
+ */
+struct nd_entry {
+	__u32		saddr, smask;	/* source address and mask */
+	__u32		daddr, dmask;	/* dest address and mask */
+	__u16		src_port[2], dst_port[2]; /* Network byte ordered */
+	char		*iface;		/* interface */
+	int		mode;		/* mode...err, what are the modes? */
+	struct nd_entry	*next;
+	struct nd_entry *nextp[POS_KERN_COD_NET_MAX - POS_KERN_COD_NET_MIN + 1];
+};
+
+#define NET_POS_TO_INDEX(x)	(x - POS_KERN_COD_NET_MIN)
+
+/**
+ * sdprofile - basic confinement data
+ *
+ * The SubDomain profile contains the basic confinement data.  Each profile
+ * has a name and potentially a list of SubDomain and NetDomain entries
+ * (files and network access control information).  The profiles are
+ * connected in a list
+ */
+struct sdprofile {
+	char		*name;		/* profile name */
+	char		*sub_name;	/* XXX WTF? */
+
+	struct sd_entry	*file_entry;	/* file ACL */
+	struct sd_entry *file_entryp[POS_KERN_COD_FILE_MAX + 1];
+	struct nd_entry	*net_entry;	/* network ACL */
+	struct nd_entry *net_entryp[POS_KERN_COD_NET_MAX - POS_KERN_COD_NET_MIN + 1];
+	struct list_head list;		/* list of profiles */
+	struct list_head sub;		/* sub profiles, for change_hat */
+#if defined NETDOMAIN && defined NETDOMAIN_SKUSERS
+	struct list_head sk_users;	/* list of listening TCP + UDP */
+#endif
+	struct flagval   flags;		/* per profile debug flags */
+
+	int	isstale;		/* is profile stale */
+
+	int	num_file_entries;	
+	int	num_file_pentries[POS_KERN_COD_FILE_MAX + 1];
+	int	num_net_entries; 
+	int	num_net_pentries[POS_KERN_COD_NET_MAX - POS_KERN_COD_NET_MIN + 1];
+
+	kernel_cap_t	capabilities;
+
+	atomic_t	count;		/* reference count */
+};
+
+/**
+ * subdomain - a task's subdomain
+ *
+ * Contains the original profile obtained from execve() as well as the
+ * current active profile (which could change due to change_hat).  Plus
+ * the hat_magic needed during change_hat.
+ */
+struct subdomain {
+	__u32		sd_magic;	/* magic value to distinguish blobs */
+	struct sdprofile *profile;	/* The profile obtained from execve() */
+	struct sdprofile *active;	/* The current active profile */
+	__u32		sd_hat_magic;	/* used with change_hat */
+	struct list_head list;		/* list of subdomains */
+	struct task_struct *task;
+};
+
+typedef int (*sd_iter)(struct subdomain *, void *);
+
+/* sd_path_data
+ * temp (cookie) data used by sd_path_* functions, see inline.h
+ */
+struct sd_path_data {
+	struct dentry *root, *dentry;
+	struct namespace *namespace;
+	struct list_head *head, *pos;
+	int errno;
+};
+
+#ifdef NETDOMAIN
+/*
+ * netdomain, a socket's subdomain
+ * 
+ * Stored in sock->security upon socket creation to hold information
+ * necessary for netdomain.
+ *
+ * - active is used to determine when original active profile
+ *   used for connecting/accepting tcp connection has changed (changehat
+ *   or profile replacement)
+ *
+ * - tcpconntype is used to determine how the original tcp socket was
+ *   created, either via local host accepting or local host connecting
+ *   This information is used to revaluate permissions if the cached
+ *   active subdomain is determined to be different that the tasks
+ *   current subdomain.
+ */
+
+#define ND_ID_MAGIC	SD_ID_MAGIC
+
+struct netdomain {
+	__u32				nd_magic;
+	struct sdprofile		*active;
+#ifdef NETDOMAIN_SKUSERS
+	struct list_head 		sk_users_next;
+	struct sock*			sk;
+#endif
+	__u8 				iface_checked;
+	enum{nd_mode_none,
+	     nd_mode_listening,
+	     nd_mode_accepted, 
+	     nd_mode_connected} 	tcpmode;
+};
+
+#define ND_NETDOMAIN(sec)	((struct netdomain*)(sec))
+#endif /* NETDOMAIN */
+
+#define SD_SUBDOMAIN(sec)	((struct subdomain*)(sec))
+#define SD_PROFILE(sec)		((struct sdprofile*)(sec))
+
+extern struct sdprofile null_profile;
+extern struct sdprofile *null_complain_profile;
+
+/* main.c */
+extern char * __sd_get_name(struct dentry *dentry, struct vfsmount *mnt);
+extern int __nd_network_perm (struct task_struct *tsk, struct subdomain *sd, 
+		__u32 saddr, __u16 sport, __u32 daddr, __u16 dport, 
+		char * ifname, int mode);
+
+extern int nd_network_perm (struct subdomain *sd, 
+		__u32 saddr, __u16 sport, __u32 daddr, __u16 dport,
+		char * ifname, int mode);
+extern int sd_attr(struct dentry *dentry, struct subdomain *sd,  struct iattr *iattr);
+extern int sd_capability(int cap, struct subdomain *sd);
+extern int sd_perm(struct inode *inode, struct subdomain *sd, struct nameidata *nd, int mask);
+extern int sd_perm_dentry(struct dentry *dentry, struct subdomain *sd, int mask);
+extern int sd_file_perm(const char *name, struct subdomain *sd, int mask, BOOL log);
+extern int sd_link(struct dentry *link, struct dentry *target, struct subdomain *sd);
+extern int sd_symlink(struct dentry *link, const char *name, struct subdomain *sd);
+extern int sd_fork(struct task_struct *p);
+extern int sd_register(struct file *file);
+extern void sd_release(struct task_struct *p);
+extern int sd_change_hat(const char *id, __u32 hat_magic);
+extern int sd_associate_filp(struct file *filp);
+
+/* list.c */
+extern struct sdprofile * sd_profilelist_find(const char *name);
+extern void sd_profilelist_add(struct sdprofile *profile);
+extern int sd_profilelist_remove(const char *name);
+extern void sd_profilelist_release(void);
+extern struct sdprofile * sd_profilelist_replace(struct sdprofile *profile);
+extern void sd_profile_dump(struct sdprofile *);
+extern void sd_profilelist_dump(void);
+extern void sd_subdomainlist_add(struct subdomain *);
+extern int sd_subdomainlist_remove(struct subdomain *);
+extern void sd_subdomainlist_iterate(sd_iter, void *);
+extern void sd_subdomainlist_iterateremove(sd_iter, void *);
+extern void sd_subdomainlist_release(void);
+
+/* sysctl.c */
+extern void free_sdprofile(struct sdprofile *profile);
+extern int sd_sys_security(unsigned int id, unsigned call, unsigned long *args);
+extern int sd_setprocattr_changehat(char *hatinfo, size_t infosize);
+extern int sd_setprocattr_setprofile(struct task_struct *p, char *profilename, size_t profilesize);
+
+/* subdomainfs.c */
+extern struct inode * sd_new_inode(struct super_block *sb, int mode, unsigned long ino);
+extern int sd_fill_root(struct dentry * root);
+
+/* capabilities.c */
+extern char * capability_to_name(int cap);
+
+/* subdomain_version.c */
+extern const char *subdomain_version(void);
+extern const char *subdomain_version_nl(void);
+
+#if defined (PRINTK_TEMPFIX) && ( defined (CONFIG_SMP) || defined (CONFIG_PREEMPT))
+extern volatile int sd_log_buf_has_data;
+extern void dump_sdprintk (void);
+#endif
+
+#ifdef NETDOMAIN
+/* netdomain.c */
+#ifdef NETDOMAIN_SKUSERS
+extern void nd_skusers_exch(struct sdprofile *old, struct sdprofile *new, int all);
+#endif
+#endif
+
+#endif // __SUBDOMAIN_H
diff -uNrp linux-2.6.11/security/subdomain/subdomain_version.c linux-2.6.11.subd-new/security/subdomain/subdomain_version.c
--- linux-2.6.11/security/subdomain/subdomain_version.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/subdomain_version.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,28 @@
+#ifndef SUBDOMAIN_VERSION
+#error "-DSUBDOMAIN_VERSION must be specified when compiling this file"
+#endif
+
+#define SUBDOMAIN_VERSION_STR_PFX "SUBDOMAIN_VERSION="
+
+/* subdomain_version_str exists to allow a strings on module to
+ * see SUBDOMAIN_VERSION= prefix
+ */
+static const char *subdomain_version_str = SUBDOMAIN_VERSION_STR_PFX SUBDOMAIN_VERSION;
+
+/* subdomain_version_str_nl exists to allow an easy way to get a newline 
+ * terminated string without having to do dynamic memory allocation
+ */
+static const char *subdomain_version_str_nl = SUBDOMAIN_VERSION "\n";
+
+
+const char *subdomain_version(void)
+{
+const int len=sizeof(SUBDOMAIN_VERSION_STR_PFX) - 1;
+
+	return subdomain_version_str + len;
+}
+
+const char *subdomain_version_nl(void)
+{
+	return subdomain_version_str_nl;
+}
diff -uNrp linux-2.6.11/security/subdomain/subdomainfs.c linux-2.6.11.subd-new/security/subdomain/subdomainfs.c
--- linux-2.6.11/security/subdomain/subdomainfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/subdomainfs.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,628 @@
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/pagemap.h>
+#include <linux/seq_file.h>
+
+#include <asm/uaccess.h>
+#include "subdomain.h"
+#include "inline.h"
+
+#ifdef SUBDOMAIN_FS
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define CHARUSER __user char
+#else
+#define CHARUSER char
+#endif
+
+/* extern from list.c */
+extern struct seq_operations subdomainfs_profiles_op;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static struct dentry *sd_root_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nameidata);
+#else
+static struct dentry *sd_root_lookup(struct inode *dir, struct dentry *dentry);
+#endif
+static int sd_add_root_entry(struct dentry *root, const char *name, struct file_operations *fops, int access, struct inode **rinode, struct dentry **rdentry, int mode, int ino);
+static int sd_prof_open(struct inode *inode, struct file *file);
+static int sd_prof_release(struct inode *inode, struct file *file);
+static ssize_t sd_version_read(struct file *file, CHARUSER *buf, size_t size, loff_t *ppos);
+static ssize_t sd_control_read(struct file *file, CHARUSER *buf, size_t size, loff_t *ppos);
+static ssize_t sd_control_write(struct file *file, const CHARUSER *buf, size_t size, loff_t *ppos);
+
+#ifdef SD_OLD_INTERFACE
+static int sd_prof_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+#else
+/* extern from module-interface.c */
+extern ssize_t sd_file_prof_add(void *, size_t);
+extern ssize_t sd_file_prof_repl (void *, size_t);
+extern ssize_t sd_file_prof_remove (const char *, int);
+extern ssize_t sd_file_prof_debug(void *, size_t);
+
+static ssize_t sd_profile_load(struct file *f, const char *buf,
+                               size_t size, loff_t *pos);
+static ssize_t sd_profile_replace(struct file *f, const char *buf,
+                                  size_t size, loff_t *pos);
+static ssize_t sd_profile_remove(struct file *f, const char *buf,
+                                  size_t size, loff_t *pos);
+static ssize_t sd_profile_debug(struct file *f, const char *buf,
+                                size_t size, loff_t *pos);
+
+static struct file_operations subdomainfs_profile_load = {
+  .write = sd_profile_load
+};
+
+static struct file_operations subdomainfs_profile_replace = {
+  .write = sd_profile_replace
+};
+
+static struct file_operations subdomainfs_profile_remove = {
+  .write = sd_profile_remove
+};
+
+static struct file_operations subdomainfs_profile_debug = {
+  .write = sd_profile_debug
+};
+#endif // SD_OLD_INTERFACE
+
+static struct inode_operations sd_root_iops = {
+	.lookup =	sd_root_lookup,
+};
+
+static struct file_operations subdomainfs_profiles_fops = {
+	.open =		sd_prof_open,
+	.read =		seq_read,
+	.llseek =	seq_lseek,
+	.release =	sd_prof_release,
+
+#ifdef SD_OLD_INTERFACE
+	.ioctl = 	sd_prof_ioctl,
+#endif
+};
+
+static struct file_operations subdomainfs_version_fops = {
+	.read = 	sd_version_read,
+};
+
+static struct file_operations subdomainfs_control_fops = {
+	.read = 	sd_control_read,
+	.write = 	sd_control_write,
+};
+
+const char *control_debug = "debug",
+	   *control_audit = "audit",
+	   *control_complain = "complain",
+	   *control_owlsm = "owlsm";
+
+/* GLOBAL FUNCTIONS */
+struct inode * sd_new_inode(struct super_block *sb, int mode, unsigned long ino)
+{
+	struct inode *inode = new_inode(sb);
+	if (inode) {
+		inode->i_ino = ino;
+		inode->i_mode = mode;
+		inode->i_uid = inode->i_gid = 0;
+		inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
+		inode->i_blksize = PAGE_CACHE_SIZE;
+		inode->i_blocks = 0;
+		switch (mode & S_IFMT) {
+		case S_IFDIR:
+			inode->i_op = &sd_root_iops;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+			inode->i_fop = &simple_dir_operations;
+#else
+			inode->i_fop = &dcache_dir_ops;
+#endif
+			break;
+		case S_IFREG:
+			break;
+		}
+	}
+
+	return inode;
+}
+
+int sd_fill_root(struct dentry * root)
+{
+	int i, parent_index;
+	const int base_inode = 3,
+	          max_depth = 5;
+	
+	struct dentry *dirstack[max_depth],
+		      **dirstack_ptr;
+
+	struct root_entry {
+		const char *name;
+		int mode;
+		int access;
+		struct file_operations *fops;
+		struct inode *inode;
+		struct dentry *dentry;
+		int parent_index;
+	} root_entries[] = {
+		/* interface for obtaining list of profiles 
+	 	 * currently loaded 
+		 */
+		{"profiles", 		S_IFREG, 0440, &subdomainfs_profiles_fops, 0, 0, 0},
+		/* interface for obtaining version# of subdomain */
+		{"version",  		S_IFREG, 0440, &subdomainfs_version_fops, 0, 0, 0},
+		{"control",  		S_IFDIR, 0550, NULL, 0, 0, 0},
+		{control_owlsm,    	S_IFREG, 0640, &subdomainfs_control_fops, 0, 0, 0},
+		{control_complain, 	S_IFREG, 0640, &subdomainfs_control_fops, 0, 0, 0},
+		{control_audit,    	S_IFREG, 0640, &subdomainfs_control_fops, 0, 0, 0},
+		{control_debug,    	S_IFREG, 0640, &subdomainfs_control_fops, 0, 0, 0},
+		{NULL,       		S_IFDIR, 0,    NULL, 0, 0, 0},
+#ifndef SD_OLD_INTERFACE
+		{".load",    		S_IFREG, 0640, &subdomainfs_profile_load, 0, 0, 0},
+		{".replace", 		S_IFREG, 0640, &subdomainfs_profile_replace, 0, 0, 0},
+		{".remove",  		S_IFREG, 0640, &subdomainfs_profile_remove, 0, 0, 0},
+		{".debug",   		S_IFREG, 0640, &subdomainfs_profile_debug, 0, 0, 0},
+#endif // !SD_OLD_INTERFACE
+	};
+		
+	const int num_entries = sizeof(root_entries) / sizeof(struct root_entry);
+
+	parent_index=-1;
+	dirstack[0] = root;
+	dirstack_ptr = &dirstack[0];
+
+	/* zero out entries in table used to temp storage */
+	for (i=0; i<num_entries; i++){
+		root_entries[i].inode = NULL;
+		root_entries[i].dentry = NULL;
+		root_entries[i].parent_index=-1;
+	}
+		
+	for (i=0; i<num_entries; i++){		
+		root_entries[i].parent_index = parent_index;
+
+		if (root_entries[i].name){
+			if (sd_add_root_entry(*dirstack_ptr,
+				      root_entries[i].name, 
+				      root_entries[i].fops,
+				      root_entries[i].access,
+				      &root_entries[i].inode,
+				      &root_entries[i].dentry,
+				      root_entries[i].mode,
+				      base_inode + i)){
+				goto error;
+			}
+
+
+			if (root_entries[i].mode == S_IFDIR){
+				if (++dirstack_ptr - dirstack >= max_depth){
+					SD_ERROR("%s: Max directory depth (%d) for root_entry exceeded\n",
+						__FUNCTION__, max_depth);
+					goto error;
+				}
+				
+				parent_index=i;
+				*dirstack_ptr = root_entries[i].dentry;
+			}
+		}else{
+			if (root_entries[i].mode == S_IFDIR){
+				if (dirstack_ptr > dirstack){
+					--dirstack_ptr;
+					parent_index = root_entries[parent_index].parent_index;
+				}else{
+					SD_ERROR("%s: Root_entry %d invalid, stack underflow\n",
+						__FUNCTION__, i);
+				}
+			}else{
+				SD_ERROR("%s: Root_entry %d invalid, not S_IFDIR\n",
+					__FUNCTION__, i);
+				goto error;
+			}
+		}
+	}
+
+	return 0;
+
+error:
+	i = 0;
+	while (root_entries[i].inode) {
+		int index;
+
+		if (root_entries[i].mode == S_IFDIR){
+			if (root_entries[i].name){
+				// if name, defer dir free till all member
+				// files freed
+				continue;
+			}else{
+				// !name, end of directory
+				index=root_entries[i].parent_index;
+			} 
+		}else{
+			index=i;
+		}
+			
+		/* if inodes is set so is dentries */
+		iput(root_entries[index].inode);
+		dput(root_entries[index].dentry);
+		i++;
+	}
+
+	return -ENOMEM;
+}
+
+
+/* STATIC FUNCTIONS */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static struct dentry *sd_root_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nameidata)
+#else
+static struct dentry *sd_root_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	d_add(dentry, NULL);
+	return NULL;
+}
+
+#ifdef SD_OLD_INTERFACE
+static int sd_prof_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	if (_IOC_TYPE(cmd) == 0x5D){
+		return sd_sys_security(SD_ID_MAGIC, _IOC_NR(cmd), (unsigned long*) arg);	
+	}else{
+		SD_WARN("%s: Invalid ioctl %d.%d\n", 
+			__FUNCTION__,
+			_IOC_TYPE(cmd), _IOC_NR(cmd));
+		return -EINVAL;
+	}
+	SD_ERROR("%s: Invalid ioctl %d.%d\n", 
+		__FUNCTION__,
+		_IOC_TYPE(cmd), _IOC_NR(cmd));
+	return -EINVAL;
+}
+#endif //SD_OLD_INTERFACE
+
+static int sd_prof_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &subdomainfs_profiles_op);
+}
+
+static int sd_prof_release(struct inode *inode, struct file *file)
+{
+	return seq_release(inode, file);
+}
+
+static ssize_t sd_version_read(struct file *file, 
+				CHARUSER *buf, 
+				size_t size, loff_t *ppos)
+{
+const char *version = subdomain_version_nl();
+size_t maxlen = strlen(version);
+loff_t offset = *ppos;
+int err;
+
+	/* loff_t is signed */
+	if (offset < 0)
+		return -EFAULT;
+
+	if (offset >= maxlen)
+		return 0;
+
+	size = min(maxlen - (size_t)offset, size);
+
+	err = copy_to_user(buf, version + offset, size);
+
+	if (err){
+		return -EFAULT;
+	}
+
+	*ppos+=size;
+
+	return size;
+}
+
+static size_t sd_control(int rw, struct file *file, CHARUSER *buf, size_t size , loff_t *ppos)
+{
+	const unsigned char *name = file->f_dentry->d_name.name;
+	int *var = NULL;
+	char *varstr = "X\n";
+	const size_t maxlen=2;
+
+	/* loff_t is signed */
+	if (*ppos < 0)
+		return -EFAULT;
+
+	/* io from beginning only in one op */
+	if (*ppos > 0 || size == 0){
+		return 0;
+	}
+
+	if (strcmp(name, control_owlsm) == 0){
+		var = &subdomain_owlsm;
+	}else if (strcmp(name, control_debug) == 0){
+		var = &subdomain_debug;
+	}else if (strcmp(name, control_audit) == 0){
+		var = &subdomain_audit;
+	}else if (strcmp(name, control_complain) == 0){
+		var = &subdomain_complain;
+	}
+	
+	if (!var){
+		/* shouldn't be possible */
+		return	-EINVAL;
+	}
+
+	if (rw){
+		/* write value */
+
+		if (size > maxlen){
+			return -ENOSPC;
+		}
+
+		size = min(maxlen, size);
+
+		if (copy_from_user(varstr, buf, size)){
+			return -EFAULT;
+		}
+
+		if (size == 1 || (size == 2 && varstr[1] == '\n')){
+			if (*varstr == '0'){
+				*var=0;
+			}else if (*varstr == '1'){
+				*var=1;
+			}else{
+				return -EIO;
+			}
+		}else{
+			return -EIO;
+		}
+
+		SD_WARN("Control variable '%s' changed to %c\n",
+			name, *varstr);	
+	}else{
+		/* read value */
+
+		varstr[0] = *var ? '1' : '0';
+
+		size = min(maxlen, size);
+
+		if (copy_to_user(buf, varstr, size)){
+			return -EFAULT;
+		}
+	}
+
+	*ppos+=size;
+
+	return size;
+}
+
+static ssize_t sd_control_read(struct file *file, CHARUSER *buf, size_t size, loff_t *ppos)
+{
+	return sd_control(0, file, buf, size, ppos);
+}
+
+static ssize_t sd_control_write(struct file *file, const CHARUSER *buf, size_t size, loff_t *ppos)
+{
+	return sd_control(1, file, (char*)buf, size, ppos);
+}
+
+static int sd_add_root_entry(struct dentry *root, const char *name,
+		      struct file_operations *fops, int access,
+		      struct inode **rinode, struct dentry **rdentry,
+		      int mode,
+		      int ino)
+{
+	struct inode *inode=NULL;
+	struct dentry *dentry;
+	struct super_block *sb = root->d_sb;
+	struct qstr ename;
+	
+	ename.name = name;
+	ename.len = strlen(ename.name);
+	ename.hash = full_name_hash(ename.name, ename.len);
+	dentry = d_alloc(root, &ename);
+	if (!dentry)
+	  goto error;
+	inode = sd_new_inode(sb, mode | access, ino);
+	if (!inode)
+		goto error;
+	
+	/* directory ops handled in sd_new_inode */
+	if ((mode & S_IFMT) == S_IFREG){
+		inode->i_fop = fops;
+	}
+	d_add(dentry, inode);
+	*rinode = inode;
+	*rdentry = dentry;
+	return 0;
+ 
+error:
+	if (inode)
+		iput(inode);
+
+	if (dentry)
+		dput(dentry);
+	return -ENOMEM;
+}
+
+#ifndef SD_OLD_INTERFACE
+/* Profile loading, replacing, removing interface for 2.6 kernels */
+
+
+static ssize_t sd_profile_load(struct file *f, const char *buf,
+			       size_t size, loff_t *pos)
+{
+	void *data;
+	ssize_t error = -EFAULT;
+
+	if (*pos != 0) {
+		/* only writes from pos 0, that is complete writes */
+		return -ESPIPE;
+	}
+
+	/* don't allow confined processes to load profiles.  We shouldn't
+         * need this if a profile is written correctly, but just in case
+         * a mistake is made, in the profile, allowing access to
+	 * /subdomain/.load reject it here */
+	if (sd_is_confined()){
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile addition (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	if (size < 0)
+		return -EFAULT;
+  
+	data = vmalloc(size);
+	if (data == NULL) return -ENOMEM;
+
+
+	if (copy_from_user(data, buf, size)) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	error = sd_file_prof_add(data, size);
+
+ out:
+	vfree(data);
+	return error;
+}
+
+
+static ssize_t sd_profile_replace(struct file *f, const char *buf,
+				  size_t size, loff_t *pos)
+{
+	void *data;
+	ssize_t error = -EFAULT;
+
+	if (*pos != 0) {
+		/* only writes from pos 0, that is complete writes */
+		return -ESPIPE;
+	}
+
+	/* don't allow confined processes to replace profiles.  We shouldn't
+         * need this if a profile is written correctly, but just in case
+         * a mistake is made, in the profile, allowing access to
+	 * /subdomain/.replace we reject it here */
+	if (sd_is_confined()){
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile replacement (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	if (size < 0)
+		return -EFAULT;
+	
+	data = vmalloc(size);
+	if (data == NULL) return -ENOMEM;
+
+	
+	if (copy_from_user(data, buf, size)) {
+		error = -EFAULT;
+		goto out;
+	}
+  
+	error = sd_file_prof_repl(data, size);
+
+ out:
+	vfree(data);
+	return error;
+}
+
+
+static ssize_t sd_profile_remove(struct file *f, const char *buf,
+				  size_t size, loff_t *pos)
+{
+	char *data;
+	ssize_t error = -EFAULT;
+	
+	if (*pos != 0) {
+		/* only writes from pos 0, that is complete writes */
+		return -ESPIPE;
+	}
+
+	/* don't allow confined processes to remove profiles.  We shouldn't
+         * need this if a profile is written correctly, but just in case
+         * a mistake is made, in the profile, allowing access to
+	 * /subdomain/.remove we reject it here */
+	if (sd_is_confined()){
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile removal (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	if (size < 0)
+		return -EFAULT;
+	
+	data = (char *) vmalloc(size+1);
+	if (data == NULL) return -ENOMEM;
+
+	data[size] = 0;
+	if (copy_from_user(data, buf, size)) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	error = sd_file_prof_remove((char *) data, size);
+
+ out:
+	vfree(data);
+	return error;
+}
+
+
+/* given a name dump what the kernel sees the profile as */
+static ssize_t sd_profile_debug(struct file *f, const char *buf,
+				size_t size, loff_t *pos)
+{
+	void *data;
+	ssize_t error = -EFAULT;
+	
+	if (*pos != 0) {
+		/* only writes from pos 0, that is complete writes */
+		return -ESPIPE;
+	}
+
+	/* don't allow confined processes to debug profiles.  We shouldn't
+         * need this if a profile is written correctly, but just in case
+         * a mistake is made, in the profile, allowing access to
+	 * /subdomain/.debug we reject it here */
+	if (sd_is_confined()){
+		struct subdomain *sd = SD_SUBDOMAIN(current->security);
+
+		SD_WARN("REJECTING access to profile debug (%s(%d) profile %s active %s)\n",
+			current->comm, current->pid,
+			sd->profile->name, sd->active->name);
+
+		return -EPERM;
+	}
+
+	if (size < 0)
+		return -EFAULT;
+	
+	data = vmalloc(size);
+	if (data == NULL) return -ENOMEM;
+
+	if (copy_from_user(data, buf, size)) {
+		error = -EFAULT;
+		goto out;
+	}
+
+	error = sd_file_prof_debug(data, size);
+
+ out:
+	vfree(data);
+	return error;
+
+}
+#endif /* !SD_OLD_INTERFACE */
+
+#endif /* SUBDOMAIN FS */
diff -uNrp linux-2.6.11/security/subdomain/sysctl.c linux-2.6.11.subd-new/security/subdomain/sysctl.c
--- linux-2.6.11/security/subdomain/sysctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11.subd-new/security/subdomain/sysctl.c	2005-01-30 02:09:07.000000000 +0100
@@ -0,0 +1,713 @@
+/*
+ * Immunix SubDomain sysctl handling
+ *
+ * Original 2.2 work
+ * Copyright 1998, 1999, 2000, 2001 Wirex Communications &
+ *			Oregon Graduate Institute
+ * 
+ * 	Written by Steve Beattie <steve@wirex.net>
+ *
+ * Updated 2.4/5 work
+ * Copyright (C) 2002 WireX Communications, Inc.
+ *
+ * Ported from 2.2 by Chris Wright <chris@wirex.com>
+ *
+ * Ported to 2.6 by Tony Jones <tony@immunix.com>
+ * Copyright (C) 2003-2004 Immunix, Inc
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/if.h>
+#include <linux/namespace.h>
+
+#include <asm/uaccess.h>
+
+#include "subdomain.h"
+#include "immunix.h"
+
+#include "inline.h"
+
+#include "pcre_tables.h"
+
+/* inlines must be forward of there use in newer version of gcc,
+   just forward declaring with a prototype won't work anymore */
+
+/**
+ * put_name - release name obtained by get_name
+ * @name: pointer to memory allocated for name by get_name
+ *
+ * Simple wrapper for kfree.
+ */
+static inline void put_name(char *name)
+{
+	if (name){
+		kfree(name);
+	}
+}
+
+/**
+ * put_pattern - release name obtained by get_pattern
+ * @name: pointer to memory allocated for name by get_name
+ *
+ * Simple wrapper for kfree.
+ */
+static inline void put_pattern(pcre *pattern)
+{
+	if (pattern){
+		kfree(pattern);
+	}
+}
+
+static inline void put_sd_entry(struct sd_entry *entry)
+{
+	if (entry) {
+		put_name (entry->filename);
+		if (entry->pattern_type == ePatternRegex){
+			put_name(entry->regex);
+			put_pattern(entry->compiled);
+		}
+		kfree(entry);
+	}
+}
+
+/*
+ * free_sd_entry - destroy existing sd_entry 
+ */
+static inline void free_sd_entry(struct sd_entry *entry)
+{
+	if (entry) {
+		kfree(entry);
+	}
+}
+
+/**
+ * alloc_nd_entry - create new network entry
+ *
+ * Creates, zeroes and returns a new network subdomain structure.
+ * Returns NULL on failure.
+ */
+static inline struct nd_entry * alloc_nd_entry(void)
+{
+	struct nd_entry *entry;
+
+	ND_DEBUG("%s\n", __FUNCTION__);
+
+	entry = kmalloc(sizeof(struct nd_entry), GFP_KERNEL);
+	if (entry)
+		memset(entry, 0, sizeof(struct nd_entry));
+	return entry;
+}		
+
+/*
+ * free_nd_entry - destroy existing nd_entry 
+ */
+static inline void free_nd_entry(struct nd_entry * entry)
+{
+	if (entry){
+		kfree(entry);
+	}
+}
+
+/**
+ * alloc_sd_entry - create new empty sd_entry
+ *
+ * This routine allocates, initializes, and returns a new SubDomain
+ * file entry structure.  Structure is zeroed.  Returns new structure on
+ * success, NULL on failure.
+ */
+static inline struct sd_entry * alloc_sd_entry(void) 
+{
+	struct sd_entry *entry;
+
+	SD_DEBUG("%s\n", __FUNCTION__);
+	entry = kmalloc(sizeof(struct sd_entry) , GFP_KERNEL);
+	if (entry)
+		memset(entry, 0, sizeof(struct sd_entry));
+	return entry;
+}
+
+
+/**
+ * count_entries - counts sd (file) entries in a profile
+ * @profile: profile to count
+ */
+static inline void count_entries(struct sdprofile *profile)
+{
+	struct sd_entry *entry;
+	int i, count=0;
+
+	SD_DEBUG("%s\n", __FUNCTION__) ;
+
+	for (entry = profile->file_entry; entry; entry = entry->next) {
+
+		count++;
+	}
+
+	for (i=0; i<=POS_KERN_COD_FILE_MAX; i++){
+		struct sd_entry *pentry;
+		int pcount=0;
+
+		pentry=profile->file_entryp[i];
+		for (; pentry ; pentry = pentry->nextp[i]){
+			pcount++;
+		}
+
+		profile->num_file_pentries[i]=pcount;
+		SD_DEBUG("%s index %d entries %d\n",  
+			__FUNCTION__, i, pcount);
+	}
+
+	profile->num_file_entries = count;
+
+	SD_DEBUG("%s %d total entries\n",  __FUNCTION__, count);
+}
+
+/**
+ * count_net_entries - counts non globbed sd (file) entries in a profile
+ * @profile: profile to count
+ */
+static inline void count_net_entries(struct sdprofile *profile)
+{
+	struct nd_entry *entry;
+	int i, count = 0;
+	
+	SD_DEBUG("%s\n", __FUNCTION__);
+
+	for (entry = profile->net_entry; entry; entry = entry->next) {
+		count++;
+	}
+
+	for (i=POS_KERN_COD_NET_MIN; i<=POS_KERN_COD_NET_MAX; i++){
+		struct nd_entry *pentry;
+		int j, pcount=0;
+
+		j=NET_POS_TO_INDEX(i);
+
+		pentry=profile->net_entryp[j];
+		for (;pentry ; pentry = pentry->nextp[j]){
+			pcount++;
+		}
+
+		profile->num_net_pentries[j]=pcount;
+		SD_DEBUG("%s index %d entries %d\n",  
+			__FUNCTION__, j, pcount);
+	}
+
+	profile->num_net_entries = count;
+
+	SD_DEBUG("%s %d total entries\n",  __FUNCTION__, count);
+}
+
+
+/**
+ * put_iface - free interface name (simple kfree() wrapper)
+ * @iface: pointer to interface name
+ */
+static inline void put_iface(char *iface)
+{
+	if (iface){
+		kfree(iface);
+	}
+}
+	
+
+/* NULL profile
+ *
+ * Used when an attempt is made to changehat into a non-existant
+ * subhat.   In the NULL profile,  no file access is allowed
+ * (currently full network access is allowed).  Using a NULL
+ * profile ensures that active is always non zero.  
+ *
+ * Leaving the NULL profile is by either successfully changehatting
+ * into a sibling hat, or changehatting back to the parent (NULL hat).
+ */
+struct sdprofile null_profile = {
+	.name	= "null-profile",	/* NULL profile */
+	.count	= {1},			/* start count at 1 */
+};
+
+/* NULL complain profile
+ *
+ * Used when in complain mode, to emit Permitting messages for non-existant
+ * profiles and hats.  This is necessary because of selective mode, in which
+ * case we need a complain null_profile and enforce null_profile
+ *
+ * The null_complain_profile cannot be statically allocated, because it
+ * can be associated to files which keep their reference even if subdomain is
+ * unloaded
+ */
+struct sdprofile *null_complain_profile;
+
+/**
+ * free_sdprofile - free sdprofile structure
+ */
+void free_sdprofile(struct sdprofile *profile)
+{
+	struct sd_entry *sdent, *next_sdent = NULL;
+	struct nd_entry *ndent, *next_ndent = NULL;
+	struct list_head *lh, *tmp;
+
+	SD_DEBUG("%s(%p)\n",__FUNCTION__, profile);
+
+	if (!profile)
+		return;
+
+	/* these profiles should never be freed */
+	if (profile == &null_profile){
+		SD_ERROR("%s: internal error, attempt to remove profile '%s'\n",
+			__FUNCTION__,
+			profile->name);
+		BUG();
+	}
+		
+	/* profile is still on global prpfile list -- invalid */
+	if (!list_empty(&profile->list)){
+		SD_ERROR("%s: internal error, profile '%s' still on global list\n",
+			__FUNCTION__,
+			profile->name);
+		BUG();
+	}
+
+#if defined NETDOMAIN && defined NETDOMAIN_SKUSERS
+	/* profile still has netdomains (sockets) using it.
+	* This is not possible, as the profile is put each time a nd_free
+	* is called on socket close
+	*/
+	if (!list_empty(&profile->sk_users)){
+		SD_ERROR("%s: internal error, profile '%s' still has sk_users\n",
+			__FUNCTION__,
+			profile->name);
+		BUG();
+	}
+#endif
+
+	for (sdent = profile->file_entry; sdent; sdent = next_sdent) {
+		next_sdent = sdent->next;
+		if (sdent->filename) {
+			SD_DEBUG("freeing sd_entry: %p %s\n" ,
+				  sdent->filename, sdent->filename);
+/*
+			put_name(sdent->filename);
+			if (sdent->pattern_type == ePatternRegex){
+				put_name(sdent->regex);
+				put_pattern(sdent->compiled);
+			}
+*/
+		}
+//		kfree(sdent);
+		put_sd_entry(sdent);
+	}
+
+	for (ndent = profile->net_entry; ndent; ndent = next_ndent) {
+		next_ndent = ndent->next;
+		if (ndent == NULL) 
+			SD_DEBUG("%s: NULL entry!!!\n", __FUNCTION__);	
+		else
+			kfree(ndent);
+	}
+
+	list_for_each_safe(lh, tmp, &profile->sub) {
+		struct sdprofile *p = list_entry(lh, struct sdprofile, list);
+		list_del_init(&p->list);
+		put_sdprofile(p);
+	}
+
+	if (profile->sub_name) {
+		SD_DEBUG("%s: %s %s\n", __FUNCTION__, profile->name,
+				profile->sub_name);
+		kfree(profile->sub_name);
+	}
+
+	if (profile->name) {
+		SD_DEBUG("%s: %s\n", __FUNCTION__, profile->name);
+		kfree(profile->name);
+	}
+
+	kfree(profile);
+}
+
+/** task_remove
+ *
+ * remove profile in a task's subdomain leaving the task unconfined
+ *
+ * @sd: task's subdomain
+ */
+static inline void
+task_remove(struct subdomain *sd)
+{
+	/* SD_WLOCK held here */
+	SD_DEBUG("%s: removing profile from task %s(%d) profile %s active %s\n",
+		__FUNCTION__,
+		sd->task->comm,
+		sd->task->pid,
+		sd->profile->name,
+		sd->active->name);
+
+	put_sdprofile(sd->profile);
+	put_sdprofile(sd->active);
+	sd->profile = sd->active = NULL;
+
+}
+
+/** taskremove_iter
+ *
+ * Iterate over all subdomains. 
+ *
+ * If any matches old_profile,  then call task_remove to remove it.
+ * This leaves the task (subdomain) unconfined.
+ */
+static int taskremove_iter(struct subdomain *sd, void *cookie)
+{
+struct sdprofile *old_profile = (struct sdprofile *) cookie;
+int remove=0;
+
+	SD_WLOCK;
+
+	if (__sd_is_confined(sd) && 
+	     sd->profile == old_profile){
+//	    !(strcmp(sd->profile->name, old_profile->name)))
+		remove=1; /* remove item from list */
+		task_remove(sd);
+	}
+
+	SD_WUNLOCK;
+
+	return remove;
+}
+
+/** task_replace
+ *
+ * replace profile in a task's subdomain with newly loaded profile
+ *
+ * @sd: task's subdomain
+ * @new: old profile
+ */
+static inline void
+task_replace(struct subdomain *sd , struct sdprofile *new)
+{
+	struct sdprofile *subprofile = NULL;
+	struct sdprofile *active = sd->active;
+	struct sdprofile *profile = sd->profile;
+
+	SD_DEBUG("%s: replacing profile for task %s(%d) profile=%s (%p) active=%s (%p)\n", 
+		__FUNCTION__,
+		sd->task->comm, sd->task->pid,
+		sd->profile->name, sd->profile,
+		sd->active->name, sd->active);
+
+	if (sd->profile == sd->active)
+		sd->active = get_sdprofile(new);
+	else if (sd->active) {
+		/* old in hat, new profile has hats */
+		/* XXX need a lock for this list */
+		subprofile = __sd_find_profile(sd->active->name, &new->sub);
+
+		/* old subprofile does not exist, set active equal to null_profile */
+		if (!subprofile) {
+			if (new->flags.complain) {
+				subprofile = get_sdprofile(null_complain_profile);
+			} else {
+				subprofile = get_sdprofile(&null_profile);
+			}
+		}
+		sd->active = subprofile;
+	}
+	sd->profile = get_sdprofile(new);
+
+	/* release the old profiles */
+	put_sdprofile(profile);
+	put_sdprofile(active);
+}
+
+struct sd_taskreplace_data {
+	struct sdprofile *old_profile;
+	struct sdprofile *new_profile;
+};
+
+/** taskreplace_iter
+ *
+ * Iterate over all subdomains. 
+ *
+ * If any matches old_profile,  then call task_replace to replace with
+ * new_profile
+ */
+static int taskreplace_iter(struct subdomain *sd, void *cookie)
+{
+struct sd_taskreplace_data *data = (struct sd_taskreplace_data *)cookie;
+
+	SD_WLOCK;
+
+	if (__sd_is_confined(sd) && 
+	     sd->profile == data->old_profile){
+//	    !(strcmp(sd->profile->name, old_profile->name)))
+		task_replace(sd, data->new_profile);
+	}
+
+	SD_WUNLOCK;
+
+	return 0;
+}
+
+
+int sd_setprocattr_changehat(char *hatinfo, size_t infosize)
+{
+	int error = -EINVAL, tmplen;
+	char *token=NULL, 
+	     *hat, *smagic, *tmp;
+	__u32 magic;
+
+	SD_DEBUG("%s: %p %d\n",  
+		__FUNCTION__,
+		hatinfo, (int) infosize);
+
+	/* strip leading white space */
+	tmplen=infosize;
+	while (tmplen){
+		if (isblank(*hatinfo)){
+			hatinfo++;
+			infosize--;
+		}
+		tmplen--;
+	}
+
+	if (infosize == 0){
+		goto out;
+	}
+
+	/* 
+	 * Copy string to a new buffer so we can play with it
+	 * It may be zero terminated but we add a trailing 0 
+	 * for 100% safety
+	 */
+	token=kmalloc(infosize+1, GFP_KERNEL);
+
+	if (!token){
+		error=-ENOMEM;
+		goto out;
+	}
+
+	memcpy(token, hatinfo, infosize);
+	token[infosize] = 0;
+
+	/* error is INVAL until we have at least parsed something */
+	error = -EINVAL;
+
+ 	tmp = token;
+	while (*tmp && *tmp != '^'){
+		tmp++;
+	}
+
+	if (!*tmp){
+		SD_WARN("%s: Invalid input '%s'\n", 
+			__FUNCTION__,
+			token);
+		goto out;
+	}
+
+	if (tmp == token){
+		/* no magic specified */
+		magic=0;
+	}else{
+		int rc, len, consumed;
+
+		/* split magic and hat into two strings */
+		*tmp = 0;
+		smagic = token;
+
+
+		/* 
+		 * Initially set consumed=strlen(magic), as if sscanf 
+		 * consumes all input via the %x it will not process the %n 
+		 * directive. Otherwise, if sscanf does not consume all the 
+		 * input it will process the %n and update consumed.
+		 */
+		consumed=len=strlen(smagic);
+
+		rc=sscanf(smagic, "%x%n", &magic, &consumed);
+
+		if (rc != 1 || consumed != len){
+			SD_WARN("%s: Invalid hex magic %s\n", 
+				__FUNCTION__,
+				smagic);
+			goto out;
+		}
+	}
+
+	hat = tmp+1;
+
+	if (!*hat){
+		hat = NULL;
+	}
+
+	if (!hat && !magic){
+		SD_WARN("%s: Invalid input, NULL hat and NULL magic\n", 
+			__FUNCTION__);
+		goto out;
+	}
+
+	SD_DEBUG("%s: Magic 0x%x Hat '%s'\n", 
+		__FUNCTION__,
+		magic, hat ? hat : NULL);
+
+	SD_WLOCK;
+	error = sd_change_hat(hat, magic);
+	SD_WUNLOCK;
+		
+out:
+	if (token){
+		kfree(token);
+	}
+
+	return error;
+}
+
+#ifdef SUBDOMAIN_PROCATTR
+int sd_setprocattr_setprofile(struct task_struct *p, char *profilename, 
+			      size_t profilesize)
+{
+	int error = -EINVAL, tmplen;
+	struct sdprofile *profile;
+	char *name=NULL;
+
+	SD_DEBUG("%s: current %s(%d)\n",
+		__FUNCTION__,
+		current->comm, current->pid);	
+
+	/* strip leading white space */
+	tmplen=profilesize;
+	while (tmplen){
+		if (isblank(*profilename)){
+			profilename++;
+			profilesize--;
+		}
+
+		tmplen--;
+	}
+
+	if (profilesize == 0){
+		goto out;
+	}
+		
+	/* 
+	 * Copy string to a new buffer so we guarantee it is zero
+	 * terminated
+	 */
+	name=kmalloc(profilesize+1, GFP_KERNEL);
+
+	if (!name){
+		error=-ENOMEM;
+		goto out;
+	}
+
+	strncpy(name, profilename, profilesize);
+	name[profilesize]=0;
+
+	if (strcmp(name, SD_UNCONSTRAINED) == 0){
+		profile=&null_profile;
+	}else{	
+		profile=sd_profilelist_find(name);
+	}
+
+	if (profile){
+		struct subdomain *sd;
+
+		SD_WLOCK;
+
+		sd = SD_SUBDOMAIN(p->security);
+
+		/* switch to unconstrained */
+		if (profile == &null_profile){
+			if (__sd_is_confined(sd)){
+				SD_WARN("%s: Unconstraining task %s(%d) profile %s active %s\n",
+					__FUNCTION__,
+					p->comm, p->pid,
+					sd->profile->name,
+					sd->active->name);
+
+				put_sdprofile(sd->profile);
+				put_sdprofile(sd->active);
+				sd->profile = sd->active = NULL;
+				sd->sd_hat_magic = 0;
+			}else{
+				SD_WARN("%s: task %s(%d) is already unconstrained\n",
+					__FUNCTION__,
+					p->comm, p->pid);
+			}
+		}else{
+			if (!sd){
+				/* this task was created before module was 
+				 * loaded, allocate a subdomain
+			 	*/
+				SD_WARN("%s: task %s(%d) has no subdomain\n",
+					__FUNCTION__,
+					p->comm, p->pid);
+
+				sd = alloc_subdomain(p);
+				if (!sd){
+					SD_WARN("%s: Unable to allocate subdomain for task %s(%d). Cannot confine task to profile %s\n",
+						__FUNCTION__,
+						p->comm, p->pid,
+						name);
+
+					error = -ENOMEM;
+					SD_WUNLOCK;
+
+					goto out;
+				}
+			}
+
+			/* we do not do a normal task replace since we are not 
+		 	 * replacing with the same profile.
+		 	 * If existing process is in a hat, it will be moved 
+			 * into the new parent profile, even if this new 
+			 * profile has a identical named hat.
+		 	 */
+			
+			SD_WARN("%s: Switching task %s(%d) profile %s active %s to new profile %s\n",
+				__FUNCTION__,
+				p->comm, p->pid,
+				sd->profile ? sd->profile->name : SD_UNCONSTRAINED,
+				sd->active ? sd->profile->name : SD_UNCONSTRAINED,
+				name);
+
+			/* these are no-ops if profile/active is NULL */
+			put_sdprofile(sd->profile);
+			put_sdprofile(sd->active);
+
+			sd->profile=profile;	/* already refcounted by
+						 * sd_profilelist_find
+						 */
+			sd->active=get_sdprofile(profile);
+
+			/* reset magic in case we were in a subhat before */
+			sd->sd_hat_magic = 0;
+
+		}
+
+		SD_WUNLOCK;
+	}else{
+		SD_WARN("%s: Unable to switch task %s(%d) to profile '%s'. No such profile.\n",
+			__FUNCTION__,
+			p->comm, p->pid,
+			name);
+
+		error = -EINVAL;
+	}
+
+out:
+	if (name){
+		kfree(name);
+	}
+
+	return error;
+}
+#endif // SUBDOMAIN_PROCATTR
+
+#ifdef SD_OLD_INTERFACE
+#  include "module_old_interface.c"
+#else
+#  include "module_interface.c"
+#endif
