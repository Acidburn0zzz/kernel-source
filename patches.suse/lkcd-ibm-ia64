fixes from ibm for the fujitsu ipf code

Index: linux.suse/arch/ia64/Kconfig
===================================================================
--- linux.suse.orig/arch/ia64/Kconfig	2004-05-25 21:05:33.463321680 +0200
+++ linux.suse/arch/ia64/Kconfig	2004-05-25 21:05:33.516056982 +0200
@@ -425,6 +425,11 @@
          or other error occurs. Dumps can also be forced with the SysRq+d
          key if MAGIC_SYSRQ is enabled.
 
+config KERNTYPES
+        bool
+        depends on CRASH_DUMP
+        default y
+
 config CRASH_DUMP_BLOCKDEV
        tristate "Crash dump block device driver"
        depends on CRASH_DUMP
Index: linux.suse/arch/ia64/kernel/irq.c
===================================================================
--- linux.suse.orig/arch/ia64/kernel/irq.c	2004-05-25 21:05:33.464298260 +0200
+++ linux.suse/arch/ia64/kernel/irq.c	2004-05-25 21:05:33.517033561 +0200
@@ -929,9 +929,9 @@
 static struct proc_dir_entry * smp_affinity_entry [NR_IRQS];
 
 #if defined(CONFIG_CRASH_DUMP) || defined (CONFIG_CRASH_DUMP_MODULE)
-	unsigned long irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = ~0UL };
+cpumask_t irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = CPU_MASK_ALL };
 #else
-	static unsigned long irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = ~0UL };
+static cpumask_t irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = CPU_MASK_ALL };
 #endif
 
 static char irq_redir [NR_IRQS]; // = { [0 ... NR_IRQS-1] = 1 };
Index: linux.suse/arch/ia64/kernel/smp.c
===================================================================
--- linux.suse.orig/arch/ia64/kernel/smp.c	2004-05-25 21:05:33.465274839 +0200
+++ linux.suse/arch/ia64/kernel/smp.c	2004-05-25 21:05:33.518010141 +0200
@@ -392,7 +392,9 @@
 }
 #endif	/* CONFIG_KDB */
 
+#if defined(CONFIG_CRASH_DUMP) || defined(CONFIG_CRASH_DUMP_MODULE)
 void dump_send_ipi(void)
 {
         send_IPI_allbutself(IPI_DUMP_INTERRUPT);
 }
+#endif
Index: linux.suse/drivers/dump/dump_filters.c
===================================================================
--- linux.suse.orig/drivers/dump/dump_filters.c	2004-05-25 21:05:33.466251419 +0200
+++ linux.suse/drivers/dump/dump_filters.c	2004-05-25 21:05:33.518010141 +0200
@@ -54,7 +54,7 @@
 		(page_to_pfn(p) < (min_low_pfn + bootmap_pages)));
 }
 
-int kernel_page(struct page *p)
+static inline int kernel_page(struct page *p)
 {
 	/* FIXME: Need to exclude hugetlb pages. Clue: reserved but inuse */
 	return (PageReserved(p) && !PageInuse(p)) || (!PageLRU(p) && PageInuse(p));
@@ -72,19 +72,12 @@
 
 
 /* loc marks the beginning of a range of pages */
-int dump_filter_kernpages(int pass, unsigned long loc, unsigned long phy_addr,unsigned long sz)
+int dump_filter_kernpages(int pass, unsigned long loc, unsigned long sz)
 {
 	struct page *page = (struct page *)loc;
 	/* if any of the pages is a kernel page, select this set */	
 	while (sz) {
-#ifndef CONFIG_IA64		
 		if (dump_low_page(page) || kernel_page(page))
-#else
-		if(IS_PINNED_ADDRESS(phy_addr))
-			return 1;
-
-		if (kernel_page(page))
-#endif			
 			return 1;
 		sz -= PAGE_SIZE;
 		page++;
@@ -94,51 +87,33 @@
 
 
 /* loc marks the beginning of a range of pages */
-int dump_filter_userpages(int pass, unsigned long loc, unsigned long phy_addr,unsigned long sz)
+int dump_filter_userpages(int pass, unsigned long loc, unsigned long sz)
 {
 	struct page *page = (struct page *)loc;
 	int ret = 0;
 	/* select if the set has any user page, and no kernel pages  */	
-
 	while (sz) {
-#ifndef CONFIG_IA64		
 		if (user_page(page) && !dump_low_page(page)) {
 			ret = 1;
 		} else if (kernel_page(page) || dump_low_page(page)) {
 			return 0;
 		}
-#else
-		if(IS_PINNED_ADDRESS(phy_addr))
-			return 0;
-
-		if (user_page(page)) {
-			ret = 1;
-		} else if (kernel_page(page)) {
-			return 0;
-		}
-#endif		
 		page++;
 		sz -= PAGE_SIZE;
 	}	
 	return ret;
 }
 
+
+
 /* loc marks the beginning of a range of pages */
-int dump_filter_unusedpages(int pass, unsigned long loc,unsigned long phy_addr, unsigned long sz)
+int dump_filter_unusedpages(int pass, unsigned long loc, unsigned long sz)
 {
 	struct page *page = (struct page *)loc;
-	
 
 	/* select if the set does not have any used pages  */	
 	while (sz) {
-#ifndef CONFIG_IA64		
 		if (!unreferenced_page(page) || dump_low_page(page)) {
-#else
-		if(IS_PINNED_ADDRESS(phy_addr))
-			return 0;
-
-		if (!unreferenced_page(page)) {
-#endif			
 			return 0;
 		}
 		page++;
@@ -148,7 +123,7 @@
 }
 
 /* dummy: last (non-existent) pass */
-int dump_filter_none(int pass, unsigned long loc,unsigned long phy_addr, unsigned long sz)
+int dump_filter_none(int pass, unsigned long loc, unsigned long sz)
 {
 	return 0;
 }
Index: linux.suse/drivers/dump/dump_fmt.c
===================================================================
--- linux.suse.orig/drivers/dump/dump_fmt.c	2004-05-25 21:05:33.467227999 +0200
+++ linux.suse/drivers/dump/dump_fmt.c	2004-05-25 21:05:33.518986721 +0200
@@ -275,17 +275,14 @@
 	return !is_curr_stack_page(page, size) && !is_dump_page(page, size);
 }
 
-void lcrash_init_pageheader(struct __dump_page *dp, struct page *page,
-       unsigned long phys_addr,
-       unsigned long sz,
-       unsigned long offset_in_page)
+void lcrash_init_pageheader(struct __dump_page *dp, struct page *page, 
+	unsigned long sz)
 {
 	memset(dp, sizeof(struct __dump_page), 0);
 	dp->dp_flags = 0; 
 	dp->dp_size = 0;
-	if (sz > 0){
-		dp->dp_address = phys_addr;
-	}
+	if (sz > 0)
+		dp->dp_address = (loff_t)page_to_pfn(page) << PAGE_SHIFT;
 
 #if DUMP_DEBUG > 6
 	dp->dp_page_index = dump_header.dh_num_dump_pages;
@@ -294,7 +291,7 @@
 #endif /* DUMP_DEBUG */
 }
 
-int dump_lcrash_add_data(unsigned long loc, unsigned long phys_addr,unsigned long len,unsigned long offset_in_page)
+int dump_lcrash_add_data(unsigned long loc, unsigned long len)
 {
 	struct page *page = (struct page *)loc;
 	void *addr, *buf = dump_config.dumper->curr_buf;
@@ -304,20 +301,11 @@
 	if (buf > dump_config.dumper->dump_buf + DUMP_BUFFER_SIZE)
 		return -ENOMEM;
 
-	lcrash_init_pageheader(dp, page, phys_addr, len,offset_in_page);
+	lcrash_init_pageheader(dp, page, len);
 	buf += sizeof(struct __dump_page);
 
 	while (len) {
-#ifdef CONFIG_IA64
-		if (IS_PINNED_ADDRESS(phys_addr)){
-			addr=(void *)(loc);
-		} else {
-			addr = kmap_atomic(page, KM_DUMP);
-			addr += offset_in_page;
-		}
-#else
 		addr = kmap_atomic(page, KM_DUMP);
-#endif
 		size = bytes = (len > PAGE_SIZE) ? PAGE_SIZE : len;	
 		/* check for compression */
 		if (dump_allow_compress(page, bytes)) {
@@ -334,14 +322,7 @@
 			size = bytes;
 		}
 		/* memset(buf, 'A', size); temporary: testing only !! */
-#ifdef CONFIG_IA64
-		if(!IS_PINNED_ADDRESS(phys_addr)){
-			kunmap_atomic(page, KM_DUMP);
-		}
-#else
-		kunmap_atomic(page, KM_DUMP);
-#endif
-
+		kunmap_atomic(addr, KM_DUMP);
 		dp->dp_size += size;
 		buf += size;
 		len -= bytes;
@@ -367,7 +348,7 @@
 	unsigned long left;
 	int ret = 0;
 		
-	lcrash_init_pageheader(dp, NULL,0, 0,0);
+	lcrash_init_pageheader(dp, NULL, 0);
 	dp->dp_flags |= DUMP_DH_END; /* tbd: truncation test ? */
 	
 	/* now update the header */
Index: linux.suse/drivers/dump/dump_i386.c
===================================================================
--- linux.suse.orig/drivers/dump/dump_i386.c	2004-05-25 21:05:33.467227999 +0200
+++ linux.suse/drivers/dump/dump_i386.c	2004-05-25 21:05:33.518986721 +0200
@@ -34,7 +34,6 @@
 
 static __s32 	     saved_irq_count;	/* saved preempt_count() flags */
 
-
 static int
 alloc_dha_stack(void)
 {
@@ -291,10 +290,6 @@
 void
 __dump_init(uint64_t local_memory_start)
 {
-	dump_mbanks = 1;
-	dump_mbank[ 0 ].start = 0;
-	dump_mbank[ 0 ].end  = (((u64) max_mapnr) << PAGE_SHIFT) - 1;
-	dump_mbank[ 0 ].type = DUMP_MBANK_TYPE_CONVENTIONAL_MEMORY;
 	return;
 }
 
Index: linux.suse/drivers/dump/dump_ia64.c
===================================================================
--- linux.suse.orig/drivers/dump/dump_ia64.c	2004-05-25 21:05:33.469181158 +0200
+++ linux.suse/drivers/dump/dump_ia64.c	2004-05-25 21:05:33.519963300 +0200
@@ -33,9 +33,7 @@
 #include <asm/hardirq.h>
 #include <linux/irq.h>
 
-extern unsigned long irq_affinity[];
 static __s32         saved_irq_count;   /* saved preempt_count() flags */
-static unsigned long saved_affinity[NR_IRQS];
 
 
 static int alloc_dha_stack(void)
@@ -89,10 +87,12 @@
 
 #ifdef CONFIG_SMP
 
-extern unsigned long irq_affinity[];
+extern cpumask_t irq_affinity[];
 #define irq_desc _irq_desc
 extern irq_desc_t irq_desc[];
 extern void dump_send_ipi(void);
+static cpumask_t saved_affinity[NR_IRQS];
+
 /*
  * Routine to save the old irq affinities and change affinities of all irqs to
  * the dumping cpu.
@@ -101,13 +101,14 @@
 set_irq_affinity(void)
 {
         int i;
-        int cpu = smp_processor_id();
+	cpumask_t cpu = CPU_MASK_NONE;
 
+	cpu_set(smp_processor_id(), cpu);
         memcpy(saved_affinity, irq_affinity, NR_IRQS * sizeof(unsigned long));
         for (i = 0; i < NR_IRQS; i++) {
                 if (irq_desc[i].handler == NULL)
                         continue;
-                irq_affinity[i] = 1UL << cpu;
+		irq_affinity[i] = cpu;
                 if (irq_desc[i].handler->set_affinity != NULL)
                         irq_desc[i].handler->set_affinity(i, irq_affinity[i]);
         }
@@ -143,7 +144,6 @@
 
 
 extern void stop_this_cpu(void);
-//extern void unset_nmi_callback(void);
 
 static int
 dump_nmi_callback(struct pt_regs *regs, int cpu)
@@ -185,7 +185,7 @@
 {
 	int cpu;
 	cpu = task_cpu(current);
-	dump_nmi_callback(regs, cpu);
+	return(dump_nmi_callback(regs, cpu));
 }
 
 /* save registers on other processors */
@@ -203,7 +203,6 @@
                 }
 
                 /* short circuit normal NMI handling temporarily */
-                /*set_nmi_callback(dump_nmi_callback);*/
 		dump_ipi_function_ptr = IPI_handler;
 		
                 wmb();
@@ -218,12 +217,8 @@
                         cpu_relax();
                 }
 
-//                unset_nmi_callback();
         }
 }
-
-#else
-#define save_other_cpu_states()
 #endif
 /*
  * Kludge - dump from interrupt context is unreliable (Fixme)
@@ -274,7 +269,7 @@
  *     Change irq affinities
  *     Re-enable interrupts
  */
-void
+int
 __dump_irq_enable(void)
 {
         set_irq_affinity();
@@ -287,6 +282,7 @@
 	ia64_setreg(_IA64_REG_CR_TPR, 0);
 	ia64_srlz_d();
         local_irq_enable();
+	return 0;
 }
 
 /*
@@ -316,63 +312,6 @@
         return 1;
 }
 
-
-void
-__init_mem_banks(void)
-{
-	void *p;
-	int i = 0;
-	void *efi_map_start = __va(ia64_boot_param->efi_memmap);
-	void *efi_map_end = efi_map_start + ia64_boot_param->efi_memmap_size;
-	u64 efi_desc_size = ia64_boot_param->efi_memdesc_size;
-
-	memset (dump_mbank, 0, sizeof dump_mbank);
-
-	for (p = efi_map_start; p < efi_map_end; p += efi_desc_size) {
-		efi_memory_desc_t *md = p;
-		u64 start = md->phys_addr;
-		u64 end = start + (md->num_pages << DUMP_EF_PAGE_SHIFT) - 1;
-		int type;
-
-		if(md->num_pages ==0 ) continue;
-		if (i >= dim(dump_mbank)) {
-			break;
-		}
-
-		/*
-		 * NB: The attribute EFI_MEMORY_UC means the memory bank can support Uncached access,
-		 *      not that the memory us curently running with Uncached access.
-		 */
-		if ( (md->attribute & (EFI_MEMORY_WB | EFI_MEMORY_WT)) == 0 ) {
-			continue;
-		}
-		switch(md->type) {
-		case EFI_UNUSABLE_MEMORY:		/* Ignore it */
-			continue;
-
-		case EFI_LOADER_CODE:
-		case EFI_LOADER_DATA:
-		case EFI_BOOT_SERVICES_CODE:
-		case EFI_BOOT_SERVICES_DATA:
-		case EFI_CONVENTIONAL_MEMORY:
-			type = DUMP_MBANK_TYPE_CONVENTIONAL_MEMORY;
-			break;
-		
-		default:
-			type = DUMP_MBANK_TYPE_OTHER;
-			break;
-
-		}
-		dump_mbank[ i ].type = type;
-		dump_mbank[ i ].start = start;
-		dump_mbank[ i ].end = end;
-		printk(KERN_EMERG "Start:: %lx End:: %lx efi phys addr = %x number of pages= %lx \n",start,end,(unsigned int)md->phys_addr,md->num_pages);
-		i++;
-	}
-	dump_mbanks = i;
-	return;
-}
-
 /*
  * Name: __dump_init()
  * Func: Initialize the dumping routine process.  This is in case
@@ -381,7 +320,6 @@
 void
 __dump_init(uint64_t local_memory_start)
 {
-	__init_mem_banks();		/* Initialize Memory Banks */
 	return;
 }
 
Index: linux.suse/drivers/dump/dump_memdev.c
===================================================================
--- linux.suse.orig/drivers/dump/dump_memdev.c	2004-05-25 21:05:33.469181158 +0200
+++ linux.suse/drivers/dump/dump_memdev.c	2004-05-25 21:05:33.520939880 +0200
@@ -299,12 +299,7 @@
 
 	/* Temporary proof of concept hack, avoid overwriting kern pages */
 
-#ifdef CONFIG_KEXEC
 	return (kernel_page(page) || dump_low_page(page) || user_page(page));
-#else
-       return 0;
-#endif
-
 }
 
 
@@ -411,13 +406,10 @@
 		}
 
 		page = virt_to_page(addr);
-
-#ifdef CONFIG_KEXEC
 		if (dump_low_page(page)) {
 			dump_free_mem(addr);
 			continue;
 		}
-#endif
 
 		if (dump_mem_add_space(dump_mdev, page)) {
 			printk("Warning: Unable to extend memdev "
Index: linux.suse/drivers/dump/dump_methods.h
===================================================================
--- linux.suse.orig/drivers/dump/dump_methods.h	2004-05-25 21:05:33.470157738 +0200
+++ linux.suse/drivers/dump/dump_methods.h	2004-05-25 21:05:33.520939880 +0200
@@ -51,7 +51,7 @@
 /* To customise selection of pages to be dumped in a given pass/group */
 struct dump_data_filter{
 	char name[32];
-	int (*selector)(int, unsigned long, unsigned long, unsigned long);
+	int (*selector)(int, unsigned long, unsigned long);
 	ulong level_mask; /* dump level(s) for which this filter applies */
 	loff_t start[MAX_NUMNODES], end[MAX_NUMNODES]; /* location range applicable */
 	ulong num_mbanks;  /* Number of memory banks. Greater than one for discontig memory (NUMA) */
@@ -71,12 +71,12 @@
 	/* ordering of passes, invoking iterator */
 	int (*sequencer)(void); 
         /* iterates over system data, selects and acts on data to dump */
-	int (*iterator)(int, int (*)(unsigned long, unsigned long, unsigned long, unsigned long), 
+	int (*iterator)(int, int (*)(unsigned long, unsigned long), 
 		struct dump_data_filter *); 
         /* action when data is selected for dump */
-	int (*save_data)(unsigned long, unsigned long,unsigned long,unsigned long); 
+	int (*save_data)(unsigned long, unsigned long); 
         /* action when data is to be excluded from dump */
-	int (*skip_data)(unsigned long,unsigned long, unsigned long,unsigned long); 
+	int (*skip_data)(unsigned long, unsigned long); 
 	/* policies for space, multiple dump devices etc */
 	int (*write_buffer)(void *, unsigned long); 
 };
@@ -105,7 +105,7 @@
 		struct task_struct *); 
 	/* typically called by the save_data action */
 	/* add formatted data to the dump buffer */
-	int (*add_data)(unsigned long, unsigned long, unsigned long,unsigned long); 
+	int (*add_data)(unsigned long, unsigned long); 
 	int (*update_end_marker)(void);
 };
 
@@ -185,8 +185,8 @@
 	return dump_config.dumper->scheme->ops->sequencer();
 }
 
-static inline int dump_iterator(int pass, int (*action)(unsigned long,unsigned long, 
-	unsigned long,unsigned long), struct dump_data_filter *filter)
+static inline int dump_iterator(int pass, int (*action)(unsigned long, 
+	unsigned long), struct dump_data_filter *filter)
 {
 	return dump_config.dumper->scheme->ops->iterator(pass, action, filter);
 }
@@ -241,9 +241,9 @@
 	return dump_config.dumper->fmt->ops->update_end_marker();
 }
 
-static inline int dump_add_data(unsigned long loc, unsigned long phys_addr, unsigned long sz,unsigned long off_in_page)
+static inline int dump_add_data(unsigned long loc, unsigned long sz)
 {
-	return dump_config.dumper->fmt->ops->add_data(loc,phys_addr, sz,off_in_page);
+	return dump_config.dumper->fmt->ops->add_data(loc, sz);
 }
 
 /* Compression operation */
@@ -262,9 +262,10 @@
 /* Default scheme methods (dump_scheme.c) */
 
 extern int dump_generic_sequencer(void);
-extern int dump_page_iterator(int pass, int (*action)(unsigned long, unsigned long, unsigned long,unsigned long), struct dump_data_filter *filter);
-extern int dump_generic_save_data(unsigned long loc, unsigned long phys_addr,unsigned long sz,unsigned long offset_in_page);
-extern int dump_generic_skip_data(unsigned long loc, unsigned long phys_addr,unsigned long sz,unsigned long offset_in_page);
+extern int dump_page_iterator(int pass, int (*action)(unsigned long, unsigned
+	long), struct dump_data_filter *filter);
+extern int dump_generic_save_data(unsigned long loc, unsigned long sz);
+extern int dump_generic_skip_data(unsigned long loc, unsigned long sz);
 extern int dump_generic_write_buffer(void *buf, unsigned long len);
 extern int dump_generic_configure(unsigned long);
 extern int dump_generic_unconfigure(void);
@@ -279,7 +280,7 @@
 extern void dump_lcrash_save_context(int  cpu, const struct pt_regs *regs, 
 	struct task_struct *tsk);
 extern int dump_generic_update_header(void);
-extern int dump_lcrash_add_data(unsigned long loc, unsigned long phys_addr, unsigned long sz,unsigned long offset_in_page);
+extern int dump_lcrash_add_data(unsigned long loc, unsigned long sz);
 extern int dump_lcrash_update_end_marker(void);
 
 /* Default format (lcrash) template */
Index: linux.suse/drivers/dump/dump_overlay.c
===================================================================
--- linux.suse.orig/drivers/dump/dump_overlay.c	2004-05-25 21:05:33.471134317 +0200
+++ linux.suse/drivers/dump/dump_overlay.c	2004-05-25 21:05:33.522893039 +0200
@@ -367,7 +367,7 @@
 	struct dump_data_filter *filter = dump_config.dumper->filter;
 	struct dump_data_filter *filter2 = dumper_stage2.filter;
 	int pass = 0, err = 0, save = 0;
-	int (*action)(unsigned long, unsigned long,unsigned long, unsigned long);
+	int (*action)(unsigned long, unsigned long);
 
 	/* Make sure gzip compression is being used */
 	if (dump_config.dumper->compress->compress_type != DUMP_COMPRESS_GZIP) {
@@ -421,7 +421,7 @@
 			break;
 		}	
 		printk("\n %d overlay pages %s of %d each in pass %d\n", 
-		err, save ? "saved" : "skipped", (int)DUMP_PAGE_SIZE, pass);
+		err, save ? "saved" : "skipped", DUMP_PAGE_SIZE, pass);
 	}
 
 	return err;
@@ -453,7 +453,7 @@
  * faster.
  */
 int dump_saved_data_iterator(int pass, int (*action)(unsigned long, 
-	unsigned long,unsigned long, unsigned long), struct dump_data_filter *filter)
+	unsigned long), struct dump_data_filter *filter)
 {
 	loff_t loc, end;
 	struct page *page;
@@ -461,16 +461,16 @@
 	int i, err = 0;
 	unsigned long sz;
 
-	for (i = 0; i < dump_mbanks; i++) {
-		loc  = dump_mbank[i].start;
-		end = dump_mbank[i].end;
+	for (i = 0; i < filter->num_mbanks; i++) {
+		loc  = filter->start[i];
+		end = filter->end[i];
 		printk("pass %d, start off 0x%llx end offset 0x%llx\n", pass,
 			loc, end);
 
 		/* loc will get treated as logical offset into stage 1 */
 		page = dump_get_saved_page(loc);
 			
-		for (; loc < end; loc += /*PAGE_SIZE*/DUMP_PAGE_SIZE) {
+		for (; loc < end; loc += PAGE_SIZE) {
 			dump_config.dumper->curr_loc = loc;
 			if (!page) {
 				printk("no more saved data for pass %d\n", 
@@ -480,8 +480,9 @@
 			sz = (loc + PAGE_SIZE > end) ? end - loc : PAGE_SIZE;
 
 			if (page && filter->selector(pass, (unsigned long)page, 
-				loc, PAGE_SIZE))  {
-				if ((err = action((unsigned long)page, sz,DUMP_PAGE_SIZE,loc%PAGE_SIZE)))
+				PAGE_SIZE))  {
+				pr_debug("mem offset 0x%llx\n", loc);
+				if ((err = action((unsigned long)page, sz))) 
 					break;
 				else
 					count++;
@@ -497,30 +498,27 @@
 	return err ? err : count;
 }
 
-static inline int dump_overlay_pages_done(unsigned long loc, unsigned long phys_addr,unsigned long len,unsigned long offset)
+static inline int dump_overlay_pages_done(struct page *page, int nr)
 {
 	int ret=0;
-	struct page *page= (struct page *)loc;
 
-	if((offset+len) == PAGE_SIZE)/*This ensures that a complete page is dumped*/
-	{
+	for (; nr ; page++, nr--) {
 		if (dump_check_and_free_page(dump_memdev, page))
 			ret++;
 	}
-
 	return ret;
 }
 
-int dump_overlay_save_data(unsigned long loc, unsigned long phys_addr,unsigned long len,unsigned long offset)
+int dump_overlay_save_data(unsigned long loc, unsigned long len)
 {
 	int err = 0;
 	struct page *page = (struct page *)loc;
 	static unsigned long cnt = 0;
 
-	if ((err = dump_generic_save_data(loc,phys_addr,len,offset)))
+	if ((err = dump_generic_save_data(loc, len)))
 		return err;
 
-	if (dump_overlay_pages_done((unsigned long)page, phys_addr,len /*>> PAGE_SHIFT*/,offset)) {
+	if (dump_overlay_pages_done(page, len >> PAGE_SHIFT)) {
 		cnt++;
 		if (!(cnt & 0x7f))
 			pr_debug("released page 0x%lx\n", page_to_pfn(page));
@@ -530,11 +528,11 @@
 }
 
 
-int dump_overlay_skip_data(unsigned long loc, unsigned long phys_addr,unsigned long len,unsigned long offset_in_page)
+int dump_overlay_skip_data(unsigned long loc, unsigned long len)
 {
 	struct page *page = (struct page *)loc;
 
-	dump_overlay_pages_done((unsigned long)page, phys_addr,len /*>> PAGE_SHIFT*/,offset_in_page);
+	dump_overlay_pages_done(page, len >> PAGE_SHIFT);
 	return 0;
 }
 
@@ -559,7 +557,7 @@
         err = dump_activate_softboot();
 #endif
 		
-//	return err;
+	return err;
 	err = dump_switchover_stage();  /* plugs into soft boot mechanism */
 	dump_config.dumper = &dumper_stage1; /* set things back */
 	return err;
@@ -608,7 +606,7 @@
 	}
 	dump_config.dump_addr = (unsigned long)dump_saved_config;
 	printk("Dump config block of size %d set up at 0x%lx\n", 
-		(int)sizeof(*dump_saved_config), (unsigned long)dump_saved_config);
+		sizeof(*dump_saved_config), (unsigned long)dump_saved_config);
 	return 0;
 }
 
@@ -666,7 +664,7 @@
 /* ----- PASSTHRU FILTER ROUTINE --------- */
 
 /* transparent - passes everything through */
-int dump_passthru_filter(int pass, unsigned long loc, unsigned long phy_addr,unsigned long sz)
+int dump_passthru_filter(int pass, unsigned long loc, unsigned long sz)
 {
 	return 1;
 }
@@ -745,7 +743,7 @@
 	if ((dph->dp_address & (PAGE_SIZE - 1)) || (dph->dp_flags 
 	      > DUMP_DH_COMPRESSED) || (!dph->dp_flags) ||
 		(dph->dp_size > PAGE_SIZE)) {
-	printk("dp->address = 0x%lx, dp->size = 0x%x, dp->flag = 0x%x\n",
+	printk("dp->address = 0x%llx, dp->size = 0x%x, dp->flag = 0x%x\n",
 		dph->dp_address, dph->dp_size, dph->dp_flags);
 		return 0;
 	}
@@ -775,14 +773,12 @@
  * TBD/Later: Consider avoiding the copy by using a scatter/gather 
  * vector representation for the dump buffer
  */
-int dump_passthru_add_data(unsigned long loc, unsigned long phys_addr,unsigned long sz,unsigned long offset_in_page)
+int dump_passthru_add_data(unsigned long loc, unsigned long sz)
 {
 	struct page *page = (struct page *)loc;
 	void *buf = dump_config.dumper->curr_buf;
 	int err = 0;
 
-//	printk(KERN_EMERG "In dump passsthrough add data \n");
-//	mdelay(1000);
 	if ((err = dump_copy_pages(buf, page, sz))) {
 		printk("dump_copy_pages failed");
 		return err;
@@ -852,7 +848,7 @@
 /* Filter that simply passes along any data within the range (transparent)*/
 /* Note: The start and end ranges in the table are filled in at run-time */
 
-extern int dump_filter_none(int pass, unsigned long loc, unsigned long phy_addr,unsigned long sz);
+extern int dump_filter_none(int pass, unsigned long loc, unsigned long sz);
 
 struct dump_data_filter dump_passthru_filtertable[MAX_PASSES] = {
 {.name = "passkern", .selector = dump_passthru_filter, 
Index: linux.suse/drivers/dump/dump_scheme.c
===================================================================
--- linux.suse.orig/drivers/dump/dump_scheme.c	2004-05-25 21:05:33.472110897 +0200
+++ linux.suse/drivers/dump/dump_scheme.c	2004-05-25 21:06:18.847908273 +0200
@@ -48,7 +48,7 @@
 {
 	struct dump_data_filter *filter = dump_config.dumper->filter;
 	int pass = 0, err = 0, save = 0;
-	int (*action)(unsigned long, unsigned long,unsigned long,unsigned long);
+	int (*action)(unsigned long, unsigned long);
 
 	/* 
 	 * We want to save the more critical data areas first in 
@@ -65,10 +65,12 @@
 		else
 			action = dump_skip_data;
 
-		if ((err = dump_iterator(pass, action, filter)) < 0){
-			printk(KERN_EMERG "Iterator failed \n");
+		if ((err = dump_iterator(pass, action, filter)) < 0)
 			break;
-		}
+
+		printk("\n %d dump pages %s of %d each in pass %d\n", 
+		err, save ? "saved" : "skipped", (int)DUMP_PAGE_SIZE, pass);
+
 	}
 
 	return (err < 0) ? err : 0;
@@ -78,14 +80,7 @@
 {
 
 	unsigned long page_index = loc >> PAGE_SHIFT;
-	unsigned long vaddr;
-#ifdef CONFIG_IA64
-	if(IS_PINNED_ADDRESS(loc))		
-	{
-		vaddr = START + loc - (PHYS_START);
-		return  (struct page *)(vaddr);
-	}
-#endif
+
 	/* todo: complete this  to account for ia64/discontig mem */
 	/* todo: and to check for validity, ram page, no i/o mem etc */
 	/* need to use pfn/physaddr equiv of kern_addr_valid */
@@ -110,32 +105,37 @@
 
 /* Default iterator: for singlestage and stage 1 of soft-boot dumping */
 /* Iterates over range of physical memory pages in DUMP_PAGE_SIZE increments */
-int dump_page_iterator(int pass, int (*action)(unsigned long, unsigned long, unsigned long,unsigned long),
-        struct dump_data_filter *filter)
+int dump_page_iterator(int pass, int (*action)(unsigned long, unsigned long), 
+	struct dump_data_filter *filter)
 {
 	/* Todo : fix unit, type */
-	loff_t loc;
-	int count = 0, err = 0,i=0;
+	loff_t loc, start, end;
+	int i, count = 0, err = 0;
 	struct page *page;
 
 	/* Todo: Add membanks code */
 	/* TBD: Check if we need to address DUMP_PAGE_SIZE < PAGE_SIZE */	
 
-	for(i=0;i<dump_mbanks;i++)
-	{
-		//printk(KERN_EMERG "Mbank %d start %lx end %lx\n",i,dump_mbank[ i ].start,dump_mbank[ i ].end);
-		for (loc = dump_mbank[ i ].start; loc < dump_mbank[ i ].end; loc += DUMP_PAGE_SIZE/*PAGE_SIZE*/) {
+	for (i = 0; i < filter->num_mbanks; i++) {
+		start = filter->start[i];
+		end = filter->end[i];
+		for (loc = start; loc < end; loc += DUMP_PAGE_SIZE) {
 			dump_config.dumper->curr_loc = loc;
 			page = dump_get_page(loc);
-			if (page && filter->selector(pass, (unsigned long) page,loc, PAGE_SIZE)) {
-				if ((err = action((unsigned long)page, loc/*+offset_in_page*/,DUMP_PAGE_SIZE,loc%PAGE_SIZE)))
-				{
-					break;
+			if (page && filter->selector(pass, 
+				(unsigned long) page, DUMP_PAGE_SIZE)) { 
+				if ((err = action((unsigned long)page, 
+					DUMP_PAGE_SIZE))) {
+					printk("dump_page_iterator: err %d for "
+						"loc 0x%llx, in pass %d\n", 
+						err, loc, pass);
+					return err ? err : count;
 				} else
 					count++;
 			}
 		}
 	}
+
 	return err ? err : count;
 }
 
@@ -143,23 +143,22 @@
  * Base function that saves the selected block of data in the dump 
  * Action taken when iterator decides that data needs to be saved 
  */
-int dump_generic_save_data(unsigned long loc, unsigned long phys_addr,unsigned long sz,unsigned long offset)
+int dump_generic_save_data(unsigned long loc, unsigned long sz)
 {
 	void *buf;
 	void *dump_buf = dump_config.dumper->dump_buf;
 	int left, bytes, ret;
 
-	if ((ret = dump_add_data(loc, phys_addr,sz,offset))) {
+	if ((ret = dump_add_data(loc, sz))) {
 		return ret;
 	}
 	buf = dump_config.dumper->curr_buf;
 
 	/* If we've filled up the buffer write it out */
-	
 	if ((left = buf - dump_buf) >= DUMP_BUFFER_SIZE) {
 		bytes = dump_write_buffer(dump_buf, DUMP_BUFFER_SIZE);
 		if (bytes < DUMP_BUFFER_SIZE) {
-			printk(KERN_EMERG "dump_write_buffer failed %d\n", bytes);
+			printk("dump_write_buffer failed %d\n", bytes);
 			return bytes ? -ENOSPC : bytes;
 		}
 
@@ -175,7 +174,7 @@
 				/* issue warning */
 				return ret;
 			}
-			printk (".");
+			printk(".");
 
 			touch_nmi_watchdog();
 		} else if (!(dump_config.dumper->count & 0x7)) {
@@ -185,6 +184,16 @@
 		/* Todo: Touch/Refresh watchdog */
 
 		/* --- Done with periodic chores -- */
+
+		/* 
+		 * extra bit of copying to simplify verification  
+		 * in the second kernel boot based scheme
+		 */
+		memcpy(dump_buf - DUMP_PAGE_SIZE, dump_buf + 
+			DUMP_BUFFER_SIZE - DUMP_PAGE_SIZE, DUMP_PAGE_SIZE);
+
+		/* now adjust the leftover bits back to the top of the page */
+		/* this case would not arise during stage 2 (passthru) */
 		memset(dump_buf, 'z', DUMP_BUFFER_SIZE);
 		if (left) {
 			memcpy(dump_buf, dump_buf + DUMP_BUFFER_SIZE, left);
@@ -196,7 +205,7 @@
 	return 0;
 }
 
-int dump_generic_skip_data(unsigned long loc, unsigned long phys_addr,unsigned long sz,unsigned long offset_in_page)
+int dump_generic_skip_data(unsigned long loc, unsigned long sz)
 {
 	/* dummy by default */
 	return 0;
@@ -216,26 +225,23 @@
 	/* make sure device is ready */
 	while ((ret = dump_dev_ready(NULL)) == -EAGAIN);
 	if  (ret < 0) {
-		printk(KERN_EMERG "dump_dev_ready failed !err %d\n", ret);
+		printk("dump_dev_ready failed !err %d\n", ret);
 		return ret;
 	}
-	
+
 	while (len) {
 		if ((last_transfer = dump_dev_write(buf, len)) <= 0)  {
 			ret = last_transfer;
-			printk(KERN_EMERG "dump_dev_write failed !err %d\n", 
+			printk("dump_dev_write failed !err %d\n", 
 			ret);
 			break;
 		}
-
 		/* wait till complete */
-		while ((ret = dump_dev_ready(buf)) == -EAGAIN){
-		//	printk(KERN_EMERG "dump_dev_ready failed \n");
-			cpu_relax();			
-		}
-		
+		while ((ret = dump_dev_ready(buf)) == -EAGAIN)
+			cpu_relax();
+
 		if  (ret < 0) {
-			printk(KERN_EMERG "i/o failed !err %d\n", ret);
+			printk("i/o failed !err %d\n", ret);
 			break;
 		}
 
@@ -256,7 +262,7 @@
 	/* check for space */
 	if ((err = dump_dev_seek(dump_config.dumper->curr_offset + len + 
 			2*DUMP_BUFFER_SIZE)) < 0) {
-		printk(KERN_EMERG "dump_write_buffer: insuff space after offset 0x%llx\n",
+		printk("dump_write_buffer: insuff space after offset 0x%llx\n",
 			dump_config.dumper->curr_offset);
 		return err;
 	}
@@ -272,7 +278,7 @@
 		written = written ? -ENOSPC : written;
 	else
 		dump_config.dumper->curr_offset += len;
-	
+
 	return written;
 }
 
@@ -294,10 +300,8 @@
 		return -ENOMEM; /* fixme: better error code */
 	}
 
-	/* Initialize the rest of the fields *
+	/* Initialize the rest of the fields */
 	dump_config.dumper->dump_buf = buf + DUMP_PAGE_SIZE;
-	COMMENTED :: TBD : Query lkcd lists For the offsetting */
-	dump_config.dumper->dump_buf = buf;
 	dumper_reset();
 
 	/* Open the dump device */
@@ -341,11 +345,7 @@
 	printk("Closed dump device\n");
 	
 	if (buf)
-	{
-		/* Commented: Query LKCD on the need for offsetting
-		 * */
-		dump_free_mem((buf /*- DUMP_PAGE_SIZE*/));
-	}
+		dump_free_mem((buf - DUMP_PAGE_SIZE));
 
 	dump_config.dumper->curr_buf = dump_config.dumper->dump_buf = NULL;
 	pr_debug("Released dump buffer\n");
Index: linux.suse/drivers/dump/dump_setup.c
===================================================================
--- linux.suse.orig/drivers/dump/dump_setup.c	2004-05-25 21:05:33.473087477 +0200
+++ linux.suse/drivers/dump/dump_setup.c	2004-05-25 21:05:33.524846199 +0200
@@ -202,9 +202,6 @@
 	.page_offset	= PAGE_OFFSET,
 };
 
-int dump_mbanks;                   /* number of  physical memory banks     */
-struct __dump_mbank dump_mbank[MAXCHUNKS]; /* describes layout of physical memory  */
-
 /*
  * -----------------------------------------------------------------------
  *            / P R O C   T U N A B L E   F U N C T I O N S
@@ -308,7 +305,7 @@
 {
 	int state = -1;
 	unsigned long flags;
-	
+
 	/* make sure we can dump */
 	if (!dump_okay) {
 		pr_info("LKCD not yet configured, can't take dump now\n");
@@ -336,16 +333,16 @@
 	 */
 	dump_oncpu = smp_processor_id() + 1;
 	dump_silence_level = DUMP_HARD_SPIN_CPUS; 
-	
+
 	state = dump_generic_execute(panic_str, regs);
-	printk(KERN_EMERG "dump_generic_execute compelte\n");	
+	
 	dump_oncpu = 0;
 	spin_unlock_irqrestore(&dump_lock, flags);
 
 	if (state < 0) {
-		printk(KERN_EMERG "Dump Incomplete or failed!\n");
+		printk("Dump Incomplete or failed!\n");
 	} else {
-		printk(KERN_EMERG "Dump Complete; %d dump pages saved.\n", 
+		printk("Dump Complete; %d dump pages saved.\n", 
 		       dump_header.dh_num_dump_pages);
 	}
 	
@@ -436,9 +433,8 @@
 #ifdef CONFIG_CRASH_DUMP_MEMDEV
 		dump_config.dumper = &dumper_stage1; 
 #else
-/*
 		printk("Requires CONFIG_CRASHDUMP_MEMDEV. Can't proceed.\n");
-		return -1;*/
+		return -1;
 #endif
 	} else {
 		dump_config.dumper = &dumper_singlestage;
@@ -499,6 +495,7 @@
 static int
 dump_ioctl(struct inode *i, struct file *f, unsigned int cmd, unsigned long arg)
 {
+	/* check capabilities */
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
@@ -744,10 +741,8 @@
 	struct pt_regs regs;
 	
 	get_current_regs(&regs);
-	printk("Inside panic event \n");
 	dump_execute((const char *)ptr, &regs);
 #endif
-	printk("Returning from panic event\n");
 	return 0;
 }
 
@@ -799,7 +794,6 @@
 #endif
 }
 
-extern unsigned long num_physpages;
 /*
  * Name: dump_init()
  * Func: Initialize the dump process.  This will set up any architecture
@@ -854,8 +848,6 @@
 
 	/* set the memory size */
 	dump_header.dh_memory_size = (u64)info.totalram;
-	bzero(&dump_header,sizeof(dump_header));
-	bzero(&dump_header_asm,sizeof(dump_header_asm));
 
 	sysctl_header = register_sysctl_table(kernel_root, 0);
 	dump_sysrq_register();
@@ -927,4 +919,3 @@
 
 module_init(dump_init);
 module_exit(dump_cleanup);
-
Index: linux.suse/include/asm-i386/dump.h
===================================================================
--- linux.suse.orig/include/asm-i386/dump.h	2004-05-25 21:05:33.474064056 +0200
+++ linux.suse/include/asm-i386/dump.h	2004-05-25 21:05:33.524846199 +0200
@@ -19,7 +19,6 @@
 #include <linux/mm.h>
 
 /* definitions */
-#define STACK_START_POSITION(tsk)		(tsk)
 #define DUMP_ASM_MAGIC_NUMBER	0xdeaddeadULL	/* magic number            */
 #define DUMP_ASM_VERSION_NUMBER	0x3	/* version number          */
 
Index: linux.suse/include/asm-ia64/dump.h
===================================================================
--- linux.suse.orig/include/asm-ia64/dump.h	2004-05-25 21:05:33.475040636 +0200
+++ linux.suse/include/asm-ia64/dump.h	2004-05-25 21:11:27.491020567 +0200
@@ -25,7 +25,7 @@
 #include <asm/ptrace.h>
 
 #ifdef CONFIG_SMP
-extern unsigned long irq_affinity[];
+extern cpumask_t irq_affinity[];
 extern int (*dump_ipi_function_ptr)(struct pt_regs *);
 extern void dump_send_ipi(void);
 #else /* !CONFIG_SMP */
@@ -55,6 +55,10 @@
  * on the the kernel that cause the core dume we may want to have something
  * more constant like the maximum system page size (See include/asm-ia64/page.h).
  */
+/* IA64 manages the stack in differnt manner as compared to other architectures.
+ * task_struct lies at the bottom of stack.
+ */
+#undef STACK_START_POSITION
 #define STACK_START_POSITION(tsk)		(tsk)
 #define DUMP_MIN_PAGE_SHIFT                 	12
 #define DUMP_MIN_PAGE_SIZE                  	(1UL << DUMP_MIN_PAGE_SHIFT)
@@ -66,23 +70,8 @@
 #define DUMP_MAX_PAGE_MASK                  	(~(DUMP_MAX_PAGE_SIZE - 1))
 #define DUMP_MAX_PAGE_ALIGN(addr)           	(((addr) + DUMP_MAX_PAGE_SIZE - 1) & DUMP_MAX_PAGE_MASK)
 
-
-#undef	DUMP_PAGE_SHIFT				/* Redefining Default for ia64  */
-#undef	DUMP_PAGE_SIZE				/* "	"	"	"	*/
-#undef	DUMP_PAGE_MASK				/* "    "       "       "       */
-#undef	DUMP_PAGE_ALIGN				/* "    "       "       "       */
-#undef	DUMP_HEADER_OFFSET			/* "    "       "       "       */
-
-#define DUMP_HEADER_OFFSET                    PAGE_SIZE
-
 #define DUMP_EF_PAGE_SHIFT			DUMP_MIN_PAGE_SHIFT
 
-/* changed here coz its already defined in linux.h  confirm this */
-#define DUMP_PAGE_SHIFT				DUMP_MIN_PAGE_SHIFT
-#define DUMP_PAGE_SIZE				DUMP_MIN_PAGE_SIZE
-#define DUMP_PAGE_MASK				DUMP_MIN_PAGE_MASK
-#define DUMP_PAGE_ALIGN(addr)			DUMP_MIN_PAGE_ALIGN(addr)
-
 extern int _end,_start;
 #define START			((unsigned long) 0xa000000100000000)
 #define END			((unsigned long) &_end)
Index: linux.suse/include/linux/dump.h
===================================================================
--- linux.suse.orig/include/linux/dump.h	2004-05-25 21:05:33.476017216 +0200
+++ linux.suse/include/linux/dump.h	2004-05-25 21:05:33.525822778 +0200
@@ -37,16 +37,26 @@
 #define DUMP_PAGE_SHIFT 	PAGE_SHIFT
 #define DUMP_PAGE_MASK		PAGE_MASK
 #define DUMP_PAGE_ALIGN(addr)	PAGE_ALIGN(addr)
-#define DUMP_HEADER_OFFSET	PAGE_SIZE
+
+/*
+ * Dump offset changed from 4Kb to 64Kb to support multiple PAGE_SIZE 
+ * (kernel page size). Assumption goes that 64K is the highest page size 
+ * supported 
+ */
+
+#define DUMP_HEADER_OFFSET	(1ULL << 16)
 
 #define OLDMINORBITS	8
 #define OLDMINORMASK	((1U << OLDMINORBITS) -1)
 
-/* keep DUMP_PAGE_SIZE constant to 4K = 1<<12
- * it may be different from PAGE_SIZE then.
+/* Making DUMP_PAGE_SIZE = PAGE_SIZE, to support dumping on architectures 
+ * which support page sizes (PAGE_SIZE) greater than 4KB.
+ * Will it affect ia64 discontinuous memory systems ????
  */
-#define DUMP_PAGE_SIZE		4096
+#define DUMP_PAGE_SIZE		PAGE_SIZE
 
+/* thread_info lies at the bottom of stack, (Except IA64). */
+#define STACK_START_POSITION(tsk)               (tsk->thread_info)
 /* 
  * Predefined default memcpy() to use when copying memory to the dump buffer.
  *
Index: linux.suse/init/Makefile
===================================================================
--- linux.suse.orig/init/Makefile	2004-05-25 21:05:33.476017216 +0200
+++ linux.suse/init/Makefile	2004-05-25 21:09:07.288365991 +0200
@@ -10,7 +10,12 @@
 mounts-$(CONFIG_BLK_DEV_MD)	+= do_mounts_md.o
 
 extra-$(CONFIG_KERNTYPES)	+= kerntypes.o
-CFLAGS_kerntypes.o		:= -gdwarf-2 -fno-eliminate-unused-debug-types
+#For IA64, compile kerntypes in dwarf-2 format.
+ifeq ($(CONFIG_IA64),y)
+CFLAGS_kerntypes.o             := -gdwarf-2
+else
+CFLAGS_kerntypes.o             := -gstabs
+endif
 
 # files to be removed upon make clean
 clean-files := ../include/linux/compile.h
Index: linux.suse/kernel/sysctl.c
===================================================================
--- linux.suse.orig/kernel/sysctl.c	2004-05-25 21:05:33.476993795 +0200
+++ linux.suse/kernel/sysctl.c	2004-05-25 21:05:33.527775938 +0200
@@ -65,7 +65,7 @@
 extern int sysrq_enabled;
 extern int core_uses_pid;
 extern char core_pattern[];
-extern int cad_pid; 
+extern int cad_pid;
 extern int pid_max;
 extern int sysctl_lower_zone_protection;
 extern int min_free_kbytes;
@@ -1654,10 +1654,6 @@
 int proc_dointvec(ctl_table *table, int write, struct file *filp,
 		     void __user *buffer, size_t *lenp)
 {
-
-	if ( KERN_CADPID == table->ctl_name){
-		panic("From cad pid");
-	}
     return do_proc_dointvec(table,write,filp,buffer,lenp,
 		    	    NULL,NULL);
 }
