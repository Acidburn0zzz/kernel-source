From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH 39/40] reiserfs: split bl_when_delete

 This patch splits bl_when_delete into two functions so that
 it is more easily readable.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

---
 fs/reiserfs/do_balan.c |  147 +++++++++++++++++++++++++------------------------
 1 file changed, 77 insertions(+), 70 deletions(-)

--- a/fs/reiserfs/do_balan.c	2007-06-11 14:49:42.000000000 -0400
+++ b/fs/reiserfs/do_balan.c	2007-06-11 14:49:59.000000000 -0400
@@ -9,7 +9,7 @@
 /* and using buffers obtained after all above.				*/
 
 /**
- ** balance_leaf_when_delete
+ ** bl_when_delete
  ** balance_leaf
  ** do_balance
  **
@@ -78,7 +78,7 @@ inline void do_balance_mark_leaf_dirty(s
 
 /* summary:
  if deleting something ( tb->insert_size[0] < 0 )
-   return(balance_leaf_when_delete()); (flag d handled here)
+   return(bl_when_delete()); (flag d handled here)
  else
    if lnum is larger than 0 we put items into the left node
    if rnum is larger than 0 we put items into the right node
@@ -88,7 +88,7 @@ Note that all *num* count new items bein
 
 It would be easier to read balance_leaf() if each of these summary
 lines was a separate procedure rather than being inlined.  I think
-that there are many passages here and in balance_leaf_when_delete() in
+that there are many passages here and in bl_when_delete() in
 which two calls to one procedure can replace two passages, and it
 might save cache space and improve software maintenance costs to do so.
 
@@ -99,6 +99,54 @@ be performed by do_balance.
 
 -Hans */
 
+/* L[0] must be joined with S[0] */
+static int bl_delete_merge_left(struct tree_balance *tb)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
+
+	/* R[0] must be also joined with S[0] */
+	if (tb->rnum[0] == -1) {
+		if (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {
+			/* all contents of all the 3 buffers will be in L[0] */
+			if (PATH_H_POSITION(tb->tb_path, 1) == 0 &&
+		            B_NR_ITEMS(tb->FR[0]) > 1)
+				replace_key(tb, tb->CFL[0], tb->lkey[0],
+					    tb->FR[0], 1);
+
+			leaf_move_items(LEAF_FROM_S_TO_L, tb, n, -1, NULL);
+			leaf_move_items(LEAF_FROM_R_TO_L, tb,
+					B_NR_ITEMS(tb->R[0]), -1, NULL);
+
+			reiserfs_invalidate_buffer(tb, tbS0);
+			reiserfs_invalidate_buffer(tb, tb->R[0]);
+
+			return 0;
+		}
+		/* all contents of all the 3 buffers will be in R[0] */
+		leaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1, NULL);
+		leaf_move_items(LEAF_FROM_L_TO_R, tb, B_NR_ITEMS(tb->L[0]),
+		                -1, NULL);
+
+		/* right_delimiting_key is correct in R[0] */
+		replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
+
+		reiserfs_invalidate_buffer(tb, tbS0);
+		reiserfs_invalidate_buffer(tb, tb->L[0]);
+
+		return -1;
+	}
+
+	RFALSE(tb->rnum[0] != 0,
+	       "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
+
+	/* all contents of L[0] and S[0] will be in L[0] */
+	leaf_shift_left(tb, n, -1);
+	reiserfs_invalidate_buffer(tb, tbS0);
+	return 0;
+
+}
+
 /* Balance leaf node in case of delete or cut: insert_size[0] < 0
  *
  * lnum, rnum can have values >= -1
@@ -106,14 +154,13 @@ be performed by do_balance.
  *	 0 means that nothing should be done with the neighbor
  *	>0 means to shift entirely or partly the specified number of items to the neighbor
  */
-static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
+static int bl_when_delete(struct tree_balance *tb, int flag)
 {
-	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int item_pos = PATH_LAST_POSITION(tb->tb_path);
-	int pos_in_item = tb->tb_path->pos_in_item;
+	int n, pos_in_item = tb->tb_path->pos_in_item;
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	struct item_head *ih = B_N_PITEM_HEAD(tbS0, item_pos);
 	struct buffer_info bi;
-	int n;
-	struct item_head *ih;
 
 	if (flag != M_DELETE && flag != M_CUT) {
 		print_cur_tb("12040");
@@ -129,22 +176,20 @@ static int balance_leaf_when_delete(stru
 	RFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),
 	       "PAP-12010: tree can not be empty");
 
-	ih = B_N_PITEM_HEAD(tbS0, item_pos);
 	buffer_info_init_tbS0(tb, &bi);
 
 	/* Delete or truncate the item */
-
 	if (flag == M_DELETE) {
 		RFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],
-		       "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
-		       -tb->insert_size[0], ih);
+		       "vs-12013: mode Delete, insert size %d, "
+		       "ih to be deleted %h", -tb->insert_size[0], ih);
 
 		leaf_delete_items(&bi, 0, item_pos, 1, -1);
 
 		if (!item_pos && tb->CFL[0]) {
 			if (B_NR_ITEMS(tbS0)) {
-				replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0,
-					    0);
+				replace_key(tb, tb->CFL[0], tb->lkey[0],
+				            tbS0, 0);
 			} else {
 				if (!PATH_H_POSITION(tb->tb_path, 1))
 					replace_key(tb, tb->CFL[0], tb->lkey[0],
@@ -170,8 +215,8 @@ static int balance_leaf_when_delete(stru
 					     -tb->insert_size[0]);
 
 			RFALSE(!item_pos && !pos_in_item && !tb->CFL[0],
-			       "PAP-12030: can not change delimiting key. CFL[0]=%p",
-			       tb->CFL[0]);
+			       "PAP-12030: can not change delimiting key. "
+			       "CFL[0]=%p", tb->CFL[0]);
 
 			if (!item_pos && !pos_in_item && tb->CFL[0]) {
 				replace_key(tb, tb->CFL[0], tb->lkey[0],
@@ -186,69 +231,31 @@ static int balance_leaf_when_delete(stru
 		}
 	}
 
-	/* the rule is that no shifting occurs unless by shifting a node can be freed */
+	/* the rule is that no shifting occurs unless by
+	 * shifting a node can be freed */
 	n = B_NR_ITEMS(tbS0);
-	if (tb->lnum[0]) {	/* L[0] takes part in balancing */
-		if (tb->lnum[0] == -1) {	/* L[0] must be joined with S[0] */
-			if (tb->rnum[0] == -1) {	/* R[0] must be also joined with S[0] */
-				if (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {
-					/* all contents of all the 3 buffers will be in L[0] */
-					if (PATH_H_POSITION(tb->tb_path, 1) == 0
-					    && 1 < B_NR_ITEMS(tb->FR[0]))
-						replace_key(tb, tb->CFL[0],
-							    tb->lkey[0],
-							    tb->FR[0], 1);
-
-					leaf_move_items(LEAF_FROM_S_TO_L, tb, n,
-							-1, NULL);
-					leaf_move_items(LEAF_FROM_R_TO_L, tb,
-							B_NR_ITEMS(tb->R[0]),
-							-1, NULL);
-
-					reiserfs_invalidate_buffer(tb, tbS0);
-					reiserfs_invalidate_buffer(tb,
-								   tb->R[0]);
-
-					return 0;
-				}
-				/* all contents of all the 3 buffers will be in R[0] */
-				leaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1,
-						NULL);
-				leaf_move_items(LEAF_FROM_L_TO_R, tb,
-						B_NR_ITEMS(tb->L[0]), -1, NULL);
-
-				/* right_delimiting_key is correct in R[0] */
-				replace_key(tb, tb->CFR[0], tb->rkey[0],
-					    tb->R[0], 0);
-
-				reiserfs_invalidate_buffer(tb, tbS0);
-				reiserfs_invalidate_buffer(tb, tb->L[0]);
-
-				return -1;
-			}
-
-			RFALSE(tb->rnum[0] != 0,
-			       "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
-			/* all contents of L[0] and S[0] will be in L[0] */
-			leaf_shift_left(tb, n, -1);
-
-			reiserfs_invalidate_buffer(tb, tbS0);
-
-			return 0;
-		}
-		/* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */
+	/* L[0] takes part in balancing */
+	if (tb->lnum[0]) {
+		/* L[0] must be joined with S[0] */
+		if (tb->lnum[0] == -1)
+			return bl_delete_merge_left(tb);
 
+		/* a part of contents of S[0] will be in L[0] and
+		 * the rest part of S[0] will be in R[0] */
 		RFALSE((tb->lnum[0] + tb->rnum[0] < n) ||
 		       (tb->lnum[0] + tb->rnum[0] > n + 1),
-		       "PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent",
+		       "PAP-12050: rnum(%d) and lnum(%d) and "
+		       "item number(%d) in S[0] are not consistent",
 		       tb->rnum[0], tb->lnum[0], n);
 		RFALSE((tb->lnum[0] + tb->rnum[0] == n) &&
 		       (tb->lbytes != -1 || tb->rbytes != -1),
-		       "PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split",
+		       "PAP-12055: bad rbytes (%d)/lbytes (%d) "
+		       "parameters when items are not split",
 		       tb->rbytes, tb->lbytes);
 		RFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&
 		       (tb->lbytes < 1 || tb->rbytes != -1),
-		       "PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split",
+		       "PAP-12060: bad rbytes (%d)/lbytes (%d) "
+		       "parameters when items are split",
 		       tb->rbytes, tb->lbytes);
 
 		leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
@@ -1366,7 +1373,7 @@ static int balance_leaf(struct tree_bala
 
 	/* Make balance in case insert_size[0] < 0 */
 	if (tb->insert_size[0] < 0)
-		return balance_leaf_when_delete(tb, flag);
+		return bl_when_delete(tb, flag);
 
 	zeros_num = 0;
 	if (flag == M_INSERT && body == 0)
