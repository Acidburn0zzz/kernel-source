---
 fs/reiserfs/do_balan.c |  137 +++++++++++++++++++++++++------------------------
 1 file changed, 72 insertions(+), 65 deletions(-)

--- a/fs/reiserfs/do_balan.c	2007-05-29 19:49:21.000000000 -0400
+++ b/fs/reiserfs/do_balan.c	2007-05-29 20:03:39.000000000 -0400
@@ -99,6 +99,54 @@ be performed by do_balance.
 
 -Hans */
 
+/* L[0] must be joined with S[0] */
+static int bl_delete_merge_left(struct tree_balance *tb)
+{
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	int n = B_NR_ITEMS(tbS0);
+
+	/* R[0] must be also joined with S[0] */
+	if (tb->rnum[0] == -1) {
+		if (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {
+			/* all contents of all the 3 buffers will be in L[0] */
+			if (PATH_H_POSITION(tb->tb_path, 1) == 0 &&
+		            B_NR_ITEMS(tb->FR[0]) > 1)
+				replace_key(tb, tb->CFL[0], tb->lkey[0],
+					    tb->FR[0], 1);
+
+			leaf_move_items(LEAF_FROM_S_TO_L, tb, n, -1, NULL);
+			leaf_move_items(LEAF_FROM_R_TO_L, tb,
+					B_NR_ITEMS(tb->R[0]), -1, NULL);
+
+			reiserfs_invalidate_buffer(tb, tbS0);
+			reiserfs_invalidate_buffer(tb, tb->R[0]);
+
+			return 0;
+		}
+		/* all contents of all the 3 buffers will be in R[0] */
+		leaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1, NULL);
+		leaf_move_items(LEAF_FROM_L_TO_R, tb, B_NR_ITEMS(tb->L[0]),
+		                -1, NULL);
+
+		/* right_delimiting_key is correct in R[0] */
+		replace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);
+
+		reiserfs_invalidate_buffer(tb, tbS0);
+		reiserfs_invalidate_buffer(tb, tb->L[0]);
+
+		return -1;
+	}
+
+	RFALSE(tb->rnum[0] != 0,
+	       "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
+
+	/* all contents of L[0] and S[0] will be in L[0] */
+	leaf_shift_left(tb, n, -1);
+	reiserfs_invalidate_buffer(tb, tbS0);
+	return 0;
+
+}
+
 /* Balance leaf node in case of delete or cut: insert_size[0] < 0
  *
  * lnum, rnum can have values >= -1
@@ -108,12 +156,11 @@ be performed by do_balance.
  */
 static int balance_leaf_when_delete(struct tree_balance *tb, int flag)
 {
-	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
 	int item_pos = PATH_LAST_POSITION(tb->tb_path);
-	int pos_in_item = tb->tb_path->pos_in_item;
+	int n, pos_in_item = tb->tb_path->pos_in_item;
+	struct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);
+	struct item_head *ih = B_N_PITEM_HEAD(tbS0, item_pos);
 	struct buffer_info bi;
-	int n;
-	struct item_head *ih;
 
 	if (flag != M_DELETE && flag != M_CUT) {
 		print_cur_tb("12040");
@@ -129,22 +176,20 @@ static int balance_leaf_when_delete(stru
 	RFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),
 	       "PAP-12010: tree can not be empty");
 
-	ih = B_N_PITEM_HEAD(tbS0, item_pos);
 	buffer_info_init_tbS0(tb, &bi);
 
 	/* Delete or truncate the item */
-
 	if (flag == M_DELETE) {
 		RFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],
-		       "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
-		       -tb->insert_size[0], ih);
+		       "vs-12013: mode Delete, insert size %d, "
+		       "ih to be deleted %h", -tb->insert_size[0], ih);
 
 		leaf_delete_items(&bi, 0, item_pos, 1, -1);
 
 		if (!item_pos && tb->CFL[0]) {
 			if (B_NR_ITEMS(tbS0)) {
-				replace_key(tb, tb->CFL[0], tb->lkey[0], tbS0,
-					    0);
+				replace_key(tb, tb->CFL[0], tb->lkey[0],
+				            tbS0, 0);
 			} else {
 				if (!PATH_H_POSITION(tb->tb_path, 1))
 					replace_key(tb, tb->CFL[0], tb->lkey[0],
@@ -170,8 +215,8 @@ static int balance_leaf_when_delete(stru
 					     -tb->insert_size[0]);
 
 			RFALSE(!item_pos && !pos_in_item && !tb->CFL[0],
-			       "PAP-12030: can not change delimiting key. CFL[0]=%p",
-			       tb->CFL[0]);
+			       "PAP-12030: can not change delimiting key. "
+			       "CFL[0]=%p", tb->CFL[0]);
 
 			if (!item_pos && !pos_in_item && tb->CFL[0]) {
 				replace_key(tb, tb->CFL[0], tb->lkey[0],
@@ -186,69 +231,31 @@ static int balance_leaf_when_delete(stru
 		}
 	}
 
-	/* the rule is that no shifting occurs unless by shifting a node can be freed */
+	/* the rule is that no shifting occurs unless by
+	 * shifting a node can be freed */
 	n = B_NR_ITEMS(tbS0);
-	if (tb->lnum[0]) {	/* L[0] takes part in balancing */
-		if (tb->lnum[0] == -1) {	/* L[0] must be joined with S[0] */
-			if (tb->rnum[0] == -1) {	/* R[0] must be also joined with S[0] */
-				if (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {
-					/* all contents of all the 3 buffers will be in L[0] */
-					if (PATH_H_POSITION(tb->tb_path, 1) == 0
-					    && 1 < B_NR_ITEMS(tb->FR[0]))
-						replace_key(tb, tb->CFL[0],
-							    tb->lkey[0],
-							    tb->FR[0], 1);
-
-					leaf_move_items(LEAF_FROM_S_TO_L, tb, n,
-							-1, NULL);
-					leaf_move_items(LEAF_FROM_R_TO_L, tb,
-							B_NR_ITEMS(tb->R[0]),
-							-1, NULL);
-
-					reiserfs_invalidate_buffer(tb, tbS0);
-					reiserfs_invalidate_buffer(tb,
-								   tb->R[0]);
-
-					return 0;
-				}
-				/* all contents of all the 3 buffers will be in R[0] */
-				leaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1,
-						NULL);
-				leaf_move_items(LEAF_FROM_L_TO_R, tb,
-						B_NR_ITEMS(tb->L[0]), -1, NULL);
-
-				/* right_delimiting_key is correct in R[0] */
-				replace_key(tb, tb->CFR[0], tb->rkey[0],
-					    tb->R[0], 0);
-
-				reiserfs_invalidate_buffer(tb, tbS0);
-				reiserfs_invalidate_buffer(tb, tb->L[0]);
-
-				return -1;
-			}
-
-			RFALSE(tb->rnum[0] != 0,
-			       "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
-			/* all contents of L[0] and S[0] will be in L[0] */
-			leaf_shift_left(tb, n, -1);
-
-			reiserfs_invalidate_buffer(tb, tbS0);
-
-			return 0;
-		}
-		/* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */
+	/* L[0] takes part in balancing */
+	if (tb->lnum[0]) {
+		/* L[0] must be joined with S[0] */
+		if (tb->lnum[0] == -1)
+			return bl_delete_merge_left(tb);
 
+		/* a part of contents of S[0] will be in L[0] and
+		 * the rest part of S[0] will be in R[0] */
 		RFALSE((tb->lnum[0] + tb->rnum[0] < n) ||
 		       (tb->lnum[0] + tb->rnum[0] > n + 1),
-		       "PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent",
+		       "PAP-12050: rnum(%d) and lnum(%d) and "
+		       "item number(%d) in S[0] are not consistent",
 		       tb->rnum[0], tb->lnum[0], n);
 		RFALSE((tb->lnum[0] + tb->rnum[0] == n) &&
 		       (tb->lbytes != -1 || tb->rbytes != -1),
-		       "PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split",
+		       "PAP-12055: bad rbytes (%d)/lbytes (%d) "
+		       "parameters when items are not split",
 		       tb->rbytes, tb->lbytes);
 		RFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&
 		       (tb->lbytes < 1 || tb->rbytes != -1),
-		       "PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split",
+		       "PAP-12060: bad rbytes (%d)/lbytes (%d) "
+		       "parameters when items are split",
 		       tb->rbytes, tb->lbytes);
 
 		leaf_shift_left(tb, tb->lnum[0], tb->lbytes);
