From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH 05/15] ocfs2: event-driven quorum

 This patch separates o2net and o2quo from knowing about one another as much
 as possible. This is the first in a series of patches that will allow
 userspace cluster interaction. Quorum is separated out first, and will
 ultimately only be associated with the disk heartbeat as a separate module.

 To do so, this patch performs the following changes:
 * Introduces an event notifier for o2net events. These should be synchronous
   and as such, the in-kernel notifier_block implementation suits this
   perfectly. notifier_blocks can be registered and unregistered with
   o2net_{,un}register_notifier() and events are issued by o2net_notify().
 * Where o2net used to call o2quo functions directly, o2net events are now
   issued. o2quo registers as a listener for these events and handles them
   appropriately.
 * o2quo heartbeat callbacks are now called directly by heartbeat rather
   than going through o2net. Previously, o2net callbacks called o2quo callbacks
   immediately. This ordering is preserved by increasing o2quo's priority over
   o2net.
 * o2net knowledge of o2quo in header files has been moved to quorum.h
 * o2net's handling of quorum decisions on connection failure has been
   moved to o2quo.
 * o2quo is initialized by the nodemanager rather than by o2net.

 fs/ocfs2/cluster/nodemanager.c  |    2 
 fs/ocfs2/cluster/quorum.c       |   84 +++++++++++++++++++++++++++++++++++++---
 fs/ocfs2/cluster/quorum.h       |   13 ++----
 fs/ocfs2/cluster/tcp.c          |   53 ++++++++++++-------------
 fs/ocfs2/cluster/tcp.h          |   11 +++++
 fs/ocfs2/cluster/tcp_internal.h |    5 --
 6 files changed, 125 insertions(+), 43 deletions(-)

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

--- a/fs/ocfs2/cluster/nodemanager.c	2007-06-04 13:41:10.000000000 -0400
+++ b/fs/ocfs2/cluster/nodemanager.c	2007-06-04 15:54:59.000000000 -0400
@@ -913,6 +913,7 @@ static void __exit exit_o2nm(void)
 	configfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);
 	o2cb_sys_shutdown();
 
+	o2quo_exit();
 	o2net_exit();
 }
 
@@ -923,6 +924,7 @@ static int __init init_o2nm(void)
 	cluster_print_version();
 
 	o2hb_init();
+	o2quo_init();
 	o2net_init();
 
 	ocfs2_table_header = register_sysctl_table(ocfs2_root_table);
--- a/fs/ocfs2/cluster/quorum.c	2007-06-04 13:42:07.000000000 -0400
+++ b/fs/ocfs2/cluster/quorum.c	2007-06-04 16:06:16.000000000 -0400
@@ -49,6 +49,7 @@
 #include <linux/reboot.h>
 
 #include "heartbeat.h"
+#include "tcp.h"
 #include "nodemanager.h"
 #define MLOG_MASK_PREFIX ML_QUORUM
 #include "masklog.h"
@@ -64,8 +65,13 @@ static struct o2quo_state {
 	unsigned long		qs_conn_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];
 	int			qs_holds;
 	unsigned long		qs_hold_bm[BITS_TO_LONGS(O2NM_MAX_NODES)];
+	struct delayed_work	qs_node_work[O2NM_MAX_NODES];
 } o2quo_state;
 
+static struct o2hb_callback_func o2quo_hb_up_cb, o2quo_hb_down_cb;
+#define O2QUO_HB_PRI 0x1
+#define O2QUO_DELAY_MS   ((o2hb_dead_threshold + 2) * O2HB_REGION_TIMEOUT_MS)
+
 unsigned int o2quo_fence_option = 0;
 
 /* this is horribly heavy-handed.  It should instead flip the file
@@ -193,7 +199,7 @@ static void o2quo_clear_hold(struct o2qu
  * the connection.  the hold will be droped in conn_up or hb_down.  it might be
  * perpetuated by con_err until hb_down.  if we already have a conn, we might
  * be dropping a hold that conn_up got. */
-void o2quo_hb_up(u8 node)
+static void o2quo_hb_up(struct o2nm_node *_node, int node, void *data)
 {
 	struct o2quo_state *qs = &o2quo_state;
 
@@ -217,7 +223,7 @@ void o2quo_hb_up(u8 node)
 
 /* hb going down releases any holds we might have had due to this node from
  * conn_up, conn_err, or hb_up */
-void o2quo_hb_down(u8 node)
+static void o2quo_hb_down(struct o2nm_node *_node, int node, void *data)
 {
 	struct o2quo_state *qs = &o2quo_state;
 
@@ -235,6 +241,8 @@ void o2quo_hb_down(u8 node)
 	o2quo_clear_hold(qs, node);
 
 	spin_unlock(&qs->qs_lock);
+
+	cancel_delayed_work(&qs->qs_node_work[node]);
 }
 
 /* this tells us that we've decided that the node is still heartbeating
@@ -242,9 +250,11 @@ void o2quo_hb_down(u8 node)
  * and indicates that we must now make a quorum decision in the future,
  * though we might be doing so after waiting for holds to drain.  Here
  * we'll be dropping the hold from conn_err. */
-void o2quo_hb_still_up(u8 node)
+void o2quo_hb_still_up(struct work_struct *work)
 {
 	struct o2quo_state *qs = &o2quo_state;
+	struct delayed_work *dw = container_of(work, struct delayed_work, work);
+	u8 node = ((void *)dw - (void *)&qs->qs_node_work) / sizeof (*dw);
 
 	spin_lock(&qs->qs_lock);
 
@@ -287,7 +297,7 @@ void o2quo_conn_up(u8 node)
  * still heartbeating we grab a hold that will delay decisions until either the
  * node stops heartbeating from hb_down or the caller decides that the node is
  * still up and calls still_up */
-void o2quo_conn_err(u8 node)
+void o2quo_conn_down(u8 node)
 {
 	struct o2quo_state *qs = &o2quo_state;
 
@@ -310,15 +320,79 @@ void o2quo_conn_err(u8 node)
 	spin_unlock(&qs->qs_lock);
 }
 
-void o2quo_init(void)
+void o2quo_conn_err(u8 node)
+{
+	struct o2quo_state *qs = &o2quo_state;
+	o2quo_conn_down(node);
+	schedule_delayed_work(&qs->qs_node_work[node],
+	                      msecs_to_jiffies(O2QUO_DELAY_MS));
+}
+
+static int o2quo_net_notifier(struct notifier_block *self, unsigned long type,
+                              void *data)
+{
+	u8 node_num = *(u8 *) data;
+	switch (type) {
+	case O2NET_CONN_UP:
+                o2quo_conn_up(node_num);
+                break;
+	case O2NET_CONN_DOWN:
+                o2quo_conn_down(node_num);
+                break;
+	case O2NET_CONN_ERR:
+                o2quo_conn_err(node_num);
+                break;
+	}
+
+	return 0;
+}
+
+static struct notifier_block o2quo_net_nb = {
+	.notifier_call = o2quo_net_notifier,
+};
+
+static void o2quo_unregister_hb_callbacks(void)
+{
+	o2hb_unregister_callback(&o2quo_hb_up_cb);
+	o2hb_unregister_callback(&o2quo_hb_down_cb);
+}
+
+static int o2quo_register_hb_callbacks(void)
+{
+	int ret;
+
+	o2hb_setup_callback(&o2quo_hb_down_cb, O2HB_NODE_DOWN_CB,
+	                    o2quo_hb_down, NULL, O2QUO_HB_PRI);
+	o2hb_setup_callback(&o2quo_hb_up_cb, O2HB_NODE_UP_CB,
+	                    o2quo_hb_up, NULL, O2QUO_HB_PRI);
+
+	ret = o2hb_register_callback(&o2quo_hb_up_cb);
+	if (ret == 0)
+		ret = o2hb_register_callback(&o2quo_hb_down_cb);
+
+	if (ret)
+		o2quo_unregister_hb_callbacks();
+
+	return ret;
+}
+
+int o2quo_init(void)
 {
 	struct o2quo_state *qs = &o2quo_state;
+	long i;
 
 	spin_lock_init(&qs->qs_lock);
 	INIT_WORK(&qs->qs_work, o2quo_make_decision);
+	for (i = 0; i < O2NM_MAX_NODES; i++)
+		INIT_DELAYED_WORK(&qs->qs_node_work[i], o2quo_hb_still_up);
+
+	o2net_register_notifier(&o2quo_net_nb);
+	return o2quo_register_hb_callbacks();
 }
 
 void o2quo_exit(void)
 {
 	flush_scheduled_work();
+	o2quo_unregister_hb_callbacks();
+	o2net_unregister_notifier(&o2quo_net_nb);
 }
--- a/fs/ocfs2/cluster/quorum.h	2007-06-04 13:42:11.000000000 -0400
+++ b/fs/ocfs2/cluster/quorum.h	2007-06-04 13:49:01.000000000 -0400
@@ -26,14 +26,13 @@
 extern unsigned int o2quo_fence_option;
 #define FENCE_PANIC_OPTION	1
 
-void o2quo_init(void);
+int o2quo_init(void);
 void o2quo_exit(void);
-
-void o2quo_hb_up(u8 node);
-void o2quo_hb_down(u8 node);
-void o2quo_hb_still_up(u8 node);
-void o2quo_conn_up(u8 node);
-void o2quo_conn_err(u8 node);
 void o2quo_disk_timeout(void);
 
+/* we're delaying our quorum decision so that heartbeat will have timed
+ * out truly dead nodes by the time we come around to making decisions
+ * on their number */
+#define O2NET_QUORUM_DELAY_MS	((o2hb_dead_threshold + 2) * O2HB_REGION_TIMEOUT_MS)
+
 #endif /* O2CLUSTER_QUORUM_H */
--- a/fs/ocfs2/cluster/tcp.c	2007-05-31 11:29:39.000000000 -0400
+++ b/fs/ocfs2/cluster/tcp.c	2007-06-04 15:59:09.000000000 -0400
@@ -67,7 +67,6 @@
 #include "nodemanager.h"
 #define MLOG_MASK_PREFIX ML_TCP
 #include "masklog.h"
-#include "quorum.h"
 
 #include "tcp_internal.h"
 
@@ -110,7 +109,6 @@
 
 static DEFINE_RWLOCK(o2net_handler_lock);
 static struct rb_root o2net_handler_tree = RB_ROOT;
-
 static struct o2net_node o2net_nodes[O2NM_MAX_NODES];
 
 /* XXX someday we'll need better accounting */
@@ -128,7 +126,9 @@ static struct workqueue_struct *o2net_wq
 static struct work_struct o2net_listen_work;
 
 static struct o2hb_callback_func o2net_hb_up, o2net_hb_down;
-#define O2NET_HB_PRI 0x1
+#define O2NET_HB_PRI 0x2
+
+static struct blocking_notifier_head o2net_notifier_head;
 
 static struct o2net_handshake *o2net_hand;
 static struct o2net_msg *o2net_keep_req, *o2net_keep_resp;
@@ -426,9 +426,7 @@ static void o2net_set_nn_state(struct o2
 		wake_up(&nn->nn_sc_wq);
 
 	if (!was_err && nn->nn_persistent_error) {
-		o2quo_conn_err(o2net_num_from_nn(nn));
-		queue_delayed_work(o2net_wq, &nn->nn_still_up,
-				   msecs_to_jiffies(O2NET_QUORUM_DELAY_MS));
+		o2net_notify(O2NET_CONN_ERR, o2net_num_from_nn(nn));
 	}
 
 	if (was_valid && !valid) {
@@ -438,7 +436,8 @@ static void o2net_set_nn_state(struct o2
 	}
 
 	if (!was_valid && valid) {
-		o2quo_conn_up(o2net_num_from_nn(nn));
+		o2net_notify(O2NET_CONN_UP, o2net_num_from_nn(nn));
+
 		/* this is a bit of a hack.  we only try reconnecting
 		 * when heartbeating starts until we get a connection.
 		 * if that connection then dies we don't try reconnecting.
@@ -1569,14 +1568,6 @@ static void o2net_connect_expired(struct
 	spin_unlock(&nn->nn_lock);
 }
 
-static void o2net_still_up(struct work_struct *work)
-{
-	struct o2net_node *nn =
-		container_of(work, struct o2net_node, nn_still_up.work);
-
-	o2quo_hb_still_up(o2net_num_from_nn(nn));
-}
-
 /* ------------------------------------------------------------ */
 
 void o2net_disconnect_node(struct o2nm_node *node)
@@ -1591,7 +1582,6 @@ void o2net_disconnect_node(struct o2nm_n
 	if (o2net_wq) {
 		cancel_delayed_work(&nn->nn_connect_expired);
 		cancel_delayed_work(&nn->nn_connect_work);
-		cancel_delayed_work(&nn->nn_still_up);
 		flush_workqueue(o2net_wq);
 	}
 }
@@ -1599,8 +1589,6 @@ void o2net_disconnect_node(struct o2nm_n
 static void o2net_hb_node_down_cb(struct o2nm_node *node, int node_num,
 				  void *data)
 {
-	o2quo_hb_down(node_num);
-
 	if (node_num != o2nm_this_node())
 		o2net_disconnect_node(node);
 
@@ -1612,8 +1600,6 @@ static void o2net_hb_node_up_cb(struct o
 {
 	struct o2net_node *nn = o2net_nn_from_num(node_num);
 
-	o2quo_hb_up(node_num);
-
 	/* ensure an immediate connect attempt */
 	nn->nn_last_connect_attempt = jiffies -
 		(msecs_to_jiffies(o2net_reconnect_delay(node)) + 1);
@@ -1880,7 +1866,7 @@ int o2net_start_listening(struct o2nm_no
 		destroy_workqueue(o2net_wq);
 		o2net_wq = NULL;
 	} else
-		o2quo_conn_up(node->nd_num);
+		o2net_notify(O2NET_CONN_UP, node->nd_num);
 
 	return ret;
 }
@@ -1917,17 +1903,33 @@ void o2net_stop_listening(struct o2nm_no
 	sock_release(o2net_listen_sock);
 	o2net_listen_sock = NULL;
 
-	o2quo_conn_err(node->nd_num);
+	o2net_notify(O2NET_CONN_DOWN, node->nd_num);
 }
 
+void o2net_register_notifier(struct notifier_block *nb)
+{
+	blocking_notifier_chain_register(&o2net_notifier_head, nb);
+}
+EXPORT_SYMBOL_GPL(o2net_register_notifier);
+
+void o2net_unregister_notifier(struct notifier_block *nb)
+{
+	blocking_notifier_chain_unregister(&o2net_notifier_head, nb);
+}
+EXPORT_SYMBOL_GPL(o2net_unregister_notifier);
+
+void o2net_notify(enum o2net_notifier_type type, u8 node_num)
+{
+	blocking_notifier_call_chain(&o2net_notifier_head, type, &node_num);
+}
+EXPORT_SYMBOL_GPL(o2net_notify);
+
 /* ------------------------------------------------------------ */
 
 int o2net_init(void)
 {
 	unsigned long i;
 
-	o2quo_init();
-
 	o2net_hand = kzalloc(sizeof(struct o2net_handshake), GFP_KERNEL);
 	o2net_keep_req = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);
 	o2net_keep_resp = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);
@@ -1946,12 +1948,12 @@ int o2net_init(void)
 
 	for (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {
 		struct o2net_node *nn = o2net_nn_from_num(i);
+		memset(nn, 0, sizeof (*nn));
 
 		spin_lock_init(&nn->nn_lock);
 		INIT_DELAYED_WORK(&nn->nn_connect_work, o2net_start_connect);
 		INIT_DELAYED_WORK(&nn->nn_connect_expired,
 				  o2net_connect_expired);
-		INIT_DELAYED_WORK(&nn->nn_still_up, o2net_still_up);
 		/* until we see hb from a node we'll return einval */
 		nn->nn_persistent_error = -ENOTCONN;
 		init_waitqueue_head(&nn->nn_sc_wq);
@@ -1964,7 +1966,6 @@ int o2net_init(void)
 
 void o2net_exit(void)
 {
-	o2quo_exit();
 	kfree(o2net_hand);
 	kfree(o2net_keep_req);
 	kfree(o2net_keep_resp);
--- a/fs/ocfs2/cluster/tcp.h	2007-05-02 14:56:06.000000000 -0400
+++ b/fs/ocfs2/cluster/tcp.h	2007-06-04 13:49:01.000000000 -0400
@@ -50,6 +50,13 @@ struct o2net_msg
 	__u8  buf[0];
 };
 
+enum o2net_notifier_type {
+	O2NET_CONN_UP,
+	O2NET_CONN_DOWN,
+	O2NET_CONN_ERR,
+	O2NET_MAX_NOTIFIER,
+};
+
 typedef int (o2net_msg_handler_func)(struct o2net_msg *msg, u32 len, void *data,
 				     void **ret_data);
 typedef void (o2net_post_msg_handler_func)(int status, void *data,
@@ -114,6 +121,10 @@ void o2net_stop_listening(struct o2nm_no
 void o2net_disconnect_node(struct o2nm_node *node);
 int o2net_num_connected_peers(void);
 
+void o2net_register_notifier(struct notifier_block *nb);
+void o2net_unregister_notifier(struct notifier_block *nb);
+void o2net_notify(enum o2net_notifier_type type, u8 node_num);
+
 int o2net_init(void);
 void o2net_exit(void);
 
--- a/fs/ocfs2/cluster/tcp_internal.h	2007-05-31 11:29:39.000000000 -0400
+++ b/fs/ocfs2/cluster/tcp_internal.h	2007-06-04 13:49:01.000000000 -0400
@@ -103,11 +103,6 @@ struct o2net_node {
 	 * established.  this expiring gives up on the node and errors out
 	 * transmits */
 	struct delayed_work		nn_connect_expired;
-
-	/* after we give up on a socket we wait a while before deciding
-	 * that it is still heartbeating and that we should do some
-	 * quorum work */
-	struct delayed_work		nn_still_up;
 };
 
 struct o2net_sock_container {
