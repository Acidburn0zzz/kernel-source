--- a/include/linux/ckrm.h	2004-04-26 12:35:35.000000000 -0400
+++ b/include/linux/ckrm.h	2004-04-28 22:57:41.000000000 -0400
@@ -1,6 +1,6 @@
 /* ckrm.h - Class-based Kernel Resource Management (CKRM)
  *
- * Copyright (C) Hubertus Franke, IBM Corp. 2003
+ * Copyright (C) Hubertus Franke, IBM Corp. 2003,2004
  *           (C) Shailabh Nagar,  IBM Corp. 2003
  *           (C) Chandra Seetharaman, IBM Corp. 2003
  * 
@@ -25,52 +25,132 @@
  * 10 Nov 2003
  *        Added callbacks_active and surrounding logic. Added task paramter
  *        for all CE callbacks.
+ * 19 Nov 2004
+ *        New Event callback structure
  */
 
 #ifndef _LINUX_CKRM_H
 #define _LINUX_CKRM_H
 
-#ifdef __KERNEL__
 #ifdef CONFIG_CKRM
 
 // Data structure and function to get the list of registered 
 // resource controllers.
 
-#include <linux/sched.h>
+// #include <linux/sched.h>
 
-extern void ckrm_init(void);
+/* CKRM defines a set of events at particular points in the kernel
+ * at which callbacks registered by various class types are called
+ */
 
-// Interfaces used from classification points
-extern void ckrm_cb_exec(const char *);
-extern void ckrm_cb_fork(struct task_struct *);
-extern void ckrm_cb_exit(struct task_struct *);
-extern void ckrm_cb_uid(void);
-extern void ckrm_cb_gid(void);
-extern void ckrm_cb_apptag(void);
-extern void ckrm_cb_login(void);
-extern void ckrm_cb_useradd(struct user_struct *);
-extern void ckrm_cb_userdel(struct user_struct *);
-extern void ckrm_new_task(struct task_struct *);
+enum ckrm_event {
+	/* we distinguish various events types
+         *
+	 * (a) CKRM_LATCHABLE_EVENTS
+         *      events can be latched for event callbacks by classtypes
+         *
+	 * (b) CKRM_NONLATACHBLE_EVENTS
+         *     events can not be latched but can be used to call classification
+         * 
+	 * (c) event that are used for notification purposes
+	 *     range: [ CKRM_EVENT_CANNOT_CLASSIFY .. )
+         */
+
+	/* events (a) */
+
+	CKRM_LATCHABLE_EVENTS,
+
+	CKRM_EVENT_NEWTASK = CKRM_LATCHABLE_EVENTS,
+	CKRM_EVENT_FORK,
+	CKRM_EVENT_EXIT,
+	CKRM_EVENT_EXEC,
+	CKRM_EVENT_UID,
+	CKRM_EVENT_GID,
+	CKRM_EVENT_LOGIN,
+	CKRM_EVENT_USERADD,
+	CKRM_EVENT_USERDEL,
+	CKRM_EVENT_LISTEN_START,
+	CKRM_EVENT_LISTEN_STOP,
+	CKRM_EVENT_APPTAG,
+
+	/* events (b) */
+
+	CKRM_NONLATCHABLE_EVENTS,
+
+	CKRM_EVENT_RECLASSIFY = CKRM_NONLATCHABLE_EVENTS,
+
+	/* events (c) */
+	CKRM_NOTCLASSIFY_EVENTS,
+
+	CKRM_EVENT_MANUAL = CKRM_NOTCLASSIFY_EVENTS,
+	
+	CKRM_NUM_EVENTS
+};
+#endif
 
-// Utility functions.
-extern int get_exe_path_name(struct task_struct *, char *, int);
+#ifdef __KERNEL__
+#ifdef CONFIG_CKRM
+
+extern void ckrm_invoke_event_cb_chain(enum ckrm_event ev, void *arg);
+
+typedef void (*ckrm_event_cb)(void *arg);
+
+struct ckrm_hook_cb {
+	ckrm_event_cb fct;
+	struct ckrm_hook_cb *next;
+};
+
+#define CKRM_DEF_CB(EV,fct)					\
+static inline void ckrm_cb_##fct(void)				\
+{								\
+         ckrm_invoke_event_cb_chain(CKRM_EVENT_##EV,NULL);      \
+}
+
+#define CKRM_DEF_CB_ARG(EV,fct,argtp)					\
+static inline void ckrm_cb_##fct(argtp arg)				\
+{									\
+         ckrm_invoke_event_cb_chain(CKRM_EVENT_##EV,(void*)arg);	\
+}
 
 #else // !CONFIG_CKRM
 
-#define ckrm_init()
-#define ckrm_cb_exec(cmd)
-#define ckrm_cb_fork(t)
-#define ckrm_cb_exit(t)
-#define ckrm_cb_uid()
-#define ckrm_cb_gid()
-#define ckrm_cb_apptag()
-#define ckrm_cb_login()
-#define ckrm_cb_useradd(x)
-#define ckrm_cb_userdel(x)
-#define ckrm_new_task(x)
+#define CKRM_DEF_CB(EV,fct)			\
+static inline void ckrm_cb_##fct(void)  { }
+
+#define CKRM_DEF_CB_ARG(EV,fct,argtp)		\
+static inline void ckrm_cb_##fct(argtp arg) { }
 
 #endif // CONFIG_CKRM
 
+/*-----------------------------------------------------------------
+ *   define the CKRM event functions 
+ *               EVENT          FCT           ARG         
+ *-----------------------------------------------------------------*/
+
+// types we refer at 
+struct task_struct;
+struct sock;
+struct user_struct;
+
+CKRM_DEF_CB_ARG( FORK         , fork,         struct task_struct *);
+CKRM_DEF_CB_ARG( EXEC         , exec,         const char*         );
+CKRM_DEF_CB    ( UID          , uid                               );
+CKRM_DEF_CB    ( GID          , gid                               );
+CKRM_DEF_CB    ( APPTAG       , apptag                            );
+CKRM_DEF_CB    ( LOGIN        , login                             );
+CKRM_DEF_CB_ARG( USERADD      , useradd,      struct user_struct *);
+CKRM_DEF_CB_ARG( USERDEL      , userdel,      struct user_struct *);
+CKRM_DEF_CB_ARG( LISTEN_START , listen_start, struct sock *       );
+CKRM_DEF_CB_ARG( LISTEN_STOP  , listen_stop,  struct sock *       );
+
+// and a few special one's
+void ckrm_cb_newtask(struct task_struct *);
+void ckrm_cb_exit(struct task_struct *);
+
+// some other functions required
+extern void ckrm_init(void);
+extern int get_exe_path_name(struct task_struct *, char *, int);
+
 #endif // __KERNEL__
 
 #endif // _LINUX_CKRM_H
--- a/include/linux/ckrm_ce.h	2004-04-26 12:35:37.000000000 -0400
+++ b/include/linux/ckrm_ce.h	2004-04-28 22:57:41.000000000 -0400
@@ -20,6 +20,8 @@
  *
  * 12 Nov 2003
  *        Created.
+ * 22 Apr 2004
+ *        Adopted to classtypes
  */
 
 #ifndef _LINUX_CKRM_CE_H
@@ -27,65 +29,48 @@
 
 #ifdef CONFIG_CKRM
 
-// Max engine name length
-#define CKRM_MAX_ENG_NAME 128
+#include "ckrm.h"  // getting the event names
 
 /* Action parameters identifying the cause of a task<->class notify callback 
  * these can perculate up to user daemon consuming records send by the classification
  * engine
  */
 
-enum {
-	CKRM_ACTION_RECLASSIFY,
-	CKRM_ACTION_MANUAL,
-	CKRM_ACTION_FORK,
-	CKRM_ACTION_EXEC,
-	CKRM_ACTION_GID,
-	CKRM_ACTION_UID,
-	CKRM_ACTION_LISTEN,
-
-	CKRM_ACTION_LAST  /* always the last entry */
-};
-
 #ifdef __KERNEL__
 
+typedef void* (*ce_classify_fct_t)(enum ckrm_event event, void *obj, ... );   
+typedef void  (*ce_notify_fct_t)  (enum ckrm_event event, void *classobj, void *obj);
+
 typedef struct ckrm_eng_callback {
 	/* general state information */
-	char ckrm_eng_name[CKRM_MAX_ENG_NAME];
 	int  always_callback;  /* set if CE should always be called back regardless of numclasses */
 
 	/* callbacks which are called without holding locks */
 
-	void * (*fork)      (struct task_struct*); // on fork
-	void * (*exec)      (struct task_struct*,const char *filename); // on exec
-
-	void * (*reclassify)(struct task_struct *); // on need
-	void * (*uid)       (struct task_struct*);  // on uid change
-	void * (*gid)       (struct task_struct*);  // on gid change
-	void * (*listen)    (void *n); // listen callback
-
-	void   (*manual)    (struct task_struct *);  /* mark manual */
+	unsigned long c_interest;         /* set of classification events CE is interested in */
+	ce_classify_fct_t   classify;     /* generic classify */
 
-	void   (*class_add) (const char *name, void *core);   /* class added */
+	void   (*class_add)   (const char *name, void *core); /* class added */
 	void   (*class_delete)(const char *name, void *core); /* class deleted */
 
-
-	/* callba which are called while holding task_lock(tsk) */
-	void (*notify)(struct task_struct *tsk, void *core, int action); /* notify on class switch */
-	void (*exit)  (struct task_struct *tsk);                         /* on exit */
-
-	/* and more to come */
+	/* callback which are called while holding task_lock(tsk) */
+	unsigned long n_interest;         /* set of notification events CE is interested in */
+	ce_notify_fct_t     notify;       /* notify on class switch */
 
 } ckrm_eng_callback_t;
 
+struct inode;
+struct dentry; 
+
 typedef struct rbce_eng_callback {
 	int (*mkdir)(struct inode *, struct dentry *, int); // mkdir
 	int (*rmdir)(struct inode *, struct dentry *); // rmdir
 } rbce_eng_callback_t;
 
-extern int ckrm_register_engine(ckrm_eng_callback_t *);
-extern int ckrm_unregister_engine(ckrm_eng_callback_t *);
-extern void *ckrm_classobj(char *);
+extern int ckrm_register_engine  (const char *name, ckrm_eng_callback_t *);
+extern int ckrm_unregister_engine(const char *name);
+
+extern void *ckrm_classobj(char *, int *classtype);
 extern int get_exe_path_name(struct task_struct *t, char *filename, int max_size);
 
 extern int rcfs_register_engine(rbce_eng_callback_t *);
@@ -93,8 +78,11 @@
 
 extern int ckrm_reclassify(int pid);
 
+#ifndef _LINUX_CKRM_RC_H
+// ckrm kernel has inlined functions for this which are exported
 extern void ckrm_core_grab(void *);
 extern void ckrm_core_drop(void *);
+#endif
 
 #endif // CONFIG_CKRM
 
--- a/include/linux/ckrm_rc.h	2004-04-26 12:35:37.000000000 -0400
+++ b/include/linux/ckrm_rc.h	2004-04-28 23:04:33.000000000 -0400
@@ -1,4 +1,4 @@
-/* ckrm_res.h - Header file to be used by Resource controllers of CKRM
+/* ckrm_rc.h - Header file to be used by Resource controllers of CKRM
  *
  * Copyright (C) Hubertus Franke, IBM Corp. 2003
  *           (C) Shailabh Nagar,  IBM Corp. 2003
@@ -23,8 +23,8 @@
  *        Created.
  */
 
-#ifndef _LINUX_CKRM_RES_H
-#define _LINUX_CKRM_RES_H
+#ifndef _LINUX_CKRM_RC_H
+#define _LINUX_CKRM_RC_H
 
 #ifdef __KERNEL__
 
@@ -32,149 +32,335 @@
 
 #include <linux/list.h>
 #include <linux/ckrm.h>
+#include <linux/ckrm_ce.h>    
 #include <linux/seq_file.h>
 
-// Class types
-enum {
-	CKRM_TASK_CLASS=1,
-	CKRM_NET_CLASS,
-};
-
-// predefined constants
-#define CKRM_MAX_RES_CTLRS 32
-#define CKRM_MAX_RES_NAME		128
-
-// Predefined macros for known kernel resources
-enum resid {
-	CKRM_RES_DUMMY=0,
-	CKRM_RES_CPU,
-	CKRM_RES_MEM,
-	CKRM_RES_IO,
-	CKRM_RES_SAQ,
-	CKRM_RES_MAX_RSVD,
-};
 
-#define CKRM_CORE_MAGIC		0xBADCAFFE
-
-// Share specifications
+/* maximum number of class types */
+#define CKRM_MAX_CLASSTYPES         32       
+/* maximum classtype name length */
+#define CKRM_MAX_CLASSTYPE_NAME     32       
+
+/* maximum resource controllers per classtype */
+#define CKRM_MAX_RES_CTLRS           8     
+/* maximum resource controller name length */
+#define CKRM_MAX_RES_NAME          128       
+
+
+struct ckrm_core_class;
+struct ckrm_classtype;
+
+/********************************************************************************
+ * Share specifications
+ *******************************************************************************/
 
 typedef struct ckrm_shares {
 	int my_guarantee;
 	int my_limit;
 	int total_guarantee;
-	int total_limit;
+	int max_limit;
 	int unused_guarantee;  // not used as parameters
-	int unused_limit;      // not used as parameters
+	int cur_max_limit;     // not used as parameters
 } ckrm_shares_t;
 
 #define CKRM_SHARE_UNCHANGED     (-1)  // value to indicate no change
 #define CKRM_SHARE_DONTCARE      (-2)  // value to indicate don't care.
 #define CKRM_SHARE_DFLT_TOTAL_GUARANTEE (100) // Start off with these values
-#define CKRM_SHARE_DFLT_TOTAL_LIMIT     (100) // to simplify set_res_shares logic
+#define CKRM_SHARE_DFLT_MAX_LIMIT     (100) // to simplify set_res_shares logic
 
-/* CKRM net struct used to keep track of the network members.
- */
-struct ckrm_net_struct {
-	int family;			// IPPROTO_IPV4 || IPPROTO_IPV6
-					// Currently only IPV4 is supported
-	__u32 daddr4;			// V4 listener's address
-	__u16 dport;			// listener's port
-	struct ckrm_core_class	*core;
-	struct list_head ckrm_link;
-};
+
+/********************************************************************************
+ * RESOURCE CONTROLLERS
+ *******************************************************************************/
+
+/* resource controller callback structure */
+
+typedef struct ckrm_res_ctlr {
+	char res_name[CKRM_MAX_RES_NAME];
+	int  res_hdepth;	          // maximum hierarchy
+	int  resid;         	          // (for now) same as the enum resid
+	struct ckrm_classtype *classtype; // classtype owning this resource controller
+
+	/* allocate/free new resource class object for resource controller */
+	void *(*res_alloc)  (struct ckrm_core_class *this, struct ckrm_core_class *parent);
+	void  (*res_free)   (void *);
+
+	/* set/get limits/guarantees for a resource controller class */
+	int  (*set_share_values) (void* , struct ckrm_shares *shares);
+	int  (*get_share_values) (void* , struct ckrm_shares *shares);
+
+	/* statistics and configuration access */
+	int  (*get_stats)    (void* , struct seq_file *);
+	int  (*reset_stats)  (void *);
+	int  (*show_config)  (void* , struct seq_file *);
+	int  (*set_config)   (void* , const char *cfgstr);
+
+	void (*change_resclass)(void *, void *, void *);
+
+} ckrm_res_ctlr_t;
+
+/***************************************************************************************
+ * CKRM_CLASSTYPE
+ *
+ *   A <struct ckrm_classtype> object describes a dimension for CKRM to classify 
+ *   along. I needs to provide methods to create and manipulate class objects in
+ *   this dimension
+ ***************************************************************************************/
+
+/* list of predefined class types, we always recognize */
+#define CKRM_CLASSTYPE_TASK_CLASS    0
+#define CKRM_CLASSTYPE_SOCKET_CLASS 1
+#define CKRM_RESV_CLASSTYPES         2  /* always +1 of last known type */
+
+#define CKRM_MAX_TYPENAME_LEN       32
+
+
+typedef struct ckrm_classtype {
+	/* Hubertus:   Rearrange slots so that they are more cache friendly during access */
+
+	/* resource controllers */
+	spinlock_t        res_ctlrs_lock;        /* protect data below (other than atomics) */
+	int               max_res_ctlrs;         /* maximum number of resource controller allowed */
+	int               max_resid;             /* maximum resid used                      */
+	int               resid_reserved;        /* maximum number of reserved controllers  */
+	long              bit_res_ctlrs;         /* bitmap of resource ID used              */
+	atomic_t          nr_resusers[CKRM_MAX_RES_CTLRS];
+	ckrm_res_ctlr_t*  res_ctlrs[CKRM_MAX_RES_CTLRS];
+
+	/* state about my classes */
+
+	struct ckrm_core_class   *default_class; // pointer to default class
+	struct list_head          classes;       // listhead to link up all classes of this classtype
+	int                       num_classes;    // how many classes do exist
+
+	/* state about my ce interaction */
+	int                       ce_regd;       // Has a CE been registered for this classtype
+	int                       ce_cb_active;  // are callbacks active
+	atomic_t                  ce_nr_users;   // how many transient calls active
+	struct ckrm_eng_callback  ce_callbacks;  // callback engine
+
+ 	// Begin classtype-rcfs private data. No rcfs/fs specific types used. 
+ 	int               mfidx;             // Index into genmfdesc array used to initialize
+ 	                                     // mfdesc and mfcount 
+ 	void              *mfdesc;           // Array of descriptors of root and magic files
+ 	int               mfcount;           // length of above array 
+ 	void              *rootde;           // root dentry created by rcfs
+ 	// End rcfs private data 
+
+	char name[CKRM_MAX_TYPENAME_LEN];    // currently same as mfdesc[0]->name but could be different
+ 	int  typeID;			       /* unique TypeID                         */
+	int  maxdepth;                         /* maximum depth supported               */
+
+	/* functions to be called on any class type by external API's */
+	struct ckrm_core_class*  (*alloc)(struct ckrm_core_class *parent, const char *name);   /* alloc class instance */
+	int                      (*free) (struct ckrm_core_class *cls);                        /* free  class instance */
+	
+	int                      (*show_members)(struct ckrm_core_class *, struct seq_file *);
+	int                      (*show_stats)  (struct ckrm_core_class *, struct seq_file *);
+	int                      (*show_config) (struct ckrm_core_class *, struct seq_file *);
+	int                      (*show_shares) (struct ckrm_core_class *, struct seq_file *);
+
+	int                      (*reset_stats) (struct ckrm_core_class *, const char *resname, 
+						 const char *);
+	int                      (*set_config)  (struct ckrm_core_class *, const char *resname,
+						 const char *cfgstr);
+	int                      (*set_shares)  (struct ckrm_core_class *, const char *resname,
+						 struct ckrm_shares *shares);
+	int                      (*forced_reclassify)(struct ckrm_core_class *, const char *);
+
+  
+	/* functions to be called on a class type by ckrm internals */
+	void                     (*add_resctrl)(struct ckrm_core_class *, int resid);     // class initialization for new RC
+ 
+} ckrm_classtype_t;
+
+/******************************************************************************************
+ * CKRM CORE CLASS
+ *      common part to any class structure (i.e. instance of a classtype)
+ ******************************************************************************************/
 
 /* basic definition of a hierarchy that is to be used by the the CORE classes
  * and can be used by the resource class objects
  */
 
-struct ckrm_hnode {
-#ifndef NEW_HNODE_IMPLMN
-	struct ckrm_hnode *parent;
-#else
-	struct ckrm_core_class *parent;
-#endif
+#define CKRM_CORE_MAGIC		0xBADCAFFE
+
+typedef struct ckrm_hnode {
+        struct ckrm_core_class *parent;
 	struct list_head   siblings; /* linked list of siblings */
 	struct list_head   children; /* anchor for children     */
-};
+} ckrm_hnode_t;
 
-/* core class definition */
-	
 typedef struct ckrm_core_class {
-	struct list_head tasklist; // list of tasks in this core class; anchor
-	int class_type;			// task class or otherwise
-  	spinlock_t ckrm_lock;           // to protect the list and the array above
-	struct list_head clslist;       // to link up all classes in a single list
+	struct ckrm_classtype *classtype; // what type does this core class belong to
+        void* res_class[CKRM_MAX_RES_CTLRS];                 // pointer to array of resource classes
+  	spinlock_t ckrm_lock;             // to protect the list and the array above
+	struct list_head objlist;         // generic list for any object list to be maintained by class
+	struct list_head clslist;         // to link up all classes in a single list type wrt to type
 	struct dentry  *dentry;           // dentry of inode in the RCFS
 	int magic;
-	void *res_class[CKRM_MAX_RES_CTLRS]; // per registered resource
 	struct ckrm_hnode  hnode;    // hierarchy
 	rwlock_t hnode_rwlock; // rw_clock protecting the hnode above.
 	atomic_t refcnt;
-	char name[100];// debug only
+	const char *name;
 } ckrm_core_class_t;
 
-#define ckrm_get_res_class(rescls,resid,type)   ((type*)((rescls)->res_class[resid]))
-
-/* resource controller callback structure */
-
-typedef struct ckrm_res_callback {
-	char res_name[CKRM_MAX_RES_NAME];
-	int  res_hdepth;	// maximum hierarchy
-	int  res_type;	        // class type to which resource belongs
-	int  resid;		// (for now) same as the enum resid
+/* type coerce between derived class types and ckrm core class type */
+#define class_type(type,coreptr)   container_of(coreptr,type,core)
+#define class_core(clsptr)         (&(clsptr)->core)
+/* locking classes */
+#define class_lock(coreptr)        spin_lock(&(coreptr)->ckrm_lock)
+#define class_unlock(coreptr)      spin_unlock(&(coreptr)->ckrm_lock)
+/* what type is a class of ISA */
+#define class_isa(clsptr)          (class_core(clsptr)->classtype)
 
-	/* allocate/free new resource class object for resource controller */
-	void * (*res_alloc)  (struct ckrm_core_class *, struct ckrm_core_class *);
-	void (*res_free)     (void *);
-	/* reinitialize existing resource class object */
-	void (*res_initcls)  (void *);
-
-	/* set/get limits/guarantees for a resource controller class */
-	int  (*set_share_values)    (void *, struct ckrm_shares *);
-	int  (*get_share_values)    (void *, struct ckrm_shares *);
 
-	/* statistics access */
-	int  (*get_stats)    (void *, struct seq_file *);
+/******************************************************************************************
+ * OTHER
+ ******************************************************************************************/
 
-	void (*change_resclass)(void *, void *, void *);
-} ckrm_res_callback_t;
+#define ckrm_get_res_class(rescls,resid,type)   ((type*)((rescls)->res_class[resid]))
 
-extern int ckrm_register_res_ctlr(ckrm_res_callback_t *);
-extern int ckrm_unregister_res_ctlr(int);
+extern int ckrm_register_res_ctlr   (struct ckrm_classtype *, ckrm_res_ctlr_t *);
+extern int ckrm_unregister_res_ctlr (ckrm_res_ctlr_t *);
 
-extern inline unsigned int is_core_valid(ckrm_core_class_t *);
-extern inline unsigned int is_res_regd(int);
-extern inline int ckrm_resid_lookup (char *);
+extern int ckrm_validate_and_grab_core(struct ckrm_core_class *core);
+extern int ckrm_init_core_class(struct ckrm_classtype  *clstype,struct ckrm_core_class *dcore,
+				struct ckrm_core_class *parent, const char *name);
+extern int ckrm_release_core_class(struct ckrm_core_class *);   // Hubertus .. can disappear after cls del debugging
+extern struct ckrm_res_ctlr *ckrm_resctlr_lookup(struct ckrm_classtype *type, const char *resname);
 
-#define for_each_resid(rid) \
-	for (rid=0; rid < CKRM_MAX_RES_CTLRS; rid++) 
+#if 0
 
+// Hubertus ... need to straighten out all these I don't think we will even call thsie ore are we 
 
 /* interface to the RCFS filesystem */
-
-extern struct ckrm_core_class ckrm_dflt_class;
-extern struct ckrm_core_class ckrm_net_root;
-
-extern struct ckrm_core_class *ckrm_alloc_core_class(struct ckrm_core_class *,
-				struct dentry *);
-extern int ckrm_free_core_class(struct ckrm_core_class *);
+extern struct ckrm_core_class *ckrm_alloc_core_class(struct ckrm_core_class *, const char *, int);
 
 // Reclassify the given pid to the given core class by force
 extern void ckrm_forced_reclassify_pid(int, struct ckrm_core_class *);
 
 // Reclassify the given net_struct  to the given core class by force
-extern void ckrm_forced_reclassify_net(struct ckrm_net_struct *, 
+extern void ckrm_forced_reclassify_laq(struct ckrm_net_struct *, 
 		struct ckrm_core_class *);
 
+#endif
+
+extern void ckrm_lock_hier(struct ckrm_core_class *);
+extern void ckrm_unlock_hier(struct ckrm_core_class *);
+extern struct ckrm_core_class * ckrm_get_next_child(struct ckrm_core_class *,
+		            struct ckrm_core_class *);
+
+extern void child_guarantee_changed(struct ckrm_shares *, int, int);
+extern void child_maxlimit_changed(struct ckrm_shares *, int);
+extern int  set_shares(struct ckrm_shares *, struct ckrm_shares *, struct ckrm_shares *);
+
+/* classtype registration and lookup */
+extern int ckrm_register_classtype  (struct ckrm_classtype *clstype);
+extern int ckrm_unregister_classtype(struct ckrm_classtype *clstype);
+extern struct ckrm_classtype* ckrm_find_classtype_by_name(const char *name);
+
+/* default functions that can be used in classtypes's function table */
+extern int ckrm_class_show_shares(struct ckrm_core_class *core, struct seq_file *seq);
+extern int ckrm_class_show_stats(struct ckrm_core_class *core, struct seq_file *seq);
+extern int ckrm_class_show_config(struct ckrm_core_class *core, struct seq_file *seq);
+extern int ckrm_class_set_config(struct ckrm_core_class *core, const char *resname, const char *cfgstr);
+extern int ckrm_class_set_shares(struct ckrm_core_class *core, const char *resname, struct ckrm_shares *shares);
+extern int ckrm_class_reset_stats(struct ckrm_core_class *core, const char *resname, const char *unused);
+
+#if 0
+extern void ckrm_ns_hold(struct ckrm_net_struct *);
+extern void ckrm_ns_put(struct ckrm_net_struct *);
+extern void *ckrm_set_rootcore_byname(char *, void *);
+#endif
+
+static inline void ckrm_core_grab(struct ckrm_core_class *core)  
+{ 
+	if (core) atomic_inc(&core->refcnt);
+}
+
+static inline void ckrm_core_drop(struct ckrm_core_class *core) 
+{ 
+	// only make definition available in this context
+	extern void ckrm_free_core_class(struct ckrm_core_class *core);   
+	if (core && (atomic_dec_and_test(&core->refcnt)))
+	    ckrm_free_core_class(core);
+}
+
+static inline unsigned int
+ckrm_is_core_valid(ckrm_core_class_t *core)
+{
+	return (core && (core->magic == CKRM_CORE_MAGIC));
+}
+
+// iterate through all associate resource controllers:
+// requires following arguments (ckrm_core_class *cls, 
+//                               ckrm_res_ctrl   *ctlr,
+//                               void            *robj,
+//                               int              bmap)
+#define forall_class_resobjs(cls,rcbs,robj,bmap)									\
+       for ( bmap=((cls->classtype)->bit_res_ctlrs) ;									\
+	     ({ int rid; ((rid=ffs(bmap)-1) >= 0) && 									\
+	                 (bmap&=~(1<<rid),((rcbs=cls->classtype->res_ctlrs[rid]) && (robj=cls->res_class[rid]))); }) ;	\
+           )
+
+extern struct ckrm_classtype* ckrm_classtypes[]; /* should provide a different interface */
+
+
+/*-----------------------------------------------------------------------------
+ * CKRM event callback specification for the classtypes or resource controllers 
+ *   typically an array is specified using CKRM_EVENT_SPEC terminated with 
+ *   CKRM_EVENT_SPEC_LAST and then that array is registered using
+ *   ckrm_register_event_set.
+ *   Individual registration of event_cb is also possible
+ *-----------------------------------------------------------------------------*/
+
+struct ckrm_event_spec {
+	enum ckrm_event     ev;
+	struct ckrm_hook_cb cb;
+};
+#define CKRM_EVENT_SPEC(EV,FCT) { CKRM_EVENT_##EV, { (ckrm_event_cb)FCT, NULL } }
 
-extern void ckrm_hnode_add(struct ckrm_hnode *,struct ckrm_hnode *);
-extern int  ckrm_hnode_remove(struct ckrm_hnode *);
+int ckrm_register_event_set(struct ckrm_event_spec especs[]);
+int ckrm_unregister_event_set(struct ckrm_event_spec especs[]);
+int ckrm_register_event_cb(enum ckrm_event ev, struct ckrm_hook_cb *cb);
+int ckrm_unregister_event_cb(enum ckrm_event ev, struct ckrm_hook_cb *cb);
+
+/******************************************************************************************
+ * CE Invocation interface
+ ******************************************************************************************/
+
+#define ce_protect(ctype)      (atomic_inc(&((ctype)->ce_nr_users)))
+#define ce_release(ctype)      (atomic_dec(&((ctype)->ce_nr_users)))
+
+// CE Classification callbacks with 
+
+#define CE_CLASSIFY_NORET(ctype, event, objs_to_classify...)					\
+do {												\
+	if ((ctype)->ce_cb_active && (test_bit(event,&(ctype)->ce_callbacks.c_interest)))	\
+		(*(ctype)->ce_callbacks.classify)(event, objs_to_classify);			\
+} while (0)
+
+#define CE_CLASSIFY_RET(ret, ctype, event, objs_to_classify...)					\
+do {												\
+	if ((ctype)->ce_cb_active && (test_bit(event,&(ctype)->ce_callbacks.c_interest)))	\
+		ret = (*(ctype)->ce_callbacks.classify)(event, objs_to_classify);		\
+} while (0)
+
+#define CE_NOTIFY(ctype, event, cls, objs_to_classify)						\
+do {												\
+	if ((ctype)->ce_cb_active && (test_bit(event,&(ctype)->ce_callbacks.n_interest)))	\
+		(*(ctype)->ce_callbacks.notify)(event,cls,objs_to_classify);			\
+} while (0)
 
 
 #endif // CONFIG_CKRM
 
 #endif // __KERNEL__
 
-#endif // _LINUX_CKRM_RES_H
+#endif // _LINUX_CKRM_RC_H
+
+
+
 
 
--- a/include/linux/ckrm_res.h	2004-04-26 12:35:35.000000000 -0400
+++ b/include/linux/ckrm_res.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-/* ckrm_res.h - Dummy resource controller for CKRM
- *
- * Copyright (C) Chandra Seetharaman, IBM Corp. 2003
- * 
- * 
- * Provides a dummy resource controller for CKRM
- *
- * Latest version, more details at http://ckrm.sf.net
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-/* Changes
- *
- * 06 Nov 2003
- *        Created.
- */
-
-#ifndef _LINUX_CKRM_RES_H
-#define _LINUX_CKRM_RES_H
-
-#ifdef CONFIG_CKRM_RES_DUMMY
-
-extern int init_ckrm_dummy_res(void);
-
-#else
-
-#define init_ckrm_dummy_res()
-
-#endif
-
-#endif // _LINUX_CKRM_RES_H
--- a/include/linux/ckrm_net.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/linux/ckrm_net.h	2004-04-28 22:57:41.000000000 -0400
@@ -0,0 +1,41 @@
+/* ckrm_rc.h - Header file to be used by Resource controllers of CKRM
+ *
+ * Copyright (C) Vivek Kashyap , IBM Corp. 2004
+ * 
+ * Provides data structures, macros and kernel API of CKRM for 
+ * resource controllers.
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef _LINUX_CKRM_NET_H
+#define _LINUX_CKRM_NET_H
+
+struct ckrm_sock_class;
+
+struct ckrm_net_struct {
+	int 		 ns_type;                    // type of net class
+	struct sock     *ns_sk;         // pointer to socket
+	pid_t            ns_tgid;       // real process id
+	pid_t            ns_pid;        // calling thread's pid
+	int              ns_family;     // IPPROTO_IPV4 || IPPROTO_IPV6
+					// Currently only IPV4 is supported
+	union {
+		__u32   ns_dipv4;       // V4 listener's address
+	} ns_daddr;
+	__u16 		ns_dport;       // listener's port
+	__u16 ns_sport;                 // sender's port
+	atomic_t ns_refcnt;
+	struct ckrm_sock_class 	*core;		
+	struct list_head       ckrm_link;
+};
+
+#define ns_daddrv4     ns_daddr.ns_dipv4
+
+#endif
--- a/include/linux/ckrm_tc.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/linux/ckrm_tc.h	2004-04-28 22:57:41.000000000 -0400
@@ -0,0 +1,18 @@
+#include <linux/ckrm_rc.h>
+
+
+
+#define TASK_CLASS_TYPE_NAME "taskclass"
+
+typedef struct ckrm_task_class {
+	struct ckrm_core_class core;   
+} ckrm_task_class_t;
+
+
+// Index into genmfdesc array, defined in rcfs/dir_modules.c,
+// which has the mfdesc entry that taskclass wants to use
+#define TC_MF_IDX  0
+
+
+extern int ckrm_forced_reclassify_pid(int pid, struct ckrm_task_class *cls);
+
--- a/include/linux/ckrm_tsk.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/linux/ckrm_tsk.h	2004-04-28 22:57:41.000000000 -0400
@@ -0,0 +1,41 @@
+/* ckrm_tsk.h - No. of tasks resource controller for CKRM
+ *
+ * Copyright (C) Chandra Seetharaman, IBM Corp. 2003
+ * 
+ * Provides No. of tasks resource controller for CKRM
+ *
+ * Latest version, more details at http://ckrm.sf.net
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/* Changes
+ *
+ * 31 Mar 2004
+ *    Created.
+ */
+
+#ifndef _LINUX_CKRM_TSK_H
+#define _LINUX_CKRM_TSK_H
+
+#include <linux/ckrm_rc.h>
+
+#ifdef CONFIG_CKRM_RES_NUMTASKS
+
+extern int numtasks_get_ref(void *, int);
+extern int numtasks_get_ref_resid(void *, int, int);
+extern void numtasks_put_ref(void *);
+
+#else
+
+#define numtasks_get_ref(a, b)		1
+#define numtasks_get_ref_resid(a, b, c)		1
+#define numtasks_put_ref(a)
+
+#endif
+
+#endif // _LINUX_CKRM_RES_H
--- a/include/linux/rcfs.h	2004-04-26 12:35:37.000000000 -0400
+++ b/include/linux/rcfs.h	2004-04-28 22:57:41.000000000 -0400
@@ -5,7 +5,6 @@
 #include <linux/fs.h>
 #include <linux/ckrm.h>
 #include <linux/ckrm_rc.h>
-#include <linux/ckrm_res.h>
 #include <linux/ckrm_ce.h>
 
 
@@ -13,39 +12,64 @@
 /* The following declarations cannot be included in any of ckrm*.h files without 
    jumping hoops. Remove later when rearrangements done */
 
-extern ckrm_res_callback_t ckrm_res_ctlrs[CKRM_MAX_RES_CTLRS];
+// Hubertus .. taken out 
+//extern ckrm_res_callback_t ckrm_res_ctlrs[CKRM_MAX_RES_CTLRS];
 
 #define RCFS_MAGIC	0x4feedbac
+#define RCFS_MAGF_NAMELEN 20
+extern int RCFS_IS_MAGIC;
 
+#define rcfs_is_magic(dentry)  ((dentry)->d_fsdata == &RCFS_IS_MAGIC)
 
 typedef struct rcfs_inode_info {
-	/* USEME ckrm_core_class_t *core */
-	void *core;
+	ckrm_core_class_t *core;
+	char *name;
 	struct inode vfs_inode;
 } rcfs_inode_info_t;
 
+#define RCFS_DEFAULT_DIR_MODE	(S_IFDIR | S_IRUGO | S_IXUGO)
+#define RCFS_DEFAULT_FILE_MODE	(S_IFREG | S_IRUSR | S_IWUSR | S_IRGRP |S_IROTH)
 
-inline struct rcfs_inode_info *RCFS_I(struct inode *inode);
 
+struct rcfs_magf {
+	char name[RCFS_MAGF_NAMELEN];
+	int mode;
+	struct inode_operations *i_op;
+	struct file_operations *i_fop;
+};
+
+struct rcfs_mfdesc {
+	struct rcfs_magf *rootmf;     // Root directory and its magic files
+	int              rootmflen;   // length of above array
+	// Can have a different magf describing magic files for non-root entries too
+};
 
-struct inode *rcfs_get_inode(struct super_block *sb, int mode, dev_t dev);
-int rcfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev);
-int rcfs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
-struct dentry * rcfs_create_internal(struct dentry *parent, const char *name, int mfmode, 
-				     int magic);
-void rcfs_make_core(struct dentry *sp, struct ckrm_core_class *core);
+extern struct rcfs_mfdesc *genmfdesc[];
 
+inline struct rcfs_inode_info *RCFS_I(struct inode *inode);
 
-int rcfs_delete_internal(struct dentry *mfdentry);
-int rcfs_clear_magic(struct dentry *parent);
+int rcfs_empty(struct dentry *);
+struct inode *rcfs_get_inode(struct super_block *, int, dev_t);
+int rcfs_mknod(struct inode *, struct dentry *, int, dev_t);
+int _rcfs_mknod(struct inode *, struct dentry *, int , dev_t);
+int rcfs_mkdir(struct inode *, struct dentry *, int);
+ckrm_core_class_t *rcfs_make_core(struct dentry *, struct ckrm_core_class *);
+struct dentry *rcfs_set_magf_byname(char *, void *);
+
+struct dentry * rcfs_create_internal(struct dentry *, struct rcfs_magf *, int);
+int rcfs_delete_internal(struct dentry *);
+int rcfs_create_magic(struct dentry *, struct rcfs_magf *, int);
+int rcfs_clear_magic(struct dentry *);
 
 
 extern struct super_operations rcfs_super_ops;
 extern struct address_space_operations rcfs_aops;
 
 extern struct inode_operations rcfs_dir_inode_operations;
+extern struct inode_operations rcfs_rootdir_inode_operations;
 extern struct inode_operations rcfs_file_inode_operations;
 
+
 extern struct file_operations target_fileops;
 extern struct file_operations shares_fileops;
 extern struct file_operations stats_fileops;
@@ -53,4 +77,22 @@
 extern struct file_operations members_fileops;
 extern struct file_operations rcfs_file_operations;
 
+// Callbacks into rcfs from ckrm 
+
+typedef struct rcfs_functions {
+	int  (* mkroot)(struct rcfs_magf *,int, struct dentry **);
+	int  (* rmroot)(struct dentry *);
+	int  (* register_classtype)(ckrm_classtype_t *);
+	int  (* deregister_classtype)(ckrm_classtype_t *);
+} rcfs_fn_t;
+
+int rcfs_register_classtype(ckrm_classtype_t *);
+int rcfs_deregister_classtype(ckrm_classtype_t *);
+int rcfs_mkroot(struct rcfs_magf *, int , struct dentry **);
+int rcfs_rmroot(struct dentry *);
+
+#define RCFS_ROOT "/rcfs"         // Hubertus .. we should use the mount point instead of hardcoded
+extern struct dentry *rcfs_rootde;
+
+
 #endif /* _LINUX_RCFS_H */ 
