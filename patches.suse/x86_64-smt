diff -u linux/include/asm-x86_64/smp.h-o linux/include/asm-x86_64/smp.h
--- linux/include/asm-x86_64/smp.h-o	2004-04-20 16:18:37.000000000 +0200
+++ linux/include/asm-x86_64/smp.h	2004-04-22 17:45:41.000000000 +0200
@@ -47,7 +47,7 @@
 extern void (*mtrr_hook) (void);
 extern void zap_low_mappings(void);
 void smp_stop_cpu(void);
-extern char cpu_sibling_map[];
+extern cpumask_t cpu_sibling_map[NR_CPUS];
 extern char phys_proc_id[NR_CPUS];
 
 #define SMP_TRAMPOLINE_BASE 0x6000
diff -u linux/include/asm-x86_64/processor.h-o linux/include/asm-x86_64/processor.h
--- linux/include/asm-x86_64/processor.h-o	2004-04-20 16:18:48.000000000 +0200
+++ linux/include/asm-x86_64/processor.h	2004-04-21 19:08:26.000000000 +0200
@@ -461,4 +461,9 @@
 
 #define cache_line_size() (boot_cpu_data.x86_cache_alignment)
 
+#ifdef CONFIG_SCHED_SMT
+#define ARCH_HAS_SCHED_DOMAIN
+#define ARCH_HAS_SCHED_WAKE_IDLE
+#endif
+
 #endif /* __ASM_X86_64_PROCESSOR_H */
diff -u linux/arch/x86_64/kernel/smpboot.c-o linux/arch/x86_64/kernel/smpboot.c
--- linux/arch/x86_64/kernel/smpboot.c-o	2004-04-20 16:18:37.000000000 +0200
+++ linux/arch/x86_64/kernel/smpboot.c	2004-04-22 17:45:24.000000000 +0200
@@ -73,7 +73,7 @@
 /* Set when the idlers are all forked */
 int smp_threads_ready;
 
-char cpu_sibling_map[NR_CPUS] __cacheline_aligned;
+cpumask_t cpu_sibling_map[NR_CPUS] __cacheline_aligned;
 
 /*
  * Trampoline 80x86 program as an array.
@@ -874,31 +874,36 @@
 	}
 
 	/*
-	 * If Hyper-Threading is avaialble, construct cpu_sibling_map[], so
-	 * that we can tell the sibling CPU efficiently.
+	 * Construct cpu_sibling_map[], so that we can tell the
+	 * sibling CPU efficiently.
 	 */
-	if (cpu_has_ht && smp_num_siblings > 1) {
-		for (cpu = 0; cpu < NR_CPUS; cpu++)
-			cpu_sibling_map[cpu] = NO_PROC_ID;
-		
-		for (cpu = 0; cpu < NR_CPUS; cpu++) {
-			int 	i;
-			if (!cpu_isset(cpu, cpu_callout_map))
-				continue;
+	for (cpu = 0; cpu < NR_CPUS; cpu++)
+		cpus_clear(cpu_sibling_map[cpu]);
+
+	for (cpu = 0; cpu < NR_CPUS; cpu++) {
+		int siblings = 0;
+		int i;
+		if (!cpu_isset(cpu, cpu_callout_map))
+			continue;
 
+		if (smp_num_siblings > 1) {
 			for (i = 0; i < NR_CPUS; i++) {
-				if (i == cpu || !cpu_isset(i, cpu_callout_map))
+				if (!cpu_isset(i, cpu_callout_map))
 					continue;
 				if (phys_proc_id[cpu] == phys_proc_id[i]) {
-					cpu_sibling_map[cpu] = i;
-					break;
+					siblings++;
+					cpu_set(i, cpu_sibling_map[cpu]);
 				}
 			}
-			if (cpu_sibling_map[cpu] == (char)NO_PROC_ID) {
-				smp_num_siblings = 1;
-				printk(KERN_WARNING "WARNING: No sibling found for CPU %d.\n", cpu);
-			}
+		} else { 
+			siblings++;
+			cpu_set(cpu, cpu_sibling_map[cpu]);
 		}
+
+		if (siblings != smp_num_siblings)
+			printk(KERN_WARNING 
+	       "WARNING: %d siblings found for CPU%d, should be %d\n", 
+			       siblings, cpu, smp_num_siblings);
 	}
 
 	Dprintk("Boot done.\n");
diff -u /dev/null linux/arch/x86_64/kernel/domain.c
--- /dev/null	2004-02-18 23:32:57.000000000 +0100
+++ linux/arch/x86_64/kernel/domain.c	2004-04-21 19:24:41.000000000 +0200
@@ -0,0 +1,89 @@
+#include <linux/init.h>
+#include <linux/sched.h>
+
+/* Don't do any NUMA setup on Opteron right now. They seem to be 
+   better off with flat scheduling. This is just for SMT. */
+
+#ifdef CONFIG_SCHED_SMT
+
+static struct sched_group sched_group_cpus[NR_CPUS];
+static struct sched_group sched_group_phys[NR_CPUS];
+static DEFINE_PER_CPU(struct sched_domain, cpu_domains);
+static DEFINE_PER_CPU(struct sched_domain, phys_domains);
+__init void arch_init_sched_domains(void)
+{
+	int i;
+	struct sched_group *first = NULL, *last = NULL;
+
+	/* Set up domains */
+	for_each_cpu(i) {
+		struct sched_domain *cpu_domain = &per_cpu(cpu_domains, i);
+		struct sched_domain *phys_domain = &per_cpu(phys_domains, i);
+
+		*cpu_domain = SD_SIBLING_INIT;
+		cpu_domain->span = cpu_sibling_map[i];
+		cpu_domain->parent = phys_domain;
+		cpu_domain->groups = &sched_group_cpus[i];
+
+		*phys_domain = SD_CPU_INIT;
+		phys_domain->span = cpu_possible_map;
+		phys_domain->groups = &sched_group_phys[first_cpu(cpu_domain->span)];
+	}
+
+	/* Set up CPU (sibling) groups */
+	for_each_cpu(i) {
+		struct sched_domain *cpu_domain = &per_cpu(cpu_domains, i);
+		int j;
+		first = last = NULL;
+
+		if (i != first_cpu(cpu_domain->span))
+			continue;
+
+		for_each_cpu_mask(j, cpu_domain->span) {
+			struct sched_group *cpu = &sched_group_cpus[j];
+
+			cpus_clear(cpu->cpumask);
+			cpu_set(j, cpu->cpumask);
+			cpu->cpu_power = SCHED_LOAD_SCALE;
+
+			if (!first)
+				first = cpu;
+			if (last)
+				last->next = cpu;
+			last = cpu;
+		}
+		last->next = first;
+	}
+
+	first = last = NULL;
+	/* Set up physical groups */
+	for_each_cpu(i) {
+		struct sched_domain *cpu_domain = &per_cpu(cpu_domains, i);
+		struct sched_group *cpu = &sched_group_phys[i];
+
+		if (i != first_cpu(cpu_domain->span))
+			continue;
+
+		cpu->cpumask = cpu_domain->span;
+		/*
+		 * Make each extra sibling increase power by 10% of
+		 * the basic CPU. This is very arbitrary.
+		 */
+		cpu->cpu_power = SCHED_LOAD_SCALE + SCHED_LOAD_SCALE*(cpus_weight(cpu->cpumask)-1) / 10;
+
+		if (!first)
+			first = cpu;
+		if (last)
+			last->next = cpu;
+		last = cpu;
+	}
+	last->next = first;
+
+	mb();
+	for_each_cpu(i) {
+		struct sched_domain *cpu_domain = &per_cpu(cpu_domains, i);
+		cpu_attach_domain(cpu_domain, i);
+	}
+}
+
+#endif
diff -u linux/arch/x86_64/kernel/Makefile-o linux/arch/x86_64/kernel/Makefile
--- linux/arch/x86_64/kernel/Makefile-o	2004-04-06 13:12:05.000000000 +0200
+++ linux/arch/x86_64/kernel/Makefile	2004-04-21 19:06:33.000000000 +0200
@@ -25,6 +25,7 @@
 obj-$(CONFIG_GART_IOMMU)	+= pci-gart.o aperture.o
 obj-$(CONFIG_DUMMY_IOMMU)	+= pci-nommu.o pci-dma.o
 obj-$(CONFIG_SWIOTLB)		+= swiotlb.o
+obj-$(CONFIG_SCHED_SMT)		+= domain.o
 
 obj-$(CONFIG_MODULES)		+= module.o
 
diff -u linux/arch/x86_64/Kconfig-o linux/arch/x86_64/Kconfig
--- linux/arch/x86_64/Kconfig-o	2004-04-20 16:18:48.000000000 +0200
+++ linux/arch/x86_64/Kconfig	2004-04-21 19:06:04.000000000 +0200
@@ -239,6 +239,16 @@
 	  Say Y here if you are feeling brave and building a kernel for a 
 	  desktop, embedded or real-time system.  Say N if you are unsure. 
 
+config SCHED_SMT
+	bool "SMT (Hyperthreading) scheduler support"
+	depends on SMP
+	default off
+	help
+	  SMT scheduler support improves the CPU scheduler's decision making
+	  when dealing with Intel Pentium 4 chips with HyperThreading at a
+	  cost of slightly increased overhead in some places. If unsure say
+	  N here.
+
 # someone write a better help text please.
 config K8_NUMA
        bool "K8 NUMA support"
