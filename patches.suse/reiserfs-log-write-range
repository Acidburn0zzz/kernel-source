filemap_fdatawrite_range provides a nice way to reiserfs to trigger bulk
log block writeback, even across multiple small transactions.  

This patch optimizes the log writeback code to use it.

Index: linux.t2/fs/reiserfs/journal.c
===================================================================
--- linux.t2.orig/fs/reiserfs/journal.c	2004-05-03 13:34:08.000000000 -0400
+++ linux.t2/fs/reiserfs/journal.c	2004-05-03 13:38:22.000000000 -0400
@@ -838,7 +838,20 @@
     unsigned long trans_id = jl->j_trans_id;
     unsigned long other_trans_id;
     unsigned long first_trans_id;
+    loff_t logstart = SB_ONDISK_JOURNAL_1st_BLOCK(s);
+    loff_t logend = logstart + SB_ONDISK_JOURNAL_SIZE(s);
 
+    logstart *= s->s_blocksize;
+    logend *= s->s_blocksize;
+
+    /*
+     * lets try to get as much log io down the pipe as we can,
+     * thanks to filemap_fdatawrite_range, we can send down
+     * all the dirty log blocks at once.  This won't
+     * include the commit blocks, but that's ok.
+     */
+    filemap_fdatawrite_range(journal->j_dev_bd->bd_inode->i_mapping,
+		       logstart, logend);
 find_first:
     /* 
      * first we walk backwards to find the oldest uncommitted transation
@@ -3096,15 +3109,6 @@
       flush_commit_list(p_s_sb, jl, 1);
   }
   unlock_kernel();
-  /*
-   * this is a little racey, but there's no harm in missing
-   * the filemap_fdata_write
-   */
-  if (!atomic_read(&journal->j_async_throttle) && !reiserfs_is_journal_aborted (journal)) {
-      atomic_inc(&journal->j_async_throttle);
-      filemap_fdatawrite(p_s_sb->s_bdev->bd_inode->i_mapping);
-      atomic_dec(&journal->j_async_throttle);
-  }
 }
 
 /*
Index: linux.t2/include/linux/fs.h
===================================================================
--- linux.t2.orig/include/linux/fs.h	2004-05-03 13:34:08.000000000 -0400
+++ linux.t2/include/linux/fs.h	2004-05-03 13:34:30.000000000 -0400
@@ -1266,6 +1266,7 @@
 extern void invalidate_inode_pages2(struct address_space *mapping);
 extern void write_inode_now(struct inode *, int);
 extern int filemap_fdatawrite(struct address_space *);
+extern int filemap_fdatawrite_range(struct address_space *, loff_t, loff_t);
 extern int filemap_flush(struct address_space *);
 extern int filemap_fdatawait(struct address_space *);
 extern int filemap_write_and_wait(struct address_space *mapping);
