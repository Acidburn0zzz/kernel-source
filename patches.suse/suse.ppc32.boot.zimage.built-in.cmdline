Date: Sun, 30 Nov 2003 20:39:52 +0100
From: olh@suse.de
Subject: Put a built-in cmdline into zImage, overrides stuff passed from OF

Index: linux-2.6.8/arch/ppc/boot/common/bootinfo.c
===================================================================
--- linux-2.6.8.orig/arch/ppc/boot/common/bootinfo.c
+++ linux-2.6.8/arch/ppc/boot/common/bootinfo.c
@@ -10,8 +10,9 @@
  */
 
 #include <linux/types.h>
 #include <linux/string.h>
+#include <asm/setup.h>
 #include <asm/bootinfo.h>
 
 #include "nonstdio.h"
 
Index: linux-2.6.8/arch/ppc/boot/include/of1275.h
===================================================================
--- linux-2.6.8.orig/arch/ppc/boot/include/of1275.h
+++ linux-2.6.8/arch/ppc/boot/include/of1275.h
@@ -15,8 +15,9 @@ typedef int (*prom_entry)(void *);
 
 #define OF_INVALID_HANDLE	((prom_handle)-1UL)
 
 extern prom_entry of_prom_entry;
+extern phandle chosen_handle;
 
 /* function declarations */
 
 void *	claim(unsigned int virt, unsigned int size, unsigned int align);
@@ -24,10 +25,11 @@ int	map(unsigned int phys, unsigned int 
 void	enter(void);
 void	exit(void);
 phandle	finddevice(const char *name);
 int	getprop(phandle node, const char *name, void *buf, int buflen);
+int	setprop(phandle node, const char *name, void *buf, int buflen);
 void	ofinit(prom_entry entry);
-int	ofstdio(ihandle *stdin, ihandle *stdout, ihandle *stderr);
+int	ofstdio(ihandle *stdin, ihandle *stdout, ihandle *stderr, phandle *chosen_handle);
 int	read(ihandle instance, void *buf, int buflen);
 void	release(void *virt, unsigned int size);
 int	write(ihandle instance, void *buf, int buflen);
 
Index: linux-2.6.8/arch/ppc/boot/ld.script
===================================================================
--- linux-2.6.8.orig/arch/ppc/boot/ld.script
+++ linux-2.6.8/arch/ppc/boot/ld.script
@@ -30,8 +30,11 @@ SECTIONS
     *(.fixup)
     __relocate_start = .;
     *(.relocate_code)
     __relocate_end = .;
+    
+    *(.kernel:cmdline)
+
   }
   _etext = .;
   PROVIDE (etext = .);
 
Index: linux-2.6.8/arch/ppc/boot/Makefile
===================================================================
--- linux-2.6.8.orig/arch/ppc/boot/Makefile
+++ linux-2.6.8/arch/ppc/boot/Makefile
@@ -22,9 +22,9 @@ subdir-$(CONFIG_PPC_OF)		+= of1275
 
 # for cleaning
 subdir-				+= simple openfirmware
 
-hostprogs-y := $(addprefix utils/, addnote mknote hack-coff mkprep mkbugboot mktree)
+hostprogs-y := $(addprefix utils/, addnote mknote hack-coff mkprep mkbugboot mktree mkzimage_cmdline)
 
 .PHONY: $(BOOT_TARGETS) $(bootdir-y)
 
 $(BOOT_TARGETS): $(bootdir-y)
Index: linux-2.6.8/arch/ppc/boot/of1275/Makefile
===================================================================
--- linux-2.6.8.orig/arch/ppc/boot/of1275/Makefile
+++ linux-2.6.8/arch/ppc/boot/of1275/Makefile
@@ -2,5 +2,5 @@
 # Makefile of1275 stuff
 #
 
 lib-y := claim.o enter.o exit.o finddevice.o getprop.o ofinit.o	\
-	 ofstdio.o read.o release.o write.o map.o
+	 ofstdio.o read.o release.o write.o map.o setprop.o
Index: linux-2.6.8/arch/ppc/boot/of1275/ofstdio.c
===================================================================
--- linux-2.6.8.orig/arch/ppc/boot/of1275/ofstdio.c
+++ linux-2.6.8/arch/ppc/boot/of1275/ofstdio.c
@@ -10,9 +10,9 @@
 
 #include "of1275.h"
 
 int
-ofstdio(ihandle *stdin, ihandle *stdout, ihandle *stderr)
+ofstdio(ihandle *stdin, ihandle *stdout, ihandle *stderr, phandle *chosen_handle)
 {
     ihandle in, out;
     phandle chosen;
 
@@ -25,8 +25,9 @@ ofstdio(ihandle *stdin, ihandle *stdout,
 
     *stdin  = in;
     *stdout = out;
     *stderr = out;
+    *chosen_handle = chosen;
     return 0;
 err:
     return -1;
 }
Index: linux-2.6.8/arch/ppc/boot/of1275/setprop.c
===================================================================
--- /dev/null
+++ linux-2.6.8/arch/ppc/boot/of1275/setprop.c
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) Paul Mackerras 1997.
+ * Copyright (C) Leigh Brown 2002.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include "of1275.h"
+
+int
+setprop(phandle node, const char *name, void *buf, int buflen)
+{
+    struct prom_args {
+	char *service;
+	int nargs;
+	int nret;
+	phandle node;
+	const char *name;
+	void *buf;
+	int buflen;
+	int size;
+    } args;
+
+    args.service = "setprop";
+    args.nargs = 4;
+    args.nret = 1;
+    args.node = node;
+    args.name = name;
+    args.buf = buf;
+    args.buflen = buflen;
+    args.size = -1;
+    (*of_prom_entry)(&args);
+    return args.size;
+}
Index: linux-2.6.8/arch/ppc/boot/openfirmware/common.c
===================================================================
--- linux-2.6.8.orig/arch/ppc/boot/openfirmware/common.c
+++ linux-2.6.8/arch/ppc/boot/openfirmware/common.c
@@ -10,11 +10,26 @@
 #include "nonstdio.h"
 #include "of1275.h"
 #include <linux/string.h>
 #include <linux/zlib.h>
+#include <asm/setup.h>
 #include <asm/bootinfo.h>
 #include <asm/page.h>
 
+#ifndef CONFIG_CMDLINE
+#define CONFIG_CMDLINE ""
+#define CONFIG_CMDLINE_PREFER '0'
+#else
+#define CONFIG_CMDLINE_PREFER '1'
+#endif
+
+struct _builtin_cmd_line  __attribute__ ((__section__ (".kernel:cmdline"))) _builtin_cmd_line = {
+	.prefer = CONFIG_CMDLINE_PREFER,
+	.cmdling_start_flag = cmdline_start_string,
+	.string = CONFIG_CMDLINE,
+	.cmdline_end_flag = cmdline_end_string,
+};
+
 /* Information from the linker */
 extern char __sysmap_begin, __sysmap_end;
 
 extern int strcmp(const char *s1, const char *s2);
@@ -146,8 +161,14 @@ void make_bi_recs(unsigned long addr, ch
 	rec->data[1] = 1;
 	rec->size = sizeof(struct bi_record) + 2 * sizeof(unsigned long);
 	rec = (struct bi_record *)((unsigned long)rec + rec->size);
 
+	if ( _builtin_cmd_line.prefer && _builtin_cmd_line.prefer != '0' ) {
+		int l = strlen (_builtin_cmd_line.string)+1;
+		printf("copy built-in cmdline(%d) %s\n\r",l,_builtin_cmd_line.string);
+		l = (int)setprop( chosen_handle, "bootargs", _builtin_cmd_line.string, l);
+		printf ("setprop bootargs: %d\n\r",l);
+	}
 	if (sysmap_size) {
 		rec->tag = BI_SYSMAP;
 		rec->data[0] = (unsigned long)(&__sysmap_begin);
 		rec->data[1] = sysmap_size;
Index: linux-2.6.8/arch/ppc/boot/openfirmware/start.c
===================================================================
--- linux-2.6.8.orig/arch/ppc/boot/openfirmware/start.c
+++ linux-2.6.8/arch/ppc/boot/openfirmware/start.c
@@ -14,16 +14,17 @@ extern void boot(int a1, int a2, void *p
 
 phandle stdin;
 phandle stdout;
 phandle stderr;
+phandle chosen_handle;
 
 void printk(char *fmt, ...);
 
 void
 start(int a1, int a2, void *promptr)
 {
     ofinit(promptr);
-    if (ofstdio(&stdin, &stdout, &stderr))
+    if (ofstdio(&stdin, &stdout, &stderr, &chosen_handle))
 	exit();
 
     boot(a1, a2, promptr);
     for (;;)
Index: linux-2.6.8/arch/ppc/boot/simple/misc.c
===================================================================
--- linux-2.6.8.orig/arch/ppc/boot/simple/misc.c
+++ linux-2.6.8/arch/ppc/boot/simple/misc.c
@@ -21,8 +21,9 @@
 #include <linux/string.h>
 
 #include <asm/page.h>
 #include <asm/mmu.h>
+#include <asm/setup.h>
 #include <asm/bootinfo.h>
 #ifdef CONFIG_44x
 #include <asm/ibm4xx.h>
 #endif
@@ -30,14 +31,22 @@
 
 #include "nonstdio.h"
 
 /* Default cmdline */
-#ifdef CONFIG_CMDLINE
-#define CMDLINE CONFIG_CMDLINE
+#ifndef CONFIG_CMDLINE
+#define CONFIG_CMDLINE ""
+#define CONFIG_CMDLINE_PREFER '0'
 #else
-#define CMDLINE ""
+#define CONFIG_CMDLINE_PREFER '1'
 #endif
 
+struct _builtin_cmd_line  __attribute__ ((__section__ (".kernel:cmdline"))) _builtin_cmd_line = {
+	.prefer = CONFIG_CMDLINE_PREFER,
+	.cmdling_start_flag = cmdline_start_string,
+	.string = CONFIG_CMDLINE,
+	.cmdline_end_flag = cmdline_end_string,
+};
+
 /* Keyboard (and VGA console)? */
 #ifdef CONFIG_VGA_CONSOLE
 #define HAS_KEYB 1
 #else
@@ -55,11 +64,9 @@
 
 char *avail_ram;
 char *end_avail;
 char *zimage_start;
-char cmd_preset[] = CMDLINE;
-char cmd_buf[256];
-char *cmd_line = cmd_buf;
+char *cmd_line = _builtin_cmd_line.string;
 int keyb_present = HAS_KEYB;
 int zimage_size;
 
 unsigned long com_port;
@@ -167,23 +174,12 @@ decompress_kernel(unsigned long load_add
 	puthex((unsigned long)end_avail); puts("\n");
 
 	if (keyb_present)
 		CRT_tstc();  /* Forces keyboard to be initialized */
-#ifdef CONFIG_GEMINI
-	/*
-	 * If cmd_line is empty and cmd_preset is not, copy cmd_preset
-	 * to cmd_line.  This way we can override cmd_preset with the
-	 * command line from Smon.
-	 */
-
-	if ( (cmd_line[0] == '\0') && (cmd_preset[0] != '\0'))
-		memcpy (cmd_line, cmd_preset, sizeof(cmd_preset));
-#endif
 
 	/* Display standard Linux/PPC boot prompt for kernel args */
 	puts("\nLinux/PPC load: ");
 	cp = cmd_line;
-	memcpy (cmd_line, cmd_preset, sizeof(cmd_preset));
 	while ( *cp ) putc(*cp++);
 
 #ifdef INTERACTIVE_CONSOLE
 	/*
Index: linux-2.6.8/arch/ppc/boot/utils/mkzimage_cmdline.c
===================================================================
--- /dev/null
+++ linux-2.6.8/arch/ppc/boot/utils/mkzimage_cmdline.c
@@ -0,0 +1,182 @@
+/*
+ * a little tool to modify the cmdline inside a zImage
+ * Olaf Hering <olh@suse.de>  Copyright (C) 2003, 2004
+ */
+
+/*
+	2003-10-02, version 1 
+	2003-11-15, version 2: fix short reads if the string is at the end of the file
+	2004-08-07, version 3: use mmap
+ */
+/*
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+
+#define MY_VERSION 3
+
+static int activate;
+static int clear;
+static int set;
+static char *string;
+static char *filename;
+
+static const char cmdline_start[] = "cmd_line_start";
+static const char cmdline_end[] = "cmd_line_end";
+
+static void my_version(void)
+{
+	printf("version: %d\n", MY_VERSION);
+	printf("(C) SuSE Linux AG, Nuernberg, Germany, 2003, 2004\n");
+	return;
+}
+
+static void my_rtfm(const char *app)
+{
+	printf("modify the built-in cmdline of a CHRP boot image\n");
+	printf("%s filename\n", app);
+	printf("work with zImage named 'filename'\n");
+	printf(" [-h] display this help\n");
+	printf(" [-v] display version\n");
+	printf(" [-a 0|1] disable/enable built-in cmdline\n");
+	printf("          overrides whatever is passed from OpenFirmware\n");
+	printf(" [-s STRING] store STRING in the boot image\n");
+	printf(" [-c] clear previous content before update\n");
+	printf(" no option will show the current settings in 'filename'\n");
+	return;
+}
+
+int main(int argc, char **argv)
+{
+	struct stat sb;
+	int fd, found;
+	unsigned char *p, *s, *e, *tmp, *active;
+
+	if (argc < 2) {
+		my_rtfm(argv[0]);
+		exit(1);
+	}
+
+	while (1) {
+		int i;
+		i = getopt(argc, argv, "a:hcvs:");
+		if (i == -1)
+			break;
+		switch (i) {
+		case 'a':
+			if (*optarg == '0')
+				activate = -1;
+			else
+				activate = 1;
+			break;
+		case 'c':
+			clear = 1;
+			break;
+		case 'h':
+			my_rtfm(argv[0]);
+			exit(0);
+		case 's':
+			string = strdup(optarg);
+			if (!string) {
+				fprintf(stderr, "set: no mem\n");
+				exit(1);
+			}
+			set = 1;
+			break;
+		case 'v':
+			my_version();
+			exit(0);
+		default:
+			printf("unknown option\n");
+			my_rtfm(argv[0]);
+			exit(1);
+		}
+	}
+	if (argc <= optind) {
+		fprintf(stderr, "filename required\n");
+		exit(1);
+	}
+	filename = strdup(argv[optind]);
+	if (!filename) {
+		fprintf(stderr, "no mem\n");
+		exit(1);
+	}
+
+	fd = open(filename, (activate || clear || set) ? O_RDWR : O_RDONLY);
+	if (fd == -1)
+		goto error;
+	found = stat(filename, &sb);
+	if (found < 0)
+		goto error;
+	if (!S_ISREG(sb.st_mode)) {
+		fprintf(stderr, "%s is not a file\n", filename);
+		exit(1);
+	}
+
+	p = mmap(NULL, sb.st_size,
+		 ((activate || clear || set) ?
+		  PROT_WRITE : 0) | PROT_READ, MAP_SHARED, fd, 0);
+	if (p == MAP_FAILED)
+		goto error;
+	s = p;
+	e = p + sb.st_size - sizeof(cmdline_start) - sizeof(cmdline_end);
+	found = 0;
+	while (s < e) {
+		if (memcmp(++s, cmdline_start, sizeof(cmdline_start) - 1) != 0)
+			continue;
+		found = 1;
+		break;
+	}
+	if (!found)
+		goto no_start;
+	found = 0;
+
+	active = s - 1;
+	tmp = s = s + sizeof(cmdline_start) - 1;
+	e = p + sb.st_size - sizeof(cmdline_end);
+	while (tmp < e) {
+		if (memcmp(++tmp, cmdline_end, sizeof(cmdline_end)) != 0)
+			continue;
+		found = 1;
+		break;
+	}
+	if (!found)
+		goto no_end;
+
+	if (activate || clear || set) {
+		if (activate)
+			*active = activate > 0 ? '1' : '0';
+		if (clear)
+			memset(s, 0x0, tmp - s);
+		if (set)
+			snprintf(s, tmp - s, "%s", string);
+	} else {
+		fprintf(stdout, "cmd_line size:%d\n", tmp - s);
+		fprintf(stdout, "cmd_line: %s\n", s);
+		fprintf(stdout, "active: %c\n", *active);
+	}
+
+	munmap(p, sb.st_size);
+	close(fd);
+	return 0;
+
+      error:
+	perror(filename);
+	return 1;
+      no_start:
+	fprintf(stderr, "%s: %s not found.\n", filename, cmdline_start);
+	return 1;
+      no_end:
+	fprintf(stderr, "%s: %s not found.\n", filename, cmdline_end);
+	return 1;
+}
Index: linux-2.6.8/arch/ppc64/boot/main.c
===================================================================
--- linux-2.6.8.orig/arch/ppc64/boot/main.c
+++ linux-2.6.8/arch/ppc64/boot/main.c
@@ -13,12 +13,14 @@
 #include <linux/elf.h>
 #include <linux/string.h>
 #include <asm/processor.h>
 #include <asm/page.h>
+#include <asm/setup.h>
 #include <asm/bootinfo.h>
 
 extern void *finddevice(const char *);
 extern int getprop(void *, const char *, void *, int);
+extern int setprop(void *, const char *, void *, int);
 extern void printk(char *fmt, ...);
 extern void printf(const char *fmt, ...);
 extern int sprintf(char *buf, const char *fmt, ...);
 void gunzip(void *, int, unsigned char *, int *);
@@ -79,8 +81,30 @@ void *chosen_handle;
 void *stdin;
 void *stdout;
 void *stderr;
 
+#ifndef CONFIG_CMDLINE
+#define CONFIG_CMDLINE ""
+#define CONFIG_CMDLINE_PREFER '0'
+#else
+#define CONFIG_CMDLINE_PREFER '1'
+#endif
+#define cmdline_start_string   "cmd_line_start"
+#define cmdline_end_string     "cmd_line_end"
+struct _builtin_cmd_line {
+	unsigned char prefer;
+	unsigned char cmdling_start_flag[sizeof(cmdline_start_string)-1]; /* without trailing zero */
+	unsigned char string[COMMAND_LINE_SIZE];
+	unsigned char cmdline_end_flag[sizeof(cmdline_end_string)]; /* with trailing zero */
+} __attribute__ ((__packed__));
+
+struct _builtin_cmd_line  __attribute__ ((__section__ (".kernel:cmdline"))) _builtin_cmd_line = {
+	.prefer = CONFIG_CMDLINE_PREFER,
+	.cmdling_start_flag = cmdline_start_string,
+	.string = CONFIG_CMDLINE,
+	.cmdline_end_flag = cmdline_end_string,
+};
+
 
 void
 start(unsigned long a1, unsigned long a2, void *promptr)
 {
@@ -241,8 +265,15 @@ make_bi_recs(unsigned long addr)
 		rec->data[0] = initrd.addr;
 		rec->data[1] = initrd.size;
 	}
 
+	if ( _builtin_cmd_line.prefer && _builtin_cmd_line.prefer != '0' ) {
+		int l = strlen (_builtin_cmd_line.string)+1;
+		printf("copy built-in cmdline(%d) %s\n\r",l,_builtin_cmd_line.string);
+		l = (int)setprop( chosen_handle, "bootargs", _builtin_cmd_line.string, l);
+		printf ("setprop bootargs: %d\n\r",l);
+	}
+
 	if ( sysmap.size > 0 ) {
 		rec = bi_rec_alloc(rec, 2);
 		rec->tag = BI_SYSMAP;
 		rec->data[0] = (unsigned long)sysmap.addr;
Index: linux-2.6.8/arch/ppc64/boot/mkzimage_cmdline.c
===================================================================
--- /dev/null
+++ linux-2.6.8/arch/ppc64/boot/mkzimage_cmdline.c
@@ -0,0 +1,182 @@
+/*
+ * a little tool to modify the cmdline inside a zImage
+ * Olaf Hering <olh@suse.de>  Copyright (C) 2003, 2004
+ */
+
+/*
+	2003-10-02, version 1 
+	2003-11-15, version 2: fix short reads if the string is at the end of the file
+	2004-08-07, version 3: use mmap
+ */
+/*
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+
+#define MY_VERSION 3
+
+static int activate;
+static int clear;
+static int set;
+static char *string;
+static char *filename;
+
+static const char cmdline_start[] = "cmd_line_start";
+static const char cmdline_end[] = "cmd_line_end";
+
+static void my_version(void)
+{
+	printf("version: %d\n", MY_VERSION);
+	printf("(C) SuSE Linux AG, Nuernberg, Germany, 2003, 2004\n");
+	return;
+}
+
+static void my_rtfm(const char *app)
+{
+	printf("modify the built-in cmdline of a CHRP boot image\n");
+	printf("%s filename\n", app);
+	printf("work with zImage named 'filename'\n");
+	printf(" [-h] display this help\n");
+	printf(" [-v] display version\n");
+	printf(" [-a 0|1] disable/enable built-in cmdline\n");
+	printf("          overrides whatever is passed from OpenFirmware\n");
+	printf(" [-s STRING] store STRING in the boot image\n");
+	printf(" [-c] clear previous content before update\n");
+	printf(" no option will show the current settings in 'filename'\n");
+	return;
+}
+
+int main(int argc, char **argv)
+{
+	struct stat sb;
+	int fd, found;
+	unsigned char *p, *s, *e, *tmp, *active;
+
+	if (argc < 2) {
+		my_rtfm(argv[0]);
+		exit(1);
+	}
+
+	while (1) {
+		int i;
+		i = getopt(argc, argv, "a:hcvs:");
+		if (i == -1)
+			break;
+		switch (i) {
+		case 'a':
+			if (*optarg == '0')
+				activate = -1;
+			else
+				activate = 1;
+			break;
+		case 'c':
+			clear = 1;
+			break;
+		case 'h':
+			my_rtfm(argv[0]);
+			exit(0);
+		case 's':
+			string = strdup(optarg);
+			if (!string) {
+				fprintf(stderr, "set: no mem\n");
+				exit(1);
+			}
+			set = 1;
+			break;
+		case 'v':
+			my_version();
+			exit(0);
+		default:
+			printf("unknown option\n");
+			my_rtfm(argv[0]);
+			exit(1);
+		}
+	}
+	if (argc <= optind) {
+		fprintf(stderr, "filename required\n");
+		exit(1);
+	}
+	filename = strdup(argv[optind]);
+	if (!filename) {
+		fprintf(stderr, "no mem\n");
+		exit(1);
+	}
+
+	fd = open(filename, (activate || clear || set) ? O_RDWR : O_RDONLY);
+	if (fd == -1)
+		goto error;
+	found = stat(filename, &sb);
+	if (found < 0)
+		goto error;
+	if (!S_ISREG(sb.st_mode)) {
+		fprintf(stderr, "%s is not a file\n", filename);
+		exit(1);
+	}
+
+	p = mmap(NULL, sb.st_size,
+		 ((activate || clear || set) ?
+		  PROT_WRITE : 0) | PROT_READ, MAP_SHARED, fd, 0);
+	if (p == MAP_FAILED)
+		goto error;
+	s = p;
+	e = p + sb.st_size - sizeof(cmdline_start) - sizeof(cmdline_end);
+	found = 0;
+	while (s < e) {
+		if (memcmp(++s, cmdline_start, sizeof(cmdline_start) - 1) != 0)
+			continue;
+		found = 1;
+		break;
+	}
+	if (!found)
+		goto no_start;
+	found = 0;
+
+	active = s - 1;
+	tmp = s = s + sizeof(cmdline_start) - 1;
+	e = p + sb.st_size - sizeof(cmdline_end);
+	while (tmp < e) {
+		if (memcmp(++tmp, cmdline_end, sizeof(cmdline_end)) != 0)
+			continue;
+		found = 1;
+		break;
+	}
+	if (!found)
+		goto no_end;
+
+	if (activate || clear || set) {
+		if (activate)
+			*active = activate > 0 ? '1' : '0';
+		if (clear)
+			memset(s, 0x0, tmp - s);
+		if (set)
+			snprintf(s, tmp - s, "%s", string);
+	} else {
+		fprintf(stdout, "cmd_line size:%d\n", tmp - s);
+		fprintf(stdout, "cmd_line: %s\n", s);
+		fprintf(stdout, "active: %c\n", *active);
+	}
+
+	munmap(p, sb.st_size);
+	close(fd);
+	return 0;
+
+      error:
+	perror(filename);
+	return 1;
+      no_start:
+	fprintf(stderr, "%s: %s not found.\n", filename, cmdline_start);
+	return 1;
+      no_end:
+	fprintf(stderr, "%s: %s not found.\n", filename, cmdline_end);
+	return 1;
+}
Index: linux-2.6.8/arch/ppc64/boot/prom.c
===================================================================
--- linux-2.6.8.orig/arch/ppc64/boot/prom.c
+++ linux-2.6.8/arch/ppc64/boot/prom.c
@@ -20,8 +20,9 @@ void *stderr;
 
 void exit(void);
 void *finddevice(const char *name);
 int getprop(void *phandle, const char *name, void *buf, int buflen);
+int setprop(void *phandle, const char *name, void *buf, int buflen);
 void chrpboot(int a1, int a2, void *prom);	/* in main.c */
 
 void printk(char *fmt, ...);
 
@@ -169,8 +170,34 @@ getprop(void *phandle, const char *name,
 	return args.size;
 }
 
 int
+setprop(void *node, const char *name, void *buf, int buflen)
+{
+    struct prom_args {
+	char *service;
+	int nargs;
+	int nret;
+	void *node;
+	const char *name;
+	void *buf;
+	int buflen;
+	int size;
+    } args;
+
+    args.service = "setprop";
+    args.nargs = 4;
+    args.nret = 1;
+    args.node = node;
+    args.name = name;
+    args.buf = buf;
+    args.buflen = buflen;
+    args.size = -1;
+    (*prom)(&args);
+    return args.size;
+}
+
+int
 putc(int c, void *f)
 {
 	char ch = c;
 
Index: linux-2.6.8/arch/ppc64/boot/zImage.lds
===================================================================
--- linux-2.6.8.orig/arch/ppc64/boot/zImage.lds
+++ linux-2.6.8/arch/ppc64/boot/zImage.lds
@@ -31,8 +31,9 @@ SECTIONS
   {
     *(.text)
     *(.fixup)
     *(.got1)
+    *(.kernel:cmdline)
   }
   . = ALIGN(4096);
   _etext = .;
   PROVIDE (etext = .);
Index: linux-2.6.8/include/asm-ppc/bootinfo.h
===================================================================
--- linux-2.6.8.orig/include/asm-ppc/bootinfo.h
+++ linux-2.6.8/include/asm-ppc/bootinfo.h
@@ -15,8 +15,17 @@
 #if defined(CONFIG_APUS) && !defined(__BOOTER__)
 #include <asm-m68k/bootinfo.h>
 #else
 
+#define cmdline_start_string   "cmd_line_start"
+#define cmdline_end_string     "cmd_line_end"
+struct _builtin_cmd_line {
+	unsigned char prefer;
+	unsigned char cmdling_start_flag[sizeof(cmdline_start_string)-1]; /* without trailing zero */
+	unsigned char string[COMMAND_LINE_SIZE];
+	unsigned char cmdline_end_flag[sizeof(cmdline_end_string)]; /* with trailing zero */
+} __attribute__ ((__packed__));
+
 struct bi_record {
 	unsigned long tag;		/* tag ID */
 	unsigned long size;		/* size of record (in bytes) */
 	unsigned long data[0];		/* data */
