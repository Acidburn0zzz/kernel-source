flush the workqueue in __put_ioctx so we know for sure there are 
no pending jobs on there when the ctx is freed

drop an extra printk from the aio read ahead code

Index: linux.t/fs/aio.c
===================================================================
--- linux.t.orig/fs/aio.c	2004-04-26 16:49:02.000000000 -0400
+++ linux.t/fs/aio.c	2004-04-26 20:32:59.599767221 -0400
@@ -372,6 +372,8 @@ void fastcall __put_ioctx(struct kioctx 
 	if (unlikely(ctx->reqs_active))
 		BUG();
 
+	cancel_delayed_work(&ctx->wq);
+	flush_workqueue(aio_wq);
 	aio_free_ring(ctx);
 	mmdrop(ctx->mm);
 	ctx->mm = NULL;
@@ -1199,11 +1201,6 @@ static void io_destroy(struct kioctx *io
 
 	aio_cancel_all(ioctx);
 	wait_for_all_aios(ioctx);
-	/*
-	 * this is an overkill, but ensures we don't leave
-	 * the ctx on the aio_wq
-	 */
-	flush_workqueue(aio_wq);
 	put_ioctx(ioctx);	/* once for the lookup */
 }
 
Index: linux.t/mm/filemap.c
===================================================================
--- linux.t.orig/mm/filemap.c	2004-04-26 16:49:14.000000000 -0400
+++ linux.t/mm/filemap.c	2004-04-26 16:49:14.000000000 -0400
@@ -695,7 +695,6 @@ void do_generic_mapping_read(struct addr
 				index + i);
 				if (bdi_read_congested(
 					mapping->backing_dev_info)) {
-					printk("AIO readahead congestion\n");
 					break;
 				}
 			}
