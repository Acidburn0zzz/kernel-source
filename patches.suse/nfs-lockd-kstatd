From: Olaf Kirch <okir@suse.de>
Subject: [NFS] Add in-kernel statd

This patch adds an in-kernel statd implementation.

Index: linux-2.6.12/fs/lockd/host.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/host.c
+++ linux-2.6.12/fs/lockd/host.c
@@ -31,6 +31,14 @@ static unsigned long		next_gc;
 static int			nrhosts;
 static DECLARE_MUTEX(nlm_host_sema);
 
+/*
+ * Function pointers - will reference either the
+ * "standard" statd functions that do upcalls to user land,
+ * or the kernel statd functions.
+ */
+int				(*nsm_monitor)(struct nlm_host *);
+int				(*nsm_unmonitor)(struct nlm_host *);
+
 
 static void			nlm_gc_hosts(void);
 static struct nsm_handle *	__nsm_find(const struct sockaddr_in *, const char *, int);
Index: linux-2.6.12/fs/lockd/mon.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/mon.c
+++ linux-2.6.12/fs/lockd/mon.c
@@ -3,6 +3,10 @@
  *
  * The kernel statd client.
  *
+ * When using the kernel statd service, none of the
+ * stuff inside this file is used.
+ * Instead look at statd.c
+ *
  * Copyright (C) 1996, Olaf Kirch <okir@monad.swb.de>
  */
 
@@ -18,6 +22,8 @@
 #define NLMDBG_FACILITY		NLMDBG_MONITOR
 
 static struct rpc_clnt *	nsm_create(void);
+static int			__nsm_monitor(struct nlm_host *);
+static int			__nsm_unmonitor(struct nlm_host *);
 
 static struct rpc_program	nsm_program;
 
@@ -28,6 +34,17 @@ static struct rpc_program	nsm_program;
 u32				nsm_local_state;
 
 /*
+ * Initialize lockd for RPC statd upcalls
+ */
+int
+nsm_statd_upcalls_init()
+{
+	nsm_monitor = __nsm_monitor;
+	nsm_unmonitor = __nsm_unmonitor;
+	return 0;
+}
+
+/*
  * Common procedure for SM_MON/SM_UNMON calls
  */
 static int
@@ -64,7 +81,7 @@ nsm_mon_unmon(struct nsm_handle *nsm, u3
  * Set up monitoring of a remote host
  */
 int
-nsm_monitor(struct nlm_host *host)
+__nsm_monitor(struct nlm_host *host)
 {
 	struct nsm_handle *nsm;
 	struct nsm_res	res;
@@ -90,7 +107,7 @@ nsm_monitor(struct nlm_host *host)
  * Cease to monitor remote host
  */
 int
-nsm_unmonitor(struct nlm_host *host)
+__nsm_unmonitor(struct nlm_host *host)
 {
 	struct nsm_handle *nsm;
 	struct nsm_res	res;
Index: linux-2.6.12/fs/lockd/statd.c
===================================================================
--- /dev/null
+++ linux-2.6.12/fs/lockd/statd.c
@@ -0,0 +1,406 @@
+/*
+ * linux/fs/lockd/nsmproc.c
+ *
+ * Kernel-based status monitor. This is an alternative to
+ * the code in mon.c.
+ *
+ * When asked to monitor a host, we add it to /var/lib/nsm/sm
+ * ourselves, and that's it. In order to catch SM_NOTIFY calls
+ * we implement a minimal statd.
+ *
+ * Minimal user space requirements for this implementation:
+ *  /var/lib/nfs/state
+ *	must exist, and must contain the NSM state as a 32bit
+ *	binary counter.
+ * /var/lib/nfs/sm
+ *	must exist
+ *
+ * Copyright (C) 2004, Olaf Kirch <okir@suse.de>
+ */
+
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/slab.h>
+#include <linux/in.h>
+#include <linux/sunrpc/svc.h>
+#include <linux/sunrpc/clnt.h>
+#include <linux/nfsd/nfsd.h>
+#include <linux/lockd/lockd.h>
+#include <linux/lockd/share.h>
+#include <linux/lockd/sm_inter.h>
+#include <linux/file.h>
+#include <linux/namei.h>
+#include <asm/uaccess.h>
+#include <linux/buffer_head.h>
+
+
+/* XXX make this a module parameter? */
+#define NSM_BASE_PATH		"/var/lib/nfs"
+#define NSM_SM_PATH		NSM_BASE_PATH "/sm"
+#define NSM_STATE_PATH		NSM_BASE_PATH "/state"
+
+#define NLMDBG_FACILITY		NLMDBG_CLIENT
+
+static int	__nsm_monitor(struct nlm_host *host);
+static int	__nsm_unmonitor(struct nlm_host *host);
+
+/*
+ * Initialize local NSM state variable
+ */
+int
+nsm_kernel_statd_init(void)
+{
+	struct file	*filp;
+	char		buffer[32];
+	mm_segment_t	fs;
+	int		res;
+
+	dprintk("lockd: nsm_init()\n");
+	filp = filp_open(NSM_STATE_PATH, O_RDONLY, 0444);
+	if (IS_ERR(filp)) {
+		res = PTR_ERR(filp);
+		printk(KERN_NOTICE "lockd: failed to open %s: err=%d\n",
+				NSM_STATE_PATH, res);
+		return res;
+	}
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	res = vfs_read(filp, buffer, sizeof(buffer), &filp->f_pos);
+	set_fs(fs);
+	filp_close(filp, NULL);
+
+	if (res < 0)
+		return res;
+	if (res == 4)
+		nsm_local_state = *(u32 *) buffer;
+	else
+		nsm_local_state = simple_strtol(buffer, NULL, 10);
+
+	nsm_monitor = __nsm_monitor;
+	nsm_unmonitor = __nsm_unmonitor;
+	return 0;
+}
+
+/*
+ * Build the NSM file name
+ */
+static char *
+nsm_filename(struct nsm_handle *nsm)
+{
+	char	*name;
+
+	name = (char *) __get_free_page(GFP_KERNEL);
+	if (name == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	if (nsm_use_hostnames) {
+		snprintf(name, PAGE_SIZE, "%s/%s",
+				NSM_SM_PATH, nsm->sm_name);
+	} else {
+		/* FIXME IPV6 */
+		snprintf(name, PAGE_SIZE, "%s/%u.%u.%u.%u",
+				NSM_SM_PATH,
+				NIPQUAD(nsm->sm_addr.sin_addr));
+	}
+	return name;
+}
+
+static void
+nsm_put_name(char *name)
+{
+	free_page((unsigned long) name);
+}
+
+/*
+ * Create the NSM monitor file
+ */
+static int
+nsm_create(struct nsm_handle *nsm)
+{
+	struct file	*filp;
+	char		*filename;
+	int		res = 0;
+
+	dprintk("lockd: creating statd monitor file for %s\n", nsm->sm_name);
+
+	if (!(filename = nsm_filename(nsm)))
+		return -ENOMEM;
+
+	filp = filp_open(filename, O_CREAT|O_SYNC|O_RDWR, 0644);
+	if (IS_ERR(filp)) {
+		res = PTR_ERR(filp);
+		printk(KERN_NOTICE
+			"lockd/statd: failed to create %s: err=%d\n",
+			filename, res);
+	} else {
+		fsync_super(filp->f_dentry->d_inode->i_sb);
+		filp_close(filp, NULL);
+	}
+
+	nsm_put_name(filename);
+	return res;
+}
+
+static int
+nsm_unlink(struct nsm_handle *nsm)
+{
+	struct nameidata nd;
+	struct inode	*inode = NULL;
+	struct dentry	*dentry;
+	char		*filename;
+	int		res = 0;
+
+	if (!(filename = nsm_filename(nsm)))
+		return -ENOMEM;
+
+	if ((res = path_lookup(filename, LOOKUP_PARENT, &nd)) != 0)
+		goto exit;
+
+	if (nd.last_type == LAST_NORM && !nd.last.name[nd.last.len]) {
+		down(&nd.dentry->d_inode->i_sem);
+
+		dentry = lookup_hash(&nd.last, nd.dentry);
+		if (!IS_ERR(dentry)) {
+			if ((inode = dentry->d_inode) != NULL)
+				atomic_inc(&inode->i_count);
+			res = vfs_unlink(nd.dentry->d_inode, dentry);
+			dput(dentry);
+		} else {
+			res = PTR_ERR(dentry);
+		}
+		up(&nd.dentry->d_inode->i_sem);
+	} else {
+		res = -EISDIR;
+	}
+	path_release(&nd);
+
+exit:
+	if (res < 0) {
+		printk(KERN_NOTICE
+			"lockd/statd: failed to unlink %s: err=%d\n",
+			filename, res);
+	}
+
+	if (inode)
+		iput(inode);
+	nsm_put_name(filename);
+	return res;
+}
+
+/*
+ * Call nsm_create/nsm_unlink with CAP_DAC_OVERRIDE
+ */
+#define swap_ugid(type, var) { \
+	type tmp = current->var; current->var = var; var = tmp; \
+}
+
+static int
+with_privilege(int (*func)(struct nsm_handle *), struct nsm_handle *nsm)
+{
+	kernel_cap_t	cap = current->cap_effective;
+	int		res = 0, mask;
+	uid_t		fsuid = 0;
+	gid_t		fsgid = 0;
+
+	/* If we're unprivileged, a call to capable() will set the
+	 * SUPERPRIV flag */
+	mask = current->flags | ~PF_SUPERPRIV;
+
+	/* Raise capability to that we're able to create/unlink the file.
+	 * Set fsuid/fsgid to 0 so the file will be owned by root. */
+	cap_raise(current->cap_effective, CAP_DAC_OVERRIDE);
+	swap_ugid(uid_t, fsuid);
+	swap_ugid(gid_t, fsgid);
+
+	res = func(nsm);
+
+	/* drop privileges */
+	current->cap_effective = cap;
+	swap_ugid(uid_t, fsuid);
+	swap_ugid(gid_t, fsgid);
+
+	/* Clear PF_SUPERPRIV unless it was set to begin with */
+	current->flags &= mask;
+
+	return res;
+}
+
+/*
+ * Set up monitoring of a remote host
+ * Note we hold the semaphore for the host table while
+ * we're here.
+ */
+static int
+__nsm_monitor(struct nlm_host *host)
+{
+	struct nsm_handle *nsm;
+	int		res = 0;
+
+	dprintk("lockd: nsm_monitor(%s)\n", host->h_name);
+	if ((nsm = host->h_nsmhandle) == NULL)
+		BUG();
+
+	if (!nsm->sm_monitored) {
+		res = with_privilege(nsm_create, nsm);
+		if (res >= 0) {
+			nsm->sm_monitored = 1;
+		} else {
+			dprintk(KERN_NOTICE "nsm_monitor(%s) failed: errno=%d\n",
+					nsm->sm_name, -res);
+		}
+	}
+
+	return res;
+}
+
+/*
+ * Cease to monitor remote host
+ * Code stolen from sys_unlink.
+ */
+static int
+__nsm_unmonitor(struct nlm_host *host)
+{
+	struct nsm_handle *nsm;
+	int res = 0;
+
+	nsm = host->h_nsmhandle;
+	host->h_nsmhandle = NULL;
+
+	/* If the host was invalidated due to lockd restart/shutdown,
+	 * don't unmonitor it.
+	 * (Strictly speaking, we would have to keep the SM file
+	 * until the next reboot. The only way to achieve that
+	 * would be to link the monitor file to sm.bak now.)
+	 */
+	if (nsm && atomic_read(&nsm->sm_count) == 1
+	 && nsm->sm_monitored && !nsm->sm_sticky) {
+		dprintk("lockd: nsm_unmonitor(%s)\n", host->h_name);
+
+		res = with_privilege(nsm_unlink, nsm);
+	}
+
+	nsm_release(nsm);
+	return res;
+}
+
+/*
+ * NSM server implementation starts here
+ */
+int
+statd_authenticate(struct svc_rqst *rqstp)
+{
+	/* No authentication for statd. Many statd implementations
+	 * even send their reboot notifications from an unprivileged
+	 * port.
+	 */
+	rqstp->rq_client = NULL;
+	return SVC_OK;
+}
+
+
+/*
+ * NULL: Test for presence of service
+ */
+static int
+nsmsvc_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)
+{
+	dprintk("statd: NULL          called\n");
+	return rpc_success;
+}
+
+/*
+ * NOTIFY: receive notification that remote host rebooted
+ */
+static int
+nsmsvc_proc_notify(struct svc_rqst *rqstp, struct nsm_args *argp,
+				           struct nsm_res  *resp)
+{
+	struct sockaddr_in	saddr = rqstp->rq_addr;
+
+	dprintk("statd: NOTIFY        called\n");
+
+	nlm_host_rebooted(&saddr, argp->mon_name, argp->state);
+	return rpc_success;
+}
+
+/*
+ * All other operations: return failure
+ */
+static int
+nsmsvc_proc_fail(struct svc_rqst *rqstp, struct nsm_args *argp,
+				         struct nsm_res  *resp)
+{
+	dprintk("statd: proc %u        called\n", rqstp->rq_proc);
+	resp->status = 0;
+	resp->state = -1;
+	return rpc_success;
+}
+
+/*
+ * NSM XDR routines
+ */
+static int
+nsmsvc_decode_void(struct svc_rqst *rqstp, u32 *p, void *dummy)
+{
+	return xdr_argsize_check(rqstp, p);
+}
+
+static int
+nsmsvc_encode_void(struct svc_rqst *rqstp, u32 *p, void *dummy)
+{
+	return xdr_ressize_check(rqstp, p);
+}
+
+static int
+nsmsvc_decode_stat_chge(struct svc_rqst *rqstp, u32 *p, struct nsm_args *argp)
+{
+	__u32	mon_name_len;
+
+	/* Skip over the client's mon_name */
+	p = xdr_decode_string(p, &argp->mon_name, &mon_name_len, SM_MAXSTRLEN);
+	if (p == NULL)
+		return 0;
+
+	argp->state = ntohl(*p++);
+	return xdr_argsize_check(rqstp, p);
+}
+
+static int
+nsmsvc_encode_res(struct svc_rqst *rqstp, u32 *p, struct nsm_res *resp)
+{
+	*p++ = resp->status;
+	return xdr_ressize_check(rqstp, p);
+}
+
+static int
+nsmsvc_encode_stat_res(struct svc_rqst *rqstp, u32 *p, struct nsm_res *resp)
+{
+	*p++ = resp->status;
+	*p++ = resp->state;
+	return xdr_ressize_check(rqstp, p);
+}
+
+struct nsm_void			{ int dummy; };
+
+#define PROC(name, xargt, xrest, argt, rest, respsize)	\
+ { .pc_func	= (svc_procfunc) nsmsvc_proc_##name,	\
+   .pc_decode	= (kxdrproc_t) nsmsvc_decode_##xargt,	\
+   .pc_encode	= (kxdrproc_t) nsmsvc_encode_##xrest,	\
+   .pc_release	= NULL,					\
+   .pc_argsize	= sizeof(struct nsm_##argt),		\
+   .pc_ressize	= sizeof(struct nsm_##rest),		\
+   .pc_xdrressize = respsize,				\
+ }
+
+struct svc_procedure		nsmsvc_procedures[] = {
+  PROC(null,		void,		void,		void,	void, 1),
+  PROC(fail,		void,		stat_res,	void,	res, 2),
+  PROC(fail,		void,		stat_res,	void,	res, 2),
+  PROC(fail,		void,		res,		void,	res, 1),
+  PROC(fail,		void,		res,		void,	res, 1),
+  PROC(fail,		void,		res,		void,	res, 1),
+  PROC(notify,		stat_chge,	void,		args,	void, 1)
+};
Index: linux-2.6.12/fs/lockd/svc.c
===================================================================
--- linux-2.6.12.orig/fs/lockd/svc.c
+++ linux-2.6.12/fs/lockd/svc.c
@@ -32,6 +32,7 @@
 #include <linux/sunrpc/svc.h>
 #include <linux/sunrpc/svcsock.h>
 #include <linux/lockd/lockd.h>
+#include <linux/lockd/sm_inter.h>
 #include <linux/nfs.h>
 
 #define NLMDBG_FACILITY		NLMDBG_SVC
@@ -39,6 +40,7 @@
 #define ALLOWED_SIGS		(sigmask(SIGKILL))
 
 static struct svc_program	nlmsvc_program;
+extern struct svc_program	nsmsvc_program;
 
 struct nlmsvc_binding *		nlmsvc_ops;
 EXPORT_SYMBOL(nlmsvc_ops);
@@ -61,6 +63,7 @@ static unsigned long		nlm_timeout = LOCK
 static int			nlm_udpport, nlm_tcpport;
 int				nlm_max_hosts = 256;
 int				nsm_use_hostnames = 1;
+static int			nsm_use_kstatd = 1;
 
 /*
  * Constants needed for the sysctl interface.
@@ -118,13 +121,20 @@ lockd(struct svc_rqst *rqstp)
 
 	daemonize("lockd");
 
+	/* Set up statd */
+	if (nsm_use_kstatd && nsm_kernel_statd_init() < 0)
+		nsm_use_kstatd = 0;
+	if (nsm_use_kstatd == 0)
+		nsm_statd_upcalls_init();
+
 	/* Process request with signals blocked, but allow SIGKILL.  */
 	allow_signal(SIGKILL);
 
 	/* kick rpciod */
 	rpciod_up();
 
-	dprintk("NFS locking service started (ver " LOCKD_VERSION ").\n");
+	dprintk("NFS locking%s service started (ver " LOCKD_VERSION ").\n",
+			nsm_use_kstatd? " and status" : "");
 
 	if (!nlm_timeout)
 		nlm_timeout = LOCKD_DFLT_TIMEO;
@@ -214,6 +224,7 @@ int
 lockd_up(void)
 {
 	static int		warned;
+	struct svc_program *	prog;
 	struct svc_serv *	serv;
 	int			error = 0;
 
@@ -237,8 +248,12 @@ lockd_up(void)
 		printk(KERN_WARNING
 			"lockd_up: no pid, %d users??\n", nlmsvc_users);
 
+	/* Register NLM program and possibly NSM (if using kstatd) */
 	error = -ENOMEM;
-	serv = svc_create(&nlmsvc_program, LOCKD_BUFSIZE);
+	prog = &nlmsvc_program;
+	if (nsm_use_kstatd)
+		prog = &nsmsvc_program;
+	serv = svc_create(prog, LOCKD_BUFSIZE);
 	if (!serv) {
 		printk(KERN_WARNING "lockd_up: create service failed\n");
 		goto out;
@@ -385,6 +400,14 @@ static ctl_table nlm_sysctls[] = {
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "nsm_use_kstatd",
+		.data		= &nsm_use_kstatd,
+		.maxlen		= sizeof(int),
+		.mode		= 0444,
+		.proc_handler	= &proc_dointvec,
+	},
 
 	{ .ctl_name = 0 }
 };
@@ -474,6 +497,7 @@ module_param_call(nlm_udpport, param_set
 		  &nlm_udpport, 0644);
 module_param_call(nlm_tcpport, param_set_port, param_get_int,
 		  &nlm_tcpport, 0644);
+module_param(nsm_use_kstatd, int, 0444);
 
 /*
  * Initialising and terminating the module.
@@ -538,3 +562,30 @@ static struct svc_program	nlmsvc_program
 	.pg_stats		= &nlmsvc_stats,	/* stats table */
 	.pg_authenticate = &lockd_authenticate	/* export authentication */
 };
+
+/*
+ * Define NSM program and procedures
+ */
+static struct svc_version	nsmsvc_version1 = {
+		.vs_vers	= 1,
+		.vs_nproc	= 7,
+		.vs_proc	= nsmsvc_procedures,
+		.vs_xdrsize	= SMSVC_XDRSIZE,
+};
+static struct svc_version *	nsmsvc_version[] = {
+	[1] = &nsmsvc_version1,
+};
+
+static struct svc_stat		nsmsvc_stats;
+
+#define SM_NRVERS	(sizeof(nsmsvc_version)/sizeof(nsmsvc_version[0]))
+struct svc_program	nsmsvc_program = {
+	.pg_next		= &nlmsvc_program,
+	.pg_prog		= SM_PROGRAM,		/* program number */
+	.pg_nvers		= SM_NRVERS,		/* number of entries in nlmsvc_version */
+	.pg_vers		= nsmsvc_version,	/* version table */
+	.pg_name		= "statd",		/* service name */
+	.pg_class		= "nfsd",		/* share authentication with nfsd */
+	.pg_stats		= &nsmsvc_stats,	/* stats table */
+	.pg_authenticate	= &statd_authenticate	/* no authentication :-( */
+};
Index: linux-2.6.12/include/linux/lockd/lockd.h
===================================================================
--- linux-2.6.12.orig/include/linux/lockd/lockd.h
+++ linux-2.6.12/include/linux/lockd/lockd.h
@@ -149,6 +149,7 @@ extern struct svc_procedure	nlmsvc_proce
 #ifdef CONFIG_LOCKD_V4
 extern struct svc_procedure	nlmsvc_procedures4[];
 #endif
+extern struct svc_procedure	nsmsvc_procedures[];
 extern int			nlmsvc_grace_period;
 extern unsigned long		nlmsvc_timeout;
 extern int			nlm_max_hosts;
Index: linux-2.6.12/include/linux/sunrpc/svc.h
===================================================================
--- linux-2.6.12.orig/include/linux/sunrpc/svc.h
+++ linux-2.6.12/include/linux/sunrpc/svc.h
@@ -275,6 +275,9 @@ struct svc_version {
 	struct svc_procedure *	vs_proc;	/* per-procedure info */
 	u32			vs_xdrsize;	/* xdrsize needed for this version */
 
+	unsigned int		vs_hidden : 1	;/* Don't register with portmapper.
+						  * Only used for nfsacl so far. */
+
 	/* Override dispatch function (e.g. when caching replies).
 	 * A return value of 0 means drop the request. 
 	 * vs_dispatch == NULL means use default dispatcher.
Index: linux-2.6.12/net/sunrpc/svc.c
===================================================================
--- linux-2.6.12.orig/net/sunrpc/svc.c
+++ linux-2.6.12/net/sunrpc/svc.c
@@ -221,23 +221,32 @@ svc_register(struct svc_serv *serv, int 
 	unsigned long		flags;
 	int			i, error = 0, dummy;
 
-	progp = serv->sv_program;
-
-	dprintk("RPC: svc_register(%s, %s, %d)\n",
-		progp->pg_name, proto == IPPROTO_UDP? "udp" : "tcp", port);
-
 	if (!port)
 		clear_thread_flag(TIF_SIGPENDING);
 
-	for (i = 0; i < progp->pg_nvers; i++) {
-		if (progp->pg_vers[i] == NULL)
-			continue;
-		error = rpc_register(progp->pg_prog, i, proto, port, &dummy);
-		if (error < 0)
-			break;
-		if (port && !dummy) {
-			error = -EACCES;
-			break;
+	for (progp = serv->sv_program; progp; progp = progp->pg_next) {
+		for (i = 0; i < progp->pg_nvers; i++) {
+			if (progp->pg_vers[i] == NULL)
+				continue;
+
+			dprintk("RPC: svc_register(%s, %s, %d, %d)%s\n",
+					progp->pg_name,
+					proto == IPPROTO_UDP?  "udp" : "tcp",
+					port,
+					i,
+					progp->pg_vers[i]->vs_hidden?
+						" (but not telling portmap)" : "");
+
+			if (progp->pg_vers[i]->vs_hidden)
+				continue;
+
+			error = rpc_register(progp->pg_prog, i, proto, port, &dummy);
+			if (error < 0)
+				break;
+			if (port && !dummy) {
+				error = -EACCES;
+				break;
+			}
 		}
 	}
 
Index: linux-2.6.12/fs/lockd/Makefile
===================================================================
--- linux-2.6.12.orig/fs/lockd/Makefile
+++ linux-2.6.12/fs/lockd/Makefile
@@ -4,7 +4,7 @@
 
 obj-$(CONFIG_LOCKD) += lockd.o
 
-lockd-objs-y := clntlock.o clntproc.o host.o svc.o svclock.o svcshare.o \
+lockd-objs-y := clntlock.o clntproc.o host.o statd.o svc.o svclock.o svcshare.o \
 	        svcproc.o svcsubs.o mon.o xdr.o
 lockd-objs-$(CONFIG_LOCKD_V4) += xdr4.o svc4proc.o
 lockd-objs		      := $(lockd-objs-y)
Index: linux-2.6.12/fs/buffer.c
===================================================================
--- linux-2.6.12.orig/fs/buffer.c
+++ linux-2.6.12/fs/buffer.c
@@ -184,6 +184,7 @@ int fsync_super(struct super_block *sb)
 
 	return sync_blockdev(sb->s_bdev);
 }
+EXPORT_SYMBOL(fsync_super);
 
 /*
  * Write out and wait upon all dirty data associated with this
Index: linux-2.6.12/fs/nfsd/nfs2acl.c
===================================================================
--- linux-2.6.12.orig/fs/nfsd/nfs2acl.c
+++ linux-2.6.12/fs/nfsd/nfs2acl.c
@@ -333,4 +333,5 @@ struct svc_version	nfsd_acl_version2 = {
 		.vs_proc	= nfsd_acl_procedures2,
 		.vs_dispatch	= nfsd_dispatch,
 		.vs_xdrsize	= NFS3_SVC_XDRSIZE,
+		.vs_hidden	= 1,
 };
Index: linux-2.6.12/fs/nfsd/nfs3acl.c
===================================================================
--- linux-2.6.12.orig/fs/nfsd/nfs3acl.c
+++ linux-2.6.12/fs/nfsd/nfs3acl.c
@@ -263,5 +263,6 @@ struct svc_version	nfsd_acl_version3 = {
 		.vs_proc	= nfsd_acl_procedures3,
 		.vs_dispatch	= nfsd_dispatch,
 		.vs_xdrsize	= NFS3_SVC_XDRSIZE,
+		.vs_hidden	= 1,
 };
 
