From: Chris Mason <mason@suse.com>
Subject: reiserfs: use mark_inode_dirty instead of reiserfs_update_sd

reiserfs should use mark_inode_dirty during reiserfs_file_write and
reiserfs_commit_write.  This makes sure the inode is properly flagged as
dirty, which is used during O_SYNC to decide when to trigger log commits.

This patch also removes the O_SYNC check from reiserfs_commit_write,
since that gets dealt with properly at higher layers once we start
using mark_inode_dirty

 fs/reiserfs/file.c  |    9 +++++----
 fs/reiserfs/inode.c |   16 +++++++---------
 2 files changed, 12 insertions(+), 13 deletions(-)

Index: linux-2.6.12/fs/reiserfs/file.c
===================================================================
--- linux-2.6.12.orig/fs/reiserfs/file.c
+++ linux-2.6.12/fs/reiserfs/file.c
@@ -667,7 +667,7 @@ static int reiserfs_allocate_blocks_for_
 	if (th->t_trans_id) {
 		int err;
 		// update any changes we made to blk count
-		reiserfs_update_sd(th, inode);
+		mark_inode_dirty(inode);
 		err =
 		    journal_end(th, inode->i_sb,
 				JOURNAL_PER_BALANCE_CNT * 3 + 1 +
@@ -855,7 +855,8 @@ static int reiserfs_submit_file_region_f
 
 		if (th->t_trans_id) {
 			reiserfs_write_lock(inode->i_sb);
-			reiserfs_update_sd(th, inode);	// And update on-disk metadata
+			// this sets the proper flags for O_SYNC to trigger a commit
+			mark_inode_dirty(inode);
 			reiserfs_write_unlock(inode->i_sb);
 		} else
 			inode->i_sb->s_op->dirty_inode(inode);
@@ -865,7 +866,7 @@ static int reiserfs_submit_file_region_f
 	if (th->t_trans_id) {
 		reiserfs_write_lock(inode->i_sb);
 		if (!sd_update)
-			reiserfs_update_sd(th, inode);
+			mark_inode_dirty(inode);
 		status = journal_end(th, th->t_super, th->t_blocks_allocated);
 		if (status)
 			retval = status;
@@ -1337,7 +1338,7 @@ static ssize_t reiserfs_file_write(struc
 				return err;
 			}
 			reiserfs_update_inode_transaction(inode);
-			reiserfs_update_sd(&th, inode);
+			mark_inode_dirty(inode);
 			err = journal_end(&th, inode->i_sb, 1);
 			if (err) {
 				reiserfs_write_unlock(inode->i_sb);
Index: linux-2.6.12/fs/reiserfs/inode.c
===================================================================
--- linux-2.6.12.orig/fs/reiserfs/inode.c
+++ linux-2.6.12/fs/reiserfs/inode.c
@@ -2627,6 +2627,12 @@ static int reiserfs_commit_write(struct 
 		}
 		reiserfs_update_inode_transaction(inode);
 		inode->i_size = pos;
+		/*
+		 * this will just nest into our transaction.  It's important
+		 * to use mark_inode_dirty so the inode gets pushed around on the
+		 * dirty lists, and so that O_SYNC works as expected
+		 */
+		mark_inode_dirty(inode);
 		reiserfs_update_sd(&myth, inode);
 		update_sd = 1;
 		ret = journal_end(&myth, inode->i_sb, 1);
@@ -2637,21 +2643,13 @@ static int reiserfs_commit_write(struct 
 	if (th) {
 		reiserfs_write_lock(inode->i_sb);
 		if (!update_sd)
-			reiserfs_update_sd(th, inode);
+			mark_inode_dirty(inode);
 		ret = reiserfs_end_persistent_transaction(th);
 		reiserfs_write_unlock(inode->i_sb);
 		if (ret)
 			goto out;
 	}
 
-	/* we test for O_SYNC here so we can commit the transaction
-	 ** for any packed tails the file might have had
-	 */
-	if (f && (f->f_flags & O_SYNC)) {
-		reiserfs_write_lock(inode->i_sb);
-		ret = reiserfs_commit_for_inode(inode);
-		reiserfs_write_unlock(inode->i_sb);
-	}
       out:
 	return ret;
 
