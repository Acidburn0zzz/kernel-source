reiserfs should use mark_inode_dirty during reiserfs_file_write and
reiserfs_commit_write.  This makes sure the inode is properly flagged as
dirty, which is used during O_SYNC to decide when to trigger log commits.

This patch also removes the O_SYNC check from reiserfs_commit_write,
since that gets dealt with properly at higher layers once we start
using mark_inode_dirty

diff -ur linux.t2/fs/reiserfs/file.c linux.t/fs/reiserfs/file.c
--- linux.t2/fs/reiserfs/file.c	2004-05-25 10:29:59.000000000 -0400
+++ linux.t/fs/reiserfs/file.c	2004-05-25 11:07:42.000000000 -0400
@@ -570,7 +570,7 @@
     if (th->t_trans_id) {
         int err;
         // update any changes we made to blk count
-        reiserfs_update_sd(th, inode);
+        mark_inode_dirty(inode);
         err = journal_end(th, inode->i_sb, JOURNAL_PER_BALANCE_CNT * 3 + 1);
         if (err)
             res = err;
@@ -756,7 +756,8 @@
 
 	if (th->t_trans_id) {
 	    reiserfs_write_lock(inode->i_sb);
-	    reiserfs_update_sd(th, inode); // And update on-disk metadata
+	    // this sets the proper flags for O_SYNC to trigger a commit
+	    mark_inode_dirty(inode);
 	    reiserfs_write_unlock(inode->i_sb);
 	} else
 	    inode->i_sb->s_op->dirty_inode(inode);
@@ -766,7 +767,7 @@
     if (th->t_trans_id) {
 	reiserfs_write_lock(inode->i_sb);
 	if (!sd_update)
-	    reiserfs_update_sd(th, inode);
+	    mark_inode_dirty(inode);
 	status = journal_end(th, th->t_super, th->t_blocks_allocated);
         if (status)
             retval = status;
@@ -1191,7 +1192,7 @@
                 return err;
             }
 	    reiserfs_update_inode_transaction(inode);
-	    reiserfs_update_sd(&th, inode);
+	    mark_inode_dirty(inode);
 	    err = journal_end(&th, inode->i_sb, 1);
             if (err) {
                 reiserfs_write_unlock (inode->i_sb);
diff -ur linux.t2/fs/reiserfs/inode.c linux.t/fs/reiserfs/inode.c
--- linux.t2/fs/reiserfs/inode.c	2004-05-25 10:29:59.000000000 -0400
+++ linux.t/fs/reiserfs/inode.c	2004-05-25 11:18:43.000000000 -0400
@@ -2511,6 +2511,12 @@
         }
 	reiserfs_update_inode_transaction(inode) ;
 	inode->i_size = pos ;
+	/* 
+	 * this will just nest into our transaction.  It's important
+	 * to use mark_inode_dirty so the inode gets pushed around on the
+	 * dirty lists, and so that O_SYNC works as expected
+	 */
+	mark_inode_dirty(inode);
 	reiserfs_update_sd(&myth, inode) ;
 	update_sd = 1;
 	ret = journal_end(&myth, inode->i_sb, 1) ;
@@ -2521,21 +2527,13 @@
     if (th) {
 	reiserfs_write_lock(inode->i_sb);
 	if (!update_sd)
-	    reiserfs_update_sd(th, inode) ;
+	    mark_inode_dirty(inode);
         ret = reiserfs_end_persistent_transaction(th);
 	reiserfs_write_unlock(inode->i_sb);
         if (ret)
             goto out;
     }
- 
-    /* we test for O_SYNC here so we can commit the transaction
-    ** for any packed tails the file might have had
-    */
-    if (f && (f->f_flags & O_SYNC)) {
-	reiserfs_write_lock(inode->i_sb);
- 	ret = reiserfs_commit_for_inode(inode) ;
-	reiserfs_write_unlock(inode->i_sb);
-    }
+
 out:
     return ret ;
 
