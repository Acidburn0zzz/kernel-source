From: Chris Mason <mason@suse.com>
Subject: reiserfs: use mark_inode_dirty instead of reiserfs_update_sd

reiserfs should use mark_inode_dirty during reiserfs_file_write and
reiserfs_commit_write.  This makes sure the inode is properly flagged as
dirty, which is used during O_SYNC to decide when to trigger log commits.

This patch also removes the O_SYNC check from reiserfs_commit_write,
since that gets dealt with properly at higher layers once we start
using mark_inode_dirty

Index: linux.merge/fs/reiserfs/file.c
===================================================================
--- linux.merge.orig/fs/reiserfs/file.c	2005-01-20 17:26:46.000000000 -0500
+++ linux.merge/fs/reiserfs/file.c	2005-01-20 17:26:49.000000000 -0500
@@ -575,7 +575,7 @@ error_exit:
     if (th->t_trans_id) {
         int err;
         // update any changes we made to blk count
-        reiserfs_update_sd(th, inode);
+        mark_inode_dirty(inode);
         err = journal_end(th, inode->i_sb, JOURNAL_PER_BALANCE_CNT * 3 + 1 + 2 * REISERFS_QUOTA_TRANS_BLOCKS);
         if (err)
             res = err;
@@ -762,7 +762,8 @@ static int reiserfs_submit_file_region_f
 
 	if (th->t_trans_id) {
 	    reiserfs_write_lock(inode->i_sb);
-	    reiserfs_update_sd(th, inode); // And update on-disk metadata
+	    // this sets the proper flags for O_SYNC to trigger a commit
+	    mark_inode_dirty(inode);
 	    reiserfs_write_unlock(inode->i_sb);
 	} else
 	    inode->i_sb->s_op->dirty_inode(inode);
@@ -772,7 +773,7 @@ static int reiserfs_submit_file_region_f
     if (th->t_trans_id) {
 	reiserfs_write_lock(inode->i_sb);
 	if (!sd_update)
-	    reiserfs_update_sd(th, inode);
+	    mark_inode_dirty(inode);
 	status = journal_end(th, th->t_super, th->t_blocks_allocated);
         if (status)
             retval = status;
@@ -1214,7 +1215,7 @@ static ssize_t reiserfs_file_write( stru
                 return err;
             }
 	    reiserfs_update_inode_transaction(inode);
-	    reiserfs_update_sd(&th, inode);
+	    mark_inode_dirty(inode);
 	    err = journal_end(&th, inode->i_sb, 1);
             if (err) {
                 reiserfs_write_unlock (inode->i_sb);
Index: linux.merge/fs/reiserfs/inode.c
===================================================================
--- linux.merge.orig/fs/reiserfs/inode.c	2005-01-20 16:52:50.000000000 -0500
+++ linux.merge/fs/reiserfs/inode.c	2005-01-20 17:26:48.000000000 -0500
@@ -2499,6 +2499,12 @@ static int reiserfs_commit_write(struct 
 	}
 	reiserfs_update_inode_transaction(inode) ;
 	inode->i_size = pos ;
+	/*
+	 * this will just nest into our transaction.  It's important
+	 * to use mark_inode_dirty so the inode gets pushed around on the
+	 * dirty lists, and so that O_SYNC works as expected
+	 */
+	mark_inode_dirty(inode);
 	reiserfs_update_sd(&myth, inode) ;
 	update_sd = 1;
 	ret = journal_end(&myth, inode->i_sb, 1) ;
@@ -2509,21 +2515,13 @@ static int reiserfs_commit_write(struct 
     if (th) {
 	reiserfs_write_lock(inode->i_sb);
 	if (!update_sd)
-	    reiserfs_update_sd(th, inode) ;
+	    mark_inode_dirty(inode);
 	ret = reiserfs_end_persistent_transaction(th);
 	reiserfs_write_unlock(inode->i_sb);
 	if (ret)
 	    goto out;
     }
- 
-    /* we test for O_SYNC here so we can commit the transaction
-    ** for any packed tails the file might have had
-    */
-    if (f && (f->f_flags & O_SYNC)) {
-	reiserfs_write_lock(inode->i_sb);
- 	ret = reiserfs_commit_for_inode(inode) ;
-	reiserfs_write_unlock(inode->i_sb);
-    }
+
 out:
     return ret ;
 
