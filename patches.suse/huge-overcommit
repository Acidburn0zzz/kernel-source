diff -u linux/include/linux/hugetlb.h-OVERCOMMIT linux/include/linux/hugetlb.h
--- linux/include/linux/hugetlb.h-OVERCOMMIT	2004-06-08 12:23:41.000000000 +0200
+++ linux/include/linux/hugetlb.h	2004-06-08 13:01:05.000000000 +0200
@@ -21,6 +21,7 @@
 void huge_page_release(struct page *);
 int hugetlb_report_meminfo(char *);
 int is_hugepage_mem_enough(size_t);
+int __is_hugepage_mem_enough(struct mempolicy *pol, size_t);
 unsigned long hugetlb_total_pages(void);
 struct page *follow_huge_addr(struct mm_struct *mm, struct vm_area_struct *vma,
 			unsigned long address, int write);
@@ -30,8 +31,12 @@
 				pmd_t *pmd, int write);
 int is_aligned_hugepage_range(unsigned long addr, unsigned long len);
 int pmd_huge(pmd_t pmd);
+unsigned long huge_pages_needed(struct address_space *mapping, 
+				struct vm_area_struct *vma,
+				unsigned long start, unsigned long end);
 
 extern int htlbpage_max;
+extern int sysctl_overcommit_hugepages;
 
 static inline void
 mark_mm_hugetlb(struct mm_struct *mm, struct vm_area_struct *vma)
diff -u linux/fs/hugetlbfs/inode.c-OVERCOMMIT linux/fs/hugetlbfs/inode.c
--- linux/fs/hugetlbfs/inode.c-OVERCOMMIT	2004-06-08 12:23:41.000000000 +0200
+++ linux/fs/hugetlbfs/inode.c	2004-06-08 18:19:36.000000000 +0200
@@ -32,6 +32,10 @@
 /* some random number */
 #define HUGETLBFS_MAGIC	0x958458f6
 
+int sysctl_overcommit_hugepages;  /* no overcommit by default */
+
+void huge_pagevec_release(struct pagevec *pvec);
+
 static struct super_operations hugetlbfs_ops;
 static struct address_space_operations hugetlbfs_aops;
 struct file_operations hugetlbfs_file_operations;
@@ -43,10 +47,39 @@
 	.memory_backed	= 1,	/* Does not contribute to dirty memory */
 };
 
+unsigned long 
+huge_pages_needed(struct address_space *mapping, struct vm_area_struct *vma,
+		  unsigned long start, unsigned long end)
+{ 
+	int i;
+	struct pagevec pvec;
+	unsigned long hugepages = (end - start) >> HPAGE_SHIFT; 
+	pgoff_t next = vma->vm_pgoff + ((start - vma->vm_start)>>PAGE_SHIFT);
+	pgoff_t endpg = next + ((end - start) >> PAGE_SHIFT);
+
+	pagevec_init(&pvec, 0);
+	while (next < endpg) { 
+		if (!pagevec_lookup(&pvec, mapping, next, PAGEVEC_SIZE))
+			break;
+		for (i = 0; i < pagevec_count(&pvec); i++) { 
+			struct page *page = pvec.pages[i];
+			if (page->index > next)
+				next = page->index;
+			if (page->index >= endpg) 
+				break;
+			next++;			
+			hugepages--; 
+		}
+		huge_pagevec_release(&pvec);
+	}
+	return hugepages << HPAGE_SHIFT; 
+} 
+
 static int hugetlbfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	struct inode *inode = file->f_dentry->d_inode;
 	struct address_space *mapping = inode->i_mapping;
+	unsigned long bytes;
 	loff_t len, vma_len;
 	int ret;
 
@@ -59,6 +92,10 @@
 	if (vma->vm_end - vma->vm_start < HPAGE_SIZE)
 		return -EINVAL;
 
+	bytes = huge_pages_needed(mapping, vma, vma->vm_start, vma->vm_end);
+	if (!sysctl_overcommit_hugepages && !is_hugepage_mem_enough(bytes))
+		return -ENOMEM;
+	    
 	vma_len = (loff_t)(vma->vm_end - vma->vm_start);
 
 	down(&inode->i_sem);
diff -u linux/kernel/sysctl.c-OVERCOMMIT linux/kernel/sysctl.c
--- linux/kernel/sysctl.c-OVERCOMMIT	2004-06-08 12:23:41.000000000 +0200
+++ linux/kernel/sysctl.c	2004-06-08 12:23:56.000000000 +0200
@@ -835,6 +835,14 @@
 		.mode		= 0644,
 		.proc_handler	= &hugetlb_sysctl_handler,
 	 },
+	{ 
+		.ctl_name = 999,
+		.procname = "overcommit_hugepages",
+		.data     = &sysctl_overcommit_hugepages,
+		.maxlen   = sizeof(int),
+		.mode     = 0644,
+		.proc_handler = &proc_dointvec,
+	},
 #endif
 	{
 		.ctl_name	= VM_LOWER_ZONE_PROTECTION,
diff -u linux/mm/policy.c-OVERCOMMIT linux/mm/policy.c
--- linux/mm/policy.c-OVERCOMMIT	2004-06-08 12:23:41.000000000 +0200
+++ linux/mm/policy.c	2004-06-08 17:57:10.000000000 +0200
@@ -258,7 +258,7 @@
 /* Step 1: check the range */
 static struct vm_area_struct *
 check_range(struct mm_struct *mm, unsigned long start, unsigned long end,
-	    unsigned long *nodes, unsigned long flags)
+	    unsigned long *nodes, unsigned long flags, struct mempolicy *pol)
 {
 	int err;
 	struct vm_area_struct *first, *vma, *prev;
@@ -279,6 +279,25 @@
 				break;
 			}
 		}
+		if (is_vm_hugetlb_page(vma) && 
+		    !sysctl_overcommit_hugepages &&
+		    pol && pol->policy == MPOL_BIND) { 
+			unsigned long rend = min_t(unsigned long, end, vma->vm_end);
+			unsigned long rstart = max_t(unsigned long,start,vma->vm_start);
+			unsigned long len; 
+
+			len = huge_pages_needed(vma->vm_file->f_mapping, vma,
+						rstart,	rend); 
+			if (len == 0)
+				;
+			else if (!__is_hugepage_mem_enough(pol, len)) { 
+				PDprintk("not enough huge pages (%d) (%d,%lx)\n",
+					 len/HPAGE_SIZE, 
+					 pol ? pol->policy : 0, 
+					 pol ? pol->v.nodes : 0); 
+				return ERR_PTR(-ENOMEM);
+			}
+		} 
 		prev = vma;
 	}
 	return first;
@@ -368,7 +387,7 @@
 			mode,nodes[0]);
 
 	down_write(&mm->mmap_sem);
-	vma = check_range(mm, start, end, nodes, flags);
+	vma = check_range(mm, start, end, nodes, flags, new);
 	err = PTR_ERR(vma);
 	if (!IS_ERR(vma))
 		err = mbind_range(vma, start, end, new);
