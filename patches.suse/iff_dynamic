#
# zap connection to dynamic IP addresses, if the interface goes down
# ported from 2.4 to 2.6 by Karsten Keil <kkeil@suse.de>
# Orignal author Andi Kleen <ak@suse.de>
#
diff -urN linux-2.6.3-30.ref/drivers/isdn/i4l/isdn_net.c linux-2.6.3-30.clean/drivers/isdn/i4l/isdn_net.c
--- linux-2.6.3-30.ref/drivers/isdn/i4l/isdn_net.c	2004-03-09 23:21:47.000000000 +0100
+++ linux-2.6.3-30.clean/drivers/isdn/i4l/isdn_net.c	2004-03-17 21:50:42.545493280 +0100
@@ -863,6 +863,8 @@
 		isdn_all_eaz(lp->isdn_device, lp->isdn_channel);
 	}
 	isdn_net_unbind_channel(lp);
+	if (!lp->master) /* never send this event to an slave device */
+		netdev_event(d, NETDEV_REBOOT);
 }
 
 typedef struct {
diff -urN linux-2.6.3-30.ref/include/linux/netdevice.h linux-2.6.3-30.clean/include/linux/netdevice.h
--- linux-2.6.3-30.ref/include/linux/netdevice.h	2004-03-09 23:22:03.000000000 +0100
+++ linux-2.6.3-30.clean/include/linux/netdevice.h	2004-03-16 23:25:46.000000000 +0100
@@ -923,6 +923,7 @@
 extern void		dev_set_promiscuity(struct net_device *dev, int inc);
 extern void		dev_set_allmulti(struct net_device *dev, int inc);
 extern void		netdev_state_change(struct net_device *dev);
+extern void		netdev_event(struct net_device *dev, int event);
 /* Load a device via the kmod */
 extern void		dev_load(const char *name);
 extern void		dev_mcast_init(void);
diff -urN linux-2.6.3-30.ref/include/net/tcp.h linux-2.6.3-30.clean/include/net/tcp.h
--- linux-2.6.3-30.ref/include/net/tcp.h	2004-03-09 23:22:00.000000000 +0100
+++ linux-2.6.3-30.clean/include/net/tcp.h	2004-03-16 23:25:46.000000000 +0100
@@ -835,6 +835,8 @@
 extern void			tcp_clear_retrans(struct tcp_opt *tp);
 extern void			tcp_update_metrics(struct sock *sk);
 
+extern void			tcp_reset(struct sock *sk); 
+
 extern void			tcp_close(struct sock *sk, 
 					  long timeout);
 extern struct sock *		tcp_accept(struct sock *sk, int flags, int *err);
diff -urN linux-2.6.3-30.ref/net/core/dev.c linux-2.6.3-30.clean/net/core/dev.c
--- linux-2.6.3-30.ref/net/core/dev.c	2004-03-09 23:21:22.000000000 +0100
+++ linux-2.6.3-30.clean/net/core/dev.c	2004-03-17 14:37:20.000000000 +0100
@@ -810,6 +810,78 @@
 	return 0;
 }
 
+struct dev_tq { 
+	struct work_struct	work;
+	struct net_device	*dev;
+	int			event;
+};
+
+static char *NetEvtStr[16] = {
+	"0000",
+	"up",
+	"down",
+	"reboot",
+	"change",
+	"register",
+	"unregister",
+	"change mtu",
+	"change addr",
+	"going down",
+	"change name",
+	"000B",
+	"000C",
+	"000D",
+	"000E",
+	"000F"
+};
+
+static void netdev_event_callback(void *data)
+{ 
+	struct dev_tq *tq = (struct dev_tq *) data;
+
+	if (0 == rtnl_shlock_nowait()) {
+		notifier_call_chain(&netdev_chain, tq->event, tq->dev);
+		rtnl_shunlock();
+	} else {
+		if (tq->dev->reg_state == NETREG_UNREGISTERED) {
+			printk(KERN_WARNING "%s: task for event %s canceled for device unregister\n",
+				__FUNCTION__, NetEvtStr[0xf & tq->event]);
+		} else {
+			schedule_delayed_work(&tq->work, 1);
+			return; 
+		}
+	}
+	dev_put(tq->dev);
+	kfree(tq);
+} 
+
+/**
+ *	netdev_event - send an event for a network device
+ *	@dev:	pointer to net device
+ *	@event:	event type
+ *
+ *	Send an event about a network device to clients in the stack.
+ *	Can be called from interrupt context.
+ *	Currently useful events:
+ *	NETDEV_REBOOT - A dial-on-demand device hung up.
+ */
+void netdev_event(struct net_device *dev, int event)
+{      
+	struct dev_tq *tq;
+	
+	if (dev->reg_state == NETREG_UNREGISTERED)
+		return;
+	tq = kmalloc(sizeof(*tq), GFP_ATOMIC);
+	if (!tq)
+		return;
+	memset(tq, 0, sizeof(*tq));
+	dev_hold(dev);
+	tq->dev = dev;
+	tq->event = event;
+	INIT_WORK(&tq->work, netdev_event_callback, tq);
+	schedule_work(&tq->work);
+}
+
 /**
  *	netdev_state_change - device changes state
  *	@dev: device to cause notification
@@ -3308,6 +3380,7 @@
 EXPORT_SYMBOL(register_gifconf);
 EXPORT_SYMBOL(register_netdevice);
 EXPORT_SYMBOL(register_netdevice_notifier);
+EXPORT_SYMBOL(netdev_event);
 EXPORT_SYMBOL(skb_checksum_help);
 EXPORT_SYMBOL(synchronize_net);
 EXPORT_SYMBOL(unregister_netdevice);
diff -urN linux-2.6.3-30.ref/net/ipv4/devinet.c linux-2.6.3-30.clean/net/ipv4/devinet.c
--- linux-2.6.3-30.ref/net/ipv4/devinet.c	2004-03-09 23:21:22.000000000 +0100
+++ linux-2.6.3-30.clean/net/ipv4/devinet.c	2004-03-17 17:31:24.254712992 +0100
@@ -992,6 +992,13 @@
 		devinet_sysctl_register(in_dev, &in_dev->cnf);
 #endif
 		break;
+	case NETDEV_REBOOT:
+		if (dev->flags & IFF_DYNAMIC ) { 
+			for_primary_ifa(in_dev) {
+				notifier_call_chain(&inetaddr_chain, NETDEV_REBOOT, ifa); 
+			} endfor_ifa(in_dev); 
+		}
+		break;
 	}
 out:
 	return NOTIFY_DONE;
diff -urN linux-2.6.3-30.ref/net/ipv4/tcp_input.c linux-2.6.3-30.clean/net/ipv4/tcp_input.c
--- linux-2.6.3-30.ref/net/ipv4/tcp_input.c	2004-03-09 23:21:22.000000000 +0100
+++ linux-2.6.3-30.clean/net/ipv4/tcp_input.c	2004-03-16 23:25:46.000000000 +0100
@@ -2592,7 +2592,7 @@
 }
 
 /* When we get a reset we do this. */
-static void tcp_reset(struct sock *sk)
+void tcp_reset(struct sock *sk)
 {
 	/* We want the right error as BSD sees it (and indeed as we do). */
 	switch (sk->sk_state) {
diff -urN linux-2.6.3-30.ref/net/ipv4/tcp_ipv4.c linux-2.6.3-30.clean/net/ipv4/tcp_ipv4.c
--- linux-2.6.3-30.ref/net/ipv4/tcp_ipv4.c	2004-03-09 23:21:23.000000000 +0100
+++ linux-2.6.3-30.clean/net/ipv4/tcp_ipv4.c	2004-03-17 15:20:45.000000000 +0100
@@ -2616,6 +2616,48 @@
 }
 #endif /* CONFIG_PROC_FS */
 
+static void tcpv4_zap_addr(__u32 addr) 
+{ 
+	int i;
+
+	for (i = 0; i < tcp_ehash_size; i++) { 
+		struct tcp_ehash_bucket *head = &tcp_ehash[i];
+		struct sock *sk;
+		struct hlist_node *node;
+		
+		/* O(n^2) on number of zapped sockets. hopefully there
+		   is only a small number of them. */
+	again:
+		read_lock(&head->lock); 
+		sk_for_each(sk, node, &head->chain) {
+			struct inet_opt *inet = inet_sk(sk);
+
+			if (sock_flag(sk, SOCK_DEAD))
+				continue;
+			if (sk->sk_err || sk->sk_zapped)
+				continue;
+			if (sk->sk_state == TCP_SYN_RECV)
+				continue;
+			if (sk->sk_state == TCP_SYN_SENT && sysctl_ip_dynaddr)
+				continue;
+			if (inet->rcv_saddr != addr)
+				continue;
+			printk(KERN_INFO 
+      "TCP: zapping lost address %d.%d.%d.%d:%d -> %d.%d.%d.%d:%d\n", 
+			       NIPQUAD(addr), ntohs(inet->sport), 
+			       NIPQUAD(inet->daddr), ntohs(inet->dport)); 
+			sock_hold(sk); 
+			read_unlock(&head->lock); 
+			lock_sock(sk);
+			tcp_reset(sk); 
+			release_sock(sk);
+			sock_put(sk); 
+			goto again; 
+		}		
+		read_unlock(&head->lock); 
+	}      
+} 
+
 struct proto tcp_prot = {
 	.name		=	"TCP",
 	.close		=	tcp_close,
@@ -2637,6 +2679,50 @@
 };
 
 
+/* 
+ * Gets told when a dynamic IP address vanishes.
+ * Runs under the RTNL semaphore.
+ */ 
+static int tcpv4_inetaddr_event(struct notifier_block *this, 
+				unsigned long event, 
+				void *ptr)
+{
+	struct in_ifaddr *ifa = (struct in_ifaddr *)ptr; 
+	struct in_device *idev; 
+	struct net_device *dev;
+
+	if (!(idev = ifa->ifa_dev) || !idev->dev || 
+	    !(idev->dev->flags & IFF_DYNAMIC))
+		return NOTIFY_DONE;
+
+	/* 
+	 * Don't do anything when the address still exists on another
+	 * interface.  Depends on running after the IP notifier.  
+	 */
+	if ((dev = ip_dev_find(ifa->ifa_local)) != NULL) { 
+		dev_put(dev);
+		return NOTIFY_DONE; 
+	} 
+
+	switch (event) { 
+	case NETDEV_REBOOT: 
+		if (!(idev->dev->flags & IFF_UP)) { 
+			printk(KERN_DEBUG "tcp_inetaddr_event: netdev_reboot: interface not up\n");
+			break; 
+		}
+		/*FALL THROUGH*/
+	case NETDEV_DOWN:
+		tcpv4_zap_addr(ifa->ifa_local);
+		break; 
+	}
+
+	return NOTIFY_DONE; 
+}
+
+static struct notifier_block tcpv4_inetaddr_notifier = {
+	.notifier_call	= tcpv4_inetaddr_event,
+	.priority	= -1,
+};
 
 void __init tcp_v4_init(struct net_proto_family *ops)
 {
@@ -2651,6 +2737,7 @@
 	 * packets.
 	 */
 	tcp_socket->sk->sk_prot->unhash(tcp_socket->sk);
+	register_inetaddr_notifier(&tcpv4_inetaddr_notifier);
 }
 
 EXPORT_SYMBOL(ipv4_specific);
