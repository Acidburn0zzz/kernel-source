From: Aurelien Aptel <aaptel@suse.com>
Date: Thu, 15 Nov 2018 17:44:12 +0100
Subject: [PATCH] cifs: Respect -EAGAIN when querying paths
References: FATE#325270
Patch-mainline: Submitted, linux-cifs 2018-11-15

After a successful reconnect, smb2_reconnect() will return -EAGAIN for
specific SMB2 commands (including queries) informing the caller to
retry the command.

This patch makes sure to retry them in possible reconnects.

Signed-off-by: Paulo Alcantara <palcantara@suse.de>
Signed-off-by: Aurelien Aptel <aaptel@suse.com>
Acked-by: Aurelien Aptel <aaptel@suse.com>
---
 fs/cifs/inode.c   |  7 +++++--
 fs/cifs/smb2ops.c | 22 +++++++++++++++++-----
 2 files changed, 22 insertions(+), 7 deletions(-)

diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index 9e5f0383962c..c61a03fe1982 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -752,8 +752,11 @@ cifs_get_inode_info(struct inode **inode, const char *full_path,
 			goto cgii_exit;
 		}
 		data = (FILE_ALL_INFO *)buf;
-		rc = server->ops->query_path_info(xid, tcon, cifs_sb, full_path,
-						  data, &adjust_tz, &symlink);
+		do {
+			rc = server->ops->query_path_info(xid, tcon, cifs_sb,
+							  full_path, data,
+							  &adjust_tz, &symlink);
+		} while (rc == -EAGAIN);
 	}
 
 	if (!rc) {
diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
index 388aef2c97fd..f9f98632512e 100644
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -979,8 +979,12 @@ smb2_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,
 	oparms.fid = fid;
 	oparms.reconnect = false;
 
-	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);
+	do {
+		rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL);
+	} while (rc == -EAGAIN);
+
 	kfree(utf16_path);
+
 	if (rc) {
 		cifs_dbg(FYI, "open dir failed rc=%d\n", rc);
 		return rc;
@@ -989,8 +993,11 @@ smb2_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,
 	srch_inf->entries_in_buffer = 0;
 	srch_inf->index_of_last_entry = 2;
 
-	rc = SMB2_query_directory(xid, tcon, fid->persistent_fid,
-				  fid->volatile_fid, 0, srch_inf);
+	do {
+		rc = SMB2_query_directory(xid, tcon, fid->persistent_fid,
+					  fid->volatile_fid, 0, srch_inf);
+	} while (rc == -EAGAIN);
+
 	if (rc) {
 		cifs_dbg(FYI, "query directory failed rc=%d\n", rc);
 		SMB2_close(xid, tcon, fid->persistent_fid, fid->volatile_fid);
@@ -1003,8 +1010,13 @@ smb2_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,
 		    struct cifs_fid *fid, __u16 search_flags,
 		    struct cifs_search_info *srch_inf)
 {
-	return SMB2_query_directory(xid, tcon, fid->persistent_fid,
-				    fid->volatile_fid, 0, srch_inf);
+	int rc;
+
+	do {
+		rc = SMB2_query_directory(xid, tcon, fid->persistent_fid,
+					  fid->volatile_fid, 0, srch_inf);
+	} while (rc == -EAGAIN);
+	return rc;
 }
 
 static int
-- 
2.13.7


