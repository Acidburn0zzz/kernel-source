From: Intel
Subject: IOAT DMA Driver
References: 142510

Acked-by: okir@suse.de

 drivers/dma/Kconfig        |   10 
 drivers/dma/cb_hw.h        |   68 ++++
 drivers/dma/cb_io.h        |  118 +++++++
 drivers/dma/cb_registers.h |  205 ++++++++++++
 drivers/dma/ioatdma.c      |  712 +++++++++++++++++++++++++++++++++++++++++++++
 drivers/dma/ioatdma.h      |  143 +++++++++
 6 files changed, 1256 insertions(+)

Index: build/drivers/dma/cb_hw.h
===================================================================
--- /dev/null
+++ build/drivers/dma/cb_hw.h
@@ -0,0 +1,68 @@
+#ifndef _CB_HW_H_
+#define _CB_HW_H_
+
+/* PCI Configuration Space Values */
+#define CB_PCI_VID					0x8086
+#define CB_PCI_DID					0x1A38
+#define CB_PCI_RID					0x00
+#define CB_PCI_SVID					0x8086
+#define CB_PCI_SID					0x8086
+
+/* MSI Capability */
+#define CB_PCI_MSICAPID					0x05
+
+/* PCI Express Capability */
+#define CB_PCI_EXPCAPID					0x10
+
+/* Power Management Capability */
+#define CB_PCI_PMCAPID					0x01
+
+#define CB_VER						0x12	/* Version 1.2 */
+
+struct cb_pci_pmcap_register {
+	uint32_t	capid:8;	/* RO: 01h */
+	uint32_t	nxtcapptr:8;
+	uint32_t	version:3;	/* RO: 010b */
+	uint32_t	pmeclk:1;	/* RO: 0b */
+	uint32_t	reserved:1;	/* RV: 0b */
+	uint32_t	dsi:1;		/* RO: 0b */
+	uint32_t	aux_current:3;	/* RO: 000b */
+	uint32_t	d1_support:1;	/* RO: 0b */
+	uint32_t	d2_support:1;	/* RO: 0b */
+	uint32_t	pme_support:5;	/* RO: 11001b */
+};
+
+struct cb_pci_pmcsr_register {
+	uint32_t	power_state:2;
+	uint32_t	reserved1:6;
+	uint32_t	pme_enable:1;
+	uint32_t	data_select:4;
+	uint32_t	data_scale:2;
+	uint32_t	pme_status:1;
+	uint32_t	reserved2:6;
+	uint32_t	b2_b3_support:1;
+	uint32_t	bus_pwr_clk_enable:1;
+	uint32_t	data:8;
+};
+
+struct cb_dma_descriptor {
+	uint32_t	size;
+	uint32_t	ctl;
+	uint64_t	src_addr;
+	uint64_t	dst_addr;
+	uint64_t	next;
+	uint64_t	rsv1;
+	uint64_t	rsv2;
+	uint64_t	user1;
+	uint64_t	user2;
+};
+
+#define CB_DMA_DESCRIPTOR_CTL_INT_GN		0x00000001
+#define CB_DMA_DESCRIPTOR_CTL_SRC_SN		0x00000002
+#define CB_DMA_DESCRIPTOR_CTL_DST_SN		0x00000004
+#define CB_DMA_DESCRIPTOR_CTL_CP_STS		0x00000008
+#define CB_DMA_DESCRIPTOR_CTL_FRAME		0x00000010
+#define CB_DMA_DESCRIPTOR_NUL			0x00000020
+#define CB_DMA_DESCRIPTOR_OPCODE		0xFF000000
+
+#endif
Index: build/drivers/dma/cb_io.h
===================================================================
--- /dev/null
+++ build/drivers/dma/cb_io.h
@@ -0,0 +1,118 @@
+/**********************************************************************
+**                                                                   **
+**                I N T E L   P R O P R I E T A R Y                  **
+**                                                                   **
+**   COPYRIGHT (c) 2004 - 2005  BY  INTEL  CORPORATION.  ALL         **
+**   RIGHTS RESERVED.   NO PART OF THIS PROGRAM OR PUBLICATION MAY   **
+**   BE  REPRODUCED,   TRANSMITTED,   TRANSCRIBED,   STORED  IN  A   **
+**   RETRIEVAL SYSTEM, OR TRANSLATED INTO ANY LANGUAGE OR COMPUTER   **
+**   LANGUAGE IN ANY FORM OR BY ANY MEANS, ELECTRONIC, MECHANICAL,   **
+**   MAGNETIC,  OPTICAL,  CHEMICAL, MANUAL, OR OTHERWISE,  WITHOUT   **
+**   THE PRIOR WRITTEN PERMISSION OF :                               **
+**                                                                   **
+**                      INTEL  CORPORATION                           **
+**                                                                   **
+**                2200 MISSION COLLEGE BOULEVARD                     **
+**                                                                   **
+**             SANTA  CLARA,  CALIFORNIA  95052-8119                 **
+**                                                                   **
+**********************************************************************/
+
+/**********************************************************************
+**                                                                   **
+** INTEL CORPORATION PROPRIETARY INFORMATION                         **
+** This software is supplied under the terms of a license agreement  **
+** with Intel Corporation and may not be copied nor disclosed        **
+** except in accordance with the terms of that agreement.            **
+**                                                                   **
+** Module Name:                                                      **
+**   cb_io.h                                                         **
+**                                                                   **
+** Abstract:                                                         **
+**                                                                   **
+**********************************************************************/
+
+#ifndef CB_IO_H
+#define CB_IO_H
+
+#include <asm/io.h>
+
+/*
+ * device and per-channel MMIO register read and write functions
+ * this is a lot of anoying inline functions, but it's typesafe
+ */
+
+static inline u8 read_reg8(struct cb_device *device, unsigned int offset)
+{
+	return readb(device->reg_base + offset);
+}
+
+static inline u16 read_reg16(struct cb_device *device, unsigned int offset)
+{
+	return readw(device->reg_base + offset);
+}
+
+static inline u32 read_reg32(struct cb_device *device, unsigned int offset)
+{
+	return readl(device->reg_base + offset);
+}
+
+static inline void write_reg8(struct cb_device *device, unsigned int offset, u8 value)
+{
+	writeb(value, device->reg_base + offset);
+}
+
+static inline void write_reg16(struct cb_device *device, unsigned int offset, u16 value)
+{
+	writew(value, device->reg_base + offset);
+}
+
+static inline void write_reg32(struct cb_device *device, unsigned int offset, u32 value)
+{
+	writel(value, device->reg_base + offset);
+}
+
+static inline u8 chan_read_reg8(struct cb_dma_chan *chan, unsigned int offset)
+{
+	return readb(chan->reg_base + offset);
+}
+
+static inline u16 chan_read_reg16(struct cb_dma_chan *chan, unsigned int offset)
+{
+	return readw(chan->reg_base + offset);
+}
+
+static inline u32 chan_read_reg32(struct cb_dma_chan *chan, unsigned int offset)
+{
+	return readl(chan->reg_base + offset);
+}
+
+static inline void chan_write_reg8(struct cb_dma_chan *chan, unsigned int offset, u8 value)
+{
+	writeb(value, chan->reg_base + offset);
+}
+
+static inline void chan_write_reg16(struct cb_dma_chan *chan, unsigned int offset, u16 value)
+{
+	writew(value, chan->reg_base + offset);
+}
+
+static inline void chan_write_reg32(struct cb_dma_chan *chan, unsigned int offset, u32 value)
+{
+	writel(value, chan->reg_base + offset);
+}
+
+#if (BITS_PER_LONG == 64)
+static inline u64 chan_read_reg64(struct cb_dma_chan *chan, unsigned int offset)
+{
+	return readq(chan->reg_base + offset);
+}
+
+static inline void chan_write_reg64(struct cb_dma_chan *chan, unsigned int offset, u64 value)
+{
+	writeq(value, chan->reg_base + offset);
+}
+#endif
+
+#endif /* CB_IO_H */
+
Index: build/drivers/dma/cb_registers.h
===================================================================
--- /dev/null
+++ build/drivers/dma/cb_registers.h
@@ -0,0 +1,205 @@
+
+#ifndef _CB_REGISTERS_H_
+#define _CB_REGISTERS_H_
+
+#define CB_PCI_DMACTRL_OFFSET				0x48
+#define CB_PCI_DMACTRL_DMA_EN				0x00000001
+#define CB_PCI_DMACTRL_MSI_EN				0x00000002
+
+/* BNB DMA MMIO Device Registers */
+#define CB_CHANCNT_OFFSET				0x00	/*  8-bit */
+
+#define CB_XFERCAP_OFFSET				0x01	/*  8-bit */
+#define CB_XFERCAP_4KB					12
+#define CB_XFERCAP_8KB					13
+#define CB_XFERCAP_16KB					14
+#define CB_XFERCAP_32KB					15
+#define CB_XFERCAP_32GB					0
+
+#define CB_GENCTRL_OFFSET				0x02	/*  8-bit */
+#define CB_GENCTRL_DEBUG_EN				0x01
+
+#define CB_INTRCTRL_OFFSET				0x03	/*  8-bit */
+#define CB_INTRCTRL_MASTER_INT_EN			0x01	/* Master Interrupt Enable */
+#define CB_INTRCTRL_INT_STATUS				0x02	/* ATTNSTATUS -or- Channel Int */
+#define CB_INTRCTRL_INT					0x04	/* INT_STATUS -and- MASTER_INT_EN */
+
+#define CB_ATTNSTATUS_OFFSET				0x04	/* Each bit is a channel */
+
+#define CB_VER_OFFSET					0x08	/*  8-bit */
+#define CB_VER_MAJOR_MASK				0xF0
+#define CB_VER_MINOR_MASK				0x0F
+#define GET_CB_VER_MAJOR(x)				((x) & CB_VER_MAJOR_MASK)
+#define GET_CB_VER_MINOR(x)				((x) & CB_VER_MINOR_MASK)
+
+#define CB_PERPORTOFFSET_OFFSET				0x0A	/* 16-bit */
+
+#define CB_INTRDELAY_OFFSET				0x0C	/* 16-bit */
+#define CB_INTRDELAY_INT_DELAY_MASK			0x3FFF	/* Interrupt Delay Time */
+#define CB_INTRDELAY_COALESE_SUPPORT			0x8000	/* Interrupt Coalesing Supported */
+
+#define CB_DEVICE_STATUS_OFFSET				0x0E	/* 16-bit */
+#define CB_DEVICE_STATUS_DEGRADED_MODE			0x0001
+
+#define CB_DBG_CHAN_SYSERR_MSK0_OFFSET			0x40
+#define CB_DBG_CHAN_SYSERR_MSK1_OFFSET			0x44
+#define CB_DBG_CHAN_SYSERR_MSK2_OFFSET			0x48
+#define CB_DBG_CHAN_SYSERR_MSK3_OFFSET			0x4C
+
+#define CB_DBG_DCA_REQID2_OFFSET			0x54
+#define CB_DBG_DCA_CTRL2_OFFSET				0x56
+#define CB_DBG_DCA_REQID3_OFFSET			0x58
+#define CB_DBG_DCA_CTRL3_OFFSET				0x5A
+#define CB_DBG_DCA_REQID4_OFFSET			0x5C
+#define CB_DBG_DCA_CTRL4_OFFSET				0x5E
+#define CB_DBG_DCA_REQID5_OFFSET			0x60
+#define CB_DBG_DCA_CTRL5_OFFSET				0x62
+#define CB_DBG_DCA_REQID6_OFFSET			0x64
+#define CB_DBG_DCA_CTRL6_OFFSET				0x66
+#define CB_DBG_DCA_REQID7_OFFSET			0x68
+#define CB_DBG_DCA_CTRL7_OFFSET				0x6A
+
+#define CB_DBG_DCA_CTRL_IGN_DCA_FN_NUM			0x01
+#define CB_DBG_DCA_REQID_INVALID			0x0000
+
+
+#define CB_CHANNEL_MMIO_SIZE				0x80	/* Each Channel MMIO space is this size */
+
+/* BNB DMA Channel Registers */
+#define CB_CHANCTRL_OFFSET				0x00	/* 16-bit Channel Control Register */
+#define CB_CHANCTRL_CHANNEL_PRIORITY_MASK		0xF000
+#define CB_CHANCTRL_CHANNEL_IN_USE			0x0100
+#define CB_CHANCTRL_DESCRIPTOR_ADDR_SNOOP_CONTROL	0x0020
+#define CB_CHANCTRL_ERR_INT_EN				0x0010
+#define CB_CHANCTRL_ANY_ERR_ABORT_EN			0x0008
+#define CB_CHANCTRL_ERR_COMPLETION_EN			0x0004
+#define CB_CHANCTRL_INT_DISABLE				0x0001
+
+#define CB_DMA_COMP_OFFSET				0x02	/* 16-bit DMA channel compatability */
+#define CB_DMA_COMP_V1					0x0001	/* Compatability with DMA version 1 */
+
+#define CB_CHANSTS_OFFSET				0x04	/* 64-bit Channel Status Register */
+#define CB_CHANSTS_OFFSET_LOW				0x04
+#define CB_CHANSTS_OFFSET_HIGH				0x08
+#define CB_CHANSTS_COMPLETED_DESCRIPTOR_ADDR		0xFFFFFFFFFFFFFFC0
+#define CB_CHANSTS_SOFT_ERR				0x0000000000000010
+#define CB_CHANSTS_UNAFFILIATED_ERR			0x0000000000000008
+#define CB_CHANSTS_DMA_TRANSFER_STATUS			0x0000000000000007
+#define CB_CHANSTS_DMA_TRANSFER_STATUS_ACTIVE		0x0
+#define CB_CHANSTS_DMA_TRANSFER_STATUS_DONE		0x1
+#define CB_CHANSTS_DMA_TRANSFER_STATUS_SUSPENDED	0x2
+#define CB_CHANSTS_DMA_TRANSFER_STATUS_HALTED		0x3
+
+#define CB_CHAINADDR_OFFSET				0x0C	/* 64-bit Descriptor Chain Address Register */
+#define CB_CHAINADDR_OFFSET_LOW				0x0C
+#define CB_CHAINADDR_OFFSET_HIGH			0x10
+
+#define CB_CHANCMD_OFFSET				0x14	/*  8-bit DMA Channel Command Register */
+#define CB_CHANCMD_RESET				0x20
+#define CB_CHANCMD_RESUME				0x10
+#define CB_CHANCMD_ABORT				0x08
+#define CB_CHANCMD_SUSPEND				0x04
+#define CB_CHANCMD_APPEND				0x02
+#define CB_CHANCMD_START				0x01
+
+#define CB_CHANCMP_OFFSET				0x18	/* 64-bit Channel Completion Address Register */
+#define CB_CHANCMP_OFFSET_LOW				0x18
+#define CB_CHANCMP_OFFSET_HIGH				0x1C
+
+#define CB_CDAR_OFFSET					0x20	/* 64-bit Current Descriptor Address Register */
+#define CB_CDAR_OFFSET_LOW				0x20
+#define CB_CDAR_OFFSET_HIGH				0x24
+
+#define CB_CHANERR_OFFSET				0x28	/* 32-bit Channel Error Register */
+#define CB_CHANERR_DMA_TRANSFER_SRC_ADDR_ERR		0x0001
+#define CB_CHANERR_DMA_TRANSFER_DEST_ADDR_ERR		0x0002
+#define CB_CHANERR_NEXT_DESCRIPTOR_ADDR_ERR		0x0004
+#define CB_CHANERR_NEXT_DESCRIPTOR_ALIGNMENT_ERR	0x0008
+#define CB_CHANERR_CHAIN_ADDR_VALUE_ERR			0x0010
+#define CB_CHANERR_CHANCMD_ERR				0x0020
+#define CB_CHANERR_CHIPSET_UNCORRECTABLE_DATA_INTEGRITY_ERR	0x0040
+#define CB_CHANERR_DMA_UNCORRECTABLE_DATA_INTEGRITY_ERR	0x0080
+#define CB_CHANERR_READ_DATA_ERR			0x0100
+#define CB_CHANERR_WRITE_DATA_ERR			0x0200
+#define CB_CHANERR_DESCRIPTOR_CONTROL_ERR		0x0400
+#define CB_CHANERR_DESCRIPTOR_LENGTH_ERR		0x0800
+#define CB_CHANERR_COMPLETION_ADDR_ERR			0x1000
+#define CB_CHANERR_INT_CONFIGURATION_ERR		0x2000
+#define CB_CHANERR_SOFT_ERR				0x4000
+#define CB_CHANERR_UNAFFILIATED_ERR			0x8000
+
+#define CB_CHANERR_MASK_OFFSET				0x2C	/* 32-bit Channel Error Register */
+
+/* Per-PCI Express Port Registers */
+#define CB_NXTPPRSET_OFFSET				0x00	/* 16-bit Next Per-Port Register Set */
+
+#define CB_PPRSETLEN_OFFSET				0x02	/* 8-bit Per-Port Register Set Length */
+
+#define CB_STRMPRI_OFFSET				0x03	/* 8-bit Stream Priority Register */
+#define CB_STRMPRI_HIGHEST_PRIORITY_SUPPORTED		0xF0
+#define CB_STRMPRI_DEFAULT_STREAM_PRIORITY		0x0F
+
+#define CB_REQID_OFFSET					0x04	/* 16-bit Requester ID Register */
+#define CB_REQID_BUS					0xFF00
+#define CB_REQID_DEVICE					0x00F8
+#define CB_REQID_FUNCTION				0x0007
+
+#define CB_STRMIDFMT_OFFSET				0x06	/* 8-bit Stream ID Format */
+#define CB_STRMIFFMT_IN_USE				0x80
+#define CB_STRMIFFMT_IGNORE_FUNCTION			0x10
+#define CB_STRMIFFMT_FUNCTION_FIELD_SIZE		0x0C
+#define CB_STRMIFFMT_TAG_FIELD_SIZE			0x03
+
+#define CB_STRMCAP_OFFSET				0x07	/* 8-bit Stream Capacity */
+
+#define CB_WCNUM_OFFSET					0x08	/* 8-bit Write Combining Number */
+
+#define CB_WCSIZE_OFFSET				0x09	/* 8-bit Write Combining Size */
+#define CB_WCSIZE_1KB					1
+#define CB_WCSIZE_2KB					2
+#define CB_WCSIZE_4KB					3
+#define CB_WCSIZE_8KB					4
+
+#define CB_WCCTRL_OFFSET				0x0A	/* 16-bit Write Combining Control */
+#define CB_WCCTRL_IN_USE				0x0100
+#define CB_WCCTRL_WINDOW_CLEAR				0x0002
+#define CB_WCCTRL_WINDOW_FLUSH				0x0001
+
+#define CB_WCCAP_OFFSET					0x0C	/* 8-bit Write Combining Capacity */
+
+#define CB_WCWINDOW_OFFSET				0x0D	/* 8-bit Write Combining Window Size */
+#define CB_WCWINDOW_64B					1
+#define CB_WCWINDOW_128B				2
+#define CB_WCWINDOW_256B				4
+
+#define CB_BRIDGE_ID_OFFSET				0x0E	/* 16-bit Bridge ID */
+#define CB_BRIDGE_ID_BUS				0xFF00
+#define CB_BRIDGE_ID_DEVICE				0x00F8
+#define CB_BRIDGE_ID_FUNCTION				0x0007
+
+#define CB_WCBASE_OFFSET				0x10	/* 64-bit Write Combining Base Address */
+#define CB_WCBASE_OFFSET_LOW				0x10
+#define CB_WCBASE_OFFSET_HIGH				0x14
+
+#define CB_STRMMAP_OFFSET_OFFSET			0x18	/* 16-bit Stream Priority Mapping Offset */
+/* At CB_BAR + CB_STRMMAP_OFFSET is the STRMMAP array of 4-bit Stream Priority Values */
+
+#define CB_PORTPRI_OFFSET				0x1A	/* 8-bit Port Priority */
+
+#define CB_STRM_COMP_OFFSET				0x1C	/* 16-bit Stream Priority Compatability */
+#define CB_STRM_COMP_V1					0x0001
+#define CB_WC_COMP_OFFSET				0x1E	/* 16-bit Write Combining Compatability */
+#define CB_WC_COMP_V1					0x0001
+
+#define CB_BR_MEM_BASE_OFFSET				0x20	/* 16-bit Bridge Memory Base */
+#define CB_BR_MEM_LIMIT_OFFSET				0x22	/* 16-bit Bridge Memory Limit */
+#define CB_BR_PMEM_BASE_OFFSET				0x24	/* 16-bit Bridge Prefetchable Memory Base */
+#define CB_BR_PMEM_LIMIT_OFFSET				0x26	/* 16-bit Bridge Prefetchable Memory Limit */
+#define CB_BR_PBASE_UPPER32_OFFSET			0x28	/* 32-bit Bridge Prefetchable Base Upper 32 */
+#define CB_BR_PLIMIT_UPPER32_OFFSET			0x2C	/* 32-bit Bridge Prefetchable Limit Upper 32 */
+
+#define CB_DOORBELL_SNOOP_ADDR0_OFFSET			0x40	/* 64-bit Doorbell Snoop Address for WC Region 0 */
+#define CB_DOORBELL_SNOOP_ADDR0_OFFSET_LOW		0x40
+#define CB_DOORBELL_SNOOP_ADDR0_OFFSET_HIGH		0x44
+
+#endif /* _CB_REGISTERS_H_ */
Index: build/drivers/dma/ioatdma.c
===================================================================
--- /dev/null
+++ build/drivers/dma/ioatdma.c
@@ -0,0 +1,712 @@
+/**********************************************************************
+**                                                                   **
+**                I N T E L   P R O P R I E T A R Y                  **
+**                                                                   **
+**   COPYRIGHT (c) 2004 - 2005  BY  INTEL  CORPORATION.  ALL         **
+**   RIGHTS RESERVED.   NO PART OF THIS PROGRAM OR PUBLICATION MAY   **
+**   BE  REPRODUCED,   TRANSMITTED,   TRANSCRIBED,   STORED  IN  A   **
+**   RETRIEVAL SYSTEM, OR TRANSLATED INTO ANY LANGUAGE OR COMPUTER   **
+**   LANGUAGE IN ANY FORM OR BY ANY MEANS, ELECTRONIC, MECHANICAL,   **
+**   MAGNETIC,  OPTICAL,  CHEMICAL, MANUAL, OR OTHERWISE,  WITHOUT   **
+**   THE PRIOR WRITTEN PERMISSION OF :                               **
+**                                                                   **
+**                      INTEL  CORPORATION                           **
+**                                                                   **
+**                2200 MISSION COLLEGE BOULEVARD                     **
+**                                                                   **
+**             SANTA  CLARA,  CALIFORNIA  95052-8119                 **
+**                                                                   **
+**********************************************************************/
+
+/**********************************************************************
+**                                                                   **
+** INTEL CORPORATION PROPRIETARY INFORMATION                         **
+** This software is supplied under the terms of a license agreement  **
+** with Intel Corporation and may not be copied nor disclosed        **
+** except in accordance with the terms of that agreement.            **
+**                                                                   **
+** Module Name:                                                      **
+**   ioatdma.c
+**                                                                   **
+** Abstract:                                                         **
+**                                                                   **
+**********************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/dmaengine.h>
+#include "ioatdma.h"
+#include "cb_io.h"
+#include "cb_registers.h"
+#include "cb_hw.h"
+
+#define to_cb_chan(chan) container_of(chan, struct cb_dma_chan, common)
+#define to_cb_device(dev) container_of(dev, struct cb_device, common)
+#define to_cb_desc(lh) container_of(lh, struct cb_desc_sw, node)
+
+/* internal functions */
+static int __devinit cb_probe(struct pci_dev *pdev, const struct pci_device_id *ent);
+static void __devexit cb_remove(struct pci_dev *pdev);
+
+static int enumerate_dma_channels(struct cb_device *device)
+{
+	u8 xfercap_scale;
+	u32 xfercap;
+	int i;
+	struct cb_dma_chan *cb_chan;
+
+	device->common.chancnt = read_reg8(device, CB_CHANCNT_OFFSET);
+	xfercap_scale = read_reg8(device, CB_XFERCAP_OFFSET);
+	xfercap = (xfercap_scale == 0 ? ~0UL : (1 << xfercap_scale));
+
+	for (i = 0; i < device->common.chancnt; i++) {
+		cb_chan = kmalloc(sizeof(*cb_chan), GFP_KERNEL);
+		if (!cb_chan)
+			return -ENOMEM;
+		memset(cb_chan, 0, sizeof(*cb_chan));
+
+		cb_chan->device = device;
+		cb_chan->common.device = &device->common;
+		cb_chan->common.client = NULL;
+		cb_chan->reg_base = device->reg_base + (0x80 * (i + 1));
+		cb_chan->xfercap = xfercap;
+		spin_lock_init(&cb_chan->cleanup_lock);
+		spin_lock_init(&cb_chan->desc_lock);
+		INIT_LIST_HEAD(&cb_chan->free_desc);
+		INIT_LIST_HEAD(&cb_chan->used_desc);
+		list_add_tail(&cb_chan->common.device_node, &device->common.channels);
+		device->idx[i] = cb_chan;
+	}
+
+	return 0;
+}
+
+static struct cb_desc_sw * cb_dma_alloc_descriptor(struct cb_dma_chan *cb_chan)
+{
+	struct cb_dma_descriptor *desc;
+	struct cb_desc_sw *desc_sw;
+	struct cb_device *cb_device = to_cb_device(cb_chan->common.device);
+	dma_addr_t phys;
+
+	desc = dma_pool_alloc(cb_device->dma_pool, GFP_ATOMIC, &phys);
+	if (!desc)
+		return NULL;
+
+	desc_sw = kmalloc(sizeof(*desc_sw), GFP_ATOMIC);
+
+	if (!desc_sw) {
+		dma_pool_free(cb_device->dma_pool, desc, phys);
+		return NULL;
+	}
+
+	memset(desc, 0, sizeof(*desc));
+	memset(desc_sw, 0, sizeof(*desc_sw));
+	desc_sw->hw = desc;
+	desc_sw->phys = phys;
+
+	return desc_sw;
+}
+
+#define INITIAL_CB_DESC_COUNT 32
+
+static void cb_start_null_desc(struct cb_dma_chan *cb_chan);
+
+/* returns the actual number of allocated descriptors */
+static int cb_dma_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct cb_dma_chan *cb_chan = to_cb_chan(chan);
+	struct cb_desc_sw *desc = NULL;
+	u16 chanctrl;
+	u32 chanerr;
+	int i;
+
+	/*
+	 * In-use bit automatically set by reading chanctrl
+	 * If 0, we got it, if 1, someone else did
+	 */
+	chanctrl = chan_read_reg16(cb_chan, CB_CHANCTRL_OFFSET);
+	if (chanctrl & CB_CHANCTRL_CHANNEL_IN_USE)
+		return -EBUSY;
+
+        /* Setup register to interrupt and write completion status on error */
+	chanctrl = CB_CHANCTRL_CHANNEL_IN_USE |
+		CB_CHANCTRL_ERR_INT_EN |
+		CB_CHANCTRL_ANY_ERR_ABORT_EN |
+		CB_CHANCTRL_ERR_COMPLETION_EN;
+        chan_write_reg16(cb_chan, CB_CHANCTRL_OFFSET, chanctrl);
+
+	chanerr = chan_read_reg32(cb_chan, CB_CHANERR_OFFSET);
+	if (chanerr) {
+		printk("CB: CHANERR = %x, clearing\n", chanerr);
+		chan_write_reg32(cb_chan, CB_CHANERR_OFFSET, chanerr);
+	}
+
+	/* Allocate descriptors */
+	spin_lock_bh(&cb_chan->desc_lock);
+	for (i = 0; i < INITIAL_CB_DESC_COUNT; i++) {
+		desc = cb_dma_alloc_descriptor(cb_chan);
+		if (!desc) {
+			printk(KERN_ERR "CB: Only %d initial descriptors\n", i);
+			break;
+		}
+		list_add_tail(&desc->node, &cb_chan->free_desc);
+	}
+	spin_unlock_bh(&cb_chan->desc_lock);
+
+	/* TODO - need to stop using virt_to_bus */
+	/* allocate a completion writeback area with pci_alloc_conststent? */
+	/* doing 2 32bit writes to mmio since 1 64b write doesn't work */
+	chan_write_reg32(cb_chan, CB_CHANCMP_OFFSET_LOW,
+		(u64) virt_to_bus(&cb_chan->completion) & 0xFFFFFFFF);
+	chan_write_reg32(cb_chan, CB_CHANCMP_OFFSET_HIGH,
+		(u64) virt_to_bus(&cb_chan->completion) >> 32);
+
+	cb_start_null_desc(cb_chan);
+
+	return i;
+}
+
+static void cb_dma_memcpy_cleanup(struct cb_dma_chan *cb_chan);
+
+static void cb_dma_free_chan_resources(struct dma_chan *chan)
+{
+	struct cb_dma_chan *cb_chan = to_cb_chan(chan);
+	struct cb_device *cb_device = to_cb_device(chan->device);
+	struct cb_desc_sw *desc, *_desc;
+	u16 chanctrl;
+	int in_use_descs = 0;
+
+	cb_dma_memcpy_cleanup(cb_chan);
+
+	chan_write_reg8(cb_chan, CB_CHANCMD_OFFSET, CB_CHANCMD_RESET);
+
+	spin_lock_bh(&cb_chan->desc_lock);
+	list_for_each_entry_safe(desc, _desc, &cb_chan->used_desc, node) {
+		in_use_descs++;
+		list_del(&desc->node);
+		dma_pool_free(cb_device->dma_pool, desc->hw, desc->phys);
+		kfree(desc);
+	}
+	list_for_each_entry_safe(desc, _desc, &cb_chan->free_desc, node) {
+		list_del(&desc->node);
+		dma_pool_free(cb_device->dma_pool, desc->hw, desc->phys);
+		kfree(desc);
+	}
+	spin_unlock_bh(&cb_chan->desc_lock);
+
+	/* one is ok since we left it on there on purpose */
+	if (in_use_descs > 1)
+		printk(KERN_ERR "CB: Freeing %d in use descriptors!\n",
+			in_use_descs - 1);
+
+	cb_chan->last_completion = cb_chan->completion = 0;
+
+	/* Tell hw the chan is free */
+	chanctrl = chan_read_reg16(cb_chan, CB_CHANCTRL_OFFSET);
+	chanctrl &= ~CB_CHANCTRL_CHANNEL_IN_USE;
+	chan_write_reg16(cb_chan, CB_CHANCTRL_OFFSET, chanctrl);
+}
+
+/**
+ * do_cb_dma_memcpy - actual function that initiates a CB DMA transaction
+ * @chan: CB DMA channel handle
+ * @dest: DMA destination address
+ * @src: DMA source address
+ * @len: transaction length in bytes
+ */
+
+static dma_cookie_t do_cb_dma_memcpy( struct cb_dma_chan *cb_chan, dma_addr_t dest, dma_addr_t src, size_t len)
+{
+	struct cb_desc_sw *first;
+	struct cb_desc_sw *prev;
+	struct cb_desc_sw *new;
+	dma_cookie_t cookie;
+	LIST_HEAD(new_chain);
+	u32 copy;
+	size_t orig_len;
+	dma_addr_t orig_src, orig_dst;
+	unsigned int desc_count = 0;
+	unsigned int append = 0;
+
+	if (!cb_chan || !dest || !src)
+		return -EFAULT;
+
+	if (!len)
+		return cb_chan->common.cookie;
+
+	orig_len = len;
+	orig_src = src;
+	orig_dst = dest;
+
+	first = NULL;
+	prev = NULL;
+
+	spin_lock_bh(&cb_chan->desc_lock);
+
+	while (len) {
+		if (!list_empty(&cb_chan->free_desc)) {
+			new = to_cb_desc(cb_chan->free_desc.next);
+			list_del(&new->node);
+		} else {
+			/* try to get another desc */
+			new = cb_dma_alloc_descriptor(cb_chan);
+			/* will this ever happen? */
+			/* TODO add upper limit on these */
+			BUG_ON(!new);
+		}
+
+		copy = min((u32) len, cb_chan->xfercap);
+
+		new->hw->size = copy;
+		new->hw->ctl = 0;
+		new->hw->src_addr = src;
+		new->hw->dst_addr = dest;
+		new->cookie = 0;
+
+		/* chain together the physical address list for the HW */
+		if (!first)
+			first = new;
+		else
+			prev->hw->next = (u64) new->phys;
+
+		prev = new;
+
+		len  -= copy;
+		dest += copy;
+		src  += copy;
+
+		list_add_tail(&new->node, &new_chain);
+		desc_count++;
+	}
+	new->hw->ctl = CB_DMA_DESCRIPTOR_CTL_CP_STS;
+	new->hw->next = 0;
+
+	/* cookie incr and addition to used_list must be atomic */
+
+	cookie = cb_chan->common.cookie;
+	cookie++;
+	if (cookie < 0)
+		cookie = 1;
+	cb_chan->common.cookie = new->cookie = cookie;
+
+	pci_unmap_addr_set(new, src, orig_src);
+	pci_unmap_addr_set(new, dst, orig_dst);
+	pci_unmap_len_set(new, src_len, orig_len);
+	pci_unmap_len_set(new, dst_len, orig_len);
+
+	/* write address into NextDescriptor field of last desc in chain */
+	to_cb_desc(cb_chan->used_desc.prev)->hw->next = first->phys;
+	list_splice_init(&new_chain, cb_chan->used_desc.prev);
+
+	cb_chan->pending += desc_count;
+	if (cb_chan->pending >= 20) {
+		append = 1;
+		cb_chan->pending = 0;
+	}
+
+	spin_unlock_bh(&cb_chan->desc_lock);
+
+	if (append)
+		chan_write_reg8(cb_chan, CB_CHANCMD_OFFSET, CB_CHANCMD_APPEND);
+
+	return cookie;
+}
+
+/**
+ * cb_dma_memcpy_buf_to_buf - wrapper that takes src & dest bufs
+ * @chan: CB DMA channel handle
+ * @dest: DMA destination address
+ * @src: DMA source address
+ * @len: transaction length in bytes
+ */
+
+static dma_cookie_t cb_dma_memcpy_buf_to_buf( struct dma_chan *chan, void *dest, void *src, size_t len)
+{
+	dma_addr_t dest_addr;
+	dma_addr_t src_addr;
+	struct cb_dma_chan *cb_chan = to_cb_chan(chan);
+
+	dest_addr = pci_map_single(cb_chan->device->pdev,
+		dest, len, PCI_DMA_FROMDEVICE);
+	src_addr = pci_map_single(cb_chan->device->pdev,
+		src, len, PCI_DMA_TODEVICE);
+
+	return do_cb_dma_memcpy(cb_chan, dest_addr, src_addr, len);
+}
+
+/**
+ * cb_dma_memcpy_buf_to_pg - wrapper, copying from a buf to a page
+ * @chan: CB DMA channel handle
+ * @page: pointer to the page to copy to
+ * @offset: offset into that page
+ * @src: DMA source address
+ * @len: transaction length in bytes
+ */
+
+static dma_cookie_t cb_dma_memcpy_buf_to_pg( struct dma_chan *chan, struct page *page, unsigned int offset, void *src, size_t len)
+{
+	dma_addr_t dest_addr;
+	dma_addr_t src_addr;
+	struct cb_dma_chan *cb_chan = to_cb_chan(chan);
+
+	dest_addr = pci_map_page(cb_chan->device->pdev,
+		page, offset, len, PCI_DMA_FROMDEVICE);
+	src_addr = pci_map_single(cb_chan->device->pdev,
+		src, len, PCI_DMA_TODEVICE);
+
+	return do_cb_dma_memcpy(cb_chan, dest_addr, src_addr, len);
+}
+
+/**
+ * cb_dma_memcpy_pg_to_pg - wrapper, copying between two pages
+ * @chan: CB DMA channel handle
+ * @dest_pg: pointer to the page to copy to
+ * @dest_off: offset into that page
+ * @src_pg: pointer to the page to copy from
+ * @src_off: offset into that page
+ * @len: transaction length in bytes. This is guaranteed to not make a copy
+ *	 across a page boundary.
+ */
+
+static dma_cookie_t cb_dma_memcpy_pg_to_pg( struct dma_chan *chan, struct page *dest_pg, unsigned int dest_off, struct page *src_pg, unsigned int src_off, size_t len)
+{
+	dma_addr_t dest_addr;
+	dma_addr_t src_addr;
+	struct cb_dma_chan *cb_chan = to_cb_chan(chan);
+
+	dest_addr = pci_map_page(cb_chan->device->pdev,
+		dest_pg, dest_off, len, PCI_DMA_FROMDEVICE);
+	src_addr = pci_map_page(cb_chan->device->pdev,
+		src_pg, src_off, len, PCI_DMA_TODEVICE);
+
+	return do_cb_dma_memcpy(cb_chan, dest_addr, src_addr, len);
+}
+
+/**
+ * cb_dma_memcpy_issue_pending - push potentially unrecognoized appended descriptors to hw
+ * @chan: DMA channel handle
+ */
+
+static void cb_dma_memcpy_issue_pending(struct dma_chan *chan)
+{
+	struct cb_dma_chan *cb_chan = to_cb_chan(chan);
+
+	if (cb_chan->pending != 0) {
+		cb_chan->pending = 0;
+		chan_write_reg8(cb_chan, CB_CHANCMD_OFFSET, CB_CHANCMD_APPEND);
+	}
+}
+
+static void cb_dma_memcpy_cleanup(struct cb_dma_chan *chan)
+{
+	unsigned long phys_complete;
+	struct cb_desc_sw *desc, *_desc;
+	dma_cookie_t cookie = 0;
+
+	prefetch(&chan->completion);
+
+	if (!spin_trylock(&chan->cleanup_lock))
+		return;
+
+	/* The completion writeback can happen at any time,
+	   so reads by the driver need to be atomic operations
+	   The descriptor physical addresses are limited to 32-bits
+	   when the CPU can only do a 32-bit mov */
+
+#if (BITS_PER_LONG == 64)
+	phys_complete = chan->completion & CB_CHANSTS_COMPLETED_DESCRIPTOR_ADDR;
+#else
+	phys_complete = chan->completion_low & CB_LOW_COMPLETION_MASK;
+#endif
+
+	if ((chan->completion & CB_CHANSTS_DMA_TRANSFER_STATUS) ==
+		CB_CHANSTS_DMA_TRANSFER_STATUS_HALTED) {
+		printk("CB: Channel halted, chanerr = %x\n",
+			chan_read_reg32(chan, CB_CHANERR_OFFSET));
+
+		/* TODO do something to salvage the situation */
+	}
+
+	if (phys_complete == chan->last_completion) {
+		spin_unlock(&chan->cleanup_lock);
+		return;
+	}
+
+	spin_lock_bh(&chan->desc_lock);
+	list_for_each_entry_safe(desc, _desc, &chan->used_desc, node) {
+
+		/*
+		 * Incoming DMA requests may use multiple descriptors, due to
+		 * exceeding xfercap, perhaps. If so, only the last one will
+		 * have a cookie, and require unmapping.
+		 */
+		if (desc->cookie) {
+			cookie = desc->cookie;
+
+			/* yes we are unmapping both _page and _single alloc'd
+			   regions with unmap_page. Is this *really* that bad?
+			*/
+			pci_unmap_page(chan->device->pdev,
+					pci_unmap_addr(desc, dst),
+					pci_unmap_len(desc, dst_len),
+					PCI_DMA_FROMDEVICE);
+			pci_unmap_page(chan->device->pdev,
+					pci_unmap_addr(desc, src),
+					pci_unmap_len(desc, src_len),
+					PCI_DMA_TODEVICE);
+		}
+
+		if (desc->phys != phys_complete) {
+			/* a completed entry, but not the last, so cleanup */
+			list_del(&desc->node);
+			list_add_tail(&desc->node, &chan->free_desc);
+		} else {
+			/* last used desc. Do not remove, so we can append from
+			   it, but don't look at it next time, either */
+			desc->cookie = 0;
+
+			/* TODO check status bits? */
+			break;
+		}
+	}
+
+	spin_unlock_bh(&chan->desc_lock);
+
+	chan->last_completion = phys_complete;
+	if (cookie != 0)
+		chan->completed_cookie = cookie;
+
+	spin_unlock(&chan->cleanup_lock);
+}
+
+/**
+ * cb_dma_is_complete - poll the status of a CB DMA transaction
+ * @chan: CB DMA channel handle
+ * @cookie: DMA transaction identifier
+ */
+
+static enum dma_status cb_dma_is_complete(struct dma_chan *chan, dma_cookie_t cookie, dma_cookie_t *done, dma_cookie_t *used)
+{
+	struct cb_dma_chan *cb_chan = to_cb_chan(chan);
+	dma_cookie_t last_used;
+	dma_cookie_t last_complete;
+	enum dma_status ret;
+
+	last_used = chan->cookie;
+	last_complete = cb_chan->completed_cookie;
+
+	if (done)
+		*done= last_complete;
+	if (used)
+		*used = last_used;
+
+	ret = dma_async_is_complete(cookie, last_complete, last_used);
+	if (ret == DMA_SUCCESS)
+		return ret;
+
+	cb_dma_memcpy_cleanup(cb_chan);
+
+	last_used = chan->cookie;
+	last_complete = cb_chan->completed_cookie;
+
+	if (done)
+		*done= last_complete;
+	if (used)
+		*used = last_used;
+
+	return dma_async_is_complete(cookie, last_complete, last_used);
+}
+
+/* PCI API */
+
+static struct pci_device_id cb_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CB) },
+	{ 0, }
+};
+
+static struct pci_driver cb_pci_drv = {
+	.name 	= "ioat-dma",
+	.id_table = cb_pci_tbl,
+	.probe	= cb_probe,
+	.remove	= __devexit_p(cb_remove),
+};
+
+static irqreturn_t cb_do_interrupt(int irq, void *data, struct pt_regs *regs)
+{
+	struct cb_device *instance = data;
+	unsigned long attnstatus;
+	u8 intrctrl;
+
+	intrctrl = read_reg8(instance, CB_INTRCTRL_OFFSET);
+
+	if (!(intrctrl & CB_INTRCTRL_MASTER_INT_EN)) {
+		return IRQ_NONE;
+	}
+
+	if (!(intrctrl & CB_INTRCTRL_INT_STATUS)) {
+		write_reg8(instance, CB_INTRCTRL_OFFSET, intrctrl);
+		return IRQ_NONE;
+	}
+
+	attnstatus = (unsigned long) read_reg32(instance, CB_ATTNSTATUS_OFFSET);
+
+	write_reg8(instance, CB_INTRCTRL_OFFSET, intrctrl);
+	return IRQ_HANDLED;
+}
+
+static void cb_start_null_desc(struct cb_dma_chan *cb_chan)
+{
+	struct cb_desc_sw *desc;
+
+	spin_lock_bh(&cb_chan->desc_lock);
+
+	if (!list_empty(&cb_chan->free_desc)) {
+		desc = to_cb_desc(cb_chan->free_desc.next);
+		list_del(&desc->node);
+	} else {
+		/* try to get another desc */
+		desc = cb_dma_alloc_descriptor(cb_chan);
+		/* will this ever happen? */
+		BUG_ON(!desc);
+	}
+
+	desc->hw->ctl = CB_DMA_DESCRIPTOR_NUL;
+	desc->hw->next = 0;
+
+	list_add_tail(&desc->node, &cb_chan->used_desc);
+
+#if (BITS_PER_LONG == 64)
+	chan_write_reg64(cb_chan, CB_CHAINADDR_OFFSET, desc->phys);
+#else
+	chan_write_reg32(cb_chan, CB_CHAINADDR_OFFSET_LOW, (u32) desc->phys);
+	chan_write_reg32(cb_chan, CB_CHAINADDR_OFFSET_HIGH, 0);
+#endif
+	chan_write_reg8(cb_chan, CB_CHANCMD_OFFSET, CB_CHANCMD_START);
+
+	spin_unlock_bh(&cb_chan->desc_lock);
+}
+
+static int __devinit cb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	int result;
+	unsigned long mmio_start, mmio_len;
+	void *reg_base;
+	struct cb_device *device;
+
+	result = pci_enable_device(pdev);
+	if (result)
+		goto err_enable_device;
+
+	result = pci_request_regions(pdev, cb_pci_drv.name);
+	if (result)
+		goto err_request_regions;
+
+	mmio_start = pci_resource_start(pdev, 0);
+	mmio_len = pci_resource_len(pdev, 0);
+
+	reg_base = ioremap(mmio_start, mmio_len);
+	if (!reg_base) {
+		result = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	device = kmalloc(sizeof(*device), GFP_KERNEL);
+	if (!device) {
+		result = -ENOMEM;
+		goto err_kmalloc;
+	}
+	memset(device, 0, sizeof(*device));
+
+	/* DMA coherent memory pool for DMA descriptor allocations */
+	device->dma_pool = dma_pool_create("dma_desc_pool", &pdev->dev,
+		sizeof(struct cb_dma_descriptor), 64, 0);
+	if (!device->dma_pool) {
+		result = -ENOMEM;
+		goto err_dma_pool;
+	}
+
+	device->pdev = pdev;
+	pci_set_drvdata(pdev, device);
+#ifdef CONFIG_PCI_MSI
+	if (pci_enable_msi(pdev) == 0) {
+		device->msi = 1;
+	} else {
+		device->msi = 0;
+	}
+#endif
+	result = request_irq(pdev->irq, &cb_do_interrupt, SA_SHIRQ, "ioat",
+		device);
+	if (result)
+		goto err_irq;
+
+	device->reg_base = reg_base;
+
+	write_reg8(device, CB_INTRCTRL_OFFSET, CB_INTRCTRL_MASTER_INT_EN);
+	pci_set_master(pdev);
+
+	INIT_LIST_HEAD(&device->common.channels);
+	enumerate_dma_channels(device);
+
+	device->common.device_alloc_chan_resources = cb_dma_alloc_chan_resources;
+	device->common.device_free_chan_resources = cb_dma_free_chan_resources;
+	device->common.device_memcpy_buf_to_buf = cb_dma_memcpy_buf_to_buf;
+	device->common.device_memcpy_buf_to_pg = cb_dma_memcpy_buf_to_pg;
+	device->common.device_memcpy_pg_to_pg = cb_dma_memcpy_pg_to_pg;
+	device->common.device_memcpy_complete = cb_dma_is_complete;
+	device->common.device_memcpy_issue_pending = cb_dma_memcpy_issue_pending;
+	printk(KERN_INFO "Intel I/OAT DMA Engine found, %d channels\n",
+		device->common.chancnt);
+	dma_async_device_register(&device->common);
+
+	return 0;
+
+err_irq:
+	dma_pool_destroy(device->dma_pool);
+err_dma_pool:
+	kfree(device);
+err_kmalloc:
+	iounmap(reg_base);
+err_ioremap:
+	pci_release_regions(pdev);
+err_request_regions:
+err_enable_device:
+	return result;
+}
+
+static void __devexit cb_remove(struct pci_dev *pdev)
+{
+	struct cb_device *device;
+
+	device = pci_get_drvdata(pdev);
+	free_irq(device->pdev->irq, device);
+#ifdef CONFIG_PCI_MSI
+	if (device->msi)
+		pci_disable_msi(device->pdev);
+#endif
+	dma_async_device_unregister(&device->common);
+	dma_pool_destroy(device->dma_pool);
+	iounmap(device->reg_base);
+	pci_release_regions(pdev);
+	kfree(device);
+}
+
+/* MODULE API */
+MODULE_VERSION("0.40");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Intel Corporation");
+
+static int __init cb_init_module(void)
+{
+	return pci_module_init(&cb_pci_drv);
+}
+
+module_init(cb_init_module);
+
+static void __exit cb_exit_module(void)
+{
+	pci_unregister_driver(&cb_pci_drv);
+}
+
+module_exit(cb_exit_module);
Index: build/drivers/dma/ioatdma.h
===================================================================
--- /dev/null
+++ build/drivers/dma/ioatdma.h
@@ -0,0 +1,143 @@
+/**********************************************************************
+**                                                                   **
+**                I N T E L   P R O P R I E T A R Y                  **
+**                                                                   **
+**   COPYRIGHT (c) 2004 - 2005  BY  INTEL  CORPORATION.  ALL         **
+**   RIGHTS RESERVED.   NO PART OF THIS PROGRAM OR PUBLICATION MAY   **
+**   BE  REPRODUCED,   TRANSMITTED,   TRANSCRIBED,   STORED  IN  A   **
+**   RETRIEVAL SYSTEM, OR TRANSLATED INTO ANY LANGUAGE OR COMPUTER   **
+**   LANGUAGE IN ANY FORM OR BY ANY MEANS, ELECTRONIC, MECHANICAL,   **
+**   MAGNETIC,  OPTICAL,  CHEMICAL, MANUAL, OR OTHERWISE,  WITHOUT   **
+**   THE PRIOR WRITTEN PERMISSION OF :                               **
+**                                                                   **
+**                      INTEL  CORPORATION                           **
+**                                                                   **
+**                2200 MISSION COLLEGE BOULEVARD                     **
+**                                                                   **
+**             SANTA  CLARA,  CALIFORNIA  95052-8119                 **
+**                                                                   **
+**********************************************************************/
+
+/**********************************************************************
+**                                                                   **
+** INTEL CORPORATION PROPRIETARY INFORMATION                         **
+** This software is supplied under the terms of a license agreement  **
+** with Intel Corporation and may not be copied nor disclosed        **
+** except in accordance with the terms of that agreement.            **
+**                                                                   **
+** Module Name:                                                      **
+**   ioatdma.h                                                       **
+**                                                                   **
+** Abstract:                                                         **
+**                                                                   **
+**********************************************************************/
+
+#ifndef IOATDMA_H
+#define IOATDMA_H
+
+#include <linux/dmaengine.h>
+#include "cb_hw.h"
+#include <linux/init.h>
+#include <linux/dmapool.h>
+#include <linux/cache.h>
+
+#define PCI_DEVICE_ID_INTEL_CB		0x1a38
+
+#define CB_LOW_COMPLETION_MASK		0xffffffc0
+
+extern struct list_head dma_device_list;
+extern struct list_head dma_client_list;
+
+/**
+ * struct cb_device - internal representation of a CB device
+ * @pdev: PCI-Express device
+ * @reg_base: MMIO register space base address
+ * @dma_pool: for allocating DMA descriptors
+ * @common: embedded struct dma_device
+ * @msi: Message Signaled Interrupt number
+ */
+
+struct cb_device {
+	struct pci_dev *pdev;
+	void *reg_base;
+	struct dma_pool *dma_pool;
+
+	struct dma_device common;
+	u8 msi;
+
+	struct cb_dma_chan *idx[4];
+};
+
+/**
+ * struct cb_dma_chan - internal representation of a DMA channel
+ * @device:
+ * @reg_base:
+ * @sw_in_use:
+ * @completion:
+ * @completion_low:
+ * @completion_high:
+ * @completed_cookie: last cookie seen completed on cleanup
+ * @cookie: value of last cookie given to client
+ * @last_completion:
+ * @xfercap:
+ * @desc_lock:
+ * @free_desc:
+ * @used_desc:
+ * @resource:
+ * @device_node:
+ */
+
+struct cb_dma_chan {
+
+	void *reg_base;
+
+	dma_cookie_t completed_cookie;
+	unsigned long last_completion;
+
+	u32 running;
+	u32 xfercap;	/* XFERCAP register value expanded out */
+
+	spinlock_t cleanup_lock;
+	spinlock_t desc_lock;
+	struct list_head free_desc;
+	struct list_head used_desc;
+
+	int pending;
+
+	struct cb_device *device;
+	struct dma_chan common;
+
+	union {
+		u64 completion; /* HW completion writeback */
+		struct {
+			u32 completion_low;
+			u32 completion_high;
+		};
+	} ____cacheline_aligned;
+	char padding ____cacheline_aligned;
+};
+
+/* wrapper around hardware descriptor format + additional software fields */
+
+/**
+ * struct cb_desc_sw - wrapper around hardware descriptor
+ * @hw: hardware DMA descriptor
+ * @node:
+ * @cookie:
+ * @phys:
+ */
+
+struct cb_desc_sw {
+	struct cb_dma_descriptor *hw;
+	struct list_head node;
+	dma_cookie_t cookie;
+	dma_addr_t phys;
+	/* these should do nothing on the arch we expect to find this device on */
+	DECLARE_PCI_UNMAP_ADDR(src)
+	DECLARE_PCI_UNMAP_LEN(src_len)
+	DECLARE_PCI_UNMAP_ADDR(dst)
+	DECLARE_PCI_UNMAP_LEN(dst_len)
+};
+
+#endif /* IOATDMA_H */
+
Index: build/drivers/dma/Kconfig
===================================================================
--- build.orig/drivers/dma/Kconfig
+++ build/drivers/dma/Kconfig
@@ -21,4 +21,14 @@ config NET_DMA
 	  offload receive copy-to-user operations, freeing CPU cycles.
 	  Since this is the main user of the DMA engine, it should be enabled;
 	  say Y here.
+
+comment "DMA Devices"
+
+config INTEL_IOATDMA
+	tristate "Intel I/OAT DMA support"
+	depends on DMA_ENGINE
+	default m
+	---help---
+	  Enable support for the Intel I/OAT DMA engine.
+
 endmenu
