From: mason@suse.com
Subject: reiserfs_write_full_page should not get_block past eof
References: 98488

reiserfs_write_full_page does zero bytes in the file past eof, but it may
call get_block on those buffers as well.  On machines where the page size
is larger than the blocksize, this can result in mmaped incorrectly files
growing up to a block boundary during writepage.

The fix is to avoid calling get_block for any blocks that are entirely past eof

diff -r 11295eac6a16 fs/reiserfs/inode.c
--- a/fs/reiserfs/inode.c	Mon May 08 14:36:37 2006 -0400
+++ b/fs/reiserfs/inode.c	Mon May 08 15:37:35 2006 -0400
@@ -2350,6 +2350,7 @@ static int reiserfs_write_full_page(stru
 	unsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT;
 	int error = 0;
 	unsigned long block;
+	sector_t last_block;
 	struct buffer_head *head, *bh;
 	int partial = 0;
 	int nr = 0;
@@ -2397,10 +2398,19 @@ static int reiserfs_write_full_page(stru
 	}
 	bh = head;
 	block = page->index << (PAGE_CACHE_SHIFT - s->s_blocksize_bits);
+	last_block = (i_size_read(inode) - 1) >> inode->i_blkbits;
 	/* first map all the buffers, logging any direct items we find */
 	do {
-		if ((checked || buffer_dirty(bh)) && (!buffer_mapped(bh) ||
-						      (buffer_mapped(bh)
+		if (block > last_block) {
+			/*
+			 * This can happen when the block size is less than
+			 * the page size.  The corresponding bytes in the page
+			 * were zero filled above
+			 */
+			clear_buffer_dirty(bh);
+			set_buffer_uptodate(bh);
+		} else if ((checked || buffer_dirty(bh)) &&
+		           (!buffer_mapped(bh) || (buffer_mapped(bh)
 						       && bh->b_blocknr ==
 						       0))) {
 			/* not mapped yet, or it points to a direct item, search
