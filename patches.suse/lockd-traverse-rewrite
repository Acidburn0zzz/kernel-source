From: Olaf Kirch <okir@suse.de>
Subject: lockd: make nlm_traverse_* more flexible

  This patch makes nlm_traverse{locks,blocks,shares} and friends
  use a function pointer rather than a "action" enum.

  This function pointer is given two nlm_hosts (one given by the
  caller, the other taken from the lock/block/share currently
  visited), and is free to do with them as it wants. If it returns a
  non-zero value, the lockd/block/share is released.

Signed-off-by: Olaf Kirch <okir@suse.de>

Index: 2.6.15/include/linux/lockd/share.h
===================================================================
--- 2.6.15.orig/include/linux/lockd/share.h
+++ 2.6.15/include/linux/lockd/share.h
@@ -25,6 +25,7 @@ u32	nlmsvc_share_file(struct nlm_host *,
 					       struct nlm_args *);
 u32	nlmsvc_unshare_file(struct nlm_host *, struct nlm_file *,
 					       struct nlm_args *);
-int	nlmsvc_traverse_shares(struct nlm_host *, struct nlm_file *, int);
+int	nlmsvc_traverse_shares(struct nlm_host *, struct nlm_file *,
+					       nlm_host_visitor_t);
 
 #endif /* LINUX_LOCKD_SHARE_H */
Index: 2.6.15/fs/lockd/svclock.c
===================================================================
--- 2.6.15.orig/fs/lockd/svclock.c
+++ 2.6.15/fs/lockd/svclock.c
@@ -273,19 +273,17 @@ nlmsvc_delete_block(struct nlm_block *bl
  * (NLM_ACT_CHECK handled by nlmsvc_inspect_file).
  */
 int
-nlmsvc_traverse_blocks(struct nlm_host *host, struct nlm_file *file, int action)
+nlmsvc_traverse_blocks(struct nlm_host *host, struct nlm_file *file,
+			nlm_host_visitor_t fn)
 {
 	struct nlm_block	*block, *next;
 
 	down(&file->f_sema);
 	for (block = file->f_blocks; block; block = next) {
 		next = block->b_fnext;
-		if (action == NLM_ACT_MARK)
-			block->b_host->h_inuse = 1;
-		else if (action == NLM_ACT_UNLOCK) {
-			if (host == NULL || host == block->b_host)
-				nlmsvc_delete_block(block, 1);
-		}
+
+		if (fn && fn(block->b_host, host))
+			nlmsvc_delete_block(block, 1);
 	}
 	up(&file->f_sema);
 	return 0;
Index: 2.6.15/fs/lockd/svcsubs.c
===================================================================
--- 2.6.15.orig/fs/lockd/svcsubs.c
+++ 2.6.15/fs/lockd/svcsubs.c
@@ -173,7 +173,8 @@ nlm_delete_file(struct nlm_file *file)
  * action.
  */
 static int
-nlm_traverse_locks(struct nlm_host *host, struct nlm_file *file, int action)
+nlm_traverse_locks(struct nlm_host *host, struct nlm_file *file,
+			nlm_host_visitor_t fn)
 {
 	struct inode	 *inode = nlmsvc_file_inode(file);
 	struct file_lock *fl;
@@ -187,16 +188,16 @@ again:
 
 		/* update current lock count */
 		file->f_locks++;
-		lockhost = (struct nlm_host *) fl->fl_owner;
-		if (action == NLM_ACT_MARK)
-			lockhost->h_inuse = 1;
-		else if (action == NLM_ACT_CHECK)
+
+		/* No host check means we just check for the
+		 * existence of any resources tied to this file.
+		 */
+		if (fn == NULL)
 			return 1;
-		else if (action == NLM_ACT_UNLOCK) {
-			struct file_lock lock = *fl;
 
-			if (host && lockhost != host)
-				continue;
+		lockhost = (struct nlm_host *) fl->fl_owner;
+		if (fn(lockhost, host)) {
+			struct file_lock lock = *fl;
 
 			lock.fl_type  = F_UNLCK;
 			lock.fl_start = 0;
@@ -217,25 +218,25 @@ again:
  * Operate on a single file
  */
 static inline int
-nlm_inspect_file(struct nlm_host *host, struct nlm_file *file, int action)
+nlm_inspect_file(struct nlm_host *host, struct nlm_file *file, nlm_host_visitor_t fn)
 {
-	if (action == NLM_ACT_CHECK) {
+	if (fn == NULL) {
 		/* Fast path for mark and sweep garbage collection */
 		if (file->f_count || file->f_blocks || file->f_shares)
 			return 1;
 	} else {
-		if (nlmsvc_traverse_blocks(host, file, action)
-		 || nlmsvc_traverse_shares(host, file, action))
+		if (nlmsvc_traverse_blocks(host, file, fn)
+		 || nlmsvc_traverse_shares(host, file, fn))
 			return 1;
 	}
-	return nlm_traverse_locks(host, file, action);
+	return nlm_traverse_locks(host, file, fn);
 }
 
 /*
  * Loop over all files in the file table.
  */
 static int
-nlm_traverse_files(struct nlm_host *host, int action)
+nlm_traverse_files(struct nlm_host *host, nlm_host_visitor_t fn)
 {
 	struct nlm_file	*file, **fp;
 	int		i;
@@ -246,7 +247,7 @@ nlm_traverse_files(struct nlm_host *host
 		while ((file = *fp) != NULL) {
 			/* Traverse locks, blocks and shares of this file
 			 * and update file->f_locks count */
-			if (nlm_inspect_file(host, file, action)) {
+			if (nlm_inspect_file(host, file, fn)) {
 				up(&nlm_file_sema);
 				return 1;
 			}
@@ -286,7 +287,7 @@ nlm_release_file(struct nlm_file *file)
 
 	/* If there are no more locks etc, delete the file */
 	if(--file->f_count == 0) {
-		if(!nlm_inspect_file(NULL, file, NLM_ACT_CHECK))
+		if(!nlm_inspect_file(NULL, file, NULL))
 			nlm_delete_file(file);
 	}
 
@@ -294,14 +295,47 @@ nlm_release_file(struct nlm_file *file)
 }
 
 /*
+ * Helpers function for resource traversal
+ *
+ * nlmsvc_mark_host:
+ *	used by the garbage collector; simply sets h_inuse.
+ *	Always returns 0.
+ *
+ * nlmsvc_same_host:
+ *	returns 1 iff the two hosts match. Used to release
+ *	all resources bound to a specific host.
+ *
+ * nlmsvc_is_client:
+ *	returns 1 iff the host is a client.
+ *	Used by nlmsvc_invalidate_all
+ */
+static int
+nlmsvc_mark_host(struct nlm_host *host, struct nlm_host *dummy)
+{
+	host->h_inuse = 1;
+	return 0;
+}
+
+static int
+nlmsvc_same_host(struct nlm_host *host, struct nlm_host *other)
+{
+	return host == other;
+}
+
+static int
+nlmsvc_is_client(struct nlm_host *host, struct nlm_host *dummy)
+{
+	return host->h_server;
+}
+
+/*
  * Mark all hosts that still hold resources
  */
 void
 nlmsvc_mark_resources(void)
 {
 	dprintk("lockd: nlmsvc_mark_resources\n");
-
-	nlm_traverse_files(NULL, NLM_ACT_MARK);
+	nlm_traverse_files(NULL, nlmsvc_mark_host);
 }
 
 /*
@@ -312,7 +346,7 @@ nlmsvc_free_host_resources(struct nlm_ho
 {
 	dprintk("lockd: nlmsvc_free_host_resources\n");
 
-	if (nlm_traverse_files(host, NLM_ACT_UNLOCK)) {
+	if (nlm_traverse_files(host, nlmsvc_same_host)) {
 		printk(KERN_WARNING
 			"lockd: couldn't remove all locks held by %s\n",
 			host->h_name);
@@ -327,8 +361,11 @@ void
 nlmsvc_invalidate_all(void)
 {
 	struct nlm_host *host;
+
+	/* Release all locks held by a NFS clients */
+	nlm_traverse_files(NULL, nlmsvc_is_client);
+
 	while ((host = nlm_find_client()) != NULL) {
-		nlmsvc_free_host_resources(host);
 		host->h_expires = 0;
 		host->h_killed = 1;
 		nlm_release_host(host);
Index: 2.6.15/include/linux/lockd/lockd.h
===================================================================
--- 2.6.15.orig/include/linux/lockd/lockd.h
+++ 2.6.15/include/linux/lockd/lockd.h
@@ -134,13 +134,6 @@ struct nlm_block {
 };
 
 /*
- * Valid actions for nlmsvc_traverse_files
- */
-#define NLM_ACT_CHECK		0		/* check for locks */
-#define NLM_ACT_MARK		1		/* mark & sweep */
-#define NLM_ACT_UNLOCK		2		/* release all locks */
-
-/*
  * Global variables
  */
 extern struct rpc_program	nlm_program;
@@ -184,6 +177,12 @@ void		  nsm_release(struct nsm_handle *)
 
 
 /*
+ * This is used in garbage collection and resource reclain
+ * A return value != 0 means destroy the lock/block/share
+ */
+typedef int	  (*nlm_host_visitor_t)(struct nlm_host *cur, struct nlm_host *ref);
+
+/*
  * Server-side lock handling
  */
 int		  nlmsvc_async_call(struct nlm_rqst *, u32, rpc_action);
@@ -195,7 +194,7 @@ u32		  nlmsvc_testlock(struct nlm_file *
 u32		  nlmsvc_cancel_blocked(struct nlm_file *, struct nlm_lock *);
 unsigned long	  nlmsvc_retry_blocked(void);
 int		  nlmsvc_traverse_blocks(struct nlm_host *, struct nlm_file *,
-					int action);
+					nlm_host_visitor_t check);
 void	  nlmsvc_grant_reply(struct svc_rqst *, struct nlm_cookie *, u32);
 
 /*
Index: 2.6.15/fs/lockd/svcshare.c
===================================================================
--- 2.6.15.orig/fs/lockd/svcshare.c
+++ 2.6.15/fs/lockd/svcshare.c
@@ -89,20 +89,16 @@ nlmsvc_unshare_file(struct nlm_host *hos
  * NLM_ACT_CHECK is handled by nlmsvc_inspect_file.
  */
 int
-nlmsvc_traverse_shares(struct nlm_host *host, struct nlm_file *file, int action)
+nlmsvc_traverse_shares(struct nlm_host *host, struct nlm_file *file, nlm_host_visitor_t fn)
 {
 	struct nlm_share	*share, **shpp;
 
 	shpp = &file->f_shares;
 	while ((share = *shpp) !=  NULL) {
-		if (action == NLM_ACT_MARK)
-			share->s_host->h_inuse = 1;
-		else if (action == NLM_ACT_UNLOCK) {
-			if (host == NULL || host == share->s_host) {
-				*shpp = share->s_next;
-				kfree(share);
-				continue;
-			}
+		if (fn && fn(share->s_host, host)) {
+			*shpp = share->s_next;
+			kfree(share);
+			continue;
 		}
 		shpp = &share->s_next;
 	}
