From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH 32/40] reiserfs: Turn tb->s[12]num and tb->s[12]bytes into an array

 This patch turns tree_balance.s[12]num into snum[2] and
 tree_balance.s[12]bytes into sbytes[2]. It doesn't have any effect now, but
 will be used when balance_leaf is split up.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

---
 fs/reiserfs/do_balan.c      |   95 ++++++++++++++++++--------------------------
 fs/reiserfs/fix_node.c      |   28 ++++++------
 fs/reiserfs/prints.c        |    6 +-
 include/linux/reiserfs_fs.h |    6 --
 4 files changed, 59 insertions(+), 76 deletions(-)

--- a/fs/reiserfs/do_balan.c	2007-06-11 14:49:41.000000000 -0400
+++ b/fs/reiserfs/do_balan.c	2007-06-11 14:50:01.000000000 -0400
@@ -82,8 +82,8 @@ inline void do_balance_mark_leaf_dirty(s
  else
    if lnum is larger than 0 we put items into the left node
    if rnum is larger than 0 we put items into the right node
-   if snum1 is larger than 0 we put items into the new node s1
-   if snum2 is larger than 0 we put items into the new node s2
+   if tb->snum[0] is larger than 0 we put items into the new node s1
+   if tb->snum[1] is larger than 0 we put items into the new node s2
 Note that all *num* count new items being created.
 
 It would be easier to read balance_leaf() if each of these summary
@@ -292,15 +292,6 @@ static int balance_leaf(struct tree_bala
 							   of the affected item */
 	struct buffer_info bi;
 	struct buffer_head *S_new[2];	/* new nodes allocated to hold what could not fit into S */
-	int snum[2];		/* number of items that will be placed
-				   into S_new (includes partially shifted
-				   items) */
-	int sbytes[2];		/* if an item is partially shifted into S_new then
-				   if it is a directory item
-				   it is the number of entries from the item that are shifted into S_new
-				   else
-				   it is the number of bytes from the item that are shifted into S_new
-				 */
 	int n, i;
 	int ret_val;
 	int pos_in_item;
@@ -1161,16 +1152,10 @@ static int balance_leaf(struct tree_bala
 	}
 
 	/* Fill new nodes that appear in place of S[0] */
-
-	/* I am told that this copying is because we need an array to enable
-	   the looping code. -Hans */
-	snum[0] = tb->s1num, snum[1] = tb->s2num;
-	sbytes[0] = tb->s1bytes;
-	sbytes[1] = tb->s2bytes;
 	for (i = tb->blknum[0] - 2; i >= 0; i--) {
 
-		RFALSE(!snum[i], "PAP-12200: snum[%d] == %d. Must be > 0", i,
-		       snum[i]);
+		RFALSE(!tb->snum[i], "PAP-12200: tb->snum[%d] == %d. Must be > 0", i,
+		       tb->snum[i]);
 
 		/* here we shift from S to S_new nodes */
 
@@ -1184,16 +1169,16 @@ static int balance_leaf(struct tree_bala
 		switch (flag) {
 		case M_INSERT:	/* insert item */
 
-			if (n - snum[i] < item_pos) {	/* new item or it's part falls to first new node S_new[i] */
-				if (item_pos == n - snum[i] + 1 && sbytes[i] != -1) {	/* part of new item falls into S_new[i] */
+			if (n - tb->snum[i] < item_pos) {	/* new item or it's part falls to first new node S_new[i] */
+				if (item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {	/* part of new item falls into S_new[i] */
 					int old_key_comp, old_len,
 					    r_zeros_number;
 					const char *r_body;
 					int version;
 
-					/* Move snum[i]-1 items from S[0] to S_new[i] */
+					/* Move tb->snum[i]-1 items from S[0] to S_new[i] */
 					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-							snum[i] - 1, -1,
+							tb->snum[i] - 1, -1,
 							S_new[i]);
 					/* Remember key component and item length */
 					version = ih_version(ih);
@@ -1204,29 +1189,29 @@ static int balance_leaf(struct tree_bala
 					set_le_ih_k_offset(ih,
 							   le_ih_k_offset(ih) +
 							   ((old_len -
-							     sbytes[i]) <<
+							     tb->sbytes[i]) <<
 							    (is_indirect_le_ih
 							     (ih) ? tb->tb_sb->
 							     s_blocksize_bits -
 							     UNFM_P_SHIFT :
 							     0)));
 
-					put_ih_item_len(ih, sbytes[i]);
+					put_ih_item_len(ih, tb->sbytes[i]);
 
 					/* Insert part of the item into S_new[i] before 0-th item */
 					buffer_info_init_bh(tb, &bi, S_new[i]);
 
-					if ((old_len - sbytes[i]) > zeros_num) {
+					if ((old_len - tb->sbytes[i]) > zeros_num) {
 						r_zeros_number = 0;
 						r_body =
 						    body + (old_len -
-							    sbytes[i]) -
+							    tb->sbytes[i]) -
 						    zeros_num;
 					} else {
 						r_body = body;
 						r_zeros_number =
 						    zeros_num - (old_len -
-								 sbytes[i]);
+								 tb->sbytes[i]);
 						zeros_num -= r_zeros_number;
 					}
 
@@ -1236,20 +1221,20 @@ static int balance_leaf(struct tree_bala
 					/* Calculate key component and item length to insert into S[i] */
 					set_le_ih_k_offset(ih, old_key_comp);
 					put_ih_item_len(ih,
-							old_len - sbytes[i]);
-					tb->insert_size[0] -= sbytes[i];
+							old_len - tb->sbytes[i]);
+					tb->insert_size[0] -= tb->sbytes[i];
 				} else {	/* whole new item falls into S_new[i] */
 
-					/* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
+					/* Shift tb->snum[0] - 1 items to S_new[i] (tb->sbytes[i] of split item) */
 					leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-							snum[i] - 1, sbytes[i],
+							tb->snum[i] - 1, tb->sbytes[i],
 							S_new[i]);
 
 					/* Insert new item into S_new[i] */
 					buffer_info_init_bh(tb, &bi, S_new[i]);
 					leaf_insert_into_buf(&bi,
 							     item_pos - n +
-							     snum[i] - 1, ih,
+							     tb->snum[i] - 1, ih,
 							     body, zeros_num);
 
 					zeros_num = tb->insert_size[0] = 0;
@@ -1259,14 +1244,14 @@ static int balance_leaf(struct tree_bala
 			else {	/* new item or it part don't falls into S_new[i] */
 
 				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-						snum[i], sbytes[i], S_new[i]);
+						tb->snum[i], tb->sbytes[i], S_new[i]);
 			}
 			break;
 
 		case M_PASTE:	/* append item */
 
-			if (n - snum[i] <= item_pos) {	/* pasted item or part if it falls to S_new[i] */
-				if (item_pos == n - snum[i] && sbytes[i] != -1) {	/* we must shift part of the appended item */
+			if (n - tb->snum[i] <= item_pos) {	/* pasted item or part if it falls to S_new[i] */
+				if (item_pos == n - tb->snum[i] && tb->sbytes[i] != -1) {	/* we must shift part of the appended item */
 					struct item_head *aux_ih;
 
 					RFALSE(ih, "PAP-12210: ih must be 0");
@@ -1281,7 +1266,7 @@ static int balance_leaf(struct tree_bala
 						entry_count =
 						    ih_entry_count(aux_ih);
 
-						if (entry_count - sbytes[i] <
+						if (entry_count - tb->sbytes[i] <
 						    pos_in_item
 						    && pos_in_item <=
 						    entry_count) {
@@ -1290,17 +1275,17 @@ static int balance_leaf(struct tree_bala
 							RFALSE(!tb->
 							       insert_size[0],
 							       "PAP-12215: insert_size is already 0");
-							RFALSE(sbytes[i] - 1 >=
+							RFALSE(tb->sbytes[i] - 1 >=
 							       entry_count,
 							       "PAP-12220: there are no so much entries (%d), only %d",
-							       sbytes[i] - 1,
+							       tb->sbytes[i] - 1,
 							       entry_count);
 
-							/* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
+							/* Shift tb->snum[i]-1 items in whole. Shift tb->sbytes[i] directory entries from directory item number tb->snum[i] */
 							leaf_move_items
 							    (LEAF_FROM_S_TO_SNEW,
-							     tb, snum[i],
-							     sbytes[i] - 1,
+							     tb, tb->snum[i],
+							     tb->sbytes[i] - 1,
 							     S_new[i]);
 							/* Paste given directory entry to directory item */
 							buffer_info_init_bh(tb, &bi, S_new[i]);
@@ -1308,7 +1293,7 @@ static int balance_leaf(struct tree_bala
 							    (&bi, 0,
 							     pos_in_item -
 							     entry_count +
-							     sbytes[i] - 1,
+							     tb->sbytes[i] - 1,
 							     tb->insert_size[0],
 							     body, zeros_num);
 							/* paste new directory entry */
@@ -1319,7 +1304,7 @@ static int balance_leaf(struct tree_bala
 									   -
 									   entry_count
 									   +
-									   sbytes
+									   tb->sbytes
 									   [i] -
 									   1, 1,
 									   (struct
@@ -1338,8 +1323,8 @@ static int balance_leaf(struct tree_bala
 						} else {	/* new directory entry doesn't fall into S_new[i] */
 							leaf_move_items
 							    (LEAF_FROM_S_TO_SNEW,
-							     tb, snum[i],
-							     sbytes[i],
+							     tb, tb->snum[i],
+							     tb->sbytes[i],
 							     S_new[i]);
 						}
 					} else {	/* regular object */
@@ -1358,19 +1343,19 @@ static int balance_leaf(struct tree_bala
 
 						/* Calculate number of bytes which must be shifted from appended item */
 						n_shift =
-						    sbytes[i] -
+						    tb->sbytes[i] -
 						    tb->insert_size[0];
 						if (n_shift < 0)
 							n_shift = 0;
 						leaf_move_items
 						    (LEAF_FROM_S_TO_SNEW, tb,
-						     snum[i], n_shift,
+						     tb->snum[i], n_shift,
 						     S_new[i]);
 
 						/* Calculate number of bytes which must remain in body after append to S_new[i] */
 						n_rem =
 						    tb->insert_size[0] -
-						    sbytes[i];
+						    tb->sbytes[i];
 						if (n_rem < 0)
 							n_rem = 0;
 						/* Append part of body into S_new[0] */
@@ -1450,8 +1435,8 @@ static int balance_leaf(struct tree_bala
 
 					ret_val =
 					    leaf_move_items(LEAF_FROM_S_TO_SNEW,
-							    tb, snum[i],
-							    sbytes[i],
+							    tb, tb->snum[i],
+							    tb->sbytes[i],
 							    S_new[i]);
 
 					RFALSE(ret_val,
@@ -1462,7 +1447,7 @@ static int balance_leaf(struct tree_bala
 					buffer_info_init_bh(tb, &bi, S_new[i]);
 					leaf_paste_in_buffer(&bi,
 							     item_pos - n +
-							     snum[i],
+							     tb->snum[i],
 							     pos_in_item,
 							     tb->insert_size[0],
 							     body, zeros_num);
@@ -1470,11 +1455,11 @@ static int balance_leaf(struct tree_bala
 					pasted =
 					    B_N_PITEM_HEAD(S_new[i],
 							   item_pos - n +
-							   snum[i]);
+							   tb->snum[i]);
 					if (is_direntry_le_ih(pasted)) {
 						leaf_paste_entries(bi.bi_bh,
 								   item_pos -
-								   n + snum[i],
+								   n + tb->snum[i],
 								   pos_in_item,
 								   1,
 								   (struct
@@ -1498,7 +1483,7 @@ static int balance_leaf(struct tree_bala
 			else {	/* pasted item doesn't fall into S_new[i] */
 
 				leaf_move_items(LEAF_FROM_S_TO_SNEW, tb,
-						snum[i], sbytes[i], S_new[i]);
+						tb->snum[i], tb->sbytes[i], S_new[i]);
 			}
 			break;
 		default:	/* cases d and t */
--- a/fs/reiserfs/fix_node.c	2007-06-11 14:49:41.000000000 -0400
+++ b/fs/reiserfs/fix_node.c	2007-06-11 14:49:41.000000000 -0400
@@ -399,8 +399,8 @@ static int get_num_ver(int mode, struct 
 
 	/* snum012 [0-2] - number of items, that lay
 	   to S[0], first new node and second new node */
-	snum012[3] = -1;	/* s1bytes */
-	snum012[4] = -1;	/* s2bytes */
+	snum012[3] = -1;	/* sbytes[0] */
+	snum012[4] = -1;	/* sbytes[1] */
 
 	/* internal level */
 	if (h > 0) {
@@ -526,7 +526,7 @@ static int get_num_ver(int mode, struct 
 		    ((split_item_positions[0] ==
 		      split_item_positions[1]) ? snum012[3] : 0);
 
-		// s2bytes
+		// sbytes[2]
 		snum012[4] =
 		    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[4] -
 		    bytes_to_r - bytes_to_l - bytes_to_S1new;
@@ -554,7 +554,7 @@ static int get_num_ver(int mode, struct 
 		    ((split_item_positions[0] == split_item_positions[1]
 		      && snum012[4] != -1) ? snum012[4] : 0);
 
-		// s1bytes
+		// sbytes[0]
 		snum012[3] =
 		    op_unit_num(&vn->vn_vi[split_item_num]) - snum012[3] -
 		    bytes_to_r - bytes_to_l - bytes_to_S2new;
@@ -581,7 +581,7 @@ extern struct tree_balance *cur_tb;
  *		not shifted entirely
  *	rbytes	number of bytes which flow to the right neighbor from the item that is not
  *		not shifted entirely
- *	s1bytes	number of bytes which flow to the first  new node when S[0] splits (this number is contained in s012 array)
+ *	sbytes[0]	number of bytes which flow to the first  new node when S[0] splits (this number is contained in s012 array)
  */
 
 static void set_parameters(struct tree_balance *tb, int h, int lnum,
@@ -595,9 +595,9 @@ static void set_parameters(struct tree_b
 	if (h == 0) {		/* only for leaf level */
 		if (s012 != NULL) {
 			tb->s0num = *s012++,
-			    tb->s1num = *s012++, tb->s2num = *s012++;
-			tb->s1bytes = *s012++;
-			tb->s2bytes = *s012;
+			    tb->snum[0] = *s012++, tb->snum[1] = *s012++;
+			tb->sbytes[0] = *s012++;
+			tb->sbytes[2] = *s012;
 		}
 		tb->lbytes = lb;
 		tb->rbytes = rb;
@@ -1235,9 +1235,9 @@ static int ip_check_balance(struct tree_
 	   nodes that might be created. */
 
 	/* we perform 8 calls to get_num_ver().  For each call we calculate five parameters.
-	   where 4th parameter is s1bytes and 5th - s2bytes
+	   where 4th parameter is sbytes[0] and 5th - sbytes[2]
 	 */
-	short snum012[40] = { 0, };	/* s0num, s1num, s2num for 8 cases
+	short snum012[40] = { 0, };	/* s0num, snum[0], snum[1] for 8 cases
 					   0,1 - do not shift and do not shift but bottle
 					   2 - shift only whole item to left
 					   3 - shift to left and bottle as much as possible
@@ -1374,7 +1374,7 @@ static int ip_check_balance(struct tree_
 		/* calculate number of blocks S[h] must be split into when
 		   nothing is shifted to the neighbors,
 		   as well as number of items in each part of the split node (s012 numbers),
-		   and number of bytes (s1bytes) of the shared drop which flow to S1 if any */
+		   and number of bytes (sbytes[0]) of the shared drop which flow to S1 if any */
 		nset = NOTHING_SHIFT_NO_FLOW;
 		nver = get_num_ver(vn->vn_mode, tb, h,
 				   0, -1, h ? vn->vn_nr_item : 0, -1,
@@ -1395,7 +1395,7 @@ static int ip_check_balance(struct tree_
 		   l_shift_num first items and l_shift_bytes of the right most
 		   liquid item to be shifted are shifted to the left neighbor,
 		   as well as number of items in each part of the splitted node (s012 numbers),
-		   and number of bytes (s1bytes) of the shared drop which flow to S1 if any
+		   and number of bytes (sbytes[0]) of the shared drop which flow to S1 if any
 		 */
 		lset = LEFT_SHIFT_NO_FLOW;
 		lnver = get_num_ver(vn->vn_mode, tb, h,
@@ -1418,7 +1418,7 @@ static int ip_check_balance(struct tree_
 		   r_shift_num first items and r_shift_bytes of the left most
 		   liquid item to be shifted are shifted to the right neighbor,
 		   as well as number of items in each part of the splitted node (s012 numbers),
-		   and number of bytes (s1bytes) of the shared drop which flow to S1 if any
+		   and number of bytes (sbytes[0]) of the shared drop which flow to S1 if any
 		 */
 		rset = RIGHT_SHIFT_NO_FLOW;
 		rnver = get_num_ver(vn->vn_mode, tb, h,
@@ -1446,7 +1446,7 @@ static int ip_check_balance(struct tree_
 		/* calculate number of blocks S[h] must be split into when
 		   items are shifted in both directions,
 		   as well as number of items in each part of the splitted node (s012 numbers),
-		   and number of bytes (s1bytes) of the shared drop which flow to S1 if any
+		   and number of bytes (sbytes[0]) of the shared drop which flow to S1 if any
 		 */
 		lrset = LR_SHIFT_NO_FLOW;
 		lrnver = get_num_ver(vn->vn_mode, tb, h,
--- a/fs/reiserfs/prints.c	2007-06-11 14:49:39.000000000 -0400
+++ b/fs/reiserfs/prints.c	2007-06-11 14:49:59.000000000 -0400
@@ -667,9 +667,9 @@ void store_print_tb(struct tree_balance 
 		"* h * size * ln * lb * rn * rb * blkn * s0 * s1 * s1b * s2 * s2b * curb * lk * rk *\n"
 		"* 0 * %4d * %2d * %2d * %2d * %2d * %4d * %2d * %2d * %3d * %2d * %3d * %4d * %2d * %2d *\n",
 		tb->insert_size[0], tb->lnum[0], tb->lbytes, tb->rnum[0],
-		tb->rbytes, tb->blknum[0], tb->s0num, tb->s1num, tb->s1bytes,
-		tb->s2num, tb->s2bytes, tb->cur_blknum, tb->lkey[0],
-		tb->rkey[0]);
+		tb->rbytes, tb->blknum[0], tb->s0num, tb->snum[0],
+		tb->sbytes[0], tb->snum[1], tb->sbytes[1], tb->cur_blknum,
+		tb->lkey[0], tb->rkey[0]);
 
 	/* this prints balance parameters for non-leaf levels */
 	h = 0;
--- a/include/linux/reiserfs_fs.h	2007-06-11 14:49:40.000000000 -0400
+++ b/include/linux/reiserfs_fs.h	2007-06-11 14:49:59.000000000 -0400
@@ -1366,17 +1366,15 @@ struct tree_balance {
 	/* fields that are used only for balancing leaves of the tree */
 	int cur_blknum;		/* number of empty blocks having been already allocated                 */
 	int s0num;		/* number of items that fall into left most  node when S[0] splits     */
-	int s1num;		/* number of items that fall into first  new node when S[0] splits     */
-	int s2num;		/* number of items that fall into second new node when S[0] splits     */
+	int snum[2];		/* number of items that fall into first and second new node when S[0] splits     */
 	int lbytes;		/* number of bytes which can flow to the left neighbor from the        left    */
 	/* most liquid item that cannot be shifted from S[0] entirely         */
 	/* if -1 then nothing will be partially shifted */
 	int rbytes;		/* number of bytes which will flow to the right neighbor from the right        */
 	/* most liquid item that cannot be shifted from S[0] entirely         */
 	/* if -1 then nothing will be partially shifted                           */
-	int s1bytes;		/* number of bytes which flow to the first  new node when S[0] splits   */
+	int sbytes[2];		/* number of bytes which flow to the first and second new node when S[0] splits   */
 	/* note: if S[0] splits into 3 nodes, then items do not need to be cut  */
-	int s2bytes;
 	struct buffer_head *buf_to_free[MAX_FREE_BLOCK];	/* buffers which are to be freed after do_balance finishes by unfix_nodes */
 	char *vn_buf;		/* kmalloced memory. Used to create
 				   virtual node and keep map of
