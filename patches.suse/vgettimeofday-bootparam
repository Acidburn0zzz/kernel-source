Index: linux-2.6.5/arch/i386/kernel/setup.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/setup.c	2004-05-19 16:06:24.000000000 +0200
+++ linux-2.6.5/arch/i386/kernel/setup.c	2004-05-19 16:15:33.000000000 +0200
@@ -67,6 +67,9 @@
 #ifdef CONFIG_EFI
 int efi_enabled = 0;
 #endif
+#ifdef CONFIG_VSYSCALL_GTOD
+int vgettimeofday_enable = 0;
+#endif
 
 /* cpu data as detected by the assembly code in head.S */
 struct cpuinfo_x86 new_cpu_data __initdata = { 0, 0, 0, 0, -1, 1, 0, 0, -1 };
@@ -622,6 +625,11 @@
 #endif /* CONFIG_X86_LOCAL_APIC */
 #endif /* CONFIG_ACPI_BOOT */
 
+#ifdef CONFIG_VSYSCALL_GTOD
+		else if (!memcmp(from, "vgettimeofday=1", 15))
+			vgettimeofday_enable = 1;
+#endif
+
 		/*
 		 * highmem=size forces highmem to be exactly 'size' bytes.
 		 * This works even on boxes that have no highmem otherwise.
Index: linux-2.6.5/arch/i386/kernel/time.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/time.c	2004-05-19 16:06:24.000000000 +0200
+++ linux-2.6.5/arch/i386/kernel/time.c	2004-05-19 16:17:56.000000000 +0200
@@ -87,6 +87,10 @@
 
 struct timer_opts *cur_timer = &timer_none;
 
+#ifdef CONFIG_VSYSCALL_GTOD
+extern int vgettimeofday_enable;
+#endif
+
 /*
  * This version of gettimeofday has microsecond resolution
  * and better than microsecond precision on fast x86 machines with TSC.
@@ -394,7 +398,12 @@
 	printk(KERN_INFO "Using %s for high-res timesource\n",cur_timer->name);
 
 	/* set vsyscall to use selected time source */
-	vsyscall_set_timesource(cur_timer->name);
+#ifdef CONFIG_VSYSCALL_GTOD
+	if (vgettimeofday_enable) {
+		printk(KERN_INFO "Enabling gettimeofday vsyscall\n");
+		vsyscall_set_timesource(cur_timer->name);
+	}
+#endif
 
 	time_init_hook();
 }
