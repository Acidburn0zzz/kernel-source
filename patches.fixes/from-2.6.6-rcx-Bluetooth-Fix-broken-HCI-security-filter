#date: 2004-04-05
#id: 1.1371.679.2
#tag: other
#time: 11:00:19
#title: [Bluetooth] Fix broken HCI security filter
#who: marcel@holtmann.org
#
# ChangeSet
#   1.1371.679.2 04/04/05 11:00:19 marcel@holtmann.org +2 -0
#   [Bluetooth] Fix broken HCI security filter
#   
#   The HCI security filter is broken on 64-bit architectures and this patch
#   restores the version from 2.4, which is working perfect on 32-bit and
#   64-bit machines.
#
# net/bluetooth/hci_sock.c +9 -4
# include/net/bluetooth/hci_core.h +3 -3
#
diff -Nru a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
--- a/include/net/bluetooth/hci_core.h	Wed Apr 28 00:27:25 2004
+++ b/include/net/bluetooth/hci_core.h	Wed Apr 28 00:27:25 2004
@@ -515,9 +515,9 @@
 #define HCI_SFLT_MAX_OGF  5
 
 struct hci_sec_filter {
-	unsigned long type_mask;
-	unsigned long event_mask[2];
-	unsigned long ocf_mask[HCI_SFLT_MAX_OGF + 1][4];
+	__u32 type_mask;
+	__u32 event_mask[2];
+	__u32 ocf_mask[HCI_SFLT_MAX_OGF + 1][4];
 };
 
 /* ----- HCI requests ----- */
diff -Nru a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
--- a/net/bluetooth/hci_sock.c	Wed Apr 28 00:27:25 2004
+++ b/net/bluetooth/hci_sock.c	Wed Apr 28 00:27:25 2004
@@ -61,6 +61,11 @@
 
 /* ----- HCI socket interface ----- */
 
+static inline int hci_test_bit(int nr, void *addr)
+{
+	return *((__u32 *) addr + (nr >> 5)) & ((__u32) 1 << (nr & 31));
+}
+
 /* Security filter */
 static struct hci_sec_filter hci_sec_filter = {
 	/* Packet types */
@@ -115,8 +120,8 @@
 
 		if (skb->pkt_type == HCI_EVENT_PKT) {
 			register int evt = (*(__u8 *)skb->data & HCI_FLT_EVENT_BITS);
-			
-			if (!test_bit(evt, flt->event_mask))
+
+			if (!hci_test_bit(evt, &flt->event_mask))
 				continue;
 
 			if (flt->opcode && ((evt == HCI_EV_CMD_COMPLETE && 
@@ -399,8 +404,8 @@
 		u16 ogf = hci_opcode_ogf(opcode);
 		u16 ocf = hci_opcode_ocf(opcode);
 
-		if (((ogf > HCI_SFLT_MAX_OGF) || 
-				!test_bit(ocf & HCI_FLT_OCF_BITS, hci_sec_filter.ocf_mask[ogf])) &&
+		if (((ogf > HCI_SFLT_MAX_OGF) ||
+				!hci_test_bit(ocf & HCI_FLT_OCF_BITS, &hci_sec_filter.ocf_mask[ogf])) &&
 		    			!capable(CAP_NET_RAW)) {
 			err = -EPERM;
 			goto drop;
