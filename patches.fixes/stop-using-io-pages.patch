

Now remove address_space.io_pages.


Index: linux.t/fs/inode.c
===================================================================
--- linux.t.orig/fs/inode.c	2004-03-15 15:05:38.683601357 -0500
+++ linux.t/fs/inode.c	2004-03-15 15:07:50.467873567 -0500
@@ -178,7 +178,6 @@ void inode_init_once(struct inode *inode
 	INIT_HLIST_NODE(&inode->i_hash);
 	INIT_LIST_HEAD(&inode->i_data.clean_pages);
 	INIT_LIST_HEAD(&inode->i_data.locked_pages);
-	INIT_LIST_HEAD(&inode->i_data.io_pages);
 	INIT_LIST_HEAD(&inode->i_dentry);
 	INIT_LIST_HEAD(&inode->i_devices);
 	sema_init(&inode->i_sem, 1);
Index: linux.t/fs/mpage.c
===================================================================
--- linux.t.orig/fs/mpage.c	2004-03-15 15:06:41.445111998 -0500
+++ linux.t/fs/mpage.c	2004-03-15 15:07:50.469873329 -0500
@@ -589,15 +589,13 @@ out:
  * This is a library function, which implements the writepages()
  * address_space_operation.
  *
- * (The next two paragraphs refer to code which isn't here yet, but they
- *  explain the presence of address_space.io_pages)
- *
  * If a page is already under I/O, generic_writepages() skips it, even
  * if it's dirty.  This is desirable behaviour for memory-cleaning writeback,
  * but it is INCORRECT for data-integrity system calls such as fsync().  fsync()
  * and msync() need to guarantee that all the data which was dirty at the time
- * the call was made get new I/O started against them.  So if called_for_sync()
- * is true, we must wait for existing IO to complete.
+ * the call was made get new I/O started against them.  If wbc->sync_mode is
+ * WB_SYNC_ALL then we were called for data integrity and we must wait for
+ * existing IO to complete.
  */
 int
 mpage_writepages(struct address_space *mapping,
Index: linux.t/include/linux/fs.h
===================================================================
--- linux.t.orig/include/linux/fs.h	2004-03-15 15:05:38.688600760 -0500
+++ linux.t/include/linux/fs.h	2004-03-15 15:07:50.473872851 -0500
@@ -327,7 +327,6 @@ struct address_space {
 	spinlock_t		tree_lock;	/* and spinlock protecting it */
 	struct list_head	clean_pages;	/* list of clean pages */
 	struct list_head	locked_pages;	/* list of locked pages */
-	struct list_head	io_pages;	/* being prepared for I/O */
 	unsigned long		nrpages;	/* number of total pages */
 	struct address_space_operations *a_ops;	/* methods */
 	struct list_head	i_mmap;		/* list of private mappings */
Index: linux.t/mm/swap_state.c
===================================================================
--- linux.t.orig/mm/swap_state.c	2004-03-15 15:05:38.695599925 -0500
+++ linux.t/mm/swap_state.c	2004-03-15 15:07:50.470873209 -0500
@@ -28,7 +28,6 @@ struct address_space swapper_space = {
 	.page_tree	= RADIX_TREE_INIT(GFP_ATOMIC),
 	.tree_lock	= SPIN_LOCK_UNLOCKED,
 	.clean_pages	= LIST_HEAD_INIT(swapper_space.clean_pages),
-	.io_pages	= LIST_HEAD_INIT(swapper_space.io_pages),
 	.locked_pages	= LIST_HEAD_INIT(swapper_space.locked_pages),
 	.a_ops		= &swap_aops,
 	.backing_dev_info = &swap_backing_dev_info,
