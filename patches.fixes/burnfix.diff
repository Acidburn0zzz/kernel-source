Date: Thu, 9 Sep 2004 09:35:13 +0200
From: Jens Axboe <axboe@suse.de>
To: Ruediger Oertel <ro@suse.de>, Andreas Jaeger <aj@suse.de>
Subject: burn fix

Hi,

Found the problem, it's actually in the highmem bounce handling.
bio_for_each_segment() iterates over the bio from bio->bi_idx, which is
the current index into the bio, and to the end. The problem is that this
index has been incremented over io, so we actually only end up iterating
over end-1 -> end of the io_vecs in the bio. Bad! For cdrom burning,
we typically issue 64kb request to the drive which is 16 pages on this
box. So we leak 15 pages on each bounced bio, not so good in the long
run... The end result is that the bounce mempool has been exhausted and
the next allocation will wait forever trying to get a new bounce page.
Even worse - on a bounced bio read with multiple pages, we return zeroes
for pages 0 to end-1! Nobody has reported this issue yet as far as I
know, but running 2.6 on an isa scsi adapter should not work very
well...

The fix is simple - always start from 0 when iterating over the bounced
bio. This way we see all pages, both for copy and freeing. Since I'm at
Linux Kongress tomorrow, maybe Rudi can apply this to HEAD and test a
KOTH with the fix? There's also a bugzilla entry from Novell about
something like this, I'm very sure it's the same bug. I'll handle that
on friday.

Jens Axboe

Index: linux-2.6.8/mm/highmem.c
===================================================================
--- linux-2.6.8.orig/mm/highmem.c
+++ linux-2.6.8/mm/highmem.c
@@ -284,7 +284,7 @@ static void copy_to_high_bio_irq(struct 
 	struct bio_vec *tovec, *fromvec;
 	int i;
 
-	bio_for_each_segment(tovec, to, i) {
+	__bio_for_each_segment(tovec, to, i, 0) {
 		fromvec = from->bi_io_vec + i;
 
 		/*
@@ -316,7 +316,7 @@ static void bounce_end_io(struct bio *bi
 	/*
 	 * free up bounce indirect pages used
 	 */
-	bio_for_each_segment(bvec, bio, i) {
+	__bio_for_each_segment(bvec, bio, i, 0) {
 		org_vec = bio_orig->bi_io_vec + i;
 		if (bvec->bv_page == org_vec->bv_page)
 			continue;
