From: James Bottomley <bottomley@steeleye.com>
Ref: http://marc.theaimsgroup.com/?l=linux-scsi&m=109885339614318&w=2

On Tue, 2004-10-26 at 14:08, Mike Christie wrote:

>>The null state and and oops are becuase of this
>>http://marc.theaimsgroup.com/?l=linux-scsi&m=109733573729283&w=2
>
>Oh yeah. that patch is not correct, but if you correctly modify it to
>use device_for_each_child per Christoph's suggestion, I seem to be
>getting some refcounting errors. For some reason the sdev will be
>released, but the sd.c still thinks it is there.


Actually, he suggested using shost_for_each_device.  The reason being
that you can't have nested device_for_each_child (because it takes the
bus semaphore).

The patch attached should do this, if someone would care to try it out.

James

--- linux-2.6.8/drivers/scsi/hosts.c.orig	2004-10-27 14:44:00.497698645 +0200
+++ linux-2.6.8/drivers/scsi/hosts.c	2004-10-27 15:12:55.139931849 +0200
@@ -50,11 +50,6 @@
 	.release	= scsi_host_cls_release,
 };
 
-static int scsi_device_cancel_cb(struct device *dev, void *data)
-{
-	return scsi_device_cancel(to_scsi_device(dev), *(int *)data);
-}
-
 /**
  * scsi_host_cancel - cancel outstanding IO to this host
  * @shost:	pointer to struct Scsi_Host
@@ -62,9 +57,12 @@
  **/
 void scsi_host_cancel(struct Scsi_Host *shost, int recovery)
 {
+	struct scsi_device *sdev;
+
 	set_bit(SHOST_CANCEL, &shost->shost_state);
-	device_for_each_child(&shost->shost_gendev, &recovery,
-			      scsi_device_cancel_cb);
+	shost_for_each_device(sdev, shost) {
+		scsi_device_cancel(sdev, recovery);
+	}
 	wait_event(shost->host_wait, (!test_bit(SHOST_RECOVERY,
 						&shost->shost_state)));
 }
