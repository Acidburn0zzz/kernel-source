Index: linux-2.6.5/arch/i386/kernel/cpu/mtrr/if.c
===================================================================
--- linux-2.6.5.orig/arch/i386/kernel/cpu/mtrr/if.c
+++ linux-2.6.5/arch/i386/kernel/cpu/mtrr/if.c
@@ -160,7 +160,7 @@ mtrr_ioctl(struct inode *inode, struct f
 
 	switch (cmd) {
 	default:
-		return -ENOIOCTLCMD;
+		return -ENOTTY;
 	case MTRRIOC_ADD_ENTRY:
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
Index: linux-2.6.5/arch/ia64/kernel/salinfo.c
===================================================================
--- linux-2.6.5.orig/arch/ia64/kernel/salinfo.c
+++ linux-2.6.5/arch/ia64/kernel/salinfo.c
@@ -430,6 +430,9 @@ salinfo_log_read(struct file *file, char
 	size_t size;
 	u8 *buf;
 	u64 bufsize;
+	loff_t pos = *ppos;
+	
+	/* FIXME: needs seek/parallel-lock */
 
 	if (data->state == STATE_LOG_RECORD) {
 		buf = data->log_buffer;
@@ -441,17 +444,17 @@ salinfo_log_read(struct file *file, char
 		buf = NULL;
 		bufsize = 0;
 	}
-	if (*ppos >= bufsize)
+	if (pos >= bufsize)
 		return 0;
 
-	saldata = buf + file->f_pos;
-	size = bufsize - file->f_pos;
+	saldata = buf + pos;
+	size = bufsize - pos;
 	if (size > count)
 		size = count;
 	if (copy_to_user(buffer, saldata, size))
 		return -EFAULT;
 
-	*ppos += size;
+	*ppos = pos + size;
 	return size;
 }
 
Index: linux-2.6.5/arch/ppc/kernel/ppc_htab.c
===================================================================
--- linux-2.6.5.orig/arch/ppc/kernel/ppc_htab.c
+++ linux-2.6.5/arch/ppc/kernel/ppc_htab.c
@@ -106,8 +106,11 @@ static ssize_t ppc_htab_read(struct file
 	PTE *ptr;
 #endif /* CONFIG_PPC_STD_MMU */
 	char buffer[512];
+	loff_t pos = *ppos;
 
-	if (count < 0)
+	/* FIXME - needs seek/pos locking */
+	
+	if (pos < 0)
 		return -EINVAL;
 
 	if (cur_cpu_spec[0]->cpu_features & CPU_FTR_604_PERF_MON) {
@@ -182,15 +185,15 @@ return_string:
 		      "Non-error misses: %lu\n"
 		      "Error misses\t: %lu\n",
 		      pte_misses, pte_errors);
-	if (*ppos >= strlen(buffer))
+	if (pos >= strlen(buffer))
 		return 0;
-	if (n > strlen(buffer) - *ppos)
-		n = strlen(buffer) - *ppos;
+	if (n > strlen(buffer) - pos)
+		n = strlen(buffer) - pos;
 	if (n > count)
 		n = count;
-	if (copy_to_user(buf, buffer + *ppos, n))
+	if (copy_to_user(buf, buffer + pos, n))
 		return -EFAULT;
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -333,13 +336,17 @@ ppc_htab_lseek(struct file * file, loff_
     lock_kernel();
     switch (orig) {
     case 0:
-	file->f_pos = offset;
-	ret = file->f_pos;
 	break;
     case 1:
-	file->f_pos += offset;
-	ret = file->f_pos;
+	offset += file->f_pos;
+    default:
+	goto error;
+    }
+    if (offset >= 0) {
+	file->f_pos = offset;
+	ret = offset;
     }
+error:
     unlock_kernel();
     return ret;
 }
Index: linux-2.6.5/arch/ppc/platforms/proc_rtas.c
===================================================================
--- linux-2.6.5.orig/arch/ppc/platforms/proc_rtas.c
+++ linux-2.6.5/arch/ppc/platforms/proc_rtas.c
@@ -265,18 +265,21 @@ static ssize_t ppc_rtas_poweron_read(str
 		size_t count, loff_t *ppos)
 {
 	int n;
+	loff_t pos = *ppos;
+	
+	/* XXX - needs seek locking */
 	if (power_on_time == 0)
 		n = sprintf(buf, "Power on time not set\n");
 	else
 		n = sprintf(buf, "%lu\n", power_on_time);
 
-	if (*ppos >= strlen(buf))
+	if (pos != (unsigned int)pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -302,15 +305,19 @@ static ssize_t ppc_rtas_progress_read(st
 		size_t count, loff_t *ppos)
 {
 	int n = 0;
+	loff_t pos = *ppos;
+	
+	/* XXX - needs seek locking */
+	
 	if (progress_led != NULL)
 		n = sprintf (buf, "%s\n", progress_led);
-	if (*ppos >= strlen(buf))
+	if (pos != (unsigned int)pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -346,7 +353,13 @@ static ssize_t ppc_rtas_clock_read(struc
 {
 	unsigned int year, mon, day, hour, min, sec;
 	unsigned long *ret = kmalloc(4*8, GFP_KERNEL);
+	loff_t pos = *ppos;
 	int n, error;
+	
+	if(ret == NULL)
+		return -ENOMEM;
+		
+	/* Needs seek locking */
 
 	error = call_rtas("get-time-of-day", 0, 8, ret);
 
@@ -362,13 +375,13 @@ static ssize_t ppc_rtas_clock_read(struc
 	}
 	kfree(ret);
 
-	if (*ppos >= strlen(buf))
+	if (pos != (unsigned int)pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -734,15 +747,19 @@ static ssize_t ppc_rtas_tone_freq_read(s
 		size_t count, loff_t *ppos)
 {
 	int n;
+	loff_t pos = *ppos;
+	
+	/* XXX - needs seek locking */
+	
 	n = sprintf(buf, "%lu\n", rtas_tone_frequency);
 
-	if (*ppos >= strlen(buf))
+	if (pos != (unsigned long)pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 /* ****************************************************************** */
@@ -774,15 +791,16 @@ static ssize_t ppc_rtas_tone_volume_writ
 static ssize_t ppc_rtas_tone_volume_read(struct file * file, char * buf,
 		size_t count, loff_t *ppos)
 {
-	int n;
-	n = sprintf(buf, "%lu\n", rtas_tone_volume);
+	int n = sprintf(buf, "%lu\n", rtas_tone_volume);
+	loff_t pos = *ppos;
 
-	if (*ppos >= strlen(buf))
+	/* XXX - Needs locking - actual shouldnt these all have ONE helper */
+	if (pos != (unsigned int) pos || pos >= strlen(buf))
 		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
+	if (n > strlen(buf) - pos)
+		n = strlen(buf) - pos;
 	if (n > count)
 		n = count;
-	*ppos += n;
+	*ppos =  pos + n;
 	return n;
 }
Index: linux-2.6.5/arch/ppc64/kernel/nvram.c
===================================================================
--- linux-2.6.5.orig/arch/ppc64/kernel/nvram.c
+++ linux-2.6.5/arch/ppc64/kernel/nvram.c
@@ -57,6 +57,7 @@ struct err_log_info {
 static loff_t dev_nvram_llseek(struct file *file, loff_t offset, int origin)
 {
 	int size;
+	/* XXX needs locking */
 
 	if (ppc_md.nvram_size == NULL)
 		return -ENODEV;
@@ -83,6 +84,7 @@ static ssize_t dev_nvram_read(struct fil
 	ssize_t len;
 	char *tmp_buffer;
 	int size;
+	loff_t pos = *ppos;
 
 	if (ppc_md.nvram_size == NULL)
 		return -ENODEV;
@@ -90,7 +92,7 @@ static ssize_t dev_nvram_read(struct fil
 
 	if (verify_area(VERIFY_WRITE, buf, count))
 		return -EFAULT;
-	if (*ppos >= size)
+	if (pos >= size || pos < 0 || size < 0)
 		return 0;
 	if (count > size) 
 		count = size;
@@ -101,7 +103,9 @@ static ssize_t dev_nvram_read(struct fil
 		return -ENOMEM;
 	}
 
-	len = ppc_md.nvram_read(tmp_buffer, count, ppos);
+	len = ppc_md.nvram_read(tmp_buffer, count, &pos);
+	*ppos = pos;
+	
 	if ((long)len <= 0) {
 		kfree(tmp_buffer);
 		return len;
@@ -123,6 +127,7 @@ static ssize_t dev_nvram_write(struct fi
 	ssize_t len;
 	char * tmp_buffer;
 	int size;
+	loff_t pos = *ppos;
 
 	if (ppc_md.nvram_size == NULL)
 		return -ENODEV;
@@ -130,7 +135,7 @@ static ssize_t dev_nvram_write(struct fi
 
 	if (verify_area(VERIFY_READ, buf, count))
 		return -EFAULT;
-	if (*ppos >= size)
+	if (pos >= size || pos < 0 || size < 0)
 		return 0;
 	if (count > size)
 		count = size;
@@ -146,7 +151,9 @@ static ssize_t dev_nvram_write(struct fi
 		return -EFAULT;
 	}
 
-	len = ppc_md.nvram_write(tmp_buffer, count, ppos);
+	len = ppc_md.nvram_write(tmp_buffer, count, &pos);
+	*ppos = pos;
+	
 	if ((long)len <= 0) {
 		kfree(tmp_buffer);
 		return len;
Index: linux-2.6.5/arch/ppc64/kernel/proc_ppc64.c
===================================================================
--- linux-2.6.5.orig/arch/ppc64/kernel/proc_ppc64.c
+++ linux-2.6.5/arch/ppc64/kernel/proc_ppc64.c
@@ -140,6 +140,7 @@ __initcall(proc_ppc64_init);
 
 static loff_t page_map_seek( struct file *file, loff_t off, int whence)
 {
+	/* XXX - locking needed */
 	loff_t new;
 	struct proc_dir_entry *dp = PDE(file->f_dentry->d_inode);
 
@@ -163,10 +164,10 @@ static loff_t page_map_seek( struct file
 
 static ssize_t page_map_read( struct file *file, char *buf, size_t nbytes, loff_t *ppos)
 {
-	unsigned pos = *ppos;
+	loff_t pos = *ppos;
 	struct proc_dir_entry *dp = PDE(file->f_dentry->d_inode);
 
-	if ( pos >= dp->size )
+	if ( pos < 0 || pos >= dp->size )
 		return 0;
 	if ( nbytes >= dp->size )
 		nbytes = dp->size;
Index: linux-2.6.5/arch/ppc64/kernel/rtas-proc.c
===================================================================
--- linux-2.6.5.orig/arch/ppc64/kernel/rtas-proc.c
+++ linux-2.6.5/arch/ppc64/kernel/rtas-proc.c
@@ -294,22 +294,24 @@ static ssize_t ppc_rtas_poweron_read(str
 {
 	char stkbuf[40];  /* its small, its on stack */
 	int n, sn;
+	loff_t pos = *ppos;
+	
 	if (power_on_time == 0)
 		n = scnprintf(stkbuf,sizeof(stkbuf),"Power on time not set\n");
 	else
 		n = scnprintf(stkbuf,sizeof(stkbuf),"%lu\n",power_on_time);
 
 	sn = strlen (stkbuf) +1;
-	if (*ppos >= sn)
+	if (pos != (unsigned int)pos || pos >= sn)
 		return 0;
-	if (n > sn - *ppos)
-		n = sn - *ppos;
+	if (n > sn - pos)
+		n = sn - pos;
 	if (n > count)
 		n = count;
-	if (copy_to_user (buf, stkbuf + (*ppos), n)) {
+	if (copy_to_user (buf, stkbuf + pos, n)) {
 		return -EFAULT;
 	}
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -341,6 +343,7 @@ static ssize_t ppc_rtas_progress_read(st
 {
 	int sn, n = 0;
 	char *tmpbuf;
+	loff_t pos = *ppos;
 
 	if (progress_led == NULL) return 0;
 
@@ -352,20 +355,20 @@ static ssize_t ppc_rtas_progress_read(st
 	n = sprintf (tmpbuf, "%s\n", progress_led);
 
 	sn = strlen (tmpbuf) +1;
-	if (*ppos >= sn) {
+	if (pos != (unsigned int)pos || pos >= sn) {
 		kfree (tmpbuf);
 		return 0;
 	}
-	if (n > sn - *ppos)
-		n = sn - *ppos;
+	if (n > sn - pos)
+		n = sn - pos;
 	if (n > count)
 		n = count;
-	if (copy_to_user (buf, tmpbuf + (*ppos), n)) {
+	if (copy_to_user (buf, tmpbuf + pos, n)) {
 		kfree (tmpbuf);
 		return -EFAULT;
 	}
 	kfree (tmpbuf);
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -409,7 +412,11 @@ static ssize_t ppc_rtas_clock_read(struc
 	unsigned long *ret = kmalloc(4*8, GFP_KERNEL);
 	int n, sn, error;
 	char stkbuf[40];  /* its small, its on stack */
+	loff_t pos = *ppos;
 
+	if(ret == NULL)
+		return -ENOMEM;
+		
 	error = rtas_call(rtas_token("get-time-of-day"), 0, 8, ret);
 	
 	year = ret[0]; mon  = ret[1]; day  = ret[2];
@@ -426,16 +433,16 @@ static ssize_t ppc_rtas_clock_read(struc
 	kfree(ret);
 
 	sn = strlen (stkbuf) +1;
-	if (*ppos >= sn)
+	if (pos != (unsigned int)pos || pos >= sn)
 		return 0;
-	if (n > sn - *ppos)
-		n = sn - *ppos;
+	if (n > sn - pos)
+		n = sn - pos;
 	if (n > count)
 		n = count;
-	if (copy_to_user (buf, stkbuf + (*ppos), n)) {
+	if (copy_to_user (buf, stkbuf + pos, n)) {
 		return -EFAULT;
 	}
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -846,7 +853,8 @@ static ssize_t ppc_rtas_tone_freq_write(
 	char *dest;
 	int error;
 
-	if (39 < count) count = 39;
+	if (39 < count)
+		count = 39;
 	if (copy_from_user (stkbuf, buf, count)) {
 		return -EFAULT;
 	}
@@ -871,20 +879,21 @@ static ssize_t ppc_rtas_tone_freq_read(s
 {
 	int n, sn;
 	char stkbuf[40];  /* its small, its on stack */
+	loff_t pos = *ppos;
 
 	n = scnprintf(stkbuf, 40, "%lu\n", rtas_tone_frequency);
 
 	sn = strlen (stkbuf) +1;
-	if (*ppos >= sn)
+	if (pos != (unsigned int)pos || pos >= sn)
 		return 0;
-	if (n > sn - *ppos)
-		n = sn - *ppos;
+	if (n > sn - pos)
+		n = sn - pos;
 	if (n > count)
 		n = count;
-	if (copy_to_user (buf, stkbuf + (*ppos), n)) {
+	if (copy_to_user (buf, stkbuf + pos, n)) {
 		return -EFAULT;
 	}
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 /* ****************************************************************** */
@@ -925,20 +934,21 @@ static ssize_t ppc_rtas_tone_volume_read
 {
 	int n, sn;
 	char stkbuf[40];  /* its small, its on stack */
+	loff_t pos = *ppos;
 
 	n = scnprintf(stkbuf, 40, "%lu\n", rtas_tone_volume);
 
 	sn = strlen (stkbuf) +1;
-	if (*ppos >= sn)
+	if (pos != (unsigned int)pos || pos >= sn)
 		return 0;
-	if (n > sn - *ppos)
-		n = sn - *ppos;
+	if (n > sn - pos)
+		n = sn - pos;
 	if (n > count)
 		n = count;
 	if (copy_to_user (buf, stkbuf + (*ppos), n)) {
 		return -EFAULT;
 	}
-	*ppos += n;
+	*ppos = pos + n;
 	return n;
 }
 
@@ -955,14 +965,13 @@ static ssize_t ppc_rtas_rmo_buf_read(str
 	if (n > count)
 		n = count;
 
-	if (ppos && *ppos != 0)
+	if (*ppos != 0)
 		return 0;
 
 	if (copy_to_user(buf, kbuf, n))
 		return -EFAULT;
 
-	if (ppos)
-		*ppos = n;
+	*ppos = n;
 	
 	return n;
 }
Index: linux-2.6.5/arch/ppc64/kernel/rtas_flash.c
===================================================================
--- linux-2.6.5.orig/arch/ppc64/kernel/rtas_flash.c
+++ linux-2.6.5/arch/ppc64/kernel/rtas_flash.c
@@ -238,7 +238,7 @@ static ssize_t rtas_flash_read(struct fi
 	if (msglen > count)
 		msglen = count;
 
-	if (ppos && *ppos != 0)
+	if (*ppos != 0)
 		return 0;	/* be cheap */
 
 	error = verify_area(VERIFY_WRITE, buf, msglen);
@@ -248,8 +248,7 @@ static ssize_t rtas_flash_read(struct fi
 	if (copy_to_user(buf, msg, msglen))
 		return -EFAULT;
 
-	if (ppos)
-		*ppos = msglen;
+	*ppos = msglen;
 	return msglen;
 }
 
@@ -375,7 +374,7 @@ static ssize_t manage_flash_read(struct 
 	if (msglen > count)
 		msglen = count;
 
-	if (ppos && *ppos != 0)
+	if (*ppos != 0)
 		return 0;	/* be cheap */
 
 	error = verify_area(VERIFY_WRITE, buf, msglen);
@@ -385,8 +384,7 @@ static ssize_t manage_flash_read(struct 
 	if (copy_to_user(buf, msg, msglen))
 		return -EFAULT;
 
-	if (ppos)
-		*ppos = msglen;
+	*ppos = msglen;
 	return msglen;
 }
 
@@ -481,7 +479,7 @@ static ssize_t validate_flash_read(struc
 
 	args_buf = (struct rtas_validate_flash_t *) dp->data;
 
-	if (ppos && *ppos != 0)
+	if (*ppos != 0)
 		return 0;	/* be cheap */
 	
 	msglen = get_validate_flash_msg(args_buf, msg);
@@ -495,8 +493,7 @@ static ssize_t validate_flash_read(struc
 	if (copy_to_user(buf, msg, msglen))
 		return -EFAULT;
 
-	if (ppos)
-		*ppos = msglen;
+	*ppos = msglen;
 	return msglen;
 }
 
Index: linux-2.6.5/arch/s390/kernel/debug.c
===================================================================
--- linux-2.6.5.orig/arch/s390/kernel/debug.c
+++ linux-2.6.5/arch/s390/kernel/debug.c
@@ -427,7 +427,7 @@ static ssize_t debug_output(struct file 
 
 	p_info = ((file_private_info_t *) file->private_data);
 	if (*offset != p_info->offset) 
-		return -EPIPE;
+		return -ESPIPE;
 	if(p_info->act_area >= p_info->debug_info_snap->nr_areas)
 		return 0;
 
@@ -449,7 +449,7 @@ static ssize_t debug_output(struct file 
 				goto out;
 	}
 out:
-	p_info->offset           = *offset + count;
+	p_info->offset           += count;
 	p_info->act_entry_offset = size;	
 	*offset = p_info->offset;
 	return count;
@@ -964,7 +964,7 @@ static int debug_input_level_fn(debug_in
 		       input_buf[0]);
 	}
       out:
-	*offset += in_buf_size;
+	*offset = in_buf_size;
 	return rc;		/* number of input characters */
 }
 
@@ -1031,7 +1031,7 @@ static int debug_input_flush_fn(debug_in
         printk(KERN_INFO "debug: area `%c` is not valid\n", input_buf[0]);
 
       out:
-        *offset += in_buf_size;
+        *offset = in_buf_size;
         return rc;              /* number of input characters */
 }
 
Index: linux-2.6.5/drivers/acpi/system.c
===================================================================
--- linux-2.6.5.orig/drivers/acpi/system.c
+++ linux-2.6.5/drivers/acpi/system.c
@@ -94,16 +94,22 @@ acpi_system_read_dsdt (
 	struct acpi_buffer	dsdt = {ACPI_ALLOCATE_BUFFER, NULL};
 	void			*data = 0;
 	size_t			size = 0;
+	loff_t			pos = *ppos;
 
 	ACPI_FUNCTION_TRACE("acpi_system_read_dsdt");
+	
+	/* XXX - seek locking required */
 
 	status = acpi_get_table(ACPI_TABLE_DSDT, 1, &dsdt);
 	if (ACPI_FAILURE(status))
 		return_VALUE(-ENODEV);
 
-	if (*ppos < dsdt.length) {
-		data = dsdt.pointer + file->f_pos;
-		size = dsdt.length - file->f_pos;
+	if (pos < 0)
+		return -EINVAL;
+		
+	if (pos < dsdt.length) {
+		data = dsdt.pointer + pos;
+		size = dsdt.length - pos;
 		if (size > count)
 			size = count;
 		if (copy_to_user(buffer, data, size)) {
@@ -114,7 +120,7 @@ acpi_system_read_dsdt (
 
 	acpi_os_free(dsdt.pointer);
 
-	*ppos += size;
+	*ppos = pos + size;
 
 	return_VALUE(size);
 }
@@ -137,6 +143,7 @@ acpi_system_read_fadt (
 	struct acpi_buffer	fadt = {ACPI_ALLOCATE_BUFFER, NULL};
 	void			*data = 0;
 	size_t			size = 0;
+	loff_t			pos = *ppos;
 
 	ACPI_FUNCTION_TRACE("acpi_system_read_fadt");
 
@@ -144,9 +151,13 @@ acpi_system_read_fadt (
 	if (ACPI_FAILURE(status))
 		return_VALUE(-ENODEV);
 
-	if (*ppos < fadt.length) {
-		data = fadt.pointer + file->f_pos;
-		size = fadt.length - file->f_pos;
+	/* XXX - seek locking required */
+	if (pos < 0)
+		return -EINVAL;
+		
+	if (pos < fadt.length) {
+		data = fadt.pointer + pos;
+		size = fadt.length - pos;
 		if (size > count)
 			size = count;
 		if (copy_to_user(buffer, data, size)) {
@@ -157,7 +168,7 @@ acpi_system_read_fadt (
 
 	acpi_os_free(fadt.pointer);
 
-	*ppos += size;
+	*ppos = pos + size;
 
 	return_VALUE(size);
 }
Index: linux-2.6.5/drivers/char/generic_nvram.c
===================================================================
--- linux-2.6.5.orig/drivers/char/generic_nvram.c
+++ linux-2.6.5/drivers/char/generic_nvram.c
@@ -22,12 +22,15 @@
 #include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 #include <asm/nvram.h>
+#include <asm/semaphore.h>
 
 #define NVRAM_SIZE	8192
 
+static DECLARE_MUTEX(nvram_sem);
+
 static loff_t nvram_llseek(struct file *file, loff_t offset, int origin)
 {
-	lock_kernel();
+	down(&nvram_sem);
 	switch (origin) {
 	case 1:
 		offset += file->f_pos;
@@ -37,48 +40,57 @@ static loff_t nvram_llseek(struct file *
 		break;
 	}
 	if (offset < 0) {
-		unlock_kernel();
+		up(&nvram_sem);
 		return -EINVAL;
 	}
 	file->f_pos = offset;
-	unlock_kernel();
+	up(&nvram_sem);
 	return file->f_pos;
 }
 
 static ssize_t read_nvram(struct file *file, char __user *buf,
 			  size_t count, loff_t *ppos)
 {
-	unsigned int i;
+	loff_t i;
 	char __user *p = buf;
-
+	
 	if (verify_area(VERIFY_WRITE, buf, count))
 		return -EFAULT;
-	if (*ppos >= NVRAM_SIZE)
-		return 0;
+		
+	down(&nvram_sem);
+	/* If we are already off the end then we report 0 anyway .. */
 	for (i = *ppos; count > 0 && i < NVRAM_SIZE; ++i, ++p, --count)
 		if (__put_user(nvram_read_byte(i), p))
+		{
+			up(&nvram_sem);
 			return -EFAULT;
+		}
 	*ppos = i;
+	up(&nvram_sem);
 	return p - buf;
 }
 
 static ssize_t write_nvram(struct file *file, const char __user *buf,
 			   size_t count, loff_t *ppos)
 {
-	unsigned int i;
+	loff_t i;
 	const char __user *p = buf;
 	char c;
 
 	if (verify_area(VERIFY_READ, buf, count))
 		return -EFAULT;
-	if (*ppos >= NVRAM_SIZE)
-		return 0;
+		
+	down(&nvram_sem);
+	/* if *ppos > end then we return 0 anyway */
 	for (i = *ppos; count > 0 && i < NVRAM_SIZE; ++i, ++p, --count) {
-		if (__get_user(c, p))
+		if (__get_user(c, p)) {
+			up(&nvram_sem);
 			return -EFAULT;
+		}
 		nvram_write_byte(c, i);
 	}
 	*ppos = i;
+	up(&nvram_sem);
 	return p - buf;
 }
 
Index: linux-2.6.5/drivers/char/i8k.c
===================================================================
--- linux-2.6.5.orig/drivers/char/i8k.c
+++ linux-2.6.5/drivers/char/i8k.c
@@ -464,27 +464,31 @@ static int i8k_get_info(char *buffer, ch
 
 static ssize_t i8k_read(struct file *f, char *buffer, size_t len, loff_t *fpos)
 {
+    loff_t pos = *fpos;
     int n;
     char info[128];
+    
+    /* XXX - seek locking required */
 
     n = i8k_get_info(info, NULL, 0, 128);
-    if (n <= 0) {
+    if (n <= 0)
 	return n;
-    }
+	
+    if (pos < 0)
+    	return -EINVAL;
 
-    if (*fpos >= n) {
+    if (pos >= n) {
 	return 0;
     }
 
-    if ((*fpos + len) >= n) {
-	len = n - *fpos;
-    }
+    if (len > n - pos - 1)
+	    len = n - pos - 1;
 
     if (copy_to_user(buffer, info, len) != 0) {
 	return -EFAULT;
     }
 
-    *fpos += len;
+    *fpos = pos + len;
     return len;
 }
 
Index: linux-2.6.5/drivers/char/istallion.c
===================================================================
--- linux-2.6.5.orig/drivers/char/istallion.c
+++ linux-2.6.5/drivers/char/istallion.c
@@ -848,7 +848,7 @@ static void __exit istallion_module_exit
 	i = tty_unregister_driver(stli_serial);
 	if (i) {
 		printk("STALLION: failed to un-register tty driver, "
-			"errno=%d,%d\n", -i);
+			"errno=%d\n", -i);
 		restore_flags(flags);
 		return;
 	}
@@ -4697,7 +4697,7 @@ static stlibrd_t *stli_allocbrd()
 	brdp = (stlibrd_t *) stli_memalloc(sizeof(stlibrd_t));
 	if (brdp == (stlibrd_t *) NULL) {
 		printk(KERN_ERR "STALLION: failed to allocate memory "
-				"(size=%d)\n", sizeof(stlibrd_t));
+				"(size=%d)\n", (int) sizeof(stlibrd_t));
 		return((stlibrd_t *) NULL);
 	}
 
@@ -4816,6 +4816,7 @@ static ssize_t stli_memread(struct file 
 	void		*memptr;
 	stlibrd_t	*brdp;
 	int		brdnr, size, n;
+	loff_t		pos = *offp;
 
 #if DEBUG
 	printk(KERN_DEBUG "stli_memread(fp=%x,buf=%x,count=%x,offp=%x)\n",
@@ -4830,26 +4831,27 @@ static ssize_t stli_memread(struct file 
 		return(-ENODEV);
 	if (brdp->state == 0)
 		return(-ENODEV);
-	if (fp->f_pos >= brdp->memsize)
+	if (pos < 0 || pos >= brdp->memsize)
 		return(0);
 
-	size = MIN(count, (brdp->memsize - fp->f_pos));
+	size = MIN(count, (brdp->memsize - pos));
 
 	save_flags(flags);
 	cli();
 	EBRDENABLE(brdp);
 	while (size > 0) {
 		memptr = (void *) EBRDGETMEMPTR(brdp, fp->f_pos);
-		n = MIN(size, (brdp->pagesize - (((unsigned long) fp->f_pos) % brdp->pagesize)));
+		n = MIN(size, (brdp->pagesize - (((unsigned long) pos) % brdp->pagesize)));
 		if (copy_to_user(buf, memptr, n)) {
 			count = -EFAULT;
 			goto out;
 		}
-		fp->f_pos += n;
+		pos += n;
 		buf += n;
 		size -= n;
 	}
 out:
+	*offp = pos;
 	EBRDDISABLE(brdp);
 	restore_flags(flags);
 
@@ -4871,7 +4873,8 @@ static ssize_t stli_memwrite(struct file
 	stlibrd_t	*brdp;
 	char		*chbuf;
 	int		brdnr, size, n;
-
+	loff_t		pos = *offp;
+	
 #if DEBUG
 	printk(KERN_DEBUG "stli_memwrite(fp=%x,buf=%x,count=%x,offp=%x)\n",
 			(int) fp, (int) buf, count, (int) offp);
@@ -4885,26 +4888,27 @@ static ssize_t stli_memwrite(struct file
 		return(-ENODEV);
 	if (brdp->state == 0)
 		return(-ENODEV);
-	if (fp->f_pos >= brdp->memsize)
+	if (pos < 0 || pos >= brdp->memsize)
 		return(0);
 
 	chbuf = (char *) buf;
-	size = MIN(count, (brdp->memsize - fp->f_pos));
+	size = MIN(count, (brdp->memsize - pos));
 
 	save_flags(flags);
 	cli();
 	EBRDENABLE(brdp);
 	while (size > 0) {
-		memptr = (void *) EBRDGETMEMPTR(brdp, fp->f_pos);
-		n = MIN(size, (brdp->pagesize - (((unsigned long) fp->f_pos) % brdp->pagesize)));
+		memptr = (void *) EBRDGETMEMPTR(brdp, pos);
+		n = MIN(size, (brdp->pagesize - (((unsigned long) pos) % brdp->pagesize)));
 		if (copy_from_user(memptr, chbuf, n)) {
 			count = -EFAULT;
 			goto out;
 		}
-		fp->f_pos += n;
+		pos += n;
 		chbuf += n;
 		size -= n;
 	}
+	*offp = pos;
 out:
 	EBRDDISABLE(brdp);
 	restore_flags(flags);
Index: linux-2.6.5/drivers/char/mem.c
===================================================================
--- linux-2.6.5.orig/drivers/char/mem.c
+++ linux-2.6.5/drivers/char/mem.c
@@ -143,7 +143,7 @@ static ssize_t do_write_mem(void *p, uns
 		return -EFAULT;
 	}
 	written += count;
-	*ppos += written;
+	*ppos = realp + written;
 	return written;
 }
 
@@ -180,7 +180,7 @@ static ssize_t read_mem(struct file * fi
 	if (copy_to_user(buf, __va(p), count))
 		return -EFAULT;
 	read += count;
-	*ppos += read;
+	*ppos = p + read;
 	return read;
 }
 
Index: linux-2.6.5/drivers/ieee1394/pcilynx.c
===================================================================
--- linux-2.6.5.orig/drivers/ieee1394/pcilynx.c
+++ linux-2.6.5/drivers/ieee1394/pcilynx.c
@@ -1052,12 +1052,13 @@ static ssize_t mem_read(struct file *fil
         ssize_t retval;
         void *membase;
 
-        if ((off + count) > PCILYNX_MAX_MEMORY+1) {
-                count = PCILYNX_MAX_MEMORY+1 - off;
-        }
-        if (count == 0 || off > PCILYNX_MAX_MEMORY) {
+	/* XXX - should do proper locking instead */
+	if (off < 0)
+		return -EINVAL;
+	if (off > PCILYNX_MAX_MEMORY)
                 return -ENOSPC;
-        }
+        if (count > PCILYNX_MAX_MEMORY + 1 - off)
+                count = PCILYNX_MAX_MEMORY + 1 - off;
 
         switch (md->type) {
         case rom:
@@ -1078,6 +1079,7 @@ static ssize_t mem_read(struct file *fil
 
         if (count < mem_mindma) {
                 memcpy_fromio(md->lynx->mem_dma_buffer, membase+off, count);
+                off += count;
                 goto out;
         }
 
@@ -1108,14 +1110,16 @@ static ssize_t mem_read(struct file *fil
         if (bcount) {
                 memcpy_fromio(md->lynx->mem_dma_buffer + count - bcount,
                               membase+off, bcount);
+                off += bcount;
         }
 
  out:
         retval = copy_to_user(buffer, md->lynx->mem_dma_buffer, count);
         up(&md->lynx->mem_dma_mutex);
 
-	if (retval) return -EFAULT;
-        *offset += count;
+	if (retval < 0)  
+		return -EFAULT;
+        *offset = off;
         return count;
 }
 
@@ -1124,32 +1128,34 @@ static ssize_t mem_write(struct file *fi
                          loff_t *offset)
 {
         struct memdata *md = (struct memdata *)file->private_data;
+        loff_t off = * offset;
+        
+	if (off < 0)
+		return -EINVAL;
+	if (off > PCILYNX_MAX_MEMORY)
+		return -ENOSPC;
 
-        if (((*offset) + count) > PCILYNX_MAX_MEMORY+1) {
-                count = PCILYNX_MAX_MEMORY+1 - *offset;
-        }
-        if (count == 0 || *offset > PCILYNX_MAX_MEMORY) {
-                return -ENOSPC;
-        }
+        if (count > PCILYNX_MAX_MEMORY + 1 - off)
+                count = PCILYNX_MAX_MEMORY + 1 - off;
 
         /* FIXME: dereferencing pointers to PCI mem doesn't work everywhere */
         switch (md->type) {
         case aux:
-		if (copy_from_user(md->lynx->aux_port+(*offset), buffer, count))
+		if (copy_from_user(md->lynx->aux_port+off, buffer, count))
 			return -EFAULT;
                 break;
         case ram:
-		if (copy_from_user(md->lynx->local_ram+(*offset), buffer, count))
+		if (copy_from_user(md->lynx->local_ram+off, buffer, count))
 			return -EFAULT;
                 break;
         case rom:
                 /* the ROM may be writeable */
-		if (copy_from_user(md->lynx->local_rom+(*offset), buffer, count))
+		if (copy_from_user(md->lynx->local_rom+off, buffer, count))
 			return -EFAULT;
                 break;
         }
 
-        file->f_pos += count;
+        *offset = off + count;
         return count;
 }
 #endif /* CONFIG_IEEE1394_PCILYNX_PORTS */
Index: linux-2.6.5/drivers/isdn/hysdn/hysdn_procconf.c
===================================================================
--- linux-2.6.5.orig/drivers/isdn/hysdn/hysdn_procconf.c
+++ linux-2.6.5/drivers/isdn/hysdn/hysdn_procconf.c
@@ -211,29 +211,27 @@ hysdn_conf_write(struct file *file, cons
 static ssize_t
 hysdn_conf_read(struct file *file, char *buf, size_t count, loff_t * off)
 {
+	loff_t pos = *off;
 	char *cp;
 	int i;
 
 	if (off != &file->f_pos)	/* fs error check */
 		return -ESPIPE;
 
-	if (file->f_mode & FMODE_READ) {
-		if (!(cp = file->private_data))
-			return (-EFAULT);	/* should never happen */
-		i = strlen(cp);	/* get total string length */
-		if (*off < i) {
-			/* still bytes to transfer */
-			cp += *off;	/* point to desired data offset */
-			i -= *off;	/* remaining length */
-			if (i > count)
-				i = count;	/* limit length to transfer */
-			if (copy_to_user(buf, cp, i))
-				return (-EFAULT);	/* copy error */
-			*off += i;	/* adjust offset */
-		} else
-			return (0);
+	if (!(cp = file->private_data))
+		return (-EFAULT);	/* should never happen */
+	i = strlen(cp);	/* get total string length */
+	if (pos >= 0 && pos < i) {
+		/* still bytes to transfer */
+		cp += pos;	/* point to desired data offset */
+		i -= pos;	/* remaining length */
+		if (i > count)
+			i = count;	/* limit length to transfer */
+		if (copy_to_user(buf, cp, i))
+			return (-EFAULT);	/* copy error */
+		*off = pos + i;	/* adjust offset */
 	} else
-		return (-EPERM);	/* no permission to read */
+		return 0;
 
 	return (i);
 }				/* hysdn_conf_read */
Index: linux-2.6.5/drivers/isdn/hysdn/hysdn_proclog.c
===================================================================
--- linux-2.6.5.orig/drivers/isdn/hysdn/hysdn_proclog.c
+++ linux-2.6.5/drivers/isdn/hysdn/hysdn_proclog.c
@@ -210,6 +210,7 @@ hysdn_log_read(struct file *file, char *
 	struct proc_dir_entry *pde = PDE(file->f_dentry->d_inode);
 	struct procdata *pd = NULL;
 	hysdn_card *card;
+	loff_t pos = *off;
 
 	if (!*((struct log_data **) file->private_data)) {
 		if (file->f_flags & O_NONBLOCK)
@@ -237,7 +238,7 @@ hysdn_log_read(struct file *file, char *
 	if ((len = strlen(inf->log_start)) <= count) {
 		if (copy_to_user(buf, inf->log_start, len))
 			return -EFAULT;
-		file->f_pos += len;
+		*off = pos + len;
 		return (len);
 	}
 	return (0);
Index: linux-2.6.5/drivers/isdn/i4l/isdn_common.c
===================================================================
--- linux-2.6.5.orig/drivers/isdn/i4l/isdn_common.c
+++ linux-2.6.5/drivers/isdn/i4l/isdn_common.c
@@ -947,7 +947,7 @@ isdn_info_update(void)
 }
 
 static ssize_t
-isdn_read(struct file *file, char *buf, size_t count, loff_t * off)
+isdn_read(struct file *file, char *buf, size_t count, loff_t * poff)
 {
 	uint minor = MINOR(file->f_dentry->d_inode->i_rdev);
 	int len = 0;
@@ -955,11 +955,14 @@ isdn_read(struct file *file, char *buf, 
 	int chidx;
 	int retval;
 	char *p;
+	loff_t off;
 
-	if (off != &file->f_pos)
+	if (poff != &file->f_pos)
 		return -ESPIPE;
 
 	lock_kernel();
+	off = *poff;
+	
 	if (minor == ISDN_MINOR_STATUS) {
 		if (!file->private_data) {
 			if (file->f_flags & O_NONBLOCK) {
@@ -975,7 +978,7 @@ isdn_read(struct file *file, char *buf, 
 				retval = -EFAULT;
 				goto out;
 			}
-			*off += len;
+			off += len;
 			retval = len;
 			goto out;
 		}
@@ -1004,7 +1007,7 @@ isdn_read(struct file *file, char *buf, 
 		}
 		len = isdn_readbchan(drvidx, chidx, p, 0, count,
 				     &dev->drv[drvidx]->rcv_waitq[chidx]);
-		*off += len;
+		off += len;
 		if (copy_to_user(buf,p,len)) 
 			len = -EFAULT;
 		kfree(p);
@@ -1037,7 +1040,7 @@ isdn_read(struct file *file, char *buf, 
 			dev->drv[drvidx]->stavail -= len;
 		else
 			dev->drv[drvidx]->stavail = 0;
-		*off += len;
+		off += len;
 		retval = len;
 		goto out;
 	}
@@ -1049,6 +1052,7 @@ isdn_read(struct file *file, char *buf, 
 #endif
 	retval = -ENODEV;
  out:
+ 	*poff = off;
 	unlock_kernel();
 	return retval;
 }
Index: linux-2.6.5/drivers/mtd/mtdchar.c
===================================================================
--- linux-2.6.5.orig/drivers/mtd/mtdchar.c
+++ linux-2.6.5/drivers/mtd/mtdchar.c
@@ -30,6 +30,8 @@ static loff_t mtd_lseek (struct file *fi
 {
 	struct mtd_info *mtd=(struct mtd_info *)file->private_data;
 
+
+	down(&mtd->mutex);
 	switch (orig) {
 	case 0:
 		/* SEEK_SET */
@@ -44,14 +46,16 @@ static loff_t mtd_lseek (struct file *fi
 		file->f_pos =mtd->size + offset;
 		break;
 	default:
+		up(&mtd->mutex);
 		return -EINVAL;
 	}
 
+	/* XXX Should return -EINVAL surely ?? */
 	if (file->f_pos < 0)
 		file->f_pos = 0;
 	else if (file->f_pos >= mtd->size)
 		file->f_pos = mtd->size - 1;
-
+	up(&mtd->mutex);
 	return file->f_pos;
 }
 
@@ -127,11 +131,16 @@ static ssize_t mtd_read(struct file *fil
 	
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
 
-	if (*ppos + count > mtd->size)
+	down(&mtd->mutex);
+	
+	if (count > mtd->size - *ppos)
 		count = mtd->size - *ppos;
 
 	if (!count)
+	{
+		up(&mtd->mutex);
 		return 0;
+	}
 	
 	/* FIXME: Use kiovec in 2.5 to lock down the user's buffers
 	   and pass them directly to the MTD functions */
@@ -143,13 +152,18 @@ static ssize_t mtd_read(struct file *fil
 
 		kbuf=kmalloc(len,GFP_KERNEL);
 		if (!kbuf)
+		{
+			up(&mtd->mutex);
+			/* API error - should return I/O done so far if > 0 */
 			return -ENOMEM;
-		
+		}		
 		ret = MTD_READ(mtd, *ppos, len, &retlen, kbuf);
 		if (!ret) {
 			*ppos += retlen;
 			if (copy_to_user(buf, kbuf, retlen)) {
 			        kfree(kbuf);
+			        up(&mtd->mutex);
+				/* API error - should return I/O done so far if > 0 */
 				return -EFAULT;
 			}
 			else
@@ -160,12 +174,13 @@ static ssize_t mtd_read(struct file *fil
 		}
 		else {
 			kfree(kbuf);
+			up(&mtd->mutex);
 			return ret;
 		}
 		
 		kfree(kbuf);
 	}
-	
+	up(&mtd->mutex);	
 	return total_retlen;
 } /* mtd_read */
 
@@ -179,15 +194,22 @@ static ssize_t mtd_write(struct file *fi
 	int len;
 
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
-	
-	if (*ppos == mtd->size)
+
+	down(&mtd->mutex);	
+	if (*ppos >= mtd->size)
+	{
+		up(&mtd->mutex);
 		return -ENOSPC;
+	}
 	
-	if (*ppos + count > mtd->size)
+	if (count > mtd->size - *ppos)
 		count = mtd->size - *ppos;
 
 	if (!count)
+	{
+		up(&mtd->mutex);
 		return 0;
+	}
 
 	while (count) {
 		if (count > MAX_KMALLOC_SIZE) 
@@ -197,11 +219,14 @@ static ssize_t mtd_write(struct file *fi
 
 		kbuf=kmalloc(len,GFP_KERNEL);
 		if (!kbuf) {
-			printk("kmalloc is null\n");
+//			printk("kmalloc is null\n");
+			/* API bug should report I/O completed */
+			up(&mtd->mutex);
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(kbuf, buf, len)) {
+			up(&mtd->mutex);
 			kfree(kbuf);
 			return -EFAULT;
 		}
@@ -214,13 +239,15 @@ static ssize_t mtd_write(struct file *fi
 			buf += retlen;
 		}
 		else {
+			up(&mtd->mutex);
 			kfree(kbuf);
+			/* API bug ?? */
 			return ret;
 		}
 		
 		kfree(kbuf);
 	}
-
+	up(&mtd->mutex);
 	return total_retlen;
 } /* mtd_write */
 
Index: linux-2.6.5/drivers/mtd/mtdcore.c
===================================================================
--- linux-2.6.5.orig/drivers/mtd/mtdcore.c
+++ linux-2.6.5/drivers/mtd/mtdcore.c
@@ -59,6 +59,7 @@ int add_mtd_device(struct mtd_info *mtd)
 			mtd_table[i] = mtd;
 			mtd->index = i;
 			mtd->usecount = 0;
+			init_MUTEX(&mtd->mutex);
 
 			DEBUG(0, "mtd: Giving out device %d to %s\n",i, mtd->name);
 			/* No need to get a refcount on the module containing
Index: linux-2.6.5/drivers/oprofile/oprofilefs.c
===================================================================
--- linux-2.6.5.orig/drivers/oprofile/oprofilefs.c
+++ linux-2.6.5/drivers/oprofile/oprofilefs.c
@@ -48,20 +48,25 @@ static struct super_operations s_ops = {
 ssize_t oprofilefs_str_to_user(char const * str, char * buf, size_t count, loff_t * offset)
 {
 	size_t len = strlen(str);
+	loff_t pos = *offset;
+	
+	/* XXX - should do proper seek locking instead */
+	if(pos < 0)
+		return -EINVAL;
 
 	if (!count)
 		return 0;
 
-	if (*offset > len)
+	if (pos > len)
 		return 0;
 
-	if (count > len - *offset)
-		count = len - *offset;
+	if (count > len - pos)
+		count = len - pos;
 
-	if (copy_to_user(buf, str + *offset, count))
+	if (copy_to_user(buf, str + pos, count))
 		return -EFAULT;
 
-	*offset += count;
+	*offset = pos + count;
 
 	return count;
 }
@@ -73,9 +78,14 @@ ssize_t oprofilefs_ulong_to_user(unsigne
 {
 	char tmpbuf[TMPBUFSIZE];
 	size_t maxlen;
+	loff_t pos = *offset;
 
 	if (!count)
 		return 0;
+	
+	/* XXX - should do proper seek locking instead */
+	if(pos < 0)
+		return -EINVAL;
 
 	spin_lock(&oprofilefs_lock);
 	maxlen = snprintf(tmpbuf, TMPBUFSIZE, "%lu\n", val);
@@ -83,16 +93,16 @@ ssize_t oprofilefs_ulong_to_user(unsigne
 	if (maxlen > TMPBUFSIZE)
 		maxlen = TMPBUFSIZE;
 
-	if (*offset > maxlen)
+	if (pos > maxlen)
 		return 0;
 
-	if (count > maxlen - *offset)
-		count = maxlen - *offset;
+	if (count > maxlen - pos)
+		count = maxlen - pos;
 
-	if (copy_to_user(buf, tmpbuf + *offset, count))
+	if (copy_to_user(buf, tmpbuf + pos, count))
 		return -EFAULT;
 
-	*offset += count;
+	*offset = pos + count;
 
 	return count;
 }
Index: linux-2.6.5/drivers/pnp/isapnp/proc.c
===================================================================
--- linux-2.6.5.orig/drivers/pnp/isapnp/proc.c
+++ linux-2.6.5/drivers/pnp/isapnp/proc.c
@@ -26,6 +26,9 @@
 #include <linux/init.h>
 #include <linux/smp_lock.h>
 #include <asm/uaccess.h>
+#include <asm/semaphore.h>
+
+static DECLARE_MUTEX(isapnp_mutex);	/* Don't whack two things at once */
 
 extern struct pnp_protocol isapnp_protocol;
 
@@ -35,7 +38,7 @@ static loff_t isapnp_proc_bus_lseek(stru
 {
 	loff_t new = -1;
 
-	lock_kernel();
+	down(&isapnp_mutex);
 	switch (whence) {
 	case 0:
 		new = off;
@@ -48,11 +51,12 @@ static loff_t isapnp_proc_bus_lseek(stru
 		break;
 	}
 	if (new < 0 || new > 256) {
-		unlock_kernel();
+		up(&isapnp_mutex);
 		return -EINVAL;
 	}
-	unlock_kernel();
-	return (file->f_pos = new);
+	file->f_pos = new;
+	up(&isapnp_mutex);
+	return new;
 }
 
 static ssize_t isapnp_proc_bus_read(struct file *file, char *buf, size_t nbytes, loff_t *ppos)
@@ -60,19 +64,27 @@ static ssize_t isapnp_proc_bus_read(stru
 	struct inode *ino = file->f_dentry->d_inode;
 	struct proc_dir_entry *dp = PDE(ino);
 	struct pnp_dev *dev = dp->data;
-	int pos = *ppos;
+	loff_t pos;
 	int cnt, size = 256;
 
+	down(&isapnp_mutex);
+	pos = *ppos;
 	if (pos >= size)
+	{
+		up(&isapnp_mutex);
 		return 0;
+	}
 	if (nbytes >= size)
 		nbytes = size;
-	if (pos + nbytes > size)
+	if (nbytes > size - pos)
 		nbytes = size - pos;
 	cnt = nbytes;
 
 	if (!access_ok(VERIFY_WRITE, buf, cnt))
-		return -EINVAL;
+	{
+		up(&isapnp_mutex);
+		return -EFAULT;
+	}
 
 	isapnp_cfg_begin(dev->card->number, dev->number);
 	for ( ; pos < 256 && cnt > 0; pos++, buf++, cnt--) {
@@ -83,6 +95,7 @@ static ssize_t isapnp_proc_bus_read(stru
 	isapnp_cfg_end();
 
 	*ppos = pos;
+	up(&isapnp_mutex);
 	return nbytes;
 }
 
Index: linux-2.6.5/drivers/s390/char/tape_char.c
===================================================================
--- linux-2.6.5.orig/drivers/s390/char/tape_char.c
+++ linux-2.6.5/drivers/s390/char/tape_char.c
@@ -142,7 +142,10 @@ tapechar_read (struct file *filp, char *
 	struct tape_request *request;
 	size_t block_size;
 	int rc;
+	loff_t pos = *ppos;
 
+	/* XXX - driver needs proper read/write/seek locks it seems */
+	
 	DBF_EVENT(6, "TCHAR:read\n");
 	device = (struct tape_device *) filp->private_data;
 	/* Check position. */
@@ -153,7 +156,7 @@ tapechar_read (struct file *filp, char *
 		 * read work...
 		 */
 		DBF_EVENT(6, "TCHAR:ppos wrong\n");
-		return -EOVERFLOW;
+		return -ESPIPE;
 	}
 
 	/*
@@ -196,11 +199,13 @@ tapechar_read (struct file *filp, char *
 	if (rc == 0) {
 		rc = block_size - request->rescnt;
 		DBF_EVENT(6, "TCHAR:rbytes:  %x\n", rc);
-		filp->f_pos += rc;
+		pos += rc;
 		/* Copy data from idal buffer to user space. */
 		if (idal_buffer_to_user(device->char_data.idal_buf,
 					data, rc) != 0)
 			rc = -EFAULT;
+		else
+			*ppos = pos;
 	}
 	tape_free_request(request);
 	return rc;
@@ -218,6 +223,9 @@ tapechar_write(struct file *filp, const 
 	size_t written;
 	int nblocks;
 	int i, rc;
+	loff_t pos = *ppos;
+
+	/* XXX - driver needs proper read/write/seek locks it seems */
 
 	DBF_EVENT(6, "TCHAR:write\n");
 	device = (struct tape_device *) filp->private_data;
@@ -225,7 +233,7 @@ tapechar_write(struct file *filp, const 
 	if (ppos != &filp->f_pos) {
 		/* "A request was outside the capabilities of the device." */
 		DBF_EVENT(6, "TCHAR:ppos wrong\n");
-		return -EOVERFLOW;
+		return -ESPIPE;
 	}
 	/* Find out block size and number of blocks */
 	if (device->char_data.block_size != 0) {
@@ -270,7 +278,7 @@ tapechar_write(struct file *filp, const 
 			break;
 		DBF_EVENT(6, "TCHAR:wbytes: %lx\n",
 			  block_size - request->rescnt);
-		filp->f_pos += block_size - request->rescnt;
+		pos += block_size - request->rescnt;
 		written += block_size - request->rescnt;
 		if (request->rescnt != 0)
 			break;
@@ -297,7 +305,10 @@ tapechar_write(struct file *filp, const 
 	 * tapemark it doesn't hurt to write two marks again.
 	 */
 	if (!rc)
+	{
 		device->required_tapemarks = 2;
+		*ppos = pos;
+	}
 
 	return rc ? rc : written;
 }
Index: linux-2.6.5/drivers/scsi/osst.c
===================================================================
--- linux-2.6.5.orig/drivers/scsi/osst.c
+++ linux-2.6.5/drivers/scsi/osst.c
@@ -3187,7 +3187,7 @@ static ssize_t osst_write(struct file * 
 	
 	if (ppos != &filp->f_pos) {
 	 	/* "A request was outside the capabilities of the device." */
-		retval = (-ENXIO);
+		retval = (-ESPIPE);
 		goto out;
 	}
 
@@ -3514,7 +3514,7 @@ static ssize_t osst_read(struct file * f
 	
 	if (ppos != &filp->f_pos) {
 		/* "A request was outside the capabilities of the device." */
-		retval = (-ENXIO);
+		retval = (-ESPIPE);
 		goto out;
 	}
 
@@ -5386,6 +5386,7 @@ static struct file_operations osst_fops 
 	.owner =        THIS_MODULE,
 	.read =         osst_read,
 	.write =        osst_write,
+	.llseek = 	no_llseek,
 	.ioctl =        osst_ioctl,
 	.open =         os_scsi_tape_open,
 	.flush =        os_scsi_tape_flush,
Index: linux-2.6.5/drivers/scsi/st.c
===================================================================
--- linux-2.6.5.orig/drivers/scsi/st.c
+++ linux-2.6.5/drivers/scsi/st.c
@@ -1219,7 +1219,7 @@ static ssize_t rw_checks(Scsi_Tape *STp,
 
 	if (ppos != &filp->f_pos) {
 		/* "A request was outside the capabilities of the device." */
-		retval = (-ENXIO);
+		retval = (-ESPIPE);
 		goto out;
 	}
 
@@ -3727,6 +3727,7 @@ static struct file_operations st_fops =
 	.read =		st_read,
 	.write =	st_write,
 	.ioctl =	st_ioctl,
+	.llseek =	no_llseek,
 	.open =		st_open,
 	.flush =	st_flush,
 	.release =	st_release,
Index: linux-2.6.5/drivers/telephony/ixj.c
===================================================================
--- linux-2.6.5.orig/drivers/telephony/ixj.c
+++ linux-2.6.5/drivers/telephony/ixj.c
@@ -2857,7 +2857,7 @@ static void alaw2ulaw(unsigned char *buf
 
 static ssize_t ixj_read(struct file * file_p, char *buf, size_t length, loff_t * ppos)
 {
-	unsigned long i = *ppos;
+	unsigned long i;
 	IXJ * j = get_ixj(NUM(file_p->f_dentry->d_inode));
 
 	DECLARE_WAITQUEUE(wait, current);
@@ -2937,7 +2937,7 @@ static ssize_t ixj_enhanced_read(struct 
 
 static ssize_t ixj_write(struct file *file_p, const char *buf, size_t count, loff_t * ppos)
 {
-	unsigned long i = *ppos;
+	unsigned long i;
 	IXJ *j = file_p->private_data;
 
 	DECLARE_WAITQUEUE(wait, current);
@@ -2983,7 +2983,7 @@ static ssize_t ixj_write(struct file *fi
 		j->flags.inwrite = 0;
 		return -EFAULT;
 	}
-       if(j->play_codec == ALAW)
+        if(j->play_codec == ALAW)
                alaw2ulaw(j->write_buffer_wp, min(count, j->write_buffer_size));
 	j->flags.inwrite = 0;
 	return min(count, j->write_buffer_size);
Index: linux-2.6.5/drivers/usb/core/devices.c
===================================================================
--- linux-2.6.5.orig/drivers/usb/core/devices.c
+++ linux-2.6.5/drivers/usb/core/devices.c
@@ -560,31 +560,39 @@ static ssize_t usb_device_read(struct fi
 {
 	struct list_head *buslist;
 	struct usb_bus *bus;
-	ssize_t ret, total_written = 0;
-	loff_t skip_bytes = *ppos;
+	ssize_t ret = 0, total_written = 0;
+	loff_t skip_bytes;
 
-	if (*ppos < 0)
-		return -EINVAL;
+	down (&usb_bus_list_lock);
+	
+	skip_bytes = *ppos;
+	if (skip_bytes < 0)
+	{
+		ret =  -EINVAL;
+		goto error;
+	}
 	if (nbytes <= 0)
-		return 0;
+		goto error;
 	if (!access_ok(VERIFY_WRITE, buf, nbytes))
-		return -EFAULT;
-
+	{
+		ret =  -EFAULT;
+		goto error;
+	}
 	/* enumerate busses */
-	down (&usb_bus_list_lock);
 	for (buslist = usb_bus_list.next; buslist != &usb_bus_list; buslist = buslist->next) {
 		/* print devices for this bus */
 		bus = list_entry(buslist, struct usb_bus, bus_list);
 		/* recurse through all children of the root hub */
 		ret = usb_device_dump(&buf, &nbytes, &skip_bytes, ppos, bus->root_hub, bus, 0, 0, 0);
 		if (ret < 0) {
-			up(&usb_bus_list_lock);
-			return ret;
+			goto error;
 		}
 		total_written += ret;
 	}
+	ret = total_written;
+error:
 	up (&usb_bus_list_lock);
-	return total_written;
+	return ret;
 }
 
 /* Kernel lock for "lastev" protection */
@@ -646,7 +654,8 @@ static loff_t usb_device_lseek(struct fi
 {
 	loff_t ret;
 
-	lock_kernel();
+	/* This already guards the other users */
+	down(&usb_bus_list_lock);
 
 	switch (orig) {
 	case 0:
@@ -662,7 +671,7 @@ static loff_t usb_device_lseek(struct fi
 		ret = -EINVAL;
 	}
 
-	unlock_kernel();
+	up(&usb_bus_list_lock);
 	return ret;
 }
 
Index: linux-2.6.5/drivers/usb/media/vicam.c
===================================================================
--- linux-2.6.5.orig/drivers/usb/media/vicam.c
+++ linux-2.6.5/drivers/usb/media/vicam.c
@@ -864,6 +864,8 @@ static void vicam_decode_color(const u8 
 {
 	/* vicam_decode_color - Convert from Vicam Y-Cr-Cb to RGB
 	 * Copyright (C) 2002 Monroe Williams (monroe@pobox.com)
+	 *
+	 * FIXME: camera should use V4L2 YCrCb return type now
 	 */
 
 	int i, prevY, nextY;
@@ -1009,8 +1011,10 @@ vicam_read( struct file *file, char *buf
 
 	DBG("read %d bytes.\n", (int) count);
 
+	down(&cam->cam_lock);
 	if (*ppos >= VICAM_MAX_FRAME_SIZE) {
 		*ppos = 0;
+		up(&cam->cam_lock);
 		return 0;
 	}
 
@@ -1032,7 +1036,7 @@ vicam_read( struct file *file, char *buf
 	if (count == VICAM_MAX_FRAME_SIZE) {
 		*ppos = 0;
 	}
-
+	up(&cam->cam_lock);
 	return count;
 }
 
Index: linux-2.6.5/drivers/usb/misc/auerswald.c
===================================================================
--- linux-2.6.5.orig/drivers/usb/misc/auerswald.c
+++ linux-2.6.5/drivers/usb/misc/auerswald.c
@@ -1591,7 +1591,7 @@ static ssize_t auerchar_read (struct fil
 	/* Error checking */
 	if (!ccp)
 		return -EIO;
-	if (*ppos)
+	if (ppos != &file->f_pos)
  		return -ESPIPE;
         if (count == 0)
 		return 0;
@@ -1723,8 +1723,8 @@ static ssize_t auerchar_write (struct fi
 	/* Error checking */
 	if (!ccp)
 		return -EIO;
-        if (*ppos)
-		return -ESPIPE;
+	if (ppos != &file->f_pos)
+ 		return -ESPIPE;
         if (len == 0)
                 return 0;
 
Index: linux-2.6.5/drivers/video/aty/radeon_base.c
===================================================================
--- linux-2.6.5.orig/drivers/video/aty/radeon_base.c
+++ linux-2.6.5/drivers/video/aty/radeon_base.c
@@ -1698,59 +1698,70 @@ int radeonfb_set_par(struct fb_info *inf
 
 static ssize_t radeonfb_read(struct file *file, char *buf, size_t count, loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	unsigned long p;
 	struct inode *inode = file->f_dentry->d_inode;
 	int fbidx = iminor(inode);
 	struct fb_info *info = registered_fb[fbidx];
 	struct radeonfb_info *rinfo = info->par;
 	
+	down(&info->mutex);
+	p = *ppos;
 	if (p >= rinfo->mapped_vram)
-	    return 0;
-	if (count >= rinfo->mapped_vram)
-	    count = rinfo->mapped_vram;
-	if (count + p > rinfo->mapped_vram)
+	{
+		up(&info->mutex);
+		return 0;
+	}
+	if (count > rinfo->mapped_vram - p)
 		count = rinfo->mapped_vram - p;
 	radeonfb_sync(info);
+	
 	if (count) {
-	    char *base_addr;
+		char *base_addr;
 
-	    base_addr = info->screen_base;
-	    count -= copy_to_user(buf, base_addr+p, count);
-	    if (!count)
-		return -EFAULT;
-	    *ppos += count;
+		base_addr = info->screen_base;
+		count -= copy_to_user(buf, base_addr+p, count);
+		if (!count)
+			count = -EFAULT;
+		else
+			*ppos += count;
 	}
+	up(&info->mutex);
 	return count;
 }
 
 static ssize_t radeonfb_write(struct file *file, const char *buf, size_t count,
 			      loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	unsigned long p;
 	struct inode *inode = file->f_dentry->d_inode;
 	int fbidx = iminor(inode);
 	struct fb_info *info = registered_fb[fbidx];
 	struct radeonfb_info *rinfo = info->par;
 	int err;
 
+	down(&info->mutex);
+	p = *ppos; /* truncated */
 	if (p > rinfo->mapped_vram)
-	    return -ENOSPC;
-	if (count >= rinfo->mapped_vram)
-	    count = rinfo->mapped_vram;
+	{
+		up(&info->mutex);
+		return -ENOSPC;
+	}
 	err = 0;
-	if (count + p > rinfo->mapped_vram) {
-	    count = rinfo->mapped_vram - p;
-	    err = -ENOSPC;
+	if (count > rinfo->mapped_vram - p) {
+		count = rinfo->mapped_vram - p;
+		err = -ENOSPC;
 	}
 	radeonfb_sync(info);
+	
 	if (count) {
-	    char *base_addr;
+		char *base_addr;
 
-	    base_addr = info->screen_base;
-	    count -= copy_from_user(base_addr+p, buf, count);
-	    *ppos += count;
-	    err = -EFAULT;
+		base_addr = info->screen_base;
+		count -= copy_from_user(base_addr+p, buf, count);
+		*ppos += count;
+		err = -EFAULT;
 	}
+	up(&info->mutex);
 	if (count)
 		return count;
 	return err;
@@ -2007,7 +2018,7 @@ static ssize_t radeon_show_one_edid(char
 	if (off > EDID_LENGTH)
 		return 0;
 
-	if (off + count > EDID_LENGTH)
+	if (count > EDID_LENGTH - off)
 		count = EDID_LENGTH - off;
 
 	memcpy(buf, edid + off, count);
Index: linux-2.6.5/drivers/video/fbmem.c
===================================================================
--- linux-2.6.5.orig/drivers/video/fbmem.c
+++ linux-2.6.5/drivers/video/fbmem.c
@@ -785,7 +785,7 @@ static int fbmem_read_proc(char *buf, ch
 static ssize_t
 fb_read(struct file *file, char *buf, size_t count, loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	loff_t p;
 	struct inode *inode = file->f_dentry->d_inode;
 	int fbidx = iminor(inode);
 	struct fb_info *info = registered_fb[fbidx];
@@ -798,35 +798,42 @@ fb_read(struct file *file, char *buf, si
 
 	if (info->fbops->fb_read)
 		return info->fbops->fb_read(file, buf, count, ppos);
+
+	down(&info->mutex);	
+	if (*ppos >= info->fix.smem_len)
+	{
+		count = 0;
+		goto error;
+	}
+	p = *ppos;
 	
-	if (p >= info->fix.smem_len)
-	    return 0;
-	if (count >= info->fix.smem_len)
-	    count = info->fix.smem_len;
-	if (count + p > info->fix.smem_len)
+	if (count > info->fix.smem_len - p)
 		count = info->fix.smem_len - p;
 	if (info->fbops->fb_sync)
 		info->fbops->fb_sync(info);
 	if (count) {
-	    char *base_addr;
+		char *base_addr;
 
-	    base_addr = info->screen_base;
-	    count -= copy_to_user(buf, base_addr+p, count);
-	    if (!count)
-		return -EFAULT;
-	    *ppos += count;
+		base_addr = info->screen_base;
+		count -= copy_to_user(buf, base_addr + p, count);
+		if (!count)
+			count = -EFAULT;
+		else
+			*ppos += count;
 	}
+error:	
+	up(&info->mutex);
 	return count;
 }
 
 static ssize_t
 fb_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	loff_t p;
 	struct inode *inode = file->f_dentry->d_inode;
 	int fbidx = iminor(inode);
 	struct fb_info *info = registered_fb[fbidx];
-	int err;
+	int err = -ENOSPC;
 
 	if (!info || !info->screen_base)
 		return -ENODEV;
@@ -837,30 +844,56 @@ fb_write(struct file *file, const char *
 	if (info->fbops->fb_write)
 		return info->fbops->fb_write(file, buf, count, ppos);
 	
-	if (p > info->fix.smem_len)
-	    return -ENOSPC;
-	if (count >= info->fix.smem_len)
-	    count = info->fix.smem_len;
+	down(&info->mutex);	
+	if (*ppos >= info->fix.smem_len)
+		goto err;
+	p = *ppos;
+	if (count > info->fix.smem_len - p)
+		count = info->fix.smem_len - p;
+		
 	err = 0;
-	if (count + p > info->fix.smem_len) {
-	    count = info->fix.smem_len - p;
-	    err = -ENOSPC;
-	}
 	if (info->fbops->fb_sync)
 		info->fbops->fb_sync(info);
 	if (count) {
-	    char *base_addr;
-
-	    base_addr = info->screen_base;
+	    char *base_addr = info->screen_base;
 	    count -= copy_from_user(base_addr+p, buf, count);
 	    *ppos += count;
 	    err = -EFAULT;
+	    if (count)
+		err = count;
 	}
-	if (count)
-		return count;
+err:
+	up(&info->mutex);
 	return err;
 }
 
+loff_t fb_llseek(struct file *file, loff_t offset, int origin)
+{
+	struct inode *inode = file->f_dentry->d_inode;
+	int fbidx = iminor(inode);
+	struct fb_info *info = registered_fb[fbidx];
+	loff_t retval;
+	
+	down(&info->mutex);
+	switch (origin) {
+		case 2:
+			offset += i_size_read(file->f_dentry->d_inode);
+			break;
+		case 1:
+			offset += file->f_pos;
+	}
+	retval = -EINVAL;
+	if (offset >= 0) {
+		if (offset != file->f_pos) {
+			file->f_pos = offset;
+			file->f_version = 0;
+		}
+		retval = offset;
+	}
+	up(&info->mutex);
+	return retval;
+}
+
 #ifdef CONFIG_KMOD
 static void try_to_load(int fb)
 {
@@ -1238,6 +1271,7 @@ static struct file_operations fb_fops = 
 	.owner =	THIS_MODULE,
 	.read =		fb_read,
 	.write =	fb_write,
+	.llseek = 	fb_llseek,
 	.ioctl =	fb_ioctl,
 	.mmap =		fb_mmap,
 	.open =		fb_open,
@@ -1300,6 +1334,7 @@ register_framebuffer(struct fb_info *fb_
 	if (fb_info->sprite.inbuf == NULL)
 		fb_info->sprite.inbuf = sys_inbuf;
 
+	init_MUTEX(&fb_info->mutex);
 	registered_fb[i] = fb_info;
 
 	devfs_mk_cdev(MKDEV(FB_MAJOR, i),
Index: linux-2.6.5/fs/proc/base.c
===================================================================
--- linux-2.6.5.orig/fs/proc/base.c
+++ linux-2.6.5/fs/proc/base.c
@@ -554,6 +554,7 @@ static ssize_t proc_info_read(struct fil
 	ssize_t length;
 	ssize_t end;
 	struct task_struct *task = proc_task(inode);
+	loff_t pos = *ppos;
 
 	if (count > PROC_BLOCK_SIZE)
 		count = PROC_BLOCK_SIZE;
@@ -567,14 +568,14 @@ static ssize_t proc_info_read(struct fil
 		return length;
 	}
 	/* Static 4kB (or whatever) block capacity */
-	if (*ppos >= length) {
+	if (pos < 0 || pos >= length) {
 		free_page(page);
 		return 0;
 	}
-	if (count + *ppos > length)
-		count = length - *ppos;
-	end = count + *ppos;
-	if (copy_to_user(buf, (char *) page + *ppos, count))
+	if (count > length - pos)
+		count = length - pos;
+	end = count + pos;
+	if (copy_to_user(buf, (char *) page + pos, count))
 		count = -EFAULT;
 	else
 		*ppos = end;
@@ -1333,7 +1334,7 @@ static ssize_t proc_pid_attr_read(struct
 		free_page(page);
 		return 0;
 	}
-	if (count + *ppos > length)
+	if (count > length - *ppos)
 		count = length - *ppos;
 	end = count + *ppos;
 	if (copy_to_user(buf, (char *) page + *ppos, count))
Index: linux-2.6.5/fs/proc/generic.c
===================================================================
--- linux-2.6.5.orig/fs/proc/generic.c
+++ linux-2.6.5/fs/proc/generic.c
@@ -53,6 +53,7 @@ proc_file_read(struct file *file, char _
 	ssize_t	n, count;
 	char	*start;
 	struct proc_dir_entry * dp;
+	loff_t pos = *ppos;
 
 	dp = PDE(inode);
 	if (!(page = (char*) __get_free_page(GFP_KERNEL)))
@@ -60,11 +61,13 @@ proc_file_read(struct file *file, char _
 
 	while ((nbytes > 0) && !eof) {
 		count = min_t(ssize_t, PROC_BLOCK_SIZE, nbytes);
-
+		if (pos != (unsigned) pos || pos > INT_MAX)
+			break;
+ 
 		start = NULL;
 		if (dp->get_info) {
 			/* Handle old net routines */
-			n = dp->get_info(page, &start, *ppos, count);
+			n = dp->get_info(page, &start, pos, count);
 			if (n < count)
 				eof = 1;
 		} else if (dp->read_proc) {
@@ -115,7 +118,7 @@ proc_file_read(struct file *file, char _
 			 *    requested offset advanced by the number of bytes
 			 *    absorbed.
 			 */
-			n = dp->read_proc(page, &start, *ppos,
+			n = dp->read_proc(page, &start, pos,
 					  count, &eof, dp->data);
 		} else
 			break;
@@ -134,12 +137,12 @@ proc_file_read(struct file *file, char _
 				       "proc_file_read: Apparent buffer overflow!\n");
 				n = PAGE_SIZE;
 			}
-			n -= *ppos;
+			n -= pos;
 			if (n <= 0)
 				break;
 			if (n > count)
 				n = count;
-			start = page + *ppos;
+			start = page + pos;
 		} else if (start < page) {
 			if (n > PAGE_SIZE) {
 				printk(KERN_ERR
@@ -172,7 +175,8 @@ proc_file_read(struct file *file, char _
 			break;
 		}
 
-		*ppos += start < page ? (unsigned long)start : n;
+		pos += start < page ? (unsigned long)start : n;
+		*ppos = pos;
 		nbytes -= n;
 		buf += n;
 		retval += n;
@@ -202,6 +206,7 @@ static loff_t
 proc_file_lseek(struct file *file, loff_t offset, int orig)
 {
     lock_kernel();
+    /* FIXME - need proper locking for proc/generic */
 
     switch (orig) {
     case 0:
Index: linux-2.6.5/fs/proc/kcore.c
===================================================================
--- linux-2.6.5.orig/fs/proc/kcore.c
+++ linux-2.6.5/fs/proc/kcore.c
@@ -276,24 +276,25 @@ read_kcore(struct file *file, char __use
 	size_t elf_buflen;
 	int nphdr;
 	unsigned long start;
+	loff_t pos = *fpos;
 
 	read_lock(&kclist_lock);
 	tsz =  get_kcore_size(&nphdr, &elf_buflen);
 	proc_root_kcore->size = size = tsz + elf_buflen;
-	if (buflen == 0 || *fpos >= size) {
+	if (buflen == 0 || pos < 0 || pos >= size) {
 		read_unlock(&kclist_lock);
 		return 0;
 	}
 
 	/* trim buflen to not go beyond EOF */
-	if (buflen > size - *fpos)
-		buflen = size - *fpos;
+	if (buflen > size - pos)
+		buflen = size - pos;
 
 	/* construct an ELF core header if we'll need some of it */
-	if (*fpos < elf_buflen) {
+	if (pos < elf_buflen) {
 		char * elf_buf;
 
-		tsz = elf_buflen - *fpos;
+		tsz = elf_buflen - pos;
 		if (buflen < tsz)
 			tsz = buflen;
 		elf_buf = kmalloc(elf_buflen, GFP_ATOMIC);
@@ -304,13 +305,14 @@ read_kcore(struct file *file, char __use
 		memset(elf_buf, 0, elf_buflen);
 		elf_kcore_store_hdr(elf_buf, nphdr, elf_buflen);
 		read_unlock(&kclist_lock);
-		if (copy_to_user(buffer, elf_buf + *fpos, tsz)) {
+		if (copy_to_user(buffer, elf_buf + pos, tsz)) {
 			kfree(elf_buf);
 			return -EFAULT;
 		}
 		kfree(elf_buf);
 		buflen -= tsz;
-		*fpos += tsz;
+		pos += tsz;
+		*fpos = pos;
 		buffer += tsz;
 		acc += tsz;
 
@@ -324,7 +326,7 @@ read_kcore(struct file *file, char __use
 	 * Check to see if our file offset matches with any of
 	 * the addresses in the elf_phdr on our list.
 	 */
-	start = kc_offset_to_vaddr(*fpos - elf_buflen);
+	start = kc_offset_to_vaddr(pos - elf_buflen);
 	if ((tsz = (PAGE_SIZE - (start & ~PAGE_MASK))) > buflen)
 		tsz = buflen;
 		
@@ -408,7 +410,8 @@ read_kcore(struct file *file, char __use
 			}
 		}
 		buflen -= tsz;
-		*fpos += tsz;
+		pos += tsz;
+		*fpos = pos;
 		buffer += tsz;
 		acc += tsz;
 		start += tsz;
Index: linux-2.6.5/fs/proc/proc_misc.c
===================================================================
--- linux-2.6.5.orig/fs/proc/proc_misc.c
+++ linux-2.6.5/fs/proc/proc_misc.c
@@ -569,12 +569,12 @@ static int execdomains_read_proc(char *p
 static ssize_t
 read_profile(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	loff_t p = *ppos;
 	ssize_t read;
 	char * pnt;
 	unsigned int sample_step = 1 << prof_shift;
 
-	if (p >= (prof_len+1)*sizeof(unsigned int))
+	if (p < 0 || p >= (prof_len+1)*sizeof(unsigned int))
 		return 0;
 	if (count > (prof_len+1)*sizeof(unsigned int) - p)
 		count = (prof_len+1)*sizeof(unsigned int) - p;
@@ -588,7 +588,7 @@ read_profile(struct file *file, char __u
 	if (copy_to_user(buf,(void *)pnt,count))
 		return -EFAULT;
 	read += count;
-	*ppos += read;
+	*ppos = p;
 	return read;
 }
 
Index: linux-2.6.5/fs/udf/file.c
===================================================================
--- linux-2.6.5.orig/fs/udf/file.c
+++ linux-2.6.5/fs/udf/file.c
@@ -114,15 +114,33 @@ static ssize_t udf_file_write(struct fil
 {
 	ssize_t retval;
 	struct inode *inode = file->f_dentry->d_inode;
-	int err, pos;
+	int err;
+	loff_t pos;
 
 	if (UDF_I_ALLOCTYPE(inode) == ICBTAG_FLAG_AD_IN_ICB)
 	{
+		/* FIXME: locking checks needed */
 		if (file->f_flags & O_APPEND)
 			pos = inode->i_size;
 		else
 			pos = *ppos;
 
+		/* Some checks from generic_file_write_checks that are
+		 * special cased: UDF_I_LENALLOC(inode) is 32-bits, but
+		 * sb->s_max_bytes = MAX_LFS_FILESIZE.
+		 * Additionally, udf_expand_file_adinicb() takes
+		 * 'int newsize', but it's not used anywhere.*/
+		if (pos < 0)
+			return -EINVAL;
+		if (pos >= MAX_NON_LFS) {
+			send_sig(SIGXFSZ, current, 0);
+			return -EFBIG;
+		}
+
+		if (count > MAX_NON_LFS - pos) {
+			count = MAX_NON_LFS - pos;
+		}
+
 		if (inode->i_sb->s_blocksize < (udf_file_entry_alloc_offset(inode) +
 			pos + count))
 		{
@@ -142,10 +160,10 @@ static ssize_t udf_file_write(struct fil
 		}
 	}
 
-	retval = generic_file_write(file, buf, count, ppos);
-
+	retval = generic_file_write(file, buf, count, &pos);
 	if (retval > 0)
 		mark_inode_dirty(inode);
+	*ppos = pos;
 	return retval;
 }
 
Index: linux-2.6.5/include/linux/fb.h
===================================================================
--- linux-2.6.5.orig/include/linux/fb.h
+++ linux-2.6.5/include/linux/fb.h
@@ -523,6 +523,7 @@ struct fb_info {
 #define FBINFO_STATE_SUSPENDED	1
 	u32 state;			/* Hardware state i.e suspend */
 
+	struct semaphore mutex;		/* Fbmem mutex */
 	/* From here on everything is device dependent */
 	void *par;	
 #ifdef CONFIG_BOOTSPLASH
Index: linux-2.6.5/include/linux/mtd/mtd.h
===================================================================
--- linux-2.6.5.orig/include/linux/mtd/mtd.h
+++ linux-2.6.5/include/linux/mtd/mtd.h
@@ -222,6 +222,9 @@ struct mtd_info {
 	/* Power Management functions */
 	int (*suspend) (struct mtd_info *mtd);
 	void (*resume) (struct mtd_info *mtd);
+	
+	/* Semaphore */
+	struct semaphore mutex;
 
 	void *priv;
 
Index: linux-2.6.5/net/atm/mpoa_proc.c
===================================================================
--- linux-2.6.5.orig/net/atm/mpoa_proc.c
+++ linux-2.6.5/net/atm/mpoa_proc.c
@@ -98,6 +98,7 @@ static const char *egress_state_string(i
 
 /*
  * READING function - called when the /proc/atm/mpoa file is read from.
+ * FIXME: needs seek locking
  */
 static ssize_t proc_mpc_read(struct file *file, char *buff,
 			     size_t count, loff_t *pos){
@@ -110,7 +111,9 @@ static ssize_t proc_mpc_read(struct file
 	eg_cache_entry *eg_entry;
 	struct timeval now;
 	unsigned char ip_string[16];
-	if(count == 0)
+	loff_t n = *pos;
+	
+	if(count == 0 || n < 0)
 	        return 0;
 	page = get_zeroed_page(GFP_KERNEL);
 	if(!page)
@@ -151,18 +154,19 @@ static ssize_t proc_mpc_read(struct file
 		mpc = mpc->next;
 	}
 
-	if (*pos >= length) length = 0;
+	if (n >= length)
+		count = 0;
 	else {
-	  if ((count + *pos) > length) count = length - *pos;
+	  if (count  > length - n) count = length - n;
 	  if (copy_to_user(buff, (char *)page , count)) {
  		  free_page(page);
 		  return -EFAULT;
           }
-	  *pos += count;
+	  *pos = n + count;
 	}
 
  	free_page(page);
-        return length;
+        return count;
 }
 
 static ssize_t proc_mpc_write(struct file *file, const char *buff,
@@ -196,8 +200,6 @@ static ssize_t proc_mpc_write(struct fil
                 return -EFAULT;
         }
 
-        *ppos += incoming;
-
         page[incoming] = '\0';
 	retval = parse_qos(page, incoming);
         if (retval == 0)
Index: linux-2.6.5/net/sunrpc/cache.c
===================================================================
--- linux-2.6.5.orig/net/sunrpc/cache.c
+++ linux-2.6.5/net/sunrpc/cache.c
@@ -1170,19 +1170,19 @@ static ssize_t read_flush(struct file *f
 {
 	struct cache_detail *cd = PDE(file->f_dentry->d_inode)->data;
 	char tbuf[20];
-	unsigned long p = *ppos;
+	loff_t p = *ppos;
 	int len;
 
-	sprintf(tbuf, "%lu\n", cd->flush_time);
-	len = strlen(tbuf);
-	if (p >= len)
+	len = sprintf(tbuf, "%lu\n", cd->flush_time);
+	if (p < 0 || p >= len)
 		return 0;
+
 	len -= p;
 	if (len > count) len = count;
 	if (copy_to_user(buf, (void*)(tbuf+p), len))
 		len = -EFAULT;
 	else
-		*ppos += len;
+		*ppos = p + len;
 	return len;
 }
 
@@ -1206,7 +1206,7 @@ static ssize_t write_flush(struct file *
 	cd->nextcheck = get_seconds();
 	cache_flush();
 
-	*ppos += count;
+	*ppos = count;
 	return count;
 }
 
