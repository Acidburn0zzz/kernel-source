diff -purN linux-post-2.6.5-rc2-20040327/arch/alpha/defconfig linux-post-2.6.5-rc2-20040329/arch/alpha/defconfig
--- linux-post-2.6.5-rc2-20040327/arch/alpha/defconfig	2004-03-20 18:01:44.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/alpha/defconfig	2004-03-23 18:24:34.000000000 +0000
@@ -207,7 +207,6 @@ CONFIG_BLK_DEV_CY82C693=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/arm/configs/cerfcube_defconfig linux-post-2.6.5-rc2-20040329/arch/arm/configs/cerfcube_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/arm/configs/cerfcube_defconfig	2004-03-25 17:56:55.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/arm/configs/cerfcube_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -448,7 +448,6 @@ CONFIG_BLK_DEV_IDECS=m
 # CONFIG_IDE_CHIPSETS is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/arm/configs/lart_defconfig linux-post-2.6.5-rc2-20040329/arch/arm/configs/lart_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/arm/configs/lart_defconfig	2004-03-25 17:56:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/arm/configs/lart_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -469,7 +469,6 @@ CONFIG_BLK_DEV_IDECD=m
 # CONFIG_IDE_CHIPSETS is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/arm/configs/netwinder_defconfig linux-post-2.6.5-rc2-20040329/arch/arm/configs/netwinder_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/arm/configs/netwinder_defconfig	2004-03-25 17:56:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/arm/configs/netwinder_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -463,7 +463,6 @@ CONFIG_BLK_DEV_ADMA=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/arm/configs/shark_defconfig linux-post-2.6.5-rc2-20040329/arch/arm/configs/shark_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/arm/configs/shark_defconfig	2004-03-25 17:56:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/arm/configs/shark_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -381,7 +381,6 @@ CONFIG_BLK_DEV_IDEFLOPPY=y
 # CONFIG_IDE_CHIPSETS is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/arm/configs/trizeps_defconfig linux-post-2.6.5-rc2-20040329/arch/arm/configs/trizeps_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/arm/configs/trizeps_defconfig	2004-03-25 17:56:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/arm/configs/trizeps_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -493,7 +493,6 @@ CONFIG_BLK_DEV_IDECS=m
 # CONFIG_BLK_DEV_IDE_RAPIDE is not set
 # CONFIG_IDE_CHIPSETS is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 
 #
 # SCSI support
diff -purN linux-post-2.6.5-rc2-20040327/arch/i386/defconfig linux-post-2.6.5-rc2-20040329/arch/i386/defconfig
--- linux-post-2.6.5-rc2-20040327/arch/i386/defconfig	2004-03-17 12:02:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/i386/defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -304,7 +304,6 @@ CONFIG_BLK_DEV_PIIX=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/i386/kernel/timers/timer_tsc.c linux-post-2.6.5-rc2-20040329/arch/i386/kernel/timers/timer_tsc.c
--- linux-post-2.6.5-rc2-20040327/arch/i386/kernel/timers/timer_tsc.c	2004-02-04 05:35:49.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/i386/kernel/timers/timer_tsc.c	2004-03-27 11:40:47.000000000 +0000
@@ -360,8 +360,9 @@ time_cpufreq_notifier(struct notifier_bl
 		if (variable_tsc)
 			cpu_data[freq->cpu].loops_per_jiffy = cpufreq_scale(loops_per_jiffy_ref, ref_freq, freq->new);
 #ifndef CONFIG_SMP
-		if (use_tsc) {
+		if (cpu_khz)
 			cpu_khz = cpufreq_scale(cpu_khz_ref, ref_freq, freq->new);
+		if (use_tsc) {
 			if (variable_tsc) {
 				fast_gettimeoffset_quotient = cpufreq_scale(fast_gettimeoffset_ref, freq->new, ref_freq);
 				set_cyc2ns_scale(cpu_khz/1000);
diff -purN linux-post-2.6.5-rc2-20040327/arch/ia64/configs/generic_defconfig linux-post-2.6.5-rc2-20040329/arch/ia64/configs/generic_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ia64/configs/generic_defconfig	2004-03-17 12:02:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ia64/configs/generic_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -214,7 +214,6 @@ CONFIG_BLK_DEV_PIIX=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ia64/configs/sn2_defconfig linux-post-2.6.5-rc2-20040329/arch/ia64/configs/sn2_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ia64/configs/sn2_defconfig	2004-03-25 14:18:56.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ia64/configs/sn2_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -221,7 +221,6 @@ CONFIG_BLK_DEV_SGIIOC4=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ia64/configs/zx1_defconfig linux-post-2.6.5-rc2-20040329/arch/ia64/configs/zx1_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ia64/configs/zx1_defconfig	2004-03-17 12:02:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ia64/configs/zx1_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -211,7 +211,6 @@ CONFIG_BLK_DEV_CMD64X=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ia64/defconfig linux-post-2.6.5-rc2-20040329/arch/ia64/defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ia64/defconfig	2004-03-16 08:03:41.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ia64/defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -218,7 +218,6 @@ CONFIG_BLK_DEV_SIIMAGE=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ia64/ia32/ia32_entry.S linux-post-2.6.5-rc2-20040329/arch/ia64/ia32/ia32_entry.S
--- linux-post-2.6.5-rc2-20040327/arch/ia64/ia32/ia32_entry.S	2003-12-31 22:51:04.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ia64/ia32/ia32_entry.S	2004-03-26 19:05:24.000000000 +0000
@@ -229,7 +229,7 @@ ia32_syscall_table:
 	data8 sys_ni_syscall
 	data8 sys32_lseek
 	data8 sys_getpid	  /* 20 */
-	data8 sys_mount
+	data8 compat_sys_mount
 	data8 sys_oldumount
 	data8 sys_setuid	/* 16-bit version */
 	data8 sys_getuid	/* 16-bit version */
diff -purN linux-post-2.6.5-rc2-20040327/arch/ia64/ia32/sys_ia32.c linux-post-2.6.5-rc2-20040329/arch/ia64/ia32/sys_ia32.c
--- linux-post-2.6.5-rc2-20040327/arch/ia64/ia32/sys_ia32.c	2004-03-15 14:22:21.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ia64/ia32/sys_ia32.c	2004-03-26 19:05:24.000000000 +0000
@@ -34,9 +34,6 @@
 #include <linux/slab.h>
 #include <linux/uio.h>
 #include <linux/nfs_fs.h>
-#include <linux/smb_fs.h>
-#include <linux/smb_mount.h>
-#include <linux/ncp_fs.h>
 #include <linux/quota.h>
 #include <linux/sunrpc/svc.h>
 #include <linux/nfsd/nfsd.h>
@@ -2384,157 +2381,6 @@ long sys32_fadvise64_64(int fd, __u32 of
 
 #ifdef	NOTYET  /* UNTESTED FOR IA64 FROM HERE DOWN */
 
-struct ncp_mount_data32 {
-	int version;
-	unsigned int ncp_fd;
-	compat_uid_t mounted_uid;
-	int wdog_pid;
-	unsigned char mounted_vol[NCP_VOLNAME_LEN + 1];
-	unsigned int time_out;
-	unsigned int retry_count;
-	unsigned int flags;
-	compat_uid_t uid;
-	compat_gid_t gid;
-	compat_mode_t file_mode;
-	compat_mode_t dir_mode;
-};
-
-static void *
-do_ncp_super_data_conv(void *raw_data)
-{
-	struct ncp_mount_data *n = (struct ncp_mount_data *)raw_data;
-	struct ncp_mount_data32 *n32 = (struct ncp_mount_data32 *)raw_data;
-
-	n->dir_mode = n32->dir_mode;
-	n->file_mode = n32->file_mode;
-	n->gid = n32->gid;
-	n->uid = n32->uid;
-	memmove (n->mounted_vol, n32->mounted_vol,
-		 (sizeof (n32->mounted_vol) + 3 * sizeof (unsigned int)));
-	n->wdog_pid = n32->wdog_pid;
-	n->mounted_uid = n32->mounted_uid;
-	return raw_data;
-}
-
-struct smb_mount_data32 {
-	int version;
-	compat_uid_t mounted_uid;
-	compat_uid_t uid;
-	compat_gid_t gid;
-	compat_mode_t file_mode;
-	compat_mode_t dir_mode;
-};
-
-static void *
-do_smb_super_data_conv(void *raw_data)
-{
-	struct smb_mount_data *s = (struct smb_mount_data *)raw_data;
-	struct smb_mount_data32 *s32 = (struct smb_mount_data32 *)raw_data;
-
-	if (s32->version != SMB_MOUNT_OLDVERSION)
-		goto out;
-	s->version = s32->version;
-	s->mounted_uid = s32->mounted_uid;
-	s->uid = s32->uid;
-	s->gid = s32->gid;
-	s->file_mode = s32->file_mode;
-	s->dir_mode = s32->dir_mode;
-out:
-	return raw_data;
-}
-
-static int
-copy_mount_stuff_to_kernel(const void *user, unsigned long *kernel)
-{
-	int i;
-	unsigned long page;
-	struct vm_area_struct *vma;
-
-	*kernel = 0;
-	if(!user)
-		return 0;
-	vma = find_vma(current->mm, (unsigned long)user);
-	if(!vma || (unsigned long)user < vma->vm_start)
-		return -EFAULT;
-	if(!(vma->vm_flags & VM_READ))
-		return -EFAULT;
-	i = vma->vm_end - (unsigned long) user;
-	if(PAGE_SIZE <= (unsigned long) i)
-		i = PAGE_SIZE - 1;
-	if(!(page = __get_free_page(GFP_KERNEL)))
-		return -ENOMEM;
-	if(copy_from_user((void *) page, user, i)) {
-		free_page(page);
-		return -EFAULT;
-	}
-	*kernel = page;
-	return 0;
-}
-
-#define SMBFS_NAME	"smbfs"
-#define NCPFS_NAME	"ncpfs"
-
-asmlinkage long
-sys32_mount(char *dev_name, char *dir_name, char *type,
-	    unsigned long new_flags, u32 data)
-{
-	unsigned long type_page;
-	int err, is_smb, is_ncp;
-
-	if(!capable(CAP_SYS_ADMIN))
-		return -EPERM;
-	is_smb = is_ncp = 0;
-	err = copy_mount_stuff_to_kernel((const void *)type, &type_page);
-	if(err)
-		return err;
-	if(type_page) {
-		is_smb = !strcmp((char *)type_page, SMBFS_NAME);
-		is_ncp = !strcmp((char *)type_page, NCPFS_NAME);
-	}
-	if(!is_smb && !is_ncp) {
-		if(type_page)
-			free_page(type_page);
-		return sys_mount(dev_name, dir_name, type, new_flags,
-				 (void *)AA(data));
-	} else {
-		unsigned long dev_page, dir_page, data_page;
-
-		err = copy_mount_stuff_to_kernel((const void *)dev_name,
-						 &dev_page);
-		if(err)
-			goto out;
-		err = copy_mount_stuff_to_kernel((const void *)dir_name,
-						 &dir_page);
-		if(err)
-			goto dev_out;
-		err = copy_mount_stuff_to_kernel((const void *)AA(data),
-						 &data_page);
-		if(err)
-			goto dir_out;
-		if(is_ncp)
-			do_ncp_super_data_conv((void *)data_page);
-		else if(is_smb)
-			do_smb_super_data_conv((void *)data_page);
-		else
-			panic("The problem is here...");
-		err = do_mount((char *)dev_page, (char *)dir_page,
-				(char *)type_page, new_flags,
-				(void *)data_page);
-		if(data_page)
-			free_page(data_page);
-	dir_out:
-		if(dir_page)
-			free_page(dir_page);
-	dev_out:
-		if(dev_page)
-			free_page(dev_page);
-	out:
-		if(type_page)
-			free_page(type_page);
-		return err;
-	}
-}
-
 asmlinkage long sys32_setreuid(compat_uid_t ruid, compat_uid_t euid)
 {
 	uid_t sruid, seuid;
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/capcella_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/capcella_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/capcella_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/capcella_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -196,7 +196,6 @@ CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/cobalt_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/cobalt_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/cobalt_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/cobalt_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -189,7 +189,6 @@ CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/db1500_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/db1500_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/db1500_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/db1500_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -268,7 +268,6 @@ CONFIG_BLK_DEV_IDECS=m
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/ddb5476_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/ddb5476_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/ddb5476_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/ddb5476_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -188,7 +188,6 @@ CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/e55_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/e55_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/e55_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/e55_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -188,7 +188,6 @@ CONFIG_IDE_TASKFILE_IO=y
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/eagle_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/eagle_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/eagle_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/eagle_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -273,7 +273,6 @@ CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/hp-lj_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/hp-lj_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/hp-lj_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/hp-lj_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -245,7 +245,6 @@ CONFIG_IDE_TASKFILE_IO=y
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/it8172_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/it8172_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/it8172_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/it8172_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -243,7 +243,6 @@ CONFIG_IDE_TASKFILE_IO=y
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/ivr_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/ivr_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/ivr_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/ivr_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -191,7 +191,6 @@ CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/lasat200_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/lasat200_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/lasat200_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/lasat200_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -284,7 +284,6 @@ CONFIG_BLK_DEV_CMD64X=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/pb1500_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/pb1500_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/pb1500_defconfig	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/pb1500_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -251,7 +251,6 @@ CONFIG_BLK_DEV_HPT366=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/tb0226_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/tb0226_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/tb0226_defconfig	2004-02-21 01:33:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/tb0226_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -192,7 +192,6 @@ CONFIG_IDE_TASKFILE_IO=y
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/mips/configs/workpad_defconfig linux-post-2.6.5-rc2-20040329/arch/mips/configs/workpad_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/mips/configs/workpad_defconfig	2004-02-21 01:33:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/mips/configs/workpad_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -188,7 +188,6 @@ CONFIG_IDE_TASKFILE_IO=y
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/parisc/configs/c3000_defconfig linux-post-2.6.5-rc2-20040329/arch/parisc/configs/c3000_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/parisc/configs/c3000_defconfig	2004-03-12 11:40:41.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/parisc/configs/c3000_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -186,7 +186,6 @@ CONFIG_BLK_DEV_SIIMAGE=m
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/parisc/kernel/sys_parisc32.c linux-post-2.6.5-rc2-20040329/arch/parisc/kernel/sys_parisc32.c
--- linux-post-2.6.5-rc2-20040327/arch/parisc/kernel/sys_parisc32.c	2004-02-25 10:31:12.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/parisc/kernel/sys_parisc32.c	2004-03-26 19:05:25.000000000 +0000
@@ -607,105 +607,6 @@ out:
 	return error;
 }
 
-static int copy_mount_stuff_to_kernel(const void *user, unsigned long *kernel)
-{
-	int i;
-	unsigned long page;
-	struct vm_area_struct *vma;
-
-	*kernel = 0;
-	if(!user)
-		return 0;
-	vma = find_vma(current->mm, (unsigned long)user);
-	if(!vma || (unsigned long)user < vma->vm_start)
-		return -EFAULT;
-	if(!(vma->vm_flags & VM_READ))
-		return -EFAULT;
-	i = vma->vm_end - (unsigned long) user;
-	if(PAGE_SIZE <= (unsigned long) i)
-		i = PAGE_SIZE - 1;
-	if(!(page = __get_free_page(GFP_KERNEL)))
-		return -ENOMEM;
-	if(copy_from_user((void *) page, user, i)) {
-		free_page(page);
-		return -EFAULT;
-	}
-	*kernel = page;
-	return 0;
-}
-
-#define SMBFS_NAME	"smbfs"
-#define NCPFS_NAME	"ncpfs"
-
-asmlinkage int sys32_mount(char *dev_name, char *dir_name, char *type, unsigned long new_flags, u32 data)
-{
-	unsigned long type_page = 0;
-	unsigned long data_page = 0;
-	unsigned long dev_page = 0;
-	unsigned long dir_page = 0;
-	int err, is_smb, is_ncp;
-
-	is_smb = is_ncp = 0;
-
-	err = copy_mount_stuff_to_kernel((const void *)type, &type_page);
-	if (err)
-		goto out;
-
-	if (!type_page) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	is_smb = !strcmp((char *)type_page, SMBFS_NAME);
-	is_ncp = !strcmp((char *)type_page, NCPFS_NAME);
-
-	err = copy_mount_stuff_to_kernel((const void *)(unsigned long)data, &data_page);
-	if (err)
-		goto type_out;
-
-	err = copy_mount_stuff_to_kernel(dev_name, &dev_page);
-	if (err)
-		goto data_out;
-
-	err = copy_mount_stuff_to_kernel(dir_name, &dir_page);
-	if (err)
-		goto dev_out;
-
-	if (!is_smb && !is_ncp) {
-		lock_kernel();
-		err = do_mount((char*)dev_page, (char*)dir_page,
-				(char*)type_page, new_flags, (char*)data_page);
-		unlock_kernel();
-	} else {
-		if (is_ncp)
-			panic("NCP mounts not yet supported 32/64 parisc");
-			/* do_ncp_super_data_conv((void *)data_page); */
-		else {
-			panic("SMB mounts not yet supported 32/64 parisc");
-			/* do_smb_super_data_conv((void *)data_page); */
-		}
-
-		lock_kernel();
-		err = do_mount((char*)dev_page, (char*)dir_page,
-				(char*)type_page, new_flags, (char*)data_page);
-		unlock_kernel();
-	}
-	free_page(dir_page);
-
-dev_out:
-	free_page(dev_page);
-
-data_out:
-	free_page(data_page);
-
-type_out:
-	free_page(type_page);
-
-out:
-	return err;
-}
-
-
 /* readv/writev stolen from mips64 */
 typedef ssize_t (*IO_fn_t)(struct file *, char *, size_t, loff_t *);
 
diff -purN linux-post-2.6.5-rc2-20040327/arch/parisc/kernel/syscall_table.S linux-post-2.6.5-rc2-20040329/arch/parisc/kernel/syscall_table.S
--- linux-post-2.6.5-rc2-20040327/arch/parisc/kernel/syscall_table.S	2004-02-04 05:41:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/parisc/kernel/syscall_table.S	2004-03-26 19:05:25.000000000 +0000
@@ -84,7 +84,7 @@
 	ENTRY_DIFF(lseek)
 	ENTRY_SAME(getpid)		/* 20 */
 	/* the 'void * data' parameter may need re-packing in wide */
-	ENTRY_DIFF(mount)
+	ENTRY_COMP(mount)
 	/* concerned about struct sockaddr in wide/narrow */
 	/* ---> I think sockaddr is OK unless the compiler packs the struct */
 	/*      differently to align the char array */
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc/configs/common_defconfig linux-post-2.6.5-rc2-20040329/arch/ppc/configs/common_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ppc/configs/common_defconfig	2004-02-05 19:38:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc/configs/common_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -241,7 +241,6 @@ CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc/configs/cpci405_defconfig linux-post-2.6.5-rc2-20040329/arch/ppc/configs/cpci405_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ppc/configs/cpci405_defconfig	2003-10-06 12:04:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc/configs/cpci405_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -177,7 +177,6 @@ CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_BLK_DEV_IDEPCI is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc/configs/pmac_defconfig linux-post-2.6.5-rc2-20040329/arch/ppc/configs/pmac_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ppc/configs/pmac_defconfig	2004-02-05 19:38:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc/configs/pmac_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -247,7 +247,6 @@ CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc/configs/pplus_defconfig linux-post-2.6.5-rc2-20040329/arch/ppc/configs/pplus_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ppc/configs/pplus_defconfig	2004-03-11 20:06:10.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc/configs/pplus_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -180,7 +180,6 @@ CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc/configs/redwood5_defconfig linux-post-2.6.5-rc2-20040329/arch/ppc/configs/redwood5_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ppc/configs/redwood5_defconfig	2003-10-06 12:04:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc/configs/redwood5_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -173,7 +173,6 @@ CONFIG_BLK_DEV_IDEDISK=y
 #
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc/defconfig linux-post-2.6.5-rc2-20040329/arch/ppc/defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ppc/defconfig	2004-02-05 19:38:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc/defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -248,7 +248,6 @@ CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc64/configs/g5_defconfig linux-post-2.6.5-rc2-20040329/arch/ppc64/configs/g5_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ppc64/configs/g5_defconfig	2004-03-23 02:42:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc64/configs/g5_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -195,7 +195,6 @@ CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc64/configs/pSeries_defconfig linux-post-2.6.5-rc2-20040329/arch/ppc64/configs/pSeries_defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ppc64/configs/pSeries_defconfig	2004-03-17 12:02:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc64/configs/pSeries_defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -197,7 +197,6 @@ CONFIG_BLK_DEV_AMD74XX=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc64/defconfig linux-post-2.6.5-rc2-20040329/arch/ppc64/defconfig
--- linux-post-2.6.5-rc2-20040327/arch/ppc64/defconfig	2004-03-17 12:02:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc64/defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -197,7 +197,6 @@ CONFIG_BLK_DEV_AMD74XX=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc64/kernel/iommu.c linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/iommu.c
--- linux-post-2.6.5-rc2-20040327/arch/ppc64/kernel/iommu.c	2004-03-22 10:44:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/iommu.c	2004-03-25 17:37:04.000000000 +0000
@@ -100,12 +100,13 @@ static unsigned long iommu_range_alloc(s
 	end = n + npages;
 
 	if (unlikely(end >= limit)) {
-		if (likely(pass++ < 2)) {
+		if (likely(pass < 2)) {
 			/* First failure, just rescan the half of the table.
 			 * Second failure, rescan the other half of the table.
 			 */
 			start = (largealloc ^ pass) ? tbl->it_halfpoint : 0;
 			limit = pass ? tbl->it_mapsize : limit;
+			pass++;
 			goto again;
 		} else {
 			/* Third failure, give up */
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc64/kernel/misc.S linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/misc.S
--- linux-post-2.6.5-rc2-20040327/arch/ppc64/kernel/misc.S	2004-03-16 11:30:35.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/misc.S	2004-03-26 19:05:26.000000000 +0000
@@ -593,7 +593,7 @@ _GLOBAL(sys_call_table32)
 	.llong .sys_ni_syscall		/* old stat syscall */
 	.llong .ppc32_lseek
 	.llong .sys_getpid              /* 20 */
-	.llong .sys32_mount
+	.llong .compat_sys_mount
 	.llong .sys_oldumount
 	.llong .sys_setuid
 	.llong .sys_getuid
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc64/kernel/prom.c linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/prom.c
--- linux-post-2.6.5-rc2-20040327/arch/ppc64/kernel/prom.c	2004-03-22 10:17:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/prom.c	2004-03-28 11:54:59.000000000 +0000
@@ -792,8 +792,8 @@ void prom_initialize_dart_table(void)
 	if (lmb_end_of_DRAM() <= 0x80000000ull && !RELOC(iommu_force_on))
 		return;
 
-	/* 512 pages is max DART tablesize. */
-	RELOC(dart_tablesize) = 1UL << 19;
+	/* 512 pages (2MB) is max DART tablesize. */
+	RELOC(dart_tablesize) = 1UL << 21;
 	/* 16MB (1 << 24) alignment. We allocate a full 16Mb chuck since we
 	 * will blow up an entire large page anyway in the kernel mapping
 	 */
diff -purN linux-post-2.6.5-rc2-20040327/arch/ppc64/kernel/sys_ppc32.c linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/sys_ppc32.c
--- linux-post-2.6.5-rc2-20040327/arch/ppc64/kernel/sys_ppc32.c	2004-03-25 08:40:38.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/sys_ppc32.c	2004-03-24 12:24:38.000000000 +0000
@@ -35,9 +35,6 @@
 #include <linux/uio.h>
 #include <linux/aio.h>
 #include <linux/nfs_fs.h>
-#include <linux/smb_fs.h>
-#include <linux/smb_mount.h>
-#include <linux/ncp_fs.h>
 #include <linux/module.h>
 #include <linux/sunrpc/svc.h>
 #include <linux/nfsd/nfsd.h>
@@ -253,208 +250,6 @@ out:
 	return ret;
 }
 
-struct ncp_mount_data32_v3 {
-        int version;
-        unsigned int ncp_fd;
-        compat_uid_t mounted_uid;
-        compat_pid_t wdog_pid;
-        unsigned char mounted_vol[NCP_VOLNAME_LEN + 1];
-        unsigned int time_out;
-        unsigned int retry_count;
-        unsigned int flags;
-        compat_uid_t uid;
-        compat_gid_t gid;
-        compat_mode_t file_mode;
-        compat_mode_t dir_mode;
-};
-
-struct ncp_mount_data32_v4 {
-	int version;
-	/* all members below are "long" in ABI ... i.e. 32bit on sparc32, while 64bits on sparc64 */
-	unsigned int flags;
-	unsigned int mounted_uid;
-	int wdog_pid;
-
-	unsigned int ncp_fd;
-	unsigned int time_out;
-	unsigned int retry_count;
-
-	unsigned int uid;
-	unsigned int gid;
-	unsigned int file_mode;
-	unsigned int dir_mode;
-};
-
-static void *do_ncp_super_data_conv(void *raw_data)
-{
-	switch (*(int*)raw_data) {
-		case NCP_MOUNT_VERSION:
-			{
-				struct ncp_mount_data news, *n = &news; 
-				struct ncp_mount_data32_v3 *n32 = (struct ncp_mount_data32_v3 *)raw_data;
-
-				n->version = n32->version;
-				n->ncp_fd = n32->ncp_fd;
-				n->mounted_uid = n32->mounted_uid;
-				n->wdog_pid = n32->wdog_pid;
-				memmove (n->mounted_vol, n32->mounted_vol, sizeof (n32->mounted_vol));
-				n->time_out = n32->time_out;
-				n->retry_count = n32->retry_count;
-				n->flags = n32->flags;
-				n->uid = n32->uid;
-				n->gid = n32->gid;
-				n->file_mode = n32->file_mode;
-				n->dir_mode = n32->dir_mode;
-				memcpy(raw_data, n, sizeof(*n)); 
-			}
-			break;
-		case NCP_MOUNT_VERSION_V4:
-			{
-				struct ncp_mount_data_v4 news, *n = &news; 
-				struct ncp_mount_data32_v4 *n32 = (struct ncp_mount_data32_v4 *)raw_data;
-
-				n->version = n32->version;
-				n->flags = n32->flags;
-				n->mounted_uid = n32->mounted_uid;
-				n->wdog_pid = n32->wdog_pid;
-				n->ncp_fd = n32->ncp_fd;
-				n->time_out = n32->time_out;
-				n->retry_count = n32->retry_count;
-				n->uid = n32->uid;
-				n->gid = n32->gid;
-				n->file_mode = n32->file_mode;
-				n->dir_mode = n32->dir_mode;
-				memcpy(raw_data, n, sizeof(*n)); 
-			}
-			break;
-		default:
-			/* do not touch unknown structures */
-			break;
-	}
-	return raw_data;
-}
-
-struct smb_mount_data32 {
-        int version;
-        compat_uid_t mounted_uid;
-        compat_uid_t uid;
-        compat_gid_t gid;
-        compat_mode_t file_mode;
-        compat_mode_t dir_mode;
-};
-
-static void *do_smb_super_data_conv(void *raw_data)
-{
-	struct smb_mount_data news, *s = &news;
-	struct smb_mount_data32 *s32 = (struct smb_mount_data32 *)raw_data;
-
-	if (s32->version != SMB_MOUNT_OLDVERSION)
-		goto out;
-	s->version = s32->version;
-	s->mounted_uid = s32->mounted_uid;
-	s->uid = s32->uid;
-	s->gid = s32->gid;
-	s->file_mode = s32->file_mode;
-	s->dir_mode = s32->dir_mode;
-	memcpy(raw_data, s, sizeof(struct smb_mount_data)); 
-out:
-	return raw_data;
-}
-
-static int copy_mount_stuff_to_kernel(const void *user, unsigned long *kernel)
-{
-	int i;
-	unsigned long page;
-	struct vm_area_struct *vma;
-
-	*kernel = 0;
-	if(!user)
-		return 0;
-	vma = find_vma(current->mm, (unsigned long)user);
-	if(!vma || (unsigned long)user < vma->vm_start)
-		return -EFAULT;
-	if(!(vma->vm_flags & VM_READ))
-		return -EFAULT;
-	i = vma->vm_end - (unsigned long) user;
-	if(PAGE_SIZE <= (unsigned long) i)
-		i = PAGE_SIZE - 1;
-	if(!(page = __get_free_page(GFP_KERNEL)))
-		return -ENOMEM;
-	if(copy_from_user((void *) page, user, i)) {
-		free_page(page);
-		return -EFAULT;
-	}
-	*kernel = page;
-	return 0;
-}
-
-#define SMBFS_NAME	"smbfs"
-#define NCPFS_NAME	"ncpfs"
-
-asmlinkage long sys32_mount(char *dev_name, char *dir_name, char *type, unsigned long new_flags, u32 data)
-{
-	unsigned long type_page = 0;
-	unsigned long data_page = 0;
-	unsigned long dev_page = 0;
-	unsigned long dir_page = 0;
-	int err, is_smb, is_ncp;
-	
-	is_smb = is_ncp = 0;
-
-	err = copy_mount_stuff_to_kernel((const void *)type, &type_page);
-	if (err)
-		goto out;
-
-	if (type_page) {
-		is_smb = !strcmp((char *)type_page, SMBFS_NAME);
-		is_ncp = !strcmp((char *)type_page, NCPFS_NAME);
-	} else {
-		is_smb = is_ncp = 0;
-	}
-
-	err = copy_mount_stuff_to_kernel((const void *)AA(data), &data_page);
-	if (err)
-		goto type_out;
-
-	err = copy_mount_stuff_to_kernel(dev_name, &dev_page);
-	if (err)
-		goto data_out;
-
-	err = copy_mount_stuff_to_kernel(dir_name, &dir_page);
-	if (err)
-		goto dev_out;
-
-	if (!is_smb && !is_ncp) {
-		lock_kernel();
-		err = do_mount((char*)dev_page, (char*)dir_page,
-				(char*)type_page, new_flags, (char*)data_page);
-		unlock_kernel();
-	} else {
-		if (is_ncp)
-			do_ncp_super_data_conv((void *)data_page);
-		else
-			do_smb_super_data_conv((void *)data_page);
-
-		lock_kernel();
-		err = do_mount((char*)dev_page, (char*)dir_page,
-				(char*)type_page, new_flags, (char*)data_page);
-		unlock_kernel();
-	}
-	free_page(dir_page);
-
-dev_out:
-	free_page(dev_page);
-
-data_out:
-	free_page(data_page);
-
-type_out:
-	free_page(type_page);
-
-out:
-	return err;
-}
-
 /* readdir & getdents */
 #define NAME_OFFSET(de) ((int) ((de)->d_name - (char *) (de)))
 #define ROUND_UP(x) (((x)+sizeof(u32)-1) & ~(sizeof(u32)-1))
@@ -527,9 +322,8 @@ struct getdents_callback32 {
 	int error;
 };
 
-static int
-filldir(void * __buf, const char * name, int namlen, off_t offset, ino_t ino,
-		               unsigned int d_type)
+static int filldir(void * __buf, const char * name, int namlen, off_t offset,
+		   ino_t ino, unsigned int d_type)
 {
 	struct linux_dirent32 * dirent;
 	struct getdents_callback32 * buf = (struct getdents_callback32 *) __buf;
@@ -539,28 +333,44 @@ filldir(void * __buf, const char * name,
 	if (reclen > buf->count)
 		return -EINVAL;
 	dirent = buf->previous;
-	if (dirent)
-		put_user(offset, &dirent->d_off);
+	if (dirent) {
+		if (__put_user(offset, &dirent->d_off))
+			goto efault;
+	}
 	dirent = buf->current_dir;
+	if (__put_user(ino, &dirent->d_ino))
+		goto efault;
+	if (__put_user(reclen, &dirent->d_reclen))
+		goto efault;
+	if (copy_to_user(dirent->d_name, name, namlen))
+		goto efault;
+	if (__put_user(0, dirent->d_name + namlen))
+		goto efault;
+	if (__put_user(d_type, (char *) dirent + reclen - 1))
+		goto efault;
 	buf->previous = dirent;
-	put_user(ino, &dirent->d_ino);
-	put_user(reclen, &dirent->d_reclen);
-	copy_to_user(dirent->d_name, name, namlen);
-	put_user(0, dirent->d_name + namlen);
-	put_user(d_type, (char *) dirent + reclen - 1);
-	((char *) dirent) += reclen;
+	dirent = (void *)dirent + reclen;
 	buf->current_dir = dirent;
 	buf->count -= reclen;
 	return 0;
+efault:
+	buf->error = -EFAULT;
+	return -EFAULT;
 }
 
-asmlinkage long sys32_getdents(unsigned int fd, struct linux_dirent32 *dirent, unsigned int count)
+long sys32_getdents(unsigned int fd, struct linux_dirent32 *dirent,
+		    unsigned int count)
 {
 	struct file * file;
 	struct linux_dirent32 * lastdirent;
 	struct getdents_callback32 buf;
-	int error = -EBADF;
+	int error;
 
+	error = -EFAULT;
+	if (!access_ok(VERIFY_WRITE, dirent, count))
+		goto out;
+
+	error = -EBADF;
 	file = fget(fd);
 	if (!file)
 		goto out;
@@ -573,19 +383,20 @@ asmlinkage long sys32_getdents(unsigned 
 	error = vfs_readdir(file, (filldir_t)filldir, &buf);
 	if (error < 0)
 		goto out_putf;
-	lastdirent = buf.previous;
 	error = buf.error;
-	if(lastdirent) {
-		put_user(file->f_pos, &lastdirent->d_off);
-		error = count - buf.count;
+	lastdirent = buf.previous;
+	if (lastdirent) {
+		if (put_user(file->f_pos, &lastdirent->d_off))
+			error = -EFAULT;
+		else
+			error = count - buf.count;
 	}
- out_putf:
-	fput(file);
 
- out:
+out_putf:
+	fput(file);
+out:
 	return error;
 }
-/* end of readdir & getdents */
 
 /*
  * Ooo, nasty.  We need here to frob 32-bit unsigned longs to
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/appldata/appldata_base.c linux-post-2.6.5-rc2-20040329/arch/s390/appldata/appldata_base.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/appldata/appldata_base.c	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/appldata/appldata_base.c	2004-03-27 11:40:46.000000000 +0000
@@ -372,31 +372,57 @@ static int
 appldata_generic_handler(ctl_table *ctl, int write, struct file *filp,
 			   void *buffer, size_t *lenp)
 {
-	struct appldata_ops *ops;
-	int rc, len;
+	struct appldata_ops *ops = NULL, *tmp_ops;
+	int rc, len, found;
 	char buf[2];
+	struct list_head *lh;
 
+	found = 0;
+	spin_lock_bh(&appldata_ops_lock);
+	list_for_each(lh, &appldata_ops_list) {
+		tmp_ops = list_entry(lh, struct appldata_ops, list);
+		if (&tmp_ops->ctl_table[2] == ctl) {
+			found = 1;
+		}
+	}
+	if (!found) {
+		spin_unlock_bh(&appldata_ops_lock);
+		return -ENODEV;
+	}
 	ops = ctl->data;
+	if (!try_module_get(ops->owner)) {	// protect this function
+		spin_unlock_bh(&appldata_ops_lock);
+		return -ENODEV;
+	}
+	spin_unlock_bh(&appldata_ops_lock);
+
 	if (!*lenp || filp->f_pos) {
 		*lenp = 0;
+		module_put(ops->owner);
 		return 0;
 	}
 	if (!write) {
 		len = sprintf(buf, ops->active ? "1\n" : "0\n");
 		if (len > *lenp)
 			len = *lenp;
-		if (copy_to_user(buffer, buf, len))
+		if (copy_to_user(buffer, buf, len)) {
+			module_put(ops->owner);
 			return -EFAULT;
+		}
 		goto out;
 	}
 	len = *lenp;
-	if (copy_from_user(buf, buffer, len > sizeof(buf) ? sizeof(buf) : len))
+	if (copy_from_user(buf, buffer,
+			   len > sizeof(buf) ? sizeof(buf) : len)) {
+		module_put(ops->owner);
 		return -EFAULT;
+	}
 
 	spin_lock_bh(&appldata_ops_lock);
 	if ((buf[0] == '1') && (ops->active == 0)) {
-		if (!try_module_get(ops->owner)) {
+		if (!try_module_get(ops->owner)) {	// protect tasklet
 			spin_unlock_bh(&appldata_ops_lock);
+			module_put(ops->owner);
 			return -ENODEV;
 		}
 		ops->active = 1;
@@ -430,6 +456,7 @@ appldata_generic_handler(ctl_table *ctl,
 out:
 	*lenp = len;
 	filp->f_pos += len;
+	module_put(ops->owner);
 	return 0;
 }
 
@@ -511,7 +538,6 @@ int appldata_register_ops(struct appldat
 	ops->ctl_table[3].ctl_name = 0;
 
 	ops->sysctl_header = register_sysctl_table(ops->ctl_table,1);
-	ops->ctl_table[2].de->owner = ops->owner;
 
 	P_INFO("%s-ops registered!\n", ops->name);
 	return 0;
@@ -525,10 +551,11 @@ int appldata_register_ops(struct appldat
 void appldata_unregister_ops(struct appldata_ops *ops)
 {
 	spin_lock_bh(&appldata_ops_lock);
-	list_del(&ops->list);
-	spin_unlock_bh(&appldata_ops_lock);
 	unregister_sysctl_table(ops->sysctl_header);
+	list_del(&ops->list);
 	kfree(ops->ctl_table);
+	ops->ctl_table = NULL;
+	spin_unlock_bh(&appldata_ops_lock);
 	P_INFO("%s-ops unregistered!\n", ops->name);
 }
 /********************** module-ops management <END> **************************/
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/defconfig linux-post-2.6.5-rc2-20040329/arch/s390/defconfig
--- linux-post-2.6.5-rc2-20040327/arch/s390/defconfig	2004-02-26 11:21:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/defconfig	2004-03-27 11:40:45.000000000 +0000
@@ -21,9 +21,11 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=17
-# CONFIG_IKCONFIG is not set
+CONFIG_HOTPLUG=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
 # CONFIG_EMBEDDED is not set
-# CONFIG_KALLSYMS is not set
+CONFIG_KALLSYMS=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 CONFIG_IOSCHED_NOOP=y
@@ -84,6 +86,7 @@ CONFIG_PFAULT=y
 # Generic Driver Options
 #
 # CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
 
 #
 # SCSI device support
@@ -110,6 +113,12 @@ CONFIG_SCSI_CONSTANTS=y
 CONFIG_SCSI_LOGGING=y
 
 #
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
 # SCSI low-level drivers
 #
 # CONFIG_SCSI_AIC7XXX_OLD is not set
@@ -185,7 +194,6 @@ CONFIG_S390_TAPE_BLOCK=y
 # S/390 tape hardware support
 #
 CONFIG_S390_TAPE_34XX=m
-CONFIG_HOTPLUG=y
 
 #
 # Networking support
@@ -199,7 +207,7 @@ CONFIG_PACKET=y
 # CONFIG_PACKET_MMAP is not set
 # CONFIG_NETLINK_DEV is not set
 CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
+CONFIG_NET_KEY=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 # CONFIG_IP_ADVANCED_ROUTER is not set
@@ -208,7 +216,6 @@ CONFIG_IP_MULTICAST=y
 # CONFIG_NET_IPGRE is not set
 # CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
-# CONFIG_INET_ECN is not set
 # CONFIG_SYN_COOKIES is not set
 # CONFIG_INET_AH is not set
 # CONFIG_INET_ESP is not set
@@ -222,11 +229,12 @@ CONFIG_IPV6=y
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_NETFILTER is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
 
 #
 # SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -247,6 +255,7 @@ CONFIG_IPV6_SCTP__=y
 CONFIG_NET_SCHED=y
 CONFIG_NET_SCH_CBQ=m
 # CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
 CONFIG_NET_SCH_CSZ=m
 CONFIG_NET_SCH_PRIO=m
 CONFIG_NET_SCH_RED=m
@@ -255,6 +264,7 @@ CONFIG_NET_SCH_TEQL=m
 CONFIG_NET_SCH_TBF=m
 CONFIG_NET_SCH_GRED=m
 CONFIG_NET_SCH_DSMARK=m
+# CONFIG_NET_SCH_DELAY is not set
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
@@ -303,6 +313,7 @@ CONFIG_NET_ETHERNET=y
 #
 # CONFIG_TR is not set
 # CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
 
 #
 # Wan interfaces
@@ -340,6 +351,8 @@ CONFIG_CCWGROUP=y
 # Bluetooth support
 #
 # CONFIG_BT is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # File systems
@@ -380,7 +393,6 @@ CONFIG_FS_MBCACHE=y
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 # CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
 # CONFIG_HUGETLB_PAGE is not set
@@ -392,6 +404,7 @@ CONFIG_RAMFS=y
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
@@ -417,7 +430,7 @@ CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
 CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_GSS is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
@@ -484,7 +497,9 @@ CONFIG_CRYPTO=y
 # CONFIG_CRYPTO_AES is not set
 # CONFIG_CRYPTO_CAST5 is not set
 # CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_ARC4 is not set
 # CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
 # CONFIG_CRYPTO_TEST is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/asm-offsets.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/asm-offsets.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/asm-offsets.c	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/asm-offsets.c	2004-03-27 11:40:46.000000000 +0000
@@ -17,10 +17,10 @@
 int main(void)
 {
 	DEFINE(__THREAD_info, offsetof(struct task_struct, thread_info),);
-	DEFINE(__THREAD_ar2, offsetof(struct task_struct, thread.ar2),);
-	DEFINE(__THREAD_ar4, offsetof(struct task_struct, thread.ar4),);
 	DEFINE(__THREAD_ksp, offsetof(struct task_struct, thread.ksp),);
 	DEFINE(__THREAD_per, offsetof(struct task_struct, thread.per_info),);
+	DEFINE(__THREAD_mm_segment,
+	       offsetof(struct task_struct, thread.mm_segment),);
 	BLANK();
 	DEFINE(__PER_atmid, offsetof(per_struct, lowcore.words.perc_atmid),);
 	DEFINE(__PER_address, offsetof(per_struct, lowcore.words.address),);
@@ -31,5 +31,12 @@ int main(void)
 	DEFINE(__TI_flags, offsetof(struct thread_info, flags),);
 	DEFINE(__TI_cpu, offsetof(struct thread_info, cpu),);
 	DEFINE(__TI_precount, offsetof(struct thread_info, preempt_count),);
+	BLANK();
+	DEFINE(__PT_PSW, offsetof(struct pt_regs, psw),);
+	DEFINE(__PT_GPRS, offsetof(struct pt_regs, gprs),);
+	DEFINE(__PT_ORIG_GPR2, offsetof(struct pt_regs, orig_gpr2),);
+	DEFINE(__PT_ILC, offsetof(struct pt_regs, ilc),);
+	DEFINE(__PT_TRAP, offsetof(struct pt_regs, trap),);
+	DEFINE(__PT_SIZE, sizeof(struct pt_regs),);
 	return 0;
 }
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/binfmt_elf32.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/binfmt_elf32.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/binfmt_elf32.c	2004-02-23 18:13:09.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/binfmt_elf32.c	2004-03-27 11:40:46.000000000 +0000
@@ -57,18 +57,7 @@
 /* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
    now struct_user_regs, they are different) */
 
-#define ELF_CORE_COPY_REGS(pr_reg, regs)        \
-	{ \
-	int i; \
-	memcpy(&pr_reg.psw.mask, &regs->psw.mask, 4); \
-	memcpy(&pr_reg.psw.addr, ((char*)&regs->psw.addr)+4, 4); \
-	for(i=0; i<NUM_GPRS; i++) \
-		pr_reg.gprs[i] = regs->gprs[i]; \
-	for(i=0; i<NUM_ACRS; i++) \
-		pr_reg.acrs[i] = regs->acrs[i]; \
-	pr_reg.orig_gpr2 = regs->orig_gpr2; \
-	}
-
+#define ELF_CORE_COPY_REGS(pr_reg, regs) dump_regs32(regs, &pr_reg);
 
 
 /* This yields a mask that user programs can use to figure out what
@@ -107,6 +96,18 @@ typedef struct
 } s390_regs32;
 typedef s390_regs32 elf_gregset_t;
 
+static inline int dump_regs32(struct pt_regs *ptregs, elf_gregset_t *regs)
+{
+	int i;
+
+	memcpy(&regs->psw.mask, &ptregs->psw.mask, 4);
+	memcpy(&regs->psw.addr, &ptregs->psw.addr, 4);
+	for (i = 0; i < NUM_GPRS; i++)
+		regs->gprs[i] = ptregs->gprs[i];
+	regs->orig_gpr2 = ptregs->orig_gpr2;
+	return 1;
+}
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/config.h>
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/compat_linux.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/compat_linux.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/compat_linux.c	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/compat_linux.c	2004-03-27 21:46:54.000000000 +0000
@@ -35,9 +35,6 @@
 #include <linux/slab.h>
 #include <linux/uio.h>
 #include <linux/nfs_fs.h>
-#include <linux/smb_fs.h>
-#include <linux/smb_mount.h>
-#include <linux/ncp_fs.h>
 #include <linux/quota.h>
 #include <linux/module.h>
 #include <linux/sunrpc/svc.h>
@@ -298,7 +295,7 @@ static inline long put_tv32(struct compa
  *
  * This is really horribly ugly.
  */
-asmlinkage int sys32_ipc (u32 call, int first, int second, int third, u32 ptr)
+asmlinkage long sys32_ipc(u32 call, int first, int second, int third, u32 ptr)
 {
 	if(call >> 16) /* hack for backward compatibility */
 		return -EINVAL;
@@ -360,7 +357,7 @@ asmlinkage int sys32_ipc (u32 call, int 
 	return -EINVAL;
 }
 
-asmlinkage int sys32_truncate64(const char * path, unsigned long high, unsigned long low)
+asmlinkage long sys32_truncate64(const char * path, unsigned long high, unsigned long low)
 {
 	if ((int)high < 0)
 		return -EINVAL;
@@ -368,7 +365,7 @@ asmlinkage int sys32_truncate64(const ch
 		return sys_truncate(path, (high << 32) | low);
 }
 
-asmlinkage int sys32_ftruncate64(unsigned int fd, unsigned long high, unsigned long low)
+asmlinkage long sys32_ftruncate64(unsigned int fd, unsigned long high, unsigned long low)
 {
 	if ((int)high < 0)
 		return -EINVAL;
@@ -479,7 +476,7 @@ out:
 	return retval;
 }
 
-asmlinkage long sys32_readv(int fd, struct compat_iovec *vector, u32 count)
+asmlinkage long sys32_readv(int fd, struct compat_iovec *vector, unsigned long count)
 {
 	struct file *file;
 	long ret = -EBADF;
@@ -497,7 +494,7 @@ bad_file:
 	return ret;
 }
 
-asmlinkage long sys32_writev(int fd, struct compat_iovec *vector, u32 count)
+asmlinkage long sys32_writev(int fd, struct compat_iovec *vector, unsigned long count)
 {
 	struct file *file;
 	int ret = -EBADF;
@@ -549,7 +546,7 @@ static int fillonedir(void * __buf, cons
 	return 0;
 }
 
-asmlinkage int old32_readdir(unsigned int fd, struct old_linux_dirent32 *dirent, unsigned int count)
+asmlinkage long old32_readdir(unsigned int fd, struct old_linux_dirent32 *dirent, unsigned int count)
 {
 	int error = -EBADF;
 	struct file * file;
@@ -611,7 +608,7 @@ static int filldir(void * __buf, const c
 	return 0;
 }
 
-asmlinkage int sys32_getdents(unsigned int fd, struct linux_dirent32 *dirent, unsigned int count)
+asmlinkage long sys32_getdents(unsigned int fd, struct linux_dirent32 *dirent, unsigned int count)
 {
 	struct file * file;
 	struct linux_dirent32 * lastdirent;
@@ -706,10 +703,10 @@ set_fd_set32(unsigned long n, u32 *ufdse
 #define MAX_SELECT_SECONDS \
 	((unsigned long) (MAX_SCHEDULE_TIMEOUT / HZ)-1)
 
-asmlinkage int sys32_select(int n, u32 *inp, u32 *outp, u32 *exp, u32 tvp_x)
+asmlinkage long sys32_select(int n, u32 *inp, u32 *outp, u32 *exp,
+				struct compat_timeval *tvp)
 {
 	fd_set_bits fds;
-	struct compat_timeval *tvp = (struct compat_timeval *)AA(tvp_x);
 	char *bits;
 	unsigned long nn;
 	long timeout;
@@ -828,157 +825,6 @@ int cp_compat_stat(struct kstat *stat, s
 	return err;
 }
 
-struct ncp_mount_data32 {
-        int version;
-        unsigned int ncp_fd;
-        compat_uid_t mounted_uid;
-        compat_pid_t wdog_pid;
-        unsigned char mounted_vol[NCP_VOLNAME_LEN + 1];
-        unsigned int time_out;
-        unsigned int retry_count;
-        unsigned int flags;
-        compat_uid_t uid;
-        compat_gid_t gid;
-        compat_mode_t file_mode;
-        compat_mode_t dir_mode;
-};
-
-static void *do_ncp_super_data_conv(void *raw_data)
-{
-	struct ncp_mount_data *n = (struct ncp_mount_data *)raw_data;
-	struct ncp_mount_data32 *n32 = (struct ncp_mount_data32 *)raw_data;
-
-	n->dir_mode = n32->dir_mode;
-	n->file_mode = n32->file_mode;
-	n->gid = low2highgid(n32->gid);
-	n->uid = low2highuid(n32->uid);
-	memmove (n->mounted_vol, n32->mounted_vol, (sizeof (n32->mounted_vol) + 3 * sizeof (unsigned int)));
-	n->wdog_pid = n32->wdog_pid;
-	n->mounted_uid = low2highuid(n32->mounted_uid);
-	return raw_data;
-}
-
-struct smb_mount_data32 {
-        int version;
-        compat_uid_t mounted_uid;
-        compat_uid_t uid;
-        compat_gid_t gid;
-        compat_mode_t file_mode;
-        compat_mode_t dir_mode;
-};
-
-static void *do_smb_super_data_conv(void *raw_data)
-{
-	struct smb_mount_data *s = (struct smb_mount_data *)raw_data;
-	struct smb_mount_data32 *s32 = (struct smb_mount_data32 *)raw_data;
-
-	if (s32->version != SMB_MOUNT_OLDVERSION)
-		goto out;
-	s->version = s32->version;
-	s->mounted_uid = low2highuid(s32->mounted_uid);
-	s->uid = low2highuid(s32->uid);
-	s->gid = low2highgid(s32->gid);
-	s->file_mode = s32->file_mode;
-	s->dir_mode = s32->dir_mode;
-out:
-	return raw_data;
-}
-
-static int copy_mount_stuff_to_kernel(const void *user, unsigned long *kernel)
-{
-	int i;
-	unsigned long page;
-	struct vm_area_struct *vma;
-
-	*kernel = 0;
-	if(!user)
-		return 0;
-	vma = find_vma(current->mm, (unsigned long)user);
-	if(!vma || (unsigned long)user < vma->vm_start)
-		return -EFAULT;
-	if(!(vma->vm_flags & VM_READ))
-		return -EFAULT;
-	i = vma->vm_end - (unsigned long) user;
-	if(PAGE_SIZE <= (unsigned long) i)
-		i = PAGE_SIZE - 1;
-	if(!(page = __get_free_page(GFP_KERNEL)))
-		return -ENOMEM;
-	if(copy_from_user((void *) page, user, i)) {
-		free_page(page);
-		return -EFAULT;
-	}
-	*kernel = page;
-	return 0;
-}
-
-#define SMBFS_NAME	"smbfs"
-#define NCPFS_NAME	"ncpfs"
-
-asmlinkage int sys32_mount(char *dev_name, char *dir_name, char *type, unsigned long new_flags, u32 data)
-{
-	unsigned long type_page = 0;
-	unsigned long data_page = 0;
-	unsigned long dev_page = 0;
-	unsigned long dir_page = 0;
-	int err, is_smb, is_ncp;
-
-	is_smb = is_ncp = 0;
-
-	err = copy_mount_stuff_to_kernel((const void *)type, &type_page);
-	if (err)
-		goto out;
-
-	if (!type_page) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	is_smb = !strcmp((char *)type_page, SMBFS_NAME);
-	is_ncp = !strcmp((char *)type_page, NCPFS_NAME);
-
-	err = copy_mount_stuff_to_kernel((const void *)AA(data), &data_page);
-	if (err)
-		goto type_out;
-
-	err = copy_mount_stuff_to_kernel(dev_name, &dev_page);
-	if (err)
-		goto data_out;
-
-	err = copy_mount_stuff_to_kernel(dir_name, &dir_page);
-	if (err)
-		goto dev_out;
-
-	if (!is_smb && !is_ncp) {
-		lock_kernel();
-		err = do_mount((char*)dev_page, (char*)dir_page,
-				(char*)type_page, new_flags, (char*)data_page);
-		unlock_kernel();
-	} else {
-		if (is_ncp)
-			do_ncp_super_data_conv((void *)data_page);
-		else
-			do_smb_super_data_conv((void *)data_page);
-
-		lock_kernel();
-		err = do_mount((char*)dev_page, (char*)dir_page,
-				(char*)type_page, new_flags, (char*)data_page);
-		unlock_kernel();
-	}
-	free_page(dir_page);
-
-dev_out:
-	free_page(dev_page);
-
-data_out:
-	free_page(data_page);
-
-type_out:
-	free_page(type_page);
-
-out:
-	return err;
-}
-
 struct sysinfo32 {
         s32 uptime;
         u32 loads[3];
@@ -996,7 +842,7 @@ struct sysinfo32 {
         char _f[8];
 };
 
-asmlinkage int sys32_sysinfo(struct sysinfo32 __user *info)
+asmlinkage long sys32_sysinfo(struct sysinfo32 __user *info)
 {
 	struct sysinfo s;
 	int ret, err;
@@ -1024,7 +870,7 @@ asmlinkage int sys32_sysinfo(struct sysi
 	return ret;
 }
 
-asmlinkage int sys32_sched_rr_get_interval(compat_pid_t pid,
+asmlinkage long sys32_sched_rr_get_interval(compat_pid_t pid,
 				struct compat_timespec __user *interval)
 {
 	struct timespec t;
@@ -1039,8 +885,8 @@ asmlinkage int sys32_sched_rr_get_interv
 	return ret;
 }
 
-asmlinkage int sys32_rt_sigprocmask(int how, compat_sigset_t __user *set,
-			compat_sigset_t __user *oset, compat_size_t sigsetsize)
+asmlinkage long sys32_rt_sigprocmask(int how, compat_sigset_t __user *set,
+			compat_sigset_t __user *oset, size_t sigsetsize)
 {
 	sigset_t s;
 	compat_sigset_t s32;
@@ -1074,8 +920,8 @@ asmlinkage int sys32_rt_sigprocmask(int 
 	return 0;
 }
 
-asmlinkage int sys32_rt_sigpending(compat_sigset_t __user *set,
-				compat_size_t sigsetsize)
+asmlinkage long sys32_rt_sigpending(compat_sigset_t __user *set,
+				size_t sigsetsize)
 {
 	sigset_t s;
 	compat_sigset_t s32;
@@ -1101,9 +947,9 @@ asmlinkage int sys32_rt_sigpending(compa
 extern int
 copy_siginfo_to_user32(siginfo_t32 *to, siginfo_t *from);
 
-asmlinkage int
+asmlinkage long
 sys32_rt_sigtimedwait(compat_sigset_t *uthese, siginfo_t32 *uinfo,
-		      struct compat_timespec *uts, compat_size_t sigsetsize)
+		      struct compat_timespec *uts, size_t sigsetsize)
 {
 	int ret, sig;
 	sigset_t these;
@@ -1182,7 +1028,7 @@ sys32_rt_sigtimedwait(compat_sigset_t *u
 	return ret;
 }
 
-asmlinkage int
+asmlinkage long
 sys32_rt_sigqueueinfo(int pid, int sig, siginfo_t32 __user *uinfo)
 {
 	siginfo_t info;
@@ -1384,7 +1230,7 @@ out_file:
  * sys32_execve() executes a new program after the asm stub has set
  * things up for us.  This should basically do what I want it to.
  */
-asmlinkage int
+asmlinkage long
 sys32_execve(struct pt_regs regs)
 {
         int error;
@@ -1412,14 +1258,14 @@ out:
 
 #ifdef CONFIG_MODULES
 
-asmlinkage int
+asmlinkage long
 sys32_init_module(void __user *umod, unsigned long len,
 		const char __user *uargs)
 {
 	return sys_init_module(umod, len, uargs);
 }
 
-asmlinkage int
+asmlinkage long
 sys32_delete_module(const char __user *name_user, unsigned int flags)
 {
 	return sys_delete_module(name_user, flags);
@@ -1427,14 +1273,14 @@ sys32_delete_module(const char __user *n
 
 #else /* CONFIG_MODULES */
 
-asmlinkage int
+asmlinkage long
 sys32_init_module(void __user *umod, unsigned long len,
 		const char __user *uargs)
 {
 	return -ENOSYS;
 }
 
-asmlinkage int
+asmlinkage long
 sys32_delete_module(const char __user *name_user, unsigned int flags)
 {
 	return -ENOSYS;
@@ -1599,7 +1445,7 @@ static int nfs_getfh32_res_trans(union n
 	return copy_to_user(res32, kres, sizeof(*res32)) ? -EFAULT : 0;
 }
 
-int asmlinkage sys32_nfsservctl(int cmd, struct nfsctl_arg32 *arg32, union nfsctl_res32 *res32)
+long asmlinkage sys32_nfsservctl(int cmd, struct nfsctl_arg32 *arg32, union nfsctl_res32 *res32)
 {
 	struct nfsctl_arg *karg = NULL;
 	union nfsctl_res *kres = NULL;
@@ -1667,7 +1513,7 @@ done:
 
 extern struct timezone sys_tz;
 
-asmlinkage int sys32_gettimeofday(struct compat_timeval *tv, struct timezone *tz)
+asmlinkage long sys32_gettimeofday(struct compat_timeval *tv, struct timezone *tz)
 {
 	if (tv) {
 		struct timeval ktv;
@@ -1696,7 +1542,7 @@ static inline long get_ts32(struct times
 	return 0;
 }
 
-asmlinkage int sys32_settimeofday(struct compat_timeval *tv, struct timezone *tz)
+asmlinkage long sys32_settimeofday(struct compat_timeval *tv, struct timezone *tz)
 {
 	struct timespec kts;
 	struct timezone ktz;
@@ -1714,23 +1560,23 @@ asmlinkage int sys32_settimeofday(struct
 }
 
 /* These are here just in case some old sparc32 binary calls it. */
-asmlinkage int sys32_pause(void)
+asmlinkage long sys32_pause(void)
 {
 	current->state = TASK_INTERRUPTIBLE;
 	schedule();
 	return -ERESTARTNOHAND;
 }
 
-asmlinkage compat_ssize_t sys32_pread64(unsigned int fd, char *ubuf,
-				 compat_size_t count, u32 poshi, u32 poslo)
+asmlinkage long sys32_pread64(unsigned int fd, char *ubuf,
+				size_t count, u32 poshi, u32 poslo)
 {
 	if ((compat_ssize_t) count < 0)
 		return -EINVAL;
 	return sys_pread64(fd, ubuf, count, ((loff_t)AA(poshi) << 32) | AA(poslo));
 }
 
-asmlinkage compat_ssize_t sys32_pwrite64(unsigned int fd, char *ubuf,
-				  compat_size_t count, u32 poshi, u32 poslo)
+asmlinkage long sys32_pwrite64(unsigned int fd, const char *ubuf,
+				size_t count, u32 poshi, u32 poslo)
 {
 	if ((compat_ssize_t) count < 0)
 		return -EINVAL;
@@ -1742,7 +1588,7 @@ asmlinkage compat_ssize_t sys32_readahea
 	return sys_readahead(fd, ((loff_t)AA(offhi) << 32) | AA(offlo), count);
 }
 
-asmlinkage int sys32_sendfile(int out_fd, int in_fd, compat_off_t *offset, s32 count)
+asmlinkage long sys32_sendfile(int out_fd, int in_fd, compat_off_t *offset, size_t count)
 {
 	mm_segment_t old_fs = get_fs();
 	int ret;
@@ -1761,7 +1607,7 @@ asmlinkage int sys32_sendfile(int out_fd
 	return ret;
 }
 
-asmlinkage int sys32_sendfile64(int out_fd, int in_fd, 
+asmlinkage long sys32_sendfile64(int out_fd, int in_fd,
 				compat_loff_t *offset, s32 count)
 {
 	mm_segment_t old_fs = get_fs();
@@ -1798,7 +1644,7 @@ struct timex32 {
 
 extern int do_adjtimex(struct timex *);
 
-asmlinkage int sys32_adjtimex(struct timex32 *utp)
+asmlinkage long sys32_adjtimex(struct timex32 *utp)
 {
 	struct timex txc;
 	int ret;
@@ -1951,7 +1797,7 @@ static int cp_stat64(struct stat64_emu31
 	return copy_to_user(ubuf,&tmp,sizeof(tmp)) ? -EFAULT : 0; 
 }
 
-asmlinkage long sys32_stat64(char * filename, struct stat64_emu31 * statbuf, long flags)
+asmlinkage long sys32_stat64(char * filename, struct stat64_emu31 * statbuf)
 {
 	struct kstat stat;
 	int ret = vfs_stat(filename, &stat);
@@ -1960,7 +1806,7 @@ asmlinkage long sys32_stat64(char * file
 	return ret;
 }
 
-asmlinkage long sys32_lstat64(char * filename, struct stat64_emu31 * statbuf, long flags)
+asmlinkage long sys32_lstat64(char * filename, struct stat64_emu31 * statbuf)
 {
 	struct kstat stat;
 	int ret = vfs_lstat(filename, &stat);
@@ -1969,7 +1815,7 @@ asmlinkage long sys32_lstat64(char * fil
 	return ret;
 }
 
-asmlinkage long sys32_fstat64(unsigned long fd, struct stat64_emu31 * statbuf, long flags)
+asmlinkage long sys32_fstat64(unsigned long fd, struct stat64_emu31 * statbuf)
 {
 	struct kstat stat;
 	int ret = vfs_fstat(fd, &stat);
@@ -2056,7 +1902,7 @@ out:
 	return error;
 }
 
-asmlinkage compat_ssize_t sys32_read(unsigned int fd, char * buf, size_t count)
+asmlinkage long sys32_read(unsigned int fd, char * buf, size_t count)
 {
 	if ((compat_ssize_t) count < 0)
 		return -EINVAL; 
@@ -2064,7 +1910,7 @@ asmlinkage compat_ssize_t sys32_read(uns
 	return sys_read(fd, buf, count);
 }
 
-asmlinkage compat_ssize_t sys32_write(unsigned int fd, char * buf, size_t count)
+asmlinkage long sys32_write(unsigned int fd, char * buf, size_t count)
 {
 	if ((compat_ssize_t) count < 0)
 		return -EINVAL; 
@@ -2072,7 +1918,7 @@ asmlinkage compat_ssize_t sys32_write(un
 	return sys_write(fd, buf, count);
 }
 
-asmlinkage int sys32_clone(struct pt_regs regs)
+asmlinkage long sys32_clone(struct pt_regs regs)
 {
         unsigned long clone_flags;
         unsigned long newsp;
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/compat_signal.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/compat_signal.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/compat_signal.c	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/compat_signal.c	2004-03-27 11:40:46.000000000 +0000
@@ -161,7 +161,7 @@ sys32_rt_sigsuspend(struct pt_regs * reg
         }
 }                                                         
 
-asmlinkage int
+asmlinkage long
 sys32_sigaction(int sig, const struct old_sigaction32 *act,
 		 struct old_sigaction32 *oact)
 {
@@ -254,7 +254,7 @@ sys32_rt_sigaction(int sig, const struct
 	return ret;
 }
 
-asmlinkage int
+asmlinkage long
 sys32_sigaltstack(const stack_t32 *uss, stack_t32 *uoss, struct pt_regs *regs)
 {
 	stack_t kss, koss;
@@ -297,7 +297,8 @@ static int save_sigregs32(struct pt_regs
 	regs32.psw.addr = PSW32_ADDR_AMODE31 | (__u32) regs->psw.addr;
 	for (i = 0; i < NUM_GPRS; i++)
 		regs32.gprs[i] = (__u32) regs->gprs[i];
-	memcpy(regs32.acrs, regs->acrs, sizeof(regs32.acrs));
+	save_access_regs(current->thread.acrs);
+	memcpy(regs32.acrs, current->thread.acrs, sizeof(regs32.acrs));
 	err = __copy_to_user(&sregs->regs, &regs32, sizeof(regs32));
 	if (err)
 		return err;
@@ -323,7 +324,8 @@ static int restore_sigregs32(struct pt_r
 	regs->psw.addr = (__u64)(regs32.psw.addr & PSW32_ADDR_INSN);
 	for (i = 0; i < NUM_GPRS; i++)
 		regs->gprs[i] = (__u64) regs32.gprs[i];
-	memcpy(regs->acrs, regs32.acrs, sizeof(regs32.acrs));
+	memcpy(current->thread.acrs, regs32.acrs, sizeof(current->thread.acrs));
+	restore_access_regs(current->thread.acrs);
 
 	err = __copy_from_user(&current->thread.fp_regs, &sregs->fpregs,
 			       sizeof(_s390_fp_regs32));
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/compat_wrapper.S linux-post-2.6.5-rc2-20040329/arch/s390/kernel/compat_wrapper.S
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/compat_wrapper.S	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/compat_wrapper.S	2004-03-27 21:43:12.000000000 +0000
@@ -102,7 +102,7 @@ sys32_mount_wrapper:
 	llgtr	%r4,%r4			# char *
 	llgfr	%r5,%r5			# unsigned long
 	llgtr	%r6,%r6			# void *
-	jg	sys32_mount		# branch to system call
+	jg	compat_sys_mount	# branch to system call
 
 	.globl  sys32_oldumount_wrapper 
 sys32_oldumount_wrapper:
@@ -126,7 +126,7 @@ sys32_ptrace_wrapper:
 
 	.globl  sys32_alarm_wrapper 
 sys32_alarm_wrapper:
-	llgtr	%r2,%r2			# unsigned int
+	llgfr	%r2,%r2			# unsigned int
 	jg	sys_alarm		# branch to system call
 
 #sys32_pause_wrapper			# void 
@@ -203,7 +203,7 @@ sys32_setgid16_wrapper:
 	.globl sys32_signal_wrapper
 sys32_signal_wrapper:
 	lgfr	%r2,%r2			# int 
-	llgfr	%r3,%r3			# __sighandler_t 
+	llgtr	%r3,%r3			# __sighandler_t
 	jg	sys_signal
 
 #sys32_geteuid16_wrapper		# void 
@@ -243,7 +243,7 @@ sys32_setpgid_wrapper:
 
 	.globl  sys32_umask_wrapper 
 sys32_umask_wrapper:
-	lgfr	%r3,%r3			# int
+	lgfr	%r2,%r2			# int
 	jg	sys_umask		# branch to system call
 
 	.globl  sys32_chroot_wrapper 
@@ -273,6 +273,7 @@ sys32_dup2_wrapper:
 sys32_sigaction_wrapper:
 	lgfr	%r2,%r2			# int 
 	llgtr	%r3,%r3			# const struct old_sigaction *
+	llgtr	%r4,%r4			# struct old_sigaction32 *
 	jg	sys32_sigaction		# branch to system call
 
 	.globl  sys32_setreuid16_wrapper 
@@ -424,8 +425,8 @@ sys32_fchmod_wrapper:
 	.globl  sys32_fchown16_wrapper 
 sys32_fchown16_wrapper:
 	llgfr	%r2,%r2			# unsigned int
-	llgtr	%r3,%r3			# __kernel_old_uid_emu31_t *
-	llgtr	%r4,%r4			# __kernel_old_gid_emu31_t *
+	llgfr	%r3,%r3			# compat_uid_t
+	llgfr	%r4,%r4			# compat_uid_t
 	jg	sys32_fchown16		# branch to system call
 
 	.globl  sys32_getpriority_wrapper 
@@ -523,7 +524,7 @@ sys32_ipc_wrapper:
 	lgfr	%r3,%r3			# int
 	lgfr	%r4,%r4			# int
 	lgfr	%r5,%r5			# int
-	llgtr	%r6,%r6			# void *
+	llgfr	%r6,%r6			# u32
 	jg	sys32_ipc		# branch to system call
 
 	.globl  sys32_fsync_wrapper 
@@ -580,9 +581,9 @@ sys32_delete_module_wrapper:
 
 	.globl  sys32_quotactl_wrapper 
 sys32_quotactl_wrapper:
-	lgfr	%r2,%r2			# int
+	llgfr	%r2,%r2			# unsigned int
 	llgtr	%r3,%r3			# const char *
-	lgfr	%r4,%r4			# int
+	llgfr	%r4,%r4			# qid_t
 	llgtr	%r5,%r5			# caddr_t
 	jg	sys_quotactl		# branch to system call
 
@@ -664,14 +665,14 @@ sys32_msync_wrapper:
 
 	.globl  sys32_readv_wrapper 
 sys32_readv_wrapper:
-	llgfr	%r2,%r2			# unsigned long
+	lgfr	%r2,%r2			# int
 	llgtr	%r3,%r3			# const struct iovec_emu31 *
 	llgfr	%r4,%r4			# unsigned long
 	jg	sys32_readv		# branch to system call
 
 	.globl  sys32_writev_wrapper 
 sys32_writev_wrapper:
-	llgfr	%r2,%r2			# unsigned long
+	lgfr	%r2,%r2			# int
 	llgtr	%r3,%r3			# const struct iovec_emu31 *
 	llgfr	%r4,%r4			# unsigned long
 	jg	sys32_writev		# branch to system call
@@ -830,6 +831,7 @@ sys32_rt_sigprocmask_wrapper:
 	lgfr	%r2,%r2			# int
 	llgtr	%r3,%r3			# old_sigset_emu31 *
 	llgtr	%r4,%r4			# old_sigset_emu31 *
+	llgfr	%r5,%r5			# size_t
 	jg	sys32_rt_sigprocmask	# branch to system call
 
 	.globl  sys32_rt_sigpending_wrapper 
@@ -917,15 +919,15 @@ sys32_sendfile_wrapper:
 	.globl  sys32_truncate64_wrapper 
 sys32_truncate64_wrapper:
 	llgtr	%r2,%r2			# const char *
-	lgfr	%r3,%r3			# s32 
-	llgfr	%r4,%r4			# u32 
+	llgfr	%r3,%r3			# unsigned long
+	llgfr	%r4,%r4			# unsigned long
 	jg	sys32_truncate64	# branch to system call
 
 	.globl  sys32_ftruncate64_wrapper 
 sys32_ftruncate64_wrapper:
 	llgfr	%r2,%r2			# unsigned int
-	lgfr	%r3,%r3			# s32 
-	llgfr	%r4,%r4			# u32 
+	llgfr	%r3,%r3			# unsigned long
+	llgfr	%r4,%r4			# unsigned long
 	jg	sys32_ftruncate64	# branch to system call
 
 	.globl sys32_lchown_wrapper	
@@ -1064,14 +1066,12 @@ compat_sys_fcntl64_wrapper:
 sys32_stat64_wrapper:
 	llgtr	%r2,%r2			# char *
 	llgtr	%r3,%r3			# struct stat64 *
-	llgfr	%r4,%r4			# long
 	jg	sys32_stat64		# branch to system call
 
 	.globl	sys32_lstat64_wrapper
 sys32_lstat64_wrapper:
 	llgtr	%r2,%r2			# char *
 	llgtr	%r3,%r3			# struct stat64 *
-	llgfr	%r4,%r4			# long
 	jg	sys32_lstat64		# branch to system call
 
 	.globl	sys32_stime_wrapper
@@ -1088,7 +1088,6 @@ sys32_sysctl_wrapper:
 sys32_fstat64_wrapper:
 	llgfr	%r2,%r2			# unsigned long
 	llgtr	%r3,%r3			# struct stat64 *
-	llgfr	%r4,%r4			# long
 	jg	sys32_fstat64		# branch to system call
 
 	.globl  compat_sys_futex_wrapper 
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/entry.S linux-post-2.6.5-rc2-20040329/arch/s390/kernel/entry.S
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/entry.S	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/entry.S	2004-03-27 11:40:46.000000000 +0000
@@ -25,40 +25,32 @@
  * The first few entries are identical to the user_regs_struct.
  */
 SP_PTREGS    =  STACK_FRAME_OVERHEAD 
-SP_PSW       =  STACK_FRAME_OVERHEAD + PT_PSWMASK
-SP_R0        =  STACK_FRAME_OVERHEAD + PT_GPR0
-SP_R1        =  STACK_FRAME_OVERHEAD + PT_GPR1
-SP_R2        =  STACK_FRAME_OVERHEAD + PT_GPR2
-SP_R3        =  STACK_FRAME_OVERHEAD + PT_GPR3
-SP_R4        =  STACK_FRAME_OVERHEAD + PT_GPR4
-SP_R5        =  STACK_FRAME_OVERHEAD + PT_GPR5
-SP_R6        =  STACK_FRAME_OVERHEAD + PT_GPR6
-SP_R7        =  STACK_FRAME_OVERHEAD + PT_GPR7
-SP_R8        =  STACK_FRAME_OVERHEAD + PT_GPR8
-SP_R9        =  STACK_FRAME_OVERHEAD + PT_GPR9
-SP_R10       =  STACK_FRAME_OVERHEAD + PT_GPR10
-SP_R11       =  STACK_FRAME_OVERHEAD + PT_GPR11
-SP_R12       =  STACK_FRAME_OVERHEAD + PT_GPR12
-SP_R13       =  STACK_FRAME_OVERHEAD + PT_GPR13
-SP_R14       =  STACK_FRAME_OVERHEAD + PT_GPR14
-SP_R15       =  STACK_FRAME_OVERHEAD + PT_GPR15
-SP_AREGS     =  STACK_FRAME_OVERHEAD + PT_ACR0
-SP_ORIG_R2   =  STACK_FRAME_OVERHEAD + PT_ORIGGPR2
-/* Now the additional entries */
-SP_ILC       =  (SP_ORIG_R2+GPR_SIZE)
-SP_TRAP      =  (SP_ILC+2)
-SP_SIZE      =  (SP_TRAP+2)
+SP_PSW       =  STACK_FRAME_OVERHEAD + __PT_PSW
+SP_R0        =  STACK_FRAME_OVERHEAD + __PT_GPRS
+SP_R1        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 4
+SP_R2        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 8
+SP_R3        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 12
+SP_R4        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 16
+SP_R5        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 20
+SP_R6        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 24
+SP_R7        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 28
+SP_R8        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 32
+SP_R9        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 36
+SP_R10       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 40
+SP_R11       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 44
+SP_R12       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 48
+SP_R13       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 52
+SP_R14       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 56
+SP_R15       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 60
+SP_ORIG_R2   =  STACK_FRAME_OVERHEAD + __PT_ORIG_GPR2
+SP_ILC       =  STACK_FRAME_OVERHEAD + __PT_ILC
+SP_TRAP      =  STACK_FRAME_OVERHEAD + __PT_TRAP
+SP_SIZE      =  STACK_FRAME_OVERHEAD + __PT_SIZE
 
 _TIF_WORK_SVC = (_TIF_SIGPENDING | _TIF_NEED_RESCHED | _TIF_RESTART_SVC)
 _TIF_WORK_INT = (_TIF_SIGPENDING | _TIF_NEED_RESCHED)
 
-/*
- * Base Address of this Module --- saved in __LC_ENTRY_BASE
- */
-       .globl entry_base
-entry_base:
-
-#define BASED(name) name-entry_base(%r13)
+#define BASED(name) name-system_call(%r13)
 
 /*
  * Register usage in interrupt handlers:
@@ -68,55 +60,108 @@ entry_base:
  *    R15 - kernel stack pointer
  */
 
-        .macro  SAVE_ALL_BASE
-        stm     %r13,%r15,__LC_SAVE_AREA
-        basr    %r13,0                    #  temp base pointer
-0:	stam    %a2,%a4,__LC_SAVE_AREA+12
-        l       %r13,.Lentry_base-0b(%r13)# load &entry_base to %r13
+        .macro  SAVE_ALL_BASE psworg,savearea,sync
+        stm     %r12,%r15,\savearea
+	l	%r13,__LC_SVC_NEW_PSW+4   # load &system_call to %r13
 	.endm
 
-        .macro  SAVE_ALL psworg,sync      # system entry macro
-        tm      \psworg+1,0x01            # test problem state bit
+        .macro  CLEANUP_SAVE_ALL_BASE psworg,savearea,sync
+	l	%r1,SP_PSW+4(%r15)
+	cli	1(%r1),0xcf
+	jne	0f
+	mvc	\savearea(16),SP_R12(%r15)
+0:	st	%r13,SP_R13(%r15)
+	.endm
+
+        .macro  SAVE_ALL psworg,savearea,sync
 	.if	\sync
+        tm      \psworg+1,0x01            # test problem state bit
         bz      BASED(1f)                 # skip stack setup save
+        l       %r15,__LC_KERNEL_STACK    # problem state -> load ksp
 	.else
-        bnz     BASED(0f)                 # from user -> load kernel stack
+        tm      \psworg+1,0x01            # test problem state bit
+        bnz     BASED(0f)                 # from user -> load async stack
 	l	%r14,__LC_ASYNC_STACK	  # are we already on the async stack ?
 	slr     %r14,%r15
 	sra	%r14,13
 	be	BASED(1f)
-        l       %r15,__LC_ASYNC_STACK     # load async. stack
-	b	BASED(1f)
+0:	l	%r15,__LC_ASYNC_STACK
 	.endif
-0:      l       %r15,__LC_KERNEL_STACK    # problem state -> load ksp
-	lam	%a2,%a4,BASED(.Lc_ac)	  # set ac.reg. 2 to primary space
-					  # and ac.reg. 4 to home space
 1:      s       %r15,BASED(.Lc_spsize)    # make room for registers & psw
-        n       %r15,BASED(.Lc0xfffffff8) # align stack pointer to 8
-        stm     %r0,%r12,SP_R0(%r15)      # store gprs 0-12 to kernel stack
+	l	%r14,BASED(.L\psworg)
+	slr	%r12,%r12
+	icm	%r14,12,__LC_SVC_ILC
+        stm     %r0,%r11,SP_R0(%r15)      # store gprs 0-12 to kernel stack
         st      %r2,SP_ORIG_R2(%r15)      # store original content of gpr 2
-        mvc     SP_R13(12,%r15),__LC_SAVE_AREA  # move R13-R15 to stack
-        stam    %a0,%a15,SP_AREGS(%r15)   # store access registers to kst.
-        mvc     SP_AREGS+8(12,%r15),__LC_SAVE_AREA+12 # store ac. regs
+        mvc     SP_R12(16,%r15),\savearea # move R13-R15 to stack
         mvc     SP_PSW(8,%r15),\psworg    # move user PSW to stack
-	mvc	SP_ILC(2,%r15),__LC_SVC_ILC      # store instruction length
-	mvc	SP_TRAP(2,%r15),BASED(.L\psworg) # store trap indication
-        xc      0(4,%r15),0(%r15)         # clear back chain
+	st	%r14,SP_ILC(%r15)
+        st      %r12,0(%r15)              # clear back chain
         .endm
 
-        .macro  RESTORE_ALL sync          # system exit macro
+	.macro	CLEANUP_SAVE_ALL psworg,savearea,sync
+	l	%r1,\savearea+12
+	.if	\sync
+	tm	\psworg+1,0x01
+	bz	BASED(1f)
+	l	%r1,__LC_KERNEL_STACK
+	.else
+	tm	\psworg+1,0x01
+	bnz	BASED(0f)
+	l	%r0,__LC_ASYNC_STACK
+	slr	%r0,%r1
+	sra	%r0,13
+	bz	BASED(1f)
+0:	l	%r1,__LC_ASYNC_STACK
+	.endif
+1:	s	%r1,BASED(.Lc_spsize)
+	st	%r1,SP_R15(%r15)
+	l	%r0,BASED(.L\psworg)
+	xc	SP_R12(4,%r15),SP_R12(%r15)
+	icm	%r0,12,__LC_SVC_ILC
+	st	%r0,SP_R14(%r15)
+	mvc	SP_R0(48,%r1),SP_R0(%r15)
+	mvc	SP_ORIG_R2(4,%r1),SP_R2(%r15)
+	mvc	SP_R12(16,%r1),\savearea
+	mvc	SP_PSW(8,%r1),\psworg
+	st	%r0,SP_ILC(%r1)
+	xc	0(4,%r1),0(%r1)
+	.endm
+
+        .macro  RESTORE_ALL               # system exit macro
         mvc     __LC_RETURN_PSW(8),SP_PSW(%r15)  # move user PSW to lowcore
-        lam     %a0,%a15,SP_AREGS(%r15)   # load the access registers
-        lm      %r0,%r15,SP_R0(%r15)      # load gprs 0-15 of user
         ni      __LC_RETURN_PSW+1,0xfd    # clear wait state bit
+        lm      %r0,%r15,SP_R0(%r15)      # load gprs 0-15 of user
         lpsw    __LC_RETURN_PSW           # back to caller
         .endm
 
+	.macro	CLEANUP_RESTORE_ALL
+	l	%r1,SP_PSW+4(%r15)
+	cli	0(%r1),0x82
+	jne	0f
+	mvc	SP_PSW(8,%r15),__LC_RETURN_PSW
+	j	1f
+0:	l	%r1,SP_R15(%r15)
+	mvc	SP_PSW(8,%r15),SP_PSW(%r1)
+	mvc	SP_R0(64,%r15),SP_R0(%r1)
+1:
+	.endm
+
         .macro  GET_THREAD_INFO
-	l	%r9,BASED(.Lc0xffffe000)  # load pointer to task_struct to %r9
-	al	%r9,__LC_KERNEL_STACK
+	l	%r9,__LC_THREAD_INFO
         .endm
 
+	.macro	CHECK_CRITICAL
+        tm      SP_PSW+1(%r15),0x01      # test problem state bit
+	bnz	BASED(0f)		 # from user -> not critical
+	clc	SP_PSW+4(4,%r15),BASED(.Lcritical_end)
+	jnl	0f
+	clc	SP_PSW+4(4,%r15),BASED(.Lcritical_start)
+	jl	0f
+	l	%r1,BASED(.Lcleanup_critical)
+	basr	%r14,%r1
+0:
+	.endm
 
 /*
  * Scheduler resume function, called by switch_to
@@ -139,13 +184,10 @@ __switch_to_noper:
         stm     %r6,%r15,24(%r15)       # store __switch_to registers of prev task
 	st	%r15,__THREAD_ksp(%r2)	# store kernel stack to prev->tss.ksp
 	l	%r15,__THREAD_ksp(%r3)	# load kernel stack from next->tss.ksp
-	stam    %a2,%a2,__THREAD_ar2(%r2)	# store kernel access reg. 2
-	stam    %a4,%a4,__THREAD_ar4(%r2)	# store kernel access reg. 4
-	lam     %a2,%a2,__THREAD_ar2(%r3)	# load kernel access reg. 2
-	lam     %a4,%a4,__THREAD_ar4(%r3)	# load kernel access reg. 4
 	lm	%r6,%r15,24(%r15)	# load __switch_to registers of next task
 	st	%r3,__LC_CURRENT	# __LC_CURRENT = current task struct
 	l	%r3,__THREAD_info(%r3)  # load thread_info from task struct
+	st	%r3,__LC_THREAD_INFO
 	ahi	%r3,8192
 	st	%r3,__LC_KERNEL_STACK	# __LC_KERNEL_STACK = new kernel stack
 	br	%r14
@@ -172,6 +214,7 @@ do_call_base:
 	lm	%r12,%r15,24(%r12)
 	br	%r14
 	
+__critical_start:
 /*
  * SVC interrupt handler routine. System calls are synchronous events and
  * are executed with interrupts enabled.
@@ -179,10 +222,10 @@ do_call_base:
 
 	.globl  system_call
 system_call:
-	SAVE_ALL_BASE
-        SAVE_ALL __LC_SVC_OLD_PSW,1
+	SAVE_ALL_BASE __LC_SVC_OLD_PSW,__LC_SAVE_AREA,1
+        SAVE_ALL __LC_SVC_OLD_PSW,__LC_SAVE_AREA,1
 	lh	%r7,0x8a	  # get svc number from lowcore
-        stosm   24(%r15),0x03     # reenable interrupts
+sysc_enter:
         GET_THREAD_INFO           # load pointer to task_struct to R9
 	sla	%r7,2             # *4 and test for svc 0
 	bnz	BASED(sysc_do_restart)  # svc number > 0
@@ -193,7 +236,7 @@ system_call:
 	sla	%r7,2             # *4
 sysc_do_restart:
 	tm	__TI_flags+3(%r9),_TIF_SYSCALL_TRACE
-        l       %r8,sys_call_table-entry_base(%r7,%r13) # get system call addr.
+        l       %r8,sys_call_table-system_call(%r7,%r13) # get system call addr.
         bo      BASED(sysc_tracesys)
         basr    %r14,%r8          # call sys_xxxx
         st      %r2,SP_R2(%r15)   # store return value (change R2 on stack)
@@ -201,19 +244,17 @@ sysc_do_restart:
                                   # changing anything here !!
 
 sysc_return:
-	stnsm   24(%r15),0xfc     # disable I/O and ext. interrupts
 	tm	SP_PSW+1(%r15),0x01	# returning to user ?
 	bno	BASED(sysc_leave)
 	tm	__TI_flags+3(%r9),_TIF_WORK_SVC
 	bnz	BASED(sysc_work)  # there is work to do (signals etc.)
 sysc_leave:
-        RESTORE_ALL 1
+        RESTORE_ALL
 
 #
 # recheck if there is more work to do
 #
 sysc_work_loop:
-	stnsm   24(%r15),0xfc     # disable I/O and ext. interrupts
         GET_THREAD_INFO           # load pointer to task_struct to R9
 	tm	__TI_flags+3(%r9),_TIF_WORK_SVC
 	bz	BASED(sysc_leave)      # there is no work to do
@@ -234,7 +275,6 @@ sysc_work:
 # _TIF_NEED_RESCHED is set, call schedule
 #	
 sysc_reschedule:        
-        stosm   24(%r15),0x03          # reenable interrupts
         l       %r1,BASED(.Lschedule)
 	la      %r14,BASED(sysc_work_loop)
 	br      %r1		       # call scheduler
@@ -243,12 +283,10 @@ sysc_reschedule:        
 # _TIF_SIGPENDING is set, call do_signal
 #
 sysc_sigpending:     
-        stosm   24(%r15),0x03          # reenable interrupts
         la      %r2,SP_PTREGS(%r15)    # load pt_regs
         sr      %r3,%r3                # clear *oldset
         l       %r1,BASED(.Ldo_signal)
 	basr	%r14,%r1               # call do_signal
-        stnsm   24(%r15),0xfc          # disable I/O and ext. interrupts
 	tm	__TI_flags+3(%r9),_TIF_RESTART_SVC
 	bo	BASED(sysc_restart)
 	b	BASED(sysc_leave)      # out of here, do NOT recheck
@@ -258,13 +296,14 @@ sysc_sigpending:     
 #
 sysc_restart:
 	ni	__TI_flags+3(%r9),255-_TIF_RESTART_SVC # clear TIF_RESTART_SVC
-	stosm	24(%r15),0x03          # reenable interrupts
 	l	%r7,SP_R2(%r15)        # load new svc number
 	sla	%r7,2
 	mvc	SP_R2(4,%r15),SP_ORIG_R2(%r15) # restore first argument
 	lm	%r2,%r6,SP_R2(%r15)    # load svc arguments
 	b	BASED(sysc_do_restart) # restart svc
 
+__critical_end:
+
 #
 # call trace before and after sys_call
 #
@@ -277,7 +316,7 @@ sysc_tracesys:
 	bnl	BASED(sysc_tracenogo)
 	l	%r7,SP_R2(%r15)        # strace might have changed the 
 	sll	%r7,2                  #  system call
-	l	%r8,sys_call_table-entry_base(%r7,%r13)
+	l	%r8,sys_call_table-system_call(%r7,%r13)
 sysc_tracego:
 	lm	%r3,%r6,SP_R3(%r15)
 	l	%r2,SP_ORIG_R2(%r15)
@@ -294,13 +333,13 @@ sysc_tracenogo:
 # a new process exits the kernel with ret_from_fork
 #
         .globl  ret_from_fork
-ret_from_fork:  
-        basr    %r13,0
-        l       %r13,.Lentry_base-.(%r13)  # setup base pointer to &entry_base
+ret_from_fork:
+	l	%r13,__LC_SVC_NEW_PSW+4
         GET_THREAD_INFO           # load pointer to task_struct to R9
         l       %r1,BASED(.Lschedtail)
-	la      %r14,BASED(sysc_return)
-        br      %r1               # call schedule_tail, return to sysc_return
+	basr    %r14,%r1
+        stosm   24(%r15),0x03     # reenable interrupts
+	b	BASED(sysc_return)
 
 #
 # clone, fork, vfork, exec and sigreturn need glue,
@@ -373,12 +412,6 @@ sys_sigaltstack_glue:
         br      %r1                   # branch to sys_sigreturn
 
 
-#define SYSCALL(esa,esame,emu)	.long esa
-	.globl  sys_call_table
-sys_call_table:
-#include "syscalls.S"
-#undef SYSCALL
-
 /*
  * Program check handler routine
  */
@@ -398,10 +431,10 @@ pgm_check_handler:
  * we just ignore the PER event (FIXME: is there anything we have to do
  * for LPSW?).
  */
-	SAVE_ALL_BASE
+	SAVE_ALL_BASE __LC_PGM_OLD_PSW,__LC_SAVE_AREA,1
         tm      __LC_PGM_INT_CODE+1,0x80 # check whether we got a per exception
         bnz     BASED(pgm_per)           # got per exception -> special case
-	SAVE_ALL __LC_PGM_OLD_PSW,1
+	SAVE_ALL __LC_PGM_OLD_PSW,__LC_SAVE_AREA,1
         l       %r3,__LC_PGM_ILC         # load program interruption code
 	la	%r8,0x7f
         l       %r7,BASED(.Ljump_table)
@@ -430,7 +463,7 @@ pgm_per:
 # Normal per exception
 #
 pgm_per_std:
-	SAVE_ALL __LC_PGM_OLD_PSW,1
+	SAVE_ALL __LC_PGM_OLD_PSW,__LC_SAVE_AREA,1
 	GET_THREAD_INFO
 	mvc	__THREAD_per+__PER_atmid(2,%r9),__LC_PER_ATMID
 	mvc	__THREAD_per+__PER_address(4,%r9),__LC_PER_ADDRESS
@@ -454,7 +487,7 @@ pgm_per_only:
 # it was a single stepped SVC that is causing all the trouble
 #
 pgm_svcper:
-	SAVE_ALL __LC_SVC_OLD_PSW,1
+	SAVE_ALL __LC_SVC_OLD_PSW,__LC_SAVE_AREA,1
 	lh	%r7,0x8a	  # get svc number from lowcore
         stosm   24(%r15),0x03     # reenable interrupts
         GET_THREAD_INFO           # load pointer to task_struct to R9
@@ -470,7 +503,7 @@ pgm_svcper:
 	sla	%r7,2             # *4
 pgm_svcstd:
 	tm	__TI_flags+3(%r9),_TIF_SYSCALL_TRACE
-        l       %r8,sys_call_table-entry_base(%r7,%r13) # get system call addr.
+        l       %r8,sys_call_table-system_call(%r7,%r13) # get system call addr.
         bo      BASED(pgm_tracesys)
         basr    %r14,%r8          # call sys_xxxx
         st      %r2,SP_R2(%r15)   # store return value (change R2 on stack)
@@ -503,7 +536,7 @@ pgm_tracesys:
 	bnl	BASED(pgm_svc_nogo)
 	l	%r7,SP_R2(%r15)   # strace changed the syscall
 	sll     %r7,2
-	l	%r8,sys_call_table-entry_base(%r7,%r13)
+	l	%r8,sys_call_table-system_call(%r7,%r13)
 pgm_svc_go:
 	lm      %r3,%r6,SP_R3(%r15)
 	l       %r2,SP_ORIG_R2(%r15)
@@ -522,10 +555,11 @@ pgm_svc_nogo:
 
         .globl io_int_handler
 io_int_handler:
-	SAVE_ALL_BASE
-        SAVE_ALL __LC_IO_OLD_PSW,0
-        GET_THREAD_INFO           # load pointer to task_struct to R9
+	SAVE_ALL_BASE __LC_IO_OLD_PSW,__LC_SAVE_AREA+16,0
+        SAVE_ALL __LC_IO_OLD_PSW,__LC_SAVE_AREA+16,0
 	stck	__LC_INT_CLOCK
+	CHECK_CRITICAL
+        GET_THREAD_INFO           # load pointer to task_struct to R9
         l       %r1,BASED(.Ldo_IRQ)        # load address of do_IRQ
         la      %r2,SP_PTREGS(%r15) # address of register-save area
         basr    %r14,%r1          # branch to standard irq handler
@@ -540,24 +574,21 @@ io_return:
 	tm	__TI_flags+3(%r9),_TIF_WORK_INT
 	bnz	BASED(io_work)         # there is work to do (signals etc.)
 io_leave:
-        RESTORE_ALL 0
+        RESTORE_ALL
 
 #ifdef CONFIG_PREEMPT
 io_preempt:
 	icm	%r0,15,__TI_precount(%r9)
 	bnz     BASED(io_leave)
-io_resume_loop:
-	tm	__TI_flags+3(%r9),_TIF_NEED_RESCHED
-	bno	BASED(io_leave)
-	mvc     __TI_precount(4,%r9),BASED(.Lc_pactive)
-	# hmpf, we are on the async. stack but to call schedule
-	# we have to move the interrupt frame to the process stack
 	l	%r1,SP_R15(%r15)
 	s	%r1,BASED(.Lc_spsize)
-	n	%r1,BASED(.Lc0xfffffff8)
-	mvc	SP_PTREGS(SP_SIZE-SP_PTREGS,%r1),SP_PTREGS(%r15)
+	mvc	SP_PTREGS(__PT_SIZE,%r1),SP_PTREGS(%r15)
         xc      0(4,%r1),0(%r1)        # clear back chain
 	lr	%r15,%r1
+io_resume_loop:
+	tm	__TI_flags+3(%r9),_TIF_NEED_RESCHED
+	bno	BASED(io_leave)
+	mvc     __TI_precount(4,%r9),BASED(.Lc_pactive)
         stosm   24(%r15),0x03          # reenable interrupts
         l       %r1,BASED(.Lschedule)
 	basr	%r14,%r1	       # call schedule
@@ -568,18 +599,19 @@ io_resume_loop:
 #endif
 
 #
-# recheck if there is more work to do
+# switch to kernel stack, then check the TIF bits
 #
-io_work_loop:
-        stnsm   24(%r15),0xfc          # disable I/O and ext. interrupts
-        GET_THREAD_INFO                # load pointer to task_struct to R9
-	tm	__TI_flags+3(%r9),_TIF_WORK_INT
-	bz	BASED(io_leave)        # there is no work to do
+io_work:
+	l	%r1,__LC_KERNEL_STACK
+	s	%r1,BASED(.Lc_spsize)
+	mvc	SP_PTREGS(__PT_SIZE,%r1),SP_PTREGS(%r15)
+        xc      0(4,%r1),0(%r1)        # clear back chain
+	lr	%r15,%r1
 #
 # One of the work bits is on. Find out which one.
 # Checked are: _TIF_SIGPENDING and _TIF_NEED_RESCHED
 #
-io_work:
+io_work_loop:
 	tm	__TI_flags+3(%r9),_TIF_NEED_RESCHED
 	bo	BASED(io_reschedule)
 	tm	__TI_flags+3(%r9),_TIF_SIGPENDING
@@ -590,10 +622,14 @@ io_work:
 # _TIF_NEED_RESCHED is set, call schedule
 #	
 io_reschedule:        
-        stosm   24(%r15),0x03          # reenable interrupts
         l       %r1,BASED(.Lschedule)
-	la      %r14,BASED(io_work_loop)
-	br      %r1		       # call scheduler
+        stosm   24(%r15),0x03          # reenable interrupts
+	basr    %r14,%r1	       # call scheduler
+        stnsm   24(%r15),0xfc          # disable I/O and ext. interrupts
+        GET_THREAD_INFO                # load pointer to task_struct to R9
+	tm	__TI_flags+3(%r9),_TIF_WORK_INT
+	bz	BASED(io_leave)        # there is no work to do
+	b	BASED(io_work_loop)
 
 #
 # _TIF_SIGPENDING is set, call do_signal
@@ -613,10 +649,11 @@ io_sigpending:     
 
         .globl  ext_int_handler
 ext_int_handler:
-	SAVE_ALL_BASE
-        SAVE_ALL __LC_EXT_OLD_PSW,0
-        GET_THREAD_INFO                # load pointer to task_struct to R9
+	SAVE_ALL_BASE __LC_EXT_OLD_PSW,__LC_SAVE_AREA+16,0
+        SAVE_ALL __LC_EXT_OLD_PSW,__LC_SAVE_AREA+16,0
 	stck	__LC_INT_CLOCK
+	CHECK_CRITICAL
+        GET_THREAD_INFO                # load pointer to task_struct to R9
 	la	%r2,SP_PTREGS(%r15)    # address of register-save area
 	lh	%r3,__LC_EXT_INT_CODE  # get interruption code
 	l	%r1,BASED(.Ldo_extint)
@@ -629,12 +666,12 @@ ext_int_handler:
 
         .globl mcck_int_handler
 mcck_int_handler:
-	SAVE_ALL_BASE
-        SAVE_ALL __LC_MCK_OLD_PSW,0
+	SAVE_ALL_BASE __LC_MCK_OLD_PSW,__LC_SAVE_AREA+32,0
+        SAVE_ALL __LC_MCK_OLD_PSW,__LC_SAVE_AREA+32,0
 	l       %r1,BASED(.Ls390_mcck)
 	basr    %r14,%r1	  # call machine check handler
 mcck_return:
-        RESTORE_ALL 0
+        RESTORE_ALL
 
 #ifdef CONFIG_SMP
 /*
@@ -667,24 +704,65 @@ restart_crash:
 restart_go:
 #endif
 
+cleanup_table:
+	.long	system_call, sysc_enter, cleanup_sysc_enter
+	.long	sysc_return, sysc_leave, cleanup_sysc_return
+	.long	sysc_leave, sysc_work_loop, cleanup_sysc_leave
+	.long	sysc_work_loop, sysc_reschedule, cleanup_sysc_return
+cleanup_table_entries=(.-cleanup_table) / 12
+
+cleanup_critical:
+	lhi	%r0,cleanup_table_entries
+	la	%r1,BASED(cleanup_table)
+	l	%r2,SP_PSW+4(%r15)
+	la	%r2,0(%r2)
+cleanup_loop:
+	cl	%r2,0(%r1)
+	bl	BASED(cleanup_cont)
+	cl	%r2,4(%r1)
+	bl	BASED(cleanup_found)
+cleanup_cont:
+	la	%r1,12(%r1)
+	bct	%r0,BASED(cleanup_loop)
+	br	%r14
+cleanup_found:
+	l	%r1,8(%r1)
+	br	%r1
+
+cleanup_sysc_enter:
+	CLEANUP_SAVE_ALL_BASE __LC_SVC_OLD_PSW,__LC_SAVE_AREA,1
+	CLEANUP_SAVE_ALL __LC_SVC_OLD_PSW,__LC_SAVE_AREA,1
+	lh	%r0,0x8a
+	st	%r0,SP_R7(%r15)
+	la	%r1,BASED(sysc_enter)
+	o	%r1,BASED(.Lamode)
+	st	%r1,SP_PSW+4(%r15)
+	br	%r14
+
+cleanup_sysc_return:
+	la	%r1,BASED(sysc_return)
+	o	%r1,BASED(.Lamode)
+	st	%r1,SP_PSW+4(%r15)
+	br	%r14
+
+cleanup_sysc_leave:
+	CLEANUP_RESTORE_ALL
+	br	%r14
+
 /*
  * Integer constants
  */
                .align 4
-.Lc0xfffffff8: .long  -8           # to align stack pointer to 8
-.Lc0xffffe000: .long  -8192        # to round stack pointer to &task_struct
 .Lc_spsize:    .long  SP_SIZE
 .Lc_overhead:  .long  STACK_FRAME_OVERHEAD
-.Lc_ac:        .long  0,0,1
-.Lc_ENOSYS:    .long  -ENOSYS
 .Lc_pactive:   .long  PREEMPT_ACTIVE
-.Lc0xff:       .long  0xff
 .Lnr_syscalls: .long  NR_syscalls
-.L0x018:       .word  0x018
-.L0x020:       .word  0x020
-.L0x028:       .word  0x028
-.L0x030:       .word  0x030
-.L0x038:       .word  0x038
+.L0x018:       .long  0x018
+.L0x020:       .long  0x020
+.L0x028:       .long  0x028
+.L0x030:       .long  0x030
+.L0x038:       .long  0x038
+.Lamode:       .long  0x80000000
 
 /*
  * Symbol constants
@@ -694,8 +772,6 @@ restart_go:
 .Ldo_extint:   .long  do_extint
 .Ldo_signal:   .long  do_signal
 .Ldo_softirq:  .long  do_softirq
-.Lentry_base:  .long  entry_base
-.Lext_hash:    .long  ext_int_hash
 .Lhandle_per:  .long  do_debugger_trap
 .Ljump_table:  .long  pgm_check_table
 .Lschedule:    .long  schedule
@@ -712,4 +788,16 @@ restart_go:
 .Lvfork:       .long  sys_vfork
 .Lschedtail:   .long  schedule_tail
 
+.Lcritical_start:
+               .long  __critical_start + 0x80000000
+.Lcritical_end:
+               .long  __critical_end + 0x80000000
+.Lcleanup_critical:
+               .long  cleanup_critical
+
+#define SYSCALL(esa,esame,emu)	.long esa
+	.globl  sys_call_table
+sys_call_table:
+#include "syscalls.S"
+#undef SYSCALL
 
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/entry64.S linux-post-2.6.5-rc2-20040329/arch/s390/kernel/entry64.S
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/entry64.S	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/entry64.S	2004-03-27 11:40:46.000000000 +0000
@@ -25,29 +25,27 @@
  * The first few entries are identical to the user_regs_struct.
  */
 SP_PTREGS    =  STACK_FRAME_OVERHEAD 
-SP_PSW       =  STACK_FRAME_OVERHEAD + PT_PSWMASK
-SP_R0        =  STACK_FRAME_OVERHEAD + PT_GPR0
-SP_R1        =  STACK_FRAME_OVERHEAD + PT_GPR1
-SP_R2        =  STACK_FRAME_OVERHEAD + PT_GPR2
-SP_R3        =  STACK_FRAME_OVERHEAD + PT_GPR3
-SP_R4        =  STACK_FRAME_OVERHEAD + PT_GPR4
-SP_R5        =  STACK_FRAME_OVERHEAD + PT_GPR5
-SP_R6        =  STACK_FRAME_OVERHEAD + PT_GPR6
-SP_R7        =  STACK_FRAME_OVERHEAD + PT_GPR7
-SP_R8        =  STACK_FRAME_OVERHEAD + PT_GPR8
-SP_R9        =  STACK_FRAME_OVERHEAD + PT_GPR9
-SP_R10       =  STACK_FRAME_OVERHEAD + PT_GPR10
-SP_R11       =  STACK_FRAME_OVERHEAD + PT_GPR11
-SP_R12       =  STACK_FRAME_OVERHEAD + PT_GPR12
-SP_R13       =  STACK_FRAME_OVERHEAD + PT_GPR13
-SP_R14       =  STACK_FRAME_OVERHEAD + PT_GPR14
-SP_R15       =  STACK_FRAME_OVERHEAD + PT_GPR15
-SP_AREGS     =  STACK_FRAME_OVERHEAD + PT_ACR0
-SP_ORIG_R2   =  STACK_FRAME_OVERHEAD + PT_ORIGGPR2
-/* Now the additional entries */
-SP_ILC       =  (SP_ORIG_R2+GPR_SIZE)
-SP_TRAP      =  (SP_ILC+2)
-SP_SIZE      =  (SP_TRAP+2)
+SP_PSW       =  STACK_FRAME_OVERHEAD + __PT_PSW
+SP_R0        =  STACK_FRAME_OVERHEAD + __PT_GPRS
+SP_R1        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 8
+SP_R2        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 16
+SP_R3        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 24
+SP_R4        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 32
+SP_R5        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 40
+SP_R6        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 48
+SP_R7        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 56
+SP_R8        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 64
+SP_R9        =  STACK_FRAME_OVERHEAD + __PT_GPRS + 72
+SP_R10       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 80
+SP_R11       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 88
+SP_R12       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 96
+SP_R13       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 104
+SP_R14       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 112
+SP_R15       =  STACK_FRAME_OVERHEAD + __PT_GPRS + 120
+SP_ORIG_R2   =  STACK_FRAME_OVERHEAD + __PT_ORIG_GPR2
+SP_ILC       =  STACK_FRAME_OVERHEAD + __PT_ILC
+SP_TRAP      =  STACK_FRAME_OVERHEAD + __PT_TRAP
+SP_SIZE      =  STACK_FRAME_OVERHEAD + __PT_SIZE
 
 _TIF_WORK_SVC = (_TIF_SIGPENDING | _TIF_NEED_RESCHED | _TIF_RESTART_SVC)
 _TIF_WORK_INT = (_TIF_SIGPENDING | _TIF_NEED_RESCHED)
@@ -60,51 +58,100 @@ _TIF_WORK_INT = (_TIF_SIGPENDING | _TIF_
  *    R15 - kernel stack pointer
  */
 
-        .macro  SAVE_ALL psworg,sync     # system entry macro
-        stmg    %r14,%r15,__LC_SAVE_AREA
-	stam    %a2,%a4,__LC_SAVE_AREA+16
-	larl	%r14,.Lconst
-        tm      \psworg+1,0x01           # test problem state bit
+        .macro  SAVE_ALL psworg,savearea,sync
+        stmg    %r13,%r15,\savearea
 	.if	\sync
+        tm      \psworg+1,0x01           # test problem state bit
         jz      1f                       # skip stack setup save
+	lg      %r15,__LC_KERNEL_STACK   # problem state -> load ksp
 	.else
+        tm      \psworg+1,0x01           # test problem state bit
 	jnz	0f			 # from user -> load kernel stack
 	lg	%r14,__LC_ASYNC_STACK	 # are we already on the async. stack ?
 	slgr	%r14,%r15
 	srag	%r14,%r14,14
-	larl	%r14,.Lconst
 	jz	1f
-	lg	%r15,__LC_ASYNC_STACK	 # load async. stack
-	j	1f
+0:	lg      %r15,__LC_ASYNC_STACK    # load async stack
 	.endif
-0:	lg      %r15,__LC_KERNEL_STACK   # problem state -> load ksp
-	lam	%a2,%a4,.Lc_ac-.Lconst(%r14)
 1:      aghi    %r15,-SP_SIZE            # make room for registers & psw
-        nill    %r15,0xfff8              # align stack pointer to 8
-        stmg    %r0,%r13,SP_R0(%r15)     # store gprs 0-13 to kernel stack
+	lghi	%r14,\psworg
+	slgr	%r13,%r13
+	icm	%r14,12,__LC_SVC_ILC
+        stmg    %r0,%r12,SP_R0(%r15)     # store gprs 0-13 to kernel stack
         stg     %r2,SP_ORIG_R2(%r15)     # store original content of gpr 2
-        mvc     SP_R14(16,%r15),__LC_SAVE_AREA # move r14 and r15 to stack
-        stam    %a0,%a15,SP_AREGS(%r15)  # store access registers to kst.
-        mvc     SP_AREGS+8(12,%r15),__LC_SAVE_AREA+16 # store ac. regs
+        mvc     SP_R13(24,%r15),\savearea # move r13, r14 and r15 to stack
         mvc     SP_PSW(16,%r15),\psworg  # move user PSW to stack
-	mvc	SP_ILC(2,%r15),__LC_SVC_ILC # store instruction length
-	mvc	SP_TRAP(2,%r15),.L\psworg-.Lconst(%r14) # store trap ind.
-        xc      0(8,%r15),0(%r15)        # clear back chain
+	st	%r14,SP_ILC(%r15)
+	stg	%r13,0(%r15)
         .endm
 
-        .macro  RESTORE_ALL sync         # system exit macro
+	.macro	CLEANUP_SAVE_ALL psworg,savearea,sync
+	lg	%r1,SP_PSW+8(%r15)
+	cli	1(%r1),0xdf
+	jne	2f
+	mvc	\savearea(24),SP_R13(%r15)
+2:	lg	%r1,\savearea+16
+	.if	\sync
+	tm	\psworg+1,0x01
+	jz	1f
+	lg	%r1,__LC_KERNEL_STACK
+	.else
+	tm	\psworg+1,0x01
+	jnz	0f
+	lg	%r0,__LC_ASYNC_STACK
+	slgr	%r0,%r1
+	srag	%r0,%r0,14
+	jz	1f
+0:	lg	%r1,__LC_ASYNC_STACK
+	.endif
+1:	aghi	%r1,-SP_SIZE
+	stg	%r1,SP_R15(%r15)
+	lghi	%r0,\psworg
+	xc	SP_R13(8,%r15),SP_R13(%r15)
+	icm	%r0,12,__LC_SVC_ILC
+	stg	%r0,SP_R14(%r15)
+	mvc	SP_R0(104,%r1),SP_R0(%r15)
+	mvc	SP_ORIG_R2(8,%r1),SP_R2(%r15)
+	mvc	SP_R13(24,%r1),\savearea
+	mvc	SP_PSW(16,%r1),\psworg
+	st	%r0,SP_ILC(%r1)
+	xc	0(8,%r1),0(%r1)
+	.endm
+
+        .macro  RESTORE_ALL              # system exit macro
         mvc     __LC_RETURN_PSW(16),SP_PSW(%r15) # move user PSW to lowcore
-        lam     %a0,%a15,SP_AREGS(%r15)  # load the access registers
-        lmg     %r0,%r15,SP_R0(%r15)     # load gprs 0-15 of user
         ni      __LC_RETURN_PSW+1,0xfd   # clear wait state bit
+        lmg     %r0,%r15,SP_R0(%r15)     # load gprs 0-15 of user
         lpswe   __LC_RETURN_PSW          # back to caller
         .endm
 
+	.macro	CLEANUP_RESTORE_ALL
+	lg	%r1,SP_PSW+8(%r15)
+	cli	0(%r1),0xb2
+	jne	0f
+	mvc	SP_PSW(16,%r15),__LC_RETURN_PSW
+	j	1f
+0:	lg	%r1,SP_R15(%r15)
+	mvc	SP_PSW(16,%r15),SP_PSW(%r1)
+	mvc	SP_R0(128,%r15),SP_R0(%r1)
+1:
+	.endm
+
         .macro  GET_THREAD_INFO
-	lg	%r9,__LC_KERNEL_STACK    # load pointer to task_struct to %r9
-	aghi	%r9,-16384
+	lg	%r9,__LC_THREAD_INFO     # load pointer to thread_info struct
         .endm
 
+	.macro	CHECK_CRITICAL
+        tm      SP_PSW+1(%r15),0x01      # test problem state bit
+	jnz	0f			 # from user -> not critical
+	larl	%r1,.Lcritical_start
+	clc	SP_PSW+8(8,%r15),8(%r1)  # compare ip with __critical_end
+	jnl	0f
+	clc	SP_PSW+8(8,%r15),0(%r1)  # compare ip with __critical_start
+	jl	0f
+	brasl	%r14,cleanup_critical
+0:
+	.endm
 
 /*
  * Scheduler resume function, called by switch_to
@@ -125,13 +172,10 @@ __switch_to_noper:
         stmg    %r6,%r15,48(%r15)       # store __switch_to registers of prev task
 	stg	%r15,__THREAD_ksp(%r2)	# store kernel stack to prev->tss.ksp
 	lg	%r15,__THREAD_ksp(%r3)	# load kernel stack from next->tss.ksp
-        stam    %a2,%a2,__THREAD_ar2(%r2)	# store kernel access reg. 2
-        stam    %a4,%a4,__THREAD_ar4(%r2)	# store kernel access reg. 4
-        lam     %a2,%a2,__THREAD_ar2(%r3)	# load kernel access reg. 2
-        lam     %a4,%a4,__THREAD_ar4(%r3)	# load kernel access reg. 4
         lmg     %r6,%r15,48(%r15)       # load __switch_to registers of next task
 	stg	%r3,__LC_CURRENT	# __LC_CURRENT = current task struct
 	lg	%r3,__THREAD_info(%r3)  # load thread_info from task struct
+	stg	%r3,__LC_THREAD_INFO
 	aghi	%r3,16384
 	stg	%r3,__LC_KERNEL_STACK	# __LC_KERNEL_STACK = new kernel stack
 	br	%r14
@@ -154,7 +198,8 @@ do_call_softirq:
 	brasl	%r14,do_softirq
 	lmg	%r12,%r15,48(%r12)
 	br	%r14
-	
+
+__critical_start:
 /*
  * SVC interrupt handler routine. System calls are synchronous events and
  * are executed with interrupts enabled.
@@ -162,14 +207,15 @@ do_call_softirq:
 
 	.globl  system_call
 system_call:
-        SAVE_ALL __LC_SVC_OLD_PSW,1
+        SAVE_ALL __LC_SVC_OLD_PSW,__LC_SAVE_AREA,1
 	llgh    %r7,__LC_SVC_INT_CODE # get svc number from lowcore
-	stosm   48(%r15),0x03     # reenable interrupts
+sysc_enter:
         GET_THREAD_INFO           # load pointer to task_struct to R9
         slag    %r7,%r7,2         # *4 and test for svc 0
 	jnz	sysc_do_restart
 	# svc 0: system call number in %r1
-	cl	%r1,.Lnr_syscalls-.Lconst(%r14)
+	lghi	%r0,NR_syscalls
+	clr	%r1,%r0
 	jnl	sysc_do_restart
 	lgfr	%r7,%r1           # clear high word in r1
 	slag    %r7,%r7,2         # svc 0: system call number in %r1
@@ -190,19 +236,17 @@ sysc_noemu:
                                   # changing anything here !!
 
 sysc_return:
-	stnsm   48(%r15),0xfc     # disable I/O and ext. interrupts
         tm      SP_PSW+1(%r15),0x01    # returning to user ?
         jno     sysc_leave
 	tm	__TI_flags+7(%r9),_TIF_WORK_SVC
 	jnz	sysc_work         # there is work to do (signals etc.)
 sysc_leave:
-        RESTORE_ALL 1
+        RESTORE_ALL
 
 #
 # recheck if there is more work to do
 #
 sysc_work_loop:
-	stnsm   48(%r15),0xfc     # disable I/O and ext. interrupts
         GET_THREAD_INFO           # load pointer to task_struct to R9
 	tm	__TI_flags+7(%r9),_TIF_WORK_SVC
 	jz	sysc_leave        # there is no work to do
@@ -223,7 +267,6 @@ sysc_work:
 # _TIF_NEED_RESCHED is set, call schedule
 #	
 sysc_reschedule:        
-	stosm   48(%r15),0x03     # reenable interrupts
 	larl    %r14,sysc_work_loop
         jg      schedule            # return point is sysc_return
 
@@ -231,11 +274,9 @@ sysc_reschedule:        
 # _TIF_SIGPENDING is set, call do_signal
 #
 sysc_sigpending:     
-	stosm   48(%r15),0x03     # reenable interrupts
         la      %r2,SP_PTREGS(%r15) # load pt_regs
         sgr     %r3,%r3           # clear *oldset
 	brasl	%r14,do_signal    # call do_signal
-	stnsm   48(%r15),0xfc     # disable I/O and ext. interrupts
 	tm	__TI_flags+7(%r9),_TIF_RESTART_SVC
 	jo	sysc_restart
 	j	sysc_leave        # out of here, do NOT recheck
@@ -245,13 +286,14 @@ sysc_sigpending:     
 #
 sysc_restart:
 	ni	__TI_flags+7(%r9),255-_TIF_RESTART_SVC # clear TIF_RESTART_SVC
-	stosm	48(%r15),0x03          # reenable interrupts
 	lg	%r7,SP_R2(%r15)        # load new svc number
         slag    %r7,%r7,2              # *4
 	mvc	SP_R2(8,%r15),SP_ORIG_R2(%r15) # restore first argument
 	lmg	%r2,%r6,SP_R2(%r15)    # load svc arguments
 	j	sysc_do_restart        # restart svc
 
+__critical_end:
+
 #
 # call syscall_trace before and after system call
 # special linkage: %r12 contains the return address for trace_svc
@@ -260,9 +302,9 @@ sysc_tracesys:
 	srl	%r7,2
 	stg     %r7,SP_R2(%r15)
         brasl   %r14,syscall_trace
-	larl	%r1,.Lnr_syscalls
-	clc	SP_R2(8,%r15),0(%r1)
-	jnl	sysc_tracenogo
+	lghi	%r0,NR_syscalls
+	clg	%r0,SP_R2(%r15)
+	jnh	sysc_tracenogo
 	lg	%r7,SP_R2(%r15)   # strace might have changed the
 	sll     %r7,2             #  system call
 	lgf	%r8,0(%r7,%r10)
@@ -283,8 +325,9 @@ sysc_tracenogo:
         .globl  ret_from_fork
 ret_from_fork:  
         GET_THREAD_INFO           # load pointer to task_struct to R9
-	larl    %r14,sysc_return
-        jg      schedule_tail     # return to sysc_return
+        brasl   %r14,schedule_tail
+        stosm   24(%r15),0x03     # reenable interrupts
+	j	sysc_return
 
 #
 # clone, fork, vfork, exec and sigreturn need glue,
@@ -405,21 +448,6 @@ sys32_sigaltstack_glue:
         jg      sys32_sigaltstack_wrapper # branch to sys_sigreturn
 #endif
 
-#define SYSCALL(esa,esame,emu)	.long esame
-	.globl  sys_call_table	
-sys_call_table:
-#include "syscalls.S"
-#undef SYSCALL
-
-#ifdef CONFIG_S390_SUPPORT
-
-#define SYSCALL(esa,esame,emu)	.long emu
-	.globl  sys_call_table_emu
-sys_call_table_emu:
-#include "syscalls.S"
-#undef SYSCALL
-#endif
-
 /*
  * Program check handler routine
  */
@@ -441,7 +469,7 @@ pgm_check_handler:
  */
         tm      __LC_PGM_INT_CODE+1,0x80 # check whether we got a per exception
         jnz     pgm_per                  # got per exception -> special case
-	SAVE_ALL __LC_PGM_OLD_PSW,1
+	SAVE_ALL __LC_PGM_OLD_PSW,__LC_SAVE_AREA,1
 	lgf     %r3,__LC_PGM_ILC	 # load program interruption code
 	lghi	%r8,0x7f
 	ngr	%r8,%r3
@@ -469,7 +497,7 @@ pgm_per:
 # Normal per exception
 #
 pgm_per_std:
-	SAVE_ALL __LC_PGM_OLD_PSW,1
+	SAVE_ALL __LC_PGM_OLD_PSW,__LC_SAVE_AREA,1
 	GET_THREAD_INFO
 	mvc	__THREAD_per+__PER_atmid(2,%r9),__LC_PER_ATMID
 	mvc	__THREAD_per+__PER_address(8,%r9),__LC_PER_ADDRESS
@@ -492,7 +520,7 @@ pgm_per_only:
 # it was a single stepped SVC that is causing all the trouble
 #
 pgm_svcper:
-	SAVE_ALL __LC_SVC_OLD_PSW,1
+	SAVE_ALL __LC_SVC_OLD_PSW,__LC_SAVE_AREA,1
 	llgh    %r7,__LC_SVC_INT_CODE # get svc number from lowcore
 	stosm   48(%r15),0x03     # reenable interrupts
         GET_THREAD_INFO           # load pointer to task_struct to R9
@@ -502,7 +530,8 @@ pgm_svcper:
 	slag	%r7,%r7,2         # *4 and test for svc 0
 	jnz	pgm_svcstd
 	# svc 0: system call number in %r1
-	clg	%r1,.Lnr_syscalls-.Lconst(%r14)
+	lghi	%r0,NR_syscalls
+	clr	%r1,%r0
 	slag	%r7,%r1,2
 pgm_svcstd:
 	larl    %r10,sys_call_table
@@ -540,8 +569,9 @@ pgm_tracesys:
 	srlg	%r7,%r7,2
 	stg	%r7,SP_R2(%r15)
         brasl   %r14,syscall_trace
-	clc	SP_R2(8,%r15),.Lnr_syscalls
-	jnl     pgm_svc_nogo
+	lghi	%r0,NR_syscalls
+	clg	%r0,SP_R2(%r15)
+	jnh	pgm_svc_nogo
 	lg      %r7,SP_R2(%r15)
 	sllg    %r7,%r7,2           # strace wants to change the syscall
 	lgf	%r8,0(%r7,%r10)
@@ -561,9 +591,10 @@ pgm_svc_nogo:
  */
         .globl io_int_handler
 io_int_handler:
-        SAVE_ALL __LC_IO_OLD_PSW,0
-        GET_THREAD_INFO                # load pointer to task_struct to R9
+        SAVE_ALL __LC_IO_OLD_PSW,__LC_SAVE_AREA+32,0
 	stck	__LC_INT_CLOCK
+	CHECK_CRITICAL
+        GET_THREAD_INFO                # load pointer to task_struct to R9
         la      %r2,SP_PTREGS(%r15)    # address of register-save area
 	brasl   %r14,do_IRQ            # call standard irq handler
 
@@ -577,25 +608,23 @@ io_return:
 	tm	__TI_flags+7(%r9),_TIF_WORK_INT
 	jnz	io_work                # there is work to do (signals etc.)
 io_leave:
-        RESTORE_ALL 0
+        RESTORE_ALL
 
 #ifdef CONFIG_PREEMPT
 io_preempt:
 	icm	%r0,15,__TI_precount(%r9)	
 	jnz     io_leave
+	# switch to kernel stack
+	lg	%r1,SP_R15(%r15)
+	aghi	%r1,-SP_SIZE
+	mvc	SP_PTREGS(__PT_SIZE,%r1),SP_PTREGS(%r15)
+        xc      0(8,%r1),0(%r1)        # clear back chain
+	lgr	%r15,%r1
 io_resume_loop:
 	tm	__TI_flags+7(%r9),_TIF_NEED_RESCHED
 	jno	io_leave
 	larl    %r1,.Lc_pactive
 	mvc     __TI_precount(4,%r9),0(%r1)
-	# hmpf, we are on the async. stack but to call schedule
-	# we have to move the interrupt frame to the process stack
-	lg	%r1,SP_R15(%r15)
-	aghi	%r1,-SP_SIZE
-	nill	%r1,0xfff8
-	mvc	SP_PTREGS(SP_SIZE-SP_PTREGS,%r1),SP_PTREGS(%r15)
-        xc      0(8,%r1),0(%r1)        # clear back chain
-	lgr	%r15,%r1
         stosm   48(%r15),0x03          # reenable interrupts
 	brasl   %r14,schedule          # call schedule
         stnsm   48(%r15),0xfc          # disable I/O and ext. interrupts
@@ -605,18 +634,19 @@ io_resume_loop:
 #endif
 
 #
-# recheck if there is more work to do
+# switch to kernel stack, then check TIF bits
 #
-io_work_loop:
-        stnsm   48(%r15),0xfc          # disable I/O and ext. interrupts
-        GET_THREAD_INFO                # load pointer to task_struct to R9
-	tm	__TI_flags+7(%r9),_TIF_WORK_INT
-	jz	io_leave               # there is no work to do
+io_work:
+	lg	%r1,__LC_KERNEL_STACK
+	aghi	%r1,-SP_SIZE
+	mvc	SP_PTREGS(__PT_SIZE,%r1),SP_PTREGS(%r15)
+        xc      0(8,%r1),0(%r1)        # clear back chain
+	lgr	%r15,%r1
 #
 # One of the work bits is on. Find out which one.
 # Checked are: _TIF_SIGPENDING and _TIF_NEED_RESCHED
 #
-io_work:
+io_work_loop:
 	tm	__TI_flags+7(%r9),_TIF_NEED_RESCHED
 	jo	io_reschedule
 	tm	__TI_flags+7(%r9),_TIF_SIGPENDING
@@ -628,8 +658,12 @@ io_work:
 #	
 io_reschedule:        
         stosm   48(%r15),0x03       # reenable interrupts
-	larl    %r14,io_work_loop
-        jg      schedule            # call scheduler
+        brasl   %r14,schedule       # call scheduler
+        stnsm   48(%r15),0xfc       # disable I/O and ext. interrupts
+        GET_THREAD_INFO             # load pointer to task_struct to R9
+	tm	__TI_flags+7(%r9),_TIF_WORK_INT
+	jz	io_leave               # there is no work to do
+	j	io_work_loop
 
 #
 # _TIF_SIGPENDING is set, call do_signal
@@ -647,7 +681,8 @@ io_sigpending:     
  */
         .globl  ext_int_handler
 ext_int_handler:
-        SAVE_ALL __LC_EXT_OLD_PSW,0
+        SAVE_ALL __LC_EXT_OLD_PSW,__LC_SAVE_AREA+32,0
+	CHECK_CRITICAL
         GET_THREAD_INFO                # load pointer to task_struct to R9
 	stck	__LC_INT_CLOCK
 	la	%r2,SP_PTREGS(%r15)    # address of register-save area
@@ -660,10 +695,10 @@ ext_int_handler:
  */
         .globl mcck_int_handler
 mcck_int_handler:
-        SAVE_ALL __LC_MCK_OLD_PSW,0
+        SAVE_ALL __LC_MCK_OLD_PSW,__LC_SAVE_AREA+64,0
 	brasl   %r14,s390_do_machine_check
 mcck_return:
-        RESTORE_ALL 0
+        RESTORE_ALL
 
 #ifdef CONFIG_SMP
 /*
@@ -694,16 +729,69 @@ restart_crash:
 restart_go:
 #endif
 
+cleanup_table:
+	.quad	system_call, sysc_enter, cleanup_sysc_enter
+	.quad	sysc_return, sysc_leave, cleanup_sysc_return
+	.quad	sysc_leave, sysc_work_loop, cleanup_sysc_leave
+	.quad	sysc_work_loop, sysc_reschedule, cleanup_sysc_return
+cleanup_table_entries=(.-cleanup_table) / 24
+
+cleanup_critical:
+	lghi	%r0,cleanup_table_entries
+	larl	%r1,cleanup_table
+	lg	%r2,SP_PSW+8(%r15)
+cleanup_loop:
+	clg	%r2,0(%r1)
+	jl	cleanup_cont
+	clg	%r2,8(%r1)
+	jl	cleanup_found
+cleanup_cont:
+	la	%r1,24(%r1)
+	brct	%r0,cleanup_loop
+	br	%r14
+cleanup_found:
+	lg	%r1,16(%r1)
+	br	%r1
+
+cleanup_sysc_enter:
+	CLEANUP_SAVE_ALL __LC_SVC_OLD_PSW,__LC_SAVE_AREA,1
+	llgh	%r0,0x8a
+	stg	%r0,SP_R7(%r15)
+	larl	%r1,sysc_enter
+	stg	%r1,SP_PSW+8(%r15)
+	br	%r14
+
+cleanup_sysc_return:
+	larl	%r1,sysc_return
+	stg	%r1,SP_PSW+8(%r15)
+	br	%r14
+
+cleanup_sysc_leave:
+	CLEANUP_RESTORE_ALL
+	br	%r14
+
 /*
  * Integer constants
  */
                .align 4
 .Lconst:
-.Lc_ac:        .long  0,0,1
 .Lc_pactive:   .long  PREEMPT_ACTIVE
-.L0x0130:      .word  0x0130
-.L0x0140:      .word  0x0140
-.L0x0150:      .word  0x0150
-.L0x0160:      .word  0x0160
-.L0x0170:      .word  0x0170
-.Lnr_syscalls: .long  NR_syscalls
+.Lcritical_start:
+               .quad  __critical_start
+.Lcritical_end:
+               .quad  __critical_end
+
+#define SYSCALL(esa,esame,emu)	.long esame
+	.globl  sys_call_table
+sys_call_table:
+#include "syscalls.S"
+#undef SYSCALL
+
+#ifdef CONFIG_S390_SUPPORT
+
+#define SYSCALL(esa,esame,emu)	.long emu
+	.globl  sys_call_table_emu
+sys_call_table_emu:
+#include "syscalls.S"
+#undef SYSCALL
+#endif
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/process.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/process.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/process.c	2004-02-26 11:21:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/process.c	2004-03-27 11:40:46.000000000 +0000
@@ -179,7 +179,7 @@ int kernel_thread(int (*fn)(void *), voi
 	memset(&regs, 0, sizeof(regs));
 	regs.psw.mask = PSW_KERNEL_BITS;
 	regs.psw.addr = (unsigned long) kernel_thread_starter | PSW_ADDR_AMODE;
-	regs.gprs[7] = STACK_FRAME_OVERHEAD;
+	regs.gprs[7] = STACK_FRAME_OVERHEAD + sizeof(struct pt_regs);
 	regs.gprs[8] = __LC_KERNEL_STACK;
 	regs.gprs[9] = (unsigned long) fn;
 	regs.gprs[10] = (unsigned long) arg;
@@ -230,6 +230,7 @@ int copy_thread(int nr, unsigned long cl
 		 (THREAD_SIZE + (unsigned long) p->thread_info)) - 1;
         p->thread.ksp = (unsigned long) frame;
 	p->set_child_tid = p->clear_child_tid = NULL;
+	/* Store access registers to kernel stack of new process. */
         frame->childregs = *regs;
 	frame->childregs.gprs[2] = 0;	/* child returns 0 on fork. */
         frame->childregs.gprs[15] = new_stackp;
@@ -240,6 +241,10 @@ int copy_thread(int nr, unsigned long cl
 
         /* fake return stack for resume(), don't go back to schedule */
         frame->gprs[9] = (unsigned long) frame;
+
+	/* Save access registers to new thread structure. */
+	save_access_regs(&p->thread.acrs[0]);
+
 #ifndef CONFIG_ARCH_S390X
         /*
 	 * save fprs to current->thread.fp_regs to merge them with
@@ -251,7 +256,7 @@ int copy_thread(int nr, unsigned long cl
         p->thread.user_seg = __pa((unsigned long) p->mm->pgd) | _SEGMENT_TABLE;
 	/* Set a new TLS ?  */
 	if (clone_flags & CLONE_SETTLS)
-		frame->childregs.acrs[0] = regs->gprs[6];
+		p->thread.acrs[0] = regs->gprs[6];
 #else /* CONFIG_ARCH_S390X */
 	/* Save the fpu registers to new thread structure. */
 	save_fp_regs(&p->thread.fp_regs);
@@ -259,30 +264,27 @@ int copy_thread(int nr, unsigned long cl
 	/* Set a new TLS ?  */
 	if (clone_flags & CLONE_SETTLS) {
 		if (test_thread_flag(TIF_31BIT)) {
-			frame->childregs.acrs[0] =
-				(unsigned int) regs->gprs[6];
+			p->thread.acrs[0] = (unsigned int) regs->gprs[6];
 		} else {
-			frame->childregs.acrs[0] =
-				(unsigned int)(regs->gprs[6] >> 32);
-			frame->childregs.acrs[1] =
-				(unsigned int) regs->gprs[6];
+			p->thread.acrs[0] = (unsigned int)(regs->gprs[6] >> 32);
+			p->thread.acrs[1] = (unsigned int) regs->gprs[6];
 		}
 	}
 #endif /* CONFIG_ARCH_S390X */
 	/* start new process with ar4 pointing to the correct address space */
-	p->thread.ar4 = get_fs().ar4;
+	p->thread.mm_segment = get_fs();
         /* Don't copy debug registers */
         memset(&p->thread.per_info,0,sizeof(p->thread.per_info));
 
         return 0;
 }
 
-asmlinkage int sys_fork(struct pt_regs regs)
+asmlinkage long sys_fork(struct pt_regs regs)
 {
 	return do_fork(SIGCHLD, regs.gprs[15], &regs, 0, NULL, NULL);
 }
 
-asmlinkage int sys_clone(struct pt_regs regs)
+asmlinkage long sys_clone(struct pt_regs regs)
 {
         unsigned long clone_flags;
         unsigned long newsp;
@@ -308,7 +310,7 @@ asmlinkage int sys_clone(struct pt_regs 
  * do not have enough call-clobbered registers to hold all
  * the information you need.
  */
-asmlinkage int sys_vfork(struct pt_regs regs)
+asmlinkage long sys_vfork(struct pt_regs regs)
 {
 	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD,
 		       regs.gprs[15], &regs, 0, NULL, NULL);
@@ -317,7 +319,7 @@ asmlinkage int sys_vfork(struct pt_regs 
 /*
  * sys_execve() executes a new program.
  */
-asmlinkage int sys_execve(struct pt_regs regs)
+asmlinkage long sys_execve(struct pt_regs regs)
 {
         int error;
         char * filename;
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/ptrace.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/ptrace.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/ptrace.c	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/ptrace.c	2004-03-27 11:40:46.000000000 +0000
@@ -137,25 +137,36 @@ peek_user(struct task_struct *child, add
 	if ((addr & 3) || addr > sizeof(struct user) - __ADDR_MASK)
 		return -EIO;
 
-	if (addr <= (addr_t) &dummy->regs.orig_gpr2) {
+	if (addr < (addr_t) &dummy->regs.acrs) {
 		/*
-		 * psw, gprs, acrs and orig_gpr2 are stored on the stack
+		 * psw and gprs are stored on the stack
 		 */
 		tmp = *(addr_t *)((addr_t) __KSTK_PTREGS(child) + addr);
 		if (addr == (addr_t) &dummy->regs.psw.mask)
 			/* Remove per bit from user psw. */
 			tmp &= ~PSW_MASK_PER;
 
-	} else if (addr >= (addr_t) &dummy->regs.fp_regs &&
-		   addr < (addr_t) (&dummy->regs.fp_regs + 1)) {
+	} else if (addr < (addr_t) &dummy->regs.orig_gpr2) {
+		/*
+		 * access registers are stored in the thread structure
+		 */
+		offset = addr - (addr_t) &dummy->regs.acrs;
+		tmp = *(addr_t *)((addr_t) &child->thread.acrs + offset);
+
+	} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {
+		/*
+		 * orig_gpr2 is stored on the kernel stack
+		 */
+		tmp = (addr_t) __KSTK_PTREGS(child)->orig_gpr2;
+
+	} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {
 		/* 
 		 * floating point regs. are stored in the thread structure
 		 */
 		offset = addr - (addr_t) &dummy->regs.fp_regs;
 		tmp = *(addr_t *)((addr_t) &child->thread.fp_regs + offset);
 
-	} else if (addr >= (addr_t) &dummy->regs.per_info &&
-		   addr < (addr_t) (&dummy->regs.per_info + 1)) {
+	} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {
 		/*
 		 * per_info is found in the thread structure
 		 */
@@ -187,9 +198,9 @@ poke_user(struct task_struct *child, add
 	if ((addr & 3) || addr > sizeof(struct user) - __ADDR_MASK)
 		return -EIO;
 
-	if (addr <= (addr_t) &dummy->regs.orig_gpr2) {
+	if (addr < (addr_t) &dummy->regs.acrs) {
 		/*
-		 * psw, gprs, acrs and orig_gpr2 are stored on the stack
+		 * psw and gprs are stored on the stack
 		 */
 		if (addr == (addr_t) &dummy->regs.psw.mask &&
 #ifdef CONFIG_S390_SUPPORT
@@ -206,8 +217,20 @@ poke_user(struct task_struct *child, add
 #endif
 		*(addr_t *)((addr_t) __KSTK_PTREGS(child) + addr) = data;
 
-	} else if (addr >= (addr_t) &dummy->regs.fp_regs &&
-		   addr < (addr_t) (&dummy->regs.fp_regs + 1)) {
+	} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {
+		/*
+		 * access registers are stored in the thread structure
+		 */
+		offset = addr - (addr_t) &dummy->regs.acrs;
+		*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;
+
+	} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {
+		/*
+		 * orig_gpr2 is stored on the kernel stack
+		 */
+		__KSTK_PTREGS(child)->orig_gpr2 = data;
+
+	} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {
 		/*
 		 * floating point regs. are stored in the thread structure
 		 */
@@ -217,8 +240,7 @@ poke_user(struct task_struct *child, add
 		offset = addr - (addr_t) &dummy->regs.fp_regs;
 		*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;
 
-	} else if (addr >= (addr_t) &dummy->regs.per_info &&
-		   addr < (addr_t) (&dummy->regs.per_info + 1)) {
+	} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {
 		/*
 		 * per_info is found in the thread structure 
 		 */
@@ -324,9 +346,9 @@ peek_user_emu31(struct task_struct *chil
 	    (addr & 3) || addr > sizeof(struct user) - 3)
 		return -EIO;
 
-	if (addr <= (addr_t) &dummy32->regs.orig_gpr2) {
+	if (addr < (addr_t) &dummy32->regs.acrs) {
 		/*
-		 * psw, gprs, acrs and orig_gpr2 are stored on the stack
+		 * psw and gprs are stored on the stack
 		 */
 		if (addr == (addr_t) &dummy32->regs.psw.mask) {
 			/* Fake a 31 bit psw mask. */
@@ -336,28 +358,32 @@ peek_user_emu31(struct task_struct *chil
 			/* Fake a 31 bit psw address. */
 			tmp = (__u32) __KSTK_PTREGS(child)->psw.addr |
 				PSW32_ADDR_AMODE31;
-		} else if (addr < (addr_t) &dummy32->regs.acrs[0]) {
+		} else {
 			/* gpr 0-15 */
 			tmp = *(__u32 *)((addr_t) __KSTK_PTREGS(child) + 
 					 addr*2 + 4);
-		} else if (addr < (addr_t) &dummy32->regs.orig_gpr2) {
-			offset = PT_ACR0 + addr - (addr_t) &dummy32->regs.acrs;
-			tmp = *(__u32*)((addr_t) __KSTK_PTREGS(child) + offset);
-		} else {
-			/* orig gpr 2 */
-			offset = PT_ORIGGPR2 + 4;
-			tmp = *(__u32*)((addr_t) __KSTK_PTREGS(child) + offset);
 		}
-	} else if (addr >= (addr_t) &dummy32->regs.fp_regs &&
-		   addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {
+	} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {
+		/*
+		 * access registers are stored in the thread structure
+		 */
+		offset = addr - (addr_t) &dummy32->regs.acrs;
+		tmp = *(__u32*)((addr_t) &child->thread.acrs + offset);
+
+	} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {
+		/*
+		 * orig_gpr2 is stored on the kernel stack
+		 */
+		tmp = *(__u32*)((addr_t) &__KSTK_PTREGS(child)->orig_gpr2 + 4);
+
+	} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {
 		/*
 		 * floating point regs. are stored in the thread structure 
 		 */
 	        offset = addr - (addr_t) &dummy32->regs.fp_regs;
 		tmp = *(__u32 *)((addr_t) &child->thread.fp_regs + offset);
 
-	} else if (addr >= (addr_t) &dummy32->regs.per_info &&
-		   addr < (addr_t) (&dummy32->regs.per_info + 1)) {
+	} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {
 		/*
 		 * per_info is found in the thread structure
 		 */
@@ -396,7 +422,7 @@ poke_user_emu31(struct task_struct *chil
 
 	tmp = (__u32) data;
 
-	if (addr <= (addr_t) &dummy32->regs.orig_gpr2) {
+	if (addr < (addr_t) &dummy32->regs.acrs) {
 		/*
 		 * psw, gprs, acrs and orig_gpr2 are stored on the stack
 		 */
@@ -411,19 +437,25 @@ poke_user_emu31(struct task_struct *chil
 			/* Build a 64 bit psw address from 31 bit address. */
 			__KSTK_PTREGS(child)->psw.addr = 
 				(__u64) tmp & PSW32_ADDR_INSN;
-		} else if (addr < (addr_t) &dummy32->regs.acrs[0]) {
+		} else {
 			/* gpr 0-15 */
 			*(__u32*)((addr_t) __KSTK_PTREGS(child) + addr*2 + 4) =
 				tmp;
-		} else if (addr < (addr_t) &dummy32->regs.orig_gpr2) {
-			offset = PT_ACR0 + addr - (addr_t) &dummy32->regs.acrs;
-			*(__u32*)((addr_t) __KSTK_PTREGS(child) + offset) = tmp;
-		} else {
-			offset = PT_ORIGGPR2 + 4;
-			*(__u32*)((addr_t) __KSTK_PTREGS(child) + offset) = tmp;
 		}
-	} else if (addr >= (addr_t) &dummy32->regs.fp_regs &&
-		   addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {
+	} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {
+		/*
+		 * access registers are stored in the thread structure
+		 */
+		offset = addr - (addr_t) &dummy32->regs.acrs;
+		*(__u32*)((addr_t) &child->thread.acrs + offset) = tmp;
+
+	} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {
+		/*
+		 * orig_gpr2 is stored on the kernel stack
+		 */
+		*(__u32*)((addr_t) &__KSTK_PTREGS(child)->orig_gpr2 + 4) = tmp;
+
+	} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {
 		/*
 		 * floating point regs. are stored in the thread structure 
 		 */
@@ -434,8 +466,7 @@ poke_user_emu31(struct task_struct *chil
 	        offset = addr - (addr_t) &dummy32->regs.fp_regs;
 		*(__u32 *)((addr_t) &child->thread.fp_regs + offset) = tmp;
 
-	} else if (addr >= (addr_t) &dummy32->regs.per_info &&
-		   addr < (addr_t) (&dummy32->regs.per_info + 1)) {
+	} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {
 		/*
 		 * per_info is found in the thread structure.
 		 */
@@ -616,7 +647,7 @@ do_ptrace(struct task_struct *child, lon
 	return -EIO;
 }
 
-asmlinkage int
+asmlinkage long
 sys_ptrace(long request, long pid, long addr, long data)
 {
 	struct task_struct *child;
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/s390_ksyms.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/s390_ksyms.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/s390_ksyms.c	2004-03-02 03:01:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/s390_ksyms.c	2004-03-27 11:40:46.000000000 +0000
@@ -33,6 +33,8 @@ EXPORT_SYMBOL_NOVERS(_sb_findmap);
 EXPORT_SYMBOL_NOVERS(__copy_from_user_asm);
 EXPORT_SYMBOL_NOVERS(__copy_to_user_asm);
 EXPORT_SYMBOL_NOVERS(__clear_user_asm);
+EXPORT_SYMBOL_NOVERS(__strncpy_from_user_asm);
+EXPORT_SYMBOL_NOVERS(__strnlen_user_asm);
 EXPORT_SYMBOL(diag10);
 
 /*
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/setup.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/setup.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/setup.c	2004-01-19 06:35:53.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/setup.c	2004-03-27 11:40:46.000000000 +0000
@@ -492,26 +492,27 @@ void __init setup_arch(char **cmdline_p)
 #endif /* CONFIG_ARCH_S390X */
 	lc->restart_psw.mask = PSW_BASE_BITS;
 	lc->restart_psw.addr =
-		PSW_ADDR_AMODE + (unsigned long) restart_int_handler;
+		PSW_ADDR_AMODE | (unsigned long) restart_int_handler;
 	lc->external_new_psw.mask = PSW_KERNEL_BITS;
 	lc->external_new_psw.addr =
-		PSW_ADDR_AMODE + (unsigned long) ext_int_handler;
-	lc->svc_new_psw.mask = PSW_KERNEL_BITS;
-	lc->svc_new_psw.addr = PSW_ADDR_AMODE + (unsigned long) system_call;
+		PSW_ADDR_AMODE | (unsigned long) ext_int_handler;
+	lc->svc_new_psw.mask = PSW_KERNEL_BITS | PSW_MASK_IO | PSW_MASK_EXT;
+	lc->svc_new_psw.addr = PSW_ADDR_AMODE | (unsigned long) system_call;
 	lc->program_new_psw.mask = PSW_KERNEL_BITS;
 	lc->program_new_psw.addr =
-		PSW_ADDR_AMODE + (unsigned long)pgm_check_handler;
+		PSW_ADDR_AMODE | (unsigned long)pgm_check_handler;
 	lc->mcck_new_psw.mask = PSW_KERNEL_BITS;
 	lc->mcck_new_psw.addr =
-		PSW_ADDR_AMODE + (unsigned long) mcck_int_handler;
+		PSW_ADDR_AMODE | (unsigned long) mcck_int_handler;
 	lc->io_new_psw.mask = PSW_KERNEL_BITS;
-	lc->io_new_psw.addr = PSW_ADDR_AMODE + (unsigned long) io_int_handler;
+	lc->io_new_psw.addr = PSW_ADDR_AMODE | (unsigned long) io_int_handler;
 	lc->ipl_device = S390_lowcore.ipl_device;
 	lc->jiffy_timer = -1LL;
 	lc->kernel_stack = ((unsigned long) &init_thread_union) + THREAD_SIZE;
 	lc->async_stack = (unsigned long)
 		__alloc_bootmem(ASYNC_SIZE, ASYNC_SIZE, 0) + ASYNC_SIZE;
 	lc->current_task = (unsigned long) init_thread_union.thread_info.task;
+	lc->thread_info = (unsigned long) &init_thread_union;
 #ifdef CONFIG_ARCH_S390X
 	if (MACHINE_HAS_DIAG44)
 		lc->diag44_opcode = 0x83000044;
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/signal.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/signal.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/signal.c	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/signal.c	2004-03-27 11:40:46.000000000 +0000
@@ -151,13 +151,20 @@ static int save_sigregs(struct pt_regs *
 	unsigned long old_mask = regs->psw.mask;
 	int err;
   
+	save_access_regs(current->thread.acrs);
+
 	/* Copy a 'clean' PSW mask to the user to avoid leaking
 	   information about whether PER is currently on.  */
 	regs->psw.mask = PSW_MASK_MERGE(PSW_USER_BITS, regs->psw.mask);
-	err = __copy_to_user(&sregs->regs, regs, sizeof(_s390_regs_common));
+	err = __copy_to_user(&sregs->regs.psw, &regs->psw,
+			     sizeof(sregs->regs.psw)+sizeof(sregs->regs.gprs));
 	regs->psw.mask = old_mask;
 	if (err != 0)
 		return err;
+	err = __copy_to_user(&sregs->regs.acrs, current->thread.acrs,
+			     sizeof(sregs->regs.acrs));
+	if (err != 0)
+		return err;
 	/* 
 	 * We have to store the fp registers to current->thread.fp_regs
 	 * to merge them with the emulated registers.
@@ -176,11 +183,17 @@ static int restore_sigregs(struct pt_reg
 	/* Alwys make any pending restarted system call return -EINTR */
 	current_thread_info()->restart_block.fn = do_no_restart_syscall;
 
-	err = __copy_from_user(regs, &sregs->regs, sizeof(_s390_regs_common));
+	err = __copy_from_user(&regs->psw, &sregs->regs.psw,
+			       sizeof(sregs->regs.psw)+sizeof(sregs->regs.gprs));
 	regs->psw.mask = PSW_MASK_MERGE(old_mask, regs->psw.mask);
 	regs->psw.addr |= PSW_ADDR_AMODE;
 	if (err)
 		return err;
+	err = __copy_from_user(&current->thread.acrs, &sregs->regs.acrs,
+			       sizeof(sregs->regs.acrs));
+	if (err)
+		return err;
+	restore_access_regs(current->thread.acrs);
 
 	err = __copy_from_user(&current->thread.fp_regs, &sregs->fpregs,
 			       sizeof(s390_fp_regs));
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/sys_s390.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/sys_s390.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/sys_s390.c	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/sys_s390.c	2004-03-27 11:40:45.000000000 +0000
@@ -32,17 +32,11 @@
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 
-#ifndef CONFIG_ARCH_S390X
-#define __SYS_RETTYPE int
-#else
-#define __SYS_RETTYPE long
-#endif /* CONFIG_ARCH_S390X */
-
 /*
  * sys_pipe() is the normal C calling standard for creating
  * a pipe. It's not the way Unix traditionally does this, though.
  */
-asmlinkage __SYS_RETTYPE sys_pipe(unsigned long * fildes)
+asmlinkage long sys_pipe(unsigned long * fildes)
 {
 	int fd[2];
 	int error;
@@ -61,7 +55,7 @@ static inline long do_mmap2(
 	unsigned long prot, unsigned long flags,
 	unsigned long fd, unsigned long pgoff)
 {
-	__SYS_RETTYPE error = -EBADF;
+	long error = -EBADF;
 	struct file * file = NULL;
 
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
@@ -109,10 +103,10 @@ out:
 	return error;
 }
 
-asmlinkage __SYS_RETTYPE old_mmap(struct mmap_arg_struct *arg)
+asmlinkage long old_mmap(struct mmap_arg_struct *arg)
 {
 	struct mmap_arg_struct a;
-	__SYS_RETTYPE error = -EFAULT;
+	long error = -EFAULT;
 
 	if (copy_from_user(&a, arg, sizeof(a)))
 		goto out;
@@ -133,7 +127,7 @@ struct sel_arg_struct {
 	struct timeval *tvp;
 };
 
-asmlinkage int old_select(struct sel_arg_struct *arg)
+asmlinkage long old_select(struct sel_arg_struct *arg)
 {
 	struct sel_arg_struct a;
 
@@ -182,7 +176,7 @@ arch_get_unmapped_area(struct file *filp
  *
  * This is really horribly ugly.
  */
-asmlinkage __SYS_RETTYPE sys_ipc (uint call, int first, int second, 
+asmlinkage long sys_ipc (uint call, int first, int second,
 				  unsigned long third, void *ptr)
 {
         struct ipc_kludge tmp;
@@ -246,7 +240,7 @@ asmlinkage __SYS_RETTYPE sys_ipc (uint c
 }
 
 #ifdef CONFIG_ARCH_S390X
-asmlinkage int s390x_newuname(struct new_utsname * name)
+asmlinkage long s390x_newuname(struct new_utsname * name)
 {
 	int ret = sys_newuname(name);
 
@@ -257,7 +251,7 @@ asmlinkage int s390x_newuname(struct new
 	return ret;
 }
 
-asmlinkage int s390x_personality(unsigned long personality)
+asmlinkage long s390x_personality(unsigned long personality)
 {
 	int ret;
 
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/kernel/traps.c linux-post-2.6.5-rc2-20040329/arch/s390/kernel/traps.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/kernel/traps.c	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/kernel/traps.c	2004-03-27 11:40:46.000000000 +0000
@@ -173,6 +173,10 @@ void show_registers(struct pt_regs *regs
 	printk("           " FOURLONG,
 	       regs->gprs[12], regs->gprs[13], regs->gprs[14], regs->gprs[15]);
 
+#if 0
+	/* FIXME: this isn't needed any more but it changes the ksymoops
+	 * input. To remove or not to remove ... */
+	save_access_regs(regs->acrs);
 	printk("%s ACRS: %08x %08x %08x %08x\n", mode,
 	       regs->acrs[0], regs->acrs[1], regs->acrs[2], regs->acrs[3]);
 	printk("           %08x %08x %08x %08x\n",
@@ -181,6 +185,7 @@ void show_registers(struct pt_regs *regs
 	       regs->acrs[8], regs->acrs[9], regs->acrs[10], regs->acrs[11]);
 	printk("           %08x %08x %08x %08x\n",
 	       regs->acrs[12], regs->acrs[13], regs->acrs[14], regs->acrs[15]);
+#endif
 
 	/*
 	 * Print the first 20 byte of the instruction stream at the
@@ -229,17 +234,17 @@ char *task_show_regs(struct task_struct 
 			  regs->gprs[12], regs->gprs[13],
 			  regs->gprs[14], regs->gprs[15]);
 	buffer += sprintf(buffer, "User ACRS: %08x %08x %08x %08x\n",
-			  regs->acrs[0], regs->acrs[1],
-			  regs->acrs[2], regs->acrs[3]);
+			  task->thread.acrs[0], task->thread.acrs[1],
+			  task->thread.acrs[2], task->thread.acrs[3]);
 	buffer += sprintf(buffer, "           %08x %08x %08x %08x\n",
-			  regs->acrs[4], regs->acrs[5],
-			  regs->acrs[6], regs->acrs[7]);
+			  task->thread.acrs[4], task->thread.acrs[5],
+			  task->thread.acrs[6], task->thread.acrs[7]);
 	buffer += sprintf(buffer, "           %08x %08x %08x %08x\n",
-			  regs->acrs[8], regs->acrs[9],
-			  regs->acrs[10], regs->acrs[11]);
+			  task->thread.acrs[8], task->thread.acrs[9],
+			  task->thread.acrs[10], task->thread.acrs[11]);
 	buffer += sprintf(buffer, "           %08x %08x %08x %08x\n",
-			  regs->acrs[12], regs->acrs[13],
-			  regs->acrs[14], regs->acrs[15]);
+			  task->thread.acrs[12], task->thread.acrs[13],
+			  task->thread.acrs[14], task->thread.acrs[15]);
 	return buffer;
 }
 
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/lib/uaccess.S linux-post-2.6.5-rc2-20040329/arch/s390/lib/uaccess.S
--- linux-post-2.6.5-rc2-20040327/arch/s390/lib/uaccess.S	2004-01-19 06:35:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/lib/uaccess.S	2004-03-27 11:40:46.000000000 +0000
@@ -9,135 +9,191 @@
  *  These functions have standard call interface
  */
 
+#include <linux/errno.h>
 #include <asm/lowcore.h>
+#include <asm/offsets.h>
 
         .text
         .align 4
         .globl __copy_from_user_asm
+	# %r2 = to, %r3 = n, %r4 = from
 __copy_from_user_asm:
-	lr	%r5,%r3
-	sacf	512
-0:	mvcle	%r2,%r4,0
-	jo	0b
-1:	sacf	0
-	lr	%r2,%r5
-	br	%r14
-2:	lhi	%r1,-4096
-	lr	%r3,%r4
-	slr	%r3,%r1      # %r3 = %r4 + 4096
-	nr	%r3,%r1      # %r3 = (%r4 + 4096) & -4096
-	slr	%r3,%r4      # %r3 = #bytes to next user page boundary
-	clr	%r5,%r3      # copy crosses next page boundary ?
-	jnh	1b           # no, this page fauled
-	# The page after the current user page might have faulted.
-	# We cant't find out which page because the program check handler
-	# might have callled schedule, destroying all lowcore information.
-	# We retry with the shortened length.
-3:	mvcle	%r2,%r4,0
-	jo	3b
-	j	1b
+	slr	%r0,%r0
+0:	mvcp	0(%r3,%r2),0(%r4),%r0
+	jnz	1f
+	slr	%r2,%r2
+	br	%r14
+1:	la	%r2,256(%r2)
+	la	%r4,256(%r4)
+	ahi	%r3,-256
+2:	mvcp	0(%r3,%r2),0(%r4),%r0
+	jnz	1b
+3:	slr	%r2,%r2
+	br	%r14
+4:	lhi	%r0,-4096
+	lr	%r5,%r4
+	slr	%r5,%r0
+	nr	%r5,%r0		# %r5 = (%r4 + 4096) & -4096
+	slr	%r5,%r4		# %r5 = #bytes to next user page boundary
+	clr	%r3,%r5		# copy crosses next page boundary ?
+	jnh	6f		# no, the current page faulted
+	# move with the reduced length which is < 256
+5:	mvcp	0(%r5,%r2),0(%r4),%r0
+	slr	%r3,%r5
+6:	lr	%r2,%r3
+	br	%r14
         .section __ex_table,"a"
-	.long	0b,2b
-	.long	3b,1b
+	.long	0b,4b
+	.long	2b,4b
+	.long	5b,6b
         .previous
 
         .align 4
         .text
         .globl __copy_to_user_asm
+	# %r2 = from, %r3 = n, %r4 = to
 __copy_to_user_asm:
-	lr	%r5,%r3
-	sacf	512
-0:	mvcle	%r4,%r2,0
-	jo	0b
-1:	sacf	0
-	lr	%r2,%r3
+	slr	%r0,%r0
+0:	mvcs	0(%r3,%r4),0(%r2),%r0
+	jnz	1f
+	slr	%r2,%r2
+	br	%r14
+1:	la	%r2,256(%r2)
+	la	%r4,256(%r4)
+	ahi	%r3,-256
+2:	mvcs	0(%r3,%r4),0(%r2),%r0
+	jnz	1b
+3:	slr	%r2,%r2
 	br	%r14
-2:	lhi	%r1,-4096
+4:	lhi	%r0,-4096
 	lr	%r5,%r4
-	slr	%r5,%r1      # %r5 = %r4 + 4096
-	nr	%r5,%r1      # %r5 = (%r4 + 4096) & -4096
-	slr	%r5,%r4      # %r5 = #bytes to next user page boundary
-	clr	%r3,%r5      # copy crosses next page boundary ?
-	jnh	1b           # no, the current page fauled
-	# The page after the current user page might have faulted.
-	# We cant't find out which page because the program check handler
-	# might have callled schedule, destroying all lowcore information.
-	# We retry with the shortened length.
-3:	mvcle	%r4,%r2,0
-	jo	3b
-	j	1b
+	slr	%r5,%r0
+	nr	%r5,%r0		# %r5 = (%r4 + 4096) & -4096
+	slr	%r5,%r4		# %r5 = #bytes to next user page boundary
+	clr	%r3,%r5		# copy crosses next page boundary ?
+	jnh	6f		# no, the current page faulted
+	# move with the reduced length which is < 256
+5:	mvcs	0(%r5,%r4),0(%r2),%r0
+	slr	%r3,%r5
+6:	lr	%r2,%r3
+	br	%r14
         .section __ex_table,"a"
-	.long	0b,2b
-	.long	3b,1b
+	.long	0b,4b
+	.long	2b,4b
+	.long	5b,6b
         .previous
 
         .align 4
         .text
         .globl __copy_in_user_asm
+	# %r2 = from, %r3 = n, %r4 = to
 __copy_in_user_asm:
-	stm	%r6,%r15,24(%r15)
-	lr	%r5,%r3
-	lr	%r7,%r3
-	lr	%r6,%r2
-	cpya	6,4          # ar6 = ar4
-	sacf	512
-0:	mvcle	%r4,%r6,0
-	jo	0b
-1:	sacf	0
-	lr	%r2,%r7
-	lm	%r6,%r15,24(%r15)
+	sacf	256
+	bras	1,1f
+	mvc	0(1,%r4),0(%r2)
+0:	mvc	0(256,%r4),0(%r2)
+	la	%r2,256(%r2)
+	la	%r4,256(%r4)
+1:	ahi	%r3,-256
+	jnm	0b
+2:	ex	%r3,0(%r1)
+	sacf	0
+	slr	%r2,%r2
+	br	14
+3:	mvc	0(1,%r4),0(%r2)
+	la	%r2,1(%r2)
+	la	%r4,1(%r4)
+	ahi	%r3,-1
+	jnm	3b
+4:	lr	%r2,%r3
+	sacf	0
 	br	%r14
-2:	lhi	%r1,-4096
-	lr	%r5,%r4
-	slr	%r5,%r1      # %r5 = %r4 + 4096
-	nr	%r5,%r1      # %r5 = (%r4 + 4096) & -4096
-	slr	%r5,%r4      # %r5 = #bytes to next user page boundary
-	clr	%r7,%r5      # copy crosses next page boundary ?
-	jnh	1b           # no, the current page fauled
-	# The page after the current user page might have faulted.
-	# We cant't find out which page because the program check handler
-	# might have callled schedule, destroying all lowcore information.
-	# We retry with the shortened length.
-3:	mvcle	%r4,%r6,0
-	jo	3b
-	j	1b
         .section __ex_table,"a"
-	.long	0b,2b
-	.long	3b,1b
+	.long	0b,3b
+	.long	2b,3b
+	.long	3b,4b
         .previous
 
         .align 4
         .text
         .globl __clear_user_asm
+	# %r2 = to, %r3 = n
 __clear_user_asm:
+	bras	%r5,0f
+	.long	empty_zero_page
+0:	l	%r5,0(%r5)
+	slr	%r0,%r0
+1:	mvcs	0(%r3,%r2),0(%r5),%r0
+	jnz	2f
+	slr	%r2,%r2
+	br	%r14
+2:	la	%r2,256(%r2)
+	ahi	%r3,-256
+3:	mvcs	0(%r3,%r2),0(%r5),%r0
+	jnz	2b
+4:	slr	%r2,%r2
+	br	%r14
+5:	lhi	%r0,-4096
 	lr	%r4,%r2
-	lr	%r5,%r3
-	sr	%r2,%r2
-	sr	%r3,%r3
-	sacf	512
-0:	mvcle	%r4,%r2,0
-	jo	0b
-1:	sacf	0
-	br	%r14
-2:	lr	%r2,%r5
-	lhi	%r1,-4096
-	slr	%r5,%r1      # %r5 = %r4 + 4096
-	nr	%r5,%r1      # %r5 = (%r4 + 4096) & -4096
-	slr	%r5,%r4      # %r5 = #bytes to next user page boundary
-	clr	%r2,%r5      # copy crosses next page boundary ?
-	jnh	1b           # no, the current page fauled
-	# The page after the current user page might have faulted.
-	# We cant't find out which page because the program check handler
-	# might have callled schedule, destroying all lowcore information.
-	# We retry with the shortened length.
-	slr	%r2,%r5
-3:	mvcle	%r4,%r2,0
-	jo	3b
-	j	1b
-4:	alr	%r2,%r5
-	j	1b
+	slr	%r4,%r0
+	nr	%r4,%r0		# %r4 = (%r2 + 4096) & -4096
+	slr	%r4,%r2		# %r4 = #bytes to next user page boundary
+	clr	%r3,%r4		# clear crosses next page boundary ?
+	jnh	7f		# no, the current page faulted
+	# clear with the reduced length which is < 256
+6:	mvcs	0(%r4,%r2),0(%r5),%r0
+	slr	%r3,%r4
+7:	lr	%r2,%r3
+	br	%r14
         .section __ex_table,"a"
-	.long	0b,2b
-        .long	3b,4b
+	.long	1b,5b
+	.long	3b,5b
+	.long	6b,7b
         .previous
 
+        .align 4
+        .text
+        .globl __strncpy_from_user_asm
+	# %r2 = dst, %r3 = src, %r4 = count
+__strncpy_from_user_asm:
+	lhi	%r0,0
+	lhi	%r1,1
+	lhi	%r5,0
+0:	mvcp	0(%r1,%r2),0(%r3),%r0
+	tm	0(%r2),0xff
+	jz	1f
+	la	%r2,1(%r2)
+	la	%r3,1(%r3)
+	ahi	%r5,1
+	clr	%r5,%r4
+	jl	0b
+1:	lr	%r2,%r5
+	br	%r14
+2:	lhi	%r2,-EFAULT
+	br	%r14
+        .section __ex_table,"a"
+	.long	0b,2b
+	.previous
+
+        .align 4
+        .text
+        .globl __strnlen_user_asm
+	# %r2 = src, %r3 = count
+__strnlen_user_asm:
+	lhi	%r0,0
+	lhi	%r1,1
+	lhi	%r5,0
+0:	mvcp	24(%r1,%r15),0(%r2),%r0
+	ahi	%r5,1
+	tm	24(%r15),0xff
+	jz	1f
+	la	%r2,1(%r2)
+	clr	%r5,%r3
+	jl	0b
+1:	lr	%r2,%r5
+	br	%r14
+2:	lhi	%r2,-EFAULT
+	br	%r14
+        .section __ex_table,"a"
+	.long	0b,2b
+	.previous
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/lib/uaccess64.S linux-post-2.6.5-rc2-20040329/arch/s390/lib/uaccess64.S
--- linux-post-2.6.5-rc2-20040327/arch/s390/lib/uaccess64.S	2004-01-19 06:35:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/lib/uaccess64.S	2004-03-27 11:40:46.000000000 +0000
@@ -9,134 +9,189 @@
  *  These functions have standard call interface
  */
 
+#include <linux/errno.h>
 #include <asm/lowcore.h>
+#include <asm/offsets.h>
 
         .text
         .align 4
         .globl __copy_from_user_asm
+	# %r2 = to, %r3 = n, %r4 = from
 __copy_from_user_asm:
-	lgr	%r5,%r3
-	sacf	512
-0:	mvcle	%r2,%r4,0
-	jo	0b
-1:	sacf	0
-	lgr	%r2,%r5
-	br	%r14
-2:	lghi	%r1,-4096
-	lgr	%r3,%r4
-	slgr	%r3,%r1      # %r3 = %r4 + 4096
-	ngr	%r3,%r1      # %r3 = (%r4 + 4096) & -4096
-	slgr	%r3,%r4      # %r3 = #bytes to next user page boundary
-	clgr	%r5,%r3      # copy crosses next page boundary ?
-	jnh	1b           # no, this page fauled
-	# The page after the current user page might have faulted.
-	# We cant't find out which page because the program check handler
-	# might have callled schedule, destroying all lowcore information.
-	# We retry with the shortened length.
-3:	mvcle	%r2,%r4,0
-	jo	3b
-	j	1b
+	slgr	%r0,%r0
+0:	mvcp	0(%r3,%r2),0(%r4),%r0
+	jnz	1f
+	slgr	%r2,%r2
+	br	%r14
+1:	la	%r2,256(%r2)
+	la	%r4,256(%r4)
+	aghi	%r3,-256
+2:	mvcp	0(%r3,%r2),0(%r4),%r0
+	jnz	1b
+3:	slgr	%r2,%r2
+	br	%r14
+4:	lghi	%r0,-4096
+	lgr	%r5,%r4
+	slgr	%r5,%r0
+	ngr	%r5,%r0		# %r5 = (%r4 + 4096) & -4096
+	slgr	%r5,%r4		# %r5 = #bytes to next user page boundary
+	clgr	%r3,%r5		# copy crosses next page boundary ?
+	jnh	6f		# no, the current page faulted
+	# move with the reduced length which is < 256
+5:	mvcp	0(%r5,%r2),0(%r4),%r0
+	slgr	%r3,%r5
+6:	lgr	%r2,%r3
+	br	%r14
         .section __ex_table,"a"
-	.quad	0b,2b
-	.quad	3b,1b
+	.quad	0b,4b
+	.quad	2b,4b
+	.quad	5b,6b
         .previous
 
         .align 4
         .text
         .globl __copy_to_user_asm
+	# %r2 = from, %r3 = n, %r4 = to
 __copy_to_user_asm:
-	lgr	%r5,%r3
-	sacf	512
-0:	mvcle	%r4,%r2,0
-	jo	0b
-1:	sacf	0
-	lgr	%r2,%r3
+	slgr	%r0,%r0
+0:	mvcs	0(%r3,%r4),0(%r2),%r0
+	jnz	1f
+	slgr	%r2,%r2
+	br	%r14
+1:	la	%r2,256(%r2)
+	la	%r4,256(%r4)
+	aghi	%r3,-256
+2:	mvcs	0(%r3,%r4),0(%r2),%r0
+	jnz	1b
+3:	slgr	%r2,%r2
 	br	%r14
-2:	lghi	%r1,-4096
+4:	lghi	%r0,-4096
 	lgr	%r5,%r4
-	slgr	%r5,%r1      # %r5 = %r4 + 4096
-	ngr	%r5,%r1      # %r5 = (%r4 + 4096) & -4096
-	slgr	%r5,%r4      # %r5 = #bytes to next user page boundary
-	clgr	%r3,%r5      # copy crosses next page boundary ?
-	jnh	1b           # no, the current page fauled
-	# The page after the current user page might have faulted.
-	# We cant't find out which page because the program check handler
-	# might have callled schedule, destroying all lowcore information.
-	# We retry with the shortened length.
-3:	mvcle	%r4,%r2,0
-	jo	3b
-	j	1b
+	slgr	%r5,%r0
+	ngr	%r5,%r0		# %r5 = (%r4 + 4096) & -4096
+	slgr	%r5,%r4		# %r5 = #bytes to next user page boundary
+	clgr	%r3,%r5		# copy crosses next page boundary ?
+	jnh	6f		# no, the current page faulted
+	# move with the reduced length which is < 256
+5:	mvcs	0(%r5,%r4),0(%r2),%r0
+	slgr	%r3,%r5
+6:	lgr	%r2,%r3
+	br	%r14
         .section __ex_table,"a"
-	.quad	0b,2b
-	.quad	3b,1b
+	.quad	0b,4b
+	.quad	2b,4b
+	.quad	5b,6b
         .previous
 
         .align 4
         .text
         .globl __copy_in_user_asm
+	# %r2 = from, %r3 = n, %r4 = to
 __copy_in_user_asm:
-	stmg	%r6,%r15,48(%r15)
-	lgr	%r5,%r3
-	lgr	%r7,%r5
-	lgr	%r6,%r2
-	cpya	6,4          # ar6 = ar4
-	sacf	512
-0:	mvcle	%r4,%r6,0
-	jo	0b
-1:	sacf	0
-	lgr	%r2,%r7
-	lmg	%r6,%r15,48(%r15)
+	sacf	256
+	bras	1,1f
+	mvc	0(1,%r4),0(%r2)
+0:	mvc	0(256,%r4),0(%r2)
+	la	%r2,256(%r2)
+	la	%r4,256(%r4)
+1:	aghi	%r3,-256
+	jnm	0b
+2:	ex	%r3,0(%r1)
+	sacf	0
+	slgr	%r2,%r2
+	br	14
+3:	mvc	0(1,%r4),0(%r2)
+	la	%r2,1(%r2)
+	la	%r4,1(%r4)
+	aghi	%r3,-1
+	jnm	3b
+4:	lgr	%r2,%r3
+	sacf	0
 	br	%r14
-2:	lghi	%r1,-4096
-	lgr	%r5,%r4
-	slgr	%r5,%r1      # %r5 = %r4 + 4096
-	ngr	%r5,%r1      # %r5 = (%r4 + 4096) & -4096
-	slgr	%r5,%r4      # %r5 = #bytes to next user page boundary
-	clgr	%r7,%r5      # copy crosses next page boundary ?
-	jnh	1b           # no, the current page fauled
-	# The page after the current user page might have faulted.
-	# We cant't find out which page because the program check handler
-	# might have callled schedule, destroying all lowcore information.
-	# We retry with the shortened length.
-3:	mvcle	%r4,%r6,0
-	jo	3b
-	j	1b
         .section __ex_table,"a"
-	.quad	0b,2b
-	.quad	3b,1b
+	.quad	0b,3b
+	.quad	2b,3b
+	.quad	3b,4b
         .previous
 
         .align 4
         .text
         .globl __clear_user_asm
+	# %r2 = to, %r3 = n
 __clear_user_asm:
+	slgr	%r0,%r0
+	larl	%r5,empty_zero_page
+1:	mvcs	0(%r3,%r2),0(%r5),%r0
+	jnz	2f
+	slgr	%r2,%r2
+	br	%r14
+2:	la	%r2,256(%r2)
+	aghi	%r3,-256
+3:	mvcs	0(%r3,%r2),0(%r5),%r0
+	jnz	2b
+4:	slgr	%r2,%r2
+	br	%r14
+5:	lghi	%r0,-4096
 	lgr	%r4,%r2
-	lgr	%r5,%r3
-	sgr	%r2,%r2
-	sgr	%r3,%r3
-	sacf	512
-0:	mvcle	%r4,%r2,0
-	jo	0b
-1:	sacf	0
-	br	%r14
-2:	lgr	%r2,%r5
-	lghi	%r1,-4096
-	slgr	%r5,%r1      # %r5 = %r4 + 4096
-	ngr	%r5,%r1      # %r5 = (%r4 + 4096) & -4096
-	slgr	%r5,%r4      # %r5 = #bytes to next user page boundary
-	clgr	%r2,%r5      # copy crosses next page boundary ?
-	jnh	1b           # no, the current page fauled
-	# The page after the current user page might have faulted.
-	# We cant't find out which page because the program check handler
-	# might have callled schedule, destroying all lowcore information.
-	# We retry with the shortened length.
-	slgr	%r2,%r5
-3:	mvcle	%r4,%r2,0
-	jo	3b
-	j	1b
-4:	algr	%r2,%r5
-	j	1b
+	slgr	%r4,%r0
+	ngr	%r4,%r0		# %r4 = (%r2 + 4096) & -4096
+	slgr	%r4,%r2		# %r4 = #bytes to next user page boundary
+	clgr	%r3,%r4		# clear crosses next page boundary ?
+	jnh	7f		# no, the current page faulted
+	# clear with the reduced length which is < 256
+6:	mvcs	0(%r4,%r2),0(%r5),%r0
+	slgr	%r3,%r4
+7:	lgr	%r2,%r3
+	br	%r14
         .section __ex_table,"a"
-	.quad	0b,2b
-        .quad	3b,4b
+	.quad	1b,5b
+	.quad	3b,5b
+	.quad	6b,7b
         .previous
+
+        .align 4
+        .text
+        .globl __strncpy_from_user_asm
+	# %r2 = dst, %r3 = src, %r4 = count
+__strncpy_from_user_asm:
+	lghi	%r0,0
+	lghi	%r1,1
+	lghi	%r5,0
+0:	mvcp	0(%r1,%r2),0(%r3),%r0
+	tm	0(%r2),0xff
+	jz	1f
+	la	%r2,1(%r2)
+	la	%r3,1(%r3)
+	aghi	%r5,1
+	clgr	%r5,%r4
+	jl	0b
+1:	lgr	%r2,%r5
+	br	%r14
+2:	lghi	%r2,-EFAULT
+	br	%r14
+        .section __ex_table,"a"
+	.quad	0b,2b
+	.previous
+
+        .align 4
+        .text
+        .globl __strnlen_user_asm
+	# %r2 = src, %r3 = count
+__strnlen_user_asm:
+	lghi	%r0,0
+	lghi	%r1,1
+	lghi	%r5,0
+0:	mvcp	24(%r1,%r15),0(%r2),%r0
+	aghi	%r5,1
+	tm	24(%r15),0xff
+	jz	1f
+	la	%r2,1(%r2)
+	clgr	%r5,%r3
+	jl	0b
+1:	lgr	%r2,%r5
+	br	%r14
+2:	lghi	%r2,-EFAULT
+	br	%r14
+        .section __ex_table,"a"
+	.quad	0b,2b
+	.previous
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/mm/fault.c linux-post-2.6.5-rc2-20040329/arch/s390/mm/fault.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/mm/fault.c	2004-01-19 06:35:53.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/mm/fault.c	2004-03-27 11:40:46.000000000 +0000
@@ -87,12 +87,12 @@ static int __check_access_register(struc
 	if (areg == 0)
 		/* Access via access register 0 -> kernel address */
 		return 0;
-	if (regs && areg < NUM_ACRS && regs->acrs[areg] <= 1)
+	if (regs && areg < NUM_ACRS && current->thread.acrs[areg] <= 1)
 		/*
 		 * access register contains 0 -> kernel address,
 		 * access register contains 1 -> user space address
 		 */
-		return regs->acrs[areg];
+		return current->thread.acrs[areg];
 
 	/* Something unhealthy was done with the access registers... */
 	die("page fault via unknown access register", regs, error_code);
@@ -115,8 +115,10 @@ static inline int check_user_space(struc
 	 *   3: Home Segment Table Descriptor
 	 */
 	int descriptor = S390_lowcore.trans_exc_code & 3;
-	if (descriptor == 1)
+	if (descriptor == 1) {
+		save_access_regs(current->thread.acrs);
 		return __check_access_register(regs, error_code);
+	}
 	return descriptor >> 1;
 }
 
diff -purN linux-post-2.6.5-rc2-20040327/arch/s390/mm/init.c linux-post-2.6.5-rc2-20040329/arch/s390/mm/init.c
--- linux-post-2.6.5-rc2-20040327/arch/s390/mm/init.c	2004-03-02 03:01:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/s390/mm/init.c	2004-03-27 11:40:46.000000000 +0000
@@ -138,6 +138,8 @@ void __init paging_init(void)
                 }
         }
 
+	S390_lowcore.kernel_asce = pgdir_k;
+
         /* enable virtual mapping in kernel mode */
         __asm__ __volatile__("    LCTL  1,1,%0\n"
                              "    LCTL  7,7,%0\n"
@@ -223,6 +225,8 @@ void __init paging_init(void)
                 }
         }
 
+	S390_lowcore.kernel_asce = pgdir_k;
+
         /* enable virtual mapping in kernel mode */
         __asm__ __volatile__("lctlg 1,1,%0\n\t"
                              "lctlg 7,7,%0\n\t"
diff -purN linux-post-2.6.5-rc2-20040327/arch/sh/defconfig linux-post-2.6.5-rc2-20040329/arch/sh/defconfig
--- linux-post-2.6.5-rc2-20040327/arch/sh/defconfig	2004-02-13 15:19:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/sh/defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -152,7 +152,6 @@ CONFIG_BLK_DEV_IDEDISK=y
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/sparc64/defconfig linux-post-2.6.5-rc2-20040329/arch/sparc64/defconfig
--- linux-post-2.6.5-rc2-20040327/arch/sparc64/defconfig	2004-03-25 21:16:37.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/sparc64/defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -277,7 +277,6 @@ CONFIG_BLK_DEV_VIA82CXXX=m
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/sparc64/kernel/sys_sparc32.c linux-post-2.6.5-rc2-20040329/arch/sparc64/kernel/sys_sparc32.c
--- linux-post-2.6.5-rc2-20040327/arch/sparc64/kernel/sys_sparc32.c	2004-03-26 23:00:38.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/sparc64/kernel/sys_sparc32.c	2004-03-27 21:46:54.000000000 +0000
@@ -27,9 +27,6 @@
 #include <linux/slab.h>
 #include <linux/uio.h>
 #include <linux/nfs_fs.h>
-#include <linux/smb_fs.h>
-#include <linux/smb_mount.h>
-#include <linux/ncp_fs.h>
 #include <linux/quota.h>
 #include <linux/module.h>
 #include <linux/sunrpc/svc.h>
@@ -1330,208 +1327,6 @@ asmlinkage int sys32_sysfs(int option, u
 	return sys_sysfs(option, arg1, arg2);
 }
 
-struct ncp_mount_data32_v3 {
-        int version;
-        unsigned int ncp_fd;
-        compat_uid_t mounted_uid;
-        compat_pid_t wdog_pid;
-        unsigned char mounted_vol[NCP_VOLNAME_LEN + 1];
-        unsigned int time_out;
-        unsigned int retry_count;
-        unsigned int flags;
-        compat_uid_t uid;
-        compat_gid_t gid;
-        compat_mode_t file_mode;
-        compat_mode_t dir_mode;
-};
-
-struct ncp_mount_data32_v4 {
-	int version;
-	/* all members below are "long" in ABI ... i.e. 32bit on sparc32, while 64bits on sparc64 */
-	unsigned int flags;
-	unsigned int mounted_uid;
-	int wdog_pid;
-
-	unsigned int ncp_fd;
-	unsigned int time_out;
-	unsigned int retry_count;
-
-	unsigned int uid;
-	unsigned int gid;
-	unsigned int file_mode;
-	unsigned int dir_mode;
-};
-
-static void *do_ncp_super_data_conv(void *raw_data)
-{
-	switch (*(int*)raw_data) {
-		case NCP_MOUNT_VERSION:
-			{
-				struct ncp_mount_data news, *n = &news; 
-				struct ncp_mount_data32_v3 *n32 = (struct ncp_mount_data32_v3 *)raw_data;
-
-				n->version = n32->version;
-				n->ncp_fd = n32->ncp_fd;
-				n->mounted_uid = low2highuid(n32->mounted_uid);
-				n->wdog_pid = n32->wdog_pid;
-				memmove (n->mounted_vol, n32->mounted_vol, sizeof (n32->mounted_vol));
-				n->time_out = n32->time_out;
-				n->retry_count = n32->retry_count;
-				n->flags = n32->flags;
-				n->uid = low2highuid(n32->uid);
-				n->gid = low2highgid(n32->gid);
-				n->file_mode = n32->file_mode;
-				n->dir_mode = n32->dir_mode;
-				memcpy(raw_data, n, sizeof(*n)); 
-			}
-			break;
-		case NCP_MOUNT_VERSION_V4:
-			{
-				struct ncp_mount_data_v4 news, *n = &news; 
-				struct ncp_mount_data32_v4 *n32 = (struct ncp_mount_data32_v4 *)raw_data;
-
-				n->version = n32->version;
-				n->flags = n32->flags;
-				n->mounted_uid = n32->mounted_uid;
-				n->wdog_pid = n32->wdog_pid;
-				n->ncp_fd = n32->ncp_fd;
-				n->time_out = n32->time_out;
-				n->retry_count = n32->retry_count;
-				n->uid = n32->uid;
-				n->gid = n32->gid;
-				n->file_mode = n32->file_mode;
-				n->dir_mode = n32->dir_mode;
-				memcpy(raw_data, n, sizeof(*n)); 
-			}
-			break;
-		default:
-			/* do not touch unknown structures */
-			break;
-	}
-	return raw_data;
-}
-
-struct smb_mount_data32 {
-        int version;
-        compat_uid_t mounted_uid;
-        compat_uid_t uid;
-        compat_gid_t gid;
-        compat_mode_t file_mode;
-        compat_mode_t dir_mode;
-};
-
-static void *do_smb_super_data_conv(void *raw_data)
-{
-	struct smb_mount_data news, *s = &news;
-	struct smb_mount_data32 *s32 = (struct smb_mount_data32 *)raw_data;
-
-	if (s32->version != SMB_MOUNT_OLDVERSION)
-		goto out;
-	s->version = s32->version;
-	s->mounted_uid = low2highuid(s32->mounted_uid);
-	s->uid = low2highuid(s32->uid);
-	s->gid = low2highgid(s32->gid);
-	s->file_mode = s32->file_mode;
-	s->dir_mode = s32->dir_mode;
-	memcpy(raw_data, s, sizeof(struct smb_mount_data)); 
-out:
-	return raw_data;
-}
-
-static int copy_mount_stuff_to_kernel(const void *user, unsigned long *kernel)
-{
-	int i;
-	unsigned long page;
-	struct vm_area_struct *vma;
-
-	*kernel = 0;
-	if(!user)
-		return 0;
-	vma = find_vma(current->mm, (unsigned long)user);
-	if(!vma || (unsigned long)user < vma->vm_start)
-		return -EFAULT;
-	if(!(vma->vm_flags & VM_READ))
-		return -EFAULT;
-	i = vma->vm_end - (unsigned long) user;
-	if(PAGE_SIZE <= (unsigned long) i)
-		i = PAGE_SIZE - 1;
-	if(!(page = __get_free_page(GFP_KERNEL)))
-		return -ENOMEM;
-	if(copy_from_user((void *) page, user, i)) {
-		free_page(page);
-		return -EFAULT;
-	}
-	*kernel = page;
-	return 0;
-}
-
-#define SMBFS_NAME	"smbfs"
-#define NCPFS_NAME	"ncpfs"
-
-asmlinkage int sys32_mount(char *dev_name, char *dir_name, char *type, unsigned long new_flags, u32 data)
-{
-	unsigned long type_page = 0;
-	unsigned long data_page = 0;
-	unsigned long dev_page = 0;
-	unsigned long dir_page = 0;
-	int err, is_smb, is_ncp;
-
-	is_smb = is_ncp = 0;
-
-	err = copy_mount_stuff_to_kernel((const void *)type, &type_page);
-	if (err)
-		goto out;
-
-	if (type_page) {
-		is_smb = !strcmp((char *)type_page, SMBFS_NAME);
-		is_ncp = !strcmp((char *)type_page, NCPFS_NAME);
-	} else {
-		is_smb = is_ncp = 0;
-	}
-
-	err = copy_mount_stuff_to_kernel((const void *)AA(data), &data_page);
-	if (err)
-		goto type_out;
-
-	err = copy_mount_stuff_to_kernel(dev_name, &dev_page);
-	if (err)
-		goto data_out;
-
-	err = copy_mount_stuff_to_kernel(dir_name, &dir_page);
-	if (err)
-		goto dev_out;
-
-	if (!is_smb && !is_ncp) {
-		lock_kernel();
-		err = do_mount((char*)dev_page, (char*)dir_page,
-				(char*)type_page, new_flags, (char*)data_page);
-		unlock_kernel();
-	} else {
-		if (is_ncp)
-			do_ncp_super_data_conv((void *)data_page);
-		else
-			do_smb_super_data_conv((void *)data_page);
-
-		lock_kernel();
-		err = do_mount((char*)dev_page, (char*)dir_page,
-				(char*)type_page, new_flags, (char*)data_page);
-		unlock_kernel();
-	}
-	free_page(dir_page);
-
-dev_out:
-	free_page(dev_page);
-
-data_out:
-	free_page(data_page);
-
-type_out:
-	free_page(type_page);
-
-out:
-	return err;
-}
-
 struct sysinfo32 {
         s32 uptime;
         u32 loads[3];
diff -purN linux-post-2.6.5-rc2-20040327/arch/sparc64/kernel/systbls.S linux-post-2.6.5-rc2-20040329/arch/sparc64/kernel/systbls.S
--- linux-post-2.6.5-rc2-20040327/arch/sparc64/kernel/systbls.S	2003-12-29 23:09:39.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/sparc64/kernel/systbls.S	2004-03-26 19:05:27.000000000 +0000
@@ -52,7 +52,7 @@ sys_call_table32:
 /*150*/	.word sys_nis_syscall, sys_nis_syscall, sys_nis_syscall, sys_poll, sys_getdents64
 	.word compat_sys_fcntl64, sys_ni_syscall, compat_sys_statfs, compat_sys_fstatfs, sys_oldumount
 /*160*/	.word compat_sys_sched_setaffinity, compat_sys_sched_getaffinity, sys_getdomainname, sys_setdomainname, sys_nis_syscall
-	.word sys_quotactl, sys_set_tid_address, sys32_mount, sys_ustat, sys_setxattr
+	.word sys_quotactl, sys_set_tid_address, compat_sys_mount, sys_ustat, sys_setxattr
 /*170*/	.word sys_lsetxattr, sys_fsetxattr, sys_getxattr, sys_lgetxattr, sys32_getdents
 	.word sys_setsid, sys_fchdir, sys_fgetxattr, sys_listxattr, sys_llistxattr
 /*180*/	.word sys_flistxattr, sys_removexattr, sys_lremovexattr, compat_sys_sigpending, sys_ni_syscall
diff -purN linux-post-2.6.5-rc2-20040327/arch/sparc64/mm/init.c linux-post-2.6.5-rc2-20040329/arch/sparc64/mm/init.c
--- linux-post-2.6.5-rc2-20040327/arch/sparc64/mm/init.c	2004-03-01 14:30:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/sparc64/mm/init.c	2004-03-28 09:19:29.000000000 +0000
@@ -104,7 +104,7 @@ void check_pgt_cache(void)
                                 if (page2)
                                         page2->lru.next = page->lru.next;
                                 else
-                                        (struct page *)pgd_quicklist = page->lru.next;
+                                        pgd_quicklist = (void *) page->lru.next;
                                 pgd_cache_size -= 2;
                                 __free_page(page);
                                 if (page2)
diff -purN linux-post-2.6.5-rc2-20040327/arch/x86_64/defconfig linux-post-2.6.5-rc2-20040329/arch/x86_64/defconfig
--- linux-post-2.6.5-rc2-20040327/arch/x86_64/defconfig	2004-03-20 01:36:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/x86_64/defconfig	2004-03-23 18:18:46.000000000 +0000
@@ -235,7 +235,6 @@ CONFIG_BLK_DEV_PIIX=y
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040327/arch/x86_64/ia32/ia32entry.S linux-post-2.6.5-rc2-20040329/arch/x86_64/ia32/ia32entry.S
--- linux-post-2.6.5-rc2-20040327/arch/x86_64/ia32/ia32entry.S	2004-03-08 18:50:19.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/x86_64/ia32/ia32entry.S	2004-03-26 19:05:27.000000000 +0000
@@ -326,7 +326,7 @@ ia32_sys_call_table:
 	.quad sys_stat
 	.quad sys32_lseek
 	.quad sys_getpid		/* 20 */
-	.quad sys_mount	/* mount  */
+	.quad compat_sys_mount	/* mount  */
 	.quad sys_oldumount	/* old_umount  */
 	.quad sys_setuid16
 	.quad sys_getuid16
diff -purN linux-post-2.6.5-rc2-20040327/arch/x86_64/ia32/sys_ia32.c linux-post-2.6.5-rc2-20040329/arch/x86_64/ia32/sys_ia32.c
--- linux-post-2.6.5-rc2-20040327/arch/x86_64/ia32/sys_ia32.c	2004-03-08 14:23:47.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/arch/x86_64/ia32/sys_ia32.c	2004-03-27 21:46:54.000000000 +0000
@@ -40,9 +40,6 @@
 #include <linux/slab.h>
 #include <linux/uio.h>
 #include <linux/nfs_fs.h>
-#include <linux/smb_fs.h>
-#include <linux/smb_mount.h>
-#include <linux/ncp_fs.h>
 #include <linux/quota.h>
 #include <linux/module.h>
 #include <linux/sunrpc/svc.h>
@@ -512,7 +509,7 @@ filldir32 (void *__buf, const char *name
 {
 	struct linux32_dirent * dirent;
 	struct getdents32_callback * buf = (struct getdents32_callback *) __buf;
-	int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 1, 4);
+	int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 2, 4);
 
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
@@ -526,6 +523,7 @@ filldir32 (void *__buf, const char *name
 	put_user(reclen, &dirent->d_reclen);
 	copy_to_user(dirent->d_name, name, namlen);
 	put_user(0, dirent->d_name + namlen);
+	put_user(d_type, (char *)dirent + reclen - 1); 
 	dirent = ((void *)dirent) + reclen;
 	buf->current_dir = dirent;
 	buf->count -= reclen;
@@ -874,39 +872,6 @@ sys32_sysfs(int option, u32 arg1, u32 ar
 	return sys_sysfs(option, arg1, arg2);
 }
 
-static char *badfs[] = {
-	"smbfs", "ncpfs", NULL
-}; 	
-
-static int checktype(char *user_type) 
-{ 
-	int err = 0; 
-	char **s,*kernel_type = getname(user_type); 
-	if (!kernel_type || IS_ERR(kernel_type)) 
-		return -EFAULT; 
-	for (s = badfs; *s; ++s) 
-		if (!strcmp(kernel_type, *s)) { 
-			printk(KERN_ERR "mount32: unsupported fs `%s' -- use 64bit mount\n", *s); 
-			err = -EINVAL; 
-			break;
-		} 	
-	putname(user_type); 
-	return err;
-} 
-
-asmlinkage long
-sys32_mount(char *dev_name, char *dir_name, char *type,
-	    unsigned long new_flags, u32 data)
-{
-	int err;
-	if(!capable(CAP_SYS_ADMIN))
-		return -EPERM;
-	err = checktype(type);
-	if (err)
-		return err;
-	return sys_mount(dev_name, dir_name, type, new_flags, (void *)AA(data));
-}
-
 struct sysinfo32 {
         s32 uptime;
         u32 loads[3];
diff -purN linux-post-2.6.5-rc2-20040327/drivers/char/cyclades.c linux-post-2.6.5-rc2-20040329/drivers/char/cyclades.c
--- linux-post-2.6.5-rc2-20040327/drivers/char/cyclades.c	2004-03-02 03:01:44.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/char/cyclades.c	2004-03-27 05:30:45.000000000 +0000
@@ -2679,7 +2679,8 @@ cy_wait_until_sent(struct tty_struct *tt
   struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
   unsigned char *base_addr;
   int card,chip,channel,index;
-  unsigned long orig_jiffies, char_time;
+  unsigned long orig_jiffies;
+  signed long char_time;
 	
     if (serial_paranoia_check(info, tty->name, "cy_wait_until_sent"))
 	return;
@@ -2699,7 +2700,7 @@ cy_wait_until_sent(struct tty_struct *tt
      */
     char_time = (info->timeout - HZ/50) / info->xmit_fifo_size;
     char_time = char_time / 5;
-    if (char_time == 0)
+    if (char_time <= 0)
 	char_time = 1;
     if (timeout < 0)
 	timeout = 0;
diff -purN linux-post-2.6.5-rc2-20040327/drivers/char/efirtc.c linux-post-2.6.5-rc2-20040329/drivers/char/efirtc.c
--- linux-post-2.6.5-rc2-20040327/drivers/char/efirtc.c	2004-01-19 23:38:04.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/char/efirtc.c	2004-03-27 11:43:20.000000000 +0000
@@ -6,13 +6,13 @@
  *
  * Based on skeleton from the drivers/char/rtc.c driver by P. Gortmaker
  *
- * This code provides a architected & portable interface to the real time 
+ * This code provides an architected & portable interface to the real time
  * clock by using EFI instead of direct bit fiddling. The functionalities are 
  * quite different from the rtc.c driver. The only way to talk to the device 
  * is by using ioctl(). There is a /proc interface which provides the raw 
  * information.
  *
- * Please note that we have kept the API as close as possible from the 
+ * Please note that we have kept the API as close as possible to the
  * legacy RTC. The standard /sbin/hwclock program should work normally 
  * when used to get/set the time.
  *
@@ -297,7 +297,7 @@ static struct miscdevice efi_rtc_dev=
 };
 
 /*
- *	We export RAW EFI information to /proc/efirtc
+ *	We export RAW EFI information to /proc/driver/efirtc
  */
 static int
 efi_rtc_get_status(char *buf)
@@ -308,6 +308,10 @@ efi_rtc_get_status(char *buf)
 	efi_bool_t	enabled, pending;	
 	unsigned long	flags;
 
+	memset(&eft, 0, sizeof(eft));
+	memset(&alm, 0, sizeof(alm));
+	memset(&cap, 0, sizeof(cap));
+
 	spin_lock_irqsave(&efi_rtc_lock, flags);
 
 	efi.get_time(&eft, &cap);
diff -purN linux-post-2.6.5-rc2-20040327/drivers/char/mem.c linux-post-2.6.5-rc2-20040329/drivers/char/mem.c
--- linux-post-2.6.5-rc2-20040327/drivers/char/mem.c	2004-03-16 10:29:47.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/char/mem.c	2004-03-27 11:40:45.000000000 +0000
@@ -311,7 +311,7 @@ static ssize_t write_kmem(struct file * 
 				len = PAGE_SIZE;
 			if (len) {
 				written = copy_from_user(kbuf, buf, len);
-				if (written != len) {
+				if (written) {
 					ssize_t ret;
 
 					free_page((unsigned long)kbuf);
diff -purN linux-post-2.6.5-rc2-20040327/drivers/ide/Kconfig linux-post-2.6.5-rc2-20040329/drivers/ide/Kconfig
--- linux-post-2.6.5-rc2-20040327/drivers/ide/Kconfig	2004-03-16 20:49:40.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/ide/Kconfig	2004-03-23 18:18:41.000000000 +0000
@@ -1114,9 +1114,6 @@ config IDEDMA_IVB
 config IDEDMA_AUTO
 	def_bool IDEDMA_PCI_AUTO || BLK_DEV_IDEDMA_PMAC_AUTO || IDEDMA_ICS_AUTO
 
-config DMA_NONPCI
-	def_bool BLK_DEV_TIVO
-
 endif
 
 config BLK_DEV_HD_ONLY
diff -purN linux-post-2.6.5-rc2-20040327/drivers/ide/ide-iops.c linux-post-2.6.5-rc2-20040329/drivers/ide/ide-iops.c
--- linux-post-2.6.5-rc2-20040327/drivers/ide/ide-iops.c	2004-02-17 14:59:43.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/ide/ide-iops.c	2004-03-23 18:18:46.000000000 +0000
@@ -829,10 +829,10 @@ int ide_config_drive_speed (ide_drive_t 
 //	while (HWGROUP(drive)->busy)
 //		ide_delay_50ms();
 
-#if defined(CONFIG_BLK_DEV_IDEDMA) && !defined(CONFIG_DMA_NONPCI)
+#ifdef CONFIG_BLK_DEV_IDEDMA
 	if (hwif->ide_dma_check)	 /* check if host supports DMA */
 		hwif->ide_dma_host_off(drive);
-#endif /* (CONFIG_BLK_DEV_IDEDMA) && !(CONFIG_DMA_NONPCI) */
+#endif
 
 	/*
 	 * Don't use ide_wait_cmd here - it will
@@ -906,14 +906,12 @@ int ide_config_drive_speed (ide_drive_t 
 	drive->id->dma_mword &= ~0x0F00;
 	drive->id->dma_1word &= ~0x0F00;
 
-#if defined(CONFIG_BLK_DEV_IDEDMA) && !defined(CONFIG_DMA_NONPCI)
-	if (speed >= XFER_SW_DMA_0) {
+#ifdef CONFIG_BLK_DEV_IDEDMA
+	if (speed >= XFER_SW_DMA_0)
 		hwif->ide_dma_host_on(drive);
-	} else {
-		if (hwif->ide_dma_check) /* check if host supports DMA */
-			hwif->ide_dma_off_quietly(drive);
-	}
-#endif /* (CONFIG_BLK_DEV_IDEDMA) && !(CONFIG_DMA_NONPCI) */
+	else if (hwif->ide_dma_check)	/* check if host supports DMA */
+		hwif->ide_dma_off_quietly(drive);
+#endif
 
 	switch(speed) {
 		case XFER_UDMA_7:   drive->id->dma_ultra |= 0x8080; break;
diff -purN linux-post-2.6.5-rc2-20040327/drivers/ide/ide-pnp.c linux-post-2.6.5-rc2-20040329/drivers/ide/ide-pnp.c
--- linux-post-2.6.5-rc2-20040327/drivers/ide/ide-pnp.c	2003-06-25 23:30:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/ide/ide-pnp.c	2004-03-23 18:26:40.000000000 +0000
@@ -64,7 +64,6 @@ static int idepnp_probe(struct pnp_dev *
 	if (index != -1) {
 	    	printk(KERN_INFO "ide%d: generic PnP IDE interface\n", index);
 		pnp_set_drvdata(dev,hwif);
-		hwif->pnp_dev = dev;
 		return 0;
 	}
 
diff -purN linux-post-2.6.5-rc2-20040327/drivers/ide/ide.c linux-post-2.6.5-rc2-20040329/drivers/ide/ide.c
--- linux-post-2.6.5-rc2-20040327/drivers/ide/ide.c	2004-03-16 22:03:51.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/ide/ide.c	2004-03-23 18:18:46.000000000 +0000
@@ -482,23 +482,14 @@ ide_proc_entry_t generic_subdriver_entri
 static struct resource* hwif_request_region(ide_hwif_t *hwif,
 					    unsigned long addr, int num)
 {
-	struct resource *res;
-
-	if (hwif->mmio)
-		res = request_mem_region(addr, num, hwif->name);
-	else
-		res = request_region(addr, num, hwif->name);
+	struct resource *res = request_region(addr, num, hwif->name);
 
 	if (!res)
-		printk(KERN_ERR "%s: %s resource 0x%lX-0x%lX not free.\n",
-				hwif->name, hwif->mmio ? "MMIO" : "I/O",
-				addr, addr+num-1);
+		printk(KERN_ERR "%s: I/O resource 0x%lX-0x%lX not free.\n",
+				hwif->name, addr, addr+num-1);
 	return res;
 }
 
-#define hwif_release_region(addr, num) \
-	((hwif->mmio) ? release_mem_region((addr),(num)) : release_region((addr),(num)))
-
 /**
  *	ide_hwif_request_regions - request resources for IDE
  *	@hwif: interface to use
@@ -515,6 +506,7 @@ int ide_hwif_request_regions(ide_hwif_t 
 
 	if (hwif->mmio == 2)
 		return 0;
+	BUG_ON(hwif->mmio == 1);
 	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
 	if (addr && !hwif_request_region(hwif, addr, 1))
 		goto control_region_busy;
@@ -530,7 +522,7 @@ int ide_hwif_request_regions(ide_hwif_t 
 		addr = hwif->io_ports[i];
 		if (!hwif_request_region(hwif, addr, 1)) {
 			while (--i)
-				hwif_release_region(addr, 1);
+				release_region(addr, 1);
 			goto data_region_busy;
 		}
 	}
@@ -539,7 +531,7 @@ int ide_hwif_request_regions(ide_hwif_t 
 data_region_busy:
 	addr = hwif->io_ports[IDE_CONTROL_OFFSET];
 	if (addr)
-		hwif_release_region(addr, 1);
+		release_region(addr, 1);
 control_region_busy:
 	/* If any errors are return, we drop the hwif interface. */
 	return -EBUSY;
@@ -565,14 +557,14 @@ void ide_hwif_release_regions(ide_hwif_t
 	if (hwif->mmio == 2)
 		return;
 	if (hwif->io_ports[IDE_CONTROL_OFFSET])
-		hwif_release_region(hwif->io_ports[IDE_CONTROL_OFFSET], 1);
+		release_region(hwif->io_ports[IDE_CONTROL_OFFSET], 1);
 	if (hwif->straight8) {
-		hwif_release_region(hwif->io_ports[IDE_DATA_OFFSET], 8);
+		release_region(hwif->io_ports[IDE_DATA_OFFSET], 8);
 		return;
 	}
 	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
 		if (hwif->io_ports[i])
-			hwif_release_region(hwif->io_ports[i], 1);
+			release_region(hwif->io_ports[i], 1);
 }
 
 EXPORT_SYMBOL(ide_hwif_release_regions);
@@ -745,7 +737,6 @@ void ide_unregister (unsigned int index)
 	unregister_blkdev(hwif->major, hwif->name);
 	spin_lock_irq(&ide_lock);
 
-#if !defined(CONFIG_DMA_NONPCI)
 	if (hwif->dma_base) {
 		(void) ide_release_dma(hwif);
 
@@ -757,7 +748,7 @@ void ide_unregister (unsigned int index)
 		hwif->dma_vendor3 = 0;
 		hwif->dma_prdtable = 0;
 	}
-#endif /* !(CONFIG_DMA_NONPCI) */
+
 	old_hwif			= *hwif;
 	init_hwif_data(index);	/* restore hwif data to pristine status */
 	hwif->hwgroup			= old_hwif.hwgroup;
@@ -2432,10 +2423,8 @@ void cleanup_module (void)
 
 	for (index = 0; index < MAX_HWIFS; ++index) {
 		ide_unregister(index);
-#if !defined(CONFIG_DMA_NONPCI)
 		if (ide_hwifs[index].dma_base)
 			(void) ide_release_dma(&ide_hwifs[index]);
-#endif /* !(CONFIG_DMA_NONPCI) */
 	}
 
 #ifdef CONFIG_PROC_FS
diff -purN linux-post-2.6.5-rc2-20040327/drivers/mtd/cmdlinepart.c linux-post-2.6.5-rc2-20040329/drivers/mtd/cmdlinepart.c
--- linux-post-2.6.5-rc2-20040327/drivers/mtd/cmdlinepart.c	2003-05-28 15:01:08.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/mtd/cmdlinepart.c	2004-03-27 11:43:44.000000000 +0000
@@ -28,7 +28,6 @@
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
-#include <asm/setup.h>
 #include <linux/bootmem.h>
 
 /* error message prefix */
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd.c linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd.c	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd.c	2004-03-27 11:40:45.000000000 +0000
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision: 1.133 $
+ * $Revision: 1.136 $
  */
 
 #include <linux/config.h>
@@ -224,7 +224,8 @@ dasd_state_basic_to_ready(struct dasd_de
 		return rc;
 	dasd_setup_queue(device);
 	device->state = DASD_STATE_READY;
-	dasd_scan_partitions(device);
+	if (dasd_scan_partitions(device) != 0)
+		device->state = DASD_STATE_BASIC;
 	return 0;
 }
 
@@ -687,7 +688,10 @@ dasd_term_IO(struct dasd_ccw_req * cqr)
 		rc = ccw_device_clear(device->cdev, (long) cqr);
 		switch (rc) {
 		case 0:	/* termination successful */
-			cqr->status = DASD_CQR_FAILED;
+			if (cqr->retries > 0)
+				cqr->status = DASD_CQR_QUEUED;
+			else
+				cqr->status = DASD_CQR_FAILED;
 			cqr->stopclk = get_clock();
 			break;
 		case -ENODEV:
@@ -779,7 +783,7 @@ dasd_timeout_device(unsigned long ptr)
 
 	device = (struct dasd_device *) ptr;
 	spin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);
-	/* re-activate first request in queue */
+	/* re-activate request queue */
         device->stopped &= ~DASD_STOPPED_PENDING;
 	spin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);
 	dasd_schedule_bh(device);
@@ -827,12 +831,25 @@ do_state_change_pending(void *data)
 		struct dasd_device *device;
 	} *p;
 	struct dasd_device *device;
+	struct dasd_ccw_req *cqr;
+	struct list_head *l, *n;
+	unsigned long flags;
 
 	p = data;
 	device = p->device;
 	DBF_EVENT(DBF_NOTICE, "State change Interrupt for bus_id %s",
 		  device->cdev->dev.bus_id);
 	device->stopped &= ~DASD_STOPPED_PENDING;
+
+        /* restart all 'running' IO on queue */
+	spin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);
+	list_for_each_safe(l, n, &device->ccw_queue) {
+		cqr = list_entry(l, struct dasd_ccw_req, list);
+                if (cqr->status == DASD_CQR_IN_IO)
+                        cqr->status = DASD_CQR_QUEUED;
+        }
+	spin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);
+	dasd_set_timer (device, 0);
 	dasd_schedule_bh(device);
 	dasd_put_device(device);
 	kfree(p);
@@ -847,7 +864,8 @@ dasd_handle_killed_request(struct ccw_de
 	cqr = (struct dasd_ccw_req *) intparm;
 	if (cqr->status != DASD_CQR_IN_IO) {
 		MESSAGE(KERN_DEBUG,
-			"invalid status: bus_id %s, status %02x",
+			"invalid status in handle_killed_request: "
+			"bus_id %s, status %02x",
 			cdev->dev.bus_id, cqr->status);
 		return;
 	}
@@ -1142,7 +1160,8 @@ __dasd_process_blk_queue(struct dasd_dev
 	       elv_next_request(queue) &&
 		nr_queued < DASD_CHANQ_MAX_SIZE) {
 		req = elv_next_request(queue);
-		if (device->ro_flag && rq_data_dir(req) == WRITE) {
+		if (test_bit(DASD_FLAG_RO, &device->flags) &&
+		    rq_data_dir(req) == WRITE) {
 			DBF_EVENT(DBF_ERR,
 				  "(%s) Rejecting write request %p",
 				  device->cdev->dev.bus_id,
@@ -1186,13 +1205,11 @@ static inline void
 __dasd_check_expire(struct dasd_device * device)
 {
 	struct dasd_ccw_req *cqr;
-	unsigned long long now;
 
 	if (list_empty(&device->ccw_queue))
 		return;
 	cqr = list_entry(device->ccw_queue.next, struct dasd_ccw_req, list);
 	if (cqr->status == DASD_CQR_IN_IO && cqr->expires != 0) {
-		now = get_clock();
 		if (time_after_eq(jiffies, cqr->expires + cqr->starttime)) {
 			if (device->discipline->term_IO(cqr) != 0)
 				/* Hmpf, try again in 1/100 sec */
@@ -1517,7 +1534,8 @@ dasd_sleep_on_immediatly(struct dasd_ccw
  * terminated if it is currently in i/o.
  * Returns 1 if the request has been terminated.
  */
-int dasd_cancel_req(struct dasd_ccw_req *cqr)
+int
+dasd_cancel_req(struct dasd_ccw_req *cqr)
 {
 	struct dasd_device *device = cqr->device;
 	unsigned long flags;
@@ -1655,18 +1673,13 @@ dasd_open(struct inode *inp, struct file
 {
 	struct gendisk *disk = inp->i_bdev->bd_disk;
 	struct dasd_device *device = disk->private_data;
-	int old_count, rc;
+	int rc;
 
-	/*
-	 * We use a negative value in open_count to indicate that
-	 * the device must not be used.
-	 */
-	do {
-		old_count = atomic_read(&device->open_count);
-		if (old_count < 0)
-			return -ENODEV;
-	} while (atomic_compare_and_swap(old_count, old_count + 1,
-					 &device->open_count));
+        atomic_inc(&device->open_count);
+	if (test_bit(DASD_FLAG_OFFLINE, &device->flags)) {
+		rc = -ENODEV;
+		goto unlock;
+	}
 
 	if (!try_module_get(device->discipline->owner)) {
 		rc = -EINVAL;
@@ -1681,7 +1694,6 @@ dasd_open(struct inode *inp, struct file
 		goto out;
 	}
 
-	rc = -ENODEV;
 	if (device->state < DASD_STATE_BASIC) {
 		DBF_DEV_EVENT(DBF_ERR, device, " %s",
 			      " Cannot open unrecognized device");
@@ -1704,12 +1716,6 @@ dasd_release(struct inode *inp, struct f
 	struct gendisk *disk = inp->i_bdev->bd_disk;
 	struct dasd_device *device = disk->private_data;
 
-	if (device->state < DASD_STATE_BASIC) {
-		DBF_DEV_EVENT(DBF_ERR, device, " %s",
-			      " Cannot release unrecognized device");
-		return -EINVAL;
-	}
-
 	atomic_dec(&device->open_count);
 	module_put(device->discipline->owner);
 	return 0;
@@ -1773,17 +1779,21 @@ dasd_generic_remove (struct ccw_device *
 
 	dasd_remove_sysfs_files(cdev);
 	device = dasd_device_from_cdev(cdev);
-	if (!IS_ERR(device)) {
-		/*
-		 * This device is removed unconditionally. Set open_count
-		 * to -1 to prevent dasd_open from opening it while it is
-		 * no quite down yet.
-		 */
-		atomic_set(&device->open_count,-1);
-		dasd_set_target_state(device, DASD_STATE_NEW);
-		/* dasd_delete_device destroys the device reference. */
-		dasd_delete_device(device);
+	if (IS_ERR(device))
+		return;
+	if (test_and_set_bit(DASD_FLAG_OFFLINE, &device->flags)) {
+		/* Already doing offline processing */
+		dasd_put_device(device);
+		return;
 	}
+	/*
+	 * This device is removed unconditionally. Set offline
+	 * flag to prevent dasd_open from opening it while it is
+	 * no quite down yet.
+	 */
+	dasd_set_target_state(device, DASD_STATE_NEW);
+	/* dasd_delete_device destroys the device reference. */
+	dasd_delete_device(device);
 }
 
 /* activate a device. This is called from dasd_{eckd,fba}_probe() when either
@@ -1801,7 +1811,7 @@ dasd_generic_set_online (struct ccw_devi
 	if (IS_ERR(device))
 		return PTR_ERR(device);
 
-	if (device->use_diag_flag) {
+	if (test_bit(DASD_FLAG_USE_DIAG, &device->flags)) {
 	  	if (!dasd_diag_discipline_pointer) {
 		        printk (KERN_WARNING
 				"dasd_generic couldn't online device %s "
@@ -1849,18 +1859,28 @@ int
 dasd_generic_set_offline (struct ccw_device *cdev)
 {
 	struct dasd_device *device;
+	int max_count;
 
 	device = dasd_device_from_cdev(cdev);
+	if (IS_ERR(device))
+		return PTR_ERR(device);
+	if (test_and_set_bit(DASD_FLAG_OFFLINE, &device->flags)) {
+		/* Already doing offline processing */
+		dasd_put_device(device);
+		return 0;
+	}
 	/*
-	 * We must make sure that this device is currently not in use
-	 * (current open_count == 0 ). We set open_count to -1 to indicate
-	 * that from now on set_offline is in progress and the device must
-	 * not be used otherwise.
+	 * We must make sure that this device is currently not in use.
+	 * The open_count is increased for every opener, that includes
+	 * the blkdev_get in dasd_scan_partitions. We are only interested
+	 * in the other openers.
 	 */
-	if (atomic_compare_and_swap(0, -1, &device->open_count)) {
+	max_count = device->bdev ? 1 : 0;
+	if (atomic_read(&device->open_count) > max_count) {
 		printk (KERN_WARNING "Can't offline dasd device with open"
 			" count = %i.\n",
 			atomic_read(&device->open_count));
+		clear_bit(DASD_FLAG_OFFLINE, &device->flags);
 		dasd_put_device(device);
 		return -EBUSY;
 	}
@@ -1890,7 +1910,7 @@ dasd_generic_notify(struct ccw_device *c
 		if (device->state < DASD_STATE_BASIC)
 			break;
 		/* Device is active. We want to keep it. */
-		if (device->disconnect_error_flag) {
+		if (test_bit(DASD_FLAG_DSC_ERROR, &device->flags)) {
 			list_for_each_entry(cqr, &device->ccw_queue, list)
 				if (cqr->status == DASD_CQR_IN_IO)
 					cqr->status = DASD_CQR_FAILED;
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_3990_erp.c linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_3990_erp.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_3990_erp.c	2004-02-26 11:21:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_3990_erp.c	2004-03-27 11:40:45.000000000 +0000
@@ -5,7 +5,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000, 2001
  *
- * $Revision: 1.27 $
+ * $Revision: 1.28 $
  */
 
 #include <linux/timer.h>
@@ -229,7 +229,7 @@ dasd_3990_erp_block_queue(struct dasd_cc
 	struct dasd_device *device = erp->device;
 
 	DEV_MESSAGE(KERN_INFO, device,
-		    "blocking request queue for %is", expires);
+		    "blocking request queue for %is", expires/HZ);
 
 	device->stopped |= DASD_STOPPED_PENDING;
 	erp->status = DASD_CQR_QUEUED;
@@ -2623,7 +2623,7 @@ dasd_3990_erp_action(struct dasd_ccw_req
 
 #ifdef ERP_DEBUG
 	/* print current erp_chain */
-	DEV_MESSAGE(KERN_DEBUG, device, "%s",
+	DEV_MESSAGE(KERN_ERR, device, "%s",
 		    "ERP chain at BEGINNING of ERP-ACTION");
 	{
 		struct dasd_ccw_req *temp_erp = NULL;
@@ -2631,9 +2631,10 @@ dasd_3990_erp_action(struct dasd_ccw_req
 		for (temp_erp = cqr;
 		     temp_erp != NULL; temp_erp = temp_erp->refers) {
 
-			DEV_MESSAGE(KERN_DEBUG, device,
-				    "	   erp %p refers to %p",
-				    temp_erp, temp_erp->refers);
+			DEV_MESSAGE(KERN_ERR, device,
+				    "   erp %p (%02x) refers to %p",
+				    temp_erp, temp_erp->status,
+				    temp_erp->refers);
 		}
 	}
 #endif				/* ERP_DEBUG */
@@ -2675,15 +2676,16 @@ dasd_3990_erp_action(struct dasd_ccw_req
 
 #ifdef ERP_DEBUG
 	/* print current erp_chain */
-	DEV_MESSAGE(KERN_DEBUG, device, "%s", "ERP chain at END of ERP-ACTION");
+	DEV_MESSAGE(KERN_ERR, device, "%s", "ERP chain at END of ERP-ACTION");
 	{
 		struct dasd_ccw_req *temp_erp = NULL;
 		for (temp_erp = erp;
 		     temp_erp != NULL; temp_erp = temp_erp->refers) {
 
-			DEV_MESSAGE(KERN_DEBUG, device,
-				    "	   erp %p refers to %p",
-				    temp_erp, temp_erp->refers);
+			DEV_MESSAGE(KERN_ERR, device,
+				    "   erp %p (%02x) refers to %p",
+				    temp_erp, temp_erp->status,
+				    temp_erp->refers);
 		}
 	}
 #endif				/* ERP_DEBUG */
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_devmap.c linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_devmap.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_devmap.c	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_devmap.c	2004-03-27 11:40:45.000000000 +0000
@@ -11,7 +11,7 @@
  * functions may not be called from interrupt context. In particular
  * dasd_get_device is a no-no from interrupt context.
  *
- * $Revision: 1.26 $
+ * $Revision: 1.27 $
  */
 
 #include <linux/config.h>
@@ -466,10 +466,14 @@ dasd_create_device(struct ccw_device *cd
 	if (!devmap->device) {
 		devmap->device = device;
 		device->devindex = devmap->devindex;
-		device->ro_flag = 
-			(devmap->features & DASD_FEATURE_READONLY) != 0;
-		device->use_diag_flag = 
-			(devmap->features & DASD_FEATURE_USEDIAG) != 0;
+		if (devmap->features & DASD_FEATURE_READONLY)
+			set_bit(DASD_FLAG_RO, &device->flags);
+		else
+			clear_bit(DASD_FLAG_RO, &device->flags);
+		if (devmap->features & DASD_FEATURE_USEDIAG)
+			set_bit(DASD_FLAG_USE_DIAG, &device->flags);
+		else
+			clear_bit(DASD_FLAG_USE_DIAG, &device->flags);
 		get_device(&cdev->dev);
 		device->cdev = cdev;
 		rc = 0;
@@ -596,7 +600,10 @@ dasd_ro_store(struct device *dev, const 
 	if (devmap->device) {
 		if (devmap->device->gdp)
 			set_disk_ro(devmap->device->gdp, ro_flag);
-		devmap->device->ro_flag = ro_flag;
+		if (ro_flag)
+			set_bit(DASD_FLAG_RO, &devmap->device->flags);
+		else
+			clear_bit(DASD_FLAG_RO, &devmap->device->flags);
 	}
 	spin_unlock(&dasd_devmap_lock);
 	return count;
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_eckd.c linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_eckd.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_eckd.c	2004-03-02 03:01:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_eckd.c	2004-03-27 11:40:45.000000000 +0000
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.51 $
+ * $Revision: 1.53 $
  */
 
 #include <linux/config.h>
@@ -1131,7 +1131,7 @@ dasd_eckd_release(struct block_device *b
 	cqr->cpaddr->cda = (__u32)(addr_t) cqr->data;
 	cqr->device = device;
 	cqr->retries = 0;
-	cqr->expires = 10 * HZ;
+	cqr->expires = 2 * HZ;
 	cqr->buildclk = get_clock();
 	cqr->status = DASD_CQR_FILLED;
 
@@ -1174,7 +1174,7 @@ dasd_eckd_reserve(struct block_device *b
 	cqr->cpaddr->cda = (__u32)(addr_t) cqr->data;
 	cqr->device = device;
 	cqr->retries = 0;
-	cqr->expires = 10 * HZ;
+	cqr->expires = 2 * HZ;
 	cqr->buildclk = get_clock();
 	cqr->status = DASD_CQR_FILLED;
 
@@ -1216,7 +1216,7 @@ dasd_eckd_steal_lock(struct block_device
 	cqr->cpaddr->cda = (__u32)(addr_t) cqr->data;
 	cqr->device = device;
 	cqr->retries = 0;
-	cqr->expires = 10 * HZ;
+	cqr->expires = 2 * HZ;
 	cqr->buildclk = get_clock();
 	cqr->status = DASD_CQR_FILLED;
 
@@ -1274,6 +1274,7 @@ dasd_eckd_performance(struct block_devic
 	stats = (struct dasd_rssd_perf_stats_t *) (prssdp + 1);
 	memset(stats, 0, sizeof (struct dasd_rssd_perf_stats_t));
 
+	ccw++;
 	ccw->cmd_code = DASD_ECKD_CCW_RSSD;
 	ccw->count = sizeof (struct dasd_rssd_perf_stats_t);
 	ccw->cda = (__u32)(addr_t) stats;
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_genhd.c linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_genhd.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_genhd.c	2004-02-26 11:21:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_genhd.c	2004-03-27 11:40:45.000000000 +0000
@@ -9,7 +9,7 @@
  *
  * gendisk related functions for the dasd driver.
  *
- * $Revision: 1.44 $
+ * $Revision: 1.46 $
  */
 
 #include <linux/config.h>
@@ -71,7 +71,7 @@ dasd_gendisk_alloc(struct dasd_device *d
 
  	sprintf(gdp->devfs_name, "dasd/%s", device->cdev->dev.bus_id);
 
-	if (device->ro_flag)
+	if (test_bit(DASD_FLAG_RO, &device->flags))
 		set_disk_ro(gdp, 1);
 	gdp->private_data = device;
 	gdp->queue = device->request_queue;
@@ -96,22 +96,33 @@ dasd_gendisk_free(struct dasd_device *de
 /*
  * Trigger a partition detection.
  */
-void
+int
 dasd_scan_partitions(struct dasd_device * device)
 {
 	struct block_device *bdev;
 
 	/* Make the disk known. */
 	set_capacity(device->gdp, device->blocks << device->s2b_shift);
-	/* See fs/partition/check.c:register_disk,rescan_partitions */
 	bdev = bdget_disk(device->gdp, 0);
-	if (bdev) {
-		if (blkdev_get(bdev, FMODE_READ, 1) >= 0) {
-			/* Can't call rescan_partitions directly. Use ioctl. */
-			ioctl_by_bdev(bdev, BLKRRPART, 0);
-			blkdev_put(bdev);
-		}
-	}
+	if (!bdev || blkdev_get(bdev, FMODE_READ, 1) < 0)
+		return -ENODEV;
+	/*
+	 * See fs/partition/check.c:register_disk,rescan_partitions
+	 * Can't call rescan_partitions directly. Use ioctl.
+	 */
+	ioctl_by_bdev(bdev, BLKRRPART, 0);
+	/*
+	 * Since the matching blkdev_put call to the blkdev_get in
+	 * this function is not called before dasd_destroy_partitions
+	 * the offline open_count limit needs to be increased from
+	 * 0 to 1. This is done by setting device->bdev (see
+	 * dasd_generic_set_offline). As long as the partition
+	 * detection is running no offline should be allowed. That
+	 * is why the assignment to device->bdev is done AFTER
+	 * the BLKRRPART ioctl.
+	 */
+	device->bdev = bdev;
+	return 0;
 }
 
 /*
@@ -121,13 +132,32 @@ dasd_scan_partitions(struct dasd_device 
 void
 dasd_destroy_partitions(struct dasd_device * device)
 {
-	int p;
+	/* The two structs have 168/176 byte on 31/64 bit. */
+	struct blkpg_partition bpart;
+	struct blkpg_ioctl_arg barg;
+	struct block_device *bdev;
+
+	/*
+	 * Get the bdev pointer from the device structure and clear
+	 * device->bdev to lower the offline open_count limit again.
+	 */
+	bdev = device->bdev;
+	device->bdev = 0;
+
+	/*
+	 * See fs/partition/check.c:delete_partition
+	 * Can't call delete_partitions directly. Use ioctl.
+	 * The ioctl also does locking and invalidation.
+	 */
+	memset(&bpart, sizeof(struct blkpg_partition), 0);
+	memset(&barg, sizeof(struct blkpg_ioctl_arg), 0);
+	barg.data = &bpart;
+	for (bpart.pno = device->gdp->minors - 1; bpart.pno > 0; bpart.pno--)
+		ioctl_by_bdev(bdev, BLKPG_DEL_PARTITION, (unsigned long) &barg);
 
-	for (p = device->gdp->minors - 1; p > 0; p--) {
-		invalidate_partition(device->gdp, p);
-		delete_partition(device->gdp, p);
-	}
 	invalidate_partition(device->gdp, 0);
+	/* Matching blkdev_put to the blkdev_get in dasd_scan_partitions. */
+	blkdev_put(bdev);
 	set_capacity(device->gdp, 0);
 }
 
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_int.h linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_int.h
--- linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_int.h	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_int.h	2004-03-27 11:40:45.000000000 +0000
@@ -6,7 +6,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.55 $
+ * $Revision: 1.56 $
  */
 
 #ifndef DASD_INT_H
@@ -268,14 +268,12 @@ struct dasd_device {
 	struct gendisk *gdp;
 	request_queue_t *request_queue;
 	spinlock_t request_queue_lock;
+	struct block_device *bdev;
         unsigned int devindex;
 	unsigned long blocks;		/* size of volume in blocks */
 	unsigned int bp_block;		/* bytes per block */
 	unsigned int s2b_shift;		/* log2 (bp_block/512) */
-	int ro_flag;			/* read-only flag */
-	int use_diag_flag;		/* diag allowed flag */
-	int disconnect_error_flag;	/* return -EIO when disconnected */
-
+	unsigned long flags;		/* per device flags */
 
 	/* Device discipline stuff. */
 	struct dasd_discipline *discipline;
@@ -318,6 +316,11 @@ struct dasd_device {
 #define DASD_STOPPED_DC_WAIT 8         /* disconnected, wait */
 #define DASD_STOPPED_DC_EIO  16        /* disconnected, return -EIO */
 
+/* per device flags */
+#define DASD_FLAG_RO		0	/* device is read-only */
+#define DASD_FLAG_USE_DIAG	1	/* use diag disciplnie */
+#define DASD_FLAG_DSC_ERROR	2	/* return -EIO when disconnected */
+#define DASD_FLAG_OFFLINE	3	/* device is in offline processing */
 
 void dasd_put_device_wake(struct dasd_device *);
 
@@ -498,7 +501,7 @@ int  dasd_gendisk_init(void);
 void dasd_gendisk_exit(void);
 int dasd_gendisk_alloc(struct dasd_device *);
 void dasd_gendisk_free(struct dasd_device *);
-void dasd_scan_partitions(struct dasd_device *);
+int dasd_scan_partitions(struct dasd_device *);
 void dasd_destroy_partitions(struct dasd_device *);
 
 /* externals in dasd_ioctl.c */
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_ioctl.c linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_ioctl.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_ioctl.c	2004-02-26 11:21:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_ioctl.c	2004-03-27 11:40:45.000000000 +0000
@@ -303,7 +303,7 @@ dasd_ioctl_format(struct block_device *b
 
 	if (device == NULL)
 		return -ENODEV;
-	if (device->ro_flag)
+	if (test_bit(DASD_FLAG_RO, &device->flags))
 		return -EROFS;
 	if (copy_from_user(&fdata, (void *) args,
 			   sizeof (struct format_data_t)))
@@ -415,8 +415,8 @@ dasd_ioctl_information(struct block_devi
 	    (dasd_check_blocksize(device->bp_block)))
 		dasd_info->format = DASD_FORMAT_NONE;
 	
-	dasd_info->features |= device->ro_flag ? DASD_FEATURE_READONLY
-					       : DASD_FEATURE_DEFAULT;
+	dasd_info->features |= test_bit(DASD_FLAG_RO, &device->flags) ?
+		DASD_FEATURE_READONLY : DASD_FEATURE_DEFAULT;
 
 	if (device->discipline)
 		memcpy(dasd_info->type, device->discipline->name, 4);
@@ -472,7 +472,10 @@ dasd_ioctl_set_ro(struct block_device *b
 	if (device == NULL)
 		return -ENODEV;
 	set_disk_ro(bdev->bd_disk, intval);
-	device->ro_flag = intval;
+	if (intval)
+		set_bit(DASD_FLAG_RO, &device->flags);
+	else
+		clear_bit(DASD_FLAG_RO, &device->flags);
 	return 0;
 }
 
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_proc.c linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_proc.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/block/dasd_proc.c	2004-02-26 11:21:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/block/dasd_proc.c	2004-03-27 11:40:45.000000000 +0000
@@ -9,7 +9,7 @@
  *
  * /proc interface for the dasd driver.
  *
- * $Revision: 1.26 $
+ * $Revision: 1.27 $
  */
 
 #include <linux/config.h>
@@ -77,7 +77,7 @@ dasd_devices_show(struct seq_file *m, vo
 	else
 		seq_printf(m, " is ????????");
 	/* Print devices features. */
-	substr = device->ro_flag ? "(ro)" : " ";
+	substr = test_bit(DASD_FLAG_RO, &device->flags) ? "(ro)" : " ";
 	seq_printf(m, "%4s: ", substr);
 	/* Print device status information. */
 	switch ((device != NULL) ? device->state : -1) {
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape.h linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape.h
--- linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape.h	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape.h	2004-03-27 11:40:46.000000000 +0000
@@ -198,6 +198,7 @@ struct tape_device {
 	/* entry in tape_device_list */
 	struct list_head		node;
 
+	int				cdev_id;
 	struct ccw_device *		cdev;
 	struct tape_class_device *	nt;
 	struct tape_class_device *	rt;
@@ -263,8 +264,8 @@ extern int tape_release(struct tape_devi
 extern int tape_mtop(struct tape_device *, int, int);
 extern void tape_state_set(struct tape_device *, enum tape_state);
 
-extern int tape_enable_device(struct tape_device *, struct tape_discipline *);
-extern void tape_disable_device(struct tape_device *device);
+extern int tape_generic_online(struct tape_device *, struct tape_discipline *);
+extern int tape_generic_offline(struct tape_device *device);
 
 /* Externals from tape_devmap.c */
 extern int tape_generic_probe(struct ccw_device *);
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape_34xx.c linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape_34xx.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape_34xx.c	2004-01-19 06:35:55.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape_34xx.c	2004-03-27 11:40:46.000000000 +0000
@@ -202,8 +202,7 @@ tape_34xx_unsolicited_irq(struct tape_de
 		tape_34xx_delete_sbid_from(device, 0);
 		tape_34xx_schedule_work(device, TO_MSEN);
 	} else {
-		DBF_EVENT(3, "unsol.irq! dev end: %s\n",
-				device->cdev->dev.bus_id);
+		DBF_EVENT(3, "unsol.irq! dev end: %08x\n", device->cdev_id);
 		PRINT_WARN("Unsolicited IRQ (Device End) caught.\n");
 		tape_dump_sense(device, NULL, irb);
 	}
@@ -1314,17 +1313,18 @@ static struct ccw_device_id tape_34xx_id
 };
 
 static int
-tape_34xx_enable(struct ccw_device *cdev)
+tape_34xx_online(struct ccw_device *cdev)
 {
-	return tape_enable_device(cdev->dev.driver_data,
-				  &tape_discipline_34xx);
+	return tape_generic_online(
+		cdev->dev.driver_data,
+		&tape_discipline_34xx
+	);
 }
 
 static int
-tape_34xx_disable(struct ccw_device *cdev)
+tape_34xx_offline(struct ccw_device *cdev)
 {
-	tape_disable_device(cdev->dev.driver_data);
-	return 0;
+	return tape_generic_offline(cdev->dev.driver_data);
 }
 
 static struct ccw_driver tape_34xx_driver = {
@@ -1333,8 +1333,8 @@ static struct ccw_driver tape_34xx_drive
 	.ids = tape_34xx_ids,
 	.probe = tape_generic_probe,
 	.remove = tape_generic_remove,
-	.set_online = tape_34xx_enable,
-	.set_offline = tape_34xx_disable,
+	.set_online = tape_34xx_online,
+	.set_offline = tape_34xx_offline,
 };
 
 static int
@@ -1342,7 +1342,7 @@ tape_34xx_init (void)
 {
 	int rc;
 
-	DBF_EVENT(3, "34xx init: $Revision: 1.18 $\n");
+	DBF_EVENT(3, "34xx init: $Revision: 1.19 $\n");
 	/* Register driver for 3480/3490 tapes. */
 	rc = ccw_driver_register(&tape_34xx_driver);
 	if (rc)
@@ -1361,7 +1361,7 @@ tape_34xx_exit(void)
 MODULE_DEVICE_TABLE(ccw, tape_34xx_ids);
 MODULE_AUTHOR("(C) 2001-2002 IBM Deutschland Entwicklung GmbH");
 MODULE_DESCRIPTION("Linux on zSeries channel attached 3480 tape "
-		   "device driver ($Revision: 1.18 $)");
+		   "device driver ($Revision: 1.19 $)");
 MODULE_LICENSE("GPL");
 
 module_init(tape_34xx_init);
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape_block.c linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape_block.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape_block.c	2004-03-02 03:01:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape_block.c	2004-03-27 11:40:46.000000000 +0000
@@ -274,12 +274,19 @@ tapeblock_cleanup_device(struct tape_dev
 	flush_scheduled_work();
 	device->blk_data.requeue_task.data = tape_put_device(device);
 
+	if (!device->blk_data.disk) {
+		PRINT_ERR("(%s): No gendisk to clean up!\n",
+			device->cdev->dev.bus_id);
+		goto cleanup_queue;
+	}
+
 	del_gendisk(device->blk_data.disk);
 	device->blk_data.disk->private_data =
 		tape_put_device(device->blk_data.disk->private_data);
 	put_disk(device->blk_data.disk);
 
 	device->blk_data.disk = NULL;
+cleanup_queue:
 	device->blk_data.request_queue->queuedata = tape_put_device(device);
 
 	blk_cleanup_queue(device->blk_data.request_queue);
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape_core.c linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape_core.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape_core.c	2004-03-02 03:01:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape_core.c	2004-03-27 11:40:46.000000000 +0000
@@ -69,6 +69,34 @@ const char *tape_op_verbose[TO_SIZE] =
 	[TO_UNASSIGN] = "UAS"
 };
 
+static inline int
+busid_to_int(char *bus_id)
+{
+	int	dec;
+	int	d;
+	char *	s;
+
+	for(s = bus_id, d = 0; *s != '\0' && *s != '.'; s++)
+		d = (d * 10) + (*s - '0');
+	dec = d;
+	for(s++, d = 0; *s != '\0' && *s != '.'; s++)
+		d = (d * 10) + (*s - '0');
+	dec = (dec << 8) + d;
+
+	for(s++; *s != '\0'; s++) {
+		if (*s >= '0' && *s <= '9') {
+			d = *s - '0';
+		} else if (*s >= 'a' && *s <= 'f') {
+			d = *s - 'a' + 10;
+		} else {
+			d = *s - 'A' + 10;
+		}
+		dec = (dec << 4) + d;
+	}
+
+	return dec;
+}
+
 /*
  * Some channel attached tape specific attributes.
  *
@@ -296,10 +324,15 @@ tape_remove_minor(struct tape_device *de
 }
 
 /*
- * Enable tape device
+ * Set a device online.
+ *
+ * This function is called by the common I/O layer to move a device from the
+ * detected but offline into the online state.
+ * If we return an error (RC < 0) the device remains in the offline state. This
+ * can happen if the device is assigned somewhere else, for example.
  */
 int
-tape_enable_device(struct tape_device *device,
+tape_generic_online(struct tape_device *device,
 		   struct tape_discipline *discipline)
 {
 	int rc;
@@ -328,6 +361,9 @@ tape_enable_device(struct tape_device *d
 		goto out_char;
 
 	tape_state_set(device, TS_UNUSED);
+
+	DBF_LH(3, "(%08x): Drive set online\n", device->cdev_id);
+
 	return 0;
 
 out_char:
@@ -342,37 +378,49 @@ out:
 }
 
 /*
- * Disable tape device. Check if there is a running request and
- * terminate it. Post all queued requests with -EIO.
+ * Set device offline.
+ *
+ * Called by the common I/O layer if the drive should set offline on user
+ * request. We may prevent this by returning an error.
+ * Manual offline is only allowed while the drive is not in use.
  */
-void
-tape_disable_device(struct tape_device *device)
+int
+tape_generic_offline(struct tape_device *device)
 {
-	struct list_head *l, *n;
-	struct tape_request *request;
+	if (!device) {
+		PRINT_ERR("tape_generic_offline: no such device\n");
+		return -ENODEV;
+	}
+
+	DBF_LH(3, "(%08x): tape_generic_offline(%p)\n",
+		device->cdev_id, device);
 
 	spin_lock_irq(get_ccwdev_lock(device->cdev));
-	/* Post remaining requests with -EIO */
-	list_for_each_safe(l, n, &device->req_queue) {
-		request = list_entry(l, struct tape_request, list);
-		if (request->status == TAPE_REQUEST_IN_IO)
-			__tape_halt_io(device, request);
-		list_del(&request->list);
-		/* Decrease ref_count for removed request. */
-		request->device = tape_put_device(device);
-		request->rc = -EIO;
-		if (request->callback != NULL)
-			request->callback(request, request->callback_data);
+	switch (device->tape_state) {
+		case TS_INIT:
+		case TS_NOT_OPER:
+			break;
+		case TS_UNUSED:
+			tapeblock_cleanup_device(device);
+			tapechar_cleanup_device(device);
+			device->discipline->cleanup_device(device);
+			tape_remove_minor(device);
+		default:
+			DBF_EVENT(3, "(%08x): Set offline failed "
+				"- drive in use.\n",
+				device->cdev_id);
+			PRINT_WARN("(%s): Set offline failed "
+				"- drive in use.\n",
+				device->cdev->dev.bus_id);
+			spin_unlock_irq(get_ccwdev_lock(device->cdev));
+			return -EBUSY;
 	}
 	spin_unlock_irq(get_ccwdev_lock(device->cdev));
 
-	tapeblock_cleanup_device(device);
-	tapechar_cleanup_device(device);
-	device->discipline->cleanup_device(device);
-	tape_remove_minor(device);
-
 	tape_med_state_set(device, MS_UNKNOWN);
-	device->tape_state = TS_INIT;
+
+	DBF_LH(3, "(%08x): Drive set offline.\n", device->cdev_id);
+	return 0;
 }
 
 /*
@@ -479,14 +527,14 @@ int
 tape_generic_probe(struct ccw_device *cdev)
 {
 	struct tape_device *device;
-	char *bus_id = cdev->dev.bus_id;
 
 	device = tape_alloc_device();
 	if (IS_ERR(device))
 		return -ENODEV;
-	PRINT_INFO("tape device %s found\n", bus_id);
+	PRINT_INFO("tape device %s found\n", cdev->dev.bus_id);
 	cdev->dev.driver_data = device;
 	device->cdev = cdev;
+	device->cdev_id = busid_to_int(cdev->dev.bus_id);
 	cdev->handler = __tape_do_irq;
 
 	ccw_device_set_options(cdev, CCWDEV_DO_PATHGROUP);
@@ -497,15 +545,58 @@ tape_generic_probe(struct ccw_device *cd
 
 /*
  * Driverfs tape remove function.
+ *
+ * This function is called whenever the common I/O layer detects the device
+ * gone. This can happen at any time and we cannot refuse.
  */
 void
 tape_generic_remove(struct ccw_device *cdev)
 {
-	ccw_device_set_offline(cdev);
+	struct tape_device *	device;
+	struct tape_request *	request;
+	struct list_head *	l, *n;
+
+	device = cdev->dev.driver_data;
+	DBF_LH(3, "(%08x): tape_generic_remove(%p)\n", device->cdev_id, cdev);
+
+	/*
+	 * No more requests may be processed. So just post them as i/o errors.
+	 */
+	spin_lock_irq(get_ccwdev_lock(device->cdev));
+	list_for_each_safe(l, n, &device->req_queue) {
+		request = list_entry(l, struct tape_request, list);
+		if (request->status == TAPE_REQUEST_IN_IO)
+			request->status = TAPE_REQUEST_DONE;
+		list_del(&request->list);
+
+		/* Decrease ref_count for removed request. */
+		request->device = tape_put_device(device);
+		request->rc = -EIO;
+		if (request->callback != NULL)
+			request->callback(request, request->callback_data);
+	}
+
+	if (device->tape_state != TS_UNUSED && device->tape_state != TS_INIT) {
+		DBF_EVENT(3, "(%08x): Drive in use vanished!\n",
+			device->cdev_id);
+		PRINT_WARN("(%s): Drive in use vanished - expect trouble!\n",
+			device->cdev->dev.bus_id);
+		PRINT_WARN("State was %i\n", device->tape_state);
+		device->tape_state = TS_NOT_OPER;
+		tapeblock_cleanup_device(device);
+		tapechar_cleanup_device(device);
+		device->discipline->cleanup_device(device);
+		tape_remove_minor(device);
+	}
+	device->tape_state = TS_NOT_OPER;
+	tape_med_state_set(device, MS_UNKNOWN);
+	spin_unlock_irq(get_ccwdev_lock(device->cdev));
+
 	if (cdev->dev.driver_data != NULL) {
 		sysfs_remove_group(&cdev->dev.kobj, &tape_attr_group);
 		cdev->dev.driver_data = tape_put_device(cdev->dev.driver_data);
 	}
+
 }
 
 /*
@@ -665,7 +756,7 @@ tape_dump_sense_dbf(struct tape_device *
 		op = "---";
 	DBF_EVENT(3, "DSTAT : %02x   CSTAT: %02x\n",
 		  irb->scsw.dstat,irb->scsw.cstat);
-	DBF_EVENT(3, "DEVICE: %s OP\t: %s\n", device->cdev->dev.bus_id,op);
+	DBF_EVENT(3, "DEVICE: %08x OP\t: %s\n", device->cdev_id, op);
 	sptr = (unsigned int *) irb->ecw;
 	DBF_EVENT(3, "%08x %08x\n", sptr[0], sptr[1]);
 	DBF_EVENT(3, "%08x %08x\n", sptr[2], sptr[3]);
@@ -815,7 +906,7 @@ tape_do_io_interruptible(struct tape_dev
 	spin_lock_irq(get_ccwdev_lock(device->cdev));
 	rc = __tape_halt_io(device, request);
 	if (rc == 0) {
-		DBF_EVENT(3, "IO stopped on %s\n", device->cdev->dev.bus_id);
+		DBF_EVENT(3, "IO stopped on %08x\n", device->cdev_id);
 		rc = -ERESTARTSYS;
 	}
 	spin_unlock_irq(get_ccwdev_lock(device->cdev));
@@ -823,6 +914,24 @@ tape_do_io_interruptible(struct tape_dev
 }
 
 /*
+ * Handle requests that return an i/o error in the irb.
+ */
+static inline void
+tape_handle_killed_request(
+	struct tape_device *device,
+	struct tape_request *request)
+{
+	if(request != NULL) {
+		/* Set ending status. FIXME: Should the request be retried? */
+		request->rc = -EIO;
+		request->status = TAPE_REQUEST_DONE;
+		__tape_remove_request(device, request);
+	} else {
+		__tape_do_io_list(device);
+	}
+}
+
+/*
  * Tape interrupt routine, called from the ccw_device layer
  */
 static void
@@ -835,7 +944,7 @@ __tape_do_irq (struct ccw_device *cdev, 
 
 	device = (struct tape_device *) cdev->dev.driver_data;
 	if (device == NULL) {
-		PRINT_ERR("could not get device structure for bus_id %s "
+		PRINT_ERR("could not get device structure for %s "
 			  "in interrupt\n", cdev->dev.bus_id);
 		return;
 	}
@@ -843,6 +952,23 @@ __tape_do_irq (struct ccw_device *cdev, 
 
 	DBF_LH(6, "__tape_do_irq(device=%p, request=%p)\n", device, request);
 
+	/* On special conditions irb is an error pointer */
+	if (IS_ERR(irb)) {
+		switch (PTR_ERR(irb)) {
+			case -ETIMEDOUT:
+				PRINT_WARN("(%s): Request timed out\n",
+					cdev->dev.bus_id);
+			case -EIO:
+				tape_handle_killed_request(device, request);
+				break;
+			default:
+				PRINT_ERR("(%s): Unexpected i/o error %li\n",
+					cdev->dev.bus_id,
+					PTR_ERR(irb));
+		}
+		return;
+	}
+
 	/* May be an unsolicited irq */
 	if(request != NULL)
 		request->rescnt = irb->scsw.count;
@@ -1023,7 +1149,7 @@ tape_init (void)
 #ifdef DBF_LIKE_HELL
 	debug_set_level(tape_dbf_area, 6);
 #endif
-	DBF_EVENT(3, "tape init: ($Revision: 1.44 $)\n");
+	DBF_EVENT(3, "tape init: ($Revision: 1.48 $)\n");
 	tape_proc_init();
 	tapechar_init ();
 	tapeblock_init ();
@@ -1048,7 +1174,7 @@ tape_exit(void)
 MODULE_AUTHOR("(C) 2001 IBM Deutschland Entwicklung GmbH by Carsten Otte and "
 	      "Michael Holzheu (cotte@de.ibm.com,holzheu@de.ibm.com)");
 MODULE_DESCRIPTION("Linux on zSeries channel attached "
-		   "tape device driver ($Revision: 1.44 $)");
+		   "tape device driver ($Revision: 1.48 $)");
 MODULE_LICENSE("GPL");
 
 module_init(tape_init);
@@ -1056,9 +1182,9 @@ module_exit(tape_exit);
 
 EXPORT_SYMBOL(tape_dbf_area);
 EXPORT_SYMBOL(tape_generic_remove);
-EXPORT_SYMBOL(tape_disable_device);
 EXPORT_SYMBOL(tape_generic_probe);
-EXPORT_SYMBOL(tape_enable_device);
+EXPORT_SYMBOL(tape_generic_online);
+EXPORT_SYMBOL(tape_generic_offline);
 EXPORT_SYMBOL(tape_put_device);
 EXPORT_SYMBOL(tape_get_device_reference);
 EXPORT_SYMBOL(tape_state_verbose);
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape_std.c linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape_std.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/char/tape_std.c	2004-01-19 06:35:55.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/char/tape_std.c	2004-03-27 11:40:46.000000000 +0000
@@ -42,8 +42,8 @@ tape_std_assign_timeout(unsigned long da
 
 	spin_lock_irq(get_ccwdev_lock(device->cdev));
 	if (request->callback != NULL) {
-		DBF_EVENT(3, "%s: Assignment timeout. Device busy.\n",
-			device->cdev->dev.bus_id);
+		DBF_EVENT(3, "%08x: Assignment timeout. Device busy.\n",
+			device->cdev_id);
 		PRINT_ERR("%s: Assignment timeout. Device busy.\n",
 			device->cdev->dev.bus_id);
 		ccw_device_clear(device->cdev, (long) request);
@@ -84,10 +84,10 @@ tape_std_assign(struct tape_device *devi
 	if (rc != 0) {
 		PRINT_WARN("%s: assign failed - device might be busy\n",
 			device->cdev->dev.bus_id);
-		DBF_EVENT(3, "%s: assign failed - device might be busy\n",
-			device->cdev->dev.bus_id);
+		DBF_EVENT(3, "%08x: assign failed - device might be busy\n",
+			device->cdev_id);
 	} else {
-		DBF_EVENT(3, "%s: Tape assigned\n", device->cdev->dev.bus_id);
+		DBF_EVENT(3, "%08x: Tape assigned\n", device->cdev_id);
 	}
 	tape_free_request(request);
 	return rc;
@@ -102,6 +102,14 @@ tape_std_unassign (struct tape_device *d
 	int                  rc;
 	struct tape_request *request;
 
+	if (device->tape_state == TS_NOT_OPER) {
+		DBF_EVENT(3, "(%08x): Can't unassign device\n",
+			device->cdev_id);
+		PRINT_WARN("(%s): Can't unassign device - device gone\n",
+			device->cdev->dev.bus_id);
+		return -EIO;
+	}
+
 	request = tape_alloc_request(2, 11);
 	if (IS_ERR(request))
 		return PTR_ERR(request);
@@ -111,10 +119,10 @@ tape_std_unassign (struct tape_device *d
 	tape_ccw_end(request->cpaddr + 1, NOP, 0, NULL);
 
 	if ((rc = tape_do_io(device, request)) != 0) {
-		DBF_EVENT(3, "%s: Unassign failed\n", device->cdev->dev.bus_id);
+		DBF_EVENT(3, "%08x: Unassign failed\n", device->cdev_id);
 		PRINT_WARN("%s: Unassign failed\n", device->cdev->dev.bus_id);
 	} else {
-		DBF_EVENT(3, "%s: Tape unassigned\n", device->cdev->dev.bus_id);
+		DBF_EVENT(3, "%08x: Tape unassigned\n", device->cdev_id);
 	}
 	tape_free_request(request);
 	return rc;
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/cio/ccwgroup.c linux-post-2.6.5-rc2-20040329/drivers/s390/cio/ccwgroup.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/cio/ccwgroup.c	2004-03-02 03:01:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/cio/ccwgroup.c	2004-03-27 11:40:46.000000000 +0000
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/ccwgroup.c
  *  bus driver for ccwgroup
- *   $Revision: 1.24 $
+ *   $Revision: 1.25 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *                       IBM Corporation
@@ -102,8 +102,10 @@ ccwgroup_release (struct device *dev)
 
 	gdev = to_ccwgroupdev(dev);
 
-	for (i = 0; i < gdev->count; i++)
+	for (i = 0; i < gdev->count; i++) {
+		gdev->cdev[i]->dev.driver_data = NULL;
 		put_device(&gdev->cdev[i]->dev);
+	}
 	kfree(gdev);
 }
 
@@ -155,6 +157,7 @@ ccwgroup_create(struct device *root,
 	struct ccwgroup_device *gdev;
 	int i;
 	int rc;
+	int del_drvdata;
 
 	if (argc > 256) /* disallow dumb users */
 		return -EINVAL;
@@ -166,6 +169,7 @@ ccwgroup_create(struct device *root,
 	memset(gdev, 0, sizeof(*gdev) + argc*sizeof(gdev->cdev[0]));
 	atomic_set(&gdev->onoff, 0);
 
+	del_drvdata = 0;
 	for (i = 0; i < argc; i++) {
 		gdev->cdev[i] = get_ccwdev_by_busid(cdrv, argv[i]);
 
@@ -177,7 +181,15 @@ ccwgroup_create(struct device *root,
 			rc = -EINVAL;
 			goto error;
 		}
+		/* Don't allow a device to belong to more than one group. */
+		if (gdev->cdev[i]->dev.driver_data) {
+			rc = -EINVAL;
+			goto error;
+		}
 	}
+	for (i = 0; i < argc; i++)
+		gdev->cdev[i]->dev.driver_data = gdev;
+	del_drvdata = 1;
 
 	*gdev = (struct ccwgroup_device) {
 		.creator_id = creator_id,
@@ -212,9 +224,11 @@ ccwgroup_create(struct device *root,
 	device_unregister(&gdev->dev);
 error:
 	for (i = 0; i < argc; i++)
-		if (gdev->cdev[i])
+		if (gdev->cdev[i]) {
 			put_device(&gdev->cdev[i]->dev);
-
+			if (del_drvdata)
+				gdev->cdev[i]->dev.driver_data = NULL;
+		}
 	kfree(gdev);
 
 	return rc;
@@ -399,40 +413,14 @@ static inline struct ccwgroup_device *
 __ccwgroup_get_gdev_by_cdev(struct ccw_device *cdev)
 {
 	struct ccwgroup_device *gdev;
-	struct list_head *entry;
-	struct device *dev;
-	int i, found;
-
-	/*
-	 * Find groupdevice cdev belongs to.
-	 * Unfortunately, we can't use bus_for_each_dev() because of the
-	 * semaphore (and return value of fn() is int).
-	 */
-	if (!get_bus(&ccwgroup_bus_type))
-		return NULL;
-
-	gdev = NULL;
-	down_read(&ccwgroup_bus_type.subsys.rwsem);
 
-	list_for_each(entry, &ccwgroup_bus_type.devices.list) {
-		dev = get_device(container_of(entry, struct device, bus_list));
-		found = 0;
-		if (!dev)
-			continue;
-		gdev = to_ccwgroupdev(dev);
-		for (i = 0; i < gdev->count && (!found); i++) {
-			if (gdev->cdev[i] == cdev)
-				found = 1;
-		}
-		if (found)
-			break;
-		put_device(dev);
-		gdev = NULL;
+	if (cdev->dev.driver_data) {
+		gdev = (struct ccwgroup_device *)cdev->dev.driver_data;
+		if (get_device(&gdev->dev))
+			return gdev;
+		return NULL;
 	}
-	up_read(&ccwgroup_bus_type.subsys.rwsem);
-	put_bus(&ccwgroup_bus_type);
-
-	return gdev;
+	return NULL;
 }
 
 void
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/cio/device_fsm.c linux-post-2.6.5-rc2-20040329/drivers/s390/cio/device_fsm.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/cio/device_fsm.c	2004-03-17 12:02:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/cio/device_fsm.c	2004-03-27 11:40:45.000000000 +0000
@@ -731,6 +731,9 @@ ccw_device_w4sense(struct ccw_device *cd
 	    		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
 		if (cdev->handler)
 			cdev->handler (cdev, 0, irb);
+		if (irb->scsw.cc == 1)
+			/* Basic sense hasn't started. Try again. */
+			ccw_device_do_sense(cdev, irb);
 		return;
 	}
 	/* Add basic sense info to irb. */
@@ -828,6 +831,8 @@ ccw_device_wait4io_irq(struct ccw_device
 	    		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS)) {
 		if (cdev->handler)
 			cdev->handler (cdev, 0, irb);
+		if (irb->scsw.cc == 1)
+			goto call_handler;
 		return;
 	}
 	/*
@@ -841,6 +846,7 @@ ccw_device_wait4io_irq(struct ccw_device
 		}
 		return;
 	}
+call_handler:
 	/* Iff device is idle, reset timeout. */
 	sch = to_subchannel(cdev->dev.parent);
 	if (!stsch(sch->irq, &sch->schib))
@@ -908,6 +914,8 @@ ccw_device_stlck_done(struct ccw_device 
 		/* Check for unsolicited interrupt. */
 		if (irb->scsw.stctl ==
 		    (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS))
+			/* FIXME: we should restart stlck here, but this
+			 * is extremely unlikely ... */
 			goto out_wakeup;
 
 		ccw_device_accumulate_irb(cdev, irb);
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/net/ctcmain.c linux-post-2.6.5-rc2-20040329/drivers/s390/net/ctcmain.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/net/ctcmain.c	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/net/ctcmain.c	2004-03-27 11:40:46.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * $Id: ctcmain.c,v 1.57 2004/03/02 15:34:01 mschwide Exp $
+ * $Id: ctcmain.c,v 1.58 2004/03/24 10:51:56 ptiedem Exp $
  *
  * CTC / ESCON network driver
  *
@@ -36,7 +36,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.57 $
+ * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.58 $
  *
  */
 
@@ -319,7 +319,7 @@ static void
 print_banner(void)
 {
 	static int printed = 0;
-	char vbuf[] = "$Revision: 1.57 $";
+	char vbuf[] = "$Revision: 1.58 $";
 	char *version = vbuf;
 
 	if (printed)
@@ -2067,7 +2067,8 @@ ctc_irq_handler(struct ccw_device *cdev,
 		return;
 	}
 	
-	priv = cdev->dev.driver_data;
+	priv = ((struct ccwgroup_device *)cdev->dev.driver_data)
+		->dev.driver_data;
 
 	/* Try to extract channel from driver data. */
 	if (priv->channel[READ]->cdev == cdev)
@@ -2963,8 +2964,6 @@ ctc_probe_device(struct ccwgroup_device 
 	cgdev->cdev[0]->handler = ctc_irq_handler;
 	cgdev->cdev[1]->handler = ctc_irq_handler;
 	cgdev->dev.driver_data = priv;
-	cgdev->cdev[0]->dev.driver_data = priv;
-	cgdev->cdev[1]->dev.driver_data = priv;
 
 	return 0;
 }
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/net/iucv.c linux-post-2.6.5-rc2-20040329/drivers/s390/net/iucv.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/net/iucv.c	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/net/iucv.c	2004-03-27 11:40:46.000000000 +0000
@@ -1,5 +1,5 @@
 /* 
- * $Id: iucv.c,v 1.26 2004/03/10 11:55:31 braunu Exp $
+ * $Id: iucv.c,v 1.27 2004/03/22 07:43:43 braunu Exp $
  *
  * IUCV network driver
  *
@@ -29,7 +29,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.26 $
+ * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.27 $
  *
  */
 
@@ -351,7 +351,7 @@ do { \
 static void
 iucv_banner(void)
 {
-	char vbuf[] = "$Revision: 1.26 $";
+	char vbuf[] = "$Revision: 1.27 $";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
@@ -374,14 +374,14 @@ iucv_init(void)
 {
 	int ret;
 
+	if (iucv_external_int_buffer)
+		return 0;
+
 	if (!MACHINE_IS_VM) {
 		printk(KERN_ERR "IUCV: IUCV connection needs VM as base\n");
 		return -EPROTONOSUPPORT;
 	}
 
-	if (iucv_external_int_buffer)
-		return 0;
-
 	ret = bus_register(&iucv_bus);
 	if (ret != 0) {
 		printk(KERN_ERR "IUCV: failed to register bus.\n");
@@ -830,7 +830,7 @@ iucv_register_program (__u8 pgmname[16],
 			memset (new_handler->id.mask, 0xFF,
 				sizeof (new_handler->id.mask));
 		}
-		memset (new_handler->id.mask, 0x00,
+		memset (new_handler->id.userid, 0x00,
 			sizeof (new_handler->id.userid));
 	}
 	/* fill in the rest of handler */
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/net/lcs.c linux-post-2.6.5-rc2-20040329/drivers/s390/net/lcs.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/net/lcs.c	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/net/lcs.c	2004-03-27 11:40:46.000000000 +0000
@@ -11,7 +11,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Martin Schwidefsky <schwidefsky@de.ibm.com>
  *
- *    $Revision: 1.68 $	 $Date: 2004/03/02 15:34:01 $
+ *    $Revision: 1.72 $	 $Date: 2004/03/22 09:34:27 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -58,9 +58,10 @@
 /**
  * initialization string for output
  */
-#define VERSION_LCS_C  "$Revision: 1.68 $"
+#define VERSION_LCS_C  "$Revision: 1.72 $"
 
 static char version[] __initdata = "LCS driver ("VERSION_LCS_C "/" VERSION_LCS_H ")";
+static char debug_buffer[255];
 
 /**
  * Some prototypes.
@@ -112,7 +113,7 @@ lcs_alloc_channel(struct lcs_channel *ch
 {
 	int cnt;
 
-	LCS_DBF_TEXT(3, setup, "ichalloc");
+	LCS_DBF_TEXT(2, setup, "ichalloc");
 	for (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {
 		/* alloc memory fo iobuffer */
 		channel->iob[cnt].data = (void *)
@@ -124,7 +125,7 @@ lcs_alloc_channel(struct lcs_channel *ch
 	}
 	if (cnt < LCS_NUM_BUFFS) {
 		/* Not all io buffers could be allocated. */
-		LCS_DBF_TEXT(3, setup, "echalloc");
+		LCS_DBF_TEXT(2, setup, "echalloc");
 		while (cnt-- > 0)
 			kfree(channel->iob[cnt].data);
 		return -ENOMEM;
@@ -140,7 +141,7 @@ lcs_free_channel(struct lcs_channel *cha
 {
 	int cnt;
 
-	LCS_DBF_TEXT(3, setup, "ichfree");
+	LCS_DBF_TEXT(2, setup, "ichfree");
 	for (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {
 		if (channel->iob[cnt].data != NULL)
 			kfree(channel->iob[cnt].data);
@@ -148,6 +149,30 @@ lcs_free_channel(struct lcs_channel *cha
 	}
 }
 
+/*
+ * Cleanup channel.
+ */
+static void
+lcs_cleanup_channel(struct lcs_channel *channel)
+{
+	LCS_DBF_TEXT(3, setup, "cleanch");
+	/* Kill write channel tasklets. */
+	tasklet_kill(&channel->irq_tasklet);
+	/* Free channel buffers. */
+	lcs_free_channel(channel);
+}
+
+/**
+ * LCS free memory for card and channels.
+ */
+static void
+lcs_free_card(struct lcs_card *card)
+{
+	LCS_DBF_TEXT(2, setup, "remcard");
+	LCS_DBF_HEX(2, setup, &card, sizeof(void*));
+	kfree(card);
+}
+
 /**
  * LCS alloc memory for card and channels
  */
@@ -155,25 +180,34 @@ static struct lcs_card *
 lcs_alloc_card(void)
 {
 	struct lcs_card *card;
+	int rc;
+
+	LCS_DBF_TEXT(2, setup, "alloclcs");
 
-	LCS_DBF_TEXT(3, setup, "alloclcs");
 	card = kmalloc(sizeof(struct lcs_card), GFP_KERNEL | GFP_DMA);
 	if (card == NULL)
 		return NULL;
 	memset(card, 0, sizeof(struct lcs_card));
 	card->lan_type = LCS_FRAME_TYPE_AUTO;
 	card->lancmd_timeout = LCS_LANCMD_TIMEOUT_DEFAULT;
-	return card;
-}
+	/* Allocate io buffers for the read channel. */
+	rc = lcs_alloc_channel(&card->read);
+	if (rc){
+		LCS_DBF_TEXT(2, setup, "iccwerr");
+		lcs_free_card(card);
+		return NULL;
+	}
+	/* Allocate io buffers for the write channel. */
+	rc = lcs_alloc_channel(&card->write);
+	if (rc) {
+		LCS_DBF_TEXT(2, setup, "iccwerr");
+		lcs_cleanup_channel(&card->read);
+		lcs_free_card(card);
+		return NULL;
+	}
 
-/**
- * LCS free memory for card and channels.
- */
-static void
-lcs_free_card(struct lcs_card *card)
-{
-	LCS_DBF_TEXT(2, setup, "remcard");
-	kfree(card);
+	LCS_DBF_HEX(2, setup, &card, sizeof(void*));
+	return card;
 }
 
 /*
@@ -218,25 +252,17 @@ lcs_setup_read_ccws(struct lcs_card *car
 	card->read.buf_idx = 0;
 }
 
-static int
+static void
 lcs_setup_read(struct lcs_card *card)
 {
-	int rc;
+	LCS_DBF_TEXT(3, setup, "initread");
 
-	LCS_DBF_TEXT(3, setup, "readirq");
-	/* Allocate io buffers for the read channel. */
-	rc = lcs_alloc_channel(&card->read);
-	if (rc){
-		LCS_DBF_TEXT(3, setup, "iccwerr");
-		return rc;
-	}
 	lcs_setup_read_ccws(card);
 	/* Initialize read channel tasklet. */
 	card->read.irq_tasklet.data = (unsigned long) &card->read;
 	card->read.irq_tasklet.func = lcs_tasklet;
 	/* Initialize waitqueue. */
 	init_waitqueue_head(&card->read.wait_q);
-	return 0;
 }
 
 /*
@@ -247,7 +273,7 @@ lcs_setup_write_ccws(struct lcs_card *ca
 {
 	int cnt;
 
-	LCS_DBF_TEXT(2, setup, "iwritccw");
+	LCS_DBF_TEXT(3, setup, "iwritccw");
 	/* Setup write ccws. */
 	memset(card->write.ccws, 0, sizeof(struct ccw1) * LCS_NUM_BUFFS + 1);
 	for (cnt = 0; cnt < LCS_NUM_BUFFS; cnt++) {
@@ -273,61 +299,32 @@ lcs_setup_write_ccws(struct lcs_card *ca
 	card->write.buf_idx = 0;
 }
 
-static int
+static void
 lcs_setup_write(struct lcs_card *card)
 {
-	int rc;
+	LCS_DBF_TEXT(3, setup, "initwrit");
 
-	LCS_DBF_TEXT(3, setup, "writeirq");
-	/* Allocate io buffers for the write channel. */
-	rc = lcs_alloc_channel(&card->write);
-	if (rc) {
-		LCS_DBF_TEXT(3, setup, "iccwerr");
-		return rc;
-	}
 	lcs_setup_write_ccws(card);
 	/* Initialize write channel tasklet. */
 	card->write.irq_tasklet.data = (unsigned long) &card->write;
 	card->write.irq_tasklet.func = lcs_tasklet;
 	/* Initialize waitqueue. */
 	init_waitqueue_head(&card->write.wait_q);
-	return 0;
 }
 
-/*
- * Cleanup channel.
- */
-static void
-lcs_cleanup_channel(struct lcs_channel *channel)
-{
-	LCS_DBF_TEXT(3, setup, "cleanch");
-	/* Kill write channel tasklets. */
-	tasklet_kill(&channel->irq_tasklet);
-	/* Free channel buffers. */
-	lcs_free_channel(channel);
-}
+
 
 /**
  * Initialize channels,card and state machines.
  */
-static int
+static void
 lcs_setup_card(struct lcs_card *card)
 {
-	int rc;
-
-	LCS_DBF_TEXT(3, setup, "initcard");
+	LCS_DBF_TEXT(2, setup, "initcard");
+	LCS_DBF_HEX(2, setup, &card, sizeof(void*));
 
-	rc = lcs_setup_read(card);
-	if (rc) {
-		PRINT_ERR("Could not initialize read channel\n");
-		return rc;
-	}
-	rc = lcs_setup_write(card);
-	if (rc) {
-		PRINT_ERR("Could not initialize write channel\n");
-		lcs_cleanup_channel(&card->read);
-		return rc;
-	}
+	lcs_setup_read(card);
+	lcs_setup_write(card);
 	/* Set cards initial state. */
 	card->state = DEV_STATE_DOWN;
 	card->tx_buffer = NULL;
@@ -342,7 +339,6 @@ lcs_setup_card(struct lcs_card *card)
 	INIT_LIST_HEAD(&card->ipm_list);
 #endif
 	INIT_LIST_HEAD(&card->lancmd_waiters);
-	return 0;
 }
 
 /**
@@ -355,6 +351,7 @@ lcs_cleanup_card(struct lcs_card *card)
 	struct lcs_ipm_list *ipm_list;
 
 	LCS_DBF_TEXT(3, setup, "cleancrd");
+	LCS_DBF_HEX(2,setup,&card,sizeof(void*));
 #ifdef	CONFIG_IP_MULTICAST
 	/* Free multicast list. */
 	list_for_each_safe(l, n, &card->ipm_list) {
@@ -376,12 +373,10 @@ lcs_cleanup_card(struct lcs_card *card)
 static int
 lcs_start_channel(struct lcs_channel *channel)
 {
-	char dbf_text[15];
 	unsigned long flags;
 	int rc;
 
-	sprintf(dbf_text,"ssch%s", channel->ccwdev->dev.bus_id);
-	LCS_DBF_TEXT(4, trace, dbf_text);
+	LCS_DBF_TEXT_(4,trace,"ssch%s", channel->ccwdev->dev.bus_id);
 	spin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);
 	rc = ccw_device_start(channel->ccwdev,
 			      channel->ccws + channel->io_idx, 0, 0,
@@ -390,37 +385,56 @@ lcs_start_channel(struct lcs_channel *ch
 		channel->state = CH_STATE_RUNNING;
 	spin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);
 	if (rc) {
-		sprintf(dbf_text,"essc%s", channel->ccwdev->dev.bus_id);
-		LCS_DBF_TEXT(4, trace, dbf_text);
+		LCS_DBF_TEXT_(4,trace,"essh%s", channel->ccwdev->dev.bus_id);
 		PRINT_ERR("Error in starting channel, rc=%d!\n", rc);
 	}
 	return rc;
 }
 
+static int
+lcs_clear_channel(struct lcs_channel *channel)
+{
+	unsigned long flags;
+	int rc;
+
+	LCS_DBF_TEXT(4,trace,"clearch");
+	LCS_DBF_TEXT_(4,trace,"%s", channel->ccwdev->dev.bus_id);
+	spin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);
+	rc = ccw_device_clear(channel->ccwdev, (addr_t) channel);
+	spin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);
+	if (rc) {
+		LCS_DBF_TEXT_(4,trace,"ecsc%s", channel->ccwdev->dev.bus_id);
+		return rc;
+	}
+	wait_event(channel->wait_q, (channel->state == CH_STATE_CLEARED));
+	channel->state = CH_STATE_STOPPED;
+	return rc;
+}
+
+
 /**
  * Stop channel.
  */
 static int
 lcs_stop_channel(struct lcs_channel *channel)
 {
-	char dbf_text[15];
 	unsigned long flags;
 	int rc;
 
 	if (channel->state == CH_STATE_STOPPED)
 		return 0;
-	sprintf(dbf_text,"hsch%s", channel->ccwdev->dev.bus_id);
-	LCS_DBF_TEXT(4, trace, dbf_text);
+	LCS_DBF_TEXT(4,trace,"haltsch");
+	LCS_DBF_TEXT_(4,trace,"%s", channel->ccwdev->dev.bus_id);
 	spin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);
 	rc = ccw_device_halt(channel->ccwdev, (addr_t) channel);
 	spin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);
 	if (rc) {
-		sprintf(dbf_text,"ehsc%s", channel->ccwdev->dev.bus_id);
-		LCS_DBF_TEXT(4, trace, dbf_text);
+		LCS_DBF_TEXT_(4,trace,"ehsc%s", channel->ccwdev->dev.bus_id);
 		return rc;
 	}
 	/* Asynchronous halt initialted. Wait for its completion. */
 	wait_event(channel->wait_q, (channel->state == CH_STATE_HALTED));
+	lcs_clear_channel(channel);
 	return 0;
 }
 
@@ -464,6 +478,7 @@ __lcs_get_buffer(struct lcs_channel *cha
 {
 	int index;
 
+	LCS_DBF_TEXT(5, trace, "_getbuff");
 	index = channel->io_idx;
 	do {
 		if (channel->iob[index].state == BUF_STATE_EMPTY) {
@@ -481,6 +496,7 @@ lcs_get_buffer(struct lcs_channel *chann
 	struct lcs_buffer *buffer;
 	unsigned long flags;
 
+	LCS_DBF_TEXT(5, trace, "getbuff");
 	spin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);
 	buffer = __lcs_get_buffer(channel);
 	spin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);
@@ -493,19 +509,16 @@ lcs_get_buffer(struct lcs_channel *chann
 static int
 __lcs_resume_channel(struct lcs_channel *channel)
 {
-	char dbf_text[15];
 	int rc;
 
 	if (channel->state != CH_STATE_SUSPENDED)
 		return 0;
 	if (channel->ccws[channel->io_idx].flags & CCW_FLAG_SUSPEND)
 		return 0;
-	sprintf(dbf_text,"rsch%s", channel->ccwdev->dev.bus_id);
-	LCS_DBF_TEXT(4, trace, dbf_text);
+	LCS_DBF_TEXT_(5, trace, "rsch%s", channel->ccwdev->dev.bus_id);
 	rc = ccw_device_resume(channel->ccwdev);
 	if (rc) {
-		sprintf(dbf_text,"ersc%s", channel->ccwdev->dev.bus_id);
-		LCS_DBF_TEXT(4, trace, dbf_text);
+		LCS_DBF_TEXT_(4, trace, "ersc%s", channel->ccwdev->dev.bus_id);
 		PRINT_ERR("Error in lcs_resume_channel: rc=%d\n",rc);
 	} else
 		channel->state = CH_STATE_RUNNING;
@@ -521,6 +534,7 @@ __lcs_ready_buffer_bits(struct lcs_chann
 {
 	int prev, next;
 
+	LCS_DBF_TEXT(5, trace, "rdybits");
 	prev = (index - 1) & (LCS_NUM_BUFFS - 1);
 	next = (index + 1) & (LCS_NUM_BUFFS - 1);
 	/* Check if we may clear the suspend bit of this buffer. */
@@ -540,6 +554,7 @@ lcs_ready_buffer(struct lcs_channel *cha
 	unsigned long flags;
 	int index, rc;
 
+	LCS_DBF_TEXT(5, trace, "rdybuff");
 	if (buffer->state != BUF_STATE_LOCKED &&
 	    buffer->state != BUF_STATE_PROCESSED)
 		BUG();
@@ -565,6 +580,7 @@ __lcs_processed_buffer(struct lcs_channe
 {
 	int index, prev, next;
 
+	LCS_DBF_TEXT(5, trace, "prcsbuff");
 	if (buffer->state != BUF_STATE_READY)
 		BUG();
 	buffer->state = BUF_STATE_PROCESSED;
@@ -597,6 +613,7 @@ lcs_release_buffer(struct lcs_channel *c
 {
 	unsigned long flags;
 
+	LCS_DBF_TEXT(5, trace, "relbuff");
 	if (buffer->state != BUF_STATE_LOCKED &&
 	    buffer->state != BUF_STATE_PROCESSED)
 		BUG();
@@ -614,6 +631,7 @@ lcs_get_lancmd(struct lcs_card *card, in
 	struct lcs_buffer *buffer;
 	struct lcs_cmd *cmd;
 
+	LCS_DBF_TEXT(4, trace, "getlncmd");
 	/* Get buffer and wait if none is available. */
 	wait_event(card->write.wait_q,
 		   ((buffer = lcs_get_buffer(&card->write)) != NULL));
@@ -637,6 +655,7 @@ lcs_notify_lancmd_waiters(struct lcs_car
 	struct list_head *l, *n;
 	struct lcs_reply *reply;
 
+	LCS_DBF_TEXT(4, trace, "notiwait");
 	spin_lock(&card->lock);
 	list_for_each_safe(l, n, &card->lancmd_waiters) {
 		reply = list_entry(l, struct lcs_reply, list);
@@ -661,6 +680,7 @@ lcs_lancmd_timeout(unsigned long data)
 {
 	struct lcs_reply *reply;
 
+	LCS_DBF_TEXT(4, trace, "timeout");
 	reply = (struct lcs_reply *) data;
 	list_del(&reply->list);
 	reply->received = 1;
@@ -676,8 +696,8 @@ lcs_send_lancmd(struct lcs_card *card, s
 	struct lcs_cmd *cmd;
 	struct timer_list timer;
 	int rc;
-	char buf[16];
 
+	LCS_DBF_TEXT(4, trace, "sendcmd");
 	cmd = (struct lcs_cmd *) buffer->data;
 	cmd->sequence_no = ++card->sequence_no;
 	cmd->return_code = 0;
@@ -700,9 +720,7 @@ lcs_send_lancmd(struct lcs_card *card, s
 	add_timer(&timer);
 	wait_event(reply.wait_q, reply.received);
 	del_timer(&timer);
-	LCS_DBF_TEXT(5, trace, "sendcmd");
-	sprintf(buf, "rc:%d", reply.rc);
-	LCS_DBF_TEXT(5, trace, buf);
+	LCS_DBF_TEXT_(4, trace, "rc:%d",reply.rc);
 	return reply.rc ? -EIO : 0;
 }
 
@@ -747,6 +765,7 @@ lcs_send_shutdown(struct lcs_card *card)
 static void
 __lcs_lanstat_cb(struct lcs_card *card, struct lcs_cmd *cmd)
 {
+	LCS_DBF_TEXT(2, trace, "statcb");
 	memcpy(card->mac, cmd->cmd.lcs_lanstat_cmd.mac_addr, LCS_MAC_LENGTH);
 }
 
@@ -756,7 +775,7 @@ lcs_send_lanstat(struct lcs_card *card)
 	struct lcs_buffer *buffer;
 	struct lcs_cmd *cmd;
 
-	LCS_DBF_TEXT(2, trace, "cmdstat");
+	LCS_DBF_TEXT(2,trace, "cmdstat");
 	buffer = lcs_get_lancmd(card, LCS_STD_CMD_SIZE);
 	cmd = (struct lcs_cmd *) buffer->data;
 	/* Setup lanstat command. */
@@ -792,6 +811,7 @@ lcs_send_stoplan(struct lcs_card *card, 
 static void
 __lcs_send_startlan_cb(struct lcs_card *card, struct lcs_cmd *cmd)
 {
+	LCS_DBF_TEXT(2, trace, "srtlancb");
 	card->lan_type = cmd->cmd.lcs_std_cmd.lan_type;
 	card->portno = cmd->cmd.lcs_std_cmd.portno;
 }
@@ -833,6 +853,7 @@ lcs_send_setipm(struct lcs_card *card,st
 	cmd->cmd.lcs_qipassist.num_ip_pairs = 1;
 	memcpy(cmd->cmd.lcs_qipassist.lcs_ipass_ctlmsg.ip_mac_pair,
 	       &ipm_list->ipm, sizeof (struct lcs_ip_mac_pair));
+	LCS_DBF_TEXT_(2, trace, "%x",ipm_list->ipm.ip_addr);
 	return lcs_send_lancmd(card, buffer, NULL);
 }
 
@@ -856,6 +877,7 @@ lcs_send_delipm(struct lcs_card *card,st
 	cmd->cmd.lcs_qipassist.num_ip_pairs = 1;
 	memcpy(cmd->cmd.lcs_qipassist.lcs_ipass_ctlmsg.ip_mac_pair,
 	       &ipm_list->ipm, sizeof (struct lcs_ip_mac_pair));
+	LCS_DBF_TEXT_(2, trace, "%x",ipm_list->ipm.ip_addr);
 	return lcs_send_lancmd(card, buffer, NULL);
 }
 
@@ -865,6 +887,7 @@ lcs_send_delipm(struct lcs_card *card,st
 static void
 __lcs_check_multicast_cb(struct lcs_card *card, struct lcs_cmd *cmd)
 {
+	LCS_DBF_TEXT(2, trace, "chkmccb");
 	card->ip_assists_supported =
 		cmd->cmd.lcs_qipassist.ip_assists_supported;
 	card->ip_assists_enabled =
@@ -919,7 +942,7 @@ lcs_fix_multicast_list(void *data)
 	card = (struct lcs_card *) data;
 
 	daemonize("fixipm");
-	LCS_DBF_TEXT(5, trace, "fixipm");
+	LCS_DBF_TEXT(4,trace, "fixipm");
 	spin_lock(&card->lock);
 	list_for_each_safe(l, n, &card->ipm_list) {
 		ipm = list_entry(l, struct lcs_ipm_list, list);
@@ -952,6 +975,7 @@ lcs_fix_multicast_list(void *data)
 static void
 lcs_get_mac_for_ipm(__u32 ipm, char *mac, struct net_device *dev)
 {
+	LCS_DBF_TEXT(4,trace, "getmac");
 	if (dev->type == ARPHRD_IEEE802_TR)
 		ip_tr_mc_map(ipm, mac);
 	else
@@ -971,7 +995,7 @@ lcs_set_multicast_list(struct net_device
 	struct lcs_ipm_list *ipm, *tmp;
 	struct lcs_card *card;
 
-	LCS_DBF_TEXT(5, trace, "setmulti");
+	LCS_DBF_TEXT(4, trace, "setmulti");
 	in4_dev = in_dev_get(dev);
 	if (in4_dev == NULL)
 		return;
@@ -1033,21 +1057,18 @@ lcs_set_multicast_list(struct net_device
 static void
 lcs_irq(struct ccw_device *cdev, unsigned long intparm, struct irb *irb)
 {
-	char dbf_text[15];
 	struct lcs_card *card;
 	struct lcs_channel *channel;
 	int index;
 
-	card = (struct lcs_card *)cdev->dev.driver_data;
+	card = CARD_FROM_DEV(cdev);
 	if (card->read.ccwdev == cdev)
 		channel = &card->read;
 	else
 		channel = &card->write;
 
-	sprintf(dbf_text, "Rint%s", cdev->dev.bus_id);
-	LCS_DBF_TEXT(5, trace, dbf_text);
-	sprintf(dbf_text, "%4x%4x", irb->scsw.cstat, irb->scsw.dstat);
-	LCS_DBF_TEXT(5, trace, dbf_text);
+	LCS_DBF_TEXT_(5, trace, "Rint%s",cdev->dev.bus_id);
+	LCS_DBF_TEXT_(5, trace, "%4x%4x",irb->scsw.cstat, irb->scsw.dstat);
 
 	/* How far in the ccw chain have we processed? */
 	if ((channel->state != CH_STATE_INIT) &&
@@ -1084,6 +1105,9 @@ lcs_irq(struct ccw_device *cdev, unsigne
 		channel->state = CH_STATE_HALTED;
 	}
 
+	if (irb->scsw.fctl & SCSW_FCTL_CLEAR_FUNC) {
+		channel->state = CH_STATE_CLEARED;
+	}
 	/* Do the rest in the tasklet. */
 	tasklet_schedule(&channel->irq_tasklet);
 }
@@ -1094,7 +1118,6 @@ lcs_irq(struct ccw_device *cdev, unsigne
 static void
 lcs_tasklet(unsigned long data)
 {
-	char dbf_text[15];
 	unsigned long flags;
 	struct lcs_channel *channel;
 	struct lcs_buffer *iob;
@@ -1102,8 +1125,7 @@ lcs_tasklet(unsigned long data)
 	int rc;
 
 	channel = (struct lcs_channel *) data;
-	sprintf(dbf_text, "tlet%s", channel->ccwdev->dev.bus_id);
-	LCS_DBF_TEXT(5, trace, dbf_text);
+	LCS_DBF_TEXT_(5, trace, "tlet%s",channel->ccwdev->dev.bus_id);
 
 	/* Check for processed buffers. */
 	iob = channel->iob;
@@ -1137,6 +1159,7 @@ lcs_tasklet(unsigned long data)
 static void
 __lcs_emit_txbuffer(struct lcs_card *card)
 {
+	LCS_DBF_TEXT(5, trace, "emittx");
 	*(__u16 *)(card->tx_buffer->data + card->tx_buffer->count) = 0;
 	card->tx_buffer->count += 2;
 	lcs_ready_buffer(&card->write, card->tx_buffer);
@@ -1152,6 +1175,7 @@ lcs_txbuffer_cb(struct lcs_channel *chan
 {
 	struct lcs_card *card;
 
+	LCS_DBF_TEXT(5, trace, "txbuffcb");
 	/* Put buffer back to pool. */
 	lcs_release_buffer(channel, buffer);
 	card = (struct lcs_card *)
@@ -1176,6 +1200,7 @@ __lcs_start_xmit(struct lcs_card *card, 
 {
 	struct lcs_header *header;
 
+	LCS_DBF_TEXT(5, trace, "hardxmit");
 	if (skb == NULL) {
 		card->stats.tx_dropped++;
 		card->stats.tx_errors++;
@@ -1201,7 +1226,6 @@ __lcs_start_xmit(struct lcs_card *card, 
 		/* Get new tx buffer */
 		card->tx_buffer = lcs_get_buffer(&card->write);
 		if (card->tx_buffer == NULL) {
-			netif_stop_queue(dev);
 			card->stats.tx_dropped++;
 			return -EBUSY;
 		}
@@ -1246,6 +1270,7 @@ lcs_startlan_auto(struct lcs_card *card)
 {
 	int rc;
 
+	LCS_DBF_TEXT(2, trace, "strtauto");
 #ifdef CONFIG_NET_ETHERNET
 	card->lan_type = LCS_FRAME_TYPE_ENET;
 	rc = lcs_send_startlan(card, LCS_INITIATOR_TCPIP);
@@ -1307,7 +1332,7 @@ lcs_detect(struct lcs_card *card)
 {
 	int rc = 0;
 
-	LCS_DBF_TEXT(3, setup," lcsdetct");
+	LCS_DBF_TEXT(2, setup, "lcsdetct");
 	/* start/reset card */
 	if (card->dev)
 		netif_stop_queue(card->dev);
@@ -1340,7 +1365,7 @@ lcs_resetcard(struct lcs_card *card)
 {
 	int retries;
 
-	LCS_DBF_TEXT(4, trace, "rescard");
+	LCS_DBF_TEXT(2, trace, "rescard");
 	for (retries = 0; retries < 10; retries++) {
 		if (lcs_detect(card) == 0) {
 			netif_wake_queue(card->dev);
@@ -1364,13 +1389,16 @@ lcs_stopcard(struct lcs_card *card)
 	int rc;
 
 	LCS_DBF_TEXT(3, setup, "stopcard");
+
 	if (card->read.state != CH_STATE_STOPPED &&
 	    card->write.state != CH_STATE_STOPPED &&
-	    card->state == DEV_STATE_UP)
+	    card->state == DEV_STATE_UP) {
 		rc = lcs_send_stoplan(card,LCS_INITIATOR_TCPIP);
-	rc = lcs_send_shutdown(card);
+		rc = lcs_send_shutdown(card);
+	}
 	rc = lcs_stop_channels(card);
 	card->state = DEV_STATE_DOWN;
+
 	return rc;
 }
 
@@ -1492,6 +1520,7 @@ lcs_start_kernel_thread(struct lcs_card 
 static void
 lcs_get_control(struct lcs_card *card, struct lcs_cmd *cmd)
 {
+	LCS_DBF_TEXT(5, trace, "getctrl");
 	if (cmd->initiator == LCS_INITIATOR_LGW) {
 		switch(cmd->cmd_code) {
 		case LCS_CMD_STARTUP:
@@ -1522,6 +1551,7 @@ lcs_get_skb(struct lcs_card *card, char 
 {
 	struct sk_buff *skb;
 
+	LCS_DBF_TEXT(5, trace, "getskb");
 	if (card->dev == NULL ||
 	    card->state != DEV_STATE_UP)
 		/* The card isn't up. Ignore the packet. */
@@ -1619,6 +1649,7 @@ lcs_stop_device(struct net_device *dev)
 	LCS_DBF_TEXT(2, trace, "stopdev");
 	card   = (struct lcs_card *) dev->priv;
 	netif_stop_queue(dev);
+	dev->flags &= ~IFF_UP;
 	rc = lcs_stopcard(card);
 	if (rc)
 		PRINT_ERR("Try it again!\n ");
@@ -1643,6 +1674,7 @@ lcs_open_device(struct net_device *dev)
 		PRINT_ERR("LCS:Error in opening device!\n");
 
 	} else {
+		dev->flags |= IFF_UP;
 		netif_wake_queue(dev);
 		card->state = DEV_STATE_UP;
 	}
@@ -1757,7 +1789,7 @@ lcs_probe_device(struct ccwgroup_device 
 	if (!get_device(&ccwgdev->dev))
 		return -ENODEV;
 
-	LCS_DBF_TEXT(3, setup, "add_dev");
+	LCS_DBF_TEXT(2, setup, "add_dev");
         card = lcs_alloc_card();
         if (!card) {
                 PRINT_ERR("Allocation of lcs card failed\n");
@@ -1772,46 +1804,62 @@ lcs_probe_device(struct ccwgroup_device 
 		return ret;
         }
 	ccwgdev->dev.driver_data = card;
-	ccwgdev->cdev[0]->dev.driver_data = card;
 	ccwgdev->cdev[0]->handler = lcs_irq;
-	ccwgdev->cdev[1]->dev.driver_data = card;
 	ccwgdev->cdev[1]->handler = lcs_irq;
         return 0;
 }
 
+static int
+lcs_register_netdev(struct ccwgroup_device *ccwgdev)
+{
+	struct lcs_card *card;
+
+	LCS_DBF_TEXT(2, setup, "regnetdv");
+	card = (struct lcs_card *)ccwgdev->dev.driver_data;
+	if (card->dev->reg_state != NETREG_UNINITIALIZED)
+		return 0;
+	SET_NETDEV_DEV(card->dev, &ccwgdev->dev);
+	return register_netdev(card->dev);
+}
+
 /**
  * lcs_new_device will be called by setting the group device online.
  */
+
 static int
 lcs_new_device(struct ccwgroup_device *ccwgdev)
 {
 	struct  lcs_card *card;
-	struct net_device *dev;
+	struct net_device *dev=NULL;
+	enum lcs_dev_states recover_state;
 	int rc;
 
 	card = (struct lcs_card *)ccwgdev->dev.driver_data;
 	if (!card)
 		return -ENODEV;
 
+	LCS_DBF_TEXT(2, setup, "newdev");
+	LCS_DBF_HEX(3, setup, &card, sizeof(void*));
 	card->read.ccwdev  = ccwgdev->cdev[0];
 	card->write.ccwdev = ccwgdev->cdev[1];
 
+	recover_state = card->state;
 	ccw_device_set_online(card->read.ccwdev);
 	ccw_device_set_online(card->write.ccwdev);
 
 	LCS_DBF_TEXT(3, setup, "lcsnewdv");
-	rc = lcs_setup_card(card);
-	if (rc) {
-		LCS_DBF_TEXT(3, setup, "errinit");
-		PRINT_ERR("LCS card Initialization failed\n");
-		return rc;
-	}
 
+	lcs_setup_card(card);
 	rc = lcs_detect(card);
 	if (rc) {
 		lcs_stopcard(card);
 		lcs_cleanup_card(card);
-		return -ENODEV;
+		goto out;
+	}
+	if (card->dev) {
+		LCS_DBF_TEXT(2, setup, "samedev");
+		LCS_DBF_HEX(3, setup, &card, sizeof(void*));
+		goto netdev_out;
 	}
 	switch (card->lan_type) {
 #ifdef CONFIG_NET_ETHERNET
@@ -1840,27 +1888,34 @@ lcs_new_device(struct ccwgroup_device *c
 	}
 	if (!dev)
 		goto out;
-	memcpy(dev->dev_addr, card->mac, LCS_MAC_LENGTH);
 	card->dev = dev;
-	dev->priv = card;
-	dev->open = lcs_open_device;
-	dev->stop = lcs_stop_device;
-	dev->hard_start_xmit = lcs_start_xmit;
+netdev_out:
+	card->dev->priv = card;
+	card->dev->open = lcs_open_device;
+	card->dev->stop = lcs_stop_device;
+	card->dev->hard_start_xmit = lcs_start_xmit;
+	card->dev->get_stats = lcs_getstats;
+	SET_MODULE_OWNER(dev);
+	if (lcs_register_netdev(ccwgdev) != 0)
+		goto out;
+	memcpy(card->dev->dev_addr, card->mac, LCS_MAC_LENGTH);
 #ifdef CONFIG_IP_MULTICAST
 	if (lcs_check_multicast_support(card))
-		dev->set_multicast_list = lcs_set_multicast_list;
+		card->dev->set_multicast_list = lcs_set_multicast_list;
 #endif
-	dev->get_stats = lcs_getstats;
-	SET_MODULE_OWNER(dev);
-	if (register_netdev(dev) != 0)
-		goto out;
-	/* Create symlinks. */
-	SET_NETDEV_DEV(dev, &ccwgdev->dev);
+	netif_stop_queue(card->dev);
+	if (recover_state == DEV_STATE_RECOVER) {
+		card->dev->flags |= IFF_UP;
+		netif_wake_queue(card->dev);
+		card->state = DEV_STATE_UP;
+	} else
+		lcs_stopcard(card);
 
-	netif_stop_queue(dev);
-	lcs_stopcard(card);
 	return 0;
 out:
+
+	ccw_device_set_offline(card->read.ccwdev);
+	ccw_device_set_offline(card->write.ccwdev);
 	lcs_cleanup_card(card);
 	return -ENODEV;
 }
@@ -1872,6 +1927,7 @@ static int
 lcs_shutdown_device(struct ccwgroup_device *ccwgdev)
 {
 	struct lcs_card *card;
+	enum lcs_dev_states recover_state;
 	int ret;
 
 	LCS_DBF_TEXT(3, setup, "shtdndev");
@@ -1879,10 +1935,17 @@ lcs_shutdown_device(struct ccwgroup_devi
 	if (!card)
 		return -ENODEV;
 
+	LCS_DBF_HEX(3, setup, &card, sizeof(void*));
+	recover_state = card->state;
+
 	ret = lcs_stop_device(card->dev);
+	ret = ccw_device_set_offline(card->read.ccwdev);
+	ret = ccw_device_set_offline(card->write.ccwdev);
+	if (recover_state == DEV_STATE_UP) {
+		card->state = DEV_STATE_RECOVER;
+	}
 	if (ret)
 		return ret;
-	unregister_netdev(card->dev);
 	return 0;
 }
 
@@ -1894,14 +1957,17 @@ lcs_remove_device(struct ccwgroup_device
 {
 	struct lcs_card *card;
 
-	LCS_DBF_TEXT(3, setup, "remdev");
 	card = (struct lcs_card *)ccwgdev->dev.driver_data;
 	if (!card)
 		return;
+
+	PRINT_INFO("Removing lcs group device ....\n");
+	LCS_DBF_TEXT(3, setup, "remdev");
+	LCS_DBF_HEX(3, setup, &card, sizeof(void*));
 	if (ccwgdev->state == CCWGROUP_ONLINE) {
-		lcs_stop_device(card->dev); /* Ignore rc. */
-		unregister_netdev(card->dev);
+		lcs_shutdown_device(ccwgdev);
 	}
+	unregister_netdev(card->dev);
 	sysfs_remove_group(&ccwgdev->dev.kobj, &lcs_attr_group);
 	lcs_cleanup_card(card);
 	lcs_free_card(card);
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/net/lcs.h linux-post-2.6.5-rc2-20040329/drivers/s390/net/lcs.h
--- linux-post-2.6.5-rc2-20040327/drivers/s390/net/lcs.h	2003-09-25 18:33:32.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/net/lcs.h	2004-03-27 11:40:46.000000000 +0000
@@ -6,19 +6,36 @@
 #include <linux/workqueue.h>
 #include <asm/ccwdev.h>
 
-#define VERSION_LCS_H "$Revision: 1.13 $"
+#define VERSION_LCS_H "$Revision: 1.15 $"
 
 #define LCS_DBF_TEXT(level, name, text) \
 	do { \
 		debug_text_event(lcs_dbf_##name, level, text); \
 	} while (0)
 
+#define LCS_DBF_HEX(level,name,addr,len) \
+do { \
+	debug_event(lcs_dbf_##name,level,(void*)(addr),len); \
+} while (0)
+
+#define LCS_DBF_TEXT_(level,name,text...) \
+do {                                       \
+	sprintf(debug_buffer, text);  \
+		debug_text_event(lcs_dbf_##name,level, debug_buffer);\
+} while (0)
+
 /**
  * some more definitions for debug or output stuff
  */
 #define PRINTK_HEADER		" lcs: "
 
 /**
+ *	sysfs related stuff
+ */
+#define CARD_FROM_DEV(cdev) \
+	(struct lcs_card *) \
+	((struct ccwgroup_device *)cdev->dev.driver_data)->dev.driver_data;
+/**
  * CCW commands used in this driver
  */
 #define LCS_CCW_WRITE		0x01
@@ -123,6 +140,7 @@ enum lcs_channel_states {
 	CH_STATE_STOPPED,
 	CH_STATE_RUNNING,
 	CH_STATE_SUSPENDED,
+	CH_STATE_CLEARED,
 };
 
 /**
@@ -131,6 +149,7 @@ enum lcs_channel_states {
 enum lcs_dev_states {
 	DEV_STATE_DOWN,
 	DEV_STATE_UP,
+	DEV_STATE_RECOVER,
 };
 
 /**
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/net/netiucv.c linux-post-2.6.5-rc2-20040329/drivers/s390/net/netiucv.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/net/netiucv.c	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/net/netiucv.c	2004-03-27 11:40:46.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * $Id: netiucv.c,v 1.45 2004/03/15 08:48:48 braunu Exp $
+ * $Id: netiucv.c,v 1.47 2004/03/22 07:41:42 braunu Exp $
  *
  * IUCV network driver
  *
@@ -30,7 +30,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV network driver $Revision: 1.45 $
+ * RELEASE-TAG: IUCV network driver $Revision: 1.47 $
  *
  */
 
@@ -764,7 +764,7 @@ conn_action_start(fsm_instance *fi, int 
 {
 	struct iucv_event *ev = (struct iucv_event *)arg;
 	struct iucv_connection *conn = ev->conn;
-
+	__u16 msglimit;
 	int rc;
 
 	pr_debug("%s() called\n", __FUNCTION__);
@@ -793,10 +793,11 @@ conn_action_start(fsm_instance *fi, int 
 
 	fsm_newstate(fi, CONN_STATE_SETUPWAIT);
 	rc = iucv_connect(&(conn->pathid), NETIUCV_QUEUELEN_DEFAULT, iucvMagic,
-			  conn->userid, iucv_host, 0, NULL, NULL, conn->handle,
+			  conn->userid, iucv_host, 0, NULL, &msglimit, conn->handle,
 			  conn);
 	switch (rc) {
 		case 0:
+			conn->netdev->tx_queue_len = msglimit;
 			return;
 		case 11:
 			printk(KERN_NOTICE
@@ -1911,7 +1912,7 @@ static struct device_driver netiucv_driv
 static void
 netiucv_banner(void)
 {
-	char vbuf[] = "$Revision: 1.45 $";
+	char vbuf[] = "$Revision: 1.47 $";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/net/qeth.c linux-post-2.6.5-rc2-20040329/drivers/s390/net/qeth.c
--- linux-post-2.6.5-rc2-20040327/drivers/s390/net/qeth.c	2004-03-17 12:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/net/qeth.c	2004-03-27 11:40:46.000000000 +0000
@@ -755,7 +755,7 @@ qeth_get_cards_problem(struct ccw_device
 	int problem = 0;
 	struct qeth_card *card;
 
-	card = cdev->dev.driver_data;
+	card = CARD_FROM_CDEV(cdev);
 
 	if (atomic_read(&card->shutdown_phase))
 		return 0;
@@ -6105,7 +6105,7 @@ qeth_interrupt_handler_read(struct ccw_d
 	sprintf(dbf_text, "%4x", rqparam);
 	QETH_DBF_TEXT4(0, trace, dbf_text);
 
-	card = cdev->dev.driver_data;
+	card = CARD_FROM_CDEV(cdev);
 	if (!card)
 		return;
 
@@ -6231,7 +6231,7 @@ qeth_interrupt_handler_write(struct ccw_
 	sprintf(dbf_text, "%4x", rqparam);
 	QETH_DBF_TEXT4(0, trace, dbf_text);
 
-	card = cdev->dev.driver_data;
+	card = CARD_FROM_CDEV(cdev);
 	if (!card)
 		return;
 
@@ -6343,7 +6343,7 @@ qeth_interrupt_handler_qdio(struct ccw_d
 	sprintf(dbf_text, "%4x", rqparam);
 	QETH_DBF_TEXT4(0, trace, dbf_text);
 
-	card = cdev->dev.driver_data;
+	card = CARD_FROM_CDEV(cdev);
 	if (!card)
 		return;
 
@@ -10620,13 +10620,10 @@ qeth_probe_device(struct ccwgroup_device
 	card->gdev = gdev;
 
 	gdev->cdev[0]->handler = qeth_interrupt_handler_read;
-	gdev->cdev[0]->dev.driver_data = card;
 
 	gdev->cdev[1]->handler = qeth_interrupt_handler_write;
-	gdev->cdev[1]->dev.driver_data = card;
 
 	gdev->cdev[2]->handler = qeth_interrupt_handler_qdio;
-	gdev->cdev[2]->dev.driver_data = card;
 
 	ret = __qeth_create_attributes(&gdev->dev);
 	if (ret != 0)
diff -purN linux-post-2.6.5-rc2-20040327/drivers/s390/net/qeth.h linux-post-2.6.5-rc2-20040329/drivers/s390/net/qeth.h
--- linux-post-2.6.5-rc2-20040327/drivers/s390/net/qeth.h	2004-01-19 06:35:56.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/s390/net/qeth.h	2004-03-27 11:40:46.000000000 +0000
@@ -696,6 +696,8 @@ struct sparebufs {
 #define CARD_RDEV_ID(card) card->gdev->cdev[0]->dev.bus_id
 #define CARD_WDEV_ID(card) card->gdev->cdev[1]->dev.bus_id
 #define CARD_DDEV_ID(card) card->gdev->cdev[2]->dev.bus_id
+#define CARD_FROM_CDEV(cdev) (struct qeth_card *) \
+	((struct ccwgroup_device *) cdev->dev.driver_data)->dev.driver_data
 
 #define SENSE_COMMAND_REJECT_BYTE 0
 #define SENSE_COMMAND_REJECT_FLAG 0x80
diff -purN linux-post-2.6.5-rc2-20040327/drivers/usb/core/message.c linux-post-2.6.5-rc2-20040329/drivers/usb/core/message.c
--- linux-post-2.6.5-rc2-20040327/drivers/usb/core/message.c	2004-03-03 12:48:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/drivers/usb/core/message.c	2004-03-24 10:17:04.000000000 +0000
@@ -794,9 +794,6 @@ void usb_disable_interface(struct usb_de
 
 static void release_interface(struct device *dev)
 {
-	struct usb_interface *interface = to_usb_interface(dev);
-
-	complete(interface->released);
 }
 
 /*
@@ -828,16 +825,12 @@ void usb_disable_device(struct usb_devic
 	if (dev->actconfig) {
 		for (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {
 			struct usb_interface	*interface;
-			struct completion	intf_completion;
 
 			/* remove this interface */
 			interface = dev->actconfig->interface[i];
 			dev_dbg (&dev->dev, "unregistering interface %s\n",
 				interface->dev.bus_id);
-			init_completion (&intf_completion);
-			interface->released = &intf_completion;
 			device_unregister (&interface->dev);
-			wait_for_completion (&intf_completion);
 		}
 		dev->actconfig = 0;
 		if (dev->state == USB_STATE_CONFIGURED)
diff -purN linux-post-2.6.5-rc2-20040327/fs/compat.c linux-post-2.6.5-rc2-20040329/fs/compat.c
--- linux-post-2.6.5-rc2-20040327/fs/compat.c	2004-02-25 16:06:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/fs/compat.c	2004-03-26 19:05:31.000000000 +0000
@@ -27,6 +27,9 @@
 #include <linux/ioctl32.h>
 #include <linux/init.h>
 #include <linux/sockios.h>	/* for SIOCDEVPRIVATE */
+#include <linux/smb.h>
+#include <linux/smb_mount.h>
+#include <linux/ncp_mount.h>
 #include <linux/smp_lock.h>
 #include <linux/syscalls.h>
 #include <linux/ctype.h>
@@ -642,3 +645,152 @@ compat_sys_io_submit(aio_context_t ctx_i
 		ret = sys_io_submit(ctx_id, nr, iocb64);
 	return ret;
 }
+
+struct compat_ncp_mount_data {
+	compat_int_t version;
+	compat_uint_t ncp_fd;
+	compat_uid_t mounted_uid;
+	compat_pid_t wdog_pid;
+	unsigned char mounted_vol[NCP_VOLNAME_LEN + 1];
+	compat_uint_t time_out;
+	compat_uint_t retry_count;
+	compat_uint_t flags;
+	compat_uid_t uid;
+	compat_gid_t gid;
+	compat_mode_t file_mode;
+	compat_mode_t dir_mode;
+};
+
+struct compat_ncp_mount_data_v4 {
+	compat_int_t version;
+	compat_ulong_t flags;
+	compat_ulong_t mounted_uid;
+	compat_long_t wdog_pid;
+	compat_uint_t ncp_fd;
+	compat_uint_t time_out;
+	compat_uint_t retry_count;
+	compat_ulong_t uid;
+	compat_ulong_t gid;
+	compat_ulong_t file_mode;
+	compat_ulong_t dir_mode;
+};
+
+static void *do_ncp_super_data_conv(void *raw_data)
+{
+	int version = *(unsigned int *)raw_data;
+
+	if (version == 3) {
+		struct compat_ncp_mount_data *c_n = raw_data;
+		struct ncp_mount_data *n = raw_data;
+
+		n->dir_mode = c_n->dir_mode;
+		n->file_mode = c_n->file_mode;
+		n->gid = c_n->gid;
+		n->uid = c_n->uid;
+		memmove (n->mounted_vol, c_n->mounted_vol, (sizeof (c_n->mounted_vol) + 3 * sizeof (unsigned int)));
+		n->wdog_pid = c_n->wdog_pid;
+		n->mounted_uid = c_n->mounted_uid;
+	} else if (version == 4) {
+		struct compat_ncp_mount_data_v4 *c_n = raw_data;
+		struct ncp_mount_data_v4 *n = raw_data;
+
+		n->dir_mode = c_n->dir_mode;
+		n->file_mode = c_n->file_mode;
+		n->gid = c_n->gid;
+		n->uid = c_n->uid;
+		n->retry_count = c_n->retry_count;
+		n->time_out = c_n->time_out;
+		n->ncp_fd = c_n->ncp_fd;
+		n->wdog_pid = c_n->wdog_pid;
+		n->mounted_uid = c_n->mounted_uid;
+		n->flags = c_n->flags;
+	} else if (version != 5) {
+		return NULL;
+	}
+
+	return raw_data;
+}
+
+struct compat_smb_mount_data {
+	compat_int_t version;
+	compat_uid_t mounted_uid;
+	compat_uid_t uid;
+	compat_gid_t gid;
+	compat_mode_t file_mode;
+	compat_mode_t dir_mode;
+};
+
+static void *do_smb_super_data_conv(void *raw_data)
+{
+	struct smb_mount_data *s = raw_data;
+	struct compat_smb_mount_data *c_s = raw_data;
+
+	if (c_s->version != SMB_MOUNT_OLDVERSION)
+		goto out;
+	s->dir_mode = c_s->dir_mode;
+	s->file_mode = c_s->file_mode;
+	s->gid = c_s->gid;
+	s->uid = c_s->uid;
+	s->mounted_uid = c_s->mounted_uid;
+ out:
+	return raw_data;
+}
+
+extern int copy_mount_options (const void __user *, unsigned long *);
+
+#define SMBFS_NAME      "smbfs"
+#define NCPFS_NAME      "ncpfs"
+
+asmlinkage int compat_sys_mount(char __user * dev_name, char __user * dir_name,
+				char __user * type, unsigned long flags,
+				void __user * data)
+{
+	unsigned long type_page;
+	unsigned long data_page;
+	unsigned long dev_page;
+	char *dir_page;
+	int retval;
+
+	retval = copy_mount_options (type, &type_page);
+	if (retval < 0)
+		goto out;
+
+	dir_page = getname(dir_name);
+	retval = PTR_ERR(dir_page);
+	if (IS_ERR(dir_page))
+		goto out1;
+
+	retval = copy_mount_options (dev_name, &dev_page);
+	if (retval < 0)
+		goto out2;
+
+	retval = copy_mount_options (data, &data_page);
+	if (retval < 0)
+		goto out3;
+
+	retval = -EINVAL;
+
+	if (type_page) {
+		if (!strcmp((char *)type_page, SMBFS_NAME)) {
+			do_smb_super_data_conv((void *)data_page);
+		} else if (!strcmp((char *)type_page, NCPFS_NAME)) {
+			do_ncp_super_data_conv((void *)data_page);
+		}
+	}
+
+	lock_kernel();
+	retval = do_mount((char*)dev_page, dir_page, (char*)type_page,
+			flags, (void*)data_page);
+	unlock_kernel();
+
+	free_page(data_page);
+ out3:
+	free_page(dev_page);
+ out2:
+	putname(dir_page);
+ out1:
+	free_page(type_page);
+ out:
+	return retval;
+}
+
diff -purN linux-post-2.6.5-rc2-20040327/fs/compat_ioctl.c linux-post-2.6.5-rc2-20040329/fs/compat_ioctl.c
--- linux-post-2.6.5-rc2-20040327/fs/compat_ioctl.c	2004-03-22 06:53:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/fs/compat_ioctl.c	2004-03-25 01:14:27.000000000 +0000
@@ -3070,6 +3070,20 @@ static int do_wireless_ioctl(unsigned in
 	return sys_ioctl(fd, cmd, (unsigned long) iwr);
 }
 
+/* Emulate old style bridge ioctls */
+static int do_bridge_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	u32 tmp;
+	unsigned long *argbuf = compat_alloc_user_space(3 * sizeof(unsigned long)); 
+	int i;	
+	for (i = 0; i < 3; i++) {
+		if (get_user(tmp, i + ((u32 *)arg)) ||
+		    put_user(tmp, i + argbuf))
+			return -EFAULT;
+	}
+	return sys_ioctl(fd, cmd, (unsigned long)argbuf);
+}
+
 #undef CODE
 #endif
 
@@ -3247,6 +3261,8 @@ HANDLE_IOCTL(SIOCSIWNICKN, do_wireless_i
 HANDLE_IOCTL(SIOCGIWNICKN, do_wireless_ioctl)
 HANDLE_IOCTL(SIOCSIWENCODE, do_wireless_ioctl)
 HANDLE_IOCTL(SIOCGIWENCODE, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCSIFBR, do_bridge_ioctl)
+HANDLE_IOCTL(SIOCGIFBR, do_bridge_ioctl)
 
 #undef DECLARES
 #endif
diff -purN linux-post-2.6.5-rc2-20040327/fs/namespace.c linux-post-2.6.5-rc2-20040329/fs/namespace.c
--- linux-post-2.6.5-rc2-20040327/fs/namespace.c	2004-03-18 22:54:21.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/fs/namespace.c	2004-03-26 19:05:31.000000000 +0000
@@ -694,7 +694,7 @@ out:
 	return err;
 }
 
-static int copy_mount_options (const void __user *data, unsigned long *where)
+int copy_mount_options (const void __user *data, unsigned long *where)
 {
 	int i;
 	unsigned long page;
diff -purN linux-post-2.6.5-rc2-20040327/fs/nfsd/nfs3xdr.c linux-post-2.6.5-rc2-20040329/fs/nfsd/nfs3xdr.c
--- linux-post-2.6.5-rc2-20040327/fs/nfsd/nfs3xdr.c	2004-02-27 05:33:07.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/fs/nfsd/nfs3xdr.c	2004-03-29 00:26:21.000000000 +0000
@@ -884,10 +884,11 @@ encode_entry(struct readdir_cd *ccd, con
 		if (plus) {
 			struct svc_fh	fh;
 
-			if (compose_entry_fh(cd, &fh, name, namlen) > 0)
-				goto noexec;
-
-			p = encode_entryplus_baggage(cd, p, &fh);
+			if (compose_entry_fh(cd, &fh, name, namlen) > 0) {
+				*p++ = 0;
+				*p++ = 0;
+			} else
+				p = encode_entryplus_baggage(cd, p, &fh);
 		}
 		num_entry_words = p - cd->buffer;
 	} else if (cd->rqstp->rq_respages[pn+1] != NULL) {
@@ -916,7 +917,7 @@ encode_entry(struct readdir_cd *ccd, con
 		/* determine entry word length and lengths to go in pages */
 		num_entry_words = p1 - tmp;
 		len1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;
-		if ((num_entry_words << 2) <= len1) {
+		if ((num_entry_words << 2) < len1) {
 			/* the actual number of words in the entry is less
 			 * than elen and can still fit in the current page
 			 */
@@ -945,16 +946,11 @@ encode_entry(struct readdir_cd *ccd, con
 		return -EINVAL;
 	}
 
-out:
 	cd->buflen -= num_entry_words;
 	cd->buffer = p;
 	cd->common.err = nfs_ok;
 	return 0;
 
-noexec:
-	*p++ = 0;
-	*p++ = 0;
-	goto out;
 }
 
 int
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-i386/node.h linux-post-2.6.5-rc2-20040329/include/asm-i386/node.h
--- linux-post-2.6.5-rc2-20040327/include/asm-i386/node.h	2003-06-06 06:36:55.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-i386/node.h	2004-03-26 11:31:18.000000000 +0000
@@ -12,9 +12,13 @@ struct i386_node {
 extern struct i386_node node_devices[MAX_NUMNODES];
 
 static inline int arch_register_node(int num){
-	int p_node = parent_node(num);
+	int p_node;
 	struct node *parent = NULL;
 
+	if (!node_online(num))
+		return 0;
+	p_node = parent_node(num);
+
 	if (p_node != num)
 		parent = &node_devices[p_node].node;
 
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-s390/elf.h linux-post-2.6.5-rc2-20040329/include/asm-s390/elf.h
--- linux-post-2.6.5-rc2-20040327/include/asm-s390/elf.h	2003-07-01 20:48:27.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-s390/elf.h	2004-03-27 11:40:46.000000000 +0000
@@ -155,9 +155,31 @@ typedef s390_regs elf_gregset_t;
 /* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
    now struct_user_regs, they are different) */
 
-#define ELF_CORE_COPY_REGS(pr_reg, regs)	\
-	memcpy(&pr_reg,regs,sizeof(elf_gregset_t)); \
+static inline int dump_regs(struct pt_regs *ptregs, elf_gregset_t *regs)
+{
+	memcpy(&regs->psw, &ptregs->psw, sizeof(regs->psw)+sizeof(regs->gprs));
+	regs->orig_gpr2 = ptregs->orig_gpr2;
+	return 1;
+}
+
+#define ELF_CORE_COPY_REGS(pr_reg, regs) dump_regs(regs, &pr_reg);
+
+static inline int dump_task_regs(struct task_struct *tsk, elf_gregset_t *regs)
+{
+	dump_regs(__KSTK_PTREGS(tsk), regs);
+	memcpy(regs->acrs, tsk->thread.acrs, sizeof(regs->acrs));
+	return 1;
+}
+
+#define ELF_CORE_COPY_TASK_REGS(tsk, regs) dump_task_regs(tsk, regs)
+
+static inline int dump_task_fpu(struct task_struct *tsk, elf_fpregset_t *fpregs)
+{
+	memcpy(fpregs, &tsk->thread.fp_regs, sizeof(elf_fpregset_t));
+	return 1;
+}
 
+#define ELF_CORE_COPY_FPREGS(tsk, fpregs) dump_task_fpu(tsk, fpregs)
 
 
 /* This yields a mask that user programs can use to figure out what
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-s390/lowcore.h linux-post-2.6.5-rc2-20040329/include/asm-s390/lowcore.h
--- linux-post-2.6.5-rc2-20040327/include/asm-s390/lowcore.h	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-s390/lowcore.h	2004-03-27 11:40:46.000000000 +0000
@@ -64,7 +64,10 @@
 
 #ifndef __s390x__
 #define __LC_KERNEL_STACK               0xC40
-#define __LC_ASYNC_STACK                0xC44
+#define __LC_THREAD_INFO		0xC44
+#define __LC_ASYNC_STACK                0xC48
+#define __LC_KERNEL_ASCE		0xC4C
+#define __LC_USER_ASCE			0xC50
 #define __LC_CPUID                      0xC60
 #define __LC_CPUADDR                    0xC68
 #define __LC_IPLDEV                     0xC7C
@@ -73,13 +76,16 @@
 #define __LC_INT_CLOCK			0xC98
 #else /* __s390x__ */
 #define __LC_KERNEL_STACK               0xD40
-#define __LC_ASYNC_STACK                0xD48
+#define __LC_THREAD_INFO		0xD48
+#define __LC_ASYNC_STACK                0xD50
+#define __LC_KERNEL_ASCE		0xD58
+#define __LC_USER_ASCE			0xD60
 #define __LC_CPUID                      0xD90
 #define __LC_CPUADDR                    0xD98
 #define __LC_IPLDEV                     0xDB8
 #define __LC_JIFFY_TIMER		0xDC0
 #define __LC_CURRENT			0xDD8
-#define __LC_INT_CLOCK			0xDE8
+#define __LC_INT_CLOCK			0xDe8
 #endif /* __s390x__ */
 
 #define __LC_PANIC_MAGIC                0xE00
@@ -99,7 +105,6 @@
 #include <linux/config.h>
 #include <asm/processor.h>
 #include <linux/types.h>
-#include <asm/atomic.h>
 #include <asm/sigp.h>
 
 void restart_int_handler(void);
@@ -167,9 +172,12 @@ struct _lowcore
         /* System info area */
 	__u32        save_area[16];            /* 0xc00 */
 	__u32        kernel_stack;             /* 0xc40 */
-	__u32        async_stack;              /* 0xc44 */
+	__u32        thread_info;              /* 0xc44 */
+	__u32        async_stack;              /* 0xc48 */
+	__u32        kernel_asce;              /* 0xc4c */
+	__u32        user_asce;                /* 0xc50 */
+	__u8         pad10[0xc60-0xc54];       /* 0xc54 */
 	/* entry.S sensitive area start */
-	__u8         pad10[0xc60-0xc48];       /* 0xc5c */
 	struct       cpuinfo_S390 cpu_data;    /* 0xc60 */
 	__u32        ipl_device;               /* 0xc7c */
 	/* entry.S sensitive area end */
@@ -245,9 +253,12 @@ struct _lowcore
 	__u64        save_area[16];            /* 0xc00 */
         __u8         pad9[0xd40-0xc80];        /* 0xc80 */
  	__u64        kernel_stack;             /* 0xd40 */
-	__u64        async_stack;              /* 0xd48 */
+	__u64        thread_info;              /* 0xd48 */
+	__u64        async_stack;              /* 0xd50 */
+	__u64        kernel_asce;              /* 0xd58 */
+	__u64        user_asce;                /* 0xd60 */
+	__u8         pad10[0xd80-0xd68];       /* 0xd68 */
 	/* entry.S sensitive area start */
-	__u8         pad10[0xd80-0xd50];       /* 0xd64 */
 	struct       cpuinfo_S390 cpu_data;    /* 0xd80 */
 	__u32        ipl_device;               /* 0xdb8 */
 	__u32        pad11;                    /* 0xdbc */
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-s390/mmu_context.h linux-post-2.6.5-rc2-20040329/include/asm-s390/mmu_context.h
--- linux-post-2.6.5-rc2-20040327/include/asm-s390/mmu_context.h	2004-01-19 06:35:53.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-s390/mmu_context.h	2004-03-27 11:40:46.000000000 +0000
@@ -24,22 +24,19 @@ static inline void enter_lazy_tlb(struct
 static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
                              struct task_struct *tsk)
 {
-        unsigned long pgd;
-
         if (prev != next) {
 #ifndef __s390x__
-	        pgd = (__pa(next->pgd)&PAGE_MASK) | 
+	        S390_lowcore.user_asce = (__pa(next->pgd)&PAGE_MASK) |
                       (_SEGMENT_TABLE|USER_STD_MASK);
-                /* Load page tables */
-                asm volatile("    lctl  7,7,%0\n"   /* secondary space */
-                             "    lctl  13,13,%0\n" /* home space */
-                             : : "m" (pgd) );
+                /* Load home space page table origin. */
+                asm volatile("lctl  13,13,%0"
+			     : : "m" (S390_lowcore.user_asce) );
 #else /* __s390x__ */
-                pgd = (__pa(next->pgd)&PAGE_MASK) | (_REGION_TABLE|USER_STD_MASK);
-                /* Load page tables */
-                asm volatile("    lctlg 7,7,%0\n"   /* secondary space */
-                             "    lctlg 13,13,%0\n" /* home space */
-                             : : "m" (pgd) );
+                S390_lowcore.user_asce = (__pa(next->pgd) & PAGE_MASK) |
+			(_REGION_TABLE|USER_STD_MASK);
+		/* Load home space page table origin. */
+		asm volatile("lctlg  13,13,%0"
+			     : : "m" (S390_lowcore.user_asce) );
 #endif /* __s390x__ */
         }
 	cpu_set(smp_processor_id(), next->cpu_vm_mask);
@@ -51,6 +48,7 @@ extern inline void activate_mm(struct mm
                                struct mm_struct *next)
 {
         switch_mm(prev, next, current);
+	set_fs(current->thread.mm_segment);
 }
 
 #endif
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-s390/processor.h linux-post-2.6.5-rc2-20040329/include/asm-s390/processor.h
--- linux-post-2.6.5-rc2-20040327/include/asm-s390/processor.h	2004-01-31 08:15:34.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-s390/processor.h	2004-03-27 11:40:46.000000000 +0000
@@ -82,10 +82,10 @@ typedef struct {
  */
 struct thread_struct {
 	s390_fp_regs fp_regs;
-	unsigned int ar2;		/* kernel access register 2         */
-        unsigned int ar4;               /* kernel access register 4         */
+	unsigned int  acrs[NUM_ACRS];
         unsigned long ksp;              /* kernel stack pointer             */
         unsigned long user_seg;         /* HSTD                             */
+	mm_segment_t mm_segment;
         unsigned long prot_addr;        /* address of protection-excep.     */
         unsigned int error_code;        /* error-code of last prog-excep.   */
         unsigned int trap_no;
@@ -106,9 +106,10 @@ typedef struct thread_struct thread_stru
 
 #define INIT_THREAD {{0,{{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},	       \
 			    {0},{0},{0},{0},{0},{0}}},			       \
-		     0, 0,						       \
+		     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},	       \
 		     sizeof(init_stack) + (unsigned long) &init_stack,	       \
 		     __SWAPPER_PG_DIR,					       \
+		     {0},						       \
 		     0,0,0,						       \
 		     (per_struct) {{{{0,}}},0,0,0,0,{{0,}}},		       \
 		     0, 0						       \
@@ -167,7 +168,7 @@ extern void show_trace(struct task_struc
 
 unsigned long get_wchan(struct task_struct *p);
 #define __KSTK_PTREGS(tsk) ((struct pt_regs *) \
-        (((unsigned long) tsk->thread_info + THREAD_SIZE - sizeof(struct pt_regs)) & -8L))
+        ((unsigned long) tsk->thread_info + THREAD_SIZE - sizeof(struct pt_regs)))
 #define KSTK_EIP(tsk)	(__KSTK_PTREGS(tsk)->psw.addr)
 #define KSTK_ESP(tsk)	(__KSTK_PTREGS(tsk)->gprs[15])
 
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-s390/ptrace.h linux-post-2.6.5-rc2-20040329/include/asm-s390/ptrace.h
--- linux-post-2.6.5-rc2-20040327/include/asm-s390/ptrace.h	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-s390/ptrace.h	2004-03-27 11:40:46.000000000 +0000
@@ -286,10 +286,7 @@ typedef struct 
 	 ((NEW) & (PSW_MASK_CC|PSW_MASK_PM)))
 
 /*
- * The first entries in pt_regs and user_regs_struct
- * are common for the two structures. The s390_regs structure
- * covers the common parts. It simplifies copying the common part
- * between the three structures.
+ * The s390_regs structure is used to define the elf_gregset_t.
  */
 typedef struct
 {
@@ -299,6 +296,7 @@ typedef struct
 	unsigned long orig_gpr2;
 } s390_regs;
 
+#ifdef __KERNEL__
 /*
  * The pt_regs struct defines the way the registers are stored on
  * the stack during a system call.
@@ -307,11 +305,11 @@ struct pt_regs 
 {
 	psw_t psw;
 	unsigned long gprs[NUM_GPRS];
-	unsigned int  acrs[NUM_ACRS];
 	unsigned long orig_gpr2;
 	unsigned short ilc;
 	unsigned short trap;
-} __attribute__ ((packed));
+};
+#endif
 
 /*
  * Now for the program event recording (trace) definitions.
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-s390/spinlock.h linux-post-2.6.5-rc2-20040329/include/asm-s390/spinlock.h
--- linux-post-2.6.5-rc2-20040327/include/asm-s390/spinlock.h	2004-01-31 08:15:34.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-s390/spinlock.h	2004-03-27 11:40:45.000000000 +0000
@@ -35,13 +35,8 @@
  */
 
 typedef struct {
-#ifndef __s390x__
-	volatile unsigned long lock;
-} spinlock_t;
-#else /* __s390x__ */
 	volatile unsigned int lock;
 } __attribute__ ((aligned (4))) spinlock_t;
-#endif /* __s390x__ */
 
 #define SPIN_LOCK_UNLOCKED (spinlock_t) { 0 }
 #define spin_lock_init(lp) do { (lp)->lock = 0; } while(0)
@@ -80,11 +75,10 @@ extern inline int _raw_spin_trylock(spin
 #else /* __s390x__ */
 	unsigned int result, reg;
 #endif /* __s390x__ */
-	__asm__ __volatile("    slr   %0,%0\n"
-			   "    basr  %1,0\n"
+	__asm__ __volatile("    basr  %1,0\n"
 			   "0:  cs    %0,%1,0(%3)"
-			   : "=&d" (result), "=&d" (reg), "=m" (lp->lock)
-			   : "a" (&lp->lock), "m" (lp->lock)
+			   : "=d" (result), "=&d" (reg), "=m" (lp->lock)
+			   : "a" (&lp->lock), "m" (lp->lock), "0" (0)
 			   : "cc", "memory" );
 	return !result;
 }
@@ -224,17 +218,15 @@ extern inline int _raw_write_trylock(rwl
 	
 	__asm__ __volatile__(
 #ifndef __s390x__
-			     "   slr  %0,%0\n"
 			     "   lhi  %1,1\n"
 			     "   sll  %1,31\n"
 			     "   cs   %0,%1,0(%3)"
 #else /* __s390x__ */
-			     "   slgr  %0,%0\n"
 			     "   llihh %1,0x8000\n"
 			     "0: csg %0,%1,0(%3)\n"
 #endif /* __s390x__ */
-			     : "=&d" (result), "=&d" (reg), "=m" (rw->lock)
-			     : "a" (&rw->lock), "m" (rw->lock)
+			     : "=d" (result), "=&d" (reg), "=m" (rw->lock)
+			     : "a" (&rw->lock), "m" (rw->lock), "0" (0)
 			     : "cc", "memory" );
 	return result == 0;
 }
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-s390/system.h linux-post-2.6.5-rc2-20040329/include/asm-s390/system.h
--- linux-post-2.6.5-rc2-20040327/include/asm-s390/system.h	2004-01-31 08:15:34.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-s390/system.h	2004-03-27 11:40:46.000000000 +0000
@@ -83,14 +83,33 @@ static inline void restore_fp_regs(s390_
 		: : "a" (fpregs), "m" (*fpregs) );
 }
 
+static inline void save_access_regs(unsigned int *acrs)
+{
+	asm volatile ("stam 0,15,0(%0)" : : "a" (acrs) : "memory" );
+}
+
+static inline void restore_access_regs(unsigned int *acrs)
+{
+	asm volatile ("lam 0,15,0(%0)" : : "a" (acrs) );
+}
+
 #define switch_to(prev,next,last) do {					     \
 	if (prev == next)						     \
 		break;							     \
 	save_fp_regs(&prev->thread.fp_regs);				     \
 	restore_fp_regs(&next->thread.fp_regs);				     \
+	save_access_regs(&prev->thread.acrs[0]);			     \
+	restore_access_regs(&next->thread.acrs[0]);			     \
 	prev = __switch_to(prev,next);					     \
 } while (0)
 
+#define prepare_arch_switch(rq, next)	do { } while(0)
+#define task_running(rq, p)		((rq)->curr == (p))
+#define finish_arch_switch(rq, prev) do {				     \
+	set_fs(current->thread.mm_segment);				     \
+	spin_unlock_irq(&(rq)->lock);					     \
+} while (0)
+
 #define nop() __asm__ __volatile__ ("nop")
 
 #define xchg(ptr,x) \
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-s390/uaccess.h linux-post-2.6.5-rc2-20040329/include/asm-s390/uaccess.h
--- linux-post-2.6.5-rc2-20040327/include/asm-s390/uaccess.h	2004-01-31 08:15:34.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-s390/uaccess.h	2004-03-27 11:40:46.000000000 +0000
@@ -36,10 +36,27 @@
 #define USER_DS         MAKE_MM_SEG(1)
 
 #define get_ds()        (KERNEL_DS)
-#define get_fs()        ({ mm_segment_t __x; \
-			   asm volatile("ear   %0,4":"=a" (__x)); \
-			   __x;})
-#define set_fs(x)       ({asm volatile("sar   4,%0"::"a" ((x).ar4));})
+#define get_fs()        (current->thread.mm_segment)
+
+#ifdef __s390x__
+#define set_fs(x) \
+({									\
+	unsigned long __pto;						\
+	current->thread.mm_segment = (x);				\
+	__pto = current->thread.mm_segment.ar4 ?			\
+		S390_lowcore.user_asce : S390_lowcore.kernel_asce;	\
+	asm volatile ("lctlg 7,7,%0" : : "m" (__pto) );			\
+})
+#else
+#define set_fs(x) \
+({									\
+	unsigned long __pto;						\
+	current->thread.mm_segment = (x);				\
+	__pto = current->thread.mm_segment.ar4 ?			\
+		S390_lowcore.user_asce : S390_lowcore.kernel_asce;	\
+	asm volatile ("lctl  7,7,%0" : : "m" (__pto) );			\
+})
+#endif
 
 #define segment_eq(a,b) ((a).ar4 == (b).ar4)
 
@@ -71,126 +88,64 @@ struct exception_table_entry
         unsigned long insn, fixup;
 };
 
-/*
- * Standard fixup section for uaccess inline functions.
- * local label 0: is the fault point
- * local label 1: is the return point
- * %0 is the error variable
- * %3 is the error value -EFAULT
- */
 #ifndef __s390x__
 #define __uaccess_fixup \
 	".section .fixup,\"ax\"\n"	\
-	"8: sacf  0\n"			\
-	"   lhi	  %0,%h3\n"		\
-	"   bras  4,9f\n"		\
-	"   .long 1b\n"			\
-	"9: l	  4,0(4)\n"		\
-	"   br	  4\n"			\
+	"2: lhi    %0,%4\n"		\
+	"   bras   1,3f\n"		\
+	"   .long  1b\n"		\
+	"3: l      1,0(1)\n"		\
+	"   br     1\n"			\
 	".previous\n"			\
 	".section __ex_table,\"a\"\n"	\
 	"   .align 4\n"			\
-	"   .long  0b,8b\n"		\
+	"   .long  0b,2b\n"		\
 	".previous"
+#define __uaccess_clobber "cc", "1"
 #else /* __s390x__ */
 #define __uaccess_fixup \
 	".section .fixup,\"ax\"\n"	\
-	"9: sacf  0\n"			\
-	"   lhi	  %0,%h3\n"		\
-	"   jg	  1b\n"			\
+	"2: lghi   %0,%4\n"		\
+	"   jg     1b\n"		\
 	".previous\n"			\
 	".section __ex_table,\"a\"\n"	\
 	"   .align 8\n"			\
-	"   .quad  0b,9b\n"		\
+	"   .quad  0b,2b\n"		\
 	".previous"
+#define __uaccess_clobber "cc"
 #endif /* __s390x__ */
 
 /*
  * These are the main single-value transfer routines.  They automatically
  * use the right size if we just have the right pointer type.
  */
-#ifndef __s390x__
-
-#define __put_user_asm_8(x, ptr, err) \
-({								\
-	register __typeof__(x) const * __from asm("2");		\
-	register __typeof__(*(ptr)) * __to asm("4");		\
-	__from = &(x);						\
-	__to = (ptr);						\
-	__asm__ __volatile__ (					\
-		"   sacf  512\n"				\
-		"0: mvc	  0(8,%1),0(%2)\n"			\
-		"   sacf  0\n"					\
-		"1:\n"						\
-		__uaccess_fixup					\
-		: "=&d" (err)					\
-		: "a" (__to),"a" (__from),"K" (-EFAULT),"0" (0),\
-		  "m" (x) : "cc" );				\
-})
-
-#else /* __s390x__ */
-
-#define __put_user_asm_8(x, ptr, err) \
-({								\
-	register __typeof__(*(ptr)) * __ptr asm("4");		\
-	__ptr = (ptr);						\
-	__asm__ __volatile__ (					\
-		"   sacf  512\n"				\
-		"0: stg	  %2,0(%1)\n"				\
-		"   sacf  0\n"					\
-		"1:\n"						\
-		__uaccess_fixup					\
-		: "=&d" (err)					\
-		: "a" (__ptr), "d" (x), "K" (-EFAULT), "0" (0)	\
-		: "cc" );					\
-})
-
-#endif /* __s390x__ */
-
-#define __put_user_asm_4(x, ptr, err) \
-({								\
-	register __typeof__(*(ptr)) * __ptr asm("4");		\
-	__ptr = (ptr);						\
-	__asm__ __volatile__ (					\
-		"   sacf  512\n"				\
-		"0: st	  %2,0(%1)\n"				\
-		"   sacf  0\n"					\
-		"1:\n"						\
-		__uaccess_fixup					\
-		: "=&d" (err)					\
-		: "a" (__ptr), "d" (x), "K" (-EFAULT), "0" (0)	\
-		: "cc" );					\
-})
-
-#define __put_user_asm_2(x, ptr, err) \
+#if __GNUC__ > 2
+#define __put_user_asm(x, ptr, err) \
 ({								\
-	register __typeof__(*(ptr)) * __ptr asm("4");		\
-	__ptr = (ptr);						\
-	__asm__ __volatile__ (					\
-		"   sacf  512\n"				\
-		"0: sth	  %2,0(%1)\n"				\
-		"   sacf  0\n"					\
+	err = 0;						\
+	asm volatile(						\
+		"0: mvcs  0(%1,%2),%3,%0\n"			\
 		"1:\n"						\
 		__uaccess_fixup					\
-		: "=&d" (err)					\
-		: "a" (__ptr), "d" (x), "K" (-EFAULT), "0" (0)	\
-		: "cc" );					\
+		: "+&d" (err)					\
+		: "d" (sizeof(*(ptr))), "a" (ptr), "Q" (x),	\
+		  "K" (-EFAULT)					\
+		: __uaccess_clobber );				\
 })
-
-#define __put_user_asm_1(x, ptr, err) \
+#else
+#define __put_user_asm(x, ptr, err) \
 ({								\
-	register __typeof__(*(ptr)) * __ptr asm("4");		\
-	__ptr = (ptr);						\
-	__asm__ __volatile__ (					\
-		"   sacf  512\n"				\
-		"0: stc	  %2,0(%1)\n"				\
-		"   sacf  0\n"					\
+	err = 0;						\
+	asm volatile(						\
+		"0: mvcs  0(%1,%2),0(%3),%0\n"			\
 		"1:\n"						\
 		__uaccess_fixup					\
-		: "=&d" (err)					\
-		: "a" (__ptr), "d" (x),	"K" (-EFAULT), "0" (0)	\
-		: "cc" );					\
+		: "+&d" (err)					\
+		: "d" (sizeof(*(ptr))), "a" (ptr), "a" (&(x)),	\
+		  "K" (-EFAULT), "m" (x)			\
+		: __uaccess_clobber );				\
 })
+#endif
 
 #define __put_user(x, ptr) \
 ({								\
@@ -198,16 +153,10 @@ struct exception_table_entry
 	int __pu_err;						\
 	switch (sizeof (*(ptr))) {				\
 	case 1:							\
-		__put_user_asm_1(__x, ptr, __pu_err);		\
-		break;						\
 	case 2:							\
-		__put_user_asm_2(__x, ptr, __pu_err);		\
-		break;						\
 	case 4:							\
-		__put_user_asm_4(__x, ptr, __pu_err);		\
-		break;						\
 	case 8:							\
-		__put_user_asm_8(__x, ptr, __pu_err);		\
+		__put_user_asm(__x, ptr, __pu_err);		\
 		break;						\
 	default:						\
 		__pu_err = __put_user_bad();			\
@@ -225,90 +174,33 @@ struct exception_table_entry
 
 extern int __put_user_bad(void);
 
-#ifndef __s390x__
-
-#define __get_user_asm_8(x, ptr, err) \
+#if __GNUC__ > 2
+#define __get_user_asm(x, ptr, err) \
 ({								\
-	register __typeof__(*(ptr)) const * __from asm("4");	\
-	register __typeof__(x) * __to asm("2");			\
-	__from = (ptr);						\
-	__to = &(x);						\
-	__asm__ __volatile__ (					\
-		"   sacf  512\n"				\
-		"0: mvc	  0(8,%2),0(%4)\n"			\
-		"   sacf  0\n"					\
+	err = 0;						\
+	asm volatile (						\
+		"0: mvcp  %O1(%2,%R1),0(%3),%0\n"		\
 		"1:\n"						\
 		__uaccess_fixup					\
-		: "=&d" (err), "=m" (x)				\
-		: "a" (__to),"K" (-EFAULT),"a" (__from),"0" (0)	\
-		: "cc" );					\
+		: "+&d" (err), "=Q" (x)				\
+		: "d" (sizeof(*(ptr))), "a" (ptr),		\
+		  "K" (-EFAULT)					\
+		: __uaccess_clobber );				\
 })
-
-#else /* __s390x__ */
-
-#define __get_user_asm_8(x, ptr, err) \
-({								\
-	register __typeof__(*(ptr)) const * __ptr asm("4");	\
-	__ptr = (ptr);						\
-	__asm__ __volatile__ (					\
-		"   sacf  512\n"				\
-		"0: lg	  %1,0(%2)\n"				\
-		"   sacf  0\n"					\
-		"1:\n"						\
-		__uaccess_fixup					\
-		: "=&d" (err), "=d" (x)				\
-		: "a" (__ptr), "K" (-EFAULT), "0" (0)		\
-		: "cc" );					\
-})
-
-#endif /* __s390x__ */
-
-
-#define __get_user_asm_4(x, ptr, err) \
-({								\
-	register __typeof__(*(ptr)) const * __ptr asm("4");	\
-	__ptr = (ptr);						\
-	__asm__ __volatile__ (					\
-		"   sacf  512\n"				\
-		"0: l	  %1,0(%2)\n"				\
-		"   sacf  0\n"					\
-		"1:\n"						\
-		__uaccess_fixup					\
-		: "=&d" (err), "=d" (x)				\
-		: "a" (__ptr), "K" (-EFAULT), "0" (0)		\
-		: "cc" );					\
-})
-
-#define __get_user_asm_2(x, ptr, err) \
-({								\
-	register __typeof__(*(ptr)) const * __ptr asm("4");	\
-	__ptr = (ptr);						\
-	__asm__ __volatile__ (					\
-		"   sacf  512\n"				\
-		"0: lh	  %1,0(%2)\n"				\
-		"   sacf  0\n"					\
-		"1:\n"						\
-		__uaccess_fixup					\
-		: "=&d" (err), "=d" (x)				\
-		: "a" (__ptr), "K" (-EFAULT), "0" (0)		\
-		: "cc" );					\
-})
-
-#define __get_user_asm_1(x, ptr, err) \
+#else
+#define __get_user_asm(x, ptr, err) \
 ({								\
-	register __typeof__(*(ptr)) const * __ptr asm("4");	\
-	__ptr = (ptr);						\
-	__asm__ __volatile__ (					\
-		"   sr	  %1,%1\n"				\
-		"   sacf  512\n"				\
-		"0: ic	  %1,0(%2)\n"				\
-		"   sacf  0\n"					\
+	err = 0;						\
+	asm volatile (						\
+		"0: mvcp  0(%2,%5),0(%3),%0\n"			\
 		"1:\n"						\
 		__uaccess_fixup					\
-		: "=&d" (err), "=&d" (x)			\
-		: "a" (__ptr), "K" (-EFAULT), "0" (0)		\
-		: "cc" );					\
+		: "+&d" (err), "=m" (x)				\
+		: "d" (sizeof(*(ptr))), "a" (ptr),		\
+		  "K" (-EFAULT), "a" (&(x))			\
+		: __uaccess_clobber );				\
 })
+#endif
 
 #define __get_user(x, ptr)					\
 ({								\
@@ -316,16 +208,10 @@ extern int __put_user_bad(void);
 	int __gu_err;						\
 	switch (sizeof(*(ptr))) {				\
 	case 1:							\
-		__get_user_asm_1(__x, ptr, __gu_err);		\
-		break;						\
 	case 2:							\
-		__get_user_asm_2(__x, ptr, __gu_err);		\
-		break;						\
 	case 4:							\
-		__get_user_asm_4(__x, ptr, __gu_err);		\
-		break;						\
 	case 8:							\
-		__get_user_asm_8(__x, ptr, __gu_err);		\
+		__get_user_asm(__x, ptr, __gu_err);		\
 		break;						\
 	default:						\
 		__x = 0;					\
@@ -344,149 +230,123 @@ extern int __put_user_bad(void);
 
 extern int __get_user_bad(void);
 
-/*
- * access register are set up, that 4 points to secondary (user),
- * 2 to primary (kernel)
- */
-
-extern long __copy_to_user_asm(const void *from, long n, const void *to);
+extern long __copy_to_user_asm(const void *from, long n, void *to);
 
-#define __copy_to_user(to, from, n)                             \
-({                                                              \
-        __copy_to_user_asm(from, n, to);                        \
-})
+/**
+ * __copy_to_user: - Copy a block of data into user space, with less checking.
+ * @to:   Destination address, in user space.
+ * @from: Source address, in kernel space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from kernel space to user space.  Caller must check
+ * the specified block with access_ok() before calling this function.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ */
+static inline unsigned long
+__copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	return __copy_to_user_asm(from, n, to);
+}
 
-#define copy_to_user(to, from, n)                               \
-({                                                              \
-        long err = 0;                                           \
-        __typeof__(n) __n = (n);                                \
-        might_sleep();						\
-        if (__access_ok(to,__n)) {                              \
-                err = __copy_to_user_asm(from, __n, to);        \
-        }                                                       \
-        else                                                    \
-                err = __n;                                      \
-        err;                                                    \
-})
+/**
+ * copy_to_user: - Copy a block of data into user space.
+ * @to:   Destination address, in user space.
+ * @from: Source address, in kernel space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from kernel space to user space.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ */
+static inline unsigned long
+copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	might_sleep();
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __copy_to_user(to, from, n);
+	return n;
+}
 
 extern long __copy_from_user_asm(void *to, long n, const void *from);
 
-#define __copy_from_user(to, from, n)                           \
-({                                                              \
-        __copy_from_user_asm(to, n, from);                      \
-})
-
-#define copy_from_user(to, from, n)                             \
-({                                                              \
-        long err = 0;                                           \
-        __typeof__(n) __n = (n);                                \
-        might_sleep();						\
-        if (__access_ok(from,__n)) {                            \
-                err = __copy_from_user_asm(to, __n, from);      \
-        }                                                       \
-        else                                                    \
-                err = __n;                                      \
-        err;                                                    \
-})
-
-extern long __copy_in_user_asm(const void *from, long n, void *to);
-
-#define __copy_in_user(to, from, n)				\
-({								\
-	__copy_in_user_asm(from, n, to);			\
-})
-
-#define copy_in_user(to, from, n)				\
-({								\
-	long err = 0;						\
-	__typeof__(n) __n = (n);				\
-	might_sleep();						\
-	if (__access_ok(from,__n) && __access_ok(to,__n)) {	\
-		err = __copy_in_user_asm(from, __n, to);	\
-	}							\
-	else							\
-		err = __n;					\
-	err;							\
-})
+/**
+ * __copy_from_user: - Copy a block of data from user space, with less checking.
+ * @to:   Destination address, in kernel space.
+ * @from: Source address, in user space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from user space to kernel space.  Caller must check
+ * the specified block with access_ok() before calling this function.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ *
+ * If some data could not be copied, this function will pad the copied
+ * data to the requested size using zero bytes.
+ */
+static inline unsigned long
+__copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	return __copy_from_user_asm(to, n, from);
+}
 
-/*
- * Copy a null terminated string from userspace.
+/**
+ * copy_from_user: - Copy a block of data from user space.
+ * @to:   Destination address, in kernel space.
+ * @from: Source address, in user space.
+ * @n:    Number of bytes to copy.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Copy data from user space to kernel space.
+ *
+ * Returns number of bytes that could not be copied.
+ * On success, this will be zero.
+ *
+ * If some data could not be copied, this function will pad the copied
+ * data to the requested size using zero bytes.
  */
+static inline unsigned long
+copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	might_sleep();
+	if (access_ok(VERIFY_READ, from, n))
+		n = __copy_from_user(to, from, n);
+	else
+		memset(to, 0, n);
+	return n;
+}
 
-#ifndef __s390x__
+extern long __copy_in_user_asm(const void *from, long n, void *to);
 
-static inline long
-__strncpy_from_user(char *dst, const char *src, long count)
+static inline unsigned long
+__copy_in_user(void __user *to, const void __user *from, unsigned long n)
 {
-        int len;
-        __asm__ __volatile__ (
-		"   slr   %0,%0\n"
-		"   lr    2,%1\n"
-                "   lr    4,%2\n"
-                "   slr   3,3\n"
-                "   sacf  512\n"
-		"0: ic	  3,0(%0,4)\n"
-		"1: stc	  3,0(%0,2)\n"
-		"   ltr	  3,3\n"
-		"   jz	  2f\n"
-		"   ahi	  %0,1\n"
-		"   clr	  %0,%3\n"
-		"   jl	  0b\n"
-		"2: sacf  0\n"
-		".section .fixup,\"ax\"\n"
-		"3: lhi	  %0,%h4\n"
-		"   basr  3,0\n"
-		"   l	  3,4f-.(3)\n"
-		"   br	  3\n"
-		"4: .long 2b\n"
-		".previous\n"
-		".section __ex_table,\"a\"\n"
-		"   .align 4\n"
-		"   .long  0b,3b\n"
-		"   .long  1b,3b\n"
-		".previous"
-		: "=&a" (len)
-		: "a" (dst), "d" (src), "d" (count), "K" (-EFAULT)
-		: "2", "3", "4", "memory", "cc" );
-	return len;
+	__copy_in_user_asm(from, n, to);
 }
 
-#else /* __s390x__ */
-
-static inline long
-__strncpy_from_user(char *dst, const char *src, long count)
+static inline unsigned long
+copy_in_user(void __user *to, const void __user *from, unsigned long n)
 {
-	long len;
-	__asm__ __volatile__ (
-		"   slgr  %0,%0\n"
-		"   lgr	  2,%1\n"
-		"   lgr	  4,%2\n"
-		"   slr	  3,3\n"
-		"   sacf  512\n"
-		"0: ic	  3,0(%0,4)\n"
-		"1: stc	  3,0(%0,2)\n"
-		"   ltr	  3,3\n"
-		"   jz	  2f\n"
-		"   aghi  %0,1\n"
-		"   cgr	  %0,%3\n"
-		"   jl	  0b\n"
-		"2: sacf  0\n"
-		".section .fixup,\"ax\"\n"
-		"3: lghi  %0,%h4\n"
-		"   jg	  2b\n"	 
-		".previous\n"
-		".section __ex_table,\"a\"\n"
-		"   .align 8\n"
-		"   .quad  0b,3b\n"
-		"   .quad  1b,3b\n"
-		".previous"
-		: "=&a" (len)
-		: "a"  (dst), "d" (src), "d" (count), "K" (-EFAULT)
-		: "cc", "2" ,"3", "4" );
-	return len;
+	might_sleep();
+	if (__access_ok(from,n) && __access_ok(to,n))
+		n = __copy_in_user_asm(from, n, to);
+	return n;
 }
 
-#endif /* __s390x__ */
+/*
+ * Copy a null terminated string from userspace.
+ */
+extern long __strncpy_from_user_asm(char *dst, const char *src, long count);
 
 static inline long
 strncpy_from_user(char *dst, const char *src, long count)
@@ -494,104 +354,34 @@ strncpy_from_user(char *dst, const char 
         long res = -EFAULT;
         might_sleep();
         if (access_ok(VERIFY_READ, src, 1))
-                res = __strncpy_from_user(dst, src, count);
+                res = __strncpy_from_user_asm(dst, src, count);
         return res;
 }
 
 
-/*
- * Return the size of a string (including the ending 0)
- *
- * Return 0 for error
- */
-#ifndef __s390x__
+extern long __strnlen_user_asm(const char *src, long count);
 
 static inline unsigned long
 strnlen_user(const char * src, unsigned long n)
 {
 	might_sleep();
-	__asm__ __volatile__ (
-		"   alr   %0,%1\n"
-		"   slr   0,0\n"
-		"   lr    4,%1\n"
-		"   sacf  512\n"
-		"0: srst  %0,4\n"
-		"   jo    0b\n"
-		"   slr   %0,%1\n"
-		"   ahi   %0,1\n"
-		"   sacf  0\n"
-		"1:\n"
-		".section .fixup,\"ax\"\n"
-		"2: sacf  0\n"
-		"   slr   %0,%0\n"
-		"   bras  4,3f\n"
-		"   .long 1b\n"
-		"3: l     4,0(4)\n"
-		"   br    4\n"
-		".previous\n"
-		".section __ex_table,\"a\"\n"
-		"  .align 4\n"
-		"  .long  0b,2b\n"
-		".previous"
-		: "+&a" (n) : "d" (src)
-		: "cc", "0", "4" );
-	return n;
+	return __strnlen_user_asm(src, n);
 }
 
-#else /* __s390x__ */
-
-static inline unsigned long
-strnlen_user(const char * src, unsigned long n)
-{
-	might_sleep();
-#if 0
-	__asm__ __volatile__ (
-		"   algr  %0,%1\n"
-		"   slgr  0,0\n"
-		"   lgr	  4,%1\n"
-		"   sacf  512\n"
-		"0: srst  %0,4\n"
-		"   jo	0b\n"
-		"   slgr  %0,%1\n"
-		"   aghi  %0,1\n"
-		"1: sacf  0\n"
-		".section .fixup,\"ax\"\n"
-		"2: slgr  %0,%0\n"
-		"   jg	  1b\n"
-		".previous\n"
-		".section __ex_table,\"a\"\n"
-		"  .align 8\n"
-		"  .quad  0b,2b\n"
-		".previous"
-		: "+&a" (n) : "d" (src)
-		: "cc", "0", "4" );
-#else
-	__asm__ __volatile__ (
-		"   lgr	  4,%1\n"
-		"   sacf  512\n"
-		"0: cli   0(4),0x00\n"
-		"   la    4,1(4)\n"
-		"   je    1f\n"
-		"   brctg %0,0b\n"
-		"1: lgr	  %0,4\n"
-		"   slgr  %0,%1\n"
-		"2: sacf  0\n"
-		".section .fixup,\"ax\"\n"
-		"3: slgr  %0,%0\n"
-		"   jg    2b\n"  
-		".previous\n"
-		".section __ex_table,\"a\"\n"
-		"  .align 8\n"
-		"  .quad  0b,3b\n"
-		".previous"
-		: "+&a" (n) : "d" (src)
-		: "cc", "4" );
-#endif
-	return n;
-}
-
-#endif /* __s390x__ */
-
+/**
+ * strlen_user: - Get the size of a string in user space.
+ * @str: The string to measure.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * Get the size of a NUL-terminated string in user space.
+ *
+ * Returns the size of the string INCLUDING the terminating NUL.
+ * On exception, returns 0.
+ *
+ * If there is a limit on the length of a valid string, you may wish to
+ * consider using strnlen_user() instead.
+ */
 #define strlen_user(str) strnlen_user(str, ~0UL)
 
 /*
@@ -600,17 +390,18 @@ strnlen_user(const char * src, unsigned 
 
 extern long __clear_user_asm(void *to, long n);
 
-#define __clear_user(to, n)					\
-({								\
-	__clear_user_asm(to, n);				\
-})
+static inline unsigned long
+__clear_user(void *to, unsigned long n)
+{
+	return __clear_user_asm(to, n);
+}
 
 static inline unsigned long
 clear_user(void *to, unsigned long n)
 {
 	might_sleep();
 	if (access_ok(VERIFY_WRITE, to, n))
-		n = __clear_user(to, n);
+		n = __clear_user_asm(to, n);
 	return n;
 }
 
diff -purN linux-post-2.6.5-rc2-20040327/include/asm-s390/unistd.h linux-post-2.6.5-rc2-20040329/include/asm-s390/unistd.h
--- linux-post-2.6.5-rc2-20040327/include/asm-s390/unistd.h	2004-03-17 12:02:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/asm-s390/unistd.h	2004-03-27 11:40:45.000000000 +0000
@@ -543,19 +543,14 @@ static inline pid_t waitpid(int pid, int
 	return sys_wait4(pid, wait_stat, flags, NULL);
 }
 struct mmap_arg_struct;
-asmlinkage long sys_mmap2(struct mmap_arg_struct *arg);
+asmlinkage long sys_mmap2(struct mmap_arg_struct __user *arg);
 
-asmlinkage int sys_execve(struct pt_regs regs);
-asmlinkage int sys_clone(struct pt_regs regs);
-asmlinkage int sys_fork(struct pt_regs regs);
-asmlinkage int sys_vfork(struct pt_regs regs);
-#ifndef CONFIG_ARCH_S390X
-#define __SYS_RETTYPE int
-#else
-#define __SYS_RETTYPE long
-#endif /* CONFIG_ARCH_S390X */
-asmlinkage __SYS_RETTYPE sys_pipe(unsigned long *fildes);
-asmlinkage int sys_ptrace(long request, long pid, long addr, long data);
+asmlinkage long sys_execve(struct pt_regs regs);
+asmlinkage long sys_clone(struct pt_regs regs);
+asmlinkage long sys_fork(struct pt_regs regs);
+asmlinkage long sys_vfork(struct pt_regs regs);
+asmlinkage long sys_pipe(unsigned long __user *fildes);
+asmlinkage long sys_ptrace(long request, long pid, long addr, long data);
 struct sigaction;
 asmlinkage long sys_rt_sigaction(int sig,
 				const struct sigaction __user *act,
diff -purN linux-post-2.6.5-rc2-20040327/include/linux/compat_ioctl.h linux-post-2.6.5-rc2-20040329/include/linux/compat_ioctl.h
--- linux-post-2.6.5-rc2-20040327/include/linux/compat_ioctl.h	2004-03-22 06:53:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/linux/compat_ioctl.h	2004-03-25 01:13:00.000000000 +0000
@@ -248,10 +248,6 @@ COMPATIBLE_IOCTL(SIOCSIFLINK)
 COMPATIBLE_IOCTL(SIOCSIFENCAP)
 COMPATIBLE_IOCTL(SIOCGIFENCAP)
 COMPATIBLE_IOCTL(SIOCSIFNAME)
-/* FIXME: not compatible
-COMPATIBLE_IOCTL(SIOCSIFBR)
-COMPATIBLE_IOCTL(SIOCGIFBR)
-*/
 COMPATIBLE_IOCTL(SIOCSARP)
 COMPATIBLE_IOCTL(SIOCGARP)
 COMPATIBLE_IOCTL(SIOCDARP)
diff -purN linux-post-2.6.5-rc2-20040327/include/linux/ide.h linux-post-2.6.5-rc2-20040329/include/linux/ide.h
--- linux-post-2.6.5-rc2-20040327/include/linux/ide.h	2004-03-16 22:12:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/linux/ide.h	2004-03-23 18:26:40.000000000 +0000
@@ -849,8 +849,6 @@ typedef struct hwif_s {
 
 	struct pci_dev  *pci_dev;	/* for pci chipsets */
 	struct ide_pci_device_s	*cds;	/* chipset device struct */
-	
-	struct pnp_dev  *pnp_dev;	/* for PnP devices */
 
 	ide_startstop_t (*rw_disk)(ide_drive_t *, struct request *, sector_t);
 
@@ -932,7 +930,7 @@ typedef struct hwif_s {
 	int sg_dma_direction;		/* dma transfer direction */
 	int sg_dma_active;		/* is it in use */
 
-	int		mmio;		/* hosts iomio (0), mmio (1) or custom (2) select */
+	int		mmio;		/* hosts iomio (0) or custom (2) select */
 	int		rqsize;		/* max sectors per request */
 	int		irq;		/* our irq number */
 
diff -purN linux-post-2.6.5-rc2-20040327/include/net/scm.h linux-post-2.6.5-rc2-20040329/include/net/scm.h
--- linux-post-2.6.5-rc2-20040327/include/net/scm.h	2003-10-01 06:42:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/include/net/scm.h	2004-03-26 19:05:31.000000000 +0000
@@ -2,6 +2,7 @@
 #define __LINUX_NET_SCM_H
 
 #include <linux/limits.h>
+#include <linux/net.h>
 
 /* Well, we should have at least one descriptor open
  * to accept passed FDs 8)
diff -purN linux-post-2.6.5-rc2-20040327/ipc/sem.c linux-post-2.6.5-rc2-20040329/ipc/sem.c
--- linux-post-2.6.5-rc2-20040327/ipc/sem.c	2004-03-12 09:32:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/ipc/sem.c	2004-03-27 11:40:45.000000000 +0000
@@ -972,8 +972,10 @@ static struct sem_undo *find_undo(int se
 	if(sma==NULL)
 		goto out;
 	un = ERR_PTR(-EIDRM);
-	if (sem_checkid(sma,semid))
-		goto out_unlock;
+	if (sem_checkid(sma,semid)) {
+		sem_unlock(sma);
+		goto out;
+	}
 	nsems = sma->sem_nsems;
 	sem_unlock(sma);
 
@@ -1004,7 +1006,6 @@ static struct sem_undo *find_undo(int se
 	sma->undo = new;
 	sem_unlock(sma);
 	un = new;
-out_unlock:
 	unlock_semundo();
 out:
 	return un;
diff -purN linux-post-2.6.5-rc2-20040327/security/selinux/hooks.c linux-post-2.6.5-rc2-20040329/security/selinux/hooks.c
--- linux-post-2.6.5-rc2-20040327/security/selinux/hooks.c	2004-03-19 06:04:56.000000000 +0000
+++ linux-post-2.6.5-rc2-20040329/security/selinux/hooks.c	2004-03-27 11:40:47.000000000 +0000
@@ -3039,6 +3039,8 @@ static int selinux_socket_sock_rcv_skb(s
 		goto out;
 	
 	err = avc_has_perm(isec->sid, node_sid, SECCLASS_NODE, node_perm, NULL, &ad);
+	if (err)
+		goto out;
 
 	if (recv_perm) {
 		u32 port_sid;
