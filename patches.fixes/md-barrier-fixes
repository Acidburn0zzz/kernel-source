Subject: Fix a couple of issues with handing BARRIER writes in md/raid1
From: NeilBrown <neilb@cse.unsw.edu.au>
Patch-mainline: 2.6.17-rc1
References: none

- Restore 'remaining' count when retrying an write operation.

  When retrying a write due to barrier failure, we don't reset
  'remaining', so it goes negative and never hits 0 again.

- call md_write_start *before* checking mddev->barriers_work.
  md_write_start might write the superblock, which will clear
  barriers_work if they don't.


Signed-off-by: Neil Brown <neilb@suse.de>


diff ./drivers/md/raid1.c~current~ ./drivers/md/raid1.c
Index: linux-2.6.16/drivers/md/raid1.c
===================================================================
--- linux-2.6.16.orig/drivers/md/raid1.c	2006-03-20 16:53:29.000000000 +1100
+++ linux-2.6.16/drivers/md/raid1.c	2006-03-28 09:59:03.000000000 +1100
@@ -753,18 +753,22 @@
 	const int rw = bio_data_dir(bio);
 	int do_barriers;
 
-	if (unlikely(!mddev->barriers_work && bio_barrier(bio))) {
-		bio_endio(bio, bio->bi_size, -EOPNOTSUPP);
-		return 0;
-	}
-
 	/*
 	 * Register the new request and wait if the reconstruction
 	 * thread has put up a bar for new requests.
 	 * Continue immediately if no resync is active currently.
+	 * We test barriers_work *after* md_write_start as md_write_start
+	 * may cause the first superblock write, and that will check out
+	 * if barriers work.
 	 */
 	md_write_start(mddev, bio); /* wait on superblock update early */
 
+	if (unlikely(!mddev->barriers_work && bio_barrier(bio))) {
+		md_write_end(mddev);
+		bio_endio(bio, bio->bi_size, -EOPNOTSUPP);
+		return 0;
+	}
+
 	wait_barrier(conf);
 
 	disk_stat_inc(mddev->gendisk, ios[rw]);
@@ -1402,6 +1406,9 @@
 			clear_bit(R1BIO_BarrierRetry, &r1_bio->state);
 			clear_bit(R1BIO_Barrier, &r1_bio->state);
 			for (i=0; i < conf->raid_disks; i++)
+				if (r1_bio->bios[i])
+					atomic_inc(&r1_bio->remaining);
+			for (i=0; i < conf->raid_disks; i++)
 				if (r1_bio->bios[i]) {
 					struct bio_vec *bvec;
 					int j;
