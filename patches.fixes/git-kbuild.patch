Date: Fri, 10 Feb 2006 19:38:26 +0100
From: Andreas Gruenbacher <agruen@suse.de>
Subject: kbuild update / fixes

Taken from the 2.6.16-rc2-mm2 tree.

GIT 275074573ca9ebffed3ce16817782279afbcfe08 git+ssh://master.kernel.org/pub/scm/linux/kernel/git/sam/kbuild.git

commit 275074573ca9ebffed3ce16817782279afbcfe08
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 23:51:57 2006 +0100

    kbuild: run depmod when installing external modules
    
    Following patch enables depmod support when installing external modules.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

commit def6355a37184036ffaa2f4497e0026139e2cfc3
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 23:08:40 2006 +0100

    kbuild: avoid stale modules in $(MODVERDIR) for external modules
    
    To avoid stale modules located in $(MODVERDIR) aka .tmp_versions/
    always delete the directory when building an external module.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

commit 780d389ab8cbd91221caa97c90cf922711076f27
Author: Martin Michlmayr <tbm@cyrius.com>
Date:   Sat Jan 28 18:38:15 2006 +0000

    kbuild: Accept various mips sub-types in SUBARCH
    
    uname -m on MIPS can give a number of results, such as mips64.  We
    need to add another substitution to the sed call for SUBARCH in the
    main Makefile.
    
    Signed-off-by: Martin Michlmayr <tbm@cyrius.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

commit 91b06e616c62c7aef213cafb1435e94158d18901
Author: Zach Brown <zach.brown@oracle.com>
Date:   Fri Jan 27 14:02:47 2006 -0800

    x86: align per-cpu section to configured cache bytes
    
    This matches the fix for a bug seen on x86-64.  Test booted on old hardware
    that had 32 byte cachelines to begin with.
    
    Signed-off-by: Zach Brown <zach.brown@oracle.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

commit cd1f125e5808203d3bf58f1d04a9cbd33f60fdb6
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 22:22:33 2006 +0100

    kbuild: warn about duplicate exported symbols
    
    In modpost introduce a check for symbols exported twice.
    This check caught only one victim (inet_bind_bucket_create) for
    which a patch is already sent to netdev.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

commit cd52b55110e6b7484e0e6a87e32bae011b501685
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 22:15:55 2006 +0100

    kbuild: improved modversioning support for external modules
    
    With following patch a second option is enabled to obtain
    symbol information from a second external module when a
    external module is build.
    The recommended approach is to use a common kbuild file but
    that may be impractical in certain cases.
    With this patch one can copy over a Module.symvers from one
    external module to make symbols (and symbol versions) available
    for another external module.
    
    Updated documentation in Documentation/kbuild/modules.txt
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

commit c6aaa0a455d3dfdf874f76bf71033da9fb4bf0ea
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 17:19:35 2006 +0100

    kbuild: apply CodingStyle to modpost.c
    
    Just some light CodingStyle updates - no functional changes.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

commit eaea50832b98d2f8710d1290bf72bf0df59c22b4
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 16:57:26 2006 +0100

    kbuild: use warn()/fatal() consistent in modpost
    
    modpost.c provides warn() and fatal() - so use them all over the place.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

commit 5ffee79b029819994d080f37ea1b062fb8db56b1
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Wed Jan 25 07:13:18 2006 +0100

    kbuild: support building individual files for external modules
    
    Support building individual files when dealing with separate modules.
    So say you have a module named "foo" which consist of two .o files bar.o
    and fun.o.
    
    You can then do:
    make -C $KERNELSRC M=`pwd` bar.o
    make -C $KERNELSRC M=`pwd` bar.lst
    make -C $KERNELSRC M=`pwd` bar.i
    make -C $KERNELSRC M=`pwd` /            <= will build all .o files
                                               and link foo.o
    make -C $KERNELSRC M=`pwd` foo.ko       <= will build the module
                                               and do the modpost step
    					   to create foo.ko
    
    The above will also work if the external module is placed in a
    subdirectory using a hirachy of kbuild files.
    Thanks to Andreas Gruenbacher <agruen@suse.de> for initial feature
    request / bug report.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

commit 7f884842500c28c81a331d12f88cd38f987642e5
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Jan 22 13:34:15 2006 +0100

    kbuild: make cc-version available in kbuild files
    
    Move $(CC) support functions to Kbuild.include so they are available
    in the kbuild files.
    In addition the following was done:
    	o as-option documented in Documentation/kbuild/makefiles.txt
    	o Moved documentation to new section to match
    	  new scope of functions
    	o added cc-ifversion used to conditionally select a text string
    	  dependent on actual $(CC) version
    	o documented cc-ifversion
    	o change so Kbuild.include is read before the kbuild file
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>


---
diff --git a/Documentation/kbuild/makefiles.txt b/Documentation/kbuild/makefiles.txt
index 443230b..99d51a5 100644
--- a/Documentation/kbuild/makefiles.txt
+++ b/Documentation/kbuild/makefiles.txt
@@ -17,6 +17,7 @@ This document describes the Linux kernel
 	   --- 3.8 Command line dependency
 	   --- 3.9 Dependency tracking
 	   --- 3.10 Special Rules
+	   --- 3.11 $(CC) support functions
 
 	=== 4 Host Program support
 	   --- 4.1 Simple Host Program
@@ -38,7 +39,6 @@ This document describes the Linux kernel
 	   --- 6.6 Commands useful for building a boot image
 	   --- 6.7 Custom kbuild commands
 	   --- 6.8 Preprocessing linker scripts
-	   --- 6.9 $(CC) support functions
 
 	=== 7 Kbuild Variables
 	=== 8 Makefile language
@@ -385,6 +385,102 @@ more details, with real examples.
 	to prerequisites are referenced with $(src) (because they are not
 	generated files).
 
+--- 3.11 $(CC) support functions
+
+	The kernel may be build with several different versions of
+	$(CC), each supporting a unique set of features and options.
+	kbuild provide basic support to check for valid options for $(CC).
+	$(CC) is useally the gcc compiler, but other alternatives are
+	available.
+
+    as-option
+    	as-option is used to check if $(CC) when used to compile
+	assembler (*.S) files supports the given option. An optional
+	second option may be specified if first option are not supported.
+
+	Example:
+		#arch/sh/Makefile
+		cflags-y += $(call as-option,-Wa$(comma)-isa=$(isa-y),)
+
+	In the above example cflags-y will be assinged the the option
+	-Wa$(comma)-isa=$(isa-y) if it is supported by $(CC).
+	The second argument is optional, and if supplied will be used
+	if first argument is not supported.
+
+    cc-option
+	cc-option is used to check if $(CC) support a given option, and not
+	supported to use an optional second option.
+
+	Example:
+		#arch/i386/Makefile
+		cflags-y += $(call cc-option,-march=pentium-mmx,-march=i586)
+
+	In the above example cflags-y will be assigned the option
+	-march=pentium-mmx if supported by $(CC), otherwise -march-i586.
+	The second argument to cc-option is optional, and if omitted
+	cflags-y will be assigned no value if first option is not supported.
+
+   cc-option-yn
+   	cc-option-yn is used to check if gcc supports a given option
+	and return 'y' if supported, otherwise 'n'.
+
+	Example:
+		#arch/ppc/Makefile
+		biarch := $(call cc-option-yn, -m32)
+		aflags-$(biarch) += -a32
+		cflags-$(biarch) += -m32
+	
+	In the above example $(biarch) is set to y if $(CC) supports the -m32
+	option. When $(biarch) equals to y the expanded variables $(aflags-y)
+	and $(cflags-y) will be assigned the values -a32 and -m32.
+
+    cc-option-align
+	gcc version >= 3.0 shifted type of options used to speify
+	alignment of functions, loops etc. $(cc-option-align) whrn used
+	as prefix to the align options will select the right prefix:
+	gcc < 3.00
+		cc-option-align = -malign
+	gcc >= 3.00
+		cc-option-align = -falign
+	
+	Example:
+		CFLAGS += $(cc-option-align)-functions=4
+
+	In the above example the option -falign-functions=4 is used for
+	gcc >= 3.00. For gcc < 3.00 -malign-functions=4 is used.
+	
+    cc-version
+	cc-version return a numerical version of the $(CC) compiler version.
+	The format is <major><minor> where both are two digits. So for example
+	gcc 3.41 would return 0341.
+	cc-version is useful when a specific $(CC) version is faulty in one
+	area, for example the -mregparm=3 were broken in some gcc version
+	even though the option was accepted by gcc.
+
+	Example:
+		#arch/i386/Makefile
+		cflags-y += $(shell \
+		if [ $(call cc-version) -ge 0300 ] ; then \
+			echo "-mregparm=3"; fi ;)
+
+	In the above example -mregparm=3 is only used for gcc version greater
+	than or equal to gcc 3.0.
+
+    cc-ifversion
+	cc-ifversion test the version of $(CC) and equals last argument if
+	version expression is true.
+
+	Example:
+		#fs/reiserfs/Makefile
+		EXTRA_CFLAGS := $(call cc-ifversion, -lt, 0402, -O1)
+
+	In this example EXTRA_CFLAGS will be assigned the value -O1 if the
+	$(CC) version is less than 4.2.
+	cc-ifversion takes all the shell operators: 
+	-eq, -ne, -lt, -le, -gt, and -ge
+	The third parameter may be a text as in this example, but it may also
+	be an expanded variable or a macro.
+
 
 === 4 Host Program support
 
@@ -973,74 +1069,6 @@ When kbuild executes the following steps
 	architecture specific files.
 
 
---- 6.9 $(CC) support functions
-
-	The kernel may be build with several different versions of
-	$(CC), each supporting a unique set of features and options.
-	kbuild provide basic support to check for valid options for $(CC).
-	$(CC) is useally the gcc compiler, but other alternatives are
-	available.
-
-    cc-option
-	cc-option is used to check if $(CC) support a given option, and not
-	supported to use an optional second option.
-
-	Example:
-		#arch/i386/Makefile
-		cflags-y += $(call cc-option,-march=pentium-mmx,-march=i586)
-
-	In the above example cflags-y will be assigned the option
-	-march=pentium-mmx if supported by $(CC), otherwise -march-i586.
-	The second argument to cc-option is optional, and if omitted
-	cflags-y will be assigned no value if first option is not supported.
-
-   cc-option-yn
-   	cc-option-yn is used to check if gcc supports a given option
-	and return 'y' if supported, otherwise 'n'.
-
-	Example:
-		#arch/ppc/Makefile
-		biarch := $(call cc-option-yn, -m32)
-		aflags-$(biarch) += -a32
-		cflags-$(biarch) += -m32
-	
-	In the above example $(biarch) is set to y if $(CC) supports the -m32
-	option. When $(biarch) equals to y the expanded variables $(aflags-y)
-	and $(cflags-y) will be assigned the values -a32 and -m32.
-
-    cc-option-align
-	gcc version >= 3.0 shifted type of options used to speify
-	alignment of functions, loops etc. $(cc-option-align) whrn used
-	as prefix to the align options will select the right prefix:
-	gcc < 3.00
-		cc-option-align = -malign
-	gcc >= 3.00
-		cc-option-align = -falign
-	
-	Example:
-		CFLAGS += $(cc-option-align)-functions=4
-
-	In the above example the option -falign-functions=4 is used for
-	gcc >= 3.00. For gcc < 3.00 -malign-functions=4 is used.
-	
-    cc-version
-	cc-version return a numerical version of the $(CC) compiler version.
-	The format is <major><minor> where both are two digits. So for example
-	gcc 3.41 would return 0341.
-	cc-version is useful when a specific $(CC) version is faulty in one
-	area, for example the -mregparm=3 were broken in some gcc version
-	even though the option was accepted by gcc.
-
-	Example:
-		#arch/i386/Makefile
-		cflags-y += $(shell \
-		if [ $(call cc-version) -ge 0300 ] ; then \
-			echo "-mregparm=3"; fi ;)
-
-	In the above example -mregparm=3 is only used for gcc version greater
-	than or equal to gcc 3.0.
-	
-
 === 7 Kbuild Variables
 
 The top Makefile exports the following variables:
diff --git a/Documentation/kbuild/modules.txt b/Documentation/kbuild/modules.txt
index 7e77f93..fcccf24 100644
--- a/Documentation/kbuild/modules.txt
+++ b/Documentation/kbuild/modules.txt
@@ -13,6 +13,7 @@ In this document you will find informati
 	   --- 2.2 Available targets
 	   --- 2.3 Available options
 	   --- 2.4 Preparing the kernel tree for module build
+	   --- 2.5 Building separate files for a module
 	=== 3. Example commands
 	=== 4. Creating a kbuild file for an external module
 	=== 5. Include files
@@ -22,7 +23,10 @@ In this document you will find informati
 	=== 6. Module installation
 	   --- 6.1 INSTALL_MOD_PATH
 	   --- 6.2 INSTALL_MOD_DIR
-	=== 7. Module versioning
+	=== 7. Module versioning & Module.symvers
+	   --- 7.1 Symbols fron the kernel (vmlinux + modules)
+	   --- 7.2 Symbols and external modules
+	   --- 7.3 Symbols from another external module
 	=== 8. Tips & Tricks
 	   --- 8.1 Testing for CONFIG_FOO_BAR
 
@@ -88,7 +92,8 @@ when building an external module.
 	make -C $KDIR M=$PWD modules_install
 		Install the external module(s).
 		Installation default is in /lib/modules/<kernel-version>/extra,
-		but may be prefixed with INSTALL_MOD_PATH - see separate chapter.
+		but may be prefixed with INSTALL_MOD_PATH - see separate
+		chapter.
 
 	make -C $KDIR M=$PWD clean
 		Remove all generated files for the module - the kernel
@@ -131,6 +136,16 @@ when building an external module.
 	      Therefore a full kernel build needs to be executed to make
 	      module versioning work.
 
+--- 2.5 Building separate files for a module
+	It is possible to build single files which is part of a module.
+	This works equal for the kernel, a module and even for external
+	modules.
+	Examples (module foo.ko, consist of bar.o, baz.o):
+		make -C $KDIR M=`pwd` bar.lst
+		make -C $KDIR M=`pwd` bar.o
+		make -C $KDIR M=`pwd` foo.ko
+		make -C $KDIR M=`pwd` /
+	
 
 === 3. Example commands
 
@@ -422,7 +437,7 @@ External modules are installed in the di
 		=> Install dir: /lib/modules/$(KERNELRELEASE)/gandalf
 
 
-=== 7. Module versioning
+=== 7. Module versioning & Module.symvers
 
 Module versioning is enabled by the CONFIG_MODVERSIONS tag.
 
@@ -432,11 +447,80 @@ when a module is loaded/used then the CR
 compared with similar values in the module. If they are not equal then the
 kernel refuses to load the module.
 
-During a kernel build a file named Module.symvers will be generated. This
-file includes the symbol version of all symbols within the kernel. If the 
-Module.symvers file is saved from the last full kernel compile one does not
-have to do a full kernel compile to build a module version's compatible module.
+Module.symvers contains a list of all exported symbols from a kernel build.
+
+--- 7.1 Symbols fron the kernel (vmlinux + modules)
+
+	During a kernel build a file named Module.symvers will be generated.
+	Module.symvers contains all exported symbols from the kernel and
+	compiled modules. For each symbols the corresponding CRC value
+	is stored too.
+
+	The syntax of the Module.symvers file is:
+		<CRC>       <Symbol>           <module>
+	Sample:
+		0x2d036834  scsi_remove_host   drivers/scsi/scsi_mod
+
+	For a kernel build without CONFIG_MODVERSIONING enabled the crc
+	would read: 0x00000000
+
+	Module.symvers serve two purposes.
+	1) It list all exported symbols both from vmlinux and all modules
+	2) It list CRC if CONFIG_MODVERSION is enabled
+
+--- 7.2 Symbols and external modules
+
+	When building an external module the build system needs access to
+	the symbols from the kernel to check if all external symbols are
+	defined. This is done in the MODPOST step and to obtain all
+	symbols modpost reads Module.symvers from the kernel.
+	If a Module.symvers file is present in the directory where
+	the external module is being build this file will be read too.
+	During the MODPOST step a new Module.symvers file will be written
+	containing all exported symbols that was not defined in the kernel.
+	
+--- 7.3 Symbols from another external module
 
+	Sometimes one external module uses exported symbols from another
+	external module. Kbuild needs to have full knowledge on all symbols
+	to avoid spitting out warnings about undefined symbols.
+	Two solutions exist to let kbuild know all symbols of more than
+	one external module.
+	The method with a top-level kbuild file is recommended but may be
+	impractical in certain situations.
+
+	Use a top-level Kbuild file
+		If you have two modules: 'foo', 'bar' and 'foo' needs symbols
+		from 'bar' then one can use a common top-level kbuild file so
+		both modules are compiled in same build.
+
+		Consider following directory layout:
+		./foo/ <= contains the foo module
+		./bar/ <= contains the bar module
+		The top-level Kbuild file would then look like:
+		
+		#./Kbuild: (this file may also be named Makefile)
+			obj-y := foo/ bar/
+
+		Executing:
+			make -C $KDIR M=`pwd`
+
+		will then do the expected and compile both modules with full
+		knowledge on symbols from both modules.
+
+	Use an extra Module.symvers file
+		When an external module is build a Module.symvers file is
+		generated containing all exported symbols which are not
+		defined in the kernel.
+		To get access to symbols from module 'bar' one can copy the
+		Module.symvers file from the compilation of the 'bar' module
+		to the directory where the 'foo' module is build.
+		During the module build kbuild will read the Module.symvers
+		file in the directory of the external module and when the
+		build is finished a new Module.symvers file is created
+		containing the sum of all symbols defined and not part of the
+		kernel.
+		
 === 8. Tips & Tricks
 
 --- 8.1 Testing for CONFIG_FOO_BAR
diff --git a/Makefile b/Makefile
index 31bbc6a..b9bffa4 100644
--- a/Makefile
+++ b/Makefile
@@ -138,7 +138,7 @@ objtree		:= $(CURDIR)
 src		:= $(srctree)
 obj		:= $(objtree)
 
-VPATH		:= $(srctree)
+VPATH		:= $(srctree):$(KBUILD_EXTMOD)
 
 export srctree objtree VPATH TOPDIR
 
@@ -152,7 +152,7 @@ export srctree objtree VPATH TOPDIR
 SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
 				  -e s/arm.*/arm/ -e s/sa110/arm/ \
 				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
-				  -e s/ppc.*/powerpc/ )
+				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ )
 
 # Cross compiling and selecting different set of gcc/bin-utils
 # ---------------------------------------------------------------------------
@@ -259,38 +259,6 @@ endif
 
 export quiet Q KBUILD_VERBOSE
 
-######
-# cc support functions to be used (only) in arch/$(ARCH)/Makefile
-# See documentation in Documentation/kbuild/makefiles.txt
-
-# as-option
-# Usage: cflags-y += $(call as-option, -Wa$(comma)-isa=foo,)
-
-as-option = $(shell if $(CC) $(CFLAGS) $(1) -Wa,-Z -c -o /dev/null \
-	     -xassembler /dev/null > /dev/null 2>&1; then echo "$(1)"; \
-	     else echo "$(2)"; fi ;)
-
-# cc-option
-# Usage: cflags-y += $(call cc-option, -march=winchip-c6, -march=i586)
-
-cc-option = $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null -xc /dev/null \
-             > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi ;)
-
-# cc-option-yn
-# Usage: flag := $(call cc-option-yn, -march=winchip-c6)
-cc-option-yn = $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null -xc /dev/null \
-                > /dev/null 2>&1; then echo "y"; else echo "n"; fi;)
-
-# cc-option-align
-# Prefix align with either -falign or -malign
-cc-option-align = $(subst -functions=0,,\
-	$(call cc-option,-falign-functions=0,-malign-functions=0))
-
-# cc-version
-# Usage gcc-ver := $(call cc-version $(CC))
-cc-version = $(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-version.sh \
-              $(if $(1), $(1), $(CC)))
-
 
 # Look for make include files relative to root of kernel src
 MAKEFLAGS += --include-dir=$(srctree)
@@ -850,27 +818,6 @@ prepare prepare-all: prepare0
 
 export CPPFLAGS_vmlinux.lds += -P -C -U$(ARCH)
 
-# Single targets
-# ---------------------------------------------------------------------------
-
-%.s: %.c scripts FORCE
-	$(Q)$(MAKE) $(build)=$(@D) $@
-%.i: %.c scripts FORCE
-	$(Q)$(MAKE) $(build)=$(@D) $@
-%.o: %.c scripts FORCE
-	$(Q)$(MAKE) $(build)=$(@D) $@
-%.ko: scripts FORCE
-	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) $(build)=$(@D) $(@:.ko=.o)
-	$(Q)$(MAKE) -rR -f $(srctree)/scripts/Makefile.modpost
-%/:      scripts prepare FORCE
-	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) $(build)=$(@D)
-%.lst: %.c scripts FORCE
-	$(Q)$(MAKE) $(build)=$(@D) $@
-%.s: %.S scripts FORCE
-	$(Q)$(MAKE) $(build)=$(@D) $@
-%.o: %.S scripts FORCE
-	$(Q)$(MAKE) $(build)=$(@D) $@
-
 # 	FIXME: The asm symlink changes when $(ARCH) changes. That's
 #	hard to detect, but I suppose "make mrproper" is a good idea
 #	before switching between archs anyway.
@@ -1148,6 +1095,7 @@ else # KBUILD_EXTMOD
 KBUILD_MODULES := 1
 .PHONY: crmodverdir
 crmodverdir:
+	$(Q)rm -rf $(MODVERDIR)
 	$(Q)mkdir -p $(MODVERDIR)
 
 .PHONY: $(objtree)/Module.symvers
@@ -1168,9 +1116,28 @@ modules: $(module-dirs)
 	$(Q)$(MAKE) -rR -f $(srctree)/scripts/Makefile.modpost
 
 .PHONY: modules_install
-modules_install:
+modules_install: _emodinst_ _emodinst_post
+	
+install-dir := $(if $(INSTALL_MOD_DIR),$(INSTALL_MOD_DIR),extra)	
+.PHONY: _emodinst_
+_emodinst_:
+	$(Q)rm -rf $(MODLIB)/$(install-dir)
+	$(Q)mkdir -p $(MODLIB)/$(install-dir)
 	$(Q)$(MAKE) -rR -f $(srctree)/scripts/Makefile.modinst
 
+# Run depmod only is we have System.map and depmod is executable
+quiet_cmd_depmod = DEPMOD  $(KERNELRELEASE)
+      cmd_depmod = if [ -r System.map -a -x $(DEPMOD) ]; then \
+                      $(DEPMOD) -ae -F System.map             \
+                      $(if $(strip $(INSTALL_MOD_PATH)),      \
+		      -b $(INSTALL_MOD_PATH) -r)              \
+		      $(KERNELRELEASE);                       \
+                   fi
+
+.PHONY: _emodinst_post
+_emodinst_post: _emodinst_
+	$(call cmd,depmod)
+
 clean-dirs := $(addprefix _clean_,$(KBUILD_EXTMOD))
 
 .PHONY: $(clean-dirs) clean
@@ -1193,6 +1160,11 @@ help:
 	@echo  '  modules_install - install the module'
 	@echo  '  clean           - remove generated files in module directory only'
 	@echo  ''
+
+# Dummies...
+.PHONY: prepare scripts
+prepare: ;
+scripts: ;
 endif # KBUILD_EXTMOD
 
 # Generate tags for editors
@@ -1314,6 +1286,44 @@ kernelrelease:
 kernelversion:
 	@echo $(KERNELVERSION)
 
+# Single targets
+# ---------------------------------------------------------------------------
+# The directory part is taken from first prerequisite, so this
+# works even with external modules
+%.s: %.c scripts FORCE
+	$(Q)$(MAKE) $(build)=$(dir $<) $(dir $<)$(notdir $@)
+%.i: %.c scripts FORCE
+	$(Q)$(MAKE) $(build)=$(dir $<) $(dir $<)$(notdir $@)
+%.o: %.c scripts FORCE
+	$(Q)$(MAKE) $(build)=$(dir $<) $(dir $<)$(notdir $@)
+%.lst: %.c scripts FORCE
+	$(Q)$(MAKE) $(build)=$(dir $<) $(dir $<)$(notdir $@)
+%.s: %.S scripts FORCE
+	$(Q)$(MAKE) $(build)=$(dir $<) $(dir $<)$(notdir $@)
+%.o: %.S scripts FORCE
+	$(Q)$(MAKE) $(build)=$(dir $<) $(dir $<)$(notdir $@)
+
+# For external modules we shall include any directory of the target,
+# but usual case there is no directory part.
+# make M=`pwd` module.o     => $(dir $@)=./
+# make M=`pwd` foo/module.o => $(dir $@)=foo/
+# make M=`pwd` /            => $(dir $@)=/
+ 
+ifeq ($(KBUILD_EXTMOD),)
+        target-dir = $(@D)
+else
+        zap-slash=$(filter-out .,$(patsubst %/,%,$(dir $@)))
+        target-dir = $(KBUILD_EXTMOD)$(if $(zap-slash),/$(zap-slash))
+endif
+
+/ %/:      scripts prepare FORCE
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
+	$(build)=$(target-dir)
+%.ko: scripts FORCE
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1)   \
+	$(build)=$(target-dir) $(@:.ko=.o)
+	$(Q)$(MAKE) -rR -f $(srctree)/scripts/Makefile.modpost
+
 # FIXME Should go into a make.lib or something 
 # ===========================================================================
 
diff --git a/arch/i386/kernel/vmlinux.lds.S b/arch/i386/kernel/vmlinux.lds.S
index 4710195..18f99cc 100644
--- a/arch/i386/kernel/vmlinux.lds.S
+++ b/arch/i386/kernel/vmlinux.lds.S
@@ -7,6 +7,7 @@
 #include <asm-generic/vmlinux.lds.h>
 #include <asm/thread_info.h>
 #include <asm/page.h>
+#include <asm/cache.h>
 
 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
 OUTPUT_ARCH(i386)
@@ -115,7 +116,7 @@ SECTIONS
   __initramfs_start = .;
   .init.ramfs : AT(ADDR(.init.ramfs) - LOAD_OFFSET) { *(.init.ramfs) }
   __initramfs_end = .;
-  . = ALIGN(32);
+  . = ALIGN(L1_CACHE_BYTES);
   __per_cpu_start = .;
   .data.percpu  : AT(ADDR(.data.percpu) - LOAD_OFFSET) { *(.data.percpu) }
   __per_cpu_end = .;
diff --git a/scripts/Kbuild.include b/scripts/Kbuild.include
index 0168d6c..92ce94b 100644
--- a/scripts/Kbuild.include
+++ b/scripts/Kbuild.include
@@ -44,6 +44,43 @@ define filechk
 	fi
 endef
 
+######
+# cc support functions to be used (only) in arch/$(ARCH)/Makefile
+# See documentation in Documentation/kbuild/makefiles.txt
+
+# as-option
+# Usage: cflags-y += $(call as-option, -Wa$(comma)-isa=foo,)
+
+as-option = $(shell if $(CC) $(CFLAGS) $(1) -Wa,-Z -c -o /dev/null \
+	     -xassembler /dev/null > /dev/null 2>&1; then echo "$(1)"; \
+	     else echo "$(2)"; fi ;)
+
+# cc-option
+# Usage: cflags-y += $(call cc-option, -march=winchip-c6, -march=i586)
+
+cc-option = $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null -xc /dev/null \
+             > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi ;)
+
+# cc-option-yn
+# Usage: flag := $(call cc-option-yn, -march=winchip-c6)
+cc-option-yn = $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null -xc /dev/null \
+                > /dev/null 2>&1; then echo "y"; else echo "n"; fi;)
+
+# cc-option-align
+# Prefix align with either -falign or -malign
+cc-option-align = $(subst -functions=0,,\
+	$(call cc-option,-falign-functions=0,-malign-functions=0))
+
+# cc-version
+# Usage gcc-ver := $(call cc-version, $(CC))
+cc-version = $(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-version.sh \
+              $(if $(1), $(1), $(CC)))
+
+# cc-ifversion
+# Usage:  EXTRA_CFLAGS += $(call cc-ifversion, -lt, 0402, -O1)
+cc-ifversion = $(shell if [ $(call cc-version, $(CC)) $(1) $(2) ]; then \
+                       echo $(3); fi;)
+
 ###
 # Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=
 # Usage:
diff --git a/scripts/Makefile.build b/scripts/Makefile.build
index c33e62b..2737765 100644
--- a/scripts/Makefile.build
+++ b/scripts/Makefile.build
@@ -10,11 +10,12 @@ __build:
 # Read .config if it exist, otherwise ignore
 -include .config
 
+include scripts/Kbuild.include
+
 # The filename Kbuild has precedence over Makefile
 kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
 include $(if $(wildcard $(kbuild-dir)/Kbuild), $(kbuild-dir)/Kbuild, $(kbuild-dir)/Makefile)
 
-include scripts/Kbuild.include
 include scripts/Makefile.lib
 
 ifdef host-progs
diff --git a/scripts/Makefile.modpost b/scripts/Makefile.modpost
index bf96a61..563e3c5 100644
--- a/scripts/Makefile.modpost
+++ b/scripts/Makefile.modpost
@@ -39,7 +39,8 @@ include .config
 include scripts/Kbuild.include
 include scripts/Makefile.lib
 
-symverfile := $(objtree)/Module.symvers
+kernelsymfile := $(objtree)/Module.symvers
+modulesymfile := $(KBUILD_EXTMOD)/Modules.symvers
 
 # Step 1), find all modules listed in $(MODVERDIR)/
 __modules := $(sort $(shell grep -h '\.ko' /dev/null $(wildcard $(MODVERDIR)/*.mod)))
@@ -54,7 +55,9 @@ quiet_cmd_modpost = MODPOST
       cmd_modpost = scripts/mod/modpost            \
         $(if $(CONFIG_MODVERSIONS),-m)             \
 	$(if $(CONFIG_MODULE_SRCVERSION_ALL),-a,)  \
-	$(if $(KBUILD_EXTMOD),-i,-o) $(symverfile) \
+	$(if $(KBUILD_EXTMOD),-i,-o) $(kernelsymfile) \
+	$(if $(KBUILD_EXTMOD),-I $(modulesymfile)) \
+	$(if $(KBUILD_EXTMOD),-o $(modulesymfile)) \
 	$(filter-out FORCE,$^)
 
 .PHONY: __modpost
diff --git a/scripts/mod/file2alias.c b/scripts/mod/file2alias.c
index be97caf..1346223 100644
--- a/scripts/mod/file2alias.c
+++ b/scripts/mod/file2alias.c
@@ -153,8 +153,8 @@ static void do_usb_table(void *symval, u
 	const unsigned long id_size = sizeof(struct usb_device_id);
 
 	if (size % id_size || size < id_size) {
-		fprintf(stderr, "*** Warning: %s ids %lu bad size "
-			"(each on %lu)\n", mod->name, size, id_size);
+		warn("%s ids %lu bad size "
+		     "(each on %lu)\n", mod->name, size, id_size);
 	}
 	/* Leave last one: it's the terminator. */
 	size -= id_size;
@@ -217,9 +217,8 @@ static int do_pci_entry(const char *file
 	if ((baseclass_mask != 0 && baseclass_mask != 0xFF)
 	    || (subclass_mask != 0 && subclass_mask != 0xFF)
 	    || (interface_mask != 0 && interface_mask != 0xFF)) {
-		fprintf(stderr,
-			"*** Warning: Can't handle masks in %s:%04X\n",
-			filename, id->class_mask);
+		warn("Can't handle masks in %s:%04X\n",
+		     filename, id->class_mask);
 		return 0;
 	}
 
@@ -445,8 +444,8 @@ static void do_table(void *symval, unsig
 	int (*do_entry)(const char *, void *entry, char *alias) = function;
 
 	if (size % id_size || size < id_size) {
-		fprintf(stderr, "*** Warning: %s ids %lu bad size "
-			"(each on %lu)\n", mod->name, size, id_size);
+		warn("%s ids %lu bad size "
+		     "(each on %lu)\n", mod->name, size, id_size);
 	}
 	/* Leave last one: it's the terminator. */
 	size -= id_size;
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f70ff13..d901095 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -20,9 +20,10 @@ int modversions = 0;
 int have_vmlinux = 0;
 /* Is CONFIG_MODULE_SRCVERSION_ALL set? */
 static int all_versions = 0;
+/* If we are modposting external module set to 1 */
+static int external_module = 0;
 
-void
-fatal(const char *fmt, ...)
+void fatal(const char *fmt, ...)
 {
 	va_list arglist;
 
@@ -35,8 +36,7 @@ fatal(const char *fmt, ...)
 	exit(1);
 }
 
-void
-warn(const char *fmt, ...)
+void warn(const char *fmt, ...)
 {
 	va_list arglist;
 
@@ -47,6 +47,18 @@ warn(const char *fmt, ...)
 	va_end(arglist);
 }
 
+static int is_vmlinux(const char *modname)
+{
+	const char *myname;
+
+	if ((myname = strrchr(modname, '/')))
+		myname++;
+	else
+		myname = modname;
+
+	return strcmp(myname, "vmlinux") == 0;
+}
+
 void *do_nofail(void *ptr, const char *expr)
 {
 	if (!ptr) {
@@ -59,8 +71,7 @@ void *do_nofail(void *ptr, const char *e
 
 static struct module *modules;
 
-struct module *
-find_module(char *modname)
+static struct module *find_module(char *modname)
 {
 	struct module *mod;
 
@@ -70,8 +81,7 @@ find_module(char *modname)
 	return mod;
 }
 
-struct module *
-new_module(char *modname)
+static struct module *new_module(char *modname)
 {
 	struct module *mod;
 	char *p, *s;
@@ -104,6 +114,10 @@ struct symbol {
 	unsigned int crc;
 	int crc_valid;
 	unsigned int weak:1;
+	unsigned int vmlinux:1;    /* 1 if symbol is defined in vmlinux */
+	unsigned int kernel:1;     /* 1 if symbol is from kernel
+				    *  (only for external modules) **/
+	unsigned int preloaded:1;  /* 1 if symbol from Module.symvers */
 	char name[0];
 };
 
@@ -122,11 +136,12 @@ static inline unsigned int tdb_hash(cons
 	return (1103515243 * value + 12345);
 }
 
-/* Allocate a new symbols for use in the hash of exported symbols or
- * the list of unresolved symbols per module */
-
-struct symbol *
-alloc_symbol(const char *name, unsigned int weak, struct symbol *next)
+/**
+ * Allocate a new symbols for use in the hash of exported symbols or
+ * the list of unresolved symbols per module
+ **/
+static struct symbol *alloc_symbol(const char *name, unsigned int weak,
+				   struct symbol *next)
 {
 	struct symbol *s = NOFAIL(malloc(sizeof(*s) + strlen(name) + 1));
 
@@ -138,9 +153,7 @@ alloc_symbol(const char *name, unsigned 
 }
 
 /* For the hash of exported symbols */
-
-void
-new_symbol(const char *name, struct module *module, unsigned int *crc)
+static struct symbol *new_symbol(const char *name, struct module *module)
 {
 	unsigned int hash;
 	struct symbol *new;
@@ -148,14 +161,10 @@ new_symbol(const char *name, struct modu
 	hash = tdb_hash(name) % SYMBOL_HASH_SIZE;
 	new = symbolhash[hash] = alloc_symbol(name, 0, symbolhash[hash]);
 	new->module = module;
-	if (crc) {
-		new->crc = *crc;
-		new->crc_valid = 1;
-	}
+	return new;
 }
 
-struct symbol *
-find_symbol(const char *name)
+static struct symbol *find_symbol(const char *name)
 {
 	struct symbol *s;
 
@@ -170,25 +179,42 @@ find_symbol(const char *name)
 	return NULL;
 }
 
-/* Add an exported symbol - it may have already been added without a
- * CRC, in this case just update the CRC */
-void
-add_exported_symbol(const char *name, struct module *module, unsigned int *crc)
+/**
+ * Add an exported symbol - it may have already been added without a
+ * CRC, in this case just update the CRC
+ **/
+static struct symbol *sym_add_exported(const char *name, struct module *mod)
 {
 	struct symbol *s = find_symbol(name);
 
 	if (!s) {
-		new_symbol(name, module, crc);
-		return;
-	}
-	if (crc) {
-		s->crc = *crc;
-		s->crc_valid = 1;
+		s = new_symbol(name, mod);
+	} else {
+		if (!s->preloaded) {
+			warn("%s: duplicate symbol '%s' previous definition "
+			     "was in %s%s\n", mod->name, name,
+			     s->module->name,
+			     is_vmlinux(s->module->name) ?"":".ko");
+		}
 	}
+	s->preloaded = 0;
+	s->vmlinux   = is_vmlinux(mod->name);
+	s->kernel    = 0;
+	return s;
 }
 
-void *
-grab_file(const char *filename, unsigned long *size)
+static void sym_update_crc(const char *name, struct module *mod,
+			   unsigned int crc)
+{
+	struct symbol *s = find_symbol(name);
+
+	if (!s)
+		s = new_symbol(name, mod);
+	s->crc = crc;
+	s->crc_valid = 1;
+}
+
+void *grab_file(const char *filename, unsigned long *size)
 {
 	struct stat st;
 	void *map;
@@ -207,13 +233,12 @@ grab_file(const char *filename, unsigned
 	return map;
 }
 
-/*
-   Return a copy of the next line in a mmap'ed file.
-   spaces in the beginning of the line is trimmed away.
-   Return a pointer to a static buffer.
-*/
-char*
-get_next_line(unsigned long *pos, void *file, unsigned long size)
+/**
+  * Return a copy of the next line in a mmap'ed file.
+  * spaces in the beginning of the line is trimmed away.
+  * Return a pointer to a static buffer.
+  **/
+char* get_next_line(unsigned long *pos, void *file, unsigned long size)
 {
 	static char line[4096];
 	int skip = 1;
@@ -243,14 +268,12 @@ get_next_line(unsigned long *pos, void *
 	return NULL;
 }
 
-void
-release_file(void *file, unsigned long size)
+void release_file(void *file, unsigned long size)
 {
 	munmap(file, size);
 }
 
-void
-parse_elf(struct elf_info *info, const char *filename)
+static void parse_elf(struct elf_info *info, const char *filename)
 {
 	unsigned int i;
 	Elf_Ehdr *hdr = info->hdr;
@@ -303,8 +326,7 @@ parse_elf(struct elf_info *info, const c
 			             sechdrs[sechdrs[i].sh_link].sh_offset;
 	}
 	if (!info->symtab_start) {
-		fprintf(stderr, "modpost: %s no symtab?\n", filename);
-		abort();
+		fatal("%s has no symtab?\n", filename);
 	}
 	/* Fix endianness in symbols */
 	for (sym = info->symtab_start; sym < info->symtab_stop; sym++) {
@@ -316,12 +338,10 @@ parse_elf(struct elf_info *info, const c
 	return;
 
  truncated:
-	fprintf(stderr, "modpost: %s is truncated.\n", filename);
-	abort();
+	fatal("%s is truncated.\n", filename);
 }
 
-void
-parse_elf_finish(struct elf_info *info)
+static void parse_elf_finish(struct elf_info *info)
 {
 	release_file(info->hdr, info->size);
 }
@@ -329,23 +349,20 @@ parse_elf_finish(struct elf_info *info)
 #define CRC_PFX     "__crc_"
 #define KSYMTAB_PFX "__ksymtab_"
 
-void
-handle_modversions(struct module *mod, struct elf_info *info,
-		   Elf_Sym *sym, const char *symname)
+static void handle_modversions(struct module *mod, struct elf_info *info,
+			       Elf_Sym *sym, const char *symname)
 {
 	unsigned int crc;
 
 	switch (sym->st_shndx) {
 	case SHN_COMMON:
-		fprintf(stderr, "*** Warning: \"%s\" [%s] is COMMON symbol\n",
-			symname, mod->name);
+		warn("\"%s\" [%s] is COMMON symbol\n", symname, mod->name);
 		break;
 	case SHN_ABS:
 		/* CRC'd symbol */
 		if (memcmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
 			crc = (unsigned int) sym->st_value;
-			add_exported_symbol(symname + strlen(CRC_PFX),
-					    mod, &crc);
+			sym_update_crc(symname + strlen(CRC_PFX), mod, crc);
 		}
 		break;
 	case SHN_UNDEF:
@@ -389,8 +406,7 @@ handle_modversions(struct module *mod, s
 	default:
 		/* All exported symbols */
 		if (memcmp(symname, KSYMTAB_PFX, strlen(KSYMTAB_PFX)) == 0) {
-			add_exported_symbol(symname + strlen(KSYMTAB_PFX),
-					    mod, NULL);
+			sym_add_exported(symname + strlen(KSYMTAB_PFX), mod);
 		}
 		if (strcmp(symname, MODULE_SYMBOL_PREFIX "init_module") == 0)
 			mod->has_init = 1;
@@ -400,20 +416,9 @@ handle_modversions(struct module *mod, s
 	}
 }
 
-int
-is_vmlinux(const char *modname)
-{
-	const char *myname;
-
-	if ((myname = strrchr(modname, '/')))
-		myname++;
-	else
-		myname = modname;
-
-	return strcmp(myname, "vmlinux") == 0;
-}
-
-/* Parse tag=value strings from .modinfo section */
+/**
+ * Parse tag=value strings from .modinfo section
+ **/
 static char *next_string(char *string, unsigned long *secsize)
 {
 	/* Skip non-zero chars */
@@ -446,8 +451,7 @@ static char *get_modinfo(void *modinfo, 
 	return NULL;
 }
 
-void
-read_symbols(char *modname)
+static void read_symbols(char *modname)
 {
 	const char *symname;
 	char *version;
@@ -462,9 +466,7 @@ read_symbols(char *modname)
 	/* When there's no vmlinux, don't print warnings about
 	 * unresolved symbols (since there'll be too many ;) */
 	if (is_vmlinux(modname)) {
-		unsigned int fake_crc = 0;
 		have_vmlinux = 1;
-		add_exported_symbol("struct_module", mod, &fake_crc);
 		mod->skip = 1;
 	}
 
@@ -499,8 +501,8 @@ read_symbols(char *modname)
  * following helper, then compare to the file on disk and
  * only update the later if anything changed */
 
-void __attribute__((format(printf, 2, 3)))
-buf_printf(struct buffer *buf, const char *fmt, ...)
+void __attribute__((format(printf, 2, 3))) buf_printf(struct buffer *buf,
+						      const char *fmt, ...)
 {
 	char tmp[SZ];
 	int len;
@@ -517,8 +519,7 @@ buf_printf(struct buffer *buf, const cha
 	va_end(ap);
 }
 
-void
-buf_write(struct buffer *buf, const char *s, int len)
+void buf_write(struct buffer *buf, const char *s, int len)
 {
 	if (buf->size - buf->pos < len) {
 		buf->size += len;
@@ -528,10 +529,10 @@ buf_write(struct buffer *buf, const char
 	buf->pos += len;
 }
 
-/* Header for the generated file */
-
-void
-add_header(struct buffer *b, struct module *mod)
+/**
+ * Header for the generated file
+ **/
+static void add_header(struct buffer *b, struct module *mod)
 {
 	buf_printf(b, "#include <linux/module.h>\n");
 	buf_printf(b, "#include <linux/vermagic.h>\n");
@@ -551,10 +552,10 @@ add_header(struct buffer *b, struct modu
 	buf_printf(b, "};\n");
 }
 
-/* Record CRCs for unresolved symbols */
-
-void
-add_versions(struct buffer *b, struct module *mod)
+/**
+ * Record CRCs for unresolved symbols
+ **/
+static void add_versions(struct buffer *b, struct module *mod)
 {
 	struct symbol *s, *exp;
 
@@ -562,8 +563,8 @@ add_versions(struct buffer *b, struct mo
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod) {
 			if (have_vmlinux && !s->weak)
-				fprintf(stderr, "*** Warning: \"%s\" [%s.ko] "
-				"undefined!\n",	s->name, mod->name);
+				warn("\"%s\" [%s.ko] undefined!\n",
+				     s->name, mod->name);
 			continue;
 		}
 		s->module = exp->module;
@@ -584,8 +585,7 @@ add_versions(struct buffer *b, struct mo
 			continue;
 		}
 		if (!s->crc_valid) {
-			fprintf(stderr, "*** Warning: \"%s\" [%s.ko] "
-				"has no CRC!\n",
+			warn("\"%s\" [%s.ko] has no CRC!\n",
 				s->name, mod->name);
 			continue;
 		}
@@ -595,8 +595,8 @@ add_versions(struct buffer *b, struct mo
 	buf_printf(b, "};\n");
 }
 
-void
-add_depends(struct buffer *b, struct module *mod, struct module *modules)
+static void add_depends(struct buffer *b, struct module *mod,
+			struct module *modules)
 {
 	struct symbol *s;
 	struct module *m;
@@ -626,8 +626,7 @@ add_depends(struct buffer *b, struct mod
 	buf_printf(b, "\";\n");
 }
 
-void
-add_srcversion(struct buffer *b, struct module *mod)
+static void add_srcversion(struct buffer *b, struct module *mod)
 {
 	if (mod->srcversion[0]) {
 		buf_printf(b, "\n");
@@ -636,8 +635,7 @@ add_srcversion(struct buffer *b, struct 
 	}
 }
 
-void
-write_if_changed(struct buffer *b, const char *fname)
+static void write_if_changed(struct buffer *b, const char *fname)
 {
 	char *tmp;
 	FILE *file;
@@ -681,8 +679,7 @@ write_if_changed(struct buffer *b, const
 	fclose(file);
 }
 
-void
-read_dump(const char *fname)
+static void read_dump(const char *fname, unsigned int kernel)
 {
 	unsigned long size, pos = 0;
 	void *file = grab_file(fname, &size);
@@ -696,6 +693,7 @@ read_dump(const char *fname)
 		char *symname, *modname, *d;
 		unsigned int crc;
 		struct module *mod;
+		struct symbol *s;
 
 		if (!(symname = strchr(line, '\t')))
 			goto fail;
@@ -716,15 +714,30 @@ read_dump(const char *fname)
 			mod = new_module(NOFAIL(strdup(modname)));
 			mod->skip = 1;
 		}
-		add_exported_symbol(symname, mod, &crc);
+		s = sym_add_exported(symname, mod);
+		s->kernel    = kernel;
+		s->preloaded = 1;
+		sym_update_crc(symname, mod, crc);
 	}
 	return;
 fail:
 	fatal("parse error in symbol dump file\n");
 }
 
-void
-write_dump(const char *fname)
+/* For normal builds always dump all symbols.
+ * For external modules only dump symbols
+ * that are not read from kernel Module.symvers.
+ **/
+static int dump_sym(struct symbol *sym)
+{
+	if (!external_module)
+		return 1;
+	if (sym->vmlinux || sym->kernel)
+		return 0;
+	return 1;
+}
+		
+static void write_dump(const char *fname)
 {
 	struct buffer buf = { };
 	struct symbol *symbol;
@@ -733,34 +746,33 @@ write_dump(const char *fname)
 	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
 		symbol = symbolhash[n];
 		while (symbol) {
-			symbol = symbol->next;
-		}
-	}
-
-	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
-		symbol = symbolhash[n];
-		while (symbol) {
-			buf_printf(&buf, "0x%08x\t%s\t%s\n", symbol->crc,
-				symbol->name, symbol->module->name);
+			if (dump_sym(symbol))
+				buf_printf(&buf, "0x%08x\t%s\t%s\n",
+					symbol->crc, symbol->name, 
+					symbol->module->name);
 			symbol = symbol->next;
 		}
 	}
 	write_if_changed(&buf, fname);
 }
 
-int
-main(int argc, char **argv)
+int main(int argc, char **argv)
 {
 	struct module *mod;
 	struct buffer buf = { };
 	char fname[SZ];
-	char *dump_read = NULL, *dump_write = NULL;
+	char *kernel_read = NULL, *module_read = NULL;
+	char *dump_write = NULL;
 	int opt;
 
-	while ((opt = getopt(argc, argv, "i:mo:a")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:mo:a")) != -1) {
 		switch(opt) {
 			case 'i':
-				dump_read = optarg;
+				kernel_read = optarg;
+				break;
+			case 'I':
+				module_read = optarg;
+				external_module = 1;
 				break;
 			case 'm':
 				modversions = 1;
@@ -776,8 +788,10 @@ main(int argc, char **argv)
 		}
 	}
 
-	if (dump_read)
-		read_dump(dump_read);
+	if (kernel_read)
+		read_dump(kernel_read, 1);
+	if (module_read)
+		read_dump(module_read, 0);
 
 	while (optind < argc) {
 		read_symbols(argv[optind++]);
@@ -804,4 +818,3 @@ main(int argc, char **argv)
 
 	return 0;
 }
-
diff --git a/scripts/mod/modpost.h b/scripts/mod/modpost.h
index 7334d83..c0de7b9 100644
--- a/scripts/mod/modpost.h
+++ b/scripts/mod/modpost.h
@@ -91,17 +91,22 @@ struct elf_info {
 	unsigned int modinfo_len;
 };
 
+/* file2alias.c */
 void handle_moddevtable(struct module *mod, struct elf_info *info,
 			Elf_Sym *sym, const char *symname);
-
 void add_moddevtable(struct buffer *buf, struct module *mod);
 
+/* sumversion.c */
 void maybe_frob_rcs_version(const char *modfilename,
 			    char *version,
 			    void *modinfo,
 			    unsigned long modinfo_offset);
 void get_src_version(const char *modname, char sum[], unsigned sumlen);
 
+/* from modpost.c */
 void *grab_file(const char *filename, unsigned long *size);
 char* get_next_line(unsigned long *pos, void *file, unsigned long size);
 void release_file(void *file, unsigned long size);
+
+void fatal(const char *fmt, ...);
+void warn(const char *fmt, ...);
diff --git a/scripts/mod/sumversion.c b/scripts/mod/sumversion.c
index 43271a1..5c07545 100644
--- a/scripts/mod/sumversion.c
+++ b/scripts/mod/sumversion.c
@@ -316,8 +316,7 @@ static int parse_source_files(const char
 
 	file = grab_file(cmd, &flen);
 	if (!file) {
-		fprintf(stderr, "Warning: could not find %s for %s\n",
-			cmd, objfile);
+		warn("could not find %s for %s\n", cmd, objfile);
 		goto out;
 	}
 
@@ -355,9 +354,8 @@ static int parse_source_files(const char
 		/* Check if this file is in same dir as objfile */
 		if ((strstr(line, dir)+strlen(dir)-1) == strrchr(line, '/')) {
 			if (!parse_file(line, md)) {
-				fprintf(stderr,
-					"Warning: could not open %s: %s\n",
-					line, strerror(errno));
+				warn("could not open %s: %s\n",
+				     line, strerror(errno));
 				goto out_file;
 			}
 
@@ -397,23 +395,20 @@ void get_src_version(const char *modname
 
 	file = grab_file(filelist, &len);
 	if (!file) {
-		fprintf(stderr, "Warning: could not find versions for %s\n",
-			filelist);
+		warn("could not find versions for %s\n", filelist);
 		return;
 	}
 
 	sources = strchr(file, '\n');
 	if (!sources) {
-		fprintf(stderr, "Warning: malformed versions file for %s\n",
-			modname);
+		warn("malformed versions file for %s\n", modname);
 		goto release;
 	}
 
 	sources++;
 	end = strchr(sources, '\n');
 	if (!end) {
-		fprintf(stderr, "Warning: bad ending versions file for %s\n",
-			modname);
+		warn("bad ending versions file for %s\n", modname);
 		goto release;
 	}
 	*end = '\0';
@@ -438,19 +433,19 @@ static void write_version(const char *fi
 
 	fd = open(filename, O_RDWR);
 	if (fd < 0) {
-		fprintf(stderr, "Warning: changing sum in %s failed: %s\n",
+		warn("changing sum in %s failed: %s\n",
 			filename, strerror(errno));
 		return;
 	}
 
 	if (lseek(fd, offset, SEEK_SET) == (off_t)-1) {
-		fprintf(stderr, "Warning: changing sum in %s:%lu failed: %s\n",
+		warn("changing sum in %s:%lu failed: %s\n",
 			filename, offset, strerror(errno));
 		goto out;
 	}
 
 	if (write(fd, sum, strlen(sum)+1) != strlen(sum)+1) {
-		fprintf(stderr, "Warning: writing sum in %s failed: %s\n",
+		warn("writing sum in %s failed: %s\n",
 			filename, strerror(errno));
 		goto out;
 	}
