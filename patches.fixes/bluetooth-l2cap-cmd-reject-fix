Date: Sat, 04 Sep 2004 12:52:38 +0200
From: Marcel holtman <marcel@holtmann.org>
Subject: Don't send L2CAP reject command for bad responses

# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/09/04 12:52:38+02:00 marcel@holtmann.org 
#   [Bluetooth] Don't send L2CAP reject command for bad responses
#   
#   If a L2CAP response is bad or not understood there is no need to send
#   a reject command. The right way is to ignore the response and let the
#   L2CAP timers trigger the further actions.
#   
#   Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
# 
# net/bluetooth/l2cap.c
#   2004/09/04 12:51:17+02:00 marcel@holtmann.org +10 -9
#   Don't send L2CAP reject command for bad responses
# 
diff -Nru a/net/bluetooth/l2cap.c b/net/bluetooth/l2cap.c
--- a/net/bluetooth/l2cap.c	2004-09-06 13:57:58 +02:00
+++ b/net/bluetooth/l2cap.c	2004-09-06 13:57:58 +02:00
@@ -57,7 +57,7 @@
 #define BT_DBG(D...)
 #endif
 
-#define VERSION "2.3"
+#define VERSION "2.4"
 
 static struct proto_ops l2cap_sock_ops;
 
@@ -1453,7 +1453,7 @@
 	BT_DBG("dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x", dcid, scid, result, status);
 
 	if (!(sk = l2cap_get_chan_by_scid(&conn->chan_list, scid)))
-		return -ENOENT;
+		return 0;
 
 	switch (result) {
 	case L2CAP_CR_SUCCESS:
@@ -1527,7 +1527,6 @@
 	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;
 	u16 scid, flags, result;
 	struct sock *sk;
-	int err = 0;
 
 	scid   = __le16_to_cpu(rsp->scid);
 	flags  = __le16_to_cpu(rsp->flags);
@@ -1536,7 +1535,7 @@
 	BT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x", scid, flags, result);
 
 	if (!(sk = l2cap_get_chan_by_scid(&conn->chan_list, scid)))
-		return -ENOENT;
+		return 0;
 
 	switch (result) {
 	case L2CAP_CONF_SUCCESS:
@@ -1581,7 +1580,7 @@
 
 done:
 	bh_unlock_sock(sk);
-	return err;
+	return 0;
 }
 
 static inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
@@ -1625,6 +1624,7 @@
 
 	if (!(sk = l2cap_get_chan_by_scid(&conn->chan_list, scid)))
 		return 0;
+
 	l2cap_chan_del(sk, 0);
 	bh_unlock_sock(sk);
 
@@ -1632,7 +1632,7 @@
 	return 0;
 }
 
-static inline int l2cap_info_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
 	struct l2cap_info_req *req = (struct l2cap_info_req *) data;
 	struct l2cap_info_rsp rsp;
@@ -1645,10 +1645,11 @@
 	rsp.type   = __cpu_to_le16(type);
 	rsp.result = __cpu_to_le16(L2CAP_IR_NOTSUPP);
 	l2cap_send_rsp(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(rsp), &rsp);
+
 	return 0;
 }
 
-static inline int l2cap_info_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
 	struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;
 	u16 type, result;
@@ -1721,11 +1722,11 @@
 			break;
 
 		case L2CAP_INFO_REQ:
-			err = l2cap_info_req(conn, &cmd, data);
+			err = l2cap_information_req(conn, &cmd, data);
 			break;
 
 		case L2CAP_INFO_RSP:
-			err = l2cap_info_rsp(conn, &cmd, data);
+			err = l2cap_information_rsp(conn, &cmd, data);
 			break;
 
 		default:
