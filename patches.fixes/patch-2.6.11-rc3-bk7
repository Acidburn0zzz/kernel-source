From: olh@suse.de
Subject: patch-2.6.11-rc3-bk7

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc3-bk6.log	2005-02-09 13:57:28.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc3-bk7.log	2005-02-10 14:04:26.000000000 +0100
 ChangeSet@1.2149.1.2, 2005-02-09 07:35:29-08:00, michael@ellerman.id.au
   [PATCH] Fix oops in alloc_zeroed_user_highpage() when page is NULL
   
   The generic and IA-64 versions of alloc_zeroed_user_highpage() don't
   check the return value from alloc_page_vma().  This can lead to an oops
   if we're OOM.
   
   This fixes my oops on PPC64, but I haven't got an IA-64 machine/compiler
   handy.
   
   Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2149.2.8, 2005-02-08 20:24:20-08:00, kaber@trash.net
   [PKT_SCHED]: Fix u32 double listing.
   
   Signed-off-by: Patrick McHardy <kaber@trash.net>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2149.2.7, 2005-02-08 20:22:16-08:00, tgraf@suug.ch
   [TCP]: Fix calculation for collapsed skb size
   
   Noticed by Denis V. Lunev <den@asplinux.ru> and based upon
   original patch by Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
   
   Signed-off-by: Thomas Graf <tgraf@suug.ch>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2149.2.6, 2005-02-08 20:05:07-08:00, nacc@us.ibm.com
   [IPV4]: ipconfig: Replace schedule_timeout() with msleep()
   
   Description: Use msleep() instead of schedule_timeout() to guarantee the task
   delays as expected. Change the units of the two constants to be msecs and secs
   respectively.
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2149.2.5, 2005-02-08 20:04:08-08:00, nacc@us.ibm.com
   [IPVS]: Replace schedule_timeout() with ssleep()
   
   Description: Use ssleep() instead of schedule_timeout() to guarantee the task
   delays as expected. The first two replacements use TASK_INTERRUPTIBLE but do not
   check for signals, so ssleep() should be appropriate.
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2149.2.4, 2005-02-08 16:20:23-08:00, nacc@us.ibm.com
   [NET]: Replace schedule_timeout() with msleep() in netdev_wait_allrefs()
   
   Description: Use msleep() instead of schedule_timeout() to guarantee the task
   delays as expected. The current code uses TASK_INTERRUPTIBLE, but does not
   respond to signals, so msleep() should be ok.
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2149.2.3, 2005-02-08 16:18:48-08:00, bunk@stusta.de
   [XFRM]: Kill xfrm_export.c
   
   This patch removes xfrm_export.c and moves the EXPORT_SYMBOL{,_GPL}'s to 
   the files where the actual functions are.
   
   Signed-off-by: Adrian Bunk <bunk@stusta.de>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2149.2.2, 2005-02-08 15:59:00-08:00, davem@nuts.davemloft.net
   [TG3]: Update driver version and reldate.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2149.2.1, 2005-02-08 15:57:45-08:00, grundler@parisc-linux.org
   [TG3]: Clean up grc_local_ctrl usage.
   
   Make the code more readable by only flipping the specific
   bits that need to change each register write.
   
   Signed-off-by: Grant Grundler (grundler@parisc-linux.org)
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2150, 2005-02-08 09:59:28-08:00, kaos@sgi.com
   [IA64] mca_asm.S: Correctly dereference ia64_mca_data
   
   arch/ia64/kernel/mca_asm.S is treating per_cpu__ia64_mca_data as the
   start of the mca data, instead of as a pointer to the mca data.  It
   ends up overwriting the rest of the per cpu area with the MCA stack and
   bspstore.  Since we dereference ia64_mca_data several times, make it a
   macro.
   
   Signed-off-by: Keith Owens <kaos@sgi.com>
   Signed-off-by: Tony Luck <tony.luck@intel.com>
 
diff -purN linux-2.6.11-rc3-bk6/Makefile linux-2.6.11-rc3-bk7/Makefile
--- linux-2.6.11-rc3-bk6/Makefile	2005-02-10 15:07:46.390795838 +0100
+++ linux-2.6.11-rc3-bk7/Makefile	2005-02-10 15:07:53.267658430 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc3-bk6
+EXTRAVERSION = -rc3-bk7
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc3-bk6/arch/ia64/kernel/mca_asm.S linux-2.6.11-rc3-bk7/arch/ia64/kernel/mca_asm.S
--- linux-2.6.11-rc3-bk6/arch/ia64/kernel/mca_asm.S	2005-02-10 15:07:46.445787279 +0100
+++ linux-2.6.11-rc3-bk7/arch/ia64/kernel/mca_asm.S	2005-02-10 15:07:53.322783043 +0100
@@ -101,6 +101,11 @@
 	ld8	tmp=[sal_to_os_handoff];;				\
 	st8     [os_to_sal_handoff]=tmp;;
 
+#define GET_IA64_MCA_DATA(reg)						\
+	GET_THIS_PADDR(reg, ia64_mca_data)				\
+	;;								\
+	ld8 reg=[reg]
+
 	.global ia64_os_mca_dispatch
 	.global ia64_os_mca_dispatch_end
 	.global ia64_sal_to_os_handoff_state
@@ -309,14 +314,14 @@ err:
 done_tlb_purge_and_reload:
 
 	// Setup new stack frame for OS_MCA handling
-	GET_THIS_PADDR(r2, ia64_mca_data)
+	GET_IA64_MCA_DATA(r2)
 	;;
 	add r3 = IA64_MCA_CPU_STACKFRAME_OFFSET, r2
 	add r2 = IA64_MCA_CPU_RBSTORE_OFFSET, r2
 	;;
 	rse_switch_context(r6,r3,r2);;	// RSC management in this new context
 
-	GET_THIS_PADDR(r2, ia64_mca_data)
+	GET_IA64_MCA_DATA(r2)
 	;;
 	add r2 = IA64_MCA_CPU_STACK_OFFSET+IA64_MCA_STACK_SIZE-16, r2
 	;;
@@ -336,7 +341,7 @@ ia64_os_mca_virtual_begin:
 ia64_os_mca_virtual_end:
 
 	// restore the original stack frame here
-	GET_THIS_PADDR(r2, ia64_mca_data)
+	GET_IA64_MCA_DATA(r2)
 	;;
 	add r2 = IA64_MCA_CPU_STACKFRAME_OFFSET, r2
 	;;
@@ -380,7 +385,7 @@ ia64_os_mca_dispatch_end:
 ia64_os_mca_proc_state_dump:
 // Save bank 1 GRs 16-31 which will be used by c-language code when we switch
 //  to virtual addressing mode.
-	GET_THIS_PADDR(r2, ia64_mca_data)
+	GET_IA64_MCA_DATA(r2)
 	;;
 	add r2 = IA64_MCA_CPU_PROC_STATE_DUMP_OFFSET, r2
 	;;
@@ -613,7 +618,7 @@ end_os_mca_dump:
 ia64_os_mca_proc_state_restore:
 
 // Restore bank1 GR16-31
-	GET_THIS_PADDR(r2, ia64_mca_data)
+	GET_IA64_MCA_DATA(r2)
 	;;
 	add r2 = IA64_MCA_CPU_PROC_STATE_DUMP_OFFSET, r2
 
diff -purN linux-2.6.11-rc3-bk6/drivers/net/tg3.c linux-2.6.11-rc3-bk7/drivers/net/tg3.c
--- linux-2.6.11-rc3-bk6/drivers/net/tg3.c	2005-02-10 15:07:46.917713824 +0100
+++ linux-2.6.11-rc3-bk7/drivers/net/tg3.c	2005-02-10 15:07:53.791710054 +0100
@@ -60,8 +60,8 @@
 
 #define DRV_MODULE_NAME		"tg3"
 #define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"3.20"
-#define DRV_MODULE_RELDATE	"February 2, 2005"
+#define DRV_MODULE_VERSION	"3.21"
+#define DRV_MODULE_RELDATE	"February 8, 2005"
 
 #define TG3_DEF_MAC_MODE	0
 #define TG3_DEF_RX_MODE		0
@@ -893,7 +893,7 @@ static void tg3_frob_aux_power(struct tg
 			      GRC_LCLCTRL_GPIO_OUTPUT1));
 			udelay(100);
 		} else {
-			int no_gpio2;
+			u32 no_gpio2;
 			u32 grc_local_ctrl;
 
 			if (tp_peer != tp &&
@@ -901,8 +901,8 @@ static void tg3_frob_aux_power(struct tg
 				return;
 
 			/* On 5753 and variants, GPIO2 cannot be used. */
-			no_gpio2 = (tp->nic_sram_data_cfg &
-				    NIC_SRAM_DATA_CFG_NO_GPIO2) != 0;
+			no_gpio2 = tp->nic_sram_data_cfg &
+				    NIC_SRAM_DATA_CFG_NO_GPIO2;
 
 			grc_local_ctrl = GRC_LCLCTRL_GPIO_OE0 |
 					 GRC_LCLCTRL_GPIO_OE1 |
@@ -914,29 +914,17 @@ static void tg3_frob_aux_power(struct tg
 						    GRC_LCLCTRL_GPIO_OUTPUT2);
 			}
 			tw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl |
-			       grc_local_ctrl);
+						grc_local_ctrl);
 			udelay(100);
 
-			grc_local_ctrl = GRC_LCLCTRL_GPIO_OE0 |
-					 GRC_LCLCTRL_GPIO_OE1 |
-					 GRC_LCLCTRL_GPIO_OE2 |
-					 GRC_LCLCTRL_GPIO_OUTPUT0 |
-					 GRC_LCLCTRL_GPIO_OUTPUT1 |
-					 GRC_LCLCTRL_GPIO_OUTPUT2;
-			if (no_gpio2) {
-				grc_local_ctrl &= ~(GRC_LCLCTRL_GPIO_OE2 |
-						    GRC_LCLCTRL_GPIO_OUTPUT2);
-			}
+			grc_local_ctrl |= GRC_LCLCTRL_GPIO_OUTPUT0;
+
 			tw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl |
-			       grc_local_ctrl);
+						grc_local_ctrl);
 			udelay(100);
 
-			grc_local_ctrl = GRC_LCLCTRL_GPIO_OE0 |
-					 GRC_LCLCTRL_GPIO_OE1 |
-					 GRC_LCLCTRL_GPIO_OE2 |
-					 GRC_LCLCTRL_GPIO_OUTPUT0 |
-					 GRC_LCLCTRL_GPIO_OUTPUT1;
 			if (!no_gpio2) {
+				grc_local_ctrl &= ~GRC_LCLCTRL_GPIO_OUTPUT2;
 				tw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl |
 				       grc_local_ctrl);
 				udelay(100);
diff -purN linux-2.6.11-rc3-bk6/include/asm-ia64/page.h linux-2.6.11-rc3-bk7/include/asm-ia64/page.h
--- linux-2.6.11-rc3-bk6/include/asm-ia64/page.h	2005-02-03 02:55:08.000000000 +0100
+++ linux-2.6.11-rc3-bk7/include/asm-ia64/page.h	2005-02-10 15:07:53.976681263 +0100
@@ -79,7 +79,8 @@ do {						\
 #define alloc_zeroed_user_highpage(vma, vaddr) \
 ({						\
 	struct page *page = alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr); \
-	flush_dcache_page(page);		\
+	if (page)				\
+ 		flush_dcache_page(page);	\
 	page;					\
 })
 
diff -purN linux-2.6.11-rc3-bk6/include/linux/highmem.h linux-2.6.11-rc3-bk7/include/linux/highmem.h
--- linux-2.6.11-rc3-bk6/include/linux/highmem.h	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk7/include/linux/highmem.h	2005-02-10 15:07:54.088663833 +0100
@@ -48,7 +48,9 @@ alloc_zeroed_user_highpage(struct vm_are
 {
 	struct page *page = alloc_page_vma(GFP_HIGHUSER, vma, vaddr);
 
-	clear_user_highpage(page, vaddr);
+	if (page)
+		clear_user_highpage(page, vaddr);
+
 	return page;
 }
 #endif
diff -purN linux-2.6.11-rc3-bk6/net/core/dev.c linux-2.6.11-rc3-bk7/net/core/dev.c
--- linux-2.6.11-rc3-bk6/net/core/dev.c	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk7/net/core/dev.c	2005-02-10 15:07:54.157653095 +0100
@@ -108,6 +108,7 @@
 #include <linux/kallsyms.h>
 #include <linux/netpoll.h>
 #include <linux/rcupdate.h>
+#include <linux/delay.h>
 #ifdef CONFIG_NET_RADIO
 #include <linux/wireless.h>		/* Note : will define WIRELESS_EXT */
 #include <net/iw_handler.h>
@@ -2899,8 +2900,7 @@ static void netdev_wait_allrefs(struct n
 			rebroadcast_time = jiffies;
 		}
 
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(HZ / 4);
+		msleep(250);
 
 		if (time_after(jiffies, warning_time + 10 * HZ)) {
 			printk(KERN_EMERG "unregister_netdevice: "
diff -purN linux-2.6.11-rc3-bk6/net/ipv4/ipconfig.c linux-2.6.11-rc3-bk7/net/ipv4/ipconfig.c
--- linux-2.6.11-rc3-bk6/net/ipv4/ipconfig.c	2005-02-10 15:07:47.278790970 +0100
+++ linux-2.6.11-rc3-bk7/net/ipv4/ipconfig.c	2005-02-10 15:07:54.161652472 +0100
@@ -53,6 +53,7 @@
 #include <linux/seq_file.h>
 #include <linux/major.h>
 #include <linux/root_dev.h>
+#include <linux/delay.h>
 #include <net/arp.h>
 #include <net/ip.h>
 #include <net/ipconfig.h>
@@ -84,8 +85,8 @@
 #endif
 
 /* Define the friendly delay before and after opening net devices */
-#define CONF_PRE_OPEN		(HZ/2)	/* Before opening: 1/2 second */
-#define CONF_POST_OPEN		(1*HZ)	/* After opening: 1 second */
+#define CONF_PRE_OPEN		500	/* Before opening: 1/2 second */
+#define CONF_POST_OPEN		1	/* After opening: 1 second */
 
 /* Define the timeout for waiting for a DHCP/BOOTP/RARP reply */
 #define CONF_OPEN_RETRIES 	2	/* (Re)open devices twice */
@@ -1259,16 +1260,14 @@ static int __init ip_auto_config(void)
  try_try_again:
 #endif
 	/* Give hardware a chance to settle */
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(CONF_PRE_OPEN);
+	msleep(CONF_PRE_OPEN);
 
 	/* Setup all network devices */
 	if (ic_open_devs() < 0)
 		return -1;
 
 	/* Give drivers a chance to settle */
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(CONF_POST_OPEN);
+	ssleep(CONF_POST_OPEN);
 
 	/*
 	 * If the config information is insufficient (e.g., our IP address or
diff -purN linux-2.6.11-rc3-bk6/net/ipv4/ipvs/ip_vs_sync.c linux-2.6.11-rc3-bk7/net/ipv4/ipvs/ip_vs_sync.c
--- linux-2.6.11-rc3-bk6/net/ipv4/ipvs/ip_vs_sync.c	2005-02-03 02:57:04.000000000 +0100
+++ linux-2.6.11-rc3-bk7/net/ipv4/ipvs/ip_vs_sync.c	2005-02-10 15:07:54.163652161 +0100
@@ -23,7 +23,7 @@
 #include <linux/slab.h>
 #include <linux/net.h>
 #include <linux/completion.h>
-
+#include <linux/delay.h>
 #include <linux/skbuff.h>
 #include <linux/in.h>
 #include <linux/igmp.h>                 /* for ip_mc_join_group */
@@ -647,8 +647,7 @@ static void sync_master_loop(void)
 		if (stop_master_sync)
 			break;
 
-		__set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(HZ);
+		ssleep(1);
 	}
 
 	/* clean up the sync_buff queue */
@@ -705,8 +704,7 @@ static void sync_backup_loop(void)
 		if (stop_backup_sync)
 			break;
 
-		__set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(HZ);
+		ssleep(1);
 	}
 
 	/* release the sending multicast socket */
@@ -818,8 +816,7 @@ static int fork_sync_thread(void *startu
 	if ((pid = kernel_thread(sync_thread, startup, 0)) < 0) {
 		IP_VS_ERR("could not create sync_thread due to %d... "
 			  "retrying.\n", pid);
-		current->state = TASK_UNINTERRUPTIBLE;
-		schedule_timeout(HZ);
+		ssleep(1);
 		goto repeat;
 	}
 
@@ -853,8 +850,7 @@ int start_sync_thread(int state, char *m
 	if ((pid = kernel_thread(fork_sync_thread, &startup, 0)) < 0) {
 		IP_VS_ERR("could not create fork_sync_thread due to %d... "
 			  "retrying.\n", pid);
-		current->state = TASK_UNINTERRUPTIBLE;
-		schedule_timeout(HZ);
+		ssleep(1);
 		goto repeat;
 	}
 
diff -purN linux-2.6.11-rc3-bk6/net/ipv4/tcp_input.c linux-2.6.11-rc3-bk7/net/ipv4/tcp_input.c
--- linux-2.6.11-rc3-bk6/net/ipv4/tcp_input.c	2005-02-03 02:56:22.000000000 +0100
+++ linux-2.6.11-rc3-bk7/net/ipv4/tcp_input.c	2005-02-10 15:07:54.182782533 +0100
@@ -3760,8 +3760,7 @@ tcp_collapse(struct sock *sk, struct sk_
 	while (before(start, end)) {
 		struct sk_buff *nskb;
 		int header = skb_headroom(skb);
-		int copy = (PAGE_SIZE - sizeof(struct sk_buff) -
-			    sizeof(struct skb_shared_info) - header - 31)&~15;
+		int copy = SKB_MAX_ORDER(header, 0);
 
 		/* Too big header? This can happen with IPv6. */
 		if (copy < 0)
diff -purN linux-2.6.11-rc3-bk6/net/sched/cls_u32.c linux-2.6.11-rc3-bk7/net/sched/cls_u32.c
--- linux-2.6.11-rc3-bk6/net/sched/cls_u32.c	2005-02-03 02:55:23.000000000 +0100
+++ linux-2.6.11-rc3-bk7/net/sched/cls_u32.c	2005-02-10 15:07:54.203779265 +0100
@@ -91,6 +91,7 @@ struct tc_u_hnode
 {
 	struct tc_u_hnode	*next;
 	u32			handle;
+	u32			prio;
 	struct tc_u_common	*tp_c;
 	int			refcnt;
 	unsigned		divisor;
@@ -323,6 +324,7 @@ static int u32_init(struct tcf_proto *tp
 	root_ht->divisor = 0;
 	root_ht->refcnt++;
 	root_ht->handle = tp_c ? gen_new_htid(tp_c) : 0x80000000;
+	root_ht->prio = tp->prio;
 
 	if (tp_c == NULL) {
 		tp_c = kmalloc(sizeof(*tp_c), GFP_KERNEL);
@@ -587,6 +589,7 @@ static int u32_change(struct tcf_proto *
 		ht->refcnt = 0;
 		ht->divisor = divisor;
 		ht->handle = handle;
+		ht->prio = tp->prio;
 		ht->next = tp_c->hlist;
 		tp_c->hlist = ht;
 		*arg = (unsigned long)ht;
@@ -703,6 +706,8 @@ static void u32_walk(struct tcf_proto *t
 		return;
 
 	for (ht = tp_c->hlist; ht; ht = ht->next) {
+		if (ht->prio != tp->prio)
+			continue;
 		if (arg->count >= arg->skip) {
 			if (arg->fn(tp, (unsigned long)ht, arg) < 0) {
 				arg->stop = 1;
diff -purN linux-2.6.11-rc3-bk6/net/xfrm/Makefile linux-2.6.11-rc3-bk7/net/xfrm/Makefile
--- linux-2.6.11-rc3-bk6/net/xfrm/Makefile	2005-02-03 02:57:04.000000000 +0100
+++ linux-2.6.11-rc3-bk7/net/xfrm/Makefile	2005-02-10 15:07:54.207778642 +0100
@@ -2,7 +2,6 @@
 # Makefile for the XFRM subsystem.
 #
 
-obj-$(CONFIG_XFRM) := xfrm_policy.o xfrm_state.o xfrm_input.o xfrm_algo.o \
-	xfrm_export.o
+obj-$(CONFIG_XFRM) := xfrm_policy.o xfrm_state.o xfrm_input.o xfrm_algo.o
 obj-$(CONFIG_XFRM_USER) += xfrm_user.o
 
diff -purN linux-2.6.11-rc3-bk6/net/xfrm/xfrm_algo.c linux-2.6.11-rc3-bk7/net/xfrm/xfrm_algo.c
--- linux-2.6.11-rc3-bk6/net/xfrm/xfrm_algo.c	2005-02-10 15:07:47.297788014 +0100
+++ linux-2.6.11-rc3-bk7/net/xfrm/xfrm_algo.c	2005-02-10 15:07:54.210778176 +0100
@@ -316,6 +316,7 @@ struct xfrm_algo_desc *xfrm_aalg_get_byi
 	}
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(xfrm_aalg_get_byid);
 
 struct xfrm_algo_desc *xfrm_ealg_get_byid(int alg_id)
 {
@@ -331,6 +332,7 @@ struct xfrm_algo_desc *xfrm_ealg_get_byi
 	}
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(xfrm_ealg_get_byid);
 
 struct xfrm_algo_desc *xfrm_calg_get_byid(int alg_id)
 {
@@ -346,6 +348,7 @@ struct xfrm_algo_desc *xfrm_calg_get_byi
 	}
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(xfrm_calg_get_byid);
 
 static struct xfrm_algo_desc *xfrm_get_byname(struct xfrm_algo_desc *list,
 					      int entries, char *name,
@@ -380,16 +383,19 @@ struct xfrm_algo_desc *xfrm_aalg_get_byn
 {
 	return xfrm_get_byname(aalg_list, aalg_entries(), name, probe);
 }
+EXPORT_SYMBOL_GPL(xfrm_aalg_get_byname);
 
 struct xfrm_algo_desc *xfrm_ealg_get_byname(char *name, int probe)
 {
 	return xfrm_get_byname(ealg_list, ealg_entries(), name, probe);
 }
+EXPORT_SYMBOL_GPL(xfrm_ealg_get_byname);
 
 struct xfrm_algo_desc *xfrm_calg_get_byname(char *name, int probe)
 {
 	return xfrm_get_byname(calg_list, calg_entries(), name, probe);
 }
+EXPORT_SYMBOL_GPL(xfrm_calg_get_byname);
 
 struct xfrm_algo_desc *xfrm_aalg_get_byidx(unsigned int idx)
 {
@@ -398,6 +404,7 @@ struct xfrm_algo_desc *xfrm_aalg_get_byi
 
 	return &aalg_list[idx];
 }
+EXPORT_SYMBOL_GPL(xfrm_aalg_get_byidx);
 
 struct xfrm_algo_desc *xfrm_ealg_get_byidx(unsigned int idx)
 {
@@ -406,6 +413,7 @@ struct xfrm_algo_desc *xfrm_ealg_get_byi
 
 	return &ealg_list[idx];
 }
+EXPORT_SYMBOL_GPL(xfrm_ealg_get_byidx);
 
 /*
  * Probe for the availability of crypto algorithms, and set the available
@@ -438,6 +446,7 @@ void xfrm_probe_algs(void)
 	}
 #endif
 }
+EXPORT_SYMBOL_GPL(xfrm_probe_algs);
 
 int xfrm_count_auth_supported(void)
 {
@@ -448,6 +457,7 @@ int xfrm_count_auth_supported(void)
 			n++;
 	return n;
 }
+EXPORT_SYMBOL_GPL(xfrm_count_auth_supported);
 
 int xfrm_count_enc_supported(void)
 {
@@ -458,6 +468,7 @@ int xfrm_count_enc_supported(void)
 			n++;
 	return n;
 }
+EXPORT_SYMBOL_GPL(xfrm_count_enc_supported);
 
 /* Move to common area: it is shared with AH. */
 
@@ -532,6 +543,7 @@ void skb_icv_walk(const struct sk_buff *
 	if (len)
 		BUG();
 }
+EXPORT_SYMBOL_GPL(skb_icv_walk);
 
 #if defined(CONFIG_INET_ESP) || defined(CONFIG_INET_ESP_MODULE) || defined(CONFIG_INET6_ESP) || defined(CONFIG_INET6_ESP_MODULE)
 
diff -purN linux-2.6.11-rc3-bk6/net/xfrm/xfrm_export.c linux-2.6.11-rc3-bk7/net/xfrm/xfrm_export.c
--- linux-2.6.11-rc3-bk6/net/xfrm/xfrm_export.c	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk7/net/xfrm/xfrm_export.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-#include <linux/module.h>
-#include <net/xfrm.h>
-
-EXPORT_SYMBOL(xfrm_user_policy);
-EXPORT_SYMBOL(km_waitq);
-EXPORT_SYMBOL(km_new_mapping);
-EXPORT_SYMBOL(xfrm_cfg_sem);
-EXPORT_SYMBOL(xfrm_policy_alloc);
-EXPORT_SYMBOL(__xfrm_policy_destroy);
-EXPORT_SYMBOL(xfrm_lookup);
-EXPORT_SYMBOL(__xfrm_policy_check);
-EXPORT_SYMBOL(__xfrm_route_forward);
-EXPORT_SYMBOL(xfrm_state_alloc);
-EXPORT_SYMBOL(__xfrm_state_destroy);
-EXPORT_SYMBOL(xfrm_state_insert);
-EXPORT_SYMBOL(xfrm_state_add);
-EXPORT_SYMBOL(xfrm_state_update);
-EXPORT_SYMBOL(xfrm_state_check_expire);
-EXPORT_SYMBOL(xfrm_state_check);
-EXPORT_SYMBOL(xfrm_state_lookup);
-EXPORT_SYMBOL(xfrm_state_register_afinfo);
-EXPORT_SYMBOL(xfrm_state_unregister_afinfo);
-EXPORT_SYMBOL(xfrm_state_delete_tunnel);
-EXPORT_SYMBOL(xfrm_replay_check);
-EXPORT_SYMBOL(xfrm_replay_advance);
-EXPORT_SYMBOL(__secpath_destroy);
-EXPORT_SYMBOL(secpath_dup);
-EXPORT_SYMBOL(xfrm_get_acqseq);
-EXPORT_SYMBOL(xfrm_parse_spi);
-EXPORT_SYMBOL(xfrm_register_type);
-EXPORT_SYMBOL(xfrm_unregister_type);
-EXPORT_SYMBOL(xfrm_get_type);
-EXPORT_SYMBOL(xfrm_register_km);
-EXPORT_SYMBOL(xfrm_unregister_km);
-EXPORT_SYMBOL(xfrm_state_delete);
-EXPORT_SYMBOL(xfrm_state_walk);
-EXPORT_SYMBOL(xfrm_find_acq_byseq);
-EXPORT_SYMBOL(xfrm_find_acq);
-EXPORT_SYMBOL(xfrm_alloc_spi);
-EXPORT_SYMBOL(xfrm_state_flush);
-EXPORT_SYMBOL(xfrm_policy_bysel);
-EXPORT_SYMBOL(xfrm_policy_insert);
-EXPORT_SYMBOL(xfrm_policy_walk);
-EXPORT_SYMBOL(xfrm_policy_flush);
-EXPORT_SYMBOL(xfrm_policy_byid);
-EXPORT_SYMBOL(xfrm_policy_list);
-EXPORT_SYMBOL(xfrm_dst_lookup);
-EXPORT_SYMBOL(xfrm_policy_register_afinfo);
-EXPORT_SYMBOL(xfrm_policy_unregister_afinfo);
-
-EXPORT_SYMBOL_GPL(xfrm_probe_algs);
-EXPORT_SYMBOL_GPL(xfrm_count_auth_supported);
-EXPORT_SYMBOL_GPL(xfrm_count_enc_supported);
-EXPORT_SYMBOL_GPL(xfrm_aalg_get_byidx);
-EXPORT_SYMBOL_GPL(xfrm_ealg_get_byidx);
-EXPORT_SYMBOL_GPL(xfrm_aalg_get_byid);
-EXPORT_SYMBOL_GPL(xfrm_ealg_get_byid);
-EXPORT_SYMBOL_GPL(xfrm_calg_get_byid);
-EXPORT_SYMBOL_GPL(xfrm_aalg_get_byname);
-EXPORT_SYMBOL_GPL(xfrm_ealg_get_byname);
-EXPORT_SYMBOL_GPL(xfrm_calg_get_byname);
-EXPORT_SYMBOL_GPL(skb_icv_walk);
diff -purN linux-2.6.11-rc3-bk6/net/xfrm/xfrm_input.c linux-2.6.11-rc3-bk7/net/xfrm/xfrm_input.c
--- linux-2.6.11-rc3-bk6/net/xfrm/xfrm_input.c	2005-02-03 02:57:05.000000000 +0100
+++ linux-2.6.11-rc3-bk7/net/xfrm/xfrm_input.c	2005-02-10 15:07:54.212777864 +0100
@@ -8,6 +8,7 @@
  */
 
 #include <linux/slab.h>
+#include <linux/module.h>
 #include <net/ip.h>
 #include <net/xfrm.h>
 
@@ -20,6 +21,7 @@ void __secpath_destroy(struct sec_path *
 		xfrm_state_put(sp->x[i].xvec);
 	kmem_cache_free(secpath_cachep, sp);
 }
+EXPORT_SYMBOL(__secpath_destroy);
 
 struct sec_path *secpath_dup(struct sec_path *src)
 {
@@ -40,6 +42,7 @@ struct sec_path *secpath_dup(struct sec_
 	atomic_set(&sp->refcnt, 1);
 	return sp;
 }
+EXPORT_SYMBOL(secpath_dup);
 
 /* Fetch spi and seq from ipsec header */
 
@@ -73,6 +76,7 @@ int xfrm_parse_spi(struct sk_buff *skb, 
 	*seq = *(u32*)(skb->h.raw + offset_seq);
 	return 0;
 }
+EXPORT_SYMBOL(xfrm_parse_spi);
 
 void __init xfrm_input_init(void)
 {
diff -purN linux-2.6.11-rc3-bk6/net/xfrm/xfrm_policy.c linux-2.6.11-rc3-bk7/net/xfrm/xfrm_policy.c
--- linux-2.6.11-rc3-bk6/net/xfrm/xfrm_policy.c	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk7/net/xfrm/xfrm_policy.c	2005-02-10 15:07:54.215777397 +0100
@@ -21,14 +21,17 @@
 #include <linux/workqueue.h>
 #include <linux/notifier.h>
 #include <linux/netdevice.h>
+#include <linux/module.h>
 #include <net/xfrm.h>
 #include <net/ip.h>
 
 DECLARE_MUTEX(xfrm_cfg_sem);
+EXPORT_SYMBOL(xfrm_cfg_sem);
 
 static DEFINE_RWLOCK(xfrm_policy_lock);
 
 struct xfrm_policy *xfrm_policy_list[XFRM_POLICY_MAX*2];
+EXPORT_SYMBOL(xfrm_policy_list);
 
 static DEFINE_RWLOCK(xfrm_policy_afinfo_lock);
 static struct xfrm_policy_afinfo *xfrm_policy_afinfo[NPROTO];
@@ -62,6 +65,7 @@ int xfrm_register_type(struct xfrm_type 
 	xfrm_policy_put_afinfo(afinfo);
 	return err;
 }
+EXPORT_SYMBOL(xfrm_register_type);
 
 int xfrm_unregister_type(struct xfrm_type *type, unsigned short family)
 {
@@ -82,6 +86,7 @@ int xfrm_unregister_type(struct xfrm_typ
 	xfrm_policy_put_afinfo(afinfo);
 	return err;
 }
+EXPORT_SYMBOL(xfrm_unregister_type);
 
 struct xfrm_type *xfrm_get_type(u8 proto, unsigned short family)
 {
@@ -112,6 +117,7 @@ retry:
 	xfrm_policy_put_afinfo(afinfo);
 	return type;
 }
+EXPORT_SYMBOL(xfrm_get_type);
 
 int xfrm_dst_lookup(struct xfrm_dst **dst, struct flowi *fl, 
 		    unsigned short family)
@@ -129,6 +135,7 @@ int xfrm_dst_lookup(struct xfrm_dst **ds
 	xfrm_policy_put_afinfo(afinfo);
 	return err;
 }
+EXPORT_SYMBOL(xfrm_dst_lookup);
 
 void xfrm_put_type(struct xfrm_type *type)
 {
@@ -234,6 +241,7 @@ struct xfrm_policy *xfrm_policy_alloc(in
 	}
 	return policy;
 }
+EXPORT_SYMBOL(xfrm_policy_alloc);
 
 /* Destroy xfrm_policy: descendant resources must be released to this moment. */
 
@@ -250,6 +258,7 @@ void __xfrm_policy_destroy(struct xfrm_p
 
 	kfree(policy);
 }
+EXPORT_SYMBOL(__xfrm_policy_destroy);
 
 static void xfrm_policy_gc_kill(struct xfrm_policy *policy)
 {
@@ -373,6 +382,7 @@ int xfrm_policy_insert(int dir, struct x
 	}
 	return 0;
 }
+EXPORT_SYMBOL(xfrm_policy_insert);
 
 struct xfrm_policy *xfrm_policy_bysel(int dir, struct xfrm_selector *sel,
 				      int delete)
@@ -396,6 +406,7 @@ struct xfrm_policy *xfrm_policy_bysel(in
 	}
 	return pol;
 }
+EXPORT_SYMBOL(xfrm_policy_bysel);
 
 struct xfrm_policy *xfrm_policy_byid(int dir, u32 id, int delete)
 {
@@ -418,6 +429,7 @@ struct xfrm_policy *xfrm_policy_byid(int
 	}
 	return pol;
 }
+EXPORT_SYMBOL(xfrm_policy_byid);
 
 void xfrm_policy_flush(void)
 {
@@ -438,6 +450,7 @@ void xfrm_policy_flush(void)
 	atomic_inc(&flow_cache_genid);
 	write_unlock_bh(&xfrm_policy_lock);
 }
+EXPORT_SYMBOL(xfrm_policy_flush);
 
 int xfrm_policy_walk(int (*func)(struct xfrm_policy *, int, int, void*),
 		     void *data)
@@ -470,7 +483,7 @@ out:
 	read_unlock_bh(&xfrm_policy_lock);
 	return error;
 }
-
+EXPORT_SYMBOL(xfrm_policy_walk);
 
 /* Find policy to apply to this flow. */
 
@@ -845,6 +858,7 @@ error:
 	*dst_p = NULL;
 	return err;
 }
+EXPORT_SYMBOL(xfrm_lookup);
 
 /* When skb is transformed back to its "native" form, we have to
  * check policy restrictions. At the moment we make this in maximally
@@ -981,6 +995,7 @@ reject:
 	xfrm_pol_put(pol);
 	return 0;
 }
+EXPORT_SYMBOL(__xfrm_policy_check);
 
 int __xfrm_route_forward(struct sk_buff *skb, unsigned short family)
 {
@@ -991,6 +1006,7 @@ int __xfrm_route_forward(struct sk_buff 
 
 	return xfrm_lookup(&skb->dst, &fl, NULL, 0) == 0;
 }
+EXPORT_SYMBOL(__xfrm_route_forward);
 
 /* Optimize later using cookies and generation ids. */
 
@@ -1163,6 +1179,7 @@ int xfrm_policy_register_afinfo(struct x
 	write_unlock(&xfrm_policy_afinfo_lock);
 	return err;
 }
+EXPORT_SYMBOL(xfrm_policy_register_afinfo);
 
 int xfrm_policy_unregister_afinfo(struct xfrm_policy_afinfo *afinfo)
 {
@@ -1190,6 +1207,7 @@ int xfrm_policy_unregister_afinfo(struct
 	write_unlock(&xfrm_policy_afinfo_lock);
 	return err;
 }
+EXPORT_SYMBOL(xfrm_policy_unregister_afinfo);
 
 static struct xfrm_policy_afinfo *xfrm_policy_get_afinfo(unsigned short family)
 {
diff -purN linux-2.6.11-rc3-bk6/net/xfrm/xfrm_state.c linux-2.6.11-rc3-bk7/net/xfrm/xfrm_state.c
--- linux-2.6.11-rc3-bk6/net/xfrm/xfrm_state.c	2005-02-03 02:56:22.000000000 +0100
+++ linux-2.6.11-rc3-bk7/net/xfrm/xfrm_state.c	2005-02-10 15:07:54.219776775 +0100
@@ -17,6 +17,7 @@
 #include <net/xfrm.h>
 #include <linux/pfkeyv2.h>
 #include <linux/ipsec.h>
+#include <linux/module.h>
 #include <asm/uaccess.h>
 
 /* Each xfrm_state may be linked to two tables:
@@ -38,6 +39,7 @@ static struct list_head xfrm_state_bydst
 static struct list_head xfrm_state_byspi[XFRM_DST_HSIZE];
 
 DECLARE_WAIT_QUEUE_HEAD(km_waitq);
+EXPORT_SYMBOL(km_waitq);
 
 static DEFINE_RWLOCK(xfrm_state_afinfo_lock);
 static struct xfrm_state_afinfo *xfrm_state_afinfo[NPROTO];
@@ -193,6 +195,7 @@ struct xfrm_state *xfrm_state_alloc(void
 	}
 	return x;
 }
+EXPORT_SYMBOL(xfrm_state_alloc);
 
 void __xfrm_state_destroy(struct xfrm_state *x)
 {
@@ -203,6 +206,7 @@ void __xfrm_state_destroy(struct xfrm_st
 	spin_unlock_bh(&xfrm_state_gc_lock);
 	schedule_work(&xfrm_state_gc_work);
 }
+EXPORT_SYMBOL(__xfrm_state_destroy);
 
 static void __xfrm_state_delete(struct xfrm_state *x)
 {
@@ -241,6 +245,7 @@ void xfrm_state_delete(struct xfrm_state
 	__xfrm_state_delete(x);
 	spin_unlock_bh(&x->lock);
 }
+EXPORT_SYMBOL(xfrm_state_delete);
 
 void xfrm_state_flush(u8 proto)
 {
@@ -267,6 +272,7 @@ restart:
 	spin_unlock_bh(&xfrm_state_lock);
 	wake_up(&km_waitq);
 }
+EXPORT_SYMBOL(xfrm_state_flush);
 
 static int
 xfrm_init_tempsel(struct xfrm_state *x, struct flowi *fl,
@@ -392,6 +398,7 @@ void xfrm_state_insert(struct xfrm_state
 	__xfrm_state_insert(x);
 	spin_unlock_bh(&xfrm_state_lock);
 }
+EXPORT_SYMBOL(xfrm_state_insert);
 
 static struct xfrm_state *__xfrm_find_acq_byseq(u32 seq);
 
@@ -444,6 +451,7 @@ out:
 
 	return err;
 }
+EXPORT_SYMBOL(xfrm_state_add);
 
 int xfrm_state_update(struct xfrm_state *x)
 {
@@ -508,6 +516,7 @@ out:
 
 	return err;
 }
+EXPORT_SYMBOL(xfrm_state_update);
 
 int xfrm_state_check_expire(struct xfrm_state *x)
 {
@@ -531,6 +540,7 @@ int xfrm_state_check_expire(struct xfrm_
 		km_state_expired(x, 0);
 	return 0;
 }
+EXPORT_SYMBOL(xfrm_state_check_expire);
 
 static int xfrm_state_check_space(struct xfrm_state *x, struct sk_buff *skb)
 {
@@ -553,6 +563,7 @@ int xfrm_state_check(struct xfrm_state *
 err:
 	return err;
 }
+EXPORT_SYMBOL(xfrm_state_check);
 
 struct xfrm_state *
 xfrm_state_lookup(xfrm_address_t *daddr, u32 spi, u8 proto,
@@ -569,6 +580,7 @@ xfrm_state_lookup(xfrm_address_t *daddr,
 	xfrm_state_put_afinfo(afinfo);
 	return x;
 }
+EXPORT_SYMBOL(xfrm_state_lookup);
 
 struct xfrm_state *
 xfrm_find_acq(u8 mode, u32 reqid, u8 proto, 
@@ -586,6 +598,7 @@ xfrm_find_acq(u8 mode, u32 reqid, u8 pro
 	xfrm_state_put_afinfo(afinfo);
 	return x;
 }
+EXPORT_SYMBOL(xfrm_find_acq);
 
 /* Silly enough, but I'm lazy to build resolution list */
 
@@ -614,7 +627,8 @@ struct xfrm_state *xfrm_find_acq_byseq(u
 	spin_unlock_bh(&xfrm_state_lock);
 	return x;
 }
- 
+EXPORT_SYMBOL(xfrm_find_acq_byseq);
+
 u32 xfrm_get_acqseq(void)
 {
 	u32 res;
@@ -626,6 +640,7 @@ u32 xfrm_get_acqseq(void)
 	spin_unlock_bh(&acqseq_lock);
 	return res;
 }
+EXPORT_SYMBOL(xfrm_get_acqseq);
 
 void
 xfrm_alloc_spi(struct xfrm_state *x, u32 minspi, u32 maxspi)
@@ -666,6 +681,7 @@ xfrm_alloc_spi(struct xfrm_state *x, u32
 		wake_up(&km_waitq);
 	}
 }
+EXPORT_SYMBOL(xfrm_alloc_spi);
 
 int xfrm_state_walk(u8 proto, int (*func)(struct xfrm_state *, int, void*),
 		    void *data)
@@ -700,7 +716,7 @@ out:
 	spin_unlock_bh(&xfrm_state_lock);
 	return err;
 }
-
+EXPORT_SYMBOL(xfrm_state_walk);
 
 int xfrm_replay_check(struct xfrm_state *x, u32 seq)
 {
@@ -726,6 +742,7 @@ int xfrm_replay_check(struct xfrm_state 
 	}
 	return 0;
 }
+EXPORT_SYMBOL(xfrm_replay_check);
 
 void xfrm_replay_advance(struct xfrm_state *x, u32 seq)
 {
@@ -745,6 +762,7 @@ void xfrm_replay_advance(struct xfrm_sta
 		x->replay.bitmap |= (1U << diff);
 	}
 }
+EXPORT_SYMBOL(xfrm_replay_advance);
 
 static struct list_head xfrm_km_list = LIST_HEAD_INIT(xfrm_km_list);
 static DEFINE_RWLOCK(xfrm_km_lock);
@@ -797,6 +815,7 @@ int km_new_mapping(struct xfrm_state *x,
 	read_unlock(&xfrm_km_lock);
 	return err;
 }
+EXPORT_SYMBOL(km_new_mapping);
 
 void km_policy_expired(struct xfrm_policy *pol, int dir, int hard)
 {
@@ -850,6 +869,7 @@ out:
 	kfree(data);
 	return err;
 }
+EXPORT_SYMBOL(xfrm_user_policy);
 
 int xfrm_register_km(struct xfrm_mgr *km)
 {
@@ -858,6 +878,7 @@ int xfrm_register_km(struct xfrm_mgr *km
 	write_unlock_bh(&xfrm_km_lock);
 	return 0;
 }
+EXPORT_SYMBOL(xfrm_register_km);
 
 int xfrm_unregister_km(struct xfrm_mgr *km)
 {
@@ -866,6 +887,7 @@ int xfrm_unregister_km(struct xfrm_mgr *
 	write_unlock_bh(&xfrm_km_lock);
 	return 0;
 }
+EXPORT_SYMBOL(xfrm_unregister_km);
 
 int xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo)
 {
@@ -885,6 +907,7 @@ int xfrm_state_register_afinfo(struct xf
 	write_unlock(&xfrm_state_afinfo_lock);
 	return err;
 }
+EXPORT_SYMBOL(xfrm_state_register_afinfo);
 
 int xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo)
 {
@@ -906,6 +929,7 @@ int xfrm_state_unregister_afinfo(struct 
 	write_unlock(&xfrm_state_afinfo_lock);
 	return err;
 }
+EXPORT_SYMBOL(xfrm_state_unregister_afinfo);
 
 static struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned short family)
 {
@@ -940,6 +964,7 @@ void xfrm_state_delete_tunnel(struct xfr
 		x->tunnel = NULL;
 	}
 }
+EXPORT_SYMBOL(xfrm_state_delete_tunnel);
 
 void __init xfrm_state_init(void)
 {
