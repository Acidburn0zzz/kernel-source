From: olh@suse.de
Subject: 2.6.11-rc4-bk8

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc4-bk7.log	2005-02-19 13:40:41.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc4-bk8.log	2005-02-20 13:57:29.000000000 +0100
 ChangeSet@1.2071, 2005-02-19 17:16:24-08:00, daniel.ritz@gmx.ch
   [PATCH] PCI: support PCI_PM_CAP version 1
   
   A check for the PM_CAP version was recently added but i breaks devices
   with version 1.  if they're in power-save mode they never get out of it.
   
   Change it to also support v1. 
   
   Signed-off-by: Daniel Ritz <daniel.ritz@gmx.ch>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2070, 2005-02-19 16:00:45-08:00, benh@kernel.crashing.org
   [PATCH] radeonfb: Workaround memory corruption accel problem
   
   A conflict between X and radeonfb can cause system memory corruption
   when switching console from X (note that this is not realted to the
   recent radeonfb patches, the problem has been there forever as far as I
   can tell).
   
   This patch works around it in radeonfb by making sure the "offsets"
   register that driver the memory mapping of the accel engine are always
   properly set before every accel op. A better fix should be done in fbcon
   ultimately.
   
   Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2069, 2005-02-19 15:48:10-08:00, takata@linux-m32r.org
   [PATCH] m32r: warning fix
   
   /project/m32r-linux/kernel/linux-2.6.11-rc4-bk4/b/include/linux/nodemask.h: In function `__first_unset_node':
   /project/m32r-linux/kernel/linux-2.6.11-rc4-bk4/b/include/linux/nodemask.h:246: warning: passing arg 1 of `find_next_zero_bit' discards qualifiers from pointer target type
   
   Signed-off-by: Hirokazu Takata <takata@linux-m32r.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2068, 2005-02-19 15:47:55-08:00, akpm@osdl.org
   [PATCH] end_buffer_async_read printk ratelimiting
   
   ratelimit the disk I/O error reporting in end_buffer_async_read().
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2067, 2005-02-19 15:47:41-08:00, akpm@osdl.org
   [PATCH] mca resource layout fix
   
   Greg's tree changes the layout of struct resource, so mca.c blows up.
   Preemptively fix it.
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
diff -purN linux-2.6.11-rc4-bk7/Makefile linux-2.6.11-rc4-bk8/Makefile
--- linux-2.6.11-rc4-bk7/Makefile	2005-02-20 20:25:58.342784195 +0100
+++ linux-2.6.11-rc4-bk8/Makefile	2005-02-20 20:26:05.142788404 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc4-bk7
+EXTRAVERSION = -rc4-bk8
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc4-bk7/arch/i386/kernel/mca.c linux-2.6.11-rc4-bk8/arch/i386/kernel/mca.c
--- linux-2.6.11-rc4-bk7/arch/i386/kernel/mca.c	2005-02-13 04:07:01.000000000 +0100
+++ linux-2.6.11-rc4-bk8/arch/i386/kernel/mca.c	2005-02-20 20:26:05.161785448 +0100
@@ -123,13 +123,13 @@ static void mca_configure_adapter_status
 /*--------------------------------------------------------------------*/
 
 static struct resource mca_standard_resources[] = {
-	{ "system control port B (MCA)", 0x60, 0x60 },
-	{ "arbitration (MCA)", 0x90, 0x90 },
-	{ "card Select Feedback (MCA)", 0x91, 0x91 },
-	{ "system Control port A (MCA)", 0x92, 0x92 },
-	{ "system board setup (MCA)", 0x94, 0x94 },
-	{ "POS (MCA)", 0x96, 0x97 },
-	{ "POS (MCA)", 0x100, 0x107 }
+	{ .start = 0x60, .end = 0x60, .name = "system control port B (MCA)" },
+	{ .start = 0x90, .end = 0x90, .name = "arbitration (MCA)" },
+	{ .start = 0x91, .end = 0x91, .name = "card Select Feedback (MCA)" },
+	{ .start = 0x92, .end = 0x92, .name = "system Control port A (MCA)" },
+	{ .start = 0x94, .end = 0x94, .name = "system board setup (MCA)" },
+	{ .start = 0x96, .end = 0x97, .name = "POS (MCA)" },
+	{ .start = 0x100, .end = 0x107, .name = "POS (MCA)" }
 };
 
 #define MCA_STANDARD_RESOURCES	(sizeof(mca_standard_resources)/sizeof(struct resource))
diff -purN linux-2.6.11-rc4-bk7/drivers/pci/pci.c linux-2.6.11-rc4-bk8/drivers/pci/pci.c
--- linux-2.6.11-rc4-bk7/drivers/pci/pci.c	2005-02-13 04:05:50.000000000 +0100
+++ linux-2.6.11-rc4-bk8/drivers/pci/pci.c	2005-02-20 20:26:05.297764286 +0100
@@ -268,7 +268,7 @@ pci_set_power_state(struct pci_dev *dev,
 		return -EIO; 
 
 	pci_read_config_word(dev,pm + PCI_PM_PMC,&pmc);
-	if ((pmc & PCI_PM_CAP_VER_MASK) != 2) {
+	if ((pmc & PCI_PM_CAP_VER_MASK) > 2) {
 		printk(KERN_DEBUG
 		       "PCI: %s has unsupported PM cap regs version (%u)\n",
 		       dev->slot_name, pmc & PCI_PM_CAP_VER_MASK);
diff -purN linux-2.6.11-rc4-bk7/drivers/video/aty/radeon_accel.c linux-2.6.11-rc4-bk8/drivers/video/aty/radeon_accel.c
--- linux-2.6.11-rc4-bk7/drivers/video/aty/radeon_accel.c	2005-02-13 04:06:55.000000000 +0100
+++ linux-2.6.11-rc4-bk8/drivers/video/aty/radeon_accel.c	2005-02-20 20:26:05.320760707 +0100
@@ -4,6 +4,41 @@
  * "ACCEL_MMIO" ifdef branches in XFree86
  * --dte
  */
+
+static void radeon_fixup_offset(struct radeonfb_info *rinfo)
+{
+	u32 local_base;
+
+	/* *** Ugly workaround *** */
+	/*
+	 * On some platforms, the video memory is mapped at 0 in radeon chip space
+	 * (like PPCs) by the firmware. X will always move it up so that it's seen
+	 * by the chip to be at the same address as the PCI BAR.
+	 * That means that when switching back from X, there is a mismatch between
+	 * the offsets programmed into the engine. This means that potentially,
+	 * accel operations done before radeonfb has a chance to re-init the engine
+	 * will have incorrect offsets, and potentially trash system memory !
+	 *
+	 * The correct fix is for fbcon to never call any accel op before the engine
+	 * has properly been re-initialized (by a call to set_var), but this is a
+	 * complex fix. This workaround in the meantime, called before every accel
+	 * operation, makes sure the offsets are in sync.
+	 */
+
+	radeon_fifo_wait (1);
+	local_base = INREG(MC_FB_LOCATION) << 16;
+	if (local_base == rinfo->fb_local_base)
+		return;
+
+	rinfo->fb_local_base = local_base;
+
+	radeon_fifo_wait (3);
+	OUTREG(DEFAULT_PITCH_OFFSET, (rinfo->pitch << 0x16) |
+				     (rinfo->fb_local_base >> 10));
+	OUTREG(DST_PITCH_OFFSET, (rinfo->pitch << 0x16) | (rinfo->fb_local_base >> 10));
+	OUTREG(SRC_PITCH_OFFSET, (rinfo->pitch << 0x16) | (rinfo->fb_local_base >> 10));
+}
+
 static void radeonfb_prim_fillrect(struct radeonfb_info *rinfo, 
 				   const struct fb_fillrect *region)
 {
@@ -38,6 +73,8 @@ void radeonfb_fillrect(struct fb_info *i
 		return;
 	}
 
+	radeon_fixup_offset(rinfo);
+
 	vxres = info->var.xres_virtual;
 	vyres = info->var.yres_virtual;
 
@@ -105,6 +142,8 @@ void radeonfb_copyarea(struct fb_info *i
 		return;
 	}
 
+	radeon_fixup_offset(rinfo);
+
 	vxres = info->var.xres_virtual;
 	vyres = info->var.yres_virtual;
 
diff -purN linux-2.6.11-rc4-bk7/fs/buffer.c linux-2.6.11-rc4-bk8/fs/buffer.c
--- linux-2.6.11-rc4-bk7/fs/buffer.c	2005-02-13 04:06:54.000000000 +0100
+++ linux-2.6.11-rc4-bk8/fs/buffer.c	2005-02-20 20:26:05.348756350 +0100
@@ -550,7 +550,8 @@ static void end_buffer_async_read(struct
 		set_buffer_uptodate(bh);
 	} else {
 		clear_buffer_uptodate(bh);
-		buffer_io_error(bh);
+		if (printk_ratelimit())
+			buffer_io_error(bh);
 		SetPageError(page);
 	}
 
diff -purN linux-2.6.11-rc4-bk7/include/asm-m32r/bitops.h linux-2.6.11-rc4-bk8/include/asm-m32r/bitops.h
--- linux-2.6.11-rc4-bk7/include/asm-m32r/bitops.h	2005-02-13 04:06:53.000000000 +0100
+++ linux-2.6.11-rc4-bk8/include/asm-m32r/bitops.h	2005-02-20 20:26:05.376751993 +0100
@@ -405,9 +405,10 @@ static __inline__ unsigned long ffz(unsi
  * @offset: The bitnumber to start searching at
  * @size: The maximum size to search
  */
-static __inline__ int find_next_zero_bit(void *addr, int size, int offset)
+static __inline__ int find_next_zero_bit(const unsigned long *addr,
+					 int size, int offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = addr + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
