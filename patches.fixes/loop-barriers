From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH] loop: perform sync operations during writeback
References: 189051

 When loopback devices are used as xen instances, the loopback can act
 has a huge writeback cache. If the physical node crashes or loses power,
 that cache ends up not being flush and massive corruption can occur.

 This patch (Originally by Jens Axboe and extended by Chris Mason) adds
 options to the loop device to perform flushing of the writes before 
 returning success.

 We may want to change the default sync mode from none to data.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

--

 drivers/block/loop.c |   65 +++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 65 insertions(+)

--- linux-2.6.16/drivers/block/loop.c	2006-04-05 04:45:43.000000000 -0400
+++ linux-2.6.16.ocfs2-devel/drivers/block/loop.c	2006-06-29 13:54:18.000000000 -0400
@@ -77,7 +77,14 @@
 
 #include <asm/uaccess.h>
 
+#define SYNC_MODE_NONE 0
+#define SYNC_MODE_BARRIER 1
+#define SYNC_MODE_DATA 2
+#define SYNC_MODE_FULL 3
+
 static int max_loop = 8;
+static int loop_sync_mode;
+static char *sync_mode = "";
 static struct loop_device *loop_dev;
 static struct gendisk **disks;
 
@@ -360,6 +367,38 @@
 	return ret;
 }
 
+/*
+ * This is best effort. We really wouldn't know what to do with a returned
+ * error. This code is taken from the implementation of fsync.
+ */
+static int sync_file(struct file * file)
+{
+	struct address_space *mapping;
+	int ret;
+
+	if (!file->f_op || !file->f_op->fsync)
+		return -EOPNOTSUPP;
+
+	mapping = file->f_mapping;
+
+	ret = filemap_fdatawrite(mapping);
+	if (!ret) {
+		/*
+		 * We need to protect against concurrent writers,
+		 * which could cause livelocks in fsync_buffers_list
+		 */
+		if (loop_sync_mode == SYNC_MODE_FULL) {
+			mutex_lock(&mapping->host->i_mutex);
+			ret = file->f_op->fsync(file, file->f_dentry, 1);
+			mutex_unlock(&mapping->host->i_mutex);
+		}
+
+		filemap_fdatawait(mapping);
+	}
+
+	return ret;
+}
+
 static int lo_send(struct loop_device *lo, struct bio *bio, int bsize,
 		loff_t pos)
 {
@@ -368,6 +407,14 @@
 	struct bio_vec *bvec;
 	struct page *page = NULL;
 	int i, ret = 0;
+	int sync = loop_sync_mode >= SYNC_MODE_DATA;
+	int barrier = bio_barrier(bio) && loop_sync_mode == SYNC_MODE_BARRIER;
+
+	if (barrier) {
+		ret = sync_file(lo->lo_backing_file);
+		if (unlikely(ret))
+			return ret;
+	}
 
 	do_lo_send = do_lo_send_aops;
 	if (!(lo->lo_flags & LO_FLAGS_USE_AOPS)) {
@@ -390,6 +437,11 @@
 		kunmap(page);
 		__free_page(page);
 	}
+
+	if ((barrier || sync) && !ret) {
+		ret = sync_file(lo->lo_backing_file);
+	}
+
 out:
 	return ret;
 fail:
@@ -1207,6 +1259,7 @@
  * And now the modules code and kernel interface.
  */
 module_param(max_loop, int, 0);
+module_param(sync_mode, charp, 0);
 MODULE_PARM_DESC(max_loop, "Maximum number of loop devices (1-256)");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_BLOCKDEV_MAJOR(LOOP_MAJOR);
@@ -1257,6 +1310,18 @@
 		max_loop = 8;
 	}
 
+	if (strcmp(sync_mode, "barrier") == 0)
+		loop_sync_mode = SYNC_MODE_BARRIER;
+	else if (strcmp(sync_mode, "full") == 0)
+		loop_sync_mode = SYNC_MODE_FULL;
+	else if (strcmp(sync_mode, "data") == 0)
+		loop_sync_mode = SYNC_MODE_DATA;
+	else if (strcmp(sync_mode, "none") == 0)
+		loop_sync_mode = SYNC_MODE_NONE;
+
+	if (loop_sync_mode)
+		printk("loop: sync_mode (%s: %d)\n", sync_mode, loop_sync_mode);
+
 	if (register_blkdev(LOOP_MAJOR, "loop"))
 		return -EIO;
 
