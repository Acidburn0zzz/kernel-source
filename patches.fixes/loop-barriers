From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH] loop: add support for O_SYNC
References: 189051
Patch-mainline: never - this is a temporary band-aid for SLES10

 This patch adds support for O_SYNC to the block loop device. When the
 backing file is opened with O_SYNC, the loop device will sync writes before
 returning successful.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

--

 drivers/block/loop.c |   51 +++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)

--- a/drivers/block/loop.c	2007-11-02 18:46:31.000000000 -0400
+++ b/drivers/block/loop.c	2007-11-02 19:04:54.000000000 -0400
@@ -200,6 +200,38 @@ lo_do_transfer(struct loop_device *lo, i
 	return lo->transfer(lo, cmd, rpage, roffs, lpage, loffs, size, rblock);
 }
 
+/*
+ * This is best effort. We really wouldn't know what to do with a returned
+ * error. This code is taken from the implementation of fsync.
+ */
+static int sync_file(struct file * file, int full_sync)
+{
+	struct address_space *mapping;
+	int ret;
+
+	if (!file->f_op || !file->f_op->fsync)
+		return -EOPNOTSUPP;
+
+	mapping = file->f_mapping;
+
+	ret = filemap_fdatawrite(mapping);
+	if (!ret) {
+		int ret2;
+		/*
+		 * We need to protect against concurrent writers,
+		 * which could cause livelocks in fsync_buffers_list
+		 */
+		if (full_sync)
+			ret = file->f_op->fsync(file, file->f_dentry, 1);
+
+		ret2 = filemap_fdatawait(mapping);
+		if (!ret)
+			ret = ret2;
+	}
+
+	return ret;
+}
+
 /**
  * do_lo_send_aops - helper for writing data to a loop device
  *
@@ -211,11 +243,18 @@ static int do_lo_send_aops(struct loop_d
 {
 	struct file *file = lo->lo_backing_file; /* kudos to NFsckingS */
 	struct address_space *mapping = file->f_mapping;
+	struct inode *inode = file->f_dentry->d_inode;
 	pgoff_t index;
 	unsigned offset, bv_offs;
 	int len, ret;
+	unsigned long old_blocks;
 
 	mutex_lock(&mapping->host->i_mutex);
+
+	spin_lock(&inode->i_lock);
+	old_blocks = inode->i_blocks;
+	spin_unlock(&inode->i_lock);
+
 	index = pos >> PAGE_CACHE_SHIFT;
 	offset = pos & ((pgoff_t)PAGE_CACHE_SIZE - 1);
 	bv_offs = bvec->bv_offset;
@@ -258,6 +297,15 @@ static int do_lo_send_aops(struct loop_d
 		pos += copied;
 	}
 	ret = 0;
+
+	if (file->f_flags & O_SYNC) {
+		int full_sync = 0;
+		spin_lock(&inode->i_lock);
+		if (inode->i_blocks > old_blocks)
+			full_sync = 1;
+		spin_unlock(&inode->i_lock);
+		ret = sync_file(file, full_sync);
+	}
 out:
 	mutex_unlock(&mapping->host->i_mutex);
 	return ret;
@@ -752,6 +800,9 @@ static int loop_set_fd(struct loop_devic
 	if (!(file->f_mode & FMODE_WRITE))
 		lo_flags |= LO_FLAGS_READ_ONLY;
 
+	if ((file->f_flags & O_SYNC) && (!file->f_op || !file->f_op->fsync))
+		return -EINVAL;
+
 	error = -EINVAL;
 	if (S_ISREG(inode->i_mode) || S_ISBLK(inode->i_mode)) {
 		const struct address_space_operations *aops = mapping->a_ops;
