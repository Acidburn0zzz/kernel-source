From: Mike Travis <travis@sgi.com>
Subject: kdb: fix stack overflow for large NR_CPUS count
References: bnc#440361

V2: remove spinlock

In auditing the 2.6.27 source I found a *big* problem in kdb.  The stack in
kdb_bp will overflow with NR_CPUS=4096 ... the stack is 31744 bytes!

    ====== Stack (-l 500)

	1 - x86_64_default_128  (NR_CPUS=128)
	2 - x86_64_default      (NR_CPUS=4096)

    .1.     .2.    ..final..
    1088  +31744 32832 +2917%  kdb_bp
       0   +2632  2632      .  smp_call_function_mask
       0   +2216  2216      .  __build_sched_domains
       0   +1544  1544      .  tick_handle_oneshot_broadcast

The problem looks like the static array in kdb_bp (template):

    static int
    kdb_bp(int argc, const char **argv)
    {
	    ...
	    kdb_bp_t template = {0};

Which has a field sized by NR_CPUS:

	    kdbhard_bp_t   *bp_hard[NR_CPUS]; /* Hardware breakpoint structure */

When NR_CPUS=4096, the above struct will overflow the 16k stack.

The fix I implemented is to move the template to static memory.  This struct
does not need to be protected because KDB stops all the cpus and only accepts
console input from one cpu at a time.

Some other minor tweaks to reduce stack size also implemented:

    kdb_cpu_callback: use set_cpus_allowed_ptr() to prevent passing cpumask_t
    		      on the stack.

    kdb_per_cpu: use cpus_clear which prevents creating an empty cpumask_t
    		 (CPU_MASK_NONE) on the stack.


For the next release, any arrays should be allocated using nr_cpu_ids.

Based on linux-2.6.27.

Signed-off-by: Mike Travis <travis@sgi.com>
Acked-by: Bernhard Walle <bwalle@suse.de>

---
 kdb/kdb_bp.c  |   27 +++++++++++++++------------
 kdb/kdbmain.c |   12 ++++++------
 2 files changed, 21 insertions(+), 18 deletions(-)

--- linux-2.6.27.orig/kdb/kdb_bp.c
+++ linux-2.6.27/kdb/kdb_bp.c
@@ -285,7 +285,7 @@ kdb_bp(int argc, const char **argv)
 	char *symname = NULL;
 	long offset = 0ul;
 	int nextarg;
-	kdb_bp_t template = {0};
+	static kdb_bp_t kdb_bp_template;
 
 	if (argc == 0) {
 		/*
@@ -300,21 +300,23 @@ kdb_bp(int argc, const char **argv)
 		return 0;
 	}
 
-	template.bp_global = ((strcmp(argv[0], "bpa") == 0)
+	memset(&kdb_bp_template, 0, sizeof(kdb_bp_template));
+
+	kdb_bp_template.bp_global = ((strcmp(argv[0], "bpa") == 0)
 			   || (strcmp(argv[0], "bpha") == 0));
-	template.bp_forcehw = ((strcmp(argv[0], "bph") == 0)
+	kdb_bp_template.bp_forcehw = ((strcmp(argv[0], "bph") == 0)
 			   || (strcmp(argv[0], "bpha") == 0));
 
 	/* Fix me: "bp" is treated as "bpa" to avoid system freeze. -jlan */
 	if (strcmp(argv[0], "bp") == 0)
-		template.bp_global = 1;
+		kdb_bp_template.bp_global = 1;
 
 	nextarg = 1;
-	diag = kdbgetaddrarg(argc, argv, &nextarg, &template.bp_addr,
+	diag = kdbgetaddrarg(argc, argv, &nextarg, &kdb_bp_template.bp_addr,
 			     &offset, &symname);
 	if (diag)
 		return diag;
-	if (!template.bp_addr)
+	if (!kdb_bp_template.bp_addr)
 		return KDB_BADINT;
 
 	/*
@@ -333,7 +335,7 @@ kdb_bp(int argc, const char **argv)
 	/*
 	 * Handle architecture dependent parsing
 	 */
-	diag = kdba_parsebp(argc, argv, &nextarg, &template);
+	diag = kdba_parsebp(argc, argv, &nextarg, &kdb_bp_template);
 	if (diag) {
 		return diag;
 	}
@@ -348,20 +350,21 @@ kdb_bp(int argc, const char **argv)
 	 */
 	for(i=0,bp_check=kdb_breakpoints; i<KDB_MAXBPT; i++,bp_check++) {
 		if (!bp_check->bp_free &&
-		    bp_check->bp_addr == template.bp_addr &&
+		    bp_check->bp_addr == kdb_bp_template.bp_addr &&
 		    (bp_check->bp_global ||
-		     bp_check->bp_cpu == template.bp_cpu)) {
-			kdb_printf("You already have a breakpoint at " kdb_bfd_vma_fmt0 "\n", template.bp_addr);
+		     bp_check->bp_cpu == kdb_bp_template.bp_cpu)) {
+			kdb_printf("You already have a breakpoint at "
+				kdb_bfd_vma_fmt0 "\n", kdb_bp_template.bp_addr);
 			return KDB_DUPBPT;
 		}
 	}
 
-	template.bp_enabled = 1;
+	kdb_bp_template.bp_enabled = 1;
 
 	/*
 	 * Actually allocate the breakpoint found earlier
 	 */
-	*bp = template;
+	*bp = kdb_bp_template;
 	bp->bp_free = 0;
 
 	if (!bp->bp_global) {
--- linux-2.6.27.orig/kdb/kdbmain.c
+++ linux-2.6.27/kdb/kdbmain.c
@@ -3715,13 +3715,14 @@ kdb_per_cpu(int argc, const char **argv)
 {
 	char buf[256], fmtstr[64];
 	kdb_symtab_t symtab;
-	cpumask_t suppress = CPU_MASK_NONE;
+	cpumask_t suppress;
 	int cpu, diag;
 	unsigned long addr, val, bytesperword = 0, whichcpu = ~0UL;
 
 	if (argc < 1 || argc > 3)
 		return KDB_ARGCOUNT;
 
+	cpus_clear(suppress);
 	snprintf(buf, sizeof(buf), "per_cpu__%s", argv[1]);
 	if (!kdbgetsymval(buf, &symtab)) {
 		kdb_printf("%s is not a per_cpu variable\n", argv[1]);
@@ -3779,7 +3780,7 @@ kdb_per_cpu(int argc, const char **argv)
 	if (cpus_weight(suppress) == 0)
 		return 0;
 	kdb_printf("Zero suppressed cpu(s):");
-	for (cpu = first_cpu(suppress); cpu < NR_CPUS; cpu = next_cpu(cpu, suppress)) {
+	for_each_cpu_mask(cpu, suppress) {
 		kdb_printf(" %d", cpu);
 		if (cpu == NR_CPUS-1 || next_cpu(cpu, suppress) != cpu + 1)
 			continue;
@@ -4234,10 +4235,9 @@ kdb_cpu_callback(struct notifier_block *
 	if (action == CPU_ONLINE) {
 		int cpu =(unsigned long)hcpu;
 		cpumask_t save_cpus_allowed = current->cpus_allowed;
-		cpumask_t new_cpus_allowed = cpumask_of_cpu(cpu);
-		set_cpus_allowed(current, new_cpus_allowed);
-		kdb(KDB_REASON_CPU_UP, 0, NULL);	/* do kdb setup on this cpu */
-		set_cpus_allowed(current, save_cpus_allowed);
+		set_cpus_allowed_ptr(current, &cpumask_of_cpu(cpu));
+		kdb(KDB_REASON_CPU_UP, 0, NULL); /* do kdb setup on this cpu */
+		set_cpus_allowed_ptr(current, &save_cpus_allowed);
 	}
 	return NOTIFY_OK;
 }
