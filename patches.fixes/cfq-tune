From: Kurt Garloff <garloff@suse.de>
Subject: Allow low-level driver to do queuing with CFQ
Patch-mainline: 

cfq_max_depth was set to a low value to make sure we get maximum control
over the queuing in the IO scheduler without interaction from the low
level driver's own queuing, which could potentially destroy some of
the latency efforts we do in CFQ.

However, some hardware (SANs ...) is really able to handle multiple 
requests at a time and profits significantly from driver queuing.

Thus this patch sets the default back to a higher value.
It can be tuned at runtime though /sys/block/XXX/queue/iosched/max_depth

References: 
http://netmama.it/oracledocs/ioscheduler_02.html
http://netmama.it/oracledocs/ioscheduler_03.html

Attribution: 
The change is based on Jens' work, not mine.

Signed-off-by: Kurt Garloff <garloff@suse.de>
Acked-by: Jens Axboe <axboe@suse.de>

Index: linux-2.6.16/block/cfq-iosched.c
===================================================================
--- linux-2.6.16.orig/block/cfq-iosched.c
+++ linux-2.6.16/block/cfq-iosched.c
@@ -42,11 +42,11 @@ static int cfq_slice_idle = HZ / 100;
 #define CFQ_KEY_ASYNC		(0)
 #define CFQ_KEY_ANY		(0xffff)
 
 /*
- * disable queueing at the driver/hardware level
+ * amount of queueing at the driver/hardware level
  */
-static const int cfq_max_depth = 2;
+static const int cfq_max_depth = 64;
 
 /*
  * for the hash of cfqq inside the cfqd
  */
