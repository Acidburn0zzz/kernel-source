# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/03/23 01:53:15-05:00 len.brown@intel.com 
#   Merge
# 
# include/asm-x86_64/mpspec.h
#   2004/03/23 01:53:14-05:00 len.brown@intel.com +0 -0
#   SCCS merged
# 
# arch/x86_64/kernel/setup.c
#   2004/03/23 01:53:14-05:00 len.brown@intel.com +0 -0
#   SCCS merged
# 
# arch/x86_64/kernel/mpparse.c
#   2004/03/23 01:53:14-05:00 len.brown@intel.com +0 -0
#   SCCS merged
# 
# arch/x86_64/kernel/Makefile
#   2004/03/23 01:53:14-05:00 len.brown@intel.com +0 -0
#   SCCS merged
# 
# BitKeeper/deleted/.del-boot.c~a0dfed61fc52b053
#   2004/03/23 01:41:55-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# BitKeeper/deleted/.del-boot.c~a0dfed61fc52b053
#   2004/03/23 01:41:55-05:00 len.brown@intel.com +0 -0
#   Merge rename: arch/x86_64/kernel/acpi/boot.c -> BitKeeper/deleted/.del-boot.c~a0dfed61fc52b053
# 
# ChangeSet
#   2004/03/23 01:33:54-05:00 len.brown@intel.com 
#   [ACPI] share i386/kernel/acpi/boot.c with x86_64
# 
# include/asm-x86_64/mpspec.h
#   2004/03/23 01:32:11-05:00 len.brown@intel.com +0 -2
#   use i386/kernel/acpi/boot.c for x86_64
# 
# drivers/acpi/bus.c
#   2004/03/23 01:32:11-05:00 len.brown@intel.com +3 -10
#   use i386/kernel/acpi/boot.c for x86_64
# 
# drivers/acpi/Kconfig
#   2004/03/23 01:32:11-05:00 len.brown@intel.com +1 -0
#   no PM_TIMER on x86_64, yet
# 
# arch/x86_64/kernel/setup.c
#   2004/03/23 01:32:11-05:00 len.brown@intel.com +12 -0
#   use i386/kernel/acpi/boot.c for x86_64
# 
# arch/x86_64/kernel/mpparse.c
#   2004/03/23 01:32:11-05:00 len.brown@intel.com +0 -63
#   use i386/kernel/acpi/boot.c for x86_64
# 
# arch/x86_64/kernel/acpi/Makefile
#   2004/03/23 01:32:11-05:00 len.brown@intel.com +1 -1
#   use i386/kernel/acpi/boot.c for x86_64
# 
# arch/x86_64/kernel/Makefile
#   2004/03/23 01:32:11-05:00 len.brown@intel.com +1 -1
#   use i386/kernel/acpi/boot.c for x86_64
# 
# arch/i386/kernel/acpi/boot.c
#   2004/03/23 01:32:11-05:00 len.brown@intel.com +49 -9
#   use i386/kernel/acpi/boot.c for x86_64
# 
# ChangeSet
#   2004/03/23 01:18:29-05:00 len.brown@intel.com 
#   [ACPI] toshiba_acpi 0.18 from John Belmonte
#     add missing copyin
# 
# drivers/acpi/toshiba_acpi.c
#   2004/03/23 01:17:28-05:00 len.brown@intel.com +27 -28
#   toshiba_acpi 0.18 from John Belmonte
#     fixes copyin bug
# 
# ChangeSet
#   2004/03/22 19:51:11-05:00 len.brown@intel.com 
#   [ACPI] delete POWER_OF_TWO array (Pavel Machek)
# 
# drivers/acpi/processor.c
#   2004/03/22 19:49:34-05:00 len.brown@intel.com +1 -3
#   delete POWER_OF_TWO array (Pavel Machek)
# 
# BitKeeper/deleted/.del-boot.c~a0dfed61fc52b053
#   2004/03/22 16:44:17-05:00 len.brown@intel.com +0 -0
#   Delete: arch/x86_64/kernel/acpi/boot.c
# 
# ChangeSet
#   2004/03/22 16:03:24-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/linux-acpi-test-2.6.4
#   into intel.com:/home/lenb/src/linux-acpi-test-2.6.5
# 
# arch/i386/kernel/setup.c
#   2004/03/22 16:03:22-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# Documentation/kernel-parameters.txt
#   2004/03/22 16:03:22-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/03/22 16:02:16-05:00 len.brown@intel.com 
#   [ACPI] ACPI SCI shall be level/low unless explicit over-ride
#   http://bugzilla.kernel.org/show_bug.cgi?id=1622
#   add "acpi_sci=edge" and "acpi_sci=high" manual over-ride
# 
# include/asm-i386/mpspec.h
#   2004/03/22 16:00:03-05:00 len.brown@intel.com +0 -7
#   delete mp_config_ioapic_for_sci()
# 
# drivers/acpi/bus.c
#   2004/03/22 16:00:03-05:00 len.brown@intel.com +18 -2
#   delete mp_config_ioapic_for_sci()
#   add param to acpi_pic_sci_set_trigger.
# 
# arch/i386/kernel/setup.c
#   2004/03/22 16:00:03-05:00 len.brown@intel.com +13 -0
#   add acpi_sci= -- they need to be early to preceed MADT table parsing
# 
# arch/i386/kernel/mpparse.c
#   2004/03/22 16:00:03-05:00 len.brown@intel.com +0 -63
#   delete mp_config_ioapic_for_sci() -- it had several problems.
#   walking the MADT was redundant
#   not setting flags for no-override case to level/low was incorrect
#   calling io_apic_set_pci_routing() on a legacy IRQ was incorrect
# 
# arch/i386/kernel/acpi/boot.c
#   2004/03/22 16:00:03-05:00 len.brown@intel.com +67 -33
#   add acpi_parse_sci_int_src_ovr() for handling SCI interrupt flags
#   grab the SCI from the early FADT parse
#   fix typo in acpi_pic_sci_set_triger() that allowed it only to set for level trigger
# 
# Documentation/kernel-parameters.txt
#   2004/03/22 16:00:03-05:00 len.brown@intel.com +2 -4
#   replace acpi_pic_sci= with acpi_sci=
# 
# ChangeSet
#   2004/03/21 21:34:35-05:00 len.brown@intel.com 
#   [ACPI] fix interrupts behind yenta cardbus bridge (David Shaohua Li)
#   http://bugzilla.kernel.org/show_bug.cgi?id=1564
# 
# drivers/acpi/pci_irq.c
#   2004/03/21 21:32:47-05:00 len.brown@intel.com +13 -1
#   fix interrupts for dev behind cardbus bridge (David Shaohua Li)
#   http://bugzilla.kernel.org/show_bug.cgi?id=1564
# 
# ChangeSet
#   2004/03/21 01:10:21-05:00 bjorn.helgaas@hp.com 
#   [PATCH] clean up ACPI GSI/IRQ conversions (i386 part)
#   
#   Add "acpi_gsi_to_irq()" as a generic replacement for "acpi_irq_to_vector()".
#   This converts from an ACPI global system interrupt number to a Linux IRQ.
#   Also, convert i386-specific terminology to use GSI when appropriate.
# 
# include/asm-i386/mpspec.h
#   2004/03/18 14:45:38-05:00 bjorn.helgaas@hp.com +4 -4
#   clean up ACPI GSI/IRQ conversions (i386 part)
# 
# include/asm-i386/acpi.h
#   2004/03/18 14:45:38-05:00 bjorn.helgaas@hp.com +2 -1
#   clean up ACPI GSI/IRQ conversions (i386 part)
# 
# arch/i386/kernel/mpparse.c
#   2004/03/18 14:45:38-05:00 bjorn.helgaas@hp.com +47 -47
#   clean up ACPI GSI/IRQ conversions (i386 part)
# 
# arch/i386/kernel/acpi/boot.c
#   2004/03/18 15:04:47-05:00 bjorn.helgaas@hp.com +12 -0
#   clean up ACPI GSI/IRQ conversions (i386 part)
# 
# ChangeSet
#   2004/03/21 00:33:11-05:00 len.brown@intel.com 
#   merge
# 
# arch/i386/kernel/dmi_scan.c
#   2004/03/21 00:33:07-05:00 len.brown@intel.com +0 -2
#   handle name conflict with dmi_disable_acpi()
# 
# include/asm-x86_64/acpi.h
#   2004/03/21 00:28:40-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# include/asm-ia64/acpi.h
#   2004/03/21 00:28:40-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# drivers/char/sonypi.h
#   2004/03/21 00:28:40-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# arch/ia64/kernel/acpi.c
#   2004/03/21 00:28:40-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# arch/i386/kernel/setup.c
#   2004/03/21 00:28:40-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/03/21 00:23:27-05:00 len.brown@intel.com 
#   [ACPI] create disable_acpi()
# 
# include/asm-x86_64/acpi.h
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +3 -0
#   create disable_acpi()
# 
# include/asm-ia64/acpi.h
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +2 -0
#   create disable_acpi()
# 
# include/asm-i386/acpi.h
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +3 -0
#   create disable_acpi()
# 
# include/acpi/acpi_bus.h
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +0 -2
#   create disable_acpi()
# 
# drivers/char/sonypi.h
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +0 -1
#   create disable_acpi()
# 
# drivers/acpi/bus.c
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +2 -17
#   create disable_acpi()
# 
# arch/ia64/kernel/acpi.c
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +0 -2
#   create disable_acpi()
# 
# arch/i386/kernel/setup.c
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +4 -5
#   create disable_acpi()
# 
# arch/i386/kernel/dmi_scan.c
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +6 -9
#   create disable_acpi()
# 
# arch/i386/kernel/acpi/boot.c
#   2004/03/21 00:18:40-05:00 len.brown@intel.com +2 -2
#   create disable_acpi()
# 
# ChangeSet
#   2004/03/20 23:44:51-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/bk/linux-2.6.5
#   into intel.com:/home/lenb/src/linux-acpi-test-2.6.5
# 
# arch/x86_64/kernel/setup.c
#   2004/03/20 23:44:43-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# arch/x86_64/kernel/mpparse.c
#   2004/03/20 23:44:43-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# arch/i386/kernel/setup.c
#   2004/03/20 23:44:43-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/03/18 22:24:47-05:00 len.brown@intel.com 
#   [ACPI] numa.c build fix (Luming Yu)
#   http://bugzilla.kernel.org/show_bug.cgi?id=2131
# 
# drivers/acpi/numa.c
#   2004/02/18 04:19:31-05:00 len.brown@intel.com +9 -2
#   [ACPI] numa.c build fix (Luming Yu)
# 
# ChangeSet
#   2004/03/17 15:36:55-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/bk/linux-2.6.5
#   into intel.com:/home/lenb/src/linux-acpi-test-2.6.5
# 
# arch/x86_64/kernel/setup.c
#   2004/03/17 15:36:51-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/03/17 00:45:57-05:00 len.brown@intel.com 
#   Merge intel.com:/home/lenb/src/linux-acpi-test-2.6.4
#   into intel.com:/home/lenb/src/linux-acpi-test-2.6.5
# 
# arch/x86_64/kernel/setup.c
#   2004/03/17 00:45:53-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# arch/x86_64/kernel/mpparse.c
#   2004/03/17 00:45:51-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# arch/i386/kernel/setup.c
#   2004/03/17 00:45:51-05:00 len.brown@intel.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/03/17 00:44:22-05:00 len.brown@intel.com 
#   [ACPI] check "maxcpus=N" early -- same as NR_CPUS check.
#   http://bugzilla.kernel.org/show_bug.cgi?id=2317
#   
#   When the BIOS enumerates physical processors before logical,
#   maxcpus=N/2 will now effectively disable HT.
#   
#   This can be verified by boot messages warning that HT is off:
#   eg. "maxcpus=2" on a 2xHT system:
#   
#   Total of 2 processors activated (11141.12 BogoMIPS).
#   WARNING: No sibling found for CPU 0.
#   WARNING: No sibling found for CPU 1.
# 
# arch/x86_64/kernel/setup.c
#   2004/03/17 00:43:10-05:00 len.brown@intel.com +12 -1
#   check "maxcpus=N" at processor enumeration-time rather than smpboot-time
# 
# arch/x86_64/kernel/mpparse.c
#   2004/03/17 00:43:10-05:00 len.brown@intel.com +12 -0
#   check "maxcpus=N" at processor enumeration-time rather than smpboot-time
# 
# arch/i386/kernel/setup.c
#   2004/03/17 00:43:10-05:00 len.brown@intel.com +12 -0
#   check "maxcpus=N" at processor enumeration-time rather than smpboot-time
# 
# arch/i386/kernel/mpparse.c
#   2004/03/17 00:43:10-05:00 len.brown@intel.com +9 -2
#   check "maxcpus=N" at processor enumeration-time rather than smpboot-time
# 
diff -Nru a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
--- a/Documentation/kernel-parameters.txt	Tue Mar 23 04:57:53 2004
+++ b/Documentation/kernel-parameters.txt	Tue Mar 23 04:57:53 2004
@@ -103,10 +103,8 @@
 			Format: { s3_bios, s3_mode }
 			See Documentation/power/video.txt
  
-	acpi_pic_sci=	[HW,ACPI] ACPI System Control Interrupt trigger mode
-			Format: { level | edge }
-			level   Force PIC-mode SCI to Level Trigger (default)
-			edge    Force PIC-mode SCI to Edge Trigge
+	acpi_sci=	[HW,ACPI] ACPI System Control Interrupt trigger mode
+			Format: { level | edge |  high | low }
 
 	acpi_irq_balance	[HW,ACPI] ACPI will balance active IRQs
 				default in APIC mode
diff -Nru a/arch/i386/kernel/acpi/boot.c b/arch/i386/kernel/acpi/boot.c
--- a/arch/i386/kernel/acpi/boot.c	Tue Mar 23 04:57:53 2004
+++ b/arch/i386/kernel/acpi/boot.c	Tue Mar 23 04:57:53 2004
@@ -35,11 +35,21 @@
 #include <asm/irq.h>
 #include <asm/mpspec.h>
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#ifdef	CONFIG_X86_64
+
+static inline void  acpi_madt_oem_check(char *oem_id, char *oem_table_id) { }
+static inline void clustered_apic_check(void) { }
+static inline int ioapic_setup_disabled(void) { return 0; }
+#include <asm/proto.h>
+
+#else	/* X86 */
+
+#ifdef	CONFIG_X86_LOCAL_APIC
 #include <mach_apic.h>
 #include <mach_mpparse.h>
-#include <asm/io_apic.h>
-#endif
+#endif	/* CONFIG_X86_LOCAL_APIC */
+
+#endif	/* X86 */
 
 #define PREFIX			"ACPI: "
 
@@ -50,6 +60,9 @@
 int acpi_ioapic;
 int acpi_strict;
 
+acpi_interrupt_flags acpi_sci_flags __initdata;
+int acpi_sci_override_gsi __initdata;
+
 #ifdef CONFIG_X86_LOCAL_APIC
 static u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;
 #endif
@@ -64,6 +77,22 @@
  */
 enum acpi_irq_model_id		acpi_irq_model = ACPI_IRQ_MODEL_PIC;
 
+#ifdef	CONFIG_X86_64
+
+/* rely on all ACPI tables being in the direct mapping */
+char *__acpi_map_table(unsigned long phys_addr, unsigned long size)
+{
+	if (!phys_addr || !size)
+	return NULL;
+
+	if (phys_addr < (end_pfn_map << PAGE_SHIFT))
+		return __va(phys_addr);
+
+	return NULL;
+}
+
+#else
+
 /*
  * Temporarily use the virtual area starting from FIX_IO_APIC_BASE_END,
  * to map the target physical address. The problem is that set_fixmap()
@@ -103,7 +132,7 @@
 
 	return ((unsigned char *) base + offset);
 }
-
+#endif
 
 #ifdef CONFIG_PCI_MMCONFIG
 static int __init acpi_parse_mcfg(unsigned long phys_addr, unsigned long size)
@@ -244,6 +273,34 @@
 	return 0;
 }
 
+/*
+ * Parse Interrupt Source Override for the ACPI SCI
+ */
+static void
+acpi_parse_sci_int_src_ovr(u8 bus_irq, u16 polarity, u16 trigger, u32 global_irq)
+{
+	if (trigger == 0)	/* compatible SCI trigger is level */
+		trigger = 3;
+
+	if (polarity == 0)	/* compatible SCI polarity is low */
+		polarity = 3;
+
+	/* Command-line over-ride via acpi_sci= */
+	if (acpi_sci_flags.trigger)
+		trigger = acpi_sci_flags.trigger;
+
+	if (acpi_sci_flags.polarity)
+		polarity = acpi_sci_flags.polarity;
+
+	mp_override_legacy_irq(bus_irq, polarity, trigger, global_irq);
+
+	/*
+	 * stash over-ride to indicate we've been here
+	 * and for later update of acpi_fadt
+	 */
+	acpi_sci_override_gsi = global_irq;
+	return;
+}
 
 static int __init
 acpi_parse_int_src_ovr (
@@ -257,6 +314,13 @@
 
 	acpi_table_print_madt_entry(header);
 
+	if (intsrc->bus_irq == acpi_fadt.sci_int) {
+		acpi_parse_sci_int_src_ovr(intsrc->bus_irq,
+			intsrc->flags.polarity, intsrc->flags.trigger,
+			intsrc->global_irq);
+		return 0;
+	}
+
 	mp_override_legacy_irq (
 		intsrc->bus_irq,
 		intsrc->flags.polarity,
@@ -287,14 +351,14 @@
 #endif /* CONFIG_X86_IO_APIC */
 
 #ifdef	CONFIG_ACPI_BUS
+
 /*
- * "acpi_pic_sci=level" (current default)
- * programs the PIC-mode SCI to Level Trigger.
- * (NO-OP if the BIOS set Level Trigger already)
+ * acpi_pic_sci_set_trigger()
+ * 
+ * use ELCR to set PIC-mode trigger type for SCI
  *
  * If a PIC-mode SCI is not recognized or gives spurious IRQ7's
- * it may require Edge Trigger -- use "acpi_pic_sci=edge"
- * (NO-OP if the BIOS set Edge Trigger already)
+ * it may require Edge Trigger -- use "acpi_sci=edge"
  *
  * Port 0x4d0-4d1 are ECLR1 and ECLR2, the Edge/Level Control Registers
  * for the 8259 PIC.  bit[n] = 1 means irq[n] is Level, otherwise Edge.
@@ -302,10 +366,8 @@
  * ECLR2 is IRQ's 8-15 (IRQ 8, 13 must be 0)
  */
 
-static int __initdata	acpi_pic_sci_trigger;	/* 0: level, 1: edge */
-
 void __init
-acpi_pic_sci_set_trigger(unsigned int irq)
+acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger)
 {
 	unsigned char mask = 1 << (irq & 7);
 	unsigned int port = 0x4d0 + (irq >> 3);
@@ -316,41 +378,26 @@
 	if (!(val & mask)) {
 		printk(" Edge");
 
-		if (!acpi_pic_sci_trigger) {
+		if (trigger == 3) {
 			printk(" set to Level");
 			outb(val | mask, port);
 		}
 	} else {
 		printk(" Level");
 
-		if (acpi_pic_sci_trigger) {
+		if (trigger == 1) {
 			printk(" set to Edge");
-			outb(val | mask, port);
+			outb(val & ~mask, port);
 		}
 	}
 	printk(" Trigger.\n");
 }
 
-int __init
-acpi_pic_sci_setup(char *str)
-{
-	while (str && *str) {
-		if (strncmp(str, "level", 5) == 0)
-			acpi_pic_sci_trigger = 0;	/* force level trigger */
-		if (strncmp(str, "edge", 4) == 0)
-			acpi_pic_sci_trigger = 1;	/* force edge trigger */
-		str = strchr(str, ',');
-		if (str)
-			str += strspn(str, ", \t");
-	}
-	return 1;
-}
-
-__setup("acpi_pic_sci=", acpi_pic_sci_setup);
 
 #endif /* CONFIG_ACPI_BUS */
 
 #ifdef CONFIG_X86_IO_APIC
+/* deprecated in favor of acpi_gsi_to_irq */
 int acpi_irq_to_vector(u32 irq)
 {
 	if (use_pci_vector() && !platform_legacy_irq(irq))
@@ -359,6 +406,17 @@
 }
 #endif
 
+int acpi_gsi_to_irq(u32 gsi, unsigned int *irq)
+{
+#ifdef CONFIG_X86_IO_APIC
+	if (use_pci_vector() && !platform_legacy_irq(gsi))
+ 		*irq = IO_APIC_VECTOR(gsi);
+	else
+#endif
+		*irq = gsi;
+	return 0;
+}
+
 static unsigned long __init
 acpi_scan_rsdp (
 	unsigned long		start,
@@ -400,7 +458,6 @@
 
 
 #ifdef CONFIG_HPET_TIMER
-extern unsigned long hpet_address;
 
 static int __init acpi_parse_hpet(unsigned long phys, unsigned long size)
 {
@@ -421,18 +478,31 @@
 		return -1;
 	}
 
-	hpet_address = hpet_tbl->addr.addrl;
-	printk(KERN_INFO PREFIX "HPET id: %#x base: %#lx\n", hpet_tbl->id,
-	       hpet_address);
+#ifdef	CONFIG_X86_64
+        vxtime.hpet_address = hpet_tbl->addr.addrl |
+                ((long) hpet_tbl->addr.addrh << 32);
+
+        printk(KERN_INFO PREFIX "HPET id: %#x base: %#lx\n",
+               hpet_tbl->id, vxtime.hpet_address);
+#else	/* X86 */
+	{
+		extern unsigned long hpet_address;
+
+		hpet_address = hpet_tbl->addr.addrl;
+		printk(KERN_INFO PREFIX "HPET id: %#x base: %#lx\n",
+			hpet_tbl->id, hpet_address);
+	}
+#endif	/* X86 */
+
 	return 0;
 }
 #else
 #define	acpi_parse_hpet	NULL
 #endif
 
-/* detect the location of the ACPI PM Timer */
 #ifdef CONFIG_X86_PM_TIMER
 extern u32 pmtmr_ioport;
+#endif
 
 static int __init acpi_parse_fadt(unsigned long phys, unsigned long size)
 {
@@ -444,6 +514,13 @@
 		return 0;
 	}
 
+#ifdef	CONFIG_ACPI_INTERPRETER
+	/* initialize sci_int early for INT_SRC_OVR MADT parsing */
+	acpi_fadt.sci_int = fadt->sci_int;
+#endif
+
+#ifdef CONFIG_X86_PM_TIMER
+	/* detect the location of the ACPI PM Timer */
 	if (fadt->revision >= FADT2_REVISION_ID) {
 		/* FADT rev. 2 */
 		if (fadt->xpm_tmr_blk.address_space_id != ACPI_ADR_SPACE_SYSTEM_IO)
@@ -456,11 +533,9 @@
 	}
 	if (pmtmr_ioport)
 		printk(KERN_INFO PREFIX "PM-Timer IO Port: %#x\n", pmtmr_ioport);
+#endif
 	return 0;
 }
-#else
-#define	acpi_parse_fadt	NULL
-#endif
 
 
 unsigned long __init
@@ -554,7 +629,7 @@
 	/*
  	 * if "noapic" boot option, don't look for IO-APICs
 	 */
-	if (ioapic_setup_disabled()) {
+	if (skip_ioapic_setup) {
 		printk(KERN_INFO PREFIX "Skipping IOAPIC probe "
 			"due to 'noapic' option.\n");
 		return -ENODEV;
@@ -580,6 +655,13 @@
 		return count;
 	}
 
+	/*
+	 * If BIOS did not supply an INT_SRC_OVR for the SCI
+	 * pretend we got one so we can set the SCI flags.
+	 */
+	if (!acpi_sci_override_gsi)
+		acpi_parse_sci_int_src_ovr(acpi_fadt.sci_int, 0, 0, acpi_fadt.sci_int);
+
 	count = acpi_table_parse_madt(ACPI_MADT_NMI_SRC, acpi_parse_nmi_src, NR_IRQ_VECTORS);
 	if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing NMI SRC entry\n");
@@ -668,7 +750,7 @@
 	 */
 	error = acpi_table_init();
 	if (error) {
-		acpi_disabled = 1;
+		disable_acpi();
 		return error;
 	}
 
@@ -680,16 +762,20 @@
 	error = acpi_blacklisted();
 	if (error) {
 		printk(KERN_WARNING PREFIX "BIOS listed in blacklist, disabling ACPI support\n");
-		acpi_disabled = 1;
+		disable_acpi();
 		return error;
 	}
 
 	/*
+	 * set sci_int and PM timer address
+	 */
+	acpi_table_parse(ACPI_FADT, acpi_parse_fadt);
+
+	/*
 	 * Process the Multiple APIC Description Table (MADT), if present
 	 */
 	acpi_process_madt();
 
-	acpi_table_parse(ACPI_FADT, acpi_parse_fadt);
 	acpi_table_parse(ACPI_HPET, acpi_parse_hpet);
 	acpi_table_parse(ACPI_MCFG, acpi_parse_mcfg);
 
diff -Nru a/arch/i386/kernel/dmi_scan.c b/arch/i386/kernel/dmi_scan.c
--- a/arch/i386/kernel/dmi_scan.c	Tue Mar 23 04:57:53 2004
+++ b/arch/i386/kernel/dmi_scan.c	Tue Mar 23 04:57:53 2004
@@ -523,13 +523,13 @@
 
 
 #ifdef	CONFIG_ACPI_BOOT
-extern int acpi_disabled, acpi_force;
+extern int acpi_force;
 
-static __init __attribute__((unused)) int disable_acpi(struct dmi_blacklist *d)
+static __init __attribute__((unused)) int dmi_disable_acpi(struct dmi_blacklist *d) 
 { 
 	if (!acpi_force) { 
 		printk(KERN_NOTICE "%s detected: acpi off\n",d->ident); 
-		acpi_disabled = 1;
+		disable_acpi();
 	} else { 
 		printk(KERN_NOTICE 
 		       "Warning: DMI blacklist says broken, but acpi forced\n"); 
@@ -537,8 +537,6 @@
 	return 0;
 } 
 
-extern int acpi_ht;
-
 /*
  * Limit ACPI to CPU enumeration for HT
  */
@@ -546,7 +544,7 @@
 { 
 	if (!acpi_force) { 
 		printk(KERN_NOTICE "%s detected: force use of acpi=ht\n", d->ident); 
-		acpi_disabled = 1; 
+		disable_acpi();
 		acpi_ht = 1; 
 	} else { 
 		printk(KERN_NOTICE 
@@ -933,7 +931,7 @@
 	 *	Boxes that need ACPI disabled
 	 */
 
-	{ disable_acpi, "IBM Thinkpad", {
+	{ dmi_disable_acpi, "IBM Thinkpad", {
 			MATCH(DMI_BOARD_VENDOR, "IBM"),
 			MATCH(DMI_BOARD_NAME, "2629H1G"),
 			NO_MATCH, NO_MATCH }},
@@ -1063,8 +1061,7 @@
 			if (disable && !acpi_force) { 
 				printk(KERN_NOTICE "ACPI disabled because your bios is from %s and too old\n", s);
 				printk(KERN_NOTICE "You can enable it with acpi=force\n");
-				acpi_disabled = 1; 
-				acpi_ht = 0;
+				disable_acpi();
 			} 
 		}
 	}
diff -Nru a/arch/i386/kernel/mpparse.c b/arch/i386/kernel/mpparse.c
--- a/arch/i386/kernel/mpparse.c	Tue Mar 23 04:57:53 2004
+++ b/arch/i386/kernel/mpparse.c	Tue Mar 23 04:57:53 2004
@@ -1,5 +1,5 @@
 /*
- *	Intel Multiprocessor Specificiation 1.1 and 1.4
+ *	Intel Multiprocessor Specification 1.1 and 1.4
  *	compliant MP-table parsing routines.
  *
  *	(c) 1995 Alan Cox, Building #3 <alan@redhat.com>
@@ -37,6 +37,7 @@
 
 /* Have we found an MP table */
 int smp_found_config;
+unsigned int __initdata maxcpus = NR_CPUS;
 
 /*
  * Various Linux-internal data structures created from the
@@ -168,8 +169,14 @@
 	}
 
 	if (num_processors >= NR_CPUS) {
-		printk(KERN_WARNING "NR_CPUS limit of %i reached.  Cannot "
-			"boot CPU(apicid 0x%x).\n", NR_CPUS, m->mpc_apicid);
+		printk(KERN_WARNING "WARNING: NR_CPUS limit of %i reached."
+			"  Processor ignored.\n", NR_CPUS); 
+		return;
+	}
+
+	if (num_processors >= maxcpus) {
+		printk(KERN_WARNING "WARNING: maxcpus limit of %i reached."
+			" Processor ignored.\n", maxcpus); 
 		return;
 	}
 	num_processors++;
@@ -844,25 +851,25 @@
 
 struct mp_ioapic_routing {
 	int			apic_id;
-	int			irq_start;
-	int			irq_end;
+	int			gsi_base;
+	int			gsi_end;
 	u32			pin_programmed[4];
 } mp_ioapic_routing[MAX_IO_APICS];
 
 
 static int __init mp_find_ioapic (
-	int			irq)
+	int			gsi)
 {
 	int			i = 0;
 
-	/* Find the IOAPIC that manages this IRQ. */
+	/* Find the IOAPIC that manages this GSI. */
 	for (i = 0; i < nr_ioapics; i++) {
-		if ((irq >= mp_ioapic_routing[i].irq_start)
-			&& (irq <= mp_ioapic_routing[i].irq_end))
+		if ((gsi >= mp_ioapic_routing[i].gsi_base)
+			&& (gsi <= mp_ioapic_routing[i].gsi_end))
 			return i;
 	}
 
-	printk(KERN_ERR "ERROR: Unable to locate IOAPIC for IRQ %d\n", irq);
+	printk(KERN_ERR "ERROR: Unable to locate IOAPIC for GSI %d\n", gsi);
 
 	return -1;
 }
@@ -871,7 +878,7 @@
 void __init mp_register_ioapic (
 	u8			id, 
 	u32			address,
-	u32			irq_base)
+	u32			gsi_base)
 {
 	int			idx = 0;
 
@@ -897,19 +904,19 @@
 	mp_ioapics[idx].mpc_apicver = io_apic_get_version(idx);
 	
 	/* 
-	 * Build basic IRQ lookup table to facilitate irq->io_apic lookups
-	 * and to prevent reprogramming of IOAPIC pins (PCI IRQs).
+	 * Build basic GSI lookup table to facilitate gsi->io_apic lookups
+	 * and to prevent reprogramming of IOAPIC pins (PCI GSIs).
 	 */
 	mp_ioapic_routing[idx].apic_id = mp_ioapics[idx].mpc_apicid;
-	mp_ioapic_routing[idx].irq_start = irq_base;
-	mp_ioapic_routing[idx].irq_end = irq_base + 
+	mp_ioapic_routing[idx].gsi_base = gsi_base;
+	mp_ioapic_routing[idx].gsi_end = gsi_base + 
 		io_apic_get_redir_entries(idx);
 
 	printk("IOAPIC[%d]: apic_id %d, version %d, address 0x%lx, "
-		"IRQ %d-%d\n", idx, mp_ioapics[idx].mpc_apicid, 
+		"GSI %d-%d\n", idx, mp_ioapics[idx].mpc_apicid, 
 		mp_ioapics[idx].mpc_apicver, mp_ioapics[idx].mpc_apicaddr,
-		mp_ioapic_routing[idx].irq_start,
-		mp_ioapic_routing[idx].irq_end);
+		mp_ioapic_routing[idx].gsi_base,
+		mp_ioapic_routing[idx].gsi_end);
 
 	return;
 }
@@ -919,7 +926,7 @@
 	u8			bus_irq,
 	u8			polarity, 
 	u8			trigger, 
-	u32			global_irq)
+	u32			gsi)
 {
 	struct mpc_config_intsrc intsrc;
 	int			i = 0;
@@ -928,12 +935,12 @@
 	int			pin = -1;
 
 	/* 
-	 * Convert 'global_irq' to 'ioapic.pin'.
+	 * Convert 'gsi' to 'ioapic.pin'.
 	 */
-	ioapic = mp_find_ioapic(global_irq);
+	ioapic = mp_find_ioapic(gsi);
 	if (ioapic < 0)
 		return;
-	pin = global_irq - mp_ioapic_routing[ioapic].irq_start;
+	pin = gsi - mp_ioapic_routing[ioapic].gsi_base;
 
 	/*
 	 * TBD: This check is for faulty timer entries, where the override
@@ -958,7 +965,7 @@
 
 	/* 
 	 * If an existing [IOAPIC.PIN -> IRQ] routing entry exists we override it.
-	 * Otherwise create a new entry (e.g. global_irq == 2).
+	 * Otherwise create a new entry (e.g. gsi == 2).
 	 */
 	for (i = 0; i < mp_irq_entries; i++) {
 		if ((mp_irqs[i].mpc_srcbus == intsrc.mpc_srcbus) 
@@ -1029,69 +1036,6 @@
 
 extern FADT_DESCRIPTOR acpi_fadt;
 
-void __init mp_config_ioapic_for_sci(int irq)
-{
-	int ioapic;
-	int ioapic_pin;
-	struct acpi_table_madt *madt;
-	struct acpi_table_int_src_ovr *entry = NULL;
-	acpi_interrupt_flags flags;
-	void *madt_end;
-	acpi_status status;
-
-	/*
-	 * Ensure that if there is an interrupt source override entry
-	 * for the ACPI SCI, we leave it as is. Unfortunately this involves
-	 * walking the MADT again.
-	 */
-	status = acpi_get_firmware_table("APIC", 1, ACPI_LOGICAL_ADDRESSING,
-		(struct acpi_table_header **) &madt);
-	if (ACPI_SUCCESS(status)) {
-		madt_end = (void *) (unsigned long)madt + madt->header.length;
-
-		entry = (struct acpi_table_int_src_ovr *)
-                ((unsigned long) madt + sizeof(struct acpi_table_madt));
-
-		while ((void *) entry < madt_end) {
-                	if (entry->header.type == ACPI_MADT_INT_SRC_OVR &&
-			    acpi_fadt.sci_int == entry->bus_irq)
-				goto found;
-			
-                	entry = (struct acpi_table_int_src_ovr *)
-                	        ((unsigned long) entry + entry->header.length);
-        	}
-	}
-	/*
-	 * Although the ACPI spec says that the SCI should be level/low
-	 * don't reprogram it unless there is an explicit MADT OVR entry
-	 * instructing us to do so -- otherwise we break Tyan boards which
-	 * have the SCI wired edge/high but no MADT OVR.
-	 */
-	return;
-
-found:
-	/*
-	 * See the note at the end of ACPI 2.0b section
-	 * 5.2.10.8 for what this is about.
-	 */
-	flags = entry->flags;
-	acpi_fadt.sci_int = entry->global_irq;
-	irq = entry->global_irq;
-
-	ioapic = mp_find_ioapic(irq);
-
-	ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
-
-	/*
-	 * MPS INTI flags:
-	 *  trigger: 0=default, 1=edge, 3=level
-	 *  polarity: 0=default, 1=high, 3=low
-	 * Per ACPI spec, default for SCI means level/low.
-	 */
-	io_apic_set_pci_routing(ioapic, ioapic_pin, irq, 
-		(flags.trigger == 1 ? 0 : 1), (flags.polarity == 1 ? 0 : 1));
-}
-
 #ifdef CONFIG_ACPI_PCI
 
 void __init mp_parse_prt (void)
@@ -1100,7 +1044,7 @@
 	struct acpi_prt_entry	*entry = NULL;
 	int			ioapic = -1;
 	int			ioapic_pin = 0;
-	int			irq = 0;
+	int			gsi = 0;
 	int			idx, bit = 0;
 	int			edge_level = 0;
 	int			active_high_low = 0;
@@ -1112,39 +1056,39 @@
 	list_for_each(node, &acpi_prt.entries) {
 		entry = list_entry(node, struct acpi_prt_entry, node);
 
-		/* Need to get irq for dynamic entry */
+		/* Need to get gsi for dynamic entry */
 		if (entry->link.handle) {
-			irq = acpi_pci_link_get_irq(entry->link.handle, entry->link.index, &edge_level, &active_high_low);
-			if (!irq)
+			gsi = acpi_pci_link_get_irq(entry->link.handle, entry->link.index, &edge_level, &active_high_low);
+			if (!gsi)
 				continue;
 		}
 		else {
-			/* Hardwired IRQ. Assume PCI standard settings */
-			irq = entry->link.index;
+			/* Hardwired GSI. Assume PCI standard settings */
+			gsi = entry->link.index;
 			edge_level = 1;
 			active_high_low = 1;
 		}
 
 		/* Don't set up the ACPI SCI because it's already set up */
-                if (acpi_fadt.sci_int == irq) {
-			irq = acpi_irq_to_vector(irq);
-			entry->irq = irq; /* we still need to set entry's irq */
+                if (acpi_fadt.sci_int == gsi) {
+			/* we still need to set entry's irq */
+			acpi_gsi_to_irq(gsi, &entry->irq);
 			continue;
                 }
 	
-		ioapic = mp_find_ioapic(irq);
+		ioapic = mp_find_ioapic(gsi);
 		if (ioapic < 0)
 			continue;
-		ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
+		ioapic_pin = gsi - mp_ioapic_routing[ioapic].gsi_base;
 
 		if (es7000_plat) {
-			if (!ioapic && (irq < 16))
-				irq += 16;
+			if (!ioapic && (gsi < 16))
+				gsi += 16;
 		}
 
 		/* 
 		 * Avoid pin reprogramming.  PRTs typically include entries  
-		 * with redundant pin->irq mappings (but unique PCI devices);
+		 * with redundant pin->gsi mappings (but unique PCI devices);
 		 * we only only program the IOAPIC on the first.
 		 */
 		bit = ioapic_pin % 32;
@@ -1158,19 +1102,19 @@
 		if ((1<<bit) & mp_ioapic_routing[ioapic].pin_programmed[idx]) {
 			Dprintk(KERN_DEBUG "Pin %d-%d already programmed\n",
 				mp_ioapic_routing[ioapic].apic_id, ioapic_pin);
- 			entry->irq = acpi_irq_to_vector(irq);
+			acpi_gsi_to_irq(gsi, &entry->irq);
 			continue;
 		}
 
 		mp_ioapic_routing[ioapic].pin_programmed[idx] |= (1<<bit);
 
-		if (!io_apic_set_pci_routing(ioapic, ioapic_pin, irq, edge_level, active_high_low)) {
- 			entry->irq = acpi_irq_to_vector(irq);
- 		}
+		if (!io_apic_set_pci_routing(ioapic, ioapic_pin, gsi, edge_level, active_high_low)) {
+			acpi_gsi_to_irq(gsi, &entry->irq);
+		}
 		printk(KERN_DEBUG "%02x:%02x:%02x[%c] -> %d-%d -> IRQ %d\n",
-			entry->id.segment, entry->id.bus, 
-			entry->id.device, ('A' + entry->pin), 
-			mp_ioapic_routing[ioapic].apic_id, ioapic_pin, 
+			entry->id.segment, entry->id.bus,
+			entry->id.device, ('A' + entry->pin),
+			mp_ioapic_routing[ioapic].apic_id, ioapic_pin,
 			entry->irq);
 	}
 
diff -Nru a/arch/i386/kernel/setup.c b/arch/i386/kernel/setup.c
--- a/arch/i386/kernel/setup.c	Tue Mar 23 04:57:53 2004
+++ b/arch/i386/kernel/setup.c	Tue Mar 23 04:57:53 2004
@@ -83,8 +83,8 @@
 EXPORT_SYMBOL(acpi_disabled);
 
 #ifdef	CONFIG_ACPI_BOOT
-extern int __initdata acpi_ht;
 int __initdata acpi_force = 0;
+extern acpi_interrupt_flags	acpi_sci_flags;
 #endif
 
 int MCA_bus;
@@ -560,17 +560,28 @@
 			}
 		}
 
+#ifdef  CONFIG_SMP
+		/*
+		 * If the BIOS enumerates physical processors before logical,
+		 * maxcpus=N at enumeration-time can be used to disable HT.
+		 */
+		else if (!memcmp(from, "maxcpus=", 8)) {
+			extern unsigned int maxcpus;
+
+			maxcpus = simple_strtoul(from + 8, NULL, 0);
+		}
+#endif
+
 #ifdef CONFIG_ACPI_BOOT
 		/* "acpi=off" disables both ACPI table parsing and interpreter */
 		else if (!memcmp(from, "acpi=off", 8)) {
-			acpi_ht = 0;
-			acpi_disabled = 1;
+			disable_acpi();
 		}
 
 		/* acpi=force to over-ride black-list */
 		else if (!memcmp(from, "acpi=force", 10)) {
 			acpi_force = 1;
-			acpi_ht=1;
+			acpi_ht = 1;
 			acpi_disabled = 0;
 		}
 
@@ -581,14 +592,27 @@
 
 		/* Limit ACPI just to boot-time to enable HT */
 		else if (!memcmp(from, "acpi=ht", 7)) {
+			if (!acpi_force)
+				disable_acpi();
 			acpi_ht = 1;
-			if (!acpi_force) acpi_disabled = 1;
 		}
 
 		/* "pci=noacpi" disables ACPI interrupt routing */
 		else if (!memcmp(from, "pci=noacpi", 10)) {
 			acpi_noirq_set();
 		}
+
+		else if (!memcmp(from, "acpi_sci=edge", 13))
+			acpi_sci_flags.trigger =  1;
+
+		else if (!memcmp(from, "acpi_sci=level", 14))
+			acpi_sci_flags.trigger = 3;
+
+		else if (!memcmp(from, "acpi_sci=high", 13))
+			acpi_sci_flags.polarity = 1;
+
+		else if (!memcmp(from, "acpi_sci=low", 12))
+			acpi_sci_flags.polarity = 3;
 
 #ifdef CONFIG_X86_LOCAL_APIC
 		/* disable IO-APIC */
diff -Nru a/arch/ia64/kernel/acpi.c b/arch/ia64/kernel/acpi.c
--- a/arch/ia64/kernel/acpi.c	Tue Mar 23 04:57:53 2004
+++ b/arch/ia64/kernel/acpi.c	Tue Mar 23 04:57:53 2004
@@ -62,8 +62,6 @@
 unsigned char acpi_kbd_controller_present = 1;
 unsigned char acpi_legacy_devices;
 
-int acpi_disabled;	/* XXX this shouldn't be needed---we can't boot without ACPI! */
-
 const char *
 acpi_get_sysname (void)
 {
diff -Nru a/arch/x86_64/kernel/Makefile b/arch/x86_64/kernel/Makefile
--- a/arch/x86_64/kernel/Makefile	Tue Mar 23 04:57:53 2004
+++ b/arch/x86_64/kernel/Makefile	Tue Mar 23 04:57:53 2004
@@ -11,6 +11,7 @@
 obj-y += mce.o acpi/
 
 obj-$(CONFIG_MTRR)		+= ../../i386/kernel/cpu/mtrr/
+obj-$(CONFIG_ACPI_BOOT)		+= acpi/
 obj-$(CONFIG_X86_MSR)		+= msr.o
 obj-$(CONFIG_MICROCODE)		+= microcode.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
diff -Nru a/arch/x86_64/kernel/acpi/Makefile b/arch/x86_64/kernel/acpi/Makefile
--- a/arch/x86_64/kernel/acpi/Makefile	Tue Mar 23 04:57:53 2004
+++ b/arch/x86_64/kernel/acpi/Makefile	Tue Mar 23 04:57:53 2004
@@ -1,3 +1,3 @@
 obj-$(CONFIG_ACPI_BOOT)		:= boot.o
+boot-$(CONFIG_ACPI_BOOT)	:= ../../../i386/kernel/acpi/boot.o
 obj-$(CONFIG_ACPI_SLEEP)	+= sleep.o wakeup.o
-
diff -Nru a/arch/x86_64/kernel/acpi/boot.c b/arch/x86_64/kernel/acpi/boot.c
--- a/arch/x86_64/kernel/acpi/boot.c	Tue Mar 23 04:57:53 2004
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,619 +0,0 @@
-/*
- *  acpi.c - Architecture-Specific Low-Level ACPI Support
- *
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *  Copyright (C) 2001 Jun Nakajima <jun.nakajima@intel.com>
- *  Copyright (C) 2001 Patrick Mochel <mochel@osdl.org>
- *  Copyright (C) 2002 Andi Kleen, SuSE Labs (x86-64 port)
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/stddef.h>
-#include <linux/slab.h>
-#include <linux/pci.h>
-#include <linux/bootmem.h>
-#include <linux/irq.h>
-#include <linux/acpi.h>
-#include <asm/mpspec.h>
-#include <asm/io.h>
-#include <asm/apic.h>
-#include <asm/apicdef.h>
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <asm/pgalloc.h>
-#include <asm/io_apic.h>
-#include <asm/proto.h>
-#include <asm/tlbflush.h>
-
-#define PREFIX			"ACPI: "
-
-int acpi_noirq __initdata;	/* skip ACPI IRQ initialization */
-int acpi_ht __initdata = 1;	/* enable HT */
-
-int acpi_lapic;
-int acpi_ioapic;
-int acpi_strict;
-
-/* --------------------------------------------------------------------------
-                              Boot-time Configuration
-   -------------------------------------------------------------------------- */
-
-#ifdef CONFIG_ACPI_BOOT
-
-enum acpi_irq_model_id		acpi_irq_model;
-
-/* rely on all ACPI tables being in the direct mapping */
-char *
-__acpi_map_table (
-	unsigned long	phys_addr,
-	unsigned long	size)
-{
-	if (!phys_addr || !size)
-		return NULL;
-
-	if (phys_addr < (end_pfn_map << PAGE_SHIFT)) 
-		return __va(phys_addr); 
-
-	return NULL; 
-} 	      
-
-#ifdef CONFIG_PCI_MMCONFIG
-static int __init acpi_parse_mcfg(unsigned long phys_addr, unsigned long size)
-{
-	struct acpi_table_mcfg *mcfg;
-
-	if (!phys_addr || !size)
-		return -EINVAL;
-
-	mcfg = (struct acpi_table_mcfg *) __acpi_map_table(phys_addr, size);
-	if (!mcfg) {
-		printk(KERN_WARNING PREFIX "Unable to map MCFG\n");
-		return -ENODEV;
-	}
-
-	if (mcfg->base_reserved) {
-		printk(KERN_ERR PREFIX "MMCONFIG not in low 4GB of memory\n");
-		return -ENODEV;
-	}
-
-	pci_mmcfg_base_addr = mcfg->base_address;
-
-	return 0;
-}
-#endif /* CONFIG_PCI_MMCONFIG */
-
-#ifdef CONFIG_X86_LOCAL_APIC
-
-static u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;
-
-
-static int __init
-acpi_parse_madt (
-	unsigned long		phys_addr,
-	unsigned long		size)
-{
-	struct acpi_table_madt	*madt = NULL;
-
-	if (!phys_addr || !size)
-		return -EINVAL;
-
-	madt = (struct acpi_table_madt *) __acpi_map_table(phys_addr, size);
-	if (!madt) {
-		printk(KERN_WARNING PREFIX "Unable to map MADT\n");
-		return -ENODEV;
-	}
-
-	if (madt->lapic_address)
-		acpi_lapic_addr = (u64) madt->lapic_address;
-
-	printk(KERN_INFO PREFIX "Local APIC address 0x%016x\n",
-		madt->lapic_address);
-
-	return 0;
-}
-
-
-static int __init
-acpi_parse_lapic (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_lapic	*processor = NULL;
-
-	processor = (struct acpi_table_lapic*) header;
-	if (!processor)
-		return -EINVAL;
-
-	acpi_table_print_madt_entry(header);
-
-	/* no utility in registering a disabled processor */
-	if (processor->flags.enabled == 0)
-		return 0;
-
-
-	mp_register_lapic (
-		processor->id,					   /* APIC ID */
-		processor->flags.enabled);			  /* Enabled? */
-
-	return 0;
-}
-
-
-static int __init
-acpi_parse_lapic_addr_ovr (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_lapic_addr_ovr *lapic_addr_ovr = NULL;
-
-	lapic_addr_ovr = (struct acpi_table_lapic_addr_ovr*) header;
-	if (!lapic_addr_ovr)
-		return -EINVAL;
-
-	acpi_lapic_addr = lapic_addr_ovr->address;
-
-	return 0;
-}
-
-
-static int __init
-acpi_parse_lapic_nmi (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_lapic_nmi *lapic_nmi = NULL;
-
-	lapic_nmi = (struct acpi_table_lapic_nmi*) header;
-	if (!lapic_nmi)
-		return -EINVAL;
-
-	acpi_table_print_madt_entry(header);
-
-	if (lapic_nmi->lint != 1)
-		printk(KERN_WARNING PREFIX "NMI not connected to LINT 1!\n");
-
-	return 0;
-}
-
-#endif /*CONFIG_X86_LOCAL_APIC*/
-
-#ifdef CONFIG_X86_IO_APIC
-
-static int __init
-acpi_parse_ioapic (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_ioapic *ioapic = NULL;
-
-	ioapic = (struct acpi_table_ioapic*) header;
-	if (!ioapic)
-		return -EINVAL;
- 
-	acpi_table_print_madt_entry(header);
-
-	mp_register_ioapic (
-		ioapic->id,
-		ioapic->address,
-		ioapic->global_irq_base);
- 
-	return 0;
-}
-
-
-static int __init
-acpi_parse_int_src_ovr (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_int_src_ovr *intsrc = NULL;
-
-	intsrc = (struct acpi_table_int_src_ovr*) header;
-	if (!intsrc)
-		return -EINVAL;
-
-	acpi_table_print_madt_entry(header);
-
-	mp_override_legacy_irq (
-		intsrc->bus_irq,
-		intsrc->flags.polarity,
-		intsrc->flags.trigger,
-		intsrc->global_irq);
-
-	return 0;
-}
-
-
-static int __init
-acpi_parse_nmi_src (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_nmi_src *nmi_src = NULL;
-
-	nmi_src = (struct acpi_table_nmi_src*) header;
-	if (!nmi_src)
-		return -EINVAL;
-
-	acpi_table_print_madt_entry(header);
-
-	/* TBD: Support nimsrc entries? */
-
-	return 0;
-}
-
-#endif /*CONFIG_X86_IO_APIC*/
-
-static int __init acpi_parse_sbf(unsigned long phys_addr, unsigned long size)
-{
-	struct acpi_table_sbf *sb;
-
-	if (!phys_addr || !size)
-		return -EINVAL;
-
-	sb = (struct acpi_table_sbf *) __acpi_map_table(phys_addr, size);
-	if (!sb) {
-		printk(KERN_WARNING PREFIX "Unable to map SBF\n");
-		return -ENODEV;
-	}
-
-	sbf_port = sb->sbf_cmos; /* Save CMOS port */
-
-	return 0;
-}
-
-#ifdef CONFIG_HPET_TIMER
-static int __init
-acpi_parse_hpet (
-	unsigned long		phys_addr,
-	unsigned long		size)
-{
-	struct acpi_table_hpet *hpet_tbl;
-
-	hpet_tbl = __va(phys_addr);
-
-	if (hpet_tbl->addr.space_id != ACPI_SPACE_MEM) {
-		printk(KERN_WARNING "acpi: HPET timers must be located in memory.\n");
-		return -1;
-	}
-
-	vxtime.hpet_address = hpet_tbl->addr.addrl |
-		((long) hpet_tbl->addr.addrh << 32);
-
-	printk(KERN_INFO "acpi: HPET id: %#x base: %#lx\n",
-	       hpet_tbl->id, vxtime.hpet_address);
-
-	return 0;
-} 
-#endif
-
-#ifdef CONFIG_ACPI_BUS
-/*
- * "acpi_pic_sci=level" (current default)
- * programs the PIC-mode SCI to Level Trigger.
- * (NO-OP if the BIOS set Level Trigger already)
- *
- * If a PIC-mode SCI is not recognized or gives spurious IRQ7's
- * it may require Edge Trigger -- use "acpi_pic_sci=edge"
- * (NO-OP if the BIOS set Edge Trigger already)
- *
- * Port 0x4d0-4d1 are ECLR1 and ECLR2, the Edge/Level Control Registers
- * for the 8259 PIC.  bit[n] = 1 means irq[n] is Level, otherwise Edge.
- * ECLR1 is IRQ's 0-7 (IRQ 0, 1, 2 must be 0)
- * ECLR2 is IRQ's 8-15 (IRQ 8, 13 must be 0)
- */
-
-static int __initdata	acpi_pic_sci_trigger;	/* 0: level, 1: edge */
-
-void __init
-acpi_pic_sci_set_trigger(unsigned int irq)
-{
-	unsigned char mask = 1 << (irq & 7);
-	unsigned int port = 0x4d0 + (irq >> 3);
-	unsigned char val = inb(port);
-
-	
-	printk(PREFIX "IRQ%d SCI:", irq);
-	if (!(val & mask)) {
-		printk(" Edge");
-
-		if (!acpi_pic_sci_trigger) {
-			printk(" set to Level");
-			outb(val | mask, port);
-		}
-	} else {
-		printk(" Level");
-
-		if (acpi_pic_sci_trigger) {
-			printk(" set to Edge");
-			outb(val | mask, port);
-		}
-	}
-	printk(" Trigger.\n");
-}
-
-int __init
-acpi_pic_sci_setup(char *str)
-{
-	while (str && *str) {
-		if (strncmp(str, "level", 5) == 0)
-			acpi_pic_sci_trigger = 0;	/* force level trigger */
-		if (strncmp(str, "edge", 4) == 0)
-			acpi_pic_sci_trigger = 1;	/* force edge trigger */
-		str = strchr(str, ',');
-		if (str)
-			str += strspn(str, ", \t");
-	}
-	return 1;
-}
-
-__setup("acpi_pic_sci=", acpi_pic_sci_setup);
-
-#endif /* CONFIG_ACPI_BUS */
-
-int acpi_gsi_to_irq(u32 gsi, unsigned int *irq)
-{
-#ifdef CONFIG_X86_IO_APIC
-	if (use_pci_vector() && !platform_legacy_irq(gsi))
- 		*irq = IO_APIC_VECTOR(gsi);
-	else
-#endif
-		*irq = gsi;
-	return 0;
-}
-
-static unsigned long __init
-acpi_scan_rsdp (
-	unsigned long		start,
-	unsigned long		length)
-{
-	unsigned long		offset = 0;
-	unsigned long		sig_len = sizeof("RSD PTR ") - 1;
-
-	/*
-	 * Scan all 16-byte boundaries of the physical memory region for the
-	 * RSDP signature.
-	 */
-	for (offset = 0; offset < length; offset += 16) {
-		if (strncmp((char *) (start + offset), "RSD PTR ", sig_len))
-			continue;
-		return (start + offset);
-	}
-
-	return 0;
-}
-
-
-unsigned long __init
-acpi_find_rsdp (void)
-{
-	unsigned long		rsdp_phys = 0;
-
-	/*
-	 * Scan memory looking for the RSDP signature. First search EBDA (low
-	 * memory) paragraphs and then search upper memory (E0000-FFFFF).
-	 */
-	rsdp_phys = acpi_scan_rsdp (0, 0x400);
-	if (!rsdp_phys)
-		rsdp_phys = acpi_scan_rsdp (0xE0000, 0xFFFFF);
-
-	return rsdp_phys;
-}
-
-/*
- * acpi_boot_init()
- *  called from setup_arch(), always.
- *     1. maps ACPI tables for later use
- *     2. enumerates lapics
- *     3. enumerates io-apics
- *
- * side effects:
- *     acpi_lapic = 1 if LAPIC found
- *     acpi_ioapic = 1 if IOAPIC found
- *     if (acpi_lapic && acpi_ioapic) smp_found_config = 1;
- *     if acpi_blacklisted() acpi_disabled = 1;
- *     acpi_irq_model=...
- *     ...
- *
- * return value: (currently ignored)
- *     0: success
- *     !0: failure
- */
-
-int __init
-acpi_boot_init (void)
-{
-	int			result = 0;
-
-	if (acpi_disabled && !acpi_ht)
-		return 1;
-
-	/*
-	 * The default interrupt routing model is PIC (8259).  This gets
-	 * overriden if IOAPICs are enumerated (below).
-	 */
-	acpi_irq_model = ACPI_IRQ_MODEL_PIC;
-
-	/* 
-	 * Initialize the ACPI boot-time table parser.
-	 */
-	result = acpi_table_init();
-	if (result) {
-		acpi_disabled = 1;
-		return result;
-	}
-
-	(void) acpi_table_parse(ACPI_BOOT, acpi_parse_sbf);
-
-	result = acpi_blacklisted();
-	if (result) {
-		printk(KERN_WARNING PREFIX "BIOS listed in blacklist, disabling ACPI support\n");
-		acpi_disabled = 1;
-		return result;
-	}
-
-	if (disable_apic) { 
-		printk(KERN_INFO PREFIX "Skipping MADT probe because local APIC is disabled\n");
-		return 0;
-	}
-
-#ifdef CONFIG_X86_LOCAL_APIC
-
-	/* 
-	 * MADT
-	 * ----
-	 * Parse the Multiple APIC Description Table (MADT), if exists.
-	 * Note that this table provides platform SMP configuration 
-	 * information -- the successor to MPS tables.
-	 */
-
-	result = acpi_table_parse(ACPI_APIC, acpi_parse_madt);
-	if (!result) {
-		printk(KERN_WARNING PREFIX "MADT not present\n");
-		return 0;
-	}
-	else if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing MADT\n");
-		return result;
-	}
-	else if (result > 1) 
-		printk(KERN_WARNING PREFIX "Multiple MADT tables exist\n");
-
-	/* 
-	 * Local APIC
-	 * ----------
-	 * Note that the LAPIC address is obtained from the MADT (32-bit value)
-	 * and (optionally) overriden by a LAPIC_ADDR_OVR entry (64-bit value).
-	 */
-
-	result = acpi_table_parse_madt(ACPI_MADT_LAPIC_ADDR_OVR, acpi_parse_lapic_addr_ovr, 0);
-	if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing LAPIC address override entry\n");
-		return result;
-	}
-
-	mp_register_lapic_address(acpi_lapic_addr);
-
-	result = acpi_table_parse_madt(ACPI_MADT_LAPIC, acpi_parse_lapic,
-				       MAX_APICS);
-	if (!result) { 
-		printk(KERN_ERR PREFIX "No LAPIC entries present\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return -ENODEV;
-	}
-	else if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing LAPIC entry\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
-	}
-
-	result = acpi_table_parse_madt(ACPI_MADT_LAPIC_NMI, acpi_parse_lapic_nmi, 0);
-	if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing LAPIC NMI entry\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
-	}
-
-	acpi_lapic = 1;
-
-#endif /*CONFIG_X86_LOCAL_APIC*/
-
-#ifdef CONFIG_X86_IO_APIC
-
-	/* 
-	 * I/O APIC 
-	 * --------
-	 */
-
-       /*
-        * ACPI interpreter is required to complete interrupt setup,
-        * so if it is off, don't enumerate the io-apics with ACPI.
-        * If MPS is present, it will handle them,
-        * otherwise the system will stay in PIC mode
-        */
-        if (acpi_disabled || acpi_noirq) {
-               return 1;
-	}
-
-	/*
-	 * if "noapic" boot option, don't look for IO-APICs
-	 */
-	if (skip_ioapic_setup) {
-		printk(KERN_INFO PREFIX "Skipping IOAPIC probe "
-		       "due to 'noapic' option.\n");
-		return 1;
-	}
-
-	result = acpi_table_parse_madt(ACPI_MADT_IOAPIC, acpi_parse_ioapic, MAX_IO_APICS);
-	if (!result) {
-		printk(KERN_ERR PREFIX "No IOAPIC entries present\n");
-		return -ENODEV;
-	}
-	else if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing IOAPIC entry\n");
-		return result;
-	}
-
-	/* Build a default routing table for legacy (ISA) interrupts. */
-	mp_config_acpi_legacy_irqs();
-
-	result = acpi_table_parse_madt(ACPI_MADT_INT_SRC_OVR, acpi_parse_int_src_ovr, NR_IRQ_VECTORS);
-	if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing interrupt source overrides entry\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
-	}
-
-	result = acpi_table_parse_madt(ACPI_MADT_NMI_SRC, acpi_parse_nmi_src,
-				       NR_IRQ_VECTORS);
-	if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing NMI SRC entry\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
-	}
-
-	acpi_irq_model = ACPI_IRQ_MODEL_IOAPIC;
-
-	acpi_irq_balance_set(NULL);
-
-	acpi_ioapic = 1;
-
-#endif /*CONFIG_X86_IO_APIC*/
-
-#ifdef CONFIG_X86_LOCAL_APIC
-	if (acpi_lapic && acpi_ioapic)
-		smp_found_config = 1;
-#endif
-
-#ifdef CONFIG_HPET_TIMER
-	result = acpi_table_parse(ACPI_HPET, acpi_parse_hpet);
-	if (result < 0) 
-		printk("ACPI: no HPET table found (%d).\n", result); 
-#endif
-
-#ifdef CONFIG_PCI_MMCONFIG
-	result = acpi_table_parse(ACPI_MCFG, acpi_parse_mcfg);
-	if (result)
-		printk(KERN_ERR PREFIX "Error %d parsing MCFG\n", result);
-#endif
-
-	return 0;
-}
-
-#endif /*CONFIG_ACPI_BOOT*/
-
diff -Nru a/arch/x86_64/kernel/mpparse.c b/arch/x86_64/kernel/mpparse.c
--- a/arch/x86_64/kernel/mpparse.c	Tue Mar 23 04:57:53 2004
+++ b/arch/x86_64/kernel/mpparse.c	Tue Mar 23 04:57:53 2004
@@ -33,6 +33,7 @@
 
 /* Have we found an MP table */
 int smp_found_config;
+unsigned int __initdata maxcpus = NR_CPUS;
 
 int acpi_found_madt;
 
@@ -117,6 +118,17 @@
 		Dprintk("    Bootup CPU\n");
 		boot_cpu_id = m->mpc_apicid;
 	}
+	if (num_processors >= NR_CPUS) {
+		printk(KERN_WARNING "WARNING: NR_CPUS limit of %i reached."
+			" Processor ignored.\n", NR_CPUS);
+		return;
+	}
+	if (num_processors >= maxcpus) {
+		printk(KERN_WARNING "WARNING: maxcpus limit of %i reached."
+			" Processor ignored.\n", maxcpus);
+		return;
+	}
+
 	num_processors++;
 
 	if (m->mpc_apicid > MAX_APICS) {
@@ -877,71 +889,6 @@
 
 
 extern FADT_DESCRIPTOR acpi_fadt;
-
-void __init mp_config_ioapic_for_sci(u32 gsi)
-{
-#ifdef CONFIG_ACPI_INTERPRETER
-	int ioapic;
-	int ioapic_pin;
-	struct acpi_table_madt *madt;
-	struct acpi_table_int_src_ovr *entry = NULL;
-	acpi_interrupt_flags flags;
-	void *madt_end;
-	acpi_status status;
-
-	/*
-	 * Ensure that if there is an interrupt source override entry
-	 * for the ACPI SCI, we leave it as is. Unfortunately this involves
-	 * walking the MADT again.
-	 */
-	status = acpi_get_firmware_table("APIC", 1, ACPI_LOGICAL_ADDRESSING,
-		(struct acpi_table_header **) &madt);
-	if (ACPI_SUCCESS(status)) {
-		madt_end = (void *) (unsigned long)madt + madt->header.length;
-
-		entry = (struct acpi_table_int_src_ovr *)
-                ((unsigned long) madt + sizeof(struct acpi_table_madt));
-
-		while ((void *) entry < madt_end) {
-                	if (entry->header.type == ACPI_MADT_INT_SRC_OVR &&
-			    acpi_fadt.sci_int == entry->bus_irq)
-				goto found;
-			
-                	entry = (struct acpi_table_int_src_ovr *)
-                	        ((unsigned long) entry + entry->header.length);
-        	}
-	}
-	/*
-	 * Although the ACPI spec says that the SCI should be level/low
-	 * don't reprogram it unless there is an explicit MADT OVR entry
-	 * instructing us to do so -- otherwise we break Tyan boards which
-	 * have the SCI wired edge/high but no MADT OVR.
-	 */
-	return;
-
-found:
-	/*
-	 * See the note at the end of ACPI 2.0b section
-	 * 5.2.10.8 for what this is about.
-	 */
-	flags = entry->flags;
-	acpi_fadt.sci_int = entry->global_irq;
-	gsi = entry->global_irq;
-
-	ioapic = mp_find_ioapic(gsi);
-
-	ioapic_pin = gsi - mp_ioapic_routing[ioapic].gsi_start;
-
-	/*
-	 * MPS INTI flags:
-	 *  trigger: 0=default, 1=edge, 3=level
-	 *  polarity: 0=default, 1=high, 3=low
-	 * Per ACPI spec, default for SCI means level/low.
-	 */
-	io_apic_set_pci_routing(ioapic, ioapic_pin, gsi, 
-		(flags.trigger == 1 ? 0 : 1), (flags.polarity == 1 ? 0 : 1));
-#endif
-}
 
 #ifdef CONFIG_ACPI_PCI
 
diff -Nru a/arch/x86_64/kernel/setup.c b/arch/x86_64/kernel/setup.c
--- a/arch/x86_64/kernel/setup.c	Tue Mar 23 04:57:53 2004
+++ b/arch/x86_64/kernel/setup.c	Tue Mar 23 04:57:53 2004
@@ -68,6 +68,7 @@
 
 #ifdef	CONFIG_ACPI_BOOT
 extern int __initdata acpi_ht;
+extern acpi_interrupt_flags	acpi_sci_flags;
 /* int __initdata acpi_force = 0; */
 #endif
 
@@ -201,7 +202,18 @@
 	for (;;) {
 		if (c != ' ') 
 			goto next_char; 
- 
+
+#ifdef  CONFIG_SMP
+		/*
+		 * If the BIOS enumerates physical processors before logical,
+		 * maxcpus=N at enumeration-time can be used to disable HT.
+		 */
+		else if (!memcmp(from, "maxcpus=", 8)) {
+			extern unsigned int maxcpus;
+
+			maxcpus = simple_strtoul(from + 8, NULL, 0);
+		}
+#endif
 #ifdef CONFIG_ACPI_BOOT
 		/* "acpi=off" disables both ACPI table parsing and interpreter init */
 		if (!memcmp(from, "acpi=off", 8))
@@ -218,6 +230,17 @@
 		if (!memcmp(from, "acpi=ht", 7)) { 
 			acpi_ht = 1; 
 		}
+                else if (!memcmp(from, "pci=noacpi", 10)) 
+                        acpi_noirq_set();
+
+		else if (!memcmp(from, "acpi_sci=edge", 13))
+			acpi_sci_flags.trigger =  1;
+		else if (!memcmp(from, "acpi_sci=level", 14))
+			acpi_sci_flags.trigger = 3;
+		else if (!memcmp(from, "acpi_sci=high", 13))
+			acpi_sci_flags.polarity = 1;
+		else if (!memcmp(from, "acpi_sci=low", 12))
+			acpi_sci_flags.polarity = 3;
 
 		/* acpi=strict disables out-of-spec workarounds */
 		else if (!memcmp(from, "acpi=strict", 11)) {
diff -Nru a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
--- a/drivers/acpi/Kconfig	Tue Mar 23 04:57:53 2004
+++ b/drivers/acpi/Kconfig	Tue Mar 23 04:57:53 2004
@@ -255,6 +255,7 @@
 	bool "Power Management Timer Support"
 	depends on X86 && ACPI
 	depends on ACPI_BOOT && EXPERIMENTAL
+	depends on !X86_64
 	default n
 	help
 	  The Power Management Timer is available on all ACPI-capable,
diff -Nru a/drivers/acpi/bus.c b/drivers/acpi/bus.c
--- a/drivers/acpi/bus.c	Tue Mar 23 04:57:53 2004
+++ b/drivers/acpi/bus.c	Tue Mar 23 04:57:53 2004
@@ -39,7 +39,9 @@
 #define _COMPONENT		ACPI_BUS_COMPONENT
 ACPI_MODULE_NAME		("acpi_bus")
 
-extern void __init acpi_pic_sci_set_trigger(unsigned int irq);
+#ifdef	CONFIG_X86
+extern void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger);
+#endif
 
 FADT_DESCRIPTOR			acpi_fadt;
 struct acpi_device		*acpi_root;
@@ -611,11 +613,18 @@
 	}
 
 #ifdef CONFIG_X86
-	/* Ensure the SCI is set to level-triggered, active-low */
-	if (acpi_ioapic)
-		mp_config_ioapic_for_sci(acpi_fadt.sci_int);
-	else
-		acpi_pic_sci_set_trigger(acpi_fadt.sci_int);
+	if (!acpi_ioapic) {
+		extern acpi_interrupt_flags acpi_sci_flags;
+		/* Set PIC-mode SCI trigger type */
+		acpi_pic_sci_set_trigger(acpi_fadt.sci_int, acpi_sci_flags.trigger);
+	} else {
+		extern int acpi_sci_override_gsi;
+		/*
+		 * now that acpi_fadt is initialized,
+		 * update it with result from INT_SRC_OVR parsing
+		 */
+		acpi_fadt.sci_int = acpi_sci_override_gsi;
+	}
 #endif
 
 	status = acpi_enable_subsystem(ACPI_FULL_INITIALIZATION);
@@ -704,29 +713,14 @@
 			pm_active = 1;
 		else {
 			printk(KERN_INFO PREFIX "APM is already active, exiting\n");
-			acpi_disabled = 1;
+			disable_acpi();
 			result = -ENODEV;
 		}
 #endif
 	} else
-		acpi_disabled = 1;
+		disable_acpi();
 
 	return_VALUE(result);
 }
 
-
-static int __init acpi_setup(char *str)
-{
-	while (str && *str) {
-		if (strncmp(str, "off", 3) == 0)
-			acpi_disabled = 1;
-		str = strchr(str, ',');
-		if (str)
-			str += strspn(str, ", \t");
-	}
-	return 1;
-}
-
 subsys_initcall(acpi_init);
-
-__setup("acpi=", acpi_setup);
diff -Nru a/drivers/acpi/numa.c b/drivers/acpi/numa.c
--- a/drivers/acpi/numa.c	Tue Mar 23 04:57:53 2004
+++ b/drivers/acpi/numa.c	Tue Mar 23 04:57:53 2004
@@ -32,12 +32,19 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acmacros.h>
 
+#define ACPI_NUMA	0x80000000
+#define _COMPONENT	ACPI_NUMA
+	ACPI_MODULE_NAME ("numa")
+
 extern int __init acpi_table_parse_madt_family (enum acpi_table_id id, unsigned long madt_size, int entry_id, acpi_madt_entry_handler handler, unsigned int max_entries);
 
 void __init
 acpi_table_print_srat_entry (
 	acpi_table_entry_header	*header)
 {
+
+	ACPI_FUNCTION_NAME ("acpi_table_print_srat_entry");
+
 	if (!header)
 		return;
 
@@ -47,7 +54,7 @@
 	{
 		struct acpi_table_processor_affinity *p =
 			(struct acpi_table_processor_affinity*) header;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO "SRAT Processor (id[0x%02x] eid[0x%02x]) in proximity domain %d %s\n",
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "SRAT Processor (id[0x%02x] eid[0x%02x]) in proximity domain %d %s\n",
 		       p->apic_id, p->lsapic_eid, p->proximity_domain,
 		       p->flags.enabled?"enabled":"disabled"));
 	}
@@ -57,7 +64,7 @@
 	{
 		struct acpi_table_memory_affinity *p =
 			(struct acpi_table_memory_affinity*) header;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO "SRAT Memory (0x%08x%08x length 0x%08x%08x type 0x%x) in proximity domain %d %s%s\n",
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "SRAT Memory (0x%08x%08x length 0x%08x%08x type 0x%x) in proximity domain %d %s%s\n",
 		       p->base_addr_hi, p->base_addr_lo, p->length_hi, p->length_lo,
 		       p->memory_type, p->proximity_domain,
 		       p->flags.enabled ? "enabled" : "disabled",
diff -Nru a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
--- a/drivers/acpi/pci_irq.c	Tue Mar 23 04:57:53 2004
+++ b/drivers/acpi/pci_irq.c	Tue Mar 23 04:57:53 2004
@@ -273,6 +273,10 @@
 	return_VALUE(entry->irq);
 }
 
+/*
+ * current thinking is that acpi_pci_irq_derive() adds no value
+ * and should be deleted, so warn if it actually does something.
+ */
 
 static int
 acpi_pci_irq_derive (
@@ -303,7 +307,8 @@
 		return_VALUE(0);
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derived IRQ %d\n", irq));
+	ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Derive IRQ %d for device %s from %s\n",
+		irq, pci_name(dev), pci_name(bridge)));
 
 	return_VALUE(irq);
 }
@@ -338,6 +343,13 @@
 	 * values override any BIOS-assigned IRQs set during boot.
 	 */
  	irq = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin);
+
+	/*
+	 * Check if the device has an IRQ,
+	 * Hotplug devices may get IRQs by scanning
+	 */
+	if (!irq && dev->irq)
+		irq = dev->irq;
  
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
diff -Nru a/drivers/acpi/processor.c b/drivers/acpi/processor.c
--- a/drivers/acpi/processor.c	Tue Mar 23 04:57:53 2004
+++ b/drivers/acpi/processor.c	Tue Mar 23 04:57:53 2004
@@ -67,8 +67,6 @@
 #define C3_OVERHEAD			4	/* 1us (3.579 ticks per us) */
 
 
-const u32 POWER_OF_2[] = {1,2,4,8,16,32,64};
-
 #define ACPI_PROCESSOR_LIMIT_USER	0
 #define ACPI_PROCESSOR_LIMIT_THERMAL	1
 
@@ -1489,7 +1487,7 @@
 		return_VALUE(0);
 	}
 
-	pr->throttling.state_count = POWER_OF_2[acpi_fadt.duty_width];
+	pr->throttling.state_count = 1 << acpi_fadt.duty_width;
 
 	/*
 	 * Compute state values. Note that throttling displays a linear power/
diff -Nru a/drivers/acpi/toshiba_acpi.c b/drivers/acpi/toshiba_acpi.c
--- a/drivers/acpi/toshiba_acpi.c	Tue Mar 23 04:57:53 2004
+++ b/drivers/acpi/toshiba_acpi.c	Tue Mar 23 04:57:53 2004
@@ -33,7 +33,7 @@
  *
  */
 
-#define TOSHIBA_ACPI_VERSION	"0.17"
+#define TOSHIBA_ACPI_VERSION	"0.18"
 #define PROC_INTERFACE_VERSION	1
 
 #include <linux/kernel.h>
@@ -41,6 +41,7 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/proc_fs.h>
+#include <asm/uaccess.h>
 
 #include <acpi/acpi_drivers.h>
 
@@ -105,24 +106,6 @@
 	*word = (*word & ~mask) | (mask * value);
 }
 
-/* an sscanf that takes explicit string length */
-static int
-snscanf(const char* str, int n, const char* format, ...)
-{
-	va_list args;
-	int result;
-	char* str2 = kmalloc(n + 1, GFP_KERNEL);
-	if (str2 == 0) return 0;
-	/* NOTE: don't even _think_ about replacing this with strlcpy */
-	strncpy(str2, str, n);
-	str2[n] = 0;
-	va_start(args, format);
-	result = vsscanf(str2, format, args);
-	va_end(args);
-	kfree(str2);
-	return result;
-}
-
 /* acpi interface wrappers
  */
 
@@ -269,10 +252,26 @@
 }
 
 static int
-dispatch_write(struct file* file, const char* buffer, unsigned long count,
-	ProcItem* item)
+dispatch_write(struct file* file, __user const char* buffer,
+	unsigned long count, ProcItem* item)
 {
-	return item->write_func(buffer, count);
+	int result;
+	char* tmp_buffer;
+
+	/* Arg buffer points to userspace memory, which can't be accessed
+	 * directly.  Since we're making a copy, zero-terminate the
+	 * destination so that sscanf can be used on it safely.
+	 */
+	tmp_buffer = kmalloc(count + 1, GFP_KERNEL);
+	if (copy_from_user(tmp_buffer, buffer, count)) {
+		result = -EFAULT;
+	}
+	else {
+		tmp_buffer[count] = 0;
+		result = item->write_func(tmp_buffer, count);
+	}
+	kfree(tmp_buffer);
+	return result;
 }
 
 static char*
@@ -300,7 +299,7 @@
 	int value;
 	u32 hci_result;
 
-	if (snscanf(buffer, count, " brightness : %i", &value) == 1 &&
+	if (sscanf(buffer, " brightness : %i", &value) == 1 &&
 			value >= 0 && value < HCI_LCD_BRIGHTNESS_LEVELS) {
 		value = value << HCI_LCD_BRIGHTNESS_SHIFT;
 		hci_write1(HCI_LCD_BRIGHTNESS, value, &hci_result);
@@ -350,11 +349,11 @@
 	 *  NOTE: to keep scanning simple, invalid fields are ignored
 	 */
 	while (remain) {
-		if (snscanf(buffer, remain, " lcd_out : %i", &value) == 1)
+		if (sscanf(buffer, " lcd_out : %i", &value) == 1)
 			lcd_out = value & 1;
-		else if (snscanf(buffer, remain, " crt_out : %i", &value) == 1)
+		else if (sscanf(buffer, " crt_out : %i", &value) == 1)
 			crt_out = value & 1;
-		else if (snscanf(buffer, remain, " tv_out : %i", &value) == 1)
+		else if (sscanf(buffer, " tv_out : %i", &value) == 1)
 			tv_out = value & 1;
 		/* advance to one character past the next ; */
 		do {
@@ -407,7 +406,7 @@
 	int value;
 	u32 hci_result;
 
-	if (snscanf(buffer, count, " force_on : %i", &value) == 1 &&
+	if (sscanf(buffer, " force_on : %i", &value) == 1 &&
 			value >= 0 && value <= 1) {
 		hci_write1(HCI_FAN, value, &hci_result);
 		if (hci_result != HCI_SUCCESS)
@@ -458,7 +457,7 @@
 {
 	int value;
 
-	if (snscanf(buffer, count, " hotkey_ready : %i", &value) == 1 &&
+	if (sscanf(buffer, " hotkey_ready : %i", &value) == 1 &&
 			value == 0) {
 		key_event_valid = 0;
 	} else {
diff -Nru a/drivers/char/sonypi.h b/drivers/char/sonypi.h
--- a/drivers/char/sonypi.h	Tue Mar 23 04:57:53 2004
+++ b/drivers/char/sonypi.h	Tue Mar 23 04:57:53 2004
@@ -396,7 +396,6 @@
 }
 
 #ifdef CONFIG_ACPI
-extern int acpi_disabled;
 #define SONYPI_ACPI_ACTIVE (!acpi_disabled)
 #else
 #define SONYPI_ACPI_ACTIVE 0
diff -Nru a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
--- a/include/acpi/acpi_bus.h	Tue Mar 23 04:57:53 2004
+++ b/include/acpi/acpi_bus.h	Tue Mar 23 04:57:53 2004
@@ -32,8 +32,6 @@
 
 #define PREFIX			"ACPI: "
 
-extern int			acpi_disabled;
-
 /* TBD: Make dynamic */
 #define ACPI_MAX_HANDLES	10
 struct acpi_handle_list {
diff -Nru a/include/asm-i386/acpi.h b/include/asm-i386/acpi.h
--- a/include/asm-i386/acpi.h	Tue Mar 23 04:57:53 2004
+++ b/include/asm-i386/acpi.h	Tue Mar 23 04:57:53 2004
@@ -116,13 +116,17 @@
 extern int acpi_ioapic;
 extern int acpi_noirq;
 extern int acpi_strict;
+extern int acpi_disabled;
+extern int acpi_ht;
+static inline void disable_acpi(void) { acpi_disabled = 1; acpi_ht = 0; }
 
 /* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
 #define FIX_ACPI_PAGES 4
 
+extern int acpi_gsi_to_irq(u32 gsi, unsigned int *irq);
 #ifdef CONFIG_X86_IO_APIC
 extern int skip_ioapic_setup;
-extern int acpi_irq_to_vector(u32 irq);
+extern int acpi_irq_to_vector(u32 irq);	/* deprecated in favor of acpi_gsi_to_irq */
 
 static inline void disable_ioapic_setup(void)
 {
diff -Nru a/include/asm-i386/mpspec.h b/include/asm-i386/mpspec.h
--- a/include/asm-i386/mpspec.h	Tue Mar 23 04:57:53 2004
+++ b/include/asm-i386/mpspec.h	Tue Mar 23 04:57:53 2004
@@ -30,17 +30,10 @@
 #ifdef CONFIG_ACPI_BOOT
 extern void mp_register_lapic (u8 id, u8 enabled);
 extern void mp_register_lapic_address (u64 address);
-extern void mp_register_ioapic (u8 id, u32 address, u32 irq_base);
-extern void mp_override_legacy_irq (u8 bus_irq, u8 polarity, u8 trigger, u32 global_irq);
+extern void mp_register_ioapic (u8 id, u32 address, u32 gsi_base);
+extern void mp_override_legacy_irq (u8 bus_irq, u8 polarity, u8 trigger, u32 gsi);
 extern void mp_config_acpi_legacy_irqs (void);
 extern void mp_parse_prt (void);
-
-#ifdef CONFIG_X86_IO_APIC
-extern void mp_config_ioapic_for_sci(int irq);
-#else
-static inline void mp_config_ioapic_for_sci(int irq)
-{ }
-#endif
 #endif /*CONFIG_ACPI_BOOT*/
 
 #define PHYSID_ARRAY_SIZE	BITS_TO_LONGS(MAX_APICS)
diff -Nru a/include/asm-ia64/acpi.h b/include/asm-ia64/acpi.h
--- a/include/asm-ia64/acpi.h	Tue Mar 23 04:57:53 2004
+++ b/include/asm-ia64/acpi.h	Tue Mar 23 04:57:53 2004
@@ -88,7 +88,9 @@
 #define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq)				\
 	((Acq) = ia64_acpi_release_global_lock((unsigned int *) GLptr))
 
+#define acpi_disabled 0	/* ACPI always enabled on IA64 */
 #define acpi_strict 1	/* no ACPI spec workarounds on IA64 */
+static inline void disable_acpi(void) { }
 
 const char *acpi_get_sysname (void);
 int acpi_request_vector (u32 int_type);
diff -Nru a/include/asm-x86_64/acpi.h b/include/asm-x86_64/acpi.h
--- a/include/asm-x86_64/acpi.h	Tue Mar 23 04:57:53 2004
+++ b/include/asm-x86_64/acpi.h	Tue Mar 23 04:57:53 2004
@@ -105,6 +105,9 @@
 extern int acpi_ioapic;
 extern int acpi_noirq;
 extern int acpi_strict;
+extern int acpi_disabled;
+extern int acpi_ht;
+static inline void disable_acpi(void) { acpi_disabled = 1; acpi_ht = 0; }
 
 /* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
 #define FIX_ACPI_PAGES 4
diff -Nru a/include/asm-x86_64/mpspec.h b/include/asm-x86_64/mpspec.h
--- a/include/asm-x86_64/mpspec.h	Tue Mar 23 04:57:53 2004
+++ b/include/asm-x86_64/mpspec.h	Tue Mar 23 04:57:53 2004
@@ -193,8 +193,6 @@
 #endif /*CONFIG_X86_IO_APIC*/
 #endif
 
-extern void mp_config_ioapic_for_sci(u32 gsi);
-
 extern int using_apic_timer;
 
 #define PHYSID_ARRAY_SIZE	BITS_TO_LONGS(MAX_APICS)
