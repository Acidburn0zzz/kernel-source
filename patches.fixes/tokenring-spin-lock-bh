From netdev-bounce@oss.sgi.com  Wed Apr 28 19:58:59 2004
Return-Path: <netdev-bounce@oss.sgi.com>
Received: from hermes.suse.de (hermes.suse.de [10.0.0.1])
	by wotan.suse.de (Postfix) with ESMTP id 3368A7EE0
	for <okir@wotan.suse.de>; Wed, 28 Apr 2004 19:58:59 +0200 (CEST)
Received: by hermes.suse.de (Postfix)
	id 2C4FA6771A; Wed, 28 Apr 2004 19:58:59 +0200 (CEST)
Received: from scanhost.suse.de (scanhost.suse.de [10.0.0.5])
	by hermes.suse.de (Postfix) with ESMTP id 2461567720
	for <okir@suse.de>; Wed, 28 Apr 2004 19:58:59 +0200 (CEST)
Received: from hermes.suse.de ([10.0.0.1])
 by scanhost.suse.de (scanhost [10.0.0.5]) (amavisd-new, port 10025)
 with ESMTP id 10895-10 for <okir@suse.de>;
 Wed, 28 Apr 2004 19:58:57 +0200 (CEST)
Received: from Cantor.suse.de (ns.suse.de [195.135.220.2])
	(using TLSv1 with cipher EDH-RSA-DES-CBC3-SHA (168/168 bits))
	(No client certificate requested)
	by hermes.suse.de (Postfix) with ESMTP id A19CB6771A
	for <okir@suse.de>; Wed, 28 Apr 2004 19:58:57 +0200 (CEST)
Received: from oss.sgi.com (oss.SGI.COM [192.48.159.27])
	by Cantor.suse.de (Postfix) with ESMTP id 685224FD828
	for <okir@suse.de>; Wed, 28 Apr 2004 19:58:56 +0200 (CEST)
Received: from oss.sgi.com (localhost [127.0.0.1])
	by oss.sgi.com (8.12.10/8.12.9) with ESMTP id i3SHwqKO015190;
	Wed, 28 Apr 2004 10:58:52 -0700
Received: with ECARTIS (v1.0.0; list netdev); Wed, 28 Apr 2004 10:58:43 -0700 (PDT)
Received: from e3.ny.us.ibm.com (e3.ny.us.ibm.com [32.97.182.103])
	by oss.sgi.com (8.12.10/8.12.9) with SMTP id i3SHwTKO015136
	for <netdev@oss.sgi.com>; Wed, 28 Apr 2004 10:58:35 -0700
Received: from northrelay04.pok.ibm.com (northrelay04.pok.ibm.com [9.56.224.206])
	by e3.ny.us.ibm.com (8.12.10/8.12.2) with ESMTP id i3SHvWIm714690;
	Wed, 28 Apr 2004 13:57:34 -0400
Received: from death.nxdomain.ibm.com (d01av02.pok.ibm.com [9.56.224.216])
	by northrelay04.pok.ibm.com (8.12.10/NCO/VER6.6) with ESMTP id i3SHvo6h104116;
	Wed, 28 Apr 2004 13:57:50 -0400
Received: from death.nxdomain.ibm.com (localhost [127.0.0.1])
	by death.nxdomain.ibm.com (8.12.8/8.12.8) with ESMTP id i3SHtXZB020276;
	Wed, 28 Apr 2004 10:55:34 -0700
Received: from death (fubar@localhost)
	by death.nxdomain.ibm.com (8.12.8/8.12.8/Submit) with ESMTP id i3SHtX7V020271;
	Wed, 28 Apr 2004 10:55:33 -0700
Message-Id: <200404281755.i3SHtX7V020271@death.nxdomain.ibm.com>
To: Paul Mackerras <paulus@samba.org>
Cc: linux-tr@linuxtr.net, netdev@oss.sgi.com
Subject: Re: spin_lock_bh() called in irq handler 
In-Reply-To: Message from Paul Mackerras <paulus@samba.org> 
   of "Wed, 28 Apr 2004 17:24:14 +1000." <16527.23582.316697.56419@cargo.ozlabs.ibm.com> 
X-Mailer: MH-E 7.4.3; nmh 1.0.4; GNU Emacs 21.3.1
Date: Wed, 28 Apr 2004 10:55:33 -0700
From: Jay Vosburgh <fubar@us.ibm.com>
X-archive-position: 4960
X-ecartis-version: Ecartis v1.0.0
Sender: netdev-bounce@oss.sgi.com
Errors-To: netdev-bounce@oss.sgi.com
X-original-sender: fubar@us.ibm.com
Precedence: bulk
X-list: netdev
X-Virus-Scanned: by amavisd-new at scanhost.suse.de
X-Spam-Checker-Version: SpamAssassin 2.63 (2004-01-11) on wotan.suse.de
X-Spam-Level: 
X-Spam-Status: No, hits=-4.9 required=5.0 tests=BAYES_00 autolearn=ham 
	version=2.63
Status: RO
Content-Length: 3269
Lines: 119


>I had a look and found that all of the token-ring drivers call
>tr_type_trans() at interrupt level.  That seems perfectly reasonable
>to me.  To fix the bug, it seems to me that there are two options:
>either move the tr_add_rif_info() call elsewhere (but I have no idea
>where) or else use spin_lock_irqsave instead of spin_lock_bh.
>
>Which is the more appropriate fix?

	I'm guessing spin_lock_irqsave; would the following be
appropriate?  I'm not absolutely sure about using spin_(un)lock_irq in
rif_seq_start/stop, but it'd be complicated to deal with the flags in
that case.

	I've built this and given it some basic testing, but not really
hammered on it.  The system doesn't panic when I cat /proc/net/tr_rif,
which is a good sign.

	-J

---
	-Jay Vosburgh, IBM Linux Technology Center, fubar@us.ibm.com


diff -urN linux-2.6.5-orig/net/802/tr.c linux-2.6.5/net/802/tr.c
--- linux-2.6.5-orig/net/802/tr.c	2004-04-28 10:02:12.000000000 -0700
+++ linux-2.6.5/net/802/tr.c	2004-04-28 10:15:47.000000000 -0700
@@ -250,10 +250,11 @@
 	unsigned int hash;
 	struct rif_cache_s *entry;
 	unsigned char *olddata;
+	unsigned long flags;
 	static const unsigned char mcast_func_addr[] 
 		= {0xC0,0x00,0x00,0x04,0x00,0x00};
 	
-	spin_lock_bh(&rif_lock);
+	spin_lock_irqsave(&rif_lock, flags);
 
 	/*
 	 *	Broadcasts are single route as stated in RFC 1042 
@@ -322,7 +323,7 @@
 	else 
 		slack = 18 - ((ntohs(trh->rcf) & TR_RCF_LEN_MASK)>>8);
 	olddata = skb->data;
-	spin_unlock_bh(&rif_lock);
+	spin_unlock_irqrestore(&rif_lock, flags);
 
 	skb_pull(skb, slack);
 	memmove(skb->data, olddata, sizeof(struct trh_hdr) - slack);
@@ -336,10 +337,11 @@
 static void tr_add_rif_info(struct trh_hdr *trh, struct net_device *dev)
 {
 	unsigned int hash, rii_p = 0;
+	unsigned long flags;
 	struct rif_cache_s *entry;
 
 
-	spin_lock_bh(&rif_lock);
+	spin_lock_irqsave(&rif_lock, flags);
 	
 	/*
 	 *	Firstly see if the entry exists
@@ -377,7 +379,7 @@
 		if(!entry) 
 		{
 			printk(KERN_DEBUG "tr.c: Couldn't malloc rif cache entry !\n");
-			spin_unlock_bh(&rif_lock);
+			spin_unlock_irqrestore(&rif_lock, flags);
 			return;
 		}
 
@@ -419,7 +421,7 @@
 		    }                                         
            	entry->last_used=jiffies;               
 	}
-	spin_unlock_bh(&rif_lock);
+	spin_unlock_irqrestore(&rif_lock, flags);
 }
 
 /*
@@ -429,9 +431,9 @@
 static void rif_check_expire(unsigned long dummy) 
 {
 	int i;
-	unsigned long next_interval = jiffies + sysctl_tr_rif_timeout/2;
+	unsigned long flags, next_interval = jiffies + sysctl_tr_rif_timeout/2;
 
-	spin_lock_bh(&rif_lock);
+	spin_lock_irqsave(&rif_lock, flags);
 	
 	for(i =0; i < RIF_TABLE_SIZE; i++) {
 		struct rif_cache_s *entry, **pentry;
@@ -453,7 +455,7 @@
 		}
 	}
 	
-	spin_unlock_bh(&rif_lock);
+	spin_unlock_irqrestore(&rif_lock, flags);
 
 	mod_timer(&rif_timer, next_interval);
 
@@ -484,7 +486,7 @@
 
 static void *rif_seq_start(struct seq_file *seq, loff_t *pos)
 {
-	spin_lock_bh(&rif_lock);
+	spin_lock_irq(&rif_lock);
 
 	return *pos ? rif_get_idx(*pos - 1) : SEQ_START_TOKEN;
 }
@@ -515,7 +517,7 @@
 
 static void rif_seq_stop(struct seq_file *seq, void *v)
 {
-	spin_unlock_bh(&rif_lock);
+	spin_unlock_irq(&rif_lock);
 }
 
 static int rif_seq_show(struct seq_file *seq, void *v)

