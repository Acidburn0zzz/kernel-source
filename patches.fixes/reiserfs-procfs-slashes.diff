From: Jeff Mahoney <jeffm@suse.com>
Subject: [PATCH] reiserfs: fix handling of device names with /'s in them
SUSE-Bugzilla: 154278

 On systems with block devices containing slashes (virtual dasd, cciss,
 etc), reiserfs will fail to initialize /proc/fs/reiserfs/<dev> due to
 it being interpreted as a subdirectory. The generic block device code
 changes the / to ! for use in the sysfs tree. This patch uses that
 convention.

 Tested by making dm devices use dm/<number> rather than dm-<number>

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

diff -ruNpX dontdiff linux-2.6.16/fs/reiserfs/procfs.c linux-2.6.16.devel/fs/reiserfs/procfs.c
--- linux-2.6.16/fs/reiserfs/procfs.c	2006-04-21 15:18:51.000000000 -0400
+++ linux-2.6.16.devel/fs/reiserfs/procfs.c	2006-04-21 17:29:04.000000000 -0400
@@ -493,9 +493,17 @@ static void add_file(struct super_block 
 
 int reiserfs_proc_info_init(struct super_block *sb)
 {
+	char bdev[BDEVNAME_SIZE];
+	char *s;
+
+	/* Some block devices use /'s */
+	strlcpy(bdev, reiserfs_bdevname(sb), BDEVNAME_SIZE);
+	s = strchr(bdev, '/');
+	if (s)
+		*s = '!';
+
 	spin_lock_init(&__PINFO(sb).lock);
-	REISERFS_SB(sb)->procdir =
-	    proc_mkdir(reiserfs_bdevname(sb), proc_info_root);
+	REISERFS_SB(sb)->procdir = proc_mkdir(bdev, proc_info_root);
 	if (REISERFS_SB(sb)->procdir) {
 		REISERFS_SB(sb)->procdir->owner = THIS_MODULE;
 		REISERFS_SB(sb)->procdir->data = sb;
@@ -509,13 +517,22 @@ int reiserfs_proc_info_init(struct super
 		return 0;
 	}
 	reiserfs_warning(sb, "reiserfs: cannot create /proc/%s/%s",
-			 proc_info_root_name, reiserfs_bdevname(sb));
+			 proc_info_root_name, bdev);
 	return 1;
 }
 
 int reiserfs_proc_info_done(struct super_block *sb)
 {
 	struct proc_dir_entry *de = REISERFS_SB(sb)->procdir;
+	char bdev[BDEVNAME_SIZE];
+	char *s;
+
+	/* Some block devices use /'s */
+	strlcpy(bdev, reiserfs_bdevname(sb), BDEVNAME_SIZE);
+	s = strchr(bdev, '/');
+	if (s)
+		*s = '!';
+
 	if (de) {
 		remove_proc_entry("journal", de);
 		remove_proc_entry("oidmap", de);
@@ -529,7 +546,7 @@ int reiserfs_proc_info_done(struct super
 	__PINFO(sb).exiting = 1;
 	spin_unlock(&__PINFO(sb).lock);
 	if (proc_info_root) {
-		remove_proc_entry(reiserfs_bdevname(sb), proc_info_root);
+		remove_proc_entry(bdev, proc_info_root);
 		REISERFS_SB(sb)->procdir = NULL;
 	}
 	return 0;
