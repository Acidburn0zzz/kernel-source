diff -purN linux-2.6.0-test11/arch/i386/mm/fault.c linux-2.5/arch/i386/mm/fault.c
--- linux-2.6.0-test11/arch/i386/mm/fault.c	2003-11-26 20:42:46.000000000 +0000
+++ linux-2.5/arch/i386/mm/fault.c	2003-12-03 02:41:44.000000000 +0000
@@ -359,7 +359,8 @@ bad_area_nosemaphore:
 			return;
 
 		tsk->thread.cr2 = address;
-		tsk->thread.error_code = error_code;
+		/* Kernel addresses are always protection faults */
+		tsk->thread.error_code = error_code | (address >= TASK_SIZE);
 		tsk->thread.trap_no = 14;
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
diff -purN linux-2.6.0-test11/drivers/block/scsi_ioctl.c linux-2.5/drivers/block/scsi_ioctl.c
--- linux-2.6.0-test11/drivers/block/scsi_ioctl.c	2003-11-26 20:46:03.000000000 +0000
+++ linux-2.5/drivers/block/scsi_ioctl.c	2003-12-11 17:55:17.000000000 +0000
@@ -150,6 +150,7 @@ static int sg_io(request_queue_t *q, str
 	struct request *rq;
 	struct bio *bio;
 	char sense[SCSI_SENSE_BUFFERSIZE];
+	unsigned char cdb[BLK_MAX_CDB];
 	void *buffer;
 
 	if (hdr->interface_id != 'S')
@@ -166,6 +167,9 @@ static int sg_io(request_queue_t *q, str
 	if (hdr->dxfer_len > (q->max_sectors << 9))
 		return -EIO;
 
+	if (copy_from_user(cdb, hdr->cmdp, hdr->cmd_len))
+		return -EFAULT;
+
 	reading = writing = 0;
 	buffer = NULL;
 	bio = NULL;
@@ -216,7 +220,7 @@ static int sg_io(request_queue_t *q, str
 	 * fill in request structure
 	 */
 	rq->cmd_len = hdr->cmd_len;
-	memcpy(rq->cmd, hdr->cmdp, hdr->cmd_len);
+	memcpy(rq->cmd, cdb, hdr->cmd_len);
 	if (sizeof(rq->cmd) != hdr->cmd_len)
 		memset(rq->cmd + hdr->cmd_len, 0, sizeof(rq->cmd) - hdr->cmd_len);
 
diff -purN linux-2.6.0-test11/drivers/i2c/busses/i2c-nforce2.c linux-2.5/drivers/i2c/busses/i2c-nforce2.c
--- linux-2.6.0-test11/drivers/i2c/busses/i2c-nforce2.c	2003-11-26 20:43:09.000000000 +0000
+++ linux-2.5/drivers/i2c/busses/i2c-nforce2.c	2003-11-28 21:49:21.000000000 +0000
@@ -147,7 +147,7 @@ static s32 nforce2_access(struct i2c_ada
 
 		case I2C_SMBUS_BYTE:
 			if (read_write == I2C_SMBUS_WRITE)
-				outb_p(data->byte, NVIDIA_SMB_DATA);
+				outb_p(command, NVIDIA_SMB_CMD);
 			protocol |= NVIDIA_SMB_PRTCL_BYTE;
 			break;
 
diff -purN linux-2.6.0-test11/drivers/ide/ide-cd.c linux-2.5/drivers/ide/ide-cd.c
--- linux-2.6.0-test11/drivers/ide/ide-cd.c	2003-11-26 20:43:50.000000000 +0000
+++ linux-2.5/drivers/ide/ide-cd.c	2003-12-14 00:01:28.000000000 +0000
@@ -799,6 +799,10 @@ static int cdrom_decode_status(ide_drive
 			 * sector...  If we got here the error is not correctable */
 			ide_dump_status (drive, "media error (bad sector)", stat);
 			do_end_request = 1;
+		} else if (sense_key == BLANK_CHECK) {
+			/* Disk appears blank ?? */
+			ide_dump_status (drive, "media error (blank)", stat);
+			do_end_request = 1;
 		} else if ((err & ~ABRT_ERR) != 0) {
 			/* Go to the default handler
 			   for other errors. */
diff -purN linux-2.6.0-test11/drivers/ide/ide-cd.h linux-2.5/drivers/ide/ide-cd.h
--- linux-2.6.0-test11/drivers/ide/ide-cd.h	2003-11-26 20:46:08.000000000 +0000
+++ linux-2.5/drivers/ide/ide-cd.h	2003-12-13 23:58:07.000000000 +0000
@@ -501,6 +501,7 @@ struct cdrom_info {
 #define ILLEGAL_REQUEST         0x05
 #define UNIT_ATTENTION          0x06
 #define DATA_PROTECT            0x07
+#define BLANK_CHECK             0x08
 #define ABORTED_COMMAND         0x0b
 #define MISCOMPARE              0x0e
 
@@ -578,7 +579,7 @@ const char * const sense_key_texts[16] =
 	"Illegal request",
 	"Unit attention",
 	"Data protect",
-	"(reserved)",
+	"Blank check",
 	"(reserved)",
 	"(reserved)",
 	"Aborted command",
diff -purN linux-2.6.0-test11/drivers/md/raid5.c linux-2.5/drivers/md/raid5.c
--- linux-2.6.0-test11/drivers/md/raid5.c	2003-11-26 20:43:24.000000000 +0000
+++ linux-2.5/drivers/md/raid5.c	2003-12-15 13:12:55.000000000 +0000
@@ -40,6 +40,16 @@
 
 #define stripe_hash(conf, sect)	((conf)->stripe_hashtbl[((sect) >> STRIPE_SHIFT) & HASH_MASK])
 
+/* bio's attached to a stripe+device for I/O are linked together in bi_sector
+ * order without overlap.  There may be several bio's per stripe+device, and
+ * a bio could span several devices.
+ * When walking this list for a particular stripe+device, we must never proceed
+ * beyond a bio that extends past this device, as the next bio might no longer
+ * be valid.
+ * This macro is used to determine the 'next' bio in the list, given the sector
+ * of the current stripe+device
+ */
+#define r5_next_bio(bio, sect) ( ( bio->bi_sector + (bio->bi_size>>9) < sect + STRIPE_SECTORS) ? bio->bi_next : NULL)
 /*
  * The following can be used to debug the driver
  */
@@ -613,7 +623,7 @@ static void copy_data(int frombio, struc
 	int i;
 
 	for (;bio && bio->bi_sector < sector+STRIPE_SECTORS;
-		bio = bio->bi_next) {
+	      bio = r5_next_bio(bio, sector) ) {
 		int page_offset;
 		if (bio->bi_sector >= sector)
 			page_offset = (signed)(bio->bi_sector - sector) * 512;
@@ -738,7 +748,11 @@ static void compute_parity(struct stripe
 	for (i = disks; i--;)
 		if (sh->dev[i].written) {
 			sector_t sector = sh->dev[i].sector;
-			copy_data(1, sh->dev[i].written, sh->dev[i].page, sector);
+			struct bio *wbi = sh->dev[i].written;
+			while (wbi && wbi->bi_sector < sector + STRIPE_SECTORS) {
+				copy_data(1, wbi, sh->dev[i].page, sector);
+				wbi = r5_next_bio(wbi, sector);
+			}
 
 			set_bit(R5_LOCKED, &sh->dev[i].flags);
 			set_bit(R5_UPTODATE, &sh->dev[i].flags);
@@ -791,8 +805,10 @@ static void add_stripe_bio (struct strip
 		bip = &sh->dev[dd_idx].towrite;
 	else
 		bip = &sh->dev[dd_idx].toread;
-	while (*bip && (*bip)->bi_sector < bi->bi_sector)
+	while (*bip && (*bip)->bi_sector < bi->bi_sector) {
+		BUG_ON((*bip)->bi_sector + ((*bip)->bi_size >> 9) > bi->bi_sector);
 		bip = & (*bip)->bi_next;
+	}
 /* FIXME do I need to worry about overlapping bion */
 	if (*bip && bi->bi_next && (*bip) != bi->bi_next)
 		BUG();
@@ -813,7 +829,7 @@ static void add_stripe_bio (struct strip
 		for (bi=sh->dev[dd_idx].towrite;
 		     sector < sh->dev[dd_idx].sector + STRIPE_SECTORS &&
 			     bi && bi->bi_sector <= sector;
-		     bi = bi->bi_next) {
+		     bi = r5_next_bio(bi, sh->dev[dd_idx].sector)) {
 			if (bi->bi_sector + (bi->bi_size>>9) >= sector)
 				sector = bi->bi_sector + (bi->bi_size>>9);
 		}
@@ -883,7 +899,7 @@ static void handle_stripe(struct stripe_
 			spin_unlock_irq(&conf->device_lock);
 			while (rbi && rbi->bi_sector < dev->sector + STRIPE_SECTORS) {
 				copy_data(0, rbi, dev->page, dev->sector);
-				rbi2 = rbi->bi_next;
+				rbi2 = r5_next_bio(rbi, dev->sector);
 				spin_lock_irq(&conf->device_lock);
 				if (--rbi->bi_phys_segments == 0) {
 					rbi->bi_next = return_bi;
@@ -928,7 +944,7 @@ static void handle_stripe(struct stripe_
 			if (bi) to_write--;
 
 			while (bi && bi->bi_sector < sh->dev[i].sector + STRIPE_SECTORS){
-				struct bio *nextbi = bi->bi_next;
+				struct bio *nextbi = r5_next_bio(bi, sh->dev[i].sector);
 				clear_bit(BIO_UPTODATE, &bi->bi_flags);
 				if (--bi->bi_phys_segments == 0) {
 					md_write_end(conf->mddev);
@@ -941,7 +957,7 @@ static void handle_stripe(struct stripe_
 			bi = sh->dev[i].written;
 			sh->dev[i].written = NULL;
 			while (bi && bi->bi_sector < sh->dev[i].sector + STRIPE_SECTORS) {
-				struct bio *bi2 = bi->bi_next;
+				struct bio *bi2 = r5_next_bio(bi, sh->dev[i].sector);
 				clear_bit(BIO_UPTODATE, &bi->bi_flags);
 				if (--bi->bi_phys_segments == 0) {
 					md_write_end(conf->mddev);
@@ -957,7 +973,7 @@ static void handle_stripe(struct stripe_
 				sh->dev[i].toread = NULL;
 				if (bi) to_read--;
 				while (bi && bi->bi_sector < sh->dev[i].sector + STRIPE_SECTORS){
-					struct bio *nextbi = bi->bi_next;
+					struct bio *nextbi = r5_next_bio(bi, sh->dev[i].sector);
 					clear_bit(BIO_UPTODATE, &bi->bi_flags);
 					if (--bi->bi_phys_segments == 0) {
 						bi->bi_next = return_bi;
@@ -1000,7 +1016,7 @@ static void handle_stripe(struct stripe_
 			    wbi = dev->written;
 			    dev->written = NULL;
 			    while (wbi && wbi->bi_sector < dev->sector + STRIPE_SECTORS) {
-				    wbi2 = wbi->bi_next;
+				    wbi2 = r5_next_bio(wbi, dev->sector);
 				    if (--wbi->bi_phys_segments == 0) {
 					    md_write_end(conf->mddev);
 					    wbi->bi_next = return_bi;
diff -purN linux-2.6.0-test11/drivers/net/pci-skeleton.c linux-2.5/drivers/net/pci-skeleton.c
--- linux-2.6.0-test11/drivers/net/pci-skeleton.c	2003-11-26 20:42:51.000000000 +0000
+++ linux-2.5/drivers/net/pci-skeleton.c	2003-12-05 13:22:32.000000000 +0000
@@ -864,13 +864,6 @@ static void __devexit netdrv_remove_one 
 
 	pci_release_regions (pdev);
 
-#ifndef NETDRV_NDEBUG
-	/* poison memory before freeing */
-	memset (dev, 0xBC,
-		sizeof (struct net_device) +
-		sizeof (struct netdrv_private));
-#endif /* NETDRV_NDEBUG */
-
 	free_netdev (dev);
 
 	pci_set_drvdata (pdev, NULL);
diff -purN linux-2.6.0-test11/drivers/net/pcnet32.c linux-2.5/drivers/net/pcnet32.c
--- linux-2.6.0-test11/drivers/net/pcnet32.c	2003-11-26 20:43:27.000000000 +0000
+++ linux-2.5/drivers/net/pcnet32.c	2003-12-05 13:22:32.000000000 +0000
@@ -1766,8 +1766,6 @@ static void __exit pcnet32_cleanup_modul
 	next_dev = lp->next;
 	unregister_netdev(pcnet32_dev);
 	release_region(pcnet32_dev->base_addr, PCNET32_TOTAL_SIZE);
-	if (lp->pci_dev)
-	    pci_unregister_driver(&pcnet32_driver);
 	pci_free_consistent(lp->pci_dev, sizeof(*lp), lp, lp->dma_addr);
 	free_netdev(pcnet32_dev);
 	pcnet32_dev = next_dev;
diff -purN linux-2.6.0-test11/drivers/net/r8169.c linux-2.5/drivers/net/r8169.c
--- linux-2.6.0-test11/drivers/net/r8169.c	2003-11-26 20:44:12.000000000 +0000
+++ linux-2.5/drivers/net/r8169.c	2003-12-05 13:22:32.000000000 +0000
@@ -642,10 +642,6 @@ rtl8169_remove_one(struct pci_dev *pdev)
 	iounmap(tp->mmio_addr);
 	pci_release_regions(pdev);
 
-	// poison memory before freeing 
-	memset(dev, 0xBC,
-	       sizeof (struct net_device) + sizeof (struct rtl8169_private));
-
 	pci_disable_device(pdev);
 	free_netdev(dev);
 	pci_set_drvdata(pdev, NULL);
diff -purN linux-2.6.0-test11/drivers/net/sis190.c linux-2.5/drivers/net/sis190.c
--- linux-2.6.0-test11/drivers/net/sis190.c	2003-11-26 20:46:10.000000000 +0000
+++ linux-2.5/drivers/net/sis190.c	2003-12-05 13:22:32.000000000 +0000
@@ -703,10 +703,6 @@ SiS190_remove_one(struct pci_dev *pdev)
 	iounmap(tp->mmio_addr);
 	pci_release_regions(pdev);
 
-	// poison memory before freeing 
-	memset(dev, 0xBC,
-	       sizeof (struct net_device) + sizeof (struct sis190_private));
-
 	free_netdev(dev);
 	pci_set_drvdata(pdev, NULL);
 }
diff -purN linux-2.6.0-test11/drivers/net/wireless/airo.c linux-2.5/drivers/net/wireless/airo.c
--- linux-2.6.0-test11/drivers/net/wireless/airo.c	2003-11-26 20:42:59.000000000 +0000
+++ linux-2.5/drivers/net/wireless/airo.c	2003-12-07 13:22:52.000000000 +0000
@@ -2466,11 +2466,8 @@ static irqreturn_t airo_interrupt ( int 
 			OUT4500( apriv, EVACK, EV_MIC );
 #ifdef MICSUPPORT
 			if (test_bit(FLAG_MIC_CAPABLE, &apriv->flags)) {
-				if (down_trylock(&apriv->sem) != 0) {
-					set_bit(JOB_MIC, &apriv->flags);
-					wake_up_interruptible(&apriv->thr_wait);
-				} else
-					micinit (apriv);
+				set_bit(JOB_MIC, &apriv->flags);
+				wake_up_interruptible(&apriv->thr_wait);
 			}
 #endif
 		}
diff -purN linux-2.6.0-test11/drivers/scsi/ide-scsi.c linux-2.5/drivers/scsi/ide-scsi.c
--- linux-2.6.0-test11/drivers/scsi/ide-scsi.c	2003-11-26 20:44:34.000000000 +0000
+++ linux-2.5/drivers/scsi/ide-scsi.c	2003-12-03 03:03:55.000000000 +0000
@@ -517,6 +517,7 @@ static ide_startstop_t idescsi_issue_pc 
 	pc->current_position=pc->buffer;
 	bcount.all = IDE_MIN(pc->request_transfer, 63 * 1024);		/* Request to transfer the entire buffer at once */
 
+	feature.all = 0;
 	if (drive->using_dma && rq->bio) {
 		if (test_bit(PC_WRITING, &pc->flags))
 			feature.b.dma = !HWIF(drive)->ide_dma_write(drive);
diff -purN linux-2.6.0-test11/drivers/scsi/libata-core.c linux-2.5/drivers/scsi/libata-core.c
--- linux-2.6.0-test11/drivers/scsi/libata-core.c	2003-11-26 20:42:46.000000000 +0000
+++ linux-2.5/drivers/scsi/libata-core.c	2003-12-05 13:46:54.000000000 +0000
@@ -3224,8 +3224,6 @@ void ata_pci_remove_one (struct pci_dev 
 		scsi_host_put(ap->host); /* FIXME: check return val */
 	}
 
-	kfree(host_set);
-
 	pci_release_regions(pdev);
 
 	for (i = 0; i < host_set->n_ports; i++) {
@@ -3242,6 +3240,7 @@ void ata_pci_remove_one (struct pci_dev 
 		}
 	}
 
+	kfree(host_set);
 	pci_disable_device(pdev);
 	pci_set_drvdata(pdev, NULL);
 }
diff -purN linux-2.6.0-test11/drivers/usb/core/devio.c linux-2.5/drivers/usb/core/devio.c
--- linux-2.6.0-test11/drivers/usb/core/devio.c	2003-11-26 20:44:09.000000000 +0000
+++ linux-2.5/drivers/usb/core/devio.c	2003-12-05 22:42:24.000000000 +0000
@@ -261,7 +261,6 @@ static void async_completed(struct urb *
         spin_lock(&ps->lock);
         list_move_tail(&as->asynclist, &ps->async_completed);
         spin_unlock(&ps->lock);
-        wake_up(&ps->wait);
 	if (as->signr) {
 		sinfo.si_signo = as->signr;
 		sinfo.si_errno = as->urb->status;
@@ -269,6 +268,7 @@ static void async_completed(struct urb *
 		sinfo.si_addr = (void *)as->userurb;
 		send_sig_info(as->signr, &sinfo, as->task);
 	}
+        wake_up(&ps->wait);
 }
 
 static void destroy_async (struct dev_state *ps, struct list_head *list)
diff -purN linux-2.6.0-test11/drivers/usb/core/hub.c linux-2.5/drivers/usb/core/hub.c
--- linux-2.6.0-test11/drivers/usb/core/hub.c	2003-11-26 20:43:56.000000000 +0000
+++ linux-2.5/drivers/usb/core/hub.c	2003-11-30 07:44:40.000000000 +0000
@@ -692,6 +692,9 @@ static int hub_port_status(struct usb_de
 	struct usb_hub *hub = usb_get_intfdata(dev->actconfig->interface[0]);
 	int ret;
 
+	if (!hub)
+		return -ENODEV;
+
 	ret = get_port_status(dev, port + 1, &hub->status->port);
 	if (ret < 0)
 		dev_err (hubdev (dev),
@@ -926,7 +929,6 @@ static void hub_port_connect_change(stru
 			break;
 		}
 
-		hub->children[port] = dev;
 		dev->state = USB_STATE_POWERED;
 
 		/* Reset the device, and detect its speed */
@@ -979,8 +981,10 @@ static void hub_port_connect_change(stru
 		dev->dev.parent = dev->parent->dev.parent->parent;
 
 		/* Run it through the hoops (find a driver, etc) */
-		if (!usb_new_device(dev, &hub->dev))
+		if (!usb_new_device(dev, &hub->dev)) {
+			hub->children[port] = dev;
 			goto done;
+		}
 
 		/* Free the configuration if there was an error */
 		usb_put_dev(dev);
@@ -989,7 +993,6 @@ static void hub_port_connect_change(stru
 		delay = HUB_LONG_RESET_TIME;
 	}
 
-	hub->children[port] = NULL;
 	hub_port_disable(hub, port);
 done:
 	up(&usb_address0_sem);
@@ -1342,6 +1345,7 @@ int usb_physical_reset_device(struct usb
 			dev->devpath, ret);
 		return ret;
 	}
+	dev->state = USB_STATE_CONFIGURED;
 
 	for (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {
 		struct usb_interface *intf = dev->actconfig->interface[i];
diff -purN linux-2.6.0-test11/drivers/usb/core/usb.c linux-2.5/drivers/usb/core/usb.c
--- linux-2.6.0-test11/drivers/usb/core/usb.c	2003-11-26 20:44:12.000000000 +0000
+++ linux-2.5/drivers/usb/core/usb.c	2003-11-14 08:18:31.000000000 +0000
@@ -1120,6 +1120,7 @@ int usb_new_device(struct usb_device *de
 	if (err) {
 		dev_err(&dev->dev, "can't set config #%d, error %d\n",
 			dev->config[0].desc.bConfigurationValue, err);
+		device_del(&dev->dev);
 		goto fail;
 	}
 
diff -purN linux-2.6.0-test11/drivers/usb/image/Kconfig linux-2.5/drivers/usb/image/Kconfig
--- linux-2.6.0-test11/drivers/usb/image/Kconfig	2003-11-26 20:42:57.000000000 +0000
+++ linux-2.5/drivers/usb/image/Kconfig	2003-12-01 13:51:48.000000000 +0000
@@ -18,13 +18,15 @@ config USB_MDC800
 	  module will be called mdc800.
 
 config USB_SCANNER
-	tristate "USB Scanner support"
+	tristate "USB Scanner support (OBSOLETE)"
 	depends on USB
 	help
 	  Say Y here if you want to connect a USB scanner to your computer's
 	  USB port. Please read <file:Documentation/usb/scanner.txt> for more
 	  information.
 
+	  This driver has been obsoleted by support via libusb.
+
 	  To compile this driver as a module, choose M here: the
 	  module will be called scanner.
 
diff -purN linux-2.6.0-test11/drivers/usb/misc/auerswald.c linux-2.5/drivers/usb/misc/auerswald.c
--- linux-2.6.0-test11/drivers/usb/misc/auerswald.c	2003-11-26 20:43:38.000000000 +0000
+++ linux-2.5/drivers/usb/misc/auerswald.c	2003-11-22 00:06:34.000000000 +0000
@@ -324,7 +324,7 @@ static void auerchain_complete (struct u
                 urb    = acep->urbp;
                 dbg ("auerchain_complete: submitting next urb from chain");
 		urb->status = 0;	/* needed! */
-		result = usb_submit_urb(urb, GFP_KERNEL);
+		result = usb_submit_urb(urb, GFP_ATOMIC);
 
                 /* check for submit errors */
                 if (result) {
@@ -402,7 +402,7 @@ static int auerchain_submit_urb_list (pa
         if (acep) {
                 dbg("submitting urb immediate");
 		urb->status = 0;	/* needed! */
-                result = usb_submit_urb(urb, GFP_KERNEL);
+                result = usb_submit_urb(urb, GFP_ATOMIC);
                 /* check for submit errors */
                 if (result) {
                         urb->status = result;
diff -purN linux-2.6.0-test11/drivers/usb/serial/usb-serial.c linux-2.5/drivers/usb/serial/usb-serial.c
--- linux-2.6.0-test11/drivers/usb/serial/usb-serial.c	2003-11-26 20:43:39.000000000 +0000
+++ linux-2.5/drivers/usb/serial/usb-serial.c	2003-12-10 13:28:31.000000000 +0000
@@ -493,12 +493,15 @@ bailout:
 	return retval;
 }
 
-static void __serial_close(struct usb_serial_port *port, struct file *filp)
+static void serial_close(struct tty_struct *tty, struct file * filp)
 {
-	if (!port->open_count) {
-		dbg ("%s - port not opened", __FUNCTION__);
+	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
+	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
+
+	if (!serial)
 		return;
-	}
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
 
 	--port->open_count;
 	if (port->open_count <= 0) {
@@ -506,30 +509,18 @@ static void __serial_close(struct usb_se
 		 * port is being closed by the last owner */
 		port->serial->type->close(port, filp);
 		port->open_count = 0;
+
+		if (port->tty) {
+			if (port->tty->driver_data)
+				port->tty->driver_data = NULL;
+			port->tty = NULL;
+		}
 	}
 
 	module_put(port->serial->type->owner);
 	kobject_put(&port->serial->kobj);
 }
 
-static void serial_close(struct tty_struct *tty, struct file * filp)
-{
-	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
-	struct usb_serial *serial = get_usb_serial (port, __FUNCTION__);
-
-	if (!serial)
-		return;
-
-	dbg("%s - port %d", __FUNCTION__, port->number);
-
-	/* if disconnect beat us to the punch here, there's nothing to do */
-	if (tty && tty->driver_data) {
-		__serial_close(port, filp);
-		tty->driver_data = NULL;
-	}
-	port->tty = NULL;
-}
-
 static int serial_write (struct tty_struct * tty, int from_user, const unsigned char *buf, int count)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) tty->driver_data;
@@ -848,19 +839,6 @@ static void destroy_serial (struct kobje
 	dbg ("%s - %s", __FUNCTION__, kobj->name);
 
 	serial = to_usb_serial(kobj);
-
-	/* fail all future close/read/write/ioctl/etc calls */
-	for (i = 0; i < serial->num_ports; ++i) {
-		port = serial->port[i];
-		if (port->tty != NULL) {
-			port->tty->driver_data = NULL;
-			while (port->open_count > 0) {
-				__serial_close(port, NULL);
-			}
-			port->tty = NULL;
-		}
-	}
-
 	serial_shutdown (serial);
 
 	/* return the minor range that this device had */
@@ -1242,7 +1220,7 @@ int usb_serial_probe(struct usb_interfac
 	/* register all of the individual ports with the driver core */
 	for (i = 0; i < num_ports; ++i) {
 		port = serial->port[i];
-		port->dev.parent = &serial->dev->dev;
+		port->dev.parent = &interface->dev;
 		port->dev.driver = NULL;
 		port->dev.bus = &usb_serial_bus_type;
 		port->dev.release = &port_release;
diff -purN linux-2.6.0-test11/drivers/usb/storage/datafab.c linux-2.5/drivers/usb/storage/datafab.c
--- linux-2.6.0-test11/drivers/usb/storage/datafab.c	2003-11-26 20:45:53.000000000 +0000
+++ linux-2.5/drivers/usb/storage/datafab.c	2003-11-22 17:37:54.000000000 +0000
@@ -387,7 +387,7 @@ static int datafab_id_device(struct us_d
 
 	// we'll go ahead and extract the media capacity while we're here...
 	//
-	rc = datafab_bulk_read(us, reply, sizeof(reply));
+	rc = datafab_bulk_read(us, reply, 512);
 	if (rc == USB_STOR_XFER_GOOD) {
 		// capacity is at word offset 57-58
 		//
diff -purN linux-2.6.0-test11/drivers/usb/storage/jumpshot.c linux-2.5/drivers/usb/storage/jumpshot.c
--- linux-2.6.0-test11/drivers/usb/storage/jumpshot.c	2003-11-26 20:42:52.000000000 +0000
+++ linux-2.5/drivers/usb/storage/jumpshot.c	2003-11-22 17:38:08.000000000 +0000
@@ -317,7 +317,7 @@ static int jumpshot_id_device(struct us_
 	}
 
 	// read the reply
-	rc = jumpshot_bulk_read(us, reply, sizeof(reply));
+	rc = jumpshot_bulk_read(us, reply, 512);
 	if (rc != USB_STOR_XFER_GOOD) {
 		rc = USB_STOR_TRANSPORT_ERROR;
 		goto leave;
diff -purN linux-2.6.0-test11/fs/hpfs/dir.c linux-2.5/fs/hpfs/dir.c
--- linux-2.6.0-test11/fs/hpfs/dir.c	2003-11-26 20:43:26.000000000 +0000
+++ linux-2.5/fs/hpfs/dir.c	2003-12-13 15:52:17.000000000 +0000
@@ -65,6 +65,8 @@ int hpfs_readdir(struct file *filp, void
 	int c1, c2 = 0;
 	int ret = 0;
 
+	lock_kernel();
+
 	if (hpfs_sb(inode->i_sb)->sb_chk) {
 		if (hpfs_chk_sectors(inode->i_sb, inode->i_ino, 1, "dir_fnode")) {
 			ret = -EFSERROR;
diff -purN linux-2.6.0-test11/fs/libfs.c linux-2.5/fs/libfs.c
--- linux-2.6.0-test11/fs/libfs.c	2003-11-26 20:42:48.000000000 +0000
+++ linux-2.5/fs/libfs.c	2003-12-07 21:56:02.000000000 +0000
@@ -79,6 +79,7 @@ loff_t dcache_dir_lseek(struct file *fil
 			loff_t n = file->f_pos - 2;
 
 			spin_lock(&dcache_lock);
+			list_del(&cursor->d_child);
 			p = file->f_dentry->d_subdirs.next;
 			while (n && p != &file->f_dentry->d_subdirs) {
 				struct dentry *next;
@@ -87,7 +88,6 @@ loff_t dcache_dir_lseek(struct file *fil
 					n--;
 				p = p->next;
 			}
-			list_del(&cursor->d_child);
 			list_add_tail(&cursor->d_child, p);
 			spin_unlock(&dcache_lock);
 		}
diff -purN linux-2.6.0-test11/fs/proc/base.c linux-2.5/fs/proc/base.c
--- linux-2.6.0-test11/fs/proc/base.c	2003-11-26 20:44:31.000000000 +0000
+++ linux-2.5/fs/proc/base.c	2003-12-03 00:00:00.000000000 +0000
@@ -1666,10 +1666,14 @@ static int get_tid_list(int index, unsig
 
 	index -= 2;
 	read_lock(&tasklist_lock);
-	do {
+	/*
+	 * The starting point task (leader_task) might be an already
+	 * unlinked task, which cannot be used to access the task-list
+	 * via next_thread().
+	 */
+	if (pid_alive(task)) do {
 		int tid = task->pid;
-		if (!pid_alive(task))
-			continue;
+
 		if (--index >= 0)
 			continue;
 		tids[nr_tids] = tid;
diff -purN linux-2.6.0-test11/include/asm-x86_64/msr.h linux-2.5/include/asm-x86_64/msr.h
--- linux-2.6.0-test11/include/asm-x86_64/msr.h	2003-11-26 20:45:35.000000000 +0000
+++ linux-2.5/include/asm-x86_64/msr.h	2003-11-26 18:05:30.000000000 +0000
@@ -50,9 +50,9 @@
      __asm__ __volatile__ ("rdtsc" : "=a" (low) : : "edx")
 
 #define rdtscll(val) do { \
-     unsigned int a,d; \
-     asm volatile("rdtsc" : "=a" (a), "=d" (d)); \
-     (val) = ((unsigned long)a) | (((unsigned long)d)<<32); \
+     unsigned int __a,__d; \
+     asm volatile("rdtsc" : "=a" (__a), "=d" (__d)); \
+     (val) = ((unsigned long)__a) | (((unsigned long)__d)<<32); \
 } while(0)
 
 #define rdpmc(counter,low,high) \
diff -purN linux-2.6.0-test11/include/linux/blkdev.h linux-2.5/include/linux/blkdev.h
--- linux-2.6.0-test11/include/linux/blkdev.h	2003-11-26 20:43:25.000000000 +0000
+++ linux-2.5/include/linux/blkdev.h	2003-12-11 17:54:43.000000000 +0000
@@ -82,6 +82,8 @@ struct request_list {
 	wait_queue_head_t wait[2];
 };
 
+#define BLK_MAX_CDB	16
+
 /*
  * try to put the fields that are referenced together in the same cacheline
  */
@@ -147,7 +149,7 @@ struct request {
 	 * when request is used as a packet command carrier
 	 */
 	unsigned int cmd_len;
-	unsigned char cmd[16];
+	unsigned char cmd[BLK_MAX_CDB];
 
 	unsigned int data_len;
 	void *data;
diff -purN linux-2.6.0-test11/include/linux/list.h linux-2.5/include/linux/list.h
--- linux-2.6.0-test11/include/linux/list.h	2003-11-26 20:44:20.000000000 +0000
+++ linux-2.5/include/linux/list.h	2003-12-12 22:20:03.000000000 +0000
@@ -208,6 +208,18 @@ static inline int list_empty(const struc
 	return head->next == head;
 }
 
+/**
+ * list_empty_careful - tests whether a list is
+ * empty _and_ checks that no other CPU might be
+ * in the process of still modifying either member
+ * @head: the list to test.
+ */
+static inline int list_empty_careful(const struct list_head *head)
+{
+	struct list_head *next = head->next;
+	return (next == head) && (next == head->prev);
+}
+
 static inline void __list_splice(struct list_head *list,
 				 struct list_head *head)
 {
diff -purN linux-2.6.0-test11/include/linux/rtnetlink.h linux-2.5/include/linux/rtnetlink.h
--- linux-2.6.0-test11/include/linux/rtnetlink.h	2003-11-26 20:45:11.000000000 +0000
+++ linux-2.5/include/linux/rtnetlink.h	2003-12-03 19:57:28.000000000 +0000
@@ -138,6 +138,7 @@ enum
 #define RTPROT_ZEBRA	11	/* Zebra */
 #define RTPROT_BIRD	12	/* BIRD */
 #define RTPROT_DNROUTED	13	/* DECnet routing daemon */
+#define RTPROT_XORP	14	/* XORP */
 
 /* rtm_scope
 
diff -purN linux-2.6.0-test11/kernel/exit.c linux-2.5/kernel/exit.c
--- linux-2.6.0-test11/kernel/exit.c	2003-11-26 20:45:29.000000000 +0000
+++ linux-2.5/kernel/exit.c	2003-12-15 02:28:23.000000000 +0000
@@ -49,9 +49,11 @@ static void __unhash_process(struct task
 
 void release_task(struct task_struct * p)
 {
+	int zap_leader;
 	task_t *leader;
 	struct dentry *proc_dentry;
- 
+
+repeat: 
 	BUG_ON(p->state < TASK_ZOMBIE);
  
 	atomic_dec(&p->user->processes);
@@ -70,10 +72,21 @@ void release_task(struct task_struct * p
 	 * group, and the leader is zombie, then notify the
 	 * group leader's parent process. (if it wants notification.)
 	 */
+	zap_leader = 0;
 	leader = p->group_leader;
-	if (leader != p && thread_group_empty(leader) &&
-		    leader->state == TASK_ZOMBIE && leader->exit_signal != -1)
+	if (leader != p && thread_group_empty(leader) && leader->state == TASK_ZOMBIE) {
+		BUG_ON(leader->exit_signal == -1);
 		do_notify_parent(leader, leader->exit_signal);
+		/*
+		 * If we were the last child thread and the leader has
+		 * exited already, and the leader's parent ignores SIGCHLD,
+		 * then we are the one who should release the leader.
+		 *
+		 * do_notify_parent() will have marked it self-reaping in
+		 * that case.
+		 */
+		zap_leader = (leader->exit_signal == -1);
+	}
 
 	p->parent->cutime += p->utime + p->cutime;
 	p->parent->cstime += p->stime + p->cstime;
@@ -88,6 +101,10 @@ void release_task(struct task_struct * p
 	proc_pid_flush(proc_dentry);
 	release_thread(p);
 	put_task_struct(p);
+
+	p = leader;
+	if (unlikely(zap_leader))
+		goto repeat;
 }
 
 /* we are using it only for SMP init */
diff -purN linux-2.6.0-test11/kernel/fork.c linux-2.5/kernel/fork.c
--- linux-2.6.0-test11/kernel/fork.c	2003-11-26 20:42:58.000000000 +0000
+++ linux-2.5/kernel/fork.c	2003-12-14 05:36:26.000000000 +0000
@@ -125,15 +125,28 @@ void remove_wait_queue(wait_queue_head_t
 
 EXPORT_SYMBOL(remove_wait_queue);
 
+
+/*
+ * Note: we use "set_current_state()" _after_ the wait-queue add,
+ * because we need a memory barrier there on SMP, so that any
+ * wake-function that tests for the wait-queue being active
+ * will be guaranteed to see waitqueue addition _or_ subsequent
+ * tests in this thread will see the wakeup having taken place.
+ *
+ * The spin_unlock() itself is semi-permeable and only protects
+ * one way (it only protects stuff inside the critical region and
+ * stops them from bleeding out - it would still allow subsequent
+ * loads to move into the the critical region).
+ */
 void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)
 {
 	unsigned long flags;
 
-	__set_current_state(state);
 	wait->flags &= ~WQ_FLAG_EXCLUSIVE;
 	spin_lock_irqsave(&q->lock, flags);
 	if (list_empty(&wait->task_list))
 		__add_wait_queue(q, wait);
+	set_current_state(state);
 	spin_unlock_irqrestore(&q->lock, flags);
 }
 
@@ -144,11 +157,11 @@ prepare_to_wait_exclusive(wait_queue_hea
 {
 	unsigned long flags;
 
-	__set_current_state(state);
 	wait->flags |= WQ_FLAG_EXCLUSIVE;
 	spin_lock_irqsave(&q->lock, flags);
 	if (list_empty(&wait->task_list))
 		__add_wait_queue_tail(q, wait);
+	set_current_state(state);
 	spin_unlock_irqrestore(&q->lock, flags);
 }
 
@@ -159,7 +172,20 @@ void finish_wait(wait_queue_head_t *q, w
 	unsigned long flags;
 
 	__set_current_state(TASK_RUNNING);
-	if (!list_empty(&wait->task_list)) {
+	/*
+	 * We can check for list emptiness outside the lock
+	 * IFF:
+	 *  - we use the "careful" check that verifies both
+	 *    the next and prev pointers, so that there cannot
+	 *    be any half-pending updates in progress on other
+	 *    CPU's that we haven't seen yet (and that might
+	 *    still change the stack area.
+	 * and
+	 *  - all other users take the lock (ie we can only
+	 *    have _one_ other CPU that looks at or modifies
+	 *    the list).
+	 */
+	if (!list_empty_careful(&wait->task_list)) {
 		spin_lock_irqsave(&q->lock, flags);
 		list_del_init(&wait->task_list);
 		spin_unlock_irqrestore(&q->lock, flags);
diff -purN linux-2.6.0-test11/kernel/sched.c linux-2.5/kernel/sched.c
--- linux-2.6.0-test11/kernel/sched.c	2003-11-26 20:45:17.000000000 +0000
+++ linux-2.5/kernel/sched.c	2003-12-02 00:00:00.000000000 +0000
@@ -646,7 +646,7 @@ repeat_lock_task:
 				 */
 				p->activated = -1;
 			}
-			if (sync)
+			if (sync && (task_cpu(p) == smp_processor_id()))
 				__activate_task(p, rq);
 			else {
 				activate_task(p, rq);
diff -purN linux-2.6.0-test11/lib/kobject.c linux-2.5/lib/kobject.c
--- linux-2.6.0-test11/lib/kobject.c	2003-11-26 20:45:34.000000000 +0000
+++ linux-2.5/lib/kobject.c	2003-12-11 17:49:17.000000000 +0000
@@ -236,8 +236,6 @@ static void unlink(struct kobject * kobj
 		list_del_init(&kobj->entry);
 		up_write(&kobj->kset->subsys->rwsem);
 	}
-	if (kobj->parent) 
-		kobject_put(kobj->parent);
 	kobject_put(kobj);
 }
 
@@ -274,9 +272,11 @@ int kobject_add(struct kobject * kobj)
 	kobj->parent = parent;
 
 	error = create_dir(kobj);
-	if (error)
+	if (error) {
 		unlink(kobj);
-	else {
+		if (parent)
+			kobject_put(parent);
+	} else {
 		/* If this kobj does not belong to a kset,
 		   try to find a parent that does. */
 		top_kobj = kobj;
@@ -452,6 +452,7 @@ void kobject_cleanup(struct kobject * ko
 {
 	struct kobj_type * t = get_ktype(kobj);
 	struct kset * s = kobj->kset;
+	struct kobject * parent = kobj->parent;
 
 	pr_debug("kobject %s: cleaning up\n",kobject_name(kobj));
 	if (kobj->k_name != kobj->name)
@@ -461,6 +462,8 @@ void kobject_cleanup(struct kobject * ko
 		t->release(kobj);
 	if (s)
 		kset_put(s);
+	if (parent) 
+		kobject_put(parent);
 }
 
 /**
diff -purN linux-2.6.0-test11/mm/mmap.c linux-2.5/mm/mmap.c
--- linux-2.6.0-test11/mm/mmap.c	2003-11-26 20:44:31.000000000 +0000
+++ linux-2.5/mm/mmap.c	2003-12-06 22:34:36.000000000 +0000
@@ -19,6 +19,7 @@
 #include <linux/hugetlb.h>
 #include <linux/profile.h>
 #include <linux/module.h>
+#include <linux/mount.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -474,8 +475,13 @@ unsigned long do_mmap_pgoff(struct file 
 	struct rb_node ** rb_link, * rb_parent;
 	unsigned long charged = 0;
 
-	if (file && (!file->f_op || !file->f_op->mmap))
-		return -ENODEV;
+	if (file) {
+		if (!file->f_op || !file->f_op->mmap)
+			return -ENODEV;
+
+		if ((prot & PROT_EXEC) && (file->f_vfsmnt->mnt_flags & MNT_NOEXEC))
+			return -EPERM;
+	}
 
 	if (!len)
 		return addr;
diff -purN linux-2.6.0-test11/net/bridge/br_netfilter.c linux-2.5/net/bridge/br_netfilter.c
--- linux-2.6.0-test11/net/bridge/br_netfilter.c	2003-11-26 20:45:45.000000000 +0000
+++ linux-2.5/net/bridge/br_netfilter.c	2003-12-05 20:41:20.000000000 +0000
@@ -180,7 +180,7 @@ static int br_nf_pre_routing_finish(stru
 			struct rtable *rt;
 			struct flowi fl = { .nl_u = 
 			{ .ip4_u = { .daddr = iph->daddr, .saddr = 0 ,
-				     .tos = iph->tos} }, .proto = 0};
+				     .tos = RT_TOS(iph->tos)} }, .proto = 0};
 
 			if (!ip_route_output_key(&rt, &fl)) {
 				/* Bridged-and-DNAT'ed traffic doesn't
diff -purN linux-2.6.0-test11/net/ipv4/netfilter/ip_conntrack_proto_tcp.c linux-2.5/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
--- linux-2.6.0-test11/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2003-11-26 20:45:53.000000000 +0000
+++ linux-2.5/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2003-12-03 19:56:54.000000000 +0000
@@ -53,7 +53,7 @@ unsigned long ip_ct_tcp_timeout_syn_sent
 unsigned long ip_ct_tcp_timeout_syn_recv =     60 SECS;
 unsigned long ip_ct_tcp_timeout_established =   5 DAYS;
 unsigned long ip_ct_tcp_timeout_fin_wait =      2 MINS;
-unsigned long ip_ct_tcp_timeout_close_wait =    3 DAYS;
+unsigned long ip_ct_tcp_timeout_close_wait =   60 SECS;
 unsigned long ip_ct_tcp_timeout_last_ack =     30 SECS;
 unsigned long ip_ct_tcp_timeout_time_wait =     2 MINS;
 unsigned long ip_ct_tcp_timeout_close =        10 SECS;
diff -purN linux-2.6.0-test11/net/ipv4/netfilter/ip_conntrack_standalone.c linux-2.5/net/ipv4/netfilter/ip_conntrack_standalone.c
--- linux-2.6.0-test11/net/ipv4/netfilter/ip_conntrack_standalone.c	2003-11-26 20:43:50.000000000 +0000
+++ linux-2.5/net/ipv4/netfilter/ip_conntrack_standalone.c	2003-12-05 20:30:11.000000000 +0000
@@ -201,7 +201,8 @@ static unsigned int ip_refrag(unsigned i
 	/* Local packets are never produced too large for their
 	   interface.  We degfragment them at LOCAL_OUT, however,
 	   so we have to refragment them here. */
-	if ((*pskb)->len > dst_pmtu(&rt->u.dst)) {
+	if ((*pskb)->len > dst_pmtu(&rt->u.dst) &&
+	    !skb_shinfo(*pskb)->tso_size) {
 		/* No hook can be after us, so this should be OK. */
 		ip_fragment(*pskb, okfn);
 		return NF_STOLEN;
diff -purN linux-2.6.0-test11/net/ipv4/tcp_ipv4.c linux-2.5/net/ipv4/tcp_ipv4.c
--- linux-2.6.0-test11/net/ipv4/tcp_ipv4.c	2003-11-26 20:43:32.000000000 +0000
+++ linux-2.5/net/ipv4/tcp_ipv4.c	2003-11-28 15:52:28.000000000 +0000
@@ -2356,6 +2356,7 @@ static void *tcp_get_idx(struct seq_file
 static void *tcp_seq_start(struct seq_file *seq, loff_t *pos)
 {
 	struct tcp_iter_state* st = seq->private;
+	st->state = TCP_SEQ_STATE_LISTENING;
 	st->num = 0;
 	return *pos ? tcp_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;
 }
diff -purN linux-2.6.0-test11/net/ipv6/tcp_ipv6.c linux-2.5/net/ipv6/tcp_ipv6.c
--- linux-2.6.0-test11/net/ipv6/tcp_ipv6.c	2003-11-26 20:44:21.000000000 +0000
+++ linux-2.5/net/ipv6/tcp_ipv6.c	2003-12-09 05:35:27.000000000 +0000
@@ -222,7 +222,7 @@ static __inline__ void __tcp_v6_hash(str
 		write_lock(lock);
 	}
 
-	sk_add_node(sk, list);
+	__sk_add_node(sk, list);
 	sock_prot_inc_use(sk->sk_prot);
 	write_unlock(lock);
 }
diff -purN linux-2.6.0-test11/net/ipv6/udp.c linux-2.5/net/ipv6/udp.c
--- linux-2.6.0-test11/net/ipv6/udp.c	2003-11-26 20:45:21.000000000 +0000
+++ linux-2.5/net/ipv6/udp.c	2003-12-03 19:54:18.000000000 +0000
@@ -825,7 +825,7 @@ static int udpv6_sendmsg(struct kiocb *i
 			struct sockaddr_in sin;
 			sin.sin_family = AF_INET;
 			sin.sin_port = sin6 ? sin6->sin6_port : inet->dport;
-			sin.sin_addr.s_addr = daddr->s6_addr[3];
+			sin.sin_addr.s_addr = daddr->s6_addr32[3];
 			msg->msg_name = &sin;
 			msg->msg_namelen = sizeof(sin);
 do_udp_sendmsg:
diff -purN linux-2.6.0-test11/net/sched/sch_htb.c linux-2.5/net/sched/sch_htb.c
--- linux-2.6.0-test11/net/sched/sch_htb.c	2003-11-26 20:44:32.000000000 +0000
+++ linux-2.5/net/sched/sch_htb.c	2003-12-08 03:33:19.000000000 +0000
@@ -74,7 +74,7 @@
 #define HTB_HYSTERESIS 1/* whether to use mode hysteresis for speedup */
 #define HTB_QLOCK(S) spin_lock_bh(&(S)->dev->queue_lock)
 #define HTB_QUNLOCK(S) spin_unlock_bh(&(S)->dev->queue_lock)
-#define HTB_VER 0x3000d	/* major must be matched with number suplied by TC as version */
+#define HTB_VER 0x3000e	/* major must be matched with number suplied by TC as version */
 
 #if HTB_VER >> 16 != TC_HTB_PROTOVER
 #error "Mismatched sch_htb.c and pkt_sch.h"
@@ -290,6 +290,11 @@ static __inline__ struct htb_class *htb_
  * then finish and return direct queue.
  */
 #define HTB_DIRECT (struct htb_class*)-1
+static inline u32 htb_classid(struct htb_class *cl)
+{
+	return (cl && cl != HTB_DIRECT) ? cl->classid : TC_H_UNSPEC;
+}
+
 static struct htb_class *htb_classify(struct sk_buff *skb, struct Qdisc *sch)
 {
 	struct htb_sched *q = (struct htb_sched *)sch->data;
@@ -703,7 +708,7 @@ static int htb_enqueue(struct sk_buff *s
 
     sch->q.qlen++;
     sch->stats.packets++; sch->stats.bytes += skb->len;
-    HTB_DBG(1,1,"htb_enq_ok cl=%X skb=%p\n",cl?cl->classid:0,skb);
+    HTB_DBG(1,1,"htb_enq_ok cl=%X skb=%p\n",htb_classid(cl),skb);
     return NET_XMIT_SUCCESS;
 }
 
@@ -731,7 +736,7 @@ static int htb_requeue(struct sk_buff *s
 	    htb_activate (q,cl);
 
     sch->q.qlen++;
-    HTB_DBG(1,1,"htb_req_ok cl=%X skb=%p\n",cl?cl->classid:0,skb);
+    HTB_DBG(1,1,"htb_req_ok cl=%X skb=%p\n",htb_classid(cl),skb);
     return NET_XMIT_SUCCESS;
 }
 
@@ -1381,11 +1386,16 @@ static void htb_destroy(struct Qdisc* sc
 #ifdef HTB_RATECM
 	del_timer_sync (&q->rttim);
 #endif
+	/* This line used to be after htb_destroy_class call below
+	   and surprisingly it worked in 2.4. But it must precede it 
+	   because filter need its target class alive to be able to call
+	   unbind_filter on it (without Oops). */
+	htb_destroy_filters(&q->filter_list);
+	
 	while (!list_empty(&q->root)) 
 		htb_destroy_class (sch,list_entry(q->root.next,
 					struct htb_class,sibling));
 
-	htb_destroy_filters(&q->filter_list);
 	__skb_queue_purge(&q->direct_queue);
 }
 
diff -purN linux-2.6.0-test11/scripts/file2alias.c linux-2.5/scripts/file2alias.c
--- linux-2.6.0-test11/scripts/file2alias.c	2003-11-26 20:44:05.000000000 +0000
+++ linux-2.5/scripts/file2alias.c	2003-11-03 16:40:48.000000000 +0000
@@ -52,6 +52,13 @@ static int do_usb_entry(const char *file
 	id->bcdDevice_lo = TO_NATIVE(id->bcdDevice_lo);
 	id->bcdDevice_hi = TO_NATIVE(id->bcdDevice_hi);
 
+	/*
+	 * Some modules (visor) have empty slots as placeholder for
+	 * run-time specification that results in catch-all alias
+	 */
+	if (!(id->idVendor | id->bDeviceClass | id->bInterfaceClass))
+		return 1;
+
 	strcpy(alias, "usb:");
 	ADD(alias, "v", id->match_flags&USB_DEVICE_ID_MATCH_VENDOR,
 	    id->idVendor);
