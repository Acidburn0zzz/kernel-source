diff -purN linux-2.6.0-test11/arch/i386/mm/fault.c linux-2.5/arch/i386/mm/fault.c
--- linux-2.6.0-test11/arch/i386/mm/fault.c	2003-11-26 20:42:46.000000000 +0000
+++ linux-2.5/arch/i386/mm/fault.c	2003-12-03 02:41:44.000000000 +0000
@@ -359,7 +359,8 @@ bad_area_nosemaphore:
 			return;
 
 		tsk->thread.cr2 = address;
-		tsk->thread.error_code = error_code;
+		/* Kernel addresses are always protection faults */
+		tsk->thread.error_code = error_code | (address >= TASK_SIZE);
 		tsk->thread.trap_no = 14;
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
diff -purN linux-2.6.0-test11/drivers/block/scsi_ioctl.c linux-2.5/drivers/block/scsi_ioctl.c
--- linux-2.6.0-test11/drivers/block/scsi_ioctl.c	2003-11-26 20:46:03.000000000 +0000
+++ linux-2.5/drivers/block/scsi_ioctl.c	2003-12-09 17:52:12.000000000 +0000
@@ -216,7 +216,12 @@ static int sg_io(request_queue_t *q, str
 	 * fill in request structure
 	 */
 	rq->cmd_len = hdr->cmd_len;
-	memcpy(rq->cmd, hdr->cmdp, hdr->cmd_len);
+
+	if (copy_from_user(rq->cmd, hdr->cmdp, hdr->cmd_len)) {
+		blk_put_request(rq);
+		return -EFAULT;
+	}
+
 	if (sizeof(rq->cmd) != hdr->cmd_len)
 		memset(rq->cmd + hdr->cmd_len, 0, sizeof(rq->cmd) - hdr->cmd_len);
 
diff -purN linux-2.6.0-test11/drivers/i2c/busses/i2c-nforce2.c linux-2.5/drivers/i2c/busses/i2c-nforce2.c
--- linux-2.6.0-test11/drivers/i2c/busses/i2c-nforce2.c	2003-11-26 20:43:09.000000000 +0000
+++ linux-2.5/drivers/i2c/busses/i2c-nforce2.c	2003-11-28 21:49:21.000000000 +0000
@@ -147,7 +147,7 @@ static s32 nforce2_access(struct i2c_ada
 
 		case I2C_SMBUS_BYTE:
 			if (read_write == I2C_SMBUS_WRITE)
-				outb_p(data->byte, NVIDIA_SMB_DATA);
+				outb_p(command, NVIDIA_SMB_CMD);
 			protocol |= NVIDIA_SMB_PRTCL_BYTE;
 			break;
 
diff -purN linux-2.6.0-test11/drivers/net/pci-skeleton.c linux-2.5/drivers/net/pci-skeleton.c
--- linux-2.6.0-test11/drivers/net/pci-skeleton.c	2003-11-26 20:42:51.000000000 +0000
+++ linux-2.5/drivers/net/pci-skeleton.c	2003-12-05 13:22:32.000000000 +0000
@@ -864,13 +864,6 @@ static void __devexit netdrv_remove_one 
 
 	pci_release_regions (pdev);
 
-#ifndef NETDRV_NDEBUG
-	/* poison memory before freeing */
-	memset (dev, 0xBC,
-		sizeof (struct net_device) +
-		sizeof (struct netdrv_private));
-#endif /* NETDRV_NDEBUG */
-
 	free_netdev (dev);
 
 	pci_set_drvdata (pdev, NULL);
diff -purN linux-2.6.0-test11/drivers/net/pcnet32.c linux-2.5/drivers/net/pcnet32.c
--- linux-2.6.0-test11/drivers/net/pcnet32.c	2003-11-26 20:43:27.000000000 +0000
+++ linux-2.5/drivers/net/pcnet32.c	2003-12-05 13:22:32.000000000 +0000
@@ -1766,8 +1766,6 @@ static void __exit pcnet32_cleanup_modul
 	next_dev = lp->next;
 	unregister_netdev(pcnet32_dev);
 	release_region(pcnet32_dev->base_addr, PCNET32_TOTAL_SIZE);
-	if (lp->pci_dev)
-	    pci_unregister_driver(&pcnet32_driver);
 	pci_free_consistent(lp->pci_dev, sizeof(*lp), lp, lp->dma_addr);
 	free_netdev(pcnet32_dev);
 	pcnet32_dev = next_dev;
diff -purN linux-2.6.0-test11/drivers/net/r8169.c linux-2.5/drivers/net/r8169.c
--- linux-2.6.0-test11/drivers/net/r8169.c	2003-11-26 20:44:12.000000000 +0000
+++ linux-2.5/drivers/net/r8169.c	2003-12-05 13:22:32.000000000 +0000
@@ -642,10 +642,6 @@ rtl8169_remove_one(struct pci_dev *pdev)
 	iounmap(tp->mmio_addr);
 	pci_release_regions(pdev);
 
-	// poison memory before freeing 
-	memset(dev, 0xBC,
-	       sizeof (struct net_device) + sizeof (struct rtl8169_private));
-
 	pci_disable_device(pdev);
 	free_netdev(dev);
 	pci_set_drvdata(pdev, NULL);
diff -purN linux-2.6.0-test11/drivers/net/sis190.c linux-2.5/drivers/net/sis190.c
--- linux-2.6.0-test11/drivers/net/sis190.c	2003-11-26 20:46:10.000000000 +0000
+++ linux-2.5/drivers/net/sis190.c	2003-12-05 13:22:32.000000000 +0000
@@ -703,10 +703,6 @@ SiS190_remove_one(struct pci_dev *pdev)
 	iounmap(tp->mmio_addr);
 	pci_release_regions(pdev);
 
-	// poison memory before freeing 
-	memset(dev, 0xBC,
-	       sizeof (struct net_device) + sizeof (struct sis190_private));
-
 	free_netdev(dev);
 	pci_set_drvdata(pdev, NULL);
 }
diff -purN linux-2.6.0-test11/drivers/net/wireless/airo.c linux-2.5/drivers/net/wireless/airo.c
--- linux-2.6.0-test11/drivers/net/wireless/airo.c	2003-11-26 20:42:59.000000000 +0000
+++ linux-2.5/drivers/net/wireless/airo.c	2003-12-07 13:22:52.000000000 +0000
@@ -2466,11 +2466,8 @@ static irqreturn_t airo_interrupt ( int 
 			OUT4500( apriv, EVACK, EV_MIC );
 #ifdef MICSUPPORT
 			if (test_bit(FLAG_MIC_CAPABLE, &apriv->flags)) {
-				if (down_trylock(&apriv->sem) != 0) {
-					set_bit(JOB_MIC, &apriv->flags);
-					wake_up_interruptible(&apriv->thr_wait);
-				} else
-					micinit (apriv);
+				set_bit(JOB_MIC, &apriv->flags);
+				wake_up_interruptible(&apriv->thr_wait);
 			}
 #endif
 		}
diff -purN linux-2.6.0-test11/drivers/scsi/ide-scsi.c linux-2.5/drivers/scsi/ide-scsi.c
--- linux-2.6.0-test11/drivers/scsi/ide-scsi.c	2003-11-26 20:44:34.000000000 +0000
+++ linux-2.5/drivers/scsi/ide-scsi.c	2003-12-03 03:03:55.000000000 +0000
@@ -517,6 +517,7 @@ static ide_startstop_t idescsi_issue_pc 
 	pc->current_position=pc->buffer;
 	bcount.all = IDE_MIN(pc->request_transfer, 63 * 1024);		/* Request to transfer the entire buffer at once */
 
+	feature.all = 0;
 	if (drive->using_dma && rq->bio) {
 		if (test_bit(PC_WRITING, &pc->flags))
 			feature.b.dma = !HWIF(drive)->ide_dma_write(drive);
diff -purN linux-2.6.0-test11/drivers/scsi/libata-core.c linux-2.5/drivers/scsi/libata-core.c
--- linux-2.6.0-test11/drivers/scsi/libata-core.c	2003-11-26 20:42:46.000000000 +0000
+++ linux-2.5/drivers/scsi/libata-core.c	2003-12-05 13:46:54.000000000 +0000
@@ -3224,8 +3224,6 @@ void ata_pci_remove_one (struct pci_dev 
 		scsi_host_put(ap->host); /* FIXME: check return val */
 	}
 
-	kfree(host_set);
-
 	pci_release_regions(pdev);
 
 	for (i = 0; i < host_set->n_ports; i++) {
@@ -3242,6 +3240,7 @@ void ata_pci_remove_one (struct pci_dev 
 		}
 	}
 
+	kfree(host_set);
 	pci_disable_device(pdev);
 	pci_set_drvdata(pdev, NULL);
 }
diff -purN linux-2.6.0-test11/fs/libfs.c linux-2.5/fs/libfs.c
--- linux-2.6.0-test11/fs/libfs.c	2003-11-26 20:42:48.000000000 +0000
+++ linux-2.5/fs/libfs.c	2003-12-07 21:56:02.000000000 +0000
@@ -79,6 +79,7 @@ loff_t dcache_dir_lseek(struct file *fil
 			loff_t n = file->f_pos - 2;
 
 			spin_lock(&dcache_lock);
+			list_del(&cursor->d_child);
 			p = file->f_dentry->d_subdirs.next;
 			while (n && p != &file->f_dentry->d_subdirs) {
 				struct dentry *next;
@@ -87,7 +88,6 @@ loff_t dcache_dir_lseek(struct file *fil
 					n--;
 				p = p->next;
 			}
-			list_del(&cursor->d_child);
 			list_add_tail(&cursor->d_child, p);
 			spin_unlock(&dcache_lock);
 		}
diff -purN linux-2.6.0-test11/fs/proc/base.c linux-2.5/fs/proc/base.c
--- linux-2.6.0-test11/fs/proc/base.c	2003-11-26 20:44:31.000000000 +0000
+++ linux-2.5/fs/proc/base.c	2003-12-03 00:00:00.000000000 +0000
@@ -1666,10 +1666,14 @@ static int get_tid_list(int index, unsig
 
 	index -= 2;
 	read_lock(&tasklist_lock);
-	do {
+	/*
+	 * The starting point task (leader_task) might be an already
+	 * unlinked task, which cannot be used to access the task-list
+	 * via next_thread().
+	 */
+	if (pid_alive(task)) do {
 		int tid = task->pid;
-		if (!pid_alive(task))
-			continue;
+
 		if (--index >= 0)
 			continue;
 		tids[nr_tids] = tid;
diff -purN linux-2.6.0-test11/include/asm-x86_64/msr.h linux-2.5/include/asm-x86_64/msr.h
--- linux-2.6.0-test11/include/asm-x86_64/msr.h	2003-11-26 20:45:35.000000000 +0000
+++ linux-2.5/include/asm-x86_64/msr.h	2003-11-26 18:05:30.000000000 +0000
@@ -50,9 +50,9 @@
      __asm__ __volatile__ ("rdtsc" : "=a" (low) : : "edx")
 
 #define rdtscll(val) do { \
-     unsigned int a,d; \
-     asm volatile("rdtsc" : "=a" (a), "=d" (d)); \
-     (val) = ((unsigned long)a) | (((unsigned long)d)<<32); \
+     unsigned int __a,__d; \
+     asm volatile("rdtsc" : "=a" (__a), "=d" (__d)); \
+     (val) = ((unsigned long)__a) | (((unsigned long)__d)<<32); \
 } while(0)
 
 #define rdpmc(counter,low,high) \
diff -purN linux-2.6.0-test11/include/linux/rtnetlink.h linux-2.5/include/linux/rtnetlink.h
--- linux-2.6.0-test11/include/linux/rtnetlink.h	2003-11-26 20:45:11.000000000 +0000
+++ linux-2.5/include/linux/rtnetlink.h	2003-12-03 19:57:28.000000000 +0000
@@ -138,6 +138,7 @@ enum
 #define RTPROT_ZEBRA	11	/* Zebra */
 #define RTPROT_BIRD	12	/* BIRD */
 #define RTPROT_DNROUTED	13	/* DECnet routing daemon */
+#define RTPROT_XORP	14	/* XORP */
 
 /* rtm_scope
 
diff -purN linux-2.6.0-test11/kernel/sched.c linux-2.5/kernel/sched.c
--- linux-2.6.0-test11/kernel/sched.c	2003-11-26 20:45:17.000000000 +0000
+++ linux-2.5/kernel/sched.c	2003-12-02 00:00:00.000000000 +0000
@@ -646,7 +646,7 @@ repeat_lock_task:
 				 */
 				p->activated = -1;
 			}
-			if (sync)
+			if (sync && (task_cpu(p) == smp_processor_id()))
 				__activate_task(p, rq);
 			else {
 				activate_task(p, rq);
diff -purN linux-2.6.0-test11/mm/mmap.c linux-2.5/mm/mmap.c
--- linux-2.6.0-test11/mm/mmap.c	2003-11-26 20:44:31.000000000 +0000
+++ linux-2.5/mm/mmap.c	2003-12-06 22:34:36.000000000 +0000
@@ -19,6 +19,7 @@
 #include <linux/hugetlb.h>
 #include <linux/profile.h>
 #include <linux/module.h>
+#include <linux/mount.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -474,8 +475,13 @@ unsigned long do_mmap_pgoff(struct file 
 	struct rb_node ** rb_link, * rb_parent;
 	unsigned long charged = 0;
 
-	if (file && (!file->f_op || !file->f_op->mmap))
-		return -ENODEV;
+	if (file) {
+		if (!file->f_op || !file->f_op->mmap)
+			return -ENODEV;
+
+		if ((prot & PROT_EXEC) && (file->f_vfsmnt->mnt_flags & MNT_NOEXEC))
+			return -EPERM;
+	}
 
 	if (!len)
 		return addr;
diff -purN linux-2.6.0-test11/net/bridge/br_netfilter.c linux-2.5/net/bridge/br_netfilter.c
--- linux-2.6.0-test11/net/bridge/br_netfilter.c	2003-11-26 20:45:45.000000000 +0000
+++ linux-2.5/net/bridge/br_netfilter.c	2003-12-05 20:41:20.000000000 +0000
@@ -180,7 +180,7 @@ static int br_nf_pre_routing_finish(stru
 			struct rtable *rt;
 			struct flowi fl = { .nl_u = 
 			{ .ip4_u = { .daddr = iph->daddr, .saddr = 0 ,
-				     .tos = iph->tos} }, .proto = 0};
+				     .tos = RT_TOS(iph->tos)} }, .proto = 0};
 
 			if (!ip_route_output_key(&rt, &fl)) {
 				/* Bridged-and-DNAT'ed traffic doesn't
diff -purN linux-2.6.0-test11/net/ipv4/netfilter/ip_conntrack_proto_tcp.c linux-2.5/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
--- linux-2.6.0-test11/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2003-11-26 20:45:53.000000000 +0000
+++ linux-2.5/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2003-12-03 19:56:54.000000000 +0000
@@ -53,7 +53,7 @@ unsigned long ip_ct_tcp_timeout_syn_sent
 unsigned long ip_ct_tcp_timeout_syn_recv =     60 SECS;
 unsigned long ip_ct_tcp_timeout_established =   5 DAYS;
 unsigned long ip_ct_tcp_timeout_fin_wait =      2 MINS;
-unsigned long ip_ct_tcp_timeout_close_wait =    3 DAYS;
+unsigned long ip_ct_tcp_timeout_close_wait =   60 SECS;
 unsigned long ip_ct_tcp_timeout_last_ack =     30 SECS;
 unsigned long ip_ct_tcp_timeout_time_wait =     2 MINS;
 unsigned long ip_ct_tcp_timeout_close =        10 SECS;
diff -purN linux-2.6.0-test11/net/ipv4/netfilter/ip_conntrack_standalone.c linux-2.5/net/ipv4/netfilter/ip_conntrack_standalone.c
--- linux-2.6.0-test11/net/ipv4/netfilter/ip_conntrack_standalone.c	2003-11-26 20:43:50.000000000 +0000
+++ linux-2.5/net/ipv4/netfilter/ip_conntrack_standalone.c	2003-12-05 20:30:11.000000000 +0000
@@ -201,7 +201,8 @@ static unsigned int ip_refrag(unsigned i
 	/* Local packets are never produced too large for their
 	   interface.  We degfragment them at LOCAL_OUT, however,
 	   so we have to refragment them here. */
-	if ((*pskb)->len > dst_pmtu(&rt->u.dst)) {
+	if ((*pskb)->len > dst_pmtu(&rt->u.dst) &&
+	    !skb_shinfo(*pskb)->tso_size) {
 		/* No hook can be after us, so this should be OK. */
 		ip_fragment(*pskb, okfn);
 		return NF_STOLEN;
diff -purN linux-2.6.0-test11/net/ipv4/tcp_ipv4.c linux-2.5/net/ipv4/tcp_ipv4.c
--- linux-2.6.0-test11/net/ipv4/tcp_ipv4.c	2003-11-26 20:43:32.000000000 +0000
+++ linux-2.5/net/ipv4/tcp_ipv4.c	2003-11-28 15:52:28.000000000 +0000
@@ -2356,6 +2356,7 @@ static void *tcp_get_idx(struct seq_file
 static void *tcp_seq_start(struct seq_file *seq, loff_t *pos)
 {
 	struct tcp_iter_state* st = seq->private;
+	st->state = TCP_SEQ_STATE_LISTENING;
 	st->num = 0;
 	return *pos ? tcp_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;
 }
diff -purN linux-2.6.0-test11/net/ipv6/tcp_ipv6.c linux-2.5/net/ipv6/tcp_ipv6.c
--- linux-2.6.0-test11/net/ipv6/tcp_ipv6.c	2003-11-26 20:44:21.000000000 +0000
+++ linux-2.5/net/ipv6/tcp_ipv6.c	2003-12-09 05:35:27.000000000 +0000
@@ -222,7 +222,7 @@ static __inline__ void __tcp_v6_hash(str
 		write_lock(lock);
 	}
 
-	sk_add_node(sk, list);
+	__sk_add_node(sk, list);
 	sock_prot_inc_use(sk->sk_prot);
 	write_unlock(lock);
 }
diff -purN linux-2.6.0-test11/net/ipv6/udp.c linux-2.5/net/ipv6/udp.c
--- linux-2.6.0-test11/net/ipv6/udp.c	2003-11-26 20:45:21.000000000 +0000
+++ linux-2.5/net/ipv6/udp.c	2003-12-03 19:54:18.000000000 +0000
@@ -825,7 +825,7 @@ static int udpv6_sendmsg(struct kiocb *i
 			struct sockaddr_in sin;
 			sin.sin_family = AF_INET;
 			sin.sin_port = sin6 ? sin6->sin6_port : inet->dport;
-			sin.sin_addr.s_addr = daddr->s6_addr[3];
+			sin.sin_addr.s_addr = daddr->s6_addr32[3];
 			msg->msg_name = &sin;
 			msg->msg_namelen = sizeof(sin);
 do_udp_sendmsg:
diff -purN linux-2.6.0-test11/net/sched/sch_htb.c linux-2.5/net/sched/sch_htb.c
--- linux-2.6.0-test11/net/sched/sch_htb.c	2003-11-26 20:44:32.000000000 +0000
+++ linux-2.5/net/sched/sch_htb.c	2003-12-08 03:33:19.000000000 +0000
@@ -74,7 +74,7 @@
 #define HTB_HYSTERESIS 1/* whether to use mode hysteresis for speedup */
 #define HTB_QLOCK(S) spin_lock_bh(&(S)->dev->queue_lock)
 #define HTB_QUNLOCK(S) spin_unlock_bh(&(S)->dev->queue_lock)
-#define HTB_VER 0x3000d	/* major must be matched with number suplied by TC as version */
+#define HTB_VER 0x3000e	/* major must be matched with number suplied by TC as version */
 
 #if HTB_VER >> 16 != TC_HTB_PROTOVER
 #error "Mismatched sch_htb.c and pkt_sch.h"
@@ -290,6 +290,11 @@ static __inline__ struct htb_class *htb_
  * then finish and return direct queue.
  */
 #define HTB_DIRECT (struct htb_class*)-1
+static inline u32 htb_classid(struct htb_class *cl)
+{
+	return (cl && cl != HTB_DIRECT) ? cl->classid : TC_H_UNSPEC;
+}
+
 static struct htb_class *htb_classify(struct sk_buff *skb, struct Qdisc *sch)
 {
 	struct htb_sched *q = (struct htb_sched *)sch->data;
@@ -703,7 +708,7 @@ static int htb_enqueue(struct sk_buff *s
 
     sch->q.qlen++;
     sch->stats.packets++; sch->stats.bytes += skb->len;
-    HTB_DBG(1,1,"htb_enq_ok cl=%X skb=%p\n",cl?cl->classid:0,skb);
+    HTB_DBG(1,1,"htb_enq_ok cl=%X skb=%p\n",htb_classid(cl),skb);
     return NET_XMIT_SUCCESS;
 }
 
@@ -731,7 +736,7 @@ static int htb_requeue(struct sk_buff *s
 	    htb_activate (q,cl);
 
     sch->q.qlen++;
-    HTB_DBG(1,1,"htb_req_ok cl=%X skb=%p\n",cl?cl->classid:0,skb);
+    HTB_DBG(1,1,"htb_req_ok cl=%X skb=%p\n",htb_classid(cl),skb);
     return NET_XMIT_SUCCESS;
 }
 
@@ -1381,11 +1386,16 @@ static void htb_destroy(struct Qdisc* sc
 #ifdef HTB_RATECM
 	del_timer_sync (&q->rttim);
 #endif
+	/* This line used to be after htb_destroy_class call below
+	   and surprisingly it worked in 2.4. But it must precede it 
+	   because filter need its target class alive to be able to call
+	   unbind_filter on it (without Oops). */
+	htb_destroy_filters(&q->filter_list);
+	
 	while (!list_empty(&q->root)) 
 		htb_destroy_class (sch,list_entry(q->root.next,
 					struct htb_class,sibling));
 
-	htb_destroy_filters(&q->filter_list);
 	__skb_queue_purge(&q->direct_queue);
 }
 
