From: Paul Clements <paul.clements@steeleye.com>
Subject: Fix IO raid1/barrier problems that cause false IO errors
Patch-mainline: 2.6.17
References: 188278

When a filesystem sends a write barrier to md (raid1) and a driver under md
does not support barriers, rather than sending back the EOPNOTSUPP error and
having the filesystem fallback to non-barrier I/O, the write simply fails and
forces one or more of the disks out of the md array. 

There are two bugs that cause this errant behavior:

1) ENOTSUPP should be changed to EOPNOTSUPP, as that is the error code used to
signify that barriers are not supported

2) the rdev pending counts are not handled properly: if the barrier error comes
back before another device write completes (successfully), the pending counts
on the devices get confused (one gets double-decremented and the other is left
alone), and the devices cannot be removed from the array because they stay
"busy"


Acked-by: Neil Brown <neilb@suse.de>
Signed-off-by: Neil Brown <neilb@suse.de>

Index: linux-2.6.16/drivers/md/raid1.c
===================================================================
--- linux-2.6.16.orig/drivers/md/raid1.c	2006-06-27 08:53:14.000000000 +1000
+++ linux-2.6.16/drivers/md/raid1.c	2006-06-27 08:55:19.000000000 +1000
@@ -307,6 +307,7 @@
 	int mirror, behind = test_bit(R1BIO_BehindIO, &r1_bio->state);
 	conf_t *conf = mddev_to_conf(r1_bio->mddev);
 	struct bio *to_put = NULL;
+	int dec_pending = 1; /* decrement pending I/O count or not? */
 
 	if (bio->bi_size)
 		return 1;
@@ -315,7 +316,8 @@
 		if (r1_bio->bios[mirror] == bio)
 			break;
 
-	if (error == -ENOTSUPP && test_bit(R1BIO_Barrier, &r1_bio->state)) {
+	if (error == -EOPNOTSUPP && test_bit(R1BIO_Barrier, &r1_bio->state)) {
+		dec_pending = 0;
 		set_bit(BarriersNotsupp, &conf->mirrors[mirror].rdev->flags);
 		set_bit(R1BIO_BarrierRetry, &r1_bio->state);
 		r1_bio->mddev->barriers_work = 0;
@@ -394,8 +396,9 @@
 		raid_end_bio_io(r1_bio);
 	}
 
-	rdev_dec_pending(conf->mirrors[mirror].rdev, conf->mddev);
  out:
+	if (dec_pending)
+		rdev_dec_pending(conf->mirrors[mirror].rdev, conf->mddev);
 	if (to_put)
 		bio_put(to_put);
 
