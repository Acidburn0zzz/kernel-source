# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/05/10 22:48:57-07:00 davidm@tiger.hpl.hp.com 
#   ia64: Add support to the kernel unwinder for the ".save rp, r0" idiom.
#   
#   Based on patch by Keith Owens.
# 
# arch/ia64/kernel/head.S
#   2004/05/10 22:48:50-07:00 davidm@tiger.hpl.hp.com +2 -4
#   (start_ap): Terminate call-chain via "r0".
#   (start_kernel_thread): Likewise.
# 
# arch/ia64/kernel/unwind.c
#   2004/05/10 22:48:50-07:00 davidm@tiger.hpl.hp.com +52 -14
#   (unw): Add member "r0".
#   (read_only): New function.
#   (unw_access_gr): Reject attempts to write to a read-only save-location.
#   (unw_access_br): Likewise.
#   (unw_access_fr): Likewise.
#   (unw_access_ar): Likewise.
#   (unw_access_pr): Likewise.
#   (compile_reg): Emit UNW_INSN_MOVE_CONST for r0.
#   (run_script): Handle UNW_INSN_MOVE_CONST.
# 
# arch/ia64/kernel/unwind_i.h
#   2004/05/10 22:48:50-07:00 davidm@tiger.hpl.hp.com +1 -0
#   (unw_insn_opcode): Add UNW_INSN_MOVE_CONST.
# 
diff -Nru a/arch/ia64/kernel/head.S b/arch/ia64/kernel/head.S
--- a/arch/ia64/kernel/head.S	Fri May 21 02:27:01 2004
+++ b/arch/ia64/kernel/head.S	Fri May 21 02:27:01 2004
@@ -56,8 +56,7 @@
 GLOBAL_ENTRY(_start)
 start_ap:
 	.prologue
-	.save rp, r4		// terminate unwind chain with a NULL rp
-	mov r4=r0
+	.save rp, r0		// terminate unwind chain with a NULL rp
 	.body
 
 	rsm psr.i | psr.ic
diff -Nru a/arch/ia64/kernel/unwind.c b/arch/ia64/kernel/unwind.c
--- a/arch/ia64/kernel/unwind.c	Fri May 21 02:27:01 2004
+++ b/arch/ia64/kernel/unwind.c	Fri May 21 02:27:01 2004
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 1999-2003 Hewlett-Packard Co
+ * Copyright (C) 1999-2004 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  * Copyright (C) 2003 Fenghua Yu <fenghua.yu@intel.com>
  * 	- Change pt_regs_off() to make it less dependant on pt_regs structure.
@@ -89,6 +89,8 @@
 	/* list of unwind tables (one per load-module) */
 	struct unw_table *tables;
 
+	unsigned long r0;			/* constant 0 for r0 */
+
 	/* table of registers that prologues can save (and order in which they're saved): */
 	const unsigned char save_order[8];
 
@@ -239,7 +241,11 @@
 #endif
 };
 
-/* Unwind accessors.  */
+static inline int
+read_only (void *addr)
+{
+	return (unsigned long) ((char *) addr - (char *) &unw.r0) < sizeof(unw.r0);
+}
 
 /*
  * Returns offset of rREG in struct pt_regs.
@@ -274,6 +280,8 @@
 	return (struct pt_regs *) info->pt;
 }
 
+/* Unwind accessors.  */
+
 int
 unw_access_gr (struct unw_frame_info *info, int regnum, unsigned long *val, char *nat, int write)
 {
@@ -377,11 +385,15 @@
 	}
 
 	if (write) {
-		*addr = *val;
-		if (*nat)
-			*nat_addr |= nat_mask;
-		else
-			*nat_addr &= ~nat_mask;
+		if (read_only(addr))
+			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n");
+		else {
+			*addr = *val;
+			if (*nat)
+				*nat_addr |= nat_mask;
+			else
+				*nat_addr &= ~nat_mask;
+		}
 	} else {
 		if ((*nat_addr & nat_mask) == 0) {
 			*val = *addr;
@@ -420,7 +432,10 @@
 		return -1;
 	}
 	if (write)
-		*addr = *val;
+		if (read_only(addr))
+			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n");
+		else
+			*addr = *val;
 	else
 		*val = *addr;
 	return 0;
@@ -465,7 +480,10 @@
 	}
 
 	if (write)
-		*addr = *val;
+		if (read_only(addr))
+			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n");
+		else
+			*addr = *val;
 	else
 		*val = *addr;
 	return 0;
@@ -557,9 +575,12 @@
 		return -1;
 	}
 
-	if (write)
-		*addr = *val;
-	else
+	if (write) {
+		if (read_only(addr))
+			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n");
+		else
+			*addr = *val;
+	} else
 		*val = *addr;
 	return 0;
 }
@@ -574,9 +595,12 @@
 	if (!addr)
 		addr = &info->sw->pr;
 
-	if (write)
-		*addr = *val;
-	else
+	if (write) {
+		if (read_only(addr))
+			UNW_DPRINT(0, "unwind.%s: ignoring attempt to write read-only location\n");
+		else
+			*addr = *val;
+	} else
 		*val = *addr;
 	return 0;
 }
@@ -1407,6 +1431,9 @@
 				need_nat_info = 0;
 			}
 			val = unw.preg_index[UNW_REG_R4 + (rval - 4)];
+		} else if (rval == 0) {
+			opc = UNW_INSN_MOVE_CONST;
+			val = 0;
 		} else {
 			/* register got spilled to a scratch register */
 			opc = UNW_INSN_MOVE_SCRATCH;
@@ -1728,6 +1755,17 @@
 					   __FUNCTION__, dst, val);
 			}
 			break;
+
+		      case UNW_INSN_MOVE_CONST:
+			if (val == 0)
+				s[dst] = (unsigned long) &unw.r0;
+			else {
+				s[dst] = 0;
+				UNW_DPRINT(0, "unwind.%s: UNW_INSN_MOVE_CONST bad val=%ld\n",
+					   __FUNCTION__, val);
+			}
+			break;
+
 
 		      case UNW_INSN_MOVE_STACKED:
 			s[dst] = (unsigned long) ia64_rse_skip_regs((unsigned long *)state->bsp,
diff -Nru a/arch/ia64/kernel/unwind_i.h b/arch/ia64/kernel/unwind_i.h
--- a/arch/ia64/kernel/unwind_i.h	Fri May 21 02:27:01 2004
+++ b/arch/ia64/kernel/unwind_i.h	Fri May 21 02:27:01 2004
@@ -133,6 +133,7 @@
 	UNW_INSN_SETNAT_TYPE,		/* s[dst+1].nat.type = val */
 	UNW_INSN_LOAD,			/* s[dst] = *s[val] */
 	UNW_INSN_MOVE_SCRATCH,		/* s[dst] = scratch reg "val" */
+	UNW_INSN_MOVE_CONST,            /* s[dst] = constant reg "val" */
 };
 
 struct unw_insn {
