diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/mm/mempolicy.c sles/mm/mempolicy.c
--- sles-ref/mm/mempolicy.c	2004-11-12 12:18:45.663532800 +0100
+++ sles/mm/mempolicy.c	2004-11-12 12:24:25.027941568 +0100
@@ -901,7 +901,7 @@ sp_lookup(struct shared_policy *sp, unsi
 		struct sp_node *p = rb_entry(n, struct sp_node, nd);
 		if (start >= p->end) {
 			n = n->rb_right;
-		} else if (end < p->start) {
+		} else if (end <= p->start) {
 			n = n->rb_left;
 		} else {
 			break;
@@ -1009,11 +1009,10 @@ static int shared_policy_replace(struct 
 					up(&sp->sem);
 					return -ENOMEM;
 				}
-				n->end = end;
+				n->end = start;
 				sp_insert(sp, new2);
-			}
-			/* Old crossing beginning, but not end (easy) */
-			if (n->start < start && n->end > start)
+				break;
+			} else
 				n->end = start;
 		}
 		if (!next)
@@ -1060,11 +1059,11 @@ void mpol_free_shared_policy(struct shar
 	while (next) {
 		n = rb_entry(next, struct sp_node, nd);
 		next = rb_next(&n->nd);
-		rb_erase(&n->nd, &p->root);
 		mpol_free(n->policy);
 		kmem_cache_free(sn_cache, n);
 	}
 	up(&p->sem);
+	p->root = RB_ROOT;
 }
 
 /* assumes fs == KERNEL_DS */
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/mm/shmem.c sles/mm/shmem.c
--- sles-ref/mm/shmem.c	2004-11-12 12:21:07.498970536 +0100
+++ sles/mm/shmem.c	2004-11-12 12:23:29.861328168 +0100
@@ -1221,6 +1221,7 @@ shmem_get_inode(struct super_block *sb, 
 			spin_lock(&shmem_ilock);
 			list_add_tail(&info->list, &shmem_inodes);
 			spin_unlock(&shmem_ilock);
+			mpol_shared_policy_init(&info->policy);
 			break;
 		case S_IFDIR:
 			inode->i_nlink++;
@@ -1230,6 +1231,11 @@ shmem_get_inode(struct super_block *sb, 
 			inode->i_fop = &simple_dir_operations;
 			break;
 		case S_IFLNK:
+			/*
+			 * Must not load anything in the rbtree,
+			 * mpol_free_shared_policy will not be called.
+			 */
+			mpol_shared_policy_init(&info->policy);
 			break;
 		}
 	}
@@ -1905,7 +1911,9 @@ static struct inode *shmem_alloc_inode(s
 
 static void shmem_destroy_inode(struct inode *inode)
 {
-	mpol_free_shared_policy(&SHMEM_I(inode)->policy);
+	if ((inode->i_mode & S_IFMT) == S_IFREG) {
+		/* only struct inode is valid if it's an inline symlink */
+		mpol_free_shared_policy(&SHMEM_I(inode)->policy);
 	kmem_cache_free(shmem_inode_cachep, SHMEM_I(inode));
 }
 
