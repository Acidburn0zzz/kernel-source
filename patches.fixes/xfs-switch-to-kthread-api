From: Christoph Hellwig <hch@lst.de>
Subject: Switch kernel thread handling to the kthread_ API
References: 113237

[...] xfsbufd_task is NULL.  The only reason I see this could happen is
due to a race when the xfsbufd thread is started - xfsbufd_wakeup is
called before the child had a chance to run.  The patch below switches
xfsbufd startup to the kthread infrastructure that avoids this race, and
adds some small fixes to xfsbufd_wakeup.

Acked-by: Andreas Gruenbacher <agruen@suse.de>

---------------------
PatchSet 10021 
Date: 2005/08/31 09:37:36
Author: hch
Branch: HEAD
Tag: (none) 
Log:
Switch kernel thread handling to the kthread_ API

Members: 
	fs/xfs/linux-2.6/xfs_buf.c:1.202->1.203 
	fs/xfs/linux-2.6/xfs_super.c:1.341->1.342 
	fs/xfs/linux-2.6/xfs_vfs.c:1.63->1.64 
	fs/xfs/linux-2.6/xfs_vfs.h:1.52->1.53 

Index: linux-2.6-xfs/fs/xfs/linux-2.6/xfs_buf.c
diff -u linux-2.6-xfs/fs/xfs/linux-2.6/xfs_buf.c:1.202 linux-2.6-xfs/fs/xfs/linux-2.6/xfs_buf.c:1.203
--- linux-2.6-xfs/fs/xfs/linux-2.6/xfs_buf.c:1.202	Sun Aug 28 23:01:53 2005
+++ linux-2.6-xfs/fs/xfs/linux-2.6/xfs_buf.c	Wed Aug 31 01:37:36 2005
@@ -54,6 +54,7 @@
 #include <linux/percpu.h>
 #include <linux/blkdev.h>
 #include <linux/hash.h>
+#include <linux/kthread.h>
 
 #include "xfs_linux.h"
 
@@ -1742,9 +1743,7 @@
 }
 
 /* Defines for pagebuf daemon */
-STATIC DECLARE_COMPLETION(xfsbufd_done);
 STATIC struct task_struct *xfsbufd_task;
-STATIC int xfsbufd_active;
 STATIC int xfsbufd_force_flush;
 STATIC int xfsbufd_force_sleep;
 
@@ -1770,14 +1769,8 @@
 	xfs_buftarg_t		*target;
 	xfs_buf_t		*pb, *n;
 
-	/*  Set up the thread  */
-	daemonize("xfsbufd");
 	current->flags |= PF_MEMALLOC;
 
-	xfsbufd_task = current;
-	xfsbufd_active = 1;
-	barrier();
-
 	INIT_LIST_HEAD(&tmp);
 	do {
 		if (unlikely(freezing(current))) {
@@ -1825,9 +1818,9 @@
 			purge_addresses();
 
 		xfsbufd_force_flush = 0;
-	} while (xfsbufd_active);
+	} while (!kthread_should_stop());
 
-	complete_and_exit(&xfsbufd_done, 0);
+	return 0;
 }
 
 /*
@@ -1910,9 +1903,11 @@
 	if (!xfsdatad_workqueue)
 		goto out_destroy_xfslogd_workqueue;
 
-	error = kernel_thread(xfsbufd, NULL, CLONE_FS|CLONE_FILES);
-	if (error < 0)
+	xfsbufd_task = kthread_run(xfsbufd, NULL, "xfsbufd");
+	if (IS_ERR(xfsbufd_task)) {
+		error = PTR_ERR(xfsbufd_task);
 		goto out_destroy_xfsdatad_workqueue;
+	}
 	return 0;
 
  out_destroy_xfsdatad_workqueue:
@@ -1929,10 +1924,7 @@
 STATIC void
 xfs_buf_daemons_stop(void)
 {
-	xfsbufd_active = 0;
-	barrier();
-	wait_for_completion(&xfsbufd_done);
-
+	kthread_stop(xfsbufd_task);
 	destroy_workqueue(xfslogd_workqueue);
 	destroy_workqueue(xfsdatad_workqueue);
 }
Index: linux-2.6-xfs/fs/xfs/linux-2.6/xfs_super.c
diff -u linux-2.6-xfs/fs/xfs/linux-2.6/xfs_super.c:1.341 linux-2.6-xfs/fs/xfs/linux-2.6/xfs_super.c:1.342
--- linux-2.6-xfs/fs/xfs/linux-2.6/xfs_super.c:1.341	Sun Aug 28 23:00:29 2005
+++ linux-2.6-xfs/fs/xfs/linux-2.6/xfs_super.c	Wed Aug 31 01:37:36 2005
@@ -72,6 +72,7 @@
 #include <linux/mount.h>
 #include <linux/mempool.h>
 #include <linux/writeback.h>
+#include <linux/kthread.h>
 
 STATIC struct quotactl_ops linvfs_qops;
 STATIC struct super_operations linvfs_sops;
@@ -529,25 +530,16 @@
 {
 	long			timeleft;
 	vfs_t			*vfsp = (vfs_t *) arg;
-	struct list_head	tmp;
 	struct vfs_sync_work	*work, *n;
+	LIST_HEAD		(tmp);
 
-	daemonize("xfssyncd");
-
-	vfsp->vfs_sync_work.w_vfs = vfsp;
-	vfsp->vfs_sync_work.w_syncer = vfs_sync_worker;
-	vfsp->vfs_sync_task = current;
-	wmb();
-	wake_up(&vfsp->vfs_wait_sync_task);
-
-	INIT_LIST_HEAD(&tmp);
 	timeleft = (xfs_syncd_centisecs * HZ) / 100;
 	for (;;) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		timeleft = schedule_timeout(timeleft);
 		/* swsusp */
 		try_to_freeze();
-		if (vfsp->vfs_flag & VFS_UMOUNT)
+		if (kthread_should_stop())
 			break;
 
 		spin_lock(&vfsp->vfs_sync_lock);
@@ -576,10 +568,6 @@
 		}
 	}
 
-	vfsp->vfs_sync_task = NULL;
-	wmb();
-	wake_up(&vfsp->vfs_wait_sync_task);
-
 	return 0;
 }
 
@@ -587,13 +575,11 @@
 linvfs_start_syncd(
 	vfs_t			*vfsp)
 {
-	int			pid;
-
-	pid = kernel_thread(xfssyncd, (void *) vfsp,
-			CLONE_VM | CLONE_FS | CLONE_FILES);
-	if (pid < 0)
-		return -pid;
-	wait_event(vfsp->vfs_wait_sync_task, vfsp->vfs_sync_task);
+	vfsp->vfs_sync_work.w_syncer = vfs_sync_worker;
+	vfsp->vfs_sync_work.w_vfs = vfsp;
+	vfsp->vfs_sync_task = kthread_run(xfssyncd, vfsp, "xfssyncd");
+	if (IS_ERR(vfsp->vfs_sync_task))
+		return -PTR_ERR(vfsp->vfs_sync_task);
 	return 0;
 }
 
@@ -601,11 +587,7 @@
 linvfs_stop_syncd(
 	vfs_t			*vfsp)
 {
-	vfsp->vfs_flag |= VFS_UMOUNT;
-	wmb();
-
-	wake_up_process(vfsp->vfs_sync_task);
-	wait_event(vfsp->vfs_wait_sync_task, !vfsp->vfs_sync_task);
+	kthread_stop(vfsp->vfs_sync_task);
 }
 
 STATIC void
Index: linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.c
diff -u linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.c:1.63 linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.c:1.64
--- linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.c:1.63	Thu Jun 23 07:57:47 2005
+++ linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.c	Wed Aug 31 01:37:36 2005
@@ -264,7 +264,6 @@
 	bhv_head_init(VFS_BHVHEAD(vfsp), "vfs");
 	INIT_LIST_HEAD(&vfsp->vfs_sync_list);
 	spin_lock_init(&vfsp->vfs_sync_lock);
-	init_waitqueue_head(&vfsp->vfs_wait_sync_task);
 	init_waitqueue_head(&vfsp->vfs_wait_single_sync_task);
 	return vfsp;
 }
Index: linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.h
diff -u linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.h:1.52 linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.h:1.53
--- linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.h:1.52	Thu Jun 23 07:57:47 2005
+++ linux-2.6-xfs/fs/xfs/linux-2.6/xfs_vfs.h	Wed Aug 31 01:37:36 2005
@@ -65,7 +65,6 @@
 	spinlock_t		vfs_sync_lock;	/* work item list lock */
 	int 			vfs_sync_seq;	/* sync thread generation no. */
 	wait_queue_head_t	vfs_wait_single_sync_task;
-	wait_queue_head_t	vfs_wait_sync_task;
 } vfs_t;
 
 #define vfs_fbhv		vfs_bh.bh_first	/* 1st on vfs behavior chain */
@@ -96,7 +95,6 @@
 #define VFS_RDONLY		0x0001	/* read-only vfs */
 #define VFS_GRPID		0x0002	/* group-ID assigned from directory */
 #define VFS_DMI			0x0004	/* filesystem has the DMI enabled */
-#define VFS_UMOUNT		0x0008	/* unmount in progress */
 #define VFS_END			0x0008	/* max flag */
 
 #define SYNC_ATTR		0x0001	/* sync attributes */
