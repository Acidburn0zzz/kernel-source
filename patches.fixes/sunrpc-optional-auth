From: okir@suse.de
Subject: lockd: do not require lockd callbacks to have rpc authentication
References: 45168

The 2.6.8 sunrpc requires that all requests using AUTH_SYS and AUTH_NULL
come from a "known" IP address, i.e. an address to which we have exported
a file system. This is not true for lockd callbacks, among other things.

This patch changes allows bypassing the IP address lookup for these
authentication flavors for certain RPC procedure numbers.

Signed-off-by: okir@suse.de

Index: linux-2.6.10/fs/lockd/svc.c
===================================================================
--- linux-2.6.10.orig/fs/lockd/svc.c	2005-01-13 10:55:25.000000000 +0100
+++ linux-2.6.10/fs/lockd/svc.c	2005-01-13 10:56:49.000000000 +0100
@@ -218,6 +218,32 @@ lockd(struct svc_rqst *rqstp)
 	module_put_and_exit(0);
 }
 
+static int
+lockd_rqst_needs_auth(struct svc_rqst *rqstp)
+{
+	u32 proc = rqstp->rq_proc;
+
+	if (proc == 0
+	 || proc == NLMPROC_GRANTED
+	 || proc == NLMPROC_TEST_RES
+	 || proc == NLMPROC_LOCK_RES
+	 || proc == NLMPROC_CANCEL_RES
+	 || proc == NLMPROC_UNLOCK_RES
+	 || proc == NLMPROC_GRANTED_MSG
+	 || proc == NLMPROC_NSM_NOTIFY)
+		return 0;
+	return 1;
+}
+
+#ifdef CONFIG_STATD
+static int
+statd_rqst_needs_auth(struct svc_rqst *rqstp)
+{
+	/* statd is unauthenticated */
+	return 0;
+}
+#endif
+
 /*
  * Bring up the lockd process if it's not already up.
  */
@@ -515,6 +541,8 @@ struct svc_program	nlmsvc_program = {
 	.pg_name	= "lockd",		/* service name */
 	.pg_class	= "nfsd",		/* share authentication with nfsd */
 	.pg_stats	= &nlmsvc_stats,	/* stats table */
+
+ 	.pg_need_auth	= lockd_rqst_needs_auth,
 };
 
 #ifdef CONFIG_STATD
@@ -542,6 +570,8 @@ struct svc_program	nsmsvc_program = {
 	.pg_name	= "statd",		/* service name */
 	.pg_class	= "nfsd",		/* share authentication with nfsd */
 	.pg_stats	= &nsmsvc_stats,	/* stats table */
+
+	.pg_need_auth	= statd_rqst_needs_auth,
 };
 #endif
 
Index: linux-2.6.10/fs/nfsd/nfssvc.c
===================================================================
--- linux-2.6.10.orig/fs/nfsd/nfssvc.c	2005-01-03 16:28:33.000000000 +0100
+++ linux-2.6.10/fs/nfsd/nfssvc.c	2005-01-13 10:57:38.000000000 +0100
@@ -358,6 +358,14 @@ nfsd_dispatch(struct svc_rqst *rqstp, u3
 	return 1;
 }
 
+static int
+nfsd_rqst_needs_auth(struct svc_rqst *rqstp)
+{
+	if (rqstp->rq_proc == 0)
+		return 0;
+	return 1;
+}
+
 extern struct svc_version nfsd_version2, nfsd_version3, nfsd_version4;
 
 static struct svc_version *	nfsd_version[] = {
@@ -378,4 +386,6 @@ struct svc_program		nfsd_program = {
 	.pg_name		= "nfsd",		/* program name */
 	.pg_class		= "nfsd",		/* authentication class */
 	.pg_stats		= &nfsd_svcstats,	/* version table */
+
+	.pg_need_auth		= nfsd_rqst_needs_auth,
 };
Index: linux-2.6.10/include/linux/sunrpc/svc.h
===================================================================
--- linux-2.6.10.orig/include/linux/sunrpc/svc.h	2005-01-13 10:55:26.000000000 +0100
+++ linux-2.6.10/include/linux/sunrpc/svc.h	2005-01-13 10:55:36.000000000 +0100
@@ -255,6 +255,8 @@ struct svc_program {
 	struct svc_stat *	pg_stats;	/* rpc statistics */
 	/* Override authentication. NULL means use default */
 	int			(*pg_authenticate)(struct svc_rqst *, u32 *);
+	/* Simpler */
+	int			(*pg_need_auth)(struct svc_rqst *);
 };
 
 /*
Index: linux-2.6.10/net/sunrpc/svcauth_unix.c
===================================================================
--- linux-2.6.10.orig/net/sunrpc/svcauth_unix.c	2005-01-03 16:28:36.000000000 +0100
+++ linux-2.6.10/net/sunrpc/svcauth_unix.c	2005-01-13 10:55:36.000000000 +0100
@@ -333,6 +333,7 @@ void svcauth_unix_purge(void)
 static int
 svcauth_null_accept(struct svc_rqst *rqstp, u32 *authp)
 {
+	struct svc_program *prog = rqstp->rq_server->sv_program;
 	struct kvec	*argv = &rqstp->rq_arg.head[0];
 	struct kvec	*resv = &rqstp->rq_res.head[0];
 	int		rv=0;
@@ -359,9 +360,10 @@ svcauth_null_accept(struct svc_rqst *rqs
 	if (rqstp->rq_cred.cr_group_info == NULL)
 		return SVC_DROP; /* kmalloc failure - client must retry */
 
-	/* Put NULL verifier */
-	svc_putu32(resv, RPC_AUTH_NULL);
-	svc_putu32(resv, 0);
+	if (prog->pg_need_auth && !prog->pg_need_auth(rqstp)) {
+		rv = SVC_OK;
+		goto accepted;
+	}
 
 	strcpy(key.m_class, rqstp->rq_server->sv_program->pg_class);
 	key.m_addr = rqstp->rq_addr.sin_addr;
@@ -391,6 +393,11 @@ svcauth_null_accept(struct svc_rqst *rqs
 	if (rqstp->rq_client == NULL && rqstp->rq_proc != 0)
 		*authp = rpc_autherr_badcred;
 
+accepted:
+	/* Put NULL verifier */
+	svc_putu32(resv, RPC_AUTH_NULL);
+	svc_putu32(resv, 0);
+
 	return rv;
 }
 
@@ -420,6 +427,7 @@ struct auth_ops svcauth_null = {
 int
 svcauth_unix_accept(struct svc_rqst *rqstp, u32 *authp)
 {
+	struct svc_program *prog = rqstp->rq_server->sv_program;
 	struct kvec	*argv = &rqstp->rq_arg.head[0];
 	struct kvec	*resv = &rqstp->rq_res.head[0];
 	struct svc_cred	*cred = &rqstp->rq_cred;
@@ -458,6 +466,10 @@ svcauth_unix_accept(struct svc_rqst *rqs
 		return SVC_DENIED;
 	}
 
+	if (prog->pg_need_auth && !prog->pg_need_auth(rqstp)) {
+		rv = SVC_OK;
+		goto accepted;
+	}
 
 	strcpy(key.m_class, rqstp->rq_server->sv_program->pg_class);
 	key.m_addr = rqstp->rq_addr.sin_addr;
@@ -486,6 +498,7 @@ svcauth_unix_accept(struct svc_rqst *rqs
 	if (rv  == SVC_OK && rqstp->rq_client == NULL && rqstp->rq_proc != 0)
 		goto badcred;
 
+accepted:
 	/* Put NULL verifier */
 	svc_putu32(resv, RPC_AUTH_NULL);
 	svc_putu32(resv, 0);
