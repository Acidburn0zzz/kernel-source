garloff@suse.de
Heiko.Carstens@de.ibm.com

Bugfix

 > > I just experienced a stack overflow (see below for part of the call trace)
 > > when an lldd returns SCSI_MLQUEUE_DEVICE_BUSY. Problem seems to be that
 > > scsi_dispatch_cmd calls scsi_queue_insert if the LLDD queuecommand function
 > > failed.
 >
 > Could you do some more debugging...there's something wierd going on
 > here.  a SCSI_MLQUEUE_DEVICE_BUSY return sets device_blocked.  As long
 > as sdev->max_device_blocked is two or more, this should cause an exit
 > from the next scsi_request_fn() (at the if(!req ||
 > !scsi_dev_queue_ready(q, sdev))

This happened when sending out the inquiry command and the LLDD was in
recovery for the specific LUN and returned SCSI_MLQUEUE_DEVICE_BUSY.
Problem is that max_device_blocked gets set _after_ the inquiry command
finished. In this specific case max_device_blocked was 0 and thus the
device was never blocked resulting in the observed stack overflow.
I moved the initializazion of max_device_blocked from scsi_add_lun to
sdev_alloc_sdev and the problem is gone. See patch below.
Thanks for pointing out where to look at!

diff -uNrp linux-2.6.5/drivers/scsi/scsi_scan.c linux-2.6.5.blocked/drivers/scsi/scsi_scan.c
--- linux-2.6.5/drivers/scsi/scsi_scan.c	2004-05-20 16:08:04.985973436 +0200
+++ linux-2.6.5.blocked/drivers/scsi/scsi_scan.c	2004-05-20 16:12:24.188384101 +0200
@@ -228,6 +228,10 @@ static struct scsi_device *scsi_alloc_sd
 	INIT_LIST_HEAD(&sdev->starved_entry);
 	spin_lock_init(&sdev->list_lock);
 
+	/* if the device needs this changing, it may do so in the detect
+	 * function */
+	sdev->max_device_blocked = SCSI_DEFAULT_DEVICE_BLOCKED;
+
 	/*
 	 * Some low level driver could use device->type
 	 */
@@ -637,10 +641,6 @@ static int scsi_add_lun(struct scsi_devi
 		spin_unlock_irqrestore(sdev->host->host_lock, flags);
 	}
 
-	/* if the device needs this changing, it may do so in the detect
-	 * function */
-	sdev->max_device_blocked = SCSI_DEFAULT_DEVICE_BLOCKED;
-
 	sdev->use_10_for_rw = 1;
 
 	if (*bflags & BLIST_MS_SKIP_PAGE_08)
