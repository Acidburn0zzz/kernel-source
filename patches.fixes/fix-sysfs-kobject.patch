Broken out patch from 2.6.6-mm2, original patch was bk-driver-core.patch

bk://kernel.bkbits.net/gregkh/linux/driver-2.6
maneesh@in.ibm.com|ChangeSet|20040511234350|39412 maneesh

# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/05/11 16:43:50-07:00 maneesh@in.ibm.com 
#   [PATCH] kobject/sysfs race fix
#   
#   The following patch fixes the race involved between unregistering a kobject
#   and simultaneously opeing a corresponding attribute file in sysfs.
#   
#   Ideally sysfs should take a ref.  to the kobject as long as it has dentries
#   referring to the kobjects, but because of current limitations in
#   module/kobject ref counting, sysfs's pinning of kobject leads to
#   hang/delays in rmmod of certain modules.  The patch checks for unhashed
#   dentries in check_perm() while opening a sysfs file.  If the dentry is
#   still hashed then it goes ahead and takes the ref to kobject.  This done
#   under the per dentry lock.  It does this in the inline routine
#   sysfs_get_kobject(dentry).
# 
# fs/sysfs/sysfs.h
#   2004/04/14 11:26:50-07:00 maneesh@in.ibm.com +13 -0
#   kobject/sysfs race fix
# 
# fs/sysfs/file.c
#   2004/04/14 11:26:50-07:00 maneesh@in.ibm.com +1 -1
#   kobject/sysfs race fix
# 
# fs/sysfs/bin.c
#   2004/04/14 11:26:50-07:00 maneesh@in.ibm.com +1 -1
#   kobject/sysfs race fix
# 
# ChangeSet
#   2004/05/11 16:31:46-07:00 maneesh@in.ibm.com 
#   [PATCH] kobject_set_name - error handling
#   
#   1) kobject_set_name-cleanup-01.patch
#   
#   This patch corrects the following by checking the reutrn code from
#   kobject_set_name().
#   
#   bus_add_driver()
#   bus_register()
#   sys_dev_register()
#   
#   
#   
#   o The following patch cleansup the kobject_set_name() users. Basically checking
#     return code from kobject_set_name(). There can be error returns like -ENOMEM
#     or -EFAULT from kobject_set_name() if the name length exceeds KOBJ_NAME_LEN.
# 
# drivers/base/sys.c
#   2004/05/11 09:20:09-07:00 maneesh@in.ibm.com +4 -1
#   kobject_set_name - error handling
# 
# drivers/base/bus.c
#   2004/05/11 09:21:15-07:00 maneesh@in.ibm.com +9 -2
#   kobject_set_name - error handling
# 
# ChangeSet
#   2004/05/05 15:10:00-07:00 bellucda@tiscali.it 
#   [PATCH] missing audit in bus_register()
#   
#   |How about using a goto on the error path to clean up properly
#   |instead of the different return sections.
#   
#   .. here goes Take 2:
# 
# drivers/base/bus.c
#   2004/04/28 11:45:19-07:00 bellucda@tiscali.it +18 -3
#   missing audit in bus_register()
# 
# ChangeSet
#   2004/05/05 14:40:43-07:00 greg@kroah.com 
#   Driver core: handle error if we run out of memory in kmap code
# 
# drivers/base/map.c
#   2004/05/05 07:39:44-07:00 greg@kroah.com +7 -0
#   Driver core: handle error if we run out of memory in kmap code
# 
# ChangeSet
#   2004/05/02 20:30:19-07:00 kenn@linux.ie 
#   [PATCH] Re: Platform device matching
#   
#   On Mon, Apr 26, 2004 at 12:27:33AM +0100, Russell King wrote:
#   > So, this comment needs updating:
#   >
#   >  *      So, extract the <name> from the device, and compare it against
#   >  *      the name of the driver. Return whether they match or not.
#   
#   Want a patch?
# 
# drivers/base/platform.c
#   2004/04/25 16:33:43-07:00 kenn@linux.ie +3 -2
#   Re: Platform device matching
# 

diff -Nru a/drivers/base/map.c b/drivers/base/map.c
--- a/drivers/base/map.c	Wed May 12 20:27:41 2004
+++ b/drivers/base/map.c	Wed May 12 20:27:41 2004
@@ -138,6 +138,13 @@
 	struct kobj_map *p = kmalloc(sizeof(struct kobj_map), GFP_KERNEL);
 	struct probe *base = kmalloc(sizeof(struct probe), GFP_KERNEL);
 	int i;
+
+	if ((p == NULL) || (base == NULL)) {
+		kfree(p);
+		kfree(base);
+		return NULL;
+	}
+
 	memset(base, 0, sizeof(struct probe));
 	base->dev = 1;
 	base->range = ~0;
diff -Nru a/drivers/base/platform.c b/drivers/base/platform.c
--- a/drivers/base/platform.c	Wed May 12 20:27:41 2004
+++ b/drivers/base/platform.c	Wed May 12 20:27:41 2004
@@ -57,8 +57,9 @@
  *	type of device, like "pci" or "floppy", and <instance> is the 
  *	enumerated instance of the device, like '0' or '42'.
  *	Driver IDs are simply "<name>". 
- *	So, extract the <name> from the device, and compare it against 
- *	the name of the driver. Return whether they match or not.
+ *	So, extract the <name> from the platform_device structure, 
+ *	and compare it against the name of the driver. Return whether 
+ *	they match or not.
  */
 
 static int platform_match(struct device * dev, struct device_driver * drv)
diff -Nru a/fs/sysfs/bin.c b/fs/sysfs/bin.c
--- a/fs/sysfs/bin.c	Wed May 12 20:27:41 2004
+++ b/fs/sysfs/bin.c	Wed May 12 20:27:41 2004
@@ -94,7 +94,7 @@
 
 static int open(struct inode * inode, struct file * file)
 {
-	struct kobject * kobj = kobject_get(file->f_dentry->d_parent->d_fsdata);
+	struct kobject *kobj = sysfs_get_kobject(file->f_dentry->d_parent);
 	struct bin_attribute * attr = file->f_dentry->d_fsdata;
 	int error = -EINVAL;
 
diff -Nru a/fs/sysfs/file.c b/fs/sysfs/file.c
--- a/fs/sysfs/file.c	Wed May 12 20:27:41 2004
+++ b/fs/sysfs/file.c	Wed May 12 20:27:41 2004
@@ -238,7 +238,7 @@
 
 static int check_perm(struct inode * inode, struct file * file)
 {
-	struct kobject * kobj = kobject_get(file->f_dentry->d_parent->d_fsdata);
+	struct kobject *kobj = sysfs_get_kobject(file->f_dentry->d_parent);
 	struct attribute * attr = file->f_dentry->d_fsdata;
 	struct sysfs_buffer * buffer;
 	struct sysfs_ops * ops = NULL;
diff -Nru a/fs/sysfs/sysfs.h b/fs/sysfs/sysfs.h
--- a/fs/sysfs/sysfs.h	Wed May 12 20:27:41 2004
+++ b/fs/sysfs/sysfs.h	Wed May 12 20:27:41 2004
@@ -11,3 +11,16 @@
 
 extern int sysfs_create_subdir(struct kobject *, const char *, struct dentry **);
 extern void sysfs_remove_subdir(struct dentry *);
+
+
+static inline struct kobject *sysfs_get_kobject(struct dentry *dentry)
+{
+	struct kobject * kobj = NULL;
+
+	spin_lock(&dentry->d_lock);
+	if (!d_unhashed(dentry))
+		kobj = kobject_get(dentry->d_fsdata);
+	spin_unlock(&dentry->d_lock);
+
+	return kobj;
+}
