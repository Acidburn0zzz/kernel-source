From: Karsten Keil <kkeil@suse.de>
Subject: Fix SMP deadlock in kernelcapi
Patch-mainline: 2.6.10-rc3
Suse-bugzilla: 47191

fix a DEADLOCK in kernelcapi if a controller is added and already applications are exists
some additional minor cleanups 

Signed-off-by: Karsten Keil <kkeil@suse.de>

diff -ur linux-2.6.5.xx/drivers/isdn/capi/capidrv.c linux-2.6.5/drivers/isdn/capi/capidrv.c
--- linux-2.6.5.xx/drivers/isdn/capi/capidrv.c	2004-10-13 14:58:50.602120814 +0200
+++ linux-2.6.5/drivers/isdn/capi/capidrv.c	2004-10-13 14:59:43.769651323 +0200
@@ -2057,6 +2057,10 @@
 		return -1;
 	}
 	card->myid = card->interface.channels;
+	memset(card->bchans, 0, sizeof(capidrv_bchan) * card->nbchan);
+	for (i = 0; i < card->nbchan; i++) {
+		card->bchans[i].contr = card;
+	}
 
 	spin_lock_irqsave(&global_lock, flags);
 	card->next = global.contr_list;
@@ -2064,11 +2068,6 @@
 	global.ncontr++;
 	spin_unlock_irqrestore(&global_lock, flags);
 
-	memset(card->bchans, 0, sizeof(capidrv_bchan) * card->nbchan);
-	for (i = 0; i < card->nbchan; i++) {
-		card->bchans[i].contr = card;
-	}
-
 	cmd.command = ISDN_STAT_RUN;
 	cmd.driver = card->myid;
 	card->interface.statcallb(&cmd);
@@ -2076,10 +2075,9 @@
 	card->cipmask = 0x1FFF03FF;	/* any */
 	card->cipmask2 = 0;
 
-	send_listen(card);
-
 	card->listentimer.data = (unsigned long)card;
 	card->listentimer.function = listentimerfunc;
+	send_listen(card);
 	mod_timer(&card->listentimer, jiffies + 60*HZ);
 
 	printk(KERN_INFO "%s: now up (%d B channels)\n",
diff -ur linux-2.6.5.xx/drivers/isdn/capi/kcapi.c linux-2.6.5/drivers/isdn/capi/kcapi.c
--- linux-2.6.5.xx/drivers/isdn/capi/kcapi.c	2004-10-13 14:58:59.727637307 +0200
+++ linux-2.6.5/drivers/isdn/capi/kcapi.c	2004-10-13 15:14:24.244236069 +0200
@@ -148,7 +148,10 @@
 {
 	card = capi_ctr_get(card);
 
-	card->register_appl(card, applid, rparam);
+	if (card)
+		card->register_appl(card, applid, rparam);
+	else
+		printk(KERN_WARNING "%s: cannot get card resources\n", __FUNCTION__);
 }
 
 
@@ -171,10 +174,15 @@
 	if (showcapimsgs & 1) {
 	        printk(KERN_DEBUG "kcapi: notify up contr %d\n", contr);
 	}
-
+	if (!card) {
+		printk(KERN_WARNING "%s: invalid contr %d\n", __FUNCTION__, contr);
+		return;
+	}
 	for (applid = 1; applid <= CAPI_MAXAPPL; applid++) {
 		ap = get_capi_appl_by_nr(applid);
-		if (ap && ap->callback && !ap->release_in_progress)
+		if (!ap || ap->release_in_progress) continue;
+		register_appl(card, applid, &ap->rparam);
+		if (ap->callback && !ap->release_in_progress)
 			ap->callback(KCI_CONTRUP, contr, &card->profile);
 	}
 }
@@ -317,19 +325,8 @@
 
 void capi_ctr_ready(struct capi_ctr * card)
 {
-	u16 appl;
-	struct capi20_appl *ap;
-
 	card->cardstate = CARD_RUNNING;
 
-	down(&controller_sem);
-	for (appl = 1; appl <= CAPI_MAXAPPL; appl++) {
-		ap = get_capi_appl_by_nr(appl);
-		if (!ap || ap->release_in_progress) continue;
-		register_appl(card, appl, &ap->rparam);
-	}
-	up(&controller_sem);
-
         printk(KERN_NOTICE "kcapi: card %d \"%s\" ready.\n",
 	       card->cnr, card->name);
 
diff -ur linux-2.6.5.xx/drivers/isdn/hardware/avm/c4.c linux-2.6.5/drivers/isdn/hardware/avm/c4.c
--- linux-2.6.5.xx/drivers/isdn/hardware/avm/c4.c	2004-10-13 14:59:36.513626038 +0200
+++ linux-2.6.5/drivers/isdn/hardware/avm/c4.c	2004-10-13 14:59:43.774649963 +0200
@@ -662,15 +662,16 @@
 
 static irqreturn_t c4_handle_interrupt(avmcard *card)
 {
+	unsigned long flags;
 	u32 status;
 
-	spin_lock(&card->lock);
+	spin_lock_irqsave(&card->lock, flags);
 	status = c4inmeml(card->mbase+DOORBELL);
 
 	if (status & DBELL_RESET_HOST) {
 		u_int i;
 		c4outmeml(card->mbase+PCI_OUT_INT_MASK, 0x0c);
-		spin_unlock(&card->lock);
+		spin_unlock_irqrestore(&card->lock, flags);
 		if (card->nlogcontr == 0)
 			return IRQ_HANDLED;
 		printk(KERN_ERR "%s: unexpected reset\n", card->name);
@@ -686,7 +687,7 @@
 
 	status &= (DBELL_UP_HOST | DBELL_DOWN_HOST);
 	if (!status) {
-		spin_unlock(&card->lock);
+		spin_unlock_irqrestore(&card->lock, flags);
 		return IRQ_HANDLED;
 	}
 	c4outmeml(card->mbase+DOORBELL, status);
@@ -709,7 +710,7 @@
 			c4_dispatch_tx(card);
 		}
 	}
-	spin_unlock(&card->lock);
+	spin_unlock_irqrestore(&card->lock, flags);
 	return IRQ_HANDLED;
 }
 
