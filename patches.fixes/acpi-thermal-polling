From: Thomas Renninger <trenn@suse.de>
Subject: [ACPI] Leave thermal passive cooling when machine cooled down
References: 98178

Patch to leave thermal passive cooling when machine cooled down.
Without this patch the polling frequency will always stay at
passive cooling trip point polling frequency (tsp - BIOS) instead of
tzp value (BIOS) or the possibly overridden value by
/proc/acpi/thermal_zone/*/polling_frequency.

This will cause critical shutdowns on hot machines with a high tsp
value exported by BIOS (e.g. the debugged machine (Thinkpad) exported
a value of 600 which means in passive mode the temperature is only polled
each 60 seconds).

Acked-by: okir@suse.de

--- x/drivers/acpi/thermal.c.orig	2005-08-29 01:41:01.000000000 +0200
+++ y/drivers/acpi/thermal.c	2005-09-13 15:07:54.000000000 +0200
@@ -514,7 +514,7 @@
 acpi_thermal_passive (
 	struct acpi_thermal	*tz)
 {
-	int			result = 0;
+	int			result = 1;
 	struct acpi_thermal_passive *passive = NULL;
 	int			trend = 0;
 	int			i = 0;
@@ -540,7 +540,7 @@
 			trend, passive->tc1, tz->temperature, 
 			tz->last_temperature, passive->tc2, 
 			tz->temperature, passive->temperature));
-		tz->trips.passive.flags.enabled = 1;
+		passive->flags.enabled = 1;
 		/* Heating up? */
 		if (trend > 0)
 			for (i=0; i<passive->devices.count; i++)
@@ -548,11 +548,24 @@
 					passive->devices.handles[i], 
 					ACPI_PROCESSOR_LIMIT_INCREMENT);
 		/* Cooling off? */
-		else if (trend < 0)
+		else if (trend < 0){
 			for (i=0; i<passive->devices.count; i++)
-				acpi_processor_set_thermal_limit(
-					passive->devices.handles[i], 
-					ACPI_PROCESSOR_LIMIT_DECREMENT);
+				// assume that we are on highest freq/lowest thrott
+				// and can leave passive mode, even in error case
+				if (!acpi_processor_set_thermal_limit(
+					    passive->devices.handles[i], 
+					    ACPI_PROCESSOR_LIMIT_DECREMENT))
+					result = 0;
+			// Leave cooling mode, even we the temp might higher than trip point.
+			// This is because some machines might have long thermal polling frequencies
+			// (tsp) defined. We will fall back into passive mode in next cycle (probably quicker)
+			if (result){
+				passive->flags.enabled = 0;
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
+						  "Disabling passive cooling, still above threshold,"
+						  " but we are cooling down\n"));
+			}
+		}
 	}
 
 	/*
@@ -562,13 +575,14 @@
 	 * and avoid thrashing around the passive trip point.  Note that we
 	 * assume symmetry.
 	 */
-	else if (tz->trips.passive.flags.enabled) {
+	else if (passive->flags.enabled) {
 		for (i=0; i<passive->devices.count; i++)
-			result = acpi_processor_set_thermal_limit(
-				passive->devices.handles[i], 
-				ACPI_PROCESSOR_LIMIT_DECREMENT);
-		if (result == 1) {
-			tz->trips.passive.flags.enabled = 0;
+			if (!acpi_processor_set_thermal_limit(
+				    passive->devices.handles[i], 
+				    ACPI_PROCESSOR_LIMIT_DECREMENT))
+				result = 0;
+		if (result) {
+			passive->flags.enabled = 0;
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
 				"Disabling passive cooling (zone is cool)\n"));
 		}
@@ -720,15 +734,13 @@
 	 * Again, separated from the above two to allow independent policy
 	 * decisions.
 	 */
-	if (tz->trips.critical.flags.enabled)
-		tz->state.critical = 1;
-	if (tz->trips.hot.flags.enabled)
-		tz->state.hot = 1;
-	if (tz->trips.passive.flags.enabled)
-		tz->state.passive = 1;
+	tz->state.critical = tz->trips.critical.flags.enabled;
+	tz->state.hot = tz->trips.hot.flags.enabled;
+	tz->state.passive = tz->trips.passive.flags.enabled;
+	tz->state.active = 0;
 	for (i=0; i<ACPI_THERMAL_MAX_ACTIVE; i++)
-		if (tz->trips.active[i].flags.enabled)
-			tz->state.active = 1;
+		tz->state.active |= tz->trips.active[i].flags.enabled;
+			
 
 	/*
 	 * Calculate Sleep Time
--- x/drivers/acpi/processor_thermal.c.orig	2005-08-29 01:41:01.000000000 +0200
+++ y/drivers/acpi/processor_thermal.c	2005-09-13 15:06:51.000000000 +0200
@@ -139,9 +139,11 @@
 	if (cpufreq_thermal_reduction_pctg[cpu] >= 20) {
 		cpufreq_thermal_reduction_pctg[cpu] -= 20;
 		cpufreq_update_policy(cpu);
+		// We reached max freq again and can leave passive mode
+		if (cpufreq_thermal_reduction_pctg[cpu] == 0)
+			return 1;
 		return 0;
 	}
-
 	return -ERANGE;
 }
 
@@ -206,7 +208,7 @@
 	int			result = 0;
 	struct acpi_processor	*pr = NULL;
 	struct acpi_device	*device = NULL;
-	int			tx = 0;
+	int			tx = 0, max_tx_px = 0;
 
 	ACPI_FUNCTION_TRACE("acpi_processor_set_thermal_limit");
 
@@ -265,9 +267,11 @@
 		/* if going down: T-states first, P-states later */
 
 		if (pr->flags.throttling) {
-			if (tx == 0)
+			if (tx == 0){
+				max_tx_px = 1;
 				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					"At minimum throttling state\n"));
+			}
 			else {
 				tx--;
 				goto end;
@@ -275,10 +279,15 @@
 		}
 
 		result = acpi_thermal_cpufreq_decrease(pr->id);
-		if (result == -ERANGE)
+		if (result){
+			// We only could get -ERANGE, 1 or 0.
+			// In the first two cases we reached max freq again.
 			ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 					"At minimum performance state\n"));
-
+			max_tx_px = 1;
+		}
+		else
+			max_tx_px = 0;
 		break;
 	}
 
@@ -298,7 +307,10 @@
 	} else
 		result = 0;
 
-	return_VALUE(result);
+	if (max_tx_px)
+		return_VALUE(1);
+	else
+		return_VALUE(result);
 }
 
 
