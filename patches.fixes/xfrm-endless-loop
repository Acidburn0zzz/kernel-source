From: Olaf Kirch <okir@suse.de>
Subject: Fix infinite loop in xfrm_lookup
References: 117749, 115200

It seems that the route xfrm_lookup is given on input can go
away when it sleeps.

Signed-off-by: Olaf Kirch <okir@suse.de>

 net/ipv4/route.c       |   25 ++++++++++++++++---------
 net/xfrm/xfrm_policy.c |   16 ++++++++++++++++
 2 files changed, 32 insertions(+), 9 deletions(-)

diff -r df2df438c970 net/ipv4/route.c
--- a/net/ipv4/route.c	Mon Feb  6 14:08:26 2006 -0500
+++ b/net/ipv4/route.c	Mon Feb  6 15:52:09 2006 -0500
@@ -2609,18 +2609,25 @@ int ip_route_output_flow(struct rtable *
 {
 	int err;
 
-	if ((err = __ip_route_output_key(rp, flp)) != 0)
-		return err;
-
-	if (flp->proto) {
-		if (!flp->fl4_src)
-			flp->fl4_src = (*rp)->rt_src;
-		if (!flp->fl4_dst)
-			flp->fl4_dst = (*rp)->rt_dst;
-		return xfrm_lookup((struct dst_entry **)rp, flp, sk, flags);
-	}
-
-	return 0;
+	if (flp->proto == 0) {
+		err = __ip_route_output_key(rp, flp);
+	} else {
+		u32 fl_src = flp->fl4_src, fl_dst = flp->fl4_dst;
+		int repeat = 1;
+
+		do {
+			if ((err = __ip_route_output_key(rp, flp)) != 0)
+				break;
+
+			if (!fl_src)
+				flp->fl4_src = (*rp)->rt_src;
+			if (!fl_dst)
+				flp->fl4_dst = (*rp)->rt_dst;
+			err = xfrm_lookup((struct dst_entry **)rp, flp, sk, flags);
+		} while (err == -EAGAIN && repeat--);
+	}
+
+	return err;
 }
 
 EXPORT_SYMBOL_GPL(ip_route_output_flow);
diff -r df2df438c970 net/xfrm/xfrm_policy.c
--- a/net/xfrm/xfrm_policy.c	Mon Feb  6 14:08:26 2006 -0500
+++ b/net/xfrm/xfrm_policy.c	Mon Feb  6 15:52:09 2006 -0500
@@ -786,7 +786,22 @@ int xfrm_lookup(struct dst_entry **dst_p
 	u16 family = dst_orig->ops->family;
 	u8 dir = policy_to_flow_dir(XFRM_POLICY_OUT);
 	u32 sk_sid = security_sk_sid(sk, fl, dir);
+	int loops = 0;
+
 restart:
+	if (loops && dst_orig && dst_orig->obsolete > 0) {
+		printk(KERN_NOTICE "xfrm_lookup: route is stale (obsolete=%d, loops=%d)\n",
+				dst_orig->obsolete, loops);
+		err = -EAGAIN;
+		goto error_nopol;
+	}
+	if (unlikely(++loops > 10)) {
+		printk(KERN_NOTICE "xfrm_lookup bailing out after %d loops\n", loops);
+		dump_stack();
+		err = -EHOSTUNREACH;
+		goto error_nopol;
+	}
+
 	genid = atomic_read(&flow_cache_genid);
 	policy = NULL;
 	if (sk && sk->sk_policy[1])
@@ -854,6 +869,7 @@ restart:
 				}
 				if (nx == -EAGAIN ||
 				    genid != atomic_read(&flow_cache_genid)) {
+					printk(KERN_NOTICE "xfrm_tmpl_resolve says EAGAIN, try again\n");
 					xfrm_pol_put(policy);
 					goto restart;
 				}
@@ -903,8 +919,9 @@ restart:
 	return 0;
 
 error:
+	xfrm_pol_put(policy);
+error_nopol:
 	dst_release(dst_orig);
-	xfrm_pol_put(policy);
 	*dst_p = NULL;
 	return err;
 }
