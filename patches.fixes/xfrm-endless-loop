From: Olaf Kirch <okir@suse.de>
Subject: Fix infinite loop in xfrm_lookup
References: 117749, 115200

It seems that the route xfrm_lookup is given on input can go
away when it sleeps.

Signed-off-by: Olaf Kirch <okir@suse.de>

 net/ipv4/route.c       |   25 ++++++++++++++++---------
 net/xfrm/xfrm_policy.c |   38 +++++++++++++++++++++++++++++++++-----
 2 files changed, 49 insertions(+), 14 deletions(-)

Index: build/net/xfrm/xfrm_policy.c
===================================================================
--- build.orig/net/xfrm/xfrm_policy.c
+++ build/net/xfrm/xfrm_policy.c
@@ -786,7 +786,23 @@ int xfrm_lookup(struct dst_entry **dst_p
 	u16 family = dst_orig->ops->family;
 	u8 dir = policy_to_flow_dir(XFRM_POLICY_OUT);
 	u32 sk_sid = security_sk_sid(sk, fl, dir);
+	int loops = 0;
+
 restart:
+	if (dst_orig && !dst_check(dst_orig, 0)) {
+		printk(KERN_NOTICE "xfrm_lookup: IPv4 route is stale (obsolete=%u, loops=%d)\n",
+				dst_orig->obsolete, loops);
+		dump_stack();
+		err = -EAGAIN;
+		goto error_nopol;
+	}
+	if (unlikely(++loops > 10)) {
+		printk(KERN_NOTICE "xfrm_lookup bailing out after %d loops\n", loops);
+		dump_stack();
+		err = -EHOSTUNREACH;
+		goto error_nopol;
+	}
+
 	genid = atomic_read(&flow_cache_genid);
 	policy = NULL;
 	if (sk && sk->sk_policy[1])
@@ -854,6 +870,7 @@ restart:
 				}
 				if (nx == -EAGAIN ||
 				    genid != atomic_read(&flow_cache_genid)) {
+					printk(KERN_NOTICE "xfrm_tmpl_resolve says EAGAIN, try again\n");
 					xfrm_pol_put(policy);
 					goto restart;
 				}
@@ -887,6 +904,8 @@ restart:
 			 */
 			write_unlock_bh(&policy->lock);
 
+			printk(KERN_NOTICE "xfrm_lookup: newly created bundle is stale\n");
+
 			xfrm_pol_put(policy);
 			if (dst)
 				dst_free(dst);
@@ -903,8 +922,9 @@ restart:
 	return 0;
 
 error:
-	dst_release(dst_orig);
 	xfrm_pol_put(policy);
+error_nopol:
+	dst_release(dst_orig);
 	*dst_p = NULL;
 	return err;
 }
@@ -1196,18 +1216,24 @@ int xfrm_bundle_ok(struct xfrm_dst *firs
 	u32 mtu;
 
 	if (!dst_check(dst->path, ((struct xfrm_dst *)dst)->path_cookie) ||
-	    (dst->dev && !netif_running(dst->dev)))
+	    (dst->dev && !netif_running(dst->dev))) {
+		printk(KERN_DEBUG "xfrm_bundle_ok: %u\n", __LINE__);
 		return 0;
+	}
 
 	last = NULL;
 
 	do {
 		struct xfrm_dst *xdst = (struct xfrm_dst *)dst;
 
-		if (fl && !xfrm_selector_match(&dst->xfrm->sel, fl, family))
+		if (fl && !xfrm_selector_match(&dst->xfrm->sel, fl, family)) {
+			printk(KERN_DEBUG "xfrm_bundle_ok: %u\n", __LINE__);
 			return 0;
-		if (dst->xfrm->km.state != XFRM_STATE_VALID)
+		}
+		if (dst->xfrm->km.state != XFRM_STATE_VALID) {
+			printk(KERN_DEBUG "xfrm_bundle_ok: %u\n", __LINE__);
 			return 0;
+		}
 
 		mtu = dst_mtu(dst->child);
 		if (xdst->child_mtu_cached != mtu) {
@@ -1215,8 +1241,10 @@ int xfrm_bundle_ok(struct xfrm_dst *firs
 			xdst->child_mtu_cached = mtu;
 		}
 
-		if (!dst_check(xdst->route, xdst->route_cookie))
+		if (!dst_check(xdst->route, xdst->route_cookie)) {
+			printk(KERN_DEBUG "xfrm_bundle_ok: %u\n", __LINE__);
 			return 0;
+		}
 		mtu = dst_mtu(xdst->route);
 		if (xdst->route_mtu_cached != mtu) {
 			last = xdst;
Index: build/net/ipv4/route.c
===================================================================
--- build.orig/net/ipv4/route.c
+++ build/net/ipv4/route.c
@@ -2609,18 +2609,25 @@ int ip_route_output_flow(struct rtable *
 {
 	int err;
 
-	if ((err = __ip_route_output_key(rp, flp)) != 0)
-		return err;
+	if (flp->proto == 0) {
+		err = __ip_route_output_key(rp, flp);
+	} else {
+		u32 fl_src = flp->fl4_src, fl_dst = flp->fl4_dst;
+		int repeat = 1;
 
-	if (flp->proto) {
-		if (!flp->fl4_src)
-			flp->fl4_src = (*rp)->rt_src;
-		if (!flp->fl4_dst)
-			flp->fl4_dst = (*rp)->rt_dst;
-		return xfrm_lookup((struct dst_entry **)rp, flp, sk, flags);
+		do {
+			if ((err = __ip_route_output_key(rp, flp)) != 0)
+				break;
+
+			if (!fl_src)
+				flp->fl4_src = (*rp)->rt_src;
+			if (!fl_dst)
+				flp->fl4_dst = (*rp)->rt_dst;
+			err = xfrm_lookup((struct dst_entry **)rp, flp, sk, flags);
+		} while (err == -EAGAIN && repeat--);
 	}
 
-	return 0;
+	return err;
 }
 
 EXPORT_SYMBOL_GPL(ip_route_output_flow);
