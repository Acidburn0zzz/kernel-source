From: Olaf Kirch <okir@suse.de>
Subject: Fix infinite loop in xfrm_lookup
References: 117749, 115200

It seems that the route xfrm_lookup is given on input can go
away when it sleeps.

Herbert Xu suggests that we simply bail out always.  If the dst decides
to die on us later on, the packet will be dropped anyway.  So there is no
great urgency to retry here.  Once we have the proper resolution queueing,
we can then do the retry again.

This is a slightly modified version of Herbert's patch.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Acked-by: Olaf Kirch <okir@suse.de>

 net/xfrm/xfrm_policy.c |   16 ++++++++++++++--
 1 files changed, 14 insertions(+), 2 deletions(-)

Index: build/net/xfrm/xfrm_policy.c
===================================================================
--- build.orig/net/xfrm/xfrm_policy.c
+++ build/net/xfrm/xfrm_policy.c
@@ -785,7 +785,16 @@ int xfrm_lookup(struct dst_entry **dst_p
 	u16 family = dst_orig->ops->family;
 	u8 dir = policy_to_flow_dir(XFRM_POLICY_OUT);
 	u32 sk_sid = security_sk_sid(sk, fl, dir);
+	int loops = 0;
+
 restart:
+	if (unlikely(++loops > 10)) {
+		printk(KERN_NOTICE "xfrm_lookup bailing out after %d loops\n", loops);
+		dump_stack();
+		err = -EHOSTUNREACH;
+		goto error_nopol;
+	}
+
 	genid = atomic_read(&flow_cache_genid);
 	policy = NULL;
 	if (sk && sk->sk_policy[1])
@@ -889,7 +898,9 @@ restart:
 			xfrm_pol_put(policy);
 			if (dst)
 				dst_free(dst);
-			goto restart;
+
+			err = -EHOSTUNREACH;
+			goto error;
 		}
 		dst->next = policy->bundles;
 		policy->bundles = dst;
@@ -902,8 +913,9 @@ restart:
 	return 0;
 
 error:
-	dst_release(dst_orig);
 	xfrm_pol_put(policy);
+error_nopol:
+	dst_release(dst_orig);
 	*dst_p = NULL;
 	return err;
 }
