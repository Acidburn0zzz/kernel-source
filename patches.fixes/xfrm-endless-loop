From: Jiri Bohac <jbohac@suse.cz>
Subject: Debug possible infinite loop in xfrm_lookup
References: 117749, 115200

It seems that the route xfrm_lookup is given on input can go
away when it sleeps.

This used to cause lockups in an infinite loop. The 
problem has probably been fixed by Olaf Kirch and Herbert Xu in 2.6.16-rc3.
Although the missing route should not lock up the system any more, we're
still not sure that the problem has been entirely fixed.

This modified version of Olaf's patch terminates the possibly infinite loop
after 1 minute and prints a warning and a stack dump. If anyone sees the debug
output in their syslog, please let me know.


 net/xfrm/xfrm_policy.c |   12 +++++++++++-
 1 files changed, 11 insertions(+), 1 deletion(-)

--- linux-2.6.15.orig/net/xfrm/xfrm_policy.c	2006-02-14 10:33:11.000000000 -0800
+++ linux-2.6.15/net/xfrm/xfrm_policy.c	2006-02-14 10:37:55.000000000 -0800
@@ -785,7 +785,18 @@
 	u16 family;
 	u8 dir = policy_to_flow_dir(XFRM_POLICY_OUT);
 	u32 sk_sid = security_sk_sid(sk, fl, dir);
+	unsigned long timeout = jiffies + 60 * HZ;
+	int loops = 0;
+
 restart:
+	if (unlikely(time_after(jiffies, timeout))) {
+		printk(KERN_NOTICE "xfrm_lookup bailing out after 60 seconds and %d loops\n", loops);
+		dump_stack();
+		err = -EHOSTUNREACH;
+		goto error_nopol;
+	}
+	++loops;
+
 	genid = atomic_read(&flow_cache_genid);
 	policy = NULL;
 	if (sk && sk->sk_policy[1])
@@ -903,8 +914,9 @@
 	return 0;
 
 error:
-	dst_release(dst_orig);
 	xfrm_pol_put(policy);
+error_nopol:
+	dst_release(dst_orig);
 	*dst_p = NULL;
 	return err;
 }
