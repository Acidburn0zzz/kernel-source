Subject: patch-2.6.13-rc4-git4
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

diff -purN linux-2.6.13-rc4-git3/Makefile linux-2.6.13-rc4-git4/Makefile
--- linux-2.6.13-rc4-git3/Makefile	2005-08-01 13:50:57.712960298 +0200
+++ linux-2.6.13-rc4-git4/Makefile	2005-08-01 13:51:05.426968791 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 13
-EXTRAVERSION = -rc4-git3
+EXTRAVERSION = -rc4-git4
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.13-rc4-git3/drivers/video/fbsysfs.c linux-2.6.13-rc4-git4/drivers/video/fbsysfs.c
--- linux-2.6.13-rc4-git3/drivers/video/fbsysfs.c	2005-08-01 13:50:58.028911476 +0200
+++ linux-2.6.13-rc4-git4/drivers/video/fbsysfs.c	2005-08-01 13:51:05.750918733 +0200
@@ -414,6 +414,13 @@ static ssize_t show_pan(struct class_dev
 			fb_info->var.xoffset);
 }
 
+static ssize_t show_name(struct class_device *class_device, char *buf)
+{
+	struct fb_info *fb_info = (struct fb_info *)class_get_devdata(class_device);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", fb_info->fix.id);
+}
+
 static struct class_device_attribute class_device_attrs[] = {
 	__ATTR(bits_per_pixel, S_IRUGO|S_IWUSR, show_bpp, store_bpp),
 	__ATTR(blank, S_IRUGO|S_IWUSR, show_blank, store_blank),
@@ -424,6 +431,7 @@ static struct class_device_attribute cla
 	__ATTR(modes, S_IRUGO|S_IWUSR, show_modes, store_modes),
 	__ATTR(pan, S_IRUGO|S_IWUSR, show_pan, store_pan),
 	__ATTR(virtual_size, S_IRUGO|S_IWUSR, show_virtual, store_virtual),
+	__ATTR(name, S_IRUGO, show_name, NULL),
 };
 
 int fb_init_class_device(struct fb_info *fb_info)
diff -purN linux-2.6.13-rc4-git3/include/net/tcp.h linux-2.6.13-rc4-git4/include/net/tcp.h
--- linux-2.6.13-rc4-git3/include/net/tcp.h	2005-07-29 00:44:44.000000000 +0200
+++ linux-2.6.13-rc4-git4/include/net/tcp.h	2005-08-01 13:51:05.790912553 +0200
@@ -1236,7 +1236,7 @@ static inline void tcp_sync_left_out(str
 	tp->left_out = tp->sacked_out + tp->lost_out;
 }
 
-/* Set slow start threshould and cwnd not falling to slow start */
+/* Set slow start threshold and cwnd not falling to slow start */
 static inline void __tcp_enter_cwr(struct tcp_sock *tp)
 {
 	tp->undo_marker = 0;
diff -purN linux-2.6.13-rc4-git3/net/core/dst.c linux-2.6.13-rc4-git4/net/core/dst.c
--- linux-2.6.13-rc4-git3/net/core/dst.c	2005-07-29 00:44:44.000000000 +0200
+++ linux-2.6.13-rc4-git4/net/core/dst.c	2005-08-01 13:51:05.809909617 +0200
@@ -45,6 +45,7 @@ static struct timer_list dst_gc_timer =
 static void dst_run_gc(unsigned long dummy)
 {
 	int    delayed = 0;
+	int    work_performed;
 	struct dst_entry * dst, **dstp;
 
 	if (!spin_trylock(&dst_lock)) {
@@ -52,9 +53,9 @@ static void dst_run_gc(unsigned long dum
 		return;
 	}
 
-
 	del_timer(&dst_gc_timer);
 	dstp = &dst_garbage_list;
+	work_performed = 0;
 	while ((dst = *dstp) != NULL) {
 		if (atomic_read(&dst->__refcnt)) {
 			dstp = &dst->next;
@@ -62,6 +63,7 @@ static void dst_run_gc(unsigned long dum
 			continue;
 		}
 		*dstp = dst->next;
+		work_performed = 1;
 
 		dst = dst_destroy(dst);
 		if (dst) {
@@ -86,9 +88,14 @@ static void dst_run_gc(unsigned long dum
 		dst_gc_timer_inc = DST_GC_MAX;
 		goto out;
 	}
-	if ((dst_gc_timer_expires += dst_gc_timer_inc) > DST_GC_MAX)
-		dst_gc_timer_expires = DST_GC_MAX;
-	dst_gc_timer_inc += DST_GC_INC;
+	if (!work_performed) {
+		if ((dst_gc_timer_expires += dst_gc_timer_inc) > DST_GC_MAX)
+			dst_gc_timer_expires = DST_GC_MAX;
+		dst_gc_timer_inc += DST_GC_INC;
+	} else {
+		dst_gc_timer_inc = DST_GC_INC;
+		dst_gc_timer_expires = DST_GC_MIN;
+	}
 	dst_gc_timer.expires = jiffies + dst_gc_timer_expires;
 #if RT_CACHE_DEBUG >= 2
 	printk("dst_total: %d/%d %ld\n",
diff -purN linux-2.6.13-rc4-git3/net/ipv4/ip_gre.c linux-2.6.13-rc4-git4/net/ipv4/ip_gre.c
--- linux-2.6.13-rc4-git3/net/ipv4/ip_gre.c	2005-07-29 00:44:44.000000000 +0200
+++ linux-2.6.13-rc4-git4/net/ipv4/ip_gre.c	2005-08-01 13:51:05.811909308 +0200
@@ -290,7 +290,6 @@ static struct ip_tunnel * ipgre_tunnel_l
 
 	dev_hold(dev);
 	ipgre_tunnel_link(nt);
-	/* Do not decrement MOD_USE_COUNT here. */
 	return nt;
 
 failed:
@@ -1277,12 +1276,28 @@ err1:
 	goto out;
 }
 
-static void ipgre_fini(void)
+static void __exit ipgre_destroy_tunnels(void)
+{
+	int prio;
+
+	for (prio = 0; prio < 4; prio++) {
+		int h;
+		for (h = 0; h < HASH_SIZE; h++) {
+			struct ip_tunnel *t;
+			while ((t = tunnels[prio][h]) != NULL)
+				unregister_netdevice(t->dev);
+		}
+	}
+}
+
+static void __exit ipgre_fini(void)
 {
 	if (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)
 		printk(KERN_INFO "ipgre close: can't remove protocol\n");
 
-	unregister_netdev(ipgre_fb_tunnel_dev);
+	rtnl_lock();
+	ipgre_destroy_tunnels();
+	rtnl_unlock();
 }
 
 module_init(ipgre_init);
diff -purN linux-2.6.13-rc4-git3/net/ipv4/ipip.c linux-2.6.13-rc4-git4/net/ipv4/ipip.c
--- linux-2.6.13-rc4-git3/net/ipv4/ipip.c	2005-07-29 00:44:44.000000000 +0200
+++ linux-2.6.13-rc4-git4/net/ipv4/ipip.c	2005-08-01 13:51:05.813908999 +0200
@@ -255,7 +255,6 @@ static struct ip_tunnel * ipip_tunnel_lo
 
 	dev_hold(dev);
 	ipip_tunnel_link(nt);
-	/* Do not decrement MOD_USE_COUNT here. */
 	return nt;
 
 failed:
@@ -920,12 +919,29 @@ static int __init ipip_init(void)
 	goto out;
 }
 
+static void __exit ipip_destroy_tunnels(void)
+{
+	int prio;
+
+	for (prio = 1; prio < 4; prio++) {
+		int h;
+		for (h = 0; h < HASH_SIZE; h++) {
+			struct ip_tunnel *t;
+			while ((t = tunnels[prio][h]) != NULL)
+				unregister_netdevice(t->dev);
+		}
+	}
+}
+
 static void __exit ipip_fini(void)
 {
 	if (ipip_unregister() < 0)
 		printk(KERN_INFO "ipip close: can't deregister tunnel\n");
 
-	unregister_netdev(ipip_fb_tunnel_dev);
+	rtnl_lock();
+	ipip_destroy_tunnels();
+	unregister_netdevice(ipip_fb_tunnel_dev);
+	rtnl_unlock();
 }
 
 module_init(ipip_init);
diff -purN linux-2.6.13-rc4-git3/net/ipv4/ipmr.c linux-2.6.13-rc4-git4/net/ipv4/ipmr.c
--- linux-2.6.13-rc4-git3/net/ipv4/ipmr.c	2005-07-29 00:44:44.000000000 +0200
+++ linux-2.6.13-rc4-git4/net/ipv4/ipmr.c	2005-08-01 13:51:05.816908536 +0200
@@ -362,7 +362,7 @@ out:
 
 /* Fill oifs list. It is called under write locked mrt_lock. */
 
-static void ipmr_update_threshoulds(struct mfc_cache *cache, unsigned char *ttls)
+static void ipmr_update_thresholds(struct mfc_cache *cache, unsigned char *ttls)
 {
 	int vifi;
 
@@ -727,7 +727,7 @@ static int ipmr_mfc_add(struct mfcctl *m
 	if (c != NULL) {
 		write_lock_bh(&mrt_lock);
 		c->mfc_parent = mfc->mfcc_parent;
-		ipmr_update_threshoulds(c, mfc->mfcc_ttls);
+		ipmr_update_thresholds(c, mfc->mfcc_ttls);
 		if (!mrtsock)
 			c->mfc_flags |= MFC_STATIC;
 		write_unlock_bh(&mrt_lock);
@@ -744,7 +744,7 @@ static int ipmr_mfc_add(struct mfcctl *m
 	c->mfc_origin=mfc->mfcc_origin.s_addr;
 	c->mfc_mcastgrp=mfc->mfcc_mcastgrp.s_addr;
 	c->mfc_parent=mfc->mfcc_parent;
-	ipmr_update_threshoulds(c, mfc->mfcc_ttls);
+	ipmr_update_thresholds(c, mfc->mfcc_ttls);
 	if (!mrtsock)
 		c->mfc_flags |= MFC_STATIC;
 
diff -purN linux-2.6.13-rc4-git3/net/ipv4/netfilter/ip_conntrack_core.c linux-2.6.13-rc4-git4/net/ipv4/netfilter/ip_conntrack_core.c
--- linux-2.6.13-rc4-git3/net/ipv4/netfilter/ip_conntrack_core.c	2005-07-29 00:44:44.000000000 +0200
+++ linux-2.6.13-rc4-git4/net/ipv4/netfilter/ip_conntrack_core.c	2005-08-01 13:51:05.819908072 +0200
@@ -513,6 +513,11 @@ init_conntrack(const struct ip_conntrack
 #ifdef CONFIG_IP_NF_CONNTRACK_MARK
 		conntrack->mark = exp->master->mark;
 #endif
+#if defined(CONFIG_IP_NF_TARGET_MASQUERADE) || \
+    defined(CONFIG_IP_NF_TARGET_MASQUERADE_MODULE)
+		/* this is ugly, but there is no other place where to put it */
+		conntrack->nat.masq_index = exp->master->nat.masq_index;
+#endif
 		nf_conntrack_get(&conntrack->master->ct_general);
 		CONNTRACK_STAT_INC(expect_new);
 	} else {
diff -purN linux-2.6.13-rc4-git3/net/ipv6/sit.c linux-2.6.13-rc4-git4/net/ipv6/sit.c
--- linux-2.6.13-rc4-git3/net/ipv6/sit.c	2005-07-29 00:44:44.000000000 +0200
+++ linux-2.6.13-rc4-git4/net/ipv6/sit.c	2005-08-01 13:51:05.821907763 +0200
@@ -195,7 +195,6 @@ static struct ip_tunnel * ipip6_tunnel_l
 	dev_hold(dev);
 
 	ipip6_tunnel_link(nt);
-	/* Do not decrement MOD_USE_COUNT here. */
 	return nt;
 
 failed:
@@ -794,10 +793,28 @@ static struct net_protocol sit_protocol 
 	.err_handler	=	ipip6_err,
 };
 
+static void __exit sit_destroy_tunnels(void)
+{
+	int prio;
+
+	for (prio = 1; prio < 4; prio++) {
+		int h;
+		for (h = 0; h < HASH_SIZE; h++) {
+			struct ip_tunnel *t;
+			while ((t = tunnels[prio][h]) != NULL)
+				unregister_netdevice(t->dev);
+		}
+	}
+}
+
 void __exit sit_cleanup(void)
 {
 	inet_del_protocol(&sit_protocol, IPPROTO_IPV6);
-	unregister_netdev(ipip6_fb_tunnel_dev);
+
+	rtnl_lock();
+	sit_destroy_tunnels();
+	unregister_netdevice(ipip6_fb_tunnel_dev);
+	rtnl_unlock();
 }
 
 int __init sit_init(void)
