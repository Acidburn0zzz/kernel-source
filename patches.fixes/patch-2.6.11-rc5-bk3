From: olh@suse.de
Subject: patch-2.6.11-rc5-bk3

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc5-bk2.log	2005-02-27 13:32:06.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc5-bk3.log	2005-02-28 13:30:42.000000000 +0100
 ChangeSet@1.2063, 2005-02-26 10:12:16-08:00, torvalds@ppc970.osdl.org
 ChangeSet@1.2055, 2005-02-27 16:10:07-08:00, rddunlap@osdl.org
   [PATCH] srat: initdata section references
   
   srat's node_to_pxm() references pxm2node[] after init. so pxm2node[]
   should not be __initdata.
   
   Error: ./arch/x86_64/mm/srat.o .text refers to 0000000000000008 R_X86_64_32S      .init.data
   Error: ./arch/x86_64/mm/srat.o .text refers to 0000000000000015 R_X86_64_32S      .init.data
   
   Signed-off-by: Randy Dunlap <rddunlap@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2049.1.17, 2005-02-27 11:15:10-08:00, davem@nuts.davemloft.net
   [AF_UNIX]: Fix SIOCINQ for STREAM and SEQPACKET.
   
   We should report the total bytes in the whole receive
   queue, not just the first packet, in these cases.
   
   Reported by Uwe Bonnes.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2049.1.16, 2005-02-27 11:10:03-08:00, davem@nuts.davemloft.net
   [IPV4]: Fix lost routes in fn_hash netlink dumps.
   
   Spotted by itkes@fat.imed.msu.ru, the fn_hash_dump_bucket() main
   loop does not increment 'i' properly, and thus routes will not
   be listed, when the test 'i < s_i' passes.
   
   The bug was added when the code was converted over to
   hlist_for_each_entry() by your's truly.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2049.1.14, 2005-02-26 10:12:16-08:00, torvalds@ppc970.osdl.org
 ChangeSet@1.2062, 2005-02-26 10:03:27-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2049.1.13, 2005-02-26 10:03:27-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2061, 2005-02-26 10:03:13-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2049.1.12, 2005-02-26 10:03:13-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2060, 2005-02-26 10:02:59-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2049.1.11, 2005-02-26 10:02:59-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2059, 2005-02-26 10:02:45-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2049.1.10, 2005-02-26 10:02:45-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2058, 2005-02-26 10:02:30-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2049.1.9, 2005-02-26 10:02:30-08:00, Andries.Brouwer@cwi.nl
 ChangeSet@1.2057, 2005-02-25 20:28:59-08:00, aurelien@aurel32.net
 ChangeSet@1.2049.1.8, 2005-02-25 20:28:59-08:00, aurelien@aurel32.net
 ChangeSet@1.2056, 2005-02-25 19:39:39-08:00, torvalds@ppc970.osdl.org
 ChangeSet@1.2049.1.7, 2005-02-25 19:39:39-08:00, torvalds@ppc970.osdl.org
 ChangeSet@1.2055, 2005-02-25 16:51:25-08:00, olh@suse.de
 ChangeSet@1.2049.1.6, 2005-02-25 16:51:25-08:00, olh@suse.de
 ChangeSet@1.2053, 2005-02-25 14:17:57-08:00, akpm@osdl.org
 ChangeSet@1.2049.1.4, 2005-02-25 14:17:57-08:00, akpm@osdl.org
 ChangeSet@1.2052, 2005-02-25 14:17:43-08:00, gregkh@suse.de
 ChangeSet@1.2049.1.3, 2005-02-25 14:17:43-08:00, gregkh@suse.de
 ChangeSet@1.2051, 2005-02-25 14:17:30-08:00, dhowells@redhat.com
 ChangeSet@1.2049.1.2, 2005-02-25 14:17:30-08:00, dhowells@redhat.com
 ChangeSet@1.2049.1.1, 2005-02-25 19:47:46+00:00, rmk@flint.arm.linux.org.uk
 ChangeSet@1.2049.2.1, 2005-02-25 19:47:46+00:00, rmk@flint.arm.linux.org.uk
 ChangeSet@1.2050, 2005-02-25 08:48:33-08:00, david@gibson.dropbear.id.au
 ChangeSet@1.2049.1.1, 2005-02-25 08:48:33-08:00, david@gibson.dropbear.id.au
 ChangeSet@1.2052, 2005-02-24 12:02:05+01:00, bzolnier@trik.(none)
   [ide] fix IRQ masking in ide_do_request()
   
   Revert to previous way of handling masked_irq argument.
   Reported to fix problems with shared PCI IRQs.
   
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.2051, 2005-02-24 11:14:08+01:00, bzolnier@trik.(none)
   [ide] fix build for built-in hpt366 and modular ide-disk
   
   * always call __ide_do_rw_disk() in ide_do_rw_disk()
   * modify ide_hwif_t->rw_disk hook accordingly
   * update and cleanup hpt372n_rw_disk()
     (the only user of ide_hwif_t->rw_disk hook)
   * make __ide_do_rw_disk() static + fix comment
   
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.2050, 2005-02-24 11:01:48+01:00, rddunlap@osdl.org
   [ide] make 1-bit fields unsigned
   
   It's a bit difficult to have a value and a sign bit in a
   1-bit field.
   
   Fix (90) boolean/bitfield sparse warnings:
   include/linux/ide.h:937:18: warning: dubious one-bit signed bitfield
   include/linux/ide.h:939:17: warning: dubious one-bit signed bitfield
   
   Signed-off-by: Randy Dunlap <rddunlap@osdl.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
diff -purN linux-2.6.11-rc5-bk2/Makefile linux-2.6.11-rc5-bk3/Makefile
--- linux-2.6.11-rc5-bk2/Makefile	2005-02-28 15:23:58.874676260 +0100
+++ linux-2.6.11-rc5-bk3/Makefile	2005-02-28 15:24:07.066722999 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc5-bk2
+EXTRAVERSION = -rc5-bk3
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc5-bk2/arch/x86_64/mm/srat.c linux-2.6.11-rc5-bk3/arch/x86_64/mm/srat.c
--- linux-2.6.11-rc5-bk2/arch/x86_64/mm/srat.c	2005-02-24 05:02:45.000000000 +0100
+++ linux-2.6.11-rc5-bk3/arch/x86_64/mm/srat.c	2005-02-28 15:24:07.071722221 +0100
@@ -23,7 +23,7 @@ static struct acpi_table_slit *acpi_slit
 static nodemask_t nodes_parsed __initdata;
 static nodemask_t nodes_found __initdata;
 static struct node nodes[MAX_NUMNODES] __initdata;
-static __u8  pxm2node[256] __initdata = { [0 ... 255] = 0xff };
+static __u8  pxm2node[256] = { [0 ... 255] = 0xff };
 
 static __init int setup_node(int pxm)
 {
diff -purN linux-2.6.11-rc5-bk2/drivers/ide/ide-disk.c linux-2.6.11-rc5-bk3/drivers/ide/ide-disk.c
--- linux-2.6.11-rc5-bk2/drivers/ide/ide-disk.c	2005-02-24 05:02:38.000000000 +0100
+++ linux-2.6.11-rc5-bk3/drivers/ide/ide-disk.c	2005-02-28 15:24:07.081720666 +0100
@@ -119,9 +119,8 @@ static int lba_capacity_is_ok (struct hd
 /*
  * __ide_do_rw_disk() issues READ and WRITE commands to a disk,
  * using LBA if supported, or CHS otherwise, to address sectors.
- * It also takes care of issuing special DRIVE_CMDs.
  */
-ide_startstop_t __ide_do_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block)
+static ide_startstop_t __ide_do_rw_disk(ide_drive_t *drive, struct request *rq, sector_t block)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	unsigned int dma	= drive->using_dma;
@@ -256,7 +255,6 @@ ide_startstop_t __ide_do_rw_disk (ide_dr
 		return pre_task_out_intr(drive, rq);
 	}
 }
-EXPORT_SYMBOL_GPL(__ide_do_rw_disk);
 
 /*
  * 268435455  == 137439 MB or 28bit limit
@@ -281,9 +279,9 @@ static ide_startstop_t ide_do_rw_disk (i
 		 block, rq->nr_sectors, (unsigned long)rq->buffer);
 
 	if (hwif->rw_disk)
-		return hwif->rw_disk(drive, rq, block);
-	else
-		return __ide_do_rw_disk(drive, rq, block);
+		hwif->rw_disk(drive, rq);
+
+	return __ide_do_rw_disk(drive, rq, block);
 }
 
 /*
diff -purN linux-2.6.11-rc5-bk2/drivers/ide/ide-io.c linux-2.6.11-rc5-bk3/drivers/ide/ide-io.c
--- linux-2.6.11-rc5-bk2/drivers/ide/ide-io.c	2005-02-24 05:03:10.000000000 +0100
+++ linux-2.6.11-rc5-bk3/drivers/ide/ide-io.c	2005-02-28 15:24:07.084720199 +0100
@@ -1163,14 +1163,14 @@ static void ide_do_request (ide_hwgroup_
 		 * happens anyway when any interrupt comes in, IDE or otherwise
 		 *  -- the kernel masks the IRQ while it is being handled.
 		 */
-		if (hwif->irq != masked_irq)
+		if (masked_irq != IDE_NO_IRQ && hwif->irq != masked_irq)
 			disable_irq_nosync(hwif->irq);
 		spin_unlock(&ide_lock);
 		local_irq_enable();
 			/* allow other IRQs while we start this request */
 		startstop = start_request(drive, rq);
 		spin_lock_irq(&ide_lock);
-		if (hwif->irq != masked_irq)
+		if (masked_irq != IDE_NO_IRQ && hwif->irq != masked_irq)
 			enable_irq(hwif->irq);
 		if (startstop == ide_stopped)
 			hwgroup->busy = 0;
diff -purN linux-2.6.11-rc5-bk2/drivers/ide/pci/hpt366.c linux-2.6.11-rc5-bk3/drivers/ide/pci/hpt366.c
--- linux-2.6.11-rc5-bk2/drivers/ide/pci/hpt366.c	2005-02-24 05:03:53.000000000 +0100
+++ linux-2.6.11-rc5-bk3/drivers/ide/pci/hpt366.c	2005-02-28 15:24:07.088719577 +0100
@@ -1018,32 +1018,25 @@ static void hpt372n_set_clock(ide_drive_
 }
 
 /**
- *	hpt372n_rw_disk		-	wrapper for I/O
+ *	hpt372n_rw_disk		-	prepare for I/O
  *	@drive: drive for command
  *	@rq: block request structure
- *	@block: block number
- *
- *	This is called when a disk I/O is issued to the 372N instead
- *	of the default functionality. We need it because of the clock
- *	switching
  *
+ *	This is called when a disk I/O is issued to the 372N.
+ *	We need it because of the clock switching.
  */
- 
-static ide_startstop_t hpt372n_rw_disk(ide_drive_t *drive, struct request *rq, sector_t block)
+
+static void hpt372n_rw_disk(ide_drive_t *drive, struct request *rq)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	int wantclock;
-	
-	if(rq_data_dir(rq) == READ)
-		wantclock = 0x21;
-	else
-		wantclock = 0x23;
-		
-	if(HWIF(drive)->config_data != wantclock)
-	{
+
+	wantclock = rq_data_dir(rq) ? 0x23 : 0x21;
+
+	if (hwif->config_data != wantclock) {
 		hpt372n_set_clock(drive, wantclock);
-		HWIF(drive)->config_data = wantclock;
+		hwif->config_data = wantclock;
 	}
-	return __ide_do_rw_disk(drive, rq, block);
 }
 
 /*
diff -purN linux-2.6.11-rc5-bk2/include/linux/ide.h linux-2.6.11-rc5-bk3/include/linux/ide.h
--- linux-2.6.11-rc5-bk2/include/linux/ide.h	2005-02-24 05:02:37.000000000 +0100
+++ linux-2.6.11-rc5-bk3/include/linux/ide.h	2005-02-28 15:24:07.108716465 +0100
@@ -797,7 +797,7 @@ typedef struct hwif_s {
 	struct pci_dev  *pci_dev;	/* for pci chipsets */
 	struct ide_pci_device_s	*cds;	/* chipset device struct */
 
-	ide_startstop_t (*rw_disk)(ide_drive_t *, struct request *, sector_t);
+	void (*rw_disk)(ide_drive_t *, struct request *);
 
 #if 0
 	ide_hwif_ops_t	*hwifops;
@@ -934,9 +934,9 @@ typedef struct hwgroup_s {
 		/* BOOL: protects all fields below */
 	volatile int busy;
 		/* BOOL: wake us up on timer expiry */
-	int sleeping	: 1;
+	unsigned int sleeping	: 1;
 		/* BOOL: polling active & poll_timeout field valid */
-	int polling	: 1;
+	unsigned int polling	: 1;
 		/* current drive */
 	ide_drive_t *drive;
 		/* ptr to current hwif in linked-list */
@@ -1318,7 +1318,6 @@ extern int set_transfer(ide_drive_t *, i
 extern int taskfile_lib_get_identify(ide_drive_t *drive, u8 *);
 
 extern int ide_wait_not_busy(ide_hwif_t *hwif, unsigned long timeout);
-ide_startstop_t __ide_do_rw_disk(ide_drive_t *drive, struct request *rq, sector_t block);
 
 /*
  * ide_stall_queue() can be used by a drive to give excess bandwidth back
diff -purN linux-2.6.11-rc5-bk2/net/ipv4/fib_hash.c linux-2.6.11-rc5-bk3/net/ipv4/fib_hash.c
--- linux-2.6.11-rc5-bk2/net/ipv4/fib_hash.c	2005-02-24 05:02:45.000000000 +0100
+++ linux-2.6.11-rc5-bk3/net/ipv4/fib_hash.c	2005-02-28 15:24:07.126713665 +0100
@@ -684,7 +684,7 @@ fn_hash_dump_bucket(struct sk_buff *skb,
 
 		list_for_each_entry(fa, &f->fn_alias, fa_list) {
 			if (i < s_i)
-				continue;
+				goto next;
 
 			if (fib_dump_info(skb, NETLINK_CB(cb->skb).pid,
 					  cb->nlh->nlmsg_seq,
@@ -699,7 +699,7 @@ fn_hash_dump_bucket(struct sk_buff *skb,
 				cb->args[3] = i;
 				return -1;
 			}
-
+		next:
 			i++;
 		}
 	}
diff -purN linux-2.6.11-rc5-bk2/net/unix/af_unix.c linux-2.6.11-rc5-bk3/net/unix/af_unix.c
--- linux-2.6.11-rc5-bk2/net/unix/af_unix.c	2005-02-24 05:03:04.000000000 +0100
+++ linux-2.6.11-rc5-bk3/net/unix/af_unix.c	2005-02-28 15:24:07.147710398 +0100
@@ -1850,15 +1850,22 @@ static int unix_ioctl(struct socket *soc
 		case SIOCINQ:
 		{
 			struct sk_buff *skb;
+
 			if (sk->sk_state == TCP_LISTEN) {
 				err = -EINVAL;
 				break;
 			}
 
 			spin_lock(&sk->sk_receive_queue.lock);
-			skb = skb_peek(&sk->sk_receive_queue);
-			if (skb)
-				amount=skb->len;
+			if (sk->sk_type == SOCK_STREAM ||
+			    sk->sk_type == SOCK_SEQPACKET) {
+				skb_queue_walk(&sk->sk_receive_queue, skb)
+					amount += skb->len;
+			} else {
+				skb = skb_peek(&sk->sk_receive_queue);
+				if (skb)
+					amount=skb->len;
+			}
 			spin_unlock(&sk->sk_receive_queue.lock);
 			err = put_user(amount, (int __user *)arg);
 			break;
