From: NeilBrown <neilb@suse.de>
Subject: Set meaningful value for fattr->time_start in readdirplus results.
Patch-mainline: no
References: 244967


The 'fattr' structure filled in by nfs3_decode_direct does not get a
value for ->time_start set.
Thus if an entry is for an inode that we already have in cache,
when nfs_readdir_lookup calls nfs_fhget, it will call nfs_refresh_inode
and may update the inode with out-of-date information.

Directories are read a page at a time, so each page could have a
different timestamp that "should" be used to set the time_start for
the fattr for info in that page.  However storing the timestamp per
page is awkward.  (We could stick in the first 4 bytes and only read 4092
bytes, but that is a bigger code change than I was interested it).

This patch records the timestamp when the first page of a directory is
read and uses it to set the time_start for the fattr for each each
entry read from the directory.  This if an inode has been updated more
recently than the directory was read, that information will not be
destroyed.

Signed-off-by: Neil Brown <neilb@suse.de>

### Diffstat output
 fs/nfs/dir.c |    4 ++++
 1 files changed, 4 insertions(+)

Acked-by: 

diff .prev/fs/nfs/dir.c ./fs/nfs/dir.c
--- linux-2.6.20.orig/fs/nfs/dir.c
+++ linux-2.6.20/fs/nfs/dir.c
@@ -154,6 +154,7 @@ typedef struct {
 	decode_dirent_t	decode;
 	int		plus;
 	int		error;
+	unsigned long	timestamp;
 } nfs_readdir_descriptor_t;
 
 /* Now we cache directories properly, by stuffing the dirent
@@ -207,6 +208,8 @@ int nfs_readdir_filler(nfs_readdir_descr
 		/* Should never happen */
 		nfs_zap_mapping(inode, inode->i_mapping);
 	}
+	if (page->index == 0)
+		desc->timestamp = timestamp;
 	unlock_page(page);
 	return 0;
  error:
@@ -1151,6 +1154,7 @@ static struct dentry *nfs_readdir_lookup
 	if (dentry == NULL)
 		return NULL;
 	dentry->d_op = NFS_PROTO(dir)->dentry_ops;
+	entry->fattr->time_start = desc->timestamp;
 	inode = nfs_fhget(dentry->d_sb, entry->fh, entry->fattr);
 	if (IS_ERR(inode)) {
 		dput(dentry);
