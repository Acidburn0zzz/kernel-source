Subject: Skip extension headers when matching ICMPv6 packets
From: Olaf Kirch <okir@suse.de>
References: 46338

This patch fixes a bug in the ip6_tables code when matching ICMP type and
code within ICMPv6 packets. The icmpv6 packet matcher expects the nexthdr
to be ICMPv6 and does not deal with hop-by-hop headers.

Signed-off-by: Olaf Kirch <okir@suse.de>

Index: linux-2.6.8/net/ipv6/netfilter/ip6_tables.c
===================================================================
--- linux-2.6.8.orig/net/ipv6/netfilter/ip6_tables.c	2004-09-30 12:54:53.000000000 +0200
+++ linux-2.6.8/net/ipv6/netfilter/ip6_tables.c	2004-09-30 13:00:03.000000000 +0200
@@ -1773,10 +1773,23 @@
 	   u_int16_t datalen,
 	   int *hotdrop)
 {
-	const struct icmp6hdr *icmp = hdr;
+	struct icmp6hdr icmph;
 	const struct ip6t_icmp *icmpinfo = matchinfo;
+	int hdroff;
+	u8 nexthdr = skb->nh.ipv6h->nexthdr;
+
+	/* Must not be a fragment. */
+	if (offset)
+		return 0;
+
+	hdroff = (u8*)(skb->nh.ipv6h+1) - skb->data;
+	hdroff = ipv6_skip_exthdr(skb, hdroff, &nexthdr, skb->len - hdroff);
+	if (hdroff < 0 || hdroff > skb->len || nexthdr != IPPROTO_ICMPV6) {
+		*hotdrop = 1;
+		return 0;
+	}
 
-	if (offset == 0 && datalen < 2) {
+	if (skb_copy_bits(skb, hdroff, &icmph, sizeof(icmph)) < 0) {
 		/* We've been asked to examine this packet, and we
 		   can't.  Hence, no choice but to drop. */
 		duprintf("Dropping evil ICMP tinygram.\n");
@@ -1785,11 +1801,10 @@
 	}
 
 	/* Must not be a fragment. */
-	return !offset
-		&& icmp6_type_code_match(icmpinfo->type,
+	return icmp6_type_code_match(icmpinfo->type,
 					icmpinfo->code[0],
 					icmpinfo->code[1],
-					icmp->icmp6_type, icmp->icmp6_code,
+					icmph.icmp6_type, icmph.icmp6_code,
 					!!(icmpinfo->invflags&IP6T_ICMP_INV));
 }
 
