From: Helmut Schaa <helmut.schaa@googlemail.com>
Date: Mon Jan 19 13:10:07 2009 +0100
Subject: iwlagn: fix hw-rfkill while the interface is down
Patch-mainline: wireless-testing (2.6.30?)
References: bnc#446158

iwlagn: fix hw-rfkill while the interface is down
    
Currently iwlagn is not able to report hw-killswitch events while the
interface is down. This has implications on user space tools (like
NetworkManager) relying on rfkill notifications to bring the interface
up once the wireless gets enabled through a hw killswitch.

Thus, enable the device already in iwl_pci_probe instead of iwl_up
and enable interrups while the interface is down in order to get
notified about killswitch state changes. The firmware loading is still
done in iwl_up.
    
Signed-off-by: Helmut Schaa <helmut.schaa@googlemail.com>
Acked-by: Reinette Chatre <reinette.chatre@intel.com>
Signed-off-by: John W. Linville <linville@tuxdriver.com>
Acked-by: Helmut Schaa <hschaa@suse.de>
Acked-by: Jiri Benc <jbenc@suse.cz>

---
 drivers/net/wireless/iwlwifi/iwl-agn.c |  111 +++++++++++++++++----------------
 1 file changed, 58 insertions(+), 53 deletions(-)

--- linux-2.6.27.orig/drivers/net/wireless/iwlwifi/iwl-agn.c
+++ linux-2.6.27/drivers/net/wireless/iwlwifi/iwl-agn.c
@@ -1643,11 +1643,17 @@ static void iwl4965_irq_tasklet(struct i
 				hw_rf_kill ? "disable radio":"enable radio");
 
 		/* driver only loads ucode once setting the interface up.
-		 * the driver as well won't allow loading if RFKILL is set
-		 * therefore no need to restart the driver from this handler
-		 */
-		if (!hw_rf_kill && !test_bit(STATUS_ALIVE, &priv->status))
-			clear_bit(STATUS_RF_KILL_HW, &priv->status);
+ 		 * the driver allows loading the ucode even if the radio
+ 		 * is killed. Hence update the killswitch state here. The
+ 		 * rfkill handler will care about restarting if needed.
+ 		 */
+ 		if (!test_bit(STATUS_ALIVE, &priv->status)) {
+ 			if (hw_rf_kill)
+ 				set_bit(STATUS_RF_KILL_HW, &priv->status);
+ 			else
+ 				clear_bit(STATUS_RF_KILL_HW, &priv->status);
+ 			queue_work(priv->workqueue, &priv->rf_kill);
+		}
 
 		handled |= CSR_INT_BIT_RF_KILL;
 	}
@@ -2349,7 +2355,8 @@ static void iwl4965_bg_rf_kill(struct wo
 		IWL_DEBUG(IWL_DL_RF_KILL,
 			  "HW and/or SW RF Kill no longer active, restarting "
 			  "device\n");
-		if (!test_bit(STATUS_EXIT_PENDING, &priv->status))
+		if (!test_bit(STATUS_EXIT_PENDING, &priv->status) &&
+		     test_bit(STATUS_ALIVE, &priv->status))
 			queue_work(priv->workqueue, &priv->restart);
 	} else {
 		/* make sure mac80211 stop sending Tx frame */
@@ -2593,31 +2600,9 @@ static int iwl4965_mac_start(struct ieee
 {
 	struct iwl_priv *priv = hw->priv;
 	int ret;
-	u16 pci_cmd;
 
 	IWL_DEBUG_MAC80211("enter\n");
 
-	if (pci_enable_device(priv->pci_dev)) {
-		IWL_ERROR("Fail to pci_enable_device\n");
-		return -ENODEV;
-	}
-	pci_restore_state(priv->pci_dev);
-	pci_enable_msi(priv->pci_dev);
-
-	/* enable interrupts if needed: hw bug w/a */
-	pci_read_config_word(priv->pci_dev, PCI_COMMAND, &pci_cmd);
-	if (pci_cmd & PCI_COMMAND_INTX_DISABLE) {
-		pci_cmd &= ~PCI_COMMAND_INTX_DISABLE;
-		pci_write_config_word(priv->pci_dev, PCI_COMMAND, pci_cmd);
-	}
-
-	ret = request_irq(priv->pci_dev->irq, iwl4965_isr, IRQF_SHARED,
-			  DRV_NAME, priv);
-	if (ret) {
-		IWL_ERROR("Error allocating IRQ %d\n", priv->pci_dev->irq);
-		goto out_disable_msi;
-	}
-
 	/* we should be verifying the device is ready to be opened */
 	mutex_lock(&priv->mutex);
 
@@ -2630,7 +2615,7 @@ static int iwl4965_mac_start(struct ieee
 		if (ret) {
 			IWL_ERROR("Could not read microcode: %d\n", ret);
 			mutex_unlock(&priv->mutex);
-			goto out_release_irq;
+			return ret;
 		}
 	}
 
@@ -2641,7 +2626,7 @@ static int iwl4965_mac_start(struct ieee
 	iwl_rfkill_set_hw_state(priv);
 
 	if (ret)
-		goto out_release_irq;
+		return ret;
 
 	if (iwl_is_rfkill(priv))
 		goto out;
@@ -2660,8 +2645,7 @@ static int iwl4965_mac_start(struct ieee
 		if (!test_bit(STATUS_READY, &priv->status)) {
 			IWL_ERROR("START_ALIVE timeout after %dms.\n",
 				jiffies_to_msecs(UCODE_READY_TIMEOUT));
-			ret = -ETIMEDOUT;
-			goto out_release_irq;
+			return -ETIMEDOUT;
 		}
 	}
 
@@ -2669,15 +2653,6 @@ out:
 	priv->is_open = 1;
 	IWL_DEBUG_MAC80211("leave\n");
 	return 0;
-
-out_release_irq:
-	free_irq(priv->pci_dev->irq, priv);
-out_disable_msi:
-	pci_disable_msi(priv->pci_dev);
-	pci_disable_device(priv->pci_dev);
-	priv->is_open = 0;
-	IWL_DEBUG_MAC80211("leave - failed\n");
-	return ret;
 }
 
 static void iwl4965_mac_stop(struct ieee80211_hw *hw)
@@ -2705,10 +2680,10 @@ static void iwl4965_mac_stop(struct ieee
 	iwl4965_down(priv);
 
 	flush_workqueue(priv->workqueue);
-	free_irq(priv->pci_dev->irq, priv);
-	pci_disable_msi(priv->pci_dev);
-	pci_save_state(priv->pci_dev);
-	pci_disable_device(priv->pci_dev);
+
+	/* enable interrupts again in order to receive rfkill changes */
+	iwl_write32(priv, CSR_INT, 0xFFFFFFFF);
+	iwl4965_enable_interrupts(priv);
 
 	IWL_DEBUG_MAC80211("leave\n");
 }
@@ -4176,6 +4151,7 @@ static int iwl4965_pci_probe(struct pci_
 	struct iwl_cfg *cfg = (struct iwl_cfg *)(ent->driver_data);
 	unsigned long flags;
 	DECLARE_MAC_BUF(mac);
+	u16 pci_cmd;
 
 	/************************
 	 * 1. Allocating HW data
@@ -4320,26 +4296,36 @@ static int iwl4965_pci_probe(struct pci_
 	iwl4965_disable_interrupts(priv);
 	spin_unlock_irqrestore(&priv->lock, flags);
 
+ 	pci_enable_msi(priv->pci_dev);
+
+ 	err = request_irq(priv->pci_dev->irq, iwl4965_isr, IRQF_SHARED,
+ 			  DRV_NAME, priv);
+ 	if (err) {
+ 		IWL_ERROR("Error allocating IRQ %d\n", priv->pci_dev->irq);
+ 		goto out_disable_msi;
+ 	}
 	err = sysfs_create_group(&pdev->dev.kobj, &iwl4965_attribute_group);
 	if (err) {
 		IWL_ERROR("failed to create sysfs device attributes\n");
 		goto out_uninit_drv;
 	}
 
-
 	iwl_setup_deferred_work(priv);
 	iwl_setup_rx_handlers(priv);
 
-	/********************
-	 * 9. Conclude
-	 ********************/
-	pci_save_state(pdev);
-	pci_disable_device(pdev);
-
 	/**********************************
-	 * 10. Setup and register mac80211
+	 * 9. Setup and register mac80211
 	 **********************************/
 
+ 	/* enable interrupts if needed: hw bug w/a */
+ 	pci_read_config_word(priv->pci_dev, PCI_COMMAND, &pci_cmd);
+ 	if (pci_cmd & PCI_COMMAND_INTX_DISABLE) {
+ 		pci_cmd &= ~PCI_COMMAND_INTX_DISABLE;
+ 		pci_write_config_word(priv->pci_dev, PCI_COMMAND, pci_cmd);
+ 	}
+
+ 	iwl4965_enable_interrupts(priv);
+
 	err = iwl_setup_mac(priv);
 	if (err)
 		goto out_remove_sysfs;
@@ -4348,15 +4334,27 @@ static int iwl4965_pci_probe(struct pci_
 	if (err)
 		IWL_ERROR("failed to create debugfs files\n");
 
+ 	/* If platform's RF_KILL switch is NOT set to KILL */
+ 	if (iwl_read32(priv, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)
+ 		clear_bit(STATUS_RF_KILL_HW, &priv->status);
+ 	else
+ 		set_bit(STATUS_RF_KILL_HW, &priv->status);
+
 	err = iwl_rfkill_init(priv);
 	if (err)
 		IWL_ERROR("Unable to initialize RFKILL system. "
 				  "Ignoring error: %d\n", err);
+	else
+ 		iwl_rfkill_set_hw_state(priv);
+
 	iwl_power_initialize(priv);
 	return 0;
 
  out_remove_sysfs:
 	sysfs_remove_group(&pdev->dev.kobj, &iwl4965_attribute_group);
+ out_disable_msi:
+ 	pci_disable_msi(priv->pci_dev);
+ 	pci_disable_device(priv->pci_dev);
  out_uninit_drv:
 	iwl_uninit_drv(priv);
  out_free_eeprom:
@@ -4428,6 +4426,8 @@ static void __devexit iwl4965_pci_remove
 	destroy_workqueue(priv->workqueue);
 	priv->workqueue = NULL;
 
+	free_irq(priv->pci_dev->irq, priv);
+	pci_disable_msi(priv->pci_dev);
 	pci_iounmap(pdev, priv->hw_base);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
@@ -4453,6 +4453,8 @@ static int iwl4965_pci_suspend(struct pc
 		priv->is_open = 1;
 	}
 
+	pci_save_state(pdev);
+	pci_disable_device(pdev);
 	pci_set_power_state(pdev, PCI_D3hot);
 
 	return 0;
@@ -4463,6 +4465,9 @@ static int iwl4965_pci_resume(struct pci
 	struct iwl_priv *priv = pci_get_drvdata(pdev);
 
 	pci_set_power_state(pdev, PCI_D0);
+	pci_enable_device(pdev);
+	pci_restore_state(pdev);
+	iwl4965_enable_interrupts(priv);
 
 	if (priv->is_open)
 		iwl4965_mac_start(priv->hw);
