Date: Thu, Jan 20 2005 14:17:13 +1100
From: Christoph Hellwig <hch@sgi.com>
References: 50038, SGI:PV923968
Patch-mainline: bk-xfs patch in -mm tree; should be in 2.6.11
Subject: [PATCH] nfs inode data corruption

Fix NFS inode data corruption

Acked-by: Andreas Gruenbacher <agrueb@suse.de>

===========================================================================
Index: linux-2.6/xfs_super.c
===========================================================================

--- a/fs/xfs/linux-2.6/xfs_super.c	2005-01-20 14:32:08.000000000 +1100
+++ b/fs/xfs/linux-2.6/xfs_super.c	2005-01-20 14:32:08.000000000 +1100
@@ -731,6 +731,39 @@
 	return result;
 }
 
+STATIC struct dentry *
+linvfs_decode_fh(
+	struct super_block	*sb,
+	__u32			*fh,
+	int			fh_len,
+	int			fileid_type,
+	int (*acceptable)(
+		void		*context,
+		struct dentry	*de),
+	void			*context)
+{
+	__u32 parent[2];
+	parent[0] = parent[1] = 0;
+	
+	if (fh_len < 2 || fileid_type > 2)
+		return NULL;
+	
+	if (fileid_type == 2 && fh_len > 2) {
+		if (fh_len == 3) {
+			printk(KERN_WARNING
+			       "XFS: detected filehandle without "
+			       "parent inode generation information.");
+			return ERR_PTR(-ESTALE);
+		}
+			
+		parent[0] = fh[2];
+		parent[1] = fh[3];
+	}
+	
+	return find_exported_dentry(sb, fh, parent, acceptable, context);
+
+}
+
 STATIC int
 linvfs_show_options(
 	struct seq_file		*m,
@@ -893,6 +926,7 @@
 
 
 STATIC struct export_operations linvfs_export_ops = {
+	.decode_fh		= linvfs_decode_fh,
 	.get_parent		= linvfs_get_parent,
 	.get_dentry		= linvfs_get_dentry,
 };

===========================================================================
Index: xfs_vfsops.c
===========================================================================

--- a/fs/xfs/xfs_vfsops.c	2005-01-20 14:32:08.000000000 +1100
+++ b/fs/xfs/xfs_vfsops.c	2005-01-20 14:32:08.000000000 +1100
@@ -1581,7 +1581,7 @@
 }
 
 /*
- * xfs_vget - called by DMAPI to get vnode from file handle
+ * xfs_vget - called by DMAPI and NFSD to get vnode from file handle
  */
 STATIC int
 xfs_vget(
@@ -1623,7 +1623,7 @@
 		return XFS_ERROR(EIO);
 	}
 
-	if (ip->i_d.di_mode == 0 || (igen && (ip->i_d.di_gen != igen))) {
+	if (ip->i_d.di_mode == 0 || ip->i_d.di_gen != igen) {
 		xfs_iput_new(ip, XFS_ILOCK_SHARED);
 		*vpp = NULL;
 		return XFS_ERROR(ENOENT);
