From: olh@suse.de
Subject: 2.6.11-rc4-bk4

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc4-bk3.log	2005-02-15 13:40:37.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc4-bk4.log	2005-02-16 13:40:02.000000000 +0100
 ChangeSet@1.2053, 2005-02-15 18:38:35-08:00, benh@kernel.crashing.org
   [PATCH] radeonfb: Fix hang on boot with some laptops
   
   It appears that access to the PLL registers of the radeon chip is
   unreliable while the card is in "legacy VGA" text mode. I don't have a
   good explanation yet, it might be the BIOS mucking around behind my
   back. This fixes the lockup by moving the code that enables/disables the
   dynamic power management to after the mode is set.
   
   I'm still waiting for a proper explanation from ATI...
   
   Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2046.1.7, 2005-02-15 14:51:04-08:00, yoshfuji@linux-ipv6.org
   [IPV6]: Fix IPV6_PKTINFO et al. handling in udpv6_recvmsg().
   
   CMSG reception needs to occur even if msg_name is not
   set.
   
   Signed-off-by: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2046.1.6, 2005-02-15 14:23:32-08:00, herbert@gondor.apana.org.au
   [NET]: Add netdev argument to dst ifdown.
   
   This patch adds a net_device argument to ifdown.  After all,
   it's a bit silly to notify someone of an ifdown event without
   telling them what which device it was for :)
   
   Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2046.1.5, 2005-02-15 14:22:41-08:00, herbert@gondor.apana.org.au
   [IPSEC]: Move dst->child loop from dst_ifdown to xfrm_dst_ifdown.
   
   Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2051, 2005-02-15 13:04:21-08:00, torvalds@ppc970.osdl.org
   Input: fix ALPS protocol validation rules
   
   We checked the wrong byte, causing the touchpad
   to lose sync if an absolute packet is received
   after a relative packet with negative Y displacement.
   
   Signed-off-by: Dmitry Torokhov <dtor_core@ameritech.net>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2050, 2005-02-15 12:59:34-08:00, torvalds@ppc970.osdl.org
   Fix bogus opost buffer size check
   
   Noted while going through the n_tty code: that buffer check
   used to check against the size of the temporary kernel buffer,
   but since the tty layer was changed to use kernel buffers
   though-out, the kernel buffer array became just a pointer, and
   the check was limiting the opost blocksize to the size of a
   pointer, which makes no sense.
   
   Just remove it, since now the whole buffer is always in kernel
   space.
 
 ChangeSet@1.2046.2.1, 2005-02-15 11:52:29-08:00, torvalds@ppc970.osdl.org
   Limit tty IO chunking to 2kB
   
   The NTTY code can get confused by 4kB chunks, apparently
   because n_tty_receive_room() will claim to have more room
   than n_tty_receive_buf() can actually accept.
   
   Until somebody figures out what the real n_tty_receive_room()
   logic should be, let's just limit it to a safe 2kB.
   
   Thanks go to Andreas Schwab for finding a test-case.
 
 ChangeSet@1.2046.1.4, 2005-02-15 09:53:23-08:00, olh@suse.de
   [NET]: Fix socket.h comment typo.
   
   Signed-off-by: Olaf Hering <olh@suse.de>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2046.1.3, 2005-02-15 09:28:16-08:00, ralf@linux-mips.org
   [NETROM/ROSE]: Use netdev_priv()
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2046.1.2, 2005-02-15 08:49:36-08:00, davem@nuts.davemloft.net
   [TG3]: Update driver version and reldate.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2046.1.1, 2005-02-15 08:48:26-08:00, davem@nuts.davemloft.net
   [TG3]: Always check tg3_readphy() return value.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2048, 2005-02-15 07:41:38-08:00, davem@nuts.davemloft.net
   [SPARC]: Fix cg3 fb blanking.
   
   cg3_blank() needs to clear the video enable register bit
   to blank the screen, not set it.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2039.3.1, 2005-02-14 14:40:27-08:00, davem@nuts.davemloft.net
   [COMPAT]: TUNSETIFF needs to copy back data after ioctl.
   
   It is defined as a _IOW() which is erroneous, it should
   have been defined as _IORW() but that cannot be changed
   now without breaking all existing applications using this
   ioctl.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
diff -purN linux-2.6.11-rc4-bk3/Makefile linux-2.6.11-rc4-bk4/Makefile
--- linux-2.6.11-rc4-bk3/Makefile	2005-02-16 14:50:12.968043471 +0100
+++ linux-2.6.11-rc4-bk4/Makefile	2005-02-16 14:50:22.041093473 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc4-bk3
+EXTRAVERSION = -rc4-bk4
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc4-bk3/drivers/char/n_tty.c linux-2.6.11-rc4-bk4/drivers/char/n_tty.c
--- linux-2.6.11-rc4-bk3/drivers/char/n_tty.c	2005-02-13 04:04:48.000000000 +0100
+++ linux-2.6.11-rc4-bk4/drivers/char/n_tty.c	2005-02-16 14:50:22.063090037 +0100
@@ -317,8 +317,6 @@ static ssize_t opost_block(struct tty_st
 		return 0;
 	if (nr > space)
 		nr = space;
-	if (nr > sizeof(buf))
-	    nr = sizeof(buf);
 
 	for (i = 0, cp = buf; i < nr; i++, cp++) {
 		switch (*cp) {
diff -purN linux-2.6.11-rc4-bk3/drivers/char/tty_io.c linux-2.6.11-rc4-bk4/drivers/char/tty_io.c
--- linux-2.6.11-rc4-bk3/drivers/char/tty_io.c	2005-02-13 04:06:54.000000000 +0100
+++ linux-2.6.11-rc4-bk4/drivers/char/tty_io.c	2005-02-16 14:50:22.068089256 +0100
@@ -1047,8 +1047,13 @@ static inline ssize_t do_tty_write(
 	 *
 	 * But if TTY_NO_WRITE_SPLIT is set, we should use a
 	 * big chunk-size..
+	 *
+	 * The default chunk-size is 2kB, because the NTTY
+	 * layer has problems with bigger chunks. It will
+	 * claim to be able to handle more characters than
+	 * it actually does.
 	 */
-	chunk = 4096;
+	chunk = 2048;
 	if (test_bit(TTY_NO_WRITE_SPLIT, &tty->flags))
 		chunk = 65536;
 	if (count < chunk)
diff -purN linux-2.6.11-rc4-bk3/drivers/input/mouse/alps.c linux-2.6.11-rc4-bk4/drivers/input/mouse/alps.c
--- linux-2.6.11-rc4-bk3/drivers/input/mouse/alps.c	2005-02-13 04:06:56.000000000 +0100
+++ linux-2.6.11-rc4-bk4/drivers/input/mouse/alps.c	2005-02-16 14:50:22.069089100 +0100
@@ -175,8 +175,8 @@ static psmouse_ret_t alps_process_byte(s
 		return PSMOUSE_BAD_DATA;
 
 	/* Bytes 2 - 6 should have 0 in the highest bit */
-	if (psmouse->pktcnt > 1 && psmouse->pktcnt <= 6 &&
-	    (psmouse->packet[psmouse->pktcnt] & 0x80))
+	if (psmouse->pktcnt >= 2 && psmouse->pktcnt <= 6 &&
+	    (psmouse->packet[psmouse->pktcnt-1] & 0x80))
 		return PSMOUSE_BAD_DATA;
 
 	if (psmouse->pktcnt == 6) {
diff -purN linux-2.6.11-rc4-bk3/drivers/net/tg3.c linux-2.6.11-rc4-bk4/drivers/net/tg3.c
--- linux-2.6.11-rc4-bk3/drivers/net/tg3.c	2005-02-13 04:06:53.000000000 +0100
+++ linux-2.6.11-rc4-bk4/drivers/net/tg3.c	2005-02-16 14:50:22.098084570 +0100
@@ -60,8 +60,8 @@
 
 #define DRV_MODULE_NAME		"tg3"
 #define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"3.22"
-#define DRV_MODULE_RELDATE	"February 11, 2005"
+#define DRV_MODULE_VERSION	"3.23"
+#define DRV_MODULE_RELDATE	"February 15, 2005"
 
 #define TG3_DEF_MAC_MODE	0
 #define TG3_DEF_RX_MODE		0
@@ -591,9 +591,10 @@ static void tg3_phy_set_wirespeed(struct
 	if (tp->tg3_flags2 & TG3_FLG2_NO_ETH_WIRE_SPEED)
 		return;
 
-	tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x7007);
-	tg3_readphy(tp, MII_TG3_AUX_CTRL, &val);
-	tg3_writephy(tp, MII_TG3_AUX_CTRL, (val | (1 << 15) | (1 << 4)));
+	if (!tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x7007) &&
+	    !tg3_readphy(tp, MII_TG3_AUX_CTRL, &val))
+		tg3_writephy(tp, MII_TG3_AUX_CTRL,
+			     (val | (1 << 15) | (1 << 4)));
 }
 
 static int tg3_bmcr_reset(struct tg3 *tp)
@@ -634,9 +635,10 @@ static int tg3_wait_macro_done(struct tg
 	while (limit--) {
 		u32 tmp32;
 
-		tg3_readphy(tp, 0x16, &tmp32);
-		if ((tmp32 & 0x1000) == 0)
-			break;
+		if (!tg3_readphy(tp, 0x16, &tmp32)) {
+			if ((tmp32 & 0x1000) == 0)
+				break;
+		}
 	}
 	if (limit <= 0)
 		return -EBUSY;
@@ -688,9 +690,9 @@ static int tg3_phy_write_and_check_testp
 		for (i = 0; i < 6; i += 2) {
 			u32 low, high;
 
-			tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &low);
-			tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &high);
-			if (tg3_wait_macro_done(tp)) {
+			if (tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &low) ||
+			    tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &high) ||
+			    tg3_wait_macro_done(tp)) {
 				*resetp = 1;
 				return -EBUSY;
 			}
@@ -746,7 +748,9 @@ static int tg3_phy_reset_5703_4_5(struct
 		}
 
 		/* Disable transmitter and interrupt.  */
-		tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);
+		if (tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32))
+			continue;
+
 		reg32 |= 0x3000;
 		tg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);
 
@@ -755,7 +759,9 @@ static int tg3_phy_reset_5703_4_5(struct
 			     BMCR_FULLDPLX | TG3_BMCR_SPEED1000);
 
 		/* Set to master mode.  */
-		tg3_readphy(tp, MII_TG3_CTRL, &phy9_orig);
+		if (tg3_readphy(tp, MII_TG3_CTRL, &phy9_orig))
+			continue;
+
 		tg3_writephy(tp, MII_TG3_CTRL,
 			     (MII_TG3_CTRL_AS_MASTER |
 			      MII_TG3_CTRL_ENABLE_AS_MASTER));
@@ -793,9 +799,11 @@ static int tg3_phy_reset_5703_4_5(struct
 
 	tg3_writephy(tp, MII_TG3_CTRL, phy9_orig);
 
-	tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);
-	reg32 &= ~0x3000;
-	tg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);
+	if (!tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32)) {
+		reg32 &= ~0x3000;
+		tg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);
+	} else if (!err)
+		err = -EBUSY;
 
 	return err;
 }
@@ -859,9 +867,9 @@ out:
 		u32 phy_reg;
 
 		/* Set bit 14 with read-modify-write to preserve other bits */
-		tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0007);
-		tg3_readphy(tp, MII_TG3_AUX_CTRL, &phy_reg);
-		tg3_writephy(tp, MII_TG3_AUX_CTRL, phy_reg | 0x4000);
+		if (!tg3_writephy(tp, MII_TG3_AUX_CTRL, 0x0007) &&
+		    !tg3_readphy(tp, MII_TG3_AUX_CTRL, &phy_reg))
+			tg3_writephy(tp, MII_TG3_AUX_CTRL, phy_reg | 0x4000);
 	}
 	tg3_phy_set_wirespeed(tp);
 	return 0;
@@ -1244,7 +1252,7 @@ static void tg3_aux_stat_to_speed_duplex
 	};
 }
 
-static int tg3_phy_copper_begin(struct tg3 *tp)
+static void tg3_phy_copper_begin(struct tg3 *tp)
 {
 	u32 new_adv;
 	int i;
@@ -1359,15 +1367,16 @@ static int tg3_phy_copper_begin(struct t
 		if (tp->link_config.duplex == DUPLEX_FULL)
 			bmcr |= BMCR_FULLDPLX;
 
-		tg3_readphy(tp, MII_BMCR, &orig_bmcr);
-		if (bmcr != orig_bmcr) {
+		if (!tg3_readphy(tp, MII_BMCR, &orig_bmcr) &&
+		    (bmcr != orig_bmcr)) {
 			tg3_writephy(tp, MII_BMCR, BMCR_LOOPBACK);
 			for (i = 0; i < 1500; i++) {
 				u32 tmp;
 
 				udelay(10);
-				tg3_readphy(tp, MII_BMSR, &tmp);
-				tg3_readphy(tp, MII_BMSR, &tmp);
+				if (tg3_readphy(tp, MII_BMSR, &tmp) ||
+				    tg3_readphy(tp, MII_BMSR, &tmp))
+					continue;
 				if (!(tmp & BMSR_LSTATUS)) {
 					udelay(40);
 					break;
@@ -1380,8 +1389,6 @@ static int tg3_phy_copper_begin(struct t
 		tg3_writephy(tp, MII_BMCR,
 			     BMCR_ANENABLE | BMCR_ANRESTART);
 	}
-
-	return 0;
 }
 
 static int tg3_init_5401phy_dsp(struct tg3 *tp)
@@ -1416,7 +1423,9 @@ static int tg3_copper_is_advertising_all
 {
 	u32 adv_reg, all_mask;
 
-	tg3_readphy(tp, MII_ADVERTISE, &adv_reg);
+	if (tg3_readphy(tp, MII_ADVERTISE, &adv_reg))
+		return 0;
+
 	all_mask = (ADVERTISE_10HALF | ADVERTISE_10FULL |
 		    ADVERTISE_100HALF | ADVERTISE_100FULL);
 	if ((adv_reg & all_mask) != all_mask)
@@ -1424,7 +1433,9 @@ static int tg3_copper_is_advertising_all
 	if (!(tp->tg3_flags & TG3_FLAG_10_100_ONLY)) {
 		u32 tg3_ctrl;
 
-		tg3_readphy(tp, MII_TG3_CTRL, &tg3_ctrl);
+		if (tg3_readphy(tp, MII_TG3_CTRL, &tg3_ctrl))
+			return 0;
+
 		all_mask = (MII_TG3_CTRL_ADV_1000_HALF |
 			    MII_TG3_CTRL_ADV_1000_FULL);
 		if ((tg3_ctrl & all_mask) != all_mask)
@@ -1464,8 +1475,8 @@ static int tg3_setup_copper_phy(struct t
 	     GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) &&
 	    netif_carrier_ok(tp->dev)) {
 		tg3_readphy(tp, MII_BMSR, &bmsr);
-		tg3_readphy(tp, MII_BMSR, &bmsr);
-		if (!(bmsr & BMSR_LSTATUS))
+		if (!tg3_readphy(tp, MII_BMSR, &bmsr) &&
+		    !(bmsr & BMSR_LSTATUS))
 			force_reset = 1;
 	}
 	if (force_reset)
@@ -1473,9 +1484,8 @@ static int tg3_setup_copper_phy(struct t
 
 	if ((tp->phy_id & PHY_ID_MASK) == PHY_ID_BCM5401) {
 		tg3_readphy(tp, MII_BMSR, &bmsr);
-		tg3_readphy(tp, MII_BMSR, &bmsr);
-
-		if (!(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE))
+		if (tg3_readphy(tp, MII_BMSR, &bmsr) ||
+		    !(tp->tg3_flags & TG3_FLAG_INIT_COMPLETE))
 			bmsr = 0;
 
 		if (!(bmsr & BMSR_LSTATUS)) {
@@ -1486,8 +1496,8 @@ static int tg3_setup_copper_phy(struct t
 			tg3_readphy(tp, MII_BMSR, &bmsr);
 			for (i = 0; i < 1000; i++) {
 				udelay(10);
-				tg3_readphy(tp, MII_BMSR, &bmsr);
-				if (bmsr & BMSR_LSTATUS) {
+				if (!tg3_readphy(tp, MII_BMSR, &bmsr) &&
+				    (bmsr & BMSR_LSTATUS)) {
 					udelay(40);
 					break;
 				}
@@ -1549,8 +1559,8 @@ static int tg3_setup_copper_phy(struct t
 	bmsr = 0;
 	for (i = 0; i < 100; i++) {
 		tg3_readphy(tp, MII_BMSR, &bmsr);
-		tg3_readphy(tp, MII_BMSR, &bmsr);
-		if (bmsr & BMSR_LSTATUS)
+		if (!tg3_readphy(tp, MII_BMSR, &bmsr) &&
+		    (bmsr & BMSR_LSTATUS))
 			break;
 		udelay(40);
 	}
@@ -1561,8 +1571,8 @@ static int tg3_setup_copper_phy(struct t
 		tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
 		for (i = 0; i < 2000; i++) {
 			udelay(10);
-			tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);
-			if (aux_stat)
+			if (!tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat) &&
+			    aux_stat)
 				break;
 		}
 
@@ -1573,7 +1583,8 @@ static int tg3_setup_copper_phy(struct t
 		bmcr = 0;
 		for (i = 0; i < 200; i++) {
 			tg3_readphy(tp, MII_BMCR, &bmcr);
-			tg3_readphy(tp, MII_BMCR, &bmcr);
+			if (tg3_readphy(tp, MII_BMCR, &bmcr))
+				continue;
 			if (bmcr && bmcr != 0x7fff)
 				break;
 			udelay(10);
@@ -1610,10 +1621,13 @@ static int tg3_setup_copper_phy(struct t
 	    (tp->link_config.autoneg == AUTONEG_ENABLE)) {
 		u32 local_adv, remote_adv;
 
-		tg3_readphy(tp, MII_ADVERTISE, &local_adv);
+		if (tg3_readphy(tp, MII_ADVERTISE, &local_adv))
+			local_adv = 0;
 		local_adv &= (ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
 
-		tg3_readphy(tp, MII_LPA, &remote_adv);
+		if (tg3_readphy(tp, MII_LPA, &remote_adv))
+			remote_adv = 0;
+
 		remote_adv &= (LPA_PAUSE_CAP | LPA_PAUSE_ASYM);
 
 		/* If we are not advertising full pause capability,
@@ -1632,8 +1646,8 @@ relink:
 		tg3_phy_copper_begin(tp);
 
 		tg3_readphy(tp, MII_BMSR, &tmp);
-		tg3_readphy(tp, MII_BMSR, &tmp);
-		if (tmp & BMSR_LSTATUS)
+		if (!tg3_readphy(tp, MII_BMSR, &tmp) &&
+		    (tmp & BMSR_LSTATUS))
 			current_link_up = 1;
 	}
 
@@ -5441,9 +5455,10 @@ static int tg3_reset_hw(struct tg3 *tp)
 		u32 tmp;
 
 		/* Clear CRC stats. */
-		tg3_readphy(tp, 0x1e, &tmp);
-		tg3_writephy(tp, 0x1e, tmp | 0x8000);
-		tg3_readphy(tp, 0x14, &tmp);
+		if (!tg3_readphy(tp, 0x1e, &tmp)) {
+			tg3_writephy(tp, 0x1e, tmp | 0x8000);
+			tg3_readphy(tp, 0x14, &tmp);
+		}
 	}
 
 	__tg3_set_rx_mode(tp->dev);
@@ -6033,9 +6048,11 @@ static unsigned long calc_crc_errors(str
 		u32 val;
 
 		spin_lock_irqsave(&tp->lock, flags);
-		tg3_readphy(tp, 0x1e, &val);
-		tg3_writephy(tp, 0x1e, val | 0x8000);
-		tg3_readphy(tp, 0x14, &val);
+		if (!tg3_readphy(tp, 0x1e, &val)) {
+			tg3_writephy(tp, 0x1e, val | 0x8000);
+			tg3_readphy(tp, 0x14, &val);
+		} else
+			val = 0;
 		spin_unlock_irqrestore(&tp->lock, flags);
 
 		tp->phy_crc_errors += val;
@@ -6651,10 +6668,10 @@ static int tg3_nway_reset(struct net_dev
 	int r;
   
 	spin_lock_irq(&tp->lock);
-	tg3_readphy(tp, MII_BMCR, &bmcr);
-	tg3_readphy(tp, MII_BMCR, &bmcr);
 	r = -EINVAL;
-	if (bmcr & BMCR_ANENABLE) {
+	tg3_readphy(tp, MII_BMCR, &bmcr);
+	if (!tg3_readphy(tp, MII_BMCR, &bmcr) &&
+	    (bmcr & BMCR_ANENABLE)) {
 		tg3_writephy(tp, MII_BMCR, bmcr | BMCR_ANRESTART);
 		r = 0;
 	}
@@ -7654,9 +7671,8 @@ static int __devinit tg3_phy_probe(struc
 		u32 bmsr, adv_reg, tg3_ctrl;
 
 		tg3_readphy(tp, MII_BMSR, &bmsr);
-		tg3_readphy(tp, MII_BMSR, &bmsr);
-
-		if (bmsr & BMSR_LSTATUS)
+		if (!tg3_readphy(tp, MII_BMSR, &bmsr) &&
+		    (bmsr & BMSR_LSTATUS))
 			goto skip_phy_reset;
 		    
 		err = tg3_phy_reset(tp);
diff -purN linux-2.6.11-rc4-bk3/drivers/video/aty/radeon_base.c linux-2.6.11-rc4-bk4/drivers/video/aty/radeon_base.c
--- linux-2.6.11-rc4-bk3/drivers/video/aty/radeon_base.c	2005-02-13 04:05:51.000000000 +0100
+++ linux-2.6.11-rc4-bk4/drivers/video/aty/radeon_base.c	2005-02-16 14:50:22.121080977 +0100
@@ -2361,13 +2361,6 @@ static int radeonfb_pci_register (struct
 
 	pci_set_drvdata(pdev, info);
 
-	/* Setup Power Management capabilities */
-	if (default_dynclk < -1) {
-		/* -2 is special: means  ON on mobility chips and do not change on others */
-		radeonfb_pm_init(rinfo, rinfo->is_mobility ? 1 : -1);
-	} else
-		radeonfb_pm_init(rinfo, default_dynclk);
-
 	/* Register with fbdev layer */
 	ret = register_framebuffer(info);
 	if (ret < 0) {
@@ -2376,6 +2369,13 @@ static int radeonfb_pci_register (struct
 		goto err_unmap_fb;
 	}
 
+	/* Setup Power Management capabilities */
+	if (default_dynclk < -1) {
+		/* -2 is special: means  ON on mobility chips and do not change on others */
+		radeonfb_pm_init(rinfo, rinfo->is_mobility ? 1 : -1);
+	} else
+		radeonfb_pm_init(rinfo, default_dynclk);
+
 #ifdef CONFIG_MTRR
 	rinfo->mtrr_hdl = nomtrr ? -1 : mtrr_add(rinfo->fb_base_phys,
 						 rinfo->video_ram,
diff -purN linux-2.6.11-rc4-bk3/drivers/video/cg3.c linux-2.6.11-rc4-bk4/drivers/video/cg3.c
--- linux-2.6.11-rc4-bk3/drivers/video/cg3.c	2005-02-13 04:06:55.000000000 +0100
+++ linux-2.6.11-rc4-bk4/drivers/video/cg3.c	2005-02-16 14:50:22.128079884 +0100
@@ -209,7 +209,7 @@ cg3_blank(int blank, struct fb_info *inf
 	case FB_BLANK_HSYNC_SUSPEND: /* VESA blank (hsync off) */
 	case FB_BLANK_POWERDOWN: /* Poweroff */
 		val = sbus_readb(&regs->control);
-		val |= CG3_CR_ENABLE_VIDEO;
+		val &= ~CG3_CR_ENABLE_VIDEO;
 		sbus_writeb(val, &regs->control);
 		par->flags |= CG3_FLAG_BLANKED;
 		break;
diff -purN linux-2.6.11-rc4-bk3/fs/compat_ioctl.c linux-2.6.11-rc4-bk4/fs/compat_ioctl.c
--- linux-2.6.11-rc4-bk3/fs/compat_ioctl.c	2005-02-13 04:08:05.000000000 +0100
+++ linux-2.6.11-rc4-bk4/fs/compat_ioctl.c	2005-02-16 14:50:22.136078634 +0100
@@ -687,6 +687,11 @@ static int dev_ifsioc(unsigned int fd, u
 	set_fs (old_fs);
 	if (!err) {
 		switch (cmd) {
+		/* TUNSETIFF is defined as _IOW, it should be _IORW
+		 * as the data is copied back to user space, but that
+		 * cannot be fixed without breaking all existing apps.
+		 */
+		case TUNSETIFF:
 		case SIOCGIFFLAGS:
 		case SIOCGIFMETRIC:
 		case SIOCGIFMTU:
diff -purN linux-2.6.11-rc4-bk3/include/linux/socket.h linux-2.6.11-rc4-bk4/include/linux/socket.h
--- linux-2.6.11-rc4-bk3/include/linux/socket.h	2005-02-13 04:07:18.000000000 +0100
+++ linux-2.6.11-rc4-bk4/include/linux/socket.h	2005-02-16 14:50:22.158075198 +0100
@@ -120,7 +120,7 @@ struct cmsghdr {
  *	Now it always returns valid, not truncated ancillary object
  *	HEADER. But caller still MUST check, that cmsg->cmsg_len is
  *	inside range, given by msg->msg_controllen before using
- *	ansillary object DATA.				--ANK (980731)
+ *	ancillary object DATA.				--ANK (980731)
  */
  
 __KINLINE struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size,
diff -purN linux-2.6.11-rc4-bk3/include/net/dst.h linux-2.6.11-rc4-bk4/include/net/dst.h
--- linux-2.6.11-rc4-bk3/include/net/dst.h	2005-02-13 04:08:05.000000000 +0100
+++ linux-2.6.11-rc4-bk4/include/net/dst.h	2005-02-16 14:50:22.159075042 +0100
@@ -89,7 +89,8 @@ struct dst_ops
 	int			(*gc)(void);
 	struct dst_entry *	(*check)(struct dst_entry *, __u32 cookie);
 	void			(*destroy)(struct dst_entry *);
-	void			(*ifdown)(struct dst_entry *, int how);
+	void			(*ifdown)(struct dst_entry *,
+					  struct net_device *dev, int how);
 	struct dst_entry *	(*negative_advice)(struct dst_entry *);
 	void			(*link_failure)(struct sk_buff *);
 	void			(*update_pmtu)(struct dst_entry *dst, u32 mtu);
diff -purN linux-2.6.11-rc4-bk3/net/core/dst.c linux-2.6.11-rc4-bk4/net/core/dst.c
--- linux-2.6.11-rc4-bk3/net/core/dst.c	2005-02-13 04:06:55.000000000 +0100
+++ linux-2.6.11-rc4-bk4/net/core/dst.c	2005-02-16 14:50:22.164074261 +0100
@@ -220,31 +220,28 @@ again:
  *
  * Commented and originally written by Alexey.
  */
-static void dst_ifdown(struct dst_entry *dst, int unregister)
+static inline void dst_ifdown(struct dst_entry *dst, struct net_device *dev,
+			      int unregister)
 {
-	struct net_device *dev = dst->dev;
+	if (dst->ops->ifdown)
+		dst->ops->ifdown(dst, dev, unregister);
+
+	if (dev != dst->dev)
+		return;
 
 	if (!unregister) {
 		dst->input = dst_discard_in;
 		dst->output = dst_discard_out;
-	}
-
-	do {
-		if (unregister) {
-			dst->dev = &loopback_dev;
-			dev_hold(&loopback_dev);
+	} else {
+		dst->dev = &loopback_dev;
+		dev_hold(&loopback_dev);
+		dev_put(dev);
+		if (dst->neighbour && dst->neighbour->dev == dev) {
+			dst->neighbour->dev = &loopback_dev;
 			dev_put(dev);
-			if (dst->neighbour && dst->neighbour->dev == dev) {
-				dst->neighbour->dev = &loopback_dev;
-				dev_put(dev);
-				dev_hold(&loopback_dev);
-			}
+			dev_hold(&loopback_dev);
 		}
-
-		if (dst->ops->ifdown)
-			dst->ops->ifdown(dst, unregister);
-	} while ((dst = dst->child) && dst->flags & DST_NOHASH &&
-		 dst->dev == dev);
+	}
 }
 
 static int dst_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
@@ -257,8 +254,7 @@ static int dst_dev_event(struct notifier
 	case NETDEV_DOWN:
 		spin_lock_bh(&dst_lock);
 		for (dst = dst_garbage_list; dst; dst = dst->next) {
-			if (dst->dev == dev)
-				dst_ifdown(dst, event != NETDEV_DOWN);
+			dst_ifdown(dst, dev, event != NETDEV_DOWN);
 		}
 		spin_unlock_bh(&dst_lock);
 		break;
diff -purN linux-2.6.11-rc4-bk3/net/ipv4/route.c linux-2.6.11-rc4-bk4/net/ipv4/route.c
--- linux-2.6.11-rc4-bk3/net/ipv4/route.c	2005-02-13 04:08:06.000000000 +0100
+++ linux-2.6.11-rc4-bk4/net/ipv4/route.c	2005-02-16 14:50:22.169073480 +0100
@@ -138,7 +138,8 @@ static struct timer_list rt_secret_timer
 
 static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie);
 static void		 ipv4_dst_destroy(struct dst_entry *dst);
-static void		 ipv4_dst_ifdown(struct dst_entry *dst, int how);
+static void		 ipv4_dst_ifdown(struct dst_entry *dst,
+					 struct net_device *dev, int how);
 static struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);
 static void		 ipv4_link_failure(struct sk_buff *skb);
 static void		 ip_rt_update_pmtu(struct dst_entry *dst, u32 mtu);
@@ -1342,11 +1343,12 @@ static void ipv4_dst_destroy(struct dst_
 	}
 }
 
-static void ipv4_dst_ifdown(struct dst_entry *dst, int how)
+static void ipv4_dst_ifdown(struct dst_entry *dst, struct net_device *dev,
+			    int how)
 {
 	struct rtable *rt = (struct rtable *) dst;
 	struct in_device *idev = rt->idev;
-	if (idev && idev->dev != &loopback_dev) {
+	if (dev != &loopback_dev && idev && idev->dev == dev) {
 		struct in_device *loopback_idev = in_dev_get(&loopback_dev);
 		if (loopback_idev) {
 			rt->idev = loopback_idev;
diff -purN linux-2.6.11-rc4-bk3/net/ipv6/route.c linux-2.6.11-rc4-bk4/net/ipv6/route.c
--- linux-2.6.11-rc4-bk3/net/ipv6/route.c	2005-02-13 04:07:01.000000000 +0100
+++ linux-2.6.11-rc4-bk4/net/ipv6/route.c	2005-02-16 14:50:22.172073011 +0100
@@ -84,7 +84,8 @@ static struct rt6_info * ip6_rt_copy(str
 static struct dst_entry	*ip6_dst_check(struct dst_entry *dst, u32 cookie);
 static struct dst_entry *ip6_negative_advice(struct dst_entry *);
 static void		ip6_dst_destroy(struct dst_entry *);
-static void		ip6_dst_ifdown(struct dst_entry *, int how);
+static void		ip6_dst_ifdown(struct dst_entry *,
+				       struct net_device *dev, int how);
 static int		 ip6_dst_gc(void);
 
 static int		ip6_pkt_discard(struct sk_buff *skb);
@@ -153,12 +154,13 @@ static void ip6_dst_destroy(struct dst_e
 	}	
 }
 
-static void ip6_dst_ifdown(struct dst_entry *dst, int how)
+static void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,
+			   int how)
 {
 	struct rt6_info *rt = (struct rt6_info *)dst;
 	struct inet6_dev *idev = rt->rt6i_idev;
 
-	if (idev != NULL && idev->dev != &loopback_dev) {
+	if (dev != &loopback_dev && idev != NULL && idev->dev == dev) {
 		struct inet6_dev *loopback_idev = in6_dev_get(&loopback_dev);
 		if (loopback_idev != NULL) {
 			rt->rt6i_idev = loopback_idev;
diff -purN linux-2.6.11-rc4-bk3/net/ipv6/udp.c linux-2.6.11-rc4-bk4/net/ipv6/udp.c
--- linux-2.6.11-rc4-bk3/net/ipv6/udp.c	2005-02-13 04:07:19.000000000 +0100
+++ linux-2.6.11-rc4-bk4/net/ipv6/udp.c	2005-02-16 14:50:22.175072543 +0100
@@ -219,6 +219,7 @@ static int udpv6_recvmsg(struct kiocb *i
 		  int noblock, int flags, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
+	struct inet_sock *inet = inet_sk(sk);
   	struct sk_buff *skb;
 	size_t copied;
   	int err;
@@ -268,21 +269,22 @@ try_again:
 		sin6->sin6_flowinfo = 0;
 		sin6->sin6_scope_id = 0;
 
-		if (skb->protocol == htons(ETH_P_IP)) {
-			struct inet_sock *inet = inet_sk(sk);
-
+		if (skb->protocol == htons(ETH_P_IP))
 			ipv6_addr_set(&sin6->sin6_addr, 0, 0,
 				      htonl(0xffff), skb->nh.iph->saddr);
-			if (inet->cmsg_flags)
-				ip_cmsg_recv(msg, skb);
-		} else {
+		else {
 			ipv6_addr_copy(&sin6->sin6_addr, &skb->nh.ipv6h->saddr);
-
-			if (np->rxopt.all)
-				datagram_recv_ctl(sk, msg, skb);
 			if (ipv6_addr_type(&sin6->sin6_addr) & IPV6_ADDR_LINKLOCAL)
 				sin6->sin6_scope_id = IP6CB(skb)->iif;
 		}
+
+	}
+	if (skb->protocol == htons(ETH_P_IP)) {
+		if (inet->cmsg_flags)
+			ip_cmsg_recv(msg, skb);
+	} else {
+		if (np->rxopt.all)
+			datagram_recv_ctl(sk, msg, skb);
   	}
 
 	err = copied;
diff -purN linux-2.6.11-rc4-bk3/net/netrom/nr_dev.c linux-2.6.11-rc4-bk4/net/netrom/nr_dev.c
--- linux-2.6.11-rc4-bk3/net/netrom/nr_dev.c	2005-02-13 04:07:40.000000000 +0100
+++ linux-2.6.11-rc4-bk4/net/netrom/nr_dev.c	2005-02-16 14:50:22.176072386 +0100
@@ -46,7 +46,7 @@
 
 int nr_rx_ip(struct sk_buff *skb, struct net_device *dev)
 {
-	struct net_device_stats *stats = (struct net_device_stats *)dev->priv;
+	struct net_device_stats *stats = netdev_priv(dev);
 
 	if (!netif_running(dev)) {
 		stats->rx_errors++;
@@ -73,7 +73,7 @@ int nr_rx_ip(struct sk_buff *skb, struct
 static int nr_rebuild_header(struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
-	struct net_device_stats *stats = (struct net_device_stats *)dev->priv;
+	struct net_device_stats *stats = netdev_priv(dev);
 	struct sk_buff *skbn;
 	unsigned char *bp = skb->data;
 	int len;
@@ -186,7 +186,7 @@ static int nr_close(struct net_device *d
 
 static int nr_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct net_device_stats *stats = (struct net_device_stats *)dev->priv;
+	struct net_device_stats *stats = netdev_priv(dev);
 	dev_kfree_skb(skb);
 	stats->tx_errors++;
 	return 0;
@@ -194,7 +194,7 @@ static int nr_xmit(struct sk_buff *skb, 
 
 static struct net_device_stats *nr_get_stats(struct net_device *dev)
 {
-	return (struct net_device_stats *)dev->priv;
+	return netdev_priv(dev);
 }
 
 void nr_setup(struct net_device *dev)
diff -purN linux-2.6.11-rc4-bk3/net/rose/rose_dev.c linux-2.6.11-rc4-bk4/net/rose/rose_dev.c
--- linux-2.6.11-rc4-bk3/net/rose/rose_dev.c	2005-02-13 04:05:41.000000000 +0100
+++ linux-2.6.11-rc4-bk4/net/rose/rose_dev.c	2005-02-16 14:50:22.177072230 +0100
@@ -57,7 +57,7 @@ static int rose_header(struct sk_buff *s
 static int rose_rebuild_header(struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
-	struct net_device_stats *stats = (struct net_device_stats *)dev->priv;
+	struct net_device_stats *stats = netdev_priv(dev);
 	unsigned char *bp = (unsigned char *)skb->data;
 	struct sk_buff *skbn;
 
@@ -117,7 +117,7 @@ static int rose_close(struct net_device 
 
 static int rose_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct net_device_stats *stats = (struct net_device_stats *)dev->priv;
+	struct net_device_stats *stats = netdev_priv(dev);
 
 	if (!netif_running(dev)) {
 		printk(KERN_ERR "ROSE: rose_xmit - called when iface is down\n");
@@ -130,7 +130,7 @@ static int rose_xmit(struct sk_buff *skb
 
 static struct net_device_stats *rose_get_stats(struct net_device *dev)
 {
-	return (struct net_device_stats *)dev->priv;
+	return netdev_priv(dev);
 }
 
 void rose_setup(struct net_device *dev)
diff -purN linux-2.6.11-rc4-bk3/net/xfrm/xfrm_policy.c linux-2.6.11-rc4-bk4/net/xfrm/xfrm_policy.c
--- linux-2.6.11-rc4-bk3/net/xfrm/xfrm_policy.c	2005-02-13 04:06:24.000000000 +0100
+++ linux-2.6.11-rc4-bk4/net/xfrm/xfrm_policy.c	2005-02-16 14:50:22.180071762 +0100
@@ -1043,6 +1043,19 @@ static void xfrm_dst_destroy(struct dst_
 	dst->xfrm = NULL;
 }
 
+static void xfrm_dst_ifdown(struct dst_entry *dst, struct net_device *dev,
+			    int unregister)
+{
+	if (!unregister)
+		return;
+
+	while ((dst = dst->child) && dst->xfrm && dst->dev == dev) {
+		dst->dev = &loopback_dev;
+		dev_hold(&loopback_dev);
+		dev_put(dev);
+	}
+}
+
 static void xfrm_link_failure(struct sk_buff *skb)
 {
 	/* Impossible. Such dst must be popped before reaches point of failure. */
@@ -1166,6 +1179,8 @@ int xfrm_policy_register_afinfo(struct x
 			dst_ops->check = xfrm_dst_check;
 		if (likely(dst_ops->destroy == NULL))
 			dst_ops->destroy = xfrm_dst_destroy;
+		if (likely(dst_ops->ifdown == NULL))
+			dst_ops->ifdown = xfrm_dst_ifdown;
 		if (likely(dst_ops->negative_advice == NULL))
 			dst_ops->negative_advice = xfrm_negative_advice;
 		if (likely(dst_ops->link_failure == NULL))
@@ -1198,6 +1213,7 @@ int xfrm_policy_unregister_afinfo(struct
 			dst_ops->kmem_cachep = NULL;
 			dst_ops->check = NULL;
 			dst_ops->destroy = NULL;
+			dst_ops->ifdown = NULL;
 			dst_ops->negative_advice = NULL;
 			dst_ops->link_failure = NULL;
 			dst_ops->get_mss = NULL;
