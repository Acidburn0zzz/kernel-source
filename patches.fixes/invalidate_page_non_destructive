From: Andrea Arcangeli <andrea@suse.de>
Subject: Make invalidate_inode_pages2 non-destructive
Patch-mainline: pending
References: 133890

Note: 30aug2006
  Slightly revised patch submitted to akpm.  However apparent Nick Piggin
  has something in the works that will make this fairly redundant, or at
  least change it substantially - his patch would cause filemap_nopage
  to lock that page so that certain races will be avoided completely.

Make invalidate_inode_pages2 non-destructive so that dirty pages never
get removed.  Otherwise nfs writes can be lost if they happen at an awkward time.


Signed-off-by: Neil Brown <neilb@suse.de>

---
 mm/truncate.c |   21 +++++++++++----------
 1 files changed, 11 insertions(+), 10 deletions(-)

--- linux-2.6.18.orig/mm/truncate.c
+++ linux-2.6.18/mm/truncate.c
@@ -310,9 +310,14 @@ failed:
  * @end: the page offset 'to' which to invalidate (inclusive)
  *
  * Any pages which are found to be mapped into pagetables are unmapped prior to
- * invalidation.
+ * invalidation. invalidate_inode_pages2_range is non destructive and it can't
+ * lose dirty data (if dirty data exists -EIO will be returned). It's up to
+ * the caller to call unmap_mapping_range and filemap_write_and_wait before
+ * invalidate_inode_pages2 if needed.
  *
- * Returns -EIO if any pages could not be invalidated.
+ * Returns -EIO if any pages could not be invalidated. Before returning -EIO
+ * it tries invalidating all pages in the range, it doesn't stop at the first
+ * page invalidation failure.
  */
 int invalidate_inode_pages2_range(struct address_space *mapping,
 				  pgoff_t start, pgoff_t end)
@@ -326,13 +331,12 @@ int invalidate_inode_pages2_range(struct
 
 	pagevec_init(&pvec, 0);
 	next = start;
-	while (next <= end && !ret && !wrapped &&
+	while (next <= end && !wrapped &&
 		pagevec_lookup(&pvec, mapping, next,
 			min(end - next, (pgoff_t)PAGEVEC_SIZE - 1) + 1)) {
-		for (i = 0; !ret && i < pagevec_count(&pvec); i++) {
+		for (i = 0; i < pagevec_count(&pvec); i++) {
 			struct page *page = pvec.pages[i];
 			pgoff_t page_index;
-			int was_dirty;
 
 			lock_page(page);
 			if (page->mapping != mapping) {
@@ -368,12 +372,9 @@ int invalidate_inode_pages2_range(struct
 					  PAGE_CACHE_SIZE, 0);
 				}
 			}
-			was_dirty = test_clear_page_dirty(page);
-			if (!invalidate_complete_page2(mapping, page)) {
-				if (was_dirty)
-					set_page_dirty(page);
+
+			if (!invalidate_complete_page2(mapping, page))
 				ret = -EIO;
-			}
 			unlock_page(page);
 		}
 		pagevec_release(&pvec);
