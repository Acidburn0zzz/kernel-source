

Withdraw call_usermodehelper_async() from the kernel API and change
call_usermodehelper() so that it always uses the async version if the caller
doesn't want to wait on the exec.

This makes the kernel API a bit cleaner and get the new code more test
coverage.  it has the downside that call_usermodehelper() gets a little more
expensive and that the caller of call_usermodehelper() doesn't get to know
whether kernel_thread() succeeded.


---

 25-akpm/include/linux/kmod.h |    2 --
 25-akpm/kernel/kmod.c        |    6 ++++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff -puN kernel/kmod.c~call_usermodehelper_async-always kernel/kmod.c
--- 25/kernel/kmod.c~call_usermodehelper_async-always	2004-04-12 01:22:08.262986048 -0700
+++ 25-akpm/kernel/kmod.c	2004-04-12 01:22:47.672994816 -0700
@@ -246,7 +246,7 @@ static void __call_usermodehelper(void *
  * be used in extremis, such as when the caller unavoidably holds locks which
  * keventd might block on.
  */
-int call_usermodehelper_async(char *path, char **argv,
+static int call_usermodehelper_async(char *path, char **argv,
 				char **envp, int gfp_flags)
 {
 	struct subprocess_info *sub_info;
@@ -277,7 +277,6 @@ enomem:
 	destroy_subinfo(sub_info);
 	return -ENOMEM;
 }
-EXPORT_SYMBOL(call_usermodehelper_async);
 
 /**
  * call_usermodehelper - start a usermode application
@@ -306,6 +305,9 @@ int call_usermodehelper(char *path, char
 	};
 	DECLARE_WORK(work, __call_usermodehelper, &sub_info);
 
+	if (!wait)
+		return call_usermodehelper_async(path, argv, envp, GFP_NOIO);
+
 	if (0 && system_state != SYSTEM_RUNNING)
 		return -EBUSY;
 
diff -puN include/linux/kmod.h~call_usermodehelper_async-always include/linux/kmod.h
--- 25/include/linux/kmod.h~call_usermodehelper_async-always	2004-04-12 01:22:43.386646440 -0700
+++ 25-akpm/include/linux/kmod.h	2004-04-12 01:22:53.144163072 -0700
@@ -34,8 +34,6 @@ static inline int request_module(const c
 #define try_then_request_module(x, mod...) ((x) ?: (request_module(mod), (x)))
 
 int call_usermodehelper(char *path, char **argv, char **envp, int wait);
-int call_usermodehelper_async(char *path, char **argv,
-				char **envp, int gfp_flags);
 
 #ifdef CONFIG_HOTPLUG
 extern char hotplug_path [];

_
