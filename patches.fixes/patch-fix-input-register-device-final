--- linux-2.6.8/net/bluetooth/hidp/core.c.orig	2004-07-26 19:47:01 +02:00
+++ linux-2.6.8/net/bluetooth/hidp/core.c	2004-09-28 13:30:09 +02:00
@@ -411,6 +411,7 @@
 static inline void hidp_setup_input(struct hidp_session *session, struct hidp_connadd_req *req)
 {
 	struct input_dev *input = session->input;
+	bdaddr_t bdaddr;
 	int i;
 
 	input->private = session;
@@ -419,6 +420,9 @@
 	input->id.vendor  = req->vendor;
 	input->id.product = req->product;
 	input->id.version = req->version;
+
+	baswap(&bdaddr, &session->bdaddr);
+	sprintf(input->cdev.class_id, "hidp_%s", batostr(&bdaddr));
 
 	if (req->subclass & 0x40) {
 		set_bit(EV_KEY, input->evbit);
--- linux-2.6.8/arch/um/drivers/x11_kern.c.orig	2004-09-28 15:05:28.011773216 +0200
+++ linux-2.6.8/arch/um/drivers/x11_kern.c	2004-09-28 15:05:08.248777648 +0200
@@ -271,6 +271,7 @@
 	kd->kbd.id.bustype = BUS_HOST;
 	kd->kbd.name = "virtual keyboard";
 	kd->kbd.phys = "x11/input0";
+	sprintf(kd->kbd.cdev.class_id,"x11kbd");
 	input_register_device(&kd->kbd);
 
 	/* mouse setup */
@@ -290,6 +291,7 @@
 	kd->mouse.id.bustype = BUS_HOST;
 	kd->mouse.name = "virtual mouse";
 	kd->mouse.phys = "x11/input1";
+	sprintf(kd->mouse.cdev.class_id,"x11mouse");
 	input_register_device(&kd->mouse);
 
 	/* misc common kernel stuff */
--- linux-2.6.8/sound/oss/dmasound/dmasound_awacs.c.orig	2004-08-14 07:36:45.000000000 +0200
+++ linux-2.6.8/sound/oss/dmasound/dmasound_awacs.c	2004-09-28 15:11:46.296265232 +0200
@@ -2821,6 +2821,9 @@
 	.id		= {
 		.bustype	= BUS_HOST,
 	},
+	.cdev		= {
+		.class_id	= "dmasound_awacs",
+	},
 };
 
 int __init dmasound_awacs_init(void)
--- linux-2.6.8/sound/ppc/beep.c.orig	2004-09-24 09:06:00.000000000 +0200
+++ linux-2.6.8/sound/ppc/beep.c	2004-09-28 15:14:08.631626968 +0200
@@ -39,6 +39,8 @@
 	struct input_dev dev;
 };
 
+static int pmac_beep_num;
+
 /*
  * stop beep if running
  */
@@ -236,6 +238,7 @@
 	beep->dev.id.vendor = 0x001f;
 	beep->dev.id.product = 0x0001;
 	beep->dev.id.version = 0x0100;
+	sprintf(beep->dev.cdev.class_id,"beep%d", pmac_beep_num++);
 
 	beep->volume = BEEP_VOLUME;
 	beep->running = 0;
--- linux-2.6.8/drivers/usb/input/xpad.c.orig	2004-08-14 07:36:58.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/xpad.c	2004-09-28 14:43:24.962907216 +0200
@@ -113,6 +113,8 @@
 	int open_count;				/* reference count */
 };
 
+static int usb_xpad_num;
+
 /*
  *	xpad_process_packet
  *
@@ -273,7 +275,8 @@
 	xpad->dev.phys = xpad->phys;
 	xpad->dev.open = xpad_open;
 	xpad->dev.close = xpad_close;
-	
+	sprintf(xpad->dev.cdev.class_id,"xpad%d",usb_xpad_num++);
+
 	usb_make_path(udev, path, 64);
 	snprintf(xpad->phys, 64,  "%s/input0", path);
 	
--- linux-2.6.8/drivers/usb/input/touchkitusb.c.orig	2004-08-14 07:36:18.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/touchkitusb.c	2004-09-28 14:27:23.196117992 +0200
@@ -70,6 +70,8 @@
 	char phys[64];
 };
 
+static int touchkit_num;
+
 static struct usb_device_id touchkit_devices[] = {
 	{USB_DEVICE(0x3823, 0x0001)},
 	{USB_DEVICE(0x0eef, 0x0001)},
@@ -204,6 +206,7 @@
 	touchkit->input.id.product = udev->descriptor.idProduct;
 	touchkit->input.id.version = udev->descriptor.bcdDevice;
 	touchkit->input.dev = &intf->dev;
+	sprintf(touchkit->input.cdev.class_id,"touchkit%d", touchkit_num++);
 
 	touchkit->input.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 	touchkit->input.absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
--- linux-2.6.8/drivers/usb/input/usbmouse.c.orig	2004-08-14 07:38:04.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/usbmouse.c	2004-09-28 14:33:43.824253720 +0200
@@ -57,6 +57,8 @@
 	dma_addr_t data_dma;
 };
 
+static int usb_mouse_num;
+
 static void usb_mouse_irq(struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_mouse *mouse = urb->context;
@@ -184,6 +186,7 @@
 	mouse->dev.id.product = dev->descriptor.idProduct;
 	mouse->dev.id.version = dev->descriptor.bcdDevice;
 	mouse->dev.dev = &intf->dev;
+	sprintf(mouse->dev.cdev.class_id,"usbmouse%d",usb_mouse_num++);
 
 	if (!(buf = kmalloc(63, GFP_KERNEL))) {
 		usb_buffer_free(dev, 8, mouse->data, mouse->data_dma);
--- linux-2.6.8/drivers/usb/input/mtouchusb.c.orig	2004-08-14 07:36:59.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/mtouchusb.c	2004-09-28 14:35:48.390316800 +0200
@@ -85,6 +85,8 @@
         char phys[64];
 };
 
+static int mtouch_usb_num;
+
 static struct usb_device_id mtouchusb_devices [] = {
         { USB_DEVICE(0x0596, 0x0001) },
         { }
@@ -227,6 +229,7 @@
         mtouch->input.id.product = udev->descriptor.idProduct;
         mtouch->input.id.version = udev->descriptor.bcdDevice;
         mtouch->input.dev = &intf->dev;
+	sprintf(mtouch->input.cdev.class_id,"mtouchusb%d",mtouch_usb_num++);
 
         mtouch->input.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
         mtouch->input.absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
--- linux-2.6.8/drivers/usb/input/powermate.c.orig	2004-08-14 07:37:15.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/powermate.c	2004-09-28 14:36:53.006493648 +0200
@@ -78,6 +78,8 @@
 	char phys[64];
 };
 
+static int powermate_num;
+
 static char pm_name_powermate[] = "Griffin PowerMate";
 static char pm_name_soundknob[] = "Griffin SoundKnob";
 
@@ -394,6 +396,7 @@
 	pm->input.id.version = udev->descriptor.bcdDevice;
 	pm->input.event = powermate_input_event;
 	pm->input.dev = &intf->dev;
+	sprintf(pm->input.cdev.class_id,"powermate%d",powermate_num++);
 
 	input_register_device(&pm->input);
 
--- linux-2.6.8/drivers/usb/input/kbtab.c.orig	2004-09-24 09:05:41.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/kbtab.c	2004-09-28 13:16:11.776472480 +0200
@@ -179,6 +179,7 @@
 	kbtab->dev.id.product = dev->descriptor.idProduct;
 	kbtab->dev.id.version = dev->descriptor.bcdDevice;
 	kbtab->dev.dev = &intf->dev;
+	sprintf(kbtab->dev.cdev.class_id,"kbtab");
 	kbtab->usbdev = dev;
 
 	endpoint = &intf->cur_altsetting->endpoint[0].desc;
--- linux-2.6.8/drivers/usb/input/aiptek.c.orig	2004-09-24 09:05:41.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/aiptek.c	2004-09-28 14:31:36.178658800 +0200
@@ -335,6 +335,8 @@
 	unsigned char *data;			/* incoming packet data          */
 };
 
+static int aiptek_num;
+
 /*
  * Permit easy lookup of keyboard events to send, versus
  * the bitmap which comes from the tablet. This hides the
@@ -2140,6 +2142,7 @@
 	aiptek->inputdev.id.vendor = usbdev->descriptor.idVendor;
 	aiptek->inputdev.id.product = usbdev->descriptor.idProduct;
 	aiptek->inputdev.id.version = usbdev->descriptor.bcdDevice;
+	sprintf(aiptek->inputdev.cdev.class_id,"aiptek%d",aiptek_num++);
 
 	aiptek->usbdev = usbdev;
 	aiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber;
--- linux-2.6.8/drivers/usb/input/ati_remote.c.orig	2004-09-24 09:05:41.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/ati_remote.c	2004-09-28 14:32:41.545721496 +0200
@@ -186,6 +186,8 @@
 	int send_flags;
 };
 
+static int ati_remote_num;
+
 /* "Kinds" of messages sent from the hardware to the driver. */
 #define KIND_END        0
 #define KIND_LITERAL    1   /* Simply pass to input system */
@@ -672,6 +674,7 @@
 	idev->id.vendor = ati_remote->udev->descriptor.idVendor;
 	idev->id.product = ati_remote->udev->descriptor.idProduct;
 	idev->id.version = ati_remote->udev->descriptor.bcdDevice;
+	sprintf(idev->cdev.class_id,"ati-remote-%d",ati_remote_num++);
 }
 
 static int ati_remote_initialize(struct ati_remote *ati_remote)
--- linux-2.6.8/drivers/usb/input/usbkbd.c.orig	2004-08-14 07:38:04.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/usbkbd.c	2004-09-28 14:29:19.241476416 +0200
@@ -82,6 +82,8 @@
 	dma_addr_t leds_dma;
 };
 
+static int usb_kbd_num;
+
 static void usb_kbd_irq(struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_kbd *kbd = urb->context;
@@ -300,6 +302,7 @@
 	kbd->dev.id.product = dev->descriptor.idProduct;
 	kbd->dev.id.version = dev->descriptor.bcdDevice;
 	kbd->dev.dev = &iface->dev;
+	sprintf(kbd->dev.cdev.class_id,"usbkbd%d",usb_kbd_num++);
 
 	if (!(buf = kmalloc(63, GFP_KERNEL))) {
 		usb_free_urb(kbd->irq);
--- linux-2.6.8/drivers/usb/input/wacom.c.orig	2004-08-14 07:36:13.000000000 +0200
+++ linux-2.6.8/drivers/usb/input/wacom.c	2004-09-28 14:28:15.210210648 +0200
@@ -107,6 +107,8 @@
 	char phys[32];
 };
 
+static int wacom_num;
+
 #define USB_REQ_SET_REPORT	0x09
 static int usb_set_report(struct usb_interface *intf, unsigned char type,
 				unsigned char id, void *buf, int size)
@@ -697,6 +699,7 @@
 	wacom->dev.id.version = dev->descriptor.bcdDevice;
 	wacom->dev.dev = &intf->dev;
 	wacom->usbdev = dev;
+	sprintf(wacom->dev.cdev.class_id,"wacom%d",wacom_num++);
 
 	endpoint = &intf->cur_altsetting->endpoint[0].desc;
 
--- linux-2.6.8/drivers/usb/media/konicawc.c.orig	2004-09-24 09:05:41.000000000 +0200
+++ linux-2.6.8/drivers/usb/media/konicawc.c	2004-09-28 14:25:43.393290328 +0200
@@ -123,6 +123,7 @@
 #endif
 };
 
+static int konicawc_num;
 
 #define konicawc_set_misc(uvd, req, value, index)		konicawc_ctrl_msg(uvd, USB_DIR_OUT, req, value, index, NULL, 0)
 #define konicawc_get_misc(uvd, req, value, index, buf, sz)	konicawc_ctrl_msg(uvd, USB_DIR_IN, req, value, index, buf, sz)
@@ -854,6 +855,7 @@
 		cam->input.id.vendor = dev->descriptor.idVendor;
 		cam->input.id.product = dev->descriptor.idProduct;
 		cam->input.id.version = dev->descriptor.bcdDevice;
+		sprintf(cam->input.cdev.class_id,"konicawc%d", konicawc_num++);
 		input_register_device(&cam->input);
 		
 		usb_make_path(dev, cam->input_physname, 56);
--- linux-2.6.8/drivers/char/sonypi.c.orig	2004-09-24 09:05:30.000000000 +0200
+++ linux-2.6.8/drivers/char/sonypi.c	2004-09-28 14:24:07.291899960 +0200
@@ -814,6 +814,7 @@
 		sprintf(sonypi_device.jog_dev.name, SONYPI_INPUTNAME);
 		sonypi_device.jog_dev.id.bustype = BUS_ISA;
 		sonypi_device.jog_dev.id.vendor = PCI_VENDOR_ID_SONY;
+		sprintf(sonypi_device.jog_dev.cdev.class_id,"sonypi-jogdial");
 	  
 		input_register_device(&sonypi_device.jog_dev);
 		printk(KERN_INFO "%s installed.\n", sonypi_device.jog_dev.name);
--- linux-2.6.8/drivers/input/touchscreen/h3600_ts_input.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/touchscreen/h3600_ts_input.c	2004-09-28 14:18:20.821571456 +0200
@@ -109,6 +109,8 @@
 	char phys[32];
 };
 
+static int h3600_ts_num;
+
 static irqreturn_t action_button_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
         int down = (GPLR & GPIO_BITSY_ACTION_BUTTON) ? 0 : 1;
@@ -456,6 +458,8 @@
 					h3600ts_pm_callback);
 	printk("registered pm callback\n");
 #endif
+	ts->dev.dev = get_device(&serio->dev);
+	sprintf(ts->dev.cdev.class_id,"ts%d", h3600_ts_num++);
 	input_register_device(&ts->dev);
 
 	printk(KERN_INFO "input: %s on %s\n", h3600_name, serio->phys);
@@ -472,6 +476,7 @@
         free_irq(IRQ_GPIO_BITSY_ACTION_BUTTON, &ts->dev);
         free_irq(IRQ_GPIO_BITSY_NPOWER_BUTTON, &ts->dev);
 	input_unregister_device(&ts->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(ts);
 }
--- linux-2.6.8/drivers/input/touchscreen/gunze.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/touchscreen/gunze.c	2004-09-28 14:40:45.841097408 +0200
@@ -49,6 +49,7 @@
 #define	GUNZE_MAX_LENGTH	10
 
 static char *gunze_name = "Gunze AHL-51S TouchScreen";
+static int gunze_num;
 
 /*
  * Per-touchscreen data.
@@ -103,6 +104,7 @@
 {
 	struct gunze* gunze = serio->private;
 	input_unregister_device(&gunze->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(gunze);
 }
@@ -149,6 +151,8 @@
 		return;
 	}
 
+	gunze->dev.dev = get_device(&serio->dev);
+	sprintf(gunze->dev.cdev.class_id,"gunze%d",gunze_num++);
 	input_register_device(&gunze->dev);
 
 	printk(KERN_INFO "input: %s on %s\n", gunze_name, serio->phys);
--- linux-2.6.8/drivers/input/input.c.orig	2004-09-28 10:03:53.000000000 +0200
+++ linux-2.6.8/drivers/input/input.c	2004-09-28 14:50:35.501455408 +0200
@@ -25,7 +25,7 @@
 #include <linux/device.h>
 #include <linux/devfs_fs_kernel.h>
 
-#define INPUT_DEBUG
+#undef INPUT_DEBUG
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
 MODULE_DESCRIPTION("Input core");
@@ -52,6 +52,8 @@
 
 static struct input_handler *input_table[8];
 
+static int input_device_num;
+
 #ifdef CONFIG_PROC_FS
 static struct proc_dir_entry *proc_bus_input_dir;
 DECLARE_WAIT_QUEUE_HEAD(input_devices_poll_wait);
@@ -518,6 +520,12 @@
 #endif
 
 	dev->cdev.dev = get_device(dev->dev);
+	if (!dev->cdev.class_id[0]) {
+		printk(KERN_WARNING "No class name for input device %s at %s",
+		       dev->name, dev->phys);
+		sprintf(dev->cdev.class_id,"device%d", input_device_num++);
+	}
+
 	if (class_device_register(&dev->cdev)) {
 		put_device(dev->dev);
 		return;
--- linux-2.6.8/drivers/input/joystick/db9.c.orig	2004-08-14 07:36:32.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/db9.c	2004-09-28 14:09:47.470612664 +0200
@@ -597,6 +597,7 @@
 		db9->dev[i].id.vendor = 0x0002;
 		db9->dev[i].id.product = config[1];
 		db9->dev[i].id.version = 0x0100;
+		sprintf(db9->dev[i].cdev.class_id,"db9-%d",i);
 
 		db9->dev[i].evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 		for (j = 0; j < db9_buttons[db9->mode]; j++)
--- linux-2.6.8/drivers/input/joystick/magellan.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/magellan.c	2004-09-28 14:02:21.047479296 +0200
@@ -62,6 +62,8 @@
 	char phys[32];
 };
 
+static int magellan_num;
+
 /*
  * magellan_crunch_nibbles() verifies that the bytes sent from the Magellan
  * have correct upper nibbles for the lower ones, if not, the packet will
@@ -138,6 +140,7 @@
 {
 	struct magellan* magellan = serio->private;
 	input_unregister_device(&magellan->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(magellan);
 }
@@ -183,10 +186,13 @@
 	magellan->dev.id.vendor = SERIO_MAGELLAN;
 	magellan->dev.id.product = 0x0001;
 	magellan->dev.id.version = 0x0100;
+	magellan->dev.dev = get_device(&serio->dev);
+	sprintf(magellan->dev.cdev.class_id,"magellan%d", magellan_num++);
 
 	serio->private = magellan;
 
 	if (serio_open(serio, drv)) {
+		put_device(&serio->dev);
 		kfree(magellan);
 		return;
 	}
--- linux-2.6.8/drivers/input/joystick/spaceorb.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/spaceorb.c	2004-09-28 14:39:49.522659112 +0200
@@ -66,6 +66,8 @@
 	char phys[32];
 };
 
+static int spaceorb_num;
+
 static unsigned char spaceorb_xor[] = "SpaceWare";
 
 static unsigned char *spaceorb_errors[] = { "EEPROM storing 0 failed", "Receive queue overflow", "Transmit queue timeout",
@@ -153,7 +155,9 @@
 static void spaceorb_disconnect(struct serio *serio)
 {
 	struct spaceorb* spaceorb = serio->private;
+
 	input_unregister_device(&spaceorb->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(spaceorb);
 }
@@ -200,6 +204,8 @@
 	spaceorb->dev.id.vendor = SERIO_SPACEORB;
 	spaceorb->dev.id.product = 0x0001;
 	spaceorb->dev.id.version = 0x0100;
+	spaceorb->dev.dev = get_device(&serio->dev);
+	sprintf(spaceorb->dev.cdev.class_id,"spaceorb%d", spaceorb_num++);
 
 	serio->private = spaceorb;
 
--- linux-2.6.8/drivers/input/joystick/grip_mp.c.orig	2004-08-14 07:37:42.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/grip_mp.c	2004-09-28 13:59:50.902304832 +0200
@@ -583,6 +583,7 @@
 	grip->dev[slot].id.product = 0x0100 + grip->mode[slot];
 	grip->dev[slot].id.version = 0x0100;
 	grip->dev[slot].evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+	sprintf(grip->dev[slot].cdev.class_id,"grip-mp%d",slot);
 
 	for (j = 0; (t = grip_abs[grip->mode[slot]][j]) >= 0; j++) {
 		set_bit(t, grip->dev[slot].absbit);
--- linux-2.6.8/drivers/input/joystick/gf2k.c.orig	2004-08-14 07:37:26.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/gf2k.c	2004-09-28 14:07:19.177156696 +0200
@@ -90,6 +90,8 @@
 	char phys[32];
 };
 
+static int gf2k_num;
+
 /*
  * gf2k_read_packet() reads a Genius Flight2000 packet.
  */
@@ -303,6 +305,7 @@
 	gf2k->dev.id.vendor = GAMEPORT_ID_VENDOR_GENIUS;
 	gf2k->dev.id.product = gf2k->id;
 	gf2k->dev.id.version = 0x0100;
+	sprintf(gf2k->dev.cdev.class_id,"gf2k-%d",gf2k_num++);
 
 	for (i = 0; i < gf2k_axes[gf2k->id]; i++)
 		set_bit(gf2k_abs[i], gf2k->dev.absbit);
--- linux-2.6.8/drivers/input/joystick/a3d.c.orig	2004-08-14 07:36:11.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/a3d.c	2004-09-28 14:13:10.889688264 +0200
@@ -69,6 +69,8 @@
 	char adcphys[32];
 };
 
+static int a3d_num;
+
 /*
  * a3d_read_packet() reads an Assassin 3D packet.
  */
@@ -365,6 +367,7 @@
 	a3d->dev.id.vendor = GAMEPORT_ID_VENDOR_MADCATZ;
 	a3d->dev.id.product = a3d->mode;
 	a3d->dev.id.version = 0x0100;
+	sprintf(a3d->dev.cdev.class_id,"a3d-%d",a3d_num++);
 
 	input_register_device(&a3d->dev);
 	printk(KERN_INFO "input: %s on %s\n", a3d_names[a3d->mode], a3d->phys);
--- linux-2.6.8/drivers/input/joystick/tmdc.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/tmdc.c	2004-09-28 14:00:43.012382896 +0200
@@ -318,6 +318,7 @@
 			tmdc->dev[j].id.vendor = GAMEPORT_ID_VENDOR_THRUSTMASTER;
 			tmdc->dev[j].id.product = models[m].id;
 			tmdc->dev[j].id.version = 0x0100;
+			sprintf(tmdc->dev[j].cdev.class_id,"tmcd%d",j);
 
 			tmdc->dev[j].evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 
--- linux-2.6.8/drivers/input/joystick/adi.c.orig	2004-08-14 07:36:45.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/adi.c	2004-09-28 14:12:01.274271416 +0200
@@ -134,6 +134,8 @@
 	int used;
 };
 
+static int adi_num;
+
 /*
  * adi_read_packet() reads a Logitech ADI packet.
  */
@@ -424,6 +426,7 @@
 	adi->dev.id.vendor = GAMEPORT_ID_VENDOR_LOGITECH;
 	adi->dev.id.product = adi->id;
 	adi->dev.id.version = 0x0100;
+	sprintf(adi->dev.cdev.class_id,"adi%d",adi_num++);
 
 	adi->dev.private = port;
 	adi->dev.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
--- linux-2.6.8/drivers/input/joystick/gamecon.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/gamecon.c	2004-09-28 13:49:26.406242664 +0200
@@ -646,6 +646,7 @@
                 gc->dev[i].id.vendor = 0x0001;
                 gc->dev[i].id.product = config[i + 1];
                 gc->dev[i].id.version = 0x0100;
+		sprintf(gc->dev[i].cdev.class_id, "gamecon%d",i);
 	}
 
 	parport_release(gc->pd);
--- linux-2.6.8/drivers/input/joystick/iforce/iforce-main.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/iforce/iforce-main.c	2004-09-28 14:05:35.949849632 +0200
@@ -81,7 +81,7 @@
 	{ 0x0000, 0x0000, "Unknown I-Force Device [%04x:%04x]",		btn_joystick, abs_joystick, ff_iforce }
 };
 
-
+static int iforce_num;
 
 static int iforce_input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)
 {
@@ -506,7 +506,7 @@
 /*
  * Register input device.
  */
-
+	sprintf(iforce->dev.cdev.class_id,"iforce%d",iforce_num++);
 	input_register_device(&iforce->dev);
 
 	printk(KERN_DEBUG "iforce->dev.open = %p\n", iforce->dev.open);
--- linux-2.6.8/drivers/input/joystick/twidjoy.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/twidjoy.c	2004-09-28 14:14:39.236257544 +0200
@@ -99,6 +99,8 @@
 	char phys[32];
 };
 
+static int twidjoy_num;
+
 /*
  * twidjoy_process_packet() decodes packets the driver receives from the
  * Twiddler. It updates the data accordingly.
@@ -177,6 +179,7 @@
 {
 	struct twidjoy *twidjoy = serio->private;
 	input_unregister_device(&twidjoy->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(twidjoy);
 }
@@ -237,6 +240,9 @@
 		return;
 	}
 
+	twidjoy->dev.dev = get_device(&serio->dev);
+	sprintf(twidjoy->dev.cdev.class_id,"twidjoy%d", twidjoy_num++);
+
 	input_register_device(&twidjoy->dev);
 
 	printk(KERN_INFO "input: %s on %s\n", twidjoy_name, serio->phys);
--- linux-2.6.8/drivers/input/joystick/turbografx.c.orig	2004-08-14 07:37:37.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/turbografx.c	2004-09-28 14:09:05.013067192 +0200
@@ -205,6 +205,7 @@
 			tgfx->dev[i].id.vendor = 0x0003;
 			tgfx->dev[i].id.product = config[i+1];
 			tgfx->dev[i].id.version = 0x0100;
+			sprintf(tgfx->dev[i].cdev.class_id,"turbografx%d",i);
 
 			tgfx->dev[i].evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 			tgfx->dev[i].absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
--- linux-2.6.8/drivers/input/joystick/interact.c.orig	2004-08-14 07:37:15.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/interact.c	2004-09-28 13:46:53.604472064 +0200
@@ -63,6 +63,8 @@
 	char phys[32];
 };
 
+static int interact_num;
+
 static short interact_abs_hhfx[] =
 	{ ABS_RX, ABS_RY, ABS_X, ABS_Y, ABS_HAT0X, ABS_HAT0Y, -1 };
 static short interact_abs_pp8d[] =
@@ -277,6 +279,7 @@
 	for (i = 0; (t = interact_type[interact->type].btn[i]) >= 0; i++)
 		set_bit(t, interact->dev.keybit);
 
+	sprintf(interact->dev.cdev.class_id,"interact%d",interact_num++);
 	input_register_device(&interact->dev);
 	printk(KERN_INFO "input: %s on %s\n",
 		interact_type[interact->type].name, gameport->phys);
--- linux-2.6.8/drivers/input/joystick/analog.c.orig	2004-08-14 07:37:41.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/analog.c	2004-09-28 13:48:04.372713656 +0200
@@ -136,6 +136,8 @@
 	int axtime;
 };
 
+static int analog_num;
+
 /*
  * Time macros.
  */
@@ -445,6 +447,7 @@
 	analog->dev.id.vendor = GAMEPORT_ID_VENDOR_ANALOG;
 	analog->dev.id.product = analog->mask >> 4;
 	analog->dev.id.version = 0x0100;
+	sprintf(analog->dev.cdev.class_id,"analog%d", analog_num++);
 
 	analog->dev.open = analog_open;
 	analog->dev.close = analog_close;
--- linux-2.6.8/drivers/input/joystick/warrior.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/warrior.c	2004-09-28 14:15:59.405070032 +0200
@@ -60,6 +60,8 @@
 	char phys[32];
 };
 
+static int warrior_num;
+
 /*
  * warrior_process_packet() decodes packets the driver receives from the
  * Warrior. It updates the data accordingly.
@@ -131,6 +133,7 @@
 {
 	struct warrior* warrior = serio->private;
 	input_unregister_device(&warrior->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(warrior);
 }
@@ -192,6 +195,8 @@
 		return;
 	}
 
+	warrior->dev.dev = get_device(&serio->dev);
+	sprintf(warrior->dev.cdev.class_id, "warrior%d", warrior_num++);
 	input_register_device(&warrior->dev);
 
 	printk(KERN_INFO "input: Logitech WingMan Warrior on %s\n", serio->phys);
--- linux-2.6.8/drivers/input/joystick/spaceball.c.orig	2004-09-24 09:06:22.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/spaceball.c	2004-09-28 13:57:34.462046904 +0200
@@ -78,6 +78,8 @@
 	char phys[32];
 };
 
+static int spaceball_num;
+
 /*
  * spaceball_process_packet() decodes packets the driver receives from the
  * SpaceBall.
@@ -193,6 +195,7 @@
 {
 	struct spaceball* spaceball = serio->private;
 	input_unregister_device(&spaceball->dev);
+	put_device(&serio->dev);
 	serio_close(serio);
 	kfree(spaceball);
 }
@@ -253,6 +256,8 @@
 	spaceball->dev.id.vendor = SERIO_SPACEBALL;
 	spaceball->dev.id.product = id;
 	spaceball->dev.id.version = 0x0100;
+	spaceball->dev.dev = get_device(&serio->dev);
+	sprintf(spaceball->dev.cdev.class_id,"spaceball%d",spaceball_num++);
 
 	serio->private = spaceball;
 
--- linux-2.6.8/drivers/input/joystick/amijoy.c.orig	2004-08-14 07:37:25.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/amijoy.c	2004-09-28 13:50:31.518344120 +0200
@@ -138,6 +138,7 @@
 			amijoy_dev[i].id.vendor = 0x0001;
 			amijoy_dev[i].id.product = 0x0003;
 			amijoy_dev[i].id.version = 0x0100;
+			sprintf(amijoy[i].cdev.class_id,"amijoy%d",i);
 
 			amijoy_dev[i].private = amijoy_used + i;
 
--- linux-2.6.8/drivers/input/joystick/guillemot.c.orig	2004-08-14 07:36:44.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/guillemot.c	2004-09-28 14:08:14.879688624 +0200
@@ -76,6 +76,8 @@
 	char phys[32];
 };
 
+static int guillemot_num;
+
 static struct guillemot_type guillemot_type[] = {
 	{ 0x00, guillemot_abs_pad, guillemot_btn_pad, 1, "Guillemot Pad" },
 	{ 0 }};
@@ -228,6 +230,7 @@
 	guillemot->dev.id.vendor = GAMEPORT_ID_VENDOR_GUILLEMOT;
 	guillemot->dev.id.product = guillemot_type[i].id;
 	guillemot->dev.id.version = (int)data[14] << 8 | data[15];
+	sprintf(guillemot->dev.cdev.class_id,"guillemot%d",guillemot_num++);
 
 	guillemot->dev.evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 
--- linux-2.6.8/drivers/input/joystick/cobra.c.orig	2004-08-14 07:36:58.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/cobra.c	2004-09-28 14:16:42.715485848 +0200
@@ -205,6 +205,7 @@
 			cobra->dev[i].id.vendor = GAMEPORT_ID_VENDOR_CREATIVE;
 			cobra->dev[i].id.product = 0x0008;
 			cobra->dev[i].id.version = 0x0100;
+			sprintf(cobra->dev[i].cdev.class_id,"cobra%d", i);
 
 			cobra->dev[i].evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 			cobra->dev[i].absbit[0] = BIT(ABS_X) | BIT(ABS_Y);
--- linux-2.6.8/drivers/input/joystick/grip.c.orig	2004-08-14 07:36:45.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/grip.c	2004-09-28 14:06:16.194731480 +0200
@@ -356,6 +356,7 @@
 			grip->dev[i].id.vendor = GAMEPORT_ID_VENDOR_GRAVIS;
 			grip->dev[i].id.product = grip->mode[i];
 			grip->dev[i].id.version = 0x0100;
+			sprintf(grip->dev[i].cdev.class_id,"grip%d",i);
 
 			grip->dev[i].evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 
--- linux-2.6.8/drivers/input/joystick/sidewinder.c.orig	2004-08-14 07:37:40.000000000 +0200
+++ linux-2.6.8/drivers/input/joystick/sidewinder.c	2004-09-28 14:38:23.992661648 +0200
@@ -721,6 +721,7 @@
 		sw->dev[i].id.vendor = GAMEPORT_ID_VENDOR_MICROSOFT;
 		sw->dev[i].id.product = sw->type;
 		sw->dev[i].id.version = 0x0100;
+		sprintf(sw->dev[i].cdev.class_id,"sidewinder%d", i );
 
 		sw->dev[i].evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
 
--- linux-2.6.8/drivers/media/dvb/ttpci/budget-ci.c.orig	2004-09-24 09:06:23.000000000 +0200
+++ linux-2.6.8/drivers/media/dvb/ttpci/budget-ci.c	2004-09-28 13:41:43.640593736 +0200
@@ -70,6 +70,8 @@
 	char ir_dev_name[50];
 };
 
+static int budget_ci_num;
+
 static u32 budget_debiread (struct budget_ci* budget_ci, u32 config, int addr, int count)
 {
 	struct saa7146_dev *saa = budget_ci->budget.dev;
@@ -255,6 +257,8 @@
 		if (key_map[i])
 			set_bit(key_map[i], budget_ci->input_dev.keybit);
 
+	sprintf(&budget_ci->input_dev.cdev.class_id,"budget%d",
+		budget_ci_num++);
 	input_register_device(&budget_ci->input_dev);
 
 	budget_ci->input_dev.timer.function = msp430_ir_debounce;
--- linux-2.6.8/drivers/media/dvb/ttpci/av7110_ir.c.orig	2004-09-24 09:06:23.000000000 +0200
+++ linux-2.6.8/drivers/media/dvb/ttpci/av7110_ir.c	2004-09-28 13:43:19.987946712 +0200
@@ -171,6 +171,7 @@
 	keyup_timer.data = 0;
 
 	input_dev.name = "DVB on-card IR receiver";
+	sprintf(input_dev.cdev.class_id,"av7110_ir");
 
 	/**
 	 *  enable keys
--- linux-2.6.8/drivers/media/video/saa7134/saa7134-input.c.orig	2004-08-14 07:37:38.000000000 +0200
+++ linux-2.6.8/drivers/media/video/saa7134/saa7134-input.c	2004-09-28 13:38:41.012357448 +0200
@@ -332,6 +332,8 @@
 	ir->dev.phys = ir->phys;
 	ir->dev.id.bustype = BUS_PCI;
 	ir->dev.id.version = 1;
+	sprintf(ir->dev.cdev.class_id,"irkbd-saa7134-%s",
+		pci_name(dev->pci));
 	if (dev->pci->subsystem_vendor) {
 		ir->dev.id.vendor  = dev->pci->subsystem_vendor;
 		ir->dev.id.product = dev->pci->subsystem_device;
--- linux-2.6.8/drivers/media/video/ir-kbd-i2c.c.orig	2004-08-14 07:36:10.000000000 +0200
+++ linux-2.6.8/drivers/media/video/ir-kbd-i2c.c	2004-09-28 14:41:44.591166040 +0200
@@ -397,6 +397,7 @@
 	ir->input.id.bustype = BUS_I2C;
 	ir->input.name       = ir->c.name;
 	ir->input.phys       = ir->phys;
+	sprintf(ir->input.cdev.class_id, "irkbd-i2c-%02x", addr);
 	input_register_device(&ir->input);
 	printk(DEVNAME ": %s detected at %s [%s]\n",
 	       ir->input.name,ir->input.phys,adap->name);
--- linux-2.6.8/drivers/media/video/ir-kbd-gpio.c.orig	2004-08-14 07:37:38.000000000 +0200
+++ linux-2.6.8/drivers/media/video/ir-kbd-gpio.c	2004-09-28 14:42:10.986153392 +0200
@@ -329,6 +329,8 @@
 	ir->input.phys = ir->phys;
 	ir->input.id.bustype = BUS_PCI;
 	ir->input.id.version = 1;
+	ir->input.dev = dev;
+	sprintf(ir->input.cdev.class_id,"irkbd-gpio-%s", pci_name(sub->core->pci)); 
 	if (sub->core->pci->subsystem_vendor) {
 		ir->input.id.vendor  = sub->core->pci->subsystem_vendor;
 		ir->input.id.product = sub->core->pci->subsystem_device;
