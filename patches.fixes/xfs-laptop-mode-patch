# Date: Wed, 12 May 2004 17:13:28 +1000 (EST)
# From: Nathan Scott <nathans@snort.melbourne.sgi.com>
# Subject: TAKE 912975 - laptop mode patch
# 
# Merge final laptop mode patch (xfssyncd) from Bart Samwel.
# 
# Date:  Wed May 12 00:13:01 PDT 2004
# Workarea:  snort.melbourne.sgi.com:/home/nathans/ultra-clean-xfs-linux
# Inspected by:  hch@lst.de
# 
# The following file(s) were checked into:
#   bonnie.engr.sgi.com:/isms/xfs-kern/xfs-linux

Index: linux-2.6.5/fs/xfs/linux/xfs_super.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/linux/xfs_super.c
+++ linux-2.6.5/fs/xfs/linux/xfs_super.c
@@ -71,6 +71,7 @@
 #include <linux/init.h>
 #include <linux/mount.h>
 #include <linux/suspend.h>
+#include <linux/writeback.h>
 
 STATIC struct quotactl_ops linvfs_qops;
 STATIC struct super_operations linvfs_sops;
@@ -413,6 +414,10 @@ xfssyncd(
 		if (vfsp->vfs_flag & VFS_RDONLY)
 			continue;
 		VFS_SYNC(vfsp, SYNCD_FLAGS, NULL, error);
+
+		vfsp->vfs_sync_seq++;
+		wmb();
+		wake_up(&vfsp->vfs_wait_single_sync_task);
 	}
 
 	vfsp->vfs_sync_task = NULL;
@@ -498,6 +503,24 @@ linvfs_sync_super(
 	VFS_SYNC(vfsp, flags, NULL, error);
 	sb->s_dirt = 0;
 
+	if (unlikely(laptop_mode)) {
+		int	prev_sync_seq = vfsp->vfs_sync_seq;
+		/*
+		 * The disk must be active because we're syncing.
+		 * We schedule syncd now (now that the disk is
+		 * active) instead of later (when it might not be).
+		 */
+		wake_up_process(vfsp->vfs_sync_task);
+		/*
+		 * We have to wait for the sync iteration to complete.
+		 * If we don't, the disk activity caused by the sync
+		 * will come after the sync is completed, and that
+		 * triggers another sync from laptop mode.
+		 */
+		wait_event(vfsp->vfs_wait_single_sync_task,
+				vfsp->vfs_sync_seq != prev_sync_seq);
+	}
+
 	return -error;
 }
 
Index: linux-2.6.5/fs/xfs/linux/xfs_vfs.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/linux/xfs_vfs.c
+++ linux-2.6.5/fs/xfs/linux/xfs_vfs.c
@@ -251,6 +251,7 @@ vfs_allocate( void )
 	vfsp = kmem_zalloc(sizeof(vfs_t), KM_SLEEP);
 	bhv_head_init(VFS_BHVHEAD(vfsp), "vfs");
 	init_waitqueue_head(&vfsp->vfs_wait_sync_task);
+	init_waitqueue_head(&vfsp->vfs_wait_single_sync_task);
 	return vfsp;
 }
 
Index: linux-2.6.5/fs/xfs/linux/xfs_vfs.h
===================================================================
--- linux-2.6.5.orig/fs/xfs/linux/xfs_vfs.h
+++ linux-2.6.5/fs/xfs/linux/xfs_vfs.h
@@ -51,7 +51,9 @@ typedef struct vfs {
 	xfs_fsid_t		*vfs_altfsid;	/* An ID fixed for life of FS */
 	bhv_head_t		vfs_bh;		/* head of vfs behavior chain */
 	struct super_block	*vfs_super;	/* Linux superblock structure */
-	struct task_struct	*vfs_sync_task;
+	struct task_struct	*vfs_sync_task;	/* xfssyncd process */
+	int 			vfs_sync_seq;	/* xfssyncd generation number */
+	wait_queue_head_t	vfs_wait_single_sync_task;
 	wait_queue_head_t	vfs_wait_sync_task;
 } vfs_t;
 
