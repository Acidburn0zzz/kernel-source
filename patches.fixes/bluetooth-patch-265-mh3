diff -urN linux-2.6.5/arch/sparc64/kernel/ioctl32.c linux-2.6.5-mh3/arch/sparc64/kernel/ioctl32.c
--- linux-2.6.5/arch/sparc64/kernel/ioctl32.c	2004-04-04 05:38:14.000000000 +0200
+++ linux-2.6.5-mh3/arch/sparc64/kernel/ioctl32.c	2004-04-10 12:09:49.000000000 +0200
@@ -1106,17 +1106,6 @@
 COMPATIBLE_IOCTL(WIOCSTART)
 COMPATIBLE_IOCTL(WIOCSTOP)
 COMPATIBLE_IOCTL(WIOCGSTAT)
-COMPATIBLE_IOCTL(HCIUARTSETPROTO)
-COMPATIBLE_IOCTL(HCIUARTGETPROTO)
-COMPATIBLE_IOCTL(RFCOMMCREATEDEV)
-COMPATIBLE_IOCTL(RFCOMMRELEASEDEV)
-COMPATIBLE_IOCTL(RFCOMMGETDEVLIST)
-COMPATIBLE_IOCTL(RFCOMMGETDEVINFO)
-COMPATIBLE_IOCTL(RFCOMMSTEALDLC)
-COMPATIBLE_IOCTL(BNEPCONNADD)
-COMPATIBLE_IOCTL(BNEPCONNDEL)
-COMPATIBLE_IOCTL(BNEPGETCONNLIST)
-COMPATIBLE_IOCTL(BNEPGETCONNINFO)
 /* And these ioctls need translation */
 /* NCPFS */
 HANDLE_IOCTL(NCP_IOC_NCPREQUEST_32, do_ncp_ncprequest)
diff -urN linux-2.6.5/arch/x86_64/ia32/ia32_ioctl.c linux-2.6.5-mh3/arch/x86_64/ia32/ia32_ioctl.c
--- linux-2.6.5/arch/x86_64/ia32/ia32_ioctl.c	2004-04-04 05:37:07.000000000 +0200
+++ linux-2.6.5-mh3/arch/x86_64/ia32/ia32_ioctl.c	2004-04-10 12:09:49.000000000 +0200
@@ -188,17 +188,6 @@
 COMPATIBLE_IOCTL(RTC_SET_TIME)
 COMPATIBLE_IOCTL(RTC_WKALM_SET)
 COMPATIBLE_IOCTL(RTC_WKALM_RD)
-COMPATIBLE_IOCTL(HCIUARTSETPROTO)
-COMPATIBLE_IOCTL(HCIUARTGETPROTO)
-COMPATIBLE_IOCTL(RFCOMMCREATEDEV)
-COMPATIBLE_IOCTL(RFCOMMRELEASEDEV)
-COMPATIBLE_IOCTL(RFCOMMGETDEVLIST)
-COMPATIBLE_IOCTL(RFCOMMGETDEVINFO)
-COMPATIBLE_IOCTL(RFCOMMSTEALDLC)
-COMPATIBLE_IOCTL(BNEPCONNADD)
-COMPATIBLE_IOCTL(BNEPCONNDEL)
-COMPATIBLE_IOCTL(BNEPGETCONNLIST)
-COMPATIBLE_IOCTL(BNEPGETCONNINFO)
 COMPATIBLE_IOCTL(FIOQSIZE)
 
 /* And these ioctls need translation */
diff -urN linux-2.6.5/drivers/bluetooth/bcm203x.c linux-2.6.5-mh3/drivers/bluetooth/bcm203x.c
--- linux-2.6.5/drivers/bluetooth/bcm203x.c	2004-04-04 05:36:15.000000000 +0200
+++ linux-2.6.5-mh3/drivers/bluetooth/bcm203x.c	2004-04-10 12:09:49.000000000 +0200
@@ -74,7 +74,7 @@
 	struct timer_list	timer;
 
 	struct urb		*urb;
-	unsigned char		buffer[4096];
+	unsigned char		*buffer;
 
 	unsigned char		*fw_data;
 	unsigned int		fw_size;
@@ -99,8 +99,7 @@
 	case BCM203X_LOAD_MINIDRV:
 		memcpy(data->buffer, "#", 1);
 
-		usb_fill_bulk_urb(urb, udev,
-				usb_sndbulkpipe(udev, BCM203X_OUT_EP),
+		usb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, BCM203X_OUT_EP),
 				data->buffer, 1, bcm203x_complete, data);
 
 		data->state = BCM203X_SELECT_MEMORY;
@@ -109,8 +108,7 @@
 		break;
 
 	case BCM203X_SELECT_MEMORY:
-		usb_fill_int_urb(urb, udev,
-				usb_rcvintpipe(udev, BCM203X_IN_EP),
+		usb_fill_int_urb(urb, udev, usb_rcvintpipe(udev, BCM203X_IN_EP),
 				data->buffer, 32, bcm203x_complete, data, 1);
 
 		data->state = BCM203X_CHECK_MEMORY;
@@ -130,20 +128,15 @@
 
 	case BCM203X_LOAD_FIRMWARE:
 		if (data->fw_sent == data->fw_size) {
-			usb_fill_int_urb(urb, udev,
-					usb_rcvintpipe(udev, BCM203X_IN_EP),
-					data->buffer, 32,
-					bcm203x_complete, data, 1);
+			usb_fill_int_urb(urb, udev, usb_rcvintpipe(udev, BCM203X_IN_EP),
+				data->buffer, 32, bcm203x_complete, data, 1);
 
 			data->state = BCM203X_CHECK_FIRMWARE;
 		} else {
-			len = min_t(uint, data->fw_size - data->fw_sent,
-							sizeof(data->buffer));
+			len = min_t(uint, data->fw_size - data->fw_sent, 4096);
 
-			usb_fill_bulk_urb(urb, udev,
-					usb_sndbulkpipe(udev, BCM203X_OUT_EP),
-					data->fw_data + data->fw_sent, len,
-					bcm203x_complete, data);
+			usb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, BCM203X_OUT_EP),
+				data->fw_data + data->fw_sent, len, bcm203x_complete, data);
 
 			data->fw_sent += len;
 		}
@@ -177,6 +170,7 @@
 	const struct firmware *firmware;
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct bcm203x_data *data;
+	int size;
 
 	BT_DBG("intf %p id %p", intf, id);
 
@@ -210,18 +204,20 @@
 
 	BT_DBG("minidrv data %p size %d", firmware->data, firmware->size);
 
-	if (firmware->size > sizeof(data->buffer)) {
-		BT_ERR("Mini driver exceeds size of buffer");
+	size = max_t(uint, firmware->size, 4096);
+
+	data->buffer = kmalloc(size, GFP_KERNEL);
+	if (!data->buffer) {
+		BT_ERR("Can't allocate memory for mini driver");
 		release_firmware(firmware);
 		usb_free_urb(data->urb);
 		kfree(data);
-		return -EIO;
+		return -ENOMEM;
 	}
 
 	memcpy(data->buffer, firmware->data, firmware->size);
 
-	usb_fill_bulk_urb(data->urb, udev,
-			usb_sndbulkpipe(udev, BCM203X_OUT_EP),
+	usb_fill_bulk_urb(data->urb, udev, usb_sndbulkpipe(udev, BCM203X_OUT_EP),
 			data->buffer, firmware->size, bcm203x_complete, data);
 
 	release_firmware(firmware);
@@ -229,6 +225,7 @@
 	if (request_firmware(&firmware, "BCM2033-FW.bin", &udev->dev) < 0) {
 		BT_ERR("Firmware request failed");
 		usb_free_urb(data->urb);
+		kfree(data->buffer);
 		kfree(data);
 		return -EIO;
 	}
@@ -239,6 +236,7 @@
 	if (!data->fw_data) {
 		BT_ERR("Can't allocate memory for firmware image");
 		usb_free_urb(data->urb);
+		kfree(data->buffer);
 		kfree(data);
 		return -ENOMEM;
 	}
@@ -272,6 +270,7 @@
 
 	usb_free_urb(data->urb);
 	kfree(data->fw_data);
+	kfree(data->buffer);
 	kfree(data);
 }
 
diff -urN linux-2.6.5/drivers/bluetooth/bfusb.c linux-2.6.5-mh3/drivers/bluetooth/bfusb.c
--- linux-2.6.5/drivers/bluetooth/bfusb.c	2004-04-04 05:37:37.000000000 +0200
+++ linux-2.6.5-mh3/drivers/bluetooth/bfusb.c	2004-04-10 12:09:49.000000000 +0200
@@ -98,6 +98,14 @@
 static void bfusb_tx_complete(struct urb *urb, struct pt_regs *regs);
 static void bfusb_rx_complete(struct urb *urb, struct pt_regs *regs);
 
+static inline void bfusb_wait_for_urb(struct urb *urb)
+{
+	while (atomic_read(&urb->count) > 1) {
+		current->state = TASK_UNINTERRUPTIBLE;
+		schedule_timeout((5 * HZ + 999) / 1000);
+	}
+}
+
 static struct urb *bfusb_get_completed(struct bfusb *bfusb)
 {
 	struct sk_buff *skb;
@@ -114,7 +122,7 @@
 	return urb;
 }
 
-static inline void bfusb_unlink_urbs(struct bfusb *bfusb)
+static void bfusb_unlink_urbs(struct bfusb *bfusb)
 {
 	struct sk_buff *skb;
 	struct urb *urb;
@@ -124,6 +132,7 @@
 	while ((skb = skb_dequeue(&bfusb->pending_q))) {
 		urb = ((struct bfusb_scb *) skb->cb)->urb;
 		usb_unlink_urb(urb);
+		bfusb_wait_for_urb(urb);
 		skb_queue_tail(&bfusb->completed_q, skb);
 	}
 
@@ -359,11 +368,11 @@
 
 	BT_DBG("bfusb %p urb %p skb %p len %d", bfusb, urb, skb, skb->len);
 
-	if (!test_bit(HCI_RUNNING, &bfusb->hdev->flags))
-		return;
-
 	read_lock(&bfusb->lock);
 
+	if (!test_bit(HCI_RUNNING, &bfusb->hdev->flags))
+		goto unlock;
+
 	if (urb->status || !count)
 		goto resubmit;
 
@@ -414,6 +423,7 @@
 					bfusb->hdev->name, urb, err);
 	}
 
+unlock:
 	read_unlock(&bfusb->lock);
 }
 
diff -urN linux-2.6.5/drivers/bluetooth/bluecard_cs.c linux-2.6.5-mh3/drivers/bluetooth/bluecard_cs.c
--- linux-2.6.5/drivers/bluetooth/bluecard_cs.c	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5-mh3/drivers/bluetooth/bluecard_cs.c	2004-04-10 12:09:49.000000000 +0200
@@ -174,6 +174,9 @@
 	bluecard_info_t *info = (bluecard_info_t *)arg;
 	unsigned int iobase = info->link.io.BasePort1;
 
+	if (!test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state)))
+		return;
+
 	if (test_bit(CARD_HAS_ACTIVITY_LED, &(info->hw_state))) {
 		/* Disable activity LED */
 		outb(0x08 | 0x20, iobase + 0x30);
@@ -188,6 +191,9 @@
 {
 	unsigned int iobase = info->link.io.BasePort1;
 
+	if (!test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state)))
+		return;
+
 	if (test_bit(CARD_HAS_ACTIVITY_LED, &(info->hw_state))) {
 		/* Enable activity LED */
 		outb(0x10 | 0x40, iobase + 0x30);
@@ -505,13 +511,13 @@
 	unsigned int iobase;
 	unsigned char reg;
 
-	if (!info) {
+	if (!info || !info->hdev) {
 		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
 
 	if (!test_bit(CARD_READY, &(info->hw_state)))
-		return IRQ_NONE;
+		return IRQ_HANDLED;
 
 	iobase = info->link.io.BasePort1;
 
@@ -629,13 +635,16 @@
 	bluecard_info_t *info = (bluecard_info_t *)(hdev->driver_data);
 	unsigned int iobase = info->link.io.BasePort1;
 
-	bluecard_hci_set_baud_rate(hdev, DEFAULT_BAUD_RATE);
+	if (test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state)))
+		bluecard_hci_set_baud_rate(hdev, DEFAULT_BAUD_RATE);
 
 	if (test_and_set_bit(HCI_RUNNING, &(hdev->flags)))
 		return 0;
 
-	/* Enable LED */
-	outb(0x08 | 0x20, iobase + 0x30);
+	if (test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state))) {
+		/* Enable LED */
+		outb(0x08 | 0x20, iobase + 0x30);
+	}
 
 	return 0;
 }
@@ -651,8 +660,10 @@
 
 	bluecard_hci_flush(hdev);
 
-	/* Disable LED */
-	outb(0x00, iobase + 0x30);
+	if (test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state))) {
+		/* Disable LED */
+		outb(0x00, iobase + 0x30);
+	}
 
 	return 0;
 }
@@ -725,6 +736,27 @@
 	info->rx_count = 0;
 	info->rx_skb = NULL;
 
+	/* Initialize HCI device */
+	hdev = hci_alloc_dev();
+	if (!hdev) {
+		BT_ERR("Can't allocate HCI device");
+		return -ENOMEM;
+	}
+
+	info->hdev = hdev;
+
+	hdev->type = HCI_PCCARD;
+	hdev->driver_data = info;
+
+	hdev->open     = bluecard_hci_open;
+	hdev->close    = bluecard_hci_close;
+	hdev->flush    = bluecard_hci_flush;
+	hdev->send     = bluecard_hci_send_frame;
+	hdev->destruct = bluecard_hci_destruct;
+	hdev->ioctl    = bluecard_hci_ioctl;
+
+	hdev->owner = THIS_MODULE;
+
 	id = inb(iobase + 0x30);
 
 	if ((id & 0x0f) == 0x02)
@@ -759,6 +791,24 @@
 	info->ctrl_reg |= REG_CONTROL_INTERRUPT;
 	outb(info->ctrl_reg, iobase + REG_CONTROL);
 
+	if ((id & 0x0f) == 0x03) {
+		/* Disable RTS */
+		info->ctrl_reg |= REG_CONTROL_RTS;
+		outb(info->ctrl_reg, iobase + REG_CONTROL);
+
+		/* Set baud rate */
+		info->ctrl_reg |= 0x03;
+		outb(info->ctrl_reg, iobase + REG_CONTROL);
+
+		/* Enable RTS */
+		info->ctrl_reg &= ~REG_CONTROL_RTS;
+		outb(info->ctrl_reg, iobase + REG_CONTROL);
+
+		set_bit(XMIT_BUF_ONE_READY, &(info->tx_state));
+		set_bit(XMIT_BUF_TWO_READY, &(info->tx_state));
+		set_bit(XMIT_SENDING_READY, &(info->tx_state));
+	}
+
 	/* Start the RX buffers */
 	outb(REG_COMMAND_RX_BUF_ONE, iobase + REG_COMMAND);
 	outb(REG_COMMAND_RX_BUF_TWO, iobase + REG_COMMAND);
@@ -776,30 +826,10 @@
 	set_current_state(TASK_INTERRUPTIBLE);
 	schedule_timeout((HZ * 5) / 4);		// or set it to 3/2
 
-
-	/* Initialize and register HCI device */
-	hdev = hci_alloc_dev();
-	if (!hdev) {
-		BT_ERR("Can't allocate HCI device");
-		return -ENOMEM;
-	}
-
-	info->hdev = hdev;
-
-	hdev->type = HCI_PCCARD;
-	hdev->driver_data = info;
-
-	hdev->open = bluecard_hci_open;
-	hdev->close = bluecard_hci_close;
-	hdev->flush = bluecard_hci_flush;
-	hdev->send = bluecard_hci_send_frame;
-	hdev->destruct = bluecard_hci_destruct;
-	hdev->ioctl = bluecard_hci_ioctl;
-
-	hdev->owner = THIS_MODULE;
-	
+	/* Register HCI device */
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
+		info->hdev = NULL;
 		hci_free_dev(hdev);
 		return -ENODEV;
 	}
@@ -813,6 +843,9 @@
 	unsigned int iobase = info->link.io.BasePort1;
 	struct hci_dev *hdev = info->hdev;
 
+	if (!hdev)
+		return -ENODEV;
+
 	bluecard_hci_close(hdev);
 
 	clear_bit(CARD_READY, &(info->hw_state));
@@ -1017,6 +1050,8 @@
 	if (link->state & DEV_PRESENT)
 		bluecard_close(info);
 
+	del_timer(&(info->timer));
+
 	link->dev = NULL;
 
 	pcmcia_release_configuration(link->handle);
diff -urN linux-2.6.5/drivers/bluetooth/bt3c_cs.c linux-2.6.5-mh3/drivers/bluetooth/bt3c_cs.c
--- linux-2.6.5/drivers/bluetooth/bt3c_cs.c	2004-04-04 05:38:23.000000000 +0200
+++ linux-2.6.5-mh3/drivers/bluetooth/bt3c_cs.c	2004-04-10 12:09:49.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/kmod.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/delay.h>
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <linux/errno.h>
@@ -43,6 +44,9 @@
 #include <asm/bitops.h>
 #include <asm/io.h>
 
+#include <linux/device.h>
+#include <linux/firmware.h>
+
 #include <pcmcia/version.h>
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
@@ -361,7 +365,7 @@
 	unsigned int iobase;
 	int iir;
 
-	if (!info) {
+	if (!info || !info->hdev) {
 		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
@@ -379,7 +383,8 @@
 		} else if ((stat & 0xff) != 0xff) {
 			if (stat & 0x0020) {
 				int stat = bt3c_read(iobase, 0x7002) & 0x10;
-				BT_ERR("Antenna %s", stat ? "out" : "in");
+				BT_INFO("%s: Antenna %s", info->hdev->name,
+							stat ? "out" : "in");
 			}
 			if (stat & 0x0001)
 				bt3c_receive(info);
@@ -481,36 +486,101 @@
 
 
 
-/* ======================== User mode firmware loader ======================== */
+/* ======================== Card services HCI interaction ======================== */
 
 
-#define FW_LOADER  "/sbin/bluefw"
+static struct device bt3c_device = {
+	.bus_id = "pcmcia",
+};
 
 
-static int bt3c_firmware_load(bt3c_info_t *info)
+static int bt3c_load_firmware(bt3c_info_t *info, unsigned char *firmware, int count)
 {
-	char dev[16];
-	int err;
+	char *ptr = (char *) firmware;
+	char b[9];
+	unsigned int iobase, size, addr, fcs, tmp;
+	int i, err = 0;
 
-	char *argv[] = { FW_LOADER, "pccard", dev, NULL };
-	char *envp[] = { "HOME=/", "TERM=linux", "PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL };
+	iobase = info->link.io.BasePort1;
 
-	sprintf(dev, "%04x", info->link.io.BasePort1);
+	/* Reset */
+	bt3c_io_write(iobase, 0x8040, 0x0404);
+	bt3c_io_write(iobase, 0x8040, 0x0400);
+
+	udelay(1);
+
+	bt3c_io_write(iobase, 0x8040, 0x0404);
+
+	udelay(17);
+
+	/* Load */
+	while (count) {
+		if (ptr[0] != 'S') {
+			BT_ERR("Bad address in firmware");
+			err = -EFAULT;
+			goto error;
+		}
 
-	err = call_usermodehelper(FW_LOADER, argv, envp, 1);
-	if (err)
-		BT_ERR("Failed to run \"%s pccard %s\" (errno=%d)", FW_LOADER, dev, err);
+		memset(b, 0, sizeof(b));
+		memcpy(b, ptr + 2, 2);
+		size = simple_strtol(b, NULL, 16);
+
+		memset(b, 0, sizeof(b));
+		memcpy(b, ptr + 4, 8);
+		addr = simple_strtol(b, NULL, 16);
+
+		memset(b, 0, sizeof(b));
+		memcpy(b, ptr + (size * 2) + 2, 2);
+		fcs = simple_strtol(b, NULL, 16);
+
+		memset(b, 0, sizeof(b));
+		for (tmp = 0, i = 0; i < size; i++) {
+			memcpy(b, ptr + (i * 2) + 2, 2);
+			tmp += simple_strtol(b, NULL, 16);
+		}
 
-	return err;
-}
+		if (((tmp + fcs) & 0xff) != 0xff) {
+			BT_ERR("Checksum error in firmware");
+			err = -EILSEQ;
+			goto error;
+		}
 
+		if (ptr[1] == '3') {
+			bt3c_address(iobase, addr);
 
+			memset(b, 0, sizeof(b));
+			for (i = 0; i < (size - 4) / 2; i++) {
+				memcpy(b, ptr + (i * 4) + 12, 4);
+				tmp = simple_strtol(b, NULL, 16);
+				bt3c_put(iobase, tmp);
+			}
+		}
 
-/* ======================== Card services HCI interaction ======================== */
+		ptr   += (size * 2) + 6;
+		count -= (size * 2) + 6;
+	}
+
+	udelay(17);
+
+	/* Boot */
+	bt3c_address(iobase, 0x3000);
+	outb(inb(iobase + CONTROL) | 0x40, iobase + CONTROL);
+
+error:
+	udelay(17);
+
+	/* Clear */
+	bt3c_io_write(iobase, 0x7006, 0x0000);
+	bt3c_io_write(iobase, 0x7005, 0x0000);
+	bt3c_io_write(iobase, 0x7001, 0x0000);
+
+	return err;
+}
 
 
 int bt3c_open(bt3c_info_t *info)
 {
+	const struct firmware *firmware;
 	struct hci_dev *hdev;
 	int err;
 
@@ -522,18 +592,7 @@
 	info->rx_count = 0;
 	info->rx_skb = NULL;
 
-	/* Load firmware */
-
-	if ((err = bt3c_firmware_load(info)) < 0)
-		return err;
-
-	/* Timeout before it is safe to send the first HCI packet */
-
-	set_current_state(TASK_INTERRUPTIBLE);
-	schedule_timeout(HZ);
-
-
-	/* Initialize and register HCI device */
+	/* Initialize HCI device */
 	hdev = hci_alloc_dev();
 	if (!hdev) {
 		BT_ERR("Can't allocate HCI device");
@@ -545,22 +604,48 @@
 	hdev->type = HCI_PCCARD;
 	hdev->driver_data = info;
 
-	hdev->open = bt3c_hci_open;
-	hdev->close = bt3c_hci_close;
-	hdev->flush = bt3c_hci_flush;
-	hdev->send = bt3c_hci_send_frame;
+	hdev->open     = bt3c_hci_open;
+	hdev->close    = bt3c_hci_close;
+	hdev->flush    = bt3c_hci_flush;
+	hdev->send     = bt3c_hci_send_frame;
 	hdev->destruct = bt3c_hci_destruct;
-	hdev->ioctl = bt3c_hci_ioctl;
+	hdev->ioctl    = bt3c_hci_ioctl;
 
 	hdev->owner = THIS_MODULE;
-	
-	if (hci_register_dev(hdev) < 0) {
+
+	/* Load firmware */
+	err = request_firmware(&firmware, "BT3CPCC.bin", &bt3c_device);
+	if (err < 0) {
+		BT_ERR("Firmware request failed");
+		goto error;
+	}
+
+	err = bt3c_load_firmware(info, firmware->data, firmware->size);
+
+	release_firmware(firmware);
+
+	if (err < 0) {
+		BT_ERR("Firmware loading failed");
+		goto error;
+	}
+
+	/* Timeout before it is safe to send the first HCI packet */
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(HZ);
+
+	/* Register HCI device */
+	err = hci_register_dev(hdev);
+	if (err < 0) {
 		BT_ERR("Can't register HCI device");
-		hci_free_dev(hdev);
-		return -ENODEV;
+		goto error;
 	}
 
 	return 0;
+
+error:
+	info->hdev = NULL;
+	hci_free_dev(hdev);
+	return err;
 }
 
 
@@ -568,6 +653,9 @@
 {
 	struct hci_dev *hdev = info->hdev;
 
+	if (!hdev)
+		return -ENODEV;
+
 	bt3c_hci_close(hdev);
 
 	if (hci_unregister_dev(hdev) < 0)
diff -urN linux-2.6.5/drivers/bluetooth/btuart_cs.c linux-2.6.5-mh3/drivers/bluetooth/btuart_cs.c
--- linux-2.6.5/drivers/bluetooth/btuart_cs.c	2004-04-04 05:38:23.000000000 +0200
+++ linux-2.6.5-mh3/drivers/bluetooth/btuart_cs.c	2004-04-10 12:09:49.000000000 +0200
@@ -308,7 +308,7 @@
 	int boguscount = 0;
 	int iir, lsr;
 
-	if (!info) {
+	if (!info || !info->hdev) {
 		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
@@ -504,6 +504,27 @@
 	info->rx_count = 0;
 	info->rx_skb = NULL;
 
+	/* Initialize HCI device */
+	hdev = hci_alloc_dev();
+	if (!hdev) {
+		BT_ERR("Can't allocate HCI device");
+		return -ENOMEM;
+	}
+
+	info->hdev = hdev;
+
+	hdev->type = HCI_PCCARD;
+	hdev->driver_data = info;
+
+	hdev->open     = btuart_hci_open;
+	hdev->close    = btuart_hci_close;
+	hdev->flush    = btuart_hci_flush;
+	hdev->send     = btuart_hci_send_frame;
+	hdev->destruct = btuart_hci_destruct;
+	hdev->ioctl    = btuart_hci_ioctl;
+
+	hdev->owner = THIS_MODULE;
+
 	spin_lock_irqsave(&(info->lock), flags);
 
 	/* Reset UART */
@@ -527,30 +548,10 @@
 	set_current_state(TASK_INTERRUPTIBLE);
 	schedule_timeout(HZ);
 
-
-	/* Initialize and register HCI device */
-	hdev = hci_alloc_dev();
-	if (!hdev) {
-		BT_ERR("Can't allocate HCI device");
-		return -ENOMEM;
-	}
-
-	info->hdev = hdev;
-
-	hdev->type = HCI_PCCARD;
-	hdev->driver_data = info;
-
-	hdev->open = btuart_hci_open;
-	hdev->close = btuart_hci_close;
-	hdev->flush = btuart_hci_flush;
-	hdev->send = btuart_hci_send_frame;
-	hdev->destruct = btuart_hci_destruct;
-	hdev->ioctl = btuart_hci_ioctl;
-
-	hdev->owner = THIS_MODULE;
-	
+	/* Register HCI device */
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
+		info->hdev = NULL;
 		hci_free_dev(hdev);
 		return -ENODEV;
 	}
@@ -565,6 +566,9 @@
 	unsigned int iobase = info->link.io.BasePort1;
 	struct hci_dev *hdev = info->hdev;
 
+	if (!hdev)
+		return -ENODEV;
+
 	btuart_hci_close(hdev);
 
 	spin_lock_irqsave(&(info->lock), flags);
diff -urN linux-2.6.5/drivers/bluetooth/dtl1_cs.c linux-2.6.5-mh3/drivers/bluetooth/dtl1_cs.c
--- linux-2.6.5/drivers/bluetooth/dtl1_cs.c	2004-04-04 05:36:57.000000000 +0200
+++ linux-2.6.5-mh3/drivers/bluetooth/dtl1_cs.c	2004-04-10 12:09:49.000000000 +0200
@@ -312,7 +312,7 @@
 	int boguscount = 0;
 	int iir, lsr;
 
-	if (!info) {
+	if (!info || !info->hdev) {
 		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
@@ -483,6 +483,27 @@
 
 	set_bit(XMIT_WAITING, &(info->tx_state));
 
+	/* Initialize HCI device */
+	hdev = hci_alloc_dev();
+	if (!hdev) {
+		BT_ERR("Can't allocate HCI device");
+		return -ENOMEM;
+	}
+
+	info->hdev = hdev;
+
+	hdev->type = HCI_PCCARD;
+	hdev->driver_data = info;
+
+	hdev->open     = dtl1_hci_open;
+	hdev->close    = dtl1_hci_close;
+	hdev->flush    = dtl1_hci_flush;
+	hdev->send     = dtl1_hci_send_frame;
+	hdev->destruct = dtl1_hci_destruct;
+	hdev->ioctl    = dtl1_hci_ioctl;
+
+	hdev->owner = THIS_MODULE;
+
 	spin_lock_irqsave(&(info->lock), flags);
 
 	/* Reset UART */
@@ -506,30 +527,10 @@
 	set_current_state(TASK_INTERRUPTIBLE);
 	schedule_timeout(HZ * 2);
 
-
-	/* Initialize and register HCI device */
-	hdev = hci_alloc_dev();
-	if (!hdev) {
-		BT_ERR("Can't allocate HCI device");
-		return -ENOMEM;
-	}
-
-	info->hdev = hdev;
-
-	hdev->type = HCI_PCCARD;
-	hdev->driver_data = info;
-
-	hdev->open = dtl1_hci_open;
-	hdev->close = dtl1_hci_close;
-	hdev->flush = dtl1_hci_flush;
-	hdev->send = dtl1_hci_send_frame;
-	hdev->destruct = dtl1_hci_destruct;
-	hdev->ioctl = dtl1_hci_ioctl;
-
-	hdev->owner = THIS_MODULE;
-
+	/* Register HCI device */
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
+		info->hdev = NULL;
 		hci_free_dev(hdev);
 		return -ENODEV;
 	}
@@ -544,6 +545,9 @@
 	unsigned int iobase = info->link.io.BasePort1;
 	struct hci_dev *hdev = info->hdev;
 
+	if (!hdev)
+		return -ENODEV;
+
 	dtl1_hci_close(hdev);
 
 	spin_lock_irqsave(&(info->lock), flags);
diff -urN linux-2.6.5/drivers/bluetooth/hci_uart.h linux-2.6.5-mh3/drivers/bluetooth/hci_uart.h
--- linux-2.6.5/drivers/bluetooth/hci_uart.h	2004-04-04 05:36:15.000000000 +0200
+++ linux-2.6.5-mh3/drivers/bluetooth/hci_uart.h	2004-04-10 12:09:49.000000000 +0200
@@ -35,11 +35,12 @@
 #define HCIUARTGETPROTO	_IOR('U', 201, int)
 
 /* UART protocols */
-#define HCI_UART_MAX_PROTO	3
+#define HCI_UART_MAX_PROTO	4
 
 #define HCI_UART_H4	0
 #define HCI_UART_BCSP	1
-#define HCI_UART_NCSP	2
+#define HCI_UART_3WIRE	2
+#define HCI_UART_H4DS	3
 
 #ifdef __KERNEL__
 struct hci_uart;
diff -urN linux-2.6.5/drivers/bluetooth/hci_usb.c linux-2.6.5-mh3/drivers/bluetooth/hci_usb.c
--- linux-2.6.5/drivers/bluetooth/hci_usb.c	2004-04-04 05:38:17.000000000 +0200
+++ linux-2.6.5-mh3/drivers/bluetooth/hci_usb.c	2004-04-10 12:09:49.000000000 +0200
@@ -109,8 +109,7 @@
 				sizeof(struct usb_iso_packet_descriptor) * isoc, gfp);
 	if (_urb) {
 		memset(_urb, 0, sizeof(*_urb));
-		_urb->urb.count = (atomic_t)ATOMIC_INIT(1);
-		spin_lock_init(&_urb->urb.lock);
+		usb_init_urb(&_urb->urb);
 	}
 	return _urb;
 }
@@ -341,6 +340,14 @@
 	return 0;
 }
 
+static inline void hci_usb_wait_for_urb(struct urb *urb)
+{
+	while (atomic_read(&urb->count) > 1) {
+		current->state = TASK_UNINTERRUPTIBLE;
+		schedule_timeout((5 * HZ + 999) / 1000);
+	}
+}
+
 static void hci_usb_unlink_urbs(struct hci_usb *husb)
 {
 	int i;
@@ -357,6 +364,7 @@
 			BT_DBG("%s unlinking _urb %p type %d urb %p", 
 					husb->hdev->name, _urb, _urb->type, urb);
 			usb_unlink_urb(urb);
+			hci_usb_wait_for_urb(urb);
 			_urb_queue_tail(__completed_q(husb, _urb->type), _urb);
 		}
 
@@ -699,11 +707,11 @@
 	BT_DBG("%s urb %p type %d status %d count %d flags %x", hdev->name, urb,
 			_urb->type, urb->status, count, urb->transfer_flags);
 
-	if (!test_bit(HCI_RUNNING, &hdev->flags))
-		return;
-
 	read_lock(&husb->completion_lock);
 
+	if (!test_bit(HCI_RUNNING, &hdev->flags))
+		goto unlock;
+
 	if (urb->status || !count)
 		goto resubmit;
 
@@ -739,6 +747,7 @@
 	BT_DBG("%s urb %p type %d resubmit status %d", hdev->name, urb,
 			_urb->type, err);
 
+unlock:
 	read_unlock(&husb->completion_lock);
 }
 
diff -urN linux-2.6.5/drivers/bluetooth/Kconfig linux-2.6.5-mh3/drivers/bluetooth/Kconfig
--- linux-2.6.5/drivers/bluetooth/Kconfig	2004-04-04 05:36:57.000000000 +0200
+++ linux-2.6.5-mh3/drivers/bluetooth/Kconfig	2004-04-10 12:09:49.000000000 +0200
@@ -104,6 +104,7 @@
 config BT_HCIBT3C
 	tristate "HCI BT3C (PC Card) driver"
 	depends on PCMCIA
+	select FW_LOADER
 	help
 	  Bluetooth HCI BT3C (PC Card) driver.
 	  This driver provides support for Bluetooth PCMCIA devices with
@@ -111,9 +112,6 @@
 	     3Com Bluetooth Card (3CRWB6096)
 	     HP Bluetooth Card
 
-	  The HCI BT3C driver uses external firmware loader program provided in
-	  the BlueFW package. For more information, see <http://bluez.sf.net>.
-
 	  Say Y here to compile support for HCI BT3C devices into the
 	  kernel or say M to compile it as module (bt3c_cs).
 
diff -urN linux-2.6.5/include/net/bluetooth/hci_core.h linux-2.6.5-mh3/include/net/bluetooth/hci_core.h
--- linux-2.6.5/include/net/bluetooth/hci_core.h	2004-04-04 05:37:07.000000000 +0200
+++ linux-2.6.5-mh3/include/net/bluetooth/hci_core.h	2004-04-10 12:09:49.000000000 +0200
@@ -515,9 +515,9 @@
 #define HCI_SFLT_MAX_OGF  5
 
 struct hci_sec_filter {
-	unsigned long type_mask;
-	unsigned long event_mask[2];
-	unsigned long ocf_mask[HCI_SFLT_MAX_OGF + 1][4];
+	__u32 type_mask;
+	__u32 event_mask[2];
+	__u32 ocf_mask[HCI_SFLT_MAX_OGF + 1][4];
 };
 
 /* ----- HCI requests ----- */
diff -urN linux-2.6.5/net/bluetooth/hci_sock.c linux-2.6.5-mh3/net/bluetooth/hci_sock.c
--- linux-2.6.5/net/bluetooth/hci_sock.c	2004-04-04 05:37:23.000000000 +0200
+++ linux-2.6.5-mh3/net/bluetooth/hci_sock.c	2004-04-10 12:09:49.000000000 +0200
@@ -61,6 +61,11 @@
 
 /* ----- HCI socket interface ----- */
 
+static inline int hci_test_bit(int nr, void *addr)
+{
+	return *((__u32 *) addr + (nr >> 5)) & ((__u32) 1 << (nr & 31));
+}
+
 /* Security filter */
 static struct hci_sec_filter hci_sec_filter = {
 	/* Packet types */
@@ -115,8 +120,8 @@
 
 		if (skb->pkt_type == HCI_EVENT_PKT) {
 			register int evt = (*(__u8 *)skb->data & HCI_FLT_EVENT_BITS);
-			
-			if (!test_bit(evt, flt->event_mask))
+
+			if (!hci_test_bit(evt, &flt->event_mask))
 				continue;
 
 			if (flt->opcode && ((evt == HCI_EV_CMD_COMPLETE && 
@@ -399,8 +404,8 @@
 		u16 ogf = hci_opcode_ogf(opcode);
 		u16 ocf = hci_opcode_ocf(opcode);
 
-		if (((ogf > HCI_SFLT_MAX_OGF) || 
-				!test_bit(ocf & HCI_FLT_OCF_BITS, hci_sec_filter.ocf_mask[ogf])) &&
+		if (((ogf > HCI_SFLT_MAX_OGF) ||
+				!hci_test_bit(ocf & HCI_FLT_OCF_BITS, &hci_sec_filter.ocf_mask[ogf])) &&
 		    			!capable(CAP_NET_RAW)) {
 			err = -EPERM;
 			goto drop;
diff -urN linux-2.6.5/net/bluetooth/rfcomm/tty.c linux-2.6.5-mh3/net/bluetooth/rfcomm/tty.c
--- linux-2.6.5/net/bluetooth/rfcomm/tty.c	2004-04-04 05:37:07.000000000 +0200
+++ linux-2.6.5-mh3/net/bluetooth/rfcomm/tty.c	2004-04-10 12:09:49.000000000 +0200
@@ -315,7 +315,7 @@
 
 	if (req.flags != NOCAP_FLAGS && !capable(CAP_NET_ADMIN))
 		return -EPERM;
-	
+
 	if (req.flags & (1 << RFCOMM_REUSE_DLC)) {
 		/* Socket must be connected */
 		if (sk->sk_state != BT_CONNECTED)
@@ -354,12 +354,14 @@
 
 	BT_DBG("dev_id %id flags 0x%x", req.dev_id, req.flags);
 
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-	
 	if (!(dev = rfcomm_dev_get(req.dev_id)))
 		return -ENODEV;
 
+	if (dev->flags != NOCAP_FLAGS && !capable(CAP_NET_ADMIN)) {
+		rfcomm_dev_put(dev);
+		return -EPERM;
+	}
+
 	if (req.flags & (1 << RFCOMM_HANGUP_NOW))
 		rfcomm_dlc_close(dev->dlc, 0);
 
