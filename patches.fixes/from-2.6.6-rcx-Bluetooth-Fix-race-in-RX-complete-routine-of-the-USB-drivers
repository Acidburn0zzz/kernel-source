#date: 2004-04-09
#id: 1.1371.679.11
#tag: other
#time: 19:17:36
#title: [Bluetooth] Fix race in RX complete routine of the USB drivers
#who: marcel@holtmann.org
#
# ChangeSet
#   1.1371.679.11 04/04/09 19:17:36 marcel@holtmann.org +2 -0
#   [Bluetooth] Fix race in RX complete routine of the USB drivers
#   
#   The test of the HCI_RUNNING flags bit in the RX complete routine should
#   be made while holding the completion lock. Otherwise there can be a race
#   on SMP systems in which RX complete finds the bit is set and on another
#   processor the close routine clears the bit, grabs and releases the lock
#   and then unlinks all the active URB's. Then the first processor acquires
#   the lock and resubmits the URB.
#   
#   Patch from Alan Stern <stern@rowland.harvard.edu>
#
# drivers/bluetooth/hci_usb.c +5 -5
# drivers/bluetooth/bfusb.c +4 -3
#
diff -Nru a/drivers/bluetooth/bfusb.c b/drivers/bluetooth/bfusb.c
--- a/drivers/bluetooth/bfusb.c	Wed Apr 28 00:14:32 2004
+++ b/drivers/bluetooth/bfusb.c	Wed Apr 28 00:14:32 2004
@@ -368,11 +368,11 @@
 
 	BT_DBG("bfusb %p urb %p skb %p len %d", bfusb, urb, skb, skb->len);
 
-	if (!test_bit(HCI_RUNNING, &bfusb->hdev->flags))
-		return;
-
 	read_lock(&bfusb->lock);
 
+	if (!test_bit(HCI_RUNNING, &bfusb->hdev->flags))
+		goto unlock;
+
 	if (urb->status || !count)
 		goto resubmit;
 
@@ -423,6 +423,7 @@
 					bfusb->hdev->name, urb, err);
 	}
 
+unlock:
 	read_unlock(&bfusb->lock);
 }
 
diff -Nru a/drivers/bluetooth/hci_usb.c b/drivers/bluetooth/hci_usb.c
--- a/drivers/bluetooth/hci_usb.c	Wed Apr 28 00:14:32 2004
+++ b/drivers/bluetooth/hci_usb.c	Wed Apr 28 00:14:32 2004
@@ -109,8 +109,7 @@
 				sizeof(struct usb_iso_packet_descriptor) * isoc, gfp);
 	if (_urb) {
 		memset(_urb, 0, sizeof(*_urb));
-		_urb->urb.count = (atomic_t)ATOMIC_INIT(1);
-		spin_lock_init(&_urb->urb.lock);
+		usb_init_urb(&_urb->urb);
 	}
 	return _urb;
 }
@@ -708,11 +707,11 @@
 	BT_DBG("%s urb %p type %d status %d count %d flags %x", hdev->name, urb,
 			_urb->type, urb->status, count, urb->transfer_flags);
 
-	if (!test_bit(HCI_RUNNING, &hdev->flags))
-		return;
-
 	read_lock(&husb->completion_lock);
 
+	if (!test_bit(HCI_RUNNING, &hdev->flags))
+		goto unlock;
+
 	if (urb->status || !count)
 		goto resubmit;
 
@@ -748,6 +747,7 @@
 	BT_DBG("%s urb %p type %d resubmit status %d", hdev->name, urb,
 			_urb->type, err);
 
+unlock:
 	read_unlock(&husb->completion_lock);
 }
 
