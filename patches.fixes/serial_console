From: schwab@suse.de
Subject: Misc serial fixes we've been carrying for ages

This should really be merged upstream --okir

---
 drivers/serial/21285.c       |    6 +++---
 drivers/serial/68360serial.c |   32 ++++++++++++++++----------------
 drivers/serial/8250.c        |    5 ++---
 drivers/serial/clps711x.c    |    8 ++++----
 drivers/serial/pmac_zilog.c  |    8 ++++----
 drivers/serial/sa1100.c      |    8 ++++----
 drivers/serial/sunsu.c       |    5 ++---
 drivers/serial/sunzilog.c    |    2 +-
 8 files changed, 36 insertions(+), 38 deletions(-)

Index: linux-2.6.15/drivers/serial/21285.c
===================================================================
--- linux-2.6.15.orig/drivers/serial/21285.c
+++ linux-2.6.15/drivers/serial/21285.c
@@ -383,14 +383,14 @@ serial21285_console_write(struct console
 	int i;
 
 	for (i = 0; i < count; i++) {
-		while (*CSR_UARTFLG & 0x20)
-			barrier();
-		*CSR_UARTDR = s[i];
 		if (s[i] == '\n') {
 			while (*CSR_UARTFLG & 0x20)
 				barrier();
 			*CSR_UARTDR = '\r';
 		}
+		while (*CSR_UARTFLG & 0x20)
+			barrier();
+		*CSR_UARTDR = s[i];
 	}
 }
 
Index: linux-2.6.15/drivers/serial/68360serial.c
===================================================================
--- linux-2.6.15.orig/drivers/serial/68360serial.c
+++ linux-2.6.15/drivers/serial/68360serial.c
@@ -2143,6 +2143,22 @@ static void my_console_write(int idx, co
 	 * buffer, but we would just wait longer between accesses......
 	 */
 	for (i = 0; i < count; i++, s++) {
+		/* if a LF, also do CR... */
+		if (*s == 10) {
+			while (bdp->status & BD_SC_READY);
+			/* cp = __va(bdp->buf); */
+			cp = bdp->buf;
+			*cp = 13;
+			bdp->length = 1;
+			bdp->status |= BD_SC_READY;
+
+			if (bdp->status & BD_SC_WRAP) {
+				bdp = bdbase;
+			}
+			else {
+				bdp++;
+			}
+		}
 		/* Wait for transmitter fifo to empty.
 		 * Ready indicates output is ready, and xmt is doing
 		 * that, not that it is ready for us to send.
@@ -2162,22 +2178,6 @@ static void my_console_write(int idx, co
 		else
 			bdp++;
 
-		/* if a LF, also do CR... */
-		if (*s == 10) {
-			while (bdp->status & BD_SC_READY);
-			/* cp = __va(bdp->buf); */
-			cp = bdp->buf;
-			*cp = 13;
-			bdp->length = 1;
-			bdp->status |= BD_SC_READY;
-
-			if (bdp->status & BD_SC_WRAP) {
-				bdp = bdbase;
-			}
-			else {
-				bdp++;
-			}
-		}
 	}
 
 	/*
Index: linux-2.6.15/drivers/serial/8250.c
===================================================================
--- linux-2.6.15.orig/drivers/serial/8250.c
+++ linux-2.6.15/drivers/serial/8250.c
@@ -2244,17 +2244,16 @@ serial8250_console_write(struct console 
 	 *	Now, do each character
 	 */
 	for (i = 0; i < count; i++, s++) {
-		wait_for_xmitr(up, UART_LSR_THRE);
-
 		/*
 		 *	Send the character out.
 		 *	If a LF, also do CR...
 		 */
-		serial_out(up, UART_TX, *s);
 		if (*s == 10) {
 			wait_for_xmitr(up, UART_LSR_THRE);
 			serial_out(up, UART_TX, 13);
 		}
+		wait_for_xmitr(up, UART_LSR_THRE);
+		serial_out(up, UART_TX, *s);
 	}
 
 	/*
Index: linux-2.6.15/drivers/serial/clps711x.c
===================================================================
--- linux-2.6.15.orig/drivers/serial/clps711x.c
+++ linux-2.6.15/drivers/serial/clps711x.c
@@ -450,16 +450,16 @@ clps711xuart_console_write(struct consol
 	 *	Now, do each character
 	 */
 	for (i = 0; i < count; i++) {
-		do {
-			status = clps_readl(SYSFLG(port));
-		} while (status & SYSFLG_UTXFF);
-		clps_writel(s[i], UARTDR(port));
 		if (s[i] == '\n') {
 			do {
 				status = clps_readl(SYSFLG(port));
 			} while (status & SYSFLG_UTXFF);
 			clps_writel('\r', UARTDR(port));
 		}
+		do {
+			status = clps_readl(SYSFLG(port));
+		} while (status & SYSFLG_UTXFF);
+		clps_writel(s[i], UARTDR(port));
 	}
 
 	/*
Index: linux-2.6.15/drivers/serial/pmac_zilog.c
===================================================================
--- linux-2.6.15.orig/drivers/serial/pmac_zilog.c
+++ linux-2.6.15/drivers/serial/pmac_zilog.c
@@ -1935,15 +1935,15 @@ static void pmz_console_write(struct con
 	write_zsreg(uap, R5, uap->curregs[5] | TxENABLE | RTS | DTR);
 
 	for (i = 0; i < count; i++) {
-		/* Wait for the transmit buffer to empty. */
-		while ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0)
-			udelay(5);
-		write_zsdata(uap, s[i]);
 		if (s[i] == 10) {
 			while ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0)
 				udelay(5);
 			write_zsdata(uap, R13);
 		}
+		/* Wait for the transmit buffer to empty. */
+		while ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0)
+			udelay(5);
+		write_zsdata(uap, s[i]);
 	}
 
 	/* Restore the values in the registers. */
Index: linux-2.6.15/drivers/serial/sa1100.c
===================================================================
--- linux-2.6.15.orig/drivers/serial/sa1100.c
+++ linux-2.6.15/drivers/serial/sa1100.c
@@ -710,16 +710,16 @@ sa1100_console_write(struct console *co,
 	 *	Now, do each character
 	 */
 	for (i = 0; i < count; i++) {
-		do {
-			status = UART_GET_UTSR1(sport);
-		} while (!(status & UTSR1_TNF));
-		UART_PUT_CHAR(sport, s[i]);
 		if (s[i] == '\n') {
 			do {
 				status = UART_GET_UTSR1(sport);
 			} while (!(status & UTSR1_TNF));
 			UART_PUT_CHAR(sport, '\r');
 		}
+		do {
+			status = UART_GET_UTSR1(sport);
+		} while (!(status & UTSR1_TNF));
+		UART_PUT_CHAR(sport, s[i]);
 	}
 
 	/*
Index: linux-2.6.15/drivers/serial/sunsu.c
===================================================================
--- linux-2.6.15.orig/drivers/serial/sunsu.c
+++ linux-2.6.15/drivers/serial/sunsu.c
@@ -1400,17 +1400,16 @@ static void sunsu_console_write(struct c
 	 *	Now, do each character
 	 */
 	for (i = 0; i < count; i++, s++) {
-		wait_for_xmitr(up);
-
 		/*
 		 *	Send the character out.
 		 *	If a LF, also do CR...
 		 */
-		serial_out(up, UART_TX, *s);
 		if (*s == 10) {
 			wait_for_xmitr(up);
 			serial_out(up, UART_TX, 13);
 		}
+		wait_for_xmitr(up);
+		serial_out(up, UART_TX, *s);
 	}
 
 	/*
Index: linux-2.6.15/drivers/serial/sunzilog.c
===================================================================
--- linux-2.6.15.orig/drivers/serial/sunzilog.c
+++ linux-2.6.15/drivers/serial/sunzilog.c
@@ -1331,9 +1331,9 @@ sunzilog_console_write(struct console *c
 
 	spin_lock_irqsave(&up->port.lock, flags);
 	for (i = 0; i < count; i++, s++) {
-		sunzilog_put_char(channel, *s);
 		if (*s == 10)
 			sunzilog_put_char(channel, 13);
+		sunzilog_put_char(channel, *s);
 	}
 	udelay(2);
 	spin_unlock_irqrestore(&up->port.lock, flags);
