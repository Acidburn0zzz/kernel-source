From: Jens Axboe <axboe@suse.de>
Subject: Fix order of port vs drive transfer settings on resume
Patch-mainline: 
References: 

We can't just use ata_set_mode() before calling the ACPI hooks, since
we need to typically unlock the drive before doing so. And we can't
necessarily issue the ACPI taskfiles without having programmed the
hardware timings first.

So split port and drive settings in two parts, to satisfy both.

Acked-by: 
Signed-off-by: 

--- linux-2.6.16/drivers/scsi/libata-core.c~	2006-03-23 21:06:21.000000000 +0100
+++ linux-2.6.16/drivers/scsi/libata-core.c	2006-03-23 21:09:28.000000000 +0100
@@ -67,6 +67,7 @@ static unsigned int ata_busy_sleep (stru
 static void ata_dev_reread_id(struct ata_port *ap, struct ata_device *dev);
 static void ata_dev_init_params(struct ata_port *ap, struct ata_device *dev);
 static void ata_set_mode(struct ata_port *ap);
+static void ata_set_drives_mode(struct ata_port *ap);
 static void ata_dev_set_xfermode(struct ata_port *ap, struct ata_device *dev);
 static unsigned int ata_get_mode_mask(const struct ata_port *ap, int shift);
 static int fgb(u32 bitmap);
@@ -1512,6 +1513,8 @@ static int ata_bus_probe(struct ata_port
 		goto err_out_disable;
 
 	ata_set_mode(ap);
+	ata_set_drives_mode(ap);
+
 	if (ap->flags & ATA_FLAG_PORT_DISABLED)
 		goto err_out_disable;
 
@@ -1890,6 +1893,12 @@ static void ata_host_set_dma(struct ata_
 	}
 }
 
+static void ata_set_drives_mode(struct ata_port *ap)
+{
+	ata_dev_set_mode(ap, &ap->device[0]);
+	ata_dev_set_mode(ap, &ap->device[1]);
+}
+
 /**
  *	ata_set_mode - Program timings and issue SET FEATURES - XFER
  *	@ap: port on which timings will be programmed
@@ -1921,10 +1930,6 @@ static void ata_set_mode(struct ata_port
 	if (xfer_shift != ATA_SHIFT_PIO)
 		ata_host_set_dma(ap, xfer_mode, xfer_shift);
 
-	/* step 4: update devices' xfer mode */
-	ata_dev_set_mode(ap, &ap->device[0]);
-	ata_dev_set_mode(ap, &ap->device[1]);
-
 	if (ap->flags & ATA_FLAG_PORT_DISABLED)
 		return;
 
@@ -4310,10 +4315,13 @@ int ata_device_resume(struct ata_port *a
 
 	if (!ata_dev_present(dev))
 		return 0;
+
+	ata_set_mode(ap);
 	ata_acpi_exec_tfs(ap);
+
 	if (ap->flags & ATA_FLAG_SUSPENDED) {
 		ap->flags &= ~ATA_FLAG_SUSPENDED;
-		ata_set_mode(ap);
+		ata_set_drives_mode(ap);
 	}
 	if (dev->class == ATA_DEV_ATA)
 		ata_start_drive(ap, dev);
