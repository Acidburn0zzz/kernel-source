Subject: i8042 - let serio bus suspend ports

Input: i8042 - let serio bus suspend ports

Let serio subsystem take care of suspending the ports; concentrate
on suspending/resuming the controller itself. Also make sure that
we suspennding the controller only after we really goting to
suspend, not when we iabout to take memory snapshot.

Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
---

 drivers/input/serio/i8042.c |   39 +++++++++++++++------------------------
 drivers/input/serio/serio.c |   28 +++++++++++++++++++++++++++-
 include/linux/serio.h       |    6 ------
 3 files changed, 42 insertions(+), 31 deletions(-)

Index: linux/drivers/input/serio/i8042.c
===================================================================
--- linux.orig/drivers/input/serio/i8042.c
+++ linux/drivers/input/serio/i8042.c
@@ -791,27 +791,6 @@ static void i8042_controller_reset(void)
 
 
 /*
- * Here we try to reset everything back to a state in which the BIOS will be
- * able to talk to the hardware when rebooting.
- */
-
-static void i8042_controller_cleanup(void)
-{
-	int i;
-
-/*
- * Reset anything that is connected to the ports.
- */
-
-	for (i = 0; i < I8042_NUM_PORTS; i++)
-		if (i8042_ports[i].serio)
-			serio_cleanup(i8042_ports[i].serio);
-
-	i8042_controller_reset();
-}
-
-
-/*
  * i8042_panic_blink() will flash the keyboard LEDs and is called when
  * kernel panics. Flashing LEDs is useful for users running X who may
  * not see the console and will help distingushing panics from "real"
@@ -858,12 +837,15 @@ static long i8042_panic_blink(long count
 #undef DELAY
 
 /*
- * Here we try to restore the original BIOS settings
+ * Here we try to restore the original BIOS settings. We only want to
+ * do that once, when we really suspend, not when we need to take a
+ * snapshot.
  */
 
 static int i8042_suspend(struct platform_device *dev, pm_message_t state)
 {
-	i8042_controller_cleanup();
+	if (state.event == PM_EVENT_SUSPEND)
+		i8042_controller_reset();
 
 	return 0;
 }
@@ -877,6 +859,12 @@ static int i8042_resume(struct platform_
 {
 	int error;
 
+/*
+ * Do not bother with restoring state if we haven't really suspened yet
+ */
+	if (dev->dev.power.power_state.event != PM_EVENT_SUSPEND)
+		return 0;
+
 	error = i8042_controller_check();
 	if (error)
 		return error;
@@ -889,6 +877,9 @@ static int i8042_resume(struct platform_
  * Restore pre-resume CTR value and disable all ports
  */
 
+	i8042_ctr = i8042_initial_ctr;
+	if (i8042_direct)
+		i8042_ctr &= ~I8042_CTR_XLATE;
 	i8042_ctr |= I8042_CTR_AUXDIS | I8042_CTR_KBDDIS;
 	i8042_ctr &= ~(I8042_CTR_AUXINT | I8042_CTR_KBDINT);
 	if (i8042_command(&i8042_ctr, I8042_CMD_CTL_WCTR)) {
@@ -919,7 +910,7 @@ static int i8042_resume(struct platform_
 
 static void i8042_shutdown(struct platform_device *dev)
 {
-	i8042_controller_cleanup();
+	i8042_controller_reset();
 }
 
 static int __devinit i8042_create_kbd_port(void)
Index: linux/drivers/input/serio/serio.c
===================================================================
--- linux.orig/drivers/input/serio/serio.c
+++ linux/drivers/input/serio/serio.c
@@ -778,6 +778,19 @@ static int serio_driver_remove(struct de
 	return 0;
 }
 
+static void serio_cleanup(struct serio *serio)
+{
+	if (serio->drv && serio->drv->cleanup)
+		serio->drv->cleanup(serio);
+}
+
+static void serio_shutdown(struct device *dev)
+{
+	struct serio *serio = to_serio_port(dev);
+
+	serio_cleanup(serio);
+}
+
 static void serio_attach_driver(struct serio_driver *drv)
 {
 	int error;
@@ -910,11 +923,22 @@ static int serio_uevent(struct device *d
 
 #endif /* CONFIG_HOTPLUG */
 
+static int serio_suspend(struct device *dev, pm_message_t state)
+{
+	struct serio *serio = to_serio_port(dev);
+
+	if (state.event == PM_EVENT_SUSPEND)
+		serio_cleanup(serio);
+
+	return 0;
+}
+
 static int serio_resume(struct device *dev)
 {
 	struct serio *serio = to_serio_port(dev);
 
-	if (serio_reconnect_driver(serio)) {
+	if (dev->power.power_state.event == PM_EVENT_SUSPEND &&
+	    serio_reconnect_driver(serio)) {
 		/*
 		 * Driver re-probing can take a while, so better let kseriod
 		 * deal with it.
@@ -974,6 +998,8 @@ static struct bus_type serio_bus = {
 	.uevent		= serio_uevent,
 	.probe		= serio_driver_probe,
 	.remove		= serio_driver_remove,
+	.shutdown	= serio_shutdown,
+	.suspend	= serio_suspend,
 	.resume		= serio_resume,
 };
 
Index: linux/include/linux/serio.h
===================================================================
--- linux.orig/include/linux/serio.h
+++ linux/include/linux/serio.h
@@ -108,12 +108,6 @@ static inline void serio_drv_write_wakeu
 		serio->drv->write_wakeup(serio);
 }
 
-static inline void serio_cleanup(struct serio *serio)
-{
-	if (serio->drv && serio->drv->cleanup)
-		serio->drv->cleanup(serio);
-}
-
 /*
  * Use the following functions to manipulate serio's per-port
  * driver-specific data.
