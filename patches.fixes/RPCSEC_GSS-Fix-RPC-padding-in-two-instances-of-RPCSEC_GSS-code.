#date: 2004-04-11
#id: 1.1371.694.12
#tag: nfs+rpc
#time: 11:24:37
#title: RPCSEC_GSS: Fix RPC padding in two instances of RPCSEC_GSS code.
#who: trond.myklebust@fys.uio.no
#
# ChangeSet
#   1.1371.694.12 04/04/11 11:24:37 trond.myklebust@fys.uio.no +5 -0
#   RPCSEC_GSS: Fix RPC padding in two instances of RPCSEC_GSS code.
#   RPC: Clean up XDR encoding of opaque data.
#
# net/sunrpc/xdr.c +41 -7
# net/sunrpc/sunrpc_syms.c +0 -1
# net/sunrpc/auth_gss/auth_gss.c +2 -5
# include/linux/sunrpc/xdr.h +7 -1
# fs/nfs/nfs4xdr.c +1 -12
#   RPCSEC_GSS: Fix RPC padding in two instances of RPCSEC_GSS code.
#     RPC: Clean up XDR encoding of opaque data.
#
diff -Nru a/fs/nfs/nfs4xdr.c b/fs/nfs/nfs4xdr.c
--- a/fs/nfs/nfs4xdr.c	Wed Apr 28 00:07:06 2004
+++ b/fs/nfs/nfs4xdr.c	Wed Apr 28 00:07:06 2004
@@ -297,7 +297,7 @@
 	*p++ = htonl((uint32_t)(n));					\
 } while (0)
 #define WRITEMEM(ptr,nbytes)     do {				\
-	p = xdr_writemem(p, ptr, nbytes);			\
+	p = xdr_encode_opaque_fixed(p, ptr, nbytes);		\
 } while (0)
 
 #define RESERVE_SPACE(nbytes)	do {				\
@@ -305,17 +305,6 @@
 	if (!p) printk("RESERVE_SPACE(%d) failed in function %s\n", (int) (nbytes), __FUNCTION__); \
 	BUG_ON(!p);						\
 } while (0)
-
-static inline
-uint32_t *xdr_writemem(uint32_t *p, const void *ptr, int nbytes)
-{
-	int tmp = XDR_QUADLEN(nbytes);
-	if (!tmp)
-		return p;
-	p[tmp-1] = 0;
-	memcpy(p, ptr, nbytes);
-	return p + tmp;
-}
 
 static int
 encode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)
diff -Nru a/include/linux/sunrpc/xdr.h b/include/linux/sunrpc/xdr.h
--- a/include/linux/sunrpc/xdr.h	Wed Apr 28 00:07:06 2004
+++ b/include/linux/sunrpc/xdr.h	Wed Apr 28 00:07:06 2004
@@ -87,7 +87,8 @@
 /*
  * Miscellaneous XDR helper functions
  */
-u32 *	xdr_encode_array(u32 *p, const void *s, unsigned int len);
+u32 *	xdr_encode_opaque_fixed(u32 *p, const void *ptr, unsigned int len);
+u32 *	xdr_encode_opaque(u32 *p, const void *ptr, unsigned int len);
 u32 *	xdr_encode_string(u32 *p, const char *s);
 u32 *	xdr_decode_string(u32 *p, char **sp, int *lenp, int maxlen);
 u32 *	xdr_decode_string_inplace(u32 *p, char **sp, int *lenp, int maxlen);
@@ -99,6 +100,11 @@
 			 unsigned int);
 void	xdr_inline_pages(struct xdr_buf *, unsigned int,
 			 struct page **, unsigned int, unsigned int);
+
+static inline u32 *xdr_encode_array(u32 *p, const void *s, unsigned int len)
+{
+	return xdr_encode_opaque(p, s, len);
+}
 
 /*
  * Decode 64bit quantities (NFSv3 support)
diff -Nru a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c
--- a/net/sunrpc/auth_gss/auth_gss.c	Wed Apr 28 00:07:06 2004
+++ b/net/sunrpc/auth_gss/auth_gss.c	Wed Apr 28 00:07:06 2004
@@ -721,8 +721,7 @@
 		printk("gss_marshal: gss_get_mic FAILED (%d)\n", maj_stat);
 		goto out_put_ctx;
 	}
-	*p++ = htonl(mic.len);
-	p += XDR_QUADLEN(mic.len);
+	p = xdr_encode_opaque(p, NULL, mic.len);
 	gss_put_ctx(ctx);
 	return p;
 out_put_ctx:
@@ -857,9 +856,7 @@
 			status = -EIO; /* XXX? */
 			if (maj_stat)
 				goto out;
-			q = p;
-			*q++ = htonl(mic.len);
-			q += XDR_QUADLEN(mic.len);
+			q = xdr_encode_opaque(p, NULL, mic.len);
 
 			offset = (u8 *)q - (u8 *)p;
 			iov->iov_len += offset;
diff -Nru a/net/sunrpc/sunrpc_syms.c b/net/sunrpc/sunrpc_syms.c
--- a/net/sunrpc/sunrpc_syms.c	Wed Apr 28 00:07:06 2004
+++ b/net/sunrpc/sunrpc_syms.c	Wed Apr 28 00:07:06 2004
@@ -120,7 +120,6 @@
 EXPORT_SYMBOL(unix_domain_find);
 
 /* Generic XDR */
-EXPORT_SYMBOL(xdr_encode_array);
 EXPORT_SYMBOL(xdr_encode_string);
 EXPORT_SYMBOL(xdr_decode_string);
 EXPORT_SYMBOL(xdr_decode_string_inplace);
diff -Nru a/net/sunrpc/xdr.c b/net/sunrpc/xdr.c
--- a/net/sunrpc/xdr.c	Wed Apr 28 00:07:06 2004
+++ b/net/sunrpc/xdr.c	Wed Apr 28 00:07:06 2004
@@ -53,16 +53,50 @@
 	return p + XDR_QUADLEN(len);
 }
 
-u32 *
-xdr_encode_array(u32 *p, const void *array, unsigned int len)
+/**
+ * xdr_encode_opaque_fixed - Encode fixed length opaque data
+ * @p - pointer to current position in XDR buffer.
+ * @ptr - pointer to data to encode (or NULL)
+ * @nbytes - size of data.
+ *
+ * Copy the array of data of length nbytes at ptr to the XDR buffer
+ * at position p, then align to the next 32-bit boundary by padding
+ * with zero bytes (see RFC1832).
+ * Note: if ptr is NULL, only the padding is performed.
+ *
+ * Returns the updated current XDR buffer position
+ *
+ */
+u32 *xdr_encode_opaque_fixed(u32 *p, const void *ptr, unsigned int nbytes)
 {
-	int quadlen = XDR_QUADLEN(len);
+	if (likely(nbytes != 0)) {
+		unsigned int quadlen = XDR_QUADLEN(nbytes);
+		unsigned int padding = (quadlen << 2) - nbytes;
 
-	p[quadlen] = 0;
-	*p++ = htonl(len);
-	memcpy(p, array, len);
-	return p + quadlen;
+		if (ptr != NULL)
+			memcpy(p, ptr, nbytes);
+		if (padding != 0)
+			memset((char *)p + nbytes, 0, padding);
+		p += quadlen;
+	}
+	return p;
 }
+EXPORT_SYMBOL(xdr_encode_opaque_fixed);
+
+/**
+ * xdr_encode_opaque - Encode variable length opaque data
+ * @p - pointer to current position in XDR buffer.
+ * @ptr - pointer to data to encode (or NULL)
+ * @nbytes - size of data.
+ *
+ * Returns the updated current XDR buffer position
+ */
+u32 *xdr_encode_opaque(u32 *p, const void *ptr, unsigned int nbytes)
+{
+	*p++ = htonl(nbytes);
+	return xdr_encode_opaque_fixed(p, ptr, nbytes);
+}
+EXPORT_SYMBOL(xdr_encode_opaque);
 
 u32 *
 xdr_encode_string(u32 *p, const char *string)
