#date: 2004-04-19
#from: me, Badari Pulavarty <pbadari@us.ibm.com>
#id: 1.1371.726.7
#tag: via-mm
#time: 12:06:03
#title: direct-IO return type fixes
#who: akpm@osdl.org[torvalds]
#
# ChangeSet
#   1.1371.726.7 04/04/19 12:06:03 akpm@osdl.org[torvalds] +12 -0
#   [PATCH] direct-IO return type fixes
#   
#   From: me, Badari Pulavarty <pbadari@us.ibm.com>
#   
#   Currently a direct-IO read or write of more than 2G on 64-bit machines is
#   broken.  Replace int with ssize_t in various places to fix that up.
#
# include/linux/nfs_fs.h +1 -1
# include/linux/fs.h +4 -4
# fs/xfs/linux/xfs_aops.c +1 -1
# fs/reiserfs/inode.c +3 -3
# fs/nfs/direct.c +10 -8
# fs/jfs/inode.c +2 -2
# fs/hfsplus/inode.c +2 -2
# fs/hfs/inode.c +2 -2
# fs/ext3/inode.c +2 -2
# fs/ext2/inode.c +1 -1
# fs/direct-io.c +5 -5
# fs/block_dev.c +1 -1
#
diff -Nru a/fs/block_dev.c b/fs/block_dev.c
--- a/fs/block_dev.c	Wed Apr 28 00:32:57 2004
+++ b/fs/block_dev.c	Wed Apr 28 00:32:57 2004
@@ -148,7 +148,7 @@
 	return 0;
 }
 
-static int
+static ssize_t
 blkdev_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs)
 {
diff -Nru a/fs/direct-io.c b/fs/direct-io.c
--- a/fs/direct-io.c	Wed Apr 28 00:32:57 2004
+++ b/fs/direct-io.c	Wed Apr 28 00:32:57 2004
@@ -125,7 +125,7 @@
 	/* AIO related stuff */
 	struct kiocb *iocb;		/* kiocb */
 	int is_async;			/* is IO async ? */
-	int result;			/* IO result */
+	ssize_t result;                 /* IO result */
 };
 
 /*
@@ -898,7 +898,7 @@
 /*
  * Releases both i_sem and i_alloc_sem
  */
-static int
+static ssize_t
 direct_io_worker(int rw, struct kiocb *iocb, struct inode *inode, 
 	const struct iovec *iov, loff_t offset, unsigned long nr_segs, 
 	unsigned blkbits, get_blocks_t get_blocks, dio_iodone_t end_io,
@@ -906,8 +906,8 @@
 {
 	unsigned long user_addr; 
 	int seg;
-	int ret = 0;
-	int ret2;
+	ssize_t ret = 0;
+	ssize_t ret2;
 	size_t bytes;
 
 	dio->bio = NULL;
@@ -1096,7 +1096,7 @@
  *
  * For writes to S_ISBLK files, i_sem is not held on entry; it is never taken.
  */
-int
+ssize_t
 __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	struct block_device *bdev, const struct iovec *iov, loff_t offset, 
 	unsigned long nr_segs, get_blocks_t get_blocks, dio_iodone_t end_io,
diff -Nru a/fs/ext2/inode.c b/fs/ext2/inode.c
--- a/fs/ext2/inode.c	Wed Apr 28 00:32:57 2004
+++ b/fs/ext2/inode.c	Wed Apr 28 00:32:57 2004
@@ -655,7 +655,7 @@
 	return ret;
 }
 
-static int
+static ssize_t
 ext2_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs)
 {
diff -Nru a/fs/ext3/inode.c b/fs/ext3/inode.c
--- a/fs/ext3/inode.c	Wed Apr 28 00:32:57 2004
+++ b/fs/ext3/inode.c	Wed Apr 28 00:32:57 2004
@@ -1525,7 +1525,7 @@
  * If the O_DIRECT write is intantiating holes inside i_size and the machine
  * crashes then stale disk data _may_ be exposed inside the file.
  */
-static int ext3_direct_IO(int rw, struct kiocb *iocb,
+static ssize_t ext3_direct_IO(int rw, struct kiocb *iocb,
 			const struct iovec *iov, loff_t offset,
 			unsigned long nr_segs)
 {
@@ -1533,7 +1533,7 @@
 	struct inode *inode = file->f_mapping->host;
 	struct ext3_inode_info *ei = EXT3_I(inode);
 	handle_t *handle = NULL;
-	int ret;
+	ssize_t ret;
 	int orphan = 0;
 	size_t count = iov_length(iov, nr_segs);
 
diff -Nru a/fs/hfs/inode.c b/fs/hfs/inode.c
--- a/fs/hfs/inode.c	Wed Apr 28 00:32:57 2004
+++ b/fs/hfs/inode.c	Wed Apr 28 00:32:57 2004
@@ -114,8 +114,8 @@
 	return ret;
 }
 
-static int hfs_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
-			 loff_t offset, unsigned long nr_segs)
+static ssize_t hfs_direct_IO(int rw, struct kiocb *iocb,
+		const struct iovec *iov, loff_t offset, unsigned long nr_segs)
 {
 	struct file *file = iocb->ki_filp;
 	struct inode *inode = file->f_dentry->d_inode->i_mapping->host;
diff -Nru a/fs/hfsplus/inode.c b/fs/hfsplus/inode.c
--- a/fs/hfsplus/inode.c	Wed Apr 28 00:32:57 2004
+++ b/fs/hfsplus/inode.c	Wed Apr 28 00:32:57 2004
@@ -114,8 +114,8 @@
 	return ret;
 }
 
-static int hfsplus_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
-			  loff_t offset, unsigned long nr_segs)
+static ssize_t hfsplus_direct_IO(int rw, struct kiocb *iocb,
+		const struct iovec *iov, loff_t offset, unsigned long nr_segs)
 {
 	struct file *file = iocb->ki_filp;
 	struct inode *inode = file->f_dentry->d_inode->i_mapping->host;
diff -Nru a/fs/jfs/inode.c b/fs/jfs/inode.c
--- a/fs/jfs/inode.c	Wed Apr 28 00:32:57 2004
+++ b/fs/jfs/inode.c	Wed Apr 28 00:32:57 2004
@@ -302,8 +302,8 @@
 	return generic_block_bmap(mapping, block, jfs_get_block);
 }
 
-static int jfs_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
-			loff_t offset, unsigned long nr_segs)
+static ssize_t jfs_direct_IO(int rw, struct kiocb *iocb,
+	const struct iovec *iov, loff_t offset, unsigned long nr_segs)
 {
 	struct file *file = iocb->ki_filp;
 	struct inode *inode = file->f_mapping->host;
diff -Nru a/fs/nfs/direct.c b/fs/nfs/direct.c
--- a/fs/nfs/direct.c	Wed Apr 28 00:32:57 2004
+++ b/fs/nfs/direct.c	Wed Apr 28 00:32:57 2004
@@ -191,16 +191,17 @@
  * writes so that this read will see them when we read from the
  * server.
  */
-static int
+static ssize_t
 nfs_direct_read(struct inode *inode, struct file *file,
 		const struct iovec *iov, loff_t file_offset,
 		unsigned long nr_segs)
 {
-	int tot_bytes = 0;
+	ssize_t tot_bytes = 0;
 	unsigned long seg = 0;
 
 	while ((seg < nr_segs) && (tot_bytes >= 0)) {
-		int result, page_count;
+		ssize_t result;
+		int page_count;
 		struct page **pages;
 		const struct iovec *vec = &iov[seg++];
 		unsigned long user_addr = (unsigned long) vec->iov_base;
@@ -359,16 +360,17 @@
  * that non-direct readers might access, so they will pick up these
  * writes immediately.
  */
-static int
+static ssize_t
 nfs_direct_write(struct inode *inode, struct file *file,
 		const struct iovec *iov, loff_t file_offset,
 		unsigned long nr_segs)
 {
-	int tot_bytes = 0;
+	ssize_t tot_bytes = 0;
 	unsigned long seg = 0;
 
 	while ((seg < nr_segs) && (tot_bytes >= 0)) {
-		int result, page_count;
+		ssize_t result;
+		int page_count;
 		struct page **pages;
 		const struct iovec *vec = &iov[seg++];
 		unsigned long user_addr = (unsigned long) vec->iov_base;
@@ -414,11 +416,11 @@
  * The inode's i_sem is no longer held by the VFS layer before it calls
  * this function to do a write.
  */
-int
+ssize_t
 nfs_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
 		loff_t file_offset, unsigned long nr_segs)
 {
-	int result = -EINVAL;
+	ssize_t result = -EINVAL;
 	struct file *file = iocb->ki_filp;
 	struct dentry *dentry = file->f_dentry;
 	struct inode *inode = dentry->d_inode;
diff -Nru a/fs/reiserfs/inode.c b/fs/reiserfs/inode.c
--- a/fs/reiserfs/inode.c	Wed Apr 28 00:32:57 2004
+++ b/fs/reiserfs/inode.c	Wed Apr 28 00:32:57 2004
@@ -2498,14 +2498,14 @@
 
 /* We thank Mingming Cao for helping us understand in great detail what
    to do in this section of the code. */
-static int reiserfs_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
-			      loff_t offset, unsigned long nr_segs)
+static ssize_t reiserfs_direct_IO(int rw, struct kiocb *iocb,
+		const struct iovec *iov, loff_t offset, unsigned long nr_segs)
 {
     struct file *file = iocb->ki_filp;
     struct inode *inode = file->f_mapping->host;
 
     return blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
-			      offset, nr_segs, reiserfs_get_blocks_direct_io, NULL);
+			offset, nr_segs, reiserfs_get_blocks_direct_io, NULL);
 }
 
 
diff -Nru a/fs/xfs/linux/xfs_aops.c b/fs/xfs/linux/xfs_aops.c
--- a/fs/xfs/linux/xfs_aops.c	Wed Apr 28 00:32:57 2004
+++ b/fs/xfs/linux/xfs_aops.c	Wed Apr 28 00:32:57 2004
@@ -1013,7 +1013,7 @@
 					create, 1, BMAPI_WRITE|BMAPI_DIRECT);
 }
 
-STATIC int
+STATIC ssize_t
 linvfs_direct_IO(
 	int			rw,
 	struct kiocb		*iocb,
diff -Nru a/include/linux/fs.h b/include/linux/fs.h
--- a/include/linux/fs.h	Wed Apr 28 00:32:57 2004
+++ b/include/linux/fs.h	Wed Apr 28 00:32:57 2004
@@ -317,7 +317,7 @@
 	sector_t (*bmap)(struct address_space *, sector_t);
 	int (*invalidatepage) (struct page *, unsigned long);
 	int (*releasepage) (struct page *, int);
-	int (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
+	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs);
 };
 
@@ -1409,7 +1409,7 @@
 				actor);
 }
 
-int __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
+ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	struct block_device *bdev, const struct iovec *iov, loff_t offset,
 	unsigned long nr_segs, get_blocks_t get_blocks, dio_iodone_t end_io,
 	int needs_special_locking);
@@ -1417,7 +1417,7 @@
 /*
  * For filesystems which need locking between buffered and direct access
  */
-static inline int blockdev_direct_IO(int rw, struct kiocb *iocb,
+static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
 	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
 	dio_iodone_t end_io)
@@ -1426,7 +1426,7 @@
 				nr_segs, get_blocks, end_io, 1);
 }
 
-static inline int blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
+static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
 	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
 	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
 	dio_iodone_t end_io)
diff -Nru a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
--- a/include/linux/nfs_fs.h	Wed Apr 28 00:32:57 2004
+++ b/include/linux/nfs_fs.h	Wed Apr 28 00:32:57 2004
@@ -304,7 +304,7 @@
 /*
  * linux/fs/nfs/direct.c
  */
-extern int nfs_direct_IO(int, struct kiocb *, const struct iovec *, loff_t,
+extern ssize_t nfs_direct_IO(int, struct kiocb *, const struct iovec *, loff_t,
 			unsigned long);
 
 /*
