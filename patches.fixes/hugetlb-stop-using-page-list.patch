

Switch them over to page.lru


Index: linux.t/arch/i386/mm/hugetlbpage.c
===================================================================
--- linux.t.orig/arch/i386/mm/hugetlbpage.c	2004-01-09 02:00:02.000000000 -0500
+++ linux.t/arch/i386/mm/hugetlbpage.c	2004-03-15 15:20:31.296877239 -0500
@@ -29,7 +29,7 @@ static spinlock_t htlbpage_lock = SPIN_L
 
 static void enqueue_huge_page(struct page *page)
 {
-	list_add(&page->list,
+	list_add(&page->lru,
 		&hugepage_freelists[page_zone(page)->zone_pgdat->node_id]);
 }
 
@@ -44,8 +44,8 @@ static struct page *dequeue_huge_page(vo
 				break;
 	}
 	if (nid >= 0 && nid < MAX_NUMNODES && !list_empty(&hugepage_freelists[nid])) {
-		page = list_entry(hugepage_freelists[nid].next, struct page, list);
-		list_del(&page->list);
+		page = list_entry(hugepage_freelists[nid].next, struct page, lru);
+		list_del(&page->lru);
 	}
 	return page;
 }
@@ -280,7 +280,7 @@ static void free_huge_page(struct page *
 	BUG_ON(page_count(page));
 	BUG_ON(page->mapping);
 
-	INIT_LIST_HEAD(&page->list);
+	INIT_LIST_HEAD(&page->lru);
 
 	spin_lock(&htlbpage_lock);
 	enqueue_huge_page(page);
@@ -409,19 +409,19 @@ static int try_to_free_low(int count)
 	/* all lowmem is on node 0 */
 	list_for_each(p, &hugepage_freelists[0]) {
 		if (map) {
-			list_del(&map->list);
+			list_del(&map->lru);
 			update_and_free_page(map);
 			htlbpagemem--;
 			map = NULL;
 			if (++count == 0)
 				break;
 		}
-		page = list_entry(p, struct page, list);
+		page = list_entry(p, struct page, lru);
 		if (!PageHighMem(page))
 			map = page;
 	}
 	if (map) {
-		list_del(&map->list);
+		list_del(&map->lru);
 		update_and_free_page(map);
 		htlbpagemem--;
 		count++;
Index: linux.t/arch/ia64/mm/hugetlbpage.c
===================================================================
--- linux.t.orig/arch/ia64/mm/hugetlbpage.c	2004-03-12 16:27:14.000000000 -0500
+++ linux.t/arch/ia64/mm/hugetlbpage.c	2004-03-15 15:20:31.316874845 -0500
@@ -32,7 +32,7 @@ static spinlock_t htlbpage_lock = SPIN_L
 
 static void enqueue_huge_page(struct page *page)
 {
-	list_add(&page->list,
+	list_add(&page->lru,
 		&hugepage_freelists[page_zone(page)->zone_pgdat->node_id]);
 }
 
@@ -48,8 +48,8 @@ static struct page *dequeue_huge_page(vo
 	}
 	if (nid >= 0 && nid < MAX_NUMNODES &&
 	    !list_empty(&hugepage_freelists[nid])) {
-		page = list_entry(hugepage_freelists[nid].next, struct page, list);
-		list_del(&page->list);
+		page = list_entry(hugepage_freelists[nid].next, struct page, lru);
+		list_del(&page->lru);
 	}
 	return page;
 }
@@ -248,7 +248,7 @@ void free_huge_page(struct page *page)
 	BUG_ON(page_count(page));
 	BUG_ON(page->mapping);
 
-	INIT_LIST_HEAD(&page->list);
+	INIT_LIST_HEAD(&page->lru);
 
 	spin_lock(&htlbpage_lock);
 	enqueue_huge_page(page);
@@ -449,19 +449,19 @@ int try_to_free_low(int count)
 	spin_lock(&htlbpage_lock);
 	list_for_each(p, &hugepage_freelists[0]) {
 		if (map) {
-			list_del(&map->list);
+			list_del(&map->lru);
 			update_and_free_page(map);
 			htlbpagemem--;
 			map = NULL;
 			if (++count == 0)
 				break;
 		}
-		page = list_entry(p, struct page, list);
+		page = list_entry(p, struct page, lru);
 		if (!PageHighMem(page))
 			map = page;
 	}
 	if (map) {
-		list_del(&map->list);
+		list_del(&map->lru);
 		update_and_free_page(map);
 		htlbpagemem--;
 		count++;
Index: linux.t/arch/ppc64/mm/hugetlbpage.c
===================================================================
--- linux.t.orig/arch/ppc64/mm/hugetlbpage.c	2004-03-12 16:27:16.000000000 -0500
+++ linux.t/arch/ppc64/mm/hugetlbpage.c	2004-03-15 15:20:31.326873647 -0500
@@ -40,7 +40,7 @@ static struct list_head hugepage_freelis
 
 static void enqueue_huge_page(struct page *page)
 {
-	list_add(&page->list,
+	list_add(&page->lru,
 		&hugepage_freelists[page_zone(page)->zone_pgdat->node_id]);
 }
 
@@ -63,8 +63,8 @@ static struct page *dequeue_huge_page(vo
 	}
 
 	if (!list_empty(&hugepage_freelists[nid])) {
-		page = list_entry(hugepage_freelists[nid].next, struct page, list);
-		list_del(&page->list);
+		page = list_entry(hugepage_freelists[nid].next, struct page, lru);
+		list_del(&page->lru);
 	}
 
 	if (largepage_roundrobin)
@@ -409,7 +409,7 @@ static void free_huge_page(struct page *
 	BUG_ON(page_count(page));
 	BUG_ON(page->mapping);
 
-	INIT_LIST_HEAD(&page->list);
+	INIT_LIST_HEAD(&page->lru);
 
 	spin_lock(&htlbpage_lock);
 	enqueue_huge_page(page);
Index: linux.t/arch/sparc64/mm/hugetlbpage.c
===================================================================
--- linux.t.orig/arch/sparc64/mm/hugetlbpage.c	2004-01-09 01:59:45.000000000 -0500
+++ linux.t/arch/sparc64/mm/hugetlbpage.c	2004-03-15 15:20:31.337872330 -0500
@@ -29,7 +29,7 @@ static spinlock_t htlbpage_lock = SPIN_L
 
 static void enqueue_huge_page(struct page *page)
 {
-	list_add(&page->list,
+	list_add(&page->lru,
 		 &hugepage_freelists[page_zone(page)->zone_pgdat->node_id]);
 }
 
@@ -46,8 +46,8 @@ static struct page *dequeue_huge_page(vo
 	if (nid >= 0 && nid < MAX_NUMNODES &&
 	    !list_empty(&hugepage_freelists[nid])) {
 		page = list_entry(hugepage_freelists[nid].next,
-				  struct page, list);
-		list_del(&page->list);
+				  struct page, lru);
+		list_del(&page->lru);
 	}
 	return page;
 }
@@ -250,7 +250,7 @@ static void free_huge_page(struct page *
 	BUG_ON(page_count(page));
 	BUG_ON(page->mapping);
 
-	INIT_LIST_HEAD(&page->list);
+	INIT_LIST_HEAD(&page->lru);
 
 	spin_lock(&htlbpage_lock);
 	enqueue_huge_page(page);
@@ -384,19 +384,19 @@ static int try_to_free_low(int count)
 	/* all lowmem is on node 0 */
 	list_for_each(p, &hugepage_freelists[0]) {
 		if (map) {
-			list_del(&map->list);
+			list_del(&map->lru);
 			update_and_free_page(map);
 			htlbpagemem--;
 			map = NULL;
 			if (++count == 0)
 				break;
 		}
-		page = list_entry(p, struct page, list);
+		page = list_entry(p, struct page, lru);
 		if (!PageHighMem(page))
 			map = page;
 	}
 	if (map) {
-		list_del(&map->list);
+		list_del(&map->lru);
 		update_and_free_page(map);
 		htlbpagemem--;
 		count++;
