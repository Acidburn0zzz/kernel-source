# Date: Fri, 21 May 2004 16:45:35 +1000 (EST)
# From: Nathan Scott <nathans@snort.melbourne.sgi.com>
# Subject: PARTIAL TAKE 913919 - remove some dead code
# 
# Most of these noticed by Chris Wedgwood, few more of these
# little cleanups to come over time.
# 
# 
# Remove xfs_swappable code, its not useful on Linux.
# 
# Date:  Thu May 20 20:30:22 PDT 2004
# Workarea:  snort.melbourne.sgi.com:/home/nathans/ultra-clean-xfs-linux
# Inspected by:  hch@lst.de
# 
# The following file(s) were checked into:
#   bonnie.engr.sgi.com:/isms/xfs-kern/xfs-linux

cvs -d :pserver:cvs@oss.sgi.com:/cvs rdiff -u -r 1.396 -r 1.397 xfs-linux/xfs_inode.c
Index: linux-2.6.5/fs/xfs/xfs_bmap.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/xfs_bmap.c
+++ linux-2.6.5/fs/xfs/xfs_bmap.c
@@ -4077,64 +4077,6 @@ xfs_bmap_cancel(
 }
 
 /*
- * Returns EINVAL if the specified file is not swappable.
- */
-int						/* error */
-xfs_bmap_check_swappable(
-	xfs_inode_t	*ip)			/* incore inode */
-{
-	xfs_bmbt_rec_t	*base;			/* base of extent array */
-	xfs_bmbt_rec_t	*ep;			/* pointer to an extent entry */
-	xfs_fileoff_t	end_fsb;		/* last block of file within size */
-	xfs_bmbt_irec_t	ext;			/* extent list entry, decoded */
-	xfs_ifork_t	*ifp;			/* inode fork pointer */
-	xfs_fileoff_t	lastaddr;		/* last block number seen */
-	xfs_extnum_t	nextents;		/* number of extent entries */
-	int		retval = 0;		/* return value */
-
-	xfs_ilock(ip, XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL);
-
-	/*
-	 * Check for a zero length file.
-	 */
-	if (ip->i_d.di_size == 0)
-		goto check_done;
-
-	ASSERT(XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) == XFS_DINODE_FMT_BTREE ||
-	       XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) == XFS_DINODE_FMT_EXTENTS);
-
-	ifp = &ip->i_df;
-	if (!(ifp->if_flags & XFS_IFEXTENTS) &&
-	    (retval = xfs_iread_extents(NULL, ip, XFS_DATA_FORK)))
-		goto check_done;
-	/*
-	 * Scan extents until the file size is reached. Look for
-	 * holes or unwritten extents, since I/O to these would cause
-	 * a transaction.
-	 */
-	end_fsb = XFS_B_TO_FSB(ip->i_mount, ip->i_d.di_size);
-	nextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);
-	base = &ifp->if_u1.if_extents[0];
-	for (lastaddr = 0, ep = base; ep < &base[nextents]; ep++) {
-		xfs_bmbt_get_all(ep, &ext);
-		if (lastaddr < ext.br_startoff ||
-		    ext.br_state != XFS_EXT_NORM) {
-			goto error_done;
-		}
-		if (end_fsb <= (lastaddr = ext.br_startoff +
-						ext.br_blockcount))
-			goto check_done;
-	}
-error_done:
-	retval = XFS_ERROR(EINVAL);
-
-
-check_done:
-	xfs_iunlock(ip, XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL);
-	return retval;
-}
-
-/*
  * Returns the file-relative block number of the first unused block(s)
  * in the file with at least "len" logically contiguous blocks free.
  * This is the lowest-address hole if the file has holes, else the first block
Index: linux-2.6.5/fs/xfs/xfs_bmap.h
===================================================================
--- linux-2.6.5.orig/fs/xfs/xfs_bmap.h
+++ linux-2.6.5/fs/xfs/xfs_bmap.h
@@ -178,13 +178,6 @@ xfs_bmap_cancel(
 	xfs_bmap_free_t		*flist);	/* free list to clean up */
 
 /*
- * Routine to check if a specified inode is swap capable.
- */
-int
-xfs_bmap_check_swappable(
-	struct xfs_inode	*ip);		/* incore inode */
-
-/*
  * Compute and fill in the value of the maximum depth of a bmap btree
  * in this filesystem.  Done once, during mount.
  */
Index: linux-2.6.5/fs/xfs/xfs_inode.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/xfs_inode.c
+++ linux-2.6.5/fs/xfs/xfs_inode.c
@@ -3725,32 +3725,6 @@ xfs_iaccess(
 }
 
 /*
- * Return whether or not it is OK to swap to the given file in the
- * given range.  Return 0 for OK and otherwise return the error.
- *
- * It is only OK to swap to a file if it has no holes, and all
- * extents have been initialized.
- *
- * We use the vnode behavior chain prevent and allow primitives
- * to ensure that the vnode chain stays coherent while we do this.
- * This allows us to walk the chain down to the bottom where XFS
- * lives without worrying about it changing out from under us.
- */
-int
-xfs_swappable(
-	bhv_desc_t	*bdp)
-{
-	xfs_inode_t	*ip;
-
-	ip = XFS_BHVTOI(bdp);
-	/*
-	 * Verify that the file does not have any
-	 * holes or unwritten exents.
-	 */
-	return xfs_bmap_check_swappable(ip);
-}
-
-/*
  * xfs_iroundup: round up argument to next power of two
  */
 uint
Index: linux-2.6.5/fs/xfs/xfs_log.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/xfs_log.c
+++ linux-2.6.5/fs/xfs/xfs_log.c
@@ -1664,7 +1664,6 @@ xlog_write(xfs_mount_t *	mp,
     int		     copy_len;	     /* # bytes actually memcpy'ing */
     int		     copy_off;	     /* # bytes from entry start */
     int		     contwr;	     /* continued write of in-core log? */
-    int		     firstwr = 0;    /* first write of transaction */
     int		     error;
     int		     record_cnt = 0, data_cnt = 0;
 
@@ -1729,7 +1728,6 @@ xlog_write(xfs_mount_t *	mp,
 		logop_head->oh_flags    = XLOG_START_TRANS;
 		INT_ZERO(logop_head->oh_res2, ARCH_CONVERT);
 		ticket->t_flags		&= ~XLOG_TIC_INITED;	/* clear bit */
-		firstwr = 1;			  /* increment log ops below */
 		record_cnt++;
 
 		start_rec_copy = sizeof(xlog_op_header_t);
@@ -1800,7 +1798,6 @@ xlog_write(xfs_mount_t *	mp,
 	    copy_len += start_rec_copy + sizeof(xlog_op_header_t);
 	    record_cnt++;
 	    data_cnt += contwr ? copy_len : 0;
-	    firstwr = 0;
 	    if (partial_copy) {			/* copied partial region */
 		    /* already marked WANT_SYNC by xlog_state_get_iclog_space */
 		    xlog_state_finish_copy(log, iclog, record_cnt, data_cnt);
Index: linux-2.6.5/fs/xfs/xfs_trans_buf.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/xfs_trans_buf.c
+++ linux-2.6.5/fs/xfs/xfs_trans_buf.c
@@ -799,7 +799,6 @@ xfs_trans_log_buf(xfs_trans_t	*tp,
 	if (bip->bli_flags & XFS_BLI_STALE) {
 		xfs_buf_item_trace("BLOG UNSTALE", bip);
 		bip->bli_flags &= ~XFS_BLI_STALE;
-		/* note this will have to change for page_buf interface... unstale isn't really an option RMC */
 		ASSERT(XFS_BUF_ISSTALE(bp));
 		XFS_BUF_UNSTALE(bp);
 		bip->bli_format.blf_flags &= ~XFS_BLI_CANCEL;
