Subject: cciss broken with 2.6.22-rc2
Date:	Tue, 29 May 2007 15:36:06 -0000
From: "Miller, Mike (OS Dev)" <Mike.Miller@hp.com>

> with the latest git snapshot the cciss driver hangs during 
> initialisation. Enabling debug output I get:
> 
> cciss0: <0x3230> at PCI 0000:06:00.0 IRQ 4338 using DAC 
> Sending cff0000 - down to controller
> cciss:  FIFO Empty read
> cciss:  Read cff00000 back from board
> Sending cff0000 - down to controller
> cciss:  FIFO Empty read
> cciss:  Read cff00002 back from board
> LUN Data
> --------------------------
> Sending cff0000 - down to controller
> cciss:  FIFO Empty read
> cciss:  Read cff00000 back from board
>       blocks= 286677120 block_size= 512
> Sending cff0000 - down to controller
> cciss:  FIFO Empty read
> cciss:  Read cff00002 back from board
>       heads=255, sectors=32, cylinders=35132
> 
> Sending 5103000 - down to controller
> 
> and then the machine hangs.
> I'll try to investigate, but as I'm no expert in cciss my 
> results might be limited.
> Looks like one of your recent fixes broke it; 2.6.21 worked fine.

Hannes,
Actually, it was someone else who broke the driver by making changes
in msi.c. This patch fixes the hang:

From: "Mike Miller (OS Dev)" <mikem@beardog.cca.cpqcorp.net> writes:

Found what seems the problem with our vectors being listed
backward. In drivers/pci/msi.c we should be using list_add_tail rather
than list_add to preserve the ordering across various kernels. Please
consider this for inclusion. 

Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -333,7 +333,7 @@ static int msi_capability_init(struct pci_dev *dev)
 			msi_mask_bits_reg(pos, is_64bit_address(control)),
 			maskbits);
 	}
-	list_add(&entry->list, &dev->msi_list);
+	list_add_tail(&entry->list, &dev->msi_list);
 
 	/* Configure MSI capability structure */
 	ret = arch_setup_msi_irqs(dev, 1, PCI_CAP_ID_MSI);
@@ -404,7 +404,7 @@ static int msix_capability_init(struct pci_dev *dev,
 		entry->dev = dev;
 		entry->mask_base = base;
 
-		list_add(&entry->list, &dev->msi_list);
+		list_add_tail(&entry->list, &dev->msi_list);
 	}
 
 	ret = arch_setup_msi_irqs(dev, nvec, PCI_CAP_ID_MSIX);
@@ -558,12 +558,12 @@ static int msi_free_irqs(struct pci_dev* dev)
 
 	list_for_each_entry_safe(entry, tmp, &dev->msi_list, list) {
 		if (entry->msi_attrib.type == PCI_CAP_ID_MSIX) {
-			if (list_is_last(&entry->list, &dev->msi_list))
-				iounmap(entry->mask_base);
-
 			writel(1, entry->mask_base + entry->msi_attrib.entry_nr
 				  * PCI_MSIX_ENTRY_SIZE
 				  + PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET);
+
+			if (list_is_last(&entry->list, &dev->msi_list))
+				iounmap(entry->mask_base);
 		}
 		list_del(&entry->list);
 		kfree(entry);
