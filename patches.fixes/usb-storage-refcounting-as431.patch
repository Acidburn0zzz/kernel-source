Date: Mon, 29 Nov 2004 15:58:43 -0500 (EST)
From: Alan Stern <stern@rowland.harvard.edu>
To: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
cc: USB Storage list <usb-storage@lists.one-eyed-alien.net>
Subject: [usb-storage] [PATCH as431] Store us_data with the Scsi_Host structure

Matt:

This is the first of two patches paving the way towards adding autosuspend
to usb-storage.  This one changes the way our private struct us_data is
allocated; now it gets allocated along with the Scsi_Host rather than
separately.  That's what the hostdata field at the end of Scsi_Host is
intended for, and this is how other low-level host drivers operate.  In
order to convert between us_data and the corresponding Scsi_Host I added
two new inline routines: us_to_host and host_to_us.  (The conversion
actually should be quicker than before by a microscopic amount, because
now it only involves adding an offset whereas before it involved
derefencing a pointer.)

In itself that's not such a big deal.  The main advantage is that the host 
is refcounted, so now our us_data automatically is too.  Although that 
doesn't matter now, it will matter later on when the control thread may 
need to outlive the disconnect callback.

As a consequence of this change, usb.h has to include <scsi/scsi_host.h>.  
I took the opportunity to reorder all the #include lines in the source
files, so that they #include usb.h before any of the other private
headers.  In principle usb.h could be made to #include debug.h,
protocol.h, scsiglue.h, and transport.h, so that the source files wouldn't
need to #include those others explicitly.  That can be done later if you 
want.

I also added the IGNORE_RESIDUE flag into the Quirks section of the
proc_info file.  And I removed some redundant checks for NULL pointers
before calling kfree.

Alan Stern

https://lists.one-eyed-alien.net/pipermail/usb-storage/2004-November/001201.html
supposed to fix oopses like that:

2.6.11-rc3-bk5-200502100455-usbtest
usb 2-1: USB disconnect, address 4
Oops: kernel access of bad area, sig: 11 [#1]
NIP: CDD3E424 LR: CDD05398 SP: C9713F40 REGS: c9713e90 TRAP: 0300    Not tainted
MSR: 00009032 EE: 1 PR: 0 FP: 0 ME: 1 IR/DR: 11
DAR: 00000130, DSISR: 40000000
TASK = cae312c0[6674] 'scsi_eh_2' THREAD: c9712000
Last syscall: -1
GPR00: 00010718 C9713F40 CAE312C0 00000000 CDD146D0 00000001 00000000 00009032
GPR08: CAABF078 00000000 CB604800 C2801200 44088028 00000000 C07C67B8 00000004
GPR16: C07D8B9A C07D69D0 CDD30000 C9713F90 C03B286C C03433D8 C9713FA8 CDD30000
GPR24: CAABF078 00000000 C2801200 00000000 C9713FA0 CAABF078 FFFFFFF0 C1711600
NIP [cdd3e424] bus_reset+0x64/0x134 [usb_storage]
LR [cdd05398] scsi_try_bus_reset+0x8c/0x104 [scsi_mod]
Call trace:
 [cdd05398] scsi_try_bus_reset+0x8c/0x104 [scsi_mod]
 [cdd068c4] scsi_error_handler+0x86c/0xe68 [scsi_mod]
 [c0006c2c] kernel_thread+0x44/0x60



2.6.11-rc4-bk3-200502151447-usbtest

Feb 16 13:09:50 cowberry kernel: usb 2-1: USB disconnect, address 7
Feb 16 13:09:50 cowberry udev[6257]: removing device node '/dev/sg0'
Feb 16 13:09:50 cowberry kernel: Oops: kernel access of bad area, sig: 11 [#1]
Feb 16 13:09:50 cowberry kernel: NIP: C0011544 LR: C0042884 SP: C1BF5D20 REGS: c1bf5c70 TRAP: 0300    Not tainted
Feb 16 13:09:50 cowberry kernel: MSR: 00001032 EE: 0 PR: 0 FP: 0 ME: 1 IR/DR: 11
Feb 16 13:09:50 cowberry kernel: DAR: EF1F1E40, DSISR: 40000000
Feb 16 13:09:50 cowberry kernel: TASK = c1acb160[53] 'khubd' THREAD: c1bf4000 
Feb 16 13:09:50 cowberry kernel: Last syscall: 120
Feb 16 13:09:50 cowberry kernel: GPR00: 00000000 C1BF5D20 C1ACB160 CA032210 EF1F1E3C DAE403CC CA03220C 1B5C8079
Feb 16 13:09:50 cowberry kernel: GPR08: 00000000 FFFFFFFC CA42F070 CA032210 00020734 00000000 C07CF7B8 00000004
Feb 16 13:09:50 cowberry kernel: GPR16: C07DFB9A C07DD9D0 C0360000 C07DFB4C C07CF7B8 C07DD800 C07CF7A0 C07DD800
Feb 16 13:09:50 cowberry kernel: GPR24: 00000000 00000001 00000001 CA032200 CA032210 00000000 251BFC30 C946FF0C
Feb 16 13:09:50 cowberry kernel: NIP [c0011544] memcpy+0x1c/0x9c
Feb 16 13:09:50 cowberry kernel: LR [c0042884] cache_flusharray+0x74/0xdc
Feb 16 13:09:50 cowberry kernel: Call trace:
Feb 16 13:09:50 cowberry kernel:  [c00429f8] kmem_cache_free+0x68/0x84
Feb 16 13:09:50 cowberry kernel:  [cdcd8128] scsi_destroy_command_freelist+0x4c/0x10c [scsi_mod]
Feb 16 13:09:50 cowberry kernel:  [cdcd86e8] scsi_host_dev_release+0x84/0xc0 [scsi_mod]
Feb 16 13:09:50 cowberry kernel:  [c01ce37c] device_release+0x30/0x64
Feb 16 13:09:50 cowberry kernel:  [c01503e8] kobject_cleanup+0xc0/0xc4
Feb 16 13:09:50 cowberry kernel:  [c01514e0] kref_put+0x60/0x70
Feb 16 13:09:50 cowberry kernel:  [c0150318] kobject_put+0x24/0x34
Feb 16 13:09:50 cowberry kernel:  [c01ce644] put_device+0x1c/0x2c
Feb 16 13:09:50 cowberry kernel:  [cdcd8624] scsi_host_put+0x14/0x24 [scsi_mod]
Feb 16 13:09:50 cowberry kernel:  [cdd49384] usb_stor_release_resources+0xf4/0x144 [usb_storage]
Feb 16 13:09:50 cowberry kernel:  [cdd49480] storage_disconnect+0xac/0x110 [usb_storage]
Feb 16 13:09:50 cowberry kernel:  [c021add0] usb_unbind_interface+0x94/0xd4
Feb 16 13:09:50 cowberry kernel:  [c01cfdbc] device_release_driver+0x98/0x9c
Feb 16 13:09:50 cowberry kernel:  [c01cffb4] bus_remove_device+0xc0/0x12c
Feb 16 13:09:50 cowberry kernel:  [c01ce6f8] device_del+0xa4/0x114
Feb 16 13:09:50 cowberry udev[6265]: removing device node '/dev/sdb1'




Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Olaf Hering <olh@suse.de>

diff -u a/drivers/usb/storage/datafab.c b/drivers/usb/storage/datafab.c
--- a/drivers/usb/storage/datafab.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/datafab.c	Sun Nov 28 15:06:01 2004
@@ -57,9 +57,9 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 
+#include "usb.h"
 #include "transport.h"
 #include "protocol.h"
-#include "usb.h"
 #include "debug.h"
 #include "datafab.h"
 
diff -u a/drivers/usb/storage/dpcm.c b/drivers/usb/storage/dpcm.c
--- a/drivers/usb/storage/dpcm.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/dpcm.c	Sun Nov 28 15:06:01 2004
@@ -34,9 +34,9 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 
+#include "usb.h"
 #include "transport.h"
 #include "protocol.h"
-#include "usb.h"
 #include "debug.h"
 #include "dpcm.h"
 #include "sddr09.h"
diff -u a/drivers/usb/storage/freecom.c b/drivers/usb/storage/freecom.c
--- a/drivers/usb/storage/freecom.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/freecom.c	Sun Nov 28 15:06:01 2004
@@ -34,9 +34,9 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 
+#include "usb.h"
 #include "transport.h"
 #include "protocol.h"
-#include "usb.h"
 #include "debug.h"
 #include "freecom.h"
 
diff -u a/drivers/usb/storage/initializers.c b/drivers/usb/storage/initializers.c
--- a/drivers/usb/storage/initializers.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/initializers.c	Sun Nov 28 15:06:01 2004
@@ -39,6 +39,8 @@
 
 #include <linux/sched.h>
 #include <linux/errno.h>
+
+#include "usb.h"
 #include "initializers.h"
 #include "debug.h"
 #include "transport.h"
diff -u a/drivers/usb/storage/isd200.c b/drivers/usb/storage/isd200.c
--- a/drivers/usb/storage/isd200.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/isd200.c	Sun Nov 28 15:06:01 2004
@@ -54,9 +54,9 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 
+#include "usb.h"
 #include "transport.h"
 #include "protocol.h"
-#include "usb.h"
 #include "debug.h"
 #include "scsiglue.h"
 #include "isd200.h"
diff -u a/drivers/usb/storage/jumpshot.c b/drivers/usb/storage/jumpshot.c
--- a/drivers/usb/storage/jumpshot.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/jumpshot.c	Sun Nov 28 15:06:01 2004
@@ -54,9 +54,9 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 
+#include "usb.h"
 #include "transport.h"
 #include "protocol.h"
-#include "usb.h"
 #include "debug.h"
 #include "jumpshot.h"
 
diff -u a/drivers/usb/storage/protocol.c b/drivers/usb/storage/protocol.c
--- a/drivers/usb/storage/protocol.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/protocol.c	Sun Nov 28 15:06:01 2004
@@ -47,8 +47,9 @@
 #include <linux/highmem.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
-#include "protocol.h"
+
 #include "usb.h"
+#include "protocol.h"
 #include "debug.h"
 #include "scsiglue.h"
 #include "transport.h"
diff -u a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
--- a/drivers/usb/storage/scsiglue.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/scsiglue.c	Sun Nov 28 15:06:01 2004
@@ -53,10 +53,9 @@
 #include <scsi/scsi_devinfo.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_eh.h>
-#include <scsi/scsi_host.h>
 
-#include "scsiglue.h"
 #include "usb.h"
+#include "scsiglue.h"
 #include "debug.h"
 #include "transport.h"
 #include "protocol.h"
@@ -83,7 +82,7 @@
 
 static int slave_configure(struct scsi_device *sdev)
 {
-	struct us_data *us = (struct us_data *) sdev->host->hostdata[0];
+	struct us_data *us = host_to_us(sdev->host);
 
 	/* Scatter-gather buffers (all but the last) must have a length
 	 * divisible by the bulk maxpacket size.  Otherwise a data packet
@@ -167,10 +166,9 @@
 static int queuecommand(struct scsi_cmnd *srb,
 			void (*done)(struct scsi_cmnd *))
 {
-	struct us_data *us = (struct us_data *)srb->device->host->hostdata[0];
+	struct us_data *us = host_to_us(srb->device->host);
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
-	srb->host_scribble = (unsigned char *)us;
 
 	/* check for state-transition errors */
 	if (us->srb != NULL) {
@@ -201,10 +199,9 @@
 
 /* Command timeout and abort */
 /* This is always called with scsi_lock(srb->host) held */
-static int command_abort(struct scsi_cmnd *srb )
+static int command_abort(struct scsi_cmnd *srb)
 {
-	struct Scsi_Host *host = srb->device->host;
-	struct us_data *us = (struct us_data *) host->hostdata[0];
+	struct us_data *us = host_to_us(srb->device->host);
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
@@ -224,13 +221,13 @@
 		set_bit(US_FLIDX_ABORTING, &us->flags);
 		usb_stor_stop_transport(us);
 	}
-	scsi_unlock(host);
+	scsi_unlock(us_to_host(us));
 
 	/* Wait for the aborted command to finish */
 	wait_for_completion(&us->notify);
 
 	/* Reacquire the lock and allow USB transfers to resume */
-	scsi_lock(host);
+	scsi_lock(us_to_host(us));
 	clear_bit(US_FLIDX_ABORTING, &us->flags);
 	clear_bit(US_FLIDX_TIMED_OUT, &us->flags);
 	return SUCCESS;
@@ -241,12 +238,12 @@
 /* This is always called with scsi_lock(srb->host) held */
 static int device_reset(struct scsi_cmnd *srb)
 {
-	struct us_data *us = (struct us_data *)srb->device->host->hostdata[0];
+	struct us_data *us = host_to_us(srb->device->host);
 	int result;
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
-	scsi_unlock(srb->device->host);
+	scsi_unlock(us_to_host(us));
 
 	/* lock the device pointers and do the reset */
 	down(&(us->dev_semaphore));
@@ -258,7 +255,7 @@
 	up(&(us->dev_semaphore));
 
 	/* lock the host for the return */
-	scsi_lock(srb->device->host);
+	scsi_lock(us_to_host(us));
 	return result;
 }
 
@@ -268,12 +265,12 @@
 /* This is always called with scsi_lock(srb->host) held */
 static int bus_reset(struct scsi_cmnd *srb)
 {
-	struct us_data *us = (struct us_data *)srb->device->host->hostdata[0];
+	struct us_data *us = host_to_us(srb->device->host);
 	int result, rc;
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
-	scsi_unlock(srb->device->host);
+	scsi_unlock(us_to_host(us));
 
 	/* The USB subsystem doesn't handle synchronisation between
 	 * a device's several drivers. Therefore we reset only devices
@@ -301,7 +298,7 @@
 	up(&(us->dev_semaphore));
 
 	/* lock the host for the return */
-	scsi_lock(srb->device->host);
+	scsi_lock(us_to_host(us));
 	return result < 0 ? FAILED : SUCCESS;
 }
 
@@ -311,11 +308,12 @@
 void usb_stor_report_device_reset(struct us_data *us)
 {
 	int i;
+	struct Scsi_Host *host = us_to_host(us);
 
-	scsi_report_device_reset(us->host, 0, 0);
+	scsi_report_device_reset(host, 0, 0);
 	if (us->flags & US_FL_SCM_MULT_TARG) {
-		for (i = 1; i < us->host->max_id; ++i)
-			scsi_report_device_reset(us->host, 0, i);
+		for (i = 1; i < host->max_id; ++i)
+			scsi_report_device_reset(host, 0, i);
 	}
 }
 
@@ -330,20 +328,18 @@
 #define DO_FLAG(a) \
 	do { if (us->flags & US_FL_##a) pos += sprintf(pos, " " #a); } while(0)
 
-static int proc_info (struct Scsi_Host *hostptr, char *buffer, char **start, off_t offset,
-		int length, int inout)
+static int proc_info (struct Scsi_Host *host, char *buffer,
+		char **start, off_t offset, int length, int inout)
 {
-	struct us_data *us;
+	struct us_data *us = host_to_us(host);
 	char *pos = buffer;
 
 	/* if someone is sending us data, just throw it away */
 	if (inout)
 		return length;
 
-	us = (struct us_data*)hostptr->hostdata[0];
-
 	/* print the controller name */
-	SPRINTF("   Host scsi%d: usb-storage\n", hostptr->host_no);
+	SPRINTF("   Host scsi%d: usb-storage\n", host->host_no);
 
 	/* print product, vendor, and serial number strings */
 	SPRINTF("       Vendor: %s\n", us->vendor);
@@ -362,6 +358,7 @@
 		DO_FLAG(SCM_MULT_TARG);
 		DO_FLAG(FIX_INQUIRY);
 		DO_FLAG(FIX_CAPACITY);
+		DO_FLAG(IGNORE_RESIDUE);
 
 		*(pos++) = '\n';
 	}
diff -u a/drivers/usb/storage/scsiglue.h b/drivers/usb/storage/scsiglue.h
--- a/drivers/usb/storage/scsiglue.h	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/scsiglue.h	Sun Nov 28 15:06:01 2004
@@ -41,10 +41,8 @@
 #ifndef _SCSIGLUE_H_
 #define _SCSIGLUE_H_
 
-#include <scsi/scsi_host.h>
-
 struct us_data;
-struct scsi_cmnd;
+struct scsi_host_template;
 
 extern void usb_stor_report_device_reset(struct us_data *us);
 
diff -u a/drivers/usb/storage/sddr09.c b/drivers/usb/storage/sddr09.c
--- a/drivers/usb/storage/sddr09.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/sddr09.c	Sun Nov 28 15:06:01 2004
@@ -48,9 +48,9 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 
+#include "usb.h"
 #include "transport.h"
 #include "protocol.h"
-#include "usb.h"
 #include "debug.h"
 #include "sddr09.h"
 
diff -u a/drivers/usb/storage/sddr55.c b/drivers/usb/storage/sddr55.c
--- a/drivers/usb/storage/sddr55.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/sddr55.c	Sun Nov 28 15:06:01 2004
@@ -31,9 +31,9 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 
+#include "usb.h"
 #include "transport.h"
 #include "protocol.h"
-#include "usb.h"
 #include "debug.h"
 #include "sddr55.h"
 
diff -u a/drivers/usb/storage/shuttle_usbat.c b/drivers/usb/storage/shuttle_usbat.c
--- a/drivers/usb/storage/shuttle_usbat.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/shuttle_usbat.c	Sun Nov 28 15:06:01 2004
@@ -47,9 +47,9 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 
+#include "usb.h"
 #include "transport.h"
 #include "protocol.h"
-#include "usb.h"
 #include "debug.h"
 #include "shuttle_usbat.h"
 
diff -u a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
--- a/drivers/usb/storage/transport.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/transport.c	Sun Nov 28 15:06:01 2004
@@ -54,10 +54,10 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 
+#include "usb.h"
 #include "transport.h"
 #include "protocol.h"
 #include "scsiglue.h"
-#include "usb.h"
 #include "debug.h"
 
 
@@ -1118,11 +1118,11 @@
 	 * RESETTING bit, and clear the ABORTING bit so that the reset
 	 * may proceed.
 	 */
-	scsi_lock(us->host);
+	scsi_lock(us_to_host(us));
 	usb_stor_report_device_reset(us);
 	set_bit(US_FLIDX_RESETTING, &us->flags);
 	clear_bit(US_FLIDX_ABORTING, &us->flags);
-	scsi_unlock(us->host);
+	scsi_unlock(us_to_host(us));
 
 	/* A 20-second timeout may seem rather long, but a LaCie
 	 * StudioDrive USB2 device takes 16+ seconds to get going
diff -u a/drivers/usb/storage/transport.h b/drivers/usb/storage/transport.h
--- a/drivers/usb/storage/transport.h	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/transport.h	Sun Nov 28 15:06:01 2004
@@ -43,8 +43,8 @@
 
 #include <linux/config.h>
 #include <linux/blkdev.h>
-#include "usb.h"
 
+struct us_data;
 struct scsi_cmnd;
 
 /* Protocols */
diff -u a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
--- a/drivers/usb/storage/usb.c	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/usb.c	Sun Nov 28 15:06:01 2004
@@ -51,6 +51,9 @@
 #include <linux/sched.h>
 #include <linux/errno.h>
 #include <linux/suspend.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
@@ -89,10 +92,6 @@
 #endif
 
 
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-
 /* Some informational data */
 MODULE_AUTHOR("Matthew Dharm <mdharm-usb@one-eyed-alien.net>");
 MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
@@ -281,7 +280,7 @@
 static int usb_stor_control_thread(void * __us)
 {
 	struct us_data *us = (struct us_data *)__us;
-	struct Scsi_Host *host = us->host;
+	struct Scsi_Host *host = us_to_host(us);
 
 	lock_kernel();
 
@@ -783,20 +782,6 @@
 
 	up(&us->dev_semaphore);
 
-	/*
-	 * Since this is a new device, we need to register a SCSI
-	 * host definition with the higher SCSI layers.
-	 */
-	us->host = scsi_host_alloc(&usb_stor_host_template, sizeof(us));
-	if (!us->host) {
-		printk(KERN_WARNING USB_STORAGE
-			"Unable to allocate the scsi host\n");
-		return -EBUSY;
-	}
-
-	/* Set the hostdata to prepare for scanning */
-	us->host->hostdata[0] = (unsigned long) us;
-
 	/* Start up our control thread */
 	p = kernel_thread(usb_stor_control_thread, us, CLONE_VM);
 	if (p < 0) {
@@ -836,9 +821,9 @@
 		 * Enqueue the command, wake up the thread, and wait for 
 		 * notification that it has exited.
 		 */
-		scsi_lock(us->host);
+		scsi_lock(us_to_host(us));
 		us->srb = NULL;
-		scsi_unlock(us->host);
+		scsi_unlock(us_to_host(us));
 		up(&us->dev_semaphore);
 
 		up(&us->sema);
@@ -851,15 +836,9 @@
 		us->extra_destructor(us->extra);
 	}
 
-	/* Finish the host removal sequence */
-	if (us->host)
-		scsi_host_put(us->host);
-
 	/* Free the extra data and the URB */
-	if (us->extra)
-		kfree(us->extra);
-	if (us->current_urb)
-		usb_free_urb(us->current_urb);
+	kfree(us->extra);
+	usb_free_urb(us->current_urb);
 
 }
 
@@ -878,9 +857,6 @@
 
 	/* Remove our private data from the interface */
 	usb_set_intfdata(us->pusb_intf, NULL);
-
-	/* Free the structure itself */
-	kfree(us);
 }
 
 /* Thread to carry out delayed SCSI-device scanning */
@@ -915,7 +891,7 @@
 
 	/* If the device is still connected, perform the scanning */
 	if (!test_bit(US_FLIDX_DISCONNECTING, &us->flags)) {
-		scsi_scan_host(us->host);
+		scsi_scan_host(us_to_host(us));
 		printk(KERN_DEBUG "usb-storage: device scan complete\n");
 	}
 
@@ -927,18 +903,25 @@
 static int storage_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id)
 {
+	struct Scsi_Host *host;
 	struct us_data *us;
 	const int id_index = id - storage_usb_ids; 
 	int result;
 
 	US_DEBUGP("USB Mass Storage device detected\n");
 
-	/* Allocate the us_data structure and initialize the mutexes */
-	us = (struct us_data *) kmalloc(sizeof(*us), GFP_KERNEL);
-	if (!us) {
-		printk(KERN_WARNING USB_STORAGE "Out of memory\n");
+	/*
+	 * Ask the SCSI layer to allocate a host structure, with extra
+	 * space at the end for our private us_data structure.
+	 */
+	host = scsi_host_alloc(&usb_stor_host_template, sizeof(*us));
+	if (!host) {
+		printk(KERN_WARNING USB_STORAGE
+			"Unable to allocate the scsi host\n");
 		return -ENOMEM;
 	}
+
+	us = host_to_us(host);
 	memset(us, 0, sizeof(struct us_data));
 	init_MUTEX(&(us->dev_semaphore));
 	init_MUTEX_LOCKED(&(us->sema));
@@ -998,7 +981,7 @@
 	result = usb_stor_acquire_resources(us);
 	if (result)
 		goto BadDevice;
-	result = scsi_add_host(us->host, &intf->dev);
+	result = scsi_add_host(host, &intf->dev);
 	if (result) {
 		printk(KERN_WARNING USB_STORAGE
 			"Unable to add the scsi host\n");
@@ -1010,7 +993,7 @@
 	if (result < 0) {
 		printk(KERN_WARNING USB_STORAGE 
 		       "Unable to start the device-scanning thread\n");
-		scsi_remove_host(us->host);
+		scsi_remove_host(host);
 		goto BadDevice;
 	}
 
@@ -1021,6 +1004,7 @@
 	US_DEBUGP("storage_probe() failed\n");
 	usb_stor_release_resources(us);
 	dissociate_dev(us);
+	scsi_host_put(host);
 	return result;
 }
 
@@ -1045,11 +1029,15 @@
 	/* Wait for the current command to finish, then remove the host */
 	down(&us->dev_semaphore);
 	up(&us->dev_semaphore);
-	scsi_remove_host(us->host);
+	scsi_remove_host(us_to_host(us));
 
 	/* Wait for everything to become idle and release all our resources */
 	usb_stor_release_resources(us);
 	dissociate_dev(us);
+
+	/* Drop our reference to the host; the SCSI core will free it
+	 * (and "us" along with it) when the refcount becomes 0. */
+	scsi_host_put(us_to_host(us));
 }
 
 /***********************************************************************
diff -u a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
--- a/drivers/usb/storage/usb.h	Sun Nov 28 11:32:42 2004
+++ b/drivers/usb/storage/usb.h	Sun Nov 28 15:06:01 2004
@@ -48,6 +48,7 @@
 #include <linux/blkdev.h>
 #include <linux/smp_lock.h>
 #include <linux/completion.h>
+#include <scsi/scsi_host.h>
 
 struct us_data;
 struct scsi_cmnd;
@@ -138,7 +139,6 @@
 	proto_cmnd		proto_handler;	 /* protocol handler	   */
 
 	/* SCSI interfaces */
-	struct Scsi_Host	*host;		 /* our dummy host data */
 	struct scsi_cmnd	*srb;		 /* current srb		*/
 
 	/* thread information */
@@ -163,6 +163,14 @@
 	void			*extra;		 /* Any extra data          */
 	extra_data_destructor	extra_destructor;/* extra data destructor   */
 };
+
+/* Convert between us_data and the corresponding Scsi_Host */
+static struct Scsi_Host inline *us_to_host(struct us_data *us) {
+	return container_of((void *) us, struct Scsi_Host, hostdata);
+}
+static struct us_data inline *host_to_us(struct Scsi_Host *host) {
+	return (struct us_data *) host->hostdata;
+}
 
 /* The structure which defines our driver */
 extern struct usb_driver usb_storage_driver;

