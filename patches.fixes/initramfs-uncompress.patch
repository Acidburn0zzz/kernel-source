
 <viro>  olh: what happens does happen when the end of final header is well-aligned
 <viro>  olh: cpio does pad the sucker otherwise and that's enough to mask the bug in do_skip()
 <viro>  olh: if the end of header is on a multiple of 512, as it is in your case, it _is_ the last thing gunzip shoves into window
 <viro>  olh: and there's nothing past it
 <viro>  olh: fix is trivial - in do_skip() replace <= with <

diff -purNX /tmp/kernel_exclude.txt linux-2.6.7-rc1.orig/init/initramfs.c linux-2.6.7-rc1/init/initramfs.c
--- linux-2.6.7-rc1.orig/init/initramfs.c	2004-05-10 02:31:59.000000000 +0000
+++ linux-2.6.7-rc1/init/initramfs.c	2004-05-23 17:44:45.000000000 +0000
@@ -207,7 +207,7 @@ static int __init do_header(void)
 
 static int __init do_skip(void)
 {
-	if (this_header + count <= next_header) {
+	if (this_header + count < next_header) {
 		eat(count);
 		return 1;
 	} else {
