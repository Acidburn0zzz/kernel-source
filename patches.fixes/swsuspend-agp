diff -urNp linux-2.6.5/arch/i386/mm/init.c linux-2.6.5.SUSE/arch/i386/mm/init.c
--- linux-2.6.5/arch/i386/mm/init.c	2004-04-04 05:37:39.000000000 +0200
+++ linux-2.6.5.SUSE/arch/i386/mm/init.c	2004-04-30 14:55:12.000000000 +0200
@@ -331,6 +331,13 @@ static void __init pagetable_init (void)
 void zap_low_mappings (void)
 {
 	int i;
+
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	{
+		extern char swsusp_pg_dir[PAGE_SIZE];
+		memcpy(swsusp_pg_dir, swapper_pg_dir, PAGE_SIZE);
+	}
+#endif
 	/*
 	 * Zap initial low-memory mappings.
 	 *
diff -urNp linux-2.6.5/arch/i386/power/cpu.c linux-2.6.5.SUSE/arch/i386/power/cpu.c
--- linux-2.6.5/arch/i386/power/cpu.c	2004-04-04 05:37:41.000000000 +0200
+++ linux-2.6.5.SUSE/arch/i386/power/cpu.c	2004-04-30 14:55:12.000000000 +0200
@@ -35,6 +35,10 @@ unsigned long saved_context_esp, saved_c
 unsigned long saved_context_esi, saved_context_edi;
 unsigned long saved_context_eflags;
 
+/* Special page directory for resume */
+char __nosavedata swsusp_pg_dir[PAGE_SIZE]
+                  __attribute__ ((aligned (PAGE_SIZE)));
+
 extern void enable_sep_cpu(void *);
 
 void save_processor_state(void)
diff -urNp linux-2.6.5/arch/i386/power/swsusp.S linux-2.6.5.SUSE/arch/i386/power/swsusp.S
--- linux-2.6.5/arch/i386/power/swsusp.S	2004-04-04 05:36:56.000000000 +0200
+++ linux-2.6.5.SUSE/arch/i386/power/swsusp.S	2004-04-30 14:55:12.000000000 +0200
@@ -29,7 +29,7 @@ ENTRY(do_magic)
 	jmp .L1449
 	.p2align 4,,7
 .L1450:
-	movl $swapper_pg_dir-__PAGE_OFFSET,%ecx
+	movl $swsusp_pg_dir-__PAGE_OFFSET,%ecx
 	movl %ecx,%cr3
 
 	call do_magic_resume_1
diff -urNp linux-2.6.5/include/asm-i386/suspend.h linux-2.6.5.SUSE/include/asm-i386/suspend.h
--- linux-2.6.5/include/asm-i386/suspend.h	2004-04-04 05:37:59.000000000 +0200
+++ linux-2.6.5.SUSE/include/asm-i386/suspend.h	2004-04-30 14:55:12.000000000 +0200
@@ -9,6 +9,9 @@
 static inline int
 arch_prepare_suspend(void)
 {
+	/* If you want to make non-PSE machine work, turn off paging
+           in do_magic. swsusp_pg_dir should have identity mapping, so
+           it could work...  */
 	if (!cpu_has_pse)
 		return -EPERM;
 	return 0;
diff -urNp linux-2.6.5/kernel/power/swsusp.c linux-2.6.5.SUSE/kernel/power/swsusp.c
--- linux-2.6.5/kernel/power/swsusp.c	2004-04-30 14:52:50.000000000 +0200
+++ linux-2.6.5.SUSE/kernel/power/swsusp.c	2004-04-30 14:55:15.000000000 +0200
@@ -577,23 +577,22 @@ static int suspend_prepare_image(void)
 		printk(KERN_CRIT "%sCouldn't get enough free pages, on %d pages short\n",
 		       name_suspend, nr_needed_pages-nr_free_pages());
 		root_swap = 0xFFFF;
-		return 1;
+		return -ENOMEM;
 	}
 	si_swapinfo(&i);	/* FIXME: si_swapinfo(&i) returns all swap devices information.
 				   We should only consider resume_device. */
 	if (i.freeswap < nr_needed_pages)  {
 		printk(KERN_CRIT "%sThere's not enough swap space available, on %ld pages short\n",
 		       name_suspend, nr_needed_pages-i.freeswap);
-		return 1;
+		return -ENOSPC;
 	}
 
 	PRINTK( "Alloc pagedir\n" ); 
 	pagedir_save = pagedir_nosave = create_suspend_pagedir(nr_copy_pages);
-	if(!pagedir_nosave) {
-		/* Shouldn't happen */
-		printk(KERN_CRIT "%sCouldn't allocate enough pages\n",name_suspend);
-		panic("Really should not happen");
-		return 1;
+	if (!pagedir_nosave) {
+		/* Pagedir is big, one-chunk allocation. It is easily possible for this allocation to fail */
+		printk(KERN_CRIT "%sCouldn't allocate continuous pagedir\n", name_suspend);
+		return -ENOMEM;
 	}
 	nr_copy_pages_check = nr_copy_pages;
 	pagedir_order_check = pagedir_order;
