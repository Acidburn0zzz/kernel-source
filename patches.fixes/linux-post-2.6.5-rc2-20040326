diff -purN linux-post-2.6.5-rc2-20040323/Documentation/DMA-API.txt linux-post-2.6.5-rc2-20040326/Documentation/DMA-API.txt
--- linux-post-2.6.5-rc2-20040323/Documentation/DMA-API.txt	2004-03-19 05:59:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/Documentation/DMA-API.txt	2004-03-23 18:12:38.000000000 +0000
@@ -279,14 +279,14 @@ recommended that you never use these unl
 cache width is.
 
 int
-dma_error(dma_addr_t dma_addr)
+dma_mapping_error(dma_addr_t dma_addr)
 
 int
-pci_dma_error(dma_addr_t dma_addr)
+pci_dma_mapping_error(dma_addr_t dma_addr)
 
 In some circumstances dma_map_single and dma_map_page will fail to create
 a mapping. A driver can check for these errors by testing the returned
-dma address with dma_error(). A non zero return value means the mapping
+dma address with dma_mapping_error(). A non zero return value means the mapping
 could not be created and the driver should take appropriate action (eg
 reduce current DMA mapping usage or delay and try again later).
 
diff -purN linux-post-2.6.5-rc2-20040323/Documentation/DMA-mapping.txt linux-post-2.6.5-rc2-20040326/Documentation/DMA-mapping.txt
--- linux-post-2.6.5-rc2-20040323/Documentation/DMA-mapping.txt	2004-03-19 05:59:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/Documentation/DMA-mapping.txt	2004-03-23 18:12:38.000000000 +0000
@@ -850,12 +850,12 @@ failure can be determined by:
 - checking if pci_alloc_consistent returns NULL or pci_map_sg returns 0
 
 - checking the returned dma_addr_t of pci_map_single and pci_map_page
-  by using pci_dma_error():
+  by using pci_dma_mapping_error():
 
 	dma_addr_t dma_handle;
 
 	dma_handle = pci_map_single(dev, addr, size, direction);
-	if (pci_dma_error(dma_handle)) {
+	if (pci_dma_mapping_error(dma_handle)) {
 		/*
 		 * reduce current DMA mapping usage,
 		 * delay and try again later or
diff -purN linux-post-2.6.5-rc2-20040323/Documentation/kernel-parameters.txt linux-post-2.6.5-rc2-20040326/Documentation/kernel-parameters.txt
--- linux-post-2.6.5-rc2-20040323/Documentation/kernel-parameters.txt	2004-03-16 16:07:14.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/Documentation/kernel-parameters.txt	2004-03-22 21:03:22.000000000 +0000
@@ -103,10 +103,8 @@ running once the system is up.
 			Format: { s3_bios, s3_mode }
 			See Documentation/power/video.txt
  
-	acpi_pic_sci=	[HW,ACPI] ACPI System Control Interrupt trigger mode
-			Format: { level | edge }
-			level   Force PIC-mode SCI to Level Trigger (default)
-			edge    Force PIC-mode SCI to Edge Trigge
+	acpi_sci=	[HW,ACPI] ACPI System Control Interrupt trigger mode
+			Format: { level | edge |  high | low }
 
 	acpi_irq_balance	[HW,ACPI] ACPI will balance active IRQs
 				default in APIC mode
diff -purN linux-post-2.6.5-rc2-20040323/Documentation/sh/new-machine.txt linux-post-2.6.5-rc2-20040326/Documentation/sh/new-machine.txt
--- linux-post-2.6.5-rc2-20040323/Documentation/sh/new-machine.txt	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/Documentation/sh/new-machine.txt	2004-03-23 10:05:26.000000000 +0000
@@ -288,22 +288,22 @@ for reference instead of trying to guess
 used on it.
 
 Also, as soon as you have copied over a sample .config for your new board
-(assume arch/sh/configs/defconfig-vapor), you can also use this directly as a
+(assume arch/sh/configs/vapor_defconfig), you can also use this directly as a
 build target, and it will be implicitly listed as such in the help text.
 
 Looking at the 'make help' output, you should now see something like:
 
 Architecture specific targets (sh):
   zImage                  - Compressed kernel image (arch/sh/boot/zImage)
-  defconfig-adx           - Build for adx
-  defconfig-cqreek        - Build for cqreek
-  defconfig-dreamcast     - Build for dreamcast
+  adx_defconfig           - Build for adx
+  cqreek_defconfig        - Build for cqreek
+  dreamcast_defconfig     - Build for dreamcast
 ...
-  defconfig-vapor         - Build for vapor
+  vapor_defconfig         - Build for vapor
 
 which then allows you to do:
 
-$ make ARCH=sh CROSS_COMPILE=sh4-linux- defconfig-vapor vmlinux
+$ make ARCH=sh CROSS_COMPILE=sh4-linux- vapor_defconfig vmlinux
 
 which will in turn copy the defconfig for this board, run it through
 oldconfig (prompting you for any new options since the time of creation),
diff -purN linux-post-2.6.5-rc2-20040323/arch/i386/Kconfig linux-post-2.6.5-rc2-20040326/arch/i386/Kconfig
--- linux-post-2.6.5-rc2-20040323/arch/i386/Kconfig	2004-03-19 06:04:56.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/i386/Kconfig	2004-03-23 10:05:27.000000000 +0000
@@ -819,7 +819,7 @@ config IRQBALANCE
 	depends on SMP && X86_IO_APIC
 	default y
 	help
- 	  The defalut yes will allow the kernel to do irq load balancing.
+ 	  The default yes will allow the kernel to do irq load balancing.
 	  Saying no will keep the kernel from doing irq load balancing.
 
 config HAVE_DEC_LOCK
diff -purN linux-post-2.6.5-rc2-20040323/arch/i386/kernel/acpi/boot.c linux-post-2.6.5-rc2-20040326/arch/i386/kernel/acpi/boot.c
--- linux-post-2.6.5-rc2-20040323/arch/i386/kernel/acpi/boot.c	2004-03-11 04:58:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/i386/kernel/acpi/boot.c	2004-03-23 06:32:11.000000000 +0000
@@ -35,11 +35,21 @@
 #include <asm/irq.h>
 #include <asm/mpspec.h>
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#ifdef	CONFIG_X86_64
+
+static inline void  acpi_madt_oem_check(char *oem_id, char *oem_table_id) { }
+static inline void clustered_apic_check(void) { }
+static inline int ioapic_setup_disabled(void) { return 0; }
+#include <asm/proto.h>
+
+#else	/* X86 */
+
+#ifdef	CONFIG_X86_LOCAL_APIC
 #include <mach_apic.h>
 #include <mach_mpparse.h>
-#include <asm/io_apic.h>
-#endif
+#endif	/* CONFIG_X86_LOCAL_APIC */
+
+#endif	/* X86 */
 
 #define PREFIX			"ACPI: "
 
@@ -50,6 +60,9 @@ int acpi_lapic;
 int acpi_ioapic;
 int acpi_strict;
 
+acpi_interrupt_flags acpi_sci_flags __initdata;
+int acpi_sci_override_gsi __initdata;
+
 #ifdef CONFIG_X86_LOCAL_APIC
 static u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;
 #endif
@@ -64,6 +77,22 @@ static u64 acpi_lapic_addr __initdata = 
  */
 enum acpi_irq_model_id		acpi_irq_model = ACPI_IRQ_MODEL_PIC;
 
+#ifdef	CONFIG_X86_64
+
+/* rely on all ACPI tables being in the direct mapping */
+char *__acpi_map_table(unsigned long phys_addr, unsigned long size)
+{
+	if (!phys_addr || !size)
+	return NULL;
+
+	if (phys_addr < (end_pfn_map << PAGE_SHIFT))
+		return __va(phys_addr);
+
+	return NULL;
+}
+
+#else
+
 /*
  * Temporarily use the virtual area starting from FIX_IO_APIC_BASE_END,
  * to map the target physical address. The problem is that set_fixmap()
@@ -103,7 +132,7 @@ char *__acpi_map_table(unsigned long phy
 
 	return ((unsigned char *) base + offset);
 }
-
+#endif
 
 #ifdef CONFIG_PCI_MMCONFIG
 static int __init acpi_parse_mcfg(unsigned long phys_addr, unsigned long size)
@@ -244,6 +273,34 @@ acpi_parse_ioapic (
 	return 0;
 }
 
+/*
+ * Parse Interrupt Source Override for the ACPI SCI
+ */
+static void
+acpi_parse_sci_int_src_ovr(u8 bus_irq, u16 polarity, u16 trigger, u32 global_irq)
+{
+	if (trigger == 0)	/* compatible SCI trigger is level */
+		trigger = 3;
+
+	if (polarity == 0)	/* compatible SCI polarity is low */
+		polarity = 3;
+
+	/* Command-line over-ride via acpi_sci= */
+	if (acpi_sci_flags.trigger)
+		trigger = acpi_sci_flags.trigger;
+
+	if (acpi_sci_flags.polarity)
+		polarity = acpi_sci_flags.polarity;
+
+	mp_override_legacy_irq(bus_irq, polarity, trigger, global_irq);
+
+	/*
+	 * stash over-ride to indicate we've been here
+	 * and for later update of acpi_fadt
+	 */
+	acpi_sci_override_gsi = global_irq;
+	return;
+}
 
 static int __init
 acpi_parse_int_src_ovr (
@@ -257,6 +314,13 @@ acpi_parse_int_src_ovr (
 
 	acpi_table_print_madt_entry(header);
 
+	if (intsrc->bus_irq == acpi_fadt.sci_int) {
+		acpi_parse_sci_int_src_ovr(intsrc->bus_irq,
+			intsrc->flags.polarity, intsrc->flags.trigger,
+			intsrc->global_irq);
+		return 0;
+	}
+
 	mp_override_legacy_irq (
 		intsrc->bus_irq,
 		intsrc->flags.polarity,
@@ -287,14 +351,14 @@ acpi_parse_nmi_src (
 #endif /* CONFIG_X86_IO_APIC */
 
 #ifdef	CONFIG_ACPI_BUS
+
 /*
- * "acpi_pic_sci=level" (current default)
- * programs the PIC-mode SCI to Level Trigger.
- * (NO-OP if the BIOS set Level Trigger already)
+ * acpi_pic_sci_set_trigger()
+ * 
+ * use ELCR to set PIC-mode trigger type for SCI
  *
  * If a PIC-mode SCI is not recognized or gives spurious IRQ7's
- * it may require Edge Trigger -- use "acpi_pic_sci=edge"
- * (NO-OP if the BIOS set Edge Trigger already)
+ * it may require Edge Trigger -- use "acpi_sci=edge"
  *
  * Port 0x4d0-4d1 are ECLR1 and ECLR2, the Edge/Level Control Registers
  * for the 8259 PIC.  bit[n] = 1 means irq[n] is Level, otherwise Edge.
@@ -302,10 +366,8 @@ acpi_parse_nmi_src (
  * ECLR2 is IRQ's 8-15 (IRQ 8, 13 must be 0)
  */
 
-static int __initdata	acpi_pic_sci_trigger;	/* 0: level, 1: edge */
-
 void __init
-acpi_pic_sci_set_trigger(unsigned int irq)
+acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger)
 {
 	unsigned char mask = 1 << (irq & 7);
 	unsigned int port = 0x4d0 + (irq >> 3);
@@ -316,41 +378,26 @@ acpi_pic_sci_set_trigger(unsigned int ir
 	if (!(val & mask)) {
 		printk(" Edge");
 
-		if (!acpi_pic_sci_trigger) {
+		if (trigger == 3) {
 			printk(" set to Level");
 			outb(val | mask, port);
 		}
 	} else {
 		printk(" Level");
 
-		if (acpi_pic_sci_trigger) {
+		if (trigger == 1) {
 			printk(" set to Edge");
-			outb(val | mask, port);
+			outb(val & ~mask, port);
 		}
 	}
 	printk(" Trigger.\n");
 }
 
-int __init
-acpi_pic_sci_setup(char *str)
-{
-	while (str && *str) {
-		if (strncmp(str, "level", 5) == 0)
-			acpi_pic_sci_trigger = 0;	/* force level trigger */
-		if (strncmp(str, "edge", 4) == 0)
-			acpi_pic_sci_trigger = 1;	/* force edge trigger */
-		str = strchr(str, ',');
-		if (str)
-			str += strspn(str, ", \t");
-	}
-	return 1;
-}
-
-__setup("acpi_pic_sci=", acpi_pic_sci_setup);
 
 #endif /* CONFIG_ACPI_BUS */
 
 #ifdef CONFIG_X86_IO_APIC
+/* deprecated in favor of acpi_gsi_to_irq */
 int acpi_irq_to_vector(u32 irq)
 {
 	if (use_pci_vector() && !platform_legacy_irq(irq))
@@ -359,6 +406,17 @@ int acpi_irq_to_vector(u32 irq)
 }
 #endif
 
+int acpi_gsi_to_irq(u32 gsi, unsigned int *irq)
+{
+#ifdef CONFIG_X86_IO_APIC
+	if (use_pci_vector() && !platform_legacy_irq(gsi))
+ 		*irq = IO_APIC_VECTOR(gsi);
+	else
+#endif
+		*irq = gsi;
+	return 0;
+}
+
 static unsigned long __init
 acpi_scan_rsdp (
 	unsigned long		start,
@@ -400,7 +458,6 @@ static int __init acpi_parse_sbf(unsigne
 
 
 #ifdef CONFIG_HPET_TIMER
-extern unsigned long hpet_address;
 
 static int __init acpi_parse_hpet(unsigned long phys, unsigned long size)
 {
@@ -421,18 +478,31 @@ static int __init acpi_parse_hpet(unsign
 		return -1;
 	}
 
-	hpet_address = hpet_tbl->addr.addrl;
-	printk(KERN_INFO PREFIX "HPET id: %#x base: %#lx\n", hpet_tbl->id,
-	       hpet_address);
+#ifdef	CONFIG_X86_64
+        vxtime.hpet_address = hpet_tbl->addr.addrl |
+                ((long) hpet_tbl->addr.addrh << 32);
+
+        printk(KERN_INFO PREFIX "HPET id: %#x base: %#lx\n",
+               hpet_tbl->id, vxtime.hpet_address);
+#else	/* X86 */
+	{
+		extern unsigned long hpet_address;
+
+		hpet_address = hpet_tbl->addr.addrl;
+		printk(KERN_INFO PREFIX "HPET id: %#x base: %#lx\n",
+			hpet_tbl->id, hpet_address);
+	}
+#endif	/* X86 */
+
 	return 0;
 }
 #else
 #define	acpi_parse_hpet	NULL
 #endif
 
-/* detect the location of the ACPI PM Timer */
 #ifdef CONFIG_X86_PM_TIMER
 extern u32 pmtmr_ioport;
+#endif
 
 static int __init acpi_parse_fadt(unsigned long phys, unsigned long size)
 {
@@ -444,6 +514,13 @@ static int __init acpi_parse_fadt(unsign
 		return 0;
 	}
 
+#ifdef	CONFIG_ACPI_INTERPRETER
+	/* initialize sci_int early for INT_SRC_OVR MADT parsing */
+	acpi_fadt.sci_int = fadt->sci_int;
+#endif
+
+#ifdef CONFIG_X86_PM_TIMER
+	/* detect the location of the ACPI PM Timer */
 	if (fadt->revision >= FADT2_REVISION_ID) {
 		/* FADT rev. 2 */
 		if (fadt->xpm_tmr_blk.address_space_id != ACPI_ADR_SPACE_SYSTEM_IO)
@@ -456,11 +533,9 @@ static int __init acpi_parse_fadt(unsign
 	}
 	if (pmtmr_ioport)
 		printk(KERN_INFO PREFIX "PM-Timer IO Port: %#x\n", pmtmr_ioport);
+#endif
 	return 0;
 }
-#else
-#define	acpi_parse_fadt	NULL
-#endif
 
 
 unsigned long __init
@@ -554,7 +629,7 @@ acpi_parse_madt_ioapic_entries(void)
 	/*
  	 * if "noapic" boot option, don't look for IO-APICs
 	 */
-	if (ioapic_setup_disabled()) {
+	if (skip_ioapic_setup) {
 		printk(KERN_INFO PREFIX "Skipping IOAPIC probe "
 			"due to 'noapic' option.\n");
 		return -ENODEV;
@@ -580,6 +655,13 @@ acpi_parse_madt_ioapic_entries(void)
 		return count;
 	}
 
+	/*
+	 * If BIOS did not supply an INT_SRC_OVR for the SCI
+	 * pretend we got one so we can set the SCI flags.
+	 */
+	if (!acpi_sci_override_gsi)
+		acpi_parse_sci_int_src_ovr(acpi_fadt.sci_int, 0, 0, acpi_fadt.sci_int);
+
 	count = acpi_table_parse_madt(ACPI_MADT_NMI_SRC, acpi_parse_nmi_src, NR_IRQ_VECTORS);
 	if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing NMI SRC entry\n");
@@ -668,7 +750,7 @@ acpi_boot_init (void)
 	 */
 	error = acpi_table_init();
 	if (error) {
-		acpi_disabled = 1;
+		disable_acpi();
 		return error;
 	}
 
@@ -680,16 +762,20 @@ acpi_boot_init (void)
 	error = acpi_blacklisted();
 	if (error) {
 		printk(KERN_WARNING PREFIX "BIOS listed in blacklist, disabling ACPI support\n");
-		acpi_disabled = 1;
+		disable_acpi();
 		return error;
 	}
 
 	/*
+	 * set sci_int and PM timer address
+	 */
+	acpi_table_parse(ACPI_FADT, acpi_parse_fadt);
+
+	/*
 	 * Process the Multiple APIC Description Table (MADT), if present
 	 */
 	acpi_process_madt();
 
-	acpi_table_parse(ACPI_FADT, acpi_parse_fadt);
 	acpi_table_parse(ACPI_HPET, acpi_parse_hpet);
 	acpi_table_parse(ACPI_MCFG, acpi_parse_mcfg);
 
diff -purN linux-post-2.6.5-rc2-20040323/arch/i386/kernel/dmi_scan.c linux-post-2.6.5-rc2-20040326/arch/i386/kernel/dmi_scan.c
--- linux-post-2.6.5-rc2-20040323/arch/i386/kernel/dmi_scan.c	2004-03-16 10:29:43.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/i386/kernel/dmi_scan.c	2004-03-21 05:33:07.000000000 +0000
@@ -523,13 +523,13 @@ static __init int print_if_true(struct d
 
 
 #ifdef	CONFIG_ACPI_BOOT
-extern int acpi_disabled, acpi_force;
+extern int acpi_force;
 
-static __init __attribute__((unused)) int disable_acpi(struct dmi_blacklist *d)
+static __init __attribute__((unused)) int dmi_disable_acpi(struct dmi_blacklist *d) 
 { 
 	if (!acpi_force) { 
 		printk(KERN_NOTICE "%s detected: acpi off\n",d->ident); 
-		acpi_disabled = 1;
+		disable_acpi();
 	} else { 
 		printk(KERN_NOTICE 
 		       "Warning: DMI blacklist says broken, but acpi forced\n"); 
@@ -537,8 +537,6 @@ static __init __attribute__((unused)) in
 	return 0;
 } 
 
-extern int acpi_ht;
-
 /*
  * Limit ACPI to CPU enumeration for HT
  */
@@ -546,7 +544,7 @@ static __init __attribute__((unused)) in
 { 
 	if (!acpi_force) { 
 		printk(KERN_NOTICE "%s detected: force use of acpi=ht\n", d->ident); 
-		acpi_disabled = 1; 
+		disable_acpi();
 		acpi_ht = 1; 
 	} else { 
 		printk(KERN_NOTICE 
@@ -933,7 +931,7 @@ static __initdata struct dmi_blacklist d
 	 *	Boxes that need ACPI disabled
 	 */
 
-	{ disable_acpi, "IBM Thinkpad", {
+	{ dmi_disable_acpi, "IBM Thinkpad", {
 			MATCH(DMI_BOARD_VENDOR, "IBM"),
 			MATCH(DMI_BOARD_NAME, "2629H1G"),
 			NO_MATCH, NO_MATCH }},
@@ -1063,8 +1061,7 @@ static __init void dmi_check_blacklist(v
 			if (disable && !acpi_force) { 
 				printk(KERN_NOTICE "ACPI disabled because your bios is from %s and too old\n", s);
 				printk(KERN_NOTICE "You can enable it with acpi=force\n");
-				acpi_disabled = 1; 
-				acpi_ht = 0;
+				disable_acpi();
 			} 
 		}
 	}
diff -purN linux-post-2.6.5-rc2-20040323/arch/i386/kernel/mpparse.c linux-post-2.6.5-rc2-20040326/arch/i386/kernel/mpparse.c
--- linux-post-2.6.5-rc2-20040323/arch/i386/kernel/mpparse.c	2004-02-26 05:11:46.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/i386/kernel/mpparse.c	2004-03-22 21:00:03.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *	Intel Multiprocessor Specificiation 1.1 and 1.4
+ *	Intel Multiprocessor Specification 1.1 and 1.4
  *	compliant MP-table parsing routines.
  *
  *	(c) 1995 Alan Cox, Building #3 <alan@redhat.com>
@@ -37,6 +37,7 @@
 
 /* Have we found an MP table */
 int smp_found_config;
+unsigned int __initdata maxcpus = NR_CPUS;
 
 /*
  * Various Linux-internal data structures created from the
@@ -168,8 +169,14 @@ void __init MP_processor_info (struct mp
 	}
 
 	if (num_processors >= NR_CPUS) {
-		printk(KERN_WARNING "NR_CPUS limit of %i reached.  Cannot "
-			"boot CPU(apicid 0x%x).\n", NR_CPUS, m->mpc_apicid);
+		printk(KERN_WARNING "WARNING: NR_CPUS limit of %i reached."
+			"  Processor ignored.\n", NR_CPUS); 
+		return;
+	}
+
+	if (num_processors >= maxcpus) {
+		printk(KERN_WARNING "WARNING: maxcpus limit of %i reached."
+			" Processor ignored.\n", maxcpus); 
 		return;
 	}
 	num_processors++;
@@ -844,25 +851,25 @@ void __init mp_register_lapic (
 
 struct mp_ioapic_routing {
 	int			apic_id;
-	int			irq_start;
-	int			irq_end;
+	int			gsi_base;
+	int			gsi_end;
 	u32			pin_programmed[4];
 } mp_ioapic_routing[MAX_IO_APICS];
 
 
 static int __init mp_find_ioapic (
-	int			irq)
+	int			gsi)
 {
 	int			i = 0;
 
-	/* Find the IOAPIC that manages this IRQ. */
+	/* Find the IOAPIC that manages this GSI. */
 	for (i = 0; i < nr_ioapics; i++) {
-		if ((irq >= mp_ioapic_routing[i].irq_start)
-			&& (irq <= mp_ioapic_routing[i].irq_end))
+		if ((gsi >= mp_ioapic_routing[i].gsi_base)
+			&& (gsi <= mp_ioapic_routing[i].gsi_end))
 			return i;
 	}
 
-	printk(KERN_ERR "ERROR: Unable to locate IOAPIC for IRQ %d\n", irq);
+	printk(KERN_ERR "ERROR: Unable to locate IOAPIC for GSI %d\n", gsi);
 
 	return -1;
 }
@@ -871,7 +878,7 @@ static int __init mp_find_ioapic (
 void __init mp_register_ioapic (
 	u8			id, 
 	u32			address,
-	u32			irq_base)
+	u32			gsi_base)
 {
 	int			idx = 0;
 
@@ -897,19 +904,19 @@ void __init mp_register_ioapic (
 	mp_ioapics[idx].mpc_apicver = io_apic_get_version(idx);
 	
 	/* 
-	 * Build basic IRQ lookup table to facilitate irq->io_apic lookups
-	 * and to prevent reprogramming of IOAPIC pins (PCI IRQs).
+	 * Build basic GSI lookup table to facilitate gsi->io_apic lookups
+	 * and to prevent reprogramming of IOAPIC pins (PCI GSIs).
 	 */
 	mp_ioapic_routing[idx].apic_id = mp_ioapics[idx].mpc_apicid;
-	mp_ioapic_routing[idx].irq_start = irq_base;
-	mp_ioapic_routing[idx].irq_end = irq_base + 
+	mp_ioapic_routing[idx].gsi_base = gsi_base;
+	mp_ioapic_routing[idx].gsi_end = gsi_base + 
 		io_apic_get_redir_entries(idx);
 
 	printk("IOAPIC[%d]: apic_id %d, version %d, address 0x%lx, "
-		"IRQ %d-%d\n", idx, mp_ioapics[idx].mpc_apicid, 
+		"GSI %d-%d\n", idx, mp_ioapics[idx].mpc_apicid, 
 		mp_ioapics[idx].mpc_apicver, mp_ioapics[idx].mpc_apicaddr,
-		mp_ioapic_routing[idx].irq_start,
-		mp_ioapic_routing[idx].irq_end);
+		mp_ioapic_routing[idx].gsi_base,
+		mp_ioapic_routing[idx].gsi_end);
 
 	return;
 }
@@ -919,7 +926,7 @@ void __init mp_override_legacy_irq (
 	u8			bus_irq,
 	u8			polarity, 
 	u8			trigger, 
-	u32			global_irq)
+	u32			gsi)
 {
 	struct mpc_config_intsrc intsrc;
 	int			i = 0;
@@ -928,12 +935,12 @@ void __init mp_override_legacy_irq (
 	int			pin = -1;
 
 	/* 
-	 * Convert 'global_irq' to 'ioapic.pin'.
+	 * Convert 'gsi' to 'ioapic.pin'.
 	 */
-	ioapic = mp_find_ioapic(global_irq);
+	ioapic = mp_find_ioapic(gsi);
 	if (ioapic < 0)
 		return;
-	pin = global_irq - mp_ioapic_routing[ioapic].irq_start;
+	pin = gsi - mp_ioapic_routing[ioapic].gsi_base;
 
 	/*
 	 * TBD: This check is for faulty timer entries, where the override
@@ -958,7 +965,7 @@ void __init mp_override_legacy_irq (
 
 	/* 
 	 * If an existing [IOAPIC.PIN -> IRQ] routing entry exists we override it.
-	 * Otherwise create a new entry (e.g. global_irq == 2).
+	 * Otherwise create a new entry (e.g. gsi == 2).
 	 */
 	for (i = 0; i < mp_irq_entries; i++) {
 		if ((mp_irqs[i].mpc_srcbus == intsrc.mpc_srcbus) 
@@ -1029,69 +1036,6 @@ void __init mp_config_acpi_legacy_irqs (
 
 extern FADT_DESCRIPTOR acpi_fadt;
 
-void __init mp_config_ioapic_for_sci(int irq)
-{
-	int ioapic;
-	int ioapic_pin;
-	struct acpi_table_madt *madt;
-	struct acpi_table_int_src_ovr *entry = NULL;
-	acpi_interrupt_flags flags;
-	void *madt_end;
-	acpi_status status;
-
-	/*
-	 * Ensure that if there is an interrupt source override entry
-	 * for the ACPI SCI, we leave it as is. Unfortunately this involves
-	 * walking the MADT again.
-	 */
-	status = acpi_get_firmware_table("APIC", 1, ACPI_LOGICAL_ADDRESSING,
-		(struct acpi_table_header **) &madt);
-	if (ACPI_SUCCESS(status)) {
-		madt_end = (void *) (unsigned long)madt + madt->header.length;
-
-		entry = (struct acpi_table_int_src_ovr *)
-                ((unsigned long) madt + sizeof(struct acpi_table_madt));
-
-		while ((void *) entry < madt_end) {
-                	if (entry->header.type == ACPI_MADT_INT_SRC_OVR &&
-			    acpi_fadt.sci_int == entry->bus_irq)
-				goto found;
-			
-                	entry = (struct acpi_table_int_src_ovr *)
-                	        ((unsigned long) entry + entry->header.length);
-        	}
-	}
-	/*
-	 * Although the ACPI spec says that the SCI should be level/low
-	 * don't reprogram it unless there is an explicit MADT OVR entry
-	 * instructing us to do so -- otherwise we break Tyan boards which
-	 * have the SCI wired edge/high but no MADT OVR.
-	 */
-	return;
-
-found:
-	/*
-	 * See the note at the end of ACPI 2.0b section
-	 * 5.2.10.8 for what this is about.
-	 */
-	flags = entry->flags;
-	acpi_fadt.sci_int = entry->global_irq;
-	irq = entry->global_irq;
-
-	ioapic = mp_find_ioapic(irq);
-
-	ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
-
-	/*
-	 * MPS INTI flags:
-	 *  trigger: 0=default, 1=edge, 3=level
-	 *  polarity: 0=default, 1=high, 3=low
-	 * Per ACPI spec, default for SCI means level/low.
-	 */
-	io_apic_set_pci_routing(ioapic, ioapic_pin, irq, 
-		(flags.trigger == 1 ? 0 : 1), (flags.polarity == 1 ? 0 : 1));
-}
-
 #ifdef CONFIG_ACPI_PCI
 
 void __init mp_parse_prt (void)
@@ -1100,7 +1044,7 @@ void __init mp_parse_prt (void)
 	struct acpi_prt_entry	*entry = NULL;
 	int			ioapic = -1;
 	int			ioapic_pin = 0;
-	int			irq = 0;
+	int			gsi = 0;
 	int			idx, bit = 0;
 	int			edge_level = 0;
 	int			active_high_low = 0;
@@ -1112,39 +1056,39 @@ void __init mp_parse_prt (void)
 	list_for_each(node, &acpi_prt.entries) {
 		entry = list_entry(node, struct acpi_prt_entry, node);
 
-		/* Need to get irq for dynamic entry */
+		/* Need to get gsi for dynamic entry */
 		if (entry->link.handle) {
-			irq = acpi_pci_link_get_irq(entry->link.handle, entry->link.index, &edge_level, &active_high_low);
-			if (!irq)
+			gsi = acpi_pci_link_get_irq(entry->link.handle, entry->link.index, &edge_level, &active_high_low);
+			if (!gsi)
 				continue;
 		}
 		else {
-			/* Hardwired IRQ. Assume PCI standard settings */
-			irq = entry->link.index;
+			/* Hardwired GSI. Assume PCI standard settings */
+			gsi = entry->link.index;
 			edge_level = 1;
 			active_high_low = 1;
 		}
 
 		/* Don't set up the ACPI SCI because it's already set up */
-                if (acpi_fadt.sci_int == irq) {
-			irq = acpi_irq_to_vector(irq);
-			entry->irq = irq; /* we still need to set entry's irq */
+                if (acpi_fadt.sci_int == gsi) {
+			/* we still need to set entry's irq */
+			acpi_gsi_to_irq(gsi, &entry->irq);
 			continue;
                 }
 	
-		ioapic = mp_find_ioapic(irq);
+		ioapic = mp_find_ioapic(gsi);
 		if (ioapic < 0)
 			continue;
-		ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
+		ioapic_pin = gsi - mp_ioapic_routing[ioapic].gsi_base;
 
 		if (es7000_plat) {
-			if (!ioapic && (irq < 16))
-				irq += 16;
+			if (!ioapic && (gsi < 16))
+				gsi += 16;
 		}
 
 		/* 
 		 * Avoid pin reprogramming.  PRTs typically include entries  
-		 * with redundant pin->irq mappings (but unique PCI devices);
+		 * with redundant pin->gsi mappings (but unique PCI devices);
 		 * we only only program the IOAPIC on the first.
 		 */
 		bit = ioapic_pin % 32;
@@ -1158,19 +1102,19 @@ void __init mp_parse_prt (void)
 		if ((1<<bit) & mp_ioapic_routing[ioapic].pin_programmed[idx]) {
 			Dprintk(KERN_DEBUG "Pin %d-%d already programmed\n",
 				mp_ioapic_routing[ioapic].apic_id, ioapic_pin);
- 			entry->irq = acpi_irq_to_vector(irq);
+			acpi_gsi_to_irq(gsi, &entry->irq);
 			continue;
 		}
 
 		mp_ioapic_routing[ioapic].pin_programmed[idx] |= (1<<bit);
 
-		if (!io_apic_set_pci_routing(ioapic, ioapic_pin, irq, edge_level, active_high_low)) {
- 			entry->irq = acpi_irq_to_vector(irq);
- 		}
+		if (!io_apic_set_pci_routing(ioapic, ioapic_pin, gsi, edge_level, active_high_low)) {
+			acpi_gsi_to_irq(gsi, &entry->irq);
+		}
 		printk(KERN_DEBUG "%02x:%02x:%02x[%c] -> %d-%d -> IRQ %d\n",
-			entry->id.segment, entry->id.bus, 
-			entry->id.device, ('A' + entry->pin), 
-			mp_ioapic_routing[ioapic].apic_id, ioapic_pin, 
+			entry->id.segment, entry->id.bus,
+			entry->id.device, ('A' + entry->pin),
+			mp_ioapic_routing[ioapic].apic_id, ioapic_pin,
 			entry->irq);
 	}
 
diff -purN linux-post-2.6.5-rc2-20040323/arch/i386/kernel/setup.c linux-post-2.6.5-rc2-20040326/arch/i386/kernel/setup.c
--- linux-post-2.6.5-rc2-20040323/arch/i386/kernel/setup.c	2004-03-19 06:04:55.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/i386/kernel/setup.c	2004-03-22 21:03:22.000000000 +0000
@@ -83,8 +83,8 @@ EXPORT_SYMBOL_GPL(mmu_cr4_features);
 EXPORT_SYMBOL(acpi_disabled);
 
 #ifdef	CONFIG_ACPI_BOOT
-extern int __initdata acpi_ht;
 int __initdata acpi_force = 0;
+extern acpi_interrupt_flags	acpi_sci_flags;
 #endif
 
 int MCA_bus;
@@ -560,17 +560,28 @@ static void __init parse_cmdline_early (
 			}
 		}
 
+#ifdef  CONFIG_SMP
+		/*
+		 * If the BIOS enumerates physical processors before logical,
+		 * maxcpus=N at enumeration-time can be used to disable HT.
+		 */
+		else if (!memcmp(from, "maxcpus=", 8)) {
+			extern unsigned int maxcpus;
+
+			maxcpus = simple_strtoul(from + 8, NULL, 0);
+		}
+#endif
+
 #ifdef CONFIG_ACPI_BOOT
 		/* "acpi=off" disables both ACPI table parsing and interpreter */
 		else if (!memcmp(from, "acpi=off", 8)) {
-			acpi_ht = 0;
-			acpi_disabled = 1;
+			disable_acpi();
 		}
 
 		/* acpi=force to over-ride black-list */
 		else if (!memcmp(from, "acpi=force", 10)) {
 			acpi_force = 1;
-			acpi_ht=1;
+			acpi_ht = 1;
 			acpi_disabled = 0;
 		}
 
@@ -581,8 +592,9 @@ static void __init parse_cmdline_early (
 
 		/* Limit ACPI just to boot-time to enable HT */
 		else if (!memcmp(from, "acpi=ht", 7)) {
+			if (!acpi_force)
+				disable_acpi();
 			acpi_ht = 1;
-			if (!acpi_force) acpi_disabled = 1;
 		}
 
 		/* "pci=noacpi" disables ACPI interrupt routing */
@@ -590,6 +602,18 @@ static void __init parse_cmdline_early (
 			acpi_noirq_set();
 		}
 
+		else if (!memcmp(from, "acpi_sci=edge", 13))
+			acpi_sci_flags.trigger =  1;
+
+		else if (!memcmp(from, "acpi_sci=level", 14))
+			acpi_sci_flags.trigger = 3;
+
+		else if (!memcmp(from, "acpi_sci=high", 13))
+			acpi_sci_flags.polarity = 1;
+
+		else if (!memcmp(from, "acpi_sci=low", 12))
+			acpi_sci_flags.polarity = 3;
+
 #ifdef CONFIG_X86_LOCAL_APIC
 		/* disable IO-APIC */
 		else if (!memcmp(from, "noapic", 6))
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/Kconfig linux-post-2.6.5-rc2-20040326/arch/ia64/Kconfig
--- linux-post-2.6.5-rc2-20040323/arch/ia64/Kconfig	2004-03-16 06:39:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/Kconfig	2004-03-19 21:15:35.000000000 +0000
@@ -214,15 +214,6 @@ config FORCE_MAX_ZONEORDER
 	int
 	default "18"
 
-config IA64_PAL_IDLE
-	bool "Use PAL_HALT_LIGHT in idle loop"
-	help
-	  Say Y here to enable use of PAL_HALT_LIGHT in the cpu_idle loop.
-	  This allows the CPU to enter a low power state when idle.  You
-	  can enable CONFIG_IA64_PALINFO and check /proc/pal/cpu0/power_info
-	  to see the power consumption and latency for this state.  If you're
-	  unsure your firmware supports it, answer N.
-
 config SMP
 	bool "Symmetric multi-processing support"
 	help
@@ -344,47 +335,6 @@ config ACPI
 	bool
 	depends on !IA64_HP_SIM
 	default y
-	help
-	  ACPI/OSPM support for Linux is currently under development. As such,
-	  this support is preliminary and EXPERIMENTAL.  Configuring ACPI
-	  support enables kernel interfaces that allow higher level software
-	  (OSPM) to manipulate ACPI defined hardware and software interfaces,
-	  including the evaluation of ACPI control methods.  If unsure, choose
-	  N here.  Note, this option will enlarge your kernel by about 120K.
-
-	  This support requires an ACPI compliant platform (hardware/firmware).
-	  If both ACPI and Advanced Power Management (APM) support are
-	  configured, whichever is loaded first shall be used.
-
-	  This code DOES NOT currently provide a complete OSPM implementation
-	  -- it has not yet reached APM's level of functionality.  When fully
-	  implemented, Linux ACPI/OSPM will provide a more robust functional
-	  replacement for legacy configuration and power management
-	  interfaces, including the Plug-and-Play BIOS specification (PnP
-	  BIOS), the Multi-Processor Specification (MPS), and the Advanced
-	  Power Management specification (APM).
-
-	  Linux support for ACPI/OSPM is based on Intel Corporation's ACPI
-	  Component Architecture (ACPI CA). The latest ACPI CA source code,
-	  documentation, debug builds, and implementation status information
-	  can be downloaded from:
-	  <http://developer.intel.com/technology/iapc/acpi/downloads.htm>.
-
-	  The ACPI Sourceforge project may also be of interest:
-	  <http://sf.net/projects/acpi/>
-
-config ACPI_INTERPRETER
-	bool
-	depends on !IA64_HP_SIM
-	default y
-
-config ACPI_KERNEL_CONFIG
-	bool
-	depends on !IA64_HP_SIM
-	default y
-	help
-	  If you say `Y' here, Linux's ACPI support will use the
-	  hardware-level system descriptions found on IA-64 systems.
 
 if !IA64_HP_SIM
 
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/hp/common/sba_iommu.c linux-post-2.6.5-rc2-20040326/arch/ia64/hp/common/sba_iommu.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/hp/common/sba_iommu.c	2004-03-15 14:51:33.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/hp/common/sba_iommu.c	2004-03-22 10:52:38.000000000 +0000
@@ -1678,6 +1678,7 @@ struct ioc_iommu {
 
 static struct ioc_iommu ioc_iommu_info[] __initdata = {
 	{ ZX1_IOC_ID, "zx1", ioc_zx1_init },
+	{ SX1000_IOC_ID, "sx1000", NULL },
 };
 
 static struct ioc * __init
@@ -1979,6 +1980,12 @@ sba_dma_supported (struct device *dev, u
 	return ((mask & 0xFFFFFFFFUL) == 0xFFFFFFFFUL);
 }
 
+int
+sba_dma_mapping_error (dma_addr_t dma_addr)
+{
+	return 0;
+}
+
 __setup("nosbagart", nosbagart);
 
 static int __init
@@ -2004,6 +2011,7 @@ sba_page_override(char *str)
 
 __setup("sbapagesize=",sba_page_override);
 
+EXPORT_SYMBOL(sba_dma_mapping_error);
 EXPORT_SYMBOL(sba_map_single);
 EXPORT_SYMBOL(sba_unmap_single);
 EXPORT_SYMBOL(sba_map_sg);
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/acpi.c linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/acpi.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/acpi.c	2004-03-12 12:32:11.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/acpi.c	2004-03-21 05:28:40.000000000 +0000
@@ -62,8 +62,6 @@ void (*pm_power_off) (void);
 unsigned char acpi_kbd_controller_present = 1;
 unsigned char acpi_legacy_devices;
 
-int acpi_disabled;	/* XXX this shouldn't be needed---we can't boot without ACPI! */
-
 const char *
 acpi_get_sysname (void)
 {
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/gate.S linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/gate.S
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/gate.S	2003-11-26 23:03:18.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/gate.S	2004-03-18 18:11:02.000000000 +0000
@@ -234,7 +234,7 @@ back_from_setup_rbs:
 	br.call.sptk.many rp=b6			// call the signal handler
 .ret0:	adds base0=(BSP_OFF+SIGCONTEXT_OFF),sp
 	;;
-	ld8 r15=[base0],(CFM_OFF-BSP_OFF)	// fetch sc_ar_bsp and advance to CFM_OFF
+	ld8 r15=[base0]				// fetch sc_ar_bsp
 	mov r14=ar.bsp
 	;;
 	cmp.ne p1,p0=r14,r15			// do we need to restore the rbs?
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/machvec.c linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/machvec.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/machvec.c	2004-01-05 15:44:04.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/machvec.c	2004-03-18 05:57:15.000000000 +0000
@@ -50,8 +50,27 @@ machvec_noop (void)
 EXPORT_SYMBOL(machvec_noop);
 
 void
-machvec_memory_fence (void)
+machvec_setup (char **arg)
+{
+}
+EXPORT_SYMBOL(machvec_setup);
+
+void
+machvec_timer_interrupt (int irq, void *dev_id, struct pt_regs *regs)
+{
+}
+EXPORT_SYMBOL(machvec_timer_interrupt);
+
+void
+machvec_dma_sync_single (struct device *hwdev, dma_addr_t dma_handle, size_t size, int dir)
+{
+	mb();
+}
+EXPORT_SYMBOL(machvec_dma_sync_single);
+
+void
+machvec_dma_sync_sg (struct device *hwdev, struct scatterlist *sg, int n, int dir)
 {
 	mb();
 }
-EXPORT_SYMBOL(machvec_memory_fence);
+EXPORT_SYMBOL(machvec_dma_sync_sg);
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/process.c linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/process.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/process.c	2004-03-02 20:51:40.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/process.c	2004-03-25 19:54:44.000000000 +0000
@@ -159,16 +159,25 @@ do_notify_resume_user (sigset_t *oldset,
 		ia64_do_signal(oldset, scr, in_syscall);
 }
 
+static int pal_halt = 1;
+static int __init nohalt_setup(char * str)
+{
+	pal_halt = 0;
+	return 1;
+}
+__setup("nohalt", nohalt_setup);
+
 /*
  * We use this if we don't have any better idle routine..
  */
 void
 default_idle (void)
 {
-#ifdef CONFIG_IA64_PAL_IDLE
-	if (!need_resched())
-		safe_halt();
-#endif
+	unsigned long pmu_active = ia64_getreg(_IA64_REG_PSR) & (IA64_PSR_PP | IA64_PSR_UP);
+
+	while (!need_resched())
+		if (pal_halt && !pmu_active)
+			safe_halt();
 }
 
 void __attribute__((noreturn))
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/setup.c linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/setup.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/setup.c	2004-03-15 14:20:19.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/setup.c	2004-03-17 12:46:59.000000000 +0000
@@ -229,6 +229,38 @@ find_initrd (void)
 #endif
 }
 
+static void __init
+io_port_init (void)
+{
+	extern unsigned long ia64_iobase;
+	unsigned long phys_iobase;
+
+	/*
+	 *  Set `iobase' to the appropriate address in region 6 (uncached access range).
+	 *
+	 *  The EFI memory map is the "preferred" location to get the I/O port space base,
+	 *  rather the relying on AR.KR0. This should become more clear in future SAL
+	 *  specs. We'll fall back to getting it out of AR.KR0 if no appropriate entry is
+	 *  found in the memory map.
+	 */
+	phys_iobase = efi_get_iobase();
+	if (phys_iobase)
+		/* set AR.KR0 since this is all we use it for anyway */
+		ia64_set_kr(IA64_KR_IO_BASE, phys_iobase);
+	else {
+		phys_iobase = ia64_get_kr(IA64_KR_IO_BASE);
+		printk(KERN_INFO "No I/O port range found in EFI memory map, falling back "
+		       "to AR.KR0\n");
+		printk(KERN_INFO "I/O port base = 0x%lx\n", phys_iobase);
+	}
+	ia64_iobase = (unsigned long) ioremap(phys_iobase, 0);
+
+	/* setup legacy IO port space */
+	io_space[0].mmio_base = ia64_iobase;
+	io_space[0].sparse = 1;
+	num_io_spaces = 1;
+}
+
 #ifdef CONFIG_SERIAL_8250_CONSOLE
 static void __init
 setup_serial_legacy (void)
@@ -251,9 +283,6 @@ setup_serial_legacy (void)
 void __init
 setup_arch (char **cmdline_p)
 {
-	extern unsigned long ia64_iobase;
-	unsigned long phys_iobase;
-
 	unw_init();
 
 	ia64_patch_vtop((u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist);
@@ -262,6 +291,11 @@ setup_arch (char **cmdline_p)
 	strlcpy(saved_command_line, *cmdline_p, sizeof(saved_command_line));
 
 	efi_init();
+	io_port_init();
+
+#ifdef CONFIG_IA64_GENERIC
+	machvec_init(acpi_get_sysname());
+#endif
 
 #ifdef CONFIG_ACPI_BOOT
 	/* Initialize the ACPI boot-time table parser */
@@ -280,35 +314,6 @@ setup_arch (char **cmdline_p)
 	/* process SAL system table: */
 	ia64_sal_init(efi.sal_systab);
 
-#ifdef CONFIG_IA64_GENERIC
-	machvec_init(acpi_get_sysname());
-#endif
-
-	/*
-	 *  Set `iobase' to the appropriate address in region 6 (uncached access range).
-	 *
-	 *  The EFI memory map is the "preferred" location to get the I/O port space base,
-	 *  rather the relying on AR.KR0. This should become more clear in future SAL
-	 *  specs. We'll fall back to getting it out of AR.KR0 if no appropriate entry is
-	 *  found in the memory map.
-	 */
-	phys_iobase = efi_get_iobase();
-	if (phys_iobase)
-		/* set AR.KR0 since this is all we use it for anyway */
-		ia64_set_kr(IA64_KR_IO_BASE, phys_iobase);
-	else {
-		phys_iobase = ia64_get_kr(IA64_KR_IO_BASE);
-		printk(KERN_INFO "No I/O port range found in EFI memory map, falling back "
-		       "to AR.KR0\n");
-		printk(KERN_INFO "I/O port base = 0x%lx\n", phys_iobase);
-	}
-	ia64_iobase = (unsigned long) ioremap(phys_iobase, 0);
-
-	/* setup legacy IO port space */
-	io_space[0].mmio_base = ia64_iobase;
-	io_space[0].sparse = 1;
-	num_io_spaces = 1;
-
 #ifdef CONFIG_SMP
 	cpu_physical_id(0) = hard_smp_processor_id();
 #endif
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/smp.c linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/smp.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/smp.c	2004-02-13 00:54:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/smp.c	2004-03-25 19:53:03.000000000 +0000
@@ -91,9 +91,6 @@ handle_IPI (int irq, void *dev_id, struc
 	unsigned long *pending_ipis = &__ia64_per_cpu_var(ipi_operation);
 	unsigned long ops;
 
-	/* Count this now; we may make a call that never returns. */
-	local_cpu_data->ipi_count++;
-
 	mb();	/* Order interrupt and bit testing. */
 	while ((ops = xchg(pending_ipis, 0)) != 0) {
 		mb();	/* Order bit clearing and data access. */
@@ -338,17 +335,6 @@ smp_call_function (void (*func) (void *i
 }
 EXPORT_SYMBOL(smp_call_function);
 
-void
-smp_do_timer (struct pt_regs *regs)
-{
-	int user = user_mode(regs);
-
-	if (--local_cpu_data->prof_counter <= 0) {
-		local_cpu_data->prof_counter = local_cpu_data->prof_multiplier;
-		update_process_times(user);
-	}
-}
-
 /*
  * this function calls the 'stop' function on all other CPUs in the system.
  */
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/smpboot.c linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/smpboot.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/smpboot.c	2004-03-15 14:20:27.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/smpboot.c	2004-03-25 19:53:03.000000000 +0000
@@ -265,8 +265,6 @@ ia64_sync_itc (unsigned int master)
 static inline void __init
 smp_setup_percpu_timer (void)
 {
-	local_cpu_data->prof_counter = 1;
-	local_cpu_data->prof_multiplier = 1;
 }
 
 static void __init
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/time.c linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/time.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/time.c	2004-01-23 10:20:12.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/time.c	2004-03-25 19:53:03.000000000 +0000
@@ -255,9 +255,13 @@ timer_interrupt (int irq, void *dev_id, 
 	ia64_do_profile(regs);
 
 	while (1) {
-
 #ifdef CONFIG_SMP
-		smp_do_timer(regs);
+		/*
+		 * For UP, this is done in do_timer().  Weird, but
+		 * fixing that would require updates to all
+		 * platforms.
+		 */
+		update_process_times(user_mode(regs));
 #endif
 		new_itm += local_cpu_data->itm_delta;
 
@@ -280,17 +284,19 @@ timer_interrupt (int irq, void *dev_id, 
 	}
 
 	do {
-	    /*
-	     * If we're too close to the next clock tick for comfort, we increase the
-	     * safety margin by intentionally dropping the next tick(s).  We do NOT update
-	     * itm.next because that would force us to call do_timer() which in turn would
-	     * let our clock run too fast (with the potentially devastating effect of
-	     * losing monotony of time).
-	     */
-	    while (!time_after(new_itm, ia64_get_itc() + local_cpu_data->itm_delta/2))
-	      new_itm += local_cpu_data->itm_delta;
-	    ia64_set_itm(new_itm);
-	    /* double check, in case we got hit by a (slow) PMI: */
+		/*
+		 * If we're too close to the next clock tick for
+		 * comfort, we increase the safety margin by
+		 * intentionally dropping the next tick(s).  We do NOT
+		 * update itm.next because that would force us to call
+		 * do_timer() which in turn would let our clock run
+		 * too fast (with the potentially devastating effect
+		 * of losing monotony of time).
+		 */
+		while (!time_after(new_itm, ia64_get_itc() + local_cpu_data->itm_delta/2))
+			new_itm += local_cpu_data->itm_delta;
+		ia64_set_itm(new_itm);
+		/* double check, in case we got hit by a (slow) PMI: */
 	} while (time_after_eq(ia64_get_itc(), new_itm));
 	return IRQ_HANDLED;
 }
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/traps.c linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/traps.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/traps.c	2004-02-11 02:51:27.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/traps.c	2004-03-24 12:40:30.000000000 +0000
@@ -488,7 +488,7 @@ ia64_fault (unsigned long vector, unsign
 			siginfo.si_isr = isr;
 			force_sig_info(sig, &siginfo, current);
 			return;
-		} else if (done_with_exception(regs))
+		} else if (ia64_done_with_exception(regs))
 			return;
 		sprintf(buf, "NaT consumption");
 		break;
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/unaligned.c linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/unaligned.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/unaligned.c	2004-02-05 21:31:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/unaligned.c	2004-03-24 13:05:41.000000000 +0000
@@ -1486,7 +1486,7 @@ ia64_handle_unaligned (unsigned long ifa
 	/* something went wrong... */
 	if (!user_mode(regs)) {
 		if (eh) {
-			handle_exception(regs, eh);
+			ia64_handle_exception(regs, eh);
 			goto done;
 		}
 		die_if_kernel("error during unaligned kernel access\n", regs, ret);
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/vmlinux.lds.S linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/vmlinux.lds.S
--- linux-post-2.6.5-rc2-20040323/arch/ia64/kernel/vmlinux.lds.S	2003-12-04 22:08:55.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/kernel/vmlinux.lds.S	2004-03-17 14:44:14.000000000 +0000
@@ -12,6 +12,11 @@ OUTPUT_FORMAT("elf64-ia64-little")
 OUTPUT_ARCH(ia64)
 ENTRY(phys_start)
 jiffies = jiffies_64;
+PHDRS {
+  code   PT_LOAD;
+  percpu PT_LOAD;
+  data   PT_LOAD;
+}
 SECTIONS
 {
   /* Sections to be discarded */
@@ -26,6 +31,7 @@ SECTIONS
   v = PAGE_OFFSET;	/* this symbol is here to make debugging easier... */
   phys_start = _start - LOAD_OFFSET;
 
+  code : { } :code
   . = KERNEL_START;
 
   _text = .;
@@ -173,6 +179,7 @@ SECTIONS
         { *(.data.cacheline_aligned) }
 
   /* Per-cpu data: */
+  percpu : { } :percpu
   . = ALIGN(PERCPU_PAGE_SIZE);
   __phys_per_cpu_start = .;
   .data.percpu PERCPU_ADDR : AT(__phys_per_cpu_start - LOAD_OFFSET)
@@ -183,6 +190,7 @@ SECTIONS
 	}
   . = __phys_per_cpu_start + PERCPU_PAGE_SIZE;	/* ensure percpu data fits into percpu page size */
 
+  data : { } :data
   .data : AT(ADDR(.data) - LOAD_OFFSET)
 	{ *(.data) *(.data1) *(.gnu.linkonce.d*) CONSTRUCTORS }
 
@@ -205,6 +213,7 @@ SECTIONS
 
   _end = .;
 
+  code : { } :code
   /* Stabs debugging sections.  */
   .stab 0 : { *(.stab) }
   .stabstr 0 : { *(.stabstr) }
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/lib/swiotlb.c linux-post-2.6.5-rc2-20040326/arch/ia64/lib/swiotlb.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/lib/swiotlb.c	2004-03-14 06:54:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/lib/swiotlb.c	2004-03-22 14:34:46.000000000 +0000
@@ -498,6 +498,12 @@ swiotlb_sync_sg_for_device (struct devic
 			sync_single(hwdev, (void *) sg->dma_address, sg->dma_length, dir);
 }
 
+int
+swiotlb_dma_mapping_error (dma_addr_t dma_addr)
+{
+	return 0;
+}
+
 /*
  * Return whether the given PCI device DMA address mask can be supported properly.  For
  * example, if your device can only drive the low 24-bits during PCI bus mastering, then
@@ -518,6 +524,7 @@ EXPORT_SYMBOL(swiotlb_sync_single_for_cp
 EXPORT_SYMBOL(swiotlb_sync_single_for_device);
 EXPORT_SYMBOL(swiotlb_sync_sg_for_cpu);
 EXPORT_SYMBOL(swiotlb_sync_sg_for_device);
+EXPORT_SYMBOL(swiotlb_dma_mapping_error);
 EXPORT_SYMBOL(swiotlb_alloc_coherent);
 EXPORT_SYMBOL(swiotlb_free_coherent);
 EXPORT_SYMBOL(swiotlb_dma_supported);
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/mm/extable.c linux-post-2.6.5-rc2-20040326/arch/ia64/mm/extable.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/mm/extable.c	2004-01-28 05:23:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/mm/extable.c	2004-03-24 12:41:13.000000000 +0000
@@ -81,7 +81,7 @@ search_extable (const struct exception_t
 }
 
 void
-handle_exception (struct pt_regs *regs, const struct exception_table_entry *e)
+ia64_handle_exception (struct pt_regs *regs, const struct exception_table_entry *e)
 {
 	long fix = (u64) &e->cont + e->cont;
 
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/mm/fault.c linux-post-2.6.5-rc2-20040326/arch/ia64/mm/fault.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/mm/fault.c	2004-01-28 05:23:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/mm/fault.c	2004-03-24 12:40:32.000000000 +0000
@@ -213,7 +213,7 @@ ia64_do_page_fault (unsigned long addres
 		return;
 	}
 
-	if (done_with_exception(regs))
+	if (ia64_done_with_exception(regs))
 		return;
 
 	/*
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/pci/pci.c linux-post-2.6.5-rc2-20040326/arch/ia64/pci/pci.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/pci/pci.c	2004-03-19 22:17:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/pci/pci.c	2004-03-24 01:55:32.000000000 +0000
@@ -128,7 +128,8 @@ struct pci_raw_ops *raw_pci_ops = &pci_s
 static int __init
 pci_set_sal_ops (void)
 {
-	if (sal_version >= SAL_VERSION_CODE(3, 2)) {
+	if (sal_revision >= SAL_VERSION_CODE(3, 2)) {
+		printk("Using SAL 3.2 to access PCI config space\n");
 		raw_pci_ops = &pci_sal_ext_ops;
 	}
 	return 0;
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/sn/io/machvec/pci_dma.c linux-post-2.6.5-rc2-20040326/arch/ia64/sn/io/machvec/pci_dma.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/sn/io/machvec/pci_dma.c	2004-03-14 19:17:06.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/sn/io/machvec/pci_dma.c	2004-03-22 14:34:46.000000000 +0000
@@ -652,6 +652,13 @@ sn_dma_sync_sg_for_device(struct device 
 }
 EXPORT_SYMBOL(sn_dma_sync_sg_for_device);
 
+int
+sn_dma_mapping_error(dma_addr_t dma_addr)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(sn_dma_mapping_error);
 EXPORT_SYMBOL(sn_pci_unmap_single);
 EXPORT_SYMBOL(sn_pci_map_single);
 EXPORT_SYMBOL(sn_pci_dma_sync_single_for_cpu);
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/sn/io/sn2/shub.c linux-post-2.6.5-rc2-20040326/arch/ia64/sn/io/sn2/shub.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/sn/io/sn2/shub.c	2004-02-13 15:00:22.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/sn/io/sn2/shub.c	2004-03-23 14:45:27.000000000 +0000
@@ -160,11 +160,13 @@ static int
 shubstats_ioctl(struct inode *inode, struct file *file,
         unsigned int cmd, unsigned long arg)
 {
-        cnodeid_t       cnode;
-        uint64_t        longarg;
+	cnodeid_t       cnode;
+	uint64_t        longarg;
+	uint64_t        intarg;
+	uint64_t        regval[2];
 	int		nasid;
 
-        cnode = (cnodeid_t)file->f_dentry->d_fsdata;
+        cnode = (cnodeid_t)(u64)file->f_dentry->d_fsdata;
         if (cnode < 0 || cnode >= numnodes)
                 return -ENODEV;
 
@@ -200,6 +202,38 @@ shubstats_ioctl(struct inode *inode, str
 		}
 		break;
 
+	case SNDRV_SHUB_GETMMR32:
+		intarg = shub_mmr_read32(cnode, arg);
+		if (copy_to_user((void *)arg, &intarg,
+					sizeof(intarg))) {
+		    return -EFAULT;
+		}
+		break;
+ 
+	case SNDRV_SHUB_GETMMR64:
+	case SNDRV_SHUB_GETMMR64_IO:
+		if (cmd == SNDRV_SHUB_GETMMR64)
+		    longarg = shub_mmr_read(cnode, arg);
+		else
+		    longarg = shub_mmr_read_iospace(cnode, arg);
+		if (copy_to_user((void *)arg, &longarg, sizeof(longarg)))
+		    return -EFAULT;
+		break;
+ 
+	case SNDRV_SHUB_PUTMMR64:
+	case SNDRV_SHUB_PUTMMR64_IO:
+		if (copy_from_user((void *)regval, (void *)arg, sizeof(regval)))
+		    return -EFAULT;
+		if (regval[0] & 0x7) {
+		    printk("Error: configure_shub_stats: unaligned address 0x%016lx\n", regval[0]);
+		    return -EINVAL;
+		}
+		if (cmd == SNDRV_SHUB_PUTMMR64)
+		    shub_mmr_write(cnode, (shubreg_t)regval[0], regval[1]);
+		else
+		    shub_mmr_write_iospace(cnode, (shubreg_t)regval[0], regval[1]);
+		break;
+ 
 	default:
 		return -EINVAL;
 	}
@@ -210,255 +244,3 @@ shubstats_ioctl(struct inode *inode, str
 struct file_operations shub_mon_fops = {
 	        .ioctl          = shubstats_ioctl,
 };
-
-/*
- * "linkstatd" kernel thread to export SGI Numalink
- * stats via /proc/sgi_sn/linkstats
- */
-static struct s_linkstats {
-	uint64_t	hs_ni_sn_errors[2];
-	uint64_t	hs_ni_cb_errors[2];
-	uint64_t	hs_ni_retry_errors[2];
-	int		hs_ii_up;
-	uint64_t	hs_ii_sn_errors;
-	uint64_t	hs_ii_cb_errors;
-	uint64_t	hs_ii_retry_errors;
-} *sn_linkstats;
-
-static spinlock_t    sn_linkstats_lock;
-static unsigned long sn_linkstats_starttime;
-static unsigned long sn_linkstats_samples;
-static unsigned long sn_linkstats_overflows;
-static unsigned long sn_linkstats_update_msecs;
-
-void
-sn_linkstats_reset(unsigned long msecs)
-{
-	int		    cnode;
-	uint64_t	    iio_wstat;
-	uint64_t	    llp_csr_reg;
-
-	spin_lock(&sn_linkstats_lock);
-	memset(sn_linkstats, 0, numnodes * sizeof(struct s_linkstats));
-	for (cnode=0; cnode < numnodes; cnode++) {
-	    shub_mmr_write(cnode, SH_NI0_LLP_ERR, 0L);
-	    shub_mmr_write(cnode, SH_NI1_LLP_ERR, 0L);
-	    shub_mmr_write_iospace(cnode, IIO_LLP_LOG, 0L);
-
-	    /* zero the II retry counter */
-	    iio_wstat = shub_mmr_read_iospace(cnode, IIO_WSTAT);
-	    iio_wstat &= 0xffffffffff00ffff; /* bits 23:16 */
-	    shub_mmr_write_iospace(cnode, IIO_WSTAT, iio_wstat);
-
-	    /* Check if the II xtalk link is working */
-	    llp_csr_reg = shub_mmr_read_iospace(cnode, IIO_LLP_CSR);
-	    if (llp_csr_reg & IIO_LLP_CSR_IS_UP)
-		sn_linkstats[cnode].hs_ii_up = 1;
-	}
-
-    	sn_linkstats_update_msecs = msecs;
-	sn_linkstats_samples = 0;
-	sn_linkstats_overflows = 0;
-	sn_linkstats_starttime = jiffies;
-	spin_unlock(&sn_linkstats_lock);
-}
-
-int
-linkstatd_thread(void *unused)
-{
-	int		    cnode;
-	int		    overflows;
-	uint64_t	    reg[2];
-	uint64_t	    iio_wstat = 0L;
-	ii_illr_u_t	    illr;
-	struct s_linkstats  *lsp;
-	struct task_struct  *tsk = current;
-
-	daemonize("linkstatd");
-	set_user_nice(tsk, 19);
-	sigfillset(&tsk->blocked);
-	strcpy(tsk->comm, "linkstatd");
-
-	while(1) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(sn_linkstats_update_msecs * HZ / 1000);
-
-		spin_lock(&sn_linkstats_lock);
-
-		overflows = 0;
-		for (lsp=sn_linkstats, cnode=0; cnode < numnodes; cnode++, lsp++) {
-			reg[0] = shub_mmr_read(cnode, SH_NI0_LLP_ERR);
-			reg[1] = shub_mmr_read(cnode, SH_NI1_LLP_ERR);
-			if (lsp->hs_ii_up) {
-			    illr = (ii_illr_u_t)shub_mmr_read_iospace(cnode, IIO_LLP_LOG);
-			    iio_wstat = shub_mmr_read_iospace(cnode, IIO_WSTAT);
-			}
-
-			if (!overflows && (
-			    (reg[0] & SH_NI0_LLP_ERR_RX_SN_ERR_COUNT_MASK) == 
-				     SH_NI0_LLP_ERR_RX_SN_ERR_COUNT_MASK ||
-			    (reg[0] & SH_NI0_LLP_ERR_RX_CB_ERR_COUNT_MASK) ==
-			             SH_NI0_LLP_ERR_RX_CB_ERR_COUNT_MASK ||
-			    (reg[1] & SH_NI1_LLP_ERR_RX_SN_ERR_COUNT_MASK) ==
-			             SH_NI1_LLP_ERR_RX_SN_ERR_COUNT_MASK ||
-			    (reg[1] & SH_NI1_LLP_ERR_RX_CB_ERR_COUNT_MASK) ==
-			             SH_NI1_LLP_ERR_RX_CB_ERR_COUNT_MASK ||
-			    (lsp->hs_ii_up && illr.ii_illr_fld_s.i_sn_cnt == IIO_LLP_SN_MAX) ||
-			    (lsp->hs_ii_up && illr.ii_illr_fld_s.i_cb_cnt == IIO_LLP_CB_MAX))) {
-			    overflows = 1;
-			}
-
-#define LINKSTAT_UPDATE(reg, cnt, mask, shift) cnt += (reg & mask) >> shift
-
-			LINKSTAT_UPDATE(reg[0], lsp->hs_ni_sn_errors[0],
-					SH_NI0_LLP_ERR_RX_SN_ERR_COUNT_MASK,
-					SH_NI0_LLP_ERR_RX_SN_ERR_COUNT_SHFT);
-
-			LINKSTAT_UPDATE(reg[1], lsp->hs_ni_sn_errors[1],
-					SH_NI1_LLP_ERR_RX_SN_ERR_COUNT_MASK,
-					SH_NI1_LLP_ERR_RX_SN_ERR_COUNT_SHFT);
-
-			LINKSTAT_UPDATE(reg[0], lsp->hs_ni_cb_errors[0],
-					SH_NI0_LLP_ERR_RX_CB_ERR_COUNT_MASK,
-					SH_NI0_LLP_ERR_RX_CB_ERR_COUNT_SHFT);
-
-			LINKSTAT_UPDATE(reg[1], lsp->hs_ni_cb_errors[1],
-					SH_NI1_LLP_ERR_RX_CB_ERR_COUNT_MASK,
-					SH_NI1_LLP_ERR_RX_CB_ERR_COUNT_SHFT);
-
-			LINKSTAT_UPDATE(reg[0], lsp->hs_ni_retry_errors[0],
-					SH_NI0_LLP_ERR_RETRY_COUNT_MASK,
-					SH_NI0_LLP_ERR_RETRY_COUNT_SHFT);
-
-			LINKSTAT_UPDATE(reg[1], lsp->hs_ni_retry_errors[1],
-					SH_NI1_LLP_ERR_RETRY_COUNT_MASK,
-					SH_NI1_LLP_ERR_RETRY_COUNT_SHFT);
-
-			if (lsp->hs_ii_up) {
-			    /* II sn and cb errors */
-			    lsp->hs_ii_sn_errors += illr.ii_illr_fld_s.i_sn_cnt;
-			    lsp->hs_ii_cb_errors += illr.ii_illr_fld_s.i_cb_cnt;
-			    lsp->hs_ii_retry_errors += (iio_wstat & 0x0000000000ff0000) >> 16;
-
-			    shub_mmr_write(cnode, SH_NI0_LLP_ERR, 0L);
-			    shub_mmr_write(cnode, SH_NI1_LLP_ERR, 0L);
-			    shub_mmr_write_iospace(cnode, IIO_LLP_LOG, 0L);
-
-			    /* zero the II retry counter */
-			    iio_wstat = shub_mmr_read_iospace(cnode, IIO_WSTAT);
-			    iio_wstat &= 0xffffffffff00ffff; /* bits 23:16 */
-			    shub_mmr_write_iospace(cnode, IIO_WSTAT, iio_wstat);
-			}
-		}
-
-		sn_linkstats_samples++;
-		if (overflows)
-		    sn_linkstats_overflows++;
-
-		spin_unlock(&sn_linkstats_lock);
-	}
-}
-
-static char *
-rate_per_minute(uint64_t val, uint64_t secs)
-{
-	static char	buf[16];
-	uint64_t	a=0, b=0, c=0, d=0;
-
-	if (secs) {
-		a = 60 * val / secs;
-		b = 60 * 10 * val / secs - (10 * a);
-		c = 60 * 100 * val / secs - (100 * a) - (10 * b);
-		d = 60 * 1000 * val / secs - (1000 * a) - (100 * b) - (10 * c);
-	}
-	sprintf(buf, "%4lu.%lu%lu%lu", a, b, c, d);
-
-	return buf;
-}
-
-int
-sn_linkstats_get(char *page)
-{
-	int			n = 0;
-	int			cnode;
-	int			nlport;
-	struct s_linkstats	*lsp;
-	nodepda_t		*npda;
-	uint64_t	    	snsum = 0;
-	uint64_t	    	cbsum = 0;
-	uint64_t	    	retrysum = 0;
-	uint64_t	    	snsum_ii = 0;
-	uint64_t	    	cbsum_ii = 0;
-	uint64_t	    	retrysum_ii = 0;
-	uint64_t		secs;
-
-	spin_lock(&sn_linkstats_lock);
-	secs = (jiffies - sn_linkstats_starttime) / HZ;
-
-	n += sprintf(page, "# SGI Numalink stats v1 : %lu samples, %lu o/flows, update %lu msecs\n",
-		sn_linkstats_samples, sn_linkstats_overflows, sn_linkstats_update_msecs);
-
-	n += sprintf(page+n, "%-37s %8s %8s %8s %8s\n",
-		"# Numalink", "sn errs", "cb errs", "cb/min", "retries");
-
-	for (lsp=sn_linkstats, cnode=0; cnode < numnodes; cnode++, lsp++) {
-		npda = NODEPDA(cnode);
-
-		/* two NL links on each SHub */
-		for (nlport=0; nlport < 2; nlport++) {
-			cbsum += lsp->hs_ni_cb_errors[nlport];
-			snsum += lsp->hs_ni_sn_errors[nlport];
-			retrysum += lsp->hs_ni_retry_errors[nlport];
-
-			/* avoid buffer overrun (should be using seq_read API) */
-			if (numnodes > 64)
-				continue;
-
-			n += sprintf(page + n, "/%s/link/%d  %8lu %8lu %8s %8lu\n",
-			    npda->hwg_node_name, nlport+1, lsp->hs_ni_sn_errors[nlport],
-			    lsp->hs_ni_cb_errors[nlport], 
-			    rate_per_minute(lsp->hs_ni_cb_errors[nlport], secs),
-			    lsp->hs_ni_retry_errors[nlport]);
-		}
-
-		/* one II port on each SHub (may not be connected) */
-		if (lsp->hs_ii_up) {
-		    n += sprintf(page + n, "/%s/xtalk   %8lu %8lu %8s %8lu\n",
-			npda->hwg_node_name, lsp->hs_ii_sn_errors,
-			lsp->hs_ii_cb_errors, rate_per_minute(lsp->hs_ii_cb_errors, secs),
-			lsp->hs_ii_retry_errors);
-
-		    snsum_ii += lsp->hs_ii_sn_errors;
-		    cbsum_ii += lsp->hs_ii_cb_errors;
-		    retrysum_ii += lsp->hs_ii_retry_errors;
-		}
-	}
-
-	n += sprintf(page + n, "%-37s %8lu %8lu %8s %8lu\n",
-		"System wide NL totals", snsum, cbsum, 
-		rate_per_minute(cbsum, secs), retrysum);
-
-	n += sprintf(page + n, "%-37s %8lu %8lu %8s %8lu\n",
-		"System wide II totals", snsum_ii, cbsum_ii, 
-		rate_per_minute(cbsum_ii, secs), retrysum_ii);
-
-	spin_unlock(&sn_linkstats_lock);
-
-	return n;
-}
-
-static int __init
-linkstatd_init(void)
-{
-	if (!ia64_platform_is("sn2"))
-		return -ENODEV;
-
-	spin_lock_init(&sn_linkstats_lock);
-	sn_linkstats = kmalloc(numnodes * sizeof(struct s_linkstats), GFP_KERNEL);
-	sn_linkstats_reset(60000UL); /* default 60 second update interval */
-	kernel_thread(linkstatd_thread, NULL, CLONE_KERNEL);
-
-	return 0;                                                                       
-}
-
-__initcall(linkstatd_init);
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/sn/kernel/mca.c linux-post-2.6.5-rc2-20040326/arch/ia64/sn/kernel/mca.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/sn/kernel/mca.c	2004-03-15 18:05:52.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/sn/kernel/mca.c	2004-03-24 00:00:00.000000000 +0000
@@ -108,6 +108,7 @@ sn_platform_plat_specific_err_print(cons
 	down(&sn_oemdata_mutex);
 	sn_oemdata = oemdata;
 	sn_oemdata_size = oemdata_size;
+	sn_oemdata_bufsize = 0;
 	ia64_sn_plat_specific_err_print(print_hook, (char *)psei);
 	up(&sn_oemdata_mutex);
 	return 0;
@@ -120,7 +121,6 @@ int sn_salinfo_platform_oemdata(const u8
 {
 	efi_guid_t guid = *(efi_guid_t *)sect_header;
 	*oemdata_size = 0;
-	sn_oemdata_bufsize = 0;
 	vfree(*oemdata);
 	*oemdata = NULL;
 	if (efi_guidcmp(guid, SAL_PLAT_SPECIFIC_ERR_SECT_GUID) == 0)
diff -purN linux-post-2.6.5-rc2-20040323/arch/ia64/sn/kernel/sn2/sn_proc_fs.c linux-post-2.6.5-rc2-20040326/arch/ia64/sn/kernel/sn2/sn_proc_fs.c
--- linux-post-2.6.5-rc2-20040323/arch/ia64/sn/kernel/sn2/sn_proc_fs.c	2004-02-04 05:39:51.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ia64/sn/kernel/sn2/sn_proc_fs.c	2004-03-23 14:36:53.000000000 +0000
@@ -73,8 +73,13 @@ register_sn_serial_numbers(void) {
 	}
 }
 
-// Disable forced interrupts, but leave the code in, just in case.
-int sn_force_interrupt_flag = 0;
+/*
+ * Enable forced interrupt by default.
+ * When set, the sn interrupt handler writes the force interrupt register on
+ * the bridge chip.  The hardware will then send an interrupt message if the
+ * interrupt line is active.  This mimics a level sensitive interrupt.
+ */
+int sn_force_interrupt_flag = 1;
 
 static int
 sn_force_interrupt_read_proc(char *page, char **start, off_t off,
@@ -113,59 +118,11 @@ register_sn_force_interrupt(void) {
 	}
 }
 
-extern int sn_linkstats_get(char *);
-extern int sn_linkstats_reset(unsigned long);
-
-static int
-sn_linkstats_read_proc(char *page, char **start, off_t off,
-		int count, int *eof, void *data) {
-       
-	return sn_linkstats_get(page);
-}
-
-static int 
-sn_linkstats_write_proc(struct file *file, const char *buffer,
-                                        unsigned long count, void *data)
-{
-	char		s[64];
-	unsigned long	msecs;
-	int		e = count;
-
-	if (copy_from_user(s, buffer, count < sizeof(s) ? count : sizeof(s)))
-		e = -EFAULT;
-	else {
-		if (sscanf(s, "%lu", &msecs) != 1 || msecs < 5)
-			/* at least 5 milliseconds between updates */
-			e = -EINVAL;
-		else
-			sn_linkstats_reset(msecs);
-	}
-
-	return e;
-}
-
-void
-register_sn_linkstats(void) {
-	struct proc_dir_entry *entry;
-
-	if (!sgi_proc_dir) {
-		sgi_proc_dir = proc_mkdir("sgi_sn", 0);
-	}
-	entry = create_proc_entry("linkstats", 0444, sgi_proc_dir);
-	if (entry) {
-		entry->nlink = 1;
-		entry->data = 0;
-		entry->read_proc = sn_linkstats_read_proc;
-		entry->write_proc = sn_linkstats_write_proc;
-	}
-}
-
 void
 register_sn_procfs(void) {
 	register_sn_partition_id();
 	register_sn_serial_numbers();
 	register_sn_force_interrupt();
-	register_sn_linkstats();
 }
 
 #endif /* CONFIG_PROC_FS */
diff -purN linux-post-2.6.5-rc2-20040323/arch/ppc/boot/ld.script linux-post-2.6.5-rc2-20040326/arch/ppc/boot/ld.script
--- linux-post-2.6.5-rc2-20040323/arch/ppc/boot/ld.script	2003-08-25 12:13:38.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ppc/boot/ld.script	2004-03-23 10:05:25.000000000 +0000
@@ -82,6 +82,7 @@ SECTIONS
     *(__ksymtab)
     *(__ksymtab_strings)
     *(__bug_table)
+    *(__kcrctab)
   }
 
 }
diff -purN linux-post-2.6.5-rc2-20040323/arch/ppc/boot/openfirmware/Makefile linux-post-2.6.5-rc2-20040326/arch/ppc/boot/openfirmware/Makefile
--- linux-post-2.6.5-rc2-20040323/arch/ppc/boot/openfirmware/Makefile	2004-03-02 18:54:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ppc/boot/openfirmware/Makefile	2004-03-23 10:05:25.000000000 +0000
@@ -104,10 +104,10 @@ quiet_cmd_gen-coff = COFF    $@
 			$(HACKCOFF) $@ && \
 			ln -sf $(notdir $@) $(images)/zImage$(initrd).pmac
 
-$(images)/vmlinux.coff: $(obj)/coffboot
+$(images)/vmlinux.coff: $(obj)/coffboot $(boot)/ld.script
 	$(call cmd,gen-coff)
 
-$(images)/vmlinux.initrd.coff: $(obj)/coffboot.initrd
+$(images)/vmlinux.initrd.coff: $(obj)/coffboot.initrd $(boot)/ld.script
 	$(call cmd,gen-coff)
 
 quiet_cmd_gen-elf-pmac = ELF     $@
@@ -116,19 +116,19 @@ quiet_cmd_gen-elf-pmac = ELF     $@
 			$(OBJCOPY) $@ $@ --add-section=.note=$(obj)/note \
 					 -R .comment $(del-ramdisk-sec)
 
-$(images)/vmlinux.elf-pmac: $(obj)/image.o $(NEWWORLDOBJS) $(LIBS) $(obj)/note
+$(images)/vmlinux.elf-pmac: $(obj)/image.o $(NEWWORLDOBJS) $(LIBS) $(obj)/note $(boot)/ld.script
 	$(call cmd,gen-elf-pmac)
 $(images)/vmlinux.initrd.elf-pmac: $(obj)/image.initrd.o $(NEWWORLDOBJS) \
-				   $(LIBS) $(obj)/note
+				   $(LIBS) $(obj)/note $(boot)/ld.script
 	$(call cmd,gen-elf-pmac)
 
 quiet_cmd_gen-chrp = CHRP    $@
       cmd_gen-chrp = $(LD) $(CHRP_LD_ARGS) -o $@ $^ && \
 			$(OBJCOPY) $@ $@ -R .comment $(del-ramdisk-sec)
 
-$(images)/zImage.chrp: $(CHRPOBJS) $(obj)/image.o $(LIBS)
+$(images)/zImage.chrp: $(CHRPOBJS) $(obj)/image.o $(LIBS) $(boot)/ld.script
 	$(call cmd,gen-chrp)
-$(images)/zImage.initrd.chrp: $(CHRPOBJS) $(obj)/image.initrd.o $(LIBS)
+$(images)/zImage.initrd.chrp: $(CHRPOBJS) $(obj)/image.initrd.o $(LIBS) $(boot)/ld.script
 	$(call cmd,gen-chrp)
 
 quiet_cmd_addnote = ADDNOTE $@
diff -purN linux-post-2.6.5-rc2-20040323/arch/ppc/kernel/entry.S linux-post-2.6.5-rc2-20040326/arch/ppc/kernel/entry.S
--- linux-post-2.6.5-rc2-20040323/arch/ppc/kernel/entry.S	2004-02-13 15:24:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ppc/kernel/entry.S	2004-03-23 22:47:12.000000000 +0000
@@ -414,6 +414,14 @@ ppc_clone:
 	stw	r0,TRAP(r1)		/* register set saved */
 	b	sys_clone
 
+	.globl	ppc_swapcontext
+ppc_swapcontext:
+	SAVE_NVGPRS(r1)
+	lwz	r0,TRAP(r1)
+	rlwinm	r0,r0,0,0,30		/* clear LSB to indicate full */
+	stw	r0,TRAP(r1)		/* register set saved */
+	b	sys_swapcontext
+
 /*
  * This routine switches between two different tasks.  The process
  * state of one is saved on its kernel stack.  Then the state
diff -purN linux-post-2.6.5-rc2-20040323/arch/ppc/kernel/misc.S linux-post-2.6.5-rc2-20040326/arch/ppc/kernel/misc.S
--- linux-post-2.6.5-rc2-20040323/arch/ppc/kernel/misc.S	2004-03-14 01:57:41.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ppc/kernel/misc.S	2004-03-23 22:46:40.000000000 +0000
@@ -1363,7 +1363,7 @@ _GLOBAL(sys_call_table)
 	.long sys_clock_gettime
 	.long sys_clock_getres
 	.long sys_clock_nanosleep
-	.long sys_swapcontext
+	.long ppc_swapcontext
 	.long sys_tgkill	/* 250 */
 	.long sys_utimes
 	.long sys_statfs64
diff -purN linux-post-2.6.5-rc2-20040323/arch/ppc/kernel/process.c linux-post-2.6.5-rc2-20040326/arch/ppc/kernel/process.c
--- linux-post-2.6.5-rc2-20040323/arch/ppc/kernel/process.c	2003-10-11 13:54:29.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ppc/kernel/process.c	2004-03-24 01:55:33.000000000 +0000
@@ -45,7 +45,6 @@
 #include <asm/prom.h>
 #include <asm/hardirq.h>
 
-int dump_fpu(struct pt_regs *regs, elf_fpregset_t *fpregs);
 extern unsigned long _get_SP(void);
 
 struct task_struct *last_task_used_math = NULL;
@@ -189,11 +188,11 @@ enable_kernel_fp(void)
 }
 
 int
-dump_fpu(struct pt_regs *regs, elf_fpregset_t *fpregs)
+dump_task_fpu(struct task_struct *tsk, elf_fpregset_t *fpregs)
 {
-	if (regs->msr & MSR_FP)
-		giveup_fpu(current);
-	memcpy(fpregs, &current->thread.fpr[0], sizeof(*fpregs));
+	if (tsk->thread.regs && tsk->thread.regs->msr & MSR_FP)
+		giveup_fpu(tsk);
+	memcpy(fpregs, &tsk->thread.fpr[0], sizeof(*fpregs));
 	return 1;
 }
 
diff -purN linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/idle.c linux-post-2.6.5-rc2-20040326/arch/ppc64/kernel/idle.c
--- linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/idle.c	2004-02-12 04:39:21.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ppc64/kernel/idle.c	2004-03-25 08:39:55.000000000 +0000
@@ -172,16 +172,16 @@ int dedicated_idle(void)
 		oldval = test_and_clear_thread_flag(TIF_NEED_RESCHED);
 		if (!oldval) {
 			set_thread_flag(TIF_POLLING_NRFLAG);
-			start_snooze = __get_tb();
+			start_snooze = __get_tb() +
+				naca->smt_snooze_delay*tb_ticks_per_usec;
 			while (!need_resched()) {
 				/* need_resched could be 1 or 0 at this 
 				 * point.  If it is 0, set it to 0, so
 				 * an IPI/Prod is sent.  If it is 1, keep
 				 * it that way & schedule work.
 				 */
-				if (__get_tb() < 
-				    (start_snooze + 
-				     naca->smt_snooze_delay*tb_ticks_per_usec)) {  
+				if (naca->smt_snooze_delay == 0 ||
+				    __get_tb() < start_snooze) {
 					HMT_low(); /* Low thread priority */
 					continue;
 				}
diff -purN linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/sys_ppc32.c linux-post-2.6.5-rc2-20040326/arch/ppc64/kernel/sys_ppc32.c
--- linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/sys_ppc32.c	2004-03-16 11:30:35.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/ppc64/kernel/sys_ppc32.c	2004-03-25 08:40:38.000000000 +0000
@@ -405,14 +405,13 @@ asmlinkage long sys32_mount(char *dev_na
 	if (err)
 		goto out;
 
-	if (!type_page) {
-		err = -EINVAL;
-		goto out;
+	if (type_page) {
+		is_smb = !strcmp((char *)type_page, SMBFS_NAME);
+		is_ncp = !strcmp((char *)type_page, NCPFS_NAME);
+	} else {
+		is_smb = is_ncp = 0;
 	}
 
-	is_smb = !strcmp((char *)type_page, SMBFS_NAME);
-	is_ncp = !strcmp((char *)type_page, NCPFS_NAME);
-
 	err = copy_mount_stuff_to_kernel((const void *)AA(data), &data_page);
 	if (err)
 		goto type_out;
@@ -534,7 +533,7 @@ filldir(void * __buf, const char * name,
 {
 	struct linux_dirent32 * dirent;
 	struct getdents_callback32 * buf = (struct getdents_callback32 *) __buf;
-	int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 1);
+	int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 2);
 
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
@@ -548,6 +547,7 @@ filldir(void * __buf, const char * name,
 	put_user(reclen, &dirent->d_reclen);
 	copy_to_user(dirent->d_name, name, namlen);
 	put_user(0, dirent->d_name + namlen);
+	put_user(d_type, (char *) dirent + reclen - 1);
 	((char *) dirent) += reclen;
 	buf->current_dir = dirent;
 	buf->count -= reclen;
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/Kconfig linux-post-2.6.5-rc2-20040326/arch/sh/Kconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/Kconfig	2004-03-19 06:04:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/Kconfig	2004-03-23 10:05:27.000000000 +0000
@@ -27,7 +27,6 @@ config RWSEM_XCHGADD_ALGORITHM
 
 source "init/Kconfig"
 
-
 menu "System type"
 
 choice
@@ -244,6 +243,19 @@ config MMU
 	  turning this off will boot the kernel on these machines with the
 	  MMU implicitly switched off.
 
+choice
+	prompt "HugeTLB page size"
+	depends on HUGETLB_PAGE && CPU_SH4 && MMU
+	default HUGETLB_PAGE_SIZE_64K
+
+config HUGETLB_PAGE_SIZE_64K
+	bool "64K"
+
+config HUGETLB_PAGE_SIZE_1MB
+	bool "1MB"
+
+endchoice
+
 config CMDLINE_BOOL
 	bool "Default bootloader kernel arguments"
 
@@ -515,6 +527,8 @@ config SH_PCLK_FREQ
 	  with an auto-probed frequency which should be considered the proper
 	  value for your hardware.
 
+menu "CPU Frequency scaling"
+
 config CPU_FREQ
 	bool "CPU Frequency scaling"
 	help
@@ -525,6 +539,8 @@ config CPU_FREQ
 
 	  If unsure, say N.
 
+source "drivers/cpufreq/Kconfig"
+
 config CPU_FREQ_TABLE
 	tristate "CPU frequency table helpers"
 	depends on CPU_FREQ
@@ -546,12 +562,20 @@ config SH_CPU_FREQ
 
 	  If unsure, say N.
 
-source "drivers/cpufreq/Kconfig"
+endmenu
 
 source "arch/sh/drivers/dma/Kconfig"
 
 source "arch/sh/cchips/Kconfig"
 
+config HEARTBEAT
+	bool "Heartbeat LED"
+	depends on SH_MPC1211 || SH_CAT68701 || SH_STB1_HARP || SH_STB1_OVERDRIVE || SH_BIGSUR || SH_7751_SOLUTION_ENGINE || SH_SOLUTION_ENGINE
+	help
+	  Use the power-on LED on your machine as a load meter.  The exact
+	  behavior is platform-dependent, but normally the flash frequency is
+	  a hyperbolic function of the 5-minute load average.
+
 endmenu
 
 
@@ -601,8 +625,9 @@ config SBUS
 	bool
 
 config MAPLE
-	bool
-	default y if SH_DREAMCAST
+	tristate "Maple Bus support"
+	depends on SH_DREAMCAST
+	default y
 
 source "arch/sh/drivers/pci/Kconfig"
 
@@ -621,351 +646,10 @@ source "fs/Kconfig.binfmt"
 
 endmenu
 
-source "drivers/base/Kconfig"
-
-source "drivers/mtd/Kconfig"
-
-source "drivers/parport/Kconfig"
-
-source "drivers/block/Kconfig"
-
-source "drivers/ide/Kconfig"
-
-source "drivers/scsi/Kconfig"
-
-source "drivers/cdrom/Kconfig"
-
-source "drivers/md/Kconfig"
-
-source "drivers/ieee1394/Kconfig"
-
-source "net/Kconfig"
-
-source "drivers/isdn/Kconfig"
-
-source "drivers/telephony/Kconfig"
-
-#
-# input - input/joystick depends on it. As does USB.
-#
-source "drivers/input/Kconfig"
-
-menu "Character devices"
-
-config VT
-	bool "Virtual terminal"
-	---help---
-	  If you say Y here, you will get support for terminal devices with
-	  display and keyboard devices. These are called "virtual" because you
-	  can run several virtual terminals (also called virtual consoles) on
-	  one physical terminal. This is rather useful, for example one
-	  virtual terminal can collect system messages and warnings, another
-	  one can be used for a text-mode user session, and a third could run
-	  an X session, all in parallel. Switching between virtual terminals
-	  is done with certain key combinations, usually Alt-<function key>.
-
-	  The setterm command ("man setterm") can be used to change the
-	  properties (such as colors or beeping) of a virtual terminal. The
-	  man page console_codes(4) ("man console_codes") contains the special
-	  character sequences that can be used to change those properties
-	  directly. The fonts used on virtual terminals can be changed with
-	  the setfont ("man setfont") command and the key bindings are defined
-	  with the loadkeys ("man loadkeys") command.
-
-	  You need at least one virtual terminal device in order to make use
-	  of your keyboard and monitor. Therefore, only people configuring an
-	  embedded system would want to say N here in order to save some
-	  memory; the only way to log into such a system is then via a serial
-	  or network connection.
-
-	  If unsure, say Y, or else you won't be able to do much with your new
-	  shiny Linux system :-)
-
-config VT_CONSOLE
-	bool "Support for console on virtual terminal"
-	depends on VT
-	---help---
-	  The system console is the device which receives all kernel messages
-	  and warnings and which allows logins in single user mode. If you
-	  answer Y here, a virtual terminal (the device used to interact with
-	  a physical terminal) can be used as system console. This is the most
-	  common mode of operations, so you should say Y here unless you want
-	  the kernel messages be output only to a serial port (in which case
-	  you should say Y to "Console on serial port", below).
-
-	  If you do say Y here, by default the currently visible virtual
-	  terminal (/dev/tty0) will be used as system console. You can change
-	  that with a kernel command line option such as "console=tty3" which
-	  would use the third virtual terminal as system console. (Try "man
-	  bootparam" or see the documentation of your boot loader (lilo or
-	  loadlin) about how to pass options to the kernel at boot time.)
-
-	  If unsure, say Y.
-
-config HW_CONSOLE
-	bool
-	depends on VT && !S390 && !UM
-	default y
-
-config SERIAL
-	tristate "Serial (8250, 16450, 16550 or compatible) support"
-	---help---
-	  This selects whether you want to include the driver for the standard
-	  serial ports.  The standard answer is Y.  People who might say N
-	  here are those that are setting up dedicated Ethernet WWW/FTP
-	  servers, or users that have one of the various bus mice instead of a
-	  serial mouse and don't intend to use their machine's standard serial
-	  port for anything.  (Note that the Cyclades and Stallion multi
-	  serial port drivers do not need this driver built in for them to
-	  work.)
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called serial.
-	  [WARNING: Do not compile this driver as a module if you are using
-	  non-standard serial ports, since the configuration information will
-	  be lost when the driver is unloaded.  This limitation may be lifted
-	  in the future.]
-
-	  BTW1: If you have a mouseman serial mouse which is not recognized by
-	  the X window system, try running gpm first.
-
-	  BTW2: If you intend to use a software modem (also called Winmodem)
-	  under Linux, forget it.  These modems are crippled and require
-	  proprietary drivers which are only available under Windows.
-
-	  Most people will say Y or M here, so that they can use serial mice,
-	  modems and similar devices connecting to the standard serial ports.
-
-config SH_SCI
-	tristate "Serial (SCI, SCIF) support"
-	help
-	  Selecting this option will allow the Linux kernel to transfer data
-	  over SCI (Serial Communication Interface) and/or SCIF (Serial
-	  Communication Interface with FIFO) which are built into the Hitachi
-	  SuperH processor.  The option provides 1 to 3 (depending
-	  on the CPU model) standard Linux tty devices, /dev/ttySC[012]; one
-	  of these is normally used as the system console.
-
-	  If in doubt, press "y".
-
-config SERIAL_CONSOLE
-	bool "Support for console on serial port"
-	depends on SERIAL=y || SH_SCI=y
-	---help---
-	  If you say Y here, it will be possible to use a serial port as the
-	  system console (the system console is the device which receives all
-	  kernel messages and warnings and which allows logins in single user
-	  mode). This could be useful if some terminal or printer is connected
-	  to that serial port.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyS1". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-	  If you don't have a VGA card installed and you say Y here, the
-	  kernel will automatically use the first serial line, /dev/ttyS0, as
-	  system console.
-
-	  If unsure, say N.
-
-comment "Unix98 PTY support"
-
-config UNIX98_PTYS
-	bool "Unix98 PTY support"
-	---help---
-	  A pseudo terminal (PTY) is a software device consisting of two
-	  halves: a master and a slave. The slave device behaves identical to
-	  a physical terminal; the master device is used by a process to
-	  read data from and write data to the slave, thereby emulating a
-	  terminal. Typical programs for the master side are telnet servers
-	  and xterms.
-
-	  Linux has traditionally used the BSD-like names /dev/ptyxx for
-	  masters and /dev/ttyxx for slaves of pseudo terminals. This scheme
-	  has a number of problems. The GNU C library glibc 2.1 and later,
-	  however, supports the Unix98 naming standard: in order to acquire a
-	  pseudo terminal, a process opens /dev/ptmx; the number of the pseudo
-	  terminal is then made available to the process and the pseudo
-	  terminal slave can be accessed as /dev/pts/<number>. What was
-	  traditionally /dev/ttyp2 will then be /dev/pts/2, for example.
-
-	  The entries in /dev/pts/ are created on the fly by a virtual
-	  file system; therefore, if you say Y here you should say Y to
-	  "/dev/pts file system for Unix98 PTYs" as well.
-
-	  If you want to say Y here, you need to have the C library glibc 2.1
-	  or later (equal to libc-6.1, check with "ls -l /lib/libc.so.*").
-	  Read the instructions in <file:Documentation/Changes> pertaining to
-	  pseudo terminals. It's safe to say N.
-
-config UNIX98_PTY_COUNT
-	int "Maximum number of Unix98 PTYs in use (0-2048)"
-	depends on UNIX98_PTYS
-	default "256"
-	help
-	  The maximum number of Unix98 PTYs that can be used at any one time.
-	  The default is 256, and should be enough for desktop systems. Server
-	  machines which support incoming telnet/rlogin/ssh connections and/or
-	  serve several X terminals may want to increase this: every incoming
-	  connection and every xterm uses up one PTY.
-
-	  When not in use, each additional set of 256 PTYs occupy
-	  approximately 8 KB of kernel memory on 32-bit architectures.
-
-config HEARTBEAT
-	bool "Heartbeat LED"
-	depends on SH_MPC1211 || SH_CAT68701 || SH_STB1_HARP || SH_STB1_OVERDRIVE || SH_BIGSUR || SH_7751_SOLUTION_ENGINE || SH_SOLUTION_ENGINE
-	help
-	  Use the power-on LED on your machine as a load meter.  The exact
-	  behavior is platform-dependent, but normally the flash frequency is
-	  a hyperbolic function of the 5-minute load average.
-
-
-menu "Maple Bus input peripherals"
-	depends on SH_DREAMCAST && MAPLE
-
-config MAPLE_KEYBOARD
-	tristate "Maple Bus keyboard support"
-	depends on INPUT
-
-config MAPLE_MOUSE
-	tristate "Maple Bus mouse support"
-	depends on INPUT
-
-comment "Input core support is required for Maple input peripherals"
-	depends on INPUT=n
-
-endmenu
-
-config PRINTER
-	tristate "Parallel printer support"
-	depends on PARPORT
-	---help---
-	  If you intend to attach a printer to the parallel port of your Linux
-	  box (as opposed to using a serial printer; if the connector at the
-	  printer has 9 or 25 holes ["female"], then it's serial), say Y.
-	  Also read the Printing-HOWTO, available from
-	  <http://www.tldp.org/docs.html#howto>.
-
-	  It is possible to share one parallel port among several devices
-	  (e.g. printer and ZIP drive) and it is safe to compile the
-	  corresponding drivers into the kernel.
-	  To compile this driver as a module, choose M here and read
-	  <file:Documentation/parport.txt>.  The module will be called lp.
-
-	  If you have several parallel ports, you can specify which ports to
-	  use with the "lp" kernel command line option.  (Try "man bootparam"
-	  or see the documentation of your boot loader (lilo or loadlin) about
-	  how to pass options to the kernel at boot time.)  The syntax of the
-	  "lp" command line option can be found in <file:drivers/char/lp.c>.
-
-	  If you have more than 8 printers, you need to increase the LP_NO
-	  macro in lp.c and the PARPORT_MAX macro in parport.h.
-
-config LP_CONSOLE
-	bool "Support for console on line printer"
-	depends on PRINTER
-	---help---
-	  If you want kernel messages to be printed out as they occur, you
-	  can have a console on the printer. This option adds support for
-	  doing that; to actually get it to happen you need to pass the
-	  option "console=lp0" to the kernel at boot time.
-
-	  If the printer is out of paper (or off, or unplugged, or too
-	  busy..) the kernel will stall until the printer is ready again.
-	  By defining CONSOLE_LP_STRICT to 0 (at your own risk) you
-	  can make the kernel continue when this happens,
-	  but it'll lose the kernel messages.
-
-	  If unsure, say N.
-
-config PPDEV
-	tristate "Support for user-space parallel port device drivers"
-	depends on PARPORT
-	---help---
-	  Saying Y to this adds support for /dev/parport device nodes.  This
-	  is needed for programs that want portable access to the parallel
-	  port, for instance deviceid (which displays Plug-and-Play device
-	  IDs).
-
-	  This is the parallel port equivalent of SCSI generic support (sg).
-	  It is safe to say N to this -- it is not needed for normal printing
-	  or parallel port CD-ROM/disk support.
-
-	  To compile this support as a module, choose M here: the
-	  module will be called ppdev.
-
-	  If unsure, say N.
-
-config PSMOUSE
-	bool "PS/2 mouse (aka \"auxiliary device\") support"
-	---help---
-	  The PS/2 mouse connects to a special mouse port that looks much like
-	  the keyboard port (small circular connector with 6 pins). This way,
-	  the mouse does not use any serial ports. This port can also be used
-	  for other input devices like light pens, tablets, keypads. Compaq,
-	  AST and IBM all use this as their mouse port on currently shipping
-	  machines. The trackballs of some laptops are PS/2 mice also. In
-	  particular, the C&T 82C710 mouse on TI Travelmates is a PS/2 mouse.
-
-	  Although PS/2 mice are not technically bus mice, they are explained
-	  in detail in the Busmouse-HOWTO, available from
-	  <http://www.tldp.org/docs.html#howto>.
-
-	  When using a PS/2 mouse, you can get problems if you want to use the
-	  mouse both on the Linux console and under X. Using the "-R" option
-	  of the Linux mouse managing program gpm (available from
-	  <ftp://gnu.systemy.it/pub/gpm/>) solves this problem, or you can get
-	  the "mconv2" utility from <ftp://ibiblio.org/pub/Linux/system/mouse/>.
-
-source "drivers/char/watchdog/Kconfig"
-
-config RTC
-	tristate "Enhanced Real Time Clock Support"
-	---help---
-	  If you say Y here and create a character special file /dev/rtc with
-	  major number 10 and minor number 135 using mknod ("man mknod"), you
-	  will get access to the real time clock (or hardware clock) built
-	  into your computer.
-
-	  Every PC has such a clock built in. It can be used to generate
-	  signals from as low as 1Hz up to 8192Hz, and can also be used
-	  as a 24 hour alarm. It reports status information via the file
-	  /proc/driver/rtc and its behaviour is set by various ioctls on
-	  /dev/rtc.
-
-	  If you run Linux on a multiprocessor machine and said Y to
-	  "Symmetric Multi Processing" above, you should say Y here to read
-	  and set the RTC in an SMP compatible fashion.
-
-	  If you think you have a use for such a device (such as periodic data
-	  sampling), then say Y here, and read <file:Documentation/rtc.txt>
-	  for details.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called rtc.
-
-source "drivers/char/pcmcia/Kconfig"
-
-source "drivers/serial/Kconfig"
-
-source "drivers/i2c/Kconfig"
- 
-endmenu
+source "drivers/Kconfig"
 
 source "fs/Kconfig"
 
-source "drivers/media/Kconfig"
-
-source "drivers/video/Kconfig"
-
-source "sound/Kconfig"
-
-source "drivers/usb/Kconfig"
-
 source "arch/sh/oprofile/Kconfig"
 
 menu "Kernel hacking"
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/Makefile linux-post-2.6.5-rc2-20040326/arch/sh/Makefile
--- linux-post-2.6.5-rc2-20040323/arch/sh/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/Makefile	2004-03-23 10:05:26.000000000 +0000
@@ -1,4 +1,4 @@
-# $Id: Makefile,v 1.32 2003/10/26 23:33:49 lethal Exp $
+# $Id: Makefile,v 1.34 2004/03/21 17:31:06 lethal Exp $
 #
 # This file is subject to the terms and conditions of the GNU General Public
 # License.  See the file "COPYING" in the main directory of this archive
@@ -35,7 +35,6 @@ cflags-$(CONFIG_CPU_SH4)		+= -m4 \
 
 cflags-$(CONFIG_SH_DSP)			+= -Wa,-dsp
 cflags-$(CONFIG_SH_KGDB)		+= -g
-cflags-$(CONFIG_EMBEDDED)		+= -Os
 
 cflags-$(CONFIG_MORE_COMPILE_OPTIONS)	+= \
 	$(shell echo $(CONFIG_COMPILE_OPTIONS) | sed -e 's/"//g')
@@ -134,19 +133,7 @@ compressed: zImage
 archclean:
 	$(Q)$(MAKE) $(clean)=$(boot)
 
-defconfig-%:
-	@echo '  Copying arch/sh/configs/$@ -> .config'
-	@if [ -e .config ]; then mv -f .config .config.old; fi
-	@cp -f arch/sh/configs/$@ .config
-	@chmod 644 .config
-
 define archhelp
-	@echo '  zImage		  - Compressed kernel image (arch/sh/boot/zImage)'
-	for board in arch/sh/configs/*; \
-	do \
-		 echo -n ' ' $$board | sed -e 's|arch/sh/configs/||g' ; \
-		 echo -n '  	  - Build for ' ; \
-		 echo -e $$board | sed -e 's|.*-||g'; \
-	done
+	@echo '  zImage 	           - Compressed kernel image (arch/sh/boot/zImage)'
 endef
 
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/boards/hp6xx/hp680/mach.c linux-post-2.6.5-rc2-20040326/arch/sh/boards/hp6xx/hp680/mach.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/boards/hp6xx/hp680/mach.c	2004-02-13 15:19:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/boards/hp6xx/hp680/mach.c	2004-03-23 10:05:27.000000000 +0000
@@ -21,29 +21,33 @@
 #include <asm/irq.h>
 
 struct sh_machine_vector mv_hp680 __initmv = {
-        .mv_nr_irqs             = HD64461_IRQBASE+HD64461_IRQ_NUM,
+	.mv_nr_irqs = HD64461_IRQBASE + HD64461_IRQ_NUM,
 
-        .mv_inb                 = hd64461_inb,
-        .mv_inw                 = hd64461_inw,
-        .mv_inl                 = hd64461_inl,
-        .mv_outb                = hd64461_outb,
-        .mv_outw                = hd64461_outw,
-        .mv_outl                = hd64461_outl,
-
-        .mv_inb_p               = hd64461_inb_p,
-        .mv_inw_p               = hd64461_inw,
-        .mv_inl_p               = hd64461_inl,
-        .mv_outb_p              = hd64461_outb_p,
-        .mv_outw_p              = hd64461_outw,
-        .mv_outl_p              = hd64461_outl,
-
-        .mv_insb                = hd64461_insb,
-        .mv_insw                = hd64461_insw,
-        .mv_insl                = hd64461_insl,
-        .mv_outsb               = hd64461_outsb,
-        .mv_outsw               = hd64461_outsw,
-        .mv_outsl               = hd64461_outsl,
+	.mv_inb = hd64461_inb,
+	.mv_inw = hd64461_inw,
+	.mv_inl = hd64461_inl,
+	.mv_outb = hd64461_outb,
+	.mv_outw = hd64461_outw,
+	.mv_outl = hd64461_outl,
 
-        .mv_irq_demux           = hd64461_irq_demux,
+	.mv_inb_p = hd64461_inb_p,
+	.mv_inw_p = hd64461_inw,
+	.mv_inl_p = hd64461_inl,
+	.mv_outb_p = hd64461_outb_p,
+	.mv_outw_p = hd64461_outw,
+	.mv_outl_p = hd64461_outl,
+
+	.mv_insb = hd64461_insb,
+	.mv_insw = hd64461_insw,
+	.mv_insl = hd64461_insl,
+	.mv_outsb = hd64461_outsb,
+	.mv_outsw = hd64461_outsw,
+	.mv_outsl = hd64461_outsl,
+
+	.mv_readw = hd64461_readw,
+	.mv_writew = hd64461_writew,
+
+	.mv_irq_demux = hd64461_irq_demux,
 };
+
 ALIAS_MV(hp680)
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/boards/hp6xx/hp680/setup.c linux-post-2.6.5-rc2-20040326/arch/sh/boards/hp6xx/hp680/setup.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/boards/hp6xx/hp680/setup.c	2004-02-13 15:19:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/boards/hp6xx/hp680/setup.c	2004-03-23 10:05:27.000000000 +0000
@@ -12,6 +12,9 @@
 #include <linux/config.h>
 #include <linux/init.h>
 #include <asm/hd64461/hd64461.h>
+#include <asm/io.h>
+#include <asm/hp6xx/hp6xx.h>
+#include <asm/cpu/dac.h>
 
 const char *get_system_type(void)
 {
@@ -20,8 +23,19 @@ const char *get_system_type(void)
 
 int __init platform_setup(void)
 {
-	__set_io_port_base(CONFIG_HD64461_IOBASE - HD64461_STBCR);
+	u16 v;
+	v = inw(HD64461_STBCR);
+	v |= HD64461_STBCR_SURTST | HD64461_STBCR_SIRST |
+	    HD64461_STBCR_STM1ST | HD64461_STBCR_STM0ST |
+	    HD64461_STBCR_SAFEST | HD64461_STBCR_SPC0ST |
+	    HD64461_STBCR_SMIAST | HD64461_STBCR_SAFECKE_OST |
+	    HD64461_STBCR_SAFECKE_IST;
+	outw(v, HD64461_STBCR);
+	v = inw(HD64461_GPADR);
+	v |= HD64461_GPADR_SPEAKER | HD64461_GPADR_PCMCIA0;
+	outw(v, HD64461_GPADR);
+
+	sh_dac_disable(DAC_SPEAKER_VOLUME);
 
 	return 0;
 }
-
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/boards/se/770x/io.c linux-post-2.6.5-rc2-20040326/arch/sh/boards/se/770x/io.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/boards/se/770x/io.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/boards/se/770x/io.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: io.c,v 1.4 2003/08/03 03:05:10 lethal Exp $
+/* $Id: io.c,v 1.5 2004/02/22 23:08:43 kkojima Exp $
  *
  * linux/arch/sh/kernel/io_se.c
  *
@@ -134,25 +134,27 @@ void se_outl(unsigned int value, unsigne
 void se_insb(unsigned long port, void *addr, unsigned long count)
 {
 	volatile __u16 *p = port2adr(port);
+	__u8 *ap = addr;
 
 	if (sh_pcic_io_start <= port && port <= sh_pcic_io_stop) {
 		volatile __u8 *bp = (__u8 *) (sh_pcic_io_wbase + 0x40000 + port); 
 		while (count--)
-			*((__u8 *) addr)++ = *bp;
+			*ap++ = *bp;
 	} else if (shifted_port(port)) {
 		while (count--)
-			*((__u8 *) addr)++ = *p >> 8;
+			*ap++ = *p >> 8;
 	} else {
 		while (count--)
-			*((__u8 *) addr)++ = *p;
+			*ap++ = *p;
 	}
 }
 
 void se_insw(unsigned long port, void *addr, unsigned long count)
 {
 	volatile __u16 *p = port2adr(port);
+	__u16 *ap = addr;
 	while (count--)
-		*((__u16 *) addr)++ = *p;
+		*ap++ = *p;
 }
 
 void se_insl(unsigned long port, void *addr, unsigned long count)
@@ -163,25 +165,27 @@ void se_insl(unsigned long port, void *a
 void se_outsb(unsigned long port, const void *addr, unsigned long count)
 {
 	volatile __u16 *p = port2adr(port);
+	const __u8 *ap = addr;
 
 	if (sh_pcic_io_start <= port && port <= sh_pcic_io_stop) {
 		volatile __u8 *bp = (__u8 *) (sh_pcic_io_wbase + port); 
 		while (count--)
-			*bp = *((__u8 *) addr)++;
+			*bp = *ap++;
 	} else if (shifted_port(port)) {
 		while (count--)
-			*p = *((__u8 *) addr)++ << 8;
+			*p = *ap++ << 8;
 	} else {
 		while (count--)
-			*p = *((__u8 *) addr)++;
+			*p = *ap++;
 	}
 }
 
 void se_outsw(unsigned long port, const void *addr, unsigned long count)
 {
 	volatile __u16 *p = port2adr(port);
+	const __u16 *ap = addr;
 	while (count--)
-		*p = *((__u16 *) addr)++;
+		*p = *ap++;
 }
 
 void se_outsl(unsigned long port, const void *addr, unsigned long count)
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/boards/se/770x/irq.c linux-post-2.6.5-rc2-20040326/arch/sh/boards/se/770x/irq.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/boards/se/770x/irq.c	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/boards/se/770x/irq.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: irq.c,v 1.1.2.2 2002/10/29 00:56:09 lethal Exp $
+/* $Id: irq.c,v 1.4 2004/02/22 22:44:36 kkojima Exp $
  * 
  * linux/arch/sh/boards/se/770x/irq.c
  *
@@ -12,7 +12,7 @@
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <asm/irq.h>
-#include <asm/hitachi_se.h>
+#include <asm/se/se.h>
 
 /*
  * Initialize IRQ setting
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/cchips/Kconfig linux-post-2.6.5-rc2-20040326/arch/sh/cchips/Kconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/cchips/Kconfig	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/cchips/Kconfig	2004-03-23 10:05:27.000000000 +0000
@@ -1,7 +1,13 @@
+menu "Companion Chips"
+
 # A board must have defined HD6446X_SERIES in order to see these
+config HD6446X_SERIES
+	bool "HD6446x support"
+	default n
+
 choice
 	prompt "HD6446x options"
-	depends HD6446X_SERIES
+	depends on HD6446X_SERIES
 	default HD64461
 
 config HD64461
@@ -73,4 +79,5 @@ config HD64465_IRQ
 
 	  Do not change this unless you know what you are doing.
 
+endmenu
 
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/cchips/hd6446x/hd64461/io.c linux-post-2.6.5-rc2-20040326/arch/sh/cchips/hd6446x/hd64461/io.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/cchips/hd6446x/hd64461/io.c	2004-02-13 15:19:29.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/cchips/hd6446x/hd64461/io.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *	$Id: io.c,v 1.5 2004/02/01 19:46:04 lethal Exp $
+ *	$Id: io.c,v 1.6 2004/03/16 00:07:50 lethal Exp $
  *	Copyright (C) 2000 YAEGASHI Takeshi
  *	Typical I/O routines for HD64461 system.
  */
@@ -8,6 +8,8 @@
 #include <asm/io.h>
 #include <asm/hd64461/hd64461.h>
 
+#define MEM_BASE (CONFIG_HD64461_IOBASE - HD64461_STBCR)
+
 static __inline__ unsigned long PORT2ADDR(unsigned long port)
 {
 	/* 16550A: HD64461 internal */
@@ -36,7 +38,9 @@ static __inline__ unsigned long PORT2ADD
 #endif
 
 	/* ??? */
-	if (port < 0x10000) return 0xa0000000 + port;
+	if (port < 0xf000) return 0xa0000000 + port;
+	/* PCMCIA channel 0, I/O (0xba000000) */
+	if (port < 0x10000) return 0xba000000 + port - 0xf000;
 
 	/* HD64461 internal devices (0xb0000000) */
 	if (port < 0x20000) return CONFIG_HD64461_IOBASE + port - 0x10000;
@@ -140,3 +144,14 @@ void hd64461_outsl(unsigned long port, c
 	const unsigned long *buf=buffer;
 	while(count--) *addr=*buf++;
 }
+
+unsigned short hd64461_readw(unsigned long addr)
+{
+	return *(volatile unsigned short*)(MEM_BASE+addr);
+}
+
+void hd64461_writew(unsigned short b, unsigned long addr)
+{
+	*(volatile unsigned short*)(MEM_BASE+addr) = b;
+}
+
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/cchips/hd6446x/hd64461/setup.c linux-post-2.6.5-rc2-20040326/arch/sh/cchips/hd6446x/hd64461/setup.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/cchips/hd6446x/hd64461/setup.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/cchips/hd6446x/hd64461/setup.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,11 +1,12 @@
 /*
- *	$Id: setup.c,v 1.4 2003/08/03 03:05:10 lethal Exp $
+ *	$Id: setup.c,v 1.5 2004/03/16 00:07:50 lethal Exp $
  *	Copyright (C) 2000 YAEGASHI Takeshi
  *	Hitachi HD64461 companion chip support
  */
 
 #include <linux/config.h>
 #include <linux/sched.h>
+#include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/param.h>
 #include <linux/interrupt.h>
@@ -30,7 +31,6 @@ static void disable_hd64461_irq(unsigned
 	local_irq_restore(flags);
 }
 
-
 static void enable_hd64461_irq(unsigned int irq)
 {
 	unsigned long flags;
@@ -44,7 +44,6 @@ static void enable_hd64461_irq(unsigned 
 	local_irq_restore(flags);
 }
 
-
 static void mask_and_ack_hd64461(unsigned int irq)
 {
 	disable_hd64461_irq(irq);
@@ -54,27 +53,23 @@ static void mask_and_ack_hd64461(unsigne
 #endif
 }
 
-
 static void end_hd64461_irq(unsigned int irq)
 {
 	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
 		enable_hd64461_irq(irq);
 }
 
-
 static unsigned int startup_hd64461_irq(unsigned int irq)
-{ 
+{
 	enable_hd64461_irq(irq);
 	return 0;
 }
 
-
 static void shutdown_hd64461_irq(unsigned int irq)
 {
 	disable_hd64461_irq(irq);
 }
 
-
 static struct hw_interrupt_type hd64461_irq_type = {
 	.typename	= "HD64461-IRQ",
 	.startup	= startup_hd64461_irq,
@@ -85,7 +80,6 @@ static struct hw_interrupt_type hd64461_
 	.end		= end_hd64461_irq,
 };
 
-
 static irqreturn_t hd64461_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	printk(KERN_INFO
@@ -95,23 +89,52 @@ static irqreturn_t hd64461_interrupt(int
 	return IRQ_NONE;
 }
 
+static struct {
+	int (*func) (int, void *);
+	void *dev;
+} hd64461_demux[HD64461_IRQ_NUM];
+
+void hd64461_register_irq_demux(int irq,
+				int (*demux) (int irq, void *dev), void *dev)
+{
+	hd64461_demux[irq - HD64461_IRQBASE].func = demux;
+	hd64461_demux[irq - HD64461_IRQBASE].dev = dev;
+}
+
+EXPORT_SYMBOL(hd64461_register_irq_demux);
+
+void hd64461_unregister_irq_demux(int irq)
+{
+	hd64461_demux[irq - HD64461_IRQBASE].func = 0;
+}
+
+EXPORT_SYMBOL(hd64461_unregister_irq_demux);
+
 int hd64461_irq_demux(int irq)
 {
 	if (irq == CONFIG_HD64461_IRQ) {
 		unsigned short bit;
 		unsigned short nirr = inw(HD64461_NIRR);
 		unsigned short nimr = inw(HD64461_NIMR);
+		int i;
+
 		nirr &= ~nimr;
-		for (bit = 1, irq = 0; irq < 16; bit <<= 1, irq++)
-			if (nirr & bit) break;
-		if (irq == 16) irq = CONFIG_HD64461_IRQ;
-		else irq += HD64461_IRQBASE;
+		for (bit = 1, i = 0; i < 16; bit <<= 1, i++)
+			if (nirr & bit)
+				break;
+		if (i == 16)
+			irq = CONFIG_HD64461_IRQ;
+		else {
+			irq = HD64461_IRQBASE + i;
+			if (hd64461_demux[i].func != 0) {
+				irq = hd64461_demux[i].func(irq, hd64461_demux[i].dev);
+			}
+		}
 	}
 	return __irq_demux(irq);
 }
 
-static struct irqaction irq0  = { hd64461_interrupt, SA_INTERRUPT, 0, "HD64461", NULL, NULL};
-
+static struct irqaction irq0 = { hd64461_interrupt, SA_INTERRUPT, 0, "HD64461", NULL, NULL };
 
 int __init setup_hd64461(void)
 {
@@ -120,11 +143,12 @@ int __init setup_hd64461(void)
 	if (!MACH_HD64461)
 		return 0;
 
-	printk(KERN_INFO "HD64461 configured at 0x%x on irq %d(mapped into %d to %d)\n",
-	       CONFIG_HD64461_IOBASE, CONFIG_HD64461_IRQ,
-	       HD64461_IRQBASE, HD64461_IRQBASE+15);
+	printk(KERN_INFO
+	       "HD64461 configured at 0x%x on irq %d(mapped into %d to %d)\n",
+	       CONFIG_HD64461_IOBASE, CONFIG_HD64461_IRQ, HD64461_IRQBASE,
+	       HD64461_IRQBASE + 15);
 
-#if defined(CONFIG_CPU_SUBTYPE_SH7709) /* Should be at processor specific part.. */
+#if defined(CONFIG_CPU_SUBTYPE_SH7709)	/* Should be at processor specific part.. */
 	outw(0x2240, INTC_ICR1);
 #endif
 	outw(0xffff, HD64461_NIMR);
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/adx_defconfig linux-post-2.6.5-rc2-20040326/arch/sh/configs/adx_defconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/adx_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/adx_defconfig	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,276 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Processor type and features
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+CONFIG_SH_ADX=y
+# CONFIG_SH_UNKNOWN is not set
+CONFIG_SH_RTC=y
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+CONFIG_CPU_SUBTYPE_SH7750=y
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x00400000
+CONFIG_MEMORY_SET=y
+# CONFIG_DISCONTIGMEM is not set
+
+#
+# General setup
+#
+CONFIG_ISA=y
+# CONFIG_EISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SBUS is not set
+# CONFIG_NET is not set
+CONFIG_CF_ENABLER=y
+# CONFIG_CF_AREA5 is not set
+CONFIG_CF_AREA6=y
+CONFIG_CF_BASE_ADDR=0xb8000000
+# CONFIG_HD64461 is not set
+# CONFIG_HD64465 is not set
+# CONFIG_SH_DMA is not set
+# CONFIG_PCI is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+CONFIG_SH_SCI=y
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_PSMOUSE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_TMPFS is not set
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_ZISOFS_FS is not set
+# CONFIG_ZLIB_FS_INFLATE is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_SH_STANDARD_BIOS=y
+CONFIG_SH_EARLY_PRINTK=y
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/cqreek_defconfig linux-post-2.6.5-rc2-20040326/arch/sh/configs/cqreek_defconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/cqreek_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/cqreek_defconfig	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,274 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Processor type and features
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+CONFIG_SH_CQREEK=y
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_UNKNOWN is not set
+CONFIG_SH_RTC=y
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+CONFIG_CPU_SUBTYPE_SH7708=y
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+CONFIG_CPU_SH3=y
+# CONFIG_CPU_SH4 is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_MEMORY_SIZE=0x00400000
+# CONFIG_DISCONTIGMEM is not set
+
+#
+# General setup
+#
+CONFIG_ISA=y
+# CONFIG_EISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SBUS is not set
+# CONFIG_NET is not set
+# CONFIG_CF_AREA5 is not set
+CONFIG_CF_AREA6=y
+CONFIG_CF_BASE_ADDR=0xb8000000
+# CONFIG_HD64461 is not set
+# CONFIG_HD64465 is not set
+# CONFIG_SH_DMA is not set
+# CONFIG_PCI is not set
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
+# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
+# CONFIG_BLK_DEV_IDEDISK_IBM is not set
+# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
+# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
+# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
+# CONFIG_BLK_DEV_IDEDISK_WD is not set
+# CONFIG_BLK_DEV_COMMERIAL is not set
+# CONFIG_BLK_DEV_TIVO is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Input core support
+#
+# CONFIG_INPUT is not set
+# CONFIG_INPUT_KEYBDEV is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+CONFIG_SH_SCI=y
+CONFIG_SERIAL_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_PSMOUSE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_TMPFS is not set
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_ZISOFS_FS is not set
+# CONFIG_ZLIB_FS_INFLATE is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_SH_STANDARD_BIOS=y
+CONFIG_SH_EARLY_PRINTK=y
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-adx linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-adx
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-adx	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-adx	1970-01-01 00:00:00.000000000 +0000
@@ -1,276 +0,0 @@
-#
-# Automatically generated by make menuconfig: don't edit
-#
-CONFIG_SUPERH=y
-CONFIG_UID16=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-
-#
-# Loadable module support
-#
-# CONFIG_MODULES is not set
-
-#
-# Processor type and features
-#
-# CONFIG_SH_SOLUTION_ENGINE is not set
-# CONFIG_SH_7751_SOLUTION_ENGINE is not set
-# CONFIG_SH_STB1_HARP is not set
-# CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
-# CONFIG_SH_CQREEK is not set
-# CONFIG_SH_DMIDA is not set
-# CONFIG_SH_EC3104 is not set
-# CONFIG_SH_DREAMCAST is not set
-# CONFIG_SH_CAT68701 is not set
-# CONFIG_SH_BIGSUR is not set
-# CONFIG_SH_SH2000 is not set
-CONFIG_SH_ADX=y
-# CONFIG_SH_UNKNOWN is not set
-CONFIG_SH_RTC=y
-# CONFIG_CPU_SUBTYPE_SH7707 is not set
-# CONFIG_CPU_SUBTYPE_SH7708 is not set
-# CONFIG_CPU_SUBTYPE_SH7709 is not set
-CONFIG_CPU_SUBTYPE_SH7750=y
-# CONFIG_CPU_SUBTYPE_SH7751 is not set
-# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
-# CONFIG_CPU_SH3 is not set
-CONFIG_CPU_SH4=y
-CONFIG_CPU_LITTLE_ENDIAN=y
-CONFIG_MEMORY_START=0x08000000
-CONFIG_MEMORY_SIZE=0x00400000
-CONFIG_MEMORY_SET=y
-# CONFIG_DISCONTIGMEM is not set
-
-#
-# General setup
-#
-CONFIG_ISA=y
-# CONFIG_EISA is not set
-# CONFIG_MCA is not set
-# CONFIG_SBUS is not set
-# CONFIG_NET is not set
-CONFIG_CF_ENABLER=y
-# CONFIG_CF_AREA5 is not set
-CONFIG_CF_AREA6=y
-CONFIG_CF_BASE_ADDR=0xb8000000
-# CONFIG_HD64461 is not set
-# CONFIG_HD64465 is not set
-# CONFIG_SH_DMA is not set
-# CONFIG_PCI is not set
-# CONFIG_HOTPLUG is not set
-# CONFIG_PCMCIA is not set
-# CONFIG_SYSVIPC is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_SYSCTL is not set
-CONFIG_KCORE_ELF=y
-# CONFIG_KCORE_AOUT is not set
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_XD is not set
-# CONFIG_PARIDE is not set
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_CISS_SCSI_TAPE is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_BLK_DEV_INITRD=y
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-# CONFIG_BLK_DEV_MD is not set
-# CONFIG_MD_LINEAR is not set
-# CONFIG_MD_RAID0 is not set
-# CONFIG_MD_RAID1 is not set
-# CONFIG_MD_RAID5 is not set
-# CONFIG_MD_MULTIPATH is not set
-# CONFIG_BLK_DEV_LVM is not set
-
-#
-# ATA/IDE/MFM/RLL support
-#
-CONFIG_IDE=y
-
-#
-# IDE, ATA and ATAPI Block devices
-#
-CONFIG_BLK_DEV_IDE=y
-# CONFIG_BLK_DEV_HD_IDE is not set
-# CONFIG_BLK_DEV_HD is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
-# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
-# CONFIG_BLK_DEV_IDEDISK_IBM is not set
-# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
-# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
-# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
-# CONFIG_BLK_DEV_IDEDISK_WD is not set
-# CONFIG_BLK_DEV_COMMERIAL is not set
-# CONFIG_BLK_DEV_TIVO is not set
-# CONFIG_BLK_DEV_IDECS is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_BLK_DEV_IDESCSI is not set
-# CONFIG_BLK_DEV_CMD640 is not set
-# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
-# CONFIG_BLK_DEV_ISAPNP is not set
-# CONFIG_IDE_CHIPSETS is not set
-# CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
-# CONFIG_BLK_DEV_ATARAID is not set
-# CONFIG_BLK_DEV_ATARAID_PDC is not set
-# CONFIG_BLK_DEV_ATARAID_HPT is not set
-
-#
-# SCSI support
-#
-# CONFIG_SCSI is not set
-
-#
-# Old CD-ROM drivers (not SCSI, not IDE)
-#
-# CONFIG_CD_NO_IDESCSI is not set
-
-#
-# Input core support
-#
-# CONFIG_INPUT is not set
-# CONFIG_INPUT_KEYBDEV is not set
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_SERIAL is not set
-CONFIG_SH_SCI=y
-CONFIG_SERIAL_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-
-#
-# Joysticks
-#
-# CONFIG_INPUT_GAMEPORT is not set
-# CONFIG_PSMOUSE is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
-# CONFIG_RTC is not set
-
-#
-# File systems
-#
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_REISERFS_CHECK is not set
-# CONFIG_REISERFS_PROC_INFO is not set
-# CONFIG_ADFS_FS is not set
-# CONFIG_ADFS_FS_RW is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_JBD_DEBUG is not set
-# CONFIG_FAT_FS is not set
-# CONFIG_MSDOS_FS is not set
-# CONFIG_UMSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_JFFS_FS is not set
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_TMPFS is not set
-CONFIG_RAMFS=y
-# CONFIG_ISO9660_FS is not set
-# CONFIG_JOLIET is not set
-# CONFIG_ZISOFS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_NTFS_FS is not set
-# CONFIG_NTFS_RW is not set
-# CONFIG_HPFS_FS is not set
-CONFIG_PROC_FS=y
-# CONFIG_DEVFS_FS is not set
-# CONFIG_DEVFS_MOUNT is not set
-# CONFIG_DEVFS_DEBUG is not set
-# CONFIG_DEVPTS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_QNX4FS_RW is not set
-# CONFIG_ROMFS_FS is not set
-CONFIG_EXT2_FS=y
-# CONFIG_SYSV_FS is not set
-# CONFIG_UDF_FS is not set
-# CONFIG_UDF_RW is not set
-# CONFIG_UFS_FS is not set
-# CONFIG_UFS_FS_WRITE is not set
-# CONFIG_NCPFS_NLS is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_ZISOFS_FS is not set
-# CONFIG_ZLIB_FS_INFLATE is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_SMB_NLS is not set
-# CONFIG_NLS is not set
-
-#
-# Multimedia devices
-#
-# CONFIG_VIDEO_DEV is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_MAGIC_SYSRQ is not set
-CONFIG_SH_STANDARD_BIOS=y
-CONFIG_SH_EARLY_PRINTK=y
-
-#
-# Library routines
-#
-# CONFIG_CRC32 is not set
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-cqreek linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-cqreek
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-cqreek	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-cqreek	1970-01-01 00:00:00.000000000 +0000
@@ -1,274 +0,0 @@
-#
-# Automatically generated by make menuconfig: don't edit
-#
-CONFIG_SUPERH=y
-CONFIG_UID16=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-
-#
-# Loadable module support
-#
-# CONFIG_MODULES is not set
-
-#
-# Processor type and features
-#
-# CONFIG_SH_SOLUTION_ENGINE is not set
-# CONFIG_SH_7751_SOLUTION_ENGINE is not set
-# CONFIG_SH_STB1_HARP is not set
-# CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
-CONFIG_SH_CQREEK=y
-# CONFIG_SH_DMIDA is not set
-# CONFIG_SH_EC3104 is not set
-# CONFIG_SH_DREAMCAST is not set
-# CONFIG_SH_CAT68701 is not set
-# CONFIG_SH_BIGSUR is not set
-# CONFIG_SH_SH2000 is not set
-# CONFIG_SH_ADX is not set
-# CONFIG_SH_UNKNOWN is not set
-CONFIG_SH_RTC=y
-# CONFIG_CPU_SUBTYPE_SH7707 is not set
-CONFIG_CPU_SUBTYPE_SH7708=y
-# CONFIG_CPU_SUBTYPE_SH7709 is not set
-# CONFIG_CPU_SUBTYPE_SH7750 is not set
-# CONFIG_CPU_SUBTYPE_SH7751 is not set
-# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
-CONFIG_CPU_SH3=y
-# CONFIG_CPU_SH4 is not set
-CONFIG_CPU_LITTLE_ENDIAN=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x00400000
-# CONFIG_DISCONTIGMEM is not set
-
-#
-# General setup
-#
-CONFIG_ISA=y
-# CONFIG_EISA is not set
-# CONFIG_MCA is not set
-# CONFIG_SBUS is not set
-# CONFIG_NET is not set
-# CONFIG_CF_AREA5 is not set
-CONFIG_CF_AREA6=y
-CONFIG_CF_BASE_ADDR=0xb8000000
-# CONFIG_HD64461 is not set
-# CONFIG_HD64465 is not set
-# CONFIG_SH_DMA is not set
-# CONFIG_PCI is not set
-# CONFIG_HOTPLUG is not set
-# CONFIG_PCMCIA is not set
-# CONFIG_SYSVIPC is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_SYSCTL is not set
-CONFIG_KCORE_ELF=y
-# CONFIG_KCORE_AOUT is not set
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_XD is not set
-# CONFIG_PARIDE is not set
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_CISS_SCSI_TAPE is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_BLK_DEV_INITRD=y
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-# CONFIG_BLK_DEV_MD is not set
-# CONFIG_MD_LINEAR is not set
-# CONFIG_MD_RAID0 is not set
-# CONFIG_MD_RAID1 is not set
-# CONFIG_MD_RAID5 is not set
-# CONFIG_MD_MULTIPATH is not set
-# CONFIG_BLK_DEV_LVM is not set
-
-#
-# ATA/IDE/MFM/RLL support
-#
-CONFIG_IDE=y
-
-#
-# IDE, ATA and ATAPI Block devices
-#
-CONFIG_BLK_DEV_IDE=y
-# CONFIG_BLK_DEV_HD_IDE is not set
-# CONFIG_BLK_DEV_HD is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_BLK_DEV_IDEDISK_VENDOR is not set
-# CONFIG_BLK_DEV_IDEDISK_FUJITSU is not set
-# CONFIG_BLK_DEV_IDEDISK_IBM is not set
-# CONFIG_BLK_DEV_IDEDISK_MAXTOR is not set
-# CONFIG_BLK_DEV_IDEDISK_QUANTUM is not set
-# CONFIG_BLK_DEV_IDEDISK_SEAGATE is not set
-# CONFIG_BLK_DEV_IDEDISK_WD is not set
-# CONFIG_BLK_DEV_COMMERIAL is not set
-# CONFIG_BLK_DEV_TIVO is not set
-# CONFIG_BLK_DEV_IDECS is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_BLK_DEV_IDESCSI is not set
-# CONFIG_BLK_DEV_CMD640 is not set
-# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
-# CONFIG_BLK_DEV_ISAPNP is not set
-# CONFIG_IDE_CHIPSETS is not set
-# CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
-# CONFIG_BLK_DEV_ATARAID is not set
-# CONFIG_BLK_DEV_ATARAID_PDC is not set
-# CONFIG_BLK_DEV_ATARAID_HPT is not set
-
-#
-# SCSI support
-#
-# CONFIG_SCSI is not set
-
-#
-# Old CD-ROM drivers (not SCSI, not IDE)
-#
-# CONFIG_CD_NO_IDESCSI is not set
-
-#
-# Input core support
-#
-# CONFIG_INPUT is not set
-# CONFIG_INPUT_KEYBDEV is not set
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_SERIAL is not set
-CONFIG_SH_SCI=y
-CONFIG_SERIAL_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-
-#
-# Joysticks
-#
-# CONFIG_INPUT_GAMEPORT is not set
-# CONFIG_PSMOUSE is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
-# CONFIG_RTC is not set
-
-#
-# File systems
-#
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_REISERFS_CHECK is not set
-# CONFIG_REISERFS_PROC_INFO is not set
-# CONFIG_ADFS_FS is not set
-# CONFIG_ADFS_FS_RW is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_JBD_DEBUG is not set
-# CONFIG_FAT_FS is not set
-# CONFIG_MSDOS_FS is not set
-# CONFIG_UMSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_JFFS_FS is not set
-# CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_TMPFS is not set
-CONFIG_RAMFS=y
-# CONFIG_ISO9660_FS is not set
-# CONFIG_JOLIET is not set
-# CONFIG_ZISOFS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_NTFS_FS is not set
-# CONFIG_NTFS_RW is not set
-# CONFIG_HPFS_FS is not set
-CONFIG_PROC_FS=y
-# CONFIG_DEVFS_FS is not set
-# CONFIG_DEVFS_MOUNT is not set
-# CONFIG_DEVFS_DEBUG is not set
-# CONFIG_DEVPTS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_QNX4FS_RW is not set
-# CONFIG_ROMFS_FS is not set
-CONFIG_EXT2_FS=y
-# CONFIG_SYSV_FS is not set
-# CONFIG_UDF_FS is not set
-# CONFIG_UDF_RW is not set
-# CONFIG_UFS_FS is not set
-# CONFIG_UFS_FS_WRITE is not set
-# CONFIG_NCPFS_NLS is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_ZISOFS_FS is not set
-# CONFIG_ZLIB_FS_INFLATE is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-# CONFIG_SMB_NLS is not set
-# CONFIG_NLS is not set
-
-#
-# Multimedia devices
-#
-# CONFIG_VIDEO_DEV is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_MAGIC_SYSRQ is not set
-CONFIG_SH_STANDARD_BIOS=y
-CONFIG_SH_EARLY_PRINTK=y
-
-#
-# Library routines
-#
-# CONFIG_CRC32 is not set
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-dreamcast linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-dreamcast
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-dreamcast	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-dreamcast	1970-01-01 00:00:00.000000000 +0000
@@ -1,584 +0,0 @@
-#
-# Automatically generated make config: don't edit
-#
-CONFIG_SUPERH=y
-CONFIG_UID16=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-# CONFIG_CLEAN_COMPILE is not set
-# CONFIG_STANDALONE is not set
-CONFIG_BROKEN=y
-CONFIG_BROKEN_ON_SMP=y
-
-#
-# General setup
-#
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_SYSCTL is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_IKCONFIG is not set
-CONFIG_EMBEDDED=y
-CONFIG_KALLSYMS=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-
-#
-# Loadable module support
-#
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODULE_FORCE_UNLOAD is not set
-CONFIG_OBSOLETE_MODPARM=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_KMOD is not set
-
-#
-# System type
-#
-# CONFIG_SH_SOLUTION_ENGINE is not set
-# CONFIG_SH_7751_SOLUTION_ENGINE is not set
-# CONFIG_SH_STB1_HARP is not set
-# CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
-# CONFIG_SH_CQREEK is not set
-# CONFIG_SH_DMIDA is not set
-# CONFIG_SH_EC3104 is not set
-# CONFIG_SH_SATURN is not set
-CONFIG_SH_DREAMCAST=y
-# CONFIG_SH_CAT68701 is not set
-# CONFIG_SH_BIGSUR is not set
-# CONFIG_SH_SH2000 is not set
-# CONFIG_SH_ADX is not set
-# CONFIG_SH_MPC1211 is not set
-# CONFIG_SH_SECUREEDGE5410 is not set
-# CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
-CONFIG_CPU_SH4=y
-# CONFIG_CPU_SUBTYPE_SH7604 is not set
-# CONFIG_CPU_SUBTYPE_SH7300 is not set
-# CONFIG_CPU_SUBTYPE_SH7707 is not set
-# CONFIG_CPU_SUBTYPE_SH7708 is not set
-# CONFIG_CPU_SUBTYPE_SH7709 is not set
-CONFIG_CPU_SUBTYPE_SH7750=y
-# CONFIG_CPU_SUBTYPE_SH7751 is not set
-# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
-CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x01000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-CONFIG_PREEMPT=y
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
-CONFIG_SH_STORE_QUEUES=y
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_FREQ=49876504
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-CONFIG_SH_CPU_FREQ=y
-# CONFIG_CPU_FREQ_PROC_INTF is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_SH_DMA=y
-CONFIG_NR_ONCHIP_DMA_CHANNELS=4
-CONFIG_NR_DMA_CHANNELS_BOOL=y
-CONFIG_NR_DMA_CHANNELS=9
-CONFIG_DMA_PAGE_OPS=y
-
-#
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
-#
-CONFIG_PCI=y
-# CONFIG_SH_PCIDMA_NONCOHERENT is not set
-CONFIG_PCI_AUTO=y
-CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
-# CONFIG_HOTPLUG is not set
-
-#
-# Executable file formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_FLAT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Generic Driver Options
-#
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Block devices
-#
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=1024
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_LBD is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_SCSI is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# IEEE 1394 (FireWire) support (EXPERIMENTAL)
-#
-# CONFIG_IEEE1394 is not set
-
-#
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-# CONFIG_NETLINK_DEV is not set
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_INET_ECN is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_IPV6 is not set
-# CONFIG_DECNET is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NETFILTER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-CONFIG_IPV6_SCTP__=y
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_FASTROUTE is not set
-# CONFIG_NET_HW_FLOWCONTROL is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-CONFIG_NETDEVICES=y
-
-#
-# ARCnet devices
-#
-# CONFIG_ARCNET is not set
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-
-#
-# Ethernet (10 or 100Mbit)
-#
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_STNIC is not set
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_NET_VENDOR_3COM is not set
-
-#
-# Tulip family network device support
-#
-# CONFIG_NET_TULIP is not set
-# CONFIG_HP100 is not set
-CONFIG_NET_PCI=y
-# CONFIG_PCNET32 is not set
-# CONFIG_AMD8111_ETH is not set
-# CONFIG_ADAPTEC_STARFIRE is not set
-# CONFIG_B44 is not set
-# CONFIG_DGRS is not set
-# CONFIG_EEPRO100 is not set
-# CONFIG_E100 is not set
-# CONFIG_FEALNX is not set
-# CONFIG_NATSEMI is not set
-# CONFIG_NE2K_PCI is not set
-# CONFIG_8139CP is not set
-CONFIG_8139TOO=y
-# CONFIG_8139TOO_PIO is not set
-# CONFIG_8139TOO_TUNE_TWISTER is not set
-# CONFIG_8139TOO_8129 is not set
-# CONFIG_8139_OLD_RX_RESET is not set
-# CONFIG_SIS900 is not set
-# CONFIG_EPIC100 is not set
-# CONFIG_SUNDANCE is not set
-# CONFIG_TLAN is not set
-# CONFIG_VIA_RHINE is not set
-
-#
-# Ethernet (1000 Mbit)
-#
-# CONFIG_ACENIC is not set
-# CONFIG_DL2K is not set
-# CONFIG_E1000 is not set
-# CONFIG_NS83820 is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_YELLOWFIN is not set
-# CONFIG_R8169 is not set
-# CONFIG_SIS190 is not set
-# CONFIG_SK98LIN is not set
-# CONFIG_TIGON3 is not set
-
-#
-# Ethernet (10000 Mbit)
-#
-# CONFIG_IXGB is not set
-# CONFIG_FDDI is not set
-# CONFIG_HIPPI is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-
-#
-# Wireless LAN (non-hamradio)
-#
-# CONFIG_NET_RADIO is not set
-
-#
-# Token Ring devices
-#
-# CONFIG_TR is not set
-# CONFIG_RCPCI is not set
-# CONFIG_SHAPER is not set
-
-#
-# Wan interfaces
-#
-# CONFIG_WAN is not set
-
-#
-# Amateur Radio support
-#
-# CONFIG_HAMRADIO is not set
-
-#
-# IrDA (infrared) support
-#
-# CONFIG_IRDA is not set
-
-#
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
-# ISDN subsystem
-#
-# CONFIG_ISDN_BOOL is not set
-
-#
-# Telephony Support
-#
-# CONFIG_PHONE is not set
-
-#
-# Input device support
-#
-# CONFIG_INPUT is not set
-
-#
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-
-#
-# Input Device Drivers
-#
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_SERIAL is not set
-CONFIG_SH_SCI=y
-CONFIG_SERIAL_CONSOLE=y
-
-#
-# Unix 98 PTY support
-#
-CONFIG_UNIX98_PTYS=y
-CONFIG_UNIX98_PTY_COUNT=256
-# CONFIG_PSMOUSE is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
-# CONFIG_RTC is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_SH_SCI is not set
-
-#
-# I2C support
-#
-# CONFIG_I2C is not set
-
-#
-# I2C Algorithms
-#
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C Hardware Sensors Chip support
-#
-# CONFIG_I2C_SENSOR is not set
-
-#
-# File systems
-#
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_MINIX_FS is not set
-CONFIG_ROMFS_FS=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_FAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
-CONFIG_DEVPTS_FS=y
-# CONFIG_DEVPTS_FS_XATTR is not set
-CONFIG_TMPFS=y
-# CONFIG_HUGETLBFS is not set
-# CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_CRAMFS=y
-# CONFIG_VXFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-
-#
-# Network File Systems
-#
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
-CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_GSS is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-
-#
-# Multimedia devices
-#
-# CONFIG_VIDEO_DEV is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-# CONFIG_DVB is not set
-
-#
-# Graphics support
-#
-CONFIG_FB=y
-# CONFIG_FB_CIRRUS is not set
-# CONFIG_FB_PM2 is not set
-# CONFIG_FB_CYBER2000 is not set
-# CONFIG_FB_ASILIANT is not set
-# CONFIG_FB_IMSTT is not set
-CONFIG_FB_PVR2=y
-# CONFIG_FB_PVR2_DEBUG is not set
-# CONFIG_FB_E1355 is not set
-# CONFIG_FB_RIVA is not set
-# CONFIG_FB_MATROX is not set
-# CONFIG_FB_RADEON is not set
-# CONFIG_FB_ATY128 is not set
-# CONFIG_FB_ATY is not set
-# CONFIG_FB_SIS is not set
-# CONFIG_FB_NEOMAGIC is not set
-# CONFIG_FB_3DFX is not set
-# CONFIG_FB_VOODOO1 is not set
-# CONFIG_FB_TRIDENT is not set
-# CONFIG_FB_PM3 is not set
-# CONFIG_FB_VIRTUAL is not set
-
-#
-# Logo configuration
-#
-# CONFIG_LOGO is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-
-#
-# USB support
-#
-# CONFIG_USB is not set
-# CONFIG_USB_GADGET is not set
-
-#
-# Profiling support
-#
-CONFIG_PROFILING=y
-CONFIG_OPROFILE=y
-
-#
-# Kernel hacking
-#
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_SH_STANDARD_BIOS is not set
-# CONFIG_KGDB is not set
-# CONFIG_FRAME_POINTER is not set
-
-#
-# Security options
-#
-# CONFIG_SECURITY is not set
-
-#
-# Cryptographic options
-#
-# CONFIG_CRYPTO is not set
-
-#
-# Library routines
-#
-CONFIG_CRC32=y
-CONFIG_ZLIB_INFLATE=y
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-hp680 linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-hp680
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-hp680	2004-02-13 15:19:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-hp680	1970-01-01 00:00:00.000000000 +0000
@@ -1,428 +0,0 @@
-#
-# Automatically generated make config: don't edit
-#
-CONFIG_SUPERH=y
-CONFIG_UID16=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-# CONFIG_CLEAN_COMPILE is not set
-# CONFIG_STANDALONE is not set
-CONFIG_BROKEN=y
-CONFIG_BROKEN_ON_SMP=y
-
-#
-# General setup
-#
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_SYSCTL is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_IKCONFIG is not set
-# CONFIG_EMBEDDED is not set
-CONFIG_KALLSYMS=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-
-#
-# Loadable module support
-#
-# CONFIG_MODULES is not set
-
-#
-# System type
-#
-# CONFIG_SH_SOLUTION_ENGINE is not set
-# CONFIG_SH_7751_SOLUTION_ENGINE is not set
-# CONFIG_SH_7751_SYSTEMH is not set
-# CONFIG_SH_STB1_HARP is not set
-# CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-CONFIG_SH_HP680=y
-# CONFIG_SH_HP690 is not set
-# CONFIG_SH_CQREEK is not set
-# CONFIG_SH_DMIDA is not set
-# CONFIG_SH_EC3104 is not set
-# CONFIG_SH_SATURN is not set
-# CONFIG_SH_DREAMCAST is not set
-# CONFIG_SH_CAT68701 is not set
-# CONFIG_SH_BIGSUR is not set
-# CONFIG_SH_SH2000 is not set
-# CONFIG_SH_ADX is not set
-# CONFIG_SH_MPC1211 is not set
-# CONFIG_SH_SECUREEDGE5410 is not set
-# CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-CONFIG_CPU_SH3=y
-# CONFIG_CPU_SH4 is not set
-# CONFIG_CPU_SUBTYPE_SH7604 is not set
-# CONFIG_CPU_SUBTYPE_SH7300 is not set
-# CONFIG_CPU_SUBTYPE_SH7707 is not set
-# CONFIG_CPU_SUBTYPE_SH7708 is not set
-CONFIG_CPU_SUBTYPE_SH7709=y
-# CONFIG_CPU_SUBTYPE_SH7750 is not set
-# CONFIG_CPU_SUBTYPE_SH7751 is not set
-# CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
-CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x00400000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
-CONFIG_SH_RTC=y
-# CONFIG_SH_DSP is not set
-CONFIG_SH_HP600=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_FREQ=1193182
-# CONFIG_CPU_FREQ is not set
-# CONFIG_SH_DMA is not set
-CONFIG_HD64461=y
-# CONFIG_HD64465 is not set
-CONFIG_HD64461_IRQ=36
-CONFIG_HD64461_ENABLER=y
-
-#
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
-#
-# CONFIG_PCI is not set
-# CONFIG_HOTPLUG is not set
-
-#
-# Executable file formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_FLAT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Generic Driver Options
-#
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_LOOP is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_LBD is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-CONFIG_IDE=y
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-# CONFIG_IDE_TASKFILE_IO is not set
-
-#
-# IDE chipset support/bugfixes
-#
-# CONFIG_BLK_DEV_IDEDMA is not set
-# CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
-# CONFIG_BLK_DEV_HD is not set
-
-#
-# SCSI device support
-#
-# CONFIG_SCSI is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# IEEE 1394 (FireWire) support (EXPERIMENTAL)
-#
-# CONFIG_IEEE1394 is not set
-
-#
-# Networking support
-#
-# CONFIG_NET is not set
-
-#
-# Amateur Radio support
-#
-# CONFIG_HAMRADIO is not set
-
-#
-# ISDN subsystem
-#
-
-#
-# Telephony Support
-#
-# CONFIG_PHONE is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-
-#
-# Userland interfaces
-#
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
-
-#
-# Character devices
-#
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
-# CONFIG_SERIAL is not set
-CONFIG_SH_SCI=y
-# CONFIG_SERIAL_CONSOLE is not set
-
-#
-# Unix 98 PTY support
-#
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_PSMOUSE is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
-# CONFIG_RTC is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_SH_SCI is not set
-
-#
-# I2C support
-#
-# CONFIG_I2C is not set
-
-#
-# I2C Algorithms
-#
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C Hardware Sensors Chip support
-#
-# CONFIG_I2C_SENSOR is not set
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_FAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
-# CONFIG_TMPFS is not set
-# CONFIG_HUGETLBFS is not set
-# CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-
-#
-# Native Language Support
-#
-# CONFIG_NLS is not set
-
-#
-# Multimedia devices
-#
-# CONFIG_VIDEO_DEV is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-
-#
-# Graphics support
-#
-CONFIG_FB=y
-# CONFIG_FB_E1355 is not set
-CONFIG_FB_HIT=y
-# CONFIG_FB_VIRTUAL is not set
-
-#
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-# CONFIG_MDA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_PCI_CONSOLE=y
-CONFIG_FONTS=y
-# CONFIG_FONT_8x8 is not set
-# CONFIG_FONT_8x16 is not set
-# CONFIG_FONT_6x11 is not set
-CONFIG_FONT_PEARL_8x8=y
-# CONFIG_FONT_ACORN_8x8 is not set
-# CONFIG_FONT_MINI_4x6 is not set
-# CONFIG_FONT_SUN8x16 is not set
-# CONFIG_FONT_SUN12x22 is not set
-
-#
-# Logo configuration
-#
-# CONFIG_LOGO is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-
-#
-# USB support
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# Profiling support
-#
-# CONFIG_PROFILING is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_SH_STANDARD_BIOS is not set
-# CONFIG_KGDB is not set
-# CONFIG_FRAME_POINTER is not set
-
-#
-# Security options
-#
-# CONFIG_SECURITY is not set
-
-#
-# Cryptographic options
-#
-# CONFIG_CRYPTO is not set
-
-#
-# Library routines
-#
-# CONFIG_CRC32 is not set
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-se7751 linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-se7751
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-se7751	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-se7751	1970-01-01 00:00:00.000000000 +0000
@@ -1,617 +0,0 @@
-#
-# Automatically generated make config: don't edit
-#
-CONFIG_SUPERH=y
-CONFIG_UID16=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_CLEAN_COMPILE=y
-CONFIG_STANDALONE=y
-CONFIG_BROKEN_ON_SMP=y
-
-#
-# General setup
-#
-CONFIG_SWAP=y
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_SYSCTL=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_IKCONFIG is not set
-CONFIG_EMBEDDED=y
-CONFIG_KALLSYMS=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-
-#
-# Loadable module support
-#
-CONFIG_MODULES=y
-# CONFIG_MODULE_UNLOAD is not set
-CONFIG_OBSOLETE_MODPARM=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_KMOD is not set
-
-#
-# System type
-#
-# CONFIG_SH_SOLUTION_ENGINE is not set
-CONFIG_SH_7751_SOLUTION_ENGINE=y
-# CONFIG_SH_7751_SYSTEMH is not set
-# CONFIG_SH_STB1_HARP is not set
-# CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
-# CONFIG_SH_CQREEK is not set
-# CONFIG_SH_DMIDA is not set
-# CONFIG_SH_EC3104 is not set
-# CONFIG_SH_SATURN is not set
-# CONFIG_SH_DREAMCAST is not set
-# CONFIG_SH_CAT68701 is not set
-# CONFIG_SH_BIGSUR is not set
-# CONFIG_SH_SH2000 is not set
-# CONFIG_SH_ADX is not set
-# CONFIG_SH_MPC1211 is not set
-# CONFIG_SH_SECUREEDGE5410 is not set
-# CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
-CONFIG_CPU_SH4=y
-# CONFIG_CPU_SUBTYPE_SH7604 is not set
-# CONFIG_CPU_SUBTYPE_SH7300 is not set
-# CONFIG_CPU_SUBTYPE_SH7707 is not set
-# CONFIG_CPU_SUBTYPE_SH7708 is not set
-# CONFIG_CPU_SUBTYPE_SH7709 is not set
-# CONFIG_CPU_SUBTYPE_SH7750 is not set
-CONFIG_CPU_SUBTYPE_SH7751=y
-# CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
-CONFIG_MMU=y
-CONFIG_CMDLINE_BOOL=y
-CONFIG_CMDLINE="console=ttySC1,38400"
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x04000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
-CONFIG_SH_RTC=y
-CONFIG_ZERO_PAGE_OFFSET=0x00010000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
-# CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_FREQ=60013568
-# CONFIG_CPU_FREQ is not set
-# CONFIG_SH_DMA is not set
-
-#
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
-#
-CONFIG_PCI=y
-# CONFIG_SH_PCIDMA_NONCOHERENT is not set
-CONFIG_PCI_AUTO=y
-CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
-CONFIG_PCI_DMA=y
-# CONFIG_PCI_LEGACY_PROC is not set
-# CONFIG_PCI_NAMES is not set
-# CONFIG_HOTPLUG is not set
-
-#
-# Executable file formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_FLAT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Generic Driver Options
-#
-
-#
-# Memory Technology Devices (MTD)
-#
-CONFIG_MTD=y
-# CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
-# CONFIG_MTD_CONCAT is not set
-# CONFIG_MTD_REDBOOT_PARTS is not set
-# CONFIG_MTD_CMDLINE_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-# CONFIG_MTD_CHAR is not set
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-CONFIG_MTD_CFI=y
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_GEN_PROBE=y
-# CONFIG_MTD_CFI_ADV_OPTIONS is not set
-# CONFIG_MTD_CFI_INTELEXT is not set
-CONFIG_MTD_CFI_AMDSTD=y
-# CONFIG_MTD_CFI_STAA is not set
-CONFIG_MTD_RAM=y
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_OBSOLETE_CHIPS is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PHYSMAP is not set
-# CONFIG_MTD_MPC1211 is not set
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_PMC551 is not set
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLKMTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOC2000 is not set
-# CONFIG_MTD_DOC2001 is not set
-# CONFIG_MTD_DOC2001PLUS is not set
-
-#
-# NAND Flash Device Drivers
-#
-# CONFIG_MTD_NAND is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_LBD is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_SCSI is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# IEEE 1394 (FireWire) support (EXPERIMENTAL)
-#
-# CONFIG_IEEE1394 is not set
-
-#
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_INET_ECN is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-# CONFIG_IPV6 is not set
-# CONFIG_DECNET is not set
-# CONFIG_BRIDGE is not set
-CONFIG_NETFILTER=y
-CONFIG_NETFILTER_DEBUG=y
-
-#
-# IP: Netfilter Configuration
-#
-# CONFIG_IP_NF_CONNTRACK is not set
-CONFIG_IP_NF_QUEUE=y
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-CONFIG_IPV6_SCTP__=y
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_FASTROUTE is not set
-# CONFIG_NET_HW_FLOWCONTROL is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-CONFIG_NETDEVICES=y
-
-#
-# ARCnet devices
-#
-# CONFIG_ARCNET is not set
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
-
-#
-# Ethernet (10 or 100Mbit)
-#
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_STNIC is not set
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_NET_VENDOR_3COM is not set
-
-#
-# Tulip family network device support
-#
-# CONFIG_NET_TULIP is not set
-# CONFIG_HP100 is not set
-CONFIG_NET_PCI=y
-CONFIG_PCNET32=y
-# CONFIG_AMD8111_ETH is not set
-# CONFIG_ADAPTEC_STARFIRE is not set
-# CONFIG_B44 is not set
-# CONFIG_DGRS is not set
-# CONFIG_EEPRO100 is not set
-# CONFIG_E100 is not set
-# CONFIG_FEALNX is not set
-# CONFIG_NATSEMI is not set
-# CONFIG_NE2K_PCI is not set
-# CONFIG_8139CP is not set
-# CONFIG_8139TOO is not set
-# CONFIG_SIS900 is not set
-# CONFIG_EPIC100 is not set
-# CONFIG_SUNDANCE is not set
-# CONFIG_TLAN is not set
-# CONFIG_VIA_RHINE is not set
-
-#
-# Ethernet (1000 Mbit)
-#
-# CONFIG_ACENIC is not set
-# CONFIG_DL2K is not set
-# CONFIG_E1000 is not set
-# CONFIG_NS83820 is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_YELLOWFIN is not set
-# CONFIG_R8169 is not set
-# CONFIG_SIS190 is not set
-# CONFIG_SK98LIN is not set
-# CONFIG_TIGON3 is not set
-
-#
-# Ethernet (10000 Mbit)
-#
-# CONFIG_IXGB is not set
-# CONFIG_FDDI is not set
-# CONFIG_HIPPI is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-
-#
-# Wireless LAN (non-hamradio)
-#
-# CONFIG_NET_RADIO is not set
-
-#
-# Token Ring devices
-#
-# CONFIG_TR is not set
-# CONFIG_RCPCI is not set
-# CONFIG_SHAPER is not set
-
-#
-# Wan interfaces
-#
-# CONFIG_WAN is not set
-
-#
-# Amateur Radio support
-#
-# CONFIG_HAMRADIO is not set
-
-#
-# IrDA (infrared) support
-#
-# CONFIG_IRDA is not set
-
-#
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
-# ISDN subsystem
-#
-# CONFIG_ISDN_BOOL is not set
-
-#
-# Telephony Support
-#
-# CONFIG_PHONE is not set
-
-#
-# Input device support
-#
-# CONFIG_INPUT is not set
-
-#
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-# CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
-# Input Device Drivers
-#
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_SERIAL is not set
-CONFIG_SH_SCI=y
-CONFIG_SERIAL_CONSOLE=y
-
-#
-# Unix 98 PTY support
-#
-CONFIG_UNIX98_PTYS=y
-CONFIG_UNIX98_PTY_COUNT=256
-CONFIG_HEARTBEAT=y
-# CONFIG_PSMOUSE is not set
-
-#
-# Watchdog Cards
-#
-CONFIG_WATCHDOG=y
-# CONFIG_WATCHDOG_NOWAYOUT is not set
-# CONFIG_SH_WDT is not set
-# CONFIG_RTC is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_SH_SCI is not set
-
-#
-# I2C support
-#
-# CONFIG_I2C is not set
-
-#
-# I2C Algorithms
-#
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C Hardware Sensors Chip support
-#
-# CONFIG_I2C_SENSOR is not set
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_FAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_KCORE=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS=y
-# CONFIG_DEVPTS_FS_XATTR is not set
-CONFIG_TMPFS=y
-# CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_JFFS_FS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_JFFS2_FS_DEBUG=0
-# CONFIG_JFFS2_FS_NAND is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-
-#
-# Network File Systems
-#
-# CONFIG_NFS_FS is not set
-# CONFIG_NFSD is not set
-# CONFIG_EXPORTFS is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-
-#
-# Multimedia devices
-#
-# CONFIG_VIDEO_DEV is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-# CONFIG_DVB is not set
-
-#
-# Graphics support
-#
-# CONFIG_FB is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-
-#
-# USB support
-#
-# CONFIG_USB is not set
-# CONFIG_USB_GADGET is not set
-
-#
-# Profiling support
-#
-# CONFIG_PROFILING is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_SH_STANDARD_BIOS is not set
-# CONFIG_KGDB is not set
-# CONFIG_FRAME_POINTER is not set
-
-#
-# Security options
-#
-# CONFIG_SECURITY is not set
-
-#
-# Cryptographic options
-#
-# CONFIG_CRYPTO is not set
-
-#
-# Library routines
-#
-CONFIG_CRC32=y
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-snapgear linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-snapgear
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-snapgear	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-snapgear	1970-01-01 00:00:00.000000000 +0000
@@ -1,540 +0,0 @@
-#
-# Automatically generated make config: don't edit
-#
-CONFIG_SUPERH=y
-CONFIG_UID16=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_CLEAN_COMPILE=y
-CONFIG_STANDALONE=y
-CONFIG_BROKEN_ON_SMP=y
-
-#
-# General setup
-#
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_SYSCTL is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_IKCONFIG is not set
-# CONFIG_EMBEDDED is not set
-CONFIG_KALLSYMS=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-
-#
-# Loadable module support
-#
-# CONFIG_MODULES is not set
-
-#
-# System type
-#
-# CONFIG_SH_SOLUTION_ENGINE is not set
-# CONFIG_SH_7751_SOLUTION_ENGINE is not set
-# CONFIG_SH_STB1_HARP is not set
-# CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
-# CONFIG_SH_CQREEK is not set
-# CONFIG_SH_DMIDA is not set
-# CONFIG_SH_EC3104 is not set
-# CONFIG_SH_SATURN is not set
-# CONFIG_SH_DREAMCAST is not set
-# CONFIG_SH_CAT68701 is not set
-# CONFIG_SH_BIGSUR is not set
-# CONFIG_SH_SH2000 is not set
-# CONFIG_SH_ADX is not set
-# CONFIG_SH_MPC1211 is not set
-CONFIG_SH_SECUREEDGE5410=y
-# CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
-CONFIG_CPU_SH4=y
-# CONFIG_CPU_SUBTYPE_SH7604 is not set
-# CONFIG_CPU_SUBTYPE_SH7300 is not set
-# CONFIG_CPU_SUBTYPE_SH7707 is not set
-# CONFIG_CPU_SUBTYPE_SH7708 is not set
-# CONFIG_CPU_SUBTYPE_SH7709 is not set
-# CONFIG_CPU_SUBTYPE_SH7750 is not set
-CONFIG_CPU_SUBTYPE_SH7751=y
-# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
-CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
-CONFIG_MEMORY_START=0x08000000
-CONFIG_MEMORY_SIZE=0x01000000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
-CONFIG_SH_RTC=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
-# CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_FREQ=60013568
-# CONFIG_CPU_FREQ is not set
-CONFIG_SH_DMA=y
-CONFIG_NR_DMA_CHANNELS=8
-# CONFIG_DMA_PAGE_OPS is not set
-
-#
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
-#
-CONFIG_PCI=y
-# CONFIG_SH_PCIDMA_NONCOHERENT is not set
-CONFIG_PCI_AUTO=y
-CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
-CONFIG_PCI_DMA=y
-# CONFIG_PCI_LEGACY_PROC is not set
-CONFIG_PCI_NAMES=y
-# CONFIG_HOTPLUG is not set
-
-#
-# Executable file formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_FLAT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Generic Driver Options
-#
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_LBD is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_SCSI is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# IEEE 1394 (FireWire) support (EXPERIMENTAL)
-#
-# CONFIG_IEEE1394 is not set
-
-#
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-# CONFIG_PACKET is not set
-# CONFIG_NETLINK_DEV is not set
-# CONFIG_UNIX is not set
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_INET_ECN is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_IPV6 is not set
-# CONFIG_DECNET is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_NETFILTER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-CONFIG_IPV6_SCTP__=y
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_LLC is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_FASTROUTE is not set
-# CONFIG_NET_HW_FLOWCONTROL is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-CONFIG_NETDEVICES=y
-
-#
-# ARCnet devices
-#
-# CONFIG_ARCNET is not set
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-
-#
-# Ethernet (10 or 100Mbit)
-#
-CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
-# CONFIG_STNIC is not set
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_NET_VENDOR_3COM is not set
-
-#
-# Tulip family network device support
-#
-# CONFIG_NET_TULIP is not set
-# CONFIG_HP100 is not set
-CONFIG_NET_PCI=y
-# CONFIG_PCNET32 is not set
-# CONFIG_AMD8111_ETH is not set
-# CONFIG_ADAPTEC_STARFIRE is not set
-# CONFIG_B44 is not set
-# CONFIG_DGRS is not set
-# CONFIG_EEPRO100 is not set
-# CONFIG_E100 is not set
-# CONFIG_FEALNX is not set
-# CONFIG_NATSEMI is not set
-# CONFIG_NE2K_PCI is not set
-# CONFIG_8139CP is not set
-CONFIG_8139TOO=y
-# CONFIG_8139TOO_PIO is not set
-# CONFIG_8139TOO_TUNE_TWISTER is not set
-# CONFIG_8139TOO_8129 is not set
-# CONFIG_8139_OLD_RX_RESET is not set
-# CONFIG_SIS900 is not set
-# CONFIG_EPIC100 is not set
-# CONFIG_SUNDANCE is not set
-# CONFIG_TLAN is not set
-# CONFIG_VIA_RHINE is not set
-
-#
-# Ethernet (1000 Mbit)
-#
-# CONFIG_ACENIC is not set
-# CONFIG_DL2K is not set
-# CONFIG_E1000 is not set
-# CONFIG_NS83820 is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_YELLOWFIN is not set
-# CONFIG_R8169 is not set
-# CONFIG_SIS190 is not set
-# CONFIG_SK98LIN is not set
-# CONFIG_TIGON3 is not set
-
-#
-# Ethernet (10000 Mbit)
-#
-# CONFIG_IXGB is not set
-# CONFIG_FDDI is not set
-# CONFIG_HIPPI is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-
-#
-# Wireless LAN (non-hamradio)
-#
-# CONFIG_NET_RADIO is not set
-
-#
-# Token Ring devices (depends on LLC=y)
-#
-# CONFIG_RCPCI is not set
-# CONFIG_SHAPER is not set
-
-#
-# Wan interfaces
-#
-# CONFIG_WAN is not set
-
-#
-# Amateur Radio support
-#
-# CONFIG_HAMRADIO is not set
-
-#
-# IrDA (infrared) support
-#
-# CONFIG_IRDA is not set
-
-#
-# ISDN subsystem
-#
-# CONFIG_ISDN_BOOL is not set
-
-#
-# Telephony Support
-#
-# CONFIG_PHONE is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-
-#
-# Userland interfaces
-#
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-# CONFIG_SERIO is not set
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_SERIAL is not set
-CONFIG_SH_SCI=y
-CONFIG_SERIAL_CONSOLE=y
-
-#
-# Unix 98 PTY support
-#
-CONFIG_UNIX98_PTYS=y
-CONFIG_UNIX98_PTY_COUNT=256
-# CONFIG_PSMOUSE is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
-# CONFIG_RTC is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_SH_SCI is not set
-
-#
-# I2C support
-#
-# CONFIG_I2C is not set
-
-#
-# I2C Hardware Sensors Mainboard support
-#
-
-#
-# I2C Hardware Sensors Chip support
-#
-# CONFIG_I2C_SENSOR is not set
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_MINIX_FS is not set
-CONFIG_ROMFS_FS=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_FAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
-CONFIG_DEVPTS_FS=y
-# CONFIG_DEVPTS_FS_XATTR is not set
-CONFIG_TMPFS=y
-CONFIG_RAMFS=y
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_CRAMFS=y
-# CONFIG_VXFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-
-#
-# Network File Systems
-#
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
-CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_GSS is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
-# CONFIG_AFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-
-#
-# Multimedia devices
-#
-# CONFIG_VIDEO_DEV is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-# CONFIG_DVB is not set
-
-#
-# Graphics support
-#
-# CONFIG_FB is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-
-#
-# USB support
-#
-# CONFIG_USB is not set
-# CONFIG_USB_GADGET is not set
-
-#
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_SH_STANDARD_BIOS is not set
-# CONFIG_KGDB is not set
-# CONFIG_FRAME_POINTER is not set
-
-#
-# Security options
-#
-# CONFIG_SECURITY is not set
-
-#
-# Cryptographic options
-#
-# CONFIG_CRYPTO is not set
-
-#
-# Library routines
-#
-# CONFIG_CRC32 is not set
-CONFIG_ZLIB_INFLATE=y
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-systemh linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-systemh
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/defconfig-systemh	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/defconfig-systemh	1970-01-01 00:00:00.000000000 +0000
@@ -1,372 +0,0 @@
-#
-# Automatically generated make config: don't edit
-#
-CONFIG_SUPERH=y
-CONFIG_UID16=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-# CONFIG_CLEAN_COMPILE is not set
-# CONFIG_STANDALONE is not set
-CONFIG_BROKEN=y
-CONFIG_BROKEN_ON_SMP=y
-
-#
-# General setup
-#
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_SYSCTL is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_IKCONFIG is not set
-CONFIG_EMBEDDED=y
-CONFIG_KALLSYMS=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-
-#
-# Loadable module support
-#
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODULE_FORCE_UNLOAD is not set
-CONFIG_OBSOLETE_MODPARM=y
-# CONFIG_MODVERSIONS is not set
-# CONFIG_KMOD is not set
-
-#
-# System type
-#
-# CONFIG_SH_SOLUTION_ENGINE is not set
-# CONFIG_SH_7751_SOLUTION_ENGINE is not set
-CONFIG_SH_7751_SYSTEMH=y
-# CONFIG_SH_STB1_HARP is not set
-# CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-# CONFIG_SH_HP680 is not set
-# CONFIG_SH_HP690 is not set
-# CONFIG_SH_CQREEK is not set
-# CONFIG_SH_DMIDA is not set
-# CONFIG_SH_EC3104 is not set
-# CONFIG_SH_SATURN is not set
-# CONFIG_SH_DREAMCAST is not set
-# CONFIG_SH_CAT68701 is not set
-# CONFIG_SH_BIGSUR is not set
-# CONFIG_SH_SH2000 is not set
-# CONFIG_SH_ADX is not set
-# CONFIG_SH_MPC1211 is not set
-# CONFIG_SH_SECUREEDGE5410 is not set
-# CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-# CONFIG_CPU_SH3 is not set
-CONFIG_CPU_SH4=y
-# CONFIG_CPU_SUBTYPE_SH7604 is not set
-# CONFIG_CPU_SUBTYPE_SH7300 is not set
-# CONFIG_CPU_SUBTYPE_SH7707 is not set
-# CONFIG_CPU_SUBTYPE_SH7708 is not set
-# CONFIG_CPU_SUBTYPE_SH7709 is not set
-# CONFIG_CPU_SUBTYPE_SH7750 is not set
-CONFIG_CPU_SUBTYPE_SH7751=y
-# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
-CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x00400000
-# CONFIG_MEMORY_OVERRIDE is not set
-CONFIG_SH_RTC=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-CONFIG_PREEMPT=y
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
-# CONFIG_SH_STORE_QUEUES is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_FREQ=49876504
-# CONFIG_CPU_FREQ is not set
-# CONFIG_SH_DMA is not set
-
-#
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
-#
-CONFIG_PCI=y
-# CONFIG_SH_PCIDMA_NONCOHERENT is not set
-CONFIG_PCI_AUTO=y
-CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
-CONFIG_PCI_DMA=y
-CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
-# CONFIG_HOTPLUG is not set
-
-#
-# Executable file formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_FLAT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# Generic Driver Options
-#
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Block devices
-#
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_LOOP is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=1024
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_LBD is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-# CONFIG_SCSI is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# IEEE 1394 (FireWire) support (EXPERIMENTAL)
-#
-# CONFIG_IEEE1394 is not set
-
-#
-# Networking support
-#
-# CONFIG_NET is not set
-
-#
-# Amateur Radio support
-#
-# CONFIG_HAMRADIO is not set
-
-#
-# ISDN subsystem
-#
-
-#
-# Telephony Support
-#
-# CONFIG_PHONE is not set
-
-#
-# Input device support
-#
-# CONFIG_INPUT is not set
-
-#
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-
-#
-# Input Device Drivers
-#
-
-#
-# Character devices
-#
-# CONFIG_VT is not set
-# CONFIG_SERIAL is not set
-CONFIG_SH_SCI=y
-CONFIG_SERIAL_CONSOLE=y
-
-#
-# Unix 98 PTY support
-#
-CONFIG_UNIX98_PTYS=y
-CONFIG_UNIX98_PTY_COUNT=256
-# CONFIG_PSMOUSE is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
-# CONFIG_RTC is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_SH_SCI is not set
-
-#
-# I2C support
-#
-# CONFIG_I2C is not set
-
-#
-# I2C Algorithms
-#
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C Hardware Sensors Chip support
-#
-# CONFIG_I2C_SENSOR is not set
-
-#
-# File systems
-#
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_MINIX_FS is not set
-CONFIG_ROMFS_FS=y
-# CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_FAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
-CONFIG_DEVPTS_FS=y
-# CONFIG_DEVPTS_FS_XATTR is not set
-CONFIG_TMPFS=y
-# CONFIG_HUGETLBFS is not set
-# CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_CRAMFS=y
-# CONFIG_VXFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-
-#
-# Multimedia devices
-#
-# CONFIG_VIDEO_DEV is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-
-#
-# Graphics support
-#
-# CONFIG_FB is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-
-#
-# USB support
-#
-# CONFIG_USB is not set
-# CONFIG_USB_GADGET is not set
-
-#
-# Profiling support
-#
-# CONFIG_PROFILING is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_MAGIC_SYSRQ is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_SH_STANDARD_BIOS is not set
-# CONFIG_KGDB is not set
-# CONFIG_FRAME_POINTER is not set
-
-#
-# Security options
-#
-# CONFIG_SECURITY is not set
-
-#
-# Cryptographic options
-#
-# CONFIG_CRYPTO is not set
-
-#
-# Library routines
-#
-CONFIG_CRC32=y
-CONFIG_ZLIB_INFLATE=y
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/dreamcast_defconfig linux-post-2.6.5-rc2-20040326/arch/sh/configs/dreamcast_defconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/dreamcast_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/dreamcast_defconfig	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,715 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_SYSCTL=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+CONFIG_SH_DREAMCAST=y
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+CONFIG_CPU_SUBTYPE_SH7750=y
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+CONFIG_MMU=y
+CONFIG_HUGETLB_PAGE_SIZE_64K=y
+# CONFIG_HUGETLB_PAGE_SIZE_1MB is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_MEMORY_SIZE=0x01000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_PREEMPT=y
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+CONFIG_SH_OCRAM=y
+CONFIG_SH_STORE_QUEUES=y
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_FREQ=49876504
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+# CONFIG_CPU_FREQ_PROC_INTF is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_24_API is not set
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_SH_CPU_FREQ=y
+CONFIG_SH_DMA=y
+CONFIG_NR_ONCHIP_DMA_CHANNELS=4
+CONFIG_NR_DMA_CHANNELS_BOOL=y
+CONFIG_NR_DMA_CHANNELS=9
+# CONFIG_HD6446X_SERIES is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_MAPLE=y
+CONFIG_PCI=y
+# CONFIG_SH_PCIDMA_NONCOHERENT is not set
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_NAMES=y
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IPV6_SCTP__=y
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_8139_RXBUF_IDX=1
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_MAPLE is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_MAPLE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_SH_WDT=y
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+CONFIG_FB_PVR2=y
+# CONFIG_FB_E1355 is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON_OLD is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_PCI_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+# CONFIG_LOGO_SUPERH_MONO is not set
+# CONFIG_LOGO_SUPERH_VGA16 is not set
+CONFIG_LOGO_SUPERH_CLUT224=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Maple Bus input peripherals
+#
+# CONFIG_MAPLE_KEYBOARD is not set
+# CONFIG_MAPLE_MOUSE is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_GSS is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+
+#
+# Kernel hacking
+#
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_KGDB is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+CONFIG_ZLIB_INFLATE=y
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/hp680_defconfig linux-post-2.6.5-rc2-20040326/arch/sh/configs/hp680_defconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/hp680_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/hp680_defconfig	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,418 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP620 is not set
+CONFIG_SH_HP680=y
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+CONFIG_CPU_SH3=y
+# CONFIG_CPU_SH4 is not set
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+CONFIG_CPU_SUBTYPE_SH7709=y
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_MEMORY_SIZE=0x00400000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+# CONFIG_SH_DSP is not set
+CONFIG_SH_HP600=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_FREQ=1193182
+# CONFIG_CPU_FREQ is not set
+# CONFIG_SH_DMA is not set
+CONFIG_HD6446X_SERIES=y
+CONFIG_HD64461=y
+# CONFIG_HD64465 is not set
+CONFIG_HD64461_IRQ=36
+# CONFIG_HD64461_ENABLER is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+# CONFIG_HOTPLUG is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_IDEDISK_STROKE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+
+#
+# Unix98 PTY support
+#
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_PSMOUSE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_E1355 is not set
+CONFIG_FB_HIT=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_PCI_CONSOLE=y
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+CONFIG_FONT_PEARL_8x8=y
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_KGDB is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/se7751_defconfig linux-post-2.6.5-rc2-20040326/arch/sh/configs/se7751_defconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/se7751_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/se7751_defconfig	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,617 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_SYSCTL=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+CONFIG_SH_7751_SOLUTION_ENGINE=y
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+CONFIG_CPU_SUBTYPE_SH7751=y
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+CONFIG_MMU=y
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="console=ttySC1,38400"
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+CONFIG_ZERO_PAGE_OFFSET=0x00010000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_FREQ=60013568
+# CONFIG_CPU_FREQ is not set
+# CONFIG_SH_DMA is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_SH_PCIDMA_NONCOHERENT is not set
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+CONFIG_PCI_DMA=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+# CONFIG_HOTPLUG is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_CHAR is not set
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_RAM=y
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_MPC1211 is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_NETLINK_DEV=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_DEBUG=y
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+CONFIG_IP_NF_QUEUE=y
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IPV6_SCTP__=y
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN_BOOL is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+CONFIG_SH_SCI=y
+CONFIG_SERIAL_CONSOLE=y
+
+#
+# Unix 98 PTY support
+#
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+CONFIG_HEARTBEAT=y
+# CONFIG_PSMOUSE is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+# CONFIG_SH_WDT is not set
+# CONFIG_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# I2C Algorithms
+#
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+# CONFIG_DEVFS_FS is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_EXPORTFS is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_KGDB is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/snapgear_defconfig linux-post-2.6.5-rc2-20040326/arch/sh/configs/snapgear_defconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/snapgear_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/snapgear_defconfig	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,540 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+CONFIG_SH_SECUREEDGE5410=y
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+CONFIG_CPU_SUBTYPE_SH7751=y
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x01000000
+CONFIG_MEMORY_SET=y
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+# CONFIG_PREEMPT is not set
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_FREQ=60013568
+# CONFIG_CPU_FREQ is not set
+CONFIG_SH_DMA=y
+CONFIG_NR_DMA_CHANNELS=8
+# CONFIG_DMA_PAGE_OPS is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_SH_PCIDMA_NONCOHERENT is not set
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+CONFIG_PCI_DMA=y
+# CONFIG_PCI_LEGACY_PROC is not set
+CONFIG_PCI_NAMES=y
+# CONFIG_HOTPLUG is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_UNIX is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IPV6_SCTP__=y
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_LLC is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_STNIC is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices (depends on LLC=y)
+#
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN_BOOL is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+CONFIG_SH_SCI=y
+CONFIG_SERIAL_CONSOLE=y
+
+#
+# Unix 98 PTY support
+#
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+# CONFIG_PSMOUSE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# I2C Hardware Sensors Mainboard support
+#
+
+#
+# I2C Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_GSS is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_KGDB is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=y
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/configs/systemh_defconfig linux-post-2.6.5-rc2-20040326/arch/sh/configs/systemh_defconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/configs/systemh_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/configs/systemh_defconfig	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,372 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+CONFIG_SH_7751_SYSTEMH=y
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+# CONFIG_SH_HP620 is not set
+# CONFIG_SH_HP680 is not set
+# CONFIG_SH_HP690 is not set
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_UNKNOWN is not set
+# CONFIG_CPU_SH2 is not set
+# CONFIG_CPU_SH3 is not set
+CONFIG_CPU_SH4=y
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+# CONFIG_CPU_SUBTYPE_SH7709 is not set
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+CONFIG_CPU_SUBTYPE_SH7751=y
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+CONFIG_MMU=y
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_MEMORY_SIZE=0x00400000
+# CONFIG_MEMORY_OVERRIDE is not set
+CONFIG_SH_RTC=y
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_PREEMPT=y
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+# CONFIG_SH_STORE_QUEUES is not set
+# CONFIG_SMP is not set
+CONFIG_SH_PCLK_FREQ=49876504
+# CONFIG_CPU_FREQ is not set
+# CONFIG_SH_DMA is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_SH_PCIDMA_NONCOHERENT is not set
+CONFIG_PCI_AUTO=y
+CONFIG_PCI_AUTO_UPDATE_RESOURCES=y
+CONFIG_PCI_DMA=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_NAMES=y
+# CONFIG_HOTPLUG is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Generic Driver Options
+#
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# Networking support
+#
+# CONFIG_NET is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+CONFIG_SH_SCI=y
+CONFIG_SERIAL_CONSOLE=y
+
+#
+# Unix 98 PTY support
+#
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+# CONFIG_PSMOUSE is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# I2C Algorithms
+#
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_KGDB is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+CONFIG_ZLIB_INFLATE=y
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/drivers/dma/Kconfig linux-post-2.6.5-rc2-20040326/arch/sh/drivers/dma/Kconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/drivers/dma/Kconfig	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/drivers/dma/Kconfig	2004-03-23 10:05:26.000000000 +0000
@@ -1,3 +1,5 @@
+menu "DMA support"
+
 config SH_DMA
 	bool "DMA controller (DMAC) support"
 	help
@@ -34,9 +36,20 @@ config NR_DMA_CHANNELS
 
 config DMA_PAGE_OPS
 	bool "Use DMAC for page copy/clear"
-	depends on SH_DMA
+	depends on SH_DMA && BROKEN
 	help
 	  Selecting this option will use a dual-address mode configured channel
 	  in the SH DMAC for copy_page()/clear_page(). Primarily a performance
 	  hack.
 
+config DMA_PAGE_OPS_CHANNEL
+	depends on DMA_PAGE_OPS
+	int "DMA channel for sh memory-manager page copy/clear"
+	default "3"
+	help
+	  This allows the specification of the dual address dma channel,
+	  in case channel 3 is unavailable. On the SH4, channels 1,2, and 3
+	  are dual-address capable.
+
+endmenu
+
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/drivers/dma/dma-api.c linux-post-2.6.5-rc2-20040326/arch/sh/drivers/dma/dma-api.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/drivers/dma/dma-api.c	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/drivers/dma/dma-api.c	2004-03-23 10:05:26.000000000 +0000
@@ -104,6 +104,11 @@ void dma_wait_for_completion(unsigned in
 {
 	struct dma_info *info = get_dma_info(chan);
 
+	if (info->tei_capable) {
+		wait_event(info->wait_queue, (info->ops->get_residue(info) == 0));
+		return;
+	}
+
 	while (info->ops->get_residue(info))
 		cpu_relax();
 }
@@ -161,6 +166,7 @@ int __init register_dmac(struct dma_ops 
 		info->chan = i;
 
 		init_MUTEX(&info->sem);
+		init_waitqueue_head(&info->wait_queue);
 	}
 
 	return 0;
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/drivers/dma/dma-sh.c linux-post-2.6.5-rc2-20040326/arch/sh/drivers/dma/dma-sh.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/drivers/dma/dma-sh.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/drivers/dma/dma-sh.c	2004-03-23 10:05:26.000000000 +0000
@@ -55,9 +55,9 @@ struct sh_dmac_channel {
 } __attribute__ ((aligned(16)));
 
 struct sh_dmac_info {
-        struct sh_dmac_channel channel[MAX_DMAC_CHANNELS];
+        struct sh_dmac_channel channel[4];
         unsigned long dmaor;
-} __attribute__ ((packed));
+};
 
 static volatile struct sh_dmac_info *sh_dmac = (volatile struct sh_dmac_info *)SH_DMAC_BASE;
 
@@ -74,25 +74,12 @@ static inline unsigned int get_dmte_irq(
 	if (chan < 4) {
 		irq = DMTE0_IRQ + chan;
 	} else {
-		irq = DMTE4_IRQ + chan;
+		irq = DMTE4_IRQ + chan - 4;
 	}
 
 	return irq;
 }
 
-static inline int get_dmte_chan(unsigned int irq)
-{
-	int chan;
-
-	if ((irq - DMTE4_IRQ) < 0) {
-		chan = irq - DMTE0_IRQ;
-	} else {
-		chan = irq - DMTE4_IRQ + 4;
-	}
-
-	return chan;
-}
-
 /*
  * We determine the correct shift size based off of the CHCR transmit size
  * for the given channel. Since we know that it will take:
@@ -106,54 +93,42 @@ static inline unsigned int calc_xmit_shi
 	return ts_shift[(sh_dmac->channel[info->chan].chcr >> 4) & 0x0007];
 }
 
+/*
+ * The transfer end interrupt must read the chcr register to end the
+ * hardware interrupt active condition.
+ * Besides that it needs to waken any waiting process, which should handle
+ * setting up the next transfer.
+ */
 static irqreturn_t dma_tei(int irq, void *dev_id, struct pt_regs *regs)
 {
-	
-	int chan = get_dmte_chan(irq);
-	struct dma_info *info = get_dma_info(chan);
+	struct dma_info * info = (struct dma_info *)dev_id;
+	u32 chcr = sh_dmac->channel[info->chan].chcr;
 
-	if (info->sar)
-		sh_dmac->channel[info->chan].sar = info->sar;
-	if (info->dar)
-		sh_dmac->channel[info->chan].sar = info->dar;
+	if (!(chcr & CHCR_TE))
+		return IRQ_NONE;
 
-	sh_dmac->channel[info->chan].dmatcr = info->count >> calc_xmit_shift(info);
-	sh_dmac->channel[info->chan].chcr &= ~CHCR_TE;
+	sh_dmac->channel[info->chan].chcr = chcr & ~(CHCR_IE | CHCR_DE);
 
-	disable_irq(irq);
+	wake_up(&info->wait_queue);
 
 	return IRQ_HANDLED;
 }
 
-static struct irqaction irq_tei = {
-	.name		= "DMAC Transfer End",
-	.handler	= dma_tei,
-	.flags		= SA_INTERRUPT,
-};
-
 static int sh_dmac_request_dma(struct dma_info *info)
 {
-	int irq = get_dmte_irq(info->chan);
-	char *p = (char *)((&irq_tei)->name);
-
-	sprintf(p, "%s (Channel %d)", p, info->chan);
-
-	make_ipr_irq(irq, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
-
-	return setup_irq(irq, &irq_tei);
+	return request_irq(get_dmte_irq(info->chan), dma_tei,
+			   SA_INTERRUPT, "DMAC Transfer End", info);
 }
 
 static void sh_dmac_free_dma(struct dma_info *info)
 {
-	free_irq(get_dmte_irq(info->chan), 0);
+	free_irq(get_dmte_irq(info->chan), info);
 }
 
 static void sh_dmac_configure_channel(struct dma_info *info, unsigned long chcr)
 {
-	if (!chcr) {
-		chcr = sh_dmac->channel[info->chan].chcr;
-		chcr |= /* CHCR_IE | */ RS_DUAL;
-	}
+	if (!chcr)
+		chcr = RS_DUAL;
 
 	sh_dmac->channel[info->chan].chcr = chcr;
 
@@ -162,12 +137,18 @@ static void sh_dmac_configure_channel(st
 
 static void sh_dmac_enable_dma(struct dma_info *info)
 {
-	sh_dmac->channel[info->chan].chcr |= CHCR_DE;
+	int irq = get_dmte_irq(info->chan);
+
+	sh_dmac->channel[info->chan].chcr |= (CHCR_DE | CHCR_IE);
+	enable_irq(irq);
 }
 
 static void sh_dmac_disable_dma(struct dma_info *info)
 {
-	sh_dmac->channel[info->chan].chcr &= ~(CHCR_DE | CHCR_TE);
+	int irq = get_dmte_irq(info->chan);
+
+	disable_irq(irq);
+	sh_dmac->channel[info->chan].chcr &= ~(CHCR_DE | CHCR_TE | CHCR_IE);
 }
 
 static int sh_dmac_xfer_dma(struct dma_info *info)
@@ -191,10 +172,14 @@ static int sh_dmac_xfer_dma(struct dma_i
 	 * In this case, only one address can be defined, anything else will
 	 * result in a DMA address error interrupt (at least on the SH-4),
 	 * which will subsequently halt the transfer.
+	 *
+	 * Channel 2 on the Dreamcast is a special case, as this is used for
+	 * cascading to the PVR2 DMAC. In this case, we still need to write
+	 * SAR and DAR, regardless of value, in order for cascading to work.
 	 */
-	if (info->sar)
+	if (info->sar || (mach_is_dreamcast() && info->chan == 2))
 		sh_dmac->channel[info->chan].sar = info->sar;
-	if (info->dar)
+	if (info->dar || (mach_is_dreamcast() && info->chan == 2))
 		sh_dmac->channel[info->chan].dar = info->dar;
 	
 	sh_dmac->channel[info->chan].dmatcr = info->count >> calc_xmit_shift(info);
@@ -206,6 +191,9 @@ static int sh_dmac_xfer_dma(struct dma_i
 
 static int sh_dmac_get_dma_residue(struct dma_info *info)
 {
+	if (!(sh_dmac->channel[info->chan].chcr & CHCR_DE))
+		return 0;
+
 	return sh_dmac->channel[info->chan].dmatcr << calc_xmit_shift(info);
 }
 
@@ -221,12 +209,6 @@ static irqreturn_t dma_err(int irq, void
 
 	return IRQ_HANDLED;
 }
-
-static struct irqaction irq_err = {
-	.name		= "DMAC Address Error",
-	.handler	= dma_err,
-	.flags		= SA_INTERRUPT,
-};
 #endif
 
 static struct dma_ops sh_dmac_ops = {
@@ -244,15 +226,21 @@ static int __init sh_dmac_init(void)
 
 #ifdef CONFIG_CPU_SH4
 	make_ipr_irq(DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
-	setup_irq(DMAE_IRQ, &irq_err);
+	i = request_irq(DMAE_IRQ, dma_err, SA_INTERRUPT, "DMAC Address Error", 0);
+	if (i < 0)
+		return i;
 #endif
 
-	/* Kick the DMAOR */
-	sh_dmac->dmaor |= DMAOR_DME /* | 0x200 */ | 0x8000;	/* DDT = 1, PR1 = 1, DME = 1 */
-	sh_dmac->dmaor &= ~(DMAOR_NMIF | DMAOR_AE);
+	for (i = 0; i < MAX_DMAC_CHANNELS; i++) {
+		int irq = get_dmte_irq(i);
+
+		make_ipr_irq(irq, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
+
+		dma_info[i].ops = &sh_dmac_ops;
+		dma_info[i].tei_capable = 1;
+	}
 
-	for (i = 0; i < MAX_DMAC_CHANNELS; i++)
-		dma_info[i].ops  = &sh_dmac_ops;
+	sh_dmac->dmaor |= 0x8000 | DMAOR_DME;
 
 	return register_dmac(&sh_dmac_ops);
 }
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/drivers/dma/dma-sh.h linux-post-2.6.5-rc2-20040326/arch/sh/drivers/dma/dma-sh.h
--- linux-post-2.6.5-rc2-20040323/arch/sh/drivers/dma/dma-sh.h	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/drivers/dma/dma-sh.h	2004-03-23 10:05:26.000000000 +0000
@@ -24,7 +24,6 @@
 #define DM_DEC	0x00008000
 #define SM_INC	0x00001000
 #define SM_DEC	0x00002000
-#define RS_DUAL	0x00000000
 #define RS_IN	0x00000200
 #define RS_OUT	0x00000300
 #define TM_BURST 0x0000080
@@ -37,6 +36,11 @@
 #define CHCR_TE 0x00000002
 #define CHCR_IE 0x00000004
 
+/* Define the default configuration for dual address memory-memory transfer.
+ * The 0x400 value represents auto-request, external->external.
+ */
+#define RS_DUAL	(DM_INC | SM_INC | 0x400 | TS_32)
+
 #define DMAOR_COD	0x00000008
 #define DMAOR_AE	0x00000004
 #define DMAOR_NMIF	0x00000002
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/drivers/pci/Kconfig linux-post-2.6.5-rc2-20040326/arch/sh/drivers/pci/Kconfig
--- linux-post-2.6.5-rc2-20040323/arch/sh/drivers/pci/Kconfig	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/drivers/pci/Kconfig	2004-03-23 10:05:26.000000000 +0000
@@ -14,6 +14,7 @@ config PCI
 config SH_PCIDMA_NONCOHERENT
 	bool "Cache and PCI noncoherent"
 	depends on PCI
+	default y
 	help
 	  Enable this option if your platform does not have a CPU cache which
 	  remains coherent with PCI DMA. It is safest to say 'Y', although you
@@ -39,8 +40,3 @@ config PCI_AUTO_UPDATE_RESOURCES
 	  with its resources updated beyond what they are when the device
 	  is powered up, set this to N. Everyone else will want this as Y.
 
-config PCI_DMA
-	bool
-	depends on PCI
-	default y if !SH_DREAMCAST
-
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/drivers/pci/Makefile linux-post-2.6.5-rc2-20040326/arch/sh/drivers/pci/Makefile
--- linux-post-2.6.5-rc2-20040323/arch/sh/drivers/pci/Makefile	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/drivers/pci/Makefile	2004-03-23 10:05:26.000000000 +0000
@@ -4,7 +4,6 @@
 
 obj-y					+= pci.o
 obj-$(CONFIG_PCI_AUTO)			+= pci-auto.o
-obj-$(CONFIG_PCI_DMA)			+= pci-dma.o
 
 obj-$(CONFIG_CPU_SUBTYPE_ST40STB1)	+= pci-st40.o
 obj-$(CONFIG_CPU_SUBTYPE_SH7751)	+= pci-sh7751.o 
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/drivers/pci/dma-dreamcast.c linux-post-2.6.5-rc2-20040326/arch/sh/drivers/pci/dma-dreamcast.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/drivers/pci/dma-dreamcast.c	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/drivers/pci/dma-dreamcast.c	2004-03-23 10:05:26.000000000 +0000
@@ -30,7 +30,7 @@
 
 static int gapspci_dma_used = 0;
 
-void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
+void *__pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
 			   dma_addr_t * dma_handle)
 {
 	unsigned long buf;
@@ -52,7 +52,7 @@ void *pci_alloc_consistent(struct pci_de
 	return (void *)buf;
 }
 
-void pci_free_consistent(struct pci_dev *hwdev, size_t size,
+void __pci_free_consistent(struct pci_dev *hwdev, size_t size,
 			 void *vaddr, dma_addr_t dma_handle)
 {
 	/* XXX */
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/drivers/pci/pci-dma.c linux-post-2.6.5-rc2-20040326/arch/sh/drivers/pci/pci-dma.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/drivers/pci/pci-dma.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/drivers/pci/pci-dma.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,42 +0,0 @@
-/* 
- * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.                            
- *
- * Dynamic DMA mapping support.
- */
-
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/string.h>
-#include <linux/pci.h>
-#include <asm/io.h>
-#include <asm/addrspace.h>
-
-
-void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
-			   dma_addr_t * dma_handle)
-{
-	void *ret;
-	int gfp = GFP_ATOMIC;
-
-	ret = (void *) __get_free_pages(gfp, get_order(size));
-
-	if (ret != NULL) {
-	        /* Is it necessary to do the memset? */
-		memset(ret, 0, size);
-		*dma_handle = virt_to_phys(ret);
-	}
-	/* We must flush the cache before we pass it on to the device */
-	dma_cache_wback_inv(ret, size);
-	return  P2SEGADDR(ret);
-}
-
-void pci_free_consistent(struct pci_dev *hwdev, size_t size,
-			 void *vaddr, dma_addr_t dma_handle)
-{
-        unsigned long p1addr=P1SEGADDR((unsigned long)vaddr);
-
-	free_pages(p1addr, get_order(size));
-}
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/cf-enabler.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/cf-enabler.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/cf-enabler.c	2003-05-04 15:29:52.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/cf-enabler.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: cf-enabler.c,v 1.3 2003/05/04 19:29:52 lethal Exp $
+/* $Id: cf-enabler.c,v 1.4 2004/02/22 22:44:36 kkojima Exp $
  *
  *  linux/drivers/block/cf-enabler.c
  *
@@ -88,7 +88,7 @@ static int __init cf_init_default(void)
 }
 
 #if defined(CONFIG_SH_SOLUTION_ENGINE)
-#include <asm/hitachi_se.h>
+#include <asm/se/se.h>
 
 /*
  * SolutionEngine
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/cpu/irq_ipr.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/cpu/irq_ipr.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/cpu/irq_ipr.c	2003-05-04 15:29:53.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/cpu/irq_ipr.c	2004-03-23 10:05:27.000000000 +0000
@@ -196,6 +196,7 @@ void __init init_IRQ(void)
 #endif
 
 	make_ipr_irq(TIMER_IRQ, TIMER_IPR_ADDR, TIMER_IPR_POS, TIMER_PRIORITY);
+	make_ipr_irq(TIMER1_IRQ, TIMER1_IPR_ADDR, TIMER1_IPR_POS, TIMER1_PRIORITY);
 	make_ipr_irq(RTC_IRQ, RTC_IPR_ADDR, RTC_IPR_POS, RTC_PRIORITY);
 
 #ifdef SCI_ERI_IRQ
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/cpu/sh4/sq.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/cpu/sh4/sq.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/cpu/sh4/sq.c	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/cpu/sh4/sq.c	2004-03-23 10:05:27.000000000 +0000
@@ -3,13 +3,13 @@
  *
  * General management API for SH-4 integrated Store Queues
  *
- * Copyright (C) 2001, 2002, 2003  Paul Mundt
+ * Copyright (C) 2001, 2002, 2003, 2004  Paul Mundt
  * Copyright (C) 2001, 2002  M. R. Brown
  *
  * Some of this code has been adopted directly from the old arch/sh/mm/sq.c
- * hack that was part of the LinuxDC project. For all intensive purposes, this
- * is a completely new interface that really doesn't have much in common with
- * the old zone-based approach at all. Infact, I'm only listing it here for
+ * hack that was part of the LinuxDC project. For all intents and purposes,
+ * this is a completely new interface that really doesn't have much in common
+ * with the old zone-based approach at all. In fact, it's only listed here for
  * general completeness.
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -24,6 +24,7 @@
 #include <linux/list.h>
 #include <linux/proc_fs.h>
 #include <linux/miscdevice.h>
+#include <linux/vmalloc.h>
 
 #include <asm/io.h>
 #include <asm/page.h>
@@ -31,6 +32,9 @@
 #include <asm/cpu/sq.h>
 
 static LIST_HEAD(sq_mapping_list);
+static spinlock_t sq_mapping_lock = SPIN_LOCK_UNLOCKED;
+
+extern struct vm_struct *__get_vm_area(unsigned long size, unsigned long flags, unsigned long start, unsigned long end);
 
 /**
  * sq_flush - Flush (prefetch) the store queue cache
@@ -42,7 +46,7 @@ static LIST_HEAD(sq_mapping_list);
  */
 inline void sq_flush(void *addr)
 {
-	__asm__ __volatile__ ("pref @%0": "=r" (addr) : : "memory");
+	__asm__ __volatile__ ("pref @%0" : : "r" (addr) : "memory");
 }
 
 /**
@@ -57,13 +61,17 @@ inline void sq_flush(void *addr)
 void sq_flush_range(unsigned long start, unsigned int len)
 {
 	volatile unsigned long *sq = (unsigned long *)start;
+	unsigned long dummy;
 
 	/* Flush the queues */
 	for (len >>= 5; len--; sq += 8)
 		sq_flush((void *)sq);
-	
+
 	/* Wait for completion */
-	sq = (volatile unsigned long *)start;
+	dummy = ctrl_inl(P4SEG_STORE_QUE);
+
+	ctrl_outl(0, P4SEG_STORE_QUE + 0);
+	ctrl_outl(0, P4SEG_STORE_QUE + 8);
 }
 
 static struct sq_mapping *__sq_alloc_mapping(unsigned long virt, unsigned long phys, unsigned long size, const char *name)
@@ -81,7 +89,7 @@ static struct sq_mapping *__sq_alloc_map
 
 	map->sq_addr	= virt;
 	map->addr	= phys;
-	map->size	= size;
+	map->size	= size + 1;
 	map->name	= name;
 
 	list_add(&map->list, &sq_mapping_list);
@@ -128,24 +136,20 @@ static unsigned long __sq_get_next_addr(
  */
 static struct sq_mapping *__sq_remap(struct sq_mapping *map)
 {
-	/*
-	 * First check the MMU status..
-	 */
-#ifndef CONFIG_MMU
+	unsigned long flags, pteh, ptel;
+	struct vm_struct *vma;
+	pgprot_t pgprot;
+
 	/*
 	 * Without an MMU (or with it turned off), this is much more
 	 * straightforward, as we can just load up each queue's QACR with
 	 * the physical address appropriately masked.
 	 */
+
 	ctrl_outl(((map->addr >> 26) << 2) & 0x1c, SQ_QACR0);
 	ctrl_outl(((map->addr >> 26) << 2) & 0x1c, SQ_QACR1);
-#else
-	unsigned long flags, pteh, ptel;
-	pgprot_t pgprot;
-	pgd_t *pgd;
-	pmd_t *pmd;
-	pte_t *pte;
 
+#ifdef CONFIG_MMU
 	/*
 	 * With an MMU on the other hand, things are slightly more involved.
 	 * Namely, we have to have a direct mapping between the SQ addr and
@@ -161,7 +165,7 @@ static struct sq_mapping *__sq_remap(str
 	 * We could also probably get by without explicitly setting PTEA, but
 	 * we do it here just for good measure.
 	 */
-	local_irq_save(flags);
+	spin_lock_irqsave(&sq_mapping_lock, flags);
 
 	pteh = map->sq_addr;
 	ctrl_outl((pteh & MMU_VPN_MASK) | get_asid(), MMU_PTEH);
@@ -177,6 +181,8 @@ static struct sq_mapping *__sq_remap(str
 
 	__asm__ __volatile__ ("ldtlb" : : : "memory");
 
+	spin_unlock_irqrestore(&sq_mapping_lock, flags);
+
 	/*
 	 * Next, we need to map ourselves in the kernel page table, so that
 	 * future accesses after a TLB flush will be handled when we take a
@@ -188,31 +194,17 @@ static struct sq_mapping *__sq_remap(str
 	 * writeout before we hit the TLB flush, we do it anyways. This way
 	 * we at least save ourselves the initial page fault overhead.
 	 */
-	pgd = pgd_offset_k(map->sq_addr);
+	vma = __get_vm_area(map->size, VM_ALLOC, map->sq_addr, SQ_ADDRMAX);
+	if (!vma)
+		return ERR_PTR(-ENOMEM);
 
-	spin_lock(&init_mm.page_table_lock);
+	vma->phys_addr = map->addr;
 
-	pmd = pmd_alloc(&init_mm, pgd, map->sq_addr);
-	if (!pmd)
-		goto out;
-	
-	pte = pte_alloc_map(&init_mm, pmd, map->sq_addr);
-	if (!pte)
-		goto out;
-	if (!pte_none(*pte)) {
-		pte_unmap(pte);
-		goto out;
+	if (remap_area_pages((unsigned long)vma->addr, vma->phys_addr,
+			     map->size, pgprot_val(pgprot))) {
+		vunmap(vma->addr);
+		return NULL;
 	}
-
-	set_pte(pte, mk_pte(phys_to_page(map->addr), pgprot));
-	pte_unmap(pte);
-
-out:
-	spin_unlock(&init_mm.page_table_lock);
-	sq_flush((void *)pteh);
-
-	local_irq_restore(flags);
-
 #endif /* CONFIG_MMU */
 
 	return map;
@@ -236,11 +228,20 @@ out:
 struct sq_mapping *sq_remap(unsigned long phys, unsigned int size, const char *name)
 {
 	struct sq_mapping *map;
-	unsigned long virt;
+	unsigned long virt, end;
 	unsigned int psz;
 
+	/* Don't allow wraparound or zero size */
+	end = phys + size - 1;
+	if (!size || end < phys)
+		return NULL;
+	/* Don't allow anyone to remap normal memory.. */
+	if (phys < virt_to_phys(high_memory))
+		return NULL;
+
 	phys &= PAGE_MASK;
 
+	size  = PAGE_ALIGN(end + 1) - phys;
 	virt  = __sq_get_next_addr();
 	psz   = (size + (PAGE_SIZE - 1)) / PAGE_SIZE;
 	map   = __sq_alloc_mapping(virt, phys, size, name);
@@ -264,30 +265,8 @@ struct sq_mapping *sq_remap(unsigned lon
  */
 void sq_unmap(struct sq_mapping *map)
 {
-#ifdef CONFIG_MMU
-	pgd_t *pgd;
-	pmd_t *pmd;
-	pte_t *pte;
-	
-	pgd = pgd_offset_k(map->sq_addr);
-	pmd = pmd_offset(pgd, map->sq_addr);
-
-	if (pmd_none(*pmd))
-		return;
-	if (pmd_bad(*pmd)) {
-		pmd_ERROR(*pmd);
-		pmd_clear(pmd);
-		return;
-	}
-
-	pte = pte_offset_kernel(pmd, map->sq_addr);
-	if (pte_none(*pte) || pte_not_present(*pte))
-		return;
-
-	ptep_get_and_clear(pte);
-
-	__flush_tlb_page(get_asid(), map->sq_addr & PAGE_MASK);
-#endif
+	if (map->sq_addr > (unsigned long)high_memory)
+		vfree((void *)(map->sq_addr & PAGE_MASK));
 
 	list_del(&map->list);
 	kfree(map);
@@ -475,6 +454,7 @@ module_exit(sq_api_exit);
 MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>, M. R. Brown <mrbrown@0xd6.org>");
 MODULE_DESCRIPTION("Simple API for SH-4 integrated Store Queues");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(STORE_QUEUE_MINOR);
 
 EXPORT_SYMBOL(sq_remap);
 EXPORT_SYMBOL(sq_unmap);
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/entry.S linux-post-2.6.5-rc2-20040326/arch/sh/kernel/entry.S
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/entry.S	2004-02-13 15:19:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/entry.S	2004-03-23 10:05:27.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: entry.S,v 1.34 2004/01/13 05:52:11 kkojima Exp $
+/* $Id: entry.S,v 1.35 2004/02/21 14:45:47 lethal Exp $
  *
  *  linux/arch/sh/entry.S
  *
@@ -1129,9 +1129,6 @@ ENTRY(sys_call_table)
 	.long sys_utimes
  	.long sys_fadvise64_64_wrapper
 	.long sys_ni_syscall	/* Reserved for vserver */
-
-	.rept NR_syscalls-(.-sys_call_table)/4
-		.long sys_ni_syscall
-	.endr
+	.long sys_ni_syscall
 
 /* End of entry.S */
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/io.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/io.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/io.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/io.c	2004-03-23 10:05:27.000000000 +0000
@@ -16,10 +16,11 @@
  */
 void  memcpy_fromio(void * to, unsigned long from, unsigned long count)
 {
+	char *p = to;
         while (count) {
                 count--;
-                *(char *) to = readb(from);
-                ((char *) to)++;
+                *p = readb(from);
+                p++;
                 from++;
         }
 }
@@ -30,10 +31,11 @@ void  memcpy_fromio(void * to, unsigned 
  */
 void  memcpy_toio(unsigned long to, const void * from, unsigned long count)
 {
+	const char *p = from;
         while (count) {
                 count--;
-                writeb(*(char *) from, to);
-                ((char *) from)++;
+                writeb(*p, to);
+                p++;
                 to++;
         }
 }
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/module.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/module.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/module.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/module.c	2004-03-23 10:05:27.000000000 +0000
@@ -55,20 +55,22 @@ int module_frob_arch_sections(Elf_Ehdr *
 #define COPY_UNALIGNED_WORD(sw, tw, align) \
 { \
 	void *__s = &(sw), *__t = &(tw); \
+	unsigned short *__s2 = __s, *__t2 = __t; \
+	unsigned char *__s1 = __s, *__t1 = __t; \
 	switch ((align)) \
 	{ \
 	case 0: \
 		*(unsigned long *) __t = *(unsigned long *) __s; \
 		break; \
 	case 2: \
-		*((unsigned short *) __t)++ = *((unsigned short *) __s)++; \
-		*((unsigned short *) __t) = *((unsigned short *) __s); \
+		*__t2++ = *__s2++; \
+		*__t2 = *__s2; \
 		break; \
 	default: \
-		*((unsigned char *) __t)++ = *((unsigned char *) __s)++; \
-		*((unsigned char *) __t)++ = *((unsigned char *) __s)++; \
-		*((unsigned char *) __t)++ = *((unsigned char *) __s)++; \
-		*((unsigned char *) __t) = *((unsigned char *) __s); \
+		*__t1++ = *__s1++; \
+		*__t1++ = *__s1++; \
+		*__t1++ = *__s1++; \
+		*__t1 = *__s1; \
 		break; \
 	} \
 }
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/process.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/process.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/process.c	2004-02-13 15:19:27.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/process.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: process.c,v 1.25 2004/01/13 05:52:11 kkojima Exp $
+/* $Id: process.c,v 1.26 2004/02/06 14:14:14 kkojima Exp $
  *
  *  linux/arch/sh/kernel/process.c
  *
@@ -254,6 +254,13 @@ int copy_thread(int nr, unsigned long cl
 		struct task_struct *p, struct pt_regs *regs)
 {
 	struct pt_regs *childregs;
+#if defined(CONFIG_CPU_SH4)
+	struct task_struct *tsk = current;
+
+	unlazy_fpu(tsk, regs);
+	p->thread.fpu = tsk->thread.fpu;
+	p->used_math = tsk->used_math;
+#endif
 
 	childregs = ((struct pt_regs *)
 		(THREAD_SIZE + (unsigned long) p->thread_info)
@@ -279,16 +286,6 @@ int copy_thread(int nr, unsigned long cl
 
 	p->thread.ubc_pc = 0;
 
-#if defined(CONFIG_CPU_SH4)
-	{
-		struct task_struct *tsk = current;
-
-		unlazy_fpu(tsk, regs);
-		p->thread.fpu = tsk->thread.fpu;
-		p->used_math = tsk->used_math;
-		clear_ti_thread_flag(p->thread_info, TIF_USEDFPU);
-	}
-#endif
 	return 0;
 }
 
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/sh_ksyms.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/sh_ksyms.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/sh_ksyms.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/sh_ksyms.c	2004-03-23 10:05:27.000000000 +0000
@@ -113,3 +113,5 @@ EXPORT_SYMBOL(__down_trylock);
 #ifdef CONFIG_SMP
 EXPORT_SYMBOL(synchronize_irq);
 #endif
+
+EXPORT_SYMBOL(csum_partial);
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/sys_sh.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/sys_sh.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/sys_sh.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/sys_sh.c	2004-03-23 10:05:27.000000000 +0000
@@ -44,7 +44,7 @@ asmlinkage int sys_pipe(unsigned long r4
 	return error;
 }
 
-#if defined(CONFIG_CPU_SH4)
+#if defined(HAVE_ARCH_UNMAPPED_AREA)
 /*
  * To avoid cache alias, we map the shard page with same color.
  */
@@ -53,7 +53,9 @@ asmlinkage int sys_pipe(unsigned long r4
 unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,
 	unsigned long len, unsigned long pgoff, unsigned long flags)
 {
+	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
+	unsigned long start_addr;
 
 	if (flags & MAP_FIXED) {
 		/* We do not accept a shared mapping if it would violate
@@ -66,20 +68,44 @@ unsigned long arch_get_unmapped_area(str
 
 	if (len > TASK_SIZE)
 		return -ENOMEM;
-	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
 
+	if (addr) {
+		if (flags & MAP_PRIVATE)
+			addr = PAGE_ALIGN(addr);
+		else
+			addr = COLOUR_ALIGN(addr);
+		vma = find_vma(mm, addr);
+		if (TASK_SIZE - len >= addr &&
+		    (!vma || addr + len <= vma->vm_start))
+			return addr;
+	}
 	if (flags & MAP_PRIVATE)
-		addr = PAGE_ALIGN(addr);
+		addr = PAGE_ALIGN(mm->free_area_cache);
 	else
-		addr = COLOUR_ALIGN(addr);
+		addr = COLOUR_ALIGN(mm->free_area_cache);
+	start_addr = addr;
 
-	for (vma = find_vma(current->mm, addr); ; vma = vma->vm_next) {
+full_search:
+	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
-		if (TASK_SIZE - len < addr)
+		if (TASK_SIZE - len < addr) {
+			/*
+			 * Start a new search - just in case we missed
+			 * some holes.
+			 */
+			if (start_addr != TASK_UNMAPPED_BASE) {
+				start_addr = addr = TASK_UNMAPPED_BASE;
+				goto full_search;
+			}
 			return -ENOMEM;
-		if (!vma || addr + len <= vma->vm_start)
+		}
+		if (!vma || addr + len <= vma->vm_start) {
+			/*
+			 * Remember the place where we stopped the search:
+			 */
+			mm->free_area_cache = addr + len;
 			return addr;
+		}
 		addr = vma->vm_end;
 		if (!(flags & MAP_PRIVATE))
 			addr = COLOUR_ALIGN(addr);
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/time.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/time.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/time.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/time.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: time.c,v 1.18 2003/10/09 16:28:14 lethal Exp $
+/* $Id: time.c,v 1.19 2004/02/27 00:40:48 lethal Exp $
  *
  *  linux/arch/sh/kernel/time.c
  *
@@ -86,10 +86,14 @@ int (*rtc_set_time)(const time_t) = 0;
 #endif
 
 #if defined(CONFIG_CPU_SH3)
-#error "FIXME"
-static int ifc_table[] = { 1, 2, 4, 1, 3, 1, 1, 1 };
-static int pfc_table[] = { 1, 2, 4, 1, 3, 6, 1, 1 };
-static int stc_table[] = { 1, 2, 4, 8, 3, 6, 1, 1 };
+static int stc_multipliers[] = { 1, 2, 3, 4, 6, 1, 1, 1 };
+static int stc_values[]      = { 0, 1, 4, 2, 5, 0, 0, 0 };
+#define bfc_divisors stc_multipliers
+#define bfc_values stc_values
+static int ifc_divisors[]    = { 1, 2, 3, 4, 1, 1, 1, 1 };
+static int ifc_values[]      = { 0, 1, 4, 2, 0, 0, 0, 0 };
+static int pfc_divisors[]    = { 1, 2, 3, 4, 6, 1, 1, 1 };
+static int pfc_values[]      = { 0, 1, 4, 2, 5, 0, 0, 0 };
 #elif defined(CONFIG_CPU_SH4)
 static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 1, 1 };
 static int ifc_values[]   = { 0, 1, 2, 3, 0, 4, 0, 5 };
@@ -398,13 +402,13 @@ void get_current_frequency_divisors(unsi
 
 	tmp  = (frqcr & 0x8000) >> 13;
 	tmp |= (frqcr & 0x0030) >>  4;
-	*bfc = stc_table[tmp];
+	*bfc = stc_multipliers[tmp];
 	tmp  = (frqcr & 0x4000)  >> 12;
 	tmp |= (frqcr & 0x000c) >> 2;
-	*ifc  = ifc_table[tmp];
+	*ifc = ifc_divisors[tmp];
 	tmp  = (frqcr & 0x2000) >> 11;
 	tmp |= frqcr & 0x0003;
-	*pfc = pfc_table[tmp];
+	*pfc = pfc_divisors[tmp];
 #elif defined(CONFIG_CPU_SH4)
 	*ifc = ifc_divisors[(frqcr >> 6) & 0x0007];
 	*bfc = bfc_divisors[(frqcr >> 3) & 0x0007];
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/kernel/traps.c linux-post-2.6.5-rc2-20040326/arch/sh/kernel/traps.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/kernel/traps.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/kernel/traps.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: traps.c,v 1.14 2003/11/14 18:40:10 lethal Exp $
+/* $Id: traps.c,v 1.16 2004/03/16 00:10:54 lethal Exp $
  *
  *  linux/arch/sh/traps.c
  *
@@ -656,6 +656,10 @@ void show_stack(struct task_struct *tsk,
 	unsigned long module_end = VMALLOC_END;
 	int i = 1;
 
+	if (tsk && !sp) {
+		sp = (unsigned long *)tsk->thread.sp;
+	}
+
 	if (!sp) {
 		__asm__ __volatile__ (
 			"mov r15, %0\n\t"
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/mm/Makefile linux-post-2.6.5-rc2-20040326/arch/sh/mm/Makefile
--- linux-post-2.6.5-rc2-20040323/arch/sh/mm/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/mm/Makefile	2004-03-23 10:05:26.000000000 +0000
@@ -2,13 +2,14 @@
 # Makefile for the Linux SuperH-specific parts of the memory manager.
 #
 
-obj-y			:= init.o extable.o
+obj-y			:= init.o extable.o consistent.o
 
 obj-$(CONFIG_CPU_SH2)	+= cache-sh2.o
 obj-$(CONFIG_CPU_SH3)	+= cache-sh3.o
 obj-$(CONFIG_CPU_SH4)	+= cache-sh4.o pg-sh4.o
 
 obj-$(CONFIG_DMA_PAGE_OPS)	+= pg-dma.o
+obj-$(CONFIG_HUGETLB_PAGE)	+= hugetlbpage.o
 
 mmu-y			:= fault-nommu.o tlb-nommu.o pg-nommu.o
 mmu-$(CONFIG_MMU)	:= fault.o clear_page.o copy_page.o
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/mm/cache-sh4.c linux-post-2.6.5-rc2-20040326/arch/sh/mm/cache-sh4.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/mm/cache-sh4.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/mm/cache-sh4.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,9 +1,10 @@
-/* $Id: cache-sh4.c,v 1.24 2003/10/12 19:40:12 lethal Exp $
+/* $Id: cache-sh4.c,v 1.26 2004/02/19 12:47:24 lethal Exp $
  *
  *  linux/arch/sh/mm/cache-sh4.c
  *
  * Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- * Copyright (C) 2001, 2002, 2003  Paul Mundt
+ * Copyright (C) 2001, 2002, 2003, 2004  Paul Mundt
+ * Copyright (C) 2003  Richard Curnow
  */
 
 #include <linux/config.h>
@@ -29,10 +30,20 @@ static void __flush_dcache_all_ex(void);
 
 int __init detect_cpu_and_cache_system(void)
 {
-	unsigned long pvr, prr, ccr;
+	unsigned long pvr, prr, ccr, cvr;
+	unsigned long size;
+
+	static unsigned long sizes[16] = {
+		[1] = (1 << 12),
+		[2] = (1 << 13),
+		[4] = (1 << 14),
+		[8] = (1 << 15),
+		[9] = (1 << 16)
+	};
 
 	pvr = (ctrl_inl(CCN_PVR) >> 8) & 0xffff;
 	prr = (ctrl_inl(CCN_PRR) >> 4) & 0xff;
+	cvr = (ctrl_inl(CCN_CVR));
 
 	/*
 	 * Setup some sane SH-4 defaults for the icache
@@ -54,6 +65,9 @@ int __init detect_cpu_and_cache_system(v
 	cpu_data->dcache.ways		= 1;
 	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
 
+	/* Set the FPU flag, virtually all SH-4's have one */
+	set_bit(CPU_HAS_FPU, &(cpu_data->flags));
+
 	/*
 	 * Probe the underlying processor version/revision and
 	 * adjust cpu_data setup accordingly.
@@ -68,7 +82,7 @@ int __init detect_cpu_and_cache_system(v
 
 		/* 
 		 * FIXME: This is needed for 7750, but do we need it for the
-		 * 7750S and 7750R too? For now, assume we do.. -- PFM
+		 * 7750S too? For now, assume we do.. -- PFM
 		 */
 		set_bit(CPU_HAS_P2_FLUSH_BUG, &(cpu_data->flags));
 
@@ -83,12 +97,18 @@ int __init detect_cpu_and_cache_system(v
 		cpu_data->type = CPU_ST40GX1;
 		break;
 	case 0x700:
-		/* XXX: Add proper CVR probing */
 		cpu_data->type = CPU_SH4_501;
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
+
+		/* No FPU on the SH4-500 series.. */
+		clear_bit(CPU_HAS_FPU, &(cpu_data->flags));
 		break;
 	case 0x600:
 		cpu_data->type = CPU_SH4_202;
-		/* fall */
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
+		break;
 	case 0x500 ... 0x501:
 		switch (prr) {
 		    case 0x10: cpu_data->type = CPU_SH7750R; break;
@@ -96,9 +116,20 @@ int __init detect_cpu_and_cache_system(v
 		    case 0x50: cpu_data->type = CPU_SH7760;  break;
 		}
 
-		if (cpu_data->type == CPU_SH7750R)
-			set_bit(CPU_HAS_P2_FLUSH_BUG, &(cpu_data->flags));
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
+
+		break;
+	default:
+		cpu_data->type = CPU_SH_NONE;
+		break;
+	}
 
+	/*
+	 * On anything that's not a direct-mapped cache, look to the CVR
+	 * for I/D-cache specifics.
+	 */
+	if (cpu_data->dcache.ways > 1) {
 		jump_to_P2();
 		ccr = ctrl_inl(CCR);
 
@@ -110,19 +141,17 @@ int __init detect_cpu_and_cache_system(v
 
 		back_to_P1();
 
-		cpu_data->icache.ways = 2;
-		cpu_data->dcache.ways = 2;
-
-		break;
-	default:
-		cpu_data->type = CPU_SH_NONE;
-		break;
+		size = sizes[(cvr >> 20) & 0xf];
+		cpu_data->icache.way_shift	=  (size >> 1);
+		cpu_data->icache.entry_mask	= ((size >> 2) - (1 << 5));
+		cpu_data->icache.sets		=  (size >> 6);
+
+		size = sizes[(cvr >> 16) & 0xf];
+		cpu_data->dcache.way_shift	=  (size >> 1);
+		cpu_data->dcache.entry_mask	= ((size >> 2) - (1 << 5));
+		cpu_data->dcache.sets		=  (size >> 6);
 	}
 
-	/* No FPU on the SH4-500 series.. */
-	if (cpu_data->type != CPU_SH4_501)
-		set_bit(CPU_HAS_FPU, &(cpu_data->flags));
-
 	return 0;
 }
 
@@ -419,7 +448,7 @@ void flush_cache_range(struct vm_area_st
 			}
 			pte++;
 			p += PAGE_SIZE;
-		} while (p < end && (unsigned long)pte & PAGE_MASK);
+		} while (p < end && ((unsigned long)pte & ~PAGE_MASK));
 		pmd++;
 	} while (p < end);
  loop_exit:
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/mm/consistent.c linux-post-2.6.5-rc2-20040326/arch/sh/mm/consistent.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/mm/consistent.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/mm/consistent.c	2004-03-23 15:23:53.000000000 +0000
@@ -0,0 +1,79 @@
+/*
+ * arch/sh/mm/consistent.c
+ *
+ * Copyright (C) 2004  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+#include <asm/io.h>
+
+void *consistent_alloc(int gfp, size_t size, dma_addr_t *handle)
+{
+	struct page *page, *end, *free;
+	void *ret;
+	int order;
+
+	size = PAGE_ALIGN(size);
+	order = get_order(size);
+
+	page = alloc_pages(gfp, order);
+	if (!page)
+		return NULL;
+
+	ret = (void *)P2SEGADDR(page_to_bus(page));
+
+	/*
+	 * We must flush the cache before we pass it on to the device
+	 */
+	dma_cache_wback_inv(ret, size);
+
+	*handle = (unsigned long)ret;
+
+	free = page + (size >> PAGE_SHIFT);
+	end  = page + (1 << order);
+
+	do {
+		set_page_count(page, 1);
+		page++;
+	} while (size -= PAGE_SIZE);
+
+	/*
+	 * Free any unused pages
+	 */
+	while (page < end) {
+		set_page_count(page, 1);
+		__free_page(page);
+		page++;
+	}
+
+	return ret;
+}
+
+void consistent_free(void *vaddr, size_t size)
+{
+	unsigned long addr = P1SEGADDR((unsigned long)vaddr);
+
+	free_pages(addr, get_order(size));
+}
+
+void consistent_sync(void *vaddr, size_t size, int direction)
+{
+	switch (direction) {
+	case DMA_FROM_DEVICE:		/* invalidate only */
+		dma_cache_inv(vaddr, size);
+		break;
+	case DMA_TO_DEVICE:		/* writeback only */
+		dma_cache_wback(vaddr, size);
+		break;
+	case DMA_BIDIRECTIONAL:		/* writeback and invalidate */
+		dma_cache_wback_inv(vaddr, size);
+		break;
+	default:
+		BUG();
+	}
+}
+
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/mm/hugetlbpage.c linux-post-2.6.5-rc2-20040326/arch/sh/mm/hugetlbpage.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/mm/hugetlbpage.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/mm/hugetlbpage.c	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,519 @@
+/*
+ * arch/sh/mm/hugetlbpage.c
+ *
+ * SuperH HugeTLB page support.
+ *
+ * Cloned from sparc64 by Paul Mundt.
+ *
+ * Copyright (C) 2002, 2003 David S. Miller (davem@redhat.com)
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/hugetlb.h>
+#include <linux/pagemap.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/sysctl.h>
+
+#include <asm/mman.h>
+#include <asm/pgalloc.h>
+#include <asm/tlb.h>
+#include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
+
+static long	htlbpagemem;
+int		htlbpage_max;
+static long	htlbzone_pages;
+
+static struct list_head hugepage_freelists[MAX_NUMNODES];
+static spinlock_t htlbpage_lock = SPIN_LOCK_UNLOCKED;
+
+static void enqueue_huge_page(struct page *page)
+{
+	list_add(&page->list,
+		 &hugepage_freelists[page_zone(page)->zone_pgdat->node_id]);
+}
+
+static struct page *dequeue_huge_page(void)
+{
+	int nid = numa_node_id();
+	struct page *page = NULL;
+
+	if (list_empty(&hugepage_freelists[nid])) {
+		for (nid = 0; nid < MAX_NUMNODES; ++nid)
+			if (!list_empty(&hugepage_freelists[nid]))
+				break;
+	}
+	if (nid >= 0 && nid < MAX_NUMNODES &&
+	    !list_empty(&hugepage_freelists[nid])) {
+		page = list_entry(hugepage_freelists[nid].next,
+				  struct page, list);
+		list_del(&page->list);
+	}
+	return page;
+}
+
+static struct page *alloc_fresh_huge_page(void)
+{
+	static int nid = 0;
+	struct page *page;
+	page = alloc_pages_node(nid, GFP_HIGHUSER, HUGETLB_PAGE_ORDER);
+	nid = (nid + 1) % numnodes;
+	return page;
+}
+
+static void free_huge_page(struct page *page);
+
+static struct page *alloc_hugetlb_page(void)
+{
+	struct page *page;
+
+	spin_lock(&htlbpage_lock);
+	page = dequeue_huge_page();
+	if (!page) {
+		spin_unlock(&htlbpage_lock);
+		return NULL;
+	}
+	htlbpagemem--;
+	spin_unlock(&htlbpage_lock);
+	set_page_count(page, 1);
+	page->lru.prev = (void *)free_huge_page;
+	memset(page_address(page), 0, HPAGE_SIZE);
+	return page;
+}
+
+static pte_t *huge_pte_alloc(struct mm_struct *mm, unsigned long addr)
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *pte = NULL;
+
+	pgd = pgd_offset(mm, addr);
+	if (pgd) {
+		pmd = pmd_alloc(mm, pgd, addr);
+		if (pmd)
+			pte = pte_alloc_map(mm, pmd, addr);
+	}
+	return pte;
+}
+
+static pte_t *huge_pte_offset(struct mm_struct *mm, unsigned long addr)
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *pte = NULL;
+
+	pgd = pgd_offset(mm, addr);
+	if (pgd) {
+		pmd = pmd_offset(pgd, addr);
+		if (pmd)
+			pte = pte_offset_map(pmd, addr);
+	}
+	return pte;
+}
+
+#define mk_pte_huge(entry) do { pte_val(entry) |= _PAGE_SZHUGE; } while (0)
+
+static void set_huge_pte(struct mm_struct *mm, struct vm_area_struct *vma,
+			 struct page *page, pte_t * page_table, int write_access)
+{
+	unsigned long i;
+	pte_t entry;
+
+	mm->rss += (HPAGE_SIZE / PAGE_SIZE);
+
+	if (write_access)
+		entry = pte_mkwrite(pte_mkdirty(mk_pte(page,
+						       vma->vm_page_prot)));
+	else
+		entry = pte_wrprotect(mk_pte(page, vma->vm_page_prot));
+	entry = pte_mkyoung(entry);
+	mk_pte_huge(entry);
+
+	for (i = 0; i < (1 << HUGETLB_PAGE_ORDER); i++) {
+		set_pte(page_table, entry);
+		page_table++;
+
+		pte_val(entry) += PAGE_SIZE;
+	}
+}
+
+/*
+ * This function checks for proper alignment of input addr and len parameters.
+ */
+int is_aligned_hugepage_range(unsigned long addr, unsigned long len)
+{
+	if (len & ~HPAGE_MASK)
+		return -EINVAL;
+	if (addr & ~HPAGE_MASK)
+		return -EINVAL;
+	return 0;
+}
+
+int copy_hugetlb_page_range(struct mm_struct *dst, struct mm_struct *src,
+			    struct vm_area_struct *vma)
+{
+	pte_t *src_pte, *dst_pte, entry;
+	struct page *ptepage;
+	unsigned long addr = vma->vm_start;
+	unsigned long end = vma->vm_end;
+	int i;
+
+	while (addr < end) {
+		dst_pte = huge_pte_alloc(dst, addr);
+		if (!dst_pte)
+			goto nomem;
+		src_pte = huge_pte_offset(src, addr);
+		BUG_ON(!src_pte || pte_none(*src_pte));
+		entry = *src_pte;
+		ptepage = pte_page(entry);
+		get_page(ptepage);
+		for (i = 0; i < (1 << HUGETLB_PAGE_ORDER); i++) {
+			set_pte(dst_pte, entry);
+			pte_val(entry) += PAGE_SIZE;
+			dst_pte++;
+		}
+		dst->rss += (HPAGE_SIZE / PAGE_SIZE);
+		addr += HPAGE_SIZE;
+	}
+	return 0;
+
+nomem:
+	return -ENOMEM;
+}
+
+int follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,
+			struct page **pages, struct vm_area_struct **vmas,
+			unsigned long *position, int *length, int i)
+{
+	unsigned long vaddr = *position;
+	int remainder = *length;
+
+	WARN_ON(!is_vm_hugetlb_page(vma));
+
+	while (vaddr < vma->vm_end && remainder) {
+		if (pages) {
+			pte_t *pte;
+			struct page *page;
+
+			pte = huge_pte_offset(mm, vaddr);
+
+			/* hugetlb should be locked, and hence, prefaulted */
+			BUG_ON(!pte || pte_none(*pte));
+
+			page = pte_page(*pte);
+
+			WARN_ON(!PageCompound(page));
+
+			get_page(page);
+			pages[i] = page;
+		}
+
+		if (vmas)
+			vmas[i] = vma;
+
+		vaddr += PAGE_SIZE;
+		--remainder;
+		++i;
+	}
+
+	*length = remainder;
+	*position = vaddr;
+
+	return i;
+}
+
+struct page *follow_huge_addr(struct mm_struct *mm,
+			      struct vm_area_struct *vma,
+			      unsigned long address, int write)
+{
+	return NULL;
+}
+
+struct vm_area_struct *hugepage_vma(struct mm_struct *mm, unsigned long addr)
+{
+	return NULL;
+}
+
+int pmd_huge(pmd_t pmd)
+{
+	return 0;
+}
+
+struct page *follow_huge_pmd(struct mm_struct *mm, unsigned long address,
+			     pmd_t *pmd, int write)
+{
+	return NULL;
+}
+
+static void free_huge_page(struct page *page)
+{
+	BUG_ON(page_count(page));
+	BUG_ON(page->mapping);
+
+	INIT_LIST_HEAD(&page->list);
+
+	spin_lock(&htlbpage_lock);
+	enqueue_huge_page(page);
+	htlbpagemem++;
+	spin_unlock(&htlbpage_lock);
+}
+
+void huge_page_release(struct page *page)
+{
+	if (!put_page_testzero(page))
+		return;
+
+	free_huge_page(page);
+}
+
+void unmap_hugepage_range(struct vm_area_struct *vma,
+			  unsigned long start, unsigned long end)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	unsigned long address;
+	pte_t *pte;
+	struct page *page;
+	int i;
+
+	BUG_ON(start & (HPAGE_SIZE - 1));
+	BUG_ON(end & (HPAGE_SIZE - 1));
+
+	for (address = start; address < end; address += HPAGE_SIZE) {
+		pte = huge_pte_offset(mm, address);
+		BUG_ON(!pte);
+		if (pte_none(*pte))
+			continue;
+		page = pte_page(*pte);
+		huge_page_release(page);
+		for (i = 0; i < (1 << HUGETLB_PAGE_ORDER); i++) {
+			pte_clear(pte);
+			pte++;
+		}
+	}
+	mm->rss -= (end - start) >> PAGE_SHIFT;
+	flush_tlb_range(vma, start, end);
+}
+
+void zap_hugepage_range(struct vm_area_struct *vma,
+			unsigned long start, unsigned long length)
+{
+	struct mm_struct *mm = vma->vm_mm;
+
+	spin_lock(&mm->page_table_lock);
+	unmap_hugepage_range(vma, start, start + length);
+	spin_unlock(&mm->page_table_lock);
+}
+
+int hugetlb_prefault(struct address_space *mapping, struct vm_area_struct *vma)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long addr;
+	int ret = 0;
+
+	BUG_ON(vma->vm_start & ~HPAGE_MASK);
+	BUG_ON(vma->vm_end & ~HPAGE_MASK);
+
+	spin_lock(&mm->page_table_lock);
+	for (addr = vma->vm_start; addr < vma->vm_end; addr += HPAGE_SIZE) {
+		unsigned long idx;
+		pte_t *pte = huge_pte_alloc(mm, addr);
+		struct page *page;
+
+		if (!pte) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		if (!pte_none(*pte))
+			continue;
+
+		idx = ((addr - vma->vm_start) >> HPAGE_SHIFT)
+			+ (vma->vm_pgoff >> (HPAGE_SHIFT - PAGE_SHIFT));
+		page = find_get_page(mapping, idx);
+		if (!page) {
+			/* charge the fs quota first */
+			if (hugetlb_get_quota(mapping)) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			page = alloc_hugetlb_page();
+			if (!page) {
+				hugetlb_put_quota(mapping);
+				ret = -ENOMEM;
+				goto out;
+			}
+			ret = add_to_page_cache(page, mapping, idx, GFP_ATOMIC);
+			unlock_page(page);
+			if (ret) {
+				hugetlb_put_quota(mapping);
+				free_huge_page(page);
+				goto out;
+			}
+		}
+		set_huge_pte(mm, vma, page, pte, vma->vm_flags & VM_WRITE);
+	}
+out:
+	spin_unlock(&mm->page_table_lock);
+	return ret;
+}
+
+static void update_and_free_page(struct page *page)
+{
+	int j;
+	struct page *map;
+
+	map = page;
+	htlbzone_pages--;
+	for (j = 0; j < (HPAGE_SIZE / PAGE_SIZE); j++) {
+		map->flags &= ~(1 << PG_locked | 1 << PG_error | 1 << PG_referenced |
+				1 << PG_dirty | 1 << PG_active | 1 << PG_reserved |
+				1 << PG_private | 1<< PG_writeback);
+		set_page_count(map, 0);
+		map++;
+	}
+	set_page_count(page, 1);
+	__free_pages(page, HUGETLB_PAGE_ORDER);
+}
+
+static int try_to_free_low(int count)
+{
+	struct list_head *p;
+	struct page *page, *map;
+
+	map = NULL;
+	spin_lock(&htlbpage_lock);
+	/* all lowmem is on node 0 */
+	list_for_each(p, &hugepage_freelists[0]) {
+		if (map) {
+			list_del(&map->list);
+			update_and_free_page(map);
+			htlbpagemem--;
+			map = NULL;
+			if (++count == 0)
+				break;
+		}
+		page = list_entry(p, struct page, list);
+		if (!PageHighMem(page))
+			map = page;
+	}
+	if (map) {
+		list_del(&map->list);
+		update_and_free_page(map);
+		htlbpagemem--;
+		count++;
+	}
+	spin_unlock(&htlbpage_lock);
+	return count;
+}
+
+static int set_hugetlb_mem_size(int count)
+{
+	int lcount;
+	struct page *page;
+
+	if (count < 0)
+		lcount = count;
+	else
+		lcount = count - htlbzone_pages;
+
+	if (lcount == 0)
+		return (int)htlbzone_pages;
+	if (lcount > 0) {	/* Increase the mem size. */
+		while (lcount--) {
+			page = alloc_fresh_huge_page();
+			if (page == NULL)
+				break;
+			spin_lock(&htlbpage_lock);
+			enqueue_huge_page(page);
+			htlbpagemem++;
+			htlbzone_pages++;
+			spin_unlock(&htlbpage_lock);
+		}
+		return (int) htlbzone_pages;
+	}
+	/* Shrink the memory size. */
+	lcount = try_to_free_low(lcount);
+	while (lcount++) {
+		page = alloc_hugetlb_page();
+		if (page == NULL)
+			break;
+		spin_lock(&htlbpage_lock);
+		update_and_free_page(page);
+		spin_unlock(&htlbpage_lock);
+	}
+	return (int) htlbzone_pages;
+}
+
+int hugetlb_sysctl_handler(struct ctl_table *table, int write,
+			   struct file *file, void *buffer, size_t *length)
+{
+	proc_dointvec(table, write, file, buffer, length);
+	htlbpage_max = set_hugetlb_mem_size(htlbpage_max);
+	return 0;
+}
+
+static int __init hugetlb_setup(char *s)
+{
+	if (sscanf(s, "%d", &htlbpage_max) <= 0)
+		htlbpage_max = 0;
+	return 1;
+}
+__setup("hugepages=", hugetlb_setup);
+
+static int __init hugetlb_init(void)
+{
+	int i;
+	struct page *page;
+
+	for (i = 0; i < MAX_NUMNODES; ++i)
+		INIT_LIST_HEAD(&hugepage_freelists[i]);
+
+	for (i = 0; i < htlbpage_max; ++i) {
+		page = alloc_fresh_huge_page();
+		if (!page)
+			break;
+		spin_lock(&htlbpage_lock);
+		enqueue_huge_page(page);
+		spin_unlock(&htlbpage_lock);
+	}
+	htlbpage_max = htlbpagemem = htlbzone_pages = i;
+	printk("Total HugeTLB memory allocated, %ld\n", htlbpagemem);
+	return 0;
+}
+module_init(hugetlb_init);
+
+int hugetlb_report_meminfo(char *buf)
+{
+	return sprintf(buf,
+			"HugePages_Total: %5lu\n"
+			"HugePages_Free:  %5lu\n"
+			"Hugepagesize:    %5lu kB\n",
+			htlbzone_pages,
+			htlbpagemem,
+			HPAGE_SIZE/1024);
+}
+
+int is_hugepage_mem_enough(size_t size)
+{
+	return (size + ~HPAGE_MASK)/HPAGE_SIZE <= htlbpagemem;
+}
+
+/*
+ * We cannot handle pagefaults against hugetlb pages at all.  They cause
+ * handle_mm_fault() to try to instantiate regular-sized pages in the
+ * hugegpage VMA.  do_page_fault() is supposed to trap this, so BUG is we get
+ * this far.
+ */
+static struct page *hugetlb_nopage(struct vm_area_struct *vma,
+				   unsigned long address, int *unused)
+{
+	BUG();
+	return NULL;
+}
+
+struct vm_operations_struct hugetlb_vm_ops = {
+	.nopage = hugetlb_nopage,
+};
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/mm/init.c linux-post-2.6.5-rc2-20040326/arch/sh/mm/init.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/mm/init.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/mm/init.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: init.c,v 1.18 2003/10/31 09:26:59 kkojima Exp $
+/* $Id: init.c,v 1.19 2004/02/21 04:42:16 kkojima Exp $
  *
  *  linux/arch/sh/mm/init.c
  *
@@ -174,6 +174,7 @@ void __init mem_init(void)
 	extern unsigned long empty_zero_page[1024];
 	int codesize, reservedpages, datasize, initsize;
 	int tmp;
+	extern unsigned long memory_start;
 
 #ifdef CONFIG_MMU
 	high_memory = (void *)__va(MAX_LOW_PFN * PAGE_SIZE);
@@ -183,7 +184,7 @@ void __init mem_init(void)
 	high_memory = (void *)(memory_end & PAGE_MASK);
 #endif
 
-	max_mapnr = num_physpages = MAP_NR(high_memory);
+	max_mapnr = num_physpages = MAP_NR(high_memory) - MAP_NR(memory_start);
 
 	/* clear the zero-page */
 	memset(empty_zero_page, 0, PAGE_SIZE);
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/mm/ioremap.c linux-post-2.6.5-rc2-20040326/arch/sh/mm/ioremap.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/mm/ioremap.c	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/mm/ioremap.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: ioremap.c,v 1.8 2003/10/09 15:25:42 lethal Exp $
+/* $Id: ioremap.c,v 1.9 2004/02/25 04:59:10 lethal Exp $
  *
  * arch/sh/mm/ioremap.c
  *
@@ -160,5 +160,5 @@ void * p3_ioremap(unsigned long phys_add
 void p3_iounmap(void *addr)
 {
 	if (addr > high_memory)
-		return vfree((void *) (PAGE_MASK & (unsigned long) addr));
+		vfree((void *)(PAGE_MASK & (unsigned long)addr));
 }
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/mm/pg-dma.c linux-post-2.6.5-rc2-20040326/arch/sh/mm/pg-dma.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/mm/pg-dma.c	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/mm/pg-dma.c	2004-03-23 10:05:26.000000000 +0000
@@ -21,7 +21,7 @@
 #include <asm/io.h>
 
 /* Channel to use for page ops, must be dual-address mode capable. */
-static int dma_channel = 3;
+static int dma_channel = CONFIG_DMA_PAGE_OPS_CHANNEL;
 
 static void copy_page_dma(void *to, void *from)
 {
diff -purN linux-post-2.6.5-rc2-20040323/arch/sh/mm/tlb-sh4.c linux-post-2.6.5-rc2-20040326/arch/sh/mm/tlb-sh4.c
--- linux-post-2.6.5-rc2-20040323/arch/sh/mm/tlb-sh4.c	2003-05-06 19:28:50.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sh/mm/tlb-sh4.c	2004-03-23 10:05:26.000000000 +0000
@@ -68,7 +68,7 @@ void update_mmu_cache(struct vm_area_str
 	/* Set PTEL register */
 	pteval &= _PAGE_FLAGS_HARDWARE_MASK; /* drop software flags */
 #ifdef CONFIG_SH_WRITETHROUGH
-	pteval |= 1;
+	pteval |= _PAGE_WT;
 #endif
 	/* conveniently, we want all the software flags to be 0 anyway */
 	ctrl_outl(pteval, MMU_PTEL);
diff -purN linux-post-2.6.5-rc2-20040323/arch/sparc64/defconfig linux-post-2.6.5-rc2-20040326/arch/sparc64/defconfig
--- linux-post-2.6.5-rc2-20040323/arch/sparc64/defconfig	2004-03-19 21:57:37.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sparc64/defconfig	2004-03-25 21:16:37.000000000 +0000
@@ -332,6 +332,7 @@ CONFIG_SCSI_SATA=y
 CONFIG_SCSI_SATA_SVW=m
 CONFIG_SCSI_ATA_PIIX=m
 CONFIG_SCSI_SATA_PROMISE=m
+CONFIG_SCSI_SATA_SIL=m
 CONFIG_SCSI_SATA_VIA=m
 CONFIG_SCSI_SATA_VITESSE=m
 # CONFIG_SCSI_BUSLOGIC is not set
@@ -464,7 +465,6 @@ CONFIG_IP_MROUTE=y
 CONFIG_IP_PIMSM_V1=y
 CONFIG_IP_PIMSM_V2=y
 CONFIG_ARPD=y
-CONFIG_INET_ECN=y
 CONFIG_SYN_COOKIES=y
 CONFIG_INET_AH=y
 CONFIG_INET_ESP=y
@@ -632,7 +632,6 @@ CONFIG_XFRM_USER=m
 #
 # SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=m
 CONFIG_IP_SCTP=m
 # CONFIG_SCTP_DBG_MSG is not set
 # CONFIG_SCTP_DBG_OBJCNT is not set
@@ -1205,7 +1204,7 @@ CONFIG_DEVFS_MOUNT=y
 # CONFIG_DEVFS_DEBUG is not set
 CONFIG_DEVPTS_FS_XATTR=y
 # CONFIG_DEVPTS_FS_SECURITY is not set
-# CONFIG_TMPFS is not set
+CONFIG_TMPFS=y
 CONFIG_HUGETLBFS=y
 CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
@@ -1751,6 +1750,7 @@ CONFIG_CRYPTO_CAST5=m
 CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_TEST=m
 
 #
diff -purN linux-post-2.6.5-rc2-20040323/arch/sparc64/kernel/sys_sparc32.c linux-post-2.6.5-rc2-20040326/arch/sparc64/kernel/sys_sparc32.c
--- linux-post-2.6.5-rc2-20040323/arch/sparc64/kernel/sys_sparc32.c	2004-03-12 09:30:19.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/sparc64/kernel/sys_sparc32.c	2004-03-24 20:08:42.000000000 +0000
@@ -1089,7 +1089,7 @@ static int filldir(void * __buf, const c
 {
 	struct linux_dirent32 * dirent;
 	struct getdents_callback32 * buf = (struct getdents_callback32 *) __buf;
-	int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 1);
+	int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 2);
 
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
@@ -1103,6 +1103,7 @@ static int filldir(void * __buf, const c
 	put_user(reclen, &dirent->d_reclen);
 	copy_to_user(dirent->d_name, name, namlen);
 	put_user(0, dirent->d_name + namlen);
+	put_user(d_type, (char *) dirent + reclen - 1);
 	((char *) dirent) += reclen;
 	buf->current_dir = dirent;
 	buf->count -= reclen;
@@ -1481,14 +1482,13 @@ asmlinkage int sys32_mount(char *dev_nam
 	if (err)
 		goto out;
 
-	if (!type_page) {
-		err = -EINVAL;
-		goto out;
+	if (type_page) {
+		is_smb = !strcmp((char *)type_page, SMBFS_NAME);
+		is_ncp = !strcmp((char *)type_page, NCPFS_NAME);
+	} else {
+		is_smb = is_ncp = 0;
 	}
 
-	is_smb = !strcmp((char *)type_page, SMBFS_NAME);
-	is_ncp = !strcmp((char *)type_page, NCPFS_NAME);
-
 	err = copy_mount_stuff_to_kernel((const void *)AA(data), &data_page);
 	if (err)
 		goto type_out;
diff -purN linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/Makefile linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/Makefile
--- linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/Makefile	2004-03-08 14:23:47.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/Makefile	2004-03-23 06:53:14.000000000 +0000
@@ -11,6 +11,7 @@ obj-y	:= process.o semaphore.o signal.o 
 obj-y += mce.o acpi/
 
 obj-$(CONFIG_MTRR)		+= ../../i386/kernel/cpu/mtrr/
+obj-$(CONFIG_ACPI_BOOT)		+= acpi/
 obj-$(CONFIG_X86_MSR)		+= msr.o
 obj-$(CONFIG_MICROCODE)		+= microcode.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
diff -purN linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/acpi/Makefile linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/acpi/Makefile
--- linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/acpi/Makefile	2003-03-28 17:53:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/acpi/Makefile	2004-03-23 06:32:11.000000000 +0000
@@ -1,3 +1,3 @@
 obj-$(CONFIG_ACPI_BOOT)		:= boot.o
+boot-$(CONFIG_ACPI_BOOT)	:= ../../../i386/kernel/acpi/boot.o
 obj-$(CONFIG_ACPI_SLEEP)	+= sleep.o wakeup.o
-
diff -purN linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/acpi/boot.c linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/acpi/boot.c
--- linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/acpi/boot.c	2004-03-18 22:25:51.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/acpi/boot.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,619 +0,0 @@
-/*
- *  acpi.c - Architecture-Specific Low-Level ACPI Support
- *
- *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
- *  Copyright (C) 2001 Jun Nakajima <jun.nakajima@intel.com>
- *  Copyright (C) 2001 Patrick Mochel <mochel@osdl.org>
- *  Copyright (C) 2002 Andi Kleen, SuSE Labs (x86-64 port)
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/stddef.h>
-#include <linux/slab.h>
-#include <linux/pci.h>
-#include <linux/bootmem.h>
-#include <linux/irq.h>
-#include <linux/acpi.h>
-#include <asm/mpspec.h>
-#include <asm/io.h>
-#include <asm/apic.h>
-#include <asm/apicdef.h>
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <asm/pgalloc.h>
-#include <asm/io_apic.h>
-#include <asm/proto.h>
-#include <asm/tlbflush.h>
-
-#define PREFIX			"ACPI: "
-
-int acpi_noirq __initdata;	/* skip ACPI IRQ initialization */
-int acpi_ht __initdata = 1;	/* enable HT */
-
-int acpi_lapic;
-int acpi_ioapic;
-int acpi_strict;
-
-/* --------------------------------------------------------------------------
-                              Boot-time Configuration
-   -------------------------------------------------------------------------- */
-
-#ifdef CONFIG_ACPI_BOOT
-
-enum acpi_irq_model_id		acpi_irq_model;
-
-/* rely on all ACPI tables being in the direct mapping */
-char *
-__acpi_map_table (
-	unsigned long	phys_addr,
-	unsigned long	size)
-{
-	if (!phys_addr || !size)
-		return NULL;
-
-	if (phys_addr < (end_pfn_map << PAGE_SHIFT)) 
-		return __va(phys_addr); 
-
-	return NULL; 
-} 	      
-
-#ifdef CONFIG_PCI_MMCONFIG
-static int __init acpi_parse_mcfg(unsigned long phys_addr, unsigned long size)
-{
-	struct acpi_table_mcfg *mcfg;
-
-	if (!phys_addr || !size)
-		return -EINVAL;
-
-	mcfg = (struct acpi_table_mcfg *) __acpi_map_table(phys_addr, size);
-	if (!mcfg) {
-		printk(KERN_WARNING PREFIX "Unable to map MCFG\n");
-		return -ENODEV;
-	}
-
-	if (mcfg->base_reserved) {
-		printk(KERN_ERR PREFIX "MMCONFIG not in low 4GB of memory\n");
-		return -ENODEV;
-	}
-
-	pci_mmcfg_base_addr = mcfg->base_address;
-
-	return 0;
-}
-#endif /* CONFIG_PCI_MMCONFIG */
-
-#ifdef CONFIG_X86_LOCAL_APIC
-
-static u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;
-
-
-static int __init
-acpi_parse_madt (
-	unsigned long		phys_addr,
-	unsigned long		size)
-{
-	struct acpi_table_madt	*madt = NULL;
-
-	if (!phys_addr || !size)
-		return -EINVAL;
-
-	madt = (struct acpi_table_madt *) __acpi_map_table(phys_addr, size);
-	if (!madt) {
-		printk(KERN_WARNING PREFIX "Unable to map MADT\n");
-		return -ENODEV;
-	}
-
-	if (madt->lapic_address)
-		acpi_lapic_addr = (u64) madt->lapic_address;
-
-	printk(KERN_INFO PREFIX "Local APIC address 0x%016x\n",
-		madt->lapic_address);
-
-	return 0;
-}
-
-
-static int __init
-acpi_parse_lapic (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_lapic	*processor = NULL;
-
-	processor = (struct acpi_table_lapic*) header;
-	if (!processor)
-		return -EINVAL;
-
-	acpi_table_print_madt_entry(header);
-
-	/* no utility in registering a disabled processor */
-	if (processor->flags.enabled == 0)
-		return 0;
-
-
-	mp_register_lapic (
-		processor->id,					   /* APIC ID */
-		processor->flags.enabled);			  /* Enabled? */
-
-	return 0;
-}
-
-
-static int __init
-acpi_parse_lapic_addr_ovr (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_lapic_addr_ovr *lapic_addr_ovr = NULL;
-
-	lapic_addr_ovr = (struct acpi_table_lapic_addr_ovr*) header;
-	if (!lapic_addr_ovr)
-		return -EINVAL;
-
-	acpi_lapic_addr = lapic_addr_ovr->address;
-
-	return 0;
-}
-
-
-static int __init
-acpi_parse_lapic_nmi (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_lapic_nmi *lapic_nmi = NULL;
-
-	lapic_nmi = (struct acpi_table_lapic_nmi*) header;
-	if (!lapic_nmi)
-		return -EINVAL;
-
-	acpi_table_print_madt_entry(header);
-
-	if (lapic_nmi->lint != 1)
-		printk(KERN_WARNING PREFIX "NMI not connected to LINT 1!\n");
-
-	return 0;
-}
-
-#endif /*CONFIG_X86_LOCAL_APIC*/
-
-#ifdef CONFIG_X86_IO_APIC
-
-static int __init
-acpi_parse_ioapic (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_ioapic *ioapic = NULL;
-
-	ioapic = (struct acpi_table_ioapic*) header;
-	if (!ioapic)
-		return -EINVAL;
- 
-	acpi_table_print_madt_entry(header);
-
-	mp_register_ioapic (
-		ioapic->id,
-		ioapic->address,
-		ioapic->global_irq_base);
- 
-	return 0;
-}
-
-
-static int __init
-acpi_parse_int_src_ovr (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_int_src_ovr *intsrc = NULL;
-
-	intsrc = (struct acpi_table_int_src_ovr*) header;
-	if (!intsrc)
-		return -EINVAL;
-
-	acpi_table_print_madt_entry(header);
-
-	mp_override_legacy_irq (
-		intsrc->bus_irq,
-		intsrc->flags.polarity,
-		intsrc->flags.trigger,
-		intsrc->global_irq);
-
-	return 0;
-}
-
-
-static int __init
-acpi_parse_nmi_src (
-	acpi_table_entry_header *header)
-{
-	struct acpi_table_nmi_src *nmi_src = NULL;
-
-	nmi_src = (struct acpi_table_nmi_src*) header;
-	if (!nmi_src)
-		return -EINVAL;
-
-	acpi_table_print_madt_entry(header);
-
-	/* TBD: Support nimsrc entries? */
-
-	return 0;
-}
-
-#endif /*CONFIG_X86_IO_APIC*/
-
-static int __init acpi_parse_sbf(unsigned long phys_addr, unsigned long size)
-{
-	struct acpi_table_sbf *sb;
-
-	if (!phys_addr || !size)
-		return -EINVAL;
-
-	sb = (struct acpi_table_sbf *) __acpi_map_table(phys_addr, size);
-	if (!sb) {
-		printk(KERN_WARNING PREFIX "Unable to map SBF\n");
-		return -ENODEV;
-	}
-
-	sbf_port = sb->sbf_cmos; /* Save CMOS port */
-
-	return 0;
-}
-
-#ifdef CONFIG_HPET_TIMER
-static int __init
-acpi_parse_hpet (
-	unsigned long		phys_addr,
-	unsigned long		size)
-{
-	struct acpi_table_hpet *hpet_tbl;
-
-	hpet_tbl = __va(phys_addr);
-
-	if (hpet_tbl->addr.space_id != ACPI_SPACE_MEM) {
-		printk(KERN_WARNING "acpi: HPET timers must be located in memory.\n");
-		return -1;
-	}
-
-	vxtime.hpet_address = hpet_tbl->addr.addrl |
-		((long) hpet_tbl->addr.addrh << 32);
-
-	printk(KERN_INFO "acpi: HPET id: %#x base: %#lx\n",
-	       hpet_tbl->id, vxtime.hpet_address);
-
-	return 0;
-} 
-#endif
-
-#ifdef CONFIG_ACPI_BUS
-/*
- * "acpi_pic_sci=level" (current default)
- * programs the PIC-mode SCI to Level Trigger.
- * (NO-OP if the BIOS set Level Trigger already)
- *
- * If a PIC-mode SCI is not recognized or gives spurious IRQ7's
- * it may require Edge Trigger -- use "acpi_pic_sci=edge"
- * (NO-OP if the BIOS set Edge Trigger already)
- *
- * Port 0x4d0-4d1 are ECLR1 and ECLR2, the Edge/Level Control Registers
- * for the 8259 PIC.  bit[n] = 1 means irq[n] is Level, otherwise Edge.
- * ECLR1 is IRQ's 0-7 (IRQ 0, 1, 2 must be 0)
- * ECLR2 is IRQ's 8-15 (IRQ 8, 13 must be 0)
- */
-
-static int __initdata	acpi_pic_sci_trigger;	/* 0: level, 1: edge */
-
-void __init
-acpi_pic_sci_set_trigger(unsigned int irq)
-{
-	unsigned char mask = 1 << (irq & 7);
-	unsigned int port = 0x4d0 + (irq >> 3);
-	unsigned char val = inb(port);
-
-	
-	printk(PREFIX "IRQ%d SCI:", irq);
-	if (!(val & mask)) {
-		printk(" Edge");
-
-		if (!acpi_pic_sci_trigger) {
-			printk(" set to Level");
-			outb(val | mask, port);
-		}
-	} else {
-		printk(" Level");
-
-		if (acpi_pic_sci_trigger) {
-			printk(" set to Edge");
-			outb(val | mask, port);
-		}
-	}
-	printk(" Trigger.\n");
-}
-
-int __init
-acpi_pic_sci_setup(char *str)
-{
-	while (str && *str) {
-		if (strncmp(str, "level", 5) == 0)
-			acpi_pic_sci_trigger = 0;	/* force level trigger */
-		if (strncmp(str, "edge", 4) == 0)
-			acpi_pic_sci_trigger = 1;	/* force edge trigger */
-		str = strchr(str, ',');
-		if (str)
-			str += strspn(str, ", \t");
-	}
-	return 1;
-}
-
-__setup("acpi_pic_sci=", acpi_pic_sci_setup);
-
-#endif /* CONFIG_ACPI_BUS */
-
-int acpi_gsi_to_irq(u32 gsi, unsigned int *irq)
-{
-#ifdef CONFIG_X86_IO_APIC
-	if (use_pci_vector() && !platform_legacy_irq(gsi))
- 		*irq = IO_APIC_VECTOR(gsi);
-	else
-#endif
-		*irq = gsi;
-	return 0;
-}
-
-static unsigned long __init
-acpi_scan_rsdp (
-	unsigned long		start,
-	unsigned long		length)
-{
-	unsigned long		offset = 0;
-	unsigned long		sig_len = sizeof("RSD PTR ") - 1;
-
-	/*
-	 * Scan all 16-byte boundaries of the physical memory region for the
-	 * RSDP signature.
-	 */
-	for (offset = 0; offset < length; offset += 16) {
-		if (strncmp((char *) (start + offset), "RSD PTR ", sig_len))
-			continue;
-		return (start + offset);
-	}
-
-	return 0;
-}
-
-
-unsigned long __init
-acpi_find_rsdp (void)
-{
-	unsigned long		rsdp_phys = 0;
-
-	/*
-	 * Scan memory looking for the RSDP signature. First search EBDA (low
-	 * memory) paragraphs and then search upper memory (E0000-FFFFF).
-	 */
-	rsdp_phys = acpi_scan_rsdp (0, 0x400);
-	if (!rsdp_phys)
-		rsdp_phys = acpi_scan_rsdp (0xE0000, 0xFFFFF);
-
-	return rsdp_phys;
-}
-
-/*
- * acpi_boot_init()
- *  called from setup_arch(), always.
- *     1. maps ACPI tables for later use
- *     2. enumerates lapics
- *     3. enumerates io-apics
- *
- * side effects:
- *     acpi_lapic = 1 if LAPIC found
- *     acpi_ioapic = 1 if IOAPIC found
- *     if (acpi_lapic && acpi_ioapic) smp_found_config = 1;
- *     if acpi_blacklisted() acpi_disabled = 1;
- *     acpi_irq_model=...
- *     ...
- *
- * return value: (currently ignored)
- *     0: success
- *     !0: failure
- */
-
-int __init
-acpi_boot_init (void)
-{
-	int			result = 0;
-
-	if (acpi_disabled && !acpi_ht)
-		return 1;
-
-	/*
-	 * The default interrupt routing model is PIC (8259).  This gets
-	 * overriden if IOAPICs are enumerated (below).
-	 */
-	acpi_irq_model = ACPI_IRQ_MODEL_PIC;
-
-	/* 
-	 * Initialize the ACPI boot-time table parser.
-	 */
-	result = acpi_table_init();
-	if (result) {
-		acpi_disabled = 1;
-		return result;
-	}
-
-	(void) acpi_table_parse(ACPI_BOOT, acpi_parse_sbf);
-
-	result = acpi_blacklisted();
-	if (result) {
-		printk(KERN_WARNING PREFIX "BIOS listed in blacklist, disabling ACPI support\n");
-		acpi_disabled = 1;
-		return result;
-	}
-
-	if (disable_apic) { 
-		printk(KERN_INFO PREFIX "Skipping MADT probe because local APIC is disabled\n");
-		return 0;
-	}
-
-#ifdef CONFIG_X86_LOCAL_APIC
-
-	/* 
-	 * MADT
-	 * ----
-	 * Parse the Multiple APIC Description Table (MADT), if exists.
-	 * Note that this table provides platform SMP configuration 
-	 * information -- the successor to MPS tables.
-	 */
-
-	result = acpi_table_parse(ACPI_APIC, acpi_parse_madt);
-	if (!result) {
-		printk(KERN_WARNING PREFIX "MADT not present\n");
-		return 0;
-	}
-	else if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing MADT\n");
-		return result;
-	}
-	else if (result > 1) 
-		printk(KERN_WARNING PREFIX "Multiple MADT tables exist\n");
-
-	/* 
-	 * Local APIC
-	 * ----------
-	 * Note that the LAPIC address is obtained from the MADT (32-bit value)
-	 * and (optionally) overriden by a LAPIC_ADDR_OVR entry (64-bit value).
-	 */
-
-	result = acpi_table_parse_madt(ACPI_MADT_LAPIC_ADDR_OVR, acpi_parse_lapic_addr_ovr, 0);
-	if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing LAPIC address override entry\n");
-		return result;
-	}
-
-	mp_register_lapic_address(acpi_lapic_addr);
-
-	result = acpi_table_parse_madt(ACPI_MADT_LAPIC, acpi_parse_lapic,
-				       MAX_APICS);
-	if (!result) { 
-		printk(KERN_ERR PREFIX "No LAPIC entries present\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return -ENODEV;
-	}
-	else if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing LAPIC entry\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
-	}
-
-	result = acpi_table_parse_madt(ACPI_MADT_LAPIC_NMI, acpi_parse_lapic_nmi, 0);
-	if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing LAPIC NMI entry\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
-	}
-
-	acpi_lapic = 1;
-
-#endif /*CONFIG_X86_LOCAL_APIC*/
-
-#ifdef CONFIG_X86_IO_APIC
-
-	/* 
-	 * I/O APIC 
-	 * --------
-	 */
-
-       /*
-        * ACPI interpreter is required to complete interrupt setup,
-        * so if it is off, don't enumerate the io-apics with ACPI.
-        * If MPS is present, it will handle them,
-        * otherwise the system will stay in PIC mode
-        */
-        if (acpi_disabled || acpi_noirq) {
-               return 1;
-	}
-
-	/*
-	 * if "noapic" boot option, don't look for IO-APICs
-	 */
-	if (skip_ioapic_setup) {
-		printk(KERN_INFO PREFIX "Skipping IOAPIC probe "
-		       "due to 'noapic' option.\n");
-		return 1;
-	}
-
-	result = acpi_table_parse_madt(ACPI_MADT_IOAPIC, acpi_parse_ioapic, MAX_IO_APICS);
-	if (!result) {
-		printk(KERN_ERR PREFIX "No IOAPIC entries present\n");
-		return -ENODEV;
-	}
-	else if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing IOAPIC entry\n");
-		return result;
-	}
-
-	/* Build a default routing table for legacy (ISA) interrupts. */
-	mp_config_acpi_legacy_irqs();
-
-	result = acpi_table_parse_madt(ACPI_MADT_INT_SRC_OVR, acpi_parse_int_src_ovr, NR_IRQ_VECTORS);
-	if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing interrupt source overrides entry\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
-	}
-
-	result = acpi_table_parse_madt(ACPI_MADT_NMI_SRC, acpi_parse_nmi_src,
-				       NR_IRQ_VECTORS);
-	if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing NMI SRC entry\n");
-		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
-	}
-
-	acpi_irq_model = ACPI_IRQ_MODEL_IOAPIC;
-
-	acpi_irq_balance_set(NULL);
-
-	acpi_ioapic = 1;
-
-#endif /*CONFIG_X86_IO_APIC*/
-
-#ifdef CONFIG_X86_LOCAL_APIC
-	if (acpi_lapic && acpi_ioapic)
-		smp_found_config = 1;
-#endif
-
-#ifdef CONFIG_HPET_TIMER
-	result = acpi_table_parse(ACPI_HPET, acpi_parse_hpet);
-	if (result < 0) 
-		printk("ACPI: no HPET table found (%d).\n", result); 
-#endif
-
-#ifdef CONFIG_PCI_MMCONFIG
-	result = acpi_table_parse(ACPI_MCFG, acpi_parse_mcfg);
-	if (result)
-		printk(KERN_ERR PREFIX "Error %d parsing MCFG\n", result);
-#endif
-
-	return 0;
-}
-
-#endif /*CONFIG_ACPI_BOOT*/
-
diff -purN linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/mpparse.c linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/mpparse.c
--- linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/mpparse.c	2004-03-19 18:38:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/mpparse.c	2004-03-23 06:53:14.000000000 +0000
@@ -33,6 +33,7 @@
 
 /* Have we found an MP table */
 int smp_found_config;
+unsigned int __initdata maxcpus = NR_CPUS;
 
 int acpi_found_madt;
 
@@ -117,6 +118,17 @@ static void __init MP_processor_info (st
 		Dprintk("    Bootup CPU\n");
 		boot_cpu_id = m->mpc_apicid;
 	}
+	if (num_processors >= NR_CPUS) {
+		printk(KERN_WARNING "WARNING: NR_CPUS limit of %i reached."
+			" Processor ignored.\n", NR_CPUS);
+		return;
+	}
+	if (num_processors >= maxcpus) {
+		printk(KERN_WARNING "WARNING: maxcpus limit of %i reached."
+			" Processor ignored.\n", maxcpus);
+		return;
+	}
+
 	num_processors++;
 
 	if (m->mpc_apicid > MAX_APICS) {
@@ -878,71 +890,6 @@ void __init mp_config_acpi_legacy_irqs (
 
 extern FADT_DESCRIPTOR acpi_fadt;
 
-void __init mp_config_ioapic_for_sci(u32 gsi)
-{
-#ifdef CONFIG_ACPI_INTERPRETER
-	int ioapic;
-	int ioapic_pin;
-	struct acpi_table_madt *madt;
-	struct acpi_table_int_src_ovr *entry = NULL;
-	acpi_interrupt_flags flags;
-	void *madt_end;
-	acpi_status status;
-
-	/*
-	 * Ensure that if there is an interrupt source override entry
-	 * for the ACPI SCI, we leave it as is. Unfortunately this involves
-	 * walking the MADT again.
-	 */
-	status = acpi_get_firmware_table("APIC", 1, ACPI_LOGICAL_ADDRESSING,
-		(struct acpi_table_header **) &madt);
-	if (ACPI_SUCCESS(status)) {
-		madt_end = (void *) (unsigned long)madt + madt->header.length;
-
-		entry = (struct acpi_table_int_src_ovr *)
-                ((unsigned long) madt + sizeof(struct acpi_table_madt));
-
-		while ((void *) entry < madt_end) {
-                	if (entry->header.type == ACPI_MADT_INT_SRC_OVR &&
-			    acpi_fadt.sci_int == entry->bus_irq)
-				goto found;
-			
-                	entry = (struct acpi_table_int_src_ovr *)
-                	        ((unsigned long) entry + entry->header.length);
-        	}
-	}
-	/*
-	 * Although the ACPI spec says that the SCI should be level/low
-	 * don't reprogram it unless there is an explicit MADT OVR entry
-	 * instructing us to do so -- otherwise we break Tyan boards which
-	 * have the SCI wired edge/high but no MADT OVR.
-	 */
-	return;
-
-found:
-	/*
-	 * See the note at the end of ACPI 2.0b section
-	 * 5.2.10.8 for what this is about.
-	 */
-	flags = entry->flags;
-	acpi_fadt.sci_int = entry->global_irq;
-	gsi = entry->global_irq;
-
-	ioapic = mp_find_ioapic(gsi);
-
-	ioapic_pin = gsi - mp_ioapic_routing[ioapic].gsi_start;
-
-	/*
-	 * MPS INTI flags:
-	 *  trigger: 0=default, 1=edge, 3=level
-	 *  polarity: 0=default, 1=high, 3=low
-	 * Per ACPI spec, default for SCI means level/low.
-	 */
-	io_apic_set_pci_routing(ioapic, ioapic_pin, gsi, 
-		(flags.trigger == 1 ? 0 : 1), (flags.polarity == 1 ? 0 : 1));
-#endif
-}
-
 #ifdef CONFIG_ACPI_PCI
 
 void __init mp_parse_prt (void)
diff -purN linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/setup.c linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/setup.c
--- linux-post-2.6.5-rc2-20040323/arch/x86_64/kernel/setup.c	2004-03-17 03:45:56.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/arch/x86_64/kernel/setup.c	2004-03-23 06:53:14.000000000 +0000
@@ -68,6 +68,7 @@ int acpi_disabled = 0;
 
 #ifdef	CONFIG_ACPI_BOOT
 extern int __initdata acpi_ht;
+extern acpi_interrupt_flags	acpi_sci_flags;
 /* int __initdata acpi_force = 0; */
 #endif
 
@@ -201,7 +202,18 @@ static __init void parse_cmdline_early (
 	for (;;) {
 		if (c != ' ') 
 			goto next_char; 
- 
+
+#ifdef  CONFIG_SMP
+		/*
+		 * If the BIOS enumerates physical processors before logical,
+		 * maxcpus=N at enumeration-time can be used to disable HT.
+		 */
+		else if (!memcmp(from, "maxcpus=", 8)) {
+			extern unsigned int maxcpus;
+
+			maxcpus = simple_strtoul(from + 8, NULL, 0);
+		}
+#endif
 #ifdef CONFIG_ACPI_BOOT
 		/* "acpi=off" disables both ACPI table parsing and interpreter init */
 		if (!memcmp(from, "acpi=off", 8))
@@ -218,6 +230,17 @@ static __init void parse_cmdline_early (
 		if (!memcmp(from, "acpi=ht", 7)) { 
 			acpi_ht = 1; 
 		}
+                else if (!memcmp(from, "pci=noacpi", 10)) 
+                        acpi_noirq_set();
+
+		else if (!memcmp(from, "acpi_sci=edge", 13))
+			acpi_sci_flags.trigger =  1;
+		else if (!memcmp(from, "acpi_sci=level", 14))
+			acpi_sci_flags.trigger = 3;
+		else if (!memcmp(from, "acpi_sci=high", 13))
+			acpi_sci_flags.polarity = 1;
+		else if (!memcmp(from, "acpi_sci=low", 12))
+			acpi_sci_flags.polarity = 3;
 
 		/* acpi=strict disables out-of-spec workarounds */
 		else if (!memcmp(from, "acpi=strict", 11)) {
diff -purN linux-post-2.6.5-rc2-20040323/drivers/acpi/Kconfig linux-post-2.6.5-rc2-20040326/drivers/acpi/Kconfig
--- linux-post-2.6.5-rc2-20040323/drivers/acpi/Kconfig	2004-02-27 07:02:52.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/acpi/Kconfig	2004-03-23 06:32:11.000000000 +0000
@@ -255,6 +255,7 @@ config X86_PM_TIMER
 	bool "Power Management Timer Support"
 	depends on X86 && ACPI
 	depends on ACPI_BOOT && EXPERIMENTAL
+	depends on !X86_64
 	default n
 	help
 	  The Power Management Timer is available on all ACPI-capable,
diff -purN linux-post-2.6.5-rc2-20040323/drivers/acpi/bus.c linux-post-2.6.5-rc2-20040326/drivers/acpi/bus.c
--- linux-post-2.6.5-rc2-20040323/drivers/acpi/bus.c	2004-02-04 05:29:19.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/acpi/bus.c	2004-03-23 06:32:11.000000000 +0000
@@ -39,7 +39,9 @@
 #define _COMPONENT		ACPI_BUS_COMPONENT
 ACPI_MODULE_NAME		("acpi_bus")
 
-extern void __init acpi_pic_sci_set_trigger(unsigned int irq);
+#ifdef	CONFIG_X86
+extern void __init acpi_pic_sci_set_trigger(unsigned int irq, u16 trigger);
+#endif
 
 FADT_DESCRIPTOR			acpi_fadt;
 struct acpi_device		*acpi_root;
@@ -611,11 +613,18 @@ acpi_bus_init (void)
 	}
 
 #ifdef CONFIG_X86
-	/* Ensure the SCI is set to level-triggered, active-low */
-	if (acpi_ioapic)
-		mp_config_ioapic_for_sci(acpi_fadt.sci_int);
-	else
-		acpi_pic_sci_set_trigger(acpi_fadt.sci_int);
+	if (!acpi_ioapic) {
+		extern acpi_interrupt_flags acpi_sci_flags;
+		/* Set PIC-mode SCI trigger type */
+		acpi_pic_sci_set_trigger(acpi_fadt.sci_int, acpi_sci_flags.trigger);
+	} else {
+		extern int acpi_sci_override_gsi;
+		/*
+		 * now that acpi_fadt is initialized,
+		 * update it with result from INT_SRC_OVR parsing
+		 */
+		acpi_fadt.sci_int = acpi_sci_override_gsi;
+	}
 #endif
 
 	status = acpi_enable_subsystem(ACPI_FULL_INITIALIZATION);
@@ -704,29 +713,14 @@ static int __init acpi_init (void)
 			pm_active = 1;
 		else {
 			printk(KERN_INFO PREFIX "APM is already active, exiting\n");
-			acpi_disabled = 1;
+			disable_acpi();
 			result = -ENODEV;
 		}
 #endif
 	} else
-		acpi_disabled = 1;
+		disable_acpi();
 
 	return_VALUE(result);
 }
 
-
-static int __init acpi_setup(char *str)
-{
-	while (str && *str) {
-		if (strncmp(str, "off", 3) == 0)
-			acpi_disabled = 1;
-		str = strchr(str, ',');
-		if (str)
-			str += strspn(str, ", \t");
-	}
-	return 1;
-}
-
 subsys_initcall(acpi_init);
-
-__setup("acpi=", acpi_setup);
diff -purN linux-post-2.6.5-rc2-20040323/drivers/acpi/numa.c linux-post-2.6.5-rc2-20040326/drivers/acpi/numa.c
--- linux-post-2.6.5-rc2-20040323/drivers/acpi/numa.c	2004-02-14 03:40:31.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/acpi/numa.c	2004-02-18 09:19:31.000000000 +0000
@@ -32,12 +32,19 @@
 #include <acpi/acpi_bus.h>
 #include <acpi/acmacros.h>
 
+#define ACPI_NUMA	0x80000000
+#define _COMPONENT	ACPI_NUMA
+	ACPI_MODULE_NAME ("numa")
+
 extern int __init acpi_table_parse_madt_family (enum acpi_table_id id, unsigned long madt_size, int entry_id, acpi_madt_entry_handler handler, unsigned int max_entries);
 
 void __init
 acpi_table_print_srat_entry (
 	acpi_table_entry_header	*header)
 {
+
+	ACPI_FUNCTION_NAME ("acpi_table_print_srat_entry");
+
 	if (!header)
 		return;
 
@@ -47,7 +54,7 @@ acpi_table_print_srat_entry (
 	{
 		struct acpi_table_processor_affinity *p =
 			(struct acpi_table_processor_affinity*) header;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO "SRAT Processor (id[0x%02x] eid[0x%02x]) in proximity domain %d %s\n",
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "SRAT Processor (id[0x%02x] eid[0x%02x]) in proximity domain %d %s\n",
 		       p->apic_id, p->lsapic_eid, p->proximity_domain,
 		       p->flags.enabled?"enabled":"disabled"));
 	}
@@ -57,7 +64,7 @@ acpi_table_print_srat_entry (
 	{
 		struct acpi_table_memory_affinity *p =
 			(struct acpi_table_memory_affinity*) header;
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO "SRAT Memory (0x%08x%08x length 0x%08x%08x type 0x%x) in proximity domain %d %s%s\n",
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "SRAT Memory (0x%08x%08x length 0x%08x%08x type 0x%x) in proximity domain %d %s%s\n",
 		       p->base_addr_hi, p->base_addr_lo, p->length_hi, p->length_lo,
 		       p->memory_type, p->proximity_domain,
 		       p->flags.enabled ? "enabled" : "disabled",
diff -purN linux-post-2.6.5-rc2-20040323/drivers/acpi/pci_irq.c linux-post-2.6.5-rc2-20040326/drivers/acpi/pci_irq.c
--- linux-post-2.6.5-rc2-20040323/drivers/acpi/pci_irq.c	2004-02-04 18:58:03.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/acpi/pci_irq.c	2004-03-22 02:32:47.000000000 +0000
@@ -273,6 +273,10 @@ acpi_pci_irq_lookup (struct pci_bus *bus
 	return_VALUE(entry->irq);
 }
 
+/*
+ * current thinking is that acpi_pci_irq_derive() adds no value
+ * and should be deleted, so warn if it actually does something.
+ */
 
 static int
 acpi_pci_irq_derive (
@@ -303,7 +307,8 @@ acpi_pci_irq_derive (
 		return_VALUE(0);
 	}
 
-	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Derived IRQ %d\n", irq));
+	ACPI_DEBUG_PRINT((ACPI_DB_WARN, "Derive IRQ %d for device %s from %s\n",
+		irq, pci_name(dev), pci_name(bridge)));
 
 	return_VALUE(irq);
 }
@@ -338,6 +343,13 @@ acpi_pci_irq_enable (
 	 * values override any BIOS-assigned IRQs set during boot.
 	 */
  	irq = acpi_pci_irq_lookup(dev->bus, PCI_SLOT(dev->devfn), pin);
+
+	/*
+	 * Check if the device has an IRQ,
+	 * Hotplug devices may get IRQs by scanning
+	 */
+	if (!irq && dev->irq)
+		irq = dev->irq;
  
 	/*
 	 * If no PRT entry was found, we'll try to derive an IRQ from the
diff -purN linux-post-2.6.5-rc2-20040323/drivers/acpi/processor.c linux-post-2.6.5-rc2-20040326/drivers/acpi/processor.c
--- linux-post-2.6.5-rc2-20040323/drivers/acpi/processor.c	2004-02-14 02:38:34.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/acpi/processor.c	2004-03-23 00:49:34.000000000 +0000
@@ -67,8 +67,6 @@
 #define C3_OVERHEAD			4	/* 1us (3.579 ticks per us) */
 
 
-const u32 POWER_OF_2[] = {1,2,4,8,16,32,64};
-
 #define ACPI_PROCESSOR_LIMIT_USER	0
 #define ACPI_PROCESSOR_LIMIT_THERMAL	1
 
@@ -1489,7 +1487,7 @@ acpi_processor_get_throttling_info (
 		return_VALUE(0);
 	}
 
-	pr->throttling.state_count = POWER_OF_2[acpi_fadt.duty_width];
+	pr->throttling.state_count = 1 << acpi_fadt.duty_width;
 
 	/*
 	 * Compute state values. Note that throttling displays a linear power/
diff -purN linux-post-2.6.5-rc2-20040323/drivers/acpi/toshiba_acpi.c linux-post-2.6.5-rc2-20040326/drivers/acpi/toshiba_acpi.c
--- linux-post-2.6.5-rc2-20040323/drivers/acpi/toshiba_acpi.c	2004-02-05 23:20:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/acpi/toshiba_acpi.c	2004-03-23 06:17:28.000000000 +0000
@@ -33,7 +33,7 @@
  *
  */
 
-#define TOSHIBA_ACPI_VERSION	"0.17"
+#define TOSHIBA_ACPI_VERSION	"0.18"
 #define PROC_INTERFACE_VERSION	1
 
 #include <linux/kernel.h>
@@ -41,6 +41,7 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/proc_fs.h>
+#include <asm/uaccess.h>
 
 #include <acpi/acpi_drivers.h>
 
@@ -105,24 +106,6 @@ _set_bit(u32* word, u32 mask, int value)
 	*word = (*word & ~mask) | (mask * value);
 }
 
-/* an sscanf that takes explicit string length */
-static int
-snscanf(const char* str, int n, const char* format, ...)
-{
-	va_list args;
-	int result;
-	char* str2 = kmalloc(n + 1, GFP_KERNEL);
-	if (str2 == 0) return 0;
-	/* NOTE: don't even _think_ about replacing this with strlcpy */
-	strncpy(str2, str, n);
-	str2[n] = 0;
-	va_start(args, format);
-	result = vsscanf(str2, format, args);
-	va_end(args);
-	kfree(str2);
-	return result;
-}
-
 /* acpi interface wrappers
  */
 
@@ -269,10 +252,26 @@ dispatch_read(char* page, char** start, 
 }
 
 static int
-dispatch_write(struct file* file, const char* buffer, unsigned long count,
-	ProcItem* item)
+dispatch_write(struct file* file, __user const char* buffer,
+	unsigned long count, ProcItem* item)
 {
-	return item->write_func(buffer, count);
+	int result;
+	char* tmp_buffer;
+
+	/* Arg buffer points to userspace memory, which can't be accessed
+	 * directly.  Since we're making a copy, zero-terminate the
+	 * destination so that sscanf can be used on it safely.
+	 */
+	tmp_buffer = kmalloc(count + 1, GFP_KERNEL);
+	if (copy_from_user(tmp_buffer, buffer, count)) {
+		result = -EFAULT;
+	}
+	else {
+		tmp_buffer[count] = 0;
+		result = item->write_func(tmp_buffer, count);
+	}
+	kfree(tmp_buffer);
+	return result;
 }
 
 static char*
@@ -300,7 +299,7 @@ write_lcd(const char* buffer, unsigned l
 	int value;
 	u32 hci_result;
 
-	if (snscanf(buffer, count, " brightness : %i", &value) == 1 &&
+	if (sscanf(buffer, " brightness : %i", &value) == 1 &&
 			value >= 0 && value < HCI_LCD_BRIGHTNESS_LEVELS) {
 		value = value << HCI_LCD_BRIGHTNESS_SHIFT;
 		hci_write1(HCI_LCD_BRIGHTNESS, value, &hci_result);
@@ -350,11 +349,11 @@ write_video(const char* buffer, unsigned
 	 *  NOTE: to keep scanning simple, invalid fields are ignored
 	 */
 	while (remain) {
-		if (snscanf(buffer, remain, " lcd_out : %i", &value) == 1)
+		if (sscanf(buffer, " lcd_out : %i", &value) == 1)
 			lcd_out = value & 1;
-		else if (snscanf(buffer, remain, " crt_out : %i", &value) == 1)
+		else if (sscanf(buffer, " crt_out : %i", &value) == 1)
 			crt_out = value & 1;
-		else if (snscanf(buffer, remain, " tv_out : %i", &value) == 1)
+		else if (sscanf(buffer, " tv_out : %i", &value) == 1)
 			tv_out = value & 1;
 		/* advance to one character past the next ; */
 		do {
@@ -407,7 +406,7 @@ write_fan(const char* buffer, unsigned l
 	int value;
 	u32 hci_result;
 
-	if (snscanf(buffer, count, " force_on : %i", &value) == 1 &&
+	if (sscanf(buffer, " force_on : %i", &value) == 1 &&
 			value >= 0 && value <= 1) {
 		hci_write1(HCI_FAN, value, &hci_result);
 		if (hci_result != HCI_SUCCESS)
@@ -458,7 +457,7 @@ write_keys(const char* buffer, unsigned 
 {
 	int value;
 
-	if (snscanf(buffer, count, " hotkey_ready : %i", &value) == 1 &&
+	if (sscanf(buffer, " hotkey_ready : %i", &value) == 1 &&
 			value == 0) {
 		key_event_valid = 0;
 	} else {
diff -purN linux-post-2.6.5-rc2-20040323/drivers/block/Kconfig linux-post-2.6.5-rc2-20040326/drivers/block/Kconfig
--- linux-post-2.6.5-rc2-20040323/drivers/block/Kconfig	2004-03-19 20:39:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/block/Kconfig	2004-03-25 08:39:56.000000000 +0000
@@ -6,7 +6,7 @@ menu "Block devices"
 
 config BLK_DEV_FD
 	tristate "Normal floppy disk support"
-	depends on (!X86_PC9800 && !ARCH_S390 && !M68K) || Q40 || (SUN3X && BROKEN)
+	depends on (!X86_PC9800 && !ARCH_S390 && !M68K && !IA64) || Q40 || (SUN3X && BROKEN)
 	---help---
 	  If you want to use the floppy disk drive(s) of your PC under Linux,
 	  say Y. Information about this driver, especially important for IBM
diff -purN linux-post-2.6.5-rc2-20040323/drivers/cdrom/cdrom.c linux-post-2.6.5-rc2-20040326/drivers/cdrom/cdrom.c
--- linux-post-2.6.5-rc2-20040323/drivers/cdrom/cdrom.c	2004-03-16 08:41:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/cdrom/cdrom.c	2004-03-25 08:39:55.000000000 +0000
@@ -725,7 +725,7 @@ static int cdrom_media_erasable(struct c
 	disc_information di;
 
 	if (cdrom_get_disc_info(cdi, &di))
-		return 0;
+		return -1;
 
 	return di.erasable;
 }
@@ -735,7 +735,16 @@ static int cdrom_media_erasable(struct c
  */
 static int cdrom_dvdram_open_write(struct cdrom_device_info *cdi)
 {
-	return !cdrom_media_erasable(cdi);
+	int ret = cdrom_media_erasable(cdi);
+
+	/*
+	 * allow writable open if media info read worked and media is
+	 * erasable, _or_ if it fails since not all drives support it
+	 */
+	if (!ret)
+		return 1;
+
+	return 0;
 }
 
 static int cdrom_mrw_open_write(struct cdrom_device_info *cdi)
diff -purN linux-post-2.6.5-rc2-20040323/drivers/cdrom/viocd.c linux-post-2.6.5-rc2-20040326/drivers/cdrom/viocd.c
--- linux-post-2.6.5-rc2-20040323/drivers/cdrom/viocd.c	2004-03-07 07:05:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/cdrom/viocd.c	2004-03-23 10:05:25.000000000 +0000
@@ -338,8 +338,9 @@ static void do_viocd_request(request_que
 	struct request *req;
 
 	while ((rwreq == 0) && ((req = elv_next_request(q)) != NULL)) {
-		/* check for any kind of error */
-		if (send_request(req) < 0) {
+		if (!blk_fs_request(req))
+			end_request(req, 0);
+		else if (send_request(req) < 0) {
 			printk(VIOCD_KERN_WARNING
 					"unable to send message to OS/400!");
 			end_request(req, 0);
diff -purN linux-post-2.6.5-rc2-20040323/drivers/char/sn_serial.c linux-post-2.6.5-rc2-20040326/drivers/char/sn_serial.c
--- linux-post-2.6.5-rc2-20040323/drivers/char/sn_serial.c	2004-03-15 14:28:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/char/sn_serial.c	2004-03-22 10:29:18.000000000 +0000
@@ -352,7 +352,7 @@ synch_flush_xmit(void)
 		if (xmit_count > 0) {
 			result = sn_func->sal_puts((char *)start, xmit_count);
 			if (!result)
-				sn_debug_printf("\n*** synch_flush_xmit failed to flush\n");
+				DPRINTF("\n*** synch_flush_xmit failed to flush\n");
 			if (result > 0) {
 				xmit_count -= result;
 				sn_total_tx_count += result;
@@ -389,12 +389,12 @@ sn_poll_transmit_chars(void)
 	xmit_count = (head < tail) ?  (SN_SAL_BUFFER_SIZE - tail) : (head - tail);
 
 	if (xmit_count == 0)
-		sn_debug_printf("\n*** empty xmit_count\n");
+		DPRINTF("\n*** empty xmit_count\n");
 
 	/* use the ops, as we could be on the simulator */
 	result = sn_func->sal_puts((char *)start, xmit_count);
 	if (!result)
-		sn_debug_printf("\n*** error in synchronous sal_puts\n");
+		DPRINTF("\n*** error in synchronous sal_puts\n");
 	/* XXX chadt clean this up */
 	if (result > 0) {
 		xmit_count -= result;
@@ -447,7 +447,7 @@ sn_intr_transmit_chars(void)
 			result = ia64_sn_console_xmit_chars((char *)start, xmit_count);
 #ifdef DEBUG
 			if (!result)
-				sn_debug_printf("`");
+				DPRINTF("`");
 #endif
 			if (result > 0) {
 				xmit_count -= result;
@@ -511,7 +511,7 @@ sn_sal_connect_interrupt(void)
 	if (result >= 0)
 		return console_irq;
 
-	printk(KERN_INFO "sn_serial: console proceeding in polled mode\n");
+	printk(KERN_WARNING "sn_serial: console proceeding in polled mode\n");
 	return 0;
 }
 
@@ -823,7 +823,7 @@ sn_sal_switch_to_asynch(void)
 		return;
 	}
 
-	sn_debug_printf("sn_serial: switch to asynchronous console\n");
+	DPRINTF("sn_serial: switch to asynchronous console\n");
 
 	/* early_printk invocation may have done this for us */
 	if (!sn_func) {
@@ -859,7 +859,7 @@ sn_sal_switch_to_interrupts(void)
 {
 	int irq;
 
-	sn_debug_printf("sn_serial: switching to interrupt driven console\n");
+	DPRINTF("sn_serial: switching to interrupt driven console\n");
 
 	irq = sn_sal_connect_interrupt();
 	if (irq) {
@@ -883,7 +883,7 @@ sn_sal_module_init(void)
 {
 	int retval;
 
-	printk("sn_serial: sn_sal_module_init\n");
+	DPRINTF("sn_serial: sn_sal_module_init\n");
 
 	if (!ia64_platform_is("sn2"))
 		return -ENODEV;
@@ -1016,7 +1016,7 @@ sn_sal_serial_console_init(void)
 {
 	if (ia64_platform_is("sn2")) {
 		sn_sal_switch_to_asynch();
-		sn_debug_printf("sn_sal_serial_console_init : register console\n");
+		DPRINTF("sn_sal_serial_console_init : register console\n");
 		register_console(&sal_console);
 	}
 	return 0;
diff -purN linux-post-2.6.5-rc2-20040323/drivers/char/sonypi.h linux-post-2.6.5-rc2-20040326/drivers/char/sonypi.h
--- linux-post-2.6.5-rc2-20040323/drivers/char/sonypi.h	2004-03-19 06:04:56.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/char/sonypi.h	2004-03-21 05:28:40.000000000 +0000
@@ -396,7 +396,6 @@ struct sonypi_device {
 }
 
 #ifdef CONFIG_ACPI
-extern int acpi_disabled;
 #define SONYPI_ACPI_ACTIVE (!acpi_disabled)
 #else
 #define SONYPI_ACPI_ACTIVE 0
diff -purN linux-post-2.6.5-rc2-20040323/drivers/char/viocons.c linux-post-2.6.5-rc2-20040326/drivers/char/viocons.c
--- linux-post-2.6.5-rc2-20040323/drivers/char/viocons.c	2004-03-19 07:10:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/char/viocons.c	2004-03-23 10:05:26.000000000 +0000
@@ -57,7 +57,6 @@
 
 #define VIOTTY_MAGIC (0x0DCB)
 #define VTTY_PORTS 10
-#define VIOTTY_SERIAL_START 65
 
 #define VIOCONS_KERN_WARN	KERN_WARNING "viocons: "
 #define VIOCONS_KERN_INFO	KERN_INFO "viocons: "
@@ -141,7 +140,6 @@ static struct port_info {
 static void initDataEvent(struct viocharlpevent *viochar, HvLpIndex lp);
 
 static struct tty_driver *viotty_driver;
-static struct tty_driver *viottyS_driver;
 
 void hvlog(char *fmt, ...)
 {
@@ -658,14 +656,14 @@ static struct tty_driver *viocons_device
  * console device I/O methods
  */
 static struct console viocons_early = {
-	.name = "ttyS",
+	.name = "viocons",
 	.write = viocons_write_early,
 	.flags = CON_PRINTBUFFER,
 	.index = -1,
 };
 
 static struct console viocons = {
-	.name = "ttyS",
+	.name = "viocons",
 	.write = viocons_write,
 	.device = viocons_device,
 	.flags = CON_PRINTBUFFER,
@@ -683,9 +681,6 @@ static int viotty_open(struct tty_struct
 
 	port = tty->index;
 
-	if (port >= VIOTTY_SERIAL_START)
-		port -= VIOTTY_SERIAL_START;
-
 	if ((port < 0) || (port >= VTTY_PORTS))
 		return -ENODEV;
 
@@ -823,13 +818,6 @@ static void viotty_put_char(struct tty_s
 }
 
 /*
- * TTY flush_chars method
- */
-static void viotty_flush_chars(struct tty_struct *tty)
-{
-}
-
-/*
  * TTY write_room method
  */
 static int viotty_write_room(struct tty_struct *tty)
@@ -867,17 +855,13 @@ static int viotty_write_room(struct tty_
 }
 
 /*
- * TTY chars_in_buffer_room method
+ * TTY chars_in_buffer method
  */
 static int viotty_chars_in_buffer(struct tty_struct *tty)
 {
 	return 0;
 }
 
-static void viotty_flush_buffer(struct tty_struct *tty)
-{
-}
-
 static int viotty_ioctl(struct tty_struct *tty, struct file *file,
 			unsigned int cmd, unsigned long arg)
 {
@@ -897,43 +881,6 @@ static int viotty_ioctl(struct tty_struc
 	return n_tty_ioctl(tty, file, cmd, arg);
 }
 
-static void viotty_throttle(struct tty_struct *tty)
-{
-}
-
-static void viotty_unthrottle(struct tty_struct *tty)
-{
-}
-
-static void viotty_set_termios(struct tty_struct *tty,
-		struct termios *old_termios)
-{
-}
-
-static void viotty_stop(struct tty_struct *tty)
-{
-}
-
-static void viotty_start(struct tty_struct *tty)
-{
-}
-
-static void viotty_hangup(struct tty_struct *tty)
-{
-}
-
-static void viotty_break(struct tty_struct *tty, int break_state)
-{
-}
-
-static void viotty_send_xchar(struct tty_struct *tty, char ch)
-{
-}
-
-static void viotty_wait_until_sent(struct tty_struct *tty, int timeout)
-{
-}
-
 /*
  * Handle an open charLpEvent.  Could be either interrupt or ack
  */
@@ -1277,20 +1224,9 @@ static struct tty_operations serial_ops 
 	.close = viotty_close,
 	.write = viotty_write,
 	.put_char = viotty_put_char,
-	.flush_chars = viotty_flush_chars,
 	.write_room = viotty_write_room,
 	.chars_in_buffer = viotty_chars_in_buffer,
-	.flush_buffer = viotty_flush_buffer,
 	.ioctl = viotty_ioctl,
-	.throttle = viotty_throttle,
-	.unthrottle = viotty_unthrottle,
-	.set_termios = viotty_set_termios,
-	.stop = viotty_stop,
-	.start = viotty_start,
-	.hangup = viotty_hangup,
-	.break_ctl = viotty_break,
-	.send_xchar = viotty_send_xchar,
-	.wait_until_sent = viotty_wait_until_sent,
 };
 
 static int __init viocons_init2(void)
@@ -1368,31 +1304,12 @@ static int __init viocons_init2(void)
 	viotty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS;
 	tty_set_operations(viotty_driver, &serial_ops);
 
-	viottyS_driver = alloc_tty_driver(VTTY_PORTS);
-	viottyS_driver->owner = THIS_MODULE;
-	viottyS_driver->driver_name = "vioconsole";
-	viottyS_driver->devfs_name = "tts/";
-	viottyS_driver->name = "ttyS";
-	viottyS_driver->major = TTY_MAJOR;
-	viottyS_driver->minor_start = VIOTTY_SERIAL_START;
-	viottyS_driver->type = TTY_DRIVER_TYPE_SERIAL;
-	viottyS_driver->subtype = 1;
-	viottyS_driver->init_termios = tty_std_termios;
-	viottyS_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS;
-	tty_set_operations(viottyS_driver, &serial_ops);
-
 	if (tty_register_driver(viotty_driver)) {
 		printk(VIOCONS_KERN_WARN "couldn't register console driver\n");
 		put_tty_driver(viotty_driver);
 		viotty_driver = NULL;
 	}
 
-	if (tty_register_driver(viottyS_driver)) {
-		printk(VIOCONS_KERN_WARN "couldn't register console S driver\n");
-		put_tty_driver(viottyS_driver);
-		viottyS_driver = NULL;
-	}
-
 	viocons_init_cfu_buffer();
 
 	unregister_console(&viocons_early);
diff -purN linux-post-2.6.5-rc2-20040323/drivers/char/vt.c linux-post-2.6.5-rc2-20040326/drivers/char/vt.c
--- linux-post-2.6.5-rc2-20040323/drivers/char/vt.c	2004-03-20 10:16:46.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/char/vt.c	2004-03-25 17:21:46.000000000 +0000
@@ -2487,11 +2487,13 @@ static void con_close(struct tty_struct 
 	if (tty && tty->count == 1) {
 		struct vt_struct *vt;
 
-		vcs_remove_devfs(tty);
 		vt = tty->driver_data;
 		if (vt)
 			vc_cons[vt->vc_num].d->vc_tty = NULL;
 		tty->driver_data = 0;
+		release_console_sem();
+		vcs_remove_devfs(tty);
+		return;
 	}
 	release_console_sem();
 }
diff -purN linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/shwdt.c linux-post-2.6.5-rc2-20040326/drivers/char/watchdog/shwdt.c
--- linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/shwdt.c	2004-02-11 19:34:35.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/char/watchdog/shwdt.c	2004-03-23 10:05:27.000000000 +0000
@@ -412,7 +412,7 @@ static int __init sh_wdt_init(void)
 		return rc;
 	}
 
-	rc = misc_register(&sh_wdt_miscdev)
+	rc = misc_register(&sh_wdt_miscdev);
 	if (rc) {
 		printk(KERN_ERR PFX "Can't register miscdev on minor=%d (err=%d)\n",
 			sh_wdt_miscdev.minor, rc);
diff -purN linux-post-2.6.5-rc2-20040323/drivers/ide/ide-cd.c linux-post-2.6.5-rc2-20040326/drivers/ide/ide-cd.c
--- linux-post-2.6.5-rc2-20040323/drivers/ide/ide-cd.c	2004-03-16 08:39:41.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/ide/ide-cd.c	2004-03-25 08:39:55.000000000 +0000
@@ -3510,6 +3510,7 @@ static int ide_cdrom_attach (ide_drive_t
 
 	cdrom_read_toc(drive, &sense);
 	g->fops = &idecd_ops;
+	g->flags |= GENHD_FL_REMOVABLE;
 	add_disk(g);
 	return 0;
 failed:
diff -purN linux-post-2.6.5-rc2-20040323/drivers/input/keyboard/maple_keyb.c linux-post-2.6.5-rc2-20040326/drivers/input/keyboard/maple_keyb.c
--- linux-post-2.6.5-rc2-20040323/drivers/input/keyboard/maple_keyb.c	2004-01-20 19:01:49.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/input/keyboard/maple_keyb.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *	$Id: maple_keyb.c,v 1.1 2001/11/02 17:27:32 jsimmons Exp $
+ *	$Id: maple_keyb.c,v 1.4 2004/03/22 01:18:15 lethal Exp $
  * 	SEGA Dreamcast keyboard driver
  *	Based on drivers/usb/usbkbd.c
  */
@@ -125,8 +125,11 @@ static int dc_kbd_connect(struct maple_d
 
 	kbd->dev.evbit[0] = BIT(EV_KEY) | BIT(EV_REP);
 
+	init_input_dev(&kbd->dev);
+
 	for (i=0; i<255; i++)
 		set_bit(dc_kbd_keycode[i], kbd->dev.keybit);
+
 	clear_bit(0, kbd->dev.keybit);
 
 	kbd->dev.private = kbd;
@@ -141,10 +144,7 @@ static int dc_kbd_connect(struct maple_d
 
 	maple_getcond_callback(dev, dc_kbd_callback, 1, MAPLE_FUNC_KEYBOARD);
 
-	printk(KERN_INFO "input%d: keyboard(0x%lx): %s\n",
-	       kbd->dev.number, data, kbd->dev.name);
-
-	MOD_INC_USE_COUNT;
+	printk(KERN_INFO "input: keyboard(0x%lx): %s\n", data, kbd->dev.name);
 
 	return 0;
 }
@@ -155,10 +155,7 @@ static void dc_kbd_disconnect(struct map
 	struct dc_kbd *kbd = dev->private_data;
 
 	input_unregister_device(&kbd->dev);
-
 	kfree(kbd);
-
-	MOD_DEC_USE_COUNT;
 }
 
 
diff -purN linux-post-2.6.5-rc2-20040323/drivers/input/mouse/maplemouse.c linux-post-2.6.5-rc2-20040326/drivers/input/mouse/maplemouse.c
--- linux-post-2.6.5-rc2-20040323/drivers/input/mouse/maplemouse.c	2002-07-25 11:56:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/input/mouse/maplemouse.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *	$Id: maplemouse.c,v 1.1 2001/11/02 17:27:32 jsimmons Exp $
+ *	$Id: maplemouse.c,v 1.2 2004/03/22 01:18:15 lethal Exp $
  * 	SEGA Dreamcast mouse driver
  *	Based on drivers/usb/usbmouse.c
  */
@@ -74,22 +74,21 @@ static int dc_mouse_connect(struct maple
 	mouse->dev.keybit[LONG(BTN_MOUSE)] = BIT(BTN_LEFT) | BIT(BTN_RIGHT) | BIT(BTN_MIDDLE);
 	mouse->dev.relbit[0] = BIT(REL_X) | BIT(REL_Y) | BIT(REL_WHEEL);
 
+	init_input_dev(&mouse->dev);
+
 	mouse->dev.private = mouse;
 	mouse->dev.open = dc_mouse_open;
 	mouse->dev.close = dc_mouse_close;
 	mouse->dev.event = NULL;
 
 	mouse->dev.name = dev->product_name;
-	mouse->dev.idbus = BUS_MAPLE;
+	mouse->dev.id.bustype = BUS_MAPLE;
 	
 	input_register_device(&mouse->dev);
 
 	maple_getcond_callback(dev, dc_mouse_callback, 1, MAPLE_FUNC_MOUSE);
 
-	printk(KERN_INFO "input%d: mouse(0x%lx): %s\n",
-	       mouse->dev.number, data, mouse->dev.name);
-
-	MOD_INC_USE_COUNT;
+	printk(KERN_INFO "input: mouse(0x%lx): %s\n", data, mouse->dev.name);
 
 	return 0;
 }
@@ -100,10 +99,7 @@ static void dc_mouse_disconnect(struct m
 	struct dc_mouse *mouse = dev->private_data;
 
 	input_unregister_device(&mouse->dev);
-
 	kfree(mouse);
-
-	MOD_DEC_USE_COUNT;
 }
 
 
diff -purN linux-post-2.6.5-rc2-20040323/drivers/net/b44.c linux-post-2.6.5-rc2-20040326/drivers/net/b44.c
--- linux-post-2.6.5-rc2-20040323/drivers/net/b44.c	2004-03-14 06:54:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/net/b44.c	2004-03-23 02:44:05.000000000 +0000
@@ -1892,6 +1892,8 @@ static int b44_resume(struct pci_dev *pd
 	if (!netif_running(dev))
 		return 0;
 
+	pci_restore_state(pdev, bp->pci_cfg_state);
+
 	spin_lock_irq(&bp->lock);
 
 	b44_init_rings(bp);
diff -purN linux-post-2.6.5-rc2-20040323/drivers/net/bmac.c linux-post-2.6.5-rc2-20040326/drivers/net/bmac.c
--- linux-post-2.6.5-rc2-20040323/drivers/net/bmac.c	2004-03-02 22:04:18.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/net/bmac.c	2004-03-24 10:05:20.000000000 +0000
@@ -1312,10 +1312,8 @@ static int __devinit bmac_probe(struct m
 	bmwrite(dev, INTDISABLE, DisableAll);
 
 	rev = addr[0] == 0 && addr[1] == 0xA0;
-	for (j = 0; j < 6; ++j) {
+	for (j = 0; j < 6; ++j)
 		dev->dev_addr[j] = rev? bitrev(addr[j]): addr[j];
-		printk("%c%.2x", (j? ':': ' '), dev->dev_addr[j]);
-	}
 
 	/* Enable chip without interrupts for now */
 	bmac_enable_and_reset_chip(dev);
@@ -1380,6 +1378,8 @@ static int __devinit bmac_probe(struct m
 	}
 
 	printk(KERN_INFO "%s: BMAC%s at", dev->name, (is_bmac_plus? "+": ""));
+	for (j = 0; j < 6; ++j)
+		printk("%c%.2x", (j? ':': ' '), dev->dev_addr[j]);
 	XXDEBUG((", base_addr=%#0lx", dev->base_addr));
 	printk("\n");
 	
diff -purN linux-post-2.6.5-rc2-20040323/drivers/net/stnic.c linux-post-2.6.5-rc2-20040326/drivers/net/stnic.c
--- linux-post-2.6.5-rc2-20040323/drivers/net/stnic.c	2004-02-07 04:48:06.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/net/stnic.c	2004-03-23 10:05:27.000000000 +0000
@@ -20,7 +20,7 @@
 
 #include <asm/system.h>
 #include <asm/io.h>
-#include <asm/hitachi_se.h>
+#include <asm/se/se.h>
 #include <asm/machvec.h>
 #ifdef CONFIG_SH_STANDARD_BIOS 
 #include <asm/sh_bios.h>
diff -purN linux-post-2.6.5-rc2-20040323/drivers/scsi/Kconfig linux-post-2.6.5-rc2-20040326/drivers/scsi/Kconfig
--- linux-post-2.6.5-rc2-20040323/drivers/scsi/Kconfig	2004-03-12 18:54:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/scsi/Kconfig	2004-03-25 12:29:40.000000000 +0000
@@ -443,7 +443,7 @@ config SCSI_SATA_PROMISE
 
 config SCSI_SATA_SIL
 	tristate "Silicon Image SATA support"
-	depends on SCSI_SATA && PCI && BROKEN
+	depends on SCSI_SATA && PCI && EXPERIMENTAL
 	help
 	  This option enables support for Silicon Image Serial ATA.
 
diff -purN linux-post-2.6.5-rc2-20040323/drivers/scsi/sata_via.c linux-post-2.6.5-rc2-20040326/drivers/scsi/sata_via.c
--- linux-post-2.6.5-rc2-20040323/drivers/scsi/sata_via.c	2004-03-18 22:55:44.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/scsi/sata_via.c	2004-03-25 12:30:08.000000000 +0000
@@ -205,7 +205,7 @@ static int svia_init_one (struct pci_dev
 	INIT_LIST_HEAD(&probe_ent->node);
 	probe_ent->pdev = pdev;
 	probe_ent->sht = &svia_sht;
-	probe_ent->host_flags = ATA_FLAG_SATA | ATA_FLAG_SATA_RESET |
+	probe_ent->host_flags = ATA_FLAG_SATA | ATA_FLAG_SRST |
 				ATA_FLAG_NO_LEGACY;
 	probe_ent->port_ops = &svia_sata_ops;
 	probe_ent->n_ports = 2;
diff -purN linux-post-2.6.5-rc2-20040323/drivers/scsi/sr.c linux-post-2.6.5-rc2-20040326/drivers/scsi/sr.c
--- linux-post-2.6.5-rc2-20040323/drivers/scsi/sr.c	2004-03-16 08:39:41.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/scsi/sr.c	2004-03-25 08:39:55.000000000 +0000
@@ -575,6 +575,7 @@ static int sr_probe(struct device *dev)
 		goto fail_put;
 
 	dev_set_drvdata(dev, cd);
+	disk->flags |= GENHD_FL_REMOVABLE;
 	add_disk(disk);
 
 	printk(KERN_DEBUG
diff -purN linux-post-2.6.5-rc2-20040323/drivers/serial/Kconfig linux-post-2.6.5-rc2-20040326/drivers/serial/Kconfig
--- linux-post-2.6.5-rc2-20040323/drivers/serial/Kconfig	2004-03-05 20:48:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/serial/Kconfig	2004-03-23 10:05:26.000000000 +0000
@@ -1,7 +1,7 @@
 #
 # Serial device configuration
 #
-# $Id: Config.in,v 1.15 2002/07/06 17:16:24 rmk Exp $
+# $Id: Kconfig,v 1.11 2004/03/11 18:08:04 lethal Exp $
 #
 
 menu "Serial drivers"
@@ -503,6 +503,16 @@ config SERIAL98_CONSOLE
         depends on SERIAL98=y
 	select SERIAL_CORE_CONSOLE
 
+config SERIAL_SH_SCI
+	tristate "SH SCI(F) serial port support"
+	depends on SUPERH
+	select SERIAL_CORE
+
+config SERIAL_SH_SCI_CONSOLE
+	bool "Support for console on SH SCI(F)"
+	depends on SERIAL_SH_SCI=y
+	select SERIAL_CORE_CONSOLE
+
 config SERIAL_AU1X00
 	bool "Enable Au1x00 UART Support"
 	depends on MIPS && SOC_AU1X00
diff -purN linux-post-2.6.5-rc2-20040323/drivers/serial/Makefile linux-post-2.6.5-rc2-20040326/drivers/serial/Makefile
--- linux-post-2.6.5-rc2-20040323/drivers/serial/Makefile	2004-02-21 22:38:19.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/serial/Makefile	2004-03-23 10:05:26.000000000 +0000
@@ -36,3 +36,4 @@ obj-$(CONFIG_SERIAL98) += serial98.o
 obj-$(CONFIG_SERIAL_PMACZILOG) += pmac_zilog.o
 obj-$(CONFIG_SERIAL_AU1X00) += au1x00_uart.o
 obj-$(CONFIG_SERIAL_DZ) += dz.o
+obj-$(CONFIG_SERIAL_SH_SCI) += sh-sci.o
diff -purN linux-post-2.6.5-rc2-20040323/drivers/serial/pmac_zilog.c linux-post-2.6.5-rc2-20040326/drivers/serial/pmac_zilog.c
--- linux-post-2.6.5-rc2-20040323/drivers/serial/pmac_zilog.c	2004-03-22 05:48:53.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/serial/pmac_zilog.c	2004-03-24 10:01:17.000000000 +0000
@@ -1626,7 +1626,7 @@ static int pmz_resume(struct macio_dev *
 	struct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);
 	struct uart_state *state;
 	unsigned long flags;
-	int pwr_delay;
+	int pwr_delay = 0;
 
 	if (uap == NULL)
 		return 0;
diff -purN linux-post-2.6.5-rc2-20040323/drivers/serial/sh-sci.c linux-post-2.6.5-rc2-20040326/drivers/serial/sh-sci.c
--- linux-post-2.6.5-rc2-20040323/drivers/serial/sh-sci.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/serial/sh-sci.c	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,1503 @@
+/*
+ * drivers/serial/sh-sci.c
+ *
+ * SuperH on-chip serial module support.  (SCI with no FIFO / with FIFO)
+ *
+ *  Copyright (C) 2002, 2003  Paul Mundt
+ *
+ * based off of the old drivers/char/sh-sci.c by:
+ *
+ *   Copyright (C) 1999, 2000  Niibe Yutaka
+ *   Copyright (C) 2000  Sugioka Toshinobu
+ *   Modified to support multiple serial ports. Stuart Menefy (May 2000).
+ *   Modified to support SecureEdge. David McCullough (2002)
+ *   Modified to support SH7300 SCIF. Takashi Kusuda (Jun 2003).
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#define DEBUG
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/sysrq.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/console.h>
+
+#ifdef CONFIG_CPU_FREQ
+#include <linux/notifier.h>
+#include <linux/cpufreq.h>
+#endif
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+
+#include <linux/generic_serial.h>
+
+#ifdef CONFIG_SH_STANDARD_BIOS
+#include <asm/sh_bios.h>
+#endif
+
+#if defined(CONFIG_SERIAL_SH_SCI_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include "sh-sci.h"
+
+#ifdef CONFIG_SH_KGDB
+#include <asm/kgdb.h>
+
+static int kgdb_get_char(struct sci_port *port);
+static void kgdb_put_char(struct sci_port *port, char c);
+static void kgdb_handle_error(struct sci_port *port);
+static struct sci_port *kgdb_sci_port;
+#endif /* CONFIG_SH_KGDB */
+
+#ifdef CONFIG_SERIAL_SH_SCI_CONSOLE
+static struct sci_port *serial_console_port = 0;
+#endif /* CONFIG_SERIAL_SH_SCI_CONSOLE */
+
+/* Function prototypes */
+static void sci_stop_tx(struct uart_port *port, unsigned int tty_stop);
+static void sci_start_tx(struct uart_port *port, unsigned int tty_start);
+static void sci_start_rx(struct uart_port *port, unsigned int tty_start);
+static void sci_stop_rx(struct uart_port *port);
+static int sci_request_irq(struct sci_port *port);
+static void sci_free_irq(struct sci_port *port);
+
+static struct sci_port sci_ports[SCI_NPORTS];
+static struct uart_driver sci_uart_driver;
+
+#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+
+static void handle_error(struct sci_port *port)
+{				/* Clear error flags */
+	sci_out(port, SCxSR, SCxSR_ERROR_CLEAR(port));
+}
+
+static int get_char(struct sci_port *port)
+{
+	unsigned long flags;
+	unsigned short status;
+	int c;
+
+	local_irq_save(flags);
+        do {
+		status = sci_in(port, SCxSR);
+		if (status & SCxSR_ERRORS(port)) {
+			handle_error(port);
+			continue;
+		}
+	} while (!(status & SCxSR_RDxF(port)));
+	c = sci_in(port, SCxRDR);
+	sci_in(port, SCxSR);            /* Dummy read */
+	sci_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));
+	local_irq_restore(flags);
+
+	return c;
+}
+
+/* Taken from sh-stub.c of GDB 4.18 */
+static const char hexchars[] = "0123456789abcdef";
+
+static __inline__ char highhex(int  x)
+{
+	return hexchars[(x >> 4) & 0xf];
+}
+
+static __inline__ char lowhex(int  x)
+{
+	return hexchars[x & 0xf];
+}
+
+#endif /* CONFIG_SH_STANDARD_BIOS || CONFIG_SH_KGDB */
+
+/*
+ * Send the packet in buffer.  The host gets one chance to read it.
+ * This routine does not wait for a positive acknowledge.
+ */
+
+#ifdef CONFIG_SERIAL_SH_SCI_CONSOLE
+static void put_char(struct uart_port *port, char c)
+{
+	unsigned long flags;
+	unsigned short status;
+
+	local_irq_save(flags);
+
+	do {
+		status = sci_in(port, SCxSR);
+	} while (!(status & SCxSR_TDxE(port)));
+
+	sci_out(port, SCxTDR, c);
+	sci_in(port, SCxSR);            /* Dummy read */
+	sci_out(port, SCxSR, SCxSR_TDxE_CLEAR(port));
+
+	local_irq_restore(flags);
+}
+
+static void put_string(struct sci_port *sci_port, const char *buffer, int count)
+{
+	struct uart_port *port = &sci_port->port;
+	const unsigned char *p = buffer;
+	int i;
+
+#if defined(CONFIG_SH_STANDARD_BIOS) || defined(CONFIG_SH_KGDB)
+	int checksum;
+	int usegdb=0;
+
+#ifdef CONFIG_SH_STANDARD_BIOS
+    	/* This call only does a trap the first time it is
+	 * called, and so is safe to do here unconditionally
+	 */
+	usegdb |= sh_bios_in_gdb_mode();
+#endif
+#ifdef CONFIG_SH_KGDB
+	usegdb |= (kgdb_in_gdb_mode && (port == kgdb_sci_port));
+#endif
+
+	if (usegdb) {
+	    /*  $<packet info>#<checksum>. */
+	    do {
+		unsigned char c;
+		put_char(port, '$');
+		put_char(port, 'O'); /* 'O'utput to console */
+		checksum = 'O';
+
+		for (i=0; i<count; i++) { /* Don't use run length encoding */
+			int h, l;
+
+			c = *p++;
+			h = highhex(c);
+			l = lowhex(c);
+			put_char(port, h);
+			put_char(port, l);
+			checksum += h + l;
+		}
+		put_char(port, '#');
+		put_char(port, highhex(checksum));
+		put_char(port, lowhex(checksum));
+	    } while  (get_char(port) != '+');
+	} else
+#endif /* CONFIG_SH_STANDARD_BIOS || CONFIG_SH_KGDB */
+	for (i=0; i<count; i++) {
+		if (*p == 10)
+			put_char(port, '\r');
+		put_char(port, *p++);
+	}
+}
+#endif /* CONFIG_SERIAL_SH_SCI_CONSOLE */
+
+
+#ifdef CONFIG_SH_KGDB
+
+/* Is the SCI ready, ie is there a char waiting? */
+static int kgdb_is_char_ready(struct sci_port *port)
+{
+        unsigned short status = sci_in(port, SCxSR);
+
+        if (status & (SCxSR_ERRORS(port) | SCxSR_BRK(port)))
+                kgdb_handle_error(port);
+
+        return (status & SCxSR_RDxF(port));
+}
+
+/* Write a char */
+static void kgdb_put_char(struct sci_port *port, char c)
+{
+        unsigned short status;
+
+        do
+                status = sci_in(port, SCxSR);
+        while (!(status & SCxSR_TDxE(port)));
+
+        sci_out(port, SCxTDR, c);
+        sci_in(port, SCxSR);    /* Dummy read */
+        sci_out(port, SCxSR, SCxSR_TDxE_CLEAR(port));
+}
+
+/* Get a char if there is one, else ret -1 */
+static int kgdb_get_char(struct sci_port *port)
+{
+        int c;
+
+        if (kgdb_is_char_ready(port) == 0)
+                c = -1;
+        else {
+                c = sci_in(port, SCxRDR);
+                sci_in(port, SCxSR);    /* Dummy read */
+                sci_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));
+        }
+
+        return c;
+}
+
+/* Called from kgdbstub.c to get a character, i.e. is blocking */
+static int kgdb_sci_getchar(void)
+{
+        volatile int c;
+
+        /* Keep trying to read a character, this could be neater */
+        while ((c = kgdb_get_char(kgdb_sci_port)) < 0);
+
+        return c;
+}
+
+/* Called from kgdbstub.c to put a character, just a wrapper */
+static void kgdb_sci_putchar(int c)
+{
+
+        kgdb_put_char(kgdb_sci_port, c);
+}
+
+/* Clear any errors on the SCI */
+static void kgdb_handle_error(struct sci_port *port)
+{
+        sci_out(port, SCxSR, SCxSR_ERROR_CLEAR(port));  /* Clear error flags */
+}
+
+/* Breakpoint if there's a break sent on the serial port */
+static void kgdb_break_interrupt(int irq, void *ptr, struct pt_regs *regs)
+{
+        struct sci_port *port = ptr;
+        unsigned short status = sci_in(port, SCxSR);
+
+        if (status & SCxSR_BRK(port)) {
+
+                /* Break into the debugger if a break is detected */
+                BREAKPOINT();
+
+                /* Clear */
+                sci_out(port, SCxSR, SCxSR_BREAK_CLEAR(port));
+        }
+}
+
+#endif /* CONFIG_SH_KGDB */
+
+#if defined(__H8300S__)
+enum { sci_disable, sci_enable };
+
+static void h8300_sci_enable(struct sci_port* port, unsigned int ctrl)
+{
+	volatile unsigned char *mstpcrl=(volatile unsigned char *)MSTPCRL;
+	int ch = (port->base  - SMR0) >> 3;
+	unsigned char mask = 1 << (ch+1);
+
+	if (ctrl == sci_disable) {
+		*mstpcrl |= mask;
+	} else {
+		*mstpcrl &= ~mask;
+	}
+}
+#endif
+
+#if defined(SCI_ONLY) || defined(SCI_AND_SCIF)
+#if defined(__H8300H__) || defined(__H8300S__)
+static void sci_init_pins_sci(struct sci_port* port, unsigned int cflag)
+{
+	int ch = (port->base - SMR0) >> 3;
+
+	/* set DDR regs */
+	H8300_GPIO_DDR(h8300_sci_pins[ch].port,h8300_sci_pins[ch].rx,H8300_GPIO_INPUT);
+	H8300_GPIO_DDR(h8300_sci_pins[ch].port,h8300_sci_pins[ch].tx,H8300_GPIO_OUTPUT);
+	/* tx mark output*/
+	H8300_SCI_DR(ch) |= h8300_sci_pins[ch].tx;
+}
+#else
+static void sci_init_pins_sci(struct uart_port *port, unsigned int cflag)
+{
+}
+#endif
+#endif
+
+#if defined(SCIF_ONLY) || defined(SCI_AND_SCIF)
+#if defined(CONFIG_CPU_SH3)
+/* For SH7707, SH7709, SH7709A, SH7729 */
+static void sci_init_pins_scif(struct uart_port *port, unsigned int cflag)
+{
+	unsigned int fcr_val = 0;
+
+	{
+		unsigned short data;
+
+		/* We need to set SCPCR to enable RTS/CTS */
+		data = ctrl_inw(SCPCR);
+		/* Clear out SCP7MD1,0, SCP6MD1,0, SCP4MD1,0*/
+		ctrl_outw(data&0x0fcf, SCPCR);
+	}
+	if (cflag & CRTSCTS)
+		fcr_val |= SCFCR_MCE;
+	else {
+		unsigned short data;
+
+		/* We need to set SCPCR to enable RTS/CTS */
+		data = ctrl_inw(SCPCR);
+		/* Clear out SCP7MD1,0, SCP4MD1,0,
+		   Set SCP6MD1,0 = {01} (output)  */
+		ctrl_outw((data&0x0fcf)|0x1000, SCPCR);
+
+		data = ctrl_inb(SCPDR);
+		/* Set /RTS2 (bit6) = 0 */
+		ctrl_outb(data&0xbf, SCPDR);
+	}
+	sci_out(port, SCFCR, fcr_val);
+}
+
+static void sci_init_pins_irda(struct uart_port *port, unsigned int cflag)
+{
+	unsigned int fcr_val = 0;
+
+	if (cflag & CRTSCTS)
+		fcr_val |= SCFCR_MCE;
+
+	sci_out(port, SCFCR, fcr_val);
+}
+
+#else
+
+/* For SH7750 */
+static void sci_init_pins_scif(struct uart_port *port, unsigned int cflag)
+{
+	unsigned int fcr_val = 0;
+
+	if (cflag & CRTSCTS) {
+		fcr_val |= SCFCR_MCE;
+	} else {
+		ctrl_outw(0x0080, SCSPTR2); /* Set RTS = 1 */
+	}
+	sci_out(port, SCFCR, fcr_val);
+}
+
+#endif
+#endif /* SCIF_ONLY || SCI_AND_SCIF */
+
+/* ********************************************************************** *
+ *                   the interrupt related routines                       *
+ * ********************************************************************** */
+
+static void sci_transmit_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	unsigned int stopped = uart_tx_stopped(port);
+	unsigned long flags;
+	unsigned short status;
+	unsigned short ctrl;
+	int count, txroom;
+
+	status = sci_in(port, SCxSR);
+	if (!(status & SCxSR_TDxE(port))) {
+		local_irq_save(flags);
+		ctrl = sci_in(port, SCSCR);
+		if (uart_circ_empty(xmit)) {
+			ctrl &= ~SCI_CTRL_FLAGS_TIE;
+		} else {
+			ctrl |= SCI_CTRL_FLAGS_TIE;
+		}
+		sci_out(port, SCSCR, ctrl);
+		local_irq_restore(flags);
+		return;
+	}
+
+	if (port->type == PORT_SCIF) {
+		txroom = 16 - (sci_in(port, SCFDR)>>8);
+	} else {
+		txroom = (sci_in(port, SCxSR) & SCI_TDRE)?1:0;
+	}
+
+	count = txroom;
+
+	do {
+		unsigned char c;
+
+		if (port->x_char) {
+			c = port->x_char;
+			port->x_char = 0;
+		} else if (!uart_circ_empty(xmit) && !stopped) {
+			c = xmit->buf[xmit->tail];
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		} else {
+			break;
+		}
+
+		sci_out(port, SCxTDR, c);
+
+		port->icount.tx++;
+	} while (--count > 0);
+
+	sci_out(port, SCxSR, SCxSR_TDxE_CLEAR(port));
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+	if (uart_circ_empty(xmit)) {
+		sci_stop_tx(port, 0);
+	} else {
+		local_irq_save(flags);
+		ctrl = sci_in(port, SCSCR);
+
+		if (port->type == PORT_SCIF) {
+			sci_in(port, SCxSR); /* Dummy read */
+			sci_out(port, SCxSR, SCxSR_TDxE_CLEAR(port));
+		}
+
+		ctrl |= SCI_CTRL_FLAGS_TIE;
+		sci_out(port, SCSCR, ctrl);
+		local_irq_restore(flags);
+	}
+}
+
+/* On SH3, SCIF may read end-of-break as a space->mark char */
+#define STEPFN(c)  ({int __c=(c); (((__c-1)|(__c)) == -1); })
+
+static inline void sci_receive_chars(struct uart_port *port,
+				     struct pt_regs *regs)
+{
+	struct tty_struct *tty = port->info->tty;
+	int i, count, copied = 0;
+	unsigned short status;
+
+	status = sci_in(port, SCxSR);
+	if (!(status & SCxSR_RDxF(port)))
+		return;
+
+	while (1) {
+		if (port->type == PORT_SCIF) {
+			count = sci_in(port, SCFDR)&0x001f;
+		} else {
+			count = (sci_in(port, SCxSR)&SCxSR_RDxF(port))?1:0;
+		}
+
+		/* Don't copy more bytes than there is room for in the buffer */
+		if (tty->flip.count + count > TTY_FLIPBUF_SIZE)
+			count = TTY_FLIPBUF_SIZE - tty->flip.count;
+
+		/* If for any reason we can't copy more data, we're done! */
+		if (count == 0)
+			break;
+
+		if (port->type == PORT_SCI) {
+			char c = sci_in(port, SCxRDR);
+                       if(((struct sci_port *)port)->break_flag
+			    || uart_handle_sysrq_char(port, c, regs)) {
+				count = 0;
+			} else {
+			    tty->flip.char_buf_ptr[0] = c;
+			    tty->flip.flag_buf_ptr[0] = TTY_NORMAL;
+			}
+		} else {
+			for (i=0; i<count; i++) {
+				char c = sci_in(port, SCxRDR);
+				status = sci_in(port, SCxSR);
+#if defined(CONFIG_CPU_SH3)
+				/* Skip "chars" during break */
+				if (((struct sci_port *)port)->break_flag) {
+					if ((c == 0) &&
+					    (status & SCxSR_FER(port))) {
+						count--; i--;
+						continue;
+					}
+					/* Nonzero => end-of-break */
+					pr_debug("scif: debounce<%02x>\n", c);
+					((struct sci_port *)port)->break_flag = 0;
+					if (STEPFN(c)) {
+						count--; i--;
+						continue;
+					}
+				}
+#endif /* CONFIG_CPU_SH3 */
+				if (uart_handle_sysrq_char(port, c, regs)) {
+					count--; i--;
+					continue;
+				}
+
+				/* Store data and status */
+				tty->flip.char_buf_ptr[i] = c;
+				if (status&SCxSR_FER(port)) {
+					tty->flip.flag_buf_ptr[i] = TTY_FRAME;
+					pr_debug("sci: frame error\n");
+				} else if (status&SCxSR_PER(port)) {
+					tty->flip.flag_buf_ptr[i] = TTY_PARITY;
+					pr_debug("sci: parity error\n");
+				} else {
+					tty->flip.flag_buf_ptr[i] = TTY_NORMAL;
+				}
+			}
+		}
+
+		sci_in(port, SCxSR); /* dummy read */
+		sci_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));
+
+		/* Update the kernel buffer end */
+		tty->flip.count += count;
+		tty->flip.char_buf_ptr += count;
+		tty->flip.flag_buf_ptr += count;
+		copied += count;
+		port->icount.rx += count;
+	}
+
+	if (copied) {
+		/* Tell the rest of the system the news. New characters! */
+		tty_flip_buffer_push(tty);
+	} else {
+		sci_in(port, SCxSR); /* dummy read */
+		sci_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));
+	}
+}
+
+#define SCI_BREAK_JIFFIES (HZ/20)
+/* The sci generates interrupts during the break,
+ * 1 per millisecond or so during the break period, for 9600 baud.
+ * So dont bother disabling interrupts.
+ * But dont want more than 1 break event.
+ * Use a kernel timer to periodically poll the rx line until
+ * the break is finished.
+ */
+static void sci_schedule_break_timer(struct sci_port *port)
+{
+	port->break_timer.expires = jiffies + SCI_BREAK_JIFFIES;
+	add_timer(&port->break_timer);
+}
+/* Ensure that two consecutive samples find the break over. */
+static void sci_break_timer(unsigned long data)
+{
+    struct sci_port * port = (struct sci_port *)data;
+	if(sci_rxd_in(&port->port) == 0) {
+		port->break_flag = 1;
+	    sci_schedule_break_timer(port);
+	} else if(port->break_flag == 1){
+		/* break is over. */
+		port->break_flag = 2;
+	    sci_schedule_break_timer(port);
+	} else port->break_flag = 0;
+}
+
+static inline int sci_handle_errors(struct uart_port *port)
+{
+	int copied = 0;
+	unsigned short status = sci_in(port, SCxSR);
+	struct tty_struct *tty = port->info->tty;
+
+	if (status&SCxSR_ORER(port) && tty->flip.count<TTY_FLIPBUF_SIZE) {
+		/* overrun error */
+		copied++;
+		*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+		pr_debug("sci: overrun error\n");
+	}
+
+	if (status&SCxSR_FER(port) && tty->flip.count<TTY_FLIPBUF_SIZE) {
+		if (sci_rxd_in(port) == 0) {
+			/* Notify of BREAK */
+			struct sci_port * sci_port = (struct sci_port *)port;
+                       if(!sci_port->break_flag) {
+	                        sci_port->break_flag = 1;
+                               sci_schedule_break_timer((struct sci_port *)port);
+				/* Do sysrq handling. */
+				if(uart_handle_break(port)) {
+					return 0;
+				}
+			        pr_debug("sci: BREAK detected\n");
+			        copied++;
+			        *tty->flip.flag_buf_ptr++ = TTY_BREAK;
+                       }
+		}
+		else {
+			/* frame error */
+			copied++;
+			*tty->flip.flag_buf_ptr++ = TTY_FRAME;
+			pr_debug("sci: frame error\n");
+		}
+	}
+
+	if (status&SCxSR_PER(port) && tty->flip.count<TTY_FLIPBUF_SIZE) {
+		/* parity error */
+		copied++;
+		*tty->flip.flag_buf_ptr++ = TTY_PARITY;
+		pr_debug("sci: parity error\n");
+	}
+
+	if (copied) {
+		tty->flip.count += copied;
+		tty_flip_buffer_push(tty);
+	}
+
+	return copied;
+}
+
+static inline int sci_handle_breaks(struct uart_port *port)
+{
+	int copied = 0;
+	unsigned short status = sci_in(port, SCxSR);
+	struct tty_struct *tty = port->info->tty;
+	struct sci_port *s = &sci_ports[port->line];
+
+	if (!s->break_flag && status & SCxSR_BRK(port) &&
+	    tty->flip.count < TTY_FLIPBUF_SIZE) {
+#if defined(CONFIG_CPU_SH3)
+		/* Debounce break */
+		s->break_flag = 1;
+#endif
+		/* Notify of BREAK */
+		copied++;
+		*tty->flip.flag_buf_ptr++ = TTY_BREAK;
+		pr_debug("sci: BREAK detected\n");
+	}
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_ST40STB1) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7760)
+	/* XXX: Handle SCIF overrun error */
+	if (port->type == PORT_SCIF && (sci_in(port, SCLSR) & SCIF_ORER) != 0) {
+		sci_out(port, SCLSR, 0);
+		if(tty->flip.count<TTY_FLIPBUF_SIZE) {
+			copied++;
+			*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+			pr_debug("sci: overrun error\n");
+		}
+	}
+#endif
+
+	if (copied) {
+		tty->flip.count += copied;
+		tty_flip_buffer_push(tty);
+	}
+
+	return copied;
+}
+
+static irqreturn_t sci_rx_interrupt(int irq, void *ptr, struct pt_regs *regs)
+{
+	struct uart_port *port = ptr;
+
+	/* I think sci_receive_chars has to be called irrespective
+	 * of whether the I_IXOFF is set, otherwise, how is the interrupt
+	 * to be disabled?
+	 */
+	sci_receive_chars(port, regs);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sci_tx_interrupt(int irq, void *ptr, struct pt_regs *regs)
+{
+	struct uart_port *port = ptr;
+
+	sci_transmit_chars(port);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sci_er_interrupt(int irq, void *ptr, struct pt_regs *regs)
+{
+	struct uart_port *port = ptr;
+
+	/* Handle errors */
+	if (port->type == PORT_SCI) {
+		if (sci_handle_errors(port)) {
+			/* discard character in rx buffer */
+			sci_in(port, SCxSR);
+			sci_out(port, SCxSR, SCxSR_RDxF_CLEAR(port));
+		}
+	} else {
+		sci_rx_interrupt(irq, ptr, regs);
+	}
+
+	sci_out(port, SCxSR, SCxSR_ERROR_CLEAR(port));
+
+	/* Kick the transmission */
+	sci_tx_interrupt(irq, ptr, regs);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sci_br_interrupt(int irq, void *ptr, struct pt_regs *regs)
+{
+	struct uart_port *port = ptr;
+
+	/* Handle BREAKs */
+	sci_handle_breaks(port);
+	sci_out(port, SCxSR, SCxSR_BREAK_CLEAR(port));
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_CPU_FREQ
+/*
+ * Here we define a transistion notifier so that we can update all of our
+ * ports' baud rate when the peripheral clock changes.
+ */
+static int sci_notifier(struct notifier_block *self, unsigned long phase, void *p)
+{
+	struct cpufreq_freqs *freqs = p;
+	int i;
+
+	if (phase == CPUFREQ_POSTCHANGE) {
+		for (i = 0; i < SCI_NPORTS; i++) {
+			struct uart_port *port = &sci_ports[i];
+
+			/*
+			 * Update the uartclk per-port if frequency has
+			 * changed, since it will no longer necessarily be
+			 * consistent with the old frequency.
+			 *
+			 * Really we want to be able to do something like
+			 * uart_change_speed() or something along those lines
+			 * here to implicitly reset the per-port baud rate..
+			 *
+			 * Clean this up later..
+			 */
+			port->uartclk = current_cpu_data.module_clock * 16;
+		}
+
+		printk("%s: got a postchange notification for cpu %d (old %d, new %d)\n",
+				__FUNCTION__, freqs->cpu, freqs->old, freqs->new);
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block sci_nb = { &sci_notifier, NULL, 0 };
+#endif /* CONFIG_CPU_FREQ */
+
+static int sci_request_irq(struct sci_port *port)
+{
+	int i;
+	irqreturn_t (*handlers[4])(int irq, void *ptr, struct pt_regs *regs) = {
+		sci_er_interrupt, sci_rx_interrupt, sci_tx_interrupt,
+		sci_br_interrupt,
+	};
+	const char *desc[] = { "SCI Receive Error", "SCI Receive Data Full",
+			       "SCI Transmit Data Empty", "SCI Break" };
+
+	for (i = 0; i < ARRAY_SIZE(handlers); i++) {
+		if (!port->irqs[i])
+			continue;
+		if (request_irq(port->irqs[i], handlers[i], SA_INTERRUPT,
+				desc[i], port)) {
+			printk(KERN_ERR "sci: Cannot allocate irq.\n");
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+static void sci_free_irq(struct sci_port *port)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(port->irqs); i++) {
+		if (!port->irqs[i])
+			continue;
+
+		free_irq(port->irqs[i], port);
+	}
+}
+
+static unsigned int sci_tx_empty(struct uart_port *port)
+{
+	/* Can't detect */
+	return TIOCSER_TEMT;
+}
+
+static void sci_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* This routine is used for seting signals of: DTR, DCD, CTS/RTS */
+	/* We use SCIF's hardware for CTS/RTS, so don't need any for that. */
+	/* If you have signals for DTR and DCD, please implement here. */
+}
+
+static unsigned int sci_get_mctrl(struct uart_port *port)
+{
+	/* This routine is used for geting signals of: DTR, DCD, DSR, RI,
+	   and CTS/RTS */
+
+	return TIOCM_DTR | TIOCM_RTS | TIOCM_DSR;
+}
+
+static void sci_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+	struct sci_port *s = &sci_ports[port->line];
+
+	disable_irq(s->irqs[SCIx_TXI_IRQ]);
+	sci_transmit_chars(port);
+	enable_irq(s->irqs[SCIx_TXI_IRQ]);
+}
+
+static void sci_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+	unsigned long flags;
+	unsigned short ctrl;
+
+	/* Clear TIE (Transmit Interrupt Enable) bit in SCSCR */
+	local_irq_save(flags);
+	ctrl = sci_in(port, SCSCR);
+	ctrl &= ~SCI_CTRL_FLAGS_TIE;
+	sci_out(port, SCSCR, ctrl);
+	local_irq_restore(flags);
+}
+
+static void sci_start_rx(struct uart_port *port, unsigned int tty_start)
+{
+	unsigned long flags;
+	unsigned short ctrl;
+
+	/* Set RIE (Receive Interrupt Enable) bit in SCSCR */
+	local_irq_save(flags);
+	ctrl = sci_in(port, SCSCR);
+	ctrl |= SCI_CTRL_FLAGS_RIE;
+	sci_out(port, SCSCR, ctrl);
+	local_irq_restore(flags);
+}
+
+static void sci_stop_rx(struct uart_port *port)
+{
+	unsigned long flags;
+	unsigned short ctrl;
+
+	/* Clear RIE (Receive Interrupt Enable) bit in SCSCR */
+	local_irq_save(flags);
+	ctrl = sci_in(port, SCSCR);
+	ctrl &= ~SCI_CTRL_FLAGS_RIE;
+	sci_out(port, SCSCR, ctrl);
+	local_irq_restore(flags);
+}
+
+static void sci_enable_ms(struct uart_port *port)
+{
+	/* Nothing here yet .. */
+}
+
+static void sci_break_ctl(struct uart_port *port, int break_state)
+{
+	/* Nothing here yet .. */
+}
+
+static int sci_startup(struct uart_port *port)
+{
+	struct sci_port *s = &sci_ports[port->line];
+
+	sci_request_irq(s);
+	sci_start_tx(port, 1);
+	sci_start_rx(port, 1);
+
+#if defined(__H8300S__)
+	h8300_sci_enable(port, sci_enable);
+#endif
+
+	return 0;
+}
+
+static void sci_shutdown(struct uart_port *port)
+{
+	struct sci_port *s = &sci_ports[port->line];
+
+	sci_stop_rx(port);
+	sci_stop_tx(port, 1);
+	sci_free_irq(s);
+
+#if defined(__H8300S__)
+	h8300_sci_enable(port, sci_disable);
+#endif
+}
+
+static void sci_set_termios(struct uart_port *port, struct termios *termios,
+			    struct termios *old)
+{
+	struct sci_port *s = &sci_ports[port->line];
+	unsigned int status, baud, smr_val;
+	unsigned long flags;
+	int t;
+
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	do {
+		status = sci_in(port, SCxSR);
+	} while (!(status & SCxSR_TEND(port)));
+
+	sci_out(port, SCSCR, 0x00);	/* TE=0, RE=0, CKE1=0 */
+
+	if (port->type == PORT_SCIF) {
+		sci_out(port, SCFCR, SCFCR_RFRST | SCFCR_TFRST);
+	}
+
+	smr_val = sci_in(port, SCSMR) & 3;
+	if ((termios->c_cflag & CSIZE) == CS7)
+		smr_val |= 0x40;
+	if (termios->c_cflag & PARENB)
+		smr_val |= 0x20;
+	if (termios->c_cflag & PARODD)
+		smr_val |= 0x30;
+	if (termios->c_cflag & CSTOPB)
+		smr_val |= 0x08;
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	sci_out(port, SCSMR, smr_val);
+
+	switch (baud) {
+		case 0:		t = -1;		break;
+		case 2400:	t = BPS_2400;	break;
+		case 4800:	t = BPS_4800;	break;
+		case 9600:	t = BPS_9600;	break;
+		case 19200:	t = BPS_19200;	break;
+		case 38400:	t = BPS_38400;	break;
+		case 57600:	t = BPS_57600;	break;
+		case 115200:	t = BPS_115200;	break;
+		default:	t = BPS_115200; break;
+	}
+
+	if (t > 0) {
+		if(t >= 256) {
+			sci_out(port, SCSMR, (sci_in(port, SCSMR) & ~3) | 1);
+			t >>= 2;
+		} else {
+			sci_out(port, SCSMR, sci_in(port, SCSMR) & ~3);
+		}
+		sci_out(port, SCBRR, t);
+		udelay((1000000+(baud-1)) / baud); /* Wait one bit interval */
+	}
+
+	s->init_pins(port, termios->c_cflag);
+	sci_out(port, SCSCR, SCSCR_INIT(port));
+
+	if ((termios->c_cflag & CREAD) != 0)
+              sci_start_rx(port,0);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *sci_type(struct uart_port *port)
+{
+	switch (port->type) {
+		case PORT_SCI:	return "sci";
+		case PORT_SCIF:	return "scif";
+		case PORT_IRDA: return "irda";
+	}
+
+	return 0;
+}
+
+static void sci_release_port(struct uart_port *port)
+{
+	/* Nothing here yet .. */
+}
+
+static int sci_request_port(struct uart_port *port)
+{
+	/* Nothing here yet .. */
+	return 0;
+}
+
+static void sci_config_port(struct uart_port *port, int flags)
+{
+	struct sci_port *s = &sci_ports[port->line];
+
+	port->type = s->type;
+}
+
+static int sci_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	struct sci_port *s = &sci_ports[port->line];
+
+	if (ser->irq != s->irqs[SCIx_TXI_IRQ] || ser->irq > NR_IRQS)
+		return -EINVAL;
+	if (ser->baud_base < 2400)
+		/* No paper tape reader for Mitch.. */
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct uart_ops sci_uart_ops = {
+	.tx_empty	= sci_tx_empty,
+	.set_mctrl	= sci_set_mctrl,
+	.get_mctrl	= sci_get_mctrl,
+	.start_tx	= sci_start_tx,
+	.stop_tx	= sci_stop_tx,
+	.stop_rx	= sci_stop_rx,
+	.enable_ms	= sci_enable_ms,
+	.break_ctl	= sci_break_ctl,
+	.startup	= sci_startup,
+	.shutdown	= sci_shutdown,
+	.set_termios	= sci_set_termios,
+	.type		= sci_type,
+	.release_port	= sci_release_port,
+	.request_port	= sci_request_port,
+	.config_port	= sci_config_port,
+	.verify_port	= sci_verify_port,
+};
+
+static struct sci_port sci_ports[SCI_NPORTS] = {
+#if defined(CONFIG_CPU_SUBTYPE_SH7708)
+	{
+		.port	= {
+			.membase	= (void *)0xfffffe80,
+			.mapbase	= 0xfffffe80,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 25,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+		.type		= PORT_SCI,
+		.irqs		= SCI_IRQS,
+		.init_pins	= sci_init_pins_sci,
+	},
+#elif defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709)
+	{
+		.port	= {
+			.membase	= (void *)0xfffffe80,
+			.mapbase	= 0xfffffe80,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 25,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+		.type		= PORT_SCI,
+		.irqs		= SCI_IRQS,
+		.init_pins	= sci_init_pins_sci,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0xa4000150,
+			.mapbase	= 0xa4000150,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 59,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+		.type		= PORT_SCIF,
+		.irqs		= SH3_SCIF_IRQS,
+		.init_pins	= sci_init_pins_scif,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0xa4000140,
+			.mapbase	= 0xa4000140,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 55,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 2,
+		},
+		.type		= PORT_IRDA,
+		.irqs		= SH3_IRDA_IRQS,
+		.init_pins	= sci_init_pins_irda,
+	}
+#elif defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_SH7751)
+	{
+		.port	= {
+			.membase	= (void *)0xffe00000,
+			.mapbase	= 0xffe00000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 25,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+		.type		= PORT_SCI,
+		.irqs		= SCI_IRQS,
+		.init_pins	= sci_init_pins_sci,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0xffe80000,
+			.mapbase	= 0xffe80000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 43,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+		.type		= PORT_SCIF,
+		.irqs		= SH4_SCIF_IRQS,
+		.init_pins	= sci_init_pins_scif,
+	},
+#elif defined(CONFIG_CPU_SUBTYPE_SH7760)
+	{
+		.port	= {
+			.membase	= (void *)0xfe600000,
+			.mapbase	= 0xfe600000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 55,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+		.type		= PORT_SCIF,
+		.irqs		= SH7760_SCIF0_IRQS,
+		.init_pins	= sci_init_pins_scif,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0xfe610000,
+			.mapbase	= 0xfe610000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 75,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+		.type		= PORT_SCIF,
+		.irqs		= SH7760_SCIF1_IRQS,
+		.init_pins	= sci_init_pins_scif,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0xfe620000,
+			.mapbase	= 0xfe620000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 79,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 2,
+		},
+		.type		= PORT_SCIF,
+		.irqs		= SH7760_SCIF2_IRQS,
+		.init_pins	= sci_init_pins_scif,
+	},
+#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+	{
+		.port	= {
+			.membase	= (void *)0xffe00000,
+			.mapbase	= 0xffe00000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 26,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+		.type		= PORT_SCIF,
+		.irqs		= STB1_SCIF1_IRQS,
+		.init_pins	= sci_init_pins_scif,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0xffe80000,
+			.mapbase	= 0xffe80000,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 43,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+		.type		= PORT_SCIF,
+		.irqs		= SH4_SCIF_IRQS,
+		.init_pins	= sci_init_pins_scif,
+	},
+#elif defined(CONFIG_H83007) || defined(CONFIG_H83068)
+	{
+		.port	= {
+			.membase	= (void *)0x00ffffb0,
+			.mapbase	= 0x00ffffb0,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 54,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+		.type		= PORT_SCI,
+		.irqs		= H8300H_SCI_IRQS0,
+		.init_pins	= sci_init_pins_sci,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0x00ffffb8,
+			.mapbase	= 0x00ffffb8,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 58,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+		.type		= PORT_SCI,
+		.irqs		= H8300H_SCI_IRQS1,
+		.init_pins	= sci_init_pins_sci,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0x00ffffc0,
+			.mapbase	= 0x00ffffc0,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 62,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 2,
+		},
+		.type		= PORT_SCI,
+		.irqs		= H8300H_SCI_IRQS2,
+		.init_pins	= sci_init_pins_sci,
+	},
+#elif defined(CONFIG_H8S2678)
+	{
+		.port	= {
+			.membase	= (void *)0x00ffff78,
+			.mapbase	= 0x00ffff78,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 90,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+		.type		= PORT_SCI,
+		.irqs		= H8S_SCI_IRQS0,
+		.init_pins	= sci_init_pins_sci,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0x00ffff80,
+			.mapbase	= 0x00ffff80,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 94,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+		.type		= PORT_SCI,
+		.irqs		= H8S_IRQS1,
+		.init_pins	= sci_init_pins_sci,
+	},
+	{
+		.port	= {
+			.membase	= (void *)0x00ffff88,
+			.mapbase	= 0x00ffff88,
+			.iotype		= SERIAL_IO_MEM,
+			.irq		= 98,
+			.ops		= &sci_uart_ops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 2,
+		},
+		.type		= PORT_SCI,
+		.irqs		= H8S_IRQS2,
+		.init_pins	= sci_init_pins_sci,
+	},
+#else
+#error "CPU subtype not defined"
+#endif
+};
+
+#ifdef CONFIG_SERIAL_SH_SCI_CONSOLE
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ */
+static void serial_console_write(struct console *co, const char *s,
+				 unsigned count)
+{
+	put_string(serial_console_port, s, count);
+}
+
+static int __init serial_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index >= SCI_NPORTS)
+		co->index = 0;
+
+	serial_console_port = &sci_ports[co->index];
+	port = &serial_console_port->port;
+	port->type = serial_console_port->type;
+
+	/*
+	 * We need to set the initial uartclk here, since otherwise it will
+	 * only ever be setup at sci_init() time.
+	 */
+	port->uartclk = current_cpu_data.module_clock * 16;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct console serial_console = {
+	.name		= "ttySC",
+	.device		= uart_console_device,
+	.write		= serial_console_write,
+	.setup		= serial_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &sci_uart_driver,
+};
+
+static int __init sci_console_init(void)
+{
+#ifdef CONFIG_SH_EARLY_PRINTK
+	extern void sh_console_unregister(void);
+
+	/*
+	 * Now that the real console is available, unregister the one we
+	 * used while first booting.
+	 */
+	sh_console_unregister();
+#endif
+
+	register_console(&serial_console);
+
+	return 0;
+}
+
+console_initcall(sci_console_init);
+#endif /* CONFIG_SERIAL_SH_SCI_CONSOLE */
+
+#ifdef CONFIG_SH_KGDB
+/*
+ * FIXME: Most of this can go away.. at the moment, we rely on
+ * arch/sh/kernel/setup.c to do the command line parsing for kgdb, though
+ * most of that can easily be done here instead.
+ *
+ * For the time being, just accept the values that were parsed earlier..
+ */
+static void __init kgdb_console_get_options(struct uart_port *port, int *baud,
+					    int *parity, int *bits)
+{
+	*baud = kgdb_baud;
+	*parity = tolower(kgdb_parity);
+	*bits = kgdb_bits - '0';
+}
+
+/*
+ * The naming here is somewhat misleading, since kgdb_console_setup() takes
+ * care of the early-on initialization for kgdb, regardless of whether we
+ * actually use kgdb as a console or not.
+ *
+ * On the plus side, this lets us kill off the old kgdb_sci_setup() nonsense.
+ */
+int __init kgdb_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port = &sci_ports[kgdb_portnum].port;
+	int baud = 38400;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index >= SCI_NPORTS || co->index != kgdb_portnum)
+		co->index = kgdb_portnum;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		kgdb_console_get_options(port, &baud, &parity, &bits);
+
+	kgdb_getchar = kgdb_sci_getchar;
+	kgdb_putchar = kgdb_sci_putchar;
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+#endif /* CONFIG_SH_KGDB */
+
+#ifdef CONFIG_SH_KGDB_CONSOLE
+static struct console kgdb_console = {
+        .name		= "ttySC",
+        .write		= kgdb_console_write,
+        .setup		= kgdb_console_setup,
+        .flags		= CON_PRINTBUFFER | CON_ENABLED,
+        .index		= -1,
+	.data		= &sci_uart_driver,
+};
+
+/* Register the KGDB console so we get messages (d'oh!) */
+static int __init kgdb_console_init(void)
+{
+        register_console(&kgdb_console);
+
+	return 0;
+}
+
+console_initcall(kgdb_console_init);
+#endif /* CONFIG_SH_KGDB_CONSOLE */
+
+#if defined(CONFIG_SH_KGDB_CONSOLE)
+#define SCI_CONSOLE	&kgdb_console
+#elif defined(CONFIG_SERIAL_SH_SCI_CONSOLE)
+#define SCI_CONSOLE	&serial_console
+#else
+#define SCI_CONSOLE 	0
+#endif
+
+static char banner[] __initdata =
+	KERN_INFO "SuperH SCI(F) driver initialized\n";
+
+static struct uart_driver sci_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "sci",
+#ifdef CONFIG_DEVFS_FS
+	.devfs_name	= "ttsc/",
+#endif
+	.dev_name	= "ttySC",
+	.major		= SCI_MAJOR,
+	.minor		= SCI_MINOR_START,
+	.nr		= SCI_NPORTS,
+	.cons		= SCI_CONSOLE,
+};
+
+static int __init sci_init(void)
+{
+	int chan, ret;
+
+	printk("%s", banner);
+
+	ret = uart_register_driver(&sci_uart_driver);
+	if (ret == 0) {
+		for (chan = 0; chan < SCI_NPORTS; chan++) {
+			struct sci_port *sciport = &sci_ports[chan];
+
+			sciport->port.uartclk = (current_cpu_data.module_clock * 16);
+			uart_add_one_port(&sci_uart_driver, &sciport->port);
+			sciport->break_timer.data = (unsigned long)sciport;
+			sciport->break_timer.function = sci_break_timer;
+			init_timer(&sciport->break_timer);
+		}
+	}
+
+#ifdef CONFIG_CPU_FREQ
+	cpufreq_register_notifier(&sci_nb, CPUFREQ_TRANSITION_NOTIFIER);
+	printk("sci: CPU frequency notifier registered\n");
+#endif
+
+#ifdef CONFIG_SH_STANDARD_BIOS
+	sh_bios_gdb_detach();
+#endif
+
+	return ret;
+}
+
+static void __exit sci_exit(void)
+{
+	int chan;
+
+	for (chan = 0; chan < SCI_NPORTS; chan++)
+		uart_remove_one_port(&sci_uart_driver, &sci_ports[chan].port);
+
+	uart_unregister_driver(&sci_uart_driver);
+}
+
+module_init(sci_init);
+module_exit(sci_exit);
+
diff -purN linux-post-2.6.5-rc2-20040323/drivers/serial/sh-sci.h linux-post-2.6.5-rc2-20040326/drivers/serial/sh-sci.h
--- linux-post-2.6.5-rc2-20040323/drivers/serial/sh-sci.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/serial/sh-sci.h	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,435 @@
+/* $Id: sh-sci.h,v 1.4 2004/02/19 16:43:56 lethal Exp $
+ *
+ *  linux/drivers/serial/sh-sci.h
+ *
+ *  SuperH on-chip serial module support.  (SCI with no FIFO / with FIFO)
+ *  Copyright (C) 1999, 2000  Niibe Yutaka
+ *  Copyright (C) 2000  Greg Banks
+ *  Copyright (C) 2002, 2003  Paul Mundt
+ *  Modified to support multiple serial ports. Stuart Menefy (May 2000).
+ *  Modified to support H8/300 Series Yoshinori Sato (Feb 2004).
+ */
+#include <linux/config.h>
+#include <linux/serial_core.h>
+
+#if defined(__H8300H__) || defined(__H8300S__)
+#include <asm/gpio.h>
+#if defined(CONFIG_H83007) || defined(CONFIG_H83068)
+#include <asm/regs306x.h>
+#endif
+#if defined(CONFIG_H8S2678)
+#include <asm/regs267x.h>
+#endif
+#endif
+
+/* Offsets into the sci_port->irqs array */
+#define SCIx_ERI_IRQ 0
+#define SCIx_RXI_IRQ 1
+#define SCIx_TXI_IRQ 2
+
+/*                     ERI, RXI, TXI, BRI */
+#define SCI_IRQS      { 23,  24,  25,   0 }
+#define SH3_SCIF_IRQS { 56,  57,  59,  58 }
+#define SH3_IRDA_IRQS { 52,  53,  55,  54 }
+#define SH4_SCIF_IRQS { 40,  41,  43,  42 }
+#define STB1_SCIF1_IRQS {23, 24,  26,  25 }
+#define SH7760_SCIF0_IRQS { 52, 53, 55, 54 }
+#define SH7760_SCIF1_IRQS { 72, 73, 75, 74 }
+#define SH7760_SCIF2_IRQS { 76, 77, 79, 78 }
+#define H8300H_SCI_IRQS0 {52, 53, 54,   0 }
+#define H8300H_SCI_IRQS1 {56, 57, 58,   0 }
+#define H8300H_SCI_IRQS2 {60, 61, 62,   0 }
+#define H8S_SCI_IRQS0 {88, 89, 90,   0 }
+#define H8S_SCI_IRQS1 {92, 93, 94,   0 }
+#define H8S_SCI_IRQS2 {96, 97, 98,   0 }
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7708)
+# define SCI_NPORTS 1
+# define SCSPTR 0xffffff7c /* 8 bit */
+# define SCSCR_INIT(port)          0x30 /* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCI_ONLY
+#elif defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709)
+# define SCI_NPORTS 3
+# define SCPCR  0xA4000116 /* 16 bit SCI and SCIF */
+# define SCPDR  0xA4000136 /* 8  bit SCI and SCIF */
+# define SCSCR_INIT(port)          0x30 /* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCI_AND_SCIF
+#elif defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_SH7751)
+# define SCI_NPORTS 2
+# define SCSPTR1 0xffe0001c /* 8  bit SCI */
+# define SCSPTR2 0xFFE80020 /* 16 bit SCIF */
+# define SCIF_ORER 0x0001   /* overrun error bit */
+# define SCSCR_INIT(port) (((port)->type == PORT_SCI) ? \
+	0x30 /* TIE=0,RIE=0,TE=1,RE=1 */ : \
+	0x38 /* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */ )
+# define SCI_AND_SCIF
+#elif defined(CONFIG_CPU_SUBTYPE_SH7760)
+# define SCI_NPORTS 3
+# define SCSPTR0 0xfe600000 /* 16 bit SCIF */
+# define SCSPTR1 0xfe610000 /* 16 bit SCIF */
+# define SCSPTR2 0xfe620000 /* 16 bit SCIF */
+# define SCIF_ORDER 0x0001  /* overrun error bit */
+# define SCSCR_INIT(port)          0x38 /* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
+# define SCIF_ONLY
+#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+# define SCI_NPORTS 2
+# define SCSPTR1 0xffe00020 /* 16 bit SCIF */
+# define SCSPTR2 0xffe80020 /* 16 bit SCIF */
+# define SCIF_ORER 0x0001   /* overrun error bit */
+# define SCSCR_INIT(port)          0x38 /* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
+# define SCIF_ONLY
+#elif defined(CONFIG_H83007) || defined(CONFIG_H83068)
+# define SCI_NPORTS 3
+# define SCSCR_INIT(port)          0x30 /* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCI_ONLY
+# define H8300_SCI_DR(ch) *(volatile char *)(P1DR + h8300_sci_pins[ch].port)
+#elif defined(CONFIG_H8S2678)
+# define SCI_NPORTS 3
+# define SCSCR_INIT(port)          0x30 /* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCI_ONLY
+# define H8300_SCI_DR(ch) *(volatile char *)(P1DR + h8300_sci_pins[ch].port)
+#else
+# error CPU subtype not defined
+#endif
+
+/* SCSCR */
+#define SCI_CTRL_FLAGS_TIE  0x80 /* all */
+#define SCI_CTRL_FLAGS_RIE  0x40 /* all */
+#define SCI_CTRL_FLAGS_TE   0x20 /* all */
+#define SCI_CTRL_FLAGS_RE   0x10 /* all */
+/*      SCI_CTRL_FLAGS_REIE 0x08  * 7750 SCIF */
+/*      SCI_CTRL_FLAGS_MPIE 0x08  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_CTRL_FLAGS_TEIE 0x04  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_CTRL_FLAGS_CKE1 0x02  * all */
+/*      SCI_CTRL_FLAGS_CKE0 0x01  * 7707 SCI/SCIF, 7708 SCI, 7709 SCI/SCIF, 7750 SCI */
+
+/* SCxSR SCI */
+#define SCI_TDRE  0x80 /* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_RDRF  0x40 /* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_ORER  0x20 /* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_FER   0x10 /* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_PER   0x08 /* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_TEND  0x04 /* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_MPB   0x02  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_MPBT  0x01  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+
+#define SCI_ERRORS ( SCI_PER | SCI_FER | SCI_ORER)
+
+/* SCxSR SCIF */
+#define SCIF_ER    0x0080 /* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_TEND  0x0040 /* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_TDFE  0x0020 /* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_BRK   0x0010 /* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_FER   0x0008 /* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_PER   0x0004 /* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_RDF   0x0002 /* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_DR    0x0001 /* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+
+#define SCIF_ERRORS ( SCIF_PER | SCIF_FER | SCIF_ER | SCIF_BRK)
+
+#if defined(SCI_ONLY)
+# define SCxSR_TEND(port)		SCI_TEND
+# define SCxSR_ERRORS(port)		SCI_ERRORS
+# define SCxSR_RDxF(port)               SCI_RDRF
+# define SCxSR_TDxE(port)               SCI_TDRE
+# define SCxSR_ORER(port)		SCI_ORER
+# define SCxSR_FER(port)		SCI_FER
+# define SCxSR_PER(port)		SCI_PER
+# define SCxSR_BRK(port)		0x00
+# define SCxSR_RDxF_CLEAR(port)		0xbc
+# define SCxSR_ERROR_CLEAR(port)	0xc4
+# define SCxSR_TDxE_CLEAR(port)		0x78
+# define SCxSR_BREAK_CLEAR(port)   	0xc4
+#elif defined(SCIF_ONLY)
+# define SCxSR_TEND(port)		SCIF_TEND
+# define SCxSR_ERRORS(port)		SCIF_ERRORS
+# define SCxSR_RDxF(port)               SCIF_RDF
+# define SCxSR_TDxE(port)               SCIF_TDFE
+# define SCxSR_ORER(port)		0x0000
+# define SCxSR_FER(port)		SCIF_FER
+# define SCxSR_PER(port)		SCIF_PER
+# define SCxSR_BRK(port)		SCIF_BRK
+# define SCxSR_RDxF_CLEAR(port)		0x00fc
+# define SCxSR_ERROR_CLEAR(port)	0x0073
+# define SCxSR_TDxE_CLEAR(port)		0x00df
+# define SCxSR_BREAK_CLEAR(port)   	0x00e3
+#else
+# define SCxSR_TEND(port)	 (((port)->type == PORT_SCI) ? SCI_TEND   : SCIF_TEND)
+# define SCxSR_ERRORS(port)	 (((port)->type == PORT_SCI) ? SCI_ERRORS : SCIF_ERRORS)
+# define SCxSR_RDxF(port)        (((port)->type == PORT_SCI) ? SCI_RDRF   : SCIF_RDF)
+# define SCxSR_TDxE(port)        (((port)->type == PORT_SCI) ? SCI_TDRE   : SCIF_TDFE)
+# define SCxSR_ORER(port)        (((port)->type == PORT_SCI) ? SCI_ORER   : 0x0000)
+# define SCxSR_FER(port)         (((port)->type == PORT_SCI) ? SCI_FER    : SCIF_FER)
+# define SCxSR_PER(port)         (((port)->type == PORT_SCI) ? SCI_PER    : SCIF_PER)
+# define SCxSR_BRK(port)         (((port)->type == PORT_SCI) ? 0x00       : SCIF_BRK)
+# define SCxSR_RDxF_CLEAR(port)	 (((port)->type == PORT_SCI) ? 0xbc : 0x00fc)
+# define SCxSR_ERROR_CLEAR(port) (((port)->type == PORT_SCI) ? 0xc4 : 0x0073)
+# define SCxSR_TDxE_CLEAR(port)  (((port)->type == PORT_SCI) ? 0x78 : 0x00df)
+# define SCxSR_BREAK_CLEAR(port) (((port)->type == PORT_SCI) ? 0xc4 : 0x00e3)
+#endif
+
+/* SCFCR */
+#define SCFCR_RFRST 0x0002
+#define SCFCR_TFRST 0x0004
+#define SCFCR_MCE   0x0008
+
+#define SCI_MAJOR		204
+#define SCI_MINOR_START		8
+
+/* Generic serial flags */
+#define SCI_RX_THROTTLE		0x0000001
+
+#define SCI_MAGIC 0xbabeface
+
+/*
+ * Events are used to schedule things to happen at timer-interrupt
+ * time, instead of at rs interrupt time.
+ */
+#define SCI_EVENT_WRITE_WAKEUP	0
+
+struct sci_port {
+	struct uart_port port;
+	int type;
+	unsigned char irqs[4]; /* ERI, RXI, TXI, BRI */
+	void (*init_pins)(struct uart_port *port, unsigned int cflag);
+	int break_flag;
+	struct timer_list break_timer;
+};
+
+#define SCI_IN(size, offset)					\
+  unsigned int addr = port->mapbase + (offset);			\
+  if ((size) == 8) { 						\
+    return ctrl_inb(addr);					\
+  } else {					 		\
+    return ctrl_inw(addr);					\
+  }
+#define SCI_OUT(size, offset, value)				\
+  unsigned int addr = port->mapbase + (offset);			\
+  if ((size) == 8) { 						\
+    ctrl_outb(value, addr);					\
+  } else {							\
+    ctrl_outw(value, addr);					\
+  }
+
+#define CPU_SCIx_FNS(name, sci_offset, sci_size, scif_offset, scif_size)\
+  static inline unsigned int sci_##name##_in(struct uart_port *port)	\
+  {									\
+    if (port->type == PORT_SCI) { 					\
+      SCI_IN(sci_size, sci_offset)					\
+    } else {								\
+      SCI_IN(scif_size, scif_offset);		 			\
+    }									\
+  }									\
+  static inline void sci_##name##_out(struct uart_port *port, unsigned int value) \
+  {									\
+    if (port->type == PORT_SCI) {					\
+      SCI_OUT(sci_size, sci_offset, value)				\
+    } else {								\
+      SCI_OUT(scif_size, scif_offset, value);				\
+    }									\
+  }
+
+#define CPU_SCIF_FNS(name, scif_offset, scif_size)				\
+  static inline unsigned int sci_##name##_in(struct uart_port *port)	\
+  {									\
+    SCI_IN(scif_size, scif_offset);		 			\
+  }									\
+  static inline void sci_##name##_out(struct uart_port *port, unsigned int value) \
+  {									\
+    SCI_OUT(scif_size, scif_offset, value);				\
+  }
+
+#define CPU_SCI_FNS(name, sci_offset, sci_size)				\
+  static inline unsigned int sci_##name##_in(struct sci_port* port)	\
+  {									\
+    SCI_IN(sci_size, sci_offset);		 			\
+  }									\
+  static inline void sci_##name##_out(struct sci_port* port, unsigned int value) \
+  {									\
+    SCI_OUT(sci_size, sci_offset, value);				\
+  }
+
+#ifdef CONFIG_CPU_SH3
+#define SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh4_sci_offset, sh4_sci_size, \
+		 sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size, \
+                 h8_sci_offset, h8_sci_size) \
+  CPU_SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh3_scif_offset, sh3_scif_size)
+#define SCIF_FNS(name, sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIF_FNS(name, sh3_scif_offset, sh3_scif_size)
+#elif defined(__H8300H__) || defined(__H8300S__)
+#define SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh4_sci_offset, sh4_sci_size, \
+		 sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size, \
+                 h8_sci_offset, h8_sci_size) \
+  CPU_SCI_FNS(name, h8_sci_offset, h8_sci_size)
+#define SCIF_FNS(name, sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size)
+#else
+#define SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh4_sci_offset, sh4_sci_size, \
+		 sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size, \
+		 h8_sci_offset, h8_sci_size) \
+  CPU_SCIx_FNS(name, sh4_sci_offset, sh4_sci_size, sh4_scif_offset, sh4_scif_size)
+#define SCIF_FNS(name, sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIF_FNS(name, sh4_scif_offset, sh4_scif_size)
+#endif
+
+/*      reg      SCI/SH3   SCI/SH4  SCIF/SH3   SCIF/SH4  SCI/H8*/
+/*      name     off  sz   off  sz   off  sz   off  sz   off  sz*/
+SCIx_FNS(SCSMR,  0x00,  8, 0x00,  8, 0x00,  8, 0x00, 16, 0x00,  8)
+SCIx_FNS(SCBRR,  0x02,  8, 0x04,  8, 0x02,  8, 0x04,  8, 0x01,  8)
+SCIx_FNS(SCSCR,  0x04,  8, 0x08,  8, 0x04,  8, 0x08, 16, 0x02,  8)
+SCIx_FNS(SCxTDR, 0x06,  8, 0x0c,  8, 0x06,  8, 0x0C,  8, 0x03,  8)
+SCIx_FNS(SCxSR,  0x08,  8, 0x10,  8, 0x08, 16, 0x10, 16, 0x04,  8)
+SCIx_FNS(SCxRDR, 0x0a,  8, 0x14,  8, 0x0A,  8, 0x14,  8, 0x05,  8)
+SCIF_FNS(SCFCR,                      0x0c,  8, 0x18, 16)
+SCIF_FNS(SCFDR,                      0x0e, 16, 0x1C, 16)
+SCIF_FNS(SCLSR,                         0,  0, 0x24, 16)
+
+#define sci_in(port, reg) sci_##reg##_in(port)
+#define sci_out(port, reg, value) sci_##reg##_out(port, value)
+
+/* H8/300 series SCI pins assignment */
+#if defined(__H8300H__) || defined(__H8300S__)
+static const struct __attribute__((packed)) {
+	int port;             /* GPIO port no */
+	unsigned short rx,tx; /* GPIO bit no */
+} h8300_sci_pins[] = {
+#if defined(CONFIG_H83007) || defined(CONFIG_H83068)
+	{    /* SCI0 */
+		.port = H8300_GPIO_P9,
+		.rx   = H8300_GPIO_B2,
+		.tx   = H8300_GPIO_B0,
+	},
+	{    /* SCI1 */
+		.port = H8300_GPIO_P9,
+		.rx   = H8300_GPIO_B3,
+		.tx   = H8300_GPIO_B1,
+	},
+	{    /* SCI2 */
+		.port = H8300_GPIO_PB,
+		.rx   = H8300_GPIO_B7,
+		.tx   = H8300_GPIO_B6,
+	}
+#elif defined(CONFIG_H8S2678)
+	{    /* SCI0 */
+		.port = H8300_GPIO_P3,
+		.rx   = H8300_GPIO_B2,
+		.tx   = H8300_GPIO_B0,
+	},
+	{    /* SCI1 */
+		.port = H8300_GPIO_P3,
+		.rx   = H8300_GPIO_B3,
+		.tx   = H8300_GPIO_B1,
+	},
+	{    /* SCI2 */
+		.port = H8300_GPIO_P5,
+		.rx   = H8300_GPIO_B1,
+		.tx   = H8300_GPIO_B0,
+	}
+#endif
+};
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7708)
+static inline int sci_rxd_in(struct uart_port *port)
+{
+	if (port->mapbase == 0xfffffe80)
+		return ctrl_inb(SCSPTR)&0x01 ? 1 : 0; /* SCI */
+	return 1;
+}
+#elif defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709)
+static inline int sci_rxd_in(struct uart_port *port)
+{
+	if (port->mapbase == 0xfffffe80)
+		return ctrl_inb(SCPDR)&0x01 ? 1 : 0; /* SCI */
+	if (port->mapbase == 0xa4000150)
+		return ctrl_inb(SCPDR)&0x10 ? 1 : 0; /* SCIF */
+	if (port->mapbase == 0xa4000140)
+		return ctrl_inb(SCPDR)&0x04 ? 1 : 0; /* IRDA */
+	return 1;
+}
+#elif defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_SH7751)
+static inline int sci_rxd_in(struct uart_port *port)
+{
+#ifndef SCIF_ONLY
+	if (port->mapbase == 0xffe00000)
+		return ctrl_inb(SCSPTR1)&0x01 ? 1 : 0; /* SCI */
+#endif
+#ifndef SCI_ONLY
+	if (port->mapbase == 0xffe80000)
+		return ctrl_inw(SCSPTR2)&0x0001 ? 1 : 0; /* SCIF */
+#endif
+	return 1;
+}
+#elif defined(CONFIG_CPU_SUBTYPE_SH7760)
+static inline int sci_rxd_in(struct uart_port *port)
+{
+	if (port->mapbase == 0xfe600000)
+		return ctrl_inw(SCSPTR0) & 0x0001 ? 1 : 0; /* SCIF */
+	if (port->mapbase == 0xfe610000)
+		return ctrl_inw(SCSPTR1) & 0x0001 ? 1 : 0; /* SCIF */
+	if (port->mapbase == 0xfe620000)
+		return ctrl_inw(SCSPTR2) & 0x0001 ? 1 : 0; /* SCIF */
+}
+#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+static inline int sci_rxd_in(struct uart_port *port)
+{
+	if (port->mapbase == 0xffe00000)
+		return ctrl_inw(SCSPTR1)&0x0001 ? 1 : 0; /* SCIF */
+	else
+		return ctrl_inw(SCSPTR2)&0x0001 ? 1 : 0; /* SCIF */
+
+}
+#elif defined(__H8300H__) || defined(__H8300S__)
+static inline int sci_rxd_in(struct sci_port *port)
+{
+	int ch = (port->base - SMR0) >> 3;
+	return (H8300_SCI_DR(ch) & h8300_sci_pins[ch].rx) ? 1 : 0;
+}
+#endif
+
+/*
+ * Values for the BitRate Register (SCBRR)
+ *
+ * The values are actually divisors for a frequency which can
+ * be internal to the SH3 (14.7456MHz) or derived from an external
+ * clock source.  This driver assumes the internal clock is used;
+ * to support using an external clock source, config options or
+ * possibly command-line options would need to be added.
+ *
+ * Also, to support speeds below 2400 (why?) the lower 2 bits of
+ * the SCSMR register would also need to be set to non-zero values.
+ *
+ * -- Greg Banks 27Feb2000
+ *
+ * Answer: The SCBRR register is only eight bits, and the value in
+ * it gets larger with lower baud rates. At around 2400 (depending on
+ * the peripherial module clock) you run out of bits. However the
+ * lower two bits of SCSMR allow the module clock to be divided down,
+ * scaling the value which is needed in SCBRR.
+ *
+ * -- Stuart Menefy - 23 May 2000
+ *
+ * I meant, why would anyone bother with bitrates below 2400.
+ *
+ * -- Greg Banks - 7Jul2000
+ *
+ * You "speedist"!  How will I use my 110bps ASR-33 teletype with paper
+ * tape reader as a console!
+ *
+ * -- Mitch Davis - 15 Jul 2000
+ */
+
+#define PCLK           (current_cpu_data.module_clock)
+
+#if !defined(__H8300H__) && !defined(__H8300S__)
+#define SCBRR_VALUE(bps) ((PCLK+16*bps)/(32*bps)-1)
+#else
+#define SCBRR_VALUE(bps) (((CONFIG_CPU_CLOCK*1000/32)/bps)-1)
+#endif
+#define BPS_2400       SCBRR_VALUE(2400)
+#define BPS_4800       SCBRR_VALUE(4800)
+#define BPS_9600       SCBRR_VALUE(9600)
+#define BPS_19200      SCBRR_VALUE(19200)
+#define BPS_38400      SCBRR_VALUE(38400)
+#define BPS_57600      SCBRR_VALUE(57600)
+#define BPS_115200     SCBRR_VALUE(115200)
+
diff -purN linux-post-2.6.5-rc2-20040323/drivers/video/console/fbcon.c linux-post-2.6.5-rc2-20040326/drivers/video/console/fbcon.c
--- linux-post-2.6.5-rc2-20040323/drivers/video/console/fbcon.c	2004-03-16 10:29:46.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/video/console/fbcon.c	2004-03-23 10:05:27.000000000 +0000
@@ -662,19 +662,17 @@ static void fbcon_set_display(struct vc_
 		struct display *q = &fb_display[i];
 		struct vc_data *tmp = vc_cons[i].d;
 		
-		if (vc->vc_font.width > 32) {
-			/* If we are not the first console on this
-			   fb, copy the font from that console */
-			vc->vc_font.width = tmp->vc_font.width;
-			vc->vc_font.height = tmp->vc_font.height;
-			vc->vc_font.data = p->fontdata = q->fontdata;
-			p->userfont = q->userfont;
-			if (p->userfont) {
-				REFCOUNT(p->fontdata)++;
-				charcnt = FNTCHARCNT(p->fontdata);
-			}
-			con_copy_unimap(vc->vc_num, i);
+		/* If we are not the first console on this
+		   fb, copy the font from that console */
+		vc->vc_font.width = tmp->vc_font.width;
+		vc->vc_font.height = tmp->vc_font.height;
+		vc->vc_font.data = p->fontdata = q->fontdata;
+		p->userfont = q->userfont;
+		if (p->userfont) {
+			REFCOUNT(p->fontdata)++;
+			charcnt = FNTCHARCNT(p->fontdata);
 		}
+		con_copy_unimap(vc->vc_num, i);
 	}
 
 	if (!p->fontdata) {
diff -purN linux-post-2.6.5-rc2-20040323/drivers/video/fbmem.c linux-post-2.6.5-rc2-20040326/drivers/video/fbmem.c
--- linux-post-2.6.5-rc2-20040323/drivers/video/fbmem.c	2004-03-02 03:01:44.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/video/fbmem.c	2004-03-23 10:05:27.000000000 +0000
@@ -1181,11 +1181,9 @@ fb_mmap(struct file *file, struct vm_are
 #elif defined(__mips__)
 	pgprot_val(vma->vm_page_prot) &= ~_CACHE_MASK;
 	pgprot_val(vma->vm_page_prot) |= _CACHE_UNCACHED;
-#elif defined(__sh__)
-	pgprot_val(vma->vm_page_prot) &= ~_PAGE_CACHABLE;
 #elif defined(__hppa__)
 	pgprot_val(vma->vm_page_prot) |= _PAGE_NO_CACHE;
-#elif defined(__ia64__) || defined(__arm__)
+#elif defined(__ia64__) || defined(__arm__) || defined(__sh__)
 	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 #else
 #warning What do we have to do here??
diff -purN linux-post-2.6.5-rc2-20040323/drivers/video/hitfb.c linux-post-2.6.5-rc2-20040326/drivers/video/hitfb.c
--- linux-post-2.6.5-rc2-20040323/drivers/video/hitfb.c	2004-02-13 15:19:31.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/video/hitfb.c	2004-03-23 10:05:27.000000000 +0000
@@ -1,16 +1,16 @@
 /*
- * $Id: hitfb.c,v 1.10 2004/02/01 19:46:04 lethal Exp $
+ * $Id: hitfb.c,v 1.12 2004/03/16 00:07:51 lethal Exp $
  * linux/drivers/video/hitfb.c -- Hitachi LCD frame buffer device
  * (C) 1999 Mihai Spatar
  * (C) 2000 YAEGASHI Takeshi
  * (C) 2003, 2004 Paul Mundt
- * (C) 2003 Andriy Skulysh
+ * (C) 2003, 2004 Andriy Skulysh
  *
  *  This file is subject to the terms and conditions of the GNU General Public
  *  License. See the file COPYING in the main directory of this archive for
  *  more details.
  */
- 
+
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -30,139 +30,137 @@
 #include <asm/io.h>
 #include <asm/hd64461/hd64461.h>
 
+#ifdef MACH_HP600
+#include <asm/cpu/dac.h>
+#include <asm/hp6xx/hp6xx.h>
+#endif
+
+#define	WIDTH 640
+
 static struct fb_var_screeninfo hitfb_var __initdata = {
 	.activate	= FB_ACTIVATE_NOW,
 	.height		= -1,
-	.width		= -1,
-	.vmode		= FB_VMODE_NONINTERLACED,
+	.width 		= -1,
+	.vmode 		= FB_VMODE_NONINTERLACED,
 };
 
 static struct fb_fix_screeninfo hitfb_fix __initdata = {
-	.id		= "Hitachi HD64461",
-	.type		= FB_TYPE_PACKED_PIXELS,
-	.ypanstep	= 8,
-	.accel		= FB_ACCEL_NONE,
+	.id 		= "Hitachi HD64461",
+	.type 		= FB_TYPE_PACKED_PIXELS,
+	.ypanstep 	= 8,
+	.accel 		= FB_ACCEL_NONE,
 };
 
 static u32 pseudo_palette[16];
 static struct fb_info fb_info;
 
-
-#define	WIDTH 640
-
-static void hitfb_set_base(u32 offset)
+static inline void hitfb_accel_wait(void)
 {
-	fb_writew(offset>>10,HD64461_LCDCBAR);
-}
-
-static inline void hitfb_accel_wait()
-{
-	while (fb_readw(HD64461_GRCFGR) & HD64461_GRCFGR_ACCSTATUS)
-		;
+	while (fb_readw(HD64461_GRCFGR) & HD64461_GRCFGR_ACCSTATUS) ;
 }
 
 static inline void hitfb_accel_start(int truecolor)
 {
 	if (truecolor) {
-		fb_writew(6,HD64461_GRCFGR);
+		fb_writew(6, HD64461_GRCFGR);
 	} else {
-		fb_writew(7,HD64461_GRCFGR);
+		fb_writew(7, HD64461_GRCFGR);
 	}
 }
 
-static inline void hitfb_accel_set_dest(int truecolor, u16 dx, u16 dy, 
-	u16 width, u16 height)
+static inline void hitfb_accel_set_dest(int truecolor, u16 dx, u16 dy,
+					u16 width, u16 height)
 {
-	u32 saddr=WIDTH*dy+dx;
+	u32 saddr = WIDTH * dy + dx;
 	if (truecolor)
 		saddr <<= 1;
-	
-	fb_writew(width,HD64461_BBTDWR);
-	fb_writew(height,HD64461_BBTDHR);
-	
-	fb_writew(saddr&0xffff,HD64461_BBTDSARL);
-	fb_writew(saddr>>16,HD64461_BBTDSARH);
-}
-
-static inline void hitfb_accel_solidfill(int truecolor, u16 dx, u16 dy, 
-	u16 width, u16 height, u16 color)
-{
-	hitfb_accel_set_dest(truecolor,dx,dy,width,height);
-
-	fb_writew(0x00f0,HD64461_BBTROPR);
-	fb_writew(16,HD64461_BBTMDR);
-	fb_writew(color,HD64461_GRSCR);
 
-	hitfb_accel_start(truecolor);
+	fb_writew(width, HD64461_BBTDWR);
+	fb_writew(height, HD64461_BBTDHR);
+
+	fb_writew(saddr & 0xffff, HD64461_BBTDSARL);
+	fb_writew(saddr >> 16, HD64461_BBTDSARH);
+
 }
 
-static inline void hitfb_accel_bitblt(int truecolor, u16 sx, u16 sy, u16 dx, u16 dy, 
-	u16 width, u16 height, u16 rop, u32 mask_addr)
+static inline void hitfb_accel_solidfill(int truecolor, u16 dx, u16 dy,
+					 u16 width, u16 height, u16 color)
 {
-	u32 saddr,daddr;
-	u32 maddr=0;
-	fb_writew(rop,HD64461_BBTROPR);
-
-	if((sy<dy)||((sy==dy)&&(sx<=dx))) {
-		saddr=WIDTH*(sy+height)+sx+width;
-		daddr=WIDTH*(dy+height)+dx+width;
+	hitfb_accel_set_dest(truecolor, dx, dy, width, height);
 
-		if (mask_addr) {
-			if (truecolor) {
-				maddr=((width>>3)+1)*(height+1)-1;
-			} else {
-				maddr=(((width>>4)+1)*(height+1)-1)*2;
-			}
+	fb_writew(0x00f0, HD64461_BBTROPR);
+	fb_writew(16, HD64461_BBTMDR);
+	fb_writew(color, HD64461_GRSCR);
 
-			fb_writew((1<<5)|1,HD64461_BBTMDR);
-		} else {
-			fb_writew(1,HD64461_BBTMDR);
-		}
+	hitfb_accel_start(truecolor);
+}
+
+static inline void hitfb_accel_bitblt(int truecolor, u16 sx, u16 sy, u16 dx,
+				      u16 dy, u16 width, u16 height, u16 rop,
+				      u32 mask_addr)
+{
+	u32 saddr, daddr;
+	u32 maddr = 0;
+
+	fb_writew(rop, HD64461_BBTROPR);
+	if ((sy < dy) || ((sy == dy) && (sx <= dx))) {
+		saddr = WIDTH * (sy + height) + sx + width;
+		daddr = WIDTH * (dy + height) + dx + width;
+		if (mask_addr) {
+			if (truecolor)
+				maddr = ((width >> 3) + 1) * (height + 1) - 1;
+			else
+				maddr =
+				    (((width >> 4) + 1) * (height + 1) - 1) * 2;
+
+			fb_writew((1 << 5) | 1, HD64461_BBTMDR);
+		} else
+			fb_writew(1, HD64461_BBTMDR);
 	} else {
-		saddr=WIDTH*sy+sx;
-		daddr=WIDTH*dy+dx;
+		saddr = WIDTH * sy + sx;
+		daddr = WIDTH * dy + dx;
 		if (mask_addr) {
-			fb_writew((1<<5),HD64461_BBTMDR);
+			fb_writew((1 << 5), HD64461_BBTMDR);
 		} else {
-			outw(0,HD64461_BBTMDR);
+			fb_writew(0, HD64461_BBTMDR);
 		}
 	}
-
 	if (truecolor) {
-		saddr<<=1;
-		daddr<<=1;
+		saddr <<= 1;
+		daddr <<= 1;
 	}
-
-	fb_writew(width,HD64461_BBTDWR);
-	fb_writew(height,HD64461_BBTDHR);
-	fb_writew(saddr&0xffff,HD64461_BBTSSARL);
-	fb_writew(saddr>>16,HD64461_BBTSSARH);
-	fb_writew(daddr&0xffff,HD64461_BBTDSARL);
-	fb_writew(daddr>>16,HD64461_BBTDSARH);
-
+	fb_writew(width, HD64461_BBTDWR);
+	fb_writew(height, HD64461_BBTDHR);
+	fb_writew(saddr & 0xffff, HD64461_BBTSSARL);
+	fb_writew(saddr >> 16, HD64461_BBTSSARH);
+	fb_writew(daddr & 0xffff, HD64461_BBTDSARL);
+	fb_writew(daddr >> 16, HD64461_BBTDSARH);
 	if (mask_addr) {
-		maddr+=mask_addr;
-		fb_writew(maddr&0xffff,HD64461_BBTMARL);
-		fb_writew(maddr>>16,HD64461_BBTMARH);
+		maddr += mask_addr;
+		fb_writew(maddr & 0xffff, HD64461_BBTMARL);
+		fb_writew(maddr >> 16, HD64461_BBTMARH);
 	}
 	hitfb_accel_start(truecolor);
 }
 
 static void hitfb_fillrect(struct fb_info *p, const struct fb_fillrect *rect)
 {
-	if (rect->rop != ROP_COPY) {
-		cfb_fillrect(p,rect);
-	} else {
-		fb_writew(0x00f0,HD64461_BBTROPR);
-		fb_writew(16,HD64461_BBTMDR);
-
-		if (p->var.bits_per_pixel==16) {
-			fb_writew( ((u32*)(p->pseudo_palette))[rect->color] , HD64461_GRSCR );
-			hitfb_accel_set_dest(1,rect->dx,rect->dy,rect->width,rect->height);
+	if (rect->rop != ROP_COPY)
+		cfb_fillrect(p, rect);
+	else {
+		fb_writew(0x00f0, HD64461_BBTROPR);
+		fb_writew(16, HD64461_BBTMDR);
+
+		if (p->var.bits_per_pixel == 16) {
+			fb_writew(((u32 *) (p->pseudo_palette))[rect->color],
+				  HD64461_GRSCR);
+			hitfb_accel_set_dest(1, rect->dx, rect->dy, rect->width,
+					     rect->height);
 			hitfb_accel_start(1);
 		} else {
 			fb_writew(rect->color, HD64461_GRSCR);
-			hitfb_accel_set_dest(0,rect->dx,rect->dy,rect->width,rect->height);
+			hitfb_accel_set_dest(0, rect->dx, rect->dy, rect->width,
+					     rect->height);
 			hitfb_accel_start(0);
 		}
 		hitfb_accel_wait();
@@ -171,23 +169,24 @@ static void hitfb_fillrect(struct fb_inf
 
 static void hitfb_copyarea(struct fb_info *p, const struct fb_copyarea *area)
 {
-	hitfb_accel_bitblt(p->var.bits_per_pixel==16,area->sx,area->sy,
-		area->dx,area->dy,area->width,area->height,0x00cc,0);
+	hitfb_accel_bitblt(p->var.bits_per_pixel == 16, area->sx, area->sy,
+			   area->dx, area->dy, area->width, area->height,
+			   0x00cc, 0);
 	hitfb_accel_wait();
 }
 
 static int hitfb_pan_display(struct fb_var_screeninfo *var,
 			     struct fb_info *info)
 {
-    int xoffset = var->xoffset;
-    int yoffset = var->yoffset;
+	int xoffset = var->xoffset;
+	int yoffset = var->yoffset;
 
-    if (xoffset!=0)
+	if (xoffset != 0)
 		return -EINVAL;
 
-    hitfb_set_base(yoffset*2*640);
+	fb_writew(yoffset, HD64461_LCDCBAR);
 
-    return 0;
+	return 0;
 }
 
 int hitfb_blank(int blank_mode, struct fb_info *info)
@@ -195,6 +194,12 @@ int hitfb_blank(int blank_mode, struct f
 	unsigned short v;
 
 	if (blank_mode) {
+#ifdef MACH_HP600
+		sh_dac_disable(DAC_LCD_BRIGHTNESS);
+		v = fb_readw(HD64461_GPBDR);
+		v |= HD64461_GPBDR_LCDOFF;
+		fb_writew(v, HD64461_GPBDR);
+#endif
 		v = fb_readw(HD64461_LDR1);
 		v &= ~HD64461_LDR1_DON;
 		fb_writew(v, HD64461_LDR1);
@@ -210,7 +215,12 @@ int hitfb_blank(int blank_mode, struct f
 		v = fb_readw(HD64461_STBCR);
 		v &= ~HD64461_STBCR_SLCDST;
 		fb_writew(v, HD64461_STBCR);
-
+#ifdef MACH_HP600
+		sh_dac_enable(DAC_LCD_BRIGHTNESS);
+		v = fb_readw(HD64461_GPBDR);
+		v &= ~HD64461_GPBDR_LCDOFF;
+		fb_writew(v, HD64461_GPBDR);
+#endif
 		v = fb_readw(HD64461_LDR1);
 		v |= HD64461_LDR1_DON;
 		fb_writew(v, HD64461_LDR1);
@@ -219,36 +229,71 @@ int hitfb_blank(int blank_mode, struct f
 		v &= ~HD64461_LCDCCR_MOFF;
 		fb_writew(v, HD64461_LCDCCR);
 	}
-
 	return 0;
 }
 
 static int hitfb_setcolreg(unsigned regno, unsigned red, unsigned green,
-			   unsigned blue, unsigned transp,
-			   struct fb_info *info)
+			   unsigned blue, unsigned transp, struct fb_info *info)
 {
 	if (regno >= info->cmap.len)
 		return 1;
-    
+
 	switch (info->var.bits_per_pixel) {
-		case 8:
-			fb_writew(regno << 8, HD64461_CPTWAR);
-			fb_writew(red >> 10, HD64461_CPTWDR);
-			fb_writew(green >> 10, HD64461_CPTWDR);
-			fb_writew(blue >> 10, HD64461_CPTWDR);
-			break;
-		case 16:
-			((u32*)(info->pseudo_palette))[regno] =
-					((red   & 0xf800)      ) |
-					((green & 0xfc00) >>  5) |
-					((blue  & 0xf800) >> 11);
-			break;
+	case 8:
+		fb_writew(regno << 8, HD64461_CPTWAR);
+		fb_writew(red >> 10, HD64461_CPTWDR);
+		fb_writew(green >> 10, HD64461_CPTWDR);
+		fb_writew(blue >> 10, HD64461_CPTWDR);
+		break;
+	case 16:
+		((u32 *) (info->pseudo_palette))[regno] =
+		    ((red & 0xf800)) |
+		    ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);
+		break;
 	}
 	return 0;
 }
 
-static int hitfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+static struct fb_ops hitfb_ops = {
+	.owner 			= THIS_MODULE,
+	.fb_setcolreg 	= hitfb_setcolreg,
+	.fb_blank 		= hitfb_blank,
+	.fb_pan_display = hitfb_pan_display,
+	.fb_fillrect 	= hitfb_fillrect,
+	.fb_copyarea 	= hitfb_copyarea,
+	.fb_imageblit 	= cfb_imageblit,
+	.fb_cursor 		= soft_cursor,
+};
+
+int __init hitfb_init(void)
 {
+	unsigned short lcdclor, ldr3, ldvndr;
+	int size;
+
+	hitfb_fix.smem_start = CONFIG_HD64461_IOBASE + 0x02000000;
+	hitfb_fix.smem_len = (MACH_HP690) ? 1024 * 1024 : 512 * 1024;
+
+	lcdclor = fb_readw(HD64461_LCDCLOR);
+	ldvndr = fb_readw(HD64461_LDVNDR);
+	ldr3 = fb_readw(HD64461_LDR3);
+
+	switch (ldr3 & 15) {
+	default:
+	case 4:
+		hitfb_var.bits_per_pixel = 8;
+		hitfb_var.xres = lcdclor;
+		break;
+	case 8:
+		hitfb_var.bits_per_pixel = 16;
+		hitfb_var.xres = lcdclor / 2;
+		break;
+	}
+	hitfb_fix.line_length = lcdclor;
+	hitfb_fix.visual = (hitfb_var.bits_per_pixel == 8) ?
+	    FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+	hitfb_var.yres = ldvndr + 1;
+	hitfb_var.xres_virtual = hitfb_var.xres;
+	hitfb_var.yres_virtual = hitfb_fix.smem_len / lcdclor;
 	switch (hitfb_var.bits_per_pixel) {
 	case 8:
 		hitfb_var.red.offset = 0;
@@ -260,7 +305,7 @@ static int hitfb_check_var(struct fb_var
 		hitfb_var.transp.offset = 0;
 		hitfb_var.transp.length = 0;
 		break;
-	case 16:	/* RGB 565 */
+	case 16:		/* RGB 565 */
 		hitfb_var.red.offset = 11;
 		hitfb_var.red.length = 5;
 		hitfb_var.green.offset = 5;
@@ -272,70 +317,22 @@ static int hitfb_check_var(struct fb_var
 		break;
 	}
 
-	return 0;
-}
+	fb_info.fbops = &hitfb_ops;
+	fb_info.var = hitfb_var;
+	fb_info.fix = hitfb_fix;
+	fb_info.pseudo_palette = pseudo_palette;
+	fb_info.flags = FBINFO_FLAG_DEFAULT;
 
-static struct fb_ops hitfb_ops = {
-	.owner		= THIS_MODULE,
-	.fb_check_var	= hitfb_check_var,
-	.fb_set_par	= hitfb_set_par,
-	.fb_setcolreg	= hitfb_setcolreg,
-	.fb_pan_display = hitfb_pan_display,
-	.fb_blank	= hitfb_blank,
-	.fb_fillrect	= hitfb_fillrect,
-	.fb_copyarea	= hitfb_copyarea,
-	.fb_imageblit	= cfb_imageblit,
-	.fb_cursor	= soft_cursor,
-};
-
-int __init hitfb_init(void)
-{
-	unsigned short lcdclor, ldr3, ldvndr;
-	int size;
-
-	hitfb_fix.smem_start = CONFIG_HD64461_IOBASE + 0x02000000;
-	hitfb_fix.smem_len = (MACH_HP690) ? 1024*1024 : 512*1024;
-
-	lcdclor = inw(HD64461_LCDCLOR);
-	ldvndr = inw(HD64461_LDVNDR);
-	ldr3 = inw(HD64461_LDR3);
-
-	switch (ldr3&15) {
-		default:
-		case 4:
-			hitfb_var.bits_per_pixel = 8;
-			hitfb_var.xres = lcdclor;
-			break;
-		case 8:
-			hitfb_var.bits_per_pixel = 16;
-			hitfb_var.xres = lcdclor/2;
-			break;
-	}
-
-	/* XXX: Most of this should go into hitfb_set_par().. --PFM. */
-	hitfb_fix.line_length = lcdclor;
-	hitfb_fix.visual = (hitfb_var.bits_per_pixel == 8) ?
-		FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
-	hitfb_var.yres = ldvndr+1;
-	hitfb_var.xres_virtual = hitfb_var.xres;
-	hitfb_var.yres_virtual = hitfb_fix.smem_len/lcdclor;
-
-	fb_info.fbops 		= &hitfb_ops;
-	fb_info.var 		= hitfb_var;
-	fb_info.fix 		= hitfb_fix;
-	fb_info.pseudo_palette 	= pseudo_palette;	
-	fb_info.flags 		= FBINFO_FLAG_DEFAULT;
-    	
-	fb_info.screen_base = (void *) hitfb_fix.smem_start;
+	fb_info.screen_base = (void *)hitfb_fix.smem_start;
 
 	size = (fb_info.var.bits_per_pixel == 8) ? 256 : 16;
-	fb_alloc_cmap(&fb_info.cmap, size, 0); 	
+	fb_alloc_cmap(&fb_info.cmap, size, 0);
 
 	if (register_framebuffer(&fb_info) < 0)
 		return -EINVAL;
-    
+
 	printk(KERN_INFO "fb%d: %s frame buffer device\n",
-			fb_info.node, fb_info.fix.id);
+	       fb_info.node, fb_info.fix.id);
 	return 0;
 }
 
@@ -350,4 +347,3 @@ module_exit(hitfb_exit);
 #endif
 
 MODULE_LICENSE("GPL");
-
diff -purN linux-post-2.6.5-rc2-20040323/drivers/video/pvr2fb.c linux-post-2.6.5-rc2-20040326/drivers/video/pvr2fb.c
--- linux-post-2.6.5-rc2-20040323/drivers/video/pvr2fb.c	2004-02-13 15:19:31.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/video/pvr2fb.c	2004-03-23 10:05:27.000000000 +0000
@@ -338,6 +338,7 @@ static int pvr2fb_setcolreg(unsigned int
 		      ((blue  & 0xf800) >> 11);
 
 		pvr2fb_set_pal_entry(par, regno, tmp);
+		((u16*)(info->pseudo_palette))[regno] = tmp;
 		break;
 	    case 24: /* RGB 888 */
 		red >>= 8; green >>= 8; blue >>= 8;
@@ -348,6 +349,7 @@ static int pvr2fb_setcolreg(unsigned int
 		tmp = (transp << 24) | (red << 16) | (green << 8) | blue;
 
 		pvr2fb_set_pal_entry(par, regno, tmp);
+		((u32*)(info->pseudo_palette))[regno] = tmp;
 		break;
 	    default:
 		pr_debug("Invalid bit depth %d?!?\n", info->var.bits_per_pixel);
diff -purN linux-post-2.6.5-rc2-20040323/drivers/video/tgafb.c linux-post-2.6.5-rc2-20040326/drivers/video/tgafb.c
--- linux-post-2.6.5-rc2-20040323/drivers/video/tgafb.c	2003-05-26 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/drivers/video/tgafb.c	2004-03-22 16:15:38.000000000 +0000
@@ -25,6 +25,7 @@
 #include <linux/pci.h>
 #include <asm/io.h>
 #include <video/tgafb.h>
+#include <linux/selection.h>
 
 /*
  * Local functions.
diff -purN linux-post-2.6.5-rc2-20040323/fs/Kconfig linux-post-2.6.5-rc2-20040326/fs/Kconfig
--- linux-post-2.6.5-rc2-20040323/fs/Kconfig	2004-03-16 14:17:55.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/Kconfig	2004-03-23 10:05:26.000000000 +0000
@@ -866,7 +866,7 @@ config TMPFS
 
 config HUGETLBFS
 	bool "HugeTLB file system support"
-	depends X86 || IA64 || PPC64 || SPARC64 || X86_64 || BROKEN
+	depends X86 || IA64 || PPC64 || SPARC64 || SUPERH || X86_64 || BROKEN
 
 config HUGETLB_PAGE
 	def_bool HUGETLBFS
diff -purN linux-post-2.6.5-rc2-20040323/fs/ext2/ialloc.c linux-post-2.6.5-rc2-20040326/fs/ext2/ialloc.c
--- linux-post-2.6.5-rc2-20040323/fs/ext2/ialloc.c	2004-03-07 07:16:09.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/ext2/ialloc.c	2004-03-25 08:39:55.000000000 +0000
@@ -294,7 +294,7 @@ static int find_group_orlov(struct super
 	ndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);
 
 	if ((parent == sb->s_root->d_inode) ||
-	    (parent->i_flags & EXT2_TOPDIR_FL)) {
+	    (EXT2_I(parent)->i_flags & EXT2_TOPDIR_FL)) {
 		struct ext2_group_desc *best_desc = NULL;
 		struct buffer_head *best_bh = NULL;
 		int best_ndir = inodes_per_group;
diff -purN linux-post-2.6.5-rc2-20040323/fs/ext3/ialloc.c linux-post-2.6.5-rc2-20040326/fs/ext3/ialloc.c
--- linux-post-2.6.5-rc2-20040323/fs/ext3/ialloc.c	2004-03-07 07:16:09.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/ext3/ialloc.c	2004-03-25 08:39:55.000000000 +0000
@@ -275,7 +275,7 @@ static int find_group_orlov(struct super
 	ndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);
 
 	if ((parent == sb->s_root->d_inode) ||
-	    (parent->i_flags & EXT3_TOPDIR_FL)) {
+	    (EXT3_I(parent)->i_flags & EXT3_TOPDIR_FL)) {
 		int best_ndir = inodes_per_group;
 		int best_group = -1;
 
diff -purN linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_dmap.c linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_dmap.c
--- linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_dmap.c	2004-03-08 21:55:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_dmap.c	2004-03-24 20:11:45.000000000 +0000
@@ -1526,6 +1526,7 @@ dbAllocAG(struct bmap * bmp, int agno, s
 			if (n == 4) {
 				jfs_error(bmp->db_ipbmap->i_sb,
 					  "dbAllocAG: failed descending stree");
+				release_metapage(mp);
 				return -EIO;
 			}
 		}
@@ -3310,7 +3311,7 @@ int dbExtendFS(struct inode *ipbmap, s64
 	int i, i0 = TRUE, j, j0 = TRUE, k, n;
 	s64 newsize;
 	s64 p;
-	struct metapage *mp, *l2mp, *l1mp, *l0mp;
+	struct metapage *mp, *l2mp, *l1mp = NULL, *l0mp = NULL;
 	struct dmapctl *l2dcp, *l1dcp, *l0dcp;
 	struct dmap *dp;
 	s8 *l0leaf, *l1leaf, *l2leaf;
@@ -3513,6 +3514,7 @@ int dbExtendFS(struct inode *ipbmap, s64
 			 */
 			*l1leaf = dbInitDmapCtl(l0dcp, 0, ++i);
 			write_metapage(l0mp);
+			l0mp = NULL;
 
 			if (nblocks)
 				l1leaf++;	/* continue for next L0 */
@@ -3536,6 +3538,7 @@ int dbExtendFS(struct inode *ipbmap, s64
 		 */
 		*l2leaf = dbInitDmapCtl(l1dcp, 1, ++j);
 		write_metapage(l1mp);
+		l1mp = NULL;
 
 		if (nblocks)
 			l2leaf++;	/* continue for next L1 */
@@ -3554,17 +3557,20 @@ int dbExtendFS(struct inode *ipbmap, s64
 
 	jfs_error(ipbmap->i_sb,
 		  "dbExtendFS: function has not returned as expected");
+errout:
+	if (l0mp)
+		release_metapage(l0mp);
+	if (l1mp)
+		release_metapage(l1mp);
+	release_metapage(l2mp);
 	return -EIO;
 
 	/*
 	 *      finalize bmap control page
 	 */
-      finalize:
+finalize:
 
 	return 0;
-
-      errout:
-	return -EIO;
 }
 
 
diff -purN linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_dtree.c linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_dtree.c
--- linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_dtree.c	2004-03-08 21:55:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_dtree.c	2004-03-24 20:11:46.000000000 +0000
@@ -1423,8 +1423,10 @@ static int dtSplitPage(tid_t tid, struct
 	 */
 	if (nextbn != 0) {
 		DT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);
-		if (rc)
+		if (rc) {
+			discard_metapage(rmp);
 			return rc;
+		}
 
 		BT_MARK_DIRTY(mp, ip);
 		/*
@@ -2235,8 +2237,10 @@ static int dtDeleteUp(tid_t tid, struct 
 	pxdlock->index = 1;
 
 	/* update sibling pointers */
-	if ((rc = dtRelink(tid, ip, fp)))
+	if ((rc = dtRelink(tid, ip, fp))) {
+		BT_PUTPAGE(fmp);
 		return rc;
+	}
 
 	xlen = lengthPXD(&fp->header.self);
 	ip->i_blocks -= LBLK2PBLK(ip->i_sb, xlen);
@@ -2307,8 +2311,10 @@ static int dtDeleteUp(tid_t tid, struct 
 				pxdlock->index = 1;
 
 				/* update sibling pointers */
-				if ((rc = dtRelink(tid, ip, p)))
+				if ((rc = dtRelink(tid, ip, p))) {
+					DT_PUTPAGE(mp);
 					return rc;
+				}
 
 				xlen = lengthPXD(&p->header.self);
 				ip->i_blocks -= LBLK2PBLK(ip->i_sb, xlen);
@@ -2621,8 +2627,10 @@ static int dtSearchNode(struct inode *ip
 		/*
 		 * descend down to leftmost child page
 		 */
-		if (p->header.flag & BT_LEAF)
+		if (p->header.flag & BT_LEAF) {
+			DT_PUTPAGE(mp);
 			return -ESTALE;
+		}
 
 		/* get the leftmost entry */
 		stbl = DT_GETSTBL(p);
diff -purN linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_imap.c linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_imap.c
--- linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_imap.c	2004-02-26 14:51:20.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_imap.c	2004-03-24 20:11:46.000000000 +0000
@@ -1546,6 +1546,7 @@ int diAlloc(struct inode *pip, boolean_t
 						 0);
 				if (rem >= INOSPEREXT) {
 					IREAD_UNLOCK(ipimap);
+					release_metapage(mp);
 					AG_UNLOCK(imap, agno);
 					jfs_error(ip->i_sb,
 						  "diAlloc: can't find free bit "
@@ -1840,6 +1841,7 @@ static int diAllocIno(struct inomap * im
 	 */
 	if (!iagp->nfreeinos) {
 		IREAD_UNLOCK(imap->im_ipimap);
+		release_metapage(mp);
 		jfs_error(ip->i_sb,
 			  "diAllocIno: nfreeinos = 0, but iag on freelist");
 		return -EIO;
@@ -1851,6 +1853,7 @@ static int diAllocIno(struct inomap * im
 	for (sword = 0;; sword++) {
 		if (sword >= SMAPSZ) {
 			IREAD_UNLOCK(imap->im_ipimap);
+			release_metapage(mp);
 			jfs_error(ip->i_sb,
 				  "diAllocIno: free inode not found in summary map");
 			return -EIO;
@@ -1866,6 +1869,7 @@ static int diAllocIno(struct inomap * im
 	rem = diFindFree(le32_to_cpu(iagp->inosmap[sword]), 0);
 	if (rem >= EXTSPERSUM) {
 		IREAD_UNLOCK(imap->im_ipimap);
+		release_metapage(mp);
 		jfs_error(ip->i_sb, "diAllocIno: no free extent found");
 		return -EIO;
 	}
@@ -1876,6 +1880,7 @@ static int diAllocIno(struct inomap * im
 	rem = diFindFree(le32_to_cpu(iagp->wmap[extno]), 0);
 	if (rem >= INOSPEREXT) {
 		IREAD_UNLOCK(imap->im_ipimap);
+		release_metapage(mp);
 		jfs_error(ip->i_sb, "diAllocIno: free inode not found");
 		return -EIO;
 	}
@@ -2839,12 +2844,14 @@ diUpdatePMap(struct inode *ipimap,
 		 * and should be free in persistent map;
 		 */
 		if (!(le32_to_cpu(iagp->wmap[extno]) & mask)) {
+			release_metapage(mp);
 			jfs_error(ipimap->i_sb,
 				  "diUpdatePMap: the inode is not allocated in "
 				  "the working map");
 			return -EIO;
 		}
 		if ((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) {
+			release_metapage(mp);
 			jfs_error(ipimap->i_sb,
 				  "diUpdatePMap: the inode is not free in the "
 				  "persistent map");
diff -purN linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_logmgr.c linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_logmgr.c
--- linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_logmgr.c	2004-03-16 20:02:36.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_logmgr.c	2004-03-24 20:17:37.000000000 +0000
@@ -979,7 +979,6 @@ static int lmLogSync(struct jfs_log * lo
 		 * We need to make sure all of the "written" metapages
 		 * actually make it to disk
 		 */
-		down(&jfs_log_sem);
 		list_for_each_entry(sbi, &log->sb_list, log_list) {
 			filemap_fdatawrite(sbi->ipbmap->i_mapping);
 			filemap_fdatawrite(sbi->ipimap->i_mapping);
@@ -990,7 +989,6 @@ static int lmLogSync(struct jfs_log * lo
 			filemap_fdatawait(sbi->ipimap->i_mapping);
 			filemap_fdatawait(sbi->sb->s_bdev->bd_inode->i_mapping);
 		}
-		up(&jfs_log_sem);
 
 		lrd.logtid = 0;
 		lrd.backchain = 0;
@@ -1151,8 +1149,10 @@ int lmLogOpen(struct super_block *sb)
 		goto shutdown;
 
 journal_found:
+	LOG_LOCK(log);
 	list_add(&sbi->log_list, &log->sb_list);
 	sbi->log = log;
+	LOG_UNLOCK(log);
 
 	up(&jfs_log_sem);
 	return 0;
@@ -1237,8 +1237,10 @@ static int open_dummy_log(struct super_b
 		}
 	}
 
+	LOG_LOCK(dummy_log);
 	list_add(&JFS_SBI(sb)->log_list, &dummy_log->sb_list);
 	JFS_SBI(sb)->log = dummy_log;
+	LOG_UNLOCK(dummy_log);
 	up(&jfs_log_sem);
 
 	return 0;
@@ -1469,7 +1471,9 @@ int lmLogClose(struct super_block *sb)
 	jfs_info("lmLogClose: log:0x%p", log);
 
 	down(&jfs_log_sem);
+	LOG_LOCK(log);
 	list_del(&sbi->log_list);
+	LOG_UNLOCK(log);
 	sbi->log = NULL;
 
 	/*
diff -purN linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_txnmgr.c linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_txnmgr.c
--- linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_txnmgr.c	2004-03-08 21:55:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_txnmgr.c	2004-03-24 20:11:46.000000000 +0000
@@ -1356,9 +1356,6 @@ static int txLog(struct jfs_log * log, s
 		lrd->log.redopage.fileset = cpu_to_le32(JFS_IP(ip)->fileset);
 		lrd->log.redopage.inode = cpu_to_le32(ip->i_ino);
 
-		if (tlck->mp)
-			hold_metapage(tlck->mp, 0);
-
 		/* write log record of page from the tlock */
 		switch (tlck->type & tlckTYPE) {
 		case tlckXTREE:
@@ -1384,8 +1381,6 @@ static int txLog(struct jfs_log * log, s
 		default:
 			jfs_err("UFO tlock:0x%p", tlck);
 		}
-		if (tlck->mp)
-			release_metapage(tlck->mp);
 	}
 
 	return rc;
@@ -1535,6 +1530,7 @@ static int dataLog(struct jfs_log * log,
 		 * the last entry, so don't bother logging this
 		 */
 		mp->lid = 0;
+		hold_metapage(mp, 0);
 		atomic_dec(&mp->nohomeok);
 		discard_metapage(mp);
 		tlck->mp = 0;
diff -purN linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_xtree.c linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_xtree.c
--- linux-post-2.6.5-rc2-20040323/fs/jfs/jfs_xtree.c	2004-03-08 21:55:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/jfs/jfs_xtree.c	2004-03-24 20:11:46.000000000 +0000
@@ -1032,11 +1032,11 @@ xtSplitUp(tid_t tid,
 	rc = (sp->header.flag & BT_ROOT) ?
 	    xtSplitRoot(tid, ip, split, &rmp) :
 	    xtSplitPage(tid, ip, split, &rmp, &rbn);
-	if (rc)
-		return -EIO;
 
 	XT_PUTPAGE(smp);
 
+	if (rc)
+		return -EIO;
 	/*
 	 * propagate up the router entry for the leaf page just split
 	 *
@@ -1611,14 +1611,16 @@ int xtExtend(tid_t tid,		/* transaction 
 	/* there must exist extent to be extended */
 	if ((rc = xtSearch(ip, xoff - 1, &cmp, &btstack, XT_INSERT)))
 		return rc;
+
+	/* retrieve search result */
+	XT_GETSEARCH(ip, btstack.top, bn, mp, p, index);
+
 	if (cmp != 0) {
+		XT_PUTPAGE(mp);
 		jfs_error(ip->i_sb, "xtExtend: xtSearch did not find extent");
 		return -EIO;
 	}
 
-	/* retrieve search result */
-	XT_GETSEARCH(ip, btstack.top, bn, mp, p, index);
-
 	/* extension must be contiguous */
 	xad = &p->xad[index];
 	if ((offsetXAD(xad) + lengthXAD(xad)) != xoff) {
@@ -1677,25 +1679,27 @@ int xtExtend(tid_t tid,		/* transaction 
 		 * resides on the new child page;
 		 */
 		if (rootsplit) {
-			if (p->header.nextindex ==
-			    cpu_to_le16(XTENTRYSTART + 1)) {
-				xad = &p->xad[XTENTRYSTART];
-				bn = addressXAD(xad);
-
-				/* get new child page */
-				XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
-
-				BT_MARK_DIRTY(mp, ip);
-				if (!test_cflag(COMMIT_Nolink, ip)) {
-					tlck = txLock(tid, ip, mp,
-						      tlckXTREE |
-						      tlckGROW);
-					xtlck = (struct xtlock *) & tlck->lock;
-				}
+			ASSERT(p->header.nextindex ==
+			       cpu_to_le16(XTENTRYSTART + 1));
+			xad = &p->xad[XTENTRYSTART];
+			bn = addressXAD(xad);
+
+			/* get new child page */
+			XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
+			if (rc)
+				return rc;
+
+			BT_MARK_DIRTY(mp, ip);
+			if (!test_cflag(COMMIT_Nolink, ip)) {
+				tlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);
+				xtlck = (struct xtlock *) & tlck->lock;
 			}
-		} else
+		} else {
 			/* get back old page */
 			XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
+			if (rc)
+				return rc;
+		}
 	}
 	/*
 	 *      insert the new entry into the leaf page
@@ -1778,14 +1782,16 @@ printf("xtTailgate: nxoff:0x%lx nxlen:0x
 	/* there must exist extent to be tailgated */
 	if ((rc = xtSearch(ip, xoff, &cmp, &btstack, XT_INSERT)))
 		return rc;
+
+	/* retrieve search result */
+	XT_GETSEARCH(ip, btstack.top, bn, mp, p, index);
+
 	if (cmp != 0) {
+		XT_PUTPAGE(mp);
 		jfs_error(ip->i_sb, "xtTailgate: couldn't find extent");
 		return -EIO;
 	}
 
-	/* retrieve search result */
-	XT_GETSEARCH(ip, btstack.top, bn, mp, p, index);
-
 	/* entry found must be last entry */
 	nextindex = le16_to_cpu(p->header.nextindex);
 	if (index != nextindex - 1) {
@@ -1843,25 +1849,27 @@ printf("xtTailgate: xoff:0x%lx xlen:0x%x
 		 * resides on the new child page;
 		 */
 		if (rootsplit) {
-			if (p->header.nextindex ==
-			    cpu_to_le16(XTENTRYSTART + 1)) {
-				xad = &p->xad[XTENTRYSTART];
-				bn = addressXAD(xad);
-
-				/* get new child page */
-				XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
-
-				BT_MARK_DIRTY(mp, ip);
-				if (!test_cflag(COMMIT_Nolink, ip)) {
-					tlck = txLock(tid, ip, mp,
-						      tlckXTREE |
-						      tlckGROW);
-					xtlck = (struct xtlock *) & tlck->lock;
-				}
+			ASSERT(p->header.nextindex ==
+			       cpu_to_le16(XTENTRYSTART + 1));
+			xad = &p->xad[XTENTRYSTART];
+			bn = addressXAD(xad);
+
+			/* get new child page */
+			XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
+			if (rc)
+				return rc;
+
+			BT_MARK_DIRTY(mp, ip);
+			if (!test_cflag(COMMIT_Nolink, ip)) {
+				tlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);
+				xtlck = (struct xtlock *) & tlck->lock;
 			}
-		} else
+		} else {
 			/* get back old page */
 			XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
+			if (rc)
+				return rc;
+		}
 	}
 	/*
 	 *      insert the new entry into the leaf page
@@ -1960,14 +1968,15 @@ int xtUpdate(tid_t tid, struct inode *ip
 	if ((rc = xtSearch(ip, nxoff, &cmp, &btstack, XT_INSERT)))
 		return rc;
 
+	/* retrieve search result */
+	XT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);
+
 	if (cmp != 0) {
+		XT_PUTPAGE(mp);
 		jfs_error(ip->i_sb, "xtUpdate: Could not find extent");
 		return -EIO;
 	}
 
-	/* retrieve search result */
-	XT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);
-
 	BT_MARK_DIRTY(mp, ip);
 	/*
 	 * acquire tlock of the leaf page containing original entry
@@ -2175,25 +2184,26 @@ int xtUpdate(tid_t tid, struct inode *ip
 		 * resides on the new child page;
 		 */
 		if (rootsplit) {
-			if (p->header.nextindex ==
-			    cpu_to_le16(XTENTRYSTART + 1)) {
-				xad = &p->xad[XTENTRYSTART];
-				bn = addressXAD(xad);
-
-				/* get new child page */
-				XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
-
-				BT_MARK_DIRTY(mp, ip);
-				if (!test_cflag(COMMIT_Nolink, ip)) {
-					tlck = txLock(tid, ip, mp,
-						      tlckXTREE |
-						      tlckGROW);
-					xtlck = (struct xtlock *) & tlck->lock;
-				}
+			ASSERT(p->header.nextindex ==
+			       cpu_to_le16(XTENTRYSTART + 1));
+			xad = &p->xad[XTENTRYSTART];
+			bn = addressXAD(xad);
+
+			/* get new child page */
+			XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
+			if (rc)
+				return rc;
+
+			BT_MARK_DIRTY(mp, ip);
+			if (!test_cflag(COMMIT_Nolink, ip)) {
+				tlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);
+				xtlck = (struct xtlock *) & tlck->lock;
 			}
 		} else {
 			/* get back old page */
 			XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
+			if (rc)
+				return rc;
 
 			/* is nXAD on new page ? */
 			if (newindex >
@@ -2247,6 +2257,8 @@ int xtUpdate(tid_t tid, struct inode *ip
 
 		/* get new right page */
 		XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
+		if (rc)
+			return rc;
 
 		BT_MARK_DIRTY(mp, ip);
 		if (!test_cflag(COMMIT_Nolink, ip)) {
@@ -2270,13 +2282,16 @@ int xtUpdate(tid_t tid, struct inode *ip
 
 		if ((rc = xtSearch(ip, nxoff, &cmp, &btstack, XT_INSERT)))
 			return rc;
+
+		/* retrieve search result */
+		XT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);
+
 		if (cmp != 0) {
+			XT_PUTPAGE(mp);
 			jfs_error(ip->i_sb, "xtUpdate: xtSearch failed");
 			return -EIO;
 		}
 
-		/* retrieve search result */
-		XT_GETSEARCH(ip, btstack.top, bn, mp, p, index0);
 		if (index0 != index) {
 			XT_PUTPAGE(mp);
 			jfs_error(ip->i_sb,
@@ -2325,25 +2340,27 @@ printf("xtUpdate.updateLeft.split p:0x%p
 		 * resides on the new child page;
 		 */
 		if (rootsplit) {
-			if (p->header.nextindex ==
-			    cpu_to_le16(XTENTRYSTART + 1)) {
-				xad = &p->xad[XTENTRYSTART];
-				bn = addressXAD(xad);
-
-				/* get new child page */
-				XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
-
-				BT_MARK_DIRTY(mp, ip);
-				if (!test_cflag(COMMIT_Nolink, ip)) {
-					tlck = txLock(tid, ip, mp,
-						      tlckXTREE |
-						      tlckGROW);
-					xtlck = (struct xtlock *) & tlck->lock;
-				}
+			ASSERT(p->header.nextindex ==
+			       cpu_to_le16(XTENTRYSTART + 1));
+			xad = &p->xad[XTENTRYSTART];
+			bn = addressXAD(xad);
+
+			/* get new child page */
+			XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
+			if (rc)
+				return rc;
+
+			BT_MARK_DIRTY(mp, ip);
+			if (!test_cflag(COMMIT_Nolink, ip)) {
+				tlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);
+				xtlck = (struct xtlock *) & tlck->lock;
 			}
-		} else
+		} else {
 			/* get back old page */
 			XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
+			if (rc)
+				return rc;
+		}
 	} else {
 		/* if insert into middle, shift right remaining entries */
 		if (newindex < nextindex)
@@ -2660,8 +2677,10 @@ xtDeleteUp(tid_t tid, struct inode *ip,
 	/*
 	 * free non-root leaf page
 	 */
-	if ((rc = xtRelink(tid, ip, fp)))
+	if ((rc = xtRelink(tid, ip, fp))) {
+		XT_PUTPAGE(fmp);
 		return rc;
+	}
 
 	xaddr = addressPXD(&fp->header.self);
 	xlen = lengthPXD(&fp->header.self);
@@ -2703,7 +2722,7 @@ xtDeleteUp(tid_t tid, struct inode *ip,
 				p->header.nextindex =
 				    cpu_to_le16(XTENTRYSTART);
 
-				/* XT_PUTPAGE(fmp); */
+				/* XT_PUTPAGE(mp); */
 
 				break;
 			} else {
@@ -2717,7 +2736,7 @@ xtDeleteUp(tid_t tid, struct inode *ip,
 				       (s64) JFS_SBI(ip->i_sb)->nbperpage);
 
 				/* unpin/free the buffer page */
-				discard_metapage(fmp);
+				discard_metapage(mp);
 
 				/* propagate up */
 				continue;
@@ -2826,14 +2845,15 @@ xtRelocate(tid_t tid, struct inode * ip,
 		rc = xtSearch(ip, xoff, &cmp, &btstack, 0);
 		if (rc)
 			return rc;
+
+		/* retrieve search result */
+		XT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);
+
 		if (cmp) {
 			XT_PUTPAGE(pmp);
 			return -ESTALE;
 		}
 
-		/* retrieve search result */
-		XT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);
-
 		/* validate for exact match with a single entry */
 		xad = &pp->xad[index];
 		if (addressXAD(xad) != oxaddr || lengthXAD(xad) != xlen) {
@@ -2846,14 +2866,15 @@ xtRelocate(tid_t tid, struct inode * ip,
 		rc = xtSearchNode(ip, oxad, &cmp, &btstack, 0);
 		if (rc)
 			return rc;
+
+		/* retrieve search result */
+		XT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);
+
 		if (cmp) {
 			XT_PUTPAGE(pmp);
 			return -ESTALE;
 		}
 
-		/* retrieve search result */
-		XT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);
-
 		/* xtSearchNode() validated for exact match with a single entry
 		 */
 		xad = &pp->xad[index];
@@ -2927,7 +2948,9 @@ xtRelocate(tid_t tid, struct inode * ip,
 		}
 
 		/* get back parent page */
-		rc = xtSearch(ip, xoff, &cmp, &btstack, 0);
+		if ((rc = xtSearch(ip, xoff, &cmp, &btstack, 0)))
+			return rc;
+
 		XT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);
 		jfs_info("xtRelocate: target data extent relocated.");
 	} else {		/* (xtype  == XTPAGE) */
@@ -3150,8 +3173,10 @@ static int xtSearchNode(struct inode *ip
 		XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
 		if (rc)
 			return rc;
-		if (p->header.flag & BT_LEAF)
+		if (p->header.flag & BT_LEAF) {
+			XT_PUTPAGE(mp);
 			return -ESTALE;
+		}
 
 		lim = le16_to_cpu(p->header.nextindex) - XTENTRYSTART;
 
@@ -3949,12 +3974,15 @@ s64 xtTruncate_pmap(tid_t tid, struct in
 		rc = xtSearch(ip, xoff, &cmp, &btstack, 0);
 		if (rc)
 			return rc;
+
+		XT_GETSEARCH(ip, btstack.top, bn, mp, p, index);
+
 		if (cmp != 0) {
+			XT_PUTPAGE(mp);
 			jfs_error(ip->i_sb,
 				  "xtTruncate_pmap: did not find extent");
 			return -EIO;
 		}
-		XT_GETSEARCH(ip, btstack.top, bn, mp, p, index);
 	} else {
 		/*
 		 * start with root
@@ -4202,17 +4230,10 @@ int xtDisplayTree(struct inode *ip)
 int xtDisplayPage(struct inode *ip, s64 bn, xtpage_t * p)
 {
 	int rc = 0;
-	struct metapage *mp;
 	xad_t *xad;
 	s64 xaddr, xoff;
 	int xlen, i, j;
 
-	if (p == NULL) {
-		XT_GETPAGE(ip, bn, mp, PSIZE, p, rc);
-		if (rc)
-			return rc;
-	}
-
 	/* display page control */
 	printf("bn:0x%lx flag:0x%x nextindex:%d\n",
 	       (ulong) bn, p->header.flag,
diff -purN linux-post-2.6.5-rc2-20040323/fs/proc/proc_misc.c linux-post-2.6.5-rc2-20040326/fs/proc/proc_misc.c
--- linux-post-2.6.5-rc2-20040323/fs/proc/proc_misc.c	2004-03-14 01:57:41.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/proc/proc_misc.c	2004-03-23 10:05:27.000000000 +0000
@@ -391,24 +391,24 @@ int show_stat(struct seq_file *p, void *
 		(unsigned long long)jiffies_64_to_clock_t(irq),
 		(unsigned long long)jiffies_64_to_clock_t(softirq));
 	for_each_cpu(i) {
-		/* two separate calls here to work around gcc-2.95.3 ICE */
-		seq_printf(p, "cpu%d %llu %llu %llu ",
+
+		/* Copy values here to work around gcc-2.95.3, gcc-2.96 */
+		user = kstat_cpu(i).cpustat.user;
+		nice = kstat_cpu(i).cpustat.nice;
+		system = kstat_cpu(i).cpustat.system;
+		idle = kstat_cpu(i).cpustat.idle;
+		iowait = kstat_cpu(i).cpustat.iowait;
+		irq = kstat_cpu(i).cpustat.irq;
+		softirq = kstat_cpu(i).cpustat.softirq;
+		seq_printf(p, "cpu%d %llu %llu %llu %llu %llu %llu %llu\n",
 			i,
-			(unsigned long long)
-			  jiffies_64_to_clock_t(kstat_cpu(i).cpustat.user),
-			(unsigned long long)
-			  jiffies_64_to_clock_t(kstat_cpu(i).cpustat.nice),
-			(unsigned long long)
-			  jiffies_64_to_clock_t(kstat_cpu(i).cpustat.system));
-		seq_printf(p, "%llu %llu %llu %llu\n",
-			(unsigned long long)
-			  jiffies_64_to_clock_t(kstat_cpu(i).cpustat.idle),
-			(unsigned long long)
-			  jiffies_64_to_clock_t(kstat_cpu(i).cpustat.iowait),
-			(unsigned long long)
-			  jiffies_64_to_clock_t(kstat_cpu(i).cpustat.irq),
-			(unsigned long long)
-			  jiffies_64_to_clock_t(kstat_cpu(i).cpustat.softirq));
+			(unsigned long long)jiffies_64_to_clock_t(user),
+			(unsigned long long)jiffies_64_to_clock_t(nice),
+			(unsigned long long)jiffies_64_to_clock_t(system),
+			(unsigned long long)jiffies_64_to_clock_t(idle),
+			(unsigned long long)jiffies_64_to_clock_t(iowait),
+			(unsigned long long)jiffies_64_to_clock_t(irq),
+			(unsigned long long)jiffies_64_to_clock_t(softirq));
 	}
 	seq_printf(p, "intr %llu", (unsigned long long)sum);
 
diff -purN linux-post-2.6.5-rc2-20040323/fs/super.c linux-post-2.6.5-rc2-20040326/fs/super.c
--- linux-post-2.6.5-rc2-20040323/fs/super.c	2004-03-12 09:30:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/fs/super.c	2004-03-25 08:39:55.000000000 +0000
@@ -636,7 +636,7 @@ struct super_block *get_sb_bdev(struct f
 		char b[BDEVNAME_SIZE];
 
 		s->s_flags = flags;
-		strncpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
+		strlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));
 		s->s_old_blocksize = block_size(bdev);
 		sb_set_blocksize(s, s->s_old_blocksize);
 		error = fill_super(s, data, flags & MS_VERBOSE ? 1 : 0);
diff -purN linux-post-2.6.5-rc2-20040323/include/acpi/acpi_bus.h linux-post-2.6.5-rc2-20040326/include/acpi/acpi_bus.h
--- linux-post-2.6.5-rc2-20040323/include/acpi/acpi_bus.h	2003-09-02 18:07:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/acpi/acpi_bus.h	2004-03-21 05:18:40.000000000 +0000
@@ -32,8 +32,6 @@
 
 #define PREFIX			"ACPI: "
 
-extern int			acpi_disabled;
-
 /* TBD: Make dynamic */
 #define ACPI_MAX_HANDLES	10
 struct acpi_handle_list {
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-generic/dma-mapping.h linux-post-2.6.5-rc2-20040326/include/asm-generic/dma-mapping.h
--- linux-post-2.6.5-rc2-20040323/include/asm-generic/dma-mapping.h	2004-03-19 05:59:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-generic/dma-mapping.h	2004-03-23 18:12:38.000000000 +0000
@@ -141,9 +141,9 @@ dma_sync_sg_for_device(struct device *de
 }
 
 static inline int
-dma_error(dma_addr_t dma_addr)
+dma_mapping_error(dma_addr_t dma_addr)
 {
-	return pci_dma_error(dma_addr);
+	return pci_dma_mapping_error(dma_addr);
 }
 
 /* Now for the API extensions over the pci_ one */
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-generic/pci-dma-compat.h linux-post-2.6.5-rc2-20040326/include/asm-generic/pci-dma-compat.h
--- linux-post-2.6.5-rc2-20040323/include/asm-generic/pci-dma-compat.h	2004-03-19 05:59:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-generic/pci-dma-compat.h	2004-03-23 18:12:38.000000000 +0000
@@ -99,9 +99,9 @@ pci_dma_sync_sg_for_device(struct pci_de
 }
 
 static inline int
-pci_dma_error(dma_addr_t dma_addr)
+pci_dma_mapping_error(dma_addr_t dma_addr)
 {
-	return dma_error(dma_addr);
+	return dma_mapping_error(dma_addr);
 }
 
 #endif
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-i386/acpi.h linux-post-2.6.5-rc2-20040326/include/asm-i386/acpi.h
--- linux-post-2.6.5-rc2-20040323/include/asm-i386/acpi.h	2004-03-11 04:39:40.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-i386/acpi.h	2004-03-18 19:45:38.000000000 +0000
@@ -116,13 +116,17 @@ extern int acpi_lapic;
 extern int acpi_ioapic;
 extern int acpi_noirq;
 extern int acpi_strict;
+extern int acpi_disabled;
+extern int acpi_ht;
+static inline void disable_acpi(void) { acpi_disabled = 1; acpi_ht = 0; }
 
 /* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
 #define FIX_ACPI_PAGES 4
 
+extern int acpi_gsi_to_irq(u32 gsi, unsigned int *irq);
 #ifdef CONFIG_X86_IO_APIC
 extern int skip_ioapic_setup;
-extern int acpi_irq_to_vector(u32 irq);
+extern int acpi_irq_to_vector(u32 irq);	/* deprecated in favor of acpi_gsi_to_irq */
 
 static inline void disable_ioapic_setup(void)
 {
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-i386/dma-mapping.h linux-post-2.6.5-rc2-20040326/include/asm-i386/dma-mapping.h
--- linux-post-2.6.5-rc2-20040323/include/asm-i386/dma-mapping.h	2004-03-19 05:59:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-i386/dma-mapping.h	2004-03-23 18:12:38.000000000 +0000
@@ -111,7 +111,7 @@ dma_sync_sg_for_device(struct device *de
 }
 
 static inline int
-dma_error(dma_addr_t dma_addr)
+dma_mapping_error(dma_addr_t dma_addr)
 {
 	return 0;
 }
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-i386/mpspec.h linux-post-2.6.5-rc2-20040326/include/asm-i386/mpspec.h
--- linux-post-2.6.5-rc2-20040323/include/asm-i386/mpspec.h	2003-12-30 08:41:12.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-i386/mpspec.h	2004-03-22 21:00:03.000000000 +0000
@@ -30,17 +30,10 @@ extern int using_apic_timer;
 #ifdef CONFIG_ACPI_BOOT
 extern void mp_register_lapic (u8 id, u8 enabled);
 extern void mp_register_lapic_address (u64 address);
-extern void mp_register_ioapic (u8 id, u32 address, u32 irq_base);
-extern void mp_override_legacy_irq (u8 bus_irq, u8 polarity, u8 trigger, u32 global_irq);
+extern void mp_register_ioapic (u8 id, u32 address, u32 gsi_base);
+extern void mp_override_legacy_irq (u8 bus_irq, u8 polarity, u8 trigger, u32 gsi);
 extern void mp_config_acpi_legacy_irqs (void);
 extern void mp_parse_prt (void);
-
-#ifdef CONFIG_X86_IO_APIC
-extern void mp_config_ioapic_for_sci(int irq);
-#else
-static inline void mp_config_ioapic_for_sci(int irq)
-{ }
-#endif
 #endif /*CONFIG_ACPI_BOOT*/
 
 #define PHYSID_ARRAY_SIZE	BITS_TO_LONGS(MAX_APICS)
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ia64/acpi.h linux-post-2.6.5-rc2-20040326/include/asm-ia64/acpi.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ia64/acpi.h	2004-03-12 12:32:41.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ia64/acpi.h	2004-03-21 05:28:40.000000000 +0000
@@ -88,7 +88,9 @@ ia64_acpi_release_global_lock (unsigned 
 #define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq)				\
 	((Acq) = ia64_acpi_release_global_lock((unsigned int *) GLptr))
 
+#define acpi_disabled 0	/* ACPI always enabled on IA64 */
 #define acpi_strict 1	/* no ACPI spec workarounds on IA64 */
+static inline void disable_acpi(void) { }
 
 const char *acpi_get_sysname (void);
 int acpi_request_vector (u32 int_type);
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ia64/dma-mapping.h linux-post-2.6.5-rc2-20040326/include/asm-ia64/dma-mapping.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ia64/dma-mapping.h	2004-03-14 06:54:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ia64/dma-mapping.h	2004-03-24 00:28:49.000000000 +0000
@@ -2,7 +2,7 @@
 #define _ASM_IA64_DMA_MAPPING_H
 
 /*
- * Copyright (C) 2003 Hewlett-Packard Co
+ * Copyright (C) 2003-2004 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
@@ -18,6 +18,7 @@
 #define dma_sync_sg_for_cpu	platform_dma_sync_sg_for_cpu
 #define dma_sync_single_for_device platform_dma_sync_single_for_device
 #define dma_sync_sg_for_device	platform_dma_sync_sg_for_device
+#define dma_mapping_error	platform_dma_mapping_error
 
 #define dma_map_page(dev, pg, off, size, dir)				\
 	dma_map_single(dev, page_address(pg) + (off), (size), (dir))
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ia64/machvec.h linux-post-2.6.5-rc2-20040326/include/asm-ia64/machvec.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ia64/machvec.h	2004-03-15 15:53:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ia64/machvec.h	2004-03-25 19:54:44.000000000 +0000
@@ -4,7 +4,7 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) Srinivasa Thirumalachar <sprasad@engr.sgi.com>
  * Copyright (C) Vijay Chander <vijay@engr.sgi.com>
- * Copyright (C) 1999-2001, 2003 Hewlett-Packard Co.
+ * Copyright (C) 1999-2001, 2003-2004 Hewlett-Packard Co.
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 #ifndef _ASM_IA64_MACHVEC_H
@@ -21,12 +21,8 @@ struct irq_desc;
 struct page;
 
 typedef void ia64_mv_setup_t (char **);
-typedef void ia64_mv_cpu_init_t(void);
+typedef void ia64_mv_cpu_init_t (void);
 typedef void ia64_mv_irq_init_t (void);
-typedef void ia64_mv_mca_init_t (void);
-typedef void ia64_mv_mca_handler_t (void);
-typedef void ia64_mv_cmci_handler_t (int, void *, struct pt_regs *);
-typedef void ia64_mv_log_print_t (void);
 typedef void ia64_mv_send_ipi_t (int, int, int, int);
 typedef void ia64_mv_timer_interrupt_t (int, void *, struct pt_regs *);
 typedef void ia64_mv_global_tlb_purge_t (unsigned long, unsigned long, unsigned long);
@@ -46,6 +42,7 @@ typedef void ia64_mv_dma_sync_single_for
 typedef void ia64_mv_dma_sync_sg_for_cpu (struct device *, struct scatterlist *, int, int);
 typedef void ia64_mv_dma_sync_single_for_device (struct device *, dma_addr_t, size_t, int);
 typedef void ia64_mv_dma_sync_sg_for_device (struct device *, struct scatterlist *, int, int);
+typedef int ia64_mv_dma_mapping_error (dma_addr_t dma_addr);
 typedef int ia64_mv_dma_supported (struct device *, u64);
 
 /*
@@ -73,7 +70,10 @@ typedef unsigned int ia64_mv_readl_relax
 typedef unsigned long ia64_mv_readq_relaxed_t (void *);
 
 extern void machvec_noop (void);
-extern void machvec_memory_fence (void);
+extern void machvec_setup (char **);
+extern void machvec_timer_interrupt (int, void *, struct pt_regs *);
+extern void machvec_dma_sync_single (struct device *, dma_addr_t, size_t, int);
+extern void machvec_dma_sync_sg (struct device *, struct scatterlist *, int, int);
 
 # if defined (CONFIG_IA64_HP_SIM)
 #  include <asm/machvec_hpsim.h>
@@ -92,10 +92,6 @@ extern void machvec_memory_fence (void);
 #  define platform_setup	ia64_mv.setup
 #  define platform_cpu_init	ia64_mv.cpu_init
 #  define platform_irq_init	ia64_mv.irq_init
-#  define platform_mca_init	ia64_mv.mca_init
-#  define platform_mca_handler	ia64_mv.mca_handler
-#  define platform_cmci_handler	ia64_mv.cmci_handler
-#  define platform_log_print	ia64_mv.log_print
 #  define platform_send_ipi	ia64_mv.send_ipi
 #  define platform_timer_interrupt	ia64_mv.timer_interrupt
 #  define platform_global_tlb_purge	ia64_mv.global_tlb_purge
@@ -110,6 +106,7 @@ extern void machvec_memory_fence (void);
 #  define platform_dma_sync_sg_for_cpu	ia64_mv.dma_sync_sg_for_cpu
 #  define platform_dma_sync_single_for_device ia64_mv.dma_sync_single_for_device
 #  define platform_dma_sync_sg_for_device ia64_mv.dma_sync_sg_for_device
+#  define platform_dma_mapping_error		ia64_mv.dma_mapping_error
 #  define platform_dma_supported	ia64_mv.dma_supported
 #  define platform_irq_desc		ia64_mv.irq_desc
 #  define platform_irq_to_vector	ia64_mv.irq_to_vector
@@ -140,10 +137,6 @@ struct ia64_machine_vector {
 	ia64_mv_setup_t *setup;
 	ia64_mv_cpu_init_t *cpu_init;
 	ia64_mv_irq_init_t *irq_init;
-	ia64_mv_mca_init_t *mca_init;
-	ia64_mv_mca_handler_t *mca_handler;
-	ia64_mv_cmci_handler_t *cmci_handler;
-	ia64_mv_log_print_t *log_print;
 	ia64_mv_send_ipi_t *send_ipi;
 	ia64_mv_timer_interrupt_t *timer_interrupt;
 	ia64_mv_global_tlb_purge_t *global_tlb_purge;
@@ -158,6 +151,7 @@ struct ia64_machine_vector {
 	ia64_mv_dma_sync_sg_for_cpu *dma_sync_sg_for_cpu;
 	ia64_mv_dma_sync_single_for_device *dma_sync_single_for_device;
 	ia64_mv_dma_sync_sg_for_device *dma_sync_sg_for_device;
+	ia64_mv_dma_mapping_error *dma_mapping_error;
 	ia64_mv_dma_supported *dma_supported;
 	ia64_mv_irq_desc *irq_desc;
 	ia64_mv_irq_to_vector *irq_to_vector;
@@ -184,10 +178,6 @@ struct ia64_machine_vector {
 	platform_setup,				\
 	platform_cpu_init,			\
 	platform_irq_init,			\
-	platform_mca_init,			\
-	platform_mca_handler,			\
-	platform_cmci_handler,			\
-	platform_log_print,			\
 	platform_send_ipi,			\
 	platform_timer_interrupt,		\
 	platform_global_tlb_purge,		\
@@ -202,6 +192,7 @@ struct ia64_machine_vector {
 	platform_dma_sync_sg_for_cpu,		\
 	platform_dma_sync_single_for_device,	\
 	platform_dma_sync_sg_for_device,	\
+	platform_dma_mapping_error,			\
 	platform_dma_supported,			\
 	platform_irq_desc,			\
 	platform_irq_to_vector,			\
@@ -243,6 +234,7 @@ extern ia64_mv_dma_sync_single_for_cpu	s
 extern ia64_mv_dma_sync_sg_for_cpu	swiotlb_sync_sg_for_cpu;
 extern ia64_mv_dma_sync_single_for_device swiotlb_sync_single_for_device;
 extern ia64_mv_dma_sync_sg_for_device	swiotlb_sync_sg_for_device;
+extern ia64_mv_dma_mapping_error	swiotlb_dma_mapping_error;
 extern ia64_mv_dma_supported		swiotlb_dma_supported;
 
 /*
@@ -250,31 +242,20 @@ extern ia64_mv_dma_supported		swiotlb_dm
  * to update the machvec files for all existing platforms.
  */
 #ifndef platform_setup
-# define platform_setup		((ia64_mv_setup_t *) machvec_noop)
+# define platform_setup			machvec_setup
 #endif
 #ifndef platform_cpu_init
-# define platform_cpu_init	((ia64_mv_cpu_init_t *) machvec_noop)
+# define platform_cpu_init		machvec_noop
 #endif
 #ifndef platform_irq_init
-# define platform_irq_init	((ia64_mv_irq_init_t *) machvec_noop)
-#endif
-#ifndef platform_mca_init
-# define platform_mca_init	((ia64_mv_mca_init_t *) machvec_noop)
-#endif
-#ifndef platform_mca_handler
-# define platform_mca_handler	((ia64_mv_mca_handler_t *) machvec_noop)
-#endif
-#ifndef platform_cmci_handler
-# define platform_cmci_handler	((ia64_mv_cmci_handler_t *) machvec_noop)
-#endif
-#ifndef platform_log_print
-# define platform_log_print	((ia64_mv_log_print_t *) machvec_noop)
+# define platform_irq_init		machvec_noop
 #endif
+
 #ifndef platform_send_ipi
-# define platform_send_ipi	ia64_send_ipi	/* default to architected version */
+# define platform_send_ipi		ia64_send_ipi	/* default to architected version */
 #endif
 #ifndef platform_timer_interrupt
-# define platform_timer_interrupt 	((ia64_mv_timer_interrupt_t *) machvec_noop)
+# define platform_timer_interrupt 	machvec_timer_interrupt
 #endif
 #ifndef platform_global_tlb_purge
 # define platform_global_tlb_purge	ia64_global_tlb_purge /* default to architected version */
@@ -312,6 +293,9 @@ extern ia64_mv_dma_supported		swiotlb_dm
 #ifndef platform_dma_sync_sg_for_device
 # define platform_dma_sync_sg_for_device	swiotlb_sync_sg_for_device
 #endif
+#ifndef platform_dma_mapping_error
+# define platform_dma_mapping_error		swiotlb_dma_mapping_error
+#endif
 #ifndef platform_dma_supported
 # define  platform_dma_supported	swiotlb_dma_supported
 #endif
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ia64/machvec_hpzx1.h linux-post-2.6.5-rc2-20040326/include/asm-ia64/machvec_hpzx1.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ia64/machvec_hpzx1.h	2004-03-14 06:54:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ia64/machvec_hpzx1.h	2004-03-24 00:28:49.000000000 +0000
@@ -9,6 +9,7 @@ extern ia64_mv_dma_unmap_single		sba_unm
 extern ia64_mv_dma_map_sg		sba_map_sg;
 extern ia64_mv_dma_unmap_sg		sba_unmap_sg;
 extern ia64_mv_dma_supported		sba_dma_supported;
+extern ia64_mv_dma_mapping_error	sba_dma_mapping_error;
 
 /*
  * This stuff has dual use!
@@ -19,17 +20,18 @@ extern ia64_mv_dma_supported		sba_dma_su
  */
 #define platform_name			"hpzx1"
 #define platform_setup			dig_setup
-#define platform_dma_init		((ia64_mv_dma_init *) machvec_noop)
+#define platform_dma_init		machvec_noop
 #define platform_dma_alloc_coherent	sba_alloc_coherent
 #define platform_dma_free_coherent	sba_free_coherent
 #define platform_dma_map_single		sba_map_single
 #define platform_dma_unmap_single	sba_unmap_single
 #define platform_dma_map_sg		sba_map_sg
 #define platform_dma_unmap_sg		sba_unmap_sg
-#define platform_dma_sync_single_for_cpu ((ia64_mv_dma_sync_single_for_cpu *) machvec_memory_fence)
-#define platform_dma_sync_sg_for_cpu	((ia64_mv_dma_sync_sg_for_cpu *) machvec_memory_fence)
-#define platform_dma_sync_single_for_device ((ia64_mv_dma_sync_single_for_device *) machvec_memory_fence)
-#define platform_dma_sync_sg_for_device	((ia64_mv_dma_sync_sg_for_device *) machvec_memory_fence)
-#define platform_dma_supported		sba_dma_supported
+#define platform_dma_sync_single_for_cpu	machvec_dma_sync_single
+#define platform_dma_sync_sg_for_cpu		machvec_dma_sync_sg
+#define platform_dma_sync_single_for_device	machvec_dma_sync_single
+#define platform_dma_sync_sg_for_device		machvec_dma_sync_sg
+#define platform_dma_supported			sba_dma_supported
+#define platform_dma_mapping_error		sba_dma_mapping_error
 
 #endif /* _ASM_IA64_MACHVEC_HPZX1_h */
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ia64/machvec_sn2.h linux-post-2.6.5-rc2-20040326/include/asm-ia64/machvec_sn2.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ia64/machvec_sn2.h	2004-03-14 06:54:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ia64/machvec_sn2.h	2004-03-22 14:34:46.000000000 +0000
@@ -66,6 +66,7 @@ extern ia64_mv_dma_sync_single_for_cpu	s
 extern ia64_mv_dma_sync_sg_for_cpu	sn_dma_sync_sg_for_cpu;
 extern ia64_mv_dma_sync_single_for_device sn_dma_sync_single_for_device;
 extern ia64_mv_dma_sync_sg_for_device	sn_dma_sync_sg_for_device;
+extern ia64_mv_dma_mapping_error	sn_dma_mapping_error;
 extern ia64_mv_dma_supported		sn_dma_supported;
 
 /*
@@ -111,6 +112,7 @@ extern ia64_mv_dma_supported		sn_dma_sup
 #define platform_dma_sync_sg_for_cpu	sn_dma_sync_sg_for_cpu
 #define platform_dma_sync_single_for_device sn_dma_sync_single_for_device
 #define platform_dma_sync_sg_for_device	sn_dma_sync_sg_for_device
+#define platform_dma_mapping_error		sn_dma_mapping_error
 #define platform_dma_supported		sn_dma_supported
 
 #include <asm/sn/sn2/io.h>
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ia64/processor.h linux-post-2.6.5-rc2-20040326/include/asm-ia64/processor.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ia64/processor.h	2004-02-25 22:46:40.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ia64/processor.h	2004-03-25 20:24:43.000000000 +0000
@@ -148,35 +148,35 @@ struct cpuinfo_ia64 {
 	__u32 softirq_pending;
 	__u64 itm_delta;	/* # of clock cycles between clock ticks */
 	__u64 itm_next;		/* interval timer mask value to use for next clock tick */
+	__u64 nsec_per_cyc;	/* (1000000000<<IA64_NSEC_PER_CYC_SHIFT)/itc_freq */
+	__u64 unimpl_va_mask;	/* mask of unimplemented virtual address bits (from PAL) */
+	__u64 unimpl_pa_mask;	/* mask of unimplemented physical address bits (from PAL) */
 	__u64 *pgd_quick;
 	__u64 *pmd_quick;
 	__u64 pgtable_cache_sz;
-	/* CPUID-derived information: */
-	__u64 ppn;
-	__u64 features;
-	__u8 number;
-	__u8 revision;
-	__u8 model;
-	__u8 family;
-	__u8 archrev;
-	char vendor[16];
 	__u64 itc_freq;		/* frequency of ITC counter */
 	__u64 proc_freq;	/* frequency of processor */
 	__u64 cyc_per_usec;	/* itc_freq/1000000 */
-	__u64 nsec_per_cyc;	/* (1000000000<<IA64_NSEC_PER_CYC_SHIFT)/itc_freq */
-	__u64 unimpl_va_mask;	/* mask of unimplemented virtual address bits (from PAL) */
-	__u64 unimpl_pa_mask;	/* mask of unimplemented physical address bits (from PAL) */
 	__u64 ptce_base;
 	__u32 ptce_count[2];
 	__u32 ptce_stride[2];
 	struct task_struct *ksoftirqd;	/* kernel softirq daemon for this CPU */
+
 #ifdef CONFIG_SMP
-	int cpu;
 	__u64 loops_per_jiffy;
-	__u64 ipi_count;
-	__u64 prof_counter;
-	__u64 prof_multiplier;
+	int cpu;
 #endif
+
+	/* CPUID-derived information: */
+	__u64 ppn;
+	__u64 features;
+	__u8 number;
+	__u8 revision;
+	__u8 model;
+	__u8 family;
+	__u8 archrev;
+	char vendor[16];
+
 #ifdef CONFIG_NUMA
 	struct ia64_node_data *node_data;
 #endif
@@ -678,7 +678,7 @@ ia64_imva (void *addr)
 #define ARCH_HAS_PREFETCH
 #define ARCH_HAS_PREFETCHW
 #define ARCH_HAS_SPINLOCK_PREFETCH
-#define PREFETCH_STRIDE 256
+#define PREFETCH_STRIDE			L1_CACHE_BYTES
 
 static inline void
 prefetch (const void *x)
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ia64/sn/sndrv.h linux-post-2.6.5-rc2-20040326/include/asm-ia64/sn/sndrv.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ia64/sn/sndrv.h	2004-01-19 06:36:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ia64/sn/sndrv.h	2004-03-23 14:36:53.000000000 +0000
@@ -41,6 +41,11 @@
 #define SNDRV_SHUB_RESETSTATS		42
 #define SNDRV_SHUB_GETSTATS		43
 #define SNDRV_SHUB_GETNASID		44
+#define SNDRV_SHUB_GETMMR32            45
+#define SNDRV_SHUB_GETMMR64            46
+#define SNDRV_SHUB_GETMMR64_IO         47
+#define SNDRV_SHUB_PUTMMR64            48
+#define SNDRV_SHUB_PUTMMR64_IO         49
 
 /* Devices */
 #define SNDRV_UKNOWN_DEVICE		-1
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ia64/uaccess.h linux-post-2.6.5-rc2-20040326/include/asm-ia64/uaccess.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ia64/uaccess.h	2004-01-28 05:23:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ia64/uaccess.h	2004-03-24 12:39:48.000000000 +0000
@@ -292,16 +292,16 @@ struct exception_table_entry {
 	int cont;	/* location-relative continuation addr.; if bit 2 is set, r9 is set to 0 */
 };
 
-extern void handle_exception (struct pt_regs *regs, const struct exception_table_entry *e);
+extern void ia64_handle_exception (struct pt_regs *regs, const struct exception_table_entry *e);
 extern const struct exception_table_entry *search_exception_tables (unsigned long addr);
 
 static inline int
-done_with_exception (struct pt_regs *regs)
+ia64_done_with_exception (struct pt_regs *regs)
 {
 	const struct exception_table_entry *e;
 	e = search_exception_tables(regs->cr_iip + ia64_psr(regs)->ri);
 	if (e) {
-		handle_exception(regs, e);
+		ia64_handle_exception(regs, e);
 		return 1;
 	}
 	return 0;
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ppc/elf.h linux-post-2.6.5-rc2-20040326/include/asm-ppc/elf.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ppc/elf.h	2003-05-12 14:05:39.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ppc/elf.h	2004-03-24 02:49:17.000000000 +0000
@@ -90,11 +90,17 @@ typedef elf_vrreg_t elf_vrregset_t[ELF_N
 #define USE_ELF_CORE_DUMP
 #define ELF_EXEC_PAGESIZE	4096
 
-#define ELF_CORE_COPY_REGS(gregs, regs) \
-	memcpy(gregs, regs, \
-	       sizeof(struct pt_regs) < sizeof(elf_gregset_t)? \
-	       sizeof(struct pt_regs): sizeof(elf_gregset_t));
+#define ELF_CORE_COPY_REGS(gregs, regs)				\
+	memcpy((gregs), (regs), sizeof(struct pt_regs));	\
+	memset((char *)(gregs) + sizeof(struct pt_regs), 0,	\
+	       sizeof(elf_gregset_t) - sizeof(struct pt_regs));
+
+#define ELF_CORE_COPY_TASK_REGS(t, elfregs)			\
+	((t)->thread.regs?					\
+	 ({ ELF_CORE_COPY_REGS((elfregs), (t)->thread.regs); 1; }): 0)
 
+extern int dump_task_fpu(struct task_struct *t, elf_fpregset_t *fpu);
+#define ELF_CORE_COPY_FPREGS(t, fpu)	dump_task_fpu((t), (fpu))
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this cpu supports.  This could be done in userspace,
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-ppc64/pci.h linux-post-2.6.5-rc2-20040326/include/asm-ppc64/pci.h
--- linux-post-2.6.5-rc2-20040323/include/asm-ppc64/pci.h	2004-03-22 10:44:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-ppc64/pci.h	2004-03-23 18:12:38.000000000 +0000
@@ -170,7 +170,7 @@ static inline int pci_dac_dma_supported(
 }
 
 #define PCI_DMA_ERROR_CODE      (~(dma_addr_t)0x0)
-static inline int pci_dma_error(dma_addr_t dma_addr)
+static inline int pci_dma_mapping_error(dma_addr_t dma_addr)
 {
 	return (dma_addr == PCI_DMA_ERROR_CODE);
 }
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/cpu-sh3/cacheflush.h linux-post-2.6.5-rc2-20040326/include/asm-sh/cpu-sh3/cacheflush.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/cpu-sh3/cacheflush.h	2003-05-04 15:30:07.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/cpu-sh3/cacheflush.h	2004-03-23 10:05:27.000000000 +0000
@@ -37,5 +37,7 @@
 
 #define p3_cache_init()				do { } while (0)
 
+#define HAVE_ARCH_UNMAPPED_AREA
+
 #endif /* __ASM_CPU_SH3_CACHEFLUSH_H */
 
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/cpu-sh3/dac.h linux-post-2.6.5-rc2-20040326/include/asm-sh/cpu-sh3/dac.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/cpu-sh3/dac.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/cpu-sh3/dac.h	2004-03-23 15:25:04.000000000 +0000
@@ -0,0 +1,42 @@
+#ifndef __ASM_SH_DAC_H
+#define __ASM_SH_DAC_H
+
+/*
+ * Copyright (C) 2003  Andriy Skulysh
+ */
+
+
+#define DADR0	0xa40000a0
+#define DADR1	0xa40000a2
+#define DACR	0xa40000a4
+#define DACR_DAOE1	0x80
+#define DACR_DAOE0	0x40
+#define DACR_DAE	0x20
+
+
+static __inline__ void sh_dac_enable(int channel)
+{
+	unsigned char v;
+	v = ctrl_inb(DACR);
+	if(channel) v |= DACR_DAOE1;
+	else v |= DACR_DAOE0;
+	ctrl_outb(v,DACR);
+}
+
+static __inline__ void sh_dac_disable(int channel)
+{
+	unsigned char v;
+	v = ctrl_inb(DACR);
+	if(channel) v &= ~DACR_DAOE1;
+	else v &= ~DACR_DAOE0;
+	ctrl_outb(v,DACR);
+}
+
+static __inline__ void sh_dac_output(u8 value, int channel)
+{
+	if(channel) ctrl_outb(value,DADR1);
+	else ctrl_outb(value,DADR0);
+}
+
+#endif /* __ASM_SH_DAC_H */
+
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/cpu-sh4/dma.h linux-post-2.6.5-rc2-20040326/include/asm-sh/cpu-sh4/dma.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/cpu-sh4/dma.h	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/cpu-sh4/dma.h	2004-03-23 10:05:26.000000000 +0000
@@ -1,7 +1,7 @@
 #ifndef __ASM_CPU_SH4_DMA_H
 #define __ASM_CPU_SH4_DMA_H
 
-#define SH_DMAC_BASE	0xbfa00000
+#define SH_DMAC_BASE	0xffa00000
 
 #endif /* __ASM_CPU_SH4_DMA_H */
 
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/dma-mapping.h linux-post-2.6.5-rc2-20040326/include/asm-sh/dma-mapping.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/dma-mapping.h	2002-12-22 04:37:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/dma-mapping.h	2004-03-23 10:05:26.000000000 +0000
@@ -1 +1,165 @@
-#include <asm-generic/dma-mapping.h>
+#ifndef __ASM_SH_DMA_MAPPING_H
+#define __ASM_SH_DMA_MAPPING_H
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <asm/scatterlist.h>
+#include <asm/io.h>
+
+/* arch/sh/mm/consistent.c */
+extern void *consistent_alloc(int gfp, size_t size, dma_addr_t *handle);
+extern void consistent_free(void *vaddr, size_t size);
+extern void consistent_sync(void *vaddr, size_t size, int direction);
+
+#ifdef CONFIG_SH_DREAMCAST
+struct pci_dev;
+extern struct bus_type pci_bus_type;
+extern void *__pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
+				    dma_addr_t *dma_handle);
+extern void __pci_free_consistent(struct pci_dev *hwdev, size_t size,
+				  void *vaddr, dma_addr_t dma_handle);
+#endif
+
+#define dma_supported(dev, mask)	(1)
+
+static inline int dma_set_mask(struct device *dev, u64 mask)
+{
+	if (!dev->dma_mask || !dma_supported(dev, mask))
+		return -EIO;
+
+	*dev->dma_mask = mask;
+
+	return 0;
+}
+
+static inline void *dma_alloc_coherent(struct device *dev, size_t size,
+			 dma_addr_t *dma_handle, int flag)
+{
+	/*
+	 * Some platforms have special pci_alloc_consistent() implementations,
+	 * in these instances we can't use the generic consistent_alloc().
+	 */
+#ifdef CONFIG_SH_DREAMCAST
+	if (dev && dev->bus == &pci_bus_type)
+		return __pci_alloc_consistent(NULL, size, dma_handle);
+#endif
+
+	return consistent_alloc(flag, size, dma_handle);
+}
+
+static inline void dma_free_coherent(struct device *dev, size_t size,
+		       void *vaddr, dma_addr_t dma_handle)
+{
+	/*
+	 * Same note as above applies to pci_free_consistent()..
+	 */
+#ifdef CONFIG_SH_DREAMCAST
+	if (dev && dev->bus == &pci_bus_type) {
+		__pci_free_consistent(NULL, size, vaddr, dma_handle);
+		return;
+	}
+#endif
+
+	consistent_free(vaddr, size);
+}
+
+static inline void dma_cache_sync(void *vaddr, size_t size,
+				  enum dma_data_direction dir)
+{
+	consistent_sync(vaddr, size, (int)dir);
+}
+
+static inline dma_addr_t dma_map_single(struct device *dev,
+					void *ptr, size_t size,
+					enum dma_data_direction dir)
+{
+#if defined(CONFIG_PCI) && !defined(CONFIG_SH_PCIDMA_NONCOHERENT)
+	if (dev->bus == &pci_bus_type)
+		return virt_to_bus(ptr);
+#endif
+	dma_cache_sync(ptr, size, dir);
+
+	return virt_to_bus(ptr);
+}
+
+#define dma_unmap_single(dev, addr, size, dir)	do { } while (0)
+
+static inline int dma_map_sg(struct device *dev, struct scatterlist *sg,
+			     int nents, enum dma_data_direction dir)
+{
+	int i;
+
+	for (i = 0; i < nents; i++) {
+#if !defined(CONFIG_PCI) || defined(CONFIG_SH_PCIDMA_NONCOHERENT)
+		dma_cache_sync(page_address(sg[i].page) + sg[i].offset,
+			       sg[i].length, dir);
+#endif
+		sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
+	}
+
+	return nents;
+}
+
+#define dma_unmap_sg(dev, sg, nents, dir)	do { } while (0)
+
+static inline dma_addr_t dma_map_page(struct device *dev, struct page *page,
+				      unsigned long offset, size_t size,
+				      enum dma_data_direction dir)
+{
+	return dma_map_single(dev, page_address(page) + offset, size, dir);
+}
+
+static inline void dma_unmap_page(struct device *dev, dma_addr_t dma_address,
+				  size_t size, enum dma_data_direction dir)
+{
+	dma_unmap_single(dev, dma_address, size, dir);
+}
+
+static inline void dma_sync_single(struct device *dev, dma_addr_t dma_handle,
+				   size_t size, enum dma_data_direction dir)
+{
+#if defined(CONFIG_PCI) && !defined(CONFIG_SH_PCIDMA_NONCOHERENT)
+	if (dev->bus == &pci_bus_type)
+		return;
+#endif
+	dma_cache_sync(bus_to_virt(dma_handle), size, dir);
+}
+
+static inline void dma_sync_single_range(struct device *dev,
+					 dma_addr_t dma_handle,
+					 unsigned long offset, size_t size,
+					 enum dma_data_direction dir)
+{
+#if defined(CONFIG_PCI) && !defined(CONFIG_SH_PCIDMA_NONCOHERENT)
+	if (dev->bus == &pci_bus_type)
+		return;
+#endif
+	dma_cache_sync(bus_to_virt(dma_handle) + offset, size, dir);
+}
+
+static inline void dma_sync_sg(struct device *dev, struct scatterlist *sg,
+			       int nelems, enum dma_data_direction dir)
+{
+	int i;
+
+	for (i = 0; i < nelems; i++) {
+#if !defined(CONFIG_PCI) || defined(CONFIG_SH_PCIDMA_NONCOHERENT)
+		dma_cache_sync(page_address(sg[i].page) + sg[i].offset,
+			       sg[i].length, dir);
+#endif
+		sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
+	}
+}
+
+static inline int dma_get_cache_alignment(void)
+{
+	/*
+	 * Each processor family will define its own L1_CACHE_SHIFT,
+	 * L1_CACHE_BYTES wraps to this, so this is always safe.
+	 */
+	return L1_CACHE_BYTES;
+}
+
+#endif /* __ASM_SH_DMA_MAPPING_H */
+
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/dma.h linux-post-2.6.5-rc2-20040326/include/asm-sh/dma.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/dma.h	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/dma.h	2004-03-23 10:05:26.000000000 +0000
@@ -12,6 +12,7 @@
 
 #include <linux/config.h>
 #include <linux/spinlock.h>
+#include <linux/wait.h>
 #include <asm/cpu/dma.h>
 #include <asm/semaphore.h>
 
@@ -63,11 +64,13 @@ struct dma_info {
 	unsigned long dar;
 
 	unsigned int configured:1;
+	unsigned int tei_capable:1;
 	atomic_t busy;
 
 	struct semaphore sem;
+	wait_queue_head_t wait_queue;
 	struct dma_ops *ops;
-} __attribute__ ((packed));
+};
 
 /* arch/sh/drivers/dma/dma-api.c */
 extern int dma_xfer(unsigned int chan, unsigned long from,
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/dreamcast/io.h linux-post-2.6.5-rc2-20040326/include/asm-sh/dreamcast/io.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/dreamcast/io.h	2003-05-04 15:30:14.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/dreamcast/io.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,49 +0,0 @@
-/*
- *	$Id: io.h,v 1.3 2003/05/04 19:30:14 lethal Exp $
- *	IO functions for SEGA Dreamcast
- */
-
-#ifndef _ASM_SH_IO_DREAMCAST_H
-#define _ASM_SH_IO_DREAMCAST_H
-
-#include <asm/io_generic.h>
-
-unsigned long dreamcast_isa_port2addr(unsigned long offset);
-
-#ifdef __WANT_IO_DEF
-
-# define __inb			generic_inb
-# define __inw			generic_inw
-# define __inl			generic_inl
-# define __outb			generic_outb
-# define __outw			generic_outw
-# define __outl			generic_outl
-
-# define __inb_p		generic_inb_p
-# define __inw_p		generic_inw
-# define __inl_p		generic_inl
-# define __outb_p		generic_outb_p
-# define __outw_p		generic_outw
-# define __outl_p		generic_outl
-
-# define __insb			generic_insb
-# define __insw			generic_insw
-# define __insl			generic_insl
-# define __outsb		generic_outsb
-# define __outsw		generic_outsw
-# define __outsl		generic_outsl
-
-# define __readb		generic_readb
-# define __readw		generic_readw
-# define __readl		generic_readl
-# define __writeb		generic_writeb
-# define __writew		generic_writew
-# define __writel		generic_writel
-
-# define __isa_port2addr	dreamcast_isa_port2addr
-# define __ioremap		generic_ioremap
-# define __iounmap		generic_iounmap
-
-#endif
-
-#endif /* _ASM_SH_IO_DREAMCAST_H */
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/hd64461/hd64461.h linux-post-2.6.5-rc2-20040326/include/asm-sh/hd64461/hd64461.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/hd64461/hd64461.h	2004-02-13 15:19:29.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/hd64461/hd64461.h	2004-03-23 10:05:27.000000000 +0000
@@ -1,12 +1,24 @@
 #ifndef __ASM_SH_HD64461
 #define __ASM_SH_HD64461
 /*
- *	$Id: hd64461.h,v 1.4 2004/02/01 19:46:04 lethal Exp $
+ *	$Id: hd64461.h,v 1.5 2004/03/16 00:07:51 lethal Exp $
  *	Copyright (C) 2000 YAEGASHI Takeshi
  *	Hitachi HD64461 companion chip support
  */
 #include <linux/config.h>
 
+/* Constants for PCMCIA mappings */
+#define HD64461_PCC_WINDOW	0x01000000
+
+#define HD64461_PCC0_BASE	0xb8000000	/* area 6 */
+#define HD64461_PCC0_ATTR	(HD64461_PCC0_BASE)
+#define HD64461_PCC0_COMM	(HD64461_PCC0_BASE+HD64461_PCC_WINDOW)
+#define HD64461_PCC0_IO		(HD64461_PCC0_BASE+2*HD64461_PCC_WINDOW)
+
+#define HD64461_PCC1_BASE	0xb4000000	/* area 5 */
+#define HD64461_PCC1_ATTR	(HD64461_PCC1_BASE)
+#define HD64461_PCC1_COMM	(HD64461_PCC1_BASE+HD64461_PCC_WINDOW)
+
 #define HD64461_STBCR	0x10000
 #define HD64461_STBCR_CKIO_STBY			0x2000
 #define HD64461_STBCR_SAFECKE_IST		0x1000
@@ -21,7 +33,7 @@
 #define HD64461_STBCR_STM0ST			0x0008
 #define HD64461_STBCR_STM1ST			0x0004
 #define HD64461_STBCR_SIRST				0x0002
-#define HD64461_STBCR_SURTSD			0x0001
+#define HD64461_STBCR_SURTST			0x0001
 
 #define HD64461_SYSCR	0x10002
 #define HD64461_SCPUCR	0x10004
@@ -77,16 +89,74 @@
 #define HD64461_BBTROPR		0x11068
 #define HD64461_BBTMDR		0x1106a
 
-#define HD64461_PCC0ISR         0x12000
-#define HD64461_PCC0GCR         0x12002
-#define HD64461_PCC0CSCR        0x12004
-#define HD64461_PCC0CSCIER      0x12006
-#define HD64461_PCC0SCR         0x12008
-#define HD64461_PCC1ISR         0x12010
-#define HD64461_PCC1GCR         0x12012
-#define HD64461_PCC1CSCR        0x12014
-#define HD64461_PCC1CSCIER      0x12016
-#define HD64461_PCC1SCR         0x12018
+/* PC Card Controller Registers */
+#define HD64461_PCC0ISR         0x12000 /* socket 0 interface status */
+#define HD64461_PCC0GCR         0x12002 /* socket 0 general control */
+#define HD64461_PCC0CSCR        0x12004 /* socket 0 card status change */
+#define HD64461_PCC0CSCIER      0x12006 /* socket 0 card status change interrupt enable */
+#define HD64461_PCC0SCR         0x12008 /* socket 0 software control */
+#define HD64461_PCC1ISR         0x12010 /* socket 1 interface status */
+#define HD64461_PCC1GCR         0x12012 /* socket 1 general control */
+#define HD64461_PCC1CSCR        0x12014 /* socket 1 card status change */
+#define HD64461_PCC1CSCIER      0x12016 /* socket 1 card status change interrupt enable */
+#define HD64461_PCC1SCR         0x12018 /* socket 1 software control */
+
+/* PCC Interface Status Register */
+#define HD64461_PCCISR_READY		0x80	/* card ready */
+#define HD64461_PCCISR_MWP		0x40	/* card write-protected */
+#define HD64461_PCCISR_VS2		0x20	/* voltage select pin 2 */
+#define HD64461_PCCISR_VS1		0x10	/* voltage select pin 1 */
+#define HD64461_PCCISR_CD2		0x08	/* card detect 2 */
+#define HD64461_PCCISR_CD1		0x04	/* card detect 1 */
+#define HD64461_PCCISR_BVD2		0x02	/* battery 1 */
+#define HD64461_PCCISR_BVD1		0x01	/* battery 1 */
+
+#define HD64461_PCCISR_PCD_MASK		0x0c    /* card detect */
+#define HD64461_PCCISR_BVD_MASK	0x03    /* battery voltage */
+#define HD64461_PCCISR_BVD_BATGOOD	0x03    /* battery good */
+#define HD64461_PCCISR_BVD_BATWARN	0x01    /* battery low warning */
+#define HD64461_PCCISR_BVD_BATDEAD1	0x02    /* battery dead */
+#define HD64461_PCCISR_BVD_BATDEAD2	0x00    /* battery dead */
+
+/* PCC General Control Register */
+#define HD64461_PCCGCR_DRVE		0x80    /* output drive */
+#define HD64461_PCCGCR_PCCR		0x40    /* PC card reset */
+#define HD64461_PCCGCR_PCCT		0x20    /* PC card type, 1=IO&mem, 0=mem */
+#define HD64461_PCCGCR_VCC0		0x10    /* voltage control pin VCC0SEL0 */
+#define HD64461_PCCGCR_PMMOD		0x08    /* memory mode */
+#define HD64461_PCCGCR_PA25		0x04    /* pin A25 */
+#define HD64461_PCCGCR_PA24		0x02    /* pin A24 */
+#define HD64461_PCCGCR_REG		0x01    /* pin PCC0REG# */
+
+/* PCC Card Status Change Register */
+#define HD64461_PCCCSCR_SCDI		0x80    /* sw card detect intr */
+#define HD64461_PCCCSCR_SRV1		0x40    /* reserved */
+#define HD64461_PCCCSCR_IREQ		0x20    /* IREQ intr req */
+#define HD64461_PCCCSCR_SC		0x10    /* STSCHG (status change) pin */
+#define HD64461_PCCCSCR_CDC		0x08    /* CD (card detect) change */
+#define HD64461_PCCCSCR_RC		0x04    /* READY change */
+#define HD64461_PCCCSCR_BW		0x02    /* battery warning change */
+#define HD64461_PCCCSCR_BD		0x01    /* battery dead change */
+
+/* PCC Card Status Change Interrupt Enable Register */
+#define HD64461_PCCCSCIER_CRE		0x80    /* change reset enable */
+#define HD64461_PCCCSCIER_IREQE_MASK   	0x60   /* IREQ enable */
+#define HD64461_PCCCSCIER_IREQE_DISABLED	0x00   /* IREQ disabled */
+#define HD64461_PCCCSCIER_IREQE_LEVEL  	0x20   /* IREQ level-triggered */
+#define HD64461_PCCCSCIER_IREQE_FALLING	0x40   /* IREQ falling-edge-trig */
+#define HD64461_PCCCSCIER_IREQE_RISING 	0x60   /* IREQ rising-edge-trig */
+
+#define HD64461_PCCCSCIER_SCE		0x10    /* status change enable */
+#define HD64461_PCCCSCIER_CDE		0x08    /* card detect change enable */
+#define HD64461_PCCCSCIER_RE		0x04    /* ready change enable */
+#define HD64461_PCCCSCIER_BWE		0x02    /* battery warn change enable */
+#define HD64461_PCCCSCIER_BDE		0x01    /* battery dead change enable*/
+
+/* PCC Software Control Register */
+#define HD64461_PCCSCR_VCC1		0x02	/* voltage control pin 1 */
+#define HD64461_PCCSCR_SWP		0x01    /* write protect */
+
+
 #define HD64461_P0OCR           0x1202a
 #define HD64461_P1OCR           0x1202c
 #define HD64461_PGCR            0x1202e
@@ -121,4 +191,13 @@
 #define HD64461_IRQBASE		OFFCHIP_IRQ_BASE
 #define HD64461_IRQ_NUM 	16
 
+#define HD64461_IRQ_UART    	(HD64461_IRQBASE+5)
+#define HD64461_IRQ_IRDA    	(HD64461_IRQBASE+6)
+#define HD64461_IRQ_TMU1   	(HD64461_IRQBASE+9)
+#define HD64461_IRQ_TMU0  	(HD64461_IRQBASE+10)
+#define HD64461_IRQ_GPIO    	(HD64461_IRQBASE+11)
+#define HD64461_IRQ_AFE     	(HD64461_IRQBASE+12)
+#define HD64461_IRQ_PCC1 	(HD64461_IRQBASE+13)
+#define HD64461_IRQ_PCC0 	(HD64461_IRQBASE+14)
+
 #endif
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/hd64461/io.h linux-post-2.6.5-rc2-20040326/include/asm-sh/hd64461/io.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/hd64461/io.h	2004-02-13 15:19:29.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/hd64461/io.h	2004-03-23 10:05:27.000000000 +0000
@@ -23,15 +23,21 @@ extern void hd64461_outl(unsigned int va
 extern unsigned char hd64461_inb_p(unsigned long port);
 extern void hd64461_outb_p(unsigned char value, unsigned long port);
 
-extern void hd64461_insb(unsigned long port, const void *buffer, unsigned long count);
-extern void hd64461_insw(unsigned long port, const void *buffer, unsigned long count);
-extern void hd64461_insl(unsigned long port, const void *buffer, unsigned long count);
+extern void hd64461_insb(unsigned long port, void *addr, unsigned long count);
+extern void hd64461_insw(unsigned long port, void *addr, unsigned long count);
+extern void hd64461_insl(unsigned long port, void *addr, unsigned long count);
 
 extern void hd64461_outsb(unsigned long port, const void *buffer, unsigned long count);
 extern void hd64461_outsw(unsigned long port, const void *buffer, unsigned long count);
 extern void hd64461_outsl(unsigned long port, const void *buffer, unsigned long count);
 
+extern unsigned short hd64461_readw(unsigned long addr);
+extern void hd64461_writew(unsigned short b, unsigned long addr);
+
 
 extern int hd64461_irq_demux(int irq);
+extern void hd64461_register_irq_demux(int irq,
+		int (*demux)(int irq, void *dev), void *dev);
+extern void hd64461_unregister_irq_demux(int irq);
 
 #endif /* _ASM_SH_IO_HD64461_H */
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/hp6xx/hp6xx.h linux-post-2.6.5-rc2-20040326/include/asm-sh/hp6xx/hp6xx.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/hp6xx/hp6xx.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/hp6xx/hp6xx.h	2004-03-23 15:25:04.000000000 +0000
@@ -0,0 +1,19 @@
+#ifndef __ASM_SH_HP6XX_H
+#define __ASM_SH_HP6XX_H
+
+/*
+ * Copyright (C) 2003  Andriy Skulysh
+ */
+
+
+#define DAC_LCD_BRIGHTNESS		0
+#define DAC_SPEAKER_VOLUME		1
+
+#define HD64461_GPADR_SPEAKER	0x01
+#define HD64461_GPADR_PCMCIA0	(0x02|0x08)
+#define HD64461_GPBDR_LCDOFF	0x01
+#define HD64461_GPBDR_LED_RED	0x80
+
+
+#endif /* __ASM_SH_HP6XX_H */
+
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/irq.h linux-post-2.6.5-rc2-20040326/include/asm-sh/irq.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/irq.h	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/irq.h	2004-03-23 10:05:27.000000000 +0000
@@ -30,6 +30,11 @@
 #define TIMER_IPR_POS	 3
 #define TIMER_PRIORITY	 2
 
+#define TIMER1_IRQ	17
+#define TIMER1_IPR_ADDR	INTC_IPRA
+#define TIMER1_IPR_POS	 2
+#define TIMER1_PRIORITY	 4
+
 #define RTC_IRQ		22
 #define RTC_IPR_ADDR	INTC_IPRA
 #define RTC_IPR_POS	 0
@@ -154,7 +159,7 @@
 # define OFFCHIP_NR_IRQS 16
 #else
 # if defined(CONFIG_HD64461)
-#  define OFFCHIP_NR_IRQS 16
+#  define OFFCHIP_NR_IRQS 18
 # elif defined (CONFIG_SH_BIGSUR) /* must be before CONFIG_HD64465 */
 #  define OFFCHIP_NR_IRQS 48
 # elif defined(CONFIG_HD64465)
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/page.h linux-post-2.6.5-rc2-20040326/include/asm-sh/page.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/page.h	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/page.h	2004-03-23 10:05:26.000000000 +0000
@@ -21,6 +21,18 @@
 #define PAGE_MASK	(~(PAGE_SIZE-1))
 #define PTE_MASK	PAGE_MASK
 
+#if defined(CONFIG_HUGETLB_PAGE_SIZE_64K)
+#define HPAGE_SHIFT	16
+#elif defined(CONFIG_HUGETLB_PAGE_SIZE_1MB)
+#define HPAGE_SHIFT	20
+#endif
+
+#ifdef CONFIG_HUGETLB_PAGE
+#define HPAGE_SIZE		(1UL << HPAGE_SHIFT)
+#define HPAGE_MASK		(~(HPAGE_SIZE-1))
+#define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT-PAGE_SHIFT)
+#endif
+
 #ifdef __KERNEL__
 #ifndef __ASSEMBLY__
 
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/pci.h linux-post-2.6.5-rc2-20040326/include/asm-sh/pci.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/pci.h	2004-03-14 06:54:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/pci.h	2004-03-23 10:05:26.000000000 +0000
@@ -3,9 +3,7 @@
 
 #ifdef __KERNEL__
 
-#include <linux/config.h>
-#include <linux/mm.h>		/* for struct page */
-#include <asm/cacheflush.h>
+#include <linux/dma-mapping.h>
 
 /* Can be used to override the logic in pci_scan_bus for skipping
    already-configured bus numbers - to be used for buggy BIOSes
@@ -59,45 +57,6 @@ static inline void pcibios_penalize_isa_
 #include <linux/string.h>
 #include <asm/io.h>
 
-/* Allocate and map kernel buffer using consistent mode DMA for a device.
- * hwdev should be valid struct pci_dev pointer for PCI devices,
- * NULL for PCI-like buses (ISA, EISA).
- * Returns non-NULL cpu-view pointer to the buffer if successful and
- * sets *dma_addrp to the pci side dma address as well, else *dma_addrp
- * is undefined.
- */
-extern void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
-				  dma_addr_t *dma_handle);
-
-/* Free and unmap a consistent DMA buffer.
- * cpu_addr is what was returned from pci_alloc_consistent,
- * size must be the same as what as passed into pci_alloc_consistent,
- * and likewise dma_addr must be the same as what *dma_addrp was set to.
- *
- * References to the memory and mappings associated with cpu_addr/dma_addr
- * past this call are illegal.
- */
-extern void pci_free_consistent(struct pci_dev *hwdev, size_t size,
-				void *vaddr, dma_addr_t dma_handle);
-
-/* Map a single buffer of the indicated size for DMA in streaming mode.
- * The 32-bit bus address to use is returned.
- *
- * Once the device is given the dma address, the device owns this memory
- * until either pci_unmap_single or pci_dma_sync_single_for_cpu is performed.
- */
-static inline dma_addr_t pci_map_single(struct pci_dev *hwdev, void *ptr,
-					size_t size, int direction)
-{
-	if (direction == PCI_DMA_NONE)
-                BUG();
-
-#ifdef CONFIG_SH_PCIDMA_NONCOHERENT
-	dma_cache_wback_inv(ptr, size);
-#endif
-	return virt_to_bus(ptr);
-}
-
 /* pci_unmap_{single,page} being a nop depends upon the
  * configuration.
  */
@@ -123,134 +82,6 @@ static inline dma_addr_t pci_map_single(
 #define pci_unmap_len_set(PTR, LEN_NAME, VAL)	do { } while (0)
 #endif
 
-/* Unmap a single streaming mode DMA translation.  The dma_addr and size
- * must match what was provided for in a previous pci_map_single call.  All
- * other usages are undefined.
- *
- * After this call, reads by the cpu to the buffer are guaranteed to see
- * whatever the device wrote there.
- */
-static inline void pci_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr,
-				    size_t size,int direction)
-{
-	/* Nothing to do */
-}
-
-/* Map a set of buffers described by scatterlist in streaming
- * mode for DMA.  This is the scather-gather version of the
- * above pci_map_single interface.  Here the scatter gather list
- * elements are each tagged with the appropriate dma address
- * and length.  They are obtained via sg_dma_{address,length}(SG).
- *
- * NOTE: An implementation may be able to use a smaller number of
- *       DMA address/length pairs than there are SG table elements.
- *       (for example via virtual mapping capabilities)
- *       The routine returns the number of addr/length pairs actually
- *       used, at most nents.
- *
- * Device ownership issues as mentioned above for pci_map_single are
- * the same here.
- */
-static inline int pci_map_sg(struct pci_dev *hwdev, struct scatterlist *sg,
-			     int nents, int direction)
-{
-#ifdef CONFIG_SH_PCIDMA_NONCOHERENT
-	int i;
-
-	for (i=0; i<nents; i++) {
-		dma_cache_wback_inv(page_address(sg[i].page) + sg[i].offset, sg[i].length);
-		sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
-	}
-#endif
-	if (direction == PCI_DMA_NONE)
-                BUG();
-
-	return nents;
-}
-
-/* Unmap a set of streaming mode DMA translations.
- * Again, cpu read rules concerning calls here are the same as for
- * pci_unmap_single() above.
- */
-static inline void pci_unmap_sg(struct pci_dev *hwdev, struct scatterlist *sg,
-				int nents, int direction)
-{
-	/* Nothing to do */
-}
-
-/* Make physical memory consistent for a single
- * streaming mode DMA translation after a transfer.
- *
- * If you perform a pci_map_single() but wish to interrogate the
- * buffer using the cpu, yet do not wish to teardown the PCI dma
- * mapping, you must call this function before doing so.  At the
- * next point you give the PCI dma address back to the card, you
- * must first perform a pci_dma_sync_for_device, and then the device
- * again owns the buffer.
- */
-static inline void pci_dma_sync_single_for_cpu(struct pci_dev *hwdev,
-					       dma_addr_t dma_handle,
-					       size_t size, int direction)
-{
-	if (direction == PCI_DMA_NONE)
-                BUG();
-}
-
-static inline void pci_dma_sync_single_for_device(struct pci_dev *hwdev,
-						  dma_addr_t dma_handle,
-						  size_t size, int direction)
-{
-	if (direction == PCI_DMA_NONE)
-                BUG();
-
-#ifdef CONFIG_SH_PCIDMA_NONCOHERENT
-	dma_cache_wback_inv(bus_to_virt(dma_handle), size);
-#endif
-	
-}
-
-/* Make physical memory consistent for a set of streaming
- * mode DMA translations after a transfer.
- *
- * The same as pci_dma_sync_single_* but for a scatter-gather list,
- * same rules and usage.
- */
-static inline void pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev,
-					   struct scatterlist *sg,
-					   int nelems, int direction)
-{
-	if (direction == PCI_DMA_NONE)
-                BUG();
-}
-
-static inline void pci_dma_sync_sg_for_device(struct pci_dev *hwdev,
-					      struct scatterlist *sg,
-					      int nelems, int direction)
-{
-	if (direction == PCI_DMA_NONE)
-                BUG();
-
-#ifdef CONFIG_SH_PCIDMA_NONCOHERENT
-	int i;
-
-	for (i=0; i<nelems; i++) {
-		dma_cache_wback_inv(page_address(sg[i].page) + sg[i].offset, sg[i].length);
-		sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
-	}
-#endif
-}
-
-
-/* Return whether the given PCI device DMA address mask can
- * be supported properly.  For example, if your device can
- * only drive the low 24-bits during PCI bus mastering, then
- * you would pass 0x00ffffff as the mask to this function.
- */
-static inline int pci_dma_supported(struct pci_dev *hwdev, u64 mask)
-{
-	return 1;
-}
-
 /* Not supporting more than 32-bit PCI bus addresses now, but
  * must satisfy references to this function.  Change if needed.
  */
@@ -282,5 +113,8 @@ static inline void pcibios_add_platform_
 /* generic pci stuff */
 #include <asm-generic/pci.h>
 
+/* generic DMA-mapping stuff */
+#include <asm-generic/pci-dma-compat.h>
+
 #endif /* __ASM_SH_PCI_H */
 
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/pgtable.h linux-post-2.6.5-rc2-20040326/include/asm-sh/pgtable.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/pgtable.h	2004-01-19 06:35:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/pgtable.h	2004-03-23 10:05:27.000000000 +0000
@@ -53,20 +53,20 @@ extern unsigned long empty_zero_page[102
 #define VMALLOC_START	(P3SEG+0x00100000)
 #define VMALLOC_END	P4SEG
 
-/*			0x001     WT-bit on SH-4, 0 on SH-3 */
+#define	_PAGE_WT	0x001  /* WT-bit on SH-4, 0 on SH-3 */
 #define _PAGE_HW_SHARED	0x002  /* SH-bit  : page is shared among processes */
 #define _PAGE_DIRTY	0x004  /* D-bit   : page changed */
 #define _PAGE_CACHABLE	0x008  /* C-bit   : cachable */
-/*			0x010     SZ0-bit : Size of page */
+#define _PAGE_SZ0	0x010  /* SZ0-bit : Size of page */
 #define _PAGE_RW	0x020  /* PR0-bit : write access allowed */
 #define _PAGE_USER	0x040  /* PR1-bit : user space access allowed */
-/*			0x080     SZ1-bit : Size of page (on SH-4) */
+#define _PAGE_SZ1	0x080  /* SZ1-bit : Size of page (on SH-4) */
 #define _PAGE_PRESENT	0x100  /* V-bit   : page is valid */
 #define _PAGE_PROTNONE	0x200  /* software: if not present  */
 #define _PAGE_ACCESSED 	0x400  /* software: page referenced */
 #define _PAGE_U0_SHARED 0x800  /* software: page is shared in user space */
 
-#define	_PAGE_FILE	0x080  /* software: pagecache or swap? */
+#define	_PAGE_FILE	_PAGE_WT  /* software: pagecache or swap? */
 
 /* software: moves to PTEA.TC (Timing Control) */
 #define _PAGE_PCC_AREA5	0x00000000	/* use BSC registers for area5 */
@@ -83,20 +83,29 @@ extern unsigned long empty_zero_page[102
 
 
 /* Mask which drop software flags
- * We also drop SZ1 bit since it is always 0 and used for _PAGE_FILE
+ * We also drop WT bit since it is used for _PAGE_FILE
  * bit in this implementation.
  */
+#define _PAGE_CLEAR_FLAGS	(_PAGE_WT | _PAGE_PROTNONE | _PAGE_ACCESSED | _PAGE_U0_SHARED)
+
 #if defined(CONFIG_CPU_SH3)
 /*
  * MMU on SH-3 has bug on SH-bit: We can't use it if MMUCR.IX=1.
  * Work around: Just drop SH-bit.
  */
-#define _PAGE_FLAGS_HARDWARE_MASK	0x1ffff17c
+#define _PAGE_FLAGS_HARDWARE_MASK	(0x1fffffff & ~(_PAGE_CLEAR_FLAGS | _PAGE_HW_SHARED))
 #else
-#define _PAGE_FLAGS_HARDWARE_MASK	0x1ffff17e
+#define _PAGE_FLAGS_HARDWARE_MASK	(0x1fffffff & ~(_PAGE_CLEAR_FLAGS))
+#endif
+
+/* Hardware flags: SZ0=1 (4k-byte) */
+#define _PAGE_FLAGS_HARD	_PAGE_SZ0
+
+#if defined(CONFIG_HUGETLB_PAGE_SIZE_64K)
+#define _PAGE_SZHUGE	(_PAGE_SZ1)
+#elif defined(CONFIG_HUGETLB_PAGE_SIZE_1MB)
+#define _PAGE_SZHUGE	(_PAGE_SZ0 | _PAGE_SZ1)
 #endif
-/* Hardware flags: SZ=1 (4k-byte) */
-#define _PAGE_FLAGS_HARD		0x00000010
 
 #define _PAGE_SHARED	_PAGE_U0_SHARED
 
@@ -195,6 +204,8 @@ static inline pgprot_t pgprot_noncached(
 	return __pgprot(prot);
 }
 
+#define pgprot_writecombine(prot) __pgprot(pgprot_val(prot) & ~_PAGE_CACHABLE)
+
 /*
  * Conversion functions: convert a page and protection to a page entry,
  * and a page entry and page directory to the page they refer to.
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/processor.h linux-post-2.6.5-rc2-20040326/include/asm-sh/processor.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/processor.h	2004-02-13 15:19:27.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/processor.h	2004-03-23 10:05:27.000000000 +0000
@@ -22,6 +22,7 @@
 
 /* Core Processor Version Register */
 #define CCN_PVR		0xff000030
+#define CCN_CVR		0xff000040
 #define CCN_PRR		0xff000044
 
 /*
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/sh2000/io.h linux-post-2.6.5-rc2-20040326/include/asm-sh/sh2000/io.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/sh2000/io.h	2002-11-01 12:19:31.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/sh2000/io.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,56 +0,0 @@
-/*
- * include/asm-sh/io_sh2000.h
- *
- * Copyright 2000 Stuart Menefy (stuart.menefy@st.com)
- *           2001 SUGIOKA Toshinobu (sugioka@itonet.co.jp)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * IO functions for use when we don't know what machine we are on
- */
-
-#ifndef _ASM_SH_IO_SH2000_H
-#define _ASM_SH_IO_SH2000_H
-
-#include <asm/io_generic.h>
-
-unsigned long sh2000_isa_port2addr(unsigned long offset);
-
-#ifdef __WANT_IO_DEF
-
-# define __inb			generic_inb
-# define __inw			generic_inw
-# define __inl			generic_inl
-# define __outb			generic_outb
-# define __outw			generic_outw
-# define __outl			generic_outl
-
-# define __inb_p		generic_inb_p
-# define __inw_p		generic_inw
-# define __inl_p		generic_inl
-# define __outb_p		generic_outb_p
-# define __outw_p		generic_outw
-# define __outl_p		generic_outl
-
-# define __insb			generic_insb
-# define __insw			generic_insw
-# define __insl			generic_insl
-# define __outsb		generic_outsb
-# define __outsw		generic_outsw
-# define __outsl		generic_outsl
-
-# define __readb		generic_readb
-# define __readw		generic_readw
-# define __readl		generic_readl
-# define __writeb		generic_writeb
-# define __writew		generic_writew
-# define __writel		generic_writel
-
-# define __isa_port2addr	sh2000_isa_port2addr
-# define __ioremap		generic_ioremap
-# define __iounmap		generic_iounmap
-
-#endif
-
-#endif /* _ASM_SH_IO_SH2000_H */
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sh/signal.h linux-post-2.6.5-rc2-20040326/include/asm-sh/signal.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sh/signal.h	2003-09-21 21:50:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sh/signal.h	2004-03-23 10:05:27.000000000 +0000
@@ -7,6 +7,10 @@
 struct pt_regs;
 struct siginfo;
 
+#ifdef __KERNEL__
+/* Most things should be clean enough to redefine this at will, if care
+   is taken to make libc match.  */
+
 #define _NSIG		64
 #define _NSIG_BPW	32
 #define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
@@ -17,6 +21,14 @@ typedef struct {
 	unsigned long sig[_NSIG_WORDS];
 } sigset_t;
 
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+#define NSIG		32
+typedef unsigned long sigset_t;
+
+#endif /* __KERNEL__ */
+
 #define SIGHUP		 1
 #define SIGINT		 2
 #define SIGQUIT		 3
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sparc/semaphore.h linux-post-2.6.5-rc2-20040326/include/asm-sparc/semaphore.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sparc/semaphore.h	2004-02-14 05:24:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sparc/semaphore.h	2004-03-25 16:09:10.000000000 +0000
@@ -26,7 +26,7 @@ struct semaphore {
 #endif
 
 #define __SEMAPHORE_INITIALIZER(name,count) \
-{ ATOMIC_INIT(count), 0, __WAIT_QUEUE_HEAD_INITIALIZER((name).wait) \
+{ ATOMIC24_INIT(count), 0, __WAIT_QUEUE_HEAD_INITIALIZER((name).wait) \
 	__SEM_DEBUG_INIT(name) }
 
 #define __MUTEX_INITIALIZER(name) \
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sparc64/pci.h linux-post-2.6.5-rc2-20040326/include/asm-sparc64/pci.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sparc64/pci.h	2004-03-19 21:37:35.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sparc64/pci.h	2004-03-23 18:15:42.000000000 +0000
@@ -215,7 +215,7 @@ pci_dac_dma_sync_single_for_device(struc
 
 #define PCI_DMA_ERROR_CODE	(~(dma_addr_t)0x0)
 
-static inline int pci_dma_error(dma_addr_t dma_addr)
+static inline int pci_dma_mapping_error(dma_addr_t dma_addr)
 {
 	return (dma_addr == PCI_DMA_ERROR_CODE);
 }
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-sparc64/pgalloc.h linux-post-2.6.5-rc2-20040326/include/asm-sparc64/pgalloc.h
--- linux-post-2.6.5-rc2-20040323/include/asm-sparc64/pgalloc.h	2003-08-20 02:00:31.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-sparc64/pgalloc.h	2004-03-24 20:16:19.000000000 +0000
@@ -38,11 +38,12 @@ static __inline__ void free_pgd_fast(pgd
 
 	preempt_disable();
 	if (!page->lru.prev) {
-		(unsigned long *)page->lru.next = pgd_quicklist;
+		page->lru.next = (void *) pgd_quicklist;
 		pgd_quicklist = (unsigned long *)page;
 	}
-	(unsigned long)page->lru.prev |=
-		(((unsigned long)pgd & (PAGE_SIZE / 2)) ? 2 : 1);
+	page->lru.prev = (void *)
+	  (((unsigned long)page->lru.prev) |
+	   (((unsigned long)pgd & (PAGE_SIZE / 2)) ? 2 : 1));
 	pgd_cache_size++;
 	preempt_enable();
 }
@@ -62,7 +63,7 @@ static __inline__ pgd_t *get_pgd_fast(vo
 			off = PAGE_SIZE / 2;
 			mask &= ~2;
 		}
-		(unsigned long)ret->lru.prev = mask;
+		ret->lru.prev = (void *) mask;
 		if (!mask)
 			pgd_quicklist = (unsigned long *)ret->lru.next;
                 ret = (struct page *)(__page_address(ret) + off);
@@ -76,10 +77,10 @@ static __inline__ pgd_t *get_pgd_fast(vo
 		if (page) {
 			ret = (struct page *)page_address(page);
 			clear_page(ret);
-			(unsigned long)page->lru.prev = 2;
+			page->lru.prev = (void *) 2UL;
 
 			preempt_disable();
-			(unsigned long *)page->lru.next = pgd_quicklist;
+			page->lru.next = (void *) pgd_quicklist;
 			pgd_quicklist = (unsigned long *)page;
 			pgd_cache_size++;
 			preempt_enable();
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-x86_64/acpi.h linux-post-2.6.5-rc2-20040326/include/asm-x86_64/acpi.h
--- linux-post-2.6.5-rc2-20040323/include/asm-x86_64/acpi.h	2004-03-16 14:05:14.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-x86_64/acpi.h	2004-03-21 05:28:40.000000000 +0000
@@ -105,6 +105,9 @@ extern int acpi_lapic;
 extern int acpi_ioapic;
 extern int acpi_noirq;
 extern int acpi_strict;
+extern int acpi_disabled;
+extern int acpi_ht;
+static inline void disable_acpi(void) { acpi_disabled = 1; acpi_ht = 0; }
 
 /* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
 #define FIX_ACPI_PAGES 4
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-x86_64/mpspec.h linux-post-2.6.5-rc2-20040326/include/asm-x86_64/mpspec.h
--- linux-post-2.6.5-rc2-20040323/include/asm-x86_64/mpspec.h	2004-03-19 18:37:08.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-x86_64/mpspec.h	2004-03-23 06:53:14.000000000 +0000
@@ -193,8 +193,6 @@ extern void mp_parse_prt (void);
 #endif /*CONFIG_X86_IO_APIC*/
 #endif
 
-extern void mp_config_ioapic_for_sci(u32 gsi);
-
 extern int using_apic_timer;
 
 #define PHYSID_ARRAY_SIZE	BITS_TO_LONGS(MAX_APICS)
diff -purN linux-post-2.6.5-rc2-20040323/include/asm-x86_64/pci.h linux-post-2.6.5-rc2-20040326/include/asm-x86_64/pci.h
--- linux-post-2.6.5-rc2-20040323/include/asm-x86_64/pci.h	2004-03-14 06:54:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/asm-x86_64/pci.h	2004-03-25 11:52:35.000000000 +0000
@@ -49,7 +49,7 @@ struct pci_dev;
 extern int iommu_setup(char *opt);
 
 extern dma_addr_t bad_dma_address;
-#define pci_dma_error(x) ((x) == bad_dma_address)
+#define pci_dma_mapping_error(x) ((x) == bad_dma_address)
 
 /* Allocate and map kernel buffer using consistent mode DMA for a device.
  * hwdev should be valid struct pci_dev pointer for PCI devices,
diff -purN linux-post-2.6.5-rc2-20040323/include/linux/miscdevice.h linux-post-2.6.5-rc2-20040326/include/linux/miscdevice.h
--- linux-post-2.6.5-rc2-20040323/include/linux/miscdevice.h	2004-01-27 20:01:20.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/linux/miscdevice.h	2004-03-23 10:05:27.000000000 +0000
@@ -19,6 +19,7 @@
 #define SUN_OPENPROM_MINOR 139
 #define DMAPI_MINOR		140	/* DMAPI */
 #define NVRAM_MINOR 144
+#define STORE_QUEUE_MINOR	155
 #define I2O_MINOR 166
 #define MICROCODE_MINOR		184
 #define MWAVE_MINOR	219		/* ACP/Mwave Modem */
diff -purN linux-post-2.6.5-rc2-20040323/include/linux/serial_core.h linux-post-2.6.5-rc2-20040326/include/linux/serial_core.h
--- linux-post-2.6.5-rc2-20040323/include/linux/serial_core.h	2004-03-07 07:16:08.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/include/linux/serial_core.h	2004-03-23 10:05:26.000000000 +0000
@@ -78,6 +78,11 @@
 #define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */
 #define PORT_PMAC_ZILOG	51
 
+/* SH-SCI */
+#define PORT_SCI	52
+#define PORT_SCIF	53
+#define PORT_IRDA	54
+
 #ifdef __KERNEL__
 
 #include <linux/config.h>
diff -purN linux-post-2.6.5-rc2-20040323/net/ipv4/Kconfig linux-post-2.6.5-rc2-20040326/net/ipv4/Kconfig
--- linux-post-2.6.5-rc2-20040323/net/ipv4/Kconfig	2004-02-07 00:24:19.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/ipv4/Kconfig	2004-03-24 21:48:42.000000000 +0000
@@ -287,25 +287,6 @@ config ARPD
 	  and you should also say Y to "Kernel/User network link driver",
 	  below. If unsure, say N.
 
-config INET_ECN
-	bool "IP: TCP Explicit Congestion Notification support"
-	depends on INET
-	---help---
-	  Explicit Congestion Notification (ECN) allows routers to notify
-	  clients about network congestion, resulting in fewer dropped packets
-	  and increased network performance.  This option adds ECN support to
-	  the Linux kernel, as well as a sysctl (/proc/sys/net/ipv4/tcp_ecn)
-	  which allows ECN support to be disabled at runtime.
-
-	  Note that, on the Internet, there are many broken firewalls which
-	  refuse connections from ECN-enabled machines, and it may be a while
-	  before these firewalls are fixed.  Until then, to access a site
-	  behind such a firewall (some of which are major sites, at the time
-	  of this writing) you will have to disable this option, either by
-	  saying N now or by using the sysctl.
-
-	  If in doubt, say N.
-
 config SYN_COOKIES
 	bool "IP: TCP syncookie support (disabled per default)"
 	depends on INET
diff -purN linux-post-2.6.5-rc2-20040323/net/ipv4/ipvs/ip_vs_conn.c linux-post-2.6.5-rc2-20040326/net/ipv4/ipvs/ip_vs_conn.c
--- linux-post-2.6.5-rc2-20040323/net/ipv4/ipvs/ip_vs_conn.c	2004-02-18 21:03:52.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/ipv4/ipvs/ip_vs_conn.c	2004-03-23 02:38:03.000000000 +0000
@@ -125,25 +125,27 @@ static unsigned int ip_vs_conn_hashkey(u
 static inline int ip_vs_conn_hash(struct ip_vs_conn *cp)
 {
 	unsigned hash;
-
-	if (cp->flags & IP_VS_CONN_F_HASHED) {
-		IP_VS_ERR("ip_vs_conn_hash(): request for already hashed, "
-			  "called from %p\n", __builtin_return_address(0));
-		return 0;
-	}
+	int ret;
 
 	/* Hash by protocol, client address and port */
 	hash = ip_vs_conn_hashkey(cp->protocol, cp->caddr, cp->cport);
 
 	ct_write_lock(hash);
 
-	list_add(&cp->c_list, &ip_vs_conn_tab[hash]);
-	cp->flags |= IP_VS_CONN_F_HASHED;
-	atomic_inc(&cp->refcnt);
+	if (!(cp->flags & IP_VS_CONN_F_HASHED)) {
+		list_add(&cp->c_list, &ip_vs_conn_tab[hash]);
+		cp->flags |= IP_VS_CONN_F_HASHED;
+		atomic_inc(&cp->refcnt);
+		ret = 1;
+	} else {
+		IP_VS_ERR("ip_vs_conn_hash(): request for already hashed, "
+			  "called from %p\n", __builtin_return_address(0));
+		ret = 0;
+	}
 
 	ct_write_unlock(hash);
 
-	return 1;
+	return ret;
 }
 
 
@@ -154,24 +156,24 @@ static inline int ip_vs_conn_hash(struct
 static inline int ip_vs_conn_unhash(struct ip_vs_conn *cp)
 {
 	unsigned hash;
-
-	if (!(cp->flags & IP_VS_CONN_F_HASHED)) {
-		IP_VS_ERR("ip_vs_conn_unhash(): request for unhash flagged, "
-			  "called from %p\n", __builtin_return_address(0));
-		return 0;
-	}
+	int ret;
 
 	/* unhash it and decrease its reference counter */
 	hash = ip_vs_conn_hashkey(cp->protocol, cp->caddr, cp->cport);
+
 	ct_write_lock(hash);
 
-	list_del(&cp->c_list);
-	cp->flags &= ~IP_VS_CONN_F_HASHED;
-	atomic_dec(&cp->refcnt);
+	if (cp->flags & IP_VS_CONN_F_HASHED) {
+		list_del(&cp->c_list);
+		cp->flags &= ~IP_VS_CONN_F_HASHED;
+		atomic_dec(&cp->refcnt);
+		ret = 1;
+	} else
+		ret = 0;
 
 	ct_write_unlock(hash);
 
-	return 1;
+	return ret;
 }
 
 
@@ -285,12 +287,18 @@ void ip_vs_conn_put(struct ip_vs_conn *c
  */
 void ip_vs_conn_fill_cport(struct ip_vs_conn *cp, __u16 cport)
 {
-	atomic_dec(&ip_vs_conn_no_cport_cnt);
-	ip_vs_conn_unhash(cp);
-	cp->flags &= ~IP_VS_CONN_F_NO_CPORT;
-	cp->cport = cport;
-	/* hash on new dport */
-	ip_vs_conn_hash(cp);
+	if (ip_vs_conn_unhash(cp)) {
+		spin_lock(&cp->lock);
+		if (cp->flags & IP_VS_CONN_F_NO_CPORT) {
+			atomic_dec(&ip_vs_conn_no_cport_cnt);
+			cp->flags &= ~IP_VS_CONN_F_NO_CPORT;
+			cp->cport = cport;
+		}
+		spin_unlock(&cp->lock);
+
+		/* hash on new dport */
+		ip_vs_conn_hash(cp);
+	}
 }
 
 
@@ -457,11 +465,14 @@ int ip_vs_check_template(struct ip_vs_co
 		/*
 		 * Invalidate the connection template
 		 */
-		ip_vs_conn_unhash(ct);
-		ct->dport = 65535;
-		ct->vport = 65535;
-		ct->cport = 0;
-		ip_vs_conn_hash(ct);
+		if (ct->cport) {
+			if (ip_vs_conn_unhash(ct)) {
+				ct->dport = 65535;
+				ct->vport = 65535;
+				ct->cport = 0;
+				ip_vs_conn_hash(ct);
+			}
+		}
 
 		/*
 		 * Simply decrease the refcnt of the template,
@@ -493,7 +504,8 @@ static void ip_vs_conn_expire(unsigned l
 	/*
 	 *	unhash it if it is hashed in the conn table
 	 */
-	ip_vs_conn_unhash(cp);
+	if (!ip_vs_conn_unhash(cp))
+		goto expire_later;
 
 	/*
 	 *	refcnt==1 implies I'm the only one referrer
diff -purN linux-post-2.6.5-rc2-20040323/net/ipv4/ipvs/ip_vs_ctl.c linux-post-2.6.5-rc2-20040326/net/ipv4/ipvs/ip_vs_ctl.c
--- linux-post-2.6.5-rc2-20040323/net/ipv4/ipvs/ip_vs_ctl.c	2004-03-16 19:50:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/ipv4/ipvs/ip_vs_ctl.c	2004-03-24 21:54:27.000000000 +0000
@@ -898,9 +898,16 @@ ip_vs_edit_dest(struct ip_vs_service *sv
 
 	__ip_vs_update_dest(svc, dest, udest);
 
+	write_lock_bh(&__ip_vs_svc_lock);
+
+	/* Wait until all other svc users go away */
+	while (atomic_read(&svc->usecnt) > 1) {};
+
 	/* call the update_service, because server weight may be changed */
 	svc->scheduler->update_service(svc);
 
+	write_unlock_bh(&__ip_vs_svc_lock);
+
 	LeaveFunction(2);
 
 	return 0;
diff -purN linux-post-2.6.5-rc2-20040323/net/ipv4/netfilter/Kconfig linux-post-2.6.5-rc2-20040326/net/ipv4/netfilter/Kconfig
--- linux-post-2.6.5-rc2-20040323/net/ipv4/netfilter/Kconfig	2004-01-14 00:26:15.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/ipv4/netfilter/Kconfig	2004-03-23 01:16:13.000000000 +0000
@@ -363,7 +363,7 @@ config IP_NF_NAT_LOCAL
 
 	  Please note that you will need a recent version (>= 1.2.6a)
 	  of the iptables userspace program in order to use this feature.
-	  See http://www.iptables.org/ for download instructions.
+	  See <http://www.iptables.org/> for download instructions.
 
 	  If unsure, say 'N'.
 
@@ -497,7 +497,7 @@ config IP_NF_TARGET_ULOG
 	  which can only be viewed through syslog.
 
 	  The apropriate userspace logging daemon (ulogd) may be obtained from
-	  http://www.gnumonks.org/projects/ulogd
+	  <http://www.gnumonks.org/projects/ulogd/>
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
diff -purN linux-post-2.6.5-rc2-20040323/net/ipv4/netfilter/ip_fw_compat_masq.c linux-post-2.6.5-rc2-20040326/net/ipv4/netfilter/ip_fw_compat_masq.c
--- linux-post-2.6.5-rc2-20040323/net/ipv4/netfilter/ip_fw_compat_masq.c	2004-01-28 23:59:33.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/ipv4/netfilter/ip_fw_compat_masq.c	2004-03-23 01:17:04.000000000 +0000
@@ -221,7 +221,7 @@ static const char *masq_proto_name(u_int
 	case IPPROTO_TCP: return "TCP";
 	case IPPROTO_UDP: return "UDP";
 	case IPPROTO_ICMP: return "ICMP";
-	default: return "MORE-CAFFIENE-FOR-RUSTY";
+	default: return "MORE-CAFFEINE-FOR-RUSTY";
 	}
 }
 
diff -purN linux-post-2.6.5-rc2-20040323/net/ipv4/netfilter/ipchains_core.c linux-post-2.6.5-rc2-20040326/net/ipv4/netfilter/ipchains_core.c
--- linux-post-2.6.5-rc2-20040323/net/ipv4/netfilter/ipchains_core.c	2003-08-24 12:00:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/ipv4/netfilter/ipchains_core.c	2004-03-23 01:17:40.000000000 +0000
@@ -101,6 +101,7 @@
 #include <linux/stat.h>
 
 MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Rusty Russell <rusty@rustcorp.com.au>");
 MODULE_DESCRIPTION("ipchains backwards compatibility layer");
 
 /* Understanding locking in this code: (thanks to Alan Cox for using
diff -purN linux-post-2.6.5-rc2-20040323/net/ipv4/tcp_diag.c linux-post-2.6.5-rc2-20040326/net/ipv4/tcp_diag.c
--- linux-post-2.6.5-rc2-20040323/net/ipv4/tcp_diag.c	2003-09-20 07:37:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/ipv4/tcp_diag.c	2004-03-24 21:48:43.000000000 +0000
@@ -167,10 +167,8 @@ static int tcpdiag_fill(struct sk_buff *
 			info->tcpi_snd_wscale = 0;
 			info->tcpi_rcv_wscale = 0;
 		}
-#ifdef CONFIG_INET_ECN
 		if (tp->ecn_flags&TCP_ECN_OK)
 			info->tcpi_options |= TCPI_OPT_ECN;
-#endif
 
 		info->tcpi_rto = (1000000*tp->rto)/HZ;
 		info->tcpi_ato = (1000000*tp->ack.ato)/HZ;
diff -purN linux-post-2.6.5-rc2-20040323/net/ipv4/tcp_input.c linux-post-2.6.5-rc2-20040326/net/ipv4/tcp_input.c
--- linux-post-2.6.5-rc2-20040323/net/ipv4/tcp_input.c	2004-03-15 23:39:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/ipv4/tcp_input.c	2004-03-24 21:48:43.000000000 +0000
@@ -77,11 +77,7 @@ int sysctl_tcp_window_scaling = 1;
 int sysctl_tcp_sack = 1;
 int sysctl_tcp_fack = 1;
 int sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;
-#ifdef CONFIG_INET_ECN
-int sysctl_tcp_ecn = 1;
-#else
 int sysctl_tcp_ecn;
-#endif
 int sysctl_tcp_dsack = 1;
 int sysctl_tcp_app_win = 31;
 int sysctl_tcp_adv_win_scale = 2;
diff -purN linux-post-2.6.5-rc2-20040323/net/ipv6/ip6_output.c linux-post-2.6.5-rc2-20040326/net/ipv6/ip6_output.c
--- linux-post-2.6.5-rc2-20040323/net/ipv6/ip6_output.c	2004-03-09 23:21:50.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/ipv6/ip6_output.c	2004-03-24 22:04:52.000000000 +0000
@@ -821,6 +821,9 @@ int ip6_append_data(struct sock *sk, int
 						       sk->sk_allocation);
 				if (unlikely(np->cork.opt == NULL))
 					return -ENOBUFS;
+			} else if (np->cork.opt->tot_len < opt->tot_len) {
+				printk(KERN_DEBUG "ip6_append_data: invalid option length\n");
+				return -EINVAL;
 			}
 			memcpy(np->cork.opt, opt, opt->tot_len);
 			inet->cork.flags |= IPCORK_OPT;
diff -purN linux-post-2.6.5-rc2-20040323/net/key/af_key.c linux-post-2.6.5-rc2-20040326/net/key/af_key.c
--- linux-post-2.6.5-rc2-20040323/net/key/af_key.c	2004-03-19 04:36:21.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/key/af_key.c	2004-03-24 22:18:34.000000000 +0000
@@ -1879,6 +1879,7 @@ static int pfkey_spdadd(struct sock *sk,
 		err = -EINVAL;
 		goto out;
 	}
+	xp->selector.family = xp->family;
 	xp->selector.prefixlen_s = sa->sadb_address_prefixlen;
 	xp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
 	xp->selector.sport = ((struct sockaddr_in *)(sa+1))->sin_port;
diff -purN linux-post-2.6.5-rc2-20040323/net/sched/sch_tbf.c linux-post-2.6.5-rc2-20040326/net/sched/sch_tbf.c
--- linux-post-2.6.5-rc2-20040323/net/sched/sch_tbf.c	2004-02-21 02:37:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/sched/sch_tbf.c	2004-03-24 21:56:54.000000000 +0000
@@ -62,7 +62,7 @@
 
 	Algorithm.
 	----------
-	
+
 	Let N(t_i) be B/R initially and N(t) grow continuously with time as:
 
 	N(t+delta) = min{B/R, N(t) + delta}
@@ -146,15 +146,15 @@ static int tbf_enqueue(struct sk_buff *s
 		if (sch->reshape_fail == NULL || sch->reshape_fail(skb, sch))
 #endif
 			kfree_skb(skb);
-	
+
 		return NET_XMIT_DROP;
 	}
-	
+
 	if ((ret = q->qdisc->enqueue(skb, q->qdisc)) != 0) {
 		sch->stats.drops++;
 		return ret;
-	}	
-	
+	}
+
 	sch->q.qlen++;
 	sch->stats.bytes += skb->len;
 	sch->stats.packets++;
@@ -165,10 +165,10 @@ static int tbf_requeue(struct sk_buff *s
 {
 	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
 	int ret;
-	
+
 	if ((ret = q->qdisc->ops->requeue(skb, q->qdisc)) == 0)
-		sch->q.qlen++; 
-	
+		sch->q.qlen++;
+
 	return ret;
 }
 
@@ -176,7 +176,7 @@ static unsigned int tbf_drop(struct Qdis
 {
 	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
 	unsigned int len;
-	
+
 	if ((len = q->qdisc->ops->drop(q->qdisc)) != 0) {
 		sch->q.qlen--;
 		sch->stats.drops++;
@@ -196,7 +196,7 @@ static struct sk_buff *tbf_dequeue(struc
 {
 	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
 	struct sk_buff *skb;
-	
+
 	skb = q->qdisc->dequeue(q->qdisc);
 
 	if (skb) {
@@ -204,7 +204,7 @@ static struct sk_buff *tbf_dequeue(struc
 		long toks;
 		long ptoks = 0;
 		unsigned int len = skb->len;
-		
+
 		PSCHED_GET_TIME(now);
 
 		toks = PSCHED_TDIFF_SAFE(now, q->t_c, q->buffer, 0);
@@ -248,13 +248,13 @@ static struct sk_buff *tbf_dequeue(struc
 		   This is the main idea of all FQ algorithms
 		   (cf. CSZ, HPFQ, HFSC)
 		 */
-		
+
 		if (q->qdisc->ops->requeue(skb, q->qdisc) != NET_XMIT_SUCCESS) {
-			/* When requeue fails skb is dropped */ 
+			/* When requeue fails skb is dropped */
 			sch->q.qlen--;
 			sch->stats.drops++;
-		}	
-		
+		}
+
 		sch->flags |= TCQ_F_THROTTLED;
 		sch->stats.overlimits++;
 	}
@@ -279,24 +279,24 @@ static struct Qdisc *tbf_create_dflt_qdi
 	struct Qdisc *q = qdisc_create_dflt(dev, &bfifo_qdisc_ops);
         struct rtattr *rta;
 	int ret;
-	
+
 	if (q) {
 		rta = kmalloc(RTA_LENGTH(sizeof(struct tc_fifo_qopt)), GFP_KERNEL);
 		if (rta) {
 			rta->rta_type = RTM_NEWQDISC;
 			rta->rta_len = RTA_LENGTH(sizeof(struct tc_fifo_qopt)); 
 			((struct tc_fifo_qopt *)RTA_DATA(rta))->limit = limit;
-			
+
 			ret = q->ops->change(q, rta);
 			kfree(rta);
-			
+
 			if (ret == 0)
 				return q;
 		}
 		qdisc_destroy(q);
 	}
 
-	return NULL;	
+	return NULL;
 }
 
 static int tbf_change(struct Qdisc* sch, struct rtattr *opt)
@@ -340,7 +340,7 @@ static int tbf_change(struct Qdisc* sch,
 	}
 	if (max_size < 0)
 		goto done;
-	
+
 	if (q->qdisc == &noop_qdisc) {
 		if ((child = tbf_create_dflt_qdisc(sch->dev, qopt->limit)) == NULL)
 			goto done;
@@ -369,17 +369,17 @@ done:
 static int tbf_init(struct Qdisc* sch, struct rtattr *opt)
 {
 	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
-	
+
 	if (opt == NULL)
 		return -EINVAL;
-	
+
 	PSCHED_GET_TIME(q->t_c);
 	init_timer(&q->wd_timer);
 	q->wd_timer.function = tbf_watchdog;
 	q->wd_timer.data = (unsigned long)sch;
 
 	q->qdisc = &noop_qdisc;
-	
+
 	return tbf_change(sch, opt);
 }
 
@@ -393,7 +393,7 @@ static void tbf_destroy(struct Qdisc *sc
 		qdisc_put_rtab(q->P_tab);
 	if (q->R_tab)
 		qdisc_put_rtab(q->R_tab);
-	
+
 	qdisc_destroy(q->qdisc);
 	q->qdisc = &noop_qdisc;
 }
@@ -404,10 +404,10 @@ static int tbf_dump(struct Qdisc *sch, s
 	unsigned char	 *b = skb->tail;
 	struct rtattr *rta;
 	struct tc_tbf_qopt opt;
-	
+
 	rta = (struct rtattr*)b;
 	RTA_PUT(skb, TCA_OPTIONS, 0, NULL);
-	
+
 	opt.limit = q->limit;
 	opt.rate = q->R_tab->rate;
 	if (q->P_tab)
@@ -427,15 +427,14 @@ rtattr_failure:
 }
 
 static int tbf_dump_class(struct Qdisc *sch, unsigned long cl,
-	       		  struct sk_buff *skb, struct tcmsg *tcm)
+			  struct sk_buff *skb, struct tcmsg *tcm)
 {
 	struct tbf_sched_data *q = (struct tbf_sched_data*)sch->data;
 
-	if (cl != 1) 	/* only one class */ 
+	if (cl != 1) 	/* only one class */
 		return -ENOENT;
-    
-	tcm->tcm_parent = TC_H_ROOT;
-	tcm->tcm_handle = 1;
+
+	tcm->tcm_handle |= TC_H_MIN(1);
 	tcm->tcm_info = q->qdisc->handle;
 
 	return 0;
@@ -449,12 +448,12 @@ static int tbf_graft(struct Qdisc *sch, 
 	if (new == NULL)
 		new = &noop_qdisc;
 
-	sch_tree_lock(sch);	
+	sch_tree_lock(sch);
 	*old = xchg(&q->qdisc, new);
 	qdisc_reset(*old);
 	sch->q.qlen = 0;
 	sch_tree_unlock(sch);
-	
+
 	return 0;
 }
 
@@ -474,7 +473,7 @@ static void tbf_put(struct Qdisc *sch, u
 }
 
 static int tbf_change_class(struct Qdisc *sch, u32 classid, u32 parentid, 
-			struct rtattr **tca, unsigned long *arg)
+			    struct rtattr **tca, unsigned long *arg)
 {
 	return -ENOSYS;
 }
@@ -486,11 +485,9 @@ static int tbf_delete(struct Qdisc *sch,
 
 static void tbf_walk(struct Qdisc *sch, struct qdisc_walker *walker)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
-
 	if (!walker->stop) {
-		if (walker->count >= walker->skip) 
-			if (walker->fn(sch, (unsigned long)q, walker) < 0) { 
+		if (walker->count >= walker->skip)
+			if (walker->fn(sch, 1, walker) < 0) {
 				walker->stop = 1;
 				return;
 			}
@@ -500,7 +497,7 @@ static void tbf_walk(struct Qdisc *sch, 
 
 static struct Qdisc_class_ops tbf_class_ops =
 {
-	.graft		= 	tbf_graft,
+	.graft		=	tbf_graft,
 	.leaf		=	tbf_leaf,
 	.get		=	tbf_get,
 	.put		=	tbf_put,
@@ -532,7 +529,7 @@ static int __init tbf_module_init(void)
 	return register_qdisc(&tbf_qdisc_ops);
 }
 
-static void __exit tbf_module_exit(void) 
+static void __exit tbf_module_exit(void)
 {
 	unregister_qdisc(&tbf_qdisc_ops);
 }
diff -purN linux-post-2.6.5-rc2-20040323/net/sctp/Kconfig linux-post-2.6.5-rc2-20040326/net/sctp/Kconfig
--- linux-post-2.6.5-rc2-20040323/net/sctp/Kconfig	2004-02-27 21:25:07.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/sctp/Kconfig	2004-03-23 18:58:14.000000000 +0000
@@ -5,14 +5,9 @@
 menu "SCTP Configuration (EXPERIMENTAL)"
 	depends on INET && EXPERIMENTAL
 
-config IPV6_SCTP__
-	tristate
-	default y if IPV6=n
-	default IPV6 if IPV6
-
 config IP_SCTP
 	tristate "The SCTP Protocol (EXPERIMENTAL)"
-	depends on IPV6_SCTP__
+	depends on IPV6 || IPV6=n
 	---help---
 	  Stream Control Transmission Protocol
 
@@ -61,6 +56,7 @@ config SCTP_DBG_OBJCNT
 choice
 	prompt "SCTP: Cookie HMAC Algorithm"
 	depends on IP_SCTP
+	default SCTP_HMAC_MD5
 	help
 	  HMAC algorithm to be used during association initialization.  It
 	  is strongly recommended to use HMAC-SHA1 or HMAC-MD5.  See 
diff -purN linux-post-2.6.5-rc2-20040323/net/sctp/sm_make_chunk.c linux-post-2.6.5-rc2-20040326/net/sctp/sm_make_chunk.c
--- linux-post-2.6.5-rc2-20040323/net/sctp/sm_make_chunk.c	2003-11-21 19:36:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/sctp/sm_make_chunk.c	2004-03-23 18:50:38.000000000 +0000
@@ -516,7 +516,7 @@ struct sctp_chunk *sctp_make_datafrag_em
 	 */
 	dp.tsn = 0;
 	dp.stream = htons(sinfo->sinfo_stream);
-	dp.ppid   = htonl(sinfo->sinfo_ppid);
+	dp.ppid   = sinfo->sinfo_ppid;
 
 	/* Set the flags for an unordered send.  */
 	if (sinfo->sinfo_flags & MSG_UNORDERED) {
diff -purN linux-post-2.6.5-rc2-20040323/net/sctp/ulpevent.c linux-post-2.6.5-rc2-20040326/net/sctp/ulpevent.c
--- linux-post-2.6.5-rc2-20040323/net/sctp/ulpevent.c	2003-07-16 18:09:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/sctp/ulpevent.c	2004-03-23 18:50:38.000000000 +0000
@@ -663,7 +663,7 @@ struct sctp_ulpevent *sctp_ulpevent_make
 	 * for and this information is passed opaquely by the SCTP stack from
 	 * one end to the other.
 	 */
-	info->sinfo_ppid = ntohl(chunk->subh.data_hdr->ppid);
+	info->sinfo_ppid = chunk->subh.data_hdr->ppid;
 
 	/* Sockets API Extensions for SCTP
 	 * Section 5.2.2 SCTP Header Information Structure (SCTP_SNDRCV)
diff -purN linux-post-2.6.5-rc2-20040323/net/xfrm/xfrm_user.c linux-post-2.6.5-rc2-20040326/net/xfrm/xfrm_user.c
--- linux-post-2.6.5-rc2-20040323/net/xfrm/xfrm_user.c	2004-02-25 08:15:07.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/net/xfrm/xfrm_user.c	2004-03-24 22:18:34.000000000 +0000
@@ -674,6 +674,7 @@ static int copy_to_user_tmpl(struct xfrm
 		struct xfrm_tmpl *kp = &xp->xfrm_vec[i];
 
 		memcpy(&up->id, &kp->id, sizeof(up->id));
+		up->family = xp->family;
 		memcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));
 		up->reqid = kp->reqid;
 		up->mode = kp->mode;
diff -purN linux-post-2.6.5-rc2-20040323/sound/oss/Kconfig linux-post-2.6.5-rc2-20040326/sound/oss/Kconfig
--- linux-post-2.6.5-rc2-20040323/sound/oss/Kconfig	2004-01-13 20:23:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/sound/oss/Kconfig	2004-03-23 10:05:26.000000000 +0000
@@ -1153,3 +1153,11 @@ config SOUND_AD1980
 	tristate "AD1980 front/back switch plugin"
 	depends on SOUND_PRIME!=n
 
+config SOUND_SH_DAC_AUDIO
+	tristate "SuperH DAC audio support"
+	depends on SOUND_PRIME!=n && SOUND && CPU_SH3
+
+config SOUND_SH_DAC_AUDIO_CHANNEL
+	int "    DAC channel"
+	default "1"
+	depends on SOUND_SH_DAC_AUDIO
diff -purN linux-post-2.6.5-rc2-20040323/sound/oss/Makefile linux-post-2.6.5-rc2-20040326/sound/oss/Makefile
--- linux-post-2.6.5-rc2-20040323/sound/oss/Makefile	2004-03-07 07:17:44.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/sound/oss/Makefile	2004-03-23 10:05:26.000000000 +0000
@@ -10,6 +10,7 @@ obj-$(CONFIG_SOUND_CS4232)	+= cs4232.o a
 
 # Please leave it as is, cause the link order is significant !
 
+obj-$(CONFIG_SOUND_SH_DAC_AUDIO)	+= sh_dac_audio.o
 obj-$(CONFIG_SOUND_HAL2)	+= hal2.o
 obj-$(CONFIG_SOUND_AEDSP16)	+= aedsp16.o
 obj-$(CONFIG_SOUND_PSS)		+= pss.o ad1848.o mpu401.o
diff -purN linux-post-2.6.5-rc2-20040323/sound/oss/sh_dac_audio.c linux-post-2.6.5-rc2-20040326/sound/oss/sh_dac_audio.c
--- linux-post-2.6.5-rc2-20040323/sound/oss/sh_dac_audio.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040326/sound/oss/sh_dac_audio.c	2004-03-23 10:05:26.000000000 +0000
@@ -0,0 +1,325 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/version.h>
+#include <linux/linkage.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/delay.h>
+#include <linux/interrupt.h>
+
+#include <asm/cpu/dac.h>
+
+#ifdef MACH_HP600
+#include <asm/hp6xx/hp6xx.h>
+#include <asm/hd64461/hd64461.h>
+#endif
+
+#define MODNAME "sh_dac_audio"
+
+#define TMU_TOCR_INIT	0x00
+
+#define TMU1_TCR_INIT	0x0020	/* Clock/4, rising edge; interrupt on */
+#define TMU1_TSTR_INIT  0x02	/* Bit to turn on TMU1 */
+
+#define TMU_TSTR	0xfffffe92
+#define TMU1_TCOR	0xfffffea0
+#define TMU1_TCNT	0xfffffea4
+#define TMU1_TCR	0xfffffea8
+
+#define BUFFER_SIZE 48000
+
+static int rate;
+static int empty;
+static char *data_buffer, *buffer_begin, *buffer_end;
+static int in_use, device_major;
+
+static void dac_audio_start_timer(void)
+{
+	u8 tstr;
+
+	tstr = ctrl_inb(TMU_TSTR);
+	tstr |= TMU1_TSTR_INIT;
+	ctrl_outb(tstr, TMU_TSTR);
+}
+
+static void dac_audio_stop_timer(void)
+{
+	u8 tstr;
+
+	tstr = ctrl_inb(TMU_TSTR);
+	tstr &= ~TMU1_TSTR_INIT;
+	ctrl_outb(tstr, TMU_TSTR);
+}
+
+static void dac_audio_reset(void)
+{
+	dac_audio_stop_timer();
+	buffer_begin = buffer_end = data_buffer;
+	empty = 1;
+}
+
+static void dac_audio_sync(void)
+{
+	while (!empty)
+		schedule();
+}
+
+static void dac_audio_start(void)
+{
+#ifdef MACH_HP600
+	u16 v;
+	v = inw(HD64461_GPADR);
+	v &= ~HD64461_GPADR_SPEAKER;
+	outw(v, HD64461_GPADR);
+#endif
+	sh_dac_enable(CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL);
+	ctrl_outw(TMU1_TCR_INIT, TMU1_TCR);
+}
+static void dac_audio_stop(void)
+{
+#ifdef MACH_HP600
+	u16 v;
+#endif
+	dac_audio_stop_timer();
+#ifdef MACH_HP600
+	v = inw(HD64461_GPADR);
+	v |= HD64461_GPADR_SPEAKER;
+	outw(v, HD64461_GPADR);
+#endif
+	sh_dac_disable(CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL);
+}
+
+static void dac_audio_set_rate(void)
+{
+	unsigned long interval;
+
+	interval = (current_cpu_data.module_clock / 4) / rate;
+	ctrl_outl(interval, TMU1_TCOR);
+	ctrl_outl(interval, TMU1_TCNT);
+}
+
+static int dac_audio_ioctl(struct inode *inode, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	int val;
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, (int *)arg);
+
+	case SNDCTL_DSP_SYNC:
+		dac_audio_sync();
+		return 0;
+
+	case SNDCTL_DSP_RESET:
+		dac_audio_reset();
+		return 0;
+
+	case SNDCTL_DSP_GETFMTS:
+		return put_user(AFMT_U8, (int *)arg);
+
+	case SNDCTL_DSP_SETFMT:
+		return put_user(AFMT_U8, (int *)arg);
+
+	case SNDCTL_DSP_NONBLOCK:
+		file->f_flags |= O_NONBLOCK;
+		return 0;
+
+	case SNDCTL_DSP_GETCAPS:
+		return 0;
+
+	case SOUND_PCM_WRITE_RATE:
+		val = *(int *)arg;
+		if (val > 0) {
+			rate = val;
+			dac_audio_set_rate();
+		}
+		return put_user(rate, (int *)arg);
+
+	case SNDCTL_DSP_STEREO:
+		return put_user(0, (int *)arg);
+
+	case SOUND_PCM_WRITE_CHANNELS:
+		return put_user(1, (int *)arg);
+
+	case SNDCTL_DSP_SETDUPLEX:
+		return -EINVAL;
+
+	case SNDCTL_DSP_PROFILE:
+		return -EINVAL;
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		return put_user(BUFFER_SIZE, (int *)arg);
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		return 0;
+
+	default:
+		printk(KERN_ERR "sh_dac_audio: unimplemented ioctl=0x%x\n",
+		       cmd);
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+static ssize_t dac_audio_write(struct file *file, const char *buf, size_t count,
+			       loff_t * ppos)
+{
+	int free;
+	int nbytes;
+
+	if (count < 0)
+		return -EINVAL;
+
+	if (!count) {
+		dac_audio_sync();
+		return 0;
+	}
+
+	free = buffer_begin - buffer_end;
+
+	if (free < 0)
+		free += BUFFER_SIZE;
+	if ((free == 0) && (empty))
+		free = BUFFER_SIZE;
+	if (count > free)
+		count = free;
+	if (buffer_begin > buffer_end) {
+		if (copy_from_user((void *)buffer_end, buf, count))
+			return -EFAULT;
+
+		buffer_end += count;
+	} else {
+		nbytes = data_buffer + BUFFER_SIZE - buffer_end;
+		if (nbytes > count) {
+			if (copy_from_user((void *)buffer_end, buf, count))
+				return -EFAULT;
+			buffer_end += count;
+		} else {
+			if (copy_from_user((void *)buffer_end, buf, nbytes))
+				return -EFAULT;
+			if (copy_from_user
+			    ((void *)data_buffer, buf + nbytes, count - nbytes))
+				return -EFAULT;
+			buffer_end = data_buffer + count - nbytes;
+		}
+	}
+
+	if (empty) {
+		empty = 0;
+		dac_audio_start_timer();
+	}
+
+	return count;
+}
+
+static ssize_t dac_audio_read(struct file *file, char *buf, size_t count,
+			      loff_t * ppos)
+{
+	return -EINVAL;
+}
+
+static int dac_audio_open(struct inode *inode, struct file *file)
+{
+	if (file->f_mode & FMODE_READ)
+		return -ENODEV;
+	if (in_use)
+		return -EBUSY;
+
+	in_use = 1;
+
+	dac_audio_start();
+
+	return 0;
+}
+
+static int dac_audio_release(struct inode *inode, struct file *file)
+{
+	dac_audio_sync();
+	dac_audio_stop();
+	in_use = 0;
+
+	return 0;
+}
+
+struct file_operations dac_audio_fops = {
+      .read =		dac_audio_read,
+      .write =	dac_audio_write,
+      .ioctl =	dac_audio_ioctl,
+      .open =		dac_audio_open,
+      .release =	dac_audio_release,
+};
+
+static irqreturn_t timer1_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	unsigned long timer_status;
+
+	timer_status = ctrl_inw(TMU1_TCR);
+	timer_status &= ~0x100;
+	ctrl_outw(timer_status, TMU1_TCR);
+
+	if (!empty) {
+		sh_dac_output(*buffer_begin, CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL);
+		buffer_begin++;
+
+		if (buffer_begin == data_buffer + BUFFER_SIZE)
+			buffer_begin = data_buffer;
+		if (buffer_begin == buffer_end) {
+			empty = 1;
+			dac_audio_stop_timer();
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static int __init dac_audio_init(void)
+{
+	int retval;
+
+	if ((device_major = register_sound_dsp(&dac_audio_fops, -1)) < 0) {
+		printk(KERN_ERR "Cannot register dsp device");
+		return device_major;
+	}
+
+	in_use = 0;
+
+	data_buffer = (char *)kmalloc(BUFFER_SIZE, GFP_KERNEL);
+	if (data_buffer == NULL)
+		return -ENOMEM;
+
+	dac_audio_reset();
+	rate = 8000;
+	dac_audio_set_rate();
+
+	retval =
+	    request_irq(TIMER1_IRQ, timer1_interrupt, SA_INTERRUPT, MODNAME, 0);
+	if (retval < 0) {
+		printk(KERN_ERR "sh_dac_audio: IRQ %d request failed\n",
+		       TIMER1_IRQ);
+		return retval;
+	}
+
+	return 0;
+}
+
+static void __exit dac_audio_exit(void)
+{
+	free_irq(TIMER1_IRQ, 0);
+
+	unregister_sound_dsp(device_major);
+	kfree((void *)data_buffer);
+}
+
+module_init(dac_audio_init);
+module_exit(dac_audio_exit);
+
+MODULE_AUTHOR("Andriy Skulysh, askulysh@image.kiev.ua");
+MODULE_DESCRIPTION("SH DAC sound driver");
+MODULE_LICENSE("GPL");
