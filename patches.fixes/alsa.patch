diff -ruN linux-2.5-plain/Documentation/sound/alsa/ALSA-Configuration.txt linux-sound-plain/Documentation/sound/alsa/ALSA-Configuration.txt
--- linux-2.5-plain/Documentation/sound/alsa/ALSA-Configuration.txt	2004-03-15 13:28:16.000000000 +0100
+++ linux-sound-plain/Documentation/sound/alsa/ALSA-Configuration.txt	2004-03-15 13:40:18.000000000 +0100
@@ -755,8 +755,10 @@
 
     port	- port number or -1 (disable)
     irq		- IRQ number or -1 (disable)
+    acpipnp	- ACPI PnP detection - 0 = disable, 1 = enable (default)
 
-    Module supports multiple devices (max 8).
+    Module supports multiple devices (max 8) and ACPI PnP.  If PnP is not
+    used (or ACPI not enabled), port and irq must be specified.
     
   Module snd-mtpav
   ----------------
diff -ruN linux-2.5-plain/include/sound/ac97_codec.h linux-sound-plain/include/sound/ac97_codec.h
--- linux-2.5-plain/include/sound/ac97_codec.h	2004-03-15 13:30:26.000000000 +0100
+++ linux-sound-plain/include/sound/ac97_codec.h	2004-03-15 13:42:31.000000000 +0100
@@ -226,10 +226,14 @@
 #define AC97_GPIO_LINE2_HL1R    0x8000  /* Opt./ Handset to Line2 relay control (out) */
 
 /* specific - SigmaTel */
+#define AC97_SIGMATEL_OUTSEL	0x64	/* Output Select, STAC9758 */
+#define AC97_SIGMATEL_INSEL	0x66	/* Input Select, STAC9758 */
+#define AC97_SIGMATEL_IOMISC	0x68	/* STAC9758 */
 #define AC97_SIGMATEL_ANALOG	0x6c	/* Analog Special */
 #define AC97_SIGMATEL_DAC2INVERT 0x6e
 #define AC97_SIGMATEL_BIAS1	0x70
 #define AC97_SIGMATEL_BIAS2	0x72
+#define AC97_SIGMATEL_VARIOUS	0x72	/* STAC9758 */
 #define AC97_SIGMATEL_MULTICHN	0x74	/* Multi-Channel programming */
 #define AC97_SIGMATEL_CIC1	0x76
 #define AC97_SIGMATEL_CIC2	0x78
diff -ruN linux-2.5-plain/sound/drivers/mpu401/mpu401.c linux-sound-plain/sound/drivers/mpu401/mpu401.c
--- linux-2.5-plain/sound/drivers/mpu401/mpu401.c	2004-03-15 13:31:20.000000000 +0100
+++ linux-sound-plain/sound/drivers/mpu401/mpu401.c	2004-03-15 13:43:29.000000000 +0100
@@ -2,6 +2,12 @@
  *  Driver for generic MPU-401 boards (UART mode only)
  *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
  *
+ *  ACPI PnP Copyright (c) 2004 by Clemens Ladisch <clemens@ladisch.de>
+ *  based on 8250_acpi.c
+ *  Copyright (c) 2002-2003 Matthew Wilcox for Hewlett-Packard
+ *  Copyright (C) 2004 Hewlett-Packard Co
+ *       Bjorn Helgaas <bjorn.helgaas@hp.com>
+ *
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -21,14 +27,17 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/wait.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
+#ifdef CONFIG_ACPI_BUS
+#include <acpi/acpi_bus.h>
+#endif
 #include <sound/core.h>
 #include <sound/mpu401.h>
 #define SNDRV_GET_ID
 #include <sound/initval.h>
-#include <linux/delay.h>
+
+#ifdef CONFIG_ACPI_BUS
+#define USE_ACPI_PNP
+#endif
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("MPU-401 UART");
@@ -38,6 +47,9 @@
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;	/* Enable this card */
+#ifdef USE_ACPI_PNP
+static int acpipnp[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 1 };
+#endif
 static long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;	/* MPU-401 port number */
 static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* MPU-401 IRQ */
 #ifdef CONFIG_X86_PC9800
@@ -53,6 +65,11 @@
 MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(enable, "Enable MPU-401 device.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
+#ifdef USE_ACPI_PNP
+MODULE_PARM(acpipnp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+MODULE_PARM_DESC(acpipnp, "ACPI PnP detection for MPU-401 device.");
+MODULE_PARM_SYNTAX(acpipnp, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
+#endif
 MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
 MODULE_PARM_DESC(port, "Port # for MPU-401 device.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
@@ -65,25 +82,107 @@
 MODULE_PARM_SYNTAX(pc98ii, SNDRV_BOOLEAN_FALSE_DESC);
 #endif
 
-static snd_card_t *snd_mpu401_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
+#ifndef CONFIG_ACPI_BUS
+struct acpi_device;
+#endif
+
+static snd_card_t *snd_mpu401_legacy_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
+
+#ifdef USE_ACPI_PNP
+
+struct mpu401_resources {
+	unsigned long port;
+	int irq;
+};
 
-static int __init snd_card_mpu401_probe(int dev)
+static acpi_status __devinit snd_mpu401_acpi_resource(struct acpi_resource *res,
+						      void *data)
+{
+	struct mpu401_resources *resources = (struct mpu401_resources *)data;
+
+	if (res->id == ACPI_RSTYPE_IRQ) {
+		if (res->data.irq.number_of_interrupts > 0) {
+#ifdef CONFIG_IA64
+			resources->irq = acpi_register_irq(res->data.irq.interrupts[0],
+							   res->data.irq.active_high_low,
+							   res->data.irq.edge_level);
+#else
+			resources->irq = res->data.irq.interrupts[0];
+#endif
+		}
+	} else if (res->id == ACPI_RSTYPE_IO) {
+		if (res->data.io.range_length >= 2) {
+			resources->port = res->data.io.min_base_address;
+		}
+	}
+	return AE_OK;
+}
+
+static int __devinit snd_mpu401_acpi_pnp(int dev, struct acpi_device *device)
+{
+	struct mpu401_resources res;
+	acpi_status status;
+
+	res.port = SNDRV_AUTO_PORT;
+	res.irq = SNDRV_AUTO_IRQ;
+	status = acpi_walk_resources(device->handle, METHOD_NAME__CRS,
+				     snd_mpu401_acpi_resource, &res);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+	if (res.port == SNDRV_AUTO_PORT || res.irq == SNDRV_AUTO_IRQ) {
+		snd_printk(KERN_ERR "no port or irq in %s _CRS\n",
+			   acpi_device_bid(device));
+		return -ENODEV;
+	}
+	port[dev] = res.port;
+	irq[dev] = res.irq;
+	return 0;
+}
+
+#endif /* USE_ACPI_PNP */
+
+static int __devinit snd_card_mpu401_probe(int dev, struct acpi_device *device)
 {
 	snd_card_t *card;
 	int err;
 
-	if (port[dev] == SNDRV_AUTO_PORT) {
-		snd_printk("specify port\n");
-		return -EINVAL;
-	}
-	if (irq[dev] == SNDRV_AUTO_IRQ) {
-		snd_printk("specify or disable IRQ port\n");
-		return -EINVAL;
+#ifdef USE_ACPI_PNP
+	if (!device) {
+#endif
+		if (port[dev] == SNDRV_AUTO_PORT) {
+			snd_printk(KERN_ERR "specify port\n");
+			return -EINVAL;
+		}
+		if (irq[dev] == SNDRV_AUTO_IRQ) {
+			snd_printk(KERN_ERR "specify or disable IRQ port\n");
+			return -EINVAL;
+		}
+#ifdef USE_ACPI_PNP
 	}
+#endif
+
+#ifdef USE_ACPI_PNP
+	if (device && (err = snd_mpu401_acpi_pnp(dev, device)) < 0)
+		return err;
+#endif
 
 	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
 	if (card == NULL)
 		return -ENOMEM;
+	strcpy(card->driver, "MPU-401 UART");
+	strcpy(card->shortname, card->driver);
+	sprintf(card->longname, "%s at 0x%lx, ", card->shortname, port[dev]);
+	if (irq[dev] >= 0) {
+		sprintf(card->longname + strlen(card->longname), "IRQ %d", irq[dev]);
+	} else {
+		strcat(card->longname, "polled");
+	}
+#ifdef USE_ACPI_PNP
+	if (device) {
+		strcat(card->longname, ", bus id ");
+		strlcat(card->longname, acpi_device_bid(device), sizeof(card->longname));
+	}
+#endif
 	if (snd_mpu401_uart_new(card, 0,
 #ifdef CONFIG_X86_PC9800
 				pc98ii[dev] ? MPU401_HW_PC98II :
@@ -95,22 +194,67 @@
 		snd_card_free(card);
 		return -ENODEV;
 	}
-	strcpy(card->driver, "MPU-401 UART");
-	strcpy(card->shortname, card->driver);
-	sprintf(card->longname, "%s at 0x%lx, ", card->shortname, port[dev]);
-	if (irq[dev] >= 0) {
-		sprintf(card->longname + strlen(card->longname), "IRQ %d", irq[dev]);
-	} else {
-		strcat(card->longname, "polled");
-	}
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
-	snd_mpu401_cards[dev] = card;
+#ifdef USE_ACPI_PNP
+	if (device)
+		acpi_driver_data(device) = card;
+	else
+#endif
+		snd_mpu401_legacy_cards[dev] = card;
 	return 0;
 }
 
+#ifdef USE_ACPI_PNP
+
+static int __devinit snd_mpu401_acpi_add(struct acpi_device *device)
+{
+	static int dev;
+	int err;
+
+	for ( ; dev < SNDRV_CARDS; ++dev) {
+		if (!enable[dev] || !acpipnp[dev])
+			continue;
+		err = snd_card_mpu401_probe(dev, device);
+		if (err < 0)
+			return err;
+		++dev;
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static int __devexit snd_mpu401_acpi_remove(struct acpi_device *device,
+					    int type)
+{
+	snd_card_t *card;
+
+	if (!device)
+		return -EINVAL;
+	card = (snd_card_t *)acpi_driver_data(device);
+	if (!card)
+		return -EINVAL;
+
+	snd_card_disconnect(card);
+	snd_card_free_in_thread(card);
+	acpi_driver_data(device) = NULL;
+	return 0;
+}
+
+static struct acpi_driver snd_mpu401_acpi_driver = {
+	.name = "MPU-401 Driver",
+	.class = "mpu401",
+	.ids = "PNPB006",
+	.ops = {
+		.add = snd_mpu401_acpi_add,
+		.remove = __devexit_p(snd_mpu401_acpi_remove),
+	},
+};
+
+#endif /* USE_ACPI_PNP */
+
 static int __init alsa_card_mpu401_init(void)
 {
 	int dev, cards = 0;
@@ -118,13 +262,25 @@
 	for (dev = 0; dev < SNDRV_CARDS; dev++) {
 		if (!enable[dev])
 			continue;
-		if (snd_card_mpu401_probe(dev) >= 0)
+#ifdef USE_ACPI_PNP
+		if (acpipnp[dev] && !acpi_disabled)
+			continue;
+#endif
+		if (snd_card_mpu401_probe(dev, NULL) >= 0)
 			cards++;
 	}
+#ifdef USE_ACPI_PNP
+	if (!acpi_disabled)
+		cards += acpi_bus_register_driver(&snd_mpu401_acpi_driver);
+#endif
 	if (!cards) {
 #ifdef MODULE
 		printk(KERN_ERR "MPU-401 device not found or device busy\n");
 #endif
+#ifdef USE_ACPI_PNP
+		if (!acpi_disabled)
+			acpi_bus_unregister_driver(&snd_mpu401_acpi_driver);
+#endif
 		return -ENODEV;
 	}
 	return 0;
@@ -134,8 +290,12 @@
 {
 	int idx;
 
+#ifdef USE_ACPI_PNP
+	if (!acpi_disabled)
+		acpi_bus_unregister_driver(&snd_mpu401_acpi_driver);
+#endif
 	for (idx = 0; idx < SNDRV_CARDS; idx++)
-		snd_card_free(snd_mpu401_cards[idx]);
+		snd_card_free(snd_mpu401_legacy_cards[idx]);
 }
 
 module_init(alsa_card_mpu401_init)
@@ -143,22 +303,28 @@
 
 #ifndef MODULE
 
-/* format is: snd-mpu401=enable,index,id,port,irq */
+/* format is: snd-mpu401=enable,index,id,acpipnp[,pc98ii],port,irq */
 
 static int __init alsa_card_mpu401_setup(char *str)
 {
 	static unsigned __initdata nr_dev = 0;
+	int __attribute__ ((__unused__)) pnp = INT_MAX;
 
 	if (nr_dev >= SNDRV_CARDS)
 		return 0;
 	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
 	       get_option(&str,&index[nr_dev]) == 2 &&
 	       get_id(&str,&id[nr_dev]) == 2 &&
+	       get_option(&str,&pnp) == 2 &&
 #ifdef CONFIG_X86_PC9800
 	       get_option(&str,&pc98ii[nr_dev]) == 2 &&
 #endif
 	       get_option_long(&str,&port[nr_dev]) == 2 &&
 	       get_option(&str,&irq[nr_dev]) == 2);
+#ifdef USE_ACPI_PNP
+	if (pnp != INT_MAX)
+		acpipnp[nr_dev] = pnp;
+#endif
 	nr_dev++;
 	return 1;
 }
diff -ruN linux-2.5-plain/sound/pci/ac97/ac97_codec.c linux-sound-plain/sound/pci/ac97/ac97_codec.c
--- linux-2.5-plain/sound/pci/ac97/ac97_codec.c	2004-03-15 13:29:33.000000000 +0100
+++ linux-sound-plain/sound/pci/ac97/ac97_codec.c	2004-03-15 13:41:37.000000000 +0100
@@ -171,6 +171,7 @@
 { 0x83847650, 0xffffffff, "STAC9750/51",	NULL,		NULL },	// patch?
 { 0x83847652, 0xffffffff, "STAC9752/53",	NULL,		NULL }, // patch?
 { 0x83847656, 0xffffffff, "STAC9756/57",	patch_sigmatel_stac9756,	NULL },
+{ 0x83847658, 0xffffffff, "STAC9758/59",	patch_sigmatel_stac9758,	NULL },
 { 0x83847666, 0xffffffff, "STAC9766/67",	NULL,		NULL }, // patch?
 { 0, 	      0,	  NULL,			NULL,		NULL }
 };
diff -ruN linux-2.5-plain/sound/pci/ac97/ac97_patch.c linux-sound-plain/sound/pci/ac97/ac97_patch.c
--- linux-2.5-plain/sound/pci/ac97/ac97_patch.c	2004-03-15 13:32:24.000000000 +0100
+++ linux-sound-plain/sound/pci/ac97/ac97_patch.c	2004-03-15 13:44:36.000000000 +0100
@@ -447,6 +447,21 @@
 	return 0;
 }
 
+int patch_sigmatel_stac9758(ac97_t * ac97)
+{
+	// patch for SigmaTel
+	ac97->build_ops = &patch_sigmatel_stac9700_ops;
+	// turn on stereo speaker, headphone and line-out
+	snd_ac97_write_cache(ac97, AC97_SIGMATEL_OUTSEL, 0x9040);
+	// headphone select and boost
+	snd_ac97_write_cache(ac97, AC97_SIGMATEL_IOMISC, 0x2102);
+	// enable mic
+	snd_ac97_write_cache(ac97, AC97_SIGMATEL_INSEL, 0x0203);
+	// enable stereo mic
+	snd_ac97_write_cache(ac97, AC97_SIGMATEL_VARIOUS, 0x0001);
+	return 0;
+}
+
 /*
  * Cirrus Logic CS42xx codecs
  */
diff -ruN linux-2.5-plain/sound/pci/ac97/ac97_patch.h linux-sound-plain/sound/pci/ac97/ac97_patch.h
--- linux-2.5-plain/sound/pci/ac97/ac97_patch.h	2004-03-15 13:27:55.000000000 +0100
+++ linux-sound-plain/sound/pci/ac97/ac97_patch.h	2004-03-15 13:39:54.000000000 +0100
@@ -34,6 +34,7 @@
 int patch_sigmatel_stac9721(ac97_t * ac97);
 int patch_sigmatel_stac9744(ac97_t * ac97);
 int patch_sigmatel_stac9756(ac97_t * ac97);
+int patch_sigmatel_stac9758(ac97_t * ac97);
 int patch_cirrus_cs4299(ac97_t * ac97);
 int patch_cirrus_spdif(ac97_t * ac97);
 int patch_conexant(ac97_t * ac97);
diff -ruN linux-2.5-plain/sound/pci/au88x0/au88x0_a3d.c linux-sound-plain/sound/pci/au88x0/au88x0_a3d.c
--- linux-2.5-plain/sound/pci/au88x0/au88x0_a3d.c	2004-03-15 13:30:20.000000000 +0100
+++ linux-sound-plain/sound/pci/au88x0/au88x0_a3d.c	2004-03-15 13:42:25.000000000 +0100
@@ -562,7 +562,7 @@
 	a3dsrc_SetA3DSampleRate(a3dsrc, 0x11);
 }
 
-int Vort3DRend_Initialize(vortex_t * v, unsigned short mode)
+static int Vort3DRend_Initialize(vortex_t * v, unsigned short mode)
 {
 	v->xt_mode = mode;	/* this_14 */
 
diff -ruN linux-2.5-plain/sound/pci/au88x0/au88x0.c linux-sound-plain/sound/pci/au88x0/au88x0.c
--- linux-2.5-plain/sound/pci/au88x0/au88x0.c	2004-03-15 13:30:20.000000000 +0100
+++ linux-sound-plain/sound/pci/au88x0/au88x0.c	2004-03-15 13:42:24.000000000 +0100
@@ -71,6 +71,8 @@
 static void __devinit snd_vortex_workaround(struct pci_dev *vortex, int fix)
 {
 	struct pci_dev *via = NULL;
+	int rc;
+
 	/* autodetect if workarounds are required */
 	while ((via = pci_find_device(PCI_VENDOR_ID_VIA,
 				      PCI_DEVICE_ID_VIA_8365_1, via))) {
@@ -86,8 +88,6 @@
 	if (fix == 255)
 		return;
 
-	int rc;
-
 	/* fix vortex latency */
 	if (fix & 0x01) {
 		if (!(rc = pci_write_config_byte(vortex, 0x40, 0xff))) {
diff -ruN linux-2.5-plain/sound/pci/au88x0/au88x0_core.c linux-sound-plain/sound/pci/au88x0/au88x0_core.c
--- linux-2.5-plain/sound/pci/au88x0/au88x0_core.c	2004-03-15 13:32:25.000000000 +0100
+++ linux-sound-plain/sound/pci/au88x0/au88x0_core.c	2004-03-15 13:44:37.000000000 +0100
@@ -82,8 +82,8 @@
 /*  MIXER (CAsp4Mix.s and CAsp4Mixer.s) */
 
 // FIXME: get rid of this.
-int mchannels[NR_MIXIN];
-int rampchs[NR_MIXIN];
+static int mchannels[NR_MIXIN];
+static int rampchs[NR_MIXIN];
 
 static void vortex_mixer_en_sr(vortex_t * vortex, int channel)
 {
diff -ruN linux-2.5-plain/sound/pci/au88x0/au88x0_game.c linux-sound-plain/sound/pci/au88x0/au88x0_game.c
--- linux-2.5-plain/sound/pci/au88x0/au88x0_game.c	2004-03-15 13:28:22.000000000 +0100
+++ linux-sound-plain/sound/pci/au88x0/au88x0_game.c	2004-03-15 13:40:24.000000000 +0100
@@ -37,6 +37,8 @@
 #include "au88x0.h"
 #include <linux/gameport.h>
 
+#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+
 #define VORTEX_GAME_DWAIT	20	/* 20 ms */
 
 static struct gameport gameport;
@@ -119,3 +121,10 @@
 		gameport_unregister_port(vortex->gameport);
 	return 0;
 }
+
+#else
+
+static inline int vortex_gameport_register(vortex_t * vortex) { return 0; }
+static inline int vortex_gameport_unregister(vortex_t * vortex) { return 0; }
+
+#endif
diff -ruN linux-2.5-plain/sound/pci/intel8x0.c linux-sound-plain/sound/pci/intel8x0.c
--- linux-2.5-plain/sound/pci/intel8x0.c	2004-03-15 13:30:49.000000000 +0100
+++ linux-sound-plain/sound/pci/intel8x0.c	2004-03-15 13:42:55.000000000 +0100
@@ -55,6 +55,8 @@
 		"{Intel,82801CA-ICH3},"
 		"{Intel,82801DB-ICH4},"
 		"{Intel,ICH5},"
+		"{Intel,ICH6},"
+		"{Intel,6300ESB},"
 		"{Intel,MX440},"
 		"{SiS,SI7012},"
 		"{NVidia,nForce Audio},"
@@ -96,7 +98,7 @@
 MODULE_PARM_SYNTAX(ac97_clock, SNDRV_ENABLED ",default:0");
 MODULE_PARM(ac97_quirk, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(ac97_quirk, "AC'97 workaround for strange hardware.");
-MODULE_PARM_SYNTAX(ac97_quirk, SNDRV_ENABLED ",allows:{{-1,3}},dialog:list,default:-1");
+MODULE_PARM_SYNTAX(ac97_quirk, SNDRV_ENABLED ",allows:{{-1,4}},dialog:list,default:-1");
 #ifdef SUPPORT_JOYSTICK
 MODULE_PARM(joystick, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(joystick, "Enable joystick for Intel i8x0 soundcard.");
@@ -131,6 +133,12 @@
 #ifndef PCI_DEVICE_ID_INTEL_ICH5
 #define PCI_DEVICE_ID_INTEL_ICH5	0x24d5
 #endif
+#ifndef PCI_DEVICE_ID_INTEL_ESB_5
+#define PCI_DEVICE_ID_INTEL_ESB_5	0x25a6
+#endif
+#ifndef PCI_DEVICE_ID_INTEL_ICH6_3
+#define PCI_DEVICE_ID_INTEL_ICH6_3	0x266e
+#endif
 #ifndef PCI_DEVICE_ID_SI_7012
 #define PCI_DEVICE_ID_SI_7012		0x7012
 #endif
@@ -198,6 +206,11 @@
 
 /* global block */
 #define ICH_REG_GLOB_CNT		0x2c	/* dword - global control */
+#define   ICH_PCM_SPDIF_MASK	0xc0000000	/* s/pdif pcm slot mask (ICH4) */
+#define   ICH_PCM_SPDIF_NONE	0x00000000	/* reserved - undefined */
+#define   ICH_PCM_SPDIF_78	0x40000000	/* s/pdif pcm on slots 7&8 */
+#define   ICH_PCM_SPDIF_69	0x80000000	/* s/pdif pcm on slots 6&9 */
+#define   ICH_PCM_SPDIF_1011	0xc0000000	/* s/pdif pcm on slots 10&11 */
 #define   ICH_PCM_20BIT		0x00400000	/* 20-bit samples (ICH4) */
 #define   ICH_PCM_246_MASK	0x00300000	/* 6 channels (not all chips) */
 #define   ICH_PCM_6		0x00200000	/* 6 channels (not all chips) */
@@ -442,6 +455,8 @@
 	{ 0x8086, 0x2485, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL },	/* ICH3 */
 	{ 0x8086, 0x24c5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL_ICH4 }, /* ICH4 */
 	{ 0x8086, 0x24d5, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL_ICH4 }, /* ICH5 */
+	{ 0x8086, 0x25a6, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL_ICH4 }, /* ESB */
+	{ 0x8086, 0x266e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL_ICH4 }, /* ICH6 */
 	{ 0x8086, 0x7195, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_INTEL },	/* 440MX */
 	{ 0x1039, 0x7012, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_SIS },	/* SI7012 */
 	{ 0x10de, 0x01b1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_NFORCE },	/* NFORCE */
@@ -2590,6 +2605,8 @@
 	{ PCI_DEVICE_ID_INTEL_ICH3, "Intel 82801CA-ICH3" },
 	{ PCI_DEVICE_ID_INTEL_ICH4, "Intel 82801DB-ICH4" },
 	{ PCI_DEVICE_ID_INTEL_ICH5, "Intel ICH5" },
+	{ PCI_DEVICE_ID_INTEL_ESB_5, "Intel 6300ESB" },
+	{ PCI_DEVICE_ID_INTEL_ICH6_3, "Intel ICH6" },
 	{ PCI_DEVICE_ID_SI_7012, "SiS SI7012" },
 	{ PCI_DEVICE_ID_NVIDIA_MCP_AUDIO, "NVidia nForce" },
 	{ PCI_DEVICE_ID_NVIDIA_MCP2_AUDIO, "NVidia nForce2" },
--- linux/sound/drivers/serial-u16550.c	13 Jan 2004 17:09:57 -0000	1.20
+++ linux/sound/drivers/serial-u16550.c	15 Mar 2004 17:40:01 -0000	1.21
@@ -342,7 +342,7 @@
 	unsigned char c;
 
 	/* Do some vague tests for the presence of the uart */
-	if (io_base == 0) {
+	if (io_base == 0 || io_base == SNDRV_AUTO_PORT) {
 		return -ENODEV;	/* Not configured */
 	}
 
@@ -804,10 +804,9 @@
 		return err;
 	}
 
-	if (irq >= 0) {
+	if (irq >= 0 && irq != SNDRV_AUTO_IRQ) {
 		if (request_irq(irq, snd_uart16550_interrupt,
 				SA_INTERRUPT, "Serial MIDI", (void *) uart)) {
-			uart->irq = -1;
 			snd_printk("irq %d busy. Using Polling.\n", irq);
 		} else {
 			uart->irq = irq;
--- linux/sound/i2c/cs8427.c	20 Jan 2004 16:40:42 -0000	1.12
+++ linux/sound/i2c/cs8427.c	15 Mar 2004 17:40:11 -0000	1.13
@@ -553,6 +553,7 @@
 			       SNDRV_CTL_EVENT_MASK_VALUE,
 			       &chip->playback.pcm_ctl->id);
 	reset = chip->rate != rate;
+	chip->rate = rate;
 	snd_i2c_unlock(cs8427->bus);
 	if (reset)
 		snd_cs8427_reset(cs8427);
--- linux/sound/pci/es1968.c	6 Mar 2004 16:46:58 -0000	1.57
+++ linux/sound/pci/es1968.c	12 Mar 2004 16:02:12 -0000
@@ -162,10 +162,10 @@
 MODULE_PARM_SYNTAX(clock, SNDRV_ENABLED);
 MODULE_PARM(use_pm, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(use_pm, "Toggle power-management.  (0 = off, 1 = on, 2 = auto)");
-MODULE_PARM_SYNTAX(use_pm, SNDRV_ENABLED ",allows:{{0,1,2}},skill:advanced");
+MODULE_PARM_SYNTAX(use_pm, SNDRV_ENABLED ",allows:{{0,1,2}},default:2,skill:advanced");
 MODULE_PARM(enable_mpu, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(enable_mpu, "Enable MPU401.  (0 = off, 1 = on, 2 = auto)");
-MODULE_PARM_SYNTAX(enable_mpu, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
+MODULE_PARM_SYNTAX(enable_mpu, SNDRV_ENABLED ",allows:{{0,2}},default:2");
 #ifdef SUPPORT_JOYSTICK
 MODULE_PARM(joystick, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(joystick, "Enable joystick.");
--- linux/sound/pci/emu10k1/emu10k1_callback.c	2 Mar 2004 15:51:55 -0000	1.8
+++ linux/sound/pci/emu10k1/emu10k1_callback.c	15 Mar 2004 17:35:39 -0000	1.9
@@ -426,7 +426,7 @@
 		snd_emu10k1_ptr_write(hw, CDF, ch, sample);
 
 		/* invalidate maps */
-		temp = ((unsigned int)hw->silent_page_dmaaddr << 1) | MAP_PTI_MASK;
+		temp = ((unsigned int)hw->silent_page.addr << 1) | MAP_PTI_MASK;
 		snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 		snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 		
--- linux/sound/pci/trident/trident_memory.c	6 Mar 2004 16:46:59 -0000	1.11
+++ linux/sound/pci/trident/trident_memory.c	15 Mar 2004 17:35:39 -0000	1.12
@@ -76,8 +76,8 @@
 static inline void set_silent_tlb(trident_t *trident, int page)
 {
 	page <<= 1;
-	__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page, trident->tlb.silent_page_dmaaddr);
-	__set_tlb_bus(trident, page+1, (unsigned long)trident->tlb.silent_page, trident->tlb.silent_page_dmaaddr);
+	__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);
+	__set_tlb_bus(trident, page+1, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);
 }
 
 #else
@@ -111,7 +111,7 @@
 	int i;
 	page *= UNIT_PAGES;
 	for (i = 0; i < UNIT_PAGES; i++, page++)
-		__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page, trident->tlb.silent_page_dmaaddr);
+		__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);
 }
 
 #endif /* PAGE_SIZE */
diff-purN linux-2.6.4.orig/sound/pci/emu10k1/memory.c linux-2.6.4/sound/pci/emu10k1/memory.c
--- linux-2.6.4.orig/sound/pci/emu10k1/memory.c	2004-03-15 16:43:20.013459000 +0000
+++ linux-2.6.4/sound/pci/emu10k1/memory.c	2004-03-15 17:07:59.338671188 +0000
@@ -62,7 +62,7 @@ static inline void set_silent_ptb(emu10k
 	page *= UNIT_PAGES;
 	for (i = 0; i < UNIT_PAGES; i++, page++)
 		/* do not increment ptr */
-		__set_ptb_entry(emu, page, emu->silent_page_dmaaddr);
+		__set_ptb_entry(emu, page, emu->silent_page.addr);
 }
 #endif /* PAGE_SIZE */
 
