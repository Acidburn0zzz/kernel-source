diff -urNp linux-2.6.4/Documentation/sound/alsa/ALSA-Configuration.txt linux-2.6.4.SUSE/Documentation/sound/alsa/ALSA-Configuration.txt
--- linux-2.6.4/Documentation/sound/alsa/ALSA-Configuration.txt	2004-03-24 15:30:17.000000000 +0100
+++ linux-2.6.4.SUSE/Documentation/sound/alsa/ALSA-Configuration.txt	2004-03-24 15:30:39.000000000 +0100
@@ -611,6 +611,8 @@ Module parameters
                         * Digigram VX442
 
     omni	- Omni I/O support for MidiMan M-Audio Delta44/66
+    cs8427_timeout - reset timeout for the CS8427 chip (S/PDIF transciever)
+                     in msec resolution, default value is 500 (0.5 sec)
 
     Module supports up to 8 cards and autoprobe. Note: The consumer part
     is not used with all Envy24 based cards (for example in the MidiMan Delta
diff -urNp linux-2.6.4/Documentation/sound/alsa/Procfile.txt linux-2.6.4.SUSE/Documentation/sound/alsa/Procfile.txt
--- linux-2.6.4/Documentation/sound/alsa/Procfile.txt	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.4.SUSE/Documentation/sound/alsa/Procfile.txt	2004-03-24 15:30:39.000000000 +0100
@@ -0,0 +1,185 @@
+		Proc Files of ALSA Drivers
+		==========================
+		Takashi Iwai <tiwai@suse.de>
+
+General
+-------
+
+ALSA has its own proc tree, /proc/asound.  Many useful information are
+found in this tree.  When you encounter a problem and need debugging,
+check the files listed in the following sections.
+
+Each card has its subtree cardX, where X is from 0 to 7. The
+card-specific files are stored in the card* subdirectories.
+
+
+Global Information
+------------------
+
+cards
+	Shows the list of currently configured ALSA drivers,
+	index, the id string, short and long descriptions.
+
+version
+	Shows the version string and compile date.
+
+modules
+	Lists the module of each card
+
+devices
+	Lists the ALSA native device mappings.
+
+meminfo
+	Shows the status of allocated pages via ALSA drivers.
+	Appears only when CONFIG_SND_DEBUG=y.
+
+hwdep
+	Lists the currently available hwdep devices in format of
+	<card>-<device>: <name>
+
+pcm
+	Lists the currently available PCM devices in format of
+	<card>-<device>: <id>: <name> : <sub-streams>
+
+timer
+	Lists the currently available timer devices
+
+
+oss/devices
+	Lists the OSS device mappings.
+
+oss/sndstat
+	Provides the output compatible with /dev/sndstat.
+	You can symlink this to /dev/sndstat.
+
+
+Card Specific Files
+-------------------
+
+The card-specific files are found in /proc/asound/card* directories.
+Some drivers (e.g. cmipci) have their own proc entries for the
+register dump, etc (e.g. /proc/asound/card*/cmipci shows the register
+dump).  These files would be really helpful for debugging.
+
+When PCM devices are available on this card, you can see directories
+like pcm0p or pcm1c.  They hold the PCM information for each PCM
+stream.  The number after 'pcm' is the PCM device number from 0, and
+the last 'p' or 'c' means playback or capture direction.  The files in
+this subtree is described later.
+
+The status of MIDI I/O is found in midi* files.  It shows the device
+name and the received/transmitted bytes through the MIDI device.
+
+When the card is equipped with AC97 codecs, there are codec97#*
+subdirectories (desribed later).
+
+When the OSS mixer emulation is enabled (and the module is loaded),
+oss_mixer file appears here, too.  This shows the current mapping of
+OSS mixer elements to the ALSA control elements.  You can change the
+mapping by writing to this device.  Read OSS-Emulation.txt for
+details.
+
+
+PCM Proc Files
+--------------
+
+card*/pcm*/info
+	The general information of this PCM device: card #, device #,
+	substreams, etc.
+
+card*/pcm*/xrun_debug
+	This file appears when CONFIG_SND_DEBUG=y.
+	This shows the status of xrun (= buffer overrun/xrun) debug of
+	ALSA PCM middle layer, as an integer from 0 to 2.  The value
+	can be changed by writing to this file, such as
+
+		 # cat 2 > /proc/asound/card0/pcm0p/xrun_debug
+
+	When this value is greater than 0, the driver will show the
+	messages to kernel log when an xrun is detected.  The debug
+	message is shown also when the invalid H/W pointer is detected
+	at the update of periods (usually called from the interrupt
+	handler).
+
+	When this value is greater than 1, the driver will show the
+	stack trace additionally.  This may help the debugging.
+
+card*/pcm*/sub*/info
+	The general information of this PCM sub-stream.
+
+card*/pcm*/sub*/status
+	The current status of this PCM sub-stream, elapsed time,
+	H/W position, etc.
+
+card*/pcm*/sub*/hw_params
+	The hardware parameters set for this sub-stream.
+
+card*/pcm*/sub*/sw_params
+	The soft parameters set for this sub-stream.
+
+card*/pcm*/sub*/prealloc
+	The buffer pre-allocation information.
+
+
+AC97 Codec Information
+----------------------
+
+card*/codec97#*/ac97#?-?
+	Shows the general information of this AC97 codec chip, such as
+	name, capabilities, set up.
+
+card*/codec97#0/ac97#?-?+regs
+	Shows the AC97 register dump.  Useful for debugging.
+
+
+Sequencer Information
+---------------------
+
+seq/drivers
+	Lists the currently available ALSA sequencer drivers.
+
+seq/clients
+	Shows the list of currently available sequencer clinets and
+	ports.  The connection status and the running status are shown
+	in this file, too.
+
+seq/queues
+	Lists the currently allocated/running sequener queues.
+
+seq/timer
+	Lists the currently allocated/running sequencer timers.
+
+seq/oss
+	Lists the OSS-compatible sequencer stuffs.
+
+
+Help For Debugging?
+-------------------
+
+When the problem is related with PCM, first try to turn on xrun_debug
+mode.  This will give you the kernel messages when and where xrun
+happened.
+
+If it's really a bug, report it with the following information
+
+  - the name of the driver/card, show in /proc/asound/cards
+  - the reigster dump, if available (e.g. card*/cmipci)
+
+when it's a PCM problem,
+
+  - set-up of PCM, shown in hw_parms, sw_params, and status in the PCM
+    sub-stream directory
+
+when it's a mixer problem,
+
+  - AC97 proc files, codec97#*/* files
+
+for USB audio/midi,
+
+  - output of lsusb -v
+  - stream* files in card directory
+
+
+The ALSA bug-tracking system is found at:
+
+    https://bugtrack.alsa-project.org/alsa-bug/
diff -urNp linux-2.6.4/include/sound/cs8427.h linux-2.6.4.SUSE/include/sound/cs8427.h
--- linux-2.6.4/include/sound/cs8427.h	2004-03-11 03:55:34.000000000 +0100
+++ linux-2.6.4.SUSE/include/sound/cs8427.h	2004-03-24 15:30:39.000000000 +0100
@@ -187,7 +187,8 @@
 #define CS8427_VER8427A		0x71
 
 int snd_cs8427_detect(snd_i2c_bus_t *bus, unsigned char addr);
-int snd_cs8427_create(snd_i2c_bus_t *bus, unsigned char addr, snd_i2c_device_t **r_cs8427);
+int snd_cs8427_create(snd_i2c_bus_t *bus, unsigned char addr,
+		      unsigned int reset_timeout, snd_i2c_device_t **r_cs8427);
 void snd_cs8427_reset(snd_i2c_device_t *cs8427);
 int snd_cs8427_reg_write(snd_i2c_device_t *device, unsigned char reg, unsigned char val);
 int snd_cs8427_reg_read(snd_i2c_device_t *device, unsigned char reg);
diff -urNp linux-2.6.4/include/sound/pcm.h linux-2.6.4.SUSE/include/sound/pcm.h
--- linux-2.6.4/include/sound/pcm.h	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/include/sound/pcm.h	2004-03-24 15:30:39.000000000 +0100
@@ -428,7 +428,7 @@ struct _snd_pcm_str {
 	snd_info_entry_t *proc_root;
 	snd_info_entry_t *proc_info_entry;
 #ifdef CONFIG_SND_DEBUG
-	unsigned int xrun_debug: 1;
+	unsigned int xrun_debug;	/* 0 = disabled, 1 = verbose, 2 = stacktrace */
 	snd_info_entry_t *proc_xrun_debug_entry;
 #endif
 };
diff -urNp linux-2.6.4/sound/core/pcm.c linux-2.6.4.SUSE/sound/core/pcm.c
--- linux-2.6.4/sound/core/pcm.c	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/sound/core/pcm.c	2004-03-24 15:30:39.000000000 +0100
@@ -403,7 +403,7 @@ static void snd_pcm_xrun_debug_write(snd
 	snd_pcm_str_t *pstr = (snd_pcm_str_t *)entry->private_data;
 	char line[64];
 	if (!snd_info_get_line(buffer, line, sizeof(line)))
-		pstr->xrun_debug = !!simple_strtoul(line, NULL, 10);
+		pstr->xrun_debug = simple_strtoul(line, NULL, 10);
 }
 #endif
 
diff -urNp linux-2.6.4/sound/core/pcm_lib.c linux-2.6.4.SUSE/sound/core/pcm_lib.c
--- linux-2.6.4/sound/core/pcm_lib.c	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/sound/core/pcm_lib.c	2004-03-24 15:30:39.000000000 +0100
@@ -167,7 +167,8 @@ static inline int snd_pcm_update_hw_ptr_
 				   substream->pcm->card->number,
 				   substream->pcm->device,
 				   substream->stream ? 'c' : 'p');
-			dump_stack();
+			if (substream->pstr->xrun_debug > 1)
+				dump_stack();
 		}
 #endif
 		return -EPIPE;
@@ -194,8 +195,11 @@ static inline int snd_pcm_update_hw_ptr_
 	if (delta > 0) {
 		if ((snd_pcm_uframes_t)delta < runtime->buffer_size / 2) {
 #ifdef CONFIG_SND_DEBUG
-			if (runtime->periods > 1)
+			if (runtime->periods > 1 && substream->pstr->xrun_debug) {
 				snd_printd(KERN_ERR "Unexpected hw_pointer value [1] (stream = %i, delta: -%ld, max jitter = %ld): wrong interrupt acknowledge?\n", substream->stream, (long) delta, runtime->buffer_size / 2);
+				if (substream->pstr->xrun_debug > 1)
+					dump_stack();
+			}
 #endif
 			return 0;
 		}
@@ -232,8 +236,11 @@ int snd_pcm_update_hw_ptr(snd_pcm_substr
 	if (delta > 0) {
 		if ((snd_pcm_uframes_t)delta < runtime->buffer_size / 2) {
 #ifdef CONFIG_SND_DEBUG
-			if (runtime->periods > 2)
+			if (runtime->periods > 2 && substream->pstr->xrun_debug) {
 				snd_printd(KERN_ERR "Unexpected hw_pointer value [2] (stream = %i, delta: -%ld, max jitter = %ld): wrong interrupt acknowledge?\n", substream->stream, (long) delta, runtime->buffer_size / 2);
+				if (substream->pstr->xrun_debug > 1)
+					dump_stack();
+			}
 #endif
 			return 0;
 		}
diff -urNp linux-2.6.4/sound/core/pcm_timer.c linux-2.6.4.SUSE/sound/core/pcm_timer.c
--- linux-2.6.4/sound/core/pcm_timer.c	2004-03-11 03:55:51.000000000 +0100
+++ linux-2.6.4.SUSE/sound/core/pcm_timer.c	2004-03-24 15:30:39.000000000 +0100
@@ -32,9 +32,9 @@
  */
 
 /* Greatest common divisor */
-static int gcd(int a, int b)
+static unsigned long gcd(unsigned long a, unsigned long b)
 {
-	int r;
+	unsigned long r;
 	if (a < b) {
 		r = a;
 		a = b;
@@ -49,7 +49,7 @@ static int gcd(int a, int b)
 
 void snd_pcm_timer_resolution_change(snd_pcm_substream_t *substream)
 {
-	unsigned int rate, mult, fsize, l;
+	unsigned long rate, mult, fsize, l;
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	
         mult = 1000000000;
@@ -67,7 +67,11 @@ void snd_pcm_timer_resolution_change(snd
 		mult /= 2;
 		rate /= 2;
 	}
-	snd_assert(rate != 0, return);
+	if (rate == 0) {
+		snd_printk(KERN_ERR "pcm timer resolution out of range (rate = %u, period_size = %lu)\n", runtime->rate, runtime->period_size);
+		runtime->timer_resolution = -1;
+		return;
+	}
 	runtime->timer_resolution = mult * fsize / rate;
 }
 
diff -urNp linux-2.6.4/sound/i2c/cs8427.c linux-2.6.4.SUSE/sound/i2c/cs8427.c
--- linux-2.6.4/sound/i2c/cs8427.c	2004-03-24 15:30:19.000000000 +0100
+++ linux-2.6.4.SUSE/sound/i2c/cs8427.c	2004-03-24 15:30:39.000000000 +0100
@@ -50,6 +50,7 @@ typedef struct {
 typedef struct {
 	unsigned char regmap[0x14];	/* map of first 1 + 13 registers */
 	unsigned int rate;
+	unsigned int reset_timeout;
 	cs8427_stream_t playback;
 	cs8427_stream_t capture;
 } cs8427_t;
@@ -163,6 +164,7 @@ static void snd_cs8427_free(snd_i2c_devi
 
 int snd_cs8427_create(snd_i2c_bus_t *bus,
 		      unsigned char addr,
+		      unsigned int reset_timeout,
 		      snd_i2c_device_t **r_cs8427)
 {
 	static unsigned char initvals1[] = {
@@ -256,6 +258,9 @@ int snd_cs8427_create(snd_i2c_bus_t *bus
 	snd_i2c_unlock(bus);
 
 	/* turn on run bit and rock'n'roll */
+	if (reset_timeout < 1)
+		reset_timeout = 1;
+	chip->reset_timeout = reset_timeout;
 	snd_cs8427_reset(device);
 
 #if 0	// it's nice for read tests
@@ -301,7 +306,7 @@ void snd_cs8427_reset(snd_i2c_device_t *
 	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE, chip->regmap[CS8427_REG_CLOCKSOURCE]);
 	udelay(200);
 	snd_i2c_unlock(cs8427->bus);
-	end_time = jiffies + HZ / 2;
+	end_time = jiffies + chip->reset_timeout;
 	while (time_after_eq(end_time, jiffies)) {
 		snd_i2c_lock(cs8427->bus);
 		data = snd_cs8427_reg_read(cs8427, CS8427_REG_RECVERRORS);
@@ -309,7 +314,7 @@ void snd_cs8427_reset(snd_i2c_device_t *
 		if (!(data & CS8427_UNLOCK))
 			break;
 		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(HZ/100);
+		schedule_timeout(1);
 	}
 	snd_i2c_lock(cs8427->bus);
 	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~CS8427_RXDMASK;
diff -urNp linux-2.6.4/sound/pci/es1968.c linux-2.6.4.SUSE/sound/pci/es1968.c
--- linux-2.6.4/sound/pci/es1968.c	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/sound/pci/es1968.c	2004-03-24 15:30:35.000000000 +0100
@@ -162,10 +162,10 @@ MODULE_PARM_DESC(clock, "Clock on " CARD
 MODULE_PARM_SYNTAX(clock, SNDRV_ENABLED);
 MODULE_PARM(use_pm, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(use_pm, "Toggle power-management.  (0 = off, 1 = on, 2 = auto)");
-MODULE_PARM_SYNTAX(use_pm, SNDRV_ENABLED ",allows:{{0,1,2}},skill:advanced");
+MODULE_PARM_SYNTAX(use_pm, SNDRV_ENABLED ",allows:{{0,1,2}},default:2,skill:advanced");
 MODULE_PARM(enable_mpu, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(enable_mpu, "Enable MPU401.  (0 = off, 1 = on, 2 = auto)");
-MODULE_PARM_SYNTAX(enable_mpu, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
+MODULE_PARM_SYNTAX(enable_mpu, SNDRV_ENABLED ",allows:{{0,2}},default:2");
 #ifdef SUPPORT_JOYSTICK
 MODULE_PARM(joystick, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(joystick, "Enable joystick.");
diff -urNp linux-2.6.4/sound/pci/ice1712/ice1712.c linux-2.6.4.SUSE/sound/pci/ice1712/ice1712.c
--- linux-2.6.4/sound/pci/ice1712/ice1712.c	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/sound/pci/ice1712/ice1712.c	2004-03-24 15:30:39.000000000 +0100
@@ -82,6 +82,7 @@ static int index[SNDRV_CARDS] = SNDRV_DE
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;		/* Enable this card */
 static int omni[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 0};	/* Delta44 & 66 Omni I/O support */
+static int cs8427_timeout[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 500}; /* CS8427 S/PDIF transciever reset timeout value in msec */
 
 MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(index, "Index value for ICE1712 soundcard.");
@@ -95,6 +96,9 @@ MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_
 MODULE_PARM(omni, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(omni, "Enable Midiman M-Audio Delta Omni I/O support.");
 MODULE_PARM_SYNTAX(omni, SNDRV_ENABLED "," SNDRV_ENABLE_DESC);
+MODULE_PARM(cs8427_timeout, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+MODULE_PARM_DESC(cs8427_timeout, "Define reset timeout for cs8427 chip in msec resolution.");
+MODULE_PARM_SYNTAX(cs8427_timeout, SNDRV_ENABLED ", allows:{{1,1000}},default=500,skill:advanced");
 
 #ifndef PCI_VENDOR_ID_ICE
 #define PCI_VENDOR_ID_ICE		0x1412
@@ -386,7 +390,9 @@ int __devinit snd_ice1712_init_cs8427(ic
 {
 	int err;
 
-	if ((err = snd_cs8427_create(ice->i2c, addr, &ice->cs8427)) < 0) {
+	if ((err = snd_cs8427_create(ice->i2c, addr,
+				     (ice->cs8427_timeout * HZ) / 1000,
+				     &ice->cs8427)) < 0) {
 		snd_printk("CS8427 initialization failed\n");
 		return err;
 	}
@@ -2404,6 +2410,7 @@ static int snd_ice1712_dev_free(snd_devi
 static int __devinit snd_ice1712_create(snd_card_t * card,
 					struct pci_dev *pci,
 					int omni,
+					int cs8427_timeout,
 					ice1712_t ** r_ice1712)
 {
 	ice1712_t *ice;
@@ -2428,6 +2435,11 @@ static int __devinit snd_ice1712_create(
 	if (ice == NULL)
 		return -ENOMEM;
 	ice->omni = omni ? 1 : 0;
+	if (cs8427_timeout < 1)
+		cs8427_timeout = 1;
+	else if (cs8427_timeout > 1000)
+		cs8427_timeout = 1000;
+	ice->cs8427_timeout = cs8427_timeout;
 	spin_lock_init(&ice->reg_lock);
 	init_MUTEX(&ice->gpio_mutex);
 	init_MUTEX(&ice->open_mutex);
@@ -2547,7 +2559,7 @@ static int __devinit snd_ice1712_probe(s
 	strcpy(card->driver, "ICE1712");
 	strcpy(card->shortname, "ICEnsemble ICE1712");
 	
-	if ((err = snd_ice1712_create(card, pci, omni[dev], &ice)) < 0) {
+	if ((err = snd_ice1712_create(card, pci, omni[dev], cs8427_timeout[dev], &ice)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
diff -urNp linux-2.6.4/sound/pci/ice1712/ice1712.h linux-2.6.4.SUSE/sound/pci/ice1712/ice1712.h
--- linux-2.6.4/sound/pci/ice1712/ice1712.h	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/sound/pci/ice1712/ice1712.h	2004-03-24 15:30:39.000000000 +0100
@@ -346,6 +346,7 @@ struct _snd_ice1712 {
 	snd_i2c_bus_t *i2c;		/* I2C bus */
 	snd_i2c_device_t *cs8404;	/* CS8404A I2C device */
 	snd_i2c_device_t *cs8427;	/* CS8427 I2C device */
+	unsigned int cs8427_timeout;	/* CS8427 reset timeout in HZ/100 */
 	snd_i2c_device_t *i2cdevs[2];	/* additional i2c devices */
 	
 	struct ice1712_gpio {
diff -urNp linux-2.6.4/sound/pci/intel8x0.c linux-2.6.4.SUSE/sound/pci/intel8x0.c
--- linux-2.6.4/sound/pci/intel8x0.c	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/sound/pci/intel8x0.c	2004-03-24 15:30:39.000000000 +0100
@@ -96,7 +96,7 @@ MODULE_PARM_DESC(ac97_clock, "AC'97 code
 MODULE_PARM_SYNTAX(ac97_clock, SNDRV_ENABLED ",default:0");
 MODULE_PARM(ac97_quirk, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(ac97_quirk, "AC'97 workaround for strange hardware.");
-MODULE_PARM_SYNTAX(ac97_quirk, SNDRV_ENABLED ",allows:{{-1,3}},dialog:list,default:-1");
+MODULE_PARM_SYNTAX(ac97_quirk, SNDRV_ENABLED ",allows:{{-1,4}},dialog:list,default:-1");
 #ifdef SUPPORT_JOYSTICK
 MODULE_PARM(joystick, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
 MODULE_PARM_DESC(joystick, "Enable joystick for Intel i8x0 soundcard.");
@@ -824,19 +824,16 @@ static irqreturn_t snd_intel8x0_interrup
 	spin_lock(&chip->reg_lock);
 	status = igetdword(chip, chip->int_sta_reg);
 	if ((status & chip->int_sta_mask) == 0) {
-		static int err_count = 10;
 		if (status) {
 			/* ack */
 			iputdword(chip, chip->int_sta_reg, status);
+			/* some Nforce[2] boards have problems when
+			   IRQ_NONE is returned here.
+			*/
 			if (chip->device_type != DEVICE_NFORCE)
-				status ^= igetdword(chip, chip->int_sta_reg);
+				status = 0;
 		}
 		spin_unlock(&chip->reg_lock);
-		if (chip->device_type != DEVICE_NFORCE && status && err_count) {
-			err_count--;
-			snd_printd("intel8x0: unknown IRQ bits 0x%x (sta_mask=0x%x)\n",
-				   status, chip->int_sta_mask);
-		}
 		return IRQ_RETVAL(status);
 	}
 
@@ -1690,6 +1687,12 @@ static struct ac97_pcm ac97_pcm_defs[] _
 
 static struct ac97_quirk ac97_quirks[] __devinitdata = {
 	{
+		.vendor = 0x0e11,
+		.device = 0x00b8,
+		.name = "Compaq Evo D510C",
+		.type = AC97_TUNE_HP_ONLY
+	},
+	{
 		.vendor = 0x1014,
 		.device = 0x1f00,
 		.name = "MS-9128",
diff -urNp linux-2.6.4/sound/pcmcia/pdaudiocf/pdaudiocf.c linux-2.6.4.SUSE/sound/pcmcia/pdaudiocf/pdaudiocf.c
--- linux-2.6.4/sound/pcmcia/pdaudiocf/pdaudiocf.c	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/sound/pcmcia/pdaudiocf/pdaudiocf.c	2004-03-24 15:30:39.000000000 +0100
@@ -25,7 +25,6 @@
 #include <pcmcia/ciscode.h>
 #include <pcmcia/cisreg.h>
 #include "pdaudiocf.h"
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 /*
diff -urNp linux-2.6.4/sound/pcmcia/pdaudiocf/pdaudiocf_core.c linux-2.6.4.SUSE/sound/pcmcia/pdaudiocf/pdaudiocf_core.c
--- linux-2.6.4/sound/pcmcia/pdaudiocf/pdaudiocf_core.c	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/sound/pcmcia/pdaudiocf/pdaudiocf_core.c	2004-03-24 15:30:39.000000000 +0100
@@ -23,7 +23,6 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include "pdaudiocf.h"
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 /*
diff -urNp linux-2.6.4/sound/pcmcia/pdaudiocf/pdaudiocf_irq.c linux-2.6.4.SUSE/sound/pcmcia/pdaudiocf/pdaudiocf_irq.c
--- linux-2.6.4/sound/pcmcia/pdaudiocf/pdaudiocf_irq.c	2004-03-24 15:30:18.000000000 +0100
+++ linux-2.6.4.SUSE/sound/pcmcia/pdaudiocf/pdaudiocf_irq.c	2004-03-24 15:30:39.000000000 +0100
@@ -21,7 +21,6 @@
 #include <sound/driver.h>
 #include <sound/core.h>
 #include "pdaudiocf.h"
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 /*
diff -urNp linux-2.6.4/sound/usb/usbaudio.c linux-2.6.4.SUSE/sound/usb/usbaudio.c
--- linux-2.6.4/sound/usb/usbaudio.c	2004-03-24 15:30:19.000000000 +0100
+++ linux-2.6.4.SUSE/sound/usb/usbaudio.c	2004-03-24 15:30:39.000000000 +0100
@@ -104,6 +104,7 @@ MODULE_PARM_SYNTAX(async_unlink, SNDRV_B
  */
 
 #define MAX_PACKS	10	
+#define MAX_PACKS_HS	(MAX_PACKS * 8)	/* in high speed mode */
 #define MAX_URBS	5	/* max. 20ms long packets */
 #define SYNC_URBS	2	/* always two urbs for sync */
 #define MIN_PACKS_URB	1	/* minimum 1 packet per urb */
@@ -161,8 +162,8 @@ struct snd_usb_substream {
 	unsigned int datapipe;   /* the data i/o pipe */
 	unsigned int syncpipe;   /* 1 - async out or adaptive in */
 	unsigned int syncinterval;  /* P for adaptive mode, 0 otherwise */
-	unsigned int freqn;      /* nominal sampling rate in USB format, i.e. fs/1000 in Q10.14 */
-	unsigned int freqm;      /* momentary sampling rate in USB format, i.e. fs/1000 in Q10.14 */
+	unsigned int freqn;      /* nominal sampling rate in fs/fps in Q16.16 format */
+	unsigned int freqm;      /* momentary sampling rate in fs/fps in Q16.16 format */
 	unsigned int freqmax;    /* maximum sampling rate, used for buffer management */
 	unsigned int phase;      /* phase accumulator */
 	unsigned int maxpacksize;	/* max packet size in bytes */
@@ -184,7 +185,7 @@ struct snd_usb_substream {
 	unsigned int nurbs;			/* # urbs */
 	snd_urb_ctx_t dataurb[MAX_URBS];	/* data urb table */
 	snd_urb_ctx_t syncurb[SYNC_URBS];	/* sync urb table */
-	char syncbuf[SYNC_URBS * MAX_PACKS * 3]; /* sync buffer; it's so small - let's get static */
+	char syncbuf[SYNC_URBS * MAX_PACKS * 4]; /* sync buffer; it's so small - let's get static */
 	char *tmpbuf;			/* temporary buffer for playback */
 
 	u64 formats;			/* format bitmasks (all or'ed) */
@@ -218,17 +219,38 @@ static snd_usb_audio_t *usb_chip[SNDRV_C
 
 
 /*
- * convert a sampling rate into USB format (fs/1000 in Q10.14)
- * this will overflow at approx 2MSPS
+ * convert a sampling rate into our full speed format (fs/1000 in Q16.16)
+ * this will overflow at approx 524 kHz
  */
-inline static unsigned get_usb_rate(unsigned int rate)
+inline static unsigned get_usb_full_speed_rate(unsigned int rate)
 {
-	return ((rate << 11) + 62) / 125;
+	return ((rate << 13) + 62) / 125;
+}
+
+/*
+ * convert a sampling rate into USB high speed format (fs/8000 in Q16.16)
+ * this will overflow at approx 4 MHz
+ */
+inline static unsigned get_usb_high_speed_rate(unsigned int rate)
+{
+	return ((rate << 10) + 62) / 125;
+}
+
+/* convert our full speed USB rate into sampling rate in Hz */
+inline static unsigned get_full_speed_hz(unsigned int usb_rate)
+{
+	return (usb_rate * 125 + (1 << 12)) >> 13;
+}
+
+/* convert our high speed USB rate into sampling rate in Hz */
+inline static unsigned get_high_speed_hz(unsigned int usb_rate)
+{
+	return (usb_rate * 125 + (1 << 9)) >> 10;
 }
 
 
 /*
- * prepare urb for capture sync pipe
+ * prepare urb for full speed capture sync pipe
  *
  * fill the length and offset of each urb descriptor.
  * the fixed 10.14 frequency is passed through the pipe.
@@ -243,14 +265,40 @@ static int prepare_capture_sync_urb(snd_
 
 	urb->number_of_packets = ctx->packets;
 	urb->dev = ctx->subs->dev; /* we need to set this at each time */
-	for (i = offs = 0; i < urb->number_of_packets; i++, offs += 3, cp += 3) {
+	for (i = offs = 0; i < urb->number_of_packets; i++, offs += 4, cp += 4) {
 		urb->iso_frame_desc[i].length = 3;
 		urb->iso_frame_desc[i].offset = offs;
+		cp[0] = subs->freqn >> 2;
+		cp[1] = subs->freqn >> 10;
+		cp[2] = subs->freqn >> 18;
+	}
+	return 0;
+}
+
+/*
+ * prepare urb for high speed capture sync pipe
+ *
+ * fill the length and offset of each urb descriptor.
+ * the fixed 12.13 frequency is passed as 16.16 through the pipe.
+ */
+static int prepare_capture_sync_urb_hs(snd_usb_substream_t *subs,
+				       snd_pcm_runtime_t *runtime,
+				       struct urb *urb)
+{
+	unsigned char *cp = urb->transfer_buffer;
+	snd_urb_ctx_t *ctx = (snd_urb_ctx_t *)urb->context;
+	int i, offs;
+
+	urb->number_of_packets = ctx->packets;
+	urb->dev = ctx->subs->dev; /* we need to set this at each time */
+	for (i = offs = 0; i < urb->number_of_packets; i++, offs += 4, cp += 4) {
+		urb->iso_frame_desc[i].length = 4;
+		urb->iso_frame_desc[i].offset = offs;
 		cp[0] = subs->freqn;
 		cp[1] = subs->freqn >> 8;
 		cp[2] = subs->freqn >> 16;
+		cp[3] = subs->freqn >> 24;
 	}
-	urb->interval = 1;
 	return 0;
 }
 
@@ -301,7 +349,6 @@ static int prepare_capture_urb(snd_usb_s
 	spin_unlock_irqrestore(&subs->lock, flags);
 	urb->transfer_buffer = ctx->buf;
 	urb->transfer_buffer_length = offs;
-	urb->interval = 1;
 #if 0 // for check
 	if (! urb->bandwidth) {
 		int bustime;
@@ -372,7 +419,7 @@ static int retire_capture_urb(snd_usb_su
 
 
 /*
- * prepare urb for playback sync pipe
+ * prepare urb for full speed playback sync pipe
  *
  * set up the offset and length to receive the current frequency.
  */
@@ -386,16 +433,37 @@ static int prepare_playback_sync_urb(snd
 
 	urb->number_of_packets = ctx->packets;
 	urb->dev = ctx->subs->dev; /* we need to set this at each time */
-	for (i = offs = 0; i < urb->number_of_packets; i++, offs += 3) {
+	for (i = offs = 0; i < urb->number_of_packets; i++, offs += 4) {
 		urb->iso_frame_desc[i].length = 3;
 		urb->iso_frame_desc[i].offset = offs;
 	}
-	urb->interval = 1;
 	return 0;
 }
 
 /*
- * process after playback sync complete
+ * prepare urb for high speed playback sync pipe
+ *
+ * set up the offset and length to receive the current frequency.
+ */
+
+static int prepare_playback_sync_urb_hs(snd_usb_substream_t *subs,
+					snd_pcm_runtime_t *runtime,
+					struct urb *urb)
+{
+	int i, offs;
+	snd_urb_ctx_t *ctx = (snd_urb_ctx_t *)urb->context;
+
+	urb->number_of_packets = ctx->packets;
+	urb->dev = ctx->subs->dev; /* we need to set this at each time */
+	for (i = offs = 0; i < urb->number_of_packets; i++, offs += 4) {
+		urb->iso_frame_desc[i].length = 4;
+		urb->iso_frame_desc[i].offset = offs;
+	}
+	return 0;
+}
+
+/*
+ * process after full speed playback sync complete
  *
  * retrieve the current 10.14 frequency from pipe, and set it.
  * the value is referred in prepare_playback_urb().
@@ -410,11 +478,11 @@ static int retire_playback_sync_urb(snd_
 	unsigned long flags;
 
 	found = 0;
-	for (i = 0; i < urb->number_of_packets; i++, cp += 3) {
+	for (i = 0; i < urb->number_of_packets; i++, cp += 4) {
 		if (urb->iso_frame_desc[i].status ||
 		    urb->iso_frame_desc[i].actual_length < 3)
 			continue;
-		f = combine_triple(cp);
+		f = combine_triple(cp) << 2;
 #if 0
 		if (f < subs->freqn - (subs->freqn>>3) || f > subs->freqmax) {
 			snd_printd(KERN_WARNING "requested frequency %d (%u,%03uHz) out of range (current nominal %d (%u,%03uHz))\n",
@@ -435,6 +503,37 @@ static int retire_playback_sync_urb(snd_
 }
 
 /*
+ * process after high speed playback sync complete
+ *
+ * retrieve the current 12.13 frequency from pipe, and set it.
+ * the value is referred in prepare_playback_urb().
+ */
+static int retire_playback_sync_urb_hs(snd_usb_substream_t *subs,
+				       snd_pcm_runtime_t *runtime,
+				       struct urb *urb)
+{
+	int i;
+	unsigned int found;
+	unsigned char *cp = urb->transfer_buffer;
+	unsigned long flags;
+
+	found = 0;
+	for (i = 0; i < urb->number_of_packets; i++, cp += 4) {
+		if (urb->iso_frame_desc[i].status ||
+		    urb->iso_frame_desc[i].actual_length < 4)
+			continue;
+		found = combine_quad(cp) & 0x0fffffff;
+	}
+	if (found) {
+		spin_lock_irqsave(&subs->lock, flags);
+		subs->freqm = found;
+		spin_unlock_irqrestore(&subs->lock, flags);
+	}
+
+	return 0;
+}
+
+/*
  * prepare urb for playback data pipe
  *
  * we copy the data directly from the pcm buffer.
@@ -464,8 +563,8 @@ static int prepare_playback_urb(snd_usb_
 		if (subs->fill_max)
 			counts = subs->maxframesize; /* fixed */
 		else {
-			subs->phase = (subs->phase & 0x3fff) + subs->freqm;
-			counts = subs->phase >> 14;
+			subs->phase = (subs->phase & 0xffff) + subs->freqm;
+			counts = subs->phase >> 16;
 			if (counts > subs->maxframesize)
 				counts = subs->maxframesize;
 		}
@@ -515,7 +614,6 @@ static int prepare_playback_urb(snd_usb_
 	spin_unlock_irqrestore(&subs->lock, flags);
 	urb->transfer_buffer_length = offs * stride;
 	ctx->transfer = offs;
-	urb->interval = 1;
 
 	return 0;
 }
@@ -565,6 +663,21 @@ static struct snd_urb_ops audio_urb_ops[
 	},
 };
 
+static struct snd_urb_ops audio_urb_ops_high_speed[2] = {
+	{
+		.prepare =	prepare_playback_urb,
+		.retire =	retire_playback_urb,
+		.prepare_sync =	prepare_playback_sync_urb_hs,
+		.retire_sync =	retire_playback_sync_urb_hs,
+	},
+	{
+		.prepare =	prepare_capture_urb,
+		.retire =	retire_capture_urb,
+		.prepare_sync =	prepare_capture_sync_urb_hs,
+		.retire_sync =	retire_capture_sync_urb,
+	},
+};
+
 /*
  * complete callback from data urb
  */
@@ -822,15 +935,19 @@ static int init_substream_urbs(snd_usb_s
 {
 	unsigned int maxsize, n, i;
 	int is_playback = subs->direction == SNDRV_PCM_STREAM_PLAYBACK;
-	unsigned int npacks[MAX_URBS], total_packs;
+	unsigned int npacks[MAX_URBS], urb_packs, total_packs;
 
-	/* calculate the frequency in 10.14 format */
-	subs->freqn = subs->freqm = get_usb_rate(rate);
+	/* calculate the frequency in 16.16 format */
+	if (subs->dev->speed == USB_SPEED_FULL)
+		subs->freqn = get_usb_full_speed_rate(rate);
+	else
+		subs->freqn = get_usb_high_speed_rate(rate);
+	subs->freqm = subs->freqn;
 	subs->freqmax = subs->freqn + (subs->freqn >> 2); /* max. allowed frequency */
 	subs->phase = 0;
 
 	/* calculate the max. size of packet */
-	maxsize = ((subs->freqmax + 0x3fff) * (frame_bits >> 3)) >> 14;
+	maxsize = ((subs->freqmax + 0xffff) * (frame_bits >> 3)) >> 16;
 	if (subs->maxpacksize && maxsize > subs->maxpacksize) {
 		//snd_printd(KERN_DEBUG "maxsize %d is greater than defined size %d\n",
 		//	   maxsize, subs->maxpacksize);
@@ -842,9 +959,14 @@ static int init_substream_urbs(snd_usb_s
 	else
 		subs->curpacksize = maxsize;
 
+	if (subs->dev->speed == USB_SPEED_FULL)
+		urb_packs = nrpacks;
+	else
+		urb_packs = nrpacks * 8;
+
 	/* allocate a temporary buffer for playback */
 	if (is_playback) {
-		subs->tmpbuf = kmalloc(maxsize * nrpacks, GFP_KERNEL);
+		subs->tmpbuf = kmalloc(maxsize * urb_packs, GFP_KERNEL);
 		if (! subs->tmpbuf) {
 			snd_printk(KERN_ERR "cannot malloc tmpbuf\n");
 			return -ENOMEM;
@@ -855,16 +977,16 @@ static int init_substream_urbs(snd_usb_s
 	total_packs = (period_bytes + maxsize - 1) / maxsize;
 	if (total_packs < 2 * MIN_PACKS_URB)
 		total_packs = 2 * MIN_PACKS_URB;
-	subs->nurbs = (total_packs + nrpacks - 1) / nrpacks;
+	subs->nurbs = (total_packs + urb_packs - 1) / urb_packs;
 	if (subs->nurbs > MAX_URBS) {
 		/* too much... */
 		subs->nurbs = MAX_URBS;
-		total_packs = MAX_URBS * nrpacks;
+		total_packs = MAX_URBS * urb_packs;
 	}
 	n = total_packs;
 	for (i = 0; i < subs->nurbs; i++) {
-		npacks[i] = n > nrpacks ? nrpacks : n;
-		n -= nrpacks;
+		npacks[i] = n > urb_packs ? urb_packs : n;
+		n -= urb_packs;
 	}
 	if (subs->nurbs <= 1) {
 		/* too little - we need at least two packets
@@ -913,6 +1035,7 @@ static int init_substream_urbs(snd_usb_s
 		u->urb->pipe = subs->datapipe;
 		u->urb->transfer_flags = URB_ISO_ASAP;
 		u->urb->number_of_packets = u->packets;
+		u->urb->interval = 1;
 		u->urb->context = u;
 		u->urb->complete = snd_usb_complete_callback(snd_complete_urb);
 	}
@@ -929,12 +1052,13 @@ static int init_substream_urbs(snd_usb_s
 				release_substream_urbs(subs, 0);
 				return -ENOMEM;
 			}
-			u->urb->transfer_buffer = subs->syncbuf + i * nrpacks * 3;
-			u->urb->transfer_buffer_length = nrpacks * 3;
+			u->urb->transfer_buffer = subs->syncbuf + i * nrpacks * 4;
+			u->urb->transfer_buffer_length = nrpacks * 4;
 			u->urb->dev = subs->dev;
 			u->urb->pipe = subs->syncpipe;
 			u->urb->transfer_flags = URB_ISO_ASAP;
 			u->urb->number_of_packets = u->packets;
+			u->urb->interval = subs->dev->speed == USB_SPEED_HIGH ? 8 : 1;
 			u->urb->context = u;
 			u->urb->complete = snd_usb_complete_callback(snd_complete_sync_urb);
 		}
@@ -1099,7 +1223,7 @@ static int set_format(snd_usb_substream_
 
 	/* set interface */
 	if (subs->interface != fmt->iface || subs->format != fmt->altset_idx) {
-		if (usb_set_interface(dev, fmt->iface, fmt->altset_idx) < 0) {
+		if (usb_set_interface(dev, fmt->iface, fmt->altsetting) < 0) {
 			snd_printk(KERN_ERR "%d:%d:%d: usb_set_interface failed\n",
 				   dev->devnum, fmt->iface, fmt->altsetting);
 			return -EIO;
@@ -1116,7 +1240,7 @@ static int set_format(snd_usb_substream_
 	else
 		subs->datapipe = usb_rcvisocpipe(dev, ep);
 	subs->syncpipe = subs->syncinterval = 0;
-	subs->maxpacksize = get_endpoint(alts, 0)->wMaxPacketSize;
+	subs->maxpacksize = fmt->maxpacksize;
 	subs->fill_max = 0;
 
 	/* we need a sync pipe in async OUT or adaptive IN mode */
@@ -1836,11 +1960,10 @@ static void proc_dump_substream_status(s
 			snd_iprintf(buffer, "%d ", subs->dataurb[i].packets);
 		snd_iprintf(buffer, "]\n");
 		snd_iprintf(buffer, "    Packet Size = %d\n", subs->curpacksize);
-		snd_iprintf(buffer, "    Momentary freq = %d.%d Hz\n",
-			    (subs->freqm * 125) >> 11,
-			    (subs->freqm >> 10) * 625
-			    + (((subs->freqm & ((1 << 10) - 1)) * 625) >> 10)
-			    - 10 * ((subs->freqm * 125) >> 11));
+		snd_iprintf(buffer, "    Momentary freq = %u Hz\n",
+			    subs->dev->speed == USB_SPEED_FULL
+			    ? get_full_speed_hz(subs->freqm)
+			    : get_high_speed_hz(subs->freqm));
 	} else {
 		snd_iprintf(buffer, "  Status: Stop\n");
 	}
@@ -1890,7 +2013,10 @@ static void init_substream(snd_usb_strea
 	subs->stream = as;
 	subs->direction = stream;
 	subs->dev = as->chip->dev;
-	subs->ops = audio_urb_ops[stream];
+	if (subs->dev->speed == USB_SPEED_FULL)
+		subs->ops = audio_urb_ops[stream];
+	else
+		subs->ops = audio_urb_ops_high_speed[stream];
 	snd_pcm_lib_preallocate_pages(as->pcm->streams[stream].substream,
 				      SNDRV_DMA_TYPE_CONTINUOUS,
 				      snd_dma_continuous_data(GFP_KERNEL),
@@ -2351,6 +2477,7 @@ static int parse_audio_endpoints(snd_usb
 		fp->altset_idx = i;
 		fp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;
 		fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
+		/* FIXME: decode wMaxPacketSize of high bandwith endpoints */
 		fp->maxpacksize = get_endpoint(alts, 0)->wMaxPacketSize;
 		fp->attributes = csep[3];
 
@@ -2405,7 +2532,7 @@ static int parse_audio_endpoints(snd_usb
 			return err;
 		}
 		/* try to set the interface... */
-		usb_set_interface(chip->dev, iface_no, i);
+		usb_set_interface(chip->dev, iface_no, altno);
 		init_usb_pitch(chip->dev, iface_no, alts, fp);
 		init_usb_sample_rate(chip->dev, iface_no, alts, fp, fp->rate_max);
 	}
@@ -2422,7 +2549,6 @@ static void snd_usb_stream_disconnect(st
 	int idx;
 	snd_usb_stream_t *as;
 	snd_usb_substream_t *subs;
-	struct list_head *p;
 
 	as = list_entry(head, snd_usb_stream_t, list);
 	for (idx = 0; idx < 2; idx++) {
@@ -2431,11 +2557,6 @@ static void snd_usb_stream_disconnect(st
 			return;
 		release_substream_urbs(subs, 1);
 		subs->interface = -1;
-		/* release interfaces */
-		list_for_each(p, &subs->fmt_list) {
-			struct audioformat *fp = list_entry(p, struct audioformat, list);
-			usb_driver_release_interface(driver, usb_ifnum_to_if(subs->dev, fp->iface));
-		}
 	}
 }
 
@@ -2587,14 +2708,13 @@ static int create_composite_quirk(snd_us
 				  struct usb_interface *iface,
 				  const snd_usb_audio_quirk_t *quirk)
 {
-	struct usb_host_config *config = chip->dev->actconfig;
 	int probed_ifnum = get_iface_desc(iface->altsetting)->bInterfaceNumber;
 	int err;
 
 	for (quirk = quirk->data; quirk->ifnum >= 0; ++quirk) {
-		if (quirk->ifnum >= get_cfg_desc(config)->bNumInterfaces)
+		iface = usb_ifnum_to_if(chip->dev, quirk->ifnum);
+		if (!iface)
 			continue;
-		iface = get_iface(config, quirk->ifnum);
 		if (quirk->ifnum != probed_ifnum &&
 		    usb_interface_claimed(iface))
 			continue;
@@ -2706,9 +2826,6 @@ static void snd_usb_audio_create_proc(sn
 
 static int snd_usb_audio_free(snd_usb_audio_t *chip)
 {
-	down(&register_mutex);
-	usb_chip[chip->index] = NULL;
-	up(&register_mutex);
 	snd_magic_kfree(chip);
 	return 0;
 }
@@ -2723,10 +2840,11 @@ static int snd_usb_audio_dev_free(snd_de
 /*
  * create a chip instance and set its names.
  */
-static int snd_usb_audio_create(snd_card_t *card, struct usb_device *dev,
+static int snd_usb_audio_create(struct usb_device *dev, int idx,
 				const snd_usb_audio_quirk_t *quirk,
 				snd_usb_audio_t **rchip)
 {
+	snd_card_t *card;
 	snd_usb_audio_t *chip;
 	int err, len;
 	char component[14];
@@ -2735,10 +2853,26 @@ static int snd_usb_audio_create(snd_card
 	};
 	
 	*rchip = NULL;
+
+	if (dev->speed != USB_SPEED_FULL &&
+	    dev->speed != USB_SPEED_HIGH) {
+		snd_printk(KERN_ERR "unknown device speed %d\n", dev->speed);
+		return -ENXIO;
+	}
+
+	card = snd_card_new(index[idx], id[idx], THIS_MODULE, 0);
+	if (card == NULL) {
+		snd_printk(KERN_ERR "cannot create card instance %d\n", idx);
+		return -ENOMEM;
+	}
+
 	chip = snd_magic_kcalloc(snd_usb_audio_t, 0, GFP_KERNEL);
-	if (! chip)
+	if (! chip) {
+		snd_card_free(card);
 		return -ENOMEM;
+	}
 
+	chip->index = idx;
 	chip->dev = dev;
 	chip->card = card;
 	INIT_LIST_HEAD(&chip->pcm_list);
@@ -2746,6 +2880,7 @@ static int snd_usb_audio_create(snd_card
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_usb_audio_free(chip);
+		snd_card_free(card);
 		return err;
 	}
 
@@ -2788,6 +2923,10 @@ static int snd_usb_audio_create(snd_card
 	if (len < sizeof(card->longname))
 		usb_make_path(dev, card->longname + len, sizeof(card->longname) - len);
 
+	strlcat(card->longname,
+		dev->speed == USB_SPEED_FULL ? ", full speed" : ", high speed",
+		sizeof(card->longname));
+
 	snd_usb_audio_create_proc(chip);
 
 	snd_card_set_dev(card, &dev->dev);
@@ -2814,7 +2953,6 @@ static void *snd_usb_audio_probe(struct 
 	struct usb_host_config *config = dev->actconfig;
 	const snd_usb_audio_quirk_t *quirk = (const snd_usb_audio_quirk_t *)usb_id->driver_info;
 	int i, err;
-	snd_card_t *card;
 	snd_usb_audio_t *chip;
 	struct usb_host_interface *alts;
 	int ifnum;
@@ -2842,11 +2980,11 @@ static void *snd_usb_audio_probe(struct 
 	down(&register_mutex);
 	for (i = 0; i < SNDRV_CARDS; i++) {
 		if (usb_chip[i] && usb_chip[i]->dev == dev) {
-			chip = usb_chip[i];
-			if (chip->shutdown) {
+			if (usb_chip[i]->shutdown) {
 				snd_printk(KERN_ERR "USB device is in the shutdown state, cannot create a card instance\n");
 				goto __error;
 			}
+			chip = usb_chip[i];
 			break;
 		}
 	}
@@ -2863,17 +3001,9 @@ static void *snd_usb_audio_probe(struct 
 			if (enable[i] && ! usb_chip[i] &&
 			    (vid[i] == -1 || vid[i] == dev->descriptor.idVendor) &&
 			    (pid[i] == -1 || pid[i] == dev->descriptor.idProduct)) {
-				card = snd_card_new(index[i], id[i], THIS_MODULE, 0);
-				if (card == NULL) {
-					snd_printk(KERN_ERR "cannot create a card instance %d\n", i);
-					goto __error;
-				}
-				if (snd_usb_audio_create(card, dev, quirk, &chip) < 0) {
-					snd_card_free(card);
+				if (snd_usb_audio_create(dev, i, quirk, &chip) < 0) {
 					goto __error;
 				}
-				chip->index = i;
-				usb_chip[i] = chip;
 				break;
 			}
 		if (! chip) {
@@ -2899,16 +3029,17 @@ static void *snd_usb_audio_probe(struct 
 
 	/* we are allowed to call snd_card_register() many times */
 	if (snd_card_register(chip->card) < 0) {
-		if (! chip->num_interfaces)
-			snd_card_free(chip->card);
 		goto __error;
 	}
 
+	usb_chip[chip->index] = chip;
 	chip->num_interfaces++;
 	up(&register_mutex);
 	return chip;
 
  __error:
+	if (chip && !chip->num_interfaces)
+		snd_card_free(chip->card);
 	up(&register_mutex);
  __err_val:
 	return NULL;
@@ -2942,6 +3073,7 @@ static void snd_usb_audio_disconnect(str
 		list_for_each(p, &chip->midi_list) {
 			snd_usbmidi_disconnect(p, &usb_audio_driver);
 		}
+		usb_chip[chip->index] = NULL;
 		up(&register_mutex);
 		snd_card_free_in_thread(card);
 	} else {
diff -urNp linux-2.6.4/sound/usb/usbaudio.h linux-2.6.4.SUSE/sound/usb/usbaudio.h
--- linux-2.6.4/sound/usb/usbaudio.h	2004-03-24 15:30:19.000000000 +0100
+++ linux-2.6.4.SUSE/sound/usb/usbaudio.h	2004-03-24 15:30:39.000000000 +0100
@@ -207,7 +207,6 @@ void snd_usbmidi_disconnect(struct list_
  * (conditional for compatibility with the older API)
  */
 #ifndef get_iface_desc
-#define get_iface(cfg, num)	((cfg)->interface[(num)])
 #define get_iface_desc(iface)	(&(iface)->desc)
 #define get_endpoint(alt,ep)	(&(alt)->endpoint[ep].desc)
 #define get_ep_desc(ep)		(&(ep)->desc)
diff -urNp linux-2.6.4/sound/usb/usbmidi.c linux-2.6.4.SUSE/sound/usb/usbmidi.c
--- linux-2.6.4/sound/usb/usbmidi.c	2004-03-24 15:30:19.000000000 +0100
+++ linux-2.6.4.SUSE/sound/usb/usbmidi.c	2004-03-24 15:30:39.000000000 +0100
@@ -714,7 +714,6 @@ void snd_usbmidi_disconnect(struct list_
 		if (ep->in && ep->in->urb)
 			usb_unlink_urb(ep->in->urb);
 	}
-	usb_driver_release_interface(driver, umidi->iface);
 }
 
 static void snd_usbmidi_rawmidi_free(snd_rawmidi_t* rmidi)
