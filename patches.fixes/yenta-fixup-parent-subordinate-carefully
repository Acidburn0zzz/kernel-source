From: Bernhard Kaindl <bk@suse.de>
Subject: [PATCH] Cardbus cards hidden, fixup parent subordinate# carefully
References: bugzilla.novell.com:146438, bugzilla.kernel.org:2944

This patch is:

- Posted on lkml: Fri, 14 Apr 2006:
  http://www.spinics.net/lists/kernel/msg463423.html

- Part of the 2.5 PCMCIA tree since Thu, 13 Apr 2006:
  http://kernel.org/git/?p=linux/kernel/git/brodo/pcmcia-2.6.git;a=summary

  Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
  (current PCMCIA subsystem maintainer)

- Part of the -mm tree since (as part of pcmcia-git) since
  about the same time (soon 4 weeks as of 2006-05-12)

  Because there have been no problem reports from this,
  and the verifications done on varous notebooks (listed
  at the end), it could be considered stable.

Description of the patch:
=========================

Problem description and approach:
=================================

Short description:
------------------

This patch fixes detection of the CardBus cards in many notebooks
due to a too low subordinate number of the parent PCI-PCI bridge

It fixes the subordinate number of the parent PCI-PCI bridge of
CardBus bridges when one is probed, before registering the CardBus
bridge with the kernel and scanning its slot for devices.

Longer description:
-------------------

On a number of Laptops, the PCI scans do not find any CardBus cards
because the parent bridge of the CardBus bridge is not configured so
that Type 1 PCI configuration cycles can reach the CardBus cards.

On one of the affected Laptops, a Samsung X20, Windows XP does a
full pci bus renumbering, so the problem is not seen with Windows.

Booting with pci=assign-busses does the same but since ACPI may contain
references to PCI busses and we do not translate them yet, it may break
things.

The generic solution used in 2.6.13 was to only increase the subordinate
number, but since this was done during PCI bus discovery, it was not safe
to it at this point and taken out with the next release.

This patch does the same but takes care that it can never cause
create a PCI bus configuration with overlapping bus numbers which
was the reason why the solution of 2.6.13 was moved to pci=assign-busses.

Description of the fix:
=======================

Principles:
-----------

Reference: PCI-PCI Bridges: PCI Configuration Cycles and PCI Bus Numbering:
http://www.science.unitn.it/~fiorella/guidelinux/tlk/node72.html
---------------------------------------------------------------------------
It is up to each individual operating system to allocate bus numbers during
PCI configuration but whatever the numbering scheme used the following
statement must be true for all of the PCI-PCI bridges in the system:

``All PCI busses located behind a PCI-PCI bridge must reside between
  the seondary bus number and the subordinate bus number (inclusive).''  

If this rule is broken then the PCI-PCI Bridges will not pass and translate
Type 1 PCI configuration cycles correctly and the system will fail to find
and initialise the PCI devices in the system. 
---------------------------------------------------------------------------

What the patch needs to do in order to make the hidden devices work:
--------------------------------------------------------------------
The patch needs to ensure that the parent PCI-PCI bridge of the Cardbus
Controller is configured so that Type 1 PCI configuration cycles reach
the devices in the CardBus slots so that they are found and initialized

The only cases where it has been found that a parent bridge of
one or more cardbus bridges was not configured in this way were
numerous laptops where the parent bridge of the cardbus bridge
is a PCI-PCI bridge and it's subordinate bus number is lower
than the subordinate bus number of the cardbus bridge.

What the patch may not do:
--------------------------
The patch may not raise the subordinate number of any PCI-PCI bridge
so that it overlaps with the bus ranges of other PCI-PCI bridges.

What the patch does:
--------------------

Called from Cardbus controller probe function, before the controller
is registered, so before the devices on it can be scanned, a new
function call is inserted. This function works the following way:

> If the parent of the cardbus parent is a root bridge, do nothing.
  (The root bridge does not hide Cardbus devices, it was always ok)

> The parent of the cardbus bridge has been identified as the PCI-PCI
  bridge who's subordinate bus number may be raised to pass and
  translate Type 1 PCI configuration cycles so that they can
  reach the devices behind the CardBus brodge, it's called bridge_to_fix.

> The subordinate number the parent of the bridge_to_fix is used
  as the initial upper limit to which we could theoretically raise
  the subordinate number of the bridge_to_fix.
  (there is no point in exceeding the range of the parent, childs
   will got get Type 1 PCI configuration cycles for those anyway)

> For each child bridge of the parent bridge
  (equal to: for each silbling and the bridge_to_fix itself), do:
  
 -> If the silbling's secondary bus number is higher than the
    subordinate of the bridge_to_fix 
    (thus, it is a bridge which we have to care for when raising
     the subordinate of the bridge_to_fix to prevent overlapping)

    *and*

    if this silbling's secondary bus number is smaller than the
    upper limit, then update the upper limit to the secondary bus
    number of the silbling minus 1.

  This is repeated for all silbling bridges of the bridge_to_fix
  (and for the bridge_to_fix itself too, but for this to have
   any effect, it's secondary must be higher than it's subordinate
   which should never be the case but even if it is [then, the
   PCI config of it is totally broken and won't work anyway]
   is that the subordinate of it will only be raised to it's
   secondary minus one, so it won't have any effect)

-> The upper_limit is then left at the last free bus number to which
   the subordinate of the cardbus parent bridge could be raised without
   reaching a bus number which is allocated for a different silbling bridge
   on the same bus and without leaving the bus range of the parent.
  
   I tested these checks to work by modifying the relevant
   data structures and verifying the results, so I certify
   that with all these tests, the upper limit was always right.

   If this upper limit is lower than the subordinate number of the cardbus
   bridge, a warning message which says which shows this constraint for
   raising the subordinate of the bridge_to_fix is logged.

   If the upper limit is higher than the subordinate of the bridge_to_fix
   (this means it could be raised to this limit, it is never reduced,
    so nothing can break), the following is done:

     The subordnate bus number to assign is set to the upper_limit or
     to the subordinate bus number of the cardbus bridge (this is the
     number which we want to have), whatever value is smaller.

     A message which logs that we raise the subordinate number of
     bridge_to fix to its new value is logged.

     The subordinate field of the PCI struct of the bridge_to_fix
     is set to the new subordnate bus number and the PCI config byte
     PCI_SUBORDINATE_BUS is set to the new number.

That's it, see the patch itself for reference, this is written from
reading and checking the patch, not from memory. It also contains
comments to help you to match this description with the source,
but this description was not written from reading the comments,
only from checking the source, it's excatly what it really does
and since the patch was developed, it was tested on many machines,
and there are no error reports.

Systems where the patch has been verified:
* Compaq R3000 (AMD64-Turion Laptops)
* HP DV1448 
* Clevo D900T
* Samsung X20 series (also fixed in new BIOS, older BIOSes are affected)
* Thinkpad G40

Equally affected systems:
* Compaq R4000 series                                 
* HP SE L2000 amd64 Turion laptop
* HP zv5000z (AMD64 3700+) and HP zv5200z series
* Toshiba Satellite Pro A60
* IBM ThinkPads (a TP 240 and a TP debugged by Pavel Machek)
* Benq Joybook S72
* MSI S260 / Medion SIM 2100 MD 95600

Tested-by:     Bernhard Kaindl <bk@suse.de>
Tested-by:     Andreas Schneider <mail@cynapses.org>
Tested-by:     Alex Kavanagh <alex@tinwood.homelinux.org>
Tested-by:     Aaron Cohen <aaron@assonance.org>
Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
Signed-off-by: Bernhard Kaindl <bk@suse.de>

--- linux-2.4.17-rc1/drivers/pcmcia/yenta_socket.c
+++ linux-2.4.17-rc1/drivers/pcmcia/yenta_socket.c
@@ -998,6 +998,77 @@
 	config_writew(socket, CB_BRIDGE_CONTROL, bridge);
 }
 
+/**
+ * yenta_fixup_parent_subordinate - Fix subordinate bus# of the parent bridge
+ * @cardbus_bridge: The PCI bus which the CardBus bridge bridges to
+ *
+ * Checks if devices on the bus which the CardBus bridge bridges to would be
+ * invisible during PCI scans because of a misconfigured subordinate number
+ * of the parent brige - some BIOSes seem to be too lazy to set it right.
+ * Does the fixup carefully by checking how far it can go without conflicts.
+ * See http://bugzilla.kernel.org/show_bug.cgi?id=2944 for more information.
+ */
+static void yenta_fixup_parent_bridge(struct pci_bus *cardbus_bridge)
+{
+	struct list_head *tmp;
+	unsigned char upper_limit;
+ 	/*
+	 * We only check and fix the parent bridge: All systems which need
+	 * this fixup that have been reviewed are laptops and the only bridge
+	 * which needed fixing was the parent bridge of the CardBus bridge:
+	 */
+	struct pci_bus *bridge_to_fix = cardbus_bridge->parent;
+
+	/* Check bus numbers are already set up correctly: */
+	if (bridge_to_fix->subordinate >= cardbus_bridge->subordinate)
+		return; /* The subordinate number is ok, nothing to do */
+
+	if (!bridge_to_fix->parent)
+		return; /* Root bridges are ok */
+
+	/* stay within the limits of the bus range of the parent: */
+	upper_limit = bridge_to_fix->parent->subordinate;
+
+	/* check the bus ranges of all silbling bridges to prevent overlap */
+	list_for_each(tmp, &bridge_to_fix->parent->children) {
+		struct pci_bus * silbling = pci_bus_b(tmp);
+		/*
+		 * If the silbling has a higher secondary bus number
+		 * and it's secondary is equal or smaller than our
+		 * current upper limit, set the new upper limit to
+		 * the bus number below the silbling's range:
+		 */
+		if (silbling->secondary > bridge_to_fix->subordinate
+		    && silbling->secondary <= upper_limit)
+			upper_limit = silbling->secondary - 1;
+	}
+
+	/* Show that the wanted subordinate number is not possible: */
+	if (cardbus_bridge->subordinate > upper_limit)
+		printk(KERN_WARNING "Yenta: Upper limit for fixing this "
+			"bridge's parent bridge: #%02x\n", upper_limit);
+
+	/* If we have room to increase the bridge's subordinate number, */
+	if (bridge_to_fix->subordinate < upper_limit) {
+
+		/* use the highest number of the hidden bus, within limits */
+		unsigned char subordinate_to_assign =
+			min(cardbus_bridge->subordinate, upper_limit);
+
+		printk(KERN_INFO "Yenta: Raising subordinate bus# of parent "
+			"bus (#%02x) from #%02x to #%02x\n",
+			bridge_to_fix->number,
+			bridge_to_fix->subordinate, subordinate_to_assign);
+
+		/* Save the new subordinate in the bus struct of the bridge */
+		bridge_to_fix->subordinate = subordinate_to_assign;
+
+		/* and update the PCI config space with the new subordinate */
+		pci_write_config_byte(bridge_to_fix->self,
+			PCI_SUBORDINATE_BUS, bridge_to_fix->subordinate);
+	}
+}
+
 /*
  * Initialize a cardbus controller. Make sure we have a usable
  * interrupt, and that we can map the cardbus area. Fill in the
@@ -1113,6 +1184,8 @@ static int __devinit yenta_probe (struct
 	yenta_get_socket_capabilities(socket, isa_interrupts);
 	printk(KERN_INFO "Socket status: %08x\n", cb_readl(socket, CB_SOCKET_STATE));
 
+	yenta_fixup_parent_bridge(dev->subordinate);
+
 	/* Register it with the pcmcia layer.. */
 	ret = pcmcia_register_socket(&socket->socket);
 	if (ret == 0) {
