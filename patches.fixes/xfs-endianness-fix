From nboullis@debian.org:

Fix XFS recovery on 64-bit big-endian architectures

As it is currently written, the xfs_contig_bits function in xfs_bit.c, when
BITS_PER_LONG != 32, implicitely assumes that the arch is little-endian, as it
considers that the LSB of *((uint *)map) is the same as the LSB of *((unsigned
long int *)map).

This patch implements a rewrite of xfs_contig_bits, that is supposed to work on
all arches. Moreover, it adds two ASSERTs that would have been useful to track
this bug.

Index: linux-2.6.5/fs/xfs/xfs_bit.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/xfs_bit.c
+++ linux-2.6.5/fs/xfs/xfs_bit.c
@@ -238,32 +238,35 @@ xfs_count_bits(uint *map, uint size, uin
 int
 xfs_contig_bits(uint *map, uint	size, uint start_bit)
 {
-#if BITS_PER_LONG == 32
-	return find_next_zero_bit((unsigned long *)map,
-			size * sizeof(uint) * 8, start_bit) - start_bit;
-#else
-	/*
-	 * The first argument to find_next_zero_bit needs to be aligned,
-	 * but this is coming from the xfs_buf_log_format_t on-disk
-	 * struct, which can't be padded or otherwise modified w/o breaking
-	 * on-disk compatibility... so create a temporary, aligned
-	 * variable, copy over the bitmap, and send that to find_next_zero_bit
-	 * This only happens in recovery, so it's ugly but not too bad.
-	 */
-	void * addr;
-	int bit;
-	size_t bitmap_size = size * sizeof(uint);
-
-	addr = (void *)kmem_alloc(bitmap_size, KM_SLEEP);
-	memcpy(addr, map, size * sizeof(uint));
-
-	bit = find_next_zero_bit((unsigned long *)addr,
-			size * sizeof(uint) * 8, start_bit) - start_bit;
+	uint * p = ((unsigned int *) map) + (start_bit >> BIT_TO_WORD_SHIFT);
+	uint result = 0;
+	uint tmp;
 
-	kmem_free(addr, bitmap_size);
+	size <<= BIT_TO_WORD_SHIFT;
 
-	return bit;
-#endif
+	ASSERT(start_bit < size);
+	size -= start_bit & ~(NBWORD - 1);
+	start_bit &= (NBWORD - 1);
+	if (start_bit) {
+		tmp = *p++;
+		/* set to one first offset bits */
+		tmp |= (~0U >> (NBWORD-start_bit));
+		ASSERT(size >= NBWORD);
+		if (tmp != ~0U)
+			goto found;
+		result += NBWORD;
+		size -= NBWORD;
+	}
+	while (size >= NBWORD) {
+		if ((tmp = *p++) != ~0U)
+			goto found;
+		result += NBWORD;
+		size -= NBWORD;
+	}
+	ASSERT(!size);
+	return result - start_bit;
+found:
+	return result + ffz(tmp) - start_bit;
 }
 
 /*
Index: linux-2.6.5/fs/xfs/xfs_log_recover.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/xfs_log_recover.c
+++ linux-2.6.5/fs/xfs/xfs_log_recover.c
@@ -1867,6 +1867,7 @@ xlog_recover_do_inode_buffer(
 
 			nbits = xfs_contig_bits(data_map, map_size,
 							 bit);
+			ASSERT(nbits > 0);
 			reg_buf_offset = bit << XFS_BLI_SHIFT;
 			reg_buf_bytes = nbits << XFS_BLI_SHIFT;
 			item_index++;
@@ -1951,6 +1952,7 @@ xlog_recover_do_reg_buffer(
 		if (bit == -1)
 			break;
 		nbits = xfs_contig_bits(data_map, map_size, bit);
+		ASSERT(nbits > 0);
 		ASSERT(item->ri_buf[i].i_addr != 0);
 		ASSERT(item->ri_buf[i].i_len % XFS_BLI_CHUNK == 0);
 		ASSERT(XFS_BUF_COUNT(bp) >=
