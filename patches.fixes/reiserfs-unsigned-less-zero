Patch-mainline: 2.6.16-rc4-mm
References: 144058
Subject:  reiserfs: do not check if unsigned < 0

From: Vladimir V. Saveliev <vs@namesys.com>

This patch fixes bugs in reiserfs where unsigned integers were checked
whether they are less then 0.

This fixes a Ooops under high load.

Signed-off-by: Vladimir V. Saveliev <vs@namesys.com>
Cc: Neil Brown <neilb@cse.unsw.edu.au>
Signed-off-by: Hans Reiser <reiser@namesys.com>
Signed-off-by: Andrew Morton <akpm@osdl.org>
Acked-by: NeilBrown <neilb@suse.de>

Index: linux-2.6.15/fs/reiserfs/file.c
===================================================================
--- linux-2.6.15.orig/fs/reiserfs/file.c	2006-03-02 13:36:50.000000000 +1100
+++ linux-2.6.15/fs/reiserfs/file.c	2006-03-02 14:20:47.000000000 +1100
@@ -1481,13 +1481,11 @@
 		   partially overwritten pages, if needed. And lock the pages,
 		   so that nobody else can access these until we are done.
 		   We get number of actual blocks needed as a result. */
-		blocks_to_allocate =
-		    reiserfs_prepare_file_region_for_write(inode, pos,
-							   num_pages,
-							   write_bytes,
-							   prepared_pages);
-		if (blocks_to_allocate < 0) {
-			res = blocks_to_allocate;
+		res = reiserfs_prepare_file_region_for_write(inode, pos,
+							     num_pages,
+							     write_bytes,
+							     prepared_pages);
+		if (res < 0) {
 			reiserfs_release_claimed_blocks(inode->i_sb,
 							num_pages <<
 							(PAGE_CACHE_SHIFT -
@@ -1495,6 +1493,8 @@
 			break;
 		}
 
+		blocks_to_allocate = res;
+
 		/* First we correct our estimate of how many blocks we need */
 		reiserfs_release_claimed_blocks(inode->i_sb,
 						(num_pages <<
Index: linux-2.6.15/fs/reiserfs/inode.c
===================================================================
--- linux-2.6.15.orig/fs/reiserfs/inode.c	2006-03-02 13:34:17.000000000 +1100
+++ linux-2.6.15/fs/reiserfs/inode.c	2006-03-02 14:20:47.000000000 +1100
@@ -627,11 +627,6 @@
 	reiserfs_write_lock(inode->i_sb);
 	version = get_inode_item_key_version(inode);
 
-	if (block < 0) {
-		reiserfs_write_unlock(inode->i_sb);
-		return -EIO;
-	}
-
 	if (!file_capable(inode, block)) {
 		reiserfs_write_unlock(inode->i_sb);
 		return -EFBIG;
@@ -934,12 +929,13 @@
 				     //pos_in_item * inode->i_sb->s_blocksize,
 				     TYPE_INDIRECT, 3);	// key type is unimportant
 
+			RFALSE(cpu_key_k_offset(&tmp_key) > cpu_key_k_offset(&key),
+			       "green-805: invalid offset");
 			blocks_needed =
 			    1 +
 			    ((cpu_key_k_offset(&key) -
 			      cpu_key_k_offset(&tmp_key)) >> inode->i_sb->
 			     s_blocksize_bits);
-			RFALSE(blocks_needed < 0, "green-805: invalid offset");
 
 			if (blocks_needed == 1) {
 				un = &unf_single;
Index: linux-2.6.15/fs/reiserfs/journal.c
===================================================================
--- linux-2.6.15.orig/fs/reiserfs/journal.c	2006-03-02 13:34:17.000000000 +1100
+++ linux-2.6.15/fs/reiserfs/journal.c	2006-03-02 14:20:47.000000000 +1100
@@ -2319,8 +2319,7 @@
 		return 1;
 	}
 	jh = (struct reiserfs_journal_header *)(journal->j_header_bh->b_data);
-	if (le32_to_cpu(jh->j_first_unflushed_offset) >= 0 &&
-	    le32_to_cpu(jh->j_first_unflushed_offset) <
+	if (le32_to_cpu(jh->j_first_unflushed_offset) <
 	    SB_ONDISK_JOURNAL_SIZE(p_s_sb)
 	    && le32_to_cpu(jh->j_last_flush_trans_id) > 0) {
 		oldest_start =
