#41427: Better handle out-of-space errors

diff -urp linux-2.6.5-7.61/fs/jfs/jfs_dtree.c linux/fs/jfs/jfs_dtree.c
--- linux-2.6.5-7.61/fs/jfs/jfs_dtree.c	2004-05-30 15:54:32.000000000 -0500
+++ linux/fs/jfs/jfs_dtree.c	2004-05-31 16:31:14.250727248 -0500
@@ -378,6 +378,8 @@ static u32 add_index(tid_t tid, struct i
 		 * It's time to move the inline table to an external
 		 * page and begin to build the xtree
 		 */
+		if (dbAlloc(ip, 0, sbi->nbperpage, &xaddr))
+			goto clean_up;	/* No space */
 
 		/*
 		 * Save the table, we're going to overwrite it with the
@@ -394,8 +396,8 @@ static u32 add_index(tid_t tid, struct i
 		/*
 		 * Allocate the first block & add it to the xtree
 		 */
-		xaddr = 0;
 		if (xtInsert(tid, ip, 0, 0, sbi->nbperpage, &xaddr, 0)) {
+			/* This really shouldn't fail */
 			jfs_warn("add_index: xtInsert failed!");
 			memcpy(&jfs_ip->i_dirtable, temp_table,
 			       sizeof (temp_table));
diff -urp linux-2.6.5-7.61/fs/jfs/jfs_txnmgr.c linux/fs/jfs/jfs_txnmgr.c
--- linux-2.6.5-7.61/fs/jfs/jfs_txnmgr.c	2004-05-30 15:54:32.000000000 -0500
+++ linux/fs/jfs/jfs_txnmgr.c	2004-05-31 16:01:10.647916552 -0500
@@ -1747,7 +1747,10 @@ static void xtLog(struct jfs_log * log, 
 
 		if (lwm == next)
 			goto out;
-		assert(lwm < next);
+		if (lwm > next) {
+			jfs_err("xtLog: lwm > next\n");
+			goto out;
+		}
 		tlck->flag |= tlckUPDATEMAP;
 		xadlock->flag = mlckALLOCXADLIST;
 		xadlock->count = next - lwm;
@@ -2624,6 +2627,7 @@ void txAbort(tid_t tid, int dirty)
 	lid_t lid, next;
 	struct metapage *mp;
 	struct tblock *tblk = tid_to_tblock(tid);
+	struct tlock *tlck;
 
 	jfs_warn("txAbort: tid:%d dirty:0x%x", tid, dirty);
 
@@ -2631,9 +2635,10 @@ void txAbort(tid_t tid, int dirty)
 	 * free tlocks of the transaction
 	 */
 	for (lid = tblk->next; lid; lid = next) {
-		next = lid_to_tlock(lid)->next;
-
-		mp = lid_to_tlock(lid)->mp;
+		tlck = lid_to_tlock(lid);
+		next = tlck->next;
+		mp = tlck->mp;
+		JFS_IP(tlck->ip)->xtlid = 0;
 
 		if (mp) {
 			mp->lid = 0;
diff -urp linux-2.6.5-7.61/fs/jfs/namei.c linux/fs/jfs/namei.c
--- linux-2.6.5-7.61/fs/jfs/namei.c	2004-05-30 15:54:32.000000000 -0500
+++ linux/fs/jfs/namei.c	2004-05-31 13:03:38.113347960 -0500
@@ -953,7 +953,7 @@ static int jfs_symlink(struct inode *dip
 	unchar *i_fastsymlink;
 	s64 xlen = 0;
 	int bmask = 0, xsize;
-	s64 xaddr;
+	s64 extent = 0, xaddr;
 	struct metapage *mp;
 	struct super_block *sb;
 	struct tblock *tblk;
@@ -1011,15 +1011,6 @@ static int jfs_symlink(struct inode *dip
 
 	ino = ip->i_ino;
 
-
-
-	if ((rc = dtInsert(tid, dip, &dname, &ino, &btstack))) {
-		jfs_err("jfs_symlink: dtInsert returned %d", rc);
-		/* discard ne inode */
-		goto out3;
-
-	}
-
 	/* fix symlink access permission
 	 * (dir_create() ANDs in the u.u_cmask, 
 	 * but symlinks really need to be 777 access)
@@ -1027,7 +1018,7 @@ static int jfs_symlink(struct inode *dip
 	ip->i_mode |= 0777;
 
 	/*
-	   *       write symbolic link target path name
+	 * write symbolic link target path name
 	 */
 	xtInitRoot(tid, ip);
 
@@ -1069,39 +1060,40 @@ static int jfs_symlink(struct inode *dip
 		sb = ip->i_sb;
 		bmask = JFS_SBI(sb)->bsize - 1;
 		xsize = (ssize + bmask) & ~bmask;
-		xaddr = 0;
+		extent = xaddr = 0;
 		xlen = xsize >> JFS_SBI(sb)->l2bsize;
-		if ((rc = xtInsert(tid, ip, 0, 0, xlen, &xaddr, 0)) == 0) {
-			ip->i_size = ssize - 1;
-			while (ssize) {
-				int copy_size = min(ssize, PSIZE);
-
-				mp = get_metapage(ip, xaddr, PSIZE, 1);
-
-				if (mp == NULL) {
-					dtDelete(tid, dip, &dname, &ino,
-						 JFS_REMOVE);
-					rc = -EIO;
-					goto out3;
-				}
-				memcpy(mp->data, name, copy_size);
-				flush_metapage(mp);
-#if 0
-				set_buffer_uptodate(bp);
-				mark_buffer_dirty(bp, 1);
-				if (IS_SYNC(dip))
-					sync_dirty_buffer(bp);
-				brelse(bp);
-#endif				/* 0 */
-				ssize -= copy_size;
-				xaddr += JFS_SBI(sb)->nbperpage;
-			}
-			ip->i_blocks = LBLK2PBLK(sb, xlen);
-		} else {
-			dtDelete(tid, dip, &dname, &ino, JFS_REMOVE);
+		if ((rc = xtInsert(tid, ip, 0, 0, xlen, &xaddr, 0))) {
+			txAbort(tid, 0);
 			rc = -ENOSPC;
 			goto out3;
 		}
+		ip->i_size = ssize - 1;
+		while (ssize) {
+			int copy_size = min(ssize, PSIZE);
+
+			mp = get_metapage(ip, xaddr, PSIZE, 1);
+
+			if (mp == NULL) {
+				dbFree(ip, extent, xlen);
+				rc = -EIO;
+				txAbort(tid, 0);
+				goto out3;
+			}
+			memcpy(mp->data, name, copy_size);
+			flush_metapage(mp);
+			ssize -= copy_size;
+			xaddr += JFS_SBI(sb)->nbperpage;
+		}
+		ip->i_blocks = LBLK2PBLK(sb, xlen);
+	}
+
+	if ((rc = dtInsert(tid, dip, &dname, &ino, &btstack))) {
+		jfs_err("jfs_symlink: dtInsert returned %d", rc);
+		if (xlen)
+			dbFree(ip, extent, xlen);
+		txAbort(tid, 0);
+		/* discard new inode */
+		goto out3;
 	}
 
 	insert_inode_hash(ip);
@@ -1109,23 +1101,11 @@ static int jfs_symlink(struct inode *dip
 
 	/*
 	 * commit update of parent directory and link object
-	 *
-	 * if extent allocation failed (ENOSPC),
-	 * the parent inode is committed regardless to avoid
-	 * backing out parent directory update (by dtInsert())
-	 * and subsequent dtDelete() which is harmless wrt 
-	 * integrity concern.  
-	 * the symlink inode will be freed by iput() at exit
-	 * as it has a zero link count (by dtDelete()) and 
-	 * no permanant resources. 
 	 */
 
 	iplist[0] = dip;
-	if (rc == 0) {
-		iplist[1] = ip;
-		rc = txCommit(tid, 2, &iplist[0], 0);
-	} else
-		rc = txCommit(tid, 1, &iplist[0], 0);
+	iplist[1] = ip;
+	rc = txCommit(tid, 2, &iplist[0], 0);
 
       out3:
 	txEnd(tid);
