Date: Mon, 16 Jan 2006 14:55:49 +1100
From: Nathan Scott <nathans@sgi.com>
Subject: XFS behaviour modules

Enable modular extensions to XFS, e.g. xfs_quota.ko.

Acked-by: Andreas Gruenbacher <agruen@suse.de>

Index: linux/fs/xfs/xfs_acl.c
===================================================================
--- linux.orig/fs/xfs/xfs_acl.c
+++ linux/fs/xfs/xfs_acl.c
@@ -36,7 +36,6 @@
 #include "xfs_mac.h"
 #include "xfs_attr.h"
 
-#include <linux/capability.h>
 #include <linux/posix_acl_xattr.h>
 
 STATIC int	xfs_acl_setmode(vnode_t *, xfs_acl_t *, int *);
@@ -522,6 +521,7 @@
 
 	return xfs_acl_capability_check(md, cr);
 }
+EXPORT_SYMBOL(xfs_acl_access);
 
 /*
  * ACL validity checker.
Index: linux/fs/xfs/linux-2.6/xfs_vnode.h
===================================================================
--- linux.orig/fs/xfs/linux-2.6/xfs_vnode.h
+++ linux/fs/xfs/linux-2.6/xfs_vnode.h
@@ -199,6 +199,8 @@
 typedef int	(*vop_release_t)(bhv_desc_t *);
 typedef int	(*vop_rwlock_t)(bhv_desc_t *, vrwlock_t);
 typedef void	(*vop_rwunlock_t)(bhv_desc_t *, vrwlock_t);
+typedef	int	(*vop_frlock_t)(bhv_desc_t *, int, struct file_lock *,int,
+				xfs_off_t, struct cred *);
 typedef int	(*vop_bmap_t)(bhv_desc_t *, xfs_off_t, ssize_t, int,
 				struct xfs_iomap *, int *);
 typedef int	(*vop_reclaim_t)(bhv_desc_t *);
@@ -244,6 +246,7 @@
 	vop_fid2_t		vop_fid2;
 	vop_rwlock_t		vop_rwlock;
 	vop_rwunlock_t		vop_rwunlock;
+	vop_frlock_t		vop_frlock;
 	vop_bmap_t		vop_bmap;
 	vop_reclaim_t		vop_reclaim;
 	vop_attr_get_t		vop_attr_get;
@@ -357,6 +360,7 @@
 #define IO_ISAIO	0x00001		/* don't wait for completion */
 #define IO_ISDIRECT	0x00004		/* bypass page cache */
 #define IO_INVIS	0x00020		/* don't update inode timestamps */
+#define IO_ISLOCKED	0x00800		/* don't do inode locking */
 
 /*
  * Flags for VOP_IFLUSH call
Index: linux/fs/xfs/xfs_vfsops.c
===================================================================
--- linux.orig/fs/xfs/xfs_vfsops.c
+++ linux/fs/xfs/xfs_vfsops.c
@@ -1981,6 +1981,7 @@
 	.vfs_vget		= xfs_vget,
 	.vfs_dmapiops		= (vfs_dmapiops_t)fs_nosys,
 	.vfs_quotactl		= (vfs_quotactl_t)fs_nosys,
+	.vfs_get_inode		= xfs_get_inode,
 	.vfs_init_vnode		= xfs_initialize_vnode,
 	.vfs_force_shutdown	= xfs_do_force_shutdown,
 	.vfs_freeze		= xfs_freeze,
Index: linux/fs/xfs/linux-2.6/xfs_globals.c
===================================================================
--- linux.orig/fs/xfs/linux-2.6/xfs_globals.c
+++ linux/fs/xfs/linux-2.6/xfs_globals.c
@@ -37,6 +37,9 @@
 	.panic_mask	= {	0,		0,		127	},
 	.error_level	= {	0,		3,		11	},
 	.syncd_timer	= {	1*100,		30*100,		7200*100},
+	.probe_dmapi	= {	0,		1,		1	},
+	.probe_ioops	= {	0,		0,		1	},
+	.probe_quota	= {	0,		1,		1	},
 	.stats_clear	= {	0,		0,		1	},
 	.inherit_sync	= {	0,		1,		1	},
 	.inherit_nodump	= {	0,		1,		1	},
Index: linux/fs/xfs/linux-2.6/xfs_vfs.h
===================================================================
--- linux.orig/fs/xfs/linux-2.6/xfs_vfs.h
+++ linux/fs/xfs/linux-2.6/xfs_vfs.h
@@ -112,6 +112,7 @@
 				struct vnode *, bhv_desc_t *, int);
 typedef void	(*vfs_force_shutdown_t)(bhv_desc_t *, int, char *, int);
 typedef void	(*vfs_freeze_t)(bhv_desc_t *);
+typedef	struct inode * (*vfs_get_inode_t)(bhv_desc_t *, xfs_ino_t, int);
 
 typedef struct vfsops {
 	bhv_position_t		vf_position;	/* behavior chain position */
@@ -126,6 +127,7 @@
 	vfs_vget_t		vfs_vget;	/* get vnode from fid */
 	vfs_dmapiops_t		vfs_dmapiops;	/* data migration */
 	vfs_quotactl_t		vfs_quotactl;	/* disk quota */
+	vfs_get_inode_t		vfs_get_inode;	/* bhv specific iget */
 	vfs_init_vnode_t	vfs_init_vnode;	/* initialize a new vnode */
 	vfs_force_shutdown_t	vfs_force_shutdown;	/* crash and burn */
 	vfs_freeze_t		vfs_freeze;	/* freeze fs for snapshot */
@@ -146,6 +148,7 @@
 #define VFS_VGET(v, vpp,fidp, rv)	((rv) = vfs_vget(VHEAD(v), vpp,fidp))
 #define VFS_DMAPIOPS(v, p, rv)		((rv) = vfs_dmapiops(VHEAD(v), p))
 #define VFS_QUOTACTL(v, c,id,p, rv)	((rv) = vfs_quotactl(VHEAD(v), c,id,p))
+#define VFS_GET_INODE(v, ino, fl)	( vfs_get_inode(VHEAD(v), ino,fl) )
 #define VFS_INIT_VNODE(v, vp,b,ul)	( vfs_init_vnode(VHEAD(v), vp,b,ul) )
 #define VFS_FORCE_SHUTDOWN(v, fl,f,l)	( vfs_force_shutdown(VHEAD(v), fl,f,l) )
 #define VFS_FREEZE(v)			( vfs_freeze(VHEAD(v)) )
@@ -164,6 +167,7 @@
 #define PVFS_VGET(b, vpp,fidp, rv)	((rv) = vfs_vget(b, vpp,fidp))
 #define PVFS_DMAPIOPS(b, p, rv)		((rv) = vfs_dmapiops(b, p))
 #define PVFS_QUOTACTL(b, c,id,p, rv)	((rv) = vfs_quotactl(b, c,id,p))
+#define PVFS_GET_INODE(b, ino,fl)	( vfs_get_inode(b, ino,fl) )
 #define PVFS_INIT_VNODE(b, vp,b2,ul)	( vfs_init_vnode(b, vp,b2,ul) )
 #define PVFS_FORCE_SHUTDOWN(b, fl,f,l)	( vfs_force_shutdown(b, fl,f,l) )
 #define PVFS_FREEZE(b)			( vfs_freeze(b) )
@@ -179,15 +183,29 @@
 extern int vfs_vget(bhv_desc_t *, struct vnode **, struct fid *);
 extern int vfs_dmapiops(bhv_desc_t *, caddr_t);
 extern int vfs_quotactl(bhv_desc_t *, int, int, caddr_t);
+extern struct inode *vfs_get_inode(bhv_desc_t *, xfs_ino_t, int);
 extern void vfs_init_vnode(bhv_desc_t *, struct vnode *, bhv_desc_t *, int);
 extern void vfs_force_shutdown(bhv_desc_t *, int, char *, int);
 extern void vfs_freeze(bhv_desc_t *);
 
+#define XFS_DMOPS		"xfs_dm_operations"	/* Data Migration */
+#define XFS_QMOPS		"xfs_qm_operations"	/* Quota Manager  */
+#define XFS_IOOPS		"xfs_io_operations"	/* I/O subsystem  */
+#define XFS_DM_MODULE		"xfs_dmapi"
+#define XFS_QM_MODULE		"xfs_quota"
+#define XFS_IO_MODULE		"xfs_ioops"
+
 typedef struct bhv_vfsops {
 	struct vfsops		bhv_common;
 	void *			bhv_custom;
 } bhv_vfsops_t;
 
+typedef struct bhv_module {
+	bhv_desc_t		bm_desc;
+	const char *		bm_name;
+	bhv_vfsops_t *		bm_ops;
+} bhv_module_t;
+
 #define vfs_bhv_lookup(v, id)	( bhv_lookup_range(&(v)->vfs_bh, (id), (id)) )
 #define vfs_bhv_custom(b)	( ((bhv_vfsops_t *)BHV_OPS(b))->bhv_custom )
 #define vfs_bhv_set_custom(b,o)	( (b)->bhv_custom = (void *)(o))
@@ -198,6 +216,9 @@
 extern void vfs_insertops(vfs_t *, bhv_vfsops_t *);
 extern void vfs_insertbhv(vfs_t *, bhv_desc_t *, vfsops_t *, void *);
 
+extern void bhv_module_init(const char *, struct module *, const void *);
+extern void bhv_module_exit(const char *);
+extern void bhv_get_vfsops(struct vfs *, const char *, const char *);
 extern void bhv_insert_all_vfsops(struct vfs *);
 extern void bhv_remove_all_vfsops(struct vfs *, int);
 extern void bhv_remove_vfsops(struct vfs *, int);
Index: linux/fs/xfs/linux-2.6/xfs_sysctl.c
===================================================================
--- linux.orig/fs/xfs/linux-2.6/xfs_sysctl.c
+++ linux/fs/xfs/linux-2.6/xfs_sysctl.c
@@ -86,6 +86,21 @@
 	&sysctl_intvec, NULL,
 	&xfs_params.syncd_timer.min, &xfs_params.syncd_timer.max},
 
+	{XFS_PROBE_DMAPI, "probe_dmapi", &xfs_params.probe_dmapi.val,
+	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
+	&sysctl_intvec, NULL,
+	&xfs_params.probe_dmapi.min, &xfs_params.probe_dmapi.max},
+
+	{XFS_PROBE_IOOPS, "probe_ioops", &xfs_params.probe_ioops.val,
+	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
+	&sysctl_intvec, NULL,
+	&xfs_params.probe_ioops.min, &xfs_params.probe_ioops.max},
+
+	{XFS_PROBE_QUOTA, "probe_quota", &xfs_params.probe_quota.val,
+	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
+	&sysctl_intvec, NULL,
+	&xfs_params.probe_quota.min, &xfs_params.probe_quota.max},
+
 	{XFS_INHERIT_SYNC, "inherit_sync", &xfs_params.inherit_sync.val,
 	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
 	&sysctl_intvec, NULL,
Index: linux/fs/xfs/linux-2.6/xfs_super.c
===================================================================
--- linux.orig/fs/xfs/linux-2.6/xfs_super.c
+++ linux/fs/xfs/linux-2.6/xfs_super.c
@@ -238,6 +238,17 @@
 	}
 }
 
+struct inode *
+xfs_get_inode(
+	bhv_desc_t	*bdp,
+	xfs_ino_t	ino,
+	int		flags)
+{
+	struct vfs	*vfsp = bhvtovfs(bdp);
+
+	return iget_locked(vfsp->vfs_super, ino);
+}
+
 int
 xfs_blkdev_get(
 	xfs_mount_t		*mp,
@@ -976,7 +987,6 @@
 	vn_init();
 	xfs_init();
 	uuid_init();
-	vfs_initquota();
 
 	error = register_filesystem(&xfs_fs_type);
 	if (error)
@@ -997,7 +1007,6 @@
 STATIC void __exit
 exit_xfs_fs( void )
 {
-	vfs_exitquota();
 	XFS_DM_EXIT(&xfs_fs_type);
 	unregister_filesystem(&xfs_fs_type);
 	xfs_cleanup();
Index: linux/fs/xfs/quota/Makefile-linux-2.6
===================================================================
--- /dev/null
+++ linux/fs/xfs/quota/Makefile-linux-2.6
@@ -0,0 +1,40 @@
+#
+# Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.
+# All Rights Reserved.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it would be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write the Free Software Foundation,
+# Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+EXTRA_CFLAGS += -I $(TOPDIR)/fs/xfs -I $(TOPDIR)/fs/xfs/linux-2.6
+
+ifeq ($(CONFIG_XFS_DEBUG),y)
+	EXTRA_CFLAGS += -g -DDEBUG
+	#EXTRA_CFLAGS += -DQUOTADEBUG
+endif
+ifeq ($(CONFIG_XFS_TRACE),y)
+	EXTRA_CFLAGS += -DXFS_DQUOT_TRACE
+	EXTRA_CFLAGS += -DXFS_VNODE_TRACE
+endif
+
+obj-$(CONFIG_XFS_QUOTA)		+= xfs_quota.o
+
+xfs_quota-y			+= xfs_dquot.o \
+				   xfs_dquot_item.o \
+				   xfs_trans_dquot.o \
+				   xfs_qm_syscalls.o \
+				   xfs_qm_bhv.o \
+				   xfs_qm_ksyms.o \
+				   xfs_qm.o
+
+xfs_quota-$(CONFIG_PROC_FS)	+= xfs_qm_stats.o
Index: linux/fs/xfs/xfs_iget.c
===================================================================
--- linux.orig/fs/xfs/xfs_iget.c
+++ linux/fs/xfs/xfs_iget.c
@@ -492,7 +492,7 @@
 	XFS_STATS_INC(xs_ig_attempts);
 
 retry:
-	if ((inode = iget_locked(XFS_MTOVFS(mp)->vfs_super, ino))) {
+	if ((inode = VFS_GET_INODE(XFS_MTOVFS(mp), ino, 0))) {
 		xfs_inode_t	*ip;
 
 		vp = LINVFS_GET_VP(inode);
Index: linux/fs/xfs/quota/xfs_qm_bhv.c
===================================================================
--- linux.orig/fs/xfs/quota/xfs_qm_bhv.c
+++ linux/fs/xfs/quota/xfs_qm_bhv.c
@@ -356,7 +356,7 @@
 };
 
 
-void __init
+static int __init
 xfs_qm_init(void)
 {
 	static char	message[] __initdata =
@@ -365,16 +365,22 @@
 	printk(message);
 	mutex_init(&xfs_Gqm_lock);
 	vfs_bhv_set_custom(&xfs_qmops, &xfs_qmcore_xfs);
+	bhv_module_init(XFS_QMOPS, THIS_MODULE, &xfs_qmops);
 	xfs_qm_init_procfs();
+	return 0;
 }
 
-void __exit
+static void __exit
 xfs_qm_exit(void)
 {
-	vfs_bhv_clr_custom(&xfs_qmops);
 	xfs_qm_cleanup_procfs();
+	bhv_module_exit(XFS_QMOPS);
+	vfs_bhv_clr_custom(&xfs_qmops);
 	if (qm_dqzone)
 		kmem_cache_destroy(qm_dqzone);
 	if (qm_dqtrxzone)
 		kmem_cache_destroy(qm_dqtrxzone);
 }
+
+module_init(xfs_qm_init);
+module_exit(xfs_qm_exit);
Index: linux/fs/xfs/linux-2.6/xfs_sysctl.h
===================================================================
--- linux.orig/fs/xfs/linux-2.6/xfs_sysctl.h
+++ linux/fs/xfs/linux-2.6/xfs_sysctl.h
@@ -39,6 +39,9 @@
 	xfs_sysctl_val_t error_level;	/* Degree of reporting for problems  */
 	xfs_sysctl_val_t syncd_timer;	/* Interval between xfssyncd wakeups */
 	xfs_sysctl_val_t stats_clear;	/* Reset all XFS statistics to zero. */
+	xfs_sysctl_val_t probe_dmapi;	/* probe for DMAPI module on mount. */
+	xfs_sysctl_val_t probe_ioops;	/* probe for an IO module on mount. */
+	xfs_sysctl_val_t probe_quota;	/* probe for quota module on mount. */
 	xfs_sysctl_val_t inherit_sync;	/* Inherit the "sync" inode flag. */
 	xfs_sysctl_val_t inherit_nodump;/* Inherit the "nodump" inode flag. */
 	xfs_sysctl_val_t inherit_noatim;/* Inherit the "noatime" inode flag. */
@@ -72,9 +75,9 @@
 	XFS_PANIC_MASK = 6,
 	XFS_ERRLEVEL = 7,
 	XFS_SYNCD_TIMER = 8,
-	/* XFS_PROBE_DMAPI = 9 */
-	/* XFS_PROBE_IOOPS = 10 */
-	/* XFS_PROBE_QUOTA = 11 */
+	XFS_PROBE_DMAPI = 9,
+	XFS_PROBE_IOOPS = 10,
+	XFS_PROBE_QUOTA = 11,
 	XFS_STATS_CLEAR = 12,
 	XFS_INHERIT_SYNC = 13,
 	XFS_INHERIT_NODUMP = 14,
Index: linux/fs/xfs/quota/xfs_qm_ksyms.c
===================================================================
--- /dev/null
+++ linux/fs/xfs/quota/xfs_qm_ksyms.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2004 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write the Free Software Foundation,
+ * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include "xfs.h"
+#include "xfs_fs.h"
+#include "xfs_bit.h"
+#include "xfs_log.h"
+#include "xfs_inum.h"
+#include "xfs_trans.h"
+#include "xfs_sb.h"
+#include "xfs_ag.h"
+#include "xfs_dir.h"
+#include "xfs_dir2.h"
+#include "xfs_alloc.h"
+#include "xfs_dmapi.h"
+#include "xfs_quota.h"
+#include "xfs_mount.h"
+#include "xfs_bmap_btree.h"
+#include "xfs_alloc_btree.h"
+#include "xfs_ialloc_btree.h"
+#include "xfs_dir_sf.h"
+#include "xfs_dir2_sf.h"
+#include "xfs_attr_sf.h"
+#include "xfs_dinode.h"
+#include "xfs_inode.h"
+#include "xfs_ialloc.h"
+#include "xfs_btree.h"
+#include "xfs_qm.h"
+
+EXPORT_SYMBOL(xfs_Gqm);
+EXPORT_SYMBOL(xfs_qm_dqattach);
+EXPORT_SYMBOL(xfs_qm_dqpurge_all);
+EXPORT_SYMBOL(xfs_qm_dqrele_all_inodes);
+EXPORT_SYMBOL(xfs_qm_quotacheck);
+EXPORT_SYMBOL(xfs_trans_reserve_quota_bydquots);
+
+MODULE_AUTHOR("Silicon Graphics, Inc.");
+MODULE_DESCRIPTION("SGI XFS quota management subsystem");
+MODULE_LICENSE("GPL");
Index: linux/fs/xfs/linux-2.6/xfs_super.h
===================================================================
--- linux.orig/fs/xfs/linux-2.6/xfs_super.h
+++ linux/fs/xfs/linux-2.6/xfs_super.h
@@ -18,28 +18,6 @@
 #ifndef __XFS_SUPER_H__
 #define __XFS_SUPER_H__
 
-#ifdef CONFIG_XFS_DMAPI
-# define vfs_insertdmapi(vfs)	vfs_insertops(vfsp, &xfs_dmops)
-# define vfs_initdmapi()	dmapi_init()
-# define vfs_exitdmapi()	dmapi_uninit()
-#else
-# define vfs_insertdmapi(vfs)	do { } while (0)
-# define vfs_initdmapi()	do { } while (0)
-# define vfs_exitdmapi()	do { } while (0)
-#endif
-
-#ifdef CONFIG_XFS_QUOTA
-# define vfs_insertquota(vfs)	vfs_insertops(vfsp, &xfs_qmops)
-extern void xfs_qm_init(void);
-extern void xfs_qm_exit(void);
-# define vfs_initquota()	xfs_qm_init()
-# define vfs_exitquota()	xfs_qm_exit()
-#else
-# define vfs_insertquota(vfs)	do { } while (0)
-# define vfs_initquota()	do { } while (0)
-# define vfs_exitquota()	do { } while (0)
-#endif
-
 #ifdef CONFIG_XFS_POSIX_ACL
 # define XFS_ACL_STRING		"ACLs, "
 # define set_posix_acl_flag(sb)	((sb)->s_flags |= MS_POSIXACL)
@@ -80,8 +58,12 @@
 
 #ifdef CONFIG_XFS_DMAPI
 # define XFS_DMAPI_STRING	"dmapi support, "
+# define XFS_DM_INIT(fstype)	xfs_dm_init(fstype)
+# define XFS_DM_EXIT(fstype)	xfs_dm_exit(fstype)
 #else
 # define XFS_DMAPI_STRING
+# define XFS_DM_INIT(fstype)
+# define XFS_DM_EXIT(fstype)
 #endif
 
 #ifdef DEBUG
@@ -110,11 +92,15 @@
 
 extern __uint64_t xfs_max_file_offset(unsigned int);
 
+extern struct inode *xfs_get_inode(bhv_desc_t *, xfs_ino_t, int);
 extern void xfs_initialize_vnode(bhv_desc_t *, vnode_t *, bhv_desc_t *, int);
 
 extern void xfs_flush_inode(struct xfs_inode *);
 extern void xfs_flush_device(struct xfs_inode *);
 
+extern void xfs_dm_init(struct file_system_type *);
+extern void xfs_dm_exit(struct file_system_type *);
+
 extern int  xfs_blkdev_get(struct xfs_mount *, const char *,
 				struct block_device **);
 extern void xfs_blkdev_put(struct block_device *);
Index: linux/fs/xfs/linux-2.6/xfs_ksyms.c
===================================================================
--- /dev/null
+++ linux/fs/xfs/linux-2.6/xfs_ksyms.c
@@ -0,0 +1,332 @@
+/*
+ * Copyright (c) 2004-2005 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write the Free Software Foundation,
+ * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include "xfs.h"
+#include "xfs_fs.h"
+#include "xfs_bit.h"
+#include "xfs_buf.h"
+#include "xfs_log.h"
+#include "xfs_imap.h"
+#include "xfs_inum.h"
+#include "xfs_clnt.h"
+#include "xfs_trans.h"
+#include "xfs_sb.h"
+#include "xfs_ag.h"
+#include "xfs_dir.h"
+#include "xfs_dir2.h"
+#include "xfs_alloc.h"
+#include "xfs_dmapi.h"
+#include "xfs_quota.h"
+#include "xfs_mount.h"
+#include "xfs_da_btree.h"
+#include "xfs_bmap_btree.h"
+#include "xfs_alloc_btree.h"
+#include "xfs_ialloc_btree.h"
+#include "xfs_dir_sf.h"
+#include "xfs_dir2_sf.h"
+#include "xfs_attr_sf.h"
+#include "xfs_dinode.h"
+#include "xfs_inode.h"
+#include "xfs_btree.h"
+#include "xfs_ialloc.h"
+#include "xfs_bmap.h"
+#include "xfs_rtalloc.h"
+#include "xfs_error.h"
+#include "xfs_itable.h"
+#include "xfs_rw.h"
+#include "xfs_refcache.h"
+#include "xfs_dir_leaf.h"
+#include "xfs_dir2_data.h"
+#include "xfs_dir2_leaf.h"
+#include "xfs_dir2_block.h"
+#include "xfs_dir2_node.h"
+#include "xfs_dir2_trace.h"
+#include "xfs_acl.h"
+#include "xfs_cap.h"
+#include "xfs_mac.h"
+#include "xfs_attr.h"
+#include "xfs_attr_leaf.h"
+#include "xfs_inode_item.h"
+#include "xfs_buf_item.h"
+#include "xfs_extfree_item.h"
+#include "xfs_log_priv.h"
+#include "xfs_trans_priv.h"
+#include "xfs_trans_space.h"
+#include "xfs_utils.h"
+#include "xfs_iomap.h"
+#include "support/ktrace.h"
+
+
+/*
+ * Export symbols used for XFS tracing
+ */
+
+#if defined(CONFIG_XFS_TRACE)
+EXPORT_SYMBOL(ktrace_enter);
+EXPORT_SYMBOL(ktrace_free);
+EXPORT_SYMBOL(ktrace_alloc);
+EXPORT_SYMBOL(ktrace_skip);
+EXPORT_SYMBOL(ktrace_nentries);
+EXPORT_SYMBOL(ktrace_first);
+EXPORT_SYMBOL(ktrace_next);
+#endif
+
+#ifdef XFS_VNODE_TRACE
+EXPORT_SYMBOL(vn_trace_ref);
+EXPORT_SYMBOL(vn_trace_entry);
+EXPORT_SYMBOL(vn_trace_exit);
+EXPORT_SYMBOL(vn_trace_hold);
+EXPORT_SYMBOL(vn_trace_rele);
+#endif
+
+#ifdef XFS_ILOCK_TRACE
+EXPORT_SYMBOL(xfs_ilock_trace_buf);
+#endif
+#ifdef XFS_ALLOC_TRACE
+EXPORT_SYMBOL(xfs_alloc_trace_buf);
+#endif
+#ifdef XFS_BMAP_TRACE
+EXPORT_SYMBOL(xfs_bmap_trace_buf);
+#endif
+#ifdef XFS_BMBT_TRACE
+EXPORT_SYMBOL(xfs_bmbt_trace_buf);
+#endif
+#ifdef XFS_ATTR_TRACE
+EXPORT_SYMBOL(xfs_attr_trace_buf);
+#endif
+#ifdef XFS_DIR2_TRACE
+EXPORT_SYMBOL(xfs_dir2_trace_buf);
+#endif
+#ifdef XFS_DIR_TRACE
+EXPORT_SYMBOL(xfs_dir_trace_buf);
+#endif
+
+#ifdef XFS_BUF_TRACE
+extern ktrace_t *xfs_buf_trace_buf;
+EXPORT_SYMBOL(xfs_buf_trace_buf);
+#endif
+
+
+/*
+ * Export symbols used for XFS debugging
+ */
+EXPORT_SYMBOL(xfs_next_bit);
+EXPORT_SYMBOL(xfs_contig_bits);
+EXPORT_SYMBOL(xfs_bmbt_get_all);
+EXPORT_SYMBOL(xfs_params);
+#ifndef XFS_NATIVE_HOST
+EXPORT_SYMBOL(xfs_bmbt_disk_get_all);
+#endif
+
+#if defined(CONFIG_XFS_DEBUG)
+extern struct list_head xfs_buftarg_list;
+EXPORT_SYMBOL(xfs_buftarg_list);
+#endif
+
+/*
+ * Export symbols used by XFS behavior modules.
+ */
+
+EXPORT_SYMBOL(assfail);
+EXPORT_SYMBOL(cmn_err);
+EXPORT_SYMBOL(bhv_base);
+EXPORT_SYMBOL(bhv_get_vfsops);
+EXPORT_SYMBOL(bhv_head_destroy);
+EXPORT_SYMBOL(bhv_insert);
+EXPORT_SYMBOL(bhv_insert_initial);
+EXPORT_SYMBOL(bhv_lookup);
+EXPORT_SYMBOL(bhv_lookup_range);
+EXPORT_SYMBOL(bhv_module_init);
+EXPORT_SYMBOL(bhv_module_exit);
+EXPORT_SYMBOL(bhv_remove_vfsops);
+EXPORT_SYMBOL(bhv_remove_all_vfsops);
+EXPORT_SYMBOL(bhv_remove_not_first);
+EXPORT_SYMBOL(fs_flush_pages);
+EXPORT_SYMBOL(fs_flushinval_pages);
+EXPORT_SYMBOL(fs_tosspages);
+EXPORT_SYMBOL(fs_noval);
+EXPORT_SYMBOL(icmn_err);
+EXPORT_SYMBOL(kmem_alloc);
+EXPORT_SYMBOL(kmem_free);
+EXPORT_SYMBOL(kmem_realloc);
+EXPORT_SYMBOL(kmem_shake_deregister);
+EXPORT_SYMBOL(kmem_shake_register);
+EXPORT_SYMBOL(kmem_zalloc);
+EXPORT_SYMBOL(kmem_zone_alloc);
+EXPORT_SYMBOL(kmem_zone_free);
+EXPORT_SYMBOL(kmem_zone_init);
+EXPORT_SYMBOL(kmem_zone_zalloc);
+EXPORT_SYMBOL(linvfs_aops);
+EXPORT_SYMBOL(linvfs_dir_inode_operations);
+EXPORT_SYMBOL(linvfs_dir_operations);
+EXPORT_SYMBOL(linvfs_file_inode_operations);
+EXPORT_SYMBOL(linvfs_file_operations);
+EXPORT_SYMBOL(linvfs_invis_file_operations);
+EXPORT_SYMBOL(linvfs_symlink_inode_operations);
+EXPORT_SYMBOL(xfs_buf_delwri_dequeue);
+EXPORT_SYMBOL(_xfs_buf_find);
+EXPORT_SYMBOL(xfs_buf_iostart);
+EXPORT_SYMBOL(xfs_buf_ispin);
+#ifdef DEBUG
+EXPORT_SYMBOL(xfs_buf_lock_value);
+#endif
+EXPORT_SYMBOL(xfs_buf_offset);
+EXPORT_SYMBOL(xfs_buf_rele);
+EXPORT_SYMBOL(xfs_buf_readahead);
+EXPORT_SYMBOL(xfs_buf_unlock);
+#if ((defined(DEBUG) || defined(INDUCE_IO_ERROR)) && !defined(NO_WANT_RANDOM))
+EXPORT_SYMBOL(random);
+#endif
+EXPORT_SYMBOL(sys_cred);
+EXPORT_SYMBOL(uuid_create_nil);
+EXPORT_SYMBOL(uuid_equal);
+EXPORT_SYMBOL(uuid_getnodeuniq);
+EXPORT_SYMBOL(uuid_hash64);
+EXPORT_SYMBOL(uuid_is_nil);
+EXPORT_SYMBOL(uuid_table_remove);
+EXPORT_SYMBOL(vfs_mount);
+EXPORT_SYMBOL(vfs_parseargs);
+EXPORT_SYMBOL(vfs_showargs);
+EXPORT_SYMBOL(vfs_unmount);
+EXPORT_SYMBOL(vfs_mntupdate);
+EXPORT_SYMBOL(vfs_root);
+EXPORT_SYMBOL(vfs_statvfs);
+EXPORT_SYMBOL(vfs_sync);
+EXPORT_SYMBOL(vfs_vget);
+EXPORT_SYMBOL(vfs_dmapiops);
+EXPORT_SYMBOL(vfs_quotactl);
+EXPORT_SYMBOL(vfs_get_inode);
+EXPORT_SYMBOL(vfs_init_vnode);
+EXPORT_SYMBOL(vfs_force_shutdown);
+EXPORT_SYMBOL(vn_hold);
+EXPORT_SYMBOL(vn_initialize);
+EXPORT_SYMBOL(vn_revalidate);
+EXPORT_SYMBOL(vn_revalidate_core);
+
+#if defined(CONFIG_XFS_POSIX_ACL)
+EXPORT_SYMBOL(xfs_acl_vtoacl);
+EXPORT_SYMBOL(xfs_acl_inherit);
+#endif
+EXPORT_SYMBOL(xfs_alloc_buftarg);
+EXPORT_SYMBOL(xfs_flush_buftarg);
+EXPORT_SYMBOL(xfs_free_buftarg);
+EXPORT_SYMBOL(xfs_bdstrat_cb);
+EXPORT_SYMBOL(xfs_bmap_cancel);
+EXPORT_SYMBOL(xfs_bmap_do_search_extents);
+EXPORT_SYMBOL(xfs_bmap_finish);
+EXPORT_SYMBOL(xfs_bmapi);
+EXPORT_SYMBOL(xfs_bmapi_single);
+EXPORT_SYMBOL(xfs_bmbt_get_blockcount);
+EXPORT_SYMBOL(xfs_bmbt_get_state);
+EXPORT_SYMBOL(xfs_bmbt_get_startoff);
+EXPORT_SYMBOL(xfs_bmbt_set_all);
+EXPORT_SYMBOL(xfs_bmbt_set_allf);
+EXPORT_SYMBOL(xfs_bmbt_set_blockcount);
+EXPORT_SYMBOL(xfs_bmbt_set_startblock);
+EXPORT_SYMBOL(xfs_bmbt_set_startoff);
+EXPORT_SYMBOL(xfs_bmbt_set_state);
+EXPORT_SYMBOL(xfs_buf_attach_iodone);
+EXPORT_SYMBOL(xfs_bulkstat);
+EXPORT_SYMBOL(xfs_bunmapi);
+EXPORT_SYMBOL(xfs_bwrite);
+EXPORT_SYMBOL(xfs_change_file_space);
+EXPORT_SYMBOL(xfs_chashlist_zone);
+EXPORT_SYMBOL(xfs_dev_is_read_only);
+EXPORT_SYMBOL(xfs_dir_ialloc);
+EXPORT_SYMBOL(xfs_error_report);
+#ifdef DEBUG
+EXPORT_SYMBOL(xfs_error_trap);
+#endif
+EXPORT_SYMBOL(xfs_file_last_byte);
+EXPORT_SYMBOL(xfs_finish_reclaim_all);
+EXPORT_SYMBOL(xfs_freesb);
+EXPORT_SYMBOL(xfs_fs_cmn_err);
+EXPORT_SYMBOL(xfs_highbit32);
+EXPORT_SYMBOL(xfs_highbit64);
+EXPORT_SYMBOL(xfs_idestroy);
+EXPORT_SYMBOL(xfs_iextract);
+EXPORT_SYMBOL(xfs_iflock);
+EXPORT_SYMBOL(xfs_iflock_nowait);
+EXPORT_SYMBOL(xfs_iflush);
+EXPORT_SYMBOL(xfs_ifunlock);
+EXPORT_SYMBOL(xfs_iget);
+EXPORT_SYMBOL(xfs_igrow_start);
+EXPORT_SYMBOL(xfs_igrow_finish);
+EXPORT_SYMBOL(xfs_ilock);
+EXPORT_SYMBOL(xfs_ilock_map_shared);
+EXPORT_SYMBOL(xfs_ilock_nowait);
+EXPORT_SYMBOL(xfs_inode_lock_init);
+EXPORT_SYMBOL(xfs_iocore_inode_init);
+EXPORT_SYMBOL(xfs_iocore_xfs);
+EXPORT_SYMBOL(xfs_iomap);
+EXPORT_SYMBOL(xfs_iput);
+EXPORT_SYMBOL(xfs_iput_new);
+EXPORT_SYMBOL(xfs_iread);
+EXPORT_SYMBOL(xfs_iread_extents);
+EXPORT_SYMBOL(xfs_itruncate_start);
+EXPORT_SYMBOL(xfs_iunlock);
+EXPORT_SYMBOL(xfs_iunlock_map_shared);
+EXPORT_SYMBOL(xfs_itruncate_finish);
+EXPORT_SYMBOL(_xfs_log_force);
+EXPORT_SYMBOL(xfs_log_force_umount);
+EXPORT_SYMBOL(xfs_log_unmount_dealloc);
+EXPORT_SYMBOL(xfs_log_unmount_write);
+EXPORT_SYMBOL(xfs_mod_sb);
+EXPORT_SYMBOL(xfs_mount_free);
+EXPORT_SYMBOL(xfs_mount_init);
+EXPORT_SYMBOL(xfs_mount_reset_sbqflags);
+EXPORT_SYMBOL(xfs_mountfs);
+EXPORT_SYMBOL(xfs_qm_dqcheck);
+EXPORT_SYMBOL(xfs_readsb);
+EXPORT_SYMBOL(xfs_read_buf);
+EXPORT_SYMBOL(xfs_rwlock);
+EXPORT_SYMBOL(xfs_rwunlock);
+EXPORT_SYMBOL(xfs_setsize_buftarg);
+EXPORT_SYMBOL(xfs_syncsub);
+EXPORT_SYMBOL(xfs_sync_inodes);
+EXPORT_SYMBOL(xfs_trans_add_item);
+EXPORT_SYMBOL(xfs_trans_alloc);
+EXPORT_SYMBOL(xfs_trans_bhold);
+EXPORT_SYMBOL(xfs_trans_bhold_release);
+EXPORT_SYMBOL(xfs_trans_bjoin);
+EXPORT_SYMBOL(xfs_trans_brelse);
+EXPORT_SYMBOL(xfs_trans_cancel);
+EXPORT_SYMBOL(_xfs_trans_commit);
+EXPORT_SYMBOL(xfs_trans_delete_ail);
+EXPORT_SYMBOL(xfs_trans_dquot_buf);
+EXPORT_SYMBOL(xfs_trans_find_item);
+EXPORT_SYMBOL(xfs_trans_get_buf);
+EXPORT_SYMBOL(xfs_trans_iget);
+EXPORT_SYMBOL(xfs_trans_ihold);
+EXPORT_SYMBOL(xfs_trans_ijoin);
+EXPORT_SYMBOL(xfs_trans_log_buf);
+EXPORT_SYMBOL(xfs_trans_log_inode);
+EXPORT_SYMBOL(xfs_trans_mod_sb);
+EXPORT_SYMBOL(xfs_trans_read_buf);
+EXPORT_SYMBOL(xfs_trans_reserve);
+EXPORT_SYMBOL(xfs_trans_unlocked_item);
+EXPORT_SYMBOL(xfs_truncate_file);
+EXPORT_SYMBOL(xfs_unmount_flush);
+EXPORT_SYMBOL(xfs_unmountfs_writesb);
+EXPORT_SYMBOL(xfs_vfsops);
+EXPORT_SYMBOL(xfs_vnodeops);
+EXPORT_SYMBOL(xfs_write_clear_setuid);
+EXPORT_SYMBOL(xfs_xlate_dinode_core);
+EXPORT_SYMBOL(xfs_xlatesb);
+EXPORT_SYMBOL(xfs_zero_eof);
+EXPORT_SYMBOL(xlog_recover_process_iunlinks);
+EXPORT_SYMBOL(xfs_ichgtime_fast);
Index: linux/fs/xfs/linux-2.6/xfs_vfs.c
===================================================================
--- linux.orig/fs/xfs/linux-2.6/xfs_vfs.c
+++ linux/fs/xfs/linux-2.6/xfs_vfs.c
@@ -184,6 +184,19 @@
 	return ((*bhvtovfsops(next)->vfs_quotactl)(next, cmd, id, addr));
 }
 
+struct inode *
+vfs_get_inode(
+	struct bhv_desc		*bdp,
+	xfs_ino_t		ino,
+	int			fl)
+{
+	struct bhv_desc		*next = bdp;
+
+	while (! (bhvtovfsops(next))->vfs_get_inode)
+		next = BHV_NEXTNULL(next);
+	return ((*bhvtovfsops(next)->vfs_get_inode)(next, ino, fl));
+}
+
 void
 vfs_init_vnode(
 	struct bhv_desc		*bdp,
@@ -270,6 +283,98 @@
 	bhv_insert_initial(&vfsp->vfs_bh, bdp);
 }
 
+/*
+ * Implementation for behaviours-as-modules
+ */
+
+typedef struct bhv_module_list {
+	struct list_head	bm_list;
+	struct module *		bm_module;
+	const char *		bm_name;
+	void *			bm_ops;
+} bhv_module_list_t;
+STATIC DEFINE_SPINLOCK(bhv_lock);
+STATIC struct list_head bhv_list = LIST_HEAD_INIT(bhv_list);
+
+void
+bhv_module_init(
+	const char		*name,
+	struct module		*module,
+	const void		*ops)
+{
+	bhv_module_list_t	*bm, *entry, *n;
+
+	bm = kmem_alloc(sizeof(struct bhv_module_list), KM_SLEEP);
+	INIT_LIST_HEAD(&bm->bm_list);
+	bm->bm_module = module;
+	bm->bm_name = name;
+	bm->bm_ops = (void *)ops;
+
+	spin_lock(&bhv_lock);
+	list_for_each_entry_safe(entry, n, &bhv_list, bm_list)
+		BUG_ON(strcmp(entry->bm_name, name) == 0);
+	list_add(&bm->bm_list, &bhv_list);
+	spin_unlock(&bhv_lock);
+}
+
+void
+bhv_module_exit(
+	const char		*name)
+{
+	bhv_module_list_t	*entry, *n;
+
+	spin_lock(&bhv_lock);
+	list_for_each_entry_safe(entry, n, &bhv_list, bm_list)
+		if (strcmp(entry->bm_name, name) == 0)
+			list_del(&entry->bm_list);
+	spin_unlock(&bhv_lock);
+}
+
+STATIC void *
+bhv_insert_module(
+	const char		*name,
+	const char		*modname)
+{
+	bhv_module_list_t	*entry, *n;
+	void			*ops = NULL;
+
+	spin_lock(&bhv_lock);
+	list_for_each_entry_safe(entry, n, &bhv_list, bm_list)
+		if (strcmp(entry->bm_name, name) == 0 &&
+		    try_module_get(entry->bm_module))
+			ops = entry->bm_ops;
+	spin_unlock(&bhv_lock);
+	return ops;
+}
+
+STATIC void
+bhv_remove_module(
+	const char		*name)
+{
+	bhv_module_list_t	*entry, *n;
+
+	spin_lock(&bhv_lock);
+	list_for_each_entry_safe(entry, n, &bhv_list, bm_list)
+		if (strcmp(entry->bm_name, name) == 0)
+		    module_put(entry->bm_module);
+	spin_unlock(&bhv_lock);
+}
+
+STATIC void *
+bhv_lookup_module(
+	const char		*name,
+	const char		*module)
+{
+	void			*ops;
+
+	ops = bhv_insert_module(name, module);
+	if (!ops && module) {
+		request_module("%s", module);
+		ops = bhv_insert_module(name, module);
+	}
+	return ops;
+}
+
 void
 bhv_remove_vfsops(
 	struct vfs		*vfsp,
@@ -278,10 +383,14 @@
 	struct bhv_desc		*bhv;
 
 	bhv = bhv_lookup_range(&vfsp->vfs_bh, pos, pos);
-	if (!bhv)
-		return;
-	bhv_remove(&vfsp->vfs_bh, bhv);
-	kmem_free(bhv, sizeof(*bhv));
+	if (bhv) {
+		struct bhv_module	*bm;
+
+		bm = (bhv_module_t *) BHV_PDATA(bhv);
+		bhv_remove(&vfsp->vfs_bh, bhv);
+		bhv_remove_module(bm->bm_name);
+		kmem_free(bhv, sizeof(*bhv));
+	}
 }
 
 void
@@ -293,6 +402,7 @@
 
 	bhv_remove_vfsops(vfsp, VFS_POSITION_QM);
 	bhv_remove_vfsops(vfsp, VFS_POSITION_DM);
+	bhv_remove_vfsops(vfsp, VFS_POSITION_IO);
 	if (!freebase)
 		return;
 	mp = XFS_BHVTOM(bhv_lookup(VFS_BHVHEAD(vfsp), &xfs_vfsops));
@@ -301,6 +411,25 @@
 }
 
 void
+bhv_get_vfsops(
+	struct vfs		*vfsp,
+	const char		*name,
+	const char		*module)
+{
+	struct bhv_vfsops	*ops;
+
+	ops = (struct bhv_vfsops *) bhv_lookup_module(name, module);
+	if (ops) {
+		struct bhv_module	*bm;
+
+		bm = kmem_alloc(sizeof(struct bhv_module), KM_SLEEP);
+		bm->bm_name = name;
+		bhv_desc_init(&bm->bm_desc, bm, vfsp, ops);
+		bhv_insert(&vfsp->vfs_bh, &bm->bm_desc);
+	}
+}
+
+void
 bhv_insert_all_vfsops(
 	struct vfs		*vfsp)
 {
@@ -308,6 +437,10 @@
 
 	mp = xfs_mount_init();
 	vfs_insertbhv(vfsp, &mp->m_bhv, &xfs_vfsops, mp);
-	vfs_insertdmapi(vfsp);
-	vfs_insertquota(vfsp);
+	bhv_get_vfsops(vfsp, XFS_DMOPS,
+		xfs_probe_dmapi ? XFS_DM_MODULE : NULL);
+	bhv_get_vfsops(vfsp, XFS_QMOPS,
+		xfs_probe_quota ? XFS_QM_MODULE : NULL);
+	bhv_get_vfsops(vfsp, XFS_IOOPS,
+		xfs_probe_ioops ? XFS_IO_MODULE : NULL);
 }
Index: linux/fs/xfs/Kconfig
===================================================================
--- linux.orig/fs/xfs/Kconfig
+++ linux/fs/xfs/Kconfig
@@ -25,7 +25,7 @@
 	default y
 
 config XFS_QUOTA
-	bool "XFS Quota support"
+	tristate "XFS Quota support"
 	depends on XFS_FS
 	help
 	  If you say Y here, you will be able to set limits for disk usage on
Index: linux/fs/xfs/quota/Makefile
===================================================================
--- /dev/null
+++ linux/fs/xfs/quota/Makefile
@@ -0,0 +1 @@
+include $(TOPDIR)/fs/xfs/quota/Makefile-linux-$(VERSION).$(PATCHLEVEL)
Index: linux/fs/xfs/Makefile-linux-2.6
===================================================================
--- linux.orig/fs/xfs/Makefile-linux-2.6
+++ linux/fs/xfs/Makefile-linux-2.6
@@ -36,7 +36,7 @@
 
 ifeq ($(CONFIG_XFS_DEBUG),y)
 	EXTRA_CFLAGS += -g -DSTATIC="" -DDEBUG
-	EXTRA_CFLAGS += -DPAGEBUF_LOCK_TRACKING
+	EXTRA_CFLAGS += -DXFS_BUF_LOCK_TRACKING
 endif
 ifeq ($(CONFIG_XFS_TRACE),y)
 	EXTRA_CFLAGS += -DXFS_ALLOC_TRACE
@@ -50,23 +50,15 @@
 	EXTRA_CFLAGS += -DXFS_ILOCK_TRACE
 	EXTRA_CFLAGS += -DXFS_LOG_TRACE
 	EXTRA_CFLAGS += -DXFS_RW_TRACE
-	EXTRA_CFLAGS += -DPAGEBUF_TRACE
+	EXTRA_CFLAGS += -DXFS_BUF_TRACE
 	EXTRA_CFLAGS += -DXFS_VNODE_TRACE
 endif
+ifeq ($(CONFIG_XFS_DMAPI),y)
+	EXTRA_CFLAGS += -I $(TOPDIR)/fs/dmapi
+endif
 
 obj-$(CONFIG_XFS_FS)		+= xfs.o
-
-xfs-$(CONFIG_XFS_QUOTA)		+= $(addprefix quota/, \
-				   xfs_dquot.o \
-				   xfs_dquot_item.o \
-				   xfs_trans_dquot.o \
-				   xfs_qm_syscalls.o \
-				   xfs_qm_bhv.o \
-				   xfs_qm.o)
-
-ifeq ($(CONFIG_XFS_QUOTA),y)
-xfs-$(CONFIG_PROC_FS)		+= quota/xfs_qm_stats.o
-endif
+obj-$(CONFIG_XFS_QUOTA)		+= quota/
 
 xfs-$(CONFIG_XFS_RT)		+= xfs_rtalloc.o
 xfs-$(CONFIG_XFS_POSIX_ACL)	+= xfs_acl.o
@@ -80,7 +72,6 @@
 				   xfs_alloc_btree.o \
 				   xfs_attr.o \
 				   xfs_attr_leaf.o \
-				   xfs_behavior.o \
 				   xfs_bit.o \
 				   xfs_bmap.o \
 				   xfs_bmap_btree.o \
@@ -104,7 +95,6 @@
 				   xfs_inode.o \
 				   xfs_inode_item.o \
 				   xfs_iocore.o \
-				   xfs_iomap.o \
 				   xfs_itable.o \
 				   xfs_dfrag.o \
 				   xfs_log.o \
@@ -121,16 +111,17 @@
 				   xfs_vfsops.o \
 				   xfs_vnodeops.o \
 				   xfs_rw.o \
+				   xfs_behavior.o \
+				   xfs_iomap.o \
 				   xfs_dmops.o \
 				   xfs_qmops.o
 
 xfs-$(CONFIG_XFS_TRACE)		+= xfs_dir2_trace.o
 
+
 # Objects in linux/
 xfs-y				+= $(addprefix $(XFS_LINUX)/, \
-				   kmem.o \
 				   xfs_aops.o \
-				   xfs_buf.o \
 				   xfs_file.o \
 				   xfs_fs_subr.o \
 				   xfs_globals.o \
@@ -139,7 +130,10 @@
 				   xfs_lrw.o \
 				   xfs_super.o \
 				   xfs_vfs.o \
-				   xfs_vnode.o)
+				   xfs_vnode.o \
+				   xfs_buf.o \
+				   xfs_ksyms.o \
+				   kmem.o)
 
 # Objects in support/
 xfs-y				+= $(addprefix support/, \
Index: linux/fs/xfs/linux-2.6/xfs_linux.h
===================================================================
--- linux.orig/fs/xfs/linux-2.6/xfs_linux.h
+++ linux/fs/xfs/linux-2.6/xfs_linux.h
@@ -117,6 +117,9 @@
 #define xfs_panic_mask		xfs_params.panic_mask.val
 #define xfs_error_level		xfs_params.error_level.val
 #define xfs_syncd_centisecs	xfs_params.syncd_timer.val
+#define xfs_probe_dmapi		xfs_params.probe_dmapi.val
+#define xfs_probe_ioops		xfs_params.probe_ioops.val
+#define xfs_probe_quota		xfs_params.probe_quota.val
 #define xfs_stats_clear		xfs_params.stats_clear.val
 #define xfs_inherit_sync	xfs_params.inherit_sync.val
 #define xfs_inherit_nodump	xfs_params.inherit_nodump.val
