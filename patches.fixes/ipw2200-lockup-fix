From: Olaf Kirch <okir@suse.de>
Subject: ipw2200 - release semaphore when sleeping in ipw_request_direct_scan
References: 133513

  When ipw_request_direct_scan finds there is a scan in progress, it
  will go to sleep until the other scan is complete.

  This causes frequent deadlocks: wpa_supplicant triggers the scan, and
  blocks. Note that this will first take the rtnl_lock (this is an
  ioctl), and then the ipw2200 interface's priv->sem.
  
  The ipw2200 worker thread also tries to do something and blocks on
  priv->sem.

  events/0 is trying run the linkwatch_queue (net/core/link_watch.c),
  and tries to take the rtnl lock but blocks as well. While it does that,
  it holds the lock_cpu_hotplug() lock for its CPU, effectively blocking
  all sorts of other tasks that try to perform a flush_workqueue on some
  work queue.

  For some odd reason, the SCAN_COMPLETED notification never arrives, so
  things remain stuck.

  For sysrq-t ouput and other details, see
  https://bugzilla.novell.com/show_bug.cgi?id=133513

Signed-off-by: Olaf Kirch <okir@suse.de>

 drivers/net/wireless/ipw2200.c |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletion(-)

Index: build/drivers/net/wireless/ipw2200.c
===================================================================
--- build.orig/drivers/net/wireless/ipw2200.c
+++ build/drivers/net/wireless/ipw2200.c
@@ -5937,6 +5937,7 @@ static void ipw_abort_scan(struct ipw_pr
 		return;
 	}
 	priv->status |= STATUS_SCAN_ABORTING;
+	wake_up_interruptible(&priv->wait_state);
 
 	err = ipw_send_scan_abort(priv);
 	if (err)
@@ -8929,6 +8930,7 @@ static int ipw_request_direct_scan(struc
 	    (priv->status & STATUS_EXIT_PENDING))
 		return 0;
 
+again:
 	down(&priv->sem);
 
 	if (priv->status & STATUS_RF_KILL_MASK) {
@@ -8940,14 +8942,20 @@ static int ipw_request_direct_scan(struc
 	IPW_DEBUG_HC("starting request direct scan!\n");
 
 	if (priv->status & (STATUS_SCANNING | STATUS_SCAN_ABORTING)) {
+		/* We should not sleep with the semaphore help.
+		 * Otherwise we will block a worker thread, deadlocking
+		 * most of the system.
+		 */
+		up(&priv->sem);
 		err = wait_event_interruptible(priv->wait_state,
 					       !(priv->
 						 status & (STATUS_SCANNING |
 							   STATUS_SCAN_ABORTING)));
 		if (err) {
 			IPW_DEBUG_HC("aborting direct scan");
-			goto done;
+			return err;
 		}
+		goto again;
 	}
 	memset(&scan, 0, sizeof(scan));
 
