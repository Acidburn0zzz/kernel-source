ChangeSet
  1.1608.6.53 04/05/10 13:55:16 akpm@osdl.org[torvalds] +1 -0
  [PATCH] Fix ext3 bogus ENOSPC
  
  With strange workloads which do a lot of quick truncation on small filesystems
  it is possible to get into a situation where there are free blocks on the
  disk, but they are not allocatable at this time due to their having been freed
  up in the current JBD transaction.  Applications get unexpected ENOSPC errors.
  
  We can fix that with this patch, originally by Andreas Dilger which forces a
  single commit+retry when an ENOSPC is encountered.

  fs/ext3/inode.c
    1.95 04/05/10 04:25:34 akpm@osdl.org[torvalds] +15 -2
    Fix ext3 bogus ENOSPC

diff -Nru a/fs/ext3/inode.c b/fs/ext3/inode.c
--- a/fs/ext3/inode.c	Tue May 11 07:17:50 2004
+++ b/fs/ext3/inode.c	Tue May 11 07:17:50 2004
@@ -1081,15 +1081,28 @@
 	struct inode *inode = page->mapping->host;
 	int ret, needed_blocks = ext3_writepage_trans_blocks(inode);
 	handle_t *handle;
+	int tried_commit = 0;
 
+retry:
 	handle = ext3_journal_start(inode, needed_blocks);
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
 		goto out;
 	}
 	ret = block_prepare_write(page, from, to, ext3_get_block);
-	if (ret != 0)
-		goto prepare_write_failed;
+	if (ret) {
+		if (ret != -ENOSPC || tried_commit)
+			goto prepare_write_failed;
+		/*
+		 * It could be that there _is_ free space, but it's all tied up
+		 * in uncommitted bitmaps.  So force a commit here, which makes
+		 * those blocks allocatable and try again.
+		 */
+		tried_commit = 1;
+		handle->h_sync = 1;
+		ext3_journal_stop(handle);
+		goto retry;
+	}
 
 	if (ext3_should_journal_data(inode)) {
 		ret = walk_page_buffers(handle, page_buffers(page),
.........................................................................
# vim: syntax=diff

