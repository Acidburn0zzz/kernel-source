Subject: Bug 175408 - LTC22391-system enter xmon(.find_writable_file+0x104/0x168 [cifs]) when running base+io+nfs+tcp testcas
From: sfrench@us.ibm.com

combinded patch (includes both find writeable file oops and cifs simultaneous
rename/delete hang) fixes.

Signed-off-by: Olaf Hering <olh@suse.de>

---
 fs/cifs/dir.c     |    4 ----
 fs/cifs/fcntl.c   |    2 --
 fs/cifs/file.c    |    8 ++++++--
 fs/cifs/inode.c   |    6 ------
 fs/cifs/link.c    |    6 ------
 fs/cifs/readdir.c |    2 --
 fs/cifs/xattr.c   |    8 --------
 7 files changed, 6 insertions(+), 30 deletions(-)

Index: linux-2.6.16/fs/cifs/dir.c
===================================================================
--- linux-2.6.16.orig/fs/cifs/dir.c
+++ linux-2.6.16/fs/cifs/dir.c
@@ -138,9 +138,7 @@ cifs_create(struct inode *inode, struct 
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
-	down(&direntry->d_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&direntry->d_sb->s_vfs_rename_sem);
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -317,9 +315,7 @@ int cifs_mknod(struct inode *inode, stru
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
-	down(&direntry->d_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&direntry->d_sb->s_vfs_rename_sem);
 	if(full_path == NULL)
 		rc = -ENOMEM;
 	else if (pTcon->ses->capabilities & CAP_UNIX) {
Index: linux-2.6.16/fs/cifs/fcntl.c
===================================================================
--- linux-2.6.16.orig/fs/cifs/fcntl.c
+++ linux-2.6.16/fs/cifs/fcntl.c
@@ -86,9 +86,7 @@ int cifs_dir_notify(struct file * file, 
 	cifs_sb = CIFS_SB(file->f_dentry->d_sb);
 	pTcon = cifs_sb->tcon;
 
-	down(&file->f_dentry->d_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(file->f_dentry);
-	up(&file->f_dentry->d_sb->s_vfs_rename_sem);
 
 	if(full_path == NULL) {
 		rc = -ENOMEM;
Index: linux-2.6.16/fs/cifs/file.c
===================================================================
--- linux-2.6.16.orig/fs/cifs/file.c
+++ linux-2.6.16/fs/cifs/file.c
@@ -203,9 +203,7 @@ int cifs_open(struct inode *inode, struc
 		}
 	}
 
-	down(&inode->i_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(file->f_dentry);
-	up(&inode->i_sb->s_vfs_rename_sem);
 	if (full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -930,6 +928,12 @@ struct cifsFileInfo *find_writable_file(
 	struct cifsFileInfo *open_file;
 	int rc;
 
+	if(cifs_inode == NULL) {
+		cERROR(1,("Null inode passed to cifs_writeable_file"));
+		dump_stack();
+		return NULL;
+	}
+
 	read_lock(&GlobalSMBSeslock);
 	list_for_each_entry(open_file, &cifs_inode->openFileList, flist) {
 		if (open_file->closePend)
Index: linux-2.6.16/fs/cifs/inode.c
===================================================================
--- linux-2.6.16.orig/fs/cifs/inode.c
+++ linux-2.6.16/fs/cifs/inode.c
@@ -718,9 +718,7 @@ int cifs_mkdir(struct inode *inode, stru
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
-	down(&inode->i_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&inode->i_sb->s_vfs_rename_sem);
 	if (full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -803,9 +801,7 @@ int cifs_rmdir(struct inode *inode, stru
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
-	down(&inode->i_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&inode->i_sb->s_vfs_rename_sem);
 	if (full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -1137,9 +1133,7 @@ int cifs_setattr(struct dentry *direntry
 			rc = 0;
 	}
 		
-	down(&direntry->d_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&direntry->d_sb->s_vfs_rename_sem);
 	if (full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
Index: linux-2.6.16/fs/cifs/link.c
===================================================================
--- linux-2.6.16.orig/fs/cifs/link.c
+++ linux-2.6.16/fs/cifs/link.c
@@ -48,10 +48,8 @@ cifs_hardlink(struct dentry *old_file, s
 /* No need to check for cross device links since server will do that
    BB note DFS case in future though (when we may have to check) */
 
-	down(&inode->i_sb->s_vfs_rename_sem);
 	fromName = build_path_from_dentry(old_file);
 	toName = build_path_from_dentry(direntry);
-	up(&inode->i_sb->s_vfs_rename_sem);
 	if((fromName == NULL) || (toName == NULL)) {
 		rc = -ENOMEM;
 		goto cifs_hl_exit;
@@ -103,9 +101,7 @@ cifs_follow_link(struct dentry *direntry
 
 	xid = GetXid();
 
-	down(&direntry->d_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&direntry->d_sb->s_vfs_rename_sem);
 
 	if (!full_path)
 		goto out_no_free;
@@ -164,9 +160,7 @@ cifs_symlink(struct inode *inode, struct
 	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
-	down(&inode->i_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&inode->i_sb->s_vfs_rename_sem);
 
 	if(full_path == NULL) {
 		FreeXid(xid);
Index: linux-2.6.16/fs/cifs/readdir.c
===================================================================
--- linux-2.6.16.orig/fs/cifs/readdir.c
+++ linux-2.6.16/fs/cifs/readdir.c
@@ -404,9 +404,7 @@ static int initiate_cifs_search(const in
 	if(pTcon == NULL)
 		return -EINVAL;
 
-	down(&file->f_dentry->d_sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(file->f_dentry);
-	up(&file->f_dentry->d_sb->s_vfs_rename_sem);
 
 	if(full_path == NULL) {
 		return -ENOMEM;
Index: linux-2.6.16/fs/cifs/xattr.c
===================================================================
--- linux-2.6.16.orig/fs/cifs/xattr.c
+++ linux-2.6.16/fs/cifs/xattr.c
@@ -62,9 +62,7 @@ int cifs_removexattr(struct dentry * dir
 	cifs_sb = CIFS_SB(sb);
 	pTcon = cifs_sb->tcon;
                                                                                      
-	down(&sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&sb->s_vfs_rename_sem);
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -116,9 +114,7 @@ int cifs_setxattr(struct dentry * dirent
 	cifs_sb = CIFS_SB(sb);
 	pTcon = cifs_sb->tcon;
 
-	down(&sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&sb->s_vfs_rename_sem);
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -223,9 +219,7 @@ ssize_t cifs_getxattr(struct dentry * di
 	cifs_sb = CIFS_SB(sb);
 	pTcon = cifs_sb->tcon;
 
-	down(&sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&sb->s_vfs_rename_sem);
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
@@ -341,9 +335,7 @@ ssize_t cifs_listxattr(struct dentry * d
 	cifs_sb = CIFS_SB(sb);
 	pTcon = cifs_sb->tcon;
 
-	down(&sb->s_vfs_rename_sem);
 	full_path = build_path_from_dentry(direntry);
-	up(&sb->s_vfs_rename_sem);
 	if(full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
