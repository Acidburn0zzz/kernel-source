# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/04/09 01:01:09+02:00 marcel@holtmann.org 
#   [Bluetooth] Fix URB unlink race in the USB drivers
#   
#   The code in hci_usb_unlink_urbs() calls usb_unlink_urb() to perform a
#   synchronous unlink of each pending URB. It then moves each URB to the
#   completed list, and then frees everything on the completed list. By doing
#   this, the code implicitly assumes that when usb_unlink_urb() returns the
#   URB will have completed and be ready to be deallocated. That's not always
#   true. The same applies to the BlueFRITZ! USB driver.
#   
#   Patch from Alan Stern <stern@rowland.harvard.edu>
# 
# drivers/bluetooth/hci_usb.c
#   2004/04/09 00:58:38+02:00 marcel@holtmann.org +9 -0
#   Fix URB unlink race in the USB drivers
# 
# drivers/bluetooth/bfusb.c
#   2004/04/09 00:58:32+02:00 marcel@holtmann.org +10 -1
#   Fix URB unlink race in the USB drivers
# 
diff -Nru a/drivers/bluetooth/bfusb.c b/drivers/bluetooth/bfusb.c
--- a/drivers/bluetooth/bfusb.c	Fri Apr  9 01:01:33 2004
+++ b/drivers/bluetooth/bfusb.c	Fri Apr  9 01:01:33 2004
@@ -98,6 +98,14 @@
 static void bfusb_tx_complete(struct urb *urb, struct pt_regs *regs);
 static void bfusb_rx_complete(struct urb *urb, struct pt_regs *regs);
 
+static inline void bfusb_wait_for_urb(struct urb *urb)
+{
+	while (atomic_read(&urb->count) > 1) {
+		current->state = TASK_UNINTERRUPTIBLE;
+		schedule_timeout((5 * HZ + 999) / 1000);
+	}
+}
+
 static struct urb *bfusb_get_completed(struct bfusb *bfusb)
 {
 	struct sk_buff *skb;
@@ -114,7 +122,7 @@
 	return urb;
 }
 
-static inline void bfusb_unlink_urbs(struct bfusb *bfusb)
+static void bfusb_unlink_urbs(struct bfusb *bfusb)
 {
 	struct sk_buff *skb;
 	struct urb *urb;
@@ -124,6 +132,7 @@
 	while ((skb = skb_dequeue(&bfusb->pending_q))) {
 		urb = ((struct bfusb_scb *) skb->cb)->urb;
 		usb_unlink_urb(urb);
+		bfusb_wait_for_urb(urb);
 		skb_queue_tail(&bfusb->completed_q, skb);
 	}
 
diff -Nru a/drivers/bluetooth/hci_usb.c b/drivers/bluetooth/hci_usb.c
--- a/drivers/bluetooth/hci_usb.c	Fri Apr  9 01:01:33 2004
+++ b/drivers/bluetooth/hci_usb.c	Fri Apr  9 01:01:33 2004
@@ -341,6 +341,14 @@
 	return 0;
 }
 
+static inline void hci_usb_wait_for_urb(struct urb *urb)
+{
+	while (atomic_read(&urb->count) > 1) {
+		current->state = TASK_UNINTERRUPTIBLE;
+		schedule_timeout((5 * HZ + 999) / 1000);
+	}
+}
+
 static void hci_usb_unlink_urbs(struct hci_usb *husb)
 {
 	int i;
@@ -357,6 +365,7 @@
 			BT_DBG("%s unlinking _urb %p type %d urb %p", 
 					husb->hdev->name, _urb, _urb->type, urb);
 			usb_unlink_urb(urb);
+			hci_usb_wait_for_urb(urb);
 			_urb_queue_tail(__completed_q(husb, _urb->type), _urb);
 		}
 
