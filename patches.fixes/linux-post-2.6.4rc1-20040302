diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/kernel/setup.c linux-post-2.6.4rc1-20040302/arch/m68k/kernel/setup.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/kernel/setup.c	2004-02-23 05:24:08.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/kernel/setup.c	2004-03-01 14:30:55.000000000 +0000
@@ -39,7 +39,6 @@
 #endif
 #ifdef CONFIG_SUN3X
 #include <asm/dvma.h>
-extern void sun_serial_setup(void);
 #endif
 
 unsigned long m68k_machtype;
diff -purN linux-post-2.6.4rc1-20040301/arch/ppc64/kernel/vio.c linux-post-2.6.4rc1-20040302/arch/ppc64/kernel/vio.c
--- linux-post-2.6.4rc1-20040301/arch/ppc64/kernel/vio.c	2004-02-27 12:22:02.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/ppc64/kernel/vio.c	2004-03-01 16:04:41.000000000 +0000
@@ -29,6 +29,8 @@
 
 #define DBGENTER() pr_debug("%s entered\n", __FUNCTION__)
 
+extern struct subsystem devices_subsys; /* needed for vio_find_name() */
+
 struct iommu_table *vio_build_iommu_table(struct vio_dev *dev);
 
 static int vio_num_address_cells;
@@ -157,8 +159,7 @@ static int __init vio_bus_init(void)
 
 	node_vroot = find_devices("vdevice");
 	if ((node_vroot == NULL) || (node_vroot->child == NULL)) {
-		printk(KERN_INFO "VIO: missing or empty /vdevice node; no virtual IO"
-			" devices present.\n");
+		/* this machine doesn't do virtual IO, and that's ok */
 		return 0;
 	}
 
@@ -260,7 +261,7 @@ struct vio_dev * __devinit vio_register_
 	/* init generic 'struct device' fields: */
 	viodev->dev.parent = &vio_bus_device->dev;
 	viodev->dev.bus = &vio_bus_type;
-	snprintf(viodev->dev.bus_id, BUS_ID_SIZE, "%lx", viodev->unit_address);
+	snprintf(viodev->dev.bus_id, BUS_ID_SIZE, "%x", viodev->unit_address);
 	viodev->dev.release = vio_dev_release;
 
 	/* register with generic device framework */
@@ -299,6 +300,42 @@ const void * vio_get_attribute(struct vi
 }
 EXPORT_SYMBOL(vio_get_attribute);
 
+/* vio_find_name() - internal because only vio.c knows how we formatted the
+ * kobject name
+ * XXX once vio_bus_type.devices is actually used as a kset in
+ * drivers/base/bus.c, this function should be removed in favor of
+ * "device_find(kobj_name, &vio_bus_type)"
+ */
+static struct vio_dev *vio_find_name(const char *kobj_name)
+{
+	struct kobject *found;
+
+	found = kset_find_obj(&devices_subsys.kset, kobj_name);
+	if (!found)
+		return NULL;
+
+	return to_vio_dev(container_of(found, struct device, kobj));
+}
+
+/**
+ * vio_find_node - find an already-registered vio_dev
+ * @vnode: device_node of the virtual device we're looking for
+ */
+struct vio_dev *vio_find_node(struct device_node *vnode)
+{
+	uint32_t *unit_address;
+	char kobj_name[BUS_ID_SIZE];
+
+	/* construct the kobject name from the device node */
+	unit_address = (uint32_t *)get_property(vnode, "reg", NULL);
+	if (!unit_address)
+		return NULL;
+	snprintf(kobj_name, BUS_ID_SIZE, "%x", *unit_address);
+
+	return vio_find_name(kobj_name);
+}
+EXPORT_SYMBOL(vio_find_node);
+
 /**
  * vio_build_iommu_table: - gets the dma information from OF and builds the TCE tree.
  * @dev: the virtual device.
diff -purN linux-post-2.6.4rc1-20040301/arch/sparc/kernel/setup.c linux-post-2.6.4rc1-20040302/arch/sparc/kernel/setup.c
--- linux-post-2.6.4rc1-20040301/arch/sparc/kernel/setup.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sparc/kernel/setup.c	2004-03-01 14:30:54.000000000 +0000
@@ -233,7 +233,6 @@ extern char cputypval;
 extern unsigned long start, end;
 extern void panic_setup(char *, int *);
 extern void srmmu_end_memory(unsigned long, unsigned long *);
-extern void sun_serial_setup(void);
 
 extern unsigned short root_flags;
 extern unsigned short root_dev;
diff -purN linux-post-2.6.4rc1-20040301/arch/sparc64/Kconfig linux-post-2.6.4rc1-20040302/arch/sparc64/Kconfig
--- linux-post-2.6.4rc1-20040301/arch/sparc64/Kconfig	2004-02-17 00:42:10.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sparc64/Kconfig	2004-02-29 05:08:39.000000000 +0000
@@ -633,6 +633,15 @@ config DEBUG_KERNEL
 	  Say Y here if you are developing drivers or trying to debug and
 	  identify kernel problems.
 
+config DEBUG_STACK_USAGE
+	bool "Enable stack utilization instrumentation"
+	depends on DEBUG_KERNEL
+	help
+	  Enables the display of the minimum amount of free stack which each
+	  task has ever had available in the sysrq-T and sysrq-P debug output.
+
+	  This option will slow down process creation somewhat.
+
 config DEBUG_SLAB
 	bool "Debug memory allocations"
 	depends on DEBUG_KERNEL
diff -purN linux-post-2.6.4rc1-20040301/arch/sparc64/defconfig linux-post-2.6.4rc1-20040302/arch/sparc64/defconfig
--- linux-post-2.6.4rc1-20040301/arch/sparc64/defconfig	2004-02-26 22:42:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sparc64/defconfig	2004-02-29 05:08:39.000000000 +0000
@@ -905,7 +905,6 @@ CONFIG_IRDA_FAST_RR=y
 #
 # Old SIR device drivers
 #
-# CONFIG_IRPORT_SIR is not set
 
 #
 # Old Serial dongle support
@@ -1657,6 +1656,7 @@ CONFIG_OPROFILE=m
 # Kernel hacking
 #
 CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_STACK_USAGE is not set
 # CONFIG_DEBUG_SLAB is not set
 CONFIG_MAGIC_SYSRQ=y
 # CONFIG_DEBUG_SPINLOCK is not set
diff -purN linux-post-2.6.4rc1-20040301/arch/sparc64/mm/init.c linux-post-2.6.4rc1-20040302/arch/sparc64/mm/init.c
--- linux-post-2.6.4rc1-20040301/arch/sparc64/mm/init.c	2004-01-27 21:44:20.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sparc64/mm/init.c	2004-03-01 14:30:54.000000000 +0000
@@ -1423,7 +1423,6 @@ unsigned long __init bootmem_init(unsign
 
 /* paging_init() sets up the page tables */
 
-extern void sun_serial_setup(void);
 extern void cheetah_ecache_flush_init(void);
 
 static unsigned long last_valid_pfn;
@@ -1548,15 +1547,6 @@ void __init paging_init(void)
 
 	inherit_locked_prom_mappings(1);
 
-#ifdef CONFIG_SUN_SERIAL
-	/* This does not logically belong here, but we need to call it at
-	 * the moment we are able to use the bootmem allocator. This _has_
-	 * to be done after the prom_mappings above so since
-	 * __alloc_bootmem() doesn't work correctly until then.
-	 */
-	sun_serial_setup();
-#endif
-
 	/* We only created DTLB mapping of this stuff. */
 	spitfire_flush_dtlb_nucleus_page(alias_base);
 	if (second_alias_page)
diff -purN linux-post-2.6.4rc1-20040301/drivers/ide/arm/icside.c linux-post-2.6.4rc1-20040302/drivers/ide/arm/icside.c
--- linux-post-2.6.4rc1-20040301/drivers/ide/arm/icside.c	2004-02-16 20:26:05.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ide/arm/icside.c	2004-02-28 11:38:08.000000000 +0000
@@ -1,13 +1,7 @@
 /*
  * linux/drivers/ide/arm/icside.c
  *
- * Copyright (c) 1996-2002 Russell King.
- *
- * Changelog:
- *  08-Jun-1996	RMK	Created
- *  12-Sep-1997	RMK	Added interrupt enable/disable
- *  17-Apr-1999	RMK	Added support for V6 EASI
- *  22-May-1999	RMK	Added support for V6 DMA
+ * Copyright (c) 1996-2003 Russell King.
  */
 
 #include <linux/config.h>
@@ -237,7 +231,7 @@ static void icside_build_sglist(ide_driv
 		sg->length = rq->nr_sectors * SECTOR_SIZE;
 		nents = 1;
 	} else {
-		nents = blk_rq_map_sg(&drive->queue, rq, sg);
+		nents = blk_rq_map_sg(drive->queue, rq, sg);
 
 		if (rq_data_dir(rq) == READ)
 			hwif->sg_dma_direction = DMA_FROM_DEVICE;
@@ -487,33 +481,31 @@ icside_dma_common(ide_drive_t *drive, st
 	set_dma_sg(hwif->hw.dma, hwif->sg_table, hwif->sg_nents);
 	set_dma_mode(hwif->hw.dma, dma_mode);
 
+	drive->waiting_for_dma = 1;
+
 	return 0;
 }
 
 static int icside_dma_read(ide_drive_t *drive)
 {
 	struct request *rq = HWGROUP(drive)->rq;
-	task_ioreg_t cmd = WIN_NOP;
+	task_ioreg_t cmd;
 
 	if (icside_dma_common(drive, rq, DMA_MODE_READ))
 		return 1;
 
-	drive->waiting_for_dma = 1;
-
 	if (drive->media != ide_disk)
 		return 0;
 
 	BUG_ON(HWGROUP(drive)->handler != NULL);
 
-	ide_set_handler(drive, icside_dmaintr, 2*WAIT_CMD, NULL);
-
 	/*
 	 * FIX ME to use only ACB ide_task_t args Struct
 	 */
 #if 0
 	{
 		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
+		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
 	}
 #else
 	if (rq->flags & REQ_DRIVE_TASKFILE) {
@@ -526,35 +518,31 @@ static int icside_dma_read(ide_drive_t *
 	}
 #endif
 	/* issue cmd to drive */
-	HWIF(drive)->OUTB(cmd, IDE_COMMAND_REG);
+	ide_execute_command(drive, cmd, icside_dmaintr, 2*WAIT_CMD, NULL);
 
 	return icside_dma_begin(drive);
 }
 
-int icside_dma_write(ide_drive_t *drive)
+static int icside_dma_write(ide_drive_t *drive)
 {
 	struct request *rq = HWGROUP(drive)->rq;
-	task_ioreg_t cmd = WIN_NOP;
+	task_ioreg_t cmd;
 
 	if (icside_dma_common(drive, rq, DMA_MODE_WRITE))
 		return 1;
 
-	drive->waiting_for_dma = 1;
-
 	if (drive->media != ide_disk)
 		return 0;
 
 	BUG_ON(HWGROUP(drive)->handler != NULL);
 
-	ide_set_handler(drive, icside_dmaintr, 2*WAIT_CMD, NULL);
-
 	/*
 	 * FIX ME to use only ACB ide_task_t args Struct
 	 */
 #if 0
 	{
 		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
+		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
 	}
 #else
 	if (rq->flags & REQ_DRIVE_TASKFILE) {
@@ -566,8 +554,9 @@ int icside_dma_write(ide_drive_t *drive)
 		cmd = WIN_WRITEDMA;
 	}
 #endif
+
 	/* issue cmd to drive */
-	HWIF(drive)->OUTB(cmd, IDE_COMMAND_REG);
+	ide_execute_command(drive, cmd, icside_dmaintr, 2*WAIT_CMD, NULL);
 
 	return icside_dma_begin(drive);
 }
@@ -787,7 +776,7 @@ icside_register_v6(struct icside_state *
 	state->hwif[0]    = hwif;
 	state->hwif[1]    = mate;
 
-	ec->irq_data	  = state;
+	ec->irq_data      = state;
 	ec->ops           = &icside_ops_arcin_v6;
 
 	hwif->maskproc    = icside_maskproc;
@@ -797,7 +786,7 @@ icside_register_v6(struct icside_state *
 	hwif->serialized  = 1;
 	hwif->config_data = slot_port;
 	hwif->select_data = sel;
-	hwif->hw.dma	  = ec->dma;
+	hwif->hw.dma      = ec->dma;
 
 	mate->maskproc    = icside_maskproc;
 	mate->channel     = 1;
@@ -806,7 +795,7 @@ icside_register_v6(struct icside_state *
 	mate->serialized  = 1;
 	mate->config_data = slot_port;
 	mate->select_data = sel | 1;
-	mate->hw.dma	  = ec->dma;
+	mate->hw.dma      = ec->dma;
 
 	if (ec->dma != NO_DMA && !request_dma(ec->dma, hwif->name)) {
 		icside_dma_init(hwif);
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/Kconfig linux-post-2.6.4rc1-20040302/drivers/net/Kconfig
--- linux-post-2.6.4rc1-20040301/drivers/net/Kconfig	2004-02-17 16:05:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/Kconfig	2004-02-27 22:23:58.000000000 +0000
@@ -1676,25 +1676,23 @@ config VIA_RHINE
 	select CRC32
 	select MII
 	help
-	  If you have a VIA "rhine" based network card (Rhine-I (3043),
-	  Rhine-2 (VT86c100A) or Rhine-III (VT6105)), say Y here.
+	  If you have a VIA "Rhine" based network card (Rhine-I (VT86C100A),
+	  Rhine-II (VT6102), or Rhine-III (VT6105)), say Y here. Rhine-type
+	  Ethernet functions can also be found integrated on South Bridges
+	  (e.g. VT8235).
 
-	  To compile this driver as a module, choose M here and read
-	  <file:Documentation/networking/net-modules.txt>. The module
+	  To compile this driver as a module, choose M here. The module
 	  will be called via-rhine.
 
 config VIA_RHINE_MMIO
-	bool "Use MMIO instead of PIO (EXPERIMENTAL)"
-	depends on VIA_RHINE && EXPERIMENTAL
+	bool "Use MMIO instead of PIO"
+	depends on VIA_RHINE
 	help
 	  This instructs the driver to use PCI shared memory (MMIO) instead of
 	  programmed I/O ports (PIO). Enabling this gives an improvement in
 	  processing time in parts of the driver.
 
-	  It is not known if this works reliably on all "rhine" based cards,
-	  but it has been tested successfully on some DFE-530TX adapters.
-
-	  If unsure, say N.
+	  If unsure, say Y.
 
 config LAN_SAA9730
 	bool "Philips SAA9730 Ethernet support (EXPERIMENTAL)"
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/hp100.c linux-post-2.6.4rc1-20040302/drivers/net/hp100.c
--- linux-post-2.6.4rc1-20040301/drivers/net/hp100.c	2004-02-18 12:39:41.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/hp100.c	2004-03-01 11:18:00.000000000 +0000
@@ -201,6 +201,7 @@ static struct eisa_device_id hp100_eisa_
 	{ "HWP1990" }, /* HP J2577 */
 	{ "CPX0301" }, /* ReadyLink ENET100-VG4 */
 	{ "CPX0401" }, /* FreedomLine 100/VG */
+	{ "" }	       /* Mandatory final entry ! */
 };
 MODULE_DEVICE_TABLE(eisa, hp100_eisa_tbl);
 #endif
@@ -326,16 +327,21 @@ static __init const char *hp100_read_id(
 	return str;
 }
 
-static __init int hp100_isa_probe1(struct net_device *dev, int addr)
+static __init int hp100_isa_probe1(struct net_device *dev, int ioaddr)
 {
 	const char *sig;
 	int i;
 
-	if (!request_region(addr, HP100_REGION_SIZE, "hp100"))
+	if (!request_region(ioaddr, HP100_REGION_SIZE, "hp100"))
 		goto err;
 
-	sig = hp100_read_id(addr);
-	release_region(addr, HP100_REGION_SIZE);
+	if (hp100_inw(HW_ID) != HP100_HW_ID_CASCADE) {
+		release_region(ioaddr, HP100_REGION_SIZE);
+		goto err;
+	}
+
+	sig = hp100_read_id(ioaddr);
+	release_region(ioaddr, HP100_REGION_SIZE);
 
 	if (sig == NULL)
 		goto err;
@@ -347,7 +353,7 @@ static __init int hp100_isa_probe1(struc
 	}
 
 	if (i < ARRAY_SIZE(hp100_isa_tbl))
-		return hp100_probe1(dev, addr, HP100_BUS_ISA, NULL);
+		return hp100_probe1(dev, ioaddr, HP100_BUS_ISA, NULL);
  err:
 	return -ENODEV;
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/hydra.c linux-post-2.6.4rc1-20040302/drivers/net/hydra.c
--- linux-post-2.6.4rc1-20040301/drivers/net/hydra.c	2004-02-20 15:10:49.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/hydra.c	2004-02-29 08:53:41.000000000 +0000
@@ -142,10 +142,6 @@ static int __devinit hydra_init(struct z
     ei_status.reg_offset = hydra_offsets;
     dev->open = &hydra_open;
     dev->stop = &hydra_close;
-#ifdef MODULE
-    ei_status.priv = (unsigned long)root_hydra_dev;
-    root_hydra_dev = dev;
-#endif
     NS8390_init(dev, 0);
 
     err = register_netdev(dev);
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/ibmveth.c linux-post-2.6.4rc1-20040302/drivers/net/ibmveth.c
--- linux-post-2.6.4rc1-20040301/drivers/net/ibmveth.c	2004-02-17 16:05:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/ibmveth.c	2004-03-01 16:38:07.000000000 +0000
@@ -52,7 +52,7 @@
 #include <asm/semaphore.h>
 #include <asm/hvcall.h>
 #include <asm/atomic.h>
-#include <asm/pci_dma.h>
+#include <asm/iommu.h>
 #include <asm/vio.h>
 #include <asm/uaccess.h>
 #include <linux/proc_fs.h>
@@ -66,16 +66,16 @@
   printk(KERN_INFO "%s: " fmt, __FILE__, ## args)
 
 #define ibmveth_error_printk(fmt, args...) \
-  printk(KERN_ERR "(%s:%3.3d ua:%lx) ERROR: " fmt, __FILE__, __LINE__ , adapter->vdev->unit_address, ## args)
+  printk(KERN_ERR "(%s:%3.3d ua:%x) ERROR: " fmt, __FILE__, __LINE__ , adapter->vdev->unit_address, ## args)
 
 #ifdef DEBUG
 #define ibmveth_debug_printk_no_adapter(fmt, args...) \
   printk(KERN_DEBUG "(%s:%3.3d): " fmt, __FILE__, __LINE__ , ## args)
 #define ibmveth_debug_printk(fmt, args...) \
-  printk(KERN_DEBUG "(%s:%3.3d ua:%lx): " fmt, __FILE__, __LINE__ , adapter->vdev->unit_address, ## args)
+  printk(KERN_DEBUG "(%s:%3.3d ua:%x): " fmt, __FILE__, __LINE__ , adapter->vdev->unit_address, ## args)
 #define ibmveth_assert(expr) \
   if(!(expr)) {                                   \
-    printk(KERN_DEBUG "assertion failed (%s:%3.3d ua:%lx): %s\n", __FILE__, __LINE__, adapter->vdev->unit_address, #expr); \
+    printk(KERN_DEBUG "assertion failed (%s:%3.3d ua:%x): %s\n", __FILE__, __LINE__, adapter->vdev->unit_address, #expr); \
     BUG(); \
   }
 #else
@@ -869,7 +869,7 @@ static int __devinit ibmveth_probe(struc
 	unsigned int *mcastFilterSize_p;
 
 
-	ibmveth_debug_printk_no_adapter("entering ibmveth_probe for UA 0x%lx\n", 
+	ibmveth_debug_printk_no_adapter("entering ibmveth_probe for UA 0x%x\n", 
 					dev->unit_address);
 
 	mac_addr_p = (unsigned int *) vio_get_attribute(dev, VETH_MAC_ADDR, 0);
@@ -913,7 +913,7 @@ static int __devinit ibmveth_probe(struc
 	adapter->mac_addr = 0;
 	memcpy(&adapter->mac_addr, mac_addr_p, 6);
 
-	adapter->liobn = dev->tce_table->index;
+	adapter->liobn = dev->iommu_table->it_index;
 	
 	netdev->irq = dev->irq;
 	netdev->open               = ibmveth_open;
@@ -1014,7 +1014,7 @@ static int ibmveth_seq_show(struct seq_f
 
 	seq_printf(seq, "%s %s\n\n", ibmveth_driver_string, ibmveth_driver_version);
 	
-	seq_printf(seq, "Unit Address:    0x%lx\n", adapter->vdev->unit_address);
+	seq_printf(seq, "Unit Address:    0x%x\n", adapter->vdev->unit_address);
 	seq_printf(seq, "LIOBN:           0x%lx\n", adapter->liobn);
 	seq_printf(seq, "Current MAC:     %02X:%02X:%02X:%02X:%02X:%02X\n",
 		   current_mac[0], current_mac[1], current_mac[2],
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/r8169.c linux-post-2.6.4rc1-20040302/drivers/net/r8169.c
--- linux-post-2.6.4rc1-20040301/drivers/net/r8169.c	2003-12-07 18:58:47.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/r8169.c	2004-02-26 06:19:13.000000000 +0000
@@ -871,7 +871,6 @@ rtl8169_tx_interrupt(struct net_device *
 		     void *ioaddr)
 {
 	unsigned long dirty_tx, tx_left = 0;
-	int entry = tp->cur_tx % NUM_TX_DESC;
 
 	assert(dev != NULL);
 	assert(tp != NULL);
@@ -881,14 +880,18 @@ rtl8169_tx_interrupt(struct net_device *
 	tx_left = tp->cur_tx - dirty_tx;
 
 	while (tx_left > 0) {
+		int entry = dirty_tx % NUM_TX_DESC;
+
 		if ((tp->TxDescArray[entry].status & OWNbit) == 0) {
-			dev_kfree_skb_irq(tp->
-					  Tx_skbuff[dirty_tx % NUM_TX_DESC]);
-			tp->Tx_skbuff[dirty_tx % NUM_TX_DESC] = NULL;
+			struct sk_buff *skb = tp->Tx_skbuff[entry];
+
+			tp->stats.tx_bytes += skb->len >= ETH_ZLEN ?
+					      skb->len : ETH_ZLEN;
 			tp->stats.tx_packets++;
+			dev_kfree_skb_irq(skb);
+			tp->Tx_skbuff[entry] = NULL;
 			dirty_tx++;
 			tx_left--;
-			entry++;
 		}
 	}
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/airo_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/airo_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/airo_cs.c	2004-01-19 06:32:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/airo_cs.c	2004-02-05 16:09:01.000000000 +0000
@@ -264,11 +264,8 @@ static void airo_detach(dev_link_t *link
 	if (*linkp == NULL)
 		return;
 	
-	if (link->state & DEV_CONFIG) {
+	if (link->state & DEV_CONFIG)
 		airo_release(link);
-		if (link->state & DEV_STALE_CONFIG)
-			return;
-	}
 	
 	if ( ((local_info_t*)link->priv)->eth_dev ) {
 		stop_airo_card( ((local_info_t*)link->priv)->eth_dev, 0 );
@@ -504,18 +501,6 @@ static void airo_release(dev_link_t *lin
 {
 	DEBUG(0, "airo_release(0x%p)\n", link);
 	
-	/*
-	  If the device is currently in use, we won't release until it
-	  is actually closed, because until then, we can't be sure that
-	  no one will try to access the device or its data structures.
-	*/
-	if (link->open) {
-		DEBUG(1, "airo_cs: release postponed, '%s' still open\n",
-		      link->dev->dev_name);
-		link->state |= DEV_STALE_CONFIG;
-		return;
-	}
-	
 	/* Unlink the device chain */
 	link->dev = NULL;
 	
@@ -533,9 +518,6 @@ static void airo_release(dev_link_t *lin
 	if (link->irq.AssignedIRQ)
 		pcmcia_release_irq(link->handle, &link->irq);
 	link->state &= ~DEV_CONFIG;
-
-	if (link->state & DEV_STALE_CONFIG)
-		airo_detach(link);
 }
 
 /*======================================================================
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/netwave_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/netwave_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/netwave_cs.c	2004-01-19 06:32:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/netwave_cs.c	2004-02-05 16:09:30.000000000 +0000
@@ -544,14 +544,8 @@ static void netwave_detach(dev_link_t *l
 	  the release() function is called, that will trigger a proper
 	  detach().
 	*/
-    if (link->state & DEV_CONFIG) {
+    if (link->state & DEV_CONFIG)
 	netwave_release(link);
-	if (link->state & DEV_STALE_CONFIG) {
-	    DEBUG(1, "netwave_cs: detach postponed, '%s' still "
-		  "locked\n", link->dev->dev_name);
-	    return;
-	}
-    }
 	
     /* Break the link with Card Services */
     if (link->handle)
@@ -1130,17 +1124,6 @@ static void netwave_release(dev_link_t *
 
     DEBUG(0, "netwave_release(0x%p)\n", link);
 
-    /*
-      If the device is currently in use, we won't release until it
-      is actually closed.
-      */
-    if (link->open) {
-	printk(KERN_DEBUG "netwave_cs: release postponed, '%s' still open\n",
-	       link->dev->dev_name);
-	link->state |= DEV_STALE_CONFIG;
-	return;
-    }
-
     /* Don't bother checking to see if these succeed or not */
     if (link->win) {
 	iounmap(priv->ramBase);
@@ -1151,9 +1134,6 @@ static void netwave_release(dev_link_t *
     pcmcia_release_irq(link->handle, &link->irq);
 
     link->state &= ~DEV_CONFIG;
-
-    if (link->state & DEV_STALE_CONFIG)
-	netwave_detach(link);
 }
 
 /*
@@ -1703,8 +1683,7 @@ static int netwave_close(struct net_devi
 
     link->open--;
     netif_stop_queue(dev);
-    if (link->state & DEV_STALE_CONFIG)
-	    netwave_release(link);
+
     return 0;
 }
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/ray_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/ray_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/ray_cs.c	2004-01-19 23:34:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/ray_cs.c	2004-02-18 22:40:58.000000000 +0000
@@ -454,11 +454,8 @@ static void ray_detach(dev_link_t *link)
       the release() function is called, that will trigger a proper
       detach().
     */
-    if (link->state & DEV_CONFIG) {
+    if (link->state & DEV_CONFIG)
         ray_release(link);
-        if(link->state & DEV_STALE_CONFIG)
-            return;
-    }
 
     /* Break the link with Card Services */
     if (link->handle)
@@ -872,15 +869,7 @@ static void ray_release(dev_link_t *link
     int i;
     
     DEBUG(1, "ray_release(0x%p)\n", link);
-    /* If the device is currently in use, we won't release until it
-      is actually closed.
-    */
-    if (link->open) {
-        DEBUG(1, "ray_cs: release postponed, '%s' still open\n",
-              link->dev->dev_name);
-        link->state |= DEV_STALE_CONFIG;
-        return;
-    }
+
     del_timer(&local->timer);
     link->state &= ~DEV_CONFIG;
 
@@ -900,9 +889,6 @@ static void ray_release(dev_link_t *link
     if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseIRQ ret = %x\n",i);
 
     DEBUG(2,"ray_release ending\n");
-
-    if (link->state & DEV_STALE_CONFIG)
-	    ray_detach(link);
 }
 
 /*=============================================================================
@@ -1724,8 +1710,6 @@ static int ray_dev_close(struct net_devi
 
     link->open--;
     netif_stop_queue(dev);
-    if (link->state & DEV_STALE_CONFIG)
-	    ray_release(link);
 
     /* In here, we should stop the hardware (stop card from beeing active)
      * and set local->card_status to CARD_AWAITING_PARAM, so that while the
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/wavelan_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/wavelan_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/wavelan_cs.c	2004-01-19 23:29:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/wavelan_cs.c	2004-02-18 22:41:02.000000000 +0000
@@ -4155,18 +4155,6 @@ wv_pcmcia_release(dev_link_t *link)
   printk(KERN_DEBUG "%s: -> wv_pcmcia_release(0x%p)\n", dev->name, link);
 #endif
 
-  /* If the device is currently in use, we won't release until it is
-   * actually closed. */
-  if(link->open)
-    {
-#ifdef DEBUG_CONFIG_INFO
-      printk(KERN_DEBUG "%s: wv_pcmcia_release: release postponed, device still open\n",
-	     dev->name);
-#endif
-      link->state |= DEV_STALE_CONFIG;
-      return;
-    }
-
   /* Don't bother checking to see if these succeed or not */
   iounmap((u_char *)dev->mem_start);
   pcmcia_release_window(link->win);
@@ -4179,9 +4167,6 @@ wv_pcmcia_release(dev_link_t *link)
 #ifdef DEBUG_CONFIG_TRACE
   printk(KERN_DEBUG "%s: <- wv_pcmcia_release()\n", dev->name);
 #endif
-
-  if (link->state & DEV_STALE_CONFIG)
-	  wavelan_detach(link);
 }
 
 /************************ INTERRUPT HANDLING ************************/
@@ -4634,10 +4619,6 @@ wavelan_close(struct net_device *	dev)
       /* Power down the module */
       hacr_write(base, HACR_DEFAULT & (~HACR_PWR_STAT));
     }
-  else
-    /* The card is no more there (flag is activated in wv_pcmcia_release) */
-    if(link->state & DEV_STALE_CONFIG)
-      wv_pcmcia_release(link);
 
 #ifdef DEBUG_CALLBACK_TRACE
   printk(KERN_DEBUG "%s: <-wavelan_close()\n", dev->name);
@@ -4802,14 +4783,6 @@ wavelan_detach(dev_link_t *	link)
     {
       /* Some others haven't done their job : give them another chance */
       wv_pcmcia_release(link);
-      if(link->state & DEV_STALE_CONFIG)
-	{
-#ifdef DEBUG_CONFIG_INFO
-	  printk(KERN_DEBUG "wavelan_detach: detach postponed,"
-		 " '%s' still locked\n", link->dev->dev_name);
-#endif
-	  return;
-	}
     }
 
   /* Break the link with Card Services */
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/wl3501_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/wl3501_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/wl3501_cs.c	2004-01-19 23:44:26.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/wl3501_cs.c	2004-02-28 10:12:49.000000000 +0000
@@ -1306,10 +1306,6 @@ static int wl3501_close(struct net_devic
 	/* Mask interrupts from the SUTRO */
 	wl3501_block_interrupt(this);
 
-	if (link->state & DEV_STALE_CONFIG) {
-		link->state |= DEV_RELEASE_PENDING;
-		wl3501_release(link);
-	}
 	rc = 0;
 	printk(KERN_INFO "%s: WL3501 closed\n", dev->name);
 out:
@@ -2220,15 +2216,6 @@ static void wl3501_release(dev_link_t *l
 {
 	struct net_device *dev = link->priv;
 
-	/* If the device is currently in use, we won't release until it is
-	 * actually closed. */
-	if (link->open) {
-		dprintk(1, "release postponed, '%s' still open",
-			link->dev->dev_name);
-		link->state |= DEV_STALE_CONFIG;
-		goto out;
-	}
-
 	/* Unlink the device chain */
 	if (link->dev) {
 		unregister_netdev(dev);
@@ -2240,11 +2227,6 @@ static void wl3501_release(dev_link_t *l
 	pcmcia_release_io(link->handle, &link->io);
 	pcmcia_release_irq(link->handle, &link->irq);
 	link->state &= ~DEV_CONFIG;
-
-	if (link->state & DEV_STALE_CONFIG)
-		wl3501_detach(link);
-out:
-	return;
 }
 
 /**
diff -purN linux-post-2.6.4rc1-20040301/drivers/scsi/libata-core.c linux-post-2.6.4rc1-20040302/drivers/scsi/libata-core.c
--- linux-post-2.6.4rc1-20040301/drivers/scsi/libata-core.c	2004-02-26 03:41:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/scsi/libata-core.c	2004-02-28 22:01:12.000000000 +0000
@@ -2005,6 +2005,14 @@ void ata_eng_timeout(struct ata_port *ap
 		goto out;
 	}
 
+	/* hack alert!  We cannot use the supplied completion
+	 * function from inside the ->eh_strategy_handler() thread.
+	 * libata is the only user of ->eh_strategy_handler() in
+	 * any kernel, so the default scsi_done() assumes it is
+	 * not being called from the SCSI EH.
+	 */
+	qc->scsidone = scsi_finish_command;
+
 	switch (qc->tf.protocol) {
 	case ATA_PROT_DMA_READ:
 	case ATA_PROT_DMA_WRITE:
diff -purN linux-post-2.6.4rc1-20040301/drivers/scsi/scsi.c linux-post-2.6.4rc1-20040302/drivers/scsi/scsi.c
--- linux-post-2.6.4rc1-20040301/drivers/scsi/scsi.c	2004-02-24 17:34:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/scsi/scsi.c	2004-02-28 22:01:12.000000000 +0000
@@ -847,6 +847,7 @@ void scsi_finish_command(struct scsi_cmn
 
 	cmd->done(cmd);
 }
+EXPORT_SYMBOL(scsi_finish_command);
 
 /*
  * Function:	scsi_adjust_queue_depth()
diff -purN linux-post-2.6.4rc1-20040301/drivers/scsi/scsi_priv.h linux-post-2.6.4rc1-20040302/drivers/scsi/scsi_priv.h
--- linux-post-2.6.4rc1-20040301/drivers/scsi/scsi_priv.h	2003-09-29 12:37:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/scsi/scsi_priv.h	2004-02-28 22:01:12.000000000 +0000
@@ -77,7 +77,6 @@ extern int scsi_dispatch_cmd(struct scsi
 extern int scsi_setup_command_freelist(struct Scsi_Host *shost);
 extern void scsi_destroy_command_freelist(struct Scsi_Host *shost);
 extern void scsi_done(struct scsi_cmnd *cmd);
-extern void scsi_finish_command(struct scsi_cmnd *cmd);
 extern int scsi_retry_command(struct scsi_cmnd *cmd);
 extern int scsi_insert_special_req(struct scsi_request *sreq, int);
 extern void scsi_init_cmd_from_req(struct scsi_cmnd *cmd,
diff -purN linux-post-2.6.4rc1-20040301/drivers/usb/class/usblp.c linux-post-2.6.4rc1-20040302/drivers/usb/class/usblp.c
--- linux-post-2.6.4rc1-20040301/drivers/usb/class/usblp.c	2004-02-09 15:03:32.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/usb/class/usblp.c	2004-03-01 07:17:24.000000000 +0000
@@ -603,7 +603,7 @@ static ssize_t usblp_write(struct file *
 {
 	DECLARE_WAITQUEUE(wait, current);
 	struct usblp *usblp = file->private_data;
-	int timeout, err = 0, transfer_length;
+	int timeout, err = 0, transfer_length = 0;
 	size_t writecount = 0;
 
 	while (writecount < count) {
@@ -654,6 +654,16 @@ static ssize_t usblp_write(struct file *
 			continue;
 		}
 
+		/* We must increment writecount here, and not at the
+		 * end of the loop. Otherwise, the final loop iteration may
+		 * be skipped, leading to incomplete printer output.
+		 */
+		writecount += transfer_length;
+		if (writecount == count) {
+			up(&usblp->sem);
+			break;
+		}
+
 		transfer_length=(count - writecount);
 		if (transfer_length > USBLP_BUF_SIZE)
 			transfer_length = USBLP_BUF_SIZE;
@@ -677,8 +687,6 @@ static ssize_t usblp_write(struct file *
 			break;
 		}
 		up (&usblp->sem);
-
-		writecount += transfer_length;
 	}
 
 	return count;
diff -purN linux-post-2.6.4rc1-20040301/drivers/usb/host/ohci-sa1111.c linux-post-2.6.4rc1-20040302/drivers/usb/host/ohci-sa1111.c
--- linux-post-2.6.4rc1-20040301/drivers/usb/host/ohci-sa1111.c	2004-02-27 21:50:27.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/usb/host/ohci-sa1111.c	2004-02-28 17:37:22.000000000 +0000
@@ -120,7 +120,13 @@ static irqreturn_t usb_hcd_sa1111_hcim_i
 	}
 #endif
 
-	return usb_hcd_irq(irq, hcd, r);
+	usb_hcd_irq(irq, hcd, r);
+
+	/*
+	 * SA1111 seems to re-assert its interrupt immediately
+	 * after processing an interrupt.  Always return IRQ_HANDLED.
+	 */
+	return IRQ_HANDLED;
 }
 
 /*-------------------------------------------------------------------------*/
diff -purN linux-post-2.6.4rc1-20040301/fs/compat_ioctl.c linux-post-2.6.4rc1-20040302/fs/compat_ioctl.c
--- linux-post-2.6.4rc1-20040301/fs/compat_ioctl.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/fs/compat_ioctl.c	2004-03-01 14:18:41.000000000 +0000
@@ -1458,6 +1458,7 @@ static int cdrom_do_generic_command(unsi
 	struct cdrom_generic_command *cgc;
 	struct cdrom_generic_command32 *cgc32;
 	unsigned char dir;
+	int itmp;
 
 	cgc = compat_alloc_user_space(sizeof(*cgc));
 	cgc32 = compat_ptr(arg);
@@ -1469,12 +1470,16 @@ static int cdrom_do_generic_command(unsi
 	    __cgc_do_ptr((void **) &cgc->sense, &cgc32->sense))
 		return -EFAULT;
 
-	if (get_user(dir, &cgc->data_direction) ||
-	    put_user(dir, &cgc32->data_direction))
+	if (get_user(dir, &cgc32->data_direction) ||
+	    put_user(dir, &cgc->data_direction))
 		return -EFAULT;
 
-	if (copy_in_user(&cgc->quiet, &cgc32->quiet,
-			 2 * sizeof(int)))
+	if (get_user(itmp, &cgc32->quiet) ||
+	    put_user(itmp, &cgc->quiet))
+		return -EFAULT;
+
+	if (get_user(itmp, &cgc32->timeout) ||
+	    put_user(itmp, &cgc->timeout))
 		return -EFAULT;
 
 	if (__cgc_do_ptr(&cgc->reserved[0], &cgc32->reserved[0]))
diff -purN linux-post-2.6.4rc1-20040301/include/asm-ppc64/vio.h linux-post-2.6.4rc1-20040302/include/asm-ppc64/vio.h
--- linux-post-2.6.4rc1-20040301/include/asm-ppc64/vio.h	2004-02-27 23:02:35.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-ppc64/vio.h	2004-03-01 16:04:24.000000000 +0000
@@ -94,8 +94,8 @@ static inline struct vio_driver *to_vio_
 struct vio_dev {
 	struct device_node *archdata;   /* Open Firmware node */
 	void *driver_data;              /* data private to the driver */
-	unsigned long unit_address;	
 	struct iommu_table *iommu_table;     /* vio_map_* uses this */
+	uint32_t unit_address;	
 	unsigned int irq;
 
 	struct device dev;
diff -purN linux-post-2.6.4rc1-20040301/include/asm-sparc64/thread_info.h linux-post-2.6.4rc1-20040302/include/asm-sparc64/thread_info.h
--- linux-post-2.6.4rc1-20040301/include/asm-sparc64/thread_info.h	2003-07-12 09:05:37.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-sparc64/thread_info.h	2004-02-29 05:08:39.000000000 +0000
@@ -142,13 +142,30 @@ register struct thread_info *current_thr
 
 /* thread information allocation */
 #if PAGE_SHIFT == 13
-#define alloc_thread_info(tsk)((struct thread_info *)__get_free_pages(GFP_KERNEL, 1))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),1)
+#define __THREAD_INFO_ORDER	1
 #else /* PAGE_SHIFT == 13 */
-#define alloc_thread_info(tsk)((struct thread_info *)__get_free_pages(GFP_KERNEL, 0))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),0)
+#define __THREAD_INFO_ORDER	0
 #endif /* PAGE_SHIFT == 13 */
 
+#ifdef CONFIG_DEBUG_STACK_USAGE
+#define alloc_thread_info(tsk)					\
+({								\
+	struct thread_info *ret;				\
+								\
+	ret = (struct thread_info *)				\
+	  __get_free_pages(GFP_KERNEL, __THREAD_INFO_ORDER);	\
+	if (ret)						\
+		memset(ret, 0, PAGE_SIZE<<__THREAD_INFO_ORDER);	\
+	ret;							\
+})
+#else
+#define alloc_thread_info(tsk) \
+	((struct thread_info *)__get_free_pages(GFP_KERNEL, __THREAD_INFO_ORDER))
+#endif
+
+#define free_thread_info(ti) \
+	free_pages((unsigned long)(ti),__THREAD_INFO_ORDER)
+
 #define __thread_flag_byte_ptr(ti)	\
 	((unsigned char *)(&((ti)->flags)))
 #define __cur_thread_flag_byte_ptr	__thread_flag_byte_ptr(current_thread_info())
diff -purN linux-post-2.6.4rc1-20040301/include/scsi/scsi_cmnd.h linux-post-2.6.4rc1-20040302/include/scsi/scsi_cmnd.h
--- linux-post-2.6.4rc1-20040301/include/scsi/scsi_cmnd.h	2004-02-23 14:21:27.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/scsi/scsi_cmnd.h	2004-02-28 22:01:12.000000000 +0000
@@ -159,5 +159,6 @@ struct scsi_cmnd {
 extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, int);
 extern void scsi_put_command(struct scsi_cmnd *);
 extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+extern void scsi_finish_command(struct scsi_cmnd *cmd);
 
 #endif /* _SCSI_SCSI_CMND_H */
