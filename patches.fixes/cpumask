Here's a workaround patch for this.  The problem was that the kernel was
truncating the cpumask display after 99 chars of output.  For any value
of NR_CPUS over 352, this guarantees incorrect results.  The low order
bits are truncated, as if the mask were shifted right before displaying.

I didn't have a copy of numactl on the system I was testing this
on, so didn't test that.  The only testing I've done was to reboot
and display the file:

  /sys/devices/system/node/node1/cpumap

This was on margin2, a 4 CPU system, building sn2_defconfig with
NR_CPUS=512.

Before this change, the above cpumap file contained the 99 chars:

  00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000

After this change, it contained the (apparently correct) 144 chars:

 00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,0000000c

As should be obvious from the comment, more work is needed here.
I don't know who will or should do this work, nor when they can.
Not me, not today.

Index: 2.6.6-rc3-mm2-bitmapv5/drivers/base/node.c
===================================================================
--- 2.6.6-rc3-mm2-bitmapv5.orig/drivers/base/node.c	2004-05-06 05:54:12.000000000 -0700
+++ 2.6.6-rc3-mm2-bitmapv5/drivers/base/node.c	2004-05-18 15:51:04.000000000 -0700
@@ -21,9 +21,25 @@
 	cpumask_t mask = node_dev->cpumap;
 	int len;
 
-	/* FIXME - someone should pass us a buffer size (count) or
-	 * use seq_file or something to avoid buffer overrun risk. */
-	len = cpumask_scnprintf(buf, 99 /* XXX FIXME */, mask);
+	/*
+	 * Serious b**t ugly hack alert:
+	 *  1) The following will overwrite a kernel buf[] if NR_CPUS
+	 *     large enough that cpumask_scnprintf() result too big.
+	 *  2) The following will overwrite users read buffer if it isn't
+	 *     large enough to hold cpumask_scnprintf() result.
+	 *  3) The following may return a count larger than that asked
+	 *     for in the read, possibly confusing unsuspecting user code.
+	 *  4) For the above, someone should pass us a buffer size (count)
+	 *     or use seq_file or something to avoid buffer overrun risks.
+	 *  5) Following hardcodes that mask scnprintf format requires 9
+	 *     chars of output for each 32 bits of mask or fraction.
+	 *  6) Following prints stale node_dev->cpumap value, instead of
+	 *     evaluating afresh node_to_cpumask(node_dev->sysdev.id).
+	 *  7) Why does struct node even has the field cpumap.  Won't it
+	 *     just get stale, especially in the face of cpu hotplug?
+	 *						 -- anon
+	 */
+	len = cpumask_scnprintf(buf, ((NR_CPUS+31)/32)*9 /* XXX FIXME */, mask);
 	len += sprintf(buf + len, "\n");
 	return len;
 }
