From: Russ Anderson <rja@sgi.com>
Subject: sgi-xpc: need to pass the physical address, not virtual.
Patch-mainline: c8182f0016fb65a721c4fbe487909a2d56178135
References: bnc#458811

xpc needs to pass the physical address, not virtual.

Signed-off-by: Russ Anderson <rja@sgi.com>
Acked-by: Dean Nelson <dcn@sgi.com>
Acked-by: Raymund Will <rw@suse.de>

---
Testing uncovered this problem.  The virtual address happens to work
most of the time due to the way bios was masking off the node bits.
Passing the physical address makes it work all of the time.

---
The only difference between the community patch and the sles11 patch is the
path to bios.h is different.  In the community it is
arch/x86/include/asm/uv/bios.h and in sles11 it is include/asm-x86/uv/bios.h.


 include/asm-x86/uv/bios.h |    2 +-
 arch/x86/kernel/bios_uv.c      |    4 +---
 drivers/misc/sgi-xp/xpc_uv.c   |    8 ++++----
 3 files changed, 6 insertions(+), 8 deletions(-)

Index: linux/drivers/misc/sgi-xp/xpc_uv.c
===================================================================
--- linux.orig/drivers/misc/sgi-xp/xpc_uv.c	2008-12-12 10:26:21.000000000 -0800
+++ linux/drivers/misc/sgi-xp/xpc_uv.c	2008-12-12 11:30:46.207944444 -0800
@@ -119,16 +119,16 @@
 	int ret;
 
 #if defined CONFIG_X86_64
-	ret = uv_bios_mq_watchlist_alloc(mq->mmr_blade, mq->address, mq->order,
-					 &mq->mmr_offset);
+	ret = uv_bios_mq_watchlist_alloc(mq->mmr_blade, uv_gpa(mq->address),
+					 mq->order, &mq->mmr_offset);
 	if (ret < 0) {
 		dev_err(xpc_part, "uv_bios_mq_watchlist_alloc() failed, "
 			"ret=%d\n", ret);
 		return ret;
 	}
 #elif defined CONFIG_IA64_GENERIC || defined CONFIG_IA64_SGI_UV
-	ret = sn_mq_watchlist_alloc(mq->mmr_blade, mq->address, mq->order,
-				    &mq->mmr_offset);
+	ret = sn_mq_watchlist_alloc(mq->mmr_blade, uv_gpa(mq->address),
+				    mq->order, &mq->mmr_offset);
 	if (ret < 0) {
 		dev_err(xpc_part, "sn_mq_watchlist_alloc() failed, ret=%d\n",
 			ret);
Index: linux/include/asm-x86/uv/bios.h
===================================================================
--- linux.orig/include/asm-x86/uv/bios.h	2008-12-12 10:26:21.788299688 -0800
+++ linux/include/asm-x86/uv/bios.h	2008-12-12 11:30:46.219945188 -0800
@@ -100,7 +100,7 @@
 
 extern s64 uv_bios_get_sn_info(int, int *, long *, long *, long *);
 extern s64 uv_bios_freq_base(u64, u64 *);
-extern int uv_bios_mq_watchlist_alloc(int, void *, unsigned int,
+extern int uv_bios_mq_watchlist_alloc(int, unsigned long, unsigned int,
 					unsigned long *);
 extern int uv_bios_mq_watchlist_free(int, int);
 extern s64 uv_bios_change_memprotect(u64, u64, enum uv_memprotect);
Index: linux/arch/x86/kernel/bios_uv.c
===================================================================
--- linux.orig/arch/x86/kernel/bios_uv.c	2008-12-12 10:26:21.000000000 -0800
+++ linux/arch/x86/kernel/bios_uv.c	2008-12-12 11:30:46.231945933 -0800
@@ -101,15 +101,13 @@
 }
 
 int
-uv_bios_mq_watchlist_alloc(int blade, void *mq, unsigned int mq_size,
+uv_bios_mq_watchlist_alloc(int blade, unsigned long addr, unsigned int mq_size,
 			   unsigned long *intr_mmr_offset)
 {
 	union uv_watchlist_u size_blade;
-	unsigned long addr;
 	u64 watchlist;
 	s64 ret;
 
-	addr = (unsigned long)mq;
 	size_blade.size = mq_size;
 	size_blade.blade = blade;
 
