diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sp1-ref/fs/bio.c sp1/fs/bio.c
--- sp1-ref/fs/bio.c	2004-10-15 04:34:14.333975976 +0200
+++ sp1/fs/bio.c	2004-10-15 04:32:00.898261288 +0200
@@ -823,6 +823,15 @@ void bio_endio(struct bio *bio, unsigned
 	bio->bi_size -= bytes_done;
 	bio->bi_sector += (bytes_done >> 9);
 
+	if (bio_data_dir(bio) == READ)
+		/*
+		 * If the current cpu has written to the page by hand
+		 * without dma, we must enforce ordering to be sure
+		 * this written data will be visible before we expose
+		 * the page contents to other cpus (for example with
+		 * a set_pte).
+		 */
+		smp_wmb();
 	if (bio->bi_end_io)
 		bio->bi_end_io(bio, bytes_done, error);
 }
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sp1-ref/include/linux/highmem.h sp1/include/linux/highmem.h
--- sp1-ref/include/linux/highmem.h	2004-02-04 16:07:05.000000000 +0100
+++ sp1/include/linux/highmem.h	2004-10-15 04:28:54.000000000 +0200
@@ -40,6 +40,8 @@ static inline void clear_user_highpage(s
 	void *addr = kmap_atomic(page, KM_USER0);
 	clear_user_page(addr, vaddr, page);
 	kunmap_atomic(addr, KM_USER0);
+	/* Make sure this page is cleared on other CPU's too before using it */
+	smp_wmb();
 }
 
 static inline void clear_highpage(struct page *page)
@@ -73,6 +75,8 @@ static inline void copy_user_highpage(st
 	copy_user_page(vto, vfrom, vaddr, to);
 	kunmap_atomic(vfrom, KM_USER0);
 	kunmap_atomic(vto, KM_USER1);
+	/* Make sure this page is cleared on other CPU's too before using it */
+	smp_wmb();
 }
 
 static inline void copy_highpage(struct page *to, struct page *from)
