# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/09/13 14:05:30-07:00 anton@samba.org 
#   [PATCH] Backward compatibility for compat sched_getaffinity
#   
#   The follow patch special cases the NR_CPUS <= BITS_PER_COMPAT_LONG case.
#   Without this patch, a 32bit task would be required to have a 64bit
#   cpumask no matter what value of NR_CPUS are used.
#   
#   With this patch a compat long sized bitmask is allowed if NR_CPUS is
#   small enough to fit within it.
#   
#   Of course applications should be using the glibc wrappers that use an
#   opaque cpu_mask_t type, but there could be older applications using the
#   syscalls directly.
#   
#   Signed-off-by: Anton Blanchard <anton@samba.org>
#   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# 
# kernel/compat.c
#   2004/09/09 05:59:05-07:00 anton@samba.org +7 -3
#   Backward compatibility for compat sched_getaffinity
# 
diff -Nru a/kernel/compat.c b/kernel/compat.c
--- a/kernel/compat.c	2004-09-18 01:10:50 -07:00
+++ b/kernel/compat.c	2004-09-18 01:10:50 -07:00
@@ -446,8 +446,12 @@
 	int ret;
 	cpumask_t mask;
 	unsigned long *k;
+	unsigned int min_length = sizeof(cpumask_t);
 
-	if (len < sizeof(cpumask_t))
+	if (NR_CPUS <= BITS_PER_COMPAT_LONG)
+		min_length = sizeof(compat_ulong_t);
+
+	if (len < min_length)
 		return -EINVAL;
 
 	ret = sched_getaffinity(pid, &mask);
@@ -455,11 +459,11 @@
 		return ret;
 
 	k = cpus_addr(mask);
-	ret = compat_put_bitmap(user_mask_ptr, k, sizeof(cpumask_t) * 8);
+	ret = compat_put_bitmap(user_mask_ptr, k, min_length * 8);
 	if (ret)
 		return ret;
 
-	return sizeof(cpumask_t);
+	return min_length;
 }
 
 static int get_compat_itimerspec(struct itimerspec *dst, 
