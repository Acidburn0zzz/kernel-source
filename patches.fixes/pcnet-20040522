Cumulative PCnet32 fixes from Don Fry.

--- linux/drivers/net/orig.pcnet32.c	2004-05-18 06:57:46.000000000 -0700
+++ linux/drivers/net/pcnet32.c	2004-05-22 14:45:42.896988088 -0700
@@ -22,8 +22,8 @@
  *************************************************************************/
 
 #define DRV_NAME	"pcnet32"
-#define DRV_VERSION	"1.29"
-#define DRV_RELDATE	"04.06.2004"
+#define DRV_VERSION	"1.30a"
+#define DRV_RELDATE	"05.22.2004"
 #define PFX		DRV_NAME ": "
 
 static const char *version =
@@ -86,7 +86,7 @@
 
 static struct net_device *pcnet32_dev;
 
-static int max_interrupt_work = 80;
+static int max_interrupt_work = 2;
 static int rx_copybreak = 200;
 
 #define PCNET32_PORT_AUI      0x00
@@ -239,6 +239,9 @@
  *	   identification code (blink led's) and register dump.
  *	   Don Fry added timer for 971/972 so skbufs don't remain on tx ring
  *	   forever.
+ * v1.30   18 May 2004 Don Fry removed timer and Last Transmit Interrupt
+ *	   (ltint) as they added complexity and didn't give good throughput.
+ * v1.30a  22 May 2004 Don Fry limit frames received during interrupt.
  */
 
 
@@ -343,7 +346,6 @@
     char		tx_full;
     int			options;
     int	shared_irq:1,			/* shared irq possible */
-	ltint:1,			/* enable TxDone-intr inhibitor */
 	dxsuflo:1,			/* disable transmit stop on uflo */
 	mii:1;				/* mii port available */
     struct net_device	*next;
@@ -895,7 +897,7 @@
     *buff++ = a->read_csr(ioaddr, 114);
 
     for (i = 0; i <= 35; i++) {
-	*buff++ = (i == 34) ? 0xdead : a->read_bcr(ioaddr, i); 
+	*buff++ = (i == 34) ? 0xdead : a->read_bcr(ioaddr, i);
     }
 
     if (!(csr0 & 0x0004)) {	/* If not stopped */
@@ -999,7 +1001,7 @@
     struct pcnet32_private *lp;
     dma_addr_t lp_dma_addr;
     int i, media;
-    int fdx, mii, fset, dxsuflo, ltint;
+    int fdx, mii, fset, dxsuflo;
     int chip_version;
     char *chipname;
     struct net_device *dev;
@@ -1030,7 +1032,7 @@
     }
 
     /* initialize variables */
-    fdx = mii = fset = dxsuflo = ltint = 0;
+    fdx = mii = fset = dxsuflo = 0;
     chip_version = (chip_version >> 12) & 0xffff;
 
     switch (chip_version) {
@@ -1050,7 +1052,6 @@
     case 0x2623:
 	chipname = "PCnet/FAST 79C971"; /* PCI */
 	fdx = 1; mii = 1; fset = 1;
-	ltint = 1;
 	break;
     case 0x2624:
 	chipname = "PCnet/FAST+ 79C972"; /* PCI */
@@ -1081,7 +1082,7 @@
 	fdx = 1; mii = 1;
 	break;
     case 0x2628:
-	chipname = "PCnet/FAST III 79C976";
+	chipname = "PCnet/PRO 79C976";
 	fdx = 1; mii = 1;
 	break;
     default:
@@ -1096,20 +1097,13 @@
      *	starting until the packet is loaded. Strike one for reliability, lose
      *	one for latency - although on PCI this isnt a big loss. Older chips
      *	have FIFO's smaller than a packet, so you can't do this.
+     *	Turn on BCR18:BurstRdEn and BCR18:BurstWrEn.
      */
 
     if (fset) {
 	a->write_bcr(ioaddr, 18, (a->read_bcr(ioaddr, 18) | 0x0860));
 	a->write_csr(ioaddr, 80, (a->read_csr(ioaddr, 80) & 0x0C00) | 0x0c00);
 	dxsuflo = 1;
-	ltint = 0;
-    }
-
-    if (ltint) {
-	/* Enable timer to prevent skbuffs from remaining on the tx ring
-	 * forever if no other tx being done.  Set timer period to about
-	 * 122 ms */
-	a->write_bcr(ioaddr, 31, 0x253b);
     }
 
     dev = alloc_etherdev(0);
@@ -1188,7 +1182,6 @@
     lp->mii_if.phy_id_mask = 0x1f;
     lp->mii_if.reg_num_mask = 0x1f;
     lp->dxsuflo = dxsuflo;
-    lp->ltint = ltint;
     lp->mii = mii;
     lp->msg_enable = pcnet32_debug;
     if ((cards_found >= MAX_UNITS) || (options[cards_found] > sizeof(options_mapping)))
@@ -1407,12 +1400,6 @@
     }
 #endif
 
-    if (lp->ltint) { /* Enable TxDone-intr inhibitor */
-	val = lp->a.read_csr (ioaddr, 5);
-	val |= (1<<14);
-	lp->a.write_csr (ioaddr, 5, val);
-    }
-
     lp->init_block.mode = le16_to_cpu((lp->options & PCNET32_PORT_PORTSEL) << 7);
     pcnet32_load_multicast(dev);
 
@@ -1430,11 +1417,6 @@
     lp->a.write_csr (ioaddr, 4, 0x0915);
     lp->a.write_csr (ioaddr, 0, 0x0001);
 
-    if (lp->ltint) {
-	/* start the software timer */
-	lp->a.write_csr(ioaddr, 7, 0x0400);	/* set STINTE */
-    }
-
     netif_start_queue(dev);
 
     /* If we have mii, print the link status and start the watchdog */
@@ -1647,19 +1629,6 @@
      * interrupt when that option is available to us.
      */
     status = 0x8300;
-    entry = (lp->cur_tx - lp->dirty_tx) & TX_RING_MOD_MASK;
-    if ((lp->ltint) &&
-	((entry == TX_RING_SIZE/3) ||
-	 (entry == (TX_RING_SIZE*2)/3) ||
-	 (entry >= TX_RING_SIZE-2)))
-    {
-	/* Enable Successful-TxDone interrupt if we have
-	 * 1/3, 2/3 or nearly all of, our ring buffer Tx'd
-	 * but not yet cleaned up.  Thus, most of the time,
-	 * we will not enable Successful-TxDone interrupts.
-	 */
-	status = 0x9300;
-    }
 
     /* Fill in a Tx ring entry */
 
@@ -1703,7 +1672,7 @@
     struct net_device *dev = dev_id;
     struct pcnet32_private *lp;
     unsigned long ioaddr;
-    u16 csr0, csr7, rap;
+    u16 csr0,rap;
     int boguscnt =  max_interrupt_work;
     int must_restart;
 
@@ -1720,19 +1689,13 @@
     spin_lock(&lp->lock);
 
     rap = lp->a.read_rap(ioaddr);
-    csr0 = lp->a.read_csr (ioaddr, 0);
-    csr7 = lp->ltint ? lp->a.read_csr(ioaddr, 7) : 0;
-
-    while ((csr0 & 0x8600 || csr7 & 0x0800) && --boguscnt >= 0) {
+    while ((csr0 = lp->a.read_csr (ioaddr, 0)) & 0x8600 && --boguscnt >= 0) {
 	if (csr0 == 0xffff) {
 	    break;			/* PCMCIA remove happened */
 	}
 	/* Acknowledge all of the current interrupt sources ASAP. */
 	lp->a.write_csr (ioaddr, 0, csr0 & ~0x004f);
 
-	if (csr7 & 0x0800)
-	    lp->a.write_csr(ioaddr, 7, csr7);
-
 	must_restart = 0;
 
 	if (netif_msg_intr(lp))
@@ -1742,7 +1705,7 @@
 	if (csr0 & 0x0400)		/* Rx interrupt */
 	    pcnet32_rx(dev);
 
-	if (csr0 & 0x0200 || csr7 & 0x0800) {	/* Tx-done or Timer interrupt */
+	if (csr0 & 0x0200) {		/* Tx-done interrupt */
 	    unsigned int dirty_tx = lp->dirty_tx;
 	    int delta;
 
@@ -1803,7 +1766,7 @@
 	    }
 
 	    delta = (lp->cur_tx - dirty_tx) & (TX_RING_MOD_MASK + TX_RING_SIZE);
-	    if (delta >= TX_RING_SIZE) {
+	    if (delta > TX_RING_SIZE) {
 		if (netif_msg_drv(lp))
 		    printk(KERN_ERR "%s: out-of-sync dirty pointer, %d vs. %d, full=%d.\n",
 			    dev->name, dirty_tx, lp->cur_tx, lp->tx_full);
@@ -1849,9 +1812,6 @@
 	    lp->a.write_csr (ioaddr, 0, 0x0004);
 	    pcnet32_restart(dev, 0x0002);
 	}
-
-	csr0 = lp->a.read_csr (ioaddr, 0);
-	csr7 = lp->ltint ? lp->a.read_csr(ioaddr, 7) : 0;
     }
 
     /* Clear any other interrupt, and set interrupt enable. */
@@ -1872,6 +1832,7 @@
 {
     struct pcnet32_private *lp = dev->priv;
     int entry = lp->cur_rx & RX_RING_MOD_MASK;
+    int boguscnt = RX_RING_SIZE / 2;
 
     /* If we own the next entry, it's a new packet. Send it up. */
     while ((short)le16_to_cpu(lp->rx_ring[entry].status) >= 0) {
@@ -1974,6 +1935,7 @@
 	wmb(); /* Make sure owner changes after all others are visible */
 	lp->rx_ring[entry].status |= le16_to_cpu(0x8000);
 	entry = (++lp->cur_rx) & RX_RING_MOD_MASK;
+	if (--boguscnt <= 0) break;	/* don't stay in loop forever */
     }
 
     return 0;
@@ -2002,10 +1964,6 @@
     /* We stop the PCNET32 here -- it occasionally polls memory if we don't. */
     lp->a.write_csr (ioaddr, 0, 0x0004);
 
-    if (lp->ltint) {	/* Disable timer interrupts */
-	lp->a.write_csr(ioaddr, 7, 0x0000);
-    }
-
     /*
      * Switch back to 16bit mode to avoid problems with dumb
      * DOS packet driver after a warm reboot
