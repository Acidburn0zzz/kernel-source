diff -purN linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/iommu.c linux-2.6.4-rc2/arch/ppc64/kernel/iommu.c
--- linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/iommu.c	2004-02-27 17:16:29.000000000 +0000
+++ linux-2.6.4-rc2/arch/ppc64/kernel/iommu.c	2004-03-03 13:26:23.000000000 +0000
@@ -1,12 +1,12 @@
 /*
- * arch/ppc64/kernel/pci_iommu.c
+ * arch/ppc64/kernel/iommu.c
  * Copyright (C) 2001 Mike Corrigan & Dave Engebretsen, IBM Corporation
  * 
  * Rewrite, cleanup, new allocation schemes, virtual merging: 
  * Copyright (C) 2004 Olof Johansson, IBM Corporation
  *               and  Ben. Herrenschmidt, IBM Corporation
  *
- * Dynamic DMA mapping support, platform-independent parts.
+ * Dynamic DMA mapping support, bus-independent parts.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -60,41 +60,57 @@ static int __init setup_iommu(char *str)
 __setup("iommu=", setup_iommu);
 
 static unsigned long iommu_range_alloc(struct iommu_table *tbl, unsigned long npages,
-			      unsigned long *handle)
+				       unsigned long *handle)
 { 
 	unsigned long n, end, i, start;
-	unsigned long hint;
 	unsigned long limit;
 	int largealloc = npages > 15;
+	int pass = 0;
 
-	if (handle && *handle)
-		hint = *handle;
-	else
-		hint = largealloc ? tbl->it_largehint : tbl->it_hint;
+	/* This allocator was derived from x86_64's bit string search */
 
-	/* Most of this is stolen from x86_64's bit string search function */
+	/* Sanity check */
+	if (unlikely(npages) == 0) {
+		if (printk_ratelimit())
+			WARN_ON(1);
+		return NO_TCE;
+	}
 
-	start = hint;
+	if (handle && *handle)
+		start = *handle;
+	else
+		start = largealloc ? tbl->it_largehint : tbl->it_hint;
 
-	/* Use only half of the table for small allocs (less than 15 pages). */
+	/* Use only half of the table for small allocs (15 pages or less) */
+	limit = largealloc ? tbl->it_mapsize : tbl->it_halfpoint;
 
-	limit = largealloc ? tbl->it_mapsize : tbl->it_mapsize >> 1; 
+	if (largealloc && start < tbl->it_halfpoint)
+		start = tbl->it_halfpoint;
 
-	if (largealloc && start < (tbl->it_mapsize >> 1))
-		start = tbl->it_mapsize >> 1;
+	/* The case below can happen if we have a small segment appended
+	 * to a large, or when the previous alloc was at the very end of
+	 * the available space. If so, go back to the initial start.
+	 */
+	if (start >= limit)
+		start = largealloc ? tbl->it_largehint : tbl->it_hint;
 	
  again:
 
 	n = find_next_zero_bit(tbl->it_map, limit, start);
-
 	end = n + npages;
-	if (end >= limit) {
-		if (hint) {
-			start = largealloc ? tbl->it_mapsize >> 1 : 0;
-			hint = 0;
+
+	if (unlikely(end >= limit)) {
+		if (likely(pass++ < 2)) {
+			/* First failure, just rescan the half of the table.
+			 * Second failure, rescan the other half of the table.
+			 */
+			start = (largealloc ^ pass) ? tbl->it_halfpoint : 0;
+			limit = pass ? tbl->it_mapsize : limit;
 			goto again;
-		} else
+		} else {
+			/* Third failure, give up */
 			return NO_TCE;
+		}
 	}
 
 	for (i = n; i < end; i++)
@@ -106,16 +122,17 @@ static unsigned long iommu_range_alloc(s
 	for (i = n; i < end; i++)
 		__set_bit(i, tbl->it_map);
 
-	/* Bump the hint to a new PHB cache line, which
-	 * is 16 entries wide on all pSeries machines.
-	 */
-	if (largealloc)
-		tbl->it_largehint = (end+tbl->it_blocksize-1) &
-					~(tbl->it_blocksize-1);
-	else 
-		tbl->it_hint = (end+tbl->it_blocksize-1) &
-				~(tbl->it_blocksize-1);
+	/* Bump the hint to a new block for small allocs. */
+	if (largealloc) {
+		/* Don't bump to new block to avoid fragmentation */
+		tbl->it_largehint = end;
+	} else {
+		/* Overflow will be taken care of at the next allocation */
+		tbl->it_hint = (end + tbl->it_blocksize - 1) &
+		                ~(tbl->it_blocksize - 1);
+	}
 
+	/* Update handle for SG allocations */
 	if (handle)
 		*handle = end;
 
@@ -123,35 +140,38 @@ static unsigned long iommu_range_alloc(s
 }
 
 dma_addr_t iommu_alloc(struct iommu_table *tbl, void *page,
-		       unsigned int npages, int direction, 
-		       unsigned long *handle)
+		       unsigned int npages, int direction)
 {
 	unsigned long entry, flags;
-	dma_addr_t retTce = NO_TCE;
+	dma_addr_t ret = NO_TCE;
 	
 	spin_lock_irqsave(&(tbl->it_lock), flags);
 
-	/* Allocate a range of entries into the table */
-	entry = iommu_range_alloc(tbl, npages, handle);
+	entry = iommu_range_alloc(tbl, npages, NULL);
+
 	if (unlikely(entry == NO_TCE)) {
 		spin_unlock_irqrestore(&(tbl->it_lock), flags);
 		return NO_TCE;
 	}
-	
-	/* We got the tces we wanted */
+
 	entry += tbl->it_offset;	/* Offset into real TCE table */
-	retTce = entry << PAGE_SHIFT;	/* Set the return dma address */
+	ret = entry << PAGE_SHIFT;	/* Set the return dma address */
 
 	/* Put the TCEs in the HW table */
-	ppc_md.tce_build(tbl, entry, npages, (unsigned long)page & PAGE_MASK, direction);
+	ppc_md.tce_build(tbl, entry, npages, (unsigned long)page & PAGE_MASK,
+			 direction);
+
 
-	/* Flush/invalidate TLBs if necessary */
+	/* Flush/invalidate TLB caches if necessary */
 	if (ppc_md.tce_flush)
 		ppc_md.tce_flush(tbl);
 
 	spin_unlock_irqrestore(&(tbl->it_lock), flags);
 
-	return retTce;
+	/* Make sure updates are seen by hardware */
+	mb();
+
+	return ret;
 }
 
 static void __iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr, 
@@ -168,7 +188,7 @@ static void __iommu_free(struct iommu_ta
 		if (printk_ratelimit()) {
 			printk(KERN_INFO "iommu_free: invalid entry\n");
 			printk(KERN_INFO "\tentry     = 0x%lx\n", entry); 
-			printk(KERN_INFO "\tdma_ddr   = 0x%lx\n", (u64)dma_addr); 
+			printk(KERN_INFO "\tdma_addr  = 0x%lx\n", (u64)dma_addr);
 			printk(KERN_INFO "\tTable     = 0x%lx\n", (u64)tbl);
 			printk(KERN_INFO "\tbus#      = 0x%lx\n", (u64)tbl->it_busno);
 			printk(KERN_INFO "\tmapsize   = 0x%lx\n", (u64)tbl->it_mapsize);
@@ -194,68 +214,30 @@ void iommu_free(struct iommu_table *tbl,
 
 	__iommu_free(tbl, dma_addr, npages);
 
-	/* Flush/invalidate TLBs if necessary */
+	/* Make sure TLB cache is flushed if the HW needs it. We do
+	 * not do an mb() here on purpose, it is not needed on any of
+	 * the current platforms.
+	 */
 	if (ppc_md.tce_flush)
 		ppc_md.tce_flush(tbl);
 
 	spin_unlock_irqrestore(&(tbl->it_lock), flags);
 }
 
-/* 
- * Build a iommu_table structure.  This contains a bit map which
- * is used to manage allocation of the tce space.
- */
-struct iommu_table *iommu_init_table(struct iommu_table *tbl)
-{
-	unsigned long sz;
-	static int welcomed = 0;
-
-	/* it_size is in pages, it_mapsize in number of entries */
-	tbl->it_mapsize = tbl->it_size * tbl->it_entrysize;
-
-	if (systemcfg->platform == PLATFORM_POWERMAC)
-		tbl->it_mapsize = tbl->it_size * (PAGE_SIZE / sizeof(unsigned int));
-	else
-		tbl->it_mapsize = tbl->it_size * (PAGE_SIZE / sizeof(union tce_entry));
-
-	/* sz is the number of bytes needed for the bitmap */
-	sz = (tbl->it_mapsize + 7) >> 3;
-
-	tbl->it_map = (unsigned long *)__get_free_pages(GFP_ATOMIC, get_order(sz));
-	
-	if (!tbl->it_map)
-		panic("iommu_init_table: Can't allocate memory, size %ld bytes\n", sz);
-
-	memset(tbl->it_map, 0, sz);
-
-	tbl->it_hint = 0;
-	tbl->it_largehint = 0;
-	spin_lock_init(&tbl->it_lock);
-
-	if (!welcomed) {
-		printk(KERN_INFO "IOMMU table initialized, virtual merging %s\n",
-		       novmerge ? "disabled" : "enabled");
-		welcomed = 1;
-	}
-
-	return tbl;
-}
-
-
-int iommu_alloc_sg(struct iommu_table *tbl, struct scatterlist *sglist, int nelems,
-		   int direction, unsigned long *handle)
+int iommu_alloc_sg(struct iommu_table *tbl, struct device *dev,
+		   struct scatterlist *sglist, int nelems, int direction)
 {
 	dma_addr_t dma_next, dma_addr;
-	unsigned long flags, vaddr, npages, entry;
-	struct scatterlist *s, *outs, *segstart, *ps;
+	unsigned long flags;
+	struct scatterlist *s, *outs, *segstart;
 	int outcount;
+	unsigned long handle;
 
-	/* Initialize some stuffs */
 	outs = s = segstart = &sglist[0];
 	outcount = 1;
-	ps = NULL;
+	handle = 0;
 
-	/* Init first segment length for error handling */
+	/* Init first segment length for backout at failure */
 	outs->dma_length = 0;
 
 	DBG("mapping %d elements:\n", nelems);
@@ -263,13 +245,21 @@ int iommu_alloc_sg(struct iommu_table *t
 	spin_lock_irqsave(&(tbl->it_lock), flags);
 
 	for (s = outs; nelems; nelems--, s++) {
+		unsigned long vaddr, npages, entry, slen;
+
+		slen = s->length;
+		/* Sanity check */
+		if (slen == 0) {
+			dma_next = 0;
+			continue;
+		}
 		/* Allocate iommu entries for that segment */
 		vaddr = (unsigned long)page_address(s->page) + s->offset;
-		npages = PAGE_ALIGN(vaddr + s->length) - (vaddr & PAGE_MASK);
+		npages = PAGE_ALIGN(vaddr + slen) - (vaddr & PAGE_MASK);
 		npages >>= PAGE_SHIFT;
-		entry = iommu_range_alloc(tbl, npages, handle);
+		entry = iommu_range_alloc(tbl, npages, &handle);
 
-		DBG("  - vaddr: %lx, size: %lx\n", vaddr, s->length);
+		DBG("  - vaddr: %lx, size: %lx\n", vaddr, slen);
 
 		/* Handle failure */
 		if (unlikely(entry == NO_TCE)) {
@@ -293,13 +283,10 @@ int iommu_alloc_sg(struct iommu_table *t
 		/* If we are in an open segment, try merging */
 		if (segstart != s) {
 			DBG("  - trying merge...\n");
-			/* We cannot merge is:
+			/* We cannot merge if:
 			 * - allocated dma_addr isn't contiguous to previous allocation
-			 * - current entry has an offset into the page
-			 * - previous entry didn't end on a page boundary
 			 */
-			if (novmerge || (dma_addr != dma_next) || s->offset ||
-			    (ps->offset + ps->length) % PAGE_SIZE) {
+			if (novmerge || (dma_addr != dma_next)) {
 				/* Can't merge: create a new segment */
 				segstart = s;
 				outcount++; outs++;
@@ -310,31 +297,28 @@ int iommu_alloc_sg(struct iommu_table *t
 			}
 		}
 
-		/* If we are beginning a new segment, fill entries */
 		if (segstart == s) {
+			/* This is a new segment, fill entries */
 			DBG("  - filling new segment.\n");
 			outs->dma_address = dma_addr;
-			outs->dma_length = s->length;
+			outs->dma_length = slen;
 		}
 
 		/* Calculate next page pointer for contiguous check */
-		dma_next = (dma_addr & PAGE_MASK) + (npages << PAGE_SHIFT);
+		dma_next = dma_addr + slen;
 
 		DBG("  - dma next is: %lx\n", dma_next);
-
-		/* Keep a pointer to the previous entry */
-		ps = s;
 	}
 
-	/* Make sure the update is visible to hardware. */
-	mb();
-
-	/* Flush/invalidate TLBs if necessary */
+	/* Flush/invalidate TLB caches if necessary */
 	if (ppc_md.tce_flush)
 		ppc_md.tce_flush(tbl);
 
 	spin_unlock_irqrestore(&(tbl->it_lock), flags);
 
+	/* Make sure updates are seen by hardware */
+	mb();
+
 	DBG("mapped %d elements:\n", outcount);
 
 	/* For the sake of iommu_free_sg, we clear out the length in the
@@ -348,25 +332,26 @@ int iommu_alloc_sg(struct iommu_table *t
 	return outcount;
 
  failure:
-	spin_unlock_irqrestore(&(tbl->it_lock), flags);
 	for (s = &sglist[0]; s <= outs; s++) {
 		if (s->dma_length != 0) {
+			unsigned long vaddr, npages;
+
 			vaddr = s->dma_address & PAGE_MASK;
 			npages = (PAGE_ALIGN(s->dma_address + s->dma_length) - vaddr)
 				>> PAGE_SHIFT;
-			iommu_free(tbl, vaddr, npages);
+			__iommu_free(tbl, vaddr, npages);
 		}
 	}
+	spin_unlock_irqrestore(&(tbl->it_lock), flags);
 	return 0;
 }
 
 
-void iommu_free_sg(struct iommu_table *tbl, struct scatterlist *sglist, int nelems,
-		   int direction)
+void iommu_free_sg(struct iommu_table *tbl, struct scatterlist *sglist,
+		   int nelems)
 {
 	unsigned long flags;
 
-	/* Lock the whole operation to try to free as a "chunk" */
 	spin_lock_irqsave(&(tbl->it_lock), flags);
 
 	while (nelems--) {
@@ -381,9 +366,49 @@ void iommu_free_sg(struct iommu_table *t
 		sglist++;
 	}
 
-	/* Flush/invalidate TLBs if necessary */
+	/* Flush/invalidate TLBs if necessary. As for iommu_free(), we
+	 * do not do an mb() here, the affected platforms do not need it
+	 * when freeing.
+	 */
 	if (ppc_md.tce_flush)
 		ppc_md.tce_flush(tbl);
 
 	spin_unlock_irqrestore(&(tbl->it_lock), flags);
 }
+
+/*
+ * Build a iommu_table structure.  This contains a bit map which
+ * is used to manage allocation of the tce space.
+ */
+struct iommu_table *iommu_init_table(struct iommu_table *tbl)
+{
+	unsigned long sz;
+	static int welcomed = 0;
+
+	/* it_size is in pages, it_mapsize in number of entries */
+	tbl->it_mapsize = (tbl->it_size << PAGE_SHIFT) / tbl->it_entrysize;
+
+	/* Set aside 1/4 of the table for large allocations. */
+	tbl->it_halfpoint = tbl->it_mapsize * 3 / 4;
+
+	/* number of bytes needed for the bitmap */
+	sz = (tbl->it_mapsize + 7) >> 3;
+
+	tbl->it_map = (unsigned long *)__get_free_pages(GFP_ATOMIC, get_order(sz));
+	if (!tbl->it_map)
+		panic("iommu_init_table: Can't allocate %ld bytes\n", sz);
+
+	memset(tbl->it_map, 0, sz);
+
+	tbl->it_hint = 0;
+	tbl->it_largehint = tbl->it_halfpoint;
+	spin_lock_init(&tbl->it_lock);
+
+	if (!welcomed) {
+		printk(KERN_INFO "IOMMU table initialized, virtual merging %s\n",
+		       novmerge ? "disabled" : "enabled");
+		welcomed = 1;
+	}
+
+	return tbl;
+}
diff -purN linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/pci_iommu.c linux-2.6.4-rc2/arch/ppc64/kernel/pci_iommu.c
--- linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/pci_iommu.c	2004-02-27 17:16:29.000000000 +0000
+++ linux-2.6.4-rc2/arch/ppc64/kernel/pci_iommu.c	2004-03-03 13:26:23.000000000 +0000
@@ -99,10 +99,7 @@ void *pci_iommu_alloc_consistent(struct 
 	memset(ret, 0, size);
 
 	/* Set up tces to cover the allocated range */
-	mapping = iommu_alloc(tbl, ret, npages, PCI_DMA_BIDIRECTIONAL, NULL);
-
-	/* Make sure the update is visible to hardware. */
-	mb();
+	mapping = iommu_alloc(tbl, ret, npages, PCI_DMA_BIDIRECTIONAL);
 
 	if (mapping == NO_TCE) {
 		free_pages((unsigned long)ret, order);
@@ -145,7 +142,6 @@ dma_addr_t pci_iommu_map_single(struct p
 	dma_addr_t dma_handle = NO_TCE;
 	unsigned long uaddr;
 	unsigned int npages;
-	unsigned long handle = 0;
 
 	BUG_ON(direction == PCI_DMA_NONE);
 
@@ -156,7 +152,7 @@ dma_addr_t pci_iommu_map_single(struct p
 	tbl = devnode_table(hwdev); 
 
 	if (tbl) {
-		dma_handle = iommu_alloc(tbl, vaddr, npages, direction, &handle);
+		dma_handle = iommu_alloc(tbl, vaddr, npages, direction);
 		if (dma_handle == NO_TCE) {
 			if (printk_ratelimit())  {
 				printk(KERN_INFO "iommu_alloc failed, tbl %p vaddr %p npages %d\n",
@@ -166,8 +162,6 @@ dma_addr_t pci_iommu_map_single(struct p
 			dma_handle |= (uaddr & ~PAGE_MASK);
 	}
 
-	mb();
-
 	return dma_handle;
 }
 
@@ -194,7 +188,6 @@ int pci_iommu_map_sg(struct pci_dev *pde
 	       int direction)
 {
 	struct iommu_table * tbl;
-	unsigned long handle;
 
 	BUG_ON(direction == PCI_DMA_NONE);
 
@@ -205,9 +198,7 @@ int pci_iommu_map_sg(struct pci_dev *pde
 	if (!tbl)
 		return 0;
 
-	handle = 0;
-
-	return iommu_alloc_sg(tbl, sglist, nelems, direction, &handle);
+	return iommu_alloc_sg(tbl, &pdev->dev, sglist, nelems, direction);
 }
 
 void pci_iommu_unmap_sg(struct pci_dev *pdev, struct scatterlist *sglist, int nelems,
@@ -221,7 +212,7 @@ void pci_iommu_unmap_sg(struct pci_dev *
 	if (!tbl)
 		return;
 
-	iommu_free_sg(tbl, sglist, nelems, direction);
+	iommu_free_sg(tbl, sglist, nelems);
 }
 
 /* We support DMA to/from any memory page via the iommu */
diff -purN linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/pmac_setup.c linux-2.6.4-rc2/arch/ppc64/kernel/pmac_setup.c
--- linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/pmac_setup.c	2004-02-27 23:02:35.000000000 +0000
+++ linux-2.6.4-rc2/arch/ppc64/kernel/pmac_setup.c	2004-03-03 10:51:22.000000000 +0000
@@ -95,6 +95,7 @@ void __pmac pmac_show_cpuinfo(struct seq
 					PMAC_MB_INFO_MODEL, 0);
 	unsigned int mbflags = pmac_call_feature(PMAC_FTR_GET_MB_INFO, NULL,
 						 PMAC_MB_INFO_FLAGS, 0);
+	extern unsigned long ppc_tb_freq;
 
 	if (pmac_call_feature(PMAC_FTR_GET_MB_INFO, NULL, PMAC_MB_INFO_NAME,
 			      (long)&mbname) != 0)
@@ -127,20 +128,11 @@ void __pmac pmac_show_cpuinfo(struct seq
 	seq_printf(m, "detected as\t: %d (%s)\n", mbmodel, mbname);
 	seq_printf(m, "pmac flags\t: %08x\n", mbflags);
 
-	/* Checks "l2cr-value" property in the registry */
-	np = find_devices("cpus");	
-	if (np == 0)
-		np = find_type_devices("cpu");	
-	if (np != 0) {
-		unsigned int *l2cr = (unsigned int *)
-			get_property(np, "l2cr-value", NULL);
-		if (l2cr != 0) {
-			seq_printf(m, "l2cr override\t: 0x%x\n", *l2cr);
-		}
-	}
-
 	/* Indicate newworld */
 	seq_printf(m, "pmac-generation\t: NewWorld\n");
+
+	/* Indicate timebase value */
+	seq_printf(m, "timebase\t: %lu\n", ppc_tb_freq);
 }
 
 
diff -purN linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/pmac_time.c linux-2.6.4-rc2/arch/ppc64/kernel/pmac_time.c
--- linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/pmac_time.c	2004-02-12 03:48:00.000000000 +0000
+++ linux-2.6.4-rc2/arch/ppc64/kernel/pmac_time.c	2004-03-04 10:21:01.000000000 +0000
@@ -39,6 +39,8 @@
 
 extern void setup_default_decr(void);
 
+extern unsigned long ppc_tb_freq;
+
 /* Apparently the RTC stores seconds since 1 Jan 1904 */
 #define RTC_OFFSET	2082844800
 
@@ -151,6 +153,7 @@ void __init pmac_calibrate_decr(void)
 	tb_to_us = mulhwu_scale_factor(freq, 1000000);
 	div128_by_32( 1024*1024, 0, tb_ticks_per_sec, &divres );
 	tb_to_xs = divres.result_low;
+	ppc_tb_freq = freq;
 
 	setup_default_decr();
 }
diff -purN linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/vio.c linux-2.6.4-rc2/arch/ppc64/kernel/vio.c
--- linux-post-2.6.4rc1-20040303/arch/ppc64/kernel/vio.c	2004-03-01 16:04:41.000000000 +0000
+++ linux-2.6.4-rc2/arch/ppc64/kernel/vio.c	2004-03-03 13:26:24.000000000 +0000
@@ -432,7 +432,7 @@ dma_addr_t vio_map_single(struct vio_dev
 	tbl = dev->iommu_table;
 
 	if (tbl) {
-		dma_handle = iommu_alloc(tbl, vaddr, npages, direction, NULL);
+		dma_handle = iommu_alloc(tbl, vaddr, npages, direction);
 		dma_handle |= (uaddr & ~PAGE_MASK);
 	}
 
@@ -461,7 +461,6 @@ int vio_map_sg(struct vio_dev *vdev, str
 	       int direction)
 {
 	struct iommu_table *tbl;
-	unsigned long handle;
 
 	BUG_ON(direction == PCI_DMA_NONE);
 
@@ -472,7 +471,7 @@ int vio_map_sg(struct vio_dev *vdev, str
 	if (!tbl)
 		return 0;
 
-	return iommu_alloc_sg(tbl, sglist, nelems, direction, &handle);
+	return iommu_alloc_sg(tbl, &vdev->dev, sglist, nelems, direction);
 }
 EXPORT_SYMBOL(vio_map_sg);
 
@@ -485,7 +484,7 @@ void vio_unmap_sg(struct vio_dev *vdev, 
 
 	tbl = vdev->iommu_table;
 	if (tbl)
-		iommu_free_sg(tbl, sglist, nelems, direction);
+		iommu_free_sg(tbl, sglist, nelems);
 }
 EXPORT_SYMBOL(vio_unmap_sg);
 
@@ -517,7 +516,7 @@ void *vio_alloc_consistent(struct vio_de
 			/* Page allocation succeeded */
 			memset(ret, 0, npages << PAGE_SHIFT);
 			/* Set up tces to cover the allocated range */
-			tce = iommu_alloc(tbl, ret, npages, PCI_DMA_BIDIRECTIONAL, NULL);
+			tce = iommu_alloc(tbl, ret, npages, PCI_DMA_BIDIRECTIONAL);
 			if (tce == NO_TCE) {
 				PPCDBG(PPCDBG_TCE, "vio_alloc_consistent: iommu_alloc failed\n" );
 				free_pages((unsigned long)ret, order);
diff -purN linux-post-2.6.4rc1-20040303/drivers/char/lp.c linux-2.6.4-rc2/drivers/char/lp.c
--- linux-post-2.6.4rc1-20040303/drivers/char/lp.c	2004-01-15 12:13:07.000000000 +0000
+++ linux-2.6.4-rc2/drivers/char/lp.c	2004-03-03 12:45:18.000000000 +0000
@@ -862,10 +862,9 @@ static void lp_detach (struct parport *p
 }
 
 static struct parport_driver lp_driver = {
-	"lp",
-	lp_attach,
-	lp_detach,
-	NULL
+	.name = "lp",
+	.attach = lp_attach,
+	.detach = lp_detach,
 };
 
 int __init lp_init (void)
diff -purN linux-post-2.6.4rc1-20040303/drivers/char/tipar.c linux-2.6.4-rc2/drivers/char/tipar.c
--- linux-post-2.6.4rc1-20040303/drivers/char/tipar.c	2003-09-05 11:31:49.000000000 +0000
+++ linux-2.6.4-rc2/drivers/char/tipar.c	2004-03-03 12:45:18.000000000 +0000
@@ -463,10 +463,9 @@ tipar_detach(struct parport *port)
 }
 
 static struct parport_driver tipar_driver = {
-	"tipar",
-	tipar_attach,
-	tipar_detach,
-	NULL
+	.name = "tipar",
+	.attach = tipar_attach,
+	.detach = tipar_detach,
 };
 
 int __init
diff -purN linux-post-2.6.4rc1-20040303/drivers/ide/pci/pdc202xx_old.c linux-2.6.4-rc2/drivers/ide/pci/pdc202xx_old.c
--- linux-post-2.6.4rc1-20040303/drivers/ide/pci/pdc202xx_old.c	2004-02-26 16:15:30.000000000 +0000
+++ linux-2.6.4-rc2/drivers/ide/pci/pdc202xx_old.c	2004-03-02 19:19:26.000000000 +0000
@@ -397,37 +397,18 @@ static int config_chipset_for_dma (ide_d
 	u8 ultra_66		= ((id->dma_ultra & 0x0010) ||
 				   (id->dma_ultra & 0x0008)) ? 1 : 0;
 
-	switch(dev->device) {
-		case PCI_DEVICE_ID_PROMISE_20267:
-		case PCI_DEVICE_ID_PROMISE_20265:
-		case PCI_DEVICE_ID_PROMISE_20263:
-		case PCI_DEVICE_ID_PROMISE_20262:
-			cable = pdc202xx_old_cable_detect(hwif);
-#if PDC202_DEBUG_CABLE
-			printk(KERN_DEBUG "%s: %s-pin cable, %s-pin cable, %d\n",
-				hwif->name, hwif->udma_four ? "80" : "40",
-				cable ? "40" : "80", cable);
-#endif /* PDC202_DEBUG_CABLE */
-			break;
-		case PCI_DEVICE_ID_PROMISE_20246:
-			ultra_66 = 0;
-			break;
-		default:
-			BUG();
-	}
-
-	if ((ultra_66) && (cable)) {
-#ifdef DEBUG
-		printk(KERN_DEBUG "ULTRA 66/100/133: %s channel of Ultra 66/100/133 "
-			"requires an 80-pin cable for Ultra66 operation.\n",
-			hwif->channel ? "Secondary" : "Primary");
-		printk(KERN_DEBUG "         Switching to Ultra33 mode.\n");
-#endif /* DEBUG */
+	if (dev->device != PCI_DEVICE_ID_PROMISE_20246)
+		cable = pdc202xx_old_cable_detect(hwif);
+	else
+		ultra_66 = 0;
+
+	if (ultra_66 && cable) {
 		printk(KERN_WARNING "Warning: %s channel requires an 80-pin cable for operation.\n", hwif->channel ? "Secondary":"Primary");
 		printk(KERN_WARNING "%s reduced to Ultra33 mode.\n", drive->name);
 	}
 
-	pdc_old_disable_66MHz_clock(drive->hwif);
+	if (dev->device != PCI_DEVICE_ID_PROMISE_20246)
+		pdc_old_disable_66MHz_clock(drive->hwif);
 
 	drive_pci = 0x60 + (drive->dn << 2);
 	pci_read_config_dword(dev, drive_pci, &drive_conf);
diff -purN linux-post-2.6.4rc1-20040303/drivers/ide/pci/pdc202xx_old.h linux-2.6.4-rc2/drivers/ide/pci/pdc202xx_old.h
--- linux-post-2.6.4rc1-20040303/drivers/ide/pci/pdc202xx_old.h	2004-02-19 01:14:51.000000000 +0000
+++ linux-2.6.4-rc2/drivers/ide/pci/pdc202xx_old.h	2004-03-02 18:44:35.000000000 +0000
@@ -5,8 +5,6 @@
 #include <linux/pci.h>
 #include <linux/ide.h>
 
-#define DISPLAY_PDC202XX_TIMINGS
-
 #ifndef SPLIT_BYTE
 #define SPLIT_BYTE(B,H,L)	((H)=(B>>4), (L)=(B-((B>>4)<<4)))
 #endif
@@ -171,32 +169,6 @@ static void decode_registers (u8 registe
 
 #endif /* PDC202XX_DECODE_REGISTER_INFO */
 
-#define set_2regs(a, b)					\
-	do {						\
-		hwif->OUTB((a + adj), indexreg);	\
-		hwif->OUTB(b, datareg);			\
-	} while(0)
-
-#define set_ultra(a, b, c)				\
-	do {						\
-		set_2regs(0x10,(a));			\
-		set_2regs(0x11,(b));			\
-		set_2regs(0x12,(c));			\
-	} while(0)
-
-#define set_ata2(a, b)					\
-	do {						\
-		set_2regs(0x0e,(a));			\
-		set_2regs(0x0f,(b));			\
-	} while(0)
-
-#define set_pio(a, b, c)				\
-	do { 						\
-		set_2regs(0x0c,(a));			\
-		set_2regs(0x0d,(b));			\
-		set_2regs(0x13,(c));			\
-	} while(0)
-
 #define DISPLAY_PDC202XX_TIMINGS
 
 static void init_setup_pdc202ata4(struct pci_dev *dev, ide_pci_device_t *d);
diff -purN linux-post-2.6.4rc1-20040303/drivers/media/video/c-qcam.c linux-2.6.4-rc2/drivers/media/video/c-qcam.c
--- linux-post-2.6.4rc1-20040303/drivers/media/video/c-qcam.c	2003-09-30 00:22:14.000000000 +0000
+++ linux-2.6.4-rc2/drivers/media/video/c-qcam.c	2004-03-03 12:45:18.000000000 +0000
@@ -818,10 +818,9 @@ static void cq_detach(struct parport *po
 }
 
 static struct parport_driver cqcam_driver = {
-	"cqcam",
-	cq_attach,
-	cq_detach,
-	NULL
+	.name = "cqcam",
+	.attach = cq_attach,
+	.detach = cq_detach,
 };
 
 static int __init cqcam_init (void)
diff -purN linux-post-2.6.4rc1-20040303/drivers/media/video/cpia_pp.c linux-2.6.4-rc2/drivers/media/video/cpia_pp.c
--- linux-post-2.6.4rc1-20040303/drivers/media/video/cpia_pp.c	2003-09-30 00:22:14.000000000 +0000
+++ linux-2.6.4-rc2/drivers/media/video/cpia_pp.c	2004-03-03 12:45:18.000000000 +0000
@@ -803,10 +803,9 @@ static void cpia_pp_attach (struct parpo
 }
 
 static struct parport_driver cpia_pp_driver = {
-	"cpia_pp",
-	cpia_pp_attach,
-	cpia_pp_detach,
-	NULL
+	.name = "cpia_pp",
+	.attach = cpia_pp_attach,
+	.detach = cpia_pp_detach,
 };
 
 int cpia_pp_init(void)
@@ -853,11 +852,6 @@ int init_module(void)
 			}
 		}
 	}
-#if defined(CONFIG_KMOD) && defined(CONFIG_PNP_PARPORT_MODULE)
-	if(parport_enumerate() && !parport_enumerate()->probe_info.model) {
-		request_module("parport_probe");
-	}
-#endif
 	return cpia_pp_init();
 }
 
diff -purN linux-post-2.6.4rc1-20040303/drivers/media/video/w9966.c linux-2.6.4-rc2/drivers/media/video/w9966.c
--- linux-post-2.6.4rc1-20040303/drivers/media/video/w9966.c	2004-01-21 19:59:27.000000000 +0000
+++ linux-2.6.4-rc2/drivers/media/video/w9966.c	2004-03-03 12:45:18.000000000 +0000
@@ -959,10 +959,9 @@ static void w9966_detach(struct parport 
 
 
 static struct parport_driver w9966_ppd = {
-	W9966_DRIVERNAME,
-	w9966_attach,
-	w9966_detach,
-	NULL
+	.name = W9966_DRIVERNAME,
+	.attach = w9966_attach,
+	.detach = w9966_detach,
 };
 
 // Module entry point
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/Makefile linux-2.6.4-rc2/drivers/parport/Makefile
--- linux-post-2.6.4rc1-20040303/drivers/parport/Makefile	2003-02-03 22:19:37.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/Makefile	2004-03-03 12:45:16.000000000 +0000
@@ -2,7 +2,7 @@
 # Makefile for the kernel Parallel port device drivers.
 #
 
-parport-objs	:= share.o ieee1284.o ieee1284_ops.o init.o procfs.o
+parport-objs	:= share.o ieee1284.o ieee1284_ops.o procfs.o
 
 ifeq ($(CONFIG_PARPORT_1284),y)
 	parport-objs	+= daisy.o probe.o
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/daisy.c linux-2.6.4-rc2/drivers/parport/daisy.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/daisy.c	2004-02-05 08:47:38.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/daisy.c	2004-03-03 12:45:16.000000000 +0000
@@ -19,6 +19,7 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/module.h>
 #include <linux/parport.h>
 #include <linux/delay.h>
 #include <linux/sched.h>
@@ -79,6 +80,7 @@ static struct parport *clone_parport (st
 		extra->portnum = real->portnum;
 		extra->physport = real;
 		extra->muxport = muxport;
+		real->slaves[muxport-1] = extra;
 	}
 
 	return extra;
@@ -93,7 +95,9 @@ int parport_daisy_init (struct parport *
 	static const char *th[] = { /*0*/"th", "st", "nd", "rd", "th" };
 	int num_ports;
 	int i;
+	int last_try = 0;
 
+again:
 	/* Because this is called before any other devices exist,
 	 * we don't have to claim exclusive access.  */
 
@@ -126,7 +130,7 @@ int parport_daisy_init (struct parport *
 			/* Analyse that port too.  We won't recurse
 			   forever because of the 'port->muxport < 0'
 			   test above. */
-			parport_announce_port (extra);
+			parport_daisy_init(extra);
 		}
 	}
 
@@ -148,6 +152,21 @@ int parport_daisy_init (struct parport *
 		kfree (deviceid);
 	}
 
+	if (!detected && !last_try) {
+		/* No devices were detected.  Perhaps they are in some
+                   funny state; let's try to reset them and see if
+                   they wake up. */
+		parport_daisy_fini (port);
+		parport_write_control (port, PARPORT_CONTROL_SELECT);
+		udelay (50);
+		parport_write_control (port,
+				       PARPORT_CONTROL_SELECT |
+				       PARPORT_CONTROL_INIT);
+		udelay (50);
+		last_try = 1;
+		goto again;
+	}
+
 	return detected;
 }
 
@@ -634,3 +653,13 @@ int parport_find_class (parport_device_c
 	spin_unlock(&topology_lock);
 	return res;
 }
+
+EXPORT_SYMBOL(parport_open);
+EXPORT_SYMBOL(parport_close);
+EXPORT_SYMBOL(parport_device_num);
+EXPORT_SYMBOL(parport_device_coords);
+EXPORT_SYMBOL(parport_daisy_deselect_all);
+EXPORT_SYMBOL(parport_daisy_select);
+EXPORT_SYMBOL(parport_daisy_init);
+EXPORT_SYMBOL(parport_find_device);
+EXPORT_SYMBOL(parport_find_class);
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/ieee1284.c linux-2.6.4-rc2/drivers/parport/ieee1284.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/ieee1284.c	2003-03-06 05:39:37.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/ieee1284.c	2004-03-03 12:45:15.000000000 +0000
@@ -17,6 +17,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/threads.h>
 #include <linux/parport.h>
 #include <linux/delay.h>
@@ -806,3 +807,15 @@ long parport_set_timeout (struct pardevi
 
 	return old;
 }
+
+/* Exported symbols for modules. */
+
+EXPORT_SYMBOL(parport_negotiate);
+EXPORT_SYMBOL(parport_write);
+EXPORT_SYMBOL(parport_read);
+EXPORT_SYMBOL(parport_ieee1284_wakeup);
+EXPORT_SYMBOL(parport_wait_peripheral);
+EXPORT_SYMBOL(parport_poll_peripheral);
+EXPORT_SYMBOL(parport_wait_event);
+EXPORT_SYMBOL(parport_set_timeout);
+EXPORT_SYMBOL(parport_ieee1284_interrupt);
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/ieee1284_ops.c linux-2.6.4-rc2/drivers/parport/ieee1284_ops.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/ieee1284_ops.c	2003-03-06 05:39:37.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/ieee1284_ops.c	2004-03-03 12:45:15.000000000 +0000
@@ -15,6 +15,7 @@
 
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/parport.h>
 #include <linux/delay.h>
 #include <linux/sched.h>
@@ -908,4 +909,13 @@ size_t parport_ieee1284_epp_read_addr (s
 	return ret;
 }
 
-
+EXPORT_SYMBOL(parport_ieee1284_ecp_write_data);
+EXPORT_SYMBOL(parport_ieee1284_ecp_read_data);
+EXPORT_SYMBOL(parport_ieee1284_ecp_write_addr);
+EXPORT_SYMBOL(parport_ieee1284_write_compat);
+EXPORT_SYMBOL(parport_ieee1284_read_nibble);
+EXPORT_SYMBOL(parport_ieee1284_read_byte);
+EXPORT_SYMBOL(parport_ieee1284_epp_write_data);
+EXPORT_SYMBOL(parport_ieee1284_epp_read_data);
+EXPORT_SYMBOL(parport_ieee1284_epp_write_addr);
+EXPORT_SYMBOL(parport_ieee1284_epp_read_addr);
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/init.c linux-2.6.4-rc2/drivers/parport/init.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/init.c	2003-03-06 23:08:36.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/init.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,229 +0,0 @@
-/* Parallel-port initialisation code.
- * 
- * Authors: David Campbell <campbell@torque.net>
- *          Tim Waugh <tim@cyberelk.demon.co.uk>
- *	    Jose Renau <renau@acm.org>
- *
- * based on work by Grant Guenther <grant@torque.net>
- *              and Philip Blundell <Philip.Blundell@pobox.com>
- */
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/threads.h>
-#include <linux/string.h>
-#include <linux/parport.h>
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-
-#ifndef MODULE
-static int io[PARPORT_MAX+1] __initdata = { [0 ... PARPORT_MAX] = 0 };
-#ifdef CONFIG_PARPORT_PC
-static int io_hi[PARPORT_MAX+1] __initdata =
-	{ [0 ... PARPORT_MAX] = PARPORT_IOHI_AUTO };
-#endif
-static int irq[PARPORT_MAX] __initdata = { [0 ... PARPORT_MAX-1] = PARPORT_IRQ_PROBEONLY };
-static int dma[PARPORT_MAX] __initdata = { [0 ... PARPORT_MAX-1] = PARPORT_DMA_NONE };
-
-extern int parport_pc_init(int *io, int *io_hi, int *irq, int *dma);
-extern int parport_sunbpp_init(void);
-extern int parport_amiga_init(void);
-extern int parport_mfc3_init(void);
-extern int parport_atari_init(void);
-
-static int parport_setup_ptr __initdata = 0;
-
-/*
- * Acceptable parameters:
- *
- * parport=0
- * parport=auto
- * parport=0xBASE[,IRQ[,DMA]]
- *
- * IRQ/DMA may be numeric or 'auto' or 'none'
- */
-static int __init parport_setup (char *str)
-{
-	char *endptr;
-	char *sep;
-	int val;
-
-	if (!str || !*str || (*str == '0' && !*(str+1))) {
-		/* Disable parport if "parport=0" in cmdline */
-		io[0] = PARPORT_DISABLE;
-		return 1;
-	}
-
-	if (!strncmp (str, "auto", 4)) {
-		irq[0] = PARPORT_IRQ_AUTO;
-		dma[0] = PARPORT_DMA_AUTO;
-		return 1;
-	}
-
-	val = simple_strtoul (str, &endptr, 0);
-	if (endptr == str) {
-		printk (KERN_WARNING "parport=%s not understood\n", str);
-		return 1;
-	}
-
-	if (parport_setup_ptr == PARPORT_MAX) {
-		printk(KERN_ERR "parport=%s ignored, too many ports\n", str);
-		return 1;
-	}
-	
-	io[parport_setup_ptr] = val;
-	irq[parport_setup_ptr] = PARPORT_IRQ_NONE;
-	dma[parport_setup_ptr] = PARPORT_DMA_NONE;
-
-	sep = strchr (str, ',');
-	if (sep++) {
-		if (!strncmp (sep, "auto", 4))
-			irq[parport_setup_ptr] = PARPORT_IRQ_AUTO;
-		else if (strncmp (sep, "none", 4)) {
-			val = simple_strtoul (sep, &endptr, 0);
-			if (endptr == sep) {
-				printk (KERN_WARNING
-					"parport=%s: irq not understood\n",
-					str);
-				return 1;
-			}
-			irq[parport_setup_ptr] = val;
-		}
-	}
-
-	sep = strchr (sep, ',');
-	if (sep++) {
-		if (!strncmp (sep, "auto", 4))
-			dma[parport_setup_ptr] = PARPORT_DMA_AUTO;
-		else if (!strncmp (sep, "nofifo", 6))
-			dma[parport_setup_ptr] = PARPORT_DMA_NOFIFO;
-		else if (strncmp (sep, "none", 4)) {
-			val = simple_strtoul (sep, &endptr, 0);
-			if (endptr == sep) {
-				printk (KERN_WARNING
-					"parport=%s: dma not understood\n",
-					str);
-				return 1;
-			}
-			dma[parport_setup_ptr] = val;
-		}
-	}
-
-	parport_setup_ptr++;
-	return 1;
-}
-
-__setup ("parport=", parport_setup);
-
-#endif
-
-#ifdef MODULE
-int init_module(void)
-{
-#ifdef CONFIG_SYSCTL
-	parport_default_proc_register ();
-#endif
-	return 0;
-}
-
-void cleanup_module(void)
-{
-#ifdef CONFIG_SYSCTL
-	parport_default_proc_unregister ();
-#endif
-}
-
-#else
-
-int __init parport_init (void)
-{
-	if (io[0] == PARPORT_DISABLE) 
-		return 1;
-
-#ifdef CONFIG_SYSCTL
-	parport_default_proc_register ();
-#endif
-
-#ifdef CONFIG_PARPORT_PC
-	parport_pc_init(io, io_hi, irq, dma);
-#endif
-#ifdef CONFIG_PARPORT_AMIGA
-	parport_amiga_init();
-#endif
-#ifdef CONFIG_PARPORT_MFC3
-	parport_mfc3_init();
-#endif
-#ifdef CONFIG_PARPORT_ATARI
-	parport_atari_init();
-#endif
-#ifdef CONFIG_PARPORT_ARC
-	parport_arc_init();
-#endif
-#ifdef CONFIG_PARPORT_SUNBPP
-	parport_sunbpp_init();
-#endif
-	return 0;
-}
-
-__initcall(parport_init);
-
-#endif
-
-/* Exported symbols for modules. */
-
-EXPORT_SYMBOL(parport_claim);
-EXPORT_SYMBOL(parport_claim_or_block);
-EXPORT_SYMBOL(parport_release);
-EXPORT_SYMBOL(parport_register_port);
-EXPORT_SYMBOL(parport_announce_port);
-EXPORT_SYMBOL(parport_unregister_port);
-EXPORT_SYMBOL(parport_register_driver);
-EXPORT_SYMBOL(parport_unregister_driver);
-EXPORT_SYMBOL(parport_register_device);
-EXPORT_SYMBOL(parport_unregister_device);
-EXPORT_SYMBOL(parport_enumerate);
-EXPORT_SYMBOL(parport_get_port);
-EXPORT_SYMBOL(parport_put_port);
-EXPORT_SYMBOL(parport_find_number);
-EXPORT_SYMBOL(parport_find_base);
-EXPORT_SYMBOL(parport_negotiate);
-EXPORT_SYMBOL(parport_write);
-EXPORT_SYMBOL(parport_read);
-EXPORT_SYMBOL(parport_ieee1284_wakeup);
-EXPORT_SYMBOL(parport_wait_peripheral);
-EXPORT_SYMBOL(parport_poll_peripheral);
-EXPORT_SYMBOL(parport_wait_event);
-EXPORT_SYMBOL(parport_set_timeout);
-EXPORT_SYMBOL(parport_ieee1284_interrupt);
-EXPORT_SYMBOL(parport_ieee1284_ecp_write_data);
-EXPORT_SYMBOL(parport_ieee1284_ecp_read_data);
-EXPORT_SYMBOL(parport_ieee1284_ecp_write_addr);
-EXPORT_SYMBOL(parport_ieee1284_write_compat);
-EXPORT_SYMBOL(parport_ieee1284_read_nibble);
-EXPORT_SYMBOL(parport_ieee1284_read_byte);
-EXPORT_SYMBOL(parport_ieee1284_epp_write_data);
-EXPORT_SYMBOL(parport_ieee1284_epp_read_data);
-EXPORT_SYMBOL(parport_ieee1284_epp_write_addr);
-EXPORT_SYMBOL(parport_ieee1284_epp_read_addr);
-EXPORT_SYMBOL(parport_proc_register);
-EXPORT_SYMBOL(parport_proc_unregister);
-EXPORT_SYMBOL(parport_device_proc_register);
-EXPORT_SYMBOL(parport_device_proc_unregister);
-EXPORT_SYMBOL(parport_default_proc_register);
-EXPORT_SYMBOL(parport_default_proc_unregister);
-EXPORT_SYMBOL(parport_parse_irqs);
-EXPORT_SYMBOL(parport_parse_dmas);
-#ifdef CONFIG_PARPORT_1284
-EXPORT_SYMBOL(parport_open);
-EXPORT_SYMBOL(parport_close);
-EXPORT_SYMBOL(parport_device_id);
-EXPORT_SYMBOL(parport_device_num);
-EXPORT_SYMBOL(parport_device_coords);
-EXPORT_SYMBOL(parport_daisy_deselect_all);
-EXPORT_SYMBOL(parport_daisy_select);
-EXPORT_SYMBOL(parport_daisy_init);
-EXPORT_SYMBOL(parport_find_device);
-EXPORT_SYMBOL(parport_find_class);
-#endif
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/parport_amiga.c linux-2.6.4-rc2/drivers/parport/parport_amiga.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/parport_amiga.c	2003-05-06 13:50:50.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/parport_amiga.c	2004-03-03 12:45:17.000000000 +0000
@@ -234,7 +234,7 @@ static struct parport_operations pp_amig
 
 /* ----------- Initialisation code --------------------------------- */
 
-int __init parport_amiga_init(void)
+static int __init parport_amiga_init(void)
 {
 	struct parport *p;
 	int err;
@@ -262,26 +262,24 @@ int __init parport_amiga_init(void)
 	this_port = p;
 	printk(KERN_INFO "%s: Amiga built-in port using irq\n", p->name);
 	/* XXX: set operating mode */
-	parport_proc_register(p);
-
 	parport_announce_port(p);
 
 	return 0;
 
 out_irq:
-	parport_unregister_port(p);
+	parport_put_port(p);
 out_port:
 	release_mem_region(CIAA_PHYSADDR-1+0x100, 0x100);
 out_mem:
 	return err;
 }
 
-void __exit parport_amiga_exit(void)
+static void __exit parport_amiga_exit(void)
 {
+	parport_remove_port(this_port);
 	if (this_port->irq != PARPORT_IRQ_NONE)
 		free_irq(IRQ_AMIGA_CIAA_FLG, this_port);
-	parport_proc_unregister(this_port);
-	parport_unregister_port(this_port);
+	parport_put_port(this_port);
 	release_mem_region(CIAA_PHYSADDR-1+0x100, 0x100);
 }
 
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/parport_arc.c linux-2.6.4-rc2/drivers/parport/parport_arc.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/parport_arc.c	2003-03-06 23:08:51.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/parport_arc.c	2004-03-03 12:45:17.000000000 +0000
@@ -104,7 +104,7 @@ static struct parport_operations parport
 
 /* --- Initialisation code -------------------------------- */
 
-int parport_arc_init(void)
+static int parport_arc_init(void)
 {
 	/* Archimedes hardware provides only one port, at a fixed address */
 	struct parport *p;
@@ -129,10 +129,11 @@ int parport_arc_init(void)
 
 	printk(KERN_INFO "%s: Archimedes on-board port, using irq %d\n",
 	       p->irq);
-	parport_proc_register(p);
 
 	/* Tell the high-level drivers about the port. */
 	parport_announce_port (p);
 
 	return 1;
 }
+
+module_init(parport_arc_init)
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/parport_atari.c linux-2.6.4-rc2/drivers/parport/parport_atari.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/parport_atari.c	2003-05-09 10:21:33.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/parport_atari.c	2004-03-03 12:45:17.000000000 +0000
@@ -185,8 +185,7 @@ static struct parport_operations parport
 };
 
 
-int __init
-parport_atari_init(void)
+static int __init parport_atari_init(void)
 {
 	struct parport *p;
 	unsigned long flags;
@@ -208,43 +207,34 @@ parport_atari_init(void)
 					  IRQ_MFP_BUSY, PARPORT_DMA_NONE,
 					  &parport_atari_ops);
 		if (!p)
-			return 0;
+			return -ENODEV;
 		if (request_irq(IRQ_MFP_BUSY, parport_atari_interrupt,
 				IRQ_TYPE_SLOW, p->name, p)) {
-			parport_unregister_port (p);
-			return 0;
+			parport_put_port (p);
+			return -ENODEV;
 		}
 
 		this_port = p;
 		printk(KERN_INFO "%s: Atari built-in port using irq\n", p->name);
-		parport_proc_register(p);
-
 		parport_announce_port (p);
 
-		return 1;
+		return 0;
 	}
-	return 0;
+	return -ENODEV;
 }
 
-#ifdef MODULE
+static void __exit parport_atari_exit(void)
+{
+	parport_remove_port(this_port);
+	if (this_port->irq != PARPORT_IRQ_NONE)
+		free_irq(IRQ_MFP_BUSY, this_port);
+	parport_put_port(this_port);
+}
 
 MODULE_AUTHOR("Andreas Schwab");
 MODULE_DESCRIPTION("Parport Driver for Atari builtin Port");
 MODULE_SUPPORTED_DEVICE("Atari builtin Parallel Port");
 MODULE_LICENSE("GPL");
 
-int
-init_module(void)
-{
-	return parport_atari_init() ? 0 : -ENODEV;
-}
-
-void
-cleanup_module(void)
-{
-	if (this_port->irq != PARPORT_IRQ_NONE)
-		free_irq(IRQ_MFP_BUSY, this_port);
-	parport_proc_unregister(this_port);
-	parport_unregister_port(this_port);
-}
-#endif
+module_init(parport_atari_init)
+module_exit(parport_atari_exit)
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/parport_gsc.c linux-2.6.4-rc2/drivers/parport/parport_gsc.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/parport_gsc.c	2004-02-05 08:47:37.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/parport_gsc.c	2004-03-03 12:45:17.000000000 +0000
@@ -412,7 +412,6 @@ struct parport *__devinit parport_gsc_pr
 	}
 #undef printmode
 	printk("]\n");
-	parport_proc_register(p);
 
 	if (p->irq != PARPORT_IRQ_NONE) {
 		if (request_irq (p->irq, parport_gsc_interrupt,
@@ -483,17 +482,17 @@ static void __devexit parport_remove_chi
 	if (p) {
 		struct parport_gsc_private *priv = p->private_data;
 		struct parport_operations *ops = p->ops;
+		parport_remove_port(p);
 		if (p->dma != PARPORT_DMA_NONE)
 			free_dma(p->dma);
 		if (p->irq != PARPORT_IRQ_NONE)
 			free_irq(p->irq, p);
-		parport_proc_unregister(p);
 		if (priv->dma_buf)
 			pci_free_consistent(priv->dev, PAGE_SIZE,
 					    priv->dma_buf,
 					    priv->dma_handle);
 		kfree (p->private_data);
-		parport_unregister_port(p);
+		parport_put_port(p);
 		kfree (ops); /* hope no-one cached it */
 	}
 }
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/parport_mfc3.c linux-2.6.4-rc2/drivers/parport/parport_mfc3.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/parport_mfc3.c	2003-05-06 13:50:50.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/parport_mfc3.c	2004-03-03 12:45:17.000000000 +0000
@@ -320,7 +320,7 @@ static struct parport_operations pp_mfc3
 
 /* ----------- Initialisation code --------------------------------- */
 
-int __init parport_mfc3_init(void)
+static int __init parport_mfc3_init(void)
 {
 	struct parport *p;
 	int pias = 0;
@@ -360,7 +360,6 @@ int __init parport_mfc3_init(void)
 		this_port[pias++] = p;
 		printk(KERN_INFO "%s: Multiface III port using irq\n", p->name);
 		/* XXX: set operating mode */
-		parport_proc_register(p);
 
 		p->private_data = (void *)piabase;
 		parport_announce_port (p);
@@ -370,7 +369,7 @@ int __init parport_mfc3_init(void)
 		continue;
 
 	out_irq:
-		parport_unregister_port(p);
+		parport_put_port(p);
 	out_port:
 		release_mem_region(piabase, sizeof(struct pia));
 	}
@@ -378,20 +377,20 @@ int __init parport_mfc3_init(void)
 	return pias ? 0 : -ENODEV;
 }
 
-void __exit parport_mfc3_exit(void)
+static void __exit parport_mfc3_exit(void)
 {
 	int i;
 
 	for (i = 0; i < MAX_MFC; i++) {
 		if (!this_port[i])
 			continue;
+		parport_remove_port(this_port[i]);
 		if (!this_port[i]->irq != PARPORT_IRQ_NONE) {
 			if (--use_cnt == 0) 
 				free_irq(IRQ_AMIGA_PORTS, &pp_mfc3_ops);
 		}
-		parport_proc_unregister(this_port[i]);
-		parport_unregister_port(this_port[i]);
 		release_mem_region(ZTWO_PADDR(this_port[i]->private_data), sizeof(struct pia));
+		parport_put_port(this_port[i]);
 	}
 }
 
@@ -403,4 +402,3 @@ MODULE_LICENSE("GPL");
 
 module_init(parport_mfc3_init)
 module_exit(parport_mfc3_exit)
-
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/parport_pc.c linux-2.6.4-rc2/drivers/parport/parport_pc.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/parport_pc.c	2004-02-04 05:34:24.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/parport_pc.c	2004-03-03 12:45:17.000000000 +0000
@@ -2107,6 +2107,9 @@ static int __devinit parport_dma_probe (
 
 /* --- Initialisation code -------------------------------- */
 
+static LIST_HEAD(ports_list);
+static spinlock_t ports_lock = SPIN_LOCK_UNLOCKED;
+
 struct parport *parport_pc_probe_port (unsigned long int base,
 				       unsigned long int base_hi,
 				       int irq, int dma,
@@ -2114,39 +2117,30 @@ struct parport *parport_pc_probe_port (u
 {
 	struct parport_pc_private *priv;
 	struct parport_operations *ops;
-	struct parport tmp;
-	struct parport *p = &tmp;
+	struct parport *p;
 	int probedirq = PARPORT_IRQ_NONE;
 	struct resource *base_res;
 	struct resource	*ECR_res = NULL;
 	struct resource	*EPP_res = NULL;
-	char *fake_name = "parport probe";
 
-	/*
-	 * Chicken and Egg problem.  request_region() wants the name of
-	 * the owner, but this instance will not know that name until
-	 * after the parport_register_port() call.  Give request_region()
-	 * a fake name until after parport_register_port(), then use
-	 * rename_region() to set correct name.
-	 */
-	base_res = request_region(base, 3, fake_name);
-	if (base_res == NULL)
-		return NULL;
+	ops = kmalloc(sizeof (struct parport_operations), GFP_KERNEL);
+	if (!ops)
+		goto out1;
+
 	priv = kmalloc (sizeof (struct parport_pc_private), GFP_KERNEL);
-	if (!priv) {
-		printk (KERN_DEBUG "parport (0x%lx): no memory!\n", base);
-		release_region(base, 3);
-		return NULL;
-	}
-	ops = kmalloc (sizeof (struct parport_operations), GFP_KERNEL);
-	if (!ops) {
-		printk (KERN_DEBUG "parport (0x%lx): no memory for ops!\n",
-			base);
-		release_region(base, 3);
-		kfree (priv);
-		return NULL;
-	}
-	memcpy (ops, &parport_pc_ops, sizeof (struct parport_operations));
+	if (!priv)
+		goto out2;
+
+	/* a misnomer, actually - it's allocate and reserve parport number */
+	p = parport_register_port(base, irq, dma, ops);
+	if (!p)
+		goto out3;
+
+	base_res = request_region(base, 3, p->name);
+	if (!base_res)
+		goto out4;
+
+	memcpy(ops, &parport_pc_ops, sizeof (struct parport_operations));
 	priv->ctr = 0xc;
 	priv->ctr_writable = ~0x10;
 	priv->ecr = 0;
@@ -2154,59 +2148,37 @@ struct parport *parport_pc_probe_port (u
 	priv->dma_buf = 0;
 	priv->dma_handle = 0;
 	priv->dev = dev;
-	p->base = base;
+	INIT_LIST_HEAD(&priv->list);
+	priv->port = p;
 	p->base_hi = base_hi;
-	p->irq = irq;
-	p->dma = dma;
 	p->modes = PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT;
-	p->ops = ops;
 	p->private_data = priv;
-	p->physport = p;
 
 	if (base_hi) {
-		ECR_res = request_region(base_hi, 3, fake_name);
+		ECR_res = request_region(base_hi, 3, p->name);
 		if (ECR_res)
 			parport_ECR_present(p);
 	}
 
 	if (base != 0x3bc) {
-		EPP_res = request_region(base+0x3, 5, fake_name);
+		EPP_res = request_region(base+0x3, 5, p->name);
 		if (EPP_res)
 			if (!parport_EPP_supported(p))
 				parport_ECPEPP_supported(p);
 	}
 	if (!parport_SPP_supported (p))
 		/* No port. */
-		goto errout;
+		goto out5;
 	if (priv->ecr)
 		parport_ECPPS2_supported(p);
 	else
-		parport_PS2_supported (p);
+		parport_PS2_supported(p);
 
-	if (!(p = parport_register_port(base, PARPORT_IRQ_NONE,
-					PARPORT_DMA_NONE, ops)))
-		goto errout;
-
-	/*
-	 * Now the real name is known... Replace the fake name
-	 * in the resources with the correct one.
-	 */
-	rename_region(base_res, p->name);
-	if (ECR_res)
-		rename_region(ECR_res, p->name);
-	if (EPP_res)
-		rename_region(EPP_res, p->name);
-
-	p->base_hi = base_hi;
-	p->modes = tmp.modes;
 	p->size = (p->modes & PARPORT_MODE_EPP)?8:3;
-	p->private_data = priv;
 
 	printk(KERN_INFO "%s: PC-style at 0x%lx", p->name, p->base);
 	if (p->base_hi && priv->ecr)
 		printk(" (0x%lx)", p->base_hi);
-	p->irq = irq;
-	p->dma = dma;
 	if (p->irq == PARPORT_IRQ_AUTO) {
 		p->irq = PARPORT_IRQ_NONE;
 		parport_irq_probe(p);
@@ -2269,7 +2241,6 @@ struct parport *parport_pc_probe_port (u
 	printk("]\n");
 	if (probedirq != PARPORT_IRQ_NONE) 
 		printk(KERN_INFO "%s: irq %d detected\n", p->name, probedirq);
-	parport_proc_register(p);
 
 	/* If No ECP release the ports grabbed above. */
 	if (ECR_res && (p->modes & PARPORT_MODE_ECP) == 0) {
@@ -2330,28 +2301,40 @@ struct parport *parport_pc_probe_port (u
 	/* Now that we've told the sharing engine about the port, and
 	   found out its characteristics, let the high-level drivers
 	   know about it. */
+	spin_lock(&ports_lock);
+	list_add(&priv->list, &ports_list);
+	spin_unlock(&ports_lock);
 	parport_announce_port (p);
 
 	return p;
 
-errout:
-	release_region(p->base, 3);
+out5:
 	if (ECR_res)
 		release_region(base_hi, 3);
 	if (EPP_res)
 		release_region(base+0x3, 5);
-
+	release_region(base, 3);
+out4:
+	parport_put_port(p);
+out3:
 	kfree (priv);
+out2:
 	kfree (ops);
+out1:
 	return NULL;
 }
 
+EXPORT_SYMBOL (parport_pc_probe_port);
+
 void parport_pc_unregister_port (struct parport *p)
 {
-#ifdef CONFIG_PARPORT_PC_FIFO
 	struct parport_pc_private *priv = p->private_data;
-#endif /* CONFIG_PARPORT_PC_FIFO */
 	struct parport_operations *ops = p->ops;
+
+	parport_remove_port(p);
+	spin_lock(&ports_lock);
+	list_del_init(&priv->list);
+	spin_unlock(&ports_lock);
 	if (p->dma != PARPORT_DMA_NONE)
 		free_dma(p->dma);
 	if (p->irq != PARPORT_IRQ_NONE)
@@ -2361,7 +2344,6 @@ void parport_pc_unregister_port (struct 
 		release_region(p->base + 3, p->size - 3);
 	if (p->modes & PARPORT_MODE_ECP)
 		release_region(p->base_hi, 3);
-	parport_proc_unregister(p);
 #ifdef CONFIG_PARPORT_PC_FIFO
 	if (priv->dma_buf)
 		pci_free_consistent(priv->dev, PAGE_SIZE,
@@ -2369,10 +2351,12 @@ void parport_pc_unregister_port (struct 
 				    priv->dma_handle);
 #endif /* CONFIG_PARPORT_PC_FIFO */
 	kfree (p->private_data);
-	parport_unregister_port(p);
+	parport_put_port(p);
 	kfree (ops); /* hope no-one cached it */
 }
 
+EXPORT_SYMBOL (parport_pc_unregister_port);
+
 #ifdef CONFIG_PCI
 
 /* ITE support maintained by Rich Liu <richliu@poorman.org> */
@@ -2931,45 +2915,57 @@ static int __init parport_pc_find_ports 
 	return count;
 }
 
-int __init parport_pc_init (int *io, int *io_hi, int *irq, int *dma)
-{
-	int count = 0, i = 0;
-	/* try to activate any PnP parports first */
-	pnp_register_driver(&parport_pc_pnp_driver);
+/*
+ *	Piles of crap below pretend to be a parser for module and kernel
+ *	parameters.  Say "thank you" to whoever had come up with that
+ *	syntax and keep in mind that code below is a cleaned up version.
+ */
 
-	if (io && *io) {
-		/* Only probe the ports we were given. */
-		user_specified = 1;
-		do {
-			if ((*io_hi) == PARPORT_IOHI_AUTO)
-			       *io_hi = 0x400 + *io;
-			if (parport_pc_probe_port(*(io++), *(io_hi++),
-						  *(irq++), *(dma++), NULL))
-				count++;
-		} while (*io && (++i < PARPORT_PC_MAX_PORTS));
-	} else {
-		count += parport_pc_find_ports (irq[0], dma[0]);
+static int __initdata io[PARPORT_PC_MAX_PORTS+1] = { [0 ... PARPORT_PC_MAX_PORTS] = 0 };
+static int __initdata io_hi[PARPORT_PC_MAX_PORTS+1] =
+	{ [0 ... PARPORT_PC_MAX_PORTS] = PARPORT_IOHI_AUTO };
+static int __initdata dmaval[PARPORT_PC_MAX_PORTS] = { [0 ... PARPORT_PC_MAX_PORTS-1] = PARPORT_DMA_NONE };
+static int __initdata irqval[PARPORT_PC_MAX_PORTS] = { [0 ... PARPORT_PC_MAX_PORTS-1] = PARPORT_IRQ_PROBEONLY };
+
+static int __init parport_parse_param(const char *s, int *val,
+				int automatic, int none, int nofifo)
+{
+	if (!s)
+		return 0;
+	if (!strncmp(s, "auto", 4))
+		*val = automatic;
+	else if (!strncmp(s, "none", 4))
+		*val = none;
+	else if (nofifo && !strncmp(s, "nofifo", 4))
+		*val = nofifo;
+	else {
+		char *ep;
+		unsigned long r = simple_strtoul(s, &ep, 0);
+		if (ep != s)
+			*val = r;
+		else {
+			printk(KERN_ERR "parport: bad specifier `%s'\n", s);
+			return -1;
+		}
 	}
+	return 0;
+}
 
-	return count;
+static int __init parport_parse_irq(const char *irqstr, int *val)
+{
+	return parport_parse_param(irqstr, val, PARPORT_IRQ_AUTO,
+				     PARPORT_IRQ_NONE, 0);
 }
 
-/* Exported symbols. */
-EXPORT_SYMBOL (parport_pc_probe_port);
-EXPORT_SYMBOL (parport_pc_unregister_port);
+static int __init parport_parse_dma(const char *dmastr, int *val)
+{
+	return parport_parse_param(dmastr, val, PARPORT_DMA_AUTO,
+				     PARPORT_DMA_NONE, PARPORT_DMA_NOFIFO);
+}
 
 #ifdef MODULE
-static int io[PARPORT_PC_MAX_PORTS+1] = { [0 ... PARPORT_PC_MAX_PORTS] = 0 };
-static int io_hi[PARPORT_PC_MAX_PORTS+1] =
-	{ [0 ... PARPORT_PC_MAX_PORTS] = PARPORT_IOHI_AUTO };
-static int dmaval[PARPORT_PC_MAX_PORTS] = { [0 ... PARPORT_PC_MAX_PORTS-1] = PARPORT_DMA_NONE };
-static int irqval[PARPORT_PC_MAX_PORTS] = { [0 ... PARPORT_PC_MAX_PORTS-1] = PARPORT_IRQ_PROBEONLY };
-static const char *irq[PARPORT_PC_MAX_PORTS] = { NULL, };
-static const char *dma[PARPORT_PC_MAX_PORTS] = { NULL, };
-
-MODULE_AUTHOR("Phil Blundell, Tim Waugh, others");
-MODULE_DESCRIPTION("PC-style parallel port driver");
-MODULE_LICENSE("GPL");
+static const char *irq[PARPORT_PC_MAX_PORTS];
+static const char *dma[PARPORT_PC_MAX_PORTS];
 
 MODULE_PARM_DESC(io, "Base I/O address (SPP regs)");
 MODULE_PARM(io, "1-" __MODULE_STRING(PARPORT_PC_MAX_PORTS) "i");
@@ -2985,22 +2981,22 @@ MODULE_PARM_DESC(verbose_probing, "Log c
 MODULE_PARM(verbose_probing, "i");
 #endif
 
-int init_module(void)
-{	
-	/* Work out how many ports we have, then get parport_share to parse
-	   the irq values. */
+static int __init parse_parport_params(void)
+{
 	unsigned int i;
-	int ret;
-	for (i = 0; i < PARPORT_PC_MAX_PORTS && io[i]; i++);
-	if (i) {
-		if (parport_parse_irqs(i, irq, irqval)) return 1;
-		if (parport_parse_dmas(i, dma, dmaval)) return 1;
+	int val;
+
+	for (i = 0; i < PARPORT_PC_MAX_PORTS && io[i]; i++) {
+		if (parport_parse_irq(irq[i], &val))
+			return 1;
+		irqval[i] = val;
+		if (parport_parse_dma(dma[i], &val))
+			return 1;
+		dmaval[i] = val;
 	}
-	else {
+	if (!io[0]) {
 		/* The user can make us use any IRQs or DMAs we find. */
-		int val;
-
-		if (irq[0] && !parport_parse_irqs (1, irq, &val))
+		if (irq[0] && !parport_parse_irq(irq[0], &val))
 			switch (val) {
 			case PARPORT_IRQ_NONE:
 			case PARPORT_IRQ_AUTO:
@@ -3013,7 +3009,7 @@ int init_module(void)
 					"to specify one\n");
 			}
 
-		if (dma[0] && !parport_parse_dmas (1, dma, &val))
+		if (dma[0] && !parport_parse_dma(dma[0], &val))
 			switch (val) {
 			case PARPORT_DMA_NONE:
 			case PARPORT_DMA_AUTO:
@@ -3026,29 +3022,144 @@ int init_module(void)
 					"to specify one\n");
 			}
 	}
+	return 0;
+}
 
-	ret = !parport_pc_init (io, io_hi, irqval, dmaval);
-	if (ret && registered_parport)
-		pci_unregister_driver (&parport_pc_pci_driver);
+#else
 
-	return ret;
+static int parport_setup_ptr __initdata = 0;
+
+/*
+ * Acceptable parameters:
+ *
+ * parport=0
+ * parport=auto
+ * parport=0xBASE[,IRQ[,DMA]]
+ *
+ * IRQ/DMA may be numeric or 'auto' or 'none'
+ */
+static int __init parport_setup (char *str)
+{
+	char *endptr;
+	char *sep;
+	int val;
+
+	if (!str || !*str || (*str == '0' && !*(str+1))) {
+		/* Disable parport if "parport=0" in cmdline */
+		io[0] = PARPORT_DISABLE;
+		return 1;
+	}
+
+	if (!strncmp (str, "auto", 4)) {
+		irqval[0] = PARPORT_IRQ_AUTO;
+		dmaval[0] = PARPORT_DMA_AUTO;
+		return 1;
+	}
+
+	val = simple_strtoul (str, &endptr, 0);
+	if (endptr == str) {
+		printk (KERN_WARNING "parport=%s not understood\n", str);
+		return 1;
+	}
+
+	if (parport_setup_ptr == PARPORT_PC_MAX_PORTS) {
+		printk(KERN_ERR "parport=%s ignored, too many ports\n", str);
+		return 1;
+	}
+
+	io[parport_setup_ptr] = val;
+	irqval[parport_setup_ptr] = PARPORT_IRQ_NONE;
+	dmaval[parport_setup_ptr] = PARPORT_DMA_NONE;
+
+	sep = strchr(str, ',');
+	if (sep++) {
+		if (parport_parse_irq(sep, &val))
+			return 1;
+		irqval[parport_setup_ptr] = val;
+		sep = strchr(sep, ',');
+		if (sep++) {
+			if (parport_parse_dma(sep, &val))
+				return 1;
+			dmaval[parport_setup_ptr] = val;
+		}
+	}
+	parport_setup_ptr++;
+	return 1;
 }
 
-void cleanup_module(void)
+static int __init parse_parport_params(void)
 {
-	/* We ought to keep track of which ports are actually ours. */
-	struct parport *p = parport_enumerate(), *tmp;
+	return io[0] == PARPORT_DISABLE;
+}
 
-	if (!user_specified)
-		pci_unregister_driver (&parport_pc_pci_driver);
+__setup ("parport=", parport_setup);
+#endif
 
-	while (p) {
-		tmp = p->next;
-		if (p->modes & PARPORT_MODE_PCSPP)
-			parport_pc_unregister_port (p);
+/* "Parser" ends here */
 
-		p = tmp;
+static int __init parport_pc_init(void)
+{
+	int count = 0;
+
+	if (parse_parport_params())
+		return -EINVAL;
+
+	/* try to activate any PnP parports first */
+	pnp_register_driver(&parport_pc_pnp_driver);
+
+	if (io[0]) {
+		int i;
+		/* Only probe the ports we were given. */
+		user_specified = 1;
+		for (i = 0; i < PARPORT_PC_MAX_PORTS; i++) {
+			if (!io[i])
+				break;
+			if ((io_hi[i]) == PARPORT_IOHI_AUTO)
+			       io_hi[i] = 0x400 + io[i];
+			if (parport_pc_probe_port(io[i], io_hi[i],
+						  irqval[i], dmaval[i], NULL))
+				count++;
+		}
+	} else {
+		count += parport_pc_find_ports (irqval[0], dmaval[0]);
+		if (!count && registered_parport)
+			pci_unregister_driver (&parport_pc_pci_driver);
+	}
+
+	if (!count) {
+		pnp_unregister_driver (&parport_pc_pnp_driver);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit parport_pc_exit(void)
+{
+	if (registered_parport)
+		pci_unregister_driver (&parport_pc_pci_driver);
+
+	spin_lock(&ports_lock);
+	while (!list_empty(&ports_list)) {
+		struct parport_pc_private *priv;
+		struct parport *port;
+		priv = list_entry(ports_list.next,
+				  struct parport_pc_private, list);
+		port = priv->port;
+		spin_unlock(&ports_lock);
+		parport_pc_unregister_port(port);
+		spin_lock(&ports_lock);
 	}
+	spin_unlock(&ports_lock);
 	pnp_unregister_driver (&parport_pc_pnp_driver);
 }
-#endif
+
+
+MODULE_AUTHOR("Phil Blundell, Tim Waugh, others");
+MODULE_DESCRIPTION("PC-style parallel port driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Phil Blundell, Tim Waugh, others");
+MODULE_DESCRIPTION("PC-style parallel port driver");
+MODULE_LICENSE("GPL");
+module_init(parport_pc_init)
+module_exit(parport_pc_exit)
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/parport_sunbpp.c linux-2.6.4-rc2/drivers/parport/parport_sunbpp.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/parport_sunbpp.c	2004-01-05 19:02:48.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/parport_sunbpp.c	2004-03-03 12:45:17.000000000 +0000
@@ -286,39 +286,49 @@ static struct parport_operations parport
 	.owner		= THIS_MODULE,
 };
 
+typedef struct {
+	struct list_head list;
+	struct parport *port;
+} Node;
+/* no locks, everything's serialized */
+static LIST_HEAD(port_list);
+
 static int __init init_one_port(struct sbus_dev *sdev)
 {
 	struct parport *p;
 	/* at least in theory there may be a "we don't dma" case */
 	struct parport_operations *ops;
 	unsigned long base;
-	int irq, dma, err, size;
+	int irq, dma, err = 0, size;
 	struct bpp_regs *regs;
 	unsigned char value_tcr;
+	Node *node;
 
 	dprintk((KERN_DEBUG "init_one_port(%p): ranges, alloc_io, ", sdev));
+	node = kmalloc(sizeof(Node), GFP_KERNEL);
+	if (!node)
+		goto out0;
+
 	irq = sdev->irqs[0];
 	base = sbus_ioremap(&sdev->resource[0], 0,
 			    sdev->reg_addrs[0].reg_size, 
 			    "sunbpp");
+	if (!base)
+		goto out1;
+
 	size = sdev->reg_addrs[0].reg_size;
 	dma = PARPORT_DMA_NONE;
 
 	dprintk(("alloc(ppops), "));
 	ops = kmalloc (sizeof (struct parport_operations), GFP_KERNEL);
-        if (!ops) {
-		sbus_iounmap(base, size);
-		return 0;
-        }
+        if (!ops)
+		goto out2;
 
         memcpy (ops, &parport_sunbpp_ops, sizeof (struct parport_operations));
 
 	dprintk(("register_port\n"));
-	if (!(p = parport_register_port(base, irq, dma, ops))) {
-		kfree(ops);
-		sbus_iounmap(base, size);
-		return 0;
-	}
+	if (!(p = parport_register_port(base, irq, dma, ops)))
+		goto out3;
 
 	p->size = size;
 
@@ -327,14 +337,10 @@ static int __init init_one_port(struct s
 	if ((err = request_irq(p->irq, parport_sunbpp_interrupt,
 			       SA_SHIRQ, p->name, p)) != 0) {
 		dprintk(("ERROR %d\n", err));
-		parport_unregister_port(p);
-		kfree(ops);
-		sbus_iounmap(base, size);
-		return err;
-	} else {
-		dprintk(("OK\n"));
-		parport_sunbpp_enable_irq(p);
+		goto out4;
 	}
+	dprintk(("OK\n"));
+	parport_sunbpp_enable_irq(p);
 
 	regs = (struct bpp_regs *)p->base;
 	dprintk((KERN_DEBUG "forward\n"));
@@ -343,17 +349,25 @@ static int __init init_one_port(struct s
 	sbus_writeb(value_tcr, &regs->p_tcr);
 
 	printk(KERN_INFO "%s: sunbpp at 0x%lx\n", p->name, p->base);
-	parport_proc_register(p);
+	node->port = p;
+	list_add(&node->list, &port_list);
 	parport_announce_port (p);
 
 	return 1;
+
+out4:
+	parport_put_port(p);
+out3:
+	kfree(ops);
+out2:
+	sbus_iounmap(base, size);
+out1:
+	kfree(node);
+out0:
+	return err;
 }
 
-#ifdef MODULE
-int init_module(void)
-#else
-int __init parport_sunbpp_init(void)
-#endif
+static int __init parport_sunbpp_init(void)
 {
         struct sbus_bus *sbus;
         struct sbus_dev *sdev;
@@ -368,34 +382,30 @@ int __init parport_sunbpp_init(void)
 	return count ? 0 : -ENODEV;
 }
 
-#ifdef MODULE
-MODULE_AUTHOR("Derrick J Brashear");
-MODULE_DESCRIPTION("Parport Driver for Sparc bidirectional Port");
-MODULE_SUPPORTED_DEVICE("Sparc Bidirectional Parallel Port");
-
-void
-cleanup_module(void)
+static void __exit parport_sunbpp_exit(void)
 {
-	struct parport *p = parport_enumerate();
-
-	while (p) {
-		struct parport *next = p->next;
-
-		if (1/*p->modes & PARPORT_MODE_PCSPP*/) { 
-			struct parport_operations *ops = p->ops;
-
-			if (p->irq != PARPORT_IRQ_NONE) {
-				parport_sunbpp_disable_irq(p);
-				free_irq(p->irq, p);
-			}
-			sbus_iounmap(p->base, p->size);
-			parport_proc_unregister(p);
-			parport_unregister_port(p);
-			kfree (ops);
+	while (!list_empty(port_list)) {
+		Node *node = list_entry(port_list.next, Node, list);
+		struct parport *p = node->port;
+		struct parport_operations *ops = p->ops;
+		parport_remove_port(p);
+
+		if (p->irq != PARPORT_IRQ_NONE) {
+			parport_sunbpp_disable_irq(p);
+			free_irq(p->irq, p);
 		}
-		p = next;
+		sbus_iounmap(p->base, p->size);
+		parport_put_port(p);
+		kfree (ops);
+		list_del(&node->list);
+		kfree (node);
 	}
 }
-#endif
 
+MODULE_AUTHOR("Derrick J Brashear");
+MODULE_DESCRIPTION("Parport Driver for Sparc bidirectional Port");
+MODULE_SUPPORTED_DEVICE("Sparc Bidirectional Parallel Port");
 MODULE_LICENSE("GPL");
+
+module_init(parport_sunbpp_init)
+module_exit(parport_sunbpp_exit)
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/probe.c linux-2.6.4-rc2/drivers/parport/probe.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/probe.c	2002-12-08 14:01:27.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/probe.c	2004-03-03 12:45:15.000000000 +0000
@@ -5,6 +5,7 @@
  *             Philip Blundell <Philip.Blundell@pobox.com>
  */
 
+#include <linux/module.h>
 #include <linux/parport.h>
 #include <linux/ctype.h>
 #include <linux/string.h>
@@ -212,3 +213,4 @@ ssize_t parport_device_id (int devnum, c
 	parport_close (dev);
 	return retval;
 }
+EXPORT_SYMBOL(parport_device_id);
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/procfs.c linux-2.6.4-rc2/drivers/parport/procfs.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/procfs.c	2002-02-05 07:37:25.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/procfs.c	2004-03-03 12:45:17.000000000 +0000
@@ -14,6 +14,8 @@
 
 #include <linux/string.h>
 #include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
@@ -479,21 +481,20 @@ int parport_device_proc_unregister(struc
 	return 0;
 }
 
-int parport_default_proc_register(void)
+static int __init parport_default_proc_register(void)
 {
 	parport_default_sysctl_table.sysctl_header =
 		register_sysctl_table(parport_default_sysctl_table.dev_dir, 0);
 	return 0;
 }
 
-int parport_default_proc_unregister(void)
+static void __exit parport_default_proc_unregister(void)
 {
 	if (parport_default_sysctl_table.sysctl_header) {
 		unregister_sysctl_table(parport_default_sysctl_table.
 					sysctl_header);
 		parport_default_sysctl_table.sysctl_header = NULL;
 	}
-	return 0;
 }
 
 #else /* no sysctl or no procfs*/
@@ -518,13 +519,19 @@ int parport_device_proc_unregister(struc
 	return 0;
 }
 
-int parport_default_proc_register (void)
+static int __init parport_default_proc_register (void)
 {
 	return 0;
 }
 
-int parport_default_proc_unregister (void)
+static void __exit parport_default_proc_unregister (void)
 {
 	return 0;
 }
 #endif
+
+EXPORT_SYMBOL(parport_device_proc_register);
+EXPORT_SYMBOL(parport_device_proc_unregister);
+
+module_init(parport_default_proc_register)
+module_exit(parport_default_proc_unregister)
diff -purN linux-post-2.6.4rc1-20040303/drivers/parport/share.c linux-2.6.4-rc2/drivers/parport/share.c
--- linux-post-2.6.4rc1-20040303/drivers/parport/share.c	2004-02-05 08:47:37.000000000 +0000
+++ linux-2.6.4-rc2/drivers/parport/share.c	2004-03-03 12:45:18.000000000 +0000
@@ -41,14 +41,14 @@
 unsigned long parport_default_timeslice = PARPORT_DEFAULT_TIMESLICE;
 int parport_default_spintime =  DEFAULT_SPIN_TIME;
 
-static struct parport *portlist = NULL, *portlist_tail = NULL;
+static LIST_HEAD(portlist);
 static spinlock_t parportlist_lock = SPIN_LOCK_UNLOCKED;
 
 /* list of all allocated ports, sorted by ->number */
 static LIST_HEAD(all_ports);
 static spinlock_t full_list_lock = SPIN_LOCK_UNLOCKED;
 
-static struct parport_driver *driver_chain = NULL;
+static LIST_HEAD(drivers);
 
 static DECLARE_MUTEX(registration_lock);
 
@@ -105,16 +105,16 @@ static void attach_driver_chain(struct p
 {
 	/* caller has exclusive registration_lock */
 	struct parport_driver *drv;
-	for (drv = driver_chain; drv; drv = drv->next)
+	list_for_each_entry(drv, &drivers, list)
 		drv->attach(port);
 }
 
 /* Call detach(port) for each registered driver. */
 static void detach_driver_chain(struct parport *port)
 {
-	/* caller has exclusive registration_lock */
 	struct parport_driver *drv;
-	for (drv = driver_chain; drv; drv = drv->next)
+	/* caller has exclusive registration_lock */
+	list_for_each_entry(drv, &drivers, list)
 		drv->detach (port);
 }
 
@@ -155,22 +155,13 @@ int parport_register_driver (struct parp
 {
 	struct parport *port;
 
-	if (!portlist)
+	if (list_empty(&portlist))
 		get_lowlevel_driver ();
 
-	/* We have to take the portlist lock for this to be sure
-	 * that port is valid for the duration of the callback. */
-
-	/* This is complicated by the fact that attach must be allowed
-	 * to block, so we can't be holding any spinlocks when we call
-	 * it.  But we need to hold a spinlock to iterate over the
-	 * list of ports.. */
-
 	down(&registration_lock);
-	for (port = portlist; port; port = port->next)
+	list_for_each_entry(port, &portlist, list)
 		drv->attach(port);
-	drv->next = driver_chain;
-	driver_chain = drv;
+	list_add(&drv->list, &drivers);
 	up(&registration_lock);
 
 	return 0;
@@ -193,33 +184,14 @@ int parport_register_driver (struct parp
  *	finished by the time this function returns.
  **/
 
-void parport_unregister_driver (struct parport_driver *arg)
+void parport_unregister_driver (struct parport_driver *drv)
 {
-	struct parport_driver *drv, *olddrv = NULL;
+	struct parport *port;
 
 	down(&registration_lock);
-	drv = driver_chain;
-	while (drv) {
-		if (drv == arg) {
-			struct parport *port;
-
-			if (olddrv)
-				olddrv->next = drv->next;
-			else
-				driver_chain = drv->next;
-
-			/* Call the driver's detach routine for each
-			 * port to clean up any resources that the
-			 * attach routine acquired. */
-			for (port = portlist; port; port = port->next)
-				drv->detach (port);
-			up(&registration_lock);
-
-			return;
-		}
-		olddrv = drv;
-		drv = drv->next;
-	}
+	list_del_init(&drv->list);
+	list_for_each_entry(port, &portlist, list)
+		drv->detach(port);
 	up(&registration_lock);
 }
 
@@ -278,28 +250,6 @@ void parport_put_port (struct parport *p
 }
 
 /**
- *	parport_enumerate - return a list of the system's parallel ports
- *
- *	This returns the head of the list of parallel ports in the
- *	system, as a &struct parport.  The structure that is returned
- *	describes the first port in the list, and its 'next' member
- *	points to the next port, or %NULL if it's the last port.
- *
- *	If there are no parallel ports in the system,
- *	parport_enumerate() will return %NULL.
- **/
-
-struct parport *parport_enumerate(void)
-{
-	/* Don't use this: use parport_register_driver instead. */
-
-	if (!portlist)
-		get_lowlevel_driver ();
-
-	return portlist;
-}
-
-/**
  *	parport_register_port - register a parallel port
  *	@base: base I/O address
  *	@irq: IRQ line
@@ -322,7 +272,7 @@ struct parport *parport_enumerate(void)
  *	parport_announce_port().
  *
  *	The @ops structure is allocated by the caller, and must not be
- *	deallocated before calling parport_unregister_port().
+ *	deallocated before calling parport_remove_port().
  *
  *	If there is no memory to allocate a new parport structure,
  *	this function will return %NULL.
@@ -350,7 +300,7 @@ struct parport *parport_register_port(un
 	tmp->dma = dma;
 	tmp->muxport = tmp->daisy = tmp->muxsel = -1;
 	tmp->modes = 0;
- 	tmp->next = NULL;
+ 	INIT_LIST_HEAD(&tmp->list);
 	tmp->devices = tmp->cad = NULL;
 	tmp->flags = 0;
 	tmp->ops = ops;
@@ -413,49 +363,36 @@ struct parport *parport_register_port(un
 
 void parport_announce_port (struct parport *port)
 {
+	int i;
 
 #ifdef CONFIG_PARPORT_1284
 	/* Analyse the IEEE1284.3 topology of the port. */
-	if (parport_daisy_init (port) == 0) {
-		/* No devices were detected.  Perhaps they are in some
-                   funny state; let's try to reset them and see if
-                   they wake up. */
-		parport_daisy_fini (port);
-		parport_write_control (port, PARPORT_CONTROL_SELECT);
-		udelay (50);
-		parport_write_control (port,
-				       PARPORT_CONTROL_SELECT |
-				       PARPORT_CONTROL_INIT);
-		udelay (50);
-		parport_daisy_init (port);
-	}
+	parport_daisy_init(port);
 #endif
 
+	parport_proc_register(port);
 	down(&registration_lock);
-	/* We are locked against anyone else performing alterations, but
-	 * because of parport_enumerate people can still _read_ the list
-	 * while we are changing it; so be careful..
-	 *
-	 * It's okay to have portlist_tail a little bit out of sync
-	 * since it's only used for changing the list, not for reading
-	 * from it.
-	 */
-
 	spin_lock_irq(&parportlist_lock);
-	if (portlist_tail)
-		portlist_tail->next = port;
-	portlist_tail = port;
-	if (!portlist)
-		portlist = port;
+	list_add_tail(&port->list, &portlist);
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (slave)
+			list_add_tail(&slave->list, &portlist);
+	}
 	spin_unlock_irq(&parportlist_lock);
 
-	/* Let drivers know that a new port has arrived. */
+	/* Let drivers know that new port(s) has arrived. */
 	attach_driver_chain (port);
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (slave)
+			attach_driver_chain(slave);
+	}
 	up(&registration_lock);
 }
 
 /**
- *	parport_unregister_port - deregister a parallel port
+ *	parport_remove_port - deregister a parallel port
  *	@port: parallel port to deregister
  *
  *	When a parallel port driver is forcibly unloaded, or a
@@ -473,44 +410,46 @@ void parport_announce_port (struct parpo
  *	with @port as the parameter.
  **/
 
-void parport_unregister_port(struct parport *port)
+void parport_remove_port(struct parport *port)
 {
-	struct parport *p;
+	int i;
 
 	down(&registration_lock);
-	port->ops = &dead_ops;
 
 	/* Spread the word. */
 	detach_driver_chain (port);
 
 #ifdef CONFIG_PARPORT_1284
 	/* Forget the IEEE1284.3 topology of the port. */
-	parport_daisy_fini (port);
+	parport_daisy_fini(port);
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (!slave)
+			continue;
+		detach_driver_chain(slave);
+		parport_daisy_fini(slave);
+	}
 #endif
 
+	port->ops = &dead_ops;
 	spin_lock(&parportlist_lock);
-
-	/* We are protected from other people changing the list, but
-	 * they can still see it (using parport_enumerate).  So be
-	 * careful about the order of writes.. */
-	if (portlist == port) {
-		if ((portlist = port->next) == NULL)
-			portlist_tail = NULL;
-	} else {
-		for (p = portlist; (p != NULL) && (p->next != port); 
-		     p=p->next);
-		if (p) {
-			if ((p->next = port->next) == NULL)
-				portlist_tail = p;
-		}
-		else printk (KERN_WARNING
-			     "%s not found in port list!\n", port->name);
+	list_del_init(&port->list);
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (slave)
+			list_del_init(&slave->list);
 	}
 	spin_unlock(&parportlist_lock);
+
 	up(&registration_lock);
 
-	/* Yes, parport_enumerate _is_ unsafe.  Don't use it. */
-	parport_put_port (port);
+	parport_proc_unregister(port);
+
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (slave)
+			parport_put_port(slave);
+	}
 }
 
 /**
@@ -607,9 +546,8 @@ parport_register_device(struct parport *
 	/* We up our own module reference count, and that of the port
            on which a device is to be registered, to ensure that
            neither of us gets unloaded while we sleep in (e.g.)
-           kmalloc.  To be absolutely safe, we have to require that
-           our caller doesn't sleep in between parport_enumerate and
-           parport_register_device.. */
+           kmalloc.
+         */
 	if (!try_module_get(port->ops->owner)) {
 		return NULL;
 	}
@@ -751,11 +689,6 @@ void parport_unregister_device(struct pa
 
 	module_put(port->ops->owner);
 	parport_put_port (port);
-
-	/* Yes, that's right, someone _could_ still have a pointer to
-	 * port, if they used parport_enumerate.  That's why they
-	 * shouldn't use it (and use parport_register_driver instead)..
-	 */
 }
 
 /**
@@ -774,15 +707,16 @@ struct parport *parport_find_number (int
 {
 	struct parport *port, *result = NULL;
 
-	if (!portlist)
+	if (list_empty(&portlist))
 		get_lowlevel_driver ();
 
 	spin_lock (&parportlist_lock);
-	for (port = portlist; port; port = port->next)
+	list_for_each_entry(port, &portlist, list) {
 		if (port->number == number) {
 			result = parport_get_port (port);
 			break;
 		}
+	}
 	spin_unlock (&parportlist_lock);
 	return result;
 }
@@ -803,15 +737,16 @@ struct parport *parport_find_base (unsig
 {
 	struct parport *port, *result = NULL;
 
-	if (!portlist)
+	if (list_empty(&portlist))
 		get_lowlevel_driver ();
 
 	spin_lock (&parportlist_lock);
-	for (port = portlist; port; port = port->next)
+	list_for_each_entry(port, &portlist, list) {
 		if (port->base == base) {
 			result = parport_get_port (port);
 			break;
 		}
+	}
 	spin_unlock (&parportlist_lock);
 	return result;
 }
@@ -1060,41 +995,21 @@ void parport_release(struct pardevice *d
 	}
 }
 
-static int parport_parse_params (int nports, const char *str[], int val[],
-				 int automatic, int none, int nofifo)
-{
-	unsigned int i;
-	for (i = 0; i < nports && str[i]; i++) {
-		if (!strncmp(str[i], "auto", 4))
-			val[i] = automatic;
-		else if (!strncmp(str[i], "none", 4))
-			val[i] = none;
-		else if (nofifo && !strncmp(str[i], "nofifo", 4))
-			val[i] = nofifo;
-		else {
-			char *ep;
-			unsigned long r = simple_strtoul(str[i], &ep, 0);
-			if (ep != str[i])
-				val[i] = r;
-			else {
-				printk(KERN_ERR "parport: bad specifier `%s'\n", str[i]);
-				return -1;
-			}
-		}
-	}
-
-	return 0;
-}
+/* Exported symbols for modules. */
 
-int parport_parse_irqs(int nports, const char *irqstr[], int irqval[])
-{
-	return parport_parse_params (nports, irqstr, irqval, PARPORT_IRQ_AUTO,
-				     PARPORT_IRQ_NONE, 0);
-}
+EXPORT_SYMBOL(parport_claim);
+EXPORT_SYMBOL(parport_claim_or_block);
+EXPORT_SYMBOL(parport_release);
+EXPORT_SYMBOL(parport_register_port);
+EXPORT_SYMBOL(parport_announce_port);
+EXPORT_SYMBOL(parport_remove_port);
+EXPORT_SYMBOL(parport_register_driver);
+EXPORT_SYMBOL(parport_unregister_driver);
+EXPORT_SYMBOL(parport_register_device);
+EXPORT_SYMBOL(parport_unregister_device);
+EXPORT_SYMBOL(parport_get_port);
+EXPORT_SYMBOL(parport_put_port);
+EXPORT_SYMBOL(parport_find_number);
+EXPORT_SYMBOL(parport_find_base);
 
-int parport_parse_dmas(int nports, const char *dmastr[], int dmaval[])
-{
-	return parport_parse_params (nports, dmastr, dmaval, PARPORT_DMA_AUTO,
-				     PARPORT_DMA_NONE, PARPORT_DMA_NOFIFO);
-}
 MODULE_LICENSE("GPL");
diff -purN linux-post-2.6.4rc1-20040303/drivers/pci/quirks.c linux-2.6.4-rc2/drivers/pci/quirks.c
--- linux-post-2.6.4rc1-20040303/drivers/pci/quirks.c	2004-03-03 05:15:53.000000000 +0000
+++ linux-2.6.4-rc2/drivers/pci/quirks.c	2004-03-03 07:33:28.000000000 +0000
@@ -826,6 +826,7 @@ static void __init quirk_intel_ide_combi
 	case 0x24df:
 	case 0x25a3:
 	case 0x25b0:
+	case 0x2651:
 	case 0x2652:
 		break;
 	default:
diff -purN linux-post-2.6.4rc1-20040303/drivers/scsi/ata_piix.c linux-2.6.4-rc2/drivers/scsi/ata_piix.c
--- linux-post-2.6.4rc1-20040303/drivers/scsi/ata_piix.c	2004-03-03 05:15:53.000000000 +0000
+++ linux-2.6.4-rc2/drivers/scsi/ata_piix.c	2004-03-03 07:33:28.000000000 +0000
@@ -80,6 +80,8 @@ static struct pci_device_id piix_pci_tbl
 	 * and enhanced mode, with queueing and other fancy stuff.
 	 * This is distinguished by PCI class code.
 	 */
+	{ 0x8086, 0x2651, PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_CLASS_STORAGE_IDE << 8, 0xffff00, ich5_sata },
 	{ 0x8086, 0x2652, PCI_ANY_ID, PCI_ANY_ID,
 	  PCI_CLASS_STORAGE_IDE << 8, 0xffff00, ich5_sata },
 
diff -purN linux-post-2.6.4rc1-20040303/drivers/usb/misc/uss720.c linux-2.6.4-rc2/drivers/usb/misc/uss720.c
--- linux-post-2.6.4rc1-20040303/drivers/usb/misc/uss720.c	2004-01-24 07:02:24.000000000 +0000
+++ linux-2.6.4-rc2/drivers/usb/misc/uss720.c	2004-03-03 12:45:17.000000000 +0000
@@ -592,7 +592,6 @@ static int uss720_probe(struct usb_inter
 		goto probe_abort_port;
 	}
 #endif
-	parport_proc_register(pp);
 	parport_announce_port(pp);
 
 	usb_set_intfdata (intf, pp);
@@ -600,7 +599,7 @@ static int uss720_probe(struct usb_inter
 
 #if 0
 probe_abort_port:
-	parport_unregister_port(pp);
+	parport_put_port(pp);
 #endif
 probe_abort:
 	kfree(priv);
@@ -615,12 +614,12 @@ static void uss720_disconnect(struct usb
 	usb_set_intfdata (intf, NULL);
 	if (pp) {
 		priv = pp->private_data;
+		parport_remove_port(pp);
 #if 0
 		usb_release_irq(usbdev, priv->irqhandle, priv->irqpipe);
 #endif
 		priv->usbdev = NULL;
-		parport_proc_unregister(pp);
-		parport_unregister_port(pp);
+		parport_put_port(pp);
 		kfree(priv);
 	}
 }
diff -purN linux-post-2.6.4rc1-20040303/drivers/video/Kconfig linux-2.6.4-rc2/drivers/video/Kconfig
--- linux-post-2.6.4rc1-20040303/drivers/video/Kconfig	2004-02-26 11:26:01.000000000 +0000
+++ linux-2.6.4-rc2/drivers/video/Kconfig	2004-02-18 08:40:48.000000000 +0000
@@ -55,7 +55,7 @@ config FB_CIRRUS
 
 config FB_PM2
 	tristate "Permedia2 support"
-	depends on FB && (AMIGA || PCI) && BROKEN
+	depends on FB && (AMIGA || PCI)
 	help
 	  This is the frame buffer device driver for the Permedia2 AGP frame
 	  buffer card from ASK, aka `Graphic Blaster Exxtreme'.  There is a
@@ -66,21 +66,7 @@ config FB_PM2_FIFO_DISCONNECT
 	bool "enable FIFO disconnect feature"
 	depends on FB_PM2 && PCI
 	help
-	  Support the Permedia2 FIFOI disconnect feature (see CONFIG_FB_PM2).
-
-config FB_PM2_PCI
-	bool "generic Permedia2 PCI board support"
-	depends on FB_PM2 && PCI
-	help
-	  Say Y to enable support for Permedia2 AGP frame buffer card from
-	  3Dlabs (aka `Graphic Blaster Exxtreme') on the PCI bus.
-
-config FB_PM2_CVPPC
-	bool "Phase5 CVisionPPC/BVisionPPC support"
-	depends on FB_PM2 && AMIGA
-	help
-	  Say Y to enable support for the Amiga Phase 5 CVisionPPC BVisionPPC
-	  framebuffer cards.  Phase 5 is no longer with us, alas.
+	  Support the Permedia2 FIFO disconnect feature (see CONFIG_FB_PM2).
 
 config FB_ACORN
 	bool "Acorn VIDC support"
diff -purN linux-post-2.6.4rc1-20040303/drivers/video/Makefile linux-2.6.4-rc2/drivers/video/Makefile
--- linux-post-2.6.4rc1-20040303/drivers/video/Makefile	2004-02-13 15:19:31.000000000 +0000
+++ linux-2.6.4-rc2/drivers/video/Makefile	2004-02-18 08:41:08.000000000 +0000
@@ -15,7 +15,7 @@ endif
 
 obj-$(CONFIG_FB_ACORN)            += acornfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p.o
-obj-$(CONFIG_FB_PM2)              += pm2fb.o
+obj-$(CONFIG_FB_PM2)              += pm2fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_PM3)		  += pm3fb.o
 obj-$(CONFIG_FB_APOLLO)           += dnfb.o cfbfillrect.o cfbimgblt.o
 obj-$(CONFIG_FB_Q40)              += q40fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
diff -purN linux-post-2.6.4rc1-20040303/drivers/video/aty/radeon_base.c linux-2.6.4-rc2/drivers/video/aty/radeon_base.c
--- linux-post-2.6.4rc1-20040303/drivers/video/aty/radeon_base.c	2004-02-27 22:45:14.000000000 +0000
+++ linux-2.6.4-rc2/drivers/video/aty/radeon_base.c	2004-03-04 00:13:58.000000000 +0000
@@ -1320,6 +1320,16 @@ static void radeon_calc_pll_regs(struct 
 	 * not sure which model starts having FP2_GEN_CNTL, I assume anything more
 	 * recent than an r(v)100...
 	 */
+#if 0
+	/* XXX I had reports of flicker happening with the cinema display
+	 * on TMDS1 that seem to be fixed if I also forbit odd dividers in
+	 * this case. This could just be a bandwidth calculation issue, I
+	 * haven't implemented the bandwidth code yet, but in the meantime,
+	 * forcing uses_dvo to 1 fixes it and shouln't have bad side effects,
+	 * I haven't seen a case were were absolutely needed an odd PLL
+	 * divider. I'll find a better fix once I have more infos on the
+	 * real cause of the problem.
+	 */
 	while (rinfo->has_CRTC2) {
 		u32 fp2_gen_cntl = INREG(FP2_GEN_CNTL);
 		u32 disp_output_cntl;
@@ -1353,6 +1363,9 @@ static void radeon_calc_pll_regs(struct 
 		uses_dvo = 1;
 		break;
 	}
+#else
+	uses_dvo = 1;
+#endif
 	if (freq > rinfo->pll.ppll_max)
 		freq = rinfo->pll.ppll_max;
 	if (freq*12 < rinfo->pll.ppll_min)
diff -purN linux-post-2.6.4rc1-20040303/drivers/video/cvisionppc.h linux-2.6.4-rc2/drivers/video/cvisionppc.h
--- linux-post-2.6.4rc1-20040303/drivers/video/cvisionppc.h	2002-02-05 17:40:16.000000000 +0000
+++ linux-2.6.4-rc2/drivers/video/cvisionppc.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,51 +0,0 @@
-/*
- * Phase5 CybervisionPPC (TVP4020) definitions for the Permedia2 framebuffer
- * driver.
- *
- * Copyright (c) 1998-1999 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)
- * --------------------------------------------------------------------------
- * $Id: cvisionppc.h,v 1.8 1999/01/28 13:18:07 illo Exp $
- * --------------------------------------------------------------------------
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file COPYING in the main directory of this archive
- * for more details.
- */
-
-#ifndef CVISIONPPC_H
-#define CVISIONPPC_H
-
-#ifndef PM2FB_H
-#include "pm2fb.h"
-#endif
-
-struct cvppc_par {
-	unsigned char* pci_config;
-	unsigned char* pci_bridge;
-	u32 user_flags;
-};
-
-#define CSPPC_PCI_BRIDGE		0xfffe0000
-#define CSPPC_BRIDGE_ENDIAN		0x0000
-#define CSPPC_BRIDGE_INT		0x0010
-
-#define	CVPPC_PCI_CONFIG		0xfffc0000
-#define CVPPC_ROM_ADDRESS		0xe2000001
-#define CVPPC_REGS_REGION		0xef000000
-#define CVPPC_FB_APERTURE_ONE		0xe0000000
-#define CVPPC_FB_APERTURE_TWO		0xe1000000
-#define CVPPC_FB_SIZE			0x00800000
-#define CVPPC_MEM_CONFIG_OLD		0xed61fcaa	/* FIXME Fujitsu?? */
-#define CVPPC_MEM_CONFIG_NEW		0xed41c532	/* FIXME USA?? */
-#define CVPPC_MEMCLOCK			83000		/* in KHz */
-
-/* CVPPC_BRIDGE_ENDIAN */
-#define CSPPCF_BRIDGE_BIG_ENDIAN	0x02
-
-/* CVPPC_BRIDGE_INT */
-#define CSPPCF_BRIDGE_ACTIVE_INT2	0x01
-
-#endif	/* CVISIONPPC_H */
-
-/*****************************************************************************
- * That's all folks!
- *****************************************************************************/
diff -purN linux-post-2.6.4rc1-20040303/drivers/video/pm2fb.c linux-2.6.4-rc2/drivers/video/pm2fb.c
--- linux-post-2.6.4rc1-20040303/drivers/video/pm2fb.c	2003-06-09 23:12:42.000000000 +0000
+++ linux-2.6.4-rc2/drivers/video/pm2fb.c	2004-02-18 08:41:12.000000000 +0000
@@ -1,25 +1,30 @@
 /*
  * Permedia2 framebuffer driver.
+ *
+ * 2.5/2.6 driver:
+ * Copyright (c) 2003 Jim Hague (jim.hague@acm.org)
+ *
+ * based on 2.4 driver:
  * Copyright (c) 1998-2000 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)
  * Copyright (c) 1999 Jakub Jelinek (jakub@redhat.com)
- * Based on linux/drivers/video/skeletonfb.c by Geert Uytterhoeven.
- * --------------------------------------------------------------------------
- * $Id: pm2fb.c,v 1.213 2000/09/19 01:03:19 illo Exp $
- * --------------------------------------------------------------------------
- * History:
- *  1999/05/09 added Jim Hague's 'var' kernel option (thanks Jim!)
- *  2002/04/23 Jim Hague <jim.hague@acm.org>
- *	* Integrated Illo's last changes, No changelist available.
- *	  Major items: acceleration support, hardware cursor code
- *	  (not yet enabled).
- *	* Fixed -vsync, added lowhsync/lowvsync overrides for use with
- *	  XFree GLINT driver.
- * --------------------------------------------------------------------------
- * TODO multiple boards support
- * --------------------------------------------------------------------------
+ *
+ * and additional input from James Simmon's port of Hannu Mallat's tdfx
+ * driver.
+ *
+ * $Id$
+ *
+ * I have a Creative Graphics Blaster Exxtreme card - pm2fb on x86.
+ * I have no access to other pm2fb implementations, and cannot test
+ * on them. Therefore for now I am omitting Sparc and CVision code.
+ *
+ * Multiple boards support has been on the TODO list for ages.
+ * Don't expect this to change.
+ *
  * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file COPYING in the main directory of this archive
- * for more details.
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ * 
  */
 
 #include <linux/config.h>
@@ -30,43 +35,24 @@
 #include <linux/mm.h>
 #include <linux/tty.h>
 #include <linux/slab.h>
-#include <linux/vmalloc.h>
 #include <linux/delay.h>
-#include <linux/interrupt.h>
 #include <linux/fb.h>
-#include <linux/selection.h>
-#include <linux/console.h>
 #include <linux/init.h>
 #include <linux/pci.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <video/fbcon.h>
-#include <video/fbcon-cfb8.h>
-#include <video/fbcon-cfb16.h>
-#include <video/fbcon-cfb24.h>
-#include <video/fbcon-cfb32.h>
-#include <video/pm2fb.h>
-#include "cvisionppc.h"
-#ifdef __sparc__
-#include <asm/pbm.h>
-#include <asm/fbio.h>
-#endif
+
+#include <video/permedia2.h>
+#include <video/cvisionppc.h>
 
 #if !defined(__LITTLE_ENDIAN) && !defined(__BIG_ENDIAN)
 #error	"The endianness of the target host has not been defined."
 #endif
 
-#if defined(__BIG_ENDIAN) && !defined(__sparc__) && (!defined(CONFIG_PPC) || defined(CONFIG_FB_PM2_CVPPC))
+#if defined(__BIG_ENDIAN) && !defined(__sparc__)
 #define PM2FB_BE_APERTURE
 #endif
 
-/* Need to debug this some more */
-#undef PM2FB_HW_CURSOR
-
-#if defined(CONFIG_FB_PM2_PCI) && !defined(CONFIG_PCI)
-#undef CONFIG_FB_PM2_PCI
-#warning "support for Permedia2 PCI boards with no generic PCI support!"
+#if !defined(CONFIG_PCI)
+#error "Only generic PCI cards supported."
 #endif
 
 #undef PM2FB_MASTER_DEBUG
@@ -74,22 +60,9 @@
 #define DPRINTK(a,b...)	printk(KERN_DEBUG "pm2fb: %s: " a, __FUNCTION__ , ## b)
 #else
 #define DPRINTK(a,b...)
-#endif 
-
-#define PICOS2KHZ(a) (1000000000UL/(a))
-#define KHZ2PICOS(a) (1000000000UL/(a))
-
-/*
- * The _DEFINITIVE_ memory mapping/unmapping functions.
- * This is due to the fact that they're changing soooo often...
- */
-#define MMAP(a,b)	ioremap((unsigned long )(a), b)
-#define UNMAP(a,b)	iounmap(a)
+#endif
 
-/*
- * The _DEFINITIVE_ memory i/o barrier functions.
- * This is due to the fact that they're changing soooo often...
- */
+/* Memory barriers. */
 #ifdef __mc68000__
 #define DEFW()
 #define DEFR()
@@ -100,356 +73,105 @@
 #define DEFRW()		mb()
 #endif
 
-#ifndef MIN
-#define MIN(a,b) ((a)<(b)?(a):(b))
-#endif
-
-#ifndef MAX
-#define MAX(a,b) ((a)>(b)?(a):(b))
-#endif
-
-#define VIDEO_MASK	0x00011e7f	/* r/w values for VIDEO_CONTROL */
-
-#define PM2FF_ACCEL		(1L<<0)
-
-struct pm2fb_par {
-	u32 pixclock;		/* pixclock in KHz */
-	u32 width;		/* width of virtual screen */
-	u32 height;		/* height of virtual screen */
-	u32 hsstart;		/* horiz. sync start */
-	u32 hsend;		/* horiz. sync end */
-	u32 hbend;		/* horiz. blank end (also gate end) */
-	u32 htotal;		/* total width (w/ sync & blank) */
-	u32 vsstart;		/* vert. sync start */
-	u32 vsend;		/* vert. sync end */
-	u32 vbend;		/* vert. blank end */
-	u32 vtotal;		/* total height (w/ sync & blank) */
-	u32 stride;		/* screen stride */
-	u32 base;		/* screen base (xoffset+yoffset) */
-	u32 depth;		/* screen depth (8, 16, 24 or 32) */
-	u32 video;		/* video control (hsync,vsync) */
-	u32 flags;		/* internal flags (PM2FF_xxxx) */
-};
-
-#define OPTF_OLD_MEM		(1L<<0)
-#define OPTF_YPAN		(1L<<1)
-#define OPTF_VIRTUAL		(1L<<2)
-#define OPTF_USER		(1L<<3)
-#define OPTF_USER_VAR		(1L<<4)
-#define	OPTF_LOW_HSYNC		(1L<<5)
-#define	OPTF_LOW_VSYNC		(1L<<6)
-
-static struct {
-	char font[40];
-	u32 flags;
-	struct pm2fb_par user_mode;
-} pm2fb_options =
-#ifdef __sparc__
-	/* For some reason Raptor is not happy with the low-end mode */
-	{"\0", 0L, {31499,640,480,4,20,50,209,0,3,20,499,80,0,8,121}};
-#else
-	{"\0", 0L, {25174,640,480,4,28,40,199,9,11,45,524,80,0,8,121}};
-#endif
-
-static char curblink __initdata = 1;
-
-static struct fb_var_screeninfo user_var __initdata={0,};
-
-#define DEFAULT_USER_MODE	0
-
-static const struct {
-	char name[16];
-	struct pm2fb_par par;
-} user_mode[] __initdata = {
-	{"640x480-60",
-		{25174,640,480,4,28,40,199,9,11,45,524,80,0,8,121,PM2FF_ACCEL}},
-	{"640x480-72",
-		{31199,640,480,6,16,48,207,8,10,39,518,80,0,8,121,PM2FF_ACCEL}},
-	{"640x480-75",
-		{31499,640,480,4,20,50,209,0,3,20,499,80,0,8,121,PM2FF_ACCEL}},
-	{"640x480-90",
-		{39909,640,480,8,18,48,207,24,38,53,532,80,0,8,121,PM2FF_ACCEL}},
-	{"640x480-100",
-		{44899,640,480,8,40,52,211,21,33,51,530,80,0,8,121,PM2FF_ACCEL}},
-	{"800x600-56",
-		{35999,800,600,6,24,56,255,0,2,25,624,100,0,8,41,PM2FF_ACCEL}},
-	{"800x600-60",
-		{40000,800,600,10,42,64,263,0,4,28,627,100,0,8,41,PM2FF_ACCEL}},
-	{"800x600-70",
-		{44899,800,600,6,42,52,251,8,20,36,635,100,0,8,105,PM2FF_ACCEL}},
-	{"800x600-72",
-		{50000,800,600,14,44,60,259,36,42,66,665,100,0,8,41,PM2FF_ACCEL}},
-	{"800x600-75",
-		{49497,800,600,4,24,64,263,0,3,25,624,100,0,8,41,PM2FF_ACCEL}},
-	{"800x600-90",
-		{56637,800,600,2,18,48,247,7,18,35,634,100,0,8,41,PM2FF_ACCEL}},
-	{"800x600-100",
-		{67499,800,600,0,16,70,269,6,10,25,624,100,0,8,41,PM2FF_ACCEL}},
-	{"1024x768-60",
-		{64998,1024,768,6,40,80,335,2,8,38,805,128,0,8,121,PM2FF_ACCEL}},
-	{"1024x768-70",
-		{74996,1024,768,6,40,76,331,2,8,38,805,128,0,8,121,PM2FF_ACCEL}},
-	{"1024x768-72",
-		{74996,1024,768,6,40,66,321,2,8,38,805,128,0,8,121,PM2FF_ACCEL}},
-	{"1024x768-75",
-		{78932,1024,768,4,28,72,327,0,3,32,799,128,0,8,41,PM2FF_ACCEL}},
-	{"1024x768-90",
-		{100000,1024,768,0,24,72,327,20,35,77,844,128,0,8,121,PM2FF_ACCEL}},
-	{"1024x768-100",
-		{109998,1024,768,0,22,92,347,0,7,24,791,128,0,8,121,PM2FF_ACCEL}},
-	{"1024x768-illo",
-		{120336,1024,768,12,48,120,375,3,7,32,799,128,0,8,41,PM2FF_ACCEL}},
-	{"1152x864-60",
-		{80000,1152,864,16,44,76,363,5,10,52,915,144,0,8,41,PM2FF_ACCEL}},
-	{"1152x864-70",
-		{100000,1152,864,10,48,90,377,12,23,81,944,144,0,8,41,PM2FF_ACCEL}},
-	{"1152x864-75",
-		{109998,1152,864,6,42,78,365,44,52,138,1001,144,0,8,41,PM2FF_ACCEL}},
-	{"1152x864-80",
-		{109998,1152,864,4,32,72,359,29,36,94,957,144,0,8,41,PM2FF_ACCEL}},
-        {"1152x900-66-sun",
-                {92940,1152,900,16,80,176,751,1,5,37,936,288,0,16,121,PM2FF_ACCEL}},
-	{"1280x1024-60",
-		{107991,1280,1024,12,40,102,421,0,3,42,1065,160,0,8,41,PM2FF_ACCEL}},
-	{"1280x1024-70",
-		{125992,1280,1024,20,48,102,421,0,5,42,1065,160,0,8,41,PM2FF_ACCEL}},
-	{"1280x1024-74",
-		{134989,1280,1024,8,44,108,427,0,29,40,1063,160,0,8,41,PM2FF_ACCEL}},
-	{"1280x1024-75",
-		{134989,1280,1024,4,40,102,421,0,3,42,1065,160,0,8,41,PM2FF_ACCEL}},
-	{"1600x1200-60",
-		{155981,1600,1200,8,48,112,511,9,17,70,1269,200,0,8,121,PM2FF_ACCEL}},
-	{"1600x1200-66",
-		{171998,1600,1200,10,44,120,519,2,5,53,1252,200,0,8,121,PM2FF_ACCEL}},
-	{"1600x1200-76",
-		{197980,1600,1200,10,44,120,519,2,7,50,1249,200,0,8,121,PM2FF_ACCEL}},
-	{"\0", },
-};
-
-#ifdef CONFIG_FB_PM2_PCI
-struct pm2pci_par {
-	u32 mem_config;
-	u32 mem_control;
-	u32 boot_address;
-	struct pci_dev* dev;
-};
-#endif
-
-#define DEFAULT_CURSOR_BLINK_RATE       (20)
-#define CURSOR_DRAW_DELAY               (2)
-
-struct pm2_cursor {
-    int	enable;
-    int on;
-    int vbl_cnt;
-    int blink_rate;
-    struct {
-        u16 x, y;
-    } pos, hot, size;
-    u8 color[6];
-    u8 bits[8][64];
-    u8 mask[8][64];
-    struct timer_list *timer;
-};
-
-static const char permedia2_name[16]="Permedia2";
-
-static struct pm2fb_info {
-	struct fb_info_gen gen;
-	int board;			/* Permedia2 board index (see
-					   board_table[] below) */
-	pm2type_t type;			/* Permedia2 board type */
-	struct {
-		unsigned long  fb_base;	/* physical framebuffer memory base */
-		u32 fb_size;		/* framebuffer memory size */
-		unsigned long  rg_base;	/* physical register memory base */
-		unsigned long  p_fb;	/* physical address of frame buffer */
-		unsigned char* v_fb;	/* virtual address of frame buffer */
-		unsigned long  p_regs;	/* physical address of registers
-					   region, must be rg_base or
-					   rg_base+PM2_REGS_SIZE depending on
-					   the host endianness */
-		unsigned char* v_regs;	/* virtual address of p_regs */
-	} regions;
-	union {				/* here, the per-board par structs */
-#ifdef CONFIG_FB_PM2_CVPPC
-		struct cvppc_par cvppc;	/* CVisionPPC data */
-#endif
-#ifdef CONFIG_FB_PM2_PCI
-		struct pm2pci_par pci;	/* Permedia2 PCI boards data */
-#endif
-	} board_par;
-	struct pm2fb_par current_par;	/* displayed screen */
-	int current_par_valid;
-	int is_blank;
-	u32 memclock;			/* memclock (set by the per-board
-					   		init routine) */
-	struct display disp;
-	struct {
-		u8 transp;
-		u8 red;
-		u8 green;
-		u8 blue;
-	} palette[256];
-	union {
-#ifdef FBCON_HAS_CFB16
-		u16 cmap16[16];
-#endif
-#ifdef FBCON_HAS_CFB24
-		u32 cmap24[16];
-#endif
-#ifdef FBCON_HAS_CFB32
-		u32 cmap32[16];
-#endif
-	} cmap;
-	struct pm2_cursor *cursor;
-} fb_info;
-
-#ifdef CONFIG_FB_PM2_CVPPC
-static int cvppc_detect(struct pm2fb_info*);
-static void cvppc_init(struct pm2fb_info*);
-#endif
-
-#ifdef CONFIG_FB_PM2_PCI
-static int pm2pci_detect(struct pm2fb_info*);
-static void pm2pci_init(struct pm2fb_info*);
-#endif
+/*
+ * Driver data 
+ */
+static char *mode __initdata = NULL;
 
-#ifdef PM2FB_HW_CURSOR
-static void pm2fb_cursor(struct display *p, int mode, int x, int y);
-static int pm2fb_set_font(struct display *d, int width, int height);
-static struct pm2_cursor *pm2_init_cursor(struct pm2fb_info *fb);
-static void pm2v_set_cursor_color(struct pm2fb_info *fb, u8 *red, u8 *green, u8 *blue);
-static void pm2v_set_cursor_shape(struct pm2fb_info *fb);
-static u8 cursor_color_map[2] = { 0, 0xff };
-#else
-#define pm2fb_cursor NULL
-#define pm2fb_set_font NULL
-#endif
+/*
+ * The XFree GLINT driver will (I think to implement hardware cursor
+ * support on TVP4010 and similar where there is no RAMDAC - see
+ * comment in set_video) always request +ve sync regardless of what
+ * the mode requires. This screws me because I have a Sun
+ * fixed-frequency monitor which absolutely has to have -ve sync. So
+ * these flags allow the user to specify that requests for +ve sync
+ * should be silently turned in -ve sync.
+ */
+static int lowhsync __initdata = 0;
+static int lowvsync __initdata = 0;	
 
 /*
- * Table of the supported Permedia2 based boards.
- * Three hooks are defined for each board:
- * detect(): should return 1 if the related board has been detected, 0
- *           otherwise. It should also fill the fields 'regions.fb_base',
- *           'regions.fb_size', 'regions.rg_base' and 'memclock' in the
- *           passed pm2fb_info structure.
- * init(): called immediately after the reset of the Permedia2 chip.
- *         It should reset the memory controller if needed (the MClk
- *         is set shortly afterwards by the caller).
- * cleanup(): called after the driver has been unregistered.
- *
- * the init and cleanup pointers can be NULL.
+ * The hardware state of the graphics card that isn't part of the
+ * screeninfo.
  */
-static const struct {
-	int (*detect)(struct pm2fb_info*);
-	void (*init)(struct pm2fb_info*);
-	void (*cleanup)(struct pm2fb_info*);
-	char name[32];
-} board_table[] = {
-#ifdef CONFIG_FB_PM2_PCI
-	{ pm2pci_detect, pm2pci_init, NULL, "Permedia2 PCI board" },
-#endif
-#ifdef CONFIG_FB_PM2_CVPPC
-	{ cvppc_detect, cvppc_init, NULL, "CVisionPPC/BVisionPPC" },
-#endif
-	{ NULL, }
+struct pm2fb_par
+{
+	pm2type_t	type;		/* Board type */
+	u32		fb_size;	/* framebuffer memory size */
+	unsigned char*	v_fb;		/* virtual address of frame buffer */
+	unsigned char*	v_regs;		/* virtual address of p_regs */
+	u32 	   	memclock;	/* memclock */
+	u32		video;		/* video flags before blanking */
 };
 
 /*
- * partial products for the supported horizontal resolutions.
+ * Here we define the default structs fb_fix_screeninfo and fb_var_screeninfo
+ * if we don't use modedb.
  */
-#define PACKPP(p0,p1,p2)	(((p2)<<6)|((p1)<<3)|(p0))
-static const struct {
-	u16 width;
-	u16 pp;
-} pp_table[] = {
-	{ 32,	PACKPP(1, 0, 0) }, { 64,	PACKPP(1, 1, 0) },
-	{ 96,	PACKPP(1, 1, 1) }, { 128,	PACKPP(2, 1, 1) },
-	{ 160,	PACKPP(2, 2, 1) }, { 192,	PACKPP(2, 2, 2) },
-	{ 224,	PACKPP(3, 2, 1) }, { 256,	PACKPP(3, 2, 2) },
-	{ 288,	PACKPP(3, 3, 1) }, { 320,	PACKPP(3, 3, 2) },
-	{ 384,	PACKPP(3, 3, 3) }, { 416,	PACKPP(4, 3, 1) },
-	{ 448,	PACKPP(4, 3, 2) }, { 512,	PACKPP(4, 3, 3) },
-	{ 544,	PACKPP(4, 4, 1) }, { 576,	PACKPP(4, 4, 2) },
-	{ 640,	PACKPP(4, 4, 3) }, { 768,	PACKPP(4, 4, 4) },
-	{ 800,	PACKPP(5, 4, 1) }, { 832,	PACKPP(5, 4, 2) },
-	{ 896,	PACKPP(5, 4, 3) }, { 1024,	PACKPP(5, 4, 4) },
-	{ 1056,	PACKPP(5, 5, 1) }, { 1088,	PACKPP(5, 5, 2) },
-	{ 1152,	PACKPP(5, 5, 3) }, { 1280,	PACKPP(5, 5, 4) },
-	{ 1536,	PACKPP(5, 5, 5) }, { 1568,	PACKPP(6, 5, 1) },
-	{ 1600,	PACKPP(6, 5, 2) }, { 1664,	PACKPP(6, 5, 3) },
-	{ 1792,	PACKPP(6, 5, 4) }, { 2048,	PACKPP(6, 5, 5) },
-	{ 0,	0 } };
-
-static void pm2fb_detect(void);
-static int pm2fb_encode_fix(struct fb_fix_screeninfo* fix,
-				const void* par, struct fb_info_gen* info);
-static int pm2fb_decode_var(const struct fb_var_screeninfo* var,
-					void* par, struct fb_info_gen* info);
-static int pm2fb_encode_var(struct fb_var_screeninfo* var,
-				const void* par, struct fb_info_gen* info);
-static void pm2fb_get_par(void* par, struct fb_info_gen* info);
-static void pm2fb_set_par(const void* par, struct fb_info_gen* info);
-static int pm2fb_getcolreg(unsigned regno,
-			unsigned* red, unsigned* green, unsigned* blue,
-				unsigned* transp, struct fb_info* info);
-static int pm2fb_blank(int blank_mode, struct fb_info_gen* info);
-static int pm2fb_pan_display(const struct fb_var_screeninfo* var,
-					struct fb_info_gen* info);
-static void pm2fb_set_disp(const void* par, struct display* disp,
-						struct fb_info_gen* info);
-
-static struct fbgen_hwswitch pm2fb_hwswitch={
-	pm2fb_detect, pm2fb_encode_fix, pm2fb_decode_var,
-	pm2fb_encode_var, pm2fb_get_par, pm2fb_set_par,
-	pm2fb_getcolreg, pm2fb_pan_display,
-	pm2fb_blank, pm2fb_set_disp
+static struct fb_fix_screeninfo pm2fb_fix __initdata = {
+	.id =		"", 
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_PSEUDOCOLOR,
+	.xpanstep =	1,
+	.ypanstep =	1,
+	.ywrapstep =	0, 
+	.accel =	FB_ACCEL_NONE,
 };
 
-
-static int pm2fb_setcolreg(unsigned regno,
-			unsigned red, unsigned green, unsigned blue,
-				unsigned transp, struct fb_info* info);
-
-static struct fb_ops pm2fb_ops={
-	.owner =	THIS_MODULE,
-	.fb_get_fix =	fbgen_get_fix,
-	.fb_get_var =	fbgen_get_var,
-	.fb_set_var =	fbgen_set_var,
-	.fb_get_cmap =	fbgen_get_cmap,
-	.fb_set_cmap =	fbgen_set_cmap,
-	.fb_pan_display =fbgen_pan_display,
-	.fb_setcolreg =	pm2fb_setcolreg,
-	.fb_blank =	fbgen_blank,
+/*
+ * Default video mode. In case the modedb doesn't work, or we're
+ * a module (in which case modedb doesn't really work).
+ */
+static struct fb_var_screeninfo pm2fb_var __initdata = {
+	/* "640x480, 8 bpp @ 60 Hz */
+	.xres =		640,
+	.yres =		480,
+	.xres_virtual =	640,
+	.yres_virtual =	480,
+	.bits_per_pixel =8,
+	.red =		{0, 8, 0},
+	.blue =		{0, 8, 0},
+	.green =	{0, 8, 0},
+	.activate =	FB_ACTIVATE_NOW,
+	.height =	-1,
+	.width =	-1,
+	.accel_flags =	0,
+	.pixclock =	39721,
+	.left_margin =	40,
+	.right_margin =	24,
+	.upper_margin =	32,
+	.lower_margin =	11,
+	.hsync_len =	96,
+	.vsync_len =	2,
+	.vmode =	FB_VMODE_NONINTERLACED
 };
 
-/***************************************************************************
- * Begin of Permedia2 specific functions
- ***************************************************************************/
-
-inline static u32 RD32(unsigned char* base, s32 off) {
+/*
+ * Utility functions
+ */
 
-	return fb_readl(base+off);
+inline static u32 RD32(unsigned char* base, s32 off)
+{
+	return fb_readl(base + off);
 }
 
-inline static void WR32(unsigned char* base, s32 off, u32 v) {
-
-	fb_writel(v, base+off);
+inline static void WR32(unsigned char* base, s32 off, u32 v)
+{
+	fb_writel(v, base + off);
 }
 
-inline static u32 pm2_RD(struct pm2fb_info* p, s32 off) {
-
-	return RD32(p->regions.v_regs, off);
+inline static u32 pm2_RD(struct pm2fb_par* p, s32 off)
+{
+	return RD32(p->v_regs, off);
 }
 
-inline static void pm2_WR(struct pm2fb_info* p, s32 off, u32 v) {
-
-	WR32(p->regions.v_regs, off, v);
+inline static void pm2_WR(struct pm2fb_par* p, s32 off, u32 v)
+{
+	WR32(p->v_regs, off, v);
 }
 
-inline static u32 pm2_RDAC_RD(struct pm2fb_info* p, s32 idx) {
-
+inline static u32 pm2_RDAC_RD(struct pm2fb_par* p, s32 idx)
+{
 	int index = PM2R_RD_INDEXED_DATA;
 	switch (p->type) {
 	case PM2_TYPE_PERMEDIA2:
@@ -464,9 +186,8 @@ inline static u32 pm2_RDAC_RD(struct pm2
 	return pm2_RD(p, index);
 }
 
-inline static void pm2_RDAC_WR(struct pm2fb_info* p, s32 idx,
-						u32 v) {
-
+inline static void pm2_RDAC_WR(struct pm2fb_par* p, s32 idx, u32 v)
+{
 	int index = PM2R_RD_INDEXED_DATA;
 	switch (p->type) {
 	case PM2_TYPE_PERMEDIA2:
@@ -481,16 +202,15 @@ inline static void pm2_RDAC_WR(struct pm
 	pm2_WR(p, index, v);
 }
 
-inline static u32 pm2v_RDAC_RD(struct pm2fb_info* p, s32 idx) {
-
+inline static u32 pm2v_RDAC_RD(struct pm2fb_par* p, s32 idx)
+{
 	pm2_WR(p, PM2VR_RD_INDEX_LOW, idx & 0xff);
 	DEFRW();
 	return pm2_RD(p, PM2VR_RD_INDEXED_DATA);
 }
 
-inline static void pm2v_RDAC_WR(struct pm2fb_info* p, s32 idx,
-						u32 v) {
-
+inline static void pm2v_RDAC_WR(struct pm2fb_par* p, s32 idx, u32 v)
+{
 	pm2_WR(p, PM2VR_RD_INDEX_LOW, idx & 0xff);
 	DEFRW();
 	pm2_WR(p, PM2VR_RD_INDEXED_DATA, v);
@@ -499,79 +219,88 @@ inline static void pm2v_RDAC_WR(struct p
 #ifdef CONFIG_FB_PM2_FIFO_DISCONNECT
 #define WAIT_FIFO(p,a)
 #else
-inline static void WAIT_FIFO(struct pm2fb_info* p, u32 a) {
-
-	while(pm2_RD(p, PM2R_IN_FIFO_SPACE)<a);
+inline static void WAIT_FIFO(struct pm2fb_par* p, u32 a)
+{
+	while( pm2_RD(p, PM2R_IN_FIFO_SPACE) < a );
 	DEFRW();
 }
 #endif
 
-static u32 partprod(u32 xres) {
+/*
+ * partial products for the supported horizontal resolutions.
+ */
+#define PACKPP(p0,p1,p2)	(((p2) << 6) | ((p1) << 3) | (p0))
+static const struct {
+	u16 width;
+	u16 pp;
+} pp_table[] = {
+	{ 32,	PACKPP(1, 0, 0) }, { 64,	PACKPP(1, 1, 0) },
+	{ 96,	PACKPP(1, 1, 1) }, { 128,	PACKPP(2, 1, 1) },
+	{ 160,	PACKPP(2, 2, 1) }, { 192,	PACKPP(2, 2, 2) },
+	{ 224,	PACKPP(3, 2, 1) }, { 256,	PACKPP(3, 2, 2) },
+	{ 288,	PACKPP(3, 3, 1) }, { 320,	PACKPP(3, 3, 2) },
+	{ 384,	PACKPP(3, 3, 3) }, { 416,	PACKPP(4, 3, 1) },
+	{ 448,	PACKPP(4, 3, 2) }, { 512,	PACKPP(4, 3, 3) },
+	{ 544,	PACKPP(4, 4, 1) }, { 576,	PACKPP(4, 4, 2) },
+	{ 640,	PACKPP(4, 4, 3) }, { 768,	PACKPP(4, 4, 4) },
+	{ 800,	PACKPP(5, 4, 1) }, { 832,	PACKPP(5, 4, 2) },
+	{ 896,	PACKPP(5, 4, 3) }, { 1024,	PACKPP(5, 4, 4) },
+	{ 1056,	PACKPP(5, 5, 1) }, { 1088,	PACKPP(5, 5, 2) },
+	{ 1152,	PACKPP(5, 5, 3) }, { 1280,	PACKPP(5, 5, 4) },
+	{ 1536,	PACKPP(5, 5, 5) }, { 1568,	PACKPP(6, 5, 1) },
+	{ 1600,	PACKPP(6, 5, 2) }, { 1664,	PACKPP(6, 5, 3) },
+	{ 1792,	PACKPP(6, 5, 4) }, { 2048,	PACKPP(6, 5, 5) },
+	{ 0,	0 } };
+
+static u32 partprod(u32 xres)
+{
 	int i;
 
-	for (i=0; pp_table[i].width && pp_table[i].width!=xres; i++);
-	if (!pp_table[i].width)
+	for (i = 0; pp_table[i].width && pp_table[i].width != xres; i++)
+		;
+	if ( pp_table[i].width == 0 )
 		DPRINTK("invalid width %u\n", xres);
 	return pp_table[i].pp;
 }
 
-static u32 to3264(u32 timing, int bpp, int is64) {
-
-	switch (bpp) {
-		case 8:
-			timing=timing>>(2+is64);
-			break;
-		case 16:
-			timing=timing>>(1+is64);
-			break;
-		case 24:
-			timing=(timing*3)>>(2+is64);
-			break;
-		case 32:
-			if (is64)
-				timing=timing>>1;
-			break;
-	}
-	return timing;
-}
-
-static u32 from3264(u32 timing, int bpp, int is64) {
-
+static u32 to3264(u32 timing, int bpp, int is64)
+{
 	switch (bpp) {
-		case 8:
-			timing=timing<<(2+is64);
-			break;
-		case 16:
-			timing=timing<<(1+is64);
-			break;
-		case 24:
-			timing=(timing<<(2+is64))/3;
-			break;
-		case 32:
-			if (is64)
-				timing=timing<<1;
-			break;
+	case 8:
+		timing >>= 2 + is64;
+		break;
+	case 16:
+		timing >>= 1 + is64;
+		break;
+	case 24:
+		timing = (timing * 3) >> (2 + is64);
+		break;
+	case 32:
+		if (is64)
+			timing >>= 1;
+		break;
 	}
 	return timing;
 }
 
 static void pm2_mnp(u32 clk, unsigned char* mm, unsigned char* nn,
-		    unsigned char* pp) {
+		    unsigned char* pp)
+{
 	unsigned char m;
 	unsigned char n;
 	unsigned char p;
 	u32 f;
 	s32 curr;
-	s32 delta=100000;
+	s32 delta = 100000;
 
-	*mm=*nn=*pp=0;
-	for (n=2; n<15; n++) {
-		for (m=2; m; m++) {
-			f=PM2_REFERENCE_CLOCK*m/n;
-			if (f>=150000 && f<=300000) {
-				for (p=0; p<5; p++, f>>=1) {
-					curr=clk>f?clk-f:f-clk;
-					if (curr<delta) {
+	*mm = *nn = *pp = 0;
+	for (n = 2; n < 15; n++) {
+		for (m = 2; m; m++) {
+			f = PM2_REFERENCE_CLOCK * m / n;
+			if (f >= 150000 && f <= 300000) {
+				for ( p = 0; p < 5; p++, f >>= 1) {
+					curr = ( clk > f ) ? clk - f : f - clk;
+					if ( curr < delta ) {
 						delta=curr;
 						*mm=m;
 						*nn=n;
@@ -584,20 +313,21 @@ static void pm2_mnp(u32 clk, unsigned ch
 }
 
 static void pm2v_mnp(u32 clk, unsigned char* mm, unsigned char* nn,
-		unsigned char* pp) {
+		     unsigned char* pp)
+{
 	unsigned char m;
 	unsigned char n;
 	unsigned char p;
 	u32 f;
-	s32 delta=1000;
+	s32 delta = 1000;
 
-	*mm=*nn=*pp=0;
-	for (n=1; n; n++) {
-		for (m=1; m; m++) {
-			for (p=0; p<2; p++) {
-				f=PM2_REFERENCE_CLOCK*n/(m * (1<<(p+1)));
-				if (clk>f-delta && clk<f+delta) {
-					delta=clk>f?clk-f:f-clk;
+	*mm = *nn = *pp = 0;
+	for (n = 1; n; n++) {
+		for ( m = 1; m; m++) {
+			for ( p = 0; p < 2; p++) {
+				f = PM2_REFERENCE_CLOCK * n / (m * (1 << (p + 1)));
+				if ( clk > f - delta && clk < f + delta ) {
+					delta = ( clk > f ) ? clk - f : f - clk;
 					*mm=m;
 					*nn=n;
 					*pp=p;
@@ -607,72 +337,7 @@ static void pm2v_mnp(u32 clk, unsigned c
 	}
 }
 
-static void wait_pm2(struct pm2fb_info* i) {
-
-	WAIT_FIFO(i, 1);
-	pm2_WR(i, PM2R_SYNC, 0);
-	DEFRW();
-	do {
-		while (pm2_RD(i, PM2R_OUT_FIFO_WORDS)==0);
-		DEFR();
-	} while (pm2_RD(i, PM2R_OUT_FIFO)!=PM2TAG(PM2R_SYNC));
-}
-
-static void pm2_set_memclock(struct pm2fb_info* info, u32 clk) {
-	int i;
-	unsigned char m, n, p;
-
-	pm2_mnp(clk, &m, &n, &p);
-	WAIT_FIFO(info, 10);
-	pm2_RDAC_WR(info, PM2I_RD_MEMORY_CLOCK_3, 6);
-	DEFW();
-	pm2_RDAC_WR(info, PM2I_RD_MEMORY_CLOCK_1, m);
-	pm2_RDAC_WR(info, PM2I_RD_MEMORY_CLOCK_2, n);
-	DEFW();
-	pm2_RDAC_WR(info, PM2I_RD_MEMORY_CLOCK_3, 8|p);
-	DEFW();
-	pm2_RDAC_RD(info, PM2I_RD_MEMORY_CLOCK_STATUS);
-	DEFR();
-	for (i=256; i &&
-		!(pm2_RD(info, PM2R_RD_INDEXED_DATA)&PM2F_PLL_LOCKED); i--);
-}
-
-static void pm2_set_pixclock(struct pm2fb_info* info, u32 clk) {
-	int i;
-	unsigned char m, n, p;
-
-	switch (info->type) {
-	case PM2_TYPE_PERMEDIA2:
-		pm2_mnp(clk, &m, &n, &p);
-		WAIT_FIFO(info, 8);
-		pm2_RDAC_WR(info, PM2I_RD_PIXEL_CLOCK_A3, 0);
-		DEFW();
-		pm2_RDAC_WR(info, PM2I_RD_PIXEL_CLOCK_A1, m);
-		pm2_RDAC_WR(info, PM2I_RD_PIXEL_CLOCK_A2, n);
-		DEFW();
-		pm2_RDAC_WR(info, PM2I_RD_PIXEL_CLOCK_A3, 8|p);
-		DEFW();
-		pm2_RDAC_RD(info, PM2I_RD_PIXEL_CLOCK_STATUS);
-		DEFR();
-		for (i=256;
-		     i && !(pm2_RD(info, PM2R_RD_INDEXED_DATA)&PM2F_PLL_LOCKED);
-		     i--)
-		    ;
-		break;
-	case PM2_TYPE_PERMEDIA2V:
-		pm2v_mnp(clk/2, &m, &n, &p);
-		WAIT_FIFO(info, 8);
-		pm2_WR(info, PM2VR_RD_INDEX_HIGH,
-		       PM2VI_RD_CLK0_PRESCALE >> 8);
-		pm2v_RDAC_WR(info, PM2VI_RD_CLK0_PRESCALE, m);
-		pm2v_RDAC_WR(info, PM2VI_RD_CLK0_FEEDBACK, n);
-		pm2v_RDAC_WR(info, PM2VI_RD_CLK0_POSTSCALE, p);
-		pm2_WR(info, PM2VR_RD_INDEX_HIGH, 0);
-		break;
-	}
-}
-
-static void clear_palette(struct pm2fb_info* p) {
+static void clear_palette(struct pm2fb_par* p) {
 	int i=256;
 
 	WAIT_FIFO(p, 1);
@@ -686,300 +351,38 @@ static void clear_palette(struct pm2fb_i
 	}
 }
 
-static void set_color(struct pm2fb_info* p, unsigned char regno,
-			unsigned char r, unsigned char g, unsigned char b) {
-
-	WAIT_FIFO(p, 4);
-	pm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, regno);
-	DEFW();
-	pm2_WR(p, PM2R_RD_PALETTE_DATA, r);
-	DEFW();
-	pm2_WR(p, PM2R_RD_PALETTE_DATA, g);
-	DEFW();
-	pm2_WR(p, PM2R_RD_PALETTE_DATA, b);
-}
-
-static void set_aperture(struct pm2fb_info* i, struct pm2fb_par* p) {
-
-	WAIT_FIFO(i, 4);
-#ifdef __LITTLE_ENDIAN
-	pm2_WR(i, PM2R_APERTURE_ONE, 0);
-	pm2_WR(i, PM2R_APERTURE_TWO, 0);
-#else
-	switch (p->depth) {
-		case 8:
-		case 24:
-			pm2_WR(i, PM2R_APERTURE_ONE, 0);
-			pm2_WR(i, PM2R_APERTURE_TWO, 1);
-			break;
-		case 16:
-			pm2_WR(i, PM2R_APERTURE_ONE, 2);
-			pm2_WR(i, PM2R_APERTURE_TWO, 1);
-			break;
-		case 32:
-			pm2_WR(i, PM2R_APERTURE_ONE, 1);
-			pm2_WR(i, PM2R_APERTURE_TWO, 1);
-			break;
-	}
+#if 0
+/*
+ * FIXME:
+ * The 2.4 driver calls this at init time, where it also sets the
+ * initial mode. I don't think the driver should touch the chip
+ * until the console sets a video mode. So I was calling this
+ * at the start of setting a mode. However, certainly on 1280x1024
+ * depth 16 this causes the display to smear slightly.
+ * I don't know why. Guesses to jim.hague@acm.org.
+ */
+static void reset_card(struct pm2fb_par* p)
+{
+	if (p->type == PM2_TYPE_PERMEDIA2V)
+		pm2_WR(p, PM2VR_RD_INDEX_HIGH, 0);
+	pm2_WR(p, PM2R_RESET_STATUS, 0);
+	DEFRW();
+	while (pm2_RD(p, PM2R_RESET_STATUS) & PM2F_BEING_RESET)
+		;
+	DEFRW();
+#ifdef CONFIG_FB_PM2_FIFO_DISCONNECT
+	DPRINTK("FIFO disconnect enabled\n");
+	pm2_WR(p, PM2R_FIFO_DISCON, 1);
+	DEFRW();
 #endif
 }
+#endif
 
-static void set_video(struct pm2fb_info* i, u32 video) {
-	u32 tmp;
-	u32 vsync;
-
-	vsync=video;
-	
-	/*
-	 * The hardware cursor needs +vsync to recognise vert retrace.
-	 * We may not be using the hardware cursor, but the X Glint
-	 * driver may well. So always set +hsync/+vsync and then set
-	 * the RAMDAC to invert the sync if necessary.
-	 */
-	vsync&=~(PM2F_HSYNC_MASK|PM2F_VSYNC_MASK);
-	vsync|=PM2F_HSYNC_ACT_HIGH|PM2F_VSYNC_ACT_HIGH;
-
-	WAIT_FIFO(i, 5);
-	pm2_WR(i, PM2R_VIDEO_CONTROL, vsync);
-
-	switch (i->type) {
-		case PM2_TYPE_PERMEDIA2:
-			tmp = PM2F_RD_PALETTE_WIDTH_8;
-			if ((video & PM2F_HSYNC_MASK) == PM2F_HSYNC_ACT_LOW)
-				tmp |= 4; /* invert hsync */
-			if ((video & PM2F_VSYNC_MASK) == PM2F_VSYNC_ACT_LOW)
-				tmp |= 8; /* invert vsync */
-			pm2_RDAC_WR(i, PM2I_RD_MISC_CONTROL, tmp);
-			break;
-		case PM2_TYPE_PERMEDIA2V:
-			tmp = 0;
-			if ((video & PM2F_HSYNC_MASK) == PM2F_HSYNC_ACT_LOW)
-				tmp |= 1; /* invert hsync */
-			if ((video & PM2F_VSYNC_MASK) == PM2F_VSYNC_ACT_LOW)
-				tmp |= 4; /* invert vsync */
-			pm2v_RDAC_WR(i, PM2VI_RD_SYNC_CONTROL, tmp);
-			pm2v_RDAC_WR(i, PM2VI_RD_MISC_CONTROL, 1);
-			break;
-	}
-}
-
-static void get_screen(struct pm2fb_info* i, struct pm2fb_par* p) {
-	u32 clrmode;
-	u32 readpx;
-	u32 misc;
-
-	memset(p, 0, sizeof(struct pm2fb_par));
-	p->base=pm2_RD(i, PM2R_SCREEN_BASE);
-	p->video=pm2_RD(i, PM2R_VIDEO_CONTROL) & VIDEO_MASK;
-	switch (i->type) {
-		case PM2_TYPE_PERMEDIA2:
-			misc=pm2_RDAC_RD(i, PM2I_RD_MISC_CONTROL);
-			if ( misc & 4 )
-				/* Hsync is actually low */
-				p->video |= PM2F_HSYNC_ACT_LOW;
-			if ( misc & 8 )
-				/* Vsync is actually low */
-				p->video |= PM2F_VSYNC_ACT_LOW;
-			break;
-		case PM2_TYPE_PERMEDIA2V:
-			misc=pm2_RDAC_RD(i, PM2VI_RD_SYNC_CONTROL);
-			if ( misc & 1 )
-				/* Hsync is actually low */
-				p->video |= PM2F_HSYNC_ACT_LOW;
-			if ( misc & 4 )
-				/* Vsync is actually low */
-				p->video |= PM2F_VSYNC_ACT_LOW;
-			break;
-	}
-	p->width=pm2_RD(i, PM2R_SCREEN_SIZE) & 0xffff;
-	p->height=pm2_RD(i, PM2R_SCREEN_SIZE) >> 16;
-	p->htotal=pm2_RD(i, PM2R_H_TOTAL);
-	p->hsstart=pm2_RD(i, PM2R_HS_START);
-	p->hsend=pm2_RD(i, PM2R_HS_END);
-	p->hbend=pm2_RD(i, PM2R_HB_END);
-	p->vtotal=pm2_RD(i, PM2R_V_TOTAL);
-	p->vsstart=pm2_RD(i, PM2R_VS_START);
-	p->vsend=pm2_RD(i, PM2R_VS_END);
-	p->vbend=pm2_RD(i, PM2R_VB_END);
-	p->stride=pm2_RD(i, PM2R_SCREEN_STRIDE);
-	clrmode=pm2_RDAC_RD(i, PM2I_RD_COLOR_MODE);
-	readpx=pm2_RD(i, PM2R_FB_READ_PIXEL);
-	if (clrmode & PM2F_RD_GUI_ACTIVE) {
-		clrmode &= ~(PM2F_RD_COLOR_MODE_RGB|PM2F_RD_GUI_ACTIVE);
-		if (clrmode==0 && readpx==0)
-			p->depth=8;
-		else if (clrmode==(PM2F_RD_TRUECOLOR|0x06) && readpx==1)
-			p->depth=16;
-		else if (clrmode==(PM2F_RD_TRUECOLOR|0x08) && readpx==2)
-			p->depth=32;
-		else if (clrmode==(PM2F_RD_TRUECOLOR|0x09) && readpx==4)
-			p->depth=24;
-	}
-	/*
-	 * Somehow I have to manage this unretrievable fields.
-	 * To say the truth, 'flags' field ought to be somewhere else.
-	 */
-	if (i->current_par_valid) {
-		p->pixclock=i->current_par.pixclock;
-		p->flags=i->current_par.flags;
-	}
-}
-	
-static void set_screen(struct pm2fb_info* i, struct pm2fb_par* p) {
-	u32 clrmode=PM2F_RD_COLOR_MODE_RGB;
-	u32 txtmap=0;
-	u32 pixsize=0;
-	u32 clrformat=0;
-	u32 xres;
-
-	if (i->type == PM2_TYPE_PERMEDIA2V) {
-		WAIT_FIFO(i, 1);
-		pm2_WR(i, PM2VR_RD_INDEX_HIGH, 0);
-	}
-	xres=(p->width+31)&~31;
-	set_aperture(i, p);
-	DEFRW();
-	WAIT_FIFO(i, 19);
-	pm2_RDAC_WR(i, PM2I_RD_COLOR_KEY_CONTROL, p->depth==8?0:
-						PM2F_COLOR_KEY_TEST_OFF);
-	switch (p->depth) {
-		case 8:
-			pm2_WR(i, PM2R_FB_READ_PIXEL, 0);
-			clrformat=0x0e;
-			break;
-		case 16:
-			pm2_WR(i, PM2R_FB_READ_PIXEL, 1);
-			clrmode|=PM2F_RD_TRUECOLOR|0x06;
-			txtmap=PM2F_TEXTEL_SIZE_16;
-			pixsize=1;
-			clrformat=0x70;
-			break;
-		case 32:
-			pm2_WR(i, PM2R_FB_READ_PIXEL, 2);
-			clrmode|=PM2F_RD_TRUECOLOR|0x08;
-			txtmap=PM2F_TEXTEL_SIZE_32;
-			pixsize=2;
-			clrformat=0x20;
-			break;
-		case 24:
-			pm2_WR(i, PM2R_FB_READ_PIXEL, 4);
-			clrmode|=PM2F_RD_TRUECOLOR|0x09;
-#ifndef PM2FB_BE_APERTURE
-			clrmode&=~PM2F_RD_COLOR_MODE_RGB;
-#endif
-			txtmap=PM2F_TEXTEL_SIZE_24;
-			pixsize=4;
-			clrformat=0x20;
-			break;
-	}
-	pm2_WR(i, PM2R_FB_WRITE_MODE, PM2F_FB_WRITE_ENABLE);
-	pm2_WR(i, PM2R_FB_READ_MODE, partprod(xres));
-	pm2_WR(i, PM2R_LB_READ_MODE, partprod(xres));
-	pm2_WR(i, PM2R_TEXTURE_MAP_FORMAT, txtmap|partprod(xres));
-	pm2_WR(i, PM2R_H_TOTAL, p->htotal);
-	pm2_WR(i, PM2R_HS_START, p->hsstart);
-	pm2_WR(i, PM2R_HS_END, p->hsend);
-	pm2_WR(i, PM2R_HG_END, p->hbend);
-	pm2_WR(i, PM2R_HB_END, p->hbend);
-	pm2_WR(i, PM2R_V_TOTAL, p->vtotal);
-	pm2_WR(i, PM2R_VS_START, p->vsstart);
-	pm2_WR(i, PM2R_VS_END, p->vsend);
-	pm2_WR(i, PM2R_VB_END, p->vbend);
-	pm2_WR(i, PM2R_SCREEN_STRIDE, p->stride);
-	DEFW();
-	pm2_WR(i, PM2R_WINDOW_ORIGIN, 0);
-	pm2_WR(i, PM2R_SCREEN_SIZE, (p->height<<16)|p->width);
-	pm2_WR(i, PM2R_SCISSOR_MODE, PM2F_SCREEN_SCISSOR_ENABLE);
-	DEFW();
-	pm2_WR(i, PM2R_SCREEN_BASE, p->base);
-	DEFW();
-	set_video(i, p->video);
-	WAIT_FIFO(i, 4);
-	switch (i->type) {
-		case PM2_TYPE_PERMEDIA2:
-			pm2_RDAC_WR(i, PM2I_RD_COLOR_MODE, PM2F_RD_COLOR_MODE_RGB|
-					PM2F_RD_GUI_ACTIVE|clrmode);
-			break;
-		case PM2_TYPE_PERMEDIA2V:
-			pm2v_RDAC_WR(i, PM2VI_RD_PIXEL_SIZE, pixsize);
-			pm2v_RDAC_WR(i, PM2VI_RD_COLOR_FORMAT, clrformat);
-			break;
-	}
-	pm2_set_pixclock(i, p->pixclock);
-}
-
-static int screen_is_valid(struct pm2fb_info* i) {
-	struct pm2fb_par actual;
-
-	get_screen(i, &actual);
-	return i->current_par_valid &&
-		!memcmp(&actual, &i->current_par, sizeof(struct pm2fb_par));
-}
-
-/*
- * copy with packed pixels (8/16bpp only).
- */
-static void pm2fb_pp_copy(struct pm2fb_info* i, s32 xsrc, s32 ysrc,
-					s32 x, s32 y, s32 w, s32 h) {
-	s32 scale=i->current_par.depth==8?2:1;
-	s32 offset;
-
-	if (!w || !h)
-		return;
-	WAIT_FIFO(i, 6);
-	pm2_WR(i, PM2R_CONFIG,	PM2F_CONFIG_FB_WRITE_ENABLE|
-				PM2F_CONFIG_FB_PACKED_DATA|
-				PM2F_CONFIG_FB_READ_SOURCE_ENABLE);
-	pm2_WR(i, PM2R_FB_SOURCE_DELTA,	((ysrc-y)&0xfff)<<16|
-						((xsrc-x)&0xfff));
-	offset=(x&0x3)-(xsrc&0x3);
-	pm2_WR(i, PM2R_RECTANGLE_ORIGIN, (y<<16)|(x>>scale));
-	pm2_WR(i, PM2R_RECTANGLE_SIZE, (h<<16)|((w+7)>>scale));
-	pm2_WR(i, PM2R_PACKED_DATA_LIMITS, (offset<<29)|(x<<16)|(x+w));
-	DEFW();
-	pm2_WR(i, PM2R_RENDER,	PM2F_RENDER_RECTANGLE|
-				(x<xsrc?PM2F_INCREASE_X:0)|
-				(y<ysrc?PM2F_INCREASE_Y:0));
-	wait_pm2(i);
-}
-
-/*
- * block operation. copy=0: rectangle fill, copy=1: rectangle copy.
- */
-static void pm2fb_block_op(struct pm2fb_info* i, int copy,
-					s32 xsrc, s32 ysrc,
-					s32 x, s32 y, s32 w, s32 h,
-					u32 color) {
-
-	if (!w || !h)
-		return;
-	WAIT_FIFO(i, 5);
-	pm2_WR(i, PM2R_CONFIG,	PM2F_CONFIG_FB_WRITE_ENABLE|
-				(copy?PM2F_CONFIG_FB_READ_SOURCE_ENABLE:0));
-	if (copy)
-		pm2_WR(i, PM2R_FB_SOURCE_DELTA,	((ysrc-y)&0xfff)<<16|
-							((xsrc-x)&0xfff));
-	else
-		pm2_WR(i, PM2R_FB_BLOCK_COLOR, color);
-	pm2_WR(i, PM2R_RECTANGLE_ORIGIN, (y<<16)|x);
-	pm2_WR(i, PM2R_RECTANGLE_SIZE, (h<<16)|w);
-	DEFW();
-	pm2_WR(i, PM2R_RENDER,	PM2F_RENDER_RECTANGLE|
-				(x<xsrc?PM2F_INCREASE_X:0)|
-				(y<ysrc?PM2F_INCREASE_Y:0)|
-				(copy?0:PM2F_RENDER_FASTFILL));
-	wait_pm2(i);
-}
-
-/***************************************************************************
- * Begin of generic initialization functions
- ***************************************************************************/
-
-static void reset_units(struct pm2fb_info* p) {
-
+static void reset_config(struct pm2fb_par* p)
+{
 	WAIT_FIFO(p, 52);
 	pm2_WR(p, PM2R_CHIP_CONFIG, pm2_RD(p, PM2R_CHIP_CONFIG)&
-					~(PM2F_VGA_ENABLE|PM2F_VGA_FIXED));
+	       ~(PM2F_VGA_ENABLE|PM2F_VGA_FIXED));
 	pm2_WR(p, PM2R_BYPASS_WRITE_MASK, ~(0L));
 	pm2_WR(p, PM2R_FRAMEBUFFER_WRITE_MASK, ~(0L));
 	pm2_WR(p, PM2R_FIFO_CONTROL, 0);
@@ -1031,1396 +434,847 @@ static void reset_units(struct pm2fb_inf
 	pm2_RDAC_WR(p, PM2I_RD_BLUE_KEY, 0);
 }
 
-static void pm2fb_reset(struct pm2fb_info* p) {
-
-	if (p->type == PM2_TYPE_PERMEDIA2V)
-		pm2_WR(p, PM2VR_RD_INDEX_HIGH, 0);
-	pm2_WR(p, PM2R_RESET_STATUS, 0);
-	DEFRW();
-	while (pm2_RD(p, PM2R_RESET_STATUS)&PM2F_BEING_RESET);
-	DEFRW();
-#ifdef CONFIG_FB_PM2_FIFO_DISCONNECT
-	DPRINTK("FIFO disconnect enabled\n");
-	pm2_WR(p, PM2R_FIFO_DISCON, 1);
-	DEFRW();
-#endif
-	if (board_table[p->board].init)
-		board_table[p->board].init(p);
-	reset_units(p);
-	clear_palette(p);
-	if (p->memclock)
-		pm2_set_memclock(p, p->memclock);
-}
-
-static int __init pm2fb_conf(struct pm2fb_info* p) {
-
-	for (p->board=0; board_table[p->board].detect &&
-			!(board_table[p->board].detect(p)); p->board++);
-	if (!board_table[p->board].detect) {
-		DPRINTK("no board found.\n");
-		return 0;
-	}
-	DPRINTK("found board: %s\n", board_table[p->board].name);
-
-	p->regions.p_fb=p->regions.fb_base;
-	if (!request_mem_region((unsigned long )p->regions.p_fb,
-					p->regions.fb_size, "pm2fb")) {
-		printk (KERN_ERR "pm2fb: cannot reserve fb memory, abort.\n");
-		return 0;
-	}
-	p->regions.v_fb=MMAP(p->regions.p_fb, p->regions.fb_size);
-
-#ifndef PM2FB_BE_APERTURE
-	p->regions.p_regs=p->regions.rg_base;
+static void set_aperture(struct pm2fb_par* p)
+{
+	WAIT_FIFO(p, 4);
+#ifdef __LITTLE_ENDIAN
+	pm2_WR(p, PM2R_APERTURE_ONE, 0);
+	pm2_WR(p, PM2R_APERTURE_TWO, 0);
 #else
-	p->regions.p_regs=p->regions.rg_base+PM2_REGS_SIZE;
-#endif
-	if (!request_mem_region((unsigned long )p->regions.p_regs,
-						PM2_REGS_SIZE, "pm2fb")) {
-		printk (KERN_ERR "pm2fb: cannot reserve mmio memory, abort.\n");
-		UNMAP(p->regions.v_fb, p->regions.fb_size);
-		return 0;
+	switch (p->depth) {
+	case 8:
+	case 24:
+		pm2_WR(p, PM2R_APERTURE_ONE, 0);
+		pm2_WR(p, PM2R_APERTURE_TWO, 1);
+		break;
+	case 16:
+		pm2_WR(p, PM2R_APERTURE_ONE, 2);
+		pm2_WR(p, PM2R_APERTURE_TWO, 1);
+		break;
+	case 32:
+		pm2_WR(p, PM2R_APERTURE_ONE, 1);
+		pm2_WR(p, PM2R_APERTURE_TWO, 1);
+		break;
 	}
-	p->regions.v_regs=MMAP(p->regions.p_regs, PM2_REGS_SIZE);
-
-#ifdef PM2FB_HW_CURSOR
-	p->cursor = pm2_init_cursor(p);
 #endif
-	return 1;
 }
 
-/***************************************************************************
- * Begin of per-board initialization functions
- ***************************************************************************/
-
-/*
- * Phase5 CvisionPPC/BVisionPPC
- */
-#ifdef CONFIG_FB_PM2_CVPPC
-static int cvppc_PCI_init(struct cvppc_par* p) {
-	extern u32 powerup_PCI_present;
-
-	if (!powerup_PCI_present) {
-		DPRINTK("no PCI bridge detected\n");
-		return 0;
-	}
-	if (!(p->pci_config=MMAP(CVPPC_PCI_CONFIG, 256))) {
-		DPRINTK("unable to map PCI config region\n");
-		return 0;
-	}
-	if (RD32(p->pci_config, PCI_VENDOR_ID)!=
-			((PCI_DEVICE_ID_TI_TVP4020<<16)|PCI_VENDOR_ID_TI)) {
-		DPRINTK("bad vendorID/deviceID\n");
-		return 0;
-	}
-	if (!(p->pci_bridge=MMAP(CSPPC_PCI_BRIDGE, 256))) {
-		DPRINTK("unable to map PCI bridge\n");
-		return 0;
-	}
-	WR32(p->pci_bridge, CSPPC_BRIDGE_ENDIAN, CSPPCF_BRIDGE_BIG_ENDIAN);
+static void set_color(struct pm2fb_par* p, unsigned char regno,
+		      unsigned char r, unsigned char g, unsigned char b)
+{
+	WAIT_FIFO(p, 4);
+	pm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, regno);
 	DEFW();
-	if (pm2fb_options.flags & OPTF_OLD_MEM)
-		WR32(p->pci_config, PCI_CACHE_LINE_SIZE, 0xff00);
-	WR32(p->pci_config, PCI_BASE_ADDRESS_0, CVPPC_REGS_REGION);
-	WR32(p->pci_config, PCI_BASE_ADDRESS_1, CVPPC_FB_APERTURE_ONE);
-	WR32(p->pci_config, PCI_BASE_ADDRESS_2, CVPPC_FB_APERTURE_TWO);
-	WR32(p->pci_config, PCI_ROM_ADDRESS, CVPPC_ROM_ADDRESS);
+	pm2_WR(p, PM2R_RD_PALETTE_DATA, r);
 	DEFW();
-	WR32(p->pci_config, PCI_COMMAND, 0xef000000 |
-						PCI_COMMAND_IO |
-						PCI_COMMAND_MEMORY |
-						PCI_COMMAND_MASTER);
-	return 1;
-}
-
-static int __init cvppc_detect(struct pm2fb_info* p) {
-
-	if (!cvppc_PCI_init(&p->board_par.cvppc))
-		return 0;
-	p->type=PM2_TYPE_PERMEDIA2;
-	p->regions.fb_base=CVPPC_FB_APERTURE_ONE;
-	p->regions.fb_size=CVPPC_FB_SIZE;
-	p->regions.rg_base=CVPPC_REGS_REGION;
-	p->memclock=CVPPC_MEMCLOCK;
-	return 1;
-}
-
-static void cvppc_init(struct pm2fb_info* p) {
-
-	WAIT_FIFO(p, 3);
-	pm2_WR(p, PM2R_MEM_CONTROL, 0);
-	pm2_WR(p, PM2R_BOOT_ADDRESS, 0x30);
+	pm2_WR(p, PM2R_RD_PALETTE_DATA, g);
 	DEFW();
-	if (pm2fb_options.flags & OPTF_OLD_MEM)
-		pm2_WR(p, PM2R_MEM_CONFIG, CVPPC_MEM_CONFIG_OLD);
-	else
-		pm2_WR(p, PM2R_MEM_CONFIG, CVPPC_MEM_CONFIG_NEW);
+	pm2_WR(p, PM2R_RD_PALETTE_DATA, b);
 }
-#endif /* CONFIG_FB_PM2_CVPPC */
-
-/*
- * Generic PCI detection routines
- */
-#ifdef CONFIG_FB_PM2_PCI
-struct {
-	unsigned short vendor, device;
-	char *name;
-	pm2type_t type;
-} pm2pci_cards[] __initdata = {
-	{ PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_TVP4020,
-		"Texas Instruments TVP4020", PM2_TYPE_PERMEDIA2 },
-	{ PCI_VENDOR_ID_3DLABS, PCI_DEVICE_ID_3DLABS_PERMEDIA2,
-		"3dLabs Permedia 2", PM2_TYPE_PERMEDIA2 },
-	{ PCI_VENDOR_ID_3DLABS, PCI_DEVICE_ID_3DLABS_PERMEDIA2V,
-		"3dLabs Permedia 2v", PM2_TYPE_PERMEDIA2V },
-	{ 0, 0 }
-};
 
-static int __init pm2pci_detect(struct pm2fb_info* p) {
-	struct pm2pci_par* pci=&p->board_par.pci;
-	struct pci_dev* dev = NULL;
+static void set_pixclock(struct pm2fb_par* par, u32 clk)
+{
 	int i;
-	unsigned char* m;
-#ifdef __sparc__
-	struct pcidev_cookie *pcp;
-#endif
-
-	memset(pci, 0, sizeof(struct pm2pci_par));
-	DPRINTK("scanning PCI bus for known chipsets...\n");
+	unsigned char m, n, p;
 
-	while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
-		for (i = 0; pm2pci_cards[i].vendor; i++)
-			if (pm2pci_cards[i].vendor == dev->vendor &&
-			    pm2pci_cards[i].device == dev->device) {
-				pci->dev = dev;
-				p->type = pm2pci_cards[i].type;
-				DPRINTK("... found %s\n", pm2pci_cards[i].name);
-				break;
-			}
-		if (pci->dev)
-			break;
-	}
-	if (!pci->dev) {
-		DPRINTK("no PCI board found.\n");
-		return 0;
-	}
-	DPRINTK("PCI board @%08lx %08lx %08lx rom %08lx\n",
-			pci->dev->resource[0].start,
-			pci->dev->resource[1].start,
-			pci->dev->resource[2].start,
-			pci->dev->resource[PCI_ROM_RESOURCE].start);
-#ifdef __sparc__
-	p->regions.rg_base= pci->dev->resource[0].start;
-	p->regions.fb_base= pci->dev->resource[1].start;
-	pcp = pci->dev->sysdata;
-	/* If the user has not asked for a particular mode, lets guess */
-	if (pcp->prom_node &&
-	    !(pm2fb_options.flags & (OPTF_USER|OPTF_USER_VAR))) {
-		char timing[256], *q, *r;
-		unsigned long w, h;
-		int i;
-		prom_getstring(pcp->prom_node, "timing-numbers", timing, 256);
-		/* FIXME: Find out what the actual pixclock is
-		 * and other values as well */
-		if (timing[0]) {
-			w = simple_strtoul(timing, &q, 0);
-			h = 0;
-			if (q == timing) w = 0;
-			if (w) {
-				for (i = 0; i < 3; i++) {
-					for (r = q;
-					     *r && (*r < '0' || *r > '9');
-					     r++)
-						;
-					simple_strtoul(r, &q, 0);
-					if (r == q) break;
-				}
-				if (i < 3) w = 0;
-			}
-			if (w) {
-				for (r = q; *r && (*r < '0' || *r > '9'); r++);
-				h = simple_strtoul(r, &q, 0);
-				if (r == q) w = 0;
-			}
-			if (w == 640 && h == 480) w = 0;
-			if (w) {
-				for (i=0; user_mode[i].name[0] &&
-					  (w != user_mode[i].par.width ||
-					   h != user_mode[i].par.height); i++);
-				if (user_mode[i].name[0])
-					memcpy(&p->current_par,
-					       &user_mode[i].par,
-					       sizeof(user_mode[i].par));
-			}
-		}
-	}
-#else
-	if (pm2fb_options.flags & OPTF_VIRTUAL) {
-		p->regions.rg_base = __pa(pci_resource_start(pci->dev, 0));
-		p->regions.fb_base = __pa(pci_resource_start(pci->dev, 1));
-	}
-	else {
-		p->regions.rg_base = pci_resource_start(pci->dev, 0);
-		p->regions.fb_base = pci_resource_start(pci->dev, 1);
-	}
-#endif
-#ifdef PM2FB_BE_APERTURE
-	p->regions.rg_base += PM2_REGS_SIZE;
-#endif
-	if ((m=MMAP(p->regions.rg_base, PM2_REGS_SIZE))) {
-		pci->mem_control=RD32(m, PM2R_MEM_CONTROL);
-		pci->boot_address=RD32(m, PM2R_BOOT_ADDRESS);
-		pci->mem_config=RD32(m, PM2R_MEM_CONFIG);
-		switch (pci->mem_config & PM2F_MEM_CONFIG_RAM_MASK) {
-			case PM2F_MEM_BANKS_1:
-				p->regions.fb_size=0x200000;
-				break;
-			case PM2F_MEM_BANKS_2:
-				p->regions.fb_size=0x400000;
-				break;
-			case PM2F_MEM_BANKS_3:
-				p->regions.fb_size=0x600000;
-				break;
-			case PM2F_MEM_BANKS_4:
-				p->regions.fb_size=0x800000;
-				break;
-		}
-		p->memclock=CVPPC_MEMCLOCK;
-		UNMAP(m, PM2_REGS_SIZE);
-		return 1;
+	switch (par->type) {
+	case PM2_TYPE_PERMEDIA2:
+		pm2_mnp(clk, &m, &n, &p);
+		WAIT_FIFO(par, 8);
+		pm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A3, 0);
+		DEFW();
+		pm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A1, m);
+		pm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A2, n);
+		DEFW();
+		pm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A3, 8|p);
+		DEFW();
+		pm2_RDAC_RD(par, PM2I_RD_PIXEL_CLOCK_STATUS);
+		DEFR();
+		for (i = 256;
+		     i && !(pm2_RD(par, PM2R_RD_INDEXED_DATA) & PM2F_PLL_LOCKED);
+		     i--)
+			;
+		break;
+	case PM2_TYPE_PERMEDIA2V:
+		pm2v_mnp(clk/2, &m, &n, &p);
+		WAIT_FIFO(par, 8);
+		pm2_WR(par, PM2VR_RD_INDEX_HIGH, PM2VI_RD_CLK0_PRESCALE >> 8);
+		pm2v_RDAC_WR(par, PM2VI_RD_CLK0_PRESCALE, m);
+		pm2v_RDAC_WR(par, PM2VI_RD_CLK0_FEEDBACK, n);
+		pm2v_RDAC_WR(par, PM2VI_RD_CLK0_POSTSCALE, p);
+		pm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);
+		break;
 	}
-	DPRINTK("MMAP() failed.\n");
-	return 0;
 }
 
-static void pm2pci_init(struct pm2fb_info* p) {
-	struct pm2pci_par* pci=&p->board_par.pci;
-
-	WAIT_FIFO(p, 3);
-	pm2_WR(p, PM2R_MEM_CONTROL, pci->mem_control);
-	pm2_WR(p, PM2R_BOOT_ADDRESS, pci->boot_address);
-	DEFW();
-	pm2_WR(p, PM2R_MEM_CONFIG, pci->mem_config);
-}
-#endif /* CONFIG_FB_PM2_PCI */
+static void set_video(struct pm2fb_par* p, u32 video) {
+	u32 tmp;
+	u32 vsync;
 
-/***************************************************************************
- * Console hw acceleration
- ***************************************************************************/
+	vsync = video;
+	
+	/*
+	 * The hardware cursor needs +vsync to recognise vert retrace.
+	 * We may not be using the hardware cursor, but the X Glint
+	 * driver may well. So always set +hsync/+vsync and then set
+	 * the RAMDAC to invert the sync if necessary.
+	 */
+	vsync &= ~(PM2F_HSYNC_MASK|PM2F_VSYNC_MASK);
+	vsync |= PM2F_HSYNC_ACT_HIGH|PM2F_VSYNC_ACT_HIGH;
 
-static int pm2fb_blank(int blank_mode, struct fb_info_gen* info) {
-	struct pm2fb_info* i=(struct pm2fb_info* )info;
-	u32 video;
+	WAIT_FIFO(p, 5);
+	pm2_WR(p, PM2R_VIDEO_CONTROL, vsync);
 
-	if (!i->current_par_valid)
-		return 1;
-	video=i->current_par.video;
-	if (blank_mode>0) {
-		i->is_blank=1;
-		switch (blank_mode-1) {
-			case VESA_NO_BLANKING:		/* FIXME */
-				video=video&~(PM2F_VIDEO_ENABLE);
-				break;
-			case VESA_HSYNC_SUSPEND:
-				video=video&~(PM2F_HSYNC_MASK|
-						PM2F_BLANK_LOW);
-				break;
-			case VESA_VSYNC_SUSPEND:
-				video=video&~(PM2F_VSYNC_MASK|
-						PM2F_BLANK_LOW);
-				break;
-			case VESA_POWERDOWN:
-				video=video&~(PM2F_VSYNC_MASK|
-						PM2F_HSYNC_MASK|
-						PM2F_BLANK_LOW);
-				break;
-		}
+	switch (p->type) {
+	case PM2_TYPE_PERMEDIA2:
+		tmp = PM2F_RD_PALETTE_WIDTH_8;
+		if ((video & PM2F_HSYNC_MASK) == PM2F_HSYNC_ACT_LOW)
+			tmp |= 4; /* invert hsync */
+		if ((video & PM2F_VSYNC_MASK) == PM2F_VSYNC_ACT_LOW)
+			tmp |= 8; /* invert vsync */
+		pm2_RDAC_WR(p, PM2I_RD_MISC_CONTROL, tmp);
+		break;
+	case PM2_TYPE_PERMEDIA2V:
+		tmp = 0;
+		if ((video & PM2F_HSYNC_MASK) == PM2F_HSYNC_ACT_LOW)
+			tmp |= 1; /* invert hsync */
+		if ((video & PM2F_VSYNC_MASK) == PM2F_VSYNC_ACT_LOW)
+			tmp |= 4; /* invert vsync */
+		pm2v_RDAC_WR(p, PM2VI_RD_SYNC_CONTROL, tmp);
+		pm2v_RDAC_WR(p, PM2VI_RD_MISC_CONTROL, 1);
+		break;
 	}
-	else
-		i->is_blank=0;
-	set_video(i, video);
-	return 0;
 }
 
-static int pm2fb_pan_display(const struct fb_var_screeninfo* var,
-					struct fb_info_gen* info) {
-	struct pm2fb_info* i=(struct pm2fb_info* )info;
-
-	if (!i->current_par_valid)
-		return -EINVAL;
-	i->current_par.base=to3264(var->yoffset*i->current_par.width+
-				var->xoffset, i->current_par.depth, 1);
-	WAIT_FIFO(i, 1);
-	pm2_WR(i, PM2R_SCREEN_BASE, i->current_par.base);
-	return 0;
-}
-
-static void pm2fb_pp_bmove(struct display* p, int sy, int sx,
-				int dy, int dx, int height, int width) {
-
-	if (fontwidthlog(p)) {
-		sx=sx<<fontwidthlog(p);
-		dx=dx<<fontwidthlog(p);
-		width=width<<fontwidthlog(p);
-	}
-	else {
-		sx=sx*fontwidth(p);
-		dx=dx*fontwidth(p);
-		width=width*fontwidth(p);
-	}
-	sy=sy*fontheight(p);
-	dy=dy*fontheight(p);
-	height=height*fontheight(p);
-	pm2fb_pp_copy((struct pm2fb_info* )p->fb_info, sx, sy, dx,
-							dy, width, height);
-}
-
-static void pm2fb_bmove(struct display* p, int sy, int sx,
-				int dy, int dx, int height, int width) {
-
-	if (fontwidthlog(p)) {
-		sx=sx<<fontwidthlog(p);
-		dx=dx<<fontwidthlog(p);
-		width=width<<fontwidthlog(p);
-	}
-	else {
-		sx=sx*fontwidth(p);
-		dx=dx*fontwidth(p);
-		width=width*fontwidth(p);
-	}
-	sy=sy*fontheight(p);
-	dy=dy*fontheight(p);
-	height=height*fontheight(p);
-	pm2fb_block_op((struct pm2fb_info* )p->fb_info, 1, sx, sy, dx, dy,
-							width, height, 0);
-}
-
-#ifdef FBCON_HAS_CFB8
-static void pm2fb_clear8(struct vc_data* conp, struct display* p,
-				int sy, int sx, int height, int width) {
-	u32 c;
-
-	sx=sx*fontwidth(p);
-	width=width*fontwidth(p);
-	sy=sy*fontheight(p);
-	height=height*fontheight(p);
-	c=attr_bgcol_ec(p, conp);
-	c|=c<<8;
-	c|=c<<16;
-	pm2fb_block_op((struct pm2fb_info* )p->fb_info, 0, 0, 0, sx, sy,
-							width, height, c);
-}
-
-static void pm2fb_clear_margins8(struct vc_data* conp, struct display* p,
-							int bottom_only) {
-	u32 c;
-	u32 sx;
-	u32 sy;
-
-	c=attr_bgcol_ec(p, conp);
-	c|=c<<8;
-	c|=c<<16;
-	sx=conp->vc_cols*fontwidth(p);
-	sy=conp->vc_rows*fontheight(p);
-	if (!bottom_only)
-		pm2fb_block_op((struct pm2fb_info* )p->fb_info, 0, 0, 0,
-			sx, 0, (p->var.xres-sx), p->var.yres_virtual, c);
-	pm2fb_block_op((struct pm2fb_info* )p->fb_info, 0, 0, 0,
-				0, p->var.yoffset+sy, sx, p->var.yres-sy, c);
-}
-
-static struct display_switch pm2_cfb8 = {
-	.setup		= fbcon_cfb8_setup,
-	.bmove		= pm2fb_pp_bmove,
-#ifdef __alpha__
-	/* Not sure why, but this works and the other does not. */
-	/* Also, perhaps we need a separate routine to wait for the
-	   blitter to stop before doing this? */
-	/* In addition, maybe we need to do this for 16 and 32 bit depths? */
-	.clear		= fbcon_cfb8_clear,
-#else
-	.clear		= pm2fb_clear8,
-#endif
-	.putc		= fbcon_cfb8_putc,
-	.putcs		= fbcon_cfb8_putcs,
-	.revc		= fbcon_cfb8_revc,
-	.cursor		= pm2fb_cursor,
-	.set_font	= pm2fb_set_font,
-	.clear_margins	= pm2fb_clear_margins8,
-	.fontwidthmask	= FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16) };
-#endif /* FBCON_HAS_CFB8 */
-
-#ifdef FBCON_HAS_CFB16
-static void pm2fb_clear16(struct vc_data* conp, struct display* p,
-				int sy, int sx, int height, int width) {
-	u32 c;
-
-	sx=sx*fontwidth(p);
-	width=width*fontwidth(p);
-	sy=sy*fontheight(p);
-	height=height*fontheight(p);
-	c=((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
-	c|=c<<16;
-	pm2fb_block_op((struct pm2fb_info* )p->fb_info, 0, 0, 0, sx, sy,
-							width, height, c);
-}
-
-static void pm2fb_clear_margins16(struct vc_data* conp, struct display* p,
-							int bottom_only) {
-	u32 c;
-	u32 sx;
-	u32 sy;
-
-	c=((u16 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
-	c|=c<<16;
-	sx=conp->vc_cols*fontwidth(p);
-	sy=conp->vc_rows*fontheight(p);
-	if (!bottom_only)
-		pm2fb_block_op((struct pm2fb_info* )p->fb_info, 0, 0, 0,
-			sx, 0, (p->var.xres-sx), p->var.yres_virtual, c);
-	pm2fb_block_op((struct pm2fb_info* )p->fb_info, 0, 0, 0,
-				0, p->var.yoffset+sy, sx, p->var.yres-sy, c);
-}
-
-static struct display_switch pm2_cfb16 = {
-	.setup =	fbcon_cfb16_setup,
-	.bmove =	pm2fb_pp_bmove,
-	.clear =	pm2fb_clear16,
-	.putc =		fbcon_cfb16_putc,
-	.putcs =	fbcon_cfb16_putcs,
-	.revc =		fbcon_cfb16_revc,
-	.cursor =	pm2fb_cursor,
-	.set_font =	pm2fb_set_font,
-	.clear_margins =pm2fb_clear_margins16,
-	.fontwidthmask =FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
-};
-#endif /* FBCON_HAS_CFB16 */
-
-#ifdef FBCON_HAS_CFB24
 /*
- * fast fill for 24bpp works only when red==green==blue
+ *
  */
-static void pm2fb_clear24(struct vc_data* conp, struct display* p,
-				int sy, int sx, int height, int width) {
-	struct pm2fb_info* i=(struct pm2fb_info* )p->fb_info;
-	u32 c;
-
-	c=attr_bgcol_ec(p, conp);
-	if (		i->palette[c].red==i->palette[c].green &&
-			i->palette[c].green==i->palette[c].blue) {
-		c=((u32 *)p->dispsw_data)[c];
-		c|=(c&0xff0000)<<8;
-		sx=sx*fontwidth(p);
-		width=width*fontwidth(p);
-		sy=sy*fontheight(p);
-		height=height*fontheight(p);
-		pm2fb_block_op(i, 0, 0, 0, sx, sy, width, height, c);
-	}
-	else
-		fbcon_cfb24_clear(conp, p, sy, sx, height, width);
-
-}
 
-static void pm2fb_clear_margins24(struct vc_data* conp, struct display* p,
-							int bottom_only) {
-	struct pm2fb_info* i=(struct pm2fb_info* )p->fb_info;
-	u32 sx;
-	u32 sy;
-
-	sx=conp->vc_cols*fontwidth(p);
-	sy=conp->vc_rows*fontheight(p);
-	if (!bottom_only)
-		pm2fb_block_op(i, 0, 0, 0, sx, 0, (p->var.xres-sx),
-			       p->var.yres_virtual, 0L);
-	pm2fb_block_op(i, 0, 0, 0, 0, p->var.yoffset+sy, sx, p->var.yres-sy, 0L);
-}
-
-static struct display_switch pm2_cfb24 = {
-	.setup =	fbcon_cfb24_setup,
-	.bmove =	pm2fb_bmove,
-	.clear =	pm2fb_clear24,
-	.putc =		fbcon_cfb24_putc,
-	.putcs =	fbcon_cfb24_putcs,
-	.revc =		fbcon_cfb24_revc,
-	.cursor =	pm2fb_cursor,
-	.set_font =	pm2fb_set_font,
-	.clear_margins =pm2fb_clear_margins24,
-	.fontwidthmask =FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
-};
-#endif /* FBCON_HAS_CFB24 */
-
-#ifdef FBCON_HAS_CFB32
-static void pm2fb_clear32(struct vc_data* conp, struct display* p,
-				int sy, int sx, int height, int width) {
-	u32 c;
-
-	sx=sx*fontwidth(p);
-	width=width*fontwidth(p);
-	sy=sy*fontheight(p);
-	height=height*fontheight(p);
-	c=((u32 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
-	pm2fb_block_op((struct pm2fb_info* )p->fb_info, 0, 0, 0, sx, sy,
-							width, height, c);
-}
-
-static void pm2fb_clear_margins32(struct vc_data* conp, struct display* p,
-							int bottom_only) {
-	u32 c;
-	u32 sx;
-	u32 sy;
-
-	c=((u32 *)p->dispsw_data)[attr_bgcol_ec(p, conp)];
-	sx=conp->vc_cols*fontwidth(p);
-	sy=conp->vc_rows*fontheight(p);
-	if (!bottom_only)
-		pm2fb_block_op((struct pm2fb_info* )p->fb_info, 0, 0, 0,
-			sx, 0, (p->var.xres-sx), p->var.yres_virtual, c);
-	pm2fb_block_op((struct pm2fb_info* )p->fb_info, 0, 0, 0,
-				0, p->var.yoffset+sy, sx, p->var.yres-sy, c);
-}
-
-static struct display_switch pm2_cfb32 = {
-	.setup =	fbcon_cfb32_setup,
-	.bmove =	pm2fb_bmove,
-	.clear =	pm2fb_clear32,
-	.putc =		fbcon_cfb32_putc,
-	.putcs =	fbcon_cfb32_putcs,
-	.revc =		fbcon_cfb32_revc,
-	.cursor =	pm2fb_cursor,
-	.set_font =	pm2fb_set_font,
-	.clear_margins =pm2fb_clear_margins32,
-	.fontwidthmask =FONTWIDTH(4)|FONTWIDTH(8)|FONTWIDTH(12)|FONTWIDTH(16)
-};
-#endif /* FBCON_HAS_CFB32 */
-
-/***************************************************************************
- * Framebuffer functions
- ***************************************************************************/
-
-static void pm2fb_detect(void) {}
-
-static int pm2fb_encode_fix(struct fb_fix_screeninfo* fix,
-			const void* par, struct fb_info_gen* info) {
-	struct pm2fb_info* i=(struct pm2fb_info* )info;
-	struct pm2fb_par* p=(struct pm2fb_par* )par;
-
-	strcpy(fix->id, permedia2_name);
-	fix->smem_start=(unsigned long )i->regions.p_fb;
-	fix->smem_len=i->regions.fb_size;
-	fix->mmio_start=(unsigned long )i->regions.p_regs;
-	fix->mmio_len=PM2_REGS_SIZE;
-	fix->accel=FB_ACCEL_3DLABS_PERMEDIA2;
-	fix->type=FB_TYPE_PACKED_PIXELS;
-	fix->visual=p->depth==8?FB_VISUAL_PSEUDOCOLOR:FB_VISUAL_TRUECOLOR;
-	fix->line_length=p->width*p->depth/8;
-	fix->xpanstep=p->depth==24?8:64/p->depth;
-	fix->ypanstep=1;
-	fix->ywrapstep=0;
-	return 0;
-}
-
-#ifdef PM2FB_MASTER_DEBUG
-static void pm2fb_display_var(const struct fb_var_screeninfo* var) {
-
-	printk( KERN_DEBUG
-"- struct fb_var_screeninfo ---------------------------------------------------\n");
-	printk( KERN_DEBUG
-		"resolution: %ux%ux%u (virtual %ux%u+%u+%u)\n",
-			var->xres, var->yres, var->bits_per_pixel,
-			var->xres_virtual, var->yres_virtual,
-			var->xoffset, var->yoffset);
-	printk( KERN_DEBUG
-		"color: %c%c "
-		"R(%u,%u,%u), G(%u,%u,%u), B(%u,%u,%u), T(%u,%u,%u)\n",
-			var->grayscale?'G':'C', var->nonstd?'N':'S',
-			var->red.offset, var->red.length, var->red.msb_right,
-			var->green.offset, var->green.length, var->green.msb_right,
-			var->blue.offset, var->blue.length, var->blue.msb_right,
-			var->transp.offset, var->transp.length,
-			var->transp.msb_right);
-	printk( KERN_DEBUG
-		"timings: %ups (%u,%u)-(%u,%u)+%u+%u\n",
-		var->pixclock,
-		var->left_margin, var->upper_margin, var->right_margin,
-		var->lower_margin, var->hsync_len, var->vsync_len);
-	printk(	KERN_DEBUG
-		"activate %08x accel_flags %08x sync %08x vmode %08x\n",
-		var->activate, var->accel_flags, var->sync, var->vmode);
-	printk(	KERN_DEBUG
-"------------------------------------------------------------------------------\n");
-}
+/**
+ *      pm2fb_check_var - Optional function. Validates a var passed in. 
+ *      @var: frame buffer variable screen structure
+ *      @info: frame buffer structure that represents a single frame buffer 
+ *
+ *	Checks to see if the hardware supports the state requested by
+ *	var passed in.
+ *
+ *	Returns negative errno on error, or zero on success.
+ */
+static int pm2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	u32 lpitch;
 
-#define pm2fb_decode_var pm2fb_wrapped_decode_var
-#endif
+	if (var->bits_per_pixel != 8  && var->bits_per_pixel != 16 &&
+	    var->bits_per_pixel != 24 && var->bits_per_pixel != 32) {
+		DPRINTK("depth not supported: %u\n", var->bits_per_pixel);
+		return -EINVAL;
+	}
 
-static int pm2fb_decode_var(const struct fb_var_screeninfo* var,
-				void* par, struct fb_info_gen* info) {
-	struct pm2fb_info* i=(struct pm2fb_info* )info;
-	struct pm2fb_par p;
-	u32 xres;
-	int data64;
+	if (var->xres != var->xres_virtual) {
+		DPRINTK("virtual x resolution != physical x resolution not supported\n");
+		return -EINVAL;
+	}
 
-	memset(&p, 0, sizeof(struct pm2fb_par));
-	if (var->accel_flags & FB_ACCELF_TEXT)
-		p.flags |= PM2FF_ACCEL;
-	p.width=(var->xres_virtual+7)&~7;
-	p.height=var->yres_virtual;
-	p.depth=(var->bits_per_pixel+7)&~7;
-	p.depth=p.depth>32?32:p.depth;
-	data64=p.depth>8 || i->type==PM2_TYPE_PERMEDIA2V;
-	xres=(var->xres+31)&~31;
-	if (p.width<xres+var->xoffset)
-		p.width=xres+var->xoffset;
-	if (p.height<var->yres+var->yoffset)
-		p.height=var->yres+var->yoffset;
-	if (!partprod(xres)) {
-		DPRINTK("width not supported: %u\n", xres);
+	if (var->yres > var->yres_virtual) {
+		DPRINTK("virtual y resolution < physical y resolution not possible\n");
 		return -EINVAL;
 	}
-	if (p.width>2047) {
-		DPRINTK("virtual width not supported: %u\n", p.width);
+
+	if (var->xoffset) {
+		DPRINTK("xoffset not supported\n");
 		return -EINVAL;
 	}
-	if (var->yres<200) {
-		DPRINTK("height not supported: %u\n",
-						(u32 )var->yres);
+
+	if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+		DPRINTK("interlace not supported\n");
 		return -EINVAL;
 	}
-	if (p.height<200 || p.height>2047) {
-		DPRINTK("virtual height not supported: %u\n", p.height);
+
+	var->xres = (var->xres + 15) & ~15; /* could sometimes be 8 */
+	lpitch = var->xres * ((var->bits_per_pixel + 7)>>3);
+  
+	if (var->xres < 320 || var->xres > 1600) {
+		DPRINTK("width not supported: %u\n", var->xres);
 		return -EINVAL;
 	}
-	if (p.depth>32) {
-		DPRINTK("depth not supported: %u\n", p.depth);
+  
+	if (var->yres < 200 || var->yres > 1200) {
+		DPRINTK("height not supported: %u\n", var->yres);
 		return -EINVAL;
 	}
-	if (p.width*p.height*p.depth/8>i->regions.fb_size) {
+  
+	if (lpitch * var->yres_virtual > info->fix.smem_len) {
 		DPRINTK("no memory for screen (%ux%ux%u)\n",
-						p.width, p.height, p.depth);
+			var->xres, var->yres_virtual, var->bits_per_pixel);
 		return -EINVAL;
 	}
-	p.pixclock=PICOS2KHZ(var->pixclock);
-	if (p.pixclock>PM2_MAX_PIXCLOCK) {
-		DPRINTK("pixclock too high (%uKHz)\n", p.pixclock);
+  
+	if (PICOS2KHZ(var->pixclock) > PM2_MAX_PIXCLOCK) {
+		DPRINTK("pixclock too high (%ldKHz)\n", PICOS2KHZ(var->pixclock));
 		return -EINVAL;
 	}
-	p.hsstart=to3264(var->right_margin, p.depth, data64);
-	p.hsend=p.hsstart+to3264(var->hsync_len, p.depth, data64);
-	p.hbend=p.hsend+to3264(var->left_margin, p.depth, data64);
-	p.htotal=to3264(xres, p.depth, data64)+p.hbend-1;
-	p.vsstart=var->lower_margin?var->lower_margin-1:0;	/* FIXME! */
-	p.vsend=var->lower_margin+var->vsync_len-1;
-	p.vbend=var->lower_margin+var->vsync_len+var->upper_margin;
-	p.vtotal=var->yres+p.vbend-1;
-	p.stride=to3264(p.width, p.depth, 1);
-	p.base=to3264(var->yoffset*xres+var->xoffset, p.depth, 1);
+
+	switch(var->bits_per_pixel) {
+	case 8:
+		var->red.length = var->green.length = var->blue.length = 8;
+		break;
+	case 16:
+		var->red.offset   = 11;
+		var->red.length   = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset  = 0;
+		var->blue.length  = 5;
+		break;
+	case 24:
+		var->red.offset	  = 16;
+		var->green.offset = 8;
+		var->blue.offset  = 0;
+		var->red.length = var->green.length = var->blue.length = 8;
+	case 32:
+		var->red.offset   = 16;
+		var->green.offset = 8;
+		var->blue.offset  = 0;
+		var->red.length = var->green.length = var->blue.length = 8;
+		break;
+	}
+	var->height = var->width = -1;
+  
+	var->accel_flags = 0;	/* Can't mmap if this is on */
+	
+	DPRINTK("Checking graphics mode at %dx%d depth %d\n",
+		var->xres, var->yres, var->bits_per_pixel);
+	return 0;
+}
+
+/**
+ *      pm2fb_set_par - Alters the hardware state.
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *	Using the fb_var_screeninfo in fb_info we set the resolution of the
+ *	this particular framebuffer.
+ */
+static int pm2fb_set_par(struct fb_info *info)
+{
+	struct pm2fb_par *par = (struct pm2fb_par *) info->par;
+	u32 pixclock;
+	u32 width, height, depth;
+	u32 hsstart, hsend, hbend, htotal;
+	u32 vsstart, vsend, vbend, vtotal;
+	u32 stride;
+	u32 base;
+	u32 video = 0;
+	u32 clrmode = PM2F_RD_COLOR_MODE_RGB;
+	u32 txtmap = 0;
+	u32 pixsize = 0;
+	u32 clrformat = 0;
+	u32 xres;
+	int data64;
+
+	reset_config(par);
+	clear_palette(par);
+    
+	width = (info->var.xres_virtual + 7) & ~7;
+	height = info->var.yres_virtual;
+	depth = (info->var.bits_per_pixel + 7) & ~7;
+	depth = (depth > 32) ? 32 : depth;
+	data64 = depth > 8 || par->type == PM2_TYPE_PERMEDIA2V;
+
+	xres = (info->var.xres + 31) & ~31;
+	pixclock = PICOS2KHZ(info->var.pixclock);
+	if (pixclock > PM2_MAX_PIXCLOCK) {
+		DPRINTK("pixclock too high (%uKHz)\n", pixclock);
+		return -EINVAL;
+	}
+    
+	hsstart = to3264(info->var.right_margin, depth, data64);
+	hsend = hsstart + to3264(info->var.hsync_len, depth, data64);
+	hbend = hsend + to3264(info->var.left_margin, depth, data64);
+	htotal = to3264(xres, depth, data64) + hbend - 1;
+	vsstart = (info->var.lower_margin)
+		? info->var.lower_margin - 1
+		: 0;	/* FIXME! */
+	vsend = info->var.lower_margin + info->var.vsync_len - 1;
+	vbend = info->var.lower_margin + info->var.vsync_len + info->var.upper_margin;
+	vtotal = info->var.yres + vbend - 1;
+	stride = to3264(width, depth, 1);
+	base = to3264(info->var.yoffset * xres + info->var.xoffset, depth, 1);
 	if (data64)
-		p.video|=PM2F_DATA_64_ENABLE;
-	if (var->sync & FB_SYNC_HOR_HIGH_ACT) {
-		if (pm2fb_options.flags & OPTF_LOW_HSYNC) {
+		video |= PM2F_DATA_64_ENABLE;
+    
+	if (info->var.sync & FB_SYNC_HOR_HIGH_ACT) {
+		if (lowhsync) {
 			DPRINTK("ignoring +hsync, using -hsync.\n");
-			p.video|=PM2F_HSYNC_ACT_LOW;
+			video |= PM2F_HSYNC_ACT_LOW;
 		} else
-			p.video|=PM2F_HSYNC_ACT_HIGH;
+			video |= PM2F_HSYNC_ACT_HIGH;
 	}
 	else
-		p.video|=PM2F_HSYNC_ACT_LOW;
-	if (var->sync & FB_SYNC_VERT_HIGH_ACT) {
-		if (pm2fb_options.flags & OPTF_LOW_VSYNC) {
+		video |= PM2F_HSYNC_ACT_LOW;
+	if (info->var.sync & FB_SYNC_VERT_HIGH_ACT) {
+		if (lowvsync) {
 			DPRINTK("ignoring +vsync, using -vsync.\n");
-			p.video|=PM2F_VSYNC_ACT_LOW;
+			video |= PM2F_VSYNC_ACT_LOW;
 		} else
-			p.video|=PM2F_VSYNC_ACT_HIGH;
+			video |= PM2F_VSYNC_ACT_HIGH;
 	}
 	else
-		p.video|=PM2F_VSYNC_ACT_LOW;
-	if ((var->vmode & FB_VMODE_MASK)==FB_VMODE_INTERLACED) {
+		video |= PM2F_VSYNC_ACT_LOW;
+	if ((info->var.vmode & FB_VMODE_MASK)==FB_VMODE_INTERLACED) {
 		DPRINTK("interlaced not supported\n");
 		return -EINVAL;
 	}
-	if ((var->vmode & FB_VMODE_MASK)==FB_VMODE_DOUBLE)
-		p.video|=PM2F_LINE_DOUBLE;
-	if (var->activate==FB_ACTIVATE_NOW)
-		p.video|=PM2F_VIDEO_ENABLE;
-	*((struct pm2fb_par* )par)=p;
-	return 0;
-}
-
-#ifdef PM2FB_MASTER_DEBUG
-#undef pm2fb_decode_var
+	if ((info->var.vmode & FB_VMODE_MASK)==FB_VMODE_DOUBLE)
+		video |= PM2F_LINE_DOUBLE;
+	if (info->var.activate==FB_ACTIVATE_NOW)
+		video |= PM2F_VIDEO_ENABLE;
+	par->video = video;
+
+	info->fix.visual =
+		(depth == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+	info->fix.line_length =
+		info->var.xres * ((info->var.bits_per_pixel + 7) >> 3);
+	info->cmap.len = 256;
 
-static int pm2fb_decode_var(const struct fb_var_screeninfo* var,
-				void* par, struct fb_info_gen* info) {
-	int result;
-
-	result=pm2fb_wrapped_decode_var(var, par, info);
-	pm2fb_display_var(var);
-	return result;
-}
+	/*
+	 * Settings calculated. Now write them out.
+	 */
+	if (par->type == PM2_TYPE_PERMEDIA2V) {
+		WAIT_FIFO(par, 1);
+		pm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);
+	}
+    
+	set_aperture(par);
+    
+	DEFRW();
+	WAIT_FIFO(par, 19);
+	pm2_RDAC_WR(par, PM2I_RD_COLOR_KEY_CONTROL,
+		    ( depth == 8 ) ? 0 : PM2F_COLOR_KEY_TEST_OFF);
+	switch (depth) {
+	case 8:
+		pm2_WR(par, PM2R_FB_READ_PIXEL, 0);
+		clrformat = 0x0e;
+		break;
+	case 16:
+		pm2_WR(par, PM2R_FB_READ_PIXEL, 1);
+		clrmode |= PM2F_RD_TRUECOLOR | 0x06;
+		txtmap = PM2F_TEXTEL_SIZE_16;
+		pixsize = 1;
+		clrformat = 0x70;
+		break;
+	case 32:
+		pm2_WR(par, PM2R_FB_READ_PIXEL, 2);
+		clrmode |= PM2F_RD_TRUECOLOR | 0x08;
+		txtmap = PM2F_TEXTEL_SIZE_32;
+		pixsize = 2;
+		clrformat = 0x20;
+		break;
+	case 24:
+		pm2_WR(par, PM2R_FB_READ_PIXEL, 4);
+		clrmode |= PM2F_RD_TRUECOLOR | 0x09;
+#ifndef PM2FB_BE_APERTURE
+		clrmode &= ~PM2F_RD_COLOR_MODE_RGB;
 #endif
-
-static void pm2fb_par2var(struct fb_var_screeninfo* v,
-					const struct pm2fb_par* p) {
-	u32 base;
-
-	memset(v, 0, sizeof(struct fb_var_screeninfo));
-	if (p->flags & PM2FF_ACCEL)
-		v->accel_flags |= FB_ACCELF_TEXT;
-	v->xres_virtual=p->width;
-	v->yres_virtual=p->height;
-	v->xres=(p->htotal+1)-p->hbend;
-	v->yres=(p->vtotal+1)-p->vbend;
-	v->right_margin=p->hsstart;
-	v->hsync_len=p->hsend-p->hsstart;
-	v->left_margin=p->hbend-p->hsend;
-	v->lower_margin=p->vsstart+1;
-	v->vsync_len=p->vsend-v->lower_margin+1;
-	v->upper_margin=p->vbend-v->lower_margin-v->vsync_len;
-	v->bits_per_pixel=p->depth;
-	if (p->video & PM2F_DATA_64_ENABLE) {
-		v->xres=v->xres<<1;
-		v->right_margin=v->right_margin<<1;
-		v->hsync_len=v->hsync_len<<1;
-		v->left_margin=v->left_margin<<1;
-	}
-	switch (p->depth) {
-		case 8:
-			v->red.length=v->green.length=v->blue.length=8;
-			v->xres=v->xres<<2;
-			v->right_margin=v->right_margin<<2;
-			v->hsync_len=v->hsync_len<<2;
-			v->left_margin=v->left_margin<<2;
-			break;
-		case 16:
-			v->red.offset=11;
-			v->red.length=5;
-			v->green.offset=5;
-			v->green.length=6;
-			v->blue.length=5;
-			v->xres=v->xres<<1;
-			v->right_margin=v->right_margin<<1;
-			v->hsync_len=v->hsync_len<<1;
-			v->left_margin=v->left_margin<<1;
-			break;
-		case 32:
-			v->transp.offset=24;
-			v->red.offset=16;
-			v->green.offset=8;
-			v->red.length=v->green.length=v->blue.length=
-							v->transp.length=8;
-			break;
-		case 24:
-			v->blue.offset=16;
-			v->green.offset=8;
-			v->red.length=v->green.length=v->blue.length=8;
-			v->xres=(v->xres<<2)/3;
-			v->right_margin=(v->right_margin<<2)/3;
-			v->hsync_len=(v->hsync_len<<2)/3;
-			v->left_margin=(v->left_margin<<2)/3;
-			break;
-	}
-	base=from3264(p->base, p->depth, 1);
-	v->xoffset=base%v->xres;
-	v->yoffset=base/v->xres;
-	v->height=v->width=-1;
-	v->pixclock=KHZ2PICOS(p->pixclock);
-	if ((p->video & PM2F_HSYNC_MASK)==PM2F_HSYNC_ACT_HIGH)
-		v->sync|=FB_SYNC_HOR_HIGH_ACT;
-	if ((p->video & PM2F_VSYNC_MASK)==PM2F_VSYNC_ACT_HIGH)
-		v->sync|=FB_SYNC_VERT_HIGH_ACT;
-	if (p->video & PM2F_LINE_DOUBLE)
-		v->vmode=FB_VMODE_DOUBLE;
-}
-
-
-static int pm2fb_encode_var(struct fb_var_screeninfo* var,
-				const void* par, struct fb_info_gen* info) {
-
-	pm2fb_par2var(var, (struct pm2fb_par* )par);
-	return 0;
-}
-
-static void set_user_mode(struct pm2fb_info* i) {
-
-	memcpy(&i->current_par, &pm2fb_options.user_mode,
-	       sizeof(i->current_par));
-	if (pm2fb_options.flags & OPTF_YPAN) {
-		i->current_par.height=i->regions.fb_size/
-			(i->current_par.width*i->current_par.depth/8);
-		i->current_par.height=MIN(i->current_par.height,2047);
-		i->current_par.height=MAX(i->current_par.height,
-					  pm2fb_options.user_mode.height);
+		txtmap = PM2F_TEXTEL_SIZE_24;
+		pixsize = 4;
+		clrformat = 0x20;
+		break;
 	}
-}
-
-static void pm2fb_get_par(void* par, struct fb_info_gen* info) {
-	struct pm2fb_info* i=(struct pm2fb_info* )info;
-
-	if (!i->current_par_valid) {
-		set_user_mode(i);
-		pm2fb_set_par(&i->current_par, info);
+	pm2_WR(par, PM2R_FB_WRITE_MODE, PM2F_FB_WRITE_ENABLE);
+	pm2_WR(par, PM2R_FB_READ_MODE, partprod(xres));
+	pm2_WR(par, PM2R_LB_READ_MODE, partprod(xres));
+	pm2_WR(par, PM2R_TEXTURE_MAP_FORMAT, txtmap | partprod(xres));
+	pm2_WR(par, PM2R_H_TOTAL, htotal);
+	pm2_WR(par, PM2R_HS_START, hsstart);
+	pm2_WR(par, PM2R_HS_END, hsend);
+	pm2_WR(par, PM2R_HG_END, hbend);
+	pm2_WR(par, PM2R_HB_END, hbend);
+	pm2_WR(par, PM2R_V_TOTAL, vtotal);
+	pm2_WR(par, PM2R_VS_START, vsstart);
+	pm2_WR(par, PM2R_VS_END, vsend);
+	pm2_WR(par, PM2R_VB_END, vbend);
+	pm2_WR(par, PM2R_SCREEN_STRIDE, stride);
+	DEFW();
+	pm2_WR(par, PM2R_WINDOW_ORIGIN, 0);
+	pm2_WR(par, PM2R_SCREEN_SIZE, (height << 16) | width);
+	pm2_WR(par, PM2R_SCISSOR_MODE, PM2F_SCREEN_SCISSOR_ENABLE);
+	DEFW();
+	pm2_WR(par, PM2R_SCREEN_BASE, base);
+	DEFW();
+	set_video(par, video);
+	WAIT_FIFO(par, 4);
+	switch (par->type) {
+	case PM2_TYPE_PERMEDIA2:
+		pm2_RDAC_WR(par, PM2I_RD_COLOR_MODE,
+			    PM2F_RD_COLOR_MODE_RGB | PM2F_RD_GUI_ACTIVE | clrmode);
+		break;
+	case PM2_TYPE_PERMEDIA2V:
+		pm2v_RDAC_WR(par, PM2VI_RD_PIXEL_SIZE, pixsize);
+		pm2v_RDAC_WR(par, PM2VI_RD_COLOR_FORMAT, clrformat);
+		break;
 	}
-	get_screen(i, (struct pm2fb_par* )par);
+	set_pixclock(par, pixclock);
+	return 0;	
 }
 
-static void pm2fb_set_par(const void* par, struct fb_info_gen* info) {
-	struct pm2fb_info* i=(struct pm2fb_info* )info;
-	struct pm2fb_par* p=(struct pm2fb_par* )par;
+/**
+ *  	pm2fb_setcolreg - Sets a color register.
+ *      @regno: boolean, 0 copy local, 1 get_user() function
+ *      @red: frame buffer colormap structure
+ *	@green: The green value which can be up to 16 bits wide 
+ *	@blue:  The blue value which can be up to 16 bits wide.
+ *	@transp: If supported the alpha value which can be up to 16 bits wide.	
+ *      @info: frame buffer info structure
+ * 
+ *  	Set a single color register. The values supplied have a 16 bit
+ *  	magnitude which needs to be scaled in this function for the hardware.
+ *	Pretty much a direct lift from tdfxfb.c.
+ * 
+ *	Returns negative errno on error, or zero on success.
+ */
+static int pm2fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned transp,
+			   struct fb_info *info)
+{
+	struct pm2fb_par *par = (struct pm2fb_par *) info->par;
 
-	if (screen_is_valid(i)) {
-		i->current_par.base=p->base;
-		if (!memcmp(p, &i->current_par, sizeof(struct pm2fb_par))) {
-			WAIT_FIFO(i, 1);
-			pm2_WR(i, PM2R_SCREEN_BASE, p->base);
-			return;
-		}
-	}
+	if (regno >= info->cmap.len)  /* no. of hw registers */
+		return 1;
+	/*
+	 * Program hardware... do anything you want with transp
+	 */
 
-	wait_pm2(i);
-	reset_units(i);
-	set_screen(i, p);
-	i->current_par=*p;
-	i->current_par_valid=1;
-#ifdef PM2FB_HW_CURSOR	
-	if (i->cursor) {
-		pm2v_set_cursor_color(i, cursor_color_map,
-				cursor_color_map, cursor_color_map);
-		pm2v_set_cursor_shape(i);
+	/* grayscale works only partially under directcolor */
+	if (info->var.grayscale) {
+		/* grayscale = 0.30*R + 0.59*G + 0.11*B */
+		red = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;
+	}
+
+	/* Directcolor:
+	 *   var->{color}.offset contains start of bitfield
+	 *   var->{color}.length contains length of bitfield
+	 *   {hardwarespecific} contains width of DAC
+	 *   cmap[X] is programmed to (X << red.offset) | (X << green.offset) | (X << blue.offset)
+	 *   RAMDAC[X] is programmed to (red, green, blue)
+	 *
+	 * Pseudocolor:
+	 *    uses offset = 0 && length = DAC register width.
+	 *    var->{color}.offset is 0
+	 *    var->{color}.length contains widht of DAC
+	 *    cmap is not used
+	 *    DAC[X] is programmed to (red, green, blue)
+	 * Truecolor:
+	 *    does not use RAMDAC (usually has 3 of them).
+	 *    var->{color}.offset contains start of bitfield
+	 *    var->{color}.length contains length of bitfield
+	 *    cmap is programmed to (red << red.offset) | (green << green.offset) |
+	 *                      (blue << blue.offset) | (transp << transp.offset)
+	 *    RAMDAC does not exist
+	 */
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		red = CNVT_TOHW(red, info->var.red.length);
+		green = CNVT_TOHW(green, info->var.green.length);
+		blue = CNVT_TOHW(blue, info->var.blue.length);
+		transp = CNVT_TOHW(transp, info->var.transp.length);
+		set_color(par, regno, red, green, blue);
+		break;
+	case FB_VISUAL_DIRECTCOLOR:
+		/* example here assumes 8 bit DAC. Might be different 
+		 * for your hardware */	
+		red = CNVT_TOHW(red, 8);       
+		green = CNVT_TOHW(green, 8);
+		blue = CNVT_TOHW(blue, 8);
+		/* hey, there is bug in transp handling... */
+		transp = CNVT_TOHW(transp, 8);
+		break;
 	}
-#endif
-}
+#undef CNVT_TOHW
+	/* Truecolor has hardware independent palette */
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
+		u32 v;
+
+		if (regno >= 16)
+			return 1;
+
+		v = (red << info->var.red.offset) |
+			(green << info->var.green.offset) |
+			(blue << info->var.blue.offset) |
+			(transp << info->var.transp.offset);
 
-static int pm2fb_getcolreg(unsigned regno,
-			unsigned* red, unsigned* green, unsigned* blue,
-				unsigned* transp, struct fb_info* info) {
-	struct pm2fb_info* i=(struct pm2fb_info* )info;
-
-	if (regno<256) {
-		*red=i->palette[regno].red<<8|i->palette[regno].red;
-		*green=i->palette[regno].green<<8|i->palette[regno].green;
-		*blue=i->palette[regno].blue<<8|i->palette[regno].blue;
-		*transp=i->palette[regno].transp<<8|i->palette[regno].transp;
-	}
-	return regno>255;
-}
-
-static int pm2fb_setcolreg(unsigned regno,
-			unsigned red, unsigned green, unsigned blue,
-				unsigned transp, struct fb_info* info) {
-	struct pm2fb_info* i=(struct pm2fb_info* )info;
-
-	if (regno<16) {
-		switch (i->current_par.depth) {
-#ifdef FBCON_HAS_CFB8
-			case 8:
-				break;
-#endif
-#ifdef FBCON_HAS_CFB16
-			case 16:
-				i->cmap.cmap16[regno]=
-					((u32 )red & 0xf800) |
-					(((u32 )green & 0xfc00)>>5) |
-					(((u32 )blue & 0xf800)>>11);
-				break;
-#endif
-#ifdef FBCON_HAS_CFB24
-			case 24:
-				i->cmap.cmap24[regno]=
-					(((u32 )blue & 0xff00) << 8) |
-					((u32 )green & 0xff00) |
-					(((u32 )red & 0xff00) >> 8);
-				break;
-#endif
-#ifdef FBCON_HAS_CFB32
-			case 32:
-	   			i->cmap.cmap32[regno]=
-					(((u32 )transp & 0xff00) << 16) |
-		    			(((u32 )red & 0xff00) << 8) |
-					(((u32 )green & 0xff00)) |
-			 		(((u32 )blue & 0xff00) >> 8);
-				break;
-#endif
-			default:
-				DPRINTK("bad depth %u\n",
-						i->current_par.depth);
-				break;
-		}
-	}
-	if (regno<256) {
-		i->palette[regno].red=red >> 8;
-		i->palette[regno].green=green >> 8;
-		i->palette[regno].blue=blue >> 8;
-		i->palette[regno].transp=transp >> 8;
-		if (i->current_par.depth==8)
-			set_color(i, regno, red>>8, green>>8, blue>>8);
-	}
-	return regno>255;
-}
-
-static void pm2fb_set_disp(const void* par, struct display* disp,
-						struct fb_info_gen* info) {
-	struct pm2fb_info* i=(struct pm2fb_info* )info;
-	struct pm2fb_par* p=(struct pm2fb_par* )par;
-	unsigned long flags;
-
-	local_irq_save(flags);
-#ifdef __alpha__
-	disp->screen_base=i->regions.v_fb + dense_mem(i->regions.v_fb);
-#else
-	disp->screen_base=i->regions.v_fb;
-#endif
-	switch (p->depth) {
-#ifdef FBCON_HAS_CFB8
+		switch (info->var.bits_per_pixel) {
 		case 8:
-			if (p->flags & PM2FF_ACCEL)
-				disp->dispsw=&pm2_cfb8;
-			else
-				disp->dispsw=&fbcon_cfb8;
-			break;
-#endif
-#ifdef FBCON_HAS_CFB16
-		case 16:
-			if (p->flags & PM2FF_ACCEL)
-				disp->dispsw=&pm2_cfb16;
-			else
-				disp->dispsw=&fbcon_cfb16;
-			disp->dispsw_data=i->cmap.cmap16;
+			/* Yes some hand held devices have this. */ 
+           		((u8*)(info->pseudo_palette))[regno] = v;
+			break;	
+   		case 16:
+           		((u16*)(info->pseudo_palette))[regno] = v;
 			break;
-#endif
-#ifdef FBCON_HAS_CFB24
 		case 24:
-			if (p->flags & PM2FF_ACCEL)
-				disp->dispsw=&pm2_cfb24;
-			else
-				disp->dispsw=&fbcon_cfb24;
-			disp->dispsw_data=i->cmap.cmap24;
-			break;
-#endif
-#ifdef FBCON_HAS_CFB32
-		case 32:
-			if (p->flags & PM2FF_ACCEL)
-				disp->dispsw=&pm2_cfb32;
-			else
-				disp->dispsw=&fbcon_cfb32;
-			disp->dispsw_data=i->cmap.cmap32;
-			break;
-#endif
-		default:
-			disp->dispsw=&fbcon_dummy;
+		case 32:	
+           		((u32*)(info->pseudo_palette))[regno] = v;
 			break;
-	}
-	local_irq_restore(flags);
-}
-
-#ifdef PM2FB_HW_CURSOR
-/***************************************************************************
- * Hardware cursor support
- ***************************************************************************/
- 
-static u8 cursor_bits_lookup[16] = {
-	0x00, 0x40, 0x10, 0x50, 0x04, 0x44, 0x14, 0x54,
-	0x01, 0x41, 0x11, 0x51, 0x05, 0x45, 0x15, 0x55
-};
-
-static u8 cursor_mask_lookup[16] = {
-	0x00, 0x80, 0x20, 0xa0, 0x08, 0x88, 0x28, 0xa8,
-	0x02, 0x82, 0x22, 0xa2, 0x0a, 0x8a, 0x2a, 0xaa
-};
-
-static void pm2v_set_cursor_color(struct pm2fb_info *fb, u8 *red, u8 *green, u8 *blue)
-{
-	struct pm2_cursor *c = fb->cursor;
-	int i;
-
-	for (i = 0; i < 2; i++) {
-		c->color[3*i] = red[i];
-		c->color[3*i+1] = green[i];
-		c->color[3*i+2] = blue[i];
-	}
-
-	WAIT_FIFO(fb, 14);
-	pm2_WR(fb, PM2VR_RD_INDEX_HIGH, PM2VI_RD_CURSOR_PALETTE >> 8);
-	for (i = 0; i < 6; i++)
-		pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_PALETTE+i, c->color[i]);
-	pm2_WR(fb, PM2VR_RD_INDEX_HIGH, 0);
-}
-
-static void pm2v_set_cursor_shape(struct pm2fb_info *fb)
-{
-	struct pm2_cursor *c = fb->cursor;
-	u8 m, b;
-	int i, x, y;
-
-	WAIT_FIFO(fb, 1);
-	pm2_WR(fb, PM2VR_RD_INDEX_HIGH, PM2VI_RD_CURSOR_PATTERN >> 8);
-	for (y = 0, i = 0; y < c->size.y; y++) {
-		WAIT_FIFO(fb, 32);
-		for (x = 0; x < c->size.x >> 3; x++) {
-			m = c->mask[x][y];
-			b = c->bits[x][y];
-			pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_PATTERN + i,
-				     cursor_mask_lookup[m >> 4] |
-				     cursor_bits_lookup[(b & m) >> 4]);
-			pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_PATTERN + i + 1,
-				     cursor_mask_lookup[m & 0x0f] |
-				     cursor_bits_lookup[(b & m) & 0x0f]);
-			i+=2;
-		}
-		for ( ; x < 8; x++) {
-			pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_PATTERN + i, 0);
-			pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_PATTERN + i + 1, 0);
-			i+=2;
-		}
-	}
-	for (; y < 64; y++) {
-		WAIT_FIFO(fb, 32);
-		for (x = 0; x < 8; x++) {
-			pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_PATTERN + i, 0);
-			pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_PATTERN + i + 1, 0);
-			i+=2;
 		}
+		return 0;
 	}
-	WAIT_FIFO(fb, 1);
-	pm2_WR(fb, PM2VR_RD_INDEX_HIGH, 0);
+	/* ... */
+	return 0;
 }
 
-static void pm2v_set_cursor(struct pm2fb_info *fb, int on)
+/**
+ *      pm2fb_pan_display - Pans the display.
+ *      @var: frame buffer variable screen structure
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *	Pan (or wrap, depending on the `vmode' field) the display using the
+ *  	`xoffset' and `yoffset' fields of the `var' structure.
+ *  	If the values don't fit, return -EINVAL.
+ *
+ *      Returns negative errno on error, or zero on success.
+ *
+ */
+static int pm2fb_pan_display(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
 {
-	struct pm2_cursor *c = fb->cursor;
-	int x = c->pos.x;
+	struct pm2fb_par *p = (struct pm2fb_par *) info->par;
+	u32 base;
+	u32 depth;
+	u32 xres;
 
-	if (!on) x = 4000;
-	WAIT_FIFO(fb, 14);
-	pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_X_LOW, x & 0xff);
-	pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_X_HIGH, (x >> 8) & 0x0f);
-	pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_Y_LOW, c->pos.y & 0xff);
-	pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_Y_HIGH, (c->pos.y >> 8) & 0x0f);
-	pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_X_HOT, c->hot.x & 0x3f);
-	pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_Y_HOT, c->hot.y & 0x3f);
-	pm2v_RDAC_WR(fb, PM2VI_RD_CURSOR_MODE, 0x11);
+	xres = (var->xres + 31) & ~31;
+	depth = (var->bits_per_pixel + 7) & ~7;
+	depth = (depth > 32) ? 32 : depth;
+	base = to3264(var->yoffset * xres + var->xoffset, depth, 1);
+	WAIT_FIFO(p, 1);
+	pm2_WR(p, PM2R_SCREEN_BASE, base);    
+	return 0;
 }
 
-static void pm2_cursor_timer_handler(unsigned long dev_addr)
+/**
+ *      pm2fb_blank - Blanks the display.
+ *      @blank_mode: the blank mode we want. 
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *      Blank the screen if blank_mode != 0, else unblank. Return 0 if
+ *      blanking succeeded, != 0 if un-/blanking failed due to e.g. a 
+ *      video mode which doesn't support it. Implements VESA suspend
+ *      and powerdown modes on hardware that supports disabling hsync/vsync:
+ *      blank_mode == 2: suspend vsync
+ *      blank_mode == 3: suspend hsync
+ *      blank_mode == 4: powerdown
+ *
+ *      Returns negative errno on error, or zero on success.
+ *
+ */
+static int pm2fb_blank(int blank_mode, struct fb_info *info)
 {
-	struct pm2fb_info *fb = (struct pm2fb_info *)dev_addr;
+	struct pm2fb_par *par = (struct pm2fb_par *) info->par;
+	u32 video = par->video;
 
-	if (!fb->cursor->enable)
-		goto out;
-
-	if (fb->cursor->vbl_cnt && --fb->cursor->vbl_cnt == 0) {
-		fb->cursor->on ^= 1;
-		pm2v_set_cursor(fb, fb->cursor->on);
-		fb->cursor->vbl_cnt = fb->cursor->blink_rate;
+	switch (blank_mode) {
+	case 0: 	/* Screen: On; HSync: On, VSync: On */
+		break;
+	case 1: 	/* Screen: Off; HSync: On, VSync: On */
+		video &= ~PM2F_VIDEO_ENABLE;
+		break;
+	case 2: /* Screen: Off; HSync: On, VSync: Off */
+		video &= ~(PM2F_VIDEO_ENABLE | PM2F_VSYNC_MASK | PM2F_BLANK_LOW );
+		break;
+	case 3: /* Screen: Off; HSync: Off, VSync: On */
+		video &= ~(PM2F_VIDEO_ENABLE | PM2F_HSYNC_MASK | PM2F_BLANK_LOW );
+		break;
+	case 4: /* Screen: Off; HSync: Off, VSync: Off */
+		video &= ~(PM2F_VIDEO_ENABLE | PM2F_VSYNC_MASK | PM2F_HSYNC_MASK|
+			   PM2F_BLANK_LOW);
+		break;
 	}
-
-out:
-	fb->cursor->timer->expires = jiffies + (HZ / 50);
-	add_timer(fb->cursor->timer);
+	set_video(par, video);
+	return 0;
 }
 
-static void pm2fb_cursor(struct display *p, int mode, int x, int y)
-{
-	struct pm2fb_info *fb = (struct pm2fb_info *)p->fb_info;
-	struct pm2_cursor *c = fb->cursor;
+/* ------------ Hardware Independent Functions ------------ */
 
-	if (!c) return;
+/*
+ *  Frame buffer operations
+ */
 
-	x *= fontwidth(p);
-	y *= fontheight(p);
-	if (c->pos.x == x && c->pos.y == y && (mode == CM_ERASE) == !c->enable)
-		return;
+static struct fb_ops pm2fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= pm2fb_check_var,
+	.fb_set_par	= pm2fb_set_par,
+	.fb_setcolreg	= pm2fb_setcolreg,
+	.fb_blank	= pm2fb_blank,
+	.fb_pan_display	= pm2fb_pan_display,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_cursor	= soft_cursor,
+};
 
-	c->enable = 0;
-	if (c->on)
-		pm2v_set_cursor(fb, 0);
-	c->pos.x = x;
-	c->pos.y = y;
+/*
+ * PCI stuff
+ */
 
-	switch (mode) {
-	case CM_ERASE:
-		c->on = 0;
-		break;
 
-	case CM_DRAW:
-	case CM_MOVE:
-		if (c->on)
-			pm2v_set_cursor(fb, 1);
-		else
-			c->vbl_cnt = CURSOR_DRAW_DELAY;
-		c->enable = 1;
+/**
+ * Device initialisation
+ *
+ * Initialise and allocate resource for PCI device.
+ *
+ * @param	pdev	PCI device.
+ * @param	id	PCI device ID.
+ */
+static int __devinit pm2fb_probe(struct pci_dev *pdev,
+				 const struct pci_device_id *id)
+{
+	struct pm2fb_par *default_par;
+	struct fb_info *info;
+	int size, err;
+	u32 pci_mem_config;
+	int err_retval = -ENXIO;
+
+	err = pci_enable_device(pdev);
+	if ( err ) {
+		printk(KERN_WARNING "pm2fb: Can't enable pdev: %d\n", err);
+		return err;
+	}
+
+	size = sizeof(struct fb_info) + sizeof(struct pm2fb_par) + 256 * sizeof(u32);
+
+	info = framebuffer_alloc(size, &pdev->dev);
+	if ( !info )
+		return -ENOMEM;
+	memset(info, 0, size);
+    
+	default_par = info->par;
+ 
+	switch (pdev->device) {
+	case  PCI_DEVICE_ID_TI_TVP4020:
+		strcpy(pm2fb_fix.id, "TVP4020");
+		default_par->type = PM2_TYPE_PERMEDIA2;
+		break;
+	case  PCI_DEVICE_ID_3DLABS_PERMEDIA2:
+		strcpy(pm2fb_fix.id, "Permedia2");
+		default_par->type = PM2_TYPE_PERMEDIA2;
+		break;
+	case  PCI_DEVICE_ID_3DLABS_PERMEDIA2V:
+		strcpy(pm2fb_fix.id, "Permedia2v");
+		default_par->type = PM2_TYPE_PERMEDIA2V;
 		break;
 	}
-}
 
-static struct pm2_cursor * __init pm2_init_cursor(struct pm2fb_info *fb)
-{
-	struct pm2_cursor *cursor;
+	pm2fb_fix.mmio_start = pci_resource_start(pdev, 0);
+	pm2fb_fix.mmio_len = PM2_REGS_SIZE;
 
-	if (fb->type != PM2_TYPE_PERMEDIA2V)
-		return 0; /* FIXME: Support hw cursor everywhere */
+#ifdef PM2FB_BE_APERTURE
+	pm2fb_fix.mmio_start += PM2_REGS_SIZE;
+#endif
+    
+	/* Registers - request region and map it. */
+	if ( !request_mem_region(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len,
+				 "pm2fb regbase") ) {
+		printk(KERN_WARNING "pm2fb: Can't reserve regbase.\n");
+		goto err_exit_neither;
+	}
+	default_par->v_regs =
+		ioremap_nocache(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len);
+	if ( !default_par->v_regs ) {
+		printk(KERN_WARNING "pm2fb: Can't remap %s register area.\n",
+		       pm2fb_fix.id);
+		release_mem_region(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len);
+		goto err_exit_neither;
+	}
+
+	/* Now work out how big lfb is going to be. */
+	pci_mem_config = RD32(default_par->v_regs, PM2R_MEM_CONFIG);
+	switch(pci_mem_config & PM2F_MEM_CONFIG_RAM_MASK) {
+	case PM2F_MEM_BANKS_1:
+		default_par->fb_size=0x200000;
+		break;
+	case PM2F_MEM_BANKS_2:
+		default_par->fb_size=0x400000;
+		break;
+	case PM2F_MEM_BANKS_3:
+		default_par->fb_size=0x600000;
+		break;
+	case PM2F_MEM_BANKS_4:
+		default_par->fb_size=0x800000;
+		break;
+	}
+	default_par->memclock = CVPPC_MEMCLOCK;
+	pm2fb_fix.smem_start = pci_resource_start(pdev, 1);
+	pm2fb_fix.smem_len = default_par->fb_size;
+
+	/* Linear frame buffer - request region and map it. */
+	if ( !request_mem_region(pm2fb_fix.smem_start, pm2fb_fix.smem_len,
+				 "pm2fb smem") ) {
+		printk(KERN_WARNING "pm2fb: Can't reserve smem.\n");
+		goto err_exit_mmio;
+	}
+	info->screen_base = default_par->v_fb =
+		ioremap_nocache(pm2fb_fix.smem_start, pm2fb_fix.smem_len);
+	if ( !default_par->v_fb ) {
+		printk(KERN_WARNING "pm2fb: Can't ioremap smem area.\n");
+		release_mem_region(pm2fb_fix.smem_start, pm2fb_fix.smem_len);
+		goto err_exit_mmio;
+	}
+
+	info->fbops		= &pm2fb_ops;
+	info->fix		= pm2fb_fix; 	
+	info->par		= default_par;
+	info->pseudo_palette	= (void *)(default_par + 1); 
+	info->flags		= FBINFO_FLAG_DEFAULT;
+
+#ifndef MODULE
+	if (!mode)
+		mode = "640x480@60";
+	 
+	err = fb_find_mode(&info->var, info, mode, NULL, 0, NULL, 8); 
+	if (!err || err == 4)
+#endif
+		info->var = pm2fb_var;
 
-	cursor = kmalloc(sizeof(struct pm2_cursor), GFP_ATOMIC);
-	if (!cursor)
-		return 0;
-	memset(cursor, 0, sizeof(*cursor));
+	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0)
+		goto err_exit_all;
 
-	cursor->timer = kmalloc(sizeof(*cursor->timer), GFP_KERNEL);
-	if (!cursor->timer) {
-		kfree(cursor);
-		return 0;
-	}
-	memset(cursor->timer, 0, sizeof(*cursor->timer));
+	if (register_framebuffer(info) < 0)
+		goto err_exit_both;
 
-	cursor->blink_rate = DEFAULT_CURSOR_BLINK_RATE;
+	printk(KERN_INFO "fb%d: %s frame buffer device, memory = %dK.\n",
+	       info->node, info->fix.id, default_par->fb_size / 1024);
 
-	if (curblink) {
-		init_timer(cursor->timer);
-		cursor->timer->expires = jiffies + (HZ / 50);
-		cursor->timer->data = (unsigned long)fb;
-		cursor->timer->function = pm2_cursor_timer_handler;
-		add_timer(cursor->timer);
-	}
+	/*
+	 * Our driver data
+	 */
+	pci_set_drvdata(pdev, info);
+
+	return 0;
 
-	return cursor;
+ err_exit_all:
+	fb_dealloc_cmap(&info->cmap);	
+ err_exit_both:    
+	iounmap((void*) pm2fb_fix.smem_start);
+	release_mem_region(pm2fb_fix.smem_start, pm2fb_fix.smem_len);
+ err_exit_mmio:
+	iounmap((void*) pm2fb_fix.mmio_start);
+	release_mem_region(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len);
+ err_exit_neither:
+	framebuffer_release(info);
+	return err_retval;
 }
 
-static int pm2fb_set_font(struct display *d, int width, int height)
+/**
+ * Device removal.
+ *
+ * Release all device resources.
+ *
+ * @param	pdev	PCI device to clean up.
+ */
+static void __devexit pm2fb_remove(struct pci_dev *pdev)
 {
-	struct pm2fb_info *fb = (struct pm2fb_info *)d->fb_info;
-	struct pm2_cursor *c = fb->cursor;
-	int i, j;
+	struct fb_info* info = pci_get_drvdata(pdev);
+	struct fb_fix_screeninfo* fix = &info->fix;
+    
+	unregister_framebuffer(info);
+    
+	iounmap((void*) fix->smem_start);
+	release_mem_region(fix->smem_start, fix->smem_len);
+	iounmap((void*) fix->mmio_start);
+	release_mem_region(fix->mmio_start, fix->mmio_len);
 
-	if (c) {
-		if (!width || !height) {
-			width = 8;
-			height = 16;
-		}
+	pci_set_drvdata(pdev, NULL);
+	kfree(info);
+}
 
-		c->hot.x = 0;
-		c->hot.y = 0;
-		c->size.x = width;
-		c->size.y = height;
-
-		memset(c->bits, 0xff, sizeof(c->bits));
-		memset(c->mask, 0, sizeof(c->mask));
-
-		for (i = 0, j = width; j >= 0; j -= 8, i++) {
-			c->mask[i][height-2] = (j >= 8) ? 0xff : (0xff << (8 - j));
-			c->mask[i][height-1] = (j >= 8) ? 0xff : (0xff << (8 - j));
-		}
+static struct pci_device_id pm2fb_id_table[] = {
+	{ PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_TVP4020,
+	  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,
+	  0xff0000, 0 },
+	{ PCI_VENDOR_ID_3DLABS, PCI_DEVICE_ID_3DLABS_PERMEDIA2,
+	  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,
+	  0xff0000, 0 },
+	{ PCI_VENDOR_ID_3DLABS, PCI_DEVICE_ID_3DLABS_PERMEDIA2V,
+	  PCI_ANY_ID, PCI_ANY_ID, PCI_BASE_CLASS_DISPLAY << 16,
+	  0xff0000, 0 },
+	{ 0, }
+};
 
-		pm2v_set_cursor_color(fb, cursor_color_map, cursor_color_map, cursor_color_map);
-		pm2v_set_cursor_shape(fb);
-	}
-	return 1;
-}
-#endif /* PM2FB_HW_CURSOR */
+static struct pci_driver pm2fb_driver = {
+	.name		= "pm2fb",
+	.id_table 	= pm2fb_id_table,
+	.probe 		= pm2fb_probe,
+	.remove 	= __devexit_p(pm2fb_remove),
+};
 
-/***************************************************************************
- * Begin of public functions
- ***************************************************************************/
+MODULE_DEVICE_TABLE(pci, pm2fb_id_table);
 
-#ifdef MODULE
-static void pm2fb_cleanup(void) {
-	struct pm2fb_info* i=&fb_info;
 
-	unregister_framebuffer((struct fb_info* )info);
-	pm2fb_reset(i);
-	
- 	UNMAP(i->regions.v_fb, i->regions.fb_size);
- 	release_mem_region(i->regions.p_fb, i->regions.fb_size);
- 
- 	UNMAP(i->regions.v_regs, PM2_REGS_SIZE);
- 	release_mem_region(i->regions.p_regs, PM2_REGS_SIZE);
-	
-	if (board_table[i->board].cleanup)
-		board_table[i->board].cleanup(i);
+/*
+ *  Initialization
+ */
+
+int __init pm2fb_init(void)
+{
+	return pci_module_init(&pm2fb_driver);
 }
-#endif /* MODULE */
 
-int __init pm2fb_init(void) {
+/*
+ *  Cleanup
+ */
 
-	MOD_INC_USE_COUNT;
-	memset(&fb_info, 0, sizeof(fb_info));
-
-	if (!pm2fb_conf(&fb_info)) {
-		MOD_DEC_USE_COUNT;
-		return -ENXIO;
-	}
-
-        /* Pick up user_var settings if set. */
-	if ((pm2fb_options.flags & OPTF_USER_VAR) &&
-	    pm2fb_decode_var(&user_var, &pm2fb_options.user_mode,
-			     &fb_info.gen)<0) {
-		printk("pm2fb: user supplied var: mode is bad.\n");
-		memcpy(&pm2fb_options.user_mode,
-		       &user_mode[DEFAULT_USER_MODE].par,
-		       sizeof(struct pm2fb_par));
-	}
-	memcpy(&fb_info.current_par, &pm2fb_options.user_mode,
-					sizeof(fb_info.current_par));
-
-	pm2fb_reset(&fb_info);
-	fb_info.disp.scrollmode=SCROLL_YNOMOVE;
-	fb_info.gen.parsize=sizeof(struct pm2fb_par);
-	fb_info.gen.fbhw=&pm2fb_hwswitch;
-	strcpy(fb_info.gen.info.modename, permedia2_name);
-	fb_info.gen.info.flags=FBINFO_FLAG_DEFAULT;
-	fb_info.gen.info.fbops=&pm2fb_ops;
-	fb_info.gen.info.disp=&fb_info.disp;
-	strcpy(fb_info.gen.info.fontname, pm2fb_options.font);
-	fb_info.gen.info.switch_con=&fbgen_switch;
-	fb_info.gen.info.updatevar=&fbgen_update_var;
-
-	fbgen_get_var(&fb_info.disp.var, -1, &fb_info.gen.info);
-	fbgen_do_set_var(&fb_info.disp.var, 1, &fb_info.gen);
-	fbgen_set_disp(-1, &fb_info.gen);
-	fbgen_install_cmap(0, &fb_info.gen);
-
-	if (register_framebuffer(&fb_info.gen.info)<0) {
-		printk(KERN_ERR "pm2fb: unable to register.\n");
-		MOD_DEC_USE_COUNT;
-		return -EINVAL;
-	}
-	printk(KERN_INFO "fb%d: %s (%s), using %uK of video memory.\n",
-				fb_info.gen.info.node,
-				board_table[fb_info.board].name,
-				permedia2_name,
-				(u32 )(fb_info.regions.fb_size>>10));
-	return 0;
+static void __exit pm2fb_exit(void)
+{
+	pci_unregister_driver(&pm2fb_driver);
 }
 
-static void __init pm2fb_mode_setup(char* options) {
-	int i;
+/*
+ *  Setup
+ */
+
+/**
+ * Parse user speficied options.
+ *
+ * This is, comma-separated options following `video=pm2fb:'.
+ */
+int __init pm2fb_setup(char *options)
+{
+	char* this_opt;
 
-	for (i=0; user_mode[i].name[0] &&
-		strcmp(options, user_mode[i].name); i++);
-	if (user_mode[i].name[0]) {
-		memcpy(&pm2fb_options.user_mode, &user_mode[i].par,
-					sizeof(pm2fb_options.user_mode));
-		pm2fb_options.flags|=OPTF_USER;
-	}
-}
-
-static void __init pm2fb_font_setup(char* options) {
-	strlcpy(pm2fb_options.font, options, sizeof(pm2fb_options.font));
-}
-
-static void __init pm2fb_var_setup(char* options) {
-	char* next;
-
-	pm2fb_par2var(&user_var, &pm2fb_options.user_mode);
-
-	while (options) {
-		if ((next=strchr(options, ';')))
-			*(next++)='\0';
-		if (!strncmp(options, "bpp:", 4))
-			user_var.bits_per_pixel=
-				simple_strtoul(options+4, NULL, 0);
-		else if (!strncmp(options, "xres:", 5))
-			user_var.xres=simple_strtoul(options+5, NULL, 0);
-		else if (!strncmp(options, "yres:", 5))
-			user_var.yres=simple_strtoul(options+5, NULL, 0);
-		else if (!strncmp(options, "vxres:", 6))
-			user_var.xres_virtual=
-				simple_strtoul(options+6, NULL, 0);
-		else if (!strncmp(options, "vyres:", 6))
-			user_var.yres_virtual=
-				simple_strtoul(options+6, NULL, 0);
-		else if (!strncmp(options, "left:", 5))
-			user_var.left_margin=
-				simple_strtoul(options+5, NULL, 0);
-		else if (!strncmp(options, "right:", 6))
-			user_var.right_margin=
-				simple_strtoul(options+6, NULL, 0);
-		else if (!strncmp(options, "lower:", 6))
-			user_var.lower_margin=
-				simple_strtoul(options+6, NULL, 0);
-		else if (!strncmp(options, "upper:", 6))
-			user_var.upper_margin=
-				simple_strtoul(options+6, NULL, 0);
-		else if (!strncmp(options, "hslen:", 6))
-			user_var.hsync_len=simple_strtoul(options+6, NULL, 0);
-		else if (!strncmp(options, "vslen:", 6))
-			user_var.vsync_len=simple_strtoul(options+6, NULL, 0);
-		else if (!strncmp(options, "pixclock:", 9))
-			user_var.pixclock=simple_strtoul(options+9, NULL, 0);
-		else if (!strcmp(options, "+hsync"))
-			user_var.sync|=FB_SYNC_HOR_HIGH_ACT;
-		else if (!strcmp(options, "-hsync"))
-			user_var.sync&=~FB_SYNC_HOR_HIGH_ACT;
-		else if (!strcmp(options, "+vsync"))
-			user_var.sync|=FB_SYNC_VERT_HIGH_ACT;
-		else if (!strcmp(options, "-vsync"))
-			user_var.sync&=~FB_SYNC_VERT_HIGH_ACT;
-		else if (!strcmp(options, "+double"))
-			user_var.vmode|=FB_VMODE_DOUBLE;
-		else if (!strcmp(options, "-double"))
-			user_var.vmode&=~FB_VMODE_DOUBLE;
-		else if (!strcmp(options, "+accel"))
-			user_var.accel_flags|=FB_ACCELF_TEXT;
-		else if (!strcmp(options, "-accel"))
-			user_var.accel_flags&=~FB_ACCELF_TEXT;
-		options=next;
-	}
-	pm2fb_options.flags|=OPTF_USER_VAR;
-}
-
-int __init pm2fb_setup(char* options) {
-	char* next;
-
-	while (options) {
-		if ((next=strchr(options, ',')))
-			*(next++)='\0';
-		if (!strncmp(options, "font:", 5))
-			pm2fb_font_setup(options+5);
-		else if (!strncmp(options, "mode:", 5))
-			pm2fb_mode_setup(options+5);
-		else if (!strncmp(options, "var:", 4))
-			pm2fb_var_setup(options+4);
-		else if (!strcmp(options, "ypan"))
-			pm2fb_options.flags |= OPTF_YPAN;
-		else if (!strcmp(options, "oldmem"))
-			pm2fb_options.flags |= OPTF_OLD_MEM;
-		else if (!strcmp(options, "virtual"))
-			pm2fb_options.flags |= OPTF_VIRTUAL;
-		else if (!strcmp(options, "lowhsync"))
-			pm2fb_options.flags |= OPTF_LOW_HSYNC;
-		else if (!strcmp(options, "lowvsync"))
-			pm2fb_options.flags |= OPTF_LOW_VSYNC;
-		else if (!strcmp(options, "noblink"))
-			curblink=0;
-		options=next;
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {	
+		if (!*this_opt)
+			continue;
+		if(!strcmp(this_opt, "lowhsync")) {
+			lowhsync = 1;
+		} else if(!strcmp(this_opt, "lowvsync")) {
+			lowvsync = 1;
+		} else {
+			mode = this_opt;
+		}
 	}
-	user_var.activate=FB_ACTIVATE_NOW;
 	return 0;
 }
 
-/***************************************************************************
- * Begin of module functions
- ***************************************************************************/
-
-#ifdef MODULE
-
-MODULE_LICENSE("GPL");
 
-static char *mode = NULL;
+/* ------------------------------------------------------------------------- */
 
-MODULE_PARM(mode, "s");
+/* ------------------------------------------------------------------------- */
 
-int init_module(void) {
 
-	if (mode)
-		pm2fb_mode_setup(mode);
-	return pm2fb_init();
-}
 
-void cleanup_module(void) {
+#ifdef MODULE
+module_init(pm2fb_init);
+#endif 
+module_exit(pm2fb_exit);
 
-	pm2fb_cleanup();
-}
-#endif /* MODULE */
+MODULE_PARM(mode,"s");
+MODULE_PARM(lowhsync,"i");
+MODULE_PARM(lowvsync,"i");
 
-/***************************************************************************
- * That's all folks!
- ***************************************************************************/
+MODULE_AUTHOR("Jim Hague <jim.hague@acm.org>");
+MODULE_DESCRIPTION("Permedia2 framebuffer device driver");
+MODULE_LICENSE("GPL");
diff -purN linux-post-2.6.4rc1-20040303/fs/jfs/jfs_imap.c linux-2.6.4-rc2/fs/jfs/jfs_imap.c
--- linux-post-2.6.4rc1-20040303/fs/jfs/jfs_imap.c	2003-12-28 13:15:19.000000000 +0000
+++ linux-2.6.4-rc2/fs/jfs/jfs_imap.c	2004-02-26 14:51:20.000000000 +0000
@@ -2055,7 +2055,7 @@ static int diAllocExt(struct inomap * im
 static int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)
 {
 	int extno, bitno, agno, sword, rc;
-	struct metapage *amp, *bmp;
+	struct metapage *amp = NULL, *bmp = NULL;
 	struct iag *aiagp = 0, *biagp = 0;
 	u32 mask;
 
@@ -2065,8 +2065,6 @@ static int diAllocBit(struct inomap * im
 	 * it on the list.
 	 */
 	if (iagp->nfreeinos == cpu_to_le32(1)) {
-		amp = bmp = NULL;
-
 		if ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {
 			if ((rc =
 			     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),
diff -purN linux-post-2.6.4rc1-20040303/fs/jfs/jfs_incore.h linux-2.6.4-rc2/fs/jfs/jfs_incore.h
--- linux-post-2.6.4rc1-20040303/fs/jfs/jfs_incore.h	2003-09-05 11:31:52.000000000 +0000
+++ linux-2.6.4-rc2/fs/jfs/jfs_incore.h	2004-03-03 22:04:28.000000000 +0000
@@ -1,6 +1,6 @@
 /*
- *   Copyright (c) International Business Machines Corp., 2000-2003
- *   Portions Copyright (c) Christoph Hellwig, 2001-2002
+ *   Copyright (C) International Business Machines Corp., 2000-2004
+ *   Portions Copyright (C) Christoph Hellwig, 2001-2002
  *
  *   This program is free software;  you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -133,12 +133,14 @@ enum cflags {
  * JFS-private superblock information.
  */
 struct jfs_sb_info {
+	struct super_block *sb;		/* Point back to vfs super block */
 	unsigned long	mntflag;	/* aggregate attributes	*/
 	struct inode	*ipbmap;	/* block map inode		*/
 	struct inode	*ipaimap;	/* aggregate inode map inode	*/
 	struct inode	*ipaimap2;	/* secondary aimap inode	*/
 	struct inode	*ipimap;	/* aggregate inode map inode	*/
 	struct jfs_log	*log;		/* log			*/
+	struct list_head log_list;	/* volumes associated with a journal */
 	short		bsize;		/* logical block size	*/
 	short		l2bsize;	/* log2 logical block size	*/
 	short		nbperpage;	/* blocks per page		*/
diff -purN linux-post-2.6.4rc1-20040303/fs/jfs/jfs_logmgr.c linux-2.6.4-rc2/fs/jfs/jfs_logmgr.c
--- linux-post-2.6.4rc1-20040303/fs/jfs/jfs_logmgr.c	2004-02-19 03:42:22.000000000 +0000
+++ linux-2.6.4-rc2/fs/jfs/jfs_logmgr.c	2004-03-03 22:04:28.000000000 +0000
@@ -1,6 +1,6 @@
 /*
- *   Copyright (c) International Business Machines Corp., 2000-2003
- *   Portions Copyright (c) Christoph Hellwig, 2001-2002
+ *   Copyright (C) International Business Machines Corp., 2000-2004
+ *   Portions Copyright (C) Christoph Hellwig, 2001-2002
  *
  *   This program is free software;  you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -159,6 +159,13 @@ do {						\
 #define lbmDIRECT	0x0100
 
 /*
+ * Global list of active external journals
+ */
+LIST_HEAD(jfs_external_logs);
+struct jfs_log *dummy_log = NULL;
+DECLARE_MUTEX(jfs_log_sem);
+
+/*
  * external references
  */
 extern void txLazyUnlock(struct tblock * tblk);
@@ -172,8 +179,11 @@ static int lmWriteRecord(struct jfs_log 
 			 struct lrd * lrd, struct tlock * tlck);
 
 static int lmNextPage(struct jfs_log * log);
-static int lmLogFileSystem(struct jfs_log * log, char *uuid, int activate);
+static int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,
+			   int activate);
 
+static int open_inline_log(struct super_block *sb);
+static int open_dummy_log(struct super_block *sb);
 static int lbmLogInit(struct jfs_log * log);
 static void lbmLogShutdown(struct jfs_log * log);
 static struct lbuf *lbmAllocate(struct jfs_log * log, int);
@@ -962,19 +972,24 @@ int lmLogSync(struct jfs_log * log, int 
 	 * reset syncpt = sync
 	 */
 	if (log->sync != log->syncpt) {
-		struct super_block *sb = log->sb;
-		struct jfs_sb_info *sbi = JFS_SBI(sb);
+		struct jfs_sb_info *sbi;
 
 		/*
 		 * We need to make sure all of the "written" metapages
 		 * actually make it to disk
 		 */
-		filemap_fdatawrite(sbi->ipbmap->i_mapping);
-		filemap_fdatawrite(sbi->ipimap->i_mapping);
-		filemap_fdatawrite(sb->s_bdev->bd_inode->i_mapping);
-		filemap_fdatawait(sbi->ipbmap->i_mapping);
-		filemap_fdatawait(sbi->ipimap->i_mapping);
-		filemap_fdatawait(sb->s_bdev->bd_inode->i_mapping);
+		down(&jfs_log_sem);
+		list_for_each_entry(sbi, &log->sb_list, log_list) {
+			filemap_fdatawrite(sbi->ipbmap->i_mapping);
+			filemap_fdatawrite(sbi->ipimap->i_mapping);
+			filemap_fdatawrite(sbi->sb->s_bdev->bd_inode->i_mapping);
+		}
+		list_for_each_entry(sbi, &log->sb_list, log_list) {
+			filemap_fdatawait(sbi->ipbmap->i_mapping);
+			filemap_fdatawait(sbi->ipimap->i_mapping);
+			filemap_fdatawait(sbi->sb->s_bdev->bd_inode->i_mapping);
+		}
+		up(&jfs_log_sem);
 
 		lrd.logtid = 0;
 		lrd.backchain = 0;
@@ -1061,51 +1076,53 @@ int lmLogSync(struct jfs_log * log, int 
  *
  * serialization:
  */
-int lmLogOpen(struct super_block *sb, struct jfs_log ** logptr)
+int lmLogOpen(struct super_block *sb)
 {
 	int rc;
 	struct block_device *bdev;
 	struct jfs_log *log;
+	struct jfs_sb_info *sbi = JFS_SBI(sb);
 
-	if (!(log = kmalloc(sizeof(struct jfs_log), GFP_KERNEL)))
-		return -ENOMEM;
-	memset(log, 0, sizeof(struct jfs_log));
-	init_waitqueue_head(&log->syncwait);
-
-	log->sb = sb;		/* This should be a list */
-
-	if (!(JFS_SBI(sb)->mntflag & JFS_INLINELOG))
-		goto externalLog;
-
-	/*
-	 *      in-line log in host file system
-	 *
-	 * file system to log have 1-to-1 relationship;
-	 */
+	if (sbi->flag & JFS_NOINTEGRITY)
+		return open_dummy_log(sb);
+	
+	if (sbi->mntflag & JFS_INLINELOG)
+		return open_inline_log(sb);
 
-	set_bit(log_INLINELOG, &log->flag);
-	log->bdev = sb->s_bdev;
-	log->base = addressPXD(&JFS_SBI(sb)->logpxd);
-	log->size = lengthPXD(&JFS_SBI(sb)->logpxd) >>
-	    (L2LOGPSIZE - sb->s_blocksize_bits);
-	log->l2bsize = sb->s_blocksize_bits;
-	ASSERT(L2LOGPSIZE >= sb->s_blocksize_bits);
+	down(&jfs_log_sem);
+	list_for_each_entry(log, &jfs_external_logs, journal_list) {
+		if (log->bdev->bd_dev == sbi->logdev) {
+			if (memcmp(log->uuid, sbi->loguuid,
+				   sizeof(log->uuid))) {
+				jfs_warn("wrong uuid on JFS journal\n");
+				up(&jfs_log_sem);
+				return -EINVAL;
+			}
+			/*
+			 * add file system to log active file system list
+			 */
+			if ((rc = lmLogFileSystem(log, sbi, 1))) {
+				up(&jfs_log_sem);
+				return rc;
+			}
+			goto journal_found;
+		}
+	}
 
-	/*
-	 * initialize log.
-	 */
-	if ((rc = lmLogInit(log)))
-		goto free;
-	goto out;
+	if (!(log = kmalloc(sizeof(struct jfs_log), GFP_KERNEL))) {
+		up(&jfs_log_sem);
+		return -ENOMEM;
+	}
+	memset(log, 0, sizeof(struct jfs_log));
+	INIT_LIST_HEAD(&log->sb_list);
 
 	/*
 	 *      external log as separate logical volume
 	 *
 	 * file systems to log may have n-to-1 relationship;
 	 */
-      externalLog:
 
-	bdev = open_by_devnum(JFS_SBI(sb)->logdev, FMODE_READ|FMODE_WRITE);
+	bdev = open_by_devnum(sbi->logdev, FMODE_READ|FMODE_WRITE);
 	if (IS_ERR(bdev)) {
 		rc = -PTR_ERR(bdev);
 		goto free;
@@ -1116,7 +1133,7 @@ int lmLogOpen(struct super_block *sb, st
 	}
 
 	log->bdev = bdev;
-	memcpy(log->uuid, JFS_SBI(sb)->loguuid, sizeof(log->uuid));
+	memcpy(log->uuid, sbi->loguuid, sizeof(log->uuid));
 	
 	/*
 	 * initialize log:
@@ -1124,20 +1141,26 @@ int lmLogOpen(struct super_block *sb, st
 	if ((rc = lmLogInit(log)))
 		goto unclaim;
 
+	list_add(&log->journal_list, &jfs_external_logs);
+
 	/*
 	 * add file system to log active file system list
 	 */
-	if ((rc = lmLogFileSystem(log, JFS_SBI(sb)->uuid, 1)))
+	if ((rc = lmLogFileSystem(log, sbi, 1)))
 		goto shutdown;
 
-      out:
-	*logptr = log;
+journal_found:
+	list_add(&sbi->log_list, &log->sb_list);
+	sbi->log = log;
+
+	up(&jfs_log_sem);
 	return 0;
 
 	/*
 	 *      unwind on error
 	 */
       shutdown:		/* unwind lbmLogInit() */
+	list_del(&log->journal_list);
 	lbmLogShutdown(log);
 
       unclaim:
@@ -1147,12 +1170,78 @@ int lmLogOpen(struct super_block *sb, st
 	blkdev_put(bdev);
 
       free:		/* free log descriptor */
+	up(&jfs_log_sem);
 	kfree(log);
 
 	jfs_warn("lmLogOpen: exit(%d)", rc);
 	return rc;
 }
 
+static int open_inline_log(struct super_block *sb)
+{
+	struct jfs_log *log;
+	int rc;
+
+	if (!(log = kmalloc(sizeof(struct jfs_log), GFP_KERNEL)))
+		return -ENOMEM;
+	memset(log, 0, sizeof(struct jfs_log));
+	INIT_LIST_HEAD(&log->sb_list);
+
+	set_bit(log_INLINELOG, &log->flag);
+	log->bdev = sb->s_bdev;
+	log->base = addressPXD(&JFS_SBI(sb)->logpxd);
+	log->size = lengthPXD(&JFS_SBI(sb)->logpxd) >>
+	    (L2LOGPSIZE - sb->s_blocksize_bits);
+	log->l2bsize = sb->s_blocksize_bits;
+	ASSERT(L2LOGPSIZE >= sb->s_blocksize_bits);
+
+	/*
+	 * initialize log.
+	 */
+	if ((rc = lmLogInit(log))) {
+		kfree(log);
+		jfs_warn("lmLogOpen: exit(%d)", rc);
+		return rc;
+	}
+
+	list_add(&JFS_SBI(sb)->log_list, &log->sb_list);
+	JFS_SBI(sb)->log = log;
+
+	return rc;
+}
+
+static int open_dummy_log(struct super_block *sb)
+{
+	int rc;
+
+	down(&jfs_log_sem);
+	if (!dummy_log) {
+		dummy_log = kmalloc(sizeof(struct jfs_log), GFP_KERNEL);
+		if (!dummy_log) {
+			up(&jfs_log_sem);
+			return -ENOMEM;
+		}
+		memset(dummy_log, 0, sizeof(struct jfs_log));
+		INIT_LIST_HEAD(&dummy_log->sb_list);
+		dummy_log->no_integrity = 1;
+		/* Make up some stuff */
+		dummy_log->base = 0;
+		dummy_log->size = 1024;
+		rc = lmLogInit(dummy_log);
+		if (rc) {
+			kfree(dummy_log);
+			dummy_log = NULL;
+			up(&jfs_log_sem);
+			return rc;
+		}
+	}
+
+	list_add(&JFS_SBI(sb)->log_list, &dummy_log->sb_list);
+	JFS_SBI(sb)->log = dummy_log;
+	up(&jfs_log_sem);
+
+	return 0;
+}
 
 /*
  * NAME:	lmLogInit()
@@ -1160,7 +1249,7 @@ int lmLogOpen(struct super_block *sb, st
  * FUNCTION:	log initialization at first log open.
  *
  *	logredo() (or logformat()) should have been run previously.
- *	initialize the log inode from log superblock.
+ *	initialize the log from log superblock.
  *	set the log state in the superblock to LOGMOUNT and
  *	write SYNCPT log record.
  *		
@@ -1180,14 +1269,26 @@ int lmLogInit(struct jfs_log * log)
 	struct lbuf *bpsuper;
 	struct lbuf *bp;
 	struct logpage *lp;
-	int lsn;
+	int lsn = 0;
 
 	jfs_info("lmLogInit: log:0x%p", log);
 
-	/*
-	 * log inode is overlaid on generic inode where
-	 * dinode have been zeroed out by iRead();
-	 */
+	/* initialize the group commit serialization lock */
+	LOGGC_LOCK_INIT(log);
+
+	/* allocate/initialize the log write serialization lock */
+	LOG_LOCK_INIT(log);
+
+	LOGSYNC_LOCK_INIT(log);
+
+	INIT_LIST_HEAD(&log->synclist);
+
+	init_waitqueue_head(&log->syncwait);
+
+	log->cqueue.head = log->cqueue.tail = NULL;
+	log->flush_tblk = NULL;
+
+	log->count = 0;
 
 	/*
 	 * initialize log i/o
@@ -1195,111 +1296,121 @@ int lmLogInit(struct jfs_log * log)
 	if ((rc = lbmLogInit(log)))
 		return rc;
 
-	/*
-	 * validate log superblock
-	 */
 	if (!test_bit(log_INLINELOG, &log->flag))
-		log->l2bsize = 12;	/* XXX kludge alert XXX */
-	if ((rc = lbmRead(log, 1, &bpsuper)))
-		goto errout10;
+		log->l2bsize = L2LOGPSIZE;
+	
+	/* check for disabled journaling to disk */
+	if (log->no_integrity) {
+		/*
+		 * Journal pages will still be filled.  When the time comes
+		 * to actually do the I/O, the write is not done, and the
+		 * endio routine is called directly.
+		 */
+		bp = lbmAllocate(log , 0);
+		log->bp = bp;
+		bp->l_pn = bp->l_eor = 0;
+	} else {
+		/*
+		 * validate log superblock
+		 */
+		if ((rc = lbmRead(log, 1, &bpsuper)))
+			goto errout10;
 
-	logsuper = (struct logsuper *) bpsuper->l_ldata;
+		logsuper = (struct logsuper *) bpsuper->l_ldata;
 
-	if (logsuper->magic != cpu_to_le32(LOGMAGIC)) {
-		jfs_warn("*** Log Format Error ! ***");
-		rc = -EINVAL;
-		goto errout20;
-	}
-
-	/* logredo() should have been run successfully. */
-	if (logsuper->state != cpu_to_le32(LOGREDONE)) {
-		jfs_warn("*** Log Is Dirty ! ***");
-		rc = -EINVAL;
-		goto errout20;
-	}
-
-	/* initialize log inode from log superblock */
-	if (test_bit(log_INLINELOG,&log->flag)) {
-		if (log->size != le32_to_cpu(logsuper->size)) {
+		if (logsuper->magic != cpu_to_le32(LOGMAGIC)) {
+			jfs_warn("*** Log Format Error ! ***");
 			rc = -EINVAL;
 			goto errout20;
 		}
-		jfs_info("lmLogInit: inline log:0x%p base:0x%Lx size:0x%x",
-			log, (unsigned long long) log->base, log->size);
-	} else {
-		if (memcmp(logsuper->uuid, log->uuid, 16)) {
-			jfs_warn("wrong uuid on JFS log device");
+
+		/* logredo() should have been run successfully. */
+		if (logsuper->state != cpu_to_le32(LOGREDONE)) {
+			jfs_warn("*** Log Is Dirty ! ***");
+			rc = -EINVAL;
 			goto errout20;
 		}
-		log->size = le32_to_cpu(logsuper->size);
-		log->l2bsize = le32_to_cpu(logsuper->l2bsize);
-		jfs_info("lmLogInit: external log:0x%p base:0x%Lx size:0x%x",
-			log, (unsigned long long) log->base, log->size);
-	}
 
-	log->page = le32_to_cpu(logsuper->end) / LOGPSIZE;
-	log->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);
+		/* initialize log from log superblock */
+		if (test_bit(log_INLINELOG,&log->flag)) {
+			if (log->size != le32_to_cpu(logsuper->size)) {
+				rc = -EINVAL;
+				goto errout20;
+			}
+			jfs_info("lmLogInit: inline log:0x%p base:0x%Lx "
+				 "size:0x%x", log,
+				 (unsigned long long) log->base, log->size);
+		} else {
+			if (memcmp(logsuper->uuid, log->uuid, 16)) {
+				jfs_warn("wrong uuid on JFS log device");
+				goto errout20;
+			}
+			log->size = le32_to_cpu(logsuper->size);
+			log->l2bsize = le32_to_cpu(logsuper->l2bsize);
+			jfs_info("lmLogInit: external log:0x%p base:0x%Lx "
+				 "size:0x%x", log,
+				 (unsigned long long) log->base, log->size);
+		}
 
-	/* check for disabled journaling to disk */
-	if (JFS_SBI(log->sb)->flag & JFS_NOINTEGRITY) {
-		log->no_integrity = 1;
-		log->ni_page = log->page;
-		log->ni_eor = log->eor;
-	}
-	else
-		log->no_integrity = 0;
+		log->page = le32_to_cpu(logsuper->end) / LOGPSIZE;
+		log->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);
 
-	/*
-	 * initialize for log append write mode
-	 */
-	/* establish current/end-of-log page/buffer */
-	if ((rc = lbmRead(log, log->page, &bp)))
-		goto errout20;
+		/*
+		 * initialize for log append write mode
+		 */
+		/* establish current/end-of-log page/buffer */
+		if ((rc = lbmRead(log, log->page, &bp)))
+			goto errout20;
 
-	lp = (struct logpage *) bp->l_ldata;
+		lp = (struct logpage *) bp->l_ldata;
 
-	jfs_info("lmLogInit: lsn:0x%x page:%d eor:%d:%d",
-		 le32_to_cpu(logsuper->end), log->page, log->eor,
-		 le16_to_cpu(lp->h.eor));
-
-//      ASSERT(log->eor == lp->h.eor);
-
-	log->bp = bp;
-	bp->l_pn = log->page;
-	bp->l_eor = log->eor;
+		jfs_info("lmLogInit: lsn:0x%x page:%d eor:%d:%d",
+			 le32_to_cpu(logsuper->end), log->page, log->eor,
+			 le16_to_cpu(lp->h.eor));
 
-	/* initialize the group commit serialization lock */
-	LOGGC_LOCK_INIT(log);
+		/* if current page is full, move on to next page */
+		if (log->eor >= LOGPSIZE - LOGPTLRSIZE)
+			lmNextPage(log);
 
-	/* if current page is full, move on to next page */
-	if (log->eor >= LOGPSIZE - LOGPTLRSIZE)
-		lmNextPage(log);
+		log->bp = bp;
+		bp->l_pn = log->page;
+		bp->l_eor = log->eor;
 
-	/* allocate/initialize the log write serialization lock */
-	LOG_LOCK_INIT(log);
 
-	/*
-	 * initialize log syncpoint
-	 */
-	/*
-	 * write the first SYNCPT record with syncpoint = 0
-	 * (i.e., log redo up to HERE !);
-	 * remove current page from lbm write queue at end of pageout
-	 * (to write log superblock update), but do not release to freelist;
-	 */
-	lrd.logtid = 0;
-	lrd.backchain = 0;
-	lrd.type = cpu_to_le16(LOG_SYNCPT);
-	lrd.length = 0;
-	lrd.log.syncpt.sync = 0;
-	lsn = lmWriteRecord(log, NULL, &lrd, NULL);
-	bp = log->bp;
-	bp->l_ceor = bp->l_eor;
-	lp = (struct logpage *) bp->l_ldata;
-	lp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);
-	lbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);
-	if ((rc = lbmIOWait(bp, 0)))
-		goto errout30;
+		/*
+		 * initialize log syncpoint
+		 */
+		/*
+		 * write the first SYNCPT record with syncpoint = 0
+		 * (i.e., log redo up to HERE !);
+		 * remove current page from lbm write queue at end of pageout
+		 * (to write log superblock update), but do not release to
+		 * freelist;
+		 */
+		lrd.logtid = 0;
+		lrd.backchain = 0;
+		lrd.type = cpu_to_le16(LOG_SYNCPT);
+		lrd.length = 0;
+		lrd.log.syncpt.sync = 0;
+		lsn = lmWriteRecord(log, NULL, &lrd, NULL);
+		bp = log->bp;
+		bp->l_ceor = bp->l_eor;
+		lp = (struct logpage *) bp->l_ldata;
+		lp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);
+		lbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);
+		if ((rc = lbmIOWait(bp, 0)))
+			goto errout30;
+
+		/*
+		 * update/write superblock
+		 */
+		logsuper->state = cpu_to_le32(LOGMOUNT);
+		log->serial = le32_to_cpu(logsuper->serial) + 1;
+		logsuper->serial = cpu_to_le32(log->serial);
+		lbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);
+		if ((rc = lbmIOWait(bpsuper, lbmFREE)))
+			goto errout30;
+	}
 
 	/* initialize logsync parameters */
 	log->logsize = (log->size - 2) << L2LOGPSIZE;
@@ -1311,30 +1422,11 @@ int lmLogInit(struct jfs_log * log)
 	jfs_info("lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x",
 		 log->lsn, log->syncpt, log->sync);
 
-	LOGSYNC_LOCK_INIT(log);
-
-	INIT_LIST_HEAD(&log->synclist);
-
-	log->cqueue.head = log->cqueue.tail = NULL;
-	log->flush_tblk = NULL;
-
-	log->count = 0;
-
 	/*
 	 * initialize for lazy/group commit
 	 */
 	log->clsn = lsn;
 
-	/*
-	 * update/write superblock
-	 */
-	logsuper->state = cpu_to_le32(LOGMOUNT);
-	log->serial = le32_to_cpu(logsuper->serial) + 1;
-	logsuper->serial = cpu_to_le32(log->serial);
-	lbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);
-	if ((rc = lbmIOWait(bpsuper, lbmFREE)))
-		goto errout30;
-
 	return 0;
 
 	/*
@@ -1361,39 +1453,66 @@ int lmLogInit(struct jfs_log * log)
  *		and close it on last close.
  *
  * PARAMETER:	sb	- superblock
- *		log	- log inode
  *
  * RETURN:	errors from subroutines
  *
  * serialization:
  */
-int lmLogClose(struct super_block *sb, struct jfs_log * log)
+int lmLogClose(struct super_block *sb)
 {
-	struct block_device *bdev = log->bdev;
-	int rc;
+	struct jfs_sb_info *sbi = JFS_SBI(sb);
+	struct jfs_log *log = sbi->log;
+	struct block_device *bdev;
+	int rc = 0;
 
 	jfs_info("lmLogClose: log:0x%p", log);
 
-	if (!test_bit(log_INLINELOG, &log->flag))
-		goto externalLog;
-	
+	down(&jfs_log_sem);
+	list_del(&sbi->log_list);
+	sbi->log = NULL;
+
 	/*
-	 *      in-line log in host file system
+	 * We need to make sure all of the "written" metapages
+	 * actually make it to disk
 	 */
-	rc = lmLogShutdown(log);
-	goto out;
+	sync_blockdev(sb->s_bdev);
+
+	if (test_bit(log_INLINELOG, &log->flag)) {
+		/*
+		 *      in-line log in host file system
+		 */
+		rc = lmLogShutdown(log);
+		goto out;
+	}
+
+	if (!log->no_integrity)
+		lmLogFileSystem(log, sbi, 0);
+
+	if (!list_empty(&log->sb_list))
+		goto out;
+
+	/*
+	 * TODO: ensure that the dummy_log is in a state to allow
+	 * lbmLogShutdown to deallocate all the buffers and call
+	 * kfree against dummy_log.  For now, leave dummy_log & its
+	 * buffers in memory, and resuse if another no-integrity mount
+	 * is requested.
+	 */
+	if (log->no_integrity)
+		goto out;
 
 	/*
 	 *      external log as separate logical volume
 	 */
-      externalLog:
-	lmLogFileSystem(log, JFS_SBI(sb)->uuid, 0);
+	list_del(&log->journal_list);
+	bdev = log->bdev;
 	rc = lmLogShutdown(log);
 
 	bd_release(bdev);
 	blkdev_put(bdev);
 
       out:
+	up(&jfs_log_sem);
 	jfs_info("lmLogClose: exit(%d)", rc);
 	return rc;
 }
@@ -1522,12 +1641,6 @@ int lmLogShutdown(struct jfs_log * log)
 	jfs_flush_journal(log, 2);
 
 	/*
-	 * We need to make sure all of the "written" metapages
-	 * actually make it to disk
-	 */
-	sync_blockdev(log->sb->s_bdev);
-
-	/*
 	 * write the last SYNCPT record with syncpoint = 0
 	 * (i.e., log redo up to HERE !)
 	 */
@@ -1537,13 +1650,6 @@ int lmLogShutdown(struct jfs_log * log)
 	lrd.length = 0;
 	lrd.log.syncpt.sync = 0;
 	
-	/* check for disabled journaling to disk */
-	if (JFS_SBI(log->sb)->flag & JFS_NOINTEGRITY) {
-		log->no_integrity = 0;
-		log->page = log->ni_page;
-		log->eor = log->ni_eor;
-	}
-
 	lsn = lmWriteRecord(log, NULL, &lrd, NULL);
 	bp = log->bp;
 	lp = (struct logpage *) bp->l_ldata;
@@ -1595,12 +1701,14 @@ int lmLogShutdown(struct jfs_log * log)
  * RETURN:	0	- success
  *		errors returned by vms_iowait().
  */
-static int lmLogFileSystem(struct jfs_log * log, char *uuid, int activate)
+static int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,
+			   int activate)
 {
 	int rc = 0;
 	int i;
 	struct logsuper *logsuper;
 	struct lbuf *bpsuper;
+	char *uuid = sbi->uuid;
 
 	/*
 	 * insert/remove file system device to log active file system list.
@@ -1613,6 +1721,7 @@ static int lmLogFileSystem(struct jfs_lo
 		for (i = 0; i < MAX_ACTIVE; i++)
 			if (!memcmp(logsuper->active[i].uuid, NULL_UUID, 16)) {
 				memcpy(logsuper->active[i].uuid, uuid, 16);
+				sbi->aggregate = i;
 				break;
 			}
 		if (i == MAX_ACTIVE) {
@@ -2251,7 +2360,7 @@ int jfsIOWait(void *arg)
 int lmLogFormat(struct jfs_log *log, s64 logAddress, int logSize)
 {
 	int rc = -EIO;
-	struct jfs_sb_info *sbi = JFS_SBI(log->sb);
+	struct jfs_sb_info *sbi;
 	struct logsuper *logsuper;
 	struct logpage *lp;
 	int lspn;		/* log sequence page number */
@@ -2262,6 +2371,8 @@ int lmLogFormat(struct jfs_log *log, s64
 	jfs_info("lmLogFormat: logAddress:%Ld logSize:%d",
 		 (long long)logAddress, logSize);
 
+	sbi = list_entry(log->sb_list.next, struct jfs_sb_info, log_list);
+
 	/* allocate a log buffer */
 	bp = lbmAllocate(log, 1);
 
diff -purN linux-post-2.6.4rc1-20040303/fs/jfs/jfs_logmgr.h linux-2.6.4-rc2/fs/jfs/jfs_logmgr.h
--- linux-post-2.6.4rc1-20040303/fs/jfs/jfs_logmgr.h	2003-07-09 15:29:24.000000000 +0000
+++ linux-2.6.4-rc2/fs/jfs/jfs_logmgr.h	2004-03-03 22:04:28.000000000 +0000
@@ -1,6 +1,6 @@
 /*
- *   Copyright (c) International Business Machines Corp., 2000-2003
- *   Portions Copyright (c) Christoph Hellwig, 2001-2002
+ *   Copyright (C) International Business Machines Corp., 2000-2004
+ *   Portions Copyright (C) Christoph Hellwig, 2001-2002
  *
  *   This program is free software;  you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -367,11 +367,10 @@ struct lvd {
  */
 struct jfs_log {
 
-	struct super_block *sb;	/* 4: This is used to sync metadata
-				 *    before writing syncpt.  Will
-				 *    need to be a list if we share
-				 *    the log between fs's
+	struct list_head sb_list;/*  This is used to sync metadata
+				 *    before writing syncpt.
 				 */
+	struct list_head journal_list; /* Global list */
 	struct block_device *bdev; /* 4: log lv pointer */
 	s32 serial;		/* 4: log mount serial number */
 
@@ -419,8 +418,6 @@ struct jfs_log {
 	char uuid[16];		/* 16: 128-bit uuid of log device */
 
 	int no_integrity;	/* 3: flag to disable journaling to disk */
-	int ni_page;		/* 4: backup of page for nointegrity option */
-	int ni_eor;		/* 4: backup of eor for nointegrity option */
 };
 
 /*
@@ -506,8 +503,8 @@ struct logsyncblk {
 		diff += (log)->logsize;\
 }
 
-extern int lmLogOpen(struct super_block *sb, struct jfs_log ** log);
-extern int lmLogClose(struct super_block *sb, struct jfs_log * log);
+extern int lmLogOpen(struct super_block *sb);
+extern int lmLogClose(struct super_block *sb);
 extern int lmLogSync(struct jfs_log * log, int nosyncwait);
 extern int lmLogShutdown(struct jfs_log * log);
 extern int lmLogInit(struct jfs_log * log);
diff -purN linux-post-2.6.4rc1-20040303/fs/jfs/jfs_mount.c linux-2.6.4-rc2/fs/jfs/jfs_mount.c
--- linux-post-2.6.4rc1-20040303/fs/jfs/jfs_mount.c	2003-09-23 04:16:30.000000000 +0000
+++ linux-2.6.4-rc2/fs/jfs/jfs_mount.c	2004-03-03 22:04:28.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *   Copyright (c) International Business Machines Corp., 2000-2003
+ *   Copyright (C) International Business Machines Corp., 2000-2004
  *
  *   This program is free software;  you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -242,7 +242,6 @@ int jfs_mount(struct super_block *sb)
 int jfs_mount_rw(struct super_block *sb, int remount)
 {
 	struct jfs_sb_info *sbi = JFS_SBI(sb);  
-	struct jfs_log *log;
 	int rc;
 
 	/*
@@ -272,18 +271,15 @@ int jfs_mount_rw(struct super_block *sb,
 	/*
 	 * open/initialize log
 	 */
-	if ((rc = lmLogOpen(sb, &log)))
+	if ((rc = lmLogOpen(sb)))
 		return rc;
 
-	JFS_SBI(sb)->log = log;
-
 	/*
 	 * update file system superblock;
 	 */
 	if ((rc = updateSuper(sb, FM_MOUNT))) {
 		jfs_err("jfs_mount: updateSuper failed w/rc = %d", rc);
-		lmLogClose(sb, log);
-		JFS_SBI(sb)->log = 0;
+		lmLogClose(sb);
 		return rc;
 	}
 
diff -purN linux-post-2.6.4rc1-20040303/fs/jfs/jfs_txnmgr.c linux-2.6.4-rc2/fs/jfs/jfs_txnmgr.c
--- linux-post-2.6.4rc1-20040303/fs/jfs/jfs_txnmgr.c	2004-02-10 21:32:21.000000000 +0000
+++ linux-2.6.4-rc2/fs/jfs/jfs_txnmgr.c	2004-03-03 22:04:28.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *   Copyright (C) International Business Machines Corp., 2000-2003
+ *   Copyright (C) International Business Machines Corp., 2000-2004
  *   Portions Copyright (C) Christoph Hellwig, 2001-2002
  *
  *   This program is free software;  you can redistribute it and/or modify
@@ -1354,7 +1354,7 @@ static int txLog(struct jfs_log * log, s
 
 		/* initialize lrd common */
 		ip = tlck->ip;
-		lrd->aggregate = cpu_to_le32(new_encode_dev(ip->i_sb->s_bdev->bd_dev));
+		lrd->aggregate = cpu_to_le32(JFS_SBI(ip->i_sb)->aggregate);
 		lrd->log.redopage.fileset = cpu_to_le32(JFS_IP(ip)->fileset);
 		lrd->log.redopage.inode = cpu_to_le32(ip->i_ino);
 
diff -purN linux-post-2.6.4rc1-20040303/fs/jfs/jfs_umount.c linux-2.6.4-rc2/fs/jfs/jfs_umount.c
--- linux-post-2.6.4rc1-20040303/fs/jfs/jfs_umount.c	2003-02-17 18:08:54.000000000 +0000
+++ linux-2.6.4-rc2/fs/jfs/jfs_umount.c	2004-03-03 22:04:28.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *   Copyright (c) International Business Machines Corp., 2000-2002
+ *   Copyright (C) International Business Machines Corp., 2000-2004
  *
  *   This program is free software;  you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -128,7 +128,7 @@ int jfs_umount(struct super_block *sb)
 		 *
 		 * remove file system from log active file system list.
 		 */
-		rc = lmLogClose(sb, log);
+		rc = lmLogClose(sb);
 	}
 	jfs_info("UnMount JFS Complete: rc = %d", rc);
 	return rc;
@@ -167,7 +167,6 @@ int jfs_umount_rw(struct super_block *sb
 	filemap_fdatawait(bdev_mapping);
 
 	updateSuper(sb, FM_CLEAN);
-	sbi->log = NULL;
 
-	return lmLogClose(sb, log);
+	return lmLogClose(sb);
 }
diff -purN linux-post-2.6.4rc1-20040303/fs/jfs/super.c linux-2.6.4-rc2/fs/jfs/super.c
--- linux-post-2.6.4rc1-20040303/fs/jfs/super.c	2004-02-12 15:23:49.000000000 +0000
+++ linux-2.6.4-rc2/fs/jfs/super.c	2004-03-03 22:04:28.000000000 +0000
@@ -381,6 +381,7 @@ static int jfs_fill_super(struct super_b
 		return -ENOSPC;
 	memset(sbi, 0, sizeof (struct jfs_sb_info));
 	sb->s_fs_info = sbi;
+	sbi->sb = sb;
 
 	/* initialize the mount flag and determine the default error handler */
 	flag = JFS_ERR_REMOUNT_RO;
diff -purN linux-post-2.6.4rc1-20040303/include/asm-ppc64/iommu.h linux-2.6.4-rc2/include/asm-ppc64/iommu.h
--- linux-post-2.6.4rc1-20040303/include/asm-ppc64/iommu.h	2004-02-27 17:16:29.000000000 +0000
+++ linux-2.6.4-rc2/include/asm-ppc64/iommu.h	2004-03-03 13:26:24.000000000 +0000
@@ -24,6 +24,7 @@
 
 #include <asm/types.h>
 #include <linux/spinlock.h>
+#include <linux/device.h>
 
 /*
  * IOMAP_MAX_ORDER defines the largest contiguous block
@@ -78,6 +79,7 @@ struct iommu_table {
 	unsigned long  it_blocksize; /* Entries in each block (cacheline) */
 	unsigned long  it_hint;      /* Hint for next alloc */
 	unsigned long  it_largehint; /* Hint for large allocs */
+	unsigned long  it_halfpoint; /* Breaking point for small/large allocs */
 	spinlock_t     it_lock;      /* Protects it_map */
 	unsigned long  it_mapsize;   /* Size of map in # of entries (bits) */
 	unsigned long *it_map;       /* A simple allocation bitmap for now */
@@ -132,16 +134,16 @@ extern struct iommu_table *iommu_init_ta
 
 /* allocates a range of tces and sets them to the pages  */
 extern dma_addr_t iommu_alloc(struct iommu_table *, void *page, 
-			      unsigned int numPages, int direction,
-			      unsigned long *handle);
+			      unsigned int numPages, int direction);
 extern void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr, 
 		       unsigned int npages);
 
 /* same with sg lists */
-extern int iommu_alloc_sg(struct iommu_table *table, struct scatterlist *sglist,
-			  int nelems, int direction, unsigned long *handle);
+extern int iommu_alloc_sg(struct iommu_table *table, struct device *dev,
+			  struct scatterlist *sglist, int nelems,
+			  int direction);
 extern void iommu_free_sg(struct iommu_table *tbl, struct scatterlist *sglist,
-			  int nelems, int direction);
+			  int nelems);
 
 
 extern void tce_init_pSeries(void);
diff -purN linux-post-2.6.4rc1-20040303/include/linux/parport.h linux-2.6.4-rc2/include/linux/parport.h
--- linux-post-2.6.4rc1-20040303/include/linux/parport.h	2004-02-05 08:47:36.000000000 +0000
+++ linux-2.6.4-rc2/include/linux/parport.h	2004-03-03 12:45:18.000000000 +0000
@@ -294,7 +294,7 @@ struct parport {
 	struct pardevice *waithead;
 	struct pardevice *waittail;
 	
-	struct parport *next;
+	struct list_head list;
 	unsigned int flags;
 
 	void *sysctl_table;
@@ -313,6 +313,7 @@ struct parport {
 	atomic_t ref_count;
 
 	struct list_head full_list;
+	struct parport *slaves[3];
 };
 
 #define DEFAULT_SPIN_TIME 500 /* us */
@@ -321,7 +322,7 @@ struct parport_driver {
 	const char *name;
 	void (*attach) (struct parport *);
 	void (*detach) (struct parport *);
-	struct parport_driver *next;
+	struct list_head list;
 };
 
 /* parport_register_port registers a new parallel port at the given
@@ -339,12 +340,7 @@ struct parport *parport_register_port(un
 void parport_announce_port (struct parport *port);
 
 /* Unregister a port. */
-extern void parport_unregister_port(struct parport *port);
-
-/* parport_enumerate returns a pointer to the linked list of all the
-   ports in this machine.  DON'T USE THIS.  Use
-   parport_register_driver instead. */
-struct parport *parport_enumerate(void);
+extern void parport_remove_port(struct parport *port);
 
 /* Register a new high-level driver. */
 extern int parport_register_driver (struct parport_driver *);
@@ -451,9 +447,6 @@ static __inline__ int parport_yield_bloc
 
 #define PARPORT_FLAG_EXCL		(1<<1)	/* EXCL driver registered. */
 
-extern int parport_parse_irqs(int, const char *[], int irqval[]);
-extern int parport_parse_dmas(int, const char *[], int dmaval[]);
-
 /* IEEE1284 functions */
 extern void parport_ieee1284_interrupt (int, void *, struct pt_regs *);
 extern int parport_negotiate (struct parport *, int mode);
@@ -538,8 +531,6 @@ extern int parport_proc_register(struct 
 extern int parport_proc_unregister(struct parport *pp);
 extern int parport_device_proc_register(struct pardevice *device);
 extern int parport_device_proc_unregister(struct pardevice *device);
-extern int parport_default_proc_register(void);
-extern int parport_default_proc_unregister(void);
 
 /* If PC hardware is the only type supported, we can optimise a bit.  */
 #if (defined(CONFIG_PARPORT_PC) || defined(CONFIG_PARPORT_PC_MODULE)) && !(defined(CONFIG_PARPORT_ARC) || defined(CONFIG_PARPORT_ARC_MODULE)) && !(defined(CONFIG_PARPORT_AMIGA) || defined(CONFIG_PARPORT_AMIGA_MODULE)) && !(defined(CONFIG_PARPORT_MFC3) || defined(CONFIG_PARPORT_MFC3_MODULE)) && !(defined(CONFIG_PARPORT_ATARI) || defined(CONFIG_PARPORT_ATARI_MODULE)) && !(defined(CONFIG_USB_USS720) || defined(CONFIG_USB_USS720_MODULE)) && !(defined(CONFIG_PARPORT_SUNBPP) || defined(CONFIG_PARPORT_SUNBPP_MODULE)) && !defined(CONFIG_PARPORT_OTHER)
diff -purN linux-post-2.6.4rc1-20040303/include/linux/parport_pc.h linux-2.6.4-rc2/include/linux/parport_pc.h
--- linux-post-2.6.4rc1-20040303/include/linux/parport_pc.h	2004-02-04 05:29:19.000000000 +0000
+++ linux-2.6.4-rc2/include/linux/parport_pc.h	2004-03-03 12:45:17.000000000 +0000
@@ -39,6 +39,8 @@ struct parport_pc_private {
 	char *dma_buf;
 	dma_addr_t dma_handle;
 	struct pci_dev *dev;
+	struct list_head list;
+	struct parport *port;
 };
 
 static __inline__ void parport_pc_write_data(struct parport *p, unsigned char d)
diff -purN linux-post-2.6.4rc1-20040303/include/video/cvisionppc.h linux-2.6.4-rc2/include/video/cvisionppc.h
--- linux-post-2.6.4rc1-20040303/include/video/cvisionppc.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.4-rc2/include/video/cvisionppc.h	2004-02-18 08:41:32.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+ * Phase5 CybervisionPPC (TVP4020) definitions for the Permedia2 framebuffer
+ * driver.
+ *
+ * Copyright (c) 1998-1999 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)
+ * --------------------------------------------------------------------------
+ * $Id: cvisionppc.h,v 1.8 1999/01/28 13:18:07 illo Exp $
+ * --------------------------------------------------------------------------
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+#ifndef CVISIONPPC_H
+#define CVISIONPPC_H
+
+#ifndef PM2FB_H
+#include "pm2fb.h"
+#endif
+
+struct cvppc_par {
+	unsigned char* pci_config;
+	unsigned char* pci_bridge;
+	u32 user_flags;
+};
+
+#define CSPPC_PCI_BRIDGE		0xfffe0000
+#define CSPPC_BRIDGE_ENDIAN		0x0000
+#define CSPPC_BRIDGE_INT		0x0010
+
+#define	CVPPC_PCI_CONFIG		0xfffc0000
+#define CVPPC_ROM_ADDRESS		0xe2000001
+#define CVPPC_REGS_REGION		0xef000000
+#define CVPPC_FB_APERTURE_ONE		0xe0000000
+#define CVPPC_FB_APERTURE_TWO		0xe1000000
+#define CVPPC_FB_SIZE			0x00800000
+#define CVPPC_MEM_CONFIG_OLD		0xed61fcaa	/* FIXME Fujitsu?? */
+#define CVPPC_MEM_CONFIG_NEW		0xed41c532	/* FIXME USA?? */
+#define CVPPC_MEMCLOCK			83000		/* in KHz */
+
+/* CVPPC_BRIDGE_ENDIAN */
+#define CSPPCF_BRIDGE_BIG_ENDIAN	0x02
+
+/* CVPPC_BRIDGE_INT */
+#define CSPPCF_BRIDGE_ACTIVE_INT2	0x01
+
+#endif	/* CVISIONPPC_H */
+
+/*****************************************************************************
+ * That's all folks!
+ *****************************************************************************/
diff -purN linux-post-2.6.4rc1-20040303/include/video/permedia2.h linux-2.6.4-rc2/include/video/permedia2.h
--- linux-post-2.6.4rc1-20040303/include/video/permedia2.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.4-rc2/include/video/permedia2.h	2004-02-18 08:41:21.000000000 +0000
@@ -0,0 +1,222 @@
+/*
+ * Permedia2 framebuffer driver definitions.
+ * Copyright (c) 1998-2000 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)
+ * --------------------------------------------------------------------------
+ * $Id: pm2fb.h,v 1.26 2000/09/19 00:11:53 illo Exp $
+ * --------------------------------------------------------------------------
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+#ifndef PM2FB_H
+#define PM2FB_H
+
+#define PM2_REFERENCE_CLOCK	14318			/* in KHz */
+#define PM2_MAX_PIXCLOCK	230000			/* in KHz */
+#define PM2_REGS_SIZE		0x10000
+
+#define PM2TAG(r) (u32 )(((r)-0x8000)>>3)
+
+/*****************************************************************************
+ * Permedia2 registers used in the framebuffer
+ *****************************************************************************/
+ 
+#define PM2R_RESET_STATUS				0x0000
+#define PM2R_IN_FIFO_SPACE				0x0018
+#define PM2R_OUT_FIFO_WORDS				0x0020
+#define PM2R_APERTURE_ONE				0x0050
+#define PM2R_APERTURE_TWO				0x0058
+#define PM2R_FIFO_DISCON				0x0068
+#define PM2R_CHIP_CONFIG				0x0070
+
+#define PM2R_REBOOT					0x1000
+#define PM2R_MEM_CONTROL				0x1040
+#define PM2R_BOOT_ADDRESS				0x1080
+#define PM2R_MEM_CONFIG					0x10c0
+#define PM2R_BYPASS_WRITE_MASK				0x1100
+#define PM2R_FRAMEBUFFER_WRITE_MASK			0x1140
+
+#define PM2R_OUT_FIFO					0x2000
+
+#define PM2R_SCREEN_BASE				0x3000
+#define PM2R_SCREEN_STRIDE				0x3008
+#define PM2R_H_TOTAL					0x3010
+#define PM2R_HG_END					0x3018
+#define PM2R_HB_END					0x3020
+#define PM2R_HS_START					0x3028
+#define PM2R_HS_END					0x3030
+#define PM2R_V_TOTAL					0x3038
+#define PM2R_VB_END					0x3040
+#define PM2R_VS_START					0x3048
+#define PM2R_VS_END					0x3050
+#define PM2R_VIDEO_CONTROL				0x3058
+#define PM2R_LINE_COUNT					0x3070
+#define PM2R_FIFO_CONTROL				0x3078
+
+#define PM2R_RD_PALETTE_WRITE_ADDRESS			0x4000
+#define PM2R_RD_PALETTE_DATA				0x4008
+#define PM2R_RD_PIXEL_MASK				0x4010
+#define PM2R_RD_PALETTE_READ_ADDRESS			0x4018
+#define PM2R_RD_INDEXED_DATA				0x4050
+
+#define PM2R_START_X_DOM				0x8000
+#define PM2R_D_X_DOM					0x8008
+#define PM2R_START_X_SUB				0x8010
+#define PM2R_D_X_SUB					0x8018
+#define PM2R_START_Y					0x8020
+#define PM2R_D_Y					0x8028
+#define PM2R_COUNT					0x8030
+#define PM2R_RENDER					0x8038
+#define PM2R_RASTERIZER_MODE				0x80a0
+#define PM2R_RECTANGLE_ORIGIN				0x80d0
+#define PM2R_RECTANGLE_SIZE				0x80d8
+#define PM2R_PACKED_DATA_LIMITS				0x8150
+#define PM2R_SCISSOR_MODE				0x8180
+#define PM2R_SCREEN_SIZE				0x8198
+#define PM2R_AREA_STIPPLE_MODE				0x81a0
+#define PM2R_WINDOW_ORIGIN				0x81c8
+#define PM2R_TEXTURE_ADDRESS_MODE			0x8380
+#define PM2R_TEXTURE_MAP_FORMAT				0x8588
+#define PM2R_TEXTURE_DATA_FORMAT			0x8590
+#define PM2R_TEXTURE_READ_MODE				0x8670
+#define PM2R_TEXEL_LUT_MODE				0x8678
+#define PM2R_TEXTURE_COLOR_MODE				0x8680
+#define PM2R_FOG_MODE					0x8690
+#define PM2R_COLOR_DDA_MODE				0x87e0
+#define PM2R_ALPHA_BLEND_MODE				0x8810
+#define PM2R_DITHER_MODE				0x8818
+#define PM2R_FB_SOFT_WRITE_MASK				0x8820
+#define PM2R_LOGICAL_OP_MODE				0x8828
+#define PM2R_LB_READ_MODE				0x8880
+#define PM2R_LB_READ_FORMAT				0x8888
+#define PM2R_LB_SOURCE_OFFSET				0x8890
+#define PM2R_LB_WINDOW_BASE				0x88b8
+#define PM2R_LB_WRITE_FORMAT				0x88c8
+#define PM2R_STENCIL_MODE				0x8988
+#define PM2R_DEPTH_MODE					0x89a0
+#define PM2R_FB_READ_MODE				0x8a80
+#define PM2R_FB_SOURCE_OFFSET				0x8a88
+#define PM2R_FB_PIXEL_OFFSET				0x8a90
+#define PM2R_FB_WINDOW_BASE				0x8ab0
+#define PM2R_FB_WRITE_MODE				0x8ab8
+#define PM2R_FB_HARD_WRITE_MASK				0x8ac0
+#define PM2R_FB_BLOCK_COLOR				0x8ac8
+#define PM2R_FB_READ_PIXEL				0x8ad0
+#define PM2R_FILTER_MODE				0x8c00
+#define PM2R_SYNC					0x8c40
+#define PM2R_YUV_MODE					0x8f00
+#define PM2R_STATISTICS_MODE				0x8c08
+#define PM2R_FB_SOURCE_DELTA				0x8d88
+#define PM2R_CONFIG					0x8d90
+#define PM2R_DELTA_MODE					0x9300
+
+/* Permedia2v */
+#define PM2VR_RD_INDEX_LOW				0x4020
+#define PM2VR_RD_INDEX_HIGH				0x4028
+#define PM2VR_RD_INDEXED_DATA				0x4030
+
+/* Permedia2 RAMDAC indexed registers */
+#define PM2I_RD_CURSOR_CONTROL				0x06
+#define PM2I_RD_COLOR_MODE				0x18
+#define PM2I_RD_MODE_CONTROL				0x19
+#define PM2I_RD_MISC_CONTROL				0x1e
+#define PM2I_RD_PIXEL_CLOCK_A1				0x20
+#define PM2I_RD_PIXEL_CLOCK_A2				0x21
+#define PM2I_RD_PIXEL_CLOCK_A3				0x22
+#define PM2I_RD_PIXEL_CLOCK_STATUS			0x29
+#define PM2I_RD_MEMORY_CLOCK_1				0x30
+#define PM2I_RD_MEMORY_CLOCK_2				0x31
+#define PM2I_RD_MEMORY_CLOCK_3				0x32
+#define PM2I_RD_MEMORY_CLOCK_STATUS			0x33
+#define PM2I_RD_COLOR_KEY_CONTROL			0x40
+#define PM2I_RD_OVERLAY_KEY				0x41
+#define PM2I_RD_RED_KEY					0x42
+#define PM2I_RD_GREEN_KEY				0x43
+#define PM2I_RD_BLUE_KEY				0x44
+
+/* Permedia2v extensions */
+#define PM2VI_RD_MISC_CONTROL				0x000
+#define PM2VI_RD_SYNC_CONTROL				0x001
+#define PM2VI_RD_DAC_CONTROL				0x002
+#define PM2VI_RD_PIXEL_SIZE				0x003
+#define PM2VI_RD_COLOR_FORMAT				0x004
+#define PM2VI_RD_CURSOR_MODE				0x005
+#define PM2VI_RD_CURSOR_X_LOW				0x007
+#define PM2VI_RD_CURSOR_X_HIGH				0x008
+#define PM2VI_RD_CURSOR_Y_LOW				0x009
+#define PM2VI_RD_CURSOR_Y_HIGH				0x00A
+#define PM2VI_RD_CURSOR_X_HOT				0x00B
+#define PM2VI_RD_CURSOR_Y_HOT				0x00C
+#define PM2VI_RD_CLK0_PRESCALE				0x201
+#define PM2VI_RD_CLK0_FEEDBACK				0x202
+#define PM2VI_RD_CLK0_POSTSCALE				0x203
+#define PM2VI_RD_CLK1_PRESCALE				0x204
+#define PM2VI_RD_CLK1_FEEDBACK				0x205
+#define PM2VI_RD_CLK1_POSTSCALE				0x206
+#define PM2VI_RD_CURSOR_PALETTE				0x303
+#define PM2VI_RD_CURSOR_PATTERN				0x400
+
+/* Fields and flags */
+#define PM2F_RENDER_AREASTIPPLE				(1L<<0)
+#define PM2F_RENDER_FASTFILL				(1L<<3)
+#define PM2F_RENDER_PRIMITIVE_MASK			(3L<<6)
+#define PM2F_RENDER_LINE				0
+#define PM2F_RENDER_TRAPEZOID				(1L<<6)
+#define PM2F_RENDER_POINT				(2L<<6)
+#define PM2F_RENDER_RECTANGLE				(3L<<6)
+#define PM2F_SYNCHRONIZATION				(1L<<10)
+#define PM2F_PLL_LOCKED					0x10
+#define PM2F_BEING_RESET				(1L<<31)
+#define PM2F_DATATYPE_COLOR				0x8000
+#define PM2F_VGA_ENABLE					0x02
+#define PM2F_VGA_FIXED					0x04
+#define PM2F_FB_WRITE_ENABLE				0x01
+#define PM2F_FB_READ_SOURCE_ENABLE			0x0200
+#define PM2F_RD_PALETTE_WIDTH_8				0x02
+#define PM2F_PART_PROD_MASK				0x01ff
+#define PM2F_SCREEN_SCISSOR_ENABLE			0x02
+#define PM2F_DATA_64_ENABLE				0x00010000
+#define PM2F_BLANK_LOW					0x02
+#define PM2F_HSYNC_MASK					0x18
+#define PM2F_VSYNC_MASK					0x60
+#define PM2F_HSYNC_ACT_HIGH				0x08
+#define PM2F_HSYNC_FORCED_LOW				0x10
+#define PM2F_HSYNC_ACT_LOW				0x18
+#define PM2F_VSYNC_ACT_HIGH				0x20
+#define PM2F_VSYNC_FORCED_LOW				0x40
+#define PM2F_VSYNC_ACT_LOW				0x60
+#define PM2F_LINE_DOUBLE				0x04
+#define PM2F_VIDEO_ENABLE				0x01
+#define PM2F_RD_GUI_ACTIVE				0x10
+#define PM2F_RD_COLOR_MODE_RGB				0x20
+#define PM2F_DELTA_ORDER_RGB				(1L<<18)
+#define PM2F_RD_TRUECOLOR				0x80
+#define PM2F_NO_ALPHA_BUFFER				0x10
+#define PM2F_TEXTEL_SIZE_16				0x00080000
+#define PM2F_TEXTEL_SIZE_32				0x00100000
+#define PM2F_TEXTEL_SIZE_4				0x00180000
+#define PM2F_TEXTEL_SIZE_24				0x00200000
+#define PM2F_INCREASE_X					(1L<<21)
+#define PM2F_INCREASE_Y					(1L<<22)
+#define PM2F_CONFIG_FB_WRITE_ENABLE			(1L<<3)
+#define PM2F_CONFIG_FB_PACKED_DATA			(1L<<2)
+#define PM2F_CONFIG_FB_READ_DEST_ENABLE			(1L<<1)
+#define PM2F_CONFIG_FB_READ_SOURCE_ENABLE		(1L<<0)
+#define PM2F_COLOR_KEY_TEST_OFF				(1L<<4)
+#define PM2F_MEM_CONFIG_RAM_MASK			(3L<<29)
+#define PM2F_MEM_BANKS_1				0L
+#define PM2F_MEM_BANKS_2				(1L<<29)
+#define PM2F_MEM_BANKS_3				(2L<<29)
+#define PM2F_MEM_BANKS_4				(3L<<29)
+
+typedef enum {
+	PM2_TYPE_PERMEDIA2,
+	PM2_TYPE_PERMEDIA2V
+} pm2type_t;
+
+#endif /* PM2FB_H */
+
+/*****************************************************************************
+ * That's all folks!
+ *****************************************************************************/
diff -purN linux-post-2.6.4rc1-20040303/include/video/pm2fb.h linux-2.6.4-rc2/include/video/pm2fb.h
--- linux-post-2.6.4rc1-20040303/include/video/pm2fb.h	2002-05-31 21:50:35.000000000 +0000
+++ linux-2.6.4-rc2/include/video/pm2fb.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,222 +0,0 @@
-/*
- * Permedia2 framebuffer driver definitions.
- * Copyright (c) 1998-2000 Ilario Nardinocchi (nardinoc@CS.UniBO.IT)
- * --------------------------------------------------------------------------
- * $Id: pm2fb.h,v 1.26 2000/09/19 00:11:53 illo Exp $
- * --------------------------------------------------------------------------
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file COPYING in the main directory of this archive
- * for more details.
- */
-
-#ifndef PM2FB_H
-#define PM2FB_H
-
-#define PM2_REFERENCE_CLOCK	14318			/* in KHz */
-#define PM2_MAX_PIXCLOCK	230000			/* in KHz */
-#define PM2_REGS_SIZE		0x10000
-
-#define PM2TAG(r) (u32 )(((r)-0x8000)>>3)
-
-/*****************************************************************************
- * Permedia2 registers used in the framebuffer
- *****************************************************************************/
- 
-#define PM2R_RESET_STATUS				0x0000
-#define PM2R_IN_FIFO_SPACE				0x0018
-#define PM2R_OUT_FIFO_WORDS				0x0020
-#define PM2R_APERTURE_ONE				0x0050
-#define PM2R_APERTURE_TWO				0x0058
-#define PM2R_FIFO_DISCON				0x0068
-#define PM2R_CHIP_CONFIG				0x0070
-
-#define PM2R_REBOOT					0x1000
-#define PM2R_MEM_CONTROL				0x1040
-#define PM2R_BOOT_ADDRESS				0x1080
-#define PM2R_MEM_CONFIG					0x10c0
-#define PM2R_BYPASS_WRITE_MASK				0x1100
-#define PM2R_FRAMEBUFFER_WRITE_MASK			0x1140
-
-#define PM2R_OUT_FIFO					0x2000
-
-#define PM2R_SCREEN_BASE				0x3000
-#define PM2R_SCREEN_STRIDE				0x3008
-#define PM2R_H_TOTAL					0x3010
-#define PM2R_HG_END					0x3018
-#define PM2R_HB_END					0x3020
-#define PM2R_HS_START					0x3028
-#define PM2R_HS_END					0x3030
-#define PM2R_V_TOTAL					0x3038
-#define PM2R_VB_END					0x3040
-#define PM2R_VS_START					0x3048
-#define PM2R_VS_END					0x3050
-#define PM2R_VIDEO_CONTROL				0x3058
-#define PM2R_LINE_COUNT					0x3070
-#define PM2R_FIFO_CONTROL				0x3078
-
-#define PM2R_RD_PALETTE_WRITE_ADDRESS			0x4000
-#define PM2R_RD_PALETTE_DATA				0x4008
-#define PM2R_RD_PIXEL_MASK				0x4010
-#define PM2R_RD_PALETTE_READ_ADDRESS			0x4018
-#define PM2R_RD_INDEXED_DATA				0x4050
-
-#define PM2R_START_X_DOM				0x8000
-#define PM2R_D_X_DOM					0x8008
-#define PM2R_START_X_SUB				0x8010
-#define PM2R_D_X_SUB					0x8018
-#define PM2R_START_Y					0x8020
-#define PM2R_D_Y					0x8028
-#define PM2R_COUNT					0x8030
-#define PM2R_RENDER					0x8038
-#define PM2R_RASTERIZER_MODE				0x80a0
-#define PM2R_RECTANGLE_ORIGIN				0x80d0
-#define PM2R_RECTANGLE_SIZE				0x80d8
-#define PM2R_PACKED_DATA_LIMITS				0x8150
-#define PM2R_SCISSOR_MODE				0x8180
-#define PM2R_SCREEN_SIZE				0x8198
-#define PM2R_AREA_STIPPLE_MODE				0x81a0
-#define PM2R_WINDOW_ORIGIN				0x81c8
-#define PM2R_TEXTURE_ADDRESS_MODE			0x8380
-#define PM2R_TEXTURE_MAP_FORMAT				0x8588
-#define PM2R_TEXTURE_DATA_FORMAT			0x8590
-#define PM2R_TEXTURE_READ_MODE				0x8670
-#define PM2R_TEXEL_LUT_MODE				0x8678
-#define PM2R_TEXTURE_COLOR_MODE				0x8680
-#define PM2R_FOG_MODE					0x8690
-#define PM2R_COLOR_DDA_MODE				0x87e0
-#define PM2R_ALPHA_BLEND_MODE				0x8810
-#define PM2R_DITHER_MODE				0x8818
-#define PM2R_FB_SOFT_WRITE_MASK				0x8820
-#define PM2R_LOGICAL_OP_MODE				0x8828
-#define PM2R_LB_READ_MODE				0x8880
-#define PM2R_LB_READ_FORMAT				0x8888
-#define PM2R_LB_SOURCE_OFFSET				0x8890
-#define PM2R_LB_WINDOW_BASE				0x88b8
-#define PM2R_LB_WRITE_FORMAT				0x88c8
-#define PM2R_STENCIL_MODE				0x8988
-#define PM2R_DEPTH_MODE					0x89a0
-#define PM2R_FB_READ_MODE				0x8a80
-#define PM2R_FB_SOURCE_OFFSET				0x8a88
-#define PM2R_FB_PIXEL_OFFSET				0x8a90
-#define PM2R_FB_WINDOW_BASE				0x8ab0
-#define PM2R_FB_WRITE_MODE				0x8ab8
-#define PM2R_FB_HARD_WRITE_MASK				0x8ac0
-#define PM2R_FB_BLOCK_COLOR				0x8ac8
-#define PM2R_FB_READ_PIXEL				0x8ad0
-#define PM2R_FILTER_MODE				0x8c00
-#define PM2R_SYNC					0x8c40
-#define PM2R_YUV_MODE					0x8f00
-#define PM2R_STATISTICS_MODE				0x8c08
-#define PM2R_FB_SOURCE_DELTA				0x8d88
-#define PM2R_CONFIG					0x8d90
-#define PM2R_DELTA_MODE					0x9300
-
-/* Permedia2v */
-#define PM2VR_RD_INDEX_LOW				0x4020
-#define PM2VR_RD_INDEX_HIGH				0x4028
-#define PM2VR_RD_INDEXED_DATA				0x4030
-
-/* Permedia2 RAMDAC indexed registers */
-#define PM2I_RD_CURSOR_CONTROL				0x06
-#define PM2I_RD_COLOR_MODE				0x18
-#define PM2I_RD_MODE_CONTROL				0x19
-#define PM2I_RD_MISC_CONTROL				0x1e
-#define PM2I_RD_PIXEL_CLOCK_A1				0x20
-#define PM2I_RD_PIXEL_CLOCK_A2				0x21
-#define PM2I_RD_PIXEL_CLOCK_A3				0x22
-#define PM2I_RD_PIXEL_CLOCK_STATUS			0x29
-#define PM2I_RD_MEMORY_CLOCK_1				0x30
-#define PM2I_RD_MEMORY_CLOCK_2				0x31
-#define PM2I_RD_MEMORY_CLOCK_3				0x32
-#define PM2I_RD_MEMORY_CLOCK_STATUS			0x33
-#define PM2I_RD_COLOR_KEY_CONTROL			0x40
-#define PM2I_RD_OVERLAY_KEY				0x41
-#define PM2I_RD_RED_KEY					0x42
-#define PM2I_RD_GREEN_KEY				0x43
-#define PM2I_RD_BLUE_KEY				0x44
-
-/* Permedia2v extensions */
-#define PM2VI_RD_MISC_CONTROL				0x000
-#define PM2VI_RD_SYNC_CONTROL				0x001
-#define PM2VI_RD_DAC_CONTROL				0x002
-#define PM2VI_RD_PIXEL_SIZE				0x003
-#define PM2VI_RD_COLOR_FORMAT				0x004
-#define PM2VI_RD_CURSOR_MODE				0x005
-#define PM2VI_RD_CURSOR_X_LOW				0x007
-#define PM2VI_RD_CURSOR_X_HIGH				0x008
-#define PM2VI_RD_CURSOR_Y_LOW				0x009
-#define PM2VI_RD_CURSOR_Y_HIGH				0x00A
-#define PM2VI_RD_CURSOR_X_HOT				0x00B
-#define PM2VI_RD_CURSOR_Y_HOT				0x00C
-#define PM2VI_RD_CLK0_PRESCALE				0x201
-#define PM2VI_RD_CLK0_FEEDBACK				0x202
-#define PM2VI_RD_CLK0_POSTSCALE				0x203
-#define PM2VI_RD_CLK1_PRESCALE				0x204
-#define PM2VI_RD_CLK1_FEEDBACK				0x205
-#define PM2VI_RD_CLK1_POSTSCALE				0x206
-#define PM2VI_RD_CURSOR_PALETTE				0x303
-#define PM2VI_RD_CURSOR_PATTERN				0x400
-
-/* Fields and flags */
-#define PM2F_RENDER_AREASTIPPLE				(1L<<0)
-#define PM2F_RENDER_FASTFILL				(1L<<3)
-#define PM2F_RENDER_PRIMITIVE_MASK			(3L<<6)
-#define PM2F_RENDER_LINE				0
-#define PM2F_RENDER_TRAPEZOID				(1L<<6)
-#define PM2F_RENDER_POINT				(2L<<6)
-#define PM2F_RENDER_RECTANGLE				(3L<<6)
-#define PM2F_SYNCHRONIZATION				(1L<<10)
-#define PM2F_PLL_LOCKED					0x10
-#define PM2F_BEING_RESET				(1L<<31)
-#define PM2F_DATATYPE_COLOR				0x8000
-#define PM2F_VGA_ENABLE					0x02
-#define PM2F_VGA_FIXED					0x04
-#define PM2F_FB_WRITE_ENABLE				0x01
-#define PM2F_FB_READ_SOURCE_ENABLE			0x0200
-#define PM2F_RD_PALETTE_WIDTH_8				0x02
-#define PM2F_PART_PROD_MASK				0x01ff
-#define PM2F_SCREEN_SCISSOR_ENABLE			0x02
-#define PM2F_DATA_64_ENABLE				0x00010000
-#define PM2F_BLANK_LOW					0x02
-#define PM2F_HSYNC_MASK					0x18
-#define PM2F_VSYNC_MASK					0x60
-#define PM2F_HSYNC_ACT_HIGH				0x08
-#define PM2F_HSYNC_FORCED_LOW				0x10
-#define PM2F_HSYNC_ACT_LOW				0x18
-#define PM2F_VSYNC_ACT_HIGH				0x20
-#define PM2F_VSYNC_FORCED_LOW				0x40
-#define PM2F_VSYNC_ACT_LOW				0x60
-#define PM2F_LINE_DOUBLE				0x04
-#define PM2F_VIDEO_ENABLE				0x01
-#define PM2F_RD_GUI_ACTIVE				0x10
-#define PM2F_RD_COLOR_MODE_RGB				0x20
-#define PM2F_DELTA_ORDER_RGB				(1L<<18)
-#define PM2F_RD_TRUECOLOR				0x80
-#define PM2F_NO_ALPHA_BUFFER				0x10
-#define PM2F_TEXTEL_SIZE_16				0x00080000
-#define PM2F_TEXTEL_SIZE_32				0x00100000
-#define PM2F_TEXTEL_SIZE_4				0x00180000
-#define PM2F_TEXTEL_SIZE_24				0x00200000
-#define PM2F_INCREASE_X					(1L<<21)
-#define PM2F_INCREASE_Y					(1L<<22)
-#define PM2F_CONFIG_FB_WRITE_ENABLE			(1L<<3)
-#define PM2F_CONFIG_FB_PACKED_DATA			(1L<<2)
-#define PM2F_CONFIG_FB_READ_DEST_ENABLE			(1L<<1)
-#define PM2F_CONFIG_FB_READ_SOURCE_ENABLE		(1L<<0)
-#define PM2F_COLOR_KEY_TEST_OFF				(1L<<4)
-#define PM2F_MEM_CONFIG_RAM_MASK			(3L<<29)
-#define PM2F_MEM_BANKS_1				0L
-#define PM2F_MEM_BANKS_2				(1L<<29)
-#define PM2F_MEM_BANKS_3				(2L<<29)
-#define PM2F_MEM_BANKS_4				(3L<<29)
-
-typedef enum {
-	PM2_TYPE_PERMEDIA2,
-	PM2_TYPE_PERMEDIA2V
-} pm2type_t;
-
-#endif /* PM2FB_H */
-
-/*****************************************************************************
- * That's all folks!
- *****************************************************************************/
