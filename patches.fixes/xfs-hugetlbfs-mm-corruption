Date: Tue, 6 Apr 2004 18:31:51 +0200
From: Andrea Arcangeli <andrea@suse.de>
Subject: [kernel] xfs mm corruption fix

XFS has a mm corruption bug that I spotted a few hours ago, it's not
related to my vm changes, it corrupts memory in mailine 2.6 with
hugetlbfs=y too. This was effectively the last vm related bugreports I
had, and until now it wasn't clear if the bug was in my vm changes or
somewhere else.

Thanks to my VM robustness changes to the page allocator the xfs
developers could notice this xfs bug for the first time even when they
compiled as usual with hugetlbfs=n (but for us it has always been an
issue since we always compile with hugetlbfs=y).

My gfp-no-compound logic allows us to fix this bug safely (so they can
still mess the page->private of slab pages of order > 0) but without
destabilizing the kernel anymore.

Christoph acknowledged the xfs issue and he posted an alternate patch
but less obviously right/safe, my below one is definitely obviously
safe, so we can apply my one any time even without any testing at all,
so I suggest to go with my one if there's sitll some time for a checkin
for sl9.1. Again, zero risks at all, if something it will help,
in the very very worst case it'll be a noop.

diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/fs/xfs/linux/kmem.h sles/fs/xfs/linux/kmem.h
--- sles-ref/fs/xfs/linux/kmem.h	2004-04-04 08:09:26.000000000 +0200
+++ sles/fs/xfs/linux/kmem.h	2004-04-06 06:58:16.956689584 +0200
@@ -101,7 +101,7 @@ kmem_flags_convert(int flags)
 	if (PFLAGS_TEST_FSTRANS() || (flags & KM_NOFS))
 		lflags &= ~__GFP_FS;
 
-	return lflags;
+	return lflags | __GFP_NO_COMP;
 }
 
 static __inline void *
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/fs/xfs/linux/xfs_buf.c sles/fs/xfs/linux/xfs_buf.c
--- sles-ref/fs/xfs/linux/xfs_buf.c	2004-04-06 06:56:58.603601064 +0200
+++ sles/fs/xfs/linux/xfs_buf.c	2004-04-06 06:58:16.953690040 +0200
@@ -185,7 +185,7 @@ free_address(
 {
 	a_list_t	*aentry;
 
-	aentry = kmalloc(sizeof(a_list_t), GFP_ATOMIC);
+	aentry = kmalloc(sizeof(a_list_t), GFP_ATOMIC | __GFP_NO_COMP);
 	if (aentry) {
 		spin_lock(&as_lock);
 		aentry->next = as_free_head;
@@ -1258,6 +1258,7 @@ bio_end_io_pagebuf(
 	for (i = 0; i < bio->bi_vcnt; i++, bvec++) {
 		struct page	*page = bvec->bv_page;
 
+		BUG_ON(PageCompound(page));
 		if (pb->pb_error) {
 			SetPageError(page);
 		} else if (blocksize == PAGE_CACHE_SIZE) {
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/fs/xfs/linux/xfs_file.c sles/fs/xfs/linux/xfs_file.c
--- sles-ref/fs/xfs/linux/xfs_file.c	2004-04-04 08:09:26.000000000 +0200
+++ sles/fs/xfs/linux/xfs_file.c	2004-04-06 06:58:16.954689888 +0200
@@ -348,7 +348,7 @@ linvfs_readdir(
 
 	/* Try fairly hard to get memory */
 	do {
-		if ((read_buf = (caddr_t)kmalloc(rlen, GFP_KERNEL)))
+		if ((read_buf = (caddr_t)kmalloc(rlen, GFP_KERNEL | __GFP_NO_COMP)))
 			break;
 		rlen >>= 1;
 	} while (rlen >= 1024);
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/fs/xfs/linux/xfs_ioctl.c sles/fs/xfs/linux/xfs_ioctl.c
--- sles-ref/fs/xfs/linux/xfs_ioctl.c	2004-04-06 06:56:41.032272312 +0200
+++ sles/fs/xfs/linux/xfs_ioctl.c	2004-04-06 06:58:16.955689736 +0200
@@ -517,7 +517,7 @@ xfs_attrmulti_by_handle(
 		return -error;
 
 	size = am_hreq.opcount * sizeof(attr_multiop_t);
-	ops = (xfs_attr_multiop_t *)kmalloc(size, GFP_KERNEL);
+	ops = (xfs_attr_multiop_t *)kmalloc(size, GFP_KERNEL | __GFP_NO_COMP);
 	if (!ops) {
 		VN_RELE(vp);
 		return -XFS_ERROR(ENOMEM);
diff -urNp --exclude CVS --exclude BitKeeper --exclude {arch} --exclude .arch-ids sles-ref/fs/xfs/linux/xfs_iops.c sles/fs/xfs/linux/xfs_iops.c
--- sles-ref/fs/xfs/linux/xfs_iops.c	2004-04-06 06:57:03.134912200 +0200
+++ sles/fs/xfs/linux/xfs_iops.c	2004-04-06 06:58:16.954689888 +0200
@@ -418,11 +418,11 @@ linvfs_follow_link(
 	ASSERT(dentry);
 	ASSERT(nd);
 
-	link = (char *)kmalloc(MAXNAMELEN+1, GFP_KERNEL);
+	link = (char *)kmalloc(MAXNAMELEN+1, GFP_KERNEL | __GFP_NO_COMP);
 	if (!link)
 		return -ENOMEM;
 
-	uio = (uio_t *)kmalloc(sizeof(uio_t), GFP_KERNEL);
+	uio = (uio_t *)kmalloc(sizeof(uio_t), GFP_KERNEL | __GFP_NO_COMP);
 	if (!uio) {
 		kfree(link);
 		return -ENOMEM;

