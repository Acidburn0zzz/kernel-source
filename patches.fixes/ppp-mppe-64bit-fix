From: Karsten Keil <kkeil@suse.de>
Subject: Fix 64 bit problems in mppe implementation
Reference: 115398

The sha1 code need 32 bit types for the digest operations, not long.

diff -ur linux/drivers/net/sha1.c linux.new/drivers/net/sha1.c
--- linux/drivers/net/sha1.c	2005-08-30 02:27:39.000000000 +0200
+++ linux.new/drivers/net/sha1.c	2005-09-08 14:14:37.000000000 +0200
@@ -29,7 +29,7 @@
 
 #include "sha1.h"
 
-static void SHA1_Transform(unsigned long[5], const unsigned char[64]);
+static void SHA1_Transform(u32 [5], const unsigned char[64]);
 
 #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
 
@@ -57,21 +57,21 @@
 /* Hash a single 512-bit block. This is the core of the algorithm. */
 
 static void
-SHA1_Transform(unsigned long state[5], const unsigned char buffer[64])
+SHA1_Transform(u32 state[5], const unsigned char buffer[64])
 {
-    unsigned long a, b, c, d, e;
+    u32 a, b, c, d, e;
     typedef union {
 	unsigned char c[64];
-	unsigned long l[16];
-    } CHAR64LONG16;
-    CHAR64LONG16 *block;
+	u32 l[16];
+    } CHAR64INT16;
+    CHAR64INT16 *block;
 
 #ifdef SHA1HANDSOFF
     static unsigned char workspace[64];
-    block = (CHAR64LONG16 *) workspace;
+    block = (CHAR64INT16 *) workspace;
     memcpy(block, buffer, 64);
 #else
-    block = (CHAR64LONG16 *) buffer;
+    block = (CHAR64INT16 *) buffer;
 #endif
     /* Copy context->state[] to working vars */
     a = state[0];
@@ -156,7 +156,7 @@
 void
 SHA1_Final(unsigned char digest[20], SHA1_CTX *context)
 {
-    unsigned long i, j;
+    u32 i, j;
     unsigned char finalcount[8];
 
     for (i = 0; i < 8; i++) {
diff -ur linux/drivers/net/sha1.h linux.new/drivers/net/sha1.h
--- linux/drivers/net/sha1.h	2005-08-30 02:27:39.000000000 +0200
+++ linux.new/drivers/net/sha1.h	2005-09-08 14:13:43.000000000 +0200
@@ -4,8 +4,8 @@
 #define _SHA1_H
 
 typedef struct {
-    unsigned long state[5];
-    unsigned long count[2];
+    u32 state[5];
+    u32 count[2];
     unsigned char buffer[64];
 } SHA1_CTX;
 
