From trenn@suse.de Mon Jul 30 21:08:35 2007
Subject: [PATCH 1/2] ondemand as default governor
From: Thomas Renninger <trenn@suse.de>
Reply-To: trenn@suse.de
To: Andrew Morton <akpm@osdl.org>
Cc: Dave Jones <davej@redhat.com>, "Pallipadi, Venkatesh" <venkatesh.pallipadi@intel.com>
Content-Type: text/plain
Organization: Novell/SUSE
Message-Id: <1185822515.18821.93.camel@queen.suse.de>
Mime-Version: 1.0
X-Mailer: Evolution 2.8.2 
Date: Mon, 30 Jul 2007 21:08:35 +0200
X-Evolution-Format: text/plain
X-Evolution-Account: 1145659904.3797.20@queen
X-Evolution-Transport:
	smtp://trenn;auth=PLAIN@relay.suse.de/;use_ssl=when-possible
X-Evolution-Fcc: imap://trenn@imap.suse.de/INBOX/Sent
X-Evolution-Source: imap://trenn@imap.suse.de/
Content-Transfer-Encoding: 8bit

Move policy's governor initialisation out of low-level drivers into cpufreq core


Signed-off-by: Thomas Renninger <trenn@suse.de>
Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>


---
 arch/arm/mach-imx/cpufreq.c                       |    1 -
 arch/arm/mach-sa1100/cpu-sa1110.c                 |    1 -
 arch/arm/plat-omap/cpu-omap.c                     |    1 -
 arch/blackfin/mach-bf533/cpu.c                    |    2 --
 arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c       |    1 -
 arch/i386/kernel/cpu/cpufreq/cpufreq-nforce2.c    |    1 -
 arch/i386/kernel/cpu/cpufreq/e_powersaver.c       |    1 -
 arch/i386/kernel/cpu/cpufreq/elanfreq.c           |    1 -
 arch/i386/kernel/cpu/cpufreq/gx-suspmod.c         |    1 -
 arch/i386/kernel/cpu/cpufreq/longhaul.c           |    1 -
 arch/i386/kernel/cpu/cpufreq/p4-clockmod.c        |    1 -
 arch/i386/kernel/cpu/cpufreq/powernow-k6.c        |    1 -
 arch/i386/kernel/cpu/cpufreq/powernow-k7.c        |    2 --
 arch/i386/kernel/cpu/cpufreq/powernow-k8.c        |    1 -
 arch/i386/kernel/cpu/cpufreq/sc520_freq.c         |    1 -
 arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c |    1 -
 arch/i386/kernel/cpu/cpufreq/speedstep-ich.c      |    1 -
 arch/i386/kernel/cpu/cpufreq/speedstep-smi.c      |    1 -
 arch/ia64/kernel/cpufreq/acpi-cpufreq.c           |    2 --
 arch/powerpc/platforms/cell/cbe_cpufreq.c         |    1 -
 arch/powerpc/platforms/pasemi/cpufreq.c           |    2 --
 arch/powerpc/platforms/powermac/cpufreq_32.c      |    1 -
 arch/powerpc/platforms/powermac/cpufreq_64.c      |    1 -
 arch/sh/kernel/cpufreq.c                          |    1 -
 arch/sparc64/kernel/us2e_cpufreq.c                |    1 -
 drivers/cpufreq/cpufreq.c                         |    2 ++
 26 files changed, 2 insertions(+), 29 deletions(-)

--- linux-2.6.22.orig/drivers/cpufreq/cpufreq.c
+++ linux-2.6.22/drivers/cpufreq/cpufreq.c
@@ -759,6 +759,8 @@ static int cpufreq_add_dev (struct sys_d
 	init_completion(&policy->kobj_unregister);
 	INIT_WORK(&policy->update, handle_update);
 
+	/* Set governor before ->init, so that driver could check it */
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	/* call driver. From then on the cpufreq must be able
 	 * to accept all calls to ->verify and ->setpolicy for this CPU
 	 */
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/powernow-k8.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/powernow-k8.c
@@ -1205,7 +1205,6 @@ static int __cpuinit powernowk8_cpu_init
 	/* run on any CPU again */
 	set_cpus_allowed(current, oldmask);
 
-	pol->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	if (cpu_family == CPU_HW_PSTATE)
 		pol->cpus = cpumask_of_cpu(pol->cpu);
 	else
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/speedstep-smi.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/speedstep-smi.c
@@ -290,7 +290,6 @@ static int speedstep_cpu_init(struct cpu
 		(speed / 1000));
 
 	/* cpuinfo and default policy values */
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
 	policy->cur = speed;
 
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c
@@ -660,7 +660,6 @@ static int acpi_cpufreq_cpu_init(struct 
 			policy->cpuinfo.transition_latency =
 			    perf->states[i].transition_latency * 1000;
 	}
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 
 	data->max_freq = perf->states[0].core_frequency * 1000;
 	/* table init */
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/cpufreq-nforce2.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/cpufreq-nforce2.c
@@ -363,7 +363,6 @@ static int nforce2_cpu_init(struct cpufr
 	policy->cur = nforce2_get(policy->cpu);
 	policy->min = policy->cpuinfo.min_freq;
 	policy->max = policy->cpuinfo.max_freq;
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 
 	return 0;
 }
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/e_powersaver.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/e_powersaver.c
@@ -253,7 +253,6 @@ static int eps_cpu_init(struct cpufreq_p
 		f_table[k].frequency = CPUFREQ_TABLE_END;
 	}
 
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = 140000; /* 844mV -> 700mV in ns */
 	policy->cur = fsb * current_multiplier;
 
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/elanfreq.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/elanfreq.c
@@ -219,7 +219,6 @@ static int elanfreq_cpu_init(struct cpuf
 	}
 
 	/* cpuinfo and default policy values */
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
 	policy->cur = elanfreq_get_cpu_frequency(0);
 
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/gx-suspmod.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/gx-suspmod.c
@@ -421,7 +421,6 @@ static int cpufreq_gx_cpu_init(struct cp
 		policy->min = maxfreq / POLICY_MIN_DIV;
 	policy->max = maxfreq;
 	policy->cur = curfreq;
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.min_freq = maxfreq / max_duration;
 	policy->cpuinfo.max_freq = maxfreq;
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/longhaul.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/longhaul.c
@@ -802,7 +802,6 @@ print_support_type:
 	if ((longhaul_version != TYPE_LONGHAUL_V1) && (scale_voltage != 0))
 		longhaul_setup_voltagescaling();
 
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = 200000;	/* nsec */
 	policy->cur = calc_speed(longhaul_get_cpu_mult());
 
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/p4-clockmod.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/p4-clockmod.c
@@ -229,7 +229,6 @@ static int cpufreq_p4_cpu_init(struct cp
 	cpufreq_frequency_table_get_attr(p4clockmod_table, policy->cpu);
 
 	/* cpuinfo and default policy values */
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = 1000000; /* assumed */
 	policy->cur = stock_freq;
 
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/powernow-k6.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/powernow-k6.c
@@ -160,7 +160,6 @@ static int powernow_k6_cpu_init(struct c
 	}
 
 	/* cpuinfo and default policy values */
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
 	policy->cur = busfreq * max_multiplier;
 
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/powernow-k7.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/powernow-k7.c
@@ -637,8 +637,6 @@ static int __init powernow_cpu_init (str
 	printk (KERN_INFO PFX "Minimum speed %d MHz. Maximum speed %d MHz.\n",
 				minimum_speed/1000, maximum_speed/1000);
 
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
-
 	policy->cpuinfo.transition_latency = cpufreq_scale(2000000UL, fsb, latency);
 
 	policy->cur = powernow_get(0);
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/sc520_freq.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/sc520_freq.c
@@ -111,7 +111,6 @@ static int sc520_freq_cpu_init(struct cp
 		return -ENODEV;
 
 	/* cpuinfo and default policy values */
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = 1000000; /* 1ms */
 	policy->cur = sc520_freq_get_cpu_frequency(0);
 
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
@@ -610,7 +610,6 @@ static int centrino_cpu_init(struct cpuf
 
 	freq = get_cur_freq(policy->cpu);
 
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = 10000; /* 10uS transition latency */
 	policy->cur = freq;
 
--- linux-2.6.22.orig/arch/i386/kernel/cpu/cpufreq/speedstep-ich.c
+++ linux-2.6.22/arch/i386/kernel/cpu/cpufreq/speedstep-ich.c
@@ -350,7 +350,6 @@ static int speedstep_cpu_init(struct cpu
 		(speed / 1000));
 
 	/* cpuinfo and default policy values */
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cur = speed;
 
 	result = cpufreq_frequency_table_cpuinfo(policy, speedstep_freqs);
--- linux-2.6.22.orig/arch/arm/mach-imx/cpufreq.c
+++ linux-2.6.22/arch/arm/mach-imx/cpufreq.c
@@ -269,7 +269,6 @@ static int __init imx_cpufreq_driver_ini
 		return -EINVAL;
 
 	policy->cur = policy->min = policy->max = imx_get_speed(0);
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.min_freq = 8000;
 	policy->cpuinfo.max_freq = 200000;
 	 /* Manual states, that PLL stabilizes in two CLK32 periods */
--- linux-2.6.22.orig/arch/arm/mach-sa1100/cpu-sa1110.c
+++ linux-2.6.22/arch/arm/mach-sa1100/cpu-sa1110.c
@@ -331,7 +331,6 @@ static int __init sa1110_cpu_init(struct
 	if (policy->cpu != 0)
 		return -EINVAL;
 	policy->cur = policy->min = policy->max = sa11x0_getspeed(0);
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.min_freq = 59000;
 	policy->cpuinfo.max_freq = 287000;
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
--- linux-2.6.22.orig/arch/arm/plat-omap/cpu-omap.c
+++ linux-2.6.22/arch/arm/plat-omap/cpu-omap.c
@@ -108,7 +108,6 @@ static int __init omap_cpu_init(struct c
 	if (policy->cpu != 0)
 		return -EINVAL;
 	policy->cur = policy->min = policy->max = omap_getspeed(0);
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.min_freq = clk_round_rate(mpu_clk, 0) / 1000;
 	policy->cpuinfo.max_freq = clk_round_rate(mpu_clk, VERY_HI_RATE) / 1000;
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
--- linux-2.6.22.orig/arch/blackfin/mach-bf533/cpu.c
+++ linux-2.6.22/arch/blackfin/mach-bf533/cpu.c
@@ -119,8 +119,6 @@ static int __init __bf533_cpu_init(struc
 	if (policy->cpu != 0)
 		return -EINVAL;
 
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
-
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
 	/*Now ,only support one cpu */
 	policy->cur = bf533_getfreq(0);
--- linux-2.6.22.orig/arch/ia64/kernel/cpufreq/acpi-cpufreq.c
+++ linux-2.6.22/arch/ia64/kernel/cpufreq/acpi-cpufreq.c
@@ -323,8 +323,6 @@ acpi_cpufreq_cpu_init (
 			    data->acpi_data.states[i].transition_latency * 1000;
 		}
 	}
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
-
 	policy->cur = processor_get_freq(data, policy->cpu);
 
 	/* table init */
--- linux-2.6.22.orig/arch/powerpc/platforms/cell/cbe_cpufreq.c
+++ linux-2.6.22/arch/powerpc/platforms/cell/cbe_cpufreq.c
@@ -238,7 +238,6 @@ static int cbe_cpufreq_cpu_init(struct c
 		pr_debug("%d: %d\n", i, cbe_freqs[i].frequency);
 	}
 
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	/* if DEBUG is enabled set_pmode() measures the correct latency of a transition */
 	policy->cpuinfo.transition_latency = 25000;
 
--- linux-2.6.22.orig/arch/powerpc/platforms/pasemi/cpufreq.c
+++ linux-2.6.22/arch/powerpc/platforms/pasemi/cpufreq.c
@@ -195,8 +195,6 @@ static int pas_cpufreq_cpu_init(struct c
 		pr_debug("%d: %d\n", i, pas_freqs[i].frequency);
 	}
 
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
-
 	policy->cpuinfo.transition_latency = get_gizmo_latency();
 
 	cur_astate = get_cur_astate(policy->cpu);
--- linux-2.6.22.orig/arch/powerpc/platforms/powermac/cpufreq_32.c
+++ linux-2.6.22/arch/powerpc/platforms/powermac/cpufreq_32.c
@@ -410,7 +410,6 @@ static int pmac_cpufreq_cpu_init(struct 
 	if (policy->cpu != 0)
 		return -ENODEV;
 
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency	= CPUFREQ_ETERNAL;
 	policy->cur = cur_freq;
 
--- linux-2.6.22.orig/arch/powerpc/platforms/powermac/cpufreq_64.c
+++ linux-2.6.22/arch/powerpc/platforms/powermac/cpufreq_64.c
@@ -357,7 +357,6 @@ static unsigned int g5_cpufreq_get_speed
 
 static int g5_cpufreq_cpu_init(struct cpufreq_policy *policy)
 {
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
 	policy->cur = g5_cpu_freqs[g5_query_freq()].frequency;
 	/* secondary CPUs are tied to the primary one by the
--- linux-2.6.22.orig/arch/sparc64/kernel/us2e_cpufreq.c
+++ linux-2.6.22/arch/sparc64/kernel/us2e_cpufreq.c
@@ -326,7 +326,6 @@ static int __init us2e_freq_cpu_init(str
 	table[2].index = 5;
 	table[3].frequency = CPUFREQ_TABLE_END;
 
-	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = 0;
 	policy->cur = clock_tick;
 
--- linux-2.6.22.orig/arch/sh/kernel/cpufreq.c
+++ linux-2.6.22/arch/sh/kernel/cpufreq.c
@@ -159,7 +159,6 @@ static int sh_cpufreq_cpu_init(struct cp
 	sh_freqs[SH_FREQ_MIN].frequency = min_freq;
 
 	/* cpuinfo and default policy values */
-	policy->governor                   = CPUFREQ_DEFAULT_GOVERNOR;
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
 	policy->cur                        = max_freq;
 
