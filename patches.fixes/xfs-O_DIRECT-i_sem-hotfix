Date: Fri, 18 Jun 2004 00:54:12 +0200
From: Christoph Hellwig <hch@lst.de>
Subject: sledgehammer fix for direct I/O fsx failure on xfs

okay, I still haven't managed to get out a proper fix so here's the
sledgehammer variant of taking i_sem and exclusive iolock for all
O_DIRECT writes.

The fs/direct-io.c [agruen: we already had that] and mm/filemap.c [we
don't need that] bits are from a patch posted on lkml a while ago,
without those the testcase fails on all filesystems.


Index: linux-2.6.5/fs/xfs/linux/xfs_file.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/linux/xfs_file.c
+++ linux-2.6.5/fs/xfs/linux/xfs_file.c
@@ -115,16 +115,12 @@ __linvfs_write(
 	ssize_t		rval;
 
 	BUG_ON(iocb->ki_pos != pos);
-	if (unlikely(file->f_flags & O_DIRECT)) {
+	if (unlikely(file->f_flags & O_DIRECT))
 		ioflags |= IO_ISDIRECT;
-		VOP_WRITE(vp, iocb, &iov, 1, &iocb->ki_pos,
-				ioflags, NULL, rval);
-	} else {
-		down(&inode->i_sem);
-		VOP_WRITE(vp, iocb, &iov, 1, &iocb->ki_pos,
-				ioflags, NULL, rval);
-		up(&inode->i_sem);
-	}
+
+	down(&inode->i_sem);
+	VOP_WRITE(vp, iocb, &iov, 1, &iocb->ki_pos, ioflags, NULL, rval);
+	up(&inode->i_sem);
 
 	return rval;
 }
@@ -213,16 +209,13 @@ __linvfs_writev(
 
 	init_sync_kiocb(&kiocb, file);
 	kiocb.ki_pos = *ppos;
-	if (unlikely(file->f_flags & O_DIRECT)) {
+	if (unlikely(file->f_flags & O_DIRECT))
 		ioflags |= IO_ISDIRECT;
-		VOP_WRITE(vp, &kiocb, iov, nr_segs, &kiocb.ki_pos,
-				ioflags, NULL, rval);
-	} else {
-		down(&inode->i_sem);
-		VOP_WRITE(vp, &kiocb, iov, nr_segs, &kiocb.ki_pos,
-				ioflags, NULL, rval);
-		up(&inode->i_sem);
-	}
+
+	down(&inode->i_sem);
+	VOP_WRITE(vp, &kiocb, iov, nr_segs, &kiocb.ki_pos, ioflags, NULL, rval);
+	up(&inode->i_sem);
+
 
 	if (rval == -EIOCBQUEUED)
 		rval = wait_on_sync_kiocb(&kiocb);
Index: linux-2.6.5/fs/xfs/linux/xfs_lrw.c
===================================================================
--- linux-2.6.5.orig/fs/xfs/linux/xfs_lrw.c
+++ linux-2.6.5/fs/xfs/linux/xfs_lrw.c
@@ -225,12 +225,13 @@ xfs_inval_cached_pages(
 	int		write,
 	int		relock)
 {
-	xfs_mount_t	*mp;
+//	xfs_mount_t	*mp;
 
 	if (!VN_CACHED(vp)) {
 		return;
 	}
 
+#if 0
 	mp = io->io_mount;
 
 	/*
@@ -253,12 +254,15 @@ xfs_inval_cached_pages(
 		}
 		XFS_IUNLOCK(mp, io, XFS_ILOCK_EXCL|XFS_EXTSIZE_RD);
 	}
+#endif
 
 	xfs_inval_cached_trace(io, offset, -1, ctooff(offtoct(offset)), -1);
 	VOP_FLUSHINVAL_PAGES(vp, ctooff(offtoct(offset)), -1, FI_REMAPF_LOCKED);
+#if 0
 	if (relock) {
 		XFS_ILOCK_DEMOTE(mp, io, XFS_IOLOCK_EXCL);
 	}
+#endif
 }
 
 ssize_t			/* bytes read, or (-)  error */
@@ -703,13 +707,11 @@ xfs_write(
 		    (size & target->pbr_smask)) {
 			return XFS_ERROR(-EINVAL);
 		}
-		iolock = XFS_IOLOCK_SHARED;
-		locktype = VRWLOCK_WRITE_DIRECT;
-	} else {
-		iolock = XFS_IOLOCK_EXCL;
-		locktype = VRWLOCK_WRITE;
 	}
 
+	iolock = XFS_IOLOCK_EXCL;
+	locktype = VRWLOCK_WRITE;
+
 	if (ioflags & IO_ISLOCKED)
 		iolock = 0;
 
@@ -784,7 +786,7 @@ start:
 	 * to zero it out up to the new size.
 	 */
 
-	if (!(ioflags & IO_ISDIRECT) && (*offset > isize && isize)) {
+	if (*offset > isize && isize) {
 		error = xfs_zero_eof(BHV_TO_VNODE(bdp), io, *offset,
 			isize, *offset + size);
 		if (error) {
