From: Kay Sievers <kay.sievers@vrfy.org>
Subject: Delay hotplug events after partition table detection is finished
References: 157095

The kernel is still scanning the partition table of the disk and the
device is not useable until that task is finished.

A similar problem is that volumes (sda, hda formatted with the broken
Linux command line tools: mkfs*, fdisk) are sometimes recognized as a
msdos partition table _and_ a FAT volume. In this case the kernel sends
out the event for the disk and userspace (HAL and the desktop stack)
probes this volume and finds a FAT volume and mounts it. At the same
time the kernel "finds out" that there is a partiton table on the device
and creates partitions (sda1, hda1, ...). In some cases these partitions
get mounted too, which obviously does something bad.

At the moment there is no way to tell reliably if the kernel will find
partitions while we process the disk event. We could only, as usual, sleep
for a few seconds and wait if we receive partition events.

This patch delays all block device events until the kernel has finished
the partition table scanning and all devices (disk and partitions) are
already created before the first event is sent out. It also creates a
/sys/block/<sda>/partitoned flag which indicates if there are is a partition
table found on the disk (we could live without the flag, cause the disk
event could just look at the already completely populated partition
devices in sysfs at the time the disk event is sent out).

It should solve the dasd problem cause we should be able to use the
device at the time it is announced. In the other case, HAL could
check for already existing partitions and then never probe for a filesystem
on the disk itself.

Signed-off-by: Kay Sievers <ksievers@novell.com>
---

diff --git a/fs/partitions/check.c b/fs/partitions/check.c
index f924f45..54f054c 100644
--- a/fs/partitions/check.c
+++ b/fs/partitions/check.c
@@ -310,7 +310,9 @@ void delete_partition(struct gendisk *di
 	p->ios[0] = p->ios[1] = 0;
 	p->sectors[0] = p->sectors[1] = 0;
 	devfs_remove("%s/part%d", disk->devfs_name, part);
-	kobject_unregister(&p->kobj);
+	kobject_uevent(&p->kobj, KOBJ_REMOVE);
+	kobject_del(&p->kobj);
+	kobject_put(&p->kobj);
 }
 
 void add_partition(struct gendisk *disk, int part, sector_t start, sector_t len)
@@ -336,7 +338,10 @@ void add_partition(struct gendisk *disk,
 		snprintf(p->kobj.name,KOBJ_NAME_LEN,"%s%d",disk->kobj.name,part);
 	p->kobj.parent = &disk->kobj;
 	p->kobj.ktype = &ktype_part;
-	kobject_register(&p->kobj);
+	kobject_init(&p->kobj);
+	kobject_add(&p->kobj);
+	if (!disk->part_uevent_supress)
+		kobject_uevent(&p->kobj, KOBJ_ADD);
 	disk->part[part-1] = p;
 }
 
@@ -373,6 +378,8 @@ void register_disk(struct gendisk *disk)
 {
 	struct block_device *bdev;
 	char *s;
+	int i;
+	struct hd_struct *p;
 	int err;
 
 	strlcpy(disk->kobj.name,disk->disk_name,KOBJ_NAME_LEN);
@@ -382,14 +389,13 @@ void register_disk(struct gendisk *disk)
 		*s = '!';
 	if ((err = kobject_add(&disk->kobj)))
 		return;
-	disk_sysfs_symlinks(disk);
-	kobject_uevent(&disk->kobj, KOBJ_ADD);
 
+	disk_sysfs_symlinks(disk);
 	/* No minors to use for partitions */
 	if (disk->minors == 1) {
 		if (disk->devfs_name[0] != '\0')
 			devfs_add_disk(disk);
-		return;
+		goto exit;
 	}
 
 	/* always add handle for the whole disk */
@@ -397,16 +403,32 @@ void register_disk(struct gendisk *disk)
 
 	/* No such device (e.g., media were just removed) */
 	if (!get_capacity(disk))
-		return;
+		goto exit;
 
 	bdev = bdget_disk(disk, 0);
 	if (!bdev)
-		return;
+		goto exit;
 
+	/* scan partition table, but supress uevents */
 	bdev->bd_invalidated = 1;
-	if (blkdev_get(bdev, FMODE_READ, 0) < 0)
-		return;
+	disk->part_uevent_supress = 1;
+	err = blkdev_get(bdev, FMODE_READ, 0);
+	disk->part_uevent_supress = 0;
+	if (err < 0)
+		goto exit;
 	blkdev_put(bdev);
+
+exit:
+	/* announce disk after possible partitions are already created */
+	kobject_uevent(&disk->kobj, KOBJ_ADD);
+
+	/* announce possible partitions */
+	for (i = 1; i < disk->minors; i++) {
+		p = disk->part[i-1];
+		if (!p || !p->nr_sects)
+			continue;
+		kobject_uevent(&p->kobj, KOBJ_ADD);
+	}
 }
 
 int rescan_partitions(struct gendisk *disk, struct block_device *bdev)
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index eef5ccd..089bb01 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -104,6 +104,7 @@ struct gendisk {
                                          * disks that can't be partitioned. */
 	char disk_name[32];		/* name of major driver */
 	struct hd_struct **part;	/* [indexed by minor] */
+	int part_uevent_supress;
 	struct block_device_operations *fops;
 	struct request_queue *queue;
 	void *private_data;
