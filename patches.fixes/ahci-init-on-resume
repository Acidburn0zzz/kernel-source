From: Hannes Reinecke <hare@suse.de>
Subject: sata-disks not correctly handled during wake-up after s2r
References: 157619
Patch-Mainline: under review on libata-dev

Upon suspend-to-RAM S-ATA drives are not waking up correctly.
There are actually two problems here: One is the wrong / missing
initialisation of the AHCI driver after resume and the other one
is that MSI registered are not restored.

This patch addresses the first issue. We have to restore the AHCI
registers upon resume as the BIOS might have done a host reset after
which most register settings are hosed.

And while we're at it, we can as well fix the disk spinup to be
a bit more spec-conformant.

Signed-off-by: Hannes Reinecke <hare@suse.de>

--- linux-2.6.16/drivers/scsi/ahci.c.orig	2006-03-30 10:07:32.000000000 +0200
+++ linux-2.6.16/drivers/scsi/ahci.c	2006-03-30 15:22:25.000000000 +0200
@@ -40,6 +40,7 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/sched.h>
+#include <linux/suspend.h>
 #include <linux/dma-mapping.h>
 #include <linux/device.h>
 #include <scsi/scsi_host.h>
@@ -86,6 +87,11 @@ enum {
 
 	/* HOST_CAP bits */
 	HOST_CAP_64		= (1 << 31), /* PCI DAC (64-bit DMA) support */
+	HOST_CAP_SIS		= (1 << 28), /* Interlock switch */
+	HOST_CAP_SSS		= (1 << 27), /* Staggered Spin-up */
+	HOST_CAP_SPM		= (1 << 17), /* Port multiplier */
+	HOST_CAP_SSC		= (1 << 14), /* Slumber capable */
+	HOST_CAP_PSC		= (1 << 13), /* Partial capable */
 
 	/* registers for each SATA port */
 	PORT_LST_ADDR		= 0x00, /* command list DMA addr */
@@ -136,13 +142,16 @@ enum {
 
 	/* PORT_CMD bits */
 	PORT_CMD_ATAPI		= (1 << 24), /* Device is ATAPI */
+	PORT_CMD_CPD		= (1 << 20), /* Cold presence detection */
 	PORT_CMD_LIST_ON	= (1 << 15), /* cmd list DMA engine running */
 	PORT_CMD_FIS_ON		= (1 << 14), /* FIS DMA engine running */
 	PORT_CMD_FIS_RX		= (1 << 4), /* Enable FIS receive DMA engine */
+	PORT_CMD_CLO		= (1 << 3), /* Command list override */
 	PORT_CMD_POWER_ON	= (1 << 2), /* Power up device */
 	PORT_CMD_SPIN_UP	= (1 << 1), /* Spin up device */
 	PORT_CMD_START		= (1 << 0), /* Enable port DMA engine */
 
+	PORT_CMD_ICC_MASK	= (0xf << 28), /* i/f ICC state mask */
 	PORT_CMD_ICC_ACTIVE	= (0x1 << 28), /* Put i/f in active state */
 	PORT_CMD_ICC_PARTIAL	= (0x2 << 28), /* Put i/f in partial state */
 	PORT_CMD_ICC_SLUMBER	= (0x6 << 28), /* Put i/f in slumber state */
@@ -170,6 +179,7 @@ struct ahci_host_priv {
 	unsigned long		flags;
 	u32			cap;	/* cache of HOST_CAP register */
 	u32			port_map; /* cache of HOST_PORTS_IMPL reg */
+	u32			dev_map;  /* connected devices */
 };
 
 struct ahci_port_priv {
@@ -197,15 +207,20 @@ static void ahci_phy_reset(struct ata_po
 static void ahci_irq_clear(struct ata_port *ap);
 static void ahci_eng_timeout(struct ata_port *ap);
 static int ahci_port_start(struct ata_port *ap);
-static int ahci_port_suspend(struct ata_port *ap);
+static int ahci_port_suspend(struct ata_port *ap, pm_message_t state);
 static int ahci_port_resume(struct ata_port *ap);
 static void ahci_port_stop(struct ata_port *ap);
+static int ahci_port_standby(void __iomem *port_mmio, u32 cap);
+static int ahci_port_spinup(void __iomem *port_mmio, u32 cap);
+static void ahci_port_disable(struct ata_port *ap);
 static void ahci_tf_read(struct ata_port *ap, struct ata_taskfile *tf);
 static void ahci_qc_prep(struct ata_queued_cmd *qc);
 static u8 ahci_check_status(struct ata_port *ap);
 static inline int ahci_host_intr(struct ata_port *ap, struct ata_queued_cmd *qc);
 static int ahci_scsi_device_suspend(struct scsi_device *sdev, pm_message_t state);
 static int ahci_scsi_device_resume(struct scsi_device *sdev);
+static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t state);
+static int ahci_pci_device_resume(struct pci_dev *pdev);
 static void ahci_remove_one (struct pci_dev *pdev);
 
 static struct scsi_host_template ahci_sht = {
@@ -231,7 +246,7 @@ static struct scsi_host_template ahci_sh
 };
 
 static const struct ata_port_operations ahci_ops = {
-	.port_disable		= ata_port_disable,
+	.port_disable		= ahci_port_disable,
 
 	.check_status		= ahci_check_status,
 	.check_altstatus	= ahci_check_status,
@@ -313,8 +328,8 @@ static struct pci_driver ahci_pci_driver
 	.id_table		= ahci_pci_tbl,
 	.probe			= ahci_init_one,
 	.remove			= ahci_remove_one,
-	.suspend		= ata_pci_device_suspend,
-	.resume			= ata_pci_device_resume,
+	.suspend		= ahci_pci_device_suspend,
+	.resume			= ahci_pci_device_resume,
 };
 
 
@@ -392,6 +407,10 @@ static int ahci_port_start(struct ata_po
 	 * Driver is setup; initialize the HBA
 	 */
 	ahci_start_fis_rx(port_mmio, pp, hpriv);
+	rc = ahci_port_spinup(port_mmio, hpriv->cap);
+	if (rc)
+		printk(KERN_WARNING "ata%d: could not spinup device (%d)\n",
+		       ap->id, rc);
 
 	/*
 	 * Do not enable DMA here; according to the spec
@@ -409,7 +428,7 @@ static void ahci_port_stop(struct ata_po
 	struct device *dev = ap->host_set->dev;
 	struct ahci_port_priv *pp = ap->private_data;
 
-	ahci_port_suspend(ap);
+	ahci_port_suspend(ap, PMSG_SUSPEND);
 
 	ap->private_data = NULL;
 	dma_free_coherent(dev, AHCI_PORT_PRIV_DMA_SZ,
@@ -425,12 +444,55 @@ static int ahci_port_resume(struct ata_p
 	struct ahci_host_priv *hpriv = ap->host_set->private_data;
 	struct ahci_port_priv *pp = ap->private_data;
 	int rc;
+	u32 tmp;
 
 	/*
 	 * Enable FIS reception
 	 */
 	ahci_start_fis_rx(port_mmio, pp, hpriv);
 
+	rc = ahci_port_spinup(port_mmio, hpriv->cap);
+	if (rc)
+		printk(KERN_WARNING "ata%d: could not spinup device (%d)\n",
+		       ap->id, rc);
+
+	/*
+	 * Clear error status
+	 */
+	tmp = readl(port_mmio + PORT_SCR_ERR);
+	writel(tmp, port_mmio + PORT_SCR_ERR);
+	/*
+	 * Clear interrupt status
+	 */
+	tmp = readl(mmio + HOST_CTL);
+	if (!(tmp & HOST_IRQ_EN)) {
+		u32 irq_stat;
+
+		/* ack any pending irq events for this port */
+		irq_stat = readl(port_mmio + PORT_IRQ_STAT);
+		if (irq_stat)
+			writel(irq_stat, port_mmio + PORT_IRQ_STAT);
+
+		/* set irq mask (enables interrupts) */
+		writel(DEF_PORT_IRQ, port_mmio + PORT_IRQ_MASK);
+
+		if ((hpriv->dev_map >> (ap->port_no + 1)) == 0) {
+			/*
+			 * Enable interrupts if this was the last port
+			 */
+			printk(KERN_WARNING "ata%d: enabling interrupts\n",
+			       ap->id);
+
+			irq_stat = readl(mmio + HOST_IRQ_STAT);
+			if (irq_stat)
+				writel(irq_stat, mmio + HOST_IRQ_STAT);
+
+			tmp |= HOST_IRQ_EN;
+			writel(tmp, mmio + HOST_CTL);
+			(void) readl(mmio + HOST_CTL);
+		}
+	}
+
 	/*
 	 * Enable DMA
 	 */
@@ -442,10 +504,11 @@ static int ahci_port_resume(struct ata_p
 	return rc;
 }
 
-static int ahci_port_suspend(struct ata_port *ap)
+static int ahci_port_suspend(struct ata_port *ap, pm_message_t state)
 {
 	void __iomem *mmio = ap->host_set->mmio_base;
 	void __iomem *port_mmio = ahci_port_base(mmio, ap->port_no);
+	struct ahci_host_priv *hpriv = ap->host_set->private_data;
 	int rc;
 
 	/*
@@ -465,9 +528,25 @@ static int ahci_port_suspend(struct ata_
 		printk(KERN_WARNING "ata%d: FIS RX still running (rc %d)\n",
 		       ap->id, rc);
 
+	/*
+	 * Put device into slumber mode
+	 */
+	if (!rc && state.event != PM_EVENT_FREEZE)
+		ahci_port_standby(port_mmio, hpriv->cap);
+
 	return rc;
 }
 
+static void ahci_port_disable(struct ata_port *ap) 
+{	
+	struct ahci_host_priv *hpriv = ap->host_set->private_data;
+
+	ata_port_disable(ap);
+
+	hpriv->dev_map &= ~(1 << ap->port_no);
+}
+
+
 static u32 ahci_scr_read (struct ata_port *ap, unsigned int sc_reg_in)
 {
 	unsigned int sc_reg;
@@ -614,10 +693,10 @@ static int ahci_stop_fis_rx(void __iomem
 	mdelay(500);
 	work = 1000;
 	while (work-- > 0) {
-	    tmp = readl(port_mmio + PORT_CMD);
-	    if ((tmp & PORT_CMD_FIS_ON) == 0)
-		return 0;
-	    udelay(10);
+		tmp = readl(port_mmio + PORT_CMD);
+		if ((tmp & PORT_CMD_FIS_ON) == 0)
+			return 0;
+		udelay(10);
 	}
 
 	return -EBUSY;
@@ -627,8 +706,10 @@ static void ahci_start_fis_rx(void __iom
 			      struct ahci_port_priv *pp,
 			      struct ahci_host_priv *hpriv)
 {
+	u32 tmp;
+
 	/*
-	 * Enable FIS reception
+	 * Set FIS registers
 	 */
 	if (hpriv->cap & HOST_CAP_64)
 		writel((pp->cmd_slot_dma >> 16) >> 16, port_mmio + PORT_LST_ADDR_HI);
@@ -641,23 +722,117 @@ static void ahci_start_fis_rx(void __iom
 	readl(port_mmio + PORT_FIS_ADDR); /* flush */
 
 	/*
-	 * This is wrong. We should only activate
-	 * FIS_RX here; everything else should be handled
-	 * separately.
-	 * Some bits might not even be settable here
-	 * as they depend on the respective feature to be
-	 * implemented (Staggered Spin-up, 
-	 * Cold-presence detection etc.)
-	 */
-	writel(PORT_CMD_ICC_ACTIVE | PORT_CMD_FIS_RX |
-	       PORT_CMD_POWER_ON | PORT_CMD_SPIN_UP,
-	       port_mmio + PORT_CMD);
+	 * Enable FIS reception
+	 */
+	tmp = readl(port_mmio + PORT_CMD);
+	tmp |= PORT_CMD_FIS_RX;
+	writel(tmp, port_mmio + PORT_CMD);
 	readl(port_mmio + PORT_CMD); /* flush */
 }
 
+static int ahci_port_spinup(void __iomem *port_mmio, u32 cap)
+{
+	u32 tmp;
+
+	tmp = readl(port_mmio + PORT_CMD);
+	/*
+	 * AHCI Rev1.1 Section 5.3.2.3:
+	 * Software is only allowed to program the PxCMD.FRE,
+	 * PxCMD.POD, PxSCTL.DET, and PxCMD.SUD register bits
+	 * when PxCMD.ST is set to ‘0’.
+	 */
+	if (tmp & PORT_CMD_START)
+		return -EBUSY;
+
+	/*
+	 * Power on device if supported
+	 */
+	if (tmp & PORT_CMD_CPD) {
+		tmp |= PORT_CMD_POWER_ON;
+		writel(tmp, port_mmio + PORT_CMD);
+		tmp = readl(port_mmio + PORT_CMD);
+	}
+
+	/*
+	 * Spin up device
+	 */
+	if (cap & HOST_CAP_SSS) {
+		tmp |= PORT_CMD_SPIN_UP;
+		writel(tmp, port_mmio + PORT_CMD);
+		tmp = readl(port_mmio + PORT_CMD);
+	}
+
+	if ((tmp & PORT_CMD_ICC_MASK) != PORT_CMD_ICC_ACTIVE) {
+		tmp |= PORT_CMD_ICC_ACTIVE;
+		writel(tmp, port_mmio + PORT_CMD);
+		tmp = readl(port_mmio + PORT_CMD);
+	}
+
+	return 0;
+}
+
+static int ahci_port_standby(void __iomem *port_mmio, u32 cap)
+{
+	u32 tmp, scontrol, sstatus;
+
+	tmp = readl(port_mmio + PORT_CMD);
+	/*
+	 * AHCI Rev1.1 Section 5.3.2.3:
+	 * Software is only allowed to program the PxCMD.FRE,
+	 * PxCMD.POD, PxSCTL.DET, and PxCMD.SUD register bits
+	 * when PxCMD.ST is set to ‘0’.
+	 */
+	if (tmp & PORT_CMD_START)
+		return -EBUSY;
+
+	if (cap & HOST_CAP_SSC) {
+		/*
+		 * Enable transitions to slumber mode
+		 */
+		scontrol = readl(port_mmio + PORT_SCR_CTL);
+		if ((scontrol & 0x0f00) > 0x100) {
+			scontrol &= ~0xf00;
+			writel(scontrol, port_mmio + PORT_SCR_CTL);
+		}
+		/*
+		 * Put device into slumber mode
+		 */
+		tmp |= PORT_CMD_ICC_SLUMBER;
+		writel(tmp, port_mmio + PORT_CMD);
+		tmp = readl(port_mmio + PORT_CMD);
+
+		/*
+		 * Actually, we should wait for the device to
+		 * enter slumber mode by checking
+		 * sstatus & 0xf00 == 6
+		 */
+		sstatus = readl(port_mmio + PORT_SCR_STAT);
+	}
+
+	/*
+	 * Put device into listen mode
+	 */
+	scontrol = readl(port_mmio + PORT_SCR_CTL);
+	scontrol &= ~0xf;
+	writel(scontrol, port_mmio + PORT_SCR_CTL);
+
+	tmp = readl(port_mmio + PORT_CMD);
+	if (cap & HOST_CAP_SSS) {
+		/*
+		 * Spin down the device for staggered spin-up support
+		 */
+		tmp &= ~PORT_CMD_SPIN_UP;
+		writel(tmp, port_mmio + PORT_CMD);
+		readl(port_mmio + PORT_CMD); /* flush */
+	}
+
+	return 0;
+}
+
 static void ahci_phy_reset(struct ata_port *ap)
 {
 	void __iomem *port_mmio = (void __iomem *) ap->ioaddr.cmd_addr;
+	struct ahci_host_priv *hpriv = ap->host_set->private_data;
 	struct ata_taskfile tf;
 	struct ata_device *dev = &ap->device[0];
 	u32 new_tmp, tmp;
@@ -673,8 +848,6 @@ static void ahci_phy_reset(struct ata_po
 	if (ap->flags & ATA_FLAG_PORT_DISABLED)
 		return;
 
-	ahci_start_engine(port_mmio);
-
 	tmp = readl(port_mmio + PORT_SIG);
 	tf.lbah		= (tmp >> 24)	& 0xff;
 	tf.lbam		= (tmp >> 16)	& 0xff;
@@ -683,7 +856,7 @@ static void ahci_phy_reset(struct ata_po
 
 	dev->class = ata_dev_classify(&tf);
 	if (!ata_dev_present(dev)) {
-		ata_port_disable(ap);
+		ap->ops->port_disable(ap);
 		return;
 	}
 
@@ -697,6 +870,10 @@ static void ahci_phy_reset(struct ata_po
 		writel(new_tmp, port_mmio + PORT_CMD);
 		readl(port_mmio + PORT_CMD); /* flush */
 	}
+
+	ahci_start_engine(port_mmio);
+	
+	hpriv->dev_map |= (1 << ap->port_no);
 }
 
 static u8 ahci_check_status(struct ata_port *ap)
@@ -990,7 +1167,7 @@ int ahci_scsi_device_suspend(struct scsi
 	rc = ata_device_suspend(ap, dev, state);
 
 	if (!rc)
-		rc = ahci_port_suspend(ap);
+		rc = ahci_port_suspend(ap, state);
 
 	return rc;
 }
@@ -1005,6 +1182,47 @@ int ahci_scsi_device_resume(struct scsi_
 	return ata_device_resume(ap, dev);
 }
 
+int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	struct device *dev = pci_dev_to_dev(pdev);
+	struct ata_host_set *host_set = dev_get_drvdata(dev);
+	void __iomem *mmio = host_set->mmio_base;
+	u32 tmp;
+
+	/*
+	 * AHCI spec rev1.1 section 8.3.3:
+	 * Software must disable interrupts prior to
+	 * requesting a transition of the HBA to
+	 * D3 state.
+	 */
+	tmp = readl(mmio + HOST_CTL);
+	tmp &= ~HOST_IRQ_EN;
+	writel(tmp, mmio + HOST_CTL);
+	tmp = readl(mmio + HOST_CTL); /* flush */
+
+	return ata_pci_device_suspend(pdev, state);
+}
+
+int ahci_pci_device_resume(struct pci_dev *pdev)
+{
+	struct device *dev = pci_dev_to_dev(pdev);
+	struct ata_host_set *host_set = dev_get_drvdata(dev);
+	void __iomem *mmio = host_set->mmio_base;
+	u32 tmp;
+
+	/*
+	 * Enabling AHCI mode
+	 */
+	tmp = readl(mmio + HOST_CTL);
+	if (!(tmp & HOST_AHCI_EN)) {
+		tmp |= HOST_AHCI_EN;
+		writel(tmp, mmio + HOST_CTL);
+		tmp = readl(mmio + HOST_CTL);
+	}
+
+	return ata_pci_device_resume(pdev);
+}
+
 static void ahci_setup_port(struct ata_ioports *port, unsigned long base,
 			    unsigned int port_idx)
 {
@@ -1029,8 +1247,15 @@ static int ahci_host_init(struct ata_pro
 	void __iomem *port_mmio;
 
 	cap_save = readl(mmio + HOST_CAP);
-	cap_save &= ( (1<<28) | (1<<17) );
-	cap_save |= (1 << 27);
+
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
+		/*
+		 * Intel ICHx specific 
+		 * AHCI spec defines HOST_CAP as R/O
+		 */
+		cap_save &= ( HOST_CAP_SIS | HOST_CAP_SPM );
+		cap_save |= HOST_CAP_SSS;
+	}
 
 	/* global controller reset */
 	tmp = readl(mmio + HOST_CTL);
@@ -1067,6 +1292,7 @@ static int ahci_host_init(struct ata_pro
 
 	hpriv->cap = readl(mmio + HOST_CAP);
 	hpriv->port_map = readl(mmio + HOST_PORTS_IMPL);
+	hpriv->dev_map = 0;
 	probe_ent->n_ports = (hpriv->cap & 0x1f) + 1;
 
 	VPRINTK("cap 0x%x  port_map 0x%x  n_ports %d\n",
@@ -1123,7 +1349,10 @@ static int ahci_host_init(struct ata_pro
 			       i, rc);
 
 		/*
-		 * TODO: port / HBA reset if the above fails
+		 * Actually, this is wrong again.
+		 * AHCI spec says that we first should
+		 * enable FIS reception before sending
+		 * SPIN_UP to the device ...
 		 */
 		writel(PORT_CMD_SPIN_UP, port_mmio + PORT_CMD);
 
@@ -1217,7 +1446,7 @@ static void ahci_print_info(struct ata_p
 	dev_printk(KERN_INFO, &pdev->dev,
 		"flags: "
 	       	"%s%s%s%s%s%s"
-	       	"%s%s%s%s%s%s%s\n"
+	       	"%s%s%s%s%s%s%s%s%s%s\n"
 	       	,
 
 		cap & (1 << 31) ? "64bit " : "",
@@ -1233,7 +1462,10 @@ static void ahci_print_info(struct ata_p
 		cap & (1 << 17) ? "pmp " : "",
 		cap & (1 << 15) ? "pio " : "",
 		cap & (1 << 14) ? "slum " : "",
-		cap & (1 << 13) ? "part " : ""
+		cap & (1 << 13) ? "part " : "",
+		cap & (1 <<  7) ? "coal " : "",
+		cap & (1 <<  6) ? "enc " : "",
+		cap & (1 <<  5) ? "ext " : ""
 		);
 }
 
--- linux-2.6.16/drivers/scsi/libata-core.c~	2006-03-30 13:43:00.000000000 +0200
+++ linux-2.6.16/drivers/scsi/libata-core.c	2006-03-30 15:09:14.000000000 +0200
@@ -1594,14 +1594,14 @@ void __sata_phy_reset(struct ata_port *a
 	} else {
 		printk(KERN_INFO "ata%u: SATA link down (SStatus %X)\n",
 		       ap->id, sstatus);
-		ata_port_disable(ap);
+		ap->ops->port_disable(ap);
 	}
 
 	if (ap->flags & ATA_FLAG_PORT_DISABLED)
 		return;
 
 	if (ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT)) {
-		ata_port_disable(ap);
+		ap->ops->port_disable(ap);
 		return;
 	}
 
@@ -1934,7 +1934,7 @@ static void ata_set_mode(struct ata_port
 	return;
 
 err_out:
-	ata_port_disable(ap);
+	ap->ops->port_disable(ap);
 }
 
 /**
@@ -2425,7 +2425,7 @@ static void ata_dev_set_xfermode(struct 
 	if (ata_exec_internal(ap, dev, &tf, DMA_NONE, NULL, 0)) {
 		printk(KERN_ERR "ata%u: failed to set xfermode, disabled\n",
 		       ap->id);
-		ata_port_disable(ap);
+		ap->ops->port_disable(ap);
 	}
 
 	DPRINTK("EXIT\n");
@@ -2469,7 +2469,7 @@ static void ata_dev_reread_id(struct ata
 	return;
 err_out:
 	printk(KERN_ERR "ata%u: failed to reread ID, disabled\n", ap->id);
-	ata_port_disable(ap);
+	ap->ops->port_disable(ap);
 }
 
 /**
@@ -2503,7 +2503,7 @@ static void ata_dev_init_params(struct a
 	if (ata_exec_internal(ap, dev, &tf, DMA_NONE, NULL, 0)) {
 		printk(KERN_ERR "ata%u: failed to init parameters, disabled\n",
 		       ap->id);
-		ata_port_disable(ap);
+		ap->ops->port_disable(ap);
 	}
 
 	DPRINTK("EXIT\n");
