Return-Path: <kernel-bounces+ak=suse.de@suse.de>
Received: from imap-dhs.suse.de ([unix socket])
	by imap-dhs (Cyrus v2.1.16) with LMTP; Wed, 02 Jun 2004 12:42:42 +0200
X-Sieve: CMU Sieve 2.2
Received: from hermes.suse.de (hermes.suse.de [10.0.0.1])
	(using TLSv1 with cipher EDH-RSA-DES-CBC3-SHA (168/168 bits))
	(Client CN "hermes.suse.de", Issuer "SuSE Linux AG internal IMAP-Server CA" (verified OK))
	by imap-dhs.suse.de (Postfix) with ESMTP id 4FCBA5F89BD
	for <ak@imap-dhs.suse.de>; Wed,  2 Jun 2004 12:42:42 +0200 (CEST)
Received: by hermes.suse.de (Postfix)
	id 2E63869034; Wed,  2 Jun 2004 12:42:42 +0200 (CEST)
Received: from Fourier.suse.de (fourier.suse.de [10.0.0.7])
	by hermes.suse.de (Postfix) with ESMTP id 29FBE69007
	for <ak@suse.de>; Wed,  2 Jun 2004 12:42:42 +0200 (CEST)
Received: from fourier.suse.de (localhost [127.0.0.1])
	by Fourier.suse.de (Postfix) with ESMTP id 1FC34C09187
	for <ak@suse.de>; Wed,  2 Jun 2004 12:42:42 +0200 (CEST)
Received: from hermes.suse.de (hermes.suse.de [10.0.0.1])
	by Fourier.suse.de (Postfix) with ESMTP id 6C334BF86FA
	for <kernel@fourier.suse.de>; Wed,  2 Jun 2004 12:42:35 +0200 (CEST)
Received: by hermes.suse.de (Postfix)
	id 63A8669064; Wed,  2 Jun 2004 12:42:35 +0200 (CEST)
Received: from verdi.suse.de (verdi.suse.de [10.11.0.38])
	by hermes.suse.de (Postfix) with ESMTP id 5E81069087
	for <kernel@suse.de>; Wed,  2 Jun 2004 12:42:35 +0200 (CEST)
Received: by verdi.suse.de (Postfix, from userid 14000)
	id 30E2A9B1558D; Wed,  2 Jun 2004 03:42:35 -0700 (PDT)
To: kernel@suse.de
From: Andi Kleen <ak@suse.de>
Date: 02 Jun 2004 03:42:35 -0700
Message-ID: <p73brk2kzqc.fsf@verdi.suse.de>
Lines: 97
User-Agent: Gnus/5.09 (Gnus v5.9.0) Emacs/21.3
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="=-=-="
Subject: [kernel] [PATCH] Fix signal race during process exit
X-BeenThere: kernel@suse.de
X-Mailman-Version: 2.1.4
Precedence: list
Reply-To: kernel@suse.de
List-Id: Kernel Developers at SuSE <kernel.suse.de>
List-Unsubscribe: <https://mailman.suse.de/mailman/listinfo/kernel>,
	<mailto:kernel-request@suse.de?subject=unsubscribe>
List-Archive: <http://mailman.suse.de/pipermail/kernel>
List-Post: <mailto:kernel@suse.de>
List-Help: <mailto:kernel-request@suse.de?subject=help>
List-Subscribe: <https://mailman.suse.de/mailman/listinfo/kernel>,
	<mailto:kernel-request@suse.de?subject=subscribe>
Sender: kernel-bounces+ak=suse.de@suse.de
Errors-To: kernel-bounces+ak=suse.de@suse.de

--=-=-=


Another bug fix from linux kernel. When a process installed
a SIGPROF timer it could oops because update_process_times
could try to raise an SIGPROF while _exit is running and
has already destroyed the signal state.

This patch avoids this

Any objections to installing that one?

Less obivous that the other patches, but the change is quite riskless
(in the worst case it doesn't plug the race, but it is unlikely
to cause new problems)


--=-=-=
Content-Type: message/rfc822
Content-Disposition: inline

From: Jeremy Kerr <jeremy@redfishsoftware.com.au>
Subject: Re: [PATCH] Fix signal race during process exit
Date: Wed, 2 Jun 2004 08:20:53 +0000 (UTC)
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii

> Andrew Morton <akpm@osdl.org> wrote:
> > yes?
>
> no.  It needs tasklist_lock as well, to keep the other CPU (which is doing
> wait4) at bay.

almost:

> +	tsk->it_virt_incr = 0;
> +	tsk->it_prof_value = 0;

If we're using this approach, we also need to deal with the send_sig() calls 
in do_process_times():

	if (psecs / HZ > p->rlim[RLIMIT_CPU].rlim_cur) {
		/* Send SIGXCPU every second.. */
		if (!(psecs % HZ))
			send_sig(SIGXCPU, p, 1);
		/* and SIGKILL when we go over max.. */
		if (psecs / HZ > p->rlim[RLIMIT_CPU].rlim_max)
			send_sig(SIGKILL, p, 1);
	}

by setting rlim_cur to RLIM_INFINITY.



Fix a race identified by Jeremy Kerr <jeremy@redfishsoftware.com.au>: if
update_process_times() decides to deliver a signal due to process timer
expiry, it can race with __exit_sighand()'s freeing of task->sighand.

Fix that by clearing the per-process timer state in exit_notify(), while under
local_irq_disable() and under tasklist_lock.  tasklist_lock provides exclusion
wrt release_task()'s freeing of task->sighand and local_irq_disable() provides
exclusion wrt update_process_times()'s inspection of the per-process timer
state.

Signed-off-by: Andrew Morton <akpm@osdl.org>
Signed-off-by: Jeremy Kerr <jk@ozlabs.org>


diff -urN --exclude '.*.sw[op]' linux-2.6.7-rc2-bk2.orig/kernel/exit.c 
linux-2.6.7-rc2-bk2/kernel/exit.c
--- linux-2.6.7-rc2-bk2.orig/kernel/exit.c	2004-06-02 11:29:13.000000000 +1000
+++ linux-2.6.7-rc2-bk2/kernel/exit.c	2004-06-02 18:02:05.000000000 +1000
@@ -736,6 +736,14 @@
 	tsk->state = state;
 	tsk->flags |= PF_DEAD;
 
+	/*
+	 * Clear these here so that update_process_times() won't try to deliver
+	 * itimer, profile or rlimit signals to this task while it is in late exit.
+	 */
+	tsk->it_virt_incr = 0;
+	tsk->it_prof_value = 0;
+	tsk->rlim[RLIMIT_CPU].rlim_cur = RLIM_INFINITY;
+
 	/*
 	 * In the preemption case it must be impossible for the task
 	 * to get runnable again, so use "_raw_" unlock to keep



Jeremy







-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/


--=-=-=--
