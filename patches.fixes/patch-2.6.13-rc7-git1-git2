Subject: patch-2.6.13-rc7-git2
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

diff -purN linux-2.6.13-rc7-git1/Makefile linux-2.6.13-rc7-git2/Makefile
--- linux-2.6.13-rc7-git1/Makefile	2005-08-27 12:24:24.255647390 +0200
+++ linux-2.6.13-rc7-git2/Makefile	2005-08-27 12:24:32.048631925 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 13
-EXTRAVERSION = -rc7-git1
+EXTRAVERSION = -rc7-git2
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.13-rc7-git1/arch/arm/mach-ixp4xx/coyote-setup.c linux-2.6.13-rc7-git2/arch/arm/mach-ixp4xx/coyote-setup.c
--- linux-2.6.13-rc7-git1/arch/arm/mach-ixp4xx/coyote-setup.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/arch/arm/mach-ixp4xx/coyote-setup.c	2005-08-27 12:24:32.049631770 +0200
@@ -36,7 +36,7 @@ static struct flash_platform_data coyote
 
 static struct resource coyote_flash_resource = {
 	.start		= COYOTE_FLASH_BASE,
-	.end		= COYOTE_FLASH_BASE + COYOTE_FLASH_SIZE,
+	.end		= COYOTE_FLASH_BASE + COYOTE_FLASH_SIZE - 1,
 	.flags		= IORESOURCE_MEM,
 };
 
diff -purN linux-2.6.13-rc7-git1/arch/arm/mach-ixp4xx/gtwx5715-setup.c linux-2.6.13-rc7-git2/arch/arm/mach-ixp4xx/gtwx5715-setup.c
--- linux-2.6.13-rc7-git1/arch/arm/mach-ixp4xx/gtwx5715-setup.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/arch/arm/mach-ixp4xx/gtwx5715-setup.c	2005-08-27 12:24:32.050631614 +0200
@@ -114,7 +114,7 @@ static struct flash_platform_data gtwx57
 
 static struct resource gtwx5715_flash_resource = {
 	.start		= GTWX5715_FLASH_BASE,
-	.end		= GTWX5715_FLASH_BASE + GTWX5715_FLASH_SIZE,
+	.end		= GTWX5715_FLASH_BASE + GTWX5715_FLASH_SIZE - 1,
 	.flags		= IORESOURCE_MEM,
 };
 
diff -purN linux-2.6.13-rc7-git1/arch/arm/mach-ixp4xx/ixdp425-setup.c linux-2.6.13-rc7-git2/arch/arm/mach-ixp4xx/ixdp425-setup.c
--- linux-2.6.13-rc7-git1/arch/arm/mach-ixp4xx/ixdp425-setup.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/arch/arm/mach-ixp4xx/ixdp425-setup.c	2005-08-27 12:24:32.056630681 +0200
@@ -36,7 +36,7 @@ static struct flash_platform_data ixdp42
 
 static struct resource ixdp425_flash_resource = {
 	.start		= IXDP425_FLASH_BASE,
-	.end		= IXDP425_FLASH_BASE + IXDP425_FLASH_SIZE,
+	.end		= IXDP425_FLASH_BASE + IXDP425_FLASH_SIZE - 1,
 	.flags		= IORESOURCE_MEM,
 };
 
diff -purN linux-2.6.13-rc7-git1/arch/ppc/syslib/m8xx_setup.c linux-2.6.13-rc7-git2/arch/ppc/syslib/m8xx_setup.c
--- linux-2.6.13-rc7-git1/arch/ppc/syslib/m8xx_setup.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/arch/ppc/syslib/m8xx_setup.c	2005-08-27 12:24:32.062629747 +0200
@@ -423,7 +423,7 @@ platform_init(unsigned long r3, unsigned
 	ppc_md.find_end_of_memory	= m8xx_find_end_of_memory;
 	ppc_md.setup_io_mappings	= m8xx_map_io;
 
-#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
+#if defined(CONFIG_BLK_DEV_MPC8xx_IDE)
 	m8xx_ide_init();
 #endif
 }
diff -purN linux-2.6.13-rc7-git1/arch/x86_64/kernel/e820.c linux-2.6.13-rc7-git2/arch/x86_64/kernel/e820.c
--- linux-2.6.13-rc7-git1/arch/x86_64/kernel/e820.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/arch/x86_64/kernel/e820.c	2005-08-27 12:24:32.074627881 +0200
@@ -185,6 +185,40 @@ unsigned long __init e820_end_of_ram(voi
 }
 
 /* 
+ * Compute how much memory is missing in a range.
+ * Unlike the other functions in this file the arguments are in page numbers.
+ */
+unsigned long __init
+e820_hole_size(unsigned long start_pfn, unsigned long end_pfn)
+{
+	unsigned long ram = 0;
+	unsigned long start = start_pfn << PAGE_SHIFT;
+	unsigned long end = end_pfn << PAGE_SHIFT;
+	int i;
+	for (i = 0; i < e820.nr_map; i++) {
+		struct e820entry *ei = &e820.map[i];
+		unsigned long last, addr;
+
+		if (ei->type != E820_RAM ||
+		    ei->addr+ei->size <= start ||
+		    ei->addr >= end)
+			continue;
+
+		addr = round_up(ei->addr, PAGE_SIZE);
+		if (addr < start)
+			addr = start;
+
+		last = round_down(ei->addr + ei->size, PAGE_SIZE);
+		if (last >= end)
+			last = end;
+
+		if (last > addr)
+			ram += last - addr;
+	}
+	return ((end - start) - ram) >> PAGE_SHIFT;
+}
+
+/*
  * Mark e820 reserved areas as busy for the resource manager.
  */
 void __init e820_reserve_resources(void)
diff -purN linux-2.6.13-rc7-git1/arch/x86_64/mm/init.c linux-2.6.13-rc7-git2/arch/x86_64/mm/init.c
--- linux-2.6.13-rc7-git1/arch/x86_64/mm/init.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/arch/x86_64/mm/init.c	2005-08-27 12:24:32.079627103 +0200
@@ -322,18 +322,26 @@ void zap_low_mappings(void)
 void __init paging_init(void)
 {
 	{
-		unsigned long zones_size[MAX_NR_ZONES] = {0, 0, 0};
+		unsigned long zones_size[MAX_NR_ZONES];
+		unsigned long holes[MAX_NR_ZONES];
 		unsigned int max_dma;
 
+		memset(zones_size, 0, sizeof(zones_size));
+		memset(holes, 0, sizeof(holes));
+
 		max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
 
-		if (end_pfn < max_dma)
+		if (end_pfn < max_dma) {
 			zones_size[ZONE_DMA] = end_pfn;
-		else {
+			holes[ZONE_DMA] = e820_hole_size(0, end_pfn);
+		} else {
 			zones_size[ZONE_DMA] = max_dma;
+			holes[ZONE_DMA] = e820_hole_size(0, max_dma);
 			zones_size[ZONE_NORMAL] = end_pfn - max_dma;
+			holes[ZONE_NORMAL] = e820_hole_size(max_dma, end_pfn);
 		}
-		free_area_init(zones_size);
+		free_area_init_node(0, NODE_DATA(0), zones_size,
+                        __pa(PAGE_OFFSET) >> PAGE_SHIFT, holes);
 	}
 	return;
 }
diff -purN linux-2.6.13-rc7-git1/arch/x86_64/mm/numa.c linux-2.6.13-rc7-git2/arch/x86_64/mm/numa.c
--- linux-2.6.13-rc7-git1/arch/x86_64/mm/numa.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/arch/x86_64/mm/numa.c	2005-08-27 12:24:32.080626947 +0200
@@ -126,9 +126,11 @@ void __init setup_node_zones(int nodeid)
 { 
 	unsigned long start_pfn, end_pfn; 
 	unsigned long zones[MAX_NR_ZONES];
+	unsigned long holes[MAX_NR_ZONES];
 	unsigned long dma_end_pfn;
 
 	memset(zones, 0, sizeof(unsigned long) * MAX_NR_ZONES); 
+	memset(holes, 0, sizeof(unsigned long) * MAX_NR_ZONES);
 
 	start_pfn = node_start_pfn(nodeid);
 	end_pfn = node_end_pfn(nodeid);
@@ -139,13 +141,17 @@ void __init setup_node_zones(int nodeid)
 	dma_end_pfn = __pa(MAX_DMA_ADDRESS) >> PAGE_SHIFT; 
 	if (start_pfn < dma_end_pfn) { 
 		zones[ZONE_DMA] = dma_end_pfn - start_pfn;
+		holes[ZONE_DMA] = e820_hole_size(start_pfn, dma_end_pfn);
 		zones[ZONE_NORMAL] = end_pfn - dma_end_pfn; 
+		holes[ZONE_NORMAL] = e820_hole_size(dma_end_pfn, end_pfn);
+
 	} else { 
 		zones[ZONE_NORMAL] = end_pfn - start_pfn; 
+		holes[ZONE_NORMAL] = e820_hole_size(start_pfn, end_pfn);
 	} 
     
 	free_area_init_node(nodeid, NODE_DATA(nodeid), zones,
-			    start_pfn, NULL); 
+			    start_pfn, holes);
 } 
 
 void __init numa_init_array(void)
diff -purN linux-2.6.13-rc7-git1/drivers/hwmon/adm1026.c linux-2.6.13-rc7-git2/drivers/hwmon/adm1026.c
--- linux-2.6.13-rc7-git1/drivers/hwmon/adm1026.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/hwmon/adm1026.c	2005-08-27 12:24:32.100623836 +0200
@@ -325,7 +325,7 @@ int adm1026_attach_adapter(struct i2c_ad
 int adm1026_detach_client(struct i2c_client *client)
 {
 	i2c_detach_client(client);
-	kfree(client);
+	kfree(i2c_get_clientdata(client));
 	return 0;
 }
 
@@ -1691,7 +1691,7 @@ int adm1026_detect(struct i2c_adapter *a
 
 	/* Error out and cleanup code */
 exitfree:
-	kfree(new_client);
+	kfree(data);
 exit:
 	return err;
 }
diff -purN linux-2.6.13-rc7-git1/drivers/hwmon/adm1031.c linux-2.6.13-rc7-git2/drivers/hwmon/adm1031.c
--- linux-2.6.13-rc7-git1/drivers/hwmon/adm1031.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/hwmon/adm1031.c	2005-08-27 12:24:32.103623369 +0200
@@ -834,7 +834,7 @@ static int adm1031_detect(struct i2c_ada
 	return 0;
 
 exit_free:
-	kfree(new_client);
+	kfree(data);
 exit:
 	return err;
 }
@@ -845,7 +845,7 @@ static int adm1031_detach_client(struct 
 	if ((ret = i2c_detach_client(client)) != 0) {
 		return ret;
 	}
-	kfree(client);
+	kfree(i2c_get_clientdata(client));
 	return 0;
 }
 
diff -purN linux-2.6.13-rc7-git1/drivers/hwmon/adm9240.c linux-2.6.13-rc7-git2/drivers/hwmon/adm9240.c
--- linux-2.6.13-rc7-git1/drivers/hwmon/adm9240.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/hwmon/adm9240.c	2005-08-27 12:24:32.110622280 +0200
@@ -616,7 +616,7 @@ static int adm9240_detect(struct i2c_ada
 
 	return 0;
 exit_free:
-	kfree(new_client);
+	kfree(data);
 exit:
 	return err;
 }
diff -purN linux-2.6.13-rc7-git1/drivers/hwmon/fscpos.c linux-2.6.13-rc7-git2/drivers/hwmon/fscpos.c
--- linux-2.6.13-rc7-git1/drivers/hwmon/fscpos.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/hwmon/fscpos.c	2005-08-27 12:24:32.113621813 +0200
@@ -167,7 +167,7 @@ static ssize_t set_temp_reset(struct i2c
 				"experience to the module author.\n");
 
 	/* Supported value: 2 (clears the status) */
-	fscpos_write_value(client, FSCPOS_REG_TEMP_STATE[nr], 2);
+	fscpos_write_value(client, FSCPOS_REG_TEMP_STATE[nr - 1], 2);
 	return count;
 }
 
diff -purN linux-2.6.13-rc7-git1/drivers/hwmon/smsc47b397.c linux-2.6.13-rc7-git2/drivers/hwmon/smsc47b397.c
--- linux-2.6.13-rc7-git1/drivers/hwmon/smsc47b397.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/hwmon/smsc47b397.c	2005-08-27 12:24:32.119620880 +0200
@@ -298,7 +298,7 @@ static int smsc47b397_detect(struct i2c_
 	return 0;
 
 error_free:
-	kfree(new_client);
+	kfree(data);
 error_release:
 	release_region(addr, SMSC_EXTENT);
 	return err;
diff -purN linux-2.6.13-rc7-git1/drivers/hwmon/smsc47m1.c linux-2.6.13-rc7-git2/drivers/hwmon/smsc47m1.c
--- linux-2.6.13-rc7-git1/drivers/hwmon/smsc47m1.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/hwmon/smsc47m1.c	2005-08-27 12:24:32.121620569 +0200
@@ -495,7 +495,7 @@ static int smsc47m1_detect(struct i2c_ad
 	return 0;
 
 error_free:
-	kfree(new_client);
+	kfree(data);
 error_release:
 	release_region(address, SMSC_EXTENT);
 	return err;
diff -purN linux-2.6.13-rc7-git1/drivers/ieee1394/ohci1394.c linux-2.6.13-rc7-git2/drivers/ieee1394/ohci1394.c
--- linux-2.6.13-rc7-git1/drivers/ieee1394/ohci1394.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/ieee1394/ohci1394.c	2005-08-27 12:24:32.132618857 +0200
@@ -478,7 +478,6 @@ static void ohci_initialize(struct ti_oh
 	int num_ports, i;
 
 	spin_lock_init(&ohci->phy_reg_lock);
-	spin_lock_init(&ohci->event_lock);
 
 	/* Put some defaults to these undefined bus options */
 	buf = reg_read(ohci, OHCI1394_BusOptions);
@@ -3402,7 +3401,14 @@ static int __devinit ohci1394_pci_probe(
 	/* We hopefully don't have to pre-allocate IT DMA like we did
 	 * for IR DMA above. Allocate it on-demand and mark inactive. */
 	ohci->it_legacy_context.ohci = NULL;
+	spin_lock_init(&ohci->event_lock);
 
+	/*
+	 * interrupts are disabled, all right, but... due to SA_SHIRQ we
+	 * might get called anyway.  We'll see no event, of course, but
+	 * we need to get to that "no event", so enough should be initialized
+	 * by that point.
+	 */
 	if (request_irq(dev->irq, ohci_irq_handler, SA_SHIRQ,
 			 OHCI1394_DRIVER_NAME, ohci))
 		FAIL(-ENOMEM, "Failed to allocate shared interrupt %d", dev->irq);
diff -purN linux-2.6.13-rc7-git1/drivers/infiniband/core/uverbs_main.c linux-2.6.13-rc7-git2/drivers/infiniband/core/uverbs_main.c
--- linux-2.6.13-rc7-git1/drivers/infiniband/core/uverbs_main.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/infiniband/core/uverbs_main.c	2005-08-27 12:24:32.140617613 +0200
@@ -130,13 +130,14 @@ static int ib_dealloc_ucontext(struct ib
 
 	list_for_each_entry_safe(uobj, tmp, &context->mr_list, list) {
 		struct ib_mr *mr = idr_find(&ib_uverbs_mr_idr, uobj->id);
+		struct ib_device *mrdev = mr->device;
 		struct ib_umem_object *memobj;
 
 		idr_remove(&ib_uverbs_mr_idr, uobj->id);
 		ib_dereg_mr(mr);
 
 		memobj = container_of(uobj, struct ib_umem_object, uobject);
-		ib_umem_release_on_close(mr->device, &memobj->umem);
+		ib_umem_release_on_close(mrdev, &memobj->umem);
 
 		list_del(&uobj->list);
 		kfree(memobj);
diff -purN linux-2.6.13-rc7-git1/drivers/md/md.c linux-2.6.13-rc7-git2/drivers/md/md.c
--- linux-2.6.13-rc7-git1/drivers/md/md.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/md/md.c	2005-08-27 12:24:32.151615901 +0200
@@ -1689,6 +1689,7 @@ static int do_md_run(mddev_t * mddev)
 	mddev->pers = pers[pnum];
 	spin_unlock(&pers_lock);
 
+	mddev->recovery = 0;
 	mddev->resync_max_sectors = mddev->size << 1; /* may be over-ridden by personality */
 
 	/* before we start the array running, initialise the bitmap */
@@ -4011,3 +4012,4 @@ EXPORT_SYMBOL(md_print_devices);
 EXPORT_SYMBOL(md_check_recovery);
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("md");
+MODULE_ALIAS_BLOCKDEV_MAJOR(MD_MAJOR);
diff -purN linux-2.6.13-rc7-git1/drivers/net/ibm_emac/ibm_emac_core.c linux-2.6.13-rc7-git2/drivers/net/ibm_emac/ibm_emac_core.c
--- linux-2.6.13-rc7-git1/drivers/net/ibm_emac/ibm_emac_core.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/net/ibm_emac/ibm_emac_core.c	2005-08-27 12:24:32.160614501 +0200
@@ -1253,7 +1253,7 @@ static int emac_init_tah(struct ocp_enet
 		 TAH_MR_CVR | TAH_MR_ST_768 | TAH_MR_TFS_10KB | TAH_MR_DTFP |
 		 TAH_MR_DIG);
 
-	iounmap(&tahp);
+	iounmap(tahp);
 
 	return 0;
 }
diff -purN linux-2.6.13-rc7-git1/drivers/net/tg3.c linux-2.6.13-rc7-git2/drivers/net/tg3.c
--- linux-2.6.13-rc7-git1/drivers/net/tg3.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/net/tg3.c	2005-08-27 12:24:32.185610612 +0200
@@ -66,8 +66,8 @@
 
 #define DRV_MODULE_NAME		"tg3"
 #define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"3.36"
-#define DRV_MODULE_RELDATE	"August 19, 2005"
+#define DRV_MODULE_VERSION	"3.37"
+#define DRV_MODULE_RELDATE	"August 25, 2005"
 
 #define TG3_DEF_MAC_MODE	0
 #define TG3_DEF_RX_MODE		0
@@ -7865,8 +7865,6 @@ static int tg3_test_loopback(struct tg3 
 
 	err = -EIO;
 
-	tg3_abort_hw(tp, 1);
-
 	tg3_reset_hw(tp);
 
 	mac_mode = (tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK) |
diff -purN linux-2.6.13-rc7-git1/drivers/pci/setup-bus.c linux-2.6.13-rc7-git2/drivers/pci/setup-bus.c
--- linux-2.6.13-rc7-git1/drivers/pci/setup-bus.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/pci/setup-bus.c	2005-08-27 12:24:32.196608901 +0200
@@ -40,7 +40,7 @@
  * FIXME: IO should be max 256 bytes.  However, since we may
  * have a P2P bridge below a cardbus bridge, we need 4K.
  */
-#define CARDBUS_IO_SIZE		(4096)
+#define CARDBUS_IO_SIZE		(256)
 #define CARDBUS_MEM_SIZE	(32*1024*1024)
 
 static void __devinit
diff -purN linux-2.6.13-rc7-git1/drivers/pci/setup-res.c linux-2.6.13-rc7-git2/drivers/pci/setup-res.c
--- linux-2.6.13-rc7-git1/drivers/pci/setup-res.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/pci/setup-res.c	2005-08-27 12:24:32.197608745 +0200
@@ -53,7 +53,9 @@ pci_update_resource(struct pci_dev *dev,
 	if (resno < 6) {
 		reg = PCI_BASE_ADDRESS_0 + 4 * resno;
 	} else if (resno == PCI_ROM_RESOURCE) {
-		new |= res->flags & IORESOURCE_ROM_ENABLE;
+		if (!(res->flags & IORESOURCE_ROM_ENABLE))
+			return;
+		new |= PCI_ROM_ADDRESS_ENABLE;
 		reg = dev->rom_base_reg;
 	} else {
 		/* Hmm, non-standard resource. */
diff -purN linux-2.6.13-rc7-git1/drivers/s390/cio/qdio.c linux-2.6.13-rc7-git2/drivers/s390/cio/qdio.c
--- linux-2.6.13-rc7-git1/drivers/s390/cio/qdio.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/drivers/s390/cio/qdio.c	2005-08-27 12:24:32.209606878 +0200
@@ -112,7 +112,7 @@ qdio_min(int a,int b)
 
 /***************** SCRUBBER HELPER ROUTINES **********************/
 
-static inline volatile __u64 
+static inline __u64 
 qdio_get_micros(void)
 {
         return (get_clock() >> 10); /* time>>12 is microseconds */
diff -purN linux-2.6.13-rc7-git1/fs/cifs/file.c linux-2.6.13-rc7-git2/fs/cifs/file.c
--- linux-2.6.13-rc7-git1/fs/cifs/file.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/fs/cifs/file.c	2005-08-27 12:24:32.223604700 +0200
@@ -643,7 +643,7 @@ int cifs_lock(struct file *file, int cmd
 			 netfid, length,
 			 pfLock->fl_start, numUnlock, numLock, lockType,
 			 wait_flag);
-	if (rc == 0 && (pfLock->fl_flags & FL_POSIX))
+	if (pfLock->fl_flags & FL_POSIX)
 		posix_lock_file_wait(file, pfLock);
 	FreeXid(xid);
 	return rc;
diff -purN linux-2.6.13-rc7-git1/fs/hppfs/hppfs_kern.c linux-2.6.13-rc7-git2/fs/hppfs/hppfs_kern.c
--- linux-2.6.13-rc7-git1/fs/hppfs/hppfs_kern.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/fs/hppfs/hppfs_kern.c	2005-08-27 12:24:32.229603767 +0200
@@ -38,7 +38,7 @@ struct hppfs_inode_info {
 
 static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)
 {
-	return(list_entry(inode, struct hppfs_inode_info, vfs_inode));
+	return container_of(inode, struct hppfs_inode_info, vfs_inode);
 }
 
 #define HPPFS_SUPER_MAGIC 0xb00000ee
@@ -662,42 +662,36 @@ static int hppfs_readlink(struct dentry 
 {
 	struct file *proc_file;
 	struct dentry *proc_dentry;
-	int (*readlink)(struct dentry *, char *, int);
-	int err, n;
+	int ret;
 
 	proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;
 	proc_file = dentry_open(dget(proc_dentry), NULL, O_RDONLY);
-	err = PTR_ERR(proc_dentry);
-	if(IS_ERR(proc_dentry))
-		return(err);
+	if (IS_ERR(proc_file))
+		return PTR_ERR(proc_file);
 
-	readlink = proc_dentry->d_inode->i_op->readlink;
-	n = (*readlink)(proc_dentry, buffer, buflen);
+	ret = proc_dentry->d_inode->i_op->readlink(proc_dentry, buffer, buflen);
 
 	fput(proc_file);
 
-	return(n);
+	return ret;
 }
 
-static int hppfs_follow_link(struct dentry *dentry, struct nameidata *nd)
+static void* hppfs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
 	struct file *proc_file;
 	struct dentry *proc_dentry;
-	int (*follow_link)(struct dentry *, struct nameidata *);
-	int err, n;
+	void *ret;
 
 	proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;
 	proc_file = dentry_open(dget(proc_dentry), NULL, O_RDONLY);
-	err = PTR_ERR(proc_dentry);
-	if(IS_ERR(proc_dentry))
-		return(err);
+	if (IS_ERR(proc_file))
+		return proc_file;
 
-	follow_link = proc_dentry->d_inode->i_op->follow_link;
-	n = (*follow_link)(proc_dentry, nd);
+	ret = proc_dentry->d_inode->i_op->follow_link(proc_dentry, nd);
 
 	fput(proc_file);
 
-	return(n);
+	return ret;
 }
 
 static struct inode_operations hppfs_dir_iops = {
diff -purN linux-2.6.13-rc7-git1/fs/inotify.c linux-2.6.13-rc7-git2/fs/inotify.c
--- linux-2.6.13-rc7-git1/fs/inotify.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/fs/inotify.c	2005-08-27 12:24:32.231603455 +0200
@@ -353,7 +353,7 @@ static int inotify_dev_get_wd(struct ino
 	do {
 		if (unlikely(!idr_pre_get(&dev->idr, GFP_KERNEL)))
 			return -ENOSPC;
-		ret = idr_get_new_above(&dev->idr, watch, dev->last_wd, &watch->wd);
+		ret = idr_get_new_above(&dev->idr, watch, dev->last_wd+1, &watch->wd);
 	} while (ret == -EAGAIN);
 
 	return ret;
diff -purN linux-2.6.13-rc7-git1/fs/sysfs/inode.c linux-2.6.13-rc7-git2/fs/sysfs/inode.c
--- linux-2.6.13-rc7-git1/fs/sysfs/inode.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/fs/sysfs/inode.c	2005-08-27 12:24:32.235602833 +0200
@@ -228,6 +228,10 @@ void sysfs_hash_and_remove(struct dentry
 	struct sysfs_dirent * sd;
 	struct sysfs_dirent * parent_sd = dir->d_fsdata;
 
+	if (dir->d_inode == NULL)
+		/* no inode means this hasn't been made visible yet */
+		return;
+
 	down(&dir->d_inode->i_sem);
 	list_for_each_entry(sd, &parent_sd->s_children, s_sibling) {
 		if (!sd->s_element)
diff -purN linux-2.6.13-rc7-git1/include/asm-ppc64/bug.h linux-2.6.13-rc7-git2/include/asm-ppc64/bug.h
--- linux-2.6.13-rc7-git1/include/asm-ppc64/bug.h	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/include/asm-ppc64/bug.h	2005-08-27 12:24:32.237602522 +0200
@@ -43,8 +43,8 @@ struct bug_entry *find_bug(unsigned long
 		".section __bug_table,\"a\"\n\t"		\
 		"	.llong 1b,%1,%2,%3\n"			\
 		".previous"					\
-		: : "r" (x), "i" (__LINE__), "i" (__FILE__),	\
-		    "i" (__FUNCTION__));			\
+		: : "r" ((long long)(x)), "i" (__LINE__),	\
+		    "i" (__FILE__), "i" (__FUNCTION__));	\
 } while (0)
 
 #define WARN_ON(x) do {						\
@@ -53,7 +53,8 @@ struct bug_entry *find_bug(unsigned long
 		".section __bug_table,\"a\"\n\t"		\
 		"	.llong 1b,%1,%2,%3\n"			\
 		".previous"					\
-		: : "r" (x), "i" (__LINE__ + BUG_WARNING_TRAP),	\
+		: : "r" ((long long)(x)),			\
+		    "i" (__LINE__ + BUG_WARNING_TRAP),		\
 		    "i" (__FILE__), "i" (__FUNCTION__));	\
 } while (0)
 
diff -purN linux-2.6.13-rc7-git1/include/asm-x86_64/e820.h linux-2.6.13-rc7-git2/include/asm-x86_64/e820.h
--- linux-2.6.13-rc7-git1/include/asm-x86_64/e820.h	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/include/asm-x86_64/e820.h	2005-08-27 12:24:32.238602366 +0200
@@ -51,6 +51,8 @@ extern int e820_mapped(unsigned long sta
 
 extern void e820_bootmem_free(pg_data_t *pgdat, unsigned long start,unsigned long end);
 extern void e820_setup_gap(void);
+extern unsigned long e820_hole_size(unsigned long start_pfn,
+				    unsigned long end_pfn);
 
 extern void __init parse_memopt(char *p, char **end);
 
diff -purN linux-2.6.13-rc7-git1/kernel/cpuset.c linux-2.6.13-rc7-git2/kernel/cpuset.c
--- linux-2.6.13-rc7-git1/kernel/cpuset.c	2005-08-27 12:24:24.308639144 +0200
+++ linux-2.6.13-rc7-git2/kernel/cpuset.c	2005-08-27 12:24:32.241601900 +0200
@@ -627,6 +627,14 @@ static int validate_change(const struct 
  * Call with cpuset_sem held.  May nest a call to the
  * lock_cpu_hotplug()/unlock_cpu_hotplug() pair.
  */
+
+/*
+ * Hack to avoid 2.6.13 partial node dynamic sched domain bug.
+ * Disable letting 'cpu_exclusive' cpusets define dynamic sched
+ * domains, until the sched domain can handle partial nodes.
+ * Remove this #if hackery when sched domains fixed.
+ */
+#if 0
 static void update_cpu_domains(struct cpuset *cur)
 {
 	struct cpuset *c, *par = cur->parent;
@@ -636,25 +644,6 @@ static void update_cpu_domains(struct cp
 		return;
 
 	/*
-	 * Hack to avoid 2.6.13 partial node dynamic sched domain bug.
-	 * Require the 'cpu_exclusive' cpuset to include all (or none)
-	 * of the CPUs on each node, or return w/o changing sched domains.
-	 * Remove this hack when dynamic sched domains fixed.
-	 */
-	{
-		int i, j;
-
-		for_each_cpu_mask(i, cur->cpus_allowed) {
-			cpumask_t mask = node_to_cpumask(cpu_to_node(i));
-
-			for_each_cpu_mask(j, mask) {
-				if (!cpu_isset(j, cur->cpus_allowed))
-					return;
-			}
-		}
-	}
-
-	/*
 	 * Get all cpus from parent's cpus_allowed not part of exclusive
 	 * children
 	 */
@@ -686,6 +675,11 @@ static void update_cpu_domains(struct cp
 	partition_sched_domains(&pspan, &cspan);
 	unlock_cpu_hotplug();
 }
+#else
+static void update_cpu_domains(struct cpuset *cur)
+{
+}
+#endif
 
 static int update_cpumask(struct cpuset *cs, char *buf)
 {
diff -purN linux-2.6.13-rc7-git1/lib/idr.c linux-2.6.13-rc7-git2/lib/idr.c
--- linux-2.6.13-rc7-git1/lib/idr.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/lib/idr.c	2005-08-27 12:24:32.247600966 +0200
@@ -207,7 +207,7 @@ build_up:
 }
 
 /**
- * idr_get_new_above - allocate new idr entry above a start id
+ * idr_get_new_above - allocate new idr entry above or equal to a start id
  * @idp: idr handle
  * @ptr: pointer you want associated with the ide
  * @start_id: id to start search at
diff -purN linux-2.6.13-rc7-git1/net/ipv4/fib_trie.c linux-2.6.13-rc7-git2/net/ipv4/fib_trie.c
--- linux-2.6.13-rc7-git1/net/ipv4/fib_trie.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git2/net/ipv4/fib_trie.c	2005-08-27 12:24:32.258599255 +0200
@@ -1333,9 +1333,9 @@ err:;
 }
 
 static inline int check_leaf(struct trie *t, struct leaf *l,  t_key key, int *plen, const struct flowi *flp,
-			     struct fib_result *res, int *err)
+			     struct fib_result *res)
 {
-	int i;
+	int err, i;
 	t_key mask;
 	struct leaf_info *li;
 	struct hlist_head *hhead = &l->list;
@@ -1348,18 +1348,18 @@ static inline int check_leaf(struct trie
 		if (l->key != (key & mask))
 			continue;
 
-		if (((*err) = fib_semantic_match(&li->falh, flp, res, l->key, mask, i)) == 0) {
+		if ((err = fib_semantic_match(&li->falh, flp, res, l->key, mask, i)) <= 0) {
 			*plen = i;
 #ifdef CONFIG_IP_FIB_TRIE_STATS
 			t->stats.semantic_match_passed++;
 #endif
-			return 1;
+			return err;
 		}
 #ifdef CONFIG_IP_FIB_TRIE_STATS
 		t->stats.semantic_match_miss++;
 #endif
 	}
-	return 0;
+	return 1;
 }
 
 static int
@@ -1386,7 +1386,7 @@ fn_trie_lookup(struct fib_table *tb, con
 
 	/* Just a leaf? */
 	if (IS_LEAF(n)) {
-		if (check_leaf(t, (struct leaf *)n, key, &plen, flp, res, &ret))
+		if ((ret = check_leaf(t, (struct leaf *)n, key, &plen, flp, res)) <= 0)
 			goto found;
 		goto failed;
 	}
@@ -1508,7 +1508,7 @@ fn_trie_lookup(struct fib_table *tb, con
 		       continue;
 		}
 		if (IS_LEAF(n)) {
-			if (check_leaf(t, (struct leaf *)n, key, &plen, flp, res, &ret))
+			if ((ret = check_leaf(t, (struct leaf *)n, key, &plen, flp, res)) <= 0)
 				goto found;
 	       }
 backtrace:
