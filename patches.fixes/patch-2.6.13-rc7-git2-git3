Subject: patch-2.6.13-rc7-git3
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

diff -purN linux-2.6.13-rc7-git2/Makefile linux-2.6.13-rc7-git3/Makefile
--- linux-2.6.13-rc7-git2/Makefile	2005-08-27 12:24:32.000000000 +0200
+++ linux-2.6.13-rc7-git3/Makefile	2005-08-28 12:05:38.560598440 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 13
-EXTRAVERSION = -rc7-git2
+EXTRAVERSION = -rc7-git3
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.13-rc7-git2/arch/um/drivers/mmapper_kern.c linux-2.6.13-rc7-git3/arch/um/drivers/mmapper_kern.c
--- linux-2.6.13-rc7-git2/arch/um/drivers/mmapper_kern.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/arch/um/drivers/mmapper_kern.c	2005-08-28 12:05:38.571596744 +0200
@@ -9,19 +9,11 @@
  *
  */
 
-#include <linux/types.h>
-#include <linux/kdev_t.h>
-#include <linux/time.h>
-#include <linux/devfs_fs_kernel.h>
+#include <linux/init.h> 
 #include <linux/module.h>
 #include <linux/mm.h> 
-#include <linux/slab.h>
-#include <linux/init.h> 
-#include <linux/smp_lock.h>
 #include <linux/miscdevice.h>
 #include <asm/uaccess.h>
-#include <asm/irq.h>
-#include <asm/pgtable.h>
 #include "mem_user.h"
 #include "user_util.h"
  
@@ -31,35 +23,22 @@ static unsigned long p_buf = 0;
 static char *v_buf = NULL;
 
 static ssize_t
-mmapper_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+mmapper_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 {
-	if(*ppos > mmapper_size)
-		return -EINVAL;
-
-	if(count + *ppos > mmapper_size)
-		count = count + *ppos - mmapper_size;
-
-	if(count < 0)
-		return -EINVAL;
- 
-	copy_to_user(buf,&v_buf[*ppos],count);
-	
-	return count;
+	return simple_read_from_buffer(buf, count, ppos, v_buf, mmapper_size);
 }
 
 static ssize_t
-mmapper_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+mmapper_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
 {
-	if(*ppos > mmapper_size)
+	if (*ppos > mmapper_size)
 		return -EINVAL;
 
-	if(count + *ppos > mmapper_size)
-		count = count + *ppos - mmapper_size;
-
-	if(count < 0)
-		return -EINVAL;
+	if (count > mmapper_size - *ppos)
+		count = mmapper_size - *ppos;
 
-	copy_from_user(&v_buf[*ppos],buf,count);
+	if (copy_from_user(&v_buf[*ppos], buf, count))
+		return -EFAULT;
 	
 	return count;
 }
@@ -77,7 +56,6 @@ mmapper_mmap(struct file *file, struct v
 	int ret = -EINVAL;
 	int size;
 
-	lock_kernel();
 	if (vma->vm_pgoff != 0)
 		goto out;
 	
@@ -92,7 +70,6 @@ mmapper_mmap(struct file *file, struct v
 		goto out;
 	ret = 0;
 out:
-	unlock_kernel();
 	return ret;
 }
 
diff -purN linux-2.6.13-rc7-git2/drivers/acpi/sleep/poweroff.c linux-2.6.13-rc7-git3/drivers/acpi/sleep/poweroff.c
--- linux-2.6.13-rc7-git2/drivers/acpi/sleep/poweroff.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/acpi/sleep/poweroff.c	2005-08-28 12:05:38.578595665 +0200
@@ -55,7 +55,11 @@ void acpi_power_off(void)
 
 static int acpi_shutdown(struct sys_device *x)
 {
-	return acpi_sleep_prepare(ACPI_STATE_S5);
+	if (system_state == SYSTEM_POWER_OFF) {
+		/* Prepare if we are going to power off the system */
+		return acpi_sleep_prepare(ACPI_STATE_S5);
+	}
+	return 0;
 }
 
 static struct sysdev_class acpi_sysclass = {
diff -purN linux-2.6.13-rc7-git2/drivers/char/vt.c linux-2.6.13-rc7-git3/drivers/char/vt.c
--- linux-2.6.13-rc7-git2/drivers/char/vt.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/char/vt.c	2005-08-28 12:05:38.587594277 +0200
@@ -2433,7 +2433,7 @@ static int con_open(struct tty_struct *t
 	int ret = 0;
 
 	acquire_console_sem();
-	if (tty->count == 1) {
+	if (tty->driver_data == NULL) {
 		ret = vc_allocate(currcons);
 		if (ret == 0) {
 			struct vc_data *vc = vc_cons[currcons].d;
diff -purN linux-2.6.13-rc7-git2/drivers/isdn/capi/capifs.c linux-2.6.13-rc7-git3/drivers/isdn/capi/capifs.c
--- linux-2.6.13-rc7-git2/drivers/isdn/capi/capifs.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/isdn/capi/capifs.c	2005-08-28 12:05:38.605591502 +0200
@@ -191,8 +191,10 @@ static int __init capifs_init(void)
 	err = register_filesystem(&capifs_fs_type);
 	if (!err) {
 		capifs_mnt = kern_mount(&capifs_fs_type);
-		if (IS_ERR(capifs_mnt))
+		if (IS_ERR(capifs_mnt)) {
 			err = PTR_ERR(capifs_mnt);
+			unregister_filesystem(&capifs_fs_type);
+		}
 	}
 	if (!err)
 		printk(KERN_NOTICE "capifs: Rev %s\n", rev);
diff -purN linux-2.6.13-rc7-git2/drivers/media/dvb/dvb-usb/dibusb-common.c linux-2.6.13-rc7-git3/drivers/media/dvb/dvb-usb/dibusb-common.c
--- linux-2.6.13-rc7-git2/drivers/media/dvb/dvb-usb/dibusb-common.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/media/dvb/dvb-usb/dibusb-common.c	2005-08-28 12:05:38.612590423 +0200
@@ -70,13 +70,22 @@ EXPORT_SYMBOL(dibusb_power_ctrl);
 
 int dibusb2_0_streaming_ctrl(struct dvb_usb_device *d, int onoff)
 {
-	u8 b[2];
-	b[0] = DIBUSB_REQ_SET_IOCTL;
-	b[1] = onoff ? DIBUSB_IOCTL_CMD_ENABLE_STREAM : DIBUSB_IOCTL_CMD_DISABLE_STREAM;
+	u8 b[3] = { 0 };
+	int ret;
 
-	dvb_usb_generic_write(d,b,3);
+	if ((ret = dibusb_streaming_ctrl(d,onoff)) < 0)
+		return ret;
 
-	return dibusb_streaming_ctrl(d,onoff);
+	if (onoff) {
+		b[0] = DIBUSB_REQ_SET_STREAMING_MODE;
+		b[1] = 0x00;
+		if ((ret = dvb_usb_generic_write(d,b,2)) < 0)
+			return ret;
+	}
+
+	b[0] = DIBUSB_REQ_SET_IOCTL;
+	b[1] = onoff ? DIBUSB_IOCTL_CMD_ENABLE_STREAM : DIBUSB_IOCTL_CMD_DISABLE_STREAM;
+	return dvb_usb_generic_write(d,b,3);
 }
 EXPORT_SYMBOL(dibusb2_0_streaming_ctrl);
 
diff -purN linux-2.6.13-rc7-git2/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c linux-2.6.13-rc7-git3/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c
--- linux-2.6.13-rc7-git2/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/media/dvb/dvb-usb/dvb-usb-dvb.c	2005-08-28 12:05:38.613590269 +0200
@@ -23,12 +23,12 @@ static int dvb_usb_ctrl_feed(struct dvb_
 	 */
 	if (newfeedcount == 0) {
 		deb_ts("stop feeding\n");
+		dvb_usb_urb_kill(d);
 
 		if (d->props.streaming_ctrl != NULL)
 			if ((ret = d->props.streaming_ctrl(d,0)))
 				err("error while stopping stream.");
 
-		dvb_usb_urb_kill(d);
 	}
 
 	d->feedcount = newfeedcount;
@@ -44,6 +44,8 @@ static int dvb_usb_ctrl_feed(struct dvb_
 	 * for reception.
 	 */
 	if (d->feedcount == onoff && d->feedcount > 0) {
+		deb_ts("submitting all URBs\n");
+		dvb_usb_urb_submit(d);
 
 		deb_ts("controlling pid parser\n");
 		if (d->props.caps & DVB_USB_HAS_PID_FILTER &&
@@ -59,7 +61,6 @@ static int dvb_usb_ctrl_feed(struct dvb_
 				return -ENODEV;
 			}
 
-		dvb_usb_urb_submit(d);
 	}
 	return 0;
 }
diff -purN linux-2.6.13-rc7-git2/drivers/net/hamradio/6pack.c linux-2.6.13-rc7-git3/drivers/net/hamradio/6pack.c
--- linux-2.6.13-rc7-git2/drivers/net/hamradio/6pack.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/net/hamradio/6pack.c	2005-08-28 12:05:38.615589961 +0200
@@ -308,12 +308,6 @@ static int sp_set_mac_address(struct net
 {
 	struct sockaddr_ax25 *sa = addr;
 
-	if (sa->sax25_family != AF_AX25)
-		return -EINVAL;
-
-	if (!sa->sax25_ndigis)
-		return -EINVAL;
-
 	spin_lock_irq(&dev->xmit_lock);
 	memcpy(dev->dev_addr, &sa->sax25_call, AX25_ADDR_LEN);
 	spin_unlock_irq(&dev->xmit_lock);
@@ -668,6 +662,9 @@ static int sixpack_open(struct tty_struc
 	netif_start_queue(dev);
 
 	init_timer(&sp->tx_t);
+	sp->tx_t.function = sp_xmit_on_air;
+	sp->tx_t.data = (unsigned long) sp;
+
 	init_timer(&sp->resync_t);
 
 	spin_unlock_bh(&sp->lock);
diff -purN linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_aux.c linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_aux.c
--- linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_aux.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_aux.c	2005-08-28 12:05:38.643585644 +0200
@@ -1299,13 +1299,10 @@ struct zfcp_port *
 zfcp_port_enqueue(struct zfcp_adapter *adapter, wwn_t wwpn, u32 status,
 		  u32 d_id)
 {
-	struct zfcp_port *port, *tmp_port;
+	struct zfcp_port *port;
 	int check_wwpn;
-	scsi_id_t scsi_id;
-	int found;
 
 	check_wwpn = !(status & ZFCP_STATUS_PORT_NO_WWPN);
-
 	/*
 	 * check that there is no port with this WWPN already in list
 	 */
@@ -1368,7 +1365,7 @@ zfcp_port_enqueue(struct zfcp_adapter *a
 	} else {
 		snprintf(port->sysfs_device.bus_id,
 			 BUS_ID_SIZE, "0x%016llx", wwpn);
-	port->sysfs_device.parent = &adapter->ccw_device->dev;
+		port->sysfs_device.parent = &adapter->ccw_device->dev;
 	}
 	port->sysfs_device.release = zfcp_sysfs_port_release;
 	dev_set_drvdata(&port->sysfs_device, port);
@@ -1388,24 +1385,8 @@ zfcp_port_enqueue(struct zfcp_adapter *a
 
 	zfcp_port_get(port);
 
-	scsi_id = 1;
-	found = 0;
 	write_lock_irq(&zfcp_data.config_lock);
-	list_for_each_entry(tmp_port, &adapter->port_list_head, list) {
-		if (atomic_test_mask(ZFCP_STATUS_PORT_NO_SCSI_ID,
-				     &tmp_port->status))
-			continue;
-		if (tmp_port->scsi_id != scsi_id) {
-			found = 1;
-			break;
-		}
-		scsi_id++;
-	}
-	port->scsi_id = scsi_id;
-	if (found)
-		list_add_tail(&port->list, &tmp_port->list);
-	else
-		list_add_tail(&port->list, &adapter->port_list_head);
+	list_add_tail(&port->list, &adapter->port_list_head);
 	atomic_clear_mask(ZFCP_STATUS_COMMON_REMOVE, &port->status);
 	atomic_set_mask(ZFCP_STATUS_COMMON_RUNNING, &port->status);
 	if (d_id == ZFCP_DID_DIRECTORY_SERVICE)
@@ -1422,11 +1403,15 @@ zfcp_port_enqueue(struct zfcp_adapter *a
 void
 zfcp_port_dequeue(struct zfcp_port *port)
 {
+	struct fc_port *rport;
+
 	zfcp_port_wait(port);
 	write_lock_irq(&zfcp_data.config_lock);
 	list_del(&port->list);
 	port->adapter->ports--;
 	write_unlock_irq(&zfcp_data.config_lock);
+	if (port->rport)
+		fc_remote_port_delete(rport);
 	zfcp_adapter_put(port->adapter);
 	zfcp_sysfs_port_remove_files(&port->sysfs_device,
 				     atomic_read(&port->status));
diff -purN linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_ccw.c linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_ccw.c
--- linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_ccw.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_ccw.c	2005-08-28 12:05:38.644585490 +0200
@@ -202,9 +202,19 @@ static int
 zfcp_ccw_set_offline(struct ccw_device *ccw_device)
 {
 	struct zfcp_adapter *adapter;
+	struct zfcp_port *port;
+	struct fc_port *rport;
 
 	down(&zfcp_data.config_sema);
 	adapter = dev_get_drvdata(&ccw_device->dev);
+	/* might be racy, but we cannot take config_lock due to the fact that
+	   fc_remote_port_delete might sleep */
+	list_for_each_entry(port, &adapter->port_list_head, list)
+		if (port->rport) {
+			rport = port->rport;
+			port->rport = NULL;
+			fc_remote_port_delete(rport);
+		}
 	zfcp_erp_adapter_shutdown(adapter, 0);
 	zfcp_erp_wait(adapter);
 	zfcp_adapter_scsi_unregister(adapter);
diff -purN linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_def.h linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_def.h
--- linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_def.h	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_def.h	2005-08-28 12:05:38.647585028 +0200
@@ -906,6 +906,7 @@ struct zfcp_adapter {
  */
 struct zfcp_port {
 	struct device          sysfs_device;   /* sysfs device */
+	struct fc_rport        *rport;         /* rport of fc transport class */
 	struct list_head       list;	       /* list of remote ports */
 	atomic_t               refcount;       /* reference count */
 	wait_queue_head_t      remove_wq;      /* can be used to wait for
@@ -916,7 +917,6 @@ struct zfcp_port {
 						  list */
 	u32		       units;	       /* # of logical units in list */
 	atomic_t	       status;	       /* status of this remote port */
-	scsi_id_t	       scsi_id;	       /* own SCSI ID */
 	wwn_t		       wwnn;	       /* WWNN if known */
 	wwn_t		       wwpn;	       /* WWPN */
 	fc_id_t		       d_id;	       /* D_ID */
diff -purN linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_erp.c linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_erp.c
--- linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_erp.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_erp.c	2005-08-28 12:05:38.652584257 +0200
@@ -3360,13 +3360,32 @@ zfcp_erp_action_cleanup(int action, stru
 		if ((result == ZFCP_ERP_SUCCEEDED)
 		    && (!atomic_test_mask(ZFCP_STATUS_UNIT_TEMPORARY,
 					  &unit->status))
-		    && (!unit->device))
- 			scsi_add_device(unit->port->adapter->scsi_host, 0,
- 					unit->port->scsi_id, unit->scsi_lun);
+		    && !unit->device
+		    && port->rport)
+ 			scsi_add_device(port->adapter->scsi_host, 0,
+ 					port->rport->scsi_target_id,
+					unit->scsi_lun);
 		zfcp_unit_put(unit);
 		break;
 	case ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:
 	case ZFCP_ERP_ACTION_REOPEN_PORT:
+		if ((result == ZFCP_ERP_SUCCEEDED)
+		    && !atomic_test_mask(ZFCP_STATUS_PORT_NO_WWPN,
+					 &port->status)
+		    && !port->rport) {
+			struct fc_rport_identifiers ids;
+			ids.node_name = port->wwnn;
+			ids.port_name = port->wwpn;
+			ids.port_id = port->d_id;
+			ids.roles = FC_RPORT_ROLE_FCP_TARGET;
+			port->rport =
+				fc_remote_port_add(adapter->scsi_host, 0, &ids);
+			if (!port->rport)
+				ZFCP_LOG_NORMAL("failed registration of rport"
+						"(adapter %s, wwpn=0x%016Lx)\n",
+						zfcp_get_busid_by_port(port),
+						port->wwpn);
+		}
 		zfcp_port_put(port);
 		break;
 	case ZFCP_ERP_ACTION_REOPEN_ADAPTER:
diff -purN linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_ext.h linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_ext.h
--- linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_ext.h	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_ext.h	2005-08-28 12:05:38.653584103 +0200
@@ -143,6 +143,8 @@ extern int zfcp_scsi_command_async(struc
 				   struct scsi_cmnd *, struct timer_list *);
 extern int zfcp_scsi_command_sync(struct zfcp_unit *, struct scsi_cmnd *,
 				  struct timer_list *);
+extern void zfcp_set_fc_host_attrs(struct zfcp_adapter *);
+extern void zfcp_set_fc_rport_attrs(struct zfcp_port *);
 extern struct scsi_transport_template *zfcp_transport_template;
 extern struct fc_function_template zfcp_transport_functions;
 
diff -purN linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_fsf.c linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_fsf.c
--- linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_fsf.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_fsf.c	2005-08-28 12:05:38.661582869 +0200
@@ -2062,6 +2062,7 @@ zfcp_fsf_exchange_config_evaluate(struct
 		zfcp_erp_adapter_shutdown(adapter, 0);
 		return -EIO;
 	}
+	zfcp_set_fc_host_attrs(adapter);
 	return 0;
 }
 
diff -purN linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_scsi.c linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_scsi.c
--- linux-2.6.13-rc7-git2/drivers/s390/scsi/zfcp_scsi.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/s390/scsi/zfcp_scsi.c	2005-08-28 12:05:38.664582407 +0200
@@ -389,7 +389,7 @@ zfcp_unit_lookup(struct zfcp_adapter *ad
 	struct zfcp_unit *unit, *retval = NULL;
 
 	list_for_each_entry(port, &adapter->port_list_head, list) {
-		if (id != port->scsi_id)
+		if (!port->rport || (id != port->rport->scsi_target_id))
 			continue;
 		list_for_each_entry(unit, &port->unit_list_head, list) {
 			if (lun == unit->scsi_lun) {
@@ -408,7 +408,7 @@ zfcp_port_lookup(struct zfcp_adapter *ad
 	struct zfcp_port *port;
 
 	list_for_each_entry(port, &adapter->port_list_head, list) {
-		if (id == port->scsi_id)
+		if (port->rport && (id == port->rport->scsi_target_id))
 			return port;
 	}
 	return (struct zfcp_port *) NULL;
@@ -634,7 +634,6 @@ zfcp_scsi_eh_device_reset_handler(struct
 {
 	int retval;
 	struct zfcp_unit *unit = (struct zfcp_unit *) scpnt->device->hostdata;
-	struct Scsi_Host *scsi_host = scpnt->device->host;
 
 	if (!unit) {
 		ZFCP_LOG_NORMAL("bug: Tried reset for nonexistent unit\n");
@@ -729,7 +728,6 @@ zfcp_scsi_eh_bus_reset_handler(struct sc
 {
 	int retval = 0;
 	struct zfcp_unit *unit;
-	struct Scsi_Host *scsi_host = scpnt->device->host;
 
 	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 	ZFCP_LOG_NORMAL("bus reset because of problems with "
@@ -753,7 +751,6 @@ zfcp_scsi_eh_host_reset_handler(struct s
 {
 	int retval = 0;
 	struct zfcp_unit *unit;
-	struct Scsi_Host *scsi_host = scpnt->device->host;
 
 	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 	ZFCP_LOG_NORMAL("host reset because of problems with "
@@ -833,6 +830,7 @@ zfcp_adapter_scsi_unregister(struct zfcp
 	shost = adapter->scsi_host;
 	if (!shost)
 		return;
+	fc_remove_host(shost);
 	scsi_remove_host(shost);
 	scsi_host_put(shost);
 	adapter->scsi_host = NULL;
@@ -906,6 +904,18 @@ zfcp_get_node_name(struct scsi_target *s
 	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
 }
 
+void
+zfcp_set_fc_host_attrs(struct zfcp_adapter *adapter)
+{
+	struct Scsi_Host *shost = adapter->scsi_host;
+
+	fc_host_node_name(shost) = adapter->wwnn;
+	fc_host_port_name(shost) = adapter->wwpn;
+	strncpy(fc_host_serial_number(shost), adapter->serial_number,
+                min(FC_SERIAL_NUMBER_SIZE, 32));
+	fc_host_supported_classes(shost) = FC_COS_CLASS2 | FC_COS_CLASS3;
+}
+
 struct fc_function_template zfcp_transport_functions = {
 	.get_starget_port_id = zfcp_get_port_id,
 	.get_starget_port_name = zfcp_get_port_name,
@@ -913,6 +923,11 @@ struct fc_function_template zfcp_transpo
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,
 	.show_starget_node_name = 1,
+	.show_rport_supported_classes = 1,
+	.show_host_node_name = 1,
+	.show_host_port_name = 1,
+	.show_host_supported_classes = 1,
+	.show_host_serial_number = 1,
 };
 
 /**
diff -purN linux-2.6.13-rc7-git2/drivers/scsi/sg.c linux-2.6.13-rc7-git3/drivers/scsi/sg.c
--- linux-2.6.13-rc7-git2/drivers/scsi/sg.c	2005-08-24 05:39:14.000000000 +0200
+++ linux-2.6.13-rc7-git3/drivers/scsi/sg.c	2005-08-28 12:05:38.668581790 +0200
@@ -2971,23 +2971,22 @@ static void * dev_seq_start(struct seq_f
 {
 	struct sg_proc_deviter * it = kmalloc(sizeof(*it), GFP_KERNEL);
 
+	s->private = it;
 	if (! it)
 		return NULL;
+
 	if (NULL == sg_dev_arr)
-		goto err1;
+		return NULL;
 	it->index = *pos;
 	it->max = sg_last_dev();
 	if (it->index >= it->max)
-		goto err1;
+		return NULL;
 	return it;
-err1:
-	kfree(it);
-	return NULL;
 }
 
 static void * dev_seq_next(struct seq_file *s, void *v, loff_t *pos)
 {
-	struct sg_proc_deviter * it = (struct sg_proc_deviter *) v;
+	struct sg_proc_deviter * it = s->private;
 
 	*pos = ++it->index;
 	return (it->index < it->max) ? it : NULL;
@@ -2995,7 +2994,7 @@ static void * dev_seq_next(struct seq_fi
 
 static void dev_seq_stop(struct seq_file *s, void *v)
 {
-	kfree (v);
+	kfree(s->private);
 }
 
 static int sg_proc_open_dev(struct inode *inode, struct file *file)
