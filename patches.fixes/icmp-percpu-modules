Fix loading as modules (#38820).

From Arnd Bergmann (arnd@arndb.de):
The problem is percpu relocations to local variables. The compiler 
makes this a 32 bit PC relative relocation because it expects the 
section to be inside of the same compilation unit. 
However, modules are loaded at a virtual location near the end of the 
available memory, while the per-cpu area is at the beginning. 
When these two are more than 4GB apart, an incorrect address will be 
generated. A solution for this particular instance is the patch below. 


--- linux-2.6.5/net/ipv4/icmp.c.orig	2004-04-27 08:14:54.036373414 +0200
+++ linux-2.6.5/net/ipv4/icmp.c	2004-04-27 08:15:02.178225512 +0200
@@ -228,7 +228,7 @@
  *
  *	On SMP we have one ICMP socket per-cpu.
  */
-static DEFINE_PER_CPU(struct socket *, __icmp_socket) = NULL;
+DEFINE_PER_CPU(struct socket *, __icmp_socket) = NULL;
 #define icmp_socket	__get_cpu_var(__icmp_socket)
 
 static __inline__ int icmp_xmit_lock(void)
--- linux-2.6.5/net/ipv6/icmp.c.orig	2004-04-27 08:14:05.193258830 +0200
+++ linux-2.6.5/net/ipv6/icmp.c	2004-04-27 08:14:27.010503148 +0200
@@ -78,7 +78,7 @@
  *
  *	On SMP we have one ICMP socket per-cpu.
  */
-static DEFINE_PER_CPU(struct socket *, __icmpv6_socket) = NULL;
+DEFINE_PER_CPU(struct socket *, __icmpv6_socket) = NULL;
 #define icmpv6_socket	__get_cpu_var(__icmpv6_socket)
 
 static int icmpv6_rcv(struct sk_buff **pskb, unsigned int *nhoffp);
