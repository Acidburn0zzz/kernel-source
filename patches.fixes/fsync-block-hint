From: mason@suse.com
Subject: disable PF_SYNCWRITE everywhere but O_DIRECT
Patch-mainline: 2.6.18-rc1
References: 176178

CFQ and AS uses PF_SYNCWRITE to decide if a given request should go into
the async queue or a queue specific to the calling task.  If this is
used for fsync or O_SYNC, the result is that io done by pdflush
or by memory pressure happens on a different queue than the fsync
generated io, making things slower.

This patch just disables PF_SYNCWRITE outside of O_DIRECT.

Acked-by: Jens Axboe <axboe@suse.de>
Signed-off-by: 

diff -r 234dcb305d9c drivers/usb/gadget/file_storage.c
--- a/drivers/usb/gadget/file_storage.c	Thu May 18 15:31:13 2006 -0400
+++ b/drivers/usb/gadget/file_storage.c	Fri May 26 08:55:03 2006 -0400
@@ -1892,7 +1892,6 @@ static int fsync_sub(struct lun *curlun)
 
 	inode = filp->f_dentry->d_inode;
 	mutex_lock(&inode->i_mutex);
-	current->flags |= PF_SYNCWRITE;
 	rc = filemap_fdatawrite(inode->i_mapping);
 	err = filp->f_op->fsync(filp, filp->f_dentry, 1);
 	if (!rc)
@@ -1900,7 +1899,6 @@ static int fsync_sub(struct lun *curlun)
 	err = filemap_fdatawait(inode->i_mapping);
 	if (!rc)
 		rc = err;
-	current->flags &= ~PF_SYNCWRITE;
 	mutex_unlock(&inode->i_mutex);
 	VLDBG(curlun, "fdatasync -> %d\n", rc);
 	return rc;
diff -r 234dcb305d9c fs/buffer.c
--- a/fs/buffer.c	Thu May 18 15:31:13 2006 -0400
+++ b/fs/buffer.c	Fri May 26 08:55:03 2006 -0400
@@ -347,7 +347,6 @@ static long do_fsync(unsigned int fd, in
 
 	mapping = file->f_mapping;
 
-	current->flags |= PF_SYNCWRITE;
 	ret = filemap_fdatawrite(mapping);
 
 	/*
@@ -362,7 +361,6 @@ static long do_fsync(unsigned int fd, in
 	err = filemap_fdatawait(mapping);
 	if (!ret)
 		ret = err;
-	current->flags &= ~PF_SYNCWRITE;
 
 out_putf:
 	fput(file);
diff -r 234dcb305d9c fs/fs-writeback.c
--- a/fs/fs-writeback.c	Thu May 18 15:31:13 2006 -0400
+++ b/fs/fs-writeback.c	Fri May 26 08:55:03 2006 -0400
@@ -642,7 +642,6 @@ int generic_osync_inode(struct inode *in
 	int need_write_inode_now = 0;
 	int err2;
 
-	current->flags |= PF_SYNCWRITE;
 	if (what & OSYNC_DATA)
 		err = filemap_fdatawrite(mapping);
 	if (what & (OSYNC_METADATA|OSYNC_DATA)) {
@@ -655,7 +654,6 @@ int generic_osync_inode(struct inode *in
 		if (!err)
 			err = err2;
 	}
-	current->flags &= ~PF_SYNCWRITE;
 
 	spin_lock(&inode_lock);
 	if ((inode->i_state & I_DIRTY) &&
diff -r 234dcb305d9c mm/msync.c
--- a/mm/msync.c	Thu May 18 15:31:13 2006 -0400
+++ b/mm/msync.c	Fri May 26 08:55:03 2006 -0400
@@ -158,9 +158,6 @@ asmlinkage long sys_msync(unsigned long 
 	struct vm_area_struct *vma;
 	int unmapped_error, error = -EINVAL;
 
-	if (flags & MS_SYNC)
-		current->flags |= PF_SYNCWRITE;
-
 	down_read(&current->mm->mmap_sem);
 	if (flags & ~(MS_ASYNC | MS_INVALIDATE | MS_SYNC))
 		goto out;
@@ -211,6 +208,5 @@ asmlinkage long sys_msync(unsigned long 
 	}
 out:
 	up_read(&current->mm->mmap_sem);
-	current->flags &= ~PF_SYNCWRITE;
 	return error;
 }
