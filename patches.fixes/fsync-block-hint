From: Jens Axboe <axboe@suse.de>
Subject: Fix fsync() performance
Patch-mainline: 
References: 176178

The PF_SYNCWRITE flag was a bad hack introduced to pass back the hint
to the 'as' io scheduler that a write should be treated as a sync request.
Unfortunately this flag is also abused for eg fsync(), causing partial
parts of async writes to go into a sync queue. This causes bad performance.
Fix this up by just passing down whether this is a sync write or not,
a bio has flags for that.

Acked-by: 
Signed-off-by: 

diff -urp /mnt/kscratch/linux-2.6.16/block/as-iosched.c linux-2.6.16/block/as-iosched.c
--- /mnt/kscratch/linux-2.6.16/block/as-iosched.c	2006-05-31 15:03:59.000000000 +0200
+++ linux-2.6.16/block/as-iosched.c	2006-05-31 21:50:31.000000000 +0200
@@ -1345,8 +1345,8 @@ static void as_add_request(request_queue
 
 	arq->state = AS_RQ_NEW;
 
-	if (rq_data_dir(arq->request) == READ
-			|| current->flags&PF_SYNCWRITE)
+	if (rq_data_dir(arq->request) == READ ||
+	   (arq->request->flags & REQ_RW_SYNC))
 		arq->is_sync = 1;
 	else
 		arq->is_sync = 0;
diff -urp /mnt/kscratch/linux-2.6.16/block/cfq-iosched.c linux-2.6.16/block/cfq-iosched.c
--- /mnt/kscratch/linux-2.6.16/block/cfq-iosched.c	2006-05-31 15:03:59.000000000 +0200
+++ linux-2.6.16/block/cfq-iosched.c	2006-05-31 22:03:30.000000000 +0200
@@ -284,8 +284,6 @@ static struct cfq_queue *cfq_find_cfq_ha
 static void cfq_dispatch_insert(request_queue_t *, struct cfq_rq *);
 static struct cfq_queue *cfq_get_queue(struct cfq_data *cfqd, unsigned int key, struct task_struct *tsk, gfp_t gfp_mask);
 
-#define process_sync(tsk)	((tsk)->flags & PF_SYNCWRITE)
-
 /*
  * lots of deadline iosched dupes, can be abstracted later...
  */
@@ -339,9 +337,9 @@ static int cfq_queue_empty(request_queue
 	return !cfqd->busy_queues;
 }
 
-static inline pid_t cfq_queue_pid(struct task_struct *task, int rw)
+static inline pid_t cfq_queue_pid(struct task_struct *task, int rw, int sync)
 {
-	if (rw == READ || process_sync(task))
+	if (rw == READ || sync)
 		return task->pid;
 
 	return CFQ_KEY_ASYNC;
@@ -630,11 +628,19 @@ cfq_reposition_crq_rb(struct cfq_queue *
 	cfq_add_crq_rb(crq);
 }
 
+static inline int cfq_bio_sync(struct bio *bio)
+{
+	if (bio && bio_sync(bio))
+		return 1;
+
+	return 0;
+}
+
 static struct request *
 cfq_find_rq_fmerge(struct cfq_data *cfqd, struct bio *bio)
 {
 	struct task_struct *tsk = current;
-	pid_t key = cfq_queue_pid(tsk, bio_data_dir(bio));
+	pid_t key = cfq_queue_pid(tsk, bio_data_dir(bio), cfq_bio_sync(bio));
 	struct cfq_queue *cfqq;
 	struct rb_node *n;
 	sector_t sector;
@@ -1969,6 +1975,7 @@ static int cfq_may_queue(request_queue_t
 {
 	struct cfq_data *cfqd = q->elevator->elevator_data;
 	struct task_struct *tsk = current;
+	const int sync = cfq_bio_sync(bio);
 	struct cfq_queue *cfqq;
 
 	/*
@@ -1977,7 +1984,7 @@ static int cfq_may_queue(request_queue_t
 	 * so just lookup a possibly existing queue, or return 'may queue'
 	 * if that fails
 	 */
-	cfqq = cfq_find_cfq_hash(cfqd, cfq_queue_pid(tsk, rw), tsk->ioprio);
+	cfqq = cfq_find_cfq_hash(cfqd, cfq_queue_pid(tsk,rw,sync), tsk->ioprio);
 	if (cfqq) {
 		cfq_init_prio_data(cfqq);
 		cfq_prio_boost(cfqq);
@@ -2042,7 +2049,7 @@ cfq_set_request(request_queue_t *q, stru
 	struct task_struct *tsk = current;
 	struct cfq_io_context *cic;
 	const int rw = rq_data_dir(rq);
-	pid_t key = cfq_queue_pid(tsk, rw);
+	pid_t key = cfq_queue_pid(tsk, rw, cfq_bio_sync(bio));
 	struct cfq_queue *cfqq;
 	struct cfq_rq *crq;
 	unsigned long flags;
diff -urp /mnt/kscratch/linux-2.6.16/block/ll_rw_blk.c linux-2.6.16/block/ll_rw_blk.c
--- /mnt/kscratch/linux-2.6.16/block/ll_rw_blk.c	2006-05-31 15:03:59.000000000 +0200
+++ linux-2.6.16/block/ll_rw_blk.c	2006-05-31 21:39:34.000000000 +0200
@@ -2803,6 +2803,9 @@ static void init_request_from_bio(struct
 	if (unlikely(bio_barrier(bio)))
 		req->flags |= (REQ_HARDBARRIER | REQ_NOMERGE);
 
+	if (bio_sync(bio))
+		req->flags |= REQ_RW_SYNC;
+
 	req->errors = 0;
 	req->hard_sector = req->sector = bio->bi_sector;
 	req->hard_nr_sectors = req->nr_sectors = bio_sectors(bio);
diff -urp /mnt/kscratch/linux-2.6.16/drivers/usb/gadget/file_storage.c linux-2.6.16/drivers/usb/gadget/file_storage.c
--- /mnt/kscratch/linux-2.6.16/drivers/usb/gadget/file_storage.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/drivers/usb/gadget/file_storage.c	2006-05-31 21:46:21.000000000 +0200
@@ -1892,7 +1892,6 @@ static int fsync_sub(struct lun *curlun)
 
 	inode = filp->f_dentry->d_inode;
 	mutex_lock(&inode->i_mutex);
-	current->flags |= PF_SYNCWRITE;
 	rc = filemap_fdatawrite(inode->i_mapping);
 	err = filp->f_op->fsync(filp, filp->f_dentry, 1);
 	if (!rc)
@@ -1900,7 +1899,6 @@ static int fsync_sub(struct lun *curlun)
 	err = filemap_fdatawait(inode->i_mapping);
 	if (!rc)
 		rc = err;
-	current->flags &= ~PF_SYNCWRITE;
 	mutex_unlock(&inode->i_mutex);
 	VLDBG(curlun, "fdatasync -> %d\n", rc);
 	return rc;
diff -urp /mnt/kscratch/linux-2.6.16/fs/buffer.c linux-2.6.16/fs/buffer.c
--- /mnt/kscratch/linux-2.6.16/fs/buffer.c	2006-05-31 15:03:58.000000000 +0200
+++ linux-2.6.16/fs/buffer.c	2006-05-31 21:40:21.000000000 +0200
@@ -347,7 +347,6 @@ static long do_fsync(unsigned int fd, in
 
 	mapping = file->f_mapping;
 
-	current->flags |= PF_SYNCWRITE;
 	ret = filemap_fdatawrite(mapping);
 
 	/*
@@ -362,7 +361,6 @@ static long do_fsync(unsigned int fd, in
 	err = filemap_fdatawait(mapping);
 	if (!ret)
 		ret = err;
-	current->flags &= ~PF_SYNCWRITE;
 
 out_putf:
 	fput(file);
diff -urp /mnt/kscratch/linux-2.6.16/fs/direct-io.c linux-2.6.16/fs/direct-io.c
--- /mnt/kscratch/linux-2.6.16/fs/direct-io.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/fs/direct-io.c	2006-05-31 21:45:33.000000000 +0200
@@ -354,6 +354,7 @@ static void dio_bio_submit(struct dio *d
 	spin_unlock_irqrestore(&dio->bio_lock, flags);
 	if (dio->is_async && dio->rw == READ)
 		bio_set_pages_dirty(bio);
+	bio->bi_rw |= (1 << BIO_RW_SYNC);
 	submit_bio(dio->rw, bio);
 
 	dio->bio = NULL;
@@ -1186,9 +1187,6 @@ __blockdev_direct_IO(int rw, struct kioc
 	int release_i_mutex = 0;
 	int acquire_i_mutex = 0;
 
-	if (rw & WRITE)
-		current->flags |= PF_SYNCWRITE;
-
 	if (bdev)
 		bdev_blkbits = blksize_bits(bdev_hardsect_size(bdev));
 
@@ -1277,8 +1275,6 @@ out:
 		mutex_unlock(&inode->i_mutex);
 	else if (acquire_i_mutex)
 		mutex_lock(&inode->i_mutex);
-	if (rw & WRITE)
-		current->flags &= ~PF_SYNCWRITE;
 	return retval;
 }
 EXPORT_SYMBOL(__blockdev_direct_IO);
diff -urp /mnt/kscratch/linux-2.6.16/fs/fs-writeback.c linux-2.6.16/fs/fs-writeback.c
--- /mnt/kscratch/linux-2.6.16/fs/fs-writeback.c	2006-05-31 15:03:57.000000000 +0200
+++ linux-2.6.16/fs/fs-writeback.c	2006-05-31 21:45:39.000000000 +0200
@@ -642,7 +642,6 @@ int generic_osync_inode(struct inode *in
 	int need_write_inode_now = 0;
 	int err2;
 
-	current->flags |= PF_SYNCWRITE;
 	if (what & OSYNC_DATA)
 		err = filemap_fdatawrite(mapping);
 	if (what & (OSYNC_METADATA|OSYNC_DATA)) {
@@ -655,7 +654,6 @@ int generic_osync_inode(struct inode *in
 		if (!err)
 			err = err2;
 	}
-	current->flags &= ~PF_SYNCWRITE;
 
 	spin_lock(&inode_lock);
 	if ((inode->i_state & I_DIRTY) &&
diff -urp /mnt/kscratch/linux-2.6.16/include/linux/blkdev.h linux-2.6.16/include/linux/blkdev.h
--- /mnt/kscratch/linux-2.6.16/include/linux/blkdev.h	2006-05-31 15:03:59.000000000 +0200
+++ linux-2.6.16/include/linux/blkdev.h	2006-05-31 21:39:16.000000000 +0200
@@ -239,6 +239,7 @@ enum rq_flag_bits {
 	__REQ_PM_RESUME,	/* resume request */
 	__REQ_PM_SHUTDOWN,	/* shutdown request */
 	__REQ_ORDERED_COLOR,	/* is before or after barrier */
+	__REQ_RW_SYNC,		/* sync request */
 	__REQ_NR_BITS,		/* stops here */
 };
 
@@ -268,6 +269,7 @@ enum rq_flag_bits {
 #define REQ_PM_RESUME	(1 << __REQ_PM_RESUME)
 #define REQ_PM_SHUTDOWN	(1 << __REQ_PM_SHUTDOWN)
 #define REQ_ORDERED_COLOR	(1 << __REQ_ORDERED_COLOR)
+#define REQ_RW_SYNC	(1 << __REQ_RW_SYNC)
 
 /*
  * State information carried for REQ_PM_SUSPEND and REQ_PM_RESUME
diff -urp /mnt/kscratch/linux-2.6.16/mm/msync.c linux-2.6.16/mm/msync.c
--- /mnt/kscratch/linux-2.6.16/mm/msync.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16/mm/msync.c	2006-05-31 21:45:50.000000000 +0200
@@ -158,9 +158,6 @@ asmlinkage long sys_msync(unsigned long 
 	struct vm_area_struct *vma;
 	int unmapped_error, error = -EINVAL;
 
-	if (flags & MS_SYNC)
-		current->flags |= PF_SYNCWRITE;
-
 	down_read(&current->mm->mmap_sem);
 	if (flags & ~(MS_ASYNC | MS_INVALIDATE | MS_SYNC))
 		goto out;
@@ -211,6 +208,5 @@ asmlinkage long sys_msync(unsigned long 
 	}
 out:
 	up_read(&current->mm->mmap_sem);
-	current->flags &= ~PF_SYNCWRITE;
 	return error;
 }
