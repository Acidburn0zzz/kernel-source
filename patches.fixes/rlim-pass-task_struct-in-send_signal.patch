
From: Chris Wright <chrisw@osdl.org>

Update send_signal() api to allow passing the task receiving the signal.  This
is necessary to ensure signals generated out of process context can be charged
to the correct user.


---

 25-akpm/kernel/signal.c |    7 ++++---
 1 files changed, 4 insertions(+), 3 deletions(-)

diff -puN kernel/signal.c~rlim-pass-task_struct-in-send_signal kernel/signal.c
--- 25/kernel/signal.c~rlim-pass-task_struct-in-send_signal	2004-05-23 01:42:12.208819856 -0700
+++ 25-akpm/kernel/signal.c	2004-05-23 01:42:12.212819248 -0700
@@ -699,7 +699,8 @@ static void handle_stop_signal(int sig, 
 	}
 }
 
-static int send_signal(int sig, struct siginfo *info, struct sigpending *signals)
+static int send_signal(int sig, struct siginfo *info, struct task_struct *t,
+			struct sigpending *signals)
 {
 	struct sigqueue * q = NULL;
 	int ret = 0;
@@ -798,7 +799,7 @@ specific_send_sig_info(int sig, struct s
 	if (LEGACY_QUEUE(&t->pending, sig))
 		goto out;
 
-	ret = send_signal(sig, info, &t->pending);
+	ret = send_signal(sig, info, t, &t->pending);
 	if (!ret && !sigismember(&t->blocked, sig))
 		signal_wake_up(t, sig == SIGKILL);
 out:
@@ -999,7 +1000,7 @@ __group_send_sig_info(int sig, struct si
 	 * We always use the shared queue for process-wide signals,
 	 * to avoid several races.
 	 */
-	ret = send_signal(sig, info, &p->signal->shared_pending);
+	ret = send_signal(sig, info, p, &p->signal->shared_pending);
 	if (unlikely(ret))
 		return ret;
 

_
