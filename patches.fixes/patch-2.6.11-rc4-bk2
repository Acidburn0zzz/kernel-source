From: olh@suse.de
Subject: 2.6.11-rc4-bk2

ChangeSet@1.2035.1.3, 2005-02-13 20:33:48+00:00, tglx@de.rmk.(none)
  [ARM PATCH] 2478/1: Remove NULL initializers
  
  Patch from Thomas Gleixner
  
  Remove NULL initializers of static variables.
  
  Signed-off-by: Thomas Gleixner
  Signed-off-by: Russell King

ChangeSet@1.2035.1.2, 2005-02-13 20:09:13+00:00, tglx@de.rmk.(none)
  [ARM PATCH] 2476/1: Fix compile for shannon
  
  Patch from Thomas Gleixner
  
  Trivial build fix for shannon platform
  
  Signed-off-by: Thomas Gleixner
  Signed-off-by: Russell King

ChangeSet@1.2035.1.1, 2005-02-13 20:02:48+00:00, tglx@de.rmk.(none)
  [ARM PATCH] 2474/1: Fix compile for badge4
  
  Patch from Thomas Gleixner
  
  Trivial build fix for badge4 platform
  
  Signed-off-by: Thomas Gleixner
  Signed-off-by: Russell King

ChangeSet@1.2037, 2005-02-13 11:07:36-08:00, torvalds@ppc970.osdl.org
  Eicon driver: remove ^M for real this time.
  
  Really.

ChangeSet@1.2036, 2005-02-13 10:14:10-08:00, arjan@infradead.org
  [PATCH] Allow heap to be marked executable too
  
  This makes it possible to mark binaries to have both an executable stack
  and heap, allowing for a NX system to disable NX on a per-binary level.
  
  Signed-off-by: Arjan van de Ven <arjan@infradead.org>
  Signed-off-by: Linus Torvalds <torvalds@osdl.org>

ChangeSet@1.2018.3.3, 2005-02-13 12:53:23-05:00, mporter@kernel.crashing.org
  [PATCH] emac: fix mdio delay
  
  Fixes MDIO delay. Please apply.
  
  Signed-off-by: Ralph Siemsen <ralphs@netwinder.org>
  Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
  Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

ChangeSet@1.2018.3.2, 2005-02-13 12:53:11-05:00, mporter@kernel.crashing.org
  [PATCH] emac: fix jumbo frame support
  
  Fixes a bug in RX buffer allocation so that jumbo size skbs are
  allocated when the MTU size is changed. Also removes the deprecated
  restore_flags() call.  Please apply.
  
  Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
  Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

ChangeSet@1.2035, 2005-02-12 20:23:28-08:00, benh@kernel.crashing.org
  [PATCH] radeonfb: typos fixes
  
  The dynamic clock code in radeonfb comes almost as-is from X.org (where
  it was contributed by ATI). It has a few typos (wrong register access
  macros) that this patch fixes.
  
  Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
  Signed-off-by: Linus Torvalds <torvalds@osdl.org>

ChangeSet@1.2034, 2005-02-12 20:23:14-08:00, joe.korty@ccur.com
  [PATCH] memset argument order misuses
  
  A simple 'grep memset.*\<0);' shows argument order errors in several
  uses of memset.
  
  This grep was inspired by Al Viro's recent patch, megaraid_mbox fix,
  which fixed this problem in the megaraid driver.

ChangeSet@1.2033, 2005-02-12 18:58:36-08:00, torvalds@ppc970.osdl.org
  Linux 2.6.11-rc4
  TAG: v2.6.11-rc4

diff -Nru a/Makefile b/Makefile
--- a/Makefile	2005-02-12 18:58:24 -08:00
+++ b/Makefile	2005-02-14 05:04:57 -08:00
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION =-rc4
+EXTRAVERSION = -rc4-bk2
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -Nru a/arch/arm/mach-sa1100/badge4.c b/arch/arm/mach-sa1100/badge4.c
--- a/arch/arm/mach-sa1100/badge4.c	2004-11-12 14:15:16 -08:00
+++ b/arch/arm/mach-sa1100/badge4.c	2005-02-12 16:00:00 -08:00
@@ -57,7 +57,7 @@
 	.name		= "sa1111",
 	.id		= 0,
 	.dev		= {
-		.dma_mask = &sa1111_dmamask;
+		.dma_mask = &sa1111_dmamask,
 		.coherent_dma_mask = 0xffffffff,
 	},
 	.num_resources	= ARRAY_SIZE(sa1111_resources),
@@ -212,8 +212,7 @@
 	/* maybe turn on 5v0 from the start */
 	badge4_set_5V(BADGE4_5V_INITIALLY, five_v_on);
 
-	sa11x0_set_flash_data(badge4_flash_data, badge4_flash_resources,
-			      ARRAY_SIZE(badge4_flash_resources);
+	sa11x0_set_flash_data(&badge4_flash_data, &badge4_flash_resource, 1);
 
 	return 0;
 }
diff -Nru a/arch/arm/mach-sa1100/shannon.c b/arch/arm/mach-sa1100/shannon.c
--- a/arch/arm/mach-sa1100/shannon.c	2004-11-12 14:15:18 -08:00
+++ b/arch/arm/mach-sa1100/shannon.c	2005-02-12 16:00:00 -08:00
@@ -2,15 +2,17 @@
  * linux/arch/arm/mach-sa1100/shannon.c
  */
 
+#include <linux/config.h>
 #include <linux/init.h>
+#include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/tty.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 
 #include <asm/hardware.h>
+#include <asm/mach-types.h>
 #include <asm/setup.h>
-#include <asm/irq.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
@@ -52,7 +54,7 @@
 
 static void __init shannon_init(void)
 {
-	sa11x0_set_flash_data(&shannon_flash_data, shannon_flash_resource, 1);
+	sa11x0_set_flash_data(&shannon_flash_data, &shannon_flash_resource, 1);
 }
 
 static void __init shannon_map_io(void)
diff -Nru a/arch/arm/mach-shark/irq.c b/arch/arm/mach-shark/irq.c
--- a/arch/arm/mach-shark/irq.c	2005-02-03 14:17:50 -08:00
+++ b/arch/arm/mach-shark/irq.c	2005-02-12 16:00:00 -08:00
@@ -103,10 +103,7 @@
 	//request_region(0xA0,0x2,"pic2");
 
 	cascade.handler = bogus_int;
-	cascade.flags = 0;
 	cascade.name = "cascade";
-	cascade.next = NULL;
-	cascade.dev_id = NULL;
 	setup_irq(2,&cascade);
 }
 
diff -Nru a/drivers/isdn/hardware/eicon/xdi_vers.h b/drivers/isdn/hardware/eicon/xdi_vers.h
--- a/drivers/isdn/hardware/eicon/xdi_vers.h	2005-02-11 11:41:25 -08:00
+++ b/drivers/isdn/hardware/eicon/xdi_vers.h	2005-02-13 11:06:46 -08:00
@@ -1,25 +1,26 @@
-/*
- *
-  Copyright (c) Eicon Networks, 2002.
- *
-  This source file is supplied for the use with
-  Eicon Networks range of DIVA Server Adapters.
- *
-  Eicon File Revision :    2.1
- *
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2, or (at your option)
-  any later version.
- *
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY OF ANY KIND WHATSOEVER INCLUDING ANY
-  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-  See the GNU General Public License for more details.
- *
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-static char diva_xdi_common_code_build[] = "102-52"; 
+
+/*
+ *
+  Copyright (c) Eicon Networks, 2002.
+ *
+  This source file is supplied for the use with
+  Eicon Networks range of DIVA Server Adapters.
+ *
+  Eicon File Revision :    2.1
+ *
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2, or (at your option)
+  any later version.
+ *
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY OF ANY KIND WHATSOEVER INCLUDING ANY
+  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+  See the GNU General Public License for more details.
+ *
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+static char diva_xdi_common_code_build[] = "102-52"; 
diff -Nru a/drivers/net/ibm_emac/ibm_emac_core.c b/drivers/net/ibm_emac/ibm_emac_core.c
--- a/drivers/net/ibm_emac/ibm_emac_core.c	2004-12-07 09:06:23 -08:00
+++ b/drivers/net/ibm_emac/ibm_emac_core.c	2005-01-20 12:25:10 -08:00
@@ -475,8 +475,9 @@
 
 	out_be32(&emacp->em0stacr, stacr);
 
-	while (((stacr = in_be32(&emacp->em0stacr) & EMAC_STACR_OC) == 0)
-					&& (count++ < 5000))
+	count = 0;
+	while ((((stacr = in_be32(&emacp->em0stacr)) & EMAC_STACR_OC) == 0)
+					&& (count++ < MDIO_DELAY))
 		udelay(1);
 	MDIO_DEBUG((" (count was %d)\n", count));
 
@@ -912,7 +913,6 @@
 		PKT_DEBUG(("emac_start_xmit() stopping queue\n"));
 		netif_stop_queue(dev);
 		spin_unlock_irqrestore(&fep->lock, flags);
-		restore_flags(flags);
 		return -EBUSY;
 	}
 
@@ -1281,7 +1281,7 @@
 	/* Format the receive descriptor ring. */
 	ep->rx_slot = 0;
 	/* Default is MTU=1500 + Ethernet overhead */
-	ep->rx_buffer_size = ENET_DEF_BUF_SIZE;
+	ep->rx_buffer_size = dev->mtu + ENET_HEADER_SIZE + ENET_FCS_SIZE;
 	emac_rx_fill(dev, 0);
 	if (ep->rx_slot != 0) {
 		printk(KERN_ERR
diff -Nru a/drivers/net/ibm_emac/ibm_emac_core.h b/drivers/net/ibm_emac/ibm_emac_core.h
--- a/drivers/net/ibm_emac/ibm_emac_core.h	2004-08-05 07:26:55 -07:00
+++ b/drivers/net/ibm_emac/ibm_emac_core.h	2005-02-08 21:24:52 -08:00
@@ -77,8 +77,6 @@
 
 #define ENET_HEADER_SIZE	14
 #define ENET_FCS_SIZE		4
-#define ENET_DEF_MTU_SIZE	1500
-#define ENET_DEF_BUF_SIZE	(ENET_DEF_MTU_SIZE + ENET_HEADER_SIZE + ENET_FCS_SIZE)
 #define EMAC_MIN_FRAME		64
 #define EMAC_MAX_FRAME		9018
 #define EMAC_MIN_MTU		(EMAC_MIN_FRAME - ENET_HEADER_SIZE - ENET_FCS_SIZE)
diff -Nru a/drivers/net/tulip/de2104x.c b/drivers/net/tulip/de2104x.c
--- a/drivers/net/tulip/de2104x.c	2005-01-25 19:28:28 -08:00
+++ b/drivers/net/tulip/de2104x.c	2005-02-07 08:51:57 -08:00
@@ -1960,8 +1960,6 @@
 	dev->tx_timeout = de_tx_timeout;
 	dev->watchdog_timeo = TX_TIMEOUT;
 
-	dev->irq = pdev->irq;
-
 	de = dev->priv;
 	de->de21040 = ent->driver_data == 0 ? 1 : 0;
 	de->pdev = pdev;
@@ -1996,6 +1994,8 @@
 		       pdev->irq, pci_name(pdev));
 		goto err_out_res;
 	}
+
+	dev->irq = pdev->irq;
 
 	/* obtain and check validity of PCI I/O address */
 	pciaddr = pci_resource_start(pdev, 1);
diff -Nru a/drivers/net/wan/dscc4.c b/drivers/net/wan/dscc4.c
--- a/drivers/net/wan/dscc4.c	2005-01-07 21:44:25 -08:00
+++ b/drivers/net/wan/dscc4.c	2005-01-13 15:55:23 -08:00
@@ -691,7 +691,7 @@
 	root = ppriv->root;
 
 	for (i = 0; i < dev_per_card; i++)
-		unregister_hdlc_device(dscc4_to_dev(&root[i]));
+		unregister_hdlc_device(dscc4_to_dev(root + i));
 
 	pci_set_drvdata(pdev, NULL);
 
@@ -706,33 +706,36 @@
 {
 	struct dscc4_pci_priv *priv;
 	struct dscc4_dev_priv *dpriv;
-	static int cards_found = 0;
 	void __iomem *ioaddr;
-	int i;
+	int i, rc;
 
 	printk(KERN_DEBUG "%s", version);
 
-	if (pci_enable_device(pdev))
-		goto err_out;
-	if (!request_mem_region(pci_resource_start(pdev, 0),
-	                	pci_resource_len(pdev, 0), "registers")) {
+	rc = pci_enable_device(pdev);
+	if (rc < 0)
+		goto out;
+
+	rc = pci_request_region(pdev, 0, "registers");
+	if (rc < 0) {
 	        printk(KERN_ERR "%s: can't reserve MMIO region (regs)\n",
 			DRV_NAME);
-	        goto err_out;
+	        goto err_disable_0;
 	}
-	if (!request_mem_region(pci_resource_start(pdev, 1),
-	                        pci_resource_len(pdev, 1), "LBI interface")) {
+	rc = pci_request_region(pdev, 1, "LBI interface");
+	if (rc < 0) {
 	        printk(KERN_ERR "%s: can't reserve MMIO region (lbi)\n",
 			DRV_NAME);
-	        goto err_out_free_mmio_region0;
+	        goto err_free_mmio_region_1;
 	}
+
 	ioaddr = ioremap(pci_resource_start(pdev, 0),
 					pci_resource_len(pdev, 0));
 	if (!ioaddr) {
 		printk(KERN_ERR "%s: cannot remap MMIO region %lx @ %lx\n",
 			DRV_NAME, pci_resource_len(pdev, 0),
 			pci_resource_start(pdev, 0));
-		goto err_out_free_mmio_region;
+		rc = -EIO;
+		goto err_free_mmio_regions_2;
 	}
 	printk(KERN_DEBUG "Siemens DSCC4, MMIO at %#lx (regs), %#lx (lbi), IRQ %d\n",
 	        pci_resource_start(pdev, 0),
@@ -742,14 +745,16 @@
 	pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0xf8);
 	pci_set_master(pdev);
 
-	if (dscc4_found1(pdev, ioaddr))
-	        goto err_out_iounmap;
+	rc = dscc4_found1(pdev, ioaddr);
+	if (rc < 0)
+	        goto err_iounmap_3;
 
-	priv = (struct dscc4_pci_priv *)pci_get_drvdata(pdev);
+	priv = pci_get_drvdata(pdev);
 
-	if (request_irq(pdev->irq, &dscc4_irq, SA_SHIRQ, DRV_NAME, priv->root)){
+	rc = request_irq(pdev->irq, dscc4_irq, SA_SHIRQ, DRV_NAME, priv->root);
+	if (rc < 0) {
 		printk(KERN_WARNING "%s: IRQ %d busy\n", DRV_NAME, pdev->irq);
-		goto err_out_free1;
+		goto err_release_4;
 	}
 
 	/* power up/little endian/dma core controlled via lrda/ltda */
@@ -769,9 +774,11 @@
 	priv->iqcfg = (u32 *) pci_alloc_consistent(pdev,
 		IRQ_RING_SIZE*sizeof(u32), &priv->iqcfg_dma);
 	if (!priv->iqcfg)
-		goto err_out_free_irq;
+		goto err_free_irq_5;
 	writel(priv->iqcfg_dma, ioaddr + IQCFG);
 
+	rc = -ENOMEM;
+
 	/*
 	 * SCC 0-3 private rx/tx irq structures
 	 * IQRX/TXi needs to be set soon. Learned it the hard way...
@@ -781,7 +788,7 @@
 		dpriv->iqtx = (u32 *) pci_alloc_consistent(pdev,
 			IRQ_RING_SIZE*sizeof(u32), &dpriv->iqtx_dma);
 		if (!dpriv->iqtx)
-			goto err_out_free_iqtx;
+			goto err_free_iqtx_6;
 		writel(dpriv->iqtx_dma, ioaddr + IQTX0 + i*4);
 	}
 	for (i = 0; i < dev_per_card; i++) {
@@ -789,7 +796,7 @@
 		dpriv->iqrx = (u32 *) pci_alloc_consistent(pdev,
 			IRQ_RING_SIZE*sizeof(u32), &dpriv->iqrx_dma);
 		if (!dpriv->iqrx)
-			goto err_out_free_iqrx;
+			goto err_free_iqrx_7;
 		writel(dpriv->iqrx_dma, ioaddr + IQRX0 + i*4);
 	}
 
@@ -804,17 +811,18 @@
 
 	writel(0xff200001, ioaddr + GCMDR);
 
-	cards_found++;
-	return 0;
+	rc = 0;
+out:
+	return rc;
 
-err_out_free_iqrx:
+err_free_iqrx_7:
 	while (--i >= 0) {
 		dpriv = priv->root + i;
 		pci_free_consistent(pdev, IRQ_RING_SIZE*sizeof(u32),
 				    dpriv->iqrx, dpriv->iqrx_dma);
 	}
 	i = dev_per_card;
-err_out_free_iqtx:
+err_free_iqtx_6:
 	while (--i >= 0) {
 		dpriv = priv->root + i;
 		pci_free_consistent(pdev, IRQ_RING_SIZE*sizeof(u32),
@@ -822,20 +830,19 @@
 	}
 	pci_free_consistent(pdev, IRQ_RING_SIZE*sizeof(u32), priv->iqcfg,
 			    priv->iqcfg_dma);
-err_out_free_irq:
+err_free_irq_5:
 	free_irq(pdev->irq, priv->root);
-err_out_free1:
+err_release_4:
 	dscc4_free1(pdev);
-err_out_iounmap:
+err_iounmap_3:
 	iounmap (ioaddr);
-err_out_free_mmio_region:
-	release_mem_region(pci_resource_start(pdev, 1),
-			   pci_resource_len(pdev, 1));
-err_out_free_mmio_region0:
-	release_mem_region(pci_resource_start(pdev, 0),
-			   pci_resource_len(pdev, 0));
-err_out:
-	return -ENODEV;
+err_free_mmio_regions_2:
+	pci_release_region(pdev, 1);
+err_free_mmio_region_1:
+	pci_release_region(pdev, 0);
+err_disable_0:
+	pci_disable_device(pdev);
+	goto out;
 };
 
 /*
@@ -882,8 +889,7 @@
 	struct dscc4_dev_priv *root;
 	int i, ret = -ENOMEM;
 
-	root = (struct dscc4_dev_priv *)
-		kmalloc(dev_per_card*sizeof(*root), GFP_KERNEL);
+	root = kmalloc(dev_per_card*sizeof(*root), GFP_KERNEL);
 	if (!root) {
 		printk(KERN_ERR "%s: can't allocate data\n", DRV_NAME);
 		goto err_out;
@@ -892,22 +898,17 @@
 
 	for (i = 0; i < dev_per_card; i++) {
 		root[i].dev = alloc_hdlcdev(root + i);
-		if (!root[i].dev) {
-			while (i--)
-				free_netdev(root[i].dev);
+		if (!root[i].dev)
 			goto err_free_dev;
-		}
 	}
 
-	ppriv = (struct dscc4_pci_priv *) kmalloc(sizeof(*ppriv), GFP_KERNEL);
+	ppriv = kmalloc(sizeof(*ppriv), GFP_KERNEL);
 	if (!ppriv) {
 		printk(KERN_ERR "%s: can't allocate private data\n", DRV_NAME);
-		goto err_free_dev2;
+		goto err_free_dev;
 	}
 	memset(ppriv, 0, sizeof(struct dscc4_pci_priv));
-	ret = dscc4_set_quartz(root, quartz);
-	if (ret < 0)
-		goto err_free_priv;
+
 	ppriv->root = root;
 	spin_lock_init(&ppriv->lock);
 
@@ -951,20 +952,24 @@
 			goto err_unregister;
 	        }
 	}
+
+	ret = dscc4_set_quartz(root, quartz);
+	if (ret < 0)
+		goto err_unregister;
+
 	pci_set_drvdata(pdev, ppriv);
 	return ret;
 
 err_unregister:
-	while (--i >= 0) {
+	while (i-- > 0) {
 		dscc4_release_ring(root + i);
-		unregister_hdlc_device(dscc4_to_dev(&root[i]));
+		unregister_hdlc_device(dscc4_to_dev(root + i));
 	}
-err_free_priv:
 	kfree(ppriv);
-err_free_dev2:
-	for (i = 0; i < dev_per_card; i++)
-		free_netdev(root[i].dev);
+	i = dev_per_card;
 err_free_dev:
+	while (i-- > 0)
+		free_netdev(root[i].dev);
 	kfree(root);
 err_out:
 	return ret;
@@ -1998,10 +2003,10 @@
 
 	iounmap(ioaddr);
 
-	release_mem_region(pci_resource_start(pdev, 1),
-			   pci_resource_len(pdev, 1));
-	release_mem_region(pci_resource_start(pdev, 0),
-			   pci_resource_len(pdev, 0));
+	pci_release_region(pdev, 1);
+	pci_release_region(pdev, 0);
+
+	pci_disable_device(pdev);
 }
 
 static int dscc4_hdlc_attach(struct net_device *dev, unsigned short encoding,
diff -Nru a/drivers/s390/block/dasd_genhd.c b/drivers/s390/block/dasd_genhd.c
--- a/drivers/s390/block/dasd_genhd.c	2004-07-01 22:23:50 -07:00
+++ b/drivers/s390/block/dasd_genhd.c	2005-02-12 18:55:49 -08:00
@@ -149,8 +149,8 @@
 	 * Can't call delete_partitions directly. Use ioctl.
 	 * The ioctl also does locking and invalidation.
 	 */
-	memset(&bpart, sizeof(struct blkpg_partition), 0);
-	memset(&barg, sizeof(struct blkpg_ioctl_arg), 0);
+	memset(&bpart, 0, sizeof(struct blkpg_partition));
+	memset(&barg, 0, sizeof(struct blkpg_ioctl_arg));
 	barg.data = &bpart;
 	barg.op = BLKPG_DEL_PARTITION;
 	for (bpart.pno = device->gdp->minors - 1; bpart.pno > 0; bpart.pno--)
diff -Nru a/drivers/s390/cio/cmf.c b/drivers/s390/cio/cmf.c
--- a/drivers/s390/cio/cmf.c	2004-10-09 14:13:57 -07:00
+++ b/drivers/s390/cio/cmf.c	2005-02-12 18:56:08 -08:00
@@ -526,7 +526,7 @@
 	time = get_clock() - cdev->private->cmb_start_time;
 	spin_unlock_irqrestore(cdev->ccwlock, flags);
 
-	memset(data, sizeof(struct cmbdata), 0);
+	memset(data, 0, sizeof(struct cmbdata));
 
 	/* we only know values before device_busy_time */
 	data->size = offsetof(struct cmbdata, device_busy_time);
@@ -736,7 +736,7 @@
 	time = get_clock() - cdev->private->cmb_start_time;
 	spin_unlock_irqrestore(cdev->ccwlock, flags);
 
-	memset (data, sizeof(struct cmbdata), 0);
+	memset (data, 0, sizeof(struct cmbdata));
 
 	/* we only know values before device_busy_time */
 	data->size = offsetof(struct cmbdata, device_busy_time);
diff -Nru a/drivers/s390/cio/css.c b/drivers/s390/cio/css.c
--- a/drivers/s390/cio/css.c	2005-01-20 21:02:15 -08:00
+++ b/drivers/s390/cio/css.c	2005-02-12 18:56:20 -08:00
@@ -527,7 +527,7 @@
 	new_slow_sch = kmalloc(sizeof(struct slow_subchannel), GFP_ATOMIC);
 	if (!new_slow_sch)
 		return -ENOMEM;
-	memset(new_slow_sch, sizeof(struct slow_subchannel), 0);
+	memset(new_slow_sch, 0, sizeof(struct slow_subchannel));
 	new_slow_sch->schid = schid;
 	spin_lock_irqsave(&slow_subchannel_lock, flags);
 	list_add_tail(&new_slow_sch->slow_list, &slow_subchannels_head);
diff -Nru a/drivers/video/aty/radeon_pm.c b/drivers/video/aty/radeon_pm.c
--- a/drivers/video/aty/radeon_pm.c	2005-02-10 22:57:44 -08:00
+++ b/drivers/video/aty/radeon_pm.c	2005-02-12 20:01:11 -08:00
@@ -180,7 +180,7 @@
 		tmp = INPLL(pllMCLK_CNTL);
 		tmp &= ~(MCLK_CNTL__FORCE_MCLKA |
 			 MCLK_CNTL__FORCE_YCLKA);
-		OUTREG(pllMCLK_CNTL, tmp);
+		OUTPLL(pllMCLK_CNTL, tmp);
 		radeon_msleep(16);
 	}
 	/* Hrm... same shit, X doesn't do that but I have to */
@@ -404,7 +404,7 @@
 	    ((INREG(CONFIG_CNTL) & CFG_ATI_REV_ID_MASK) < CFG_ATI_REV_A13)) {
 		tmp = INPLL(pllPLL_PWRMGT_CNTL);
 		tmp |= PLL_PWRMGT_CNTL__TCL_BYPASS_DISABLE;
-		OUTREG(pllPLL_PWRMGT_CNTL, tmp);
+		OUTPLL(pllPLL_PWRMGT_CNTL, tmp);
 		radeon_msleep(15);
 	}
 
diff -Nru a/fs/binfmt_elf.c b/fs/binfmt_elf.c
--- a/fs/binfmt_elf.c	2005-02-10 12:32:25 -08:00
+++ b/fs/binfmt_elf.c	2005-02-06 03:29:02 -08:00
@@ -757,7 +757,7 @@
 	/* Do this immediately, since STACK_TOP as used in setup_arg_pages
 	   may depend on the personality.  */
 	SET_PERSONALITY(loc->elf_ex, ibcs2_interpreter);
-	if (elf_read_implies_exec(loc->elf_ex, have_pt_gnu_stack))
+	if (elf_read_implies_exec(loc->elf_ex, executable_stack))
 		current->personality |= READ_IMPLIES_EXEC;
 
 	arch_pick_mmap_layout(current->mm);
diff -Nru a/include/asm-i386/elf.h b/include/asm-i386/elf.h
--- a/include/asm-i386/elf.h	2004-09-13 17:00:00 -07:00
+++ b/include/asm-i386/elf.h	2005-02-06 03:29:55 -08:00
@@ -123,7 +123,7 @@
  * An executable for which elf_read_implies_exec() returns TRUE will
  * have the READ_IMPLIES_EXEC personality flag set automatically.
  */
-#define elf_read_implies_exec(ex, have_pt_gnu_stack)	(!(have_pt_gnu_stack))
+#define elf_read_implies_exec(ex, executable_stack)	(executable_stack != EXSTACK_DISABLE_X)
 
 extern int dump_task_regs (struct task_struct *, elf_gregset_t *);
 extern int dump_task_fpu (struct task_struct *, elf_fpregset_t *);
diff -Nru a/include/asm-ia64/elf.h b/include/asm-ia64/elf.h
--- a/include/asm-ia64/elf.h	2004-10-05 11:24:12 -07:00
+++ b/include/asm-ia64/elf.h	2005-02-06 03:32:47 -08:00
@@ -186,8 +186,8 @@
 
 #ifdef __KERNEL__
 #define SET_PERSONALITY(ex, ibcs2)	set_personality(PER_LINUX)
-#define elf_read_implies_exec(ex, have_pt_gnu_stack)					\
-	(!(have_pt_gnu_stack) && ((ex).e_flags & EF_IA_64_LINUX_EXECUTABLE_STACK) != 0)
+#define elf_read_implies_exec(ex, executable_stack)					\
+	((executable_stack!=EXSTACK_DISABLE_X) && ((ex).e_flags & EF_IA_64_LINUX_EXECUTABLE_STACK) != 0)
 
 struct task_struct;
 
diff -Nru a/include/asm-x86_64/elf.h b/include/asm-x86_64/elf.h
--- a/include/asm-x86_64/elf.h	2004-10-19 02:40:25 -07:00
+++ b/include/asm-x86_64/elf.h	2005-02-06 03:31:39 -08:00
@@ -147,14 +147,7 @@
  * An executable for which elf_read_implies_exec() returns TRUE will
  * have the READ_IMPLIES_EXEC personality flag set automatically.
  */
-#define elf_read_implies_exec(ex, have_pt_gnu_stack)	(!(have_pt_gnu_stack))
-	
-/*
- * An executable for which elf_read_implies_exec() returns TRUE will
- * have the READ_IMPLIES_EXEC personality flag set automatically.
- */
-#define elf_read_implies_exec_binary(ex, have_pt_gnu_stack)   \
-	 (!(have_pt_gnu_stack))
+#define elf_read_implies_exec(ex, executable_stack)	(executable_stack != EXSTACK_DISABLE_X)
 
 extern int dump_task_regs (struct task_struct *, elf_gregset_t *);
 extern int dump_task_fpu (struct task_struct *, elf_fpregset_t *);
