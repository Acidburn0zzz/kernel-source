When the nr_hugepages sysctl is changed x86-64 would sometimes not free
all hugepages. The problem was that it only looked on node 0, but 
they could be in other nodes too.

Just iterate over all nodes. 2.6.7 does it in the same way.

The patch is for x86-64 (code shared with i386), but it is a nop
on i386 because MAX_NUMNODES is always 1 on i386 in our kernels
(we don't support NUMA i386 kernels). Even if it wasn't a nop
it wouldn't hurt there.

diff -u linux/arch/i386/mm/hugetlbpage.c-o linux/arch/i386/mm/hugetlbpage.c
--- linux/arch/i386/mm/hugetlbpage.c-o	2004-06-23 00:42:54.000000000 +0200
+++ linux/arch/i386/mm/hugetlbpage.c	2004-06-24 16:53:31.000000000 +0200
@@ -485,23 +490,26 @@
 {
 	struct list_head *p;
 	struct page *page, *map;
+	int i;
 
-    page = NULL;
+	page = NULL;
 	map = NULL;
 	spin_lock(&htlbpage_lock);
-	/* all lowmem is on node 0 */
-	list_for_each(p, &hugepage_freelists[0]) {
-		if (map) {
-			list_del(&map->lru);
-			update_and_free_page(map);
- 			htlbpagemem[page_zone(map)->zone_pgdat->node_id]--;
-			map = NULL;
-			if (++count == 0)
-				break;
+	
+	for (i = 0; i < MAX_NUMNODES; i++) { 
+		list_for_each(p, &hugepage_freelists[i]) {
+			if (map) {
+				list_del(&map->lru);
+				update_and_free_page(map);
+				htlbpagemem[page_zone(map)->zone_pgdat->node_id]--;
+				map = NULL;
+				if (++count == 0)
+					break;
+			}
+			page = list_entry(p, struct page, lru);
+			if (!PageHighMem(page))
+				map = page;
 		}
-		page = list_entry(p, struct page, lru);
-		if (!PageHighMem(page))
-			map = page;
 	}
 	if (map) {
 		list_del(&map->lru);
