From: olh@suse.de
Subject: 2.6.11-rc4-bk5

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc4-bk4.log	2005-02-16 13:40:02.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc4-bk5.log	2005-02-17 13:40:19.000000000 +0100
 ChangeSet@1.2053, 2005-02-15 18:38:35-08:00, benh@kernel.crashing.org
 ChangeSet@1.2057, 2005-02-16 15:15:42-08:00, trini@kernel.crashing.org
   [PATCH] ppc32: fixup of previous PCI9 patch
   
   Previous PCI9 patch had a #endif placed wrong for some unknown reason (was
   correct in local tree) This fixes it.
   
   Signed-off-by: Rune Torgersen <runet@innovsys.com>
   Signed-off-by: Tom Rini <trini@kernel.crashing.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2056, 2005-02-16 15:15:27-08:00, ntl@pobox.com
   [PATCH] kthread_bind new worker threads when onlining cpu
   
   We weren't binding new worker threads to their cpu when onlining.  Using
   preempt and the debug version of smp_processor_id found this.
   
   Signed-off-by: Nathan Lynch <ntl@pobox.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2048.2.4, 2005-02-16 14:27:17-08:00, david-b@pacbell.net
   [PATCH] USB: ehci requeue revisit
   
   This gets rid of a bug found in some IRQ handling logic, after tripping
   a debug assertion.  Basically, a recent patch called the wrong routine to
   unlink a QH.  Net result, it wasn't allowing for the case that some other
   QH was already being unlinked.  This patch uses the correct routine; the
   names are confusingly similar, and the effect is often identical.
   
   The consequence of using the wrong routine was that the driver could
   lose one of the pending unlinks (probably wedging some activity) and
   treat the other one as completed before it was safe to do so (which
   probably wouldn't oops, but could cause other nasty corruption).
   
   From: Brian Murphy <brian@murphy.dk>
   Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
   Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
 
 ChangeSet@1.2048.2.3, 2005-02-16 14:26:53-08:00, stern@rowland.harvard.edu
   [PATCH] USB Hub driver: Add reset recovery-time delay
   
   This patch is clearly needed for us to be in compliance with the USB spec.
   It adds the mandated recovery-time delay following a port reset.
   Regardless of anything else we do to alter the device initialization
   sequence, this is necessary.
   
   
   Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
   Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
 
 ChangeSet@1.2048.2.2, 2005-02-16 14:26:30-08:00, david-b@pacbell.net
   [PATCH] USB: ehci patch for NF4 port miscounting
   
   Turns out that a workaround for a different EHCI chip trips up at
   least one NForce4 board.  Neither controller can multiply right.
   
   Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
   Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
 
 ChangeSet@1.2048.2.1, 2005-02-16 08:41:34-08:00, adaplas@hotpop.com
   [PATCH] fbdev: Fix gcc 4.0 compile failure
   
   From: Art Haas
   
   The current GCC cvs code does not like the include/linux/fb.h file:
   
   In file included from drivers/video/aty/atyfb_base.c:63:
   include/linux/fb.h:865: error: array type has incomplete element type
   
   This error is due to recent changes in GCC. A thread discussing this
   change can be found by following the link below:
   
   http://gcc.gnu.org/ml/gcc/2005-02/msg00053.html
   
   The patch moves the array declaration after the definition of the
   fb_modelist structure, and with this small change GCC is happy once
   again.
   
   Signed-off-by: Antonino Daplas <adaplas@pol.net>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2048.1.6, 2005-02-16 08:09:40-08:00, Robert.Olsson@data.slu.se
   [PKTGEN]: Bug fixes, bump to version 2.56.
   
   - Fix printing of running list, do not stop at first
     not-running device, instead scan them all.
   - Do not free SKB before final access via show_results()
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2052, 2005-02-15 18:44:43-08:00, breuerr@mc.net
   [SPARC]: Check prom_getproperty return value.
   
   Errors should not be ignored, so add __must_check
   tag to this function as well.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2048.1.5, 2005-02-15 18:38:35-08:00, benh@kernel.crashing.org
 ChangeSet@1.2051, 2005-02-15 13:04:21-08:00, torvalds@ppc970.osdl.org
 ChangeSet@1.2048.1.3, 2005-02-15 13:04:21-08:00, torvalds@ppc970.osdl.org
 ChangeSet@1.2050, 2005-02-15 12:59:34-08:00, torvalds@ppc970.osdl.org
 ChangeSet@1.2048.1.2, 2005-02-15 12:59:34-08:00, torvalds@ppc970.osdl.org
 ChangeSet@1.2051, 2005-02-15 09:35:53-08:00, ahaas@airmail.net
   [SPARC]:Check prom_getproperty() return value in prom_nodematch().
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2050, 2005-02-15 09:12:27-08:00, krzysztof.h1@wp.pl
   [SPARC32]: Need to clear PSR_EF in psr of childregs on fork() on SMP.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2049, 2005-02-15 08:23:00-08:00, davem@nuts.davemloft.net
   [SPARC]: Fix video mode probing in atyfb driver.
   
   On Sparc, if the user does not specify a mode option, we
   should use the PROM probed values in default_var always.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
diff -purN linux-2.6.11-rc4-bk4/Makefile linux-2.6.11-rc4-bk5/Makefile
--- linux-2.6.11-rc4-bk4/Makefile	2005-02-17 14:53:42.439487911 +0100
+++ linux-2.6.11-rc4-bk5/Makefile	2005-02-17 14:53:48.579467731 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc4-bk4
+EXTRAVERSION = -rc4-bk5
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc4-bk4/arch/sparc/kernel/auxio.c linux-2.6.11-rc4-bk5/arch/sparc/kernel/auxio.c
--- linux-2.6.11-rc4-bk4/arch/sparc/kernel/auxio.c	2005-02-13 04:07:00.000000000 +0100
+++ linux-2.6.11-rc4-bk5/arch/sparc/kernel/auxio.c	2005-02-17 14:53:48.598464772 +0100
@@ -53,7 +53,8 @@ void __init auxio_probe(void)
 #endif
 		}
 	}
-	prom_getproperty(auxio_nd, "reg", (char *) auxregs, sizeof(auxregs));
+	if(prom_getproperty(auxio_nd, "reg", (char *) auxregs, sizeof(auxregs)) <= 0)
+		return;
 	prom_apply_obio_ranges(auxregs, 0x1);
 	/* Map the register both read and write */
 	r.flags = auxregs[0].which_io & 0xF;
@@ -121,7 +122,8 @@ void __init auxio_power_probe(void)
 		return;
 
 	/* Map the power control register. */
-	prom_getproperty(node, "reg", (char *)&regs, sizeof(regs));
+	if (prom_getproperty(node, "reg", (char *)&regs, sizeof(regs)) <= 0)
+		return;
 	prom_apply_obio_ranges(&regs, 1);
 	memset(&r, 0, sizeof(r));
 	r.flags = regs.which_io & 0xF;
diff -purN linux-2.6.11-rc4-bk4/arch/sparc/kernel/idprom.c linux-2.6.11-rc4-bk5/arch/sparc/kernel/idprom.c
--- linux-2.6.11-rc4-bk4/arch/sparc/kernel/idprom.c	2005-02-13 04:05:41.000000000 +0100
+++ linux-2.6.11-rc4-bk5/arch/sparc/kernel/idprom.c	2005-02-17 14:53:48.599464616 +0100
@@ -53,13 +53,12 @@ static void __init display_system_type(u
 
 	for (i = 0; i < NUM_SUN_MACHINES; i++) {
 		if(Sun_Machines[i].id_machtype == machtype) {
-			if (machtype != (SM_SUN4M_OBP | 0x00))
+			if (machtype != (SM_SUN4M_OBP | 0x00) ||
+			    prom_getproperty(prom_root_node, "banner-name",
+					     sysname, sizeof(sysname)) <= 0)
 				printk("TYPE: %s\n", Sun_Machines[i].name);
-			else {
-				prom_getproperty(prom_root_node, "banner-name",
-						 sysname, sizeof(sysname));
+			else
 				printk("TYPE: %s\n", sysname);
-			}
 			return;
 		}
 	}
diff -purN linux-2.6.11-rc4-bk4/arch/sparc/kernel/process.c linux-2.6.11-rc4-bk5/arch/sparc/kernel/process.c
--- linux-2.6.11-rc4-bk4/arch/sparc/kernel/process.c	2005-02-13 04:05:28.000000000 +0100
+++ linux-2.6.11-rc4-bk5/arch/sparc/kernel/process.c	2005-02-17 14:53:48.601464305 +0100
@@ -549,6 +549,11 @@ int copy_thread(int nr, unsigned long cl
 		}
 	}
 
+#ifdef CONFIG_SMP
+	/* FPU must be disabled on SMP. */
+	childregs->psr &= ~PSR_EF;
+#endif
+
 	/* Set the return value for the child. */
 	childregs->u_regs[UREG_I0] = current->pid;
 	childregs->u_regs[UREG_I1] = 1;
diff -purN linux-2.6.11-rc4-bk4/arch/sparc/kernel/sun4c_irq.c linux-2.6.11-rc4-bk5/arch/sparc/kernel/sun4c_irq.c
--- linux-2.6.11-rc4-bk4/arch/sparc/kernel/sun4c_irq.c	2005-02-13 04:05:11.000000000 +0100
+++ linux-2.6.11-rc4-bk5/arch/sparc/kernel/sun4c_irq.c	2005-02-17 14:53:48.602464149 +0100
@@ -217,13 +217,18 @@ void __init sun4c_init_IRQ(void)
 			panic("Cannot find /interrupt-enable node");
 
 		/* Depending on the "address" property is bad news... */
-		prom_getproperty(ie_node, "reg", (char *) int_regs, sizeof(int_regs));
-		memset(&phyres, 0, sizeof(struct resource));
-		phyres.flags = int_regs[0].which_io;
-		phyres.start = int_regs[0].phys_addr;
-		interrupt_enable = (char *) sbus_ioremap(&phyres, 0,
-		    int_regs[0].reg_size, "sun4c_intr");
+		interrupt_enable = NULL;
+		if (prom_getproperty(ie_node, "reg", (char *) int_regs,
+				     sizeof(int_regs)) != -1) {
+			memset(&phyres, 0, sizeof(struct resource));
+			phyres.flags = int_regs[0].which_io;
+			phyres.start = int_regs[0].phys_addr;
+			interrupt_enable = (char *) sbus_ioremap(&phyres, 0,
+			    int_regs[0].reg_size, "sun4c_intr");
+		}
 	}
+	if (!interrupt_enable)
+		panic("Cannot map interrupt_enable");
 
 	BTFIXUPSET_CALL(sbint_to_irq, sun4c_sbint_to_irq, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(enable_irq, sun4c_enable_irq, BTFIXUPCALL_NORM);
diff -purN linux-2.6.11-rc4-bk4/arch/sparc/mm/io-unit.c linux-2.6.11-rc4-bk5/arch/sparc/mm/io-unit.c
--- linux-2.6.11-rc4-bk4/arch/sparc/mm/io-unit.c	2005-02-13 04:06:22.000000000 +0100
+++ linux-2.6.11-rc4-bk5/arch/sparc/mm/io-unit.c	2005-02-17 14:53:48.604463838 +0100
@@ -52,13 +52,15 @@ iounit_init(int sbi_node, int io_node, s
 	iounit->rotor[1] = IOUNIT_BMAP2_START;
 	iounit->rotor[2] = IOUNIT_BMAPM_START;
 
-	prom_getproperty(sbi_node, "reg", (void *) iommu_promregs,
-			 sizeof(iommu_promregs));
-	prom_apply_generic_ranges(io_node, 0, iommu_promregs, 3);
-	memset(&r, 0, sizeof(r));
-	r.flags = iommu_promregs[2].which_io;
-	r.start = iommu_promregs[2].phys_addr;
-	xpt = (iopte_t *) sbus_ioremap(&r, 0, PAGE_SIZE * 16, "XPT");
+	xpt = NULL;
+	if(prom_getproperty(sbi_node, "reg", (void *) iommu_promregs,
+			    sizeof(iommu_promregs)) != -1) {
+		prom_apply_generic_ranges(io_node, 0, iommu_promregs, 3);
+		memset(&r, 0, sizeof(r));
+		r.flags = iommu_promregs[2].which_io;
+		r.start = iommu_promregs[2].phys_addr;
+		xpt = (iopte_t *) sbus_ioremap(&r, 0, PAGE_SIZE * 16, "XPT");
+	}
 	if(!xpt) panic("Cannot map External Page Table.");
 	
 	sbus->iommu = (struct iommu_struct *)iounit;
diff -purN linux-2.6.11-rc4-bk4/arch/sparc/mm/iommu.c linux-2.6.11-rc4-bk5/arch/sparc/mm/iommu.c
--- linux-2.6.11-rc4-bk4/arch/sparc/mm/iommu.c	2005-02-13 04:07:49.000000000 +0100
+++ linux-2.6.11-rc4-bk5/arch/sparc/mm/iommu.c	2005-02-17 14:53:48.605463682 +0100
@@ -71,14 +71,16 @@ iommu_init(int iommund, struct sbus_bus 
 		prom_printf("Unable to allocate iommu structure\n");
 		prom_halt();
 	}
-	prom_getproperty(iommund, "reg", (void *) iommu_promregs,
-			 sizeof(iommu_promregs));
-	memset(&r, 0, sizeof(r));
-	r.flags = iommu_promregs[0].which_io;
-	r.start = iommu_promregs[0].phys_addr;
-	iommu->regs = (struct iommu_regs *)
-		sbus_ioremap(&r, 0, PAGE_SIZE * 3, "iommu_regs");
-	if(!iommu->regs) {
+	iommu->regs = NULL;
+	if (prom_getproperty(iommund, "reg", (void *) iommu_promregs,
+			 sizeof(iommu_promregs)) != -1) {
+		memset(&r, 0, sizeof(r));
+		r.flags = iommu_promregs[0].which_io;
+		r.start = iommu_promregs[0].phys_addr;
+		iommu->regs = (struct iommu_regs *)
+			sbus_ioremap(&r, 0, PAGE_SIZE * 3, "iommu_regs");
+	}
+	if (!iommu->regs) {
 		prom_printf("Cannot map IOMMU registers\n");
 		prom_halt();
 	}
diff -purN linux-2.6.11-rc4-bk4/arch/sparc/mm/sun4c.c linux-2.6.11-rc4-bk5/arch/sparc/mm/sun4c.c
--- linux-2.6.11-rc4-bk4/arch/sparc/mm/sun4c.c	2005-02-13 04:07:01.000000000 +0100
+++ linux-2.6.11-rc4-bk5/arch/sparc/mm/sun4c.c	2005-02-17 14:53:48.610462903 +0100
@@ -511,7 +511,8 @@ void __init sun4c_probe_memerr_reg(void)
 		node = prom_searchsiblings(prom_root_node, "memory-error");
 		if (!node)
 			return;
-		prom_getproperty(node, "reg", (char *)regs, sizeof(regs));
+		if (prom_getproperty(node, "reg", (char *)regs, sizeof(regs)) <= 0)
+			return;
 		/* hmm I think regs[0].which_io is zero here anyways */
 		sun4c_memerr_reg = ioremap(regs[0].phys_addr, regs[0].reg_size);
 	}
diff -purN linux-2.6.11-rc4-bk4/arch/sparc/prom/console.c linux-2.6.11-rc4-bk5/arch/sparc/prom/console.c
--- linux-2.6.11-rc4-bk4/arch/sparc/prom/console.c	2005-02-13 04:06:04.000000000 +0100
+++ linux-2.6.11-rc4-bk5/arch/sparc/prom/console.c	2005-02-17 14:53:48.612462592 +0100
@@ -111,6 +111,7 @@ prom_query_input_device(void)
 	int st_p;
 	char propb[64];
 	char *p;
+	int propl;
 
 	switch(prom_vers) {
 	case PROM_V0:
@@ -139,14 +140,16 @@ prom_query_input_device(void)
 		if(strncmp(propb, "serial", sizeof("serial")))
 			return PROMDEV_I_UNK;
 		}
-		prom_getproperty(prom_root_node, "stdin-path", propb, sizeof(propb));
-		p = propb;
-		while(*p) p++; p -= 2;
-		if(p[0] == ':') {
-			if(p[1] == 'a')
-				return PROMDEV_ITTYA;
-			else if(p[1] == 'b')
-				return PROMDEV_ITTYB;
+		propl = prom_getproperty(prom_root_node, "stdin-path", propb, sizeof(propb));
+		if(propl > 2) {
+			p = propb;
+			while(*p) p++; p -= 2;
+			if(p[0] == ':') {
+				if(p[1] == 'a')
+					return PROMDEV_ITTYA;
+				else if(p[1] == 'b')
+					return PROMDEV_ITTYB;
+			}
 		}
 		return PROMDEV_I_UNK;
 	}
@@ -179,7 +182,7 @@ prom_query_output_device(void)
 		restore_current();
 		spin_unlock_irqrestore(&prom_lock, flags);
 		propl = prom_getproperty(st_p, "device_type", propb, sizeof(propb));
-		if (propl >= 0 && propl == sizeof("display") &&
+		if (propl == sizeof("display") &&
 			strncmp("display", propb, sizeof("display")) == 0)
 		{
 			return PROMDEV_OSCREEN;
@@ -188,16 +191,20 @@ prom_query_output_device(void)
 			if(propl >= 0 &&
 			    strncmp("serial", propb, sizeof("serial")) != 0)
 				return PROMDEV_O_UNK;
-			prom_getproperty(prom_root_node, "stdout-path", propb, sizeof(propb));
-			if(strncmp(propb, con_name_jmc, CON_SIZE_JMC) == 0)
+			propl = prom_getproperty(prom_root_node, "stdout-path",
+						 propb, sizeof(propb));
+			if(propl == CON_SIZE_JMC &&
+			    strncmp(propb, con_name_jmc, CON_SIZE_JMC) == 0)
 				return PROMDEV_OTTYA;
-			p = propb;
-			while(*p) p++; p -= 2;
-			if(p[0]==':') {
-				if(p[1] == 'a')
-					return PROMDEV_OTTYA;
-				else if(p[1] == 'b')
-					return PROMDEV_OTTYB;
+			if(propl > 2) {
+				p = propb;
+				while(*p) p++; p-= 2;
+				if(p[0]==':') {
+					if(p[1] == 'a')
+						return PROMDEV_OTTYA;
+					else if(p[1] == 'b')
+						return PROMDEV_OTTYB;
+				}
 			}
 		} else {
 			switch(*romvec->pv_stdin) {
diff -purN linux-2.6.11-rc4-bk4/arch/sparc/prom/tree.c linux-2.6.11-rc4-bk5/arch/sparc/prom/tree.c
--- linux-2.6.11-rc4-bk4/arch/sparc/prom/tree.c	2005-02-13 04:06:04.000000000 +0100
+++ linux-2.6.11-rc4-bk5/arch/sparc/prom/tree.c	2005-02-17 14:53:48.613462436 +0100
@@ -176,8 +176,11 @@ void prom_getstring(int node, char *prop
  */
 int prom_nodematch(int node, char *name)
 {
+	int error;
+
 	static char namebuf[128];
-	prom_getproperty(node, "name", namebuf, sizeof(namebuf));
+	error = prom_getproperty(node, "name", namebuf, sizeof(namebuf));
+	if (error == -1) return 0;
 	if(strcmp(namebuf, name) == 0) return 1;
 	return 0;
 }
diff -purN linux-2.6.11-rc4-bk4/drivers/usb/core/hub.c linux-2.6.11-rc4-bk5/drivers/usb/core/hub.c
--- linux-2.6.11-rc4-bk4/drivers/usb/core/hub.c	2005-02-13 04:06:23.000000000 +0100
+++ linux-2.6.11-rc4-bk5/drivers/usb/core/hub.c	2005-02-17 14:53:48.686451068 +0100
@@ -1382,6 +1382,9 @@ static int hub_port_reset(struct usb_hub
 		/* return on disconnect or reset */
 		switch (status) {
 		case 0:
+			/* TRSTRCY = 10 ms */
+			msleep(10);
+			/* FALL THROUGH */
 		case -ENOTCONN:
 		case -ENODEV:
 			clear_port_feature(hub->hdev,
diff -purN linux-2.6.11-rc4-bk4/drivers/usb/host/ehci-hcd.c linux-2.6.11-rc4-bk5/drivers/usb/host/ehci-hcd.c
--- linux-2.6.11-rc4-bk4/drivers/usb/host/ehci-hcd.c	2005-02-13 04:08:05.000000000 +0100
+++ linux-2.6.11-rc4-bk5/drivers/usb/host/ehci-hcd.c	2005-02-17 14:53:48.689450601 +0100
@@ -389,8 +389,29 @@ static int ehci_hc_reset (struct usb_hcd
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
 	temp &= 0x0f;
 	if (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {
-		temp |= (ehci->hcs_params & ~0xf);
-		ehci->hcs_params = temp;
+		ehci_dbg (ehci, "bogus port configuration: "
+			"cc=%d x pcc=%d < ports=%d\n",
+			HCS_N_CC(ehci->hcs_params),
+			HCS_N_PCC(ehci->hcs_params),
+			HCS_N_PORTS(ehci->hcs_params));
+
+#ifdef	CONFIG_PCI
+		if (hcd->self.controller->bus == &pci_bus_type) {
+			struct pci_dev	*pdev;
+
+			pdev = to_pci_dev(hcd->self.controller);
+			switch (pdev->vendor) {
+			case 0x17a0:		/* GENESYS */
+				/* GL880S: should be PORTS=2 */
+				temp |= (ehci->hcs_params & ~0xf);
+				ehci->hcs_params = temp;
+				break;
+			case PCI_VENDOR_ID_NVIDIA:
+				/* NF4: should be PCC=10 */
+				break;
+			}
+		}
+#endif
 	}
 
 	/* force HC to halt state */
diff -purN linux-2.6.11-rc4-bk4/drivers/usb/host/ehci-q.c linux-2.6.11-rc4-bk5/drivers/usb/host/ehci-q.c
--- linux-2.6.11-rc4-bk4/drivers/usb/host/ehci-q.c	2005-02-13 04:07:18.000000000 +0100
+++ linux-2.6.11-rc4-bk5/drivers/usb/host/ehci-q.c	2005-02-17 14:53:48.692450133 +0100
@@ -267,6 +267,7 @@ __acquires(ehci->lock)
 }
 
 static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
+static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
@@ -430,7 +431,7 @@ halt:
 				intr_deschedule (ehci, qh);
 				(void) qh_schedule (ehci, qh);
 			} else
-				start_unlink_async (ehci, qh);
+				unlink_async (ehci, qh);
 			break;
 		/* otherwise, unlink already started */
 		}
diff -purN linux-2.6.11-rc4-bk4/drivers/video/aty/atyfb_base.c linux-2.6.11-rc4-bk5/drivers/video/aty/atyfb_base.c
--- linux-2.6.11-rc4-bk4/drivers/video/aty/atyfb_base.c	2005-02-13 04:07:01.000000000 +0100
+++ linux-2.6.11-rc4-bk5/drivers/video/aty/atyfb_base.c	2005-02-17 14:53:48.699449043 +0100
@@ -2511,7 +2511,15 @@ static int __init aty_init(struct fb_inf
 		}
 	} else
 #endif /* !CONFIG_PPC */
-	if (!fb_find_mode(&var, info, mode, NULL, 0, &defmode, 8))
+	if (
+#if defined(CONFIG_SPARC32) || defined(CONFIG_SPARC64)
+	   /* On Sparc, unless the user gave a specific mode
+	    * specification, use the PROM probed values in
+	    * default_var.
+	    */
+	    !mode ||
+#endif
+	    !fb_find_mode(&var, info, mode, NULL, 0, &defmode, 8))
 		var = default_var;
 
 	if (noaccel)
diff -purN linux-2.6.11-rc4-bk4/include/asm-ppc/io.h linux-2.6.11-rc4-bk5/include/asm-ppc/io.h
--- linux-2.6.11-rc4-bk4/include/asm-ppc/io.h	2005-02-13 04:07:18.000000000 +0100
+++ linux-2.6.11-rc4-bk5/include/asm-ppc/io.h	2005-02-17 14:53:48.744442036 +0100
@@ -360,6 +360,7 @@ static inline void memcpy_toio(volatile 
 {
 	memcpy((void __force *) dst, src, count);
 }
+#endif
 
 #define eth_io_copy_and_sum(a,b,c,d)		eth_copy_and_sum((a),(void __force *)(void __iomem *)(b),(c),(d))
 
@@ -408,7 +409,7 @@ extern inline void * bus_to_virt(unsigne
 	return (void*) mm_ptov (address);
 #endif
 }
-#endif
+
 /*
  * Change virtual addresses to physical addresses and vv, for
  * addresses in the area where the kernel has the RAM mapped.
diff -purN linux-2.6.11-rc4-bk4/include/asm-sparc/floppy.h linux-2.6.11-rc4-bk5/include/asm-sparc/floppy.h
--- linux-2.6.11-rc4-bk4/include/asm-sparc/floppy.h	2005-02-13 04:04:47.000000000 +0100
+++ linux-2.6.11-rc4-bk5/include/asm-sparc/floppy.h	2005-02-17 14:53:48.747441568 +0100
@@ -312,8 +312,8 @@ static int sun_floppy_init(void)
 	}
 
 	/* The sun4m lets us know if the controller is actually usable. */
-	if(sparc_cpu_model == sun4m) {
-		prom_getproperty(fd_node, "status", state, sizeof(state));
+	if(sparc_cpu_model == sun4m &&
+	   prom_getproperty(fd_node, "status", state, sizeof(state)) != -1) {
 		if(!strcmp(state, "disabled")) {
 			goto no_sun_fdc;
 		}
diff -purN linux-2.6.11-rc4-bk4/include/asm-sparc/oplib.h linux-2.6.11-rc4-bk5/include/asm-sparc/oplib.h
--- linux-2.6.11-rc4-bk4/include/asm-sparc/oplib.h	2005-02-13 04:07:49.000000000 +0100
+++ linux-2.6.11-rc4-bk5/include/asm-sparc/oplib.h	2005-02-17 14:53:48.748441413 +0100
@@ -10,6 +10,7 @@
 
 #include <asm/openprom.h>
 #include <linux/spinlock.h>
+#include <linux/compiler.h>
 
 /* The master romvec pointer... */
 extern struct linux_romvec *romvec;
@@ -244,8 +245,8 @@ extern int prom_getproplen(int thisnode,
 /* Fetch the requested property using the given buffer.  Returns
  * the number of bytes the prom put into your buffer or -1 on error.
  */
-extern int prom_getproperty(int thisnode, char *property,
-			    char *prop_buffer, int propbuf_size);
+extern int __must_check prom_getproperty(int thisnode, char *property,
+					 char *prop_buffer, int propbuf_size);
 
 /* Acquire an integer property. */
 extern int prom_getint(int node, char *property);
diff -purN linux-2.6.11-rc4-bk4/include/linux/fb.h linux-2.6.11-rc4-bk5/include/linux/fb.h
--- linux-2.6.11-rc4-bk4/include/linux/fb.h	2005-02-13 04:05:50.000000000 +0100
+++ linux-2.6.11-rc4-bk5/include/linux/fb.h	2005-02-17 14:53:48.752440790 +0100
@@ -862,7 +862,6 @@ extern void fb_destroy_modedb(struct fb_
 
 /* drivers/video/modedb.c */
 #define VESA_MODEDB_SIZE 34
-extern const struct fb_videomode vesa_modes[];
 extern void fb_var_to_videomode(struct fb_videomode *mode,
 				struct fb_var_screeninfo *var);
 extern void fb_videomode_to_var(struct fb_var_screeninfo *var,
@@ -907,6 +906,8 @@ struct fb_videomode {
 	u32 flag;
 };
 
+extern const struct fb_videomode vesa_modes[];
+
 struct fb_modelist {
 	struct list_head list;
 	struct fb_videomode mode;
diff -purN linux-2.6.11-rc4-bk4/kernel/workqueue.c linux-2.6.11-rc4-bk5/kernel/workqueue.c
--- linux-2.6.11-rc4-bk4/kernel/workqueue.c	2005-02-13 04:07:49.000000000 +0100
+++ linux-2.6.11-rc4-bk5/kernel/workqueue.c	2005-02-17 14:53:48.756440167 +0100
@@ -485,8 +485,10 @@ static int __devinit workqueue_cpu_callb
 
 	case CPU_ONLINE:
 		/* Kick off worker threads. */
-		list_for_each_entry(wq, &workqueues, list)
+		list_for_each_entry(wq, &workqueues, list) {
+			kthread_bind(wq->cpu_wq[hotcpu].thread, hotcpu);
 			wake_up_process(wq->cpu_wq[hotcpu].thread);
+		}
 		break;
 
 	case CPU_UP_CANCELED:
diff -purN linux-2.6.11-rc4-bk4/net/core/pktgen.c linux-2.6.11-rc4-bk5/net/core/pktgen.c
--- linux-2.6.11-rc4-bk4/net/core/pktgen.c	2005-02-13 04:08:05.000000000 +0100
+++ linux-2.6.11-rc4-bk5/net/core/pktgen.c	2005-02-17 14:53:48.769438142 +0100
@@ -148,7 +148,7 @@
 #include <asm/timex.h>
 
 
-#define VERSION  "pktgen v2.54: Packet Generator for packet performance testing.\n"
+#define VERSION  "pktgen v2.56: Packet Generator for packet performance testing.\n"
 
 /* #define PG_DEBUG(a) a */
 #define PG_DEBUG(a) 
@@ -167,9 +167,6 @@
 #define F_TXSIZE_RND  (1<<6)  /* Transmit size is random */
 #define F_IPV6        (1<<7)  /* Interface in IPV6 Mode */
 
-#define L_PUSH(t, i)              {i->next = t; t=i;}
-#define L_POP(t, i)               {i=t; if(i) t = i->next;}
-
 /* Thread control flag bits */
 #define T_TERMINATE   (1<<0)  
 #define T_STOP        (1<<1)  /* Stop run */
@@ -1366,19 +1363,15 @@ static int proc_thread_read(char *buf , 
         p += sprintf(p, "Running: ");
         
         if_lock(t);
-        pkt_dev = t->if_list;
-        while (pkt_dev && pkt_dev->running) {
-                p += sprintf(p, "%s ", pkt_dev->ifname);
-                pkt_dev = pkt_dev->next;
-        }
+        for(pkt_dev = t->if_list;pkt_dev; pkt_dev = pkt_dev->next) 
+		if(pkt_dev->running)
+			p += sprintf(p, "%s ", pkt_dev->ifname);
+        
         p += sprintf(p, "\nStopped: ");
 
-        pkt_dev = t->if_list;
-        while (pkt_dev && !pkt_dev->running) {
-                p += sprintf(p, "%s ", pkt_dev->ifname);
-                pkt_dev = pkt_dev->next;
-        }
-
+        for(pkt_dev = t->if_list;pkt_dev; pkt_dev = pkt_dev->next) 
+		if(!pkt_dev->running)
+			p += sprintf(p, "%s ", pkt_dev->ifname);
 
 	if (t->result[0])
 		p += sprintf(p, "\nResult: %s\n", t->result);
@@ -2393,7 +2386,7 @@ static void pktgen_stop_all_threads_ifs(
        thread_unlock();
 }
 
-static int running(struct pktgen_thread *t )
+static int thread_is_running(struct pktgen_thread *t )
 {
         struct pktgen_dev *next;
         int res = 0;
@@ -2415,7 +2408,7 @@ static int pktgen_wait_thread_run(struct
         
         if_lock(t);
 
-        while(running(t)) {
+        while(thread_is_running(t)) {
                 if_unlock(t);
         
                 interruptible_sleep_on_timeout(&queue, HZ/10);
@@ -2520,13 +2513,15 @@ static int pktgen_stop_device(struct pkt
                 return -EINVAL;
         }
 
-	if (pkt_dev->skb) 
-		kfree_skb(pkt_dev->skb);
-
         pkt_dev->stopped_at = getCurUs();
         pkt_dev->running = 0;
 
 	show_results(pkt_dev, skb_shinfo(pkt_dev->skb)->nr_frags);
+
+	if (pkt_dev->skb) 
+		kfree_skb(pkt_dev->skb);
+
+	pkt_dev->skb = NULL;
 	
         return 0;
 }
@@ -2860,10 +2855,10 @@ static struct pktgen_dev *pktgen_find_de
 
         for(pkt_dev=t->if_list; pkt_dev; pkt_dev = pkt_dev->next ) {
                 if (strcmp(pkt_dev->ifname, ifname) == 0) {
-                        goto out;
+                        break;
                 }
         }
- out:
+
         if_unlock(t);
 	PG_DEBUG(printk("pktgen: find_dev(%s) returning %p\n", ifname,pkt_dev));
         return pkt_dev;
@@ -2884,8 +2879,7 @@ static int add_dev_to_thread(struct pktg
                 rv = -EBUSY;
                 goto out;
         }
-
-	L_PUSH(t->if_list, pkt_dev);
+	pkt_dev->next =t->if_list; t->if_list=pkt_dev;
         pkt_dev->pg_thread = t;
 	pkt_dev->running = 0;
 
