This is a workaround for SuSE bug #42902/LTC9841

Problem description courtesy of David Stevens:

	It appears that conntrack, when loaded, is queueing the fragments
	for reassembly pre-routing (ie, when skb->dst is 0) and giving
	the fully reassembled packet to the pre-routing code which will
	set skb->dst before using it.

	IP without conntrack does the queueing of fragments and reassembly
	post-routing, so skb->dst in that case is set for all fragments
	and the reassembled packet.

	In the failure scenario, it appears that conntrack has queued
	some of the fragments (w/ skb->dst=0, esp. in the offset=0 first
	fragment) and then the conntrack module is removed. Arrival
	of a fragment afterward will queue and reassemble the entire
	packet post-routing, but the first frag still has skb->dst 0,
	so it'll blow up

To fix this, we simply drop the offending packets. A better fix would
be to change the conntrack module not to mess with the skbs in the
first place.

Index: linux-2.6.5/net/ipv4/ip_input.c
===================================================================
--- linux-2.6.5.orig/net/ipv4/ip_input.c	2004-08-02 14:51:53.000000000 +0200
+++ linux-2.6.5/net/ipv4/ip_input.c	2004-08-02 15:27:12.000000000 +0200
@@ -177,6 +177,14 @@
 					read_unlock(&ip_ra_lock);
 					return 1;
 				}
+				if (skb->dst == NULL) {
+					/* IP conntrack zaps skb->dst before queueing fragments,
+					 * and fixes up the skb before reinjecting it.
+					 * Too bad if the module is unloaded inbetween.
+					 */
+					 kfree_skb(skb);
+					 return 1;
+				 }
 			}
 			if (last) {
 				struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
@@ -281,6 +289,14 @@
 		skb = ip_defrag(skb);
 		if (!skb)
 			return 0;
+		if (skb->dst == NULL) {
+			/* IP conntrack zaps skb->dst before queueing fragments,
+			 * and fixes up the skb before reinjecting it.
+			 * Too bad if the module is unloaded inbetween.
+			 */
+			 kfree_skb(skb);
+			 return 0;
+		 }
 	}
 
 	return NF_HOOK_COND(PF_INET, NF_IP_LOCAL_IN, skb, skb->dev, NULL,
