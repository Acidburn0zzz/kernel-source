Subject: Fix dead blocking while module_init()
From: Takashi Iwai <tiwai@suse.de>
References: 46600

The patch fixes the dead blocking state during module_init()
when the module auto-loading is performed by the sequencer
modules.  


--- linux/include/sound/seq_kernel.h	23 Jun 2004 13:34:03 -0000	1.10
+++ linux/include/sound/seq_kernel.h	4 Oct 2004 10:06:33 -0000	1.11
@@ -180,4 +180,12 @@
 			      int cap, int type, int midi_channels, int midi_voices, char *portname);
 int snd_seq_event_port_detach(int client, int port);
 
+#ifdef CONFIG_KMOD
+void snd_seq_autoload_lock(void);
+void snd_seq_autoload_unlock(void);
+#else
+#define snd_seq_autload_lock()
+#define snd_seq_autoload_unlock()
+#endif
+
 #endif /* __SOUND_SEQ_KERNEL_H */
--- linux/sound/core/seq/seq.c	16 Sep 2004 13:25:36 -0000	1.13
+++ linux/sound/core/seq/seq.c	4 Oct 2004 10:06:20 -0000	1.14
@@ -71,39 +71,37 @@
  *  INIT PART
  */
 
-int snd_seq_in_init;
-
 static int __init alsa_seq_init(void)
 {
 	int err;
 
-	snd_seq_in_init = 1;
-
+	snd_seq_autoload_lock();
 	if ((err = client_init_data()) < 0)
-		return err;
+		goto error;
 
 	/* init memory, room for selected events */
 	if ((err = snd_sequencer_memory_init()) < 0)
-		return err;
+		goto error;
 
 	/* init event queues */
 	if ((err = snd_seq_queues_init()) < 0)
-		return err;
+		goto error;
 
 	/* register sequencer device */
 	if ((err = snd_sequencer_device_init()) < 0)
-		return err;
+		goto error;
 
 	/* register proc interface */
 	if ((err = snd_seq_info_init()) < 0)
-		return err;
+		goto error;
 
 	/* register our internal client */
 	if ((err = snd_seq_system_client_init()) < 0)
-		return err;
+		goto error;
 
-	snd_seq_in_init = 0;
-	return 0;
+ error:
+	snd_seq_autoload_unlock();
+	return err;
 }
 
 static void __exit alsa_seq_exit(void)
--- linux/sound/core/seq/seq_clientmgr.c	16 Sep 2004 13:25:36 -0000	1.37
+++ linux/sound/core/seq/seq_clientmgr.c	4 Oct 2004 10:06:20 -0000	1.38
@@ -152,16 +152,11 @@
 		} else if (clientid >= 64 && clientid < 128) {
 			int card = (clientid - 64) / 8;
 			if (card < snd_ecards_limit) {
-				extern int snd_seq_in_init;
 				if (! card_requested[card]) {
 					card_requested[card] = 1;
 					snd_request_card(card);
 				}
-				/* Calling request_module during module_init()
-				 * may cause blocking.
-				 */
-				if (! snd_seq_in_init)
-					snd_seq_device_load_drivers();
+				snd_seq_device_load_drivers();
 			}
 		}
 		spin_lock_irqsave(&clients_lock, flags);
--- linux/sound/core/seq/seq_device.c	30 Jun 2004 14:20:19 -0000	1.14
+++ linux/sound/core/seq/seq_device.c	4 Oct 2004 10:06:20 -0000	1.15
@@ -125,11 +125,31 @@
  * load all registered drivers (called from seq_clientmgr.c)
  */
 
+#ifdef CONFIG_KMOD
+/* avoid auto-loading during module_init() */
+static int snd_seq_in_init;
+void snd_seq_autoload_lock(void)
+{
+	snd_seq_in_init++;
+}
+
+void snd_seq_autoload_unlock(void)
+{
+	snd_seq_in_init--;
+}
+#endif
+
 void snd_seq_device_load_drivers(void)
 {
 #ifdef CONFIG_KMOD
 	struct list_head *head;
 
+	/* Calling request_module during module_init()
+	 * may cause blocking.
+	 */
+	if (snd_seq_in_init)
+		return;
+
 	if (! current->fs->root)
 		return;
 
@@ -309,12 +329,16 @@
 	    entry->init_device == NULL || entry->free_device == NULL)
 		return -EINVAL;
 
+	snd_seq_autoload_lock();
 	ops = find_driver(id, 1);
-	if (ops == NULL)
+	if (ops == NULL) {
+		snd_seq_autoload_unlock();
 		return -ENOMEM;
+	}
 	if (ops->driver & DRIVER_LOADED) {
 		snd_printk(KERN_WARNING "driver_register: driver '%s' already exists\n", id);
 		unlock_driver(ops);
+		snd_seq_autoload_unlock();
 		return -EBUSY;
 	}
 
@@ -332,6 +356,7 @@
 	up(&ops->reg_mutex);
 
 	unlock_driver(ops);
+	snd_seq_autoload_unlock();
 
 	return 0;
 }
@@ -543,3 +568,7 @@
 EXPORT_SYMBOL(snd_seq_device_new);
 EXPORT_SYMBOL(snd_seq_device_register_driver);
 EXPORT_SYMBOL(snd_seq_device_unregister_driver);
+#ifdef CONFIG_KMOD
+EXPORT_SYMBOL(snd_seq_autoload_lock);
+EXPORT_SYMBOL(snd_seq_autoload_unlock);
+#endif
--- linux/sound/core/seq/seq_dummy.c	16 Aug 2004 10:01:37 -0000	1.14
+++ linux/sound/core/seq/seq_dummy.c	4 Oct 2004 10:06:20 -0000	1.15
@@ -256,7 +256,11 @@
 
 static int __init alsa_seq_dummy_init(void)
 {
-	return register_client();
+	int err;
+	snd_seq_autoload_lock();
+	err = register_client();
+	snd_seq_autoload_unlock();
+	return err;
 }
 
 static void __exit alsa_seq_dummy_exit(void)
--- linux/sound/core/seq/seq_midi.c	22 Sep 2004 11:21:34 -0000	1.23
+++ linux/sound/core/seq/seq_midi.c	4 Oct 2004 10:06:20 -0000	1.24
@@ -464,7 +464,9 @@
 		snd_seq_midisynth_unregister_port,
 	};
 	memset(&synths, 0, sizeof(synths));
+	snd_seq_autoload_lock();
 	snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_MIDISYNTH, &ops, 0);
+	snd_seq_autoload_unlock();
 	return 0;
 }
 
--- linux/sound/core/seq/oss/seq_oss.c	16 Jul 2004 16:50:36 -0000	1.13
+++ linux/sound/core/seq/oss/seq_oss.c	4 Oct 2004 10:06:21 -0000	1.14
@@ -78,16 +78,17 @@
 		snd_seq_oss_synth_unregister,
 	};
 
+	snd_seq_autoload_lock();
 	if ((rc = register_device()) < 0)
-		return rc;
+		goto error;
 	if ((rc = register_proc()) < 0) {
 		unregister_device();
-		return rc;
+		goto error;
 	}
 	if ((rc = snd_seq_oss_create_client()) < 0) {
 		unregister_proc();
 		unregister_device();
-		return rc;
+		goto error;
 	}
 
 	if ((rc = snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_OSS, &ops,
@@ -95,12 +96,15 @@
 		snd_seq_oss_delete_client();
 		unregister_proc();
 		unregister_device();
-		return rc;
+		goto error;
 	}
 
 	/* success */
 	snd_seq_oss_synth_init();
-	return 0;
+
+ error:
+	snd_seq_autoload_unlock();
+	return rc;
 }
 
 static void __exit alsa_seq_oss_exit(void)
