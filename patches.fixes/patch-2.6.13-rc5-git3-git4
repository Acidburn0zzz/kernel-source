Subject: patch-2.6.13-rc5-git4
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

diff -purN linux-2.6.13-rc5-git3/Makefile linux-2.6.13-rc5-git4/Makefile
--- linux-2.6.13-rc5-git3/Makefile	2005-08-05 13:06:57.000000000 +0200
+++ linux-2.6.13-rc5-git4/Makefile	2005-08-06 11:46:19.873134763 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 13
-EXTRAVERSION = -rc5-git3
+EXTRAVERSION = -rc5-git4
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.13-rc5-git3/REPORTING-BUGS linux-2.6.13-rc5-git4/REPORTING-BUGS
--- linux-2.6.13-rc5-git3/REPORTING-BUGS	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/REPORTING-BUGS	2005-08-06 11:46:19.874134608 +0200
@@ -41,18 +41,19 @@ summary from [1.]>" for easy identificat
 [2.] Full description of the problem/report:
 [3.] Keywords (i.e., modules, networking, kernel):
 [4.] Kernel version (from /proc/version):
-[5.] Output of Oops.. message (if applicable) with symbolic information 
+[5.] Most recent kernel version which did not have the bug:
+[6.] Output of Oops.. message (if applicable) with symbolic information
      resolved (see Documentation/oops-tracing.txt)
-[6.] A small shell script or example program which triggers the
+[7.] A small shell script or example program which triggers the
      problem (if possible)
-[7.] Environment
-[7.1.] Software (add the output of the ver_linux script here)
-[7.2.] Processor information (from /proc/cpuinfo):
-[7.3.] Module information (from /proc/modules):
-[7.4.] Loaded driver and hardware information (/proc/ioports, /proc/iomem)
-[7.5.] PCI information ('lspci -vvv' as root)
-[7.6.] SCSI information (from /proc/scsi/scsi)
-[7.7.] Other information that might be relevant to the problem
+[8.] Environment
+[8.1.] Software (add the output of the ver_linux script here)
+[8.2.] Processor information (from /proc/cpuinfo):
+[8.3.] Module information (from /proc/modules):
+[8.4.] Loaded driver and hardware information (/proc/ioports, /proc/iomem)
+[8.5.] PCI information ('lspci -vvv' as root)
+[8.6.] SCSI information (from /proc/scsi/scsi)
+[8.7.] Other information that might be relevant to the problem
        (please look in /proc and include all information that you
        think to be relevant):
 [X.] Other notes, patches, fixes, workarounds:
diff -purN linux-2.6.13-rc5-git3/arch/i386/mach-voyager/voyager_basic.c linux-2.6.13-rc5-git4/arch/i386/mach-voyager/voyager_basic.c
--- linux-2.6.13-rc5-git3/arch/i386/mach-voyager/voyager_basic.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/arch/i386/mach-voyager/voyager_basic.c	2005-08-06 11:46:20.004114448 +0200
@@ -279,6 +279,13 @@ machine_restart(char *cmd)
 }
 
 void
+machine_emergency_restart(void)
+{
+	/*for now, just hook this to a warm restart */
+	machine_restart(NULL);
+}
+
+void
 mca_nmi_hook(void)
 {
 	__u8 dumpval __attribute__((unused)) = inb(0xf823);
diff -purN linux-2.6.13-rc5-git3/arch/ppc64/boot/zlib.c linux-2.6.13-rc5-git4/arch/ppc64/boot/zlib.c
--- linux-2.6.13-rc5-git3/arch/ppc64/boot/zlib.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/arch/ppc64/boot/zlib.c	2005-08-06 11:46:20.032110106 +0200
@@ -1307,7 +1307,7 @@ local int huft_build(
   {
     *t = (inflate_huft *)Z_NULL;
     *m = 0;
-    return Z_OK;
+    return Z_DATA_ERROR;
   }
 
 
@@ -1351,6 +1351,7 @@ local int huft_build(
     if ((j = *p++) != 0)
       v[x[j]++] = i;
   } while (++i < n);
+  n = x[g];			/* set n to length of v */
 
 
   /* Generate the Huffman codes and for each, make the table entries */
diff -purN linux-2.6.13-rc5-git3/drivers/block/ll_rw_blk.c linux-2.6.13-rc5-git4/drivers/block/ll_rw_blk.c
--- linux-2.6.13-rc5-git3/drivers/block/ll_rw_blk.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/drivers/block/ll_rw_blk.c	2005-08-06 11:46:20.139093513 +0200
@@ -719,7 +719,7 @@ struct request *blk_queue_find_tag(reque
 {
 	struct blk_queue_tag *bqt = q->queue_tags;
 
-	if (unlikely(bqt == NULL || tag >= bqt->max_depth))
+	if (unlikely(bqt == NULL || tag >= bqt->real_max_depth))
 		return NULL;
 
 	return bqt->tag_index[tag];
@@ -798,6 +798,7 @@ init_tag_map(request_queue_t *q, struct 
 
 	memset(tag_index, 0, depth * sizeof(struct request *));
 	memset(tag_map, 0, nr_ulongs * sizeof(unsigned long));
+	tags->real_max_depth = depth;
 	tags->max_depth = depth;
 	tags->tag_index = tag_index;
 	tags->tag_map = tag_map;
@@ -872,11 +873,22 @@ int blk_queue_resize_tags(request_queue_
 		return -ENXIO;
 
 	/*
+	 * if we already have large enough real_max_depth.  just
+	 * adjust max_depth.  *NOTE* as requests with tag value
+	 * between new_depth and real_max_depth can be in-flight, tag
+	 * map can not be shrunk blindly here.
+	 */
+	if (new_depth <= bqt->real_max_depth) {
+		bqt->max_depth = new_depth;
+		return 0;
+	}
+
+	/*
 	 * save the old state info, so we can copy it back
 	 */
 	tag_index = bqt->tag_index;
 	tag_map = bqt->tag_map;
-	max_depth = bqt->max_depth;
+	max_depth = bqt->real_max_depth;
 
 	if (init_tag_map(q, bqt, new_depth))
 		return -ENOMEM;
@@ -913,7 +925,7 @@ void blk_queue_end_tag(request_queue_t *
 
 	BUG_ON(tag == -1);
 
-	if (unlikely(tag >= bqt->max_depth))
+	if (unlikely(tag >= bqt->real_max_depth))
 		/*
 		 * This can happen after tag depth has been reduced.
 		 * FIXME: how about a warning or info message here?
diff -purN linux-2.6.13-rc5-git3/drivers/char/rtc.c linux-2.6.13-rc5-git4/drivers/char/rtc.c
--- linux-2.6.13-rc5-git3/drivers/char/rtc.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/drivers/char/rtc.c	2005-08-06 11:46:20.147092272 +0200
@@ -1209,6 +1209,7 @@ static int rtc_proc_open(struct inode *i
 
 void rtc_get_rtc_time(struct rtc_time *rtc_tm)
 {
+	unsigned long uip_watchdog = jiffies;
 	unsigned char ctrl;
 #ifdef CONFIG_MACH_DECSTATION
 	unsigned int real_year;
@@ -1224,8 +1225,10 @@ void rtc_get_rtc_time(struct rtc_time *r
 	 * Once the read clears, read the RTC time (again via ioctl). Easy.
 	 */
 
-	if (rtc_is_updating() != 0)
-		msleep(20);
+	while (rtc_is_updating() != 0 && jiffies - uip_watchdog < 2*HZ/100) {
+		barrier();
+		cpu_relax();
+	}
 
 	/*
 	 * Only the values that we read from the RTC are set. We leave
diff -purN linux-2.6.13-rc5-git3/drivers/char/tpm/Kconfig linux-2.6.13-rc5-git4/drivers/char/tpm/Kconfig
--- linux-2.6.13-rc5-git3/drivers/char/tpm/Kconfig	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/drivers/char/tpm/Kconfig	2005-08-06 11:46:20.148092117 +0200
@@ -17,6 +17,8 @@ config TCG_TPM
 	  obtained at: <http://sourceforge.net/projects/trousers>.  To 
 	  compile this driver as a module, choose M here; the module 
 	  will be called tpm. If unsure, say N.
+	  Note: For more TPM drivers enable CONFIG_PNP, CONFIG_ACPI_BUS
+	  and CONFIG_PNPACPI.
 
 config TCG_NSC
 	tristate "National Semiconductor TPM Interface"
@@ -36,12 +38,13 @@ config TCG_ATMEL
 	  as a module, choose M here; the module will be called tpm_atmel.
 
 config TCG_INFINEON
-	tristate "Infineon Technologies SLD 9630 TPM Interface"
-	depends on TCG_TPM
+	tristate "Infineon Technologies TPM Interface"
+	depends on TCG_TPM && PNPACPI
 	---help---
 	  If you have a TPM security chip from Infineon Technologies
-	  say Yes and it will be accessible from within Linux.  To
-	  compile this driver as a module, choose M here; the module
+	  (either SLD 9630 TT 1.1 or SLB 9635 TT 1.2) say Yes and it
+	  will be accessible from within Linux.
+	  To compile this driver as a module, choose M here; the module
 	  will be called tpm_infineon.
 	  Further information on this driver and the supported hardware
 	  can be found at http://www.prosec.rub.de/tpm
diff -purN linux-2.6.13-rc5-git3/drivers/char/tpm/tpm_infineon.c linux-2.6.13-rc5-git4/drivers/char/tpm/tpm_infineon.c
--- linux-2.6.13-rc5-git3/drivers/char/tpm/tpm_infineon.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/drivers/char/tpm/tpm_infineon.c	2005-08-06 11:46:20.155091032 +0200
@@ -1,7 +1,7 @@
 /*
  * Description:
  * Device Driver for the Infineon Technologies
- * SLD 9630 TT Trusted Platform Module
+ * SLD 9630 TT 1.1 and SLB 9635 TT 1.2 Trusted Platform Module
  * Specifications at www.trustedcomputinggroup.org
  *
  * Copyright (C) 2005, Marcel Selhorst <selhorst@crypto.rub.de>
@@ -12,9 +12,10 @@
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation, version 2 of the
  * License.
- *
  */
 
+#include <acpi/acpi_bus.h>
+#include <linux/pnp.h>
 #include "tpm.h"
 
 /* Infineon specific definitions */
@@ -26,8 +27,11 @@
 #define	TPM_MSLEEP_TIME 	3
 /* gives number of max. msleep()-calls before throwing timeout */
 #define	TPM_MAX_TRIES		5000
-#define	TCPA_INFINEON_DEV_VEN_VALUE	0x15D1
-#define	TPM_DATA 			(TPM_ADDR + 1) & 0xff
+#define	TPM_INFINEON_DEV_VEN_VALUE	0x15D1
+
+/* These values will be filled after ACPI-call */
+static int TPM_INF_DATA = 0;
+static int TPM_INF_ADDR = 0;
 
 /* TPM header definitions */
 enum infineon_tpm_header {
@@ -305,9 +309,10 @@ static int tpm_inf_send(struct tpm_chip 
 
 static void tpm_inf_cancel(struct tpm_chip *chip)
 {
-	/* Nothing yet!
-	   This has something to do with the internal functions
-	   of the TPM. Abort isn't really necessary...
+	/*
+	   Since we are using the legacy mode to communicate
+	   with the TPM, we have no cancel functions, but have
+	   a workaround for interrupting the TPM through WTX.
 	 */
 }
 
@@ -345,6 +350,32 @@ static struct tpm_vendor_specific tpm_in
 	.miscdev = {.fops = &inf_ops,},
 };
 
+static const struct pnp_device_id tpm_pnp_tbl[] = {
+	/* Infineon TPMs */
+	{"IFX0101", 0},
+	{"IFX0102", 0},
+	{"", 0}
+};
+
+static int __devinit tpm_inf_acpi_probe(struct pnp_dev *dev,
+					const struct pnp_device_id *dev_id)
+{
+	TPM_INF_ADDR = (pnp_port_start(dev, 0) & 0xff);
+	TPM_INF_DATA = ((TPM_INF_ADDR + 1) & 0xff);
+	tpm_inf.base = pnp_port_start(dev, 1);
+	dev_info(&dev->dev, "Found %s with ID %s\n",
+		 dev->name, dev_id->id);
+	if (!((tpm_inf.base >> 8) & 0xff))
+		tpm_inf.base = 0;
+	return 0;
+}
+
+static struct pnp_driver tpm_inf_pnp = {
+	.name = "tpm_inf_pnp",
+	.id_table = tpm_pnp_tbl,
+	.probe = tpm_inf_acpi_probe,
+};
+
 static int __devinit tpm_inf_probe(struct pci_dev *pci_dev,
 				   const struct pci_device_id *pci_id)
 {
@@ -353,64 +384,99 @@ static int __devinit tpm_inf_probe(struc
 	int vendorid[2];
 	int version[2];
 	int productid[2];
+	char chipname[20];
 
 	if (pci_enable_device(pci_dev))
 		return -EIO;
 
 	dev_info(&pci_dev->dev, "LPC-bus found at 0x%x\n", pci_id->device);
 
+	/* read IO-ports from ACPI */
+	pnp_register_driver(&tpm_inf_pnp);
+	pnp_unregister_driver(&tpm_inf_pnp);
+
+	/* Make sure, we have received valid config ports */
+	if (!TPM_INF_ADDR) {
+		pci_disable_device(pci_dev);
+		return -EIO;
+	}
+
 	/* query chip for its vendor, its version number a.s.o. */
-	outb(ENABLE_REGISTER_PAIR, TPM_ADDR);
-	outb(IDVENL, TPM_ADDR);
-	vendorid[1] = inb(TPM_DATA);
-	outb(IDVENH, TPM_ADDR);
-	vendorid[0] = inb(TPM_DATA);
-	outb(IDPDL, TPM_ADDR);
-	productid[1] = inb(TPM_DATA);
-	outb(IDPDH, TPM_ADDR);
-	productid[0] = inb(TPM_DATA);
-	outb(CHIP_ID1, TPM_ADDR);
-	version[1] = inb(TPM_DATA);
-	outb(CHIP_ID2, TPM_ADDR);
-	version[0] = inb(TPM_DATA);
-
-	if ((vendorid[0] << 8 | vendorid[1]) == (TCPA_INFINEON_DEV_VEN_VALUE)) {
-
-		/* read IO-ports from TPM */
-		outb(IOLIMH, TPM_ADDR);
-		ioh = inb(TPM_DATA);
-		outb(IOLIML, TPM_ADDR);
-		iol = inb(TPM_DATA);
-		tpm_inf.base = (ioh << 8) | iol;
+	outb(ENABLE_REGISTER_PAIR, TPM_INF_ADDR);
+	outb(IDVENL, TPM_INF_ADDR);
+	vendorid[1] = inb(TPM_INF_DATA);
+	outb(IDVENH, TPM_INF_ADDR);
+	vendorid[0] = inb(TPM_INF_DATA);
+	outb(IDPDL, TPM_INF_ADDR);
+	productid[1] = inb(TPM_INF_DATA);
+	outb(IDPDH, TPM_INF_ADDR);
+	productid[0] = inb(TPM_INF_DATA);
+	outb(CHIP_ID1, TPM_INF_ADDR);
+	version[1] = inb(TPM_INF_DATA);
+	outb(CHIP_ID2, TPM_INF_ADDR);
+	version[0] = inb(TPM_INF_DATA);
+
+	switch ((productid[0] << 8) | productid[1]) {
+	case 6:
+		sprintf(chipname, " (SLD 9630 TT 1.1)");
+		break;
+	case 11:
+		sprintf(chipname, " (SLB 9635 TT 1.2)");
+		break;
+	default:
+		sprintf(chipname, " (unknown chip)");
+		break;
+	}
+	chipname[19] = 0;
+
+	if ((vendorid[0] << 8 | vendorid[1]) == (TPM_INFINEON_DEV_VEN_VALUE)) {
 
 		if (tpm_inf.base == 0) {
-			dev_err(&pci_dev->dev, "No IO-ports set!\n");
+			dev_err(&pci_dev->dev, "No IO-ports found!\n");
 			pci_disable_device(pci_dev);
-			return -ENODEV;
+			return -EIO;
+		}
+		/* configure TPM with IO-ports */
+		outb(IOLIMH, TPM_INF_ADDR);
+		outb(((tpm_inf.base >> 8) & 0xff), TPM_INF_DATA);
+		outb(IOLIML, TPM_INF_ADDR);
+		outb((tpm_inf.base & 0xff), TPM_INF_DATA);
+
+		/* control if IO-ports are set correctly */
+		outb(IOLIMH, TPM_INF_ADDR);
+		ioh = inb(TPM_INF_DATA);
+		outb(IOLIML, TPM_INF_ADDR);
+		iol = inb(TPM_INF_DATA);
+
+		if ((ioh << 8 | iol) != tpm_inf.base) {
+			dev_err(&pci_dev->dev,
+				"Could not set IO-ports to %04x\n",
+				tpm_inf.base);
+			pci_disable_device(pci_dev);
+			return -EIO;
 		}
 
 		/* activate register */
-		outb(TPM_DAR, TPM_ADDR);
-		outb(0x01, TPM_DATA);
-		outb(DISABLE_REGISTER_PAIR, TPM_ADDR);
+		outb(TPM_DAR, TPM_INF_ADDR);
+		outb(0x01, TPM_INF_DATA);
+		outb(DISABLE_REGISTER_PAIR, TPM_INF_ADDR);
 
 		/* disable RESET, LP and IRQC */
 		outb(RESET_LP_IRQC_DISABLE, tpm_inf.base + CMD);
 
 		/* Finally, we're done, print some infos */
 		dev_info(&pci_dev->dev, "TPM found: "
+			 "config base 0x%x, "
 			 "io base 0x%x, "
 			 "chip version %02x%02x, "
 			 "vendor id %x%x (Infineon), "
 			 "product id %02x%02x"
 			 "%s\n",
+			 TPM_INF_ADDR,
 			 tpm_inf.base,
 			 version[0], version[1],
 			 vendorid[0], vendorid[1],
-			 productid[0], productid[1], ((productid[0] == 0)
-						      && (productid[1] ==
-							  6)) ?
-			 " (SLD 9630 TT 1.1)" : "");
+			 productid[0], productid[1], chipname);
 
 		rc = tpm_register_hardware(pci_dev, &tpm_inf);
 		if (rc < 0) {
@@ -462,6 +528,6 @@ module_init(init_inf);
 module_exit(cleanup_inf);
 
 MODULE_AUTHOR("Marcel Selhorst <selhorst@crypto.rub.de>");
-MODULE_DESCRIPTION("Driver for Infineon TPM SLD 9630 TT");
-MODULE_VERSION("1.4");
+MODULE_DESCRIPTION("Driver for Infineon TPM SLD 9630 TT 1.1 / SLB 9635 TT 1.2");
+MODULE_VERSION("1.5");
 MODULE_LICENSE("GPL");
diff -purN linux-2.6.13-rc5-git3/drivers/sbus/char/vfc.h linux-2.6.13-rc5-git4/drivers/sbus/char/vfc.h
--- linux-2.6.13-rc5-git3/drivers/sbus/char/vfc.h	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/drivers/sbus/char/vfc.h	2005-08-06 11:46:20.249209300 +0200
@@ -129,8 +129,6 @@ struct vfc_dev {
 	struct vfc_regs *phys_regs;
 	unsigned int control_reg;
 	struct semaphore device_lock_sem;
-	struct timer_list poll_timer;
-	wait_queue_head_t poll_wait;
 	int instance;
 	int busy;
 	unsigned long which_io;
diff -purN linux-2.6.13-rc5-git3/drivers/sbus/char/vfc_dev.c linux-2.6.13-rc5-git4/drivers/sbus/char/vfc_dev.c
--- linux-2.6.13-rc5-git3/drivers/sbus/char/vfc_dev.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/drivers/sbus/char/vfc_dev.c	2005-08-06 11:46:20.251208990 +0200
@@ -137,7 +137,6 @@ int init_vfc_devstruct(struct vfc_dev *d
 	dev->instance=instance;
 	init_MUTEX(&dev->device_lock_sem);
 	dev->control_reg=0;
-	init_waitqueue_head(&dev->poll_wait);
 	dev->busy=0;
 	return 0;
 }
diff -purN linux-2.6.13-rc5-git3/drivers/sbus/char/vfc_i2c.c linux-2.6.13-rc5-git4/drivers/sbus/char/vfc_i2c.c
--- linux-2.6.13-rc5-git3/drivers/sbus/char/vfc_i2c.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/drivers/sbus/char/vfc_i2c.c	2005-08-06 11:46:20.253208679 +0200
@@ -79,25 +79,10 @@ int vfc_pcf8584_init(struct vfc_dev *dev
 	return 0;
 }
 
-void vfc_i2c_delay_wakeup(struct vfc_dev *dev) 
-{
-	/* Used to profile code and eliminate too many delays */
-	VFC_I2C_DEBUG_PRINTK(("vfc%d: Delaying\n", dev->instance));
-	wake_up(&dev->poll_wait);
-}
-
 void vfc_i2c_delay_no_busy(struct vfc_dev *dev, unsigned long usecs) 
 {
-	DEFINE_WAIT(wait);
-	init_timer(&dev->poll_timer);
-	dev->poll_timer.expires = jiffies + usecs_to_jiffies(usecs);
-	dev->poll_timer.data=(unsigned long)dev;
-	dev->poll_timer.function=(void *)(unsigned long)vfc_i2c_delay_wakeup;
-	add_timer(&dev->poll_timer);
-	prepare_to_wait(&dev->poll_wait, &wait, TASK_UNINTERRUPTIBLE);
-	schedule();
-	del_timer(&dev->poll_timer);
-	finish_wait(&dev->poll_wait, &wait);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(usecs_to_jiffies(usecs));
 }
 
 void inline vfc_i2c_delay(struct vfc_dev *dev) 
diff -purN linux-2.6.13-rc5-git3/include/asm-ppc/pgtable.h linux-2.6.13-rc5-git4/include/asm-ppc/pgtable.h
--- linux-2.6.13-rc5-git3/include/asm-ppc/pgtable.h	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/include/asm-ppc/pgtable.h	2005-08-06 11:46:20.364191466 +0200
@@ -202,18 +202,64 @@ extern unsigned long ioremap_bot, iorema
  *
  * Note that these bits preclude future use of a page size
  * less than 4KB.
+ *
+ *
+ * PPC 440 core has following TLB attribute fields;
+ *
+ *   TLB1:
+ *   0  1  2  3  4  ... 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
+ *   RPN.................................  -  -  -  -  -  - ERPN.......
+ *
+ *   TLB2:
+ *   0  1  2  3  4  ... 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
+ *   -  -  -  -  -    - U0 U1 U2 U3 W  I  M  G  E   - UX UW UR SX SW SR
+ *
+ * There are some constrains and options, to decide mapping software bits
+ * into TLB entry.
+ *
+ *   - PRESENT *must* be in the bottom three bits because swap cache
+ *     entries use the top 29 bits for TLB2.
+ *
+ *   - FILE *must* be in the bottom three bits because swap cache
+ *     entries use the top 29 bits for TLB2.
+ *
+ *   - CACHE COHERENT bit (M) has no effect on PPC440 core, because it
+ *     doesn't support SMP. So we can use this as software bit, like
+ *     DIRTY.
+ *
+ * PPC Book-E Linux implementation uses PPC HW PTE bit field definition,
+ * even it doesn't have HW PTE. 0-11th LSB of PTE stand for memory
+ * protection-related function. (See PTE structure in include/asm-ppc/mmu.h)
+ * Definition of _PAGE_XXX in "include/asm-ppc/pagetable.h" stands for
+ * above bits. Note that those bits values are CPU dependent, not
+ * architecture.
+ *
+ * Kernel PTE entry holds arch-dependent swp_entry structure under certain
+ * situation. In other words, in such situation, some portion of PTE bits
+ * are used as swp_entry. In PPC implementation, 3-24th LSB are shared with
+ * swp_entry, however 0-2nd three LSB still hold protection values.
+ * That means three protection bits are reserved for both PTE and SWAP
+ * entry at the most three LSBs.
+ *
+ * There are three protection bits available for SWAP entry;
+ *	_PAGE_PRESENT
+ *	_PAGE_FILE
+ *	_PAGE_HASHPTE (if HW has)
+ *
+ * So those three bits have to be inside of 0-2nd LSB of PTE.
+ *
  */
+
 #define _PAGE_PRESENT	0x00000001		/* S: PTE valid */
 #define	_PAGE_RW	0x00000002		/* S: Write permission */
-#define	_PAGE_DIRTY	0x00000004		/* S: Page dirty */
+#define _PAGE_FILE	0x00000004		/* S: nonlinear file mapping */
 #define _PAGE_ACCESSED	0x00000008		/* S: Page referenced */
 #define _PAGE_HWWRITE	0x00000010		/* H: Dirty & RW */
 #define _PAGE_HWEXEC	0x00000020		/* H: Execute permission */
 #define	_PAGE_USER	0x00000040		/* S: User page */
 #define	_PAGE_ENDIAN	0x00000080		/* H: E bit */
 #define	_PAGE_GUARDED	0x00000100		/* H: G bit */
-#define	_PAGE_COHERENT	0x00000200		/* H: M bit */
-#define _PAGE_FILE	0x00000400		/* S: nonlinear file mapping */
+#define	_PAGE_DIRTY	0x00000200		/* S: Page dirty */
 #define	_PAGE_NO_CACHE	0x00000400		/* H: I bit */
 #define	_PAGE_WRITETHRU	0x00000800		/* H: W bit */
 
diff -purN linux-2.6.13-rc5-git3/include/linux/blkdev.h linux-2.6.13-rc5-git4/include/linux/blkdev.h
--- linux-2.6.13-rc5-git3/include/linux/blkdev.h	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/include/linux/blkdev.h	2005-08-06 11:46:20.380188985 +0200
@@ -301,6 +301,7 @@ struct blk_queue_tag {
 	struct list_head busy_list;	/* fifo list of busy tags */
 	int busy;			/* current depth */
 	int max_depth;			/* what we will send to device */
+	int real_max_depth;		/* what the array can hold */
 	atomic_t refcnt;		/* map can be shared */
 };
 
diff -purN linux-2.6.13-rc5-git3/ipc/sem.c linux-2.6.13-rc5-git4/ipc/sem.c
--- linux-2.6.13-rc5-git3/ipc/sem.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/ipc/sem.c	2005-08-06 11:46:20.406184953 +0200
@@ -895,7 +895,7 @@ static inline void lock_semundo(void)
 	struct sem_undo_list *undo_list;
 
 	undo_list = current->sysvsem.undo_list;
-	if ((undo_list != NULL) && (atomic_read(&undo_list->refcnt) != 1))
+	if (undo_list)
 		spin_lock(&undo_list->lock);
 }
 
@@ -915,7 +915,7 @@ static inline void unlock_semundo(void)
 	struct sem_undo_list *undo_list;
 
 	undo_list = current->sysvsem.undo_list;
-	if ((undo_list != NULL) && (atomic_read(&undo_list->refcnt) != 1))
+	if (undo_list)
 		spin_unlock(&undo_list->lock);
 }
 
@@ -943,9 +943,7 @@ static inline int get_undo_list(struct s
 		if (undo_list == NULL)
 			return -ENOMEM;
 		memset(undo_list, 0, size);
-		/* don't initialize unodhd->lock here.  It's done
-		 * in copy_semundo() instead.
-		 */
+		spin_lock_init(&undo_list->lock);
 		atomic_set(&undo_list->refcnt, 1);
 		current->sysvsem.undo_list = undo_list;
 	}
@@ -1231,8 +1229,6 @@ int copy_semundo(unsigned long clone_fla
 		error = get_undo_list(&undo_list);
 		if (error)
 			return error;
-		if (atomic_read(&undo_list->refcnt) == 1)
-			spin_lock_init(&undo_list->lock);
 		atomic_inc(&undo_list->refcnt);
 		tsk->sysvsem.undo_list = undo_list;
 	} else 
diff -purN linux-2.6.13-rc5-git3/lib/inflate.c linux-2.6.13-rc5-git4/lib/inflate.c
--- linux-2.6.13-rc5-git3/lib/inflate.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/lib/inflate.c	2005-08-06 11:46:20.428181541 +0200
@@ -326,7 +326,7 @@ DEBG("huft1 ");
   {
     *t = (struct huft *)NULL;
     *m = 0;
-    return 0;
+    return 2;
   }
 
 DEBG("huft2 ");
@@ -374,6 +374,7 @@ DEBG("huft5 ");
     if ((j = *p++) != 0)
       v[x[j]++] = i;
   } while (++i < n);
+  n = x[g];                   /* set n to length of v */
 
 DEBG("h6 ");
 
@@ -410,12 +411,13 @@ DEBG1("1 ");
 DEBG1("2 ");
           f -= a + 1;           /* deduct codes from patterns left */
           xp = c + k;
-          while (++j < z)       /* try smaller tables up to z bits */
-          {
-            if ((f <<= 1) <= *++xp)
-              break;            /* enough codes to use up j bits */
-            f -= *xp;           /* else deduct codes from patterns */
-          }
+          if (j < z)
+            while (++j < z)       /* try smaller tables up to z bits */
+            {
+              if ((f <<= 1) <= *++xp)
+                break;            /* enough codes to use up j bits */
+              f -= *xp;           /* else deduct codes from patterns */
+            }
         }
 DEBG1("3 ");
         z = 1 << j;             /* table entries for j-bit table */
diff -purN linux-2.6.13-rc5-git3/lib/zlib_inflate/inftrees.c linux-2.6.13-rc5-git4/lib/zlib_inflate/inftrees.c
--- linux-2.6.13-rc5-git3/lib/zlib_inflate/inftrees.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/lib/zlib_inflate/inftrees.c	2005-08-06 11:46:20.430181231 +0200
@@ -141,7 +141,7 @@ static int huft_build(
   {
     *t = NULL;
     *m = 0;
-    return Z_OK;
+    return Z_DATA_ERROR;
   }
 
 
diff -purN linux-2.6.13-rc5-git3/mm/hugetlb.c linux-2.6.13-rc5-git4/mm/hugetlb.c
--- linux-2.6.13-rc5-git3/mm/hugetlb.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/mm/hugetlb.c	2005-08-06 11:46:20.432180921 +0200
@@ -301,6 +301,7 @@ void unmap_hugepage_range(struct vm_area
 {
 	struct mm_struct *mm = vma->vm_mm;
 	unsigned long address;
+	pte_t *ptep;
 	pte_t pte;
 	struct page *page;
 
@@ -309,9 +310,17 @@ void unmap_hugepage_range(struct vm_area
 	BUG_ON(end & ~HPAGE_MASK);
 
 	for (address = start; address < end; address += HPAGE_SIZE) {
-		pte = huge_ptep_get_and_clear(mm, address, huge_pte_offset(mm, address));
+		ptep = huge_pte_offset(mm, address);
+		if (! ptep)
+			/* This can happen on truncate, or if an
+			 * mmap() is aborted due to an error before
+			 * the prefault */
+			continue;
+
+		pte = huge_ptep_get_and_clear(mm, address, ptep);
 		if (pte_none(pte))
 			continue;
+
 		page = pte_page(pte);
 		put_page(page);
 	}
diff -purN linux-2.6.13-rc5-git3/net/ipv4/fib_semantics.c linux-2.6.13-rc5-git4/net/ipv4/fib_semantics.c
--- linux-2.6.13-rc5-git3/net/ipv4/fib_semantics.c	2005-08-02 06:45:48.000000000 +0200
+++ linux-2.6.13-rc5-git4/net/ipv4/fib_semantics.c	2005-08-06 11:46:20.457177044 +0200
@@ -593,10 +593,13 @@ static void fib_hash_move(struct hlist_h
 			  struct hlist_head *new_laddrhash,
 			  unsigned int new_size)
 {
+	struct hlist_head *old_info_hash, *old_laddrhash;
 	unsigned int old_size = fib_hash_size;
-	unsigned int i;
+	unsigned int i, bytes;
 
 	write_lock(&fib_info_lock);
+	old_info_hash = fib_info_hash;
+	old_laddrhash = fib_info_laddrhash;
 	fib_hash_size = new_size;
 
 	for (i = 0; i < old_size; i++) {
@@ -636,6 +639,10 @@ static void fib_hash_move(struct hlist_h
 	fib_info_laddrhash = new_laddrhash;
 
 	write_unlock(&fib_info_lock);
+
+	bytes = old_size * sizeof(struct hlist_head *);
+	fib_hash_free(old_info_hash, bytes);
+	fib_hash_free(old_laddrhash, bytes);
 }
 
 struct fib_info *
