Subject: drivers using uncached allocator (e.g. SGI mspec driver) can MCA
References: 161480
From: SGI
Acked-by: schwab@suse.de
Patch-mainline: never

Index: linux/lib/genalloc.c
===================================================================
--- linux.orig/lib/genalloc.c	2006-04-05 12:39:43.062678589 -0500
+++ linux/lib/genalloc.c	2006-04-05 12:46:14.859944946 -0500
@@ -107,9 +107,10 @@
 			spin_unlock_irqrestore(&poolp->lock, flags);
 			ptr = (struct gen_pool_link *)poolp->get_new_chunk(poolp);
 			spin_lock_irqsave(&poolp->lock, flags);
-			h[j].next = ptr;
-			if (h[j].next)
-				h[j].next->next = NULL;
+			if (ptr != NULL) {
+				ptr->next = h[j].next;
+				h[j].next = ptr;
+			}
 			break;
 		}
 		j++;
@@ -129,6 +130,9 @@
 			h[j].next = (struct gen_pool_link *) (a + s);
 			h[j].next->next = NULL;
 		}
+		((struct gen_pool_link *)a)->next = NULL;
+		while (((volatile struct gen_pool_link *)a)->next != NULL)
+			;  /* spin until uncached write gets to FSB */
 	}
 	spin_unlock_irqrestore(&poolp->lock, flags);
 	return a;
@@ -161,8 +165,6 @@
 	spin_lock_irqsave(&poolp->lock, flags);
 	while (1) {
 		if (s == max_chunk_size) {
-			((struct gen_pool_link *)a)->next = h[i].next;
-			h[i].next = (struct gen_pool_link *)a;
 			break;
 		}
 		b = a ^ s;
@@ -172,15 +174,19 @@
 			q = q->next;
 
 		if (!q->next) {
-			((struct gen_pool_link *)a)->next = h[i].next;
-			h[i].next = (struct gen_pool_link *)a;
 			break;
 		}
 		q->next = q->next->next;
 		a = a & b;
+		b = a + s;
+		((struct gen_pool_link *)b)->next = NULL;
 		s <<= 1;
 		i++;
 	}
+	((struct gen_pool_link *)a)->next = h[i].next;
+	while (((volatile struct gen_pool_link *)a)->next != h[i].next)
+		;  /* spin until uncached write gets to FSB */
+	h[i].next = (struct gen_pool_link *)a;
 	spin_unlock_irqrestore(&poolp->lock, flags);
 }
 EXPORT_SYMBOL(gen_pool_free);
