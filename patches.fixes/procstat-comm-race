garloff

Bugfix 42364

The task->comm deref can go wrong and produce confusing output (resulting
in top to coredump) as we don't hold the task_lock. Fix copies the comm
field at a moment where we do.

diff -Naur linux-2.6.5-7.79/fs/proc/array.c linux-2.6.5-7.79.work/fs/proc/array.c
--- linux-2.6.5-7.79/fs/proc/array.c	2004-06-22 16:45:10.000000000 +0000
+++ linux-2.6.5-7.79.work/fs/proc/array.c	2004-06-23 03:46:18.000000000 +0000
@@ -307,6 +307,7 @@
  	pid_t ppid, pgid = -1, sid = -1;
 	int num_threads = 0;
 	struct mm_struct *mm;
+	char pname[sizeof(task->comm)];
 
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
@@ -314,6 +315,7 @@
 	mm = task->mm;
 	if(mm)
 		mm = mmgrab(mm);
+	memcpy(pname, task->comm, sizeof(pname));
 	task_unlock(task);
 	if (mm) {
 		down_read(&mm->mmap_sem);
@@ -356,7 +358,7 @@
 %lu %lu %lu %lu %lu %ld %ld %ld %ld %d %ld %llu %lu %ld %lu %lu %lu %lu %lu \
 %lu %lu %lu %lu %lu %lu %lu %lu %d %d %lu %lu\n",
 		task->pid,
-		task->comm,
+		pname,
 		state,
 		ppid,
 		pgid,
