From: olh@suse.de
Subject: patch-2.6.11-rc3-bk1

 ChangeSet@1.2077, 2005-02-03 17:09:48-08:00, ralf@linux-mips.org
   [PATCH] mips: SGI IP22 updates
   
    o Remove old unused header files
    o Update the VINO video driver to something that's vaguely working
    o Bug fixes for the IP22 Zilog driver
    o Fix use of config.h
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2076, 2005-02-03 17:05:33-08:00, linux@dominikbrodowski.de
   [PATCH] pcmcia: m32 registration failure fixup
   
   The pseudo-unregistration of PCMCIA sockets in case the registration of any
   such socket failed causes lockups.
   
   See http://bugme.osdl.org/show_bug.cgi?id=4115 for details (same problem,
   
   Signed-off-by: Dominik Brodowski <linux@brodo.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2075, 2005-02-03 17:05:20-08:00, linux@dominikbrodowski.de
   [PATCH] pcmcia: i82365 registration failure fixup
   
   Fix a bug which was diagnosed by David Howard <daveh@dmh2000.com>.
   
   The pseudo-unregistration of PCMCIA sockets in case the registration of any
   such socket failed causes lockups.
   
   See http://bugme.osdl.org/show_bug.cgi?id=4115 for details
   
   Signed-off-by: Dominik Brodowski <linux@brodo.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2074, 2005-02-03 17:05:05-08:00, sripathik@in.ibm.com
   [PATCH] s390: compat_sys_old_readdir and compat_sys_getdents
   
   s390 should use the generic compat functions for compat_sys_old_readdir and
   compat_sys_getdents.  The s390 specific ones are buggy and superflous.
   
   Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2073, 2005-02-03 17:04:51-08:00, hare@suse.de
   [PATCH] s390: compat SI_TIMER conversion
   
   tst-timer4 from the glibc fails in the 32bit compat execution environment. 
   This is due to a incomplete siginfo structure for POSIX.1b timers in
   compat_signal.c.
   
   Signed-off-by: Hannes Reinecke <hare@suse.de>
   Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2072, 2005-02-03 17:04:37-08:00, schwidefsky@de.ibm.com
   [PATCH] s390: qeth network driver
   
   From: Steffen Thoss <thoss@de.ibm.com>
   From: Frank Pavlic <pavlic@de.ibm.com>
   
   qeth network driver changes:
    - Improve performance by omitting svs.
    - Use function callback mechanism to set layer 2 parameters when getting
      a reply for a Layer 2 command.
    - dev->hard_header must not be NULL when fake_ll is no set since
      IPv6 and Layer2 needs the default function set by network stack.
    - ping6 works now when running in layer 2 mode.
    - Save original dev->hard_header to restore it when the user doesn't
      want to use fake_ll anymore.
    - Fake ethernet header in outgoing packets. This currently works
      only if qeth is compiled without ipv6 support.
    - Add more debug information in case of failures in qeth_set_offline.
    - Using fake_ll with HiperSockets devices results in misaligned
      ip packets and thus no traffic over HiperSockets.
    - Start qeth_remove_device only after the qeth recovery completed.
   
   Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2071, 2005-02-03 17:04:23-08:00, tspat@de.ibm.com
   [PATCH] s390: key protected i/o
   
   Add interface for key protected i/o.
   
   Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2070, 2005-02-03 17:04:09-08:00, cohuck@de.ibm.com
   [PATCH] s390: common i/o layer
   
   Common i/o layer changes:
    - Allow ccw_device_halt() and ccw_device_clear() in state WAIT4IO.
   
   Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2069, 2005-02-03 17:03:54-08:00, horst.hummel@de.ibm.com
   [PATCH] s390: dasd i/o scheduler & debug logs
   
   dasd driver change:
    - Set default i/o scheduler to 'deadline'. Latest performance
      results indicate that this works fastest.
    - Set default debug feature level to DBF_EMERG.
   
   Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2068, 2005-02-03 17:03:40-08:00, cborntra@de.ibm.com
   [PATCH] s390: cpcmd interface
   
   - Diagnose 8 needs a response buffer below 2GB real storage.
     As the caller cannot always allocate the buffer with GFP_DMA the best
     solution is to rewrite cpcmd to use a bounce buffer if necessary.
     The old function was renamed to __cpcmd and can be called if appropriate.
     The early boot code does not provide kmalloc but need cpcmd functionality.
     These places have been converted to use __cpcmd, as the init code and data
     are below 2GB.
   - In case of an 31 bit system, cpcmd is defined as __cpcmd.
   - EXPORT_SYMBOL(cpcmd) moved into cpcmd.c
   - some whitespace fixes in cpcmd.[c/h]
   
   Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2067, 2005-02-03 17:03:26-08:00, jlamanna@gmail.com
   [PATCH] s390: vfree checking cleanup
   
   arch/s390/kernel/module.c vfree() checking cleanup.
   
   Signed-off-by: James Lamanna <jlamanna@gmail.com>
   Signed-off-by: Domen Puncer <domen@coderock.org>
   Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2066, 2005-02-03 17:03:12-08:00, schwidefsky@de.ibm.com
   [PATCH] s390: core changes
   
   From: Christian Bornträger <cborntra@de.ibm.com>
   From: Heiko Carstens <heiko.carstens@de.ibm.com>
   From: Michael Holzheu <holzheu@de.ibm.com>
   From: Martin Schwidefsky <schwidefsky@de.ibm.com>
   
   s390 core changes:
    - Export arch_pick_mmap_layout as GPL symbol for binfmt_elf32.
    - Remove unnecessary include from cmm.
    - Allow only root to read the debug feature logs.
    - Register all RAM resources, this fixes output of /proc/iomem.
    - Add read_can_lock and write_can_lock primitives.
    - Regenerate default configuration.
   
   Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2065, 2005-02-03 17:02:57-08:00, mgreer@mvista.com
   [PATCH] ppc32: fix locking bugs in mv64x60 code
   
   This patch fixes 2 SMP deadlocks.  The first is that mv64x60_read() was
   returning before the unlock.  The second was mv64x60_modify() locks the
   spin lock and calls mv64x60_read() and mv64x60_write() which also lock the
   same spin lock.
   
   Signed-Off-By: Brian Waite <waite@skycomputers.com>
   Signed-off-by: Mark A. Greer <mgreer@mvista.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2064, 2005-02-03 17:02:43-08:00, mgreer@mvista.com
   [PATCH] ppc32: include/asm-ppc/rwsem.h RWSEM_DEBUG usage
   
   include/asm-ppc/rwsem.h has '#ifdef RWSEM_DEBUG' but RWSEM_DEBUG is always
   defined (as 0) in include/linux/rwsem.h.  The #ifdef's should be #if's. 
   This also brings the ppc usage in line with the the other architectures.
   
   Signed-off-by: Mark A. Greer <mgreer@mvista.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2063, 2005-02-03 17:02:28-08:00, mporter@kernel.crashing.org
   [PATCH] ppc32: add PPC440SP and Luan ref board support
   
   Adds support for the IBM/AMCC PPC440SP SoC.  Also adds support for the Luan
   reference board that has a 440SP on it.
   
   Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2062, 2005-02-03 17:02:13-08:00, mporter@kernel.crashing.org
   [PATCH] ppc32: PPC4xx DMA fixes, burst, and sg improvements
   
   This fixes several issues with the PPC4xx DMA library as well as adding
   support for bursting and some improvements to SG handling.
   
   Signed-off-by: Colin Wernham <cwernham@airspan.com>
   Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2061, 2005-02-03 17:02:00-08:00, sds@tycho.nsa.gov
   [PATCH] SELinux: audit any unmapped permissions
   
   This patch changes SELinux to display any permission values that could not
   be mapped to names as a hex value when generating an audit message.
   
   Signed-off-by:  Stephen Smalley <sds@tycho.nsa.gov>
   Signed-off-by:  James Morris <jmorris@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2060, 2005-02-03 17:01:47-08:00, sds@tycho.nsa.gov
   [PATCH] SELinux: define execmod permission for character devices
   
   This patch regenerates the SELinux module headers to define the execmod
   permission for character device files in order to provide proper auditing
   of such checks on /dev/zero.
   
   Signed-off-by:  Stephen Smalley <sds@tycho.nsa.gov>
   Signed-off-by:  James Morris <jmorris@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2059, 2005-02-03 17:01:33-08:00, dilinger@voxel.net
   [PATCH] cpufreq_resume() fix
   
   Since acpi_cpufreq_resume and speedstep_resume appear to return 0 upon
   success, it seems like the attached patch is what the desired behavior
   would be.  Otherwise, cpufreq_resume() always prints an error and exits
   early if using a cpufreq_driver that supports resume.
   
   Signed-off-by: Dominik Brodowski <linux@brodo.de>
   Signed-off-by: Dave Jones <davej@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2058, 2005-02-03 17:01:20-08:00, arnd@arndb.de
   [PATCH] SERIAL_TXX9 fix
   
   The earlier patch forgot to add the Makefile change.
   
   Signed-off-by: Arnd Bergmann <arnd@arndb.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2057, 2005-02-03 17:01:06-08:00, fanny.wakizaka@cyclades.com
   [PATCH] avma1_cs: Inverted parameter order in outb
   
   avma1_cs detect routine for AVM A1 based PCMCIA cards has its "outb"
   parameters inverted - switch to "byteout" define to be conformant with the
   rest of the driver, fixing the order.  
   
   This was noticed on PPC, which triggers an MCE in case of invalid IO port
   access, which is not the case on x86.
   
   Signed-off-by: Marcelo Tosatti <marcelo.tosatti@cyclades.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2056, 2005-02-03 17:00:52-08:00, trini@kernel.crashing.org
   [PATCH] Move <linux/prio_tree.h> down in <linux/fs.h>
   
   <linux/prio_tree.h> is unsafe for inclusion by userland apps, but it is in
   the userland-exposed portion of <linux/fs.h>.  It's only needed in the
   __KERNEL__ protected portion of the file, so move the #include down to
   there.
   
   lmbench-2.0.4 runs into this issue in 'flushdisk'.
   
   Signed-off-by: Tom Rini <trini@kernel.crashing.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2055, 2005-02-03 17:00:39-08:00, jack@suse.cz
   [PATCH] Fix reiserfs quota SMP locks
   
   From: Vladimir Saveliev <vs@namesys.com>, Jan Kara <jack@suse.cz>
   
   Add missing SMP locking and one lock_buffer() to the reiserfs quota code.
   
   Signed-off-by: Jan Kara <jack@suse.cz>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2054, 2005-02-03 17:00:26-08:00, agk@redhat.com
   [PATCH] device-mapper: Fixes for 64-bit sector_t
   
   Fix some bugs in device-mapper handling of 64-bit values, replacing
   dm_div_up() and dm_round_up() inlines with macros and removing some
   avoidable divisions of 64-bit numbers.
   
   The mirror region size is the granularity used to manage and monitor the
   data copying, typically 512KB, so 32 bits (of sectors) should be plenty to
   hold this.
   
   Taken together with the two earlier patches:
     "fix TB stripe data corruption" (a missing cast) and
     "stripe_width should be sector_t",
   I've now had 3 independent reports that this fixes device-mapper
   for devices with large stripes.
   
   Still awaiting test results for dm-crypt and dm-raid1.
   
   Signed-Off-By: Alasdair G Kergon <agk@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2053, 2005-02-03 17:00:10-08:00, agk@redhat.com
   [PATCH] device-mapper: stripe_width should be sector_t
   
   stripe_width should be sector_t to support large devices.
   
   Signed-Off-By: Alasdair G Kergon <agk@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2052, 2005-02-03 16:59:56-08:00, davej@redhat.com
   [PATCH] ppc32: unbreak perfctr build
   
   Signed-off-by: Dave Jones <davej@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2051, 2005-02-03 16:59:43-08:00, mst@mellanox.co.il
   [PATCH] InfiniBand: remove unbalance refcnt decrement
   
   Fix unbalanced QP reference count decrement (introduced with QP lock
   optimization patch)
   
   Signed-off-by: Michael S. Tsirkin <mst@mellanox.co.il>
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2050, 2005-02-03 16:59:28-08:00, libor@topspin.com
   [PATCH] InfiniBand: add missing break between cases
   
   Add a missing break statement between RC and UD cases in mthca_post_send().
    This fixes a possible oops for protocols that use the RC transport.
   
   Signed-off-by: Libor Michalek <libor@topspin.com>
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2049, 2005-02-03 16:59:15-08:00, akpm@osdl.org
   [PATCH] pnpacpi build fix
   
   - Fix it for older C compilers.
   
   - Extern decls always, always, always go in header files, please.
   
   Cc: "Brown, Len" <len.brown@intel.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2040.1.7, 2005-02-03 10:31:07-08:00, torvalds@ppc970.osdl.org
   Merge bk://kernel.bkbits.net/gregkh/linux/2.6.11-rc3/pci
   into ppc970.osdl.org:/home/torvalds/v2.6/linux
 
 ChangeSet@1.2040.3.9, 2005-02-03 10:18:57-08:00, torvalds@ppc970.osdl.org
   Make generic rw_verify_area check against file offset overflows.
   
   Not that low-level code really tends to care, but since loff_t is
   a signed 64-bit entity and size_t is unsigned (and potentially
   64-bit), mixing the two isn't very well-defined.. 
 
 ChangeSet@1.2040.3.8, 2005-02-03 09:37:45-08:00, torvalds@ppc970.osdl.org
   Make read/write always do the full "access_ok()" tests.
   
   The actual user copy will do them too, but only for the
   range that ends up being actually copied. That hides
   bugs when the range has been clamped by file size or other
   issues.
 
 ChangeSet@1.2040.3.6, 2005-02-03 08:44:37-08:00, viro@parcelfarce.linux.theplanet.co.uk
   [PATCH] via82cxxx: fix ppc32 multiplatform config test
   
   PPC_MULTIPLATFORM exists both for ppc32 and ppc64; chrp and pegasos,
   OTOH, are ppc32-only.  The ifdef in via82cxxx should be for
   PPC_MULTIPLATFORM and PPC32 - it makes no sense for ppc64 multiplatform
   and, as the matter of fact, simply won't compile there.
   
   Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2040.3.5, 2005-02-03 08:44:22-08:00, viro@parcelfarce.linux.theplanet.co.uk
   [PATCH] sparc64: fix compile with strict mm types
   
   compile fix on sparc64 - missed pgd_val() bites now that we have
   STRICT_MM_TYPECHECKS set.  Incidentally, shifting _by_ unsigned long is
   useless - type of result is determined by the type of first argument... 
   
   Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2040.3.4, 2005-02-03 08:18:37-08:00, axboe@suse.de
   [PATCH] md sync_page_io bio leak
   
   I accidentally introduced a leak in there, because the end_io function
   doesn't do a bio_put() like most others. Fortunately it's not critical,
   as it only happens on the md super block read. So just drop the initial
   bio_get(), since it's sync we can just bio_put() safely at the end after
   it has completed.
   
   Signed-off-by: Jens Axboe <axboe@suse.de>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2040.3.3, 2005-02-03 08:18:23-08:00, kraxel@bytesex.org
   [PATCH] DVB: No signal with bt848/tda9887
   
   Markus Trippelsdorf reported a non-working bt848 card with the recent
   DVB update. 
   
   It's an initialization order bug which changes the default state of the
   tda9887 output ports.
   
   Verified to fix the problem by Markus Trippelsdorf <markus@trippelsdorf.de>
   
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2040.3.2, 2005-02-03 08:18:09-08:00, oskar.senft@gmx.de
   [PATCH] Fix ISDN4Linux bug in isdnhdlc.c
   
   isdnhdlc_decode is called multiple times for bigger frames, so
   decrementing dsize is a bad idea and can cause a overflow of
   the dst buffer.
   
   Signed-off-by: Karsten Keil <kkeil@suse.de>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.1992.9.17, 2005-02-03 16:59:05+01:00, bzolnier@trik.(none)
   [ide] fix printk in ide_allocate_dma_engine()
   
   With Olaf Hering <olh@suse.de>.
   
   Parameters were interchanged.
   
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.16, 2005-02-03 16:52:26+01:00, prarit@sgi.com
   [ide] fix error handling in probe_hwif_init() and sgiioc4 driver
   
   From: Prarit Bhargava <prarit@sgi.com>
   
   I discovered an issue where a hwif_init() failure lead to /proc/ide files
   being created for devices that failed probes.  This resulted in
   oops/WARN_ON/BUG_ON executions through the kernel depending on what
   actions were on going.
   
   slightly changed by me (bart)
   
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.15, 2005-02-03 16:50:28+01:00, tj@home-tj.org
   [ide] add ide_hwgroup_t.polling
   
   ide_hwgroup_t.polling field added.  0 in poll_timeout field
   used to indicate inactive polling but because 0 is a valid
   jiffy value, though slim, there's a chance that something
   weird can happen.
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.14, 2005-02-03 16:48:42+01:00, tj@home-tj.org
   [ide] add ide_drive_t.sleeping
   
   ide_drive_t.sleeping field added.  0 in sleep field used to
   indicate inactive sleeping but because 0 is a valid jiffy
   value, though slim, there's a chance that something can go
   weird.  And while at it, explicit jiffy comparisons are
   converted to use time_before() macros.
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.13, 2005-02-03 16:47:16+01:00, tj@home-tj.org
   [ide] comment fixes
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.12, 2005-02-03 16:45:57+01:00, tj@home-tj.org
   [ide] remove NULL checking in ide_error()
   
   In ide_error(), drive cannot be NULL.  ide_dump_status() can't
   handle NULL drive.
   
   From: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.11, 2005-02-03 16:44:41+01:00, tj@home-tj.org
   [ide] ide-tape: use time_after() macro
   
   Explicit jiffy comparision converted to time_after() macro.
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.10, 2005-02-03 16:43:04+01:00, tj@home-tj.org
   [ide] __ide_do_rw_disk() return value fix
   
   In __ide_do_rw_disk(), ide_started used to be returned blindly
   after issusing PIO write.  This can cause hang if
   pre_task_out_intr() returns ide_stopped due to failed
   ide_wait_stat() test.  Fixed to pass the return value of
   pre_task_out_intr().
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.9, 2005-02-03 16:41:20+01:00, tj@home-tj.org
   [ide] __ide_do_rw_disk() lba48 dma check fix
   
   In __ide_do_rw_disk(), the shifted block, instead of the
   original rq->sector, should be used when checking range for
   lba48 dma.
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.8, 2005-02-03 16:39:36+01:00, tj@home-tj.org
   [ide] cleanup piix
   
   In drivers/ide/pci/piix.[hc], init_setup_piix() is defined and
   used but only one init_setup function is defined and no
   demultiplexing is done using init_setup callback.  As other
   drivers call ide_setup_pci_device() directly in such cases,
   this patch removes init_setup_piix() and makes piix_init_one()
   call ide_setup_pci_device() directly.
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.7, 2005-02-03 16:38:05+01:00, tj@home-tj.org
   [ide] cleanup opti621
   
   In drivers/ide/pci/opti612.[hc], init_setup_opti621() is
   declared, defined and referenced but never actually used.
   This patch removes the function.
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.6, 2005-02-03 16:36:41+01:00, bzolnier@trik.(none)
   [ide] fix it8172 build for real
   
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.5, 2005-02-03 16:35:12+01:00, tj@home-tj.org
   [ide] cleanup it8172
   
   In drivers/ide/pci/it8172.h, it8172_ratefilter() and
   init_setup_it8172() are declared and the latter is referenced
   in it8172_chipsets.  Both functions are not defined or used
   anywhere.  This patch removes the prototypes and reference.
   it8172 should be compilable now.
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.4, 2005-02-03 16:33:36+01:00, tj@home-tj.org
   [ide] remove adma100
   
   Removes drivers/ide/pci/adma100.[hc].  The driver isn't
   compilable (missing functions) and no Kconfig actually enables
   CONFIG_BLK_DEV_ADMA100.
   
   On Wed, 02 Feb 2005 03:31:59 -0500, Jeff Garzik <jgarzik@pobox.com> wrote:
   > Also, the libata-dev-2.6 tree has an "ata_adma" driver which is
   > complete, but needs some testing (and I have h/w).
   
   Signed-off-by: Tejun Heo <tj@home-tj.org>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.3, 2005-02-03 16:29:50+01:00, bunk@stusta.de
   [ide] possible cleanups
   
   This patch contains the following possible cleanups:
   - make some needlessly global code static
   - ide-dma.c: remove the unneeded EXPORT_SYMBOL(__ide_dma_test_irq)
   
   slightly changed by me (bart)
   
   Signed-off-by: Adrian Bunk <bunk@stusta.de>
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.1992.9.2, 2005-02-03 16:21:14+01:00, arjan@infradead.org
   [ide] unexport atapi_*_bytes() and ide_read_24()
   
   From: Arjan van de Ven <arjan@infradead.org>
   
   * make atapi_{input,output}_bytes() static, fix users to use drive->hwif
   * remove ide_read_24() export; it's unused since the ide-io.c reorganization
   * add a FIXME comment to the ide_fix_driveid() export
   
   slightly changed by me (bart)
   
   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
 
 ChangeSet@1.2040.2.12, 2005-02-03 01:42:08-08:00, hkneissel@gmx.de
   [PATCH] USB: garmin_gps tweak
   
   attached is a new patch for the garmin_gps driver. It only updates my email
   address in the header, as i am in the process of changing my isp and the
   listed address will be offline sometime soon.
   The second change makes the configuration entry look more like the
   other entries in the menu.
   
   
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.11, 2005-02-03 01:41:41-08:00, akpm@osdl.org
   [PATCH] USB: Logitech Cordeless Desktop Keyboard fails to report class descriptor
   
   From: Nico Huber <nico.h@gmx.de>
   
   The receiver of my Logitech Cordeless Desktop fails to report the
   keyboard's class descriptor most times I insert the usb-hid module since I
   changed to linux 2.6.  The modell of the receiver is C-BD9-DUAL REV C.  The
   request seems not to fail but the count of received characters is zero.
   
   As I said it only fails most times, I worked around making the following
   changes in drivers/usb/input/hid-core.c from linux-2.6.11-rc2:
   
   Following the good example of drivers/usb/core/message.c line 575, I
   initialized the buffer in hid_get_class_descriptor() to zero.  In the loop
   of hid_get_class_descriptor() not waiting for any result but waiting for a
   result wich is lower the requested size of the class descriptor (line
   1290).  usb_hid_configure() should not try to parse the expected length but
   the received (line 1653).
   
   Attached is a patch with these changes
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.10, 2005-02-03 01:41:15-08:00, rddunlap@osdl.org
   [PATCH] USB: hid-core: possible buffer overflow in hid-core.c
   
   Peter Bartosch wrote:
   > Hello all,
   >
   >
   > i think i found a possible buffer overflow in hid-core (2.6.10-rc2):
   
   Agreed, and sorry it took so long to reply/patch this.
   (from 2004-DEC-01)
   
   > when i interpret this code right, the buffer (buf) will overflow when
   > the iManufacturer stringlength is 0 and the iProduct stringlength
   > is > 64!
   
   Thanks, here's a patch for it.
   
   Fix potential buffer overflow (by a device descriptor):
   buf size is only 64 bytes.
   
   Signed-off-by: Randy Dunlap <rddunlap@osdl.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.9, 2005-02-03 01:40:48-08:00, krautz@gmail.com
   [PATCH] TIGLUSB Cleanups 3/3
   
   This removes the TIGLUSB-documentation, silverlink.txt.
   
   Signed-off-by: Mikkel Krautz <krautz@gmail.com>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.8, 2005-02-03 01:40:20-08:00, krautz@gmail.com
   [PATCH] TIGLUSB Cleanups 2/3
   
   This removes the TIGLUSB-maintainers from the MAINTAINERS-file.
   
   
   Signed-off-by: Mikkel Krautz <krautz@gmail.com>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.7, 2005-02-03 01:39:53-08:00, krautz@gmail.com
   [PATCH] TIGLUSB Cleanups 1/3
   
   This removes the tiusb boot-parameter from kernel-parameters.txt.
   
   
   Signed-off-by: Mikkel Krautz <krautz@gmail.com>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.6, 2005-02-03 01:39:27-08:00, stern@rowland.harvard.edu
   [PATCH] USB: unusual_devs.h update
   
   This patch updates the unusual_devs entry for the SCM multimedia card
   adapter.  Apparently earlier versions of the device included wrong
   descriptors but later versions did not.
   
   
   Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.5, 2005-02-03 01:39:00-08:00, oliver@neukum.org
   [PATCH] USB: fix for open/disconnect race in acm
   
   open takes the semaphore too late. This fixes it.
   
   Signed-off-by: Oliver Neukum <oliver@neukum.name>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.4, 2005-02-03 01:38:33-08:00, david-b@pacbell.net
   [PATCH] USB: another usbnet ax8817x device (goodway docking station)
   
   Add support for another AX8817x network device,
   found in a docking station.
   
   T:  Bus=01 Lev=02 Prnt=03 Port=00 Cnt=01 Dev#=  4 Spd=480 MxCh= 0
   D:  Ver= 2.00 Cls=02(comm.) Sub=00 Prot=00 MxPS=64 #Cfgs=  1
   P:  Vendor=1631 ProdID=6200 Rev= 0.01
   S:  Manufacturer=goodway corp usb
   S:  Product=gwusb2e
   S:  SerialNumber=01
   C:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=450mA
   I:  If#= 0 Alt= 0 #EPs= 3 Cls=00(>ifc ) Sub=00 Prot=00 Driver=(none)
   E:  Ad=81(I) Atr=03(Int.) MxPS=   8 Ivl=128ms
   E:  Ad=02(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
   E:  Ad=83(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
   
   Signed-off-by: Olaf Hering <olh@suse.de>
   Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.3, 2005-02-03 01:38:05-08:00, dwmw2@infradead.org
   [PATCH] USB: fix libusb endian issues
   
   On Wed, 2005-01-19 at 15:39 -0800, John Mock wrote:
   > New to 2.6.11-rc1 is that 'lsusb' exhibits 'endian' problems on the
   > PowerMac.
   
   Is that really new to 2.6.11-rc1? The kernel byte-swaps the bcdUSB,
   idVendor, idProduct, and bcdDevice fields in the device descriptor. It
   should probably swap them back before copying it up to userspace.
   
   From: David Woodhouse <dwmw2@infradead.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.2, 2005-02-03 01:37:39-08:00, stern@rowland.harvard.edu
   [PATCH] USB: Fix EHCI boot oops on AMD
   
   > > ----- Forwarded message from Andi Kleen <ak@suse.de> -----
   > > Someone added an test for AMD 8111 in EHCI, returning
   > > an error in reset.
   > >
   > > When triggered it would cause an NULL pointer oops because
   > > it would usb_hcd_put an half initialized hcd without
   > > initialized class.  I added a new usb_hcd_free function
   > > to handle such half baked objects.
   
   Andi's diagnosis is correct -- the embedded class_device was not fully
   initialized -- but the solution is wrong.  The correct patch
   is below.  This was clearly my fault, an error in driver-model
   programming brought on by lack of documentation about which fields in the
   driver-model structures need to be set for which API calls.  (Greg, long
   ago I sent you a documentation patch to try and help remedy this problem,
   but it seems to have fallen by the wayside.)
   
   
   Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.2.1, 2005-02-03 01:37:12-08:00, R.E.Wolff@harddisk-recovery.nl
   [PATCH] Re: Bug when using custom baud rates....
   
    When using custom baud rates, the code does:
   
   
           if ((new_serial.baud_base != priv->baud_base) ||
                (new_serial.baud_base < 9600))
                    return -EINVAL;
   
    Which translates to english as:
   
    	If you changed the baud-base, OR the new one is
    	invalid, return invalid.
   
    but it should be:
   
    	If you changed the baud-base, OR the new one is
    	invalid, return invalid.
   
   
   From: Rogier Wolff <R.E.Wolff@harddisk-recovery.nl>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.1.6, 2005-02-03 00:42:00-08:00, tlnguyen@snoqualmie.dp.intel.com
   [PATCH] PCI: change sysfs representation of PCI-E devices
   
   Before changes:
   
   The patch makes the parent of the device pointing to the pci_dev
   structure. The parents portX devices are in /sys/devices which
   should be removed based on your suggestions. Below is /sys/devices
   before any changes made.
   
   /sys/devices
   	|
   	__ ide0
   	|
   	__ pci0000:00
   	|
   	__ pnp0
   	|
   	__ port1
   	|	|
   	|  	__ port1.00
   	|	|
   	|	__ port1.01
   	|	.
   	|	.
   	|	.
   	|
   	__ port2
   	|
    	__ port3
   	|
   	__ system
   
   After changes:
   
   The parents portX devices are no longer necessary because port1.00
   and port1.01 devices shoud have the parent of the pci_dev structure
   (based on your suggestion). The patch does the following changes:
   
   - remove code creating and handling the parent portX devices.
   - rename portX.YZ to pcieYZ (for example port1.00 renamed to pcie00)
     since portX is no longer needed.
   - make pcieYZ have the parent of the pci_dev structure.
   
   Below is /sys/devices after changes made to the patch.
   
   /sys/devices
   	|
   	__ ide0
   	|
   	__ pci0000:00
   	|	|
   	|	__ 0000:00:00.0
   	|	|
   	|	__ 0000:00:04.0
   	|	|	|
   	|	.	__ class
   	|	.	|
   	|	.	__ pcie00
   	|		|
   	|		__ pcie01
   	|		.
   	|		.
   	|		.
   	|
   	__ platform
   	|
   	__ pnp0
   	|
   	__ system
   
   
   Signed-off-by: T. Long Nguyen <tom.l.nguyen@intel.com>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.1.5, 2005-02-03 00:41:32-08:00, greg@kroah.com
   [PATCH] PCI: add linux-pci mailing list to PCI maintainers entry.
   
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.1.4, 2005-02-03 00:41:04-08:00, johnrose@austin.ibm.com
   [PATCH] PCI Hotplug: remove incorrect rpaphp firmware dependency
   
   The RPA PCI Hotplug module incorrectly uses a certain firmware property when
   determining the hotplug capabilities of a slot.  Recent firmware changes have
   demonstrated that this property should not be referenced or depended upon by
   the OS.  This patch removes the dependency, and implements a correct set of
   logic for determining hotplug capabilities.
   
   Signed-off-by: John Rose <johnrose@austin.ibm.com>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
   
   diff -puN drivers/pci/hotplug/rpadlpar_core.c~02_rpadebug drivers/pci/hotplug/rpadlpar_core.c
 
 ChangeSet@1.2040.1.3, 2005-02-03 00:40:37-08:00, kay.sievers@vrfy.org
   [PATCH] PCI: memset rom attribute before using it
   
   Initialize the allocated bin_attribute structure, otherwise unused fields
   are pointing to random places.
   
   Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.1.2, 2005-02-03 00:40:09-08:00, brking@us.ibm.com
   [PATCH] pci: Add Citrine quirk
   
   The IBM Citrine chipset has a feature that if PCI config register
   0xA0 is read while DMAs are being performed to it, there is the possiblity
   that the parity will be wrong on the PCI bus, causing a parity error and
   a master abort. On this chipset, this register is simply a debug register
   for the chip developers and the registers after it are not defined.
   Patch sets cfg_size to 0xA0 to prevent this problem from being seen.
   
   Signed-off-by: Brian King <brking@us.ibm.com>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040.1.1, 2005-02-03 00:39:41-08:00, akpm@osdl.org
   [PATCH] PCI: typo in pci_scan_bus_parented
   
   From: Olaf Hering <olh@suse.de>
   
   printk format string misses a x
   
   Signed-off-by: Olaf Hering <olh@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2047, 2005-02-03 00:31:16-08:00, khali@linux-fr.org
   [PATCH] I2C: Prevent buffer overflow on SMBus block read in
   
   Hi Greg, Linus, all,
   
   I just hit a buffer overflow while playing around with i2cdump and
   i2c-viapro through i2c-dev. This is caused by a missing length check on
   a buffer operation when doing a SMBus block read in the i2c-viapro
   driver. The problem was already known and had been fixed upon report by
   Sergey Vlasov back in August 2003 in lm_sensors (2.4 kernel version of
   the driver) but for some reason it was never ported to the 2.6 kernel
   version.
   
   I am not a security expert but I would guess that such a buffer overflow
   could possibly be used to run arbitrary code in kernel space from user
   space through i2c-dev. The severity obviously depends on the permisions
   set on the i2c device files in /dev. Maybe it wouldn't be a bad idea to
   push this patch upstream rather sooner than later.
   
   While I was at it, I also changed a similar size check (for SMBus block
   write this time) in the same driver to use the correct constant
   I2C_SMBUS_BLOCK_MAX instead of its current numerical value. This doesn't
   change a thing at the moment but prevents another potential buffer
   overflow in case the value of I2C_SMBUS_BLOCK_MAX were to be changed in
   the future (admittedly unlikely though).
   
   > Now if we have broken hardware, then we might have a problem here, but
   > otherwise I don't see it as a security issue right now.
   
   It doesn't take broken hardware.
   
   (Warning: I am going technical at this point, people not interested in
   the gory details of the I2C and SMBus protocols should better stop here
   ;))
   
   It just depends on what part of the SMBus and I2C specifications a given
   client chip supports. SMBus block reads are no different from SMBus byte
   reads, except that the master (here the VIA Pro) goes on reading after
   the first byte sent by the slave (which could be about anything, from
   hardware monitoring chip to EEPROM). In that respect, it also doesn't
   much differ from the I2C block read, which also starts in the exact same
   way. The difference between SMBus block read and I2C block read is that
   the first byte returned by the slave on SMBus block read is supposed to
   be the remaining number of data byte to be sent, while this is simply
   the first data byte for I2C block reads.
   
   To make it clearer, here comes the detail of the byte read, SMBus block
   read and I2C block read commands (-> means from master to slave, <-
   means from slave to master). See the official specifications for I2C and
   SMBus for nicer graphics and additional details.
   
   Byte read:
   -> client address, write mode
   -> register address
   -> client address, read mode
   <- data byte
   
   SMBus block read:
   -> client address, write mode
   -> register address
   -> client address, read mode
   <- length byte (1 <=3D N <=3D 32)
   <- first byte
   <- next byte
   <- ...
   <- last (Nth) byte
   
   I2C block read:
   -> client address, write mode
   -> register address
   -> client address, read mode
   <- first byte
   <- next byte
   <- ...
   <- last byte
   
   In each case, the *master* decides when to stop the transfer, not the
   slave.
   
   There are two consequences for us here:
   
   1* The client chip cannot differenciate between byte read and SMBus block
   read until after it sent a first byte - which basically means that a
   given register address is specified to be read with either command, not
   both, and not using the correct one returns bogus results. i2c-dev
   allows arbitrary commands so it is possible to ask for a SMBus block
   read on a register that expects a simple byte read. The client
   innocently will answer with the register value - which the master will
   interpret as a length, and the master will then request that many
   additional data bytes. If the client features autoincrement in this
   register address range, it will most likely provide the value of the
   next registers, if not it will dumbly return the same register value
   again and again.
   
   This illustrates the fact that it doesn't take a broken chip to cause a
   buffer overflow. It only takes a SMBus block read command on a register
   for which the client did not expect it (and almost no client actually
   supports SMBus block reads at the moment). If it happens that the
   register value was greater than 32, the buffer overflow will occur
   (without Sergey's fix, that is). So, with write access to the i2c
   device files, it is actually very easy to trigger the buffer overflow,
   providing there is at least one chip on the VIA Pro SMBus.
   
   2* A client chip can obviously only implement SMBus block read or I2C
   block read for a given register address, since the sequence sent by the
   master is exactly the same. Not a big deal since a client chip is
   designed either as an I2C slave or as a SMBus slave. However the master
   doesn't know this, and i2c-dev allows arbitrary commands, so it is
   possible to use an SMBus block read on an I2C slave which expected
   instead an I2C block read, causing weird results.
   
   EEPROMs are such I2C slaves and they support I2C block reads. Now,
   imagine that a non-write-protected EEPROM hangs on my VIA Pro SMBus (a
   memory module SPD EEPROM would probably do), and for some reason i2c-dev
   gives me access to it. I can write arbitrary bytes to the EEPROM using
   simple byte writes. I could write the following bytes, in order, at some
   location: 0x80, 34 null bytes, 94 bytes of nasty code. Then, still
   through i2c-dev, I request a SMBus block read from the same location.
   The EEPROM will answer as if it were an I2C block read (it can't
   differenciate and doesn't support SMBus block reads anyway), i.e. it
   will return as many bytes as requested, in order. The VIA Pro master
   will however interpret the first byte (0x80) as a length, and will read
   128 bytes from the EEPROM, 34 of which will fill the data buffer, and 94
   will overflow. Providing I know how the kernel works, these 94 bytes
   could be used for doing presumably bad things.
   
   This illustrates the fact that the user may actually control the buffer
   overflow, indirectly, depending on what hardware is present on the bus.
   EEPROMs are the most obvious way to do it, but some hardware monitoring
   chips have RAM arrays that could presumably be used in a similar way.
   
   As a conclusion, I definitely agree that this buffer overflow isn't easy
   to exploit, as it takes a particular combination of hardware and
   non-standard permissions on i2c device files, and also requires very
   good knowledge of the I2C and SMBus protocols; it is not impossible
   though.
   
   
   Signed-off-by: Jean Delvare <khali@linux-fr.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2046, 2005-02-03 00:30:49-08:00, khali@linux-fr.org
   [PATCH] I2C: Do not show disabled pc87360 fans
   
   The pc87360 driver create sysfs files even for disabled fans. Since data
   won't ever be updated, it doesn't make much sense. The following patch
   adds some tests to only create the interface files that are actually
   needed.
   
   Signed-off-by: Jean Delvare <khali@linux-fr.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2045, 2005-02-03 00:30:21-08:00, khali@linux-fr.org
   [PATCH] I2C: Fix i2c-sis5595 pci configuration accesses
   
   The i2c-sis5595 bus driver has logic errors on pci configuration
   accesses. It returns an error on success and vice versa. The 2.4 kernel
   version of the driver, as found in the lm_sensors CVS repository, is
   correct, so the problem was introducted when the driver was ported to
   the 2.6 kernel tree  (in 2.6.0-test6). As odd as it sounds, the driver
   has been sitting here broken and unusable for 17 months and nobody ever
   reported, until yesterday.
   
   Credits go to Sebastian Hesselbarth for discovering and analyzing the
   problem.
   
   Here is a patch that fixes the problem, succesfully tested by Aurelien
   Jarno and Sebastian Hesselbarth. Please apply.
   
   Signed-off-by: Jean Delvare <khali@linux-fr.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2044, 2005-02-03 00:29:54-08:00, khali@linux-fr.org
   [PATCH] I2C: Reduce it87 i2c address range
   
   IT87xxF chips were never seen at any other I2C address than the default
   (0x2d) so I think that we could safely reduce the range of addresses the
   it87 drivers accepts. Currently it accepts 0x20-0x2f, I believe that
   0x28-0x2f would already be more than sufficient.
   
   (In theory, any address is possible, so whatever range we choose is
   arbitrary anyway.)
   
   Signed-off-by: Jean Delvare <khali@linux-fr.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2043, 2005-02-03 00:29:27-08:00, khali@linux-fr.org
   [PATCH] I2C: Use standard temperature converters for as99127f
   
   When support for the Asus AS99127F chip was once added to the w83781d
   driver, it was decided that we would treat temp2 and temp3 as having a
   LSB of 0.25 degree C, as opposed to 0.5 degree C for the compatible
   Winbond chips. The reason why this was done seems to be a couple of
   users reporting that these temperatures were reading twice as high as it
   should for them in the first place. We had much more feedback about the
   A99127F chip since, and it turns out that the exact conversion required
   for temp2 and temp3 depends on the motherboard model. For some models
   (including my A7V133-C), we now have to multiply the readings by 2,
   effectively negating the change that was once done in the driver. For
   other models, a linear conversion formula is needed. The bottom line is
   that the raw readings from the driver are correct for no known board,
   while it would be for at least some of them if we had kept the same LSB
   as the Winbond chips are known to have. Thus I believe that the standard
   LSB of 0.5 degree C should be restored.
   
   There is no datasheet available for the AS99127F chip, so whatever was
   done was guess work (and still is). I see no reason why we would keep
   additional code in the w83781d driver to handle this former supposed
   difference, especially when the facts now tend to prove that this
   difference doesn't exist.
   
   The following patch drops the additional code and treats temp2 and temp3
   the same way for all chips supported by the w83781d driver. A similar
   change will be made to the 2.4 version of this driver, and the default
   sensors.conf will be updated accordingly. Users will have to update
   their configuration file, or their readings will of course read twice as
   high as they should due to the old conversion formulae.
   
   
   Signed-off-by: Jean Delvare <khali@linux-fr.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2042, 2005-02-03 00:29:01-08:00, khali@linux-fr.org
   [PATCH] I2C: Resolve resource conflict between i2c-viapro and via686a
   
   Here comes the finalized version of our patch solving the PCI device
   resource conflict between the i2c-viapro bus driver and and the via686a
   chip driver. It is based on your original work and the IRC conversation
   we had yesterday.
   
   The retained solution is to not permanently register the PCI device in
   either driver. This is legitimate since we only need it at init time to
   retrieve the ISA address of a sub-device (SMBus master or integrated
   sensors), and possibly change that address on user request. Once this is
   done we can safely release the PCI device for others to use.
   
   I am really glad to see this problem finally solved, as this was the
   last remaining annoying issue left from the Linux 2.6 migration (missing
   drivers left apart), and was generating many complaints both at our
   level and at the distributions' support.
   
   
   Signed-off-by: Jean Delvare <khali@linux-fr.org>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2041, 2005-02-03 00:28:34-08:00, aurelien@aurel32.net
   [PATCH] I2C: Fix DS1621 detection
   
   Dallas Semiconductors as recently changed the design of their DS1621
   chips, including the bits that were checked in the kernel driver to
   detect it.
   
   The patch below fixes the detection by checking an other bit of the
   configuration register instead.
   
   Signed-off-by: Aurelien Jarno <aurelien@aurel32.net>
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
 
 ChangeSet@1.2040, 2005-02-02 17:50:58-08:00, torvalds@ppc970.osdl.org
   Linux 2.6.11-rc3
   TAG: v2.6.11-rc3
 
diff -Nru a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
--- a/Documentation/kernel-parameters.txt	2005-02-02 16:21:28 -08:00
+++ b/Documentation/kernel-parameters.txt	2005-02-02 22:19:14 -08:00
@@ -1363,9 +1363,6 @@
 	tipar.delay=	[HW,PPT]
 			Set inter-bit delay in microseconds (default 10).
 
-	tiusb=		[HW,USB] Texas Instruments' USB GraphLink (aka SilverLink)
-			Format: <timeout>
- 
 	tmc8xx=		[HW,SCSI]
 			See header of drivers/scsi/seagate.c.
 
diff -Nru a/Documentation/usb/silverlink.txt b/Documentation/usb/silverlink.txt
--- a/Documentation/usb/silverlink.txt	2004-09-26 06:16:15 -07:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,78 +0,0 @@
--------------------------------------------------------------------------
-Readme for Linux device driver for the Texas Instruments SilverLink cable
-and direct USB cable provided by some TI's handhelds.
--------------------------------------------------------------------------
-
-Author: Romain Liévin & Julien Blache
-Homepage: http://lpg.ticalc.org/prj_usb
-
-INTRODUCTION:
-
-This is a driver for the TI-GRAPH LINK USB (aka SilverLink) cable, a cable 
-designed by TI for connecting their TI8x/9x calculators to a computer 
-(PC or Mac usually). It has been extended to support the USB port offered by
-some latest TI handhelds (TI84+ and TI89 Titanium).
-
-If you need more information, please visit the 'SilverLink drivers' homepage 
-at the above URL.
-
-WHAT YOU NEED:
-
-A TI calculator of course and a program capable to communicate with your 
-calculator.
-TiLP will work for sure (since I am his developer !). yal92 may be able to use
-it by changing tidev for tiglusb (may require some hacking...).
-
-HOW TO USE IT:
-
-You must have first compiled USB support, support for your specific USB host
-controller (UHCI or OHCI).
-
-Next, (as root) from your appropriate modules directory (lib/modules/2.5.XX):
-
-       insmod usb/usbcore.o
-       insmod usb/usb-uhci.o  <OR>  insmod usb/ohci-hcd.o
-       insmod tiglusb.o
-
-If it is not already there (it usually is), create the device:
-
-       mknod /dev/tiglusb0 c 115 16
-
-You will have to set permissions on this device to allow you to read/write
-from it:
-
-       chmod 666 /dev/tiglusb0
-       
-Now you are ready to run a linking program such as TiLP. Be sure to configure 
-it properly (RTFM).
-       
-MODULE PARAMETERS:
-
-  You can set these with:  insmod tiglusb NAME=VALUE
-  There is currently no way to set these on a per-cable basis.
-
-  NAME: timeout
-  TYPE: integer
-  DEFAULT: 15
-  DESC: Timeout value in tenth of seconds. If no data is available once this 
-       time has expired then the driver will return with a timeout error.
-
-QUIRKS:
-
-The following problem seems to be specific to the link cable since it appears 
-on all platforms (Linux, Windows, Mac OS-X). 
-
-In some very particular cases, the driver returns with success but
-without any data. The application should retry a read operation at least once.
-
-HOW TO CONTACT US:
-
-You can email me at roms@lpg.ticalc.org. Please prefix the subject line
-with "TIGLUSB: " so that I am certain to notice your message.
-You can also mail JB at jb@jblache.org: he has written the first release of 
-this driver but he better knows the Mac OS-X driver.
-
-CREDITS:
-
-The code is based on dabusb.c, printer.c and scanner.c !
-The driver has been developed independently of Texas Instruments Inc.
diff -Nru a/MAINTAINERS b/MAINTAINERS
--- a/MAINTAINERS	2005-02-01 08:48:42 -08:00
+++ b/MAINTAINERS	2005-02-03 10:31:03 -08:00
@@ -1746,6 +1746,7 @@
 P:	Greg Kroah-Hartman
 M:	greg@kroah.com
 L:	linux-kernel@vger.kernel.org
+L:	linux-pci@atrey.karlin.mff.cuni.cz
 S:	Supported
 
 PCI HOTPLUG CORE
@@ -2182,13 +2183,6 @@
 SYSV FILESYSTEM
 P:	Christoph Hellwig
 M:	hch@infradead.org
-S:	Maintained
-
-TI GRAPH LINK USB (SilverLink) CABLE DRIVER
-P:	Romain Lievin
-M:	roms@lpg.ticalc.org
-P:	Julien Blache
-M:	jb@technologeek.org
 S:	Maintained
 
 TI PARALLEL LINK CABLE DRIVER
diff -Nru a/Makefile b/Makefile
--- a/Makefile	2005-02-02 17:50:51 -08:00
+++ b/Makefile	2005-02-04 05:43:17 -08:00
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION =-rc3
+EXTRAVERSION = -rc3-bk1
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -Nru a/arch/ia64/Kconfig b/arch/ia64/Kconfig
--- a/arch/ia64/Kconfig	2005-01-18 12:06:17 -08:00
+++ b/arch/ia64/Kconfig	2005-01-28 15:32:25 -08:00
@@ -158,14 +158,6 @@
 	depends on ITANIUM
 	default y
 
-config ITANIUM_BSTEP_SPECIFIC
-	bool "Itanium B-step specific code"
-	depends on ITANIUM
-	help
-	  Select this option to build a kernel for an Itanium prototype system
-	  with a B-step CPU.  You have a B-step CPU if the "revision" field in
-	  /proc/cpuinfo has a value in the range from 1 to 4.
-
 # align cache-sensitive data to 128 bytes
 config IA64_L1_CACHE_SHIFT
 	int
diff -Nru a/arch/ia64/Makefile b/arch/ia64/Makefile
--- a/arch/ia64/Makefile	2005-01-07 16:15:52 -08:00
+++ b/arch/ia64/Makefile	2005-01-28 15:32:45 -08:00
@@ -46,8 +46,6 @@
 	cflags-$(CONFIG_MCKINLEY)	+= -mtune=mckinley
 endif
 
-cflags-$(CONFIG_ITANIUM_BSTEP_SPECIFIC)	+= -mb-step
-
 CFLAGS += $(cflags-y)
 head-y := arch/ia64/kernel/head.o arch/ia64/kernel/init_task.o
 
diff -Nru a/arch/ia64/configs/bigsur_defconfig b/arch/ia64/configs/bigsur_defconfig
--- a/arch/ia64/configs/bigsur_defconfig	2004-11-30 08:48:16 -08:00
+++ b/arch/ia64/configs/bigsur_defconfig	2005-01-28 15:32:47 -08:00
@@ -73,7 +73,6 @@
 CONFIG_IA64_PAGE_SIZE_16KB=y
 # CONFIG_IA64_PAGE_SIZE_64KB is not set
 CONFIG_IA64_BRL_EMU=y
-# CONFIG_ITANIUM_BSTEP_SPECIFIC is not set
 CONFIG_IA64_L1_CACHE_SHIFT=6
 # CONFIG_NUMA is not set
 # CONFIG_VIRTUAL_MEM_MAP is not set
diff -Nru a/arch/ia64/ia32/ia32_signal.c b/arch/ia64/ia32/ia32_signal.c
--- a/arch/ia64/ia32/ia32_signal.c	2005-01-04 18:48:19 -08:00
+++ b/arch/ia64/ia32/ia32_signal.c	2005-01-25 12:23:45 -08:00
@@ -1,7 +1,7 @@
 /*
  * IA32 Architecture-specific signal handling support.
  *
- * Copyright (C) 1999, 2001-2002 Hewlett-Packard Co
+ * Copyright (C) 1999, 2001-2002, 2005 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  * Copyright (C) 1999 Arun Sharma <arun.sharma@intel.com>
  * Copyright (C) 2000 VA Linux Co
@@ -970,11 +970,10 @@
 }
 
 asmlinkage long
-sys32_sigreturn (int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7,
-		 unsigned long stack)
+sys32_sigreturn (int arg0, int arg1, int arg2, int arg3, int arg4, int arg5,
+		 int arg6, int arg7, struct pt_regs regs)
 {
-	struct pt_regs *regs = (struct pt_regs *) &stack;
-	unsigned long esp = (unsigned int) regs->r12;
+	unsigned long esp = (unsigned int) regs.r12;
 	struct sigframe_ia32 __user *frame = (struct sigframe_ia32 __user *)(esp - 8);
 	sigset_t set;
 	int eax;
@@ -993,7 +992,7 @@
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
 
-	if (restore_sigcontext_ia32(regs, &frame->sc, &eax))
+	if (restore_sigcontext_ia32(&regs, &frame->sc, &eax))
 		goto badframe;
 	return eax;
 
@@ -1003,11 +1002,10 @@
 }
 
 asmlinkage long
-sys32_rt_sigreturn (int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7,
-		    unsigned long stack)
+sys32_rt_sigreturn (int arg0, int arg1, int arg2, int arg3, int arg4,
+		    int arg5, int arg6, int arg7, struct pt_regs regs)
 {
-	struct pt_regs *regs = (struct pt_regs *) &stack;
-	unsigned long esp = (unsigned int) regs->r12;
+	unsigned long esp = (unsigned int) regs.r12;
 	struct rt_sigframe_ia32 __user *frame = (struct rt_sigframe_ia32 __user *)(esp - 4);
 	sigset_t set;
 	int eax;
@@ -1023,7 +1021,7 @@
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
 
-	if (restore_sigcontext_ia32(regs, &frame->uc.uc_mcontext, &eax))
+	if (restore_sigcontext_ia32(&regs, &frame->uc.uc_mcontext, &eax))
 		goto badframe;
 
 	/* It is more difficult to avoid calling this function than to
diff -Nru a/arch/ia64/ia32/sys_ia32.c b/arch/ia64/ia32/sys_ia32.c
--- a/arch/ia64/ia32/sys_ia32.c	2005-01-25 13:50:22 -08:00
+++ b/arch/ia64/ia32/sys_ia32.c	2005-01-31 14:15:33 -08:00
@@ -6,7 +6,7 @@
  * Copyright (C) 1999		Arun Sharma <arun.sharma@intel.com>
  * Copyright (C) 1997,1998	Jakub Jelinek (jj@sunsite.mff.cuni.cz)
  * Copyright (C) 1997		David S. Miller (davem@caip.rutgers.edu)
- * Copyright (C) 2000-2003 Hewlett-Packard Co
+ * Copyright (C) 2000-2003, 2005 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  * Copyright (C) 2004		Gordon Jin <gordon.jin@intel.com>
  *
@@ -1436,7 +1436,7 @@
 }
 
 static unsigned int
-ia32_peek (struct pt_regs *regs, struct task_struct *child, unsigned long addr, unsigned int *val)
+ia32_peek (struct task_struct *child, unsigned long addr, unsigned int *val)
 {
 	size_t copied;
 	unsigned int ret;
@@ -1446,7 +1446,7 @@
 }
 
 static unsigned int
-ia32_poke (struct pt_regs *regs, struct task_struct *child, unsigned long addr, unsigned int val)
+ia32_poke (struct task_struct *child, unsigned long addr, unsigned int val)
 {
 
 	if (access_process_vm(child, addr, &val, sizeof(val), 1) != sizeof(val))
@@ -1751,25 +1751,16 @@
 	return 0;
 }
 
-/*
- *  Note that the IA32 version of `ptrace' calls the IA64 routine for
- *    many of the requests.  This will only work for requests that do
- *    not need access to the calling processes `pt_regs' which is located
- *    at the address of `stack'.  Once we call the IA64 `sys_ptrace' then
- *    the address of `stack' will not be the address of the `pt_regs'.
- */
 asmlinkage long
-sys32_ptrace (int request, pid_t pid, unsigned int addr, unsigned int data,
-	      long arg4, long arg5, long arg6, long arg7, long stack)
+sys32_ptrace (int request, pid_t pid, unsigned int addr, unsigned int data)
 {
-	struct pt_regs *regs = (struct pt_regs *) &stack;
 	struct task_struct *child;
 	unsigned int value, tmp;
 	long i, ret;
 
 	lock_kernel();
 	if (request == PTRACE_TRACEME) {
-		ret = sys_ptrace(request, pid, addr, data, arg4, arg5, arg6, arg7, stack);
+		ret = sys_ptrace(request, pid, addr, data);
 		goto out;
 	}
 
@@ -1786,7 +1777,7 @@
 		goto out_tsk;
 
 	if (request == PTRACE_ATTACH) {
-		ret = sys_ptrace(request, pid, addr, data, arg4, arg5, arg6, arg7, stack);
+		ret = sys_ptrace(request, pid, addr, data);
 		goto out_tsk;
 	}
 
@@ -1797,7 +1788,7 @@
 	switch (request) {
 	      case PTRACE_PEEKTEXT:
 	      case PTRACE_PEEKDATA:	/* read word at location addr */
-		ret = ia32_peek(regs, child, addr, &value);
+		ret = ia32_peek(child, addr, &value);
 		if (ret == 0)
 			ret = put_user(value, (unsigned int __user *) compat_ptr(data));
 		else
@@ -1806,7 +1797,7 @@
 
 	      case PTRACE_POKETEXT:
 	      case PTRACE_POKEDATA:	/* write the word at location addr */
-		ret = ia32_poke(regs, child, addr, data);
+		ret = ia32_poke(child, addr, data);
 		goto out_tsk;
 
 	      case PTRACE_PEEKUSR:	/* read word at addr in USER area */
@@ -1882,7 +1873,7 @@
 	      case PTRACE_KILL:
 	      case PTRACE_SINGLESTEP:	/* execute chile for one instruction */
 	      case PTRACE_DETACH:	/* detach a process */
-		ret = sys_ptrace(request, pid, addr, data, arg4, arg5, arg6, arg7, stack);
+		ret = sys_ptrace(request, pid, addr, data);
 		break;
 
 	      default:
@@ -1905,9 +1896,9 @@
 
 asmlinkage long
 sys32_sigaltstack (ia32_stack_t __user *uss32, ia32_stack_t __user *uoss32,
-		   long arg2, long arg3, long arg4, long arg5, long arg6, long arg7, long stack)
+		   long arg2, long arg3, long arg4, long arg5, long arg6,
+		   long arg7, struct pt_regs pt)
 {
-	struct pt_regs *pt = (struct pt_regs *) &stack;
 	stack_t uss, uoss;
 	ia32_stack_t buf32;
 	int ret;
@@ -1928,7 +1919,7 @@
 	}
 	set_fs(KERNEL_DS);
 	ret = do_sigaltstack(uss32 ? (stack_t __user *) &uss : NULL,
-			     (stack_t __user *) &uoss, pt->r12);
+			     (stack_t __user *) &uoss, pt.r12);
  	current->sas_ss_size = buf32.ss_size;
 	set_fs(old_fs);
 out:
diff -Nru a/arch/ia64/kernel/asm-offsets.c b/arch/ia64/kernel/asm-offsets.c
--- a/arch/ia64/kernel/asm-offsets.c	2005-01-06 16:19:39 -08:00
+++ b/arch/ia64/kernel/asm-offsets.c	2005-01-26 09:59:15 -08:00
@@ -193,9 +193,17 @@
 	DEFINE(IA64_CLONE_VM, CLONE_VM);
 
 	BLANK();
-	DEFINE(IA64_CPUINFO_NSEC_PER_CYC_OFFSET, offsetof (struct cpuinfo_ia64, nsec_per_cyc));
-	DEFINE(IA64_TIMESPEC_TV_NSEC_OFFSET, offsetof (struct timespec, tv_nsec));
-
+	DEFINE(IA64_CPUINFO_NSEC_PER_CYC_OFFSET,
+	       offsetof (struct cpuinfo_ia64, nsec_per_cyc));
+	DEFINE(IA64_CPUINFO_PTCE_BASE_OFFSET,
+	       offsetof (struct cpuinfo_ia64, ptce_base));
+	DEFINE(IA64_CPUINFO_PTCE_COUNT_OFFSET,
+	       offsetof (struct cpuinfo_ia64, ptce_count));
+	DEFINE(IA64_CPUINFO_PTCE_STRIDE_OFFSET,
+	       offsetof (struct cpuinfo_ia64, ptce_stride));
+	BLANK();
+	DEFINE(IA64_TIMESPEC_TV_NSEC_OFFSET,
+	       offsetof (struct timespec, tv_nsec));
 
 	DEFINE(CLONE_SETTLS_BIT, 19);
 #if CLONE_SETTLS != (1<<19)
@@ -203,19 +211,16 @@
 #endif
 
 	BLANK();
-	/* used by arch/ia64/kernel/mca_asm.S */
-	DEFINE(IA64_CPUINFO_PERCPU_PADDR, offsetof (struct cpuinfo_ia64, percpu_paddr));
-	DEFINE(IA64_CPUINFO_PAL_PADDR, offsetof (struct cpuinfo_ia64, pal_paddr));
-	DEFINE(IA64_CPUINFO_PA_MCA_INFO, offsetof (struct cpuinfo_ia64, ia64_pa_mca_data));
-	DEFINE(IA64_MCA_PROC_STATE_DUMP, offsetof (struct ia64_mca_cpu_s, ia64_mca_proc_state_dump));
-	DEFINE(IA64_MCA_STACK, offsetof (struct ia64_mca_cpu_s, ia64_mca_stack));
-	DEFINE(IA64_MCA_STACKFRAME, offsetof (struct ia64_mca_cpu_s, ia64_mca_stackframe));
-	DEFINE(IA64_MCA_BSPSTORE, offsetof (struct ia64_mca_cpu_s, ia64_mca_bspstore));
-	DEFINE(IA64_INIT_STACK, offsetof (struct ia64_mca_cpu_s, ia64_init_stack));
-
-	/* used by head.S */
-	DEFINE(IA64_CPUINFO_NSEC_PER_CYC_OFFSET, offsetof (struct cpuinfo_ia64, nsec_per_cyc));
-
+	DEFINE(IA64_MCA_CPU_PROC_STATE_DUMP_OFFSET,
+	       offsetof (struct ia64_mca_cpu, proc_state_dump));
+	DEFINE(IA64_MCA_CPU_STACK_OFFSET,
+	       offsetof (struct ia64_mca_cpu, stack));
+	DEFINE(IA64_MCA_CPU_STACKFRAME_OFFSET,
+	       offsetof (struct ia64_mca_cpu, stackframe));
+	DEFINE(IA64_MCA_CPU_RBSTORE_OFFSET,
+	       offsetof (struct ia64_mca_cpu, rbstore));
+	DEFINE(IA64_MCA_CPU_INIT_STACK_OFFSET,
+	       offsetof (struct ia64_mca_cpu, init_stack));
 	BLANK();
 	/* used by fsys_gettimeofday in arch/ia64/kernel/fsys.S */
 	DEFINE(IA64_TIME_INTERPOLATOR_ADDRESS_OFFSET, offsetof (struct time_interpolator, addr));
diff -Nru a/arch/ia64/kernel/efi.c b/arch/ia64/kernel/efi.c
--- a/arch/ia64/kernel/efi.c	2005-01-22 15:59:24 -08:00
+++ b/arch/ia64/kernel/efi.c	2005-01-26 10:01:27 -08:00
@@ -415,8 +415,8 @@
  * Abstraction Layer chapter 11 in ADAG
  */
 
-static efi_memory_desc_t *
-pal_code_memdesc (void)
+void *
+efi_get_pal_addr (void)
 {
 	void *efi_map_start, *efi_map_end, *p;
 	efi_memory_desc_t *md;
@@ -474,51 +474,31 @@
 			md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT),
 			vaddr & mask, (vaddr & mask) + IA64_GRANULE_SIZE);
 #endif
-		return md;
+		return __va(md->phys_addr);
 	}
-
+	printk(KERN_WARNING "%s: no PAL-code memory-descriptor found",
+	       __FUNCTION__);
 	return NULL;
 }
 
 void
-efi_get_pal_addr (void)
-{
-	efi_memory_desc_t *md = pal_code_memdesc();
-	u64 vaddr, mask;
-	struct cpuinfo_ia64 *cpuinfo;
-
-	if (md != NULL) {
-
-		vaddr = PAGE_OFFSET + md->phys_addr;
-		mask  = ~((1 << IA64_GRANULE_SHIFT) - 1);
-
-		cpuinfo = (struct cpuinfo_ia64 *)__va(ia64_get_kr(IA64_KR_PA_CPU_INFO));
-		cpuinfo->pal_base = vaddr & mask;
-		cpuinfo->pal_paddr = pte_val(mk_pte_phys(md->phys_addr, PAGE_KERNEL));
-	}
-}
-
-void
 efi_map_pal_code (void)
 {
-	efi_memory_desc_t *md = pal_code_memdesc();
-	u64 vaddr, mask, psr;
-
-	if (md != NULL) {
+	void *pal_vaddr = efi_get_pal_addr ();
+	u64 psr;
 
-		vaddr = PAGE_OFFSET + md->phys_addr;
-		mask  = ~((1 << IA64_GRANULE_SHIFT) - 1);
+	if (!pal_vaddr)
+		return;
 
-		/*
-		 * Cannot write to CRx with PSR.ic=1
-		 */
-		psr = ia64_clear_ic();
-		ia64_itr(0x1, IA64_TR_PALCODE, vaddr & mask,
-			pte_val(pfn_pte(md->phys_addr >> PAGE_SHIFT, PAGE_KERNEL)),
-			IA64_GRANULE_SHIFT);
-		ia64_set_psr(psr);		/* restore psr */
-		ia64_srlz_i();
-	}
+	/*
+	 * Cannot write to CRx with PSR.ic=1
+	 */
+	psr = ia64_clear_ic();
+	ia64_itr(0x1, IA64_TR_PALCODE, GRANULEROUNDDOWN((unsigned long) pal_vaddr),
+		 pte_val(pfn_pte(__pa(pal_vaddr) >> PAGE_SHIFT, PAGE_KERNEL)),
+		 IA64_GRANULE_SHIFT);
+	ia64_set_psr(psr);		/* restore psr */
+	ia64_srlz_i();
 }
 
 void __init
diff -Nru a/arch/ia64/kernel/entry.S b/arch/ia64/kernel/entry.S
--- a/arch/ia64/kernel/entry.S	2005-01-22 14:32:20 -08:00
+++ b/arch/ia64/kernel/entry.S	2005-01-28 15:15:49 -08:00
@@ -558,7 +558,7 @@
 .mem.offset 0,0; st8.spill [r2]=r8		// store return value in slot for r8
 .mem.offset 8,0; st8.spill [r3]=r10		// clear error indication in slot for r10
 	br.call.sptk.many rp=syscall_trace_leave // give parent a chance to catch return value
-.ret3:	br.cond.sptk ia64_leave_syscall
+.ret3:	br.cond.sptk .work_pending_syscall_end
 
 strace_error:
 	ld8 r3=[r2]				// load pt_regs.r8
@@ -621,10 +621,7 @@
 	PT_REGS_UNWIND_INFO(0)
 	cmp.ge p6,p7=r8,r0			// syscall executed successfully?
 	adds r2=PT(R8)+16,sp			// r2 = &pt_regs.r8
-	adds r3=PT(R10)+16,sp			// r3 = &pt_regs.r10
-	;;
-.mem.offset 0,0; (p6) st8.spill [r2]=r8	// store return value in slot for r8 and set unat bit
-.mem.offset 8,0; (p6) st8.spill [r3]=r0	// clear error indication in slot for r10 and set unat bit
+	mov r10=r0				// clear error indication in r10
 (p7)	br.cond.spnt handle_syscall_error	// handle potential syscall failure
 END(ia64_ret_from_syscall)
 	// fall through
@@ -709,27 +706,23 @@
 	ld8 r19=[r2],PT(B6)-PT(LOADRS)		// load ar.rsc value for "loadrs"
 	mov b7=r0		// clear b7
 	;;
-	ld8 r23=[r3],PT(R9)-PT(AR_BSPSTORE)	// load ar.bspstore (may be garbage)
-	ld8 r18=[r2],PT(R8)-PT(B6)		// load b6
+	ld8 r23=[r3],PT(R11)-PT(AR_BSPSTORE)	// load ar.bspstore (may be garbage)
+	ld8 r18=[r2],PT(R9)-PT(B6)		// load b6
 (p6)	and r15=TIF_WORK_MASK,r31		// any work other than TIF_SYSCALL_TRACE?
 	;;
 	mov r16=ar.bsp				// M2  get existing backing store pointer
 (p6)	cmp4.ne.unc p6,p0=r15, r0		// any special work pending?
-(p6)	br.cond.spnt .work_pending
+(p6)	br.cond.spnt .work_pending_syscall
 	;;
 	// start restoring the state saved on the kernel stack (struct pt_regs):
-	ld8.fill r8=[r2],16
-	ld8.fill r9=[r3],16
+	ld8 r9=[r2],PT(CR_IPSR)-PT(R9)
+	ld8 r11=[r3],PT(CR_IIP)-PT(R11)
 	mov f6=f0		// clear f6
 	;;
 	invala			// M0|1 invalidate ALAT
 	rsm psr.i | psr.ic	// M2 initiate turning off of interrupt and interruption collection
 	mov f9=f0		// clear f9
 
-	ld8.fill r10=[r2],16
-	ld8.fill r11=[r3],16
-	mov f7=f0		// clear f7
-	;;
 	ld8 r29=[r2],16		// load cr.ipsr
 	ld8 r28=[r3],16			// load cr.iip
 	mov f8=f0		// clear f8
@@ -760,7 +753,7 @@
 	;;
 	srlz.d			// M0  ensure interruption collection is off
 	ld8.fill r13=[r3],16
-	nop.i 0
+	mov f7=f0		// clear f7
 	;;
 	ld8.fill r12=[r2]	// restore r12 (sp)
 	ld8.fill r15=[r3]	// restore r15
@@ -770,8 +763,8 @@
 (pUStk) st1 [r14]=r17
 	mov b6=r18		// I0  restore b6
 	;;
-	shr.u r18=r19,16	// I0|1 get byte size of existing "dirty" partition
 	mov r14=r0		// clear r14
+	shr.u r18=r19,16	// I0|1 get byte size of existing "dirty" partition
 (pKStk) br.cond.dpnt.many skip_rbs_switch
 
 	mov.m ar.ccv=r0		// clear ar.ccv
@@ -987,7 +980,7 @@
 	shladd in0=loc1,3,r17
 	mov in1=0
 	;;
-	.align 32
+	TEXT_ALIGN(32)
 rse_clear_invalid:
 #ifdef CONFIG_ITANIUM
 	// cycle 0
@@ -1083,6 +1076,12 @@
 	 * On exit:
 	 *	p6 = TRUE if work-pending-check needs to be redone
 	 */
+.work_pending_syscall:
+	add r2=-8,r2
+	add r3=-8,r3
+	;;
+	st8 [r2]=r8
+	st8 [r3]=r10
 .work_pending:
 	tbit.nz p6,p0=r31,TIF_SIGDELAYED		// signal delayed from  MCA/INIT/NMI/PMI context?
 (p6)	br.cond.sptk.few .sigdelayed
@@ -1104,13 +1103,13 @@
 	;;
 (pKStk)	st4 [r20]=r0		// preempt_count() <- 0
 #endif
-(pLvSys)br.cond.sptk.many .work_processed_syscall	// re-check
+(pLvSys)br.cond.sptk.few  .work_pending_syscall_end
 	br.cond.sptk.many .work_processed_kernel	// re-check
 
 .notify:
 (pUStk)	br.call.spnt.many rp=notify_resume_user
 .ret10:	cmp.ne p6,p0=r0,r0				// p6 <- 0
-(pLvSys)br.cond.sptk.many .work_processed_syscall	// don't re-check
+(pLvSys)br.cond.sptk.few  .work_pending_syscall_end
 	br.cond.sptk.many .work_processed_kernel	// don't re-check
 
 // There is a delayed signal that was detected in MCA/INIT/NMI/PMI context where
@@ -1121,9 +1120,17 @@
 .sigdelayed:
 	br.call.sptk.many rp=do_sigdelayed
 	cmp.eq p6,p0=r0,r0				// p6 <- 1, always re-check
-(pLvSys)br.cond.sptk.many .work_processed_syscall	// re-check
+(pLvSys)br.cond.sptk.few  .work_pending_syscall_end
 	br.cond.sptk.many .work_processed_kernel	// re-check
 
+.work_pending_syscall_end:
+	adds r2=PT(R8)+16,r12
+	adds r3=PT(R10)+16,r12
+	;;
+	ld8 r8=[r2]
+	ld8 r10=[r3]
+	br.cond.sptk.many .work_processed_syscall	// re-check
+
 END(ia64_leave_kernel)
 
 ENTRY(handle_syscall_error)
@@ -1135,17 +1142,11 @@
 	 */
 	PT_REGS_UNWIND_INFO(0)
 	ld8 r3=[r2]		// load pt_regs.r8
-	sub r9=0,r8		// negate return value to get errno
 	;;
-	mov r10=-1		// return -1 in pt_regs.r10 to indicate error
 	cmp.eq p6,p7=r3,r0	// is pt_regs.r8==0?
-	adds r3=16,r2		// r3=&pt_regs.r10
-	;;
-(p6)	mov r9=r8
-(p6)	mov r10=0
 	;;
-.mem.offset 0,0; st8.spill [r2]=r9	// store errno in pt_regs.r8 and set unat bit
-.mem.offset 8,0; st8.spill [r3]=r10	// store error indication in pt_regs.r10 and set unat bit
+(p7)	mov r10=-1
+(p7)	sub r8=0,r8		// negate return value to get errno
 	br.cond.sptk ia64_leave_syscall
 END(handle_syscall_error)
 
diff -Nru a/arch/ia64/kernel/head.S b/arch/ia64/kernel/head.S
--- a/arch/ia64/kernel/head.S	2005-01-11 15:45:50 -08:00
+++ b/arch/ia64/kernel/head.S	2005-01-28 15:50:13 -08:00
@@ -5,7 +5,7 @@
  * to set up the kernel's global pointer and jump to the kernel
  * entry point.
  *
- * Copyright (C) 1998-2001, 2003 Hewlett-Packard Co
+ * Copyright (C) 1998-2001, 2003, 2005 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  *	Stephane Eranian <eranian@hpl.hp.com>
  * Copyright (C) 1999 VA Linux Systems
@@ -232,21 +232,6 @@
 	;;
 (isBP)	st8 [r2]=r28		// save the address of the boot param area passed by the bootloader
 
-#ifdef CONFIG_IA64_EARLY_PRINTK
-	.rodata
-alive_msg:
-	stringz "I'm alive and well\n"
-alive_msg_end:
-	.previous
-
-	alloc r2=ar.pfs,0,0,2,0
-	movl out0=alive_msg
-	movl out1=alive_msg_end-alive_msg-1
-	;;
-	br.call.sptk.many rp=early_printk
-1:	// force new bundle
-#endif /* CONFIG_IA64_EARLY_PRINTK */
-
 #ifdef CONFIG_SMP
 (isAP)	br.call.sptk.many rp=start_secondary
 .ret0:
@@ -267,7 +252,9 @@
 	;;
 	ld8 out0=[r3]
 	br.call.sptk.many b0=console_print
-self:	br.sptk.many self		// endless loop
+
+self:	hint @pause
+	br.sptk.many self		// endless loop
 END(_start)
 
 GLOBAL_ENTRY(ia64_save_debug_regs)
diff -Nru a/arch/ia64/kernel/ivt.S b/arch/ia64/kernel/ivt.S
--- a/arch/ia64/kernel/ivt.S	2005-01-22 14:19:19 -08:00
+++ b/arch/ia64/kernel/ivt.S	2005-02-02 15:06:25 -08:00
@@ -548,7 +548,7 @@
 #endif
 	mov pr=r31,-1				// restore pr
 	rfi
-END(idirty_bit)
+END(dirty_bit)
 
 	.org ia64_ivt+0x2400
 /////////////////////////////////////////////////////////////////////////////////////////
diff -Nru a/arch/ia64/kernel/mca.c b/arch/ia64/kernel/mca.c
--- a/arch/ia64/kernel/mca.c	2005-01-22 13:48:51 -08:00
+++ b/arch/ia64/kernel/mca.c	2005-02-02 12:21:18 -08:00
@@ -67,6 +67,7 @@
 
 #include <asm/delay.h>
 #include <asm/machvec.h>
+#include <asm/meminit.h>
 #include <asm/page.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
@@ -86,6 +87,12 @@
 ia64_mca_sal_to_os_state_t	ia64_sal_to_os_handoff_state;
 ia64_mca_os_to_sal_state_t	ia64_os_to_sal_handoff_state;
 u64				ia64_mca_serialize;
+DEFINE_PER_CPU(u64, ia64_mca_data); /* == __per_cpu_mca[smp_processor_id()] */
+DEFINE_PER_CPU(u64, ia64_mca_per_cpu_pte); /* PTE to map per-CPU area */
+DEFINE_PER_CPU(u64, ia64_mca_pal_pte);	    /* PTE to map PAL code */
+DEFINE_PER_CPU(u64, ia64_mca_pal_base);    /* vaddr PAL code granule */
+
+unsigned long __per_cpu_mca[NR_CPUS];
 
 /* In mca_asm.S */
 extern void			ia64_monarch_init_handler (void);
@@ -1194,6 +1201,53 @@
 	.name =		"cpe_poll"
 };
 #endif /* CONFIG_ACPI */
+
+/* Do per-CPU MCA-related initialization.  */
+
+void __devinit
+ia64_mca_cpu_init(void *cpu_data)
+{
+	void *pal_vaddr;
+
+	if (smp_processor_id() == 0) {
+		void *mca_data;
+		int cpu;
+
+		mca_data = alloc_bootmem(sizeof(struct ia64_mca_cpu)
+					 * NR_CPUS);
+		for (cpu = 0; cpu < NR_CPUS; cpu++) {
+			__per_cpu_mca[cpu] = __pa(mca_data);
+			mca_data += sizeof(struct ia64_mca_cpu);
+		}
+	}
+
+        /*
+         * The MCA info structure was allocated earlier and its
+         * physical address saved in __per_cpu_mca[cpu].  Copy that
+         * address * to ia64_mca_data so we can access it as a per-CPU
+         * variable.
+         */
+	__get_cpu_var(ia64_mca_data) = __per_cpu_mca[smp_processor_id()];
+
+	/*
+	 * Stash away a copy of the PTE needed to map the per-CPU page.
+	 * We may need it during MCA recovery.
+	 */
+	__get_cpu_var(ia64_mca_per_cpu_pte) =
+		pte_val(mk_pte_phys(__pa(cpu_data), PAGE_KERNEL));
+
+        /*
+         * Also, stash away a copy of the PAL address and the PTE
+         * needed to map it.
+         */
+        pal_vaddr = efi_get_pal_addr();
+	if (!pal_vaddr)
+		return;
+	__get_cpu_var(ia64_mca_pal_base) =
+		GRANULEROUNDDOWN((unsigned long) pal_vaddr);
+	__get_cpu_var(ia64_mca_pal_pte) = pte_val(mk_pte_phys(__pa(pal_vaddr),
+							      PAGE_KERNEL));
+}
 
 /*
  * ia64_mca_init
diff -Nru a/arch/ia64/kernel/mca_asm.S b/arch/ia64/kernel/mca_asm.S
--- a/arch/ia64/kernel/mca_asm.S	2005-01-06 16:20:34 -08:00
+++ b/arch/ia64/kernel/mca_asm.S	2005-01-26 14:26:40 -08:00
@@ -144,24 +144,26 @@
 	// The following code purges TC and TR entries. Then reload all TC entries.
 	// Purge percpu data TC entries.
 begin_tlb_purge_and_reload:
-	GET_PERCPU_PADDR(r2)	// paddr of percpu_paddr in cpuinfo struct
-	;;
-	mov	r17=r2
-	;;
-	adds r17=8,r17
+
+#define O(member)	IA64_CPUINFO_##member##_OFFSET
+
+	GET_THIS_PADDR(r2, cpu_info)	// load phys addr of cpu_info into r2
 	;;
-	ld8 r18=[r17],8		// r18=ptce_base
-  	;;
-	ld4 r19=[r17],4		// r19=ptce_count[0]
+	addl r17=O(PTCE_STRIDE),r2
+	addl r2=O(PTCE_BASE),r2
 	;;
-	ld4 r20=[r17],4		// r20=ptce_count[1]
+	ld8 r18=[r2],(O(PTCE_COUNT)-O(PTCE_BASE));;	// r18=ptce_base
+	ld4 r19=[r2],4					// r19=ptce_count[0]
+	ld4 r21=[r17],4					// r21=ptce_stride[0]
 	;;
-	ld4 r21=[r17],4		// r21=ptce_stride[0]
+	ld4 r20=[r2]					// r20=ptce_count[1]
+	ld4 r22=[r17]					// r22=ptce_stride[1]
 	mov r24=0
 	;;
-	ld4 r22=[r17],4		// r22=ptce_stride[1]
 	adds r20=-1,r20
 	;;
+#undef O
+
 2:
 	cmp.ltu p6,p7=r24,r19
 (p7)	br.cond.dpnt.few 4f
@@ -201,9 +203,9 @@
 	srlz.d
 	;;
 	// 3. Purge ITR for PAL code.
-	adds r17=40,r23
+	GET_THIS_PADDR(r2, ia64_mca_pal_base)
 	;;
-	ld8 r16=[r17]
+	ld8 r16=[r2]
 	mov r18=IA64_GRANULE_SHIFT<<2
 	;;
 	ptr.i r16,r18
@@ -246,16 +248,15 @@
 	srlz.d
 	;;
 	// 2. Reload DTR register for PERCPU data.
-	GET_PERCPU_PADDR(r2)		// paddr of percpu_paddr in cpuinfo struct
+	GET_THIS_PADDR(r2, ia64_mca_per_cpu_pte)
 	;;
-	mov r17=r2
 	movl r16=PERCPU_ADDR		// vaddr
 	movl r18=PERCPU_PAGE_SHIFT<<2
 	;;
 	mov cr.itir=r18
 	mov cr.ifa=r16
 	;;
-	ld8 r18=[r17]			// pte
+	ld8 r18=[r2]			// load per-CPU PTE
 	mov r16=IA64_TR_PERCPU_DATA;
 	;;
 	itr.d dtr[r16]=r18
@@ -263,13 +264,13 @@
 	srlz.d
 	;;
 	// 3. Reload ITR for PAL code.
-	GET_CPUINFO_PAL_PADDR(r2)	// paddr of pal_paddr in cpuinfo struct
+	GET_THIS_PADDR(r2, ia64_mca_pal_pte)
 	;;
-	mov r17=r2
+	ld8 r18=[r2]			// load PAL PTE
 	;;
-	ld8 r18=[r17],8			// pte
+	GET_THIS_PADDR(r2, ia64_mca_pal_base)
 	;;
-	ld8 r16=[r17]			// vaddr
+	ld8 r16=[r2]			// load PAL vaddr
 	mov r19=IA64_GRANULE_SHIFT<<2
 	;;
 	mov cr.itir=r19
@@ -308,14 +309,18 @@
 done_tlb_purge_and_reload:
 
 	// Setup new stack frame for OS_MCA handling
-	GET_MCA_BSPSTORE(r2)		// paddr of bspstore save area
-	GET_MCA_STACKFRAME(r3);;	// paddr of stack frame save area
+	GET_THIS_PADDR(r2, ia64_mca_data)
+	;;
+	add r3 = IA64_MCA_CPU_STACKFRAME_OFFSET, r2
+	add r2 = IA64_MCA_CPU_RBSTORE_OFFSET, r2
+	;;
 	rse_switch_context(r6,r3,r2);;	// RSC management in this new context
-	GET_MCA_STACK(r2);;		// paddr of stack save area
-					// stack size must be same as C array
-	addl	r2=8*1024-16,r2;;	// stack base @ bottom of array
-	mov	r12=r2			// allow 16 bytes of scratch
-					// (C calling convention)
+
+	GET_THIS_PADDR(r2, ia64_mca_data)
+	;;
+	add r2 = IA64_MCA_CPU_STACK_OFFSET+IA64_MCA_STACK_SIZE-16, r2
+	;;
+	mov r12=r2		// establish new stack-pointer
 
         // Enter virtual mode from physical mode
 	VIRTUAL_MODE_ENTER(r2, r3, ia64_os_mca_virtual_begin, r4)
@@ -331,7 +336,10 @@
 ia64_os_mca_virtual_end:
 
 	// restore the original stack frame here
-	GET_MCA_STACKFRAME(r2);;	// phys addr of MCA save area
+	GET_THIS_PADDR(r2, ia64_mca_data)
+	;;
+	add r2 = IA64_MCA_CPU_STACKFRAME_OFFSET, r2
+	;;
 	movl    r4=IA64_PSR_MC
 	;;
 	rse_return_context(r4,r3,r2)	// switch from interrupt context for RSE
@@ -372,8 +380,10 @@
 ia64_os_mca_proc_state_dump:
 // Save bank 1 GRs 16-31 which will be used by c-language code when we switch
 //  to virtual addressing mode.
-	GET_MCA_DUMP_PADDR(r2);;  // phys addr of MCA save area
-
+	GET_THIS_PADDR(r2, ia64_mca_data)
+	;;
+	add r2 = IA64_MCA_CPU_PROC_STATE_DUMP_OFFSET, r2
+	;;
 // save ar.NaT
 	mov		r5=ar.unat                  // ar.unat
 
@@ -603,7 +613,9 @@
 ia64_os_mca_proc_state_restore:
 
 // Restore bank1 GR16-31
-	GET_MCA_DUMP_PADDR(r2);;		// phys addr of proc state dump area
+	GET_THIS_PADDR(r2, ia64_mca_data)
+	;;
+	add r2 = IA64_MCA_CPU_PROC_STATE_DUMP_OFFSET, r2
 
 restore_GRs:                                    // restore bank-1 GRs 16-31
 	bsw.1;;
diff -Nru a/arch/ia64/kernel/minstate.h b/arch/ia64/kernel/minstate.h
--- a/arch/ia64/kernel/minstate.h	2004-12-10 13:31:49 -08:00
+++ b/arch/ia64/kernel/minstate.h	2005-01-26 10:01:31 -08:00
@@ -37,10 +37,10 @@
  * go virtual and don't want to destroy the iip or ipsr.
  */
 #define MINSTATE_START_SAVE_MIN_PHYS								\
-(pKStk) mov r3=ar.k3;;										\
-(pKStk) addl r3=IA64_CPUINFO_PA_MCA_INFO,r3;;							\
+(pKStk) mov r3=IA64_KR(PER_CPU_DATA);;								\
+(pKStk) addl r3=THIS_CPU(ia64_mca_data),r3;;							\
 (pKStk) ld8 r3 = [r3];;										\
-(pKStk) addl r3=IA64_INIT_STACK,r3;;								\
+(pKStk) addl r3=IA64_MCA_CPU_INIT_STACK_OFFSET,r3;;						\
 (pKStk) addl sp=IA64_STK_OFFSET-IA64_PT_REGS_SIZE,r3;						\
 (pUStk)	mov ar.rsc=0;		/* set enforced lazy mode, pl 0, little-endian, loadrs=0 */	\
 (pUStk)	addl r22=IA64_RBS_OFFSET,r1;		/* compute base of register backing store */	\
diff -Nru a/arch/ia64/kernel/perfmon.c b/arch/ia64/kernel/perfmon.c
--- a/arch/ia64/kernel/perfmon.c	2004-12-28 13:20:10 -08:00
+++ b/arch/ia64/kernel/perfmon.c	2005-01-25 12:23:45 -08:00
@@ -5,13 +5,13 @@
  * The initial version of perfmon.c was written by
  * Ganesh Venkitachalam, IBM Corp.
  *
- * Then it was modified for perfmon-1.x by Stephane Eranian and 
+ * Then it was modified for perfmon-1.x by Stephane Eranian and
  * David Mosberger, Hewlett Packard Co.
- * 
+ *
  * Version Perfmon-2.x is a rewrite of perfmon-1.x
- * by Stephane Eranian, Hewlett Packard Co. 
+ * by Stephane Eranian, Hewlett Packard Co.
  *
- * Copyright (C) 1999-2003  Hewlett Packard Co
+ * Copyright (C) 1999-2003, 2005  Hewlett Packard Co
  *               Stephane Eranian <eranian@hpl.hp.com>
  *               David Mosberger-Tang <davidm@hpl.hp.com>
  *
@@ -4778,10 +4778,8 @@
  * system-call entry point (must return long)
  */
 asmlinkage long
-sys_perfmonctl (int fd, int cmd, void __user *arg, int count, long arg5, long arg6, long arg7,
-		long arg8, long stack)
+sys_perfmonctl (int fd, int cmd, void __user *arg, int count)
 {
-	struct pt_regs *regs = (struct pt_regs *)&stack;
 	struct file *file = NULL;
 	pfm_context_t *ctx = NULL;
 	unsigned long flags = 0UL;
@@ -4905,7 +4903,7 @@
 	if (unlikely(ret)) goto abort_locked;
 
 skip_fd:
-	ret = (*func)(ctx, args_k, count, regs);
+	ret = (*func)(ctx, args_k, count, ia64_task_regs(current));
 
 	call_made = 1;
 
@@ -6671,8 +6669,7 @@
 }
 #else  /* !CONFIG_PERFMON */
 asmlinkage long
-sys_perfmonctl (int fd, int cmd, void *arg, int count, long arg5, long arg6, long arg7,
-		long arg8, long stack)
+sys_perfmonctl (int fd, int cmd, void *arg, int count)
 {
 	return -ENOSYS;
 }
diff -Nru a/arch/ia64/kernel/ptrace.c b/arch/ia64/kernel/ptrace.c
--- a/arch/ia64/kernel/ptrace.c	2005-01-22 13:20:22 -08:00
+++ b/arch/ia64/kernel/ptrace.c	2005-01-28 15:43:34 -08:00
@@ -1,11 +1,10 @@
 /*
  * Kernel support for the ptrace() and syscall tracing interfaces.
  *
- * Copyright (C) 1999-2004 Hewlett-Packard Co
+ * Copyright (C) 1999-2005 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  *
- * Derived from the x86 and Alpha versions.  Most of the code in here
- * could actually be factored into a common set of routines.
+ * Derived from the x86 and Alpha versions.
  */
 #include <linux/config.h>
 #include <linux/kernel.h>
@@ -40,9 +39,11 @@
  *	ri (restart instruction; two bits)
  *	is (instruction set; one bit)
  */
-#define IPSR_WRITE_MASK \
-	(IA64_PSR_UM | IA64_PSR_DB | IA64_PSR_IS | IA64_PSR_ID | IA64_PSR_DD | IA64_PSR_RI)
-#define IPSR_READ_MASK	IPSR_WRITE_MASK
+#define IPSR_MASK (IA64_PSR_UM | IA64_PSR_DB | IA64_PSR_IS	\
+		   | IA64_PSR_ID | IA64_PSR_DD | IA64_PSR_RI)
+
+#define MASK(nbits)	((1UL << (nbits)) - 1)	/* mask with NBITS bits set */
+#define PFM_MASK	MASK(38)
 
 #define PTRACE_DEBUG	0
 
@@ -68,23 +69,24 @@
 unsigned long
 ia64_get_scratch_nat_bits (struct pt_regs *pt, unsigned long scratch_unat)
 {
-#	define GET_BITS(first, last, unat)						\
-	({										\
-		unsigned long bit = ia64_unat_pos(&pt->r##first);			\
-		unsigned long mask = ((1UL << (last - first + 1)) - 1) << first;	\
-		unsigned long dist;							\
-		if (bit < first)							\
-			dist = 64 + bit - first;					\
-		else									\
-			dist = bit - first;						\
-		ia64_rotr(unat, dist) & mask;						\
+#	define GET_BITS(first, last, unat)				\
+	({								\
+		unsigned long bit = ia64_unat_pos(&pt->r##first);	\
+		unsigned long nbits = (last - first + 1);		\
+		unsigned long mask = MASK(nbits) << first;		\
+		unsigned long dist;					\
+		if (bit < first)					\
+			dist = 64 + bit - first;			\
+		else							\
+			dist = bit - first;				\
+		ia64_rotr(unat, dist) & mask;				\
 	})
 	unsigned long val;
 
 	/*
-	 * Registers that are stored consecutively in struct pt_regs can be handled in
-	 * parallel.  If the register order in struct_pt_regs changes, this code MUST be
-	 * updated.
+	 * Registers that are stored consecutively in struct pt_regs
+	 * can be handled in parallel.  If the register order in
+	 * struct_pt_regs changes, this code MUST be updated.
 	 */
 	val  = GET_BITS( 1,  1, scratch_unat);
 	val |= GET_BITS( 2,  3, scratch_unat);
@@ -106,23 +108,24 @@
 unsigned long
 ia64_put_scratch_nat_bits (struct pt_regs *pt, unsigned long nat)
 {
-#	define PUT_BITS(first, last, nat)						\
-	({										\
-		unsigned long bit = ia64_unat_pos(&pt->r##first);			\
-		unsigned long mask = ((1UL << (last - first + 1)) - 1) << first;	\
-		long dist;								\
-		if (bit < first)							\
-			dist = 64 + bit - first;					\
-		else									\
-			dist = bit - first;						\
-		ia64_rotl(nat & mask, dist);						\
+#	define PUT_BITS(first, last, nat)				\
+	({								\
+		unsigned long bit = ia64_unat_pos(&pt->r##first);	\
+		unsigned long nbits = (last - first + 1);		\
+		unsigned long mask = MASK(nbits) << first;		\
+		long dist;						\
+		if (bit < first)					\
+			dist = 64 + bit - first;			\
+		else							\
+			dist = bit - first;				\
+		ia64_rotl(nat & mask, dist);				\
 	})
 	unsigned long scratch_unat;
 
 	/*
-	 * Registers that are stored consecutively in struct pt_regs can be handled in
-	 * parallel.  If the register order in struct_pt_regs changes, this code MUST be
-	 * updated.
+	 * Registers that are stored consecutively in struct pt_regs
+	 * can be handled in parallel.  If the register order in
+	 * struct_pt_regs changes, this code MUST be updated.
 	 */
 	scratch_unat  = PUT_BITS( 1,  1, nat);
 	scratch_unat |= PUT_BITS( 2,  3, nat);
@@ -185,10 +188,12 @@
 }
 
 /*
- * This routine is used to read an rnat bits that are stored on the kernel backing store.
- * Since, in general, the alignment of the user and kernel are different, this is not
- * completely trivial.  In essence, we need to construct the user RNAT based on up to two
- * kernel RNAT values and/or the RNAT value saved in the child's pt_regs.
+ * This routine is used to read an rnat bits that are stored on the
+ * kernel backing store.  Since, in general, the alignment of the user
+ * and kernel are different, this is not completely trivial.  In
+ * essence, we need to construct the user RNAT based on up to two
+ * kernel RNAT values and/or the RNAT value saved in the child's
+ * pt_regs.
  *
  * user rbs
  *
@@ -221,24 +226,28 @@
  *					+--------+
  *						  <--- child_stack->ar_bspstore
  *
- * The way to think of this code is as follows: bit 0 in the user rnat corresponds to some
- * bit N (0 <= N <= 62) in one of the kernel rnat value.  The kernel rnat value holding
- * this bit is stored in variable rnat0.  rnat1 is loaded with the kernel rnat value that
+ * The way to think of this code is as follows: bit 0 in the user rnat
+ * corresponds to some bit N (0 <= N <= 62) in one of the kernel rnat
+ * value.  The kernel rnat value holding this bit is stored in
+ * variable rnat0.  rnat1 is loaded with the kernel rnat value that
  * form the upper bits of the user rnat value.
  *
  * Boundary cases:
  *
- * o when reading the rnat "below" the first rnat slot on the kernel backing store,
- *   rnat0/rnat1 are set to 0 and the low order bits are merged in from pt->ar_rnat.
+ * o when reading the rnat "below" the first rnat slot on the kernel
+ *   backing store, rnat0/rnat1 are set to 0 and the low order bits are
+ *   merged in from pt->ar_rnat.
  *
- * o when reading the rnat "above" the last rnat slot on the kernel backing store,
- *   rnat0/rnat1 gets its value from sw->ar_rnat.
+ * o when reading the rnat "above" the last rnat slot on the kernel
+ *   backing store, rnat0/rnat1 gets its value from sw->ar_rnat.
  */
 static unsigned long
 get_rnat (struct task_struct *task, struct switch_stack *sw,
-	  unsigned long *krbs, unsigned long *urnat_addr, unsigned long *urbs_end)
+	  unsigned long *krbs, unsigned long *urnat_addr,
+	  unsigned long *urbs_end)
 {
-	unsigned long rnat0 = 0, rnat1 = 0, urnat = 0, *slot0_kaddr, umask = 0, mask, m;
+	unsigned long rnat0 = 0, rnat1 = 0, urnat = 0, *slot0_kaddr;
+	unsigned long umask = 0, mask, m;
 	unsigned long *kbsp, *ubspstore, *rnat0_kaddr, *rnat1_kaddr, shift;
 	long num_regs, nbits;
 	struct pt_regs *pt;
@@ -251,11 +260,12 @@
 		nbits = ia64_rse_num_regs(urnat_addr - 63, urbs_end);
 	else
 		nbits = 63;
-	mask = (1UL << nbits) - 1;
+	mask = MASK(nbits);
 	/*
-	 * First, figure out which bit number slot 0 in user-land maps to in the kernel
-	 * rnat.  Do this by figuring out how many register slots we're beyond the user's
-	 * backingstore and then computing the equivalent address in kernel space.
+	 * First, figure out which bit number slot 0 in user-land maps
+	 * to in the kernel rnat.  Do this by figuring out how many
+	 * register slots we're beyond the user's backingstore and
+	 * then computing the equivalent address in kernel space.
 	 */
 	num_regs = ia64_rse_num_regs(ubspstore, urnat_addr + 1);
 	slot0_kaddr = ia64_rse_skip_regs(krbs, num_regs);
@@ -265,7 +275,7 @@
 
 	if (ubspstore + 63 > urnat_addr) {
 		/* some bits need to be merged in from pt->ar_rnat */
-		umask = ((1UL << ia64_rse_slot_num(ubspstore)) - 1) & mask;
+		umask = MASK(ia64_rse_slot_num(ubspstore)) & mask;
 		urnat = (pt->ar_rnat & umask);
 		mask &= ~umask;
 		if (!mask)
@@ -323,12 +333,13 @@
 			return;
 		nbits = ia64_rse_num_regs(urnat_addr - 63, urbs_kargs);
 	}
-	mask = (1UL << nbits) - 1;
+	mask = MASK(nbits);
 
 	/*
-	 * First, figure out which bit number slot 0 in user-land maps to in the kernel
-	 * rnat.  Do this by figuring out how many register slots we're beyond the user's
-	 * backingstore and then computing the equivalent address in kernel space.
+	 * First, figure out which bit number slot 0 in user-land maps
+	 * to in the kernel rnat.  Do this by figuring out how many
+	 * register slots we're beyond the user's backingstore and
+	 * then computing the equivalent address in kernel space.
 	 */
 	num_regs = ia64_rse_num_regs(ubspstore, urnat_addr + 1);
 	slot0_kaddr = ia64_rse_skip_regs(krbs, num_regs);
@@ -338,7 +349,7 @@
 
 	if (ubspstore + 63 > urnat_addr) {
 		/* some bits need to be place in pt->ar_rnat: */
-		umask = ((1UL << ia64_rse_slot_num(ubspstore)) - 1) & mask;
+		umask = MASK(ia64_rse_slot_num(ubspstore)) & mask;
 		pt->ar_rnat = (pt->ar_rnat & ~umask) | (urnat & umask);
 		mask &= ~umask;
 		if (!mask)
@@ -364,25 +375,28 @@
 }
 
 static inline int
-on_kernel_rbs (unsigned long addr, unsigned long bspstore, unsigned long urbs_end)
+on_kernel_rbs (unsigned long addr, unsigned long bspstore,
+	       unsigned long urbs_end)
 {
-	return (addr >= bspstore
-		&& addr <= (unsigned long) ia64_rse_rnat_addr((unsigned long *) urbs_end));
+	unsigned long *rnat_addr = ia64_rse_rnat_addr((unsigned long *)
+						      urbs_end);
+	return (addr >= bspstore && addr <= (unsigned long) rnat_addr);
 }
 
 /*
- * Read a word from the user-level backing store of task CHILD.  ADDR is the user-level
- * address to read the word from, VAL a pointer to the return value, and USER_BSP gives
- * the end of the user-level backing store (i.e., it's the address that would be in ar.bsp
- * after the user executed a "cover" instruction).
+ * Read a word from the user-level backing store of task CHILD.  ADDR
+ * is the user-level address to read the word from, VAL a pointer to
+ * the return value, and USER_BSP gives the end of the user-level
+ * backing store (i.e., it's the address that would be in ar.bsp after
+ * the user executed a "cover" instruction).
  *
- * This routine takes care of accessing the kernel register backing store for those
- * registers that got spilled there.  It also takes care of calculating the appropriate
- * RNaT collection words.
+ * This routine takes care of accessing the kernel register backing
+ * store for those registers that got spilled there.  It also takes
+ * care of calculating the appropriate RNaT collection words.
  */
 long
-ia64_peek (struct task_struct *child, struct switch_stack *child_stack, unsigned long user_rbs_end,
-	   unsigned long addr, long *val)
+ia64_peek (struct task_struct *child, struct switch_stack *child_stack,
+	   unsigned long user_rbs_end, unsigned long addr, long *val)
 {
 	unsigned long *bspstore, *krbs, regnum, *laddr, *urbs_end, *rnat_addr;
 	struct pt_regs *child_regs;
@@ -394,10 +408,13 @@
 	child_regs = ia64_task_regs(child);
 	bspstore = (unsigned long *) child_regs->ar_bspstore;
 	krbs = (unsigned long *) child + IA64_RBS_OFFSET/8;
-	if (on_kernel_rbs(addr, (unsigned long) bspstore, (unsigned long) urbs_end)) {
+	if (on_kernel_rbs(addr, (unsigned long) bspstore,
+			  (unsigned long) urbs_end))
+	{
 		/*
-		 * Attempt to read the RBS in an area that's actually on the kernel RBS =>
-		 * read the corresponding bits in the kernel RBS.
+		 * Attempt to read the RBS in an area that's actually
+		 * on the kernel RBS => read the corresponding bits in
+		 * the kernel RBS.
 		 */
 		rnat_addr = ia64_rse_rnat_addr(laddr);
 		ret = get_rnat(child, child_stack, krbs, rnat_addr, urbs_end);
@@ -410,18 +427,23 @@
 
 		if (((1UL << ia64_rse_slot_num(laddr)) & ret) != 0) {
 			/*
-			 * It is implementation dependent whether the data portion of a
-			 * NaT value gets saved on a st8.spill or RSE spill (e.g., see
-			 * EAS 2.6, 4.4.4.6 Register Spill and Fill).  To get consistent
-			 * behavior across all possible IA-64 implementations, we return
-			 * zero in this case.
+			 * It is implementation dependent whether the
+			 * data portion of a NaT value gets saved on a
+			 * st8.spill or RSE spill (e.g., see EAS 2.6,
+			 * 4.4.4.6 Register Spill and Fill).  To get
+			 * consistent behavior across all possible
+			 * IA-64 implementations, we return zero in
+			 * this case.
 			 */
 			*val = 0;
 			return 0;
 		}
 
 		if (laddr < urbs_end) {
-			/* the desired word is on the kernel RBS and is not a NaT */
+			/*
+			 * The desired word is on the kernel RBS and
+			 * is not a NaT.
+			 */
 			regnum = ia64_rse_num_regs(bspstore, laddr);
 			*val = *ia64_rse_skip_regs(krbs, regnum);
 			return 0;
@@ -435,43 +457,51 @@
 }
 
 long
-ia64_poke (struct task_struct *child, struct switch_stack *child_stack, unsigned long user_rbs_end,
-	   unsigned long addr, long val)
+ia64_poke (struct task_struct *child, struct switch_stack *child_stack,
+	   unsigned long user_rbs_end, unsigned long addr, long val)
 {
-	unsigned long *bspstore, *krbs, regnum, *laddr, *urbs_end = (long *) user_rbs_end;
+	unsigned long *bspstore, *krbs, regnum, *laddr;
+	unsigned long *urbs_end = (long *) user_rbs_end;
 	struct pt_regs *child_regs;
 
 	laddr = (unsigned long *) addr;
 	child_regs = ia64_task_regs(child);
 	bspstore = (unsigned long *) child_regs->ar_bspstore;
 	krbs = (unsigned long *) child + IA64_RBS_OFFSET/8;
-	if (on_kernel_rbs(addr, (unsigned long) bspstore, (unsigned long) urbs_end)) {
+	if (on_kernel_rbs(addr, (unsigned long) bspstore,
+			  (unsigned long) urbs_end))
+	{
 		/*
-		 * Attempt to write the RBS in an area that's actually on the kernel RBS
-		 * => write the corresponding bits in the kernel RBS.
+		 * Attempt to write the RBS in an area that's actually
+		 * on the kernel RBS => write the corresponding bits
+		 * in the kernel RBS.
 		 */
 		if (ia64_rse_is_rnat_slot(laddr))
-			put_rnat(child, child_stack, krbs, laddr, val, urbs_end);
+			put_rnat(child, child_stack, krbs, laddr, val,
+				 urbs_end);
 		else {
 			if (laddr < urbs_end) {
 				regnum = ia64_rse_num_regs(bspstore, laddr);
 				*ia64_rse_skip_regs(krbs, regnum) = val;
 			}
 		}
-	} else if (access_process_vm(child, addr, &val, sizeof(val), 1) != sizeof(val)) {
+	} else if (access_process_vm(child, addr, &val, sizeof(val), 1)
+		   != sizeof(val))
 		return -EIO;
-	}
 	return 0;
 }
 
 /*
- * Calculate the address of the end of the user-level register backing store.  This is the
- * address that would have been stored in ar.bsp if the user had executed a "cover"
- * instruction right before entering the kernel.  If CFMP is not NULL, it is used to
- * return the "current frame mask" that was active at the time the kernel was entered.
+ * Calculate the address of the end of the user-level register backing
+ * store.  This is the address that would have been stored in ar.bsp
+ * if the user had executed a "cover" instruction right before
+ * entering the kernel.  If CFMP is not NULL, it is used to return the
+ * "current frame mask" that was active at the time the kernel was
+ * entered.
  */
 unsigned long
-ia64_get_user_rbs_end (struct task_struct *child, struct pt_regs *pt, unsigned long *cfmp)
+ia64_get_user_rbs_end (struct task_struct *child, struct pt_regs *pt,
+		       unsigned long *cfmp)
 {
 	unsigned long *krbs, *bspstore, cfm = pt->cr_ifs;
 	long ndirty;
@@ -491,9 +521,11 @@
 }
 
 /*
- * Synchronize (i.e, write) the RSE backing store living in kernel space to the VM of the
- * CHILD task.  SW and PT are the pointers to the switch_stack and pt_regs structures,
- * respectively.  USER_RBS_END is the user-level address at which the backing store ends.
+ * Synchronize (i.e, write) the RSE backing store living in kernel
+ * space to the VM of the CHILD task.  SW and PT are the pointers to
+ * the switch_stack and pt_regs structures, respectively.
+ * USER_RBS_END is the user-level address at which the backing store
+ * ends.
  */
 long
 ia64_sync_user_rbs (struct task_struct *child, struct switch_stack *sw,
@@ -507,7 +539,8 @@
 		ret = ia64_peek(child, sw, user_rbs_end, addr, &val);
 		if (ret < 0)
 			return ret;
-		if (access_process_vm(child, addr, &val, sizeof(val), 1) != sizeof(val))
+		if (access_process_vm(child, addr, &val, sizeof(val), 1)
+		    != sizeof(val))
 			return -EIO;
 	}
 	return 0;
@@ -521,13 +554,14 @@
 
 	if (ptrace_check_attach(thread, 0) < 0)
 		/*
-		 * If the thread is not in an attachable state, we'll ignore it.
-		 * The net effect is that if ADDR happens to overlap with the
-		 * portion of the thread's register backing store that is
-		 * currently residing on the thread's kernel stack, then ptrace()
-		 * may end up accessing a stale value.  But if the thread isn't
-		 * stopped, that's a problem anyhow, so we're doing as well as we
-		 * can...
+		 * If the thread is not in an attachable state, we'll
+		 * ignore it.  The net effect is that if ADDR happens
+		 * to overlap with the portion of the thread's
+		 * register backing store that is currently residing
+		 * on the thread's kernel stack, then ptrace() may end
+		 * up accessing a stale value.  But if the thread
+		 * isn't stopped, that's a problem anyhow, so we're
+		 * doing as well as we can...
 		 */
 		return 0;
 
@@ -540,10 +574,11 @@
 }
 
 /*
- * GDB apparently wants to be able to read the register-backing store of any thread when
- * attached to a given process.  If we are peeking or poking an address that happens to
- * reside in the kernel-backing store of another thread, we need to attach to that thread,
- * because otherwise we end up accessing stale data.
+ * GDB apparently wants to be able to read the register-backing store
+ * of any thread when attached to a given process.  If we are peeking
+ * or poking an address that happens to reside in the kernel-backing
+ * store of another thread, we need to attach to that thread, because
+ * otherwise we end up accessing stale data.
  *
  * task_list_lock must be read-locked before calling this routine!
  */
@@ -557,7 +592,8 @@
 	if (!(mm = get_task_mm(child)))
 		return child;
 
-	mm_users = atomic_read(&mm->mm_users) - 1;	/* -1 because of our get_task_mm()... */
+	/* -1 because of our get_task_mm(): */
+	mm_users = atomic_read(&mm->mm_users) - 1;
 	if (mm_users <= 1)
 		goto out;		/* not multi-threaded */
 
@@ -627,7 +663,8 @@
 }
 
 static int
-access_fr (struct unw_frame_info *info, int regnum, int hi, unsigned long *data, int write_access)
+access_fr (struct unw_frame_info *info, int regnum, int hi,
+	   unsigned long *data, int write_access)
 {
 	struct ia64_fpreg fpval;
 	int ret;
@@ -649,7 +686,8 @@
  * kernel exit-path, rather than the syscall-exit path.
  */
 static void
-convert_to_non_syscall (struct task_struct *child, struct pt_regs  *pt, unsigned long cfm)
+convert_to_non_syscall (struct task_struct *child, struct pt_regs  *pt,
+			unsigned long cfm)
 {
 	struct unw_frame_info info, prev_info;
 	unsigned long ip, pr;
@@ -674,11 +712,51 @@
 }
 
 static int
-access_uarea (struct task_struct *child, unsigned long addr, unsigned long *data, int write_access)
+access_nat_bits (struct task_struct *child, struct pt_regs *pt,
+		 struct unw_frame_info *info,
+		 unsigned long *data, int write_access)
+{
+	unsigned long regnum, nat_bits, scratch_unat, dummy = 0;
+	char nat = 0;
+
+	if (write_access) {
+		nat_bits = *data;
+		scratch_unat = ia64_put_scratch_nat_bits(pt, nat_bits);
+		if (unw_set_ar(info, UNW_AR_UNAT, scratch_unat) < 0) {
+			dprintk("ptrace: failed to set ar.unat\n");
+			return -1;
+		}
+		for (regnum = 4; regnum <= 7; ++regnum) {
+			unw_get_gr(info, regnum, &dummy, &nat);
+			unw_set_gr(info, regnum, dummy,
+				   (nat_bits >> regnum) & 1);
+		}
+	} else {
+		if (unw_get_ar(info, UNW_AR_UNAT, &scratch_unat) < 0) {
+			dprintk("ptrace: failed to read ar.unat\n");
+			return -1;
+		}
+		nat_bits = ia64_get_scratch_nat_bits(pt, scratch_unat);
+		for (regnum = 4; regnum <= 7; ++regnum) {
+			unw_get_gr(info, regnum, &dummy, &nat);
+			nat_bits |= (nat != 0) << regnum;
+		}
+		*data = nat_bits;
+	}
+	return 0;
+}
+
+static int
+access_uarea (struct task_struct *child, unsigned long addr,
+	      unsigned long *data, int write_access)
 {
 	unsigned long *ptr, regnum, urbs_end, rnat_addr, cfm;
 	struct switch_stack *sw;
 	struct pt_regs *pt;
+#	define pt_reg_addr(pt, reg)	((void *)			    \
+					 ((unsigned long) (pt)		    \
+					  + offsetof(struct pt_regs, reg)))
+
 
 	pt = ia64_task_regs(child);
 	sw = (struct switch_stack *) (child->thread.ksp + 16);
@@ -694,17 +772,20 @@
 			ia64_sync_fph(child);
 		else
 			ia64_flush_fph(child);
-		ptr = (unsigned long *) ((unsigned long) &child->thread.fph + addr);
+		ptr = (unsigned long *)
+			((unsigned long) &child->thread.fph + addr);
 	} else if ((addr >= PT_F10) && (addr < PT_F11 + 16)) {
 		/* scratch registers untouched by kernel (saved in pt_regs) */
-		ptr = (unsigned long *)
-			((long) pt + offsetof(struct pt_regs, f10) + addr - PT_F10);
+		ptr = pt_reg_addr(pt, f10) + (addr - PT_F10);
 	} else if (addr >= PT_F12 && addr < PT_F15 + 16) {
-		/* scratch registers untouched by kernel (saved in switch_stack) */
-		ptr = (unsigned long *) ((long) sw + (addr - PT_NAT_BITS - 32));
+		/*
+		 * Scratch registers untouched by kernel (saved in
+		 * switch_stack).
+		 */
+		ptr = (unsigned long *) ((long) sw
+					 + (addr - PT_NAT_BITS - 32));
 	} else if (addr < PT_AR_LC + 8) {
 		/* preserved state: */
-		unsigned long nat_bits, scratch_unat, dummy = 0;
 		struct unw_frame_info info;
 		char nat = 0;
 		int ret;
@@ -715,62 +796,48 @@
 
 		switch (addr) {
 		      case PT_NAT_BITS:
-			if (write_access) {
-				nat_bits = *data;
-				scratch_unat = ia64_put_scratch_nat_bits(pt, nat_bits);
-				if (unw_set_ar(&info, UNW_AR_UNAT, scratch_unat) < 0) {
-					dprintk("ptrace: failed to set ar.unat\n");
-					return -1;
-				}
-				for (regnum = 4; regnum <= 7; ++regnum) {
-					unw_get_gr(&info, regnum, &dummy, &nat);
-					unw_set_gr(&info, regnum, dummy, (nat_bits >> regnum) & 1);
-				}
-			} else {
-				if (unw_get_ar(&info, UNW_AR_UNAT, &scratch_unat) < 0) {
-					dprintk("ptrace: failed to read ar.unat\n");
-					return -1;
-				}
-				nat_bits = ia64_get_scratch_nat_bits(pt, scratch_unat);
-				for (regnum = 4; regnum <= 7; ++regnum) {
-					unw_get_gr(&info, regnum, &dummy, &nat);
-					nat_bits |= (nat != 0) << regnum;
-				}
-				*data = nat_bits;
-			}
-			return 0;
+			return access_nat_bits(child, pt, &info,
+					       data, write_access);
 
 		      case PT_R4: case PT_R5: case PT_R6: case PT_R7:
 			if (write_access) {
 				/* read NaT bit first: */
 				unsigned long dummy;
 
-				ret = unw_get_gr(&info, (addr - PT_R4)/8 + 4, &dummy, &nat);
+				ret = unw_get_gr(&info, (addr - PT_R4)/8 + 4,
+						 &dummy, &nat);
 				if (ret < 0)
 					return ret;
 			}
-			return unw_access_gr(&info, (addr - PT_R4)/8 + 4, data, &nat,
-					     write_access);
+			return unw_access_gr(&info, (addr - PT_R4)/8 + 4, data,
+					     &nat, write_access);
 
-		      case PT_B1: case PT_B2: case PT_B3: case PT_B4: case PT_B5:
-			return unw_access_br(&info, (addr - PT_B1)/8 + 1, data, write_access);
+		      case PT_B1: case PT_B2: case PT_B3:
+		      case PT_B4: case PT_B5:
+			return unw_access_br(&info, (addr - PT_B1)/8 + 1, data,
+					     write_access);
 
 		      case PT_AR_EC:
-			return unw_access_ar(&info, UNW_AR_EC, data, write_access);
+			return unw_access_ar(&info, UNW_AR_EC, data,
+					     write_access);
 
 		      case PT_AR_LC:
-			return unw_access_ar(&info, UNW_AR_LC, data, write_access);
+			return unw_access_ar(&info, UNW_AR_LC, data,
+					     write_access);
 
 		      default:
 			if (addr >= PT_F2 && addr < PT_F5 + 16)
-				return access_fr(&info, (addr - PT_F2)/16 + 2, (addr & 8) != 0,
-						 data, write_access);
+				return access_fr(&info, (addr - PT_F2)/16 + 2,
+						 (addr & 8) != 0, data,
+						 write_access);
 			else if (addr >= PT_F16 && addr < PT_F31 + 16)
-				return access_fr(&info, (addr - PT_F16)/16 + 16, (addr & 8) != 0,
+				return access_fr(&info,
+						 (addr - PT_F16)/16 + 16,
+						 (addr & 8) != 0,
 						 data, write_access);
 			else {
-				dprintk("ptrace: rejecting access to register address 0x%lx\n",
-					addr);
+				dprintk("ptrace: rejecting access to register "
+					"address 0x%lx\n", addr);
 				return -1;
 			}
 		}
@@ -779,34 +846,49 @@
 		switch (addr) {
 		      case PT_AR_BSP:
 			/*
-			 * By convention, we use PT_AR_BSP to refer to the end of the user-level
-			 * backing store.  Use ia64_rse_skip_regs(PT_AR_BSP, -CFM.sof) to get
-			 * the real value of ar.bsp at the time the kernel was entered.
+			 * By convention, we use PT_AR_BSP to refer to
+			 * the end of the user-level backing store.
+			 * Use ia64_rse_skip_regs(PT_AR_BSP, -CFM.sof)
+			 * to get the real value of ar.bsp at the time
+			 * the kernel was entered.
 			 *
-			 * Furthermore, when changing the contents of PT_AR_BSP (or
-			 * PT_CFM) we MUST copy any users-level stacked registers that are
-			 * stored on the kernel stack back to user-space because
-			 * otherwise, we might end up clobbering kernel stacked registers.
-			 * Also, if this happens while the task is blocked in a system
-			 * call, which convert the state such that the non-system-call
-			 * exit path is used.  This ensures that the proper state will be
-			 * picked up when resuming execution.  However, it *also* means
-			 * that once we write PT_AR_BSP/PT_CFM, it won't be possible to
-			 * modify the syscall arguments of the pending system call any
-			 * longer.  This shouldn't be an issue because modifying
-			 * PT_AR_BSP/PT_CFM generally implies that we're either abandoning
-			 * the pending system call or that we defer it's re-execution
-			 * (e.g., due to GDB doing an inferior function call).
+			 * Furthermore, when changing the contents of
+			 * PT_AR_BSP (or PT_CFM) we MUST copy any
+			 * users-level stacked registers that are
+			 * stored on the kernel stack back to
+			 * user-space because otherwise, we might end
+			 * up clobbering kernel stacked registers.
+			 * Also, if this happens while the task is
+			 * blocked in a system call, which convert the
+			 * state such that the non-system-call exit
+			 * path is used.  This ensures that the proper
+			 * state will be picked up when resuming
+			 * execution.  However, it *also* means that
+			 * once we write PT_AR_BSP/PT_CFM, it won't be
+			 * possible to modify the syscall arguments of
+			 * the pending system call any longer.  This
+			 * shouldn't be an issue because modifying
+			 * PT_AR_BSP/PT_CFM generally implies that
+			 * we're either abandoning the pending system
+			 * call or that we defer it's re-execution
+			 * (e.g., due to GDB doing an inferior
+			 * function call).
 			 */
 			urbs_end = ia64_get_user_rbs_end(child, pt, &cfm);
 			if (write_access) {
 				if (*data != urbs_end) {
 					if (ia64_sync_user_rbs(child, sw,
-							       pt->ar_bspstore, urbs_end) < 0)
+							       pt->ar_bspstore,
+							       urbs_end) < 0)
 						return -1;
 					if (in_syscall(pt))
-						convert_to_non_syscall(child, pt, cfm);
-					/* simulate user-level write of ar.bsp: */
+						convert_to_non_syscall(child,
+								       pt,
+								       cfm);
+					/*
+					 * Simulate user-level write
+					 * of ar.bsp:
+					 */
 					pt->loadrs = 0;
 					pt->ar_bspstore = *data;
 				}
@@ -817,14 +899,17 @@
 		      case PT_CFM:
 			urbs_end = ia64_get_user_rbs_end(child, pt, &cfm);
 			if (write_access) {
-				if (((cfm ^ *data) & 0x3fffffffffUL) != 0) {
+				if (((cfm ^ *data) & PFM_MASK) != 0) {
 					if (ia64_sync_user_rbs(child, sw,
-							       pt->ar_bspstore, urbs_end) < 0)
+							       pt->ar_bspstore,
+							       urbs_end) < 0)
 						return -1;
 					if (in_syscall(pt))
-						convert_to_non_syscall(child, pt, cfm);
-					pt->cr_ifs = ((pt->cr_ifs & ~0x3fffffffffUL)
-						      | (*data & 0x3fffffffffUL));
+						convert_to_non_syscall(child,
+								       pt,
+								       cfm);
+					pt->cr_ifs = ((pt->cr_ifs & ~PFM_MASK)
+						      | (*data & PFM_MASK));
 				}
 			} else
 				*data = cfm;
@@ -832,99 +917,94 @@
 
 		      case PT_CR_IPSR:
 			if (write_access)
-				pt->cr_ipsr = ((*data & IPSR_WRITE_MASK)
-					       | (pt->cr_ipsr & ~IPSR_WRITE_MASK));
+				pt->cr_ipsr = ((*data & IPSR_MASK)
+					       | (pt->cr_ipsr & ~IPSR_MASK));
 			else
-				*data = (pt->cr_ipsr & IPSR_READ_MASK);
+				*data = (pt->cr_ipsr & IPSR_MASK);
 			return 0;
 
 		      case PT_AR_RNAT:
 			urbs_end = ia64_get_user_rbs_end(child, pt, NULL);
-			rnat_addr = (long) ia64_rse_rnat_addr((long *) urbs_end);
+			rnat_addr = (long) ia64_rse_rnat_addr((long *)
+							      urbs_end);
 			if (write_access)
-				return ia64_poke(child, sw, urbs_end, rnat_addr, *data);
+				return ia64_poke(child, sw, urbs_end,
+						 rnat_addr, *data);
 			else
-				return ia64_peek(child, sw, urbs_end, rnat_addr, data);
+				return ia64_peek(child, sw, urbs_end,
+						 rnat_addr, data);
 
 		      case PT_R1:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, r1));
+			ptr = pt_reg_addr(pt, r1);
 			break;
-
 		      case PT_R2:  case PT_R3:
-			ptr = (unsigned long *)
-				((long) pt + offsetof(struct pt_regs, r2) + addr - PT_R2);
+			ptr = pt_reg_addr(pt, r2) + (addr - PT_R2);
 			break;
 		      case PT_R8:  case PT_R9:  case PT_R10: case PT_R11:
-			ptr = (unsigned long *)
-				((long) pt + offsetof(struct pt_regs, r8)+  addr - PT_R8);
+			ptr = pt_reg_addr(pt, r8) + (addr - PT_R8);
 			break;
 		      case PT_R12: case PT_R13:
-			ptr = (unsigned long *)
-				((long) pt + offsetof(struct pt_regs, r12)+  addr - PT_R12);
+			ptr = pt_reg_addr(pt, r12) + (addr - PT_R12);
 			break;
 		      case PT_R14:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, r14));
+			ptr = pt_reg_addr(pt, r14);
 			break;
 		      case PT_R15:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, r15));
+			ptr = pt_reg_addr(pt, r15);
 			break;
 		      case PT_R16: case PT_R17: case PT_R18: case PT_R19:
 		      case PT_R20: case PT_R21: case PT_R22: case PT_R23:
 		      case PT_R24: case PT_R25: case PT_R26: case PT_R27:
 		      case PT_R28: case PT_R29: case PT_R30: case PT_R31:
-			ptr = (unsigned long *)
-				((long) pt + offsetof(struct pt_regs, r16) + addr - PT_R16);
+			ptr = pt_reg_addr(pt, r16) + (addr - PT_R16);
 			break;
 		      case PT_B0:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, b0));
+			ptr = pt_reg_addr(pt, b0);
 			break;
 		      case PT_B6:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, b6));
+			ptr = pt_reg_addr(pt, b6);
 			break;
 		      case PT_B7:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, b7));
+			ptr = pt_reg_addr(pt, b7);
 			break;
 		      case PT_F6:  case PT_F6+8: case PT_F7: case PT_F7+8:
 		      case PT_F8:  case PT_F8+8: case PT_F9: case PT_F9+8:
-			ptr = (unsigned long *)
-				((long) pt + offsetof(struct pt_regs, f6) + addr - PT_F6);
+			ptr = pt_reg_addr(pt, f6) + (addr - PT_F6);
 			break;
 		      case PT_AR_BSPSTORE:
-			ptr = (unsigned long *)
-				((long) pt + offsetof(struct pt_regs, ar_bspstore));
+			ptr = pt_reg_addr(pt, ar_bspstore);
 			break;
 		      case PT_AR_RSC:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, ar_rsc));
+			ptr = pt_reg_addr(pt, ar_rsc);
 			break;
 		      case PT_AR_UNAT:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, ar_unat));
+			ptr = pt_reg_addr(pt, ar_unat);
 			break;
 		      case PT_AR_PFS:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, ar_pfs));
+			ptr = pt_reg_addr(pt, ar_pfs);
 			break;
 		      case PT_AR_CCV:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, ar_ccv));
+			ptr = pt_reg_addr(pt, ar_ccv);
 			break;
 		      case PT_AR_FPSR:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, ar_fpsr));
+			ptr = pt_reg_addr(pt, ar_fpsr);
 			break;
 		      case PT_CR_IIP:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, cr_iip));
+			ptr = pt_reg_addr(pt, cr_iip);
 			break;
 		      case PT_PR:
-			ptr = (unsigned long *) ((long) pt + offsetof(struct pt_regs, pr));
+			ptr = pt_reg_addr(pt, pr);
 			break;
 			/* scratch register */
 
 		      default:
 			/* disallow accessing anything else... */
-			dprintk("ptrace: rejecting access to register address 0x%lx\n",
-				addr);
+			dprintk("ptrace: rejecting access to register "
+				"address 0x%lx\n", addr);
 			return -1;
 		}
 	} else if (addr <= PT_AR_SSD) {
-		ptr = (unsigned long *)
-			((long) pt + offsetof(struct pt_regs, ar_csd) + addr - PT_AR_CSD);
+		ptr = pt_reg_addr(pt, ar_csd) + (addr - PT_AR_CSD);
 	} else {
 		/* access debug registers */
 
@@ -937,41 +1017,46 @@
 		}
 
 		if (regnum >= 8) {
-			dprintk("ptrace: rejecting access to register address 0x%lx\n", addr);
+			dprintk("ptrace: rejecting access to register "
+				"address 0x%lx\n", addr);
 			return -1;
 		}
 #ifdef CONFIG_PERFMON
 		/*
-		 * Check if debug registers are used by perfmon. This test must be done
-		 * once we know that we can do the operation, i.e. the arguments are all
-		 * valid, but before we start modifying the state.
+		 * Check if debug registers are used by perfmon. This
+		 * test must be done once we know that we can do the
+		 * operation, i.e. the arguments are all valid, but
+		 * before we start modifying the state.
 		 *
-		 * Perfmon needs to keep a count of how many processes are trying to
-		 * modify the debug registers for system wide monitoring sessions.
+		 * Perfmon needs to keep a count of how many processes
+		 * are trying to modify the debug registers for system
+		 * wide monitoring sessions.
 		 *
-		 * We also include read access here, because they may cause the
-		 * PMU-installed debug register state (dbr[], ibr[]) to be reset. The two
-		 * arrays are also used by perfmon, but we do not use
-		 * IA64_THREAD_DBG_VALID. The registers are restored by the PMU context
-		 * switch code.
+		 * We also include read access here, because they may
+		 * cause the PMU-installed debug register state
+		 * (dbr[], ibr[]) to be reset. The two arrays are also
+		 * used by perfmon, but we do not use
+		 * IA64_THREAD_DBG_VALID. The registers are restored
+		 * by the PMU context switch code.
 		 */
 		if (pfm_use_debug_registers(child)) return -1;
 #endif
 
 		if (!(child->thread.flags & IA64_THREAD_DBG_VALID)) {
 			child->thread.flags |= IA64_THREAD_DBG_VALID;
-			memset(child->thread.dbr, 0, sizeof(child->thread.dbr));
-			memset(child->thread.ibr, 0, sizeof(child->thread.ibr));
+			memset(child->thread.dbr, 0,
+			       sizeof(child->thread.dbr));
+			memset(child->thread.ibr, 0,
+			       sizeof(child->thread.ibr));
 		}
 
 		ptr += regnum;
 
-		if (write_access)
-			/* don't let the user set kernel-level breakpoints... */
+		if ((regnum & 1) && write_access) {
+			/* don't let the user set kernel-level breakpoints: */
 			*ptr = *data & ~(7UL << 56);
-		else
-			*data = *ptr;
-		return 0;
+			return 0;
+		}
 	}
 	if (write_access)
 		*ptr = *data;
@@ -992,7 +1077,8 @@
 	char nat = 0;
 	int i;
 
-	retval = verify_area(VERIFY_WRITE, ppr, sizeof(struct pt_all_user_regs));
+	retval = verify_area(VERIFY_WRITE, ppr,
+			     sizeof(struct pt_all_user_regs));
 	if (retval != 0) {
 		return -EIO;
 	}
@@ -1094,11 +1180,13 @@
 
 	/* fr6-fr11 */
 
-	retval |= __copy_to_user(&ppr->fr[6], &pt->f6, sizeof(struct ia64_fpreg) * 6);
+	retval |= __copy_to_user(&ppr->fr[6], &pt->f6,
+				 sizeof(struct ia64_fpreg) * 6);
 
 	/* fp scratch regs(12-15) */
 
-	retval |= __copy_to_user(&ppr->fr[12], &sw->f12, sizeof(struct ia64_fpreg) * 4);
+	retval |= __copy_to_user(&ppr->fr[12], &sw->f12,
+				 sizeof(struct ia64_fpreg) * 4);
 
 	/* fr16-fr31 */
 
@@ -1111,7 +1199,8 @@
 	/* fph */
 
 	ia64_flush_fph(child);
-	retval |= __copy_to_user(&ppr->fr[32], &child->thread.fph, sizeof(ppr->fr[32]) * 96);
+	retval |= __copy_to_user(&ppr->fr[32], &child->thread.fph,
+				 sizeof(ppr->fr[32]) * 96);
 
 	/*  preds */
 
@@ -1138,7 +1227,8 @@
 
 	memset(&fpval, 0, sizeof(fpval));
 
-	retval = verify_area(VERIFY_READ, ppr, sizeof(struct pt_all_user_regs));
+	retval = verify_area(VERIFY_READ, ppr,
+			     sizeof(struct pt_all_user_regs));
 	if (retval != 0) {
 		return -EIO;
 	}
@@ -1186,7 +1276,8 @@
 
 	for (i = 4; i < 8; i++) {
 		retval |= __get_user(val, &ppr->gr[i]);
-		if (unw_set_gr(&info, i, val, 0) < 0)	 /* NaT bit will be set via PT_NAT_BITS */
+		/* NaT bit will be set via PT_NAT_BITS: */
+		if (unw_set_gr(&info, i, val, 0) < 0)
 			return -EIO;
 	}
 
@@ -1230,16 +1321,19 @@
 
 	/* fr6-fr11 */
 
-	retval |= __copy_from_user(&pt->f6, &ppr->fr[6], sizeof(ppr->fr[6]) * 6);
+	retval |= __copy_from_user(&pt->f6, &ppr->fr[6],
+				   sizeof(ppr->fr[6]) * 6);
 
 	/* fp scratch regs(12-15) */
 
-	retval |= __copy_from_user(&sw->f12, &ppr->fr[12], sizeof(ppr->fr[12]) * 4);
+	retval |= __copy_from_user(&sw->f12, &ppr->fr[12],
+				   sizeof(ppr->fr[12]) * 4);
 
 	/* fr16-fr31 */
 
 	for (i = 16; i < 32; i++) {
-		retval |= __copy_from_user(&fpval, &ppr->fr[i], sizeof(fpval));
+		retval |= __copy_from_user(&fpval, &ppr->fr[i],
+					   sizeof(fpval));
 		if (unw_set_fr(&info, i, fpval) < 0)
 			return -EIO;
 	}
@@ -1247,7 +1341,8 @@
 	/* fph */
 
 	ia64_sync_fph(child);
-	retval |= __copy_from_user(&child->thread.fph, &ppr->fr[32], sizeof(ppr->fr[32]) * 96);
+	retval |= __copy_from_user(&child->thread.fph, &ppr->fr[32],
+				   sizeof(ppr->fr[32]) * 96);
 
 	/* preds */
 
@@ -1279,16 +1374,15 @@
 {
 	struct ia64_psr *child_psr = ia64_psr(ia64_task_regs(child));
 
-	/* make sure the single step/take-branch tra bits are not set: */
+	/* make sure the single step/taken-branch trap bits are not set: */
 	child_psr->ss = 0;
 	child_psr->tb = 0;
 }
 
 asmlinkage long
-sys_ptrace (long request, pid_t pid, unsigned long addr, unsigned long data,
-	    long arg4, long arg5, long arg6, long arg7, long stack)
+sys_ptrace (long request, pid_t pid, unsigned long addr, unsigned long data)
 {
-	struct pt_regs *pt, *regs = (struct pt_regs *) &stack;
+	struct pt_regs *pt;
 	unsigned long urbs_end, peek_or_poke;
 	struct task_struct *child;
 	struct switch_stack *sw;
@@ -1308,8 +1402,10 @@
 		goto out;
 	}
 
-	peek_or_poke = (request == PTRACE_PEEKTEXT || request == PTRACE_PEEKDATA
-			|| request == PTRACE_POKETEXT || request == PTRACE_POKEDATA);
+	peek_or_poke = (request == PTRACE_PEEKTEXT
+			|| request == PTRACE_PEEKDATA
+			|| request == PTRACE_POKETEXT
+			|| request == PTRACE_POKEDATA);
 	ret = -ESRCH;
 	read_lock(&tasklist_lock);
 	{
@@ -1341,31 +1437,37 @@
 
 	switch (request) {
 	      case PTRACE_PEEKTEXT:
-	      case PTRACE_PEEKDATA:		/* read word at location addr */
+	      case PTRACE_PEEKDATA:
+		/* read word at location addr */
 		urbs_end = ia64_get_user_rbs_end(child, pt, NULL);
 		ret = ia64_peek(child, sw, urbs_end, addr, &data);
 		if (ret == 0) {
 			ret = data;
-			regs->r8 = 0;	/* ensure "ret" is not mistaken as an error code */
+			/* ensure "ret" is not mistaken as an error code: */
+			force_successful_syscall_return();
 		}
 		goto out_tsk;
 
 	      case PTRACE_POKETEXT:
-	      case PTRACE_POKEDATA:		/* write the word at location addr */
+	      case PTRACE_POKEDATA:
+		/* write the word at location addr */
 		urbs_end = ia64_get_user_rbs_end(child, pt, NULL);
 		ret = ia64_poke(child, sw, urbs_end, addr, data);
 		goto out_tsk;
 
-	      case PTRACE_PEEKUSR:		/* read the word at addr in the USER area */
+	      case PTRACE_PEEKUSR:
+		/* read the word at addr in the USER area */
 		if (access_uarea(child, addr, &data, 0) < 0) {
 			ret = -EIO;
 			goto out_tsk;
 		}
 		ret = data;
-		regs->r8 = 0;	/* ensure "ret" is not mistaken as an error code */
+		/* ensure "ret" is not mistaken as an error code */
+		force_successful_syscall_return();
 		goto out_tsk;
 
-	      case PTRACE_POKEUSR:	      /* write the word at addr in the USER area */
+	      case PTRACE_POKEUSR:
+		/* write the word at addr in the USER area */
 		if (access_uarea(child, addr, &data, 1) < 0) {
 			ret = -EIO;
 			goto out_tsk;
@@ -1373,16 +1475,20 @@
 		ret = 0;
 		goto out_tsk;
 
-	      case PTRACE_OLD_GETSIGINFO:		/* for backwards-compatibility */
+	      case PTRACE_OLD_GETSIGINFO:
+		/* for backwards-compatibility */
 		ret = ptrace_request(child, PTRACE_GETSIGINFO, addr, data);
 		goto out_tsk;
 
-	      case PTRACE_OLD_SETSIGINFO:		/* for backwards-compatibility */
+	      case PTRACE_OLD_SETSIGINFO:
+		/* for backwards-compatibility */
 		ret = ptrace_request(child, PTRACE_SETSIGINFO, addr, data);
 		goto out_tsk;
 
-	      case PTRACE_SYSCALL:	/* continue and stop at next (return from) syscall */
-	      case PTRACE_CONT:		/* restart after signal. */
+	      case PTRACE_SYSCALL:
+		/* continue and stop at next (return from) syscall */
+	      case PTRACE_CONT:
+		/* restart after signal. */
 		ret = -EIO;
 		if (data > _NSIG)
 			goto out_tsk;
@@ -1392,7 +1498,10 @@
 			clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
 		child->exit_code = data;
 
-		/* make sure the single step/taken-branch trap bits are not set: */
+		/*
+		 * Make sure the single step/taken-branch trap bits
+		 * are not set:
+		 */
 		ia64_psr(pt)->ss = 0;
 		ia64_psr(pt)->tb = 0;
 
@@ -1406,19 +1515,18 @@
 		 * sigkill.  Perhaps it should be put in the status
 		 * that it wants to exit.
 		 */
-		if (child->exit_state == EXIT_ZOMBIE)		/* already dead */
+		if (child->exit_state == EXIT_ZOMBIE)
+			/* already dead */
 			goto out_tsk;
 		child->exit_code = SIGKILL;
 
-		/* make sure the single step/take-branch tra bits are not set: */
-		ia64_psr(pt)->ss = 0;
-		ia64_psr(pt)->tb = 0;
-
+		ptrace_disable(child);
 		wake_up_process(child);
 		ret = 0;
 		goto out_tsk;
 
-	      case PTRACE_SINGLESTEP:		/* let child execute for one instruction */
+	      case PTRACE_SINGLESTEP:
+		/* let child execute for one instruction */
 	      case PTRACE_SINGLEBLOCK:
 		ret = -EIO;
 		if (data > _NSIG)
@@ -1437,16 +1545,19 @@
 		ret = 0;
 		goto out_tsk;
 
-	      case PTRACE_DETACH:		/* detach a process that was attached. */
+	      case PTRACE_DETACH:
+		/* detach a process that was attached. */
 		ret = ptrace_detach(child, data);
 		goto out_tsk;
 
 	      case PTRACE_GETREGS:
-		ret = ptrace_getregs(child, (struct pt_all_user_regs __user *) data);
+		ret = ptrace_getregs(child,
+				     (struct pt_all_user_regs __user *) data);
 		goto out_tsk;
 
 	      case PTRACE_SETREGS:
-		ret = ptrace_setregs(child, (struct pt_all_user_regs __user *) data);
+		ret = ptrace_setregs(child,
+				     (struct pt_all_user_regs __user *) data);
 		goto out_tsk;
 
 	      default:
@@ -1469,15 +1580,16 @@
 	if (!(current->ptrace & PT_PTRACED))
 		return;
 	/*
-	 * The 0x80 provides a way for the tracing parent to distinguish between a syscall
-	 * stop and SIGTRAP delivery.
+	 * The 0x80 provides a way for the tracing parent to
+	 * distinguish between a syscall stop and SIGTRAP delivery.
 	 */
-	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD) ? 0x80 : 0));
+	ptrace_notify(SIGTRAP
+		      | ((current->ptrace & PT_TRACESYSGOOD) ? 0x80 : 0));
 
 	/*
-	 * This isn't the same as continuing with a signal, but it will do for normal use.
-	 * strace only continues with a signal if the stopping signal is not SIGTRAP.
-	 * -brl
+	 * This isn't the same as continuing with a signal, but it
+	 * will do for normal use.  strace only continues with a
+	 * signal if the stopping signal is not SIGTRAP.  -brl
 	 */
 	if (current->exit_code) {
 		send_sig(current->exit_code, current, 1);
@@ -1489,21 +1601,22 @@
 
 asmlinkage void
 syscall_trace_enter (long arg0, long arg1, long arg2, long arg3,
-		     long arg4, long arg5, long arg6, long arg7, long stack)
+		     long arg4, long arg5, long arg6, long arg7,
+		     struct pt_regs regs)
 {
-	struct pt_regs *regs = (struct pt_regs *) &stack;
 	long syscall;
 
 	if (unlikely(current->audit_context)) {
-		if (IS_IA32_PROCESS(regs))
-			syscall = regs->r1;
+		if (IS_IA32_PROCESS(&regs))
+			syscall = regs.r1;
 		else
-			syscall = regs->r15;
+			syscall = regs.r15;
 
 		audit_syscall_entry(current, syscall, arg0, arg1, arg2, arg3);
 	}
 
-	if (test_thread_flag(TIF_SYSCALL_TRACE) && (current->ptrace & PT_PTRACED))
+	if (test_thread_flag(TIF_SYSCALL_TRACE)
+	    && (current->ptrace & PT_PTRACED))
 		syscall_trace();
 }
 
@@ -1511,11 +1624,13 @@
 
 asmlinkage void
 syscall_trace_leave (long arg0, long arg1, long arg2, long arg3,
-		     long arg4, long arg5, long arg6, long arg7, long stack)
+		     long arg4, long arg5, long arg6, long arg7,
+		     struct pt_regs regs)
 {
 	if (unlikely(current->audit_context))
-		audit_syscall_exit(current, ((struct pt_regs *) &stack)->r8);
+		audit_syscall_exit(current, regs.r8);
 
-	if (test_thread_flag(TIF_SYSCALL_TRACE) && (current->ptrace & PT_PTRACED))
+	if (test_thread_flag(TIF_SYSCALL_TRACE)
+	    && (current->ptrace & PT_PTRACED))
 		syscall_trace();
 }
diff -Nru a/arch/ia64/kernel/setup.c b/arch/ia64/kernel/setup.c
--- a/arch/ia64/kernel/setup.c	2005-01-18 12:06:18 -08:00
+++ b/arch/ia64/kernel/setup.c	2005-02-02 12:21:27 -08:00
@@ -60,7 +60,6 @@
 unsigned long __per_cpu_offset[NR_CPUS];
 EXPORT_SYMBOL(__per_cpu_offset);
 #endif
-unsigned long __per_cpu_mca[NR_CPUS];
 
 DEFINE_PER_CPU(struct cpuinfo_ia64, cpu_info);
 DEFINE_PER_CPU(unsigned long, local_per_cpu_offset);
@@ -388,7 +387,7 @@
 	/* enable IA-64 Machine Check Abort Handling unless disabled */
 	if (!strstr(saved_command_line, "nomca"))
 		ia64_mca_init();
-	
+
 	platform_setup(cmdline_p);
 	paging_init();
 }
@@ -602,7 +601,6 @@
 cpu_init (void)
 {
 	extern void __devinit ia64_mmu_init (void *);
-	extern void set_mca_pointer (struct cpuinfo_ia64 *, void *);
 	unsigned long num_phys_stacked;
 	pal_vm_info_2_u_t vmi;
 	unsigned int max_ctx;
@@ -611,6 +609,14 @@
 
 	cpu_data = per_cpu_init();
 
+	/*
+	 * We set ar.k3 so that assembly code in MCA handler can compute
+	 * physical addresses of per cpu variables with a simple:
+	 *   phys = ar.k3 + &per_cpu_var
+	 */
+	ia64_set_kr(IA64_KR_PER_CPU_DATA,
+		    ia64_tpa(cpu_data) - (long) __per_cpu_start);
+
 	get_max_cacheline_size();
 
 	/*
@@ -657,7 +663,7 @@
 		BUG();
 
 	ia64_mmu_init(ia64_imva(cpu_data));
-	set_mca_pointer(cpu_info, cpu_data);
+	ia64_mca_cpu_init(ia64_imva(cpu_data));
 
 #ifdef CONFIG_IA32_SUPPORT
 	ia32_cpu_init();
diff -Nru a/arch/ia64/kernel/signal.c b/arch/ia64/kernel/signal.c
--- a/arch/ia64/kernel/signal.c	2004-12-13 15:10:01 -08:00
+++ b/arch/ia64/kernel/signal.c	2005-01-25 12:23:45 -08:00
@@ -84,12 +84,11 @@
 }
 
 asmlinkage long
-sys_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, long arg2, long arg3, long arg4,
-		 long arg5, long arg6, long arg7, long stack)
+sys_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, long arg2,
+		 long arg3, long arg4, long arg5, long arg6, long arg7,
+		 struct pt_regs regs)
 {
-	struct pt_regs *pt = (struct pt_regs *) &stack;
-
-	return do_sigaltstack(uss, uoss, pt->r12);
+	return do_sigaltstack(uss, uoss, regs.r12);
 }
 
 static long
diff -Nru a/arch/ia64/kernel/sys_ia64.c b/arch/ia64/kernel/sys_ia64.c
--- a/arch/ia64/kernel/sys_ia64.c	2004-10-18 22:26:36 -07:00
+++ b/arch/ia64/kernel/sys_ia64.c	2005-01-25 12:23:45 -08:00
@@ -2,7 +2,7 @@
  * This file contains various system calls that have different calling
  * conventions on different platforms.
  *
- * Copyright (C) 1999-2000, 2002-2003 Hewlett-Packard Co
+ * Copyright (C) 1999-2000, 2002-2003, 2005 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 #include <linux/config.h>
@@ -163,10 +163,9 @@
  * and r9) as this is faster than doing a copy_to_user().
  */
 asmlinkage long
-sys_pipe (long arg0, long arg1, long arg2, long arg3,
-	  long arg4, long arg5, long arg6, long arg7, long stack)
+sys_pipe (void)
 {
-	struct pt_regs *regs = (struct pt_regs *) &stack;
+	struct pt_regs *regs = ia64_task_regs(current);
 	int fd[2];
 	int retval;
 
diff -Nru a/arch/ia64/kernel/traps.c b/arch/ia64/kernel/traps.c
--- a/arch/ia64/kernel/traps.c	2004-10-05 11:27:40 -07:00
+++ b/arch/ia64/kernel/traps.c	2005-01-25 12:23:45 -08:00
@@ -358,11 +358,10 @@
 };
 
 struct illegal_op_return
-ia64_illegal_op_fault (unsigned long ec, unsigned long arg1, unsigned long arg2,
-		       unsigned long arg3, unsigned long arg4, unsigned long arg5,
-		       unsigned long arg6, unsigned long arg7, unsigned long stack)
+ia64_illegal_op_fault (unsigned long ec, long arg1, long arg2, long arg3,
+		       long arg4, long arg5, long arg6, long arg7,
+		       struct pt_regs regs)
 {
-	struct pt_regs *regs = (struct pt_regs *) &stack;
 	struct illegal_op_return rv;
 	struct siginfo si;
 	char buf[128];
@@ -371,19 +370,19 @@
 	{
 		extern struct illegal_op_return ia64_emulate_brl (struct pt_regs *, unsigned long);
 
-		rv = ia64_emulate_brl(regs, ec);
+		rv = ia64_emulate_brl(&regs, ec);
 		if (rv.fkt != (unsigned long) -1)
 			return rv;
 	}
 #endif
 
 	sprintf(buf, "IA-64 Illegal operation fault");
-	die_if_kernel(buf, regs, 0);
+	die_if_kernel(buf, &regs, 0);
 
 	memset(&si, 0, sizeof(si));
 	si.si_signo = SIGILL;
 	si.si_code = ILL_ILLOPC;
-	si.si_addr = (void __user *) (regs->cr_iip + ia64_psr(regs)->ri);
+	si.si_addr = (void __user *) (regs.cr_iip + ia64_psr(&regs)->ri);
 	force_sig_info(SIGILL, &si, current);
 	rv.fkt = 0;
 	return rv;
@@ -391,11 +390,10 @@
 
 void
 ia64_fault (unsigned long vector, unsigned long isr, unsigned long ifa,
-	    unsigned long iim, unsigned long itir, unsigned long arg5,
-	    unsigned long arg6, unsigned long arg7, unsigned long stack)
+	    unsigned long iim, unsigned long itir, long arg5, long arg6,
+	    long arg7, struct pt_regs regs)
 {
-	struct pt_regs *regs = (struct pt_regs *) &stack;
-	unsigned long code, error = isr;
+	unsigned long code, error = isr, iip;
 	struct siginfo siginfo;
 	char buf[128];
 	int result, sig;
@@ -415,10 +413,12 @@
 		 * This fault was due to lfetch.fault, set "ed" bit in the psr to cancel
 		 * the lfetch.
 		 */
-		ia64_psr(regs)->ed = 1;
+		ia64_psr(&regs)->ed = 1;
 		return;
 	}
 
+	iip = regs.cr_iip + ia64_psr(&regs)->ri;
+
 	switch (vector) {
 	      case 24: /* General Exception */
 		code = (isr >> 4) & 0xf;
@@ -428,8 +428,8 @@
 		if (code == 8) {
 # ifdef CONFIG_IA64_PRINT_HAZARDS
 			printk("%s[%d]: possible hazard @ ip=%016lx (pr = %016lx)\n",
-			       current->comm, current->pid, regs->cr_iip + ia64_psr(regs)->ri,
-			       regs->pr);
+			       current->comm, current->pid,
+			       regs.cr_iip + ia64_psr(&regs)->ri, regs.pr);
 # endif
 			return;
 		}
@@ -437,14 +437,14 @@
 
 	      case 25: /* Disabled FP-Register */
 		if (isr & 2) {
-			disabled_fph_fault(regs);
+			disabled_fph_fault(&regs);
 			return;
 		}
 		sprintf(buf, "Disabled FPL fault---not supposed to happen!");
 		break;
 
 	      case 26: /* NaT Consumption */
-		if (user_mode(regs)) {
+		if (user_mode(&regs)) {
 			void __user *addr;
 
 			if (((isr >> 4) & 0xf) == 2) {
@@ -456,7 +456,8 @@
 				/* register NaT consumption */
 				sig = SIGILL;
 				code = ILL_ILLOPN;
-				addr = (void __user *) (regs->cr_iip + ia64_psr(regs)->ri);
+				addr = (void __user *) (regs.cr_iip
+							+ ia64_psr(&regs)->ri);
 			}
 			siginfo.si_signo = sig;
 			siginfo.si_code = code;
@@ -467,17 +468,17 @@
 			siginfo.si_isr = isr;
 			force_sig_info(sig, &siginfo, current);
 			return;
-		} else if (ia64_done_with_exception(regs))
+		} else if (ia64_done_with_exception(&regs))
 			return;
 		sprintf(buf, "NaT consumption");
 		break;
 
 	      case 31: /* Unsupported Data Reference */
-		if (user_mode(regs)) {
+		if (user_mode(&regs)) {
 			siginfo.si_signo = SIGILL;
 			siginfo.si_code = ILL_ILLOPN;
 			siginfo.si_errno = 0;
-			siginfo.si_addr = (void __user *) (regs->cr_iip + ia64_psr(regs)->ri);
+			siginfo.si_addr = (void __user *) iip;
 			siginfo.si_imm = vector;
 			siginfo.si_flags = __ISR_VALID;
 			siginfo.si_isr = isr;
@@ -490,7 +491,7 @@
 	      case 29: /* Debug */
 	      case 35: /* Taken Branch Trap */
 	      case 36: /* Single Step Trap */
-		if (fsys_mode(current, regs)) {
+		if (fsys_mode(current, &regs)) {
 			extern char __kernel_syscall_via_break[];
 			/*
 			 * Got a trap in fsys-mode: Taken Branch Trap and Single Step trap
@@ -498,13 +499,13 @@
 			 */
 			if (unlikely(vector == 29)) {
 				die("Got debug trap in fsys-mode---not supposed to happen!",
-				    regs, 0);
+				    &regs, 0);
 				return;
 			}
 			/* re-do the system call via break 0x100000: */
-			regs->cr_iip = (unsigned long) __kernel_syscall_via_break;
-			ia64_psr(regs)->ri = 0;
-			ia64_psr(regs)->cpl = 3;
+			regs.cr_iip = (unsigned long) __kernel_syscall_via_break;
+			ia64_psr(&regs)->ri = 0;
+			ia64_psr(&regs)->cpl = 3;
 			return;
 		}
 		switch (vector) {
@@ -515,8 +516,8 @@
 			 * Erratum 10 (IFA may contain incorrect address) now has
 			 * "NoFix" status.  There are no plans for fixing this.
 			 */
-			if (ia64_psr(regs)->is == 0)
-			  ifa = regs->cr_iip;
+			if (ia64_psr(&regs)->is == 0)
+			  ifa = regs.cr_iip;
 #endif
 			break;
 		      case 35: siginfo.si_code = TRAP_BRANCH; ifa = 0; break;
@@ -533,12 +534,12 @@
 
 	      case 32: /* fp fault */
 	      case 33: /* fp trap */
-		result = handle_fpu_swa((vector == 32) ? 1 : 0, regs, isr);
+		result = handle_fpu_swa((vector == 32) ? 1 : 0, &regs, isr);
 		if ((result < 0) || (current->thread.flags & IA64_THREAD_FPEMU_SIGFPE)) {
 			siginfo.si_signo = SIGFPE;
 			siginfo.si_errno = 0;
 			siginfo.si_code = FPE_FLTINV;
-			siginfo.si_addr = (void __user *) (regs->cr_iip + ia64_psr(regs)->ri);
+			siginfo.si_addr = (void __user *) iip;
 			siginfo.si_flags = __ISR_VALID;
 			siginfo.si_isr = isr;
 			siginfo.si_imm = 0;
@@ -554,19 +555,18 @@
 			 * interesting work (e.g., signal delivery is done in the kernel
 			 * exit path).
 			 */
-			ia64_psr(regs)->lp = 0;
+			ia64_psr(&regs)->lp = 0;
 			return;
 		} else {
 			/* Unimplemented Instr. Address Trap */
-			if (user_mode(regs)) {
+			if (user_mode(&regs)) {
 				siginfo.si_signo = SIGILL;
 				siginfo.si_code = ILL_BADIADDR;
 				siginfo.si_errno = 0;
 				siginfo.si_flags = 0;
 				siginfo.si_isr = 0;
 				siginfo.si_imm = 0;
-				siginfo.si_addr = (void __user *)
-					(regs->cr_iip + ia64_psr(regs)->ri);
+				siginfo.si_addr = (void __user *) iip;
 				force_sig_info(SIGILL, &siginfo, current);
 				return;
 			}
@@ -576,23 +576,23 @@
 
 	      case 45:
 #ifdef CONFIG_IA32_SUPPORT
-		if (ia32_exception(regs, isr) == 0)
+		if (ia32_exception(&regs, isr) == 0)
 			return;
 #endif
 		printk(KERN_ERR "Unexpected IA-32 exception (Trap 45)\n");
 		printk(KERN_ERR "  iip - 0x%lx, ifa - 0x%lx, isr - 0x%lx\n",
-		       regs->cr_iip, ifa, isr);
+		       iip, ifa, isr);
 		force_sig(SIGSEGV, current);
 		break;
 
 	      case 46:
 #ifdef CONFIG_IA32_SUPPORT
-		if (ia32_intercept(regs, isr) == 0)
+		if (ia32_intercept(&regs, isr) == 0)
 			return;
 #endif
 		printk(KERN_ERR "Unexpected IA-32 intercept trap (Trap 46)\n");
 		printk(KERN_ERR "  iip - 0x%lx, ifa - 0x%lx, isr - 0x%lx, iim - 0x%lx\n",
-		       regs->cr_iip, ifa, isr, iim);
+		       iip, ifa, isr, iim);
 		force_sig(SIGSEGV, current);
 		return;
 
@@ -604,6 +604,6 @@
 		sprintf(buf, "Fault %lu", vector);
 		break;
 	}
-	die_if_kernel(buf, regs, error);
+	die_if_kernel(buf, &regs, error);
 	force_sig(SIGILL, current);
 }
diff -Nru a/arch/ia64/mm/contig.c b/arch/ia64/mm/contig.c
--- a/arch/ia64/mm/contig.c	2005-01-18 15:21:57 -08:00
+++ b/arch/ia64/mm/contig.c	2005-02-02 12:21:57 -08:00
@@ -178,7 +178,7 @@
 void *
 per_cpu_init (void)
 {
-	void *cpu_data, *mca_data;
+	void *cpu_data;
 	int cpu;
 
 	/*
@@ -189,14 +189,11 @@
 	if (smp_processor_id() == 0) {
 		cpu_data = __alloc_bootmem(PERCPU_PAGE_SIZE * NR_CPUS,
 					   PERCPU_PAGE_SIZE, __pa(MAX_DMA_ADDRESS));
-		mca_data = alloc_bootmem(PERCPU_MCA_SIZE * NR_CPUS);
 		for (cpu = 0; cpu < NR_CPUS; cpu++) {
 			memcpy(cpu_data, __phys_per_cpu_start, __per_cpu_end - __per_cpu_start);
 			__per_cpu_offset[cpu] = (char *) cpu_data - __per_cpu_start;
 			cpu_data += PERCPU_PAGE_SIZE;
 			per_cpu(local_per_cpu_offset, cpu) = __per_cpu_offset[cpu];
-			__per_cpu_mca[cpu] = (unsigned long)__pa(mca_data);
-			mca_data += PERCPU_MCA_SIZE;
 		}
 	}
 	return __per_cpu_start + __per_cpu_offset[smp_processor_id()];
diff -Nru a/arch/ia64/mm/discontig.c b/arch/ia64/mm/discontig.c
--- a/arch/ia64/mm/discontig.c	2005-01-18 12:06:18 -08:00
+++ b/arch/ia64/mm/discontig.c	2005-02-02 12:22:02 -08:00
@@ -26,7 +26,6 @@
 #include <asm/meminit.h>
 #include <asm/numa.h>
 #include <asm/sections.h>
-#include <asm/mca.h>
 
 /*
  * Track per-node information needed to setup the boot memory allocator, the
@@ -294,9 +293,6 @@
  *   |------------------------|
  *   |  local ia64_node_data  |
  *   |------------------------|
- *   |    MCA/INIT data *     |
- *   |    cpus_on_this_node   |
- *   |------------------------|
  *   |          ???           |
  *   |________________________|
  *
@@ -310,7 +306,7 @@
 {
 	unsigned long epfn, cpu, cpus, phys_cpus;
 	unsigned long pernodesize = 0, pernode, pages, mapsize;
-	void *cpu_data, *mca_data_phys;
+	void *cpu_data;
 	struct bootmem_data *bdp = &mem_data[node].bootmem_data;
 
 	epfn = (start + len) >> PAGE_SHIFT;
@@ -339,7 +335,6 @@
 	pernodesize += node * L1_CACHE_BYTES;
 	pernodesize += L1_CACHE_ALIGN(sizeof(pg_data_t));
 	pernodesize += L1_CACHE_ALIGN(sizeof(struct ia64_node_data));
-	pernodesize += L1_CACHE_ALIGN(sizeof(ia64_mca_cpu_t)) * phys_cpus;
 	pernodesize = PAGE_ALIGN(pernodesize);
 	pernode = NODEDATA_ALIGN(start, node);
 
@@ -362,9 +357,6 @@
 		mem_data[node].pgdat->bdata = bdp;
 		pernode += L1_CACHE_ALIGN(sizeof(pg_data_t));
 
-		mca_data_phys = (void *)pernode;
-		pernode += L1_CACHE_ALIGN(sizeof(ia64_mca_cpu_t)) * phys_cpus;
-
 		/*
 		 * Copy the static per-cpu data into the region we
 		 * just set aside and then setup __per_cpu_offset
@@ -374,18 +366,6 @@
 			if (node == node_cpuid[cpu].nid) {
 				memcpy(__va(cpu_data), __phys_per_cpu_start,
 				       __per_cpu_end - __per_cpu_start);
-				if ((cpu == 0) || (node_cpuid[cpu].phys_id > 0)) {
-					/* 
-					 * The memory for the cpuinfo structure is allocated
-					 * here, but the data in the structure is initialized
-					 * later.  Save the physical address of the MCA save
-					 * area in __per_cpu_mca[cpu].  When the cpuinfo struct 
-					 * is initialized, the value in __per_cpu_mca[cpu]
-					 * will be put in the cpuinfo structure.
-					 */
-					__per_cpu_mca[cpu] = __pa(mca_data_phys);
-					mca_data_phys += L1_CACHE_ALIGN(sizeof(ia64_mca_cpu_t));
-				}
 				__per_cpu_offset[cpu] = (char*)__va(cpu_data) -
 					__per_cpu_start;
 				cpu_data += PERCPU_PAGE_SIZE;
diff -Nru a/arch/ia64/mm/init.c b/arch/ia64/mm/init.c
--- a/arch/ia64/mm/init.c	2005-01-18 12:06:18 -08:00
+++ b/arch/ia64/mm/init.c	2005-01-26 10:01:35 -08:00
@@ -40,7 +40,6 @@
 DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
 
 extern void ia64_tlb_init (void);
-extern void efi_get_pal_addr (void);
 
 unsigned long MAX_DMA_ADDRESS = PAGE_OFFSET + 0x100000000UL;
 
@@ -290,27 +289,6 @@
 	put_kernel_page(page, GATE_ADDR + PERCPU_PAGE_SIZE, PAGE_GATE);
 #endif
 	ia64_patch_gate();
-}
-
-void
-set_mca_pointer(struct cpuinfo_ia64 *cpuinfo, void *cpu_data)
-{
-	void *my_cpu_data = ia64_imva(cpu_data);
-
-        /*
-         * The MCA info structure was allocated earlier and a physical address pointer
-         * saved in __per_cpu_mca[cpu].  Move that pointer into the cpuinfo structure.
-         */
-
-        cpuinfo->ia64_pa_mca_data = (__u64 *)__per_cpu_mca[smp_processor_id()];
-
-        cpuinfo->percpu_paddr = pte_val(mk_pte_phys(__pa(my_cpu_data), PAGE_KERNEL));
-        ia64_set_kr(IA64_KR_PA_CPU_INFO, __pa(cpuinfo));
-
-        /*
-         * Set pal_base and pal_paddr in cpuinfo structure.
-         */
-        efi_get_pal_addr();
 }
 
 void __devinit
diff -Nru a/arch/ia64/pci/pci.c b/arch/ia64/pci/pci.c
--- a/arch/ia64/pci/pci.c	2005-01-22 14:42:51 -08:00
+++ b/arch/ia64/pci/pci.c	2005-01-25 13:23:42 -08:00
@@ -71,7 +71,7 @@
 	u64 addr, mode, data = 0;
 	int result = 0;
 
-	if ((seg > 255) || (bus > 255) || (devfn > 255) || (reg > 4095))
+	if ((seg > 65535) || (bus > 255) || (devfn > 255) || (reg > 4095))
 		return -EINVAL;
 
 	if ((seg | reg) <= 255) {
diff -Nru a/arch/ia64/sn/include/shubio.h b/arch/ia64/sn/include/shubio.h
--- a/arch/ia64/sn/include/shubio.h	2004-10-11 13:03:57 -07:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,3476 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1992 - 1997, 2000-2004 Silicon Graphics, Inc. All rights reserved.
- */
-
-#ifndef _ASM_IA64_SN_SHUBIO_H
-#define _ASM_IA64_SN_SHUBIO_H
-
-#define HUB_WIDGET_ID_MAX 0xf
-#define IIO_NUM_ITTES   7
-#define HUB_NUM_BIG_WINDOW      (IIO_NUM_ITTES - 1)
-
-#define    IIO_WID                   0x00400000    /* Crosstalk Widget Identification */
-                                                   /* This register is also accessible from
-                                                    * Crosstalk at address 0x0.  */
-#define    IIO_WSTAT                 0x00400008    /* Crosstalk Widget Status */
-#define    IIO_WCR                   0x00400020    /* Crosstalk Widget Control Register */
-#define    IIO_ILAPR                 0x00400100    /* IO Local Access Protection Register */
-#define    IIO_ILAPO                 0x00400108    /* IO Local Access Protection Override */
-#define    IIO_IOWA                  0x00400110    /* IO Outbound Widget Access */
-#define    IIO_IIWA                  0x00400118    /* IO Inbound Widget Access */
-#define    IIO_IIDEM                 0x00400120    /* IO Inbound Device Error Mask */
-#define    IIO_ILCSR                 0x00400128    /* IO LLP Control and Status Register */
-#define    IIO_ILLR                  0x00400130    /* IO LLP Log Register    */
-#define    IIO_IIDSR                 0x00400138    /* IO Interrupt Destination */
-
-#define    IIO_IGFX0                 0x00400140    /* IO Graphics Node-Widget Map 0 */
-#define    IIO_IGFX1                 0x00400148    /* IO Graphics Node-Widget Map 1 */
-
-#define    IIO_ISCR0                 0x00400150    /* IO Scratch Register 0 */
-#define    IIO_ISCR1                 0x00400158    /* IO Scratch Register 1 */
-
-#define    IIO_ITTE1                 0x00400160    /* IO Translation Table Entry 1 */
-#define    IIO_ITTE2                 0x00400168    /* IO Translation Table Entry 2 */
-#define    IIO_ITTE3                 0x00400170    /* IO Translation Table Entry 3 */
-#define    IIO_ITTE4                 0x00400178    /* IO Translation Table Entry 4 */
-#define    IIO_ITTE5                 0x00400180    /* IO Translation Table Entry 5 */
-#define    IIO_ITTE6                 0x00400188    /* IO Translation Table Entry 6 */
-#define    IIO_ITTE7                 0x00400190    /* IO Translation Table Entry 7 */
-
-#define    IIO_IPRB0                 0x00400198    /* IO PRB Entry 0         */
-#define    IIO_IPRB8                 0x004001A0    /* IO PRB Entry 8         */
-#define    IIO_IPRB9                 0x004001A8    /* IO PRB Entry 9         */
-#define    IIO_IPRBA                 0x004001B0    /* IO PRB Entry A         */
-#define    IIO_IPRBB                 0x004001B8    /* IO PRB Entry B         */
-#define    IIO_IPRBC                 0x004001C0    /* IO PRB Entry C         */
-#define    IIO_IPRBD                 0x004001C8    /* IO PRB Entry D         */
-#define    IIO_IPRBE                 0x004001D0    /* IO PRB Entry E         */
-#define    IIO_IPRBF                 0x004001D8    /* IO PRB Entry F         */
-
-#define    IIO_IXCC                  0x004001E0    /* IO Crosstalk Credit Count Timeout */
-#define    IIO_IMEM                  0x004001E8    /* IO Miscellaneous Error Mask */
-#define    IIO_IXTT                  0x004001F0    /* IO Crosstalk Timeout Threshold */
-#define    IIO_IECLR                 0x004001F8    /* IO Error Clear Register */
-#define    IIO_IBCR                  0x00400200    /* IO BTE Control Register */
-
-#define    IIO_IXSM                  0x00400208    /* IO Crosstalk Spurious Message */
-#define    IIO_IXSS                  0x00400210    /* IO Crosstalk Spurious Sideband */
-
-#define    IIO_ILCT                  0x00400218    /* IO LLP Channel Test    */
-
-#define    IIO_IIEPH1                0x00400220    /* IO Incoming Error Packet Header, Part 1 */
-#define    IIO_IIEPH2                0x00400228    /* IO Incoming Error Packet Header, Part 2 */
-
-
-#define    IIO_ISLAPR                0x00400230    /* IO SXB Local Access Protection Regster */
-#define    IIO_ISLAPO                0x00400238    /* IO SXB Local Access Protection Override */
-
-#define    IIO_IWI                   0x00400240    /* IO Wrapper Interrupt Register */
-#define    IIO_IWEL                  0x00400248    /* IO Wrapper Error Log Register */
-#define    IIO_IWC                   0x00400250    /* IO Wrapper Control Register */
-#define    IIO_IWS                   0x00400258    /* IO Wrapper Status Register */
-#define    IIO_IWEIM                 0x00400260    /* IO Wrapper Error Interrupt Masking Register */
-
-#define    IIO_IPCA                  0x00400300    /* IO PRB Counter Adjust */
-
-#define    IIO_IPRTE0_A              0x00400308    /* IO PIO Read Address Table Entry 0, Part A */
-#define    IIO_IPRTE1_A              0x00400310    /* IO PIO Read Address Table Entry 1, Part A */
-#define    IIO_IPRTE2_A              0x00400318    /* IO PIO Read Address Table Entry 2, Part A */
-#define    IIO_IPRTE3_A               0x00400320    /* IO PIO Read Address Table Entry 3, Part A */
-#define    IIO_IPRTE4_A               0x00400328    /* IO PIO Read Address Table Entry 4, Part A */
-#define    IIO_IPRTE5_A               0x00400330    /* IO PIO Read Address Table Entry 5, Part A */
-#define    IIO_IPRTE6_A               0x00400338    /* IO PIO Read Address Table Entry 6, Part A */
-#define    IIO_IPRTE7_A               0x00400340    /* IO PIO Read Address Table Entry 7, Part A */
-
-#define    IIO_IPRTE0_B              0x00400348    /* IO PIO Read Address Table Entry 0, Part B */
-#define    IIO_IPRTE1_B              0x00400350    /* IO PIO Read Address Table Entry 1, Part B */
-#define    IIO_IPRTE2_B              0x00400358    /* IO PIO Read Address Table Entry 2, Part B */
-#define    IIO_IPRTE3_B               0x00400360    /* IO PIO Read Address Table Entry 3, Part B */
-#define    IIO_IPRTE4_B               0x00400368    /* IO PIO Read Address Table Entry 4, Part B */
-#define    IIO_IPRTE5_B               0x00400370    /* IO PIO Read Address Table Entry 5, Part B */
-#define    IIO_IPRTE6_B               0x00400378    /* IO PIO Read Address Table Entry 6, Part B */
-#define    IIO_IPRTE7_B               0x00400380    /* IO PIO Read Address Table Entry 7, Part B */
-
-#define    IIO_IPDR                  0x00400388    /* IO PIO Deallocation Register */
-#define    IIO_ICDR                  0x00400390    /* IO CRB Entry Deallocation Register */
-#define    IIO_IFDR                  0x00400398    /* IO IOQ FIFO Depth Register */
-#define    IIO_IIAP                  0x004003A0    /* IO IIQ Arbitration Parameters */
-#define    IIO_ICMR                  0x004003A8    /* IO CRB Management Register */
-#define    IIO_ICCR                  0x004003B0    /* IO CRB Control Register */
-#define    IIO_ICTO                  0x004003B8    /* IO CRB Timeout         */
-#define    IIO_ICTP                  0x004003C0    /* IO CRB Timeout Prescalar */
-
-#define    IIO_ICRB0_A               0x00400400    /* IO CRB Entry 0_A       */
-#define    IIO_ICRB0_B               0x00400408    /* IO CRB Entry 0_B       */
-#define    IIO_ICRB0_C               0x00400410    /* IO CRB Entry 0_C       */
-#define    IIO_ICRB0_D               0x00400418    /* IO CRB Entry 0_D       */
-#define    IIO_ICRB0_E               0x00400420    /* IO CRB Entry 0_E       */
-
-#define    IIO_ICRB1_A               0x00400430    /* IO CRB Entry 1_A       */
-#define    IIO_ICRB1_B               0x00400438    /* IO CRB Entry 1_B       */
-#define    IIO_ICRB1_C               0x00400440    /* IO CRB Entry 1_C       */
-#define    IIO_ICRB1_D               0x00400448    /* IO CRB Entry 1_D       */
-#define    IIO_ICRB1_E               0x00400450    /* IO CRB Entry 1_E       */
-
-#define    IIO_ICRB2_A               0x00400460    /* IO CRB Entry 2_A       */
-#define    IIO_ICRB2_B               0x00400468    /* IO CRB Entry 2_B       */
-#define    IIO_ICRB2_C               0x00400470    /* IO CRB Entry 2_C       */
-#define    IIO_ICRB2_D               0x00400478    /* IO CRB Entry 2_D       */
-#define    IIO_ICRB2_E               0x00400480    /* IO CRB Entry 2_E       */
-
-#define    IIO_ICRB3_A               0x00400490    /* IO CRB Entry 3_A       */
-#define    IIO_ICRB3_B               0x00400498    /* IO CRB Entry 3_B       */
-#define    IIO_ICRB3_C               0x004004a0    /* IO CRB Entry 3_C       */
-#define    IIO_ICRB3_D               0x004004a8    /* IO CRB Entry 3_D       */
-#define    IIO_ICRB3_E               0x004004b0    /* IO CRB Entry 3_E       */
-
-#define    IIO_ICRB4_A               0x004004c0    /* IO CRB Entry 4_A       */
-#define    IIO_ICRB4_B               0x004004c8    /* IO CRB Entry 4_B       */
-#define    IIO_ICRB4_C               0x004004d0    /* IO CRB Entry 4_C       */
-#define    IIO_ICRB4_D               0x004004d8    /* IO CRB Entry 4_D       */
-#define    IIO_ICRB4_E               0x004004e0    /* IO CRB Entry 4_E       */
-
-#define    IIO_ICRB5_A               0x004004f0    /* IO CRB Entry 5_A       */
-#define    IIO_ICRB5_B               0x004004f8    /* IO CRB Entry 5_B       */
-#define    IIO_ICRB5_C               0x00400500    /* IO CRB Entry 5_C       */
-#define    IIO_ICRB5_D               0x00400508    /* IO CRB Entry 5_D       */
-#define    IIO_ICRB5_E               0x00400510    /* IO CRB Entry 5_E       */
-
-#define    IIO_ICRB6_A               0x00400520    /* IO CRB Entry 6_A       */
-#define    IIO_ICRB6_B               0x00400528    /* IO CRB Entry 6_B       */
-#define    IIO_ICRB6_C               0x00400530    /* IO CRB Entry 6_C       */
-#define    IIO_ICRB6_D               0x00400538    /* IO CRB Entry 6_D       */
-#define    IIO_ICRB6_E               0x00400540    /* IO CRB Entry 6_E       */
-
-#define    IIO_ICRB7_A               0x00400550    /* IO CRB Entry 7_A       */
-#define    IIO_ICRB7_B               0x00400558    /* IO CRB Entry 7_B       */
-#define    IIO_ICRB7_C               0x00400560    /* IO CRB Entry 7_C       */
-#define    IIO_ICRB7_D               0x00400568    /* IO CRB Entry 7_D       */
-#define    IIO_ICRB7_E               0x00400570    /* IO CRB Entry 7_E       */
-
-#define    IIO_ICRB8_A               0x00400580    /* IO CRB Entry 8_A       */
-#define    IIO_ICRB8_B               0x00400588    /* IO CRB Entry 8_B       */
-#define    IIO_ICRB8_C               0x00400590    /* IO CRB Entry 8_C       */
-#define    IIO_ICRB8_D               0x00400598    /* IO CRB Entry 8_D       */
-#define    IIO_ICRB8_E               0x004005a0    /* IO CRB Entry 8_E       */
-
-#define    IIO_ICRB9_A               0x004005b0    /* IO CRB Entry 9_A       */
-#define    IIO_ICRB9_B               0x004005b8    /* IO CRB Entry 9_B       */
-#define    IIO_ICRB9_C               0x004005c0    /* IO CRB Entry 9_C       */
-#define    IIO_ICRB9_D               0x004005c8    /* IO CRB Entry 9_D       */
-#define    IIO_ICRB9_E               0x004005d0    /* IO CRB Entry 9_E       */
-
-#define    IIO_ICRBA_A               0x004005e0    /* IO CRB Entry A_A       */
-#define    IIO_ICRBA_B               0x004005e8    /* IO CRB Entry A_B       */
-#define    IIO_ICRBA_C               0x004005f0    /* IO CRB Entry A_C       */
-#define    IIO_ICRBA_D               0x004005f8    /* IO CRB Entry A_D       */
-#define    IIO_ICRBA_E               0x00400600    /* IO CRB Entry A_E       */
-
-#define    IIO_ICRBB_A               0x00400610    /* IO CRB Entry B_A       */
-#define    IIO_ICRBB_B               0x00400618    /* IO CRB Entry B_B       */
-#define    IIO_ICRBB_C               0x00400620    /* IO CRB Entry B_C       */
-#define    IIO_ICRBB_D               0x00400628    /* IO CRB Entry B_D       */
-#define    IIO_ICRBB_E               0x00400630    /* IO CRB Entry B_E       */
-
-#define    IIO_ICRBC_A               0x00400640    /* IO CRB Entry C_A       */
-#define    IIO_ICRBC_B               0x00400648    /* IO CRB Entry C_B       */
-#define    IIO_ICRBC_C               0x00400650    /* IO CRB Entry C_C       */
-#define    IIO_ICRBC_D               0x00400658    /* IO CRB Entry C_D       */
-#define    IIO_ICRBC_E               0x00400660    /* IO CRB Entry C_E       */
-
-#define    IIO_ICRBD_A               0x00400670    /* IO CRB Entry D_A       */
-#define    IIO_ICRBD_B               0x00400678    /* IO CRB Entry D_B       */
-#define    IIO_ICRBD_C               0x00400680    /* IO CRB Entry D_C       */
-#define    IIO_ICRBD_D               0x00400688    /* IO CRB Entry D_D       */
-#define    IIO_ICRBD_E               0x00400690    /* IO CRB Entry D_E       */
-
-#define    IIO_ICRBE_A               0x004006a0    /* IO CRB Entry E_A       */
-#define    IIO_ICRBE_B               0x004006a8    /* IO CRB Entry E_B       */
-#define    IIO_ICRBE_C               0x004006b0    /* IO CRB Entry E_C       */
-#define    IIO_ICRBE_D               0x004006b8    /* IO CRB Entry E_D       */
-#define    IIO_ICRBE_E               0x004006c0    /* IO CRB Entry E_E       */
-
-#define    IIO_ICSML                 0x00400700    /* IO CRB Spurious Message Low */
-#define    IIO_ICSMM                 0x00400708    /* IO CRB Spurious Message Middle */
-#define    IIO_ICSMH                 0x00400710    /* IO CRB Spurious Message High */
-
-#define    IIO_IDBSS                 0x00400718    /* IO Debug Submenu Select */
-
-#define    IIO_IBLS0                 0x00410000    /* IO BTE Length Status 0 */
-#define    IIO_IBSA0                 0x00410008    /* IO BTE Source Address 0 */
-#define    IIO_IBDA0                 0x00410010    /* IO BTE Destination Address 0 */
-#define    IIO_IBCT0                 0x00410018    /* IO BTE Control Terminate 0 */
-#define    IIO_IBNA0                 0x00410020    /* IO BTE Notification Address 0 */
-#define    IIO_IBIA0                 0x00410028    /* IO BTE Interrupt Address 0 */
-#define    IIO_IBLS1                 0x00420000    /* IO BTE Length Status 1 */
-#define    IIO_IBSA1                 0x00420008    /* IO BTE Source Address 1 */
-#define    IIO_IBDA1                 0x00420010    /* IO BTE Destination Address 1 */
-#define    IIO_IBCT1                 0x00420018    /* IO BTE Control Terminate 1 */
-#define    IIO_IBNA1                 0x00420020    /* IO BTE Notification Address 1 */
-#define    IIO_IBIA1                 0x00420028    /* IO BTE Interrupt Address 1 */
-
-#define    IIO_IPCR                  0x00430000    /* IO Performance Control */
-#define    IIO_IPPR                  0x00430008    /* IO Performance Profiling */
-
-
-/************************************************************************
- *                                                                      *
- * Description:  This register echoes some information from the         *
- * LB_REV_ID register. It is available through Crosstalk as described   *
- * above. The REV_NUM and MFG_NUM fields receive their values from      *
- * the REVISION and MANUFACTURER fields in the LB_REV_ID register.      *
- * The PART_NUM field's value is the Crosstalk device ID number that    *
- * Steve Miller assigned to the SHub chip.                              *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_wid_u {
-	uint64_t	ii_wid_regval;
-	struct	{
-		uint64_t	w_rsvd_1		  :	 1;
-		uint64_t	w_mfg_num		  :	11;
-		uint64_t	w_part_num		  :	16;
-		uint64_t	w_rev_num		  :	 4;
-		uint64_t	w_rsvd			  :	32;
-	} ii_wid_fld_s;
-} ii_wid_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  The fields in this register are set upon detection of an error      *
- * and cleared by various mechanisms, as explained in the               *
- * description.                                                         *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_wstat_u {
-	uint64_t	ii_wstat_regval;
-	struct	{
-		uint64_t	w_pending		  :	 4;
-		uint64_t	w_xt_crd_to		  :	 1;
-		uint64_t	w_xt_tail_to		  :	 1;
-		uint64_t	w_rsvd_3		  :	 3;
-		uint64_t       w_tx_mx_rty               :      1;
-		uint64_t	w_rsvd_2		  :	 6;
-		uint64_t	w_llp_tx_cnt		  :	 8;
-		uint64_t	w_rsvd_1		  :	 8;
-		uint64_t	w_crazy			  :	 1;
-		uint64_t	w_rsvd			  :	31;
-	} ii_wstat_fld_s;
-} ii_wstat_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  This is a read-write enabled register. It controls     *
- * various aspects of the Crosstalk flow control.                       *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_wcr_u {
-	uint64_t	ii_wcr_regval;
-	struct	{
-		uint64_t	w_wid			  :	 4;
-		uint64_t	w_tag			  :	 1;
-		uint64_t	w_rsvd_1		  :	 8;
-		uint64_t	w_dst_crd		  :	 3;
-		uint64_t	w_f_bad_pkt		  :	 1;
-		uint64_t	w_dir_con		  :	 1;
-		uint64_t	w_e_thresh		  :	 5;
-		uint64_t	w_rsvd			  :	41;
-	} ii_wcr_fld_s;
-} ii_wcr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  This register's value is a bit vector that guards      *
- * access to local registers within the II as well as to external       *
- * Crosstalk widgets. Each bit in the register corresponds to a         *
- * particular region in the system; a region consists of one, two or    *
- * four nodes (depending on the value of the REGION_SIZE field in the   *
- * LB_REV_ID register, which is documented in Section 8.3.1.1). The     *
- * protection provided by this register applies to PIO read             *
- * operations as well as PIO write operations. The II will perform a    *
- * PIO read or write request only if the bit for the requestor's        *
- * region is set; otherwise, the II will not perform the requested      *
- * operation and will return an error response. When a PIO read or      *
- * write request targets an external Crosstalk widget, then not only    *
- * must the bit for the requestor's region be set in the ILAPR, but     *
- * also the target widget's bit in the IOWA register must be set in     *
- * order for the II to perform the requested operation; otherwise,      *
- * the II will return an error response. Hence, the protection          *
- * provided by the IOWA register supplements the protection provided    *
- * by the ILAPR for requests that target external Crosstalk widgets.    *
- * This register itself can be accessed only by the nodes whose         *
- * region ID bits are enabled in this same register. It can also be     *
- * accessed through the IAlias space by the local processors.           *
- * The reset value of this register allows access by all nodes.         *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ilapr_u {
-	uint64_t	ii_ilapr_regval;
-	struct  {
-		uint64_t	i_region                  :	64;
-	} ii_ilapr_fld_s;
-} ii_ilapr_u_t;
-
-
-
-
-/************************************************************************
- *                                                                      *
- * Description:  A write to this register of the 64-bit value           *
- * "SGIrules" in ASCII, will cause the bit in the ILAPR register        *
- * corresponding to the region of the requestor to be set (allow        *
- * access). A write of any other value will be ignored. Access          *
- * protection for this register is "SGIrules".                          *
- * This register can also be accessed through the IAlias space.         *
- * However, this access will not change the access permissions in the   *
- * ILAPR.                                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ilapo_u {
-	uint64_t	ii_ilapo_regval;
-	struct	{
-		uint64_t	i_io_ovrride            :	64;
-	} ii_ilapo_fld_s;
-} ii_ilapo_u_t;
-
-
-
-/************************************************************************
- *                                                                      *
- *  This register qualifies all the PIO and Graphics writes launched    *
- * from the SHUB towards a widget.                                      *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iowa_u {
-	uint64_t	ii_iowa_regval;
-	struct	{
-		uint64_t	i_w0_oac		  :	 1;
-		uint64_t	i_rsvd_1		  :	 7;
-                uint64_t       i_wx_oac                  :      8;
-		uint64_t	i_rsvd			  :	48;
-	} ii_iowa_fld_s;
-} ii_iowa_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  This register qualifies all the requests launched      *
- * from a widget towards the Shub. This register is intended to be      *
- * used by software in case of misbehaving widgets.                     *
- *                                                                      *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iiwa_u {
-	uint64_t	ii_iiwa_regval;
-	struct  {
-		uint64_t	i_w0_iac                  :	 1;
-		uint64_t	i_rsvd_1		  :	 7;
-		uint64_t	i_wx_iac		  :	 8;
-		uint64_t	i_rsvd			  :	48;
-	} ii_iiwa_fld_s;
-} ii_iiwa_u_t;
-
-
-
-/************************************************************************
- *                                                                      *
- * Description:  This register qualifies all the operations launched    *
- * from a widget towards the SHub. It allows individual access          *
- * control for up to 8 devices per widget. A device refers to           *
- * individual DMA master hosted by a widget.                            *
- * The bits in each field of this register are cleared by the Shub      *
- * upon detection of an error which requires the device to be           *
- * disabled. These fields assume that 0=TNUM=7 (i.e., Bridge-centric    *
- * Crosstalk). Whether or not a device has access rights to this        *
- * Shub is determined by an AND of the device enable bit in the         *
- * appropriate field of this register and the corresponding bit in      *
- * the Wx_IAC field (for the widget which this device belongs to).      *
- * The bits in this field are set by writing a 1 to them. Incoming      *
- * replies from Crosstalk are not subject to this access control        *
- * mechanism.                                                           *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iidem_u {
-	uint64_t	ii_iidem_regval;
-	struct	{
-		uint64_t	i_w8_dxs		  :	 8;
-		uint64_t	i_w9_dxs		  :	 8;
-		uint64_t	i_wa_dxs		  :	 8;
-		uint64_t	i_wb_dxs		  :	 8;
-		uint64_t	i_wc_dxs		  :	 8;
-		uint64_t	i_wd_dxs		  :	 8;
-		uint64_t	i_we_dxs		  :	 8;
-		uint64_t	i_wf_dxs		  :	 8;
-	} ii_iidem_fld_s;
-} ii_iidem_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the various programmable fields necessary    *
- * for controlling and observing the LLP signals.                       *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ilcsr_u {
-	uint64_t	ii_ilcsr_regval;
-	struct  {
-		uint64_t	i_nullto                  :	 6;
-		uint64_t	i_rsvd_4		  :	 2;
-		uint64_t	i_wrmrst		  :	 1;
-		uint64_t	i_rsvd_3		  :	 1;
-		uint64_t	i_llp_en		  :	 1;
-		uint64_t	i_bm8			  :	 1;
-		uint64_t	i_llp_stat		  :	 2;
-		uint64_t	i_remote_power		  :	 1;
-		uint64_t	i_rsvd_2		  :	 1;
-		uint64_t	i_maxrtry		  :	10;
-		uint64_t	i_d_avail_sel		  :	 2;
-		uint64_t	i_rsvd_1		  :	 4;
-		uint64_t	i_maxbrst		  :	10;
-                uint64_t       i_rsvd                    :     22;
-
-	} ii_ilcsr_fld_s;
-} ii_ilcsr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This is simply a status registers that monitors the LLP error       *
- * rate.                                                                *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_illr_u {
-	uint64_t	ii_illr_regval;
-	struct	{
-		uint64_t	i_sn_cnt		  :	16;
-		uint64_t	i_cb_cnt		  :	16;
-		uint64_t	i_rsvd			  :	32;
-	} ii_illr_fld_s;
-} ii_illr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  All II-detected non-BTE error interrupts are           *
- * specified via this register.                                         *
- * NOTE: The PI interrupt register address is hardcoded in the II. If   *
- * PI_ID==0, then the II sends an interrupt request (Duplonet PWRI      *
- * packet) to address offset 0x0180_0090 within the local register      *
- * address space of PI0 on the node specified by the NODE field. If     *
- * PI_ID==1, then the II sends the interrupt request to address         *
- * offset 0x01A0_0090 within the local register address space of PI1    *
- * on the node specified by the NODE field.                             *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iidsr_u {
-	uint64_t	ii_iidsr_regval;
-	struct  {
-		uint64_t	i_level                   :	 8;
-		uint64_t	i_pi_id			  :	 1;
-		uint64_t	i_node			  :	11;
-		uint64_t       i_rsvd_3                  :      4;
-		uint64_t	i_enable		  :	 1;
-		uint64_t	i_rsvd_2		  :	 3;
-		uint64_t	i_int_sent		  :	 2;
-		uint64_t       i_rsvd_1                  :      2;
-		uint64_t	i_pi0_forward_int	  :	 1;
-		uint64_t	i_pi1_forward_int	  :	 1;
-		uint64_t	i_rsvd			  :	30;
-	} ii_iidsr_fld_s;
-} ii_iidsr_u_t;
-
-
-
-/************************************************************************
- *                                                                      *
- *  There are two instances of this register. This register is used     *
- * for matching up the incoming responses from the graphics widget to   *
- * the processor that initiated the graphics operation. The             *
- * write-responses are converted to graphics credits and returned to    *
- * the processor so that the processor interface can manage the flow    *
- * control.                                                             *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_igfx0_u {
-	uint64_t	ii_igfx0_regval;
-	struct	{
-		uint64_t	i_w_num			  :	 4;
-		uint64_t       i_pi_id                   :      1;
-		uint64_t	i_n_num			  :	12;
-		uint64_t       i_p_num                   :      1;
-		uint64_t       i_rsvd                    :     46;
-	} ii_igfx0_fld_s;
-} ii_igfx0_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are two instances of this register. This register is used     *
- * for matching up the incoming responses from the graphics widget to   *
- * the processor that initiated the graphics operation. The             *
- * write-responses are converted to graphics credits and returned to    *
- * the processor so that the processor interface can manage the flow    *
- * control.                                                             *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_igfx1_u {
-	uint64_t	ii_igfx1_regval;
-	struct  {
-		uint64_t	i_w_num			  :	 4;
-		uint64_t       i_pi_id                   :      1;
-		uint64_t	i_n_num			  :	12;
-		uint64_t       i_p_num                   :      1;
-		uint64_t       i_rsvd                    :     46;
-	} ii_igfx1_fld_s;
-} ii_igfx1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are two instances of this registers. These registers are      *
- * used as scratch registers for software use.                          *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iscr0_u {
-	uint64_t	ii_iscr0_regval;
-	struct  {
-		uint64_t	i_scratch                 :	64;
-	} ii_iscr0_fld_s;
-} ii_iscr0_u_t;
-
-
-
-/************************************************************************
- *                                                                      *
- *  There are two instances of this registers. These registers are      *
- * used as scratch registers for software use.                          *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iscr1_u {
-	uint64_t	ii_iscr1_regval;
-	struct  {
-		uint64_t	i_scratch                 :	64;
-	} ii_iscr1_fld_s;
-} ii_iscr1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are seven instances of translation table entry   *
- * registers. Each register maps a Shub Big Window to a 48-bit          *
- * address on Crosstalk.                                                *
- * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
- * number) are used to select one of these 7 registers. The Widget      *
- * number field is then derived from the W_NUM field for synthesizing   *
- * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
- * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
- * are padded with zeros. Although the maximum Crosstalk space          *
- * addressable by the SHub is thus the lower 16 GBytes per widget       * 
- * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
- * space can be accessed.                                               *
- * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
- * Window number) are used to select one of these 7 registers. The      *
- * Widget number field is then derived from the W_NUM field for         *
- * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
- * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
- * field is used as Crosstalk[47], and remainder of the Crosstalk       *
- * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
- * Crosstalk space addressable by the Shub is thus the lower            *
- * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
- * of this space can be accessed.                                       *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_itte1_u {
-	uint64_t	ii_itte1_regval;
-	struct  {
-		uint64_t	i_offset                  :	 5;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t	i_w_num			  :	 4;
-		uint64_t	i_iosp			  :	 1;
-		uint64_t	i_rsvd			  :	51;
-	} ii_itte1_fld_s;
-} ii_itte1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are seven instances of translation table entry   *
- * registers. Each register maps a Shub Big Window to a 48-bit          *
- * address on Crosstalk.                                                *
- * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
- * number) are used to select one of these 7 registers. The Widget      *
- * number field is then derived from the W_NUM field for synthesizing   *
- * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
- * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
- * are padded with zeros. Although the maximum Crosstalk space          *
- * addressable by the Shub is thus the lower 16 GBytes per widget       *
- * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
- * space can be accessed.                                               *
- * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
- * Window number) are used to select one of these 7 registers. The      *
- * Widget number field is then derived from the W_NUM field for         *
- * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
- * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
- * field is used as Crosstalk[47], and remainder of the Crosstalk       *
- * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
- * Crosstalk space addressable by the Shub is thus the lower            *
- * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
- * of this space can be accessed.                                       *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_itte2_u {
-	uint64_t	ii_itte2_regval;
-	struct	{
-		uint64_t	i_offset		  :	 5;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t	i_w_num			  :	 4;
-		uint64_t	i_iosp			  :	 1;
-		uint64_t       i_rsvd                    :     51;
-	} ii_itte2_fld_s;
-} ii_itte2_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are seven instances of translation table entry   *
- * registers. Each register maps a Shub Big Window to a 48-bit          *
- * address on Crosstalk.                                                *
- * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
- * number) are used to select one of these 7 registers. The Widget      *
- * number field is then derived from the W_NUM field for synthesizing   *
- * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
- * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
- * are padded with zeros. Although the maximum Crosstalk space          *
- * addressable by the Shub is thus the lower 16 GBytes per widget       *
- * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
- * space can be accessed.                                               *
- * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
- * Window number) are used to select one of these 7 registers. The      *
- * Widget number field is then derived from the W_NUM field for         *
- * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
- * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
- * field is used as Crosstalk[47], and remainder of the Crosstalk       *
- * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
- * Crosstalk space addressable by the SHub is thus the lower            *
- * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
- * of this space can be accessed.                                       *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_itte3_u {
-	uint64_t	ii_itte3_regval;
-	struct  {
-		uint64_t	i_offset                  :	 5;
-		uint64_t       i_rsvd_1                  :      3;
-		uint64_t       i_w_num                   :      4;
-		uint64_t       i_iosp                    :      1;
-		uint64_t       i_rsvd                    :     51;
-	} ii_itte3_fld_s;
-} ii_itte3_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are seven instances of translation table entry   *
- * registers. Each register maps a SHub Big Window to a 48-bit          *
- * address on Crosstalk.                                                *
- * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
- * number) are used to select one of these 7 registers. The Widget      *
- * number field is then derived from the W_NUM field for synthesizing   *
- * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
- * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
- * are padded with zeros. Although the maximum Crosstalk space          *
- * addressable by the SHub is thus the lower 16 GBytes per widget       *
- * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
- * space can be accessed.                                               *
- * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
- * Window number) are used to select one of these 7 registers. The      *
- * Widget number field is then derived from the W_NUM field for         *
- * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
- * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
- * field is used as Crosstalk[47], and remainder of the Crosstalk       *
- * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
- * Crosstalk space addressable by the SHub is thus the lower            *
- * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
- * of this space can be accessed.                                       *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_itte4_u {
-	uint64_t	ii_itte4_regval;
-	struct  {
-		uint64_t	i_offset                  :	 5;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t       i_w_num                   :      4;
-		uint64_t       i_iosp                    :      1;
-		uint64_t       i_rsvd                    :     51;
-	} ii_itte4_fld_s;
-} ii_itte4_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are seven instances of translation table entry   *
- * registers. Each register maps a SHub Big Window to a 48-bit          *
- * address on Crosstalk.                                                *
- * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
- * number) are used to select one of these 7 registers. The Widget      *
- * number field is then derived from the W_NUM field for synthesizing   *
- * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
- * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
- * are padded with zeros. Although the maximum Crosstalk space          *
- * addressable by the Shub is thus the lower 16 GBytes per widget       *
- * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
- * space can be accessed.                                               *
- * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
- * Window number) are used to select one of these 7 registers. The      *
- * Widget number field is then derived from the W_NUM field for         *
- * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
- * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
- * field is used as Crosstalk[47], and remainder of the Crosstalk       *
- * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
- * Crosstalk space addressable by the Shub is thus the lower            *
- * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
- * of this space can be accessed.                                       *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_itte5_u {
-	uint64_t	ii_itte5_regval;
-	struct  {
-		uint64_t	i_offset                  :	 5;
-		uint64_t       i_rsvd_1                  :      3;
-		uint64_t       i_w_num                   :      4;
-		uint64_t       i_iosp                    :      1;
-		uint64_t       i_rsvd                    :     51;
-	} ii_itte5_fld_s;
-} ii_itte5_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are seven instances of translation table entry   *
- * registers. Each register maps a Shub Big Window to a 48-bit          *
- * address on Crosstalk.                                                *
- * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
- * number) are used to select one of these 7 registers. The Widget      *
- * number field is then derived from the W_NUM field for synthesizing   *
- * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
- * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
- * are padded with zeros. Although the maximum Crosstalk space          *
- * addressable by the Shub is thus the lower 16 GBytes per widget       *
- * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
- * space can be accessed.                                               *
- * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
- * Window number) are used to select one of these 7 registers. The      *
- * Widget number field is then derived from the W_NUM field for         *
- * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
- * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
- * field is used as Crosstalk[47], and remainder of the Crosstalk       *
- * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
- * Crosstalk space addressable by the Shub is thus the lower            *
- * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
- * of this space can be accessed.                                       *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_itte6_u {
-	uint64_t	ii_itte6_regval;
-	struct  {
-		uint64_t	i_offset                  :	 5;
-		uint64_t       i_rsvd_1                  :      3;
-		uint64_t       i_w_num                   :      4;
-		uint64_t       i_iosp                    :      1;
-		uint64_t       i_rsvd                    :     51;
-	} ii_itte6_fld_s;
-} ii_itte6_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are seven instances of translation table entry   *
- * registers. Each register maps a Shub Big Window to a 48-bit          *
- * address on Crosstalk.                                                *
- * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
- * number) are used to select one of these 7 registers. The Widget      *
- * number field is then derived from the W_NUM field for synthesizing   *
- * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
- * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
- * are padded with zeros. Although the maximum Crosstalk space          *
- * addressable by the Shub is thus the lower 16 GBytes per widget       *
- * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
- * space can be accessed.                                               *
- * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
- * Window number) are used to select one of these 7 registers. The      *
- * Widget number field is then derived from the W_NUM field for         *
- * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
- * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
- * field is used as Crosstalk[47], and remainder of the Crosstalk       *
- * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
- * Crosstalk space addressable by the SHub is thus the lower            *
- * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
- * of this space can be accessed.                                       *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_itte7_u {
-	uint64_t	ii_itte7_regval;
-	struct  {
-		uint64_t	i_offset                  :	 5;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t       i_w_num                   :      4;
-		uint64_t       i_iosp                    :      1;
-		uint64_t       i_rsvd                    :     51;
-	} ii_itte7_fld_s;
-} ii_itte7_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 9 instances of this register, one per        *
- * actual widget in this implementation of SHub and Crossbow.           *
- * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
- * refers to Crossbow's internal space.                                 *
- * This register contains the state elements per widget that are        *
- * necessary to manage the PIO flow control on Crosstalk and on the     *
- * Router Network. See the PIO Flow Control chapter for a complete      *
- * description of this register                                         *
- * The SPUR_WR bit requires some explanation. When this register is     *
- * written, the new value of the C field is captured in an internal     *
- * register so the hardware can remember what the programmer wrote      *
- * into the credit counter. The SPUR_WR bit sets whenever the C field   *
- * increments above this stored value, which indicates that there       *
- * have been more responses received than requests sent. The SPUR_WR    *
- * bit cannot be cleared until a value is written to the IPRBx          *
- * register; the write will correct the C field and capture its new     *
- * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
- * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
- * .                                                                    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprb0_u {
-	uint64_t	ii_iprb0_regval;
-	struct  {
-		uint64_t	i_c                       :	 8;
-		uint64_t	i_na			  :	14;
-		uint64_t       i_rsvd_2                  :      2;
-		uint64_t	i_nb			  :	14;
-		uint64_t	i_rsvd_1		  :	 2;
-		uint64_t	i_m			  :	 2;
-		uint64_t	i_f			  :	 1;
-		uint64_t	i_of_cnt		  :	 5;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_rd_to			  :	 1;
-		uint64_t	i_spur_wr		  :	 1;
-		uint64_t	i_spur_rd		  :	 1;
-		uint64_t	i_rsvd			  :	11;
-		uint64_t	i_mult_err		  :	 1;
-	} ii_iprb0_fld_s;
-} ii_iprb0_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 9 instances of this register, one per        *
- * actual widget in this implementation of SHub and Crossbow.           *
- * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
- * refers to Crossbow's internal space.                                 *
- * This register contains the state elements per widget that are        *
- * necessary to manage the PIO flow control on Crosstalk and on the     *
- * Router Network. See the PIO Flow Control chapter for a complete      *
- * description of this register                                         *
- * The SPUR_WR bit requires some explanation. When this register is     *
- * written, the new value of the C field is captured in an internal     *
- * register so the hardware can remember what the programmer wrote      *
- * into the credit counter. The SPUR_WR bit sets whenever the C field   *
- * increments above this stored value, which indicates that there       *
- * have been more responses received than requests sent. The SPUR_WR    *
- * bit cannot be cleared until a value is written to the IPRBx          *
- * register; the write will correct the C field and capture its new     *
- * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
- * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
- * .                                                                    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprb8_u {
-	uint64_t	ii_iprb8_regval;
-	struct  {
-		uint64_t	i_c                       :	 8;
-		uint64_t	i_na			  :	14;
-		uint64_t       i_rsvd_2                  :      2;
-		uint64_t	i_nb			  :	14;
-		uint64_t       i_rsvd_1                  :      2;
-		uint64_t       i_m                       :      2;
-		uint64_t       i_f                       :      1;
-		uint64_t       i_of_cnt                  :      5;
-		uint64_t       i_error                   :      1;
-		uint64_t       i_rd_to                   :      1;
-		uint64_t       i_spur_wr                 :      1;
-		uint64_t	i_spur_rd		  :	 1;
-		uint64_t       i_rsvd                    :     11;
-		uint64_t	i_mult_err		  :	 1;
-	} ii_iprb8_fld_s;
-} ii_iprb8_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 9 instances of this register, one per        *
- * actual widget in this implementation of SHub and Crossbow.           *
- * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
- * refers to Crossbow's internal space.                                 *
- * This register contains the state elements per widget that are        *
- * necessary to manage the PIO flow control on Crosstalk and on the     *
- * Router Network. See the PIO Flow Control chapter for a complete      *
- * description of this register                                         *
- * The SPUR_WR bit requires some explanation. When this register is     *
- * written, the new value of the C field is captured in an internal     *
- * register so the hardware can remember what the programmer wrote      *
- * into the credit counter. The SPUR_WR bit sets whenever the C field   *
- * increments above this stored value, which indicates that there       *
- * have been more responses received than requests sent. The SPUR_WR    *
- * bit cannot be cleared until a value is written to the IPRBx          *
- * register; the write will correct the C field and capture its new     *
- * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
- * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
- * .                                                                    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprb9_u {
-	uint64_t	ii_iprb9_regval;
-	struct	{
-		uint64_t	i_c			  :	 8;
-		uint64_t	i_na			  :	14;
-		uint64_t	i_rsvd_2		  :	 2;
-		uint64_t	i_nb			  :	14;
-		uint64_t	i_rsvd_1		  :	 2;
-		uint64_t	i_m			  :	 2;
-		uint64_t	i_f			  :	 1;
-		uint64_t	i_of_cnt		  :	 5;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_rd_to			  :	 1;
-		uint64_t	i_spur_wr		  :	 1;
-		uint64_t	i_spur_rd		  :	 1;
-		uint64_t	i_rsvd			  :	11;
-		uint64_t	i_mult_err		  :	 1;
-	} ii_iprb9_fld_s;
-} ii_iprb9_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 9 instances of this register, one per        *
- * actual widget in this implementation of SHub and Crossbow.        *
- * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
- * refers to Crossbow's internal space.                                 *
- * This register contains the state elements per widget that are        *
- * necessary to manage the PIO flow control on Crosstalk and on the     *
- * Router Network. See the PIO Flow Control chapter for a complete      *
- * description of this register                                         *
- * The SPUR_WR bit requires some explanation. When this register is     *
- * written, the new value of the C field is captured in an internal     *
- * register so the hardware can remember what the programmer wrote      *
- * into the credit counter. The SPUR_WR bit sets whenever the C field   *
- * increments above this stored value, which indicates that there       *
- * have been more responses received than requests sent. The SPUR_WR    *
- * bit cannot be cleared until a value is written to the IPRBx          *
- * register; the write will correct the C field and capture its new     *
- * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
- * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
- *                                                                      *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprba_u {
-	uint64_t	ii_iprba_regval;
-	struct  {
-		uint64_t	i_c                       :	 8;
-		uint64_t	i_na			  :	14;
-		uint64_t       i_rsvd_2                  :      2;
-		uint64_t	i_nb			  :	14;
-		uint64_t	i_rsvd_1		  :	 2;
-		uint64_t	i_m			  :	 2;
-		uint64_t	i_f			  :	 1;
-		uint64_t	i_of_cnt		  :	 5;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_rd_to			  :	 1;
-		uint64_t	i_spur_wr		  :	 1;
-		uint64_t	i_spur_rd		  :	 1;
-		uint64_t	i_rsvd			  :	11;
-		uint64_t	i_mult_err		  :	 1;
-	} ii_iprba_fld_s;
-} ii_iprba_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 9 instances of this register, one per        *
- * actual widget in this implementation of SHub and Crossbow.           *
- * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
- * refers to Crossbow's internal space.                                 *
- * This register contains the state elements per widget that are        *
- * necessary to manage the PIO flow control on Crosstalk and on the     *
- * Router Network. See the PIO Flow Control chapter for a complete      *
- * description of this register                                         *
- * The SPUR_WR bit requires some explanation. When this register is     *
- * written, the new value of the C field is captured in an internal     *
- * register so the hardware can remember what the programmer wrote      *
- * into the credit counter. The SPUR_WR bit sets whenever the C field   *
- * increments above this stored value, which indicates that there       *
- * have been more responses received than requests sent. The SPUR_WR    *
- * bit cannot be cleared until a value is written to the IPRBx          *
- * register; the write will correct the C field and capture its new     *
- * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
- * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
- * .                                                                    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprbb_u {
-	uint64_t	ii_iprbb_regval;
-	struct	{
-		uint64_t	i_c			  :	 8;
-		uint64_t	i_na			  :	14;
-		uint64_t	i_rsvd_2		  :	 2;
-		uint64_t	i_nb			  :	14;
-		uint64_t	i_rsvd_1		  :	 2;
-		uint64_t	i_m			  :	 2;
-		uint64_t	i_f			  :	 1;
-		uint64_t	i_of_cnt		  :	 5;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_rd_to			  :	 1;
-		uint64_t	i_spur_wr		  :	 1;
-		uint64_t	i_spur_rd		  :	 1;
-		uint64_t	i_rsvd			  :	11;
-		uint64_t	i_mult_err		  :	 1;
-	} ii_iprbb_fld_s;
-} ii_iprbb_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 9 instances of this register, one per        *
- * actual widget in this implementation of SHub and Crossbow.           *
- * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
- * refers to Crossbow's internal space.                                 *
- * This register contains the state elements per widget that are        *
- * necessary to manage the PIO flow control on Crosstalk and on the     *
- * Router Network. See the PIO Flow Control chapter for a complete      *
- * description of this register                                         *
- * The SPUR_WR bit requires some explanation. When this register is     *
- * written, the new value of the C field is captured in an internal     *
- * register so the hardware can remember what the programmer wrote      *
- * into the credit counter. The SPUR_WR bit sets whenever the C field   *
- * increments above this stored value, which indicates that there       *
- * have been more responses received than requests sent. The SPUR_WR    *
- * bit cannot be cleared until a value is written to the IPRBx          *
- * register; the write will correct the C field and capture its new     *
- * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
- * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
- * .                                                                    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprbc_u {
-	uint64_t	ii_iprbc_regval;
-	struct	{
-		uint64_t	i_c			  :	 8;
-		uint64_t	i_na			  :	14;
-		uint64_t	i_rsvd_2		  :	 2;
-		uint64_t	i_nb			  :	14;
-		uint64_t	i_rsvd_1		  :	 2;
-		uint64_t	i_m			  :	 2;
-		uint64_t	i_f			  :	 1;
-		uint64_t	i_of_cnt		  :	 5;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_rd_to			  :	 1;
-		uint64_t	i_spur_wr		  :	 1;
-		uint64_t	i_spur_rd		  :	 1;
-		uint64_t	i_rsvd			  :	11;
-		uint64_t	i_mult_err		  :	 1;
-	} ii_iprbc_fld_s;
-} ii_iprbc_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 9 instances of this register, one per        *
- * actual widget in this implementation of SHub and Crossbow.           *
- * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
- * refers to Crossbow's internal space.                                 *
- * This register contains the state elements per widget that are        *
- * necessary to manage the PIO flow control on Crosstalk and on the     *
- * Router Network. See the PIO Flow Control chapter for a complete      *
- * description of this register                                         *
- * The SPUR_WR bit requires some explanation. When this register is     *
- * written, the new value of the C field is captured in an internal     *
- * register so the hardware can remember what the programmer wrote      *
- * into the credit counter. The SPUR_WR bit sets whenever the C field   *
- * increments above this stored value, which indicates that there       *
- * have been more responses received than requests sent. The SPUR_WR    *
- * bit cannot be cleared until a value is written to the IPRBx          *
- * register; the write will correct the C field and capture its new     *
- * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
- * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
- * .                                                                    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprbd_u {
-	uint64_t	ii_iprbd_regval;
-	struct	{
-		uint64_t	i_c			  :	 8;
-		uint64_t	i_na			  :	14;
-		uint64_t	i_rsvd_2		  :	 2;
-		uint64_t	i_nb			  :	14;
-		uint64_t	i_rsvd_1		  :	 2;
-		uint64_t	i_m			  :	 2;
-		uint64_t	i_f			  :	 1;
-		uint64_t	i_of_cnt		  :	 5;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_rd_to			  :	 1;
-		uint64_t	i_spur_wr		  :	 1;
-		uint64_t	i_spur_rd		  :	 1;
-		uint64_t	i_rsvd			  :	11;
-		uint64_t	i_mult_err		  :	 1;
-	} ii_iprbd_fld_s;
-} ii_iprbd_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 9 instances of this register, one per        *
- * actual widget in this implementation of SHub and Crossbow.           *
- * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
- * refers to Crossbow's internal space.                                 *
- * This register contains the state elements per widget that are        *
- * necessary to manage the PIO flow control on Crosstalk and on the     *
- * Router Network. See the PIO Flow Control chapter for a complete      *
- * description of this register                                         *
- * The SPUR_WR bit requires some explanation. When this register is     *
- * written, the new value of the C field is captured in an internal     *
- * register so the hardware can remember what the programmer wrote      *
- * into the credit counter. The SPUR_WR bit sets whenever the C field   *
- * increments above this stored value, which indicates that there       *
- * have been more responses received than requests sent. The SPUR_WR    *
- * bit cannot be cleared until a value is written to the IPRBx          *
- * register; the write will correct the C field and capture its new     *
- * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
- * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
- * .                                                                    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprbe_u {
-	uint64_t	ii_iprbe_regval;
-	struct	{
-		uint64_t	i_c			  :	 8;
-		uint64_t	i_na			  :	14;
-		uint64_t	i_rsvd_2		  :	 2;
-		uint64_t	i_nb			  :	14;
-		uint64_t	i_rsvd_1		  :	 2;
-		uint64_t	i_m			  :	 2;
-		uint64_t	i_f			  :	 1;
-		uint64_t	i_of_cnt		  :	 5;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_rd_to			  :	 1;
-		uint64_t	i_spur_wr		  :	 1;
-		uint64_t	i_spur_rd		  :	 1;
-		uint64_t	i_rsvd			  :	11;
-		uint64_t	i_mult_err		  :	 1;
-	} ii_iprbe_fld_s;
-} ii_iprbe_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 9 instances of this register, one per        *
- * actual widget in this implementation of Shub and Crossbow.           *
- * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
- * refers to Crossbow's internal space.                                 *
- * This register contains the state elements per widget that are        *
- * necessary to manage the PIO flow control on Crosstalk and on the     *
- * Router Network. See the PIO Flow Control chapter for a complete      *
- * description of this register                                         *
- * The SPUR_WR bit requires some explanation. When this register is     *
- * written, the new value of the C field is captured in an internal     *
- * register so the hardware can remember what the programmer wrote      *
- * into the credit counter. The SPUR_WR bit sets whenever the C field   *
- * increments above this stored value, which indicates that there       *
- * have been more responses received than requests sent. The SPUR_WR    *
- * bit cannot be cleared until a value is written to the IPRBx          *
- * register; the write will correct the C field and capture its new     *
- * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
- * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
- * .                                                                    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprbf_u {
-        uint64_t       ii_iprbf_regval;
-        struct  {
-                uint64_t       i_c                       :      8;
-                uint64_t       i_na                      :     14;
-                uint64_t       i_rsvd_2                  :      2;
-                uint64_t       i_nb                      :     14;
-                uint64_t       i_rsvd_1                  :      2;
-                uint64_t       i_m                       :      2;
-                uint64_t       i_f                       :      1;
-                uint64_t       i_of_cnt                  :      5;
-                uint64_t       i_error                   :      1;
-                uint64_t       i_rd_to                   :      1;
-                uint64_t       i_spur_wr                 :      1;
-                uint64_t       i_spur_rd                 :      1;
-                uint64_t       i_rsvd                    :     11;
-                uint64_t       i_mult_err                :      1;
-        } ii_iprbe_fld_s;
-} ii_iprbf_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register specifies the timeout value to use for monitoring     *
- * Crosstalk credits which are used outbound to Crosstalk. An           *
- * internal counter called the Crosstalk Credit Timeout Counter         *
- * increments every 128 II clocks. The counter starts counting          *
- * anytime the credit count drops below a threshold, and resets to      *
- * zero (stops counting) anytime the credit count is at or above the    *
- * threshold. The threshold is 1 credit in direct connect mode and 2    *
- * in Crossbow connect mode. When the internal Crosstalk Credit         *
- * Timeout Counter reaches the value programmed in this register, a     *
- * Crosstalk Credit Timeout has occurred. The internal counter is not   *
- * readable from software, and stops counting at its maximum value,     *
- * so it cannot cause more than one interrupt.                          *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ixcc_u {
-	uint64_t	ii_ixcc_regval;
-	struct  {
-		uint64_t	i_time_out                :	26;
-		uint64_t	i_rsvd			  :	38;
-	} ii_ixcc_fld_s;
-} ii_ixcc_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  This register qualifies all the PIO and DMA            *
- * operations launched from widget 0 towards the SHub. In               *
- * addition, it also qualifies accesses by the BTE streams.             *
- * The bits in each field of this register are cleared by the SHub      *
- * upon detection of an error which requires widget 0 or the BTE        *
- * streams to be terminated. Whether or not widget x has access         *
- * rights to this SHub is determined by an AND of the device            *
- * enable bit in the appropriate field of this register and bit 0 in    *
- * the Wx_IAC field. The bits in this field are set by writing a 1 to   *
- * them. Incoming replies from Crosstalk are not subject to this        *
- * access control mechanism.                                            *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_imem_u {
-	uint64_t	ii_imem_regval;
-	struct  {
-		uint64_t	i_w0_esd                  :	 1;
-		uint64_t	i_rsvd_3		  :	 3;
-		uint64_t	i_b0_esd		  :	 1;
-		uint64_t	i_rsvd_2		  :	 3;
-		uint64_t	i_b1_esd		  :	 1;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t	i_clr_precise		  :	 1;
-		uint64_t       i_rsvd                    :     51;
-	} ii_imem_fld_s;
-} ii_imem_u_t;
-
-
-
-/************************************************************************
- *                                                                      *
- * Description:  This register specifies the timeout value to use for   *
- * monitoring Crosstalk tail flits coming into the Shub in the          *
- * TAIL_TO field. An internal counter associated with this register     *
- * is incremented every 128 II internal clocks (7 bits). The counter    *
- * starts counting anytime a header micropacket is received and stops   *
- * counting (and resets to zero) any time a micropacket with a Tail     *
- * bit is received. Once the counter reaches the threshold value        *
- * programmed in this register, it generates an interrupt to the        *
- * processor that is programmed into the IIDSR. The counter saturates   *
- * (does not roll over) at its maximum value, so it cannot cause        *
- * another interrupt until after it is cleared.                         *
- * The register also contains the Read Response Timeout values. The     *
- * Prescalar is 23 bits, and counts II clocks. An internal counter      *
- * increments on every II clock and when it reaches the value in the    *
- * Prescalar field, all IPRTE registers with their valid bits set       *
- * have their Read Response timers bumped. Whenever any of them match   *
- * the value in the RRSP_TO field, a Read Response Timeout has          *
- * occurred, and error handling occurs as described in the Error        *
- * Handling section of this document.                                   *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ixtt_u {
-	uint64_t	ii_ixtt_regval;
-	struct  {
-		uint64_t	i_tail_to                 :	26;
-		uint64_t	i_rsvd_1		  :	 6;
-		uint64_t	i_rrsp_ps		  :	23;
-		uint64_t	i_rrsp_to		  :	 5;
-		uint64_t	i_rsvd			  :	 4;
-	} ii_ixtt_fld_s;
-} ii_ixtt_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  Writing a 1 to the fields of this register clears the appropriate   *
- * error bits in other areas of SHub. Note that when the                *
- * E_PRB_x bits are used to clear error bits in PRB registers,          *
- * SPUR_RD and SPUR_WR may persist, because they require additional     *
- * action to clear them. See the IPRBx and IXSS Register                *
- * specifications.                                                      *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ieclr_u {
-	uint64_t	ii_ieclr_regval;
-	struct  {
-		uint64_t	i_e_prb_0                 :	 1;
-		uint64_t	i_rsvd			  :	 7;
-		uint64_t	i_e_prb_8		  :	 1;
-		uint64_t	i_e_prb_9		  :	 1;
-		uint64_t	i_e_prb_a		  :	 1;
-		uint64_t	i_e_prb_b		  :	 1;
-		uint64_t	i_e_prb_c		  :	 1;
-		uint64_t	i_e_prb_d		  :	 1;
-		uint64_t	i_e_prb_e		  :	 1;
-		uint64_t	i_e_prb_f		  :	 1;
-		uint64_t	i_e_crazy		  :	 1;
-		uint64_t	i_e_bte_0		  :	 1;
-		uint64_t	i_e_bte_1		  :	 1;
-		uint64_t	i_reserved_1		  :	10;
-		uint64_t	i_spur_rd_hdr		  :	 1;
-		uint64_t	i_cam_intr_to		  :	 1;
-		uint64_t	i_cam_overflow		  :	 1;
-		uint64_t	i_cam_read_miss		  :	 1;
-		uint64_t	i_ioq_rep_underflow	  :	 1;
-		uint64_t	i_ioq_req_underflow	  :	 1;
-		uint64_t	i_ioq_rep_overflow	  :	 1;
-		uint64_t	i_ioq_req_overflow	  :	 1;
-		uint64_t	i_iiq_rep_overflow	  :	 1;
-		uint64_t	i_iiq_req_overflow	  :	 1;
-		uint64_t	i_ii_xn_rep_cred_overflow :	 1;
-		uint64_t	i_ii_xn_req_cred_overflow :	 1;
-		uint64_t	i_ii_xn_invalid_cmd	  :	 1;
-		uint64_t	i_xn_ii_invalid_cmd	  :	 1;
-		uint64_t	i_reserved_2		  :	21;
-	} ii_ieclr_fld_s;
-} ii_ieclr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register controls both BTEs. SOFT_RESET is intended for        *
- * recovery after an error. COUNT controls the total number of CRBs     *
- * that both BTEs (combined) can use, which affects total BTE           *
- * bandwidth.                                                           *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibcr_u {
-	uint64_t	ii_ibcr_regval;
-	struct  {
-		uint64_t	i_count                   :	 4;
-		uint64_t	i_rsvd_1		  :	 4;
-		uint64_t	i_soft_reset		  :	 1;
-		uint64_t	i_rsvd			  :	55;
-	} ii_ibcr_fld_s;
-} ii_ibcr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the header of a spurious read response       *
- * received from Crosstalk. A spurious read response is defined as a    *
- * read response received by II from a widget for which (1) the SIDN    *
- * has a value between 1 and 7, inclusive (II never sends requests to   *
- * these widgets (2) there is no valid IPRTE register which             *
- * corresponds to the TNUM, or (3) the widget indicated in SIDN is      *
- * not the same as the widget recorded in the IPRTE register            *
- * referenced by the TNUM. If this condition is true, and if the        *
- * IXSS[VALID] bit is clear, then the header of the spurious read       *
- * response is capture in IXSM and IXSS, and IXSS[VALID] is set. The    *
- * errant header is thereby captured, and no further spurious read      *
- * respones are captured until IXSS[VALID] is cleared by setting the    *
- * appropriate bit in IECLR.Everytime a spurious read response is       *
- * detected, the SPUR_RD bit of the PRB corresponding to the incoming   *
- * message's SIDN field is set. This always happens, regarless of       *
- * whether a header is captured. The programmer should check            *
- * IXSM[SIDN] to determine which widget sent the spurious response,     *
- * because there may be more than one SPUR_RD bit set in the PRB        *
- * registers. The widget indicated by IXSM[SIDN] was the first          *
- * spurious read response to be received since the last time            *
- * IXSS[VALID] was clear. The SPUR_RD bit of the corresponding PRB      *
- * will be set. Any SPUR_RD bits in any other PRB registers indicate    *
- * spurious messages from other widets which were detected after the    *
- * header was captured..                                                *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ixsm_u {
-	uint64_t	ii_ixsm_regval;
-	struct  {
-		uint64_t	i_byte_en                 :	32;
-		uint64_t	i_reserved		  :	 1;
-		uint64_t	i_tag			  :	 3;
-		uint64_t	i_alt_pactyp		  :	 4;
-		uint64_t	i_bo			  :	 1;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_vbpm			  :	 1;
-		uint64_t	i_gbr			  :	 1;
-		uint64_t	i_ds			  :	 2;
-		uint64_t	i_ct			  :	 1;
-		uint64_t	i_tnum			  :	 5;
-		uint64_t	i_pactyp		  :	 4;
-		uint64_t	i_sidn			  :	 4;
-		uint64_t	i_didn			  :	 4;
-	} ii_ixsm_fld_s;
-} ii_ixsm_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the sideband bits of a spurious read         *
- * response received from Crosstalk.                                    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ixss_u {
-	uint64_t	ii_ixss_regval;
-	struct  {
-		uint64_t	i_sideband                :	 8;
-		uint64_t	i_rsvd			  :	55;
-		uint64_t	i_valid			  :	 1;
-	} ii_ixss_fld_s;
-} ii_ixss_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register enables software to access the II LLP's test port.    *
- * Refer to the LLP 2.5 documentation for an explanation of the test    *
- * port. Software can write to this register to program the values      *
- * for the control fields (TestErrCapture, TestClear, TestFlit,         *
- * TestMask and TestSeed). Similarly, software can read from this       *
- * register to obtain the values of the test port's status outputs      *
- * (TestCBerr, TestValid and TestData).                                 *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ilct_u {
-	uint64_t	ii_ilct_regval;
-	struct  {
-		uint64_t	i_test_seed               :	20;
-		uint64_t	i_test_mask               :	 8;
-		uint64_t	i_test_data               :	20;
-		uint64_t	i_test_valid              :	 1;
-		uint64_t	i_test_cberr              :	 1;
-		uint64_t	i_test_flit               :	 3;
-		uint64_t	i_test_clear              :	 1;
-		uint64_t	i_test_err_capture        :	 1;
-		uint64_t	i_rsvd                    :	 9;
-	} ii_ilct_fld_s;
-} ii_ilct_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  If the II detects an illegal incoming Duplonet packet (request or   *
- * reply) when VALID==0 in the IIEPH1 register, then it saves the       *
- * contents of the packet's header flit in the IIEPH1 and IIEPH2        *
- * registers, sets the VALID bit in IIEPH1, clears the OVERRUN bit,     *
- * and assigns a value to the ERR_TYPE field which indicates the        *
- * specific nature of the error. The II recognizes four different       *
- * types of errors: short request packets (ERR_TYPE==2), short reply    *
- * packets (ERR_TYPE==3), long request packets (ERR_TYPE==4) and long   *
- * reply packets (ERR_TYPE==5). The encodings for these types of        *
- * errors were chosen to be consistent with the same types of errors    *
- * indicated by the ERR_TYPE field in the LB_ERROR_HDR1 register (in    *
- * the LB unit). If the II detects an illegal incoming Duplonet         *
- * packet when VALID==1 in the IIEPH1 register, then it merely sets     *
- * the OVERRUN bit to indicate that a subsequent error has happened,    *
- * and does nothing further.                                            *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iieph1_u {
-	uint64_t	ii_iieph1_regval;
-	struct	{
-		uint64_t	i_command		  :	 7;
-		uint64_t	i_rsvd_5		  :	 1;
-		uint64_t	i_suppl			  :	14;
-		uint64_t	i_rsvd_4		  :	 1;
-		uint64_t	i_source		  :	14;
-		uint64_t	i_rsvd_3		  :	 1;
-		uint64_t	i_err_type		  :	 4;
-		uint64_t	i_rsvd_2		  :	 4;
-		uint64_t	i_overrun		  :	 1;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t	i_valid			  :	 1;
-		uint64_t	i_rsvd			  :	13;
-	} ii_iieph1_fld_s;
-} ii_iieph1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register holds the Address field from the header flit of an    *
- * incoming erroneous Duplonet packet, along with the tail bit which    *
- * accompanied this header flit. This register is essentially an        *
- * extension of IIEPH1. Two registers were necessary because the 64     *
- * bits available in only a single register were insufficient to        *
- * capture the entire header flit of an erroneous packet.               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iieph2_u {
-	uint64_t	ii_iieph2_regval;
-	struct  {
-		uint64_t	i_rsvd_0		  :	 3;
-		uint64_t	i_address                 :	47;
-		uint64_t	i_rsvd_1		  :	10;
-		uint64_t	i_tail			  :	 1;
-		uint64_t	i_rsvd			  :	 3;
-	} ii_iieph2_fld_s;
-} ii_iieph2_u_t;
-
-
-/******************************/
-
-
-
-/************************************************************************
- *                                                                      *
- *  This register's value is a bit vector that guards access from SXBs  *
- * to local registers within the II as well as to external Crosstalk    *
- * widgets								*
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_islapr_u {
-	uint64_t	ii_islapr_regval;
-	struct  {
-		uint64_t	i_region		  :	64;
-	} ii_islapr_fld_s;
-} ii_islapr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  A write to this register of the 56-bit value "Pup+Bun" will cause	*
- * the bit in the ISLAPR register corresponding to the region of the	*
- * requestor to be set (access allowed).				(
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_islapo_u {
-	uint64_t	ii_islapo_regval;
-	struct  {
-		uint64_t	i_io_sbx_ovrride	  :	56;
-		uint64_t	i_rsvd			  :	 8;
-	} ii_islapo_fld_s;
-} ii_islapo_u_t;
-
-/************************************************************************
- *                                                                      *
- *  Determines how long the wrapper will wait aftr an interrupt is	*
- * initially issued from the II before it times out the outstanding	*
- * interrupt and drops it from the interrupt queue.			* 
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iwi_u {
-	uint64_t	ii_iwi_regval;
-	struct  {
-		uint64_t	i_prescale		  :	24;
-		uint64_t	i_rsvd			  :	 8;
-		uint64_t	i_timeout		  :	 8;
-		uint64_t	i_rsvd1			  :	 8;
-		uint64_t	i_intrpt_retry_period	  :	 8;
-		uint64_t	i_rsvd2			  :	 8;
-	} ii_iwi_fld_s;
-} ii_iwi_u_t;
-
-/************************************************************************
- *                                                                      *
- *  Log errors which have occurred in the II wrapper. The errors are	*
- * cleared by writing to the IECLR register.				* 
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iwel_u {
-	uint64_t	ii_iwel_regval;
-	struct  {
-		uint64_t	i_intr_timed_out	  :	 1;
-		uint64_t	i_rsvd			  :	 7;
-		uint64_t	i_cam_overflow		  :	 1;
-		uint64_t	i_cam_read_miss		  :	 1;
-		uint64_t	i_rsvd1			  :	 2;
-		uint64_t	i_ioq_rep_underflow	  :	 1;
-		uint64_t	i_ioq_req_underflow	  :	 1;
-		uint64_t	i_ioq_rep_overflow	  :	 1;
-		uint64_t	i_ioq_req_overflow	  :	 1;
-		uint64_t	i_iiq_rep_overflow	  :	 1;
-		uint64_t	i_iiq_req_overflow	  :	 1;
-		uint64_t	i_rsvd2			  :	 6;
-		uint64_t	i_ii_xn_rep_cred_over_under:	 1;
-		uint64_t	i_ii_xn_req_cred_over_under:	 1;
-		uint64_t	i_rsvd3			  :	 6;
-		uint64_t	i_ii_xn_invalid_cmd	  :	 1;
-		uint64_t	i_xn_ii_invalid_cmd	  :	 1;
-		uint64_t	i_rsvd4			  :	30;
-	} ii_iwel_fld_s;
-} ii_iwel_u_t;
-
-/************************************************************************
- *                                                                      *
- *  Controls the II wrapper.						* 
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iwc_u {
-	uint64_t	ii_iwc_regval;
-	struct  {
-		uint64_t	i_dma_byte_swap		  :	 1;
-		uint64_t	i_rsvd			  :	 3;
-		uint64_t	i_cam_read_lines_reset	  :	 1;
-		uint64_t	i_rsvd1			  :	 3;
-		uint64_t	i_ii_xn_cred_over_under_log:	 1;
-		uint64_t	i_rsvd2			  :	19;
-		uint64_t	i_xn_rep_iq_depth	  :	 5;
-		uint64_t	i_rsvd3			  :	 3;
-		uint64_t	i_xn_req_iq_depth	  :	 5;
-		uint64_t	i_rsvd4			  :	 3;
-		uint64_t	i_iiq_depth		  :	 6;
-		uint64_t	i_rsvd5			  :	12;
-		uint64_t	i_force_rep_cred	  :	 1;
-		uint64_t	i_force_req_cred	  :	 1;
-	} ii_iwc_fld_s;
-} ii_iwc_u_t;
-
-/************************************************************************
- *                                                                      *
- *  Status in the II wrapper.						* 
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iws_u {
-	uint64_t	ii_iws_regval;
-	struct  {
-		uint64_t	i_xn_rep_iq_credits	  :	 5;
-		uint64_t	i_rsvd			  :	 3;
-		uint64_t	i_xn_req_iq_credits	  :	 5;
-		uint64_t	i_rsvd1			  :	51;
-	} ii_iws_fld_s;
-} ii_iws_u_t;
-
-/************************************************************************
- *                                                                      *
- *  Masks errors in the IWEL register.					*
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iweim_u {
-	uint64_t	ii_iweim_regval;
-	struct  {
-		uint64_t	i_intr_timed_out	  :	 1;
-		uint64_t	i_rsvd			  :	 7;
-		uint64_t	i_cam_overflow		  :	 1;
-		uint64_t	i_cam_read_miss		  :	 1;
-		uint64_t	i_rsvd1			  :	 2;
-		uint64_t	i_ioq_rep_underflow	  :	 1;
-		uint64_t	i_ioq_req_underflow	  :	 1;
-		uint64_t	i_ioq_rep_overflow	  :	 1;
-		uint64_t	i_ioq_req_overflow	  :	 1;
-		uint64_t	i_iiq_rep_overflow	  :	 1;
-		uint64_t	i_iiq_req_overflow	  :	 1;
-		uint64_t	i_rsvd2			  :	 6;
-		uint64_t	i_ii_xn_rep_cred_overflow :	 1;
-		uint64_t	i_ii_xn_req_cred_overflow :	 1;
-		uint64_t	i_rsvd3			  :	 6;
-		uint64_t	i_ii_xn_invalid_cmd	  :	 1;
-		uint64_t	i_xn_ii_invalid_cmd	  :	 1;
-		uint64_t	i_rsvd4			  :	30;
-	} ii_iweim_fld_s;
-} ii_iweim_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  A write to this register causes a particular field in the           *
- * corresponding widget's PRB entry to be adjusted up or down by 1.     *
- * This counter should be used when recovering from error and reset     *
- * conditions. Note that software would be capable of causing           *
- * inadvertent overflow or underflow of these counters.                 *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ipca_u {
-	uint64_t	ii_ipca_regval;
-	struct  {
-		uint64_t	i_wid                     :	 4;
-		uint64_t	i_adjust		  :	 1;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t	i_field			  :	 2;
-		uint64_t	i_rsvd			  :	54;
-	} ii_ipca_fld_s;
-} ii_ipca_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-
-typedef union ii_iprte0a_u {
-	uint64_t	ii_iprte0a_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	54;
-		uint64_t	i_widget		  :	 4;
-		uint64_t	i_to_cnt		  :	 5;
-		uint64_t       i_vld                     :      1;
-	} ii_iprte0a_fld_s;
-} ii_iprte0a_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte1a_u {
-	uint64_t	ii_iprte1a_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	54;
-		uint64_t	i_widget		  :	 4;
-		uint64_t	i_to_cnt		  :	 5;
-		uint64_t       i_vld                     :      1;
-	} ii_iprte1a_fld_s;
-} ii_iprte1a_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte2a_u {
-	uint64_t	ii_iprte2a_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	54;
-		uint64_t	i_widget		  :	 4;
-		uint64_t	i_to_cnt		  :	 5;
-		uint64_t       i_vld                     :      1;
-	} ii_iprte2a_fld_s;
-} ii_iprte2a_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte3a_u {
-	uint64_t	ii_iprte3a_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	54;
-		uint64_t	i_widget		  :	 4;
-		uint64_t	i_to_cnt		  :	 5;
-		uint64_t	i_vld			  :	 1;
-	} ii_iprte3a_fld_s;
-} ii_iprte3a_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte4a_u {
-	uint64_t	ii_iprte4a_regval;
-	struct	{
-		uint64_t	i_rsvd_1		  :	54;
-		uint64_t	i_widget		  :	 4;
-		uint64_t	i_to_cnt		  :	 5;
-		uint64_t	i_vld			  :	 1;
-	} ii_iprte4a_fld_s;
-} ii_iprte4a_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte5a_u {
-	uint64_t	ii_iprte5a_regval;
-	struct	{
-		uint64_t	i_rsvd_1		  :	54;
-		uint64_t	i_widget		  :	 4;
-		uint64_t	i_to_cnt		  :	 5;
-		uint64_t	i_vld			  :	 1;
-	} ii_iprte5a_fld_s;
-} ii_iprte5a_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte6a_u {
-	uint64_t	ii_iprte6a_regval;
-	struct	{
-		uint64_t	i_rsvd_1		  :	54;
-		uint64_t	i_widget		  :	 4;
-		uint64_t	i_to_cnt		  :	 5;
-		uint64_t	i_vld			  :	 1;
-	} ii_iprte6a_fld_s;
-} ii_iprte6a_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte7a_u {
-        uint64_t       ii_iprte7a_regval;
-        struct  {
-                uint64_t       i_rsvd_1                  :     54;
-                uint64_t       i_widget                  :      4;
-                uint64_t       i_to_cnt                  :      5;
-                uint64_t       i_vld                     :      1;
-        } ii_iprtea7_fld_s;
-} ii_iprte7a_u_t;
-
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-
-typedef union ii_iprte0b_u {
-	uint64_t	ii_iprte0b_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 3;
-		uint64_t	i_address		  :	47;
-		uint64_t	i_init			  :	 3;
-		uint64_t       i_source                  :     11;
-	} ii_iprte0b_fld_s;
-} ii_iprte0b_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte1b_u {
-	uint64_t	ii_iprte1b_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 3;
-		uint64_t	i_address		  :	47;
-		uint64_t	i_init			  :	 3;
-		uint64_t       i_source                  :     11;
-	} ii_iprte1b_fld_s;
-} ii_iprte1b_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte2b_u {
-	uint64_t	ii_iprte2b_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 3;
-		uint64_t	i_address		  :	47;
-		uint64_t	i_init			  :	 3;
-		uint64_t       i_source                  :     11;
-	} ii_iprte2b_fld_s;
-} ii_iprte2b_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte3b_u {
-	uint64_t	ii_iprte3b_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 3;
-		uint64_t	i_address		  :	47;
-		uint64_t	i_init			  :	 3;
-		uint64_t       i_source                  :     11;
-	} ii_iprte3b_fld_s;
-} ii_iprte3b_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte4b_u {
-	uint64_t	ii_iprte4b_regval;
-	struct	{
-		uint64_t	i_rsvd_1                  :	 3;
-		uint64_t	i_address		  :	47;
-		uint64_t	i_init			  :	 3;
-		uint64_t       i_source                  :     11;
-	} ii_iprte4b_fld_s;
-} ii_iprte4b_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte5b_u {
-	uint64_t	ii_iprte5b_regval;
-	struct	{
-		uint64_t	i_rsvd_1                  :	 3;
-		uint64_t	i_address		  :	47;
-		uint64_t	i_init			  :	 3;
-		uint64_t       i_source                  :     11;
-	} ii_iprte5b_fld_s;
-} ii_iprte5b_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte6b_u {
-	uint64_t	ii_iprte6b_regval;
-	struct	{
-		uint64_t	i_rsvd_1                  :	 3;
-		uint64_t	i_address		  :	47;
-		uint64_t	i_init			  :	 3;
-		uint64_t       i_source                  :     11;
-
-	} ii_iprte6b_fld_s;
-} ii_iprte6b_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  There are 8 instances of this register. This register contains      *
- * the information that the II has to remember once it has launched a   *
- * PIO Read operation. The contents are used to form the correct        *
- * Router Network packet and direct the Crosstalk reply to the          *
- * appropriate processor.                                               *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iprte7b_u {
-        uint64_t       ii_iprte7b_regval;
-        struct  {
-		uint64_t	i_rsvd_1                  :	 3;
-		uint64_t	i_address		  :	47;
-		uint64_t	i_init			  :	 3;
-		uint64_t       i_source                  :     11;
-        } ii_iprte7b_fld_s;
-} ii_iprte7b_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  SHub II contains a feature which did not exist in      *
- * the Hub which automatically cleans up after a Read Response          *
- * timeout, including deallocation of the IPRTE and recovery of IBuf    *
- * space. The inclusion of this register in SHub is for backward        *
- * compatibility                                                        *
- * A write to this register causes an entry from the table of           *
- * outstanding PIO Read Requests to be freed and returned to the        *
- * stack of free entries. This register is used in handling the         *
- * timeout errors that result in a PIO Reply never returning from       *
- * Crosstalk.                                                           *
- * Note that this register does not affect the contents of the IPRTE    *
- * registers. The Valid bits in those registers have to be              *
- * specifically turned off by software.                                 *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ipdr_u {
-	uint64_t	ii_ipdr_regval;
-	struct  {
-		uint64_t	i_te                      :	 3;
-		uint64_t	i_rsvd_1		  :	 1;
-		uint64_t	i_pnd			  :	 1;
-		uint64_t	i_init_rpcnt		  :	 1;
-		uint64_t	i_rsvd			  :	58;
-	} ii_ipdr_fld_s;
-} ii_ipdr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  A write to this register causes a CRB entry to be returned to the   *
- * queue of free CRBs. The entry should have previously been cleared    *
- * (mark bit) via backdoor access to the pertinent CRB entry. This      *
- * register is used in the last step of handling the errors that are    *
- * captured and marked in CRB entries.  Briefly: 1) first error for     *
- * DMA write from a particular device, and first error for a            *
- * particular BTE stream, lead to a marked CRB entry, and processor     *
- * interrupt, 2) software reads the error information captured in the   *
- * CRB entry, and presumably takes some corrective action, 3)           *
- * software clears the mark bit, and finally 4) software writes to      *
- * the ICDR register to return the CRB entry to the list of free CRB    *
- * entries.                                                             *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icdr_u {
-	uint64_t	ii_icdr_regval;
-	struct  {
-		uint64_t	i_crb_num                 :	 4;
-		uint64_t	i_pnd			  :	 1;
-		uint64_t       i_rsvd                    :     59;
-	} ii_icdr_fld_s;
-} ii_icdr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register provides debug access to two FIFOs inside of II.      *
- * Both IOQ_MAX* fields of this register contain the instantaneous      *
- * depth (in units of the number of available entries) of the           *
- * associated IOQ FIFO.  A read of this register will return the        *
- * number of free entries on each FIFO at the time of the read.  So     *
- * when a FIFO is idle, the associated field contains the maximum       *
- * depth of the FIFO.  This register is writable for debug reasons      *
- * and is intended to be written with the maximum desired FIFO depth    *
- * while the FIFO is idle. Software must assure that II is idle when    *
- * this register is written. If there are any active entries in any     *
- * of these FIFOs when this register is written, the results are        *
- * undefined.                                                           *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ifdr_u {
-	uint64_t	ii_ifdr_regval;
-	struct  {
-		uint64_t	i_ioq_max_rq              :	 7;
-		uint64_t	i_set_ioq_rq		  :	 1;
-		uint64_t	i_ioq_max_rp		  :	 7;
-		uint64_t	i_set_ioq_rp		  :	 1;
-		uint64_t	i_rsvd			  :	48;
-	} ii_ifdr_fld_s;
-} ii_ifdr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register allows the II to become sluggish in removing          *
- * messages from its inbound queue (IIQ). This will cause messages to   *
- * back up in either virtual channel. Disabling the "molasses" mode     *
- * subsequently allows the II to be tested under stress. In the         *
- * sluggish ("Molasses") mode, the localized effects of congestion      *
- * can be observed.                                                     *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iiap_u {
-        uint64_t       ii_iiap_regval;
-        struct  {
-                uint64_t       i_rq_mls                  :      6;
-		uint64_t	i_rsvd_1		  :	 2;
-		uint64_t	i_rp_mls		  :	 6;
-		uint64_t       i_rsvd                    :     50;
-        } ii_iiap_fld_s;
-} ii_iiap_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register allows several parameters of CRB operation to be      *
- * set. Note that writing to this register can have catastrophic side   *
- * effects, if the CRB is not quiescent, i.e. if the CRB is             *
- * processing protocol messages when the write occurs.                  *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icmr_u {
-	uint64_t	ii_icmr_regval;
-	struct  {
-		uint64_t	i_sp_msg                  :	 1;
-		uint64_t	i_rd_hdr		  :	 1;
-		uint64_t	i_rsvd_4		  :	 2;
-		uint64_t	i_c_cnt			  :	 4;
-		uint64_t	i_rsvd_3		  :	 4;
-		uint64_t	i_clr_rqpd		  :	 1;
-		uint64_t	i_clr_rppd		  :	 1;
-		uint64_t	i_rsvd_2		  :	 2;
-		uint64_t	i_fc_cnt		  :	 4;
-		uint64_t	i_crb_vld		  :	15;
-		uint64_t	i_crb_mark		  :	15;
-		uint64_t	i_rsvd_1		  :	 2;
-		uint64_t	i_precise		  :	 1;
-		uint64_t	i_rsvd			  :	11;
-	} ii_icmr_fld_s;
-} ii_icmr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register allows control of the table portion of the CRB        *
- * logic via software. Control operations from this register have       *
- * priority over all incoming Crosstalk or BTE requests.                *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_iccr_u {
-	uint64_t	ii_iccr_regval;
-	struct  {
-		uint64_t	i_crb_num                 :	 4;
-		uint64_t	i_rsvd_1		  :	 4;
-		uint64_t	i_cmd			  :	 8;
-		uint64_t	i_pending		  :	 1;
-		uint64_t	i_rsvd			  :	47;
-	} ii_iccr_fld_s;
-} ii_iccr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register allows the maximum timeout value to be programmed.    *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icto_u {
-	uint64_t	ii_icto_regval;
-	struct  {
-		uint64_t	i_timeout                 :	 8;
-		uint64_t	i_rsvd			  :	56;
-	} ii_icto_fld_s;
-} ii_icto_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register allows the timeout prescalar to be programmed. An     *
- * internal counter is associated with this register. When the          *
- * internal counter reaches the value of the PRESCALE field, the        *
- * timer registers in all valid CRBs are incremented (CRBx_D[TIMEOUT]   *
- * field). The internal counter resets to zero, and then continues      *
- * counting.                                                            *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ictp_u {
-	uint64_t	ii_ictp_regval;
-	struct  {
-		uint64_t	i_prescale                :	24;
-		uint64_t	i_rsvd			  :	40;
-	} ii_ictp_fld_s;
-} ii_ictp_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
- * used for Crosstalk operations (both cacheline and partial            *
- * operations) or BTE/IO. Because the CRB entries are very wide, five   *
- * registers (_A to _E) are required to read and write each entry.      *
- * The CRB Entry registers can be conceptualized as rows and columns    *
- * (illustrated in the table above). Each row contains the 4            *
- * registers required for a single CRB Entry. The first doubleword      *
- * (column) for each entry is labeled A, and the second doubleword      *
- * (higher address) is labeled B, the third doubleword is labeled C,    *
- * the fourth doubleword is labeled D and the fifth doubleword is       *
- * labeled E. All CRB entries have their addresses on a quarter         *
- * cacheline aligned boundary.                   *
- * Upon reset, only the following fields are initialized: valid         *
- * (VLD), priority count, timeout, timeout valid, and context valid.    *
- * All other bits should be cleared by software before use (after       *
- * recovering any potential error state from before the reset).         *
- * The following four tables summarize the format for the four          *
- * registers that are used for each ICRB# Entry.                        *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icrb0_a_u {
-	uint64_t	ii_icrb0_a_regval;
-	struct  {
-		uint64_t	ia_iow                    :	 1;
-		uint64_t	ia_vld			  :	 1;
-		uint64_t	ia_addr			  :	47;
-		uint64_t	ia_tnum			  :	 5;
-		uint64_t	ia_sidn			  :	 4;
-		uint64_t       ia_rsvd                   :      6;
-	} ii_icrb0_a_fld_s;
-} ii_icrb0_a_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
- * used for Crosstalk operations (both cacheline and partial            *
- * operations) or BTE/IO. Because the CRB entries are very wide, five   *
- * registers (_A to _E) are required to read and write each entry.      *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icrb0_b_u {
-	uint64_t	ii_icrb0_b_regval;
-	struct	{
-		uint64_t	ib_xt_err		  :	 1;
-		uint64_t	ib_mark			  :	 1;
-		uint64_t	ib_ln_uce		  :	 1;
-		uint64_t	ib_errcode		  :	 3;
-		uint64_t	ib_error		  :	 1;
-		uint64_t	ib_stall__bte_1		  :	 1;
-		uint64_t	ib_stall__bte_0		  :	 1;
-		uint64_t	ib_stall__intr		  :	 1;
-		uint64_t	ib_stall_ib		  :	 1;
-		uint64_t	ib_intvn		  :	 1;
-		uint64_t	ib_wb			  :	 1;
-		uint64_t	ib_hold			  :	 1;
-		uint64_t	ib_ack			  :	 1;
-		uint64_t	ib_resp			  :	 1;
-		uint64_t	ib_ack_cnt		  :	11;
-		uint64_t	ib_rsvd			  :	 7;
-		uint64_t	ib_exc			  :	 5;
-		uint64_t	ib_init			  :	 3;
-		uint64_t	ib_imsg			  :	 8;
-		uint64_t	ib_imsgtype		  :	 2;
-		uint64_t	ib_use_old		  :	 1;
-		uint64_t	ib_rsvd_1		  :	11;
-	} ii_icrb0_b_fld_s;
-} ii_icrb0_b_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
- * used for Crosstalk operations (both cacheline and partial            *
- * operations) or BTE/IO. Because the CRB entries are very wide, five   *
- * registers (_A to _E) are required to read and write each entry.      *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icrb0_c_u {
-	uint64_t	ii_icrb0_c_regval;
-	struct	{
-		uint64_t	ic_source		  :	15;
-		uint64_t	ic_size			  :	 2;
-		uint64_t	ic_ct			  :	 1;
-		uint64_t	ic_bte_num		  :	 1;
-		uint64_t	ic_gbr			  :	 1;
-		uint64_t	ic_resprqd		  :	 1;
-		uint64_t	ic_bo			  :	 1;
-		uint64_t	ic_suppl		  :	15;
-		uint64_t	ic_rsvd			  :	27;
-	} ii_icrb0_c_fld_s;
-} ii_icrb0_c_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
- * used for Crosstalk operations (both cacheline and partial            *
- * operations) or BTE/IO. Because the CRB entries are very wide, five   *
- * registers (_A to _E) are required to read and write each entry.      *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icrb0_d_u {
-	uint64_t	ii_icrb0_d_regval;
-	struct  {
-		uint64_t	id_pa_be                  :	43;
-		uint64_t	id_bte_op		  :	 1;
-		uint64_t	id_pr_psc		  :	 4;
-		uint64_t	id_pr_cnt		  :	 4;
-		uint64_t	id_sleep		  :	 1;
-		uint64_t	id_rsvd			  :	11;
-	} ii_icrb0_d_fld_s;
-} ii_icrb0_d_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
- * used for Crosstalk operations (both cacheline and partial            *
- * operations) or BTE/IO. Because the CRB entries are very wide, five   *
- * registers (_A to _E) are required to read and write each entry.      *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icrb0_e_u {
-	uint64_t	ii_icrb0_e_regval;
-	struct  {
-		uint64_t	ie_timeout                :	 8;
-		uint64_t	ie_context		  :	15;
-		uint64_t	ie_rsvd			  :	 1;
-		uint64_t	ie_tvld			  :	 1;
-		uint64_t	ie_cvld			  :	 1;
-		uint64_t	ie_rsvd_0		  :	38;
-	} ii_icrb0_e_fld_s;
-} ii_icrb0_e_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the lower 64 bits of the header of the       *
- * spurious message captured by II. Valid when the SP_MSG bit in ICMR   *
- * register is set.                                                     *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icsml_u {
-	uint64_t	ii_icsml_regval;
-	struct  {
-		uint64_t	i_tt_addr                 :	47;
-		uint64_t	i_newsuppl_ex		  :	14;
-		uint64_t	i_reserved		  :	 2;
-		uint64_t       i_overflow                :      1;
-	} ii_icsml_fld_s;
-} ii_icsml_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the middle 64 bits of the header of the      *
- * spurious message captured by II. Valid when the SP_MSG bit in ICMR   *
- * register is set.                                                     *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icsmm_u {
-	uint64_t	ii_icsmm_regval;
-	struct  {
-		uint64_t	i_tt_ack_cnt              :	11;
-		uint64_t	i_reserved		  :	53;
-	} ii_icsmm_fld_s;
-} ii_icsmm_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the microscopic state, all the inputs to     *
- * the protocol table, captured with the spurious message. Valid when   *
- * the SP_MSG bit in the ICMR register is set.                          *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_icsmh_u {
-	uint64_t	ii_icsmh_regval;
-	struct  {
-		uint64_t	i_tt_vld                  :	 1;
-		uint64_t	i_xerr			  :	 1;
-		uint64_t	i_ft_cwact_o		  :	 1;
-		uint64_t	i_ft_wact_o		  :	 1;
-		uint64_t       i_ft_active_o             :      1;
-		uint64_t	i_sync			  :	 1;
-		uint64_t	i_mnusg			  :	 1;
-		uint64_t	i_mnusz			  :	 1;
-		uint64_t	i_plusz			  :	 1;
-		uint64_t	i_plusg			  :	 1;
-		uint64_t	i_tt_exc		  :	 5;
-		uint64_t	i_tt_wb			  :	 1;
-		uint64_t	i_tt_hold		  :	 1;
-		uint64_t	i_tt_ack		  :	 1;
-		uint64_t	i_tt_resp		  :	 1;
-		uint64_t	i_tt_intvn		  :	 1;
-		uint64_t	i_g_stall_bte1		  :	 1;
-		uint64_t	i_g_stall_bte0		  :	 1;
-		uint64_t	i_g_stall_il		  :	 1;
-		uint64_t	i_g_stall_ib		  :	 1;
-		uint64_t	i_tt_imsg		  :	 8;
-		uint64_t	i_tt_imsgtype		  :	 2;
-		uint64_t	i_tt_use_old		  :	 1;
-		uint64_t	i_tt_respreqd		  :	 1;
-		uint64_t	i_tt_bte_num		  :	 1;
-		uint64_t	i_cbn			  :	 1;
-		uint64_t	i_match			  :	 1;
-		uint64_t	i_rpcnt_lt_34		  :	 1;
-		uint64_t	i_rpcnt_ge_34		  :	 1;
-		uint64_t	i_rpcnt_lt_18		  :	 1;
-		uint64_t	i_rpcnt_ge_18		  :	 1;
-		uint64_t       i_rpcnt_lt_2              :      1;
-		uint64_t	i_rpcnt_ge_2		  :	 1;
-		uint64_t	i_rqcnt_lt_18		  :	 1;
-		uint64_t	i_rqcnt_ge_18		  :	 1;
-		uint64_t	i_rqcnt_lt_2		  :	 1;
-		uint64_t	i_rqcnt_ge_2		  :	 1;
-		uint64_t	i_tt_device		  :	 7;
-		uint64_t	i_tt_init		  :	 3;
-		uint64_t	i_reserved		  :	 5;
-	} ii_icsmh_fld_s;
-} ii_icsmh_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  The Shub DEBUG unit provides a 3-bit selection signal to the        *
- * II core and a 3-bit selection signal to the fsbclk domain in the II  *
- * wrapper.                                                             *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_idbss_u {
-	uint64_t	ii_idbss_regval;
-	struct  {
-		uint64_t	i_iioclk_core_submenu     :	 3;
-		uint64_t	i_rsvd			  :	 5;
-		uint64_t	i_fsbclk_wrapper_submenu  :	 3;
-		uint64_t	i_rsvd_1		  :	 5;
-		uint64_t	i_iioclk_menu		  :	 5;
-		uint64_t	i_rsvd_2		  :	43;
-	} ii_idbss_fld_s;
-} ii_idbss_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  This register is used to set up the length for a       *
- * transfer and then to monitor the progress of that transfer. This     *
- * register needs to be initialized before a transfer is started. A     *
- * legitimate write to this register will set the Busy bit, clear the   *
- * Error bit, and initialize the length to the value desired.           *
- * While the transfer is in progress, hardware will decrement the       *
- * length field with each successful block that is copied. Once the     *
- * transfer completes, hardware will clear the Busy bit. The length     *
- * field will also contain the number of cache lines left to be         *
- * transferred.                                                         *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibls0_u {
-	uint64_t	ii_ibls0_regval;
-	struct	{
-		uint64_t	i_length		  :	16;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t	i_busy			  :	 1;
-		uint64_t       i_rsvd                    :     43;
-	} ii_ibls0_fld_s;
-} ii_ibls0_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register should be loaded before a transfer is started. The    *
- * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
- * address as described in Section 1.3, Figure2 and Figure3. Since      *
- * the bottom 7 bits of the address are always taken to be zero, BTE    *
- * transfers are always cacheline-aligned.                              *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibsa0_u {
-	uint64_t	ii_ibsa0_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 7;
-		uint64_t	i_addr			  :	42;
-		uint64_t       i_rsvd                    :     15;
-	} ii_ibsa0_fld_s;
-} ii_ibsa0_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register should be loaded before a transfer is started. The    *
- * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
- * address as described in Section 1.3, Figure2 and Figure3. Since      *
- * the bottom 7 bits of the address are always taken to be zero, BTE    *
- * transfers are always cacheline-aligned.                              *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibda0_u {
-	uint64_t	ii_ibda0_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 7;
-		uint64_t	i_addr			  :	42;
-		uint64_t	i_rsvd			  :	15;
-	} ii_ibda0_fld_s;
-} ii_ibda0_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  Writing to this register sets up the attributes of the transfer     *
- * and initiates the transfer operation. Reading this register has      *
- * the side effect of terminating any transfer in progress. Note:       *
- * stopping a transfer midstream could have an adverse impact on the    *
- * other BTE. If a BTE stream has to be stopped (due to error           *
- * handling for example), both BTE streams should be stopped and        *
- * their transfers discarded.                                           *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibct0_u {
-	uint64_t	ii_ibct0_regval;
-	struct  {
-		uint64_t	i_zerofill                :	 1;
-		uint64_t	i_rsvd_2		  :	 3;
-		uint64_t	i_notify		  :	 1;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t       i_poison                  :      1;
-		uint64_t       i_rsvd                    :     55;
-	} ii_ibct0_fld_s;
-} ii_ibct0_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the address to which the WINV is sent.       *
- * This address has to be cache line aligned.                           *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibna0_u {
-	uint64_t	ii_ibna0_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 7;
-		uint64_t	i_addr			  :	42;
-		uint64_t	i_rsvd			  :	15;
-	} ii_ibna0_fld_s;
-} ii_ibna0_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the programmable level as well as the node   *
- * ID and PI unit of the processor to which the interrupt will be       *
- * sent.                                                                *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibia0_u {
-	uint64_t	ii_ibia0_regval;
-	struct  {
-		uint64_t	i_rsvd_2                   :	 1;
-		uint64_t	i_node_id		  :	11;
-		uint64_t	i_rsvd_1		  :	 4;
-		uint64_t	i_level			  :	 7;
-		uint64_t       i_rsvd                    :     41;
-	} ii_ibia0_fld_s;
-} ii_ibia0_u_t;
-
-
-/************************************************************************
- *                                                                      *
- * Description:  This register is used to set up the length for a       *
- * transfer and then to monitor the progress of that transfer. This     *
- * register needs to be initialized before a transfer is started. A     *
- * legitimate write to this register will set the Busy bit, clear the   *
- * Error bit, and initialize the length to the value desired.           *
- * While the transfer is in progress, hardware will decrement the       *
- * length field with each successful block that is copied. Once the     *
- * transfer completes, hardware will clear the Busy bit. The length     *
- * field will also contain the number of cache lines left to be         *
- * transferred.                                                         *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibls1_u {
-	uint64_t	ii_ibls1_regval;
-	struct  {
-		uint64_t	i_length                  :	16;
-		uint64_t	i_error			  :	 1;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t	i_busy			  :	 1;
-		uint64_t       i_rsvd                    :     43;
-	} ii_ibls1_fld_s;
-} ii_ibls1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register should be loaded before a transfer is started. The    *
- * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
- * address as described in Section 1.3, Figure2 and Figure3. Since      *
- * the bottom 7 bits of the address are always taken to be zero, BTE    *
- * transfers are always cacheline-aligned.                              *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibsa1_u {
-	uint64_t	ii_ibsa1_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 7;
-		uint64_t	i_addr			  :	33;
-		uint64_t	i_rsvd			  :	24;
-	} ii_ibsa1_fld_s;
-} ii_ibsa1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register should be loaded before a transfer is started. The    *
- * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
- * address as described in Section 1.3, Figure2 and Figure3. Since      *
- * the bottom 7 bits of the address are always taken to be zero, BTE    *
- * transfers are always cacheline-aligned.                              *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibda1_u {
-	uint64_t	ii_ibda1_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 7;
-		uint64_t	i_addr			  :	33;
-		uint64_t	i_rsvd			  :	24;
-	} ii_ibda1_fld_s;
-} ii_ibda1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  Writing to this register sets up the attributes of the transfer     *
- * and initiates the transfer operation. Reading this register has      *
- * the side effect of terminating any transfer in progress. Note:       *
- * stopping a transfer midstream could have an adverse impact on the    *
- * other BTE. If a BTE stream has to be stopped (due to error           *
- * handling for example), both BTE streams should be stopped and        *
- * their transfers discarded.                                           *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibct1_u {
-	uint64_t	ii_ibct1_regval;
-	struct  {
-		uint64_t	i_zerofill                :	 1;
-		uint64_t	i_rsvd_2		  :	 3;
-		uint64_t	i_notify		  :	 1;
-		uint64_t	i_rsvd_1		  :	 3;
-		uint64_t	i_poison		  :	 1;
-		uint64_t	i_rsvd			  :	55;
-	} ii_ibct1_fld_s;
-} ii_ibct1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the address to which the WINV is sent.       *
- * This address has to be cache line aligned.                           *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibna1_u {
-	uint64_t	ii_ibna1_regval;
-	struct  {
-		uint64_t	i_rsvd_1                  :	 7;
-		uint64_t	i_addr			  :	33;
-		uint64_t       i_rsvd                    :     24;
-	} ii_ibna1_fld_s;
-} ii_ibna1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register contains the programmable level as well as the node   *
- * ID and PI unit of the processor to which the interrupt will be       *
- * sent.                                                                *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ibia1_u {
-	uint64_t	ii_ibia1_regval;
-	struct  {
-		uint64_t	i_pi_id                   :	 1;
-		uint64_t	i_node_id		  :	 8;
-		uint64_t	i_rsvd_1		  :	 7;
-		uint64_t	i_level			  :	 7;
-		uint64_t	i_rsvd			  :	41;
-	} ii_ibia1_fld_s;
-} ii_ibia1_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *  This register defines the resources that feed information into      *
- * the two performance counters located in the IO Performance           *
- * Profiling Register. There are 17 different quantities that can be    *
- * measured. Given these 17 different options, the two performance      *
- * counters have 15 of them in common; menu selections 0 through 0xE    *
- * are identical for each performance counter. As for the other two     *
- * options, one is available from one performance counter and the       *
- * other is available from the other performance counter. Hence, the    *
- * II supports all 17*16=272 possible combinations of quantities to     *
- * measure.                                                             *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ipcr_u {
-	uint64_t	ii_ipcr_regval;
-	struct  {
-		uint64_t	i_ippr0_c                 :	 4;
-		uint64_t	i_ippr1_c		  :	 4;
-		uint64_t	i_icct			  :	 8;
-		uint64_t       i_rsvd                    :     48;
-	} ii_ipcr_fld_s;
-} ii_ipcr_u_t;
-
-
-/************************************************************************
- *                                                                      *
- *                                                                      *
- *                                                                      *
- ************************************************************************/
-
-typedef union ii_ippr_u {
-	uint64_t	ii_ippr_regval;
-	struct  {
-		uint64_t	i_ippr0                   :	32;
-		uint64_t	i_ippr1			  :	32;
-	} ii_ippr_fld_s;
-} ii_ippr_u_t;
-
-
-
-/**************************************************************************
- *                                                                        *
- * The following defines which were not formed into structures are        *
- * probably indentical to another register, and the name of the           *
- * register is provided against each of these registers. This             *
- * information needs to be checked carefully                              *
- *                                                                        *
- *           IIO_ICRB1_A                IIO_ICRB0_A                       *
- *           IIO_ICRB1_B                IIO_ICRB0_B                       *
- *           IIO_ICRB1_C                IIO_ICRB0_C                       *
- *           IIO_ICRB1_D                IIO_ICRB0_D                       *
- *           IIO_ICRB1_E                IIO_ICRB0_E                       *
- *           IIO_ICRB2_A                IIO_ICRB0_A                       *
- *           IIO_ICRB2_B                IIO_ICRB0_B                       *
- *           IIO_ICRB2_C                IIO_ICRB0_C                       *
- *           IIO_ICRB2_D                IIO_ICRB0_D                       *
- *           IIO_ICRB2_E                IIO_ICRB0_E                       *
- *           IIO_ICRB3_A                IIO_ICRB0_A                       *
- *           IIO_ICRB3_B                IIO_ICRB0_B                       *
- *           IIO_ICRB3_C                IIO_ICRB0_C                       *
- *           IIO_ICRB3_D                IIO_ICRB0_D                       *
- *           IIO_ICRB3_E                IIO_ICRB0_E                       *
- *           IIO_ICRB4_A                IIO_ICRB0_A                       *
- *           IIO_ICRB4_B                IIO_ICRB0_B                       *
- *           IIO_ICRB4_C                IIO_ICRB0_C                       *
- *           IIO_ICRB4_D                IIO_ICRB0_D                       *
- *           IIO_ICRB4_E                IIO_ICRB0_E                       *
- *           IIO_ICRB5_A                IIO_ICRB0_A                       *
- *           IIO_ICRB5_B                IIO_ICRB0_B                       *
- *           IIO_ICRB5_C                IIO_ICRB0_C                       *
- *           IIO_ICRB5_D                IIO_ICRB0_D                       *
- *           IIO_ICRB5_E                IIO_ICRB0_E                       *
- *           IIO_ICRB6_A                IIO_ICRB0_A                       *
- *           IIO_ICRB6_B                IIO_ICRB0_B                       *
- *           IIO_ICRB6_C                IIO_ICRB0_C                       *
- *           IIO_ICRB6_D                IIO_ICRB0_D                       *
- *           IIO_ICRB6_E                IIO_ICRB0_E                       *
- *           IIO_ICRB7_A                IIO_ICRB0_A                       *
- *           IIO_ICRB7_B                IIO_ICRB0_B                       *
- *           IIO_ICRB7_C                IIO_ICRB0_C                       *
- *           IIO_ICRB7_D                IIO_ICRB0_D                       *
- *           IIO_ICRB7_E                IIO_ICRB0_E                       *
- *           IIO_ICRB8_A                IIO_ICRB0_A                       *
- *           IIO_ICRB8_B                IIO_ICRB0_B                       *
- *           IIO_ICRB8_C                IIO_ICRB0_C                       *
- *           IIO_ICRB8_D                IIO_ICRB0_D                       *
- *           IIO_ICRB8_E                IIO_ICRB0_E                       *
- *           IIO_ICRB9_A                IIO_ICRB0_A                       *
- *           IIO_ICRB9_B                IIO_ICRB0_B                       *
- *           IIO_ICRB9_C                IIO_ICRB0_C                       *
- *           IIO_ICRB9_D                IIO_ICRB0_D                       *
- *           IIO_ICRB9_E                IIO_ICRB0_E                       *
- *           IIO_ICRBA_A                IIO_ICRB0_A                       *
- *           IIO_ICRBA_B                IIO_ICRB0_B                       *
- *           IIO_ICRBA_C                IIO_ICRB0_C                       *
- *           IIO_ICRBA_D                IIO_ICRB0_D                       *
- *           IIO_ICRBA_E                IIO_ICRB0_E                       *
- *           IIO_ICRBB_A                IIO_ICRB0_A                       *
- *           IIO_ICRBB_B                IIO_ICRB0_B                       *
- *           IIO_ICRBB_C                IIO_ICRB0_C                       *
- *           IIO_ICRBB_D                IIO_ICRB0_D                       *
- *           IIO_ICRBB_E                IIO_ICRB0_E                       *
- *           IIO_ICRBC_A                IIO_ICRB0_A                       *
- *           IIO_ICRBC_B                IIO_ICRB0_B                       *
- *           IIO_ICRBC_C                IIO_ICRB0_C                       *
- *           IIO_ICRBC_D                IIO_ICRB0_D                       *
- *           IIO_ICRBC_E                IIO_ICRB0_E                       *
- *           IIO_ICRBD_A                IIO_ICRB0_A                       *
- *           IIO_ICRBD_B                IIO_ICRB0_B                       *
- *           IIO_ICRBD_C                IIO_ICRB0_C                       *
- *           IIO_ICRBD_D                IIO_ICRB0_D                       *
- *           IIO_ICRBD_E                IIO_ICRB0_E                       *
- *           IIO_ICRBE_A                IIO_ICRB0_A                       *
- *           IIO_ICRBE_B                IIO_ICRB0_B                       *
- *           IIO_ICRBE_C                IIO_ICRB0_C                       *
- *           IIO_ICRBE_D                IIO_ICRB0_D                       *
- *           IIO_ICRBE_E                IIO_ICRB0_E                       *
- *                                                                        *
- **************************************************************************/
-
-
-/*
- * Slightly friendlier names for some common registers.
- */
-#define IIO_WIDGET              IIO_WID      /* Widget identification */
-#define IIO_WIDGET_STAT         IIO_WSTAT    /* Widget status register */
-#define IIO_WIDGET_CTRL         IIO_WCR      /* Widget control register */
-#define IIO_PROTECT             IIO_ILAPR    /* IO interface protection */
-#define IIO_PROTECT_OVRRD       IIO_ILAPO    /* IO protect override */
-#define IIO_OUTWIDGET_ACCESS    IIO_IOWA     /* Outbound widget access */
-#define IIO_INWIDGET_ACCESS     IIO_IIWA     /* Inbound widget access */
-#define IIO_INDEV_ERR_MASK      IIO_IIDEM    /* Inbound device error mask */
-#define IIO_LLP_CSR             IIO_ILCSR    /* LLP control and status */
-#define IIO_LLP_LOG             IIO_ILLR     /* LLP log */
-#define IIO_XTALKCC_TOUT        IIO_IXCC     /* Xtalk credit count timeout*/
-#define IIO_XTALKTT_TOUT        IIO_IXTT     /* Xtalk tail timeout */
-#define IIO_IO_ERR_CLR          IIO_IECLR    /* IO error clear */
-#define IIO_IGFX_0 		IIO_IGFX0
-#define IIO_IGFX_1 		IIO_IGFX1
-#define IIO_IBCT_0		IIO_IBCT0
-#define IIO_IBCT_1		IIO_IBCT1
-#define IIO_IBLS_0		IIO_IBLS0
-#define IIO_IBLS_1		IIO_IBLS1
-#define IIO_IBSA_0		IIO_IBSA0
-#define IIO_IBSA_1		IIO_IBSA1
-#define IIO_IBDA_0		IIO_IBDA0
-#define IIO_IBDA_1		IIO_IBDA1
-#define IIO_IBNA_0		IIO_IBNA0
-#define IIO_IBNA_1		IIO_IBNA1
-#define IIO_IBIA_0		IIO_IBIA0
-#define IIO_IBIA_1		IIO_IBIA1
-#define IIO_IOPRB_0		IIO_IPRB0
-
-#define IIO_PRTE_A(_x)		(IIO_IPRTE0_A + (8 * (_x)))
-#define IIO_PRTE_B(_x)		(IIO_IPRTE0_B + (8 * (_x)))
-#define IIO_NUM_PRTES		8	/* Total number of PRB table entries */
-#define IIO_WIDPRTE_A(x)	IIO_PRTE_A(((x) - 8)) /* widget ID to its PRTE num */
-#define IIO_WIDPRTE_B(x)	IIO_PRTE_B(((x) - 8)) /* widget ID to its PRTE num */
-
-#define IIO_NUM_IPRBS 		(9) 
-
-#define IIO_LLP_CSR_IS_UP               0x00002000
-#define IIO_LLP_CSR_LLP_STAT_MASK       0x00003000
-#define IIO_LLP_CSR_LLP_STAT_SHFT       12
-
-#define IIO_LLP_CB_MAX  0xffff	/* in ILLR CB_CNT, Max Check Bit errors */
-#define IIO_LLP_SN_MAX  0xffff	/* in ILLR SN_CNT, Max Sequence Number errors */
-
-/* key to IIO_PROTECT_OVRRD */
-#define IIO_PROTECT_OVRRD_KEY   0x53474972756c6573ull   /* "SGIrules" */
-
-/* BTE register names */
-#define IIO_BTE_STAT_0          IIO_IBLS_0   /* Also BTE length/status 0 */
-#define IIO_BTE_SRC_0           IIO_IBSA_0   /* Also BTE source address  0 */
-#define IIO_BTE_DEST_0          IIO_IBDA_0   /* Also BTE dest. address 0 */
-#define IIO_BTE_CTRL_0          IIO_IBCT_0   /* Also BTE control/terminate 0 */
-#define IIO_BTE_NOTIFY_0        IIO_IBNA_0   /* Also BTE notification 0 */
-#define IIO_BTE_INT_0           IIO_IBIA_0   /* Also BTE interrupt 0 */
-#define IIO_BTE_OFF_0           0            /* Base offset from BTE 0 regs. */
-#define IIO_BTE_OFF_1   	(IIO_IBLS_1 - IIO_IBLS_0) /* Offset from base to BTE 1 */
-
-/* BTE register offsets from base */
-#define BTEOFF_STAT             0
-#define BTEOFF_SRC              (IIO_BTE_SRC_0 - IIO_BTE_STAT_0)
-#define BTEOFF_DEST             (IIO_BTE_DEST_0 - IIO_BTE_STAT_0)
-#define BTEOFF_CTRL             (IIO_BTE_CTRL_0 - IIO_BTE_STAT_0)
-#define BTEOFF_NOTIFY           (IIO_BTE_NOTIFY_0 - IIO_BTE_STAT_0)
-#define BTEOFF_INT              (IIO_BTE_INT_0 - IIO_BTE_STAT_0)
-
-
-/* names used in shub diags */
-#define IIO_BASE_BTE0   IIO_IBLS_0		
-#define IIO_BASE_BTE1   IIO_IBLS_1		
-
-/*
- * Macro which takes the widget number, and returns the
- * IO PRB address of that widget.
- * value _x is expected to be a widget number in the range
- * 0, 8 - 0xF
- */
-#define IIO_IOPRB(_x)   (IIO_IOPRB_0 + ( ( (_x) < HUB_WIDGET_ID_MIN ? \
-                        (_x) : \
-                        (_x) - (HUB_WIDGET_ID_MIN-1)) << 3) )
-
-
-/* GFX Flow Control Node/Widget Register */
-#define IIO_IGFX_W_NUM_BITS	4	/* size of widget num field */
-#define IIO_IGFX_W_NUM_MASK	((1<<IIO_IGFX_W_NUM_BITS)-1)
-#define IIO_IGFX_W_NUM_SHIFT	0
-#define IIO_IGFX_PI_NUM_BITS	1	/* size of PI num field */
-#define IIO_IGFX_PI_NUM_MASK	((1<<IIO_IGFX_PI_NUM_BITS)-1)
-#define IIO_IGFX_PI_NUM_SHIFT	4
-#define IIO_IGFX_N_NUM_BITS	8	/* size of node num field */
-#define IIO_IGFX_N_NUM_MASK	((1<<IIO_IGFX_N_NUM_BITS)-1)
-#define IIO_IGFX_N_NUM_SHIFT	5
-#define IIO_IGFX_P_NUM_BITS	1	/* size of processor num field */
-#define IIO_IGFX_P_NUM_MASK	((1<<IIO_IGFX_P_NUM_BITS)-1)
-#define IIO_IGFX_P_NUM_SHIFT	16
-#define IIO_IGFX_INIT(widget, pi, node, cpu)				(\
-	(((widget) & IIO_IGFX_W_NUM_MASK) << IIO_IGFX_W_NUM_SHIFT) |	 \
-	(((pi)     & IIO_IGFX_PI_NUM_MASK)<< IIO_IGFX_PI_NUM_SHIFT)|	 \
-	(((node)   & IIO_IGFX_N_NUM_MASK) << IIO_IGFX_N_NUM_SHIFT) |	 \
-	(((cpu)    & IIO_IGFX_P_NUM_MASK) << IIO_IGFX_P_NUM_SHIFT))
-
-
-/* Scratch registers (all bits available) */
-#define IIO_SCRATCH_REG0        IIO_ISCR0
-#define IIO_SCRATCH_REG1        IIO_ISCR1
-#define IIO_SCRATCH_MASK        0xffffffffffffffffUL
-
-#define IIO_SCRATCH_BIT0_0      0x0000000000000001UL
-#define IIO_SCRATCH_BIT0_1      0x0000000000000002UL
-#define IIO_SCRATCH_BIT0_2      0x0000000000000004UL
-#define IIO_SCRATCH_BIT0_3      0x0000000000000008UL
-#define IIO_SCRATCH_BIT0_4      0x0000000000000010UL
-#define IIO_SCRATCH_BIT0_5      0x0000000000000020UL
-#define IIO_SCRATCH_BIT0_6      0x0000000000000040UL
-#define IIO_SCRATCH_BIT0_7      0x0000000000000080UL
-#define IIO_SCRATCH_BIT0_8      0x0000000000000100UL
-#define IIO_SCRATCH_BIT0_9      0x0000000000000200UL
-#define IIO_SCRATCH_BIT0_A      0x0000000000000400UL
-
-#define IIO_SCRATCH_BIT1_0      0x0000000000000001UL
-#define IIO_SCRATCH_BIT1_1      0x0000000000000002UL
-/* IO Translation Table Entries */
-#define IIO_NUM_ITTES   7               /* ITTEs numbered 0..6 */
-                                        /* Hw manuals number them 1..7! */
-/*
- * IIO_IMEM Register fields.
- */
-#define IIO_IMEM_W0ESD  0x1UL             /* Widget 0 shut down due to error */
-#define IIO_IMEM_B0ESD  (1UL << 4)        /* BTE 0 shut down due to error */
-#define IIO_IMEM_B1ESD  (1UL << 8)        /* BTE 1 Shut down due to error */
-
-/*
- * As a permanent workaround for a bug in the PI side of the shub, we've
- * redefined big window 7 as small window 0.
- XXX does this still apply for SN1??
- */
-#define HUB_NUM_BIG_WINDOW      (IIO_NUM_ITTES - 1)
-
-/*
- * Use the top big window as a surrogate for the first small window
- */
-#define SWIN0_BIGWIN            HUB_NUM_BIG_WINDOW
-
-#define ILCSR_WARM_RESET        0x100
-
-/*
- * CRB manipulation macros
- *      The CRB macros are slightly complicated, since there are up to
- *      four registers associated with each CRB entry.
- */
-#define IIO_NUM_CRBS            15      /* Number of CRBs */
-#define IIO_NUM_PC_CRBS         4       /* Number of partial cache CRBs */
-#define IIO_ICRB_OFFSET         8
-#define IIO_ICRB_0              IIO_ICRB0_A
-#define IIO_ICRB_ADDR_SHFT	2	/* Shift to get proper address */
-/* XXX - This is now tuneable:
-        #define IIO_FIRST_PC_ENTRY 12
- */
-
-#define IIO_ICRB_A(_x)  ((u64)(IIO_ICRB_0 + (6 * IIO_ICRB_OFFSET * (_x))))
-#define IIO_ICRB_B(_x)  ((u64)((char *)IIO_ICRB_A(_x) + 1*IIO_ICRB_OFFSET))
-#define IIO_ICRB_C(_x)  ((u64)((char *)IIO_ICRB_A(_x) + 2*IIO_ICRB_OFFSET))
-#define IIO_ICRB_D(_x)  ((u64)((char *)IIO_ICRB_A(_x) + 3*IIO_ICRB_OFFSET))
-#define IIO_ICRB_E(_x)  ((u64)((char *)IIO_ICRB_A(_x) + 4*IIO_ICRB_OFFSET))
-
-#define TNUM_TO_WIDGET_DEV(_tnum)	(_tnum & 0x7)
-
-/*
- * values for "ecode" field
- */
-#define IIO_ICRB_ECODE_DERR     0       /* Directory error due to IIO access */
-#define IIO_ICRB_ECODE_PERR     1       /* Poison error on IO access */
-#define IIO_ICRB_ECODE_WERR     2       /* Write error by IIO access
-                                         * e.g. WINV to a Read only line. */
-#define IIO_ICRB_ECODE_AERR     3       /* Access error caused by IIO access */
-#define IIO_ICRB_ECODE_PWERR    4       /* Error on partial write       */
-#define IIO_ICRB_ECODE_PRERR    5       /* Error on partial read        */
-#define IIO_ICRB_ECODE_TOUT     6       /* CRB timeout before deallocating */
-#define IIO_ICRB_ECODE_XTERR    7       /* Incoming xtalk pkt had error bit */
-
-/*
- * Values for field imsgtype
- */
-#define IIO_ICRB_IMSGT_XTALK    0       /* Incoming Meessage from Xtalk */
-#define IIO_ICRB_IMSGT_BTE      1       /* Incoming message from BTE    */
-#define IIO_ICRB_IMSGT_SN1NET   2       /* Incoming message from SN1 net */
-#define IIO_ICRB_IMSGT_CRB      3       /* Incoming message from CRB ???  */
-
-/*
- * values for field initiator.
- */
-#define IIO_ICRB_INIT_XTALK     0       /* Message originated in xtalk  */
-#define IIO_ICRB_INIT_BTE0      0x1     /* Message originated in BTE 0  */
-#define IIO_ICRB_INIT_SN1NET    0x2     /* Message originated in SN1net */
-#define IIO_ICRB_INIT_CRB       0x3     /* Message originated in CRB ?  */
-#define IIO_ICRB_INIT_BTE1      0x5     /* MEssage originated in BTE 1  */
-
-/*
- * Number of credits Hub widget has while sending req/response to
- * xbow.
- * Value of 3 is required by Xbow 1.1
- * We may be able to increase this to 4 with Xbow 1.2.
- */
-#define       HUBII_XBOW_CREDIT       3
-#define       HUBII_XBOW_REV2_CREDIT  4
-
-/*
- * Number of credits that xtalk devices should use when communicating
- * with a SHub (depth of SHub's queue).
- */
-#define HUB_CREDIT 4
-
-/*
- * Some IIO_PRB fields
- */
-#define IIO_PRB_MULTI_ERR	(1LL << 63)
-#define IIO_PRB_SPUR_RD		(1LL << 51)
-#define IIO_PRB_SPUR_WR		(1LL << 50)
-#define IIO_PRB_RD_TO		(1LL << 49)
-#define IIO_PRB_ERROR		(1LL << 48)
-
-/*************************************************************************
-
- Some of the IIO field masks and shifts are defined here.
- This is in order to maintain compatibility in SN0 and SN1 code
- 
-**************************************************************************/
-
-/*
- * ICMR register fields
- * (Note: the IIO_ICMR_P_CNT and IIO_ICMR_PC_VLD from Hub are not
- * present in SHub)
- */
-
-#define IIO_ICMR_CRB_VLD_SHFT   20
-#define IIO_ICMR_CRB_VLD_MASK   (0x7fffUL << IIO_ICMR_CRB_VLD_SHFT)
-
-#define IIO_ICMR_FC_CNT_SHFT    16
-#define IIO_ICMR_FC_CNT_MASK    (0xf << IIO_ICMR_FC_CNT_SHFT)
-
-#define IIO_ICMR_C_CNT_SHFT     4
-#define IIO_ICMR_C_CNT_MASK     (0xf << IIO_ICMR_C_CNT_SHFT)
-
-#define IIO_ICMR_PRECISE        (1UL << 52)
-#define IIO_ICMR_CLR_RPPD       (1UL << 13)
-#define IIO_ICMR_CLR_RQPD       (1UL << 12)
-
-/*
- * IIO PIO Deallocation register field masks : (IIO_IPDR)
- XXX present but not needed in bedrock?  See the manual.
- */
-#define IIO_IPDR_PND    (1 << 4)
-
-/*
- * IIO CRB deallocation register field masks: (IIO_ICDR)
- */
-#define IIO_ICDR_PND    (1 << 4)
-
-/* 
- * IO BTE Length/Status (IIO_IBLS) register bit field definitions
- */
-#define IBLS_BUSY		(0x1UL << 20)
-#define IBLS_ERROR_SHFT		16
-#define IBLS_ERROR		(0x1UL << IBLS_ERROR_SHFT)
-#define IBLS_LENGTH_MASK	0xffff
-
-/*
- * IO BTE Control/Terminate register (IBCT) register bit field definitions
- */
-#define IBCT_POISON		(0x1UL << 8)
-#define IBCT_NOTIFY		(0x1UL << 4)
-#define IBCT_ZFIL_MODE		(0x1UL << 0)
-
-/*
- * IIO Incoming Error Packet Header (IIO_IIEPH1/IIO_IIEPH2)
- */
-#define IIEPH1_VALID		(1UL << 44)
-#define IIEPH1_OVERRUN		(1UL << 40)
-#define IIEPH1_ERR_TYPE_SHFT	32
-#define IIEPH1_ERR_TYPE_MASK	0xf
-#define IIEPH1_SOURCE_SHFT	20
-#define IIEPH1_SOURCE_MASK	11
-#define IIEPH1_SUPPL_SHFT	8
-#define IIEPH1_SUPPL_MASK	11
-#define IIEPH1_CMD_SHFT		0
-#define IIEPH1_CMD_MASK		7
-
-#define IIEPH2_TAIL		(1UL << 40)
-#define IIEPH2_ADDRESS_SHFT	0
-#define IIEPH2_ADDRESS_MASK	38
-
-#define IIEPH1_ERR_SHORT_REQ	2
-#define IIEPH1_ERR_SHORT_REPLY	3
-#define IIEPH1_ERR_LONG_REQ	4
-#define IIEPH1_ERR_LONG_REPLY	5
-
-/*
- * IO Error Clear register bit field definitions
- */
-#define IECLR_PI1_FWD_INT	(1UL << 31)  /* clear PI1_FORWARD_INT in iidsr */
-#define IECLR_PI0_FWD_INT	(1UL << 30)  /* clear PI0_FORWARD_INT in iidsr */
-#define IECLR_SPUR_RD_HDR	(1UL << 29)  /* clear valid bit in ixss reg */
-#define IECLR_BTE1		(1UL << 18)  /* clear bte error 1 */
-#define IECLR_BTE0		(1UL << 17)  /* clear bte error 0 */
-#define IECLR_CRAZY		(1UL << 16)  /* clear crazy bit in wstat reg */
-#define IECLR_PRB_F		(1UL << 15)  /* clear err bit in PRB_F reg */
-#define IECLR_PRB_E		(1UL << 14)  /* clear err bit in PRB_E reg */
-#define IECLR_PRB_D		(1UL << 13)  /* clear err bit in PRB_D reg */
-#define IECLR_PRB_C		(1UL << 12)  /* clear err bit in PRB_C reg */
-#define IECLR_PRB_B		(1UL << 11)  /* clear err bit in PRB_B reg */
-#define IECLR_PRB_A		(1UL << 10)  /* clear err bit in PRB_A reg */
-#define IECLR_PRB_9		(1UL << 9)   /* clear err bit in PRB_9 reg */
-#define IECLR_PRB_8		(1UL << 8)   /* clear err bit in PRB_8 reg */
-#define IECLR_PRB_0		(1UL << 0)   /* clear err bit in PRB_0 reg */
-
-/*
- * IIO CRB control register Fields: IIO_ICCR 
- */
-#define	IIO_ICCR_PENDING	(0x10000)
-#define	IIO_ICCR_CMD_MASK	(0xFF)
-#define	IIO_ICCR_CMD_SHFT	(7)
-#define	IIO_ICCR_CMD_NOP	(0x0)	/* No Op */
-#define	IIO_ICCR_CMD_WAKE	(0x100) /* Reactivate CRB entry and process */
-#define	IIO_ICCR_CMD_TIMEOUT	(0x200)	/* Make CRB timeout & mark invalid */
-#define	IIO_ICCR_CMD_EJECT	(0x400)	/* Contents of entry written to memory 
-					 * via a WB
-					 */
-#define	IIO_ICCR_CMD_FLUSH	(0x800)
-
-/*
- *
- * CRB Register description.
- *
- * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
- * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
- * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
- * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
- * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
- *
- * Many of the fields in CRB are status bits used by hardware
- * for implementation of the protocol. It's very dangerous to
- * mess around with the CRB registers.
- *
- * It's OK to read the CRB registers and try to make sense out of the
- * fields in CRB.
- *
- * Updating CRB requires all activities in Hub IIO to be quiesced.
- * otherwise, a write to CRB could corrupt other CRB entries.
- * CRBs are here only as a back door peek to shub IIO's status.
- * Quiescing implies  no dmas no PIOs
- * either directly from the cpu or from sn0net.
- * this is not something that can be done easily. So, AVOID updating
- * CRBs.
- */
-
-/*
- * Easy access macros for CRBs, all 5 registers (A-E)
- */
-typedef ii_icrb0_a_u_t icrba_t;
-#define a_sidn          ii_icrb0_a_fld_s.ia_sidn
-#define a_tnum          ii_icrb0_a_fld_s.ia_tnum
-#define a_addr          ii_icrb0_a_fld_s.ia_addr
-#define a_valid         ii_icrb0_a_fld_s.ia_vld
-#define a_iow           ii_icrb0_a_fld_s.ia_iow
-#define a_regvalue	ii_icrb0_a_regval
-
-typedef ii_icrb0_b_u_t icrbb_t;
-#define b_use_old       ii_icrb0_b_fld_s.ib_use_old
-#define b_imsgtype      ii_icrb0_b_fld_s.ib_imsgtype
-#define b_imsg          ii_icrb0_b_fld_s.ib_imsg
-#define b_initiator     ii_icrb0_b_fld_s.ib_init
-#define b_exc           ii_icrb0_b_fld_s.ib_exc
-#define b_ackcnt        ii_icrb0_b_fld_s.ib_ack_cnt
-#define b_resp          ii_icrb0_b_fld_s.ib_resp
-#define b_ack           ii_icrb0_b_fld_s.ib_ack
-#define b_hold          ii_icrb0_b_fld_s.ib_hold
-#define b_wb            ii_icrb0_b_fld_s.ib_wb
-#define b_intvn         ii_icrb0_b_fld_s.ib_intvn
-#define b_stall_ib      ii_icrb0_b_fld_s.ib_stall_ib
-#define b_stall_int     ii_icrb0_b_fld_s.ib_stall__intr
-#define b_stall_bte_0   ii_icrb0_b_fld_s.ib_stall__bte_0
-#define b_stall_bte_1   ii_icrb0_b_fld_s.ib_stall__bte_1
-#define b_error         ii_icrb0_b_fld_s.ib_error
-#define b_ecode         ii_icrb0_b_fld_s.ib_errcode
-#define b_lnetuce       ii_icrb0_b_fld_s.ib_ln_uce
-#define b_mark          ii_icrb0_b_fld_s.ib_mark
-#define b_xerr          ii_icrb0_b_fld_s.ib_xt_err
-#define b_regvalue	ii_icrb0_b_regval
-
-typedef ii_icrb0_c_u_t icrbc_t;
-#define c_suppl         ii_icrb0_c_fld_s.ic_suppl
-#define c_barrop        ii_icrb0_c_fld_s.ic_bo
-#define c_doresp        ii_icrb0_c_fld_s.ic_resprqd
-#define c_gbr           ii_icrb0_c_fld_s.ic_gbr
-#define c_btenum        ii_icrb0_c_fld_s.ic_bte_num
-#define c_cohtrans      ii_icrb0_c_fld_s.ic_ct
-#define c_xtsize        ii_icrb0_c_fld_s.ic_size
-#define c_source        ii_icrb0_c_fld_s.ic_source
-#define c_regvalue	ii_icrb0_c_regval
-
-
-typedef ii_icrb0_d_u_t icrbd_t;
-#define d_sleep         ii_icrb0_d_fld_s.id_sleep
-#define d_pricnt        ii_icrb0_d_fld_s.id_pr_cnt
-#define d_pripsc        ii_icrb0_d_fld_s.id_pr_psc
-#define d_bteop         ii_icrb0_d_fld_s.id_bte_op
-#define d_bteaddr       ii_icrb0_d_fld_s.id_pa_be /* ic_pa_be fld has 2 names*/
-#define d_benable       ii_icrb0_d_fld_s.id_pa_be /* ic_pa_be fld has 2 names*/
-#define d_regvalue	ii_icrb0_d_regval
-
-typedef ii_icrb0_e_u_t icrbe_t;
-#define icrbe_ctxtvld   ii_icrb0_e_fld_s.ie_cvld
-#define icrbe_toutvld   ii_icrb0_e_fld_s.ie_tvld
-#define icrbe_context   ii_icrb0_e_fld_s.ie_context
-#define icrbe_timeout   ii_icrb0_e_fld_s.ie_timeout
-#define e_regvalue	ii_icrb0_e_regval
-
-
-/* Number of widgets supported by shub */
-#define HUB_NUM_WIDGET          9
-#define HUB_WIDGET_ID_MIN       0x8
-#define HUB_WIDGET_ID_MAX       0xf
-
-#define HUB_WIDGET_PART_NUM     0xc120
-#define MAX_HUBS_PER_XBOW       2
-
-/* A few more #defines for backwards compatibility */
-#define iprb_t          ii_iprb0_u_t
-#define iprb_regval     ii_iprb0_regval
-#define iprb_mult_err	ii_iprb0_fld_s.i_mult_err
-#define iprb_spur_rd	ii_iprb0_fld_s.i_spur_rd
-#define iprb_spur_wr	ii_iprb0_fld_s.i_spur_wr
-#define iprb_rd_to	ii_iprb0_fld_s.i_rd_to
-#define iprb_ovflow     ii_iprb0_fld_s.i_of_cnt
-#define iprb_error      ii_iprb0_fld_s.i_error
-#define iprb_ff         ii_iprb0_fld_s.i_f
-#define iprb_mode       ii_iprb0_fld_s.i_m
-#define iprb_bnakctr    ii_iprb0_fld_s.i_nb
-#define iprb_anakctr    ii_iprb0_fld_s.i_na
-#define iprb_xtalkctr   ii_iprb0_fld_s.i_c
-
-#define LNK_STAT_WORKING        0x2		/* LLP is working */
-
-#define IIO_WSTAT_ECRAZY        (1ULL << 32)    /* Hub gone crazy */
-#define IIO_WSTAT_TXRETRY       (1ULL << 9)     /* Hub Tx Retry timeout */
-#define IIO_WSTAT_TXRETRY_MASK  (0x7F)   /* should be 0xFF?? */
-#define IIO_WSTAT_TXRETRY_SHFT  (16)
-#define IIO_WSTAT_TXRETRY_CNT(w)        (((w) >> IIO_WSTAT_TXRETRY_SHFT) & \
-                                          IIO_WSTAT_TXRETRY_MASK)
-
-/* Number of II perf. counters we can multiplex at once */
-
-#define IO_PERF_SETS	32
-
-/* Bit for the widget in inbound access register */
-#define IIO_IIWA_WIDGET(_w)     ((uint64_t)(1ULL << _w))
-/* Bit for the widget in outbound access register */
-#define IIO_IOWA_WIDGET(_w)     ((uint64_t)(1ULL << _w))
-
-/* NOTE: The following define assumes that we are going to get
- * widget numbers from 8 thru F and the device numbers within
- * widget from 0 thru 7.
- */
-#define IIO_IIDEM_WIDGETDEV_MASK(w, d)  ((uint64_t)(1ULL << (8 * ((w) - 8) + (d))))
-
-/* IO Interrupt Destination Register */
-#define IIO_IIDSR_SENT_SHIFT    28
-#define IIO_IIDSR_SENT_MASK     0x30000000
-#define IIO_IIDSR_ENB_SHIFT     24
-#define IIO_IIDSR_ENB_MASK      0x01000000
-#define IIO_IIDSR_NODE_SHIFT    9
-#define IIO_IIDSR_NODE_MASK     0x000ff700
-#define IIO_IIDSR_PI_ID_SHIFT   8
-#define IIO_IIDSR_PI_ID_MASK    0x00000100
-#define IIO_IIDSR_LVL_SHIFT     0
-#define IIO_IIDSR_LVL_MASK      0x000000ff
-
-/* Xtalk timeout threshhold register (IIO_IXTT) */
-#define IXTT_RRSP_TO_SHFT	55	   /* read response timeout */
-#define IXTT_RRSP_TO_MASK	(0x1FULL << IXTT_RRSP_TO_SHFT)
-#define IXTT_RRSP_PS_SHFT	32	   /* read responsed TO prescalar */
-#define IXTT_RRSP_PS_MASK	(0x7FFFFFULL << IXTT_RRSP_PS_SHFT)
-#define IXTT_TAIL_TO_SHFT	0	   /* tail timeout counter threshold */
-#define IXTT_TAIL_TO_MASK	(0x3FFFFFFULL << IXTT_TAIL_TO_SHFT)
-
-/*
- * The IO LLP control status register and widget control register
- */
-
-typedef union hubii_wcr_u {
-        uint64_t      wcr_reg_value;
-        struct {
-	  uint64_t	wcr_widget_id:   4,     /* LLP crossbar credit */
-			wcr_tag_mode:	 1,	/* Tag mode */
-			wcr_rsvd1:	 8,	/* Reserved */
-			wcr_xbar_crd:	 3,	/* LLP crossbar credit */
-			wcr_f_bad_pkt:	 1,	/* Force bad llp pkt enable */
-			wcr_dir_con:	 1,	/* widget direct connect */
-			wcr_e_thresh:	 5,	/* elasticity threshold */
-			wcr_rsvd:	41;	/* unused */
-        } wcr_fields_s;
-} hubii_wcr_t;
-
-#define iwcr_dir_con    wcr_fields_s.wcr_dir_con
-
-/* The structures below are defined to extract and modify the ii
-performance registers */
-
-/* io_perf_sel allows the caller to specify what tests will be
-   performed */
-
-typedef union io_perf_sel {
-        uint64_t perf_sel_reg;
-        struct {
-               uint64_t	perf_ippr0 :  4,
-				perf_ippr1 :  4,
-				perf_icct  :  8,
-				perf_rsvd  : 48;
-        } perf_sel_bits;
-} io_perf_sel_t;
-
-/* io_perf_cnt is to extract the count from the shub registers. Due to
-   hardware problems there is only one counter, not two. */
-
-typedef union io_perf_cnt {
-        uint64_t      perf_cnt;
-        struct {
-               uint64_t	perf_cnt   : 20,
-				perf_rsvd2 : 12,
-				perf_rsvd1 : 32;
-        } perf_cnt_bits;
-
-} io_perf_cnt_t;
-
-typedef union iprte_a {
-	uint64_t	entry;
-	struct {
-		uint64_t	i_rsvd_1                  :	 3;
-		uint64_t	i_addr			  :	38;
-		uint64_t	i_init			  :	 3;
-		uint64_t	i_source		  :	 8;
-		uint64_t	i_rsvd			  :	 2;
-		uint64_t	i_widget		  :	 4;
-		uint64_t	i_to_cnt		  :	 5;
-		uint64_t       i_vld                     :      1;
-	} iprte_fields;
-} iprte_a_t;
-
-#endif /* _ASM_IA64_SN_SHUBIO_H */
-
diff -Nru a/arch/ia64/sn/kernel/bte.c b/arch/ia64/sn/kernel/bte.c
--- a/arch/ia64/sn/kernel/bte.c	2004-10-19 13:37:28 -07:00
+++ b/arch/ia64/sn/kernel/bte.c	2005-01-28 15:38:45 -08:00
@@ -13,7 +13,7 @@
 #include <asm/sn/arch.h>
 #include <asm/sn/sn_cpuid.h>
 #include <asm/sn/pda.h>
-#include "shubio.h"
+#include <asm/sn/shubio.h>
 #include <asm/nodedata.h>
 #include <asm/delay.h>
 
diff -Nru a/arch/ia64/sn/kernel/bte_error.c b/arch/ia64/sn/kernel/bte_error.c
--- a/arch/ia64/sn/kernel/bte_error.c	2005-01-19 17:15:06 -08:00
+++ b/arch/ia64/sn/kernel/bte_error.c	2005-01-28 15:38:54 -08:00
@@ -10,7 +10,7 @@
 #include <asm/sn/sn_sal.h>
 #include "ioerror.h"
 #include <asm/sn/addrs.h>
-#include "shubio.h"
+#include <asm/sn/shubio.h>
 #include <asm/sn/geo.h>
 #include "xtalk/xwidgetdev.h"
 #include "xtalk/hubdev.h"
diff -Nru a/arch/ia64/sn/kernel/huberror.c b/arch/ia64/sn/kernel/huberror.c
--- a/arch/ia64/sn/kernel/huberror.c	2004-10-19 13:39:55 -07:00
+++ b/arch/ia64/sn/kernel/huberror.c	2005-01-28 15:38:55 -08:00
@@ -13,7 +13,7 @@
 #include <asm/sn/sn_sal.h>
 #include "ioerror.h"
 #include <asm/sn/addrs.h>
-#include "shubio.h"
+#include <asm/sn/shubio.h>
 #include <asm/sn/geo.h>
 #include "xtalk/xwidgetdev.h"
 #include "xtalk/hubdev.h"
diff -Nru a/arch/mips/Kconfig b/arch/mips/Kconfig
--- a/arch/mips/Kconfig	2005-01-30 22:33:45 -08:00
+++ b/arch/mips/Kconfig	2005-02-03 06:42:40 -08:00
@@ -456,6 +456,9 @@
 
 config SGI_IP22
 	bool "Support for SGI IP22 (Indy/Indigo2)"
+	select ARC
+	select ARC32
+	select BOOT_ELF32
 	select DMA_NONCOHERENT
 	select IP22_CPU_SCACHE
 	select IRQ_CPU
diff -Nru a/arch/mips/configs/ip22_defconfig b/arch/mips/configs/ip22_defconfig
--- a/arch/mips/configs/ip22_defconfig	2004-12-15 12:56:10 -08:00
+++ b/arch/mips/configs/ip22_defconfig	2005-02-03 06:42:40 -08:00
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:59 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:49:04 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -86,16 +86,16 @@
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 CONFIG_IRQ_CPU=y
 CONFIG_SWAP_IO_SPACE=y
+CONFIG_ARC32=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-CONFIG_ARC32=y
-# CONFIG_FB is not set
 CONFIG_ARC_CONSOLE=y
 CONFIG_ARC_PROMLIB=y
 
@@ -139,6 +139,19 @@
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -154,6 +167,7 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -173,9 +187,11 @@
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -189,6 +205,7 @@
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -223,13 +240,13 @@
 #
 CONFIG_SCSI_SPI_ATTRS=m
 # CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
 
 #
 # SCSI low-level drivers
 #
 CONFIG_SGIWD93_SCSI=y
 # CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 # CONFIG_SCSI_DEBUG is not set
 
 #
@@ -390,8 +407,6 @@
 CONFIG_IP_NF_ARPTABLES=m
 CONFIG_IP_NF_ARPFILTER=m
 CONFIG_IP_NF_ARP_MANGLE=m
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 
 #
 # IPv6: Netfilter Configuration
@@ -470,6 +485,7 @@
 CONFIG_NET_CLS_U32=m
 # CONFIG_CLS_U32_PERF is not set
 # CONFIG_NET_CLS_IND is not set
+# CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
 # CONFIG_NET_CLS_ACT is not set
@@ -560,6 +576,7 @@
 CONFIG_SERIO_I8042=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+CONFIG_SERIO_LIBPS2=y
 CONFIG_SERIO_RAW=m
 
 #
@@ -626,7 +643,6 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 CONFIG_RAW_DRIVER=m
 CONFIG_MAX_RAW_DEVS=256
@@ -658,6 +674,7 @@
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
@@ -675,6 +692,7 @@
 # CONFIG_LOGO_LINUX_VGA16 is not set
 # CONFIG_LOGO_LINUX_CLUT224 is not set
 CONFIG_LOGO_SGI_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -688,11 +706,25 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=m
@@ -797,7 +829,7 @@
 CONFIG_CIFS=m
 # CONFIG_CIFS_STATS is not set
 # CONFIG_CIFS_XATTR is not set
-# CONFIG_CIFS_POSIX is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
 # CONFIG_NCP_FS is not set
 CONFIG_CODA_FS=m
 # CONFIG_CODA_FS_OLD_API is not set
@@ -868,6 +900,11 @@
 CONFIG_NLS_UTF8=m
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -910,10 +947,14 @@
 CONFIG_CRYPTO_TEST=m
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
+CONFIG_CRC32=m
 CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -Nru a/arch/mips/defconfig b/arch/mips/defconfig
--- a/arch/mips/defconfig	2004-12-15 12:56:10 -08:00
+++ b/arch/mips/defconfig	2005-02-03 06:42:40 -08:00
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.10-rc2
-# Sun Nov 21 14:11:54 2004
+# Linux kernel version: 2.6.11-rc2
+# Wed Jan 26 02:48:59 2005
 #
 CONFIG_MIPS=y
 # CONFIG_MIPS64 is not set
@@ -86,16 +86,16 @@
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_NONCOHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 CONFIG_IRQ_CPU=y
 CONFIG_SWAP_IO_SPACE=y
+CONFIG_ARC32=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
-CONFIG_ARC32=y
-# CONFIG_FB is not set
 CONFIG_ARC_CONSOLE=y
 CONFIG_ARC_PROMLIB=y
 
@@ -139,6 +139,19 @@
 CONFIG_MMU=y
 
 #
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
 # Executable file formats
 #
 CONFIG_BINFMT_ELF=y
@@ -154,6 +167,7 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -173,9 +187,11 @@
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
@@ -189,6 +205,7 @@
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -223,13 +240,13 @@
 #
 CONFIG_SCSI_SPI_ATTRS=m
 # CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
 
 #
 # SCSI low-level drivers
 #
 CONFIG_SGIWD93_SCSI=y
 # CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_QLOGIC_1280_1040 is not set
 # CONFIG_SCSI_DEBUG is not set
 
 #
@@ -390,8 +407,6 @@
 CONFIG_IP_NF_ARPTABLES=m
 CONFIG_IP_NF_ARPFILTER=m
 CONFIG_IP_NF_ARP_MANGLE=m
-# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
-# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 
 #
 # IPv6: Netfilter Configuration
@@ -470,6 +485,7 @@
 CONFIG_NET_CLS_U32=m
 # CONFIG_CLS_U32_PERF is not set
 # CONFIG_NET_CLS_IND is not set
+# CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
 # CONFIG_NET_CLS_ACT is not set
@@ -560,6 +576,7 @@
 CONFIG_SERIO_I8042=y
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+CONFIG_SERIO_LIBPS2=y
 CONFIG_SERIO_RAW=m
 
 #
@@ -626,7 +643,6 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_AGP is not set
 # CONFIG_DRM is not set
 CONFIG_RAW_DRIVER=m
 CONFIG_MAX_RAW_DEVS=256
@@ -658,6 +674,7 @@
 #
 # Graphics support
 #
+# CONFIG_FB is not set
 
 #
 # Console display driver support
@@ -675,6 +692,7 @@
 # CONFIG_LOGO_LINUX_VGA16 is not set
 # CONFIG_LOGO_LINUX_CLUT224 is not set
 CONFIG_LOGO_SGI_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -688,11 +706,25 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
 #
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=m
@@ -797,7 +829,7 @@
 CONFIG_CIFS=m
 # CONFIG_CIFS_STATS is not set
 # CONFIG_CIFS_XATTR is not set
-# CONFIG_CIFS_POSIX is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
 # CONFIG_NCP_FS is not set
 CONFIG_CODA_FS=m
 # CONFIG_CODA_FS_OLD_API is not set
@@ -868,6 +900,11 @@
 CONFIG_NLS_UTF8=m
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
@@ -910,10 +947,14 @@
 CONFIG_CRYPTO_TEST=m
 
 #
+# Hardware crypto devices
+#
+
+#
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
+CONFIG_CRC32=m
 CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -Nru a/arch/mips/sgi-ip22/ip22-nvram.c b/arch/mips/sgi-ip22/ip22-nvram.c
--- a/arch/mips/sgi-ip22/ip22-nvram.c	2004-02-19 12:53:02 -08:00
+++ b/arch/mips/sgi-ip22/ip22-nvram.c	2005-02-03 06:42:40 -08:00
@@ -26,7 +26,7 @@
 #define EEPROM_DATO	0x08	/* Data out */
 #define EEPROM_DATI	0x10	/* Data in */
 
-/* We need to use this functions early... */
+/* We need to use these functions early... */
 #define delay()	({						\
 	int x;							\
 	for (x=0; x<100000; x++) __asm__ __volatile__(""); })
diff -Nru a/arch/mips/sgi-ip22/ip22-setup.c b/arch/mips/sgi-ip22/ip22-setup.c
--- a/arch/mips/sgi-ip22/ip22-setup.c	2004-11-29 05:11:43 -08:00
+++ b/arch/mips/sgi-ip22/ip22-setup.c	2005-02-03 06:42:40 -08:00
@@ -120,9 +120,8 @@
 	}
 #endif
 
-#ifdef CONFIG_VT
-#ifdef CONFIG_SGI_NEWPORT_CONSOLE
-	if (ctype && *ctype == 'g'){
+#if defined(CONFIG_VT) && defined(CONFIG_SGI_NEWPORT_CONSOLE)
+	{
 		ULONG *gfxinfo;
 		ULONG * (*__vec)(void) = (void *) (long)
 			*((_PULONG *)(long)((PROMBLOCK)->pvector + 0x20));
@@ -137,7 +136,6 @@
 			conswitchp = &newport_con;
 		}
 	}
-#endif
 #endif
 
 	return 0;
diff -Nru a/arch/ppc/boot/simple/Makefile b/arch/ppc/boot/simple/Makefile
--- a/arch/ppc/boot/simple/Makefile	2005-01-03 15:49:19 -08:00
+++ b/arch/ppc/boot/simple/Makefile	2005-02-03 06:42:41 -08:00
@@ -66,6 +66,12 @@
          end-$(CONFIG_EBONY)		:= ebony
   entrypoint-$(CONFIG_EBONY)		:= 0x01000000
 
+      zimage-$(CONFIG_LUAN)		:= zImage-TREE
+zimageinitrd-$(CONFIG_LUAN)		:= zImage.initrd-TREE
+         end-$(CONFIG_LUAN)		:= luan
+  entrypoint-$(CONFIG_LUAN)		:= 0x01000000
+     extra.o-$(CONFIG_LUAN)		:= pibs.o
+
       zimage-$(CONFIG_OCOTEA)		:= zImage-TREE
 zimageinitrd-$(CONFIG_OCOTEA)		:= zImage.initrd-TREE
          end-$(CONFIG_OCOTEA)		:= ocotea
diff -Nru a/arch/ppc/boot/simple/pibs.c b/arch/ppc/boot/simple/pibs.c
--- a/arch/ppc/boot/simple/pibs.c	2004-10-05 23:05:22 -07:00
+++ b/arch/ppc/boot/simple/pibs.c	2005-02-03 06:42:41 -08:00
@@ -1,5 +1,5 @@
 /*
- * 2004 (c) MontaVista, Software, Inc.  This file is licensed under
+ * 2004-2005 (c) MontaVista, Software, Inc.  This file is licensed under
  * the terms of the GNU General Public License version 2.  This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
@@ -10,7 +10,7 @@
 #include <linux/string.h>
 #include <linux/ctype.h>
 #include <asm/ppcboot.h>
-#include <platforms/4xx/ocotea.h>
+#include <asm/ibm4xx.h>
 
 extern unsigned long decompress_kernel(unsigned long load_addr, int num_words,
 				       unsigned long cksum);
@@ -89,13 +89,15 @@
 
 	decompress_kernel(load_addr, num_words, cksum);
 
-	mac64 = simple_strtoull((char *)OCOTEA_PIBS_MAC_BASE, 0, 16);
+	mac64 = simple_strtoull((char *)PIBS_MAC_BASE, 0, 16);
 	memcpy(hold_residual->bi_enetaddr, (char *)&mac64+2, 6);
-	mac64 = simple_strtoull((char *)(OCOTEA_PIBS_MAC_BASE+OCOTEA_PIBS_MAC_OFFSET), 0, 16);
+#ifdef CONFIG_440GX
+	mac64 = simple_strtoull((char *)(PIBS_MAC_BASE+PIBS_MAC_OFFSET), 0, 16);
 	memcpy(hold_residual->bi_enet1addr, (char *)&mac64+2, 6);
-	mac64 = simple_strtoull((char *)(OCOTEA_PIBS_MAC_BASE+OCOTEA_PIBS_MAC_OFFSET*2), 0, 16);
+	mac64 = simple_strtoull((char *)(PIBS_MAC_BASE+PIBS_MAC_OFFSET*2), 0, 16);
 	memcpy(hold_residual->bi_enet2addr, (char *)&mac64+2, 6);
-	mac64 = simple_strtoull((char *)(OCOTEA_PIBS_MAC_BASE+OCOTEA_PIBS_MAC_OFFSET*3), 0, 16);
+	mac64 = simple_strtoull((char *)(PIBS_MAC_BASE+PIBS_MAC_OFFSET*3), 0, 16);
 	memcpy(hold_residual->bi_enet3addr, (char *)&mac64+2, 6);
+#endif
 	return (void *)hold_residual;
 }
diff -Nru a/arch/ppc/configs/luan_defconfig b/arch/ppc/configs/luan_defconfig
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/arch/ppc/configs/luan_defconfig	2005-02-03 06:42:41 -08:00
@@ -0,0 +1,668 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc2
+# Mon Jan 31 16:26:31 2005
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+CONFIG_44x=y
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+# CONFIG_E500 is not set
+CONFIG_BOOKE=y
+CONFIG_PTE_64BIT=y
+CONFIG_PHYS_64BIT=y
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_CPU_FREQ is not set
+CONFIG_4xx=y
+
+#
+# IBM 4xx options
+#
+# CONFIG_EBONY is not set
+CONFIG_LUAN=y
+# CONFIG_OCOTEA is not set
+CONFIG_440SP=y
+CONFIG_440=y
+CONFIG_IBM_OCP=y
+CONFIG_IBM_EMAC4=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_PPC_GEN550=y
+# CONFIG_PM is not set
+CONFIG_NOT_COHERENT_CACHE=y
+
+#
+# Platform options
+#
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="ip=on console=ttyS0,115200"
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_NAMES is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_CONSISTENT_START=0xff100000
+CONFIG_CONSISTENT_SIZE=0x00200000
+CONFIG_BOOT_LOAD=0x01000000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_IBM_EMAC=y
+# CONFIG_IBM_EMAC_ERRMSG is not set
+CONFIG_IBM_EMAC_RXB=128
+CONFIG_IBM_EMAC_TXB=128
+CONFIG_IBM_EMAC_FGAP=8
+CONFIG_IBM_EMAC_SKBRES=0
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_RSA is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_KGDB is not set
+# CONFIG_XMON is not set
+CONFIG_BDI_SWITCH=y
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+CONFIG_PPC_OCP=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -Nru a/arch/ppc/kernel/head_44x.S b/arch/ppc/kernel/head_44x.S
--- a/arch/ppc/kernel/head_44x.S	2005-01-03 15:49:17 -08:00
+++ b/arch/ppc/kernel/head_44x.S	2005-02-03 06:42:41 -08:00
@@ -21,7 +21,7 @@
  * 	Author: MontaVista Software, Inc.
  *         	frank_rowand@mvista.com or source@mvista.com
  * 	   	debbie_chu@mvista.com
- *    Copyright 2002-2004 MontaVista Software, Inc.
+ *    Copyright 2002-2005 MontaVista Software, Inc.
  *      PowerPC 44x support, Matt Porter <mporter@kernel.crashing.org>
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -185,11 +185,11 @@
 	 * are used for polled operation.
 	 */
  	/* pageid fields */
-	lis	r3,0xe000	
+	lis	r3,UART0_IO_BASE@h
 	ori	r3,r3,PPC44x_TLB_VALID | PPC44x_TLB_256M
 
 	/* xlat fields */
-	lis	r4,0x4000		/* RPN is 0x40000000 */
+	lis	r4,UART0_PHYS_IO_BASE@h		/* RPN depends on SoC */
 	ori	r4,r4,0x0001		/* ERPN is 1 for second 4GB page */
 
 	/* attrib fields */
diff -Nru a/arch/ppc/platforms/4xx/Kconfig b/arch/ppc/platforms/4xx/Kconfig
--- a/arch/ppc/platforms/4xx/Kconfig	2004-11-02 06:40:33 -08:00
+++ b/arch/ppc/platforms/4xx/Kconfig	2005-02-03 06:42:41 -08:00
@@ -73,6 +73,11 @@
 	help
 	  This option enables support for the IBM PPC440GP evaluation board.
 
+config LUAN
+	bool "Luan"
+	help
+	  This option enables support for the IBM PPC440SP evaluation board.
+
 config OCOTEA
 	bool "Ocotea"
 	help
@@ -103,9 +108,14 @@
 	depends on OCOTEA
 	default y
 
+config 440SP
+	bool
+	depends on LUAN
+	default y
+
 config 440
 	bool
-	depends on 440GP
+	depends on 440GP || 440SP
 	default y
 
 config 440A
@@ -132,7 +142,7 @@
 
 config IBM_OCP
 	bool
-	depends on ASH || BUBINGA || CPCI405 || EBONY || EP405 || OCOTEA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
+	depends on ASH || BUBINGA || CPCI405 || EBONY || EP405 || LUAN || OCOTEA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
 	default y
 
 config XILINX_OCP
@@ -142,7 +152,7 @@
 
 config IBM_EMAC4
 	bool
-	depends on 440GX
+	depends on 440GX || 440SP
 	default y
 
 config BIOS_FIXUP
diff -Nru a/arch/ppc/platforms/4xx/Makefile b/arch/ppc/platforms/4xx/Makefile
--- a/arch/ppc/platforms/4xx/Makefile	2004-10-18 22:26:40 -07:00
+++ b/arch/ppc/platforms/4xx/Makefile	2005-02-03 06:42:41 -08:00
@@ -6,6 +6,7 @@
 obj-$(CONFIG_EBONY)		+= ebony.o
 obj-$(CONFIG_EP405)		+= ep405.o
 obj-$(CONFIG_BUBINGA)		+= bubinga.o
+obj-$(CONFIG_LUAN)		+= luan.o
 obj-$(CONFIG_OAK)		+= oak.o
 obj-$(CONFIG_OCOTEA)		+= ocotea.o
 obj-$(CONFIG_REDWOOD_5)		+= redwood5.o
@@ -20,6 +21,7 @@
 obj-$(CONFIG_REDWOOD_6)		+= ibmstbx25.o
 obj-$(CONFIG_440GP)		+= ibm440gp.o
 obj-$(CONFIG_440GX)		+= ibm440gx.o
+obj-$(CONFIG_440SP)		+= ibm440sp.o
 obj-$(CONFIG_405EP)		+= ibm405ep.o
 obj-$(CONFIG_405GPR)		+= ibm405gpr.o
 obj-$(CONFIG_VIRTEX_II_PRO)	+= virtex-ii_pro.o
diff -Nru a/arch/ppc/platforms/4xx/ebony.c b/arch/ppc/platforms/4xx/ebony.c
--- a/arch/ppc/platforms/4xx/ebony.c	2005-01-03 15:49:19 -08:00
+++ b/arch/ppc/platforms/4xx/ebony.c	2005-02-03 06:42:41 -08:00
@@ -4,7 +4,7 @@
  * Ebony board specific routines
  *
  * Matt Porter <mporter@kernel.crashing.org>
- * Copyright 2002-2004 MontaVista Software Inc.
+ * Copyright 2002-2005 MontaVista Software Inc.
  *
  * Eugene Surovegin <eugene.surovegin@zultys.com> or <ebs@ebshome.net>
  * Copyright (c) 2003, 2004 Zultys Technologies
@@ -140,7 +140,7 @@
 {
 	void *pcix_reg_base;
 
-	pcix_reg_base = ioremap64(PCIX0_REG_BASE, PCIX0_REG_SIZE);
+	pcix_reg_base = ioremap64(PCIX0_REG_BASE, PCIX_REG_SIZE);
 
 	/* Disable all windows */
 	PCIX_WRITEL(0, PCIX0_POM0SA);
diff -Nru a/arch/ppc/platforms/4xx/ibm440sp.c b/arch/ppc/platforms/4xx/ibm440sp.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/arch/ppc/platforms/4xx/ibm440sp.c	2005-02-03 06:42:41 -08:00
@@ -0,0 +1,131 @@
+/*
+ * arch/ppc/platforms/4xx/ibm440sp.c
+ *
+ * PPC440SP I/O descriptions
+ *
+ * Matt Porter <mporter@kernel.crashing.org>
+ * Copyright 2002-2005 MontaVista Software Inc.
+ *
+ * Eugene Surovegin <eugene.surovegin@zultys.com> or <ebs@ebshome.net>
+ * Copyright (c) 2003, 2004 Zultys Technologies
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <platforms/4xx/ibm440sp.h>
+#include <asm/ocp.h>
+
+static struct ocp_func_emac_data ibm440sp_emac0_def = {
+	.rgmii_idx	= -1,		/* No RGMII */
+	.rgmii_mux	= -1,		/* No RGMII */
+	.zmii_idx       = -1,           /* No ZMII */
+	.zmii_mux       = -1,           /* No ZMII */
+	.mal_idx        = 0,            /* MAL device index */
+	.mal_rx_chan    = 0,            /* MAL rx channel number */
+	.mal_tx_chan    = 0,            /* MAL tx channel number */
+	.wol_irq        = 61,  		/* WOL interrupt number */
+	.mdio_idx       = -1,           /* No shared MDIO */
+	.tah_idx	= -1,		/* No TAH */
+	.jumbo		= 1,		/* Jumbo frames supported */
+};
+OCP_SYSFS_EMAC_DATA()
+
+static struct ocp_func_mal_data ibm440sp_mal0_def = {
+	.num_tx_chans   = 4,    	/* Number of TX channels */
+	.num_rx_chans   = 4,    	/* Number of RX channels */
+	.txeob_irq	= 38,		/* TX End Of Buffer IRQ  */
+	.rxeob_irq	= 39,		/* RX End Of Buffer IRQ  */
+	.txde_irq	= 34,		/* TX Descriptor Error IRQ */
+	.rxde_irq	= 35,		/* RX Descriptor Error IRQ */
+	.serr_irq	= 33,		/* MAL System Error IRQ    */
+};
+OCP_SYSFS_MAL_DATA()
+
+static struct ocp_func_iic_data ibm440sp_iic0_def = {
+	.fast_mode	= 0,		/* Use standad mode (100Khz) */
+};
+
+static struct ocp_func_iic_data ibm440sp_iic1_def = {
+	.fast_mode	= 0,		/* Use standad mode (100Khz) */
+};
+OCP_SYSFS_IIC_DATA()
+
+struct ocp_def core_ocp[] = {
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_OPB,
+	  .index	= 0,
+	  .paddr	= 0x0000000140000000ULL,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= OCP_CPM_NA,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_16550,
+	  .index	= 0,
+	  .paddr	= PPC440SP_UART0_ADDR,
+	  .irq		= UART0_INT,
+	  .pm		= IBM_CPM_UART0,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_16550,
+	  .index	= 1,
+	  .paddr	= PPC440SP_UART1_ADDR,
+	  .irq		= UART1_INT,
+	  .pm		= IBM_CPM_UART1,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_16550,
+	  .index	= 2,
+	  .paddr	= PPC440SP_UART2_ADDR,
+	  .irq		= UART2_INT,
+	  .pm		= IBM_CPM_UART2,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_IIC,
+	  .index	= 0,
+	  .paddr	= 0x00000001f0000400ULL,
+	  .irq		= 2,
+	  .pm		= IBM_CPM_IIC0,
+	  .additions	= &ibm440sp_iic0_def,
+	  .show		= &ocp_show_iic_data
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_IIC,
+	  .index	= 1,
+	  .paddr	= 0x00000001f0000500ULL,
+	  .irq		= 3,
+	  .pm		= IBM_CPM_IIC1,
+	  .additions	= &ibm440sp_iic1_def,
+	  .show		= &ocp_show_iic_data
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_GPIO,
+	  .index	= 0,
+	  .paddr	= 0x00000001f0000700ULL,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= IBM_CPM_GPIO0,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_MAL,
+	  .paddr	= OCP_PADDR_NA,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= OCP_CPM_NA,
+	  .additions	= &ibm440sp_mal0_def,
+	  .show		= &ocp_show_mal_data,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_EMAC,
+	  .index	= 0,
+	  .paddr	= 0x00000001f0000800ULL,
+	  .irq		= 60,
+	  .pm		= OCP_CPM_NA,
+	  .additions	= &ibm440sp_emac0_def,
+	  .show		= &ocp_show_emac_data,
+	},
+	{ .vendor	= OCP_VENDOR_INVALID
+	}
+};
diff -Nru a/arch/ppc/platforms/4xx/ibm440sp.h b/arch/ppc/platforms/4xx/ibm440sp.h
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/arch/ppc/platforms/4xx/ibm440sp.h	2005-02-03 06:42:41 -08:00
@@ -0,0 +1,64 @@
+/*
+ * arch/ppc/platforms/4xx/ibm440sp.h
+ *
+ * PPC440SP definitions
+ *
+ * Matt Porter <mporter@kernel.crashing.org>
+ *
+ * Copyright 2004-2005 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifdef __KERNEL__
+#ifndef __PPC_PLATFORMS_IBM440SP_H
+#define __PPC_PLATFORMS_IBM440SP_H
+
+#include <linux/config.h>
+
+#include <asm/ibm44x.h>
+
+/* UART */
+#define PPC440SP_UART0_ADDR	0x00000001f0000200ULL
+#define PPC440SP_UART1_ADDR	0x00000001f0000300ULL
+#define PPC440SP_UART2_ADDR	0x00000001f0000600ULL
+#define UART0_INT		0
+#define UART1_INT		1
+#define UART2_INT		2
+
+/* Clock and Power Management */
+#define IBM_CPM_IIC0		0x80000000	/* IIC interface */
+#define IBM_CPM_IIC1		0x40000000	/* IIC interface */
+#define IBM_CPM_PCI		0x20000000	/* PCI bridge */
+#define IBM_CPM_CPU		    0x02000000	/* processor core */
+#define IBM_CPM_DMA		    0x01000000	/* DMA controller */
+#define IBM_CPM_BGO		    0x00800000	/* PLB to OPB bus arbiter */
+#define IBM_CPM_BGI		    0x00400000	/* OPB to PLB bridge */
+#define IBM_CPM_EBC		    0x00200000	/* External Bux Controller */
+#define IBM_CPM_EBM		    0x00100000	/* Ext Bus Master Interface */
+#define IBM_CPM_DMC		    0x00080000	/* SDRAM peripheral controller */
+#define IBM_CPM_PLB		    0x00040000	/* PLB bus arbiter */
+#define IBM_CPM_SRAM		0x00020000	/* SRAM memory controller */
+#define IBM_CPM_PPM		    0x00002000	/* PLB Performance Monitor */
+#define IBM_CPM_UIC1		0x00001000	/* Universal Interrupt Controller */
+#define IBM_CPM_GPIO0		0x00000800	/* General Purpose IO (??) */
+#define IBM_CPM_GPT		    0x00000400	/* General Purpose Timers  */
+#define IBM_CPM_UART0		0x00000200	/* serial port 0 */
+#define IBM_CPM_UART1		0x00000100	/* serial port 1 */
+#define IBM_CPM_UART2		0x00000100	/* serial port 1 */
+#define IBM_CPM_UIC0		0x00000080	/* Universal Interrupt Controller */
+#define IBM_CPM_TMRCLK		0x00000040	/* CPU timers */
+#define IBM_CPM_EMAC0  		0x00000020	/* EMAC 0     */
+
+#define DFLT_IBM4xx_PM		~(IBM_CPM_UIC | IBM_CPM_UIC1 | IBM_CPM_CPU \
+				| IBM_CPM_EBC | IBM_CPM_SRAM | IBM_CPM_BGO \
+				| IBM_CPM_EBM | IBM_CPM_PLB | IBM_CPM_OPB \
+				| IBM_CPM_TMRCLK | IBM_CPM_DMA | IBM_CPM_PCI \
+				| IBM_CPM_TAHOE0 | IBM_CPM_TAHOE1 \
+				| IBM_CPM_EMAC0 | IBM_CPM_EMAC1 \
+			  	| IBM_CPM_EMAC2 | IBM_CPM_EMAC3 )
+#endif /* __PPC_PLATFORMS_IBM440SP_H */
+#endif /* __KERNEL__ */
diff -Nru a/arch/ppc/platforms/4xx/luan.c b/arch/ppc/platforms/4xx/luan.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/arch/ppc/platforms/4xx/luan.c	2005-02-03 06:42:41 -08:00
@@ -0,0 +1,387 @@
+/*
+ * arch/ppc/platforms/4xx/luan.c
+ *
+ * Luan board specific routines
+ *
+ * Matt Porter <mporter@kernel.crashing.org>
+ *
+ * Copyright 2004-2005 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/major.h>
+#include <linux/blkdev.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <linux/initrd.h>
+#include <linux/irq.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/ocp.h>
+#include <asm/pci-bridge.h>
+#include <asm/time.h>
+#include <asm/todc.h>
+#include <asm/bootinfo.h>
+#include <asm/ppc4xx_pic.h>
+#include <asm/ppcboot.h>
+
+#include <syslib/ibm44x_common.h>
+#include <syslib/ibm440gx_common.h>
+#include <syslib/ibm440sp_common.h>
+
+/*
+ * This is a horrible kludge, we eventually need to abstract this
+ * generic PHY stuff, so the  standard phy mode defines can be
+ * easily used from arch code.
+ */
+#include "../../../../drivers/net/ibm_emac/ibm_emac_phy.h"
+
+bd_t __res;
+
+static struct ibm44x_clocks clocks __initdata;
+
+static void __init
+luan_calibrate_decr(void)
+{
+	unsigned int freq;
+
+	if (mfspr(SPRN_CCR1) & CCR1_TCS)
+		freq = LUAN_TMR_CLK;
+	else
+		freq = clocks.cpu;
+
+	ibm44x_calibrate_decr(freq);
+}
+
+static int
+luan_show_cpuinfo(struct seq_file *m)
+{
+	seq_printf(m, "vendor\t\t: IBM\n");
+	seq_printf(m, "machine\t\t: PPC440SP EVB (Luan)\n");
+
+	return 0;
+}
+
+static inline int
+luan_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	struct pci_controller *hose = pci_bus_to_hose(dev->bus->number);
+
+	/* PCIX0 in adapter mode, no host interrupt routing */
+
+	/* PCIX1 */
+	if (hose->index == 0) {
+		static char pci_irq_table[][4] =
+		/*
+		 *	PCI IDSEL/INTPIN->INTLINE
+		 *	  A   B   C   D
+		 */
+		{
+			{ 49, 49, 49, 49 },	/* IDSEL 1 - PCIX1 Slot 0 */
+			{ 49, 49, 49, 49 },	/* IDSEL 2 - PCIX1 Slot 1 */
+			{ 49, 49, 49, 49 },	/* IDSEL 3 - PCIX1 Slot 2 */
+			{ 49, 49, 49, 49 },	/* IDSEL 4 - PCIX1 Slot 3 */
+		};
+		const long min_idsel = 1, max_idsel = 4, irqs_per_slot = 4;
+		return PCI_IRQ_TABLE_LOOKUP;
+	/* PCIX2 */
+	} else if (hose->index == 1) {
+		static char pci_irq_table[][4] =
+		/*
+		 *	PCI IDSEL/INTPIN->INTLINE
+		 *	  A   B   C   D
+		 */
+		{
+			{ 50, 50, 50, 50 },	/* IDSEL 1 - PCIX2 Slot 0 */
+			{ 50, 50, 50, 50 },	/* IDSEL 2 - PCIX2 Slot 1 */
+			{ 50, 50, 50, 50 },	/* IDSEL 3 - PCIX2 Slot 2 */
+			{ 50, 50, 50, 50 },	/* IDSEL 4 - PCIX2 Slot 3 */
+		};
+		const long min_idsel = 1, max_idsel = 4, irqs_per_slot = 4;
+		return PCI_IRQ_TABLE_LOOKUP;
+	}
+	return -1;
+}
+
+static void __init luan_set_emacdata(void)
+{
+	struct ocp_def *def;
+	struct ocp_func_emac_data *emacdata;
+
+	/* Set phy_map, phy_mode, and mac_addr for the EMAC */
+	def = ocp_get_one_device(OCP_VENDOR_IBM, OCP_FUNC_EMAC, 0);
+	emacdata = def->additions;
+	emacdata->phy_map = 0x00000001;	/* Skip 0x00 */
+	emacdata->phy_mode = PHY_MODE_GMII;
+	memcpy(emacdata->mac_addr, __res.bi_enetaddr, 6);
+}
+
+#define PCIX_READW(offset) \
+	(readw((void *)((u32)pcix_reg_base+offset)))
+
+#define PCIX_WRITEW(value, offset) \
+	(writew(value, (void *)((u32)pcix_reg_base+offset)))
+
+#define PCIX_WRITEL(value, offset) \
+	(writel(value, (void *)((u32)pcix_reg_base+offset)))
+
+static void __init
+luan_setup_pcix(void)
+{
+	int i;
+	void *pcix_reg_base;
+
+	for (i=0;i<3;i++) {
+		pcix_reg_base = ioremap64(PCIX0_REG_BASE + i*PCIX_REG_OFFSET, PCIX_REG_SIZE);
+
+		/* Enable PCIX0 I/O, Mem, and Busmaster cycles */
+		PCIX_WRITEW(PCIX_READW(PCIX0_COMMAND) | PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER, PCIX0_COMMAND);
+
+		/* Disable all windows */
+		PCIX_WRITEL(0, PCIX0_POM0SA);
+		PCIX_WRITEL(0, PCIX0_POM1SA);
+		PCIX_WRITEL(0, PCIX0_POM2SA);
+		PCIX_WRITEL(0, PCIX0_PIM0SA);
+		PCIX_WRITEL(0, PCIX0_PIM0SAH);
+		PCIX_WRITEL(0, PCIX0_PIM1SA);
+		PCIX_WRITEL(0, PCIX0_PIM2SA);
+		PCIX_WRITEL(0, PCIX0_PIM2SAH);
+
+		/*
+		 * Setup 512MB PLB->PCI outbound mem window
+		 * (a_n000_0000->0_n000_0000)
+		 * */
+		PCIX_WRITEL(0x0000000a, PCIX0_POM0LAH);
+		PCIX_WRITEL(0x80000000 | i*LUAN_PCIX_MEM_SIZE, PCIX0_POM0LAL);
+		PCIX_WRITEL(0x00000000, PCIX0_POM0PCIAH);
+		PCIX_WRITEL(0x80000000 | i*LUAN_PCIX_MEM_SIZE, PCIX0_POM0PCIAL);
+		PCIX_WRITEL(0xe0000001, PCIX0_POM0SA);
+
+		/* Setup 2GB PCI->PLB inbound memory window at 0, enable MSIs */
+		PCIX_WRITEL(0x00000000, PCIX0_PIM0LAH);
+		PCIX_WRITEL(0x00000000, PCIX0_PIM0LAL);
+		PCIX_WRITEL(0xe0000007, PCIX0_PIM0SA);
+		PCIX_WRITEL(0xffffffff, PCIX0_PIM0SAH);
+
+		iounmap(pcix_reg_base);
+	}
+
+	eieio();
+}
+
+static void __init
+luan_setup_hose(struct pci_controller *hose,
+		int lower_mem,
+		int upper_mem,
+		int cfga,
+		int cfgd,
+		u64 pcix_io_base)
+{
+	char name[20];
+
+	sprintf(name, "PCIX%d host bridge", hose->index);
+
+	hose->pci_mem_offset = LUAN_PCIX_MEM_OFFSET;
+
+	pci_init_resource(&hose->io_resource,
+			LUAN_PCIX_LOWER_IO,
+			LUAN_PCIX_UPPER_IO,
+			IORESOURCE_IO,
+			name);
+
+	pci_init_resource(&hose->mem_resources[0],
+			lower_mem,
+			upper_mem,
+			IORESOURCE_MEM,
+			name);
+
+	hose->io_space.start = LUAN_PCIX_LOWER_IO;
+	hose->io_space.end = LUAN_PCIX_UPPER_IO;
+	hose->mem_space.start = lower_mem;
+	hose->mem_space.end = upper_mem;
+	isa_io_base =
+		(unsigned long)ioremap64(pcix_io_base, PCIX_IO_SIZE);
+	hose->io_base_virt = (void *)isa_io_base;
+
+	setup_indirect_pci(hose, cfga, cfgd);
+	hose->set_cfg_type = 1;
+}
+
+static void __init
+luan_setup_hoses(void)
+{
+	struct pci_controller *hose1, *hose2;
+
+	/* Configure windows on the PCI-X host bridge */
+	luan_setup_pcix();
+
+	/* Allocate hoses for PCIX1 and PCIX2 */
+	hose1 = pcibios_alloc_controller();
+	hose2 = pcibios_alloc_controller();
+	if (!hose1 || !hose2)
+		return;
+
+	/* Setup PCIX1 */
+	hose1->first_busno = 0;
+	hose1->last_busno = 0xff;
+
+	luan_setup_hose(hose1,
+			LUAN_PCIX1_LOWER_MEM,
+			LUAN_PCIX1_UPPER_MEM,
+			PCIX1_CFGA,
+			PCIX1_CFGD,
+			PCIX1_IO_BASE);
+
+	hose1->last_busno = pciauto_bus_scan(hose1, hose1->first_busno);
+
+	/* Setup PCIX2 */
+	hose2->first_busno = hose1->last_busno + 1;
+	hose2->last_busno = 0xff;
+
+	luan_setup_hose(hose2,
+			LUAN_PCIX2_LOWER_MEM,
+			LUAN_PCIX2_UPPER_MEM,
+			PCIX2_CFGA,
+			PCIX2_CFGD,
+			PCIX2_IO_BASE);
+
+	hose2->last_busno = pciauto_bus_scan(hose2, hose2->first_busno);
+
+	ppc_md.pci_swizzle = common_swizzle;
+	ppc_md.pci_map_irq = luan_map_irq;
+}
+
+TODC_ALLOC();
+
+static void __init
+luan_early_serial_map(void)
+{
+	struct uart_port port;
+
+	/* Setup ioremapped serial port access */
+	memset(&port, 0, sizeof(port));
+	port.membase = ioremap64(PPC440SP_UART0_ADDR, 8);
+	port.irq = UART0_INT;
+	port.uartclk = clocks.uart0;
+	port.regshift = 0;
+	port.iotype = SERIAL_IO_MEM;
+	port.flags = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
+	port.line = 0;
+
+	if (early_serial_setup(&port) != 0) {
+		printk("Early serial init of port 0 failed\n");
+	}
+
+	port.membase = ioremap64(PPC440SP_UART1_ADDR, 8);
+	port.irq = UART1_INT;
+	port.uartclk = clocks.uart1;
+	port.line = 1;
+
+	if (early_serial_setup(&port) != 0) {
+		printk("Early serial init of port 1 failed\n");
+	}
+
+	port.membase = ioremap64(PPC440SP_UART2_ADDR, 8);
+	port.irq = UART2_INT;
+	port.uartclk = BASE_BAUD;
+	port.line = 2;
+
+	if (early_serial_setup(&port) != 0) {
+		printk("Early serial init of port 2 failed\n");
+	}
+}
+
+static void __init
+luan_setup_arch(void)
+{
+	luan_set_emacdata();
+
+#if !defined(CONFIG_BDI_SWITCH)
+	/*
+	 * The Abatron BDI JTAG debugger does not tolerate others
+	 * mucking with the debug registers.
+	 */
+        mtspr(SPRN_DBCR0, (DBCR0_TDE | DBCR0_IDM));
+#endif
+
+	/*
+	 * Determine various clocks.
+	 * To be completely correct we should get SysClk
+	 * from FPGA, because it can be changed by on-board switches
+	 * --ebs
+	 */
+	/* 440GX and 440SP clocking is the same -mdp */
+	ibm440gx_get_clocks(&clocks, 33333333, 6 * 1843200);
+	ocp_sys_info.opb_bus_freq = clocks.opb;
+
+	/* init to some ~sane value until calibrate_delay() runs */
+        loops_per_jiffy = 50000000/HZ;
+
+	/* Setup PCIXn host bridges */
+	luan_setup_hoses();
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start)
+		ROOT_DEV = Root_RAM0;
+	else
+#endif
+#ifdef CONFIG_ROOT_NFS
+		ROOT_DEV = Root_NFS;
+#else
+		ROOT_DEV = Root_HDA1;
+#endif
+
+	luan_early_serial_map();
+
+	/* Identify the system */
+	printk("Luan port (MontaVista Software, Inc. <source@mvista.com>)\n");
+}
+
+void __init platform_init(unsigned long r3, unsigned long r4,
+		unsigned long r5, unsigned long r6, unsigned long r7)
+{
+	parse_bootinfo(find_bootinfo());
+
+	/*
+	 * If we were passed in a board information, copy it into the
+	 * residual data area.
+	 */
+	if (r3)
+		__res = *(bd_t *)(r3 + KERNELBASE);
+
+	ibm44x_platform_init();
+
+	ppc_md.setup_arch = luan_setup_arch;
+	ppc_md.show_cpuinfo = luan_show_cpuinfo;
+	ppc_md.find_end_of_memory = ibm440sp_find_end_of_memory;
+	ppc_md.get_irq = NULL;		/* Set in ppc4xx_pic_init() */
+
+	ppc_md.calibrate_decr = luan_calibrate_decr;
+#ifdef CONFIG_KGDB
+	ppc_md.early_serial_map = luan_early_serial_map;
+#endif
+}
diff -Nru a/arch/ppc/platforms/4xx/luan.h b/arch/ppc/platforms/4xx/luan.h
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/arch/ppc/platforms/4xx/luan.h	2005-02-03 06:42:41 -08:00
@@ -0,0 +1,80 @@
+/*
+ * arch/ppc/platforms/4xx/luan.h
+ *
+ * Luan board definitions
+ *
+ * Matt Porter <mporter@kernel.crashing.org>
+ *
+ * Copyright 2004-2005 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_LUAN_H__
+#define __ASM_LUAN_H__
+
+#include <linux/config.h>
+#include <platforms/4xx/ibm440sp.h>
+
+/* F/W TLB mapping used in bootloader glue to reset EMAC */
+#define PPC44x_EMAC0_MR0	0xa0000800
+
+/* Location of MAC addresses in PIBS image */
+#define PIBS_FLASH_BASE		0xffe00000
+#define PIBS_MAC_BASE		(PIBS_FLASH_BASE+0x1b0400)
+
+/* External timer clock frequency */
+#define LUAN_TMR_CLK		25000000
+
+/* Flash */
+#define LUAN_FPGA_REG_0			0x0000000148300000ULL
+#define LUAN_BOOT_LARGE_FLASH(x)	(x & 0x40)
+#define LUAN_SMALL_FLASH_LOW		0x00000001ff900000ULL
+#define LUAN_SMALL_FLASH_HIGH		0x00000001ffe00000ULL
+#define LUAN_SMALL_FLASH_SIZE		0x100000
+#define LUAN_LARGE_FLASH_LOW		0x00000001ff800000ULL
+#define LUAN_LARGE_FLASH_HIGH		0x00000001ffc00000ULL
+#define LUAN_LARGE_FLASH_SIZE		0x400000
+
+/*
+ * Serial port defines
+ */
+#define RS_TABLE_SIZE	3
+
+/* PIBS defined UART mappings, used before early_serial_setup */
+#define UART0_IO_BASE	(u8 *) 0xa0000200
+#define UART1_IO_BASE	(u8 *) 0xa0000300
+#define UART2_IO_BASE	(u8 *) 0xa0000600
+
+#define BASE_BAUD	11059200
+#define STD_UART_OP(num)					\
+	{ 0, BASE_BAUD, 0, UART##num##_INT,			\
+		(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),	\
+		iomem_base: UART##num##_IO_BASE,		\
+		io_type: SERIAL_IO_MEM},
+
+#define SERIAL_PORT_DFNS	\
+	STD_UART_OP(0)		\
+	STD_UART_OP(1)		\
+	STD_UART_OP(2)
+
+/* PCI support */
+#define LUAN_PCIX_LOWER_IO	0x00000000
+#define LUAN_PCIX_UPPER_IO	0x0000ffff
+#define LUAN_PCIX0_LOWER_MEM	0x80000000
+#define LUAN_PCIX0_UPPER_MEM	0x9fffffff
+#define LUAN_PCIX1_LOWER_MEM	0xa0000000
+#define LUAN_PCIX1_UPPER_MEM	0xbfffffff
+#define LUAN_PCIX2_LOWER_MEM	0xc0000000
+#define LUAN_PCIX2_UPPER_MEM	0xdfffffff
+
+#define LUAN_PCIX_MEM_SIZE	0x20000000
+#define LUAN_PCIX_MEM_OFFSET	0x00000000
+
+#endif				/* __ASM_LUAN_H__ */
+#endif				/* __KERNEL__ */
diff -Nru a/arch/ppc/platforms/4xx/ocotea.c b/arch/ppc/platforms/4xx/ocotea.c
--- a/arch/ppc/platforms/4xx/ocotea.c	2005-01-03 15:49:19 -08:00
+++ b/arch/ppc/platforms/4xx/ocotea.c	2005-02-03 06:42:41 -08:00
@@ -5,7 +5,7 @@
  *
  * Matt Porter <mporter@kernel.crashing.org>
  *
- * Copyright 2003-2004 MontaVista Software Inc.
+ * Copyright 2003-2005 MontaVista Software Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -163,7 +163,7 @@
 {
 	void *pcix_reg_base;
 
-	pcix_reg_base = ioremap64(PCIX0_REG_BASE, PCIX0_REG_SIZE);
+	pcix_reg_base = ioremap64(PCIX0_REG_BASE, PCIX_REG_SIZE);
 
 	/* Enable PCIX0 I/O, Mem, and Busmaster cycles */
 	PCIX_WRITEW(PCIX_READW(PCIX0_COMMAND) | PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER, PCIX0_COMMAND);
diff -Nru a/arch/ppc/platforms/4xx/ocotea.h b/arch/ppc/platforms/4xx/ocotea.h
--- a/arch/ppc/platforms/4xx/ocotea.h	2004-10-05 23:05:22 -07:00
+++ b/arch/ppc/platforms/4xx/ocotea.h	2005-02-03 06:42:41 -08:00
@@ -3,9 +3,9 @@
  *
  * Ocotea board definitions
  *
- * Matt Porter <mporter@mvista.com>
+ * Matt Porter <mporter@kernel.crashing.org>
  *
- * Copyright 2003 MontaVista Software Inc.
+ * Copyright 2003-2005 MontaVista Software Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -22,13 +22,13 @@
 #include <platforms/4xx/ibm440gx.h>
 
 /* F/W TLB mapping used in bootloader glue to reset EMAC */
-#define PPC44x_EMAC0_MR0	0xE0000800
+#define PPC44x_EMAC0_MR0	0xe0000800
 
 /* Location of MAC addresses in PIBS image */
-#define OCOTEA_PIBS_FLASH	0xfff00000
-#define OCOTEA_PIBS_MAC_BASE	(OCOTEA_PIBS_FLASH+0xb0500)
-#define OCOTEA_PIBS_MAC_SIZE	0x200
-#define OCOTEA_PIBS_MAC_OFFSET	0x100
+#define PIBS_FLASH_BASE		0xfff00000
+#define PIBS_MAC_BASE		(PIBS_FLASH_BASE+0xb0500)
+#define PIBS_MAC_SIZE		0x200
+#define PIBS_MAC_OFFSET		0x100
 
 /* External timer clock frequency */
 #define OCOTEA_TMR_CLK	25000000
diff -Nru a/arch/ppc/syslib/Makefile b/arch/ppc/syslib/Makefile
--- a/arch/ppc/syslib/Makefile	2005-01-20 20:56:31 -08:00
+++ b/arch/ppc/syslib/Makefile	2005-02-03 06:42:41 -08:00
@@ -13,6 +13,7 @@
 obj-$(CONFIG_44x)		+= ibm44x_common.o
 obj-$(CONFIG_440GP)		+= ibm440gp_common.o
 obj-$(CONFIG_440GX)		+= ibm440gx_common.o
+obj-$(CONFIG_440SP)		+= ibm440gx_common.o ibm440sp_common.o
 ifeq ($(CONFIG_4xx),y)
 ifeq ($(CONFIG_VIRTEX_II_PRO),y)
 obj-$(CONFIG_40x)		+= xilinx_pic.o
@@ -52,6 +53,7 @@
 obj-$(CONFIG_K2)		+= i8259.o indirect_pci.o todc_time.o \
 					pci_auto.o
 obj-$(CONFIG_LOPEC)		+= i8259.o pci_auto.o todc_time.o
+obj-$(CONFIG_LUAN)		+= indirect_pci.o pci_auto.o todc_time.o
 obj-$(CONFIG_KATANA)		+= pci_auto.o
 obj-$(CONFIG_MCPN765)		+= todc_time.o indirect_pci.o pci_auto.o \
 					open_pic.o i8259.o hawk_common.o
diff -Nru a/arch/ppc/syslib/ibm440sp_common.c b/arch/ppc/syslib/ibm440sp_common.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/arch/ppc/syslib/ibm440sp_common.c	2005-02-03 06:42:41 -08:00
@@ -0,0 +1,71 @@
+/*
+ * arch/ppc/syslib/ibm440sp_common.c
+ *
+ * PPC440SP system library
+ *
+ * Matt Porter <mporter@kernel.crashing.org>
+ * Copyright 2002-2005 MontaVista Software Inc.
+ *
+ * Eugene Surovegin <eugene.surovegin@zultys.com> or <ebs@ebshome.net>
+ * Copyright (c) 2003, 2004 Zultys Technologies
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/serial.h>
+
+#include <asm/param.h>
+#include <asm/ibm44x.h>
+#include <asm/mmu.h>
+#include <asm/machdep.h>
+#include <asm/time.h>
+#include <asm/ppc4xx_pic.h>
+
+/*
+ * Read the 440SP memory controller to get size of system memory.
+ */
+unsigned long __init ibm440sp_find_end_of_memory(void)
+{
+	u32 i;
+	u32 mem_size = 0;
+
+	/* Read two bank sizes and sum */
+	for (i=0; i<2; i++)
+		switch (mfdcr(DCRN_MQ0_BS0BAS + i) & MQ0_CONFIG_SIZE_MASK) {
+			case MQ0_CONFIG_SIZE_8M:
+				mem_size += PPC44x_MEM_SIZE_8M;
+				break;
+			case MQ0_CONFIG_SIZE_16M:
+				mem_size += PPC44x_MEM_SIZE_16M;
+				break;
+			case MQ0_CONFIG_SIZE_32M:
+				mem_size += PPC44x_MEM_SIZE_32M;
+				break;
+			case MQ0_CONFIG_SIZE_64M:
+				mem_size += PPC44x_MEM_SIZE_64M;
+				break;
+			case MQ0_CONFIG_SIZE_128M:
+				mem_size += PPC44x_MEM_SIZE_128M;
+				break;
+			case MQ0_CONFIG_SIZE_256M:
+				mem_size += PPC44x_MEM_SIZE_256M;
+				break;
+			case MQ0_CONFIG_SIZE_512M:
+				mem_size += PPC44x_MEM_SIZE_512M;
+				break;
+			case MQ0_CONFIG_SIZE_1G:
+				mem_size += PPC44x_MEM_SIZE_1G;
+				break;
+			case MQ0_CONFIG_SIZE_2G:
+				mem_size += PPC44x_MEM_SIZE_2G;
+				break;
+			default:
+				break;
+		}
+	return mem_size;
+}
diff -Nru a/arch/ppc/syslib/ibm440sp_common.h b/arch/ppc/syslib/ibm440sp_common.h
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/arch/ppc/syslib/ibm440sp_common.h	2005-02-03 06:42:41 -08:00
@@ -0,0 +1,25 @@
+/*
+ * arch/ppc/syslib/ibm440sp_common.h
+ *
+ * PPC440SP system library
+ *
+ * Matt Porter <mporter@kernel.crashing.org>
+ * Copyright 2004-2005 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#ifdef __KERNEL__
+#ifndef __PPC_SYSLIB_IBM440SP_COMMON_H
+#define __PPC_SYSLIB_IBM440SP_COMMON_H
+
+#ifndef __ASSEMBLY__
+
+extern unsigned long __init ibm440sp_find_end_of_memory(void);
+
+#endif /* __ASSEMBLY__ */
+#endif /* __PPC_SYSLIB_IBM440SP_COMMON_H */
+#endif /* __KERNEL__ */
diff -Nru a/arch/ppc/syslib/ibm44x_common.c b/arch/ppc/syslib/ibm44x_common.c
--- a/arch/ppc/syslib/ibm44x_common.c	2005-01-30 22:22:38 -08:00
+++ b/arch/ppc/syslib/ibm44x_common.c	2005-02-03 06:42:41 -08:00
@@ -4,7 +4,7 @@
  * PPC44x system library
  *
  * Matt Porter <mporter@kernel.crashing.org>
- * Copyright 2002-2004 MontaVista Software Inc.
+ * Copyright 2002-2005 MontaVista Software Inc.
  *
  * Eugene Surovegin <eugene.surovegin@zultys.com> or <ebs@ebshome.net>
  * Copyright (c) 2003, 2004 Zultys Technologies
@@ -39,11 +39,17 @@
 	 * address in the 440's 36-bit address space.  Fix
 	 * them up with the appropriate ERPN
 	 */
-	if ((addr >= PPC44x_IO_LO) && (addr < PPC44x_IO_HI))
+	if ((addr >= PPC44x_IO_LO) && (addr <= PPC44x_IO_HI))
 		page_4gb = PPC44x_IO_PAGE;
-	else if ((addr >= PPC44x_PCICFG_LO) && (addr < PPC44x_PCICFG_HI))
+	else if ((addr >= PPC44x_PCI0CFG_LO) && (addr <= PPC44x_PCI0CFG_HI))
 		page_4gb = PPC44x_PCICFG_PAGE;
-	else if ((addr >= PPC44x_PCIMEM_LO) && (addr < PPC44x_PCIMEM_HI))
+#ifdef CONFIG_440SP
+	else if ((addr >= PPC44x_PCI1CFG_LO) && (addr <= PPC44x_PCI1CFG_HI))
+		page_4gb = PPC44x_PCICFG_PAGE;
+	else if ((addr >= PPC44x_PCI2CFG_LO) && (addr <= PPC44x_PCI2CFG_HI))
+		page_4gb = PPC44x_PCICFG_PAGE;
+#endif
+	else if ((addr >= PPC44x_PCIMEM_LO) && (addr <= PPC44x_PCIMEM_HI))
 		page_4gb = PPC44x_PCIMEM_PAGE;
 
 	return (page_4gb | addr);
diff -Nru a/arch/ppc/syslib/mv64x60.c b/arch/ppc/syslib/mv64x60.c
--- a/arch/ppc/syslib/mv64x60.c	2005-01-30 22:22:37 -08:00
+++ b/arch/ppc/syslib/mv64x60.c	2005-02-03 06:42:42 -08:00
@@ -32,7 +32,7 @@
 
 
 u8		mv64x60_pci_exclude_bridge = 1;
-spinlock_t	mv64x60_lock; /* Only really used by PIC code once init done */
+spinlock_t	mv64x60_lock = SPIN_LOCK_UNLOCKED;
 
 static phys_addr_t 	mv64x60_bridge_pbase = 0;
 static void 		*mv64x60_bridge_vbase = 0;
diff -Nru a/arch/ppc/syslib/ppc4xx_dma.c b/arch/ppc/syslib/ppc4xx_dma.c
--- a/arch/ppc/syslib/ppc4xx_dma.c	2005-01-07 21:44:28 -08:00
+++ b/arch/ppc/syslib/ppc4xx_dma.c	2005-02-03 06:42:41 -08:00
@@ -512,6 +512,8 @@
 		return DMA_STATUS_BAD_CHANNEL;
 	}
 
+	memcpy(p_dma_ch, &dma_channels[dmanr], sizeof (ppc_dma_ch_t));
+
 #if DCRN_POL > 0
 	polarity = mfdcr(DCRN_POL);
 #else
@@ -604,6 +606,84 @@
 	return (GET_DMA_PW(control));
 }
 
+/*
+ * Clears the channel status bits
+ */
+int
+ppc4xx_clr_dma_status(unsigned int dmanr)
+{
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk(KERN_ERR "ppc4xx_clr_dma_status: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	mtdcr(DCRN_DMASR, ((u32)DMA_CH0_ERR | (u32)DMA_CS0 | (u32)DMA_TS0) >> dmanr);
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Enables the burst on the channel (BTEN bit in the control/count register)
+ * Note:
+ * For scatter/gather dma, this function MUST be called before the
+ * ppc4xx_alloc_dma_handle() func as the chan count register is copied into the
+ * sgl list and used as each sgl element is added.
+ */
+int
+ppc4xx_enable_burst(unsigned int dmanr)
+{
+	unsigned int ctc;
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk(KERN_ERR "ppc4xx_enable_burst: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+        ctc = mfdcr(DCRN_DMACT0 + (dmanr * 0x8)) | DMA_CTC_BTEN;
+	mtdcr(DCRN_DMACT0 + (dmanr * 0x8), ctc);
+	return DMA_STATUS_GOOD;
+}
+/*
+ * Disables the burst on the channel (BTEN bit in the control/count register)
+ * Note:
+ * For scatter/gather dma, this function MUST be called before the
+ * ppc4xx_alloc_dma_handle() func as the chan count register is copied into the
+ * sgl list and used as each sgl element is added.
+ */
+int
+ppc4xx_disable_burst(unsigned int dmanr)
+{
+	unsigned int ctc;
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk(KERN_ERR "ppc4xx_disable_burst: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	ctc = mfdcr(DCRN_DMACT0 + (dmanr * 0x8)) &~ DMA_CTC_BTEN;
+	mtdcr(DCRN_DMACT0 + (dmanr * 0x8), ctc);
+	return DMA_STATUS_GOOD;
+}
+/*
+ * Sets the burst size (number of peripheral widths) for the channel
+ * (BSIZ bits in the control/count register))
+ * must be one of:
+ *    DMA_CTC_BSIZ_2
+ *    DMA_CTC_BSIZ_4
+ *    DMA_CTC_BSIZ_8
+ *    DMA_CTC_BSIZ_16
+ * Note:
+ * For scatter/gather dma, this function MUST be called before the
+ * ppc4xx_alloc_dma_handle() func as the chan count register is copied into the
+ * sgl list and used as each sgl element is added.
+ */
+int
+ppc4xx_set_burst_size(unsigned int dmanr, unsigned int bsize)
+{
+	unsigned int ctc;
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk(KERN_ERR "ppc4xx_set_burst_size: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	ctc = mfdcr(DCRN_DMACT0 + (dmanr * 0x8)) &~ DMA_CTC_BSIZ_MSK;
+	ctc |= (bsize & DMA_CTC_BSIZ_MSK);
+	mtdcr(DCRN_DMACT0 + (dmanr * 0x8), ctc);
+	return DMA_STATUS_GOOD;
+}
 
 EXPORT_SYMBOL(ppc4xx_init_dma_channel);
 EXPORT_SYMBOL(ppc4xx_get_channel_config);
@@ -622,3 +702,7 @@
 EXPORT_SYMBOL(ppc4xx_enable_dma_interrupt);
 EXPORT_SYMBOL(ppc4xx_disable_dma_interrupt);
 EXPORT_SYMBOL(ppc4xx_get_dma_status);
+EXPORT_SYMBOL(ppc4xx_clr_dma_status);
+EXPORT_SYMBOL(ppc4xx_enable_burst);
+EXPORT_SYMBOL(ppc4xx_disable_burst);
+EXPORT_SYMBOL(ppc4xx_set_burst_size);
diff -Nru a/arch/ppc/syslib/ppc4xx_sgdma.c b/arch/ppc/syslib/ppc4xx_sgdma.c
--- a/arch/ppc/syslib/ppc4xx_sgdma.c	2004-08-07 15:02:29 -07:00
+++ b/arch/ppc/syslib/ppc4xx_sgdma.c	2005-02-03 06:42:41 -08:00
@@ -120,6 +120,12 @@
 		psgl->ptail = psgl->phead;
 		psgl->ptail_dma = psgl->phead_dma;
 	} else {
+		if(p_dma_ch->int_on_final_sg) {
+			/* mask out all dma interrupts, except error, on tail
+			before adding new tail. */
+			psgl->ptail->control_count &=
+				~(SG_TCI_ENABLE | SG_ETI_ENABLE);
+		}
 		psgl->ptail->next = psgl->ptail_dma + sizeof(ppc_sgl_t);
 		psgl->ptail++;
 		psgl->ptail_dma += sizeof(ppc_sgl_t);
@@ -217,7 +223,7 @@
 	}
 
 	sgl_addr = (ppc_sgl_t *) __va(mfdcr(DCRN_ASG0 + (psgl->dmanr * 0x8)));
-	count_left = mfdcr(DCRN_DMACT0 + (psgl->dmanr * 0x8));
+	count_left = mfdcr(DCRN_DMACT0 + (psgl->dmanr * 0x8)) & SG_COUNT_MASK;
 
 	if (!sgl_addr) {
 		printk("ppc4xx_get_dma_sgl_residue: sgl addr register is null\n");
@@ -351,10 +357,11 @@
 int
 ppc4xx_alloc_dma_handle(sgl_handle_t * phandle, unsigned int mode, unsigned int dmanr)
 {
-	sgl_list_info_t *psgl;
+	sgl_list_info_t *psgl=NULL;
 	dma_addr_t dma_addr;
 	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
 	uint32_t sg_command;
+	uint32_t ctc_settings;
 	void *ret;
 
 	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
@@ -411,6 +418,11 @@
 	/* Enable SGL control access */
 	mtdcr(DCRN_ASGC, sg_command);
 	psgl->sgl_control = SG_ERI_ENABLE | SG_LINK;
+
+	/* keep control count register settings */
+	ctc_settings = mfdcr(DCRN_DMACT0 + (dmanr * 0x8))
+		& (DMA_CTC_BSIZ_MSK | DMA_CTC_BTEN); /*burst mode settings*/
+	psgl->sgl_control |= ctc_settings;
 
 	if (p_dma_ch->int_enable) {
 		if (p_dma_ch->tce_enable)
diff -Nru a/arch/s390/defconfig b/arch/s390/defconfig
--- a/arch/s390/defconfig	2005-01-15 14:01:57 -08:00
+++ b/arch/s390/defconfig	2005-02-03 06:42:42 -08:00
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc1
-# Fri Jan 14 14:56:51 2005
+# Linux kernel version: 2.6.11-rc2
+# Mon Jan 31 16:27:12 2005
 #
 CONFIG_MMU=y
 CONFIG_RWSEM_XCHGADD_ALGORITHM=y
@@ -156,6 +156,7 @@
 #
 # Block devices
 #
+# CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=m
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_NBD=m
@@ -579,5 +580,5 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
+CONFIG_CRC32=m
 # CONFIG_LIBCRC32C is not set
diff -Nru a/arch/s390/kernel/compat_linux.c b/arch/s390/kernel/compat_linux.c
--- a/arch/s390/kernel/compat_linux.c	2005-01-25 13:50:22 -08:00
+++ b/arch/s390/kernel/compat_linux.c	2005-02-03 06:42:43 -08:00
@@ -355,136 +355,6 @@
 		return sys_ftruncate(fd, (high << 32) | low);
 }
 
-/* readdir & getdents */
-
-#define NAME_OFFSET(de) ((int) ((de)->d_name - (char *) (de)))
-#define ROUND_UP(x) (((x)+sizeof(u32)-1) & ~(sizeof(u32)-1))
-
-struct old_linux_dirent32 {
-	u32		d_ino;
-	u32		d_offset;
-	unsigned short	d_namlen;
-	char		d_name[1];
-};
-
-struct readdir_callback32 {
-	struct old_linux_dirent32 * dirent;
-	int count;
-};
-
-static int fillonedir(void * __buf, const char * name, int namlen,
-		      loff_t offset, ino_t ino, unsigned int d_type)
-{
-	struct readdir_callback32 * buf = (struct readdir_callback32 *) __buf;
-	struct old_linux_dirent32 * dirent;
-
-	if (buf->count)
-		return -EINVAL;
-	buf->count++;
-	dirent = buf->dirent;
-	put_user(ino, &dirent->d_ino);
-	put_user(offset, &dirent->d_offset);
-	put_user(namlen, &dirent->d_namlen);
-	copy_to_user(dirent->d_name, name, namlen);
-	put_user(0, dirent->d_name + namlen);
-	return 0;
-}
-
-asmlinkage long old32_readdir(unsigned int fd, struct old_linux_dirent32 *dirent, unsigned int count)
-{
-	int error = -EBADF;
-	struct file * file;
-	struct readdir_callback32 buf;
-
-	file = fget(fd);
-	if (!file)
-		goto out;
-
-	buf.count = 0;
-	buf.dirent = dirent;
-
-	error = vfs_readdir(file, fillonedir, &buf);
-	if (error < 0)
-		goto out_putf;
-	error = buf.count;
-
-out_putf:
-	fput(file);
-out:
-	return error;
-}
-
-struct linux_dirent32 {
-	u32		d_ino;
-	u32		d_off;
-	unsigned short	d_reclen;
-	char		d_name[1];
-};
-
-struct getdents_callback32 {
-	struct linux_dirent32 * current_dir;
-	struct linux_dirent32 * previous;
-	int count;
-	int error;
-};
-
-static int filldir(void * __buf, const char * name, int namlen, loff_t offset, ino_t ino,
-		   unsigned int d_type)
-{
-	struct linux_dirent32 * dirent;
-	struct getdents_callback32 * buf = (struct getdents_callback32 *) __buf;
-	int reclen = ROUND_UP(NAME_OFFSET(dirent) + namlen + 1);
-
-	buf->error = -EINVAL;	/* only used if we fail.. */
-	if (reclen > buf->count)
-		return -EINVAL;
-	dirent = buf->previous;
-	if (dirent)
-		put_user(offset, &dirent->d_off);
-	dirent = buf->current_dir;
-	buf->previous = dirent;
-	put_user(ino, &dirent->d_ino);
-	put_user(reclen, &dirent->d_reclen);
-	copy_to_user(dirent->d_name, name, namlen);
-	put_user(0, dirent->d_name + namlen);
-	buf->current_dir = ((void *)dirent) + reclen;
-	buf->count -= reclen;
-	return 0;
-}
-
-asmlinkage long sys32_getdents(unsigned int fd, struct linux_dirent32 *dirent, unsigned int count)
-{
-	struct file * file;
-	struct linux_dirent32 * lastdirent;
-	struct getdents_callback32 buf;
-	int error = -EBADF;
-
-	file = fget(fd);
-	if (!file)
-		goto out;
-
-	buf.current_dir = dirent;
-	buf.previous = NULL;
-	buf.count = count;
-	buf.error = 0;
-
-	error = vfs_readdir(file, filldir, &buf);
-	if (error < 0)
-		goto out_putf;
-	lastdirent = buf.previous;
-	error = buf.error;
-	if(lastdirent) {
-		put_user(file->f_pos, &lastdirent->d_off);
-		error = count - buf.count;
-	}
-out_putf:
-	fput(file);
-out:
-	return error;
-}
-
-/* end of readdir & getdents */
-
 int cp_compat_stat(struct kstat *stat, struct compat_stat *statbuf)
 {
 	int err;
diff -Nru a/arch/s390/kernel/compat_linux.h b/arch/s390/kernel/compat_linux.h
--- a/arch/s390/kernel/compat_linux.h	2005-01-04 18:48:19 -08:00
+++ b/arch/s390/kernel/compat_linux.h	2005-02-03 06:42:43 -08:00
@@ -50,9 +50,10 @@
 
 		/* POSIX.1b timers */
 		struct {
-			unsigned int	_timer1;
-			unsigned int	_timer2;
-                
+			timer_t _tid;		/* timer id */
+			int _overrun;		/* overrun count */
+			sigval_t _sigval;	/* same as below */
+			int _sys_private;       /* not to be passed to user */
 		} _timer;
 
 		/* POSIX.1b signals */
@@ -98,6 +99,8 @@
 #define si_addr		_sifields._sigfault._addr
 #define si_band		_sifields._sigpoll._band
 #define si_fd		_sifields._sigpoll._fd    
+#define si_tid		_sifields._timer._tid
+#define si_overrun	_sifields._timer._overrun
 
 /* asm/sigcontext.h */
 typedef union
diff -Nru a/arch/s390/kernel/compat_signal.c b/arch/s390/kernel/compat_signal.c
--- a/arch/s390/kernel/compat_signal.c	2005-01-04 18:48:19 -08:00
+++ b/arch/s390/kernel/compat_signal.c	2005-02-03 06:42:43 -08:00
@@ -95,10 +95,14 @@
 					  &to->si_addr);
 			break;
 		case __SI_POLL >> 16:
-		case __SI_TIMER >> 16:
 			err |= __put_user(from->si_band, &to->si_band);
 			err |= __put_user(from->si_fd, &to->si_fd);
 			break;
+		case __SI_TIMER >> 16:
+			err |= __put_user(from->si_tid, &to->si_tid);
+			err |= __put_user(from->si_overrun, &to->si_overrun);
+			err |= __put_user(from->si_int, &to->si_int);
+			break;
 		default:
 			break;
 		}
@@ -142,9 +146,13 @@
 			to->si_addr = (void *)(u64) (tmp & PSW32_ADDR_INSN);
 			break;
 		case __SI_POLL >> 16:
-		case __SI_TIMER >> 16:
 			err |= __get_user(to->si_band, &from->si_band);
 			err |= __get_user(to->si_fd, &from->si_fd);
+			break;
+		case __SI_TIMER >> 16:
+			err |= __get_user(to->si_tid, &from->si_tid);
+			err |= __get_user(to->si_overrun, &from->si_overrun);
+			err |= __get_user(to->si_int, &from->si_int);
 			break;
 		default:
 			break;
diff -Nru a/arch/s390/kernel/compat_wrapper.S b/arch/s390/kernel/compat_wrapper.S
--- a/arch/s390/kernel/compat_wrapper.S	2005-01-14 11:56:05 -08:00
+++ b/arch/s390/kernel/compat_wrapper.S	2005-02-03 06:42:43 -08:00
@@ -391,7 +391,7 @@
 	llgfr	%r2,%r2			# unsigned int
 	llgtr	%r3,%r3			# void *
 	llgfr	%r4,%r4			# unsigned int
-	jg	old32_readdir		# branch to system call
+	jg	compat_sys_old_readdir	# branch to system call
 
 	.globl  old32_mmap_wrapper 
 old32_mmap_wrapper:
@@ -639,7 +639,7 @@
 	llgfr	%r2,%r2			# unsigned int
 	llgtr	%r3,%r3			# void *
 	llgfr	%r4,%r4			# unsigned int
-	jg	sys32_getdents		# branch to system call
+	jg	compat_sys_getdents	# branch to system call
 
 	.globl  compat_sys_select_wrapper
 compat_sys_select_wrapper:
diff -Nru a/arch/s390/kernel/cpcmd.c b/arch/s390/kernel/cpcmd.c
--- a/arch/s390/kernel/cpcmd.c	2005-01-20 21:02:10 -08:00
+++ b/arch/s390/kernel/cpcmd.c	2005-02-03 06:42:42 -08:00
@@ -4,34 +4,41 @@
  *  S390 version
  *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
+ *               Christian Borntraeger (cborntra@de.ibm.com),
  */
 
-#include <linux/stddef.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/stddef.h>
 #include <linux/string.h>
 #include <asm/ebcdic.h>
-#include <linux/spinlock.h>
 #include <asm/cpcmd.h>
 #include <asm/system.h>
 
 static DEFINE_SPINLOCK(cpcmd_lock);
 static char cpcmd_buf[240];
 
-void cpcmd(char *cmd, char *response, int rlen)
+/*
+ * the caller of __cpcmd has to ensure that the response buffer is below 2 GB
+ */
+void __cpcmd(char *cmd, char *response, int rlen)
 {
-        const int mask = 0x40000000L;
+	const int mask = 0x40000000L;
 	unsigned long flags;
-        int cmdlen;
+	int cmdlen;
 
 	spin_lock_irqsave(&cpcmd_lock, flags);
 	cmdlen = strlen(cmd);
-	BUG_ON(cmdlen>240);
+	BUG_ON(cmdlen > 240);
 	strcpy(cpcmd_buf, cmd);
 	ASCEBC(cpcmd_buf, cmdlen);
 
 	if (response != NULL && rlen > 0) {
+		memset(response, 0, rlen);
 #ifndef CONFIG_ARCH_S390X
-                asm volatile ("LRA   2,0(%0)\n\t"
+		asm volatile ("LRA   2,0(%0)\n\t"
                               "LR    4,%1\n\t"
                               "O     4,%4\n\t"
                               "LRA   3,0(%2)\n\t"
@@ -78,3 +85,27 @@
 	spin_unlock_irqrestore(&cpcmd_lock, flags);
 }
 
+EXPORT_SYMBOL(__cpcmd);
+
+#ifdef CONFIG_ARCH_S390X
+void cpcmd(char *cmd, char *response, int rlen)
+{
+	char *lowbuf;
+	if ((rlen == 0) || (response == NULL)
+	    || !((unsigned long)response >> 31))
+		__cpcmd(cmd, response, rlen);
+	else {
+		lowbuf = kmalloc(rlen, GFP_KERNEL | GFP_DMA);
+		if (!lowbuf) {
+			printk(KERN_WARNING
+				"cpcmd: could not allocate response buffer\n");
+			return;
+		}
+		__cpcmd(cmd, lowbuf, rlen);
+		memcpy(response, lowbuf, rlen);
+		kfree(lowbuf);
+	}
+}
+
+EXPORT_SYMBOL(cpcmd);
+#endif		/* CONFIG_ARCH_S390X */
diff -Nru a/arch/s390/kernel/debug.c b/arch/s390/kernel/debug.c
--- a/arch/s390/kernel/debug.c	2004-10-25 12:47:52 -07:00
+++ b/arch/s390/kernel/debug.c	2005-02-03 06:42:42 -08:00
@@ -931,7 +931,7 @@
 	int rc = 0;
 	int i;
 	unsigned long flags;
-	mode_t mode = S_IFREG;
+	mode_t mode = S_IFREG | S_IRUSR | S_IWUSR;
 	struct proc_dir_entry *pde;
 
 	if (!id)
diff -Nru a/arch/s390/kernel/module.c b/arch/s390/kernel/module.c
--- a/arch/s390/kernel/module.c	2004-05-14 19:00:18 -07:00
+++ b/arch/s390/kernel/module.c	2005-02-03 06:42:42 -08:00
@@ -396,8 +396,7 @@
 		    const Elf_Shdr *sechdrs,
 		    struct module *me)
 {
-	if (me->arch.syminfo)
-		vfree(me->arch.syminfo);
+	vfree(me->arch.syminfo);
 	return 0;
 }
 
diff -Nru a/arch/s390/kernel/s390_ksyms.c b/arch/s390/kernel/s390_ksyms.c
--- a/arch/s390/kernel/s390_ksyms.c	2004-10-09 14:13:56 -07:00
+++ b/arch/s390/kernel/s390_ksyms.c	2005-02-03 06:42:42 -08:00
@@ -63,4 +63,3 @@
 EXPORT_SYMBOL(console_devno);
 EXPORT_SYMBOL(console_irq);
 EXPORT_SYMBOL(sys_wait4);
-EXPORT_SYMBOL(cpcmd);
diff -Nru a/arch/s390/kernel/setup.c b/arch/s390/kernel/setup.c
--- a/arch/s390/kernel/setup.c	2005-01-30 22:20:14 -08:00
+++ b/arch/s390/kernel/setup.c	2005-02-03 06:42:42 -08:00
@@ -76,8 +76,15 @@
 
 static char command_line[COMMAND_LINE_SIZE] = { 0, };
 
-static struct resource code_resource = { "Kernel code", 0x100000, 0 };
-static struct resource data_resource = { "Kernel data", 0, 0 };
+static struct resource code_resource = {
+	.name  = "Kernel code",
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
+};
+
+static struct resource data_resource = {
+	.name = "Kernel data",
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
+};
 
 /*
  * cpu_init() initializes state that is per-CPU.
@@ -184,11 +191,11 @@
 	char *ptr;
 
         if (MACHINE_IS_VM) {
-		cpcmd("QUERY CONSOLE", query_buffer, 1024);
+		__cpcmd("QUERY CONSOLE", query_buffer, 1024);
 		console_devno = simple_strtoul(query_buffer + 5, NULL, 16);
 		ptr = strstr(query_buffer, "SUBCHANNEL =");
 		console_irq = simple_strtoul(ptr + 13, NULL, 16);
-		cpcmd("QUERY TERM", query_buffer, 1024);
+		__cpcmd("QUERY TERM", query_buffer, 1024);
 		ptr = strstr(query_buffer, "CONMODE");
 		/*
 		 * Set the conmode to 3215 so that the device recognition 
@@ -197,7 +204,7 @@
 		 * 3215 and the 3270 driver will try to access the console
 		 * device (3215 as console and 3270 as normal tty).
 		 */
-		cpcmd("TERM CONMODE 3215", NULL, 0);
+		__cpcmd("TERM CONMODE 3215", NULL, 0);
 		if (ptr == NULL) {
 #if defined(CONFIG_SCLP_CONSOLE)
 			SET_CONSOLE_SCLP;
@@ -314,7 +321,6 @@
         unsigned long bootmap_size;
         unsigned long memory_start, memory_end;
         char c = ' ', cn, *to = command_line, *from = COMMAND_LINE;
-	struct resource *res;
 	unsigned long start_pfn, end_pfn;
         static unsigned int smptrap=0;
         unsigned long delay = 0;
@@ -472,6 +478,30 @@
         }
 #endif
 
+	for (i = 0; i < 16 && memory_chunk[i].size > 0; i++) {
+		struct resource *res;
+
+		res = alloc_bootmem_low(sizeof(struct resource));
+		res->flags = IORESOURCE_BUSY | IORESOURCE_MEM;
+
+		switch (memory_chunk[i].type) {
+		case CHUNK_READ_WRITE:
+			res->name = "System RAM";
+			break;
+		case CHUNK_READ_ONLY:
+			res->name = "System ROM";
+			res->flags |= IORESOURCE_READONLY;
+			break;
+		default:
+			res->name = "reserved";
+		}
+		res->start = memory_chunk[i].addr;
+		res->end = memory_chunk[i].addr +  memory_chunk[i].size - 1;
+		request_resource(&iomem_resource, res);
+		request_resource(res, &code_resource);
+		request_resource(res, &data_resource);
+	}
+
         /*
          * Setup lowcore for boot cpu
          */
@@ -523,14 +553,6 @@
 	 * Create kernel page tables and switch to virtual addressing.
 	 */
         paging_init();
-
-	res = alloc_bootmem_low(sizeof(struct resource));
-	res->start = 0;
-	res->end = memory_end;
-	res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
-	request_resource(&iomem_resource, res);
-	request_resource(res, &code_resource);
-	request_resource(res, &data_resource);
 
         /* Setup default console */
 	conmode_default();
diff -Nru a/arch/s390/mm/cmm.c b/arch/s390/mm/cmm.c
--- a/arch/s390/mm/cmm.c	2005-01-15 14:01:57 -08:00
+++ b/arch/s390/mm/cmm.c	2005-02-03 06:42:42 -08:00
@@ -19,7 +19,6 @@
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
-#include <asm/smp.h>
 
 #include "../../../drivers/s390/net/smsgiucv.h"
 
diff -Nru a/arch/s390/mm/extmem.c b/arch/s390/mm/extmem.c
--- a/arch/s390/mm/extmem.c	2005-01-30 22:33:46 -08:00
+++ b/arch/s390/mm/extmem.c	2005-02-03 06:42:42 -08:00
@@ -576,8 +576,8 @@
 			segtype_string[seg->range[i].start & 0xff]);
 	}
 	sprintf(cmd2, "SAVESEG %s", name);
-	cpcmd(cmd1, NULL, 80);
-	cpcmd(cmd2, NULL, 80);
+	cpcmd(cmd1, NULL, 0);
+	cpcmd(cmd2, NULL, 0);
 	spin_unlock(&dcss_lock);
 }
 
diff -Nru a/arch/s390/mm/mmap.c b/arch/s390/mm/mmap.c
--- a/arch/s390/mm/mmap.c	2004-10-18 22:26:36 -07:00
+++ b/arch/s390/mm/mmap.c	2005-02-03 06:42:42 -08:00
@@ -26,6 +26,7 @@
 
 #include <linux/personality.h>
 #include <linux/mm.h>
+#include <linux/module.h>
 
 /*
  * Top of mmap area (just below the process stack).
@@ -81,3 +82,5 @@
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
 }
+EXPORT_SYMBOL_GPL(arch_pick_mmap_layout);
+
diff -Nru a/arch/sparc64/kernel/binfmt_aout32.c b/arch/sparc64/kernel/binfmt_aout32.c
--- a/arch/sparc64/kernel/binfmt_aout32.c	2005-01-11 17:37:28 -08:00
+++ b/arch/sparc64/kernel/binfmt_aout32.c	2005-02-02 21:02:02 -08:00
@@ -335,7 +335,7 @@
 	if (!(orig_thr_flags & _TIF_32BIT)) {
 		unsigned long pgd_cache;
 
-		pgd_cache = ((unsigned long)current->mm->pgd[0])<<11UL;
+		pgd_cache = ((unsigned long)pgd_val(current->mm->pgd[0]))<<11;
 		__asm__ __volatile__("stxa\t%0, [%1] %2\n\t"
 				     "membar #Sync"
 				     : /* no outputs */
diff -Nru a/drivers/char/mmtimer.c b/drivers/char/mmtimer.c
--- a/drivers/char/mmtimer.c	2004-11-18 23:03:12 -08:00
+++ b/drivers/char/mmtimer.c	2005-01-28 15:38:57 -08:00
@@ -36,9 +36,7 @@
 #include <asm/sn/intr.h>
 #include <asm/sn/shub_mmr.h>
 #include <asm/sn/nodepda.h>
-
-/* This is ugly and jbarnes has promised me to fix this later */
-#include "../../arch/ia64/sn/include/shubio.h"
+#include <asm/sn/shubio.h>
 
 MODULE_AUTHOR("Jesse Barnes <jbarnes@sgi.com>");
 MODULE_DESCRIPTION("SGI Altix RTC Timer");
diff -Nru a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
--- a/drivers/cpufreq/cpufreq.c	2005-01-20 21:02:15 -08:00
+++ b/drivers/cpufreq/cpufreq.c	2005-02-03 06:42:40 -08:00
@@ -900,9 +900,12 @@
 
 	if (cpufreq_driver->resume) {
 		ret = cpufreq_driver->resume(cpu_policy);
-		printk(KERN_ERR "cpufreq: resume failed in ->resume step on CPU %u\n", cpu_policy->cpu);
-		cpufreq_cpu_put(cpu_policy);
-		return (ret);
+		if (ret) {
+			printk(KERN_ERR "cpufreq: resume failed in ->resume "
+					"step on CPU %u\n", cpu_policy->cpu);
+			cpufreq_cpu_put(cpu_policy);
+			return ret;
+		}
 	}
 
 	if (!(cpufreq_driver->flags & CPUFREQ_CONST_LOOPS)) {
diff -Nru a/drivers/i2c/busses/i2c-sis5595.c b/drivers/i2c/busses/i2c-sis5595.c
--- a/drivers/i2c/busses/i2c-sis5595.c	2004-10-19 16:46:13 -07:00
+++ b/drivers/i2c/busses/i2c-sis5595.c	2005-02-02 22:34:13 -08:00
@@ -181,9 +181,11 @@
 
 	if (force_addr) {
 		dev_info(&SIS5595_dev->dev, "forcing ISA address 0x%04X\n", sis5595_base);
-		if (!pci_write_config_word(SIS5595_dev, ACPI_BASE, sis5595_base))
+		if (pci_write_config_word(SIS5595_dev, ACPI_BASE, sis5595_base)
+		    != PCIBIOS_SUCCESSFUL)
 			goto error;
-		if (!pci_read_config_word(SIS5595_dev, ACPI_BASE, &a))
+		if (pci_read_config_word(SIS5595_dev, ACPI_BASE, &a)
+		    != PCIBIOS_SUCCESSFUL)
 			goto error;
 		if ((a & ~(SIS5595_EXTENT - 1)) != sis5595_base) {
 			/* doesn't work for some chips! */
@@ -192,13 +194,16 @@
 		}
 	}
 
-	if (!pci_read_config_byte(SIS5595_dev, SIS5595_ENABLE_REG, &val))
+	if (pci_read_config_byte(SIS5595_dev, SIS5595_ENABLE_REG, &val)
+	    != PCIBIOS_SUCCESSFUL)
 		goto error;
 	if ((val & 0x80) == 0) {
 		dev_info(&SIS5595_dev->dev, "enabling ACPI\n");
-		if (!pci_write_config_byte(SIS5595_dev, SIS5595_ENABLE_REG, val | 0x80))
+		if (pci_write_config_byte(SIS5595_dev, SIS5595_ENABLE_REG, val | 0x80)
+		    != PCIBIOS_SUCCESSFUL)
 			goto error;
-		if (!pci_read_config_byte(SIS5595_dev, SIS5595_ENABLE_REG, &val))
+		if (pci_read_config_byte(SIS5595_dev, SIS5595_ENABLE_REG, &val)
+		    != PCIBIOS_SUCCESSFUL)
 			goto error;
 		if ((val & 0x80) == 0) {
 			/* doesn't work for some chips? */
diff -Nru a/drivers/i2c/busses/i2c-viapro.c b/drivers/i2c/busses/i2c-viapro.c
--- a/drivers/i2c/busses/i2c-viapro.c	2004-12-18 09:34:28 -08:00
+++ b/drivers/i2c/busses/i2c-viapro.c	2005-02-02 22:33:16 -08:00
@@ -45,6 +45,8 @@
 #include <linux/init.h>
 #include <asm/io.h>
 
+static struct pci_dev *vt596_pdev;
+
 #define SMBBA1	   	 0x90
 #define SMBBA2     	 0x80
 #define SMBBA3     	 0xD0
@@ -231,8 +233,8 @@
 			len = data->block[0];
 			if (len < 0)
 				len = 0;
-			if (len > 32)
-				len = 32;
+			if (len > I2C_SMBUS_BLOCK_MAX)
+				len = I2C_SMBUS_BLOCK_MAX;
 			outb_p(len, SMBHSTDAT0);
 			i = inb_p(SMBHSTCNT);	/* Reset SMBBLKDAT */
 			for (i = 1; i <= len; i++)
@@ -266,6 +268,8 @@
 		break;
 	case VT596_BLOCK_DATA:
 		data->block[0] = inb_p(SMBHSTDAT0);
+		if (data->block[0] > I2C_SMBUS_BLOCK_MAX)
+			data->block[0] = I2C_SMBUS_BLOCK_MAX;
 		i = inb_p(SMBHSTCNT);	/* Reset SMBBLKDAT */
 		for (i = 1; i <= data->block[0]; i++)
 			data->block[i] = inb_p(SMBBLKDAT);
@@ -381,19 +385,23 @@
 	snprintf(vt596_adapter.name, I2C_NAME_SIZE,
 			"SMBus Via Pro adapter at %04x", vt596_smba);
 	
-	return i2c_add_adapter(&vt596_adapter);
+	vt596_pdev = pci_dev_get(pdev);
+	if (i2c_add_adapter(&vt596_adapter)) {
+		pci_dev_put(vt596_pdev);
+		vt596_pdev = NULL;
+	}
+
+	/* Always return failure here.  This is to allow other drivers to bind
+	 * to this pci device.  We don't really want to have control over the
+	 * pci device, we only wanted to read as few register values from it.
+	 */
+	return -ENODEV;
 
  release_region:
 	release_region(vt596_smba, 8);
 	return error;
 }
 
-static void __devexit vt596_remove(struct pci_dev *pdev)
-{
-	i2c_del_adapter(&vt596_adapter);
-	release_region(vt596_smba, 8);
-}
-
 static struct pci_device_id vt596_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C596_3),
 	  .driver_data = SMBBA1 },
@@ -420,7 +428,6 @@
 	.name		= "vt596_smbus",
 	.id_table	= vt596_ids,
 	.probe		= vt596_probe,
-	.remove		= __devexit_p(vt596_remove),
 };
 
 static int __init i2c_vt596_init(void)
@@ -432,6 +439,12 @@
 static void __exit i2c_vt596_exit(void)
 {
 	pci_unregister_driver(&vt596_driver);
+	if (vt596_pdev != NULL) {
+		i2c_del_adapter(&vt596_adapter);
+		release_region(vt596_smba, 8);
+		pci_dev_put(vt596_pdev);
+		vt596_pdev = NULL;
+	}
 }
 
 MODULE_AUTHOR(
diff -Nru a/drivers/i2c/chips/ds1621.c b/drivers/i2c/chips/ds1621.c
--- a/drivers/i2c/chips/ds1621.c	2004-11-08 16:37:27 -08:00
+++ b/drivers/i2c/chips/ds1621.c	2005-02-02 22:35:48 -08:00
@@ -42,9 +42,8 @@
 /* Many DS1621 constants specified below */
 /* Config register used for detection         */
 /*  7    6    5    4    3    2    1    0      */
-/* |Done|THF |TLF |NVB | 1  | 0  |POL |1SHOT| */
-#define DS1621_REG_CONFIG_MASK		0x0C
-#define DS1621_REG_CONFIG_VAL		0x08
+/* |Done|THF |TLF |NVB | X  | X  |POL |1SHOT| */
+#define DS1621_REG_CONFIG_NVB		0x10
 #define DS1621_REG_CONFIG_POLARITY	0x02
 #define DS1621_REG_CONFIG_1SHOT		0x01
 #define DS1621_REG_CONFIG_DONE		0x80
@@ -55,6 +54,7 @@
 #define DS1621_REG_TEMP_MAX		0xA2 /* word, RW */
 #define DS1621_REG_CONF			0xAC /* byte, RW */
 #define DS1621_COM_START		0xEE /* no data */
+#define DS1621_COM_STOP			0x22 /* no data */
 
 /* The DS1621 configuration register */
 #define DS1621_ALARM_TEMP_HIGH		0x40
@@ -212,9 +212,13 @@
 
 	/* Now, we do the remaining detection. It is lousy. */
 	if (kind < 0) {
+		/* The NVB bit should be low if no EEPROM write has been 
+		   requested during the latest 10ms, which is highly 
+		   improbable in our case. */
 		conf = ds1621_read_value(new_client, DS1621_REG_CONF);
-		if ((conf & DS1621_REG_CONFIG_MASK) != DS1621_REG_CONFIG_VAL)
+		if (conf & DS1621_REG_CONFIG_NVB)
 			goto exit_free;
+		/* The 7 lowest bits of a temperature should always be 0. */
 		temp = ds1621_read_value(new_client, DS1621_REG_TEMP);
 		if (temp & 0x007f)
 			goto exit_free;
diff -Nru a/drivers/i2c/chips/it87.c b/drivers/i2c/chips/it87.c
--- a/drivers/i2c/chips/it87.c	2005-01-14 14:17:28 -08:00
+++ b/drivers/i2c/chips/it87.c	2005-02-02 22:34:21 -08:00
@@ -2,8 +2,8 @@
     it87.c - Part of lm_sensors, Linux kernel modules for hardware
              monitoring.
 
-    Supports: IT8705F  Super I/O chip w/LPC interface
-              IT8712F  Super I/O chip w/LPC interface & SMbus
+    Supports: IT8705F  Super I/O chip w/LPC interface & SMBus
+              IT8712F  Super I/O chip w/LPC interface & SMBus
               Sis950   A clone of the IT8705F
 
     Copyright (C) 2001 Chris Gauthron <chrisg@0-in.com> 
@@ -42,10 +42,8 @@
 
 
 /* Addresses to scan */
-static unsigned short normal_i2c[] = { 0x20, 0x21, 0x22, 0x23, 0x24,
-					0x25, 0x26, 0x27, 0x28, 0x29,
-					0x2a, 0x2b, 0x2c, 0x2d, 0x2e,
-					0x2f, I2C_CLIENT_END };
+static unsigned short normal_i2c[] = { 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
+					0x2e, 0x2f, I2C_CLIENT_END };
 static unsigned int normal_isa[] = { 0x0290, I2C_CLIENT_ISA_END };
 
 /* Insmod parameters */
diff -Nru a/drivers/i2c/chips/pc87360.c b/drivers/i2c/chips/pc87360.c
--- a/drivers/i2c/chips/pc87360.c	2004-12-10 10:39:34 -08:00
+++ b/drivers/i2c/chips/pc87360.c	2005-02-02 22:34:00 -08:00
@@ -795,8 +795,10 @@
 
 	/* Fan clock dividers may be needed before any data is read */
 	for (i = 0; i < data->fannr; i++) {
-		data->fan_status[i] = pc87360_read_value(data, LD_FAN,
-				      NO_BANK, PC87360_REG_FAN_STATUS(i));
+		if (FAN_CONFIG_MONITOR(data->fan_conf, i))
+			data->fan_status[i] = pc87360_read_value(data,
+					      LD_FAN, NO_BANK,
+					      PC87360_REG_FAN_STATUS(i));
 	}
 
 	if (init > 0) {
@@ -898,14 +900,27 @@
 	}
 
 	if (data->fannr) {
-		device_create_file(&new_client->dev, &dev_attr_fan1_input);
-		device_create_file(&new_client->dev, &dev_attr_fan2_input);
-		device_create_file(&new_client->dev, &dev_attr_fan1_min);
-		device_create_file(&new_client->dev, &dev_attr_fan2_min);
-		device_create_file(&new_client->dev, &dev_attr_fan1_div);
-		device_create_file(&new_client->dev, &dev_attr_fan2_div);
-		device_create_file(&new_client->dev, &dev_attr_fan1_status);
-		device_create_file(&new_client->dev, &dev_attr_fan2_status);
+		if (FAN_CONFIG_MONITOR(data->fan_conf, 0)) {
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan1_input);
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan1_min);
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan1_div);
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan1_status);
+		}
+
+		if (FAN_CONFIG_MONITOR(data->fan_conf, 1)) {
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan2_input);
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan2_min);
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan2_div);
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan2_status);
+		}
 
 		if (FAN_CONFIG_CONTROL(data->fan_conf, 0))
 			device_create_file(&new_client->dev, &dev_attr_pwm1);
@@ -913,10 +928,16 @@
 			device_create_file(&new_client->dev, &dev_attr_pwm2);
 	}
 	if (data->fannr == 3) {
-		device_create_file(&new_client->dev, &dev_attr_fan3_input);
-		device_create_file(&new_client->dev, &dev_attr_fan3_min);
-		device_create_file(&new_client->dev, &dev_attr_fan3_div);
-		device_create_file(&new_client->dev, &dev_attr_fan3_status);
+		if (FAN_CONFIG_MONITOR(data->fan_conf, 2)) {
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan3_input);
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan3_min);
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan3_div);
+			device_create_file(&new_client->dev,
+					   &dev_attr_fan3_status);
+		}
 
 		if (FAN_CONFIG_CONTROL(data->fan_conf, 2))
 			device_create_file(&new_client->dev, &dev_attr_pwm3);
diff -Nru a/drivers/i2c/chips/via686a.c b/drivers/i2c/chips/via686a.c
--- a/drivers/i2c/chips/via686a.c	2005-01-14 14:18:19 -08:00
+++ b/drivers/i2c/chips/via686a.c	2005-02-02 22:34:47 -08:00
@@ -815,20 +815,24 @@
                return -ENODEV;
        }
        normal_isa[0] = addr;
-       s_bridge = dev;
-       return i2c_add_driver(&via686a_driver);
-}
 
-static void __devexit via686a_pci_remove(struct pci_dev *dev)
-{
-       i2c_del_driver(&via686a_driver);
+	s_bridge = pci_dev_get(dev);
+	if (i2c_add_driver(&via686a_driver)) {
+		pci_dev_put(s_bridge);
+		s_bridge = NULL;
+	}
+
+	/* Always return failure here.  This is to allow other drivers to bind
+	 * to this pci device.  We don't really want to have control over the
+	 * pci device, we only wanted to read as few register values from it.
+	 */
+	return -ENODEV;
 }
 
 static struct pci_driver via686a_pci_driver = {
        .name		= "via686a",
        .id_table	= via686a_pci_ids,
        .probe		= via686a_pci_probe,
-       .remove		= __devexit_p(via686a_pci_remove),
 };
 
 static int __init sm_via686a_init(void)
@@ -838,7 +842,12 @@
 
 static void __exit sm_via686a_exit(void)
 {
-       pci_unregister_driver(&via686a_pci_driver);
+	pci_unregister_driver(&via686a_pci_driver);
+	if (s_bridge != NULL) {
+		i2c_del_driver(&via686a_driver);
+		pci_dev_put(s_bridge);
+		s_bridge = NULL;
+	}
 }
 
 MODULE_AUTHOR("Kyösti Mälkki <kmalkki@cc.hut.fi>, "
diff -Nru a/drivers/i2c/chips/w83781d.c b/drivers/i2c/chips/w83781d.c
--- a/drivers/i2c/chips/w83781d.c	2004-12-10 10:38:41 -08:00
+++ b/drivers/i2c/chips/w83781d.c	2005-02-02 22:34:25 -08:00
@@ -175,11 +175,6 @@
 						: (val)) / 1000, 0, 0xff))
 #define TEMP_FROM_REG(val)		(((val) & 0x80 ? (val)-0x100 : (val)) * 1000)
 
-#define AS99127_TEMP_ADD_TO_REG(val)	(SENSORS_LIMIT((((val) < 0 ? (val)+0x10000*250 \
-						: (val)) / 250) << 7, 0, 0xffff))
-#define AS99127_TEMP_ADD_FROM_REG(val)	((((val) & 0x8000 ? (val)-0x10000 : (val)) \
-						>> 7) * 250)
-
 #define ALARMS_FROM_REG(val)		(val)
 #define PWM_FROM_REG(val)		(val)
 #define PWM_TO_REG(val)			(SENSORS_LIMIT((val),0,255))
@@ -417,13 +412,8 @@
 { \
 	struct w83781d_data *data = w83781d_update_device(dev); \
 	if (nr >= 2) {	/* TEMP2 and TEMP3 */ \
-		if (data->type == as99127f) { \
-			return sprintf(buf,"%ld\n", \
-				(long)AS99127_TEMP_ADD_FROM_REG(data->reg##_add[nr-2])); \
-		} else { \
-			return sprintf(buf,"%d\n", \
-				LM75_TEMP_FROM_REG(data->reg##_add[nr-2])); \
-		} \
+		return sprintf(buf,"%d\n", \
+			LM75_TEMP_FROM_REG(data->reg##_add[nr-2])); \
 	} else {	/* TEMP1 */ \
 		return sprintf(buf,"%ld\n", (long)TEMP_FROM_REG(data->reg)); \
 	} \
@@ -442,11 +432,7 @@
 	val = simple_strtol(buf, NULL, 10); \
 	 \
 	if (nr >= 2) {	/* TEMP2 and TEMP3 */ \
-		if (data->type == as99127f) \
-			data->temp_##reg##_add[nr-2] = AS99127_TEMP_ADD_TO_REG(val); \
-		else \
-			data->temp_##reg##_add[nr-2] = LM75_TEMP_TO_REG(val); \
-		 \
+		data->temp_##reg##_add[nr-2] = LM75_TEMP_TO_REG(val); \
 		w83781d_write_value(client, W83781D_REG_TEMP_##REG(nr), \
 				data->temp_##reg##_add[nr-2]); \
 	} else {	/* TEMP1 */ \
diff -Nru a/drivers/ide/ide-disk.c b/drivers/ide/ide-disk.c
--- a/drivers/ide/ide-disk.c	2005-01-04 09:39:25 -08:00
+++ b/drivers/ide/ide-disk.c	2005-02-02 16:38:38 -08:00
@@ -132,7 +132,7 @@
 	nsectors.all		= (u16) rq->nr_sectors;
 
 	if (hwif->no_lba48_dma && lba48 && dma) {
-		if (rq->sector + rq->nr_sectors > 1ULL << 28)
+		if (block + rq->nr_sectors > 1ULL << 28)
 			dma = 0;
 	}
 
@@ -253,8 +253,7 @@
 		/* FIXME: ->OUTBSYNC ? */
 		hwif->OUTB(command, IDE_COMMAND_REG);
 
-		pre_task_out_intr(drive, rq);
-		return ide_started;
+		return pre_task_out_intr(drive, rq);
 	}
 }
 EXPORT_SYMBOL_GPL(__ide_do_rw_disk);
diff -Nru a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
--- a/drivers/ide/ide-dma.c	2005-01-09 12:06:39 -08:00
+++ b/drivers/ide/ide-dma.c	2005-02-03 07:58:51 -08:00
@@ -227,7 +227,9 @@
  *	the PRD table that the IDE layer wants to be fed. The code
  *	knows about the 64K wrap bug in the CS5530.
  *
- *	Returns 0 if all went okay, returns 1 otherwise.
+ *	Returns the number of built PRD entries if all went okay,
+ *	returns 0 otherwise.
+ *
  *	May also be invoked from trm290.c
  */
  
@@ -631,7 +633,7 @@
 EXPORT_SYMBOL(__ide_dma_end);
 
 /* returns 1 if dma irq issued, 0 otherwise */
-int __ide_dma_test_irq (ide_drive_t *drive)
+static int __ide_dma_test_irq(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 dma_stat		= hwif->INB(hwif->dma_status);
@@ -650,8 +652,6 @@
 			drive->name, __FUNCTION__);
 	return 0;
 }
-
-EXPORT_SYMBOL(__ide_dma_test_irq);
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 int __ide_dma_bad_drive (ide_drive_t *drive)
@@ -784,7 +784,7 @@
 /*
  * Needed for allowing full modular support of ide-driver
  */
-int ide_release_dma_engine (ide_hwif_t *hwif)
+static int ide_release_dma_engine(ide_hwif_t *hwif)
 {
 	if (hwif->dmatable_cpu) {
 		pci_free_consistent(hwif->pci_dev,
@@ -796,7 +796,7 @@
 	return 1;
 }
 
-int ide_release_iomio_dma (ide_hwif_t *hwif)
+static int ide_release_iomio_dma(ide_hwif_t *hwif)
 {
 	if ((hwif->dma_extra) && (hwif->channel == 0))
 		release_region((hwif->dma_base + 16), hwif->dma_extra);
@@ -820,7 +820,7 @@
 	return ide_release_iomio_dma(hwif);
 }
 
-int ide_allocate_dma_engine (ide_hwif_t *hwif)
+static int ide_allocate_dma_engine(ide_hwif_t *hwif)
 {
 	hwif->dmatable_cpu = pci_alloc_consistent(hwif->pci_dev,
 						  PRD_ENTRIES * PRD_BYTES,
@@ -830,14 +830,13 @@
 		return 0;
 
 	printk(KERN_ERR "%s: -- Error, unable to allocate%s DMA table(s).\n",
-		(hwif->dmatable_cpu == NULL) ? " CPU" : "",
-		hwif->cds->name);
+			hwif->cds->name, !hwif->dmatable_cpu ? " CPU" : "");
 
 	ide_release_dma_engine(hwif);
 	return 1;
 }
 
-int ide_mapped_mmio_dma (ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+static int ide_mapped_mmio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
 {
 	printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
 
@@ -852,7 +851,7 @@
 	return 0;
 }
 
-int ide_iomio_dma (ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+static int ide_iomio_dma(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
 {
 	printk(KERN_INFO "    %s: BM-DMA at 0x%04lx-0x%04lx",
 		hwif->name, base, base + ports - 1);
@@ -881,10 +880,7 @@
 	return 0;
 }
 
-/*
- * 
- */
-int ide_dma_iobase (ide_hwif_t *hwif, unsigned long base, unsigned int ports)
+static int ide_dma_iobase(ide_hwif_t *hwif, unsigned long base, unsigned int ports)
 {
 	if (hwif->mmio == 2)
 		return ide_mapped_mmio_dma(hwif, base,ports);
diff -Nru a/drivers/ide/ide-floppy.c b/drivers/ide/ide-floppy.c
--- a/drivers/ide/ide-floppy.c	2005-01-04 09:39:25 -08:00
+++ b/drivers/ide/ide-floppy.c	2005-02-02 15:21:22 -08:00
@@ -585,7 +585,7 @@
 			count = min(bvec->bv_len, bcount);
 
 			data = bvec_kmap_irq(bvec, &flags);
-			atapi_input_bytes(drive, data, count);
+			drive->hwif->atapi_input_bytes(drive, data, count);
 			bvec_kunmap_irq(data, &flags);
 
 			bcount -= count;
@@ -619,7 +619,7 @@
 			count = min(bvec->bv_len, bcount);
 
 			data = bvec_kmap_irq(bvec, &flags);
-			atapi_output_bytes(drive, data, count);
+			drive->hwif->atapi_output_bytes(drive, data, count);
 			bvec_kunmap_irq(data, &flags);
 
 			bcount -= count;
diff -Nru a/drivers/ide/ide-io.c b/drivers/ide/ide-io.c
--- a/drivers/ide/ide-io.c	2005-01-09 11:54:36 -08:00
+++ b/drivers/ide/ide-io.c	2005-02-03 06:19:43 -08:00
@@ -555,7 +555,7 @@
 
 	err = ide_dump_status(drive, msg, stat);
 
-	if (drive == NULL || (rq = HWGROUP(drive)->rq) == NULL)
+	if ((rq = HWGROUP(drive)->rq) == NULL)
 		return ide_stopped;
 
 	/* retry only "normal" I/O: */
@@ -933,6 +933,7 @@
 	if (timeout > WAIT_WORSTCASE)
 		timeout = WAIT_WORSTCASE;
 	drive->sleep = timeout + jiffies;
+	drive->sleeping = 1;
 }
 
 EXPORT_SYMBOL(ide_stall_queue);
@@ -972,18 +973,18 @@
 	}
 
 	do {
-		if ((!drive->sleep || time_after_eq(jiffies, drive->sleep))
+		if ((!drive->sleeping || time_after_eq(jiffies, drive->sleep))
 		    && !elv_queue_empty(drive->queue)) {
 			if (!best
-			 || (drive->sleep && (!best->sleep || 0 < (signed long)(best->sleep - drive->sleep)))
-			 || (!best->sleep && 0 < (signed long)(WAKEUP(best) - WAKEUP(drive))))
+			 || (drive->sleeping && (!best->sleeping || time_before(drive->sleep, best->sleep)))
+			 || (!best->sleeping && time_before(WAKEUP(drive), WAKEUP(best))))
 			{
 				if (!blk_queue_plugged(drive->queue))
 					best = drive;
 			}
 		}
 	} while ((drive = drive->next) != hwgroup->drive);
-	if (best && best->nice1 && !best->sleep && best != hwgroup->drive && best->service_time > WAIT_MIN_SLEEP) {
+	if (best && best->nice1 && !best->sleeping && best != hwgroup->drive && best->service_time > WAIT_MIN_SLEEP) {
 		long t = (signed long)(WAKEUP(best) - jiffies);
 		if (t >= WAIT_MIN_SLEEP) {
 		/*
@@ -992,10 +993,9 @@
 		 */
 			drive = best->next;
 			do {
-				if (!drive->sleep
-				/* FIXME: use time_before */
-				 && 0 < (signed long)(WAKEUP(drive) - (jiffies - best->service_time))
-				 && 0 < (signed long)((jiffies + t) - WAKEUP(drive)))
+				if (!drive->sleeping
+				 && time_before(jiffies - best->service_time, WAKEUP(drive))
+				 && time_before(WAKEUP(drive), jiffies + t))
 				{
 					ide_stall_queue(best, min_t(long, t, 10 * WAIT_MIN_SLEEP));
 					goto repeat;
@@ -1058,14 +1058,17 @@
 		hwgroup->busy = 1;
 		drive = choose_drive(hwgroup);
 		if (drive == NULL) {
-			unsigned long sleep = 0;
+			int sleeping = 0;
+			unsigned long sleep = 0; /* shut up, gcc */
 			hwgroup->rq = NULL;
 			drive = hwgroup->drive;
 			do {
-				if (drive->sleep && (!sleep || 0 < (signed long)(sleep - drive->sleep)))
+				if (drive->sleeping && (!sleeping || time_before(drive->sleep, sleep))) {
+					sleeping = 1;
 					sleep = drive->sleep;
+				}
 			} while ((drive = drive->next) != hwgroup->drive);
-			if (sleep) {
+			if (sleeping) {
 		/*
 		 * Take a short snooze, and then wake up this hwgroup again.
 		 * This gives other hwgroups on the same a chance to
@@ -1105,7 +1108,7 @@
 		}
 		hwgroup->hwif = hwif;
 		hwgroup->drive = drive;
-		drive->sleep = 0;
+		drive->sleeping = 0;
 		drive->service_start = jiffies;
 
 		if (blk_queue_plugged(drive->queue)) {
@@ -1311,7 +1314,7 @@
 			/* local CPU only,
 			 * as if we were handling an interrupt */
 			local_irq_disable();
-			if (hwgroup->poll_timeout != 0) {
+			if (hwgroup->polling) {
 				startstop = handler(drive);
 			} else if (drive_is_ready(drive)) {
 				if (drive->waiting_for_dma)
@@ -1439,8 +1442,7 @@
 		return IRQ_NONE;
 	}
 
-	if ((handler = hwgroup->handler) == NULL ||
-	    hwgroup->poll_timeout != 0) {
+	if ((handler = hwgroup->handler) == NULL || hwgroup->polling) {
 		/*
 		 * Not expecting an interrupt from this drive.
 		 * That means this could be:
diff -Nru a/drivers/ide/ide-iops.c b/drivers/ide/ide-iops.c
--- a/drivers/ide/ide-iops.c	2005-01-06 19:03:04 -08:00
+++ b/drivers/ide/ide-iops.c	2005-02-03 06:19:43 -08:00
@@ -184,16 +184,6 @@
 
 EXPORT_SYMBOL(default_hwif_mmiops);
 
-void default_hwif_transport (ide_hwif_t *hwif)
-{
-	hwif->ata_input_data		= ata_input_data;
-	hwif->ata_output_data		= ata_output_data;
-	hwif->atapi_input_bytes		= atapi_input_bytes;
-	hwif->atapi_output_bytes	= atapi_output_bytes;
-}
-
-EXPORT_SYMBOL(default_hwif_transport);
-
 u32 ide_read_24 (ide_drive_t *drive)
 {
 	u8 hcyl = HWIF(drive)->INB(IDE_HCYL_REG);
@@ -202,8 +192,6 @@
 	return (hcyl<<16)|(lcyl<<8)|sect;
 }
 
-EXPORT_SYMBOL(ide_read_24);
-
 void SELECT_DRIVE (ide_drive_t *drive)
 {
 	if (HWIF(drive)->selectproc)
@@ -240,7 +228,7 @@
  * of the sector count register location, with interrupts disabled
  * to ensure that the reads all happen together.
  */
-void ata_vlb_sync (ide_drive_t *drive, unsigned long port)
+static void ata_vlb_sync(ide_drive_t *drive, unsigned long port)
 {
 	(void) HWIF(drive)->INB(port);
 	(void) HWIF(drive)->INB(port);
@@ -250,7 +238,7 @@
 /*
  * This is used for most PIO data transfers *from* the IDE interface
  */
-void ata_input_data (ide_drive_t *drive, void *buffer, u32 wcount)
+static void ata_input_data(ide_drive_t *drive, void *buffer, u32 wcount)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 io_32bit		= drive->io_32bit;
@@ -272,7 +260,7 @@
 /*
  * This is used for most PIO data transfers *to* the IDE interface
  */
-void ata_output_data (ide_drive_t *drive, void *buffer, u32 wcount)
+static void ata_output_data(ide_drive_t *drive, void *buffer, u32 wcount)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 io_32bit		= drive->io_32bit;
@@ -299,7 +287,7 @@
  * extra byte allocated for the buffer.
  */
 
-void atapi_input_bytes (ide_drive_t *drive, void *buffer, u32 bytecount)
+static void atapi_input_bytes(ide_drive_t *drive, void *buffer, u32 bytecount)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 
@@ -316,9 +304,7 @@
 		hwif->INSW(IDE_DATA_REG, ((u8 *)buffer)+(bytecount & ~0x03), 1);
 }
 
-EXPORT_SYMBOL(atapi_input_bytes);
-
-void atapi_output_bytes (ide_drive_t *drive, void *buffer, u32 bytecount)
+static void atapi_output_bytes(ide_drive_t *drive, void *buffer, u32 bytecount)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 
@@ -335,7 +321,15 @@
 		hwif->OUTSW(IDE_DATA_REG, ((u8*)buffer)+(bytecount & ~0x03), 1);
 }
 
-EXPORT_SYMBOL(atapi_output_bytes);
+void default_hwif_transport(ide_hwif_t *hwif)
+{
+	hwif->ata_input_data		= ata_input_data;
+	hwif->ata_output_data		= ata_output_data;
+	hwif->atapi_input_bytes		= atapi_input_bytes;
+	hwif->atapi_output_bytes	= atapi_output_bytes;
+}
+
+EXPORT_SYMBOL(default_hwif_transport);
 
 /*
  * Beginning of Taskfile OPCODE Library and feature sets.
@@ -437,6 +431,7 @@
 #endif
 }
 
+/* FIXME: exported for use by the USB storage (isd200.c) code only */
 EXPORT_SYMBOL(ide_fix_driveid);
 
 void ide_fixstring (u8 *s, const int bytecount, const int byteswap)
@@ -1028,14 +1023,14 @@
 			return ide_started;
 		}
 		/* end of polling */
-		hwgroup->poll_timeout = 0;
+		hwgroup->polling = 0;
 		printk("%s: ATAPI reset timed-out, status=0x%02x\n",
 				drive->name, stat);
 		/* do it the old fashioned way */
 		return do_reset1(drive, 1);
 	}
 	/* done polling */
-	hwgroup->poll_timeout = 0;
+	hwgroup->polling = 0;
 	return ide_stopped;
 }
 
@@ -1095,7 +1090,7 @@
 			printk("\n");
 		}
 	}
-	hwgroup->poll_timeout = 0;	/* done polling */
+	hwgroup->polling = 0;	/* done polling */
 	return ide_stopped;
 }
 
@@ -1112,7 +1107,7 @@
 #endif
 }
 
-void pre_reset (ide_drive_t *drive)
+static void pre_reset(ide_drive_t *drive)
 {
 	DRIVER(drive)->pre_reset(drive);
 
@@ -1170,6 +1165,7 @@
 		udelay (20);
 		hwif->OUTB(WIN_SRST, IDE_COMMAND_REG);
 		hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
+		hwgroup->polling = 1;
 		__ide_set_handler(drive, &atapi_reset_pollfunc, HZ/20, NULL);
 		spin_unlock_irqrestore(&ide_lock, flags);
 		return ide_started;
@@ -1210,6 +1206,7 @@
 	/* more than enough time */
 	udelay(10);
 	hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
+	hwgroup->polling = 1;
 	__ide_set_handler(drive, &reset_pollfunc, HZ/20, NULL);
 
 	/*
diff -Nru a/drivers/ide/ide-pnp.c b/drivers/ide/ide-pnp.c
--- a/drivers/ide/ide-pnp.c	2004-06-15 09:31:45 -07:00
+++ b/drivers/ide/ide-pnp.c	2005-02-03 07:29:37 -08:00
@@ -21,7 +21,7 @@
 #include <linux/ide.h>
 
 /* Add your devices here :)) */
-struct pnp_device_id idepnp_devices[] = {
+static struct pnp_device_id idepnp_devices[] = {
   	/* Generic ESDI/IDE/ATA compatible hard disk controller */
 	{.id = "PNP0600", .driver_data = 0},
 	{.id = ""}
diff -Nru a/drivers/ide/ide-probe.c b/drivers/ide/ide-probe.c
--- a/drivers/ide/ide-probe.c	2005-01-12 06:01:25 -08:00
+++ b/drivers/ide/ide-probe.c	2005-02-03 06:58:21 -08:00
@@ -841,7 +841,11 @@
 	if (fixup)
 		fixup(hwif);
 
-	hwif_init(hwif);
+	if (!hwif_init(hwif)) {
+		printk(KERN_INFO "%s: failed to initialize IDE interface\n",
+				 hwif->name);
+		return -1;
+	}
 
 	if (hwif->present) {
 		u16 unit = 0;
diff -Nru a/drivers/ide/ide-tape.c b/drivers/ide/ide-tape.c
--- a/drivers/ide/ide-tape.c	2004-10-20 01:37:15 -07:00
+++ b/drivers/ide/ide-tape.c	2005-02-02 17:09:29 -08:00
@@ -2439,7 +2439,7 @@
 			tape->dsc_polling_start = jiffies;
 			tape->dsc_polling_frequency = tape->best_dsc_rw_frequency;
 			tape->dsc_timeout = jiffies + IDETAPE_DSC_RW_TIMEOUT;
-		} else if ((signed long) (jiffies - tape->dsc_timeout) > 0) {
+		} else if (time_after(jiffies, tape->dsc_timeout)) {
 			printk(KERN_ERR "ide-tape: %s: DSC timeout\n",
 				tape->name);
 			if (rq->cmd[0] & REQ_IDETAPE_PC2) {
diff -Nru a/drivers/ide/ide-taskfile.c b/drivers/ide/ide-taskfile.c
--- a/drivers/ide/ide-taskfile.c	2005-01-06 19:03:04 -08:00
+++ b/drivers/ide/ide-taskfile.c	2005-02-02 17:19:08 -08:00
@@ -851,8 +851,8 @@
 		hwif->OUTB(taskfile->high_cylinder, IDE_HCYL_REG);
 
         /*
-	 * (ks) In the flagged taskfile approch, we will used all specified
-	 * registers and the register value will not be changed. Except the
+	 * (ks) In the flagged taskfile approch, we will use all specified
+	 * registers and the register value will not be changed, except the
 	 * select bit (master/slave) in the drive_head register. We must make
 	 * sure that the desired drive is selected.
 	 */
diff -Nru a/drivers/ide/ide.c b/drivers/ide/ide.c
--- a/drivers/ide/ide.c	2005-01-20 21:02:09 -08:00
+++ b/drivers/ide/ide.c	2005-02-03 07:29:37 -08:00
@@ -333,7 +333,7 @@
  *	Returns a guessed speed in MHz.
  */
 
-int ide_system_bus_speed (void)
+static int ide_system_bus_speed(void)
 {
 	static struct pci_device_id pci_default[] = {
 		{ PCI_DEVICE(PCI_ANY_ID, PCI_ANY_ID) },
@@ -414,7 +414,7 @@
 #ifdef CONFIG_PROC_FS
 struct proc_dir_entry *proc_ide_root;
 
-ide_proc_entry_t generic_subdriver_entries[] = {
+static ide_proc_entry_t generic_subdriver_entries[] = {
 	{ "capacity",	S_IFREG|S_IRUGO,	proc_ide_read_capacity,	NULL },
 	{ NULL, 0, NULL, NULL }
 };
@@ -1675,7 +1675,7 @@
  *
  * Remember to update Documentation/ide.txt if you change something here.
  */
-int __init ide_setup (char *s)
+static int __init ide_setup(char *s)
 {
 	int i, vals[3];
 	ide_hwif_t *hwif;
@@ -2261,7 +2261,7 @@
 /*
  * This is gets invoked once during initialization, to set *everything* up
  */
-int __init ide_init (void)
+static int __init ide_init(void)
 {
 	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
 	devfs_mk_dir("ide");
@@ -2308,7 +2308,7 @@
 }
 
 #ifdef MODULE
-char *options = NULL;
+static char *options = NULL;
 module_param(options, charp, 0);
 MODULE_LICENSE("GPL");
 
diff -Nru a/drivers/ide/legacy/ide-cs.c b/drivers/ide/legacy/ide-cs.c
--- a/drivers/ide/legacy/ide-cs.c	2005-01-15 14:31:03 -08:00
+++ b/drivers/ide/legacy/ide-cs.c	2005-02-03 07:29:37 -08:00
@@ -209,7 +209,7 @@
 #define CS_CHECK(fn, ret) \
 do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 
-void ide_config(dev_link_t *link)
+static void ide_config(dev_link_t *link)
 {
     client_handle_t handle = link->handle;
     ide_info_t *info = link->priv;
diff -Nru a/drivers/ide/pci/Makefile b/drivers/ide/pci/Makefile
--- a/drivers/ide/pci/Makefile	2004-03-16 12:49:40 -08:00
+++ b/drivers/ide/pci/Makefile	2005-02-02 16:19:50 -08:00
@@ -1,5 +1,4 @@
 
-obj-$(CONFIG_BLK_DEV_ADMA100)		+= adma100.o
 obj-$(CONFIG_BLK_DEV_AEC62XX)		+= aec62xx.o
 obj-$(CONFIG_BLK_DEV_ALI15X3)		+= alim15x3.o
 obj-$(CONFIG_BLK_DEV_AMD74XX)		+= amd74xx.o
diff -Nru a/drivers/ide/pci/adma100.c b/drivers/ide/pci/adma100.c
--- a/drivers/ide/pci/adma100.c	2003-02-18 10:06:19 -08:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,30 +0,0 @@
-/*
- *  linux/drivers/ide/pci/adma100.c -- basic support for Pacific Digital ADMA-100 boards
- *
- *     Created 09 Apr 2002 by Mark Lord
- *
- *  This file is subject to the terms and conditions of the GNU General Public
- *  License.  See the file COPYING in the main directory of this archive for
- *  more details.
- */
-
-#include <linux/mm.h>
-#include <linux/blkdev.h>
-#include <linux/hdreg.h>
-#include <linux/ide.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <asm/io.h>
-
-void __init ide_init_adma100 (ide_hwif_t *hwif)
-{
-	unsigned long  phy_admctl = pci_resource_start(hwif->pci_dev, 4) + 0x80 + (hwif->channel * 0x20);
-	void *v_admctl;
-
-	hwif->autodma = 0;		// not compatible with normal IDE DMA transfers
-	hwif->dma_base = 0;		// disable DMA completely
-	hwif->io_ports[IDE_CONTROL_OFFSET] += 4;	// chip needs offset of 6 instead of 2
-	v_admctl = ioremap_nocache(phy_admctl, 1024);	// map config regs, so we can turn on drive IRQs
-	*((unsigned short *)v_admctl) &= 3;		// enable aIEN; preserve PIO mode
-	iounmap(v_admctl);				// all done; unmap config regs
-}
diff -Nru a/drivers/ide/pci/adma100.h b/drivers/ide/pci/adma100.h
--- a/drivers/ide/pci/adma100.h	2004-05-20 10:41:38 -07:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,28 +0,0 @@
-#ifndef ADMA_100_H
-#define ADMA_100_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-extern void init_setup_pdcadma(struct pci_dev *, ide_pci_device_t *);
-extern unsigned int init_chipset_pdcadma(struct pci_dev *, const char *);
-extern void init_hwif_pdcadma(ide_hwif_t *);
-extern void init_dma_pdcadma(ide_hwif_t *, unsigned long);
-
-static ide_pci_device_t pdcadma_chipsets[] __devinitdata = {
-	{
-		.vendor		= PCI_VENDOR_ID_PDC,
-		.device		= PCI_DEVICE_ID_PDC_1841,
-		.name		= "ADMA100",
-		.init_setup	= init_setup_pdcadma,
-		.init_chipset	= init_chipset_pdcadma,
-		.init_hwif	= init_hwif_pdcadma,
-		.init_dma	= init_dma_pdcadma,
-		.channels	= 2,
-		.autodma	= NODMA,
-		.bootable	= OFF_BOARD,
-	}
-}
-
-#endif /* ADMA_100_H */
diff -Nru a/drivers/ide/pci/it8172.c b/drivers/ide/pci/it8172.c
--- a/drivers/ide/pci/it8172.c	2004-12-30 11:27:27 -08:00
+++ b/drivers/ide/pci/it8172.c	2005-02-02 16:20:32 -08:00
@@ -56,7 +56,7 @@
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	struct pci_dev *dev	= hwif->pci_dev;
-	int is_slave		= (hwif->drives[1] == drive);
+	int is_slave		= (&hwif->drives[1] == drive);
 	unsigned long flags;
 	u16 drive_enables;
 	u32 drive_timing;
@@ -94,7 +94,7 @@
 	}
 
 	pci_write_config_word(dev, 0x40, drive_enables);
-	spin_unlock_irqrestore(&ide_lock, flags)
+	spin_unlock_irqrestore(&ide_lock, flags);
 }
 
 static u8 it8172_dma_2_pio (u8 xfer_rate)
diff -Nru a/drivers/ide/pci/it8172.h b/drivers/ide/pci/it8172.h
--- a/drivers/ide/pci/it8172.h	2004-06-01 12:04:38 -07:00
+++ b/drivers/ide/pci/it8172.h	2005-02-02 16:20:02 -08:00
@@ -6,7 +6,6 @@
 #include <linux/ide.h>
 
 static u8 it8172_ratemask(ide_drive_t *drive);
-static u8 it8172_ratefilter(ide_drive_t *drive, u8 speed);
 static void it8172_tune_drive(ide_drive_t *drive, u8 pio);
 static u8 it8172_dma_2_pio(u8 xfer_rate);
 static int it8172_tune_chipset(ide_drive_t *drive, u8 xferspeed);
@@ -14,14 +13,12 @@
 static int it8172_config_chipset_for_dma(ide_drive_t *drive);
 #endif
 
-static void init_setup_it8172(struct pci_dev *, ide_pci_device_t *);
 static unsigned int init_chipset_it8172(struct pci_dev *, const char *);
 static void init_hwif_it8172(ide_hwif_t *);
 
 static ide_pci_device_t it8172_chipsets[] __devinitdata = {
 	{	/* 0 */
 		.name		= "IT8172G",
-		.init_setup	= init_setup_it8172,
 		.init_chipset	= init_chipset_it8172,
 		.init_hwif	= init_hwif_it8172,
 		.channels	= 2,
diff -Nru a/drivers/ide/pci/opti621.c b/drivers/ide/pci/opti621.c
--- a/drivers/ide/pci/opti621.c	2004-12-29 14:58:32 -08:00
+++ b/drivers/ide/pci/opti621.c	2005-02-02 16:20:46 -08:00
@@ -348,11 +348,6 @@
 	hwif->drives[1].autodma = hwif->autodma;
 }
 
-static int __init init_setup_opti621 (struct pci_dev *dev, ide_pci_device_t *d)
-{
-	return ide_setup_pci_device(dev, d);
-}
-
 static int __devinit opti621_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	return ide_setup_pci_device(dev, &opti621_chipsets[id->driver_data]);
diff -Nru a/drivers/ide/pci/opti621.h b/drivers/ide/pci/opti621.h
--- a/drivers/ide/pci/opti621.h	2004-12-29 14:58:32 -08:00
+++ b/drivers/ide/pci/opti621.h	2005-02-02 16:20:46 -08:00
@@ -5,13 +5,11 @@
 #include <linux/pci.h>
 #include <linux/ide.h>
 
-static int init_setup_opti621(struct pci_dev *, ide_pci_device_t *);
 static void init_hwif_opti621(ide_hwif_t *);
 
 static ide_pci_device_t opti621_chipsets[] __devinitdata = {
 	{	/* 0 */
 		.name		= "OPTI621",
-		.init_setup	= init_setup_opti621,
 		.init_hwif	= init_hwif_opti621,
 		.channels	= 2,
 		.autodma	= AUTODMA,
@@ -19,7 +17,6 @@
 		.bootable	= ON_BOARD,
 	},{	/* 1 */
 		.name		= "OPTI621X",
-		.init_setup	= init_setup_opti621,
 		.init_hwif	= init_hwif_opti621,
 		.channels	= 2,
 		.autodma	= AUTODMA,
diff -Nru a/drivers/ide/pci/piix.c b/drivers/ide/pci/piix.c
--- a/drivers/ide/pci/piix.c	2005-01-14 17:49:03 -08:00
+++ b/drivers/ide/pci/piix.c	2005-02-02 16:21:00 -08:00
@@ -531,20 +531,6 @@
 }
 
 /**
- *	init_setup_piix		-	callback for IDE initialize
- *	@dev: PIIX PCI device
- *	@d: IDE pci info
- *
- *	Enable the xp fixup for the PIIX controller and then perform
- *	a standard ide PCI setup
- */
-
-static int __devinit init_setup_piix(struct pci_dev *dev, ide_pci_device_t *d)
-{
-	return ide_setup_pci_device(dev, d);
-}
-
-/**
  *	piix_init_one	-	called when a PIIX is found
  *	@dev: the piix device
  *	@id: the matching pci id
@@ -557,7 +543,7 @@
 {
 	ide_pci_device_t *d = &piix_pci_info[id->driver_data];
 
-	return d->init_setup(dev, d);
+	return ide_setup_pci_device(dev, d);
 }
 
 /**
diff -Nru a/drivers/ide/pci/piix.h b/drivers/ide/pci/piix.h
--- a/drivers/ide/pci/piix.h	2005-01-14 17:49:03 -08:00
+++ b/drivers/ide/pci/piix.h	2005-02-02 16:21:00 -08:00
@@ -5,14 +5,12 @@
 #include <linux/pci.h>
 #include <linux/ide.h>
 
-static int init_setup_piix(struct pci_dev *, ide_pci_device_t *);
 static unsigned int __devinit init_chipset_piix(struct pci_dev *, const char *);
 static void init_hwif_piix(ide_hwif_t *);
 
 #define DECLARE_PIIX_DEV(name_str) \
 	{						\
 		.name		= name_str,		\
-		.init_setup	= init_setup_piix,	\
 		.init_chipset	= init_chipset_piix,	\
 		.init_hwif	= init_hwif_piix,	\
 		.channels	= 2,			\
@@ -32,7 +30,6 @@
 
 	{	/* 2 */
 		.name		= "MPIIX",
-		.init_setup	= init_setup_piix,
 		.init_hwif	= init_hwif_piix,
 		.channels	= 2,
 		.autodma	= NODMA,
diff -Nru a/drivers/ide/pci/sgiioc4.c b/drivers/ide/pci/sgiioc4.c
--- a/drivers/ide/pci/sgiioc4.c	2005-01-06 17:35:35 -08:00
+++ b/drivers/ide/pci/sgiioc4.c	2005-02-03 06:58:21 -08:00
@@ -669,7 +669,8 @@
 		printk(KERN_INFO "%s: %s Bus-Master DMA disabled\n",
 		       hwif->name, d->name);
 
-	probe_hwif_init(hwif);
+	if (probe_hwif_init(hwif))
+		return -EIO;
 
 	/* Create /proc/ide entries */
 	create_proc_ide_interfaces(); 
diff -Nru a/drivers/ide/pci/siimage.c b/drivers/ide/pci/siimage.c
--- a/drivers/ide/pci/siimage.c	2004-12-29 14:58:32 -08:00
+++ b/drivers/ide/pci/siimage.c	2005-02-03 06:19:43 -08:00
@@ -590,7 +590,7 @@
 		if ((hwif->INL(SATA_STATUS_REG) & 0x03) != 0x03) {
 			printk(KERN_WARNING "%s: reset phy dead, status=0x%08x\n",
 				hwif->name, hwif->INL(SATA_STATUS_REG));
-			HWGROUP(drive)->poll_timeout = 0;
+			HWGROUP(drive)->polling = 0;
 			return ide_started;
 		}
 		return 0;
diff -Nru a/drivers/ide/pci/via82cxxx.c b/drivers/ide/pci/via82cxxx.c
--- a/drivers/ide/pci/via82cxxx.c	2005-01-30 22:22:38 -08:00
+++ b/drivers/ide/pci/via82cxxx.c	2005-02-02 23:24:29 -08:00
@@ -589,7 +589,7 @@
 	hwif->speedproc = &via_set_drive;
 
 
-#ifdef CONFIG_PPC_MULTIPLATFORM
+#if defined(CONFIG_PPC_MULTIPLATFORM) && defined(CONFIG_PPC32)
 	if(_machine == _MACH_chrp && _chrp_type == _CHRP_Pegasos) {
 		hwif->irq = hwif->channel ? 15 : 14;
 	}
diff -Nru a/drivers/infiniband/hw/mthca/mthca_cq.c b/drivers/infiniband/hw/mthca/mthca_cq.c
--- a/drivers/infiniband/hw/mthca/mthca_cq.c	2005-01-15 14:01:49 -08:00
+++ b/drivers/infiniband/hw/mthca/mthca_cq.c	2005-02-03 06:42:39 -08:00
@@ -422,8 +422,6 @@
 				*freed = 0;
 			}
 			spin_unlock(&(*cur_qp)->lock);
-			if (atomic_dec_and_test(&(*cur_qp)->refcount))
-				wake_up(&(*cur_qp)->wait);
 		}
 
 		spin_lock(&dev->qp_table.lock);
diff -Nru a/drivers/infiniband/hw/mthca/mthca_qp.c b/drivers/infiniband/hw/mthca/mthca_qp.c
--- a/drivers/infiniband/hw/mthca/mthca_qp.c	2005-01-15 14:01:50 -08:00
+++ b/drivers/infiniband/hw/mthca/mthca_qp.c	2005-02-03 06:42:39 -08:00
@@ -1323,6 +1323,8 @@
 				break;
 			}
 
+			break;
+
 		case UD:
 			((struct mthca_ud_seg *) wqe)->lkey =
 				cpu_to_be32(to_mah(wr->wr.ud.ah)->key);
diff -Nru a/drivers/isdn/hisax/avm_a1p.c b/drivers/isdn/hisax/avm_a1p.c
--- a/drivers/isdn/hisax/avm_a1p.c	2004-02-18 19:42:12 -08:00
+++ b/drivers/isdn/hisax/avm_a1p.c	2005-02-03 06:42:40 -08:00
@@ -231,7 +231,7 @@
 	cs->irq = card->para[0];
 
 
-	outb(cs->hw.avm.cfg_reg+ASL1_OFFSET, ASL1_W_ENABLE_S0);
+	byteout(cs->hw.avm.cfg_reg+ASL1_OFFSET, ASL1_W_ENABLE_S0);
 	byteout(cs->hw.avm.cfg_reg+ASL0_OFFSET,0x00);
 	HZDELAY(HZ / 5 + 1);
 	byteout(cs->hw.avm.cfg_reg+ASL0_OFFSET,ASL0_W_RESET);
diff -Nru a/drivers/isdn/hisax/isdnhdlc.c b/drivers/isdn/hisax/isdnhdlc.c
--- a/drivers/isdn/hisax/isdnhdlc.c	2004-07-11 01:54:51 -07:00
+++ b/drivers/isdn/hisax/isdnhdlc.c	2005-02-03 06:50:06 -08:00
@@ -308,7 +308,7 @@
 				hdlc->crc = crc_ccitt_byte(hdlc->crc, hdlc->shift_reg);
 
 				// good byte received
-				if (dsize--) {
+				if (hdlc->dstpos < dsize) {
 					dst[hdlc->dstpos++] = hdlc->shift_reg;
 				} else {
 					// frame too long
diff -Nru a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c
--- a/drivers/md/dm-crypt.c	2004-11-15 19:29:25 -08:00
+++ b/drivers/md/dm-crypt.c	2005-02-03 07:16:04 -08:00
@@ -329,7 +329,7 @@
                    struct bio *base_bio, unsigned int *bio_vec_idx)
 {
 	struct bio *bio;
-	unsigned int nr_iovecs = dm_div_up(size, PAGE_SIZE);
+	unsigned int nr_iovecs = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	int gfp_mask = GFP_NOIO | __GFP_HIGHMEM;
 	unsigned long flags = current->flags;
 	unsigned int i;
diff -Nru a/drivers/md/dm-log.c b/drivers/md/dm-log.c
--- a/drivers/md/dm-log.c	2005-01-25 13:50:21 -08:00
+++ b/drivers/md/dm-log.c	2005-02-03 07:16:04 -08:00
@@ -129,7 +129,7 @@
 struct log_c {
 	struct dm_target *ti;
 	int touched;
-	sector_t region_size;
+	uint32_t region_size;
 	unsigned int region_count;
 	region_t sync_count;
 
@@ -292,7 +292,7 @@
 	enum sync sync = DEFAULTSYNC;
 
 	struct log_c *lc;
-	sector_t region_size;
+	uint32_t region_size;
 	unsigned int region_count;
 	size_t bitset_size;
 
@@ -313,12 +313,12 @@
 		}
 	}
 
-	if (sscanf(argv[0], SECTOR_FORMAT, &region_size) != 1) {
+	if (sscanf(argv[0], "%u", &region_size) != 1) {
 		DMWARN("invalid region size string");
 		return -EINVAL;
 	}
 
-	region_count = dm_div_up(ti->len, region_size);
+	region_count = dm_sector_div_up(ti->len, region_size);
 
 	lc = kmalloc(sizeof(*lc), GFP_KERNEL);
 	if (!lc) {
@@ -508,7 +508,7 @@
 	return write_header(lc);
 }
 
-static sector_t core_get_region_size(struct dirty_log *log)
+static uint32_t core_get_region_size(struct dirty_log *log)
 {
 	struct log_c *lc = (struct log_c *) log->context;
 	return lc->region_size;
@@ -616,7 +616,7 @@
 		break;
 
 	case STATUSTYPE_TABLE:
-		DMEMIT("%s %u " SECTOR_FORMAT " ", log->type->name,
+		DMEMIT("%s %u %u ", log->type->name,
 		       lc->sync == DEFAULTSYNC ? 1 : 2, lc->region_size);
 		DMEMIT_SYNC;
 	}
@@ -637,7 +637,7 @@
 
 	case STATUSTYPE_TABLE:
 		format_dev_t(buffer, lc->log_dev->bdev->bd_dev);
-		DMEMIT("%s %u %s " SECTOR_FORMAT " ", log->type->name,
+		DMEMIT("%s %u %s %u ", log->type->name,
 		       lc->sync == DEFAULTSYNC ? 2 : 3, buffer,
 		       lc->region_size);
 		DMEMIT_SYNC;
diff -Nru a/drivers/md/dm-log.h b/drivers/md/dm-log.h
--- a/drivers/md/dm-log.h	2004-09-22 13:34:57 -07:00
+++ b/drivers/md/dm-log.h	2005-02-03 07:16:04 -08:00
@@ -39,7 +39,7 @@
 	 * Retrieves the smallest size of region that the log can
 	 * deal with.
 	 */
-	sector_t (*get_region_size)(struct dirty_log *log);
+	uint32_t (*get_region_size)(struct dirty_log *log);
 
         /*
 	 * A predicate to say whether a region is clean or not.
diff -Nru a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c
--- a/drivers/md/dm-raid1.c	2005-01-25 13:50:21 -08:00
+++ b/drivers/md/dm-raid1.c	2005-02-03 07:16:04 -08:00
@@ -67,7 +67,7 @@
 struct mirror_set;
 struct region_hash {
 	struct mirror_set *ms;
-	sector_t region_size;
+	uint32_t region_size;
 	unsigned region_shift;
 
 	/* holds persistent region state */
@@ -135,7 +135,7 @@
 #define MIN_REGIONS 64
 #define MAX_RECOVERY 1
 static int rh_init(struct region_hash *rh, struct mirror_set *ms,
-		   struct dirty_log *log, sector_t region_size,
+		   struct dirty_log *log, uint32_t region_size,
 		   region_t nr_regions)
 {
 	unsigned int nr_buckets, max_buckets;
@@ -871,7 +871,7 @@
  * Target functions
  *---------------------------------------------------------------*/
 static struct mirror_set *alloc_context(unsigned int nr_mirrors,
-					sector_t region_size,
+					uint32_t region_size,
 					struct dm_target *ti,
 					struct dirty_log *dl)
 {
@@ -894,7 +894,7 @@
 
 	ms->ti = ti;
 	ms->nr_mirrors = nr_mirrors;
-	ms->nr_regions = dm_div_up(ti->len, region_size);
+	ms->nr_regions = dm_sector_div_up(ti->len, region_size);
 	ms->in_sync = 0;
 
 	if (rh_init(&ms->rh, ms, dl, region_size, ms->nr_regions)) {
@@ -916,7 +916,7 @@
 	kfree(ms);
 }
 
-static inline int _check_region_size(struct dm_target *ti, sector_t size)
+static inline int _check_region_size(struct dm_target *ti, uint32_t size)
 {
 	return !(size % (PAGE_SIZE >> 9) || (size & (size - 1)) ||
 		 size > ti->len);
diff -Nru a/drivers/md/dm-stripe.c b/drivers/md/dm-stripe.c
--- a/drivers/md/dm-stripe.c	2005-01-25 13:50:21 -08:00
+++ b/drivers/md/dm-stripe.c	2005-02-03 06:42:39 -08:00
@@ -21,7 +21,7 @@
 	uint32_t stripes;
 
 	/* The size of this target / num. stripes */
-	uint32_t stripe_width;
+	sector_t stripe_width;
 
 	/* stripe chunk size */
 	uint32_t chunk_shift;
diff -Nru a/drivers/md/dm-table.c b/drivers/md/dm-table.c
--- a/drivers/md/dm-table.c	2005-01-25 13:50:21 -08:00
+++ b/drivers/md/dm-table.c	2005-02-03 07:16:04 -08:00
@@ -58,7 +58,7 @@
 /*
  * Similar to ceiling(log_size(n))
  */
-static unsigned int int_log(unsigned long n, unsigned long base)
+static unsigned int int_log(unsigned int n, unsigned int base)
 {
 	int result = 0;
 
diff -Nru a/drivers/md/dm.c b/drivers/md/dm.c
--- a/drivers/md/dm.c	2005-01-25 13:50:21 -08:00
+++ b/drivers/md/dm.c	2005-02-03 07:16:04 -08:00
@@ -331,8 +331,8 @@
 	 */
 	if (ti->split_io) {
 		sector_t boundary;
-		boundary = dm_round_up(offset + 1, ti->split_io) - offset;
-
+		boundary = ((offset + ti->split_io) & ~(ti->split_io - 1))
+			   - offset;
 		if (len > boundary)
 			len = boundary;
 	}
diff -Nru a/drivers/md/dm.h b/drivers/md/dm.h
--- a/drivers/md/dm.h	2005-01-25 13:50:21 -08:00
+++ b/drivers/md/dm.h	2005-02-03 07:16:04 -08:00
@@ -143,21 +143,22 @@
 }
 
 /*
- * ceiling(n / size) * size
+ * Ceiling(n / sz)
  */
-static inline unsigned long dm_round_up(unsigned long n, unsigned long size)
-{
-	unsigned long r = n % size;
-	return n + (r ? (size - r) : 0);
-}
+#define dm_div_up(n, sz) (((n) + (sz) - 1) / (sz))
+
+#define dm_sector_div_up(n, sz) ( \
+{ \
+	sector_t _r = ((n) + (sz) - 1); \
+	sector_div(_r, (sz)); \
+	_r; \
+} \
+)
 
 /*
- * Ceiling(n / size)
+ * ceiling(n / size) * size
  */
-static inline unsigned long dm_div_up(unsigned long n, unsigned long size)
-{
-	return dm_round_up(n, size) / size;
-}
+#define dm_round_up(n, sz) (dm_div_up((n), (sz)) * (sz))
 
 static inline sector_t to_sector(unsigned long n)
 {
diff -Nru a/drivers/md/md.c b/drivers/md/md.c
--- a/drivers/md/md.c	2005-01-19 04:23:30 -08:00
+++ b/drivers/md/md.c	2005-02-03 00:06:54 -08:00
@@ -336,8 +336,6 @@
 	struct completion event;
 	int ret;
 
-	bio_get(bio);
-
 	rw |= (1 << BIO_RW_SYNC);
 
 	bio->bi_bdev = bdev;
diff -Nru a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
--- a/drivers/media/video/Kconfig	2005-01-25 13:50:27 -08:00
+++ b/drivers/media/video/Kconfig	2005-02-03 06:42:40 -08:00
@@ -146,7 +146,8 @@
 
 config VIDEO_VINO
 	tristate "SGI Vino Video For Linux (EXPERIMENTAL)"
-	depends on EXPERIMENTAL && VIDEO_DEV && SGI
+	depends on VIDEO_DEV && I2C && SGI_IP22 && EXPERIMENTAL
+	select I2C_ALGO_SGI
 	help
 	  Say Y here to build in support for the Vino video input system found
 	  on SGI Indy machines.
diff -Nru a/drivers/media/video/tda9887.c b/drivers/media/video/tda9887.c
--- a/drivers/media/video/tda9887.c	2005-01-25 13:50:26 -08:00
+++ b/drivers/media/video/tda9887.c	2005-02-03 03:26:16 -08:00
@@ -305,9 +305,9 @@
 	printk("  B5   force mute audio: %s\n",
 	       (buf[1] & 0x20) ? "yes" : "no");
 	printk("  B6   output port 1   : %s\n",
-	       (buf[1] & 0x40) ? "high" : "low");
+	       (buf[1] & 0x40) ? "high (inactive)" : "low (active)");
 	printk("  B7   output port 2   : %s\n",
-	       (buf[1] & 0x80) ? "high" : "low");
+	       (buf[1] & 0x80) ? "high (inactive)" : "low (active)");
 
 	printk(PREFIX "write: byte C 0x%02x\n",buf[2]);
 	printk("  C0-4 top adjustment  : %s dB\n", adjust[buf[2] & 0x1f]);
@@ -545,9 +545,9 @@
 	int rc;
 
 	memset(buf,0,sizeof(buf));
+	tda9887_set_tvnorm(t,buf);
 	buf[1] |= cOutputPort1Inactive;
 	buf[1] |= cOutputPort2Inactive;
-	tda9887_set_tvnorm(t,buf);
 	if (UNSET != t->pinnacle_id) {
 		tda9887_set_pinnacle(t,buf);
 	}
diff -Nru a/drivers/media/video/vino.c b/drivers/media/video/vino.c
--- a/drivers/media/video/vino.c	2002-11-29 08:30:41 -08:00
+++ b/drivers/media/video/vino.c	2005-02-03 06:42:40 -08:00
@@ -1,267 +1,347 @@
-/* $Id: vino.c,v 1.5 1999/10/09 00:01:14 ralf Exp $
- * drivers/char/vino.c
+/*
+ * (incomplete) Driver for the VINO (Video In No Out) system found in SGI Indys.
  *
- * (incomplete) Driver for the Vino Video input system found in SGI Indys.
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License version 2 as published by the Free Software Foundation.
  *
- * Copyright (C) 1999 Ulf Carlsson (ulfc@bun.falkenberg.se)
- *
- * This isn't complete yet, please don't expect any video until I've written
- * some more code.
+ * Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
  */
 
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/wrapper.h>
 #include <linux/errno.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
 #include <linux/videodev.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-sgi.h>
 
 #include <asm/addrspace.h>
 #include <asm/system.h>
+#include <asm/bootinfo.h>
+#include <asm/pgtable.h>
+#include <asm/paccess.h>
+#include <asm/io.h>
+#include <asm/sgi/ip22.h>
+#include <asm/sgi/hpc3.h>
+#include <asm/sgi/mc.h>
 
 #include "vino.h"
 
+/* debugging? */
+#if 1
+#define DEBUG(x...)     printk(x);
+#else
+#define DEBUG(x...)
+#endif
+
+
+/* VINO ASIC registers */
+struct sgi_vino *vino;
+
+static const char *vinostr = "VINO IndyCam/TV";
+static int threshold_a = 512;
+static int threshold_b = 512;
+
 struct vino_device {
 	struct video_device vdev;
+#define VINO_CHAN_A		1
+#define VINO_CHAN_B		2
+	int chan;
+};
 
-	unsigned long chan;
-#define VINO_CHAN_A		0
-#define VINO_CHAN_B		1
-
-	unsigned long flags;
-#define VINO_DMA_ACTIVE		(1<<0)
+struct vino_client {
+	struct i2c_client *driver;
+	int owner;
 };
 
-/* We can actually receive TV and IndyCam input at the same time. Believe it or
- * not..
- */
-static struct vino_device vino[2];
+struct vino_video {
+	struct vino_device chA;
+	struct vino_device chB;
+
+	struct vino_client decoder;
+	struct vino_client camera;
+
+	struct semaphore input_lock;
+
+	/* Loaded into VINO descriptors to clear End Of Descriptors table
+	 * interupt condition */
+	unsigned long dummy_page;
+	unsigned int dummy_buf[4] __attribute__((aligned(8)));
+};
 
-/* Those registers have to be accessed by either *one* 64 bit write or *one* 64
- * bit read. We need some asm to fix this. We can't use mips3 as standard
- * because we just save 32 bits at context switch.
- */
+static struct vino_video *Vino;
 
-static __inline__ unsigned long long vino_reg_read(unsigned long addr)
+unsigned i2c_vino_getctrl(void *data)
 {
-	unsigned long long ret __attribute__ ((aligned (64)));
-	unsigned long virt_addr = KSEG1ADDR(addr + VINO_BASE);
-	unsigned long flags;
-
-	save_and_cli(flags);
-	__asm__ __volatile__(
-		".set\tmips3\n\t"
-		".set\tnoat\n\t"
-		"ld\t$1,(%0)\n\t"
-		"sd\t$1,(%1)\n\t"
-		".set\tat\n\t"
-		".set\tmips0"
-		:
-		:"r" (virt_addr),
-		 "r" (&ret)
-		:"$1");
-	restore_flags(flags);
-
-	return ret;
+	return vino->i2c_control;
 }
 
-static __inline__ void vino_reg_write(unsigned long long value,
-				      unsigned long addr)
+void i2c_vino_setctrl(void *data, unsigned val)
 {
-	unsigned long virt_addr = KSEG1ADDR(addr + VINO_BASE);
-	unsigned long flags;
+	vino->i2c_control = val;
+}
 
-	/* we might lose the upper parts of the registers which are not saved
-	 * if there comes an interrupt in our way, play safe */
+unsigned i2c_vino_rdata(void *data)
+{
+	return vino->i2c_data;
+}
 
-	save_and_cli(flags);
-	__asm__ __volatile__(
-		".set\tmips3\n\t"
-		".set\tnoat\n\t"
-		"ld\t$1,(%0)\n\t"
-		"sd\t$1,(%1)\n\t"
-		".set\tat\n\t"
-		".set\tmips0"
-		:
-		:"r" (&value),
-		 "r" (virt_addr)
-		:"$1");
-	restore_flags(flags);
-}
-
-static __inline__ void vino_reg_and(unsigned long long value,
-				    unsigned long addr)
-{
-	unsigned long virt_addr = KSEG1ADDR(addr + VINO_BASE);
-	unsigned long flags;
-
-	save_and_cli(flags);
-	__asm__ __volatile__(
-		".set\tmips3\n\t"
-		".set\tnoat\n\t"
-		"ld\t$1,(%0)\n\t"
-		"ld\t$2,(%1)\n\t"
-		"and\t$1,$1,$2\n\t"
-		"sd\t$1,(%0)\n\t"
-		".set\tat\n\t"
-		".set\tmips0"
-		:
-		:"r" (virt_addr),
-		 "r" (&value)
-		:"$1","$2");
-	restore_flags(flags);
-}
-
-static __inline__ void vino_reg_or(unsigned long long value,
-				   unsigned long addr)
-{
-	unsigned long virt_addr = KSEG1ADDR(addr + VINO_BASE);
-	unsigned long flags;
-
-	save_and_cli(flags);
-	__asm__ __volatile__(
-		".set\tmips3\n\t"
-		".set\tnoat\n\t"
-		"ld\t$1,(%0)\n\t"
-		"ld\t$2,(%1)\n\t"
-		"or\t$1,$1,$2\n\t"
-		"sd\t$1,(%0)\n\t"
-		".set\tat\n\t"
-		".set\tmips0"
-		:
-		:"r" (virt_addr),
-		 "r" (&value)
-		:"$1","$2");
-	restore_flags(flags);
+void i2c_vino_wdata(void *data, unsigned val)
+{
+	vino->i2c_data = val;
 }
 
-static int vino_dma_setup(void)
+static struct i2c_algo_sgi_data i2c_sgi_vino_data =
 {
-	return 0;
+	.getctrl = &i2c_vino_getctrl,
+	.setctrl = &i2c_vino_setctrl,
+	.rdata   = &i2c_vino_rdata,
+	.wdata   = &i2c_vino_wdata,
+	.xfer_timeout = 200,
+	.ack_timeout  = 1000,
+};
+
+/*
+ * There are two possible clients on VINO I2C bus, so we limit usage only
+ * to them.
+ */
+static int i2c_vino_client_reg(struct i2c_client *client)
+{
+	int res = 0;
+
+	down(&Vino->input_lock);
+	switch (client->driver->id) {
+	case I2C_DRIVERID_SAA7191:
+		if (Vino->decoder.driver)
+			res = -EBUSY;
+		else
+			Vino->decoder.driver = client;
+		break;
+	case I2C_DRIVERID_INDYCAM:
+		if (Vino->camera.driver)
+			res = -EBUSY;
+		else
+			Vino->camera.driver = client;
+		break;
+	default:
+		res = -ENODEV;
+	}
+	up(&Vino->input_lock);
+
+	return res;
 }
 
-static void vino_dma_stop(void)
+static int i2c_vino_client_unreg(struct i2c_client *client)
 {
+	int res = 0;
+
+	down(&Vino->input_lock);
+	if (client == Vino->decoder.driver) {
+		if (Vino->decoder.owner)
+			res = -EBUSY;
+		else
+			Vino->decoder.driver = NULL;
+	} else if (client == Vino->camera.driver) {
+		if (Vino->camera.owner)
+			res = -EBUSY;
+		else
+			Vino->camera.driver = NULL;
+	}
+	up(&Vino->input_lock);
 
+	return res;
 }
 
-static int vino_init(void)
+static struct i2c_adapter vino_i2c_adapter =
 {
-	unsigned long ret;
-	unsigned short rev, id;
-	unsigned long long foo;
-	unsigned long *bar;
-
-	bar = (unsigned long *) &foo;
-
-	ret = vino_reg_read(VINO_REVID);
-
-	rev = (ret & VINO_REVID_REV_MASK);
-	id = (ret & VINO_REVID_ID_MASK) >> 4;
-
-	printk("Vino: ID:%02hx Rev:%02hx\n", id, rev);
-
-	foo = vino_reg_read(VINO_A_DESC_DATA0);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_A_DESC_DATA1);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_A_DESC_DATA2);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_A_DESC_DATA3);
-	printk("0x%lx", bar[0]);
-	printk("%lx\n", bar[1]);
-	foo = vino_reg_read(VINO_B_DESC_DATA0);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_B_DESC_DATA1);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_B_DESC_DATA2);
-	printk("0x%lx", bar[0]);
-	printk("%lx ", bar[1]);
-	foo = vino_reg_read(VINO_B_DESC_DATA3);
-	printk("0x%lx", bar[0]);
-	printk("%lx\n", bar[1]);
+	.name			= "VINO I2C bus",
+	.id			= I2C_HW_SGI_VINO,
+	.algo_data		= &i2c_sgi_vino_data,
+	.client_register	= &i2c_vino_client_reg,
+	.client_unregister	= &i2c_vino_client_unreg,
+};
 
-	return 0;
+static int vino_i2c_add_bus(void)
+{
+	return i2c_sgi_add_bus(&vino_i2c_adapter);
 }
 
-static void vino_dma_go(struct vino_device *v)
+static int vino_i2c_del_bus(void)
 {
-	
+	return i2c_sgi_del_bus(&vino_i2c_adapter);
 }
 
-/* Reset the vino back to default state */
 
-static void vino_setup(struct vino_device *v)
+static void vino_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	
 }
 
 static int vino_open(struct video_device *dev, int flags)
 {
+	struct vino_device *videv = (struct vino_device *)dev;
+
 	return 0;
 }
 
 static void vino_close(struct video_device *dev)
 {
+	struct vino_device *videv = (struct vino_device *)dev;
 }
 
-static int vino_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
+static int vino_mmap(struct video_device *dev, const char *adr,
+		     unsigned long size)
 {
-	return 0;
+	struct vino_device *videv = (struct vino_device *)dev;
+
+	return -EINVAL;
 }
 
-static int vino_mmap(struct video_device *dev, const char *adr,
-		     unsigned long size)
+static int vino_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
 {
-	return 0;
+	struct vino_device *videv = (struct vino_device *)dev;
+
+	return -EINVAL;
 }
 
-static struct video_device vino_dev = {
+static const struct video_device vino_device = {
 	.owner		= THIS_MODULE,
-	.name		= "Vino IndyCam/TV",
-	.type		= VID_TYPE_CAPTURE,
+	.type		= VID_TYPE_CAPTURE | VID_TYPE_SUBCAPTURE,
 	.hardware	= VID_HARDWARE_VINO,
+	.name		= "VINO",
 	.open		= vino_open,
 	.close		= vino_close,
 	.ioctl		= vino_ioctl,
 	.mmap		= vino_mmap,
 };
 
-int __init init_vino(struct video_device *dev)
+static int __init vino_init(void)
 {
-	int err;
+	unsigned long rev;
+	int i, ret = 0;
 
-	err = vino_init();
-	if (err)
-		return err;
+	/* VINO is Indy specific beast */
+	if (ip22_is_fullhouse())
+		return -ENODEV;
 
-#if 0
-	if (video_register_device(&vinodev, VFL_TYPE_GRABBER) == -1) {
+	/*
+	 * VINO is in the EISA address space, so the sysid register will tell
+	 * us if the EISA_PRESENT pin on MC has been pulled low.
+	 *
+	 * If EISA_PRESENT is not set we definitely don't have a VINO equiped
+	 * system.
+	 */
+	if (!(sgimc->systemid & SGIMC_SYSID_EPRESENT)) {
+		printk(KERN_ERR "VINO not found\n");
 		return -ENODEV;
 	}
-#endif
 
-	return 0;
-}
+	vino = (struct sgi_vino *)ioremap(VINO_BASE, sizeof(struct sgi_vino));
+	if (!vino)
+		return -EIO;
+
+	/* Okay, once we know that VINO is present we'll read its revision
+	 * safe way. One never knows... */
+	if (get_dbe(rev, &(vino->rev_id))) {
+		printk(KERN_ERR "VINO: failed to read revision register\n");
+		ret = -ENODEV;
+		goto out_unmap;
+	}
+	if (VINO_ID_VALUE(rev) != VINO_CHIP_ID) {
+		printk(KERN_ERR "VINO is not VINO (Rev/ID: 0x%04lx)\n", rev);
+		ret = -ENODEV;
+		goto out_unmap;
+	}
+	printk(KERN_INFO "VINO Rev: 0x%02lx\n", VINO_REV_NUM(rev));
 
-#ifdef MODULE
-int init_module(void)
-{
-	int err;
+	Vino = (struct vino_video *)
+		kmalloc(sizeof(struct vino_video), GFP_KERNEL);
+	if (!Vino) {
+		ret = -ENOMEM;
+		goto out_unmap;
+	}
+
+	Vino->dummy_page = get_zeroed_page(GFP_KERNEL | GFP_DMA);
+	if (!Vino->dummy_page) {
+		ret = -ENOMEM;
+		goto out_free_vino;
+	}
+	for (i = 0; i < 4; i++)
+		Vino->dummy_buf[i] = PHYSADDR(Vino->dummy_page);
+
+	vino->control = 0;
+	/* prevent VINO from throwing spurious interrupts */
+	vino->a.next_4_desc = PHYSADDR(Vino->dummy_buf);
+	vino->b.next_4_desc = PHYSADDR(Vino->dummy_buf);
+	udelay(5);
+	vino->intr_status = 0;
+        /* set threshold level */
+        vino->a.fifo_thres = threshold_a;
+	vino->b.fifo_thres = threshold_b;
+
+	init_MUTEX(&Vino->input_lock);
+
+	if (request_irq(SGI_VINO_IRQ, vino_interrupt, 0, vinostr, NULL)) {
+		printk(KERN_ERR "VINO: irq%02d registration failed\n",
+		       SGI_VINO_IRQ);
+		ret = -EAGAIN;
+		goto out_free_page;
+	}
 
-	err = vino_init();
-	if (err)
-		return err;
+	ret = vino_i2c_add_bus();
+	if (ret) {
+		printk(KERN_ERR "VINO: I2C bus registration failed\n");
+		goto out_free_irq;
+	}
+
+	if (video_register_device(&Vino->chA.vdev, VFL_TYPE_GRABBER, -1) < 0) {
+		printk("%s, chnl %d: device registration failed.\n",
+			Vino->chA.vdev.name, Vino->chA.chan);
+		ret = -EINVAL;
+		goto out_i2c_del_bus;
+	}
+	if (video_register_device(&Vino->chB.vdev, VFL_TYPE_GRABBER, -1) < 0) {
+		printk("%s, chnl %d: device registration failed.\n",
+			Vino->chB.vdev.name, Vino->chB.chan);
+		ret = -EINVAL;
+		goto out_unregister_vdev;
+	}
 
 	return 0;
+
+out_unregister_vdev:
+	video_unregister_device(&Vino->chA.vdev);
+out_i2c_del_bus:
+	vino_i2c_del_bus();
+out_free_irq:
+	free_irq(SGI_VINO_IRQ, NULL);
+out_free_page:
+	free_page(Vino->dummy_page);
+out_free_vino:
+	kfree(Vino);
+out_unmap:
+	iounmap(vino);
+
+	return ret;
 }
 
-void cleanup_module(void)
+static void __exit vino_exit(void)
 {
+	video_unregister_device(&Vino->chA.vdev);
+	video_unregister_device(&Vino->chB.vdev);
+	vino_i2c_del_bus();
+	free_irq(SGI_VINO_IRQ, NULL);
+	free_page(Vino->dummy_page);
+	kfree(Vino);
+	iounmap(vino);
 }
-#endif
+
+module_init(vino_init);
+module_exit(vino_exit);
+
+MODULE_DESCRIPTION("Video4Linux driver for SGI Indy VINO (IndyCam)");
+MODULE_LICENSE("GPL");
diff -Nru a/drivers/media/video/vino.h b/drivers/media/video/vino.h
--- a/drivers/media/video/vino.h	2002-02-04 23:44:55 -08:00
+++ b/drivers/media/video/vino.h	2005-02-03 06:42:40 -08:00
@@ -1,64 +1,84 @@
 /*
- * Copyright (C) 1999 Ulf Carlsson (ulfc@bun.falkenberg.se)
- * Copyright (C) 2001 Ralf Baechle (ralf@gnu.org)
+ * Copyright (C) 1999 Ulf Karlsson <ulfc@bun.falkenberg.se>
+ * Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
  */
 
-#define VINO_BASE		0x00080000	/* In EISA address space */
+#ifndef VINO_H
+#define VINO_H
 
-#define VINO_REVID		0x0000
-#define VINO_CTRL		0x0008
-#define VINO_INTSTAT		0x0010	/* Interrupt status */
-#define VINO_I2C_CTRL		0x0018
-#define VINO_I2C_DATA		0x0020
-#define VINO_A_ALPHA		0x0028	/* Channel A ... */
-#define VINO_A_CLIPS		0x0030	/* Clipping start */
-#define VINO_A_CLIPE		0x0038	/* Clipping end */
-#define VINO_A_FRAMERT		0x0040	/* Framerate */
-#define VINO_A_FLDCNT		0x0048	/* Field counter */
-#define VINO_A_LNSZ		0x0050
-#define VINO_A_LNCNT		0x0058
-#define VINO_A_PGIX		0x0060	/* Page index */
-#define VINO_A_DESC_PTR		0x0068	/* Ptr to next four descriptors */
-#define VINO_A_DESC_TLB_PTR	0x0070	/* Ptr to start of descriptor table */
-#define VINO_A_DESC_DATA0	0x0078	/* Descriptor data 0 */
-#define VINO_A_DESC_DATA1	0x0080	/* ... */
-#define VINO_A_DESC_DATA2	0x0088
-#define VINO_A_DESC_DATA3	0x0090
-#define VINO_A_FIFO_THRESHOLD	0x0098	/* FIFO threshold */
-#define VINO_A_FIFO_RP		0x00a0
-#define VINO_A_FIFO_WP		0x00a8
-#define VINO_B_ALPHA		0x00b0	/* Channel B ... */
-#define VINO_B_CLIPS		0x00b8
-#define VINO_B_CLIPE		0x00c0
-#define VINO_B_FRAMERT		0x00c8
-#define VINO_B_FLDCNT		0x00d0
-#define VINO_B_LNSZ		0x00d8
-#define VINO_B_LNCNT		0x00e0
-#define VINO_B_PGIX		0x00e8
-#define VINO_B_DESC_PTR		0x00f0
-#define VINO_B_DESC_TLB_PTR	0x00f8
-#define VINO_B_DESC_DATA0	0x0100
-#define VINO_B_DESC_DATA1	0x0108
-#define VINO_B_DESC_DATA2	0x0110
-#define VINO_B_DESC_DATA3	0x0118
-#define VINO_B_FIFO_THRESHOLD	0x0120
-#define VINO_B_FIFO_RP		0x0128
-#define VINO_B_FIFO_WP		0x0130
+#define VINO_BASE	0x00080000	/* Vino is in the EISA address space,
+					 * but it is not an EISA bus card */
 
-/* Bits in the VINO_REVID register */
-
-#define VINO_REVID_REV_MASK		0x000f	/* bits 0:3 */
-#define VINO_REVID_ID_MASK		0x00f0	/* bits 4:7 */
-
-/* Bits in the VINO_CTRL register */
+struct sgi_vino_channel {
+	u32 _pad_alpha;
+	volatile u32 alpha;
+
+#define VINO_CLIP_X(x)		((x) & 0x3ff)		/* bits 0:9 */
+#define VINO_CLIP_ODD(x)	(((x) & 0x1ff) << 10)	/* bits 10:18 */
+#define VINO_CLIP_EVEN(x)	(((x) & 0x1ff) << 19)	/* bits 19:27 */
+	u32 _pad_clip_start;
+	volatile u32 clip_start;
+	u32 _pad_clip_end;
+	volatile u32 clip_end;
+
+#define VINO_FRAMERT_PAL	(1<<0)			/* 0=NTSC 1=PAL */
+#define VINO_FRAMERT_RT(x)	(((x) & 0x1fff) << 1)	/* bits 1:12 */
+	u32 _pad_frame_rate;
+	volatile u32 frame_rate;
+
+	u32 _pad_field_counter;
+	volatile u32 field_counter;
+	u32 _pad_line_size;
+	volatile u32 line_size;
+	u32 _pad_line_count;
+	volatile u32 line_count;
+	u32 _pad_page_index;
+	volatile u32 page_index;
+	u32 _pad_next_4_desc;
+	volatile u32 next_4_desc;
+	u32 _pad_start_desc_tbl;
+	volatile u32 start_desc_tbl;
+
+#define VINO_DESC_JUMP		(1<<30)
+#define VINO_DESC_STOP		(1<<31)
+#define VINO_DESC_VALID		(1<<32)
+	u32 _pad_desc_0;
+	volatile u32 desc_0;
+	u32 _pad_desc_1;
+	volatile u32 desc_1;
+	u32 _pad_desc_2;
+	volatile u32 desc_2;
+	u32 _pad_Bdesc_3;
+	volatile u32 desc_3;
+
+	u32 _pad_fifo_thres;
+	volatile u32 fifo_thres;
+	u32 _pad_fifo_read;
+	volatile u32 fifo_read;
+	u32 _pad_fifo_write;
+	volatile u32 fifo_write;
+};
+
+struct sgi_vino {
+#define VINO_CHIP_ID		0xb
+#define VINO_REV_NUM(x)		((x) & 0x0f)
+#define VINO_ID_VALUE(x)	(((x) & 0xf0) >> 4)
+	u32 _pad_rev_id;
+	volatile u32 rev_id;
 
 #define VINO_CTRL_LITTLE_ENDIAN		(1<<0)
 #define VINO_CTRL_A_FIELD_TRANS_INT	(1<<1)	/* Field transferred int */
 #define VINO_CTRL_A_FIFO_OF_INT		(1<<2)	/* FIFO overflow int */
 #define VINO_CTRL_A_END_DESC_TBL_INT	(1<<3)	/* End of desc table int */
+#define VINO_CTRL_A_INT			(VINO_CTRL_A_FIELD_TRANS_INT | \
+					 VINO_CTRL_A_FIFO_OF_INT | \
+					 VINO_CTRL_A_END_DESC_TBL_INT)
 #define VINO_CTRL_B_FIELD_TRANS_INT	(1<<4)	/* Field transferred int */
 #define VINO_CTRL_B_FIFO_OF_INT		(1<<5)	/* FIFO overflow int */
-#define VINO_CTRL_B_END_DESC_TLB_INT	(1<<6)	/* End of desc table int */
+#define VINO_CTRL_B_END_DESC_TBL_INT	(1<<6)	/* End of desc table int */
+#define VINO_CTRL_B_INT			(VINO_CTRL_B_FIELD_TRANS_INT | \
+					 VINO_CTRL_B_FIFO_OF_INT | \
+					 VINO_CTRL_B_END_DESC_TBL_INT)
 #define VINO_CTRL_A_DMA_ENBL		(1<<7)
 #define VINO_CTRL_A_INTERLEAVE_ENBL	(1<<8)
 #define VINO_CTRL_A_SYNC_ENBL		(1<<9)
@@ -67,51 +87,45 @@
 #define VINO_CTRL_A_LUMA_ONLY		(1<<12)
 #define VINO_CTRL_A_DEC_ENBL		(1<<13)	/* Decimation */
 #define VINO_CTRL_A_DEC_SCALE_MASK	0x1c000	/* bits 14:17 */
+#define VINO_CTRL_A_DEC_SCALE_SHIFT	(14)
 #define VINO_CTRL_A_DEC_HOR_ONLY	(1<<17)	/* Horizontal only */
 #define VINO_CTRL_A_DITHER		(1<<18)	/* 24 -> 8 bit dither */
 #define VINO_CTRL_B_DMA_ENBL		(1<<19)
 #define VINO_CTRL_B_INTERLEAVE_ENBL	(1<<20)
 #define VINO_CTRL_B_SYNC_ENBL		(1<<21)
 #define VINO_CTRL_B_SELECT		(1<<22)	/* 1=D1 0=Philips */
-#define VINO_CTRL_B_RGB			(1<<22)	/* 1=RGB 0=YUV */
-#define VINO_CTRL_B_LUMA_ONLY		(1<<23)
-#define VINO_CTRL_B_DEC_ENBL		(1<<24)	/* Decimation */
-#define VINO_CTRL_B_DEC_SCALE_MASK	0x1c000000	/* bits 25:28 */
+#define VINO_CTRL_B_RGB			(1<<23)	/* 1=RGB 0=YUV */
+#define VINO_CTRL_B_LUMA_ONLY		(1<<24)
+#define VINO_CTRL_B_DEC_ENBL		(1<<25)	/* Decimation */
+#define VINO_CTRL_B_DEC_SCALE_MASK	0x1c000000	/* bits 26:28 */
+#define VINO_CTRL_B_DEC_SCALE_SHIFT	(26)
 #define VINO_CTRL_B_DEC_HOR_ONLY	(1<<29)	/* Decimation horizontal only */
 #define VINO_CTRL_B_DITHER		(1<<30)	/* ChanB 24 -> 8 bit dither */
-
-/* Bits in the Interrupt and Status register */
+	u32 _pad_control;
+	volatile u32 control;
 
 #define VINO_INTSTAT_A_FIELD_TRANS	(1<<0)	/* Field transferred int */
 #define VINO_INTSTAT_A_FIFO_OF		(1<<1)	/* FIFO overflow int */
 #define VINO_INTSTAT_A_END_DESC_TBL	(1<<2)	/* End of desc table int */
+#define VINO_INTSTAT_A			(VINO_INTSTAT_A_FIELD_TRANS | \
+					 VINO_INTSTAT_A_FIFO_OF | \
+					 VINO_INTSTAT_A_END_DESC_TBL)
 #define VINO_INTSTAT_B_FIELD_TRANS	(1<<3)	/* Field transferred int */
 #define VINO_INTSTAT_B_FIFO_OF		(1<<4)	/* FIFO overflow int */
 #define VINO_INTSTAT_B_END_DESC_TBL	(1<<5)	/* End of desc table int */
+#define VINO_INTSTAT_B			(VINO_INTSTAT_B_FIELD_TRANS | \
+					 VINO_INTSTAT_B_FIFO_OF | \
+					 VINO_INTSTAT_B_END_DESC_TBL)
+	u32 _pad_intr_status;
+	volatile u32 intr_status;
+
+	u32 _pad_i2c_control;
+	volatile u32 i2c_control;
+	u32 _pad_i2c_data;
+	volatile u32 i2c_data;
+
+	struct sgi_vino_channel a;
+	struct sgi_vino_channel b;
+};
 
-/* Bits in the Clipping Start register */
-
-#define VINO_CLIPS_START		0x3ff		/* bits 0:9 */
-#define VINO_CLIPS_ODD_MASK		0x7fc00		/* bits 10:18 */
-#define VINO_CLIPS_EVEN_MASK		0xff80000	/* bits 19:27 */
-
-/* Bits in the Clipping End register */
-
-#define VINO_CLIPE_END			0x3ff		/* bits 0:9 */
-#define VINO_CLIPE_ODD_MASK		0x7fc00		/* bits 10:18 */
-#define VINO_CLIPE_EVEN_MASK		0xff80000	/* bits 19:27 */
-
-/* Bits in the Frame Rate register */
-
-#define VINO_FRAMERT_PAL		(1<<0)	/* 0=NTSC 1=PAL */
-#define VINO_FRAMERT_RT_MASK		0x1ffe		/* bits 1:12 */
-
-/* Bits in the VINO_I2C_CTRL */
-
-#define VINO_CTRL_I2C_IDLE		(1<<0)	/* write: 0=force idle
-						 * read: 0=idle 1=not idle */
-#define VINO_CTRL_I2C_DIR		(1<<1)	/* 0=read 1=write */
-#define VINO_CTRL_I2C_MORE_BYTES	(1<<2)	/* 0=last byte 1=more bytes */
-#define VINO_CTRL_I2C_TRANS_BUSY	(1<<4)	/* 0=trans done 1=trans busy */
-#define VINO_CTRL_I2C_ACK		(1<<5)	/* 0=ack received 1=ack not */
-#define VINO_CTRL_I2C_BUS_ERROR		(1<<7)	/* 0=no bus err 1=bus err */
+#endif
diff -Nru a/drivers/pci/hotplug/rpaphp.h b/drivers/pci/hotplug/rpaphp.h
--- a/drivers/pci/hotplug/rpaphp.h	2004-10-06 09:43:44 -07:00
+++ b/drivers/pci/hotplug/rpaphp.h	2005-02-02 22:42:11 -08:00
@@ -109,13 +109,6 @@
 extern struct list_head rpaphp_slot_head;
 extern int num_slots;
 
-static inline int is_hotplug_capable(struct device_node *dn)
-{
-	unsigned char *ptr = get_property(dn, "ibm,fw-pci-hot-plug-ctrl", NULL);
-
-	return (int) (ptr != NULL);
-}
-
 /* function prototypes */
 
 /* rpaphp_pci.c */
diff -Nru a/drivers/pci/hotplug/rpaphp_core.c b/drivers/pci/hotplug/rpaphp_core.c
--- a/drivers/pci/hotplug/rpaphp_core.c	2004-10-06 09:43:44 -07:00
+++ b/drivers/pci/hotplug/rpaphp_core.c	2005-02-02 22:42:11 -08:00
@@ -287,26 +287,43 @@
 	return 1;
 }
 
-static int is_php_dn(struct device_node *dn, int **indexes, int **names, int **types,
-	  int **power_domains)
+static int is_php_type(char *drc_type)
 {
+	unsigned long value;
+	char *endptr;
+
+	/* PCI Hotplug nodes have an integer for drc_type */
+	value = simple_strtoul(drc_type, &endptr, 10);
+	if (endptr == drc_type)
+		return 0;
+
+	return 1;
+}
+
+static int is_php_dn(struct device_node *dn, int **indexes, int **names,
+		int **types, int **power_domains)
+{
+	int *drc_types;
 	int rc;
 
-	if (!is_hotplug_capable(dn))
-		return (0);
-	rc = get_children_props(dn, indexes, names, types, power_domains);
-	if (rc)
-		return (0);
-	return (1);
+	rc = get_children_props(dn, indexes, names, &drc_types, power_domains);
+	if (rc) {
+		if (is_php_type((char *) &drc_types[1])) {
+			*types = drc_types;
+			return 1;
+		}
+	}
+
+	return 0;
 }
 
-static int is_dr_dn(struct device_node *dn, int **indexes, int **names, int **types,
-	  int **power_domains, int **my_drc_index)
+static int is_dr_dn(struct device_node *dn, int **indexes, int **names,
+		int **types, int **power_domains, int **my_drc_index)
 {
 	int rc;
 
 	*my_drc_index = (int *) get_property(dn, "ibm,my-drc-index", NULL);
-	if(!*my_drc_index) 		
+	if(!*my_drc_index)
 		return (0);
 
 	if (!dn->parent)
diff -Nru a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
--- a/drivers/pci/pci-sysfs.c	2005-01-06 12:30:29 -08:00
+++ b/drivers/pci/pci-sysfs.c	2005-02-02 22:42:15 -08:00
@@ -436,6 +436,7 @@
 		
 		rom_attr = kmalloc(sizeof(*rom_attr), GFP_ATOMIC);
 		if (rom_attr) {
+			memset(rom_attr, 0x00, sizeof(*rom_attr));
 			pdev->rom_attr = rom_attr;
 			rom_attr->size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
 			rom_attr->attr.name = "rom";
diff -Nru a/drivers/pci/pcie/portdrv.h b/drivers/pci/pcie/portdrv.h
--- a/drivers/pci/pcie/portdrv.h	2005-01-14 15:07:35 -08:00
+++ b/drivers/pci/pcie/portdrv.h	2005-02-02 22:41:40 -08:00
@@ -28,14 +28,13 @@
 #define get_descriptor_id(type, service) (((type - 4) << 4) | service)
 
 extern struct bus_type pcie_port_bus_type;
-extern struct device_driver pcieport_generic_driver;
 extern int pcie_port_device_probe(struct pci_dev *dev);
 extern int pcie_port_device_register(struct pci_dev *dev);
 #ifdef CONFIG_PM
-extern int pcie_port_device_suspend(struct pcie_device *dev, u32 state);
-extern int pcie_port_device_resume(struct pcie_device *dev);
+extern int pcie_port_device_suspend(struct pci_dev *dev, u32 state);
+extern int pcie_port_device_resume(struct pci_dev *dev);
 #endif
-extern void pcie_port_device_remove(struct pcie_device *dev);
+extern void pcie_port_device_remove(struct pci_dev *dev);
 extern void pcie_port_bus_register(void);
 extern void pcie_port_bus_unregister(void);
 
diff -Nru a/drivers/pci/pcie/portdrv_bus.c b/drivers/pci/pcie/portdrv_bus.c
--- a/drivers/pci/pcie/portdrv_bus.c	2005-01-14 15:07:35 -08:00
+++ b/drivers/pci/pcie/portdrv_bus.c	2005-02-02 22:41:40 -08:00
@@ -14,8 +14,6 @@
 
 #include <linux/pcieport_if.h>
 
-static int generic_probe (struct device *dev) {	return 0;}
-static int generic_remove (struct device *dev) { return 0;}
 static int pcie_port_bus_match(struct device *dev, struct device_driver *drv);
 static int pcie_port_bus_suspend(struct device *dev, u32 state);
 static int pcie_port_bus_resume(struct device *dev);
@@ -27,23 +25,14 @@
 	.resume		= pcie_port_bus_resume, 
 };
 
-struct device_driver pcieport_generic_driver = {
-	.name =	"pcieport",
-	.bus = &pcie_port_bus_type,
-	.probe = generic_probe,
-	.remove = generic_remove,
-};
-
 static int pcie_port_bus_match(struct device *dev, struct device_driver *drv)
 {
 	struct pcie_device *pciedev;
 	struct pcie_port_service_driver *driver;
 
-	if (	drv->bus != &pcie_port_bus_type || 
-		dev->bus != &pcie_port_bus_type	||
-		drv == &pcieport_generic_driver) {
+	if (drv->bus != &pcie_port_bus_type || dev->bus != &pcie_port_bus_type)
 		return 0;
-	}
+	
 	pciedev = to_pcie_device(dev);
 	driver = to_service_driver(drv);
 	if (   (driver->id_table->vendor != PCI_ANY_ID && 
diff -Nru a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
--- a/drivers/pci/pcie/portdrv_core.c	2005-01-14 15:07:35 -08:00
+++ b/drivers/pci/pcie/portdrv_core.c	2005-02-02 22:41:40 -08:00
@@ -17,8 +17,6 @@
 
 extern int pcie_mch_quirk;	/* MSI-quirk Indicator */
 
-extern struct device_driver pcieport_generic_driver;
-
 static int pcie_port_probe_service(struct device *dev)
 {
 	struct pcie_device *pciedev;
@@ -103,6 +101,7 @@
  */
 static void release_pcie_device(struct device *dev)
 {
+	printk(KERN_DEBUG "Free Port Service[%s]\n", dev->bus_id);
 	kfree(to_pcie_device(dev));			
 }
 
@@ -217,18 +216,18 @@
 	return services;
 }
 
-static void pcie_device_init(struct pcie_device *parent, 
-			struct pcie_device *dev, 
-			int port_type, int service_type)
+static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev, 
+	int port_type, int service_type, int irq, int irq_mode)
 {
 	struct device *device;
 
-	if (parent) {
-		dev->id.vendor = parent->port->vendor;
-		dev->id.device = parent->port->device;
-		dev->id.port_type = port_type;
-		dev->id.service_type = (1 << service_type);
-	}
+	dev->port = parent;
+	dev->interrupt_mode = irq_mode;
+	dev->irq = irq;
+	dev->id.vendor = parent->vendor;
+	dev->id.device = parent->device;
+	dev->id.port_type = port_type;
+	dev->id.service_type = (1 << service_type);
 
 	/* Initialize generic device interface */
 	device = &dev->device;
@@ -240,35 +239,23 @@
 	device->driver = NULL;
 	device->driver_data = NULL; 
 	device->release = release_pcie_device;	/* callback to free pcie dev */
-	sprintf(&device->bus_id[0], "%s.%02x", parent->device.bus_id, 
-			get_descriptor_id(port_type, service_type));
-	device->parent = ((parent == NULL) ? NULL : &parent->device);
+	sprintf(&device->bus_id[0], "pcie%02x", 
+		get_descriptor_id(port_type, service_type));
+	device->parent = &parent->dev;
 }
 
-static struct pcie_device* alloc_pcie_device(
-	struct pcie_device *parent, struct pci_dev *bridge, 
+static struct pcie_device* alloc_pcie_device(struct pci_dev *parent, 
 	int port_type, int service_type, int irq, int irq_mode)
 {
 	struct pcie_device *device;
-	static int NR_PORTS = 0;
 
 	device = kmalloc(sizeof(struct pcie_device), GFP_KERNEL);
 	if (!device)
 		return NULL;
 
 	memset(device, 0, sizeof(struct pcie_device));
-	device->port = bridge;
-	device->interrupt_mode = irq_mode;
-	device->irq = irq;
-	if (!parent) {
-		pcie_device_init(NULL, device, port_type, service_type);
-		NR_PORTS++;
-		device->device.driver = &pcieport_generic_driver;
-		sprintf(&device->device.bus_id[0], "port%d", NR_PORTS); 
-	} else { 
-		pcie_device_init(parent, device, port_type, service_type);
-	}
-	printk(KERN_DEBUG "Allocate Port Device[%s]\n", device->device.bus_id);
+	pcie_device_init(parent, device, port_type, service_type, irq,irq_mode);
+	printk(KERN_DEBUG "Allocate Port Service[%s]\n", device->device.bus_id);
 	return device;
 }
 
@@ -291,7 +278,6 @@
 
 int pcie_port_device_register(struct pci_dev *dev)
 {
-	struct pcie_device *parent;
 	int status, type, capabilities, irq_mode, i;
 	int vectors[PCIE_PORT_DEVICE_MAXSERVICES];
 	u16 reg16;
@@ -306,27 +292,13 @@
 	capabilities = get_port_device_capability(dev);
 	irq_mode = assign_interrupt_mode(dev, vectors, capabilities);
 
-	/* Allocate parent */
-	parent = alloc_pcie_device(NULL, dev, type, 0, dev->irq, irq_mode);
-	if (!parent) 
-		return -ENOMEM;
-	
-	status = device_register(&parent->device);
-	if (status) {
-		kfree(parent);
-		return status;
-	}
-	get_device(&parent->device);
-	pci_set_drvdata(dev, parent);	
-
 	/* Allocate child services if any */
 	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
 		struct pcie_device *child;
 
 		if (capabilities & (1 << i)) {
 			child = alloc_pcie_device(
-				parent,		/* parent */ 
-				dev, 		/* Root/Upstream/Downstream */
+				dev, 		/* parent */
 				type,		/* port type */ 
 				i,		/* service type */
 				vectors[i],	/* irq */
@@ -345,17 +317,21 @@
 }
 
 #ifdef CONFIG_PM
-int pcie_port_device_suspend(struct pcie_device *dev, u32 state)
+int pcie_port_device_suspend(struct pci_dev *dev, u32 state)
 {
-	struct list_head 		*head;
+	struct list_head 		*head, *tmp;
 	struct device 			*parent, *child;
 	struct device_driver 		*driver;
 	struct pcie_port_service_driver *service_driver;
 
-	parent = &dev->device;
+	parent = &dev->dev;
 	head = &parent->children;
-	while (!list_empty(head)) {
-		child = container_of(head->next, struct device, node);
+	tmp = head->next;
+	while (head != tmp) {
+		child = container_of(tmp, struct device, node);
+		tmp = tmp->next;
+		if (child->bus != &pcie_port_bus_type)
+			continue;
 		driver = child->driver;
 		if (!driver)
 			continue;
@@ -366,17 +342,21 @@
 	return 0; 
 }
 
-int pcie_port_device_resume(struct pcie_device *dev) 
+int pcie_port_device_resume(struct pci_dev *dev) 
 { 
-	struct list_head 		*head;
+	struct list_head 		*head, *tmp;
 	struct device 			*parent, *child;
 	struct device_driver 		*driver;
 	struct pcie_port_service_driver *service_driver;
 
-	parent = &dev->device;
+	parent = &dev->dev;
 	head = &parent->children;
-	while (!list_empty(head)) {
-		child = container_of(head->next, struct device, node);
+	tmp = head->next;
+	while (head != tmp) {
+		child = container_of(tmp, struct device, node);
+		tmp = tmp->next;
+		if (child->bus != &pcie_port_bus_type)
+			continue;
 		driver = child->driver;
 		if (!driver)
 			continue;
@@ -389,45 +369,46 @@
 }
 #endif
 
-void pcie_port_device_remove(struct pcie_device *dev)
+void pcie_port_device_remove(struct pci_dev *dev)
 {
-	struct list_head 		*head;
+	struct list_head 		*head, *tmp;
 	struct device 			*parent, *child;
 	struct device_driver 		*driver;
 	struct pcie_port_service_driver *service_driver;
+	int interrupt_mode = PCIE_PORT_INTx_MODE;
 
-	parent = &dev->device;
+	parent = &dev->dev;
 	head = &parent->children;
-	while (!list_empty(head)) {
-		child = container_of(head->next, struct device, node);
+	tmp = head->next;
+	while (head != tmp) {
+		child = container_of(tmp, struct device, node);
+		tmp = tmp->next;
+		if (child->bus != &pcie_port_bus_type)
+			continue;
 		driver = child->driver;
 		if (driver) { 
 			service_driver = to_service_driver(driver);
 			if (service_driver->remove)  
 				service_driver->remove(to_pcie_device(child));
 		}
+		interrupt_mode = (to_pcie_device(child))->interrupt_mode;
 		put_device(child);
 		device_unregister(child);
 	}
-
 	/* Switch to INTx by default if MSI enabled */
-	if (dev->interrupt_mode == PCIE_PORT_MSIX_MODE)
-		pci_disable_msix(dev->port);
-	else if (dev->interrupt_mode == PCIE_PORT_MSI_MODE)
-		pci_disable_msi(dev->port);
-	put_device(parent);
-	device_unregister(parent);
+	if (interrupt_mode == PCIE_PORT_MSIX_MODE)
+		pci_disable_msix(dev);
+	else if (interrupt_mode == PCIE_PORT_MSI_MODE)
+		pci_disable_msi(dev);
 }
 
 void pcie_port_bus_register(void)
 {
 	bus_register(&pcie_port_bus_type);
-	driver_register(&pcieport_generic_driver);
 }
 
 void pcie_port_bus_unregister(void)
 {
-	driver_unregister(&pcieport_generic_driver);
 	bus_unregister(&pcie_port_bus_type);
 }
 
diff -Nru a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
--- a/drivers/pci/pcie/portdrv_pci.c	2005-01-14 15:07:35 -08:00
+++ b/drivers/pci/pcie/portdrv_pci.c	2005-02-02 22:41:40 -08:00
@@ -63,34 +63,18 @@
 
 static void pcie_portdrv_remove (struct pci_dev *dev)
 {
-	struct pcie_device *pciedev;
-
-      	pciedev = (struct pcie_device *)pci_get_drvdata(dev);
-	if (pciedev) {
-		pcie_port_device_remove(pciedev);
-		pci_set_drvdata(dev, NULL); 
-	}
+	pcie_port_device_remove(dev);
 }
 
 #ifdef CONFIG_PM
 static int pcie_portdrv_suspend (struct pci_dev *dev, u32 state)
 {
-	struct pcie_device *pciedev;
-	
-      	pciedev = (struct pcie_device *)pci_get_drvdata(dev);
-	if (pciedev) 
-		pcie_port_device_suspend(pciedev, state);
-	return 0;
+	return pcie_port_device_suspend(dev, state);
 }
 
 static int pcie_portdrv_resume (struct pci_dev *dev)
 {
-	struct pcie_device *pciedev;
-	
-      	pciedev = (struct pcie_device *)pci_get_drvdata(dev);
-	if (pciedev) 
-		pcie_port_device_resume(pciedev);
-	return 0;
+	return pcie_port_device_resume(dev);
 }
 #endif
 
diff -Nru a/drivers/pci/probe.c b/drivers/pci/probe.c
--- a/drivers/pci/probe.c	2005-01-14 15:06:55 -08:00
+++ b/drivers/pci/probe.c	2005-02-02 22:42:24 -08:00
@@ -879,7 +879,7 @@
 
 	if (pci_find_bus(pci_domain_nr(b), bus)) {
 		/* If we already got to this bus through a different bridge, ignore it */
-		DBG("PCI: Bus %04:%02x already known\n", pci_domain_nr(b), bus);
+		DBG("PCI: Bus %04x:%02x already known\n", pci_domain_nr(b), bus);
 		goto err_out;
 	}
 	list_add_tail(&b->node, &pci_root_buses);
diff -Nru a/drivers/pci/quirks.c b/drivers/pci/quirks.c
--- a/drivers/pci/quirks.c	2005-01-10 08:52:27 -08:00
+++ b/drivers/pci/quirks.c	2005-02-02 22:42:20 -08:00
@@ -216,6 +216,16 @@
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443BX_2, 	quirk_natoma );
 
 /*
+ *  This chip can cause PCI parity errors if config register 0xA0 is read
+ *  while DMAs are occurring.
+ */
+static void __devinit quirk_citrine(struct pci_dev *dev)
+{
+	dev->cfg_size = 0xA0;
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_IBM,	PCI_DEVICE_ID_IBM_CITRINE,	quirk_citrine );
+
+/*
  *  S3 868 and 968 chips report region size equal to 32M, but they decode 64M.
  *  If it's needed, re-allocate the region.
  */
diff -Nru a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
--- a/drivers/pcmcia/i82365.c	2005-01-25 13:50:25 -08:00
+++ b/drivers/pcmcia/i82365.c	2005-02-03 06:42:43 -08:00
@@ -208,6 +208,7 @@
 #define IS_UNKNOWN	0x0400
 #define IS_VG_PWR	0x0800
 #define IS_DF_PWR	0x1000
+#define IS_REGISTERED	0x2000
 #define IS_ALIVE	0x8000
 
 typedef struct pcic_t {
@@ -1403,12 +1404,10 @@
 	    socket[i].socket.resource_ops = &pccard_nonstatic_ops;
 	    socket[i].socket.owner = THIS_MODULE;
 	    socket[i].number = i;
-	    ret = pcmcia_register_socket(&socket[i].socket);	    
-	    if (ret && i--) {
-		    for (; i>= 0; i--)
-			    pcmcia_unregister_socket(&socket[i].socket);
-		    break;
-	    }
+	    ret = pcmcia_register_socket(&socket[i].socket);
+	    if (!ret)
+		    socket[i].flags |= IS_REGISTERED;
+
 #if 0 /* driver model ordering issue */
 	   class_device_create_file(&socket[i].socket.dev,
 			   	    &class_device_attr_info);
@@ -1435,7 +1434,8 @@
     int i;
 
     for (i = 0; i < sockets; i++) {
-	    pcmcia_unregister_socket(&socket[i].socket);
+	    if (socket[i].flags & IS_REGISTERED)
+		    pcmcia_unregister_socket(&socket[i].socket);
     }
     platform_device_unregister(&i82365_device);
     if (poll_interval != 0)
diff -Nru a/drivers/pcmcia/m32r_cfc.c b/drivers/pcmcia/m32r_cfc.c
--- a/drivers/pcmcia/m32r_cfc.c	2005-01-25 13:50:25 -08:00
+++ b/drivers/pcmcia/m32r_cfc.c	2005-02-03 06:42:44 -08:00
@@ -239,6 +239,7 @@
 
 /*====================================================================*/
 
+#define IS_REGISTERED		0x2000
 #define IS_ALIVE		0x8000
 
 typedef struct pcc_t {
@@ -835,11 +836,9 @@
 		socket[i].socket.owner = THIS_MODULE;
 		socket[i].number = i;
 		ret = pcmcia_register_socket(&socket[i].socket);
-		if (ret && i--) {
-			for (; i>= 0; i--)
-				pcmcia_unregister_socket(&socket[i].socket);
-			break;
-		}
+		if (!ret)
+			socket[i].flags |= IS_REGISTERED;
+
 #if 0	/* driver model ordering issue */
 		class_device_create_file(&socket[i].socket.dev,
 					 &class_device_attr_info);
@@ -865,7 +864,8 @@
 	int i;
 
 	for (i = 0; i < pcc_sockets; i++)
-		pcmcia_unregister_socket(&socket[i].socket);
+		if (socket[i].flags & IS_REGISTERED)
+			pcmcia_unregister_socket(&socket[i].socket);
 
 	platform_device_unregister(&pcc_device);
 	if (poll_interval != 0)
diff -Nru a/drivers/pcmcia/m32r_pcc.c b/drivers/pcmcia/m32r_pcc.c
--- a/drivers/pcmcia/m32r_pcc.c	2005-01-25 13:50:25 -08:00
+++ b/drivers/pcmcia/m32r_pcc.c	2005-02-03 06:42:44 -08:00
@@ -257,6 +257,7 @@
 
 /*====================================================================*/
 
+#define IS_REGISTERED		0x2000
 #define IS_ALIVE		0x8000
 
 typedef struct pcc_t {
@@ -772,11 +773,9 @@
 		socket[i].socket.owner = THIS_MODULE;
 		socket[i].number = i;
 		ret = pcmcia_register_socket(&socket[i].socket);
-		if (ret && i--) {
-			for (; i>= 0; i--)
-				pcmcia_unregister_socket(&socket[i].socket);
-			break;
-		}
+		if (!ret)
+			socket[i].flags |= IS_REGISTERED;
+
 #if 0	/* driver model ordering issue */
 		class_device_create_file(&socket[i].socket.dev,
 					 &class_device_attr_info);
@@ -802,7 +801,8 @@
 	int i;
 
 	for (i = 0; i < pcc_sockets; i++)
-		pcmcia_unregister_socket(&socket[i].socket);
+		if (socket[i].flags & IS_REGISTERED)
+			pcmcia_unregister_socket(&socket[i].socket);
 
 	platform_device_unregister(&pcc_device);
 	if (poll_interval != 0)
diff -Nru a/drivers/pnp/pnpbios/core.c b/drivers/pnp/pnpbios/core.c
--- a/drivers/pnp/pnpbios/core.c	2005-01-30 21:12:33 -08:00
+++ b/drivers/pnp/pnpbios/core.c	2005-02-03 06:42:38 -08:00
@@ -61,6 +61,7 @@
 #include <linux/spinlock.h>
 #include <linux/dmi.h>
 #include <linux/delay.h>
+#include <linux/acpi.h>
 
 #include <asm/page.h>
 #include <asm/desc.h>
@@ -539,7 +540,6 @@
 	}
 
 #ifdef CONFIG_PNPACPI
-	extern int pnpacpi_disabled;
 	if (!acpi_disabled && !pnpacpi_disabled) {
 		pnpbios_disabled = 1;
 		printk(KERN_INFO "PnPBIOS: Disabled by ACPI PNP\n");
diff -Nru a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
--- a/drivers/s390/block/dasd.c	2005-01-15 14:01:58 -08:00
+++ b/drivers/s390/block/dasd.c	2005-02-03 06:42:42 -08:00
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision: 1.154 $
+ * $Revision: 1.156 $
  */
 
 #include <linux/config.h>
@@ -179,7 +179,7 @@
 	device->debug_area = debug_register(device->cdev->dev.bus_id, 0, 2,
 					    8 * sizeof (long));
 	debug_register_view(device->debug_area, &debug_sprintf_view);
-	debug_set_level(device->debug_area, DBF_DEBUG);
+	debug_set_level(device->debug_area, DBF_EMERG);
 	DBF_DEV_EVENT(DBF_EMERG, device, "%s", "debug area created");
 
 	device->state = DASD_STATE_BASIC;
@@ -745,8 +745,9 @@
 	switch (rc) {
 	case 0:
 		cqr->status = DASD_CQR_IN_IO;
-		DBF_DEV_EVENT(DBF_DEBUG, device, "%s",
-			      "start_IO: request %p started successful");
+		DBF_DEV_EVENT(DBF_DEBUG, device,
+			      "start_IO: request %p started successful",
+			      cqr);
 		break;
 	case -EBUSY:
 		DBF_DEV_EVENT(DBF_ERR, device, "%s",
@@ -1579,25 +1580,26 @@
 }
 
 /*
- * Allocate and initialize request queue.
+ * Allocate and initialize request queue and default I/O scheduler.
  */
 static int
 dasd_alloc_queue(struct dasd_device * device)
 {
+	int rc;
+
 	device->request_queue = blk_init_queue(do_dasd_request,
 					       &device->request_queue_lock);
 	if (device->request_queue == NULL)
 		return -ENOMEM;
 
 	device->request_queue->queuedata = device;
-#if 0
+
 	elevator_exit(device->request_queue->elevator);
-	rc = elevator_init(device->request_queue, "noop");
+	rc = elevator_init(device->request_queue, "deadline");
 	if (rc) {
 		blk_cleanup_queue(device->request_queue);
 		return rc;
 	}
-#endif
 	return 0;
 }
 
@@ -1963,7 +1965,7 @@
 		goto failed;
 	}
 	debug_register_view(dasd_debug_area, &debug_sprintf_view);
-	debug_set_level(dasd_debug_area, DBF_DEBUG);
+	debug_set_level(dasd_debug_area, DBF_EMERG);
 
 	DBF_EVENT(DBF_EMERG, "%s", "debug area created");
 
diff -Nru a/drivers/s390/cio/cio.c b/drivers/s390/cio/cio.c
--- a/drivers/s390/cio/cio.c	2005-01-03 15:49:38 -08:00
+++ b/drivers/s390/cio/cio.c	2005-02-03 06:42:43 -08:00
@@ -175,9 +175,10 @@
 }
 
 int
-cio_start (struct subchannel *sch,	/* subchannel structure */
-	   struct ccw1 * cpa,		/* logical channel prog addr */
-	   __u8 lpm)			/* logical path mask */
+cio_start_key (struct subchannel *sch,	/* subchannel structure */
+	       struct ccw1 * cpa,	/* logical channel prog addr */
+	       __u8 lpm,		/* logical path mask */
+	       __u8 key)                /* storage key */
 {
 	char dbf_txt[15];
 	int ccode;
@@ -200,12 +201,12 @@
 	sch->orb.c64 = 1;
 	sch->orb.i2k = 0;
 #endif
+	sch->orb.key = key >> 4;
+	/* issue "Start Subchannel" */
 	sch->orb.cpa = (__u32) __pa (cpa);
-
-	/*
-	 * Issue "Start subchannel" and process condition code
-	 */
 	ccode = ssch (sch->irq, &sch->orb);
+
+	/* process condition code */
 	sprintf (dbf_txt, "ccode:%d", ccode);
 	CIO_TRACE_EVENT (4, dbf_txt);
 
@@ -222,6 +223,12 @@
 	default:		/* device/path not operational */
 		return cio_start_handle_notoper(sch, lpm);
 	}
+}
+
+int
+cio_start (struct subchannel *sch, struct ccw1 *cpa, __u8 lpm)
+{
+	return cio_start_key(sch, cpa, lpm, default_storage_key);
 }
 
 /*
diff -Nru a/drivers/s390/cio/cio.h b/drivers/s390/cio/cio.h
--- a/drivers/s390/cio/cio.h	2004-08-07 11:05:35 -07:00
+++ b/drivers/s390/cio/cio.h	2005-02-03 06:42:43 -08:00
@@ -122,6 +122,7 @@
 extern int cio_resume (struct subchannel *);
 extern int cio_halt (struct subchannel *);
 extern int cio_start (struct subchannel *, struct ccw1 *, __u8);
+extern int cio_start_key (struct subchannel *, struct ccw1 *, __u8, __u8);
 extern int cio_cancel (struct subchannel *);
 extern int cio_set_options (struct subchannel *, int);
 extern int cio_get_options (struct subchannel *);
diff -Nru a/drivers/s390/cio/device_ops.c b/drivers/s390/cio/device_ops.c
--- a/drivers/s390/cio/device_ops.c	2004-08-07 11:05:36 -07:00
+++ b/drivers/s390/cio/device_ops.c	2005-02-03 06:42:43 -08:00
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/device_ops.c
  *
- *   $Revision: 1.50 $
+ *   $Revision: 1.53 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -54,6 +54,7 @@
 	if (cdev->private->state == DEV_STATE_NOT_OPER)
 		return -ENODEV;
 	if (cdev->private->state != DEV_STATE_ONLINE &&
+	    cdev->private->state != DEV_STATE_WAIT4IO &&
 	    cdev->private->state != DEV_STATE_W4SENSE)
 		return -EINVAL;
 	sch = to_subchannel(cdev->dev.parent);
@@ -66,8 +67,9 @@
 }
 
 int
-ccw_device_start(struct ccw_device *cdev, struct ccw1 *cpa,
-		 unsigned long intparm, __u8 lpm, unsigned long flags)
+ccw_device_start_key(struct ccw_device *cdev, struct ccw1 *cpa,
+		     unsigned long intparm, __u8 lpm, __u8 key,
+		     unsigned long flags)
 {
 	struct subchannel *sch;
 	int ret;
@@ -87,29 +89,49 @@
 	ret = cio_set_options (sch, flags);
 	if (ret)
 		return ret;
-	ret = cio_start (sch, cpa, lpm);
+	ret = cio_start_key (sch, cpa, lpm, key);
 	if (ret == 0)
 		cdev->private->intparm = intparm;
 	return ret;
 }
 
+
 int
-ccw_device_start_timeout(struct ccw_device *cdev, struct ccw1 *cpa,
-			 unsigned long intparm, __u8 lpm, unsigned long flags,
-			 int expires)
+ccw_device_start_timeout_key(struct ccw_device *cdev, struct ccw1 *cpa,
+			     unsigned long intparm, __u8 lpm, __u8 key,
+			     unsigned long flags, int expires)
 {
 	int ret;
 
 	if (!cdev)
 		return -ENODEV;
 	ccw_device_set_timeout(cdev, expires);
-	ret = ccw_device_start(cdev, cpa, intparm, lpm, flags);
+	ret = ccw_device_start_key(cdev, cpa, intparm, lpm, key, flags);
 	if (ret != 0)
 		ccw_device_set_timeout(cdev, 0);
 	return ret;
 }
 
 int
+ccw_device_start(struct ccw_device *cdev, struct ccw1 *cpa,
+		 unsigned long intparm, __u8 lpm, unsigned long flags)
+{
+	return ccw_device_start_key(cdev, cpa, intparm, lpm,
+				    default_storage_key, flags);
+}
+
+int
+ccw_device_start_timeout(struct ccw_device *cdev, struct ccw1 *cpa,
+			 unsigned long intparm, __u8 lpm, unsigned long flags,
+			 int expires)
+{
+	return ccw_device_start_timeout_key(cdev, cpa, intparm, lpm,
+					    default_storage_key, flags,
+					    expires);
+}
+
+
+int
 ccw_device_halt(struct ccw_device *cdev, unsigned long intparm)
 {
 	struct subchannel *sch;
@@ -120,6 +142,7 @@
 	if (cdev->private->state == DEV_STATE_NOT_OPER)
 		return -ENODEV;
 	if (cdev->private->state != DEV_STATE_ONLINE &&
+	    cdev->private->state != DEV_STATE_WAIT4IO &&
 	    cdev->private->state != DEV_STATE_W4SENSE)
 		return -EINVAL;
 	sch = to_subchannel(cdev->dev.parent);
@@ -539,6 +562,8 @@
 EXPORT_SYMBOL(ccw_device_resume);
 EXPORT_SYMBOL(ccw_device_start_timeout);
 EXPORT_SYMBOL(ccw_device_start);
+EXPORT_SYMBOL(ccw_device_start_timeout_key);
+EXPORT_SYMBOL(ccw_device_start_key);
 EXPORT_SYMBOL(ccw_device_get_ciw);
 EXPORT_SYMBOL(ccw_device_get_path_mask);
 EXPORT_SYMBOL(read_conf_data);
diff -Nru a/drivers/s390/net/qeth.h b/drivers/s390/net/qeth.h
--- a/drivers/s390/net/qeth.h	2005-01-03 15:49:39 -08:00
+++ b/drivers/s390/net/qeth.h	2005-02-03 06:42:43 -08:00
@@ -24,7 +24,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.129 $"
+#define VERSION_QETH_H 		"$Revision: 1.132 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -754,6 +754,8 @@
 	struct qeth_perf_stats perf_stats;
 #endif /* CONFIG_QETH_PERF_STATS */
 	int use_hard_stop;
+	int (*orig_hard_header)(struct sk_buff *,struct net_device *,
+				unsigned short,void *,void *,unsigned);
 };
 
 struct qeth_card_list_struct {
@@ -828,6 +830,17 @@
 #endif
 	}
 }
+static inline struct sk_buff *
+qeth_pskb_unshare(struct sk_buff *skb, int pri)
+{
+        struct sk_buff *nskb;
+        if (!skb_cloned(skb))
+                return skb;
+        nskb = skb_copy(skb, pri);
+        kfree_skb(skb); /* free our shared copy */
+        return nskb;
+}
+
 
 inline static int
 qeth_get_initial_mtu_for_card(struct qeth_card * card)
@@ -1071,8 +1084,4 @@
 extern int
 qeth_realloc_buffer_pool(struct qeth_card *, int);
 
-extern int
-qeth_fake_header(struct sk_buff *skb, struct net_device *dev,
-                 unsigned short type, void *daddr, void *saddr,
-		 unsigned len);
 #endif /* __QETH_H__ */
diff -Nru a/drivers/s390/net/qeth_main.c b/drivers/s390/net/qeth_main.c
--- a/drivers/s390/net/qeth_main.c	2005-01-17 13:13:31 -08:00
+++ b/drivers/s390/net/qeth_main.c	2005-02-03 06:42:43 -08:00
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.181 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.191 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.181 $	 $Date: 2004/12/27 07:36:40 $
+ *    $Revision: 1.191 $	 $Date: 2005/01/31 13:13:57 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -41,16 +41,9 @@
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/mm.h>
-
-#include <asm/io.h>
-#include <asm/ebcdic.h>
-#include <linux/ctype.h>
-#include <asm/semaphore.h>
-#include <asm/timex.h>
 #include <linux/ip.h>
 #include <linux/inetdevice.h>
 #include <linux/netdevice.h>
@@ -62,23 +55,29 @@
 #include <linux/tcp.h>
 #include <linux/icmp.h>
 #include <linux/skbuff.h>
-#include <net/route.h>
-#include <net/arp.h>
 #include <linux/in.h>
 #include <linux/igmp.h>
-#include <net/ip.h>
-#include <asm/uaccess.h>
 #include <linux/init.h>
 #include <linux/reboot.h>
-#include <asm/qeth.h>
 #include <linux/mii.h>
 #include <linux/rcupdate.h>
 
+#include <net/arp.h>
+#include <net/ip.h>
+#include <net/route.h>
+
+#include <asm/ebcdic.h>
+#include <asm/io.h>
+#include <asm/qeth.h>
+#include <asm/timex.h>
+#include <asm/semaphore.h>
+#include <asm/uaccess.h>
+
 #include "qeth.h"
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.181 $"
+#define VERSION_QETH_C "$Revision: 1.191 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -514,6 +513,7 @@
 qeth_set_offline(struct ccwgroup_device *cgdev)
 {
 	struct qeth_card *card = (struct qeth_card *) cgdev->dev.driver_data;
+	int rc = 0;
 	enum qeth_card_states recover_flag;
 
 	QETH_DBF_TEXT(setup, 3, "setoffl");
@@ -525,15 +525,21 @@
 			   CARD_BUS_ID(card));
 		return -ERESTARTSYS;
 	}
-	ccw_device_set_offline(CARD_DDEV(card));
-	ccw_device_set_offline(CARD_WDEV(card));
-	ccw_device_set_offline(CARD_RDEV(card));
+	if ((rc = ccw_device_set_offline(CARD_DDEV(card))) ||
+	    (rc = ccw_device_set_offline(CARD_WDEV(card))) ||
+	    (rc = ccw_device_set_offline(CARD_RDEV(card)))) {
+		QETH_DBF_TEXT_(setup, 2, "1err%d", rc);
+	}
 	if (recover_flag == CARD_STATE_UP)
 		card->state = CARD_STATE_RECOVER;
 	qeth_notify_processes();
 	return 0;
 }
 
+static int
+qeth_wait_for_threads(struct qeth_card *card, unsigned long threads);
+
+
 static void
 qeth_remove_device(struct ccwgroup_device *cgdev)
 {
@@ -546,6 +552,9 @@
 	if (!card)
 		return;
 
+	if (qeth_wait_for_threads(card, 0xffffffff))
+		return;
+
 	if (cgdev->state == CCWGROUP_ONLINE){
 		card->use_hard_stop = 1;
 		qeth_set_offline(cgdev);
@@ -621,7 +630,7 @@
 	if (todo->users > 0){
 		/* for VIPA and RXIP limit refcount to 1 */
 		if (todo->type != QETH_IP_TYPE_NORMAL)
-			addr->users = 1;
+			todo->users = 1;
 		return 1;
 	} else
 		return 0;
@@ -2262,8 +2271,8 @@
 		skb->ip_summed = CHECKSUM_NONE;
 #ifdef CONFIG_QETH_VLAN
 	if (hdr->hdr.l2.flags[2] & (QETH_LAYER2_FLAG_VLAN)) {
-		skb_pull(skb, VLAN_HLEN);
 		vlan_id = hdr->hdr.l2.vlan_id;
+		skb_pull(skb, VLAN_HLEN);
 	}
 #endif
 	skb->protocol = qeth_type_trans(skb, skb->dev);
@@ -3262,13 +3271,15 @@
 
 	QETH_DBF_TEXT(trace,3,"qdioclr");
 	if (card->qdio.state == QETH_QDIO_ESTABLISHED){
-		qdio_cleanup(CARD_DDEV(card),
+		if ((rc = qdio_cleanup(CARD_DDEV(card),
 			     (card->info.type == QETH_CARD_TYPE_IQD) ?
 			     QDIO_FLAG_CLEANUP_USING_HALT :
-			     QDIO_FLAG_CLEANUP_USING_CLEAR);
+			     QDIO_FLAG_CLEANUP_USING_CLEAR)))
+			QETH_DBF_TEXT_(trace, 3, "1err%d", rc);
 		card->qdio.state = QETH_QDIO_ALLOCATED;
 	}
-	rc = qeth_clear_halt_card(card, use_halt);
+	if ((rc = qeth_clear_halt_card(card, use_halt)))
+		QETH_DBF_TEXT_(trace, 3, "2err%d", rc);
 	card->state = CARD_STATE_DOWN;
 	return rc;
 }
@@ -3370,6 +3381,26 @@
 	return dev;
 }
 
+/*hard_header fake function; used in case fake_ll is set */
+static int
+qeth_fake_header(struct sk_buff *skb, struct net_device *dev,
+		     unsigned short type, void *daddr, void *saddr,
+		     unsigned len)
+{
+	struct ethhdr *hdr;
+	struct qeth_card *card;
+
+	card = (struct qeth_card *)dev->priv;
+        hdr = (struct ethhdr *)skb_push(skb, QETH_FAKE_LL_LEN);
+	memcpy(hdr->h_source, card->dev->dev_addr, ETH_ALEN);
+        memcpy(hdr->h_dest, "FAKELL", ETH_ALEN);
+        if (type != ETH_P_802_3)
+                hdr->h_proto = htons(type);
+        else
+                hdr->h_proto = htons(len);
+	return QETH_FAKE_LL_LEN;
+}
+
 static inline int
 qeth_send_packet(struct qeth_card *, struct sk_buff *);
 
@@ -3399,6 +3430,14 @@
 	card->perf_stats.outbound_cnt++;
 	card->perf_stats.outbound_start_time = qeth_get_micros();
 #endif
+	if (dev->hard_header == qeth_fake_header) {
+               if ((skb = qeth_pskb_unshare(skb, GFP_ATOMIC)) == NULL) {
+                        card->stats.tx_dropped++;
+                        dev_kfree_skb_irq(skb);
+                        return 0;
+                }
+                skb_pull(skb, QETH_FAKE_LL_LEN);
+	}
 	/*
 	 * We only call netif_stop_queue in case of errors. Since we've
 	 * got our own synchronization on queues we can keep the stack's
@@ -5219,7 +5258,10 @@
 
 static int
 qeth_layer2_send_setdelmac(struct qeth_card *card, __u8 *mac,
-			   enum qeth_ipa_cmds ipacmd)
+			   enum qeth_ipa_cmds ipacmd,
+			   int (*reply_cb) (struct qeth_card *,
+					    struct qeth_reply*,
+					    unsigned long))
 {
 	struct qeth_ipa_cmd *cmd;
 	struct qeth_cmd_buffer *iob;
@@ -5229,9 +5271,139 @@
 	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
         cmd->data.setdelmac.mac_length = OSA_ADDR_LEN;
         memcpy(&cmd->data.setdelmac.mac, mac, OSA_ADDR_LEN);
-	return qeth_send_ipa_cmd(card, iob, NULL, NULL);
+	return qeth_send_ipa_cmd(card, iob, reply_cb, NULL);
+}
+
+static int
+qeth_layer2_send_setgroupmac_cb(struct qeth_card *card,
+				struct qeth_reply *reply,
+				unsigned long data)
+{
+	struct qeth_ipa_cmd *cmd;
+	__u8 *mac;
+
+	QETH_DBF_TEXT(trace, 2, "L2Sgmacb");
+	cmd = (struct qeth_ipa_cmd *) data;
+	mac = &cmd->data.setdelmac.mac[0];
+	/* MAC already registered, needed in couple/uncouple case */
+	if (cmd->hdr.return_code == 0x2005) {
+		PRINT_WARN("Group MAC %02x:%02x:%02x:%02x:%02x:%02x " \
+			  "already existing on %s \n",
+			  mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],
+			  QETH_CARD_IFNAME(card));
+		cmd->hdr.return_code = 0;
+	}
+	if (cmd->hdr.return_code)
+		PRINT_ERR("Could not set group MAC " \
+			  "%02x:%02x:%02x:%02x:%02x:%02x on %s: %x\n",
+			  mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],
+			  QETH_CARD_IFNAME(card),cmd->hdr.return_code);
+	return 0;
+}
+
+static int
+qeth_layer2_send_setgroupmac(struct qeth_card *card, __u8 *mac)
+{
+	QETH_DBF_TEXT(trace, 2, "L2Sgmac");
+	return qeth_layer2_send_setdelmac(card, mac, IPA_CMD_SETGMAC,
+					  qeth_layer2_send_setgroupmac_cb);
+}
+
+static int
+qeth_layer2_send_delgroupmac_cb(struct qeth_card *card,
+				struct qeth_reply *reply,
+				unsigned long data)
+{
+	struct qeth_ipa_cmd *cmd;
+	__u8 *mac;
+
+	QETH_DBF_TEXT(trace, 2, "L2Dgmacb");
+	cmd = (struct qeth_ipa_cmd *) data;
+	mac = &cmd->data.setdelmac.mac[0];
+	if (cmd->hdr.return_code)
+		PRINT_ERR("Could not delete group MAC " \
+			  "%02x:%02x:%02x:%02x:%02x:%02x on %s: %x\n",
+			  mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],
+			  QETH_CARD_IFNAME(card), cmd->hdr.return_code);
+	return 0;
+}
+
+static int
+qeth_layer2_send_delgroupmac(struct qeth_card *card, __u8 *mac)
+{
+	QETH_DBF_TEXT(trace, 2, "L2Dgmac");
+	return qeth_layer2_send_setdelmac(card, mac, IPA_CMD_DELGMAC,
+					  qeth_layer2_send_delgroupmac_cb);
+}
+
+static int
+qeth_layer2_send_setmac_cb(struct qeth_card *card,
+			   struct qeth_reply *reply,
+			   unsigned long data)
+{
+	struct qeth_ipa_cmd *cmd;
+
+	QETH_DBF_TEXT(trace, 2, "L2Smaccb");
+	cmd = (struct qeth_ipa_cmd *) data;
+	if (cmd->hdr.return_code) {
+		QETH_DBF_TEXT_(trace, 2, "L2er%x", cmd->hdr.return_code);
+		PRINT_WARN("Error in registering MAC address on " \
+			   "device %s: x%x\n", CARD_BUS_ID(card),
+			   cmd->hdr.return_code);
+		card->info.layer2_mac_registered = 0;
+		cmd->hdr.return_code = -EIO;
+	} else {
+		card->info.layer2_mac_registered = 1;
+		memcpy(card->dev->dev_addr,cmd->data.setdelmac.mac,
+		       OSA_ADDR_LEN);
+		PRINT_INFO("MAC address %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x "
+			   "successfully registered on device %s\n",
+			   card->dev->dev_addr[0], card->dev->dev_addr[1],
+			   card->dev->dev_addr[2], card->dev->dev_addr[3],
+			   card->dev->dev_addr[4], card->dev->dev_addr[5],
+			   card->dev->name);
+	}
+	return 0;
+}
+
+static int
+qeth_layer2_send_setmac(struct qeth_card *card, __u8 *mac)
+{
+	QETH_DBF_TEXT(trace, 2, "L2Setmac");
+	return qeth_layer2_send_setdelmac(card, mac, IPA_CMD_SETVMAC,
+					  qeth_layer2_send_setmac_cb);
 }
 
+static int
+qeth_layer2_send_delmac_cb(struct qeth_card *card,
+			   struct qeth_reply *reply,
+			   unsigned long data)
+{
+	struct qeth_ipa_cmd *cmd;
+
+	QETH_DBF_TEXT(trace, 2, "L2Dmaccb");
+	cmd = (struct qeth_ipa_cmd *) data;
+	if (cmd->hdr.return_code) {
+		PRINT_WARN("Error in deregistering MAC address on " \
+			   "device %s: x%x\n", CARD_BUS_ID(card),
+			   cmd->hdr.return_code);
+		QETH_DBF_TEXT_(trace, 2, "err%d", cmd->hdr.return_code);
+		cmd->hdr.return_code = -EIO;
+		return 0;
+	}
+	card->info.layer2_mac_registered = 0;
+
+	return 0;
+}
+static int
+qeth_layer2_send_delmac(struct qeth_card *card, __u8 *mac)
+{
+	QETH_DBF_TEXT(trace, 2, "L2Delmac");
+	if (!card->info.layer2_mac_registered)
+		return 0;
+	return qeth_layer2_send_setdelmac(card, mac, IPA_CMD_DELVMAC,
+					  qeth_layer2_send_delmac_cb);
+}
 
 static int
 qeth_layer2_set_mac_address(struct net_device *dev, void *p)
@@ -5256,32 +5428,9 @@
 	}
 	QETH_DBF_TEXT_(trace, 3, "%s", CARD_BUS_ID(card));
 	QETH_DBF_HEX(trace, 3, addr->sa_data, OSA_ADDR_LEN);
-	if (card->info.layer2_mac_registered)
-		rc = qeth_layer2_send_setdelmac(card, &card->dev->dev_addr[0],
-						IPA_CMD_DELVMAC);
-	if (rc) {
-		PRINT_WARN("Error in deregistering MAC address on " \
-			   "device %s: x%x\n", CARD_BUS_ID(card), rc);
-		QETH_DBF_TEXT_(trace, 2, "err%d", rc);
-		return -EIO;
-	}
-	card->info.layer2_mac_registered = 0;
-
-	rc = qeth_layer2_send_setdelmac(card, addr->sa_data, IPA_CMD_SETVMAC);
-	if (rc) {
-		PRINT_WARN("Error in registering MAC address on " \
-			   "device %s: x%x\n", CARD_BUS_ID(card), rc);
-		QETH_DBF_TEXT_(trace, 2, "2err%d", rc);
-		return -EIO;
-	}
-	card->info.layer2_mac_registered = 1;
-	memcpy(dev->dev_addr, addr->sa_data, OSA_ADDR_LEN);
-	PRINT_INFO("MAC address %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x "
-		   "successfully registered on device %s\n",
-		   dev->dev_addr[0],dev->dev_addr[1],dev->dev_addr[2],
-		   dev->dev_addr[3],dev->dev_addr[4],dev->dev_addr[5],
-		   dev->name);
-
+	rc = qeth_layer2_send_delmac(card, &card->dev->dev_addr[0]);
+	if (!rc)
+		rc = qeth_layer2_send_setmac(card, addr->sa_data);
 	return rc;
 }
 
@@ -5392,45 +5541,22 @@
 qeth_layer2_register_addr_entry(struct qeth_card *card,
 				struct qeth_ipaddr *addr)
 {
-	int rc = 0;
-
 	if (!addr->is_multicast)
 		return 0;
-
 	QETH_DBF_TEXT(trace, 2, "setgmac");
 	QETH_DBF_HEX(trace,3,&addr->mac[0],OSA_ADDR_LEN);
-	rc = qeth_layer2_send_setdelmac(card, &addr->mac[0],
-					IPA_CMD_SETGMAC);
-	if (rc)
-		PRINT_ERR("Could not set group MAC " \
-			  "%02x:%02x:%02x:%02x:%02x:%02x on %s: %x\n",
-			  addr->mac[0],addr->mac[1],addr->mac[2],
-			  addr->mac[3],addr->mac[4],addr->mac[5],
-			  QETH_CARD_IFNAME(card),rc);
-	return rc;
+	return qeth_layer2_send_setgroupmac(card, &addr->mac[0]);
 }
 
 static int
 qeth_layer2_deregister_addr_entry(struct qeth_card *card,
 				  struct qeth_ipaddr *addr)
 {
-	int rc = 0;
-
 	if (!addr->is_multicast)
 		return 0;
-
 	QETH_DBF_TEXT(trace, 2, "delgmac");
 	QETH_DBF_HEX(trace,3,&addr->mac[0],OSA_ADDR_LEN);
-	rc = qeth_layer2_send_setdelmac(card, &addr->mac[0],
-					IPA_CMD_DELGMAC);
-	if (rc)
-		PRINT_ERR("Could not delete group MAC " \
-			  "%02x:%02x:%02x:%02x:%02x:%02x on %s: %x\n",
-			  addr->mac[0],addr->mac[1],addr->mac[2],
-			  addr->mac[3],addr->mac[4],addr->mac[5],
-			  QETH_CARD_IFNAME(card),rc);
-	return rc;
-
+	return qeth_layer2_send_delgroupmac(card, &addr->mac[0]);
 }
 
 static int
@@ -5526,14 +5652,6 @@
 	return qeth_layer3_deregister_addr_entry(card, addr);
 }
 
-int
-qeth_fake_header(struct sk_buff *skb, struct net_device *dev,
-		     unsigned short type, void *daddr, void *saddr,
-		     unsigned len)
-{
-	return QETH_FAKE_LL_LEN;
-}
-
 static int
 qeth_netdev_init(struct net_device *dev)
 {
@@ -5558,9 +5676,12 @@
 	dev->vlan_rx_kill_vid = qeth_vlan_rx_kill_vid;
 	dev->vlan_rx_add_vid = qeth_vlan_rx_add_vid;
 #endif
+	dev->hard_header = card->orig_hard_header;
 	if (qeth_get_netdev_flags(card) & IFF_NOARP) {
 		dev->rebuild_header = NULL;
 		dev->hard_header = NULL;
+		if (card->options.fake_ll)
+			dev->hard_header = qeth_fake_header;
 		dev->header_cache_update = NULL;
 		dev->hard_header_cache = NULL;
 	}
@@ -5572,10 +5693,6 @@
 	dev->hard_header_parse = NULL;
 	dev->set_mac_address = qeth_layer2_set_mac_address;
 	dev->flags |= qeth_get_netdev_flags(card);
-	if (card->options.fake_ll)
-		dev->hard_header = qeth_fake_header;
-	else
-		dev->hard_header = NULL;
 	if ((card->options.fake_broadcast) ||
 	    (card->info.broadcast_capable))
 		dev->flags |= IFF_BROADCAST;
@@ -5672,22 +5789,26 @@
 		QETH_DBF_TEXT_(setup, 2, "5err%d", rc);
 		goto out;
 	}
+	/*network device will be recovered*/
+	if (card->dev) {
+		card->dev->hard_header = card->orig_hard_header;
+		return 0;
+	}
 	/* at first set_online allocate netdev */
+	card->dev = qeth_get_netdevice(card->info.type,
+				       card->info.link_type);
 	if (!card->dev){
-		card->dev = qeth_get_netdevice(card->info.type,
-					       card->info.link_type);
-		if (!card->dev){
-			qeth_qdio_clear_card(card, card->info.type ==
-					     QETH_CARD_TYPE_OSAE);
-			rc = -ENODEV;
-			QETH_DBF_TEXT_(setup, 2, "6err%d", rc);
-			goto out;
-		}
-		card->dev->priv = card;
-		card->dev->type = qeth_get_arphdr_type(card->info.type,
-						       card->info.link_type);
-		card->dev->init = qeth_netdev_init;
+		qeth_qdio_clear_card(card, card->info.type ==
+				     QETH_CARD_TYPE_OSAE);
+		rc = -ENODEV;
+		QETH_DBF_TEXT_(setup, 2, "6err%d", rc);
+		goto out;
 	}
+	card->dev->priv = card;
+	card->orig_hard_header = card->dev->hard_header;
+	card->dev->type = qeth_get_arphdr_type(card->info.type,
+					       card->info.link_type);
+	card->dev->init = qeth_netdev_init;
 	return 0;
 out:
 	PRINT_ERR("Initialization in hardsetup failed! rc=%d\n", rc);
@@ -5906,15 +6027,9 @@
         }
 	QETH_DBF_HEX(setup,2, card->dev->dev_addr, OSA_ADDR_LEN);
 
-	rc = qeth_layer2_send_setdelmac(card, &card->dev->dev_addr[0],
-					IPA_CMD_SETVMAC);
-        if (rc) {
-		card->info.layer2_mac_registered = 0;
-                PRINT_WARN("Error in processing MAC address on " \
-                           "device %s: x%x\n",CARD_BUS_ID(card),rc);
+	rc = qeth_layer2_send_setmac(card, &card->dev->dev_addr[0]);
+        if (rc)
 		QETH_DBF_TEXT_(setup, 2,"2err%d",rc);
-        } else
-		card->info.layer2_mac_registered = 1;
         return 0;
 }
 
@@ -6712,9 +6827,8 @@
 		rtnl_unlock();
 		if (!card->use_hard_stop) {
 			__u8 *mac = &card->dev->dev_addr[0];
-			if ((rc = qeth_layer2_send_setdelmac(card, mac,
-							    IPA_CMD_DELVMAC)));
-				QETH_DBF_TEXT_(setup, 2, "Lerr%d", rc);
+			rc = qeth_layer2_send_delmac(card, mac);
+			QETH_DBF_TEXT_(setup, 2, "Lerr%d", rc);
 			if ((rc = qeth_send_stoplan(card)))
 				QETH_DBF_TEXT_(setup, 2, "1err%d", rc);
 		}
@@ -6872,8 +6986,10 @@
 qeth_register_netdev(struct qeth_card *card)
 {
 	QETH_DBF_TEXT(setup, 3, "regnetd");
-	if (card->dev->reg_state != NETREG_UNINITIALIZED)
+	if (card->dev->reg_state != NETREG_UNINITIALIZED) {
+		qeth_netdev_init(card->dev);
 		return 0;
+	}
 	/* sysfs magic */
 	SET_NETDEV_DEV(card->dev, &card->gdev->dev);
 	return register_netdev(card->dev);
@@ -6961,9 +7077,9 @@
 	}
 
 	recover_flag = card->state;
-	if (ccw_device_set_online(CARD_RDEV(card)) ||
-	    ccw_device_set_online(CARD_WDEV(card)) ||
-	    ccw_device_set_online(CARD_DDEV(card))){
+	if ((rc = ccw_device_set_online(CARD_RDEV(card))) ||
+	    (rc = ccw_device_set_online(CARD_WDEV(card))) ||
+	    (rc = ccw_device_set_online(CARD_DDEV(card)))){
 		QETH_DBF_TEXT_(setup, 2, "1err%d", rc);
 		return -EIO;
 	}
@@ -7157,7 +7273,8 @@
 	card = qeth_get_card_from_dev(dev);
 	if (card == NULL)
 		goto out;
-	if(card->options.layer2)
+	if((card->options.layer2) ||
+	   (card->dev->hard_header == qeth_fake_header))
 		goto out;
 
 	rcu_read_lock();
diff -Nru a/drivers/s390/net/qeth_sys.c b/drivers/s390/net/qeth_sys.c
--- a/drivers/s390/net/qeth_sys.c	2005-01-03 15:49:39 -08:00
+++ b/drivers/s390/net/qeth_sys.c	2005-02-03 06:42:43 -08:00
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.48 $)
+ * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.49 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to sysfs.
@@ -20,7 +20,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-const char *VERSION_QETH_SYS_C = "$Revision: 1.48 $";
+const char *VERSION_QETH_SYS_C = "$Revision: 1.49 $";
 
 /*****************************************************************************/
 /*                                                                           */
@@ -514,19 +514,11 @@
 		return -EPERM;
 
 	i = simple_strtoul(buf, &tmp, 16);
-	if ((i == 0) || (i == 1)) {
-		card->options.fake_ll = i;
-		if (card->dev) {
-			if (i)
-  				card->dev->hard_header = qeth_fake_header;
-			else
-				card->dev->hard_header = NULL;
-		}
-	}
-	else {
+	if ((i != 0) && (i != 1)) {
 		PRINT_WARN("fake_ll: write 0 or 1 to this file!\n");
 		return -EINVAL;
 	}
+	card->options.fake_ll = i;
 	return count;
 }
 
diff -Nru a/drivers/scsi/ide-scsi.c b/drivers/scsi/ide-scsi.c
--- a/drivers/scsi/ide-scsi.c	2005-01-03 14:56:40 -08:00
+++ b/drivers/scsi/ide-scsi.c	2005-02-02 15:21:22 -08:00
@@ -152,7 +152,7 @@
 		}
 		count = min(pc->sg->length - pc->b_count, bcount);
 		buf = page_address(pc->sg->page) + pc->sg->offset;
-		atapi_input_bytes (drive, buf + pc->b_count, count);
+		drive->hwif->atapi_input_bytes(drive, buf + pc->b_count, count);
 		bcount -= count; pc->b_count += count;
 		if (pc->b_count == pc->sg->length) {
 			pc->sg++;
@@ -174,7 +174,7 @@
 		}
 		count = min(pc->sg->length - pc->b_count, bcount);
 		buf = page_address(pc->sg->page) + pc->sg->offset;
-		atapi_output_bytes (drive, buf + pc->b_count, count);
+		drive->hwif->atapi_output_bytes(drive, buf + pc->b_count, count);
 		bcount -= count; pc->b_count += count;
 		if (pc->b_count == pc->sg->length) {
 			pc->sg++;
@@ -481,7 +481,7 @@
 					if (pc->sg)
 						idescsi_input_buffers(drive, pc, temp);
 					else
-						atapi_input_bytes(drive, pc->current_position, temp);
+						drive->hwif->atapi_input_bytes(drive, pc->current_position, temp);
 					printk(KERN_ERR "ide-scsi: transferred %d of %d bytes\n", temp, bcount.all);
 				}
 				pc->actually_transferred += temp;
@@ -541,7 +541,7 @@
 	/* Set the interrupt routine */
 	ide_set_handler(drive, &idescsi_pc_intr, get_timeout(pc), idescsi_expiry);
 	/* Send the actual packet */
-	atapi_output_bytes(drive, scsi->pc->c, 12);
+	drive->hwif->atapi_output_bytes(drive, scsi->pc->c, 12);
 	if (test_bit (PC_DMA_OK, &pc->flags)) {
 		set_bit (PC_DMA_IN_PROGRESS, &pc->flags);
 		hwif->dma_start(drive);
diff -Nru a/drivers/scsi/wd33c93.h b/drivers/scsi/wd33c93.h
--- a/drivers/scsi/wd33c93.h	2004-06-20 09:01:32 -07:00
+++ b/drivers/scsi/wd33c93.h	2005-02-03 06:42:40 -08:00
@@ -22,6 +22,8 @@
 #ifndef WD33C93_H
 #define WD33C93_H
 
+#include <linux/config.h>
+
 #define PROC_INTERFACE     /* add code for /proc/scsi/wd33c93/xxx interface */
 #ifdef  PROC_INTERFACE
 #define PROC_STATISTICS    /* add code for keeping various real time stats */
diff -Nru a/drivers/serial/Makefile b/drivers/serial/Makefile
--- a/drivers/serial/Makefile	2005-01-15 14:31:04 -08:00
+++ b/drivers/serial/Makefile	2005-02-03 06:42:40 -08:00
@@ -48,3 +48,4 @@
 obj-$(CONFIG_SERIAL_M32R_SIO) += m32r_sio.o
 obj-$(CONFIG_SERIAL_MPSC) += mpsc.o
 obj-$(CONFIG_ETRAX_SERIAL) += crisv10.o
+obj-$(CONFIG_SERIAL_TXX9) += serial_txx9.o
diff -Nru a/drivers/serial/ip22zilog.c b/drivers/serial/ip22zilog.c
--- a/drivers/serial/ip22zilog.c	2004-02-18 19:42:44 -08:00
+++ b/drivers/serial/ip22zilog.c	2005-02-03 06:42:40 -08:00
@@ -47,8 +47,6 @@
 
 #include "ip22zilog.h"
 
-int ip22serial_current_minor = 64;
-
 void ip22_do_break(void);
 
 /*
@@ -59,10 +57,10 @@
 #define ZSDELAY_LONG()		udelay(20)
 #define ZS_WSYNC(channel)	do { } while (0)
 
-#define NUM_IP22ZILOG	1
-#define NUM_CHANNELS	(NUM_IP22ZILOG * 2)
+#define NUM_IP22ZILOG		1
+#define NUM_CHANNELS		(NUM_IP22ZILOG * 2)
 
-#define ZS_CLOCK		4915200 /* Zilog input clock rate. */
+#define ZS_CLOCK		3672000	/* Zilog input clock rate. */
 #define ZS_CLOCK_DIVISOR	16      /* Divisor this driver uses. */
 
 /*
@@ -86,7 +84,7 @@
 #define IP22ZILOG_FLAG_TX_STOPPED	0x00000080
 #define IP22ZILOG_FLAG_TX_ACTIVE	0x00000100
 
-	unsigned int cflag;
+	unsigned int			cflag;
 
 	/* L1-A keyboard break state.  */
 	int				kbd_id;
@@ -642,36 +640,28 @@
 	}
 }
 
-/* The port lock is not held.  */
+/* The port lock is held and interrupts are disabled.  */
 static void ip22zilog_stop_rx(struct uart_port *port)
 {
 	struct uart_ip22zilog_port *up = UART_ZILOG(port);
 	struct zilog_channel *channel;
-	unsigned long flags;
 
 	if (ZS_IS_CONS(up))
 		return;
 
-	spin_lock_irqsave(&port->lock, flags);
-
 	channel = ZILOG_CHANNEL_FROM_PORT(port);
 
 	/* Disable all RX interrupts.  */
 	up->curregs[R1] &= ~RxINT_MASK;
 	ip22zilog_maybe_update_regs(up, channel);
-
-	spin_unlock_irqrestore(&port->lock, flags);
 }
 
-/* The port lock is not held.  */
+/* The port lock is held.  */
 static void ip22zilog_enable_ms(struct uart_port *port)
 {
 	struct uart_ip22zilog_port *up = (struct uart_ip22zilog_port *) port;
 	struct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);
 	unsigned char new_reg;
-	unsigned long flags;
-
-	spin_lock_irqsave(&port->lock, flags);
 
 	new_reg = up->curregs[R15] | (DCDIE | SYNCIE | CTSIE);
 	if (new_reg != up->curregs[R15]) {
@@ -680,8 +670,6 @@
 		/* NOTE: Not subject to 'transmitter active' rule.  */ 
 		write_zsreg(channel, R15, up->curregs[R15]);
 	}
-
-	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 /* The port lock is not held.  */
@@ -807,7 +795,7 @@
 	up->curregs[R4] |= X16CLK;
 	up->curregs[R12] = brg & 0xff;
 	up->curregs[R13] = (brg >> 8) & 0xff;
-	up->curregs[R14] = BRSRC | BRENAB;
+	up->curregs[R14] = BRENAB;
 
 	/* Character size, stop bits, and parity. */
 	up->curregs[3] &= ~RxN_MASK;
@@ -950,13 +938,6 @@
 static struct uart_ip22zilog_port *ip22zilog_irq_chain;
 static int zilog_irq = -1;
 
-static struct uart_driver ip22zilog_reg = {
-	.owner		=	THIS_MODULE,
-	.driver_name	=	"ttyS",
-	.devfs_name	=	"tty/",
-	.major		=	TTY_MAJOR,
-};
-
 static void * __init alloc_one_table(unsigned long size)
 {
 	void *ret;
@@ -990,7 +971,7 @@
 	}
 
 	/* Not probe-able, hard code it. */
-	base = (unsigned long) &sgioc->serport;
+	base = (unsigned long) &sgioc->uart;
 
 	zilog_irq = SGI_SERIAL_IRQ;
 	request_mem_region(base, 8, "IP22-Zilog");
@@ -1047,9 +1028,6 @@
 	int parity = 'n';
 	int flow = 'n';
 
-	if (!serial_console)
-		return;
-
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
 
@@ -1077,8 +1055,7 @@
 	unsigned long flags;
 	int baud, brg;
 
-	printk("Console: ttyS%d (IP22-Zilog)\n",
-	       (ip22zilog_reg.minor - 64) + con->index);
+	printk("Console: ttyS%d (IP22-Zilog)\n", con->index);
 
 	/* Get firmware console settings.  */
 	ip22serial_console_termios(con, options);
@@ -1112,6 +1089,8 @@
 	return 0;
 }
 
+static struct uart_driver ip22zilog_reg;
+
 static struct console ip22zilog_console = {
 	.name	=	"ttyS",
 	.write	=	ip22zilog_console_write,
@@ -1121,32 +1100,20 @@
 	.index	=	-1,
 	.data	=	&ip22zilog_reg,
 };
-#define IP22ZILOG_CONSOLE	(&ip22zilog_console)
-
-static int __init ip22zilog_console_init(void)
-{
-	int i;
-
-	if (con_is_present())
-		return 0;
-
-	for (i = 0; i < NUM_CHANNELS; i++) {
-		int this_minor = ip22zilog_reg.minor + i;
+#endif /* CONFIG_SERIAL_IP22_ZILOG_CONSOLE */
 
-		if ((this_minor - 64) == (serial_console - 1))
-			break;
-	}
-	if (i == NUM_CHANNELS)
-		return 0;
-
-	ip22zilog_console.index = i;
-	register_console(&ip22zilog_console);
-	return 0;
-}
-#else /* CONFIG_SERIAL_IP22_ZILOG_CONSOLE */
-#define IP22ZILOG_CONSOLE		(NULL)
-#define ip22zilog_console_init()	do { } while (0)
+static struct uart_driver ip22zilog_reg = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "serial",
+	.devfs_name	= "tts/",
+	.dev_name	= "ttyS",
+	.major		= TTY_MAJOR,
+	.minor		= 64,
+	.nr		= NUM_CHANNELS,
+#ifdef CONFIG_SERIAL_IP22_ZILOG_CONSOLE
+	.cons		= &ip22zilog_console,
 #endif
+};
 
 static void __init ip22zilog_prepare(void)
 {
@@ -1160,17 +1127,24 @@
 	for (channel = 0; channel < NUM_CHANNELS; channel++)
 		spin_lock_init(&ip22zilog_port_table[channel].port.lock);
 
-	ip22zilog_irq_chain = up = &ip22zilog_port_table[0];
-	for (channel = 0; channel < NUM_CHANNELS - 1; channel++)
-		up[channel].next = &up[channel + 1];
+	ip22zilog_irq_chain = &ip22zilog_port_table[NUM_CHANNELS - 1];
+        up = &ip22zilog_port_table[0];
+	for (channel = NUM_CHANNELS - 1 ; channel > 0; channel--)
+		up[channel].next = &up[channel - 1];
 	up[channel].next = NULL;
 
 	for (chip = 0; chip < NUM_IP22ZILOG; chip++) {
 		if (!ip22zilog_chip_regs[chip]) {
 			ip22zilog_chip_regs[chip] = rp = get_zs(chip);
 
-			up[(chip * 2) + 0].port.membase = (char *) &rp->channelA;
-			up[(chip * 2) + 1].port.membase = (char *) &rp->channelB;
+			up[(chip * 2) + 0].port.membase = (char *) &rp->channelB;
+			up[(chip * 2) + 1].port.membase = (char *) &rp->channelA;
+
+			/* In theory mapbase is the physical address ...  */
+			up[(chip * 2) + 0].port.mapbase =
+				(unsigned long) ioremap((unsigned long) &rp->channelB, 8);
+			up[(chip * 2) + 1].port.mapbase =
+				(unsigned long) ioremap((unsigned long) &rp->channelA, 8);
 		}
 
 		/* Channel A */
@@ -1182,7 +1156,7 @@
 		up[(chip * 2) + 0].port.type = PORT_IP22ZILOG;
 		up[(chip * 2) + 0].port.flags = 0;
 		up[(chip * 2) + 0].port.line = (chip * 2) + 0;
-		up[(chip * 2) + 0].flags |= IP22ZILOG_FLAG_IS_CHANNEL_A;
+		up[(chip * 2) + 0].flags = 0;
 
 		/* Channel B */
 		up[(chip * 2) + 1].port.iotype = UPIO_MEM;
@@ -1191,9 +1165,9 @@
 		up[(chip * 2) + 1].port.fifosize = 1;
 		up[(chip * 2) + 1].port.ops = &ip22zilog_pops;
 		up[(chip * 2) + 1].port.type = PORT_IP22ZILOG;
-		up[(chip * 2) + 1].port.flags = 0;
+		up[(chip * 2) + 1].port.flags |= IP22ZILOG_FLAG_IS_CHANNEL_A;
 		up[(chip * 2) + 1].port.line = (chip * 2) + 1;
-		up[(chip * 2) + 1].flags |= 0;
+		up[(chip * 2) + 1].flags = 0;
 	}
 }
 
@@ -1228,8 +1202,10 @@
 		brg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);
 		up->curregs[R12] = (brg & 0xff);
 		up->curregs[R13] = (brg >> 8) & 0xff;
-		up->curregs[R14] = BRSRC | BRENAB;
+		up->curregs[R14] = BRENAB;
 		__load_zsregs(channel, up->curregs);
+	        /* set master interrupt enable */
+	        write_zsreg(channel, R9, up->curregs[R9]);
 
 		spin_unlock_irqrestore(&up->port.lock, flags);
 	}
@@ -1250,15 +1226,6 @@
 
 	ip22zilog_init_hw();
 
-	/* We can only init this once we have probed the Zilogs
-	 * in the system.
-	 */
-	ip22zilog_reg.nr = NUM_CHANNELS;
-	ip22zilog_reg.cons = IP22ZILOG_CONSOLE;
-
-	ip22zilog_reg.minor = ip22serial_current_minor;
-	ip22serial_current_minor += NUM_CHANNELS;
-
 	ret = uart_register_driver(&ip22zilog_reg);
 	if (ret == 0) {
 		int i;
@@ -1276,11 +1243,8 @@
 static int __init ip22zilog_init(void)
 {
 	/* IP22 Zilog setup is hard coded, no probing to do.  */
-
 	ip22zilog_alloc_tables();
-
 	ip22zilog_ports_init();
-	ip22zilog_console_init();
 
 	return 0;
 }
diff -Nru a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
--- a/drivers/usb/class/cdc-acm.c	2005-01-14 16:02:24 -08:00
+++ b/drivers/usb/class/cdc-acm.c	2005-02-02 22:19:36 -08:00
@@ -261,16 +261,22 @@
 
 static int acm_tty_open(struct tty_struct *tty, struct file *filp)
 {
-	struct acm *acm = acm_table[tty->index];
+	struct acm *acm;
+	int rv = -EINVAL;
 	dbg("Entering acm_tty_open.\n");
+	
+	down(&open_sem);
 
+	acm = acm_table[tty->index];
 	if (!acm || !acm->dev)
-		return -EINVAL;
+		goto err_out;
+	else
+		rv = 0;
 
 	tty->driver_data = acm;
 	acm->tty = tty;
 
-        down(&open_sem);
+
 
 	if (acm->used) {
 		goto done;
@@ -279,7 +285,8 @@
 	acm->ctrlurb->dev = acm->dev;
 	if (usb_submit_urb(acm->ctrlurb, GFP_KERNEL)) {
 		dbg("usb_submit_urb(ctrl irq) failed");
-		goto bail_out;
+		rv = -EIO;
+		goto err_out;
 	}
 
 	acm->readurb->dev = acm->dev;
@@ -297,14 +304,14 @@
 
 done:
 	acm->used++;
+err_out:
 	up(&open_sem);
-	return 0;
+	return rv;
 
 full_bailout:
 	usb_kill_urb(acm->readurb);
 bail_out_and_unlink:
 	usb_kill_urb(acm->ctrlurb);
-bail_out:
 	up(&open_sem);
 	return -EIO;
 }
diff -Nru a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
--- a/drivers/usb/core/devio.c	2005-01-14 16:01:56 -08:00
+++ b/drivers/usb/core/devio.c	2005-02-02 22:20:50 -08:00
@@ -123,13 +123,26 @@
 	}
 
 	if (pos < sizeof(struct usb_device_descriptor)) {
+		struct usb_device_descriptor *desc = kmalloc(sizeof(*desc), GFP_KERNEL);
+		if (!desc) {
+			ret = -ENOMEM;
+			goto err;
+		}
+		memcpy(desc, &dev->descriptor, sizeof(dev->descriptor));
+		le16_to_cpus(&desc->bcdUSB);
+		le16_to_cpus(&desc->idVendor);
+		le16_to_cpus(&desc->idProduct);
+		le16_to_cpus(&desc->bcdDevice);
+
 		len = sizeof(struct usb_device_descriptor) - pos;
 		if (len > nbytes)
 			len = nbytes;
-		if (copy_to_user(buf, ((char *)&dev->descriptor) + pos, len)) {
+		if (copy_to_user(buf, ((char *)desc) + pos, len)) {
+			kfree(desc);
 			ret = -EFAULT;
 			goto err;
 		}
+		kfree(desc);
 
 		*ppos += len;
 		buf += len;
diff -Nru a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
--- a/drivers/usb/core/hcd.c	2005-01-25 13:50:18 -08:00
+++ b/drivers/usb/core/hcd.c	2005-02-02 22:20:55 -08:00
@@ -676,6 +676,7 @@
 	INIT_LIST_HEAD (&bus->bus_list);
 
 	class_device_initialize(&bus->class_dev);
+	bus->class_dev.class = &usb_host_class;
 }
 EXPORT_SYMBOL (usb_bus_init);
 
@@ -732,7 +733,6 @@
 	}
 
 	snprintf(bus->class_dev.class_id, BUS_ID_SIZE, "usb%d", busnum);
-	bus->class_dev.class = &usb_host_class;
 	bus->class_dev.dev = bus->controller;
 	retval = class_device_add(&bus->class_dev);
 	if (retval) {
diff -Nru a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
--- a/drivers/usb/input/hid-core.c	2005-01-22 02:19:23 -08:00
+++ b/drivers/usb/input/hid-core.c	2005-02-02 22:18:48 -08:00
@@ -1295,12 +1295,15 @@
 		unsigned char type, void *buf, int size)
 {
 	int result, retries = 4;
+
+	memset(buf,0,size);	// Make sure we parse really received data
+
 	do {
 		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 				USB_REQ_GET_DESCRIPTOR, USB_RECIP_INTERFACE | USB_DIR_IN,
 				(type << 8), ifnum, buf, size, HZ * USB_CTRL_GET_TIMEOUT);
 		retries--;
-	} while (result < 0 && retries);
+	} while (result < size && retries);
 	return result;
 }
 
@@ -1663,7 +1666,7 @@
 	printk("\n");
 #endif
 
-	if (!(hid = hid_parse_report(rdesc, rsize))) {
+	if (!(hid = hid_parse_report(rdesc, n))) {
 		dbg("parsing report descriptor failed");
 		kfree(rdesc);
 		return NULL;
@@ -1740,7 +1743,7 @@
 		strcat(hid->name, buf);
 		if (usb_string(dev, dev->descriptor.iProduct, buf, 64) > 0)
 			snprintf(hid->name, 64, "%s %s", hid->name, buf);
-	} else if (usb_string(dev, dev->descriptor.iProduct, buf, 128) > 0) {
+	} else if (usb_string(dev, dev->descriptor.iProduct, buf, 64) > 0) {
 			snprintf(hid->name, 128, "%s", buf);
 	} else
 		snprintf(hid->name, 128, "%04x:%04x", 
diff -Nru a/drivers/usb/net/usbnet.c b/drivers/usb/net/usbnet.c
--- a/drivers/usb/net/usbnet.c	2005-01-14 16:01:50 -08:00
+++ b/drivers/usb/net/usbnet.c	2005-02-02 22:20:02 -08:00
@@ -3286,6 +3286,10 @@
 	// Surecom EP-1427X-2
 	USB_DEVICE (0x1189, 0x0893),
 	.driver_info = (unsigned long) &ax8817x_info,
+}, {
+	// goodway corp usb gwusb2e
+	USB_DEVICE (0x1631, 0x6200),
+	.driver_info = (unsigned long) &ax8817x_info,
 },
 #endif
 
diff -Nru a/drivers/usb/serial/Kconfig b/drivers/usb/serial/Kconfig
--- a/drivers/usb/serial/Kconfig	2004-12-05 10:44:05 -08:00
+++ b/drivers/usb/serial/Kconfig	2005-02-02 22:18:38 -08:00
@@ -203,7 +203,7 @@
 	  module will be called io_ti.
 
 config USB_SERIAL_GARMIN
-       tristate "Garmin GPS driver"
+       tristate "USB Garmin GPS driver"
        depends on USB_SERIAL
        help
          Say Y here if you want to connect to your Garmin GPS.
diff -Nru a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c
--- a/drivers/usb/serial/ftdi_sio.c	2005-01-14 16:00:58 -08:00
+++ b/drivers/usb/serial/ftdi_sio.c	2005-02-02 22:20:59 -08:00
@@ -1140,7 +1140,7 @@
 		goto check_and_exit;
 	}
 
-	if ((new_serial.baud_base != priv->baud_base) ||
+	if ((new_serial.baud_base != priv->baud_base) &&
 	    (new_serial.baud_base < 9600))
 		return -EINVAL;
 
diff -Nru a/drivers/usb/serial/garmin_gps.c b/drivers/usb/serial/garmin_gps.c
--- a/drivers/usb/serial/garmin_gps.c	2005-01-14 16:01:56 -08:00
+++ b/drivers/usb/serial/garmin_gps.c	2005-02-02 22:18:38 -08:00
@@ -1,7 +1,7 @@
 /*
  * Garmin GPS driver
  *
- * Copyright (C) 2004 Hermann Kneissel hkneissel@t-online.de
+ * Copyright (C) 2004 Hermann Kneissel herkne@users.sourceforge.net
  *
  * The latest version of the driver can be found at
  * http://sourceforge.net/projects/garmin-gps/
diff -Nru a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
--- a/drivers/usb/storage/unusual_devs.h	2005-01-14 16:02:13 -08:00
+++ b/drivers/usb/storage/unusual_devs.h	2005-02-02 22:19:27 -08:00
@@ -210,7 +210,15 @@
 		0), 
 #endif
 
-UNUSUAL_DEV(  0x04e6, 0x0006, 0x0100, 0x0205, 
+/* Reported by Markus Demleitner <msdemlei@cl.uni-heidelberg.de> */
+UNUSUAL_DEV(  0x04e6, 0x0006, 0x0100, 0x0100, 
+		"SCM Microsystems Inc.",
+		"eUSB MMC Adapter",
+		US_SC_SCSI, US_PR_CB, NULL, 
+		US_FL_SINGLE_LUN), 
+
+/* Reported by Daniel Nouri <dpunktnpunkt@web.de> */
+UNUSUAL_DEV(  0x04e6, 0x0006, 0x0205, 0x0205, 
 		"Shuttle",
 		"eUSB MMC Adapter",
 		US_SC_SCSI, US_PR_DEVICE, NULL, 
diff -Nru a/drivers/video/console/newport_con.c b/drivers/video/console/newport_con.c
--- a/drivers/video/console/newport_con.c	2004-07-29 09:00:39 -07:00
+++ b/drivers/video/console/newport_con.c	2005-02-03 06:42:40 -08:00
@@ -21,6 +21,7 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 
+#include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <asm/page.h>
@@ -73,7 +74,7 @@
 static inline void newport_render_background(int xstart, int ystart,
 					     int xend, int yend, int ci)
 {
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.wrmask = 0xffffffff;
 	npregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX
@@ -90,7 +91,7 @@
 	unsigned short i;
 
 	for (i = 0; i < 16; i++) {
-		newport_bfwait();
+		newport_bfwait(npregs);
 		newport_cmap_setaddr(npregs, color_table[i]);
 		newport_cmap_setrgb(npregs,
 				    default_red[i],
@@ -107,19 +108,19 @@
 	unsigned long i;
 
 	for (i = 0; i < logo->clutsize; i++) {
-		newport_bfwait();
+		newport_bfwait(npregs);
 		newport_cmap_setaddr(npregs, i + 0x20);
 		newport_cmap_setrgb(npregs, clut[0], clut[1], clut[2]);
 		clut += 3;
 	}
 
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_CHOST);
 
 	npregs->set.xystarti = ((newport_xsize - logo->width) << 16) | (0);
 	npregs->set.xyendi = ((newport_xsize - 1) << 16);
-	newport_wait();
+	newport_wait(npregs);
 
 	for (i = 0; i < logo->width*logo->height; i++)
 		npregs->go.hostrw0 = *data++ << 24;
@@ -132,7 +133,7 @@
 	if (logo_active)
 		return;
 
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.wrmask = 0xffffffff;
 	npregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX
@@ -154,7 +155,7 @@
 	unsigned short treg;
 	int i;
 
-	newport_wait();
+	newport_wait(npregs);
 	treg = newport_vc2_get(npregs, VC2_IREG_CONTROL);
 	newport_vc2_set(npregs, VC2_IREG_CONTROL,
 			(treg | VC2_CTRL_EVIDEO));
@@ -164,7 +165,7 @@
 	npregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |
 			       NPORT_DMODE_W2 | VC2_PROTOCOL);
 	for (i = 0; i < 128; i++) {
-		newport_bfwait();
+		newport_bfwait(npregs);
 		if (i == 92 || i == 94)
 			npregs->set.dcbdata0.byshort.s1 = 0xff00;
 		else
@@ -204,7 +205,7 @@
 	npregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |
 			       NPORT_DMODE_W2 | VC2_PROTOCOL);
 	for (i = 0; i < 128; i++) {
-		newport_bfwait();
+		newport_bfwait(npregs);
 		linetable[i] = npregs->set.dcbdata0.byshort.s1;
 	}
 
@@ -215,12 +216,12 @@
 		npregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |
 				       NPORT_DMODE_W2 | VC2_PROTOCOL);
 		do {
-			newport_bfwait();
+			newport_bfwait(npregs);
 			treg = npregs->set.dcbdata0.byshort.s1;
 			if ((treg & 1) == 0)
 				cols += (treg >> 7) & 0xfe;
 			if ((treg & 0x80) == 0) {
-				newport_bfwait();
+				newport_bfwait(npregs);
 				treg = npregs->set.dcbdata0.byshort.s1;
 			}
 		} while ((treg & 0x8000) == 0);
@@ -290,16 +291,16 @@
 
 	if (!sgi_gfxaddr)
 		return NULL;
-	npregs = (struct newport_regs *) (KSEG1 + sgi_gfxaddr);
+	npregs = (struct newport_regs *)	/* ioremap cannot fail */
+		 ioremap(sgi_gfxaddr, sizeof(struct newport_regs));
 	npregs->cset.config = NPORT_CFG_GD0;
 
-	if (newport_wait()) {
-		return NULL;
-	}
+	if (newport_wait(npregs))
+		goto out_unmap;
 
 	npregs->set.xstarti = TESTVAL;
 	if (npregs->set._xstart.word != XSTI_TO_FXSTART(TESTVAL))
-		return NULL;
+		goto out_unmap;
 
 	for (i = 0; i < MAX_NR_CONSOLES; i++)
 		font_data[i] = FONT_DATA;
@@ -309,6 +310,10 @@
 	newport_get_screensize();
 
 	return "SGI Newport";
+
+out_unmap:
+	iounmap((void *)npregs);
+	return NULL;
 }
 
 static void newport_init(struct vc_data *vc, int init)
@@ -362,7 +367,7 @@
 				  (charattr & 0xf0) >> 4);
 
 	/* Set the color and drawing mode. */
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.colori = charattr & 0xf;
 	npregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_STOPX | NPORT_DMODE0_ZPENAB |
@@ -371,7 +376,7 @@
 	/* Set coordinates for bitmap operation. */
 	npregs->set.xystarti = (xpos << 16) | ((ypos + topscan) & 0x3ff);
 	npregs->set.xyendi = ((xpos + 7) << 16);
-	newport_wait();
+	newport_wait(npregs);
 
 	/* Go, baby, go... */
 	RENDER(npregs, p);
@@ -395,7 +400,7 @@
 					  xpos + ((count - 1) << 3), ypos,
 					  (charattr & 0xf0) >> 4);
 
-	newport_wait();
+	newport_wait(npregs);
 
 	/* Set the color and drawing mode. */
 	npregs->set.colori = charattr & 0xf;
@@ -406,7 +411,7 @@
 	for (i = 0; i < count; i++, xpos += 8) {
 		p = &font_data[vc->vc_num][(scr_readw(s++) & 0xff) << 4];
 
-		newport_wait();
+		newport_wait(npregs);
 
 		/* Set coordinates for bitmap operation. */
 		npregs->set.xystarti =
@@ -459,7 +464,7 @@
 	return 1;
 }
 
-static int newport_blank(struct vc_data *c, int blank)
+static int newport_blank(struct vc_data *c, int blank, int mode_switch)
 {
 	unsigned short treg;
 
@@ -684,7 +689,7 @@
 		xe = xs;
 		xs = tmp;
 	}
-	newport_wait();
+	newport_wait(npregs);
 	npregs->set.drawmode0 = (NPORT_DMODE0_S2S | NPORT_DMODE0_BLOCK |
 				 NPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX
 				 | NPORT_DMODE0_STOPY);
@@ -701,24 +706,24 @@
 #define DUMMY (void *) newport_dummy
 
 const struct consw newport_con = {
-    .owner =		THIS_MODULE,
-    .con_startup =	newport_startup,
-    .con_init =		newport_init,
-    .con_deinit =	newport_deinit,
-    .con_clear =	newport_clear,
-    .con_putc =		newport_putc,
-    .con_putcs =	newport_putcs,
-    .con_cursor =	newport_cursor,
-    .con_scroll =	newport_scroll,
-    .con_bmove =	newport_bmove,
-    .con_switch =	newport_switch,
-    .con_blank =	newport_blank,
-    .con_font_set =	newport_font_set,
-    .con_font_default =	newport_font_default,
-    .con_set_palette =	newport_set_palette,
-    .con_scrolldelta =	newport_scrolldelta,
-    .con_set_origin =	DUMMY,
-    .con_save_screen =	DUMMY
+	.owner		  = THIS_MODULE,
+	.con_startup	  = newport_startup,
+	.con_init	  = newport_init,
+	.con_deinit	  = newport_deinit,
+	.con_clear	  = newport_clear,
+	.con_putc	  = newport_putc,
+	.con_putcs	  = newport_putcs,
+	.con_cursor	  = newport_cursor,
+	.con_scroll	  = newport_scroll,
+	.con_bmove 	  = newport_bmove,
+	.con_switch	  = newport_switch,
+	.con_blank	  = newport_blank,
+	.con_font_set	  = newport_font_set,
+	.con_font_default = newport_font_default,
+	.con_set_palette  = newport_set_palette,
+	.con_scrolldelta  = newport_scrolldelta,
+	.con_set_origin	  = DUMMY,
+	.con_save_screen  = DUMMY
 };
 
 #ifdef MODULE
@@ -730,6 +735,7 @@
 static void __exit newport_console_exit(void)
 {
 	give_up_console(&newport_con);
+	iounmap((void *)npregs);
 }
 
 module_init(newport_console_init);
diff -Nru a/fs/read_write.c b/fs/read_write.c
--- a/fs/read_write.c	2005-01-25 20:29:40 -08:00
+++ b/fs/read_write.c	2005-02-03 10:18:50 -08:00
@@ -186,14 +186,21 @@
 int rw_verify_area(int read_write, struct file *file, loff_t *ppos, size_t count)
 {
 	struct inode *inode;
+	loff_t pos;
 
-	if (count > file->f_maxcount)
-		return -EINVAL;
+	if (unlikely(count > file->f_maxcount))
+		goto Einval;
+	pos = *ppos;
+	if (unlikely((pos < 0) || (loff_t) (pos + count) < 0))
+		goto Einval;
 
 	inode = file->f_dentry->d_inode;
 	if (inode->i_flock && MANDATORY_LOCK(inode))
-		return locks_mandatory_area(read_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE, inode, file, *ppos, count);
+		return locks_mandatory_area(read_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE, inode, file, pos, count);
 	return 0;
+
+Einval:
+	return -EINVAL;
 }
 
 ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)
@@ -220,6 +227,8 @@
 		return -EBADF;
 	if (!file->f_op || (!file->f_op->read && !file->f_op->aio_read))
 		return -EINVAL;
+	if (unlikely(!access_ok(VERIFY_WRITE, buf, count)))
+		return -EFAULT;
 
 	ret = rw_verify_area(READ, file, pos, count);
 	if (!ret) {
@@ -266,6 +275,8 @@
 		return -EBADF;
 	if (!file->f_op || (!file->f_op->write && !file->f_op->aio_write))
 		return -EINVAL;
+	if (unlikely(!access_ok(VERIFY_READ, buf, count)))
+		return -EFAULT;
 
 	ret = rw_verify_area(WRITE, file, pos, count);
 	if (!ret) {
@@ -397,6 +408,9 @@
 
 EXPORT_SYMBOL(iov_shorten);
 
+/* A write operation does a read from user space and vice versa */
+#define vrfy_dir(type) ((type) == READ ? VERIFY_WRITE : VERIFY_READ)
+
 static ssize_t do_readv_writev(int type, struct file *file,
 			       const struct iovec __user * uvector,
 			       unsigned long nr_segs, loff_t *pos)
@@ -450,8 +464,11 @@
 	tot_len = 0;
 	ret = -EINVAL;
 	for (seg = 0; seg < nr_segs; seg++) {
+		void __user *buf = iov[seg].iov_base;
 		ssize_t len = (ssize_t)iov[seg].iov_len;
 
+		if (unlikely(!access_ok(vrfy_dir(type), buf, len)))
+			goto Efault;
 		if (len < 0)	/* size_t not fitting an ssize_t .. */
 			goto out;
 		tot_len += len;
@@ -510,6 +527,9 @@
 		dnotify_parent(file->f_dentry,
 				(type == READ) ? DN_ACCESS : DN_MODIFY);
 	return ret;
+Efault:
+	ret = -EFAULT;
+	goto out;
 }
 
 ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,
diff -Nru a/fs/reiserfs/super.c b/fs/reiserfs/super.c
--- a/fs/reiserfs/super.c	2005-01-07 21:44:20 -08:00
+++ b/fs/reiserfs/super.c	2005-02-03 06:42:39 -08:00
@@ -1835,9 +1835,11 @@
     int ret;
 
     /* We may create quota structure so we need to reserve enough blocks */
+    reiserfs_write_lock(inode->i_sb);
     journal_begin(&th, inode->i_sb, 2*REISERFS_QUOTA_INIT_BLOCKS);
     ret = dquot_initialize(inode, type);
     journal_end(&th, inode->i_sb, 2*REISERFS_QUOTA_INIT_BLOCKS);
+    reiserfs_write_unlock(inode->i_sb);
     return ret;
 }
 
@@ -1847,9 +1849,11 @@
     int ret;
 
     /* We may delete quota structure so we need to reserve enough blocks */
+    reiserfs_write_lock(inode->i_sb);
     journal_begin(&th, inode->i_sb, 2*REISERFS_QUOTA_INIT_BLOCKS);
     ret = dquot_drop(inode);
     journal_end(&th, inode->i_sb, 2*REISERFS_QUOTA_INIT_BLOCKS);
+    reiserfs_write_unlock(inode->i_sb);
     return ret;
 }
 
@@ -1858,9 +1862,11 @@
     struct reiserfs_transaction_handle th;
     int ret;
 
+    reiserfs_write_lock(dquot->dq_sb);
     journal_begin(&th, dquot->dq_sb, REISERFS_QUOTA_TRANS_BLOCKS);
     ret = dquot_commit(dquot);
     journal_end(&th, dquot->dq_sb, REISERFS_QUOTA_TRANS_BLOCKS);
+    reiserfs_write_unlock(dquot->dq_sb);
     return ret;
 }
 
@@ -1869,9 +1875,11 @@
     struct reiserfs_transaction_handle th;
     int ret;
 
+    reiserfs_write_lock(dquot->dq_sb);
     journal_begin(&th, dquot->dq_sb, REISERFS_QUOTA_INIT_BLOCKS);
     ret = dquot_acquire(dquot);
     journal_end(&th, dquot->dq_sb, REISERFS_QUOTA_INIT_BLOCKS);
+    reiserfs_write_unlock(dquot->dq_sb);
     return ret;
 }
 
@@ -1880,9 +1888,11 @@
     struct reiserfs_transaction_handle th;
     int ret;
 
+    reiserfs_write_lock(dquot->dq_sb);
     journal_begin(&th, dquot->dq_sb, REISERFS_QUOTA_INIT_BLOCKS);
     ret = dquot_release(dquot);
     journal_end(&th, dquot->dq_sb, REISERFS_QUOTA_INIT_BLOCKS);
+    reiserfs_write_unlock(dquot->dq_sb);
     return ret;
 }
 
@@ -1904,9 +1914,11 @@
     int ret;
 
     /* Data block + inode block */
+    reiserfs_write_lock(sb);
     journal_begin(&th, sb, 2);
     ret = dquot_commit_info(sb, type);
     journal_end(&th, sb, 2);
+    reiserfs_write_unlock(sb);
     return ret;
 }
 
@@ -1993,7 +2005,9 @@
 	tocopy = sb->s_blocksize - offset < toread ? sb->s_blocksize - offset : toread;
 	tmp_bh.b_state = 0;
 	/* Quota files are without tails so we can safely use this function */
+	reiserfs_write_lock(sb);
 	err = reiserfs_get_block(inode, blk, &tmp_bh, 0);
+	reiserfs_write_unlock(sb);
 	if (err)
 	    return err;
 	if (!buffer_mapped(&tmp_bh))    /* A hole? */
@@ -2041,8 +2055,11 @@
 	    err = -EIO;
 	    goto out;
 	}
+	lock_buffer(bh);
 	memcpy(bh->b_data+offset, data, tocopy);
+	flush_dcache_page(bh->b_page);
 	set_buffer_uptodate(bh);
+	unlock_buffer(bh);
 	reiserfs_prepare_for_journal(sb, bh, 1);
 	journal_mark_dirty(current->journal_info, sb, bh);
 	if (!journal_quota)
diff -Nru a/include/asm-ia64/kregs.h b/include/asm-ia64/kregs.h
--- a/include/asm-ia64/kregs.h	2004-12-10 13:25:43 -08:00
+++ b/include/asm-ia64/kregs.h	2005-01-26 10:01:36 -08:00
@@ -14,7 +14,7 @@
  */
 #define IA64_KR_IO_BASE		0	/* ar.k0: legacy I/O base address */
 #define IA64_KR_TSSD		1	/* ar.k1: IVE uses this as the TSSD */
-#define IA64_KR_PA_CPU_INFO	3	/* ar.k3: phys addr of this cpu's cpu_info struct */
+#define IA64_KR_PER_CPU_DATA	3	/* ar.k3: physical per-CPU base */
 #define IA64_KR_CURRENT_STACK	4	/* ar.k4: what's mapped in IA64_TR_CURRENT_STACK */
 #define IA64_KR_FPU_OWNER	5	/* ar.k5: fpu-owner (UP only, at the moment) */
 #define IA64_KR_CURRENT		6	/* ar.k6: "current" task pointer */
diff -Nru a/include/asm-ia64/mca.h b/include/asm-ia64/mca.h
--- a/include/asm-ia64/mca.h	2005-01-07 13:54:29 -08:00
+++ b/include/asm-ia64/mca.h	2005-01-26 10:01:37 -08:00
@@ -11,6 +11,8 @@
 #ifndef _ASM_IA64_MCA_H
 #define _ASM_IA64_MCA_H
 
+#define IA64_MCA_STACK_SIZE	8192
+
 #if !defined(__ASSEMBLY__)
 
 #include <linux/interrupt.h>
@@ -102,21 +104,21 @@
 						 */
 } ia64_mca_os_to_sal_state_t;
 
-#define IA64_MCA_STACK_SIZE 	1024
-#define IA64_MCA_STACK_SIZE_BYTES 	(1024 * 8)
-#define IA64_MCA_BSPSTORE_SIZE 	1024
-
-typedef struct ia64_mca_cpu_s {
-	u64	ia64_mca_stack[IA64_MCA_STACK_SIZE] 		__attribute__((aligned(16)));
-	u64	ia64_mca_proc_state_dump[512]			__attribute__((aligned(16)));
-	u64	ia64_mca_stackframe[32]				__attribute__((aligned(16)));
-	u64	ia64_mca_bspstore[IA64_MCA_BSPSTORE_SIZE]	__attribute__((aligned(16)));
-	u64	ia64_init_stack[KERNEL_STACK_SIZE/8] 		__attribute__((aligned(16)));
-} ia64_mca_cpu_t;
+/* Per-CPU MCA state that is too big for normal per-CPU variables.  */
+
+struct ia64_mca_cpu {
+	u64 stack[IA64_MCA_STACK_SIZE/8];	/* MCA memory-stack */
+	u64 proc_state_dump[512];
+	u64 stackframe[32];
+	u64 rbstore[IA64_MCA_STACK_SIZE/8];	/* MCA reg.-backing store */
+	u64 init_stack[KERNEL_STACK_SIZE/8];
+} __attribute__ ((aligned(16)));
 
-#define PERCPU_MCA_SIZE sizeof(ia64_mca_cpu_t)
+/* Array of physical addresses of each CPU's MCA area.  */
+extern unsigned long __per_cpu_mca[NR_CPUS];
 
 extern void ia64_mca_init(void);
+extern void ia64_mca_cpu_init(void *);
 extern void ia64_os_mca_dispatch(void);
 extern void ia64_os_mca_dispatch_end(void);
 extern void ia64_mca_ucmc_handler(void);
diff -Nru a/include/asm-ia64/mca_asm.h b/include/asm-ia64/mca_asm.h
--- a/include/asm-ia64/mca_asm.h	2005-01-06 16:22:36 -08:00
+++ b/include/asm-ia64/mca_asm.h	2005-01-26 10:01:38 -08:00
@@ -46,40 +46,9 @@
 	mov	temp	= 0x7	;;							\
 	dep	addr	= temp, addr, 61, 3
 
-/*
- * This macro gets the physical address of this cpu's cpuinfo structure.
- */
-#define GET_PERCPU_PADDR(reg)							\
-	mov	reg	= ar.k3;;						\
-	addl	reg	= IA64_CPUINFO_PERCPU_PADDR,reg
-
-#define GET_CPUINFO_PAL_PADDR(reg)						\
-	mov	reg	= ar.k3;;						\
-	addl	reg	= IA64_CPUINFO_PAL_PADDR,reg
-
-/*
- * This macro gets the physical address of this cpu's MCA save structure.
- */
-#define GET_CPUINFO_MCA_PADDR(reg)						\
-	mov	reg	= ar.k3;;						\
-	addl	reg	= IA64_CPUINFO_PA_MCA_INFO,reg;;			\
-	ld8	reg	= [reg]
-
-#define	GET_MCA_BSPSTORE(reg)							\
-	GET_CPUINFO_MCA_PADDR(reg);;						\
-	addl	reg	= IA64_MCA_BSPSTORE,reg
-
-#define	GET_MCA_STACKFRAME(reg)							\
-	GET_CPUINFO_MCA_PADDR(reg);;						\
-	addl	reg	= IA64_MCA_STACKFRAME,reg
-
-#define	GET_MCA_STACK(reg)							\
-	GET_CPUINFO_MCA_PADDR(reg);;						\
-	addl	reg	= IA64_MCA_STACK,reg
-
-#define	GET_MCA_DUMP_PADDR(reg)							\
-	GET_CPUINFO_MCA_PADDR(reg);;						\
-	addl	reg	= IA64_MCA_PROC_STATE_DUMP,reg
+#define GET_THIS_PADDR(reg, var)		\
+	mov	reg = IA64_KR(PER_CPU_DATA);;	\
+        addl	reg = THIS_CPU(var), reg
 
 /*
  * This macro jumps to the instruction at the given virtual address
diff -Nru a/include/asm-ia64/percpu.h b/include/asm-ia64/percpu.h
--- a/include/asm-ia64/percpu.h	2005-01-06 16:23:02 -08:00
+++ b/include/asm-ia64/percpu.h	2005-02-02 12:22:04 -08:00
@@ -56,8 +56,6 @@
 
 #endif	/* SMP */
 
-extern unsigned long __per_cpu_mca[NR_CPUS];
-
 #define EXPORT_PER_CPU_SYMBOL(var)		EXPORT_SYMBOL(per_cpu__##var)
 #define EXPORT_PER_CPU_SYMBOL_GPL(var)		EXPORT_SYMBOL_GPL(per_cpu__##var)
 
diff -Nru a/include/asm-ia64/processor.h b/include/asm-ia64/processor.h
--- a/include/asm-ia64/processor.h	2004-12-10 13:24:20 -08:00
+++ b/include/asm-ia64/processor.h	2005-01-26 10:01:41 -08:00
@@ -151,12 +151,9 @@
 	__u64 itc_freq;		/* frequency of ITC counter */
 	__u64 proc_freq;	/* frequency of processor */
 	__u64 cyc_per_usec;	/* itc_freq/1000000 */
-	__u64 percpu_paddr;
 	__u64 ptce_base;
 	__u32 ptce_count[2];
 	__u32 ptce_stride[2];
-	__u64 pal_paddr;
-	__u64 pal_base;
 	struct task_struct *ksoftirqd;	/* kernel softirq daemon for this CPU */
 
 #ifdef CONFIG_SMP
@@ -177,7 +174,6 @@
 #ifdef CONFIG_NUMA
 	struct ia64_node_data *node_data;
 #endif
-	__u64 *ia64_pa_mca_data;	/* prt to MCA/INIT processor state */
 };
 
 DECLARE_PER_CPU(struct cpuinfo_ia64, cpu_info);
diff -Nru a/include/asm-ia64/sn/shubio.h b/include/asm-ia64/sn/shubio.h
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/include/asm-ia64/sn/shubio.h	2005-01-28 15:36:08 -08:00
@@ -0,0 +1,3476 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1992 - 1997, 2000-2004 Silicon Graphics, Inc. All rights reserved.
+ */
+
+#ifndef _ASM_IA64_SN_SHUBIO_H
+#define _ASM_IA64_SN_SHUBIO_H
+
+#define HUB_WIDGET_ID_MAX 0xf
+#define IIO_NUM_ITTES   7
+#define HUB_NUM_BIG_WINDOW      (IIO_NUM_ITTES - 1)
+
+#define    IIO_WID                   0x00400000    /* Crosstalk Widget Identification */
+                                                   /* This register is also accessible from
+                                                    * Crosstalk at address 0x0.  */
+#define    IIO_WSTAT                 0x00400008    /* Crosstalk Widget Status */
+#define    IIO_WCR                   0x00400020    /* Crosstalk Widget Control Register */
+#define    IIO_ILAPR                 0x00400100    /* IO Local Access Protection Register */
+#define    IIO_ILAPO                 0x00400108    /* IO Local Access Protection Override */
+#define    IIO_IOWA                  0x00400110    /* IO Outbound Widget Access */
+#define    IIO_IIWA                  0x00400118    /* IO Inbound Widget Access */
+#define    IIO_IIDEM                 0x00400120    /* IO Inbound Device Error Mask */
+#define    IIO_ILCSR                 0x00400128    /* IO LLP Control and Status Register */
+#define    IIO_ILLR                  0x00400130    /* IO LLP Log Register    */
+#define    IIO_IIDSR                 0x00400138    /* IO Interrupt Destination */
+
+#define    IIO_IGFX0                 0x00400140    /* IO Graphics Node-Widget Map 0 */
+#define    IIO_IGFX1                 0x00400148    /* IO Graphics Node-Widget Map 1 */
+
+#define    IIO_ISCR0                 0x00400150    /* IO Scratch Register 0 */
+#define    IIO_ISCR1                 0x00400158    /* IO Scratch Register 1 */
+
+#define    IIO_ITTE1                 0x00400160    /* IO Translation Table Entry 1 */
+#define    IIO_ITTE2                 0x00400168    /* IO Translation Table Entry 2 */
+#define    IIO_ITTE3                 0x00400170    /* IO Translation Table Entry 3 */
+#define    IIO_ITTE4                 0x00400178    /* IO Translation Table Entry 4 */
+#define    IIO_ITTE5                 0x00400180    /* IO Translation Table Entry 5 */
+#define    IIO_ITTE6                 0x00400188    /* IO Translation Table Entry 6 */
+#define    IIO_ITTE7                 0x00400190    /* IO Translation Table Entry 7 */
+
+#define    IIO_IPRB0                 0x00400198    /* IO PRB Entry 0         */
+#define    IIO_IPRB8                 0x004001A0    /* IO PRB Entry 8         */
+#define    IIO_IPRB9                 0x004001A8    /* IO PRB Entry 9         */
+#define    IIO_IPRBA                 0x004001B0    /* IO PRB Entry A         */
+#define    IIO_IPRBB                 0x004001B8    /* IO PRB Entry B         */
+#define    IIO_IPRBC                 0x004001C0    /* IO PRB Entry C         */
+#define    IIO_IPRBD                 0x004001C8    /* IO PRB Entry D         */
+#define    IIO_IPRBE                 0x004001D0    /* IO PRB Entry E         */
+#define    IIO_IPRBF                 0x004001D8    /* IO PRB Entry F         */
+
+#define    IIO_IXCC                  0x004001E0    /* IO Crosstalk Credit Count Timeout */
+#define    IIO_IMEM                  0x004001E8    /* IO Miscellaneous Error Mask */
+#define    IIO_IXTT                  0x004001F0    /* IO Crosstalk Timeout Threshold */
+#define    IIO_IECLR                 0x004001F8    /* IO Error Clear Register */
+#define    IIO_IBCR                  0x00400200    /* IO BTE Control Register */
+
+#define    IIO_IXSM                  0x00400208    /* IO Crosstalk Spurious Message */
+#define    IIO_IXSS                  0x00400210    /* IO Crosstalk Spurious Sideband */
+
+#define    IIO_ILCT                  0x00400218    /* IO LLP Channel Test    */
+
+#define    IIO_IIEPH1                0x00400220    /* IO Incoming Error Packet Header, Part 1 */
+#define    IIO_IIEPH2                0x00400228    /* IO Incoming Error Packet Header, Part 2 */
+
+
+#define    IIO_ISLAPR                0x00400230    /* IO SXB Local Access Protection Regster */
+#define    IIO_ISLAPO                0x00400238    /* IO SXB Local Access Protection Override */
+
+#define    IIO_IWI                   0x00400240    /* IO Wrapper Interrupt Register */
+#define    IIO_IWEL                  0x00400248    /* IO Wrapper Error Log Register */
+#define    IIO_IWC                   0x00400250    /* IO Wrapper Control Register */
+#define    IIO_IWS                   0x00400258    /* IO Wrapper Status Register */
+#define    IIO_IWEIM                 0x00400260    /* IO Wrapper Error Interrupt Masking Register */
+
+#define    IIO_IPCA                  0x00400300    /* IO PRB Counter Adjust */
+
+#define    IIO_IPRTE0_A              0x00400308    /* IO PIO Read Address Table Entry 0, Part A */
+#define    IIO_IPRTE1_A              0x00400310    /* IO PIO Read Address Table Entry 1, Part A */
+#define    IIO_IPRTE2_A              0x00400318    /* IO PIO Read Address Table Entry 2, Part A */
+#define    IIO_IPRTE3_A               0x00400320    /* IO PIO Read Address Table Entry 3, Part A */
+#define    IIO_IPRTE4_A               0x00400328    /* IO PIO Read Address Table Entry 4, Part A */
+#define    IIO_IPRTE5_A               0x00400330    /* IO PIO Read Address Table Entry 5, Part A */
+#define    IIO_IPRTE6_A               0x00400338    /* IO PIO Read Address Table Entry 6, Part A */
+#define    IIO_IPRTE7_A               0x00400340    /* IO PIO Read Address Table Entry 7, Part A */
+
+#define    IIO_IPRTE0_B              0x00400348    /* IO PIO Read Address Table Entry 0, Part B */
+#define    IIO_IPRTE1_B              0x00400350    /* IO PIO Read Address Table Entry 1, Part B */
+#define    IIO_IPRTE2_B              0x00400358    /* IO PIO Read Address Table Entry 2, Part B */
+#define    IIO_IPRTE3_B               0x00400360    /* IO PIO Read Address Table Entry 3, Part B */
+#define    IIO_IPRTE4_B               0x00400368    /* IO PIO Read Address Table Entry 4, Part B */
+#define    IIO_IPRTE5_B               0x00400370    /* IO PIO Read Address Table Entry 5, Part B */
+#define    IIO_IPRTE6_B               0x00400378    /* IO PIO Read Address Table Entry 6, Part B */
+#define    IIO_IPRTE7_B               0x00400380    /* IO PIO Read Address Table Entry 7, Part B */
+
+#define    IIO_IPDR                  0x00400388    /* IO PIO Deallocation Register */
+#define    IIO_ICDR                  0x00400390    /* IO CRB Entry Deallocation Register */
+#define    IIO_IFDR                  0x00400398    /* IO IOQ FIFO Depth Register */
+#define    IIO_IIAP                  0x004003A0    /* IO IIQ Arbitration Parameters */
+#define    IIO_ICMR                  0x004003A8    /* IO CRB Management Register */
+#define    IIO_ICCR                  0x004003B0    /* IO CRB Control Register */
+#define    IIO_ICTO                  0x004003B8    /* IO CRB Timeout         */
+#define    IIO_ICTP                  0x004003C0    /* IO CRB Timeout Prescalar */
+
+#define    IIO_ICRB0_A               0x00400400    /* IO CRB Entry 0_A       */
+#define    IIO_ICRB0_B               0x00400408    /* IO CRB Entry 0_B       */
+#define    IIO_ICRB0_C               0x00400410    /* IO CRB Entry 0_C       */
+#define    IIO_ICRB0_D               0x00400418    /* IO CRB Entry 0_D       */
+#define    IIO_ICRB0_E               0x00400420    /* IO CRB Entry 0_E       */
+
+#define    IIO_ICRB1_A               0x00400430    /* IO CRB Entry 1_A       */
+#define    IIO_ICRB1_B               0x00400438    /* IO CRB Entry 1_B       */
+#define    IIO_ICRB1_C               0x00400440    /* IO CRB Entry 1_C       */
+#define    IIO_ICRB1_D               0x00400448    /* IO CRB Entry 1_D       */
+#define    IIO_ICRB1_E               0x00400450    /* IO CRB Entry 1_E       */
+
+#define    IIO_ICRB2_A               0x00400460    /* IO CRB Entry 2_A       */
+#define    IIO_ICRB2_B               0x00400468    /* IO CRB Entry 2_B       */
+#define    IIO_ICRB2_C               0x00400470    /* IO CRB Entry 2_C       */
+#define    IIO_ICRB2_D               0x00400478    /* IO CRB Entry 2_D       */
+#define    IIO_ICRB2_E               0x00400480    /* IO CRB Entry 2_E       */
+
+#define    IIO_ICRB3_A               0x00400490    /* IO CRB Entry 3_A       */
+#define    IIO_ICRB3_B               0x00400498    /* IO CRB Entry 3_B       */
+#define    IIO_ICRB3_C               0x004004a0    /* IO CRB Entry 3_C       */
+#define    IIO_ICRB3_D               0x004004a8    /* IO CRB Entry 3_D       */
+#define    IIO_ICRB3_E               0x004004b0    /* IO CRB Entry 3_E       */
+
+#define    IIO_ICRB4_A               0x004004c0    /* IO CRB Entry 4_A       */
+#define    IIO_ICRB4_B               0x004004c8    /* IO CRB Entry 4_B       */
+#define    IIO_ICRB4_C               0x004004d0    /* IO CRB Entry 4_C       */
+#define    IIO_ICRB4_D               0x004004d8    /* IO CRB Entry 4_D       */
+#define    IIO_ICRB4_E               0x004004e0    /* IO CRB Entry 4_E       */
+
+#define    IIO_ICRB5_A               0x004004f0    /* IO CRB Entry 5_A       */
+#define    IIO_ICRB5_B               0x004004f8    /* IO CRB Entry 5_B       */
+#define    IIO_ICRB5_C               0x00400500    /* IO CRB Entry 5_C       */
+#define    IIO_ICRB5_D               0x00400508    /* IO CRB Entry 5_D       */
+#define    IIO_ICRB5_E               0x00400510    /* IO CRB Entry 5_E       */
+
+#define    IIO_ICRB6_A               0x00400520    /* IO CRB Entry 6_A       */
+#define    IIO_ICRB6_B               0x00400528    /* IO CRB Entry 6_B       */
+#define    IIO_ICRB6_C               0x00400530    /* IO CRB Entry 6_C       */
+#define    IIO_ICRB6_D               0x00400538    /* IO CRB Entry 6_D       */
+#define    IIO_ICRB6_E               0x00400540    /* IO CRB Entry 6_E       */
+
+#define    IIO_ICRB7_A               0x00400550    /* IO CRB Entry 7_A       */
+#define    IIO_ICRB7_B               0x00400558    /* IO CRB Entry 7_B       */
+#define    IIO_ICRB7_C               0x00400560    /* IO CRB Entry 7_C       */
+#define    IIO_ICRB7_D               0x00400568    /* IO CRB Entry 7_D       */
+#define    IIO_ICRB7_E               0x00400570    /* IO CRB Entry 7_E       */
+
+#define    IIO_ICRB8_A               0x00400580    /* IO CRB Entry 8_A       */
+#define    IIO_ICRB8_B               0x00400588    /* IO CRB Entry 8_B       */
+#define    IIO_ICRB8_C               0x00400590    /* IO CRB Entry 8_C       */
+#define    IIO_ICRB8_D               0x00400598    /* IO CRB Entry 8_D       */
+#define    IIO_ICRB8_E               0x004005a0    /* IO CRB Entry 8_E       */
+
+#define    IIO_ICRB9_A               0x004005b0    /* IO CRB Entry 9_A       */
+#define    IIO_ICRB9_B               0x004005b8    /* IO CRB Entry 9_B       */
+#define    IIO_ICRB9_C               0x004005c0    /* IO CRB Entry 9_C       */
+#define    IIO_ICRB9_D               0x004005c8    /* IO CRB Entry 9_D       */
+#define    IIO_ICRB9_E               0x004005d0    /* IO CRB Entry 9_E       */
+
+#define    IIO_ICRBA_A               0x004005e0    /* IO CRB Entry A_A       */
+#define    IIO_ICRBA_B               0x004005e8    /* IO CRB Entry A_B       */
+#define    IIO_ICRBA_C               0x004005f0    /* IO CRB Entry A_C       */
+#define    IIO_ICRBA_D               0x004005f8    /* IO CRB Entry A_D       */
+#define    IIO_ICRBA_E               0x00400600    /* IO CRB Entry A_E       */
+
+#define    IIO_ICRBB_A               0x00400610    /* IO CRB Entry B_A       */
+#define    IIO_ICRBB_B               0x00400618    /* IO CRB Entry B_B       */
+#define    IIO_ICRBB_C               0x00400620    /* IO CRB Entry B_C       */
+#define    IIO_ICRBB_D               0x00400628    /* IO CRB Entry B_D       */
+#define    IIO_ICRBB_E               0x00400630    /* IO CRB Entry B_E       */
+
+#define    IIO_ICRBC_A               0x00400640    /* IO CRB Entry C_A       */
+#define    IIO_ICRBC_B               0x00400648    /* IO CRB Entry C_B       */
+#define    IIO_ICRBC_C               0x00400650    /* IO CRB Entry C_C       */
+#define    IIO_ICRBC_D               0x00400658    /* IO CRB Entry C_D       */
+#define    IIO_ICRBC_E               0x00400660    /* IO CRB Entry C_E       */
+
+#define    IIO_ICRBD_A               0x00400670    /* IO CRB Entry D_A       */
+#define    IIO_ICRBD_B               0x00400678    /* IO CRB Entry D_B       */
+#define    IIO_ICRBD_C               0x00400680    /* IO CRB Entry D_C       */
+#define    IIO_ICRBD_D               0x00400688    /* IO CRB Entry D_D       */
+#define    IIO_ICRBD_E               0x00400690    /* IO CRB Entry D_E       */
+
+#define    IIO_ICRBE_A               0x004006a0    /* IO CRB Entry E_A       */
+#define    IIO_ICRBE_B               0x004006a8    /* IO CRB Entry E_B       */
+#define    IIO_ICRBE_C               0x004006b0    /* IO CRB Entry E_C       */
+#define    IIO_ICRBE_D               0x004006b8    /* IO CRB Entry E_D       */
+#define    IIO_ICRBE_E               0x004006c0    /* IO CRB Entry E_E       */
+
+#define    IIO_ICSML                 0x00400700    /* IO CRB Spurious Message Low */
+#define    IIO_ICSMM                 0x00400708    /* IO CRB Spurious Message Middle */
+#define    IIO_ICSMH                 0x00400710    /* IO CRB Spurious Message High */
+
+#define    IIO_IDBSS                 0x00400718    /* IO Debug Submenu Select */
+
+#define    IIO_IBLS0                 0x00410000    /* IO BTE Length Status 0 */
+#define    IIO_IBSA0                 0x00410008    /* IO BTE Source Address 0 */
+#define    IIO_IBDA0                 0x00410010    /* IO BTE Destination Address 0 */
+#define    IIO_IBCT0                 0x00410018    /* IO BTE Control Terminate 0 */
+#define    IIO_IBNA0                 0x00410020    /* IO BTE Notification Address 0 */
+#define    IIO_IBIA0                 0x00410028    /* IO BTE Interrupt Address 0 */
+#define    IIO_IBLS1                 0x00420000    /* IO BTE Length Status 1 */
+#define    IIO_IBSA1                 0x00420008    /* IO BTE Source Address 1 */
+#define    IIO_IBDA1                 0x00420010    /* IO BTE Destination Address 1 */
+#define    IIO_IBCT1                 0x00420018    /* IO BTE Control Terminate 1 */
+#define    IIO_IBNA1                 0x00420020    /* IO BTE Notification Address 1 */
+#define    IIO_IBIA1                 0x00420028    /* IO BTE Interrupt Address 1 */
+
+#define    IIO_IPCR                  0x00430000    /* IO Performance Control */
+#define    IIO_IPPR                  0x00430008    /* IO Performance Profiling */
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  This register echoes some information from the         *
+ * LB_REV_ID register. It is available through Crosstalk as described   *
+ * above. The REV_NUM and MFG_NUM fields receive their values from      *
+ * the REVISION and MANUFACTURER fields in the LB_REV_ID register.      *
+ * The PART_NUM field's value is the Crosstalk device ID number that    *
+ * Steve Miller assigned to the SHub chip.                              *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_wid_u {
+	uint64_t	ii_wid_regval;
+	struct	{
+		uint64_t	w_rsvd_1		  :	 1;
+		uint64_t	w_mfg_num		  :	11;
+		uint64_t	w_part_num		  :	16;
+		uint64_t	w_rev_num		  :	 4;
+		uint64_t	w_rsvd			  :	32;
+	} ii_wid_fld_s;
+} ii_wid_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  The fields in this register are set upon detection of an error      *
+ * and cleared by various mechanisms, as explained in the               *
+ * description.                                                         *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_wstat_u {
+	uint64_t	ii_wstat_regval;
+	struct	{
+		uint64_t	w_pending		  :	 4;
+		uint64_t	w_xt_crd_to		  :	 1;
+		uint64_t	w_xt_tail_to		  :	 1;
+		uint64_t	w_rsvd_3		  :	 3;
+		uint64_t       w_tx_mx_rty               :      1;
+		uint64_t	w_rsvd_2		  :	 6;
+		uint64_t	w_llp_tx_cnt		  :	 8;
+		uint64_t	w_rsvd_1		  :	 8;
+		uint64_t	w_crazy			  :	 1;
+		uint64_t	w_rsvd			  :	31;
+	} ii_wstat_fld_s;
+} ii_wstat_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  This is a read-write enabled register. It controls     *
+ * various aspects of the Crosstalk flow control.                       *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_wcr_u {
+	uint64_t	ii_wcr_regval;
+	struct	{
+		uint64_t	w_wid			  :	 4;
+		uint64_t	w_tag			  :	 1;
+		uint64_t	w_rsvd_1		  :	 8;
+		uint64_t	w_dst_crd		  :	 3;
+		uint64_t	w_f_bad_pkt		  :	 1;
+		uint64_t	w_dir_con		  :	 1;
+		uint64_t	w_e_thresh		  :	 5;
+		uint64_t	w_rsvd			  :	41;
+	} ii_wcr_fld_s;
+} ii_wcr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  This register's value is a bit vector that guards      *
+ * access to local registers within the II as well as to external       *
+ * Crosstalk widgets. Each bit in the register corresponds to a         *
+ * particular region in the system; a region consists of one, two or    *
+ * four nodes (depending on the value of the REGION_SIZE field in the   *
+ * LB_REV_ID register, which is documented in Section 8.3.1.1). The     *
+ * protection provided by this register applies to PIO read             *
+ * operations as well as PIO write operations. The II will perform a    *
+ * PIO read or write request only if the bit for the requestor's        *
+ * region is set; otherwise, the II will not perform the requested      *
+ * operation and will return an error response. When a PIO read or      *
+ * write request targets an external Crosstalk widget, then not only    *
+ * must the bit for the requestor's region be set in the ILAPR, but     *
+ * also the target widget's bit in the IOWA register must be set in     *
+ * order for the II to perform the requested operation; otherwise,      *
+ * the II will return an error response. Hence, the protection          *
+ * provided by the IOWA register supplements the protection provided    *
+ * by the ILAPR for requests that target external Crosstalk widgets.    *
+ * This register itself can be accessed only by the nodes whose         *
+ * region ID bits are enabled in this same register. It can also be     *
+ * accessed through the IAlias space by the local processors.           *
+ * The reset value of this register allows access by all nodes.         *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ilapr_u {
+	uint64_t	ii_ilapr_regval;
+	struct  {
+		uint64_t	i_region                  :	64;
+	} ii_ilapr_fld_s;
+} ii_ilapr_u_t;
+
+
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  A write to this register of the 64-bit value           *
+ * "SGIrules" in ASCII, will cause the bit in the ILAPR register        *
+ * corresponding to the region of the requestor to be set (allow        *
+ * access). A write of any other value will be ignored. Access          *
+ * protection for this register is "SGIrules".                          *
+ * This register can also be accessed through the IAlias space.         *
+ * However, this access will not change the access permissions in the   *
+ * ILAPR.                                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ilapo_u {
+	uint64_t	ii_ilapo_regval;
+	struct	{
+		uint64_t	i_io_ovrride            :	64;
+	} ii_ilapo_fld_s;
+} ii_ilapo_u_t;
+
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register qualifies all the PIO and Graphics writes launched    *
+ * from the SHUB towards a widget.                                      *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iowa_u {
+	uint64_t	ii_iowa_regval;
+	struct	{
+		uint64_t	i_w0_oac		  :	 1;
+		uint64_t	i_rsvd_1		  :	 7;
+                uint64_t       i_wx_oac                  :      8;
+		uint64_t	i_rsvd			  :	48;
+	} ii_iowa_fld_s;
+} ii_iowa_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  This register qualifies all the requests launched      *
+ * from a widget towards the Shub. This register is intended to be      *
+ * used by software in case of misbehaving widgets.                     *
+ *                                                                      *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iiwa_u {
+	uint64_t	ii_iiwa_regval;
+	struct  {
+		uint64_t	i_w0_iac                  :	 1;
+		uint64_t	i_rsvd_1		  :	 7;
+		uint64_t	i_wx_iac		  :	 8;
+		uint64_t	i_rsvd			  :	48;
+	} ii_iiwa_fld_s;
+} ii_iiwa_u_t;
+
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  This register qualifies all the operations launched    *
+ * from a widget towards the SHub. It allows individual access          *
+ * control for up to 8 devices per widget. A device refers to           *
+ * individual DMA master hosted by a widget.                            *
+ * The bits in each field of this register are cleared by the Shub      *
+ * upon detection of an error which requires the device to be           *
+ * disabled. These fields assume that 0=TNUM=7 (i.e., Bridge-centric    *
+ * Crosstalk). Whether or not a device has access rights to this        *
+ * Shub is determined by an AND of the device enable bit in the         *
+ * appropriate field of this register and the corresponding bit in      *
+ * the Wx_IAC field (for the widget which this device belongs to).      *
+ * The bits in this field are set by writing a 1 to them. Incoming      *
+ * replies from Crosstalk are not subject to this access control        *
+ * mechanism.                                                           *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iidem_u {
+	uint64_t	ii_iidem_regval;
+	struct	{
+		uint64_t	i_w8_dxs		  :	 8;
+		uint64_t	i_w9_dxs		  :	 8;
+		uint64_t	i_wa_dxs		  :	 8;
+		uint64_t	i_wb_dxs		  :	 8;
+		uint64_t	i_wc_dxs		  :	 8;
+		uint64_t	i_wd_dxs		  :	 8;
+		uint64_t	i_we_dxs		  :	 8;
+		uint64_t	i_wf_dxs		  :	 8;
+	} ii_iidem_fld_s;
+} ii_iidem_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the various programmable fields necessary    *
+ * for controlling and observing the LLP signals.                       *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ilcsr_u {
+	uint64_t	ii_ilcsr_regval;
+	struct  {
+		uint64_t	i_nullto                  :	 6;
+		uint64_t	i_rsvd_4		  :	 2;
+		uint64_t	i_wrmrst		  :	 1;
+		uint64_t	i_rsvd_3		  :	 1;
+		uint64_t	i_llp_en		  :	 1;
+		uint64_t	i_bm8			  :	 1;
+		uint64_t	i_llp_stat		  :	 2;
+		uint64_t	i_remote_power		  :	 1;
+		uint64_t	i_rsvd_2		  :	 1;
+		uint64_t	i_maxrtry		  :	10;
+		uint64_t	i_d_avail_sel		  :	 2;
+		uint64_t	i_rsvd_1		  :	 4;
+		uint64_t	i_maxbrst		  :	10;
+                uint64_t       i_rsvd                    :     22;
+
+	} ii_ilcsr_fld_s;
+} ii_ilcsr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This is simply a status registers that monitors the LLP error       *
+ * rate.                                                                *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_illr_u {
+	uint64_t	ii_illr_regval;
+	struct	{
+		uint64_t	i_sn_cnt		  :	16;
+		uint64_t	i_cb_cnt		  :	16;
+		uint64_t	i_rsvd			  :	32;
+	} ii_illr_fld_s;
+} ii_illr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  All II-detected non-BTE error interrupts are           *
+ * specified via this register.                                         *
+ * NOTE: The PI interrupt register address is hardcoded in the II. If   *
+ * PI_ID==0, then the II sends an interrupt request (Duplonet PWRI      *
+ * packet) to address offset 0x0180_0090 within the local register      *
+ * address space of PI0 on the node specified by the NODE field. If     *
+ * PI_ID==1, then the II sends the interrupt request to address         *
+ * offset 0x01A0_0090 within the local register address space of PI1    *
+ * on the node specified by the NODE field.                             *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iidsr_u {
+	uint64_t	ii_iidsr_regval;
+	struct  {
+		uint64_t	i_level                   :	 8;
+		uint64_t	i_pi_id			  :	 1;
+		uint64_t	i_node			  :	11;
+		uint64_t       i_rsvd_3                  :      4;
+		uint64_t	i_enable		  :	 1;
+		uint64_t	i_rsvd_2		  :	 3;
+		uint64_t	i_int_sent		  :	 2;
+		uint64_t       i_rsvd_1                  :      2;
+		uint64_t	i_pi0_forward_int	  :	 1;
+		uint64_t	i_pi1_forward_int	  :	 1;
+		uint64_t	i_rsvd			  :	30;
+	} ii_iidsr_fld_s;
+} ii_iidsr_u_t;
+
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are two instances of this register. This register is used     *
+ * for matching up the incoming responses from the graphics widget to   *
+ * the processor that initiated the graphics operation. The             *
+ * write-responses are converted to graphics credits and returned to    *
+ * the processor so that the processor interface can manage the flow    *
+ * control.                                                             *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_igfx0_u {
+	uint64_t	ii_igfx0_regval;
+	struct	{
+		uint64_t	i_w_num			  :	 4;
+		uint64_t       i_pi_id                   :      1;
+		uint64_t	i_n_num			  :	12;
+		uint64_t       i_p_num                   :      1;
+		uint64_t       i_rsvd                    :     46;
+	} ii_igfx0_fld_s;
+} ii_igfx0_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are two instances of this register. This register is used     *
+ * for matching up the incoming responses from the graphics widget to   *
+ * the processor that initiated the graphics operation. The             *
+ * write-responses are converted to graphics credits and returned to    *
+ * the processor so that the processor interface can manage the flow    *
+ * control.                                                             *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_igfx1_u {
+	uint64_t	ii_igfx1_regval;
+	struct  {
+		uint64_t	i_w_num			  :	 4;
+		uint64_t       i_pi_id                   :      1;
+		uint64_t	i_n_num			  :	12;
+		uint64_t       i_p_num                   :      1;
+		uint64_t       i_rsvd                    :     46;
+	} ii_igfx1_fld_s;
+} ii_igfx1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are two instances of this registers. These registers are      *
+ * used as scratch registers for software use.                          *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iscr0_u {
+	uint64_t	ii_iscr0_regval;
+	struct  {
+		uint64_t	i_scratch                 :	64;
+	} ii_iscr0_fld_s;
+} ii_iscr0_u_t;
+
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are two instances of this registers. These registers are      *
+ * used as scratch registers for software use.                          *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iscr1_u {
+	uint64_t	ii_iscr1_regval;
+	struct  {
+		uint64_t	i_scratch                 :	64;
+	} ii_iscr1_fld_s;
+} ii_iscr1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are seven instances of translation table entry   *
+ * registers. Each register maps a Shub Big Window to a 48-bit          *
+ * address on Crosstalk.                                                *
+ * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
+ * number) are used to select one of these 7 registers. The Widget      *
+ * number field is then derived from the W_NUM field for synthesizing   *
+ * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
+ * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
+ * are padded with zeros. Although the maximum Crosstalk space          *
+ * addressable by the SHub is thus the lower 16 GBytes per widget       * 
+ * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
+ * space can be accessed.                                               *
+ * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
+ * Window number) are used to select one of these 7 registers. The      *
+ * Widget number field is then derived from the W_NUM field for         *
+ * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
+ * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
+ * field is used as Crosstalk[47], and remainder of the Crosstalk       *
+ * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
+ * Crosstalk space addressable by the Shub is thus the lower            *
+ * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
+ * of this space can be accessed.                                       *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_itte1_u {
+	uint64_t	ii_itte1_regval;
+	struct  {
+		uint64_t	i_offset                  :	 5;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t	i_w_num			  :	 4;
+		uint64_t	i_iosp			  :	 1;
+		uint64_t	i_rsvd			  :	51;
+	} ii_itte1_fld_s;
+} ii_itte1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are seven instances of translation table entry   *
+ * registers. Each register maps a Shub Big Window to a 48-bit          *
+ * address on Crosstalk.                                                *
+ * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
+ * number) are used to select one of these 7 registers. The Widget      *
+ * number field is then derived from the W_NUM field for synthesizing   *
+ * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
+ * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
+ * are padded with zeros. Although the maximum Crosstalk space          *
+ * addressable by the Shub is thus the lower 16 GBytes per widget       *
+ * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
+ * space can be accessed.                                               *
+ * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
+ * Window number) are used to select one of these 7 registers. The      *
+ * Widget number field is then derived from the W_NUM field for         *
+ * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
+ * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
+ * field is used as Crosstalk[47], and remainder of the Crosstalk       *
+ * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
+ * Crosstalk space addressable by the Shub is thus the lower            *
+ * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
+ * of this space can be accessed.                                       *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_itte2_u {
+	uint64_t	ii_itte2_regval;
+	struct	{
+		uint64_t	i_offset		  :	 5;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t	i_w_num			  :	 4;
+		uint64_t	i_iosp			  :	 1;
+		uint64_t       i_rsvd                    :     51;
+	} ii_itte2_fld_s;
+} ii_itte2_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are seven instances of translation table entry   *
+ * registers. Each register maps a Shub Big Window to a 48-bit          *
+ * address on Crosstalk.                                                *
+ * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
+ * number) are used to select one of these 7 registers. The Widget      *
+ * number field is then derived from the W_NUM field for synthesizing   *
+ * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
+ * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
+ * are padded with zeros. Although the maximum Crosstalk space          *
+ * addressable by the Shub is thus the lower 16 GBytes per widget       *
+ * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
+ * space can be accessed.                                               *
+ * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
+ * Window number) are used to select one of these 7 registers. The      *
+ * Widget number field is then derived from the W_NUM field for         *
+ * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
+ * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
+ * field is used as Crosstalk[47], and remainder of the Crosstalk       *
+ * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
+ * Crosstalk space addressable by the SHub is thus the lower            *
+ * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
+ * of this space can be accessed.                                       *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_itte3_u {
+	uint64_t	ii_itte3_regval;
+	struct  {
+		uint64_t	i_offset                  :	 5;
+		uint64_t       i_rsvd_1                  :      3;
+		uint64_t       i_w_num                   :      4;
+		uint64_t       i_iosp                    :      1;
+		uint64_t       i_rsvd                    :     51;
+	} ii_itte3_fld_s;
+} ii_itte3_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are seven instances of translation table entry   *
+ * registers. Each register maps a SHub Big Window to a 48-bit          *
+ * address on Crosstalk.                                                *
+ * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
+ * number) are used to select one of these 7 registers. The Widget      *
+ * number field is then derived from the W_NUM field for synthesizing   *
+ * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
+ * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
+ * are padded with zeros. Although the maximum Crosstalk space          *
+ * addressable by the SHub is thus the lower 16 GBytes per widget       *
+ * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
+ * space can be accessed.                                               *
+ * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
+ * Window number) are used to select one of these 7 registers. The      *
+ * Widget number field is then derived from the W_NUM field for         *
+ * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
+ * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
+ * field is used as Crosstalk[47], and remainder of the Crosstalk       *
+ * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
+ * Crosstalk space addressable by the SHub is thus the lower            *
+ * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
+ * of this space can be accessed.                                       *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_itte4_u {
+	uint64_t	ii_itte4_regval;
+	struct  {
+		uint64_t	i_offset                  :	 5;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t       i_w_num                   :      4;
+		uint64_t       i_iosp                    :      1;
+		uint64_t       i_rsvd                    :     51;
+	} ii_itte4_fld_s;
+} ii_itte4_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are seven instances of translation table entry   *
+ * registers. Each register maps a SHub Big Window to a 48-bit          *
+ * address on Crosstalk.                                                *
+ * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
+ * number) are used to select one of these 7 registers. The Widget      *
+ * number field is then derived from the W_NUM field for synthesizing   *
+ * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
+ * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
+ * are padded with zeros. Although the maximum Crosstalk space          *
+ * addressable by the Shub is thus the lower 16 GBytes per widget       *
+ * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
+ * space can be accessed.                                               *
+ * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
+ * Window number) are used to select one of these 7 registers. The      *
+ * Widget number field is then derived from the W_NUM field for         *
+ * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
+ * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
+ * field is used as Crosstalk[47], and remainder of the Crosstalk       *
+ * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
+ * Crosstalk space addressable by the Shub is thus the lower            *
+ * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
+ * of this space can be accessed.                                       *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_itte5_u {
+	uint64_t	ii_itte5_regval;
+	struct  {
+		uint64_t	i_offset                  :	 5;
+		uint64_t       i_rsvd_1                  :      3;
+		uint64_t       i_w_num                   :      4;
+		uint64_t       i_iosp                    :      1;
+		uint64_t       i_rsvd                    :     51;
+	} ii_itte5_fld_s;
+} ii_itte5_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are seven instances of translation table entry   *
+ * registers. Each register maps a Shub Big Window to a 48-bit          *
+ * address on Crosstalk.                                                *
+ * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
+ * number) are used to select one of these 7 registers. The Widget      *
+ * number field is then derived from the W_NUM field for synthesizing   *
+ * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
+ * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
+ * are padded with zeros. Although the maximum Crosstalk space          *
+ * addressable by the Shub is thus the lower 16 GBytes per widget       *
+ * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
+ * space can be accessed.                                               *
+ * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
+ * Window number) are used to select one of these 7 registers. The      *
+ * Widget number field is then derived from the W_NUM field for         *
+ * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
+ * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
+ * field is used as Crosstalk[47], and remainder of the Crosstalk       *
+ * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
+ * Crosstalk space addressable by the Shub is thus the lower            *
+ * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
+ * of this space can be accessed.                                       *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_itte6_u {
+	uint64_t	ii_itte6_regval;
+	struct  {
+		uint64_t	i_offset                  :	 5;
+		uint64_t       i_rsvd_1                  :      3;
+		uint64_t       i_w_num                   :      4;
+		uint64_t       i_iosp                    :      1;
+		uint64_t       i_rsvd                    :     51;
+	} ii_itte6_fld_s;
+} ii_itte6_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are seven instances of translation table entry   *
+ * registers. Each register maps a Shub Big Window to a 48-bit          *
+ * address on Crosstalk.                                                *
+ * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
+ * number) are used to select one of these 7 registers. The Widget      *
+ * number field is then derived from the W_NUM field for synthesizing   *
+ * a Crosstalk packet. The 5 bits of OFFSET are concatenated with       *
+ * SysAD[28:0] to form Crosstalk[33:0]. The upper Crosstalk[47:34]      *
+ * are padded with zeros. Although the maximum Crosstalk space          *
+ * addressable by the Shub is thus the lower 16 GBytes per widget       *
+ * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
+ * space can be accessed.                                               *
+ * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
+ * Window number) are used to select one of these 7 registers. The      *
+ * Widget number field is then derived from the W_NUM field for         *
+ * synthesizing a Crosstalk packet. The 5 bits of OFFSET are            *
+ * concatenated with SysAD[27:0] to form Crosstalk[33:0]. The IOSP      *
+ * field is used as Crosstalk[47], and remainder of the Crosstalk       *
+ * address bits (Crosstalk[46:34]) are always zero. While the maximum   *
+ * Crosstalk space addressable by the SHub is thus the lower            *
+ * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
+ * of this space can be accessed.                                       *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_itte7_u {
+	uint64_t	ii_itte7_regval;
+	struct  {
+		uint64_t	i_offset                  :	 5;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t       i_w_num                   :      4;
+		uint64_t       i_iosp                    :      1;
+		uint64_t       i_rsvd                    :     51;
+	} ii_itte7_fld_s;
+} ii_itte7_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 9 instances of this register, one per        *
+ * actual widget in this implementation of SHub and Crossbow.           *
+ * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
+ * refers to Crossbow's internal space.                                 *
+ * This register contains the state elements per widget that are        *
+ * necessary to manage the PIO flow control on Crosstalk and on the     *
+ * Router Network. See the PIO Flow Control chapter for a complete      *
+ * description of this register                                         *
+ * The SPUR_WR bit requires some explanation. When this register is     *
+ * written, the new value of the C field is captured in an internal     *
+ * register so the hardware can remember what the programmer wrote      *
+ * into the credit counter. The SPUR_WR bit sets whenever the C field   *
+ * increments above this stored value, which indicates that there       *
+ * have been more responses received than requests sent. The SPUR_WR    *
+ * bit cannot be cleared until a value is written to the IPRBx          *
+ * register; the write will correct the C field and capture its new     *
+ * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
+ * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
+ * .                                                                    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprb0_u {
+	uint64_t	ii_iprb0_regval;
+	struct  {
+		uint64_t	i_c                       :	 8;
+		uint64_t	i_na			  :	14;
+		uint64_t       i_rsvd_2                  :      2;
+		uint64_t	i_nb			  :	14;
+		uint64_t	i_rsvd_1		  :	 2;
+		uint64_t	i_m			  :	 2;
+		uint64_t	i_f			  :	 1;
+		uint64_t	i_of_cnt		  :	 5;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_rd_to			  :	 1;
+		uint64_t	i_spur_wr		  :	 1;
+		uint64_t	i_spur_rd		  :	 1;
+		uint64_t	i_rsvd			  :	11;
+		uint64_t	i_mult_err		  :	 1;
+	} ii_iprb0_fld_s;
+} ii_iprb0_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 9 instances of this register, one per        *
+ * actual widget in this implementation of SHub and Crossbow.           *
+ * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
+ * refers to Crossbow's internal space.                                 *
+ * This register contains the state elements per widget that are        *
+ * necessary to manage the PIO flow control on Crosstalk and on the     *
+ * Router Network. See the PIO Flow Control chapter for a complete      *
+ * description of this register                                         *
+ * The SPUR_WR bit requires some explanation. When this register is     *
+ * written, the new value of the C field is captured in an internal     *
+ * register so the hardware can remember what the programmer wrote      *
+ * into the credit counter. The SPUR_WR bit sets whenever the C field   *
+ * increments above this stored value, which indicates that there       *
+ * have been more responses received than requests sent. The SPUR_WR    *
+ * bit cannot be cleared until a value is written to the IPRBx          *
+ * register; the write will correct the C field and capture its new     *
+ * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
+ * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
+ * .                                                                    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprb8_u {
+	uint64_t	ii_iprb8_regval;
+	struct  {
+		uint64_t	i_c                       :	 8;
+		uint64_t	i_na			  :	14;
+		uint64_t       i_rsvd_2                  :      2;
+		uint64_t	i_nb			  :	14;
+		uint64_t       i_rsvd_1                  :      2;
+		uint64_t       i_m                       :      2;
+		uint64_t       i_f                       :      1;
+		uint64_t       i_of_cnt                  :      5;
+		uint64_t       i_error                   :      1;
+		uint64_t       i_rd_to                   :      1;
+		uint64_t       i_spur_wr                 :      1;
+		uint64_t	i_spur_rd		  :	 1;
+		uint64_t       i_rsvd                    :     11;
+		uint64_t	i_mult_err		  :	 1;
+	} ii_iprb8_fld_s;
+} ii_iprb8_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 9 instances of this register, one per        *
+ * actual widget in this implementation of SHub and Crossbow.           *
+ * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
+ * refers to Crossbow's internal space.                                 *
+ * This register contains the state elements per widget that are        *
+ * necessary to manage the PIO flow control on Crosstalk and on the     *
+ * Router Network. See the PIO Flow Control chapter for a complete      *
+ * description of this register                                         *
+ * The SPUR_WR bit requires some explanation. When this register is     *
+ * written, the new value of the C field is captured in an internal     *
+ * register so the hardware can remember what the programmer wrote      *
+ * into the credit counter. The SPUR_WR bit sets whenever the C field   *
+ * increments above this stored value, which indicates that there       *
+ * have been more responses received than requests sent. The SPUR_WR    *
+ * bit cannot be cleared until a value is written to the IPRBx          *
+ * register; the write will correct the C field and capture its new     *
+ * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
+ * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
+ * .                                                                    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprb9_u {
+	uint64_t	ii_iprb9_regval;
+	struct	{
+		uint64_t	i_c			  :	 8;
+		uint64_t	i_na			  :	14;
+		uint64_t	i_rsvd_2		  :	 2;
+		uint64_t	i_nb			  :	14;
+		uint64_t	i_rsvd_1		  :	 2;
+		uint64_t	i_m			  :	 2;
+		uint64_t	i_f			  :	 1;
+		uint64_t	i_of_cnt		  :	 5;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_rd_to			  :	 1;
+		uint64_t	i_spur_wr		  :	 1;
+		uint64_t	i_spur_rd		  :	 1;
+		uint64_t	i_rsvd			  :	11;
+		uint64_t	i_mult_err		  :	 1;
+	} ii_iprb9_fld_s;
+} ii_iprb9_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 9 instances of this register, one per        *
+ * actual widget in this implementation of SHub and Crossbow.        *
+ * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
+ * refers to Crossbow's internal space.                                 *
+ * This register contains the state elements per widget that are        *
+ * necessary to manage the PIO flow control on Crosstalk and on the     *
+ * Router Network. See the PIO Flow Control chapter for a complete      *
+ * description of this register                                         *
+ * The SPUR_WR bit requires some explanation. When this register is     *
+ * written, the new value of the C field is captured in an internal     *
+ * register so the hardware can remember what the programmer wrote      *
+ * into the credit counter. The SPUR_WR bit sets whenever the C field   *
+ * increments above this stored value, which indicates that there       *
+ * have been more responses received than requests sent. The SPUR_WR    *
+ * bit cannot be cleared until a value is written to the IPRBx          *
+ * register; the write will correct the C field and capture its new     *
+ * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
+ * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
+ *                                                                      *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprba_u {
+	uint64_t	ii_iprba_regval;
+	struct  {
+		uint64_t	i_c                       :	 8;
+		uint64_t	i_na			  :	14;
+		uint64_t       i_rsvd_2                  :      2;
+		uint64_t	i_nb			  :	14;
+		uint64_t	i_rsvd_1		  :	 2;
+		uint64_t	i_m			  :	 2;
+		uint64_t	i_f			  :	 1;
+		uint64_t	i_of_cnt		  :	 5;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_rd_to			  :	 1;
+		uint64_t	i_spur_wr		  :	 1;
+		uint64_t	i_spur_rd		  :	 1;
+		uint64_t	i_rsvd			  :	11;
+		uint64_t	i_mult_err		  :	 1;
+	} ii_iprba_fld_s;
+} ii_iprba_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 9 instances of this register, one per        *
+ * actual widget in this implementation of SHub and Crossbow.           *
+ * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
+ * refers to Crossbow's internal space.                                 *
+ * This register contains the state elements per widget that are        *
+ * necessary to manage the PIO flow control on Crosstalk and on the     *
+ * Router Network. See the PIO Flow Control chapter for a complete      *
+ * description of this register                                         *
+ * The SPUR_WR bit requires some explanation. When this register is     *
+ * written, the new value of the C field is captured in an internal     *
+ * register so the hardware can remember what the programmer wrote      *
+ * into the credit counter. The SPUR_WR bit sets whenever the C field   *
+ * increments above this stored value, which indicates that there       *
+ * have been more responses received than requests sent. The SPUR_WR    *
+ * bit cannot be cleared until a value is written to the IPRBx          *
+ * register; the write will correct the C field and capture its new     *
+ * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
+ * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
+ * .                                                                    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprbb_u {
+	uint64_t	ii_iprbb_regval;
+	struct	{
+		uint64_t	i_c			  :	 8;
+		uint64_t	i_na			  :	14;
+		uint64_t	i_rsvd_2		  :	 2;
+		uint64_t	i_nb			  :	14;
+		uint64_t	i_rsvd_1		  :	 2;
+		uint64_t	i_m			  :	 2;
+		uint64_t	i_f			  :	 1;
+		uint64_t	i_of_cnt		  :	 5;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_rd_to			  :	 1;
+		uint64_t	i_spur_wr		  :	 1;
+		uint64_t	i_spur_rd		  :	 1;
+		uint64_t	i_rsvd			  :	11;
+		uint64_t	i_mult_err		  :	 1;
+	} ii_iprbb_fld_s;
+} ii_iprbb_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 9 instances of this register, one per        *
+ * actual widget in this implementation of SHub and Crossbow.           *
+ * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
+ * refers to Crossbow's internal space.                                 *
+ * This register contains the state elements per widget that are        *
+ * necessary to manage the PIO flow control on Crosstalk and on the     *
+ * Router Network. See the PIO Flow Control chapter for a complete      *
+ * description of this register                                         *
+ * The SPUR_WR bit requires some explanation. When this register is     *
+ * written, the new value of the C field is captured in an internal     *
+ * register so the hardware can remember what the programmer wrote      *
+ * into the credit counter. The SPUR_WR bit sets whenever the C field   *
+ * increments above this stored value, which indicates that there       *
+ * have been more responses received than requests sent. The SPUR_WR    *
+ * bit cannot be cleared until a value is written to the IPRBx          *
+ * register; the write will correct the C field and capture its new     *
+ * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
+ * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
+ * .                                                                    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprbc_u {
+	uint64_t	ii_iprbc_regval;
+	struct	{
+		uint64_t	i_c			  :	 8;
+		uint64_t	i_na			  :	14;
+		uint64_t	i_rsvd_2		  :	 2;
+		uint64_t	i_nb			  :	14;
+		uint64_t	i_rsvd_1		  :	 2;
+		uint64_t	i_m			  :	 2;
+		uint64_t	i_f			  :	 1;
+		uint64_t	i_of_cnt		  :	 5;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_rd_to			  :	 1;
+		uint64_t	i_spur_wr		  :	 1;
+		uint64_t	i_spur_rd		  :	 1;
+		uint64_t	i_rsvd			  :	11;
+		uint64_t	i_mult_err		  :	 1;
+	} ii_iprbc_fld_s;
+} ii_iprbc_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 9 instances of this register, one per        *
+ * actual widget in this implementation of SHub and Crossbow.           *
+ * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
+ * refers to Crossbow's internal space.                                 *
+ * This register contains the state elements per widget that are        *
+ * necessary to manage the PIO flow control on Crosstalk and on the     *
+ * Router Network. See the PIO Flow Control chapter for a complete      *
+ * description of this register                                         *
+ * The SPUR_WR bit requires some explanation. When this register is     *
+ * written, the new value of the C field is captured in an internal     *
+ * register so the hardware can remember what the programmer wrote      *
+ * into the credit counter. The SPUR_WR bit sets whenever the C field   *
+ * increments above this stored value, which indicates that there       *
+ * have been more responses received than requests sent. The SPUR_WR    *
+ * bit cannot be cleared until a value is written to the IPRBx          *
+ * register; the write will correct the C field and capture its new     *
+ * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
+ * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
+ * .                                                                    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprbd_u {
+	uint64_t	ii_iprbd_regval;
+	struct	{
+		uint64_t	i_c			  :	 8;
+		uint64_t	i_na			  :	14;
+		uint64_t	i_rsvd_2		  :	 2;
+		uint64_t	i_nb			  :	14;
+		uint64_t	i_rsvd_1		  :	 2;
+		uint64_t	i_m			  :	 2;
+		uint64_t	i_f			  :	 1;
+		uint64_t	i_of_cnt		  :	 5;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_rd_to			  :	 1;
+		uint64_t	i_spur_wr		  :	 1;
+		uint64_t	i_spur_rd		  :	 1;
+		uint64_t	i_rsvd			  :	11;
+		uint64_t	i_mult_err		  :	 1;
+	} ii_iprbd_fld_s;
+} ii_iprbd_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 9 instances of this register, one per        *
+ * actual widget in this implementation of SHub and Crossbow.           *
+ * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
+ * refers to Crossbow's internal space.                                 *
+ * This register contains the state elements per widget that are        *
+ * necessary to manage the PIO flow control on Crosstalk and on the     *
+ * Router Network. See the PIO Flow Control chapter for a complete      *
+ * description of this register                                         *
+ * The SPUR_WR bit requires some explanation. When this register is     *
+ * written, the new value of the C field is captured in an internal     *
+ * register so the hardware can remember what the programmer wrote      *
+ * into the credit counter. The SPUR_WR bit sets whenever the C field   *
+ * increments above this stored value, which indicates that there       *
+ * have been more responses received than requests sent. The SPUR_WR    *
+ * bit cannot be cleared until a value is written to the IPRBx          *
+ * register; the write will correct the C field and capture its new     *
+ * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
+ * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
+ * .                                                                    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprbe_u {
+	uint64_t	ii_iprbe_regval;
+	struct	{
+		uint64_t	i_c			  :	 8;
+		uint64_t	i_na			  :	14;
+		uint64_t	i_rsvd_2		  :	 2;
+		uint64_t	i_nb			  :	14;
+		uint64_t	i_rsvd_1		  :	 2;
+		uint64_t	i_m			  :	 2;
+		uint64_t	i_f			  :	 1;
+		uint64_t	i_of_cnt		  :	 5;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_rd_to			  :	 1;
+		uint64_t	i_spur_wr		  :	 1;
+		uint64_t	i_spur_rd		  :	 1;
+		uint64_t	i_rsvd			  :	11;
+		uint64_t	i_mult_err		  :	 1;
+	} ii_iprbe_fld_s;
+} ii_iprbe_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 9 instances of this register, one per        *
+ * actual widget in this implementation of Shub and Crossbow.           *
+ * Note: Crossbow only has ports for Widgets 8 through F, widget 0      *
+ * refers to Crossbow's internal space.                                 *
+ * This register contains the state elements per widget that are        *
+ * necessary to manage the PIO flow control on Crosstalk and on the     *
+ * Router Network. See the PIO Flow Control chapter for a complete      *
+ * description of this register                                         *
+ * The SPUR_WR bit requires some explanation. When this register is     *
+ * written, the new value of the C field is captured in an internal     *
+ * register so the hardware can remember what the programmer wrote      *
+ * into the credit counter. The SPUR_WR bit sets whenever the C field   *
+ * increments above this stored value, which indicates that there       *
+ * have been more responses received than requests sent. The SPUR_WR    *
+ * bit cannot be cleared until a value is written to the IPRBx          *
+ * register; the write will correct the C field and capture its new     *
+ * value in the internal register. Even if IECLR[E_PRB_x] is set, the   *
+ * SPUR_WR bit will persist if IPRBx hasn't yet been written.           *
+ * .                                                                    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprbf_u {
+        uint64_t       ii_iprbf_regval;
+        struct  {
+                uint64_t       i_c                       :      8;
+                uint64_t       i_na                      :     14;
+                uint64_t       i_rsvd_2                  :      2;
+                uint64_t       i_nb                      :     14;
+                uint64_t       i_rsvd_1                  :      2;
+                uint64_t       i_m                       :      2;
+                uint64_t       i_f                       :      1;
+                uint64_t       i_of_cnt                  :      5;
+                uint64_t       i_error                   :      1;
+                uint64_t       i_rd_to                   :      1;
+                uint64_t       i_spur_wr                 :      1;
+                uint64_t       i_spur_rd                 :      1;
+                uint64_t       i_rsvd                    :     11;
+                uint64_t       i_mult_err                :      1;
+        } ii_iprbe_fld_s;
+} ii_iprbf_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register specifies the timeout value to use for monitoring     *
+ * Crosstalk credits which are used outbound to Crosstalk. An           *
+ * internal counter called the Crosstalk Credit Timeout Counter         *
+ * increments every 128 II clocks. The counter starts counting          *
+ * anytime the credit count drops below a threshold, and resets to      *
+ * zero (stops counting) anytime the credit count is at or above the    *
+ * threshold. The threshold is 1 credit in direct connect mode and 2    *
+ * in Crossbow connect mode. When the internal Crosstalk Credit         *
+ * Timeout Counter reaches the value programmed in this register, a     *
+ * Crosstalk Credit Timeout has occurred. The internal counter is not   *
+ * readable from software, and stops counting at its maximum value,     *
+ * so it cannot cause more than one interrupt.                          *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ixcc_u {
+	uint64_t	ii_ixcc_regval;
+	struct  {
+		uint64_t	i_time_out                :	26;
+		uint64_t	i_rsvd			  :	38;
+	} ii_ixcc_fld_s;
+} ii_ixcc_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  This register qualifies all the PIO and DMA            *
+ * operations launched from widget 0 towards the SHub. In               *
+ * addition, it also qualifies accesses by the BTE streams.             *
+ * The bits in each field of this register are cleared by the SHub      *
+ * upon detection of an error which requires widget 0 or the BTE        *
+ * streams to be terminated. Whether or not widget x has access         *
+ * rights to this SHub is determined by an AND of the device            *
+ * enable bit in the appropriate field of this register and bit 0 in    *
+ * the Wx_IAC field. The bits in this field are set by writing a 1 to   *
+ * them. Incoming replies from Crosstalk are not subject to this        *
+ * access control mechanism.                                            *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_imem_u {
+	uint64_t	ii_imem_regval;
+	struct  {
+		uint64_t	i_w0_esd                  :	 1;
+		uint64_t	i_rsvd_3		  :	 3;
+		uint64_t	i_b0_esd		  :	 1;
+		uint64_t	i_rsvd_2		  :	 3;
+		uint64_t	i_b1_esd		  :	 1;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t	i_clr_precise		  :	 1;
+		uint64_t       i_rsvd                    :     51;
+	} ii_imem_fld_s;
+} ii_imem_u_t;
+
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  This register specifies the timeout value to use for   *
+ * monitoring Crosstalk tail flits coming into the Shub in the          *
+ * TAIL_TO field. An internal counter associated with this register     *
+ * is incremented every 128 II internal clocks (7 bits). The counter    *
+ * starts counting anytime a header micropacket is received and stops   *
+ * counting (and resets to zero) any time a micropacket with a Tail     *
+ * bit is received. Once the counter reaches the threshold value        *
+ * programmed in this register, it generates an interrupt to the        *
+ * processor that is programmed into the IIDSR. The counter saturates   *
+ * (does not roll over) at its maximum value, so it cannot cause        *
+ * another interrupt until after it is cleared.                         *
+ * The register also contains the Read Response Timeout values. The     *
+ * Prescalar is 23 bits, and counts II clocks. An internal counter      *
+ * increments on every II clock and when it reaches the value in the    *
+ * Prescalar field, all IPRTE registers with their valid bits set       *
+ * have their Read Response timers bumped. Whenever any of them match   *
+ * the value in the RRSP_TO field, a Read Response Timeout has          *
+ * occurred, and error handling occurs as described in the Error        *
+ * Handling section of this document.                                   *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ixtt_u {
+	uint64_t	ii_ixtt_regval;
+	struct  {
+		uint64_t	i_tail_to                 :	26;
+		uint64_t	i_rsvd_1		  :	 6;
+		uint64_t	i_rrsp_ps		  :	23;
+		uint64_t	i_rrsp_to		  :	 5;
+		uint64_t	i_rsvd			  :	 4;
+	} ii_ixtt_fld_s;
+} ii_ixtt_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  Writing a 1 to the fields of this register clears the appropriate   *
+ * error bits in other areas of SHub. Note that when the                *
+ * E_PRB_x bits are used to clear error bits in PRB registers,          *
+ * SPUR_RD and SPUR_WR may persist, because they require additional     *
+ * action to clear them. See the IPRBx and IXSS Register                *
+ * specifications.                                                      *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ieclr_u {
+	uint64_t	ii_ieclr_regval;
+	struct  {
+		uint64_t	i_e_prb_0                 :	 1;
+		uint64_t	i_rsvd			  :	 7;
+		uint64_t	i_e_prb_8		  :	 1;
+		uint64_t	i_e_prb_9		  :	 1;
+		uint64_t	i_e_prb_a		  :	 1;
+		uint64_t	i_e_prb_b		  :	 1;
+		uint64_t	i_e_prb_c		  :	 1;
+		uint64_t	i_e_prb_d		  :	 1;
+		uint64_t	i_e_prb_e		  :	 1;
+		uint64_t	i_e_prb_f		  :	 1;
+		uint64_t	i_e_crazy		  :	 1;
+		uint64_t	i_e_bte_0		  :	 1;
+		uint64_t	i_e_bte_1		  :	 1;
+		uint64_t	i_reserved_1		  :	10;
+		uint64_t	i_spur_rd_hdr		  :	 1;
+		uint64_t	i_cam_intr_to		  :	 1;
+		uint64_t	i_cam_overflow		  :	 1;
+		uint64_t	i_cam_read_miss		  :	 1;
+		uint64_t	i_ioq_rep_underflow	  :	 1;
+		uint64_t	i_ioq_req_underflow	  :	 1;
+		uint64_t	i_ioq_rep_overflow	  :	 1;
+		uint64_t	i_ioq_req_overflow	  :	 1;
+		uint64_t	i_iiq_rep_overflow	  :	 1;
+		uint64_t	i_iiq_req_overflow	  :	 1;
+		uint64_t	i_ii_xn_rep_cred_overflow :	 1;
+		uint64_t	i_ii_xn_req_cred_overflow :	 1;
+		uint64_t	i_ii_xn_invalid_cmd	  :	 1;
+		uint64_t	i_xn_ii_invalid_cmd	  :	 1;
+		uint64_t	i_reserved_2		  :	21;
+	} ii_ieclr_fld_s;
+} ii_ieclr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register controls both BTEs. SOFT_RESET is intended for        *
+ * recovery after an error. COUNT controls the total number of CRBs     *
+ * that both BTEs (combined) can use, which affects total BTE           *
+ * bandwidth.                                                           *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibcr_u {
+	uint64_t	ii_ibcr_regval;
+	struct  {
+		uint64_t	i_count                   :	 4;
+		uint64_t	i_rsvd_1		  :	 4;
+		uint64_t	i_soft_reset		  :	 1;
+		uint64_t	i_rsvd			  :	55;
+	} ii_ibcr_fld_s;
+} ii_ibcr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the header of a spurious read response       *
+ * received from Crosstalk. A spurious read response is defined as a    *
+ * read response received by II from a widget for which (1) the SIDN    *
+ * has a value between 1 and 7, inclusive (II never sends requests to   *
+ * these widgets (2) there is no valid IPRTE register which             *
+ * corresponds to the TNUM, or (3) the widget indicated in SIDN is      *
+ * not the same as the widget recorded in the IPRTE register            *
+ * referenced by the TNUM. If this condition is true, and if the        *
+ * IXSS[VALID] bit is clear, then the header of the spurious read       *
+ * response is capture in IXSM and IXSS, and IXSS[VALID] is set. The    *
+ * errant header is thereby captured, and no further spurious read      *
+ * respones are captured until IXSS[VALID] is cleared by setting the    *
+ * appropriate bit in IECLR.Everytime a spurious read response is       *
+ * detected, the SPUR_RD bit of the PRB corresponding to the incoming   *
+ * message's SIDN field is set. This always happens, regarless of       *
+ * whether a header is captured. The programmer should check            *
+ * IXSM[SIDN] to determine which widget sent the spurious response,     *
+ * because there may be more than one SPUR_RD bit set in the PRB        *
+ * registers. The widget indicated by IXSM[SIDN] was the first          *
+ * spurious read response to be received since the last time            *
+ * IXSS[VALID] was clear. The SPUR_RD bit of the corresponding PRB      *
+ * will be set. Any SPUR_RD bits in any other PRB registers indicate    *
+ * spurious messages from other widets which were detected after the    *
+ * header was captured..                                                *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ixsm_u {
+	uint64_t	ii_ixsm_regval;
+	struct  {
+		uint64_t	i_byte_en                 :	32;
+		uint64_t	i_reserved		  :	 1;
+		uint64_t	i_tag			  :	 3;
+		uint64_t	i_alt_pactyp		  :	 4;
+		uint64_t	i_bo			  :	 1;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_vbpm			  :	 1;
+		uint64_t	i_gbr			  :	 1;
+		uint64_t	i_ds			  :	 2;
+		uint64_t	i_ct			  :	 1;
+		uint64_t	i_tnum			  :	 5;
+		uint64_t	i_pactyp		  :	 4;
+		uint64_t	i_sidn			  :	 4;
+		uint64_t	i_didn			  :	 4;
+	} ii_ixsm_fld_s;
+} ii_ixsm_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the sideband bits of a spurious read         *
+ * response received from Crosstalk.                                    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ixss_u {
+	uint64_t	ii_ixss_regval;
+	struct  {
+		uint64_t	i_sideband                :	 8;
+		uint64_t	i_rsvd			  :	55;
+		uint64_t	i_valid			  :	 1;
+	} ii_ixss_fld_s;
+} ii_ixss_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register enables software to access the II LLP's test port.    *
+ * Refer to the LLP 2.5 documentation for an explanation of the test    *
+ * port. Software can write to this register to program the values      *
+ * for the control fields (TestErrCapture, TestClear, TestFlit,         *
+ * TestMask and TestSeed). Similarly, software can read from this       *
+ * register to obtain the values of the test port's status outputs      *
+ * (TestCBerr, TestValid and TestData).                                 *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ilct_u {
+	uint64_t	ii_ilct_regval;
+	struct  {
+		uint64_t	i_test_seed               :	20;
+		uint64_t	i_test_mask               :	 8;
+		uint64_t	i_test_data               :	20;
+		uint64_t	i_test_valid              :	 1;
+		uint64_t	i_test_cberr              :	 1;
+		uint64_t	i_test_flit               :	 3;
+		uint64_t	i_test_clear              :	 1;
+		uint64_t	i_test_err_capture        :	 1;
+		uint64_t	i_rsvd                    :	 9;
+	} ii_ilct_fld_s;
+} ii_ilct_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  If the II detects an illegal incoming Duplonet packet (request or   *
+ * reply) when VALID==0 in the IIEPH1 register, then it saves the       *
+ * contents of the packet's header flit in the IIEPH1 and IIEPH2        *
+ * registers, sets the VALID bit in IIEPH1, clears the OVERRUN bit,     *
+ * and assigns a value to the ERR_TYPE field which indicates the        *
+ * specific nature of the error. The II recognizes four different       *
+ * types of errors: short request packets (ERR_TYPE==2), short reply    *
+ * packets (ERR_TYPE==3), long request packets (ERR_TYPE==4) and long   *
+ * reply packets (ERR_TYPE==5). The encodings for these types of        *
+ * errors were chosen to be consistent with the same types of errors    *
+ * indicated by the ERR_TYPE field in the LB_ERROR_HDR1 register (in    *
+ * the LB unit). If the II detects an illegal incoming Duplonet         *
+ * packet when VALID==1 in the IIEPH1 register, then it merely sets     *
+ * the OVERRUN bit to indicate that a subsequent error has happened,    *
+ * and does nothing further.                                            *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iieph1_u {
+	uint64_t	ii_iieph1_regval;
+	struct	{
+		uint64_t	i_command		  :	 7;
+		uint64_t	i_rsvd_5		  :	 1;
+		uint64_t	i_suppl			  :	14;
+		uint64_t	i_rsvd_4		  :	 1;
+		uint64_t	i_source		  :	14;
+		uint64_t	i_rsvd_3		  :	 1;
+		uint64_t	i_err_type		  :	 4;
+		uint64_t	i_rsvd_2		  :	 4;
+		uint64_t	i_overrun		  :	 1;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t	i_valid			  :	 1;
+		uint64_t	i_rsvd			  :	13;
+	} ii_iieph1_fld_s;
+} ii_iieph1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register holds the Address field from the header flit of an    *
+ * incoming erroneous Duplonet packet, along with the tail bit which    *
+ * accompanied this header flit. This register is essentially an        *
+ * extension of IIEPH1. Two registers were necessary because the 64     *
+ * bits available in only a single register were insufficient to        *
+ * capture the entire header flit of an erroneous packet.               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iieph2_u {
+	uint64_t	ii_iieph2_regval;
+	struct  {
+		uint64_t	i_rsvd_0		  :	 3;
+		uint64_t	i_address                 :	47;
+		uint64_t	i_rsvd_1		  :	10;
+		uint64_t	i_tail			  :	 1;
+		uint64_t	i_rsvd			  :	 3;
+	} ii_iieph2_fld_s;
+} ii_iieph2_u_t;
+
+
+/******************************/
+
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register's value is a bit vector that guards access from SXBs  *
+ * to local registers within the II as well as to external Crosstalk    *
+ * widgets								*
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_islapr_u {
+	uint64_t	ii_islapr_regval;
+	struct  {
+		uint64_t	i_region		  :	64;
+	} ii_islapr_fld_s;
+} ii_islapr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  A write to this register of the 56-bit value "Pup+Bun" will cause	*
+ * the bit in the ISLAPR register corresponding to the region of the	*
+ * requestor to be set (access allowed).				(
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_islapo_u {
+	uint64_t	ii_islapo_regval;
+	struct  {
+		uint64_t	i_io_sbx_ovrride	  :	56;
+		uint64_t	i_rsvd			  :	 8;
+	} ii_islapo_fld_s;
+} ii_islapo_u_t;
+
+/************************************************************************
+ *                                                                      *
+ *  Determines how long the wrapper will wait aftr an interrupt is	*
+ * initially issued from the II before it times out the outstanding	*
+ * interrupt and drops it from the interrupt queue.			* 
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iwi_u {
+	uint64_t	ii_iwi_regval;
+	struct  {
+		uint64_t	i_prescale		  :	24;
+		uint64_t	i_rsvd			  :	 8;
+		uint64_t	i_timeout		  :	 8;
+		uint64_t	i_rsvd1			  :	 8;
+		uint64_t	i_intrpt_retry_period	  :	 8;
+		uint64_t	i_rsvd2			  :	 8;
+	} ii_iwi_fld_s;
+} ii_iwi_u_t;
+
+/************************************************************************
+ *                                                                      *
+ *  Log errors which have occurred in the II wrapper. The errors are	*
+ * cleared by writing to the IECLR register.				* 
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iwel_u {
+	uint64_t	ii_iwel_regval;
+	struct  {
+		uint64_t	i_intr_timed_out	  :	 1;
+		uint64_t	i_rsvd			  :	 7;
+		uint64_t	i_cam_overflow		  :	 1;
+		uint64_t	i_cam_read_miss		  :	 1;
+		uint64_t	i_rsvd1			  :	 2;
+		uint64_t	i_ioq_rep_underflow	  :	 1;
+		uint64_t	i_ioq_req_underflow	  :	 1;
+		uint64_t	i_ioq_rep_overflow	  :	 1;
+		uint64_t	i_ioq_req_overflow	  :	 1;
+		uint64_t	i_iiq_rep_overflow	  :	 1;
+		uint64_t	i_iiq_req_overflow	  :	 1;
+		uint64_t	i_rsvd2			  :	 6;
+		uint64_t	i_ii_xn_rep_cred_over_under:	 1;
+		uint64_t	i_ii_xn_req_cred_over_under:	 1;
+		uint64_t	i_rsvd3			  :	 6;
+		uint64_t	i_ii_xn_invalid_cmd	  :	 1;
+		uint64_t	i_xn_ii_invalid_cmd	  :	 1;
+		uint64_t	i_rsvd4			  :	30;
+	} ii_iwel_fld_s;
+} ii_iwel_u_t;
+
+/************************************************************************
+ *                                                                      *
+ *  Controls the II wrapper.						* 
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iwc_u {
+	uint64_t	ii_iwc_regval;
+	struct  {
+		uint64_t	i_dma_byte_swap		  :	 1;
+		uint64_t	i_rsvd			  :	 3;
+		uint64_t	i_cam_read_lines_reset	  :	 1;
+		uint64_t	i_rsvd1			  :	 3;
+		uint64_t	i_ii_xn_cred_over_under_log:	 1;
+		uint64_t	i_rsvd2			  :	19;
+		uint64_t	i_xn_rep_iq_depth	  :	 5;
+		uint64_t	i_rsvd3			  :	 3;
+		uint64_t	i_xn_req_iq_depth	  :	 5;
+		uint64_t	i_rsvd4			  :	 3;
+		uint64_t	i_iiq_depth		  :	 6;
+		uint64_t	i_rsvd5			  :	12;
+		uint64_t	i_force_rep_cred	  :	 1;
+		uint64_t	i_force_req_cred	  :	 1;
+	} ii_iwc_fld_s;
+} ii_iwc_u_t;
+
+/************************************************************************
+ *                                                                      *
+ *  Status in the II wrapper.						* 
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iws_u {
+	uint64_t	ii_iws_regval;
+	struct  {
+		uint64_t	i_xn_rep_iq_credits	  :	 5;
+		uint64_t	i_rsvd			  :	 3;
+		uint64_t	i_xn_req_iq_credits	  :	 5;
+		uint64_t	i_rsvd1			  :	51;
+	} ii_iws_fld_s;
+} ii_iws_u_t;
+
+/************************************************************************
+ *                                                                      *
+ *  Masks errors in the IWEL register.					*
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iweim_u {
+	uint64_t	ii_iweim_regval;
+	struct  {
+		uint64_t	i_intr_timed_out	  :	 1;
+		uint64_t	i_rsvd			  :	 7;
+		uint64_t	i_cam_overflow		  :	 1;
+		uint64_t	i_cam_read_miss		  :	 1;
+		uint64_t	i_rsvd1			  :	 2;
+		uint64_t	i_ioq_rep_underflow	  :	 1;
+		uint64_t	i_ioq_req_underflow	  :	 1;
+		uint64_t	i_ioq_rep_overflow	  :	 1;
+		uint64_t	i_ioq_req_overflow	  :	 1;
+		uint64_t	i_iiq_rep_overflow	  :	 1;
+		uint64_t	i_iiq_req_overflow	  :	 1;
+		uint64_t	i_rsvd2			  :	 6;
+		uint64_t	i_ii_xn_rep_cred_overflow :	 1;
+		uint64_t	i_ii_xn_req_cred_overflow :	 1;
+		uint64_t	i_rsvd3			  :	 6;
+		uint64_t	i_ii_xn_invalid_cmd	  :	 1;
+		uint64_t	i_xn_ii_invalid_cmd	  :	 1;
+		uint64_t	i_rsvd4			  :	30;
+	} ii_iweim_fld_s;
+} ii_iweim_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  A write to this register causes a particular field in the           *
+ * corresponding widget's PRB entry to be adjusted up or down by 1.     *
+ * This counter should be used when recovering from error and reset     *
+ * conditions. Note that software would be capable of causing           *
+ * inadvertent overflow or underflow of these counters.                 *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ipca_u {
+	uint64_t	ii_ipca_regval;
+	struct  {
+		uint64_t	i_wid                     :	 4;
+		uint64_t	i_adjust		  :	 1;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t	i_field			  :	 2;
+		uint64_t	i_rsvd			  :	54;
+	} ii_ipca_fld_s;
+} ii_ipca_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+
+typedef union ii_iprte0a_u {
+	uint64_t	ii_iprte0a_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	54;
+		uint64_t	i_widget		  :	 4;
+		uint64_t	i_to_cnt		  :	 5;
+		uint64_t       i_vld                     :      1;
+	} ii_iprte0a_fld_s;
+} ii_iprte0a_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte1a_u {
+	uint64_t	ii_iprte1a_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	54;
+		uint64_t	i_widget		  :	 4;
+		uint64_t	i_to_cnt		  :	 5;
+		uint64_t       i_vld                     :      1;
+	} ii_iprte1a_fld_s;
+} ii_iprte1a_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte2a_u {
+	uint64_t	ii_iprte2a_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	54;
+		uint64_t	i_widget		  :	 4;
+		uint64_t	i_to_cnt		  :	 5;
+		uint64_t       i_vld                     :      1;
+	} ii_iprte2a_fld_s;
+} ii_iprte2a_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte3a_u {
+	uint64_t	ii_iprte3a_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	54;
+		uint64_t	i_widget		  :	 4;
+		uint64_t	i_to_cnt		  :	 5;
+		uint64_t	i_vld			  :	 1;
+	} ii_iprte3a_fld_s;
+} ii_iprte3a_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte4a_u {
+	uint64_t	ii_iprte4a_regval;
+	struct	{
+		uint64_t	i_rsvd_1		  :	54;
+		uint64_t	i_widget		  :	 4;
+		uint64_t	i_to_cnt		  :	 5;
+		uint64_t	i_vld			  :	 1;
+	} ii_iprte4a_fld_s;
+} ii_iprte4a_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte5a_u {
+	uint64_t	ii_iprte5a_regval;
+	struct	{
+		uint64_t	i_rsvd_1		  :	54;
+		uint64_t	i_widget		  :	 4;
+		uint64_t	i_to_cnt		  :	 5;
+		uint64_t	i_vld			  :	 1;
+	} ii_iprte5a_fld_s;
+} ii_iprte5a_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte6a_u {
+	uint64_t	ii_iprte6a_regval;
+	struct	{
+		uint64_t	i_rsvd_1		  :	54;
+		uint64_t	i_widget		  :	 4;
+		uint64_t	i_to_cnt		  :	 5;
+		uint64_t	i_vld			  :	 1;
+	} ii_iprte6a_fld_s;
+} ii_iprte6a_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte7a_u {
+        uint64_t       ii_iprte7a_regval;
+        struct  {
+                uint64_t       i_rsvd_1                  :     54;
+                uint64_t       i_widget                  :      4;
+                uint64_t       i_to_cnt                  :      5;
+                uint64_t       i_vld                     :      1;
+        } ii_iprtea7_fld_s;
+} ii_iprte7a_u_t;
+
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+
+typedef union ii_iprte0b_u {
+	uint64_t	ii_iprte0b_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 3;
+		uint64_t	i_address		  :	47;
+		uint64_t	i_init			  :	 3;
+		uint64_t       i_source                  :     11;
+	} ii_iprte0b_fld_s;
+} ii_iprte0b_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte1b_u {
+	uint64_t	ii_iprte1b_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 3;
+		uint64_t	i_address		  :	47;
+		uint64_t	i_init			  :	 3;
+		uint64_t       i_source                  :     11;
+	} ii_iprte1b_fld_s;
+} ii_iprte1b_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte2b_u {
+	uint64_t	ii_iprte2b_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 3;
+		uint64_t	i_address		  :	47;
+		uint64_t	i_init			  :	 3;
+		uint64_t       i_source                  :     11;
+	} ii_iprte2b_fld_s;
+} ii_iprte2b_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte3b_u {
+	uint64_t	ii_iprte3b_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 3;
+		uint64_t	i_address		  :	47;
+		uint64_t	i_init			  :	 3;
+		uint64_t       i_source                  :     11;
+	} ii_iprte3b_fld_s;
+} ii_iprte3b_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte4b_u {
+	uint64_t	ii_iprte4b_regval;
+	struct	{
+		uint64_t	i_rsvd_1                  :	 3;
+		uint64_t	i_address		  :	47;
+		uint64_t	i_init			  :	 3;
+		uint64_t       i_source                  :     11;
+	} ii_iprte4b_fld_s;
+} ii_iprte4b_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte5b_u {
+	uint64_t	ii_iprte5b_regval;
+	struct	{
+		uint64_t	i_rsvd_1                  :	 3;
+		uint64_t	i_address		  :	47;
+		uint64_t	i_init			  :	 3;
+		uint64_t       i_source                  :     11;
+	} ii_iprte5b_fld_s;
+} ii_iprte5b_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte6b_u {
+	uint64_t	ii_iprte6b_regval;
+	struct	{
+		uint64_t	i_rsvd_1                  :	 3;
+		uint64_t	i_address		  :	47;
+		uint64_t	i_init			  :	 3;
+		uint64_t       i_source                  :     11;
+
+	} ii_iprte6b_fld_s;
+} ii_iprte6b_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  There are 8 instances of this register. This register contains      *
+ * the information that the II has to remember once it has launched a   *
+ * PIO Read operation. The contents are used to form the correct        *
+ * Router Network packet and direct the Crosstalk reply to the          *
+ * appropriate processor.                                               *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iprte7b_u {
+        uint64_t       ii_iprte7b_regval;
+        struct  {
+		uint64_t	i_rsvd_1                  :	 3;
+		uint64_t	i_address		  :	47;
+		uint64_t	i_init			  :	 3;
+		uint64_t       i_source                  :     11;
+        } ii_iprte7b_fld_s;
+} ii_iprte7b_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  SHub II contains a feature which did not exist in      *
+ * the Hub which automatically cleans up after a Read Response          *
+ * timeout, including deallocation of the IPRTE and recovery of IBuf    *
+ * space. The inclusion of this register in SHub is for backward        *
+ * compatibility                                                        *
+ * A write to this register causes an entry from the table of           *
+ * outstanding PIO Read Requests to be freed and returned to the        *
+ * stack of free entries. This register is used in handling the         *
+ * timeout errors that result in a PIO Reply never returning from       *
+ * Crosstalk.                                                           *
+ * Note that this register does not affect the contents of the IPRTE    *
+ * registers. The Valid bits in those registers have to be              *
+ * specifically turned off by software.                                 *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ipdr_u {
+	uint64_t	ii_ipdr_regval;
+	struct  {
+		uint64_t	i_te                      :	 3;
+		uint64_t	i_rsvd_1		  :	 1;
+		uint64_t	i_pnd			  :	 1;
+		uint64_t	i_init_rpcnt		  :	 1;
+		uint64_t	i_rsvd			  :	58;
+	} ii_ipdr_fld_s;
+} ii_ipdr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  A write to this register causes a CRB entry to be returned to the   *
+ * queue of free CRBs. The entry should have previously been cleared    *
+ * (mark bit) via backdoor access to the pertinent CRB entry. This      *
+ * register is used in the last step of handling the errors that are    *
+ * captured and marked in CRB entries.  Briefly: 1) first error for     *
+ * DMA write from a particular device, and first error for a            *
+ * particular BTE stream, lead to a marked CRB entry, and processor     *
+ * interrupt, 2) software reads the error information captured in the   *
+ * CRB entry, and presumably takes some corrective action, 3)           *
+ * software clears the mark bit, and finally 4) software writes to      *
+ * the ICDR register to return the CRB entry to the list of free CRB    *
+ * entries.                                                             *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icdr_u {
+	uint64_t	ii_icdr_regval;
+	struct  {
+		uint64_t	i_crb_num                 :	 4;
+		uint64_t	i_pnd			  :	 1;
+		uint64_t       i_rsvd                    :     59;
+	} ii_icdr_fld_s;
+} ii_icdr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register provides debug access to two FIFOs inside of II.      *
+ * Both IOQ_MAX* fields of this register contain the instantaneous      *
+ * depth (in units of the number of available entries) of the           *
+ * associated IOQ FIFO.  A read of this register will return the        *
+ * number of free entries on each FIFO at the time of the read.  So     *
+ * when a FIFO is idle, the associated field contains the maximum       *
+ * depth of the FIFO.  This register is writable for debug reasons      *
+ * and is intended to be written with the maximum desired FIFO depth    *
+ * while the FIFO is idle. Software must assure that II is idle when    *
+ * this register is written. If there are any active entries in any     *
+ * of these FIFOs when this register is written, the results are        *
+ * undefined.                                                           *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ifdr_u {
+	uint64_t	ii_ifdr_regval;
+	struct  {
+		uint64_t	i_ioq_max_rq              :	 7;
+		uint64_t	i_set_ioq_rq		  :	 1;
+		uint64_t	i_ioq_max_rp		  :	 7;
+		uint64_t	i_set_ioq_rp		  :	 1;
+		uint64_t	i_rsvd			  :	48;
+	} ii_ifdr_fld_s;
+} ii_ifdr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register allows the II to become sluggish in removing          *
+ * messages from its inbound queue (IIQ). This will cause messages to   *
+ * back up in either virtual channel. Disabling the "molasses" mode     *
+ * subsequently allows the II to be tested under stress. In the         *
+ * sluggish ("Molasses") mode, the localized effects of congestion      *
+ * can be observed.                                                     *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iiap_u {
+        uint64_t       ii_iiap_regval;
+        struct  {
+                uint64_t       i_rq_mls                  :      6;
+		uint64_t	i_rsvd_1		  :	 2;
+		uint64_t	i_rp_mls		  :	 6;
+		uint64_t       i_rsvd                    :     50;
+        } ii_iiap_fld_s;
+} ii_iiap_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register allows several parameters of CRB operation to be      *
+ * set. Note that writing to this register can have catastrophic side   *
+ * effects, if the CRB is not quiescent, i.e. if the CRB is             *
+ * processing protocol messages when the write occurs.                  *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icmr_u {
+	uint64_t	ii_icmr_regval;
+	struct  {
+		uint64_t	i_sp_msg                  :	 1;
+		uint64_t	i_rd_hdr		  :	 1;
+		uint64_t	i_rsvd_4		  :	 2;
+		uint64_t	i_c_cnt			  :	 4;
+		uint64_t	i_rsvd_3		  :	 4;
+		uint64_t	i_clr_rqpd		  :	 1;
+		uint64_t	i_clr_rppd		  :	 1;
+		uint64_t	i_rsvd_2		  :	 2;
+		uint64_t	i_fc_cnt		  :	 4;
+		uint64_t	i_crb_vld		  :	15;
+		uint64_t	i_crb_mark		  :	15;
+		uint64_t	i_rsvd_1		  :	 2;
+		uint64_t	i_precise		  :	 1;
+		uint64_t	i_rsvd			  :	11;
+	} ii_icmr_fld_s;
+} ii_icmr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register allows control of the table portion of the CRB        *
+ * logic via software. Control operations from this register have       *
+ * priority over all incoming Crosstalk or BTE requests.                *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_iccr_u {
+	uint64_t	ii_iccr_regval;
+	struct  {
+		uint64_t	i_crb_num                 :	 4;
+		uint64_t	i_rsvd_1		  :	 4;
+		uint64_t	i_cmd			  :	 8;
+		uint64_t	i_pending		  :	 1;
+		uint64_t	i_rsvd			  :	47;
+	} ii_iccr_fld_s;
+} ii_iccr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register allows the maximum timeout value to be programmed.    *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icto_u {
+	uint64_t	ii_icto_regval;
+	struct  {
+		uint64_t	i_timeout                 :	 8;
+		uint64_t	i_rsvd			  :	56;
+	} ii_icto_fld_s;
+} ii_icto_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register allows the timeout prescalar to be programmed. An     *
+ * internal counter is associated with this register. When the          *
+ * internal counter reaches the value of the PRESCALE field, the        *
+ * timer registers in all valid CRBs are incremented (CRBx_D[TIMEOUT]   *
+ * field). The internal counter resets to zero, and then continues      *
+ * counting.                                                            *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ictp_u {
+	uint64_t	ii_ictp_regval;
+	struct  {
+		uint64_t	i_prescale                :	24;
+		uint64_t	i_rsvd			  :	40;
+	} ii_ictp_fld_s;
+} ii_ictp_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
+ * used for Crosstalk operations (both cacheline and partial            *
+ * operations) or BTE/IO. Because the CRB entries are very wide, five   *
+ * registers (_A to _E) are required to read and write each entry.      *
+ * The CRB Entry registers can be conceptualized as rows and columns    *
+ * (illustrated in the table above). Each row contains the 4            *
+ * registers required for a single CRB Entry. The first doubleword      *
+ * (column) for each entry is labeled A, and the second doubleword      *
+ * (higher address) is labeled B, the third doubleword is labeled C,    *
+ * the fourth doubleword is labeled D and the fifth doubleword is       *
+ * labeled E. All CRB entries have their addresses on a quarter         *
+ * cacheline aligned boundary.                   *
+ * Upon reset, only the following fields are initialized: valid         *
+ * (VLD), priority count, timeout, timeout valid, and context valid.    *
+ * All other bits should be cleared by software before use (after       *
+ * recovering any potential error state from before the reset).         *
+ * The following four tables summarize the format for the four          *
+ * registers that are used for each ICRB# Entry.                        *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icrb0_a_u {
+	uint64_t	ii_icrb0_a_regval;
+	struct  {
+		uint64_t	ia_iow                    :	 1;
+		uint64_t	ia_vld			  :	 1;
+		uint64_t	ia_addr			  :	47;
+		uint64_t	ia_tnum			  :	 5;
+		uint64_t	ia_sidn			  :	 4;
+		uint64_t       ia_rsvd                   :      6;
+	} ii_icrb0_a_fld_s;
+} ii_icrb0_a_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
+ * used for Crosstalk operations (both cacheline and partial            *
+ * operations) or BTE/IO. Because the CRB entries are very wide, five   *
+ * registers (_A to _E) are required to read and write each entry.      *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icrb0_b_u {
+	uint64_t	ii_icrb0_b_regval;
+	struct	{
+		uint64_t	ib_xt_err		  :	 1;
+		uint64_t	ib_mark			  :	 1;
+		uint64_t	ib_ln_uce		  :	 1;
+		uint64_t	ib_errcode		  :	 3;
+		uint64_t	ib_error		  :	 1;
+		uint64_t	ib_stall__bte_1		  :	 1;
+		uint64_t	ib_stall__bte_0		  :	 1;
+		uint64_t	ib_stall__intr		  :	 1;
+		uint64_t	ib_stall_ib		  :	 1;
+		uint64_t	ib_intvn		  :	 1;
+		uint64_t	ib_wb			  :	 1;
+		uint64_t	ib_hold			  :	 1;
+		uint64_t	ib_ack			  :	 1;
+		uint64_t	ib_resp			  :	 1;
+		uint64_t	ib_ack_cnt		  :	11;
+		uint64_t	ib_rsvd			  :	 7;
+		uint64_t	ib_exc			  :	 5;
+		uint64_t	ib_init			  :	 3;
+		uint64_t	ib_imsg			  :	 8;
+		uint64_t	ib_imsgtype		  :	 2;
+		uint64_t	ib_use_old		  :	 1;
+		uint64_t	ib_rsvd_1		  :	11;
+	} ii_icrb0_b_fld_s;
+} ii_icrb0_b_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
+ * used for Crosstalk operations (both cacheline and partial            *
+ * operations) or BTE/IO. Because the CRB entries are very wide, five   *
+ * registers (_A to _E) are required to read and write each entry.      *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icrb0_c_u {
+	uint64_t	ii_icrb0_c_regval;
+	struct	{
+		uint64_t	ic_source		  :	15;
+		uint64_t	ic_size			  :	 2;
+		uint64_t	ic_ct			  :	 1;
+		uint64_t	ic_bte_num		  :	 1;
+		uint64_t	ic_gbr			  :	 1;
+		uint64_t	ic_resprqd		  :	 1;
+		uint64_t	ic_bo			  :	 1;
+		uint64_t	ic_suppl		  :	15;
+		uint64_t	ic_rsvd			  :	27;
+	} ii_icrb0_c_fld_s;
+} ii_icrb0_c_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
+ * used for Crosstalk operations (both cacheline and partial            *
+ * operations) or BTE/IO. Because the CRB entries are very wide, five   *
+ * registers (_A to _E) are required to read and write each entry.      *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icrb0_d_u {
+	uint64_t	ii_icrb0_d_regval;
+	struct  {
+		uint64_t	id_pa_be                  :	43;
+		uint64_t	id_bte_op		  :	 1;
+		uint64_t	id_pr_psc		  :	 4;
+		uint64_t	id_pr_cnt		  :	 4;
+		uint64_t	id_sleep		  :	 1;
+		uint64_t	id_rsvd			  :	11;
+	} ii_icrb0_d_fld_s;
+} ii_icrb0_d_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  There are 15 CRB Entries (ICRB0 to ICRBE) that are     *
+ * used for Crosstalk operations (both cacheline and partial            *
+ * operations) or BTE/IO. Because the CRB entries are very wide, five   *
+ * registers (_A to _E) are required to read and write each entry.      *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icrb0_e_u {
+	uint64_t	ii_icrb0_e_regval;
+	struct  {
+		uint64_t	ie_timeout                :	 8;
+		uint64_t	ie_context		  :	15;
+		uint64_t	ie_rsvd			  :	 1;
+		uint64_t	ie_tvld			  :	 1;
+		uint64_t	ie_cvld			  :	 1;
+		uint64_t	ie_rsvd_0		  :	38;
+	} ii_icrb0_e_fld_s;
+} ii_icrb0_e_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the lower 64 bits of the header of the       *
+ * spurious message captured by II. Valid when the SP_MSG bit in ICMR   *
+ * register is set.                                                     *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icsml_u {
+	uint64_t	ii_icsml_regval;
+	struct  {
+		uint64_t	i_tt_addr                 :	47;
+		uint64_t	i_newsuppl_ex		  :	14;
+		uint64_t	i_reserved		  :	 2;
+		uint64_t       i_overflow                :      1;
+	} ii_icsml_fld_s;
+} ii_icsml_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the middle 64 bits of the header of the      *
+ * spurious message captured by II. Valid when the SP_MSG bit in ICMR   *
+ * register is set.                                                     *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icsmm_u {
+	uint64_t	ii_icsmm_regval;
+	struct  {
+		uint64_t	i_tt_ack_cnt              :	11;
+		uint64_t	i_reserved		  :	53;
+	} ii_icsmm_fld_s;
+} ii_icsmm_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the microscopic state, all the inputs to     *
+ * the protocol table, captured with the spurious message. Valid when   *
+ * the SP_MSG bit in the ICMR register is set.                          *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_icsmh_u {
+	uint64_t	ii_icsmh_regval;
+	struct  {
+		uint64_t	i_tt_vld                  :	 1;
+		uint64_t	i_xerr			  :	 1;
+		uint64_t	i_ft_cwact_o		  :	 1;
+		uint64_t	i_ft_wact_o		  :	 1;
+		uint64_t       i_ft_active_o             :      1;
+		uint64_t	i_sync			  :	 1;
+		uint64_t	i_mnusg			  :	 1;
+		uint64_t	i_mnusz			  :	 1;
+		uint64_t	i_plusz			  :	 1;
+		uint64_t	i_plusg			  :	 1;
+		uint64_t	i_tt_exc		  :	 5;
+		uint64_t	i_tt_wb			  :	 1;
+		uint64_t	i_tt_hold		  :	 1;
+		uint64_t	i_tt_ack		  :	 1;
+		uint64_t	i_tt_resp		  :	 1;
+		uint64_t	i_tt_intvn		  :	 1;
+		uint64_t	i_g_stall_bte1		  :	 1;
+		uint64_t	i_g_stall_bte0		  :	 1;
+		uint64_t	i_g_stall_il		  :	 1;
+		uint64_t	i_g_stall_ib		  :	 1;
+		uint64_t	i_tt_imsg		  :	 8;
+		uint64_t	i_tt_imsgtype		  :	 2;
+		uint64_t	i_tt_use_old		  :	 1;
+		uint64_t	i_tt_respreqd		  :	 1;
+		uint64_t	i_tt_bte_num		  :	 1;
+		uint64_t	i_cbn			  :	 1;
+		uint64_t	i_match			  :	 1;
+		uint64_t	i_rpcnt_lt_34		  :	 1;
+		uint64_t	i_rpcnt_ge_34		  :	 1;
+		uint64_t	i_rpcnt_lt_18		  :	 1;
+		uint64_t	i_rpcnt_ge_18		  :	 1;
+		uint64_t       i_rpcnt_lt_2              :      1;
+		uint64_t	i_rpcnt_ge_2		  :	 1;
+		uint64_t	i_rqcnt_lt_18		  :	 1;
+		uint64_t	i_rqcnt_ge_18		  :	 1;
+		uint64_t	i_rqcnt_lt_2		  :	 1;
+		uint64_t	i_rqcnt_ge_2		  :	 1;
+		uint64_t	i_tt_device		  :	 7;
+		uint64_t	i_tt_init		  :	 3;
+		uint64_t	i_reserved		  :	 5;
+	} ii_icsmh_fld_s;
+} ii_icsmh_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  The Shub DEBUG unit provides a 3-bit selection signal to the        *
+ * II core and a 3-bit selection signal to the fsbclk domain in the II  *
+ * wrapper.                                                             *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_idbss_u {
+	uint64_t	ii_idbss_regval;
+	struct  {
+		uint64_t	i_iioclk_core_submenu     :	 3;
+		uint64_t	i_rsvd			  :	 5;
+		uint64_t	i_fsbclk_wrapper_submenu  :	 3;
+		uint64_t	i_rsvd_1		  :	 5;
+		uint64_t	i_iioclk_menu		  :	 5;
+		uint64_t	i_rsvd_2		  :	43;
+	} ii_idbss_fld_s;
+} ii_idbss_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  This register is used to set up the length for a       *
+ * transfer and then to monitor the progress of that transfer. This     *
+ * register needs to be initialized before a transfer is started. A     *
+ * legitimate write to this register will set the Busy bit, clear the   *
+ * Error bit, and initialize the length to the value desired.           *
+ * While the transfer is in progress, hardware will decrement the       *
+ * length field with each successful block that is copied. Once the     *
+ * transfer completes, hardware will clear the Busy bit. The length     *
+ * field will also contain the number of cache lines left to be         *
+ * transferred.                                                         *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibls0_u {
+	uint64_t	ii_ibls0_regval;
+	struct	{
+		uint64_t	i_length		  :	16;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t	i_busy			  :	 1;
+		uint64_t       i_rsvd                    :     43;
+	} ii_ibls0_fld_s;
+} ii_ibls0_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register should be loaded before a transfer is started. The    *
+ * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
+ * address as described in Section 1.3, Figure2 and Figure3. Since      *
+ * the bottom 7 bits of the address are always taken to be zero, BTE    *
+ * transfers are always cacheline-aligned.                              *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibsa0_u {
+	uint64_t	ii_ibsa0_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 7;
+		uint64_t	i_addr			  :	42;
+		uint64_t       i_rsvd                    :     15;
+	} ii_ibsa0_fld_s;
+} ii_ibsa0_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register should be loaded before a transfer is started. The    *
+ * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
+ * address as described in Section 1.3, Figure2 and Figure3. Since      *
+ * the bottom 7 bits of the address are always taken to be zero, BTE    *
+ * transfers are always cacheline-aligned.                              *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibda0_u {
+	uint64_t	ii_ibda0_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 7;
+		uint64_t	i_addr			  :	42;
+		uint64_t	i_rsvd			  :	15;
+	} ii_ibda0_fld_s;
+} ii_ibda0_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  Writing to this register sets up the attributes of the transfer     *
+ * and initiates the transfer operation. Reading this register has      *
+ * the side effect of terminating any transfer in progress. Note:       *
+ * stopping a transfer midstream could have an adverse impact on the    *
+ * other BTE. If a BTE stream has to be stopped (due to error           *
+ * handling for example), both BTE streams should be stopped and        *
+ * their transfers discarded.                                           *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibct0_u {
+	uint64_t	ii_ibct0_regval;
+	struct  {
+		uint64_t	i_zerofill                :	 1;
+		uint64_t	i_rsvd_2		  :	 3;
+		uint64_t	i_notify		  :	 1;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t       i_poison                  :      1;
+		uint64_t       i_rsvd                    :     55;
+	} ii_ibct0_fld_s;
+} ii_ibct0_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the address to which the WINV is sent.       *
+ * This address has to be cache line aligned.                           *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibna0_u {
+	uint64_t	ii_ibna0_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 7;
+		uint64_t	i_addr			  :	42;
+		uint64_t	i_rsvd			  :	15;
+	} ii_ibna0_fld_s;
+} ii_ibna0_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the programmable level as well as the node   *
+ * ID and PI unit of the processor to which the interrupt will be       *
+ * sent.                                                                *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibia0_u {
+	uint64_t	ii_ibia0_regval;
+	struct  {
+		uint64_t	i_rsvd_2                   :	 1;
+		uint64_t	i_node_id		  :	11;
+		uint64_t	i_rsvd_1		  :	 4;
+		uint64_t	i_level			  :	 7;
+		uint64_t       i_rsvd                    :     41;
+	} ii_ibia0_fld_s;
+} ii_ibia0_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ * Description:  This register is used to set up the length for a       *
+ * transfer and then to monitor the progress of that transfer. This     *
+ * register needs to be initialized before a transfer is started. A     *
+ * legitimate write to this register will set the Busy bit, clear the   *
+ * Error bit, and initialize the length to the value desired.           *
+ * While the transfer is in progress, hardware will decrement the       *
+ * length field with each successful block that is copied. Once the     *
+ * transfer completes, hardware will clear the Busy bit. The length     *
+ * field will also contain the number of cache lines left to be         *
+ * transferred.                                                         *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibls1_u {
+	uint64_t	ii_ibls1_regval;
+	struct  {
+		uint64_t	i_length                  :	16;
+		uint64_t	i_error			  :	 1;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t	i_busy			  :	 1;
+		uint64_t       i_rsvd                    :     43;
+	} ii_ibls1_fld_s;
+} ii_ibls1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register should be loaded before a transfer is started. The    *
+ * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
+ * address as described in Section 1.3, Figure2 and Figure3. Since      *
+ * the bottom 7 bits of the address are always taken to be zero, BTE    *
+ * transfers are always cacheline-aligned.                              *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibsa1_u {
+	uint64_t	ii_ibsa1_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 7;
+		uint64_t	i_addr			  :	33;
+		uint64_t	i_rsvd			  :	24;
+	} ii_ibsa1_fld_s;
+} ii_ibsa1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register should be loaded before a transfer is started. The    *
+ * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
+ * address as described in Section 1.3, Figure2 and Figure3. Since      *
+ * the bottom 7 bits of the address are always taken to be zero, BTE    *
+ * transfers are always cacheline-aligned.                              *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibda1_u {
+	uint64_t	ii_ibda1_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 7;
+		uint64_t	i_addr			  :	33;
+		uint64_t	i_rsvd			  :	24;
+	} ii_ibda1_fld_s;
+} ii_ibda1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  Writing to this register sets up the attributes of the transfer     *
+ * and initiates the transfer operation. Reading this register has      *
+ * the side effect of terminating any transfer in progress. Note:       *
+ * stopping a transfer midstream could have an adverse impact on the    *
+ * other BTE. If a BTE stream has to be stopped (due to error           *
+ * handling for example), both BTE streams should be stopped and        *
+ * their transfers discarded.                                           *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibct1_u {
+	uint64_t	ii_ibct1_regval;
+	struct  {
+		uint64_t	i_zerofill                :	 1;
+		uint64_t	i_rsvd_2		  :	 3;
+		uint64_t	i_notify		  :	 1;
+		uint64_t	i_rsvd_1		  :	 3;
+		uint64_t	i_poison		  :	 1;
+		uint64_t	i_rsvd			  :	55;
+	} ii_ibct1_fld_s;
+} ii_ibct1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the address to which the WINV is sent.       *
+ * This address has to be cache line aligned.                           *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibna1_u {
+	uint64_t	ii_ibna1_regval;
+	struct  {
+		uint64_t	i_rsvd_1                  :	 7;
+		uint64_t	i_addr			  :	33;
+		uint64_t       i_rsvd                    :     24;
+	} ii_ibna1_fld_s;
+} ii_ibna1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register contains the programmable level as well as the node   *
+ * ID and PI unit of the processor to which the interrupt will be       *
+ * sent.                                                                *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ibia1_u {
+	uint64_t	ii_ibia1_regval;
+	struct  {
+		uint64_t	i_pi_id                   :	 1;
+		uint64_t	i_node_id		  :	 8;
+		uint64_t	i_rsvd_1		  :	 7;
+		uint64_t	i_level			  :	 7;
+		uint64_t	i_rsvd			  :	41;
+	} ii_ibia1_fld_s;
+} ii_ibia1_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *  This register defines the resources that feed information into      *
+ * the two performance counters located in the IO Performance           *
+ * Profiling Register. There are 17 different quantities that can be    *
+ * measured. Given these 17 different options, the two performance      *
+ * counters have 15 of them in common; menu selections 0 through 0xE    *
+ * are identical for each performance counter. As for the other two     *
+ * options, one is available from one performance counter and the       *
+ * other is available from the other performance counter. Hence, the    *
+ * II supports all 17*16=272 possible combinations of quantities to     *
+ * measure.                                                             *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ipcr_u {
+	uint64_t	ii_ipcr_regval;
+	struct  {
+		uint64_t	i_ippr0_c                 :	 4;
+		uint64_t	i_ippr1_c		  :	 4;
+		uint64_t	i_icct			  :	 8;
+		uint64_t       i_rsvd                    :     48;
+	} ii_ipcr_fld_s;
+} ii_ipcr_u_t;
+
+
+/************************************************************************
+ *                                                                      *
+ *                                                                      *
+ *                                                                      *
+ ************************************************************************/
+
+typedef union ii_ippr_u {
+	uint64_t	ii_ippr_regval;
+	struct  {
+		uint64_t	i_ippr0                   :	32;
+		uint64_t	i_ippr1			  :	32;
+	} ii_ippr_fld_s;
+} ii_ippr_u_t;
+
+
+
+/**************************************************************************
+ *                                                                        *
+ * The following defines which were not formed into structures are        *
+ * probably indentical to another register, and the name of the           *
+ * register is provided against each of these registers. This             *
+ * information needs to be checked carefully                              *
+ *                                                                        *
+ *           IIO_ICRB1_A                IIO_ICRB0_A                       *
+ *           IIO_ICRB1_B                IIO_ICRB0_B                       *
+ *           IIO_ICRB1_C                IIO_ICRB0_C                       *
+ *           IIO_ICRB1_D                IIO_ICRB0_D                       *
+ *           IIO_ICRB1_E                IIO_ICRB0_E                       *
+ *           IIO_ICRB2_A                IIO_ICRB0_A                       *
+ *           IIO_ICRB2_B                IIO_ICRB0_B                       *
+ *           IIO_ICRB2_C                IIO_ICRB0_C                       *
+ *           IIO_ICRB2_D                IIO_ICRB0_D                       *
+ *           IIO_ICRB2_E                IIO_ICRB0_E                       *
+ *           IIO_ICRB3_A                IIO_ICRB0_A                       *
+ *           IIO_ICRB3_B                IIO_ICRB0_B                       *
+ *           IIO_ICRB3_C                IIO_ICRB0_C                       *
+ *           IIO_ICRB3_D                IIO_ICRB0_D                       *
+ *           IIO_ICRB3_E                IIO_ICRB0_E                       *
+ *           IIO_ICRB4_A                IIO_ICRB0_A                       *
+ *           IIO_ICRB4_B                IIO_ICRB0_B                       *
+ *           IIO_ICRB4_C                IIO_ICRB0_C                       *
+ *           IIO_ICRB4_D                IIO_ICRB0_D                       *
+ *           IIO_ICRB4_E                IIO_ICRB0_E                       *
+ *           IIO_ICRB5_A                IIO_ICRB0_A                       *
+ *           IIO_ICRB5_B                IIO_ICRB0_B                       *
+ *           IIO_ICRB5_C                IIO_ICRB0_C                       *
+ *           IIO_ICRB5_D                IIO_ICRB0_D                       *
+ *           IIO_ICRB5_E                IIO_ICRB0_E                       *
+ *           IIO_ICRB6_A                IIO_ICRB0_A                       *
+ *           IIO_ICRB6_B                IIO_ICRB0_B                       *
+ *           IIO_ICRB6_C                IIO_ICRB0_C                       *
+ *           IIO_ICRB6_D                IIO_ICRB0_D                       *
+ *           IIO_ICRB6_E                IIO_ICRB0_E                       *
+ *           IIO_ICRB7_A                IIO_ICRB0_A                       *
+ *           IIO_ICRB7_B                IIO_ICRB0_B                       *
+ *           IIO_ICRB7_C                IIO_ICRB0_C                       *
+ *           IIO_ICRB7_D                IIO_ICRB0_D                       *
+ *           IIO_ICRB7_E                IIO_ICRB0_E                       *
+ *           IIO_ICRB8_A                IIO_ICRB0_A                       *
+ *           IIO_ICRB8_B                IIO_ICRB0_B                       *
+ *           IIO_ICRB8_C                IIO_ICRB0_C                       *
+ *           IIO_ICRB8_D                IIO_ICRB0_D                       *
+ *           IIO_ICRB8_E                IIO_ICRB0_E                       *
+ *           IIO_ICRB9_A                IIO_ICRB0_A                       *
+ *           IIO_ICRB9_B                IIO_ICRB0_B                       *
+ *           IIO_ICRB9_C                IIO_ICRB0_C                       *
+ *           IIO_ICRB9_D                IIO_ICRB0_D                       *
+ *           IIO_ICRB9_E                IIO_ICRB0_E                       *
+ *           IIO_ICRBA_A                IIO_ICRB0_A                       *
+ *           IIO_ICRBA_B                IIO_ICRB0_B                       *
+ *           IIO_ICRBA_C                IIO_ICRB0_C                       *
+ *           IIO_ICRBA_D                IIO_ICRB0_D                       *
+ *           IIO_ICRBA_E                IIO_ICRB0_E                       *
+ *           IIO_ICRBB_A                IIO_ICRB0_A                       *
+ *           IIO_ICRBB_B                IIO_ICRB0_B                       *
+ *           IIO_ICRBB_C                IIO_ICRB0_C                       *
+ *           IIO_ICRBB_D                IIO_ICRB0_D                       *
+ *           IIO_ICRBB_E                IIO_ICRB0_E                       *
+ *           IIO_ICRBC_A                IIO_ICRB0_A                       *
+ *           IIO_ICRBC_B                IIO_ICRB0_B                       *
+ *           IIO_ICRBC_C                IIO_ICRB0_C                       *
+ *           IIO_ICRBC_D                IIO_ICRB0_D                       *
+ *           IIO_ICRBC_E                IIO_ICRB0_E                       *
+ *           IIO_ICRBD_A                IIO_ICRB0_A                       *
+ *           IIO_ICRBD_B                IIO_ICRB0_B                       *
+ *           IIO_ICRBD_C                IIO_ICRB0_C                       *
+ *           IIO_ICRBD_D                IIO_ICRB0_D                       *
+ *           IIO_ICRBD_E                IIO_ICRB0_E                       *
+ *           IIO_ICRBE_A                IIO_ICRB0_A                       *
+ *           IIO_ICRBE_B                IIO_ICRB0_B                       *
+ *           IIO_ICRBE_C                IIO_ICRB0_C                       *
+ *           IIO_ICRBE_D                IIO_ICRB0_D                       *
+ *           IIO_ICRBE_E                IIO_ICRB0_E                       *
+ *                                                                        *
+ **************************************************************************/
+
+
+/*
+ * Slightly friendlier names for some common registers.
+ */
+#define IIO_WIDGET              IIO_WID      /* Widget identification */
+#define IIO_WIDGET_STAT         IIO_WSTAT    /* Widget status register */
+#define IIO_WIDGET_CTRL         IIO_WCR      /* Widget control register */
+#define IIO_PROTECT             IIO_ILAPR    /* IO interface protection */
+#define IIO_PROTECT_OVRRD       IIO_ILAPO    /* IO protect override */
+#define IIO_OUTWIDGET_ACCESS    IIO_IOWA     /* Outbound widget access */
+#define IIO_INWIDGET_ACCESS     IIO_IIWA     /* Inbound widget access */
+#define IIO_INDEV_ERR_MASK      IIO_IIDEM    /* Inbound device error mask */
+#define IIO_LLP_CSR             IIO_ILCSR    /* LLP control and status */
+#define IIO_LLP_LOG             IIO_ILLR     /* LLP log */
+#define IIO_XTALKCC_TOUT        IIO_IXCC     /* Xtalk credit count timeout*/
+#define IIO_XTALKTT_TOUT        IIO_IXTT     /* Xtalk tail timeout */
+#define IIO_IO_ERR_CLR          IIO_IECLR    /* IO error clear */
+#define IIO_IGFX_0 		IIO_IGFX0
+#define IIO_IGFX_1 		IIO_IGFX1
+#define IIO_IBCT_0		IIO_IBCT0
+#define IIO_IBCT_1		IIO_IBCT1
+#define IIO_IBLS_0		IIO_IBLS0
+#define IIO_IBLS_1		IIO_IBLS1
+#define IIO_IBSA_0		IIO_IBSA0
+#define IIO_IBSA_1		IIO_IBSA1
+#define IIO_IBDA_0		IIO_IBDA0
+#define IIO_IBDA_1		IIO_IBDA1
+#define IIO_IBNA_0		IIO_IBNA0
+#define IIO_IBNA_1		IIO_IBNA1
+#define IIO_IBIA_0		IIO_IBIA0
+#define IIO_IBIA_1		IIO_IBIA1
+#define IIO_IOPRB_0		IIO_IPRB0
+
+#define IIO_PRTE_A(_x)		(IIO_IPRTE0_A + (8 * (_x)))
+#define IIO_PRTE_B(_x)		(IIO_IPRTE0_B + (8 * (_x)))
+#define IIO_NUM_PRTES		8	/* Total number of PRB table entries */
+#define IIO_WIDPRTE_A(x)	IIO_PRTE_A(((x) - 8)) /* widget ID to its PRTE num */
+#define IIO_WIDPRTE_B(x)	IIO_PRTE_B(((x) - 8)) /* widget ID to its PRTE num */
+
+#define IIO_NUM_IPRBS 		(9) 
+
+#define IIO_LLP_CSR_IS_UP               0x00002000
+#define IIO_LLP_CSR_LLP_STAT_MASK       0x00003000
+#define IIO_LLP_CSR_LLP_STAT_SHFT       12
+
+#define IIO_LLP_CB_MAX  0xffff	/* in ILLR CB_CNT, Max Check Bit errors */
+#define IIO_LLP_SN_MAX  0xffff	/* in ILLR SN_CNT, Max Sequence Number errors */
+
+/* key to IIO_PROTECT_OVRRD */
+#define IIO_PROTECT_OVRRD_KEY   0x53474972756c6573ull   /* "SGIrules" */
+
+/* BTE register names */
+#define IIO_BTE_STAT_0          IIO_IBLS_0   /* Also BTE length/status 0 */
+#define IIO_BTE_SRC_0           IIO_IBSA_0   /* Also BTE source address  0 */
+#define IIO_BTE_DEST_0          IIO_IBDA_0   /* Also BTE dest. address 0 */
+#define IIO_BTE_CTRL_0          IIO_IBCT_0   /* Also BTE control/terminate 0 */
+#define IIO_BTE_NOTIFY_0        IIO_IBNA_0   /* Also BTE notification 0 */
+#define IIO_BTE_INT_0           IIO_IBIA_0   /* Also BTE interrupt 0 */
+#define IIO_BTE_OFF_0           0            /* Base offset from BTE 0 regs. */
+#define IIO_BTE_OFF_1   	(IIO_IBLS_1 - IIO_IBLS_0) /* Offset from base to BTE 1 */
+
+/* BTE register offsets from base */
+#define BTEOFF_STAT             0
+#define BTEOFF_SRC              (IIO_BTE_SRC_0 - IIO_BTE_STAT_0)
+#define BTEOFF_DEST             (IIO_BTE_DEST_0 - IIO_BTE_STAT_0)
+#define BTEOFF_CTRL             (IIO_BTE_CTRL_0 - IIO_BTE_STAT_0)
+#define BTEOFF_NOTIFY           (IIO_BTE_NOTIFY_0 - IIO_BTE_STAT_0)
+#define BTEOFF_INT              (IIO_BTE_INT_0 - IIO_BTE_STAT_0)
+
+
+/* names used in shub diags */
+#define IIO_BASE_BTE0   IIO_IBLS_0		
+#define IIO_BASE_BTE1   IIO_IBLS_1		
+
+/*
+ * Macro which takes the widget number, and returns the
+ * IO PRB address of that widget.
+ * value _x is expected to be a widget number in the range
+ * 0, 8 - 0xF
+ */
+#define IIO_IOPRB(_x)   (IIO_IOPRB_0 + ( ( (_x) < HUB_WIDGET_ID_MIN ? \
+                        (_x) : \
+                        (_x) - (HUB_WIDGET_ID_MIN-1)) << 3) )
+
+
+/* GFX Flow Control Node/Widget Register */
+#define IIO_IGFX_W_NUM_BITS	4	/* size of widget num field */
+#define IIO_IGFX_W_NUM_MASK	((1<<IIO_IGFX_W_NUM_BITS)-1)
+#define IIO_IGFX_W_NUM_SHIFT	0
+#define IIO_IGFX_PI_NUM_BITS	1	/* size of PI num field */
+#define IIO_IGFX_PI_NUM_MASK	((1<<IIO_IGFX_PI_NUM_BITS)-1)
+#define IIO_IGFX_PI_NUM_SHIFT	4
+#define IIO_IGFX_N_NUM_BITS	8	/* size of node num field */
+#define IIO_IGFX_N_NUM_MASK	((1<<IIO_IGFX_N_NUM_BITS)-1)
+#define IIO_IGFX_N_NUM_SHIFT	5
+#define IIO_IGFX_P_NUM_BITS	1	/* size of processor num field */
+#define IIO_IGFX_P_NUM_MASK	((1<<IIO_IGFX_P_NUM_BITS)-1)
+#define IIO_IGFX_P_NUM_SHIFT	16
+#define IIO_IGFX_INIT(widget, pi, node, cpu)				(\
+	(((widget) & IIO_IGFX_W_NUM_MASK) << IIO_IGFX_W_NUM_SHIFT) |	 \
+	(((pi)     & IIO_IGFX_PI_NUM_MASK)<< IIO_IGFX_PI_NUM_SHIFT)|	 \
+	(((node)   & IIO_IGFX_N_NUM_MASK) << IIO_IGFX_N_NUM_SHIFT) |	 \
+	(((cpu)    & IIO_IGFX_P_NUM_MASK) << IIO_IGFX_P_NUM_SHIFT))
+
+
+/* Scratch registers (all bits available) */
+#define IIO_SCRATCH_REG0        IIO_ISCR0
+#define IIO_SCRATCH_REG1        IIO_ISCR1
+#define IIO_SCRATCH_MASK        0xffffffffffffffffUL
+
+#define IIO_SCRATCH_BIT0_0      0x0000000000000001UL
+#define IIO_SCRATCH_BIT0_1      0x0000000000000002UL
+#define IIO_SCRATCH_BIT0_2      0x0000000000000004UL
+#define IIO_SCRATCH_BIT0_3      0x0000000000000008UL
+#define IIO_SCRATCH_BIT0_4      0x0000000000000010UL
+#define IIO_SCRATCH_BIT0_5      0x0000000000000020UL
+#define IIO_SCRATCH_BIT0_6      0x0000000000000040UL
+#define IIO_SCRATCH_BIT0_7      0x0000000000000080UL
+#define IIO_SCRATCH_BIT0_8      0x0000000000000100UL
+#define IIO_SCRATCH_BIT0_9      0x0000000000000200UL
+#define IIO_SCRATCH_BIT0_A      0x0000000000000400UL
+
+#define IIO_SCRATCH_BIT1_0      0x0000000000000001UL
+#define IIO_SCRATCH_BIT1_1      0x0000000000000002UL
+/* IO Translation Table Entries */
+#define IIO_NUM_ITTES   7               /* ITTEs numbered 0..6 */
+                                        /* Hw manuals number them 1..7! */
+/*
+ * IIO_IMEM Register fields.
+ */
+#define IIO_IMEM_W0ESD  0x1UL             /* Widget 0 shut down due to error */
+#define IIO_IMEM_B0ESD  (1UL << 4)        /* BTE 0 shut down due to error */
+#define IIO_IMEM_B1ESD  (1UL << 8)        /* BTE 1 Shut down due to error */
+
+/*
+ * As a permanent workaround for a bug in the PI side of the shub, we've
+ * redefined big window 7 as small window 0.
+ XXX does this still apply for SN1??
+ */
+#define HUB_NUM_BIG_WINDOW      (IIO_NUM_ITTES - 1)
+
+/*
+ * Use the top big window as a surrogate for the first small window
+ */
+#define SWIN0_BIGWIN            HUB_NUM_BIG_WINDOW
+
+#define ILCSR_WARM_RESET        0x100
+
+/*
+ * CRB manipulation macros
+ *      The CRB macros are slightly complicated, since there are up to
+ *      four registers associated with each CRB entry.
+ */
+#define IIO_NUM_CRBS            15      /* Number of CRBs */
+#define IIO_NUM_PC_CRBS         4       /* Number of partial cache CRBs */
+#define IIO_ICRB_OFFSET         8
+#define IIO_ICRB_0              IIO_ICRB0_A
+#define IIO_ICRB_ADDR_SHFT	2	/* Shift to get proper address */
+/* XXX - This is now tuneable:
+        #define IIO_FIRST_PC_ENTRY 12
+ */
+
+#define IIO_ICRB_A(_x)  ((u64)(IIO_ICRB_0 + (6 * IIO_ICRB_OFFSET * (_x))))
+#define IIO_ICRB_B(_x)  ((u64)((char *)IIO_ICRB_A(_x) + 1*IIO_ICRB_OFFSET))
+#define IIO_ICRB_C(_x)  ((u64)((char *)IIO_ICRB_A(_x) + 2*IIO_ICRB_OFFSET))
+#define IIO_ICRB_D(_x)  ((u64)((char *)IIO_ICRB_A(_x) + 3*IIO_ICRB_OFFSET))
+#define IIO_ICRB_E(_x)  ((u64)((char *)IIO_ICRB_A(_x) + 4*IIO_ICRB_OFFSET))
+
+#define TNUM_TO_WIDGET_DEV(_tnum)	(_tnum & 0x7)
+
+/*
+ * values for "ecode" field
+ */
+#define IIO_ICRB_ECODE_DERR     0       /* Directory error due to IIO access */
+#define IIO_ICRB_ECODE_PERR     1       /* Poison error on IO access */
+#define IIO_ICRB_ECODE_WERR     2       /* Write error by IIO access
+                                         * e.g. WINV to a Read only line. */
+#define IIO_ICRB_ECODE_AERR     3       /* Access error caused by IIO access */
+#define IIO_ICRB_ECODE_PWERR    4       /* Error on partial write       */
+#define IIO_ICRB_ECODE_PRERR    5       /* Error on partial read        */
+#define IIO_ICRB_ECODE_TOUT     6       /* CRB timeout before deallocating */
+#define IIO_ICRB_ECODE_XTERR    7       /* Incoming xtalk pkt had error bit */
+
+/*
+ * Values for field imsgtype
+ */
+#define IIO_ICRB_IMSGT_XTALK    0       /* Incoming Meessage from Xtalk */
+#define IIO_ICRB_IMSGT_BTE      1       /* Incoming message from BTE    */
+#define IIO_ICRB_IMSGT_SN1NET   2       /* Incoming message from SN1 net */
+#define IIO_ICRB_IMSGT_CRB      3       /* Incoming message from CRB ???  */
+
+/*
+ * values for field initiator.
+ */
+#define IIO_ICRB_INIT_XTALK     0       /* Message originated in xtalk  */
+#define IIO_ICRB_INIT_BTE0      0x1     /* Message originated in BTE 0  */
+#define IIO_ICRB_INIT_SN1NET    0x2     /* Message originated in SN1net */
+#define IIO_ICRB_INIT_CRB       0x3     /* Message originated in CRB ?  */
+#define IIO_ICRB_INIT_BTE1      0x5     /* MEssage originated in BTE 1  */
+
+/*
+ * Number of credits Hub widget has while sending req/response to
+ * xbow.
+ * Value of 3 is required by Xbow 1.1
+ * We may be able to increase this to 4 with Xbow 1.2.
+ */
+#define       HUBII_XBOW_CREDIT       3
+#define       HUBII_XBOW_REV2_CREDIT  4
+
+/*
+ * Number of credits that xtalk devices should use when communicating
+ * with a SHub (depth of SHub's queue).
+ */
+#define HUB_CREDIT 4
+
+/*
+ * Some IIO_PRB fields
+ */
+#define IIO_PRB_MULTI_ERR	(1LL << 63)
+#define IIO_PRB_SPUR_RD		(1LL << 51)
+#define IIO_PRB_SPUR_WR		(1LL << 50)
+#define IIO_PRB_RD_TO		(1LL << 49)
+#define IIO_PRB_ERROR		(1LL << 48)
+
+/*************************************************************************
+
+ Some of the IIO field masks and shifts are defined here.
+ This is in order to maintain compatibility in SN0 and SN1 code
+ 
+**************************************************************************/
+
+/*
+ * ICMR register fields
+ * (Note: the IIO_ICMR_P_CNT and IIO_ICMR_PC_VLD from Hub are not
+ * present in SHub)
+ */
+
+#define IIO_ICMR_CRB_VLD_SHFT   20
+#define IIO_ICMR_CRB_VLD_MASK   (0x7fffUL << IIO_ICMR_CRB_VLD_SHFT)
+
+#define IIO_ICMR_FC_CNT_SHFT    16
+#define IIO_ICMR_FC_CNT_MASK    (0xf << IIO_ICMR_FC_CNT_SHFT)
+
+#define IIO_ICMR_C_CNT_SHFT     4
+#define IIO_ICMR_C_CNT_MASK     (0xf << IIO_ICMR_C_CNT_SHFT)
+
+#define IIO_ICMR_PRECISE        (1UL << 52)
+#define IIO_ICMR_CLR_RPPD       (1UL << 13)
+#define IIO_ICMR_CLR_RQPD       (1UL << 12)
+
+/*
+ * IIO PIO Deallocation register field masks : (IIO_IPDR)
+ XXX present but not needed in bedrock?  See the manual.
+ */
+#define IIO_IPDR_PND    (1 << 4)
+
+/*
+ * IIO CRB deallocation register field masks: (IIO_ICDR)
+ */
+#define IIO_ICDR_PND    (1 << 4)
+
+/* 
+ * IO BTE Length/Status (IIO_IBLS) register bit field definitions
+ */
+#define IBLS_BUSY		(0x1UL << 20)
+#define IBLS_ERROR_SHFT		16
+#define IBLS_ERROR		(0x1UL << IBLS_ERROR_SHFT)
+#define IBLS_LENGTH_MASK	0xffff
+
+/*
+ * IO BTE Control/Terminate register (IBCT) register bit field definitions
+ */
+#define IBCT_POISON		(0x1UL << 8)
+#define IBCT_NOTIFY		(0x1UL << 4)
+#define IBCT_ZFIL_MODE		(0x1UL << 0)
+
+/*
+ * IIO Incoming Error Packet Header (IIO_IIEPH1/IIO_IIEPH2)
+ */
+#define IIEPH1_VALID		(1UL << 44)
+#define IIEPH1_OVERRUN		(1UL << 40)
+#define IIEPH1_ERR_TYPE_SHFT	32
+#define IIEPH1_ERR_TYPE_MASK	0xf
+#define IIEPH1_SOURCE_SHFT	20
+#define IIEPH1_SOURCE_MASK	11
+#define IIEPH1_SUPPL_SHFT	8
+#define IIEPH1_SUPPL_MASK	11
+#define IIEPH1_CMD_SHFT		0
+#define IIEPH1_CMD_MASK		7
+
+#define IIEPH2_TAIL		(1UL << 40)
+#define IIEPH2_ADDRESS_SHFT	0
+#define IIEPH2_ADDRESS_MASK	38
+
+#define IIEPH1_ERR_SHORT_REQ	2
+#define IIEPH1_ERR_SHORT_REPLY	3
+#define IIEPH1_ERR_LONG_REQ	4
+#define IIEPH1_ERR_LONG_REPLY	5
+
+/*
+ * IO Error Clear register bit field definitions
+ */
+#define IECLR_PI1_FWD_INT	(1UL << 31)  /* clear PI1_FORWARD_INT in iidsr */
+#define IECLR_PI0_FWD_INT	(1UL << 30)  /* clear PI0_FORWARD_INT in iidsr */
+#define IECLR_SPUR_RD_HDR	(1UL << 29)  /* clear valid bit in ixss reg */
+#define IECLR_BTE1		(1UL << 18)  /* clear bte error 1 */
+#define IECLR_BTE0		(1UL << 17)  /* clear bte error 0 */
+#define IECLR_CRAZY		(1UL << 16)  /* clear crazy bit in wstat reg */
+#define IECLR_PRB_F		(1UL << 15)  /* clear err bit in PRB_F reg */
+#define IECLR_PRB_E		(1UL << 14)  /* clear err bit in PRB_E reg */
+#define IECLR_PRB_D		(1UL << 13)  /* clear err bit in PRB_D reg */
+#define IECLR_PRB_C		(1UL << 12)  /* clear err bit in PRB_C reg */
+#define IECLR_PRB_B		(1UL << 11)  /* clear err bit in PRB_B reg */
+#define IECLR_PRB_A		(1UL << 10)  /* clear err bit in PRB_A reg */
+#define IECLR_PRB_9		(1UL << 9)   /* clear err bit in PRB_9 reg */
+#define IECLR_PRB_8		(1UL << 8)   /* clear err bit in PRB_8 reg */
+#define IECLR_PRB_0		(1UL << 0)   /* clear err bit in PRB_0 reg */
+
+/*
+ * IIO CRB control register Fields: IIO_ICCR 
+ */
+#define	IIO_ICCR_PENDING	(0x10000)
+#define	IIO_ICCR_CMD_MASK	(0xFF)
+#define	IIO_ICCR_CMD_SHFT	(7)
+#define	IIO_ICCR_CMD_NOP	(0x0)	/* No Op */
+#define	IIO_ICCR_CMD_WAKE	(0x100) /* Reactivate CRB entry and process */
+#define	IIO_ICCR_CMD_TIMEOUT	(0x200)	/* Make CRB timeout & mark invalid */
+#define	IIO_ICCR_CMD_EJECT	(0x400)	/* Contents of entry written to memory 
+					 * via a WB
+					 */
+#define	IIO_ICCR_CMD_FLUSH	(0x800)
+
+/*
+ *
+ * CRB Register description.
+ *
+ * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
+ * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
+ * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
+ * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
+ * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING * WARNING
+ *
+ * Many of the fields in CRB are status bits used by hardware
+ * for implementation of the protocol. It's very dangerous to
+ * mess around with the CRB registers.
+ *
+ * It's OK to read the CRB registers and try to make sense out of the
+ * fields in CRB.
+ *
+ * Updating CRB requires all activities in Hub IIO to be quiesced.
+ * otherwise, a write to CRB could corrupt other CRB entries.
+ * CRBs are here only as a back door peek to shub IIO's status.
+ * Quiescing implies  no dmas no PIOs
+ * either directly from the cpu or from sn0net.
+ * this is not something that can be done easily. So, AVOID updating
+ * CRBs.
+ */
+
+/*
+ * Easy access macros for CRBs, all 5 registers (A-E)
+ */
+typedef ii_icrb0_a_u_t icrba_t;
+#define a_sidn          ii_icrb0_a_fld_s.ia_sidn
+#define a_tnum          ii_icrb0_a_fld_s.ia_tnum
+#define a_addr          ii_icrb0_a_fld_s.ia_addr
+#define a_valid         ii_icrb0_a_fld_s.ia_vld
+#define a_iow           ii_icrb0_a_fld_s.ia_iow
+#define a_regvalue	ii_icrb0_a_regval
+
+typedef ii_icrb0_b_u_t icrbb_t;
+#define b_use_old       ii_icrb0_b_fld_s.ib_use_old
+#define b_imsgtype      ii_icrb0_b_fld_s.ib_imsgtype
+#define b_imsg          ii_icrb0_b_fld_s.ib_imsg
+#define b_initiator     ii_icrb0_b_fld_s.ib_init
+#define b_exc           ii_icrb0_b_fld_s.ib_exc
+#define b_ackcnt        ii_icrb0_b_fld_s.ib_ack_cnt
+#define b_resp          ii_icrb0_b_fld_s.ib_resp
+#define b_ack           ii_icrb0_b_fld_s.ib_ack
+#define b_hold          ii_icrb0_b_fld_s.ib_hold
+#define b_wb            ii_icrb0_b_fld_s.ib_wb
+#define b_intvn         ii_icrb0_b_fld_s.ib_intvn
+#define b_stall_ib      ii_icrb0_b_fld_s.ib_stall_ib
+#define b_stall_int     ii_icrb0_b_fld_s.ib_stall__intr
+#define b_stall_bte_0   ii_icrb0_b_fld_s.ib_stall__bte_0
+#define b_stall_bte_1   ii_icrb0_b_fld_s.ib_stall__bte_1
+#define b_error         ii_icrb0_b_fld_s.ib_error
+#define b_ecode         ii_icrb0_b_fld_s.ib_errcode
+#define b_lnetuce       ii_icrb0_b_fld_s.ib_ln_uce
+#define b_mark          ii_icrb0_b_fld_s.ib_mark
+#define b_xerr          ii_icrb0_b_fld_s.ib_xt_err
+#define b_regvalue	ii_icrb0_b_regval
+
+typedef ii_icrb0_c_u_t icrbc_t;
+#define c_suppl         ii_icrb0_c_fld_s.ic_suppl
+#define c_barrop        ii_icrb0_c_fld_s.ic_bo
+#define c_doresp        ii_icrb0_c_fld_s.ic_resprqd
+#define c_gbr           ii_icrb0_c_fld_s.ic_gbr
+#define c_btenum        ii_icrb0_c_fld_s.ic_bte_num
+#define c_cohtrans      ii_icrb0_c_fld_s.ic_ct
+#define c_xtsize        ii_icrb0_c_fld_s.ic_size
+#define c_source        ii_icrb0_c_fld_s.ic_source
+#define c_regvalue	ii_icrb0_c_regval
+
+
+typedef ii_icrb0_d_u_t icrbd_t;
+#define d_sleep         ii_icrb0_d_fld_s.id_sleep
+#define d_pricnt        ii_icrb0_d_fld_s.id_pr_cnt
+#define d_pripsc        ii_icrb0_d_fld_s.id_pr_psc
+#define d_bteop         ii_icrb0_d_fld_s.id_bte_op
+#define d_bteaddr       ii_icrb0_d_fld_s.id_pa_be /* ic_pa_be fld has 2 names*/
+#define d_benable       ii_icrb0_d_fld_s.id_pa_be /* ic_pa_be fld has 2 names*/
+#define d_regvalue	ii_icrb0_d_regval
+
+typedef ii_icrb0_e_u_t icrbe_t;
+#define icrbe_ctxtvld   ii_icrb0_e_fld_s.ie_cvld
+#define icrbe_toutvld   ii_icrb0_e_fld_s.ie_tvld
+#define icrbe_context   ii_icrb0_e_fld_s.ie_context
+#define icrbe_timeout   ii_icrb0_e_fld_s.ie_timeout
+#define e_regvalue	ii_icrb0_e_regval
+
+
+/* Number of widgets supported by shub */
+#define HUB_NUM_WIDGET          9
+#define HUB_WIDGET_ID_MIN       0x8
+#define HUB_WIDGET_ID_MAX       0xf
+
+#define HUB_WIDGET_PART_NUM     0xc120
+#define MAX_HUBS_PER_XBOW       2
+
+/* A few more #defines for backwards compatibility */
+#define iprb_t          ii_iprb0_u_t
+#define iprb_regval     ii_iprb0_regval
+#define iprb_mult_err	ii_iprb0_fld_s.i_mult_err
+#define iprb_spur_rd	ii_iprb0_fld_s.i_spur_rd
+#define iprb_spur_wr	ii_iprb0_fld_s.i_spur_wr
+#define iprb_rd_to	ii_iprb0_fld_s.i_rd_to
+#define iprb_ovflow     ii_iprb0_fld_s.i_of_cnt
+#define iprb_error      ii_iprb0_fld_s.i_error
+#define iprb_ff         ii_iprb0_fld_s.i_f
+#define iprb_mode       ii_iprb0_fld_s.i_m
+#define iprb_bnakctr    ii_iprb0_fld_s.i_nb
+#define iprb_anakctr    ii_iprb0_fld_s.i_na
+#define iprb_xtalkctr   ii_iprb0_fld_s.i_c
+
+#define LNK_STAT_WORKING        0x2		/* LLP is working */
+
+#define IIO_WSTAT_ECRAZY        (1ULL << 32)    /* Hub gone crazy */
+#define IIO_WSTAT_TXRETRY       (1ULL << 9)     /* Hub Tx Retry timeout */
+#define IIO_WSTAT_TXRETRY_MASK  (0x7F)   /* should be 0xFF?? */
+#define IIO_WSTAT_TXRETRY_SHFT  (16)
+#define IIO_WSTAT_TXRETRY_CNT(w)        (((w) >> IIO_WSTAT_TXRETRY_SHFT) & \
+                                          IIO_WSTAT_TXRETRY_MASK)
+
+/* Number of II perf. counters we can multiplex at once */
+
+#define IO_PERF_SETS	32
+
+/* Bit for the widget in inbound access register */
+#define IIO_IIWA_WIDGET(_w)     ((uint64_t)(1ULL << _w))
+/* Bit for the widget in outbound access register */
+#define IIO_IOWA_WIDGET(_w)     ((uint64_t)(1ULL << _w))
+
+/* NOTE: The following define assumes that we are going to get
+ * widget numbers from 8 thru F and the device numbers within
+ * widget from 0 thru 7.
+ */
+#define IIO_IIDEM_WIDGETDEV_MASK(w, d)  ((uint64_t)(1ULL << (8 * ((w) - 8) + (d))))
+
+/* IO Interrupt Destination Register */
+#define IIO_IIDSR_SENT_SHIFT    28
+#define IIO_IIDSR_SENT_MASK     0x30000000
+#define IIO_IIDSR_ENB_SHIFT     24
+#define IIO_IIDSR_ENB_MASK      0x01000000
+#define IIO_IIDSR_NODE_SHIFT    9
+#define IIO_IIDSR_NODE_MASK     0x000ff700
+#define IIO_IIDSR_PI_ID_SHIFT   8
+#define IIO_IIDSR_PI_ID_MASK    0x00000100
+#define IIO_IIDSR_LVL_SHIFT     0
+#define IIO_IIDSR_LVL_MASK      0x000000ff
+
+/* Xtalk timeout threshhold register (IIO_IXTT) */
+#define IXTT_RRSP_TO_SHFT	55	   /* read response timeout */
+#define IXTT_RRSP_TO_MASK	(0x1FULL << IXTT_RRSP_TO_SHFT)
+#define IXTT_RRSP_PS_SHFT	32	   /* read responsed TO prescalar */
+#define IXTT_RRSP_PS_MASK	(0x7FFFFFULL << IXTT_RRSP_PS_SHFT)
+#define IXTT_TAIL_TO_SHFT	0	   /* tail timeout counter threshold */
+#define IXTT_TAIL_TO_MASK	(0x3FFFFFFULL << IXTT_TAIL_TO_SHFT)
+
+/*
+ * The IO LLP control status register and widget control register
+ */
+
+typedef union hubii_wcr_u {
+        uint64_t      wcr_reg_value;
+        struct {
+	  uint64_t	wcr_widget_id:   4,     /* LLP crossbar credit */
+			wcr_tag_mode:	 1,	/* Tag mode */
+			wcr_rsvd1:	 8,	/* Reserved */
+			wcr_xbar_crd:	 3,	/* LLP crossbar credit */
+			wcr_f_bad_pkt:	 1,	/* Force bad llp pkt enable */
+			wcr_dir_con:	 1,	/* widget direct connect */
+			wcr_e_thresh:	 5,	/* elasticity threshold */
+			wcr_rsvd:	41;	/* unused */
+        } wcr_fields_s;
+} hubii_wcr_t;
+
+#define iwcr_dir_con    wcr_fields_s.wcr_dir_con
+
+/* The structures below are defined to extract and modify the ii
+performance registers */
+
+/* io_perf_sel allows the caller to specify what tests will be
+   performed */
+
+typedef union io_perf_sel {
+        uint64_t perf_sel_reg;
+        struct {
+               uint64_t	perf_ippr0 :  4,
+				perf_ippr1 :  4,
+				perf_icct  :  8,
+				perf_rsvd  : 48;
+        } perf_sel_bits;
+} io_perf_sel_t;
+
+/* io_perf_cnt is to extract the count from the shub registers. Due to
+   hardware problems there is only one counter, not two. */
+
+typedef union io_perf_cnt {
+        uint64_t      perf_cnt;
+        struct {
+               uint64_t	perf_cnt   : 20,
+				perf_rsvd2 : 12,
+				perf_rsvd1 : 32;
+        } perf_cnt_bits;
+
+} io_perf_cnt_t;
+
+typedef union iprte_a {
+	uint64_t	entry;
+	struct {
+		uint64_t	i_rsvd_1                  :	 3;
+		uint64_t	i_addr			  :	38;
+		uint64_t	i_init			  :	 3;
+		uint64_t	i_source		  :	 8;
+		uint64_t	i_rsvd			  :	 2;
+		uint64_t	i_widget		  :	 4;
+		uint64_t	i_to_cnt		  :	 5;
+		uint64_t       i_vld                     :      1;
+	} iprte_fields;
+} iprte_a_t;
+
+#endif /* _ASM_IA64_SN_SHUBIO_H */
+
diff -Nru a/include/asm-ia64/unistd.h b/include/asm-ia64/unistd.h
--- a/include/asm-ia64/unistd.h	2005-01-22 14:19:22 -08:00
+++ b/include/asm-ia64/unistd.h	2005-01-25 12:23:46 -08:00
@@ -4,7 +4,7 @@
 /*
  * IA-64 Linux syscall numbers and inline-functions.
  *
- * Copyright (C) 1998-2004 Hewlett-Packard Co
+ * Copyright (C) 1998-2005 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
@@ -376,15 +376,13 @@
 struct sigaction;
 long sys_execve(char __user *filename, char __user * __user *argv,
 			   char __user * __user *envp, struct pt_regs *regs);
-asmlinkage long sys_pipe(long arg0, long arg1, long arg2, long arg3,
-			long arg4, long arg5, long arg6, long arg7, long stack);
+asmlinkage long sys_pipe(void);
 asmlinkage long sys_ptrace(long request, pid_t pid,
-			unsigned long addr, unsigned long data,
-			long arg4, long arg5, long arg6, long arg7, long stack);
+			   unsigned long addr, unsigned long data);
 asmlinkage long sys_rt_sigaction(int sig,
-				const struct sigaction __user *act,
-				struct sigaction __user *oact,
-				size_t sigsetsize);
+				 const struct sigaction __user *act,
+				 struct sigaction __user *oact,
+				 size_t sigsetsize);
 
 /*
  * "Conditional" syscalls
diff -Nru a/include/asm-mips/ng1.h b/include/asm-mips/ng1.h
--- a/include/asm-mips/ng1.h	2003-04-14 20:10:06 -07:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,55 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * SGI/Newport video card ioctl definitions
- */
-#ifndef _ASM_NG1_H
-#define _ASM_NG1_H
-
-typedef struct {
-        int flags;
-        __u16 w, h;
-        __u16 fields_sec;
-} ng1_vof_info_t;
-
-struct ng1_info {
-	struct gfx_info gfx_info;
-	__u8 boardrev;
-        __u8 rex3rev;
-        __u8 vc2rev;
-        __u8 monitortype;
-        __u8 videoinstalled;
-        __u8 mcrev;
-        __u8 bitplanes;
-        __u8 xmap9rev;
-        __u8 cmaprev;
-        ng1_vof_info_t ng1_vof_info;
-        __u8 bt445rev;
-        __u8 paneltype;
-};
-
-#define GFX_NAME_NEWPORT "NG1"
-
-/* ioctls */
-#define NG1_SET_CURSOR_HOTSPOT 21001
-struct ng1_set_cursor_hotspot {
-	unsigned short xhot;
-        unsigned short yhot;
-};
-
-#define NG1_SETDISPLAYMODE     21006
-struct ng1_setdisplaymode_args {
-        int wid;
-        unsigned int mode;
-};
-
-#define NG1_SETGAMMARAMP0      21007
-struct ng1_setgammaramp_args {
-        unsigned char red   [256];
-        unsigned char green [256];
-        unsigned char blue  [256];
-};
-
-#endif /* _ASM_NG1_H */
diff -Nru a/include/asm-mips/ng1hw.h b/include/asm-mips/ng1hw.h
--- a/include/asm-mips/ng1hw.h	2003-06-15 16:56:21 -07:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,219 +0,0 @@
-/*
- * ng1hw.h: Tweaks the newport.h structures and definitions to be compatible
- * 	    with IRIX.  Quite ugly, but it works.
- *
- * Copyright (C) 1999 Ulf Carlsson (ulfc@thepuffingroup.com)
- */
-#ifndef _SGI_NG1HW_H
-#define _SGI_NG1HW_H
-
-#include <video/newport.h>
-
-#define rex3regs	newport_rexregs
-#define configregs	newport_cregs
-#define float_long	npfreg_t
-
-typedef struct newport_rexregs Rex3regs;
-typedef struct newport_cregs Configregs;
-typedef union np_dcb DCB_reg;
-
-
-/* It looks like I can't do a simple tweak with this structure because the IRIX
- * version is just *too* stupid.  Ok, here's a new version of it..
- */
-
-struct rex3chip {
-	struct newport_rexregs set;
-	unsigned long _unused0[0x16e];
-	struct newport_rexregs go;
-	unsigned long _unused1[0x22e];
-	struct {
-		struct newport_cregs set;
-		unsigned long _unused2[0x1ef];
-		struct newport_cregs go;
-	} p1;
-};
-
-typedef struct rex3chip rex3Chip;
-typedef struct rex3chip Rex3chip;
-
-/* Tweak the defines .. */
-
-#define DM0_OPCODE		NPORT_DMODE0_OPMASK
-#define DM0_NOP			NPORT_DMODE0_NOP
-#define DM0_READ		NPORT_DMODE0_RD
-#define DM0_DRAW		NPORT_DMODE0_DRAW
-#define DM0_SCR2SCR		NPORT_DMODE0_S2S
-
-#define DM0_ADRMODE_SHIFT	2
-#define DM0_ADRMODE		NPORT_DMODE0_AMMASK
-#define DM0_SPAN		NPORT_DMODE0_SPAN
-#define DM0_BLOCK		NPORT_DMODE0_BLOCK
-#define DM0_ILINE		NPORT_DMODE0_ILINE
-#define DM0_FLINE		NPORT_DMODE0_FLINE
-#define DM0_ALINE		NPORT_DMODE0_ALINE
-#define DM0_TLINE		NPORT_DMODE0_TLINE
-#define DM0_BLINE               NPORT_DMODE0_BLINE
-
-#define DM0_DOSETUP		NPORT_DMODE0_DOSETUP
-#define DM0_COLORHOST		NPORT_DMODE0_CHOST
-#define DM0_ALPHAHOST		NPORT_DMODE0_AHOST
-#define DM0_STOPONX		NPORT_DMODE0_STOPX
-#define DM0_STOPONY		NPORT_DMODE0_STOPY
-#define DM0_STOPONXY		(NPORT_DMODE0_STOPX | NPORT_DMODE0_STOPY)
-#define DM0_SKIPFIRST		NPORT_DMODE0_SK1ST
-#define DM0_SKIPLAST		NPORT_DMODE0_SKLST
-#define DM0_ENZPATTERN		NPORT_DMODE0_ZPENAB
-#define DM0_ENLSPATTERN		NPORT_DMODE0_LISPENAB
-#define DM0_LSADVLAST		NPORT_DMODE0_LISLST
-#define DM0_LENGTH32		NPORT_DMODE0_L32
-#define DM0_ZOPAQUE		NPORT_DMODE0_ZOPQ
-#define DM0_LSOPAQUE		NPORT_DMODE0_LISOPQ
-#define DM0_SHADE		NPORT_DMODE0_SHADE
-#define DM0_LRONLY		NPORT_DMODE0_LRONLY
-#define DM0_XYOFFSET		NPORT_DMODE0_XYOFF
-#define DM0_CICLAMP		NPORT_DMODE0_CLAMP
-#define DM0_ENDPTFILTER		NPORT_DMODE0_ENDPF
-#define	DM0_YSTRIDE		NPORT_DMODE0_YSTR
-
-#define DM1_PLANES_SHIFT	0
-/* The rest of the DM1 planes defines are in newport.h */
-
-#define DM1_DRAWDEPTH_SHIFT	3
-#define DM1_DRAWDEPTH_MASK	NPORT_DMODE1_DDMASK
-#define DM1_DRAWDEPTH		NPORT_DMODE1_DD24 /* An alias? */
-#define DM1_DRAWDEPTH4		NPORT_DMODE1_DD4
-#define DM1_DRAWDEPTH8		NPORT_DMODE1_DD8
-#define DM1_DRAWDEPTH12		NPORT_DMODE1_DD12
-#define DM1_DRAWDEPTH24		NPORT_DMODE1_DD24
-
-#define DM1_DBLSRC		NPORT_DMODE1_DSRC
-#define DM1_YFLIP		NPORT_DMODE1_YFLIP
-#define DM1_RWPACKED		NPORT_DMODE1_RWPCKD
-
-#define DM1_HOSTDEPTH_SHIFT 	8
-#define DM1_HOSTDEPTH_MASK	NPORT_DMODE1_HDMASK
-#define DM1_HOSTDEPTH		NPORT_DMODE1_HD32 /* An alias? */
-#define DM1_HOSTDEPTH4		NPORT_DMODE1_HD4
-#define DM1_HOSTDEPTH8		NPORT_DMODE1_HD8
-#define DM1_HOSTDEPTH12		NPORT_DMODE1_HD12
-#define DM1_HOSTDEPTH32		NPORT_DMODE1_HD32
-
-#define DM1_RWDOUBLE		NPORT_DMODE1_RWDBL
-#define DM1_SWAPENDIAN		NPORT_DMODE1_ESWAP
-
-#define DM1_COLORCOMPARE_SHIFT	12
-#define DM1_COLORCOMPARE_MASK	NPORT_DMODE1_CCMASK
-#define DM1_COLORCOMPARE	NPORT_DMODE1_CCMASK
-#define DM1_COLORCOMPLT		NPORT_DMODE1_CCLT
-#define DM1_COLORCOMPEQ		NPORT_DMODE1_CCEQ
-#define DM1_COLORCOMPGT		NPORT_DMODE1_CCGT
-
-#define DM1_RGBMODE		NPORT_DMODE1_RGBMD
-#define DM1_ENDITHER		NPORT_DMODE1_DENAB
-#define DM1_FASTCLEAR		NPORT_DMODE1_FCLR
-#define DM1_ENBLEND		NPORT_DMODE1_BENAB
-
-#define DM1_SF_SHIFT		19
-#define DM1_SF_MASK   		NPORT_DMODE1_SFMASK
-#define DM1_SF			NPORT_DMODE1_SFMASK
-#define DM1_SF_ZERO		NPORT_DMODE1_SF0
-#define DM1_SF_ONE		NPORT_DMODE1_SF1
-#define DM1_SF_DC		NPORT_DMODE1_SFDC
-#define DM1_SF_MDC		NPORT_DMODE1_SFMDC
-#define DM1_SF_SA		NPORT_DMODE1_SFSA
-#define DM1_SF_MSA		NPORT_DMODE1_SFMSA
-
-#define DM1_DF_SHIFT		22	/* dfactor(2:0)	*/
-#define DM1_DF_MASK		NPORT_DMODE1_DFMASK
-#define DM1_DF			NPORT_DMODE1_DFMASK
-#define DM1_DF_ZERO		NPORT_DMODE1_DF0
-#define DM1_DF_ONE		NPORT_DMODE1_DF1
-#define DM1_DF_SC		NPORT_DMODE1_DFSC
-#define DM1_DF_MSC		NPORT_DMODE1_DFMSC
-#define DM1_DF_SA		NPORT_DMODE1_DFSA
-#define DM1_DF_MSA		NPORT_DMODE1_DFMSA
-
-#define DM1_ENBACKBLEND		NPORT_DMODE1_BBENAB
-#define DM1_ENPREFETCH		NPORT_DMODE1_PFENAB
-#define DM1_BLENDALPHA		NPORT_DMODE1_ABLEND
-
-#define DM1_LO_SHIFT		28
-#define DM1_LO			NPORT_DMODE1_LOMASK
-#define DM1_LO_MASK      	NPORT_DMODE1_LOMASK
-#define DM1_LO_ZERO		NPORT_DMODE1_LOZERO
-#define DM1_LO_AND		NPORT_DMODE1_LOAND
-#define DM1_LO_ANDR		NPORT_DMODE1_LOANDR
-#define DM1_LO_SRC		NPORT_DMODE1_LOSRC
-#define DM1_LO_ANDI		NPORT_DMODE1_LOANDI
-#define DM1_LO_DST		NPORT_DMODE1_LODST
-#define DM1_LO_XOR		NPORT_DMODE1_LOXOR
-#define DM1_LO_OR		NPORT_DMODE1_LOOR
-#define DM1_LO_NOR		NPORT_DMODE1_LONOR
-#define DM1_LO_XNOR		NPORT_DMODE1_LOXNOR
-#define DM1_LO_NDST		NPORT_DMODE1_LONDST
-#define DM1_LO_ORR		NPORT_DMODE1_LOORR
-#define DM1_LO_NSRC		NPORT_DMODE1_LONSRC
-#define DM1_LO_ORI		NPORT_DMODE1_LOORI
-#define DM1_LO_NAND		NPORT_DMODE1_LONAND
-#define DM1_LO_ONE		NPORT_DMODE1_LOONE
-
-#define SMASK0			NPORT_CMODE_SM0
-#define SMASK1			NPORT_CMODE_SM1
-#define SMASK2			NPORT_CMODE_SM2
-#define SMASK3			NPORT_CMODE_SM3
-#define SMASK4			NPORT_CMODE_SM4
-#define ALL_SMASKS		0x1f
-
-#define CM_CIDMATCH_SHIFT       9
-#define CM_CIDMATCH_MASK        NPORT_CMODE_CMSK
-
-#define REX3VERSION_MASK	NPORT_STAT_VERS
-#define GFXBUSY        		NPORT_STAT_GBUSY
-#define BACKBUSY        	NPORT_STAT_BBUSY
-#define VRINT           	NPORT_STAT_VRINT
-#define VIDEOINT        	NPORT_STAT_VIDINT
-#define GFIFO_LEVEL_SHIFT       7
-#define GFIFO_LEVEL_MASK        NPORT_STAT_GLMSK
-#define BFIFO_LEVEL_SHIFT       13
-#define BFIFO_LEVEL_MASK        NPORT_STAT_BLMSK
-#define BFIFO_INT        	NPORT_STAT_BFIRQ
-#define GFIFO_INT        	NPORT_STAT_GFIRQ
-
-#define GIO32MODE		NPORT_CFG_G32MD
-#define BUSWIDTH		NPORT_CFG_BWIDTH
-#define EXTREGXCVR		NPORT_CFG_ERCVR
-#define BFIFODEPTH_SHIFT	3
-#define BFIFODEPTH_MASK		NPORT_CFG_BDMSK
-#define BFIFOABOVEINT		NPORT_CFG_BFAINT
-#define GFIFODEPTH_SHIFT        8
-#define GFIFODEPTH_MASK		NPORT_CFG_GDMSK
-#define GFIFOABOVEINT		NPORT_CFG_GFAINT
-#define TIMEOUT_SHIFT		14
-#define TIMEOUT_MASK		NPORT_CFG_TOMSK
-#define VREFRESH_SHIFT		17
-#define VREFRESH_MASK		NPORT_CFG_VRMSK
-#define FB_TYPE			NPORT_CFG_FBTYP
-
-#define DCB_DATAWIDTH_MASK	(0x3)
-
-#define DCB_CRS_MASK		(0x7 << DCB_CRS_SHIFT)
-#define DCB_ADDR_MASK		(0xf << DCB_ADDR_SHIFT)
-#define DCB_CSWIDTH_MASK	(0x1f << DCB_CSWIDTH_SHIFT)
-#define DCB_CSHOLD_MASK		(0x1f << DCB_CSHOLD_SHIFT)
-#define DCB_CSSETUP_MASK	(0x1f << DCB_CSSETUP_SHIFT)
-
-#define DCB_SWAPENDIAN		(1 << 28)
-
-#define REX3WAIT(rex3)  while ((rex3)->p1.set.status & GFXBUSY)
-#define BFIFOWAIT(rex3)  while ((rex3)->p1.set.status & BACKBUSY)
-
-#define REX3_GIO_ADDR_0         0x1f0f0000
-#define REX3_GIO_ADDR_1         0x1f4f0000
-#define REX3_GIO_ADDR_2         0x1f8f0000
-#define REX3_GIO_ADDR_3         0x1fcf0000
-
-#define NG1_XSIZE		1280
-#define NG1_YSIZE		1024
-
-#endif
diff -Nru a/include/asm-mips/sgi/sgi.h b/include/asm-mips/sgi/sgi.h
--- a/include/asm-mips/sgi/sgi.h	2003-04-14 20:10:06 -07:00
+++ b/include/asm-mips/sgi/sgi.h	2005-02-03 06:42:40 -08:00
@@ -28,8 +28,8 @@
 	ip26,	/* TFP UP, Indigo2 */
 	ip27,	/* R10k MP, R12k MP, Origin */
 	ip28,	/* R10k UP, Indigo2 */
-	ip30,
-	ip32,
+	ip30,	/* Octane */
+	ip32,	/* O2 */
 };
 
 extern enum sgi_mach sgimach;
diff -Nru a/include/asm-ppc/ibm44x.h b/include/asm-ppc/ibm44x.h
--- a/include/asm-ppc/ibm44x.h	2005-01-30 22:22:38 -08:00
+++ b/include/asm-ppc/ibm44x.h	2005-02-03 06:42:41 -08:00
@@ -3,9 +3,9 @@
  *
  * PPC44x definitions
  *
- * Matt Porter <mporter@mvista.com>
+ * Matt Porter <mporter@kernel.crashing.org>
  *
- * Copyright 2002-2003 MontaVista Software Inc.
+ * Copyright 2002-2005 MontaVista Software Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -34,23 +34,55 @@
 /* Lowest TLB slot consumed by the default pinned TLBs */
 #define PPC44x_LOW_SLOT		63
 
+/* LS 32-bits of UART0 physical address location for early serial text debug */
+#ifdef CONFIG_440SP
+#define UART0_PHYS_IO_BASE	0xf0000200
+#else
+#define UART0_PHYS_IO_BASE	0x40000200
+#endif
+
+/*
+ * XXX This 36-bit trap stuff will move somewhere in syslib/
+ * when we rework/abstract the PPC44x PCI-X handling -mdp
+ */
+
 /*
  * Standard 4GB "page" definitions
  */
+#ifdef CONFIG_440SP
+#define	PPC44x_IO_PAGE		0x0000000100000000ULL
+#define	PPC44x_PCICFG_PAGE	0x0000000900000000ULL
+#define	PPC44x_PCIIO_PAGE	PPC44x_PCICFG_PAGE
+#define	PPC44x_PCIMEM_PAGE	0x0000000a00000000ULL
+#else
 #define	PPC44x_IO_PAGE		0x0000000100000000ULL
 #define	PPC44x_PCICFG_PAGE	0x0000000200000000ULL
 #define	PPC44x_PCIIO_PAGE	PPC44x_PCICFG_PAGE
 #define	PPC44x_PCIMEM_PAGE	0x0000000300000000ULL
+#endif
 
 /*
  * 36-bit trap ranges
  */
-#define PPC44x_IO_LO		0x40000000
-#define PPC44x_IO_HI		0x40001000
-#define PPC44x_PCICFG_LO	0x0ec00000
-#define PPC44x_PCICFG_HI	0x0ec7ffff
-#define PPC44x_PCIMEM_LO	0x80002000
-#define PPC44x_PCIMEM_HI	0xffffffff
+#ifdef CONFIG_440SP
+#define PPC44x_IO_LO		0xf0000000UL
+#define PPC44x_IO_HI		0xf0000fffUL
+#define PPC44x_PCI0CFG_LO	0x0ec00000UL
+#define PPC44x_PCI0CFG_HI	0x0ec00007UL
+#define PPC44x_PCI1CFG_LO	0x1ec00000UL
+#define PPC44x_PCI1CFG_HI	0x1ec00007UL
+#define PPC44x_PCI2CFG_LO	0x2ec00000UL
+#define PPC44x_PCI2CFG_HI	0x2ec00007UL
+#define PPC44x_PCIMEM_LO	0x80000000UL
+#define PPC44x_PCIMEM_HI	0xdfffffffUL
+#else
+#define PPC44x_IO_LO		0x40000000UL
+#define PPC44x_IO_HI		0x40000fffUL
+#define PPC44x_PCI0CFG_LO	0x0ec00000UL
+#define PPC44x_PCI0CFG_HI	0x0ec00007UL
+#define PPC44x_PCIMEM_LO	0x80002000UL
+#define PPC44x_PCIMEM_HI	0xffffffffUL
+#endif
 
 /*
  * The "residual" board information structure the boot loader passes
@@ -62,8 +94,8 @@
  * DCRN definitions
  */
 
-#ifdef CONFIG_440GX
-/* CPRs */
+
+/* CPRs (440GX and 440SP) */
 #define DCRN_CPR_CONFIG_ADDR	0xc
 #define DCRN_CPR_CONFIG_DATA	0xd
 
@@ -84,7 +116,7 @@
 	mtdcr(DCRN_CPR_CONFIG_ADDR, offset); \
 	mtdcr(DCRN_CPR_CONFIG_DATA, data);})
 
-/* SDRs */
+/* SDRs (440GX and 440SP) */
 #define DCRN_SDR_CONFIG_ADDR 	0xe
 #define DCRN_SDR_CONFIG_DATA	0xf
 #define DCRN_SDR_PFC0		0x4100
@@ -127,9 +159,8 @@
 #define SDR_WRITE(offset, data) ({\
 	mtdcr(DCRN_SDR_CONFIG_ADDR, offset); \
 	mtdcr(DCRN_SDR_CONFIG_DATA,data);})
-#endif /* CONFIG_440GX */
 
-/* Base DCRNs */
+/* DMA (excluding 440SP) */
 #define DCRN_DMA0_BASE		0x100
 #define DCRN_DMA1_BASE		0x108
 #define DCRN_DMA2_BASE		0x110
@@ -163,7 +194,7 @@
 #define UICB_UIC1NC		0x10000000
 #define UICB_UIC2NC		0x04000000
 
-/* 440GP MAL DCRs */
+/* 440 MAL DCRs */
 #define DCRN_MALCR(base)		(base + 0x0)	/* Configuration */
 #define DCRN_MALESR(base)		(base + 0x1)	/* Error Status */
 #define DCRN_MALIER(base)		(base + 0x2)	/* Interrupt Enable */
@@ -194,7 +225,6 @@
 #define DCRN_MALRCBS2(base)	((base) + 0x62)	/* Channel Rx 2 Channel Buffer Size */
 #define DCRN_MALRCBS3(base)	((base) + 0x63)	/* Channel Rx 3 Channel Buffer Size */
 
-
 #define MALCR_MMSR		0x80000000	/* MAL Software reset */
 #define MALCR_PLBP_1		0x00400000	/* MAL reqest priority: */
 #define MALCR_PLBP_2		0x00800000	/* lowsest is 00 */
@@ -320,7 +350,7 @@
 #define DCRN_SLP	(DCRN_DMASR_BASE + 0x5)	/* DMA Sleep Register */
 #define DCRN_POL	(DCRN_DMASR_BASE + 0x6)	/* DMA Polarity Register */
 
-/* 440GP DRAM controller DCRs */
+/* 440GP/440GX SDRAM controller DCRs */
 #define DCRN_SDRAM0_CFGADDR		0x010
 #define DCRN_SDRAM0_CFGDATA		0x011
 
@@ -346,13 +376,35 @@
 #define PPC44x_MEM_SIZE_128M		0x08000000
 #define PPC44x_MEM_SIZE_256M		0x10000000
 #define PPC44x_MEM_SIZE_512M		0x20000000
+#define PPC44x_MEM_SIZE_1G		0x40000000
+#define PPC44x_MEM_SIZE_2G		0x80000000
 
-#ifdef CONFIG_440GX
-/* Internal SRAM Controller */
-#define DCRN_SRAM0_SB0CR	0x020
-#define DCRN_SRAM0_SB1CR	0x021
-#define DCRN_SRAM0_SB2CR	0x022
-#define DCRN_SRAM0_SB3CR	0x023
+/* 440SP memory controller DCRs */
+#define DCRN_MQ0_BS0BAS			0x40
+#define DCRN_MQ0_BS1BAS			0x41
+
+#define MQ0_CONFIG_SIZE_MASK		0x0000fff0
+#define MQ0_CONFIG_SIZE_8M		0x0000ffc0
+#define MQ0_CONFIG_SIZE_16M		0x0000ff80
+#define MQ0_CONFIG_SIZE_32M		0x0000ff00
+#define MQ0_CONFIG_SIZE_64M		0x0000fe00
+#define MQ0_CONFIG_SIZE_128M		0x0000fc00
+#define MQ0_CONFIG_SIZE_256M		0x0000f800
+#define MQ0_CONFIG_SIZE_512M		0x0000f000
+#define MQ0_CONFIG_SIZE_1G		0x0000e000
+#define MQ0_CONFIG_SIZE_2G		0x0000c000
+
+/* Internal SRAM Controller 440GX/440SP */
+#ifdef CONFIG_440SP
+#define DCRN_SRAM0_BASE		0x100
+#else /* 440GX */
+#define DCRN_SRAM0_BASE		0x000
+#endif
+
+#define DCRN_SRAM0_SB0CR	(DCRN_SRAM0_BASE + 0x020)
+#define DCRN_SRAM0_SB1CR	(DCRN_SRAM0_BASE + 0x021)
+#define DCRN_SRAM0_SB2CR	(DCRN_SRAM0_BASE + 0x022)
+#define DCRN_SRAM0_SB3CR	(DCRN_SRAM0_BASE + 0x023)
 #define  SRAM_SBCR_BAS0		0x80000000
 #define  SRAM_SBCR_BAS1		0x80010000
 #define  SRAM_SBCR_BAS2		0x80020000
@@ -361,16 +413,16 @@
 #define  SRAM_SBCR_BS_64KB	0x00000800
 #define  SRAM_SBCR_BU_RO	0x00000080
 #define  SRAM_SBCR_BU_RW	0x00000180
-#define DCRN_SRAM0_BEAR		0x024
-#define DCRN_SRAM0_BESR0	0x025
-#define DCRN_SRAM0_BESR1	0x026
-#define DCRN_SRAM0_PMEG		0x027
-#define DCRN_SRAM0_CID		0x028
-#define DCRN_SRAM0_REVID	0x029
-#define DCRN_SRAM0_DPC		0x02a
+#define DCRN_SRAM0_BEAR		(DCRN_SRAM0_BASE + 0x024)
+#define DCRN_SRAM0_BESR0	(DCRN_SRAM0_BASE + 0x025)
+#define DCRN_SRAM0_BESR1	(DCRN_SRAM0_BASE + 0x026)
+#define DCRN_SRAM0_PMEG		(DCRN_SRAM0_BASE + 0x027)
+#define DCRN_SRAM0_CID		(DCRN_SRAM0_BASE + 0x028)
+#define DCRN_SRAM0_REVID	(DCRN_SRAM0_BASE + 0x029)
+#define DCRN_SRAM0_DPC		(DCRN_SRAM0_BASE + 0x02a)
 #define  SRAM_DPC_ENABLE	0x80000000
 
-/* L2 Cache Controller */
+/* L2 Cache Controller 440GX/440SP */
 #define DCRN_L2C0_CFG		0x030
 #define  L2C_CFG_L2M		0x80000000
 #define  L2C_CFG_ICU		0x40000000
@@ -420,13 +472,29 @@
 #define  L2C_SNP_SSR_MASK	0x0000f000
 #define  L2C_SNP_SSR_32G	0x0000f000
 #define  L2C_SNP_ESR		0x00000800
-#endif /* CONFIG_440GX */
 
 /*
  * PCI-X definitions
  */
-#define PCIX0_REG_BASE		0x20ec80000ULL
-#define PCIX0_REG_SIZE		0x200
+#define PCIX0_CFGA		0x0ec00000UL
+#define PCIX1_CFGA		0x1ec00000UL
+#define PCIX2_CFGA		0x2ec00000UL
+#define PCIX0_CFGD		0x0ec00004UL
+#define PCIX1_CFGD		0x1ec00004UL
+#define PCIX2_CFGD		0x2ec00004UL
+
+#define PCIX0_IO_BASE		0x0000000908000000ULL
+#define PCIX1_IO_BASE		0x0000000908000000ULL
+#define PCIX2_IO_BASE		0x0000000908000000ULL
+#define PCIX_IO_SIZE		0x00010000
+
+#ifdef CONFIG_440SP
+#define PCIX0_REG_BASE		0x000000090ec80000ULL
+#else
+#define PCIX0_REG_BASE		0x000000020ec80000ULL
+#endif
+#define PCIX_REG_OFFSET		0x10000000
+#define PCIX_REG_SIZE		0x200
 
 #define PCIX0_VENDID		0x000
 #define PCIX0_DEVID		0x002
@@ -523,8 +591,6 @@
 #else
 #define NR_UICS 2
 #endif
-
-#define BD_EMAC_ADDR(e,i) bi_enetaddr[e][i]
 
 #include <asm/ibm4xx.h>
 
diff -Nru a/include/asm-ppc/ibm4xx.h b/include/asm-ppc/ibm4xx.h
--- a/include/asm-ppc/ibm4xx.h	2004-10-18 22:26:40 -07:00
+++ b/include/asm-ppc/ibm4xx.h	2005-02-03 06:42:41 -08:00
@@ -101,6 +101,10 @@
 #include <platforms/4xx/ebony.h>
 #endif
 
+#if defined(CONFIG_LUAN)
+#include <platforms/4xx/luan.h>
+#endif
+
 #if defined(CONFIG_OCOTEA)
 #include <platforms/4xx/ocotea.h>
 #endif
diff -Nru a/include/asm-ppc/mv64x60.h b/include/asm-ppc/mv64x60.h
--- a/include/asm-ppc/mv64x60.h	2005-01-30 22:22:37 -08:00
+++ b/include/asm-ppc/mv64x60.h	2005-02-03 06:42:42 -08:00
@@ -254,10 +254,12 @@
 extern inline u32
 mv64x60_read(struct mv64x60_handle *bh, u32 offset) {
 	ulong	flags;
+	u32     reg;
 
 	spin_lock_irqsave(&mv64x60_lock, flags);
-	return in_le32(bh->v_base + offset);
+	reg = in_le32(bh->v_base + offset);
 	spin_unlock_irqrestore(&mv64x60_lock, flags);
+	return reg;
 }
 
 extern inline void
@@ -267,9 +269,9 @@
 	ulong	flags;
 
 	spin_lock_irqsave(&mv64x60_lock, flags);
-	reg = mv64x60_read(bh, offs) & (~mask); /* zero bits we care about */
-	reg |= data & mask; /* set bits from the data */
-	mv64x60_write(bh, offs, reg);
+	reg = in_le32(bh->v_base + offs) & (~mask);
+	reg |= data & mask;
+	out_le32(bh->v_base + offs, reg);
 	spin_unlock_irqrestore(&mv64x60_lock, flags);
 }
 
diff -Nru a/include/asm-ppc/ppc4xx_dma.h b/include/asm-ppc/ppc4xx_dma.h
--- a/include/asm-ppc/ppc4xx_dma.h	2004-08-07 15:02:29 -07:00
+++ b/include/asm-ppc/ppc4xx_dma.h	2005-02-03 06:42:41 -08:00
@@ -137,10 +137,11 @@
 #define DMA_TCE_ENABLE     (1<<(8-DMA_CR_OFFSET))
 #define SET_DMA_TCE(x)     (((x)&0x1)<<(8-DMA_CR_OFFSET))
 
-#define DMA_DEC            (1<<(2)	/* Address Decrement */
+#define DMA_DEC            (1<<(2))	/* Address Decrement */
 #define SET_DMA_DEC(x)     (((x)&0x1)<<2)
 #define GET_DMA_DEC(x)     (((x)&DMA_DEC)>>2)
 
+
 /*
  * Transfer Modes
  * These modes are defined in a way that makes it possible to
@@ -244,6 +245,14 @@
 #define DMA_SG2            (1<<5)
 #define DMA_SG3            (1<<4)
 
+/* DMA Channel Count Register */
+#define DMA_CTC_BTEN     (1<<23)    /* Burst Enable/Disable bit */
+#define DMA_CTC_BSIZ_MSK (3<<21)    /* Mask of the Burst size bits */
+#define DMA_CTC_BSIZ_2   (0)
+#define DMA_CTC_BSIZ_4   (1<<21)
+#define DMA_CTC_BSIZ_8   (2<<21)
+#define DMA_CTC_BSIZ_16  (3<<21)
+
 /*
  * DMA SG Command Register
  */
@@ -482,6 +491,7 @@
 	char td;		/* transfer direction */
 #endif
 
+	char int_on_final_sg;/* for scatter/gather - only interrupt on last sg */
 } ppc_dma_ch_t;
 
 /*
@@ -545,6 +555,9 @@
 extern int ppc4xx_alloc_dma_handle(sgl_handle_t *, unsigned int, unsigned int);
 extern void ppc4xx_free_dma_handle(sgl_handle_t);
 extern int ppc4xx_get_dma_status(void);
+extern int ppc4xx_enable_burst(unsigned int);
+extern int ppc4xx_disable_burst(unsigned int);
+extern int ppc4xx_set_burst_size(unsigned int, unsigned int);
 extern void ppc4xx_set_src_addr(int dmanr, phys_addr_t src_addr);
 extern void ppc4xx_set_dst_addr(int dmanr, phys_addr_t dst_addr);
 extern void ppc4xx_enable_dma(unsigned int dmanr);
diff -Nru a/include/asm-ppc/reg.h b/include/asm-ppc/reg.h
--- a/include/asm-ppc/reg.h	2005-01-30 22:22:38 -08:00
+++ b/include/asm-ppc/reg.h	2005-02-03 06:42:39 -08:00
@@ -333,6 +333,7 @@
 #define MMCR0_PMC2_CYCLES	0x1
 #define MMCR0_PMC2_ITLB		0x7
 #define MMCR0_PMC2_LOADMISSTIME	0x5
+#define MMCR0_PMXE	(1 << 26)
 
 /* Short-hand versions for a number of the above SPRNs */
 #define CTR	SPRN_CTR	/* Counter Register */
diff -Nru a/include/asm-ppc/rwsem.h b/include/asm-ppc/rwsem.h
--- a/include/asm-ppc/rwsem.h	2004-04-07 15:55:06 -07:00
+++ b/include/asm-ppc/rwsem.h	2005-02-03 06:42:41 -08:00
@@ -27,7 +27,7 @@
 #define RWSEM_ACTIVE_WRITE_BIAS		(RWSEM_WAITING_BIAS + RWSEM_ACTIVE_BIAS)
 	spinlock_t		wait_lock;
 	struct list_head	wait_list;
-#ifdef RWSEM_DEBUG
+#if RWSEM_DEBUG
 	int			debug;
 #endif
 };
@@ -35,7 +35,7 @@
 /*
  * initialisation
  */
-#ifdef RWSEM_DEBUG
+#if RWSEM_DEBUG
 #define __RWSEM_DEBUG_INIT      , 0
 #else
 #define __RWSEM_DEBUG_INIT	/* */
@@ -59,7 +59,7 @@
 	sem->count = RWSEM_UNLOCKED_VALUE;
 	spin_lock_init(&sem->wait_lock);
 	INIT_LIST_HEAD(&sem->wait_list);
-#ifdef RWSEM_DEBUG
+#if RWSEM_DEBUG
 	sem->debug = 0;
 #endif
 }
diff -Nru a/include/asm-s390/ccwdev.h b/include/asm-s390/ccwdev.h
--- a/include/asm-s390/ccwdev.h	2004-03-01 19:01:23 -08:00
+++ b/include/asm-s390/ccwdev.h	2005-02-03 06:42:43 -08:00
@@ -144,6 +144,19 @@
  */
 extern int ccw_device_start_timeout(struct ccw_device *, struct ccw1 *,
 				    unsigned long, __u8, unsigned long, int);
+/*
+ * ccw_device_start_key()
+ * ccw_device_start_key_timeout()
+ *
+ * Same as ccw_device_start() and ccw_device_start_timeout(), except a
+ * storage key != default key can be provided for the I/O.
+ */
+extern int ccw_device_start_key(struct ccw_device *, struct ccw1 *,
+				unsigned long, __u8, __u8, unsigned long);
+extern int ccw_device_start_timeout_key(struct ccw_device *, struct ccw1 *,
+					unsigned long, __u8, __u8,
+					unsigned long, int);
+
 
 extern int ccw_device_resume(struct ccw_device *);
 extern int ccw_device_halt(struct ccw_device *, unsigned long);
diff -Nru a/include/asm-s390/cpcmd.h b/include/asm-s390/cpcmd.h
--- a/include/asm-s390/cpcmd.h	2002-02-04 23:39:15 -08:00
+++ b/include/asm-s390/cpcmd.h	2005-02-03 06:42:42 -08:00
@@ -4,11 +4,21 @@
  *  S390 version
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
+ *               Christian Borntraeger (cborntra@de.ibm.com),
  */
 
 #ifndef __CPCMD__
 #define __CPCMD__
 
+/*
+ * the caller of __cpcmd has to ensure that the response buffer is below 2 GB
+ */
+extern void __cpcmd(char *cmd, char *response, int rlen);
+
+#ifndef __s390x__
+#define cpcmd __cpcmd
+#else
 extern void cpcmd(char *cmd, char *response, int rlen);
+#endif /*__s390x__*/
 
 #endif
diff -Nru a/include/asm-s390/spinlock.h b/include/asm-s390/spinlock.h
--- a/include/asm-s390/spinlock.h	2005-01-20 08:21:24 -08:00
+++ b/include/asm-s390/spinlock.h	2005-02-03 06:42:42 -08:00
@@ -117,6 +117,18 @@
 
 #define rwlock_init(x)	do { *(x) = RW_LOCK_UNLOCKED; } while(0)
 
+/**
+ * read_can_lock - would read_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+#define read_can_lock(x) ((int)(x)->lock >= 0)
+
+/**
+ * write_can_lock - would write_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+#define write_can_lock(x) ((x)->lock == 0)
+
 #ifndef __s390x__
 #define _raw_read_lock(rw)   \
         asm volatile("   l     2,0(%1)\n"   \
diff -Nru a/include/linux/acpi.h b/include/linux/acpi.h
--- a/include/linux/acpi.h	2005-01-04 18:48:17 -08:00
+++ b/include/linux/acpi.h	2005-02-03 06:42:38 -08:00
@@ -532,4 +532,7 @@
 	return 0;
 }
 #endif
+
+extern int pnpacpi_disabled;
+
 #endif /*_LINUX_ACPI_H*/
diff -Nru a/include/linux/device-mapper.h b/include/linux/device-mapper.h
--- a/include/linux/device-mapper.h	2005-01-25 13:50:21 -08:00
+++ b/include/linux/device-mapper.h	2005-02-03 07:16:04 -08:00
@@ -108,6 +108,7 @@
 	sector_t len;
 
 	/* FIXME: turn this into a mask, and merge with io_restrictions */
+	/* Always a power of 2 */
 	sector_t split_io;
 
 	/*
diff -Nru a/include/linux/efi.h b/include/linux/efi.h
--- a/include/linux/efi.h	2005-01-22 14:43:57 -08:00
+++ b/include/linux/efi.h	2005-01-26 10:01:42 -08:00
@@ -289,6 +289,7 @@
 }
 
 extern void efi_init (void);
+extern void *efi_get_pal_addr (void);
 extern void efi_map_pal_code (void);
 extern void efi_map_memmap(void);
 extern void efi_memmap_walk (efi_freemem_callback_t callback, void *arg);
diff -Nru a/include/linux/fs.h b/include/linux/fs.h
--- a/include/linux/fs.h	2005-01-31 15:17:07 -08:00
+++ b/include/linux/fs.h	2005-02-03 06:42:40 -08:00
@@ -16,7 +16,6 @@
 #include <linux/dcache.h>
 #include <linux/stat.h>
 #include <linux/cache.h>
-#include <linux/prio_tree.h>
 #include <linux/kobject.h>
 #include <asm/atomic.h>
 
@@ -219,6 +218,7 @@
 
 #include <linux/list.h>
 #include <linux/radix-tree.h>
+#include <linux/prio_tree.h>
 #include <linux/audit.h>
 #include <linux/init.h>
 #include <asm/semaphore.h>
diff -Nru a/include/linux/ide.h b/include/linux/ide.h
--- a/include/linux/ide.h	2005-01-09 12:06:39 -08:00
+++ b/include/linux/ide.h	2005-02-03 06:19:43 -08:00
@@ -187,11 +187,7 @@
  * Timeouts for various operations:
  */
 #define WAIT_DRQ	(HZ/10)		/* 100msec - spec allows up to 20ms */
-#if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)
 #define WAIT_READY	(5*HZ)		/* 5sec - some laptops are very slow */
-#else
-#define WAIT_READY	(HZ/10)		/* 100msec - should be instantaneous */
-#endif /* CONFIG_APM || CONFIG_APM_MODULE */
 #define WAIT_PIDENTIFY	(10*HZ)	/* 10sec  - should be less than 3ms (?), if all ATAPI CD is closed at boot */
 #define WAIT_WORSTCASE	(30*HZ)	/* 30sec  - worst case when spinning up */
 #define WAIT_CMD	(10*HZ)	/* 10sec  - maximum wait for an IRQ to happen */
@@ -721,6 +717,7 @@
 					 *  3=64-bit
 					 */
 	unsigned scsi		: 1;	/* 0=default, 1=ide-scsi emulation */
+	unsigned sleeping	: 1;	/* 1=sleeping & sleep field valid */
 
         u8	quirk_list;	/* considered quirky, set for a specific host */
         u8	init_speed;	/* transfer rate set at boot */
@@ -937,7 +934,9 @@
 		/* BOOL: protects all fields below */
 	volatile int busy;
 		/* BOOL: wake us up on timer expiry */
-	int sleeping;
+	int sleeping	: 1;
+		/* BOOL: polling active & poll_timeout field valid */
+	int polling	: 1;
 		/* current drive */
 	ide_drive_t *drive;
 		/* ptr to current hwif in linked-list */
@@ -1297,11 +1296,6 @@
 extern void SELECT_MASK(ide_drive_t *, int);
 extern void QUIRK_LIST(ide_drive_t *);
 
-extern void ata_input_data(ide_drive_t *, void *, u32);
-extern void ata_output_data(ide_drive_t *, void *, u32);
-extern void atapi_input_bytes(ide_drive_t *, void *, u32);
-extern void atapi_output_bytes(ide_drive_t *, void *, u32);
-
 extern int drive_is_ready(ide_drive_t *);
 extern int wait_for_ready(ide_drive_t *, int /* timeout */);
 
@@ -1341,14 +1335,6 @@
 ide_startstop_t __ide_do_rw_disk(ide_drive_t *drive, struct request *rq, sector_t block);
 
 /*
- * ide_system_bus_speed() returns what we think is the system VESA/PCI
- * bus speed (in MHz).  This is used for calculating interface PIO timings.
- * The default is 40 for known PCI systems, 50 otherwise.
- * The "idebus=xx" parameter can be used to override this value.
- */
-extern int ide_system_bus_speed(void);
-
-/*
  * ide_stall_queue() can be used by a drive to give excess bandwidth back
  * to the hwgroup by sleeping for timeout jiffies.
  */
@@ -1361,7 +1347,6 @@
 extern void ide_init_subdrivers(void);
 
 extern struct block_device_operations ide_fops[];
-extern ide_proc_entry_t generic_subdriver_entries[];
 
 extern int ata_attach(ide_drive_t *);
 
@@ -1458,7 +1443,6 @@
 extern int ide_dma_setup(ide_drive_t *);
 extern void ide_dma_start(ide_drive_t *);
 extern int __ide_dma_end(ide_drive_t *);
-extern int __ide_dma_test_irq(ide_drive_t *);
 extern int __ide_dma_lostirq(ide_drive_t *);
 extern int __ide_dma_timeout(ide_drive_t *);
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
diff -Nru a/include/video/newport.h b/include/video/newport.h
--- a/include/video/newport.h	2002-02-04 23:39:17 -08:00
+++ b/include/video/newport.h	2005-02-03 06:42:40 -08:00
@@ -291,8 +291,6 @@
 	unsigned int _unused2[0x1ef];
 	struct newport_cregs cgo;
 };
-extern struct newport_regs *npregs;
-
 
 typedef struct {
 	unsigned int drawmode1;
@@ -450,38 +448,26 @@
 
 /* Miscellaneous NEWPORT routines. */
 #define BUSY_TIMEOUT 100000
-static __inline__ int newport_wait(void)
+static __inline__ int newport_wait(struct newport_regs *regs)
 {
-	int i = 0;
+	int t = BUSY_TIMEOUT;
 
-	while(i < BUSY_TIMEOUT)
-		if(!(npregs->cset.status & NPORT_STAT_GBUSY))
+	while (t--)
+		if (!(regs->cset.status & NPORT_STAT_GBUSY))
 			break;
-	if(i == BUSY_TIMEOUT)
-		return 1;
-	return 0;
+	return !t;
 }
 
-static __inline__ int newport_bfwait(void)
+static __inline__ int newport_bfwait(struct newport_regs *regs)
 {
-	int i = 0;
+	int t = BUSY_TIMEOUT;
 
-	while(i < BUSY_TIMEOUT)
-		if(!(npregs->cset.status & NPORT_STAT_BBUSY))
+	while (t--)
+		if(!(regs->cset.status & NPORT_STAT_BBUSY))
 			break;
-	if(i == BUSY_TIMEOUT)
-		return 1;
-	return 0;
+	return !t;
 }
 
-/* newport.c and cons_newport.c routines */
-extern struct graphics_ops *newport_probe (int, const char **);
-
-void newport_save    (void *);
-void newport_restore (void *);
-void newport_reset   (void);
-int  newport_ioctl   (int card, int cmd, unsigned long arg);
-
 /*
  * DCBMODE register defines:
  */
@@ -564,7 +550,7 @@
 {
         rex->set.dcbmode = DCB_XMAP0 | XM9_CRS_FIFO_AVAIL |
 		DCB_DATAWIDTH_1 | R_DCB_XMAP9_PROTOCOL;
-        newport_bfwait ();
+        newport_bfwait (rex);
 	
         while ((rex->set.dcbdata0.bybytes.b3 & 3) != XM9_FIFO_EMPTY)
 		;
diff -Nru a/security/selinux/avc.c b/security/selinux/avc.c
--- a/security/selinux/avc.c	2005-01-20 21:02:10 -08:00
+++ b/security/selinux/avc.c	2005-02-03 06:42:41 -08:00
@@ -162,8 +162,10 @@
 	i = 0;
 	perm = 1;
 	while (perm < common_base) {
-		if (perm & av)
+		if (perm & av) {
 			audit_log_format(ab, " %s", common_pts[i]);
+			av &= ~perm;
+		}
 		i++;
 		perm <<= 1;
 	}
@@ -175,13 +177,18 @@
 				    (av_perm_to_string[i2].value == perm))
 					break;
 			}
-			if (i2 < ARRAY_SIZE(av_perm_to_string))
+			if (i2 < ARRAY_SIZE(av_perm_to_string)) {
 				audit_log_format(ab, " %s",
 						 av_perm_to_string[i2].name);
+				av &= ~perm;
+			}
 		}
 		i++;
 		perm <<= 1;
 	}
+
+	if (av)
+		audit_log_format(ab, " 0x%x", av);
 
 	audit_log_format(ab, " }");
 }
diff -Nru a/security/selinux/include/av_perm_to_string.h b/security/selinux/include/av_perm_to_string.h
--- a/security/selinux/include/av_perm_to_string.h	2005-01-04 18:48:22 -08:00
+++ b/security/selinux/include/av_perm_to_string.h	2005-02-03 06:42:40 -08:00
@@ -17,6 +17,9 @@
    S_(SECCLASS_FILE, FILE__EXECUTE_NO_TRANS, "execute_no_trans")
    S_(SECCLASS_FILE, FILE__ENTRYPOINT, "entrypoint")
    S_(SECCLASS_FILE, FILE__EXECMOD, "execmod")
+   S_(SECCLASS_CHR_FILE, CHR_FILE__EXECUTE_NO_TRANS, "execute_no_trans")
+   S_(SECCLASS_CHR_FILE, CHR_FILE__ENTRYPOINT, "entrypoint")
+   S_(SECCLASS_CHR_FILE, CHR_FILE__EXECMOD, "execmod")
    S_(SECCLASS_FD, FD__USE, "use")
    S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__CONNECTTO, "connectto")
    S_(SECCLASS_TCP_SOCKET, TCP_SOCKET__NEWCONN, "newconn")
diff -Nru a/security/selinux/include/av_permissions.h b/security/selinux/include/av_permissions.h
--- a/security/selinux/include/av_permissions.h	2005-01-04 18:48:22 -08:00
+++ b/security/selinux/include/av_permissions.h	2005-02-03 06:42:40 -08:00
@@ -143,6 +143,10 @@
 #define CHR_FILE__QUOTAON                         0x00008000UL
 #define CHR_FILE__MOUNTON                         0x00010000UL
 
+#define CHR_FILE__EXECUTE_NO_TRANS                0x00020000UL
+#define CHR_FILE__ENTRYPOINT                      0x00040000UL
+#define CHR_FILE__EXECMOD                         0x00080000UL
+
 #define BLK_FILE__IOCTL                           0x00000001UL
 #define BLK_FILE__READ                            0x00000002UL
 #define BLK_FILE__WRITE                           0x00000004UL
