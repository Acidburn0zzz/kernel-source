#
# This patch fix the kernel PPP/IPPP active/passiv filter code
# to flag inbound/outbound traffic correct for new libpcap
# BUG #34724
#
diff -ur linux-2.6.4-7.org/drivers/isdn/i4l/Kconfig linux-2.6.4-7.clean/drivers/isdn/i4l/Kconfig
--- linux-2.6.4-7.org/drivers/isdn/i4l/Kconfig	2004-03-16 15:10:37.000000000 +0100
+++ linux-2.6.4-7.clean/drivers/isdn/i4l/Kconfig	2004-03-21 15:09:16.000000000 +0100
@@ -31,6 +31,17 @@
 	  by bundling several ISDN-connections, using this protocol. See
 	  <file:Documentation/isdn/README.syncppp> for more information.
 
+config IPPP_FILTER
+	bool "Filtering for synchronous PPP"
+	depends on ISDN_PPP
+	help
+	  Say Y here if you want to be able to filter the packets passing over
+	  IPPP interfaces.  This allows you to control which packets count as
+	  activity (i.e. which packets will reset the idle timer or bring up
+	  a demand-dialled link) and which packets are to be dropped entirely.
+	  You need to say Y here if you wish to use the pass-filter and
+	  active-filter options to ipppd.
+
 config ISDN_PPP_BSDCOMP
 	tristate "Support BSD compression"
 	depends on ISDN_PPP
diff -ur linux-2.6.4-7.org/drivers/isdn/i4l/isdn_ppp.c linux-2.6.4-7.clean/drivers/isdn/i4l/isdn_ppp.c
--- linux-2.6.4-7.org/drivers/isdn/i4l/isdn_ppp.c	2004-03-16 15:10:37.000000000 +0100
+++ linux-2.6.4-7.clean/drivers/isdn/i4l/isdn_ppp.c	2004-03-22 09:08:21.000000000 +0100
@@ -606,7 +606,7 @@
 
 				if (copy_from_user(&uprog, (void *) arg, sizeof(uprog)))
 					return -EFAULT;
-				if (uprog.len > 0 && uprog.len < 65536) {
+				if (uprog.len > 0) {
 					len = uprog.len * sizeof(struct sock_filter);
 					code = kmalloc(len, GFP_KERNEL);
 					if (code == NULL)
@@ -1121,7 +1121,7 @@
 	 * the filter instructions are constructed assuming
 	 * a four-byte PPP header on each packet (which is still present) */
 	skb_push(skb, 4);
-	skb->data[0] = 0;	/* indicate inbound */
+	*(u_int16_t *)skb->data = 0;	/* indicate inbound in DLT_LINUX_SLL */
 
 	if (is->pass_filter.filter
 	    && sk_run_filter(skb, is->pass_filter.filter,
@@ -1263,7 +1263,7 @@
 	 * the filter instructions are constructed assuming
 	 * a four-byte PPP header on each packet */
 	skb_push(skb, 4);
-	skb->data[0] = 1;	/* indicate outbound */
+	*(u_int16_t *)skb->data = htons(4); /* indicate outbound in DLT_LINUX_SLL */
 	*(u_int16_t *)(skb->data + 2) = htons(proto);
 
 	if (ipt->pass_filter.filter 
@@ -1457,7 +1457,7 @@
 	 * earlier.
 	 */
 	skb_pull(skb, IPPP_MAX_HEADER - 4);
-	skb->data[0] = 1;	/* indicate outbound */
+	*(u_int16_t *)skb->data = htons(4);	/* indicate outbound in DLT_LINUX_SLL */
 	*(u_int16_t *)(skb->data + 2) = htons(proto);
 	
 	drop |= is->pass_filter.filter
diff -ur linux-2.6.4-7.org/drivers/net/ppp_generic.c linux-2.6.4-7.clean/drivers/net/ppp_generic.c
--- linux-2.6.4-7.org/drivers/net/ppp_generic.c	2004-03-16 15:10:28.000000000 +0100
+++ linux-2.6.4-7.clean/drivers/net/ppp_generic.c	2004-03-22 08:56:27.000000000 +0100
@@ -994,7 +994,7 @@
 		/* check if we should pass this packet */
 		/* the filter instructions are constructed assuming
 		   a four-byte PPP header on each packet */
-		*skb_push(skb, 2) = 1;
+		*(u_int16_t *)skb_push(skb, 2) = htons(4); /* indicate outbound in DLT_LINUX_SLL */;
 		if (ppp->pass_filter.filter
 		    && sk_run_filter(skb, ppp->pass_filter.filter,
 				     ppp->pass_filter.len) == 0) {
@@ -1537,7 +1537,7 @@
 		/* check if the packet passes the pass and active filters */
 		/* the filter instructions are constructed assuming
 		   a four-byte PPP header on each packet */
-		*skb_push(skb, 2) = 0;
+		*(u_int16_t *)skb_push(skb, 2) = 0; /* indicate inbound in DLT_LINUX_SLL */
 		if (ppp->pass_filter.filter
 		    && sk_run_filter(skb, ppp->pass_filter.filter,
 				     ppp->pass_filter.len) == 0) {
