From: Thomas Renninger <trenn@suse.de>
Subject: ACPI: acpi_bus_{scan,bus,add}: return -ENODEV if no device was found
Patch-Mainline: queued for 2.6.34
References: bnc#531547

Callers (acpi_memhotplug.c, dock.c and others) check for the return
value of acpi_bus_add() and assume a valid device was returned in
case zero was returned.

Thus return -ENODEV if no device was found in acpi_bus_scan and
propagate this through acpi_bus_add and acpi_bus_start.

Also remove a confusing comment in acpiphp_glue.c, acpi_bus_scan
will and cannot invoke if acpi_bus_add returns no valid device.


Signed-off-by: Thomas Renninger <trenn@suse.de>
CC: bjorn.helgaas@hp.com
CC: lenb@kernel.org
CC: linux-acpi@vger.kernel.org
CC: kristen.c.accardi@intel.com

---
 drivers/acpi/scan.c                |   24 +++++++++++++++++++-----
 drivers/pci/hotplug/acpiphp_glue.c |    6 ------
 2 files changed, 19 insertions(+), 11 deletions(-)

Index: linux-2.6.32-SLE11-SP1/drivers/acpi/scan.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/acpi/scan.c
+++ linux-2.6.32-SLE11-SP1/drivers/acpi/scan.c
@@ -1361,9 +1361,25 @@ static int acpi_bus_scan(acpi_handle han
 
 	if (child)
 		*child = device;
-	return 0;
+
+	if (device)
+		return 0;
+	else
+		return -ENODEV;
 }
 
+/*
+ * acpi_bus_add and acpi_bus_start
+ *
+ * scan a given ACPI tree and (probably recently hot-plugged)
+ * create and add or starts found devices.
+ *
+ * If no devices were found -ENODEV is returned which does not
+ * mean that this is a real error, there just have been no suitable
+ * ACPI objects in the table trunk from which the kernel could create
+ * a device and add/start an appropriate driver.
+ */
+
 int
 acpi_bus_add(struct acpi_device **child,
 	     struct acpi_device *parent, acpi_handle handle, int type)
@@ -1373,8 +1389,7 @@ acpi_bus_add(struct acpi_device **child,
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_add = 1;
 
-	acpi_bus_scan(handle, &ops, child);
-	return 0;
+	return acpi_bus_scan(handle, &ops, child);
 }
 EXPORT_SYMBOL(acpi_bus_add);
 
@@ -1388,8 +1403,7 @@ int acpi_bus_start(struct acpi_device *d
 	memset(&ops, 0, sizeof(ops));
 	ops.acpi_op_start = 1;
 
-	acpi_bus_scan(device->handle, &ops, NULL);
-	return 0;
+	return acpi_bus_scan(device->handle, &ops, NULL);
 }
 EXPORT_SYMBOL(acpi_bus_start);
 
Index: linux-2.6.32-SLE11-SP1/drivers/pci/hotplug/acpiphp_glue.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/pci/hotplug/acpiphp_glue.c
+++ linux-2.6.32-SLE11-SP1/drivers/pci/hotplug/acpiphp_glue.c
@@ -920,12 +920,6 @@ static int acpiphp_bus_add(struct acpiph
 			-ret_val);
 		goto acpiphp_bus_add_out;
 	}
-	/*
-	 * try to start anyway.  We could have failed to add
-	 * simply because this bus had previously been added
-	 * on another add.  Don't bother with the return value
-	 * we just keep going.
-	 */
 	ret_val = acpi_bus_start(device);
 
 acpiphp_bus_add_out:
