Subject: sched, cgroup: Use exit hook to avoid use-after-free crash
From: Peter Zijlstra <peterz@infradead.org>
Date: Fri, 24 Dec 2010 16:59:13 +0100
Patch-mainline: Maybe 2.6.37, see discussion at
 http://groups.google.com/group/linux.kernel/browse_thread/thread/549060f23106acac/920f6adacc785e4f?lnk=gst&q=Zijlstra#920f6adacc785e4f

By not notifying the controller of the on-exit move back to
init_css_set, we fail to move the task out of the previous cgroup's
cfs_rq. This leads to an opportunity for a cgroup-destroy to come in and
free the cgroup (there are no active tasks left in it after all) to
which the not-quite dead task is still enqueued.

Cc: stable@kernel.org
Reported-by: Miklos Vajna <vmiklos@frugalware.org>
Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 kernel/sched.c |   10 ++++++++++
 1 file changed, 10 insertions(+)

Index: linux-2.6.37.git/kernel/sched.c
===================================================================
--- linux-2.6.37.git.orig/kernel/sched.c
+++ linux-2.6.37.git/kernel/sched.c
@@ -613,6 +613,9 @@ static inline struct task_group *task_gr
 	struct task_group *tg;
 	struct cgroup_subsys_state *css;
 
+	if (p->flags & PF_EXITING)
+		return &root_task_group;
+
 	css = task_subsys_state_check(p, cpu_cgroup_subsys_id,
 			lockdep_is_held(&task_rq(p)->lock));
 	tg = container_of(css, struct task_group, css);
@@ -9187,6 +9190,12 @@ cpu_cgroup_attach(struct cgroup_subsys *
 	}
 }
 
+static void
+cpu_cgroup_exit(struct cgroup_subsys *ss, struct task_struct *task)
+{
+	sched_move_task(task);
+}
+
 #ifdef CONFIG_FAIR_GROUP_SCHED
 static int cpu_shares_write_u64(struct cgroup *cgrp, struct cftype *cftype,
 				u64 shareval)
@@ -9259,6 +9268,7 @@ struct cgroup_subsys cpu_cgroup_subsys =
 	.destroy	= cpu_cgroup_destroy,
 	.can_attach	= cpu_cgroup_can_attach,
 	.attach		= cpu_cgroup_attach,
+	.exit		= cpu_cgroup_exit,
 	.populate	= cpu_cgroup_populate,
 	.subsys_id	= cpu_cgroup_subsys_id,
 	.early_init	= 1,
