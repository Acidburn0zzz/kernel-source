diff -urN linux-2.6.5/drivers/usb/core/devio.c linux-2.6.5-sema/drivers/usb/core/devio.c
--- linux-2.6.5/drivers/usb/core/devio.c	2004-06-01 15:13:45.000000000 +0200
+++ linux-2.6.5-sema/drivers/usb/core/devio.c	2004-06-01 16:04:23.404596544 +0200
@@ -1204,7 +1204,9 @@
 	if (!ps->dev) {
 		up_read(&ps->devsem);
 		return -ENODEV;
 	}
+	down(&(ps->dev->serialize));
+
 	switch (cmd) {
 	case USBDEVFS_CONTROL:
 		ret = proc_control(ps, (void __user *)arg);
@@ -1284,6 +1287,7 @@
 		ret = proc_ioctl(ps, (void __user *) arg);
 		break;
 	}
+	up(&(ps->dev->serialize));
 	up_read(&ps->devsem);
 	if (ret >= 0)
 		inode->i_atime = CURRENT_TIME;
diff -urN linux-2.6.5/drivers/usb/storage/isd200.c linux-2.6.5-sema/drivers/usb/storage/isd200.c
--- linux-2.6.5/drivers/usb/storage/isd200.c	2004-04-04 05:37:06.000000000 +0200
+++ linux-2.6.5-sema/drivers/usb/storage/isd200.c	2004-06-01 16:02:35.111487664 +0200
@@ -485,7 +485,9 @@
 
 	memcpy(srb->cmnd, &ata, sizeof(ata.generic));
 	srb->cmd_len = sizeof(ata.generic);
+	down(&(us->pusb_dev->serialize));
 	status = usb_stor_Bulk_transport(srb, us);
+	up(&(us->pusb_dev->serialize));
 	if (status == USB_STOR_TRANSPORT_GOOD)
 		status = ISD200_GOOD;
 	else {
@@ -545,7 +547,9 @@
 	/* send the command to the transport layer */
 	memcpy(srb->cmnd, ataCdb, sizeof(ataCdb->generic));
 	srb->cmd_len = sizeof(ataCdb->generic);
+	down(&(us->pusb_dev->serialize));
 	transferStatus = usb_stor_Bulk_transport(srb, us);
+	up(&(us->pusb_dev->serialize));
 
 	/* if the command gets aborted by the higher layers, we need to
 	 * short-circuit all other processing
diff -urN linux-2.6.5/drivers/usb/storage/transport.c linux-2.6.5-sema/drivers/usb/storage/transport.c
--- linux-2.6.5/drivers/usb/storage/transport.c	2004-06-01 15:13:45.000000000 +0200
+++ linux-2.6.5-sema/drivers/usb/storage/transport.c	2004-06-01 16:02:35.109487957 +0200
@@ -527,9 +527,18 @@
 	int need_auto_sense;
 	int result;
 
+	/*
+	 * Grab device's serialize mutex to prevent /usbfs and others from
+	 * sending out a command in the middle of ours (if libusb sends a
+	 * get_descriptor or something on pipe 0 after our CBW and before
+	 * our CSW, and then we get a stall, we have trouble)
+	 */
+ 
 	/* send the command to the transport layer */
+	down(&(us->pusb_dev->serialize));
 	srb->resid = 0;
 	result = us->transport(srb, us);
+	up(&(us->pusb_dev->serialize));
 
 	/* if the command gets aborted by the higher layers, we need to
 	 * short-circuit all other processing
@@ -648,9 +657,11 @@
 		srb->serial_number ^= 0x80000000;
 
 		/* issue the auto-sense command */
+		down(&(us->pusb_dev->serialize));
 		old_resid = srb->resid;
 		srb->resid = 0;
 		temp_result = us->transport(us->srb, us);
+		up(&(us->pusb_dev->serialize));
 
 		/* let's clean up right away */
 		srb->resid = old_resid;
