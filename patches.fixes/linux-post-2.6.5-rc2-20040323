diff -purN linux-post-2.6.5-rc2-20040320/Documentation/crypto/api-intro.txt linux-post-2.6.5-rc2-20040323/Documentation/crypto/api-intro.txt
--- linux-post-2.6.5-rc2-20040320/Documentation/crypto/api-intro.txt	2004-03-04 08:14:43.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/Documentation/crypto/api-intro.txt	2004-03-22 06:38:12.000000000 +0000
@@ -187,6 +187,7 @@ Original developers of the crypto algori
   Brian Gladman (AES)
   Kartikey Mahendra Bhatt (CAST6)
   Jon Oberheide (ARC4)
+  Jouni Malinen (Michael MIC)
 
 SHA1 algorithm contributors:
   Jean-Francois Dive
diff -purN linux-post-2.6.5-rc2-20040320/Makefile linux-post-2.6.5-rc2-20040323/Makefile
--- linux-post-2.6.5-rc2-20040320/Makefile	2004-03-20 00:09:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/Makefile	2004-03-21 08:00:57.000000000 +0000
@@ -563,7 +563,7 @@ $(sort $(vmlinux-objs)) arch/$(ARCH)/ker
 # 	Handle descending into subdirectories listed in $(SUBDIRS)
 
 .PHONY: $(SUBDIRS)
-$(SUBDIRS): prepare-all
+$(SUBDIRS): prepare-all scripts
 	$(Q)$(MAKE) $(build)=$@
 
 # Things we need to do before we recursively start building the kernel
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/configs/g5_defconfig linux-post-2.6.5-rc2-20040323/arch/ppc64/configs/g5_defconfig
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/configs/g5_defconfig	2004-03-17 12:02:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/configs/g5_defconfig	2004-03-23 02:42:25.000000000 +0000
@@ -46,6 +46,7 @@ CONFIG_MODULE_FORCE_UNLOAD=y
 CONFIG_OBSOLETE_MODPARM=y
 # CONFIG_MODVERSIONS is not set
 # CONFIG_KMOD is not set
+CONFIG_STOP_MACHINE=y
 
 #
 # Platform support
@@ -100,6 +101,7 @@ CONFIG_PROC_DEVICETREE=y
 # Generic Driver Options
 #
 CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -126,10 +128,10 @@ CONFIG_FW_LOADER=y
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_CARMEL is not set
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_SIZE=8192
 CONFIG_BLK_DEV_INITRD=y
-# CONFIG_DCSSBLK is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -221,6 +223,12 @@ CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_LOGGING is not set
 
 #
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
 # SCSI low-level drivers
 #
 # CONFIG_BLK_DEV_3W_XXXX_RAID is not set
@@ -236,6 +244,7 @@ CONFIG_SCSI_SATA_SVW=y
 # CONFIG_SCSI_ATA_PIIX is not set
 # CONFIG_SCSI_SATA_PROMISE is not set
 # CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -295,6 +304,8 @@ CONFIG_IEEE1394=y
 #
 # CONFIG_IEEE1394_VERBOSEDEBUG is not set
 CONFIG_IEEE1394_OUI_DB=y
+CONFIG_IEEE1394_EXTRA_CONFIG_ROMS=y
+CONFIG_IEEE1394_CONFIG_ROM_IP1394=y
 
 #
 # Device Drivers
@@ -349,15 +360,72 @@ CONFIG_NET_IPIP=y
 # CONFIG_NET_IPGRE is not set
 # CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
-CONFIG_INET_ECN=y
+# CONFIG_INET_ECN is not set
 CONFIG_SYN_COOKIES=y
 CONFIG_INET_AH=m
 CONFIG_INET_ESP=m
 CONFIG_INET_IPCOMP=m
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
 # CONFIG_IPV6 is not set
 # CONFIG_DECNET is not set
 # CONFIG_BRIDGE is not set
-# CONFIG_NETFILTER is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+# CONFIG_IP_NF_FTP is not set
+# CONFIG_IP_NF_IRC is not set
+# CONFIG_IP_NF_TFTP is not set
+# CONFIG_IP_NF_AMANDA is not set
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_LIMIT=y
+CONFIG_IP_NF_MATCH_IPRANGE=y
+CONFIG_IP_NF_MATCH_MAC=y
+CONFIG_IP_NF_MATCH_PKTTYPE=y
+CONFIG_IP_NF_MATCH_MARK=y
+CONFIG_IP_NF_MATCH_MULTIPORT=y
+CONFIG_IP_NF_MATCH_TOS=y
+CONFIG_IP_NF_MATCH_RECENT=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_DSCP=y
+CONFIG_IP_NF_MATCH_AH_ESP=y
+CONFIG_IP_NF_MATCH_LENGTH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_TCPMSS=y
+CONFIG_IP_NF_MATCH_HELPER=y
+CONFIG_IP_NF_MATCH_STATE=y
+CONFIG_IP_NF_MATCH_CONNTRACK=y
+CONFIG_IP_NF_MATCH_OWNER=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_SAME=y
+# CONFIG_IP_NF_NAT_LOCAL is not set
+# CONFIG_IP_NF_NAT_SNMP_BASIC is not set
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_TOS=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_DSCP=y
+CONFIG_IP_NF_TARGET_MARK=y
+CONFIG_IP_NF_TARGET_CLASSIFY=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_TARGET_TCPMSS=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
 CONFIG_XFRM=y
 # CONFIG_XFRM_USER is not set
 
@@ -467,6 +535,7 @@ CONFIG_IBMOL=y
 # CONFIG_TMS380TR is not set
 # CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
 
 #
 # Wan interfaces
@@ -487,6 +556,8 @@ CONFIG_IBMOL=y
 # Bluetooth support
 #
 # CONFIG_BT is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -532,11 +603,13 @@ CONFIG_SERIO=y
 CONFIG_INPUT_KEYBOARD=y
 # CONFIG_KEYBOARD_ATKBD is not set
 # CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
 # CONFIG_KEYBOARD_XTKBD is not set
 # CONFIG_KEYBOARD_NEWTON is not set
 CONFIG_INPUT_MOUSE=y
 # CONFIG_MOUSE_PS2 is not set
 # CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
@@ -562,11 +635,6 @@ CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
 CONFIG_HVC_CONSOLE=y
-
-#
-# Mice
-#
-# CONFIG_BUSMOUSE is not set
 # CONFIG_QIC02_TAPE is not set
 
 #
@@ -578,7 +646,6 @@ CONFIG_HVC_CONSOLE=y
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-# CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
 # CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
@@ -629,28 +696,40 @@ CONFIG_I2C_KEYWEST=y
 # CONFIG_I2C_VOODOO3 is not set
 
 #
-# I2C Hardware Sensors Chip support
+# Hardware Sensors Chip support
 #
 # CONFIG_I2C_SENSOR is not set
 # CONFIG_SENSORS_ADM1021 is not set
 # CONFIG_SENSORS_ASB100 is not set
-# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_DS1621 is not set
 # CONFIG_SENSORS_FSCHER is not set
 # CONFIG_SENSORS_GL518SM is not set
 # CONFIG_SENSORS_IT87 is not set
 # CONFIG_SENSORS_LM75 is not set
 # CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
 # CONFIG_SENSORS_LM83 is not set
 # CONFIG_SENSORS_LM85 is not set
 # CONFIG_SENSORS_LM90 is not set
 # CONFIG_SENSORS_VIA686A is not set
 # CONFIG_SENSORS_W83781D is not set
 # CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
 # CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
 # CONFIG_I2C_DEBUG_BUS is not set
 # CONFIG_I2C_DEBUG_CHIP is not set
 
 #
+# Misc devices
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -664,6 +743,7 @@ CONFIG_I2C_KEYWEST=y
 # Graphics support
 #
 CONFIG_FB=y
+# CONFIG_FB_PM2 is not set
 # CONFIG_FB_CYBER2000 is not set
 CONFIG_FB_OF=y
 # CONFIG_FB_CONTROL is not set
@@ -731,6 +811,7 @@ CONFIG_USB_DEVICEFS=y
 # USB Host Controller Drivers
 #
 CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
 CONFIG_USB_OHCI_HCD=y
 # CONFIG_USB_UHCI_HCD is not set
 
@@ -739,9 +820,9 @@ CONFIG_USB_OHCI_HCD=y
 #
 # CONFIG_USB_BLUETOOTH_TTY is not set
 CONFIG_USB_ACM=m
-CONFIG_USB_PRINTER=m
-CONFIG_USB_STORAGE=m
-CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_PRINTER=y
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
 CONFIG_USB_STORAGE_DATAFAB=y
 CONFIG_USB_STORAGE_FREECOM=y
 CONFIG_USB_STORAGE_ISD200=y
@@ -765,7 +846,9 @@ CONFIG_USB_HIDDEV=y
 # CONFIG_USB_WACOM is not set
 # CONFIG_USB_KBTAB is not set
 # CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
 # CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
 
 #
 # USB Imaging devices
@@ -795,6 +878,7 @@ CONFIG_USB_USBNET=m
 #
 # USB Host-to-Host Cables
 #
+CONFIG_USB_ALI_M5632=y
 CONFIG_USB_AN2720=y
 CONFIG_USB_BELKIN=y
 CONFIG_USB_GENESYS=y
@@ -866,7 +950,6 @@ CONFIG_USB_EZUSB=y
 # CONFIG_USB_AUERSWALD is not set
 # CONFIG_USB_RIO500 is not set
 # CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_BRLVGER is not set
 # CONFIG_USB_LCD is not set
 # CONFIG_USB_LED is not set
 # CONFIG_USB_TEST is not set
@@ -961,12 +1044,13 @@ CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
 CONFIG_SUNRPC=y
-CONFIG_SUNRPC_GSS=m
-CONFIG_RPCSEC_GSS_KRB5=m
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
 # CONFIG_SMB_FS is not set
 CONFIG_CIFS=m
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -978,7 +1062,11 @@ CONFIG_PARTITION_ADVANCED=y
 # CONFIG_AMIGA_PARTITION is not set
 # CONFIG_ATARI_PARTITION is not set
 CONFIG_MAC_PARTITION=y
-# CONFIG_MSDOS_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
 # CONFIG_LDM_PARTITION is not set
 # CONFIG_NEC98_PARTITION is not set
 # CONFIG_SGI_PARTITION is not set
@@ -1059,18 +1147,20 @@ CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
 CONFIG_CRYPTO_NULL=m
 CONFIG_CRYPTO_MD4=m
-CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_MD5=y
 CONFIG_CRYPTO_SHA1=m
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
-CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_DES=y
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
 CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
 CONFIG_CRYPTO_CAST5=m
 CONFIG_CRYPTO_CAST6=m
+# CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
 CONFIG_CRYPTO_TEST=m
 
 #
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/chrp_setup.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/chrp_setup.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/chrp_setup.c	2004-02-27 23:02:35.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/chrp_setup.c	2004-03-22 05:48:50.000000000 +0000
@@ -88,14 +88,11 @@ extern unsigned long loops_per_jiffy;
 extern unsigned long ppc_proc_freq;
 extern unsigned long ppc_tb_freq;
 
-void 
-chrp_get_cpuinfo(struct seq_file *m)
+void chrp_get_cpuinfo(struct seq_file *m)
 {
 	struct device_node *root;
 	const char *model = "";
 
-	seq_printf(m, "timebase\t: %lu\n", ppc_tb_freq);
-
 	root = of_find_node_by_path("/");
 	if (root)
 		model = get_property(root, "model", NULL);
@@ -209,15 +206,17 @@ void __init fwnmi_init(void)
 		fwnmi_active = 1;
 }
 
-
 /* Early initialization.  Relocation is on but do not reference unbolted pages */
 void __init pSeries_init_early(void)
 {
-#ifdef CONFIG_PPC_PSERIES	/* This ifdef should go away */
 	void *comport;
 
 	hpte_init_pSeries();
-	tce_init_pSeries();
+
+	if (ppc64_iommu_off)
+		pci_dma_init_direct();
+	else
+		tce_init_pSeries();
 
 #ifdef CONFIG_SMP
 	smp_init_pSeries();
@@ -230,7 +229,6 @@ void __init pSeries_init_early(void)
 	ppc_md.udbg_putc = udbg_putc;
 	ppc_md.udbg_getc = udbg_getc;
 	ppc_md.udbg_getc_poll = udbg_getc_poll;
-#endif
 }
 
 void __init
@@ -253,7 +251,6 @@ chrp_init(unsigned long r3, unsigned lon
 #endif
 
 	ppc_md.setup_arch     = chrp_setup_arch;
-	ppc_md.setup_residual = NULL;
 	ppc_md.get_cpuinfo    = chrp_get_cpuinfo;
 	if(naca->interrupt_controller == IC_OPEN_PIC) {
 		ppc_md.init_IRQ       = pSeries_init_openpic; 
@@ -418,46 +415,64 @@ chrp_progress(char *s, unsigned short he
 
 extern void setup_default_decr(void);
 
+/* Some sane defaults: 125 MHz timebase, 1GHz processor */
+#define DEFAULT_TB_FREQ		125000000UL
+#define DEFAULT_PROC_FREQ	(DEFAULT_TB_FREQ * 8)
+
 void __init pSeries_calibrate_decr(void)
 {
 	struct device_node *cpu;
 	struct div_result divres;
-	int *fp;
-	unsigned long freq, processor_freq;
+	unsigned int *fp;
+	int node_found;
 
 	/*
 	 * The cpu node should have a timebase-frequency property
 	 * to tell us the rate at which the decrementer counts.
 	 */
-	freq = 16666000;        /* hardcoded default */
 	cpu = of_find_node_by_type(NULL, "cpu");
+
+	ppc_tb_freq = DEFAULT_TB_FREQ;		/* hardcoded default */
+	node_found = 0;
 	if (cpu != 0) {
-		fp = (int *) get_property(cpu, "timebase-frequency", NULL);
-		if (fp != 0)
-			freq = *fp;
+		fp = (unsigned int *)get_property(cpu, "timebase-frequency",
+						  NULL);
+		if (fp != 0) {
+			node_found = 1;
+			ppc_tb_freq = *fp;
+		}
 	}
-	ppc_tb_freq = freq;
-	processor_freq = freq;
+	if (!node_found)
+		printk(KERN_ERR "WARNING: Estimating decrementer frequency "
+				"(not found)\n");
+
+	ppc_proc_freq = DEFAULT_PROC_FREQ;
+	node_found = 0;
 	if (cpu != 0) {
-		fp = (int *) get_property(cpu, "clock-frequency", NULL);
-		if (fp != 0)
-			processor_freq = *fp;
+		fp = (unsigned int *)get_property(cpu, "clock-frequency",
+						  NULL);
+		if (fp != 0) {
+			node_found = 1;
+			ppc_proc_freq = *fp;
+		}
 	}
-	ppc_proc_freq = processor_freq;
+	if (!node_found)
+		printk(KERN_ERR "WARNING: Estimating processor frequency "
+				"(not found)\n");
+
 	of_node_put(cpu);
 
-	printk("time_init: decrementer frequency = %lu.%.6lu MHz\n",
-	       freq/1000000, freq%1000000);
-	printk("time_init: processor frequency   = %lu.%.6lu MHz\n",
-	       processor_freq/1000000, processor_freq%1000000);
+	printk(KERN_INFO "time_init: decrementer frequency = %lu.%.6lu MHz\n",
+	       ppc_tb_freq/1000000, ppc_tb_freq%1000000);
+	printk(KERN_INFO "time_init: processor frequency   = %lu.%.6lu MHz\n",
+	       ppc_proc_freq/1000000, ppc_proc_freq%1000000);
 
-	tb_ticks_per_jiffy = freq / HZ;
+	tb_ticks_per_jiffy = ppc_tb_freq / HZ;
 	tb_ticks_per_sec = tb_ticks_per_jiffy * HZ;
-	tb_ticks_per_usec = freq / 1000000;
-	tb_to_us = mulhwu_scale_factor(freq, 1000000);
-	div128_by_32( 1024*1024, 0, tb_ticks_per_sec, &divres );
+	tb_ticks_per_usec = ppc_tb_freq / 1000000;
+	tb_to_us = mulhwu_scale_factor(ppc_tb_freq, 1000000);
+	div128_by_32(1024*1024, 0, tb_ticks_per_sec, &divres);
 	tb_to_xs = divres.result_low;
 
 	setup_default_decr();
 }
-
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/iSeries_pci.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/iSeries_pci.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/iSeries_pci.c	2004-03-16 11:30:37.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/iSeries_pci.c	2004-03-21 10:27:39.000000000 +0000
@@ -103,47 +103,6 @@ static void pci_Log_Error(char *Error_Te
 	       Error_Text, Bus, SubBus, AgentId, HvRc);
 }
 
-#if 0
-/*
- * Dump the iSeries Temp Device Node 
- * <4>buswalk [swapper : - DeviceNode: 0xC000000000634300
- * <4>00. Device Node   = 0xC000000000634300
- * <4>    - PciDev      = 0x0000000000000000
- * <4>    - tDevice     = 0x  17:01.00  0x1022 00
- * <4>  4. Device Node = 0xC000000000634480
- * <4>     - PciDev    = 0x0000000000000000
- * <4>     - Device    = 0x  18:38.16 Irq:0xA7 Vendor:0x1014  Flags:0x00
- * <4>     - Devfn     = 0xB0: 22.18
- */
-void dumpDevice_Node(struct iSeries_Device_Node *DevNode)
-{
-	udbg_printf("Device Node      = 0x%p\n", DevNode);
-	udbg_printf("     - PciDev    = 0x%p\n", DevNode->PciDev);
-	udbg_printf("     - Device    = 0x%4X:%02X.%02X (0x%02X)\n",
-			ISERIES_BUS(DevNode), ISERIES_SUBBUS(DevNode),
-			DevNode->AgentId, DevNode->DevFn);
-	udbg_printf("     - LSlot     = 0x%02X\n", DevNode->LogicalSlot);
-	udbg_printf("     - TceTable  = 0x%p\n  ", DevNode->DevTceTable);
-	udbg_printf("     - DSA       = 0x%04X\n", ISERIES_DSA(DevNode) >> 32);
-	udbg_printf("                 = Irq:0x%02X Vendor:0x%04X  Flags:0x%02X\n",
-			DevNode->Irq, DevNode->Vendor, DevNode->Flags);
-	udbg_printf("     - Location  = %s\n", DevNode->CardLocation);
-}
-
-/*
- * Walk down the device node chain 
- */
-static void list_device_nodes(void)
-{
-	struct list_head *Device_Node_Ptr = iSeries_Global_Device_List.next;
-
-	while (Device_Node_Ptr != &iSeries_Global_Device_List) {
-		dumpDevice_Node((struct iSeries_Device_Node*)Device_Node_Ptr);
-		Device_Node_Ptr = Device_Node_Ptr->next;
-	}
-}
-#endif
-
 /*
  * build_device_node(u16 Bus, int SubBus, u8 DevFn)
  */
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/iSeries_setup.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/iSeries_setup.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/iSeries_setup.c	2004-03-16 11:30:38.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/iSeries_setup.c	2004-03-21 10:27:41.000000000 +0000
@@ -311,7 +311,6 @@ void __init iSeries_init_early(void)
 	iSeries_recal_titan = HvCallXm_loadTod();
 
 	ppc_md.setup_arch = iSeries_setup_arch;
-	ppc_md.setup_residual = iSeries_setup_residual;
 	ppc_md.get_cpuinfo = iSeries_get_cpuinfo;
 	ppc_md.init_IRQ = iSeries_init_IRQ;
 	ppc_md.get_irq = iSeries_get_irq;
@@ -726,29 +725,6 @@ void __init iSeries_setup_arch(void)
 	printk("Processor version = %x\n", systemcfg->processor);
 }
 
-/*
- * int as400_setup_residual()
- *
- * Description:
- *   This routine pretty-prints CPU information gathered from the VPD    
- *   for use in /proc/cpuinfo                               
- *
- * Input(s):
- *  *buffer - Buffer into which CPU data is to be printed.             
- *
- * Output(s):
- *  *buffer - Buffer with CPU data.
- */
-void iSeries_setup_residual(struct seq_file *m, int cpu_id)
-{
-	seq_printf(m, "clock\t\t: %lu.%02luMhz\n", procFreqMhz,
-			procFreqMhzHundreths);
-	seq_printf(m, "time base\t: %lu.%02luMHz\n", tbFreqMhz,
-			tbFreqMhzHundreths);
-	seq_printf(m, "i-cache\t\t: %d\n", systemcfg->iCacheL1LineSize);
-	seq_printf(m, "d-cache\t\t: %d\n", systemcfg->dCacheL1LineSize);
-}
-
 void iSeries_get_cpuinfo(struct seq_file *m)
 {
 	seq_printf(m, "machine\t\t: 64-bit iSeries Logical Partition\n");
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/ioctl32.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/ioctl32.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/ioctl32.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/ioctl32.c	2004-03-21 10:27:18.000000000 +0000
@@ -346,9 +346,6 @@ COMPATIBLE_IOCTL(TCSBRKP)
 COMPATIBLE_IOCTL(TIOCSTART)
 COMPATIBLE_IOCTL(TIOCSTOP)
 COMPATIBLE_IOCTL(TIOCSLTC)
-#if 0
-COMPATIBLE_IOCTL(FBIOBLANK)
-#endif
 /* Little p (/dev/rtc, /dev/envctrl, etc.) */
 COMPATIBLE_IOCTL(_IOR('p', 20, int[7])) /* RTCGET */
 COMPATIBLE_IOCTL(_IOW('p', 21, int[7])) /* RTCSET */
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/iommu.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/iommu.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/iommu.c	2004-03-03 13:26:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/iommu.c	2004-03-22 10:44:59.000000000 +0000
@@ -73,7 +73,7 @@ static unsigned long iommu_range_alloc(s
 	if (unlikely(npages) == 0) {
 		if (printk_ratelimit())
 			WARN_ON(1);
-		return NO_TCE;
+		return PCI_DMA_ERROR_CODE;
 	}
 
 	if (handle && *handle)
@@ -109,7 +109,7 @@ static unsigned long iommu_range_alloc(s
 			goto again;
 		} else {
 			/* Third failure, give up */
-			return NO_TCE;
+			return PCI_DMA_ERROR_CODE;
 		}
 	}
 
@@ -143,15 +143,15 @@ dma_addr_t iommu_alloc(struct iommu_tabl
 		       unsigned int npages, int direction)
 {
 	unsigned long entry, flags;
-	dma_addr_t ret = NO_TCE;
+	dma_addr_t ret = PCI_DMA_ERROR_CODE;
 	
 	spin_lock_irqsave(&(tbl->it_lock), flags);
 
 	entry = iommu_range_alloc(tbl, npages, NULL);
 
-	if (unlikely(entry == NO_TCE)) {
+	if (unlikely(entry == PCI_DMA_ERROR_CODE)) {
 		spin_unlock_irqrestore(&(tbl->it_lock), flags);
-		return NO_TCE;
+		return PCI_DMA_ERROR_CODE;
 	}
 
 	entry += tbl->it_offset;	/* Offset into real TCE table */
@@ -262,7 +262,7 @@ int iommu_alloc_sg(struct iommu_table *t
 		DBG("  - vaddr: %lx, size: %lx\n", vaddr, slen);
 
 		/* Handle failure */
-		if (unlikely(entry == NO_TCE)) {
+		if (unlikely(entry == PCI_DMA_ERROR_CODE)) {
 			if (printk_ratelimit())
 				printk(KERN_INFO "iommu_alloc failed, tbl %p vaddr %lx"
 				       " npages %lx\n", tbl, vaddr, npages);
@@ -326,7 +326,7 @@ int iommu_alloc_sg(struct iommu_table *t
 	 */
 	if (outcount < nelems) {
 		outs++;
-		outs->dma_address = NO_TCE;
+		outs->dma_address = PCI_DMA_ERROR_CODE;
 		outs->dma_length = 0;
 	}
 	return outcount;
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/pSeries_pci.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/pSeries_pci.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/pSeries_pci.c	2004-02-27 23:02:35.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/pSeries_pci.c	2004-03-22 05:48:50.000000000 +0000
@@ -699,7 +699,8 @@ void __init pSeries_final_fixup(void)
 	phbs_fixup_io();
 	chrp_request_regions();
 	pci_fix_bus_sysdata();
-	iommu_setup_pSeries();
+	if (!ppc64_iommu_off)
+		iommu_setup_pSeries();
 }
 
 /*********************************************************************** 
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/pci_iommu.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/pci_iommu.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/pci_iommu.c	2004-03-03 13:26:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/pci_iommu.c	2004-03-22 10:44:59.000000000 +0000
@@ -82,7 +82,7 @@ void *pci_iommu_alloc_consistent(struct 
 	if (order >= IOMAP_MAX_ORDER) {
 		printk("PCI_DMA: pci_alloc_consistent size too large: 0x%lx\n",
 			size);
-		return (void *)NO_TCE;
+		return (void *)PCI_DMA_ERROR_CODE;
 	}
 
 	tbl = devnode_table(hwdev); 
@@ -101,7 +101,7 @@ void *pci_iommu_alloc_consistent(struct 
 	/* Set up tces to cover the allocated range */
 	mapping = iommu_alloc(tbl, ret, npages, PCI_DMA_BIDIRECTIONAL);
 
-	if (mapping == NO_TCE) {
+	if (mapping == PCI_DMA_ERROR_CODE) {
 		free_pages((unsigned long)ret, order);
 		ret = NULL;
 	} else
@@ -139,7 +139,7 @@ dma_addr_t pci_iommu_map_single(struct p
 				size_t size, int direction)
 {
 	struct iommu_table * tbl;
-	dma_addr_t dma_handle = NO_TCE;
+	dma_addr_t dma_handle = PCI_DMA_ERROR_CODE;
 	unsigned long uaddr;
 	unsigned int npages;
 
@@ -153,7 +153,7 @@ dma_addr_t pci_iommu_map_single(struct p
 
 	if (tbl) {
 		dma_handle = iommu_alloc(tbl, vaddr, npages, direction);
-		if (dma_handle == NO_TCE) {
+		if (dma_handle == PCI_DMA_ERROR_CODE) {
 			if (printk_ratelimit())  {
 				printk(KERN_INFO "iommu_alloc failed, tbl %p vaddr %p npages %d\n",
 				       tbl, vaddr, npages);
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/pmac_setup.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/pmac_setup.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/pmac_setup.c	2004-03-03 10:51:22.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/pmac_setup.c	2004-03-21 10:27:41.000000000 +0000
@@ -95,7 +95,6 @@ void __pmac pmac_show_cpuinfo(struct seq
 					PMAC_MB_INFO_MODEL, 0);
 	unsigned int mbflags = pmac_call_feature(PMAC_FTR_GET_MB_INFO, NULL,
 						 PMAC_MB_INFO_FLAGS, 0);
-	extern unsigned long ppc_tb_freq;
 
 	if (pmac_call_feature(PMAC_FTR_GET_MB_INFO, NULL, PMAC_MB_INFO_NAME,
 			      (long)&mbname) != 0)
@@ -130,9 +129,6 @@ void __pmac pmac_show_cpuinfo(struct seq
 
 	/* Indicate newworld */
 	seq_printf(m, "pmac-generation\t: NewWorld\n");
-
-	/* Indicate timebase value */
-	seq_printf(m, "timebase\t: %lu\n", ppc_tb_freq);
 }
 
 
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/pmac_time.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/pmac_time.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/pmac_time.c	2004-03-04 10:21:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/pmac_time.c	2004-03-21 10:27:41.000000000 +0000
@@ -40,6 +40,7 @@
 extern void setup_default_decr(void);
 
 extern unsigned long ppc_tb_freq;
+extern unsigned long ppc_proc_freq;
 
 /* Apparently the RTC stores seconds since 1 Jan 1904 */
 #define RTC_OFFSET	2082844800
@@ -155,6 +156,11 @@ void __init pmac_calibrate_decr(void)
 	tb_to_xs = divres.result_low;
 	ppc_tb_freq = freq;
 
+	fp = (unsigned int *)get_property(cpu, "clock-frequency", NULL);
+	if (fp == 0)
+		panic("can't get cpu processor frequency");
+	ppc_proc_freq = *fp;
+
 	setup_default_decr();
 }
 
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/prom.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/prom.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/prom.c	2004-03-19 05:59:30.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/prom.c	2004-03-22 10:17:13.000000000 +0000
@@ -525,25 +525,16 @@ prom_initialize_naca(unsigned long mem)
 	return mem;
 }
 
-#ifdef CONFIG_PMAC_DART
-static int dart_force_on;
-#endif
+static int iommu_force_on;
+int ppc64_iommu_off;
 
-static unsigned long __init
-prom_initialize_lmb(unsigned long mem)
+static void early_cmdline_parse(void)
 {
-	phandle node;
-	char type[64];
-        unsigned long i, offset = reloc_offset();
-	struct prom_t *_prom = PTRRELOC(&prom);
-        struct systemcfg *_systemcfg = RELOC(systemcfg);
-	union lmb_reg_property reg;
-	unsigned long lmb_base, lmb_size;
-	unsigned long num_regs, bytes_per_reg = (_prom->encode_phys_size*2)/8;
-	int nodart = 0;
-
-#ifdef CONFIG_PMAC_DART
+	unsigned long offset = reloc_offset();
 	char *opt;
+#ifndef CONFIG_PMAC_DART
+	struct systemcfg *_systemcfg = RELOC(systemcfg);
+#endif
 
 	opt = strstr(RELOC(cmd_line), RELOC("iommu="));
 	if (opt) {
@@ -554,16 +545,30 @@ prom_initialize_lmb(unsigned long mem)
 		while (*opt && *opt == ' ')
 			opt++;
 		if (!strncmp(opt, RELOC("off"), 3))
-			nodart = 1;
+			RELOC(ppc64_iommu_off) = 1;
 		else if (!strncmp(opt, RELOC("force"), 5))
-			RELOC(dart_force_on) = 1;
+			RELOC(iommu_force_on) = 1;
 	}
-#else
-	nodart = 1;
-#endif /* CONFIG_PMAC_DART */
 
-	if (nodart)
+#ifndef CONFIG_PMAC_DART
+	if (_systemcfg->platform == PLATFORM_POWERMAC) {
+		RELOC(ppc64_iommu_off) = 1;
 		prom_print(RELOC("DART disabled on PowerMac !\n"));
+	}
+#endif
+}
+
+static unsigned long __init
+prom_initialize_lmb(unsigned long mem)
+{
+	phandle node;
+	char type[64];
+        unsigned long i, offset = reloc_offset();
+	struct prom_t *_prom = PTRRELOC(&prom);
+        struct systemcfg *_systemcfg = RELOC(systemcfg);
+	union lmb_reg_property reg;
+	unsigned long lmb_base, lmb_size;
+	unsigned long num_regs, bytes_per_reg = (_prom->encode_phys_size*2)/8;
 
 	lmb_init();
 
@@ -589,11 +594,6 @@ prom_initialize_lmb(unsigned long mem)
 				lmb_base = ((unsigned long)reg.addrPM[i].address_hi) << 32;
 				lmb_base |= (unsigned long)reg.addrPM[i].address_lo;
 				lmb_size = reg.addrPM[i].size;
-				if (nodart && lmb_base > 0x80000000ull) {
-					prom_print(RELOC("Skipping memory above 2Gb for "
-							 "now, DART support disabled\n"));
-					continue;
-				}
 			} else if (_prom->encode_phys_size == 32) {
 				lmb_base = reg.addr32[i].address;
 				lmb_size = reg.addr32[i].size;
@@ -602,7 +602,16 @@ prom_initialize_lmb(unsigned long mem)
 				lmb_size = reg.addr64[i].size;
 			}
 
-			if ( lmb_add(lmb_base, lmb_size) < 0 )
+			/* We limit memory to 2GB if the IOMMU is off */
+			if (RELOC(ppc64_iommu_off)) {
+				if (lmb_base >= 0x80000000UL)
+					continue;
+
+				if ((lmb_base + lmb_size) > 0x80000000UL)
+					lmb_size = 0x80000000UL - lmb_base;
+			}
+
+			if (lmb_add(lmb_base, lmb_size) < 0)
 				prom_print(RELOC("Too many LMB's, discarding this one...\n"));
 		}
 
@@ -780,7 +789,7 @@ void prom_initialize_dart_table(void)
 	/* Only reserve DART space if machine has more than 2GB of RAM
 	 * or if requested with iommu=on on cmdline.
 	 */
-	if (lmb_end_of_DRAM() <= 0x80000000ull && !RELOC(dart_force_on))
+	if (lmb_end_of_DRAM() <= 0x80000000ull && !RELOC(iommu_force_on))
 		return;
 
 	/* 512 pages is max DART tablesize. */
@@ -811,6 +820,9 @@ prom_initialize_tce_table(void)
 	struct of_tce_table *prom_tce_table = RELOC(of_tce_table);
 	unsigned long tce_entry, *tce_entryp;
 
+	if (RELOC(ppc64_iommu_off))
+		return;
+
 #ifdef DEBUG_PROM
 	prom_print(RELOC("starting prom_initialize_tce_table\n"));
 #endif
@@ -930,16 +942,15 @@ prom_initialize_tce_table(void)
                              path, sizeof(path)-1) <= 0) {
                         prom_print(RELOC("package-to-path failed\n"));
                 } else {
-                        prom_print(RELOC("opened "));
+                        prom_print(RELOC("opening PHB "));
                         prom_print(path);
-                        prom_print_nl();
                 }
 
                 phb_node = (ihandle)call_prom(RELOC("open"), 1, 1, path);
                 if ( (long)phb_node <= 0) {
-                        prom_print(RELOC("open failed\n"));
+                        prom_print(RELOC("... failed\n"));
                 } else {
-                        prom_print(RELOC("open success\n"));
+                        prom_print(RELOC("... done\n"));
                 }
                 call_prom(RELOC("call-method"), 6, 0,
                              RELOC("set-64-bit-addressing"),
@@ -1136,7 +1147,7 @@ prom_hold_cpus(unsigned long mem)
 			prom_print_hex(cpuid);
 			prom_print(RELOC(" : starting cpu "));
 			prom_print(path);
-			prom_print(RELOC("..."));
+			prom_print(RELOC("... "));
 			call_prom(RELOC("start-cpu"), 3, 0, node, 
 				  secondary_hold, cpuid);
 
@@ -1144,7 +1155,7 @@ prom_hold_cpus(unsigned long mem)
 			      (*acknowledge == ((unsigned long)-1)); i++ ) ;
 
 			if (*acknowledge == cpuid) {
-				prom_print(RELOC("ok\n"));
+				prom_print(RELOC("... done\n"));
 				/* We have to get every CPU out of OF,
 				 * even if we never start it. */
 				if (cpuid >= NR_CPUS)
@@ -1157,10 +1168,9 @@ prom_hold_cpus(unsigned long mem)
 				cpu_set(cpuid, RELOC(cpu_present_at_boot));
 #endif
 			} else {
-				prom_print(RELOC("failed: "));
+				prom_print(RELOC("... failed: "));
 				prom_print_hex(*acknowledge);
 				prom_print_nl();
-				/* prom_panic(RELOC("cpu failed to start")); */
 			}
 		}
 #ifdef CONFIG_SMP
@@ -1583,6 +1593,8 @@ prom_init(unsigned long r3, unsigned lon
 			strlcpy(RELOC(cmd_line), p, sizeof(cmd_line));
 	}
 
+	early_cmdline_parse();
+
 	mem = prom_initialize_lmb(mem);
 
 	mem = prom_bi_rec_reserve(mem);
@@ -1691,7 +1703,7 @@ check_display(unsigned long mem)
 
 	prom_print(RELOC("Looking for displays\n"));
 	if (RELOC(of_stdout_device) != 0) {
-		prom_print(RELOC("OF stdout is   : "));
+		prom_print(RELOC("OF stdout is    : "));
 		prom_print(PTRRELOC(RELOC(of_stdout_device)));
 		prom_print(RELOC("\n"));
 	}
@@ -1751,7 +1763,7 @@ check_display(unsigned long mem)
 			continue;
 		}
 
-		prom_print(RELOC("... ok\n"));
+		prom_print(RELOC("... done\n"));
 
 		/* Setup a useable color table when the appropriate
 		 * method is available. Should update this to set-colors */
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/rtas.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/rtas.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/rtas.c	2004-03-16 11:30:38.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/rtas.c	2004-03-21 10:27:37.000000000 +0000
@@ -130,7 +130,7 @@ rtas_token(const char *service)
 void
 log_rtas_error(struct rtas_args	*rtas_args)
 {
-	struct rtas_args err_args;
+	struct rtas_args err_args, temp_args;
 
 	err_args.token = rtas_token("rtas-last-error");
 	err_args.nargs = 2;
@@ -141,6 +141,7 @@ log_rtas_error(struct rtas_args	*rtas_ar
 	err_args.args[1] = RTAS_ERROR_LOG_MAX;
 	err_args.args[2] = 0;
 
+	temp_args = *rtas_args;
 	get_paca()->xRtas = err_args;
 
 	PPCDBG(PPCDBG_RTAS, "\tentering rtas with 0x%lx\n",
@@ -148,8 +149,9 @@ log_rtas_error(struct rtas_args	*rtas_ar
 	enter_rtas((void *)__pa((unsigned long)&get_paca()->xRtas));
 	PPCDBG(PPCDBG_RTAS, "\treturned from rtas ...\n");
 
+
 	err_args = get_paca()->xRtas;
-	get_paca()->xRtas = *rtas_args;
+	get_paca()->xRtas = temp_args;
 
 	if (err_args.rets[0] == 0)
 		log_error(rtas_err_buf, ERR_TYPE_RTAS_LOG, 0);
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/setup.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/setup.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/setup.c	2004-02-23 16:39:09.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/setup.c	2004-03-21 10:27:41.000000000 +0000
@@ -330,6 +330,7 @@ static int show_cpuinfo(struct seq_file 
 	unsigned short min;
 
 	if (cpu_id == NR_CPUS) {
+		seq_printf(m, "timebase\t: %lu\n", ppc_tb_freq);
 
 		if (ppc_md.get_cpuinfo != NULL)
 			ppc_md.get_cpuinfo(m);
@@ -363,29 +364,12 @@ static int show_cpuinfo(struct seq_file 
 
 	seq_printf(m, "\n");
 
-#ifdef CONFIG_PPC_PSERIES
 	/*
 	 * Assume here that all clock rates are the same in a
 	 * smp system.  -- Cort
 	 */
-	if (systemcfg->platform != PLATFORM_ISERIES_LPAR) {
-		struct device_node *cpu_node;
-		int *fp;
-
-		cpu_node = of_find_node_by_type(NULL, "cpu");
-		if (cpu_node) {
-			fp = (int *) get_property(cpu_node, "clock-frequency",
-						  NULL);
-			if (fp)
-				seq_printf(m, "clock\t\t: %dMHz\n",
-					   *fp / 1000000);
-			of_node_put(cpu_node);
-		}
-	}
-#endif
-
-	if (ppc_md.setup_residual != NULL)
-		ppc_md.setup_residual(m, cpu_id);
+	seq_printf(m, "clock\t\t: %lu.%06luMHz\n", ppc_proc_freq / 1000000,
+		   ppc_proc_freq % 1000000);
 
 	seq_printf(m, "revision\t: %hd.%hd\n\n", maj, min);
 	
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/vio.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/vio.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/vio.c	2004-03-16 11:30:36.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/vio.c	2004-03-22 10:44:59.000000000 +0000
@@ -419,7 +419,7 @@ dma_addr_t vio_map_single(struct vio_dev
 			  size_t size, int direction )
 {
 	struct iommu_table *tbl;
-	dma_addr_t dma_handle = NO_TCE;
+	dma_addr_t dma_handle = PCI_DMA_ERROR_CODE;
 	unsigned long uaddr;
 	unsigned int npages;
 
@@ -504,7 +504,7 @@ void *vio_alloc_consistent(struct vio_de
 	/* It is easier to debug here for the drivers than in the tce tables.*/
  	if(order >= IOMAP_MAX_ORDER) {
  		printk("VIO_DMA: vio_alloc_consistent size to large: 0x%lx \n", size);
- 		return (void *)NO_TCE;
+ 		return (void *)PCI_DMA_ERROR_CODE;
  	}
 
 	tbl = dev->iommu_table;
@@ -517,7 +517,7 @@ void *vio_alloc_consistent(struct vio_de
 			memset(ret, 0, npages << PAGE_SHIFT);
 			/* Set up tces to cover the allocated range */
 			tce = iommu_alloc(tbl, ret, npages, PCI_DMA_BIDIRECTIONAL);
-			if (tce == NO_TCE) {
+			if (tce == PCI_DMA_ERROR_CODE) {
 				PPCDBG(PPCDBG_TCE, "vio_alloc_consistent: iommu_alloc failed\n" );
 				free_pages((unsigned long)ret, order);
 				ret = NULL;
diff -purN linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/viopath.c linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/viopath.c
--- linux-post-2.6.5-rc2-20040320/arch/ppc64/kernel/viopath.c	2004-03-16 11:30:38.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/ppc64/kernel/viopath.c	2004-03-19 07:10:24.000000000 +0000
@@ -105,6 +105,9 @@ EXPORT_SYMBOL(viopath_ourLp);
  */
 static vio_event_handler_t *vio_handler[VIO_MAX_SUBTYPES];
 
+#define VIOPATH_KERN_WARN	KERN_WARNING "viopath: "
+#define VIOPATH_KERN_INFO	KERN_INFO "viopath: "
+
 static unsigned char e2a(unsigned char x)
 {
 	switch (x) {
@@ -209,7 +212,7 @@ static int proc_viopath_show(struct seq_
 			((u64)handle) << 32, PAGE_SIZE, 0, 0);
 
 	if (hvrc != HvLpEvent_Rc_Good)
-		printk("viopath hv error on op %d\n", (int)hvrc);
+		printk(VIOPATH_KERN_WARN "hv error on op %d\n", (int)hvrc);
 
 	down(&Semaphore);
 
@@ -318,7 +321,7 @@ static void sendMonMsg(HvLpIndex remoteL
 	if (hvrc == HvLpEvent_Rc_Good)
 		viopathStatus[remoteLp].isActive = 1;
 	else {
-		printk(KERN_WARNING_VIO "could not connect to partition %d\n",
+		printk(VIOPATH_KERN_WARN "could not connect to partition %d\n",
 				remoteLp);
 		viopathStatus[remoteLp].isActive = 0;
 	}
@@ -355,11 +358,11 @@ static void handleMonitorEvent(struct Hv
 	remoteLp = event->xTargetLp;
 	if ((event->xSourceInstanceId != viopathStatus[remoteLp].mSourceInst) ||
 	    (event->xTargetInstanceId != viopathStatus[remoteLp].mTargetInst)) {
-		printk(KERN_WARNING_VIO "ignoring ack....mismatched instances\n");
+		printk(VIOPATH_KERN_WARN "ignoring ack....mismatched instances\n");
 		return;
 	}
 
-	printk(KERN_WARNING_VIO "partition %d ended\n", remoteLp);
+	printk(VIOPATH_KERN_WARN "partition %d ended\n", remoteLp);
 
 	viopathStatus[remoteLp].isActive = 0;
 
@@ -403,7 +406,7 @@ static void handleConfig(struct HvLpEven
 	if (!event)
 		return;
 	if (event->xFlags.xFunction == HvLpEvent_Function_Int) {
-		printk(KERN_WARNING_VIO
+		printk(VIOPATH_KERN_WARN
 		       "unexpected config request from partition %d",
 		       event->xSourceLp);
 
@@ -461,7 +464,7 @@ static void vio_handleEvent(struct HvLpE
 		if (viopathStatus[remoteLp].isActive
 		    && (event->xSourceInstanceId !=
 			viopathStatus[remoteLp].mTargetInst)) {
-			printk(KERN_WARNING_VIO
+			printk(VIOPATH_KERN_WARN
 			       "message from invalid partition. "
 			       "int msg rcvd, source inst (%d) doesnt match (%d)\n",
 			       viopathStatus[remoteLp].mTargetInst,
@@ -472,7 +475,7 @@ static void vio_handleEvent(struct HvLpE
 		if (viopathStatus[remoteLp].isActive
 		    && (event->xTargetInstanceId !=
 			viopathStatus[remoteLp].mSourceInst)) {
-			printk(KERN_WARNING_VIO
+			printk(VIOPATH_KERN_WARN
 			       "message from invalid partition. "
 			       "int msg rcvd, target inst (%d) doesnt match (%d)\n",
 			       viopathStatus[remoteLp].mSourceInst,
@@ -483,7 +486,7 @@ static void vio_handleEvent(struct HvLpE
 		remoteLp = event->xTargetLp;
 		if (event->xSourceInstanceId !=
 		    viopathStatus[remoteLp].mSourceInst) {
-			printk(KERN_WARNING_VIO
+			printk(VIOPATH_KERN_WARN
 			       "message from invalid partition. "
 			       "ack msg rcvd, source inst (%d) doesnt match (%d)\n",
 			       viopathStatus[remoteLp].mSourceInst,
@@ -493,7 +496,7 @@ static void vio_handleEvent(struct HvLpE
 
 		if (event->xTargetInstanceId !=
 		    viopathStatus[remoteLp].mTargetInst) {
-			printk(KERN_WARNING_VIO
+			printk(VIOPATH_KERN_WARN
 			       "message from invalid partition. "
 			       "viopath: ack msg rcvd, target inst (%d) doesnt match (%d)\n",
 			       viopathStatus[remoteLp].mTargetInst,
@@ -503,7 +506,7 @@ static void vio_handleEvent(struct HvLpE
 	}
 
 	if (vio_handler[subtype] == NULL) {
-		printk(KERN_WARNING_VIO
+		printk(VIOPATH_KERN_WARN
 		       "unexpected virtual io event subtype %d from partition %d\n",
 		       event->xSubtype, remoteLp);
 		/* No handler.  Ack if necessary */
@@ -608,10 +611,10 @@ int viopath_open(HvLpIndex remoteLp, int
 		HvLpEvent_registerHandler(HvLpEvent_Type_VirtualIo,
 					  &vio_handleEvent);
 		sendMonMsg(remoteLp);
-		printk(KERN_INFO_VIO
-		       "Opening connection to partition %d, setting sinst %d, tinst %d\n",
-		       remoteLp, viopathStatus[remoteLp].mSourceInst,
-		       viopathStatus[remoteLp].mTargetInst);
+		printk(VIOPATH_KERN_INFO "opening connection to partition %d, "
+				"setting sinst %d, tinst %d\n",
+				remoteLp, viopathStatus[remoteLp].mSourceInst,
+				viopathStatus[remoteLp].mTargetInst);
 	}
 
 	spin_unlock_irqrestore(&statuslock, flags);
@@ -662,7 +665,7 @@ int viopath_close(HvLpIndex remoteLp, in
 		numOpen += viopathStatus[remoteLp].users[i];
 
 	if ((viopathStatus[remoteLp].isOpen) && (numOpen == 0)) {
-		printk(KERN_INFO_VIO "Closing connection to partition %d",
+		printk(VIOPATH_KERN_INFO "closing connection to partition %d",
 				remoteLp);
 
 		HvCallEvent_closeLpEventPath(remoteLp,
@@ -696,23 +699,21 @@ void vio_free_event_buffer(int subtype, 
 {
 	subtype = subtype >> VIOMAJOR_SUBTYPE_SHIFT;
 	if ((subtype < 0) || (subtype >= VIO_MAX_SUBTYPES)) {
-		printk(KERN_WARNING_VIO
-		       "unexpected subtype %d freeing event buffer\n",
-		       subtype);
+		printk(VIOPATH_KERN_WARN
+		       "unexpected subtype %d freeing event buffer\n", subtype);
 		return;
 	}
 
 	if (atomic_read(&event_buffer_available[subtype]) != 0) {
-		printk(KERN_WARNING_VIO
+		printk(VIOPATH_KERN_WARN
 		       "freeing unallocated event buffer, subtype %d\n",
 		       subtype);
 		return;
 	}
 
 	if (buffer != &event_buffer[subtype * 256]) {
-		printk(KERN_WARNING_VIO
-		       "freeing invalid event buffer, subtype %d\n",
-		       subtype);
+		printk(VIOPATH_KERN_WARN
+		       "freeing invalid event buffer, subtype %d\n", subtype);
 	}
 
 	atomic_set(&event_buffer_available[subtype], 1);
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/Makefile linux-post-2.6.5-rc2-20040323/arch/sparc/Makefile
--- linux-post-2.6.5-rc2-20040320/arch/sparc/Makefile	2004-02-20 07:55:22.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/Makefile	2004-03-22 00:57:30.000000000 +0000
@@ -67,7 +67,8 @@ include/asm-$(ARCH)/asm_offsets.h: arch/
 	$(call filechk,gen-asm-offsets)
 
 CLEAN_FILES +=	include/asm-$(ARCH)/asm_offsets.h	\
-		arch/$(ARCH)/kernel/asm-offsets.s
+		arch/$(ARCH)/kernel/asm-offsets.s	\
+		arch/$(ARCH)/boot/System.map
 
 # Don't use tabs in echo arguments.
 define archhelp
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/boot/Makefile linux-post-2.6.5-rc2-20040323/arch/sparc/boot/Makefile
--- linux-post-2.6.5-rc2-20040320/arch/sparc/boot/Makefile	2003-12-30 00:46:37.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/boot/Makefile	2004-03-22 00:57:30.000000000 +0000
@@ -32,6 +32,3 @@ $(obj)/tftpboot.img: $(obj)/piggyback $(
 
 $(obj)/btfix.s: $(obj)/btfixupprep vmlinux FORCE
 	$(call if_changed,btfix)
-
-clean:
-	rm $(obj)/System.map
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/entry.S linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/entry.S
--- linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/entry.S	2004-03-18 23:07:14.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/entry.S	2004-03-22 01:40:01.000000000 +0000
@@ -32,6 +32,7 @@
 #include <asm/obio.h>
 #include <asm/mxcc.h>
 #include <asm/thread_info.h>
+#include <asm/param.h>
 
 #include <asm/asmmacro.h>
 
@@ -1808,36 +1809,37 @@ fpload:
 	retl
 	 nop
 
-	.globl	ndelay
-ndelay:
+	/* __ndelay and __udelay take two arguments:
+	 * 0 - nsecs or usecs to delay
+	 * 1 - per_cpu udelay_val (loops per jiffy)
+	 *
+	 * Note that ndelay gives HZ times higher resolution but has a 10ms
+	 * limit.  udelay can handle up to 1s.
+	 */
+	.globl	__ndelay
+__ndelay:
 	save	%sp, -STACKFRAME_SZ, %sp
 	mov	%i0, %o0
 	call	.umul
-	 mov	5, %o1
+	 mov	0x1ad, %o1		! 2**32 / (1 000 000 000 / HZ)
+	call	.umul
+	 mov	%i1, %o1		! udelay_val
 	ba	delay_continue
-	 nop
+	 mov	%o1, %o0		! >>32 later for better resolution
 
-	.globl	udelay
-udelay:
+	.globl	__udelay
+__udelay:
 	save	%sp, -STACKFRAME_SZ, %sp
 	mov	%i0, %o0
 	sethi	%hi(0x10c6), %o1
 	call	.umul
-	 or	%o1, %lo(0x10c6), %o1
-delay_continue:
-#ifndef CONFIG_SMP
-	sethi	%hi(loops_per_jiffy), %o3
+	 or	%o1, %lo(0x10c6), %o1	! 2**32 / 1 000 000
 	call	.umul
-	 ld	[%o3 + %lo(loops_per_jiffy)], %o1
-#else
-	GET_PROCESSOR_OFFSET(o4, o2)
-	set	cpu_data, %o3
-	call	.umul
-	 ld	[%o3 + %o4], %o1
-#endif
+	 mov	%i1, %o1		! udelay_val
 	call	.umul
-	 mov	100, %o0
+	 mov	HZ, %o0			! >>32 earlier for wider range
 
+delay_continue:
 	cmp	%o0, 0x0
 1:
 	bne	1b
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/setup.c linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/setup.c
--- linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/setup.c	2004-03-15 00:45:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/setup.c	2004-03-21 22:43:34.000000000 +0000
@@ -331,6 +331,7 @@ void __init setup_arch(char **cmdline_p)
 		if (highest_paddr < top)
 			highest_paddr = top;
 	}
+	pfn_base = phys_base >> PAGE_SHIFT;
 
 	if (!root_flags)
 		root_mountflags &= ~MS_RDONLY;
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/smp.c linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/smp.c
--- linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/smp.c	2004-03-15 01:23:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/smp.c	2004-03-16 10:14:48.000000000 +0000
@@ -20,11 +20,11 @@
 #include <linux/fs.h>
 #include <linux/seq_file.h>
 #include <linux/cache.h>
+#include <linux/delay.h>
 
 #include <asm/ptrace.h>
 #include <asm/atomic.h>
 
-#include <asm/delay.h>
 #include <asm/irq.h>
 #include <asm/page.h>
 #include <asm/pgalloc.h>
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/sparc_ksyms.c linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/sparc_ksyms.c
--- linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/sparc_ksyms.c	2004-03-14 06:54:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/sparc_ksyms.c	2004-03-22 01:40:02.000000000 +0000
@@ -145,6 +145,7 @@ EXPORT_SYMBOL(__down_interruptible);
 
 EXPORT_SYMBOL(sparc_valid_addr_bitmap);
 EXPORT_SYMBOL(phys_base);
+EXPORT_SYMBOL(pfn_base);
 
 /* Atomic operations. */
 EXPORT_SYMBOL(___atomic24_add);
@@ -164,8 +165,8 @@ EXPORT_SYMBOL(__cpu_number_map);
 EXPORT_SYMBOL(__cpu_logical_map);
 #endif
 
-EXPORT_SYMBOL(udelay);
-EXPORT_SYMBOL(ndelay);
+EXPORT_SYMBOL(__udelay);
+EXPORT_SYMBOL(__ndelay);
 EXPORT_SYMBOL(rtc_lock);
 EXPORT_SYMBOL(mostek_lock);
 EXPORT_SYMBOL(mstk48t02_regs);
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/sun4d_smp.c linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/sun4d_smp.c
--- linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/sun4d_smp.c	2004-03-15 01:23:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/sun4d_smp.c	2004-03-16 10:14:48.000000000 +0000
@@ -49,7 +49,6 @@ static int smp_highest_cpu;
 extern int smp_threads_ready;
 extern volatile unsigned long cpu_callin_map[NR_CPUS];
 extern struct cpuinfo_sparc cpu_data[NR_CPUS];
-extern unsigned long cpu_offset[NR_CPUS];
 extern unsigned char boot_cpu_id;
 extern int smp_activated;
 extern volatile int __cpu_number_map[NR_CPUS];
@@ -171,9 +170,6 @@ void __init smp4d_boot_cpus(void)
 
 	printk("Entering SMP Mode...\n");
 	
-	for (i = 0; i < NR_CPUS; i++)
-		cpu_offset[i] = (char *)&(cpu_data(i)) - (char *)&(cpu_data(0));
-		
 	if (boot_cpu_id)
 		current_set[0] = NULL;
 
@@ -427,9 +423,6 @@ void smp4d_message_pass(int target, int 
 
 extern void sparc_do_profile(unsigned long pc, unsigned long o7);
 
-#define prof_multiplier(__cpu)		cpu_data(__cpu).multiplier
-#define prof_counter(__cpu)		cpu_data(__cpu).counter
-
 void smp4d_percpu_timer_interrupt(struct pt_regs *regs)
 {
 	int cpu = hard_smp4d_processor_id();
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/sun4m_smp.c linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/sun4m_smp.c
--- linux-post-2.6.5-rc2-20040320/arch/sparc/kernel/sun4m_smp.c	2004-03-15 01:23:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/kernel/sun4m_smp.c	2004-03-16 10:14:48.000000000 +0000
@@ -44,7 +44,6 @@ extern unsigned long cpu_present_map;
 extern int smp_num_cpus;
 extern int smp_threads_ready;
 extern volatile unsigned long cpu_callin_map[NR_CPUS];
-extern unsigned long cpu_offset[NR_CPUS];
 extern unsigned char boot_cpu_id;
 extern int smp_activated;
 extern volatile int __cpu_number_map[NR_CPUS];
@@ -152,9 +151,7 @@ void __init smp4m_boot_cpus(void)
 	for (i = 0; !cpu_find_by_instance(i, NULL, &mid); i++)
 		cpu_present_map |= (1<<mid);
 
-	/* XXX cpu_offset is broken -Keith */
 	for(i=0; i < NR_CPUS; i++) {
-		cpu_offset[i] = (char *)&(cpu_data(i)) - (char *)&(cpu_data(0));
 		__cpu_number_map[i] = -1;
 		__cpu_logical_map[i] = -1;
 	}
@@ -409,9 +406,6 @@ void smp4m_cross_call_irq(void)
 
 extern void sparc_do_profile(unsigned long pc, unsigned long o7);
 
-#define prof_multiplier(__cpu)		cpu_data(__cpu).multiplier
-#define prof_counter(__cpu)		cpu_data(__cpu).counter
-
 void smp4m_percpu_timer_interrupt(struct pt_regs *regs)
 {
 	int cpu = smp_processor_id();
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/mm/init.c linux-post-2.6.5-rc2-20040323/arch/sparc/mm/init.c
--- linux-post-2.6.5-rc2-20040320/arch/sparc/mm/init.c	2004-01-06 04:26:21.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/mm/init.c	2004-03-21 22:43:34.000000000 +0000
@@ -38,6 +38,7 @@ DEFINE_PER_CPU(struct mmu_gather, mmu_ga
 unsigned long *sparc_valid_addr_bitmap;
 
 unsigned long phys_base;
+unsigned long pfn_base;
 
 unsigned long page_kernel;
 
@@ -134,7 +135,7 @@ unsigned long calc_highpages(void)
 unsigned long calc_max_low_pfn(void)
 {
 	int i;
-	unsigned long tmp = (SRMMU_MAXMEM >> PAGE_SHIFT);
+	unsigned long tmp = pfn_base + (SRMMU_MAXMEM >> PAGE_SHIFT);
 	unsigned long curr_pfn, last_pfn;
 
 	last_pfn = (sp_banks[0].base_addr + sp_banks[0].num_bytes) >> PAGE_SHIFT;
@@ -189,9 +190,6 @@ unsigned long __init bootmem_init(unsign
 	 */
 	start_pfn  = (unsigned long)__pa(PAGE_ALIGN((unsigned long) &_end));
 
-	/* Adjust up to the physical address where the kernel begins. */
-	start_pfn += phys_base;
-
 	/* Now shift down to get the real physical page frame number. */
 	start_pfn >>= PAGE_SHIFT;
 
@@ -202,8 +200,8 @@ unsigned long __init bootmem_init(unsign
 	max_low_pfn = max_pfn;
 	highstart_pfn = highend_pfn = max_pfn;
 
-	if (max_low_pfn > (SRMMU_MAXMEM >> PAGE_SHIFT)) {
-		highstart_pfn = (SRMMU_MAXMEM >> PAGE_SHIFT);
+	if (max_low_pfn > pfn_base + (SRMMU_MAXMEM >> PAGE_SHIFT)) {
+		highstart_pfn = pfn_base + (SRMMU_MAXMEM >> PAGE_SHIFT);
 		max_low_pfn = calc_max_low_pfn();
 		printk(KERN_NOTICE "%ldMB HIGHMEM available.\n",
 		    calc_highpages() >> (20 - PAGE_SHIFT));
@@ -230,7 +228,8 @@ unsigned long __init bootmem_init(unsign
 	}
 #endif	
 	/* Initialize the boot-time allocator. */
-	bootmap_size = init_bootmem_node(NODE_DATA(0), bootmap_pfn, phys_base>>PAGE_SHIFT, max_low_pfn);
+	bootmap_size = init_bootmem_node(NODE_DATA(0), bootmap_pfn, pfn_base,
+					 max_low_pfn);
 
 	/* Now register the available physical memory with the
 	 * allocator.
@@ -267,8 +266,8 @@ unsigned long __init bootmem_init(unsign
 		reserve_bootmem(initrd_start, size);
 		*pages_avail -= PAGE_ALIGN(size) >> PAGE_SHIFT;
 
-		initrd_start += PAGE_OFFSET;
-		initrd_end += PAGE_OFFSET;
+		initrd_start = (initrd_start - phys_base) + PAGE_OFFSET;
+		initrd_end = (initrd_end - phys_base) + PAGE_OFFSET;		
 	}
 #endif
 	/* Reserve the kernel text/data/bss. */
@@ -432,7 +431,7 @@ void __init mem_init(void)
 
 	taint_real_pages();
 
-	max_mapnr = last_valid_pfn - (phys_base >> PAGE_SHIFT);
+	max_mapnr = last_valid_pfn - pfn_base;
 	high_memory = __va(max_low_pfn << PAGE_SHIFT);
 
 	num_physpages = totalram_pages = free_all_bootmem();
@@ -474,11 +473,9 @@ void free_initmem (void)
 
 	addr = (unsigned long)(&__init_begin);
 	for (; addr < (unsigned long)(&__init_end); addr += PAGE_SIZE) {
-		unsigned long page;
 		struct page *p;
 
-		page = addr + phys_base;
-		p = virt_to_page(page);
+		p = virt_to_page(addr);
 
 		ClearPageReserved(p);
 		set_page_count(p, 1);
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/mm/srmmu.c linux-post-2.6.5-rc2-20040323/arch/sparc/mm/srmmu.c
--- linux-post-2.6.5-rc2-20040320/arch/sparc/mm/srmmu.c	2004-03-15 00:45:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/mm/srmmu.c	2004-03-21 22:43:34.000000000 +0000
@@ -213,7 +213,7 @@ static inline pte_t srmmu_pte_mkyoung(pt
  * and a page entry and page directory to the page they refer to.
  */
 static pte_t srmmu_mk_pte(struct page *page, pgprot_t pgprot)
-{ return __pte(((page - mem_map) << (PAGE_SHIFT-4)) | pgprot_val(pgprot)); }
+{ return __pte((page_to_pfn(page) << (PAGE_SHIFT-4)) | pgprot_val(pgprot)); }
 
 static pte_t srmmu_mk_pte_phys(unsigned long page, pgprot_t pgprot)
 { return __pte(((page) >> 4) | pgprot_val(pgprot)); }
@@ -245,7 +245,7 @@ static void srmmu_pmd_populate(pmd_t *pm
 	unsigned long ptp;	/* Physical address, shifted right by 4 */
 	int i;
 
-	ptp = (ptep - mem_map) << (PAGE_SHIFT-4);	/* watch for overflow */
+	ptp = page_to_pfn(ptep) << (PAGE_SHIFT-4);	/* watch for overflow */
 	for (i = 0; i < SRMMU_PTRS_PER_PTE_SOFT/SRMMU_PTRS_PER_PTE; i++) {
 		srmmu_set_pte((pte_t *)&pmdp->pmdv[i], SRMMU_ET_PTD | ptp);
 		ptp += (SRMMU_PTRS_PER_PTE*sizeof(pte_t) >> 4);
@@ -480,7 +480,7 @@ srmmu_pte_alloc_one(struct mm_struct *mm
 
 	if ((pte = (unsigned long)srmmu_pte_alloc_one_kernel(mm, address)) == 0)
 		return NULL;
-	return mem_map + (__nocache_pa(pte) >> PAGE_SHIFT);
+	return pfn_to_page( __nocache_pa(pte) >> PAGE_SHIFT );
 }
 
 static void srmmu_free_pte_fast(pte_t *pte)
@@ -495,7 +495,7 @@ static void srmmu_pte_free(struct page *
 	p = (unsigned long)page_address(pte);	/* Cached address (for test) */
 	if (p == 0)
 		BUG();
-	p = ((pte - mem_map) << PAGE_SHIFT);	/* Physical address */
+	p = page_to_pfn(pte) << PAGE_SHIFT;	/* Physical address */
 	p = (unsigned long) __nocache_va(p);	/* Nocached virtual */
 	srmmu_free_nocache(p, SRMMU_PTE_SZ_SOFT);
 }
@@ -1316,7 +1316,7 @@ void __init srmmu_paging_init(void)
 		for (znum = 0; znum < MAX_NR_ZONES; znum++)
 			zones_size[znum] = zholes_size[znum] = 0;
 
-		npages = max_low_pfn - (phys_base >> PAGE_SHIFT);
+		npages = max_low_pfn - pfn_base;
 
 		zones_size[ZONE_DMA] = npages;
 		zholes_size[ZONE_DMA] = npages - pages_avail;
@@ -1326,13 +1326,9 @@ void __init srmmu_paging_init(void)
 		zholes_size[ZONE_HIGHMEM] = npages - calc_highpages();
 
 		free_area_init_node(0, &contig_page_data, NULL, zones_size,
-				    phys_base >> PAGE_SHIFT, zholes_size);
+				    pfn_base, zholes_size);
 		mem_map = contig_page_data.node_mem_map;
 	}
-
-/* P3: easy to fix, todo. Current code is utterly broken, though. */
-	if (phys_base != 0)
-		panic("phys_base nonzero");
 }
 
 static void srmmu_mmu_info(struct seq_file *m)
diff -purN linux-post-2.6.5-rc2-20040320/arch/sparc/mm/sun4c.c linux-post-2.6.5-rc2-20040323/arch/sparc/mm/sun4c.c
--- linux-post-2.6.5-rc2-20040320/arch/sparc/mm/sun4c.c	2004-03-05 05:57:03.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/sparc/mm/sun4c.c	2004-03-21 22:43:34.000000000 +0000
@@ -2088,7 +2088,7 @@ void __init sun4c_paging_init(void)
 		for (znum = 0; znum < MAX_NR_ZONES; znum++)
 			zones_size[znum] = zholes_size[znum] = 0;
 
-		npages = max_low_pfn - (phys_base >> PAGE_SHIFT);
+		npages = max_low_pfn - pfn_base;
 
 		zones_size[ZONE_DMA] = npages;
 		zholes_size[ZONE_DMA] = npages - pages_avail;
@@ -2098,7 +2098,7 @@ void __init sun4c_paging_init(void)
 		zholes_size[ZONE_HIGHMEM] = npages - calc_highpages();
 
 		free_area_init_node(0, &contig_page_data, NULL, zones_size,
-				    phys_base >> PAGE_SHIFT, zholes_size);
+				    pfn_base, zholes_size);
 		mem_map = contig_page_data.node_mem_map;
 	}
 
diff -purN linux-post-2.6.5-rc2-20040320/arch/x86_64/ia32/ia32_ioctl.c linux-post-2.6.5-rc2-20040323/arch/x86_64/ia32/ia32_ioctl.c
--- linux-post-2.6.5-rc2-20040320/arch/x86_64/ia32/ia32_ioctl.c	2004-02-25 16:06:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/arch/x86_64/ia32/ia32_ioctl.c	2004-03-21 20:12:10.000000000 +0000
@@ -27,7 +27,7 @@ static int tiocgdev(unsigned fd, unsigne
 	struct file *file = fget(fd);
 	struct tty_struct *real_tty;
 
-	if (!fd)
+	if (!file)
 		return -EBADF;
 	if (file->f_op->ioctl != tty_ioctl)
 		return -EINVAL; 
diff -purN linux-post-2.6.5-rc2-20040320/crypto/Kconfig linux-post-2.6.5-rc2-20040323/crypto/Kconfig
--- linux-post-2.6.5-rc2-20040320/crypto/Kconfig	2004-03-04 08:14:43.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/crypto/Kconfig	2004-03-22 06:38:12.000000000 +0000
@@ -161,6 +161,15 @@ config CRYPTO_DEFLATE
 	  
 	  You will most probably want this if using IPSec.
 
+config CRYPTO_MICHAEL_MIC
+	tristate "Michael MIC keyed digest algorithm"
+	depends on CRYPTO
+	help
+	  Michael MIC is used for message integrity protection in TKIP
+	  (IEEE 802.11i). This algorithm is required for TKIP, but it
+	  should not be used for other purposes because of the weakness
+	  of the algorithm.
+
 config CRYPTO_TEST
 	tristate "Testing module"
 	depends on CRYPTO
diff -purN linux-post-2.6.5-rc2-20040320/crypto/Makefile linux-post-2.6.5-rc2-20040323/crypto/Makefile
--- linux-post-2.6.5-rc2-20040320/crypto/Makefile	2004-03-04 08:14:43.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/crypto/Makefile	2004-03-22 06:38:12.000000000 +0000
@@ -23,5 +23,6 @@ obj-$(CONFIG_CRYPTO_CAST5) += cast5.o
 obj-$(CONFIG_CRYPTO_CAST6) += cast6.o
 obj-$(CONFIG_CRYPTO_ARC4) += arc4.o
 obj-$(CONFIG_CRYPTO_DEFLATE) += deflate.o
+obj-$(CONFIG_CRYPTO_MICHAEL_MIC) += michael_mic.o
 
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
diff -purN linux-post-2.6.5-rc2-20040320/crypto/arc4.c linux-post-2.6.5-rc2-20040323/crypto/arc4.c
--- linux-post-2.6.5-rc2-20040320/crypto/arc4.c	2004-03-07 10:22:38.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/crypto/arc4.c	2004-03-22 06:43:23.000000000 +0000
@@ -45,10 +45,6 @@ static int arc4_set_key(void *ctx_arg, c
 			k = 0;
 	}
 
-	/* TODO: dump the first 768 bytes generated as recommended
-	   by Ilya Mironov (http://eprint.iacr.org/2002/067/) to 
-	   increase the statistical strength of the state table */
-
 	return 0;
 }
 
diff -purN linux-post-2.6.5-rc2-20040320/crypto/digest.c linux-post-2.6.5-rc2-20040323/crypto/digest.c
--- linux-post-2.6.5-rc2-20040320/crypto/digest.c	2003-03-29 11:16:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/crypto/digest.c	2004-03-22 06:31:09.000000000 +0000
@@ -42,6 +42,15 @@ static void final(struct crypto_tfm *tfm
 	tfm->__crt_alg->cra_digest.dia_final(crypto_tfm_ctx(tfm), out);
 }
 
+static int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)
+{
+	u32 flags;
+	if (tfm->__crt_alg->cra_digest.dia_setkey == NULL)
+		return -ENOSYS;
+	return tfm->__crt_alg->cra_digest.dia_setkey(crypto_tfm_ctx(tfm),
+						     key, keylen, &flags);
+}
+
 static void digest(struct crypto_tfm *tfm,
                    struct scatterlist *sg, unsigned int nsg, u8 *out)
 {
@@ -72,6 +81,7 @@ int crypto_init_digest_ops(struct crypto
 	ops->dit_update	= update;
 	ops->dit_final	= final;
 	ops->dit_digest	= digest;
+	ops->dit_setkey	= setkey;
 	
 	return crypto_alloc_hmac_block(tfm);
 }
diff -purN linux-post-2.6.5-rc2-20040320/crypto/michael_mic.c linux-post-2.6.5-rc2-20040323/crypto/michael_mic.c
--- linux-post-2.6.5-rc2-20040320/crypto/michael_mic.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/crypto/michael_mic.c	2004-03-22 06:38:08.000000000 +0000
@@ -0,0 +1,193 @@
+/*
+ * Cryptographic API
+ *
+ * Michael MIC (IEEE 802.11i/TKIP) keyed digest
+ *
+ * Copyright (c) 2004 Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/crypto.h>
+
+
+struct michael_mic_ctx {
+	u8 pending[4];
+	size_t pending_len;
+
+	u32 l, r;
+};
+
+
+static inline u32 rotl(u32 val, int bits)
+{
+	return (val << bits) | (val >> (32 - bits));
+}
+
+
+static inline u32 rotr(u32 val, int bits)
+{
+	return (val >> bits) | (val << (32 - bits));
+}
+
+
+static inline u32 xswap(u32 val)
+{
+	return ((val & 0x00ff00ff) << 8) | ((val & 0xff00ff00) >> 8);
+}
+
+
+#define michael_block(l, r)	\
+do {				\
+	r ^= rotl(l, 17);	\
+	l += r;			\
+	r ^= xswap(l);		\
+	l += r;			\
+	r ^= rotl(l, 3);	\
+	l += r;			\
+	r ^= rotr(l, 2);	\
+	l += r;			\
+} while (0)
+
+
+static inline u32 get_le32(const u8 *p)
+{
+	return p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);
+}
+
+
+static inline void put_le32(u8 *p, u32 v)
+{
+	p[0] = v;
+	p[1] = v >> 8;
+	p[2] = v >> 16;
+	p[3] = v >> 24;
+}
+
+
+static void michael_init(void *ctx)
+{
+	struct michael_mic_ctx *mctx = ctx;
+	mctx->pending_len = 0;
+}
+
+
+static void michael_update(void *ctx, const u8 *data, unsigned int len)
+{
+	struct michael_mic_ctx *mctx = ctx;
+
+	if (mctx->pending_len) {
+		int flen = 4 - mctx->pending_len;
+		if (flen > len)
+			flen = len;
+		memcpy(&mctx->pending[mctx->pending_len], data, flen);
+		mctx->pending_len += flen;
+		data += flen;
+		len -= flen;
+
+		if (mctx->pending_len < 4)
+			return;
+
+		mctx->l ^= get_le32(mctx->pending);
+		michael_block(mctx->l, mctx->r);
+		mctx->pending_len = 0;
+	}
+
+	while (len >= 4) {
+		mctx->l ^= get_le32(data);
+		michael_block(mctx->l, mctx->r);
+		data += 4;
+		len -= 4;
+	}
+
+	if (len > 0) {
+		mctx->pending_len = len;
+		memcpy(mctx->pending, data, len);
+	}
+}
+
+
+static void michael_final(void *ctx, u8 *out)
+{
+	struct michael_mic_ctx *mctx = ctx;
+	u8 *data = mctx->pending;
+
+	/* Last block and padding (0x5a, 4..7 x 0) */
+	switch (mctx->pending_len) {
+	case 0:
+		mctx->l ^= 0x5a;
+		break;
+	case 1:
+		mctx->l ^= data[0] | 0x5a00;
+		break;
+	case 2:
+		mctx->l ^= data[0] | (data[1] << 8) | 0x5a0000;
+		break;
+	case 3:
+		mctx->l ^= data[0] | (data[1] << 8) | (data[2] << 16) |
+			0x5a000000;
+		break;
+	}
+	michael_block(mctx->l, mctx->r);
+	/* l ^= 0; */
+	michael_block(mctx->l, mctx->r);
+
+	put_le32(out, mctx->l);
+	put_le32(out + 4, mctx->r);
+}
+
+
+static int michael_setkey(void *ctx, const u8 *key, unsigned int keylen,
+			  u32 *flags)
+{
+	struct michael_mic_ctx *mctx = ctx;
+	if (keylen != 8) {
+		if (flags)
+			*flags = CRYPTO_TFM_RES_BAD_KEY_LEN;
+		return -EINVAL;
+	}
+	mctx->l = get_le32(key);
+	mctx->r = get_le32(key + 4);
+	return 0;
+}
+
+
+static struct crypto_alg michael_mic_alg = {
+	.cra_name	= "michael_mic",
+	.cra_flags	= CRYPTO_ALG_TYPE_DIGEST,
+	.cra_blocksize	= 8,
+	.cra_ctxsize	= sizeof(struct michael_mic_ctx),
+	.cra_module	= THIS_MODULE,
+	.cra_list	= LIST_HEAD_INIT(michael_mic_alg.cra_list),
+	.cra_u		= { .digest = {
+	.dia_digestsize	= 8,
+	.dia_init	= michael_init,
+	.dia_update	= michael_update,
+	.dia_final	= michael_final,
+	.dia_setkey	= michael_setkey } }
+};
+
+
+static int __init michael_mic_init(void)
+{
+	return crypto_register_alg(&michael_mic_alg);
+}
+
+
+static void __exit michael_mic_exit(void)
+{
+	crypto_unregister_alg(&michael_mic_alg);
+}
+
+
+module_init(michael_mic_init);
+module_exit(michael_mic_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Michael MIC");
+MODULE_AUTHOR("Jouni Malinen <jkmaline@cc.hut.fi>");
diff -purN linux-post-2.6.5-rc2-20040320/crypto/tcrypt.c linux-post-2.6.5-rc2-20040323/crypto/tcrypt.c
--- linux-post-2.6.5-rc2-20040320/crypto/tcrypt.c	2004-03-10 22:11:59.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/crypto/tcrypt.c	2004-03-22 06:38:12.000000000 +0000
@@ -61,7 +61,7 @@ static char *tvmem;
 static char *check[] = {
 	"des", "md5", "des3_ede", "rot13", "sha1", "sha256", "blowfish",
 	"twofish", "serpent", "sha384", "sha512", "md4", "aes", "cast6", 
-	"arc4", "deflate", NULL
+	"arc4", "michael_mic", "deflate", NULL
 };
 
 static void
@@ -112,6 +112,10 @@ test_hash (char * algo, struct hash_test
 		sg[0].length = hash_tv[i].psize;
 
 		crypto_digest_init (tfm);
+		if (tfm->crt_u.digest.dit_setkey) {
+			crypto_digest_setkey (tfm, hash_tv[i].key,
+					      hash_tv[i].ksize);
+		}
 		crypto_digest_update (tfm, sg, 1);
 		crypto_digest_final (tfm, result);
 
@@ -568,6 +572,8 @@ do_test(void)
 		test_hmac("sha1", hmac_sha1_tv_template, HMAC_SHA1_TEST_VECTORS);		
 		test_hmac("sha256", hmac_sha256_tv_template, HMAC_SHA256_TEST_VECTORS);
 #endif		
+
+		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
 		break;
 
 	case 1:
@@ -647,6 +653,10 @@ do_test(void)
 		test_cipher ("arc4", MODE_ECB, DECRYPT, arc4_dec_tv_template, ARC4_DEC_TEST_VECTORS);
 		break;
 
+	case 17:
+		test_hash("michael_mic", michael_mic_tv_template, MICHAEL_MIC_TEST_VECTORS);
+		break;
+
 #ifdef CONFIG_CRYPTO_HMAC
 	case 100:
 		test_hmac("md5", hmac_md5_tv_template, HMAC_MD5_TEST_VECTORS);
diff -purN linux-post-2.6.5-rc2-20040320/crypto/tcrypt.h linux-post-2.6.5-rc2-20040323/crypto/tcrypt.h
--- linux-post-2.6.5-rc2-20040320/crypto/tcrypt.h	2004-03-04 08:14:43.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/crypto/tcrypt.h	2004-03-22 06:38:12.000000000 +0000
@@ -30,6 +30,8 @@ struct hash_testvec {
 	char digest[MAX_DIGEST_SIZE];
 	unsigned char np;
 	unsigned char tap[MAX_TAP];		
+	char key[128]; /* only used with keyed hash algorithms */
+	unsigned char ksize;
 };
 
 struct hmac_testvec {	
@@ -1719,4 +1721,54 @@ struct comp_testvec deflate_decomp_tv_te
 	},
 };
 
+/*
+ * Michael MIC test vectors from IEEE 802.11i
+ */
+#define MICHAEL_MIC_TEST_VECTORS 6
+
+struct hash_testvec michael_mic_tv_template[] =
+{
+	{
+		.key = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+		.ksize = 8,
+		.plaintext = { },
+		.psize = 0,
+		.digest = { 0x82, 0x92, 0x5c, 0x1c, 0xa1, 0xd1, 0x30, 0xb8 }
+	},
+	{
+		.key = { 0x82, 0x92, 0x5c, 0x1c, 0xa1, 0xd1, 0x30, 0xb8 },
+		.ksize = 8,
+		.plaintext = { 'M' },
+		.psize = 1,
+		.digest = { 0x43, 0x47, 0x21, 0xca, 0x40, 0x63, 0x9b, 0x3f }
+	},
+	{
+		.key = { 0x43, 0x47, 0x21, 0xca, 0x40, 0x63, 0x9b, 0x3f },
+		.ksize = 8,
+		.plaintext = { 'M', 'i' },
+		.psize = 2,
+		.digest = { 0xe8, 0xf9, 0xbe, 0xca, 0xe9, 0x7e, 0x5d, 0x29 }
+	},
+	{
+		.key = { 0xe8, 0xf9, 0xbe, 0xca, 0xe9, 0x7e, 0x5d, 0x29 },
+		.ksize = 8,
+		.plaintext = { 'M', 'i', 'c' },
+		.psize = 3,
+		.digest = { 0x90, 0x03, 0x8f, 0xc6, 0xcf, 0x13, 0xc1, 0xdb }
+	},
+	{
+		.key = { 0x90, 0x03, 0x8f, 0xc6, 0xcf, 0x13, 0xc1, 0xdb },
+		.ksize = 8,
+		.plaintext = { 'M', 'i', 'c', 'h' },
+		.psize = 4,
+		.digest = { 0xd5, 0x5e, 0x10, 0x05, 0x10, 0x12, 0x89, 0x86 }
+	},
+	{
+		.key = { 0xd5, 0x5e, 0x10, 0x05, 0x10, 0x12, 0x89, 0x86 },
+		.ksize = 8,
+		.plaintext = { 'M', 'i', 'c', 'h', 'a', 'e', 'l' },
+		.psize = 7,
+		.digest = { 0x0a, 0x94, 0x2b, 0x12, 0x4e, 0xca, 0xa5, 0x46 },
+	}
+};
 #endif	/* _CRYPTO_TCRYPT_H */
diff -purN linux-post-2.6.5-rc2-20040320/drivers/bluetooth/hci_usb.c linux-post-2.6.5-rc2-20040323/drivers/bluetooth/hci_usb.c
--- linux-post-2.6.5-rc2-20040320/drivers/bluetooth/hci_usb.c	2004-03-15 18:05:04.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/bluetooth/hci_usb.c	2004-03-20 10:33:14.000000000 +0000
@@ -73,6 +73,9 @@ static struct usb_device_id bluetooth_id
 	/* Generic Bluetooth USB device */
 	{ USB_DEVICE_INFO(HCI_DEV_CLASS, HCI_DEV_SUBCLASS, HCI_DEV_PROTOCOL) },
 
+	/* AVM BlueFRITZ! USB v2.0 */
+	{ USB_DEVICE(0x057c, 0x3800) },
+
 	/* Ericsson with non-standard id */
 	{ USB_DEVICE(0x0bdb, 0x1002) },
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/char/viocons.c linux-post-2.6.5-rc2-20040323/drivers/char/viocons.c
--- linux-post-2.6.5-rc2-20040320/drivers/char/viocons.c	2004-03-11 05:06:46.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/char/viocons.c	2004-03-19 07:10:24.000000000 +0000
@@ -9,7 +9,7 @@
  *           Colin Devilbiss <devilbis@us.ibm.com>
  *           Stephen Rothwell <sfr@au1.ibm.com>
  *
- * (C) Copyright 2000, 2001, 2002, 2003 IBM Corporation
+ * (C) Copyright 2000, 2001, 2002, 2003, 2004 IBM Corporation
  *
  * This program is free software;  you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -59,6 +59,9 @@
 #define VTTY_PORTS 10
 #define VIOTTY_SERIAL_START 65
 
+#define VIOCONS_KERN_WARN	KERN_WARNING "viocons: "
+#define VIOCONS_KERN_INFO	KERN_INFO "viocons: "
+
 static spinlock_t consolelock = SPIN_LOCK_UNLOCKED;
 static spinlock_t consoleloglock = SPIN_LOCK_UNLOCKED;
 
@@ -189,10 +192,10 @@ void hvlogOutput(const char *buf, int co
 static inline int viotty_paranoia_check(struct port_info *pi,
 					char *name, const char *routine)
 {
-	static const char *bad_pi_addr = KERN_WARNING_VIO
-		"Warning: bad address for port_info struct (%s) in %s\n";
-	static const char *badmagic = KERN_WARNING_VIO
-		"Warning: bad magic number for port_info struct (%s) in %s\n";
+	static const char *bad_pi_addr = VIOCONS_KERN_WARN
+		"warning: bad address for port_info struct (%s) in %s\n";
+	static const char *badmagic = VIOCONS_KERN_WARN
+		"warning: bad magic number for port_info struct (%s) in %s\n";
 
 	if ((pi < &port_info[0]) || (viochar_port(pi) > VTTY_PORTS)) {
 		printk(bad_pi_addr, name, routine);
@@ -395,8 +398,8 @@ static void send_buffers(struct port_inf
 			vio_free_event_buffer(viomajorsubtype_chario, viochar);
 			spin_unlock_irqrestore(&consolelock, flags);
 
-			printk(KERN_WARNING_VIO
-			       "console error sending event! return code %d\n",
+			printk(VIOCONS_KERN_WARN
+			       "error sending event! return code %d\n",
 			       (int)hvrc);
 			return;
 		}
@@ -692,8 +695,8 @@ static int viotty_open(struct tty_struct
 	/* If some other TTY is already connected here, reject the open */
 	if ((pi->tty) && (pi->tty != tty)) {
 		spin_unlock_irqrestore(&consolelock, flags);
-		printk(KERN_WARNING_VIO
-		       "console attempt to open device twice from different ttys\n");
+		printk(VIOCONS_KERN_WARN
+		       "attempt to open device twice from different ttys\n");
 		return -EBUSY;
 	}
 	tty->driver_data = pi;
@@ -964,23 +967,22 @@ static void vioHandleOpenEvent(struct Hv
 
 		spin_unlock_irqrestore(&consolelock, flags);
 		if (event->xRc != HvLpEvent_Rc_Good)
-			printk(KERN_WARNING_VIO
-			       "viocons: event->xRc != HvLpEvent_Rc_Good, event->xRc == (%d).\n",
+			printk(VIOCONS_KERN_WARN
+			       "handle_open_event: event->xRc == (%d).\n",
 			       event->xRc);
 
 		if (event->xCorrelationToken != 0) {
 			atomic_t *aptr= (atomic_t *)event->xCorrelationToken;
 			atomic_set(aptr, 1);
 		} else
-			printk(KERN_WARNING_VIO
-			       "viocons: wierd...got open ack without atomic\n");
+			printk(VIOCONS_KERN_WARN
+			       "wierd...got open ack without atomic\n");
 		return;
 	}
 
 	/* This had better require an ack, otherwise complain */
 	if (event->xFlags.xAckInd != HvLpEvent_AckInd_DoAck) {
-		printk(KERN_WARNING_VIO
-		       "console: viocharopen without ack bit!\n");
+		printk(VIOCONS_KERN_WARN "viocharopen without ack bit!\n");
 		return;
 	}
 
@@ -1019,11 +1021,10 @@ static void vioHandleOpenEvent(struct Hv
 	spin_unlock_irqrestore(&consolelock, flags);
 
 	if (reject == 1)
-		printk(KERN_WARNING_VIO
-			"viocons: console open rejected : bad virtual tty.\n");
+		printk(VIOCONS_KERN_WARN "open rejected: bad virtual tty.\n");
 	else if (reject == 2)
-		printk(KERN_WARNING_VIO
-			"viocons: console open rejected : console in exclusive use by another partition.\n");
+		printk(VIOCONS_KERN_WARN
+			"open rejected: console in exclusive use by another partition.\n");
 
 	/* Return the acknowledgement */
 	HvCallEvent_ackLpEvent(event);
@@ -1050,7 +1051,8 @@ static void vioHandleCloseEvent(struct H
 
 	if (event->xFlags.xFunction == HvLpEvent_Function_Int) {
 		if (port >= VTTY_PORTS) {
-			printk(KERN_WARNING_VIO "viocons: close message from invalid virtual device.\n");
+			printk(VIOCONS_KERN_WARN
+					"close message from invalid virtual device.\n");
 			return;
 		}
 
@@ -1062,11 +1064,10 @@ static void vioHandleCloseEvent(struct H
 			port_info[port].lp = HvLpIndexInvalid;
 
 		spin_unlock_irqrestore(&consolelock, flags);
-		printk(KERN_INFO_VIO
-		       "console close from %d\n", event->xSourceLp);
+		printk(VIOCONS_KERN_INFO "close from %d\n", event->xSourceLp);
 	} else
-		printk(KERN_WARNING_VIO
-		       "console got unexpected close acknowlegement\n");
+		printk(VIOCONS_KERN_WARN
+				"got unexpected close acknowlegement\n");
 }
 
 /*
@@ -1079,12 +1080,11 @@ static void vioHandleConfig(struct HvLpE
 	HvCall_writeLogBuffer(cevent->data, cevent->len);
 
 	if (cevent->data[0] == 0x01)
-		printk(KERN_INFO_VIO
-		       "console window resized to %d: %d: %d: %d\n",
+		printk(VIOCONS_KERN_INFO "window resized to %d: %d: %d: %d\n",
 		       cevent->data[1], cevent->data[2],
 		       cevent->data[3], cevent->data[4]);
 	else
-		printk(KERN_WARNING_VIO "console unknown config event\n");
+		printk(VIOCONS_KERN_WARN "unknown config event\n");
 }
 
 /*
@@ -1100,8 +1100,8 @@ static void vioHandleData(struct HvLpEve
 	u8 port = cevent->virtual_device;
 
 	if (port >= VTTY_PORTS) {
-		printk(KERN_WARNING_VIO
-		       "console data on invalid virtual device %d\n", port);
+		printk(VIOCONS_KERN_WARN "data on invalid virtual device %d\n",
+				port);
 		return;
 	}
 
@@ -1130,13 +1130,14 @@ static void vioHandleData(struct HvLpEve
 	tty = pi->tty;
 	if (tty == NULL) {
 		spin_unlock_irqrestore(&consolelock, flags);
-		printk(KERN_WARNING_VIO "no tty for virtual device %d\n", port);
+		printk(VIOCONS_KERN_WARN "no tty for virtual device %d\n",
+				port);
 		return;
 	}
 
 	if (tty->magic != TTY_MAGIC) {
 		spin_unlock_irqrestore(&consolelock, flags);
-		printk(KERN_WARNING_VIO "tty bad magic\n");
+		printk(VIOCONS_KERN_WARN "tty bad magic\n");
 		return;
 	}
 
@@ -1186,8 +1187,7 @@ static void vioHandleData(struct HvLpEve
 		 * have room for because it would fail without indication.
 		 */
 		if ((tty->flip.count + 1) > TTY_FLIPBUF_SIZE) {
-			printk(KERN_WARNING_VIO
-					"console input buffer overflow!\n");
+			printk(VIOCONS_KERN_WARN "input buffer overflow!\n");
 			break;
 		}
 		tty_insert_flip_char(tty, cevent->data[index], TTY_NORMAL);
@@ -1209,8 +1209,7 @@ static void vioHandleAck(struct HvLpEven
 	u8 port = cevent->virtual_device;
 
 	if (port >= VTTY_PORTS) {
-		printk(KERN_WARNING_VIO
-		       "viocons: data on invalid virtual device\n");
+		printk(VIOCONS_KERN_WARN "data on invalid virtual device\n");
 		return;
 	}
 
@@ -1299,14 +1298,11 @@ static int __init viocons_init2(void)
 	atomic_t wait_flag;
 	int rc;
 
-	/* Now open to the primary LP */
-	printk(KERN_INFO_VIO "console open path to primary\n");
 	/* +2 for fudge */
 	rc = viopath_open(HvLpConfig_getPrimaryLpIndex(),
 			viomajorsubtype_chario, VIOCHAR_WINDOW + 2);
 	if (rc)
-		printk(KERN_WARNING_VIO "console error opening to primary %d\n",
-				rc);
+		printk(VIOCONS_KERN_WARN "error opening to primary %d\n", rc);
 
 	if (viopath_hostLp == HvLpIndexInvalid)
 		vio_set_hostlp();
@@ -1317,30 +1313,28 @@ static int __init viocons_init2(void)
 	 */
 	if ((viopath_hostLp != HvLpIndexInvalid) &&
 	    (viopath_hostLp != HvLpConfig_getPrimaryLpIndex())) {
-		printk(KERN_INFO_VIO "console open path to hosting (%d)\n",
+		printk(VIOCONS_KERN_INFO "open path to hosting (%d)\n",
 				viopath_hostLp);
 		rc = viopath_open(viopath_hostLp, viomajorsubtype_chario,
 				VIOCHAR_WINDOW + 2);	/* +2 for fudge */
 		if (rc)
-			printk(KERN_WARNING_VIO
-				"console error opening to partition %d: %d\n",
+			printk(VIOCONS_KERN_WARN
+				"error opening to partition %d: %d\n",
 				viopath_hostLp, rc);
 	}
 
 	if (vio_setHandler(viomajorsubtype_chario, vioHandleCharEvent) < 0)
-		printk(KERN_WARNING_VIO
-				"Error seting handler for console events!\n");
-
-	printk(KERN_INFO_VIO "console major number is %d\n", TTY_MAJOR);
+		printk(VIOCONS_KERN_WARN
+				"error seting handler for console events!\n");
 
-	/* First, try to open the console to the hosting lp.
+	/*
+	 * First, try to open the console to the hosting lp.
 	 * Wait on a semaphore for the response.
 	 */
 	atomic_set(&wait_flag, 0);
 	if ((viopath_isactive(viopath_hostLp)) &&
 	    (send_open(viopath_hostLp, (void *)&wait_flag) == 0)) {
-		printk(KERN_INFO_VIO
-			"opening console to hosting partition %d\n",
+		printk(VIOCONS_KERN_INFO "hosting partition %d\n",
 			viopath_hostLp);
 		while (atomic_read(&wait_flag) == 0)
 			mb();
@@ -1354,7 +1348,7 @@ static int __init viocons_init2(void)
 	    (viopath_isactive(HvLpConfig_getPrimaryLpIndex())) &&
 	    (send_open(HvLpConfig_getPrimaryLpIndex(), (void *)&wait_flag)
 	     == 0)) {
-		printk(KERN_INFO_VIO "opening console to primary partition\n");
+		printk(VIOCONS_KERN_INFO "opening console to primary partition\n");
 		while (atomic_read(&wait_flag) == 0)
 			mb();
 	}
@@ -1388,13 +1382,13 @@ static int __init viocons_init2(void)
 	tty_set_operations(viottyS_driver, &serial_ops);
 
 	if (tty_register_driver(viotty_driver)) {
-		printk(KERN_WARNING_VIO "Couldn't register console driver\n");
+		printk(VIOCONS_KERN_WARN "couldn't register console driver\n");
 		put_tty_driver(viotty_driver);
 		viotty_driver = NULL;
 	}
 
 	if (tty_register_driver(viottyS_driver)) {
-		printk(KERN_WARNING_VIO "Couldn't register console S driver\n");
+		printk(VIOCONS_KERN_WARN "couldn't register console S driver\n");
 		put_tty_driver(viottyS_driver);
 		viottyS_driver = NULL;
 	}
@@ -1411,7 +1405,7 @@ static int __init viocons_init(void)
 {
 	int i;
 
-	printk(KERN_INFO_VIO "registering console\n");
+	printk(VIOCONS_KERN_INFO "registering console\n");
 	for (i = 0; i < VTTY_PORTS; i++) {
 		port_info[i].lp = HvLpIndexInvalid;
 		port_info[i].magic = VIOTTY_MAGIC;
diff -purN linux-post-2.6.5-rc2-20040320/drivers/char/viotape.c linux-post-2.6.5-rc2-20040323/drivers/char/viotape.c
--- linux-post-2.6.5-rc2-20040320/drivers/char/viotape.c	2004-03-19 05:59:29.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/char/viotape.c	2004-03-19 07:10:24.000000000 +0000
@@ -913,8 +913,6 @@ int __init viotap_init(void)
 	char tapename[32];
 	int i;
 
-	printk(VIOTAPE_KERN_INFO "driver version " VIOTAPE_VERSION "\n");
-
 	op_struct_list = NULL;
 	if ((ret = add_op_structs(VIOTAPE_MAXREQ)) < 0) {
 		printk(VIOTAPE_KERN_WARN "couldn't allocate op structs\n");
@@ -932,8 +930,6 @@ int __init viotap_init(void)
 		}
 	}
 
-	printk(VIOTAPE_KERN_INFO "init - open path to hosting (%d)\n",
-			viopath_hostLp);
 	ret = viopath_open(viopath_hostLp, viomajorsubtype_tape,
 			VIOTAPE_MAXREQ + 2);
 	if (ret) {
@@ -943,6 +939,9 @@ int __init viotap_init(void)
 		goto clear_op;
 	}
 
+	printk(VIOTAPE_KERN_INFO "vers " VIOTAPE_VERSION
+			", hosting partition %d\n", viopath_hostLp);
+
 	vio_setHandler(viomajorsubtype_tape, vioHandleTapeEvent);
 
 	ret = register_chrdev(VIOTAPE_MAJOR, "viotape", &viotap_fops);
diff -purN linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/Kconfig linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/Kconfig
--- linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/Kconfig	2004-03-02 03:01:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/Kconfig	2004-03-22 20:49:16.000000000 +0000
@@ -374,7 +374,7 @@ config PCWATCHDOG
 	tristate "Berkshire Products ISA-PC Watchdog"
 	depends on WATCHDOG && ISA
 	---help---
-	  This is the driver for the Berkshire Products PC Watchdog card.
+	  This is the driver for the Berkshire Products ISA-PC Watchdog card.
 	  This card simply watches your kernel to make sure it doesn't freeze,
 	  and if it does, it reboots your computer after a certain amount of
 	  time. This driver is like the WDT501 driver but for different
@@ -406,10 +406,8 @@ config WDT
 	---help---
 	  If you have a WDT500P or WDT501P watchdog board, say Y here,
 	  otherwise N. It is not possible to probe for this board, which means
-	  that you have to inform the kernel about the IO port and IRQ using
-	  the "wdt=" kernel option (try "man bootparam" or see the
-	  documentation of your boot loader (lilo or loadlin) about how to
-	  pass options to the kernel at boot time).
+	  that you have to inform the kernel about the IO port and IRQ that
+	  is needed (you can do this via the io and irq parameters)
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called wdt.
@@ -425,11 +423,8 @@ config WDT_501
 	  Fahrenheit. This works only if you have a WDT501P watchdog board
 	  installed.
 
-config WDT_501_FAN
-	bool "Fan Tachometer"
-	depends on WDT_501
-	help
-	  Enable the Fan Tachometer on the WDT501. Only do this if you have a
+	  If you want to enable the Fan Tachometer on the WDT501P, then you
+	  can do this via the tachometer parameter. Only do this if you have a
 	  fan tachometer actually set up.
 
 #
@@ -455,30 +450,29 @@ config PCIPCWATCHDOG
 	  Most people will say N.
 
 config WDTPCI
-	tristate "WDT PCI Watchdog timer"
+	tristate "PCI-WDT500/501 Watchdog timer"
 	depends on WATCHDOG && PCI
 	---help---
-	  If you have a PCI WDT500/501 watchdog board, say Y here, otherwise
-	  N.  It is not possible to probe for this board, which means that you
-	  have to inform the kernel about the IO port and IRQ using the "wdt="
-	  kernel option (try "man bootparam" or see the documentation of your
-	  boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time).
+	  If you have a PCI-WDT500/501 watchdog board, say Y here, otherwise N.
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called wdt_pci.
 
 config WDT_501_PCI
-	bool "WDT501-PCI features"
+	bool "PCI-WDT501 features"
 	depends on WDTPCI
 	help
 	  Saying Y here and creating a character special file /dev/temperature
 	  with major number 10 and minor number 131 ("man mknod") will give
 	  you a thermometer inside your computer: reading from
 	  /dev/temperature yields one byte, the temperature in degrees
-	  Fahrenheit. This works only if you have a WDT501P watchdog board
+	  Fahrenheit. This works only if you have a PCI-WDT501 watchdog board
 	  installed.
 
+	  If you want to enable the Fan Tachometer on the PCI-WDT501, then you
+	  can do this via the tachometer parameter. Only do this if you have a
+	  fan tachometer actually set up.
+
 #
 # USB-based Watchdog Cards
 #
diff -purN linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/pcwd.c linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/pcwd.c
--- linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/pcwd.c	2004-03-02 03:01:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/pcwd.c	2004-03-21 19:32:20.000000000 +0000
@@ -71,7 +71,7 @@
  */
 static int pcwd_ioports[] = { 0x270, 0x350, 0x370, 0x000 };
 
-#define WD_VER                  "1.12 (12/14/2001)"
+#define WD_VER                  "1.14 (03/12/2004)"
 
 /*
  * It should be noted that PCWD_REVISION_B was removed because A and B
@@ -227,6 +227,45 @@ void pcwd_showprevstate(void)
 	}
 }
 
+static int pcwd_start(void)
+{
+	int stat_reg;
+
+	/*  Enable the port  */
+	if (revision == PCWD_REVISION_C) {
+		spin_lock(&io_lock);
+		outb_p(0x00, current_readport + 3);
+		stat_reg = inb_p(current_readport + 2);
+		spin_unlock(&io_lock);
+		if (stat_reg & 0x10)
+		{
+			printk(KERN_INFO "pcwd: Could not start watchdog.\n");
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
+static int pcwd_stop(void)
+{
+	int stat_reg;
+
+	/*  Disable the board  */
+	if (revision == PCWD_REVISION_C) {
+		spin_lock(&io_lock);
+		outb_p(0xA5, current_readport + 3);
+		outb_p(0xA5, current_readport + 3);
+		stat_reg = inb_p(current_readport + 2);
+		spin_unlock(&io_lock);
+		if ((stat_reg & 0x10) == 0)
+		{
+			printk(KERN_INFO "pcwd: Could not stop watchdog.\n");
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
 static void pcwd_send_heartbeat(void)
 {
 	int wdrst_stat;
@@ -242,13 +281,41 @@ static void pcwd_send_heartbeat(void)
 		outb_p(wdrst_stat, current_readport);
 }
 
+static int pcwd_get_temperature(int *temperature)
+{
+	/* check that port 0 gives temperature info and no command results */
+	if (mode_debug)
+		return -1;
+
+	*temperature = 0;
+	if (!supports_temp)
+		return -ENODEV;
+
+	/*
+	 * Convert celsius to fahrenheit, since this was
+	 * the decided 'standard' for this return value.
+	 */
+	spin_lock(&io_lock);
+	*temperature = ((inb(current_readport)) * 9 / 5) + 32;
+	spin_unlock(&io_lock);
+
+	return 0;
+}
+
+/*
+ *	/dev/watchdog handling
+ */
+
 static int pcwd_ioctl(struct inode *inode, struct file *file,
 		      unsigned int cmd, unsigned long arg)
 {
 	int cdat, rv;
+	int temperature;
 	static struct watchdog_info ident=
 	{
-		.options =		WDIOF_OVERHEAT|WDIOF_CARDRESET,
+		.options =		WDIOF_OVERHEAT |
+					WDIOF_CARDRESET |
+					WDIOF_MAGICCLOSE,
 		.firmware_version =	1,
 		.identity =		"PCWD",
 	};
@@ -332,17 +399,10 @@ static int pcwd_ioctl(struct inode *inod
 
 	case WDIOC_GETTEMP:
 
-		rv = 0;
-		if ((supports_temp) && (mode_debug == 0))
-		{
-			spin_lock(&io_lock);
-			rv = inb(current_readport);
-			spin_unlock(&io_lock);
-			if(put_user(rv, (int*) arg))
-				return -EFAULT;
-		} else if(put_user(rv, (int*) arg))
-				return -EFAULT;
-		return 0;
+		if (pcwd_get_temperature(&temperature))
+			return -EFAULT;
+
+		return put_user(temperature, (int *) arg);
 
 	case WDIOC_SETOPTIONS:
 		if (revision == PCWD_REVISION_C)
@@ -352,32 +412,12 @@ static int pcwd_ioctl(struct inode *inod
 
 			if (rv & WDIOS_DISABLECARD)
 			{
-				spin_lock(&io_lock);
-				outb_p(0xA5, current_readport + 3);
-				outb_p(0xA5, current_readport + 3);
-				cdat = inb_p(current_readport + 2);
-				spin_unlock(&io_lock);
-				if ((cdat & 0x10) == 0)
-				{
-					printk(KERN_INFO "pcwd: Could not disable card.\n");
-					return -EIO;
-				}
-
-				return 0;
+				return pcwd_stop();
 			}
 
 			if (rv & WDIOS_ENABLECARD)
 			{
-				spin_lock(&io_lock);
-				outb_p(0x00, current_readport + 3);
-				cdat = inb_p(current_readport + 2);
-				spin_unlock(&io_lock);
-				if (cdat & 0x10)
-				{
-					printk(KERN_INFO "pcwd: Could not enable card.\n");
-					return -EIO;
-				}
-				return 0;
+				return pcwd_start();
 			}
 
 			if (rv & WDIOS_TEMPPANIC)
@@ -423,72 +463,66 @@ static ssize_t pcwd_write(struct file *f
 	return len;
 }
 
-static int pcwd_open(struct inode *ino, struct file *filep)
+static int pcwd_open(struct inode *inode, struct file *file)
 {
-	switch (iminor(ino)) {
-	case WATCHDOG_MINOR:
-		if (!atomic_dec_and_test(&open_allowed) ) {
-			atomic_inc( &open_allowed );
-			return -EBUSY;
-		}
+	if (!atomic_dec_and_test(&open_allowed) ) {
+		atomic_inc( &open_allowed );
+		return -EBUSY;
+	}
+
+	if (nowayout)
 		__module_get(THIS_MODULE);
-		/*  Enable the port  */
-		if (revision == PCWD_REVISION_C) {
-			spin_lock(&io_lock);
-			outb_p(0x00, current_readport + 3);
-			spin_unlock(&io_lock);
-		}
-		return(0);
 
-	case TEMP_MINOR:
-		return(0);
-	default:
-		return (-ENODEV);
+	/* Activate */
+	pcwd_start();
+	return(0);
+}
+
+static int pcwd_close(struct inode *inode, struct file *file)
+{
+	if (expect_close == 42) {
+		pcwd_stop();
+		atomic_inc( &open_allowed );
+        } else {
+                printk(KERN_CRIT "pcwd: Unexpected close, not stopping watchdog!\n");
+                pcwd_send_heartbeat();
 	}
+	expect_close = 0;
+	return 0;
 }
 
-static ssize_t pcwd_read(struct file *file, char *buf, size_t count,
+/*
+ *	/dev/temperature handling
+ */
+
+static ssize_t pcwd_temp_read(struct file *file, char *buf, size_t count,
 			 loff_t *ppos)
 {
-	unsigned short c;
-	unsigned char cp;
+	int temperature;
 
 	/*  Can't seek (pread) on this device  */
 	if (ppos != &file->f_pos)
 		return -ESPIPE;
-	switch(iminor(file->f_dentry->d_inode))
-	{
-		case TEMP_MINOR:
-			/*
-			 * Convert metric to Fahrenheit, since this was
-			 * the decided 'standard' for this return value.
-			 */
-
-			c = inb(current_readport);
-			cp = (c * 9 / 5) + 32;
-			if(copy_to_user(buf, &cp, 1))
-				return -EFAULT;
-			return 1;
-		default:
-			return -EINVAL;
-	}
+
+	if (pcwd_get_temperature(&temperature))
+		return -EFAULT;
+
+	if (copy_to_user(buf, &temperature, 1))
+		return -EFAULT;
+
+	return 1;
 }
 
-static int pcwd_close(struct inode *ino, struct file *filep)
-{
-	if (iminor(ino)==WATCHDOG_MINOR) {
-		if (expect_close == 42) {
-			/*  Disable the board  */
-			if (revision == PCWD_REVISION_C) {
-				spin_lock(&io_lock);
-				outb_p(0xA5, current_readport + 3);
-				outb_p(0xA5, current_readport + 3);
-				spin_unlock(&io_lock);
-			}
-			atomic_inc( &open_allowed );
-		}
-	}
-	expect_close = 0;
+static int pcwd_temp_open(struct inode *inode, struct file *file)
+{
+	if (!supports_temp)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int pcwd_temp_close(struct inode *inode, struct file *file)
+{
 	return 0;
 }
 
@@ -569,7 +603,7 @@ static void debug_off(void)
 
 static struct file_operations pcwd_fops = {
 	.owner		= THIS_MODULE,
-	.read		= pcwd_read,
+	.llseek		= no_llseek,
 	.write		= pcwd_write,
 	.ioctl		= pcwd_ioctl,
 	.open		= pcwd_open,
@@ -582,10 +616,18 @@ static struct miscdevice pcwd_miscdev = 
 	.fops =		&pcwd_fops,
 };
 
+static struct file_operations pcwd_temp_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= pcwd_temp_read,
+	.open		= pcwd_temp_open,
+	.release	= pcwd_temp_close,
+};
+
 static struct miscdevice temp_miscdev = {
 	.minor =	TEMP_MINOR,
 	.name =		"temperature",
-	.fops =		&pcwd_fops,
+	.fops =		&pcwd_temp_fops,
 };
 
 static void __init pcwd_validate_timeout(void)
diff -purN linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/softdog.c linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/softdog.c
--- linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/softdog.c	2004-02-11 19:44:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/softdog.c	2004-03-21 10:27:22.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *	SoftDog	0.06:	A Software Watchdog Device
+ *	SoftDog	0.07:	A Software Watchdog Device
  *
  *	(c) Copyright 1996 Alan Cox <alan@redhat.com>, All Rights Reserved.
  *				http://www.redhat.com
@@ -40,26 +40,21 @@
 #include <linux/moduleparam.h>
 #include <linux/config.h>
 #include <linux/types.h>
+#include <linux/timer.h>
 #include <linux/miscdevice.h>
 #include <linux/watchdog.h>
 #include <linux/fs.h>
+#include <linux/notifier.h>
 #include <linux/reboot.h>
 #include <linux/init.h>
 #include <asm/uaccess.h>
 
-#define TIMER_MARGIN	60		/* (secs) Default is 1 minute */
+#define PFX "SoftDog: "
 
-static char expect_close;
+#define TIMER_MARGIN	60		/* Default is 60 seconds */
 static int soft_margin = TIMER_MARGIN;	/* in seconds */
-#ifdef ONLY_TESTING
-static int soft_noboot = 1;
-#else
-static int soft_noboot = 0;
-#endif  /* ONLY_TESTING */
-
 module_param(soft_margin, int, 0);
-module_param(soft_noboot, int, 0);
-MODULE_LICENSE("GPL");
+MODULE_PARM_DESC(soft_margin, "Watchdog soft_margin in seconds. (0<soft_margin<65536, default=" __MODULE_STRING(TIMER_MARGIN) ")");
 
 #ifdef CONFIG_WATCHDOG_NOWAYOUT
 static int nowayout = 1;
@@ -70,6 +65,15 @@ static int nowayout = 0;
 module_param(nowayout, int, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=CONFIG_WATCHDOG_NOWAYOUT)");
 
+#ifdef ONLY_TESTING
+static int soft_noboot = 1;
+#else
+static int soft_noboot = 0;
+#endif  /* ONLY_TESTING */
+
+module_param(soft_noboot, int, 0);
+MODULE_PARM_DESC(soft_noboot, "Softdog action, set to 1 to ignore reboots, 0 to reboot (default depends on ONLY_TESTING)");
+
 /*
  *	Our timer
  */
@@ -79,6 +83,7 @@ static void watchdog_fire(unsigned long)
 static struct timer_list watchdog_ticktock =
 		TIMER_INITIALIZER(watchdog_fire, 0, 0);
 static unsigned long timer_alive;
+static char expect_close;
 
 
 /*
@@ -88,17 +93,42 @@ static unsigned long timer_alive;
 static void watchdog_fire(unsigned long data)
 {
 	if (soft_noboot)
-		printk(KERN_CRIT "SOFTDOG: Triggered - Reboot ignored.\n");
+		printk(KERN_CRIT PFX "Triggered - Reboot ignored.\n");
 	else
 	{
-		printk(KERN_CRIT "SOFTDOG: Initiating system reboot.\n");
+		printk(KERN_CRIT PFX "Initiating system reboot.\n");
 		machine_restart(NULL);
-		printk("SOFTDOG: Reboot didn't ?????\n");
+		printk(KERN_CRIT PFX "Reboot didn't ?????\n");
 	}
 }
 
 /*
- *	Allow only one person to hold it open
+ *	Softdog operations
+ */
+
+static int softdog_keepalive(void)
+{
+	mod_timer(&watchdog_ticktock, jiffies+(soft_margin*HZ));
+	return 0;
+}
+
+static int softdog_stop(void)
+{
+	del_timer(&watchdog_ticktock);
+	return 0;
+}
+
+static int softdog_set_heartbeat(int t)
+{
+	if ((t < 0x0001) || (t > 0xFFFF))
+		return -EINVAL;
+
+	soft_margin = t;
+	return 0;
+}
+
+/*
+ *	/dev/watchdog handling
  */
 
 static int softdog_open(struct inode *inode, struct file *file)
@@ -110,7 +140,7 @@ static int softdog_open(struct inode *in
 	/*
 	 *	Activate timer
 	 */
-	mod_timer(&watchdog_ticktock, jiffies+(soft_margin*HZ));
+	softdog_keepalive();
 	return 0;
 }
 
@@ -121,9 +151,10 @@ static int softdog_release(struct inode 
 	 * 	Lock it in if it's a module and we set nowayout
 	 */
 	if (expect_close == 42) {
-		del_timer(&watchdog_ticktock);
+		softdog_stop();
 	} else {
-		printk(KERN_CRIT "SOFTDOG: WDT device closed unexpectedly.  WDT will not stop!\n");
+		printk(KERN_CRIT PFX "Unexpected close, not stopping watchdog!\n");
+		softdog_keepalive();
 	}
 	clear_bit(0, &timer_alive);
 	expect_close = 0;
@@ -155,7 +186,7 @@ static ssize_t softdog_write(struct file
 					expect_close = 42;
 			}
 		}
-		mod_timer(&watchdog_ticktock, jiffies+(soft_margin*HZ));
+		softdog_keepalive();
 	}
 	return len;
 }
@@ -165,37 +196,57 @@ static int softdog_ioctl(struct inode *i
 {
 	int new_margin;
 	static struct watchdog_info ident = {
-		.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE,
-		.identity = "Software Watchdog",
+		.options =		WDIOF_SETTIMEOUT |
+					WDIOF_KEEPALIVEPING |
+					WDIOF_MAGICCLOSE,
+		.firmware_version =	0,
+		.identity =		"Software Watchdog",
 	};
 	switch (cmd) {
 		default:
 			return -ENOIOCTLCMD;
 		case WDIOC_GETSUPPORT:
-			if(copy_to_user((struct watchdog_info *)arg, &ident, sizeof(ident)))
-				return -EFAULT;
-			return 0;
+			return copy_to_user((struct watchdog_info *)arg, &ident,
+				sizeof(ident)) ? -EFAULT : 0;
 		case WDIOC_GETSTATUS:
 		case WDIOC_GETBOOTSTATUS:
 			return put_user(0,(int *)arg);
 		case WDIOC_KEEPALIVE:
-			mod_timer(&watchdog_ticktock, jiffies+(soft_margin*HZ));
+			softdog_keepalive();
 			return 0;
 		case WDIOC_SETTIMEOUT:
 			if (get_user(new_margin, (int *)arg))
 				return -EFAULT;
-			if (new_margin < 1)
+			if (softdog_set_heartbeat(new_margin))
 				return -EINVAL;
-			soft_margin = new_margin;
-			mod_timer(&watchdog_ticktock, jiffies+(soft_margin*HZ));
+			softdog_keepalive();
 			/* Fall */
 		case WDIOC_GETTIMEOUT:
 			return put_user(soft_margin, (int *)arg);
 	}
 }
 
+/*
+ *	Notifier for system down
+ */
+
+static int softdog_notify_sys(struct notifier_block *this, unsigned long code,
+	void *unused)
+{
+	if(code==SYS_DOWN || code==SYS_HALT) {
+		/* Turn the WDT off */
+		softdog_stop();
+	}
+	return NOTIFY_DONE;
+}
+
+/*
+ *	Kernel Interfaces
+ */
+
 static struct file_operations softdog_fops = {
 	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
 	.write		= softdog_write,
 	.ioctl		= softdog_ioctl,
 	.open		= softdog_open,
@@ -208,18 +259,39 @@ static struct miscdevice softdog_miscdev
 	.fops		= &softdog_fops,
 };
 
-static char banner[] __initdata = KERN_INFO "Software Watchdog Timer: 0.06, soft_margin: %d sec, nowayout: %d\n";
+static struct notifier_block softdog_notifier = {
+	.notifier_call	= softdog_notify_sys,
+};
+
+static char banner[] __initdata = KERN_INFO "Software Watchdog Timer: 0.07 initialized. soft_noboot=%d soft_margin=%d sec (nowayout= %d)\n";
 
 static int __init watchdog_init(void)
 {
 	int ret;
 
-	ret = misc_register(&softdog_miscdev);
+	/* Check that the soft_margin value is within it's range ; if not reset to the default */
+	if (softdog_set_heartbeat(soft_margin)) {
+		softdog_set_heartbeat(TIMER_MARGIN);
+		printk(KERN_INFO PFX "soft_margin value must be 0<soft_margin<65536, using %d\n",
+			TIMER_MARGIN);
+	}
 
-	if (ret)
+	ret = register_reboot_notifier(&softdog_notifier);
+	if (ret) {
+		printk (KERN_ERR PFX "cannot register reboot notifier (err=%d)\n",
+			ret);
 		return ret;
+	}
+
+	ret = misc_register(&softdog_miscdev);
+	if (ret) {
+		printk (KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+			WATCHDOG_MINOR, ret);
+		unregister_reboot_notifier(&softdog_notifier);
+		return ret;
+	}
 
-	printk(banner, soft_margin, nowayout);
+	printk(banner, soft_noboot, soft_margin, nowayout);
 
 	return 0;
 }
@@ -227,6 +299,7 @@ static int __init watchdog_init(void)
 static void __exit watchdog_exit(void)
 {
 	misc_deregister(&softdog_miscdev);
+	unregister_reboot_notifier(&softdog_notifier);
 }
 
 module_init(watchdog_init);
diff -purN linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/wd501p.h linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/wd501p.h
--- linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/wd501p.h	2002-11-25 17:24:31.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/wd501p.h	2004-03-21 10:23:55.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *	Industrial Computer Source WDT500/501 driver for Linux 1.3.x
+ *	Industrial Computer Source WDT500/501 driver
  *
  *	(c) Copyright 1995	CymruNET Ltd
  *				Innovation Centre
@@ -40,52 +40,13 @@
 /* programmable outputs: */
 #define WDT_PROGOUT		(io+15)	/* wr=enable, rd=disable */
 
-#define WDC_SR_WCCR		1	/* Active low */
-#define WDC_SR_TGOOD		2
-#define WDC_SR_ISOI0		4
-#define WDC_SR_ISII1		8
-#define WDC_SR_FANGOOD		16
-#define WDC_SR_PSUOVER		32	/* Active low */
-#define WDC_SR_PSUUNDR		64	/* Active low */
-#define WDC_SR_IRQ		128	/* Active low */
+								/* FAN 501 500 */
+#define WDC_SR_WCCR		1	/* Active low */	/*  X   X   X  */
+#define WDC_SR_TGOOD		2				/*  X   X   -  */
+#define WDC_SR_ISOI0		4				/*  X   X   X  */
+#define WDC_SR_ISII1		8				/*  X   X   X  */
+#define WDC_SR_FANGOOD		16				/*  X   -   -  */
+#define WDC_SR_PSUOVER		32	/* Active low */	/*  X   X   -  */
+#define WDC_SR_PSUUNDR		64	/* Active low */	/*  X   X   -  */
+#define WDC_SR_IRQ		128	/* Active low */	/*  X   X   X  */
 
-#ifndef WDT_IS_PCI
-
-/*
- *	Feature Map 1 is the active high inputs not supported on your card.
- *	Feature Map 2 is the active low inputs not supported on your card.
- */
- 
-#ifdef CONFIG_WDT_501		/* Full board */
-
-#ifdef CONFIG_WDT501_FAN	/* Full board, Fan has no tachometer */
-#define FEATUREMAP1		0
-#define WDT_OPTION_MASK		(WDIOF_OVERHEAT|WDIOF_POWERUNDER|WDIOF_POWEROVER|WDIOF_EXTERN1|WDIOF_EXTERN2|WDIOF_FANFAULT)
-#else
-#define FEATUREMAP1		WDC_SR_FANGOOD
-#define WDT_OPTION_MASK		(WDIOF_OVERHEAT|WDIOF_POWERUNDER|WDIOF_POWEROVER|WDIOF_EXTERN1|WDIOF_EXTERN2)
-#endif
-
-#define FEATUREMAP2		0
-#endif
-
-#ifndef CONFIG_WDT_501
-#define CONFIG_WDT_500
-#endif
-
-#ifdef CONFIG_WDT_500		/* Minimal board */
-#define FEATUREMAP1		(WDC_SR_TGOOD|WDC_SR_FANGOOD)
-#define FEATUREMAP2		(WDC_SR_PSUOVER|WDC_SR_PSUUNDR)
-#define WDT_OPTION_MASK		(WDIOF_OVERHEAT)
-#endif
-
-#else
-
-#define FEATUREMAP1		(WDC_SR_TGOOD|WDC_SR_FANGOOD)
-#define FEATUREMAP2		(WDC_SR_PSUOVER|WDC_SR_PSUUNDR)
-#define WDT_OPTION_MASK		(WDIOF_OVERHEAT)
-#endif
-
-#ifndef FEATUREMAP1
-#error "Config option not set"
-#endif
diff -purN linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/wdt.c linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/wdt.c
--- linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/wdt.c	2004-03-13 22:48:21.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/wdt.c	2004-03-21 10:07:44.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *	Industrial Computer Source WDT500/501 driver for Linux 2.1.x
+ *	Industrial Computer Source WDT500/501 driver
  *
  *	(c) Copyright 1996-1997 Alan Cox <alan@redhat.com>, All Rights Reserved.
  *				http://www.redhat.com
@@ -15,7 +15,7 @@
  *
  *	(c) Copyright 1995    Alan Cox <alan@lxorguk.ukuu.org.uk>
  *
- *	Release 0.09.
+ *	Release 0.10.
  *
  *	Fixes
  *		Dave Gregorich	:	Modularisation and minor bugs
@@ -53,17 +53,15 @@ static unsigned long wdt_is_open;
 static char expect_close;
 
 /*
- *	You must set these - there is no sane way to probe for this board.
- *	You can use wdt=x,y to set these now.
+ *	Module parameters
  */
 
-static int io=0x240;
-static int irq=11;
+#define WD_TIMO 60			/* Default heartbeat = 60 seconds */
 
-/* Default margin */
-#define WD_TIMO (100*60)		/* 1 minute */
-
-static int wd_margin = WD_TIMO;
+static int heartbeat = WD_TIMO;
+static int wd_heartbeat;
+module_param(heartbeat, int, 0);
+MODULE_PARM_DESC(heartbeat, "Watchdog heartbeat in seconds. (0<heartbeat<65536, default=" __MODULE_STRING(WD_TIMO) ")");
 
 #ifdef CONFIG_WATCHDOG_NOWAYOUT
 static int nowayout = 1;
@@ -74,11 +72,23 @@ static int nowayout = 0;
 module_param(nowayout, int, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=CONFIG_WATCHDOG_NOWAYOUT)");
 
+/* You must set these - there is no sane way to probe for this board. */
+static int io=0x240;
+static int irq=11;
+
 module_param(io, int, 0);
 MODULE_PARM_DESC(io, "WDT io port (default=0x240)");
 module_param(irq, int, 0);
 MODULE_PARM_DESC(irq, "WDT irq (default=11)");
 
+#ifdef CONFIG_WDT_501
+/* Support for the Fan Tachometer on the WDT501-P */
+static int tachometer;
+
+module_param(tachometer, int, 0);
+MODULE_PARM_DESC(tachometer, "WDT501-P Fan Tachometer support (0=disable, default=0)");
+#endif /* CONFIG_WDT_501 */
+
 /*
  *	Programming support
  */
@@ -97,13 +107,77 @@ static void wdt_ctr_load(int ctr, int va
 	outb_p(val>>8, WDT_COUNT0+ctr);
 }
 
-/*
- *	Kernel methods.
+/**
+ *	wdt_start:
+ *
+ *	Start the watchdog driver.
+ */
+
+static int wdt_start(void)
+{
+	inb_p(WDT_DC);			/* Disable watchdog */
+	wdt_ctr_mode(0,3);		/* Program CTR0 for Mode 3: Square Wave Generator */
+	wdt_ctr_mode(1,2);		/* Program CTR1 for Mode 2: Rate Generator */
+	wdt_ctr_mode(2,0);		/* Program CTR2 for Mode 0: Pulse on Terminal Count */
+	wdt_ctr_load(0, 8948);		/* Count at 100Hz */
+	wdt_ctr_load(1,wd_heartbeat);	/* Heartbeat */
+	wdt_ctr_load(2,65535);		/* Length of reset pulse */
+	outb_p(0, WDT_DC);		/* Enable watchdog */
+	return 0;
+}
+
+/**
+ *	wdt_stop:
+ *
+ *	Stop the watchdog driver.
+ */
+
+static int wdt_stop (void)
+{
+	/* Turn the card off */
+	inb_p(WDT_DC);			/* Disable watchdog */
+	wdt_ctr_load(2,0);		/* 0 length reset pulses now */
+	return 0;
+}
+
+/**
+ *	wdt_ping:
+ *
+ *	Reload counter one with the watchdog heartbeat. We don't bother reloading
+ *	the cascade counter.
  */
 
+static int wdt_ping(void)
+{
+	/* Write a watchdog value */
+	inb_p(WDT_DC);			/* Disable watchdog */
+	wdt_ctr_mode(1,2);		/* Re-Program CTR1 for Mode 2: Rate Generator */
+	wdt_ctr_load(1,wd_heartbeat);	/* Heartbeat */
+	outb_p(0, WDT_DC);		/* Enable watchdog */
+	return 0;
+}
 
 /**
- *	wdt_status:
+ *	wdt_set_heartbeat:
+ *	@t:		the new heartbeat value that needs to be set.
+ *
+ *	Set a new heartbeat value for the watchdog device. If the heartbeat value is
+ *	incorrect we keep the old value and return -EINVAL. If successfull we
+ *	return 0.
+ */
+static int wdt_set_heartbeat(int t)
+{
+	if ((t < 1) || (t > 65535))
+		return -EINVAL;
+
+	heartbeat = t;
+	wd_heartbeat = t * 100;
+	return 0;
+}
+
+/**
+ *	wdt_get_status:
+ *	@status:		the new status.
  *
  *	Extract the status information from a WDT watchdog device. There are
  *	several board variants so we have to know which bits are valid. Some
@@ -112,31 +186,46 @@ static void wdt_ctr_load(int ctr, int va
  *	we then map the bits onto the status ioctl flags.
  */
 
-static int wdt_status(void)
+static int wdt_get_status(int *status)
 {
-	/*
-	 *	Status register to bit flags
-	 */
+	unsigned char new_status=inb_p(WDT_SR);
 
-	int flag=0;
-	unsigned char status=inb_p(WDT_SR);
-	status|=FEATUREMAP1;
-	status&=~FEATUREMAP2;
+	*status=0;
+	if (new_status & WDC_SR_ISOI0)
+		*status |= WDIOF_EXTERN1;
+	if (new_status & WDC_SR_ISII1)
+		*status |= WDIOF_EXTERN2;
+#ifdef CONFIG_WDT_501
+	if (!(new_status & WDC_SR_TGOOD))
+		*status |= WDIOF_OVERHEAT;
+	if (!(new_status & WDC_SR_PSUOVER))
+		*status |= WDIOF_POWEROVER;
+	if (!(new_status & WDC_SR_PSUUNDR))
+		*status |= WDIOF_POWERUNDER;
+	if (tachometer) {
+		if (!(new_status & WDC_SR_FANGOOD))
+			*status |= WDIOF_FANFAULT;
+	}
+#endif /* CONFIG_WDT_501 */
+	return 0;
+}
 
-	if(!(status&WDC_SR_TGOOD))
-		flag|=WDIOF_OVERHEAT;
-	if(!(status&WDC_SR_PSUOVER))
-		flag|=WDIOF_POWEROVER;
-	if(!(status&WDC_SR_PSUUNDR))
-		flag|=WDIOF_POWERUNDER;
-	if(!(status&WDC_SR_FANGOOD))
-		flag|=WDIOF_FANFAULT;
-	if(status&WDC_SR_ISOI0)
-		flag|=WDIOF_EXTERN1;
-	if(status&WDC_SR_ISII1)
-		flag|=WDIOF_EXTERN2;
-	return flag;
+#ifdef CONFIG_WDT_501
+/**
+ *	wdt_get_temperature:
+ *
+ *	Reports the temperature in degrees Fahrenheit. The API is in
+ *	farenheit. It was designed by an imperial measurement luddite.
+ */
+
+static int wdt_get_temperature(int *temperature)
+{
+	unsigned short c=inb_p(WDT_RT);
+
+	*temperature = (c * 11 / 15) + 7;
+	return 0;
 }
+#endif /* CONFIG_WDT_501 */
 
 /**
  *	wdt_interrupt:
@@ -155,23 +244,23 @@ static irqreturn_t wdt_interrupt(int irq
 	 *	Read the status register see what is up and
 	 *	then printk it.
 	 */
-
 	unsigned char status=inb_p(WDT_SR);
 
-	status|=FEATUREMAP1;
-	status&=~FEATUREMAP2;
-
 	printk(KERN_CRIT "WDT status %d\n", status);
 
-	if(!(status&WDC_SR_TGOOD))
+#ifdef CONFIG_WDT_501
+	if (!(status & WDC_SR_TGOOD))
 		printk(KERN_CRIT "Overheat alarm.(%d)\n",inb_p(WDT_RT));
-	if(!(status&WDC_SR_PSUOVER))
+	if (!(status & WDC_SR_PSUOVER))
 		printk(KERN_CRIT "PSU over voltage.\n");
-	if(!(status&WDC_SR_PSUUNDR))
+	if (!(status & WDC_SR_PSUUNDR))
 		printk(KERN_CRIT "PSU under voltage.\n");
-	if(!(status&WDC_SR_FANGOOD))
-		printk(KERN_CRIT "Possible fan fault.\n");
-	if(!(status&WDC_SR_WCCR))
+	if (tachometer) {
+		if (!(status & WDC_SR_FANGOOD))
+			printk(KERN_CRIT "Possible fan fault.\n");
+	}
+#endif /* CONFIG_WDT_501 */
+	if (!(status & WDC_SR_WCCR))
 #ifdef SOFTWARE_REBOOT
 #ifdef ONLY_TESTING
 		printk(KERN_CRIT "Would Reboot.\n");
@@ -187,22 +276,6 @@ static irqreturn_t wdt_interrupt(int irq
 
 
 /**
- *	wdt_ping:
- *
- *	Reload counter one with the watchdog timeout. We don't bother reloading
- *	the cascade counter.
- */
-
-static void wdt_ping(void)
-{
-	/* Write a watchdog value */
-	inb_p(WDT_DC);
-	wdt_ctr_mode(1,2);
-	wdt_ctr_load(1,wd_margin);		/* Timeout */
-	outb_p(0, WDT_DC);
-}
-
-/**
  *	wdt_write:
  *	@file: file handle to the watchdog
  *	@buf: buffer to write (unused as data does not matter here
@@ -240,40 +313,6 @@ static ssize_t wdt_write(struct file *fi
 }
 
 /**
- *	wdt_read:
- *	@file: file handle to the watchdog board
- *	@buf: buffer to write 1 byte into
- *	@count: length of buffer
- *	@ptr: offset (no seek allowed)
- *
- *	Read reports the temperature in degrees Fahrenheit. The API is in
- *	farenheit. It was designed by an imperial measurement luddite.
- */
-
-static ssize_t wdt_read(struct file *file, char *buf, size_t count, loff_t *ptr)
-{
-	unsigned short c=inb_p(WDT_RT);
-	unsigned char cp;
-
-	/*  Can't seek (pread) on this device  */
-	if (ptr != &file->f_pos)
-		return -ESPIPE;
-
-	switch(iminor(file->f_dentry->d_inode))
-	{
-		case TEMP_MINOR:
-			c*=11;
-			c/=15;
-			cp=c+7;
-			if(copy_to_user(buf,&cp,1))
-				return -EFAULT;
-			return 1;
-		default:
-			return -EINVAL;
-	}
-}
-
-/**
  *	wdt_ioctl:
  *	@inode: inode of the device
  *	@file: file handle to the device
@@ -288,18 +327,25 @@ static ssize_t wdt_read(struct file *fil
 static int wdt_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
 	unsigned long arg)
 {
-	int new_margin;
+	int new_heartbeat;
+	int status;
 
-	static struct watchdog_info ident=
-	{
-		.options = WDIOF_OVERHEAT|WDIOF_POWERUNDER|WDIOF_POWEROVER
-					|WDIOF_EXTERN1|WDIOF_EXTERN2|WDIOF_FANFAULT
-					|WDIOF_SETTIMEOUT|WDIOF_MAGICCLOSE,
-		.firmware_version = 1,
-		.identity = "WDT500/501",
+	static struct watchdog_info ident = {
+		.options =		WDIOF_SETTIMEOUT|
+					WDIOF_MAGICCLOSE|
+					WDIOF_KEEPALIVEPING,
+		.firmware_version =	1,
+		.identity =		"WDT500/501",
 	};
 
-	ident.options&=WDT_OPTION_MASK;	/* Mask down to the card we have */
+	/* Add options according to the card we have */
+	ident.options |= (WDIOF_EXTERN1|WDIOF_EXTERN2);
+#ifdef CONFIG_WDT_501
+	ident.options |= (WDIOF_OVERHEAT|WDIOF_POWERUNDER|WDIOF_POWEROVER);
+	if (tachometer)
+		ident.options |= WDIOF_FANFAULT;
+#endif /* CONFIG_WDT_501 */
+
 	switch(cmd)
 	{
 		default:
@@ -308,23 +354,24 @@ static int wdt_ioctl(struct inode *inode
 			return copy_to_user((struct watchdog_info *)arg, &ident, sizeof(ident))?-EFAULT:0;
 
 		case WDIOC_GETSTATUS:
-			return put_user(wdt_status(),(int *)arg);
+			wdt_get_status(&status);
+			return put_user(status,(int *)arg);
 		case WDIOC_GETBOOTSTATUS:
 			return put_user(0, (int *)arg);
 		case WDIOC_KEEPALIVE:
 			wdt_ping();
 			return 0;
 		case WDIOC_SETTIMEOUT:
-			if (get_user(new_margin, (int *)arg))
+			if (get_user(new_heartbeat, (int *)arg))
 				return -EFAULT;
-			/* Arbitrary, can't find the card's limits */
-			if ((new_margin < 0) || (new_margin > 60))
+
+			if (wdt_set_heartbeat(new_heartbeat))
 				return -EINVAL;
-			wd_margin = new_margin * 100;
+
 			wdt_ping();
 			/* Fall */
 		case WDIOC_GETTIMEOUT:
-			return put_user(wd_margin / 100, (int *)arg);
+			return put_user(heartbeat, (int *)arg);
 	}
 }
 
@@ -333,43 +380,26 @@ static int wdt_ioctl(struct inode *inode
  *	@inode: inode of device
  *	@file: file handle to device
  *
- *	One of our two misc devices has been opened. The watchdog device is
- *	single open and on opening we load the counters. Counter zero is a
- *	100Hz cascade, into counter 1 which downcounts to reboot. When the
- *	counter triggers counter 2 downcounts the length of the reset pulse
- *	which set set to be as long as possible.
+ *	The watchdog device has been opened. The watchdog device is single
+ *	open and on opening we load the counters. Counter zero is a 100Hz
+ *	cascade, into counter 1 which downcounts to reboot. When the counter
+ *	triggers counter 2 downcounts the length of the reset pulse which
+ *	set set to be as long as possible.
  */
 
 static int wdt_open(struct inode *inode, struct file *file)
 {
-	switch(iminor(inode))
-	{
-		case WATCHDOG_MINOR:
-			if(test_and_set_bit(0, &wdt_is_open))
-				return -EBUSY;
-			/*
-			 *	Activate
-			 */
-
-			wdt_is_open=1;
-			inb_p(WDT_DC);		/* Disable */
-			wdt_ctr_mode(0,3);
-			wdt_ctr_mode(1,2);
-			wdt_ctr_mode(2,0);
-			wdt_ctr_load(0, 8948);		/* count at 100Hz */
-			wdt_ctr_load(1,wd_margin);	/* Timeout 120 seconds */
-			wdt_ctr_load(2,65535);
-			outb_p(0, WDT_DC);	/* Enable */
-			return 0;
-		case TEMP_MINOR:
-			return 0;
-		default:
-			return -ENODEV;
-	}
+	if(test_and_set_bit(0, &wdt_is_open))
+		return -EBUSY;
+	/*
+	 *	Activate
+	 */
+	wdt_start();
+	return 0;
 }
 
 /**
- *	wdt_close:
+ *	wdt_release:
  *	@inode: inode to board
  *	@file: file handle to board
  *
@@ -382,21 +412,74 @@ static int wdt_open(struct inode *inode,
 
 static int wdt_release(struct inode *inode, struct file *file)
 {
-	if(iminor(inode)==WATCHDOG_MINOR)
-	{
-		if (expect_close == 42) {
-			inb_p(WDT_DC);		/* Disable counters */
-			wdt_ctr_load(2,0);	/* 0 length reset pulses now */
-		} else {
-			printk(KERN_CRIT "wdt: WDT device closed unexpectedly.  WDT will not stop!\n");
-		}
+	if (expect_close == 42) {
+		wdt_stop();
 		clear_bit(0, &wdt_is_open);
-		expect_close = 0;
+	} else {
+		printk(KERN_CRIT "wdt: WDT device closed unexpectedly.  WDT will not stop!\n");
+		wdt_ping();
 	}
+	expect_close = 0;
+	return 0;
+}
+
+#ifdef CONFIG_WDT_501
+/**
+ *	wdt_temp_read:
+ *	@file: file handle to the watchdog board
+ *	@buf: buffer to write 1 byte into
+ *	@count: length of buffer
+ *	@ptr: offset (no seek allowed)
+ *
+ *	Temp_read reports the temperature in degrees Fahrenheit. The API is in
+ *	farenheit. It was designed by an imperial measurement luddite.
+ */
+
+static ssize_t wdt_temp_read(struct file *file, char *buf, size_t count, loff_t *ptr)
+{
+	int temperature;
+
+	/*  Can't seek (pread) on this device  */
+	if (ptr != &file->f_pos)
+		return -ESPIPE;
+
+	if (wdt_get_temperature(&temperature))
+		return -EFAULT;
+
+	if (copy_to_user (buf, &temperature, 1))
+		return -EFAULT;
+
+	return 1;
+}
+
+/**
+ *	wdt_temp_open:
+ *	@inode: inode of device
+ *	@file: file handle to device
+ *
+ *	The temperature device has been opened.
+ */
+
+static int wdt_temp_open(struct inode *inode, struct file *file)
+{
 	return 0;
 }
 
 /**
+ *	wdt_temp_release:
+ *	@inode: inode to board
+ *	@file: file handle to board
+ *
+ *	The temperature device has been closed.
+ */
+
+static int wdt_temp_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+#endif /* CONFIG_WDT_501 */
+
+/**
  *	notify_sys:
  *	@this: our notifier block
  *	@code: the event being reported
@@ -411,11 +494,9 @@ static int wdt_release(struct inode *ino
 static int wdt_notify_sys(struct notifier_block *this, unsigned long code,
 	void *unused)
 {
-	if(code==SYS_DOWN || code==SYS_HALT)
-	{
+	if(code==SYS_DOWN || code==SYS_HALT) {
 		/* Turn the card off */
-		inb_p(WDT_DC);
-		wdt_ctr_load(2,0);
+		wdt_stop();
 	}
 	return NOTIFY_DONE;
 }
@@ -428,36 +509,40 @@ static int wdt_notify_sys(struct notifie
 static struct file_operations wdt_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
-	.read		= wdt_read,
 	.write		= wdt_write,
 	.ioctl		= wdt_ioctl,
 	.open		= wdt_open,
 	.release	= wdt_release,
 };
 
-static struct miscdevice wdt_miscdev=
-{
+static struct miscdevice wdt_miscdev = {
 	.minor	= WATCHDOG_MINOR,
 	.name	= "watchdog",
 	.fops	= &wdt_fops,
 };
 
 #ifdef CONFIG_WDT_501
-static struct miscdevice temp_miscdev=
-{
+static struct file_operations wdt_temp_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= wdt_temp_read,
+	.open		= wdt_temp_open,
+	.release	= wdt_temp_release,
+};
+
+static struct miscdevice temp_miscdev = {
 	.minor	= TEMP_MINOR,
 	.name	= "temperature",
-	.fops	= &wdt_fops,
+	.fops	= &wdt_temp_fops,
 };
-#endif
+#endif /* CONFIG_WDT_501 */
 
 /*
  *	The WDT card needs to learn about soft shutdowns in order to
  *	turn the timebomb registers off.
  */
 
-static struct notifier_block wdt_notifier=
-{
+static struct notifier_block wdt_notifier = {
 	.notifier_call = wdt_notify_sys,
 };
 
@@ -476,10 +561,10 @@ static void __exit wdt_exit(void)
 	misc_deregister(&wdt_miscdev);
 #ifdef CONFIG_WDT_501
 	misc_deregister(&temp_miscdev);
-#endif
+#endif /* CONFIG_WDT_501 */
 	unregister_reboot_notifier(&wdt_notifier);
-	release_region(io,8);
 	free_irq(irq, NULL);
+	release_region(io,8);
 }
 
 /**
@@ -494,51 +579,67 @@ static int __init wdt_init(void)
 {
 	int ret;
 
-	ret = misc_register(&wdt_miscdev);
-	if (ret) {
-		printk(KERN_ERR "wdt: can't misc_register on minor=%d\n", WATCHDOG_MINOR);
+	/* Check that the heartbeat value is within it's range ; if not reset to the default */
+	if (wdt_set_heartbeat(heartbeat)) {
+		wdt_set_heartbeat(WD_TIMO);
+		printk(KERN_INFO "wdt: heartbeat value must be 0<heartbeat<65536, using %d\n",
+			WD_TIMO);
+	}
+
+	if (!request_region(io, 8, "wdt501p")) {
+		printk(KERN_ERR "wdt: I/O address 0x%04x already in use\n", io);
+		ret = -EBUSY;
 		goto out;
 	}
+
 	ret = request_irq(irq, wdt_interrupt, SA_INTERRUPT, "wdt501p", NULL);
 	if(ret) {
 		printk(KERN_ERR "wdt: IRQ %d is not free.\n", irq);
-		goto outmisc;
-	}
-	if (!request_region(io, 8, "wdt501p")) {
-		printk(KERN_ERR "wdt: IO %X is not free.\n", io);
-		ret = -EBUSY;
-		goto outirq;
+		goto outreg;
 	}
+
 	ret = register_reboot_notifier(&wdt_notifier);
 	if(ret) {
-		printk(KERN_ERR "wdt: can't register reboot notifier (err=%d)\n", ret);
-		goto outreg;
+		printk(KERN_ERR "wdt: cannot register reboot notifier (err=%d)\n", ret);
+		goto outirq;
 	}
 
 #ifdef CONFIG_WDT_501
 	ret = misc_register(&temp_miscdev);
 	if (ret) {
-		printk(KERN_ERR "wdt: can't misc_register (temp) on minor=%d\n", TEMP_MINOR);
+		printk(KERN_ERR "wdt: cannot register miscdev on minor=%d (err=%d)\n",
+			TEMP_MINOR, ret);
 		goto outrbt;
 	}
-#endif
+#endif /* CONFIG_WDT_501 */
+
+	ret = misc_register(&wdt_miscdev);
+	if (ret) {
+		printk(KERN_ERR "wdt: cannot register miscdev on minor=%d (err=%d)\n",
+			WATCHDOG_MINOR, ret);
+		goto outmisc;
+	}
 
 	ret = 0;
-	printk(KERN_INFO "WDT500/501-P driver 0.07 at %X (Interrupt %d)\n", io, irq);
+	printk(KERN_INFO "WDT500/501-P driver 0.10 at 0x%04x (Interrupt %d). heartbeat=%d sec (nowayout=%d)\n",
+		io, irq, heartbeat, nowayout);
+#ifdef CONFIG_WDT_501
+	printk(KERN_INFO "wdt: Fan Tachometer is %s\n", (tachometer ? "Enabled" : "Disabled"));
+#endif /* CONFIG_WDT_501 */
+
 out:
 	return ret;
 
+outmisc:
 #ifdef CONFIG_WDT_501
+	misc_deregister(&temp_miscdev);
+#endif /* CONFIG_WDT_501 */
 outrbt:
 	unregister_reboot_notifier(&wdt_notifier);
-#endif
-
-outreg:
-	release_region(io,8);
 outirq:
 	free_irq(irq, NULL);
-outmisc:
-	misc_deregister(&wdt_miscdev);
+outreg:
+	release_region(io,8);
 	goto out;
 }
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/wdt_pci.c linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/wdt_pci.c
--- linux-post-2.6.5-rc2-20040320/drivers/char/watchdog/wdt_pci.c	2004-03-02 03:01:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/char/watchdog/wdt_pci.c	2004-03-21 10:21:19.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *	Industrial Computer Source WDT500/501 driver for Linux 2.1.x
+ *	Industrial Computer Source PCI-WDT500/501 driver
  *
  *	(c) Copyright 1996-1997 Alan Cox <alan@redhat.com>, All Rights Reserved.
  *				http://www.redhat.com
@@ -15,7 +15,7 @@
  *
  *	(c) Copyright 1995    Alan Cox <alan@lxorguk.ukuu.org.uk>
  *
- *	Release 0.09.
+ *	Release 0.10.
  *
  *	Fixes
  *		Dave Gregorich	:	Modularisation and minor bugs
@@ -46,6 +46,7 @@
 #include <linux/notifier.h>
 #include <linux/reboot.h>
 #include <linux/init.h>
+#include <linux/fs.h>
 #include <linux/pci.h>
 
 #include <asm/io.h>
@@ -70,6 +71,9 @@
 #define PCI_DEVICE_ID_WDG_CSM 0x22c0
 #endif
 
+/* We can only use 1 card due to the /dev/watchdog restriction */
+static int dev_count;
+
 static struct semaphore open_sem;
 static spinlock_t wdtpci_lock;
 static char expect_close;
@@ -78,10 +82,12 @@ static int io;
 static int irq;
 
 /* Default timeout */
-#define WD_TIMO (100*60)		/* 1 minute */
-#define WD_TIMO_MAX (WD_TIMO*60)	/* 1 hour(?) */
+#define WD_TIMO 60			/* Default heartbeat = 60 seconds */
 
-static int wd_margin = WD_TIMO;
+static int heartbeat = WD_TIMO;
+static int wd_heartbeat;
+module_param(heartbeat, int, 0);
+MODULE_PARM_DESC(heartbeat, "Watchdog heartbeat in seconds. (0<heartbeat<65536, default=" __MODULE_STRING(WD_TIMO) ")");
 
 #ifdef CONFIG_WATCHDOG_NOWAYOUT
 static int nowayout = 1;
@@ -92,6 +98,14 @@ static int nowayout = 0;
 module_param(nowayout, int, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=CONFIG_WATCHDOG_NOWAYOUT)");
 
+#ifdef CONFIG_WDT_501_PCI
+/* Support for the Fan Tachometer on the PCI-WDT501 */
+static int tachometer;
+
+module_param(tachometer, int, 0);
+MODULE_PARM_DESC(tachometer, "PCI-WDT501 Fan Tachometer support (0=disable, default=0)");
+#endif /* CONFIG_WDT_501_PCI */
+
 /*
  *	Programming support
  */
@@ -110,13 +124,105 @@ static void wdtpci_ctr_load(int ctr, int
 	outb_p(val>>8, WDT_COUNT0+ctr);
 }
 
-/*
- *	Kernel methods.
+/**
+ *	wdtpci_start:
+ *
+ *	Start the watchdog driver.
  */
 
+static int wdtpci_start(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wdtpci_lock, flags);
+
+	/*
+	 * "pet" the watchdog, as Access says.
+	 * This resets the clock outputs.
+	 */
+	inb_p(WDT_DC);			/* Disable watchdog */
+	wdtpci_ctr_mode(2,0);		/* Program CTR2 for Mode 0: Pulse on Terminal Count */
+	outb_p(0, WDT_DC);		/* Enable watchdog */
+
+	inb_p(WDT_DC);			/* Disable watchdog */
+	outb_p(0, WDT_CLOCK);		/* 2.0833MHz clock */
+	inb_p(WDT_BUZZER);		/* disable */
+	inb_p(WDT_OPTONOTRST);		/* disable */
+	inb_p(WDT_OPTORST);		/* disable */
+	inb_p(WDT_PROGOUT);		/* disable */
+	wdtpci_ctr_mode(0,3);		/* Program CTR0 for Mode 3: Square Wave Generator */
+	wdtpci_ctr_mode(1,2);		/* Program CTR1 for Mode 2: Rate Generator */
+	wdtpci_ctr_mode(2,1);		/* Program CTR2 for Mode 1: Retriggerable One-Shot */
+	wdtpci_ctr_load(0,20833);	/* count at 100Hz */
+	wdtpci_ctr_load(1,wd_heartbeat);/* Heartbeat */
+	/* DO NOT LOAD CTR2 on PCI card! -- JPN */
+	outb_p(0, WDT_DC);		/* Enable watchdog */
+
+	spin_unlock_irqrestore(&wdtpci_lock, flags);
+	return 0;
+}
+
+/**
+ *	wdtpci_stop:
+ *
+ *	Stop the watchdog driver.
+ */
+
+static int wdtpci_stop (void)
+{
+	unsigned long flags;
+
+	/* Turn the card off */
+	spin_lock_irqsave(&wdtpci_lock, flags);
+	inb_p(WDT_DC);			/* Disable watchdog */
+	wdtpci_ctr_load(2,0);		/* 0 length reset pulses now */
+	spin_unlock_irqrestore(&wdtpci_lock, flags);
+	return 0;
+}
+
+/**
+ *	wdtpci_ping:
+ *
+ *	Reload counter one with the watchdog heartbeat. We don't bother reloading
+ *	the cascade counter.
+ */
+
+static int wdtpci_ping(void)
+{
+	unsigned long flags;
+
+	/* Write a watchdog value */
+	spin_lock_irqsave(&wdtpci_lock, flags);
+	inb_p(WDT_DC);			/* Disable watchdog */
+	wdtpci_ctr_mode(1,2);		/* Re-Program CTR1 for Mode 2: Rate Generator */
+	wdtpci_ctr_load(1,wd_heartbeat);/* Heartbeat */
+	outb_p(0, WDT_DC);		/* Enable watchdog */
+	spin_unlock_irqrestore(&wdtpci_lock, flags);
+	return 0;
+}
+
+/**
+ *	wdtpci_set_heartbeat:
+ *	@t:		the new heartbeat value that needs to be set.
+ *
+ *	Set a new heartbeat value for the watchdog device. If the heartbeat value is
+ *	incorrect we keep the old value and return -EINVAL. If successfull we
+ *	return 0.
+ */
+static int wdtpci_set_heartbeat(int t)
+{
+	/* Arbitrary, can't find the card's limits */
+	if ((t < 1) || (t > 65535))
+		return -EINVAL;
+
+	heartbeat = t;
+	wd_heartbeat = t * 100;
+	return 0;
+}
 
 /**
- *	wdtpci_status:
+ *	wdtpci_get_status:
+ *	@status:		the new status.
  *
  *	Extract the status information from a WDT watchdog device. There are
  *	several board variants so we have to know which bits are valid. Some
@@ -125,31 +231,46 @@ static void wdtpci_ctr_load(int ctr, int
  *	we then map the bits onto the status ioctl flags.
  */
 
-static int wdtpci_status(void)
+static int wdtpci_get_status(int *status)
 {
-	/*
-	 *	Status register to bit flags
-	 */
+	unsigned char new_status=inb_p(WDT_SR);
 
-	int flag=0;
-	unsigned char status=inb_p(WDT_SR);
-	status|=FEATUREMAP1;
-	status&=~FEATUREMAP2;
+	*status=0;
+	if (new_status & WDC_SR_ISOI0)
+		*status |= WDIOF_EXTERN1;
+	if (new_status & WDC_SR_ISII1)
+		*status |= WDIOF_EXTERN2;
+#ifdef CONFIG_WDT_501_PCI
+	if (!(new_status & WDC_SR_TGOOD))
+		*status |= WDIOF_OVERHEAT;
+	if (!(new_status & WDC_SR_PSUOVER))
+		*status |= WDIOF_POWEROVER;
+	if (!(new_status & WDC_SR_PSUUNDR))
+		*status |= WDIOF_POWERUNDER;
+	if (tachometer) {
+		if (!(new_status & WDC_SR_FANGOOD))
+			*status |= WDIOF_FANFAULT;
+	}
+#endif /* CONFIG_WDT_501_PCI */
+	return 0;
+}
 
-	if(!(status&WDC_SR_TGOOD))
-		flag|=WDIOF_OVERHEAT;
-	if(!(status&WDC_SR_PSUOVER))
-		flag|=WDIOF_POWEROVER;
-	if(!(status&WDC_SR_PSUUNDR))
-		flag|=WDIOF_POWERUNDER;
-	if(!(status&WDC_SR_FANGOOD))
-		flag|=WDIOF_FANFAULT;
-	if(status&WDC_SR_ISOI0)
-		flag|=WDIOF_EXTERN1;
-	if(status&WDC_SR_ISII1)
-		flag|=WDIOF_EXTERN2;
-	return flag;
+#ifdef CONFIG_WDT_501_PCI
+/**
+ *	wdtpci_get_temperature:
+ *
+ *	Reports the temperature in degrees Fahrenheit. The API is in
+ *	farenheit. It was designed by an imperial measurement luddite.
+ */
+
+static int wdtpci_get_temperature(int *temperature)
+{
+	unsigned short c=inb_p(WDT_RT);
+
+	*temperature = (c * 11 / 15) + 7;
+	return 0;
 }
+#endif /* CONFIG_WDT_501_PCI */
 
 /**
  *	wdtpci_interrupt:
@@ -168,58 +289,38 @@ static irqreturn_t wdtpci_interrupt(int 
 	 *	Read the status register see what is up and
 	 *	then printk it.
 	 */
-
 	unsigned char status=inb_p(WDT_SR);
 
-	status|=FEATUREMAP1;
-	status&=~FEATUREMAP2;
-
-	printk(KERN_CRIT "WDT status %d\n", status);
+	printk(KERN_CRIT PFX "status %d\n", status);
 
-	if(!(status&WDC_SR_TGOOD))
-		printk(KERN_CRIT "Overheat alarm.(%d)\n",inb_p(WDT_RT));
-	if(!(status&WDC_SR_PSUOVER))
-		printk(KERN_CRIT "PSU over voltage.\n");
-	if(!(status&WDC_SR_PSUUNDR))
-		printk(KERN_CRIT "PSU under voltage.\n");
-	if(!(status&WDC_SR_FANGOOD))
-		printk(KERN_CRIT "Possible fan fault.\n");
-	if(!(status&WDC_SR_WCCR))
+#ifdef CONFIG_WDT_501_PCI
+	if (!(status & WDC_SR_TGOOD))
+ 		printk(KERN_CRIT PFX "Overheat alarm.(%d)\n",inb_p(WDT_RT));
+	if (!(status & WDC_SR_PSUOVER))
+ 		printk(KERN_CRIT PFX "PSU over voltage.\n");
+	if (!(status & WDC_SR_PSUUNDR))
+ 		printk(KERN_CRIT PFX "PSU under voltage.\n");
+	if (tachometer) {
+		if (!(status & WDC_SR_FANGOOD))
+			printk(KERN_CRIT PFX "Possible fan fault.\n");
+	}
+#endif /* CONFIG_WDT_501_PCI */
+	if (!(status&WDC_SR_WCCR))
 #ifdef SOFTWARE_REBOOT
 #ifdef ONLY_TESTING
-		printk(KERN_CRIT "Would Reboot.\n");
+		printk(KERN_CRIT PFX "Would Reboot.\n");
 #else
-		printk(KERN_CRIT "Initiating system reboot.\n");
+		printk(KERN_CRIT PFX "Initiating system reboot.\n");
 		machine_restart(NULL);
 #endif
 #else
-		printk(KERN_CRIT "Reset in 5ms.\n");
+		printk(KERN_CRIT PFX "Reset in 5ms.\n");
 #endif
 	return IRQ_HANDLED;
 }
 
 
 /**
- *	wdtpci_ping:
- *
- *	Reload counter one with the watchdog timeout. We don't bother reloading
- *	the cascade counter.
- */
-
-static void wdtpci_ping(void)
-{
-	unsigned long flags;
-
-	/* Write a watchdog value */
-	spin_lock_irqsave(&wdtpci_lock, flags);
-	inb_p(WDT_DC);
-	wdtpci_ctr_mode(1,2);
-	wdtpci_ctr_load(1,wd_margin);		/* Timeout */
-	outb_p(0, WDT_DC);
-	spin_unlock_irqrestore(&wdtpci_lock, flags);
-}
-
-/**
  *	wdtpci_write:
  *	@file: file handle to the watchdog
  *	@buf: buffer to write (unused as data does not matter here
@@ -257,40 +358,6 @@ static ssize_t wdtpci_write(struct file 
 }
 
 /**
- *	wdtpci_read:
- *	@file: file handle to the watchdog board
- *	@buf: buffer to write 1 byte into
- *	@count: length of buffer
- *	@ptr: offset (no seek allowed)
- *
- *	Read reports the temperature in degrees Fahrenheit. The API is in
- *	fahrenheit. It was designed by an imperial measurement luddite.
- */
-
-static ssize_t wdtpci_read(struct file *file, char *buf, size_t count, loff_t *ptr)
-{
-	unsigned short c=inb_p(WDT_RT);
-	unsigned char cp;
-
-	/*  Can't seek (pread) on this device  */
-	if (ptr != &file->f_pos)
-		return -ESPIPE;
-
-	switch(iminor(file->f_dentry->d_inode))
-	{
-		case TEMP_MINOR:
-			c*=11;
-			c/=15;
-			cp=c+7;
-			if(copy_to_user(buf,&cp,1))
-				return -EFAULT;
-			return 1;
-		default:
-			return -EINVAL;
-	}
-}
-
-/**
  *	wdtpci_ioctl:
  *	@inode: inode of the device
  *	@file: file handle to the device
@@ -305,17 +372,25 @@ static ssize_t wdtpci_read(struct file *
 static int wdtpci_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
 	unsigned long arg)
 {
-	int new_margin;
+	int new_heartbeat;
+	int status;
+
 	static struct watchdog_info ident = {
-		.options	= WDIOF_OVERHEAT  | WDIOF_POWERUNDER |
-				  WDIOF_POWEROVER | WDIOF_EXTERN1 |
-				  WDIOF_EXTERN2   | WDIOF_FANFAULT |
-				  WDIOF_SETTIMEOUT|WDIOF_MAGICCLOSE,
-		.firmware_version = 1,
-		.identity	  = "WDT500/501PCI",
+		.options =		WDIOF_SETTIMEOUT|
+					WDIOF_MAGICCLOSE|
+					WDIOF_KEEPALIVEPING,
+		.firmware_version =	1,
+		.identity =		"PCI-WDT500/501",
 	};
 
-	ident.options&=WDT_OPTION_MASK;	/* Mask down to the card we have */
+	/* Add options according to the card we have */
+	ident.options |= (WDIOF_EXTERN1|WDIOF_EXTERN2);
+#ifdef CONFIG_WDT_501_PCI
+	ident.options |= (WDIOF_OVERHEAT|WDIOF_POWERUNDER|WDIOF_POWEROVER);
+	if (tachometer)
+		ident.options |= WDIOF_FANFAULT;
+#endif /* CONFIG_WDT_501_PCI */
+
 	switch(cmd)
 	{
 		default:
@@ -324,24 +399,24 @@ static int wdtpci_ioctl(struct inode *in
 			return copy_to_user((struct watchdog_info *)arg, &ident, sizeof(ident))?-EFAULT:0;
 
 		case WDIOC_GETSTATUS:
-			return put_user(wdtpci_status(),(int *)arg);
+			wdtpci_get_status(&status);
+			return put_user(status,(int *)arg);
 		case WDIOC_GETBOOTSTATUS:
 			return put_user(0, (int *)arg);
 		case WDIOC_KEEPALIVE:
 			wdtpci_ping();
 			return 0;
 		case WDIOC_SETTIMEOUT:
-			if (get_user(new_margin, (int *)arg))
+			if (get_user(new_heartbeat, (int *)arg))
 				return -EFAULT;
-			/* Arbitrary, can't find the card's limits */
-			new_margin *= 100;
-			if ((new_margin < 0) || (new_margin > WD_TIMO_MAX))
+
+			if (wdtpci_set_heartbeat(new_heartbeat))
 				return -EINVAL;
-			wd_margin = new_margin;
+
 			wdtpci_ping();
 			/* Fall */
 		case WDIOC_GETTIMEOUT:
-			return put_user(wd_margin / 100, (int *)arg);
+			return put_user(heartbeat, (int *)arg);
 	}
 }
 
@@ -350,66 +425,30 @@ static int wdtpci_ioctl(struct inode *in
  *	@inode: inode of device
  *	@file: file handle to device
  *
- *	One of our two misc devices has been opened. The watchdog device is
- *	single open and on opening we load the counters. Counter zero is a
- *	100Hz cascade, into counter 1 which downcounts to reboot. When the
- *	counter triggers counter 2 downcounts the length of the reset pulse
- *	which set set to be as long as possible.
+ *	The watchdog device has been opened. The watchdog device is single
+ *	open and on opening we load the counters. Counter zero is a 100Hz
+ *	cascade, into counter 1 which downcounts to reboot. When the counter
+ *	triggers counter 2 downcounts the length of the reset pulse which
+ *	set set to be as long as possible.
  */
 
 static int wdtpci_open(struct inode *inode, struct file *file)
 {
-	unsigned long flags;
+	if (down_trylock(&open_sem))
+		return -EBUSY;
 
-	switch(iminor(inode))
-	{
-		case WATCHDOG_MINOR:
-			if (down_trylock(&open_sem))
-				return -EBUSY;
-
-			if (nowayout) {
-				__module_get(THIS_MODULE);
-			}
-			/*
-			 *	Activate
-			 */
-			spin_lock_irqsave(&wdtpci_lock, flags);
-
-			inb_p(WDT_DC);		/* Disable */
-
-			/*
-			 * "pet" the watchdog, as Access says.
-			 * This resets the clock outputs.
-			 */
-
-			wdtpci_ctr_mode(2,0);
-			outb_p(0, WDT_DC);
-
-			inb_p(WDT_DC);
-
-			outb_p(0, WDT_CLOCK);	/* 2.0833MHz clock */
-			inb_p(WDT_BUZZER);	/* disable */
-			inb_p(WDT_OPTONOTRST);	/* disable */
-			inb_p(WDT_OPTORST);	/* disable */
-			inb_p(WDT_PROGOUT);	/* disable */
-			wdtpci_ctr_mode(0,3);
-			wdtpci_ctr_mode(1,2);
-			wdtpci_ctr_mode(2,1);
-			wdtpci_ctr_load(0,20833);	/* count at 100Hz */
-			wdtpci_ctr_load(1,wd_margin);/* Timeout 60 seconds */
-			/* DO NOT LOAD CTR2 on PCI card! -- JPN */
-			outb_p(0, WDT_DC);	/* Enable */
-			spin_unlock_irqrestore(&wdtpci_lock, flags);
-			return 0;
-		case TEMP_MINOR:
-			return 0;
-		default:
-			return -ENODEV;
+	if (nowayout) {
+		__module_get(THIS_MODULE);
 	}
+	/*
+	 *	Activate
+	 */
+	wdtpci_start();
+	return 0;
 }
 
 /**
- *	wdtpci_close:
+ *	wdtpci_release:
  *	@inode: inode to board
  *	@file: file handle to board
  *
@@ -422,24 +461,73 @@ static int wdtpci_open(struct inode *ino
 
 static int wdtpci_release(struct inode *inode, struct file *file)
 {
-
-	if (iminor(inode)==WATCHDOG_MINOR) {
-		unsigned long flags;
-		if (expect_close == 42) {
-			spin_lock_irqsave(&wdtpci_lock, flags);
-			inb_p(WDT_DC);		/* Disable counters */
-			wdtpci_ctr_load(2,0);	/* 0 length reset pulses now */
-			spin_unlock_irqrestore(&wdtpci_lock, flags);
-		} else {
-			printk(KERN_CRIT PFX "Unexpected close, not stopping timer!");
-			wdtpci_ping();
-		}
-		expect_close = 0;
-		up(&open_sem);
+	if (expect_close == 42) {
+		wdtpci_stop();
+	} else {
+		printk(KERN_CRIT PFX "Unexpected close, not stopping timer!");
+		wdtpci_ping();
 	}
+	expect_close = 0;
+	up(&open_sem);
 	return 0;
 }
 
+#ifdef CONFIG_WDT_501_PCI
+/**
+ *	wdtpci_temp_read:
+ *	@file: file handle to the watchdog board
+ *	@buf: buffer to write 1 byte into
+ *	@count: length of buffer
+ *	@ptr: offset (no seek allowed)
+ *
+ *	Read reports the temperature in degrees Fahrenheit. The API is in
+ *	fahrenheit. It was designed by an imperial measurement luddite.
+ */
+
+static ssize_t wdtpci_temp_read(struct file *file, char *buf, size_t count, loff_t *ptr)
+{
+	int temperature;
+
+	/*  Can't seek (pread) on this device  */
+	if (ptr != &file->f_pos)
+		return -ESPIPE;
+
+	if (wdtpci_get_temperature(&temperature))
+		return -EFAULT;
+
+	if (copy_to_user (buf, &temperature, 1))
+		return -EFAULT;
+
+	return 1;
+}
+
+/**
+ *	wdtpci_temp_open:
+ *	@inode: inode of device
+ *	@file: file handle to device
+ *
+ *	The temperature device has been opened.
+ */
+
+static int wdtpci_temp_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/**
+ *	wdtpci_temp_release:
+ *	@inode: inode to board
+ *	@file: file handle to board
+ *
+ *	The temperature device has been closed.
+ */
+
+static int wdtpci_temp_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+#endif /* CONFIG_WDT_501_PCI */
+
 /**
  *	notify_sys:
  *	@this: our notifier block
@@ -455,14 +543,9 @@ static int wdtpci_release(struct inode *
 static int wdtpci_notify_sys(struct notifier_block *this, unsigned long code,
 	void *unused)
 {
-	unsigned long flags;
-
 	if (code==SYS_DOWN || code==SYS_HALT) {
 		/* Turn the card off */
-		spin_lock_irqsave(&wdtpci_lock, flags);
-		inb_p(WDT_DC);
-		wdtpci_ctr_load(2,0);
-		spin_unlock_irqrestore(&wdtpci_lock, flags);
+		wdtpci_stop();
 	}
 	return NOTIFY_DONE;
 }
@@ -475,7 +558,6 @@ static int wdtpci_notify_sys(struct noti
 static struct file_operations wdtpci_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= no_llseek,
-	.read		= wdtpci_read,
 	.write		= wdtpci_write,
 	.ioctl		= wdtpci_ioctl,
 	.open		= wdtpci_open,
@@ -489,12 +571,20 @@ static struct miscdevice wdtpci_miscdev 
 };
 
 #ifdef CONFIG_WDT_501_PCI
+static struct file_operations wdtpci_temp_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= wdtpci_temp_read,
+	.open		= wdtpci_temp_open,
+	.release	= wdtpci_temp_release,
+};
+
 static struct miscdevice temp_miscdev = {
 	.minor	= TEMP_MINOR,
 	.name	= "temperature",
-	.fops	= &wdtpci_fops,
+	.fops	= &wdtpci_temp_fops,
 };
-#endif
+#endif /* CONFIG_WDT_501_PCI */
 
 /*
  *	The WDT card needs to learn about soft shutdowns in order to
@@ -509,71 +599,96 @@ static struct notifier_block wdtpci_noti
 static int __devinit wdtpci_init_one (struct pci_dev *dev,
 				   const struct pci_device_id *ent)
 {
-	static int dev_count = 0;
 	int ret = -EIO;
 
 	dev_count++;
 	if (dev_count > 1) {
-		printk (KERN_ERR PFX
-			"this driver only supports 1 device\n");
+		printk (KERN_ERR PFX "this driver only supports 1 device\n");
 		return -ENODEV;
 	}
 
-	if (pci_enable_device (dev))
-		goto out;
+	if (pci_enable_device (dev)) {
+		printk (KERN_ERR PFX "Not possible to enable PCI Device\n");
+		return -ENODEV;
+	}
+
+	if (pci_resource_start (dev, 2) == 0x0000) {
+		printk (KERN_ERR PFX "No I/O-Address for card detected\n");
+		ret = -ENODEV;
+		goto out_pci;
+	}
 
 	sema_init(&open_sem, 1);
 	spin_lock_init(&wdtpci_lock);
 
 	irq = dev->irq;
 	io = pci_resource_start (dev, 2);
-	printk ("WDT501-P(PCI-WDG-CSM) driver 0.07 at %X "
-		"(Interrupt %d)\n", io, irq);
 
-	if (request_region (io, 16, "wdt-pci") == NULL) {
-		printk (KERN_ERR PFX "I/O %d is not free.\n", io);
-		goto out;
+	if (request_region (io, 16, "wdt_pci") == NULL) {
+		printk (KERN_ERR PFX "I/O address 0x%04x already in use\n", io);
+		goto out_pci;
 	}
 
 	if (request_irq (irq, wdtpci_interrupt, SA_INTERRUPT | SA_SHIRQ,
-			 "wdt-pci", &wdtpci_miscdev)) {
-		printk (KERN_ERR PFX "IRQ %d is not free.\n", irq);
+			 "wdt_pci", &wdtpci_miscdev)) {
+		printk (KERN_ERR PFX "IRQ %d is not free\n", irq);
 		goto out_reg;
 	}
 
-	ret = misc_register (&wdtpci_miscdev);
-	if (ret) {
-		printk (KERN_ERR PFX "can't misc_register on minor=%d\n", WATCHDOG_MINOR);
-		goto out_irq;
+	printk ("PCI-WDT500/501 (PCI-WDG-CSM) driver 0.10 at 0x%04x (Interrupt %d)\n",
+		io, irq);
+
+	/* Check that the heartbeat value is within it's range ; if not reset to the default */
+	if (wdtpci_set_heartbeat(heartbeat)) {
+		wdtpci_set_heartbeat(WD_TIMO);
+		printk(KERN_INFO PFX "heartbeat value must be 0<heartbeat<65536, using %d\n",
+			WD_TIMO);
 	}
 
 	ret = register_reboot_notifier (&wdtpci_notifier);
 	if (ret) {
-		printk (KERN_ERR PFX "can't misc_register on minor=%d\n", WATCHDOG_MINOR);
-		goto out_misc;
+		printk (KERN_ERR PFX "cannot register reboot notifier (err=%d)\n", ret);
+		goto out_irq;
 	}
+
 #ifdef CONFIG_WDT_501_PCI
 	ret = misc_register (&temp_miscdev);
 	if (ret) {
-		printk (KERN_ERR PFX "can't misc_register (temp) on minor=%d\n", TEMP_MINOR);
+		printk (KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+			TEMP_MINOR, ret);
 		goto out_rbt;
 	}
-#endif
+#endif /* CONFIG_WDT_501_PCI */
+
+	ret = misc_register (&wdtpci_miscdev);
+	if (ret) {
+		printk (KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+			WATCHDOG_MINOR, ret);
+		goto out_misc;
+	}
+
+	printk(KERN_INFO PFX "initialized. heartbeat=%d sec (nowayout=%d)\n",
+		heartbeat, nowayout);
+#ifdef CONFIG_WDT_501_PCI
+	printk(KERN_INFO "wdt: Fan Tachometer is %s\n", (tachometer ? "Enabled" : "Disabled"));
+#endif /* CONFIG_WDT_501_PCI */
 
 	ret = 0;
 out:
 	return ret;
 
+out_misc:
 #ifdef CONFIG_WDT_501_PCI
+	misc_deregister(&temp_miscdev);
+#endif /* CONFIG_WDT_501_PCI */
 out_rbt:
 	unregister_reboot_notifier(&wdtpci_notifier);
-#endif
-out_misc:
-	misc_deregister(&wdtpci_miscdev);
 out_irq:
 	free_irq(irq, &wdtpci_miscdev);
 out_reg:
 	release_region (io, 16);
+out_pci:
+	pci_disable_device(dev);
 	goto out;
 }
 
@@ -582,13 +697,15 @@ static void __devexit wdtpci_remove_one 
 {
 	/* here we assume only one device will ever have
 	 * been picked up and registered by probe function */
-	unregister_reboot_notifier(&wdtpci_notifier);
+	misc_deregister(&wdtpci_miscdev);
 #ifdef CONFIG_WDT_501_PCI
 	misc_deregister(&temp_miscdev);
-#endif
-	misc_deregister(&wdtpci_miscdev);
+#endif /* CONFIG_WDT_501_PCI */
+	unregister_reboot_notifier(&wdtpci_notifier);
 	free_irq(irq, &wdtpci_miscdev);
 	release_region(io, 16);
+	pci_disable_device(pdev);
+	dev_count--;
 }
 
 
@@ -605,7 +722,7 @@ MODULE_DEVICE_TABLE(pci, wdtpci_pci_tbl)
 
 
 static struct pci_driver wdtpci_driver = {
-	.name		= "wdt-pci",
+	.name		= "wdt_pci",
 	.id_table	= wdtpci_pci_tbl,
 	.probe		= wdtpci_init_one,
 	.remove		= __devexit_p(wdtpci_remove_one),
@@ -619,7 +736,7 @@ static struct pci_driver wdtpci_driver =
  *	If your watchdog is set to continue ticking on close and you unload
  *	it, well it keeps ticking. We won't get the interrupt but the board
  *	will not touch PC memory so all is fine. You just have to load a new
- *	module in 60 seconds or reboot.
+ *	module in xx seconds or reboot.
  */
 
 static void __exit wdtpci_cleanup(void)
@@ -638,12 +755,7 @@ static void __exit wdtpci_cleanup(void)
 
 static int __init wdtpci_init(void)
 {
-	int rc = pci_register_driver (&wdtpci_driver);
-
-	if (rc < 1)
-		return -ENODEV;
-
-	return 0;
+	return pci_register_driver (&wdtpci_driver);
 }
 
 
@@ -651,7 +763,7 @@ module_init(wdtpci_init);
 module_exit(wdtpci_cleanup);
 
 MODULE_AUTHOR("JP Nollmann, Alan Cox");
-MODULE_DESCRIPTION("Driver for the ICS PCI watchdog cards");
+MODULE_DESCRIPTION("Driver for the ICS PCI-WDT500/501 watchdog cards");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
 MODULE_ALIAS_MISCDEV(TEMP_MINOR);
diff -purN linux-post-2.6.5-rc2-20040320/drivers/i2c/busses/i2c-keywest.c linux-post-2.6.5-rc2-20040323/drivers/i2c/busses/i2c-keywest.c
--- linux-post-2.6.5-rc2-20040320/drivers/i2c/busses/i2c-keywest.c	2004-03-15 10:25:23.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/i2c/busses/i2c-keywest.c	2004-03-20 14:33:07.000000000 +0000
@@ -608,6 +608,7 @@ create_iface(struct device_node *np, str
 	}
 #endif /* POLLED_MODE */
 
+	pmac_low_i2c_unlock(np);
 	dev_set_drvdata(dev, iface);
 	
 	for (i=0; i<nchan; i++) {
@@ -645,7 +646,6 @@ create_iface(struct device_node *np, str
 	printk(KERN_INFO "Found KeyWest i2c on \"%s\", %d channel%s, stepping: %d bits\n",
 		np->parent->name, nchan, nchan > 1 ? "s" : "", bsteps);
 		
-	pmac_low_i2c_unlock(np);
 	return 0;
 }
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/input/serio/i8042.c linux-post-2.6.5-rc2-20040323/drivers/input/serio/i8042.c
--- linux-post-2.6.5-rc2-20040320/drivers/input/serio/i8042.c	2004-03-03 14:13:56.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/input/serio/i8042.c	2004-03-23 01:49:43.000000000 +0000
@@ -722,6 +722,14 @@ static int i8042_controller_init(void)
 	}
 
 /*
+ * If the chip is configured into nontranslated mode by the BIOS, don't
+ * bother enabling translating and be happy.
+ */
+
+	if (~i8042_ctr & I8042_CTR_XLATE)
+		i8042_direct = 1;
+
+/*
  * Set nontranslated mode for the kbd interface if requested by an option.
  * After this the kbd interface becomes a simple serial in/out, like the aux
  * interface is. We don't do this by default, since it can confuse notebook
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/adapter.h linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/adapter.h
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/adapter.h	2002-11-13 20:59:11.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/adapter.h	2004-03-21 18:34:18.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: adapter.h,v 1.1.2.2 2002/10/02 14:38:37 armin Exp $ */
+/* $Id: adapter.h,v 1.4 2004/03/21 17:26:01 armin Exp $ */
 
 #ifndef __DIVA_USER_MODE_IDI_ADAPTER_H__
 #define __DIVA_USER_MODE_IDI_ADAPTER_H__
@@ -6,10 +6,10 @@
 #define DIVA_UM_IDI_ADAPTER_REMOVED 0x00000001
 
 typedef struct _diva_um_idi_adapter {
-	diva_entity_link_t link;
+	struct list_head link;
 	DESCRIPTOR d;
 	int adapter_nr;
-	diva_entity_queue_t entity_q;	/* entities linked to this adapter */
+	struct list_head entity_q;	/* entities linked to this adapter */
 	dword status;
 } diva_um_idi_adapter_t;
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/capifunc.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/capifunc.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/capifunc.c	2004-01-19 23:38:02.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/capifunc.c	2004-03-22 16:45:23.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: capifunc.c,v 1.48 2004/01/11 19:20:54 armin Exp $
+/* $Id: capifunc.c,v 1.60 2004/03/22 16:28:27 armin Exp $
  *
  * ISDN interface module for Eicon active cards DIVA.
  * CAPI Interface common functions
@@ -39,9 +39,9 @@ extern word CapiRegister(word);
 extern word api_put(APPL *, CAPI_MSG *);
 
 static diva_os_spin_lock_t api_lock;
-static diva_os_spin_lock_t ll_lock;
 
-static diva_card *cards;
+static LIST_HEAD(cards);
+
 static dword notify_handle;
 static void DIRequest(ENTITY * e);
 static DESCRIPTOR MAdapter;
@@ -152,26 +152,15 @@ byte UnMapController(byte MappedControll
 static int find_free_id(void)
 {
 	int num = 0;
-	diva_card *p;
-	diva_os_spin_lock_magic_t old_irql;
+	DIVA_CAPI_ADAPTER *a;
 
-	diva_os_enter_spin_lock(&ll_lock, &old_irql, "find free id");
-	while (num < 100) {
-		num++;
-		p = cards;
-		while (p) {
-			if (p->Id == num)
+	while (num < MAX_DESCRIPTORS) {
+		a = &adapter[num];
+		if (!a->Id)
 				break;
-			p = p->next;
-		}
-		if(!p) {
-		diva_os_leave_spin_lock(&ll_lock, &old_irql,
-					"find free id");
-		return (num);
-		}
+		num++;
 	}
-	diva_os_leave_spin_lock(&ll_lock, &old_irql, "find free id");
-	return (999);
+	return(num + 1);
 }
 
 /*
@@ -179,21 +168,17 @@ static int find_free_id(void)
  */
 static diva_card *find_card_by_ctrl(word controller)
 {
-	diva_card *p;
-	diva_os_spin_lock_magic_t old_irql;
-
-	diva_os_enter_spin_lock(&ll_lock, &old_irql, "find card ctrl");
-	p = cards;
+	struct list_head *tmp;
+	diva_card *card;
 
-	while (p) {
-		if (ControllerMap[p->Id] == controller) {
-			diva_os_leave_spin_lock(&ll_lock, &old_irql,
-						"find card ctrl");
-			return p;
+	list_for_each(tmp, &cards) {
+		card = list_entry(tmp, diva_card, list);
+		if (ControllerMap[card->Id] == controller) {
+			if (card->remove_in_progress)
+				card = NULL;
+			return(card);
 		}
-		p = p->next;
 	}
-	diva_os_leave_spin_lock(&ll_lock, &old_irql, "find card ctrl");
 	return (diva_card *) 0;
 }
 
@@ -358,28 +343,18 @@ void sendf(APPL * appl, word command, dw
 /*
  * cleanup adapter
  */
-static void clean_adapter(int id)
+static void clean_adapter(int id, struct list_head *free_mem_q)
 {
 	DIVA_CAPI_ADAPTER *a;
-#if IMPLEMENT_LINE_INTERCONNECT2
 	int i, k;
-#endif				/* IMPLEMENT_LINE_INTERCONNECT2 */
 
 	a = &adapter[id];
-#if IMPLEMENT_LINE_INTERCONNECT
-	if (a->li_pri) {
-		if (a->li_config.pri)
-			diva_os_free(0, a->li_config.pri);
-	} else {
-		if (a->li_config.bri)
-			diva_os_free(0, a->li_config.bri);
-	}
-#endif				/* IMPLEMENT_LINE_INTERCONNECT */
-#if IMPLEMENT_LINE_INTERCONNECT2
 	k = li_total_channels - a->li_channels;
 	if (k == 0) {
-		diva_os_free(0, li_config_table);
+		if (li_config_table) {
+			list_add((struct list_head *)li_config_table, free_mem_q);
 		li_config_table = NULL;
+		}
 	} else {
 		if (a->li_base < k) {
 			memmove(&li_config_table[a->li_base],
@@ -401,9 +376,8 @@ static void clean_adapter(int id)
 		if (adapter[i].request)
 			adapter[i].li_base -= a->li_channels;
 	}
-#endif				/* IMPLEMENT_LINE_INTERCONNECT2 */
 	if (a->plci)
-		diva_os_free(0, a->plci);
+		list_add((struct list_head *)a->plci, free_mem_q);
 
 	memset(a, 0x00, sizeof(DIVA_CAPI_ADAPTER));
 	while ((max_adapter != 0) && !adapter[max_adapter - 1].request)
@@ -411,67 +385,85 @@ static void clean_adapter(int id)
 }
 
 /*
- * remove cards
+ * remove a card, but ensures consistent state of LI tables
+ * in the time adapter is removed
  */
-static void DIVA_EXIT_FUNCTION divacapi_remove_cards(void)
+static void divacapi_remove_card(DESCRIPTOR * d)
 {
-	diva_card *last;
-	diva_card *card;
+	diva_card *card = NULL;
 	diva_os_spin_lock_magic_t old_irql;
+	LIST_HEAD(free_mem_q);
+	struct list_head *link;
+	struct list_head *tmp;
+
+	/*
+	 * Set "remove in progress flag".
+	 * Ensures that there is no call from sendf to CAPI in
+	 * the time CAPI controller is about to be removed.
+	 */
+	diva_os_enter_spin_lock(&api_lock, &old_irql, "remove card");
+	list_for_each(tmp, &cards) {
+		card = list_entry(tmp, diva_card, list);
+		if (card->d.request == d->request) {
+			card->remove_in_progress = 1;
+			list_del(tmp);
+			break;
+		}
+	}
+	diva_os_leave_spin_lock(&api_lock, &old_irql, "remove card");
 
-	diva_os_enter_spin_lock(&ll_lock, &old_irql, "remove cards");
-	card = cards;
-
-	while (card) {
+	if (card) {
+		/*
+		 * Detach CAPI. Sendf cannot call to CAPI any more.
+		 * After detach no call to send_message() is done too.
+		 */
 		detach_capi_ctr(&card->capi_ctrl);
-		clean_adapter(card->Id - 1);
-		DBG_TRC(("adapter remove, max_adapter=%d", max_adapter));
-		card = card->next;
-	}
 
-	card = cards;
-	while (card) {
-		last = card;
-		card = card->next;
-		diva_os_free(0, last);
+		/*
+		 * Now get API lock (to ensure stable state of LI tables)
+		 * and update the adapter map/LI table.
+		 */
+		diva_os_enter_spin_lock(&api_lock, &old_irql, "remove card");
+
+		clean_adapter(card->Id - 1, &free_mem_q);
+		DBG_TRC(("DelAdapterMap (%d) -> (%d)",
+				ControllerMap[card->Id], card->Id))
+				ControllerMap[card->Id] = 0;
+		DBG_TRC(("adapter remove, max_adapter=%d",
+				max_adapter));
+		diva_os_leave_spin_lock(&api_lock, &old_irql, "remove card");
+		
+		/* After releasing the lock, we can free the memory */
+		diva_os_free (0, card);
+	}
+
+	/* free queued memory areas */
+	list_for_each_safe(link, tmp, &free_mem_q) {
+		list_del(link);
+		diva_os_free(0, link);
 	}
-	diva_os_leave_spin_lock(&ll_lock, &old_irql, "remove cards");
 }
 
 /*
- * remove a card
+ * remove cards
  */
-static void divacapi_remove_card(DESCRIPTOR * d)
+static void divacapi_remove_cards(void)
 {
-	diva_card *last;
+	DESCRIPTOR d;
+	struct list_head *tmp;
 	diva_card *card;
 	diva_os_spin_lock_magic_t old_irql;
 
-	diva_os_enter_spin_lock(&ll_lock, &old_irql, "remove card");
-	last = card = cards;
-	while (card) {
-		if (card->d.request == d->request) {
-			detach_capi_ctr(&card->capi_ctrl);
-			clean_adapter(card->Id - 1);
-			DBG_TRC(
-				("DelAdapterMap (%d) -> (%d)",
-				 ControllerMap[card->Id], card->Id))
-			    ControllerMap[card->Id] = 0;
-			DBG_TRC(
-				("adapter remove, max_adapter=%d",
-				 max_adapter));
-			if (card == last)
-				cards = card->next;
-			else
-				last->next = card->next;
-
-			diva_os_free(0, card);
-			break;
-		}
-		last = card;
-		card = card->next;
+rescan:
+	diva_os_enter_spin_lock(&api_lock, &old_irql, "remove cards");
+	list_for_each(tmp, &cards) {
+		card = list_entry(tmp, diva_card, list);
+		diva_os_leave_spin_lock(&api_lock, &old_irql, "remove cards");
+		d.request = card->d.request;
+		divacapi_remove_card(&d);
+		goto rescan;
 	}
-	diva_os_leave_spin_lock(&ll_lock, &old_irql, "remove card");
+	diva_os_leave_spin_lock(&api_lock, &old_irql, "remove cards");
 }
 
 /*
@@ -500,10 +492,9 @@ static int diva_add_card(DESCRIPTOR * d)
 	DIVA_CAPI_ADAPTER *a = NULL;
 	IDI_SYNC_REQ sync_req;
 	char serial[16];
-#if IMPLEMENT_LINE_INTERCONNECT2
+	void* mem_to_free;
 	LI_CONFIG *new_li_config_table;
 	int j;
-#endif				/* IMPLEMENT_LINE_INTERCONNECT2 */
 
 	if (!(card = (diva_card *) diva_os_malloc(0, sizeof(diva_card)))) {
 		DBG_ERR(("diva_add_card: failed to allocate card struct."))
@@ -529,7 +520,11 @@ static int diva_add_card(DESCRIPTOR * d)
 		    diva_os_free(0, card);
 		return (0);
 	}
+	
+	diva_os_enter_spin_lock(&api_lock, &old_irql, "find id");
 	card->Id = find_free_id();
+	diva_os_leave_spin_lock(&api_lock, &old_irql, "find id");
+	
 	strlcpy(ctrl->manu, M_COMPANY, sizeof(ctrl->manu));
 	ctrl->version.majorversion = 2;
 	ctrl->version.minorversion = 0;
@@ -600,9 +595,7 @@ static int diva_add_card(DESCRIPTOR * d)
 #if IMPLEMENT_DTMF
 		a->profile.Global_Options |= 0x8;
 #endif				/* IMPLEMENT_DTMF */
-#if (IMPLEMENT_LINE_INTERCONNECT || IMPLEMENT_LINE_INTERCONNECT2)
-		a->profile.Global_Options |= 0x80;
-#endif				/* (IMPLEMENT_LINE_INTERCONNECT || IMPLEMENT_LINE_INTERCONNECT2) */
+		a->profile.Global_Options |= 0x80; /* Line Interconnect */
 #if IMPLEMENT_ECHO_CANCELLER
 		a->profile.Global_Options |= 0x100;
 #endif				/* IMPLEMENT_ECHO_CANCELLER */
@@ -620,25 +613,6 @@ static int diva_add_card(DESCRIPTOR * d)
 		a->manufacturer_features = 0;
 	}
 
-#if IMPLEMENT_LINE_INTERCONNECT
-	a->li_pri = (a->profile.Channels > 2);
-	if (a->li_pri) {
-		if (!(a->li_config.pri = (LI_CONFIG_PRI *) diva_os_malloc(0, sizeof(LI_CONFIG_PRI)))) {
-			DBG_ERR(("diva_add_card: failed alloc li_config.pri struct."))
-			memset(a, 0, sizeof(DIVA_CAPI_ADAPTER));
-			return (0);
-		}
-		memset(a->li_config.pri, 0, sizeof(LI_CONFIG_PRI));
-	} else 
-		if (!(a->li_config.bri = (LI_CONFIG_BRI *) diva_os_malloc(0, sizeof(LI_CONFIG_BRI)))) {
-			DBG_ERR(("diva_add_card: failed alloc li_config.bri struct."))
-			memset(a, 0, sizeof(DIVA_CAPI_ADAPTER));
-			return (0);
-		}
-		memset(a->li_config.bri, 0, sizeof(LI_CONFIG_BRI));
-	}
-#endif				/* IMPLEMENT_LINE_INTERCONNECT */
-#if IMPLEMENT_LINE_INTERCONNECT2
 	a->li_pri = (a->profile.Channels > 2);
 	a->li_channels = a->li_pri ? MIXER_CHANNELS_PRI : MIXER_CHANNELS_BRI;
 	a->li_base = 0;
@@ -654,6 +628,10 @@ static int diva_add_card(DESCRIPTOR * d)
 		memset(a, 0, sizeof(DIVA_CAPI_ADAPTER));
 		return (0);
 	}
+
+	/* Prevent access to line interconnect table in process update */
+	diva_os_enter_spin_lock(&api_lock, &old_irql, "add card");
+	
 	j = 0;
 	for (i = 0; i < k; i++) {
 		if ((i >= a->li_base) && (i < a->li_base + a->li_channels))
@@ -694,25 +672,26 @@ static int diva_add_card(DESCRIPTOR * d)
 	}
 	li_total_channels = k;
 
-	if (li_config_table != NULL)
-		diva_os_free(0, li_config_table);
+	mem_to_free = li_config_table;
 
 	li_config_table = new_li_config_table;
 	for (i = card->Id; i < max_adapter; i++) {
 		if (adapter[i].request)
 			adapter[i].li_base += a->li_channels;
 	}
-#endif				/* IMPLEMENT_LINE_INTERCONNECT2 */
 
 	if (a == &adapter[max_adapter])
 		max_adapter++;
 
-	diva_os_enter_spin_lock(&ll_lock, &old_irql, "add card");
-	card->next = cards;
-	cards = card;
-	diva_os_leave_spin_lock(&ll_lock, &old_irql, "add card");
-
+	list_add(&(card->list), &cards);
 	AutomaticLaw(a);
+
+	diva_os_leave_spin_lock(&api_lock, &old_irql, "add card");
+
+	if (mem_to_free) {
+		diva_os_free (0, mem_to_free);
+	}
+
 	i = 0;
 	while (i++ < 30) {
 		if (a->automatic_law > 3)
@@ -863,6 +842,7 @@ static void diva_release_appl(struct cap
 {
 	diva_os_spin_lock_magic_t old_irql;
 	APPL *this = &application[appl - 1];
+	void *mem_to_free = NULL;
 
 	DBG_TRC(("application %d(%d) cleanup", this->Id, appl))
 
@@ -874,13 +854,15 @@ static void diva_release_appl(struct cap
 	diva_os_enter_spin_lock(&api_lock, &old_irql, "release_appl");
 	if (this->Id) {
 		CapiRelease(this->Id);
-		if (this->DataNCCI)
-			diva_os_free(0, this->DataNCCI);
+		mem_to_free = this->DataNCCI;
 		this->DataNCCI = NULL;
 		this->Id = 0;
 	}
 	diva_os_leave_spin_lock(&api_lock, &old_irql, "release_appl");
 
+	if (mem_to_free)
+		diva_os_free(0, mem_to_free);
+
 }
 
 /*
@@ -906,6 +888,11 @@ static u16 diva_send_message(struct capi
 	}
 	DBG_PRV1(("Write - appl = %d, cmd = 0x%x", this->Id, command))
 
+	if (card->remove_in_progress) {
+		DBG_ERR(("CAPI_SEND_MSG - remove in progress!"))
+		return CAPI_REGOSRESOURCEERR;
+	}
+
 	if (!this->Id) {
 		return CAPI_ILLAPPNR;
 	}
@@ -1163,11 +1150,30 @@ static void remove_main_structs(void)
 }
 
 /*
+ * api_remove_start
+ */
+static void do_api_remove_start(void)
+{
+	diva_os_spin_lock_magic_t old_irql;
+	int ret = 1, count = 100;
+
+	do {
+		diva_os_enter_spin_lock(&api_lock, &old_irql, "api remove start");
+		ret = api_remove_start();
+		diva_os_leave_spin_lock(&api_lock, &old_irql, "api remove start");
+
+		diva_os_sleep(10);
+	} while (ret && count--);
+
+	if (ret)
+		DBG_ERR(("could not remove signaling ID's"))
+}
+
+/*
  * init
  */
 int DIVA_INIT_FUNCTION init_capifunc(void)
 {
-	diva_os_initialize_spin_lock(&ll_lock, "capifunc");
 	diva_os_initialize_spin_lock(&api_lock, "capifunc");
 	memset(ControllerMap, 0, MAX_DESCRIPTORS + 1);
 	max_adapter = 0;
@@ -1175,12 +1181,16 @@ int DIVA_INIT_FUNCTION init_capifunc(voi
 
 	if (!init_main_structs()) {
 		DBG_ERR(("init: failed to init main structs."))
+		diva_os_destroy_spin_lock(&api_lock, "capifunc");
 		return (0);
 	}
 
 	if (!divacapi_connect_didd()) {
 		DBG_ERR(("init: failed to connect to DIDD."))
+		do_api_remove_start();
+		divacapi_remove_cards();
 		remove_main_structs();
+		diva_os_destroy_spin_lock(&api_lock, "capifunc");
 		return (0);
 	}
 
@@ -1192,21 +1202,9 @@ int DIVA_INIT_FUNCTION init_capifunc(voi
  */
 void DIVA_EXIT_FUNCTION finit_capifunc(void)
 {
-	int count = 100;
-	word ret = 1;
-
-	while (ret && count--) {
-		ret = api_remove_start();
-		diva_os_sleep(10);
-	}
-	if (ret)
-		DBG_ERR(("could not remove signaling ID's"))
-
+	do_api_remove_start();
 		    divacapi_disconnect_didd();
 	divacapi_remove_cards();
-
 	remove_main_structs();
-
 	diva_os_destroy_spin_lock(&api_lock, "capifunc");
-	diva_os_destroy_spin_lock(&ll_lock, "capifunc");
 }
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/capifunc.h linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/capifunc.h
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/capifunc.h	2003-09-09 10:02:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/capifunc.h	2004-03-20 18:18:26.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: capifunc.h,v 1.10 2003/08/25 10:06:37 schindler Exp $
+/* $Id: capifunc.h,v 1.11 2004/03/20 17:19:58 armin Exp $
  *
  * ISDN interface module for Eicon active cards DIVA.
  * CAPI Interface common functions
@@ -24,8 +24,9 @@
 extern char DRIVERRELEASE_CAPI[];
 
 typedef struct _diva_card {
+	struct list_head list;
+	int remove_in_progress;
 	int Id;
-	struct _diva_card *next;
 	struct capi_ctr capi_ctrl;
 	DIVA_CAPI_ADAPTER *adapter;
 	DESCRIPTOR d;
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/diva.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/diva.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/diva.c	2003-09-09 10:02:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/diva.c	2004-03-21 18:34:18.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: diva.c,v 1.17 2003/09/09 06:52:01 schindler Exp $ */
+/* $Id: diva.c,v 1.21 2004/03/21 17:30:25 armin Exp $ */
 
 #define CARDTYPE_H_WANT_DATA            1
 #define CARDTYPE_H_WANT_IDI_DATA        0
@@ -8,7 +8,6 @@
 #include "platform.h"
 #include "debuglib.h"
 #include "cardtype.h"
-#include "dlist.h"
 #include "pc.h"
 #include "di_defs.h"
 #include "di.h"
@@ -75,14 +74,9 @@ DivaIdiReqFunc(31)
 struct pt_regs;
 
 /*
- * include queue functions
- */
-#include "dlist.c"
-
-/*
 **  LOCALS
 */
-diva_entity_queue_t adapter_queue;
+static LIST_HEAD(adapter_queue);
 
 typedef struct _diva_get_xlog {
 	word command;
@@ -158,6 +152,16 @@ static int diva_find_free_adapters(int b
 	return (0);
 }
 
+static diva_os_xdi_adapter_t *diva_q_get_next(struct list_head * what)
+{
+	diva_os_xdi_adapter_t *a = NULL;
+
+	if (what && !list_empty(what))
+		a = list_entry(what->next, diva_os_xdi_adapter_t, link);
+
+	return(a);
+}
+
 /* --------------------------------------------------------------------------
     Add card to the card list
    -------------------------------------------------------------------------- */
@@ -204,7 +208,7 @@ void *diva_driver_add_card(void *pdev, u
 					diva_os_enter_spin_lock(&adapter_lock, &old_irql, "add card");
 					pa = pdiva;
 					for (j = 1; j < nr; j++) {	/* slave adapters, if any */
-						pa = (diva_os_xdi_adapter_t *) diva_q_get_next(&pa->link);
+						pa = diva_q_get_next(&pa->link);
 						if (pa && !pa->interface.cleanup_adapter_proc) {
 							pa->controller = i + 1 + j;
 							pa->xdi_adapter.ANum = pa->controller;
@@ -246,7 +250,6 @@ void *diva_driver_add_card(void *pdev, u
 int divasa_xdi_driver_entry(void)
 {
 	diva_os_initialize_spin_lock(&adapter_lock, "adapter");
-	diva_q_init(&adapter_queue);
 	memset(&IoAdapters[0], 0x00, sizeof(IoAdapters));
 	diva_init_request_array();
 
@@ -259,12 +262,14 @@ int divasa_xdi_driver_entry(void)
 static diva_os_xdi_adapter_t *get_and_remove_from_queue(void)
 {
 	diva_os_spin_lock_magic_t old_irql;
-	diva_os_xdi_adapter_t *a;
+	diva_os_xdi_adapter_t *a = NULL;
 
 	diva_os_enter_spin_lock(&adapter_lock, &old_irql, "driver_unload");
 
-	if ((a = (diva_os_xdi_adapter_t *) diva_q_get_head(&adapter_queue)))
-		diva_q_remove(&adapter_queue, &a->link);
+	if (!list_empty(&adapter_queue)) {
+		a = list_entry(adapter_queue.next, diva_os_xdi_adapter_t, link);
+		list_del(adapter_queue.next);
+	}
 
 	diva_os_leave_spin_lock(&adapter_lock, &old_irql, "driver_unload");
 	return (a);
@@ -286,7 +291,7 @@ void diva_driver_remove_card(void *pdiva
 	diva_os_enter_spin_lock(&adapter_lock, &old_irql, "remode adapter");
 
 	for (i = 1; i < 4; i++) {
-		if ((pa = (diva_os_xdi_adapter_t *) diva_q_get_next(&pa->link))
+		if ((pa = diva_q_get_next(&pa->link))
 		    && !pa->interface.cleanup_adapter_proc) {
 			a[i] = pa;
 		} else {
@@ -295,7 +300,7 @@ void diva_driver_remove_card(void *pdiva
 	}
 
 	for (i = 0; ((i < 4) && a[i]); i++) {
-		diva_q_remove(&adapter_queue, &a[i]->link);
+		list_del(&a[i]->link);
 	}
 
 	diva_os_leave_spin_lock(&adapter_lock, &old_irql, "driver_unload");
@@ -345,12 +350,12 @@ static void *divas_create_pci_card(int h
 	   numbers as master adapter
 	 */
 	diva_os_enter_spin_lock(&adapter_lock, &old_irql, "found_pci_card");
-	diva_q_add_tail(&adapter_queue, &a->link);
+	list_add_tail(&a->link, &adapter_queue);
 	diva_os_leave_spin_lock(&adapter_lock, &old_irql, "found_pci_card");
 
 	if ((*(pI->init_card)) (a)) {
 		diva_os_enter_spin_lock(&adapter_lock, &old_irql, "found_pci_card");
-		diva_q_remove(&adapter_queue, &a->link);
+		list_del(&a->link);
 		diva_os_leave_spin_lock(&adapter_lock, &old_irql, "found_pci_card");
 		diva_os_free(0, a);
 		DBG_ERR(("A: can't get adapter resources"));
@@ -383,21 +388,14 @@ void divasa_xdi_driver_unload(void)
 /*
 **  Receive and process command from user mode utility
 */
-static int cmp_adapter_nr(const void *what, const diva_entity_link_t * p)
-{
-	diva_os_xdi_adapter_t *a = (diva_os_xdi_adapter_t *) p;
-	dword nr = (dword) (unsigned long) what;
-
-	return (nr != a->controller);
-}
-
 void *diva_xdi_open_adapter(void *os_handle, const void *src,
 			    int length,
 			    divas_xdi_copy_from_user_fn_t cp_fn)
 {
 	diva_xdi_um_cfg_cmd_t msg;
-	diva_os_xdi_adapter_t *a;
+	diva_os_xdi_adapter_t *a = NULL;
 	diva_os_spin_lock_magic_t old_irql;
+	struct list_head *tmp;
 
 	if (length < sizeof(diva_xdi_um_cfg_cmd_t)) {
 		DBG_ERR(("A: A(?) open, msg too small (%d < %d)",
@@ -409,10 +407,12 @@ void *diva_xdi_open_adapter(void *os_han
 		return (0);
 	}
 	diva_os_enter_spin_lock(&adapter_lock, &old_irql, "open_adapter");
-	a = (diva_os_xdi_adapter_t *) diva_q_find(&adapter_queue,
-						  (void *) (unsigned long)
-						  msg.adapter,
-						  cmp_adapter_nr);
+	list_for_each(tmp, &adapter_queue) {
+		a = list_entry(tmp, diva_os_xdi_adapter_t, link);
+		if (a->controller == (int)msg.adapter)
+			break;
+		a = NULL;
+	}
 	diva_os_leave_spin_lock(&adapter_lock, &old_irql, "open_adapter");
 
 	if (!a) {
@@ -611,7 +611,7 @@ void diva_add_slave_adapter(diva_os_xdi_
 	diva_os_spin_lock_magic_t old_irql;
 
 	diva_os_enter_spin_lock(&adapter_lock, &old_irql, "add_slave");
-	diva_q_add_tail(&adapter_queue, &a->link);
+	list_add_tail(&a->link, &adapter_queue);
 	diva_os_leave_spin_lock(&adapter_lock, &old_irql, "add_slave");
 }
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/divasmain.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/divasmain.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/divasmain.c	2004-02-25 02:34:51.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/divasmain.c	2004-03-21 18:34:18.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: divasmain.c,v 1.48 2004/02/24 17:46:28 armin Exp $
+/* $Id: divasmain.c,v 1.52 2004/03/21 17:26:01 armin Exp $
  *
  * Low level driver for Eicon DIVA Server ISDN cards.
  *
@@ -22,6 +22,7 @@
 #include <linux/pci.h>
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
+#include <linux/list.h>
 #include <linux/poll.h>
 #include <linux/kmod.h>
 
@@ -29,7 +30,6 @@
 #undef ID_MASK
 #undef N_DATA
 #include "pc.h"
-#include "dlist.h"
 #include "di_defs.h"
 #include "divasync.h"
 #include "diva.h"
@@ -41,7 +41,7 @@
 #include "diva_dma.h"
 #include "diva_pci.h"
 
-static char *main_revision = "$Revision: 1.48 $";
+static char *main_revision = "$Revision: 1.52 $";
 
 static int major;
 
@@ -69,7 +69,7 @@ extern int divasfunc_init(int dbgmask);
 extern void divasfunc_exit(void);
 
 typedef struct _diva_os_thread_dpc {
-	struct work_struct divas_task;
+	struct tasklet_struct divas_task;
 	struct work_struct trap_script_task;
 	diva_os_soft_isr_t *psoft_isr;
 	int card_failed;
@@ -552,7 +552,7 @@ void diva_os_remove_irq(void *context, b
 /* --------------------------------------------------------------------------
     DPC framework implementation
    -------------------------------------------------------------------------- */
-static void diva_os_dpc_proc(void *context)
+static void diva_os_dpc_proc(unsigned long context)
 {
 	diva_os_thread_dpc_t *psoft_isr = (diva_os_thread_dpc_t *) context;
 	diva_os_soft_isr_t *pisr = psoft_isr->psoft_isr;
@@ -575,7 +575,7 @@ int diva_os_initialize_soft_isr(diva_os_
 	psoft_isr->callback_context = callback_context;
 	pdpc->psoft_isr = psoft_isr;
 	INIT_WORK(&pdpc->trap_script_task, diva_adapter_trapped, pdpc);
-	INIT_WORK(&pdpc->divas_task, diva_os_dpc_proc, pdpc);
+	tasklet_init(&pdpc->divas_task, diva_os_dpc_proc, (unsigned long)pdpc);
 
 	return (0);
 }
@@ -586,7 +586,7 @@ int diva_os_schedule_soft_isr(diva_os_so
 		diva_os_thread_dpc_t *pdpc =
 		    (diva_os_thread_dpc_t *) psoft_isr->object;
 
-		schedule_work(&pdpc->divas_task);
+		tasklet_schedule(&pdpc->divas_task);
 	}
 
 	return (1);
@@ -594,14 +594,22 @@ int diva_os_schedule_soft_isr(diva_os_so
 
 int diva_os_cancel_soft_isr(diva_os_soft_isr_t * psoft_isr)
 {
+	if (psoft_isr && psoft_isr->object) {
+		diva_os_thread_dpc_t *pdpc =
+		    (diva_os_thread_dpc_t *) psoft_isr->object;
+		tasklet_kill(&pdpc->divas_task);
+	}
 	return (0);
 }
 
 void diva_os_remove_soft_isr(diva_os_soft_isr_t * psoft_isr)
 {
 	if (psoft_isr && psoft_isr->object) {
+		diva_os_thread_dpc_t *pdpc =
+		    (diva_os_thread_dpc_t *) psoft_isr->object;
 		void *mem;
 
+		tasklet_kill(&pdpc->divas_task);
 		flush_scheduled_work();
 		mem = psoft_isr->object;
 		psoft_isr->object = 0;
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/divasproc.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/divasproc.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/divasproc.c	2003-09-09 10:02:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/divasproc.c	2004-03-21 18:34:18.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: divasproc.c,v 1.18 2003/09/09 06:46:29 schindler Exp $
+/* $Id: divasproc.c,v 1.19 2004/03/21 17:26:01 armin Exp $
  *
  * Low level driver for Eicon DIVA Server ISDN cards.
  * /proc functions
@@ -15,10 +15,10 @@
 #include <linux/kernel.h>
 #include <linux/poll.h>
 #include <linux/proc_fs.h>
+#include <linux/list.h>
 
 #include "platform.h"
 #include "debuglib.h"
-#include "dlist.h"
 #undef ID_MASK
 #undef N_DATA
 #include "pc.h"
@@ -33,7 +33,6 @@
 
 
 extern PISDN_ADAPTER IoAdapters[MAX_ADAPTER];
-extern diva_entity_queue_t adapter_queue;
 extern void divas_get_version(char *);
 extern void diva_get_vserial_number(PISDN_ADAPTER IoAdapter, char *buf);
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/dlist.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/dlist.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/dlist.c	2003-09-09 10:02:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/dlist.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,76 +0,0 @@
-/* $Id: dlist.c,v 1.6 2003/08/25 16:03:35 schindler Exp $ */
-
-#include "platform.h"
-#include "dlist.h"
-
-/*
-**  Initialize linked list
-*/
-
-static void diva_q_init(diva_entity_queue_t * q)
-{
-	memset(q, 0x00, sizeof(*q));
-}
-
-/*
-**  Remove element from linked list
-*/
-static void diva_q_remove(diva_entity_queue_t * q, diva_entity_link_t * what)
-{
-	if (!what->prev) {
-		if ((q->head = what->next)) {
-			q->head->prev = 0;
-		} else {
-			q->tail = 0;
-		}
-	} else if (!what->next) {
-		q->tail = what->prev;
-		q->tail->next = 0;
-	} else {
-		what->prev->next = what->next;
-		what->next->prev = what->prev;
-	}
-	what->prev = what->next = 0;
-}
-
-/*
-**  Add element to the tail of linked list
-*/
-static void diva_q_add_tail(diva_entity_queue_t * q, diva_entity_link_t * what)
-{
-	what->next = 0;
-	if (!q->head) {
-		what->prev = 0;
-		q->head = q->tail = what;
-	} else {
-		what->prev = q->tail;
-		q->tail->next = what;
-		q->tail = what;
-	}
-}
-
-static diva_entity_link_t *diva_q_find(const diva_entity_queue_t * q,
-				const void *what, diva_q_cmp_fn_t cmp_fn)
-{
-	diva_entity_link_t *diva_current = q->head;
-
-	while (diva_current) {
-		if (!(*cmp_fn) (what, diva_current)) {
-			break;
-		}
-		diva_current = diva_current->next;
-	}
-
-	return (diva_current);
-}
-
-static diva_entity_link_t *diva_q_get_head(diva_entity_queue_t * q)
-{
-	return (q->head);
-}
-
-static diva_entity_link_t *diva_q_get_next(diva_entity_link_t * what)
-{
-	return ((what) ? what->next : 0);
-}
-
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/dlist.h linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/dlist.h
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/dlist.h	2003-09-09 10:02:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/dlist.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-/* $Id: dlist.h,v 1.5 2003/08/25 16:03:35 schindler Exp $ */
-
-#ifndef __DIVA_LINK_H__
-#define __DIVA_LINK_H__
-
-struct _diva_entity_link;
-typedef struct _diva_entity_link {
-	struct _diva_entity_link *prev;
-	struct _diva_entity_link *next;
-} diva_entity_link_t;
-
-typedef struct _diva_entity_queue {
-	diva_entity_link_t *head;
-	diva_entity_link_t *tail;
-} diva_entity_queue_t;
-
-typedef int (*diva_q_cmp_fn_t) (const void *what,
-				const diva_entity_link_t *);
-
-#endif
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/entity.h linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/entity.h
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/entity.h	2002-11-13 20:59:12.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/entity.h	2004-03-21 18:34:18.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: entity.h,v 1.1.2.1 2001/02/08 12:25:43 armin Exp $ */
+/* $Id: entity.h,v 1.4 2004/03/21 17:26:01 armin Exp $ */
 
 #ifndef __DIVAS_USER_MODE_IDI_ENTITY__
 #define __DIVAS_USER_MODE_IDI_ENTITY__
@@ -10,7 +10,7 @@
 #define DIVA_UM_IDI_ASSIGN_PENDING  0x00000010
 
 typedef struct _divas_um_idi_entity {
-	diva_entity_link_t        link; /* should be first */
+	struct list_head          link;
 	diva_um_idi_adapter_t*    adapter; /* Back to adapter */
 	ENTITY                    e;
 	void*                     os_ref;
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/i4l_idi.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/i4l_idi.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/i4l_idi.c	2003-05-26 00:00:00.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/i4l_idi.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,3135 +0,0 @@
-/* $Id: i4l_idi.c,v 1.1.2.2 2002/10/02 14:38:37 armin Exp $
- *
- * ISDN interface module for Eicon active cards.
- * I4L - IDI Interface
- *
- * Copyright 1998-2000  by Armin Schindler (mac@melware.de)
- * Copyright 1999-2002  Cytronics & Melware (info@melware.de)
- *
- * Thanks to	Deutsche Mailbox Saar-Lor-Lux GmbH
- *		for sponsoring and testing fax
- *		capabilities with Diva Server cards.
- *		(dor@deutschemailbox.de)
- *
- * This software may be used and distributed according to the terms
- * of the GNU General Public License, incorporated herein by reference.
- */
-
-#include <linux/config.h>
-#include "i4lididrv.h"
-
-#undef EICON_FULL_SERVICE_OKTETT
-
-char *eicon_idi_revision = "$Revision: 1.1.2.2 $";
-
-eicon_manifbuf *manbuf;
-
-static int eicon_idi_manage_assign(eicon_card *card);
-static int idi_fill_in_T30(eicon_chan *chan, unsigned char *buffer);
-
-static int
-idi_assign_req(eicon_REQ *reqbuf, int signet, eicon_chan *chan)
-{
-	int l = 0;
-	int tmp;
-
-	tmp = 0;
-  if (!signet) {
-	/* Signal Layer */
-	reqbuf->XBuffer.P[l++] = CAI;
-	reqbuf->XBuffer.P[l++] = 1;
-	reqbuf->XBuffer.P[l++] = 0;
-	reqbuf->XBuffer.P[l++] = KEY;
-	reqbuf->XBuffer.P[l++] = 3;
-	reqbuf->XBuffer.P[l++] = 'I';
-	reqbuf->XBuffer.P[l++] = '4';
-	reqbuf->XBuffer.P[l++] = 'L';
-	reqbuf->XBuffer.P[l++] = SHIFT|6;
-	reqbuf->XBuffer.P[l++] = SIN;
-	reqbuf->XBuffer.P[l++] = 2;
-	reqbuf->XBuffer.P[l++] = 0;
-	reqbuf->XBuffer.P[l++] = 0;
-	reqbuf->XBuffer.P[l++] = 0; /* end */
-	reqbuf->Req = ASSIGN;
-	reqbuf->ReqCh = 0;
-	reqbuf->ReqId = DSIG_ID;
-	reqbuf->XBuffer.length = l;
-	reqbuf->Reference = 0; /* Sig Entity */
-  }
-  else {
-	/* Network Layer */
-	reqbuf->XBuffer.P[l++] = CAI;
-	reqbuf->XBuffer.P[l++] = 1;
-	reqbuf->XBuffer.P[l++] = chan->e.D3Id;
-	reqbuf->XBuffer.P[l++] = LLC;
-	reqbuf->XBuffer.P[l++] = 2;
-	switch(chan->l2prot) {
-		case ISDN_PROTO_L2_V11096:
-		case ISDN_PROTO_L2_V11019:
-		case ISDN_PROTO_L2_V11038:
-		case ISDN_PROTO_L2_TRANS:
-			reqbuf->XBuffer.P[l++] = 2; /* transparent */
-			break;
-		case ISDN_PROTO_L2_X75I:
-		case ISDN_PROTO_L2_X75UI:
-		case ISDN_PROTO_L2_X75BUI:
-			reqbuf->XBuffer.P[l++] = 5; /* X.75 */ 
-			break;
-		case ISDN_PROTO_L2_MODEM:
-  			  if (chan->fsm_state == EICON_STATE_IWAIT)
-				reqbuf->XBuffer.P[l++] = 9; /* V.42 incoming */
-  			  else
-				reqbuf->XBuffer.P[l++] = 10; /* V.42 */
-			  break;
-		case ISDN_PROTO_L2_HDLC:
-		case ISDN_PROTO_L2_FAX:
-  			if (chan->fsm_state == EICON_STATE_IWAIT)
-				reqbuf->XBuffer.P[l++] = 3; /* autoconnect on incoming */
-			else
-				reqbuf->XBuffer.P[l++] = 2; /* transparent */
-			break;
-		default:
-			reqbuf->XBuffer.P[l++] = 1;
-	}
-	switch(chan->l3prot) {
-		case ISDN_PROTO_L3_FCLASS2:
-#ifdef CONFIG_ISDN_TTY_FAX
-			reqbuf->XBuffer.P[l++] = 6;
-			reqbuf->XBuffer.P[l++] = NLC;
-			tmp = idi_fill_in_T30(chan, &reqbuf->XBuffer.P[l+1]);
-			reqbuf->XBuffer.P[l++] = tmp; 
-			l += tmp;
-			break;
-#endif
-		case ISDN_PROTO_L3_TRANS:
-		default:
-			reqbuf->XBuffer.P[l++] = 4;
-	}
-        /* Additional DLC element */
-       switch(chan->l2prot) {
-               case ISDN_PROTO_L2_X75I:
-               case ISDN_PROTO_L2_X75UI:
-               case ISDN_PROTO_L2_X75BUI:
-               case ISDN_PROTO_L2_FAX:
-                    reqbuf->XBuffer.P[l++] = DLC;
-                    reqbuf->XBuffer.P[l++] = 2;
-                    reqbuf->XBuffer.P[l++] = (2138 % 256); /* max. info (lo byte) */
-                    reqbuf->XBuffer.P[l++] = (2138 / 256); /* max. info (hi byte) */
-                break;
-        }
-	reqbuf->XBuffer.P[l++] = 0; /* end */
-	reqbuf->Req = ASSIGN;
-	reqbuf->ReqCh = 0;
-	reqbuf->ReqId = NL_ID;
-	reqbuf->XBuffer.length = l;
-	reqbuf->Reference = 1; /* Net Entity */
-  }
-   return(0);
-}
-
-static int
-idi_put_req(eicon_REQ *reqbuf, int rq, int signet, int Ch)
-{
-	reqbuf->Req = rq;
-	reqbuf->ReqCh = Ch;
-	reqbuf->ReqId = 1;
-	reqbuf->XBuffer.length = 1;
-	reqbuf->XBuffer.P[0] = 0;
-	reqbuf->Reference = signet;
-   return(0);
-}
-
-static int
-idi_put_suspend_req(eicon_REQ *reqbuf, eicon_chan *chan)
-{
-	reqbuf->Req = SUSPEND;
-	reqbuf->ReqCh = 0;
-	reqbuf->ReqId = 1;
-	reqbuf->XBuffer.P[0] = CAI;
-	reqbuf->XBuffer.P[1] = 1;
-	reqbuf->XBuffer.P[2] = chan->No;
-	reqbuf->XBuffer.P[3] = 0;
-	reqbuf->XBuffer.length = 4;
-	reqbuf->Reference = 0; /* Sig Entity */
-   return(0);
-}
-
-static int
-idi_call_res_req(eicon_REQ *reqbuf, eicon_chan *chan)
-{
-	int l = 9;
-	reqbuf->Req = CALL_RES;
-	reqbuf->ReqCh = 0;
-	reqbuf->ReqId = 1;
-	reqbuf->XBuffer.P[0] = CAI;
-	reqbuf->XBuffer.P[1] = 6;
-	reqbuf->XBuffer.P[2] = 9;
-	reqbuf->XBuffer.P[3] = 0;
-	reqbuf->XBuffer.P[4] = 0;
-	reqbuf->XBuffer.P[5] = 0;
-	reqbuf->XBuffer.P[6] = 32;
-	reqbuf->XBuffer.P[7] = 0;
-	switch(chan->l2prot) {
-		case ISDN_PROTO_L2_X75I:
-		case ISDN_PROTO_L2_X75UI:
-		case ISDN_PROTO_L2_X75BUI:
-		case ISDN_PROTO_L2_HDLC:
-			reqbuf->XBuffer.P[1] = 1;
-			reqbuf->XBuffer.P[2] = 0x05;
-			l = 4;
-			break;
-		case ISDN_PROTO_L2_V11096:
-			reqbuf->XBuffer.P[2] = 0x0d;
-			reqbuf->XBuffer.P[3] = 5;
-			reqbuf->XBuffer.P[4] = 0;
-			break;
-		case ISDN_PROTO_L2_V11019:
-			reqbuf->XBuffer.P[2] = 0x0d;
-			reqbuf->XBuffer.P[3] = 6;
-			reqbuf->XBuffer.P[4] = 0;
-			break;
-		case ISDN_PROTO_L2_V11038:
-			reqbuf->XBuffer.P[2] = 0x0d;
-			reqbuf->XBuffer.P[3] = 7;
-			reqbuf->XBuffer.P[4] = 0;
-			break;
-		case ISDN_PROTO_L2_MODEM:
-			/* reqbuf->XBuffer.P[1] = 12; */
-			reqbuf->XBuffer.P[2] = 0x11;
-			reqbuf->XBuffer.P[3] = 9;
-			reqbuf->XBuffer.P[4] = 0;
-			reqbuf->XBuffer.P[5] = 0;
-			reqbuf->XBuffer.P[6] = 32;
-			reqbuf->XBuffer.P[7] = 0;
-			break;
-		case ISDN_PROTO_L2_FAX:
-			reqbuf->XBuffer.P[2] = 0x10;
-			reqbuf->XBuffer.P[3] = 0;
-			reqbuf->XBuffer.P[4] = 0;
-			reqbuf->XBuffer.P[5] = 0;
-			reqbuf->XBuffer.P[6] = 32;
-			reqbuf->XBuffer.P[7] = 0;
-			break;
-		case ISDN_PROTO_L2_TRANS:
-			switch(chan->l3prot) {
-				case ISDN_PROTO_L3_TRANSDSP:
-					reqbuf->XBuffer.P[2] = 22; /* DTMF, audio events on */
-			}
-			break;
-	}
-	reqbuf->XBuffer.P[l-1] = 0;
-	reqbuf->XBuffer.length = l;
-	reqbuf->Reference = 0; /* Sig Entity */
-	eicon_log(NULL, 8, "idi_req: Ch%d: Call_Res\n", chan->No);
-   return(0);
-}
-
-int
-idi_do_req(eicon_card *card, eicon_chan *chan, int cmd, int layer)
-{
-        struct sk_buff *skb;
-        struct sk_buff *skb2;
-	eicon_REQ *reqbuf;
-	eicon_chan_ptr *chan2;
-
-        skb = alloc_skb(270 + sizeof(eicon_REQ), GFP_ATOMIC);
-        skb2 = alloc_skb(sizeof(eicon_chan_ptr), GFP_ATOMIC);
-
-        if ((!skb) || (!skb2)) {
-               	eicon_log(card, 1, "idi_err: Ch%d: alloc_skb failed in do_req()\n", chan->No);
-		if (skb) 
-			dev_kfree_skb(skb);
-		if (skb2) 
-			dev_kfree_skb(skb2);
-                return -ENOMEM; 
-	}
-
-	chan2 = (eicon_chan_ptr *)skb_put(skb2, sizeof(eicon_chan_ptr));
-	chan2->ptr = chan;
-
-	reqbuf = (eicon_REQ *)skb_put(skb, 270 + sizeof(eicon_REQ));
-	eicon_log(card, 8, "idi_req: Ch%d: req %x (%s)\n", chan->No, cmd, (layer)?"Net":"Sig");
-	if (layer) cmd |= 0x700;
-	switch(cmd) {
-		case ASSIGN:
-		case ASSIGN|0x700:
-			idi_assign_req(reqbuf, layer, chan);
-			break;
-		case REMOVE:
-		case REMOVE|0x700:
-			idi_put_req(reqbuf, REMOVE, layer, 0);
-			break;
-		case INDICATE_REQ:
-			idi_put_req(reqbuf, INDICATE_REQ, 0, 0);
-			break;
-		case HANGUP:
-			idi_put_req(reqbuf, HANGUP, 0, 0);
-			break;
-		case SUSPEND:
-			idi_put_suspend_req(reqbuf, chan);
-			break;
-		case RESUME:
-			idi_put_req(reqbuf, RESUME, 0 ,0);
-			break;
-		case REJECT:
-			idi_put_req(reqbuf, REJECT, 0 ,0);
-			break;
-		case CALL_ALERT:
-			idi_put_req(reqbuf, CALL_ALERT, 0, 0);
-			break;
-		case CALL_RES:
-			idi_call_res_req(reqbuf, chan);
-			break;
-		case CALL_HOLD:
-			idi_put_req(reqbuf, CALL_HOLD, 0, 0);
-			break;
-		case N_CONNECT|0x700:
-			idi_put_req(reqbuf, N_CONNECT, 1, 0);
-			break;
-		case N_CONNECT_ACK|0x700:
-			idi_put_req(reqbuf, N_CONNECT_ACK, 1, 0);
-			break;
-		case N_DISC|0x700:
-			idi_put_req(reqbuf, N_DISC, 1, chan->e.IndCh);
-			break;
-		case N_DISC_ACK|0x700:
-			idi_put_req(reqbuf, N_DISC_ACK, 1, chan->e.IndCh);
-			break;
-		default:
-			eicon_log(card, 1, "idi_req: Ch%d: Unknown request\n", chan->No);
-			dev_kfree_skb(skb);
-			dev_kfree_skb(skb2);
-			return(-1);
-	}
-
-	skb_queue_tail(&chan->e.X, skb);
-	skb_queue_tail(&card->sndq, skb2); 
-	eicon_tx_request(card);
-	return(0);
-}
-
-int
-eicon_idi_listen_req(eicon_card *card, eicon_chan *chan)
-{
-	if ((!card) || (!chan))
-		return 1;
-
-	eicon_log(card, 16, "idi_req: Ch%d: Listen_Req eazmask=0x%x\n",chan->No, chan->eazmask);
-	if (!chan->e.D3Id) {
-		idi_do_req(card, chan, ASSIGN, 0); 
-	}
-	if (chan->fsm_state == EICON_STATE_NULL) {
-		if (!(chan->statectrl & HAVE_CONN_REQ)) {
-			idi_do_req(card, chan, INDICATE_REQ, 0);
-			chan->fsm_state = EICON_STATE_LISTEN;
-		}
-	}
-  return(0);
-}
-
-static unsigned char
-idi_si2bc(int si1, int si2, char *bc, char *hlc)
-{
-  hlc[0] = 0;
-  switch(si1) {
-	case 1:
-		bc[0] = 0x90;		/* 3,1 kHz audio */
-		bc[1] = 0x90;		/* 64 kbit/s */
-		bc[2] = 0xa3;		/* G.711 A-law */
-#ifdef EICON_FULL_SERVICE_OKTETT
-		if (si2 == 1) {
-			bc[0] = 0x80;	/* Speech */
-			hlc[0] = 0x02;	/* hlc len */
-			hlc[1] = 0x91;	/* first hic */
-			hlc[2] = 0x81;	/* Telephony */
-		}
-#endif
-		return(3);
-	case 2:
-		bc[0] = 0x90;		/* 3,1 kHz audio */
-		bc[1] = 0x90;		/* 64 kbit/s */
-		bc[2] = 0xa3;		/* G.711 A-law */
-#ifdef EICON_FULL_SERVICE_OKTETT
-		if (si2 == 2) {
-			hlc[0] = 0x02;	/* hlc len */
-			hlc[1] = 0x91;	/* first hic */
-			hlc[2] = 0x84;	/* Fax Gr.2/3 */
-		}
-#endif
-		return(3);
-	case 5:
-	case 7:
-	default:
-		bc[0] = 0x88;
-		bc[1] = 0x90;
-		return(2);
-  }
- return (0);
-}
-
-int
-idi_hangup(eicon_card *card, eicon_chan *chan)
-{
-	if ((!card) || (!chan))
-		return 1;
-
-	if ((chan->fsm_state == EICON_STATE_ACTIVE) ||
-	    (chan->fsm_state == EICON_STATE_WMCONN)) {
-  		if (chan->e.B2Id) idi_do_req(card, chan, N_DISC, 1);
-	}
-	if (chan->e.B2Id) idi_do_req(card, chan, REMOVE, 1);
-	if (chan->fsm_state != EICON_STATE_NULL) {
-		chan->statectrl |= WAITING_FOR_HANGUP;
-		idi_do_req(card, chan, HANGUP, 0);
-		chan->fsm_state = EICON_STATE_NULL;
-	}
-	eicon_log(card, 8, "idi_req: Ch%d: Hangup\n", chan->No);
-#ifdef CONFIG_ISDN_TTY_FAX
-	chan->fax = 0;
-#endif
-  return(0);
-}
-
-int
-capipmsg(eicon_card *card, eicon_chan *chan, capi_msg *cm)
-{
-	if ((cm->para[0] != 3) || (cm->para[1] != 0))
-		return -1;
-	if (cm->para[2] < 3)
-		return -1;
-	if (cm->para[4] != 0)
-		return -1;
-	switch(cm->para[3]) {
-		case 4: /* Suspend */
-			eicon_log(card, 8, "idi_req: Ch%d: Call Suspend\n", chan->No);
-			if (cm->para[5]) {
-				idi_do_req(card, chan, SUSPEND, 0);
-			} else {
-				idi_do_req(card, chan, CALL_HOLD, 0);
-			}
-			break;
-		case 5: /* Resume */
-			eicon_log(card, 8, "idi_req: Ch%d: Call Resume\n", chan->No);
-			idi_do_req(card, chan, RESUME, 0);
-			break;
-        }
-	return 0;
-}
-
-int
-idi_connect_res(eicon_card *card, eicon_chan *chan)
-{
-	if ((!card) || (!chan))
-		return 1;
-
-	chan->fsm_state = EICON_STATE_IWAIT;
-	
-	/* check if old NetID has been removed */
-	if (chan->e.B2Id) {
-		eicon_log(card, 1, "idi_conn_res: Ch%d: old net_id %x still exist, removing.\n",
-			chan->No, chan->e.B2Id);
-		idi_do_req(card, chan, REMOVE, 1);
-	}
-
-	idi_do_req(card, chan, ASSIGN, 1);
-	idi_do_req(card, chan, CALL_RES, 0);
-	return(0);
-}
-
-int
-idi_connect_req(eicon_card *card, eicon_chan *chan, char *phone,
-                    char *eazmsn, int si1, int si2)
-{
-	int l = 0;
-	int i;
-	unsigned char tmp;
-	unsigned char *sub, *sp;
-	unsigned char bc[5];
-	unsigned char hlc[5];
-        struct sk_buff *skb;
-        struct sk_buff *skb2;
-	eicon_REQ *reqbuf;
-	eicon_chan_ptr *chan2;
-
-	if ((!card) || (!chan))
-		return 1;
-
-        skb = alloc_skb(270 + sizeof(eicon_REQ), GFP_ATOMIC);
-        skb2 = alloc_skb(sizeof(eicon_chan_ptr), GFP_ATOMIC);
-
-        if ((!skb) || (!skb2)) {
-               	eicon_log(card, 1, "idi_err: Ch%d: alloc_skb failed in connect_req()\n", chan->No);
-		if (skb) 
-			dev_kfree_skb(skb);
-		if (skb2) 
-			dev_kfree_skb(skb2);
-                return -ENOMEM; 
-	}
-
-	chan2 = (eicon_chan_ptr *)skb_put(skb2, sizeof(eicon_chan_ptr));
-	chan2->ptr = chan;
-
-	reqbuf = (eicon_REQ *)skb_put(skb, 270 + sizeof(eicon_REQ));
-	reqbuf->Req = CALL_REQ;
-	reqbuf->ReqCh = 0;
-	reqbuf->ReqId = 1;
-
-	sub = NULL;
-	sp = phone;
-	while (*sp) {
-		if (*sp == '.') {
-			sub = sp + 1;
-			*sp = 0;
-		} else
-			sp++;
-	}
-	reqbuf->XBuffer.P[l++] = CPN;
-	reqbuf->XBuffer.P[l++] = strlen(phone) + 1;
-	reqbuf->XBuffer.P[l++] = 0x81;
-	for(i=0; i<strlen(phone);i++) 
-		reqbuf->XBuffer.P[l++] = phone[i] & 0x7f;
-	if (sub) {
-		reqbuf->XBuffer.P[l++] = DSA;
-		reqbuf->XBuffer.P[l++] = strlen(sub) + 2;
-		reqbuf->XBuffer.P[l++] = 0x80; /* NSAP coded */
-		reqbuf->XBuffer.P[l++] = 0x50; /* local IDI format */
-		while (*sub)
-			reqbuf->XBuffer.P[l++] = *sub++ & 0x7f;
-	}
-
-	sub = NULL;
-	sp = eazmsn;
-	while (*sp) {
-		if (*sp == '.') {
-			sub = sp + 1;
-			*sp = 0;
-		} else
-			sp++;
-	}
-	reqbuf->XBuffer.P[l++] = OAD;
-	reqbuf->XBuffer.P[l++] = strlen(eazmsn) + 2;
-	reqbuf->XBuffer.P[l++] = 0x01;
-	reqbuf->XBuffer.P[l++] = 0x80;
-	for(i=0; i<strlen(eazmsn);i++) 
-		reqbuf->XBuffer.P[l++] = eazmsn[i] & 0x7f;
-	if (sub) {
-		reqbuf->XBuffer.P[l++] = OSA;
-		reqbuf->XBuffer.P[l++] = strlen(sub) + 2;
-		reqbuf->XBuffer.P[l++] = 0x80; /* NSAP coded */
-		reqbuf->XBuffer.P[l++] = 0x50; /* local IDI format */
-		while (*sub)
-			reqbuf->XBuffer.P[l++] = *sub++ & 0x7f;
-	}
-
-	if (si2 > 2) {
-		reqbuf->XBuffer.P[l++] = SHIFT|6;
-		reqbuf->XBuffer.P[l++] = SIN;
-		reqbuf->XBuffer.P[l++] = 2;
-		reqbuf->XBuffer.P[l++] = si1;
-		reqbuf->XBuffer.P[l++] = si2;
-	}
-	else if ((tmp = idi_si2bc(si1, si2, bc, hlc)) > 0) {
-		reqbuf->XBuffer.P[l++] = BC;
-		reqbuf->XBuffer.P[l++] = tmp;
-		for(i=0; i<tmp;i++) 
-			reqbuf->XBuffer.P[l++] = bc[i];
-		if ((tmp=hlc[0])) {
-			reqbuf->XBuffer.P[l++] = HLC;
-			reqbuf->XBuffer.P[l++] = tmp;
-			for(i=1; i<=tmp;i++) 
-				reqbuf->XBuffer.P[l++] = hlc[i];
-		}
-	}
-
-        reqbuf->XBuffer.P[l++] = CAI;
-        reqbuf->XBuffer.P[l++] = 6;
-        reqbuf->XBuffer.P[l++] = 0x09;
-	reqbuf->XBuffer.P[l++] = 0;
-	reqbuf->XBuffer.P[l++] = 0;
-	reqbuf->XBuffer.P[l++] = 0;
-	reqbuf->XBuffer.P[l++] = 32;
-	reqbuf->XBuffer.P[l++] = 0;
-        switch(chan->l2prot) {
-		case ISDN_PROTO_L2_X75I:
-		case ISDN_PROTO_L2_X75UI:
-		case ISDN_PROTO_L2_X75BUI:
-                case ISDN_PROTO_L2_HDLC:
-                        reqbuf->XBuffer.P[l-6] = 5;
-                        reqbuf->XBuffer.P[l-7] = 1;
-			l -= 5; 
-                        break;
-                case ISDN_PROTO_L2_V11096:
-                        reqbuf->XBuffer.P[l-7] = 3;
-                        reqbuf->XBuffer.P[l-6] = 0x0d;
-                        reqbuf->XBuffer.P[l-5] = 5;
-                        reqbuf->XBuffer.P[l-4] = 0;
-                        l -= 3;
-                        break;
-                case ISDN_PROTO_L2_V11019:
-                        reqbuf->XBuffer.P[l-7] = 3;
-                        reqbuf->XBuffer.P[l-6] = 0x0d;
-                        reqbuf->XBuffer.P[l-5] = 6;
-                        reqbuf->XBuffer.P[l-4] = 0;
-                        l -= 3;
-                        break;
-                case ISDN_PROTO_L2_V11038:
-                        reqbuf->XBuffer.P[l-7] = 3;
-                        reqbuf->XBuffer.P[l-6] = 0x0d;
-                        reqbuf->XBuffer.P[l-5] = 7;
-                        reqbuf->XBuffer.P[l-4] = 0;
-                        l -= 3;
-                        break;
-                case ISDN_PROTO_L2_MODEM:
-			/* reqbuf->XBuffer.P[l-7] = 12; */
-			reqbuf->XBuffer.P[l-6] = 0x11;
-			reqbuf->XBuffer.P[l-5] = 7;
-			reqbuf->XBuffer.P[l-4] = 0;
-			reqbuf->XBuffer.P[l-3] = 0;
-			reqbuf->XBuffer.P[l-2] = 32;
-			reqbuf->XBuffer.P[l-1] = 0;
-                        break;
-                case ISDN_PROTO_L2_FAX:
-			reqbuf->XBuffer.P[l-6] = 0x10;
-			reqbuf->XBuffer.P[l-5] = 0;
-			reqbuf->XBuffer.P[l-4] = 0;
-			reqbuf->XBuffer.P[l-3] = 0;
-			reqbuf->XBuffer.P[l-2] = 32;
-			reqbuf->XBuffer.P[l-1] = 0;
-                        break;
-		case ISDN_PROTO_L2_TRANS:
-			switch(chan->l3prot) {
-				case ISDN_PROTO_L3_TRANSDSP:
-					reqbuf->XBuffer.P[l-6] = 22; /* DTMF, audio events on */
-			}
-			break;
-        }
-	
-	reqbuf->XBuffer.P[l++] = 0; /* end */
-	reqbuf->XBuffer.length = l;
-	reqbuf->Reference = 0; /* Sig Entity */
-
-	if (chan->statectrl & WAITING_FOR_HANGUP) {
-		/*	If the line did not disconnect yet,
-			we have to delay this command		*/
-		eicon_log(card, 32, "idi_req: Ch%d: delaying conn_req\n", chan->No);
-		chan->statectrl |= HAVE_CONN_REQ;
-		chan->tskb1 = skb;
-		chan->tskb2 = skb2;
-	} else {
-		skb_queue_tail(&chan->e.X, skb);
-		skb_queue_tail(&card->sndq, skb2); 
-		eicon_tx_request(card);
-	}
-
-	eicon_log(card, 8, "idi_req: Ch%d: Conn_Req %s -> %s\n",chan->No, eazmsn, phone);
-   return(0);
-}
-
-
-static void
-idi_IndParse(eicon_card *ccard, eicon_chan *chan, idi_ind_message *message, unsigned char *buffer, int len)
-{
-	int i,j;
-	int pos = 0;
-	int codeset = 0;
-	int wlen = 0;
-	int lock = 0;
-	__u8 w;
-	__u16 code;
-	isdn_ctrl cmd;
-
-	memset(message, 0, sizeof(idi_ind_message));
-
-	if ((!len) || (!buffer[pos])) return;
-
-  while(pos <= len) {
-	w = buffer[pos++];
-	if (!w) return;
-	if (w & 0x80) {
-		wlen = 0;
-	}
-	else {
-		wlen = buffer[pos++];
-	}
-
-	if (pos > len) return;
-
-	if (lock & 0x80) lock &= 0x7f;
-	else codeset = lock;
-
-	if((w&0xf0) == SHIFT) {
-		codeset = w;
-		if(!(codeset & 0x08)) lock = codeset & 7;
-		codeset &= 7;
-		lock |= 0x80;
-	}
-	else {
-		if (w==ESC && wlen >=2) {
-			code = buffer[pos++]|0x800;
-			wlen--;
-		}
-		else code = w;
-		code |= (codeset<<8);
-
-		if (pos + wlen > len) {
-			eicon_log(ccard, 1, "idi_err: Ch%d: IElen %d of %x exceeds Ind_Length (+%d)\n", chan->No, 
-					wlen, code, (pos + wlen) - len);
-			return;
-		}
-
-		switch(code) {
-			case OAD:
-				if (wlen > sizeof(message->oad)) {
-					pos += wlen;
-					break;
-				}
-				j = 1;
-				if (wlen) {
-					message->plan = buffer[pos++];
-					if (message->plan &0x80) 
-						message->screen = 0;
-					else {
-						message->screen = buffer[pos++];
-						j = 2;
-					}
-				}
-				for(i=0; i < wlen-j; i++) 
-					message->oad[i] = buffer[pos++];
-				eicon_log(ccard, 2, "idi_inf: Ch%d: OAD=(0x%02x,0x%02x) %s\n", chan->No, 
-					message->plan, message->screen, message->oad);
-				break;
-			case RDN:
-				if (wlen > sizeof(message->rdn)) {
-					pos += wlen;
-					break;
-				}
-				j = 1;
-				if (wlen) {
-					if (!(buffer[pos++] & 0x80)) {
-						pos++; 
-						j = 2;
-					}
-				}
-				for(i=0; i < wlen-j; i++) 
-					message->rdn[i] = buffer[pos++];
-				eicon_log(ccard, 2, "idi_inf: Ch%d: RDN= %s\n", chan->No, 
-						message->rdn);
-				break;
-			case CPN:
-				if (wlen > sizeof(message->cpn)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->cpn[i] = buffer[pos++];
-				eicon_log(ccard, 2, "idi_inf: Ch%d: CPN=(0x%02x) %s\n", chan->No,
-					(__u8)message->cpn[0], message->cpn + 1);
-				break;
-			case DSA:
-				if (wlen > sizeof(message->dsa)) {
-					pos += wlen;
-					break;
-				}
-				pos += 2;
-				for(i=0; i < wlen-2; i++) 
-					message->dsa[i] = buffer[pos++];
-				eicon_log(ccard, 2, "idi_inf: Ch%d: DSA=%s\n", chan->No, message->dsa);
-				break;
-			case OSA:
-				if (wlen > sizeof(message->osa)) {
-					pos += wlen;
-					break;
-				}
-				pos += 2;
-				for(i=0; i < wlen-2; i++) 
-					message->osa[i] = buffer[pos++];
-				eicon_log(ccard, 2, "idi_inf: Ch%d: OSA=%s\n", chan->No, message->osa);
-				break;
-			case CAD:
-				pos += wlen;
-				eicon_log(ccard, 2, "idi_inf: Ch%d: Connected Address in ind, len:%x\n", 
-					chan->No, wlen);
-				break;
-			case BC:
-				if (wlen > sizeof(message->bc)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->bc[i] = buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: BC = 0x%02x 0x%02x 0x%02x\n", chan->No,
-					message->bc[0],message->bc[1],message->bc[2]);
-				break;
-			case 0x800|BC:
-				if (wlen > sizeof(message->e_bc)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->e_bc[i] = buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: ESC/BC=%d\n", chan->No, message->bc[0]);
-				break;
-			case LLC:
-				if (wlen > sizeof(message->llc)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->llc[i] = buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: LLC=%d %d %d %d ...\n", chan->No, message->llc[0],
-					message->llc[1],message->llc[2],message->llc[3]);
-				break;
-			case HLC:
-				if (wlen > sizeof(message->hlc)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->hlc[i] = buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: HLC=%x %x %x %x %x ...\n", chan->No,
-					message->hlc[0], message->hlc[1],
-					message->hlc[2], message->hlc[3], message->hlc[4]);
-				break;
-			case DSP:
-			case 0x600|DSP:
-				if (wlen > sizeof(message->display)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->display[i] = buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: Display: %s\n", chan->No,
-					message->display);
-				break;
-			case 0x600|KEY:
-				if (wlen > sizeof(message->keypad)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->keypad[i] = buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: Keypad: %s\n", chan->No,
-					message->keypad);
-				break;
-			case NI:
-			case 0x600|NI:
-				if (wlen) {
-					switch(buffer[pos] & 127) {
-						case 0:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: User suspended.\n", chan->No);
-							break;
-						case 1:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: User resumed.\n", chan->No);
-							break;
-						case 2:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: Bearer service change.\n", chan->No);
-							break;
-						default:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: Unknown Notification %x.\n", 
-									chan->No, buffer[pos] & 127);
-					}
-					pos += wlen;
-				}
-				break;
-			case PI:
-			case 0x600|PI:
-				if (wlen > 1) {
-					switch(buffer[pos+1] & 127) {
-						case 1:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: Call is not end-to-end ISDN.\n", chan->No);
-							break;
-						case 2:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: Destination address is non ISDN.\n", chan->No);
-							break;
-						case 3:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: Origination address is non ISDN.\n", chan->No);
-							break;
-						case 4:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: Call has returned to the ISDN.\n", chan->No);
-							break;
-						case 5:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: Interworking has occurred.\n", chan->No);
-							break;
-						case 8:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: In-band information available.\n", chan->No);
-							break;
-						default:
-							eicon_log(ccard, 4, "idi_inf: Ch%d: Unknown Progress %x.\n", 
-									chan->No, buffer[pos+1] & 127);
-					}
-				}
-				pos += wlen;
-				break;
-			case CAU:
-				if (wlen > sizeof(message->cau)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->cau[i] = buffer[pos++];
-				memcpy(&chan->cause, &message->cau, 2);
-				eicon_log(ccard, 4, "idi_inf: Ch%d: CAU=%d %d\n", chan->No,
-					message->cau[0],message->cau[1]);
-				break;
-			case 0x800|CAU:
-				if (wlen > sizeof(message->e_cau)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->e_cau[i] = buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: ECAU=%d %d\n", chan->No,
-					message->e_cau[0],message->e_cau[1]);
-				break;
-			case 0x800|CHI:
-				if (wlen > sizeof(message->e_chi)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->e_chi[i] = buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: ESC/CHI=%d\n", chan->No,
-					message->e_cau[0]);
-				break;
-			case 0x800|0x7a:
-				pos ++;
-				message->e_mt=buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: EMT=0x%x\n", chan->No, message->e_mt);
-				break;
-			case DT:
-				if (wlen > sizeof(message->dt)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->dt[i] = buffer[pos++];
-				eicon_log(ccard, 4, "idi_inf: Ch%d: DT: %02d.%02d.%02d %02d:%02d:%02d\n", chan->No,
-					message->dt[2], message->dt[1], message->dt[0],
-					message->dt[3], message->dt[4], message->dt[5]);
-				break;
-			case 0x600|SIN:
-				if (wlen > sizeof(message->sin)) {
-					pos += wlen;
-					break;
-				}
-				for(i=0; i < wlen; i++) 
-					message->sin[i] = buffer[pos++];
-				eicon_log(ccard, 2, "idi_inf: Ch%d: SIN=%d %d\n", chan->No,
-					message->sin[0],message->sin[1]);
-				break;
-			case 0x600|CPS:
-				eicon_log(ccard, 2, "idi_inf: Ch%d: Called Party Status in ind\n", chan->No);
-				pos += wlen;
-				break;
-			case 0x600|CIF:
-				for (i = 0; i < wlen; i++)
-					if (buffer[pos + i] != '0') break;
-				memcpy(&cmd.parm.num, &buffer[pos + i], wlen - i);
-				cmd.parm.num[wlen - i] = 0;
-				eicon_log(ccard, 2, "idi_inf: Ch%d: CIF=%s\n", chan->No, cmd.parm.num);
-				pos += wlen;
-				cmd.driver = ccard->myid;
-				cmd.command = ISDN_STAT_CINF;
-				cmd.arg = chan->No;
-				ccard->interface.statcallb(&cmd);
-				break;
-			case 0x600|DATE:
-				eicon_log(ccard, 2, "idi_inf: Ch%d: Date in ind\n", chan->No);
-				pos += wlen;
-				break;
-			case 0xa1: 
-				eicon_log(ccard, 2, "idi_inf: Ch%d: Sending Complete in ind.\n", chan->No);
-				pos += wlen;
-				break;
-			case 0xe08: 
-			case 0xe7a: 
-			case 0xe04: 
-			case 0xe00: 
-				/* *** TODO *** */
-			case CHA:
-				/* Charge advice */
-			case FTY:
-			case 0x600|FTY:
-			case CHI:
-			case 0x800:
-				/* Not yet interested in this */
-				pos += wlen;
-				break;
-			case 0x880:
-				/* Managment Information Element */
-				if (!manbuf) {
-					eicon_log(ccard, 1, "idi_err: manbuf not allocated\n");
-				}
-				else {
-					memcpy(&manbuf->data[manbuf->pos], &buffer[pos], wlen);
-					manbuf->length[manbuf->count] = wlen;
-					manbuf->count++;
-					manbuf->pos += wlen;
-				}
-				pos += wlen;
-				break;
-			default:
-				pos += wlen;
-				eicon_log(ccard, 6, "idi_inf: Ch%d: unknown information element 0x%x in ind, len:%x\n", 
-					chan->No, code, wlen);
-		}
-	}
-  }
-}
-
-static void
-idi_bc2si(unsigned char *bc, unsigned char *hlc, unsigned char *sin, unsigned char *si1, unsigned char *si2)
-{
-	si1[0] = 0;
-	si2[0] = 0;
-
-	switch (bc[0] & 0x7f) {
-		case 0x00: /* Speech */
-			si1[0] = 1;
-#ifdef EICON_FULL_SERVICE_OKTETT
-			si1[0] = sin[0];
-			si2[0] = sin[1];
-#endif
-			break;
-		case 0x10: /* 3.1 Khz audio */
-			si1[0] = 1;
-#ifdef EICON_FULL_SERVICE_OKTETT
-			si1[0] = sin[0];
-			si2[0] = sin[1];
-#endif
-			break;
-		case 0x08: /* Unrestricted digital information */
-			si1[0] = 7;
-			si2[0] = sin[1];
-			break;
-		case 0x09: /* Restricted digital information */
-			si1[0] = 2;
-			break;
-		case 0x11:
-			/* Unrestr. digital information  with
-			 * tones/announcements ( or 7 kHz audio
-			 */
-			si1[0] = 3;
-			break;
-		case 0x18: /* Video */
-			si1[0] = 4;
-			break;
-	}
-	switch (bc[1] & 0x7f) {
-		case 0x40: /* packed mode */
-			si1[0] = 8;
-			break;
-		case 0x10: /* 64 kbit */
-		case 0x11: /* 2*64 kbit */
-		case 0x13: /* 384 kbit */
-		case 0x15: /* 1536 kbit */
-		case 0x17: /* 1920 kbit */
-			/* moderate = bc[1] & 0x7f; */
-			break;
-	}
-}
-
-/********************* FAX stuff ***************************/
-
-#ifdef CONFIG_ISDN_TTY_FAX
-
-static int
-idi_fill_in_T30(eicon_chan *chan, unsigned char *buffer)
-{
-	eicon_t30_s	*t30 = (eicon_t30_s *) buffer;
-
-	if (!chan->fax) {
-		eicon_log(NULL, 1,"idi_T30: fill_in with NULL fax struct, ERROR\n");
-		return 0;
-	}
-	memset(t30, 0, sizeof(eicon_t30_s));
-	t30->station_id_len = EICON_FAXID_LEN;
-	memcpy(&t30->station_id[0], &chan->fax->id[0], EICON_FAXID_LEN);
-	t30->resolution = chan->fax->resolution;
-	t30->rate = chan->fax->rate + 1;	/* eicon rate starts with 1 */
-	t30->format = T30_FORMAT_SFF;
-	t30->pages_low = 0;
-	t30->pages_high = 0;
-	t30->atf = 1;				/* optimised for AT+F command set */
-	t30->code = 0;
-	t30->feature_bits_low = 0;
-	t30->feature_bits_high = 0;
-	t30->control_bits_low = 0;
-	t30->control_bits_high = 0;
-
-	if (chan->fax->nbc) {
-		/* set compression by DCC value */
-  	  switch(chan->fax->compression) {
-		case (0):	/* 1-D modified */
-			break;
-		case (1):	/* 2-D modified Read */
-			t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_2D_CODING;
-			t30->feature_bits_low |= T30_FEATURE_BIT_2D_CODING;
-			break;
-		case (2):	/* 2-D uncompressed */
-			t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_UNCOMPR;
-			t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_2D_CODING;
-			t30->feature_bits_low |= T30_FEATURE_BIT_UNCOMPR_ENABLED;
-			t30->feature_bits_low |= T30_FEATURE_BIT_2D_CODING;
-			break;
-		case (3):	/* 2-D modified Read */
-			t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_T6_CODING;
-			t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_2D_CODING;
-			t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_UNCOMPR;
-			t30->feature_bits_low |= T30_FEATURE_BIT_UNCOMPR_ENABLED;
-			t30->feature_bits_low |= T30_FEATURE_BIT_T6_CODING;
-			t30->feature_bits_low |= T30_FEATURE_BIT_2D_CODING;
-			t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_ECM;
-			t30->feature_bits_low |= T30_FEATURE_BIT_ECM;
-			break;
-	  }
-	} else {
-		/* set compression to best */
-		t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_T6_CODING;
-		t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_2D_CODING;
-		t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_UNCOMPR;
-		t30->feature_bits_low |= T30_FEATURE_BIT_UNCOMPR_ENABLED;
-		t30->feature_bits_low |= T30_FEATURE_BIT_T6_CODING;
-		t30->feature_bits_low |= T30_FEATURE_BIT_2D_CODING;
-		t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_ECM;
-		t30->feature_bits_low |= T30_FEATURE_BIT_ECM;
-	}
-	switch(chan->fax->ecm) {
-		case (0):	/* disable ECM */
-			break;
-		case (1):
-			t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_ECM;
-			t30->control_bits_low |= T30_CONTROL_BIT_ECM_64_BYTES;
-			t30->feature_bits_low |= T30_FEATURE_BIT_ECM;
-			t30->feature_bits_low |= T30_FEATURE_BIT_ECM_64_BYTES;
-			break;
-		case (2):
-			t30->control_bits_low |= T30_CONTROL_BIT_ENABLE_ECM;
-			t30->feature_bits_low |= T30_FEATURE_BIT_ECM;
-			break;
-	}
-
-	if (DebugVar & 128) {
-		char st[40];
-		eicon_log(NULL, 128, "sT30:code = %x\n", t30->code);
-		eicon_log(NULL, 128, "sT30:rate = %x\n", t30->rate);
-		eicon_log(NULL, 128, "sT30:res  = %x\n", t30->resolution);
-		eicon_log(NULL, 128, "sT30:format = %x\n", t30->format);
-		eicon_log(NULL, 128, "sT30:pages_low = %x\n", t30->pages_low);
-		eicon_log(NULL, 128, "sT30:pages_high = %x\n", t30->pages_high);
-		eicon_log(NULL, 128, "sT30:atf  = %x\n", t30->atf);
-		eicon_log(NULL, 128, "sT30:control_bits_low = %x\n", t30->control_bits_low);
-		eicon_log(NULL, 128, "sT30:control_bits_high = %x\n", t30->control_bits_high);
-		eicon_log(NULL, 128, "sT30:feature_bits_low = %x\n", t30->feature_bits_low);
-		eicon_log(NULL, 128, "sT30:feature_bits_high = %x\n", t30->feature_bits_high);
-		//eicon_log(NULL, 128, "sT30:universal_5 = %x\n", t30->universal_5);
-		//eicon_log(NULL, 128, "sT30:universal_6 = %x\n", t30->universal_6);
-		//eicon_log(NULL, 128, "sT30:universal_7 = %x\n", t30->universal_7);
-		eicon_log(NULL, 128, "sT30:station_id_len = %x\n", t30->station_id_len);
-		eicon_log(NULL, 128, "sT30:head_line_len = %x\n", t30->head_line_len);
-		strlcpy(st, t30->station_id, t30->station_id_len + 1);
-		eicon_log(NULL, 128, "sT30:station_id = <%s>\n", st);
-	}
-	return(sizeof(eicon_t30_s));
-}
-
-/* send fax struct */
-static int
-idi_send_edata(eicon_card *card, eicon_chan *chan)
-{
-	struct sk_buff *skb;
-	struct sk_buff *skb2;
-	eicon_REQ *reqbuf;
-	eicon_chan_ptr *chan2;
-
-	if ((chan->fsm_state == EICON_STATE_NULL) || (chan->fsm_state == EICON_STATE_LISTEN)) {
-		eicon_log(card, 1, "idi_snd: Ch%d: send edata on state %d !\n", chan->No, chan->fsm_state);
-		return -ENODEV;
-	}
-	eicon_log(card, 128, "idi_snd: Ch%d: edata (fax)\n", chan->No);
-
-	skb = alloc_skb(sizeof(eicon_REQ) + sizeof(eicon_t30_s), GFP_ATOMIC);
-	skb2 = alloc_skb(sizeof(eicon_chan_ptr), GFP_ATOMIC);
-
-	if ((!skb) || (!skb2)) {
-		eicon_log(card, 1, "idi_err: Ch%d: alloc_skb failed in send_edata()\n", chan->No);
-		if (skb) 
-			dev_kfree_skb(skb);
-		if (skb2) 
-			dev_kfree_skb(skb2);
-		return -ENOMEM;
-	}
-
-	chan2 = (eicon_chan_ptr *)skb_put(skb2, sizeof(eicon_chan_ptr));
-	chan2->ptr = chan;
-
-	reqbuf = (eicon_REQ *)skb_put(skb, sizeof(eicon_t30_s) + sizeof(eicon_REQ));
-
-	reqbuf->Req = N_EDATA;
-	reqbuf->ReqCh = chan->e.IndCh;
-	reqbuf->ReqId = 1;
-
-	reqbuf->XBuffer.length = idi_fill_in_T30(chan, reqbuf->XBuffer.P);
-	reqbuf->Reference = 1; /* Net Entity */
-
-	skb_queue_tail(&chan->e.X, skb);
-	skb_queue_tail(&card->sndq, skb2);
-	eicon_tx_request(card);
-	return (0);
-}
-
-static void
-idi_parse_edata(eicon_card *ccard, eicon_chan *chan, unsigned char *buffer, int len)
-{
-	eicon_t30_s *p = (eicon_t30_s *)buffer;
-	int i;
-
-	if (DebugVar & 128) {
-		char st[40];
-		eicon_log(ccard, 128, "rT30:len %d , size %d\n", len, sizeof(eicon_t30_s));
-		eicon_log(ccard, 128, "rT30:code = %x\n", p->code);
-		eicon_log(ccard, 128, "rT30:rate = %x\n", p->rate);
-		eicon_log(ccard, 128, "rT30:res  = %x\n", p->resolution);
-		eicon_log(ccard, 128, "rT30:format = %x\n", p->format);
-		eicon_log(ccard, 128, "rT30:pages_low = %x\n", p->pages_low);
-		eicon_log(ccard, 128, "rT30:pages_high = %x\n", p->pages_high);
-		eicon_log(ccard, 128, "rT30:atf  = %x\n", p->atf);
-		eicon_log(ccard, 128, "rT30:control_bits_low = %x\n", p->control_bits_low);
-		eicon_log(ccard, 128, "rT30:control_bits_high = %x\n", p->control_bits_high);
-		eicon_log(ccard, 128, "rT30:feature_bits_low = %x\n", p->feature_bits_low);
-		eicon_log(ccard, 128, "rT30:feature_bits_high = %x\n", p->feature_bits_high);
-		//eicon_log(ccard, 128, "rT30:universal_5 = %x\n", p->universal_5);
-		//eicon_log(ccard, 128, "rT30:universal_6 = %x\n", p->universal_6);
-		//eicon_log(ccard, 128, "rT30:universal_7 = %x\n", p->universal_7);
-		eicon_log(ccard, 128, "rT30:station_id_len = %x\n", p->station_id_len);
-		eicon_log(ccard, 128, "rT30:head_line_len = %x\n", p->head_line_len);
-		strlcpy(st, p->station_id, p->station_id_len + 1);
-		eicon_log(ccard, 128, "rT30:station_id = <%s>\n", st);
-	}
-	if (!chan->fax) {
-		eicon_log(ccard, 1, "idi_edata: parse to NULL fax struct, ERROR\n");
-		return;
-	}
-	chan->fax->code = p->code;
-	i = (p->station_id_len < FAXIDLEN) ? p->station_id_len : (FAXIDLEN - 1);
-	memcpy(chan->fax->r_id, p->station_id, i);
-	chan->fax->r_id[i] = 0;
-	chan->fax->r_resolution = p->resolution;
-	chan->fax->r_rate = p->rate - 1;
-	chan->fax->r_binary = 0; /* no binary support */
-	chan->fax->r_width = 0;
-	chan->fax->r_length = 2;
-	chan->fax->r_scantime = 0;
-	chan->fax->r_compression = 0;
-	chan->fax->r_ecm = 0;
-	if (p->feature_bits_low & T30_FEATURE_BIT_2D_CODING) {
-		chan->fax->r_compression = 1;
-		if (p->feature_bits_low & T30_FEATURE_BIT_UNCOMPR_ENABLED) {
-			chan->fax->r_compression = 2;
-		}
-	}
-	if (p->feature_bits_low & T30_FEATURE_BIT_T6_CODING) {
-		chan->fax->r_compression = 3;
-	}
-
-	if (p->feature_bits_low & T30_FEATURE_BIT_ECM) {
-		chan->fax->r_ecm = 2;
-		if (p->feature_bits_low & T30_FEATURE_BIT_ECM_64_BYTES)
-			chan->fax->r_ecm = 1;
-	}
-}
-
-static void
-idi_fax_send_header(eicon_card *card, eicon_chan *chan, int header)
-{
-	static __u16 wd2sff[] = {
-		1728, 2048, 2432, 1216, 864
-	};
-	static __u16 ln2sff[2][3] = {
-		{ 1143, 1401, 0 } , { 2287, 2802, 0 }
-	};
-	struct sk_buff *skb;
-	eicon_sff_dochead *doc;
-	eicon_sff_pagehead *page;
-	u_char *docp;
-
-	if (!chan->fax) {
-		eicon_log(card, 1, "idi_fax: send head with NULL fax struct, ERROR\n");
-		return;
-	}
-	if (header == 2) { /* DocHeader + PageHeader */
-		skb = alloc_skb(sizeof(eicon_sff_dochead) + sizeof(eicon_sff_pagehead), GFP_ATOMIC);
-	} else {
-		skb = alloc_skb(sizeof(eicon_sff_pagehead), GFP_ATOMIC);
-	}
-	if (!skb) {
-		eicon_log(card, 1, "idi_err: Ch%d: alloc_skb failed in fax_send_header()\n", chan->No);
-		return;
-	}
-
-	if (header == 2) { /* DocHeader + PageHeader */
-		docp = skb_put(skb, sizeof(eicon_sff_dochead) + sizeof(eicon_sff_pagehead));
-		doc = (eicon_sff_dochead *) docp;
-		page = (eicon_sff_pagehead *) (docp + sizeof(eicon_sff_dochead));
-		memset(docp, 0,sizeof(eicon_sff_dochead)  + sizeof(eicon_sff_pagehead));
-		doc->id = 0x66666653;
-		doc->version = 0x01;
-		doc->off1pagehead = sizeof(eicon_sff_dochead);
-	} else {
-		page = (eicon_sff_pagehead *)skb_put(skb, sizeof(eicon_sff_pagehead));
-		memset(page, 0, sizeof(eicon_sff_pagehead));
-	}
-
-	switch(header) {
-		case 1:	/* PageHeaderEnd */
-			page->pageheadid = 254;
-			page->pageheadlen = 0; 
-			break;
-		case 0: /* PageHeader */
-		case 2: /* DocHeader + PageHeader */
-			page->pageheadid = 254;
-			page->pageheadlen = sizeof(eicon_sff_pagehead) - 2;
-			page->resvert = chan->fax->resolution;
-			page->reshoriz = 0; /* always 203 dpi */
-			page->coding = 0; /* always 1D */
-			page->linelength = wd2sff[chan->fax->width];
-			page->pagelength = ln2sff[chan->fax->resolution][chan->fax->length]; 
-			eicon_log(card, 128, "sSFF-Head: linelength = %d\n", page->linelength);
-			eicon_log(card, 128, "sSFF-Head: pagelength = %d\n", page->pagelength);
-			break;
-	}
-	idi_send_data(card, chan, 0, skb, 0, 0);
-}
-
-void
-idi_fax_cmd(eicon_card *card, eicon_chan *chan) 
-{
-	isdn_ctrl cmd;
-
-	if ((!card) || (!chan))
-		return;
-
-	if (!chan->fax) {
-		eicon_log(card, 1, "idi_fax: cmd with NULL fax struct, ERROR\n");
-		return;
-	}
-	switch (chan->fax->code) {
-		case ISDN_TTY_FAX_DT:
-			if (chan->fax->phase == ISDN_FAX_PHASE_B) {
-				idi_send_edata(card, chan);
-				break;
-			}
-			if (chan->fax->phase == ISDN_FAX_PHASE_D) {
-				idi_send_edata(card, chan);
-				break;
-			}
-			break;
-
-		case ISDN_TTY_FAX_DR:
-			if (chan->fax->phase == ISDN_FAX_PHASE_B) {
-				idi_send_edata(card, chan);
-
-				cmd.driver = card->myid;
-				cmd.command = ISDN_STAT_FAXIND;
-				cmd.arg = chan->No;
-				chan->fax->r_code = ISDN_TTY_FAX_CFR;
-				card->interface.statcallb(&cmd);
-
-				cmd.driver = card->myid;
-				cmd.command = ISDN_STAT_FAXIND;
-				cmd.arg = chan->No;
-				chan->fax->r_code = ISDN_TTY_FAX_RID;
-				card->interface.statcallb(&cmd);
-
-				/* telling 1-D compression */
-				chan->fax->r_compression = 0;
-				cmd.driver = card->myid;
-				cmd.command = ISDN_STAT_FAXIND;
-				cmd.arg = chan->No;
-				chan->fax->r_code = ISDN_TTY_FAX_DCS;
-				card->interface.statcallb(&cmd);
-
-				chan->fax2.NextObject = FAX_OBJECT_DOCU;
-				chan->fax2.PrevObject = FAX_OBJECT_DOCU;
-
-				break;
-			}
-			if (chan->fax->phase == ISDN_FAX_PHASE_D) {
-				idi_send_edata(card, chan);
-				break;
-			}
-			break;
-
-		case ISDN_TTY_FAX_ET:
-				switch(chan->fax->fet) {
-					case 0:
-					case 1:
-						idi_fax_send_header(card, chan, 0);
-						break;
-					case 2:
-						idi_fax_send_header(card, chan, 1);
-						break;
-				}
-			break;
-	}
-}
-
-static void
-idi_edata_rcveop(eicon_card *card, eicon_chan *chan)
-{
-	isdn_ctrl cmd;
-
-	if (!chan->fax) {
-		eicon_log(card, 1, "idi_edata: rcveop with NULL fax struct, ERROR\n");
-		return;
-	}
-	cmd.driver = card->myid;
-	cmd.command = ISDN_STAT_FAXIND;
-	cmd.arg = chan->No;
-	chan->fax->r_code = ISDN_TTY_FAX_ET;
-	card->interface.statcallb(&cmd);
-}
-
-static void
-idi_reset_fax_stat(eicon_chan *chan)
-{
-	chan->fax2.LineLen = 0;
-	chan->fax2.LineData = 0;
-	chan->fax2.LineDataLen = 0;
-	chan->fax2.NullByteExist = 0;
-	chan->fax2.Dle = 0;
-	chan->fax2.PageCount = 0;
-	chan->fax2.Eop = 0;
-}
-
-static void
-idi_edata_action(eicon_card *ccard, eicon_chan *chan, char *buffer, int len)
-{
-	isdn_ctrl cmd;
-
-	if (!chan->fax) {
-		eicon_log(ccard, 1, "idi_edata: action with NULL fax struct, ERROR\n");
-		return;
-	}
-	if (chan->fax->direction == ISDN_TTY_FAX_CONN_OUT) {
-		idi_parse_edata(ccard, chan, buffer, len);
-
-		if (chan->fax->phase == ISDN_FAX_PHASE_A) {
-			idi_reset_fax_stat(chan);
-
-			chan->fsm_state = EICON_STATE_ACTIVE;
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_BCONN;
-			cmd.arg = chan->No;
-			strcpy(cmd.parm.num, "");
-			ccard->interface.statcallb(&cmd);
-
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_FAXIND;
-			cmd.arg = chan->No;
-			chan->fax->r_code = ISDN_TTY_FAX_FCON;
-			ccard->interface.statcallb(&cmd);
-
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_FAXIND;
-			cmd.arg = chan->No;
-			chan->fax->r_code = ISDN_TTY_FAX_RID;
-			ccard->interface.statcallb(&cmd);
-
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_FAXIND;
-			cmd.arg = chan->No;
-			chan->fax->r_code = ISDN_TTY_FAX_DIS;
-			ccard->interface.statcallb(&cmd);
-
-			if (chan->fax->r_compression != 0) {
-			/* telling fake compression in second DIS message */
-				chan->fax->r_compression = 0;
-				cmd.driver = ccard->myid;
-				cmd.command = ISDN_STAT_FAXIND;
-				cmd.arg = chan->No;
-				chan->fax->r_code = ISDN_TTY_FAX_DIS;
-				ccard->interface.statcallb(&cmd);
-			}
-
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_FAXIND;
-			cmd.arg = chan->No;
-			chan->fax->r_code = ISDN_TTY_FAX_SENT; /* OK message */
-			ccard->interface.statcallb(&cmd);
-		} else
-		if (chan->fax->phase == ISDN_FAX_PHASE_D) {
-
-			if ((chan->fax->code == EDATA_T30_MCF) &&
-			    (chan->fax->fet != 2)) {
-				cmd.driver = ccard->myid;
-				cmd.command = ISDN_STAT_FAXIND;
-				cmd.arg = chan->No;
-				chan->fax->r_code = ISDN_TTY_FAX_PTS;
-				ccard->interface.statcallb(&cmd);
-			}
-
-			switch(chan->fax->fet) {
-				case 0:	/* new page */
-					/* stay in phase D , wait on cmd +FDT */
-					break;
-				case 1:	/* new document */
-					/* link-level switch to phase B */
-					break;
-				case 2:	/* session end */
-				default:
-					/* send_edata produces error on some */
-					/* fax-machines here, so we don't */
-					/* idi_send_edata(ccard, chan); */
-					break;
-			}
-		}
-	}
-
-	if (chan->fax->direction == ISDN_TTY_FAX_CONN_IN) {
-		idi_parse_edata(ccard, chan, buffer, len);
-
-		if ((chan->fax->code == EDATA_T30_DCS) &&
-		    (chan->fax->phase == ISDN_FAX_PHASE_A)) {
-			idi_reset_fax_stat(chan);
-
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_BCONN;
-			cmd.arg = chan->No;
-			strcpy(cmd.parm.num, "");
-			ccard->interface.statcallb(&cmd);
-
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_FAXIND;
-			cmd.arg = chan->No;
-			chan->fax->r_code = ISDN_TTY_FAX_FCON_I;
-			ccard->interface.statcallb(&cmd);
-		} else
-		if ((chan->fax->code == EDATA_T30_TRAIN_OK) &&
-		    (chan->fax->phase == ISDN_FAX_PHASE_A)) {
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_FAXIND;
-			cmd.arg = chan->No;
-			chan->fax->r_code = ISDN_TTY_FAX_RID;
-			ccard->interface.statcallb(&cmd);
-
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_FAXIND;
-			cmd.arg = chan->No;
-			chan->fax->r_code = ISDN_TTY_FAX_TRAIN_OK;
-			ccard->interface.statcallb(&cmd);
-		} else
-		if ((chan->fax->code == EDATA_T30_TRAIN_OK) &&
-		    (chan->fax->phase == ISDN_FAX_PHASE_B)) {
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_FAXIND;
-			cmd.arg = chan->No;
-			chan->fax->r_code = ISDN_TTY_FAX_TRAIN_OK;
-			ccard->interface.statcallb(&cmd);
-		} else
-		if (chan->fax->phase == ISDN_FAX_PHASE_C) {
-			switch(chan->fax->code) {
-				case EDATA_T30_TRAIN_OK:
-					idi_send_edata(ccard, chan);
-					break;
-				case EDATA_T30_MPS:
-					chan->fax->fet = 0;
-					idi_edata_rcveop(ccard, chan);
-					break;
-				case EDATA_T30_EOM:
-					chan->fax->fet = 1;
-					idi_edata_rcveop(ccard, chan);
-					break;
-				case EDATA_T30_EOP:
-					chan->fax->fet = 2;
-					idi_edata_rcveop(ccard, chan);
-					break;
-			}
-		}
-	}
-}
-
-static void
-fax_put_rcv(eicon_card *ccard, eicon_chan *chan, u_char *Data, int len)
-{
-	struct sk_buff *skb;
-	
-        skb = alloc_skb(len + MAX_HEADER_LEN, GFP_ATOMIC);
-	if (!skb) {
-		eicon_log(ccard, 1, "idi_err: Ch%d: alloc_skb failed in fax_put_rcv()\n", chan->No);
-		return;
-	}
-	skb_reserve(skb, MAX_HEADER_LEN);
-	memcpy(skb_put(skb, len), Data, len);
-	ccard->interface.rcvcallb_skb(ccard->myid, chan->No, skb);
-}
-
-static void
-idi_faxdata_rcv(eicon_card *ccard, eicon_chan *chan, struct sk_buff *skb)
-{
-	eicon_OBJBUFFER InBuf;
-	eicon_OBJBUFFER LineBuf;
-	unsigned int Length = 0;
-	unsigned int aLength = 0;
-	unsigned int ObjectSize = 0;
-	unsigned int ObjHeadLen = 0;
-	unsigned int ObjDataLen = 0;
-	__u8 Recordtype;
-	__u8 PageHeaderLen;	
-	__u8 Event;
-	eicon_sff_pagehead *ob_page;
-
-	__u16 Cl2Eol = 0x8000;
-
-#	define EVENT_NONE	0
-#	define EVENT_NEEDDATA	1
-
-	if (!chan->fax) {
-		eicon_log(ccard, 1, "idi_fax: rcvdata with NULL fax struct, ERROR\n");
-		return;
-	}
-
-
-	
-	if (chan->fax->direction == ISDN_TTY_FAX_CONN_IN) {
-		InBuf.Data = skb->data;
-		InBuf.Size = skb->len;
-		InBuf.Len  = 0;
-		InBuf.Next = InBuf.Data;
-		LineBuf.Data = chan->fax2.abLine;
-		LineBuf.Size = sizeof(chan->fax2.abLine);
-		LineBuf.Len  = chan->fax2.LineLen;
-		LineBuf.Next = LineBuf.Data + LineBuf.Len;
-
-		Event = EVENT_NONE;
-		while (Event == EVENT_NONE) {
-			switch(chan->fax2.NextObject) {
-				case FAX_OBJECT_DOCU:
-						Length = LineBuf.Len + (InBuf.Size - InBuf.Len);
-						if (Length < sizeof(eicon_sff_dochead)) {
-							Event = EVENT_NEEDDATA;
-							break;
-						}
-						ObjectSize = sizeof(eicon_sff_dochead);
-						Length = ObjectSize;
-						if (LineBuf.Len < Length) {
-							Length -= LineBuf.Len;
-							LineBuf.Len = 0;
-							LineBuf.Next = LineBuf.Data;
-							InBuf.Len += Length;
-							InBuf.Next += Length;
-						} else {
-							LineBuf.Len -= Length;
-							LineBuf.Next = LineBuf.Data + LineBuf.Len;
-							memmove(LineBuf.Data, LineBuf.Data + Length, LineBuf.Len);
-						}
-						chan->fax2.PrevObject = FAX_OBJECT_DOCU;
-						chan->fax2.NextObject = FAX_OBJECT_PAGE;
-					break;
-
-				case FAX_OBJECT_PAGE:
-						Length = LineBuf.Len + (InBuf.Size - InBuf.Len);
-						if (Length < 2) {
-							Event = EVENT_NEEDDATA;
-							break;
-						}
-						if (LineBuf.Len == 0) {
-							*LineBuf.Next++ = *InBuf.Next++;
-							LineBuf.Len++;
-							InBuf.Len++;
-						}
-						if (LineBuf.Len == 1) {
-							*LineBuf.Next++ = *InBuf.Next++;
-							LineBuf.Len++;
-							InBuf.Len++;
-						}
-						PageHeaderLen = *(LineBuf.Data + 1);
-						ObjectSize = (PageHeaderLen == 0) ? 2 : sizeof(eicon_sff_pagehead);
-						if (Length < ObjectSize) {
-							Event = EVENT_NEEDDATA;
-							break;
-						}
-						Length = ObjectSize;
-						/* extract page dimensions */
-						if (LineBuf.Len < Length) {
-							aLength = Length - LineBuf.Len;
-							memcpy(LineBuf.Next, InBuf.Next, aLength);
-							LineBuf.Next += aLength;
-							InBuf.Next += aLength;
-							LineBuf.Len += aLength;
-							InBuf.Len += aLength;
-						}
-						if (Length > 2) {
-							ob_page = (eicon_sff_pagehead *)LineBuf.Data;
-							switch(ob_page->linelength) {
-								case 2048:
-									chan->fax->r_width = 1;
-									break;
-								case 2432:
-									chan->fax->r_width = 2;
-									break;
-								case 1216:
-									chan->fax->r_width = 3;
-									break;
-								case 864:
-									chan->fax->r_width = 4;
-									break;
-								case 1728:
-								default:
-									chan->fax->r_width = 0;
-							}
-							switch(ob_page->pagelength) {
-								case 1143:
-								case 2287:
-									chan->fax->r_length = 0;
-									break;
-								case 1401:
-								case 2802:
-									chan->fax->r_length = 1;
-									break;
-								default:
-									chan->fax->r_length = 2;
-							}
-							eicon_log(ccard, 128, "rSFF-Head: linelength = %d\n", ob_page->linelength);
-							eicon_log(ccard, 128, "rSFF-Head: pagelength = %d\n", ob_page->pagelength);
-						}
-						LineBuf.Len -= Length;
-						LineBuf.Next = LineBuf.Data + LineBuf.Len;
-						memmove(LineBuf.Data, LineBuf.Data + Length, LineBuf.Len);
-
-						chan->fax2.PrevObject = FAX_OBJECT_PAGE;
-						chan->fax2.NextObject = FAX_OBJECT_LINE;
-					break;
-
-				case FAX_OBJECT_LINE:
-						Length = LineBuf.Len + (InBuf.Size - InBuf.Len);
-						if (Length < 1) {
-							Event = EVENT_NEEDDATA;
-							break;
-						}
-						if (LineBuf.Len == 0) {
-							*LineBuf.Next++ = *InBuf.Next++;
-							LineBuf.Len++;
-							InBuf.Len++;
-						}
-						Recordtype = *LineBuf.Data;
-						if (Recordtype == 0) {
-							/* recordtype pixel row (2 byte length) */
-							ObjHeadLen = 3;
-							if (Length < ObjHeadLen) {
-								Event = EVENT_NEEDDATA;
-								break;
-							}
-							while (LineBuf.Len < ObjHeadLen) {
-								*LineBuf.Next++ = *InBuf.Next++;
-								LineBuf.Len++;
-								InBuf.Len++;
-							}
-							ObjDataLen = *((__u16*) (LineBuf.Data + 1));
-							ObjectSize = ObjHeadLen + ObjDataLen;
-							if (Length < ObjectSize) {
-								Event = EVENT_NEEDDATA;
-								break;
-							}
-						} else
-						if ((Recordtype >= 1) && (Recordtype <= 216)) {
-							/* recordtype pixel row (1 byte length) */
-							ObjHeadLen = 1;
-							ObjDataLen = Recordtype;
-							ObjectSize = ObjHeadLen + ObjDataLen;
-							if (Length < ObjectSize) {
-								Event = EVENT_NEEDDATA;
-								break;
-							}
-						} else
-						if ((Recordtype >= 217) && (Recordtype <= 253)) {
-							/* recordtype empty lines */
-							ObjHeadLen = 1;
-							ObjDataLen = 0;
-							ObjectSize = ObjHeadLen + ObjDataLen;
-							LineBuf.Len--;
-							LineBuf.Next = LineBuf.Data + LineBuf.Len;
-							memmove(LineBuf.Data, LineBuf.Data + 1, LineBuf.Len);
-							break;
-						} else
-						if (Recordtype == 254) {
-							/* recordtype page header */
-							chan->fax2.PrevObject = FAX_OBJECT_LINE;
-							chan->fax2.NextObject = FAX_OBJECT_PAGE;
-							break;
-						} else {
-							/* recordtype user information */
-							ObjHeadLen = 2;
-							if (Length < ObjHeadLen) {
-								Event = EVENT_NEEDDATA;
-								break;
-							}
-							while (LineBuf.Len < ObjHeadLen) {
-								*LineBuf.Next++ = *InBuf.Next++;
-								LineBuf.Len++;
-								InBuf.Len++;
-							}
-							ObjDataLen = *(LineBuf.Data + 1);
-							ObjectSize = ObjHeadLen + ObjDataLen;
-							if (ObjDataLen == 0) {
-								/* illegal line coding */
-								LineBuf.Len -= ObjHeadLen;
-								LineBuf.Next = LineBuf.Data + LineBuf.Len;
-								memmove(LineBuf.Data, LineBuf.Data + ObjHeadLen, LineBuf.Len);
-								break;
-							} else {
-								/* user information */
-								if (Length < ObjectSize) {
-									Event = EVENT_NEEDDATA;
-									break;
-								}
-								Length = ObjectSize;
-								if (LineBuf.Len < Length) {
-									Length -= LineBuf.Len;
-									LineBuf.Len = 0;
-									LineBuf.Next = LineBuf.Data;
-									InBuf.Len += Length;
-									InBuf.Next += Length;
-								} else {
-									LineBuf.Len -= Length;
-									LineBuf.Next = LineBuf.Data + LineBuf.Len;
-									memmove(LineBuf.Data, LineBuf.Data + Length, LineBuf.Len);
-								}
-							}
-							break;	
-						}
-						Length = ObjectSize;
-						if (LineBuf.Len > ObjHeadLen) {
-							fax_put_rcv(ccard, chan, LineBuf.Data + ObjHeadLen,
-									(LineBuf.Len - ObjHeadLen));
-						}
-						Length -= LineBuf.Len;
-						LineBuf.Len = 0;
-						LineBuf.Next = LineBuf.Data;
-						if (Length > 0) {
-							fax_put_rcv(ccard, chan, InBuf.Next, Length);
-							InBuf.Len += Length;
-							InBuf.Next += Length;
-						}
-						fax_put_rcv(ccard, chan, (__u8 *)&Cl2Eol, sizeof(Cl2Eol));
-					break;
-			} /* end of switch (chan->fax2.NextObject) */
-		} /* end of while (Event==EVENT_NONE) */
-		if (InBuf.Len < InBuf.Size) {
-			Length = InBuf.Size - InBuf.Len;
-			if ((LineBuf.Len + Length) > LineBuf.Size) {
-				eicon_log(ccard, 1, "idi_fax: Ch%d: %d bytes dropping, small buffer\n", chan->No,
-					Length);
-				} else {
-					memcpy(LineBuf.Next, InBuf.Next, Length);
-					LineBuf.Len += Length;
-				}
-		}
-		chan->fax2.LineLen = LineBuf.Len;
-	} else { /* CONN_OUT */
-		/* On CONN_OUT we do not need incoming data, drop it */
-		/* maybe later for polling */
-	}
-
-#	undef EVENT_NONE
-#	undef EVENT_NEEDDATA
-
-	return;
-}
-
-static int
-idi_fax_send_outbuf(eicon_card *ccard, eicon_chan *chan, eicon_OBJBUFFER *OutBuf)
-{
-	struct sk_buff *skb;
-
-	skb = alloc_skb(OutBuf->Len, GFP_ATOMIC);
-	if (!skb) {
-		eicon_log(ccard, 1, "idi_err: Ch%d: alloc_skb failed in fax_send_outbuf()\n", chan->No);
-		return(-1);
-	}
-	memcpy(skb_put(skb, OutBuf->Len), OutBuf->Data, OutBuf->Len);
-
-	OutBuf->Len = 0;
-	OutBuf->Next = OutBuf->Data;
-
-	return(idi_send_data(ccard, chan, 0, skb, 1, 0));
-}
-
-int
-idi_faxdata_send(eicon_card *ccard, eicon_chan *chan, struct sk_buff *skb)
-{
-	isdn_ctrl cmd;
-	eicon_OBJBUFFER InBuf;
-	__u8 InData;
-	__u8 InMask;
-	eicon_OBJBUFFER OutBuf;
-	eicon_OBJBUFFER LineBuf;
-	__u32 LineData;
-	unsigned int LineDataLen;
-	__u8 Byte;
-	__u8 Event;
-	int ret = 1;
-
-#	define EVENT_NONE	0
-#	define EVENT_EOD	1
-#	define EVENT_EOL 	2
-#	define EVENT_EOP 	3
-
-	if ((!ccard) || (!chan))
-		return -1;
-
-	if (!chan->fax) {
-		eicon_log(ccard, 1, "idi_fax: senddata with NULL fax struct, ERROR\n");
-		return -1;
-	}
-
-	if (chan->fax->direction == ISDN_TTY_FAX_CONN_IN) {
-		/* Simply ignore any data written in data mode when receiving a fax.    */
-		/* This is not completely correct because only XON's should come here.  */
-        	dev_kfree_skb(skb);
-		return 1;
-	}
-
-	if (chan->fax->phase != ISDN_FAX_PHASE_C) {
-        	dev_kfree_skb(skb);
-		return 1;
-	}
-
-        if (chan->queued + skb->len > 1200)
-                return 0;
-	if (chan->pqueued > 1)
-		return 0;
-
-	InBuf.Data = skb->data;
-	InBuf.Size = skb->len;
-	InBuf.Len  = 0;
-	InBuf.Next = InBuf.Data;
-	InData = 0;
-	InMask = 0;
-
-	LineBuf.Data = chan->fax2.abLine;
-	LineBuf.Size = sizeof(chan->fax2.abLine);
-	LineBuf.Len  = chan->fax2.LineLen;
-	LineBuf.Next = LineBuf.Data + LineBuf.Len;
-	LineData = chan->fax2.LineData;
-	LineDataLen = chan->fax2.LineDataLen;
-
-	OutBuf.Data = chan->fax2.abFrame;
-	OutBuf.Size = sizeof(chan->fax2.abFrame);
-	OutBuf.Len = 0;
-	OutBuf.Next = OutBuf.Data;
-
-	Event = EVENT_NONE;
-
-	chan->fax2.Eop = 0;
-
-	for (;;) {
-	  for (;;) {
-		if (InMask == 0) {
-			if (InBuf.Len >= InBuf.Size) {
-				Event = EVENT_EOD;
-				break;
-			}
-			if ((chan->fax2.Dle != _DLE_) && *InBuf.Next == _DLE_) {
-				chan->fax2.Dle = _DLE_;
-				InBuf.Next++;
-				InBuf.Len++;
-				if (InBuf.Len >= InBuf.Size) {
-					Event = EVENT_EOD;
-					break;
-				}
-			}
-			if (chan->fax2.Dle == _DLE_) {
-				chan->fax2.Dle = 0;
-				if (*InBuf.Next == _ETX_) {
-					Event = EVENT_EOP;
-					break;
-				} else
-				if (*InBuf.Next == _DLE_) {
-					/* do nothing */
-				} else {
-					eicon_log(ccard, 1,
-						"idi_err: Ch%d: unknown DLE escape %02x found\n",
-							chan->No, *InBuf.Next);
-					InBuf.Next++;
-					InBuf.Len++;
-					if (InBuf.Len >= InBuf.Size) {
-						Event = EVENT_EOD;
-						break;
-					}
-				}
-			}
-			InBuf.Len++;
-			InData = *InBuf.Next++;
-			InMask = (chan->fax->bor) ? 0x80 : 0x01;
-		}
-		while (InMask) {
-			LineData >>= 1;
-			LineDataLen++;
-			if (InData & InMask)
-				LineData |= 0x80000000;
-			if (chan->fax->bor)
-				InMask >>= 1;
-			else
-				InMask <<= 1;
-
-			if ((LineDataLen >= T4_EOL_BITSIZE) &&
-			   ((LineData & T4_EOL_MASK_DWORD) == T4_EOL_DWORD)) {
-				Event = EVENT_EOL;
-				if (LineDataLen > T4_EOL_BITSIZE) {
-					Byte = (__u8)
-						((LineData & ~T4_EOL_MASK_DWORD) >>
-						(32 - LineDataLen));
-					if (Byte == 0) {
-						if (! chan->fax2.NullByteExist) {
-							chan->fax2.NullBytesPos = LineBuf.Len;
-							chan->fax2.NullByteExist = 1;
-						}
-					} else {
-						chan->fax2.NullByteExist = 0;
-					}
-					if (LineBuf.Len < LineBuf.Size) {
-						*LineBuf.Next++  = Byte;
-						LineBuf.Len++;
-					}
-				}
-				LineDataLen = 0;
-				break;
-			}
-			if (LineDataLen >= T4_EOL_BITSIZE + 8) {
-				Byte = (__u8)
-					((LineData & ~T4_EOL_MASK_DWORD) >>
-					(32 - T4_EOL_BITSIZE - 8));
-				LineData &= T4_EOL_MASK_DWORD;
-				LineDataLen = T4_EOL_BITSIZE;
-				if (Byte == 0) {
-					if (! chan->fax2.NullByteExist) {
-						chan->fax2.NullBytesPos = LineBuf.Len;
-						chan->fax2.NullByteExist = 1;
-					}
-				} else {
-					chan->fax2.NullByteExist = 0;
-				}
-				if (LineBuf.Len < LineBuf.Size) {
-					*LineBuf.Next++  = Byte; 
-					LineBuf.Len++;
-				}
-			}
-		}
-		if (Event != EVENT_NONE)
-			break;
-	  }
-
-		if ((Event != EVENT_EOL) && (Event != EVENT_EOP))
-			break;
-
-		if ((Event == EVENT_EOP) && (LineDataLen > 0)) {
-			LineData >>= 32 - LineDataLen;
-			LineDataLen = 0;
-			while (LineData != 0) {
-				Byte = (__u8) LineData;
-				LineData >>= 8;
-				if (Byte == 0) {
-					if (! chan->fax2.NullByteExist) {
-						chan->fax2.NullBytesPos = LineBuf.Len;
-						chan->fax2.NullByteExist = 1;
-					}
-				} else {
-					chan->fax2.NullByteExist = 0;
-				}
-				if (LineBuf.Len < LineBuf.Size) {
-					*LineBuf.Next++  = Byte;
-					LineBuf.Len++;
-				}
-				
-			}
-		}
-		if (chan->fax2.NullByteExist) {
-			if (chan->fax2.NullBytesPos == 0) {
-				LineBuf.Len = 0;
-			} else {
-				LineBuf.Len = chan->fax2.NullBytesPos + 1;
-			}
-		}
-		if (LineBuf.Len > 0) {
-			if (OutBuf.Len + LineBuf.Len + SFF_LEN_FLD_SIZE > OutBuf.Size) {
-				ret = idi_fax_send_outbuf(ccard, chan, &OutBuf);
-			}
-			if (LineBuf.Len <= 216) {
-				*OutBuf.Next++ = (__u8) LineBuf.Len;
-				OutBuf.Len++;
-			} else {
-				*OutBuf.Next++ = 0;
-				*((__u16 *) OutBuf.Next)++ = (__u16) LineBuf.Len;
-				OutBuf.Len += 3;
-			}
-			memcpy(OutBuf.Next, LineBuf.Data, LineBuf.Len);
-			OutBuf.Next += LineBuf.Len;
-			OutBuf.Len  += LineBuf.Len;
-		}
-		LineBuf.Len = 0;
-		LineBuf.Next = LineBuf.Data;
-		chan->fax2.NullByteExist = 0;
-		if (Event == EVENT_EOP)
-			break;
-
-		Event = EVENT_NONE;
-	}
-
-	if (Event == EVENT_EOP) {
-		chan->fax2.Eop = 1;
-		chan->fax2.PageCount++;
-		cmd.driver = ccard->myid;
-		cmd.command = ISDN_STAT_FAXIND;
-		cmd.arg = chan->No;
-		chan->fax->r_code = ISDN_TTY_FAX_EOP;
-		ccard->interface.statcallb(&cmd);
-	}
-	if (OutBuf.Len > 0) {
-		ret = idi_fax_send_outbuf(ccard, chan, &OutBuf);
-	}
-
-	chan->fax2.LineLen = LineBuf.Len;
-	chan->fax2.LineData = LineData;
-	chan->fax2.LineDataLen = LineDataLen;
-
-#	undef EVENT_NONE
-#	undef EVENT_EOD
-#	undef EVENT_EOL
-#	undef EVENT_EOP
-
-	if (ret >= 0)
-	        dev_kfree_skb(skb);
-	if (ret == 0)
-		ret = 1;
-	return(ret);
-}
-
-static void
-idi_fax_hangup(eicon_card *ccard, eicon_chan *chan)
-{
-	isdn_ctrl cmd;
-
-	if (!chan->fax) {
-		eicon_log(ccard, 1, "idi_fax: hangup with NULL fax struct, ERROR\n");
-		return;
-	}
-	if ((chan->fax->direction == ISDN_TTY_FAX_CONN_OUT) &&
-	    (chan->fax->code == 0)) {
-		cmd.driver = ccard->myid;
-		cmd.command = ISDN_STAT_FAXIND;
-		cmd.arg = chan->No;
-		chan->fax->r_code = ISDN_TTY_FAX_PTS;
-		ccard->interface.statcallb(&cmd);
-	}
-	if ((chan->fax->code > 1) && (chan->fax->code < 120))
-		chan->fax->code += 120;
-	eicon_log(ccard, 8, "idi_fax: Ch%d: Hangup (code=%d)\n", chan->No, chan->fax->code);
-	chan->fax->r_code = ISDN_TTY_FAX_HNG;
-	cmd.driver = ccard->myid;
-	cmd.command = ISDN_STAT_FAXIND;
-	cmd.arg = chan->No;
-	ccard->interface.statcallb(&cmd);
-}
-
-#endif	/******** FAX ********/
-
-static int
-idi_send_udata(eicon_card *card, eicon_chan *chan, int UReq, u_char *buffer, int len)
-{
-	struct sk_buff *skb;
-	struct sk_buff *skb2;
-	eicon_REQ *reqbuf;
-	eicon_chan_ptr *chan2;
-
-	if ((chan->fsm_state == EICON_STATE_NULL) || (chan->fsm_state == EICON_STATE_LISTEN)) {
-		eicon_log(card, 1, "idi_snd: Ch%d: send udata on state %d !\n", chan->No, chan->fsm_state);
-		return -ENODEV;
-	}
-	eicon_log(card, 8, "idi_snd: Ch%d: udata 0x%x: %d %d %d %d\n", chan->No,
-			UReq, buffer[0], buffer[1], buffer[2], buffer[3]);
-
-	skb = alloc_skb(sizeof(eicon_REQ) + len + 1, GFP_ATOMIC);
-	skb2 = alloc_skb(sizeof(eicon_chan_ptr), GFP_ATOMIC);
-
-	if ((!skb) || (!skb2)) {
-		eicon_log(card, 1, "idi_err: Ch%d: alloc_skb failed in send_udata()\n", chan->No);
-		if (skb) 
-			dev_kfree_skb(skb);
-		if (skb2) 
-			dev_kfree_skb(skb2);
-		return -ENOMEM;
-	}
-
-	chan2 = (eicon_chan_ptr *)skb_put(skb2, sizeof(eicon_chan_ptr));
-	chan2->ptr = chan;
-
-	reqbuf = (eicon_REQ *)skb_put(skb, 1 + len + sizeof(eicon_REQ));
-
-	reqbuf->Req = N_UDATA;
-	reqbuf->ReqCh = chan->e.IndCh;
-	reqbuf->ReqId = 1;
-
-	reqbuf->XBuffer.length = len + 1;
-	reqbuf->XBuffer.P[0] = UReq;
-	memcpy(&reqbuf->XBuffer.P[1], buffer, len);
-	reqbuf->Reference = 1; /* Net Entity */
-
-	skb_queue_tail(&chan->e.X, skb);
-	skb_queue_tail(&card->sndq, skb2);
-	eicon_tx_request(card);
-	return (0);
-}
-
-void
-idi_audio_cmd(eicon_card *ccard, eicon_chan *chan, int cmd, u_char *value)
-{
-	u_char buf[6];
-	struct enable_dtmf_s *dtmf_buf = (struct enable_dtmf_s *)buf;
-
-	if ((!ccard) || (!chan))
-		return;
-
-	memset(buf, 0, 6);
-	switch(cmd) {
-		case ISDN_AUDIO_SETDD:
-			if (value[0]) {
-				dtmf_buf->tone = (__u16) (value[1] * 5);
-				dtmf_buf->gap = (__u16) (value[1] * 5);
-				idi_send_udata(ccard, chan,
-					DSP_UDATA_REQUEST_ENABLE_DTMF_RECEIVER,
-					buf, 4);
-			} else {
-				idi_send_udata(ccard, chan,
-					DSP_UDATA_REQUEST_DISABLE_DTMF_RECEIVER,
-					buf, 0);
-			}
-			break;
-	}
-}
-
-static void
-idi_parse_udata(eicon_card *ccard, eicon_chan *chan, unsigned char *buffer, int len)
-{
-	isdn_ctrl cmd;
-	eicon_dsp_ind *p = (eicon_dsp_ind *) (&buffer[1]);
-        static char *connmsg[] =
-        {"", "V.21", "V.23", "V.22", "V.22bis", "V.32bis", "V.34",
-         "V.8", "Bell 212A", "Bell 103", "V.29 Leased", "V.33 Leased", "V.90",
-         "V.21 CH2", "V.27ter", "V.29", "V.33", "V.17", "V.32", "K56Flex",
-         "X2", "V.18", "V.18LH", "V.18HL", "V.21LH", "V.21HL",
-         "Bell 103LH", "Bell 103HL", "V.23", "V.23", "EDT 110",
-         "Baudot45", "Baudot47", "Baudot50", "DTMF" };
-	static u_char dtmf_code[] = {
-	'1','4','7','*','2','5','8','0','3','6','9','#','A','B','C','D'
-	};
-
-	if ((!ccard) || (!chan))
-		return;
-
-	switch (buffer[0]) {
-		case DSP_UDATA_INDICATION_SYNC:
-			eicon_log(ccard, 16, "idi_ind: Ch%d: UDATA_SYNC time %d\n", chan->No, p->time);
-			break;
-		case DSP_UDATA_INDICATION_DCD_OFF:
-			eicon_log(ccard, 8, "idi_ind: Ch%d: UDATA_DCD_OFF time %d\n", chan->No, p->time);
-			break;
-		case DSP_UDATA_INDICATION_DCD_ON:
-			if ((chan->l2prot == ISDN_PROTO_L2_MODEM) &&
-			   ((chan->fsm_state == EICON_STATE_IBWAIT) ||
-			    (chan->fsm_state == EICON_STATE_WMCONN))) {
-				chan->fsm_state = EICON_STATE_ACTIVE;
-				cmd.driver = ccard->myid;
-				cmd.command = ISDN_STAT_BCONN;
-				cmd.arg = chan->No;
-                                if (p->norm > 34) {
-                                  sprintf(cmd.parm.num, "%d/(%d)", p->speed, p->norm);
-                                } else {
-                                  sprintf(cmd.parm.num, "%d/%s", p->speed, connmsg[p->norm]);
-                                }
-				ccard->interface.statcallb(&cmd);
-			}
-			eicon_log(ccard, 8, "idi_ind: Ch%d: UDATA_DCD_ON time %d\n", chan->No, p->time);
-			eicon_log(ccard, 8, "idi_ind: Ch%d: %d %d %d %d\n", chan->No,
-				p->norm, p->options, p->speed, p->delay); 
-			break;
-		case DSP_UDATA_INDICATION_CTS_OFF:
-			eicon_log(ccard, 8, "idi_ind: Ch%d: UDATA_CTS_OFF time %d\n", chan->No, p->time);
-			break;
-		case DSP_UDATA_INDICATION_CTS_ON:
-			eicon_log(ccard, 8, "idi_ind: Ch%d: UDATA_CTS_ON time %d\n", chan->No, p->time);
-			eicon_log(ccard, 8, "idi_ind: Ch%d: %d %d %d %d\n", chan->No,
-				p->norm, p->options, p->speed, p->delay); 
-			break;
-		case DSP_UDATA_INDICATION_DISCONNECT:
-			eicon_log(ccard, 8, "idi_ind: Ch%d: UDATA_DISCONNECT cause %d\n", chan->No, buffer[1]);
-			break;
-		case DSP_UDATA_INDICATION_DTMF_DIGITS_RECEIVED:
-			eicon_log(ccard, 8, "idi_ind: Ch%d: UDATA_DTMF_REC '%c'\n", chan->No,
-				dtmf_code[buffer[1]]);
-			cmd.driver = ccard->myid;
-			cmd.command = ISDN_STAT_AUDIO;
-			cmd.parm.num[0] = ISDN_AUDIO_DTMF;
-			cmd.parm.num[1] = dtmf_code[buffer[1]];
-			cmd.arg = chan->No;
-			ccard->interface.statcallb(&cmd);
-			break;
-		default:
-			eicon_log(ccard, 8, "idi_ind: Ch%d: UNHANDLED UDATA Indication 0x%02x\n", chan->No, buffer[0]);
-	}
-}
-
-static void
-eicon_parse_trace(eicon_card *ccard, unsigned char *buffer, int len)
-{
-	int i,j,n;
-	int buflen = len * 3 + 30;
-	char *p;
-	struct trace_s {
-		unsigned long time;
-		unsigned short size;
-		unsigned short code;
-		unsigned char data[1];
-	} *q;
-
-	if (!(p = kmalloc(buflen, GFP_ATOMIC))) {
-		eicon_log(ccard, 1, "idi_err: Ch??: could not allocate trace buffer\n");
-		return;
-	}
-	memset(p, 0, buflen);
-	q = (struct trace_s *)buffer;
-
-	if (DebugVar & 512) {
-		if ((q->code == 3) || (q->code == 4)) {
-			n = (short) *(q->data);
-			if (n) {
-				j = sprintf(p, "DTRC:");
-				for (i = 0; i < n; i++) {
-					j += sprintf(p + j, "%02x ", q->data[i+2]);
-				}
-				j += sprintf(p + j, "\n");
-			}
-		}
-	} else {
-		j = sprintf(p, "XLOG: %lx %04x %04x ",
-			q->time, q->size, q->code);
-
-		for (i = 0; i < q->size; i++) {
-			j += sprintf(p + j, "%02x ", q->data[i]);
-		}
-		j += sprintf(p + j, "\n");
-	}
-	if (strlen(p))
-		eicon_putstatus(ccard, p);
-	kfree(p);
-}
-
-void
-idi_handle_ind(eicon_card *ccard, struct sk_buff *skb)
-{
-	int tmp;
-	char tnum[64];
-	int dlev;
-	int free_buff;
-  eicon_IND *ind = (eicon_IND *)skb->data;
-	eicon_chan *chan;
-	idi_ind_message message;
-	isdn_ctrl cmd;
-
-	if (!ccard) {
-		eicon_log(ccard, 1, "idi_err: Ch??: null card in handle_ind\n");
-  		dev_kfree_skb(skb);
-		return;
-	}
-
-	if ((chan = ccard->IdTable[ind->IndId]) == NULL) {
-		eicon_log(ccard, 1, "idi_err: Ch??: null chan in handle_ind\n");
-  		dev_kfree_skb(skb);
-		return;
-	}
-	
-	if ((ind->Ind != 8) && (ind->Ind != 0xc))
-		dlev = 144;
-	else
-		dlev = 128;
-
-       	eicon_log(ccard, dlev, "idi_hdl: Ch%d: Ind=%x Id=%x Ch=%x MInd=%x MLen=%x Len=%x\n", chan->No,
-	        ind->Ind,ind->IndId,ind->IndCh,ind->MInd,ind->MLength,ind->RBuffer.length);
-
-	free_buff = 1;
-	/* Signal Layer */
-	if (chan->e.D3Id == ind->IndId) {
-		idi_IndParse(ccard, chan, &message, ind->RBuffer.P, ind->RBuffer.length);
-		switch(ind->Ind) {
-			case HANGUP:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Hangup\n", chan->No);
-		    skb_queue_purge(&chan->e.X);
-				chan->queued = 0;
-				chan->pqueued = 0;
-				chan->waitq = 0;
-				chan->waitpq = 0;
-				if (message.e_cau[0] & 0x7f) {
-					cmd.driver = ccard->myid;
-					cmd.arg = chan->No;
-					sprintf(cmd.parm.num,"E%02x%02x", 
-						chan->cause[0]&0x7f, message.e_cau[0]&0x7f); 
-					cmd.command = ISDN_STAT_CAUSE;
-					ccard->interface.statcallb(&cmd);
-				}
-				chan->cause[0] = 0; 
-				if ((chan->fsm_state == EICON_STATE_ACTIVE) ||
-				    ((chan->l2prot == ISDN_PROTO_L2_FAX) &&
-				    (chan->fsm_state == EICON_STATE_OBWAIT))) {
-					chan->fsm_state = EICON_STATE_NULL;
-				} else {
-					if (chan->e.B2Id)
-						idi_do_req(ccard, chan, REMOVE, 1);
-					chan->statectrl &= ~WAITING_FOR_HANGUP;
-					chan->statectrl &= ~IN_HOLD;
-					if (chan->statectrl & HAVE_CONN_REQ) {
-						eicon_log(ccard, 32, "idi_req: Ch%d: queueing delayed conn_req\n", chan->No);
-						chan->statectrl &= ~HAVE_CONN_REQ;
-						if ((chan->tskb1) && (chan->tskb2)) {
-							skb_queue_tail(&chan->e.X, chan->tskb1);
-							skb_queue_tail(&ccard->sndq, chan->tskb2); 
-						}
-						chan->tskb1 = NULL;
-						chan->tskb2 = NULL;
-					} else {
-						chan->fsm_state = EICON_STATE_NULL;
-						cmd.driver = ccard->myid;
-						cmd.arg = chan->No;
-						cmd.command = ISDN_STAT_DHUP;
-						ccard->interface.statcallb(&cmd);
-						eicon_idi_listen_req(ccard, chan);
-#ifdef CONFIG_ISDN_TTY_FAX
-						chan->fax = 0;
-#endif
-					}
-				}
-				break;
-			case INDICATE_IND:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Indicate_Ind\n", chan->No);
-				if (chan->fsm_state != EICON_STATE_LISTEN) {
-					eicon_log(ccard, 1, "idi_err: Ch%d: Incoming call on wrong state (%d).\n",
-						chan->No, chan->fsm_state);
-					idi_do_req(ccard, chan, HANGUP, 0);
-					break;
-				}
-				chan->fsm_state = EICON_STATE_ICALL;
-				idi_bc2si(message.bc, message.hlc, message.sin, &chan->si1, &chan->si2);
-				strcpy(chan->cpn, message.cpn + 1);
-				strcpy(chan->oad, message.oad);
-				strcpy(chan->dsa, message.dsa);
-				strcpy(chan->osa, message.osa);
-				chan->plan = message.plan;
-				chan->screen = message.screen;
-				try_stat_icall_again: 
-				cmd.driver = ccard->myid;
-				cmd.command = ISDN_STAT_ICALL;
-				cmd.arg = chan->No;
-				cmd.parm.setup.si1 = chan->si1;
-				cmd.parm.setup.si2 = chan->si2;
-				strcpy(tnum, chan->cpn);
-				if (strlen(chan->dsa)) {
-					strcat(tnum, ".");
-					strcat(tnum, chan->dsa);
-				}
-				tnum[ISDN_MSNLEN - 1] = 0;
-				strcpy(cmd.parm.setup.eazmsn, tnum);
-				strcpy(tnum, chan->oad);
-				if (strlen(chan->osa)) {
-					strcat(tnum, ".");
-					strcat(tnum, chan->osa);
-				}
-				tnum[ISDN_MSNLEN - 1] = 0;
-				strcpy(cmd.parm.setup.phone, tnum);
-				cmd.parm.setup.plan = chan->plan;
-				cmd.parm.setup.screen = chan->screen;
-				tmp = ccard->interface.statcallb(&cmd);
-				switch(tmp) {
-					case 0: /* no user responding */
-						idi_do_req(ccard, chan, HANGUP, 0);
-						chan->fsm_state = EICON_STATE_NULL;
-						break;
-					case 1: /* alert */
-						eicon_log(ccard, 8, "idi_req: Ch%d: Call Alert\n", chan->No);
-						if ((chan->fsm_state == EICON_STATE_ICALL) || (chan->fsm_state == EICON_STATE_ICALLW)) {
-							chan->fsm_state = EICON_STATE_ICALL;
-							idi_do_req(ccard, chan, CALL_ALERT, 0);
-						}
-						break;
-					case 2: /* reject */
-						eicon_log(ccard, 8, "idi_req: Ch%d: Call Reject\n", chan->No);
-						idi_do_req(ccard, chan, REJECT, 0);
-						break;
-					case 3: /* incomplete number */
-						eicon_log(ccard, 8, "idi_req: Ch%d: Incomplete Number\n", chan->No);
-						chan->fsm_state = EICON_STATE_ICALLW;
-						break;
-				}
-				break;
-			case INFO_IND:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Info_Ind\n", chan->No);
-				if ((chan->fsm_state == EICON_STATE_ICALLW) &&
-				    (message.cpn[0])) {
-					strcat(chan->cpn, message.cpn + 1);
-					goto try_stat_icall_again;
-				}
-				break;
-			case CALL_IND:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Call_Ind\n", chan->No);
-				if ((chan->fsm_state == EICON_STATE_ICALL) ||
-                                     (chan->fsm_state == EICON_STATE_WMCONN) ||
-                                     (chan->fsm_state == EICON_STATE_IWAIT)) {
-					chan->fsm_state = EICON_STATE_IBWAIT;
-					cmd.driver = ccard->myid;
-					cmd.command = ISDN_STAT_DCONN;
-					cmd.arg = chan->No;
-					ccard->interface.statcallb(&cmd);
-					switch(chan->l2prot) {
-						case ISDN_PROTO_L2_FAX:
-#ifdef CONFIG_ISDN_TTY_FAX
-							if (chan->fax)
-								chan->fax->phase = ISDN_FAX_PHASE_A;
-#endif
-							break;
-						case ISDN_PROTO_L2_MODEM:
-							/* do nothing, wait for connect */
-							break;
-						case ISDN_PROTO_L2_V11096:
-						case ISDN_PROTO_L2_V11019:
-						case ISDN_PROTO_L2_V11038:
-						case ISDN_PROTO_L2_TRANS:
-							idi_do_req(ccard, chan, N_CONNECT, 1);
-							break;
-						default:
-							/* On most incoming calls we use automatic connect */
-							/* idi_do_req(ccard, chan, N_CONNECT, 1); */
-							break;
-					}
-				} else {
-					if (chan->fsm_state != EICON_STATE_ACTIVE)
-						idi_hangup(ccard, chan);
-				}
-				break;
-			case CALL_CON:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Call_Con\n", chan->No);
-				if (chan->fsm_state == EICON_STATE_OCALL) {
-					/* check if old NetID has been removed */
-					if (chan->e.B2Id) {
-						eicon_log(ccard, 1, "idi_ind: Ch%d: old net_id %x still exist, removing.\n",
-							chan->No, chan->e.B2Id);
-						idi_do_req(ccard, chan, REMOVE, 1);
-					}
-#ifdef CONFIG_ISDN_TTY_FAX
-					if (chan->l2prot == ISDN_PROTO_L2_FAX) {
-						if (chan->fax) {
-							chan->fax->phase = ISDN_FAX_PHASE_A;
-						} else {
-							eicon_log(ccard, 1, "idi_ind: Call_Con with NULL fax struct, ERROR\n");
-							idi_hangup(ccard, chan);
-							break;
-						}
-					}
-#endif
-					chan->fsm_state = EICON_STATE_OBWAIT;
-					cmd.driver = ccard->myid;
-					cmd.command = ISDN_STAT_DCONN;
-					cmd.arg = chan->No;
-					ccard->interface.statcallb(&cmd);
-
-					idi_do_req(ccard, chan, ASSIGN, 1); 
-					idi_do_req(ccard, chan, N_CONNECT, 1);
-				} else
-					idi_hangup(ccard, chan);
-				break;
-			case AOC_IND:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Advice of Charge\n", chan->No);
-				break;
-			case CALL_HOLD_ACK:
-				chan->statectrl |= IN_HOLD;
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Call Hold Ack\n", chan->No);
-				break;
-			case SUSPEND_REJ:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Suspend Rejected\n", chan->No);
-				break;
-			case SUSPEND:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Suspend Ack\n", chan->No);
-				break;
-			case RESUME:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: Resume Ack\n", chan->No);
-				break;
-			default:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: UNHANDLED SigIndication 0x%02x\n", chan->No, ind->Ind);
-		}
-	}
-	/* Network Layer */
-	else if (chan->e.B2Id == ind->IndId) {
-
-		if (chan->No == ccard->nchannels) {
-			/* Management Indication */
-			if (ind->Ind == 0x04) { /* Trace_Ind */
-				eicon_parse_trace(ccard, ind->RBuffer.P, ind->RBuffer.length);
-			} else {
-				idi_IndParse(ccard, chan, &message, ind->RBuffer.P, ind->RBuffer.length);
-				chan->fsm_state = 1;
-			}
-		} 
-		else
-		switch(ind->Ind) {
-			case N_CONNECT_ACK:
-				eicon_log(ccard, 16, "idi_ind: Ch%d: N_Connect_Ack\n", chan->No);
-				if (chan->l2prot == ISDN_PROTO_L2_MODEM) {
-					chan->fsm_state = EICON_STATE_WMCONN;
-					break;
-				}
-				if (chan->l2prot == ISDN_PROTO_L2_FAX) {
-#ifdef CONFIG_ISDN_TTY_FAX
-					chan->fsm_state = EICON_STATE_ACTIVE;
-					idi_parse_edata(ccard, chan, ind->RBuffer.P, ind->RBuffer.length);
-					if (chan->fax) {
-						if (chan->fax->phase == ISDN_FAX_PHASE_B) {
-							idi_fax_send_header(ccard, chan, 2);
-							cmd.driver = ccard->myid;
-							cmd.command = ISDN_STAT_FAXIND;
-							cmd.arg = chan->No;
-							chan->fax->r_code = ISDN_TTY_FAX_DCS;
-							ccard->interface.statcallb(&cmd);
-						}
-					}
-					else {
-						eicon_log(ccard, 1, "idi_ind: N_Connect_Ack with NULL fax struct, ERROR\n");
-					}
-#endif
-					break;
-				}
-				chan->fsm_state = EICON_STATE_ACTIVE;
-				cmd.driver = ccard->myid;
-				cmd.command = ISDN_STAT_BCONN;
-				cmd.arg = chan->No;
-				strcpy(cmd.parm.num, "64000");
-				ccard->interface.statcallb(&cmd);
-				break; 
-			case N_CONNECT:
-				eicon_log(ccard, 16,"idi_ind: Ch%d: N_Connect\n", chan->No);
-				chan->e.IndCh = ind->IndCh;
-				if (chan->e.B2Id) idi_do_req(ccard, chan, N_CONNECT_ACK, 1);
-				if (chan->l2prot == ISDN_PROTO_L2_FAX) {
-					break;
-				}
-				if (chan->l2prot == ISDN_PROTO_L2_MODEM) {
-					chan->fsm_state = EICON_STATE_WMCONN;
-					break;
-				}
-				chan->fsm_state = EICON_STATE_ACTIVE;
-				cmd.driver = ccard->myid;
-				cmd.command = ISDN_STAT_BCONN;
-				cmd.arg = chan->No;
-				strcpy(cmd.parm.num, "64000");
-				ccard->interface.statcallb(&cmd);
-				break; 
-			case N_DISC:
-				eicon_log(ccard, 16, "idi_ind: Ch%d: N_Disc\n", chan->No);
-				if (chan->e.B2Id) {
-		      skb_queue_purge(&chan->e.X);
-					idi_do_req(ccard, chan, N_DISC_ACK, 1);
-					idi_do_req(ccard, chan, REMOVE, 1);
-				}
-#ifdef CONFIG_ISDN_TTY_FAX
-				if ((chan->l2prot == ISDN_PROTO_L2_FAX) && (chan->fax)){
-					idi_parse_edata(ccard, chan, ind->RBuffer.P, ind->RBuffer.length);
-					idi_fax_hangup(ccard, chan);
-				}
-#endif
-				chan->e.IndCh = 0;
-				chan->queued = 0;
-				chan->pqueued = 0;
-				chan->waitq = 0;
-				chan->waitpq = 0;
-				if (!(chan->statectrl & IN_HOLD)) {
-					idi_do_req(ccard, chan, HANGUP, 0);
-				}
-				if (chan->fsm_state == EICON_STATE_ACTIVE) {
-					cmd.driver = ccard->myid;
-					cmd.command = ISDN_STAT_BHUP;
-					cmd.arg = chan->No;
-					ccard->interface.statcallb(&cmd);
-					chan->fsm_state = EICON_STATE_NULL;
-					if (!(chan->statectrl & IN_HOLD)) {
-						chan->statectrl |= WAITING_FOR_HANGUP;
-					}
-				}
-#ifdef CONFIG_ISDN_TTY_FAX
-				chan->fax = 0;
-#endif
-				break; 
-			case N_DISC_ACK:
-				eicon_log(ccard, 16, "idi_ind: Ch%d: N_Disc_Ack\n", chan->No);
-#ifdef CONFIG_ISDN_TTY_FAX
-				if (chan->l2prot == ISDN_PROTO_L2_FAX) {
-					idi_parse_edata(ccard, chan, ind->RBuffer.P, ind->RBuffer.length);
-					idi_fax_hangup(ccard, chan);
-				}
-#endif
-				break; 
-			case N_DATA_ACK:
-				eicon_log(ccard, 128, "idi_ind: Ch%d: N_Data_Ack\n", chan->No);
-				break;
-			case N_DATA:
-				skb_pull(skb, sizeof(eicon_IND) - 1);
-				eicon_log(ccard, 128, "idi_rcv: Ch%d: %d bytes\n", chan->No, skb->len);
-				if (chan->l2prot == ISDN_PROTO_L2_FAX) {
-#ifdef CONFIG_ISDN_TTY_FAX
-					idi_faxdata_rcv(ccard, chan, skb);
-#endif
-				} else {
-					ccard->interface.rcvcallb_skb(ccard->myid, chan->No, skb);
-					free_buff = 0; 
-				}
-				break; 
-			case N_UDATA:
-				idi_parse_udata(ccard, chan, ind->RBuffer.P, ind->RBuffer.length);
-				break; 
-#ifdef CONFIG_ISDN_TTY_FAX
-			case N_EDATA:
-				idi_edata_action(ccard, chan, ind->RBuffer.P, ind->RBuffer.length);
-				break; 
-#endif
-			default:
-				eicon_log(ccard, 8, "idi_ind: Ch%d: UNHANDLED NetIndication 0x%02x\n", chan->No, ind->Ind);
-		}
-	}
-	else {
-		eicon_log(ccard, 1, "idi_ind: Ch%d: Ind is neither SIG nor NET !\n", chan->No);
-	}
-   if (free_buff)
-	dev_kfree_skb(skb);
-}
-
-static int
-idi_handle_ack_ok(eicon_card *ccard, eicon_chan *chan, eicon_RC *ack)
-{
-  isdn_ctrl cmd;
-  int tqueued = 0;
-  int twaitpq = 0;
-
-	if (ack->RcId != ((chan->e.ReqCh) ? chan->e.B2Id : chan->e.D3Id)) {
-		/* I don't know why this happens, should not ! */
-		/* just ignoring this RC */
-		eicon_log(ccard, 16, "idi_ack: Ch%d: RcId %d not equal to last %d\n", chan->No, 
-			ack->RcId, (chan->e.ReqCh) ? chan->e.B2Id : chan->e.D3Id);
-		return 1;
-	}
-
-	/* Management Interface */	
-	if (chan->No == ccard->nchannels) {
-		/* Managementinterface: changing state */
-		if (chan->e.Req != 0x02)
-			chan->fsm_state = 1;
-	}
-
-	/* Remove an Id */
-	if (chan->e.Req == REMOVE) {
-		if (ack->Reference != chan->e.ref) {
-			/* This should not happen anymore */
-			eicon_log(ccard, 16, "idi_ack: Ch%d: Rc-Ref %d not equal to stored %d\n", chan->No,
-				ack->Reference, chan->e.ref);
-		}
-		ccard->IdTable[ack->RcId] = NULL;
-		if (!chan->e.ReqCh) 
-			chan->e.D3Id = 0;
-		else
-			chan->e.B2Id = 0;
-		eicon_log(ccard, 16, "idi_ack: Ch%d: Removed : Id=%x Ch=%d (%s)\n", chan->No,
-			ack->RcId, ack->RcCh, (chan->e.ReqCh)? "Net":"Sig");
-		return 1;
-	}
-
-	/* Signal layer */
-	if (!chan->e.ReqCh) {
-		eicon_log(ccard, 16, "idi_ack: Ch%d: RC OK Id=%x Ch=%d (ref:%d)\n", chan->No,
-			ack->RcId, ack->RcCh, ack->Reference);
-	} else {
-	/* Network layer */
-		switch(chan->e.Req & 0x0f) {
-			case N_CONNECT:
-				chan->e.IndCh = ack->RcCh;
-				eicon_log(ccard, 16, "idi_ack: Ch%d: RC OK Id=%x Ch=%d (ref:%d)\n", chan->No,
-					ack->RcId, ack->RcCh, ack->Reference);
-				break;
-			case N_MDATA:
-			case N_DATA:
-				tqueued = chan->queued;
-				twaitpq = chan->waitpq;
-				if ((chan->e.Req & 0x0f) == N_DATA) {
-					chan->waitpq = 0;
-					if(chan->pqueued)
-						chan->pqueued--;
-#ifdef CONFIG_ISDN_TTY_FAX
-					if (chan->l2prot == ISDN_PROTO_L2_FAX) {
-						if (((chan->queued - chan->waitq) < 1) &&
-						    (chan->fax2.Eop)) {
-							chan->fax2.Eop = 0;
-							if (chan->fax) {
-								cmd.driver = ccard->myid;
-								cmd.command = ISDN_STAT_FAXIND;
-								cmd.arg = chan->No;
-								chan->fax->r_code = ISDN_TTY_FAX_SENT;
-								ccard->interface.statcallb(&cmd);
-							}
-							else {
-								eicon_log(ccard, 1, "idi_ack: Sent with NULL fax struct, ERROR\n");
-							}
-						}
-					}
-#endif
-				}
-				chan->queued -= chan->waitq;
-				if (chan->queued < 0) chan->queued = 0;
-				if (((chan->e.Req & 0x0f) == N_DATA) && (tqueued)) {
-					cmd.driver = ccard->myid;
-					cmd.command = ISDN_STAT_BSENT;
-					cmd.arg = chan->No;
-					cmd.parm.length = twaitpq;
-					ccard->interface.statcallb(&cmd);
-				}
-				break;
-			default:
-				eicon_log(ccard, 16, "idi_ack: Ch%d: RC OK Id=%x Ch=%d (ref:%d)\n", chan->No,
-					ack->RcId, ack->RcCh, ack->Reference);
-		}
-	}
-	return 1;
-}
-
-void
-idi_handle_ack(eicon_card *ccard, struct sk_buff *skb)
-{
-	int j;
-        eicon_RC *ack = (eicon_RC *)skb->data;
-	eicon_chan *chan;
-	isdn_ctrl cmd;
-	int dCh = -1;
-
-	if (!ccard) {
-		eicon_log(ccard, 1, "idi_err: Ch??: null card in handle_ack\n");
-		dev_kfree_skb(skb);
-		return;
-	}
-
-	if ((chan = ccard->IdTable[ack->RcId]) != NULL)
-		dCh = chan->No;
-
-	switch (ack->Rc) {
-		case OK_FC:
-		case N_FLOW_CONTROL:
-		case ASSIGN_RC:
-			eicon_log(ccard, 1, "idi_ack: Ch%d: unhandled RC 0x%x\n",
-				dCh, ack->Rc);
-			break;
-		case READY_INT:
-		case TIMER_INT:
-			/* we do nothing here */
-			break;
-
-		case OK:
-			if (!chan) {
-				eicon_log(ccard, 1, "idi_ack: Ch%d: OK on chan without Id\n", dCh);
-				break;
-			}
-			if (!idi_handle_ack_ok(ccard, chan, ack))
-				chan = NULL;
-			break;
-
-		case ASSIGN_OK:
-			if (chan) {
-				eicon_log(ccard, 1, "idi_ack: Ch%d: ASSIGN-OK on chan already assigned (%x,%x)\n",
-					chan->No, chan->e.D3Id, chan->e.B2Id);
-			}
-			for(j = 0; j < ccard->nchannels + 1; j++) {
-				if ((ccard->bch[j].e.ref == ack->Reference) &&
-					(ccard->bch[j].e.Req == ASSIGN)) {
-					if (!ccard->bch[j].e.ReqCh) 
-						ccard->bch[j].e.D3Id  = ack->RcId;
-					else
-						ccard->bch[j].e.B2Id  = ack->RcId;
-					ccard->IdTable[ack->RcId] = &ccard->bch[j];
-					chan = &ccard->bch[j];
-					break;
-				}
-			}
-			eicon_log(ccard, 16, "idi_ack: Ch%d: Id %x assigned (%s)\n", j, 
-				ack->RcId, (ccard->bch[j].e.ReqCh)? "Net":"Sig");
-			if (j > ccard->nchannels) {
-				eicon_log(ccard, 24, "idi_ack: Ch??: ref %d not found for Id %d\n", 
-					ack->Reference, ack->RcId);
-			}
-			break;
-
-		case OUT_OF_RESOURCES:
-		case UNKNOWN_COMMAND:
-		case WRONG_COMMAND:
-		case WRONG_ID:
-		case 0x08:  /* ADAPTER_DEAD */ 
-		case WRONG_CH:
-		case UNKNOWN_IE:
-		case WRONG_IE:
-		default:
-			if (!chan) {
-				eicon_log(ccard, 1, "idi_ack: Ch%d: Not OK !! on chan without Id\n", dCh);
-				break;
-			} else
-			switch (chan->e.Req) {
-				case 12:	/* Alert */
-					eicon_log(ccard, 2, "idi_err: Ch%d: Alert Not OK : Rc=%d Id=%x Ch=%d\n",
-						dCh, ack->Rc, ack->RcId, ack->RcCh);
-					break;
-				default:
-					if (dCh != ccard->nchannels)
-						eicon_log(ccard, 1, "idi_err: Ch%d: Ack Not OK !!: Rc=%d Id=%x Ch=%d Req=%d\n",
-							dCh, ack->Rc, ack->RcId, ack->RcCh, chan->e.Req);
-			}
-			if (dCh == ccard->nchannels) { /* Management */
-				chan->fsm_state = 2;
-				eicon_log(ccard, 8, "idi_err: Ch%d: Ack Not OK !!: Rc=%d Id=%x Ch=%d Req=%d\n",
-					dCh, ack->Rc, ack->RcId, ack->RcCh, chan->e.Req);
-			} else if (dCh >= 0) {
-					/* any other channel */
-					/* card reports error: we hangup */
-				idi_hangup(ccard, chan);
-				cmd.driver = ccard->myid;
-				cmd.command = ISDN_STAT_DHUP;
-				cmd.arg = chan->No;
-				ccard->interface.statcallb(&cmd);
-			}
-	}
-	if (chan) {
-		chan->e.ref = 0;
-		chan->e.busy = 0;
-	}
-	dev_kfree_skb(skb);
-}
-
-int
-idi_send_data(eicon_card *card, eicon_chan *chan, int ack, struct sk_buff *skb, int que, int chk)
-{
-        struct sk_buff *xmit_skb;
-        struct sk_buff *skb2;
-        eicon_REQ *reqbuf;
-        eicon_chan_ptr *chan2;
-        int len, plen = 0, offset = 0;
-
-	if ((!card) || (!chan)) {
-		eicon_log(card, 1, "idi_err: Ch??: null card/chan in send_data\n");
-		return -1;
-	}
-
-        if (chan->fsm_state != EICON_STATE_ACTIVE) {
-		eicon_log(card, 1, "idi_snd: Ch%d: send bytes on state %d !\n", chan->No, chan->fsm_state);
-                return -ENODEV;
-	}
-
-        len = skb->len;
-	if (len > EICON_MAX_QUEUE)	/* too much for the shared memory */
-		return -1;
-        if (!len)
-                return 0;
-
-	if ((chk) && (chan->pqueued > 1))
-		return 0;
-
-	eicon_log(card, 128, "idi_snd: Ch%d: %d bytes (Pqueue=%d)\n",
-		chan->No, len, chan->pqueued);
-	while(offset < len) {
-
-		plen = ((len - offset) > 270) ? 270 : len - offset;
-
-	        xmit_skb = alloc_skb(plen + sizeof(eicon_REQ), GFP_ATOMIC);
-        	skb2 = alloc_skb(sizeof(eicon_chan_ptr), GFP_ATOMIC);
-
-	        if ((!xmit_skb) || (!skb2)) {
-        	        eicon_log(card, 1, "idi_err: Ch%d: alloc_skb failed in send_data()\n", chan->No);
-			if (xmit_skb) 
-				dev_kfree_skb(skb);
-			if (skb2) 
-				dev_kfree_skb(skb2);
-                	return -ENOMEM;
-	        }
-
-	        chan2 = (eicon_chan_ptr *)skb_put(skb2, sizeof(eicon_chan_ptr));
-        	chan2->ptr = chan;
-
-	        reqbuf = (eicon_REQ *)skb_put(xmit_skb, plen + sizeof(eicon_REQ));
-		if ((len - offset) > 270) {
-		        reqbuf->Req = N_MDATA;
-		} else {
-		        reqbuf->Req = N_DATA;
-			/* if (ack) reqbuf->Req |= N_D_BIT; */
-		}	
-        	reqbuf->ReqCh = chan->e.IndCh;
-	        reqbuf->ReqId = 1;
-		memcpy(&reqbuf->XBuffer.P, skb->data + offset, plen);
-		reqbuf->XBuffer.length = plen;
-		reqbuf->Reference = 1; /* Net Entity */
-
-		skb_queue_tail(&chan->e.X, xmit_skb);
-		skb_queue_tail(&card->sndq, skb2); 
-
-		offset += plen;
-	}
-	if (que) {
-		chan->queued += len;
-		chan->pqueued++;
-	}
-	eicon_tx_request(card);
-        dev_kfree_skb(skb);
-        return len;
-}
-
-
-static int
-eicon_idi_manage_assign(eicon_card *card)
-{
-        struct sk_buff *skb;
-        struct sk_buff *skb2;
-        eicon_REQ  *reqbuf;
-        eicon_chan     *chan;
-        eicon_chan_ptr *chan2;
-
-        chan = &(card->bch[card->nchannels]);
-
-        skb = alloc_skb(270 + sizeof(eicon_REQ), GFP_ATOMIC);
-        skb2 = alloc_skb(sizeof(eicon_chan_ptr), GFP_ATOMIC);
-
-        if ((!skb) || (!skb2)) {
-		eicon_log(card, 1, "idi_err: alloc_skb failed in manage_assign()\n");
-		if (skb) 
-			dev_kfree_skb(skb);
-		if (skb2) 
-			dev_kfree_skb(skb2);
-                return -ENOMEM;
-        }
-
-        chan2 = (eicon_chan_ptr *)skb_put(skb2, sizeof(eicon_chan_ptr));
-        chan2->ptr = chan;
-
-        reqbuf = (eicon_REQ *)skb_put(skb, 270 + sizeof(eicon_REQ));
-
-        reqbuf->XBuffer.P[0] = 0;
-        reqbuf->Req = ASSIGN;
-        reqbuf->ReqCh = 0;
-        reqbuf->ReqId = MAN_ID;
-        reqbuf->XBuffer.length = 1;
-        reqbuf->Reference = 2; /* Man Entity */
-
-        skb_queue_tail(&chan->e.X, skb);
-        skb_queue_tail(&card->sndq, skb2);
-        eicon_tx_request(card);
-        return(0);
-}
-
-int
-eicon_idi_manage(eicon_card *card, eicon_manifbuf *mb)
-{
-	int l = 0;
-	int ret = 0;
-	int timeout;
-	int i;
-        struct sk_buff *skb;
-        struct sk_buff *skb2;
-        eicon_REQ  *reqbuf;
-        eicon_chan     *chan;
-        eicon_chan_ptr *chan2;
-
-        chan = &(card->bch[card->nchannels]);
-
-	if (!(chan->e.D3Id)) {
-		chan->e.D3Id = 1;
-		skb_queue_purge(&chan->e.X);
-		chan->e.busy = 0;
- 
-		if ((ret = eicon_idi_manage_assign(card))) {
-			chan->e.D3Id = 0;
-			return(ret); 
-		}
-
-	        timeout = jiffies + 50;
-        	while (time_before(jiffies, timeout)) {
-	                if (chan->e.B2Id) break;
-        	        SLEEP(10);
-	        }
-	        if (!chan->e.B2Id) {
-			chan->e.D3Id = 0;
-			return -EIO;
-		}
-	}
-
-	chan->fsm_state = 0;
-
-	if (!(manbuf = kmalloc(sizeof(eicon_manifbuf), GFP_KERNEL))) {
-               	eicon_log(card, 1, "idi_err: alloc_manifbuf failed\n");
-		return -ENOMEM;
-	}
-	if (copy_from_user(manbuf, mb, sizeof(eicon_manifbuf))) {
-		kfree(manbuf);
-		return -EFAULT;
-	}
-
-        skb = alloc_skb(270 + sizeof(eicon_REQ), GFP_ATOMIC);
-        skb2 = alloc_skb(sizeof(eicon_chan_ptr), GFP_ATOMIC);
-
-        if ((!skb) || (!skb2)) {
-               	eicon_log(card, 1, "idi_err_manif: alloc_skb failed in manage()\n");
-		if (skb) 
-			dev_kfree_skb(skb);
-		if (skb2) 
-			dev_kfree_skb(skb2);
-		kfree(manbuf);
-                return -ENOMEM;
-        }
-
-        chan2 = (eicon_chan_ptr *)skb_put(skb2, sizeof(eicon_chan_ptr));
-        chan2->ptr = chan;
-
-        reqbuf = (eicon_REQ *)skb_put(skb, 270 + sizeof(eicon_REQ));
-
-        reqbuf->XBuffer.P[l++] = ESC;
-        reqbuf->XBuffer.P[l++] = 6;
-        reqbuf->XBuffer.P[l++] = 0x80;
-	for (i = 0; i < manbuf->length[0]; i++)
-	        reqbuf->XBuffer.P[l++] = manbuf->data[i];
-        reqbuf->XBuffer.P[1] = manbuf->length[0] + 1;
-
-        reqbuf->XBuffer.P[l++] = 0;
-        reqbuf->Req = (manbuf->count) ? manbuf->count : MAN_READ;
-        reqbuf->ReqCh = 0;
-        reqbuf->ReqId = 1;
-        reqbuf->XBuffer.length = l;
-        reqbuf->Reference = 2; /* Man Entity */
-
-        skb_queue_tail(&chan->e.X, skb);
-        skb_queue_tail(&card->sndq, skb2);
-
-	manbuf->count = 0;
-	manbuf->pos = 0;
-
-        eicon_tx_request(card);
-
-        timeout = jiffies + 50;
-        while (time_before(jiffies, timeout)) {
-                if (chan->fsm_state) break;
-                SLEEP(10);
-        }
-        if ((!chan->fsm_state) || (chan->fsm_state == 2)) {
-		kfree(manbuf);
-		return -EIO;
-	}
-	if (copy_to_user(mb, manbuf, sizeof(eicon_manifbuf))) {
-		kfree(manbuf);
-		return -EFAULT;
-	}
-
-	kfree(manbuf);
-  return(0);
-}
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/i4l_idi.h linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/i4l_idi.h
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/i4l_idi.h	2002-10-11 03:09:02.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/i4l_idi.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,381 +0,0 @@
-/* $Id: i4l_idi.h,v 1.1.2.2 2002/10/02 14:38:37 armin Exp $
- *
- * ISDN interface module for Eicon active cards.
- * I4L - IDI Interface
- *
- * Copyright 1998-2000  by Armin Schindler (mac@melware.de)
- * Copyright 1999-2002  Cytronics & Melware (info@melware.de)
- *
- * This software may be used and distributed according to the terms
- * of the GNU General Public License, incorporated herein by reference.
- */
-
-#ifndef E_IDI_H
-#define E_IDI_H
-
-#include <linux/config.h>
-
-#undef N_DATA
-#undef ID_MASK
-
-#include "pc.h"
-
-#define AOC_IND  26		/* Advice of Charge                         */
-#define PI  0x1e                /* Progress Indicator               */
-#define NI  0x27                /* Notification Indicator           */
-
-/* defines for statectrl */
-#define WAITING_FOR_HANGUP	0x01
-#define HAVE_CONN_REQ		0x02
-#define IN_HOLD			0x04
-
-typedef struct {
-	char cpn[32];
-	char oad[32];
-	char dsa[32];
-	char osa[32];
-	__u8 plan;
-	__u8 screen;
-	__u8 sin[4];
-	__u8 chi[4];
-	__u8 e_chi[4];
-	__u8 bc[12];
-	__u8 e_bc[12];
- 	__u8 llc[18];
-	__u8 hlc[5];
-	__u8 cau[4];
-	__u8 e_cau[2];
-	__u8 e_mt;
-	__u8 dt[6];
-	char display[83];
-	char keypad[35];
-	char rdn[32];
-} idi_ind_message;
-
-typedef struct { 
-  __u16 next            __attribute__ ((packed));
-  __u8  Req             __attribute__ ((packed));
-  __u8  ReqId           __attribute__ ((packed));
-  __u8  ReqCh           __attribute__ ((packed));
-  __u8  Reserved1       __attribute__ ((packed));
-  __u16 Reference       __attribute__ ((packed));
-  __u8  Reserved[8]     __attribute__ ((packed));
-  eicon_PBUFFER XBuffer; 
-} eicon_REQ;
-
-typedef struct {
-  __u16 next            __attribute__ ((packed));
-  __u8  Rc              __attribute__ ((packed));
-  __u8  RcId            __attribute__ ((packed));
-  __u8  RcCh            __attribute__ ((packed));
-  __u8  Reserved1       __attribute__ ((packed));
-  __u16 Reference       __attribute__ ((packed));
-  __u8  Reserved2[8]    __attribute__ ((packed));
-} eicon_RC;
-
-typedef struct {
-  __u16 next            __attribute__ ((packed));
-  __u8  Ind             __attribute__ ((packed));
-  __u8  IndId           __attribute__ ((packed));
-  __u8  IndCh           __attribute__ ((packed));
-  __u8  MInd            __attribute__ ((packed));
-  __u16 MLength         __attribute__ ((packed));
-  __u16 Reference       __attribute__ ((packed));
-  __u8  RNR             __attribute__ ((packed));
-  __u8  Reserved        __attribute__ ((packed));
-  __u32 Ack             __attribute__ ((packed));
-  eicon_PBUFFER RBuffer;
-} eicon_IND;
-
-typedef struct {
-	__u8		*Data;
-	unsigned int	Size;
-	unsigned int	Len;
-	__u8		*Next;
-} eicon_OBJBUFFER;
-
-extern int idi_do_req(eicon_card *card, eicon_chan *chan, int cmd, int layer);
-extern int idi_hangup(eicon_card *card, eicon_chan *chan);
-extern int idi_connect_res(eicon_card *card, eicon_chan *chan);
-extern int eicon_idi_listen_req(eicon_card *card, eicon_chan *chan);
-extern int idi_connect_req(eicon_card *card, eicon_chan *chan, char *phone,
-	                    char *eazmsn, int si1, int si2);
-
-extern void idi_handle_ack(eicon_card *card, struct sk_buff *skb);
-extern void idi_handle_ind(eicon_card *card, struct sk_buff *skb);
-extern int eicon_idi_manage(eicon_card *card, eicon_manifbuf *mb);
-extern int idi_send_data(eicon_card *card, eicon_chan *chan, int ack, struct sk_buff *skb, int que, int chk);
-extern void idi_audio_cmd(eicon_card *ccard, eicon_chan *chan, int cmd, u_char *value);
-extern int capipmsg(eicon_card *card, eicon_chan *chan, capi_msg *cm);
-#ifdef CONFIG_ISDN_TTY_FAX
-extern void idi_fax_cmd(eicon_card *card, eicon_chan *chan);
-extern int idi_faxdata_send(eicon_card *ccard, eicon_chan *chan, struct sk_buff *skb);
-#endif
-
-#include "dsp_defs.h"
-
-#define DSP_UDATA_REQUEST_SWITCH_FRAMER         1
-/*
-parameters:
-  <byte> transmit framer type
-  <byte> receive framer type
-*/
-
-#define DSP_REQUEST_SWITCH_FRAMER_HDLC          0
-#define DSP_REQUEST_SWITCH_FRAMER_TRANSPARENT   1
-#define DSP_REQUEST_SWITCH_FRAMER_ASYNC         2
-
-
-#define DSP_UDATA_REQUEST_CLEARDOWN             2
-/*
-parameters:
-  - none -
-*/
-
-
-#define DSP_UDATA_REQUEST_TX_CONFIRMATION_ON    3
-/*
-parameters:
-  - none -
-*/
-
-
-#define DSP_UDATA_REQUEST_TX_CONFIRMATION_OFF   4
-/*
-parameters:
-  - none -
-*/
-
-typedef struct eicon_dsp_ind {
-	__u16	time		__attribute__ ((packed));
-	__u8	norm		__attribute__ ((packed));
-	__u16	options		__attribute__ ((packed));
-	__u32	speed		__attribute__ ((packed));
-	__u16	delay		__attribute__ ((packed));
-	__u32	txspeed		__attribute__ ((packed));
-	__u32	rxspeed		__attribute__ ((packed));
-} eicon_dsp_ind;
-
-#define DSP_CONNECTED_OPTION_V42_TRANS           0x0002
-#define DSP_CONNECTED_OPTION_V42_LAPM            0x0004
-#define DSP_CONNECTED_OPTION_SHORT_TRAIN         0x0008
-#define DSP_CONNECTED_OPTION_TALKER_ECHO_PROTECT 0x0010
-
-#define DSP_UDATA_INDICATION_DISCONNECT         5
-/*
-returns:
-  <byte> cause
-*/
-
-#define DSP_DISCONNECT_CAUSE_NONE               0x00
-#define DSP_DISCONNECT_CAUSE_BUSY_TONE          0x01
-#define DSP_DISCONNECT_CAUSE_CONGESTION_TONE    0x02
-#define DSP_DISCONNECT_CAUSE_INCOMPATIBILITY    0x03
-#define DSP_DISCONNECT_CAUSE_CLEARDOWN          0x04
-#define DSP_DISCONNECT_CAUSE_TRAINING_TIMEOUT   0x05
-
-#define DSP_UDATA_INDICATION_TX_CONFIRMATION    6
-/*
-returns:
-  <word> confirmation number
-*/
-
-
-#define DSP_UDATA_REQUEST_SEND_DTMF_DIGITS      16
-/*
-parameters:
-  <word> tone duration (ms)
-  <word> gap duration (ms)
-  <byte> digit 0 tone code
-  ...
-  <byte> digit n tone code
-*/
-
-#define DSP_SEND_DTMF_DIGITS_HEADER_LENGTH      5
-
-#define DSP_DTMF_DIGIT_TONE_LOW_GROUP_697_HZ    0x00
-#define DSP_DTMF_DIGIT_TONE_LOW_GROUP_770_HZ    0x01
-#define DSP_DTMF_DIGIT_TONE_LOW_GROUP_852_HZ    0x02
-#define DSP_DTMF_DIGIT_TONE_LOW_GROUP_941_HZ    0x03
-#define DSP_DTMF_DIGIT_TONE_LOW_GROUP_MASK      0x03
-#define DSP_DTMF_DIGIT_TONE_HIGH_GROUP_1209_HZ  0x00
-#define DSP_DTMF_DIGIT_TONE_HIGH_GROUP_1336_HZ  0x04
-#define DSP_DTMF_DIGIT_TONE_HIGH_GROUP_1477_HZ  0x08
-#define DSP_DTMF_DIGIT_TONE_HIGH_GROUP_1633_HZ  0x0c
-#define DSP_DTMF_DIGIT_TONE_HIGH_GROUP_MASK     0x0c
-
-#define DSP_DTMF_DIGIT_TONE_CODE_0              0x07
-#define DSP_DTMF_DIGIT_TONE_CODE_1              0x00
-#define DSP_DTMF_DIGIT_TONE_CODE_2              0x04
-#define DSP_DTMF_DIGIT_TONE_CODE_3              0x08
-#define DSP_DTMF_DIGIT_TONE_CODE_4              0x01
-#define DSP_DTMF_DIGIT_TONE_CODE_5              0x05
-#define DSP_DTMF_DIGIT_TONE_CODE_6              0x09
-#define DSP_DTMF_DIGIT_TONE_CODE_7              0x02
-#define DSP_DTMF_DIGIT_TONE_CODE_8              0x06
-#define DSP_DTMF_DIGIT_TONE_CODE_9              0x0a
-#define DSP_DTMF_DIGIT_TONE_CODE_STAR           0x03
-#define DSP_DTMF_DIGIT_TONE_CODE_HASHMARK       0x0b
-#define DSP_DTMF_DIGIT_TONE_CODE_A              0x0c
-#define DSP_DTMF_DIGIT_TONE_CODE_B              0x0d
-#define DSP_DTMF_DIGIT_TONE_CODE_C              0x0e
-#define DSP_DTMF_DIGIT_TONE_CODE_D              0x0f
-
-
-#define DSP_UDATA_INDICATION_DTMF_DIGITS_SENT   16
-/*
-returns:
-  - none -
-  One indication will be sent for every request.
-*/
-
-
-#define DSP_UDATA_REQUEST_ENABLE_DTMF_RECEIVER  17
-/*
-parameters:
-  <word> tone duration (ms)
-  <word> gap duration (ms)
-*/
-typedef struct enable_dtmf_s {
-	__u16 tone;
-	__u16 gap;
-} enable_dtmf_s;
-
-#define DSP_UDATA_REQUEST_DISABLE_DTMF_RECEIVER 18
-/*
-parameters:
-  - none -
-*/
-
-#define DSP_UDATA_INDICATION_DTMF_DIGITS_RECEIVED 17
-/*
-returns:
-  <byte> digit 0 tone code
-  ...
-  <byte> digit n tone code
-*/
-
-#define DSP_DTMF_DIGITS_RECEIVED_HEADER_LENGTH  1
-
-
-#define DSP_UDATA_INDICATION_MODEM_CALLING_TONE 18
-/*
-returns:
-  - none -
-*/
-
-#define DSP_UDATA_INDICATION_FAX_CALLING_TONE   19
-/*
-returns:
-  - none -
-*/
-
-#define DSP_UDATA_INDICATION_ANSWER_TONE        20
-/*
-returns:
-  - none -
-*/
-
-/* ============= FAX ================ */
-
-#define EICON_FAXID_LEN 20
-
-typedef struct eicon_t30_s {
-  __u8          code;
-  __u8          rate;
-  __u8          resolution;
-  __u8          format;
-  __u8          pages_low;
-  __u8          pages_high;
-  __u8          atf;
-  __u8          control_bits_low;
-  __u8          control_bits_high;
-  __u8          feature_bits_low;
-  __u8          feature_bits_high;
-  __u8          universal_5;
-  __u8          universal_6;
-  __u8          universal_7;
-  __u8          station_id_len;
-  __u8          head_line_len;
-  __u8          station_id[EICON_FAXID_LEN];
-/* __u8          head_line[]; */
-} eicon_t30_s;
-
-        /* EDATA transmit messages */
-#define EDATA_T30_DIS       0x01
-#define EDATA_T30_FTT       0x02
-#define EDATA_T30_MCF       0x03
-
-        /* EDATA receive messages */
-#define EDATA_T30_DCS       0x81
-#define EDATA_T30_TRAIN_OK  0x82
-#define EDATA_T30_EOP       0x83
-#define EDATA_T30_MPS       0x84
-#define EDATA_T30_EOM       0x85
-#define EDATA_T30_DTC       0x86
-
-#define T30_FORMAT_SFF            0
-#define T30_FORMAT_ASCII          1
-#define T30_FORMAT_COUNT          2
-
-#define T30_CONTROL_BIT_DISABLE_FINE      0x0001
-#define T30_CONTROL_BIT_ENABLE_ECM        0x0002
-#define T30_CONTROL_BIT_ECM_64_BYTES      0x0004
-#define T30_CONTROL_BIT_ENABLE_2D_CODING  0x0008
-#define T30_CONTROL_BIT_ENABLE_T6_CODING  0x0010
-#define T30_CONTROL_BIT_ENABLE_UNCOMPR    0x0020
-#define T30_CONTROL_BIT_ACCEPT_POLLING    0x0040
-#define T30_CONTROL_BIT_REQUEST_POLLING   0x0080
-#define T30_CONTROL_BIT_MORE_DOCUMENTS    0x0100
-
-#define T30_CONTROL_BIT_ALL_FEATURES\
-  (T30_CONTROL_BIT_ENABLE_ECM | T30_CONTROL_BIT_ENABLE_2D_CODING |\
-   T30_CONTROL_BIT_ENABLE_T6_CODING | T30_CONTROL_BIT_ENABLE_UNCOMPR)
-
-#define T30_FEATURE_BIT_FINE              0x0001
-#define T30_FEATURE_BIT_ECM               0x0002
-#define T30_FEATURE_BIT_ECM_64_BYTES      0x0004
-#define T30_FEATURE_BIT_2D_CODING         0x0008
-#define T30_FEATURE_BIT_T6_CODING         0x0010
-#define T30_FEATURE_BIT_UNCOMPR_ENABLED   0x0020
-#define T30_FEATURE_BIT_POLLING           0x0040
-
-#define FAX_OBJECT_DOCU		1
-#define FAX_OBJECT_PAGE		2
-#define FAX_OBJECT_LINE		3
-
-#define T4_EOL			0x800
-#define T4_EOL_BITSIZE		12
-#define T4_EOL_DWORD		(T4_EOL << (32 - T4_EOL_BITSIZE))
-#define T4_EOL_MASK_DWORD	((__u32) -1 << (32 - T4_EOL_BITSIZE))
-
-#define SFF_LEN_FLD_SIZE	3
-
-#define _DLE_	0x10
-#define _ETX_	0x03
-
-typedef struct eicon_sff_dochead {
-	__u32	id		__attribute__ ((packed));
-	__u8	version		__attribute__ ((packed));
-	__u8	reserved1	__attribute__ ((packed));
-	__u16	userinfo	__attribute__ ((packed));
-	__u16	pagecount	__attribute__ ((packed));
-	__u16	off1pagehead	__attribute__ ((packed));
-	__u32	offnpagehead	__attribute__ ((packed));
-	__u32	offdocend	__attribute__ ((packed));
-} eicon_sff_dochead;
-
-typedef struct eicon_sff_pagehead {
-	__u8	pageheadid	__attribute__ ((packed));
-	__u8	pageheadlen	__attribute__ ((packed));
-	__u8	resvert		__attribute__ ((packed));
-	__u8	reshoriz	__attribute__ ((packed));
-	__u8	coding		__attribute__ ((packed));
-	__u8	reserved2	__attribute__ ((packed));
-	__u16	linelength	__attribute__ ((packed));
-	__u16	pagelength	__attribute__ ((packed));
-	__u32	offprevpage	__attribute__ ((packed));
-	__u32	offnextpage	__attribute__ ((packed));
-} eicon_sff_pagehead;
-
-#endif	/* E_IDI_H */
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/i4lididrv.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/i4lididrv.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/i4lididrv.c	2003-09-22 02:01:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/i4lididrv.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,1418 +0,0 @@
-/* $Id: i4lididrv.c,v 1.1.2.2 2002/10/02 14:38:37 armin Exp $
- *
- * ISDN interface module for Eicon active cards.
- * I4L - IDI Interface
- * 
- * Copyright 1998-2000 by Armin Schindler (mac@melware.de) 
- * Copyright 1999-2002 Cytronics & Melware (info@melware.de)
- * 
- * Thanks to	Deutsche Mailbox Saar-Lor-Lux GmbH
- *		for sponsoring and testing fax
- *		capabilities with Diva Server cards.
- *		(dor@deutschemailbox.de)
- *
- * This software may be used and distributed according to the terms
- * of the GNU General Public License, incorporated herein by reference.
- */
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/proc_fs.h>
-#include <linux/vmalloc.h>
-
-#include "i4lididrv.h"
-#include <linux/smp_lock.h>
-#include "divasync.h"
-
-#include "../avmb1/capicmd.h"  /* this should be moved in a common place */
-
-#define INCLUDE_INLINE_FUNCS
-
-static eicon_card *cards = (eicon_card *) NULL;   /* glob. var , contains
-                                                     start of card-list   */
-
-static char *DRIVERNAME = "Eicon Diva - native I4L Interface driver (http://www.melware.net)";
-static char *DRIVERLNAME = "diva2i4l";
-static char *DRIVERRELEASE = "2.0";
-static char *eicon_revision = "$Revision: 1.1.2.2 $";
-extern char *eicon_idi_revision;
-
-#define EICON_CTRL_VERSION 2
-
-ulong DebugVar;
-
-static spinlock_t status_lock;
-static spinlock_t ll_lock;
-
-#define MAX_DESCRIPTORS  32
-extern void DIVA_DIDD_Read(DESCRIPTOR *, int);
-
-static dword notify_handle;
-static DESCRIPTOR DAdapter;
-static DESCRIPTOR MAdapter;
-
-/* Parameter to be set by insmod */
-static char *id  = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
-static int debug = 1;
-
-MODULE_DESCRIPTION(             "ISDN4Linux Interface for Eicon active card driver");
-MODULE_AUTHOR(                  "Armin Schindler");
-MODULE_SUPPORTED_DEVICE(        "ISDN subsystem and Eicon active card driver");
-MODULE_PARM_DESC(id,   		"ID-String for ISDN4Linux");
-MODULE_PARM(id,           	"s");
-MODULE_PARM_DESC(debug,		"Initial debug value");
-MODULE_PARM(debug,           	"i");
-MODULE_LICENSE("GPL");
-
-void no_printf (unsigned char * x ,...)
-{
-  /* dummy debug function */
-}
-DIVA_DI_PRINTF dprintf = no_printf;
-
-#define DBG_MINIMUM  (DL_LOG + DL_FTL + DL_ERR)
-#define DBG_DEFAULT  (DBG_MINIMUM + DL_XLOG + DL_REG)
-#include "debuglib.c"
-
-static char *
-eicon_getrev(const char *revision)
-{
-	char *rev;
-	char *p;
-	if ((p = strchr(revision, ':'))) {
-		rev = p + 2;
-		p = strchr(rev, '$');
-		*--p = 0;
-	} else rev = "1.0";
-	return rev;
-
-}
-
-static void
-stop_dbg(void)
-{
-		DbgDeregister();
-		memset(&MAdapter, 0, sizeof(MAdapter));
-		dprintf = no_printf;
-}
-
-static eicon_chan *
-find_channel(eicon_card *card, int channel)
-{
-	if ((channel >= 0) && (channel < card->nchannels))
-        	return &(card->bch[channel]);
-	eicon_log(card, 1, "%s: Invalid channel %d\n", DRIVERLNAME, channel);
-	return NULL;
-}
-
-static void
-eicon_rx_request(struct eicon_card *card)
-{
-	struct sk_buff *skb, *skb2, *skb_new;
-	eicon_IND *ind, *ind2, *ind_new;
-	eicon_chan *chan;
-
-	if (!card) {
-		eicon_log(card, 1, "%s: NULL card in rcv_dispatch !\n", DRIVERLNAME);
-		return;
-	}
-
-	while((skb = skb_dequeue(&card->rcvq))) {
-		ind = (eicon_IND *)skb->data;
-
-		if ((chan = card->IdTable[ind->IndId]) == NULL) {
-			if (DebugVar & 1) {
-				switch(ind->Ind) {
-					case N_DISC_ACK:
-						/* doesn't matter if this happens */
-						break;
-					default:
-						eicon_log(card, 1, "idi: Indication for unknown channel Ind=%d Id=%x\n", ind->Ind, ind->IndId);
-						eicon_log(card, 1, "idi_hdl: Ch??: Ind=%d Id=%x Ch=%d MInd=%d MLen=%d Len=%d\n",
-						ind->Ind,ind->IndId,ind->IndCh,ind->MInd,ind->MLength,ind->RBuffer.length);
-				}
-			}
-			dev_kfree_skb(skb);
-			continue;
-		}
-
-		if (chan->e.complete) { /* check for rec-buffer chaining */
-			if (ind->MLength == ind->RBuffer.length) {
-				chan->e.complete = 1;
-				idi_handle_ind(card, skb);
-				continue;
-			}
-			else {
-				chan->e.complete = 0;
-				ind->Ind = ind->MInd;
-				skb_queue_tail(&chan->e.R, skb);
-				continue;
-			}
-		}
-		else {
-			if (!(skb2 = skb_dequeue(&chan->e.R))) {
-				chan->e.complete = 1;
-				eicon_log(card, 1, "%s: buffer incomplete, but 0 in queue\n", DRIVERLNAME);
-				dev_kfree_skb(skb);
-				continue;
-			}
-			ind2 = (eicon_IND *)skb2->data;
-			skb_new = alloc_skb(((sizeof(eicon_IND)-1)+ind->RBuffer.length+ind2->RBuffer.length),
-				GFP_ATOMIC);
-			if (!skb_new) {
-			eicon_log(card, 1, "%s: skb_alloc failed in rcv_dispatch()\n", DRIVERLNAME);
-				dev_kfree_skb(skb);
-				dev_kfree_skb(skb2);
-				continue;
-			}
-			ind_new = (eicon_IND *)skb_put(skb_new,
-				((sizeof(eicon_IND)-1)+ind->RBuffer.length+ind2->RBuffer.length));
-			ind_new->Ind = ind2->Ind;
-			ind_new->IndId = ind2->IndId;
-			ind_new->IndCh = ind2->IndCh;
-			ind_new->MInd = ind2->MInd;
-			ind_new->MLength = ind2->MLength;
-			ind_new->RBuffer.length = ind2->RBuffer.length + ind->RBuffer.length;
-			memcpy(&ind_new->RBuffer.P, &ind2->RBuffer.P, ind2->RBuffer.length);
-			memcpy((&ind_new->RBuffer.P)+ind2->RBuffer.length, &ind->RBuffer.P, ind->RBuffer.length);
-			dev_kfree_skb(skb);
-			dev_kfree_skb(skb2);
-			if (ind->MLength == ind->RBuffer.length) {
-				chan->e.complete = 2;
-				idi_handle_ind(card, skb_new);
-				continue;
-			}
-			else {
-				chan->e.complete = 0;
-				skb_queue_tail(&chan->e.R, skb_new);
-				continue;
-			}
-		}
-	}
-}
-
-static void
-eicon_ack_request(struct eicon_card *card)
-{
-	struct sk_buff *skb;
-
-	if (!card) {
-		eicon_log(card, 1, "%s: NULL card in ack_dispatch!\n", DRIVERLNAME);
-		return;
-	}
-	while((skb = skb_dequeue(&card->rackq))) {
-		idi_handle_ack(card, skb);
-	}
-}
-
-/*
- *  IDI-Callback function
- */
-static void
-eicon_idi_callback(ENTITY *de)
-{
-	eicon_card *ccard = (eicon_card *)de->R;
-	struct sk_buff *skb;
-	eicon_RC *ack;
-	eicon_IND *ind;
-	int len = 0;
-
-	if (de->complete == 255) {
-		/* Return Code */
-		skb = alloc_skb(sizeof(eicon_RC), GFP_ATOMIC);
-		if (!skb) {
-			eicon_log(ccard, 1, "%s: skb_alloc failed in _idi_callback()\n", DRIVERLNAME);
-		} else {
-			ack = (eicon_RC *)skb_put(skb, sizeof(eicon_RC));
-			ack->Rc = de->Rc;
-			if (de->Rc == ASSIGN_OK) {
-				ack->RcId = de->Id;
-				de->user[1] = de->Id;
-			} else {
-				ack->RcId = de->user[1];
-			}
-			ack->RcCh = de->RcCh;
-			ack->Reference = de->user[0];
-			skb_queue_tail(&ccard->rackq, skb);
-			eicon_ack_request(ccard);
-			eicon_log(ccard, 128, "idi_cbk: Ch%d: Rc=%x Id=%x RLen=%x compl=%x\n",
-				de->user[0], de->Rc, ack->RcId, de->RLength, de->complete);
-			DBG_TRC(("idi_cbk: Ch%d: Rc=%x Id=%x RLen=%x compl=%x",
-				de->user[0], de->Rc, ack->RcId, de->RLength, de->complete))
-	                de->Rc = 0;
-		}
-	} else {
-		/* Indication */
-		if (de->complete) {
-			len = de->RLength;
-		} else {
-			len = 270;
-			if (de->RLength <= 270)
-				eicon_log(ccard, 1, "idi_cbk: ind not complete but <= 270\n");
-		}
-		skb = alloc_skb((sizeof(eicon_IND) + len - 1), GFP_ATOMIC);
-		if (!skb) {
-			eicon_log(ccard, 1, "%s: skb_alloc failed in _idi_callback()\n", DRIVERLNAME);
-		} else {
-			ind = (eicon_IND *)skb_put(skb, (sizeof(eicon_IND) + len - 1));
-			ind->Ind = de->Ind;
-			ind->IndId = de->user[1];
-			ind->IndCh = de->IndCh;
-			ind->MInd  = de->Ind;
-			ind->RBuffer.length = len;
-			ind->MLength = de->RLength;
-			memcpy(&ind->RBuffer.P, &de->RBuffer->P, len);
-			skb_queue_tail(&ccard->rcvq, skb);
-			eicon_rx_request(ccard);
-			eicon_log(ccard, 128, "idi_cbk: Ch%d: Ind=%x Id=%x RLen=%x compl=%x\n",
-				de->user[0], de->Ind, ind->IndId, de->RLength, de->complete);
-			DBG_TRC(("idi_cbk: Ch%d: Ind=%x Id=%x RLen=%x compl=%x",
-				de->user[0], de->Ind, ind->IndId, de->RLength, de->complete))
-	                de->Ind = 0;
-		}
-	}
-	de->RNum = 0;
-	de->RNR = 0;
-    eicon_tx_request(ccard);
-}
-
-/*
-**  Kernel thread to prevent in_interrupt
-*/
-static DECLARE_TASK_QUEUE(tq_divad);
-static struct semaphore diva_thread_sem;
-static struct semaphore diva_thread_end;
-static int divad_pid = -1;
-static int divad_thread(void * data);
-static void diva_tx(void *data);
-static atomic_t thread_running;
-
-static void __init
-diva_init_thread(void)
-{
-  int pid = 0;
-
-  pid = kernel_thread(divad_thread, NULL, CLONE_KERNEL);
-  if (pid >= 0) {
-       divad_pid = pid;
-  }
-}
-
-static int
-divad_thread(void * data)
-{
-  atomic_inc(&thread_running);
-  if (atomic_read(&thread_running) > 1) {
-      printk(KERN_WARNING"%s: thread already running\n", DRIVERLNAME);
-      return(0);
-  }
-
-  printk(KERN_INFO "%s: thread started with pid %d\n", DRIVERLNAME, current->pid);
-  exit_mm(current);
-  exit_files(current);
-  exit_fs(current);
-
-  /* Set to RealTime */
-  current->policy = SCHED_FIFO;
-  current->rt_priority = 33;
-
-  strcpy(current->comm, "kdiva2i4ld");
-
-  for(;;) {
-    down_interruptible(&diva_thread_sem);
-    if(!(atomic_read(&thread_running)))
-      break;
-    if(signal_pending(current)) {
-         flush_signals(current);
-    } else {
-         run_task_queue(&tq_divad);
-    }
-  }
-  up(&diva_thread_end);
-  divad_pid = -1;
-  return 0;
-}
-
-static void
-stop_diva_thread(void)
-{
-    if (divad_pid >= 0) {
-         atomic_set(&thread_running, 0);
-         up(&diva_thread_sem);
-         down_interruptible(&diva_thread_end);
-    }
-}
-
-void
-eicon_tx_request(struct eicon_card *card)
-{
-  card->tq.routine = diva_tx;
-  card->tq.data = (void *)card;
-  queue_task(&card->tq, &tq_divad);
-  up(&diva_thread_sem);
-}
-
-static void
-diva_tx(void *data)
-{
-        struct eicon_card *card = (eicon_card *) data;
-	struct sk_buff *skb;
-	struct sk_buff *skb2;
-	eicon_chan *chan;
-	eicon_chan_ptr *chan2;
-	eicon_REQ *reqbuf = 0;
-	int ReqCount = 0;
-	int tmpid = 0;
-	int quloop = 1;
-	int dlev = 0;
-	ENTITY *ep = 0;
-
-        if (!card) {
-                eicon_log(card, 1, "%s: NULL card in transmit !\n", DRIVERLNAME);
-                return;
-        }
-
-	ReqCount = 0;
-	if (!(skb2 = skb_dequeue(&card->sndq)))
-		quloop = 0;
-	while(quloop) {
-		chan2 = (eicon_chan_ptr *)skb2->data;
-		chan = chan2->ptr;
-		if (!chan->e.busy) {
-		 if((skb = skb_dequeue(&chan->e.X))) {
-
-		  reqbuf = (eicon_REQ *)skb->data;
-		  if ((reqbuf->Reference) && (chan->e.B2Id == 0) && (reqbuf->ReqId & 0x1f)) {
-			eicon_log(card, 16, "%s: transmit: error Id=0 on %d (Net)\n", DRIVERLNAME, chan->No);
-		  } else {
-			dlev = 160;
-			if (reqbuf->ReqId & 0x1f) { /* if this is no ASSIGN */
-
-				if (!reqbuf->Reference) { /* Signal Layer */
-					ep = &chan->de;
-					tmpid = chan->e.D3Id;
-					chan->e.ReqCh = 0;
-				}
-				else {                  /* Net Layer */
-					ep = &chan->be;
-					tmpid = chan->e.B2Id;
-					chan->e.ReqCh = 1;
-					if (((reqbuf->Req & 0x0f) == 0x08) ||
-					    ((reqbuf->Req & 0x0f) == 0x01)) { /* Send Data */
-						chan->waitq = reqbuf->XBuffer.length;
-						chan->waitpq += reqbuf->XBuffer.length;
-						dlev = 128;
-					}
-				}
-
-			} else {        /* It is an ASSIGN */
-				if (!reqbuf->Reference)
-					ep = &chan->de;
-				else
-					ep = &chan->be;
-				ep->Id = reqbuf->ReqId;
-				tmpid = reqbuf->ReqId;
-
-				if (!reqbuf->Reference)
-					chan->e.ReqCh = 0;
-				else
-					chan->e.ReqCh = 1;
-			}
-
-			chan->e.ref = chan->No;
-			chan->e.Req = reqbuf->Req;
-			ReqCount++;
-			if (ep) {
-				ep->callback = eicon_idi_callback;
-				ep->R = (BUFFERS *)card;
-				ep->user[0] = (word)chan->No;
-				ep->user[1] = (word)tmpid;
-				ep->XNum = 1;
-				ep->RNum = 0;
-				ep->RNR = 0;
-				ep->Rc = 0;
-				ep->Ind = 0;
-				ep->X->PLength = reqbuf->XBuffer.length;
-				memcpy(ep->X->P, &reqbuf->XBuffer.P, reqbuf->XBuffer.length);
-				ep->ReqCh = reqbuf->ReqCh;
-				ep->Req = reqbuf->Req;
-			}
-			chan->e.busy = 1;
-			eicon_log(card, dlev, "idi: Req=%d Id=%x Ch=%d Len=%d Ref=%d\n",
-				reqbuf->Req, tmpid,
-				reqbuf->ReqCh, reqbuf->XBuffer.length,
-				chan->e.ref);
-			if (ep) {
-				card->d.request(ep);
-				if (ep->Rc)
-					eicon_idi_callback(ep);
-			}
-		  }
-		  dev_kfree_skb(skb);
-		 }
-		 dev_kfree_skb(skb2);
-		}
-		else {
-			skb_queue_tail(&card->sackq, skb2);
-			eicon_log(card, 128, "%s: transmit: busy chan %d\n", DRIVERLNAME, chan->No);
-		}
-		if (!(skb2 = skb_dequeue(&card->sndq)))
-			quloop = 0;
-	}
-	while((skb = skb_dequeue(&card->sackq))) {
-		skb_queue_tail(&card->sndq, skb);
-	}
-}
-
-static int
-eicon_command(eicon_card * card, isdn_ctrl * c)
-{
-        ulong a;
-        eicon_chan *chan;
-	isdn_ctrl cmd;
-	int ret = 0;
-
-	eicon_log(card, 16, "%s_cmd 0x%x with arg 0x%lx (0x%lx)\n", DRIVERLNAME,
-		c->command, c->arg, (ulong) *c->parm.num);
-
-        switch (c->command) {
-		case ISDN_CMD_IOCTL:
-			memcpy(&a, c->parm.num, sizeof(ulong));
-			switch (c->arg) {
-				case EICON_IOCTL_GETVER:
-					return(EICON_CTRL_VERSION);
-				case EICON_IOCTL_MANIF:
-					if (!card->flags & EICON_FLAGS_RUNNING)
-						return -ENODEV;
-					if (!card->d.features & DI_MANAGE)
-						return -ENODEV;
-					ret = eicon_idi_manage(
-						card, 
-						(eicon_manifbuf *)a);
-					return ret;
-
-				case EICON_IOCTL_GETXLOG:
-					return -ENODEV;
-				case EICON_IOCTL_DEBUGVAR:
-					DebugVar = a;
-					eicon_log(card, 1, "%s: Debug Value set to %ld\n", DRIVERLNAME, DebugVar);
-					return 0;
-				case EICON_IOCTL_LOADPCI:
-					eicon_log(card, 1, "%s: Wrong version of load-utility,\n", DRIVERLNAME);
-					eicon_log(card, 1, "%s: re-compile eiconctrl !\n", DRIVERLNAME);
-					eicon_log(card, 1, "%s: Maybe update of utility is necessary !\n", DRIVERLNAME);
-					return -EINVAL;
-				default:	
-					return -EINVAL;
-			}
-			break;
-		case ISDN_CMD_DIAL:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			if ((chan->fsm_state != EICON_STATE_NULL) && (chan->fsm_state != EICON_STATE_LISTEN)) {
-				eicon_log(card, 1, "%s: Dial on channel %d with state %d\n", DRIVERLNAME,
-					chan->No, chan->fsm_state);
-				return -EBUSY;
-			}
-			chan->fsm_state = EICON_STATE_OCALL;
-			
-			ret = idi_connect_req(card, chan, c->parm.setup.phone,
-						     c->parm.setup.eazmsn,
-						     c->parm.setup.si1,
-						     c->parm.setup.si2);
-			if (ret) {
-				cmd.driver = card->myid;
-				cmd.command = ISDN_STAT_DHUP;
-				cmd.arg &= 0x1f;
-				card->interface.statcallb(&cmd);
-			}
-			return ret;
-		case ISDN_CMD_ACCEPTD:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			if (chan->fsm_state == EICON_STATE_ICALL) { 
-				idi_connect_res(card, chan);
-			}
-			return 0;
-		case ISDN_CMD_ACCEPTB:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			return 0;
-		case ISDN_CMD_HANGUP:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			idi_hangup(card, chan);
-			return 0;
-		case ISDN_CMD_SETEAZ:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			chan->eazmask = 0x3ff;
-			eicon_idi_listen_req(card, chan);
-			return 0;
-		case ISDN_CMD_CLREAZ:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			chan->eazmask = 0;
-			eicon_idi_listen_req(card, chan);
-			return 0;
-		case ISDN_CMD_SETL2:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			chan->l2prot = (c->arg >> 8);
-                        memcpy(chan->a_para, c->parm.aux.para, sizeof(chan->a_para));
-			return 0;
-		case ISDN_CMD_SETL3:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			chan->l3prot = (c->arg >> 8);
-#ifdef CONFIG_ISDN_TTY_FAX
-			if (chan->l3prot == ISDN_PROTO_L3_FCLASS2) {
-				chan->fax = c->parm.fax;
-				eicon_log(card, 128, "idi_cmd: Ch%d: SETL3 struct fax=0x%x\n",chan->No, chan->fax);
-			}
-#endif
-			return 0;
-#ifdef CONFIG_ISDN_TTY_FAX
-		case ISDN_CMD_FAXCMD:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			if (!chan->fax)
-				break;
-			idi_fax_cmd(card, chan);
-			return 0;
-#endif
-		case ISDN_CMD_AUDIO:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			idi_audio_cmd(card, chan, c->arg >> 8, c->parm.num);
-			return 0;
-		case CAPI_PUT_MESSAGE:
-			if (!card->flags & EICON_FLAGS_RUNNING)
-				return -ENODEV;
-			if (!(chan = find_channel(card, c->arg & 0x1f)))
-				break;
-			if (c->parm.cmsg.Length < 8)
-				break;
-			switch(c->parm.cmsg.Command) {
-				case CAPI_FACILITY:
-					if (c->parm.cmsg.Subcommand == CAPI_REQ)
-						return(capipmsg(card, chan, &c->parm.cmsg));
-					break;
-				case CAPI_MANUFACTURER:
-				default:
-					break;
-			}
-			return 0;
-        }
-	
-        return -EINVAL;
-}
-
-static int
-find_free_number(void)
-{
-  int num = 0;
-  char cid[40];
-  eicon_card *p;
-  ulong flags;
-
-  spin_lock_irqsave(&ll_lock, flags);
-  while(num < 100) {
-    sprintf(cid, "%s%d", id, num);
-    num++;
-    p = cards;
-    while (p) {
-      if (!strcmp(p->regname, cid))
-        break;
-      p = p->next;
-    }
-		if (p)
-		{
-	    spin_unlock_irqrestore(&ll_lock, flags);
-  	  return(num - 1);
-		}
-  }
-  spin_unlock_irqrestore(&ll_lock, flags);
-  return(999);
-}
-
-/*
- * Find card with given driverId
- */
-static inline eicon_card *
-eicon_findcard(int driverid)
-{
-  eicon_card *p;
-  ulong flags;
-
-  spin_lock_irqsave(&ll_lock, flags);
-  p = cards;
-  while (p) {
-    if (p->myid == driverid) {
-      spin_unlock_irqrestore(&ll_lock, flags);
-      return p;
-    }
-    p = p->next;
-  }
-  spin_unlock_irqrestore(&ll_lock, flags);
-  return (eicon_card *) 0;
-}
-
-/*
- * Wrapper functions for interface to linklevel
- */
-static int
-if_command(isdn_ctrl * c)
-{
-        eicon_card *card = eicon_findcard(c->driver);
-
-        if (card)
-                return (eicon_command(card, c));
-        printk(KERN_ERR
-             "%s: if_command %d called with invalid driverId %d!\n", DRIVERLNAME,
-               c->command, c->driver);
-        return -ENODEV;
-}
-
-static int
-if_writecmd(const u_char * buf, int len, int user, int id, int channel)
-{
-	/* Not used */
-        return (len);
-}
-
-static int
-if_readstatus(u_char * buf, int len, int user, int id, int channel)
-{
-  int count = 0;
-  int cnt = 0;
-  u_char *p = buf;
-  struct sk_buff *skb;
-  ulong flags;
-
-        eicon_card *card = eicon_findcard(id);
-	
-        if (card) {
-                if (!card->flags & EICON_FLAGS_RUNNING)
-                        return -ENODEV;
-	
-		spin_lock_irqsave(&status_lock, flags);
-		while((skb = skb_dequeue(&card->statq))) {
-
-			if ((skb->len + count) > len)
-				cnt = len - count;
-			else
-				cnt = skb->len;
-
-			if (user)
-				copy_to_user(p, skb->data, cnt);
-			else
-				memcpy(p, skb->data, cnt);
-
-			count += cnt;
-			p += cnt;
-
-			if (cnt == skb->len) {
-				dev_kfree_skb(skb);
-				if (card->statq_entries > 0)
-					card->statq_entries--;
-			} else {
-				skb_pull(skb, cnt);
-				skb_queue_head(&card->statq, skb);
-				spin_unlock_irqrestore(&status_lock, flags);
-				return count;
-			}
-		}
-		card->statq_entries = 0;
-		spin_unlock_irqrestore(&status_lock, flags);
-		return count;
-        }
-        printk(KERN_ERR
-               "%s: if_readstatus called with invalid driverId!\n", DRIVERLNAME);
-        return 0;
-}
-
-static int
-if_sendbuf(int id, int channel, int ack, struct sk_buff *skb)
-{
-        eicon_card *card = eicon_findcard(id);
-	eicon_chan *chan;
-	int ret = 0;
-	int len;
-
-	len = skb->len;
-
-        if (card) {
-                if (!card->flags & EICON_FLAGS_RUNNING)
-                        return -ENODEV;
-        	if (!(chan = find_channel(card, channel)))
-			return -ENODEV;
-
-		if (chan->fsm_state == EICON_STATE_ACTIVE) {
-#ifdef CONFIG_ISDN_TTY_FAX
-			if (chan->l2prot == ISDN_PROTO_L2_FAX) {
-				if ((ret = idi_faxdata_send(card, chan, skb)) > 0)
-					ret = len;
-			}
-			else
-#endif
-				ret = idi_send_data(card, chan, ack, skb, 1, 1);
-			return (ret);
-		} else {
-			return -ENODEV;
-		}
-        }
-        printk(KERN_ERR
-               "%s: if_sendbuf called with invalid driverId!\n", DRIVERLNAME);
-        return -ENODEV;
-}
-
-/* jiftime() copied from HiSax */
-static inline int jiftime(char *s, long mark)
-{
-        s += 8;
-
-        *s-- = '\0';
-        *s-- = mark % 10 + '0';
-        mark /= 10;
-        *s-- = mark % 10 + '0';
-        mark /= 10;
-        *s-- = '.';
-        *s-- = mark % 10 + '0';
-        mark /= 10;
-        *s-- = mark % 6 + '0';
-        mark /= 6;
-        *s-- = ':';
-        *s-- = mark % 10 + '0';
-        mark /= 10;
-        *s-- = mark % 10 + '0';
-        return(8);
-}
-
-void
-eicon_putstatus(eicon_card * card, char * buf)
-{
-  int count;
-  isdn_ctrl cmd;
-  u_char *p;
-  struct sk_buff *skb;
-  ulong flags;
-
-	if (!card) {
-		if (!(card = cards))
-			return;
-	}
-
-	spin_lock_irqsave(&status_lock, flags);
-	count = strlen(buf);
-	skb = alloc_skb(count, GFP_ATOMIC);
-	if (!skb) {
-		spin_unlock_irqrestore(&status_lock, flags);
-		printk(KERN_ERR "%s: could not alloc skb in putstatus\n", DRIVERLNAME);
-		return;
-	}
-	p = skb_put(skb, count);
-	memcpy(p, buf, count);
-
-	skb_queue_tail(&card->statq, skb);
-
-	if (card->statq_entries >= MAX_STATUS_BUFFER) {
-		if ((skb = skb_dequeue(&card->statq))) {
-			count -= skb->len;
-			dev_kfree_skb(skb);
-		} else
-			count = 0;
-	} else
-		card->statq_entries++;
-
-	spin_unlock_irqrestore(&status_lock, flags);
-        if (count) {
-                cmd.command = ISDN_STAT_STAVAIL;
-                cmd.driver = card->myid;
-                cmd.arg = count;
-		card->interface.statcallb(&cmd);
-        }
-}
-
-/*
- * Debug and Log 
- */
-void
-eicon_log(eicon_card * card, int level, const char *fmt, ...)
-{
-	va_list args;
-	char Line[160];
-	u_char *p;
-
-
-	if ((DebugVar & level) || (DebugVar & 256)) {
-		va_start(args, fmt);
-
-		if (DebugVar & level) {
-			if (DebugVar & 256) {
-				/* log-buffer */
-				p = Line;
-				p += jiftime(p, jiffies);
-				*p++ = 32;
-				p += vsprintf(p, fmt, args);
-				*p = 0;	
-				eicon_putstatus(card, Line);
-			} else {
-				/* printk, syslogd */
-				vsprintf(Line, fmt, args);
-				printk(KERN_DEBUG "%s", Line);
-			}
-		}
-
-		va_end(args);
-	}
-}
-
-
-/*
- * Allocate a new card-struct, initialize it
- * link it into cards-list.
- */
-static void
-eicon_alloccard(DESCRIPTOR *d)
-{
-  int j;
-  char cid[40];
-  eicon_card *card;
-  ulong flags;
-
-	sprintf(cid, "%s%d", id, find_free_number());
-	if (!(card = (eicon_card *) kmalloc(sizeof(eicon_card), GFP_KERNEL))) {
-		eicon_log(card, 1,
-		       "%s: (%s) Could not allocate card-struct.\n", DRIVERLNAME, cid);
-		return;
-	}
-	memset((char *) card, 0, sizeof(eicon_card));
-	skb_queue_head_init(&card->sndq);
-	skb_queue_head_init(&card->rcvq);
-	skb_queue_head_init(&card->rackq);
-	skb_queue_head_init(&card->sackq);
-	skb_queue_head_init(&card->statq);
-	card->statq_entries = 0;
-	card->interface.owner = THIS_MODULE;
-	card->interface.maxbufsize = 4000;
-	card->interface.command = if_command;
-	card->interface.writebuf_skb = if_sendbuf;
-	card->interface.writecmd = if_writecmd;
-	card->interface.readstat = if_readstatus;
-	card->interface.features =
-		ISDN_FEATURE_L2_X75I |
-		ISDN_FEATURE_L2_HDLC |
-		ISDN_FEATURE_L2_TRANS |
-		ISDN_FEATURE_L3_TRANS |
-		ISDN_FEATURE_L3_TRANSDSP |
-		ISDN_FEATURE_P_UNKNOWN;
-	card->interface.hl_hdrlen = 20;
-	card->ptype = ISDN_PTYPE_UNKNOWN;
-	strcpy(card->interface.id, cid);
-	card->myid = -1;
-	card->type = d->type;
-
-	if (d->features & (DI_FAX3 | DI_EXTD_FAX))
-		card->interface.features |= (ISDN_FEATURE_L2_FAX | ISDN_FEATURE_L3_FCLASS2);
-	if (d->features & DI_MODEM)
-		card->interface.features |= ISDN_FEATURE_L2_MODEM;
-	if (d->features & DI_V110)
-		card->interface.features |= (ISDN_FEATURE_L2_V11096|ISDN_FEATURE_L2_V11019|ISDN_FEATURE_L2_V11038);
-
-	card->flags = 0;
-	card->nchannels = d->channels;
-	card->interface.channels = d->channels;
-	if (!(card->bch = (eicon_chan *) vmalloc(sizeof(eicon_chan) * (card->nchannels + 1)))) {
-		eicon_log(card, 1,
-		       "%s: (%s) Could not allocate bch-struct.\n", DRIVERLNAME, cid);
-		kfree(card);
-		return;
-	}
-	for (j=0; j< (card->nchannels + 1); j++) {
-		memset((char *)&card->bch[j], 0, sizeof(eicon_chan));
-		card->bch[j].statectrl = 0;
-		card->bch[j].l2prot = ISDN_PROTO_L2_X75I;
-		card->bch[j].l3prot = ISDN_PROTO_L3_TRANS;
-		card->bch[j].e.D3Id = 0;
-		card->bch[j].e.B2Id = 0;
-		card->bch[j].e.Req = 0;
-		card->bch[j].No = j;
-		card->bch[j].tskb1 = NULL;
-		card->bch[j].tskb2 = NULL;
-		skb_queue_head_init(&card->bch[j].e.X);
-		skb_queue_head_init(&card->bch[j].e.R);
-	}
-
-	if (!(card->dbuf = (DBUFFER *) kmalloc((sizeof(DBUFFER) * (card->nchannels + 1))*2
-						 , GFP_KERNEL))) {
-		eicon_log(card, 1,
-		       "%s: (%s) Could not allocate DBUFFER-struct.\n", DRIVERLNAME, cid);
-		kfree(card);
-		vfree(card->bch);
-		return;
-	}
-	if (!(card->sbuf = (BUFFERS *) kmalloc((sizeof(BUFFERS) * (card->nchannels + 1)) * 2, GFP_KERNEL))) {
-		eicon_log(card, 1,
-		       "%s: (%s) Could not allocate BUFFERS-struct.\n", DRIVERLNAME, cid);
-		kfree(card);
-		vfree(card->bch);
-		kfree(card->dbuf);
-		return;
-	}
-	if (!(card->sbufp = (char *) kmalloc((270 * (card->nchannels + 1)) * 2, GFP_KERNEL))) {
-		eicon_log(card, 1,
-		       "%s: (%s) Could not allocate BUFFERSP-struct.\n", DRIVERLNAME, cid);
-		kfree(card);
-		vfree(card->bch);
-		kfree(card->dbuf);
-		kfree(card->sbuf);
-		return;
-	}
-	for (j=0; j< (card->nchannels + 1); j++) {
-		memset((char *)&card->dbuf[j], 0, sizeof(DBUFFER));
-		card->bch[j].de.RBuffer = (DBUFFER *)&card->dbuf[j];
-		memset((char *)&card->dbuf[j+(card->nchannels+1)], 0, sizeof(BUFFERS));
-		card->bch[j].be.RBuffer = (DBUFFER *)&card->dbuf[j+(card->nchannels+1)];
-
-		memset((char *)&card->sbuf[j], 0, sizeof(BUFFERS));
-		card->bch[j].de.X = (BUFFERS *)&card->sbuf[j];
-		memset((char *)&card->sbuf[j+(card->nchannels+1)], 0, sizeof(BUFFERS));
-		card->bch[j].be.X = (BUFFERS *)&card->sbuf[j+(card->nchannels+1)];
-
-		memset((char *)&card->sbufp[j], 0, 270);
-		card->bch[j].de.X->P = (char *)&card->sbufp[j * 270];
-		memset((char *)&card->sbufp[j+(card->nchannels+1)], 0, 270);
-		card->bch[j].be.X->P = (char *)&card->sbufp[(j+(card->nchannels+1)) * 270];
-	}
-	memcpy(&card->d, d, sizeof(*d)); /* DESCRIPTOR entries */
-
-	/* initializing some variables */
-	card->lock = SPIN_LOCK_UNLOCKED;
-	card->ReadyInt = 0;
-
-	for(j = 0; j < 256; j++)
-		card->IdTable[j] = NULL;
-
-	for(j = 0; j < (card->d.channels + 1); j++) {
-		card->bch[j].e.busy = 0;
-		card->bch[j].e.D3Id = 0;
-		card->bch[j].e.B2Id = 0;
-		card->bch[j].e.ref = 0;
-		card->bch[j].e.Req = 0;
-		card->bch[j].e.complete = 1;
-		card->bch[j].fsm_state = EICON_STATE_NULL;
-	}
-	printk(KERN_INFO "%s: registered card '%s' with %d channels\n",
-		DRIVERLNAME, cid, d->channels);
-
-  spin_lock_irqsave(&ll_lock, flags);
-	card->next = cards;
-	cards = card;
-  spin_unlock_irqrestore(&ll_lock, flags);
-}
-
-/*
- * register card at linklevel
- */
-static int
-eicon_registercard(eicon_card * card)
-{
-	isdn_ctrl cmd;
-
-        if (!register_isdn(&card->interface)) {
-                printk(KERN_WARNING
-                       "%s: Unable to register %s\n", DRIVERLNAME,
-                       card->interface.id);
-                return -1;
-        }
-        card->myid = card->interface.channels;
-        sprintf(card->regname, "%s", card->interface.id);
-
-	/* after register we start it */
-	card->flags |= EICON_FLAGS_LOADED;
-	card->flags |= EICON_FLAGS_RUNNING;
-	cmd.command = ISDN_STAT_RUN;
-	cmd.driver = card->myid;
-	cmd.arg = 0;
-	card->interface.statcallb(&cmd);
-
-        return 0;
-}
-
-static void 
-unregister_card(eicon_card * card, int rme)
-{
-  int count;
-  int channel;
-  isdn_ctrl cmd;
-  eicon_chan *chan;
-
-  if(rme) {
-      /* before unload we need to remove the signal entity */
-      for(channel = 0; channel < card->nchannels; channel++)
-        {
-		chan = &(card->bch[channel]);
-                if (chan->e.D3Id) {
-                        idi_do_req(card, chan, REMOVE, 0);
-			count = 100;
-			while(count--) {
-				if (!chan->e.D3Id)
-					break;
-				SLEEP(2);
-			}
-			if (!count)
-				printk(KERN_WARNING"%s: ch:%d unlink to diva module not successful !\n",
-					DRIVERLNAME, chan->No);
-		}
-        }
-  }
-
-  cmd.command = ISDN_STAT_UNLOAD;
-  cmd.driver = card->myid;
-  card->interface.statcallb(&cmd);
-  DBG_TRC(("channel entities freed"));
-}
-
-static void
-eicon_freecard(eicon_card *card) {
-	int i;
-
-	for(i = 0; i < (card->nchannels + 1); i++) {
-		skb_queue_purge(&card->bch[i].e.X);
-		skb_queue_purge(&card->bch[i].e.R);
-	}
-	skb_queue_purge(&card->sndq);
-	skb_queue_purge(&card->rcvq);
-	skb_queue_purge(&card->rackq);
-	skb_queue_purge(&card->sackq);
-	skb_queue_purge(&card->statq);
-
-	kfree(card->sbufp);
-	kfree(card->sbuf);
-	kfree(card->dbuf);
-	vfree(card->bch);
-	kfree(card);
-        DBG_TRC(("card structures freed"));
-}
-
-static int
-eicon_addcard(DESCRIPTOR *d)
-{
-  eicon_card *p;
-  eicon_card *q = NULL;
-  int registered;
-  int added = 0;
-  int failed = 0;
-  ulong flags;
-
-	eicon_alloccard(d);
-        p = cards;
-        while (p) {
-		registered = 0;
-		if (!p->interface.statcallb) {
-			/* Not yet registered.
-			 * Try to register and activate it.
-			 */
-			added++;
-			if (!eicon_registercard(p))
-				registered = 1;
-		} else {
-			/* Card already registered */
-			registered = 1;
-		}
-
-                if (registered) {
-			/* Init OK, next card ... */
-                        spin_lock_irqsave(&ll_lock, flags);
-                        q = p;
-                        p = p->next;
-                        spin_unlock_irqrestore(&ll_lock, flags);
-                } else {
-                        /* registering failed, remove card from list, free memory */
-                        printk(KERN_ERR
-                               "%s: Initialization of %s failed\n", DRIVERLNAME,
-                               p->interface.id);
-                        spin_lock_irqsave(&ll_lock, flags);
-                        if (q) {
-                                q->next = p->next;
-                                eicon_freecard(p);
-                                p = q->next;
-                        } else {
-                                cards = p->next;
-                                eicon_freecard(p);
-                                p = cards;
-                        }
-                        spin_unlock_irqrestore(&ll_lock, flags);
-			failed++;
-                }
-	}
-        return (added - failed);
-}
-
-static void *
-didd_callback(void *context, DESCRIPTOR* adapter, int removal)
-{
-  eicon_card *cp = NULL, *lastcp = NULL;
-  ulong flags;
-
-  if (adapter->type == IDI_DADAPTER)
-  {
-    printk(KERN_ERR "%s: Change in DAdapter ? Oops ?.\n", DRIVERLNAME);
-    DBG_ERR(("Notification about IDI_DADAPTER change ! Oops."));
-    return(NULL);
-  }
-  else if (adapter->type == IDI_DIMAINT)
-  {
-    if (removal)
-    {
-				stop_dbg();
-    }
-    else
-    {
-      memcpy(&MAdapter, adapter, sizeof(MAdapter));
-      dprintf = (DIVA_DI_PRINTF)MAdapter.request;
-      DbgRegister("I4L", DRIVERRELEASE, DBG_DEFAULT);
-    }
-  }
-  else if ((adapter->type > 0) &&
-           (adapter->type < 16))
-  {  /* IDI Adapter */
-    if (removal)
-    {
-      spin_lock_irqsave(&ll_lock, flags);
-      lastcp = cp = cards;
-      while (cp) {
-        if (cp->d.request == adapter->request)
-        {
-          spin_unlock_irqrestore(&ll_lock, flags);
-          DBG_LOG(("remove adapter from list"));
-          unregister_card(cp, 0);
-          spin_lock_irqsave(&ll_lock, flags);
-          if (cp == lastcp)
-            cards = cp->next;
-          else
-            lastcp->next = cp->next;
-          eicon_freecard(cp);
-          break;
-        }
-        lastcp = cp;
-        cp = cp->next;
-      }
-      spin_unlock_irqrestore(&ll_lock, flags);
-    }
-    else
-    {
-      if (adapter->channels) {
-        DBG_LOG(("add adapter to list"));
-        eicon_addcard(adapter);
-      }
-    }
-  }
-  return(NULL);
-}
-
-static int __init
-connect_didd(void)
-{
-  int x = 0;
-  int dadapter = 0;
-  IDI_SYNC_REQ req;
-  DESCRIPTOR DIDD_Table[MAX_DESCRIPTORS];
-
-  DIVA_DIDD_Read(DIDD_Table, sizeof(DIDD_Table));
-
-  for (x = 0; x < MAX_DESCRIPTORS; x++)
-  {
-    if (DIDD_Table[x].type == IDI_DADAPTER)
-    {  /* DADAPTER found */
-      dadapter = 1;
-      memcpy(&DAdapter, &DIDD_Table[x], sizeof(DAdapter));
-      req.didd_notify.e.Req = 0;
-      req.didd_notify.e.Rc = IDI_SYNC_REQ_DIDD_REGISTER_ADAPTER_NOTIFY;
-      req.didd_notify.info.callback = didd_callback;
-      req.didd_notify.info.context = 0;
-      DAdapter.request((ENTITY *)&req);
-      if (req.didd_notify.e.Rc != 0xff)
-			{
-					stop_dbg();
-					return(0);
-			}
-      notify_handle = req.didd_notify.info.handle;
-    }
-    else if (DIDD_Table[x].type == IDI_DIMAINT)
-    {  /* MAINT found */
-      memcpy(&MAdapter, &DIDD_Table[x], sizeof(DAdapter));
-      dprintf = (DIVA_DI_PRINTF)MAdapter.request;
-      DbgRegister("I4L", DRIVERRELEASE, DBG_DEFAULT);
-    }
-    else if ((DIDD_Table[x].type > 0) &&
-             (DIDD_Table[x].type < 16))
-    {  /* IDI Adapter found */
-      if (DIDD_Table[x].channels) {
-        eicon_addcard(&DIDD_Table[x]);
-      }
-    }
-  }
-
-	if (!dadapter) {
-			stop_dbg();
-	}
-
-  return(dadapter);
-}
-
-static void __exit
-disconnect_didd(void)
-{
-  IDI_SYNC_REQ req;
-
-	stop_dbg();
-
-  req.didd_notify.e.Req = 0;
-  req.didd_notify.e.Rc = IDI_SYNC_REQ_DIDD_REMOVE_ADAPTER_NOTIFY;
-  req.didd_notify.info.handle = notify_handle;
-  DAdapter.request((ENTITY *)&req);
-}
-
-/*
-** proc entry
-*/
-extern struct proc_dir_entry *proc_net_isdn_eicon;
-static struct proc_dir_entry *i4lidi_proc_entry = NULL;
-
-static int
-i4lidi_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data)
-{
-  int len = 0;
-  char tmprev[32];
-
-  len += sprintf(page+len, "%s\n", DRIVERNAME);
-  len += sprintf(page+len, "name     : %s\n", DRIVERLNAME);
-  len += sprintf(page+len, "release  : %s\n", DRIVERRELEASE);
-  strcpy(tmprev, eicon_revision);
-  len += sprintf(page+len, "revision : %s/", eicon_getrev(tmprev));
-  strcpy(tmprev, eicon_idi_revision);
-  len += sprintf(page+len, "%s\n", eicon_getrev(tmprev));
-
-  if (off + count >= len)
-    *eof = 1;
-  if (len < off)
-    return 0;
-  *start = page + off;
-  return((count < len-off) ? count : len-off);
-}
-
-static void __init
-create_proc(void)
-{
-  if(!(i4lidi_proc_entry = create_proc_entry(DRIVERLNAME,
-                          S_IFREG | S_IRUGO | S_IWUSR, proc_net_isdn_eicon)))
-  {
-    printk(KERN_WARNING "%s: failed to create proc entry.\n", DRIVERLNAME);
-    return;
-  }
-  i4lidi_proc_entry->read_proc = i4lidi_proc_read;
-  i4lidi_proc_entry->owner = THIS_MODULE;
-}
-
-static void __exit
-remove_proc(void)
-{
-  if(i4lidi_proc_entry)
-      remove_proc_entry(DRIVERLNAME,  proc_net_isdn_eicon);
-}
-
-/*
-** load / unload
-*/
-static int __init
-i4l_idi_init(void)
-{
-  int ret = 0;
-  char tmprev[50];
-
-  status_lock = SPIN_LOCK_UNLOCKED;
-  ll_lock = SPIN_LOCK_UNLOCKED;
-
-  if (strlen(id) < 1)
-    strcpy(id, "diva");
-
-  DebugVar = debug;
-
-  init_MUTEX_LOCKED(&diva_thread_sem);
-  init_MUTEX_LOCKED(&diva_thread_end);
-
-  printk(KERN_INFO "%s\n", DRIVERNAME);
-  printk(KERN_INFO "%s: Rel:%s  Rev:",DRIVERLNAME , DRIVERRELEASE);
-  strcpy(tmprev, eicon_revision);
-  printk("%s/", eicon_getrev(tmprev));
-  strcpy(tmprev, eicon_idi_revision);
-  printk("%s\n", eicon_getrev(tmprev));
-
-  diva_init_thread();
-
-  if(!connect_didd()) {
-    printk(KERN_ERR "%s: failed to connect to DIDD.\n", DRIVERLNAME);
-    stop_diva_thread();
-    ret = -EIO;
-    goto out;
-  }    
-  create_proc();
-
-out:
-  return(ret);
-}
-
-static void __exit
-i4l_idi_exit(void)
-{
-  eicon_card *card, *last, *cc;
-  ulong flags;
-
-  spin_lock_irqsave(&ll_lock, flags);
-  cc = cards;
-  card = cc;
-  cards = NULL;
-  spin_unlock_irqrestore(&ll_lock, flags);
-
-  remove_proc();
-
-  while (card) {
-    unregister_card(card, 1); 
-    card = card->next;
-  }
-
-  stop_diva_thread();
-  disconnect_didd();
-
-  card = cc;
-  while (card) {
-    last = card;
-    card = card->next;
-    eicon_freecard(last);
-  }
-  printk(KERN_INFO "%s: module unloaded.\n", DRIVERLNAME);
-}
-
-module_init(i4l_idi_init);
-module_exit(i4l_idi_exit);
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/i4lididrv.h linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/i4lididrv.h
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/i4lididrv.h	2002-10-11 03:09:02.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/i4lididrv.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,272 +0,0 @@
-/* $Id: i4lididrv.h,v 1.1.2.2 2002/10/02 14:38:37 armin Exp $
- *
- * ISDN interface module for Eicon active cards.
- * I4L - IDI Interface
- *
- * Copyright 1998-2000  by Armin Schindler (mac@melware.de) 
- * Copyright 1999-2002  Cytronics & Melware (info@melware.de)
- *
- * This software may be used and distributed according to the terms
- * of the GNU General Public License, incorporated herein by reference.
- */
-
-
-#ifndef i4lididrv_h
-#define i4lididrv_h
-
-#include <linux/isdn.h>
-#include <linux/isdnif.h>
-
-#include "platform.h"
-#include "di_defs.h"
-
-#define EICON_IOCTL_GETTYPE   6
-#define EICON_IOCTL_LOADPCI   7 
-#define EICON_IOCTL_GETVER    9 
-#define EICON_IOCTL_GETXLOG  10 
-
-#define EICON_IOCTL_MANIF    90 
-
-#define EICON_IOCTL_FREEIT   97
-#define EICON_IOCTL_TEST     98
-#define EICON_IOCTL_DEBUGVAR 99
-
-/* Constants for describing Card-Type */
-#define EICON_CTYPE_S            0
-#define EICON_CTYPE_SX           1
-#define EICON_CTYPE_SCOM         2
-#define EICON_CTYPE_QUADRO       3
-#define EICON_CTYPE_S2M          4
-#define EICON_CTYPE_MAESTRA      5
-#define EICON_CTYPE_MAESTRAQ     6
-#define EICON_CTYPE_MAESTRAQ_U   7
-#define EICON_CTYPE_MAESTRAP     8
-#define EICON_CTYPE_ISABRI       0x10
-#define EICON_CTYPE_ISAPRI       0x20
-#define EICON_CTYPE_MASK         0x0f
-#define EICON_CTYPE_QUADRO_NR(n) (n<<4)
-
-#define MAX_HEADER_LEN 10
-
-#define MAX_STATUS_BUFFER	150
-
-/* Data for Management interface */
-typedef struct {
-	int count;
-	int pos;
-	int length[50];
-	unsigned char data[700]; 
-} eicon_manifbuf;
-
-#define TRACE_OK                 (1)
-
-#ifdef __KERNEL__
-
-/* Macro for delay via schedule() */
-#define SLEEP(j) {                     \
-  set_current_state(TASK_INTERRUPTIBLE); \
-  schedule_timeout(j);                 \
-}
-
-/* Kernel includes */
-#include <linux/config.h>
-#include <linux/sched.h>
-#include <linux/skbuff.h>
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/mm.h>
-#include <linux/delay.h>
-#include <linux/ctype.h>
-
-typedef struct {
-  __u16 length __attribute__ ((packed)); /* length of data/parameter field */
-  __u8  P[1];                          /* data/parameter field */
-} eicon_PBUFFER;
-
-typedef struct {
-  __u16 NextReq  __attribute__ ((packed));  /* pointer to next Req Buffer */
-  __u16 NextRc   __attribute__ ((packed));  /* pointer to next Rc Buffer  */
-  __u16 NextInd  __attribute__ ((packed));  /* pointer to next Ind Buffer */
-  __u8 ReqInput  __attribute__ ((packed));  /* number of Req Buffers sent */
-  __u8 ReqOutput  __attribute__ ((packed)); /* number of Req Buffers returned */
-  __u8 ReqReserved  __attribute__ ((packed));/*number of Req Buffers reserved */
-  __u8 Int  __attribute__ ((packed));       /* ISDN-P interrupt           */
-  __u8 XLock  __attribute__ ((packed));     /* Lock field for arbitration */
-  __u8 RcOutput  __attribute__ ((packed));  /* number of Rc buffers received */
-  __u8 IndOutput  __attribute__ ((packed)); /* number of Ind buffers received */
-  __u8 IMask  __attribute__ ((packed));     /* Interrupt Mask Flag        */
-  __u8 Reserved1[2]  __attribute__ ((packed)); /* reserved field, do not use */
-  __u8 ReadyInt  __attribute__ ((packed));  /* request field for ready int */
-  __u8 Reserved2[12]  __attribute__ ((packed)); /* reserved field, do not use */
-  __u8 InterfaceType  __attribute__ ((packed)); /* interface type 1=16K    */
-  __u16 Signature  __attribute__ ((packed));    /* ISDN-P initialized ind  */
-  __u8 B[1];                            /* buffer space for Req,Ind and Rc */
-} eicon_pr_ram;
-
-typedef struct {
-  __u8                  Req;            /* pending request          */
-  __u8                  Rc;             /* return code received     */
-  __u8                  Ind;            /* indication received      */
-  __u8                  ReqCh;          /* channel of current Req   */
-  __u8                  RcCh;           /* channel of current Rc    */
-  __u8                  IndCh;          /* channel of current Ind   */
-  __u8                  D3Id;           /* ID used by this entity   */
-  __u8                  B2Id;           /* ID used by this entity   */
-  __u8                  GlobalId;       /* reserved field           */
-  __u8                  XNum;           /* number of X-buffers      */
-  __u8                  RNum;           /* number of R-buffers      */
-  struct sk_buff_head   X;              /* X-buffer queue           */
-  struct sk_buff_head   R;              /* R-buffer queue           */
-  __u8                  RNR;            /* receive not ready flag   */
-  __u8                  complete;       /* receive complete status  */
-  __u8                  busy;           /* busy flag                */
-  __u16                 ref;            /* saved reference          */
-} entity;
-
-#define FAX_MAX_SCANLINE 2500 
-
-typedef struct {
-	__u8		PrevObject;
-	__u8		NextObject;
-	__u8		abLine[FAX_MAX_SCANLINE];
-	__u8		abFrame[FAX_MAX_SCANLINE];
-	unsigned int	LineLen;
-	unsigned int	LineDataLen;
-	__u32		LineData;
-	unsigned int	NullBytesPos;
-	__u8		NullByteExist;
-	int		PageCount;
-	__u8		Dle;
-	__u8		Eop;
-} eicon_ch_fax_buf;
-
-typedef struct {
-	int	       No;		 /* Channel Number	        */
-	unsigned short fsm_state;        /* Current D-Channel state     */
-	unsigned short statectrl;	 /* State controling bits	*/
-	unsigned short eazmask;          /* EAZ-Mask for this Channel   */
-	int		queued;          /* User-Data Bytes in TX queue */
-	int		pqueued;         /* User-Data Packets in TX queue */
-	int		waitq;           /* User-Data Bytes in wait queue */
-	int		waitpq;          /* User-Data Bytes in packet queue */
-	struct sk_buff *tskb1;           /* temp skb 1			*/
-	struct sk_buff *tskb2;           /* temp skb 2			*/
-	unsigned char  l2prot;           /* Layer 2 protocol            */
-	unsigned char  l3prot;           /* Layer 3 protocol            */
-#ifdef CONFIG_ISDN_TTY_FAX
-	T30_s		*fax;		 /* pointer to fax data in LL	*/
-	eicon_ch_fax_buf fax2;		 /* fax related struct		*/
-#endif
-	entity		e;		 /* Native Entity		*/
-	ENTITY		de;		 /* Divas D Entity 		*/
-	ENTITY		be;		 /* Divas B Entity 		*/
-	char		cpn[32];	 /* remember cpn		*/
-	char		oad[32];	 /* remember oad		*/
-	char		dsa[32];	 /* remember dsa		*/
-	char		osa[32];	 /* remember osa		*/
-	unsigned char   cause[2];	 /* Last Cause			*/
-	unsigned char	si1;
-	unsigned char	si2;
-	unsigned char	plan;
-	unsigned char	screen;
-        unsigned char   a_para[8];       /* Additional parameter        */
-} eicon_chan;
-
-typedef struct {
-	eicon_chan *ptr;
-} eicon_chan_ptr;
-
-
-#define EICON_FLAGS_RUNNING  1 /* Cards driver activated */
-#define EICON_FLAGS_LOADED   8 /* Firmware loaded        */
-
-/* D-Channel states */
-#define EICON_STATE_NULL     0
-#define EICON_STATE_ICALL    1
-#define EICON_STATE_OCALL    2
-#define EICON_STATE_IWAIT    3
-#define EICON_STATE_OWAIT    4
-#define EICON_STATE_IBWAIT   5
-#define EICON_STATE_OBWAIT   6
-#define EICON_STATE_BWAIT    7
-#define EICON_STATE_BHWAIT   8
-#define EICON_STATE_BHWAIT2  9
-#define EICON_STATE_DHWAIT  10
-#define EICON_STATE_DHWAIT2 11
-#define EICON_STATE_BSETUP  12
-#define EICON_STATE_ACTIVE  13
-#define EICON_STATE_ICALLW  14
-#define EICON_STATE_LISTEN  15
-#define EICON_STATE_WMCONN  16
-
-#define EICON_MAX_QUEUE  2138
-
-typedef struct {
-	__u8 ret;
-	__u8 id;
-	__u8 ch;
-} eicon_ack;
-
-typedef struct {
-	__u8 code;
-	__u8 id;
-	__u8 ch;
-} eicon_req;
-
-typedef struct {
-	__u8 ret;
-	__u8 id;
-	__u8 ch;
-	__u8 more;
-} eicon_indhdr;
-
-/*
- * Per card driver data
- */
-typedef struct eicon_card {
-	DESCRIPTOR d;			 /* IDI Descriptor		     */
-        u_char ptype;                    /* Protocol type (1TR6 or Euro)     */
-        u_char type;                     /* Cardtype (EICON_CTYPE_...)       */
-	struct eicon_card *qnext;  	 /* Pointer to next quadro adapter   */
-        int Feature;                     /* Protocol Feature Value           */
-        struct eicon_card *next;	 /* Pointer to next device struct    */
-        int myid;                        /* Driver-Nr. assigned by linklevel */
-        unsigned long flags;             /* Statusflags                      */
-	struct sk_buff_head rcvq;        /* Receive-Message queue            */
-	struct sk_buff_head sndq;        /* Send-Message queue               */
-	struct sk_buff_head rackq;       /* Req-Ack-Message queue            */
-	struct sk_buff_head sackq;       /* Data-Ack-Message queue           */
-	struct sk_buff_head statq;       /* Status-Message queue             */
-	int statq_entries;
-	eicon_chan*	IdTable[256];	 /* Table to find entity   */
-	__u16  ref_in;
-	__u16  ref_out;
-	int    nchannels;                /* Number of B-Channels             */
-	int    ReadyInt;		 /* Ready Interrupt		     */
-	eicon_chan *bch;                 /* B-Channel status/control         */
-	DBUFFER *dbuf;			 /* Dbuffer for Diva Server	     */
-	BUFFERS *sbuf;			 /* Buffer for Diva Server	     */
-	char *sbufp;			 /* Data Buffer for Diva Server	     */
-        isdn_if interface;               /* Interface to upper layer         */
-        char regname[35];                /* Drivers card name 		     */
-	spinlock_t lock;		 /* spin lock per card		     */
-        struct tq_struct tq;             /* task queue for thread            */
-} eicon_card;
-
-#include "i4l_idi.h"
-
-extern eicon_card *cards;
-extern char *eicon_ctype_name[];
-
-extern ulong DebugVar;
-extern void eicon_log(eicon_card * card, int level, const char *fmt, ...);
-extern void eicon_putstatus(eicon_card * card, char * buf);
-
-extern void eicon_tx_request(struct eicon_card *);
-
-extern spinlock_t eicon_lock;
-
-#endif  /* __KERNEL__ */
-
-#endif	/* i4lididrv_h */
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/idifunc.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/idifunc.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/idifunc.c	2003-09-09 10:02:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/idifunc.c	2004-03-21 18:34:18.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: idifunc.c,v 1.13 2003/08/25 14:49:53 schindler Exp $
+/* $Id: idifunc.c,v 1.14 2004/03/21 18:13:43 armin Exp $
  *
  * Driver for Eicon DIVA Server ISDN cards.
  * User Mode IDI Interface 
@@ -49,76 +49,37 @@ static void stop_dbg(void)
 }
 
 typedef struct _udiva_card {
-	struct _udiva_card *next;
+	struct list_head list;
 	int Id;
 	DESCRIPTOR d;
 } udiva_card;
 
-static udiva_card *cards;
+static LIST_HEAD(cards);
 static diva_os_spin_lock_t ll_lock;
 
 /*
- * add card to list
- */
-static void add_card_to_list(udiva_card * c)
-{
-	diva_os_spin_lock_magic_t old_irql;
-
-	diva_os_enter_spin_lock(&ll_lock, &old_irql, "add card");
-	c->next = cards;
-	cards = c;
-	diva_os_leave_spin_lock(&ll_lock, &old_irql, "add card");
-}
-
-/*
  * find card in list
  */
 static udiva_card *find_card_in_list(DESCRIPTOR * d)
 {
 	udiva_card *card;
+	struct list_head *tmp;
 	diva_os_spin_lock_magic_t old_irql;
 
 	diva_os_enter_spin_lock(&ll_lock, &old_irql, "find card");
-	card = cards;
-	while (card) {
+	list_for_each(tmp, &cards) {
+		card = list_entry(tmp, udiva_card, list);
 		if (card->d.request == d->request) {
 			diva_os_leave_spin_lock(&ll_lock, &old_irql,
 						"find card");
 			return (card);
 		}
-		card = card->next;
 	}
 	diva_os_leave_spin_lock(&ll_lock, &old_irql, "find card");
 	return ((udiva_card *) NULL);
 }
 
 /*
- * remove card from list
- */
-static void remove_card_from_list(udiva_card * c)
-{
-	udiva_card *list = NULL, *last;
-	diva_os_spin_lock_magic_t old_irql;
-
-	diva_os_enter_spin_lock(&ll_lock, &old_irql, "remove card");
-	list = cards;
-	last = list;
-	while (list) {
-		if (list == c) {
-			if (cards == c) {
-				cards = c->next;
-			} else {
-				last->next = c->next;
-			}
-			break;
-		}
-		last = list;
-		list = list->next;
-	}
-	diva_os_leave_spin_lock(&ll_lock, &old_irql, "remove card");
-}
-
-/*
  * new card
  */
 static void um_new_card(DESCRIPTOR * d)
@@ -126,6 +87,7 @@ static void um_new_card(DESCRIPTOR * d)
 	int adapter_nr = 0;
 	udiva_card *card = NULL;
 	IDI_SYNC_REQ sync_req;
+	diva_os_spin_lock_magic_t old_irql;
 
 	if (!(card = diva_os_malloc(0, sizeof(udiva_card)))) {
 		DBG_ERR(("cannot get buffer for card"));
@@ -140,7 +102,9 @@ static void um_new_card(DESCRIPTOR * d)
 	    sync_req.xdi_logical_adapter_number.info.logical_adapter_number;
 	card->Id = adapter_nr;
 	if (!(diva_user_mode_idi_create_adapter(d, adapter_nr))) {
-		add_card_to_list(card);
+		diva_os_enter_spin_lock(&ll_lock, &old_irql, "add card");
+		list_add_tail(&card->list, &cards);
+		diva_os_leave_spin_lock(&ll_lock, &old_irql, "add card");
 	} else {
 		DBG_ERR(("could not create user mode idi card %d",
 			 adapter_nr));
@@ -152,6 +116,7 @@ static void um_new_card(DESCRIPTOR * d)
  */
 static void um_remove_card(DESCRIPTOR * d)
 {
+	diva_os_spin_lock_magic_t old_irql;
 	udiva_card *card = NULL;
 
 	if (!(card = find_card_in_list(d))) {
@@ -159,7 +124,9 @@ static void um_remove_card(DESCRIPTOR * 
 		return;
 	}
 	diva_user_mode_idi_remove_adapter(card->Id);
-	remove_card_from_list(card);
+	diva_os_enter_spin_lock(&ll_lock, &old_irql, "remove card");
+	list_del(&card->list);
+	diva_os_leave_spin_lock(&ll_lock, &old_irql, "remove card");
 	DBG_LOG(("idi proc entry removed for card %d", card->Id));
 	diva_os_free(0, card);
 }
@@ -169,20 +136,20 @@ static void um_remove_card(DESCRIPTOR * 
  */
 static void DIVA_EXIT_FUNCTION remove_all_idi_proc(void)
 {
-	udiva_card *card, *last;
+	udiva_card *card;
+	struct list_head *tmp;
 	diva_os_spin_lock_magic_t old_irql;
 
+rescan:
 	diva_os_enter_spin_lock(&ll_lock, &old_irql, "remove all");
-	card = cards;
-	cards = NULL;
+	list_for_each(tmp, &cards) {
+		card = list_entry(tmp, udiva_card, list);
 	diva_os_leave_spin_lock(&ll_lock, &old_irql, "remove all");
-
-	while (card) {
 		diva_user_mode_idi_remove_adapter(card->Id);
-		last = card;
-		card = card->next;
-		diva_os_free(0, last);
+		diva_os_free(0, card);
+		goto rescan;
 	}
+	diva_os_leave_spin_lock(&ll_lock, &old_irql, "remove all");
 }
 
 /*
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/os_4bri.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/os_4bri.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/os_4bri.c	2003-09-09 10:02:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/os_4bri.c	2004-03-21 18:34:18.000000000 +0000
@@ -1,9 +1,8 @@
-/* $Id: os_4bri.c,v 1.25 2003/06/21 17:08:44 schindler Exp $ */
+/* $Id: os_4bri.c,v 1.28 2004/03/21 17:26:01 armin Exp $ */
 
 #include "platform.h"
 #include "debuglib.h"
 #include "cardtype.h"
-#include "dlist.h"
 #include "pc.h"
 #include "pr_pc.h"
 #include "di_defs.h"
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/os_bri.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/os_bri.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/os_bri.c	2003-09-09 10:02:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/os_bri.c	2004-03-21 18:34:18.000000000 +0000
@@ -1,9 +1,8 @@
-/* $Id: os_bri.c,v 1.18 2003/06/21 17:10:29 schindler Exp $ */
+/* $Id: os_bri.c,v 1.21 2004/03/21 17:26:01 armin Exp $ */
 
 #include "platform.h"
 #include "debuglib.h"
 #include "cardtype.h"
-#include "dlist.h"
 #include "pc.h"
 #include "pr_pc.h"
 #include "di_defs.h"
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/os_pri.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/os_pri.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/os_pri.c	2003-09-09 10:02:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/os_pri.c	2004-03-21 18:34:18.000000000 +0000
@@ -1,9 +1,8 @@
-/* $Id: os_pri.c,v 1.29 2003/08/25 13:41:27 schindler Exp $ */
+/* $Id: os_pri.c,v 1.32 2004/03/21 17:26:01 armin Exp $ */
 
 #include "platform.h"
 #include "debuglib.h"
 #include "cardtype.h"
-#include "dlist.h"
 #include "pc.h"
 #include "pr_pc.h"
 #include "di_defs.h"
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/platform.h linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/platform.h
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/platform.h	2004-01-19 23:38:02.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/platform.h	2004-03-20 18:18:26.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: platform.h,v 1.35 2003/12/05 18:45:05 armin Exp $
+/* $Id: platform.h,v 1.37 2004/03/20 17:44:29 armin Exp $
  *
  * platform.h
  * 
@@ -29,6 +29,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp_lock.h>
 #include <linux/delay.h>
+#include <linux/list.h>
 #include <asm/types.h>
 #include <asm/io.h>
 
@@ -332,7 +333,6 @@ diva_os_atomic_decrement(diva_os_atomic_
 */
 #define NO_CORNETN
 #define IMPLEMENT_DTMF 1
-#define IMPLEMENT_LINE_INTERCONNECT2 1
 #define IMPLEMENT_ECHO_CANCELLER 1
 #define IMPLEMENT_RTP 1
 #define IMPLEMENT_T38 1
@@ -346,7 +346,6 @@ diva_os_atomic_decrement(diva_os_atomic_
 #define IMPLEMENT_FAX_NONSTANDARD 1
 #define VSWITCH_SUPPORT 1
 
-#define IMPLEMENT_LINE_INTERCONNECT  0
 #define IMPLEMENT_MARKED_OK_AFTER_FC 1
 
 #define DIVA_IDI_RX_DMA 1
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/um_idi.c linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/um_idi.c
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/um_idi.c	2004-01-19 23:38:02.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/um_idi.c	2004-03-21 18:34:18.000000000 +0000
@@ -1,9 +1,8 @@
-/* $Id: um_idi.c,v 1.12 2004/01/12 18:00:09 armin Exp $ */
+/* $Id: um_idi.c,v 1.14 2004/03/21 17:54:37 armin Exp $ */
 
 #include "platform.h"
 #include "di_defs.h"
 #include "pc.h"
-#include "dlist.h"
 #include "dqueue.h"
 #include "adapter.h"
 #include "entity.h"
@@ -22,7 +21,7 @@ extern void diva_os_wakeup_close(void *o
 /* --------------------------------------------------------------------------
 		LOCALS
    -------------------------------------------------------------------------- */
-static diva_entity_queue_t adapter_q;
+static LIST_HEAD(adapter_q);
 static diva_os_spin_lock_t adapter_lock;
 
 static diva_um_idi_adapter_t *diva_um_idi_find_adapter(dword nr);
@@ -37,17 +36,11 @@ static int process_idi_rc(divas_um_idi_e
 static int process_idi_ind(divas_um_idi_entity_t * e, byte ind);
 static int write_return_code(divas_um_idi_entity_t * e, byte rc);
 
-/*
- * include queue functions
- */
-#include "dlist.c"
-
 /* --------------------------------------------------------------------------
 		MAIN
    -------------------------------------------------------------------------- */
 int diva_user_mode_idi_init(void)
 {
-	diva_q_init(&adapter_q);
 	diva_os_initialize_spin_lock(&adapter_lock, "adapter");
 	return (0);
 }
@@ -89,18 +82,18 @@ diva_user_mode_idi_adapter_features(diva
    -------------------------------------------------------------------------- */
 void diva_user_mode_idi_remove_adapter(int adapter_nr)
 {
-	diva_um_idi_adapter_t *a =
-	    (diva_um_idi_adapter_t *) diva_q_get_head(&adapter_q);
+	struct list_head *tmp;
+	diva_um_idi_adapter_t *a;
 
-	while (a) {
+	list_for_each(tmp, &adapter_q) {
+		a = list_entry(tmp, diva_um_idi_adapter_t, link);
 		if (a->adapter_nr == adapter_nr) {
-			diva_q_remove(&adapter_q, &a->link);
+			list_del(tmp);
 			cleanup_adapter(a);
 			DBG_LOG(("DIDD: del adapter(%d)", a->adapter_nr));
 			diva_os_free(0, a);
 			break;
 		}
-		a = (diva_um_idi_adapter_t *) diva_q_get_next(&a->link);
 	}
 }
 
@@ -109,15 +102,15 @@ void diva_user_mode_idi_remove_adapter(i
    -------------------------------------------------------------------------- */
 void diva_user_mode_idi_finit(void)
 {
-	diva_um_idi_adapter_t *a =
-	    (diva_um_idi_adapter_t *) diva_q_get_head(&adapter_q);
+	struct list_head *tmp, *safe;
+	diva_um_idi_adapter_t *a;
 
-	while (a) {
-		diva_q_remove(&adapter_q, &a->link);
+	list_for_each_safe(tmp, safe, &adapter_q) {
+		a = list_entry(tmp, diva_um_idi_adapter_t, link);
+		list_del(tmp);
 		cleanup_adapter(a);
 		DBG_LOG(("DIDD: del adapter(%d)", a->adapter_nr));
 		diva_os_free(0, a);
-		a = (diva_um_idi_adapter_t *) diva_q_get_head(&adapter_q);
 	}
 	diva_os_destroy_spin_lock(&adapter_lock, "adapter");
 }
@@ -137,6 +130,7 @@ int diva_user_mode_idi_create_adapter(co
 		return (-1);
 	}
 	memset(a, 0x00, sizeof(*a));
+	INIT_LIST_HEAD(&a->entity_q);
 
 	a->d = *d;
 	a->adapter_nr = adapter_nr;
@@ -145,46 +139,27 @@ int diva_user_mode_idi_create_adapter(co
 		 adapter_nr, a->d.type, a->d.features, a->d.channels));
 
 	diva_os_enter_spin_lock(&adapter_lock, &old_irql, "create_adapter");
-	diva_q_add_tail(&adapter_q, &a->link);
+	list_add_tail(&a->link, &adapter_q);
 	diva_os_leave_spin_lock(&adapter_lock, &old_irql, "create_adapter");
 	return (0);
 }
 
-static int cmp_adapter_nr(const void *what, const diva_entity_link_t * p)
-{
-	diva_um_idi_adapter_t *a = (diva_um_idi_adapter_t *) p;
-	dword nr = (dword) (unsigned long) what;
-
-	DBG_TRC(("find_adapter: (%d)-(%d)", nr, a->adapter_nr));
-
-	return (nr != a->adapter_nr);
-}
-
 /* ------------------------------------------------------------------------
 			Find adapter by Adapter number
    ------------------------------------------------------------------------ */
 static diva_um_idi_adapter_t *diva_um_idi_find_adapter(dword nr)
 {
-	return (diva_um_idi_adapter_t *) diva_q_find(&adapter_q,
-						     (void *) (unsigned
-							       long) nr,
-						     cmp_adapter_nr);
-}
-
-/* ------------------------------------------------------------------------
-		Return number of adapters in system
-   ------------------------------------------------------------------------ */
-int diva_um_idi_nr_of_adapters(void)
-{
-	int i = 0;
-	const diva_entity_queue_t * q = &adapter_q;
-	const diva_entity_link_t *diva_current = q->head;
+	diva_um_idi_adapter_t *a = NULL;
+	struct list_head *tmp;
 
-	while (diva_current) {
-		i++;
-		diva_current = diva_current->next;
+	list_for_each(tmp, &adapter_q) {
+		a = list_entry(tmp, diva_um_idi_adapter_t, link);
+		DBG_TRC(("find_adapter: (%d)-(%d)", nr, a->adapter_nr));
+		if (a->adapter_nr == (int)nr)
+			break;
+		a = NULL;
 	}
-	return(i);
+	return(a);
 }
 
 /* ------------------------------------------------------------------------
@@ -193,17 +168,17 @@ int diva_um_idi_nr_of_adapters(void)
    ------------------------------------------------------------------------ */
 static void cleanup_adapter(diva_um_idi_adapter_t * a)
 {
-	divas_um_idi_entity_t *e =
-	    (divas_um_idi_entity_t *) diva_q_get_head(&a->entity_q);
+	struct list_head *tmp, *safe;
+	divas_um_idi_entity_t *e;
 
-	while (e) {
-		diva_q_remove(&a->entity_q, &e->link);
+	list_for_each_safe(tmp, safe, &a->entity_q) {
+		e = list_entry(tmp, divas_um_idi_entity_t, link);
+		list_del(tmp);
 		cleanup_entity(e);
 		if (e->os_context) {
 			diva_os_wakeup_read(e->os_context);
 			diva_os_wakeup_close(e->os_context);
 		}
-		e = (divas_um_idi_entity_t *) diva_q_get_head(&a->entity_q);
 	}
 	memset(&a->d, 0x00, sizeof(DESCRIPTOR));
 }
@@ -281,7 +256,7 @@ void *divas_um_idi_create_entity(dword a
 		e->os_ref = file;	/* link to os handle */
 		e->adapter = a;	/* link to adapter   */
 
-		diva_q_add_tail(&a->entity_q, &e->link);	/* link from adapter */
+		list_add_tail(&e->link, &a->entity_q);	/* link from adapter */
 
 		diva_os_leave_spin_lock(&adapter_lock, &old_irql, "create_entity");
 
@@ -305,7 +280,7 @@ int divas_um_idi_delete_entity(int adapt
 
 	diva_os_enter_spin_lock(&adapter_lock, &old_irql, "delete_entity");
 	if ((a = e->adapter)) {
-		diva_q_remove(&a->entity_q, &e->link);
+		list_del(&e->link);
 	}
 	diva_os_leave_spin_lock(&adapter_lock, &old_irql, "delete_entity");
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/um_idi.h linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/um_idi.h
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/um_idi.h	2002-11-13 20:59:12.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/um_idi.h	2004-03-21 18:34:18.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: um_idi.h,v 1.1.2.2 2002/10/02 14:38:38 armin Exp $ */
+/* $Id: um_idi.h,v 1.6 2004/03/21 17:26:01 armin Exp $ */
 
 #ifndef __DIVA_USER_MODE_IDI_CORE_H__
 #define __DIVA_USER_MODE_IDI_CORE_H__
@@ -9,7 +9,6 @@
   */
 int diva_user_mode_idi_init(void);
 void diva_user_mode_idi_finit(void);
-int diva_um_idi_nr_of_adapters(void);
 void *divas_um_idi_create_entity(dword adapter_nr, void *file);
 int divas_um_idi_delete_entity(int adapter_nr, void *entity);
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/xdi_adapter.h linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/xdi_adapter.h
--- linux-post-2.6.5-rc2-20040320/drivers/isdn/hardware/eicon/xdi_adapter.h	2004-01-19 23:38:02.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/isdn/hardware/eicon/xdi_adapter.h	2004-03-21 18:34:18.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: xdi_adapter.h,v 1.6 2003/12/05 18:45:05 armin Exp $ */
+/* $Id: xdi_adapter.h,v 1.7 2004/03/21 17:26:01 armin Exp $ */
 
 #ifndef __DIVA_OS_XDI_ADAPTER_H__
 #define __DIVA_OS_XDI_ADAPTER_H__
@@ -47,7 +47,7 @@ typedef struct _diva_os_idi_adapter_inte
 } diva_os_idi_adapter_interface_t;
 
 typedef struct _diva_os_xdi_adapter {
-	diva_entity_link_t link;
+	struct list_head link;
 	int CardIndex;
 	int CardOrdinal;
 	int controller;		/* number of this controller */
diff -purN linux-post-2.6.5-rc2-20040320/drivers/macintosh/therm_windtunnel.c linux-post-2.6.5-rc2-20040323/drivers/macintosh/therm_windtunnel.c
--- linux-post-2.6.5-rc2-20040320/drivers/macintosh/therm_windtunnel.c	2004-02-05 06:23:52.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/macintosh/therm_windtunnel.c	2004-03-20 14:45:16.000000000 +0000
@@ -1,24 +1,23 @@
 /* 
  *   Creation Date: <2003/03/14 20:54:13 samuel>
- *   Time-stamp: <2003/03/15 18:55:53 samuel>
+ *   Time-stamp: <2004/03/20 14:20:59 samuel>
  *   
  *	<therm_windtunnel.c>
  *	
- *	The G4 "windtunnel" has a single fan controlled by a
- *	DS1775 fan controller and an ADM1030 thermostat.
+ *	The G4 "windtunnel" has a single fan controlled by an
+ *	ADM1030 fan controller and a DS1775 thermostat.
  *
  *	The fan controller is equipped with a temperature sensor
- *	which measures the case temperature. The ADM censor
+ *	which measures the case temperature. The DS1775 sensor
  *	measures the CPU temperature. This driver tunes the
  *	behavior of the fan. It is based upon empirical observations
- *	of the 'AppleFan' driver under OSX.
+ *	of the 'AppleFan' driver under Mac OS X.
  *
  *	WARNING: This driver has only been testen on Apple's
- *	1.25 MHz Dual G4 (March 03). Other machines might have
- *	a different thermal design. It is tuned for a CPU
+ *	1.25 MHz Dual G4 (March 03). It is tuned for a CPU
  *	temperatur around 57 C.
  *
- *   Copyright (C) 2003 Samuel Rydh (samuel@ibrium.se)
+ *   Copyright (C) 2003, 2004 Samuel Rydh (samuel@ibrium.se)
  *
  *   Loosely based upon 'thermostat.c' written by Benjamin Herrenschmidt
  *   
@@ -38,50 +37,37 @@
 #include <linux/i2c.h>
 #include <linux/slab.h>
 #include <linux/init.h>
-#include <linux/workqueue.h>
 #include <asm/prom.h>
 #include <asm/machdep.h>
 #include <asm/io.h>
 #include <asm/system.h>
 #include <asm/sections.h>
-
-MODULE_AUTHOR("Samuel Rydh <samuel@ibrium.se>");
-MODULE_DESCRIPTION("Apple G4 (windtunnel) fan driver");
-MODULE_LICENSE("GPL");
+#include <asm/of_device.h>
 
 #define LOG_TEMP		0			/* continously log temperature */
 
-/* scan 0x48-0x4f (DS1775) and 0x2c-2x2f (ADM1030) */
-static unsigned short normal_i2c[] = { 0x49, 0x2c, I2C_CLIENT_END };
-static unsigned short normal_i2c_range[] = { 0x48, 0x4f, 0x2c, 0x2f, I2C_CLIENT_END };
-static struct work_struct poll_work;
-
-I2C_CLIENT_INSMOD;
-
 #define I2C_DRIVERID_G4FAN	0x9001			/* fixme */
-
 #define THERMOSTAT_CLIENT_ID	1
 #define FAN_CLIENT_ID		2
 
-struct temp_range {
-	u8			high;			/* start the fan */
-	u8			low;			/* stop the fan */
-};
-struct apple_thermal_info {
-	u8			id;			/* implementation ID */
-	u8			fan_count;		/* number of fans */
-	u8			thermostat_count;	/* number of thermostats */
-	u8			unused[5];
-	struct temp_range	ranges[4];		/* temperature ranges (may be [])*/
-};
+static int 			do_probe( struct i2c_adapter *adapter, int addr, int kind);
 
-static int do_detect( struct i2c_adapter *adapter, int addr, int kind);
+/* scan 0x48-0x4f (DS1775) and 0x2c-2x2f (ADM1030) */
+static unsigned short		normal_i2c[] = { 0x49, 0x2c, I2C_CLIENT_END };
+static unsigned short		normal_i2c_range[] = { 0x48, 0x4f, 0x2c, 0x2f, I2C_CLIENT_END };
+
+I2C_CLIENT_INSMOD;
 
 static struct {
+	volatile int		running;
+	struct completion	completion;
+	pid_t			poll_task;
+	
+	struct semaphore 	lock;
+	struct of_device	*of_dev;
+	
 	struct i2c_client	*thermostat;
 	struct i2c_client	*fan;
-	int			error;
-	struct timer_list	timer;
 
 	int			overheat_temp;		/* 100% fan at this temp */
 	int			overheat_hyst;
@@ -95,37 +81,54 @@ static struct {
 	int			r0, r1, r20, r23, r25;	/* saved register */
 } x;
 
+#define T(x,y)			(((x)<<8) | (y)*0x100/10 )
+
 static struct {
+	int			fan_down_setting;
 	int			temp;
-	int			fan_setting;
-} fan_up_table[] = {
-	{ 0x0000, 11 },		/* min fan */
-	{ 0x3900, 8 },		/* 57.0 C */
-	{ 0x3a4a, 7 },		/* 58.3 C */
-	{ 0x3ad3, 6 },		/* 58.8 C */
-	{ 0x3b3c, 5 },		/* 59.2 C */
-	{ 0x3b94, 4 },		/* 59.6 C */
-	{ 0x3be3, 3 },		/* 58.9 C */
-	{ 0x3c29, 2 },		/* 59.2 C */
-	{ 0xffff, 1 }		/* on fire */
-};
-static struct {
-	int			temp;
-	int			fan_setting;
-} fan_down_table[] = {
-	{ 0x3700, 11 },		/* 55.0 C */
-	{ 0x374a, 6 },
-	{ 0x3800, 7 },		/* 56.0 C */
-	{ 0x3900, 8 },		/* 57.0 C */
-	{ 0x3a4a, 7 },		/* 58.3 C */
-	{ 0x3ad3, 6 },		/* 58.8 C */
-	{ 0x3b3c, 5 },		/* 59.2 C */
-	{ 0x3b94, 4 },		/* 58.9 C */
-	{ 0x3be3, 3 },		/* 58.9 C */
-	{ 0x3c29, 2 },		/* 59.2 C */
-	{ 0xffff, 1 }
+	int			fan_up_setting;
+} fan_table[] = {
+	{ 11, T(0,0),  11 },	/* min fan */
+	{ 11, T(55,0), 11 },
+	{  6, T(55,3), 11 },
+	{  7, T(56,0), 11 },
+	{  8, T(57,0), 8 },
+	{  7, T(58,3), 7 },
+	{  6, T(58,8), 6 },
+	{  5, T(59,2), 5 },
+	{  4, T(59,6), 4 },
+	{  3, T(59,9), 3 },
+	{  2, T(60,1), 2 },
+	{  1, 0xfffff, 1 }	/* on fire */
 };
 
+static void
+print_temp( const char *s, int temp )
+{
+	printk("%s%d.%d C", s ? s : "", temp>>8, (temp & 255)*10/256 );
+}
+
+static ssize_t
+show_cpu_temperature( struct device *dev, char *buf )
+{
+	return sprintf(buf, "%d.%d\n", x.temp>>8, (x.temp & 255)*10/256 );
+}
+
+static ssize_t
+show_case_temperature( struct device *dev, char *buf )
+{
+	return sprintf(buf, "%d.%d\n", x.casetemp>>8, (x.casetemp & 255)*10/256 );
+}
+
+static DEVICE_ATTR(cpu_temperature, S_IRUGO, show_cpu_temperature, NULL );
+static DEVICE_ATTR(case_temperature, S_IRUGO, show_case_temperature, NULL );
+
+
+
+/************************************************************************/
+/*	controller thread						*/
+/************************************************************************/
+
 static int
 write_reg( struct i2c_client *cl, int reg, int data, int len )
 {
@@ -159,37 +162,32 @@ read_reg( struct i2c_client *cl, int reg
 	return (len == 2)? ((unsigned int)buf[0] << 8) | buf[1] : buf[0];
 }
 
-
-static void
-print_temp( const char *s, int temp )
-{
-	printk("%s%d.%d C", s ? s : "", temp>>8, (temp & 255)*10/256 );
-}
-
 static void
 tune_fan( int fan_setting )
 {
 	int val = (fan_setting << 3) | 7;
-	x.fan_level = fan_setting;
-	
-	//write_reg( x.fan, 0x24, val, 1 );
+
+	/* write_reg( x.fan, 0x24, val, 1 ); */
 	write_reg( x.fan, 0x25, val, 1 );
 	write_reg( x.fan, 0x20, 0, 1 );
 	print_temp("CPU-temp: ", x.temp );
 	if( x.casetemp )
 		print_temp(", Case: ", x.casetemp );
-	printk("  Tuning fan: %d (%02x)\n", fan_setting, val );
+	printk(",  Fan: %d (tuned %+d)\n", 11-fan_setting, x.fan_level-fan_setting );
+
+	x.fan_level = fan_setting;
 }
 
 static void
-poll_temp( void *param )
+poll_temp( void )
 {
-	int temp = read_reg( x.thermostat, 0, 2 );
-	int i, level, casetemp;
+	int temp, i, level, casetemp;
+
+	temp = read_reg( x.thermostat, 0, 2 );
 
 	/* this actually occurs when the computer is loaded */
 	if( temp < 0 )
-		goto out;
+		return;
 
 	casetemp = read_reg(x.fan, 0x0b, 1) << 8;
 	casetemp |= (read_reg(x.fan, 0x06, 1) & 0x7) << 5;
@@ -197,37 +195,117 @@ poll_temp( void *param )
 	if( LOG_TEMP && x.temp != temp ) {
 		print_temp("CPU-temp: ", temp );
 		print_temp(", Case: ", casetemp );
-		printk(",  Fan: %d\n", x.fan_level );
+		printk(",  Fan: %d\n", 11-x.fan_level );
 	}
 	x.temp = temp;
 	x.casetemp = casetemp;
 
 	level = -1;
-	for( i=0; (temp & 0xffff) > fan_down_table[i].temp ; i++ )
+	for( i=0; (temp & 0xffff) > fan_table[i].temp ; i++ )
 		;
 	if( i < x.downind )
-		level = fan_down_table[i].fan_setting;
+		level = fan_table[i].fan_down_setting;
 	x.downind = i;
 
-	for( i=0; (temp & 0xfffe) >= fan_up_table[i+1].temp ; i++ )
+	for( i=0; (temp & 0xffff) >= fan_table[i+1].temp ; i++ )
 		;
 	if( x.upind < i )
-		level = fan_up_table[i].fan_setting;
+		level = fan_table[i].fan_up_setting;
 	x.upind = i;
 
 	if( level >= 0 )
 		tune_fan( level );
- out:
-	x.timer.expires = jiffies + 8*HZ;
-	add_timer( &x.timer );
+}
+
+
+static void
+setup_hardware( void )
+{
+	int val;
+
+	/* save registers (if we unload the module) */
+	x.r0 = read_reg( x.fan, 0x00, 1 );
+	x.r1 = read_reg( x.fan, 0x01, 1 );
+	x.r20 = read_reg( x.fan, 0x20, 1 );
+	x.r23 = read_reg( x.fan, 0x23, 1 );
+	x.r25 = read_reg( x.fan, 0x25, 1 );
+
+	/* improve measurement resolution (convergence time 1.5s) */
+	if( (val=read_reg(x.thermostat, 1, 1)) >= 0 ) {
+		val |= 0x60;
+		if( write_reg( x.thermostat, 1, val, 1 ) )
+			printk("Failed writing config register\n");
+	}
+	/* disable interrupts and TAC input */
+	write_reg( x.fan, 0x01, 0x01, 1 );
+	/* enable filter */
+	write_reg( x.fan, 0x23, 0x91, 1 );
+	/* remote temp. controls fan */
+	write_reg( x.fan, 0x00, 0x95, 1 );
+
+	/* The thermostat (which besides measureing temperature controls
+	 * has a THERM output which puts the fan on 100%) is usually
+	 * set to kick in at 80 C (chip default). We reduce this a bit
+	 * to be on the safe side (OSX doesn't)...
+	 */
+	if( x.overheat_temp == (80 << 8) ) {
+		x.overheat_temp = 65 << 8;
+		x.overheat_hyst = 60 << 8;
+		write_reg( x.thermostat, 2, x.overheat_hyst, 2 );
+		write_reg( x.thermostat, 3, x.overheat_temp, 2 );
+
+		print_temp("Reducing overheating limit to ", x.overheat_temp );
+		print_temp(" (Hyst: ", x.overheat_hyst );
+		printk(")\n");
+	}
+
+	/* set an initial fan setting */
+	x.downind = 0xffff;
+	x.upind = -1;
+	/* tune_fan( fan_up_table[x.upind].fan_setting ); */
+
+	device_create_file( &x.of_dev->dev, &dev_attr_cpu_temperature );
+	device_create_file( &x.of_dev->dev, &dev_attr_case_temperature );
 }
 
 static void
-schedule_poll( unsigned long t )
+restore_regs( void )
 {
-	schedule_work(&poll_work);
+	device_remove_file( &x.of_dev->dev, &dev_attr_cpu_temperature );
+	device_remove_file( &x.of_dev->dev, &dev_attr_case_temperature );
+
+	write_reg( x.fan, 0x01, x.r1, 1 );
+	write_reg( x.fan, 0x20, x.r20, 1 );
+	write_reg( x.fan, 0x23, x.r23, 1 );
+	write_reg( x.fan, 0x25, x.r25, 1 );
+	write_reg( x.fan, 0x00, x.r0, 1 );
 }
 
+static int
+control_loop( void *dummy )
+{
+	daemonize("g4fand");
+
+	down( &x.lock );
+	setup_hardware();
+
+	while( x.running ) {
+		up( &x.lock );
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout( 8*HZ );
+		
+		down( &x.lock );
+		poll_temp();
+	}
+
+	restore_regs();
+	up( &x.lock );
+
+	complete_and_exit( &x.completion, 0 );
+}
+
+
 /************************************************************************/
 /*	i2c probing and setup						*/
 /************************************************************************/
@@ -235,7 +313,20 @@ schedule_poll( unsigned long t )
 static int
 do_attach( struct i2c_adapter *adapter )
 {
-	return i2c_probe( adapter, &addr_data, &do_detect );
+	int ret = 0;
+
+	if( strncmp(adapter->name, "uni-n", 5) )
+		return 0;
+
+	if( !x.running ) {
+		ret = i2c_probe( adapter, &addr_data, &do_probe );
+		if( x.thermostat && x.fan ) {
+			x.running = 1;
+			init_completion( &x.completion );
+			x.poll_task = kernel_thread( control_loop, NULL, SIGCHLD | CLONE_KERNEL );
+		}
+	}
+	return ret;
 }
 
 static int
@@ -243,13 +334,23 @@ do_detach( struct i2c_client *client )
 {
 	int err;
 
-	printk("do_detach: id %d\n", client->id );
-	if( (err=i2c_detach_client(client)) ) {
-		printk("failed to detach thermostat client\n");
-		return err;
+	if( (err=i2c_detach_client(client)) )
+		printk(KERN_ERR "failed to detach thermostat client\n");
+	else {
+		if( x.running ) {
+			x.running = 0;
+			wait_for_completion( &x.completion );
+		}
+		if( client == x.thermostat )
+			x.thermostat = NULL;
+		else if( client == x.fan )
+			x.fan = NULL;
+		else {
+			printk(KERN_ERR "g4fan: bad client\n");
+		}
+		kfree( client );
 	}
-	kfree( client );
-	return 0;
+	return err;
 }
 
 static struct i2c_driver g4fan_driver = {  
@@ -262,24 +363,21 @@ static struct i2c_driver g4fan_driver = 
 };
 
 static int
-detect_fan( struct i2c_client *cl )
+attach_fan( struct i2c_client *cl )
 {
+	if( x.fan )
+		goto out;
+
 	/* check that this is an ADM1030 */
 	if( read_reg(cl, 0x3d, 1) != 0x30 || read_reg(cl, 0x3e, 1) != 0x41 )
 		goto out;
-	printk("ADM1030 fan controller detected at %02x\n", cl->addr );
+	printk("ADM1030 fan controller [@%02x]\n", cl->addr );
 
-	if( x.fan ) {
-		x.error |= 2;
-		goto out;
-	}
-	x.fan = cl;
 	cl->id = FAN_CLIENT_ID;
-	strncpy( cl->name, "ADM1030 fan controller", sizeof(cl->name) );
+	strlcpy( cl->name, "ADM1030 fan controller", sizeof(cl->name) );
 
-	if( i2c_attach_client( cl ) )
-		goto out;
-	return 0;
+	if( !i2c_attach_client(cl) )
+		x.fan = cl;
  out:
 	if( cl != x.fan )
 		kfree( cl );
@@ -287,10 +385,13 @@ detect_fan( struct i2c_client *cl )
 }
 
 static int
-detect_thermostat( struct i2c_client *cl ) 
+attach_thermostat( struct i2c_client *cl ) 
 {
 	int hyst_temp, os_temp, temp;
 
+	if( x.thermostat )
+		goto out;
+
 	if( (temp=read_reg(cl, 0, 2)) < 0 )
 		goto out;
 	
@@ -302,44 +403,37 @@ detect_thermostat( struct i2c_client *cl
 	if( hyst_temp < 0 || os_temp < 0 )
 		goto out;
 
-	printk("DS1775 digital thermometer detected at %02x\n", cl->addr );
+	printk("DS1775 digital thermometer [@%02x]\n", cl->addr );
 	print_temp("Temp: ", temp );
 	print_temp("  Hyst: ", hyst_temp );
 	print_temp("  OS: ", os_temp );
 	printk("\n");
 
-	if( x.thermostat ) {
-		x.error |= 1;
-		goto out;
-	}
 	x.temp = temp;
-	x.thermostat = cl;
 	x.overheat_temp = os_temp;
 	x.overheat_hyst = hyst_temp;
 	
 	cl->id = THERMOSTAT_CLIENT_ID;
-	strncpy( cl->name, "DS1775 thermostat", sizeof(cl->name) );
+	strlcpy( cl->name, "DS1775 thermostat", sizeof(cl->name) );
 
-	if( i2c_attach_client( cl ) )
-		goto out;
-	return 0;
+	if( !i2c_attach_client(cl) )
+		x.thermostat = cl;
 out:
-	kfree( cl );
+	if( cl != x.thermostat )
+		kfree( cl );
 	return 0;
 }
 
 static int
-do_detect( struct i2c_adapter *adapter, int addr, int kind )
+do_probe( struct i2c_adapter *adapter, int addr, int kind )
 {
 	struct i2c_client *cl;
 
-	if( strncmp(adapter->name, "uni-n", 5) )
-		return 0;
 	if( !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA
 				     | I2C_FUNC_SMBUS_WRITE_BYTE) )
 		return 0;
 
-	if( !(cl=kmalloc( sizeof(struct i2c_client), GFP_KERNEL )) )
+	if( !(cl=kmalloc(sizeof(*cl), GFP_KERNEL)) )
 		return -ENOMEM;
 	memset( cl, 0, sizeof(struct i2c_client) );
 
@@ -349,108 +443,94 @@ do_detect( struct i2c_adapter *adapter, 
 	cl->flags = 0;
 
 	if( addr < 0x48 )
-		return detect_fan( cl );
-	return detect_thermostat( cl );
+		return attach_fan( cl );
+	return attach_thermostat( cl );
+}
+
+
+/************************************************************************/
+/*	initialization / cleanup					*/
+/************************************************************************/
+
+static int
+therm_of_probe( struct of_device *dev, const struct of_match *match )
+{
+	return i2c_add_driver( &g4fan_driver );
 }
 
-#define PRINT_REG( r )	printk("reg %02x = %02x\n", r, read_reg(x.fan, r, 1) )
+static int
+therm_of_remove( struct of_device *dev )
+{
+	return i2c_del_driver( &g4fan_driver );
+}
+
+static struct of_match therm_of_match[] = {{
+	.name		= "fan",
+	.type		= OF_ANY_MATCH,
+	.compatible	= "adm1030"
+    }, {}
+};
+
+static struct of_platform_driver therm_of_driver = {
+	.name		= "temperature",
+	.match_table	= therm_of_match,
+	.probe		= therm_of_probe,
+	.remove		= therm_of_remove,
+};
+
+struct apple_thermal_info {
+	u8		id;			/* implementation ID */
+	u8		fan_count;		/* number of fans */
+	u8		thermostat_count;	/* number of thermostats */
+	u8		unused;
+};
 
 static int __init
 g4fan_init( void )
 {
 	struct apple_thermal_info *info;
 	struct device_node *np;
-	int ret, val;
-	
-	np = of_find_node_by_name(NULL, "power-mgt");
-	if (np == NULL)
+
+	init_MUTEX( &x.lock );
+
+	if( !(np=of_find_node_by_name(NULL, "power-mgt")) )
 		return -ENODEV;
 	info = (struct apple_thermal_info*)get_property(np, "thermal-info", NULL);
 	of_node_put(np);
-	if (info == NULL)
-		return -ENODEV;
-	
-	/* check for G4 "Windtunnel" SMP */
-	if( machine_is_compatible("PowerMac3,6") ) {
-		if( info->id != 3 ) {
-			printk(KERN_ERR "g4fan: design id %d unknown\n", info->id);
-			return -ENODEV;
-		}
-	} else {
-		printk(KERN_ERR "g4fan: unsupported machine type\n");
-		return -ENODEV;
-	}
-	if( (ret=i2c_add_driver(&g4fan_driver)) )
-		return ret;
 
-	if( !x.thermostat || !x.fan ) {
-		i2c_del_driver(&g4fan_driver );
+	if( !info || !machine_is_compatible("PowerMac3,6") )
 		return -ENODEV;
-	}
-
-	/* save registers (if we unload the module) */
-	x.r0 = read_reg( x.fan, 0x00, 1 );
-	x.r1 = read_reg( x.fan, 0x01, 1 );
-	x.r20 = read_reg( x.fan, 0x20, 1 );
-	x.r23 = read_reg( x.fan, 0x23, 1 );
-	x.r25 = read_reg( x.fan, 0x25, 1 );
 
-	/* improve measurement resolution (convergence time 1.5s) */
-	if( (val=read_reg( x.thermostat, 1, 1 )) >= 0 ) {
-		val |= 0x60;
-		if( write_reg( x.thermostat, 1, val, 1 ) )
-			printk("Failed writing config register\n");
+	if( info->id != 3 ) {
+		printk(KERN_ERR "therm_windtunnel: unsupported thermal design %d\n", info->id );
+		return -ENODEV;
 	}
-	/* disable interrupts and TAC input */
-	write_reg( x.fan, 0x01, 0x01, 1 );
-	/* enable filter */
-	write_reg( x.fan, 0x23, 0x91, 1 );
-	/* remote temp. controls fan */
-	write_reg( x.fan, 0x00, 0x95, 1 );
-
-	/* The thermostat (which besides measureing temperature controls
-	 * has a THERM output which puts the fan on 100%) is usually
-	 * set to kick in at 80 C (chip default). We reduce this a bit
-	 * to be on the safe side (OSX doesn't)...
-	 */
-	if( x.overheat_temp == (80 << 8) ) {
-		x.overheat_temp = 65 << 8;
-		x.overheat_hyst = 60 << 8;
-		write_reg( x.thermostat, 2, x.overheat_hyst, 2 );
-		write_reg( x.thermostat, 3, x.overheat_temp, 2 );
+	if( !(np=of_find_node_by_name(NULL, "fan")) )
+		return -ENODEV;
+	x.of_dev = of_platform_device_create( np, "temperature" );
+	of_node_put( np );
 
-		print_temp("Reducing overheating limit to ", x.overheat_temp );
-		print_temp(" (Hyst: ", x.overheat_hyst );
-		printk(")\n");
+	if( !x.of_dev ) {
+		printk(KERN_ERR "Can't register fan controller!\n");
+		return -ENODEV;
 	}
 
-	/* set an initial fan setting */
-	x.upind = x.downind = 1;
-	tune_fan( fan_up_table[x.upind].fan_setting );
-
-	INIT_WORK(&poll_work, poll_temp, NULL);
-
-	init_timer( &x.timer );
-	x.timer.expires = jiffies + 8*HZ;
-	x.timer.function = schedule_poll;
-	add_timer( &x.timer );
+	of_register_driver( &therm_of_driver );
 	return 0;
 }
 
 static void __exit
 g4fan_exit( void )
 {
-	del_timer( &x.timer );
+	of_unregister_driver( &therm_of_driver );
 
-	write_reg( x.fan, 0x01, x.r1, 1 );
-	write_reg( x.fan, 0x20, x.r20, 1 );
-	write_reg( x.fan, 0x23, x.r23, 1 );
-	write_reg( x.fan, 0x25, x.r25, 1 );
-	write_reg( x.fan, 0x00, x.r0, 1 );
-
-	i2c_del_driver( &g4fan_driver );
+	if( x.of_dev )
+		of_device_unregister( x.of_dev );
 }
 
 module_init(g4fan_init);
 module_exit(g4fan_exit);
 
+MODULE_AUTHOR("Samuel Rydh <samuel@ibrium.se>");
+MODULE_DESCRIPTION("Apple G4 (windtunnel) fan controller");
+MODULE_LICENSE("GPL");
diff -purN linux-post-2.6.5-rc2-20040320/drivers/message/fusion/mptbase.c linux-post-2.6.5-rc2-20040323/drivers/message/fusion/mptbase.c
--- linux-post-2.6.5-rc2-20040320/drivers/message/fusion/mptbase.c	2004-03-10 16:36:32.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/message/fusion/mptbase.c	2004-03-20 03:11:24.000000000 +0000
@@ -1280,12 +1280,17 @@ mptbase_probe(struct pci_dev *pdev, cons
 		return r;
 	}
 
+#if 0
+	/* broken because some code assumes that multiple calls
+	   to pci_alloc_consistent return data in the same 4GB segment. 
+	   This cannot work on machines with enough memory. */
 	if (!pci_set_consistent_dma_mask(pdev, mask))
 		dprintk((KERN_INFO MYNAM
 			": Using 64 bit consistent mask\n"));
 	else
 		dprintk((KERN_INFO MYNAM
 			": Not using 64 bit consistent mask\n"));
+#endif
 
 	ioc = kmalloc(sizeof(MPT_ADAPTER), GFP_ATOMIC);
 	if (ioc == NULL) {
diff -purN linux-post-2.6.5-rc2-20040320/drivers/net/ibmveth.c linux-post-2.6.5-rc2-20040323/drivers/net/ibmveth.c
--- linux-post-2.6.5-rc2-20040320/drivers/net/ibmveth.c	2004-03-16 11:30:36.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/net/ibmveth.c	2004-03-22 10:44:59.000000000 +0000
@@ -60,6 +60,9 @@
 
 #include "ibmveth.h"
 
+#warning remove NO_TCE usage from ibmveth.c
+#define NO_TCE PCI_DMA_ERROR_CODE
+
 #define DEBUG 1
 
 #define ibmveth_printk(fmt, args...) \
diff -purN linux-post-2.6.5-rc2-20040320/drivers/parport/parport_pc.c linux-post-2.6.5-rc2-20040323/drivers/parport/parport_pc.c
--- linux-post-2.6.5-rc2-20040320/drivers/parport/parport_pc.c	2004-03-03 12:45:17.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/parport/parport_pc.c	2004-03-20 00:33:15.000000000 +0000
@@ -13,6 +13,7 @@
  * Many ECP bugs fixed.  Fred Barnes & Jamie Lokier, 1999
  * More PCI support now conditional on CONFIG_PCI, 03/2001, Paul G. 
  * Various hacks, Fred Barnes, 04/2001
+ * Updated probing logic - Adam Belay <ambx1@neo.rr.com>
  */
 
 /* This driver should work with any hardware that is broadly compatible
@@ -98,7 +99,8 @@ static int user_specified;
        (defined(CONFIG_PARPORT_1284) && defined(CONFIG_PARPORT_PC_FIFO))
 static int verbose_probing;
 #endif
-static int registered_parport;
+static int pci_registered_parport;
+static int pnp_registered_parport;
 
 /* frob_control, but for ECR */
 static void frob_econtrol (struct parport *pb, unsigned char m,
@@ -2771,10 +2773,11 @@ static struct pci_device_id parport_pc_p
 };
 MODULE_DEVICE_TABLE(pci,parport_pc_pci_tbl);
 
-static int __devinit parport_pc_pci_probe (struct pci_dev *dev,
+static int parport_pc_pci_probe (struct pci_dev *dev,
 					   const struct pci_device_id *id)
 {
 	int err, count, n, i = id->driver_data;
+
 	if (i < last_sio)
 		/* This is an onboard Super-IO and has already been probed */
 		return 0;
@@ -2847,23 +2850,72 @@ static struct pci_driver parport_pc_pci_
 static int __init parport_pc_init_superio(int autoirq, int autodma) {return 0;}
 #endif /* CONFIG_PCI */
 
-#ifdef CONFIG_PNP
-static const struct pnp_device_id pnp_dev_table[] = {
+
+static const struct pnp_device_id parport_pc_pnp_tbl[] = {
 	/* Standard LPT Printer Port */
 	{.id = "PNP0400", .driver_data = 0},
 	/* ECP Printer Port */
 	{.id = "PNP0401", .driver_data = 0},
-	{.id = ""}
+	{ }
 };
 
+MODULE_DEVICE_TABLE(pnp,parport_pc_pnp_tbl);
+
+static int parport_pc_pnp_probe(struct pnp_dev *dev, const struct pnp_device_id *id)
+{
+	struct parport *pdata;
+	unsigned long io_lo, io_hi;
+	int dma, irq;
+
+	if (pnp_port_valid(dev,0) &&
+		!(pnp_port_flags(dev,0) & IORESOURCE_DISABLED)) {
+		io_lo = pnp_port_start(dev,0);
+	} else
+		return -EINVAL;
+
+	if (pnp_port_valid(dev,1) &&
+		!(pnp_port_flags(dev,1) & IORESOURCE_DISABLED)) {
+		io_hi = pnp_port_start(dev,1);
+	} else
+		io_hi = 0;
+
+	if (pnp_irq_valid(dev,0) &&
+		!(pnp_irq_flags(dev,0) & IORESOURCE_DISABLED)) {
+		irq = pnp_irq(dev,0);
+	} else
+		irq = PARPORT_IRQ_NONE;
+
+	if (pnp_dma_valid(dev,0) &&
+		!(pnp_dma_flags(dev,0) & IORESOURCE_DISABLED)) {
+		dma = pnp_dma(dev,0);
+	} else
+		dma = PARPORT_DMA_NONE;
+
+	printk(KERN_INFO "parport: PnPBIOS parport detected.\n");
+	if (!(pdata = parport_pc_probe_port (io_lo, io_hi, irq, dma, NULL)))
+		return -ENODEV;
+
+	pnp_set_drvdata(dev,pdata);
+	return 0;
+}
+
+static void parport_pc_pnp_remove(struct pnp_dev *dev)
+{
+	struct parport *pdata = (struct parport *)pnp_get_drvdata(dev);
+	if (!pdata)
+		return;
+
+	parport_pc_unregister_port(pdata);
+}
+
 /* we only need the pnp layer to activate the device, at least for now */
 static struct pnp_driver parport_pc_pnp_driver = {
 	.name		= "parport_pc",
-	.id_table	= pnp_dev_table,
+	.id_table	= parport_pc_pnp_tbl,
+	.probe		= parport_pc_pnp_probe,
+	.remove		= parport_pc_pnp_remove,
 };
-#else
-static struct pnp_driver parport_pc_pnp_driver;
-#endif
+
 
 /* This is called by parport_pc_find_nonpci_ports (in asm/parport.h) */
 static int __init __attribute__((unused))
@@ -2903,12 +2955,18 @@ static int __init parport_pc_find_ports 
 	/* Onboard SuperIO chipsets that show themselves on the PCI bus. */
 	count += parport_pc_init_superio (autoirq, autodma);
 
+	r = pnp_register_driver (&parport_pc_pnp_driver);
+	if (r >= 0) {
+		pnp_registered_parport = 1;
+		count += r;
+	}
+
 	/* ISA ports and whatever (see asm/parport.h). */
 	count += parport_pc_find_nonpci_ports (autoirq, autodma);
 
 	r = pci_register_driver (&parport_pc_pci_driver);
 	if (r >= 0) {
-		registered_parport = 1;
+		pci_registered_parport = 1;
 		count += r;
 	}
 
@@ -3104,9 +3162,6 @@ static int __init parport_pc_init(void)
 	if (parse_parport_params())
 		return -EINVAL;
 
-	/* try to activate any PnP parports first */
-	pnp_register_driver(&parport_pc_pnp_driver);
-
 	if (io[0]) {
 		int i;
 		/* Only probe the ports we were given. */
@@ -3120,24 +3175,18 @@ static int __init parport_pc_init(void)
 						  irqval[i], dmaval[i], NULL))
 				count++;
 		}
-	} else {
+	} else
 		count += parport_pc_find_ports (irqval[0], dmaval[0]);
-		if (!count && registered_parport)
-			pci_unregister_driver (&parport_pc_pci_driver);
-	}
-
-	if (!count) {
-		pnp_unregister_driver (&parport_pc_pnp_driver);
-		return -ENODEV;
-	}
 
 	return 0;
 }
 
 static void __exit parport_pc_exit(void)
 {
-	if (registered_parport)
+	if (pci_registered_parport)
 		pci_unregister_driver (&parport_pc_pci_driver);
+	if (pnp_registered_parport)
+		pnp_unregister_driver (&parport_pc_pnp_driver);
 
 	spin_lock(&ports_lock);
 	while (!list_empty(&ports_list)) {
@@ -3151,13 +3200,8 @@ static void __exit parport_pc_exit(void)
 		spin_lock(&ports_lock);
 	}
 	spin_unlock(&ports_lock);
-	pnp_unregister_driver (&parport_pc_pnp_driver);
 }
 
-
-MODULE_AUTHOR("Phil Blundell, Tim Waugh, others");
-MODULE_DESCRIPTION("PC-style parallel port driver");
-MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Phil Blundell, Tim Waugh, others");
 MODULE_DESCRIPTION("PC-style parallel port driver");
 MODULE_LICENSE("GPL");
diff -purN linux-post-2.6.5-rc2-20040320/drivers/pci/hotplug/rpaphp_pci.c linux-post-2.6.5-rc2-20040323/drivers/pci/hotplug/rpaphp_pci.c
--- linux-post-2.6.5-rc2-20040320/drivers/pci/hotplug/rpaphp_pci.c	2004-03-05 09:45:43.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/pci/hotplug/rpaphp_pci.c	2004-03-21 10:27:21.000000000 +0000
@@ -257,6 +257,7 @@ static struct pci_dev *rpaphp_config_pci
 		}
 
 		dev = rpaphp_pci_config_dn(slot->dn, pci_bus);
+		eeh_add_device(dev);
 	} else {
 		/* slot is not enabled */
 		err("slot doesn't have pci_dev structure\n");
@@ -281,6 +282,7 @@ int rpaphp_unconfig_pci_adapter(struct s
 		goto exit;
 	}
 	/* remove the device from the pci core */
+	eeh_remove_device(slot->dev.pci_dev);
 	pci_remove_bus_device(slot->dev.pci_dev);
 
 	slot->state = NOT_CONFIGURED;
diff -purN linux-post-2.6.5-rc2-20040320/drivers/pnp/isapnp/Kconfig linux-post-2.6.5-rc2-20040323/drivers/pnp/isapnp/Kconfig
--- linux-post-2.6.5-rc2-20040320/drivers/pnp/isapnp/Kconfig	2004-02-08 15:51:52.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/pnp/isapnp/Kconfig	2004-03-20 17:53:00.000000000 +0000
@@ -2,8 +2,8 @@
 # ISA Plug and Play configuration
 #
 config ISAPNP
-	bool "ISA Plug and Play support (EXPERIMENTAL)"
-	depends on PNP && EXPERIMENTAL
+	bool "ISA Plug and Play support"
+	depends on PNP
 	help
 	  Say Y here if you would like support for ISA Plug and Play devices.
 	  Some information is in <file:Documentation/isapnp.txt>.
diff -purN linux-post-2.6.5-rc2-20040320/drivers/pnp/isapnp/core.c linux-post-2.6.5-rc2-20040323/drivers/pnp/isapnp/core.c
--- linux-post-2.6.5-rc2-20040320/drivers/pnp/isapnp/core.c	2004-02-08 15:28:02.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/pnp/isapnp/core.c	2004-03-20 17:10:01.000000000 +0000
@@ -99,6 +99,7 @@ MODULE_LICENSE("GPL");
 static unsigned char isapnp_checksum_value;
 static DECLARE_MUTEX(isapnp_cfg_mutex);
 static int isapnp_detected;
+static int isapnp_csn_count;
 
 /* some prototypes */
 
@@ -371,11 +372,14 @@ static int __init isapnp_isolate(void)
 			break;
 		}
 	      __next:
+		if (csn == 255)
+			break;
 		checksum = 0x6a;
 		chksum = 0x00;
 		bit = 0x00;
 	}
 	isapnp_wait();
+	isapnp_csn_count = csn;
 	return csn;
 }
 
@@ -880,7 +884,7 @@ static int __init isapnp_build_device_li
 
 	isapnp_wait();
 	isapnp_key();
-	for (csn = 1; csn <= 10; csn++) {
+	for (csn = 1; csn <= isapnp_csn_count; csn++) {
 		isapnp_wake(csn);
 		isapnp_peek(header, 9);
 		checksum = isapnp_checksum(header);
@@ -890,12 +894,6 @@ static int __init isapnp_build_device_li
 			header[4], header[5], header[6], header[7], header[8]);
 		printk(KERN_DEBUG "checksum = 0x%x\n", checksum);
 #endif
-		/* Don't be strict on the checksum, here !
-                   e.g. 'SCM SwapBox Plug and Play' has header[8]==0 (should be: b7)*/
-		if (header[8] == 0)
-			;
-		else if (checksum == 0x00 || checksum != header[8])	/* not valid CSN */
-			continue;
 		if ((card = isapnp_alloc(sizeof(struct pnp_card))) == NULL)
 			continue;
 
@@ -932,9 +930,8 @@ int isapnp_present(void)
 
 int isapnp_cfg_begin(int csn, int logdev)
 {
-	if (csn < 1 || csn > 10 || logdev > 10)
+	if (csn < 1 || csn > isapnp_csn_count || logdev > 10)
 		return -EINVAL;
-	MOD_INC_USE_COUNT;
 	down(&isapnp_cfg_mutex);
 	isapnp_wait();
 	isapnp_key();
@@ -962,7 +959,6 @@ int isapnp_cfg_end(void)
 {
 	isapnp_wait();
 	up(&isapnp_cfg_mutex);
-	MOD_DEC_USE_COUNT;
 	return 0;
 }
 
@@ -1050,7 +1046,7 @@ static int isapnp_set_resources(struct p
 	for (tmp = 0; tmp < PNP_MAX_DMA && (res->dma_resource[tmp].flags & (IORESOURCE_DMA | IORESOURCE_UNSET)) == IORESOURCE_DMA; tmp++)
 		isapnp_write_byte(ISAPNP_CFG_DMA+tmp, res->dma_resource[tmp].start);
 	for (tmp = 0; tmp < PNP_MAX_MEM && (res->mem_resource[tmp].flags & (IORESOURCE_MEM | IORESOURCE_UNSET)) == IORESOURCE_MEM; tmp++)
-		isapnp_write_word(ISAPNP_CFG_MEM+(tmp<<2), (res->mem_resource[tmp].start >> 8) & 0xffff);
+		isapnp_write_word(ISAPNP_CFG_MEM+(tmp<<3), (res->mem_resource[tmp].start >> 8) & 0xffff);
 	/* FIXME: We aren't handling 32bit mems properly here */
 	isapnp_activate(dev->number);
 	isapnp_cfg_end();
diff -purN linux-post-2.6.5-rc2-20040320/drivers/pnp/resource.c linux-post-2.6.5-rc2-20040323/drivers/pnp/resource.c
--- linux-post-2.6.5-rc2-20040320/drivers/pnp/resource.c	2004-02-08 15:28:02.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/pnp/resource.c	2004-03-20 00:28:51.000000000 +0000
@@ -231,15 +231,9 @@ void pnp_free_option(struct pnp_option *
 
 #define length(start, end) (*(end) - *(start) + 1)
 
-/* ranged_conflict - used to determine if two resource ranges conflict
- * condition 1: check if the start of a is within b
- * condition 2: check if the end of a is within b
- * condition 3: check if b is engulfed by a */
-
+/* Two ranges conflict if one doesn't end before the other starts */
 #define ranged_conflict(starta, enda, startb, endb) \
-((*(starta) >= *(startb) && *(starta) <= *(endb)) || \
- (*(enda) >= *(startb) && *(enda) <= *(endb)) || \
- (*(starta) < *(startb) && *(enda) > *(endb)))
+	!((*(enda) < *(startb)) || (*(endb) < *(starta)))
 
 #define cannot_compare(flags) \
 ((flags) & (IORESOURCE_UNSET | IORESOURCE_DISABLED))
diff -purN linux-post-2.6.5-rc2-20040320/drivers/pnp/system.c linux-post-2.6.5-rc2-20040323/drivers/pnp/system.c
--- linux-post-2.6.5-rc2-20040320/drivers/pnp/system.c	2003-11-16 00:25:14.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/pnp/system.c	2004-03-20 16:38:56.000000000 +0000
@@ -21,7 +21,7 @@ static const struct pnp_device_id pnp_de
 	{	"",			0	}
 };
 
-static void __init reserve_ioport_range(char *pnpid, int start, int end)
+static void reserve_ioport_range(char *pnpid, int start, int end)
 {
 	struct resource *res;
 	char *regionid;
@@ -49,7 +49,7 @@ static void __init reserve_ioport_range(
 	return;
 }
 
-static void __init reserve_resources_of_dev( struct pnp_dev *dev )
+static void reserve_resources_of_dev( struct pnp_dev *dev )
 {
 	int i;
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/scsi/sg.c linux-post-2.6.5-rc2-20040323/drivers/scsi/sg.c
--- linux-post-2.6.5-rc2-20040320/drivers/scsi/sg.c	2004-03-12 16:22:11.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/scsi/sg.c	2004-03-20 13:48:28.000000000 +0000
@@ -1256,7 +1256,6 @@ sg_cmd_done(Scsi_Cmnd * SCpnt)
 	SRpnt->sr_request->rq_disk = NULL; /* "sg" _disowns_ request blk */
 
 	srp->my_cmdp = NULL;
-	srp->done = 1;
 
 	SCSI_LOG_TIMEOUT(4, printk("sg_cmd_done: %s, pack_id=%d, res=0x%x\n",
 		sdp->disk->disk_name, srp->header.pack_id, (int) SRpnt->sr_result));
@@ -1312,8 +1311,9 @@ sg_cmd_done(Scsi_Cmnd * SCpnt)
 	}
 	if (sfp && srp) {
 		/* Now wake up any sg_read() that is waiting for this packet. */
-		wake_up_interruptible(&sfp->read_wait);
 		kill_fasync(&sfp->async_qp, SIGPOLL, POLL_IN);
+		srp->done = 1;
+		wake_up_interruptible(&sfp->read_wait);
 	}
 }
 
diff -purN linux-post-2.6.5-rc2-20040320/drivers/scsi/st.c linux-post-2.6.5-rc2-20040323/drivers/scsi/st.c
--- linux-post-2.6.5-rc2-20040320/drivers/scsi/st.c	2004-03-15 23:02:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/scsi/st.c	2004-03-20 13:47:27.000000000 +0000
@@ -17,7 +17,7 @@
    Last modified: 18-JAN-1998 Richard Gooch <rgooch@atnf.csiro.au> Devfs support
  */
 
-static char *verstr = "20040226";
+static char *verstr = "20040318";
 
 #include <linux/module.h>
 
@@ -4193,20 +4193,25 @@ CLASS_DEVICE_ATTR(default_compression, S
 
 static void do_create_class_files(Scsi_Tape *STp, int dev_num, int mode)
 {
-	int rew, error;
+	int i, rew, error;
+	char name[10];
 	struct class_device *st_class_member;
 
 	if (!st_sysfs_class)
 		return;
 
 	for (rew=0; rew < 2; rew++) {
+		/* Make sure that the minor numbers corresponding to the four
+		   first modes always get the same names */
+		i = mode << (4 - ST_NBR_MODE_BITS);
+		snprintf(name, 10, "%s%s%s", rew ? "n" : "",
+			 STp->disk->disk_name, st_formats[i]);
 		st_class_member =
 			class_simple_device_add(st_sysfs_class,
 						MKDEV(SCSI_TAPE_MAJOR,
 						      TAPE_MINOR(dev_num, mode, rew)),
-						&STp->device->sdev_gendev, "%s",
-						STp->modes[mode].cdevs[rew]->kobj.name);
-		if (!st_class_member) {
+						&STp->device->sdev_gendev, "%s", name);
+		if (IS_ERR(st_class_member)) {
 			printk(KERN_WARNING "st%d: class_simple_device_add failed\n",
 			       dev_num);
 			goto out;
diff -purN linux-post-2.6.5-rc2-20040320/drivers/serial/8250_pnp.c linux-post-2.6.5-rc2-20040323/drivers/serial/8250_pnp.c
--- linux-post-2.6.5-rc2-20040320/drivers/serial/8250_pnp.c	2004-03-19 06:04:54.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/serial/8250_pnp.c	2004-03-20 17:47:29.000000000 +0000
@@ -266,6 +266,8 @@ static const struct pnp_device_id pnp_de
 	{	"RSS00A0",		0	},
 	/* Viking 56K FAX INT */
 	{	"RSS0262",		0	},
+	/* K56 par,VV,Voice,Speakphone,AudioSpan,PnP */
+	{       "RSS0250",              0       },
 	/* SupraExpress 28.8 Data/Fax PnP modem */
 	{	"SUP1310",		0	},
 	/* SupraExpress 33.6 Data/Fax PnP modem */
@@ -283,6 +285,8 @@ static const struct pnp_device_id pnp_de
 	/* 3Com Corp. */
 	/* Gateway Telepath IIvi 33.6 */
 	{	"USR0000",		0	},
+	/* U.S. Robotics Sporster 33.6K Fax INT PnP */
+	{	"USR0002",		0	},
 	/*  Sportster Vi 14.4 PnP FAX Voicemail */
 	{	"USR0004",		0	},
 	/* U.S. Robotics 33.6K Voice INT PnP */
@@ -315,6 +319,8 @@ static const struct pnp_device_id pnp_de
 	{	"USR9180",		0	},
 	/* U.S. Robotics 56K Voice INT PnP*/
 	{	"USR9190",		0	},
+	/* Rockwell's (PORALiNK) 33600 INT PNP */
+	{	"WCI0003",		0	},
 	/* Unkown PnP modems */
 	{	"PNPCXXX",		UNKNOWN_DEV	},
 	/* More unkown PnP modems */
diff -purN linux-post-2.6.5-rc2-20040320/drivers/serial/pmac_zilog.c linux-post-2.6.5-rc2-20040323/drivers/serial/pmac_zilog.c
--- linux-post-2.6.5-rc2-20040320/drivers/serial/pmac_zilog.c	2004-03-10 10:18:32.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/drivers/serial/pmac_zilog.c	2004-03-22 05:48:53.000000000 +0000
@@ -1563,15 +1563,21 @@ static int pmz_detach(struct macio_dev *
 static int pmz_suspend(struct macio_dev *mdev, u32 pm_state)
 {
 	struct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);
-	struct uart_state *state = pmz_uart_reg.state + uap->port.line;
+	struct uart_state *state;
 	unsigned long flags;
 
-	if (uap == NULL)
+	if (uap == NULL) {
+		printk("HRM... pmz_suspend with NULL uap\n");
 		return 0;
+	}
 
 	if (pm_state == mdev->ofdev.dev.power_state || pm_state < 2)
 		return 0;
 
+	pmz_debug("suspend, switching to state %d\n", pm_state);
+
+	state = pmz_uart_reg.state + uap->port.line;
+
 	down(&pmz_irq_sem);
 	down(&state->sem);
 
@@ -1607,6 +1613,8 @@ static int pmz_suspend(struct macio_dev 
 	up(&state->sem);
 	up(&pmz_irq_sem);
 
+	pmz_debug("suspend, switching complete\n");
+
 	mdev->ofdev.dev.power_state = pm_state;
 
 	return 0;
@@ -1616,7 +1624,7 @@ static int pmz_suspend(struct macio_dev 
 static int pmz_resume(struct macio_dev *mdev)
 {
 	struct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);
-	struct uart_state *state = pmz_uart_reg.state + uap->port.line;
+	struct uart_state *state;
 	unsigned long flags;
 	int pwr_delay;
 
@@ -1626,6 +1634,10 @@ static int pmz_resume(struct macio_dev *
 	if (mdev->ofdev.dev.power_state == 0)
 		return 0;
 	
+	pmz_debug("resume, switching to state 0\n");
+
+	state = pmz_uart_reg.state + uap->port.line;
+
 	down(&pmz_irq_sem);
 	down(&state->sem);
 
@@ -1658,6 +1670,7 @@ static int pmz_resume(struct macio_dev *
 		enable_irq(uap->port.irq);
 	}
 
+ bail:
 	up(&state->sem);
 	up(&pmz_irq_sem);
 
@@ -1670,7 +1683,8 @@ static int pmz_resume(struct macio_dev *
 		schedule_timeout((pwr_delay * HZ)/1000);
 	}
 
- bail:
+	pmz_debug("resume, switching complete\n");
+
 	mdev->ofdev.dev.power_state = 0;
 
 	return 0;
diff -purN linux-post-2.6.5-rc2-20040320/fs/Kconfig.binfmt linux-post-2.6.5-rc2-20040323/fs/Kconfig.binfmt
--- linux-post-2.6.5-rc2-20040320/fs/Kconfig.binfmt	2004-02-19 00:46:02.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/fs/Kconfig.binfmt	2004-03-21 22:55:43.000000000 +0000
@@ -44,7 +44,7 @@ config BINFMT_SHARED_FLAT
 
 config BINFMT_AOUT
 	tristate "Kernel support for a.out and ECOFF binaries"
-	depends on (X86 && !X86_64) || ALPHA || ARM || M68K || MIPS || SPARC
+	depends on (X86 && !X86_64) || ALPHA || ARM || M68K || MIPS || SPARC32
 	---help---
 	  A.out (Assembler.OUTput) is a set of formats for libraries and
 	  executables used in the earliest versions of UNIX.  Linux used
diff -purN linux-post-2.6.5-rc2-20040320/fs/char_dev.c linux-post-2.6.5-rc2-20040323/fs/char_dev.c
--- linux-post-2.6.5-rc2-20040320/fs/char_dev.c	2004-03-13 08:04:26.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/fs/char_dev.c	2004-03-22 04:13:19.000000000 +0000
@@ -265,7 +265,7 @@ int chrdev_open(struct inode * inode, st
 		spin_unlock(&cdev_lock);
 		kobj = kobj_lookup(cdev_map, inode->i_rdev, &idx);
 		if (!kobj)
-			return -ENODEV;
+			return -ENXIO;
 		new = container_of(kobj, struct cdev, kobj);
 		spin_lock(&cdev_lock);
 		p = inode->i_cdev;
@@ -275,9 +275,9 @@ int chrdev_open(struct inode * inode, st
 			list_add(&inode->i_devices, &p->list);
 			new = NULL;
 		} else if (!cdev_get(p))
-			ret = -ENODEV;
+			ret = -ENXIO;
 	} else if (!cdev_get(p))
-		ret = -ENODEV;
+		ret = -ENXIO;
 	spin_unlock(&cdev_lock);
 	cdev_put(new);
 	if (ret)
@@ -285,7 +285,7 @@ int chrdev_open(struct inode * inode, st
 	filp->f_op = fops_get(p->ops);
 	if (!filp->f_op) {
 		cdev_put(p);
-		return -ENODEV;
+		return -ENXIO;
 	}
 	if (filp->f_op->open) {
 		lock_kernel();
diff -purN linux-post-2.6.5-rc2-20040320/fs/compat_ioctl.c linux-post-2.6.5-rc2-20040323/fs/compat_ioctl.c
--- linux-post-2.6.5-rc2-20040320/fs/compat_ioctl.c	2004-03-16 21:12:40.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/fs/compat_ioctl.c	2004-03-22 06:53:25.000000000 +0000
@@ -1986,13 +1986,18 @@ static int do_blkgetsize64(unsigned int 
 }
 
 /* Bluetooth ioctls */
-#define HCIUARTSETPROTO        _IOW('U', 200, int)
-#define HCIUARTGETPROTO        _IOR('U', 201, int)
+#define HCIUARTSETPROTO	_IOW('U', 200, int)
+#define HCIUARTGETPROTO	_IOR('U', 201, int)
 
-#define BNEPCONNADD    _IOW('B', 200, int)
-#define BNEPCONNDEL    _IOW('B', 201, int)
-#define BNEPGETCONNLIST        _IOR('B', 210, int)
-#define BNEPGETCONNINFO        _IOR('B', 211, int)
+#define BNEPCONNADD	_IOW('B', 200, int)
+#define BNEPCONNDEL	_IOW('B', 201, int)
+#define BNEPGETCONNLIST	_IOR('B', 210, int)
+#define BNEPGETCONNINFO	_IOR('B', 211, int)
+
+#define CMTPCONNADD	_IOW('C', 200, int)
+#define CMTPCONNDEL	_IOW('C', 201, int)
+#define CMTPGETCONNLIST	_IOR('C', 210, int)
+#define CMTPGETCONNINFO	_IOR('C', 211, int)
 
 struct floppy_struct32 {
 	compat_uint_t	size;
diff -purN linux-post-2.6.5-rc2-20040320/fs/udf/file.c linux-post-2.6.5-rc2-20040323/fs/udf/file.c
--- linux-post-2.6.5-rc2-20040320/fs/udf/file.c	2004-03-12 09:30:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/fs/udf/file.c	2004-03-21 22:26:46.000000000 +0000
@@ -247,9 +247,9 @@ static int udf_release_file(struct inode
 {
 	if (filp->f_mode & FMODE_WRITE)
 	{
-		down(&inode->i_sem);
+		lock_kernel();
 		udf_discard_prealloc(inode);
-		up(&inode->i_sem);
+		unlock_kernel();
 	}
 	return 0;
 }
diff -purN linux-post-2.6.5-rc2-20040320/fs/udf/inode.c linux-post-2.6.5-rc2-20040323/fs/udf/inode.c
--- linux-post-2.6.5-rc2-20040320/fs/udf/inode.c	2004-03-12 09:30:25.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/fs/udf/inode.c	2004-03-21 22:26:21.000000000 +0000
@@ -84,9 +84,9 @@ void udf_put_inode(struct inode * inode)
 {
 	if (!(inode->i_sb->s_flags & MS_RDONLY))
 	{
-		down(&inode->i_sem);
+		lock_kernel();
 		udf_discard_prealloc(inode);
-		up(&inode->i_sem);
+		unlock_kernel();
 	}
 }
 
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-ppc64/iSeries/vio.h linux-post-2.6.5-rc2-20040323/include/asm-ppc64/iSeries/vio.h
--- linux-post-2.6.5-rc2-20040320/include/asm-ppc64/iSeries/vio.h	2004-03-07 07:05:28.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-ppc64/iSeries/vio.h	2004-03-19 07:10:25.000000000 +0000
@@ -70,11 +70,6 @@ void vio_free_event_buffer(int subtype, 
 extern HvLpIndex viopath_hostLp;
 extern HvLpIndex viopath_ourLp;
 
-#define VIO_MESSAGE "iSeries virtual I/O: "
-#define KERN_DEBUG_VIO KERN_DEBUG VIO_MESSAGE
-#define KERN_INFO_VIO KERN_INFO VIO_MESSAGE
-#define KERN_WARNING_VIO KERN_WARNING VIO_MESSAGE
-
 #define VIOCHAR_MAX_DATA 200
 
 #define VIOMAJOR_SUBTYPE_MASK 0xff00
@@ -84,11 +79,11 @@ extern HvLpIndex viopath_ourLp;
 #define VIOVERSION            0x0101
 
 /*
-This is the general structure for VIO errors; each module should have a table
-of them, and each table should be terminated by an entry of { 0, 0, NULL }.
-Then, to find a specific error message, a module should pass its local table
-and the return code.
-*/
+ * This is the general structure for VIO errors; each module should have
+ * a table of them, and each table should be terminated by an entry of
+ * { 0, 0, NULL }.  Then, to find a specific error message, a module
+ * should pass its local table and the return code.
+ */
 struct vio_error_entry {
 	u16 rc;
 	int errno;
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-ppc64/iommu.h linux-post-2.6.5-rc2-20040323/include/asm-ppc64/iommu.h
--- linux-post-2.6.5-rc2-20040320/include/asm-ppc64/iommu.h	2004-03-03 13:26:24.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-ppc64/iommu.h	2004-03-22 10:44:59.000000000 +0000
@@ -33,8 +33,6 @@
  */
 #define IOMAP_MAX_ORDER 10
 
-#define NO_TCE ((dma_addr_t)-1)
-
 /*
  * Tces come in two formats, one for the virtual bus and a different
  * format for PCI
@@ -152,4 +150,6 @@ extern void tce_init_iSeries(void);
 extern void pci_iommu_init(void);
 extern void pci_dma_init_direct(void);
 
+extern int ppc64_iommu_off;
+
 #endif
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-ppc64/machdep.h linux-post-2.6.5-rc2-20040323/include/asm-ppc64/machdep.h
--- linux-post-2.6.5-rc2-20040320/include/asm-ppc64/machdep.h	2004-02-27 23:02:35.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-ppc64/machdep.h	2004-03-21 10:27:41.000000000 +0000
@@ -65,8 +65,6 @@ struct machdep_calls {
 
 	void		(*setup_arch)(void);
 	/* Optional, may be NULL. */
-	void		(*setup_residual)(struct seq_file *m, int cpu_id);
-	/* Optional, may be NULL. */
 	void		(*get_cpuinfo)(struct seq_file *m);
 
 	void		(*init_IRQ)(void);
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-ppc64/pci.h linux-post-2.6.5-rc2-20040323/include/asm-ppc64/pci.h
--- linux-post-2.6.5-rc2-20040320/include/asm-ppc64/pci.h	2004-03-14 06:54:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-ppc64/pci.h	2004-03-22 10:44:59.000000000 +0000
@@ -169,6 +169,12 @@ static inline int pci_dac_dma_supported(
 	return 0;
 }
 
+#define PCI_DMA_ERROR_CODE      (~(dma_addr_t)0x0)
+static inline int pci_dma_error(dma_addr_t dma_addr)
+{
+	return (dma_addr == PCI_DMA_ERROR_CODE);
+}
+
 extern int pci_domain_nr(struct pci_bus *bus);
 
 /* Set the name of the bus as it appears in /proc/bus/pci */
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-sparc/asmmacro.h linux-post-2.6.5-rc2-20040323/include/asm-sparc/asmmacro.h
--- linux-post-2.6.5-rc2-20040320/include/asm-sparc/asmmacro.h	2004-03-15 00:43:40.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-sparc/asmmacro.h	2004-03-16 10:14:48.000000000 +0000
@@ -29,13 +29,6 @@
 	srl	%reg, 12, %reg; \
 	and	%reg, 3, %reg;
 
-#define GET_PROCESSOR_OFFSET(reg, tmp) \
-	GET_PROCESSOR_ID(reg) \
-	sethi	%hi(cpu_offset), %tmp; \
-	sll	%reg, 2, %reg; \
-	or	%tmp, %lo(cpu_offset), %tmp; \
-	ld	[%tmp + %reg], %reg;
-
 /* All trap entry points _must_ begin with this macro or else you
  * lose.  It makes sure the kernel has a proper window so that
  * c-code can be called.
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-sparc/delay.h linux-post-2.6.5-rc2-20040323/include/asm-sparc/delay.h
--- linux-post-2.6.5-rc2-20040320/include/asm-sparc/delay.h	2003-02-04 10:47:29.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-sparc/delay.h	2004-03-16 10:14:49.000000000 +0000
@@ -7,7 +7,8 @@
 #ifndef __SPARC_DELAY_H
 #define __SPARC_DELAY_H
 
-extern unsigned long loops_per_jiffy;
+#include <linux/config.h>
+#include <asm/cpudata.h>
 
 extern __inline__ void __delay(unsigned long loops)
 {
@@ -20,7 +21,15 @@ extern __inline__ void __delay(unsigned 
 }
 
 /* This is too messy with inline asm on the Sparc. */
-extern void udelay(unsigned long usecs);
-extern void ndelay(unsigned long usecs);
+extern void __udelay(unsigned long usecs, unsigned long lpj);
+extern void __ndelay(unsigned long nsecs, unsigned long lpj);
+
+#ifdef CONFIG_SMP
+#define __udelay_val	cpu_data(smp_processor_id()).udelay_val
+#else /* SMP */
+#define __udelay_val	loops_per_jiffy
+#endif /* SMP */
+#define udelay(__usecs)	__udelay(__usecs, __udelay_val)
+#define ndelay(__nsecs)	__ndelay(__nsecs, __udelay_val)
 
 #endif /* defined(__SPARC_DELAY_H) */
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-sparc/page.h linux-post-2.6.5-rc2-20040323/include/asm-sparc/page.h
--- linux-post-2.6.5-rc2-20040320/include/asm-sparc/page.h	2004-01-06 04:26:21.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-sparc/page.h	2004-03-21 22:43:34.000000000 +0000
@@ -156,17 +156,22 @@ extern __inline__ int get_order(unsigned
 #define PAGE_ALIGN(addr)  (((addr)+PAGE_SIZE-1)&PAGE_MASK)
 
 #define PAGE_OFFSET	0xf0000000
-#define __pa(x)                 ((unsigned long)(x) - PAGE_OFFSET)
-#define __va(x)                 ((void *)((unsigned long) (x) + PAGE_OFFSET))
+#ifndef __ASSEMBLY__
+extern unsigned long phys_base;
+extern unsigned long pfn_base;
+#endif
+#define __pa(x)			((unsigned long)(x) - PAGE_OFFSET + phys_base)
+#define __va(x)			((void *)((unsigned long) (x) - phys_base + PAGE_OFFSET))
+
+#define virt_to_phys		__pa
+#define phys_to_virt		__va
+
+#define pfn_to_page(pfn)	(mem_map + ((pfn)-(pfn_base)))
+#define page_to_pfn(page)	((unsigned long)(((page) - mem_map) + pfn_base))
+#define virt_to_page(kaddr)	(mem_map + ((((unsigned long)(kaddr)-PAGE_OFFSET)>>PAGE_SHIFT)))
 
-#define virt_to_phys(x)		__pa((unsigned long)(x))
-#define phys_to_virt(x)		__va((unsigned long)(x))
-
-#define pfn_to_page(pfn)        (mem_map + (pfn))
-#define page_to_pfn(page)       ((unsigned long)((page) - mem_map))
-#define virt_to_page(kaddr)	(mem_map + (__pa(kaddr) >> PAGE_SHIFT))
-#define pfn_valid(pfn)		((pfn) < max_mapnr)
-#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+#define pfn_valid(pfn)		(((pfn) >= (pfn_base)) && (((pfn)-(pfn_base)) < max_mapnr))
+#define virt_addr_valid(kaddr)	((((unsigned long)(kaddr)-PAGE_OFFSET)>>PAGE_SHIFT) < max_mapnr)
 
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-sparc/pgtable.h linux-post-2.6.5-rc2-20040323/include/asm-sparc/pgtable.h
--- linux-post-2.6.5-rc2-20040320/include/asm-sparc/pgtable.h	2004-02-04 05:31:19.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-sparc/pgtable.h	2004-03-21 22:43:34.000000000 +0000
@@ -181,6 +181,7 @@ extern int num_contexts;
  * hit for all __pa()/__va() operations.
  */
 extern unsigned long phys_base;
+extern unsigned long pfn_base;
 
 /*
  * BAD_PAGETABLE is used when we need a bogus page-table, while
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-sparc/smp.h linux-post-2.6.5-rc2-20040323/include/asm-sparc/smp.h
--- linux-post-2.6.5-rc2-20040320/include/asm-sparc/smp.h	2004-03-15 01:06:22.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-sparc/smp.h	2004-03-16 10:14:49.000000000 +0000
@@ -148,7 +148,10 @@ extern __inline__ int hard_smp_processor
 }
 #endif
 
-#define smp_processor_id() hard_smp_processor_id()
+#define smp_processor_id()	(current_thread_info()->cpu)
+
+#define prof_multiplier(__cpu)		cpu_data(__cpu).multiplier
+#define prof_counter(__cpu)		cpu_data(__cpu).counter
 
 #endif /* !(__ASSEMBLY__) */
 
diff -purN linux-post-2.6.5-rc2-20040320/include/asm-x86_64/calling.h linux-post-2.6.5-rc2-20040323/include/asm-x86_64/calling.h
--- linux-post-2.6.5-rc2-20040320/include/asm-x86_64/calling.h	2004-03-17 15:52:48.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/asm-x86_64/calling.h	2004-03-21 20:35:48.000000000 +0000
@@ -56,7 +56,7 @@
 	movq  %r10,1*8(%rsp) 
 	CFI_REL_OFFSET	r10,1*8
 	movq  %r11,(%rsp) 
-	CFI_OFFSET	r11
+	CFI_REL_OFFSET	r11,0*8
 	.endif
 	.endm
 
diff -purN linux-post-2.6.5-rc2-20040320/include/linux/compat_ioctl.h linux-post-2.6.5-rc2-20040323/include/linux/compat_ioctl.h
--- linux-post-2.6.5-rc2-20040320/include/linux/compat_ioctl.h	2004-03-20 00:07:04.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/linux/compat_ioctl.h	2004-03-22 06:53:25.000000000 +0000
@@ -618,6 +618,10 @@ COMPATIBLE_IOCTL(BNEPCONNADD)
 COMPATIBLE_IOCTL(BNEPCONNDEL)
 COMPATIBLE_IOCTL(BNEPGETCONNLIST)
 COMPATIBLE_IOCTL(BNEPGETCONNINFO)
+COMPATIBLE_IOCTL(CMTPCONNADD)
+COMPATIBLE_IOCTL(CMTPCONNDEL)
+COMPATIBLE_IOCTL(CMTPGETCONNLIST)
+COMPATIBLE_IOCTL(CMTPGETCONNINFO)
 /* Misc. */
 COMPATIBLE_IOCTL(0x41545900)		/* ATYIO_CLKR */
 COMPATIBLE_IOCTL(0x41545901)		/* ATYIO_CLKW */
diff -purN linux-post-2.6.5-rc2-20040320/include/linux/crypto.h linux-post-2.6.5-rc2-20040323/include/linux/crypto.h
--- linux-post-2.6.5-rc2-20040320/include/linux/crypto.h	2003-08-18 11:03:55.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/linux/crypto.h	2004-03-22 06:31:09.000000000 +0000
@@ -76,6 +76,8 @@ struct digest_alg {
 	void (*dia_init)(void *ctx);
 	void (*dia_update)(void *ctx, const u8 *data, unsigned int len);
 	void (*dia_final)(void *ctx, u8 *out);
+	int (*dia_setkey)(void *ctx, const u8 *key,
+	                  unsigned int keylen, u32 *flags);
 };
 
 struct compress_alg {
@@ -157,6 +159,8 @@ struct digest_tfm {
 	void (*dit_final)(struct crypto_tfm *tfm, u8 *out);
 	void (*dit_digest)(struct crypto_tfm *tfm, struct scatterlist *sg,
 	                   unsigned int nsg, u8 *out);
+	int (*dit_setkey)(struct crypto_tfm *tfm,
+	                  const u8 *key, unsigned int keylen);
 #ifdef CONFIG_CRYPTO_HMAC
 	void *dit_hmac_block;
 #endif
@@ -282,6 +286,15 @@ static inline void crypto_digest_digest(
 	tfm->crt_digest.dit_digest(tfm, sg, nsg, out);
 }
 
+static inline int crypto_digest_setkey(struct crypto_tfm *tfm,
+                                       const u8 *key, unsigned int keylen)
+{
+	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
+	if (tfm->crt_digest.dit_setkey == NULL)
+		return -ENOSYS;
+	return tfm->crt_digest.dit_setkey(tfm, key, keylen);
+}
+
 static inline int crypto_cipher_setkey(struct crypto_tfm *tfm,
                                        const u8 *key, unsigned int keylen)
 {
diff -purN linux-post-2.6.5-rc2-20040320/include/net/xfrm.h linux-post-2.6.5-rc2-20040323/include/net/xfrm.h
--- linux-post-2.6.5-rc2-20040320/include/net/xfrm.h	2003-11-30 04:24:32.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/include/net/xfrm.h	2004-03-20 03:35:32.000000000 +0000
@@ -166,7 +166,7 @@ struct xfrm_policy_afinfo {
 	struct dst_ops		*dst_ops;
 	void			(*garbage_collect)(void);
 	int			(*dst_lookup)(struct xfrm_dst **dst, struct flowi *fl);
-	struct dst_entry	*(*find_bundle)(struct flowi *fl, struct rtable *rt, struct xfrm_policy *policy);
+	struct dst_entry	*(*find_bundle)(struct flowi *fl, struct xfrm_policy *policy);
 	int			(*bundle_create)(struct xfrm_policy *policy, 
 						 struct xfrm_state **xfrm, 
 						 int nx,
diff -purN linux-post-2.6.5-rc2-20040320/kernel/sysctl.c linux-post-2.6.5-rc2-20040323/kernel/sysctl.c
--- linux-post-2.6.5-rc2-20040320/kernel/sysctl.c	2004-02-25 10:34:51.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/kernel/sysctl.c	2004-03-21 08:00:57.000000000 +0000
@@ -1004,7 +1004,8 @@ int do_sysctl_strategy (ctl_table *table
 	 * zero, proceed with automatic r/w */
 	if (table->data && table->maxlen) {
 		if (oldval && oldlenp) {
-			get_user(len, oldlenp);
+			if (get_user(len, oldlenp))
+				return -EFAULT;
 			if (len) {
 				if (len > table->maxlen)
 					len = table->maxlen;
@@ -1303,7 +1304,7 @@ int proc_dostring(ctl_table *table, int 
 		len = 0;
 		p = buffer;
 		while (len < *lenp) {
-			if(get_user(c, p++))
+			if (get_user(c, p++))
 				return -EFAULT;
 			if (c == 0 || c == '\n')
 				break;
@@ -1470,7 +1471,7 @@ static int do_proc_dointvec(ctl_table *t
 		p = (char *) buffer;
 		while (left) {
 			char c;
-			if(get_user(c, p++))
+			if (get_user(c, p++))
 				return -EFAULT;
 			if (!isspace(c))
 				break;
@@ -1705,7 +1706,7 @@ static int do_proc_doulongvec_minmax(ctl
 		p = (char *) buffer;
 		while (left) {
 			char c;
-			if(get_user(c, p++))
+			if (get_user(c, p++))
 				return -EFAULT;
 			if (!isspace(c))
 				break;
@@ -1930,7 +1931,7 @@ int sysctl_string(ctl_table *table, int 
 		return -ENOTDIR;
 	
 	if (oldval && oldlenp) {
-		if(get_user(len, oldlenp))
+		if (get_user(len, oldlenp))
 			return -EFAULT;
 		if (len) {
 			l = strlen(table->data);
@@ -1987,7 +1988,8 @@ int sysctl_intvec(ctl_table *table, int 
 
 		for (i = 0; i < length; i++) {
 			int value;
-			get_user(value, vec + i);
+			if (get_user(value, vec + i))
+				return -EFAULT;
 			if (min && value < min[i])
 				return -EINVAL;
 			if (max && value > max[i])
diff -purN linux-post-2.6.5-rc2-20040320/lib/inflate.c linux-post-2.6.5-rc2-20040323/lib/inflate.c
--- linux-post-2.6.5-rc2-20040320/lib/inflate.c	2003-12-30 08:42:22.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/lib/inflate.c	2004-03-21 23:53:16.000000000 +0000
@@ -102,6 +102,7 @@
       a repeat code (16, 17, or 18) to go across the boundary between
       the two sets of lengths.
  */
+#include <linux/compiler.h>
 
 #ifdef RCSID
 static char rcsid[] = "#Id: inflate.c,v 0.14 1993/06/10 13:27:04 jloup Exp #";
@@ -685,8 +686,10 @@ DEBG("<stor");
 }
 
 
-
-STATIC int inflate_fixed(void)
+/*
+ * We use `noinline' here to prevent gcc-3.5 from using too much stack space
+ */
+STATIC int noinline inflate_fixed(void)
 /* decompress an inflated type 1 (fixed Huffman codes) block.  We should
    either replace this with a custom decoder, or at least precompute the
    Huffman tables. */
@@ -739,8 +742,10 @@ DEBG("<fix");
 }
 
 
-
-STATIC int inflate_dynamic(void)
+/*
+ * We use `noinline' here to prevent gcc-3.5 from using too much stack space
+ */
+STATIC int noinline inflate_dynamic(void)
 /* decompress an inflated type 2 (dynamic Huffman codes) block. */
 {
   int i;                /* temporary variables */
diff -purN linux-post-2.6.5-rc2-20040320/mm/mprotect.c linux-post-2.6.5-rc2-20040323/mm/mprotect.c
--- linux-post-2.6.5-rc2-20040320/mm/mprotect.c	2003-09-25 05:11:49.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/mm/mprotect.c	2004-03-21 08:00:58.000000000 +0000
@@ -237,7 +237,7 @@ sys_mprotect(unsigned long start, size_t
 	len = PAGE_ALIGN(len);
 	end = start + len;
 	if (end < start)
-		return -EINVAL;
+		return -ENOMEM;
 	if (prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM))
 		return -EINVAL;
 	if (end == start)
diff -purN linux-post-2.6.5-rc2-20040320/mm/slab.c linux-post-2.6.5-rc2-20040323/mm/slab.c
--- linux-post-2.6.5-rc2-20040320/mm/slab.c	2004-03-17 02:10:10.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/mm/slab.c	2004-03-21 07:49:49.000000000 +0000
@@ -576,7 +576,7 @@ static void __slab_error(const char *fun
  * Add the CPU number into the expiry time to minimize the possibility of the
  * CPUs getting into lockstep and contending for the global cache chain lock.
  */
-static void __init start_cpu_timer(int cpu)
+static void __devinit start_cpu_timer(int cpu)
 {
 	struct timer_list *rt = &per_cpu(reap_timers, cpu);
 
diff -purN linux-post-2.6.5-rc2-20040320/net/bluetooth/hci_sysfs.c linux-post-2.6.5-rc2-20040323/net/bluetooth/hci_sysfs.c
--- linux-post-2.6.5-rc2-20040320/net/bluetooth/hci_sysfs.c	2004-02-25 23:53:43.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/net/bluetooth/hci_sysfs.c	2004-03-20 10:39:10.000000000 +0000
@@ -52,7 +52,7 @@ static ssize_t show_inquiry_cache(struct
 		n += sprintf(buf + n, "%s %d %d %d 0x%.2x%.2x%.2x 0x%.4x 0x%.2x %u\n",
 				batostr(&bdaddr),
 				info->pscan_rep_mode, info->pscan_period_mode, info->pscan_mode,
-				info->dev_class[0], info->dev_class[1], info->dev_class[2],
+				info->dev_class[2], info->dev_class[1], info->dev_class[0],
 				info->clock_offset, 0, e->timestamp);
 	}
 
diff -purN linux-post-2.6.5-rc2-20040320/net/ipv4/xfrm4_policy.c linux-post-2.6.5-rc2-20040323/net/ipv4/xfrm4_policy.c
--- linux-post-2.6.5-rc2-20040320/net/ipv4/xfrm4_policy.c	2003-07-28 02:22:27.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/net/ipv4/xfrm4_policy.c	2004-03-20 03:35:32.000000000 +0000
@@ -43,14 +43,10 @@ static int __xfrm4_bundle_ok(struct xfrm
 }
 
 static struct dst_entry *
-__xfrm4_find_bundle(struct flowi *fl, struct rtable *rt, struct xfrm_policy *policy)
+__xfrm4_find_bundle(struct flowi *fl, struct xfrm_policy *policy)
 {
 	struct dst_entry *dst;
 
-	if (!fl->fl4_src)
-		fl->fl4_src = rt->rt_src;
-	if (!fl->fl4_dst)
-		fl->fl4_dst = rt->rt_dst;
 	read_lock_bh(&policy->lock);
 	for (dst = policy->bundles; dst; dst = dst->next) {
 		struct xfrm_dst *xdst = (struct xfrm_dst*)dst;
diff -purN linux-post-2.6.5-rc2-20040320/net/ipv6/xfrm6_policy.c linux-post-2.6.5-rc2-20040323/net/ipv6/xfrm6_policy.c
--- linux-post-2.6.5-rc2-20040320/net/ipv6/xfrm6_policy.c	2004-02-11 18:34:58.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/net/ipv6/xfrm6_policy.c	2004-03-20 03:35:32.000000000 +0000
@@ -52,7 +52,7 @@ static int __xfrm6_bundle_ok(struct xfrm
 }
 
 static struct dst_entry *
-__xfrm6_find_bundle(struct flowi *fl, struct rtable *rt, struct xfrm_policy *policy)
+__xfrm6_find_bundle(struct flowi *fl, struct xfrm_policy *policy)
 {
 	struct dst_entry *dst;
 
diff -purN linux-post-2.6.5-rc2-20040320/net/sched/sch_htb.c linux-post-2.6.5-rc2-20040323/net/sched/sch_htb.c
--- linux-post-2.6.5-rc2-20040320/net/sched/sch_htb.c	2004-03-15 21:46:01.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/net/sched/sch_htb.c	2004-03-22 06:51:20.000000000 +0000
@@ -21,9 +21,11 @@
  *			created test case so that I was able to fix nasty bug
  *		Wilfried Weissmann
  *			spotted bug in dequeue code and helped with fix
+ *		Jiri Fojtasek
+ *			fixed requeue routine
  *		and many others. thanks.
  *
- * $Id: sch_htb.c,v 1.24 2003/07/28 15:25:23 devik Exp devik $
+ * $Id: sch_htb.c,v 1.25 2003/12/07 11:08:25 devik Exp devik $
  */
 #include <linux/config.h>
 #include <linux/module.h>
@@ -74,7 +76,7 @@
 #define HTB_HYSTERESIS 1/* whether to use mode hysteresis for speedup */
 #define HTB_QLOCK(S) spin_lock_bh(&(S)->dev->queue_lock)
 #define HTB_QUNLOCK(S) spin_unlock_bh(&(S)->dev->queue_lock)
-#define HTB_VER 0x3000f	/* major must be matched with number suplied by TC as version */
+#define HTB_VER 0x30010	/* major must be matched with number suplied by TC as version */
 
 #if HTB_VER >> 16 != TC_HTB_PROTOVER
 #error "Mismatched sch_htb.c and pkt_sch.h"
@@ -708,7 +710,7 @@ static int htb_enqueue(struct sk_buff *s
 
     sch->q.qlen++;
     sch->stats.packets++; sch->stats.bytes += skb->len;
-    HTB_DBG(1,1,"htb_enq_ok cl=%X skb=%p\n",htb_classid(cl),skb);
+    HTB_DBG(1,1,"htb_enq_ok cl=%X skb=%p\n",(cl && cl != HTB_DIRECT)?cl->classid:0,skb);
     return NET_XMIT_SUCCESS;
 }
 
@@ -717,16 +719,18 @@ static int htb_requeue(struct sk_buff *s
 {
     struct htb_sched *q = (struct htb_sched *)sch->data;
     struct htb_class *cl = htb_classify(skb,sch);
+    struct sk_buff *tskb;
 
     if (cl == HTB_DIRECT || !cl) {
 	/* enqueue to helper queue */
 	if (q->direct_queue.qlen < q->direct_qlen && cl) {
-	    __skb_queue_tail(&q->direct_queue, skb);
-	    q->direct_pkts++;
+	    __skb_queue_head(&q->direct_queue, skb);
 	} else {
-	    kfree_skb (skb);
-	    sch->stats.drops++;
-	    return NET_XMIT_DROP;
+            __skb_queue_head(&q->direct_queue, skb);
+            tskb = __skb_dequeue_tail(&q->direct_queue);
+            kfree_skb (tskb);
+            sch->stats.drops++;
+            return NET_XMIT_CN;	
 	}
     } else if (cl->un.leaf.q->ops->requeue(skb, cl->un.leaf.q) != NET_XMIT_SUCCESS) {
 	sch->stats.drops++;
@@ -736,7 +740,7 @@ static int htb_requeue(struct sk_buff *s
 	    htb_activate (q,cl);
 
     sch->q.qlen++;
-    HTB_DBG(1,1,"htb_req_ok cl=%X skb=%p\n",htb_classid(cl),skb);
+    HTB_DBG(1,1,"htb_req_ok cl=%X skb=%p\n",(cl && cl != HTB_DIRECT)?cl->classid:0,skb);
     return NET_XMIT_SUCCESS;
 }
 
@@ -1487,7 +1491,7 @@ static int htb_change_class(struct Qdisc
 		cl->magic = HTB_CMAGIC;
 #endif
 
-		/* create leaf qdisc early because it uses kmalloc(GPF_KERNEL)
+		/* create leaf qdisc early because it uses kmalloc(GFP_KERNEL)
 		   so that can't be used inside of sch_tree_lock
 		   -- thanks to Karlis Peisenieks */
 		new_q = qdisc_create_dflt(sch->dev, &pfifo_qdisc_ops);
diff -purN linux-post-2.6.5-rc2-20040320/net/xfrm/xfrm_policy.c linux-post-2.6.5-rc2-20040323/net/xfrm/xfrm_policy.c
--- linux-post-2.6.5-rc2-20040320/net/xfrm/xfrm_policy.c	2004-02-05 07:08:29.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/net/xfrm/xfrm_policy.c	2004-03-20 03:35:32.000000000 +0000
@@ -646,13 +646,13 @@ fail:
  */
 
 static struct dst_entry *
-xfrm_find_bundle(struct flowi *fl, struct rtable *rt, struct xfrm_policy *policy, unsigned short family)
+xfrm_find_bundle(struct flowi *fl, struct xfrm_policy *policy, unsigned short family)
 {
 	struct dst_entry *x;
 	struct xfrm_policy_afinfo *afinfo = xfrm_policy_get_afinfo(family);
 	if (unlikely(afinfo == NULL))
 		return ERR_PTR(-EINVAL);
-	x = afinfo->find_bundle(fl, rt, policy);
+	x = afinfo->find_bundle(fl, policy);
 	xfrm_policy_put_afinfo(afinfo);
 	return x;
 }
@@ -762,7 +762,7 @@ restart:
 		 * LATER: help from flow cache. It is optional, this
 		 * is required only for output policy.
 		 */
-		dst = xfrm_find_bundle(fl, rt, policy, family);
+		dst = xfrm_find_bundle(fl, policy, family);
 		if (IS_ERR(dst)) {
 			xfrm_pol_put(policy);
 			return PTR_ERR(dst);
diff -purN linux-post-2.6.5-rc2-20040320/sound/oss/via82cxxx_audio.c linux-post-2.6.5-rc2-20040323/sound/oss/via82cxxx_audio.c
--- linux-post-2.6.5-rc2-20040320/sound/oss/via82cxxx_audio.c	2003-12-29 21:38:34.000000000 +0000
+++ linux-post-2.6.5-rc2-20040323/sound/oss/via82cxxx_audio.c	2004-03-21 20:16:37.000000000 +0000
@@ -3411,12 +3411,18 @@ static int __devinit via_init_one (struc
 	rc = pci_enable_device (pdev);
 	if (rc)
 		goto err_out;
-		
 
 	rc = pci_request_regions (pdev, "via82cxxx_audio");
 	if (rc)
 		goto err_out_disable;
 
+	rc = pci_set_dma_mask(pdev, 0xffffffffULL);
+	if (rc)
+		goto err_out_res;
+	rc = pci_set_consistent_dma_mask(pdev, 0xffffffffULL);
+	if (rc)
+		goto err_out_res;
+
 	card = kmalloc (sizeof (*card), GFP_KERNEL);
 	if (!card) {
 		printk (KERN_ERR PFX "out of memory, aborting\n");
