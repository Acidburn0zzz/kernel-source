diff -rup linux-2.6.5/sound/arm/sa11xx-uda1341.c linux/sound/arm/sa11xx-uda1341.c
--- linux-2.6.5/sound/arm/sa11xx-uda1341.c	2004-04-04 05:36:16.000000000 +0200
+++ linux/sound/arm/sa11xx-uda1341.c	2004-04-07 12:48:05.000000000 +0200
@@ -62,6 +62,7 @@
 #include <linux/config.h>
 #include <sound/driver.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/ioctl.h>
@@ -112,7 +113,7 @@ MODULE_DEVICES("{{UDA1341,iPAQ H3600 UDA
 
 static char *id = NULL;	/* ID for this card */
 
-MODULE_PARM(id, "s");
+module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for SA1100/SA1111 + UDA1341TS soundcard.");
 
 #define chip_t sa11xx_uda1341_t
diff -rup linux-2.6.5/sound/core/control.c linux/sound/core/control.c
--- linux-2.6.5/sound/core/control.c	2004-04-04 05:36:25.000000000 +0200
+++ linux/sound/core/control.c	2004-04-08 13:09:46.000000000 +0200
@@ -995,6 +995,33 @@
 	return 0;
 }
 
+#ifdef CONFIG_PM
+/*
+ * change the power state
+ */
+static int snd_ctl_set_power_state(snd_card_t *card, unsigned int power_state)
+{
+	switch (power_state) {
+	case SNDRV_CTL_POWER_D0:
+	case SNDRV_CTL_POWER_D1:
+	case SNDRV_CTL_POWER_D2:
+		if (card->power_state != power_state)
+			/* FIXME: pass the correct state value */
+			card->pm_resume(card, 0);
+		break;
+	case SNDRV_CTL_POWER_D3hot:
+	case SNDRV_CTL_POWER_D3cold:
+		if (card->power_state != power_state)
+			/* FIXME: pass the correct state value */
+			card->pm_suspend(card, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+#endif
+
 static int snd_ctl_ioctl(struct inode *inode, struct file *file,
 			 unsigned int cmd, unsigned long arg)
 {
@@ -1038,9 +1065,9 @@
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
 #ifdef CONFIG_PM
-		if (card->set_power_state) {
+		if (card->pm_suspend && card->pm_resume) {
 			snd_power_lock(card);
-			err = card->set_power_state(card, err);
+			err = snd_ctl_set_power_state(card, err);
 			snd_power_unlock(card);
 		} else
 #endif
diff -rup linux-2.6.5/sound/core/init.c linux/sound/core/init.c
--- linux-2.6.5/sound/core/init.c	2004-04-04 05:36:26.000000000 +0200
+++ linux/sound/core/init.c	2004-04-15 11:21:16.000000000 +0200
@@ -26,6 +26,8 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/ctype.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/info.h>
@@ -254,6 +256,12 @@ int snd_card_free(snd_card_t * card)
 
 #ifdef CONFIG_PM
 	wake_up(&card->power_sleep);
+#ifdef CONFIG_ISA
+	if (card->pm_dev) {
+		pm_unregister(card->pm_dev);
+		card->pm_dev = NULL;
+	}
+#endif
 #endif
 
 	/* wait, until all devices are ready for the free operation */
@@ -708,4 +716,93 @@ int snd_power_wait(snd_card_t *card, uns
 	remove_wait_queue(&card->power_sleep, &wait);
 	return result;
 }
+
+/**
+ * snd_card_set_pm_callback - set the PCI power-management callbacks
+ * @card: soundcard structure
+ * @suspend: suspend callback function
+ * @resume: resume callback function
+ * @private_data: private data to pass to the callback functions
+ *
+ * Sets the power-management callback functions of the card.
+ * These callbacks are called from ALSA's common PCI suspend/resume
+ * handler and from the control API.
+ */
+int snd_card_set_pm_callback(snd_card_t *card,
+			     int (*suspend)(snd_card_t *, unsigned int),
+			     int (*resume)(snd_card_t *, unsigned int),
+			     void *private_data)
+{
+	card->pm_suspend = suspend;
+	card->pm_resume = resume;
+	card->pm_private_data = private_data;
+	return 0;
+}
+
+#ifdef CONFIG_ISA
+static int snd_isa_pm_callback(struct pm_dev *dev, pm_request_t rqst, void *data)
+{
+	snd_card_t *card = dev->data;
+
+	switch (rqst) {
+	case PM_SUSPEND:
+		/* FIXME: the correct state value? */
+		card->pm_suspend(card, 0);
+		break;
+	case PM_RESUME:
+		/* FIXME: the correct state value? */
+		card->pm_resume(card, 0);
+		break;
+	}
+	return 0;
+}
+
+/**
+ * snd_card_set_isa_pm_callback - set the ISA power-management callbacks
+ * @card: soundcard structure
+ * @suspend: suspend callback function
+ * @resume: resume callback function
+ * @private_data: private data to pass to the callback functions
+ *
+ * Registers the power-management and sets the lowlevel callbacks for
+ * the given ISA card.  These callbacks are called from the ALSA's
+ * common PM handler and from the control API.
+ */
+int snd_card_set_isa_pm_callback(snd_card_t *card,
+				 int (*suspend)(snd_card_t *, unsigned int),
+				 int (*resume)(snd_card_t *, unsigned int),
+				 void *private_data)
+{
+	card->pm_dev = pm_register(PM_ISA_DEV, 0, snd_isa_pm_callback);
+	if (! card->pm_dev)
+		return -ENOMEM;
+	card->pm_dev->data = card;
+	return snd_card_set_pm_callback(card, suspend, resume, private_data);
+}
+#endif
+
+#ifdef CONFIG_PCI
+int snd_card_pci_suspend(struct pci_dev *dev, u32 state)
+{
+	snd_card_t *card = pci_get_drvdata(dev);
+	if (! card || ! card->pm_suspend)
+		return 0;
+	if (card->power_state == SNDRV_CTL_POWER_D3hot)
+		return 0;
+	/* FIXME: correct state value? */
+	return card->pm_suspend(card, 0);
+}
+
+int snd_card_pci_resume(struct pci_dev *dev)
+{
+	snd_card_t *card = pci_get_drvdata(dev);
+	if (! card || ! card->pm_resume)
+		return 0;
+	if (card->power_state == SNDRV_CTL_POWER_D0)
+		return 0;
+	/* FIXME: correct state value? */
+	return card->pm_resume(card, 0);
+}
+#endif
+
 #endif /* CONFIG_PM */
diff -rup linux-2.6.5/sound/core/memalloc.c linux/sound/core/memalloc.c
--- linux-2.6.5/sound/core/memalloc.c	2004-04-04 05:38:21.000000000 +0200
+++ linux/sound/core/memalloc.c	2004-04-13 18:58:05.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
+#include <linux/moduleparam.h>
 #include <asm/semaphore.h>
 #include <sound/memalloc.h>
 #ifdef CONFIG_SBUS
@@ -45,7 +46,8 @@
 #define SNDRV_CARDS	8
 #endif
 static int enable[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+static int boot_devs;
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable cards to allocate buffers.");
 
 /*
@@ -89,32 +91,7 @@
  *  Hacks
  */
 
-static void *snd_dma_alloc_coherent1(struct device *dev, size_t size,
-				     dma_addr_t *dma_handle, int flags)
-{
-	if (dev)
-		return dma_alloc_coherent(dev, size, dma_handle, flags);
-	else /* FIXME: dma_alloc_coherent does't always accept dev=NULL */
-		return pci_alloc_consistent(NULL, size, dma_handle);
-}
-
-static void snd_dma_free_coherent1(struct device *dev, size_t size, void *dma_addr,
-				   dma_addr_t dma_handle)
-{
-	if (dev)
-		return dma_free_coherent(dev, size, dma_addr, dma_handle);
-	else
-		return pci_free_consistent(NULL, size, dma_addr, dma_handle);
-}
-
-#undef dma_alloc_coherent
-#define dma_alloc_coherent snd_dma_alloc_coherent1
-#undef dma_free_coherent
-#define dma_free_coherent snd_dma_free_coherent1
-
-
 #if defined(__i386__) || defined(__ppc__) || defined(__x86_64__)
-
 /*
  * A hack to allocate large buffers via dma_alloc_coherent()
  *
@@ -135,14 +112,17 @@
 					 dma_addr_t *dma_handle, int flags)
 {
 	void *ret;
-	u64 dma_mask;
+	u64 dma_mask, coherent_dma_mask;
 
 	if (dev == NULL || !dev->dma_mask)
 		return dma_alloc_coherent(dev, size, dma_handle, flags);
 	dma_mask = *dev->dma_mask;
+	coherent_dma_mask = dev->coherent_dma_mask;
 	*dev->dma_mask = 0xffffffff; 	/* do without masking */
+	dev->coherent_dma_mask = 0xffffffff; 	/* do without masking */
 	ret = dma_alloc_coherent(dev, size, dma_handle, flags);
 	*dev->dma_mask = dma_mask;	/* restore */
+	dev->coherent_dma_mask = coherent_dma_mask;	/* restore */
 	if (ret) {
 		/* obtained address is out of range? */
 		if (((unsigned long)*dma_handle + size - 1) & ~dma_mask) {
@@ -152,8 +132,12 @@
 		}
 	} else {
 		/* wish to success now with the proper mask... */
-		if (dma_mask != 0xffffffffUL)
+		if (dma_mask != 0xffffffffUL) {
+			/* allocation with GFP_ATOMIC to avoid the long stall */
+			flags &= ~GFP_KERNEL;
+			flags |= GFP_ATOMIC;
 			ret = dma_alloc_coherent(dev, size, dma_handle, flags);
+		}
 	}
 	return ret;
 }
@@ -842,25 +826,6 @@
 module_exit(snd_mem_exit)
 
 
-#ifndef MODULE
-
-/* format is: snd-page-alloc=enable */
-
-static int __init snd_mem_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-page-alloc=", snd_mem_setup);
-
-#endif
-
 /*
  * exports
  */
diff -rup linux-2.6.5/sound/core/oss/pcm_oss.c linux/sound/core/oss/pcm_oss.c
--- linux-2.6.5/sound/core/oss/pcm_oss.c	2004-04-04 05:38:12.000000000 +0200
+++ linux/sound/core/oss/pcm_oss.c	2004-04-07 17:00:25.000000000 +0200
@@ -31,6 +31,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/vmalloc.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/pcm.h>
@@ -45,17 +46,18 @@
 static int dsp_map[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 0};
 static int adsp_map[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};
 static int nonblock_open;
+static int boot_devs;
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Abramo Bagnara <abramo@alsa-project.org>");
 MODULE_DESCRIPTION("PCM OSS emulation for ALSA.");
 MODULE_LICENSE("GPL");
-MODULE_PARM(dsp_map, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dsp_map, int, boot_devs, 0444);
 MODULE_PARM_DESC(dsp_map, "PCM device number assigned to 1st OSS device.");
 MODULE_PARM_SYNTAX(dsp_map, "default:0,skill:advanced");
-MODULE_PARM(adsp_map, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(adsp_map, int, boot_devs, 0444);
 MODULE_PARM_DESC(adsp_map, "PCM device number assigned to 2nd OSS device.");
 MODULE_PARM_SYNTAX(adsp_map, "default:1,skill:advanced");
-MODULE_PARM(nonblock_open, "i");
+module_param(nonblock_open, bool, 0444);
 MODULE_PARM_DESC(nonblock_open, "Don't block opening busy PCM devices.");
 MODULE_PARM_SYNTAX(nonblock_open, "default:0,skill:advanced");
 MODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_PCM);
@@ -2510,24 +2512,3 @@ static void __exit alsa_pcm_oss_exit(voi
 
 module_init(alsa_pcm_oss_init)
 module_exit(alsa_pcm_oss_exit)
-
-#ifndef MODULE
-
-/* format is: snd-pcm-oss=dsp_map,adsp_map[,nonblock_open] */
-
-static int __init alsa_pcm_oss_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&dsp_map[nr_dev]) == 2 &&
-	       get_option(&str,&adsp_map[nr_dev]) == 2);
-	(void)(get_option(&str,&nonblock_open) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-pcm-oss=", alsa_pcm_oss_setup);
-
-#endif /* !MODULE */
diff -rup linux-2.6.5/sound/core/pcm_memory.c linux/sound/core/pcm_memory.c
--- linux-2.6.5/sound/core/pcm_memory.c	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/core/pcm_memory.c	2004-04-07 16:35:59.000000000 +0200
@@ -23,18 +23,19 @@
 #include <asm/io.h>
 #include <linux/time.h>
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/info.h>
 #include <sound/initval.h>
 
 static int preallocate_dma = 1;
-MODULE_PARM(preallocate_dma, "i");
+module_param(preallocate_dma, int, 0444);
 MODULE_PARM_DESC(preallocate_dma, "Preallocate DMA memory when the PCM devices are initialized.");
 MODULE_PARM_SYNTAX(preallocate_dma, SNDRV_BOOLEAN_TRUE_DESC);
 
 static int maximum_substreams = 4;
-MODULE_PARM(maximum_substreams, "i");
+module_param(maximum_substreams, int, 0444);
 MODULE_PARM_DESC(maximum_substreams, "Maximum substreams with preallocated DMA memory.");
 MODULE_PARM_SYNTAX(maximum_substreams, SNDRV_BOOLEAN_TRUE_DESC);
 
diff -rup linux-2.6.5/sound/core/pcm_native.c linux/sound/core/pcm_native.c
--- linux-2.6.5/sound/core/pcm_native.c	2004-04-04 05:36:55.000000000 +0200
+++ linux/sound/core/pcm_native.c	2004-04-15 11:11:02.000000000 +0200
@@ -1038,7 +1038,7 @@ static int snd_pcm_resume(snd_pcm_substr
 
 	snd_power_lock(card);
 	if ((res = snd_power_wait(card, SNDRV_CTL_POWER_D0, substream->ffile)) >= 0)
-		return snd_pcm_action_lock_irq(&snd_pcm_action_resume, substream, 0, 0);
+		res = snd_pcm_action_lock_irq(&snd_pcm_action_resume, substream, 0, 0);
 	snd_power_unlock(card);
 	return res;
 }
diff -rup linux-2.6.5/sound/core/rawmidi.c linux/sound/core/rawmidi.c
--- linux-2.6.5/sound/core/rawmidi.c	2004-04-04 05:36:25.000000000 +0200
+++ linux/sound/core/rawmidi.c	2004-04-07 17:00:33.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/wait.h>
+#include <linux/moduleparam.h>
 #include <sound/rawmidi.h>
 #include <sound/info.h>
 #include <sound/control.h>
@@ -40,10 +41,11 @@ MODULE_LICENSE("GPL");
 #ifdef CONFIG_SND_OSSEMUL
 static int midi_map[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 0};
 static int amidi_map[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};
-MODULE_PARM(midi_map, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+static int boot_devs;
+module_param_array(midi_map, int, boot_devs, 0444);
 MODULE_PARM_DESC(midi_map, "Raw MIDI device number assigned to 1st OSS device.");
 MODULE_PARM_SYNTAX(midi_map, "default:0,skill:advanced");
-MODULE_PARM(amidi_map, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(amidi_map, int, boot_devs, 0444);
 MODULE_PARM_DESC(amidi_map, "Raw MIDI device number assigned to 2nd OSS device.");
 MODULE_PARM_SYNTAX(amidi_map, "default:1,skill:advanced");
 #endif /* CONFIG_SND_OSSEMUL */
@@ -1637,26 +1639,6 @@ static void __exit alsa_rawmidi_exit(voi
 module_init(alsa_rawmidi_init)
 module_exit(alsa_rawmidi_exit)
 
-#ifndef MODULE
-#ifdef CONFIG_SND_OSSEMUL
-/* format is: snd-rawmidi=midi_map,amidi_map */
-
-static int __init alsa_rawmidi_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&midi_map[nr_dev]) == 2 &&
-	       get_option(&str,&amidi_map[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-rawmidi=", alsa_rawmidi_setup);
-#endif /* CONFIG_SND_OSSEMUL */
-#endif /* ifndef MODULE */
-
 EXPORT_SYMBOL(snd_rawmidi_output_params);
 EXPORT_SYMBOL(snd_rawmidi_input_params);
 EXPORT_SYMBOL(snd_rawmidi_drop_output);
diff -rup linux-2.6.5/sound/core/rtctimer.c linux/sound/core/rtctimer.c
--- linux-2.6.5/sound/core/rtctimer.c	2004-04-04 05:37:45.000000000 +0200
+++ linux/sound/core/rtctimer.c	2004-04-07 16:37:22.000000000 +0200
@@ -25,6 +25,7 @@
 #include <linux/time.h>
 #include <linux/threads.h>
 #include <linux/interrupt.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/timer.h>
 #include <sound/info.h>
@@ -177,21 +178,9 @@ static void __exit rtctimer_exit(void)
 module_init(rtctimer_init)
 module_exit(rtctimer_exit)
 
-MODULE_PARM(rtctimer_freq, "i");
+module_param(rtctimer_freq, int, 0444);
 MODULE_PARM_DESC(rtctimer_freq, "timer frequency in Hz");
 
 MODULE_LICENSE("GPL");
 
-#ifndef MODULE
-/* format is: snd-rtctimer=freq */
-
-static int __init rtctimer_setup(char *str)
-{
-	(void)(get_option(&str,&rtctimer_freq) == 2);
-	return 1;
-}
-
-__setup("snd-rtctimer=", rtctimer_setup);
-#endif /* ifndef MODULE */
-
 #endif /* CONFIG_RTC || CONFIG_RTC_MODULE */
diff -rup linux-2.6.5/sound/core/seq/oss/seq_oss.c linux/sound/core/seq/oss/seq_oss.c
--- linux-2.6.5/sound/core/seq/oss/seq_oss.c	2004-04-04 05:37:42.000000000 +0200
+++ linux/sound/core/seq/oss/seq_oss.c	2004-04-07 16:40:30.000000000 +0200
@@ -22,6 +22,7 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/initval.h>
@@ -40,7 +41,7 @@ MODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS
 MODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_MUSIC);
 
 #ifdef SNDRV_SEQ_OSS_DEBUG
-MODULE_PARM(seq_oss_debug, "i");
+module_param(seq_oss_debug, int, 0444);
 MODULE_PARM_DESC(seq_oss_debug, "debug option");
 int seq_oss_debug = 0;
 #endif
diff -rup linux-2.6.5/sound/core/seq/oss/seq_oss_init.c linux/sound/core/seq/oss/seq_oss_init.c
--- linux-2.6.5/sound/core/seq/oss/seq_oss_init.c	2004-04-04 05:36:17.000000000 +0200
+++ linux/sound/core/seq/oss/seq_oss_init.c	2004-04-07 17:03:23.000000000 +0200
@@ -28,17 +28,18 @@
 #include "seq_oss_timer.h"
 #include "seq_oss_event.h"
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 
 /*
  * common variables
  */
-MODULE_PARM(maxqlen, "i");
+static int maxqlen = SNDRV_SEQ_OSS_MAX_QLEN;
+module_param(maxqlen, int, 0444);
 MODULE_PARM_DESC(maxqlen, "maximum queue length");
 
 static int system_client = -1; /* ALSA sequencer client number */
 static int system_port = -1;
 
-int maxqlen = SNDRV_SEQ_OSS_MAX_QLEN;
 static int num_clients;
 static seq_oss_devinfo_t *client_table[SNDRV_SEQ_OSS_MAX_CLIENTS];
 
diff -rup linux-2.6.5/sound/core/seq/seq.c linux/sound/core/seq/seq.c
--- linux-2.6.5/sound/core/seq/seq.c	2004-04-04 05:37:37.000000000 +0200
+++ linux/sound/core/seq/seq.c	2004-04-13 12:48:11.000000000 +0200
@@ -21,6 +21,7 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/initval.h>
 
@@ -34,7 +35,11 @@
 #include "seq_info.h"
 #include <sound/seq_device.h>
 
+#if defined(CONFIG_SND_SEQ_DUMMY_MODULE)
+int seq_client_load[64] = {[0] = SNDRV_SEQ_CLIENT_DUMMY, [1 ... 63] = -1};
+#else
 int seq_client_load[64] = {[0 ... 63] = -1};
+#endif
 int seq_default_timer_class = SNDRV_TIMER_CLASS_GLOBAL;
 int seq_default_timer_sclass = SNDRV_TIMER_SCLASS_NONE;
 int seq_default_timer_card = -1;
@@ -48,19 +53,20 @@ MODULE_LICENSE("GPL");
 MODULE_CLASSES("{sound}");
 MODULE_SUPPORTED_DEVICE("sound");
 
-MODULE_PARM(seq_client_load, "1-64i");
+static int boot_devs;
+module_param_array(seq_client_load, int, boot_devs, 0444);
 MODULE_PARM_DESC(seq_client_load, "The numbers of global (system) clients to load through kmod.");
-MODULE_PARM(seq_default_timer_class, "i");
+module_param(seq_default_timer_class, int, 0444);
 MODULE_PARM_DESC(seq_default_timer_class, "The default timer class.");
-MODULE_PARM(seq_default_timer_sclass, "i");
+module_param(seq_default_timer_sclass, int, 0444);
 MODULE_PARM_DESC(seq_default_timer_sclass, "The default timer slave class.");
-MODULE_PARM(seq_default_timer_card, "i");
+module_param(seq_default_timer_card, int, 0444);
 MODULE_PARM_DESC(seq_default_timer_card, "The default timer card number.");
-MODULE_PARM(seq_default_timer_device, "i");
+module_param(seq_default_timer_device, int, 0444);
 MODULE_PARM_DESC(seq_default_timer_device, "The default timer device number.");
-MODULE_PARM(seq_default_timer_subdevice, "i");
+module_param(seq_default_timer_subdevice, int, 0444);
 MODULE_PARM_DESC(seq_default_timer_subdevice, "The default timer subdevice number.");
-MODULE_PARM(seq_default_timer_resolution, "i");
+module_param(seq_default_timer_resolution, int, 0444);
 MODULE_PARM_DESC(seq_default_timer_resolution, "The default timer resolution in Hz.");
 
 /*
diff -rup linux-2.6.5/sound/core/seq/seq_dummy.c linux/sound/core/seq/seq_dummy.c
--- linux-2.6.5/sound/core/seq/seq_dummy.c	2004-04-04 05:37:07.000000000 +0200
+++ linux/sound/core/seq/seq_dummy.c	2004-04-07 16:35:36.000000000 +0200
@@ -21,6 +21,7 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include "seq_clientmgr.h"
 #include <sound/initval.h>
@@ -64,12 +65,14 @@ MODULE_DESCRIPTION("ALSA sequencer MIDI-
 MODULE_LICENSE("GPL");
 MODULE_CLASSES("{sound}");
 MODULE_SUPPORTED_DEVICE("sound");
-MODULE_PARM(ports, "i");
+
+static int ports = 1;
+static int duplex = 0;
+
+module_param(ports, int, 0444);
 MODULE_PARM_DESC(ports, "number of ports to be created");
-MODULE_PARM(duplex, "i");
+module_param(duplex, bool, 0444);
 MODULE_PARM_DESC(duplex, "create DUPLEX ports");
-int ports = 1;
-int duplex = 0;
 
 typedef struct snd_seq_dummy_port {
 	int client;
diff -rup linux-2.6.5/sound/core/seq/seq_midi.c linux/sound/core/seq/seq_midi.c
--- linux-2.6.5/sound/core/seq/seq_midi.c	2004-04-04 05:37:59.000000000 +0200
+++ linux/sound/core/seq/seq_midi.c	2004-04-07 16:35:05.000000000 +0200
@@ -31,6 +31,7 @@ Possible options for midisynth module:
 #include <linux/slab.h>
 #include <linux/errno.h>
 #include <linux/string.h>
+#include <linux/moduleparam.h>
 #include <asm/semaphore.h>
 #include <sound/core.h>
 #include <sound/rawmidi.h>
@@ -45,10 +46,10 @@ MODULE_LICENSE("GPL");
 MODULE_CLASSES("{sound}");
 MODULE_SUPPORTED_DEVICE("sound");
 int output_buffer_size = PAGE_SIZE;
-MODULE_PARM(output_buffer_size, "i");
+module_param(output_buffer_size, int, 0444);
 MODULE_PARM_DESC(output_buffer_size, "Output buffer size in bytes.");
 int input_buffer_size = PAGE_SIZE;
-MODULE_PARM(input_buffer_size, "i");
+module_param(input_buffer_size, int, 0444);
 MODULE_PARM_DESC(input_buffer_size, "Input buffer size in bytes.");
 
 /* data for this midi synth driver */
diff -rup linux-2.6.5/sound/core/sound.c linux/sound/core/sound.c
--- linux-2.6.5/sound/core/sound.c	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/core/sound.c	2004-04-08 18:28:22.000000000 +0200
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/info.h>
@@ -45,15 +46,15 @@ MODULE_DESCRIPTION("Advanced Linux Sound
 MODULE_LICENSE("GPL");
 MODULE_CLASSES("{sound}");
 MODULE_SUPPORTED_DEVICE("sound");
-MODULE_PARM(major, "i");
+module_param(major, int, 0444);
 MODULE_PARM_DESC(major, "Major # for sound driver.");
 MODULE_PARM_SYNTAX(major, "default:116,skill:devel");
-MODULE_PARM(cards_limit, "i");
+module_param(cards_limit, int, 0444);
 MODULE_PARM_DESC(cards_limit, "Count of auto-loadable soundcards.");
 MODULE_PARM_SYNTAX(cards_limit, "default:8,skill:advanced");
 MODULE_ALIAS_CHARDEV_MAJOR(CONFIG_SND_MAJOR);
 #ifdef CONFIG_DEVFS_FS
-MODULE_PARM(device_mode, "i");
+module_param(device_mode, int, 0444);
 MODULE_PARM_DESC(device_mode, "Device file permission mask for devfs.");
 MODULE_PARM_SYNTAX(device_mode, "default:0666,base:8");
 #endif
@@ -465,6 +466,14 @@ EXPORT_SYMBOL(snd_card_file_add);
 EXPORT_SYMBOL(snd_card_file_remove);
 #ifdef CONFIG_PM
 EXPORT_SYMBOL(snd_power_wait);
+EXPORT_SYMBOL(snd_card_set_pm_callback);
+#ifdef CONFIG_PCI
+EXPORT_SYMBOL(snd_card_pci_suspend);
+EXPORT_SYMBOL(snd_card_pci_resume);
+#endif
+#ifdef CONFIG_ISA
+EXPORT_SYMBOL(snd_card_set_isa_pm_callback);
+#endif
 #endif
   /* device.c */
 EXPORT_SYMBOL(snd_device_new);
diff -rup linux-2.6.5/sound/core/timer.c linux/sound/core/timer.c
--- linux-2.6.5/sound/core/timer.c	2004-04-04 05:37:27.000000000 +0200
+++ linux/sound/core/timer.c	2004-04-07 16:36:38.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/timer.h>
 #include <sound/control.h>
@@ -46,7 +47,7 @@ MODULE_AUTHOR("Jaroslav Kysela <perex@su
 MODULE_DESCRIPTION("ALSA timer interface");
 MODULE_LICENSE("GPL");
 MODULE_CLASSES("{sound}");
-MODULE_PARM(timer_limit, "i");
+module_param(timer_limit, int, 0444);
 MODULE_PARM_DESC(timer_limit, "Maximum global timers in system.");
 
 typedef struct {
@@ -1512,7 +1513,6 @@ static int snd_timer_user_info(struct fi
 
 static int snd_timer_user_params(struct file *file, snd_timer_params_t *_params)
 {
-	unsigned long flags;
 	snd_timer_user_t *tu;
 	snd_timer_params_t params;
 	snd_timer_t *t;
@@ -1548,18 +1548,17 @@ static int snd_timer_user_params(struct 
 		goto _end;
 	}
 	snd_timer_stop(tu->timeri);
-	spin_lock_irqsave(&t->lock, flags);
-	if (params.flags & SNDRV_TIMER_PSFLG_AUTO) {
+	spin_lock_irq(&t->lock);
+	tu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|
+			       SNDRV_TIMER_IFLG_EXCLUSIVE|
+			       SNDRV_TIMER_IFLG_EARLY_EVENT);
+	if (params.flags & SNDRV_TIMER_PSFLG_AUTO)
 		tu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;
-	} else {
-		tu->timeri->flags &= ~SNDRV_TIMER_IFLG_AUTO;
-	}
-	if (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE) {
+	if (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)
 		tu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;
-	} else {
-		tu->timeri->flags &= ~SNDRV_TIMER_IFLG_EXCLUSIVE;
-	}
-	spin_unlock_irqrestore(&t->lock, flags);
+	if (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)
+		tu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;
+	spin_unlock_irq(&t->lock);
 	if (params.queue_size > 0 && (unsigned int)tu->queue_size != params.queue_size) {
 		if (tu->tread) {
 			ttr = (snd_timer_tread_t *)kmalloc(params.queue_size * sizeof(snd_timer_tread_t), GFP_KERNEL);
@@ -1577,6 +1576,24 @@ static int snd_timer_user_params(struct 
 			}
 		}
 	}
+	tu->qhead = tu->qtail = tu->qused = 0;
+	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
+		if (tu->tread) {
+			snd_timer_tread_t tread;
+			tread.event = SNDRV_TIMER_EVENT_EARLY;
+			tread.tstamp.tv_sec = 0;
+			tread.tstamp.tv_nsec = 0;
+			tread.val = 0;
+			snd_timer_user_append_to_tqueue(tu, &tread);
+		} else {
+			snd_timer_read_t *r = &tu->queue[0];
+			r->resolution = 0;
+			r->ticks = 0;
+			tu->qused++;
+			tu->qtail++;
+		}
+		
+	}
 	tu->filter = params.filter;
 	tu->ticks = params.ticks;
 	err = 0;
@@ -1588,7 +1605,6 @@ static int snd_timer_user_params(struct 
 
 static int snd_timer_user_status(struct file *file, snd_timer_status_t *_status)
 {
-	unsigned long flags;
 	snd_timer_user_t *tu;
 	snd_timer_status_t status;
 	
@@ -1599,9 +1615,9 @@ static int snd_timer_user_status(struct 
 	status.resolution = snd_timer_resolution(tu->timeri);
 	status.lost = tu->timeri->lost;
 	status.overrun = tu->overrun;
-	spin_lock_irqsave(&tu->qlock, flags);
+	spin_lock_irq(&tu->qlock);
 	status.queue = tu->qused;
-	spin_unlock_irqrestore(&tu->qlock, flags);
+	spin_unlock_irq(&tu->qlock);
 	if (copy_to_user(_status, &status, sizeof(status)))
 		return -EFAULT;
 	return 0;
@@ -1848,18 +1864,6 @@ static void __exit alsa_timer_exit(void)
 module_init(alsa_timer_init)
 module_exit(alsa_timer_exit)
 
-#ifndef MODULE
-/* format is: snd-timer=timer_limit */
-
-static int __init alsa_timer_setup(char *str)
-{
-	(void)(get_option(&str,&timer_limit) == 2);
-	return 1;
-}
-
-__setup("snd-timer=", alsa_timer_setup);
-#endif /* ifndef MODULE */
-
 EXPORT_SYMBOL(snd_timer_open);
 EXPORT_SYMBOL(snd_timer_close);
 EXPORT_SYMBOL(snd_timer_resolution);
diff -rup linux-2.6.5/sound/drivers/dummy.c linux/sound/drivers/dummy.c
--- linux-2.6.5/sound/drivers/dummy.c	2004-04-04 05:38:14.000000000 +0200
+++ linux/sound/drivers/dummy.c	2004-04-07 17:01:27.000000000 +0200
@@ -24,11 +24,11 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/wait.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -129,23 +129,24 @@ static int enable[SNDRV_CARDS] = {1, [1 
 static int pcm_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
 static int pcm_substreams[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8};
 //static int midi_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for dummy soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for dummy soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable this dummy soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(pcm_devs, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pcm_devs, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_devs, "PCM devices # (0-4) for dummy driver.");
 MODULE_PARM_SYNTAX(pcm_devs, SNDRV_ENABLED ",allows:{{0,4}},default:1,dialog:list");
-MODULE_PARM(pcm_substreams, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pcm_substreams, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-16) for dummy driver.");
 MODULE_PARM_SYNTAX(pcm_substreams, SNDRV_ENABLED ",allows:{{1,16}},default:8,dialog:list");
-//MODULE_PARM(midi_devs, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+//module_param_array(midi_devs, int, boot_devs, 0444);
 //MODULE_PARM_DESC(midi_devs, "MIDI devices # (0-2) for dummy driver.");
 //MODULE_PARM_SYNTAX(midi_devs, SNDRV_ENABLED ",allows:{{0,2}},default:8,dialog:list");
 
@@ -661,27 +662,3 @@ static void __exit alsa_card_dummy_exit(
 
 module_init(alsa_card_dummy_init)
 module_exit(alsa_card_dummy_exit)
-
-#ifndef MODULE
-
-/* format is: snd-dummy=enable,index,id,
-			pcm_devs,pcm_substreams */
-
-static int __init alsa_card_dummy_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pcm_devs[nr_dev]) == 2 &&
-	       get_option(&str,&pcm_substreams[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-dummy=", alsa_card_dummy_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/drivers/mpu401/mpu401.c linux/sound/drivers/mpu401/mpu401.c
--- linux-2.6.5/sound/drivers/mpu401/mpu401.c	2004-04-04 05:37:37.000000000 +0200
+++ linux/sound/drivers/mpu401/mpu401.c	2004-04-07 17:01:32.000000000 +0200
@@ -30,9 +30,9 @@
 #ifdef CONFIG_ACPI_BUS
 #include <acpi/acpi_bus.h>
 #endif
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #ifdef CONFIG_ACPI_BUS
@@ -55,29 +55,30 @@ static int irq[SNDRV_CARDS] = SNDRV_DEFA
 #ifdef CONFIG_X86_PC9800
 static int pc98ii[SNDRV_CARDS];				/* PC98-II dauther board */
 #endif
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for MPU-401 device.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for MPU-401 device.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable MPU-401 device.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 #ifdef USE_ACPI_PNP
-MODULE_PARM(acpipnp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(acpipnp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(acpipnp, "ACPI PnP detection for MPU-401 device.");
 MODULE_PARM_SYNTAX(acpipnp, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
 #endif
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for MPU-401 device.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for MPU-401 device.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
 #ifdef CONFIG_X86_PC9800
-MODULE_PARM(pc98ii, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pc98ii, bool, boot_devs, 0444);
 MODULE_PARM_DESC(pc98ii, "Roland MPU-PC98II support.");
 MODULE_PARM_SYNTAX(pc98ii, SNDRV_BOOLEAN_FALSE_DESC);
 #endif
@@ -303,35 +304,3 @@ static void __exit alsa_card_mpu401_exit
 
 module_init(alsa_card_mpu401_init)
 module_exit(alsa_card_mpu401_exit)
-
-#ifndef MODULE
-
-/* format is: snd-mpu401=enable,index,id,acpipnp[,pc98ii],port,irq */
-
-static int __init alsa_card_mpu401_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-	int __attribute__ ((__unused__)) pnp = INT_MAX;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pnp) == 2 &&
-#ifdef CONFIG_X86_PC9800
-	       get_option(&str,&pc98ii[nr_dev]) == 2 &&
-#endif
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2);
-#ifdef USE_ACPI_PNP
-	if (pnp != INT_MAX)
-		acpipnp[nr_dev] = pnp;
-#endif
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-mpu401=", alsa_card_mpu401_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/drivers/mtpav.c linux/sound/drivers/mtpav.c
--- linux-2.6.5/sound/drivers/mtpav.c	2004-04-04 05:37:43.000000000 +0200
+++ linux/sound/drivers/mtpav.c	2004-04-07 16:39:31.000000000 +0200
@@ -55,8 +55,8 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/rawmidi.h>
 #include <linux/delay.h>
@@ -83,19 +83,19 @@ static long port = MTPAV_IOBASE;	/* 0x37
 static int irq = MTPAV_IRQ;		/* 7, 5 */
 static int hwports = MTPAV_MAX_PORTS;	/* use hardware ports 1-8 */
 
-MODULE_PARM(index, "i");
+module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for MotuMTPAV MIDI.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "s");
+module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for MotuMTPAV MIDI.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(port, "l");
+module_param(port, long, 0444);
 MODULE_PARM_DESC(port, "Parallel port # for MotuMTPAV MIDI.");
 MODULE_PARM_SYNTAX(port, SNDRV_ENABLED ",allows:{{0x378},{0x278}},dialog:list");
-MODULE_PARM(irq, "i");
+module_param(irq, int, 0444);
 MODULE_PARM_DESC(irq, "Parallel IRQ # for MotuMTPAV MIDI.");
 MODULE_PARM_SYNTAX(irq,  SNDRV_ENABLED ",allows:{{7},{5}},dialog:list");
-MODULE_PARM(hwports, "i");
+module_param(hwports, int, 0444);
 MODULE_PARM_DESC(hwports, "Hardware ports # for MotuMTPAV MIDI.");
 MODULE_PARM_SYNTAX(hwports, SNDRV_ENABLED ",allows:{{1,8}},dialog:list");
 
@@ -800,25 +800,3 @@ static void __exit alsa_card_mtpav_exit(
 
 module_init(alsa_card_mtpav_init)
 module_exit(alsa_card_mtpav_exit)
-
-#ifndef MODULE
-
-/* format is: snd-mtpav=enable,index,id,
-			port,irq,hwports */
-
-static int __init alsa_card_mtpav_setup(char *str)
-{
-        int __attribute__ ((__unused__)) enable = 1;
-
-	(void)(get_option(&str,&enable) == 2 &&
-	       get_option(&str,&index) == 2 &&
-	       get_id(&str,&id) == 2 &&
-	       get_option_long(&str,&port) == 2 &&
-	       get_option(&str,&irq) == 2 &&
-	       get_option(&str,&hwports) == 2);
-	return 1;
-}
-
-__setup("snd-mtpav=", alsa_card_mtpav_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/drivers/opl3/opl3_seq.c linux/sound/drivers/opl3/opl3_seq.c
--- linux-2.6.5/sound/drivers/opl3/opl3_seq.c	2004-04-04 05:37:27.000000000 +0200
+++ linux/sound/drivers/opl3/opl3_seq.c	2004-04-07 16:37:59.000000000 +0200
@@ -24,6 +24,7 @@
 
 #include "opl3_voice.h"
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Uros Bizjak <uros@kss-loka.si>");
@@ -32,7 +33,7 @@ MODULE_DESCRIPTION("ALSA driver for OPL3
 MODULE_CLASSES("{sound}");
 
 int use_internal_drums = 0;
-MODULE_PARM(use_internal_drums, "i");
+module_param(use_internal_drums, bool, 0444);
 MODULE_PARM_DESC(use_internal_drums, "Enable internal OPL2/3 drums.");
 
 int snd_opl3_synth_use_inc(opl3_t * opl3)
diff -rup linux-2.6.5/sound/drivers/opl4/opl4_seq.c linux/sound/drivers/opl4/opl4_seq.c
--- linux-2.6.5/sound/drivers/opl4/opl4_seq.c	2004-04-04 05:37:07.000000000 +0200
+++ linux/sound/drivers/opl4/opl4_seq.c	2004-04-07 16:38:25.000000000 +0200
@@ -33,6 +33,7 @@
 
 #include "opl4_local.h"
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
@@ -42,7 +43,7 @@ MODULE_CLASSES("{sound}");
 
 int volume_boost = 8;
 
-MODULE_PARM(volume_boost, "i");
+module_param(volume_boost, int, 0444);
 MODULE_PARM_DESC(volume_boost, "Additional volume for OPL4 wavetable sounds.");
 MODULE_PARM_SYNTAX(volume_boost, "default:8");
 
diff -rup linux-2.6.5/sound/drivers/serial-u16550.c linux/sound/drivers/serial-u16550.c
--- linux-2.6.5/sound/drivers/serial-u16550.c	2004-04-04 05:36:18.000000000 +0200
+++ linux/sound/drivers/serial-u16550.c	2004-04-07 17:01:42.000000000 +0200
@@ -35,9 +35,9 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/rawmidi.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <linux/serial_reg.h>
@@ -77,39 +77,40 @@ static int outs[SNDRV_CARDS] = {[0 ... (
 static int ins[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};	/* 1 to 16 */
 static int adaptor[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = SNDRV_SERIAL_SOUNDCANVAS};
 static int droponfull[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS -1)] = SNDRV_SERIAL_NORMALBUFF };
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Serial MIDI.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Serial MIDI.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable UART16550A chip.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for UART16550A chip.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for UART16550A chip.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(speed, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(speed, int, boot_devs, 0444);
 MODULE_PARM_DESC(speed, "Speed in bauds.");
 MODULE_PARM_SYNTAX(speed, SNDRV_ENABLED ",allows:{9600,19200,38400,57600,115200},dialog:list");
-MODULE_PARM(base, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(base, int, boot_devs, 0444);
 MODULE_PARM_DESC(base, "Base for divisor in bauds.");
 MODULE_PARM_SYNTAX(base, SNDRV_ENABLED ",allows:{57600,115200,230400,460800},dialog:list");
-MODULE_PARM(outs, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(outs, int, boot_devs, 0444);
 MODULE_PARM_DESC(outs, "Number of MIDI outputs.");
-MODULE_PARM(ins, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ins, int, boot_devs, 0444);
 MODULE_PARM_DESC(ins, "Number of MIDI inputs.");
-MODULE_PARM(droponfull, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(droponfull, bool, boot_devs, 0444);
 MODULE_PARM_DESC(droponfull, "Flag to enable drop-on-full buffer mode");
 MODULE_PARM_SYNTAX(droponfull, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 
 MODULE_PARM_SYNTAX(outs, SNDRV_ENABLED ",allows:{{1,16}},dialog:list");
 MODULE_PARM_SYNTAX(ins, SNDRV_ENABLED ",allows:{{1,16}},dialog:list");
-MODULE_PARM(adaptor, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(adaptor, int, boot_devs, 0444);
 MODULE_PARM_DESC(adaptor, "Type of adaptor.");
 MODULE_PARM_SYNTAX(adaptor, SNDRV_ENABLED ",allows:{{0=Soundcanvas,1=MS-124T,2=MS-124W S/A,3=MS-124W M/B,4=Generic}},dialog:list");
 
@@ -987,34 +988,3 @@ static void __exit alsa_card_serial_exit
 
 module_init(alsa_card_serial_init)
 module_exit(alsa_card_serial_exit)
-
-#ifndef MODULE
-
-/* format is: snd-serial=enable,index,id,
-			 port,irq,speed,base,outs,
- 			 ins,adaptor,droponfull */
-
-static int __init alsa_card_serial_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&speed[nr_dev]) == 2 &&
-	       get_option(&str,&base[nr_dev]) == 2 &&
-	       get_option(&str,&outs[nr_dev]) == 2 &&
-	       get_option(&str,&ins[nr_dev]) == 2 &&
-	       get_option(&str,&adaptor[nr_dev]) == 2 &&
-	       get_option(&str,&droponfull[nr_dev]) == 2 );
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-serial=", alsa_card_serial_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/drivers/virmidi.c linux/sound/drivers/virmidi.c
--- linux-2.6.5/sound/drivers/virmidi.c	2004-04-04 05:36:47.000000000 +0200
+++ linux/sound/drivers/virmidi.c	2004-04-07 17:01:17.000000000 +0200
@@ -45,10 +45,10 @@
 #include <linux/init.h>
 #include <linux/wait.h>
 #include <linux/sched.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/seq_kernel.h>
 #include <sound/seq_virmidi.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 /* hack: OSS defines midi_devs, so undefine it (versioned symbols) */
@@ -66,17 +66,18 @@ static int index[SNDRV_CARDS] = SNDRV_DE
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};
 static int midi_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 4};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for virmidi soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for virmidi soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable this soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(midi_devs, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(midi_devs, int, boot_devs, 0444);
 MODULE_PARM_DESC(midi_devs, "MIDI devices # (1-8)");
 MODULE_PARM_SYNTAX(midi_devs, SNDRV_ENABLED ",allows:{{1,8}}");
 
@@ -162,25 +163,3 @@ static void __exit alsa_card_virmidi_exi
 
 module_init(alsa_card_virmidi_init)
 module_exit(alsa_card_virmidi_exit)
-
-#ifndef MODULE
-
-/* format is: snd-virmidi=enable,index,id,midi_devs */
-
-static int __init alsa_card_virmidi_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&midi_devs[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-virmidi=", alsa_card_virmidi_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/ad1816a/ad1816a.c linux/sound/isa/ad1816a/ad1816a.c
--- linux-2.6.5/sound/isa/ad1816a/ad1816a.c	2004-04-04 05:36:45.000000000 +0200
+++ linux/sound/isa/ad1816a/ad1816a.c	2004-04-07 16:46:05.000000000 +0200
@@ -23,8 +23,8 @@
 #include <linux/time.h>
 #include <linux/wait.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/ad1816a.h>
 #include <sound/mpu401.h>
@@ -56,35 +56,36 @@ static int irq[SNDRV_CARDS] = SNDRV_DEFA
 static int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* Pnp setup */
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* PnP setup */
 static int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* PnP setup */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for ad1816a based soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for ad1816a based soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable ad1816a based soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for ad1816a driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for ad1816a driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT12_DESC);
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for ad1816a driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for ad1816a driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for ad1816a driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "1st DMA # for ad1816a driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "2nd DMA # for ad1816a driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_DMA_DESC);
 
@@ -323,33 +324,3 @@ static void __exit alsa_card_ad1816a_exi
 
 module_init(alsa_card_ad1816a_init)
 module_exit(alsa_card_ad1816a_exit)
-
-#ifndef MODULE
-
-/* format is: snd-ad1816a=enable,index,id,port,
-			  mpu_port,fm_port,irq,mpu_irq,
-			  dma1,dma2 */
-
-static int __init alsa_card_ad1816a_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&mpu_irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-ad1816a=", alsa_card_ad1816a_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/ad1848/ad1848.c linux/sound/isa/ad1848/ad1848.c
--- linux-2.6.5/sound/isa/ad1848/ad1848.c	2004-04-04 05:37:23.000000000 +0200
+++ linux/sound/isa/ad1848/ad1848.c	2004-04-07 16:45:30.000000000 +0200
@@ -25,9 +25,9 @@
 #include <linux/init.h>
 #include <linux/time.h>
 #include <linux/wait.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/ad1848.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #define chip_t ad1848_t
@@ -47,26 +47,27 @@ static long port[SNDRV_CARDS] = SNDRV_DE
 static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 5,7,9,11,12,15 */
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3,5,6,7 */
 static int thinkpad[SNDRV_CARDS];			/* Thinkpad special case */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for AD1848 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for AD1848 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable AD1848 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for AD1848 driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for AD1848 driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for AD1848 driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(thinkpad, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(thinkpad, bool, boot_devs, 0444);
 MODULE_PARM_DESC(thinkpad, "Enable only for the onboard CS4248 of IBM Thinkpad 360/750/755 series.");
 MODULE_PARM_SYNTAX(thinkpad,  SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 
@@ -159,29 +160,3 @@ static void __exit alsa_card_ad1848_exit
 
 module_init(alsa_card_ad1848_init)
 module_exit(alsa_card_ad1848_exit)
-
-#ifndef MODULE
-
-/* format is: snd-ad1848=enable,index,id,port,
-			 irq,dma1 */
-
-static int __init alsa_card_ad1848_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&thinkpad[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-ad1848=", alsa_card_ad1848_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/ad1848/ad1848_lib.c linux/sound/isa/ad1848/ad1848_lib.c
--- linux-2.6.5/sound/isa/ad1848/ad1848_lib.c	2004-04-04 05:38:20.000000000 +0200
+++ linux/sound/isa/ad1848/ad1848_lib.c	2004-04-08 13:00:15.000000000 +0200
@@ -647,12 +647,12 @@ static void snd_ad1848_thinkpad_twiddle(
 }
 
 #ifdef CONFIG_PM
-static void snd_ad1848_suspend(ad1848_t *chip) {
-
-	snd_card_t *card = chip->card;
+static int snd_ad1848_suspend(snd_card_t *card, unsigned int state)
+{
+	ad1848_t *chip = snd_magic_cast(ad1848_t, card->pm_private_data, return -EINVAL);
 
 	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
+		return 0;
 
 	snd_pcm_suspend_all(chip->pcm);
 	/* FIXME: save registers? */
@@ -661,14 +661,15 @@ static void snd_ad1848_suspend(ad1848_t 
 		snd_ad1848_thinkpad_twiddle(chip, 0);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void snd_ad1848_resume(ad1848_t *chip) {
-
-	snd_card_t *card = chip->card;
+static int snd_ad1848_resume(snd_card_t *card, unsigned int state)
+{
+	ad1848_t *chip = snd_magic_cast(ad1848_t, card->pm_private_data, return -EINVAL);
 
 	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
+		return 0;
 
 	if (chip->thinkpad_flag)
 		snd_ad1848_thinkpad_twiddle(chip, 1);
@@ -676,43 +677,8 @@ static void snd_ad1848_resume(ad1848_t *
 	/* FIXME: restore registers? */
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-/* callback for control API */
-static int snd_ad1848_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	ad1848_t *chip = (ad1848_t *) card->power_state_private_data;
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		snd_ad1848_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		snd_ad1848_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int snd_ad1848_pm_callback(struct pm_dev *dev, pm_request_t rqst, void *data)
-{
-	ad1848_t *chip = snd_magic_cast(ad1848_t, dev->data, return 0);
-
-	switch (rqst) {
-	case PM_SUSPEND:
-		snd_ad1848_suspend(chip);
-		break;
-	case PM_RESUME:
-		snd_ad1848_resume(chip);
-		break;
-	}
 	return 0;
 }
-
 #endif /* CONFIG_PM */
 
 static int snd_ad1848_probe(ad1848_t * chip)
@@ -891,10 +857,6 @@ static int snd_ad1848_capture_close(snd_
 
 static int snd_ad1848_free(ad1848_t *chip)
 {
-#ifdef CONFIG_PM
-        if (chip->thinkpad_pmstate)
-                pm_unregister(chip->thinkpad_pmstate);
-#endif
 	if (chip->res_port) {
 		release_resource(chip->res_port);
 		kfree_nocheck(chip->res_port);
@@ -973,14 +935,7 @@ int snd_ad1848_create(snd_card_t * card,
 		chip->thinkpad_flag = 1;
 		chip->hardware = AD1848_HW_DETECT; /* reset */
 		snd_ad1848_thinkpad_twiddle(chip, 1);
-#ifdef CONFIG_PM
-		chip->thinkpad_pmstate = pm_register(PM_ISA_DEV, 0, snd_ad1848_pm_callback);
-		if (chip->thinkpad_pmstate) {
-			chip->thinkpad_pmstate->data = chip;
-			card->set_power_state = snd_ad1848_set_power_state; /* callback */
-			card->power_state_private_data = chip;
-		}
-#endif
+		snd_card_set_isa_pm_callback(card, snd_ad1848_suspend, snd_ad1848_resume, chip);
 	}
 
 	if (snd_ad1848_probe(chip) < 0) {
diff -rup linux-2.6.5/sound/isa/als100.c linux/sound/isa/als100.c
--- linux-2.6.5/sound/isa/als100.c	2004-04-04 05:36:18.000000000 +0200
+++ linux/sound/isa/als100.c	2004-04-07 16:46:41.000000000 +0200
@@ -25,8 +25,8 @@
 #include <linux/wait.h>
 #include <linux/time.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
@@ -59,35 +59,36 @@ static int irq[SNDRV_CARDS] = SNDRV_DEFA
 static int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* PnP setup */
 static int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* PnP setup */
 static int dma16[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* PnP setup */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for als100 based soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for als100 based soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable als100 based soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for als100 driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for als100 driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT12_DESC);
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for als100 driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for als100 driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for als100 driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma8, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma8, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma8, "8-bit DMA # for als100 driver.");
 MODULE_PARM_SYNTAX(dma8, SNDRV_DMA8_DESC);
-MODULE_PARM(dma16, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma16, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma16, "16-bit DMA # for als100 driver.");
 MODULE_PARM_SYNTAX(dma16, SNDRV_DMA16_DESC);
 
@@ -345,33 +346,3 @@ static void __exit alsa_card_als100_exit
 
 module_init(alsa_card_als100_init)
 module_exit(alsa_card_als100_exit)
-
-#ifndef MODULE
-
-/* format is: snd-als100=enable,index,id,port,
-			 mpu_port,fm_port,irq,mpu_irq,
-			 dma8,dma16 */
-
-static int __init alsa_card_als100_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&mpu_irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma8[nr_dev]) == 2 &&
-	       get_option(&str,&dma16[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-als100=", alsa_card_als100_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/azt2320.c linux/sound/isa/azt2320.c
--- linux-2.6.5/sound/isa/azt2320.c	2004-04-04 05:38:18.000000000 +0200
+++ linux/sound/isa/azt2320.c	2004-04-07 16:46:48.000000000 +0200
@@ -36,8 +36,8 @@
 #include <linux/time.h>
 #include <linux/wait.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/cs4231.h>
 #include <sound/mpu401.h>
@@ -68,38 +68,39 @@ static int irq[SNDRV_CARDS] = SNDRV_DEFA
 static int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* Pnp setup */
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* PnP setup */
 static int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* PnP setup */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for azt2320 based soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for azt2320 based soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable azt2320 based soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for azt2320 driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(wss_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(wss_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(wss_port, "WSS Port # for azt2320 driver.");
 MODULE_PARM_SYNTAX(wss_port, SNDRV_PORT12_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for azt2320 driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT12_DESC);
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for azt2320 driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for azt2320 driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for azt2320 driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "1st DMA # for azt2320 driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "2nd DMA # for azt2320 driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_DMA_DESC);
 
@@ -378,33 +379,3 @@ static void __exit alsa_card_azt2320_exi
 
 module_init(alsa_card_azt2320_init)
 module_exit(alsa_card_azt2320_exit)
-
-#ifndef MODULE
-
-/* format is: snd-azt2320=enable,index,id,port,
-			  wss_port,mpu_port,fm_port,
-			  irq,mpu_irq,dma1,dma2 */
-
-static int __init alsa_card_azt2320_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&wss_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&mpu_irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-azt2320=", alsa_card_azt2320_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/cmi8330.c linux/sound/isa/cmi8330.c
--- linux-2.6.5/sound/isa/cmi8330.c	2004-04-04 05:36:24.000000000 +0200
+++ linux/sound/isa/cmi8330.c	2004-04-07 16:46:15.000000000 +0200
@@ -47,10 +47,10 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/ad1848.h>
 #include <sound/sb.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 /*
@@ -79,42 +79,43 @@ static int sbdma16[SNDRV_CARDS] = SNDRV_
 static long wssport[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;
 static int wssirq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;
 static int wssdma[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for CMI8330 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string  for CMI8330 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable CMI8330 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 #ifdef CONFIG_PNP
-MODULE_PARM(isapnp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(isapnp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(isapnp, "PnP detection for specified soundcard.");
 MODULE_PARM_SYNTAX(isapnp, SNDRV_ISAPNP_DESC);
 #endif
 
-MODULE_PARM(sbport, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(sbport, long, boot_devs, 0444);
 MODULE_PARM_DESC(sbport, "Port # for CMI8330 SB driver.");
 MODULE_PARM_SYNTAX(sbport, SNDRV_ENABLED ",allows:{{0x220,0x280,0x20}},prefers:{0x220},base:16,dialog:list");
-MODULE_PARM(sbirq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(sbirq, int, boot_devs, 0444);
 MODULE_PARM_DESC(sbirq, "IRQ # for CMI8330 SB driver.");
 MODULE_PARM_SYNTAX(sbirq, SNDRV_ENABLED ",allows:{{5},{7},{9},{10},{11},{12}},prefers:{5},dialog:list");
-MODULE_PARM(sbdma8, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(sbdma8, int, boot_devs, 0444);
 MODULE_PARM_DESC(sbdma8, "DMA8 for CMI8330 SB driver.");
 MODULE_PARM_SYNTAX(sbdma8, SNDRV_DMA8_DESC ",prefers:{1}");
-MODULE_PARM(sbdma16, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(sbdma16, int, boot_devs, 0444);
 MODULE_PARM_DESC(sbdma16, "DMA16 for CMI8330 SB driver.");
 MODULE_PARM_SYNTAX(sbdma16, SNDRV_ENABLED ",allows:{{5},{7}},prefers:{5},dialog:list");
 
-MODULE_PARM(wssport, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(wssport, long, boot_devs, 0444);
 MODULE_PARM_DESC(wssport, "Port # for CMI8330 WSS driver.");
 MODULE_PARM_SYNTAX(wssport, SNDRV_ENABLED ",allows:{{0x530},{0xe80,0xf40,0xc0}},prefers:{0x530},base:16,dialog:list");
-MODULE_PARM(wssirq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(wssirq, int, boot_devs, 0444);
 MODULE_PARM_DESC(wssirq, "IRQ # for CMI8330 WSS driver.");
 MODULE_PARM_SYNTAX(wssirq, SNDRV_ENABLED ",allows:{{5},{7},{9},{10},{11},{12}},prefers:{11},dialog:list");
-MODULE_PARM(wssdma, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(wssdma, int, boot_devs, 0444);
 MODULE_PARM_DESC(wssdma, "DMA for CMI8330 WSS driver.");
 MODULE_PARM_SYNTAX(wssdma, SNDRV_DMA8_DESC ",prefers:{0}");
 
@@ -643,41 +644,3 @@ static void __exit alsa_card_cmi8330_exi
 
 module_init(alsa_card_cmi8330_init)
 module_exit(alsa_card_cmi8330_exit)
-
-#ifndef MODULE
-
-/* format is: snd-cmi8330=enable,index,id,isapnp,
-			  sbport,sbirq,
-			  sbdma8,sbdma16,
-			  wssport,wssirq,
-			  wssdma */
-
-static int __init alsa_card_cmi8330_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-	int __attribute__ ((__unused__)) pnp = INT_MAX;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pnp) == 2 &&
-	       get_option_long(&str,&sbport[nr_dev]) == 2 &&
-	       get_option(&str,&sbirq[nr_dev]) == 2 &&
-	       get_option(&str,&sbdma8[nr_dev]) == 2 &&
-	       get_option(&str,&sbdma16[nr_dev]) == 2 &&
-	       get_option_long(&str,&wssport[nr_dev]) == 2 &&
-	       get_option(&str,&wssirq[nr_dev]) == 2 &&
-	       get_option(&str,&wssdma[nr_dev]) == 2);
-#ifdef CONFIG_PNP
-	if (pnp != INT_MAX)
-		isapnp[nr_dev] = pnp;
-#endif
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-cmi8330=", alsa_card_cmi8330_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/cs423x/cs4231.c linux/sound/isa/cs423x/cs4231.c
--- linux-2.6.5/sound/isa/cs423x/cs4231.c	2004-04-04 05:36:14.000000000 +0200
+++ linux/sound/isa/cs423x/cs4231.c	2004-04-07 16:45:37.000000000 +0200
@@ -24,10 +24,10 @@
 #include <linux/init.h>
 #include <linux/time.h>
 #include <linux/wait.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/cs4231.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #define chip_t cs4231_t
@@ -47,32 +47,33 @@ static int irq[SNDRV_CARDS] = SNDRV_DEFA
 static int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 9,11,12,15 */
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3,5,6,7 */
 static int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3,5,6,7 */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for CS4231 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for CS4231 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable CS4231 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for CS4231 driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for CS4231 driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for CS4231 driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for CS4231 driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for CS4231 driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for CS4231 driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_DMA_DESC);
 
@@ -179,34 +180,3 @@ static void __exit alsa_card_cs4231_exit
 
 module_init(alsa_card_cs4231_init)
 module_exit(alsa_card_cs4231_exit)
-
-#ifndef MODULE
-
-/* format is: snd-cs4231=enable,index,id,
-			 port,mpu_port,irq,mpu_irq,
-			 dma1,dma2 */
-
-static int __init alsa_card_cs4231_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-	int __attribute__ ((__unused__)) pnp = INT_MAX;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pnp) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&mpu_irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-cs4231=", alsa_card_cs4231_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/cs423x/cs4231_lib.c linux/sound/isa/cs423x/cs4231_lib.c
--- linux-2.6.5/sound/isa/cs423x/cs4231_lib.c	2004-04-04 05:36:26.000000000 +0200
+++ linux/sound/isa/cs423x/cs4231_lib.c	2004-04-13 12:48:15.000000000 +0200
@@ -1343,6 +1343,7 @@ static int snd_cs4231_capture_close(snd_
 
 #ifdef CONFIG_PM
 
+/* lowlevel suspend callback for CS4231 */
 static void snd_cs4231_suspend(cs4231_t *chip)
 {
 	int reg;
@@ -1354,6 +1355,7 @@ static void snd_cs4231_suspend(cs4231_t 
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
+/* lowlevel resume callback for CS4231 */
 static void snd_cs4231_resume(cs4231_t *chip)
 {
 	int reg;
@@ -1395,25 +1397,25 @@ static void snd_cs4231_resume(cs4231_t *
 #endif
 }
 
-static int snd_cs4231_pm_callback(struct pm_dev *dev, pm_request_t rqst, void *data)
+static int snd_cs4231_pm_suspend(snd_card_t *card, unsigned int state)
 {
-	cs4231_t *chip = snd_magic_cast(cs4231_t, dev->data, return 0);
-
-	switch (rqst) {
-	case PM_SUSPEND:
-		if (chip->suspend) {
-			snd_pcm_suspend_all(chip->pcm);
-			(*chip->suspend)(chip);
-		}
-		break;
-	case PM_RESUME:
-		if (chip->resume)
-			(*chip->resume)(chip);
-		break;
+	cs4231_t *chip = snd_magic_cast(cs4231_t, card->pm_private_data, return -EINVAL);
+	if (chip->suspend) {
+		chip->suspend(chip);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	}
 	return 0;
 }
 
+static int snd_cs4231_pm_resume(snd_card_t *card, unsigned int state)
+{
+	cs4231_t *chip = snd_magic_cast(cs4231_t, card->pm_private_data, return -EINVAL);
+	if (chip->resume) {
+		chip->resume(chip);
+		snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	}
+	return 0;
+}
 #endif /* CONFIG_PM */
 
 #ifdef LEGACY_SUPPORT
@@ -1441,10 +1443,6 @@ static int snd_cs4231_free(cs4231_t *chi
 		snd_dma_disable(chip->dma2);
 		free_dma(chip->dma2);
 	}
-#ifdef CONFIG_PM
-	if (chip->pm_dev)
-		pm_unregister(chip->pm_dev);
-#endif
 	if (chip->timer)
 		snd_device_free(chip->card, chip->timer);
 	snd_magic_kfree(chip);
@@ -1587,9 +1585,7 @@ int snd_cs4231_create(snd_card_t * card,
 	/* Power Management */
 	chip->suspend = snd_cs4231_suspend;
 	chip->resume = snd_cs4231_resume;
-	chip->pm_dev = pm_register(PM_ISA_DEV, 0, snd_cs4231_pm_callback);
-	if (chip->pm_dev)
-		chip->pm_dev->data = chip;
+	snd_card_set_isa_pm_callback(card, snd_cs4231_pm_suspend, snd_cs4231_pm_resume, chip);
 #endif
 
 	*rchip = chip;
@@ -1659,7 +1655,7 @@ int snd_cs4231_pcm(cs4231_t *chip, int d
 #else
 #  ifdef EBUS_SUPPORT
         if (chip->ebus_flag) {
-                snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_PCI,
+                snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
                 				      chip->dev_u.pdev,
 						      64*1024, 128*1024);
         } else {
diff -rup linux-2.6.5/sound/isa/cs423x/cs4236.c linux/sound/isa/cs423x/cs4236.c
--- linux-2.6.5/sound/isa/cs423x/cs4236.c	2004-04-04 05:36:19.000000000 +0200
+++ linux/sound/isa/cs423x/cs4236.c	2004-04-07 16:45:43.000000000 +0200
@@ -23,11 +23,11 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/cs4231.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #define chip_t cs4231_t
@@ -95,46 +95,47 @@ static int irq[SNDRV_CARDS] = SNDRV_DEFA
 static int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 9,11,12,15 */
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3,5,6,7 */
 static int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3,5,6,7 */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for " IDENT " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for " IDENT " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable " IDENT " soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 #ifdef CONFIG_PNP
-MODULE_PARM(isapnp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(isapnp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(isapnp, "ISA PnP detection for specified soundcard.");
 MODULE_PARM_SYNTAX(isapnp, SNDRV_ISAPNP_DESC);
 #endif
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(cport, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(cport, long, boot_devs, 0444);
 MODULE_PARM_DESC(cport, "Control port # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(cport, SNDRV_PORT12_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT12_DESC);
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_PORT12_DESC);
-MODULE_PARM(sb_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(sb_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(sb_port, "SB port # for " IDENT " driver (optional).");
 MODULE_PARM_SYNTAX(sb_port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_DMA_DESC);
 
@@ -618,48 +619,3 @@ static void __exit alsa_card_cs423x_exit
 
 module_init(alsa_card_cs423x_init)
 module_exit(alsa_card_cs423x_exit)
-
-#ifndef MODULE
-
-/* format is: snd-cs4232=enable,index,id,isapnp,port,
-			 cport,mpu_port,fm_port,sb_port,
-			 irq,mpu_irq,dma1,dma2 */
-/* format is: snd-cs4236=enable,index,id,isapnp,port,
-			 cport,mpu_port,fm_port,sb_port,
-			 irq,mpu_irq,dma1,dma2 */
-
-static int __init alsa_card_cs423x_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-	int __attribute__ ((__unused__)) pnp = INT_MAX;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pnp) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&cport[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&sb_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&mpu_irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2);
-#ifdef CONFIG_PNP
-	if (pnp != INT_MAX)
-		isapnp[nr_dev] = pnp;
-#endif
-	nr_dev++;
-	return 1;
-}
-
-#ifdef CS4232
-__setup("snd-cs4232=", alsa_card_cs423x_setup);
-#else /* CS4236 */
-__setup("snd-cs4236=", alsa_card_cs423x_setup);
-#endif
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/cs423x/pc98.c linux/sound/isa/cs423x/pc98.c
--- linux-2.6.5/sound/isa/cs423x/pc98.c	2004-04-04 05:36:56.000000000 +0200
+++ linux/sound/isa/cs423x/pc98.c	2004-04-07 16:45:48.000000000 +0200
@@ -25,11 +25,11 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/cs4231.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include "sound_pc9800.h"
 
@@ -57,43 +57,44 @@ static int mpu_irq[SNDRV_CARDS] = SNDRV_
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3,5,6,7 */
 static int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3,5,6,7 */
 static int pc98ii[SNDRV_CARDS];				/* PC98II */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for " IDENT " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for " IDENT " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable " IDENT " soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
 #if 0 /* NOT USED */
-MODULE_PARM(cport, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(cport, long, boot_devs, 0444);
 MODULE_PARM_DESC(cport, "Control port # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(cport, SNDRV_PORT12_DESC);
 #endif
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT12_DESC);
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for " IDENT " driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_DMA_DESC);
-MODULE_PARM(pc98ii, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pc98ii, bool, boot_devs, 0444);
 MODULE_PARM_DESC(pc98ii, "Roland MPU-PC98II support.");
 MODULE_PARM_SYNTAX(pc98ii, SNDRV_BOOLEAN_FALSE_DESC);
 
@@ -435,34 +436,3 @@ static void __exit alsa_card_pc98_exit(v
 
 module_init(alsa_card_pc98_init)
 module_exit(alsa_card_pc98_exit)
-
-#ifndef MODULE
-
-/* format is: snd-pc98-cs4232=enable,index,id,port,
-			 mpu_port,fm_port,
-			 irq,mpu_irq,dma1,dma2,pc98ii */
-
-static int __init alsa_card_pc98_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&mpu_irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2 &&
-	       get_option(&str,&pc98ii[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-pc98-cs4232=", alsa_card_pc98_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/dt019x.c linux/sound/isa/dt019x.c
--- linux-2.6.5/sound/isa/dt019x.c	2004-04-04 05:36:57.000000000 +0200
+++ linux/sound/isa/dt019x.c	2004-04-07 16:47:00.000000000 +0200
@@ -26,8 +26,8 @@
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
@@ -53,32 +53,33 @@ static long fm_port[SNDRV_CARDS] = SNDRV
 static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* PnP setup */
 static int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* PnP setup */
 static int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* PnP setup */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for DT-019X based soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for DT-019X based soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable DT-019X based soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for dt019x driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for dt019x driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT12_DESC);
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for dt019x driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for dt019x driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for dt019x driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma8, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma8, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma8, "8-bit DMA # for dt019x driver.");
 MODULE_PARM_SYNTAX(dma8, SNDRV_DMA8_DESC);
 
@@ -337,32 +338,3 @@ static void __exit alsa_card_dt019x_exit
 
 module_init(alsa_card_dt019x_init)
 module_exit(alsa_card_dt019x_exit)
-
-#ifndef MODULE
-
-/* format is: snd-dt019x=enable,index,id,
-			  port,mpu_port,fm_port,
-			  irq,mpu_irq,dma8,dma8_size */
-
-static int __init alsa_card_dt019x_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&mpu_irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma8[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-dt019x=", alsa_card_dt019x_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/es1688/es1688.c linux/sound/isa/es1688/es1688.c
--- linux-2.6.5/sound/isa/es1688/es1688.c	2004-04-04 05:36:55.000000000 +0200
+++ linux/sound/isa/es1688/es1688.c	2004-04-07 16:45:59.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/time.h>
 #include <linux/wait.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/es1688.h>
 #include <sound/mpu401.h>
@@ -31,7 +32,6 @@
 #define SNDRV_LEGACY_AUTO_PROBE
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #define chip_t es1688_t
@@ -53,29 +53,30 @@ static long mpu_port[SNDRV_CARDS] = {[0 
 static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 5,7,9,10 */
 static int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 5,7,9,10 */
 static int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3 */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for ESx688 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for ESx688 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable ESx688 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for ESx688 driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for ESx688 driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for ESx688 driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for ESx688 driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma8, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma8, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma8, "8-bit DMA # for ESx688 driver.");
 MODULE_PARM_SYNTAX(dma8, SNDRV_DMA8_DESC);
 
@@ -213,32 +214,3 @@ static void __exit alsa_card_es1688_exit
 
 module_init(alsa_card_es1688_init)
 module_exit(alsa_card_es1688_exit)
-
-#ifndef MODULE
-
-/* format is: snd-es1688=enable,index,id,
-			 port,mpu_port,
-			 irq,mpu_irq,
-			 dma8 */
-
-static int __init alsa_card_es1688_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&mpu_irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma8[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-es1688=", alsa_card_es1688_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/es18xx.c linux/sound/isa/es18xx.c
--- linux-2.6.5/sound/isa/es18xx.c	2004-04-04 05:36:57.000000000 +0200
+++ linux/sound/isa/es18xx.c	2004-04-08 13:22:18.000000000 +0200
@@ -72,6 +72,7 @@
 #include <linux/slab.h>
 #include <linux/pnp.h>
 #include <linux/isapnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
@@ -81,7 +82,6 @@
 #define SNDRV_LEGACY_AUTO_PROBE
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #define PFX "es18xx: "
@@ -124,7 +124,6 @@ struct _snd_es18xx {
 	spinlock_t mixer_lock;
 	spinlock_t ctrl_lock;
 #ifdef CONFIG_PM
-	struct pm_dev *pm_dev;
 	unsigned char pm_reg;
 #endif
 };
@@ -1610,12 +1609,9 @@ int __devinit snd_es18xx_pcm(es18xx_t *c
 
 /* Power Management support functions */
 #ifdef CONFIG_PM
-static void snd_es18xx_suspend(es18xx_t *chip)
+static int snd_es18xx_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
-
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
+	es18xx_t *chip = snd_magic_cast(es18xx_t, card->pm_private_data, return -EINVAL);
 
 	snd_pcm_suspend_all(chip->pcm);
 
@@ -1626,63 +1622,23 @@ static void snd_es18xx_suspend(es18xx_t 
 	snd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_SUS);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void snd_es18xx_resume(es18xx_t *chip)
+static int snd_es18xx_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
-
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
+	es18xx_t *chip = snd_magic_cast(es18xx_t, card->pm_private_data, return -EINVAL);
 
 	/* restore PM register, we won't wake till (not 0x07) i/o activity though */
 	snd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_FM);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-/* callback for control API */
-static int snd_es18xx_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	es18xx_t *chip = (es18xx_t *) card->power_state_private_data;
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		snd_es18xx_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		snd_es18xx_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int snd_es18xx_pm_callback(struct pm_dev *dev, pm_request_t rqst, void *data)
-{
-	es18xx_t *chip = snd_magic_cast(es18xx_t, dev->data, return 0);
-
-	switch (rqst) {
-	case PM_SUSPEND:
-		snd_es18xx_suspend(chip);
-		break;
-	case PM_RESUME:
-		snd_es18xx_resume(chip);
-		break;
-	}
 	return 0;
 }
 #endif /* CONFIG_PM */
 
 static int snd_es18xx_free(es18xx_t *chip)
 {
-#ifdef CONFIG_PM
-	if (chip->pm_dev)
-		pm_unregister(chip->pm_dev);
-#endif
 	if (chip->res_port) {
 		release_resource(chip->res_port);
 		kfree_nocheck(chip->res_port);
@@ -1900,37 +1856,38 @@ static long fm_port[SNDRV_CARDS] = SNDRV
 static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 5,7,9,10 */
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3 */
 static int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3 */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for ES18xx soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for ES18xx soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable ES18xx soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 #ifdef CONFIG_PNP
-MODULE_PARM(isapnp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(isapnp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(isapnp, "PnP detection for specified soundcard.");
 MODULE_PARM_SYNTAX(isapnp, SNDRV_ISAPNP_DESC);
 #endif
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for ES18xx driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_ENABLED ",allows:{{0x220,0x280,0x20}},prefers:{0x220},base:16,dialog:list");
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for ES18xx driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_ENABLED ",allows:{{0x300,0x330,0x30},{0x800,0xffe,0x2}},prefers:{0x330,0x300},base:16,dialog:combo");
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for ES18xx driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_ENABLED ",allows:{{0x388},{0x800,0xffc,0x4}},prefers:{0x388},base:16,dialog:combo");
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for ES18xx driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC ",prefers:{5}");
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA 1 # for ES18xx driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA8_DESC ",prefers:{1}");
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "DMA 2 # for ES18xx driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_ENABLED ",allows:{{0},{1},{3},{5}},dialog:list,prefers:{0}");
 
@@ -2149,16 +2106,9 @@ static int __devinit snd_audiodrive_prob
 		chip->rmidi = rmidi;
 	}
 
-#ifdef CONFIG_PM
 	/* Power Management */
-	chip->pm_dev = pm_register(PM_ISA_DEV, 0, snd_es18xx_pm_callback);
-	if (chip->pm_dev) {
-		chip->pm_dev->data = chip;
-		/* set control api callback */
-		card->set_power_state = snd_es18xx_set_power_state;
-		card->power_state_private_data = chip;
-	}
-#endif
+	snd_card_set_isa_pm_callback(card, snd_es18xx_suspend, snd_es18xx_resume, chip);
+
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);
 		return err;
@@ -2283,39 +2233,3 @@ static void __exit alsa_card_es18xx_exit
 
 module_init(alsa_card_es18xx_init)
 module_exit(alsa_card_es18xx_exit)
-
-
-#ifndef MODULE
-
-/* format is: snd-es18xx=enable,index,id,isapnp,
-			 port,mpu_port,fm_port,irq,
-			 dma1,dma2 */
-
-static int __init alsa_card_es18xx_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-	int __attribute__ ((__unused__)) pnp = INT_MAX;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pnp) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2);
-#ifdef CONFIG_PNP
-	if (pnp != INT_MAX)
-		isapnp[nr_dev] = pnp;
-#endif
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-es18xx=", alsa_card_es18xx_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/gus/gusclassic.c linux/sound/isa/gus/gusclassic.c
--- linux-2.6.5/sound/isa/gus/gusclassic.c	2004-04-04 05:38:26.000000000 +0200
+++ linux/sound/isa/gus/gusclassic.c	2004-04-07 16:45:03.000000000 +0200
@@ -24,12 +24,12 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/time.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/gus.h>
 #define SNDRV_LEGACY_AUTO_PROBE
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -49,35 +49,36 @@ static int joystick_dac[SNDRV_CARDS] = {
 				/* 0 to 31, (0.59V-4.52V or 0.389V-2.98V) */
 static int channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 24};
 static int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for GUS Classic soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for GUS Classic soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable GUS Classic soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for GUS Classic driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_ENABLED ",allows:{{0x220,0x260,0x10}},dialog:list");
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for GUS Classic driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_ENABLED ",allows:{{3},{5},{9},{11},{12},{15}},dialog:list");
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for GUS Classic driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_ENABLED ",allows:{{1},{3},{5},{6},{7}},dialog:list");
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for GUS Classic driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_ENABLED ",allows:{{1},{3},{5},{6},{7}},dialog:list");
-MODULE_PARM(joystick_dac, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick_dac, int, boot_devs, 0444);
 MODULE_PARM_DESC(joystick_dac, "Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for GUS Classic driver.");
 MODULE_PARM_SYNTAX(joystick_dac, SNDRV_ENABLED ",allows:{{0,31}}");
-MODULE_PARM(channels, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(channels, int, boot_devs, 0444);
 MODULE_PARM_DESC(channels, "GF1 channels for GUS Classic driver.");
 MODULE_PARM_SYNTAX(channels,  SNDRV_ENABLED ",allows:{{14,32}}");
-MODULE_PARM(pcm_channels, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pcm_channels, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS Classic driver.");
 MODULE_PARM_SYNTAX(pcm_channels, SNDRV_ENABLED ",allows:{{2,16}}");
 
@@ -269,35 +270,3 @@ static void __exit alsa_card_gusclassic_
 
 module_init(alsa_card_gusclassic_init)
 module_exit(alsa_card_gusclassic_exit)
-
-#ifndef MODULE
-
-/* format is: snd-gusclassic=enable,index,id,
-			     port,irq,
-			     dma1,dma2,
-			     joystick_dac,
-			     channels,pcm_channels */
-
-static int __init alsa_card_gusclassic_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2 &&
-	       get_option(&str,&joystick_dac[nr_dev]) == 2 &&
-	       get_option(&str,&channels[nr_dev]) == 2 &&
-	       get_option(&str,&pcm_channels[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-gusclassic=", alsa_card_gusclassic_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/gus/gusextreme.c linux/sound/isa/gus/gusextreme.c
--- linux-2.6.5/sound/isa/gus/gusextreme.c	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/isa/gus/gusextreme.c	2004-04-07 16:45:09.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/time.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/gus.h>
 #include <sound/es1688.h>
@@ -32,7 +33,6 @@
 #define SNDRV_LEGACY_AUTO_PROBE
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -56,47 +56,48 @@ static int joystick_dac[SNDRV_CARDS] = {
 				/* 0 to 31, (0.59V-4.52V or 0.389V-2.98V) */
 static int channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 24};
 static int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for GUS Extreme soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for GUS Extreme soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable GUS Extreme soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_ENABLED ",allows:{{0x220,0x260,0x20}},dialog:list");
-MODULE_PARM(gf1_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(gf1_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(gf1_port, "GF1 port # for GUS Extreme driver (optional).");
 MODULE_PARM_SYNTAX(gf1_port, SNDRV_ENABLED ",allows:{{0x210,0x270,0x10}},dialog:list");
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_ENABLED ",allows:{{0x300,0x320,0x10}},dialog:list");
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_ENABLED ",allows:{{5},{7},{9},{10}},dialog:list");
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_ENABLED ",allows:{{5},{7},{9},{10}},dialog:list");
-MODULE_PARM(gf1_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(gf1_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(gf1_irq, "GF1 IRQ # for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(gf1_irq, SNDRV_ENABLED ",allows:{{2},{3},{5},{9},{11},{12},{15}},dialog:list");
-MODULE_PARM(dma8, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma8, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma8, "8-bit DMA # for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(dma8, SNDRV_DMA8_DESC);
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "GF1 DMA # for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(joystick_dac, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick_dac, int, boot_devs, 0444);
 MODULE_PARM_DESC(joystick_dac, "Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(joystick_dac, SNDRV_ENABLED ",allows:{{0,31}}");
-MODULE_PARM(channels, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(channels, int, boot_devs, 0444);
 MODULE_PARM_DESC(channels, "GF1 channels for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(channels, SNDRV_ENABLED ",allows:{{14,32}}");
-MODULE_PARM(pcm_channels, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pcm_channels, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS Extreme driver.");
 MODULE_PARM_SYNTAX(pcm_channels, SNDRV_ENABLED ",allows:{{2,16}}");
 
@@ -387,37 +388,3 @@ static void __exit alsa_card_gusextreme_
 
 module_init(alsa_card_gusextreme_init)
 module_exit(alsa_card_gusextreme_exit)
-
-#ifndef MODULE
-
-/* format is: snd-gusextreme=enable,index,id,
-			     port,gf1_port,mpu_port,
-			     irq,gf1_irq,mpu_irq,
-			     dma8,dma1,
-			     joystick_dac,
-			     channels,pcm_channels */
-
-static int __init alsa_card_gusextreme_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&gf1_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&gf1_irq[nr_dev]) == 2 &&
-	       get_option(&str,&mpu_irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma8[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-gusextreme=", alsa_card_gusextreme_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/gus/gusmax.c linux/sound/isa/gus/gusmax.c
--- linux-2.6.5/sound/isa/gus/gusmax.c	2004-04-04 05:37:23.000000000 +0200
+++ linux/sound/isa/gus/gusmax.c	2004-04-07 16:45:14.000000000 +0200
@@ -24,13 +24,13 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/time.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/gus.h>
 #include <sound/cs4231.h>
 #define SNDRV_LEGACY_AUTO_PROBE
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -50,35 +50,36 @@ static int joystick_dac[SNDRV_CARDS] = {
 				/* 0 to 31, (0.59V-4.52V or 0.389V-2.98V) */
 static int channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 24};
 static int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for GUS MAX soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for GUS MAX soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable GUS MAX soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for GUS MAX driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_ENABLED ",allows:{{0x220},{0x230},{0x240},{0x250},{0x260}},dialog:list");
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for GUS MAX driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_ENABLED ",allows:{{3},{5},{9},{11},{12},{15}},dialog:list");
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for GUS MAX driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for GUS MAX driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_DMA_DESC);
-MODULE_PARM(joystick_dac, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick_dac, int, boot_devs, 0444);
 MODULE_PARM_DESC(joystick_dac, "Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for GUS MAX driver.");
 MODULE_PARM_SYNTAX(joystick_dac, SNDRV_ENABLED ",allows:{{0,31}}");
-MODULE_PARM(channels, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(channels, int, boot_devs, 0444);
 MODULE_PARM_DESC(channels, "Used GF1 channels for GUS MAX driver.");
 MODULE_PARM_SYNTAX(channels, SNDRV_ENABLED ",allows:{{14,32}}");
-MODULE_PARM(pcm_channels, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pcm_channels, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS MAX driver.");
 MODULE_PARM_SYNTAX(pcm_channels, SNDRV_ENABLED ",allows:{{2,16}}");
 
@@ -409,35 +410,3 @@ static void __exit alsa_card_gusmax_exit
 
 module_init(alsa_card_gusmax_init)
 module_exit(alsa_card_gusmax_exit)
-
-#ifndef MODULE
-
-/* format is: snd-gusmax=enable,index,id,
-			 port,irq,
-			 dma1,dma2,
-			 joystick_dac,
-			 channels,pcm_channels */
-
-static int __init alsa_card_gusmax_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2 &&
-	       get_option(&str,&joystick_dac[nr_dev]) == 2 &&
-	       get_option(&str,&channels[nr_dev]) == 2 &&
-	       get_option(&str,&pcm_channels[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-gusmax=", alsa_card_gusmax_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/gus/interwave.c linux/sound/isa/gus/interwave.c
--- linux-2.6.5/sound/isa/gus/interwave.c	2004-04-04 05:37:07.000000000 +0200
+++ linux/sound/isa/gus/interwave.c	2004-04-07 16:44:55.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/gus.h>
 #include <sound/cs4231.h>
@@ -37,7 +38,6 @@
 #define SNDRV_LEGACY_AUTO_PROBE
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -73,46 +73,47 @@ static int joystick_dac[SNDRV_CARDS] = {
 static int midi[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
 static int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
 static int effect[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for InterWave soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for InterWave soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable InterWave soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(isapnp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(isapnp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(isapnp, "ISA PnP detection for specified soundcard.");
 MODULE_PARM_SYNTAX(isapnp, SNDRV_ISAPNP_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for InterWave driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_ENABLED ",allows:{{0x210,0x260,0x10}},dialog:list");
 #ifdef SNDRV_STB
-MODULE_PARM(port_tc, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port_tc, long, boot_devs, 0444);
 MODULE_PARM_DESC(port_tc, "Tone control (TEA6330T - i2c bus) port # for InterWave driver.");
 MODULE_PARM_SYNTAX(port_tc, SNDRV_ENABLED ",allows:{{0x350,0x380,0x10}},dialog:list");
 #endif
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for InterWave driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_ENABLED ",allows:{{3},{5},{9},{11},{12},{15}},dialog:list");
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for InterWave driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for InterWave driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_DMA_DESC);
-MODULE_PARM(joystick_dac, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick_dac, int, boot_devs, 0444);
 MODULE_PARM_DESC(joystick_dac, "Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for InterWave driver.");
 MODULE_PARM_SYNTAX(joystick_dac, SNDRV_ENABLED ",allows:{{0,31}}");
-MODULE_PARM(midi, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(midi, int, boot_devs, 0444);
 MODULE_PARM_DESC(midi, "MIDI UART enable for InterWave driver.");
 MODULE_PARM_SYNTAX(midi, SNDRV_ENABLED "," SNDRV_ENABLE_DESC);
-MODULE_PARM(pcm_channels, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pcm_channels, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for InterWave driver.");
 MODULE_PARM_SYNTAX(pcm_channels, SNDRV_ENABLED ",allows:{{2,16}}");
-MODULE_PARM(effect, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(effect, int, boot_devs, 0444);
 MODULE_PARM_DESC(effect, "Effects enable for InterWave driver.");
 MODULE_PARM_SYNTAX(effect, SNDRV_ENABLED "," SNDRV_ENABLE_DESC);
 
@@ -985,49 +986,3 @@ static void __exit alsa_card_interwave_e
 
 module_init(alsa_card_interwave_init)
 module_exit(alsa_card_interwave_exit)
-
-#ifndef MODULE
-
-/* format is: snd-interwave=enable,index,id,isapnp,
-			    port[,port_tc],irq,
-			    dma1,dma2,
-			    joystick_dac,midi,
-			    pcm_channels,effect */
-
-static int __init alsa_card_interwave_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-	int __attribute__ ((__unused__)) pnp = INT_MAX;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pnp) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-#ifdef SNDRV_STB
-	       get_option_long(&str,&port_tc[nr_dev]) == 2 &&
-#endif
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2 &&
-	       get_option(&str,&joystick_dac[nr_dev]) == 2 &&
-	       get_option(&str,&midi[nr_dev]) == 2 &&
-	       get_option(&str,&pcm_channels[nr_dev]) == 2 &&
-	       get_option(&str,&effect[nr_dev]) == 2);
-#ifdef CONFIG_PNP
-	if (pnp != INT_MAX)
-		isapnp[nr_dev] = pnp;
-#endif
-	nr_dev++;
-	return 1;
-}
-
-#ifndef SNDRV_STB
-__setup("snd-interwave=", alsa_card_interwave_setup);
-#else
-__setup("snd-interwave-stb=", alsa_card_interwave_setup);
-#endif
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/opl3sa2.c linux/sound/isa/opl3sa2.c
--- linux-2.6.5/sound/isa/opl3sa2.c	2004-04-04 05:38:21.000000000 +0200
+++ linux/sound/isa/opl3sa2.c	2004-04-08 13:15:17.000000000 +0200
@@ -25,11 +25,11 @@
 #include <linux/pm.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/cs4231.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <asm/io.h>
@@ -59,46 +59,47 @@ static int irq[SNDRV_CARDS] = SNDRV_DEFA
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 1,3,5,6,7 */
 static int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 1,3,5,6,7 */
 static int opl3sa3_ymode[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 };   /* 0,1,2,3 */ /*SL Added*/
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for OPL3-SA soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for OPL3-SA soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable OPL3-SA soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 #ifdef CONFIG_PNP
-MODULE_PARM(isapnp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(isapnp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(isapnp, "PnP detection for specified soundcard.");
 MODULE_PARM_SYNTAX(isapnp, SNDRV_ISAPNP_DESC);
 #endif
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for OPL3-SA driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_ENABLED ",allows:{{0xf86},{0x370},{0x100}},dialog:list");
-MODULE_PARM(sb_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(sb_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(sb_port, "SB port # for OPL3-SA driver.");
 MODULE_PARM_SYNTAX(sb_port, SNDRV_ENABLED ",allows:{{0x220},{0x240},{0x260}},dialog:list");
-MODULE_PARM(wss_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(wss_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(wss_port, "WSS port # for OPL3-SA driver.");
 MODULE_PARM_SYNTAX(wss_port, SNDRV_ENABLED ",allows:{{0x530},{0xe80},{0xf40},{0x604}},dialog:list");
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for OPL3-SA driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_ENABLED ",allows:{{0x388}},dialog:list");
-MODULE_PARM(midi_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(midi_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(midi_port, "MIDI port # for OPL3-SA driver.");
 MODULE_PARM_SYNTAX(midi_port, SNDRV_ENABLED ",allows:{{0x330},{0x300}},dialog:list");
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for OPL3-SA driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_ENABLED ",allows:{{0},{1},{3},{5},{9},{11},{12},{15}},dialog:list");
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for OPL3-SA driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_ENABLED ",allows:{{1},{3},{5},{6},{7}},dialog:list");
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for OPL3-SA driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_ENABLED ",allows:{{1},{3},{5},{6},{7}},dialog:list");
-MODULE_PARM(opl3sa3_ymode, "1-" __MODULE_STRING(SNDRV_CARDS) "i"); /* SL Added */
+module_param_array(opl3sa3_ymode, int, boot_devs, 0444);
 MODULE_PARM_DESC(opl3sa3_ymode, "Speaker size selection for 3D Enhancement mode: Desktop/Large Notebook/Small Notebook/HiFi.");
 MODULE_PARM_SYNTAX(opl3sa3_ymode, SNDRV_ENABLED ",allows:{{0,3}},dialog:list");  /* SL Added */
 
@@ -151,7 +152,6 @@ struct snd_opl3sa2 {
 	snd_kcontrol_t *master_switch;
 	snd_kcontrol_t *master_volume;
 #ifdef CONFIG_PM
-	struct pm_dev *pm_dev;
 	void (*cs4231_suspend)(cs4231_t *);
 	void (*cs4231_resume)(cs4231_t *);
 #endif
@@ -547,12 +547,9 @@ static int __init snd_opl3sa2_mixer(opl3
 
 /* Power Management support functions */
 #ifdef CONFIG_PM
-static void snd_opl3sa2_suspend(opl3sa2_t *chip)
+static int snd_opl3sa2_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
-
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
+	opl3sa2_t *chip = snd_magic_cast(opl3sa2_t, card->pm_private_data, return -EINVAL);
 
 	snd_pcm_suspend_all(chip->cs4231->pcm); /* stop before saving regs */
 	chip->cs4231_suspend(chip->cs4231);
@@ -561,16 +558,14 @@ static void snd_opl3sa2_suspend(opl3sa2_
 	snd_opl3sa2_write(chip, OPL3SA2_PM_CTRL, OPL3SA2_PM_D3);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void snd_opl3sa2_resume(opl3sa2_t *chip)
+static int snd_opl3sa2_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	opl3sa2_t *chip = snd_magic_cast(opl3sa2_t, card->pm_private_data, return -EINVAL);
 	int i;
 
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
-
 	/* power up */
 	snd_opl3sa2_write(chip, OPL3SA2_PM_CTRL, OPL3SA2_PM_D0);
 
@@ -587,43 +582,8 @@ static void snd_opl3sa2_resume(opl3sa2_t
 	chip->cs4231_resume(chip->cs4231);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-/* callback for control API */
-static int snd_opl3sa2_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	opl3sa2_t *chip = (opl3sa2_t *) card->power_state_private_data;
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		snd_opl3sa2_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		snd_opl3sa2_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int snd_opl3sa2_pm_callback(struct pm_dev *dev, pm_request_t rqst, void *data)
-{
-	opl3sa2_t *chip = snd_magic_cast(opl3sa2_t, dev->data, return 0);
-
-	switch (rqst) {
-	case PM_SUSPEND:
-		snd_opl3sa2_suspend(chip);
-		break;
-	case PM_RESUME:
-		snd_opl3sa2_resume(chip);
-		break;
-	}
 	return 0;
 }
-
 #endif /* CONFIG_PM */
 
 #ifdef CONFIG_PNP
@@ -688,10 +648,6 @@ static int __init snd_opl3sa2_pnp(int de
 
 static int snd_opl3sa2_free(opl3sa2_t *chip)
 {
-#ifdef CONFIG_PM
-	if (chip->pm_dev)
-		pm_unregister(chip->pm_dev);
-#endif
 	if (chip->irq >= 0)
 		free_irq(chip->irq, (void *)chip);
 	if (chip->res_port) {
@@ -816,22 +772,12 @@ static int __devinit snd_opl3sa2_probe(i
 			goto __error;
 	}
 #ifdef CONFIG_PM
-	/* Power Management */
-	chip->pm_dev = pm_register(PM_ISA_DEV, 0, snd_opl3sa2_pm_callback);
-	if (chip->pm_dev) {
-		chip->pm_dev->data = chip;
-		/* remember callbacks for cs4231 - they are called inside
-		 * opl3sa2 pm callback
-		 */
-		chip->cs4231_suspend = chip->cs4231->suspend;
-		chip->cs4231_resume = chip->cs4231->resume;
-		/* now clear callbacks for cs4231 */
-		chip->cs4231->suspend = NULL;
-		chip->cs4231->resume = NULL;
-		/* set control api callback */
-		card->set_power_state = snd_opl3sa2_set_power_state;
-		card->power_state_private_data = chip;
-	}
+	chip->cs4231_suspend = chip->cs4231->suspend;
+	chip->cs4231_resume = chip->cs4231->resume;
+	/* now clear callbacks for cs4231 */
+	chip->cs4231->suspend = NULL;
+	chip->cs4231->resume = NULL;
+	snd_card_set_isa_pm_callback(card, snd_opl3sa2_suspend, snd_opl3sa2_resume, chip);
 #endif
 
 	sprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",
@@ -932,42 +878,3 @@ static void __exit alsa_card_opl3sa2_exi
 
 module_init(alsa_card_opl3sa2_init)
 module_exit(alsa_card_opl3sa2_exit)
-
-#ifndef MODULE
-
-/* format is: snd-opl3sa2=enable,index,id,isapnp,
-			  port,sb_port,wss_port,fm_port,
-			  midi_port,irq,dma1,dma2,
-			  opl3sa3_ymode */
-
-static int __init alsa_card_opl3sa2_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-	int __attribute__ ((__unused__)) pnp = INT_MAX;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pnp) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&sb_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&wss_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&midi_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2 &&
-	       get_option(&str,&opl3sa3_ymode[nr_dev]) == 2);
-#ifdef CONFIG_PNP
-	if (pnp != INT_MAX)
-		isapnp[nr_dev] = pnp;
-#endif
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-opl3sa2=", alsa_card_opl3sa2_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/opti9xx/opti92x-ad1848.c linux/sound/isa/opti9xx/opti92x-ad1848.c
--- linux-2.6.5/sound/isa/opti9xx/opti92x-ad1848.c	2004-04-04 05:36:25.000000000 +0200
+++ linux/sound/isa/opti9xx/opti92x-ad1848.c	2004-04-07 16:39:15.000000000 +0200
@@ -30,6 +30,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #ifdef CS4231
 #include <sound/cs4231.h>
@@ -48,7 +49,6 @@
 #endif
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Massimo Piccioni <dafastidio@libero.it>");
@@ -84,38 +84,38 @@ static int dma1 = SNDRV_DEFAULT_DMA1;		/
 static int dma2 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
 #endif	/* CS4231 || OPTi93X */
 
-MODULE_PARM(index, "i");
+module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for opti9xx based soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "s");
+module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for opti9xx based soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-//MODULE_PARM(enable, "i");
+//module_param(enable, bool, 0444);
 //MODULE_PARM_DESC(enable, "Enable opti9xx soundcard.");
 //MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(isapnp, "i");
+module_param(isapnp, bool, 0444);
 MODULE_PARM_DESC(isapnp, "Enable ISA PnP detection for specified soundcard.");
 MODULE_PARM_SYNTAX(isapnp, SNDRV_ISAPNP_DESC);
-MODULE_PARM(port, "l");
+module_param(port, long, 0444);
 MODULE_PARM_DESC(port, "WSS port # for opti9xx driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT_DESC);
-MODULE_PARM(mpu_port, "l");
+module_param(mpu_port, long, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for opti9xx driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT_DESC);
-MODULE_PARM(fm_port, "l");
+module_param(fm_port, long, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for opti9xx driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_PORT_DESC);
-MODULE_PARM(irq, "i");
+module_param(irq, int, 0444);
 MODULE_PARM_DESC(irq, "WSS irq # for opti9xx driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(mpu_irq, "i");
+module_param(mpu_irq, int, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 irq # for opti9xx driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma1, "i");
+module_param(dma1, int, 0444);
 MODULE_PARM_DESC(dma1, "1st dma # for opti9xx driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
 #if defined(CS4231) || defined(OPTi93X)
-MODULE_PARM(dma2, "i");
+module_param(dma2, int, 0444);
 MODULE_PARM_DESC(dma2, "2nd dma # for opti9xx driver.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_DMA_DESC);
 #endif	/* CS4231 || OPTi93X */
@@ -2253,47 +2253,3 @@ static void __exit alsa_card_opti9xx_exi
 
 module_init(alsa_card_opti9xx_init)
 module_exit(alsa_card_opti9xx_exit)
-
-#ifndef MODULE
-
-/* format is: snd-opti9xx=enable,index,id,isapnp,
-			  port,mpu_port,fm_port,
-			  irq,mpu_irq,
-			  dma1,[dma2] */
-
-static int __init alsa_card_opti9xx_setup(char *str)
-{
-	int __attribute__ ((__unused__)) enable = 1;
-	int __attribute__ ((__unused__)) pnp = INT_MAX;
-
-	(void)(get_option(&str,&enable) == 2 &&
-	       get_option(&str,&index) == 2 &&
-	       get_id(&str,&id) == 2 &&
-	       get_option(&str,&pnp) == 2 &&
-	       get_option_long(&str,&port) == 2 &&
-	       get_option_long(&str,&mpu_port) == 2 &&
-	       get_option_long(&str,&fm_port) == 2 &&
-	       get_option(&str,&irq) == 2 &&
-	       get_option(&str,&mpu_irq) == 2 &&
-	       get_option(&str,&dma1) == 2
-#if defined(CS4231) || defined(OPTi93X)
-	       &&
-	       get_option(&str,&dma2) == 2
-#endif
-	       );
-#ifdef CONFIG_PNP
-	if (pnp != INT_MAX)
-		isapnp = pnp;
-#endif
-	return 1;
-}
-
-#if defined(OPTi93X)
-__setup("snd-opti93x=", alsa_card_opti9xx_setup);
-#elif defined(CS4231)
-__setup("snd-opti92x-cs4231=", alsa_card_opti9xx_setup);
-#else
-__setup("snd-opti92x-ad1848=", alsa_card_opti9xx_setup);
-#endif
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/sb/emu8000_patch.c linux/sound/isa/sb/emu8000_patch.c
--- linux-2.6.5/sound/isa/sb/emu8000_patch.c	2004-04-04 05:36:25.000000000 +0200
+++ linux/sound/isa/sb/emu8000_patch.c	2004-04-07 17:46:27.000000000 +0200
@@ -21,12 +21,12 @@
 
 #include "emu8000_local.h"
 #include <asm/uaccess.h>
+#include <linux/moduleparam.h>
 
-MODULE_PARM(emu8000_reset_addr, "i");
+static int emu8000_reset_addr = 0;
+module_param(emu8000_reset_addr, int, 0444);
 MODULE_PARM_DESC(emu8000_reset_addr, "reset write address at each time (makes slowdown)");
 
-int emu8000_reset_addr = 0;
-
 
 /*
  * Open up channels.
diff -rup linux-2.6.5/sound/isa/sb/es968.c linux/sound/isa/sb/es968.c
--- linux-2.6.5/sound/isa/sb/es968.c	2004-04-04 05:37:06.000000000 +0200
+++ linux/sound/isa/sb/es968.c	2004-04-07 16:44:30.000000000 +0200
@@ -24,8 +24,8 @@
 #include <linux/init.h>
 #include <linux/time.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/sb.h>
 
@@ -45,23 +45,24 @@ static int enable[SNDRV_CARDS] = SNDRV_D
 static long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;	/* PnP setup */
 static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* Pnp setup */
 static int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* PnP setup */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for es968 based soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for es968 based soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable es968 based soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for es968 driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for es968 driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma8, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma8, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma8, "8-bit DMA # for es968 driver.");
 MODULE_PARM_SYNTAX(dma8, SNDRV_DMA8_DESC);
 
@@ -242,28 +243,3 @@ static void __exit alsa_card_es968_exit(
 
 module_init(alsa_card_es968_init)
 module_exit(alsa_card_es968_exit)
-
-#ifndef MODULE
-
-/* format is: snd-es968=enable,index,id,
-			port,irq,dma1 */
-
-static int __init alsa_card_es968_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma8[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-es968=", alsa_card_es968_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/sb/sb16.c linux/sound/isa/sb/sb16.c
--- linux-2.6.5/sound/isa/sb/sb16.c	2004-04-04 05:37:43.000000000 +0200
+++ linux/sound/isa/sb/sb16.c	2004-04-07 16:44:43.000000000 +0200
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/sb.h>
 #include <sound/sb16_csp.h>
@@ -34,7 +35,6 @@
 #define SNDRV_LEGACY_AUTO_PROBE
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #define chip_t sb_t
@@ -92,54 +92,55 @@ static int csp[SNDRV_CARDS] = {[0 ... (S
 #ifdef SNDRV_SBAWE_EMU8000
 static int seq_ports[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 4};
 #endif
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for SoundBlaster 16 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for SoundBlaster 16 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable SoundBlaster 16 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 #ifdef CONFIG_PNP
-MODULE_PARM(isapnp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(isapnp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(isapnp, "PnP detection for specified soundcard.");
 MODULE_PARM_SYNTAX(isapnp, SNDRV_ISAPNP_DESC);
 #endif
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for SB16 driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_ENABLED ",allows:{{0x220},{0x240},{0x260},{0x280}},dialog:list");
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for SB16 driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_ENABLED ",allows:{{0x330},{0x300}},dialog:list");
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for SB16 PnP driver.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_ENABLED ",allows:{{0x388},{0x38c},{0x390},{0x394}},dialog:list");
 #ifdef SNDRV_SBAWE_EMU8000
-MODULE_PARM(awe_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(awe_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(awe_port, "AWE port # for SB16 PnP driver.");
 MODULE_PARM_SYNTAX(awe_port, SNDRV_ENABLED ",allows:{{0x620},{0x640},{0x660},{0x680}},dialog:list");
 #endif
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for SB16 driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma8, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma8, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma8, "8-bit DMA # for SB16 driver.");
 MODULE_PARM_SYNTAX(dma8, SNDRV_DMA8_DESC);
-MODULE_PARM(dma16, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma16, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma16, "16-bit DMA # for SB16 driver.");
 MODULE_PARM_SYNTAX(dma16, SNDRV_DMA16_DESC);
-MODULE_PARM(mic_agc, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mic_agc, int, boot_devs, 0444);
 MODULE_PARM_DESC(mic_agc, "Mic Auto-Gain-Control switch.");
 MODULE_PARM_SYNTAX(mic_agc, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
 #ifdef CONFIG_SND_SB16_CSP
-MODULE_PARM(csp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(csp, int, boot_devs, 0444);
 MODULE_PARM_DESC(csp, "ASP/CSP chip support.");
 MODULE_PARM_SYNTAX(csp, SNDRV_ENABLED "," SNDRV_ENABLE_DESC);
 #endif
 #ifdef SNDRV_SBAWE_EMU8000
-MODULE_PARM(seq_ports, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(seq_ports, int, boot_devs, 0444);
 MODULE_PARM_DESC(seq_ports, "Number of sequencer ports for WaveTable synth.");
 MODULE_PARM_SYNTAX(seq_ports, SNDRV_ENABLED ",allows:{{0,8}},skill:advanced");
 #endif
@@ -691,60 +692,3 @@ static void __exit alsa_card_sb16_exit(v
 
 module_init(alsa_card_sb16_init)
 module_exit(alsa_card_sb16_exit)
-
-#ifndef MODULE
-
-/* format is: snd-sb16=enable,index,id,isapnp,
-		       port,mpu_port,fm_port,
-		       irq,dma8,dma16,
-		       mic_agc,csp,
-		       [awe_port,seq_ports] */
-
-static int __init alsa_card_sb16_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-	int __attribute__ ((__unused__)) pnp = INT_MAX;
-	int __attribute__ ((__unused__)) xcsp = INT_MAX;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pnp) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma8[nr_dev]) == 2 &&
-	       get_option(&str,&dma16[nr_dev]) == 2 &&
-	       get_option(&str,&mic_agc[nr_dev]) == 2
-#ifdef CONFIG_SND_SB16_CSP
-	       &&
-	       get_option(&str,&xcsp) == 2
-#endif
-#ifdef SNDRV_SBAWE_EMU8000
-	       &&
-	       get_option_long(&str,&awe_port[nr_dev]) == 2 &&
-	       get_option(&str,&seq_ports[nr_dev]) == 2
-#endif
-	       );
-#ifdef CONFIG_PNP
-	if (pnp != INT_MAX)
-		isapnp[nr_dev] = pnp;
-#endif
-#ifdef CONFIG_SND_SB16_CSP
-	if (xcsp != INT_MAX)
-		csp[nr_dev] = xcsp;
-#endif
-	nr_dev++;
-	return 1;
-}
-
-#ifndef SNDRV_SBAWE_EMU8000
-__setup("snd-sb16=", alsa_card_sb16_setup);
-#else
-__setup("snd-sbawe=", alsa_card_sb16_setup);
-#endif
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/sb/sb8.c linux/sound/isa/sb/sb8.c
--- linux-2.6.5/sound/isa/sb/sb8.c	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/isa/sb/sb8.c	2004-04-07 16:44:21.000000000 +0200
@@ -23,11 +23,11 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/sb.h>
 #include <sound/opl3.h>
 #define SNDRV_LEGACY_AUTO_PROBE
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #define chip_t sb_t
@@ -44,23 +44,24 @@ static int enable[SNDRV_CARDS] = SNDRV_D
 static long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;	/* 0x220,0x240,0x260 */
 static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 5,7,9,10 */
 static int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 1,3 */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Sound Blaster soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Sound Blaster soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Sound Blaster soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for SB8 driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_PORT12_DESC);
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for SB8 driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
-MODULE_PARM(dma8, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma8, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma8, "8-bit DMA # for SB8 driver.");
 MODULE_PARM_SYNTAX(dma8, SNDRV_DMA8_DESC);
 
@@ -230,28 +231,3 @@ static void __exit alsa_card_sb8_exit(vo
 
 module_init(alsa_card_sb8_init)
 module_exit(alsa_card_sb8_exit)
-
-#ifndef MODULE
-
-/* format is: snd-sb8=enable,index,id,
-		      port,irq,dma8 */
-
-static int __init alsa_card_sb8_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&port[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma8[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-sb8=", alsa_card_sb8_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/sgalaxy.c linux/sound/isa/sgalaxy.c
--- linux-2.6.5/sound/isa/sgalaxy.c	2004-04-04 05:38:28.000000000 +0200
+++ linux/sound/isa/sgalaxy.c	2004-04-07 16:46:35.000000000 +0200
@@ -27,13 +27,13 @@
 #include <linux/delay.h>
 #include <linux/time.h>
 #include <linux/irq.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/sb.h>
 #include <sound/ad1848.h>
 #include <sound/control.h>
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Christopher Butler <chrisb@sandy.force9.co.uk>");
@@ -49,23 +49,24 @@ static long sbport[SNDRV_CARDS] = SNDRV_
 static long wssport[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;	/* 0x530,0xe80,0xf40,0x604 */
 static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 7,9,10,11 */
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3 */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Sound Galaxy soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Sound Galaxy soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(sbport, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(sbport, long, boot_devs, 0444);
 MODULE_PARM_DESC(sbport, "Port # for Sound Galaxy SB driver.");
 MODULE_PARM_SYNTAX(sbport, SNDRV_ENABLED ",allows:{{0x220},{0x240}},dialog:list");
-MODULE_PARM(wssport, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(wssport, long, boot_devs, 0444);
 MODULE_PARM_DESC(wssport, "Port # for Sound Galaxy WSS driver.");
 MODULE_PARM_SYNTAX(wssport, SNDRV_ENABLED ",allows:{{0x530},{0xe80},{0xf40},{0x604}},dialog:list");
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for Sound Galaxy driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_ENABLED ",allows:{{7},{9},{10},{11}},dialog:list");
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for Sound Galaxy driver.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA8_DESC);
 
@@ -327,30 +328,3 @@ static void __exit alsa_card_sgalaxy_exi
 
 module_init(alsa_card_sgalaxy_init)
 module_exit(alsa_card_sgalaxy_exit)
-
-#ifndef MODULE
-
-/* format is: snd-sgalaxy=enable,index,id,
-			  sbport,wssport,
-			  irq,dma1 */
-
-static int __init alsa_card_sgalaxy_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&sbport[nr_dev]) == 2 &&
-	       get_option_long(&str,&wssport[nr_dev]) == 2 &&
-	       get_option(&str,&irq[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-sgalaxy=", alsa_card_sgalaxy_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/sscape.c linux/sound/isa/sscape.c
--- linux-2.6.5/sound/isa/sscape.c	2004-04-04 05:36:18.000000000 +0200
+++ linux/sound/isa/sscape.c	2004-04-07 16:46:10.000000000 +0200
@@ -26,12 +26,12 @@
 #include <linux/delay.h>
 #include <linux/pnp.h>
 #include <linux/spinlock.h>
+#include <linux/moduleparam.h>
 #include <asm/dma.h>
 #include <sound/core.h>
 #include <sound/hwdep.h>
 #include <sound/cs4231.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <sound/sscape_ioctl.h>
@@ -49,28 +49,29 @@ static long port[SNDRV_CARDS] __devinitd
 static int irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
 static int mpu_irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
 static int dma[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_DMA;
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index number for SoundScape soundcard");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
 
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "Description for SoundScape card");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
 
-MODULE_PARM(port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(port, long, boot_devs, 0444);
 MODULE_PARM_DESC(port, "Port # for SoundScape driver.");
 MODULE_PARM_SYNTAX(port, SNDRV_ENABLED);
 
-MODULE_PARM(irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for SoundScape driver.");
 MODULE_PARM_SYNTAX(irq, SNDRV_IRQ_DESC);
 
-MODULE_PARM(mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU401 IRQ # for SoundScape driver.");
 MODULE_PARM_SYNTAX(mpu_irq, SNDRV_IRQ_DESC);
 
-MODULE_PARM(dma, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma, "DMA # for SoundScape driver.");
 MODULE_PARM_SYNTAX(dma, SNDRV_DMA8_DESC);
   
@@ -1531,30 +1532,3 @@ static int __init sscape_init(void)
 
 module_init(sscape_init);
 module_exit(sscape_exit);
-
-#ifndef MODULE
-
-/* format is: snd-sscape=index,id,port,irq,mpu_irq,dma */
-
-static int __init builtin_sscape_setup(char *str)
-{
-	static unsigned __initdata nr_dev;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-
-	(void)((get_option(&str, &index[nr_dev]) == 2) &&
-	       (get_id(&str, &id[nr_dev]) == 2) &&
-	       (get_option_long(&str, &port[nr_dev]) == 2) &&
-	       (get_option(&str, &irq[nr_dev]) == 2) &&
-	       (get_option(&str, &mpu_irq[nr_dev]) == 2) &&
-	       (get_option(&str, &dma[nr_dev]) == 2)); 
- 
-	++nr_dev;
-	return 1;
-}
-
-__setup("snd-sscape=", builtin_sscape_setup);
-
-#endif
-
diff -rup linux-2.6.5/sound/isa/wavefront/wavefront.c linux/sound/isa/wavefront/wavefront.c
--- linux-2.6.5/sound/isa/wavefront/wavefront.c	2004-04-04 05:37:39.000000000 +0200
+++ linux/sound/isa/wavefront/wavefront.c	2004-04-07 16:45:54.000000000 +0200
@@ -24,8 +24,8 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/opl3.h>
 #include <sound/snd_wavefront.h>
@@ -52,49 +52,50 @@ static long fm_port[SNDRV_CARDS] = SNDRV
 static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	    /* 0,1,3,5,6,7 */
 static int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	    /* 0,1,3,5,6,7 */
 static int use_cs4232_midi[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; 
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for WaveFront soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for WaveFront soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable WaveFront soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 #ifdef CONFIG_PNP
-MODULE_PARM(isapnp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(isapnp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(isapnp, "ISA PnP detection for WaveFront soundcards.");
 MODULE_PARM_SYNTAX(isapnp, SNDRV_ISAPNP_DESC);
 #endif
-MODULE_PARM(cs4232_pcm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(cs4232_pcm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(cs4232_pcm_port, "Port # for CS4232 PCM interface.");
 MODULE_PARM_SYNTAX(cs4232_pcm_port, SNDRV_PORT12_DESC);
-MODULE_PARM(cs4232_pcm_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(cs4232_pcm_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(cs4232_pcm_irq, "IRQ # for CS4232 PCM interface.");
 MODULE_PARM_SYNTAX(cs4232_pcm_irq, SNDRV_ENABLED ",allows:{{5},{7},{9},{11},{12},{15}},dialog:list");
-MODULE_PARM(dma1, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma1, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma1, "DMA1 # for CS4232 PCM interface.");
 MODULE_PARM_SYNTAX(dma1, SNDRV_DMA_DESC);
-MODULE_PARM(dma2, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dma2, int, boot_devs, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for CS4232 PCM interface.");
 MODULE_PARM_SYNTAX(dma2, SNDRV_DMA_DESC);
-MODULE_PARM(cs4232_mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(cs4232_mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(cs4232_mpu_port, "port # for CS4232 MPU-401 interface.");
 MODULE_PARM_SYNTAX(cs4232_mpu_port, SNDRV_PORT12_DESC);
-MODULE_PARM(cs4232_mpu_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(cs4232_mpu_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(cs4232_mpu_irq, "IRQ # for CS4232 MPU-401 interface.");
 MODULE_PARM_SYNTAX(cs4232_mpu_irq, SNDRV_ENABLED ",allows:{{9},{11},{12},{15}},dialog:list");
-MODULE_PARM(ics2115_irq, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ics2115_irq, int, boot_devs, 0444);
 MODULE_PARM_DESC(ics2115_irq, "IRQ # for ICS2115.");
 MODULE_PARM_SYNTAX(ics2115_irq, SNDRV_ENABLED ",allows:{{9},{11},{12},{15}},dialog:list");
-MODULE_PARM(ics2115_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(ics2115_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(ics2115_port, "Port # for ICS2115.");
 MODULE_PARM_SYNTAX(ics2115_port, SNDRV_PORT12_DESC);
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port #.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_PORT12_DESC);
-MODULE_PARM(use_cs4232_midi, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(use_cs4232_midi, bool, boot_devs, 0444);
 MODULE_PARM_DESC(use_cs4232_midi, "Use CS4232 MPU-401 interface (inaccessibly located inside your computer)");
 MODULE_PARM_SYNTAX(use_cs4232_midi, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 
@@ -731,41 +732,3 @@ static void __exit alsa_card_wavefront_e
 
 module_init(alsa_card_wavefront_init)
 module_exit(alsa_card_wavefront_exit)
-
-#ifndef MODULE
-
-/* format is: snd-wavefront=enable,index,id,isapnp,
-			    cs4232_pcm_port,cs4232_pcm_irq,
-			    cs4232_mpu_port,cs4232_mpu_irq,
-			    ics2115_port,ics2115_irq,
-			    fm_port,
-			    dma1,dma2,
-			    use_cs4232_midi */
-
-static int __init alsa_card_wavefront_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&isapnp[nr_dev]) == 2 &&
-	       get_option_long(&str,&cs4232_pcm_port[nr_dev]) == 2 &&
-	       get_option(&str,&cs4232_pcm_irq[nr_dev]) == 2 &&
-	       get_option_long(&str,&cs4232_mpu_port[nr_dev]) == 2 &&
-	       get_option(&str,&cs4232_mpu_irq[nr_dev]) == 2 &&
-	       get_option_long(&str,&ics2115_port[nr_dev]) == 2 &&
-	       get_option(&str,&ics2115_irq[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option(&str,&dma1[nr_dev]) == 2 &&
-	       get_option(&str,&dma2[nr_dev]) == 2 &&
-	       get_option(&str,&use_cs4232_midi[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-wavefront=", alsa_card_wavefront_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/isa/wavefront/wavefront_synth.c linux/sound/isa/wavefront/wavefront_synth.c
--- linux-2.6.5/sound/isa/wavefront/wavefront_synth.c	2004-04-04 05:36:56.000000000 +0200
+++ linux/sound/isa/wavefront/wavefront_synth.c	2004-04-07 16:31:27.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/delay.h>
 #include <linux/time.h>
 #include <linux/wait.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/snd_wavefront.h>
 #include <sound/initval.h>
@@ -83,25 +84,25 @@ int ramcheck_time = 20;    /* time in se
 int osrun_time = 10;       /* time in seconds we wait for the OS to
 			      start running.
 			   */
-MODULE_PARM(wf_raw,"i");
+module_param(wf_raw, int, 0444);
 MODULE_PARM_DESC(wf_raw, "if non-zero, assume that we need to boot the OS");
-MODULE_PARM(fx_raw,"i");
+module_param(fx_raw, int, 0444);
 MODULE_PARM_DESC(fx_raw, "if non-zero, assume that the FX process needs help");
-MODULE_PARM(debug_default,"i");
+module_param(debug_default, int, 0444);
 MODULE_PARM_DESC(debug_default, "debug parameters for card initialization");
-MODULE_PARM(wait_usecs,"i");
+module_param(wait_usecs, int, 0444);
 MODULE_PARM_DESC(wait_usecs, "how long to wait without sleeping, usecs");
-MODULE_PARM(sleep_interval,"i");
+module_param(sleep_interval, int, 0444);
 MODULE_PARM_DESC(sleep_interval, "how long to sleep when waiting for reply");
-MODULE_PARM(sleep_tries,"i");
+module_param(sleep_tries, int, 0444);
 MODULE_PARM_DESC(sleep_tries, "how many times to try sleeping during a wait");
-MODULE_PARM(ospath,"s");
+module_param(ospath, charp, 0444);
 MODULE_PARM_DESC(ospath, "full pathname to processed ICS2115 OS firmware");
-MODULE_PARM(reset_time,"i");
+module_param(reset_time, int, 0444);
 MODULE_PARM_DESC(reset_time, "how long to wait for a reset to take effect");
-MODULE_PARM(ramcheck_time,"i");
+module_param(ramcheck_time, int, 0444);
 MODULE_PARM_DESC(ramcheck_time, "how many seconds to wait for the RAM test");
-MODULE_PARM(osrun_time,"i");
+module_param(osrun_time, int, 0444);
 MODULE_PARM_DESC(osrun_time, "how many seconds to wait for the ICS2115 OS");
 
 /* if WF_DEBUG not defined, no run-time debugging messages will
diff -rup linux-2.6.5/sound/parisc/harmony.c linux/sound/parisc/harmony.c
--- linux-2.6.5/sound/parisc/harmony.c	2004-04-04 05:36:57.000000000 +0200
+++ linux/sound/parisc/harmony.c	2004-04-13 12:48:17.000000000 +0200
@@ -70,11 +70,11 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/wait.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/info.h>
 #include <asm/hardware.h>
@@ -140,6 +140,17 @@ MODULE_DEVICES("{{ALSA,Harmony soundcard
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;
+static int boot_devs;
+
+module_param_array(index, int, boot_devs, 0444);
+MODULE_PARM_DESC(index, "Index value for Sun CS4231 soundcard.");
+MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
+module_param_array(id, charp, boot_devs, 0444);
+MODULE_PARM_DESC(id, "ID string for Sun CS4231 soundcard.");
+MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
+module_param_array(enable, bool, boot_devs, 0444);
+MODULE_PARM_DESC(enable, "Enable Sun CS4231 soundcard.");
+MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 
 /* Register offset (from base hpa) */
 #define REG_ID		0x00
@@ -544,7 +555,7 @@ static int snd_card_harmony_capture_trig
 		case SNDRV_PCM_TRIGGER_STOP:
 			if (harmony->cap_stopped) 
 				return -EBUSY;
-			harmony->cap_stopped = 1;
+			harmony->cap_stopped = 1;;
 			snd_harmony_disable_interrupts(harmony);
 			break;
 		case SNDRV_PCM_TRIGGER_START:
@@ -847,7 +858,7 @@ static int snd_card_harmony_pcm_init(snd
 	harmony->pcm = pcm;
 	
 	/* initialize graveyard buffer */
-	harmony->dma_dev.type = SNDRV_DMA_TYPE_PCI;
+	harmony->dma_dev.type = SNDRV_DMA_TYPE_DEV;
 	harmony->dma_dev.dev = snd_dma_pci_data(harmony->fake_pci_dev); 
 	harmony->graveyard_addr = snd_dma_alloc_pages(&chip->dma_dev,
 			HARMONY_BUF_SIZE*GRAVEYARD_BUFS, &harmony->graveyard_dma);
diff -rup linux-2.6.5/sound/pci/Kconfig linux/sound/pci/Kconfig
--- linux-2.6.5/sound/pci/Kconfig	2004-04-04 05:36:56.000000000 +0200
+++ linux/sound/pci/Kconfig	2004-04-13 17:29:59.000000000 +0200
@@ -29,6 +29,9 @@ config SND_AU8810
 	select SND_AC97_CODEC
         help
           Say 'Y' or 'M' to include support for Aureal Advantage soundcards.
+          Supported features: Hardware Mixer, SRC, EQ and SPDIF output.
+          3D support code is in place, but not yet useable. For more info, 
+          email the ALSA developer list, or mjander@users.sourceforge.net.
  
 config SND_AU8820
         tristate "Aureal Vortex"
@@ -37,6 +40,8 @@ config SND_AU8820
 	select SND_AC97_CODEC
         help
           Say 'Y' or 'M' to include support for Aureal Vortex soundcards.
+          Supported features: Hardware Mixer and SRC. For more info, email 
+          the ALSA developer list, or mjander@users.sourceforge.net.
  
 config SND_AU8830
         tristate "Aureal Vortex 2"
@@ -45,6 +50,9 @@ config SND_AU8830
 	select SND_AC97_CODEC
         help
           Say 'Y' or 'M' to include support for Aureal Vortex 2 soundcards.
+          Supported features: Hardware Mixer, SRC, EQ and SPDIF output.
+          3D support code is in place, but not yet useable. For more info, 
+          email the ALSA developer list, or mjander@users.sourceforge.net.
  
 config SND_AZT3328
 	tristate "Aztech AZF3328 / PCI168 (EXPERIMENTAL)"
diff -rup linux-2.6.5/sound/pci/ac97/ac97_codec.c linux/sound/pci/ac97/ac97_codec.c
--- linux-2.6.5/sound/pci/ac97/ac97_codec.c	2004-04-04 05:36:56.000000000 +0200
+++ linux/sound/pci/ac97/ac97_codec.c	2004-04-14 12:24:15.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/pci.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
@@ -42,7 +43,7 @@ MODULE_LICENSE("GPL");
 
 static int enable_loopback;
 
-MODULE_PARM(enable_loopback, "i");
+module_param(enable_loopback, bool, 0444);
 MODULE_PARM_DESC(enable_loopback, "Enable AC97 ADC/DAC Loopback Control");
 MODULE_PARM_SYNTAX(enable_loopback, SNDRV_BOOLEAN_FALSE_DESC);
 
@@ -299,6 +300,16 @@ unsigned short snd_ac97_read(ac97_t *ac9
 	return ac97->bus->read(ac97, reg);
 }
 
+/* read a register - return the cached value if already read */
+static inline unsigned short snd_ac97_read_cache(ac97_t *ac97, unsigned short reg)
+{
+	if (! test_bit(reg, ac97->reg_accessed)) {
+		ac97->regs[reg] = ac97->bus->read(ac97, reg);
+		// set_bit(reg, ac97->reg_accessed);
+	}
+	return ac97->regs[reg];
+}
+
 /**
  * snd_ac97_write_cache - write a value on the given register and update the cache
  * @ac97: the ac97 instance
@@ -370,7 +381,7 @@ int snd_ac97_update_bits(ac97_t *ac97, u
 	if (!snd_ac97_valid_reg(ac97, reg))
 		return -EINVAL;
 	spin_lock(&ac97->reg_lock);
-	old = ac97->regs[reg];
+	old = snd_ac97_read_cache(ac97, reg);
 	new = (old & ~mask) | value;
 	change = old != new;
 	if (change) {
@@ -385,25 +396,26 @@ int snd_ac97_update_bits(ac97_t *ac97, u
 static int snd_ac97_ad18xx_update_pcm_bits(ac97_t *ac97, int codec, unsigned short mask, unsigned short value)
 {
 	int change;
-	unsigned short old, new;
+	unsigned short old, new, cfg;
 
 	down(&ac97->spec.ad18xx.mutex);
 	spin_lock(&ac97->reg_lock);
 	old = ac97->spec.ad18xx.pcmreg[codec];
 	new = (old & ~mask) | value;
+	cfg = snd_ac97_read_cache(ac97, AC97_AD_SERIAL_CFG);
 	change = old != new;
 	if (change) {
 		ac97->spec.ad18xx.pcmreg[codec] = new;
 		spin_unlock(&ac97->reg_lock);
 		/* select single codec */
 		ac97->bus->write(ac97, AC97_AD_SERIAL_CFG,
-				 (ac97->regs[AC97_AD_SERIAL_CFG] & ~0x7000) |
+				 (cfg & ~0x7000) |
 				 ac97->spec.ad18xx.unchained[codec] | ac97->spec.ad18xx.chained[codec]);
 		/* update PCM bits */
 		ac97->bus->write(ac97, AC97_PCM, new);
 		/* select all codecs */
 		ac97->bus->write(ac97, AC97_AD_SERIAL_CFG,
-				 ac97->regs[AC97_AD_SERIAL_CFG] | 0x7000);
+				 cfg | 0x7000);
 	} else
 		spin_unlock(&ac97->reg_lock);
 	up(&ac97->spec.ad18xx.mutex);
@@ -435,7 +447,7 @@ static int snd_ac97_get_mux(snd_kcontrol
 	ac97_t *ac97 = snd_kcontrol_chip(kcontrol);
 	unsigned short val;
 	
-	val = ac97->regs[AC97_REC_SEL];
+	val = snd_ac97_read_cache(ac97, AC97_REC_SEL);
 	ucontrol->value.enumerated.item[0] = (val >> 8) & 7;
 	ucontrol->value.enumerated.item[1] = (val >> 0) & 7;
 	return 0;
@@ -493,7 +505,7 @@ static int snd_ac97_get_enum_double(snd_
 	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int invert = (kcontrol->private_value >> 24) & 0xff;
 	
-	val = (ac97->regs[reg] >> shift) & 1;
+	val = (snd_ac97_read_cache(ac97, reg) >> shift) & 1;
 	if (invert)
 		val ^= 1;
 	ucontrol->value.enumerated.item[0] = val;
@@ -535,7 +547,7 @@ int snd_ac97_get_single(snd_kcontrol_t *
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 	int invert = (kcontrol->private_value >> 24) & 0xff;
 	
-	ucontrol->value.integer.value[0] = (ac97->regs[reg] >> shift) & mask;
+	ucontrol->value.integer.value[0] = (snd_ac97_read_cache(ac97, reg) >> shift) & mask;
 	if (invert)
 		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
 	return 0;
@@ -582,8 +594,8 @@ static int snd_ac97_get_double(snd_kcont
 	int invert = (kcontrol->private_value >> 24) & 0xff;
 	
 	spin_lock(&ac97->reg_lock);
-	ucontrol->value.integer.value[0] = (ac97->regs[reg] >> shift_left) & mask;
-	ucontrol->value.integer.value[1] = (ac97->regs[reg] >> shift_right) & mask;
+	ucontrol->value.integer.value[0] = (snd_ac97_read_cache(ac97, reg) >> shift_left) & mask;
+	ucontrol->value.integer.value[1] = (snd_ac97_read_cache(ac97, reg) >> shift_right) & mask;
 	spin_unlock(&ac97->reg_lock);
 	if (invert) {
 		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
@@ -796,7 +808,7 @@ static int snd_ac97_spdif_default_put(sn
 					       AC97_CXR_SPDIF_MASK | AC97_CXR_COPYRGT,
 					       v);
 	} else {
-		unsigned short extst = ac97->regs[AC97_EXTENDED_STATUS];
+		unsigned short extst = snd_ac97_read_cache(ac97, AC97_EXTENDED_STATUS);
 		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0); /* turn off */
 
 		change |= snd_ac97_update_bits(ac97, AC97_SPDIF, 0x3fff, val);
@@ -822,13 +834,13 @@ static int snd_ac97_put_spsa(snd_kcontro
 	mask <<= shift;
 	value <<= shift;
 	spin_lock(&ac97->reg_lock);
-	old = ac97->regs[reg];
+	old = snd_ac97_read_cache(ac97, reg);
 	new = (old & ~mask) | value;
 	spin_unlock(&ac97->reg_lock);
 
 	if (old != new) {
 		int change;
-		unsigned short extst = ac97->regs[AC97_EXTENDED_STATUS];
+		unsigned short extst = snd_ac97_read_cache(ac97, AC97_EXTENDED_STATUS);
 		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0); /* turn off */
 		change = snd_ac97_update_bits(ac97, reg, mask, value);
 		if (extst & AC97_EA_SPDIF)
@@ -1572,6 +1584,26 @@ static void snd_ac97_determine_rates(ac9
 	*r_result = result;
 }
 
+/* check AC97_SPDIF register to accept which sample rates */
+static unsigned int snd_ac97_determine_spdif_rates(ac97_t *ac97)
+{
+	unsigned int result = 0;
+	int i;
+	static unsigned short ctl_bits[] = {
+		AC97_SC_SPSR_44K, AC97_SC_SPSR_32K, AC97_SC_SPSR_48K
+	};
+	static unsigned int rate_bits[] = {
+		SNDRV_PCM_RATE_44100, SNDRV_PCM_RATE_32000, SNDRV_PCM_RATE_48000
+	};
+
+	for (i = 0; i < (int)ARRAY_SIZE(ctl_bits); i++) {
+		snd_ac97_update_bits(ac97, AC97_SPDIF, AC97_SC_SPSR_MASK, ctl_bits[i]);
+		if ((snd_ac97_read(ac97, AC97_SPDIF) & AC97_SC_SPSR_MASK) == ctl_bits[i])
+			result |= rate_bits[i];
+	}
+	return result;
+}
+
 void snd_ac97_get_name(ac97_t *ac97, unsigned int id, char *name, int modem)
 {
 	const ac97_codec_id_t *pid;
@@ -1889,9 +1921,7 @@ int snd_ac97_mixer(ac97_bus_t * bus, ac9
 		else if (ac97->id == AC97_ID_CM9739)
 			ac97->rates[AC97_RATES_SPDIF] = SNDRV_PCM_RATE_48000;
 		else
-			ac97->rates[AC97_RATES_SPDIF] = SNDRV_PCM_RATE_48000 |
-						SNDRV_PCM_RATE_44100 |
-						SNDRV_PCM_RATE_32000;
+			ac97->rates[AC97_RATES_SPDIF] = snd_ac97_determine_spdif_rates(ac97);
 	}
 	if (ac97->ext_id & AC97_EI_VRM) {	/* MIC VRA support */
 		snd_ac97_determine_rates(ac97, AC97_PCM_MIC_ADC_RATE, 0, &ac97->rates[AC97_RATES_MIC_ADC]);
@@ -1949,12 +1979,12 @@ int snd_ac97_mixer(ac97_bus_t * bus, ac9
 	}
 	/* make sure the proper powerdown bits are cleared */
 	if (ac97->scaps) {
-		reg = snd_ac97_read(ac97, AC97_EXTENDED_ID);
+		reg = snd_ac97_read(ac97, AC97_EXTENDED_STATUS);
 		if (ac97->scaps & AC97_SCAP_SURROUND_DAC) 
 			reg &= ~AC97_EA_PRJ;
 		if (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC) 
 			reg &= ~(AC97_EA_PRI | AC97_EA_PRK);
-		snd_ac97_write_cache(ac97, AC97_EXTENDED_ID, reg);
+		snd_ac97_write_cache(ac97, AC97_EXTENDED_STATUS, reg);
 	}
 	snd_ac97_proc_init(ac97);
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ac97, &ops)) < 0) {
@@ -1971,11 +2001,19 @@ int snd_ac97_mixer(ac97_bus_t * bus, ac9
  * @ac97: the ac97 instance
  *
  * Suspends the codec, power down the chip.
+ * MASTER and HEADPHONE registers are muted but the register cache values
+ * are not changed, so that the values can be restored in snd_ac97_resume().
  */
 void snd_ac97_suspend(ac97_t *ac97)
 {
 	unsigned short power = (ac97->regs[AC97_POWERDOWN] ^ 0x8000) & ~0x8000;	/* invert EAPD */
 
+	if (ac97_is_audio(ac97)) {
+		/* some codecs have stereo mute bits */
+		snd_ac97_write(ac97, AC97_MASTER, 0x9f9f);
+		snd_ac97_write(ac97, AC97_HEADPHONE, 0x9f9f);
+	}
+
 	power |= 0x4000;	/* Headphone amplifier powerdown */
 	power |= 0x0300;	/* ADC & DAC powerdown */
 	snd_ac97_write(ac97, AC97_POWERDOWN, power);
@@ -2267,6 +2305,7 @@ EXPORT_SYMBOL(snd_ac97_tune_hardware);
 EXPORT_SYMBOL(snd_ac97_set_rate);
 #ifdef CONFIG_PM
 EXPORT_SYMBOL(snd_ac97_resume);
+EXPORT_SYMBOL(snd_ac97_suspend);
 #endif
 
 /*
diff -rup linux-2.6.5/sound/pci/ac97/ac97_patch.c linux/sound/pci/ac97/ac97_patch.c
--- linux-2.6.5/sound/pci/ac97/ac97_patch.c	2004-04-04 05:38:15.000000000 +0200
+++ linux/sound/pci/ac97/ac97_patch.c	2004-04-07 12:53:40.000000000 +0200
@@ -1027,6 +1027,8 @@ int patch_ad1985(ac97_t * ac97)
 			     AC97_AD198X_MSPLT |
 			     AC97_AD198X_AC97NC);
 	ac97->flags |= AC97_STEREO_MUTES;
+	/* on AD1985 rev. 3, AC'97 revision bits are zero */
+	ac97->ext_id = (ac97->ext_id & ~AC97_EI_REV_MASK) | AC97_EI_REV_23;
 	return 0;
 }
 
diff -rup linux-2.6.5/sound/pci/ac97/ac97_pcm.c linux/sound/pci/ac97/ac97_pcm.c
--- linux-2.6.5/sound/pci/ac97/ac97_pcm.c	2004-04-04 05:36:24.000000000 +0200
+++ linux/sound/pci/ac97/ac97_pcm.c	2004-04-07 12:53:40.000000000 +0200
@@ -210,7 +210,7 @@ static int set_spdif_rate(ac97_t *ac97, 
 	}
 
 	spin_lock(&ac97->reg_lock);
-	old = ac97->regs[reg] & mask;
+	old = snd_ac97_read(ac97, reg) & mask;
 	spin_unlock(&ac97->reg_lock);
 	if (old != bits) {
 		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
diff -rup linux-2.6.5/sound/pci/ac97/ac97_proc.c linux/sound/pci/ac97/ac97_proc.c
--- linux-2.6.5/sound/pci/ac97/ac97_proc.c	2004-04-04 05:38:25.000000000 +0200
+++ linux/sound/pci/ac97/ac97_proc.c	2004-04-07 12:53:40.000000000 +0200
@@ -34,6 +34,40 @@
  * proc interface
  */
 
+static void snd_ac97_proc_read_functions(ac97_t *ac97, snd_info_buffer_t *buffer)
+{
+	int header = 0, function;
+	unsigned short info, sense_info;
+	static const char *function_names[12] = {
+		"Master Out", "AUX Out", "Center/LFE Out", "SPDIF Out",
+		"Phone In", "Mic 1", "Mic 2", "Line In", "CD In", "Video In",
+		"Aux In", "Mono Out"
+	};
+	static const char *locations[8] = {
+		"Rear I/O Panel", "Front Panel", "Motherboard", "Dock/External",
+		"reserved", "reserved", "reserved", "NC/unused"
+	};
+
+	for (function = 0; function < 12; ++function) {
+		snd_ac97_write(ac97, AC97_FUNC_SELECT, function << 1);
+		info = snd_ac97_read(ac97, AC97_FUNC_INFO);
+		if (!(info & 0x0001))
+			continue;
+		if (!header) {
+			snd_iprintf(buffer, "\n                    Gain     Inverted  Buffer delay  Location\n");
+			header = 1;
+		}
+		sense_info = snd_ac97_read(ac97, AC97_SENSE_INFO);
+		snd_iprintf(buffer, "%-17s: %3d.%d dBV    %c      %2d/fs         %s\n",
+			    function_names[function],
+			    (info & 0x8000 ? -1 : 1) * ((info & 0x7000) >> 12) * 3 / 2,
+			    ((info & 0x0800) >> 11) * 5,
+			    info & 0x0400 ? 'X' : '-',
+			    (info & 0x03e0) >> 5,
+			    locations[sense_info >> 13]);
+	}
+}
+
 static void snd_ac97_proc_read_main(ac97_t *ac97, snd_info_buffer_t * buffer, int subidx)
 {
 	char name[64];
@@ -47,6 +81,21 @@ static void snd_ac97_proc_read_main(ac97
 	if ((ac97->scaps & AC97_SCAP_AUDIO) == 0)
 		goto __modem;
 
+	if ((ac97->ext_id & AC97_EI_REV_MASK) >= AC97_EI_REV_23) {
+		val = snd_ac97_read(ac97, AC97_INT_PAGING);
+		snd_ac97_update_bits(ac97, AC97_INT_PAGING,
+				     AC97_PAGE_MASK, AC97_PAGE_1);
+		tmp = snd_ac97_read(ac97, AC97_CODEC_CLASS_REV);
+		snd_iprintf(buffer, "Revision         : 0x%02x\n", tmp & 0xff);
+		snd_iprintf(buffer, "Compat. Class    : 0x%02x\n", (tmp >> 8) & 0x1f);
+		snd_iprintf(buffer, "Subsys. Vendor ID: 0x%04x\n",
+			    snd_ac97_read(ac97, AC97_PCI_SVID));
+		snd_iprintf(buffer, "Subsys. ID       : 0x%04x\n\n",
+			    snd_ac97_read(ac97, AC97_PCI_SID));
+		snd_ac97_update_bits(ac97, AC97_INT_PAGING,
+				     AC97_PAGE_MASK, val & AC97_PAGE_MASK);
+	}
+
 	// val = snd_ac97_read(ac97, AC97_RESET);
 	val = ac97->caps;
 	snd_iprintf(buffer, "Capabilities     :%s%s%s%s%s%s\n",
@@ -185,6 +234,14 @@ static void snd_ac97_proc_read_main(ac97
 			}
 		}
 	}
+	if ((ac97->ext_id & AC97_EI_REV_MASK) >= AC97_EI_REV_23) {
+		val = snd_ac97_read(ac97, AC97_INT_PAGING);
+		snd_ac97_update_bits(ac97, AC97_INT_PAGING,
+				     AC97_PAGE_MASK, AC97_PAGE_1);
+		snd_ac97_proc_read_functions(ac97, buffer);
+		snd_ac97_update_bits(ac97, AC97_INT_PAGING,
+				     AC97_PAGE_MASK, val & AC97_PAGE_MASK);
+	}
 
 
       __modem:
diff -rup linux-2.6.5/sound/pci/ali5451/ali5451.c linux/sound/pci/ali5451/ali5451.c
--- linux-2.6.5/sound/pci/ali5451/ali5451.c	2004-04-04 05:38:17.000000000 +0200
+++ linux/sound/pci/ali5451/ali5451.c	2004-04-14 11:56:27.000000000 +0200
@@ -25,8 +25,6 @@
  *
  */
 
-#define __SNDRV_OSS_COMPAT__
-
 #include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
@@ -34,12 +32,12 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/info.h>
 #include <sound/ac97_codec.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Matt Wu <Matt_Wu@acersoftech.com.cn>");
@@ -53,20 +51,21 @@ static char *id[SNDRV_CARDS] = SNDRV_DEF
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
 static int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 32};
 static int spdif[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for ALI M5451 PCI Audio.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for ALI M5451 PCI Audio.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable ALI 5451 PCI Audio.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(pcm_channels, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(pcm_channels, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_channels, "PCM Channels");
 MODULE_PARM_SYNTAX(pcm_channels, SNDRV_ENABLED ",default:32,allows:{{1,32}}");
-MODULE_PARM(spdif, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(spdif, bool, boot_devs, 0444);
 MODULE_PARM_DESC(spdif, "Support SPDIF I/O");
 MODULE_PARM_SYNTAX(spdif, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 
@@ -1906,14 +1905,18 @@ static int __devinit snd_ali_mixer(ali_t
 }
 
 #ifdef CONFIG_PM
-static void ali_suspend(ali_t *chip)
+static int ali_suspend(snd_card_t *card, unsigned int state)
 {
+	ali_t *chip = snd_magic_cast(ali_t, card->pm_private_data, return -EINVAL);
 	ali_image_t *im;
 	int i, j;
 
 	im = chip->image;
 	if (! im)
-		return;
+		return 0;
+
+	snd_pcm_suspend_all(chip->pcm);
+	snd_ac97_suspend(chip->ac97);
 
 	spin_lock_irq(&chip->reg_lock);
 	
@@ -1940,16 +1943,18 @@ static void ali_suspend(ali_t *chip)
 	outl(0xffffffff, ALI_REG(chip, ALI_STOP));
 
 	spin_unlock_irq(&chip->reg_lock);
+	return 0;
 }
 
-static void ali_resume(ali_t *chip)
+static int ali_resume(snd_card_t *card, unsigned int state)
 {
+	ali_t *chip = snd_magic_cast(ali_t, card->pm_private_data, return -EINVAL);
 	ali_image_t *im;
 	int i, j;
 
 	im = chip->image;
 	if (! im)
-		return;
+		return 0;
 
 	pci_enable_device(chip->pci);
 
@@ -1967,27 +1972,15 @@ static void ali_resume(ali_t *chip)
 		outl(im->regs[i], ALI_REG(chip, i*4));
 	}
 	
-	snd_ac97_resume(chip->ac97);
-	
 	// start HW channel
 	outl(im->regs[ALI_START >> 2], ALI_REG(chip, ALI_START));
 	// restore IRQ enable bits
 	outl(im->regs[ALI_MISCINT >> 2], ALI_REG(chip, ALI_MISCINT));
 	
 	spin_unlock_irq(&chip->reg_lock);
-	return;
-}
 
-static int snd_ali_suspend(struct pci_dev *dev, u32 state)
-{
-	ali_t *chip = snd_magic_cast(ali_t, pci_get_drvdata(dev), return -ENXIO);
-	ali_suspend(chip);
-	return 0;
-}
-static int snd_ali_resume(struct pci_dev *dev)
-{
-	ali_t *chip = snd_magic_cast(ali_t, pci_get_drvdata(dev), return -ENXIO);
-	ali_resume(chip);
+	snd_ac97_resume(chip->ac97);
+	
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -2203,7 +2196,9 @@ static int __devinit snd_ali_create(snd_
 #ifdef CONFIG_PM
 	codec->image = kmalloc(sizeof(*codec->image), GFP_KERNEL);
 	if (! codec->image)
-		snd_printk("can't allocate apm buffer\n");
+		snd_printk(KERN_WARNING "can't allocate apm buffer\n");
+	else
+		snd_card_set_pm_callback(card, ali_suspend, ali_resume, codec);
 #endif
 
 	snd_ali_enable_address_interrupt(codec);
@@ -2263,16 +2258,14 @@ static int __devinit snd_ali_probe(struc
 		snd_card_free(card);
 		return err;
 	}
-	pci_set_drvdata(pci, codec);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
 static void __devexit snd_ali_remove(struct pci_dev *pci)
 {
-	ali_t *chip = snd_magic_cast(ali_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -2281,23 +2274,12 @@ static struct pci_driver driver = {
 	.id_table = snd_ali_ids,
 	.probe = snd_ali_probe,
 	.remove = __devexit_p(snd_ali_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_ali_suspend,
-	.resume = snd_ali_resume,
-#endif
+	SND_PCI_PM_CALLBACKS
 };                                
 
 static int __init alsa_card_ali_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "ALi pci audio not found or device busy.\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_ali_exit(void)
@@ -2307,25 +2289,3 @@ static void __exit alsa_card_ali_exit(vo
 
 module_init(alsa_card_ali_init)
 module_exit(alsa_card_ali_exit)
-
-#ifndef MODULE
-
-/* format is: snd-ali5451=enable,index,id,pcm_channels */
-
-static int __init alsa_card_ali_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pcm_channels[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-ali5451=", alsa_card_ali_setup);
-
-#endif /* ifndef */
diff -rup linux-2.6.5/sound/pci/als4000.c linux/sound/pci/als4000.c
--- linux-2.6.5/sound/pci/als4000.c	2004-04-04 05:38:17.000000000 +0200
+++ linux/sound/pci/als4000.c	2004-04-13 13:02:19.000000000 +0200
@@ -64,13 +64,13 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
 #include <sound/sb.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Bart Hartgers <bart@etpmod.phys.tue.nl>");
@@ -89,18 +89,19 @@ static int enable[SNDRV_CARDS] = SNDRV_D
 #ifdef SUPPORT_JOYSTICK
 static int joystick_port[SNDRV_CARDS];
 #endif
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for ALS4000 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for ALS4000 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable ALS4000 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_INDEX_DESC);
 #ifdef SUPPORT_JOYSTICK
-MODULE_PARM(joystick_port, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick_port, int, boot_devs, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address for ALS4000 soundcard. (0 = disabled)");
 MODULE_PARM_SYNTAX(joystick_port, SNDRV_ENABLED);
 #endif
@@ -755,15 +756,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_als4000_init(void)
 {
-	int err;
-	
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "no ALS4000 based soundcards found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_als4000_exit(void)
@@ -773,28 +766,3 @@ static void __exit alsa_card_als4000_exi
 
 module_init(alsa_card_als4000_init)
 module_exit(alsa_card_als4000_exit)
-
-#ifndef MODULE
-
-/* format is: snd-als4000=enable,index,id,joystick_port */
-
-static int __init alsa_card_als4000_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2
-#ifdef SUPPORT_JOYSTICK
-	       && get_option(&str,&joystick_port[nr_dev]) == 2
-#endif
-	       );
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-als4000=", alsa_card_als4000_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/atiixp.c linux/sound/pci/atiixp.c
--- linux-2.6.5/sound/pci/atiixp.c	2004-04-04 05:37:23.000000000 +0200
+++ linux/sound/pci/atiixp.c	2004-04-13 13:03:13.000000000 +0200
@@ -26,12 +26,12 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/info.h>
 #include <sound/ac97_codec.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
@@ -45,20 +45,21 @@
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int ac97_clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 48000};
 static int spdif_aclink[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for ATI IXP controller.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for ATI IXP controller.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable audio part of ATI IXP controller.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(ac97_clock, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ac97_clock, int, boot_devs, 0444);
 MODULE_PARM_DESC(ac97_clock, "AC'97 codec clock (default 48000Hz).");
 MODULE_PARM_SYNTAX(ac97_clock, SNDRV_ENABLED ",default:48000");
-MODULE_PARM(spdif_aclink, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(spdif_aclink, bool, boot_devs, 0444);
 MODULE_PARM_DESC(spdif_aclink, "S/PDIF over AC-link.");
 MODULE_PARM_SYNTAX(spdif_aclink, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
 
@@ -246,9 +247,10 @@
 	snd_pcm_substream_t *substream;	/* assigned PCM substream */
 	unsigned int buf_addr, buf_bytes;	/* DMA buffer address, bytes */
 	unsigned int period_bytes, periods;
+	int opened;
 	int running;
-	struct ac97_pcm *pcm;
 	int pcm_open_flag;
+	int ac97_pcm_type;	/* index # of ac97_pcm to access, -1 = not used */
 };
 
 /*
@@ -270,19 +272,23 @@
 	spinlock_t ac97_lock;
 
 	atiixp_dma_t dmas[3];		/* playback, capture, spdif */
+	struct ac97_pcm *pcms[3];	/* playback, capture, spdif */
 
 	int max_channels;		/* max. channels for PCM out */
 
 	unsigned int codec_not_ready_bits;	/* for codec detection */
 
 	int spdif_over_aclink;		/* passed from the module option */
+	struct semaphore open_mutex;	/* playback open mutex */
 };
 
 
 /*
  */
 static struct pci_device_id snd_atiixp_ids[] = {
-	{ 0x1002, 0x4341, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ 0x1002, 0x4341, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* SB200 */
+	{ 0x1002, 0x4361, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, /* SB300 */
+	{ 0, }
 };
 
 MODULE_DEVICE_TABLE(pci, snd_atiixp_ids);
@@ -393,7 +399,7 @@
 		addr += period_bytes;
 	}
 
-	writel(cpu_to_le32((u32)dma->desc_buf.addr | ATI_REG_LINKPTR_EN),
+	writel((u32)dma->desc_buf.addr | ATI_REG_LINKPTR_EN,
 	       chip->remap_addr + dma->ops->llp_offset);
 
 	dma->period_bytes = period_bytes;
@@ -452,7 +458,9 @@
 			return data >> ATI_REG_PHYS_IN_DATA_SHIFT;
 		udelay(1);
 	} while (--timeout);
-	snd_printk(KERN_WARNING "atiixp: codec read timeout\n");
+	/* time out may happen during reset */
+	if (reg < 0x7c)
+		snd_printk(KERN_WARNING "atiixp: codec read timeout (reg %x)\n", reg);
 	return 0xffff;
 }
 
@@ -585,12 +593,16 @@
 {
 	unsigned int reg;
 
-	/* enable burst mode */
+	/* set up spdif, enable burst mode */
 	reg = atiixp_read(chip, CMD);
 	reg |= 0x02 << ATI_REG_CMD_SPDF_THRESHOLD_SHIFT;
 	reg |= ATI_REG_CMD_BURST_EN;
 	atiixp_write(chip, CMD, reg);
 
+	reg = atiixp_read(chip, SPDF_CMD);
+	reg &= ~(ATI_REG_SPDF_CMD_LFSR|ATI_REG_SPDF_CMD_SINGLE_CH);
+	atiixp_write(chip, SPDF_CMD, reg);
+
 	/* clear all interrupt source */
 	atiixp_write(chip, ISR, 0xffffffff);
 	/* enable irqs */
@@ -657,7 +669,7 @@
 {
 	if (! dma->substream || ! dma->running)
 		return;
-	snd_printd(KERN_DEBUG "atiixp: XRUN detected (DMA %d)\n", dma->ops->type);
+	snd_printdd("atiixp: XRUN detected (DMA %d)\n", dma->ops->type);
 	snd_pcm_stop(dma->substream, SNDRV_PCM_STATE_XRUN);
 }
 
@@ -800,15 +812,10 @@
 {
 	unsigned int data;
 	data = atiixp_read(chip, CMD);
-	if (on) {
+	if (on)
 		data |= ATI_REG_CMD_SPDF_OUT_EN;
-		if (chip->spdif_over_aclink)
-			data |= ATI_REG_CMD_SEND_EN;
-	}  else {
+	else
 		data &= ~ATI_REG_CMD_SPDF_OUT_EN;
-		if (chip->spdif_over_aclink)
-			data &= ~ATI_REG_CMD_SEND_EN;
-	}
 	atiixp_write(chip, CMD, data);
 }
 
@@ -835,25 +842,27 @@
 static int snd_atiixp_spdif_prepare(snd_pcm_substream_t *substream)
 {
 	atiixp_t *chip = snd_pcm_substream_chip(substream);
-	unsigned int data;
 
 	spin_lock(&chip->reg_lock);
 	if (chip->spdif_over_aclink) {
+		unsigned int data;
 		/* enable slots 10/11 */
 		atiixp_update(chip, CMD, ATI_REG_CMD_SPDF_CONFIG_MASK,
 			      ATI_REG_CMD_SPDF_CONFIG_01);
-		data = atiixp_read(chip, OUT_DMA_SLOT);
+		data = atiixp_read(chip, OUT_DMA_SLOT) & ~ATI_REG_OUT_DMA_SLOT_MASK;
 		data |= ATI_REG_OUT_DMA_SLOT_BIT(10) |
 			ATI_REG_OUT_DMA_SLOT_BIT(11);
 		data |= 0x04 << ATI_REG_OUT_DMA_THRESHOLD_SHIFT;
 		atiixp_write(chip, OUT_DMA_SLOT, data);
+		atiixp_update(chip, CMD, ATI_REG_CMD_INTERLEAVE_OUT,
+			      substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE ?
+			      ATI_REG_CMD_INTERLEAVE_OUT : 0);
 	} else {
 		atiixp_update(chip, CMD, ATI_REG_CMD_SPDF_CONFIG_MASK, 0);
+		atiixp_update(chip, CMD, ATI_REG_CMD_INTERLEAVE_SPDF,
+			      substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE ?
+			      ATI_REG_CMD_INTERLEAVE_SPDF : 0);
 	}
-
-	atiixp_update(chip, CMD, ATI_REG_CMD_INTERLEAVE_SPDF,
-		      substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE ?
-		      ATI_REG_CMD_INTERLEAVE_SPDF : 0);
 	spin_unlock(&chip->reg_lock);
 	return 0;
 }
@@ -938,17 +947,18 @@
 	if (err < 0)
 		return err;
 
-	if (dma->pcm) {
+	if (dma->ac97_pcm_type >= 0) {
+		struct ac97_pcm *pcm = chip->pcms[dma->ac97_pcm_type];
 		/* PCM is bound to AC97 codec(s)
 		 * set up the AC97 codecs
 		 */
 		if (dma->pcm_open_flag) {
-			snd_ac97_pcm_close(dma->pcm);
+			snd_ac97_pcm_close(pcm);
 			dma->pcm_open_flag = 0;
 		}
-		err = snd_ac97_pcm_open(dma->pcm, params_rate(hw_params),
+		err = snd_ac97_pcm_open(pcm, params_rate(hw_params),
 					params_channels(hw_params),
-					dma->pcm->r[0].slots);
+					pcm->r[0].slots);
 		if (err >= 0)
 			dma->pcm_open_flag = 1;
 	}
@@ -962,7 +972,8 @@
 	atiixp_dma_t *dma = (atiixp_dma_t *)substream->runtime->private_data;
 
 	if (dma->pcm_open_flag) {
-		snd_ac97_pcm_close(dma->pcm);
+		struct ac97_pcm *pcm = chip->pcms[dma->ac97_pcm_type];
+		snd_ac97_pcm_close(pcm);
 		dma->pcm_open_flag = 0;
 	}
 	atiixp_clear_dma_packets(chip, dma, substream);
@@ -992,7 +1003,7 @@
 	.periods_max =		ATI_MAX_DESCRIPTORS,
 };
 
-static int snd_atiixp_pcm_open(snd_pcm_substream_t *substream, atiixp_dma_t *dma)
+static int snd_atiixp_pcm_open(snd_pcm_substream_t *substream, atiixp_dma_t *dma, int pcm_type)
 {
 	atiixp_t *chip = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
@@ -1001,10 +1012,13 @@
 
 	snd_assert(dma->ops && dma->ops->enable_dma, return -EINVAL);
 
+	if (dma->opened)
+		return -EBUSY;
 	dma->substream = substream;
 	runtime->hw = snd_atiixp_pcm_hw;
-	if (dma->pcm) {
-		runtime->hw.rates = dma->pcm->rates;
+	dma->ac97_pcm_type = pcm_type;
+	if (pcm_type >= 0) {
+		runtime->hw.rates = chip->pcms[pcm_type]->rates;
 		snd_pcm_limit_hw_rates(runtime);
 	} else {
 		/* SPDIF */
@@ -1019,6 +1033,7 @@
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	dma->ops->enable_dma(chip, 1);
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	dma->opened = 1;
 
 	return 0;
 }
@@ -1032,6 +1047,7 @@
 	dma->ops->enable_dma(chip, 0);
 	spin_unlock_irq(&chip->reg_lock);
 	dma->substream = NULL;
+	dma->opened = 0;
 	return 0;
 }
 
@@ -1042,26 +1058,33 @@
 	atiixp_t *chip = snd_pcm_substream_chip(substream);
 	int err;
 
-	err = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_PLAYBACK]);
+	down(&chip->open_mutex);
+	err = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_PLAYBACK], 0);
+	up(&chip->open_mutex);
+	if (err < 0)
+		return err;
 	substream->runtime->hw.channels_max = chip->max_channels;
 	if (chip->max_channels > 2)
 		/* channels must be even */
 		snd_pcm_hw_constraint_step(substream->runtime, 0,
 					   SNDRV_PCM_HW_PARAM_CHANNELS, 2);
-
 	return 0;
 }
 
 static int snd_atiixp_playback_close(snd_pcm_substream_t *substream)
 {
 	atiixp_t *chip = snd_pcm_substream_chip(substream);
-	return snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_PLAYBACK]);
+	int err;
+	down(&chip->open_mutex);
+	err = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_PLAYBACK]);
+	up(&chip->open_mutex);
+	return err;
 }
 
 static int snd_atiixp_capture_open(snd_pcm_substream_t *substream)
 {
 	atiixp_t *chip = snd_pcm_substream_chip(substream);
-	return snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_CAPTURE]);
+	return snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_CAPTURE], 1);
 }
 
 static int snd_atiixp_capture_close(snd_pcm_substream_t *substream)
@@ -1073,13 +1096,27 @@
 static int snd_atiixp_spdif_open(snd_pcm_substream_t *substream)
 {
 	atiixp_t *chip = snd_pcm_substream_chip(substream);
-	return snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_SPDIF]);
+	int err;
+	down(&chip->open_mutex);
+	if (chip->spdif_over_aclink) /* share DMA_PLAYBACK */
+		err = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_PLAYBACK], 2);
+	else
+		err = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_SPDIF], -1);
+	up(&chip->open_mutex);
+	return err;
 }
 
 static int snd_atiixp_spdif_close(snd_pcm_substream_t *substream)
 {
 	atiixp_t *chip = snd_pcm_substream_chip(substream);
-	return snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_SPDIF]);
+	int err;
+	down(&chip->open_mutex);
+	if (chip->spdif_over_aclink)
+		err = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_PLAYBACK]);
+	else
+		err = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_SPDIF]);
+	up(&chip->open_mutex);
+	return err;
 }
 
 /* AC97 playback */
@@ -1188,7 +1225,8 @@
 	/* initialize constants */
 	chip->dmas[ATI_DMA_PLAYBACK].ops = &snd_atiixp_playback_dma_ops;
 	chip->dmas[ATI_DMA_CAPTURE].ops = &snd_atiixp_capture_dma_ops;
-	chip->dmas[ATI_DMA_SPDIF].ops = &snd_atiixp_spdif_dma_ops;
+	if (! chip->spdif_over_aclink)
+		chip->dmas[ATI_DMA_SPDIF].ops = &snd_atiixp_spdif_dma_ops;
 
 	/* assign AC97 pcm */
 	if (chip->spdif_over_aclink)
@@ -1198,6 +1236,8 @@
 	err = snd_ac97_pcm_assign(pbus, num_pcms, atiixp_pcm_defs);
 	if (err < 0)
 		return err;
+	for (i = 0; i < num_pcms; i++)
+		chip->pcms[i] = &pbus->pcms[i];
 
 	chip->max_channels = 2;
 	if (pbus->pcms[0].r[0].slots & (1 << AC97_SLOT_PCM_SLEFT)) {
@@ -1207,11 +1247,6 @@
 			chip->max_channels = 4;
 	}
 
-	chip->dmas[ATI_DMA_PLAYBACK].pcm = &pbus->pcms[0];
-	chip->dmas[ATI_DMA_CAPTURE].pcm = &pbus->pcms[1];
-	if (chip->spdif_over_aclink)
-		chip->dmas[ATI_DMA_SPDIF].pcm = &pbus->pcms[2];
-
 	/* PCM #0: analog I/O */
 	err = snd_pcm_new(chip->card, "ATI IXP AC97", 0, 1, 1, &pcm);
 	if (err < 0)
@@ -1225,9 +1260,13 @@
 					      snd_dma_pci_data(chip->pci), 64*1024, 128*1024);
 
 	/* no SPDIF support on codec? */
-	if (chip->dmas[ATI_DMA_SPDIF].pcm && ! chip->dmas[ATI_DMA_SPDIF].pcm->rates)
+	if (chip->pcms[2] && ! chip->pcms[2]->rates)
 		return 0;
 		
+	/* FIXME: non-48k sample rate doesn't work on my test machine with AD1888 */
+	if (chip->pcms[2])
+		chip->pcms[2]->rates = SNDRV_PCM_RATE_48000;
+
 	/* PCM #1: spdif playback */
 	err = snd_pcm_new(chip->card, "ATI IXP IEC958", 1, 1, 0, &pcm);
 	if (err < 0)
@@ -1272,10 +1311,12 @@
 		snd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_CAPTURE]);
 	else if (status & ATI_REG_ISR_IN_STATUS)
 		snd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_CAPTURE]);
-	if (status & ATI_REG_ISR_SPDF_XRUN)
-		snd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_SPDIF]);
-	else if (status & ATI_REG_ISR_SPDF_STATUS)
-		snd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_SPDIF]);
+	if (! chip->spdif_over_aclink) {
+		if (status & ATI_REG_ISR_SPDF_XRUN)
+			snd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_SPDIF]);
+		else if (status & ATI_REG_ISR_SPDF_STATUS)
+			snd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_SPDIF]);
+	}
 
 	/* for codec detection */
 	if (status & CODEC_CHECK_BITS) {
@@ -1412,6 +1453,7 @@
 
 	spin_lock_init(&chip->reg_lock);
 	spin_lock_init(&chip->ac97_lock);
+	init_MUTEX(&chip->open_mutex);
 	chip->card = card;
 	chip->pci = pci;
 	chip->irq = -1;
@@ -1497,7 +1539,7 @@
 	if ((err = snd_card_register(card)) < 0)
 		goto __error;
 
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 
@@ -1508,9 +1550,7 @@
 
 static void __devexit snd_atiixp_remove(struct pci_dev *pci)
 {
-	atiixp_t *chip = snd_magic_cast(atiixp_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -1524,16 +1564,7 @@
 
 static int __init alsa_card_atiixp_init(void)
 {
-	int err;
-
-        if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "ATI IXP AC97 controller not found or device busy\n");
-#endif
-                return err;
-        }
-
-        return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_atiixp_exit(void)
@@ -1543,27 +1574,3 @@
 
 module_init(alsa_card_atiixp_init)
 module_exit(alsa_card_atiixp_exit)
-
-#ifndef MODULE
-
-/* format is: snd-atiixp=enable,index,id,ac97_clock,spdif_aclink */
-
-static int __init alsa_card_atiixp_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&ac97_clock[nr_dev]) == 2 &&
-	       get_option(&str,&spdif_aclink[nr_dev]) == 2
-	       );
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-atiixp=", alsa_card_atiixp_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/au88x0/au8810.h linux/sound/pci/au88x0/au8810.h
--- linux-2.6.5/sound/pci/au88x0/au8810.h	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/pci/au88x0/au8810.h	2004-04-13 17:28:56.000000000 +0200
@@ -7,7 +7,7 @@
 #define CARD_NAME "Aureal Advantage 3D Sound Processor"
 #define CARD_NAME_SHORT "au8810"
 
-#define NR_ADB		0x20
+#define NR_ADB		0x10
 #define NR_WT		0x00
 #define NR_SRC		0x10
 #define NR_A3D		0x10
@@ -51,13 +51,14 @@
 /* ADB */
 #define VORTEX_ADB_SR 0x28400	/* Samplerates enable/disable */
 #define VORTEX_ADB_RTBASE 0x28000
-#define VORTEX_ADB_RTBASE_SIZE (VORTEX_ADB_CHNBASE - VORTEX_ADB_RTBASE)
+#define VORTEX_ADB_RTBASE_COUNT 173
 #define VORTEX_ADB_CHNBASE 0x282b4
-#define VORTEX_ADB_CHNBASE_SIZE (ADB_MASK - VORTEX_ADB_RTBASE_SIZE)
+#define VORTEX_ADB_CHNBASE_COUNT 24
 #define 	ROUTE_MASK	0xffff
 #define		SOURCE_MASK	0xff00
 #define     ADB_MASK   0xff
 #define		ADB_SHIFT 0x8
+
 /* ADB address */
 #define		OFFSET_ADBDMA	0x00
 #define		OFFSET_SRCIN	0x40
@@ -69,10 +70,12 @@
 #define		OFFSET_SPORTIN	0x78	/* ch 0x13 */
 #define		OFFSET_SPORTOUT	0x90
 #define		OFFSET_SPDIFOUT	0x92	/* ch 0x14 check this! */
-#define		OFFSET_EQIN		0xa0
+#define		OFFSET_EQIN	0xa0
 #define		OFFSET_EQOUT	0x7e	/* 2 routes on ch 0x11 */
 #define		OFFSET_XTALKOUT	0x66	/* crosstalk canceller (source) */
 #define		OFFSET_XTALKIN	0x96	/* crosstalk canceller (sink) */
+#define		OFFSET_A3DIN	0x70	/* ADB sink. */
+#define		OFFSET_A3DOUT	0xA6	/* ADB source. 2 routes per slice = 8 */
 #define		OFFSET_EFXIN	0x80	/* ADB sink. */
 #define		OFFSET_EFXOUT	0x68	/* ADB source. */
 
@@ -89,8 +92,8 @@
 #define ADB_SPDIFOUT(x)	(x + OFFSET_SPDIFOUT)
 #define ADB_EQIN(x) (x + OFFSET_EQIN)
 #define ADB_EQOUT(x) (x + OFFSET_EQOUT)
-#define ADB_A3DOUT(x) (x + 0x50)	/* A3D blocks */
-#define ADB_A3DIN(x) (x + 0x70)
+#define ADB_A3DOUT(x) (x + OFFSET_A3DOUT)	/* 0x10 A3D blocks */
+#define ADB_A3DIN(x) (x + OFFSET_A3DIN)
 #define ADB_XTALKIN(x) (x + OFFSET_XTALKIN)
 #define ADB_XTALKOUT(x) (x + OFFSET_XTALKOUT)
 
@@ -120,20 +123,31 @@
 #define		VOL_MAX 0x7f	/* FIXME: Not confirmed! Just guessed. */
 
 /* SRC */
-#define VORTEX_SRCBLOCK_SR	0x26cc0
-#define VORTEX_SRC_CHNBASE	0x26c40
-#define VORTEX_SRC_RTBASE	0x26c00
-#define VORTEX_SRC_SOURCE	0x26cc4
-#define VORTEX_SRC_SOURCESIZE 0x26cc8
-#define VORTEX_SRC_CONVRATIO 0x26e40
-#define VORTEX_SRC_DRIFT0	0x26e80
-#define VORTEX_SRC_DRIFT1	0x26ec0
-#define VORTEX_SRC_DRIFT2	0x26f40
-#define VORTEX_SRC_U0		0x26e00
-#define VORTEX_SRC_U1		0x26f00
-#define VORTEX_SRC_U2		0x26f80
-#define VORTEX_SRC_DATA		0x26800	/* 0xc800 */
-#define VORTEX_SRC_DATA0	0x26000
+#define VORTEX_SRC_CHNBASE		0x26c40
+#define VORTEX_SRC_RTBASE		0x26c00
+#define VORTEX_SRCBLOCK_SR		0x26cc0
+#define VORTEX_SRC_SOURCE		0x26cc4
+#define VORTEX_SRC_SOURCESIZE	0x26cc8
+/* Params
+	0x26e00	: 1 U0
+	0x26e40	: 2 CR
+	0x26e80	: 3 U3
+	0x26ec0	: 4 DRIFT1
+	0x26f00 : 5 U1
+	0x26f40	: 6 DRIFT2
+	0x26f80	: 7 U2 : Target rate, direction
+*/
+
+#define VORTEX_SRC_CONVRATIO	0x26e40
+#define VORTEX_SRC_DRIFT0		0x26e80
+#define VORTEX_SRC_DRIFT1		0x26ec0
+#define VORTEX_SRC_DRIFT2		0x26f40
+#define VORTEX_SRC_U0			0x26e00
+#define		U0_SLOWLOCK		0x200
+#define VORTEX_SRC_U1			0x26f00
+#define VORTEX_SRC_U2			0x26f80
+#define VORTEX_SRC_DATA			0x26800	/* 0xc800 */
+#define VORTEX_SRC_DATA0		0x26000
 
 /* FIFO */
 #define VORTEX_FIFO_ADBCTRL 0x16100	/* Control bits. */
@@ -150,33 +164,37 @@
 //#define       FIFO_MASK       0x1f    /* at shift left 0xb */
 //#define               FIFO_SIZE       0x20
 #define 	FIFO_BITS	0x03880000
-#define VORTEX_FIFO_ADBDATA 0x14000
-#define VORTEX_FIFO_WTDATA 0x10000
+#define VORTEX_FIFO_ADBDATA	0x14000
+#define VORTEX_FIFO_WTDATA	0x10000
 
 /* CODEC */
-#define VORTEX_CODEC_CTRL 0x29184
-#define VORTEX_CODEC_EN 0x29190
+#define VORTEX_CODEC_CTRL	0x29184
+#define VORTEX_CODEC_EN		0x29190
 #define		EN_CODEC0	0x00000300
+#define 	EN_AC98		0x00000c00 /* Modem AC98 slots. */
 #define		EN_CODEC1	0x00003000
 #define		EN_CODEC	(EN_CODEC0 | EN_CODEC1)
 #define		EN_SPORT	0x00030000
 #define		EN_SPDIF	0x000c0000
-#define VORTEX_CODEC_CHN 0x29080
-#define VORTEX_CODEC_WRITE 0x00800000
-#define VORTEX_CODEC_ADDSHIFT 16
-#define VORTEX_CODEC_ADDMASK 0x7f0000	/* 0x000f0000 */
-#define VORTEX_CODEC_DATSHIFT 0
-#define VORTEX_CODEC_DATMASK 0xffff
-#define VORTEX_CODEC_IO 0x29188
+
+#define VORTEX_CODEC_CHN 	0x29080
+#define VORTEX_CODEC_WRITE	0x00800000
+#define VORTEX_CODEC_ADDSHIFT 	16
+#define VORTEX_CODEC_ADDMASK	0x7f0000	/* 0x000f0000 */
+#define VORTEX_CODEC_DATSHIFT	0
+#define VORTEX_CODEC_DATMASK	0xffff
+#define VORTEX_CODEC_IO		0x29188
 
 /* SPDIF */
-#define VORTEX_SPDIF_FLAGS		0x2205c
-#define VORTEX_SPDIF_CFG0		0x291D0
-#define VORTEX_SPDIF_CFG1		0x291D4
+#define VORTEX_SPDIF_FLAGS	0x2205c
+#define VORTEX_SPDIF_CFG0	0x291D0
+#define VORTEX_SPDIF_CFG1	0x291D4
 #define VORTEX_SPDIF_SMPRATE	0x29194
 
 /* Sample timer */
-#define VORTEX_SMP_TIME  0x29198
+#define VORTEX_SMP_TIME		0x29198
+
+#define VORTEX_MODEM_CTRL	0x291ac
 
 /* IRQ */
 #define VORTEX_IRQ_SOURCE 0x2a000	/* Interrupt source flags. */
@@ -193,19 +211,19 @@
 #define 	CTRL_IRQ_ENABLE	0x00004000
 
 /* write: Timer period config / read: TIMER IRQ ack. */
-#define VORTEX_IRQ_STAT 0x2919c
+#define VORTEX_IRQ_STAT		0x2919c
 
 /* DMA */
-#define VORTEX_ENGINE_CTRL 0x27ae8
-#define 	ENGINE_INIT 0x1380000
+#define VORTEX_ENGINE_CTRL	0x27ae8
+#define 	ENGINE_INIT	0x1380000
 
-		     /* MIDI *//* GAME. */
-#define VORTEX_MIDI_DATA 0x28800
-#define VORTEX_MIDI_CMD 0x28804	/* Write command / Read status */
+/* MIDI *//* GAME. */
+#define VORTEX_MIDI_DATA	0x28800
+#define VORTEX_MIDI_CMD		0x28804	/* Write command / Read status */
 
-#define VORTEX_CTRL2 0x2880c
+#define VORTEX_CTRL2		0x2880c
 #define		CTRL2_GAME_ADCMODE 0x40
-#define VORTEX_GAME_LEGACY 0x28808
-#define VORTEX_GAME_AXIS 0x28810
+#define VORTEX_GAME_LEGACY	0x28808
+#define VORTEX_GAME_AXIS	0x28810
 #define		AXIS_SIZE 4
 #define		AXIS_RANGE 0x1fff
diff -rup linux-2.6.5/sound/pci/au88x0/au8820.h linux/sound/pci/au88x0/au8820.h
--- linux-2.6.5/sound/pci/au88x0/au8820.h	2004-04-04 05:36:24.000000000 +0200
+++ linux/sound/pci/au88x0/au8820.h	2004-04-13 17:28:56.000000000 +0200
@@ -48,9 +48,9 @@
 /* ADB */
 #define VORTEX_ADB_SR 0x10a00	/* Samplerates enable/disable */
 #define VORTEX_ADB_RTBASE 0x10800
-#define VORTEX_ADB_RTBASE_SIZE (VORTEX_ADB_CHNBASE - VORTEX_ADB_RTBASE)
+#define VORTEX_ADB_RTBASE_COUNT 103
 #define VORTEX_ADB_CHNBASE 0x1099c
-#define VORTEX_ADB_CHNBASE_SIZE (ADB_MASK - VORTEX_ADB_RTBASE_SIZE)
+#define VORTEX_ADB_CHNBASE_COUNT 22
 #define 	ROUTE_MASK	0x3fff
 #define     ADB_MASK   0x7f
 #define		ADB_SHIFT 0x7
diff -rup linux-2.6.5/sound/pci/au88x0/au8830.h linux/sound/pci/au88x0/au8830.h
--- linux-2.6.5/sound/pci/au88x0/au8830.h	2004-04-04 05:36:57.000000000 +0200
+++ linux/sound/pci/au88x0/au8830.h	2004-04-13 17:28:56.000000000 +0200
@@ -45,7 +45,7 @@
 #define VORTEX_ADBDMA_START 0x27c00	/* Which subbuffer starts */
 
 #define VORTEX_ADBDMA_STATUS 0x27A90	/* stored at AdbDma->this_10 / 2 DWORD in size. */
-/* Starting at MSB, each pair seem to be the current DMA page. */
+/* Starting at the MSB, each pair of bits seem to be the current DMA page. */
 /* This current page bits are consistent (same value) with VORTEX_ADBDMA_STAT) */
 
 /* DMA */
@@ -65,9 +65,9 @@
 /* ADB */
 #define VORTEX_ADB_SR 0x28400	/* Samplerates enable/disable */
 #define VORTEX_ADB_RTBASE 0x28000
-#define VORTEX_ADB_RTBASE_SIZE (VORTEX_ADB_CHNBASE - VORTEX_ADB_RTBASE)
+#define VORTEX_ADB_RTBASE_COUNT 173
 #define VORTEX_ADB_CHNBASE 0x282b4
-#define VORTEX_ADB_CHNBASE_SIZE (ADB_MASK - VORTEX_ADB_RTBASE_SIZE)
+#define VORTEX_ADB_CHNBASE_COUNT 24
 #define 	ROUTE_MASK	0xffff
 #define		SOURCE_MASK	0xff00
 #define     ADB_MASK   0xff
@@ -147,7 +147,7 @@
 #define VORTEX_SRC_RTBASE		0x26c00
 #define VORTEX_SRCBLOCK_SR		0x26cc0
 #define VORTEX_SRC_SOURCE		0x26cc4
-#define VORTEX_SRC_SOURCESIZE	0x26cc4
+#define VORTEX_SRC_SOURCESIZE	0x26cc8
 /* Params
 	0x26e00	: 1 U0
 	0x26e40	: 2 CR
diff -rup linux-2.6.5/sound/pci/au88x0/au88x0.c linux/sound/pci/au88x0/au88x0.c
--- linux-2.6.5/sound/pci/au88x0/au88x0.c	2004-04-04 05:37:07.000000000 +0200
+++ linux/sound/pci/au88x0/au88x0.c	2004-04-13 17:28:56.000000000 +0200
@@ -19,7 +19,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
-#define SNDRV_GET_ID
+#include <linux/moduleparam.h>
 #include <sound/initval.h>
 
 // module parameters (see "Module Parameters")
@@ -27,17 +27,18 @@ static int index[SNDRV_CARDS] = SNDRV_DE
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
 static int pcifix[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 255 };
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(pcifix, "1-255i");
+module_param_array(pcifix, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcifix, "Enable VIA-workaround for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(pcifix,
 		   SNDRV_ENABLED
@@ -48,80 +49,72 @@ MODULE_CLASSES("{sound}");
 MODULE_LICENSE("GPL");
 MODULE_DEVICES("{{Aureal Semiconductor Inc., Aureal Vortex Sound Processor}}");
 
-#ifndef MODULE
-/* format is: snd-mychip=enable,index,id */
-static int __init alsa_card_vortex_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str, &enable[nr_dev]) == 2 &&
-	       get_option(&str, &index[nr_dev]) == 2 &&
-	       get_id(&str, &id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-au88x0=", alsa_card_vortex_setup);
-#endif				/* ifndef MODULE */
-
 MODULE_DEVICE_TABLE(pci, snd_vortex_ids);
 
-static void __devinit snd_vortex_workaround(struct pci_dev *vortex, int fix)
+static void vortex_fix_latency(struct pci_dev *vortex)
 {
-	struct pci_dev *via = NULL;
 	int rc;
-
-	/* autodetect if workarounds are required */
-	while ((via = pci_find_device(PCI_VENDOR_ID_VIA,
-				      PCI_DEVICE_ID_VIA_8365_1, via))) {
-		if (fix == 255) {
+	if (!(rc = pci_write_config_byte(vortex, 0x40, 0xff))) {
 			printk(KERN_INFO CARD_NAME
-			       ": detected VIA KT133/KM133. activating workaround...\n");
-			fix = 3;	// do latency and via bridge workaround
-		}
-		break;
+			       ": vortex latency is 0xff\n");
+	} else {
+		printk(KERN_WARNING CARD_NAME
+				": could not set vortex latency: pci error 0x%x\n", rc);
 	}
+}
 
-	/* do not do anything if autodetection was enabled and found no VIA */
-	if (fix == 255)
-		return;
+static void vortex_fix_agp_bridge(struct pci_dev *via)
+{
+	int rc;
+	u8 value;
 
-	/* fix vortex latency */
-	if (fix & 0x01) {
-		if (!(rc = pci_write_config_byte(vortex, 0x40, 0xff))) {
-			printk(KERN_INFO CARD_NAME
-			       ": vortex latency is 0xff\n");
-		} else {
-			printk(KERN_WARNING CARD_NAME
-			       ": could not set vortex latency: pci error 0x%x\n",
-			       rc);
-		}
+	/*
+	 * only set the bit (Extend PCI#2 Internal Master for
+	 * Efficient Handling of Dummy Requests) if the can
+	 * read the config and it is not already set
+	 */
+
+	if (!(rc = pci_read_config_byte(via, 0x42, &value))
+			&& ((value & 0x10)
+				|| !(rc = pci_write_config_byte(via, 0x42, value | 0x10)))) {
+		printk(KERN_INFO CARD_NAME
+				": bridge config is 0x%x\n", value | 0x10);
+	} else {
+		printk(KERN_WARNING CARD_NAME
+				": could not set vortex latency: pci error 0x%x\n", rc);
 	}
+}
 
-	/* fix via agp bridge */
-	if (via && (fix & 0x02)) {
-		u8 value;
-
-		/*
-		 * only set the bit (Extend PCI#2 Internal Master for
-		 * Efficient Handling of Dummy Requests) if the can
-		 * read the config and it is not already set
-		 */
-
-		if (!(rc = pci_read_config_byte(via, 0x42, &value))
-		    && ((value & 0x10)
-			|| !(rc =
-			     pci_write_config_byte(via, 0x42, value | 0x10)))) {
+static void __devinit snd_vortex_workaround(struct pci_dev *vortex, int fix)
+{
+	struct pci_dev *via;
 
-			printk(KERN_INFO CARD_NAME
-			       ": bridge config is 0x%x\n", value | 0x10);
-		} else {
-			printk(KERN_WARNING CARD_NAME
-			       ": could not set vortex latency: pci error 0x%x\n",
-			       rc);
+	/* autodetect if workarounds are required */
+	if (fix == 255) {
+		/* VIA KT133 */
+		via = pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8365_1, NULL);
+		/* VIA Apollo */
+		if (via == NULL) {
+			via = pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C598_1, NULL);
+		}
+		/* AMD Irongate */
+		if (via == NULL) {
+			via = pci_find_device(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_FE_GATE_7007, NULL);
 		}
+		if (via) {
+			printk(KERN_INFO CARD_NAME ": Activating latency workaround...\n");
+			vortex_fix_latency(vortex);
+			vortex_fix_agp_bridge(via);
+		}
+	} else {
+		if (fix & 0x1)
+			vortex_fix_latency(vortex);
+		if ((fix & 0x2) && (via = pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8365_1, NULL)))
+			vortex_fix_agp_bridge(via);
+		if ((fix & 0x4) && (via = pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C598_1, NULL)))
+			vortex_fix_agp_bridge(via);
+		if ((fix & 0x8) && (via = pci_find_device(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_FE_GATE_7007, NULL)))
+			vortex_fix_agp_bridge(via);
 	}
 }
 
@@ -370,7 +363,7 @@ snd_vortex_probe(struct pci_dev *pci, co
 		return err;
 	}
 	// (7)
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	vortex_connect_default(chip, 1);
 	vortex_enable_int(chip);
@@ -380,16 +373,8 @@ snd_vortex_probe(struct pci_dev *pci, co
 // destructor -- see "Destructor" sub-section
 static void __devexit snd_vortex_remove(struct pci_dev *pci)
 {
-	vortex_t *vortex = snd_magic_cast(vortex_t,
-					  pci_get_drvdata(pci), return);
-
-	if (vortex) {
-		// Release ALSA stuff.
-		snd_card_free(vortex->card);
-		// Free Vortex struct.
-		pci_set_drvdata(pci, NULL);
-	} else
-		printk("snd_vortex_remove called more than one time!\n");
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
 }
 
 // pci_driver definition
@@ -403,16 +388,7 @@ static struct pci_driver driver = {
 // initialization of the module
 static int __init alsa_card_vortex_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Aureal soundcard not found "
-		       "or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 // clean up the module
diff -rup linux-2.6.5/sound/pci/au88x0/au88x0.h linux/sound/pci/au88x0/au88x0.h
--- linux-2.6.5/sound/pci/au88x0/au88x0.h	2004-04-04 05:37:23.000000000 +0200
+++ linux/sound/pci/au88x0/au88x0.h	2004-04-13 17:33:17.000000000 +0200
@@ -17,6 +17,7 @@
 #ifndef __SOUND_AU88X0_H
 #define __SOUND_AU88X0_H
 
+#ifdef __KERNEL__
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/pci.h>
@@ -28,6 +29,8 @@
 #include <sound/hwdep.h>
 #include <sound/ac97_codec.h>
 
+#endif
+
 #ifndef CHIP_AU8820
 #include "au88x0_eq.h"
 #include "au88x0_a3d.h"
@@ -69,20 +72,19 @@
 #define IRQ_MODEM	0x4000
 
 /* ADB Resource */
-#define VORTEX_RESOURCE_DMA		0x00000000
-#define VORTEX_RESOURCE_SRC		0x00000001
+#define VORTEX_RESOURCE_DMA	0x00000000
+#define VORTEX_RESOURCE_SRC	0x00000001
 #define VORTEX_RESOURCE_MIXIN	0x00000002
 #define VORTEX_RESOURCE_MIXOUT	0x00000003
-#define VORTEX_RESOURCE_A3D		0x00000004
+#define VORTEX_RESOURCE_A3D	0x00000004
 #define VORTEX_RESOURCE_LAST	0x00000005
 
 /* Check for SDAC bit in "Extended audio ID" AC97 register */
-#define VORTEX_IS_QUAD(x) ((x->codec == NULL) ?  0 : (x->codec->ext_id|0x80))
+#define VORTEX_IS_QUAD(x) ((x->codec == NULL) ?  0 : (x->codec->ext_id&0x80))
 /* Check if chip has bug. */
 #define IS_BAD_CHIP(x) (\
-	(x->rev < 3 && x->device == PCI_DEVICE_ID_AUREAL_VORTEX) || \
-	(x->rev < 0xfe && x->device == PCI_DEVICE_ID_AUREAL_VORTEX2) || \
-	(x->rev < 0xfe && x->device == PCI_DEVICE_ID_AUREAL_ADVANTAGE))
+	(x->rev == 0xfe && x->device == PCI_DEVICE_ID_AUREAL_VORTEX2) || \
+	(x->rev == 0xfe && x->device == PCI_DEVICE_ID_AUREAL_ADVANTAGE))
 
 
 /* PCM devices */
diff -rup linux-2.6.5/sound/pci/au88x0/au88x0_a3d.c linux/sound/pci/au88x0/au88x0_a3d.c
--- linux-2.6.5/sound/pci/au88x0/au88x0_a3d.c	2004-04-04 05:37:07.000000000 +0200
+++ linux/sound/pci/au88x0/au88x0_a3d.c	2004-04-13 17:28:56.000000000 +0200
@@ -617,6 +617,12 @@ static void vortex_Vort3D(vortex_t * v, 
 static void vortex_Vort3D_connect(vortex_t * v, int en)
 {
 	int i;
+	
+// Disable AU8810 routes, since they seem to be wrong (in au8810.h).
+#ifdef CHIP_AU8810
+	return;
+#endif
+	
 #if 1
 	/* Alloc Xtalk mixin resources */
 	v->mixxtlk[0] =
diff -rup linux-2.6.5/sound/pci/au88x0/au88x0_core.c linux/sound/pci/au88x0/au88x0_core.c
--- linux-2.6.5/sound/pci/au88x0/au88x0_core.c	2004-04-04 05:38:16.000000000 +0200
+++ linux/sound/pci/au88x0/au88x0_core.c	2004-04-13 17:28:56.000000000 +0200
@@ -72,6 +72,7 @@
             into au88x0_pcm.c .
  06-06-2003 Buffer shifter bugfix. Mixer volume fix.
  07-12-2003 A3D routing finally fixed. Believed to be OK.
+ 25-03-2004 Many thanks to Claudia, for such valuable bug reports.
  
 */
 
@@ -772,7 +773,9 @@ vortex_src_delWTD(vortex_t * vortex, uns
 	return 1;
 }
 
- /*FIFO*/ static void
+ /*FIFO*/ 
+
+static void
 vortex_fifo_clearadbdata(vortex_t * vortex, int fifo, int x)
 {
 	for (x--; x >= 0; x--)
@@ -1345,31 +1348,29 @@ vortex_wtdma_setbuffers(vortex_t * vorte
 	dma->nr_periods = count;
 	dma->sgbuf = sgbuf;
 
-	psize--;
-
 	dma->cfg0 = 0;
 	dma->cfg1 = 0;
 	switch (count) {
 		/* Four or more pages */
 	default:
 	case 4:
-		dma->cfg1 |= 0x88000000 | 0x44000000 | 0x30000000 | psize;
-		hwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4),
+		dma->cfg1 |= 0x88000000 | 0x44000000 | 0x30000000 | (psize-1);
+		hwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4) + 0xc,
 			snd_sgbuf_get_addr(sgbuf, psize * 3));
 		/* 3 pages */
 	case 3:
 		dma->cfg0 |= 0x12000000;
-		dma->cfg1 |= 0x80000000 | 0x40000000 | (psize << 0xc);
-		hwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4),
+		dma->cfg1 |= 0x80000000 | 0x40000000 | ((psize-1) << 0xc);
+		hwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4)  + 0x8,
 			snd_sgbuf_get_addr(sgbuf, psize * 2));
 		/* 2 pages */
 	case 2:
-		dma->cfg0 |= 0x88000000 | 0x44000000 | 0x10000000 | psize;
-		hwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4),
+		dma->cfg0 |= 0x88000000 | 0x44000000 | 0x10000000 | (psize-1);
+		hwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4) + 0x4,
 			snd_sgbuf_get_addr(sgbuf, psize));
 		/* 1 page */
 	case 1:
-		dma->cfg0 |= 0x80000000 | 0x40000000 | (psize << 0xc);
+		dma->cfg0 |= 0x80000000 | 0x40000000 | ((psize-1) << 0xc);
 		hwwrite(vortex->mmio, VORTEX_WTDMA_BUFBASE + (wtdma << 4),
 			snd_sgbuf_get_addr(sgbuf, 0));
 		break;
@@ -1575,11 +1576,11 @@ static void vortex_adb_init(vortex_t * v
 	/* it looks like we are writing more than we need to...
 	 * if we write what we are supposed to it breaks things... */
 	hwwrite(vortex->mmio, VORTEX_ADB_SR, 0);
-	for (i = 0; i < VORTEX_ADB_RTBASE_SIZE; i++)
+	for (i = 0; i < VORTEX_ADB_RTBASE_COUNT; i++)
 		hwwrite(vortex->mmio, VORTEX_ADB_RTBASE + (i << 2),
 			hwread(vortex->mmio,
 			       VORTEX_ADB_RTBASE + (i << 2)) | ROUTE_MASK);
-	for (i = 0; i < VORTEX_ADB_CHNBASE_SIZE; i++) {
+	for (i = 0; i < VORTEX_ADB_CHNBASE_COUNT; i++) {
 		hwwrite(vortex->mmio, VORTEX_ADB_CHNBASE + (i << 2),
 			hwread(vortex->mmio,
 			       VORTEX_ADB_CHNBASE + (i << 2)) | ROUTE_MASK);
@@ -1922,6 +1923,9 @@ vortex_connect_codecplay(vortex_t * vort
 	// Connect front channels through EQ.
 	vortex_connection_mix_adb(vortex, en, 0x11, mixers[0], ADB_EQIN(0));
 	vortex_connection_mix_adb(vortex, en, 0x11, mixers[1], ADB_EQIN(1));
+	/* Lower volume, since EQ has some gain. */
+	vortex_mix_setvolumebyte(vortex, mixers[0], 0);
+	vortex_mix_setvolumebyte(vortex, mixers[1], 0);
 	vortex_route(vortex, en, 0x11, ADB_EQOUT(0), ADB_CODECOUT(0));
 	vortex_route(vortex, en, 0x11, ADB_EQOUT(1), ADB_CODECOUT(1));
 
@@ -2007,9 +2011,11 @@ vortex_adb_checkinout(vortex_t * vortex,
 }
 
 /* Default Connections  */
+static int
+vortex_adb_allocroute(vortex_t * vortex, int dma, int nr_ch, int dir, int type);
+
 static void vortex_connect_default(vortex_t * vortex, int en)
 {
-	// FIXME: check if checkout was succesful.
 	// Connect AC97 codec.
 	vortex->mixplayb[0] = vortex_adb_checkinout(vortex, vortex->fixed_res, en,
 				  VORTEX_RESOURCE_MIXOUT);
@@ -2044,7 +2050,7 @@ static void vortex_connect_default(vorte
 #ifndef CHIP_AU8810
 	vortex_wt_connect(vortex, en);
 #endif
-	// A3D (crosstalk canceler and A3D slices).
+	// A3D (crosstalk canceler and A3D slices). AU8810 disabled for now.
 #ifndef CHIP_AU8820
 	vortex_Vort3D_connect(vortex, en);
 #endif
@@ -2053,18 +2059,7 @@ static void vortex_connect_default(vorte
 	// Connect DSP interface for SQ3500 turbo (not here i think...)
 
 	// Connect AC98 modem codec
- 	
- 	/* Fast Play Workaround. Revision 0xFE does not seem to need it. */
- 	printk(KERN_INFO "vortex: revision = 0x%x, device = %d\n", vortex->rev, vortex->device);
- 	if (IS_BAD_CHIP(vortex)) {
- 		printk(KERN_INFO "vortex: Erratum workaround enabled.\n");
- #ifndef CHIP_AU8820
- 		vortex->fixed_res[VORTEX_RESOURCE_DMA] = 0x00000001;
- #endif
- 		// Channel swapping workaround. We are nuking registers somewhere, or
- 		// its a hardware bug.
- 		vortex->fixed_res[VORTEX_RESOURCE_SRC] = 0x00000001;
- 	}
+	
 }
 
 /*
@@ -2081,7 +2076,7 @@ vortex_adb_allocroute(vortex_t * vortex,
 {
 	stream_t *stream;
 	int i, en;
-
+	
 	if ((nr_ch == 3)
 	    || ((dir == SNDRV_PCM_STREAM_CAPTURE) && (nr_ch > 2)))
 		return -EBUSY;
@@ -2105,7 +2100,6 @@ vortex_adb_allocroute(vortex_t * vortex,
 	stream->dir = dir;
 	stream->type = type;
 
-	// FIXME: check for success of checkout or checkin.
 	/* PLAYBACK ROUTES. */
 	if (dir == SNDRV_PCM_STREAM_PLAYBACK) {
 		int src[4], mix[4], ch_top;
@@ -2165,8 +2159,7 @@ vortex_adb_allocroute(vortex_t * vortex,
 		for (i = 0; i < nr_ch; i++) {
 			if (stream->type == VORTEX_PCM_ADB) {
 				vortex_connection_adbdma_src(vortex, en,
-							     src[nr_ch - 1], 
-							     //src[0], 
+							     src[nr_ch - 1],
 							     dma,
 							     src[i]);
 				vortex_connection_src_mixin(vortex, en,
@@ -2188,7 +2181,7 @@ vortex_adb_allocroute(vortex_t * vortex,
 #ifndef CHIP_AU8820
 			if (stream->type == VORTEX_PCM_A3D) {
 				vortex_connection_adbdma_src(vortex, en,
-							     src[0], 
+							     src[nr_ch - 1], 
 								 dma,
 							     src[i]);
 				vortex_route(vortex, en, 0x11, ADB_SRCOUT(src[i]), ADB_A3DIN(a3d));
@@ -2237,7 +2230,7 @@ vortex_adb_allocroute(vortex_t * vortex,
 				     ADB_SPDIFOUT(1));
 		}
 #endif
-		/* CAPTURE ROUTES. */
+	/* CAPTURE ROUTES. */
 	} else {
 		int src[2], mix[2];
 
@@ -2271,7 +2264,7 @@ vortex_adb_allocroute(vortex_t * vortex,
 			vortex_connection_mixin_mix(vortex, en,
 						    MIX_CAPT(1), mix[0], 0);
 			vortex_connection_src_adbdma(vortex, en,
-						     src[nr_ch - 1],
+						     src[0],
 						     src[0], dma);
 		} else {
 			vortex_connection_mixin_mix(vortex, en,
@@ -2279,7 +2272,7 @@ vortex_adb_allocroute(vortex_t * vortex,
 			vortex_connection_mix_src(vortex, en, 0x11, mix[1],
 						  src[1]);
 			vortex_connection_src_src_adbdma(vortex, en,
-							 src[0], src[0],
+							 src[1], src[0],
 							 src[1], dma);
 		}
 	}
diff -rup linux-2.6.5/sound/pci/au88x0/au88x0_eq.c linux/sound/pci/au88x0/au88x0_eq.c
--- linux-2.6.5/sound/pci/au88x0/au88x0_eq.c	2004-04-04 05:38:14.000000000 +0200
+++ linux/sound/pci/au88x0/au88x0_eq.c	2004-04-13 17:28:56.000000000 +0200
@@ -710,11 +710,13 @@ static void vortex_Eqlzr_ShutDownA3d(vor
 static void vortex_Eqlzr_SetBypass(vortex_t * vortex, long bp)
 {
 	eqlzr_t *eq = &(vortex->eq);
-
+	
 	if ((eq->this28) && (bp == 0)) {
+		/* EQ enabled */
 		vortex_Eqlzr_SetAllBandsFromActiveCoeffSet(vortex);
 		vortex_EqHw_SetBypassGain(vortex, eq->this08, eq->this08);
 	} else {
+		/* EQ disabled. */
 		vortex_EqHw_SetLeftGainsTarget(vortex, (u16 *) (eq->this14));
 		vortex_EqHw_SetRightGainsTarget(vortex, (u16 *) (eq->this14));
 		vortex_EqHw_SetBypassGain(vortex, eq->this0c, eq->this0c);
diff -rup linux-2.6.5/sound/pci/au88x0/au88x0_game.c linux/sound/pci/au88x0/au88x0_game.c
--- linux-2.6.5/sound/pci/au88x0/au88x0_game.c	2004-04-04 05:36:18.000000000 +0200
+++ linux/sound/pci/au88x0/au88x0_game.c	2004-04-13 17:28:56.000000000 +0200
@@ -41,8 +41,6 @@
 
 #define VORTEX_GAME_DWAIT	20	/* 20 ms */
 
-static struct gameport gameport;
-
 static unsigned char vortex_game_read(struct gameport *gameport)
 {
 	vortex_t *vortex = gameport->driver;
@@ -97,8 +95,10 @@ static int vortex_game_open(struct gamep
 
 static int vortex_gameport_register(vortex_t * vortex)
 {
-	vortex->gameport = &gameport;
-
+	if ((vortex->gameport = snd_kcalloc(sizeof(struct gameport), GFP_KERNEL)) == NULL) {
+		return -1;
+	};
+	
 	vortex->gameport->driver = vortex;
 	vortex->gameport->fuzz = 64;
 
@@ -117,8 +117,10 @@ static int vortex_gameport_register(vort
 
 static int vortex_gameport_unregister(vortex_t * vortex)
 {
-	if (vortex->gameport != NULL)
+	if (vortex->gameport != NULL) {
 		gameport_unregister_port(vortex->gameport);
+		kfree(vortex->gameport);
+	}
 	return 0;
 }
 
diff -rup linux-2.6.5/sound/pci/au88x0/au88x0_pcm.c linux/sound/pci/au88x0/au88x0_pcm.c
--- linux-2.6.5/sound/pci/au88x0/au88x0_pcm.c	2004-04-04 05:37:06.000000000 +0200
+++ linux/sound/pci/au88x0/au88x0_pcm.c	2004-04-13 17:28:56.000000000 +0200
@@ -18,8 +18,7 @@
  * Vortex PCM ALSA driver.
  *
  * Supports ADB and WT DMA. Unfortunately, WT channels do not run yet.
- * It remains stuck,and DMA transfers do not happen.
- *
+ * It remains stuck,and DMA transfers do not happen. 
  */
 
 #include <sound/driver.h>
@@ -124,7 +123,7 @@ static int snd_vortex_pcm_open(snd_pcm_s
 	vortex_t *vortex = snd_pcm_substream_chip(substream);
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	int err;
-
+	
 	/* Force equal size periods */
 	if ((err =
 	     snd_pcm_hw_constraint_integer(runtime,
@@ -232,12 +231,13 @@ snd_vortex_pcm_hw_params(snd_pcm_substre
 	}
 #ifndef CHIP_AU8810
 	else {
-		/*if (stream != NULL)
+		/* if (stream != NULL)
 		   vortex_wt_allocroute(chip, substream->number, 0); */
 		vortex_wt_allocroute(chip, substream->number,
 				     params_channels(hw_params));
 		stream = substream->runtime->private_data =
 		    &chip->dma_wt[substream->number];
+		stream->dma = substream->number;
 		stream->substream = substream;
 		vortex_wtdma_setbuffers(chip, substream->number, sgbuf,
 					params_period_bytes(hw_params),
@@ -325,7 +325,7 @@ static int snd_vortex_pcm_trigger(snd_pc
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 		// do something to stop the PCM engine
-		//printk(KERN_INFO "vortex: stop %d\n", dma)
+		//printk(KERN_INFO "vortex: stop %d\n", dma);
 		stream->fifo_enabled = 0;
 		if (VORTEX_PCM_TYPE(substream->pcm) != VORTEX_PCM_WT)
 			vortex_adbdma_pausefifo(chip, dma);
@@ -502,18 +502,13 @@ static int __devinit snd_vortex_new_pcm(
 	if (idx == VORTEX_PCM_ADB)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
 				&snd_vortex_playback_ops);
-
+	
 	/* pre-allocation of Scatter-Gather buffers */
 	
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
-										  snd_dma_pci_data(chip->pci_dev),
-										  0x10000, 0x10000);
-	
-	// The above should be used, as soon as ALSA gets updated.
-	/*
-	snd_pcm_lib_preallocate_sg_pages_for_all(chip->pci_dev, pcm,
-						 0x10000, 0x10000);
-	*/
+					      snd_dma_pci_data(chip->pci_dev),
+					      0x10000, 0x10000);
+
 	if (VORTEX_PCM_TYPE(pcm) == VORTEX_PCM_SPDIF) {
 		snd_kcontrol_t *kcontrol;
 
diff -rup linux-2.6.5/sound/pci/au88x0/au88x0_synth.c linux/sound/pci/au88x0/au88x0_synth.c
--- linux-2.6.5/sound/pci/au88x0/au88x0_synth.c	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/pci/au88x0/au88x0_synth.c	2004-04-13 17:28:57.000000000 +0200
@@ -36,6 +36,7 @@ static int vortex_wt_SetReg(vortex_t * v
 
 /* WT */
 
+/* Put 2 WT channels together for one stereo interlaced channel. */
 static void vortex_wt_setstereo(vortex_t * vortex, u32 wt, u32 stereo)
 {
 	int temp;
@@ -47,6 +48,7 @@ static void vortex_wt_setstereo(vortex_t
 	hwwrite(vortex->mmio, WT_STEREO(wt), temp);
 }
 
+/* Join to mixdown route. */
 static void vortex_wt_setdsout(vortex_t * vortex, u32 wt, int en)
 {
 	int temp;
@@ -60,7 +62,7 @@ static void vortex_wt_setdsout(vortex_t 
 	hwwrite(vortex->mmio, WT_DSREG((wt >= 0x20) ? 1 : 0), temp);
 }
 
-// WT routing is still a mistery.
+/* Setup WT route. */
 static int vortex_wt_allocroute(vortex_t * vortex, int wt, int nr_ch)
 {
 	wt_voice_t *voice = &(vortex->wt_voice[wt]);
@@ -68,13 +70,15 @@ static int vortex_wt_allocroute(vortex_t
 
 	//FIXME: WT audio routing.
 	if (nr_ch) {
-		vortex_fifo_wtinitialize(vortex, wt, 2);
+		vortex_fifo_wtinitialize(vortex, wt, 1);
 		vortex_fifo_setwtvalid(vortex, wt, 1);
 		vortex_wt_setstereo(vortex, wt, nr_ch - 1);
 	} else
 		vortex_fifo_setwtvalid(vortex, wt, 0);
-
-	vortex_wt_setdsout(vortex, wt, 0);
+	
+	/* Set mixdown mode. */
+	vortex_wt_setdsout(vortex, wt, 1);
+	/* Set other parameter registers. */
 	hwwrite(vortex->mmio, WT_SRAMP(0), 0x880000);
 	//hwwrite(vortex->mmio, WT_GMODE(0), 0xffffffff);
 #ifdef CHIP_AU8830
@@ -87,7 +91,7 @@ static int vortex_wt_allocroute(vortex_t
 
 	temp = hwread(vortex->mmio, WT_PARM(wt, 3));
 	printk("vortex: WT PARM3: %x\n", temp);
-	hwwrite(vortex->mmio, WT_PARM(wt, 3), temp);
+	//hwwrite(vortex->mmio, WT_PARM(wt, 3), temp);
 
 	hwwrite(vortex->mmio, WT_DELAY(wt, 0), 0);
 	hwwrite(vortex->mmio, WT_DELAY(wt, 1), 0);
@@ -106,6 +110,7 @@ static int vortex_wt_allocroute(vortex_t
 	return 0;
 }
 
+
 static void vortex_wt_connect(vortex_t * vortex, int en)
 {
 	int i, ii, mix;
@@ -129,15 +134,12 @@ static void vortex_wt_connect(vortex_t *
 				     ADB_WTOUT(i, ii + 0x20), ADB_MIXIN(mix));
 
 			vortex_connection_mixin_mix(vortex, en, mix,
-						    vortex->mixplayb[ii %
-								     2], 0);
+						    vortex->mixplayb[ii % 2], 0);
 			if (VORTEX_IS_QUAD(vortex))
 				vortex_connection_mixin_mix(vortex, en,
 							    mix,
-							    vortex->
-							    mixplayb[2 +
-								     (ii %
-								      2)], 0);
+							    vortex->mixplayb[2 +
+								     (ii % 2)], 0);
 		}
 	}
 	for (i = 0; i < NR_WT; i++) {
@@ -155,7 +157,7 @@ static int vortex_wt_GetReg(vortex_t * v
 		return hwread(vortex->mmio, WT_PARM(wt, 3));
 	}
 	if (reg == 7) {
-		return hwread(vortex->mmio, WT_GMODE(wt));
+		return hwread(vortex->mmio, WT_GMODE(wt));;
 	}
 
 	return 0;
diff -rup linux-2.6.5/sound/pci/azt3328.c linux/sound/pci/azt3328.c
--- linux-2.6.5/sound/pci/azt3328.c	2004-04-04 05:37:23.000000000 +0200
+++ linux/sound/pci/azt3328.c	2004-04-13 13:03:59.000000000 +0200
@@ -98,13 +98,13 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include "azt3328.h"
 
@@ -166,18 +166,19 @@ static int enable[SNDRV_CARDS] = SNDRV_D
 #ifdef SUPPORT_JOYSTICK
 static int joystick[SNDRV_CARDS];
 #endif
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for AZF3328 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for AZF3328 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable AZF3328 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_INDEX_DESC);
 #ifdef SUPPORT_JOYSTICK
-MODULE_PARM(joystick, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick, bool, boot_devs, 0444);
 MODULE_PARM_DESC(joystick, "Enable joystick for AZF3328 soundcard.");
 MODULE_PARM_SYNTAX(joystick, SNDRV_BOOLEAN_FALSE_DESC);
 #endif
@@ -1267,6 +1268,10 @@ static int snd_azf3328_free(azf3328_t *c
         if (chip->irq < 0)
                 goto __end_hw;
 
+	/* reset (close) mixer */
+	snd_azf3328_mixer_set_mute(chip, IDX_MIXER_PLAY_MASTER, 1); /* first mute master volume */
+	snd_azf3328_mixer_write(chip, IDX_MIXER_RESET, 0x0, WORD_VALUE);
+
         /* interrupt setup - mask everything */
 	/* FIXME */
 
@@ -1540,7 +1545,7 @@ static int __devinit snd_azf3328_probe(s
 	snd_azf3328_config_joystick(chip, joystick[dev]);
 #endif
 
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 
 	snd_azf3328_dbgcallleave();
@@ -1549,16 +1554,8 @@ static int __devinit snd_azf3328_probe(s
 
 static void __devexit snd_azf3328_remove(struct pci_dev *pci)
 {
-        azf3328_t *chip = snd_magic_cast(azf3328_t, pci_get_drvdata(pci), return);
-	
 	snd_azf3328_dbgcallenter();
-
-	/* reset (close) mixer */
-	snd_azf3328_mixer_set_mute(chip, IDX_MIXER_PLAY_MASTER, 1); /* first mute master volume */
-	snd_azf3328_mixer_write(chip, IDX_MIXER_RESET, 0x0, WORD_VALUE);
-
-        if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 	snd_azf3328_dbgcallleave();
 }
@@ -1573,18 +1570,10 @@ static struct pci_driver driver = {
 static int __init alsa_card_azf3328_init(void)
 {
 	int err;
-	
 	snd_azf3328_dbgcallenter();
-
-	if ((err = pci_module_init(&driver)) < 0)
-	{
-#ifdef MODULE
-		printk(KERN_ERR "azt3328: no AZF3328 based soundcards found or device busy\n");
-#endif
-		return err;
-	}
+	err = pci_module_init(&driver);
 	snd_azf3328_dbgcallleave();
-	return 0;
+	return err;
 }
 
 static void __exit alsa_card_azf3328_exit(void)
@@ -1596,31 +1585,3 @@ static void __exit alsa_card_azf3328_exi
 
 module_init(alsa_card_azf3328_init)
 module_exit(alsa_card_azf3328_exit)
-
-#ifndef MODULE
-
-/* format is: snd-azf3328=enable,index,id,joystick */
-
-static int __init alsa_card_azf3328_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	snd_azf3328_dbgcallenter();
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2
-#ifdef SUPPORT_JOYSTICK
-	       && get_option(&str,&joystick[nr_dev]) == 2
-#endif
-	       );
-	nr_dev++;
-	snd_azf3328_dbgcallleave();
-	return 1;
-}
-
-__setup("snd-azt3328=", alsa_card_azf3328_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/bt87x.c linux/sound/pci/bt87x.c
--- linux-2.6.5/sound/pci/bt87x.c	2004-04-04 05:37:23.000000000 +0200
+++ linux/sound/pci/bt87x.c	2004-04-13 13:04:20.000000000 +0200
@@ -26,13 +26,13 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <asm/io.h>
 #include <asm/bitops.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/control.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
@@ -46,17 +46,18 @@ static int index[SNDRV_CARDS] = SNDRV_DE
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int digital_rate[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 }; /* digital input rate */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Bt87x soundcard");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Bt87x soundcard");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Bt87x soundcard");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(digital_rate, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(digital_rate, int, boot_devs, 0444);
 MODULE_PARM_DESC(digital_rate, "Digital input rate for Bt87x soundcard");
 MODULE_PARM_SYNTAX(digital_rate, SNDRV_ENABLED);
 
@@ -808,7 +809,7 @@ static int __devinit snd_bt87x_probe(str
 	if (err < 0)
 		goto _error;
 
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	++dev;
 	return 0;
 
@@ -819,9 +820,7 @@ _error:
 
 static void __devexit snd_bt87x_remove(struct pci_dev *pci)
 {
-	bt87x_t *chip = snd_magic_cast(bt87x_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -851,16 +850,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_bt87x_init(void)
 {
-	int err;
-
-	err = pci_module_init(&driver);
-	if (err < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Bt87x soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_bt87x_exit(void)
@@ -870,24 +860,3 @@ static void __exit alsa_card_bt87x_exit(
 
 module_init(alsa_card_bt87x_init)
 module_exit(alsa_card_bt87x_exit)
-
-#ifndef MODULE
-
-/* format is: snd-bt87x=enable,index,id */
-
-static int __init alsa_card_bt87x_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-bt87x=", alsa_card_bt87x_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/cmipci.c linux/sound/pci/cmipci.c
--- linux-2.6.5/sound/pci/cmipci.c	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/pci/cmipci.c	2004-04-13 13:04:35.000000000 +0200
@@ -32,6 +32,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
@@ -41,7 +42,6 @@
 #include <sound/opl3.h>
 #include <sound/sb.h>
 #include <sound/asoundef.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
@@ -68,29 +68,30 @@ static int soft_ac3[SNDRV_CARDS] = {[0 .
 #ifdef SUPPORT_JOYSTICK
 static int joystick_port[SNDRV_CARDS];
 #endif
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for C-Media PCI soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for C-Media PCI soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable C-Media PCI soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_ENABLED ",allows:{{0},{0x330},{0x320},{0x310},{0x300}},dialog:list");
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM port.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_ENABLED ",allows:{{0},{0x388},{0x3c8},{0x3e0},{0x3e8}},dialog:list");
 #ifdef DO_SOFT_AC3
-MODULE_PARM(soft_ac3, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(soft_ac3, bool, boot_devs, 0444);
 MODULE_PARM_DESC(soft_ac3, "Sofware-conversion of raw SPDIF packets (model 033 only).");
 MODULE_PARM_SYNTAX(soft_ac3, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
 #endif
 #ifdef SUPPORT_JOYSTICK
-MODULE_PARM(joystick_port, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick_port, int, boot_devs, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 MODULE_PARM_SYNTAX(joystick_port, SNDRV_ENABLED ",allows:{{0},{1},{0x200},{0x201}},dialog:list");
 #endif
@@ -3264,15 +3265,7 @@ static struct pci_driver driver = {
 	
 static int __init alsa_card_cmipci_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "C-Media PCI soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_cmipci_exit(void)
@@ -3282,34 +3275,3 @@ static void __exit alsa_card_cmipci_exit
 
 module_init(alsa_card_cmipci_init)
 module_exit(alsa_card_cmipci_exit)
-
-#ifndef MODULE
-
-/* format is: snd-cmipci=enable,index,id,
-			 mpu_port,fm_port,soft_ac3,joystick_port */
-
-static int __init alsa_card_cmipci_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2
-#ifdef DO_SOFT_AC3
-	       && get_option(&str,&soft_ac3[nr_dev]) == 2
-#endif
-#ifdef SUPPORT_JOYSTICK
-	       && get_option(&str,&joystick_port[nr_dev]) == 2
-#endif
-	       );
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-cmipci=", alsa_card_cmipci_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/cs4281.c linux/sound/pci/cs4281.c
--- linux-2.6.5/sound/pci/cs4281.c	2004-04-04 05:38:18.000000000 +0200
+++ linux/sound/pci/cs4281.c	2004-04-14 11:47:56.000000000 +0200
@@ -27,13 +27,13 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
 #include <sound/ac97_codec.h>
 #include <sound/opl3.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 
@@ -47,17 +47,18 @@ static int index[SNDRV_CARDS] = SNDRV_DE
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
 static int dual_codec[SNDRV_CARDS];	/* dual codec */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for CS4281 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for CS4281 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable CS4281 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(dual_codec, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dual_codec, bool, boot_devs, 0444);
 MODULE_PARM_DESC(dual_codec, "Secondary Codec ID (0 = disabled).");
 MODULE_PARM_SYNTAX(dual_codec, SNDRV_ENABLED ",allows:{{0,3}}");
 
@@ -1395,7 +1396,8 @@ static int snd_cs4281_dev_free(snd_devic
 
 static int snd_cs4281_chip_init(cs4281_t *chip); /* defined below */
 #ifdef CONFIG_PM
-static int snd_cs4281_set_power_state(snd_card_t *card, unsigned int power_state);
+static int cs4281_suspend(snd_card_t *card, unsigned int state);
+static int cs4281_resume(snd_card_t *card, unsigned int state);
 #endif
 
 static int __devinit snd_cs4281_create(snd_card_t * card,
@@ -1461,10 +1463,7 @@ static int __devinit snd_cs4281_create(s
 
 	snd_cs4281_proc_init(chip);
 
-#ifdef CONFIG_PM
-	card->set_power_state = snd_cs4281_set_power_state;
-	card->power_state_private_data = chip;
-#endif
+	snd_card_set_pm_callback(card, cs4281_suspend, cs4281_resume, chip);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_cs4281_free(chip);
@@ -1481,7 +1480,9 @@ static int snd_cs4281_chip_init(cs4281_t
 {
 	unsigned int tmp;
 	int timeout;
+	int retry_count = 2;
 
+      __retry:
 	tmp = snd_cs4281_peekBA0(chip, BA0_CFLR);
 	if (tmp != BA0_CFLR_DEFAULT) {
 		snd_cs4281_pokeBA0(chip, BA0_CFLR, BA0_CFLR_DEFAULT);
@@ -1629,6 +1630,8 @@ static int snd_cs4281_chip_init(cs4281_t
 		snd_cs4281_delay_long();
 	} while (timeout-- > 0);
 
+	if (--retry_count > 0)
+		goto __retry;
 	snd_printk(KERN_ERR "never read ISV3 and ISV4 from AC'97\n");
 	return -EIO;
 
@@ -1999,15 +2002,14 @@ static int __devinit snd_cs4281_probe(st
 		return err;
 	}
 
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
 static void __devexit snd_cs4281_remove(struct pci_dev *pci)
 {
-	cs4281_t *chip = pci_get_drvdata(pci);
-	snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -2036,17 +2038,19 @@ static int saved_regs[SUSPEND_REGISTERS]
 
 #define CLKCR1_CKRA                             0x00010000L
 
-static void cs4281_suspend(cs4281_t *chip)
+static int cs4281_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	cs4281_t *chip = snd_magic_cast(cs4281_t, card->pm_private_data, return -EINVAL);
 	u32 ulCLK;
 	unsigned int i;
 
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
-
 	snd_pcm_suspend_all(chip->pcm);
 
+	if (chip->ac97)
+		snd_ac97_suspend(chip->ac97);
+	if (chip->ac97_secondary)
+		snd_ac97_suspend(chip->ac97_secondary);
+
 	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
 	ulCLK |= CLKCR1_CKRA;
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
@@ -2076,17 +2080,15 @@ static void cs4281_suspend(cs4281_t *chi
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void cs4281_resume(cs4281_t *chip)
+static int cs4281_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	cs4281_t *chip = snd_magic_cast(cs4281_t, card->pm_private_data, return -EINVAL);
 	unsigned int i;
 	u32 ulCLK;
 
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
-
 	pci_enable_device(chip->pci);
 
 	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
@@ -2110,41 +2112,8 @@ static void cs4281_resume(cs4281_t *chip
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-static int snd_cs4281_suspend(struct pci_dev *dev, u32 state)
-{
-	cs4281_t *chip = snd_magic_cast(cs4281_t, pci_get_drvdata(dev), return -ENXIO);
-	cs4281_suspend(chip);
-	return 0;
-}
-static int snd_cs4281_resume(struct pci_dev *dev)
-{
-	cs4281_t *chip = snd_magic_cast(cs4281_t, pci_get_drvdata(dev), return -ENXIO);
-	cs4281_resume(chip);
 	return 0;
 }
-
-/* callback */
-static int snd_cs4281_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	cs4281_t *chip = snd_magic_cast(cs4281_t, card->power_state_private_data, return -ENXIO);
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		cs4281_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		cs4281_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
 #endif /* CONFIG_PM */
 
 static struct pci_driver driver = {
@@ -2152,23 +2121,12 @@ static struct pci_driver driver = {
 	.id_table = snd_cs4281_ids,
 	.probe = snd_cs4281_probe,
 	.remove = __devexit_p(snd_cs4281_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_cs4281_suspend,
-	.resume = snd_cs4281_resume,
-#endif
+	SND_PCI_PM_CALLBACKS
 };
 	
 static int __init alsa_card_cs4281_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "CS4281 soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_cs4281_exit(void)
@@ -2178,24 +2136,3 @@ static void __exit alsa_card_cs4281_exit
 
 module_init(alsa_card_cs4281_init)
 module_exit(alsa_card_cs4281_exit)
-
-#ifndef MODULE
-
-/* format is: snd-cs4281=enable,index,id */
-
-static int __init alsa_card_cs4281_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-cs4281=", alsa_card_cs4281_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/cs46xx/cs46xx.c linux/sound/pci/cs46xx/cs46xx.c
--- linux-2.6.5/sound/pci/cs46xx/cs46xx.c	2004-04-04 05:38:22.000000000 +0200
+++ linux/sound/pci/cs46xx/cs46xx.c	2004-04-13 13:05:00.000000000 +0200
@@ -29,9 +29,9 @@
 #include <linux/pci.h>
 #include <linux/time.h>
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/cs46xx.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -52,23 +52,24 @@ static int enable[SNDRV_CARDS] = SNDRV_D
 static int external_amp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
 static int thinkpad[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
 static int mmap_valid[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for the CS46xx soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for the CS46xx soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable CS46xx soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(external_amp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(external_amp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(external_amp, "Force to enable external amplifer.");
 MODULE_PARM_SYNTAX(external_amp, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
-MODULE_PARM(thinkpad, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(thinkpad, bool, boot_devs, 0444);
 MODULE_PARM_DESC(thinkpad, "Force to enable Thinkpad's CLKRUN control.");
 MODULE_PARM_SYNTAX(thinkpad, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
-MODULE_PARM(mmap_valid, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mmap_valid, bool, boot_devs, 0444);
 MODULE_PARM_DESC(mmap_valid, "Support OSS mmap.");
 MODULE_PARM_SYNTAX(mmap_valid, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
 
@@ -157,31 +158,14 @@ static int __devinit snd_card_cs46xx_pro
 		return err;
 	}
 
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int snd_card_cs46xx_suspend(struct pci_dev *pci, u32 state)
-{
-	cs46xx_t *chip = snd_magic_cast(cs46xx_t, pci_get_drvdata(pci), return -ENXIO);
-	snd_cs46xx_suspend(chip);
-	return 0;
-}
-static int snd_card_cs46xx_resume(struct pci_dev *pci)
-{
-	cs46xx_t *chip = snd_magic_cast(cs46xx_t, pci_get_drvdata(pci), return -ENXIO);
-	snd_cs46xx_resume(chip);
-	return 0;
-}
-#endif
-
 static void __devexit snd_card_cs46xx_remove(struct pci_dev *pci)
 {
-	cs46xx_t *chip = snd_magic_cast(cs46xx_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -190,23 +174,12 @@ static struct pci_driver driver = {
 	.id_table = snd_cs46xx_ids,
 	.probe = snd_card_cs46xx_probe,
 	.remove = __devexit_p(snd_card_cs46xx_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_card_cs46xx_suspend,
-	.resume = snd_card_cs46xx_resume,
-#endif
+	SND_PCI_PM_CALLBACKS
 };
 
 static int __init alsa_card_cs46xx_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Sound Fusion CS46xx soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_cs46xx_exit(void)
@@ -216,27 +189,3 @@ static void __exit alsa_card_cs46xx_exit
 
 module_init(alsa_card_cs46xx_init)
 module_exit(alsa_card_cs46xx_exit)
-
-#ifndef MODULE
-
-/* format is: snd-cs46xx=enable,index,id,mmap_valid,external_amp,thinkpad */
-
-static int __init alsa_card_cs46xx_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&mmap_valid[nr_dev]) == 2 &&
-	       get_option(&str,&external_amp[nr_dev]) == 2 &&
-	       get_option(&str,&thinkpad[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-cs46xx=", alsa_card_cs46xx_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/cs46xx/cs46xx_lib.c linux/sound/pci/cs46xx/cs46xx_lib.c
--- linux-2.6.5/sound/pci/cs46xx/cs46xx_lib.c	2004-04-04 05:36:17.000000000 +0200
+++ linux/sound/pci/cs46xx/cs46xx_lib.c	2004-04-14 11:52:15.000000000 +0200
@@ -3784,17 +3784,19 @@ static struct cs_card_type __devinitdata
  * APM support
  */
 #ifdef CONFIG_PM
-void snd_cs46xx_suspend(cs46xx_t *chip)
+static int snd_cs46xx_suspend(snd_card_t *card, unsigned int state)
 {
+	cs46xx_t *chip = snd_magic_cast(cs46xx_t, card->pm_private_data, return -EINVAL);
 	int amp_saved;
 
-	snd_card_t *card = chip->card;
-
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
 	snd_pcm_suspend_all(chip->pcm);
 	// chip->ac97_powerdown = snd_cs46xx_codec_read(chip, AC97_POWER_CONTROL);
 	// chip->ac97_general_purpose = snd_cs46xx_codec_read(chip, BA0_AC97_GENERAL_PURPOSE);
+
+	snd_ac97_suspend(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]);
+	if (chip->ac97[CS46XX_SECONDARY_CODEC_INDEX])
+		snd_ac97_suspend(chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]);
+
 	amp_saved = chip->amplifier;
 	/* turn off amp */
 	chip->amplifier_ctrl(chip, -chip->amplifier);
@@ -3803,16 +3805,14 @@ void snd_cs46xx_suspend(cs46xx_t *chip)
 	chip->active_ctrl(chip, -chip->amplifier);
 	chip->amplifier = amp_saved; /* restore the status */
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-void snd_cs46xx_resume(cs46xx_t *chip)
+static int snd_cs46xx_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	cs46xx_t *chip = snd_magic_cast(cs46xx_t, card->pm_private_data, return -EINVAL);
 	int amp_saved;
 
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
-
 	pci_enable_device(chip->pci);
 	amp_saved = chip->amplifier;
 	chip->amplifier = 0;
@@ -3832,6 +3832,8 @@ void snd_cs46xx_resume(cs46xx_t *chip)
 #endif
 
 	snd_ac97_resume(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]);
+	if (chip->ac97[CS46XX_SECONDARY_CODEC_INDEX])
+		snd_ac97_resume(chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]);
 
 	if (amp_saved)
 		chip->amplifier_ctrl(chip, 1); /* turn amp on */
@@ -3839,25 +3841,6 @@ void snd_cs46xx_resume(cs46xx_t *chip)
 		chip->active_ctrl(chip, -1); /* disable CLKRUN */
 	chip->amplifier = amp_saved;
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-static int snd_cs46xx_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	cs46xx_t *chip = snd_magic_cast(cs46xx_t, card->power_state_private_data, return -ENXIO);
-
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		snd_cs46xx_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		snd_cs46xx_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -4010,10 +3993,7 @@ int __devinit snd_cs46xx_create(snd_card
 
 	snd_cs46xx_proc_init(card, chip);
 
-#ifdef CONFIG_PM
-	card->set_power_state = snd_cs46xx_set_power_state;
-	card->power_state_private_data = chip;
-#endif
+	snd_card_set_pm_callback(card, snd_cs46xx_suspend, snd_cs46xx_resume, chip);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_cs46xx_free(chip);
diff -rup linux-2.6.5/sound/pci/cs46xx/dsp_spos.c linux/sound/pci/cs46xx/dsp_spos.c
--- linux-2.6.5/sound/pci/cs46xx/dsp_spos.c	2004-04-04 05:37:59.000000000 +0200
+++ linux/sound/pci/cs46xx/dsp_spos.c	2004-04-07 12:53:54.000000000 +0200
@@ -823,7 +823,7 @@ int cs46xx_dsp_proc_init (snd_card_t * c
 		entry->private_data = chip;
 		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
 		entry->c.text.read_size = 512;
-		entry->c.text.read = cs46xx_dsp_proc_task_tree_read;
+		entry->c.text.read = cs46xx_dsp_proc_task_tree_read;;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;
@@ -836,7 +836,7 @@ int cs46xx_dsp_proc_init (snd_card_t * c
 		entry->private_data = chip;
 		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
 		entry->c.text.read_size = 1024;
-		entry->c.text.read = cs46xx_dsp_proc_scb_read;
+		entry->c.text.read = cs46xx_dsp_proc_scb_read;;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;
diff -rup linux-2.6.5/sound/pci/emu10k1/emu10k1.c linux/sound/pci/emu10k1/emu10k1.c
--- linux-2.6.5/sound/pci/emu10k1/emu10k1.c	2004-04-04 05:36:12.000000000 +0200
+++ linux/sound/pci/emu10k1/emu10k1.c	2004-04-13 13:05:20.000000000 +0200
@@ -23,9 +23,9 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/time.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/emu10k1.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -49,32 +49,33 @@ static int seq_ports[SNDRV_CARDS] = {[0 
 static int max_synth_voices[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 64};
 static int max_buffer_size[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 128};
 static int enable_ir[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for the EMU10K1 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for the EMU10K1 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable the EMU10K1 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(extin, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(extin, int, boot_devs, 0444);
 MODULE_PARM_DESC(extin, "Available external inputs for FX8010. Zero=default.");
 MODULE_PARM_SYNTAX(extin, SNDRV_ENABLED "allows:{{0,0x0ffff}},base:16");
-MODULE_PARM(extout, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(extout, int, boot_devs, 0444);
 MODULE_PARM_DESC(extout, "Available external outputs for FX8010. Zero=default.");
 MODULE_PARM_SYNTAX(extout, SNDRV_ENABLED "allows:{{0,0x0ffff}},base:16");
-MODULE_PARM(seq_ports, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(seq_ports, int, boot_devs, 0444);
 MODULE_PARM_DESC(seq_ports, "Allocated sequencer ports for internal synthesizer.");
 MODULE_PARM_SYNTAX(seq_ports, SNDRV_ENABLED "allows:{{0,32}}");
-MODULE_PARM(max_synth_voices, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(max_synth_voices, int, boot_devs, 0444);
 MODULE_PARM_DESC(max_synth_voices, "Maximum number of voices for WaveTable.");
 MODULE_PARM_SYNTAX(max_synth_voices, SNDRV_ENABLED);
-MODULE_PARM(max_buffer_size, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(max_buffer_size, int, boot_devs, 0444);
 MODULE_PARM_DESC(max_buffer_size, "Maximum sample buffer size in MB.");
 MODULE_PARM_SYNTAX(max_buffer_size, SNDRV_ENABLED);
-MODULE_PARM(enable_ir, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable_ir, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable_ir, "Enable IR.");
 MODULE_PARM_SYNTAX(enable_ir, SNDRV_ENABLE_DESC);
 
@@ -211,15 +212,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_emu10k1_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "EMU10K1/Audigy soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_emu10k1_exit(void)
@@ -229,27 +222,3 @@ static void __exit alsa_card_emu10k1_exi
 
 module_init(alsa_card_emu10k1_init)
 module_exit(alsa_card_emu10k1_exit)
-
-#ifndef MODULE
-
-/* format is: snd-emu10k1=enable,index,id,
-			  seq_ports,max_synth_voices */
-
-static int __init alsa_card_emu10k1_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&seq_ports[nr_dev]) == 2 &&
-	       get_option(&str,&max_synth_voices[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-emu10k1=", alsa_card_emu10k1_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/ens1370.c linux/sound/pci/ens1370.c
--- linux-2.6.5/sound/pci/ens1370.c	2004-04-04 05:37:44.000000000 +0200
+++ linux/sound/pci/ens1370.c	2004-04-13 13:05:35.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
@@ -36,7 +37,6 @@
 #else
 #include <sound/ak4531_codec.h>
 #endif
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/asoundef.h>
 
@@ -86,23 +86,24 @@ static int joystick_port[SNDRV_CARDS];
 static int joystick[SNDRV_CARDS];
 #endif
 #endif
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Ensoniq AudioPCI soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Ensoniq AudioPCI soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Ensoniq AudioPCI soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 #ifdef SUPPORT_JOYSTICK
 #ifdef CHIP1371
-MODULE_PARM(joystick_port, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick_port, int, boot_devs, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 MODULE_PARM_SYNTAX(joystick_port, SNDRV_ENABLED ",allows:{{0},{1},{0x200},{0x208},{0x210},{0x218}},dialog:list");
 #else
-MODULE_PARM(joystick, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick, bool, boot_devs, 0444);
 MODULE_PARM_DESC(joystick, "Enable joystick.");
 MODULE_PARM_SYNTAX(joystick, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 #endif
@@ -2371,15 +2372,7 @@ static struct pci_driver driver = {
 	
 static int __init alsa_card_ens137x_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Ensoniq AudioPCI soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_ens137x_exit(void)
@@ -2389,36 +2382,3 @@ static void __exit alsa_card_ens137x_exi
 
 module_init(alsa_card_ens137x_init)
 module_exit(alsa_card_ens137x_exit)
-
-#ifndef MODULE
-
-/* format is: snd-ens1370=enable,index,id,joystick */
-
-static int __init alsa_card_ens137x_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2
-#ifdef SUPPORT_JOYSTICK
-#ifdef CHIP1371
-	       && get_option(&str,&joystick_port[nr_dev]) == 2
-#else
-	       && get_option(&str,&joystick[nr_dev]) == 2
-#endif
-#endif
-	       );
-	nr_dev++;
-	return 1;
-}
-
-#if defined(CHIP1370)
-__setup("snd-ens1370=", alsa_card_ens137x_setup);
-#elif defined(CHIP1371)
-__setup("snd-ens1371=", alsa_card_ens137x_setup);
-#endif
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/es1938.c linux/sound/pci/es1938.c
--- linux-2.6.5/sound/pci/es1938.c	2004-04-04 05:37:37.000000000 +0200
+++ linux/sound/pci/es1938.c	2004-04-13 13:05:49.000000000 +0200
@@ -53,12 +53,12 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/opl3.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <asm/io.h>
@@ -84,14 +84,15 @@ MODULE_DEVICES("{{ESS,ES1938},"
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for ESS Solo-1 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for ESS Solo-1 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable ESS Solo-1 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 
@@ -1700,15 +1701,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_es1938_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "ESS Solo-1 soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_es1938_exit(void)
@@ -1718,24 +1711,3 @@ static void __exit alsa_card_es1938_exit
 
 module_init(alsa_card_es1938_init)
 module_exit(alsa_card_es1938_exit)
-
-#ifndef MODULE
-
-/* format is: snd-es1938=enable,index,id */
-
-static int __init alsa_card_es1938_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-es1938=", alsa_card_es1938_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/es1968.c linux/sound/pci/es1968.c
--- linux-2.6.5/sound/pci/es1968.c	2004-04-04 05:37:37.000000000 +0200
+++ linux/sound/pci/es1968.c	2004-04-14 11:48:34.000000000 +0200
@@ -102,11 +102,11 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/mpu401.h>
 #include <sound/ac97_codec.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #define chip_t es1968_t
@@ -138,36 +138,37 @@ static int enable_mpu[SNDRV_CARDS] = {[0
 #ifdef SUPPORT_JOYSTICK
 static int joystick[SNDRV_CARDS];
 #endif
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(total_bufsize, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(total_bufsize, int, boot_devs, 0444);
 MODULE_PARM_DESC(total_bufsize, "Total buffer size in kB.");
 MODULE_PARM_SYNTAX(total_bufsize, SNDRV_ENABLED ",allows:{{1,4096}},skill:advanced");
-MODULE_PARM(pcm_substreams_p, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pcm_substreams_p, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_substreams_p, "PCM Playback substreams for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(pcm_substreams_p, SNDRV_ENABLED ",allows:{{1,8}}");
-MODULE_PARM(pcm_substreams_c, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pcm_substreams_c, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_substreams_c, "PCM Capture substreams for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(pcm_substreams_c, SNDRV_ENABLED ",allows:{{0,8}}");
-MODULE_PARM(clock, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(clock, int, boot_devs, 0444);
 MODULE_PARM_DESC(clock, "Clock on " CARD_NAME " soundcard.  (0 = auto-detect)");
 MODULE_PARM_SYNTAX(clock, SNDRV_ENABLED);
-MODULE_PARM(use_pm, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(use_pm, int, boot_devs, 0444);
 MODULE_PARM_DESC(use_pm, "Toggle power-management.  (0 = off, 1 = on, 2 = auto)");
-MODULE_PARM_SYNTAX(use_pm, SNDRV_ENABLED ",allows:{{0,1,2}},skill:advanced");
-MODULE_PARM(enable_mpu, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+MODULE_PARM_SYNTAX(use_pm, SNDRV_ENABLED ",allows:{{0,1,2}},default:2,skill:advanced");
+module_param_array(enable_mpu, int, boot_devs, 0444);
 MODULE_PARM_DESC(enable_mpu, "Enable MPU401.  (0 = off, 1 = on, 2 = auto)");
-MODULE_PARM_SYNTAX(enable_mpu, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
+MODULE_PARM_SYNTAX(enable_mpu, SNDRV_ENABLED ",allows:{{0,2}},default:2");
 #ifdef SUPPORT_JOYSTICK
-MODULE_PARM(joystick, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick, bool, boot_devs, 0444);
 MODULE_PARM_DESC(joystick, "Enable joystick.");
 MODULE_PARM_SYNTAX(joystick, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 #endif
@@ -2415,30 +2416,26 @@ static void snd_es1968_start_irq(es1968_
 /*
  * PM support
  */
-static void es1968_suspend(es1968_t *chip)
+static int es1968_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	es1968_t *chip = snd_magic_cast(es1968_t, card->pm_private_data, return -EINVAL);
 
 	if (! chip->do_pm)
-		return;
-
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
+		return 0;
 
 	snd_pcm_suspend_all(chip->pcm);
+	snd_ac97_suspend(chip->ac97);
 	snd_es1968_bob_stop(chip);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void es1968_resume(es1968_t *chip)
+static int es1968_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	es1968_t *chip = snd_magic_cast(es1968_t, card->pm_private_data, return -EINVAL);
 
 	if (! chip->do_pm)
-		return;
-
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
+		return 0;
 
 	/* restore all our config */
 	pci_enable_device(chip->pci);
@@ -2460,41 +2457,8 @@ static void es1968_resume(es1968_t *chip
 		snd_es1968_bob_start(chip);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-static int snd_es1968_suspend(struct pci_dev *dev, u32 state)
-{
-	es1968_t *chip = snd_magic_cast(es1968_t, pci_get_drvdata(dev), return -ENXIO);
-	es1968_suspend(chip);
 	return 0;
 }
-static int snd_es1968_resume(struct pci_dev *dev)
-{
-	es1968_t *chip = snd_magic_cast(es1968_t, pci_get_drvdata(dev), return -ENXIO);
-	es1968_resume(chip);
-	return 0;
-}
-
-/* callback */
-static int snd_es1968_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	es1968_t *chip = snd_magic_cast(es1968_t, card->power_state_private_data, return -ENXIO);
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		es1968_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		es1968_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
 #endif /* CONFIG_PM */
 
 static int snd_es1968_free(es1968_t *chip)
@@ -2636,12 +2600,8 @@ static int __devinit snd_es1968_create(s
 
 	snd_es1968_chip_init(chip);
 
-#ifdef CONFIG_PM
-	if (chip->do_pm) {
-		card->set_power_state = snd_es1968_set_power_state;
-		card->power_state_private_data = chip;
-	}
-#endif
+	if (chip->do_pm)
+		snd_card_set_pm_callback(card, es1968_suspend, es1968_resume, chip);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_es1968_free(chip);
@@ -2763,16 +2723,14 @@ static int __devinit snd_es1968_probe(st
 		snd_card_free(card);
 		return err;
 	}
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
 static void __devexit snd_es1968_remove(struct pci_dev *pci)
 {
-	es1968_t *chip = snd_magic_cast(es1968_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -2781,71 +2739,18 @@ static struct pci_driver driver = {
 	.id_table = snd_es1968_ids,
 	.probe = snd_es1968_probe,
 	.remove = __devexit_p(snd_es1968_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_es1968_suspend,
-	.resume = snd_es1968_resume,
-#endif
+	SND_PCI_PM_CALLBACKS
 };
 
 static int __init alsa_card_es1968_init(void)
 {
-	int err;
-
-        if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "ESS Maestro soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_es1968_exit(void)
 {
-#if 0 // do we really need this?
-	unregister_reboot_notifier(&snd_es1968_nb);
-#endif
 	pci_unregister_driver(&driver);
 }
 
 module_init(alsa_card_es1968_init)
 module_exit(alsa_card_es1968_exit)
-
-#ifndef MODULE
-
-/* format is: snd-es1968=enable,index,id,
-			 total_bufsize,
-			 pcm_substreams_p,
-			 pcm_substreams_c,
-			 clock,
-			 use_pm,
-			 enable_mpu,
-			 joystick
-*/
-
-static int __init alsa_card_es1968_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&total_bufsize[nr_dev]) == 2 &&
-	       get_option(&str,&pcm_substreams_p[nr_dev]) == 2 &&
-	       get_option(&str,&pcm_substreams_c[nr_dev]) == 2 &&
-	       get_option(&str,&clock[nr_dev]) == 2 &&
-	       get_option(&str,&use_pm[nr_dev]) == 2 &&
-	       get_option(&str,&enable_mpu[nr_dev]) == 2
-#ifdef SUPPORT_JOYSTICK
-	       && get_option(&str,&joystick[nr_dev]) == 2
-#endif
-	       );
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-es1968=", alsa_card_es1968_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/fm801.c linux/sound/pci/fm801.c
--- linux-2.6.5/sound/pci/fm801.c	2004-04-04 05:37:42.000000000 +0200
+++ linux/sound/pci/fm801.c	2004-04-13 13:07:01.000000000 +0200
@@ -25,12 +25,12 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <asm/io.h>
@@ -60,17 +60,18 @@ static int enable[SNDRV_CARDS] = SNDRV_D
  *  High 16-bits are video (radio) device number + 1
  */
 static int tea575x_tuner[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 };
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for the FM801 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for the FM801 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable FM801 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(tea575x_tuner, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(tea575x_tuner, bool, boot_devs, 0444);
 MODULE_PARM_DESC(tea575x_tuner, "Enable TEA575x tuner.");
 MODULE_PARM_SYNTAX(tea575x_tuner, SNDRV_ENABLE_DESC);
 
@@ -1482,15 +1483,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_fm801_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "ForteMedia FM801 soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_fm801_exit(void)
@@ -1500,25 +1493,3 @@ static void __exit alsa_card_fm801_exit(
 
 module_init(alsa_card_fm801_init)
 module_exit(alsa_card_fm801_exit)
-
-#ifndef MODULE
-
-/* format is: snd-fm801=enable,index,id,tea575x_tuner */
-
-static int __init alsa_card_fm801_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&tea575x_tuner[nr_dev]));
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-fm801=", alsa_card_fm801_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/ice1712/hoontech.c linux/sound/pci/ice1712/hoontech.c
--- linux-2.6.5/sound/pci/ice1712/hoontech.c	2004-04-04 05:37:23.000000000 +0200
+++ linux/sound/pci/ice1712/hoontech.c	2004-04-13 17:50:44.000000000 +0200
@@ -152,6 +152,20 @@ static int __devinit snd_ice1712_hoontec
 {
 	int box, chn;
 
+	/* EZ8 Hack: Change shortname and subvendor id, Recall functions called in
+	 * snd_ice1712_chip_init when it still thinks it is a Hoontech DSP24 card.
+	 */
+	if (ice->ez8) {
+		strcpy(ice->card->shortname, "Event Electronics EZ8");
+		ice->eeprom.subvendor = 0;
+		ice->gpio.write_mask = ice->eeprom.gpiomask;
+		ice->gpio.direction = ice->eeprom.gpiodir;
+		snd_ice1712_write(ice, ICE1712_IREG_GPIO_WRITE_MASK, ice->eeprom.gpiomask);
+		snd_ice1712_write(ice, ICE1712_IREG_GPIO_DIRECTION, ice->eeprom.gpiodir);
+		snd_ice1712_write(ice, ICE1712_IREG_GPIO_DATA, ice->eeprom.gpiostate);
+		return 0;
+	}
+
 	ice->num_total_dacs = 8;
 	ice->num_total_adcs = 8;
 
diff -rup linux-2.6.5/sound/pci/ice1712/ice1712.c linux/sound/pci/ice1712/ice1712.c
--- linux-2.6.5/sound/pci/ice1712/ice1712.c	2004-04-04 05:36:55.000000000 +0200
+++ linux/sound/pci/ice1712/ice1712.c	2004-04-13 17:48:38.000000000 +0200
@@ -41,6 +41,9 @@
  *  2003.02.20  Taksahi Iwai <tiwai@suse.de>
  *	Split vt1724 part to an independent driver.
  *	The GPIO is accessed through the callback functions now.
+ *
+ * 2004.03.31 Doug McLain <nostar@comcast.net>
+ *    Added support for Event Electronics EZ8 card to hoontech.c.
  */
 
 
@@ -51,11 +54,11 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/cs8427.h>
 #include <sound/info.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <sound/asoundef.h>
@@ -81,24 +84,29 @@ MODULE_DEVICES("{"
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;		/* Enable this card */
-static int omni[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 0};	/* Delta44 & 66 Omni I/O support */
+static int omni[SNDRV_CARDS];	/* Delta44 & 66 Omni I/O support */
 static int cs8427_timeout[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 500}; /* CS8427 S/PDIF transciever reset timeout value in msec */
+static int ez8[SNDRV_CARDS];	/* EZ8 card */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for ICE1712 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for ICE1712 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable ICE1712 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(omni, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(omni, bool, boot_devs, 0444);
 MODULE_PARM_DESC(omni, "Enable Midiman M-Audio Delta Omni I/O support.");
 MODULE_PARM_SYNTAX(omni, SNDRV_ENABLED "," SNDRV_ENABLE_DESC);
-MODULE_PARM(cs8427_timeout, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(cs8427_timeout, int, boot_devs, 0444);
 MODULE_PARM_DESC(cs8427_timeout, "Define reset timeout for cs8427 chip in msec resolution.");
 MODULE_PARM_SYNTAX(cs8427_timeout, SNDRV_ENABLED ", allows:{{1,1000}},default=500,skill:advanced");
+module_param_array(ez8, bool, boot_devs, 0444);
+MODULE_PARM_DESC(ez8, "Enable Event Electronics EZ8 support.");
+MODULE_PARM_SYNTAX(ez8, SNDRV_ENABLED "," SNDRV_ENABLE_DESC);
 
 #ifndef PCI_VENDOR_ID_ICE
 #define PCI_VENDOR_ID_ICE		0x1412
@@ -2409,6 +2417,7 @@ static int __devinit snd_ice1712_create(
 					struct pci_dev *pci,
 					int omni,
 					int cs8427_timeout,
+					int ez8,
 					ice1712_t ** r_ice1712)
 {
 	ice1712_t *ice;
@@ -2437,6 +2446,7 @@ static int __devinit snd_ice1712_create(
 		cs8427_timeout = 1;
 	else if (cs8427_timeout > 1000)
 		cs8427_timeout = 1000;
+	ice->ez8 = ez8 ? 1 : 0;
 	ice->cs8427_timeout = cs8427_timeout;
 	spin_lock_init(&ice->reg_lock);
 	init_MUTEX(&ice->gpio_mutex);
@@ -2557,7 +2567,7 @@ static int __devinit snd_ice1712_probe(s
 	strcpy(card->driver, "ICE1712");
 	strcpy(card->shortname, "ICEnsemble ICE1712");
 	
-	if ((err = snd_ice1712_create(card, pci, omni[dev], cs8427_timeout[dev], &ice)) < 0) {
+	if ((err = snd_ice1712_create(card, pci, omni[dev], cs8427_timeout[dev], ez8[dev], &ice)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
@@ -2659,15 +2669,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_ice1712_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "ICE1712 soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_ice1712_exit(void)
@@ -2677,24 +2679,3 @@ static void __exit alsa_card_ice1712_exi
 
 module_init(alsa_card_ice1712_init)
 module_exit(alsa_card_ice1712_exit)
-
-#ifndef MODULE
-
-/* format is: snd-ice1712=enable,index,id */
-
-static int __init alsa_card_ice1712_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-ice1712=", alsa_card_ice1712_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/ice1712/ice1712.h linux/sound/pci/ice1712/ice1712.h
--- linux-2.6.5/sound/pci/ice1712/ice1712.h	2004-04-04 05:36:16.000000000 +0200
+++ linux/sound/pci/ice1712/ice1712.h	2004-04-13 17:49:02.000000000 +0200
@@ -329,6 +329,7 @@ struct _snd_ice1712 {
 	unsigned int pro_volumes[20];
 	unsigned int omni: 1;		/* Delta Omni I/O */
 	unsigned int vt1724: 1;
+	unsigned int ez8: 1;		/* EZ8 support */
 	unsigned int num_total_dacs;	/* total DACs */
 	unsigned int num_total_adcs;	/* total ADCs */
 	unsigned char hoontech_boxbits[4];
diff -rup linux-2.6.5/sound/pci/ice1712/ice1724.c linux/sound/pci/ice1712/ice1724.c
--- linux-2.6.5/sound/pci/ice1712/ice1724.c	2004-04-04 05:36:58.000000000 +0200
+++ linux/sound/pci/ice1712/ice1724.c	2004-04-13 13:07:29.000000000 +0200
@@ -28,10 +28,10 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <sound/asoundef.h>
@@ -62,14 +62,15 @@ MODULE_DEVICES("{"
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;		/* Enable this card */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for ICE1724 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for ICE1724 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable ICE1724 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 
@@ -2141,15 +2142,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_ice1724_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "ICE1724 soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_ice1724_exit(void)
@@ -2159,24 +2152,3 @@ static void __exit alsa_card_ice1724_exi
 
 module_init(alsa_card_ice1724_init)
 module_exit(alsa_card_ice1724_exit)
-
-#ifndef MODULE
-
-/* format is: snd-ice1724=enable,index,id */
-
-static int __init alsa_card_ice1724_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-ice1724=", alsa_card_ice1724_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/intel8x0.c linux/sound/pci/intel8x0.c
--- linux-2.6.5/sound/pci/intel8x0.c	2004-04-04 05:37:24.000000000 +0200
+++ linux/sound/pci/intel8x0.c	2004-04-14 11:46:03.000000000 +0200
@@ -34,12 +34,12 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
 #include <sound/info.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 /* for 440MX workaround */
 #include <asm/pgtable.h>
@@ -81,29 +81,30 @@ static int joystick[SNDRV_CARDS];
 #ifdef SUPPORT_MIDI
 static int mpu_port[SNDRV_CARDS]; /* disabled */
 #endif
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Intel i8x0 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Intel i8x0 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Intel i8x0 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(ac97_clock, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ac97_clock, int, boot_devs, 0444);
 MODULE_PARM_DESC(ac97_clock, "AC'97 codec clock (0 = auto-detect).");
 MODULE_PARM_SYNTAX(ac97_clock, SNDRV_ENABLED ",default:0");
-MODULE_PARM(ac97_quirk, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ac97_quirk, int, boot_devs, 0444);
 MODULE_PARM_DESC(ac97_quirk, "AC'97 workaround for strange hardware.");
 MODULE_PARM_SYNTAX(ac97_quirk, SNDRV_ENABLED ",allows:{{-1,4}},dialog:list,default:-1");
 #ifdef SUPPORT_JOYSTICK
-MODULE_PARM(joystick, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick, bool, boot_devs, 0444);
 MODULE_PARM_DESC(joystick, "Enable joystick for Intel i8x0 soundcard.");
 MODULE_PARM_SYNTAX(joystick, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 #endif
 #ifdef SUPPORT_MIDI
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mpu_port, int, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU401 port # for Intel i8x0 driver.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_ENABLED ",allows:{{0},{0x330},{0x300}},dialog:list");
 #endif
@@ -235,6 +236,7 @@ DEFINE_REGSET(SP, 0x60);	/* SPDIF out */
 #define   ICH_P2INT		0x02000000	/* ICH4: PCM2-In interrupt */
 #define   ICH_M2INT		0x01000000	/* ICH4: Mic2-In interrupt */
 #define   ICH_SAMPLE_CAP	0x00c00000	/* ICH4: sample capability bits (RO) */
+#define   ICH_SAMPLE_16_20	0x00400000	/* ICH4: 16- and 20-bit samples */
 #define   ICH_MULTICHAN_CAP	0x00300000	/* ICH4: multi-channel capability bits (RO) */
 #define   ICH_MD3		0x00020000	/* modem power down semaphore */
 #define   ICH_AD3		0x00010000	/* audio power down semaphore */
@@ -378,6 +380,7 @@ typedef struct {
         unsigned int fragsize;
         unsigned int fragsize1;
         unsigned int position;
+	unsigned int pos_shift;
         int frags;
         int lvi;
         int lvi_frag;
@@ -441,11 +444,6 @@ struct _snd_intel8x0 {
 	struct snd_dma_buffer bdbars;
 	u32 int_sta_reg;		/* interrupt status register */
 	u32 int_sta_mask;		/* interrupt status mask */
-	unsigned int pcm_pos_shift;
-	
-#ifdef CONFIG_PM
-	int in_suspend;
-#endif
 };
 
 static struct pci_device_id snd_intel8x0_ids[] = {
@@ -719,10 +717,10 @@ static void snd_intel8x0_setup_periods(i
 		for (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 4) {
 			bdbar[idx + 0] = cpu_to_le32(ichdev->physbuf);
 			bdbar[idx + 1] = cpu_to_le32(0x80000000 | /* interrupt on completion */
-						     ichdev->fragsize1 >> chip->pcm_pos_shift);
+						     ichdev->fragsize1 >> ichdev->pos_shift);
 			bdbar[idx + 2] = cpu_to_le32(ichdev->physbuf + (ichdev->size >> 1));
 			bdbar[idx + 3] = cpu_to_le32(0x80000000 | /* interrupt on completion */
-						     ichdev->fragsize1 >> chip->pcm_pos_shift);
+						     ichdev->fragsize1 >> ichdev->pos_shift);
 		}
 		ichdev->frags = 2;
 	} else {
@@ -731,7 +729,7 @@ static void snd_intel8x0_setup_periods(i
 		for (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 2) {
 			bdbar[idx + 0] = cpu_to_le32(ichdev->physbuf + (((idx >> 1) * ichdev->fragsize) % ichdev->size));
 			bdbar[idx + 1] = cpu_to_le32(0x80000000 | /* interrupt on completion */
-						     ichdev->fragsize >> chip->pcm_pos_shift);
+						     ichdev->fragsize >> ichdev->pos_shift);
 			// printk("bdbar[%i] = 0x%x [0x%x]\n", idx + 0, bdbar[idx + 0], bdbar[idx + 1]);
 		}
 		ichdev->frags = ichdev->size / ichdev->fragsize;
@@ -981,7 +979,8 @@ static int snd_intel8x0_hw_free(snd_pcm_
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static void snd_intel8x0_setup_multi_channels(intel8x0_t *chip, int channels)
+static void snd_intel8x0_setup_pcm_out(intel8x0_t *chip,
+				       int channels, int sample_bits)
 {
 	unsigned int cnt;
 	switch (chip->device_type) {
@@ -1005,7 +1004,7 @@ static void snd_intel8x0_setup_multi_cha
 		break;
 	default:
 		cnt = igetdword(chip, ICHREG(GLOB_CNT));
-		cnt &= ~ICH_PCM_246_MASK;
+		cnt &= ~(ICH_PCM_246_MASK | ICH_PCM_20BIT);
 		if (chip->multi4 && channels == 4)
 			cnt |= ICH_PCM_4;
 		else if (chip->multi6 && channels == 6)
@@ -1016,6 +1015,9 @@ static void snd_intel8x0_setup_multi_cha
 			 */
 			iputdword(chip, ICHREG(GLOB_CNT), (cnt & 0xcfffff));
 			mdelay(50); /* grrr... */
+		} else if (chip->device_type == DEVICE_INTEL_ICH4) {
+			if (sample_bits > 16)
+				cnt |= ICH_PCM_20BIT;
 		}
 		iputdword(chip, ICHREG(GLOB_CNT), cnt);
 		break;
@@ -1033,8 +1035,12 @@ static int snd_intel8x0_pcm_prepare(snd_
 	ichdev->fragsize = snd_pcm_lib_period_bytes(substream);
 	if (ichdev->ichd == ICHD_PCMOUT) {
 		spin_lock(&chip->reg_lock);
-		snd_intel8x0_setup_multi_channels(chip, runtime->channels);
+		snd_intel8x0_setup_pcm_out(chip, runtime->channels,
+					   runtime->sample_bits);
 		spin_unlock(&chip->reg_lock);
+		if (chip->device_type == DEVICE_INTEL_ICH4) {
+			ichdev->pos_shift = (runtime->sample_bits > 16) ? 2 : 1;
+		}
 	}
 	snd_intel8x0_setup_periods(chip, ichdev);
 	return 0;
@@ -1047,7 +1053,7 @@ static snd_pcm_uframes_t snd_intel8x0_pc
 	unsigned long flags;
 	size_t ptr1, ptr;
 
-	ptr1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb) << chip->pcm_pos_shift;
+	ptr1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb) << ichdev->pos_shift;
 	if (ptr1 != 0)
 		ptr = ichdev->fragsize1 - ptr1;
 	else
@@ -1142,6 +1148,8 @@ static int snd_intel8x0_playback_open(sn
 		runtime->hw.channels_max = 4;
 		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels4);
 	}
+	if (chip->smp20bit)
+		runtime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;
 	return 0;
 }
 
@@ -1844,6 +1852,7 @@ static int __devinit snd_intel8x0_mixer(
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = chip;
 	ac97.private_free = snd_intel8x0_mixer_free_ac97;
+	ac97.scaps = AC97_SCAP_SKIP_MODEM;
 	if (chip->device_type != DEVICE_ALI) {
 		glob_sta = igetdword(chip, ICHREG(GLOB_STA));
 		bus.write = snd_intel8x0_codec_write;
@@ -1892,7 +1901,8 @@ static int __devinit snd_intel8x0_mixer(
 	for (i = 0; i < codecs; i++) {
 		ac97.num = i;
 		if ((err = snd_ac97_mixer(pbus, &ac97, &x97)) < 0) {
-			snd_printk(KERN_ERR "Unable to initialize codec #%d\n", i);
+			if (err != -EACCES)
+				snd_printk(KERN_ERR "Unable to initialize codec #%d\n", i);
 			if (i == 0)
 				goto __err;
 			continue;
@@ -1946,6 +1956,10 @@ static int __devinit snd_intel8x0_mixer(
 		if (pbus->pcms[0].r[0].slots & (1 << AC97_SLOT_LFE))
 			chip->multi6 = 1;
 	}
+	if (chip->device_type == DEVICE_INTEL_ICH4) {
+		if ((igetdword(chip, ICHREG(GLOB_STA)) & ICH_SAMPLE_CAP) == ICH_SAMPLE_16_20)
+			chip->smp20bit = 1;
+	}
 	if (chip->device_type == DEVICE_NFORCE) {
 		/* 48kHz only */
 		chip->ichd[spdif_idx].pcm->rates = SNDRV_PCM_RATE_48000;
@@ -2184,74 +2198,52 @@ static int snd_intel8x0_free(intel8x0_t 
 /*
  * power management
  */
-static void intel8x0_suspend(intel8x0_t *chip)
+static int intel8x0_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	intel8x0_t *chip = snd_magic_cast(intel8x0_t, card->pm_private_data, return -EINVAL);
 	int i;
 
-	if (chip->in_suspend ||
-	    card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
-
-	chip->in_suspend = 1;
 	for (i = 0; i < chip->pcm_devs; i++)
 		snd_pcm_suspend_all(chip->pcm[i]);
+	for (i = 0; i < 3; i++)
+		if (chip->ac97[i])
+			snd_ac97_suspend(chip->ac97[i]);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void intel8x0_resume(intel8x0_t *chip)
+static int intel8x0_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	intel8x0_t *chip = snd_magic_cast(intel8x0_t, card->pm_private_data, return -EINVAL);
 	int i;
 
-	if (! chip->in_suspend ||
-	    card->power_state == SNDRV_CTL_POWER_D0)
-		return;
-
 	pci_enable_device(chip->pci);
 	pci_set_master(chip->pci);
 	snd_intel8x0_chip_init(chip, 0);
+
+	/* refill nocache */
+	if (chip->fix_nocache)
+		fill_nocache(chip->bdbars.area, chip->bdbars.bytes, 1);
+
 	for (i = 0; i < 3; i++)
 		if (chip->ac97[i])
 			snd_ac97_resume(chip->ac97[i]);
 
-	chip->in_suspend = 0;
-	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-static int snd_intel8x0_suspend(struct pci_dev *dev, u32 state)
-{
-	intel8x0_t *chip = snd_magic_cast(intel8x0_t, pci_get_drvdata(dev), return -ENXIO);
-	intel8x0_suspend(chip);
-	return 0;
-}
-static int snd_intel8x0_resume(struct pci_dev *dev)
-{
-	intel8x0_t *chip = snd_magic_cast(intel8x0_t, pci_get_drvdata(dev), return -ENXIO);
-	intel8x0_resume(chip);
-	return 0;
-}
-
-/* callback */
-static int snd_intel8x0_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	intel8x0_t *chip = snd_magic_cast(intel8x0_t, card->power_state_private_data, return -ENXIO);
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		intel8x0_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		intel8x0_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
+	/* refill nocache */
+	if (chip->fix_nocache) {
+		for (i = 0; i < chip->bdbars_count; i++) {
+			ichdev_t *ichdev = &chip->ichd[i];
+			if (ichdev->substream) {
+				snd_pcm_runtime_t *runtime = ichdev->substream->runtime;
+				if (runtime->dma_area)
+					fill_nocache(runtime->dma_area, runtime->dma_bytes, 1);
+			}
+		}
 	}
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
-
 #endif /* CONFIG_PM */
 
 #define INTEL8X0_TESTBUF_SIZE	32768	/* enough large for one shot */
@@ -2305,7 +2297,7 @@ static void __devinit intel8x0_measure_a
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	/* check the position */
 	pos = ichdev->fragsize1;
-	pos -= igetword(chip, ichdev->reg_offset + ichdev->roff_picb) << chip->pcm_pos_shift;
+	pos -= igetword(chip, ichdev->reg_offset + ichdev->roff_picb) << ichdev->pos_shift;
 	pos += ichdev->position;
 	do_gettimeofday(&stop_time);
 	/* stop */
@@ -2546,9 +2538,9 @@ static int __devinit snd_intel8x0_create
 		}
 		if (device_type == DEVICE_ALI)
 			ichdev->ali_slot = (ichdev->reg_offset - 0x40) / 0x10;
+		/* SIS7012 handles the pcm data in bytes, others are in samples */
+		ichdev->pos_shift = (device_type == DEVICE_SIS) ? 0 : 1;
 	}
-	/* SIS7012 handles the pcm data in bytes, others are in words */
-	chip->pcm_pos_shift = (device_type == DEVICE_SIS) ? 0 : 1;
 
 	memset(&chip->dma_dev, 0, sizeof(chip->dma_dev));
 	chip->dma_dev.type = SNDRV_DMA_TYPE_DEV;
@@ -2581,10 +2573,7 @@ static int __devinit snd_intel8x0_create
 		return err;
 	}
 
-#ifdef CONFIG_PM
-	card->set_power_state = snd_intel8x0_set_power_state;
-	card->power_state_private_data = chip;
-#endif
+	snd_card_set_pm_callback(card, intel8x0_suspend, intel8x0_resume, chip);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_intel8x0_free(chip);
@@ -2692,16 +2681,14 @@ static int __devinit snd_intel8x0_probe(
 		snd_card_free(card);
 		return err;
 	}
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
 static void __devexit snd_intel8x0_remove(struct pci_dev *pci)
 {
-	intel8x0_t *chip = snd_magic_cast(intel8x0_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -2710,10 +2697,7 @@ static struct pci_driver driver = {
 	.id_table = snd_intel8x0_ids,
 	.probe = snd_intel8x0_probe,
 	.remove = __devexit_p(snd_intel8x0_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_intel8x0_suspend,
-	.resume = snd_intel8x0_resume,
-#endif
+	SND_PCI_PM_CALLBACKS
 };
 
 
@@ -2817,12 +2801,9 @@ static int __init alsa_card_intel8x0_ini
 {
 	int err;
 
-        if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Intel ICH soundcard not found or device busy\n");
-#endif
+        if ((err = pci_module_init(&driver)) < 0)
                 return err;
-        }
+
 #if defined(SUPPORT_JOYSTICK) || defined(SUPPORT_MIDI)
 	if (pci_module_init(&joystick_driver) < 0) {
 		snd_printdd(KERN_INFO "no joystick found\n");
@@ -2847,33 +2828,3 @@ static void __exit alsa_card_intel8x0_ex
 
 module_init(alsa_card_intel8x0_init)
 module_exit(alsa_card_intel8x0_exit)
-
-#ifndef MODULE
-
-/* format is: snd-intel8x0=enable,index,id,ac97_clock,ac97_quirk,mpu_port,joystick */
-
-static int __init alsa_card_intel8x0_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&ac97_clock[nr_dev]) == 2 &&
-	       get_option(&str,&ac97_quirk[nr_dev]) == 2
-#ifdef SUPPORT_MIDI
-	       && get_option(&str,&mpu_port[nr_dev]) == 2
-#endif
-#ifdef SUPPORT_JOYSTICK
-	       && get_option(&str,&joystick[nr_dev]) == 2
-#endif
-	       );
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-intel8x0=", alsa_card_intel8x0_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/intel8x0m.c linux/sound/pci/intel8x0m.c
--- linux-2.6.5/sound/pci/intel8x0m.c	2004-04-04 05:37:07.000000000 +0200
+++ linux/sound/pci/intel8x0m.c	2004-04-14 11:48:24.000000000 +0200
@@ -31,12 +31,12 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
 #include <sound/info.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -56,17 +56,18 @@ static int index[SNDRV_CARDS] = SNDRV_DE
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int ac97_clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Intel i8x0 modemcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Intel i8x0 modemcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Intel i8x0 modemcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(ac97_clock, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ac97_clock, int, boot_devs, 0444);
 MODULE_PARM_DESC(ac97_clock, "AC'97 codec clock (0 = auto-detect).");
 MODULE_PARM_SYNTAX(ac97_clock, SNDRV_ENABLED ",default:0");
 
@@ -266,10 +267,6 @@ struct _snd_intel8x0m {
 	u32 int_sta_reg;		/* interrupt status register */
 	u32 int_sta_mask;		/* interrupt status mask */
 	unsigned int pcm_pos_shift;
-	
-#ifdef CONFIG_PM
-	int in_suspend;
-#endif
 };
 
 static struct pci_device_id snd_intel8x0m_ids[] = {
@@ -905,6 +902,7 @@ static int __devinit snd_intel8x0_mixer(
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = chip;
 	ac97.private_free = snd_intel8x0_mixer_free_ac97;
+	ac97.scaps = AC97_SCAP_SKIP_AUDIO;
 
 	glob_sta = igetdword(chip, ICHREG(GLOB_STA));
 	bus.write = snd_intel8x0_codec_write;
@@ -1081,72 +1079,31 @@ static int snd_intel8x0_free(intel8x0_t 
 /*
  * power management
  */
-static void intel8x0_suspend(intel8x0_t *chip)
+static int intel8x0m_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	intel8x0_t *chip = snd_magic_cast(intel8x0_t, card->pm_private_data, return -EINVAL);
 	int i;
 
-	if (chip->in_suspend ||
-	    card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
-
-	chip->in_suspend = 1;
 	for (i = 0; i < chip->pcm_devs; i++)
 		snd_pcm_suspend_all(chip->pcm[i]);
+	if (chip->ac97)
+		snd_ac97_suspend(chip->ac97);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void intel8x0_resume(intel8x0_t *chip)
+static int intel8x0m_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
-
-	if (! chip->in_suspend ||
-	    card->power_state == SNDRV_CTL_POWER_D0)
-		return;
-
+	intel8x0_t *chip = snd_magic_cast(intel8x0_t, card->pm_private_data, return -EINVAL);
 	pci_enable_device(chip->pci);
 	pci_set_master(chip->pci);
 	snd_intel8x0_chip_init(chip, 0);
 	if (chip->ac97)
 		snd_ac97_resume(chip->ac97);
 
-	chip->in_suspend = 0;
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-static int snd_intel8x0m_suspend(struct pci_dev *dev, u32 state)
-{
-	intel8x0_t *chip = snd_magic_cast(intel8x0_t, pci_get_drvdata(dev), return -ENXIO);
-	intel8x0_suspend(chip);
-	return 0;
-}
-static int snd_intel8x0m_resume(struct pci_dev *dev)
-{
-	intel8x0_t *chip = snd_magic_cast(intel8x0_t, pci_get_drvdata(dev), return -ENXIO);
-	intel8x0_resume(chip);
 	return 0;
 }
-
-/* callback */
-static int snd_intel8x0_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	intel8x0_t *chip = snd_magic_cast(intel8x0_t, card->power_state_private_data, return -ENXIO);
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		intel8x0_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		intel8x0_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
 #endif /* CONFIG_PM */
 
 static void snd_intel8x0m_proc_read(snd_info_entry_t * entry,
@@ -1338,10 +1295,7 @@ static int __devinit snd_intel8x0m_creat
 		return err;
 	}
 
-#ifdef CONFIG_PM
-	card->set_power_state = snd_intel8x0_set_power_state;
-	card->power_state_private_data = chip;
-#endif
+	snd_card_set_pm_callback(card, intel8x0m_suspend, intel8x0m_resume, chip);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_intel8x0_free(chip);
@@ -1436,16 +1390,14 @@ static int __devinit snd_intel8x0m_probe
 		snd_card_free(card);
 		return err;
 	}
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
 static void __devexit snd_intel8x0m_remove(struct pci_dev *pci)
 {
-	intel8x0_t *chip = snd_magic_cast(intel8x0_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -1454,25 +1406,13 @@ static struct pci_driver driver = {
 	.id_table = snd_intel8x0m_ids,
 	.probe = snd_intel8x0m_probe,
 	.remove = __devexit_p(snd_intel8x0m_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_intel8x0m_suspend,
-	.resume = snd_intel8x0m_resume,
-#endif
+	SND_PCI_PM_CALLBACKS
 };
 
 
 static int __init alsa_card_intel8x0m_init(void)
 {
-	int err;
-
-        if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Intel ICH modemcard not found or device busy\n");
-#endif
-                return err;
-        }
-
-        return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_intel8x0m_exit(void)
@@ -1482,26 +1422,3 @@ static void __exit alsa_card_intel8x0m_e
 
 module_init(alsa_card_intel8x0m_init)
 module_exit(alsa_card_intel8x0m_exit)
-
-#ifndef MODULE
-
-/* format is: snd-intel8x0=enable,index,id,ac97_clock,mpu_port,joystick */
-
-static int __init alsa_card_intel8x0m_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&ac97_clock[nr_dev]) == 2
-	       );
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-intel8x0m=", alsa_card_intel8x0m_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/korg1212/korg1212.c linux/sound/pci/korg1212/korg1212.c
--- linux-2.6.5/sound/pci/korg1212/korg1212.c	2004-04-04 05:36:14.000000000 +0200
+++ linux/sound/pci/korg1212/korg1212.c	2004-04-13 13:08:13.000000000 +0200
@@ -26,13 +26,13 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/wait.h>
+#include <linux/moduleparam.h>
 
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <asm/io.h>
@@ -417,14 +417,15 @@ MODULE_DEVICES("{{KORG,korg1212}}");
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;     /* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	   /* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE; /* Enable this card */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Korg 1212 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Korg 1212 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Korg 1212 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 MODULE_AUTHOR("Haroldo Gamal <gamal@alternex.com.br>");
@@ -2504,15 +2505,14 @@ snd_korg1212_probe(struct pci_dev *pci,
 		snd_card_free(card);
 		return err;
 	}
-	pci_set_drvdata(pci, korg1212);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
 static void __devexit snd_korg1212_remove(struct pci_dev *pci)
 {
-	korg1212_t *korg1212 = pci_get_drvdata(pci);
-	snd_card_free(korg1212->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -2525,15 +2525,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_korg1212_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "No Korg 1212IO cards found\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_korg1212_exit(void)
@@ -2543,25 +2535,3 @@ static void __exit alsa_card_korg1212_ex
 
 module_init(alsa_card_korg1212_init)
 module_exit(alsa_card_korg1212_exit)
-
-#ifndef MODULE
-
-/* format is: snd-korg1212=enable,index,id */
-
-static int __init alsa_card_korg1212_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-korg1212=", alsa_card_korg1212_setup);
-
-#endif /* ifndef MODULE */
-
diff -rup linux-2.6.5/sound/pci/maestro3.c linux/sound/pci/maestro3.c
--- linux-2.6.5/sound/pci/maestro3.c	2004-04-04 05:37:23.000000000 +0200
+++ linux/sound/pci/maestro3.c	2004-04-14 12:25:12.000000000 +0200
@@ -39,13 +39,13 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/mpu401.h>
 #include <sound/ac97_codec.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Zach Brown <zab@zabbo.net>, Takashi Iwai <tiwai@suse.de>");
@@ -63,20 +63,21 @@ static char *id[SNDRV_CARDS] = SNDRV_DEF
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP; /* all enabled */
 static int external_amp[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
 static int amp_gpio[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -1};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable this soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(external_amp, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(external_amp, bool, boot_devs, 0444);
 MODULE_PARM_DESC(external_amp, "Enable external amp for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(external_amp, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
-MODULE_PARM(amp_gpio, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(amp_gpio, int, boot_devs, 0444);
 MODULE_PARM_DESC(amp_gpio, "GPIO pin number for external amp. (default = -1)");
 MODULE_PARM_SYNTAX(amp_gpio, SNDRV_ENABLED);
 
@@ -2410,18 +2411,16 @@ static int snd_m3_free(m3_t *chip)
  * APM support
  */
 #ifdef CONFIG_PM
-
-static void m3_suspend(m3_t *chip)
+static int m3_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	m3_t *chip = snd_magic_cast(m3_t, card->pm_private_data, return -EINVAL);
 	int i, index;
 
 	if (chip->suspend_mem == NULL)
-		return;
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
+		return 0;
 
 	snd_pcm_suspend_all(chip->pcm);
+	snd_ac97_suspend(chip->ac97);
 
 	big_mdelay(10); /* give the assp a chance to idle.. */
 
@@ -2440,17 +2439,16 @@ static void m3_suspend(m3_t *chip)
 	snd_m3_outw(chip, 0xffff, 0x54);
 	snd_m3_outw(chip, 0xffff, 0x56);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void m3_resume(m3_t *chip)
+static int m3_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	m3_t *chip = snd_magic_cast(m3_t, card->pm_private_data, return -EINVAL);
 	int i, index;
 
 	if (chip->suspend_mem == NULL)
-		return;
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
+		return 0;
 
 	/* first lets just bring everything back. .*/
 	snd_m3_outw(chip, 0, 0x54);
@@ -2481,41 +2479,8 @@ static void m3_resume(m3_t *chip)
 	snd_m3_amp_enable(chip, 1);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-static int snd_m3_suspend(struct pci_dev *pci, u32 state)
-{
-	m3_t *chip = snd_magic_cast(m3_t, pci_get_drvdata(pci), return -ENXIO);
-	m3_suspend(chip);
-	return 0;
-}
-static int snd_m3_resume(struct pci_dev *pci)
-{
-	m3_t *chip = snd_magic_cast(m3_t, pci_get_drvdata(pci), return -ENXIO);
-	m3_resume(chip);
-	return 0;
-}
-
-/* callback */
-static int snd_m3_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	m3_t *chip = snd_magic_cast(m3_t, card->power_state_private_data, return -ENXIO);
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		m3_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		m3_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
 	return 0;
 }
-
 #endif /* CONFIG_PM */
 
 
@@ -2651,11 +2616,9 @@ snd_m3_create(snd_card_t *card, struct p
 #ifdef CONFIG_PM
 	chip->suspend_mem = vmalloc(sizeof(u16) * (REV_B_CODE_MEMORY_LENGTH + REV_B_DATA_MEMORY_LENGTH));
 	if (chip->suspend_mem == NULL)
-		snd_printk("can't allocate apm buffer\n");
-	else {
-		card->set_power_state = snd_m3_set_power_state;
-		card->power_state_private_data = chip;
-	}
+		snd_printk(KERN_WARNING "can't allocate apm buffer\n");
+	else
+		snd_card_set_pm_callback(card, m3_suspend, m3_resume, chip);
 #endif
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
@@ -2738,16 +2701,14 @@ snd_m3_probe(struct pci_dev *pci, const 
 		printk(KERN_WARNING "maestro3: no midi support.\n");
 #endif
 
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
 static void __devexit snd_m3_remove(struct pci_dev *pci)
 {
-	m3_t *chip = snd_magic_cast(m3_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -2756,23 +2717,12 @@ static struct pci_driver driver = {
 	.id_table = snd_m3_ids,
 	.probe = snd_m3_probe,
 	.remove = __devexit_p(snd_m3_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_m3_suspend,
-	.resume = snd_m3_resume,
-#endif
+	SND_PCI_PM_CALLBACKS
 };
 	
 static int __init alsa_card_m3_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Maestro3/Allegro soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_m3_exit(void)
@@ -2782,26 +2732,3 @@ static void __exit alsa_card_m3_exit(voi
 
 module_init(alsa_card_m3_init)
 module_exit(alsa_card_m3_exit)
-
-#ifndef MODULE
-
-/* format is: snd-maestro3=enable,index,id,external_amp,amp_gpio */
-
-static int __init alsa_card_maestro3_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&external_amp[nr_dev]) == 2 &&
-	       get_option(&str,&amp_gpio[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-maestro3=", alsa_card_maestro3_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/mixart/mixart.c linux/sound/pci/mixart/mixart.c
--- linux-2.6.5/sound/pci/mixart/mixart.c	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/pci/mixart/mixart.c	2004-04-13 13:08:39.000000000 +0200
@@ -25,8 +25,8 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/info.h>
 #include <sound/control.h>
@@ -48,16 +48,17 @@ MODULE_DEVICES("{{Digigram," CARD_NAME "
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;             /* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;              /* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;     /* Enable this card */
+static int boot_devs;
 
 #define chip_t mixart_t
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Digigram " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Digigram " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Digigram " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 
@@ -1432,15 +1433,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_mixart_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		snd_printk(KERN_ERR "Digigram miXart soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_mixart_exit(void)
@@ -1450,24 +1443,3 @@ static void __exit alsa_card_mixart_exit
 
 module_init(alsa_card_mixart_init)
 module_exit(alsa_card_mixart_exit)
-
-#ifndef MODULE
-
-/* format is: snd-mixart=enable,index,id */
-
-static int __init alsa_card_mixart_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-mixart=", alsa_card_mixart_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/nm256/nm256.c linux/sound/pci/nm256/nm256.c
--- linux-2.6.5/sound/pci/nm256/nm256.c	2004-04-04 05:38:12.000000000 +0200
+++ linux/sound/pci/nm256/nm256.c	2004-04-14 11:50:37.000000000 +0200
@@ -31,12 +31,12 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/ac97_codec.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #define CARD_NAME "NeoMagic 256AV/ZX"
@@ -62,32 +62,33 @@ static int force_ac97[SNDRV_CARDS] = {[0
 static int buffer_top[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* not specified */
 static int use_cache[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled */
 static int vaio_hack[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable this soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(playback_bufsize, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(playback_bufsize, int, boot_devs, 0444);
 MODULE_PARM_DESC(playback_bufsize, "DAC frame size in kB for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(playback_bufsize, SNDRV_ENABLED);
-MODULE_PARM(capture_bufsize, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(capture_bufsize, int, boot_devs, 0444);
 MODULE_PARM_DESC(capture_bufsize, "ADC frame size in kB for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(capture_bufsize, SNDRV_ENABLED);
-MODULE_PARM(force_ac97, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(force_ac97, bool, boot_devs, 0444);
 MODULE_PARM_DESC(force_ac97, "Force to use AC97 codec for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(force_ac97, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
-MODULE_PARM(buffer_top, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(buffer_top, int, boot_devs, 0444);
 MODULE_PARM_DESC(buffer_top, "Set the top address of audio buffer for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(buffer_top, SNDRV_ENABLED);
-MODULE_PARM(use_cache, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(use_cache, bool, boot_devs, 0444);
 MODULE_PARM_DESC(use_cache, "Enable the cache for coefficient table access.");
 MODULE_PARM_SYNTAX(use_cache, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
-MODULE_PARM(vaio_hack, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(vaio_hack, bool, boot_devs, 0444);
 MODULE_PARM_DESC(vaio_hack, "Enable workaround for Sony VAIO notebooks.");
 MODULE_PARM_SYNTAX(vaio_hack, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 
@@ -1283,24 +1284,20 @@ snd_nm256_peek_for_sig(nm256_t *chip)
  * APM event handler, so the card is properly reinitialized after a power
  * event.
  */
-static void nm256_suspend(nm256_t *chip)
+static int nm256_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
-
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
+	nm256_t *chip = snd_magic_cast(nm256_t, card->pm_private_data, return -EINVAL);
 
 	snd_pcm_suspend_all(chip->pcm);
+	snd_ac97_suspend(chip->ac97);
 	chip->coeffs_current = 0;
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void nm256_resume(nm256_t *chip)
+static int nm256_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
-
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
+	nm256_t *chip = snd_magic_cast(nm256_t, card->pm_private_data, return -EINVAL);
 
 	/* Perform a full reset on the hardware */
 	pci_enable_device(chip->pci);
@@ -1310,41 +1307,8 @@ static void nm256_resume(nm256_t *chip)
 	snd_ac97_resume(chip->ac97);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-static int snd_nm256_suspend(struct pci_dev *dev, u32 state)
-{
-	nm256_t *chip = snd_magic_cast(nm256_t, pci_get_drvdata(dev), return -ENXIO);
-	nm256_suspend(chip);
-	return 0;
-}
-static int snd_nm256_resume(struct pci_dev *dev)
-{
-	nm256_t *chip = snd_magic_cast(nm256_t, pci_get_drvdata(dev), return -ENXIO);
-	nm256_resume(chip);
-	return 0;
-}
-
-/* callback */
-static int snd_nm256_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	nm256_t *chip = snd_magic_cast(nm256_t, card->power_state_private_data, return -ENXIO);
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		nm256_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		nm256_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
 	return 0;
 }
-
 #endif /* CONFIG_PM */
 
 static int snd_nm256_free(nm256_t *chip)
@@ -1552,10 +1516,7 @@ snd_nm256_create(snd_card_t *card, struc
 
 	// pci_set_master(pci); /* needed? */
 	
-#ifdef CONFIG_PM
-	card->set_power_state = snd_nm256_set_power_state;
-	card->power_state_private_data = chip;
-#endif
+	snd_card_set_pm_callback(card, nm256_suspend, nm256_resume, chip);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)
 		goto __error;
@@ -1641,16 +1602,14 @@ static int __devinit snd_nm256_probe(str
 		return err;
 	}
 
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
 static void __devexit snd_nm256_remove(struct pci_dev *pci)
 {
-	nm256_t *chip = snd_magic_cast(nm256_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -1660,23 +1619,13 @@ static struct pci_driver driver = {
 	.id_table = snd_nm256_ids,
 	.probe = snd_nm256_probe,
 	.remove = __devexit_p(snd_nm256_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_nm256_suspend,
-	.resume = snd_nm256_resume,
-#endif
+	SND_PCI_PM_CALLBACKS
 };
 
 
 static int __init alsa_card_nm256_init(void)
 {
-	int err;
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "NeoMagic 256 audio soundchip not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_nm256_exit(void)
@@ -1686,31 +1635,3 @@ static void __exit alsa_card_nm256_exit(
 
 module_init(alsa_card_nm256_init)
 module_exit(alsa_card_nm256_exit)
-
-#ifndef MODULE
-
-/* format is: snd-nm256=enable,index,id,
-			playback_bufsize,capture_bufsize,
-			force_ac97,buffer_top,use_cache */
-
-static int __init alsa_card_nm256_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&playback_bufsize[nr_dev]) == 2 &&
-	       get_option(&str,&capture_bufsize[nr_dev]) == 2 &&
-	       get_option(&str,&force_ac97[nr_dev]) == 2 &&
-	       get_option(&str,&buffer_top[nr_dev]) == 2 &&
-	       get_option(&str,&use_cache[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-nm256=", alsa_card_nm256_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/rme32.c linux/sound/pci/rme32.c
--- linux-2.6.5/sound/pci/rme32.c	2004-04-04 05:38:23.000000000 +0200
+++ linux/sound/pci/rme32.c	2004-04-13 13:09:10.000000000 +0200
@@ -61,6 +61,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 
 #include <sound/core.h>
 #include <sound/info.h>
@@ -68,7 +69,6 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <asm/io.h>
@@ -76,14 +76,15 @@
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for RME Digi32 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for RME Digi32 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable RME Digi32 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 MODULE_AUTHOR("Martin Langer <martin-langer@gmx.de>");
@@ -1995,15 +1996,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_rme32_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		snd_printk("No RME Digi32 cards found\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_rme32_exit(void)
@@ -2013,22 +2006,3 @@ static void __exit alsa_card_rme32_exit(
 
 module_init(alsa_card_rme32_init)
 module_exit(alsa_card_rme32_exit)
-
-#ifndef MODULE
-
-static int __init alsa_card_rme32_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void) (get_option(&str, &enable[nr_dev]) == 2 &&
-		get_option(&str, &index[nr_dev]) == 2 &&
-		get_id(&str, &id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-rme32=", alsa_card_rme32_setup);
-
-#endif				/* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/rme96.c linux/sound/pci/rme96.c
--- linux-2.6.5/sound/pci/rme96.c	2004-04-04 05:36:56.000000000 +0200
+++ linux/sound/pci/rme96.c	2004-04-13 13:09:27.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 
 #include <sound/core.h>
 #include <sound/info.h>
@@ -36,7 +37,6 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/asoundef.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <asm/io.h>
@@ -57,14 +57,15 @@ MODULE_DEVICES("{{RME,Digi96},"
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for RME Digi96 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for RME Digi96 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable RME Digi96 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 
@@ -2565,15 +2566,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_rme96_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "No RME Digi96 cards found\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_rme96_exit(void)
@@ -2583,24 +2576,3 @@ static void __exit alsa_card_rme96_exit(
 
 module_init(alsa_card_rme96_init)
 module_exit(alsa_card_rme96_exit)
-
-#ifndef MODULE
-
-/* format is: snd-rme96=enable,index,id */
-
-static int __init alsa_card_rme96_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-rme96=", alsa_card_rme96_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/rme9652/hdsp.c linux/sound/pci/rme9652/hdsp.c
--- linux-2.6.5/sound/pci/rme9652/hdsp.c	2004-04-04 05:36:55.000000000 +0200
+++ linux/sound/pci/rme9652/hdsp.c	2004-04-13 13:09:55.000000000 +0200
@@ -27,6 +27,7 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/pci.h>
+#include <linux/moduleparam.h>
 
 #include <sound/core.h>
 #include <sound/control.h>
@@ -35,7 +36,6 @@
 #include <sound/asoundef.h>
 #include <sound/rawmidi.h>
 #include <sound/hwdep.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/hdsp.h>
 
@@ -48,20 +48,21 @@ static char *id[SNDRV_CARDS] = SNDRV_DEF
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int precise_ptr[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 }; /* Enable precise pointer */
 static int line_outs_monitor[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0}; /* Send all inputs/playback to line outs */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for RME Hammerfall DSP interface.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for RME Hammerfall DSP interface.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable/disable specific Hammerfall DSP soundcards.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(precise_ptr, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(precise_ptr, bool, boot_devs, 0444);
 MODULE_PARM_DESC(precise_ptr, "Enable precise pointer (doesn't work reliably).");
 MODULE_PARM_SYNTAX(precise_ptr, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
-MODULE_PARM(line_outs_monitor,"1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(line_outs_monitor, bool, boot_devs, 0444);
 MODULE_PARM_DESC(line_outs_monitor, "Send all input and playback streams to line outs by default.");
 MODULE_PARM_SYNTAX(line_outs_monitor, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 MODULE_AUTHOR("Paul Davis <paul@linuxaudiosystems.com>, Marcus Andersson, Thomas Charbonnel <thomas@undata.org>");
@@ -5198,14 +5199,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_hdsp_init(void)
 {
-	if (pci_module_init(&driver) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "RME Hammerfall-DSP: no cards found\n");
-#endif
-		return -ENODEV;
-	}
-
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_hdsp_exit(void)
@@ -5215,24 +5209,3 @@ static void __exit alsa_card_hdsp_exit(v
 
 module_init(alsa_card_hdsp_init)
 module_exit(alsa_card_hdsp_exit)
-
-#ifndef MODULE
-
-/* format is: snd-hdsp=enable,index,id */
-
-static int __init alsa_card_hdsp_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-hdsp=", alsa_card_hdsp_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/rme9652/rme9652.c linux/sound/pci/rme9652/rme9652.c
--- linux-2.6.5/sound/pci/rme9652/rme9652.c	2004-04-04 05:36:57.000000000 +0200
+++ linux/sound/pci/rme9652/rme9652.c	2004-04-13 13:09:41.000000000 +0200
@@ -26,13 +26,13 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 #include <sound/info.h>
 #include <sound/asoundef.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <asm/current.h>
@@ -42,17 +42,18 @@ static int index[SNDRV_CARDS] = SNDRV_DE
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int precise_ptr[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = 0 }; /* Enable precise pointer */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for RME Digi9652 (Hammerfall) soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for RME Digi9652 (Hammerfall) soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable/disable specific RME96{52,36} soundcards.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(precise_ptr, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(precise_ptr, bool, boot_devs, 0444);
 MODULE_PARM_DESC(precise_ptr, "Enable precise pointer (doesn't work reliably).");
 MODULE_PARM_SYNTAX(precise_ptr, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 MODULE_AUTHOR("Paul Davis <pbd@op.net>, Winfried Ritsch");
@@ -2748,14 +2749,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_hammerfall_init(void)
 {
-	if (pci_module_init(&driver) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "RME Digi9652/Digi9636: no cards found\n");
-#endif
-		return -ENODEV;
-	}
-
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_hammerfall_exit(void)
@@ -2765,24 +2759,3 @@ static void __exit alsa_card_hammerfall_
 
 module_init(alsa_card_hammerfall_init)
 module_exit(alsa_card_hammerfall_exit)
-
-#ifndef MODULE
-
-/* format is: snd-rme9652=enable,index,id */
-
-static int __init alsa_card_rme9652_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-rme9652=", alsa_card_rme9652_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/sonicvibes.c linux/sound/pci/sonicvibes.c
--- linux-2.6.5/sound/pci/sonicvibes.c	2004-04-04 05:37:37.000000000 +0200
+++ linux/sound/pci/sonicvibes.c	2004-04-13 13:10:10.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -36,7 +37,6 @@
 #include <sound/control.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <asm/io.h>
@@ -60,23 +60,24 @@ static int enable[SNDRV_CARDS] = SNDRV_D
 static int reverb[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
 static int mge[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
 static unsigned int dmaio = 0x7a00;	/* DDMA i/o address */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for S3 SonicVibes soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for S3 SonicVibes soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable S3 SonicVibes soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(reverb, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(reverb, bool, boot_devs, 0444);
 MODULE_PARM_DESC(reverb, "Enable reverb (SRAM is present) for S3 SonicVibes soundcard.");
 MODULE_PARM_SYNTAX(reverb, SNDRV_ENABLED "," SNDRV_ENABLE_DESC);
-MODULE_PARM(mge, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mge, bool, boot_devs, 0444);
 MODULE_PARM_DESC(mge, "MIC Gain Enable for S3 SonicVibes soundcard.");
 MODULE_PARM_SYNTAX(mge, SNDRV_ENABLED "," SNDRV_ENABLE_DESC);
-MODULE_PARM(dmaio, "i");
+module_param(dmaio, uint, 0444);
 MODULE_PARM_DESC(dmaio, "DDMA i/o base address for S3 SonicVibes soundcard.");
 MODULE_PARM_SYNTAX(dmaio, "global," SNDRV_PORT_DESC);
 
@@ -1535,15 +1536,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_sonicvibes_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "S3 SonicVibes soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_sonicvibes_exit(void)
@@ -1553,28 +1546,3 @@ static void __exit alsa_card_sonicvibes_
 
 module_init(alsa_card_sonicvibes_init)
 module_exit(alsa_card_sonicvibes_exit)
-
-#ifndef MODULE
-
-/* format is: snd-sonicvibes=enable,index,id,
-			     reverb,mge,dmaio */
-
-static int __init alsa_card_sonicvibes_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&reverb[nr_dev]) == 2 &&
-	       get_option(&str,&mge[nr_dev]) == 2 &&
-	       get_option(&str,(int *)&dmaio) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-sonicvibes=", alsa_card_sonicvibes_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/trident/trident.c linux/sound/pci/trident/trident.c
--- linux-2.6.5/sound/pci/trident/trident.c	2004-04-04 05:36:12.000000000 +0200
+++ linux/sound/pci/trident/trident.c	2004-04-13 13:10:22.000000000 +0200
@@ -25,9 +25,9 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/time.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/trident.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, <audio@tridentmicro.com>");
@@ -52,20 +52,21 @@ static char *id[SNDRV_CARDS] = SNDRV_DEF
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 32};
 static int wavetable_size[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8192};
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Trident 4DWave PCI soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Trident 4DWave PCI soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Trident 4DWave PCI soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(pcm_channels, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pcm_channels, int, boot_devs, 0444);
 MODULE_PARM_DESC(pcm_channels, "Number of hardware channels assigned for PCM.");
 MODULE_PARM_SYNTAX(pcm_channels, SNDRV_ENABLED ",default:32,allows:{{1,32}}");
-MODULE_PARM(wavetable_size, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(wavetable_size, int, boot_devs, 0444);
 MODULE_PARM_DESC(wavetable_size, "Maximum memory size in kB for wavetable synth.");
 MODULE_PARM_SYNTAX(wavetable_size, SNDRV_ENABLED ",default:8192,skill:advanced");
 
@@ -169,56 +170,28 @@ static int __devinit snd_trident_probe(s
 		snd_card_free(card);
 		return err;
 	}
-	pci_set_drvdata(pci, trident);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
 static void __devexit snd_trident_remove(struct pci_dev *pci)
 {
-	trident_t *trident = snd_magic_cast(trident_t, pci_get_drvdata(pci), return);
-	if (trident)
-		snd_card_free(trident->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
-#ifdef CONFIG_PM
-static int snd_card_trident_suspend(struct pci_dev *pci, u32 state)
-{
-	trident_t *chip = snd_magic_cast(trident_t, pci_get_drvdata(pci), return -ENXIO);
-	snd_trident_suspend(chip);
-	return 0;
-}
-static int snd_card_trident_resume(struct pci_dev *pci)
-{
-	trident_t *chip = snd_magic_cast(trident_t, pci_get_drvdata(pci), return -ENXIO);
-	snd_trident_resume(chip);
-	return 0;
-}
-#endif
-
 static struct pci_driver driver = {
 	.name = "Trident4DWaveAudio",
 	.id_table = snd_trident_ids,
 	.probe = snd_trident_probe,
 	.remove = __devexit_p(snd_trident_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_card_trident_suspend,
-	.resume = snd_card_trident_resume,
-#endif
+	SND_PCI_PM_CALLBACKS
 };
 
 static int __init alsa_card_trident_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Trident 4DWave PCI soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_trident_exit(void)
@@ -228,27 +201,3 @@ static void __exit alsa_card_trident_exi
 
 module_init(alsa_card_trident_init)
 module_exit(alsa_card_trident_exit)
-
-#ifndef MODULE
-
-/* format is: snd-trident=enable,index,id,
-			  pcm_channels,wavetable_size */
-
-static int __init alsa_card_trident_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option(&str,&pcm_channels[nr_dev]) == 2 &&
-	       get_option(&str,&wavetable_size[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-trident=", alsa_card_trident_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/trident/trident_main.c linux/sound/pci/trident/trident_main.c
--- linux-2.6.5/sound/pci/trident/trident_main.c	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/pci/trident/trident_main.c	2004-04-14 11:53:54.000000000 +0200
@@ -50,7 +50,8 @@ static int snd_trident_pcm_mixer_build(t
 static int snd_trident_pcm_mixer_free(trident_t *trident, snd_trident_voice_t * voice, snd_pcm_substream_t *substream);
 static irqreturn_t snd_trident_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 #ifdef CONFIG_PM
-static int snd_trident_set_power_state(snd_card_t *card, unsigned int power_state);
+static int snd_trident_suspend(snd_card_t *card, unsigned int state);
+static int snd_trident_resume(snd_card_t *card, unsigned int state);
 #endif
 static int snd_trident_sis_reset(trident_t *trident);
 
@@ -3646,10 +3647,8 @@ int __devinit snd_trident_create(snd_car
 
 	snd_trident_enable_eso(trident);
 
-#ifdef CONFIG_PM
-	card->set_power_state = snd_trident_set_power_state;
-	card->power_state_private_data = trident;
-#endif
+	
+	snd_card_set_pm_callback(card, snd_trident_suspend, snd_trident_resume, trident);
 
 	snd_trident_proc_init(trident);
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, trident, &ops)) < 0) {
@@ -3949,19 +3948,21 @@ void snd_trident_clear_voices(trident_t 
 }
 
 #ifdef CONFIG_PM
-
-void snd_trident_suspend(trident_t *trident)
+static int snd_trident_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = trident->card;
+	trident_t *trident = snd_magic_cast(trident_t, card->pm_private_data, return -EINVAL);
 
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
 	trident->in_suspend = 1;
 	snd_pcm_suspend_all(trident->pcm);
 	if (trident->foldback)
 		snd_pcm_suspend_all(trident->foldback);
 	if (trident->spdif)
 		snd_pcm_suspend_all(trident->spdif);
+
+	snd_ac97_suspend(trident->ac97);
+	if (trident->ac97_sec)
+		snd_ac97_suspend(trident->ac97_sec);
+
 	switch (trident->device) {
 	case TRIDENT_DEVICE_ID_DX:
 	case TRIDENT_DEVICE_ID_NX:
@@ -3970,14 +3971,12 @@ void snd_trident_suspend(trident_t *trid
 		break;
 	}
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-void snd_trident_resume(trident_t *trident)
+static int snd_trident_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = trident->card;
-
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
+	trident_t *trident = snd_magic_cast(trident_t, card->pm_private_data, return -EINVAL);
 
 	pci_enable_device(trident->pci);
 	if (pci_set_dma_mask(trident->pci, 0x3fffffff) < 0 ||
@@ -3998,6 +3997,8 @@ void snd_trident_resume(trident_t *tride
 	}
 
 	snd_ac97_resume(trident->ac97);
+	if (trident->ac97_sec)
+		snd_ac97_resume(trident->ac97_sec);
 
 	/* restore some registers */
 	outl(trident->musicvol_wavevol, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
@@ -4006,28 +4007,8 @@ void snd_trident_resume(trident_t *tride
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	trident->in_suspend = 0;
+	return 0;
 }
-
-static int snd_trident_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	trident_t *chip = snd_magic_cast(trident_t, card->power_state_private_data, return -ENXIO);
-        
-	switch (power_state) {
-        case SNDRV_CTL_POWER_D0:
-        case SNDRV_CTL_POWER_D1:
-        case SNDRV_CTL_POWER_D2:
-        	snd_trident_resume(chip);
-                break;
-	case SNDRV_CTL_POWER_D3hot:
-        case SNDRV_CTL_POWER_D3cold:
-		snd_trident_suspend(chip);
-		break;
-        default:
-	        return -EINVAL;
-        }
-        return 0;
-}
-
 #endif /* CONFIG_PM */
 
 EXPORT_SYMBOL(snd_trident_alloc_voice);
diff -rup linux-2.6.5/sound/pci/via82xx.c linux/sound/pci/via82xx.c
--- linux-2.6.5/sound/pci/via82xx.c	2004-04-04 05:37:59.000000000 +0200
+++ linux/sound/pci/via82xx.c	2004-04-13 13:10:42.000000000 +0200
@@ -51,13 +51,13 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/info.h>
 #include <sound/ac97_codec.h>
 #include <sound/mpu401.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #if 0
@@ -84,31 +84,32 @@ static int joystick[SNDRV_CARDS];
 static int ac97_clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 48000};
 static int ac97_quirk[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = AC97_TUNE_DEFAULT};
 static int dxs_support[SNDRV_CARDS];
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for VIA 82xx bridge.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for VIA 82xx bridge.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable audio part of VIA 82xx bridge.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port. (VT82C686x only)");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_PORT_DESC);
 #ifdef SUPPORT_JOYSTICK
-MODULE_PARM(joystick, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(joystick, bool, boot_devs, 0444);
 MODULE_PARM_DESC(joystick, "Enable joystick. (VT82C686x only)");
 MODULE_PARM_SYNTAX(joystick, SNDRV_ENABLE_DESC "," SNDRV_BOOLEAN_FALSE_DESC);
 #endif
-MODULE_PARM(ac97_clock, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ac97_clock, int, boot_devs, 0444);
 MODULE_PARM_DESC(ac97_clock, "AC'97 codec clock (default 48000Hz).");
 MODULE_PARM_SYNTAX(ac97_clock, SNDRV_ENABLED ",default:48000");
-MODULE_PARM(ac97_quirk, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ac97_quirk, int, boot_devs, 0444);
 MODULE_PARM_DESC(ac97_quirk, "AC'97 workaround for strange hardware.");
 MODULE_PARM_SYNTAX(ac97_quirk, SNDRV_ENABLED ",allows:{{-1,4}},dialog:list,default:-1");
-MODULE_PARM(dxs_support, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(dxs_support, int, boot_devs, 0444);
 MODULE_PARM_DESC(dxs_support, "Support for DXS channels (0 = auto, 1 = enable, 2 = disable, 3 = 48k only, 4 = no VRA)");
 MODULE_PARM_SYNTAX(dxs_support, SNDRV_ENABLED ",allows:{{0,4}},dialog:list");
 
@@ -1584,6 +1585,12 @@ static struct ac97_quirk ac97_quirks[] =
 		.name = "Mitac Mobo",
 		.type = AC97_TUNE_ALC_JACK
 	},
+	{
+		.vendor = 0x161f,
+		.device = 0x202b,
+		.name = "Arima Notebook",
+		.type = AC97_TUNE_HP_ONLY,
+	},
 	{ } /* terminator */
 };
 
@@ -2025,6 +2032,7 @@ static int __devinit check_dxs_list(stru
 		{ .vendor = 0x1462, .device = 0x7120, .action = VIA_DXS_ENABLE }, /* MSI KT4V */
 		{ .vendor = 0x1462, .device = 0x5901, .action = VIA_DXS_NO_VRA }, /* MSI KT6 Delta-SR */
 		{ .vendor = 0x1584, .device = 0x8120, .action = VIA_DXS_ENABLE }, /* Gericom/Targa/Vobis/Uniwill laptop */
+		{ .vendor = 0x161f, .device = 0x202b, .action = VIA_DXS_NO_VRA }, /* Amira Note book */
 		{ .vendor = 0x1631, .device = 0xe004, .action = VIA_DXS_ENABLE }, /* Easy Note 3174, Packard Bell */
 		{ .vendor = 0x1695, .device = 0x3005, .action = VIA_DXS_ENABLE }, /* EPoX EP-8K9A */
 		{ .vendor = 0x1849, .device = 0x3059, .action = VIA_DXS_NO_VRA }, /* ASRock K7VM2 */
@@ -2182,15 +2190,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_via82xx_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "VIA 82xx soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_via82xx_exit(void)
@@ -2200,33 +2200,3 @@ static void __exit alsa_card_via82xx_exi
 
 module_init(alsa_card_via82xx_init)
 module_exit(alsa_card_via82xx_exit)
-
-#ifndef MODULE
-
-/* format is: snd-via82xx=enable,index,id,
-			  mpu_port,joystick,
-			  ac97_quirk,ac97_clock,dxs_support */
-
-static int __init alsa_card_via82xx_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2 &&
-#ifdef SUPPORT_JOYSTICK
-	       get_option(&str,&joystick[nr_dev]) == 2 &&
-#endif
-	       get_option(&str,&ac97_quirk[nr_dev]) == 2 &&
-	       get_option(&str,&ac97_clock[nr_dev]) == 2 &&
-	       get_option(&str,&dxs_support[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-via82xx=", alsa_card_via82xx_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/vx222/vx222.c linux/sound/pci/vx222/vx222.c
--- linux-2.6.5/sound/pci/vx222/vx222.c	2004-04-04 05:37:07.000000000 +0200
+++ linux/sound/pci/vx222/vx222.c	2004-04-13 13:10:57.000000000 +0200
@@ -23,8 +23,8 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include "vx222.h"
 
@@ -43,20 +43,21 @@ static char *id[SNDRV_CARDS] = SNDRV_DEF
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int mic[SNDRV_CARDS]; /* microphone */
 static int ibl[SNDRV_CARDS]; /* microphone */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Digigram " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Digigram " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Digigram " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(mic, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(mic, bool, boot_devs, 0444);
 MODULE_PARM_DESC(mic, "Enable Microphone.");
 MODULE_PARM_SYNTAX(mic, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
-MODULE_PARM(ibl, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ibl, int, boot_devs, 0444);
 MODULE_PARM_DESC(ibl, "Capture IBL size.");
 MODULE_PARM_SYNTAX(ibl, SNDRV_ENABLED);
 
@@ -272,15 +273,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_vx222_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Digigram VX222 soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_vx222_exit(void)
@@ -290,24 +283,3 @@ static void __exit alsa_card_vx222_exit(
 
 module_init(alsa_card_vx222_init)
 module_exit(alsa_card_vx222_exit)
-
-#ifndef MODULE
-
-/* format is: snd-vx222=enable,index,id */
-
-static int __init alsa_card_vx222_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-vx222=", alsa_card_vx222_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/ymfpci/ymfpci.c linux/sound/pci/ymfpci/ymfpci.c
--- linux-2.6.5/sound/pci/ymfpci/ymfpci.c	2004-04-04 05:36:57.000000000 +0200
+++ linux/sound/pci/ymfpci/ymfpci.c	2004-04-13 13:11:08.000000000 +0200
@@ -23,11 +23,11 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/time.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/ymfpci.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
@@ -50,28 +50,29 @@ static long mpu_port[SNDRV_CARDS];
 static long joystick_port[SNDRV_CARDS];
 #endif
 static int rear_switch[SNDRV_CARDS];
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for the Yamaha DS-XG PCI soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for the Yamaha DS-XG PCI soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Yamaha DS-XG soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(mpu_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(mpu_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 Port.");
 MODULE_PARM_SYNTAX(mpu_port, SNDRV_ENABLED);
-MODULE_PARM(fm_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(fm_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(fm_port, "FM OPL-3 Port.");
 MODULE_PARM_SYNTAX(fm_port, SNDRV_ENABLED);
 #ifdef SUPPORT_JOYSTICK
-MODULE_PARM(joystick_port, "1-" __MODULE_STRING(SNDRV_CARDS) "l");
+module_param_array(joystick_port, long, boot_devs, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address");
 MODULE_PARM_SYNTAX(joystick_port, SNDRV_ENABLED);
 #endif
-MODULE_PARM(rear_switch, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(rear_switch, bool, boot_devs, 0444);
 MODULE_PARM_DESC(rear_switch, "Enable shared rear/line-in switch");
 MODULE_PARM_SYNTAX(rear_switch, SNDRV_ENABLED "," SNDRV_BOOLEAN_FALSE_DESC);
 
@@ -311,31 +312,14 @@ static int __devinit snd_card_ymfpci_pro
 		snd_card_free(card);
 		return err;
 	}
-	pci_set_drvdata(pci, chip);
+	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int snd_card_ymfpci_suspend(struct pci_dev *pci, u32 state)
-{
-	ymfpci_t *chip = snd_magic_cast(ymfpci_t, pci_get_drvdata(pci), return -ENXIO);
-	snd_ymfpci_suspend(chip);
-	return 0;
-}
-static int snd_card_ymfpci_resume(struct pci_dev *pci)
-{
-	ymfpci_t *chip = snd_magic_cast(ymfpci_t, pci_get_drvdata(pci), return -ENXIO);
-	snd_ymfpci_resume(chip);
-	return 0;
-}
-#endif
-
 static void __devexit snd_card_ymfpci_remove(struct pci_dev *pci)
 {
-	ymfpci_t *chip = snd_magic_cast(ymfpci_t, pci_get_drvdata(pci), return);
-	if (chip)
-		snd_card_free(chip->card);
+	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
 }
 
@@ -344,23 +328,12 @@ static struct pci_driver driver = {
 	.id_table = snd_ymfpci_ids,
 	.probe = snd_card_ymfpci_probe,
 	.remove = __devexit_p(snd_card_ymfpci_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_card_ymfpci_suspend,
-	.resume = snd_card_ymfpci_resume,
-#endif	
+	SND_PCI_PM_CALLBACKS
 };
 
 static int __init alsa_card_ymfpci_init(void)
 {
-	int err;
-
-	if ((err = pci_module_init(&driver)) < 0) {
-#ifdef MODULE
-		printk(KERN_ERR "Yamaha DS-XG PCI soundcard not found or device busy\n");
-#endif
-		return err;
-	}
-	return 0;
+	return pci_module_init(&driver);
 }
 
 static void __exit alsa_card_ymfpci_exit(void)
@@ -370,27 +343,3 @@ static void __exit alsa_card_ymfpci_exit
 
 module_init(alsa_card_ymfpci_init)
 module_exit(alsa_card_ymfpci_exit)
-
-#ifndef MODULE
-
-/* format is: snd-ymfpci=enable,index,id,
-			 fm_port,mpu_port */
-
-static int __init alsa_card_ymfpci_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&enable[nr_dev]) == 2 &&
-	       get_option(&str,&index[nr_dev]) == 2 &&
-	       get_id(&str,&id[nr_dev]) == 2 &&
-	       get_option_long(&str,&fm_port[nr_dev]) == 2 &&
-	       get_option_long(&str,&mpu_port[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-ymfpci=", alsa_card_ymfpci_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/pci/ymfpci/ymfpci_main.c linux/sound/pci/ymfpci/ymfpci_main.c
--- linux-2.6.5/sound/pci/ymfpci/ymfpci_main.c	2004-04-04 05:38:12.000000000 +0200
+++ linux/sound/pci/ymfpci/ymfpci_main.c	2004-04-14 12:24:59.000000000 +0200
@@ -2157,33 +2157,30 @@ static int saved_regs_index[] = {
 };
 #define YDSXGR_NUM_SAVED_REGS	ARRAY_SIZE(saved_regs_index)
 
-void snd_ymfpci_suspend(ymfpci_t *chip)
+static int snd_ymfpci_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	ymfpci_t *chip = snd_magic_cast(ymfpci_t, card->pm_private_data, return -EINVAL);
 	unsigned int i;
 	
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
 	snd_pcm_suspend_all(chip->pcm);
 	snd_pcm_suspend_all(chip->pcm2);
 	snd_pcm_suspend_all(chip->pcm_spdif);
 	snd_pcm_suspend_all(chip->pcm_4ch);
+	snd_ac97_suspend(chip->ac97);
 	for (i = 0; i < YDSXGR_NUM_SAVED_REGS; i++)
 		chip->saved_regs[i] = snd_ymfpci_readl(chip, saved_regs_index[i]);
 	chip->saved_ydsxgr_mode = snd_ymfpci_readl(chip, YDSXGR_MODE);
 	snd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0);
 	snd_ymfpci_disable_dsp(chip);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-void snd_ymfpci_resume(ymfpci_t *chip)
+static int snd_ymfpci_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	ymfpci_t *chip = snd_magic_cast(ymfpci_t, card->pm_private_data, return -EINVAL);
 	unsigned int i;
 
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
-
 	pci_enable_device(chip->pci);
 	pci_set_master(chip->pci);
 	snd_ymfpci_aclink_reset(chip->pci);
@@ -2205,25 +2202,6 @@ void snd_ymfpci_resume(ymfpci_t *chip)
 		spin_unlock_irqrestore(&chip->reg_lock, flags);
 	}
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-static int snd_ymfpci_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	ymfpci_t *chip = snd_magic_cast(ymfpci_t, card->power_state_private_data, return -ENXIO);
-
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		snd_ymfpci_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		snd_ymfpci_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -2304,8 +2282,7 @@ int __devinit snd_ymfpci_create(snd_card
 		snd_ymfpci_free(chip);
 		return -ENOMEM;
 	}
-	card->set_power_state = snd_ymfpci_set_power_state;
-	card->power_state_private_data = chip;
+	snd_card_set_pm_callback(card, snd_ymfpci_suspend, snd_ymfpci_resume, chip);
 #endif
 
 	snd_ymfpci_proc_init(card, chip);
diff -rup linux-2.6.5/sound/pcmcia/Kconfig linux/sound/pcmcia/Kconfig
--- linux-2.6.5/sound/pcmcia/Kconfig	2004-04-04 05:37:07.000000000 +0200
+++ linux/sound/pcmcia/Kconfig	2004-04-03 16:22:40.000000000 +0200
@@ -20,6 +20,7 @@ config SND_VXP440
 config SND_PDAUDIOCF
 	tristate "Sound Core PDAudioCF"
 	depends on SND && PCMCIA && ISA
+	select SND_PCM
 	help
 	  Say 'Y' or 'M' to include support for Sound Core PDAudioCF soundcard.
 
diff -rup linux-2.6.5/sound/pcmcia/pdaudiocf/pdaudiocf.c linux/sound/pcmcia/pdaudiocf/pdaudiocf.c
--- linux-2.6.5/sound/pcmcia/pdaudiocf/pdaudiocf.c	2004-04-04 05:36:54.000000000 +0200
+++ linux/sound/pcmcia/pdaudiocf/pdaudiocf.c	2004-04-08 16:04:27.000000000 +0200
@@ -21,6 +21,7 @@
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <linux/slab.h>
+#include <linux/moduleparam.h>
 #include <pcmcia/version.h>
 #include <pcmcia/ciscode.h>
 #include <pcmcia/cisreg.h>
@@ -43,19 +44,20 @@ static char *id[SNDRV_CARDS] = SNDRV_DEF
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
 static unsigned int irq_mask = 0xffff;
 static int irq_list[4] = { -1 };
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(irq_mask, "i");
+module_param(irq_mask, int, 0444);
 MODULE_PARM_DESC(irq_mask, "IRQ bitmask for " CARD_NAME " soundcard.");
-MODULE_PARM(irq_list, "1-4i");
+module_param_array(irq_list, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq_list, "List of Available interrupts for " CARD_NAME " soundcard.");
  
 
@@ -241,10 +243,7 @@ static int snd_pdacf_assign_resources(pd
 	if (err < 0)
 		return err;
 
-#ifdef CONFIG_PM
-	card->power_state_private_data = pdacf;
-	card->set_power_state = snd_pdacf_set_power_state;
-#endif
+	snd_card_set_pm_callback(card, snd_pdacf_suspend, snd_pdacf_resume, pdacf);
 
 	if ((err = snd_card_register(card)) < 0)
 		return err;
@@ -369,7 +368,7 @@ static int pdacf_event(event_t event, in
 		link->state |= DEV_SUSPEND;
 		if (chip) {
 			snd_printdd(KERN_DEBUG "snd_pdacf_suspend calling\n");
-			snd_pdacf_suspend(chip);
+			snd_pdacf_suspend(chip->card, 0);
 		}
 		/* Fall through... */
 	case CS_EVENT_RESET_PHYSICAL:
@@ -388,7 +387,7 @@ static int pdacf_event(event_t event, in
 			pcmcia_request_configuration(link->handle, &link->conf);
 			if (chip) {
 				snd_printdd(KERN_DEBUG "calling snd_pdacf_resume\n");
-				snd_pdacf_resume(chip);
+				snd_pdacf_resume(chip->card, 0);
 			}
 		}
 		snd_printdd(KERN_DEBUG "resume done!\n");
diff -rup linux-2.6.5/sound/pcmcia/pdaudiocf/pdaudiocf.h linux/sound/pcmcia/pdaudiocf/pdaudiocf.h
--- linux-2.6.5/sound/pcmcia/pdaudiocf/pdaudiocf.h	2004-04-04 05:36:14.000000000 +0200
+++ linux/sound/pcmcia/pdaudiocf/pdaudiocf.h	2004-04-08 16:04:09.000000000 +0200
@@ -136,9 +136,8 @@ pdacf_t *snd_pdacf_create(snd_card_t *ca
 int snd_pdacf_ak4117_create(pdacf_t *pdacf);
 void snd_pdacf_powerdown(pdacf_t *chip);
 #ifdef CONFIG_PM
-void snd_pdacf_suspend(pdacf_t *chip);
-void snd_pdacf_resume(pdacf_t *chip);
-int snd_pdacf_set_power_state(snd_card_t *card, unsigned int power_state);
+int snd_pdacf_suspend(snd_card_t *card, unsigned int state);
+int snd_pdacf_resume(snd_card_t *card, unsigned int state);
 #endif
 int snd_pdacf_pcm_new(pdacf_t *chip);
 void pdacf_interrupt(int irq, void *dev, struct pt_regs *regs);
diff -rup linux-2.6.5/sound/pcmcia/pdaudiocf/pdaudiocf_core.c linux/sound/pcmcia/pdaudiocf/pdaudiocf_core.c
--- linux-2.6.5/sound/pcmcia/pdaudiocf/pdaudiocf_core.c	2004-04-04 05:36:52.000000000 +0200
+++ linux/sound/pcmcia/pdaudiocf/pdaudiocf_core.c	2004-04-08 16:00:24.000000000 +0200
@@ -255,13 +255,11 @@ void snd_pdacf_powerdown(pdacf_t *chip)
 
 #ifdef CONFIG_PM
 
-void snd_pdacf_suspend(pdacf_t *chip)
+int snd_pdacf_suspend(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	pdacf_t *chip = snd_magic_cast(pdacf_t, card->pm_private_data, return -EINVAL);
 	u16 val;
 	
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
 	snd_pcm_suspend_all(chip->pcm);
 	/* disable interrupts, but use direct write to preserve old register value in chip->regmap */
 	val = inw(chip->port + PDAUDIOCF_REG_IER);
@@ -270,6 +268,7 @@ void snd_pdacf_suspend(pdacf_t *chip)
 	chip->chip_status |= PDAUDIOCF_STAT_IS_SUSPENDED;	/* ignore interrupts from now */
 	snd_pdacf_powerdown(chip);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
 static inline int check_signal(pdacf_t *chip)
@@ -277,13 +276,11 @@ static inline int check_signal(pdacf_t *
 	return (chip->ak4117->rcs0 & AK4117_UNLCK) == 0;
 }
 
-void snd_pdacf_resume(pdacf_t *chip)
+int snd_pdacf_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
+	pdacf_t *chip = snd_magic_cast(pdacf_t, card->pm_private_data, return -EINVAL);
 	int timeout = 40;
 
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
 	pdacf_reinit(chip, 1);
 	/* wait for AK4117's PLL */
 	while (timeout-- > 0 &&
@@ -291,26 +288,6 @@ void snd_pdacf_resume(pdacf_t *chip)
 		mdelay(1);
 	chip->chip_status &= ~PDAUDIOCF_STAT_IS_SUSPENDED;
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-}
-
-int snd_pdacf_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	pdacf_t *chip = snd_magic_cast(pdacf_t, card->power_state_private_data, return -ENXIO);
-
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		snd_pdacf_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		snd_pdacf_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
 	return 0;
 }
-
 #endif
diff -rup linux-2.6.5/sound/pcmcia/vx/vxpocket.c linux/sound/pcmcia/vx/vxpocket.c
--- linux-2.6.5/sound/pcmcia/vx/vxpocket.c	2004-04-04 05:36:26.000000000 +0200
+++ linux/sound/pcmcia/vx/vxpocket.c	2004-04-07 19:25:27.000000000 +0200
@@ -32,6 +32,7 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <pcmcia/version.h>
 #include "vxpocket.h"
@@ -58,21 +59,22 @@ static int enable[SNDRV_CARDS] = SNDRV_D
 static unsigned int irq_mask = 0xffff;
 static int irq_list[4] = { -1 };
 static int ibl[SNDRV_CARDS];
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(irq_mask, "i");
+module_param(irq_mask, int, 0444);
 MODULE_PARM_DESC(irq_mask, "IRQ bitmask for " CARD_NAME " soundcard.");
-MODULE_PARM(irq_list, "1-4i");
+module_param_array(irq_list, int, boot_devs, 0444);
 MODULE_PARM_DESC(irq_list, "List of Available interrupts for " CARD_NAME " soundcard.");
-MODULE_PARM(ibl, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(ibl, int, boot_devs, 0444);
 MODULE_PARM_DESC(ibl, "Capture IBL size for " CARD_NAME " soundcard.");
 MODULE_PARM_SYNTAX(ibl, SNDRV_ENABLED);
  
diff -rup linux-2.6.5/sound/ppc/awacs.c linux/sound/ppc/awacs.c
--- linux-2.6.5/sound/ppc/awacs.c	2004-04-04 05:37:07.000000000 +0200
+++ linux/sound/ppc/awacs.c	2004-04-07 12:51:40.000000000 +0200
@@ -574,11 +574,22 @@ static snd_kcontrol_new_t snd_pmac_awacs
 	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("Master Capture Switch", 1, SHIFT_LOOPTHRU, 0),
 	AWACS_VOLUME("Capture Volume", 0, 4, 0),
-	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_LINE, 0),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
+};
+
+/* FIXME: is this correct order?
+ * screamer (powerbook G3 pismo) seems to have different bits...
+ */
+static snd_kcontrol_new_t snd_pmac_awacs_mixers2[] __initdata = {
+	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_LINE, 0),
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
+static snd_kcontrol_new_t snd_pmac_screamer_mixers2[] __initdata = {
+	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
+	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_LINE, 0),
+};
+
 static snd_kcontrol_new_t snd_pmac_awacs_master_sw __initdata =
 AWACS_SWITCH("Master Playback Switch", 1, SHIFT_HDMUTE, 1);
 
@@ -821,6 +832,14 @@ snd_pmac_awacs_init(pmac_t *chip)
 	if ((err = build_mixers(chip, num_controls(snd_pmac_awacs_mixers),
 				snd_pmac_awacs_mixers)) < 0)
 		return err;
+	if (chip->model == PMAC_SCREAMER)
+		err = build_mixers(chip, num_controls(snd_pmac_screamer_mixers2),
+				   snd_pmac_screamer_mixers2);
+	else
+		err = build_mixers(chip, num_controls(snd_pmac_awacs_mixers2),
+				   snd_pmac_awacs_mixers2);
+	if (err < 0)
+		return err;
 	chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_master_sw, chip);
 	if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
 		return err;
diff -rup linux-2.6.5/sound/ppc/pmac.c linux/sound/ppc/pmac.c
--- linux-2.6.5/sound/ppc/pmac.c	2004-04-04 05:38:26.000000000 +0200
+++ linux/sound/ppc/pmac.c	2004-04-15 14:36:39.460485789 +0200
@@ -42,7 +42,8 @@
 #if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
 static int snd_pmac_register_sleep_notifier(pmac_t *chip);
 static int snd_pmac_unregister_sleep_notifier(pmac_t *chip);
-static int snd_pmac_set_power_state(snd_card_t *card, unsigned int power_state);
+static int snd_pmac_suspend(snd_card_t *card, unsigned int state);
+static int snd_pmac_resume(snd_card_t *card, unsigned int state);
 #endif
 
 
@@ -1170,9 +1171,8 @@
 
 #if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
 	/* add sleep notifier */
-	snd_pmac_register_sleep_notifier(chip);
-	card->set_power_state = snd_pmac_set_power_state;
-	card->power_state_private_data = chip;
+	if (! snd_pmac_register_sleep_notifier(chip))
+		snd_card_set_pm_callback(chip->card, snd_pmac_suspend, snd_pmac_resume, chip);
 #endif
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)
@@ -1197,13 +1197,10 @@
  * Save state when going to sleep, restore it afterwards.
  */
 
-static void snd_pmac_suspend(pmac_t *chip)
+static int snd_pmac_suspend(snd_card_t *card, unsigned int state)
 {
+	pmac_t *chip = snd_magic_cast(pmac_t, card->pm_private_data, return -EINVAL);
 	unsigned long flags;
-	snd_card_t *card = chip->card;
-
-	if (card->power_state == SNDRV_CTL_POWER_D3hot)
-		return;
 
 	if (chip->suspend)
 		chip->suspend(chip);
@@ -1219,14 +1216,12 @@
 		disable_irq(chip->rx_irq);
 	snd_pmac_sound_feature(chip, 0);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	return 0;
 }
 
-static void snd_pmac_resume(pmac_t *chip)
+static int snd_pmac_resume(snd_card_t *card, unsigned int state)
 {
-	snd_card_t *card = chip->card;
-
-	if (card->power_state == SNDRV_CTL_POWER_D0)
-		return;
+	pmac_t *chip = snd_magic_cast(pmac_t, card->pm_private_data, return -EINVAL);
 
 	snd_pmac_sound_feature(chip, 1);
 	if (chip->resume)
@@ -1248,6 +1243,7 @@
 		enable_irq(chip->rx_irq);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
 }
 
 /* the chip is stored statically by snd_pmac_register_sleep_notifier
@@ -1264,10 +1260,10 @@
 
 	switch (when) {
 	case PBOOK_SLEEP_NOW:
-		snd_pmac_suspend(chip);
+		snd_pmac_suspend(chip->card, 0);
 		break;
 	case PBOOK_WAKE:
-		snd_pmac_resume(chip);
+		snd_pmac_resume(chip->card, 0);
 		break;
 	}
 	return PBOOK_SLEEP_OK;
@@ -1280,46 +1276,19 @@
 static int __init snd_pmac_register_sleep_notifier(pmac_t *chip)
 {
 	/* should be protected here.. */
-	if (sleeping_pmac) {
-		snd_printd("sleep notifier already reigistered\n");
-		return -EBUSY;
-	}
+	snd_assert(! sleeping_pmac, return -EBUSY);
 	sleeping_pmac = chip;
 	pmu_register_sleep_notifier(&snd_pmac_sleep_notifier);
-	chip->sleep_registered = 1;
 	return 0;
 }
 						    
 static int snd_pmac_unregister_sleep_notifier(pmac_t *chip)
 {
-	if (! chip->sleep_registered)
-		return 0;
 	/* should be protected here.. */
-	if (sleeping_pmac != chip)
-		return -ENODEV;
+	snd_assert(sleeping_pmac == chip, return -ENODEV);
 	pmu_unregister_sleep_notifier(&snd_pmac_sleep_notifier);
 	sleeping_pmac = NULL;
 	return 0;
 }
 
-/* callback */
-static int snd_pmac_set_power_state(snd_card_t *card, unsigned int power_state)
-{
-	pmac_t *chip = snd_magic_cast(pmac_t, card->power_state_private_data, return -ENXIO);
-	switch (power_state) {
-	case SNDRV_CTL_POWER_D0:
-	case SNDRV_CTL_POWER_D1:
-	case SNDRV_CTL_POWER_D2:
-		snd_pmac_resume(chip);
-		break;
-	case SNDRV_CTL_POWER_D3hot:
-	case SNDRV_CTL_POWER_D3cold:
-		snd_pmac_suspend(chip);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
 #endif /* CONFIG_PM && CONFIG_PMAC_PBOOK */
diff -rup linux-2.6.5/sound/ppc/pmac.h linux/sound/ppc/pmac.h
--- linux-2.6.5/sound/ppc/pmac.h	2004-04-04 05:37:36.000000000 +0200
+++ linux/sound/ppc/pmac.h	2004-04-15 14:36:48.591413860 +0200
@@ -162,7 +162,6 @@ struct snd_pmac {
 	void (*update_automute)(pmac_t *chip, int do_notify);
 	int (*detect_headphone)(pmac_t *chip);
 #ifdef CONFIG_PMAC_PBOOK
-	unsigned int sleep_registered : 1;
 	void (*suspend)(pmac_t *chip);
 	void (*resume)(pmac_t *chip);
 #endif
diff -rup linux-2.6.5/sound/ppc/powermac.c linux/sound/ppc/powermac.c
--- linux-2.6.5/sound/ppc/powermac.c	2004-04-04 05:38:25.000000000 +0200
+++ linux/sound/ppc/powermac.c	2004-04-07 16:33:16.000000000 +0200
@@ -20,8 +20,8 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include "pmac.h"
 #include "awacs.h"
@@ -41,17 +41,17 @@ static char *id = SNDRV_DEFAULT_STR1;		/
 static int enable_beep = 1;
 #endif
 
-MODULE_PARM(index, "i");
+module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for " CHIP_NAME " soundchip.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "s");
+module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for " CHIP_NAME " soundchip.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-/* MODULE_PARM(enable, "i");
+/* module_param(enable, bool, 0444);
    MODULE_PARM_DESC(enable, "Enable this soundchip.");
    MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC); */
 #ifdef PMAC_SUPPORT_PCM_BEEP
-MODULE_PARM(enable_beep, "i");
+module_param(enable_beep, bool, 0444);
 MODULE_PARM_DESC(enable_beep, "Enable beep using PCM.");
 MODULE_PARM_SYNTAX(enable_beep, SNDRV_ENABLED "," SNDRV_BOOLEAN_TRUE_DESC);
 #endif
@@ -175,26 +175,3 @@ static void __exit alsa_card_pmac_exit(v
 
 module_init(alsa_card_pmac_init)
 module_exit(alsa_card_pmac_exit)
-
-#ifndef MODULE
-
-/* format is: snd-pmac=enable,index,id,enable_beep
- */
-
-static int __init alsa_card_pmac_setup(char *str)
-{
-	int __attribute__ ((__unused__)) enable = 1;
-
-	(void)(get_option(&str,&enable) == 2 &&
-	       get_option(&str,&index) == 2 &&
-	       get_id(&str,&id) == 2
-#ifdef PMAC_SUPPORT_PCM_BEEP
-	       && get_option(&str,&enable_beep) == 2
-#endif
-	       );
-	return 1;
-}
-
-__setup("snd-pmac=", alsa_card_pmac_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/sparc/amd7930.c linux/sound/sparc/amd7930.c
--- linux-2.6.5/sound/sparc/amd7930.c	2004-04-04 05:36:26.000000000 +0200
+++ linux/sound/sparc/amd7930.c	2004-04-07 17:01:11.000000000 +0200
@@ -34,13 +34,13 @@
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/moduleparam.h>
 
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/info.h>
 #include <sound/control.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include <asm/io.h>
@@ -50,14 +50,15 @@
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Sun AMD7930 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Sun AMD7930 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Sun AMD7930 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 MODULE_AUTHOR("Thomas K. Dyas and David S. Miller");
@@ -1152,24 +1153,3 @@ static void __exit amd7930_exit(void)
 
 module_init(amd7930_init);
 module_exit(amd7930_exit);
-
-#ifndef MODULE
-
-/* format is: snd-sun-amd7930=index,id,enable */
-
-static int __init alsa_card_sun_amd7930_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&index[nr_dev]) == 2 &&
-	       get_option(&str,&id[nr_dev]) == 2 &&
-	       get_id(&str,&enable[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-sun-amd7930=", alsa_card_sun_amd7930_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/sparc/cs4231.c linux/sound/sparc/cs4231.c
--- linux-2.6.5/sound/sparc/cs4231.c	2004-04-04 05:36:16.000000000 +0200
+++ linux/sound/sparc/cs4231.c	2004-04-07 17:01:04.000000000 +0200
@@ -15,6 +15,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/moduleparam.h>
 
 #include <sound/driver.h>
 #include <sound/core.h>
@@ -22,7 +23,6 @@
 #include <sound/info.h>
 #include <sound/control.h>
 #include <sound/timer.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 #include <sound/pcm_params.h>
 
@@ -49,14 +49,15 @@
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for Sun CS4231 soundcard.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for Sun CS4231 soundcard.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable Sun CS4231 soundcard.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 MODULE_AUTHOR("Jaroslav Kysela, Derrick J. Brashear and David S. Miller");
@@ -2251,24 +2252,3 @@ static void __exit cs4231_exit(void)
 
 module_init(cs4231_init);
 module_exit(cs4231_exit);
-
-#ifndef MODULE
-
-/* format is: snd-sun-cs4231=index,id,enable */
-
-static int __init alsa_card_sun_cs4231_setup(char *str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str,&index[nr_dev]) == 2 &&
-	       get_option(&str,&id[nr_dev]) == 2 &&
-	       get_id(&str,&enable[nr_dev]) == 2);
-	nr_dev++;
-	return 1;
-}
-
-__setup("snd-sun-cs4231=", alsa_card_sun_cs4231_setup);
-
-#endif /* ifndef MODULE */
diff -rup linux-2.6.5/sound/usb/usbaudio.c linux/sound/usb/usbaudio.c
--- linux-2.6.5/sound/usb/usbaudio.c	2004-04-04 05:37:37.000000000 +0200
+++ linux/sound/usb/usbaudio.c	2004-04-13 12:48:23.000000000 +0200
@@ -45,11 +45,11 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/usb.h>
+#include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
-#define SNDRV_GET_ID
 #include <sound/initval.h>
 
 #include "usbaudio.h"
@@ -69,26 +69,27 @@ static int vid[SNDRV_CARDS] = { [0 ... (
 static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 }; /* Product ID for this card */
 static int nrpacks = 4;		/* max. number of packets per urb */
 static int async_unlink = 1;
+static int boot_devs;
 
-MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(index, int, boot_devs, 0444);
 MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");
 MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+module_param_array(id, charp, boot_devs, 0444);
 MODULE_PARM_DESC(id, "ID string for the USB audio adapter.");
 MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(enable, bool, boot_devs, 0444);
 MODULE_PARM_DESC(enable, "Enable USB audio adapter.");
 MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
-MODULE_PARM(vid, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(vid, int, boot_devs, 0444);
 MODULE_PARM_DESC(vid, "Vendor ID for the USB audio device.");
 MODULE_PARM_SYNTAX(vid, SNDRV_ENABLED ",allows:{{-1,0xffff}},base:16");
-MODULE_PARM(pid, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+module_param_array(pid, int, boot_devs, 0444);
 MODULE_PARM_DESC(pid, "Product ID for the USB audio device.");
 MODULE_PARM_SYNTAX(pid, SNDRV_ENABLED ",allows:{{-1,0xffff}},base:16");
-MODULE_PARM(nrpacks, "i");
+module_param(nrpacks, int, 0444);
 MODULE_PARM_DESC(nrpacks, "Max. number of packets per URB.");
 MODULE_PARM_SYNTAX(nrpacks, SNDRV_ENABLED ",allows:{{1,10}}");
-MODULE_PARM(async_unlink, "i");
+module_param(async_unlink, bool, 0444);
 MODULE_PARM_DESC(async_unlink, "Use async unlink mode.");
 MODULE_PARM_SYNTAX(async_unlink, SNDRV_BOOLEAN_TRUE_DESC);
 
@@ -1146,7 +1147,7 @@ static int init_usb_pitch(struct usb_dev
 	/* if endpoint has pitch control, enable it */
 	if (fmt->attributes & EP_CS_ATTR_PITCH_CONTROL) {
 		data[0] = 1;
-		if ((err = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), SET_CUR,
+		if ((err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), SET_CUR,
 					   USB_TYPE_CLASS|USB_RECIP_ENDPOINT|USB_DIR_OUT, 
 					   PITCH_CONTROL << 8, ep, data, 1, HZ)) < 0) {
 			snd_printk(KERN_ERR "%d:%d:%d: cannot set enable PITCH\n",
@@ -1172,14 +1173,14 @@ static int init_usb_sample_rate(struct u
 		data[0] = rate;
 		data[1] = rate >> 8;
 		data[2] = rate >> 16;
-		if ((err = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), SET_CUR,
+		if ((err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), SET_CUR,
 					   USB_TYPE_CLASS|USB_RECIP_ENDPOINT|USB_DIR_OUT, 
 					   SAMPLING_FREQ_CONTROL << 8, ep, data, 3, HZ)) < 0) {
 			snd_printk(KERN_ERR "%d:%d:%d: cannot set freq %d to ep 0x%x\n",
 				   dev->devnum, iface, fmt->altsetting, rate, ep);
 			return err;
 		}
-		if ((err = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), GET_CUR,
+		if ((err = snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), GET_CUR,
 					   USB_TYPE_CLASS|USB_RECIP_ENDPOINT|USB_DIR_IN,
 					   SAMPLING_FREQ_CONTROL << 8, ep, data, 3, HZ)) < 0) {
 			snd_printk(KERN_ERR "%d:%d:%d: cannot get freq at ep 0x%x\n",
@@ -1884,6 +1885,32 @@ void *snd_usb_find_csint_desc(void *buff
 	return NULL;
 }
 
+/*
+ * Wrapper for usb_control_msg().
+ * Allocates a temp buffer to prevent dmaing from/to the stack.
+ */
+int snd_usb_ctl_msg(struct usb_device *dev, unsigned int pipe, __u8 request,
+		    __u8 requesttype, __u16 value, __u16 index, void *data,
+		    __u16 size, int timeout)
+{
+	int err;
+	void *buf = NULL;
+
+	if (size > 0) {
+		buf = kmalloc(size, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+		memcpy(buf, data, size);
+	}
+	err = usb_control_msg(dev, pipe, request, requesttype,
+			      value, index, buf, size, timeout);
+	if (size > 0) {
+		memcpy(data, buf, size);
+		kfree(buf);
+	}
+	return err;
+}
+
 
 /*
  * entry point for linux usb interface
@@ -2640,6 +2667,7 @@ static int create_fixed_stream_quirk(snd
 	struct audioformat *fp;
 	struct usb_host_interface *alts;
 	int stream, err;
+	int *rate_table = NULL;
 
 	fp = kmalloc(sizeof(*fp), GFP_KERNEL);
 	if (! fp) {
@@ -2647,16 +2675,30 @@ static int create_fixed_stream_quirk(snd
 		return -ENOMEM;
 	}
 	memcpy(fp, quirk->data, sizeof(*fp));
+	if (fp->nr_rates > 0) {
+		rate_table = kmalloc(sizeof(int) * fp->nr_rates, GFP_KERNEL);
+		if (!rate_table) {
+			kfree(fp);
+			return -ENOMEM;
+		}
+		memcpy(rate_table, fp->rate_table, sizeof(int) * fp->nr_rates);
+		fp->rate_table = rate_table;
+	}
+
 	stream = (fp->endpoint & USB_DIR_IN)
 		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
 	err = add_audio_endpoint(chip, stream, fp);
 	if (err < 0) {
 		kfree(fp);
+		if (rate_table)
+			kfree(rate_table);
 		return err;
 	}
 	if (fp->iface != get_iface_desc(&iface->altsetting[0])->bInterfaceNumber ||
 	    fp->altset_idx >= iface->num_altsetting) {
 		kfree(fp);
+		if (rate_table)
+			kfree(rate_table);
 		return -EINVAL;
 	}
 	alts = &iface->altsetting[fp->altset_idx];
@@ -2747,7 +2789,7 @@ static int snd_usb_extigy_boot_quirk(str
 	    get_cfg_desc(config)->wTotalLength == EXTIGY_FIRMWARE_SIZE_NEW) {
 		snd_printdd("sending Extigy boot sequence...\n");
 		/* Send message to force it to reconnect with full interface. */
-		err = usb_control_msg(dev, usb_sndctrlpipe(dev,0),
+		err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev,0),
 				      0x10, 0x43, 0x0001, 0x000a, NULL, 0, HZ);
 		if (err < 0) snd_printdd("error sending boot message: %d\n", err);
 		err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
@@ -3124,26 +3166,3 @@ static void __exit snd_usb_audio_cleanup
 
 module_init(snd_usb_audio_init);
 module_exit(snd_usb_audio_cleanup);
-
-#ifndef MODULE
-/*
- * format is snd-usb-audio=enable,index,id,vid,pid
- */
-static int __init snd_usb_audio_module_setup(char* str)
-{
-	static unsigned __initdata nr_dev = 0;
-
-	if (nr_dev >= SNDRV_CARDS)
-		return 0;
-	(void)(get_option(&str, &enable[nr_dev]) == 2 &&
-	       get_option(&str, &index[nr_dev]) == 2 &&
-	       get_id(&str, &id[nr_dev]) == 2 &&
-	       get_option(&str, &vid[nr_dev]) == 2 &&
-	       get_option(&str, &pid[nr_dev]) == 2);
-	++nr_dev;
-	return 1;
-}
-
-__setup("snd-usb-audio=", snd_usb_audio_module_setup);
-
-#endif /* !MODULE */
diff -rup linux-2.6.5/sound/usb/usbaudio.h linux/sound/usb/usbaudio.h
--- linux-2.6.5/sound/usb/usbaudio.h	2004-04-04 05:37:25.000000000 +0200
+++ linux/sound/usb/usbaudio.h	2004-04-13 12:48:23.000000000 +0200
@@ -197,6 +197,8 @@ unsigned int snd_usb_combine_bytes(unsig
 void *snd_usb_find_desc(void *descstart, int desclen, void *after, u8 dtype);
 void *snd_usb_find_csint_desc(void *descstart, int desclen, void *after, u8 dsubtype);
 
+int snd_usb_ctl_msg(struct usb_device *dev, unsigned int pipe, __u8 request, __u8 requesttype, __u16 value, __u16 index, void *data, __u16 size, int timeout);
+
 int snd_usb_create_mixer(snd_usb_audio_t *chip, int ctrlif);
 
 int snd_usb_create_midi_interface(snd_usb_audio_t *chip, struct usb_interface *iface, const snd_usb_audio_quirk_t *quirk);
diff -rup linux-2.6.5/sound/usb/usbmixer.c linux/sound/usb/usbmixer.c
--- linux-2.6.5/sound/usb/usbmixer.c	2004-04-04 05:36:54.000000000 +0200
+++ linux/sound/usb/usbmixer.c	2004-04-13 12:48:23.000000000 +0200
@@ -301,7 +301,7 @@ static int get_ctl_value(usb_mixer_elem_
 	int timeout = 10;
  
 	while (timeout-- > 0) {
-		if (usb_control_msg(cval->chip->dev, usb_rcvctrlpipe(cval->chip->dev, 0),
+		if (snd_usb_ctl_msg(cval->chip->dev, usb_rcvctrlpipe(cval->chip->dev, 0),
 				    request,
 				    USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,
 				    validx, cval->ctrlif | (cval->id << 8),
@@ -339,7 +339,7 @@ static int set_ctl_value(usb_mixer_elem_
 	buf[0] = value_set & 0xff;
 	buf[1] = (value_set >> 8) & 0xff;
 	while (timeout -- > 0)
-		if (usb_control_msg(cval->chip->dev, usb_sndctrlpipe(cval->chip->dev, 0),
+		if (snd_usb_ctl_msg(cval->chip->dev, usb_sndctrlpipe(cval->chip->dev, 0),
 				    request,
 				    USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,
 				    validx, cval->ctrlif | (cval->id << 8),
diff -rup linux-2.6.5/sound/usb/usbquirks.h linux/sound/usb/usbquirks.h
--- linux-2.6.5/sound/usb/usbquirks.h	2004-04-04 05:36:57.000000000 +0200
+++ linux/sound/usb/usbquirks.h	2004-04-07 12:12:10.000000000 +0200
@@ -113,7 +113,7 @@ YAMAHA_DEVICE(0x5008, "01V96"),
 		.product_name = "UA-100",
 		.ifnum = QUIRK_ANY_INTERFACE,
 		.type = QUIRK_COMPOSITE,
-		.data = & (const snd_usb_audio_quirk_t[]) {
+		.data = (const snd_usb_audio_quirk_t[]) {
 			{
 				.ifnum = 0,
 				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
@@ -274,7 +274,7 @@ YAMAHA_DEVICE(0x5008, "01V96"),
 		.product_name = "SC-D70",
 		.ifnum = QUIRK_ANY_INTERFACE,
 		.type = QUIRK_COMPOSITE,
-		.data = & (const snd_usb_audio_quirk_t[]) {
+		.data = (const snd_usb_audio_quirk_t[]) {
 			{
 				.ifnum = 0,
 				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
@@ -338,7 +338,7 @@ YAMAHA_DEVICE(0x5008, "01V96"),
 		.product_name = "UA-5",
 		.ifnum = QUIRK_ANY_INTERFACE,
 		.type = QUIRK_COMPOSITE,
-		.data = & (const snd_usb_audio_quirk_t[]) {
+		.data = (const snd_usb_audio_quirk_t[]) {
 			{
 				.ifnum = 1,
 				.type = QUIRK_AUDIO_STANDARD_INTERFACE
@@ -443,7 +443,7 @@ YAMAHA_DEVICE(0x5008, "01V96"),
 		.product_name = "UA-20",
 		.ifnum = QUIRK_ANY_INTERFACE,
 		.type = QUIRK_COMPOSITE,
-		.data = & (const snd_usb_audio_quirk_t[]) {
+		.data = (const snd_usb_audio_quirk_t[]) {
 			{
 				.ifnum = 1,
 				.type = QUIRK_AUDIO_STANDARD_INTERFACE
@@ -629,7 +629,7 @@ YAMAHA_DEVICE(0x5008, "01V96"),
 		.product_name = "UA-3FX",
 		.ifnum = QUIRK_ANY_INTERFACE,
 		.type = QUIRK_COMPOSITE,
-		.data = & (const snd_usb_audio_quirk_t[]) {
+		.data = (const snd_usb_audio_quirk_t[]) {
 			{
 				.ifnum = 1,
 				.type = QUIRK_AUDIO_STANDARD_INTERFACE
diff -ru linux-2.6.5/include/sound/ac97_codec.h linux/include/sound/ac97_codec.h
--- linux-2.6.5/include/sound/ac97_codec.h	2004-04-04 05:37:07.000000000 +0200
+++ linux/include/sound/ac97_codec.h	2004-04-07 12:12:05.000000000 +0200
@@ -51,7 +51,7 @@
 #define AC97_REC_GAIN_MIC	0x1e	/* Record Gain MIC (optional) */
 #define AC97_GENERAL_PURPOSE	0x20	/* General Purpose (optional) */
 #define AC97_3D_CONTROL		0x22	/* 3D Control (optional) */
-#define AC97_RESERVED		0x24	/* Reserved */
+#define AC97_INT_PAGING		0x24	/* Audio Interrupt & Paging (AC'97 2.3) */
 #define AC97_POWERDOWN		0x26	/* Powerdown control / status */
 /* range 0x28-0x3a - AUDIO AC'97 2.0 extensions */
 #define AC97_EXTENDED_ID	0x28	/* Extended Audio ID */
@@ -82,6 +82,13 @@
 /* range 0x5a-0x7b - Vendor Specific */
 #define AC97_VENDOR_ID1		0x7c	/* Vendor ID1 */
 #define AC97_VENDOR_ID2		0x7e	/* Vendor ID2 / revision */
+/* range 0x60-0x6f (page 1) - extended codec registers */
+#define AC97_CODEC_CLASS_REV	0x60	/* Codec Class/Revision */
+#define AC97_PCI_SVID		0x62	/* PCI Subsystem Vendor ID */
+#define AC97_PCI_SID		0x64	/* PCI Subsystem ID */
+#define AC97_FUNC_SELECT	0x66	/* Function Select */
+#define AC97_FUNC_INFO		0x68	/* Function Information */
+#define AC97_SENSE_INFO		0x6a	/* Sense Details */
 
 /* slot allocation */
 #define AC97_SLOT_TAG		0
@@ -139,6 +146,7 @@
 #define AC97_EI_AMAP		0x0200	/* indicates optional slot/DAC mapping based on codec ID */
 #define AC97_EI_REV_MASK	0x0c00	/* AC'97 revision mask */
 #define AC97_EI_REV_22		0x0400	/* AC'97 revision 2.2 */
+#define AC97_EI_REV_23		0x0800	/* AC'97 revision 2.3 */
 #define AC97_EI_REV_SHIFT	10
 #define AC97_EI_ADDR_MASK	0xc000	/* physical codec ID (address) */
 #define AC97_EI_ADDR_SHIFT	14
@@ -180,6 +188,16 @@
 #define AC97_SC_DRS		0x4000	/* Double Rate S/PDIF */
 #define AC97_SC_V		0x8000	/* Validity status */
 
+/* Interrupt and Paging bit defines (AC'97 2.3) */
+#define AC97_PAGE_MASK		0x000f	/* Page Selector */
+#define AC97_PAGE_VENDOR	0	/* Vendor-specific registers */
+#define AC97_PAGE_1		1	/* Extended Codec Registers page 1 */
+#define AC97_INT_ENABLE		0x0800	/* Interrupt Enable */
+#define AC97_INT_SENSE		0x1000	/* Sense Cycle */
+#define AC97_INT_CAUSE_SENSE	0x2000	/* Sense Cycle Completed (RO) */
+#define AC97_INT_CAUSE_GPIO	0x4000	/* GPIO bits changed (RO) */
+#define AC97_INT_STATUS		0x8000	/* Interrupt Status */
+
 /* extended modem ID bit defines */
 #define AC97_MEI_LINE1		0x0001	/* Line1 present */
 #define AC97_MEI_LINE2		0x0002	/* Line2 present */
diff -ru linux-2.6.5/include/sound/ad1848.h linux/include/sound/ad1848.h
--- linux-2.6.5/include/sound/ad1848.h	2004-04-04 05:36:55.000000000 +0200
+++ linux/include/sound/ad1848.h	2004-04-08 12:59:25.000000000 +0200
@@ -147,9 +147,6 @@
 	int calibrate_mute;
 	int dma_size;
 	int thinkpad_flag;		/* Thinkpad CS4248 needs some extra help */
-#ifdef CONFIG_PM
-	struct pm_dev *thinkpad_pmstate;
-#endif
 
 	spinlock_t reg_lock;
 	struct semaphore open_mutex;
diff -ru linux-2.6.5/include/sound/asound.h linux/include/sound/asound.h
--- linux-2.6.5/include/sound/asound.h	2004-04-04 05:37:36.000000000 +0200
+++ linux/include/sound/asound.h	2004-04-07 12:12:05.000000000 +0200
@@ -538,7 +538,7 @@
  *  Timer section - /dev/snd/timer
  */
 
-#define SNDRV_TIMER_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 1)
+#define SNDRV_TIMER_VERSION		SNDRV_PROTOCOL_VERSION(2, 0, 2)
 
 enum sndrv_timer_class {
 	SNDRV_TIMER_CLASS_NONE = -1,
@@ -619,6 +619,7 @@
 
 #define SNDRV_TIMER_PSFLG_AUTO		(1<<0)	/* auto start, otherwise one-shot */
 #define SNDRV_TIMER_PSFLG_EXCLUSIVE	(1<<1)	/* exclusive use, precise start/stop/pause/continue */
+#define SNDRV_TIMER_PSFLG_EARLY_EVENT	(1<<2)	/* write early event to the poll queue */
 
 struct sndrv_timer_params {
 	unsigned int flags;		/* flags - SNDRV_MIXER_PSFLG_* */
@@ -667,6 +668,7 @@
 	SNDRV_TIMER_EVENT_STOP,			/* val = 0 */
 	SNDRV_TIMER_EVENT_CONTINUE,		/* val = resolution in ns */
 	SNDRV_TIMER_EVENT_PAUSE,		/* val = 0 */
+	SNDRV_TIMER_EVENT_EARLY,		/* val = 0, early event */
 	/* master timer events for slave timer instances */
 	SNDRV_TIMER_EVENT_MSTART = SNDRV_TIMER_EVENT_START + 10,
 	SNDRV_TIMER_EVENT_MSTOP = SNDRV_TIMER_EVENT_STOP + 10,
diff -ru linux-2.6.5/include/sound/core.h linux/include/sound/core.h
--- linux-2.6.5/include/sound/core.h	2004-04-04 05:38:24.000000000 +0200
+++ linux/include/sound/core.h	2004-04-08 15:17:04.000000000 +0200
@@ -163,8 +163,10 @@
 	struct device *dev;
 
 #ifdef CONFIG_PM
-	int (*set_power_state) (snd_card_t *card, unsigned int state);
-	void *power_state_private_data;
+	int (*pm_suspend)(snd_card_t *card, unsigned int state);
+	int (*pm_resume)(snd_card_t *card, unsigned int state);
+	struct pm_dev *pm_dev;		/* for ISA */
+	void *pm_private_data;
 	unsigned int power_state;	/* power state */
 	struct semaphore power_lock;	/* power lock */
 	wait_queue_head_t power_sleep;
@@ -199,12 +201,29 @@
 	card->power_state = state;
 	wake_up(&card->power_sleep);
 }
+int snd_card_set_pm_callback(snd_card_t *card,
+			     int (*suspend)(snd_card_t *, unsigned int),
+			     int (*resume)(snd_card_t *, unsigned int),
+			     void *private_data);
+int snd_card_set_isa_pm_callback(snd_card_t *card,
+				 int (*suspend)(snd_card_t *, unsigned int),
+				 int (*resume)(snd_card_t *, unsigned int),
+				 void *private_data);
+#ifndef SND_PCI_PM_CALLBACKS
+int snd_card_pci_suspend(struct pci_dev *dev, u32 state);
+int snd_card_pci_resume(struct pci_dev *dev);
+#define SND_PCI_PM_CALLBACKS \
+	.suspend = snd_card_pci_suspend,  .resume = snd_card_pci_resume
+#endif
 #else
 #define snd_power_lock(card)		do { (void)(card); } while (0)
 #define snd_power_unlock(card)		do { (void)(card); } while (0)
 static inline int snd_power_wait(snd_card_t *card, unsigned int state, struct file *file) { return 0; }
 #define snd_power_get_state(card)	SNDRV_CTL_POWER_D0
 #define snd_power_change_state(card, state)	do { (void)(card); } while (0)
+#define snd_card_set_pm_callback(card,suspend,resume,data) -EINVAL
+#define snd_card_set_isa_pm_callback(card,suspend,resume,data) -EINVAL
+#define SND_PCI_PM_CALLBACKS
 #endif
 
 /* device.c */
diff -ru linux-2.6.5/include/sound/cs4231.h linux/include/sound/cs4231.h
--- linux-2.6.5/include/sound/cs4231.h	2004-04-04 05:37:06.000000000 +0200
+++ linux/include/sound/cs4231.h	2004-04-08 13:19:03.000000000 +0200
@@ -295,7 +295,6 @@
 	void (*set_capture_format) (cs4231_t *chip, snd_pcm_hw_params_t *hw_params, unsigned char cdfr);
 	void (*trigger) (cs4231_t *chip, unsigned int what, int start);
 #ifdef CONFIG_PM
-	struct pm_dev *pm_dev;
 	void (*suspend) (cs4231_t *chip);
 	void (*resume) (cs4231_t *chip);
 #endif
diff -ru linux-2.6.5/include/sound/cs46xx.h linux/include/sound/cs46xx.h
--- linux-2.6.5/include/sound/cs46xx.h	2004-04-04 05:36:55.000000000 +0200
+++ linux/include/sound/cs46xx.h	2004-04-08 15:42:20.000000000 +0200
@@ -1737,9 +1737,6 @@
 
 	struct snd_cs46xx_gameport *gameport;
 
-#ifdef CONFIG_PM
-	struct pm_dev *pm_dev;
-#endif
 #ifdef CONFIG_SND_CS46XX_DEBUG_GPIO
 	int current_gpio;
 #endif
@@ -1771,9 +1768,4 @@
 int snd_cs46xx_start_dsp(cs46xx_t *chip);
 void snd_cs46xx_gameport(cs46xx_t *chip);
 
-#ifdef CONFIG_PM
-void snd_cs46xx_suspend(cs46xx_t *chip);
-void snd_cs46xx_resume(cs46xx_t *chip);
-#endif
-
 #endif /* __SOUND_CS46XX_H */
diff -ru linux-2.6.5/include/sound/initval.h linux/include/sound/initval.h
--- linux-2.6.5/include/sound/initval.h	2004-04-04 05:36:14.000000000 +0200
+++ linux/include/sound/initval.h	2004-04-07 15:05:34.000000000 +0200
@@ -133,44 +133,4 @@
 }
 #endif
 
-#if defined(SNDRV_GET_ID) && !defined(MODULE)
-#include <linux/ctype.h>
-#include <linux/init.h>
-#include <linux/bootmem.h>
-static int __init get_id(char **str, char **dst)
-{
-	char *s;
-
-	if (!(*str) || !(**str))
-		return 0;
-	for (s = *str; isalpha(*s) || isdigit(*s) || *s == '_'; s++);
-	if (s != *str) {
-		int len = s - *str;
-		char *d = (char *)alloc_bootmem(len + 1);
-		if (d != NULL) {
-			memcpy(*dst = d, *str, len);
-			d[len] = '\0';
-		}
-	}
-	if (*s == ',') {
-		*str = s + 1;
-		return 2;
-	}
-	*str = s;
-	return 1;
-}
-#endif
-
-/* simple wrapper for long variable.
- * the value more than 32bit won't work!
- */
-inline static int get_option_long(char **str, long *valp)
-{
-	int val, ret;
-	ret = get_option(str, &val);
-	if (ret)
-		*valp = val;
-	return ret;
-}
-
 #endif /* __SOUND_INITVAL_H */
diff -ru linux-2.6.5/include/sound/timer.h linux/include/sound/timer.h
--- linux-2.6.5/include/sound/timer.h	2004-04-04 05:37:07.000000000 +0200
+++ linux/include/sound/timer.h	2004-04-07 12:12:06.000000000 +0200
@@ -60,6 +60,7 @@
 #define SNDRV_TIMER_IFLG_FAST	  0x00000010	/* fast callback (do not use tasklet) */
 #define SNDRV_TIMER_IFLG_CALLBACK 0x00000020	/* timer callback is active */
 #define SNDRV_TIMER_IFLG_EXCLUSIVE 0x00000040	/* exclusive owner - no more instances */
+#define SNDRV_TIMER_IFLG_EARLY_EVENT 0x00000080	/* write early event to the poll queue */
 
 #define SNDRV_TIMER_FLG_CHANGE	0x00000001
 #define SNDRV_TIMER_FLG_RESCHED	0x00000002	/* need reschedule */
diff -ru linux-2.6.5/include/sound/trident.h linux/include/sound/trident.h
--- linux-2.6.5/include/sound/trident.h	2004-04-04 05:37:23.000000000 +0200
+++ linux/include/sound/trident.h	2004-04-13 12:48:15.000000000 +0200
@@ -54,13 +54,6 @@
 #define TRIDENT_DEVICE_ID_NX		((PCI_VENDOR_ID_TRIDENT<<16)|PCI_DEVICE_ID_TRIDENT_4DWAVE_NX)
 #define TRIDENT_DEVICE_ID_SI7018	((PCI_VENDOR_ID_SI<<16)|PCI_DEVICE_ID_SI_7018)
 
-/* Trident chipsets have 1GB memory limit */
-#ifdef __alpha__
-#define TRIDENT_DMA_TYPE        SNDRV_DMA_TYPE_PCI_16MB
-#else
-#define TRIDENT_DMA_TYPE        SNDRV_DMA_TYPE_PCI
-#endif
-
 #define SNDRV_SEQ_DEV_ID_TRIDENT			"trident-synth"
 
 #define SNDRV_TRIDENT_VOICE_TYPE_PCM		0
@@ -488,10 +481,4 @@
 int snd_trident_synth_bzero(trident_t *trident, snd_util_memblk_t *blk, int offset, int size);
 int snd_trident_synth_copy_from_user(trident_t *trident, snd_util_memblk_t *blk, int offset, const char *data, int size);
 
-/* Power Management */
-#ifdef CONFIG_PM
-void snd_trident_suspend(trident_t *trident);
-void snd_trident_resume(trident_t *trident);
-#endif
-
 #endif /* __SOUND_TRIDENT_H */
diff -ru linux-2.6.5/include/sound/version.h linux/include/sound/version.h
--- linux-2.6.5/include/sound/version.h	2004-04-04 05:36:56.000000000 +0200
+++ linux/include/sound/version.h	2004-04-07 18:10:32.000000000 +0200
@@ -1,3 +1,3 @@
 /* include/version.h.  Generated by configure.  */
-#define CONFIG_SND_VERSION "1.0.4rc2"
-#define CONFIG_SND_DATE " (Tue Mar 30 08:19:30 2004 UTC)"
+#define CONFIG_SND_VERSION "1.0.4"
+#define CONFIG_SND_DATE ""
diff -ru linux-2.6.5/include/sound/ymfpci.h linux/include/sound/ymfpci.h
--- linux-2.6.5/include/sound/ymfpci.h	2004-04-04 05:36:56.000000000 +0200
+++ linux/include/sound/ymfpci.h	2004-04-08 15:39:30.000000000 +0200
@@ -393,11 +393,6 @@
 int snd_ymfpci_voice_alloc(ymfpci_t *chip, ymfpci_voice_type_t type, int pair, ymfpci_voice_t **rvoice);
 int snd_ymfpci_voice_free(ymfpci_t *chip, ymfpci_voice_t *pvoice);
 
-#ifdef CONFIG_PM
-void snd_ymfpci_suspend(ymfpci_t *chip);
-void snd_ymfpci_resume(ymfpci_t *chip);
-#endif
-
 #if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
 #define SUPPORT_JOYSTICK
 #endif
diff -ru linux-2.6.5/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl linux/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl
--- linux-2.6.5/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl	2004-04-04 05:36:54.000000000 +0200
+++ linux/Documentation/sound/alsa/DocBook/writing-an-alsa-driver.tmpl	2004-04-13 13:11:45.000000000 +0200
@@ -511,7 +511,7 @@
           }
 
           // (7)
-          pci_set_drvdata(pci, chip);
+          pci_set_drvdata(pci, card);
           dev++;
           return 0;
   }
@@ -519,10 +519,7 @@
   // destructor -- see "Destructor" sub-section
   static void __devexit snd_mychip_remove(struct pci_dev *pci)
   {
-          mychip_t *chip = snd_magic_cast(mychip_t,
-                                     pci_get_drvdata(pci), return);
-          if (chip)
-                  snd_card_free(chip->card);
+          snd_card_free(pci_get_drvdata(pci));
           pci_set_drvdata(pci, NULL);
   }
 ]]>
@@ -691,21 +688,16 @@
           <informalexample>
             <programlisting>
 <![CDATA[
-        pci_set_drvdata(pci, chip);
+        pci_set_drvdata(pci, card);
         dev++;
         return 0;
 ]]>
             </programlisting>
           </informalexample>
 
-          In the above, the chip record is stored. This pointer is
+          In the above, the card record is stored. This pointer is
         referred in the remove callback and power-management
         callbacks, too. 
-	If the card doesn't support the suspend/resume, you can store
-        the card pointer instead of the chip pointer, so that
-        <function>snd_card_free</function> can be called directly
-        without cast in the remove callback.  But anyway, be sure
-        which pointer is used.
         </para>
       </section>
     </section>
@@ -726,21 +718,15 @@
 <![CDATA[
   static void __devexit snd_mychip_remove(struct pci_dev *pci)
   {
-          mychip_t *chip = snd_magic_cast(mychip_t,
-                                    pci_get_drvdata(pci), return);
-          if (chip)
-                  snd_card_free(chip->card);
+          snd_card_free(pci_get_drvdata(pci));
           pci_set_drvdata(pci, NULL);
   }
 ]]>
           </programlisting>
         </informalexample>
 
-        The above code assumes that the chip is allocated
-	with snd_magic stuff and
-      has the field to hold the card pointer (see <link
-      linkend="card-management"><citetitle>the next
-      section</citetitle></link>). 
+        The above code assumes that the card pointer is set to the PCI
+	driver data.
       </para>
     </section>
 
@@ -1355,16 +1341,7 @@
   // initialization of the module
   static int __init alsa_card_mychip_init(void)
   {
-          int err;
-
-          if ((err = pci_module_init(&driver)) < 0) {
-  #ifdef MODULE
-                  printk(KERN_ERR "My chip soundcard not found "
-                                  "or device busy\n");
-  #endif
-                  return err;
-          }
-          return 0;
+          return pci_module_init(&driver);
   }
 
   // clean up the module
@@ -1781,16 +1758,7 @@
 <![CDATA[
   static int __init alsa_card_mychip_init(void)
   {
-          int err;
-
-          if ((err = pci_module_init(&driver)) < 0) {
-  #ifdef MODULE
-                  printk(KERN_ERR "My chip soundcard not found"
-                                  " or device busy\n");
-  #endif
-                  return err;
-          }
-          return 0;
+          return pci_module_init(&driver);
   }
 
   static void __exit alsa_card_mychip_exit(void)
@@ -5254,47 +5222,23 @@
     </para>
 
     <para>
-      Basic jobs of suspend/resume are done in
-      <structfield>suspend</structfield> and
-      <structfield>resume</structfield> callbacks of
-      <structname>pci_driver</structname> struct. Unfortunately, the
-      API of these callbacks was changed at the middle time of Linux
-      2.4.x, if you want to keep the support for older kernels, you
-      have to write two different callbacks. The example below is the
-      skeleton callbacks which just call the real suspend and resume
-      functions. 
+      ALSA provides the common power-management layer. Each card driver
+      needs to have only low-level suspend and resume callbacks.
 
       <informalexample>
         <programlisting>
 <![CDATA[
-  #ifndef PCI_OLD_SUSPEND
-  static int snd_my_suspend(struct pci_dev *dev, u32 state)
+  #ifdef CONFIG_PM
+  static int snd_my_suspend(snd_card_t *card, unsigned int state)
   {
-          mychip_t *chip = snd_magic_cast(mychip_t,
-                             pci_get_drvdata(dev), return -ENXIO);
-          mychip_suspend(chip);
+          .... // do things for suspsend
           return 0;
   }
-  static int snd_my_resume(struct pci_dev *dev)
+  static int snd_my_resume(snd_card_t *card, unsigned int state)
   {
-          mychip_t *chip = snd_magic_cast(mychip_t,
-                             pci_get_drvdata(dev), return -ENXIO);
-          mychip_resume(chip);
+          .... // do things for suspsend
           return 0;
   }
-  #else
-  static void snd_my_suspend(struct pci_dev *dev)
-  {
-          mychip_t *chip = snd_magic_cast(mychip_t,
-                             pci_get_drvdata(dev), return);
-          mychip_suspend(chip);
-  }
-  static void snd_mychip_resume(struct pci_dev *dev)
-  {
-          mychip_t *chip = snd_magic_cast(mychip_t,
-                             pci_get_drvdata(dev), return);
-          mychip_resume(chip);
-  }
   #endif
 ]]>
         </programlisting>
@@ -5302,17 +5246,10 @@
     </para>
 
     <para>
-      For keeping the readability of 2.6 source code, it's recommended to
-      separate the above ifdef condition as the patch file in alsa-driver
-      directory.
-      See <filename>alsa-driver/pci/ali5451.c</filename> for example.
-   </para>
-
-    <para>
       The scheme of the real suspend job is as following.
 
       <orderedlist>
-        <listitem><para>Check whether the power-state is already D3hot. If yes, skip the job.</para></listitem>
+        <listitem><para>Retrieve the chip data from pm_private_data field.</para></listitem>
         <listitem><para>Call <function>snd_pcm_suspend_all()</function> to suspend the running PCM streams.</para></listitem>
         <listitem><para>Save the register values if necessary.</para></listitem>
         <listitem><para>Stop the hardware if necessary.</para></listitem>
@@ -5326,12 +5263,11 @@
       <informalexample>
         <programlisting>
 <![CDATA[
-  static void mychip_suspend(mychip_t *chip)
+  static int mychip_suspend(snd_card_t *card, unsigned int state)
   {
-          snd_card_t *card = chip->card;
           // (1)
-          if (card->power_state == SNDRV_CTL_POWER_D3hot)
-                  return;
+          mychip_t *chip = snd_magic_cast(mychip_t, card->pm_private_data,
+                                          return -ENXIO);
           // (2)
           snd_pcm_suspend_all(chip->pcm);
           // (3)
@@ -5340,6 +5276,7 @@
           snd_mychip_stop_hardware(chip);
           // (5)
           snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+          return 0;
   }
 ]]>
         </programlisting>
@@ -5350,8 +5287,7 @@
     The scheme of the real resume job is as following.
 
     <orderedlist>
-    <listitem><para>Check whether the power-state is already D0.
-    If yes, skip the job.</para></listitem>
+    <listitem><para>Retrieve the chip data from pm_private_data field.</para></listitem>
     <listitem><para>Enable the pci device again by calling
     <function>pci_enable_device()</function>.</para></listitem>
     <listitem><para>Re-initialize the chip.</para></listitem>
@@ -5372,10 +5308,9 @@
 <![CDATA[
   static void mychip_resume(mychip_t *chip)
   {
-          snd_card_t *card = chip->card;
           // (1)
-          if (card->power_state == SNDRV_CTL_POWER_D0)
-                  return;
+          mychip_t *chip = snd_magic_cast(mychip_t, card->pm_private_data,
+                                          return -ENXIO);
           // (2)
           pci_enable_device(chip->pci);
           // (3)
@@ -5388,38 +5323,6 @@
           snd_mychip_restart_chip(chip);
           // (7)
           snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-  }
-]]>
-        </programlisting>
-      </informalexample>
-    </para>
-
-    <para>
-      In addition to the callbacks above, you should define a callback
-      for the changes via the ALSA control interface. It's defined
-      like below: 
-
-      <informalexample>
-        <programlisting>
-<![CDATA[
-  static int snd_mychip_set_power_state(snd_card_t *card,
-                                        unsigned int power_state)
-  {
-          mychip_t *chip = snd_magic_cast(mychip_t,
-                   card->power_state_private_data, return -ENXIO);
-          switch (power_state) {
-          case SNDRV_CTL_POWER_D0:
-          case SNDRV_CTL_POWER_D1:
-          case SNDRV_CTL_POWER_D2:
-                  mychip_resume(chip);
-                  break;
-          case SNDRV_CTL_POWER_D3hot:
-          case SNDRV_CTL_POWER_D3cold:
-                  mychip_suspend(chip);
-                  break;
-          default:
-                  return -EINVAL;
-          }
           return 0;
   }
 ]]>
@@ -5439,41 +5342,42 @@
   {
           ....
           snd_card_t *card;
+          mychip_t *chip;
           ....
-  #ifdef CONFIG_PM
-          card->set_power_state = snd_mychip_set_power_state;
-          card->power_state_private_data = chip;
-  #endif
+          snd_card_set_pm_callback(card, snd_my_suspend, snd_my_resume, chip);
           ....
   }
 ]]>
         </programlisting>
       </informalexample>
+
+    Here you don't have to put ifdef CONFIG_PM around, since it's already
+    checked in the header and expanded to empty if not needed.
     </para>
 
     <para>
       If you need a space for saving the registers, you'll need to
-    allocate the buffer for it here, too, since you cannot call
-    <function>kmalloc()</function> with
-    <constant>GFP_KERNEL</constant> flag or
-    <function>vmalloc()</function> in the suspend callback.
+    allocate the buffer for it here, too, since it would be fatal
+    if you cannot allocate a memory in the suspend phase.
     The allocated buffer should be released in the corresponding
     destructor.
     </para>
 
     <para>
       And next, set suspend/resume callbacks to the pci_driver,
+      This can be done by passing a macro SND_PCI_PM_CALLBACKS
+      in the pci_driver struct.  This macro is expanded to the correct
+      (global) callbacks if CONFIG_PM is set.
 
       <informalexample>
         <programlisting>
 <![CDATA[
   static struct pci_driver driver = {
           .name = "My Chip",
-          ....
-  #ifdef CONFIG_PM
-          .suspend = snd_mychip_suspend,
-          .resume = snd_mychip_resume,
-  #endif
+          .id_table = snd_my_ids,
+          .probe = snd_my_probe,
+          .remove = __devexit_p(snd_my_remove),
+          SND_PCI_PM_CALLBACKS
   };
 ]]>
         </programlisting>
@@ -5521,7 +5425,8 @@
 
     <para>
       The module parameters must be declared with the standard
-    <function>MODULE_PARM()</function> and
+    <function>module_param()()</function>,
+    <function>module_param_array()()</function> and
     <function>MODULE_PARM_DESC()</function> macros. The ALSA provides
     an additional macro, <function>MODULE_PARM_SYNTAX()</function>,
     for describing its syntax. The strings will be written to
@@ -5545,18 +5450,22 @@
 <![CDATA[
   #define CARD_NAME "My Chip"
 
-  MODULE_PARM(index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+  static int boot_devs;
+  module_param_array(index, int, boot_devs, 0444);
   MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
   MODULE_PARM_SYNTAX(index, SNDRV_INDEX_DESC);
-  MODULE_PARM(id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+  module_param_array(id, charp, boot_devs, 0444);
   MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
   MODULE_PARM_SYNTAX(id, SNDRV_ID_DESC);
-  MODULE_PARM(enable, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+  module_param_array(enable, bool, boot_devs, 0444);
   MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
   MODULE_PARM_SYNTAX(enable, SNDRV_ENABLE_DESC);
 ]]>
         </programlisting>
       </informalexample>
+
+    Here boot_devs is passed but simply ignored since we don't care
+    the number of parsed parameters.
     </para>
 
     <para>
@@ -5577,39 +5486,6 @@
       </informalexample>
     </para>
 
-    <para>
-      For building the driver into kernel, you should define the
-      <function>setup()</function> function in addition, too. 
-      ALSA provides <function>get_id()</function> function to retrieve
-      a string argument from the kernel boot parameters.
-
-      <informalexample>
-        <programlisting>
-<![CDATA[
-  #ifndef MODULE
-
-  /* format is: snd-mychip=enable,index,id */
-
-  static int __init alsa_card_mychip_setup(char *str)
-  {
-          static unsigned __initdata nr_dev = 0;
-
-          if (nr_dev >= SNDRV_CARDS)
-                  return 0;
-          (void)(get_option(&str,&enable[nr_dev]) == 2 &&
-                 get_option(&str,&index[nr_dev]) == 2 &&
-                 get_id(&str,&id[nr_dev]) == 2);
-          nr_dev++;
-          return 1;
-  }
-
-  __setup("snd-mychip=", alsa_card_mychip_setup);
-
-  #endif /* ifndef MODULE */
-]]>
-        </programlisting>
-      </informalexample>
-    </para>
   </chapter>
 
 
