diff -u linux/fs/mpage.c-FLUSHFAST linux/fs/mpage.c
--- linux/fs/mpage.c-FLUSHFAST	2004-06-11 03:58:32.000000000 +0200
+++ linux/fs/mpage.c	2004-06-11 12:17:35.000000000 +0200
@@ -655,7 +655,10 @@
 			 * mapping
 			 */
 
-			lock_page(page);
+			if (wbc->sync_mode != WB_SYNC_FAST)
+				lock_page(page);
+			else if (TestSetPageLocked(page))
+		                continue;
 
 			if (unlikely(page->mapping != mapping)) {
 				unlock_page(page);
diff -u linux/include/linux/fs.h-FLUSHFAST linux/include/linux/fs.h
--- linux/include/linux/fs.h-FLUSHFAST	2004-06-11 03:58:42.000000000 +0200
+++ linux/include/linux/fs.h	2004-06-11 12:17:35.000000000 +0200
@@ -1285,6 +1285,7 @@
 extern int filemap_fdatawrite(struct address_space *);
 extern int filemap_fdatawrite_range(struct address_space *, loff_t, loff_t);
 extern int filemap_flush(struct address_space *);
+extern int filemap_flushfast(struct address_space *);
 extern int filemap_fdatawait(struct address_space *);
 extern int filemap_write_and_wait(struct address_space *mapping);
 extern void sync_supers(void);
diff -u linux/include/linux/writeback.h-FLUSHFAST linux/include/linux/writeback.h
--- linux/include/linux/writeback.h-FLUSHFAST	2004-06-11 03:58:32.000000000 +0200
+++ linux/include/linux/writeback.h	2004-06-11 12:17:35.000000000 +0200
@@ -26,6 +26,7 @@
 	WB_SYNC_NONE,	/* Don't wait on anything */
 	WB_SYNC_ALL,	/* Wait on every mapping */
 	WB_SYNC_HOLD,	/* Hold the inode on sb_dirty for sys_sync() */
+	WB_SYNC_FAST,	/* Really don't wait on anything */
 };
 
 /*
diff -u linux/mm/filemap.c-FLUSHFAST linux/mm/filemap.c
--- linux/mm/filemap.c-FLUSHFAST	2004-06-11 03:58:43.000000000 +0200
+++ linux/mm/filemap.c	2004-06-11 12:17:35.000000000 +0200
@@ -204,6 +204,18 @@
 EXPORT_SYMBOL(filemap_flush);
 
 /*
+ * This is a completely non-blocking flush.  Not suitable for much,
+ * used by filesystems where page locks may be held already - not
+ * only may I/O not be started against all dirty pages, but we will
+ * only trylock pages too.
+ */
+int filemap_flushfast(struct address_space *mapping)
+{
+	return __filemap_fdatawrite(mapping, WB_SYNC_FAST);
+}
+EXPORT_SYMBOL(filemap_flushfast);
+
+/*
  * Wait for writeback to complete against pages indexed by start->end
  * inclusive. 
  * This could be a synchronous wait or could just queue an async
