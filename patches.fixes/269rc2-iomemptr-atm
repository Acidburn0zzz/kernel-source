Index: linux-2.6.8/drivers/atm/eni.c
===================================================================
--- linux-2.6.8.orig/drivers/atm/eni.c
+++ linux-2.6.8/drivers/atm/eni.c
@@ -50,18 +50,18 @@
 
 /*
  * KNOWN BUGS:
  *
- * - may run into JK-JK bug and deadlock
- * - should allocate UBR channel first
- * - buffer space allocation algorithm is stupid
- *   (RX: should be maxSDU+maxdelay*rate
- *    TX: should be maxSDU+min(maxSDU,maxdelay*rate) )
- * - doesn't support OAM cells
- * - eni_put_free may hang if not putting memory fragments that _complete_
- *   2^n block (never happens in real life, though)
- * - keeps IRQ even if initialization fails
- */
+	 * - may run into JK-JK bug and deadlock
+	 * - should allocate UBR channel first
+	 * - buffer space allocation algorithm is stupid
+	 *   (RX: should be maxSDU+maxdelay*rate
+	 *    TX: should be maxSDU+min(maxSDU,maxdelay*rate) )
+	 * - doesn't support OAM cells
+	 * - eni_put_free may hang if not putting memory fragments that _complete_
+	 *   2^n block (never happens in real life, though)
+	 * - keeps IRQ even if initialization fails
+	 */
 
 
 #if 0
 #define DPRINTK(format,args...) printk(KERN_DEBUG format,##args)
@@ -83,820 +83,821 @@
 
 #define EVENT(s,a,b)
 
 
-static void event_dump(void)
-{
-}
+	static void event_dump(void)
+	{
+	}
 
 
 #else
 
 
-/* 
- * NULL pointer checking
- */
+	/* 
+	 * NULL pointer checking
+	 */
 
 #define NULLCHECK(x) \
-	if ((unsigned long) (x) < 0x30) \
-		printk(KERN_CRIT #x "==0x%lx\n",(unsigned long) (x))
+		if ((unsigned long) (x) < 0x30) \
+			printk(KERN_CRIT #x "==0x%lx\n",(unsigned long) (x))
 
-/*
- * Very extensive activity logging. Greatly improves bug detection speed but
- * costs a few Mbps if enabled.
- */
+	/*
+	 * Very extensive activity logging. Greatly improves bug detection speed but
+	 * costs a few Mbps if enabled.
+	 */
 
 #define EV 64
 
-static const char *ev[EV];
-static unsigned long ev_a[EV],ev_b[EV];
-static int ec = 0;
+	static const char *ev[EV];
+	static unsigned long ev_a[EV],ev_b[EV];
+	static int ec = 0;
 
 
-static void EVENT(const char *s,unsigned long a,unsigned long b)
-{
-	ev[ec] = s; 
-	ev_a[ec] = a;
-	ev_b[ec] = b;
-	ec = (ec+1) % EV;
-}
+	static void EVENT(const char *s,unsigned long a,unsigned long b)
+	{
+		ev[ec] = s; 
+		ev_a[ec] = a;
+		ev_b[ec] = b;
+		ec = (ec+1) % EV;
+	}
 
 
-static void event_dump(void)
-{
-	int n,i;
+	static void event_dump(void)
+	{
+		int n,i;
 
-	for (n = 0; n < EV; n++) {
-		i = (ec+n) % EV;
-		printk(KERN_NOTICE);
-		printk(ev[i] ? ev[i] : "(null)",ev_a[i],ev_b[i]);
+		for (n = 0; n < EV; n++) {
+			i = (ec+n) % EV;
+			printk(KERN_NOTICE);
+			printk(ev[i] ? ev[i] : "(null)",ev_a[i],ev_b[i]);
+		}
 	}
-}
 
 
 #endif /* CONFIG_ATM_ENI_DEBUG */
 
 
-/*
- * NExx   must not be equal at end
- * EExx   may be equal at end
- * xxPJOK verify validity of pointer jumps
- * xxPMOK operating on a circular buffer of "c" words
- */
+	/*
+	 * NExx   must not be equal at end
+	 * EExx   may be equal at end
+	 * xxPJOK verify validity of pointer jumps
+	 * xxPMOK operating on a circular buffer of "c" words
+	 */
 
 #define NEPJOK(a0,a1,b) \
-    ((a0) < (a1) ? (b) <= (a0) || (b) > (a1) : (b) <= (a0) && (b) > (a1))
+	    ((a0) < (a1) ? (b) <= (a0) || (b) > (a1) : (b) <= (a0) && (b) > (a1))
 #define EEPJOK(a0,a1,b) \
-    ((a0) < (a1) ? (b) < (a0) || (b) >= (a1) : (b) < (a0) && (b) >= (a1))
+	    ((a0) < (a1) ? (b) < (a0) || (b) >= (a1) : (b) < (a0) && (b) >= (a1))
 #define NEPMOK(a0,d,b,c) NEPJOK(a0,(a0+d) & (c-1),b)
 #define EEPMOK(a0,d,b,c) EEPJOK(a0,(a0+d) & (c-1),b)
 
 
-static int tx_complete = 0,dma_complete = 0,queued = 0,requeued = 0,
-  backlogged = 0,rx_enqueued = 0,rx_dequeued = 0,pushed = 0,submitted = 0,
-  putting = 0;
+	static int tx_complete = 0,dma_complete = 0,queued = 0,requeued = 0,
+	  backlogged = 0,rx_enqueued = 0,rx_dequeued = 0,pushed = 0,submitted = 0,
+	  putting = 0;
 
-static struct atm_dev *eni_boards = NULL;
+	static struct atm_dev *eni_boards = NULL;
 
-static u32 *cpu_zeroes = NULL; /* aligned "magic" zeroes */
-static dma_addr_t zeroes;
+	static u32 *cpu_zeroes = NULL; /* aligned "magic" zeroes */
+	static dma_addr_t zeroes;
 
-/* Read/write registers on card */
+	/* Read/write registers on card */
 #define eni_in(r)	readl(eni_dev->reg+(r)*4)
 #define eni_out(v,r)	writel((v),eni_dev->reg+(r)*4)
 
 
-/*-------------------------------- utilities --------------------------------*/
+	/*-------------------------------- utilities --------------------------------*/
 
 
-static void dump_mem(struct eni_dev *eni_dev)
-{
-	int i;
+	static void dump_mem(struct eni_dev *eni_dev)
+	{
+		int i;
 
-	for (i = 0; i < eni_dev->free_len; i++)
-		printk(KERN_DEBUG "  %d: 0x%lx %d\n",i,
-		    eni_dev->free_list[i].start,
-		    1 << eni_dev->free_list[i].order);
-}
+		for (i = 0; i < eni_dev->free_len; i++)
+			printk(KERN_DEBUG "  %d: 0x%p %d\n",i,
+			    eni_dev->free_list[i].start,
+			    1 << eni_dev->free_list[i].order);
+	}
 
 
-static void dump(struct atm_dev *dev)
-{
-	struct eni_dev *eni_dev;
+	static void dump(struct atm_dev *dev)
+	{
+		struct eni_dev *eni_dev;
 
-	int i;
+		int i;
 
-	eni_dev = ENI_DEV(dev);
-	printk(KERN_NOTICE "Free memory\n");
-	dump_mem(eni_dev);
-	printk(KERN_NOTICE "TX buffers\n");
-	for (i = 0; i < NR_CHAN; i++)
-		if (eni_dev->tx[i].send)
-			printk(KERN_NOTICE "  TX %d @ 0x%lx: %ld\n",i,
-			    eni_dev->tx[i].send,eni_dev->tx[i].words*4);
-	printk(KERN_NOTICE "RX buffers\n");
-	for (i = 0; i < 1024; i++)
-		if (eni_dev->rx_map[i] && ENI_VCC(eni_dev->rx_map[i])->rx)
-			printk(KERN_NOTICE "  RX %d @ 0x%lx: %ld\n",i,
-			    ENI_VCC(eni_dev->rx_map[i])->recv,
-			    ENI_VCC(eni_dev->rx_map[i])->words*4);
-	printk(KERN_NOTICE "----\n");
-}
+		eni_dev = ENI_DEV(dev);
+		printk(KERN_NOTICE "Free memory\n");
+		dump_mem(eni_dev);
+		printk(KERN_NOTICE "TX buffers\n");
+		for (i = 0; i < NR_CHAN; i++)
+			if (eni_dev->tx[i].send)
+				printk(KERN_NOTICE "  TX %d @ 0x%p: %ld\n",i,
+				    eni_dev->tx[i].send,eni_dev->tx[i].words*4);
+		printk(KERN_NOTICE "RX buffers\n");
+		for (i = 0; i < 1024; i++)
+			if (eni_dev->rx_map[i] && ENI_VCC(eni_dev->rx_map[i])->rx)
+				printk(KERN_NOTICE "  RX %d @ 0x%p: %ld\n",i,
+				    ENI_VCC(eni_dev->rx_map[i])->recv,
+				    ENI_VCC(eni_dev->rx_map[i])->words*4);
+		printk(KERN_NOTICE "----\n");
+	}
 
 
-static void eni_put_free(struct eni_dev *eni_dev,unsigned long start,
-    unsigned long size)
-{
-	struct eni_free *list;
-	int len,order;
-
-	DPRINTK("init 0x%lx+%ld(0x%lx)\n",start,size,size);
-	start += eni_dev->base_diff;
-	list = eni_dev->free_list;
-	len = eni_dev->free_len;
-	while (size) {
-		if (len >= eni_dev->free_list_size) {
-			printk(KERN_CRIT "eni_put_free overflow (0x%lx,%ld)\n",
-			    start,size);
-			break;
-		}
-		for (order = 0; !((start | size) & (1 << order)); order++);
-		if (MID_MIN_BUF_SIZE > (1 << order)) {
-			printk(KERN_CRIT "eni_put_free: order %d too small\n",
-			    order);
-			break;
+	static void eni_put_free(struct eni_dev *eni_dev, void __iomem *start,
+				 unsigned long size)
+	{
+		struct eni_free *list;
+		int len,order;
+
+		DPRINTK("init 0x%p+%ld(0x%lx)\n",start,size,size);
+		start += eni_dev->base_diff;
+		list = eni_dev->free_list;
+		len = eni_dev->free_len;
+		while (size) {
+			if (len >= eni_dev->free_list_size) {
+				printk(KERN_CRIT "eni_put_free overflow (0x%p,%ld)\n",
+				    start,size);
+				break;
+			}
+			for (order = 0; !(((unsigned long)start | size) & (1 << order)); order++);
+			if (MID_MIN_BUF_SIZE > (1 << order)) {
+				printk(KERN_CRIT "eni_put_free: order %d too small\n",
+				    order);
+				break;
+			}
+			list[len].start = start;
+			list[len].order = order;
+			len++;
+			start += 1 << order;
+			size -= 1 << order;
 		}
-		list[len].start = start;
-		list[len].order = order;
-		len++;
-		start += 1 << order;
-		size -= 1 << order;
-	}
-	eni_dev->free_len = len;
-	/*dump_mem(eni_dev);*/
-}
+		eni_dev->free_len = len;
+		/*dump_mem(eni_dev);*/
+	}
 
 
-static unsigned long eni_alloc_mem(struct eni_dev *eni_dev,unsigned long *size)
-{
-	struct eni_free *list;
-	unsigned long start;
-	int len,i,order,best_order,index;
-
-	list = eni_dev->free_list;
-	len = eni_dev->free_len;
-	if (*size < MID_MIN_BUF_SIZE) *size = MID_MIN_BUF_SIZE;
-	if (*size > MID_MAX_BUF_SIZE) return 0;
-	for (order = 0; (1 << order) < *size; order++);
-	DPRINTK("trying: %ld->%d\n",*size,order);
-	best_order = 65; /* we don't have more than 2^64 of anything ... */
-	index = 0; /* silence GCC */
-	for (i = 0; i < len; i++)
-		if (list[i].order == order) {
-			best_order = order;
-			index = i;
-			break;
-		}
-		else if (best_order > list[i].order && list[i].order > order) {
-				best_order = list[i].order;
+	static void __iomem *eni_alloc_mem(struct eni_dev *eni_dev,unsigned long *size)
+	{
+		struct eni_free *list;
+		void __iomem *start;
+		int len,i,order,best_order,index;
+
+		list = eni_dev->free_list;
+		len = eni_dev->free_len;
+		if (*size < MID_MIN_BUF_SIZE) *size = MID_MIN_BUF_SIZE;
+		if (*size > MID_MAX_BUF_SIZE) return 0;
+		for (order = 0; (1 << order) < *size; order++);
+		DPRINTK("trying: %ld->%d\n",*size,order);
+		best_order = 65; /* we don't have more than 2^64 of anything ... */
+		index = 0; /* silence GCC */
+		for (i = 0; i < len; i++)
+			if (list[i].order == order) {
+				best_order = order;
 				index = i;
+				break;
 			}
-	if (best_order == 65) return 0;
-	start = list[index].start-eni_dev->base_diff;
-	list[index] = list[--len];
-	eni_dev->free_len = len;
-	*size = 1 << order;
-	eni_put_free(eni_dev,start+*size,(1 << best_order)-*size);
-	DPRINTK("%ld bytes (order %d) at 0x%lx\n",*size,order,start);
-	memset_io(start,0,*size);       /* never leak data */
-	/*dump_mem(eni_dev);*/
-	return start;
-}
+			else if (best_order > list[i].order && list[i].order > order) {
+					best_order = list[i].order;
+					index = i;
+				}
+		if (best_order == 65) return 0;
+		start = list[index].start-eni_dev->base_diff;
+		list[index] = list[--len];
+		eni_dev->free_len = len;
+		*size = 1 << order;
+		eni_put_free(eni_dev,start+*size,(1 << best_order)-*size);
+		DPRINTK("%ld bytes (order %d) at 0x%lx\n",*size,order,start);
+		memset_io(start,0,*size);       /* never leak data */
+		/*dump_mem(eni_dev);*/
+		return start;
+	}
 
 
-static void eni_free_mem(struct eni_dev *eni_dev,unsigned long start,
-    unsigned long size)
-{
-	struct eni_free *list;
-	int len,i,order;
-
-	start += eni_dev->base_diff;
-	list = eni_dev->free_list;
-	len = eni_dev->free_len;
-	for (order = -1; size; order++) size >>= 1;
-	DPRINTK("eni_free_mem: 0x%lx+0x%lx (order %d)\n",start,size,order);
-	for (i = 0; i < len; i++)
-		if (list[i].start == (start^(1 << order)) &&
-		    list[i].order == order) {
-			DPRINTK("match[%d]: 0x%lx/0x%lx(0x%x), %d/%d\n",i,
-			    list[i].start,start,1 << order,list[i].order,order);
-			list[i] = list[--len];
-			start &= ~(unsigned long) (1 << order);
-			order++;
-			i = -1;
-			continue;
-		}
-	if (len >= eni_dev->free_list_size) {
-		printk(KERN_ALERT "eni_free_mem overflow (0x%lx,%d)\n",start,
-		    order);
-		return;
-	}
-	list[len].start = start;
-	list[len].order = order;
-	eni_dev->free_len = len+1;
-	/*dump_mem(eni_dev);*/
-}
+	static void eni_free_mem(struct eni_dev *eni_dev, void __iomem *start,
+	    unsigned long size)
+	{
+		struct eni_free *list;
+		int len,i,order;
 
+		start += eni_dev->base_diff;
+		list = eni_dev->free_list;
+		len = eni_dev->free_len;
+		for (order = -1; size; order++) size >>= 1;
+		DPRINTK("eni_free_mem: 0x%p+0x%lx (order %d)\n",start,size,order);
+		for (i = 0; i < len; i++) 
+			if ((unsigned long)list[i].start == ((unsigned long)start^(1 << order)) &&
+			    list[i].order == order) {
+				DPRINTK("match[%d]: 0x%p/0x%p(0x%x), %d/%d\n",i,
+				    list[i].start,start,1 << order,list[i].order,order);
+				list[i] = list[--len];
+				start = (unsigned long)start & ~ (1 << order);
+				order++;
+				i = -1;
+				continue;
+			}
+		if (len >= eni_dev->free_list_size) {
+			printk(KERN_ALERT "eni_free_mem overflow (0x%p,x%d)\n",start,
+			    order);
+			return;
+		}
+		list[len].start = start;
+		list[len].order = order;
+		eni_dev->free_len = len+1;
+		/*dump_mem(eni_dev);*/
+	}
 
-/*----------------------------------- RX ------------------------------------*/
 
+	/*----------------------------------- RX ------------------------------------*/
 
-#define ENI_VCC_NOS ((struct atm_vcc *) 1)
 
+#define ENI_VCC_NOS ((struct atm_vcc *) 1)
 
-static void rx_ident_err(struct atm_vcc *vcc)
-{
-	struct atm_dev *dev;
-	struct eni_dev *eni_dev;
-	struct eni_vcc *eni_vcc;
-
-	dev = vcc->dev;
-	eni_dev = ENI_DEV(dev);
-	/* immediately halt adapter */
-	eni_out(eni_in(MID_MC_S) &
-	    ~(MID_DMA_ENABLE | MID_TX_ENABLE | MID_RX_ENABLE),MID_MC_S);
-	/* dump useful information */
-	eni_vcc = ENI_VCC(vcc);
-	printk(KERN_ALERT DEV_LABEL "(itf %d): driver error - RX ident "
-	    "mismatch\n",dev->number);
-	printk(KERN_ALERT "  VCI %d, rxing %d, words %ld\n",vcc->vci,
-	    eni_vcc->rxing,eni_vcc->words);
-	printk(KERN_ALERT "  host descr 0x%lx, rx pos 0x%lx, descr value "
-	    "0x%x\n",eni_vcc->descr,eni_vcc->rx_pos,
-	    (unsigned) readl(eni_vcc->recv+eni_vcc->descr*4));
-	printk(KERN_ALERT "  last 0x%p, servicing %d\n",eni_vcc->last,
-	    eni_vcc->servicing);
-	EVENT("---dump ends here---\n",0,0);
-	printk(KERN_NOTICE "---recent events---\n");
-	event_dump();
-	ENI_DEV(dev)->fast = NULL; /* really stop it */
-	ENI_DEV(dev)->slow = NULL;
-	skb_queue_head_init(&ENI_DEV(dev)->rx_queue);
-}
 
+	static void rx_ident_err(struct atm_vcc *vcc)
+	{
+		struct atm_dev *dev;
+		struct eni_dev *eni_dev;
+		struct eni_vcc *eni_vcc;
+
+		dev = vcc->dev;
+		eni_dev = ENI_DEV(dev);
+		/* immediately halt adapter */
+		eni_out(eni_in(MID_MC_S) &
+		    ~(MID_DMA_ENABLE | MID_TX_ENABLE | MID_RX_ENABLE),MID_MC_S);
+		/* dump useful information */
+		eni_vcc = ENI_VCC(vcc);
+		printk(KERN_ALERT DEV_LABEL "(itf %d): driver error - RX ident "
+		    "mismatch\n",dev->number);
+		printk(KERN_ALERT "  VCI %d, rxing %d, words %ld\n",vcc->vci,
+		    eni_vcc->rxing,eni_vcc->words);
+		printk(KERN_ALERT "  host descr 0x%lx, rx pos 0x%lx, descr value "
+		    "0x%x\n",eni_vcc->descr,eni_vcc->rx_pos,
+		    (unsigned) readl(eni_vcc->recv+eni_vcc->descr*4));
+		printk(KERN_ALERT "  last 0x%p, servicing %d\n",eni_vcc->last,
+		    eni_vcc->servicing);
+		EVENT("---dump ends here---\n",0,0);
+		printk(KERN_NOTICE "---recent events---\n");
+		event_dump();
+		ENI_DEV(dev)->fast = NULL; /* really stop it */
+		ENI_DEV(dev)->slow = NULL;
+		skb_queue_head_init(&ENI_DEV(dev)->rx_queue);
+	}
 
-static int do_rx_dma(struct atm_vcc *vcc,struct sk_buff *skb,
-    unsigned long skip,unsigned long size,unsigned long eff)
-{
-	struct eni_dev *eni_dev;
-	struct eni_vcc *eni_vcc;
-	u32 dma_rd,dma_wr;
-	u32 dma[RX_DMA_BUF*2];
-	dma_addr_t paddr;
-	unsigned long here;
-	int i,j;
 
-	eni_dev = ENI_DEV(vcc->dev);
-	eni_vcc = ENI_VCC(vcc);
-	paddr = 0; /* GCC, shut up */
-	if (skb) {
-		paddr = pci_map_single(eni_dev->pci_dev,skb->data,skb->len,
-		    PCI_DMA_FROMDEVICE);
-		ENI_PRV_PADDR(skb) = paddr;
-		if (paddr & 3)
-			printk(KERN_CRIT DEV_LABEL "(itf %d): VCI %d has "
-			    "mis-aligned RX data (0x%lx)\n",vcc->dev->number,
-			    vcc->vci,(unsigned long) paddr);
-		ENI_PRV_SIZE(skb) = size+skip;
-		    /* PDU plus descriptor */
-		ATM_SKB(skb)->vcc = vcc;
-	}
-	j = 0;
-	if ((eff && skip) || 1) { /* @@@ actually, skip is always == 1 ... */
-		here = (eni_vcc->descr+skip) & (eni_vcc->words-1);
-		dma[j++] = (here << MID_DMA_COUNT_SHIFT) | (vcc->vci
-		    << MID_DMA_VCI_SHIFT) | MID_DT_JK;
-		j++;
-	}
-	here = (eni_vcc->descr+size+skip) & (eni_vcc->words-1);
-	if (!eff) size += skip;
-	else {
-		unsigned long words;
+	static int do_rx_dma(struct atm_vcc *vcc,struct sk_buff *skb,
+	    unsigned long skip,unsigned long size,unsigned long eff)
+	{
+		struct eni_dev *eni_dev;
+		struct eni_vcc *eni_vcc;
+		u32 dma_rd,dma_wr;
+		u32 dma[RX_DMA_BUF*2];
+		dma_addr_t paddr;
+		unsigned long here;
+		int i,j;
 
-		if (!size) {
-			DPRINTK("strange things happen ...\n");
-			EVENT("strange things happen ... (skip=%ld,eff=%ld)\n",
-			    size,eff);
-		}
-		words = eff;
-		if (paddr & 15) {
-			unsigned long init;
-
-			init = 4-((paddr & 15) >> 2);
-			if (init > words) init = words;
-			dma[j++] = MID_DT_WORD | (init << MID_DMA_COUNT_SHIFT) |
-			    (vcc->vci << MID_DMA_VCI_SHIFT);
-			dma[j++] = paddr;
-			paddr += init << 2;
-			words -= init;
+		eni_dev = ENI_DEV(vcc->dev);
+		eni_vcc = ENI_VCC(vcc);
+		paddr = 0; /* GCC, shut up */
+		if (skb) {
+			paddr = pci_map_single(eni_dev->pci_dev,skb->data,skb->len,
+			    PCI_DMA_FROMDEVICE);
+			ENI_PRV_PADDR(skb) = paddr;
+			if (paddr & 3)
+				printk(KERN_CRIT DEV_LABEL "(itf %d): VCI %d has "
+				    "mis-aligned RX data (0x%lx)\n",vcc->dev->number,
+				    vcc->vci,(unsigned long) paddr);
+			ENI_PRV_SIZE(skb) = size+skip;
+			    /* PDU plus descriptor */
+			ATM_SKB(skb)->vcc = vcc;
+		}
+		j = 0;
+		if ((eff && skip) || 1) { /* @@@ actually, skip is always == 1 ... */
+			here = (eni_vcc->descr+skip) & (eni_vcc->words-1);
+			dma[j++] = (here << MID_DMA_COUNT_SHIFT) | (vcc->vci
+			    << MID_DMA_VCI_SHIFT) | MID_DT_JK;
+			j++;
 		}
+		here = (eni_vcc->descr+size+skip) & (eni_vcc->words-1);
+		if (!eff) size += skip;
+		else {
+			unsigned long words;
+
+			if (!size) {
+				DPRINTK("strange things happen ...\n");
+				EVENT("strange things happen ... (skip=%ld,eff=%ld)\n",
+				    size,eff);
+			}
+			words = eff;
+			if (paddr & 15) {
+				unsigned long init;
+
+				init = 4-((paddr & 15) >> 2);
+				if (init > words) init = words;
+				dma[j++] = MID_DT_WORD | (init << MID_DMA_COUNT_SHIFT) |
+				    (vcc->vci << MID_DMA_VCI_SHIFT);
+				dma[j++] = paddr;
+				paddr += init << 2;
+				words -= init;
+			}
 #ifdef CONFIG_ATM_ENI_BURST_RX_16W /* may work with some PCI chipsets ... */
-		if (words & ~15) {
-			dma[j++] = MID_DT_16W | ((words >> 4) <<
-			    MID_DMA_COUNT_SHIFT) | (vcc->vci <<
-			    MID_DMA_VCI_SHIFT);
-			dma[j++] = paddr;
-			paddr += (words & ~15) << 2;
-			words &= 15;
-		}
+			if (words & ~15) {
+				dma[j++] = MID_DT_16W | ((words >> 4) <<
+				    MID_DMA_COUNT_SHIFT) | (vcc->vci <<
+				    MID_DMA_VCI_SHIFT);
+				dma[j++] = paddr;
+				paddr += (words & ~15) << 2;
+				words &= 15;
+			}
 #endif
 #ifdef CONFIG_ATM_ENI_BURST_RX_8W  /* works only with *some* PCI chipsets ... */
-		if (words & ~7) {
-			dma[j++] = MID_DT_8W | ((words >> 3) <<
-			    MID_DMA_COUNT_SHIFT) | (vcc->vci <<
-			    MID_DMA_VCI_SHIFT);
-			dma[j++] = paddr;
-			paddr += (words & ~7) << 2;
-			words &= 7;
-		}
+			if (words & ~7) {
+				dma[j++] = MID_DT_8W | ((words >> 3) <<
+				    MID_DMA_COUNT_SHIFT) | (vcc->vci <<
+				    MID_DMA_VCI_SHIFT);
+				dma[j++] = paddr;
+				paddr += (words & ~7) << 2;
+				words &= 7;
+			}
 #endif
 #ifdef CONFIG_ATM_ENI_BURST_RX_4W /* recommended */
-		if (words & ~3) {
-			dma[j++] = MID_DT_4W | ((words >> 2) <<
-			    MID_DMA_COUNT_SHIFT) | (vcc->vci <<
-			    MID_DMA_VCI_SHIFT);
-			dma[j++] = paddr;
-			paddr += (words & ~3) << 2;
-			words &= 3;
-		}
+			if (words & ~3) {
+				dma[j++] = MID_DT_4W | ((words >> 2) <<
+				    MID_DMA_COUNT_SHIFT) | (vcc->vci <<
+				    MID_DMA_VCI_SHIFT);
+				dma[j++] = paddr;
+				paddr += (words & ~3) << 2;
+				words &= 3;
+			}
 #endif
 #ifdef CONFIG_ATM_ENI_BURST_RX_2W /* probably useless if RX_4W, RX_8W, ... */
-		if (words & ~1) {
-			dma[j++] = MID_DT_2W | ((words >> 1) <<
-			    MID_DMA_COUNT_SHIFT) | (vcc->vci <<
-			    MID_DMA_VCI_SHIFT);
-			dma[j++] = paddr;
-			paddr += (words & ~1) << 2;
-			words &= 1;
-		}
-#endif
-		if (words) {
-			dma[j++] = MID_DT_WORD | (words << MID_DMA_COUNT_SHIFT)
-			    | (vcc->vci << MID_DMA_VCI_SHIFT);
-			dma[j++] = paddr;
-		}
-	}
-	if (size != eff) {
-		dma[j++] = (here << MID_DMA_COUNT_SHIFT) |
-		    (vcc->vci << MID_DMA_VCI_SHIFT) | MID_DT_JK;
-		j++;
-	}
-	if (!j || j > 2*RX_DMA_BUF) {
-		printk(KERN_CRIT DEV_LABEL "!j or j too big!!!\n");
-		goto trouble;
-	}
-	dma[j-2] |= MID_DMA_END;
-	j = j >> 1;
-	dma_wr = eni_in(MID_DMA_WR_RX);
-	dma_rd = eni_in(MID_DMA_RD_RX);
-	/*
-	 * Can I move the dma_wr pointer by 2j+1 positions without overwriting
-	 * data that hasn't been read (position of dma_rd) yet ?
-	 */
-	if (!NEPMOK(dma_wr,j+j+1,dma_rd,NR_DMA_RX)) { /* @@@ +1 is ugly */
-		printk(KERN_WARNING DEV_LABEL "(itf %d): RX DMA full\n",
-		    vcc->dev->number);
-		goto trouble;
-	}
-        for (i = 0; i < j; i++) {
-		writel(dma[i*2],eni_dev->rx_dma+dma_wr*8);
-		writel(dma[i*2+1],eni_dev->rx_dma+dma_wr*8+4);
-		dma_wr = (dma_wr+1) & (NR_DMA_RX-1);
-        }
-	if (skb) {
-		ENI_PRV_POS(skb) = eni_vcc->descr+size+1;
-		skb_queue_tail(&eni_dev->rx_queue,skb);
-		eni_vcc->last = skb;
-rx_enqueued++;
-	}
-	eni_vcc->descr = here;
-	eni_out(dma_wr,MID_DMA_WR_RX);
-	return 0;
-
-trouble:
-	if (paddr)
-		pci_unmap_single(eni_dev->pci_dev,paddr,skb->len,
-		    PCI_DMA_FROMDEVICE);
-	if (skb) dev_kfree_skb_irq(skb);
-	return -1;
-}
-
-
-static void discard(struct atm_vcc *vcc,unsigned long size)
-{
-	struct eni_vcc *eni_vcc;
-
-	eni_vcc = ENI_VCC(vcc);
-	EVENT("discard (size=%ld)\n",size,0);
-	while (do_rx_dma(vcc,NULL,1,size,0)) EVENT("BUSY LOOP",0,0);
-	    /* could do a full fallback, but that might be more expensive */
-	if (eni_vcc->rxing) ENI_PRV_POS(eni_vcc->last) += size+1;
-	else eni_vcc->rx_pos = (eni_vcc->rx_pos+size+1) & (eni_vcc->words-1);
-}
+			if (words & ~1) {
+				dma[j++] = MID_DT_2W | ((words >> 1) <<
+				    MID_DMA_COUNT_SHIFT) | (vcc->vci <<
+				    MID_DMA_VCI_SHIFT);
+				dma[j++] = paddr;
+				paddr += (words & ~1) << 2;
+				words &= 1;
+			}
+#endif
+			if (words) {
+				dma[j++] = MID_DT_WORD | (words << MID_DMA_COUNT_SHIFT)
+				    | (vcc->vci << MID_DMA_VCI_SHIFT);
+				dma[j++] = paddr;
+			}
+		}
+		if (size != eff) {
+			dma[j++] = (here << MID_DMA_COUNT_SHIFT) |
+			    (vcc->vci << MID_DMA_VCI_SHIFT) | MID_DT_JK;
+			j++;
+		}
+		if (!j || j > 2*RX_DMA_BUF) {
+			printk(KERN_CRIT DEV_LABEL "!j or j too big!!!\n");
+			goto trouble;
+		}
+		dma[j-2] |= MID_DMA_END;
+		j = j >> 1;
+		dma_wr = eni_in(MID_DMA_WR_RX);
+		dma_rd = eni_in(MID_DMA_RD_RX);
+		/*
+		 * Can I move the dma_wr pointer by 2j+1 positions without overwriting
+		 * data that hasn't been read (position of dma_rd) yet ?
+		 */
+		if (!NEPMOK(dma_wr,j+j+1,dma_rd,NR_DMA_RX)) { /* @@@ +1 is ugly */
+			printk(KERN_WARNING DEV_LABEL "(itf %d): RX DMA full\n",
+			    vcc->dev->number);
+			goto trouble;
+		}
+		for (i = 0; i < j; i++) {
+			writel(dma[i*2],eni_dev->rx_dma+dma_wr*8);
+			writel(dma[i*2+1],eni_dev->rx_dma+dma_wr*8+4);
+			dma_wr = (dma_wr+1) & (NR_DMA_RX-1);
+		}
+		if (skb) {
+			ENI_PRV_POS(skb) = eni_vcc->descr+size+1;
+			skb_queue_tail(&eni_dev->rx_queue,skb);
+			eni_vcc->last = skb;
+	rx_enqueued++;
+		}
+		eni_vcc->descr = here;
+		eni_out(dma_wr,MID_DMA_WR_RX);
+		return 0;
 
+	trouble:
+		if (paddr)
+			pci_unmap_single(eni_dev->pci_dev,paddr,skb->len,
+			    PCI_DMA_FROMDEVICE);
+		if (skb) dev_kfree_skb_irq(skb);
+		return -1;
+	}
 
-/*
- * TODO: should check whether direct copies (without DMA setup, dequeuing on
- * interrupt, etc.) aren't much faster for AAL0
- */
 
-static int rx_aal0(struct atm_vcc *vcc)
-{
-	struct eni_vcc *eni_vcc;
-	unsigned long descr;
-	unsigned long length;
-	struct sk_buff *skb;
+	static void discard(struct atm_vcc *vcc,unsigned long size)
+	{
+		struct eni_vcc *eni_vcc;
 
-	DPRINTK(">rx_aal0\n");
-	eni_vcc = ENI_VCC(vcc);
-	descr = readl(eni_vcc->recv+eni_vcc->descr*4);
-	if ((descr & MID_RED_IDEN) != (MID_RED_RX_ID << MID_RED_SHIFT)) {
-		rx_ident_err(vcc);
-		return 1;
-	}
-	if (descr & MID_RED_T) {
-		DPRINTK(DEV_LABEL "(itf %d): trashing empty cell\n",
-		    vcc->dev->number);
-		length = 0;
-		atomic_inc(&vcc->stats->rx_err);
-	}
-	else {
-		length = ATM_CELL_SIZE-1; /* no HEC */
-	}
-	skb = length ? atm_alloc_charge(vcc,length,GFP_ATOMIC) : NULL;
-	if (!skb) {
-		discard(vcc,length >> 2);
-		return 0;
+		eni_vcc = ENI_VCC(vcc);
+		EVENT("discard (size=%ld)\n",size,0);
+		while (do_rx_dma(vcc,NULL,1,size,0)) EVENT("BUSY LOOP",0,0);
+		    /* could do a full fallback, but that might be more expensive */
+		if (eni_vcc->rxing) ENI_PRV_POS(eni_vcc->last) += size+1;
+		else eni_vcc->rx_pos = (eni_vcc->rx_pos+size+1) & (eni_vcc->words-1);
 	}
-	skb_put(skb,length);
-	skb->stamp = eni_vcc->timestamp;
-	DPRINTK("got len %ld\n",length);
-	if (do_rx_dma(vcc,skb,1,length >> 2,length >> 2)) return 1;
-	eni_vcc->rxing++;
-	return 0;
-}
 
 
-static int rx_aal5(struct atm_vcc *vcc)
-{
-	struct eni_vcc *eni_vcc;
-	unsigned long descr;
-	unsigned long size,eff,length;
-	struct sk_buff *skb;
+	/*
+	 * TODO: should check whether direct copies (without DMA setup, dequeuing on
+	 * interrupt, etc.) aren't much faster for AAL0
+	 */
 
-	EVENT("rx_aal5\n",0,0);
-	DPRINTK(">rx_aal5\n");
-	eni_vcc = ENI_VCC(vcc);
-	descr = readl(eni_vcc->recv+eni_vcc->descr*4);
-	if ((descr & MID_RED_IDEN) != (MID_RED_RX_ID << MID_RED_SHIFT)) {
-		rx_ident_err(vcc);
-		return 1;
-	}
-	if (descr & (MID_RED_T | MID_RED_CRC_ERR)) {
+	static int rx_aal0(struct atm_vcc *vcc)
+	{
+		struct eni_vcc *eni_vcc;
+		unsigned long descr;
+		unsigned long length;
+		struct sk_buff *skb;
+
+		DPRINTK(">rx_aal0\n");
+		eni_vcc = ENI_VCC(vcc);
+		descr = readl(eni_vcc->recv+eni_vcc->descr*4);
+		if ((descr & MID_RED_IDEN) != (MID_RED_RX_ID << MID_RED_SHIFT)) {
+			rx_ident_err(vcc);
+			return 1;
+		}
 		if (descr & MID_RED_T) {
-			EVENT("empty cell (descr=0x%lx)\n",descr,0);
 			DPRINTK(DEV_LABEL "(itf %d): trashing empty cell\n",
 			    vcc->dev->number);
-			size = 0;
+			length = 0;
+			atomic_inc(&vcc->stats->rx_err);
 		}
 		else {
-			static unsigned long silence = 0;
+			length = ATM_CELL_SIZE-1; /* no HEC */
+		}
+		skb = length ? atm_alloc_charge(vcc,length,GFP_ATOMIC) : NULL;
+		if (!skb) {
+			discard(vcc,length >> 2);
+			return 0;
+		}
+		skb_put(skb,length);
+		skb->stamp = eni_vcc->timestamp;
+		DPRINTK("got len %ld\n",length);
+		if (do_rx_dma(vcc,skb,1,length >> 2,length >> 2)) return 1;
+		eni_vcc->rxing++;
+		return 0;
+	}
+
+
+	static int rx_aal5(struct atm_vcc *vcc)
+	{
+		struct eni_vcc *eni_vcc;
+		unsigned long descr;
+		unsigned long size,eff,length;
+		struct sk_buff *skb;
 
-			if (time_after(jiffies, silence) || silence == 0) {
-				printk(KERN_WARNING DEV_LABEL "(itf %d): "
-				    "discarding PDU(s) with CRC error\n",
+		EVENT("rx_aal5\n",0,0);
+		DPRINTK(">rx_aal5\n");
+		eni_vcc = ENI_VCC(vcc);
+		descr = readl(eni_vcc->recv+eni_vcc->descr*4);
+		if ((descr & MID_RED_IDEN) != (MID_RED_RX_ID << MID_RED_SHIFT)) {
+			rx_ident_err(vcc);
+			return 1;
+		}
+		if (descr & (MID_RED_T | MID_RED_CRC_ERR)) {
+			if (descr & MID_RED_T) {
+				EVENT("empty cell (descr=0x%lx)\n",descr,0);
+				DPRINTK(DEV_LABEL "(itf %d): trashing empty cell\n",
 				    vcc->dev->number);
-				silence = (jiffies+2*HZ)|1;
+				size = 0;
+			}
+			else {
+				static unsigned long silence = 0;
+
+				if (time_after(jiffies, silence) || silence == 0) {
+					printk(KERN_WARNING DEV_LABEL "(itf %d): "
+					    "discarding PDU(s) with CRC error\n",
+					    vcc->dev->number);
+					silence = (jiffies+2*HZ)|1;
+				}
+				size = (descr & MID_RED_COUNT)*(ATM_CELL_PAYLOAD >> 2);
+				EVENT("CRC error (descr=0x%lx,size=%ld)\n",descr,
+				    size);
 			}
+			eff = length = 0;
+			atomic_inc(&vcc->stats->rx_err);
+		}
+		else {
 			size = (descr & MID_RED_COUNT)*(ATM_CELL_PAYLOAD >> 2);
-			EVENT("CRC error (descr=0x%lx,size=%ld)\n",descr,
-			    size);
+			DPRINTK("size=%ld\n",size);
+			length = readl(eni_vcc->recv+(((eni_vcc->descr+size-1) &
+			    (eni_vcc->words-1)))*4) & 0xffff;
+					/* -trailer(2)+header(1) */
+			if (length && length <= (size << 2)-8 && length <=
+			  ATM_MAX_AAL5_PDU) eff = (length+3) >> 2;
+			else {				 /* ^ trailer length (8) */
+				EVENT("bad PDU (descr=0x08%lx,length=%ld)\n",descr,
+				    length);
+				printk(KERN_ERR DEV_LABEL "(itf %d): bad AAL5 PDU "
+				    "(VCI=%d,length=%ld,size=%ld (descr 0x%lx))\n",
+				    vcc->dev->number,vcc->vci,length,size << 2,descr);
+				length = eff = 0;
+				atomic_inc(&vcc->stats->rx_err);
+			}
 		}
-		eff = length = 0;
-		atomic_inc(&vcc->stats->rx_err);
-	}
-	else {
-		size = (descr & MID_RED_COUNT)*(ATM_CELL_PAYLOAD >> 2);
-		DPRINTK("size=%ld\n",size);
-		length = readl(eni_vcc->recv+(((eni_vcc->descr+size-1) &
-		    (eni_vcc->words-1)))*4) & 0xffff;
-				/* -trailer(2)+header(1) */
-		if (length && length <= (size << 2)-8 && length <=
-		  ATM_MAX_AAL5_PDU) eff = (length+3) >> 2;
-		else {				 /* ^ trailer length (8) */
-			EVENT("bad PDU (descr=0x08%lx,length=%ld)\n",descr,
-			    length);
-			printk(KERN_ERR DEV_LABEL "(itf %d): bad AAL5 PDU "
-			    "(VCI=%d,length=%ld,size=%ld (descr 0x%lx))\n",
-			    vcc->dev->number,vcc->vci,length,size << 2,descr);
-			length = eff = 0;
-			atomic_inc(&vcc->stats->rx_err);
+		skb = eff ? atm_alloc_charge(vcc,eff << 2,GFP_ATOMIC) : NULL;
+		if (!skb) {
+			discard(vcc,size);
+			return 0;
 		}
-	}
-	skb = eff ? atm_alloc_charge(vcc,eff << 2,GFP_ATOMIC) : NULL;
-	if (!skb) {
-		discard(vcc,size);
+		skb_put(skb,length);
+		DPRINTK("got len %ld\n",length);
+		if (do_rx_dma(vcc,skb,1,size,eff)) return 1;
+		eni_vcc->rxing++;
 		return 0;
 	}
-	skb_put(skb,length);
-	DPRINTK("got len %ld\n",length);
-	if (do_rx_dma(vcc,skb,1,size,eff)) return 1;
-	eni_vcc->rxing++;
-	return 0;
-}
 
 
-static inline int rx_vcc(struct atm_vcc *vcc)
-{
-	unsigned long vci_dsc,tmp;
-	struct eni_vcc *eni_vcc;
+	static inline int rx_vcc(struct atm_vcc *vcc)
+	{
+		unsigned long tmp;
+		void __iomem *vci_dsc;
+		struct eni_vcc *eni_vcc;
 
-	eni_vcc = ENI_VCC(vcc);
-	vci_dsc = ENI_DEV(vcc->dev)->vci+vcc->vci*16;
-	EVENT("rx_vcc(1)\n",0,0);
-	while (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>
-	    MID_VCI_DESCR_SHIFT)) {
-		EVENT("rx_vcc(2: host dsc=0x%lx, nic dsc=0x%lx)\n",
-		    eni_vcc->descr,tmp);
-		DPRINTK("CB_DESCR %ld REG_DESCR %d\n",ENI_VCC(vcc)->descr,
-		    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
-		    MID_VCI_DESCR_SHIFT));
-		if (ENI_VCC(vcc)->rx(vcc)) return 1;
-	}
-	/* clear IN_SERVICE flag */
-	writel(readl(vci_dsc) & ~MID_VCI_IN_SERVICE,vci_dsc);
-	/*
-	 * If new data has arrived between evaluating the while condition and
-	 * clearing IN_SERVICE, we wouldn't be notified until additional data
-	 * follows. So we have to loop again to be sure.
-	 */
-	EVENT("rx_vcc(3)\n",0,0);
-	while (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)
-	    >> MID_VCI_DESCR_SHIFT)) {
-		EVENT("rx_vcc(4: host dsc=0x%lx, nic dsc=0x%lx)\n",
-		    eni_vcc->descr,tmp);
-		DPRINTK("CB_DESCR %ld REG_DESCR %d\n",ENI_VCC(vcc)->descr,
-		    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
-		    MID_VCI_DESCR_SHIFT));
-		if (ENI_VCC(vcc)->rx(vcc)) return 1;
+		eni_vcc = ENI_VCC(vcc);
+		vci_dsc = ENI_DEV(vcc->dev)->vci+vcc->vci*16;
+		EVENT("rx_vcc(1)\n",0,0);
+		while (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>
+		    MID_VCI_DESCR_SHIFT)) {
+			EVENT("rx_vcc(2: host dsc=0x%lx, nic dsc=0x%lx)\n",
+			    eni_vcc->descr,tmp);
+			DPRINTK("CB_DESCR %ld REG_DESCR %d\n",ENI_VCC(vcc)->descr,
+			    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
+			    MID_VCI_DESCR_SHIFT));
+			if (ENI_VCC(vcc)->rx(vcc)) return 1;
+		}
+		/* clear IN_SERVICE flag */
+		writel(readl(vci_dsc) & ~MID_VCI_IN_SERVICE,vci_dsc);
+		/*
+		 * If new data has arrived between evaluating the while condition and
+		 * clearing IN_SERVICE, we wouldn't be notified until additional data
+		 * follows. So we have to loop again to be sure.
+		 */
+		EVENT("rx_vcc(3)\n",0,0);
+		while (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)
+		    >> MID_VCI_DESCR_SHIFT)) {
+			EVENT("rx_vcc(4: host dsc=0x%lx, nic dsc=0x%lx)\n",
+			    eni_vcc->descr,tmp);
+			DPRINTK("CB_DESCR %ld REG_DESCR %d\n",ENI_VCC(vcc)->descr,
+			    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>
+			    MID_VCI_DESCR_SHIFT));
+			if (ENI_VCC(vcc)->rx(vcc)) return 1;
+		}
+		return 0;
 	}
-	return 0;
-}
 
 
-static void poll_rx(struct atm_dev *dev)
-{
-	struct eni_dev *eni_dev;
-	struct atm_vcc *curr;
+	static void poll_rx(struct atm_dev *dev)
+	{
+		struct eni_dev *eni_dev;
+		struct atm_vcc *curr;
 
-	eni_dev = ENI_DEV(dev);
-	while ((curr = eni_dev->fast)) {
-		EVENT("poll_rx.fast\n",0,0);
-		if (rx_vcc(curr)) return;
-		eni_dev->fast = ENI_VCC(curr)->next;
-		ENI_VCC(curr)->next = ENI_VCC_NOS;
-		barrier();
-		ENI_VCC(curr)->servicing--;
-	}
-	while ((curr = eni_dev->slow)) {
-		EVENT("poll_rx.slow\n",0,0);
-		if (rx_vcc(curr)) return;
-		eni_dev->slow = ENI_VCC(curr)->next;
-		ENI_VCC(curr)->next = ENI_VCC_NOS;
-		barrier();
-		ENI_VCC(curr)->servicing--;
+		eni_dev = ENI_DEV(dev);
+		while ((curr = eni_dev->fast)) {
+			EVENT("poll_rx.fast\n",0,0);
+			if (rx_vcc(curr)) return;
+			eni_dev->fast = ENI_VCC(curr)->next;
+			ENI_VCC(curr)->next = ENI_VCC_NOS;
+			barrier();
+			ENI_VCC(curr)->servicing--;
+		}
+		while ((curr = eni_dev->slow)) {
+			EVENT("poll_rx.slow\n",0,0);
+			if (rx_vcc(curr)) return;
+			eni_dev->slow = ENI_VCC(curr)->next;
+			ENI_VCC(curr)->next = ENI_VCC_NOS;
+			barrier();
+			ENI_VCC(curr)->servicing--;
+		}
 	}
-}
-
 
-static void get_service(struct atm_dev *dev)
-{
-	struct eni_dev *eni_dev;
-	struct atm_vcc *vcc;
-	unsigned long vci;
 
-	DPRINTK(">get_service\n");
-	eni_dev = ENI_DEV(dev);
-	while (eni_in(MID_SERV_WRITE) != eni_dev->serv_read) {
-		vci = readl(eni_dev->service+eni_dev->serv_read*4);
-		eni_dev->serv_read = (eni_dev->serv_read+1) & (NR_SERVICE-1);
-		vcc = eni_dev->rx_map[vci & 1023];
-		if (!vcc) {
-			printk(KERN_CRIT DEV_LABEL "(itf %d): VCI %ld not "
-			    "found\n",dev->number,vci);
-			continue; /* nasty but we try to go on anyway */
-			/* @@@ nope, doesn't work */
-		}
-		EVENT("getting from service\n",0,0);
-		if (ENI_VCC(vcc)->next != ENI_VCC_NOS) {
-			EVENT("double service\n",0,0);
-			DPRINTK("Grr, servicing VCC %ld twice\n",vci);
-			continue;
-		}
-		do_gettimeofday(&ENI_VCC(vcc)->timestamp);
-		ENI_VCC(vcc)->next = NULL;
-		if (vcc->qos.rxtp.traffic_class == ATM_CBR) {
-			if (eni_dev->fast)
-				ENI_VCC(eni_dev->last_fast)->next = vcc;
-			else eni_dev->fast = vcc;
-			eni_dev->last_fast = vcc;
-		}
-		else {
-			if (eni_dev->slow)
-				ENI_VCC(eni_dev->last_slow)->next = vcc;
-			else eni_dev->slow = vcc;
-			eni_dev->last_slow = vcc;
+	static void get_service(struct atm_dev *dev)
+	{
+		struct eni_dev *eni_dev;
+		struct atm_vcc *vcc;
+		unsigned long vci;
+
+		DPRINTK(">get_service\n");
+		eni_dev = ENI_DEV(dev);
+		while (eni_in(MID_SERV_WRITE) != eni_dev->serv_read) {
+			vci = readl(eni_dev->service+eni_dev->serv_read*4);
+			eni_dev->serv_read = (eni_dev->serv_read+1) & (NR_SERVICE-1);
+			vcc = eni_dev->rx_map[vci & 1023];
+			if (!vcc) {
+				printk(KERN_CRIT DEV_LABEL "(itf %d): VCI %ld not "
+				    "found\n",dev->number,vci);
+				continue; /* nasty but we try to go on anyway */
+				/* @@@ nope, doesn't work */
+			}
+			EVENT("getting from service\n",0,0);
+			if (ENI_VCC(vcc)->next != ENI_VCC_NOS) {
+				EVENT("double service\n",0,0);
+				DPRINTK("Grr, servicing VCC %ld twice\n",vci);
+				continue;
+			}
+			do_gettimeofday(&ENI_VCC(vcc)->timestamp);
+			ENI_VCC(vcc)->next = NULL;
+			if (vcc->qos.rxtp.traffic_class == ATM_CBR) {
+				if (eni_dev->fast)
+					ENI_VCC(eni_dev->last_fast)->next = vcc;
+				else eni_dev->fast = vcc;
+				eni_dev->last_fast = vcc;
+			}
+			else {
+				if (eni_dev->slow)
+					ENI_VCC(eni_dev->last_slow)->next = vcc;
+				else eni_dev->slow = vcc;
+				eni_dev->last_slow = vcc;
+			}
+	putting++;
+			ENI_VCC(vcc)->servicing++;
 		}
-putting++;
-		ENI_VCC(vcc)->servicing++;
 	}
-}
 
 
-static void dequeue_rx(struct atm_dev *dev)
-{
-	struct eni_dev *eni_dev;
-	struct eni_vcc *eni_vcc;
-	struct atm_vcc *vcc;
-	struct sk_buff *skb;
-	unsigned long vci_dsc;
-	int first;
-
-	eni_dev = ENI_DEV(dev);
-	first = 1;
-	while (1) {
-		skb = skb_dequeue(&eni_dev->rx_queue);
-		if (!skb) {
-			if (first) {
-				DPRINTK(DEV_LABEL "(itf %d): RX but not "
-				    "rxing\n",dev->number);
-				EVENT("nothing to dequeue\n",0,0);
+	static void dequeue_rx(struct atm_dev *dev)
+	{
+		struct eni_dev *eni_dev;
+		struct eni_vcc *eni_vcc;
+		struct atm_vcc *vcc;
+		struct sk_buff *skb;
+		void __iomem *vci_dsc;
+		int first;
+
+		eni_dev = ENI_DEV(dev);
+		first = 1;
+		while (1) {
+			skb = skb_dequeue(&eni_dev->rx_queue);
+			if (!skb) {
+				if (first) {
+					DPRINTK(DEV_LABEL "(itf %d): RX but not "
+					    "rxing\n",dev->number);
+					EVENT("nothing to dequeue\n",0,0);
+				}
+				break;
 			}
-			break;
-		}
-		EVENT("dequeued (size=%ld,pos=0x%lx)\n",ENI_PRV_SIZE(skb),
-		    ENI_PRV_POS(skb));
-rx_dequeued++;
-		vcc = ATM_SKB(skb)->vcc;
-		eni_vcc = ENI_VCC(vcc);
-		first = 0;
-		vci_dsc = eni_dev->vci+vcc->vci*16;
-		if (!EEPMOK(eni_vcc->rx_pos,ENI_PRV_SIZE(skb),
-		    (readl(vci_dsc+4) & MID_VCI_READ) >> MID_VCI_READ_SHIFT,
-		    eni_vcc->words)) {
-			EVENT("requeuing\n",0,0);
-			skb_queue_head(&eni_dev->rx_queue,skb);
-			break;
-		}
-		eni_vcc->rxing--;
-		eni_vcc->rx_pos = ENI_PRV_POS(skb) & (eni_vcc->words-1);
-		pci_unmap_single(eni_dev->pci_dev,ENI_PRV_PADDR(skb),skb->len,
-		    PCI_DMA_TODEVICE);
-		if (!skb->len) dev_kfree_skb_irq(skb);
-		else {
-			EVENT("pushing (len=%ld)\n",skb->len,0);
-			if (vcc->qos.aal == ATM_AAL0)
-				*(unsigned long *) skb->data =
-				    ntohl(*(unsigned long *) skb->data);
-			memset(skb->cb,0,sizeof(struct eni_skb_prv));
-			vcc->push(vcc,skb);
-			pushed++;
+			EVENT("dequeued (size=%ld,pos=0x%lx)\n",ENI_PRV_SIZE(skb),
+			    ENI_PRV_POS(skb));
+	rx_dequeued++;
+			vcc = ATM_SKB(skb)->vcc;
+			eni_vcc = ENI_VCC(vcc);
+			first = 0;
+			vci_dsc = eni_dev->vci+vcc->vci*16;
+			if (!EEPMOK(eni_vcc->rx_pos,ENI_PRV_SIZE(skb),
+			    (readl(vci_dsc+4) & MID_VCI_READ) >> MID_VCI_READ_SHIFT,
+			    eni_vcc->words)) {
+				EVENT("requeuing\n",0,0);
+				skb_queue_head(&eni_dev->rx_queue,skb);
+				break;
+			}
+			eni_vcc->rxing--;
+			eni_vcc->rx_pos = ENI_PRV_POS(skb) & (eni_vcc->words-1);
+			pci_unmap_single(eni_dev->pci_dev,ENI_PRV_PADDR(skb),skb->len,
+			    PCI_DMA_TODEVICE);
+			if (!skb->len) dev_kfree_skb_irq(skb);
+			else {
+				EVENT("pushing (len=%ld)\n",skb->len,0);
+				if (vcc->qos.aal == ATM_AAL0)
+					*(unsigned long *) skb->data =
+					    ntohl(*(unsigned long *) skb->data);
+				memset(skb->cb,0,sizeof(struct eni_skb_prv));
+				vcc->push(vcc,skb);
+				pushed++;
+			}
+			atomic_inc(&vcc->stats->rx);
 		}
-		atomic_inc(&vcc->stats->rx);
+		wake_up(&eni_dev->rx_wait);
 	}
-	wake_up(&eni_dev->rx_wait);
-}
 
 
-static int open_rx_first(struct atm_vcc *vcc)
-{
-	struct eni_dev *eni_dev;
-	struct eni_vcc *eni_vcc;
-	unsigned long size;
+	static int open_rx_first(struct atm_vcc *vcc)
+	{
+		struct eni_dev *eni_dev;
+		struct eni_vcc *eni_vcc;
+		unsigned long size;
 
-	DPRINTK("open_rx_first\n");
-	eni_dev = ENI_DEV(vcc->dev);
-	eni_vcc = ENI_VCC(vcc);
-	eni_vcc->rx = NULL;
-	if (vcc->qos.rxtp.traffic_class == ATM_NONE) return 0;
-	size = vcc->qos.rxtp.max_sdu*eni_dev->rx_mult/100;
-	if (size > MID_MAX_BUF_SIZE && vcc->qos.rxtp.max_sdu <=
-	    MID_MAX_BUF_SIZE)
-		size = MID_MAX_BUF_SIZE;
-	eni_vcc->recv = eni_alloc_mem(eni_dev,&size);
-	DPRINTK("rx at 0x%lx\n",eni_vcc->recv);
-	eni_vcc->words = size >> 2;
-	if (!eni_vcc->recv) return -ENOBUFS;
-	eni_vcc->rx = vcc->qos.aal == ATM_AAL5 ? rx_aal5 : rx_aal0;
-	eni_vcc->descr = 0;
-	eni_vcc->rx_pos = 0;
-	eni_vcc->rxing = 0;
-	eni_vcc->servicing = 0;
-	eni_vcc->next = ENI_VCC_NOS;
-	return 0;
-}
+		DPRINTK("open_rx_first\n");
+		eni_dev = ENI_DEV(vcc->dev);
+		eni_vcc = ENI_VCC(vcc);
+		eni_vcc->rx = NULL;
+		if (vcc->qos.rxtp.traffic_class == ATM_NONE) return 0;
+		size = vcc->qos.rxtp.max_sdu*eni_dev->rx_mult/100;
+		if (size > MID_MAX_BUF_SIZE && vcc->qos.rxtp.max_sdu <=
+		    MID_MAX_BUF_SIZE)
+			size = MID_MAX_BUF_SIZE;
+		eni_vcc->recv = eni_alloc_mem(eni_dev,&size);
+		DPRINTK("rx at 0x%lx\n",eni_vcc->recv);
+		eni_vcc->words = size >> 2;
+		if (!eni_vcc->recv) return -ENOBUFS;
+		eni_vcc->rx = vcc->qos.aal == ATM_AAL5 ? rx_aal5 : rx_aal0;
+		eni_vcc->descr = 0;
+		eni_vcc->rx_pos = 0;
+		eni_vcc->rxing = 0;
+		eni_vcc->servicing = 0;
+		eni_vcc->next = ENI_VCC_NOS;
+		return 0;
+	}
 
 
-static int open_rx_second(struct atm_vcc *vcc)
-{
-	unsigned long here;
-	struct eni_dev *eni_dev;
-	struct eni_vcc *eni_vcc;
-	unsigned long size;
-	int order;
+	static int open_rx_second(struct atm_vcc *vcc)
+	{
+		void __iomem * here;
+		struct eni_dev *eni_dev;
+		struct eni_vcc *eni_vcc;
+		unsigned long size;
+		int order;
 
-	DPRINTK("open_rx_second\n");
-	eni_dev = ENI_DEV(vcc->dev);
-	eni_vcc = ENI_VCC(vcc);
-	if (!eni_vcc->rx) return 0;
-	/* set up VCI descriptor */
-	here = eni_dev->vci+vcc->vci*16;
-	DPRINTK("loc 0x%x\n",(unsigned) (eni_vcc->recv-eni_dev->ram)/4);
-	size = eni_vcc->words >> 8;
-	for (order = -1; size; order++) size >>= 1;
-	writel(0,here+4); /* descr, read = 0 */
-	writel(0,here+8); /* write, state, count = 0 */
-	if (eni_dev->rx_map[vcc->vci])
-		printk(KERN_CRIT DEV_LABEL "(itf %d): BUG - VCI %d already "
-		    "in use\n",vcc->dev->number,vcc->vci);
-	eni_dev->rx_map[vcc->vci] = vcc; /* now it counts */
-	writel(((vcc->qos.aal != ATM_AAL5 ? MID_MODE_RAW : MID_MODE_AAL5) <<
-	    MID_VCI_MODE_SHIFT) | MID_VCI_PTI_MODE |
-	    (((eni_vcc->recv-eni_dev->ram) >> (MID_LOC_SKIP+2)) <<
-	    MID_VCI_LOCATION_SHIFT) | (order << MID_VCI_SIZE_SHIFT),here);
-	return 0;
-}
+		DPRINTK("open_rx_second\n");
+		eni_dev = ENI_DEV(vcc->dev);
+		eni_vcc = ENI_VCC(vcc);
+		if (!eni_vcc->rx) return 0;
+		/* set up VCI descriptor */
+		here = eni_dev->vci+vcc->vci*16;
+		DPRINTK("loc 0x%x\n",(unsigned) (eni_vcc->recv-eni_dev->ram)/4);
+		size = eni_vcc->words >> 8;
+		for (order = -1; size; order++) size >>= 1;
+		writel(0,here+4); /* descr, read = 0 */
+		writel(0,here+8); /* write, state, count = 0 */
+		if (eni_dev->rx_map[vcc->vci])
+			printk(KERN_CRIT DEV_LABEL "(itf %d): BUG - VCI %d already "
+			    "in use\n",vcc->dev->number,vcc->vci);
+		eni_dev->rx_map[vcc->vci] = vcc; /* now it counts */
+		writel(((vcc->qos.aal != ATM_AAL5 ? MID_MODE_RAW : MID_MODE_AAL5) <<
+		    MID_VCI_MODE_SHIFT) | MID_VCI_PTI_MODE |
+		    (((unsigned long)(eni_vcc->recv-eni_dev->ram) >> (MID_LOC_SKIP+2)) <<
+		    MID_VCI_LOCATION_SHIFT) | (order << MID_VCI_SIZE_SHIFT), here);
+		return 0;
+	}
 
 
-static void close_rx(struct atm_vcc *vcc)
-{
-	DECLARE_WAITQUEUE(wait,current);
-	unsigned long here;
-	struct eni_dev *eni_dev;
-	struct eni_vcc *eni_vcc;
+	static void close_rx(struct atm_vcc *vcc)
+	{
+		DECLARE_WAITQUEUE(wait,current);
+		void __iomem *here;
+		struct eni_dev *eni_dev;
+		struct eni_vcc *eni_vcc;
 
-	eni_vcc = ENI_VCC(vcc);
-	if (!eni_vcc->rx) return;
-	eni_dev = ENI_DEV(vcc->dev);
-	if (vcc->vpi != ATM_VPI_UNSPEC && vcc->vci != ATM_VCI_UNSPEC) {
-		here = eni_dev->vci+vcc->vci*16;
-		/* block receiver */
-		writel((readl(here) & ~MID_VCI_MODE) | (MID_MODE_TRASH <<
-		    MID_VCI_MODE_SHIFT),here);
-		/* wait for receiver to become idle */
-		udelay(27);
-		/* discard pending cell */
-		writel(readl(here) & ~MID_VCI_IN_SERVICE,here);
-		/* don't accept any new ones */
-		eni_dev->rx_map[vcc->vci] = NULL;
-		/* wait for RX queue to drain */
-		DPRINTK("eni_close: waiting for RX ...\n");
-		EVENT("RX closing\n",0,0);
-		add_wait_queue(&eni_dev->rx_wait,&wait);
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		barrier();
-		for (;;) {
-			/* transition service->rx: rxing++, servicing-- */
-			if (!eni_vcc->servicing) {
-				barrier();
-				if (!eni_vcc->rxing) break;
-			}
-			EVENT("drain PDUs (rx %ld, serv %ld)\n",eni_vcc->rxing,
-			    eni_vcc->servicing);
-			printk(KERN_INFO "%d+%d RX left\n",eni_vcc->servicing,
-			    eni_vcc->rxing);
-			schedule();
-			set_current_state(TASK_UNINTERRUPTIBLE);
-		}
-		for (;;) {
-			int at_end;
-			u32 tmp;
-
-			tasklet_disable(&eni_dev->task);
-			tmp = readl(eni_dev->vci+vcc->vci*16+4) & MID_VCI_READ;
-			at_end = eni_vcc->rx_pos == tmp >> MID_VCI_READ_SHIFT;
-			tasklet_enable(&eni_dev->task);
-			if (at_end) break;
-			EVENT("drain discard (host 0x%lx, nic 0x%lx)\n",
-			    eni_vcc->rx_pos,tmp);
-			printk(KERN_INFO "draining RX: host 0x%lx, nic 0x%x\n",
-			    eni_vcc->rx_pos,tmp);
-			schedule();
+		eni_vcc = ENI_VCC(vcc);
+		if (!eni_vcc->rx) return;
+		eni_dev = ENI_DEV(vcc->dev);
+		if (vcc->vpi != ATM_VPI_UNSPEC && vcc->vci != ATM_VCI_UNSPEC) {
+			here = eni_dev->vci+vcc->vci*16;
+			/* block receiver */
+			writel((readl(here) & ~MID_VCI_MODE) | (MID_MODE_TRASH <<
+			    MID_VCI_MODE_SHIFT),here);
+			/* wait for receiver to become idle */
+			udelay(27);
+			/* discard pending cell */
+			writel(readl(here) & ~MID_VCI_IN_SERVICE,here);
+			/* don't accept any new ones */
+			eni_dev->rx_map[vcc->vci] = NULL;
+			/* wait for RX queue to drain */
+			DPRINTK("eni_close: waiting for RX ...\n");
+			EVENT("RX closing\n",0,0);
+			add_wait_queue(&eni_dev->rx_wait,&wait);
 			set_current_state(TASK_UNINTERRUPTIBLE);
+			barrier();
+			for (;;) {
+				/* transition service->rx: rxing++, servicing-- */
+				if (!eni_vcc->servicing) {
+					barrier();
+					if (!eni_vcc->rxing) break;
+				}
+				EVENT("drain PDUs (rx %ld, serv %ld)\n",eni_vcc->rxing,
+				    eni_vcc->servicing);
+				printk(KERN_INFO "%d+%d RX left\n",eni_vcc->servicing,
+				    eni_vcc->rxing);
+				schedule();
+				set_current_state(TASK_UNINTERRUPTIBLE);
+			}
+			for (;;) {
+				int at_end;
+				u32 tmp;
+
+				tasklet_disable(&eni_dev->task);
+				tmp = readl(eni_dev->vci+vcc->vci*16+4) & MID_VCI_READ;
+				at_end = eni_vcc->rx_pos == tmp >> MID_VCI_READ_SHIFT;
+				tasklet_enable(&eni_dev->task);
+				if (at_end) break;
+				EVENT("drain discard (host 0x%lx, nic 0x%lx)\n",
+				    eni_vcc->rx_pos,tmp);
+				printk(KERN_INFO "draining RX: host 0x%lx, nic 0x%x\n",
+				    eni_vcc->rx_pos,tmp);
+				schedule();
+				set_current_state(TASK_UNINTERRUPTIBLE);
+			}
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&eni_dev->rx_wait,&wait);
 		}
-		set_current_state(TASK_RUNNING);
-		remove_wait_queue(&eni_dev->rx_wait,&wait);
-	}
 	eni_free_mem(eni_dev,eni_vcc->recv,eni_vcc->words << 2);
 	eni_vcc->rx = NULL;
 }
 
@@ -1288,9 +1289,10 @@ static int reserve_or_set_tx(struct atm_
 {
 	struct eni_dev *eni_dev = ENI_DEV(vcc->dev);
 	struct eni_vcc *eni_vcc = ENI_VCC(vcc);
 	struct eni_tx *tx;
-	unsigned long size,mem;
+	unsigned long size;
+	void __iomem *mem;
 	int rate,ubr,unlimited,new_tx;
 	int pre,res,order;
 	int error;
 
@@ -1316,9 +1318,10 @@ static int reserve_or_set_tx(struct atm_
 	mem = 0; /* for gcc */
 	if (!new_tx) tx = eni_vcc->tx;
 	else {
 		mem = eni_alloc_mem(eni_dev,&size);
-		if (!mem) return -ENOBUFS;
+		if (!mem) 
+			return -ENOBUFS;
 		tx = alloc_tx(eni_dev,unlimited);
 		if (!tx) {
 			eni_free_mem(eni_dev,mem,size);
 			return -EBUSY;
@@ -1686,11 +1689,11 @@ static int __devinit get_esi_asic(struct
 #undef SET_SEPROM
 #undef GET_SEPROM
 
 
-static int __devinit get_esi_fpga(struct atm_dev *dev,unsigned long base)
+static int __devinit get_esi_fpga(struct atm_dev *dev, void __iomem *base)
 {
-	unsigned long mac_base;
+	void __iomem *mac_base;
 	int i;
 
 	mac_base = base+EPROM_SIZE-sizeof(struct midway_eprom);
 	for (i = 0; i < ESI_LEN; i++) dev->esi[i] = readb(mac_base+(i^3));
@@ -1702,9 +1705,10 @@ static int __devinit eni_do_init(struct 
 {
 	struct midway_eprom *eprom;
 	struct eni_dev *eni_dev;
 	struct pci_dev *pci_dev;
-	unsigned long real_base,base;
+	void __iomem *base;
+	unsigned long real_base;
 	unsigned char revision;
 	int error,i,last;
 
 	DPRINTK(">eni_init\n");
@@ -1729,15 +1733,15 @@ static int __devinit eni_do_init(struct 
 		return -EIO;
 	}
 	printk(KERN_NOTICE DEV_LABEL "(itf %d): rev.%d,base=0x%lx,irq=%d,",
 	    dev->number,revision,real_base,eni_dev->irq);
-	if (!(base = (unsigned long) ioremap_nocache(real_base,MAP_MAX_SIZE))) {
+	if (!(base = ioremap_nocache(real_base,MAP_MAX_SIZE))) {
 		printk("\n");
 		printk(KERN_ERR DEV_LABEL "(itf %d): can't set up page "
 		    "mapping\n",dev->number);
 		return error;
 	}
-	eni_dev->base_diff = real_base-base;
+	eni_dev->base_diff = real_base - (unsigned long)base;
 	/* id may not be present in ASIC Tonga boards - check this @@@ */
 	if (!eni_dev->asic) {
 		eprom = (struct midway_eprom *) (base+EPROM_SIZE-sizeof(struct
 		    midway_eprom));
@@ -1789,9 +1793,10 @@ static int __devinit eni_do_init(struct 
 
 static int __devinit eni_start(struct atm_dev *dev)
 {
 	struct eni_dev *eni_dev;
-	unsigned long buf,buffer_mem;
+	void __iomem *buf;
+	unsigned long buffer_mem;
 	int error;
 
 	DPRINTK(">eni_start\n");
 	eni_dev = ENI_DEV(dev);
@@ -1827,9 +1832,9 @@ static int __devinit eni_start(struct at
 	spin_lock_init(&eni_dev->lock);
 	tasklet_init(&eni_dev->task,eni_tasklet,(unsigned long) dev);
 	eni_dev->events = 0;
 	/* initialize memory management */
-	buffer_mem = eni_dev->mem-(buf-eni_dev->ram);
+	buffer_mem = eni_dev->mem - (buf - eni_dev->ram);
 	eni_dev->free_list_size = buffer_mem/MID_MIN_BUF_SIZE/2;
 	eni_dev->free_list = (struct eni_free *) kmalloc(
 	    sizeof(struct eni_free)*(eni_dev->free_list_size+1),GFP_KERNEL);
 	if (!eni_dev->free_list) {
@@ -1954,9 +1959,9 @@ static int eni_change_qos(struct atm_vcc
 	 * segmentation buffer descriptors of this VCC.
 	 */
 	tasklet_disable(&eni_dev->task);
 	skb_queue_walk(&eni_dev->tx_queue, skb) {
-		unsigned long dsc;
+		void __iomem *dsc;
 
 		if (ATM_SKB(skb)->vcc != vcc) continue;
 		dsc = tx->send+ENI_PRV_POS(skb)*4;
 		writel((readl(dsc) & ~(MID_SEG_RATE | MID_SEG_PR)) |
@@ -2135,9 +2140,9 @@ static int eni_proc_read(struct atm_dev 
 		struct eni_tx *tx = eni_dev->tx+i;
 
 		if (!tx->send) continue;
 		if (!--left) {
-			return sprintf(page,"tx[%d]:    0x%06lx-0x%06lx "
+			return sprintf(page,"tx[%d]:    0x%p-0x%p "
 			    "(%6ld bytes), rsv %d cps, shp %d cps%s\n",i,
 			    tx->send-eni_dev->ram,
 			    tx->send-eni_dev->ram+tx->words*4-1,tx->words*4,
 			    tx->reserved,tx->shaping,
@@ -2161,9 +2166,9 @@ static int eni_proc_read(struct atm_dev 
 			eni_vcc = ENI_VCC(vcc);
 			if (--left) continue;
 			length = sprintf(page,"vcc %4d: ",vcc->vci);
 			if (eni_vcc->rx) {
-				length += sprintf(page+length,"0x%06lx-0x%06lx "
+				length += sprintf(page+length,"0x%p-0x%p "
 				    "(%6ld bytes)",
 				    eni_vcc->recv-eni_dev->ram,
 				    eni_vcc->recv-eni_dev->ram+eni_vcc->words*4-1,
 				    eni_vcc->words*4);
@@ -2183,9 +2188,9 @@ static int eni_proc_read(struct atm_dev 
 		unsigned long offset;
 
 		if (--left) continue;
 		offset = eni_dev->ram+eni_dev->base_diff;
-		return sprintf(page,"free      0x%06lx-0x%06lx (%6d bytes)\n",
+		return sprintf(page,"free      0x%p-0x%p (%6d bytes)\n",
 		    fe->start-offset,fe->start-offset+(1 << fe->order)-1,
 		    1 << fe->order);
 	}
 	return 0;
Index: linux-2.6.8/drivers/atm/nicstarmac.h
===================================================================
--- linux-2.6.8.orig/drivers/atm/nicstarmac.h
+++ linux-2.6.8/drivers/atm/nicstarmac.h
@@ -6,9 +6,9 @@
  *
  ******************************************************************************/
 
 
-typedef unsigned int virt_addr_t;
+typedef void __iomem * virt_addr_t;
 
 u_int32_t nicstar_read_eprom_status( virt_addr_t base );
 void nicstar_init_eprom( virt_addr_t base );
 void nicstar_read_eprom( virt_addr_t, u_int8_t, u_int8_t *, u_int32_t);
Index: linux-2.6.8/drivers/atm/firestream.h
===================================================================
--- linux-2.6.8.orig/drivers/atm/firestream.h
+++ linux-2.6.8/drivers/atm/firestream.h
@@ -476,9 +476,9 @@ struct fs_dev {
 	struct atm_dev *atm_dev;
 	struct timer_list timer;
 
 	unsigned long hw_base;		/* mem base address */
-	unsigned long base;             /* Mapping of base address */
+	void __iomem *base;             /* Mapping of base address */
 	int channo;
 	unsigned long channel_mask;
 
 	struct queue    hp_txq, lp_txq, tx_relq, st_q;
Index: linux-2.6.8/drivers/atm/he.h
===================================================================
--- linux-2.6.8.orig/drivers/atm/he.h
+++ linux-2.6.8/drivers/atm/he.h
@@ -264,9 +264,9 @@ struct he_cs_stper
 
 struct he_dev {
 	unsigned int number;
 	unsigned int irq;
-	unsigned long membase;
+	void __iomem *membase;
 
 	char prod_id[30];
 	char mac_addr[6];
 	int media;			/*  
Index: linux-2.6.8/drivers/atm/idt77252.h
===================================================================
--- linux-2.6.8.orig/drivers/atm/idt77252.h
+++ linux-2.6.8/drivers/atm/idt77252.h
@@ -356,9 +356,9 @@ struct idt77252_dev
 	struct atm_dev		*atmdev;	/* ATM device desriptor */
 
 	unsigned long		membase;	/* SAR's memory base address */
 	unsigned long		srambase;	/* SAR's sram  base address */
-	unsigned long		fbq[4];		/* FBQ fill addresses */
+	void __iomem *		fbq[4];		/* FBQ fill addresses */
 
 	struct semaphore	mutex;
 	spinlock_t		cmd_lock;	/* for r/w utility/sram */
 
Index: linux-2.6.8/drivers/atm/iphase.h
===================================================================
--- linux-2.6.8.orig/drivers/atm/iphase.h
+++ linux-2.6.8/drivers/atm/iphase.h
@@ -1005,10 +1005,10 @@ typedef struct iadev_t {  
 						internal registers */  
 	u32 *reass_reg;			/* base pointer to reassemble engine  
 						internal registers */  
 	u32 *ram;			/* base pointer to SAR RAM */  
-	unsigned int seg_ram;  
-	unsigned int reass_ram;  
+	void __iomem *seg_ram;
+	void __iomem *reass_ram;
 	struct dle_q tx_dle_q;  
 	struct free_desc_q *tx_free_desc_qhead;  
 	struct sk_buff_head tx_dma_q, tx_backlog;  
         spinlock_t            tx_lock;
@@ -1018,9 +1018,9 @@ typedef struct iadev_t {  
         wait_queue_head_t    timeout_wait;
 	struct cpcs_trailer_desc *tx_buf;
         u16 num_tx_desc, tx_buf_sz, rate_limit;
         u32 tx_cell_cnt, tx_pkt_cnt;
-        u32 MAIN_VC_TABLE_ADDR, EXT_VC_TABLE_ADDR, ABR_SCHED_TABLE_ADDR;
+        void __iomem *MAIN_VC_TABLE_ADDR, *EXT_VC_TABLE_ADDR, *ABR_SCHED_TABLE_ADDR;
 	struct dle_q rx_dle_q;  
 	struct free_desc_q *rx_free_desc_qhead;  
 	struct sk_buff_head rx_dma_q;  
         spinlock_t rx_lock, misc_lock;
Index: linux-2.6.8/drivers/atm/nicstar.h
===================================================================
--- linux-2.6.8.orig/drivers/atm/nicstar.h
+++ linux-2.6.8/drivers/atm/nicstar.h
@@ -762,9 +762,9 @@ struct ns_skb_data
 typedef struct ns_dev
 {
    int index;				/* Card ID to the device driver */
    int sram_size;			/* In k x 32bit words. 32 or 128 */
-   unsigned long membase;			/* Card's memory base address */
+   void __iomem *membase;		/* Card's memory base address */
    unsigned long max_pcr;
    int rct_size;			/* Number of entries */
    int vpibits;
    int vcibits;
Index: linux-2.6.8/drivers/atm/eni.h
===================================================================
--- linux-2.6.8.orig/drivers/atm/eni.h
+++ linux-2.6.8/drivers/atm/eni.h
@@ -32,14 +32,14 @@
 #define ENI_ZEROES_SIZE	  4		/* need that many DMA-able zero bytes */
 
 
 struct eni_free {
-	unsigned long start;		/* counting in bytes */
+	void __iomem *start;		/* counting in bytes */
 	int order;
 };
 
 struct eni_tx {
-	unsigned long send;		/* base, 0 if unused */
+	void __iomem *send;		/* base, 0 if unused */
 	int prescaler;			/* shaping prescaler */
 	int resolution;			/* shaping divider */
 	unsigned long tx_pos;		/* current TX write position */
 	unsigned long words;		/* size of TX queue */
@@ -50,9 +50,9 @@ struct eni_tx {
 };
 
 struct eni_vcc {
 	int (*rx)(struct atm_vcc *vcc);	/* RX function, NULL if none */
-	unsigned long recv;		/* receive buffer */
+	void __iomem *recv;		/* receive buffer */
 	unsigned long words;		/* its size in words */
 	unsigned long descr;		/* next descriptor (RX) */
 	unsigned long rx_pos;		/* current RX descriptor pos */
 	struct eni_tx *tx;		/* TXer, NULL if none */
@@ -71,15 +71,15 @@ struct eni_dev {
 	struct tasklet_struct task;	/* tasklet for interrupt work */
 	u32 events;			/* pending events */
 	/*-------------------------------- base pointers into Midway address
 					   space */
-	unsigned long phy;		/* PHY interface chip registers */
-	unsigned long reg;		/* register base */
-	unsigned long ram;		/* RAM base */
-	unsigned long vci;		/* VCI table */
-	unsigned long rx_dma;		/* RX DMA queue */
-	unsigned long tx_dma;		/* TX DMA queue */
-	unsigned long service;		/* service list */
+	void __iomem *phy;		/* PHY interface chip registers */
+	void __iomem *reg;		/* register base */
+	void __iomem *ram;		/* RAM base */
+	void __iomem *vci;		/* VCI table */
+	void __iomem *rx_dma;		/* RX DMA queue */
+	void __iomem *tx_dma;		/* TX DMA queue */
+	void __iomem *service;		/* service list */
 	/*-------------------------------- TX part */
 	struct eni_tx tx[NR_CHAN];	/* TX channels */
 	struct eni_tx *ubr;		/* UBR channel */
 	struct sk_buff_head tx_queue;	/* PDUs currently being TX DMAed*/
Index: linux-2.6.8/drivers/atm/nicstarmac.c
===================================================================
--- linux-2.6.8.orig/drivers/atm/nicstarmac.c
+++ linux-2.6.8/drivers/atm/nicstarmac.c
@@ -105,12 +105,12 @@ static u_int32_t clocktab[] =
 };
 
 
 #define NICSTAR_REG_WRITE(bs, reg, val) \
-	while ( readl(bs + STAT) & 0x0200 ) ; \
-	writel((val),(base)+(reg))
+	while ( readl((void __iomem *)bs + STAT) & 0x0200 ) ; \
+	writel((val),(void __iomem *)(base)+(reg))
 #define NICSTAR_REG_READ(bs, reg) \
-	readl((base)+(reg))
+	readl((void __iomem *)(base)+(reg))
 #define NICSTAR_REG_GENERAL_PURPOSE GP
 
 /*
  * This routine will clock the Read_Status_reg function into the X2520
@@ -161,9 +161,9 @@ nicstar_read_eprom_status( virt_addr_t b
  * Purpose register.  
  */
  
 static u_int8_t 
-read_eprom_byte(u_int32_t base, u_int8_t offset)
+read_eprom_byte(void __iomem *base, u_int8_t offset)
 {
    u_int32_t val = 0;
    int i,j=0;
    u_int8_t tempread = 0;
Index: linux-2.6.8/drivers/atm/lanai.c
===================================================================
--- linux-2.6.8.orig/drivers/atm/lanai.c
+++ linux-2.6.8/drivers/atm/lanai.c
@@ -190,9 +190,9 @@
 #define LANAI_MAPPING_SIZE	(0x40000)
 #define LANAI_EEPROM_SIZE	(128)
 
 typedef int vci_t;
-typedef unsigned long bus_addr_t;
+typedef void __iomem * bus_addr_t;
 
 /* DMA buffer in host memory for TX, RX, or service list. */
 struct lanai_buffer {
 	u32 *start;	/* From get_free_pages */
@@ -467,12 +467,12 @@ enum lanai_register {
 	PingCount_Reg		= 0x58,	/* Ping count */
 	DMA_Addr_Reg		= 0x5C	/* DMA address */
 };
 
-static inline bus_addr_t reg_addr(const struct lanai_dev *lanai,
+static inline void __iomem * reg_addr(const struct lanai_dev *lanai,
 	enum lanai_register reg)
 {
-	return lanai->base + (bus_addr_t) reg;
+	return lanai->base + reg;
 }
 
 static inline u32 reg_read(const struct lanai_dev *lanai,
 	enum lanai_register reg)
@@ -650,9 +650,9 @@ static inline u32 cardvcc_read(const str
 	enum lanai_vcc_offset offset)
 {
 	u32 val;
 	APRINTK(lvcc->vbase != 0, "cardvcc_read: unbound vcc!\n");
-	val= readl(lvcc->vbase + (bus_addr_t) offset);
+	val= readl(lvcc->vbase + offset);
 	RWDEBUG("VR vci=%04d 0x%02X = 0x%08X\n",
 	    lvcc->vci, (int) offset, val);
 	return val;
 }
@@ -665,9 +665,9 @@ static inline void cardvcc_write(const s
 	    "cardvcc_write: bad val 0x%X (vci=%d, addr=0x%02X)\n",
 	    (unsigned int) val, lvcc->vci, (unsigned int) offset);
 	RWDEBUG("VW vci=%04d 0x%02X > 0x%08X\n",
 	    lvcc->vci, (unsigned int) offset, (unsigned int) val);
-	writel(val, lvcc->vbase + (bus_addr_t) offset);
+	writel(val, lvcc->vbase + offset);
 }
 
 /* -------------------- COMPUTE SIZE OF AN AAL5 PDU: */
 
@@ -2176,9 +2176,9 @@ static int __init lanai_dev_open(struct 
 
 	/* 3.2: PCI initialization */
 	if ((result = lanai_pci_start(lanai)) != 0)
 		goto error;
-	raw_base = (bus_addr_t) lanai->pci->resource[0].start;
+	raw_base = lanai->pci->resource[0].start;
 	lanai->base = (bus_addr_t) ioremap(raw_base, LANAI_MAPPING_SIZE);
 	if (lanai->base == 0) {
 		printk(KERN_ERR DEV_LABEL ": couldn't remap I/O space\n");
 		goto error_pci;
Index: linux-2.6.8/drivers/atm/idt77252.c
===================================================================
--- linux-2.6.8.orig/drivers/atm/idt77252.c
+++ linux-2.6.8/drivers/atm/idt77252.c
@@ -164,11 +164,11 @@ static void
 waitfor_idle(struct idt77252_dev *card)
 {
 	u32 stat;
 
-	stat = readl(SAR_REG_STAT);
+	stat = readl((void __iomem *)SAR_REG_STAT);
 	while (stat & SAR_STAT_CMDBZ)
-		stat = readl(SAR_REG_STAT);
+		stat = readl((void __iomem *)SAR_REG_STAT);
 }
 
 static u32
 read_sram(struct idt77252_dev *card, unsigned long addr)
@@ -176,11 +176,11 @@ read_sram(struct idt77252_dev *card, uns
 	unsigned long flags;
 	u32 value;
 
 	spin_lock_irqsave(&card->cmd_lock, flags);
-	writel(SAR_CMD_READ_SRAM | (addr << 2), SAR_REG_CMD);
+	writel(SAR_CMD_READ_SRAM | (addr << 2), (void __iomem *)SAR_REG_CMD);
 	waitfor_idle(card);
-	value = readl(SAR_REG_DR0);
+	value = readl((void __iomem *)SAR_REG_DR0);
 	spin_unlock_irqrestore(&card->cmd_lock, flags);
 	return value;
 }
 
@@ -198,10 +198,10 @@ write_sram(struct idt77252_dev *card, un
 		       card->name, addr, value);
 	}
 
 	spin_lock_irqsave(&card->cmd_lock, flags);
-	writel(value, SAR_REG_DR0);
-	writel(SAR_CMD_WRITE_SRAM | (addr << 2), SAR_REG_CMD);
+	writel(value, (void __iomem *)SAR_REG_DR0);
+	writel(SAR_CMD_WRITE_SRAM | (addr << 2), (void __iomem *)SAR_REG_CMD);
 	waitfor_idle(card);
 	spin_unlock_irqrestore(&card->cmd_lock, flags);
 }
 
@@ -217,11 +217,11 @@ read_utility(void *dev, unsigned long ub
 		return -1;
 	}
 
 	spin_lock_irqsave(&card->cmd_lock, flags);
-	writel(SAR_CMD_READ_UTILITY + ubus_addr, SAR_REG_CMD);
+	writel(SAR_CMD_READ_UTILITY + ubus_addr, (void __iomem *)SAR_REG_CMD);
 	waitfor_idle(card);
-	value = readl(SAR_REG_DR0);
+	value = readl((void __iomem *)SAR_REG_DR0);
 	spin_unlock_irqrestore(&card->cmd_lock, flags);
 	return value;
 }
 
@@ -236,10 +236,10 @@ write_utility(void *dev, unsigned long u
 		return;
 	}
 
 	spin_lock_irqsave(&card->cmd_lock, flags);
-	writel((u32) value, SAR_REG_DR0);
-	writel(SAR_CMD_WRITE_UTILITY + ubus_addr, SAR_REG_CMD);
+	writel((u32) value, (void __iomem *)SAR_REG_DR0);
+	writel(SAR_CMD_WRITE_UTILITY + ubus_addr, (void __iomem *)SAR_REG_CMD);
 	waitfor_idle(card);
 	spin_unlock_irqrestore(&card->cmd_lock, flags);
 }
 
@@ -373,9 +373,9 @@ idt77252_write_gp(struct idt77252_dev *c
 #endif
 
 	spin_lock_irqsave(&card->cmd_lock, flags);
 	waitfor_idle(card);
-	writel(value, SAR_REG_GP);
+	writel(value, (void __iomem *)SAR_REG_GP);
 	spin_unlock_irqrestore(&card->cmd_lock, flags);
 }
 
 static u8
@@ -737,9 +737,9 @@ push_on_scq(struct idt77252_dev *card, s
 			vc->estimator->avcps = cps << 5;
 			if (vc->lacr < vc->init_er) {
 				vc->lacr = vc->init_er;
 				writel(TCMDQ_LACR | (vc->lacr << 16) |
-				       vc->index, SAR_REG_TCMDQ);
+				       vc->index, (void __iomem *)SAR_REG_TCMDQ);
 			}
 		}
 	}
 	spin_unlock_irqrestore(&vc->lock, flags);
@@ -766,9 +766,9 @@ push_on_scq(struct idt77252_dev *card, s
 	scq->trans_start = jiffies;
 
 	if (test_and_clear_bit(VCF_IDLE, &vc->flags)) {
 		writel(TCMDQ_START_LACR | (vc->lacr << 16) | vc->index,
-		       SAR_REG_TCMDQ);
+		       (void __iomem *)SAR_REG_TCMDQ);
 	}
 
 	TXPRINTK("%d entries in SCQ used (push).\n", atomic_read(&scq->used));
 
@@ -989,10 +989,10 @@ init_rsq(struct idt77252_dev *card)
 	for (rsqe = card->rsq.base; rsqe <= card->rsq.last; rsqe++)
 		rsqe->word_4 = 0;
 
 	writel((unsigned long) card->rsq.last - (unsigned long) card->rsq.base,
-	       SAR_REG_RSQH);
-	writel(card->rsq.paddr, SAR_REG_RSQB);
+	       (void __iomem *)SAR_REG_RSQH);
+	writel(card->rsq.paddr, (void __iomem *)SAR_REG_RSQB);
 
 	IPRINTK("%s: RSQ base at 0x%lx (0x%x).\n", card->name,
 		(unsigned long) card->rsq.base,
 		readl(SAR_REG_RSQB));
@@ -1241,9 +1241,9 @@ idt77252_rx(struct idt77252_dev *card)
 			rsqe = card->rsq.next + 1;
 	} while (le32_to_cpu(rsqe->word_4) & SAR_RSQE_VALID);
 
 	writel((unsigned long) card->rsq.next - (unsigned long) card->rsq.base,
-	       SAR_REG_RSQH);
+	       (void __iomem *)SAR_REG_RSQH);
 }
 
 static void
 idt77252_rx_raw(struct idt77252_dev *card)
@@ -1263,9 +1263,9 @@ idt77252_rx_raw(struct idt77252_dev *car
 	if (!queue)
 		return;
 
 	head = IDT77252_PRV_PADDR(queue) + (queue->data - queue->head - 16);
-	tail = readl(SAR_REG_RAWCT);
+	tail = readl((void __iomem *)SAR_REG_RAWCT);
 
 	pci_dma_sync_single(card->pcidev, IDT77252_PRV_PADDR(queue),
 			    queue->end - queue->head - 16, PCI_DMA_FROMDEVICE);
 
@@ -1398,11 +1398,11 @@ init_tsq(struct idt77252_dev *card)
 	card->tsq.next = card->tsq.last;
 	for (tsqe = card->tsq.base; tsqe <= card->tsq.last; tsqe++)
 		tsqe->word_2 = cpu_to_le32(SAR_TSQE_INVALID);
 
-	writel(card->tsq.paddr, SAR_REG_TSQB);
+	writel(card->tsq.paddr, (void __iomem *)SAR_REG_TSQB);
 	writel((unsigned long) card->tsq.next - (unsigned long) card->tsq.base,
-	       SAR_REG_TSQH);
+	       (void __iomem *)SAR_REG_TSQH);
 
 	return 0;
 }
 
@@ -1531,13 +1531,13 @@ idt77252_tx(struct idt77252_dev *card)
 
 	} while (!(stat & SAR_TSQE_INVALID));
 
 	writel((unsigned long)card->tsq.next - (unsigned long)card->tsq.base,
-	       SAR_REG_TSQH);
+	       (void __iomem *)SAR_REG_TSQH);
 
 	XPRINTK("idt77252_tx-after writel%d: TSQ head = 0x%x, tail = 0x%x, next = 0x%p.\n",
-		card->index, readl(SAR_REG_TSQH),
-		readl(SAR_REG_TSQT), card->tsq.next);
+		card->index, readl((void __iomem *)SAR_REG_TSQH),
+		readl((void __iomem *)SAR_REG_TSQT), card->tsq.next);
 }
 
 
 static void
@@ -1556,9 +1556,9 @@ tst_timer(unsigned long data)
 
 	if (test_bit(TST_SWITCH_WAIT, &card->tst_state)) {
 		jump = base + card->tst_size - 2;
 
-		pc = readl(SAR_REG_NOW) >> 2;
+		pc = readl((void __iomem *)SAR_REG_NOW) >> 2;
 		if ((pc ^ idle) & ~(card->tst_size - 1)) {
 			mod_timer(&card->tst_timer, jiffies + 1);
 			goto out;
 		}
@@ -1798,15 +1798,15 @@ set_tct(struct idt77252_dev *card, struc
 
 static __inline__ int
 idt77252_fbq_level(struct idt77252_dev *card, int queue)
 {
-	return (readl(SAR_REG_STAT) >> (16 + (queue << 2))) & 0x0f;
+	return (readl((void __iomem *)SAR_REG_STAT) >> (16 + (queue << 2))) & 0x0f;
 }
 
 static __inline__ int
 idt77252_fbq_full(struct idt77252_dev *card, int queue)
 {
-	return (readl(SAR_REG_STAT) >> (16 + (queue << 2))) == 0x0f;
+	return (readl((void __iomem *)SAR_REG_STAT) >> (16 + (queue << 2))) == 0x0f;
 }
 
 static int
 push_rx_skb(struct idt77252_dev *card, struct sk_buff *skb, int queue)
@@ -2123,9 +2123,9 @@ idt77252_est_timer(unsigned long data)
 		lacr = vc->max_er;
 
 	if (lacr != vc->lacr) {
 		vc->lacr = lacr;
-		writel(TCMDQ_LACR|(vc->lacr << 16)|vc->index, SAR_REG_TCMDQ);
+		writel(TCMDQ_LACR|(vc->lacr << 16)|vc->index, (void __iomem *)SAR_REG_TCMDQ);
 	}
 
 	est->timer.expires = jiffies + ((HZ / 4) << est->interval);
 	add_timer(&est->timer);
@@ -2319,9 +2319,9 @@ idt77252_init_tx(struct idt77252_dev *ca
 				return error;
 			}
 
 			clear_bit(VCF_IDLE, &vc->flags);
-			writel(TCMDQ_START | vc->index, SAR_REG_TCMDQ);
+			writel(TCMDQ_START | vc->index, (void __iomem *)SAR_REG_TCMDQ);
 			break;
 
 		case SCHED_UBR:
 			error = idt77252_init_ubr(card, vc, vcc, qos);
@@ -2396,9 +2396,9 @@ idt77252_init_rx(struct idt77252_dev *ca
 	OPRINTK("%s: writing RCT at 0x%lx\n", card->name, addr);
 	write_sram(card, addr, rcte);
 
 	spin_lock_irqsave(&card->cmd_lock, flags);
-	writel(SAR_CMD_OPEN_CONNECTION | (addr << 2), SAR_REG_CMD);
+	writel(SAR_CMD_OPEN_CONNECTION | (addr << 2), (void __iomem *)SAR_REG_CMD);
 	waitfor_idle(card);
 	spin_unlock_irqrestore(&card->cmd_lock, flags);
 
 	return 0;
@@ -2537,9 +2537,9 @@ idt77252_close(struct atm_vcc *vcc)
 
 		addr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;
 
 		spin_lock_irqsave(&card->cmd_lock, flags);
-		writel(SAR_CMD_CLOSE_CONNECTION | (addr << 2), SAR_REG_CMD);
+		writel(SAR_CMD_CLOSE_CONNECTION | (addr << 2), (void __iomem *)SAR_REG_CMD);
 		waitfor_idle(card);
 		spin_unlock_irqrestore(&card->cmd_lock, flags);
 
 		if (vc->rcv.rx_pool.count) {
@@ -2575,9 +2575,9 @@ done:
 		if (!timeout)
 			printk("%s: SCQ drain timeout: %u used\n",
 			       card->name, atomic_read(&vc->scq->used));
 
-		writel(TCMDQ_HALT | vc->index, SAR_REG_TCMDQ);
+		writel(TCMDQ_HALT | vc->index, (void __iomem *)SAR_REG_TCMDQ);
 		clear_scd(card, vc->scq, vc->class);
 
 		if (vc->class == SCHED_CBR) {
 			clear_tst(card, vc);
@@ -2621,9 +2621,9 @@ idt77252_change_qos(struct atm_vcc *vcc,
 					goto out;
 
 				if (!test_bit(VCF_IDLE, &vc->flags)) {
 					writel(TCMDQ_LACR | (vc->lacr << 16) |
-					       vc->index, SAR_REG_TCMDQ);
+					       vc->index, (void __iomem *)SAR_REG_TCMDQ);
 				}
 				break;
 
 			case ATM_VBR:
@@ -2728,11 +2728,11 @@ static void
 idt77252_collect_stat(struct idt77252_dev *card)
 {
 	u32 cdc, vpec, icc;
 
-	cdc = readl(SAR_REG_CDC);
-	vpec = readl(SAR_REG_VPEC);
-	icc = readl(SAR_REG_ICC);
+	cdc = readl((void __iomem *)SAR_REG_CDC);
+	vpec = readl((void __iomem *)SAR_REG_VPEC);
+	icc = readl((void __iomem *)SAR_REG_ICC);
 
 #ifdef	NOTDEF
 	printk("%s:", card->name);
 
@@ -2781,18 +2781,18 @@ idt77252_interrupt(int irq, void *dev_id
 {
 	struct idt77252_dev *card = dev_id;
 	u32 stat;
 
-	stat = readl(SAR_REG_STAT) & 0xffff;
+	stat = readl((void __iomem *)SAR_REG_STAT) & 0xffff;
 	if (!stat)	/* no interrupt for us */
 		return IRQ_NONE;
 
 	if (test_and_set_bit(IDT77252_BIT_INTERRUPT, &card->flags)) {
 		printk("%s: Re-entering irq_handler()\n", card->name);
 		goto out;
 	}
 
-	writel(stat, SAR_REG_STAT);	/* reset interrupt */
+	writel(stat, (void __iomem *)SAR_REG_STAT);	/* reset interrupt */
 
 	if (stat & SAR_STAT_TSIF) {	/* entry written to TSQ  */
 		INTPRINTK("%s: TSIF\n", card->name);
 		card->irqstat[15]++;
@@ -2846,9 +2846,9 @@ idt77252_interrupt(int irq, void *dev_id
 
 	if (stat & (SAR_STAT_FBQ0A | SAR_STAT_FBQ1A |
 		    SAR_STAT_FBQ2A | SAR_STAT_FBQ3A)) {
 
-		writel(readl(SAR_REG_CFG) & ~(SAR_CFG_FBIE), SAR_REG_CFG);
+		writel(readl((void __iomem *)SAR_REG_CFG) & ~(SAR_CFG_FBIE), (void __iomem *)SAR_REG_CFG);
 
 		INTPRINTK("%s: FBQA: %04x\n", card->name, stat);
 
 		if (stat & SAR_STAT_FBQ0A)
@@ -2875,9 +2875,9 @@ idt77252_softint(void *dev_id)
 	u32 stat;
 	int done;
 
 	for (done = 1; ; done = 1) {
-		stat = readl(SAR_REG_STAT) >> 16;
+		stat = readl((void __iomem *)SAR_REG_STAT) >> 16;
 
 		if ((stat & 0x0f) < SAR_FBQ0_HIGH) {
 			add_rx_skb(card, 0, SAR_FB_SIZE_0, 32);
 			done = 0;
@@ -2904,9 +2904,9 @@ idt77252_softint(void *dev_id)
 		if (done)
 			break;
 	}
 
-	writel(readl(SAR_REG_CFG) | SAR_CFG_FBIE, SAR_REG_CFG);
+	writel(readl((void __iomem *)SAR_REG_CFG) | SAR_CFG_FBIE, (void __iomem *)SAR_REG_CFG);
 }
 
 
 static int
@@ -2944,9 +2944,9 @@ open_card_oam(struct idt77252_dev *card)
 			write_sram(card, addr, rcte);
 
 			spin_lock_irqsave(&card->cmd_lock, flags);
 			writel(SAR_CMD_OPEN_CONNECTION | (addr << 2),
-			       SAR_REG_CMD);
+			       (void __iomem *)SAR_REG_CMD);
 			waitfor_idle(card);
 			spin_unlock_irqrestore(&card->cmd_lock, flags);
 		}
 	}
@@ -2971,9 +2971,9 @@ close_card_oam(struct idt77252_dev *card
 			addr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;
 
 			spin_lock_irqsave(&card->cmd_lock, flags);
 			writel(SAR_CMD_CLOSE_CONNECTION | (addr << 2),
-			       SAR_REG_CMD);
+			       (void __iomem *)SAR_REG_CMD);
 			waitfor_idle(card);
 			spin_unlock_irqrestore(&card->cmd_lock, flags);
 
 			if (vc->rcv.rx_pool.count) {
@@ -3022,9 +3022,9 @@ open_card_ubr0(struct idt77252_dev *card
 	write_sram(card, card->tct_base + 6, 0);
 	write_sram(card, card->tct_base + 7, TCT_FLAG_UBR);
 
 	clear_bit(VCF_IDLE, &vc->flags);
-	writel(TCMDQ_START | 0, SAR_REG_TCMDQ);
+	writel(TCMDQ_START | 0, (void __iomem *)SAR_REG_TCMDQ);
 	return 0;
 }
 
 static int
@@ -3054,9 +3054,9 @@ idt77252_dev_open(struct idt77252_dev *c
 	/* Test RAW cell receive. */
 	conf |= SAR_CFG_VPECA;
 #endif
 
-	writel(readl(SAR_REG_CFG) | conf, SAR_REG_CFG);
+	writel(readl((void __iomem *)SAR_REG_CFG) | conf, (void __iomem *)SAR_REG_CFG);
 
 	if (open_card_oam(card)) {
 		printk("%s: Error initializing OAM.\n", card->name);
 		return -1;
@@ -3090,9 +3090,9 @@ idt77252_dev_close(struct atm_dev *dev)
 	    SAR_CFG_TXUIE |	/* interrupt on xmit underrun    */
 	    SAR_CFG_TXSFI	/* interrupt on TSQ almost full  */
 	    ;
 
-	writel(readl(SAR_REG_CFG) & ~(conf), SAR_REG_CFG);
+	writel(readl((void __iomem *)SAR_REG_CFG) & ~(conf), (void __iomem *)SAR_REG_CFG);
 
 	DIPRINTK("%s: closed IDT77252 ABR SAR.\n", card->name);
 }
 
@@ -3115,9 +3115,9 @@ deinit_card(struct idt77252_dev *card)
 		return;
 	}
 	DIPRINTK("idt77252: deinitialize card %u\n", card->index);
 
-	writel(0, SAR_REG_CFG);
+	writel(0, (void __iomem *)SAR_REG_CFG);
 
 	if (card->atmdev)
 		atm_dev_deregister(card->atmdev);
 
@@ -3163,9 +3163,9 @@ deinit_card(struct idt77252_dev *card)
 	free_irq(card->pcidev->irq, card);
 
 	for (i = 0; i < 4; i++) {
 		if (card->fbq[i])
-			iounmap((void *) card->fbq[i]);
+			iounmap((void __iomem *) card->fbq[i]);
 	}
 
 	if (card->membase)
 		iounmap((void *) card->membase);
@@ -3246,15 +3246,15 @@ init_sram(struct idt77252_dev *card)
 				    (u32) 0xffffffff);
 	}
 
 	writel((SAR_FBQ0_LOW << 28) | 0x00000000 | 0x00000000 |
-	       (SAR_FB_SIZE_0 / 48), SAR_REG_FBQS0);
+	       (SAR_FB_SIZE_0 / 48), (void __iomem *)SAR_REG_FBQS0);
 	writel((SAR_FBQ1_LOW << 28) | 0x00000000 | 0x00000000 |
-	       (SAR_FB_SIZE_1 / 48), SAR_REG_FBQS1);
+	       (SAR_FB_SIZE_1 / 48), (void __iomem *)SAR_REG_FBQS1);
 	writel((SAR_FBQ2_LOW << 28) | 0x00000000 | 0x00000000 |
-	       (SAR_FB_SIZE_2 / 48), SAR_REG_FBQS2);
+	       (SAR_FB_SIZE_2 / 48), (void __iomem *)SAR_REG_FBQS2);
 	writel((SAR_FBQ3_LOW << 28) | 0x00000000 | 0x00000000 |
-	       (SAR_FB_SIZE_3 / 48), SAR_REG_FBQS3);
+	       (SAR_FB_SIZE_3 / 48), (void __iomem *)SAR_REG_FBQS3);
 
 	/* Initialize rate table  */
 	for (i = 0; i < 256; i++) {
 		write_sram(card, card->rt_base + i, log_to_rate[i]);
@@ -3288,9 +3288,9 @@ init_sram(struct idt77252_dev *card)
 	}
 #endif
 
 	IPRINTK("%s: initialize rate table ...\n", card->name);
-	writel(card->rt_base << 2, SAR_REG_RTBL);
+	writel(card->rt_base << 2, (void __iomem *)SAR_REG_RTBL);
 
 	/* Initialize TSTs */
 	IPRINTK("%s: initialize TST ...\n", card->name);
 	card->tst_free = card->tst_size - 2;	/* last two are jumps */
@@ -3308,18 +3308,18 @@ init_sram(struct idt77252_dev *card)
 	write_sram(card, i++, TSTE_OPC_JMP | (card->tst[0] << 2));
 	idt77252_sram_write_errors = 0;
 
 	card->tst_index = 0;
-	writel(card->tst[0] << 2, SAR_REG_TSTB);
+	writel(card->tst[0] << 2, (void __iomem *)SAR_REG_TSTB);
 
 	/* Initialize ABRSTD and Receive FIFO */
 	IPRINTK("%s: initialize ABRSTD ...\n", card->name);
 	writel(card->abrst_size | (card->abrst_base << 2),
-	       SAR_REG_ABRSTD);
+	       (void __iomem *)SAR_REG_ABRSTD);
 
 	IPRINTK("%s: initialize receive fifo ...\n", card->name);
 	writel(card->fifo_size | (card->fifo_base << 2),
-	       SAR_REG_RXFD);
+	       (void __iomem *)SAR_REG_RXFD);
 
 	IPRINTK("%s: SRAM initialization complete.\n", card->name);
 	return 0;
 }
@@ -3381,11 +3381,11 @@ init_card(struct atm_dev *dev)
 			return -1;
 		}
 	}
 	/* Reset Timer register */
-	if (readl(SAR_REG_STAT) & SAR_STAT_TMROF) {
+	if (readl((void __iomem *)SAR_REG_STAT) & SAR_STAT_TMROF) {
 		printk("%s: resetting timer overflow.\n", card->name);
-		writel(SAR_STAT_TMROF, SAR_REG_STAT);
+		writel(SAR_STAT_TMROF, (void __iomem *)SAR_REG_STAT);
 	}
 	IPRINTK("%s: Request IRQ ... ", card->name);
 	if (request_irq(pcidev->irq, idt77252_interrupt, SA_INTERRUPT|SA_SHIRQ,
 			card->name, card) != 0) {
@@ -3430,9 +3430,9 @@ init_card(struct atm_dev *dev)
 		conf |= SAR_CFG_VPVCS_8;
 		break;
 	}
 
-	writel(readl(SAR_REG_CFG) | conf, SAR_REG_CFG);
+	writel(readl((void __iomem *)SAR_REG_CFG) | conf, (void __iomem *)SAR_REG_CFG);
 
 	if (init_sram(card) < 0)
 		return -1;
 
@@ -3463,12 +3463,12 @@ init_card(struct atm_dev *dev)
 		i <<= 1;
 	}
 
 	IPRINTK("%s: Setting VPI/VCI mask to zero.\n", card->name);
-	writel(0, SAR_REG_VPM);
+	writel(0, (void __iomem *)SAR_REG_VPM);
 
 	/* Little Endian Order   */
-	writel(0, SAR_REG_GP);
+	writel(0, (void __iomem *)SAR_REG_GP);
 
 	/* Initialize RAW Cell Handle Register  */
 	card->raw_cell_hnd = pci_alloc_consistent(card->pcidev, 2 * sizeof(u32),
 						  &card->raw_cell_paddr);
@@ -3477,9 +3477,9 @@ init_card(struct atm_dev *dev)
 		deinit_card(card);
 		return -1;
 	}
 	memset(card->raw_cell_hnd, 0, 2 * sizeof(u32));
-	writel(card->raw_cell_paddr, SAR_REG_RAWHND);
+	writel(card->raw_cell_paddr, (void __iomem *)SAR_REG_RAWHND);
 	IPRINTK("%s: raw cell handle is at 0x%p.\n", card->name,
 		card->raw_cell_hnd);
 
 	size = sizeof(struct vc_map *) * card->tct_size;
@@ -3590,9 +3590,9 @@ init_card(struct atm_dev *dev)
 	 * XXX: </hack>
 	 */
 
 	/* Set Maximum Deficit Count for now. */
-	writel(0xffff, SAR_REG_MDFCT);
+	writel(0xffff, (void __iomem *)SAR_REG_MDFCT);
 
 	set_bit(IDT77252_BIT_INIT, &card->flags);
 
 	XPRINTK("%s: IDT77252 ABR SAR initialization complete.\n", card->name);
@@ -3639,11 +3639,11 @@ idt77252_preset(struct idt77252_dev *car
 /*   G E N E R I C   R E S E T                                   */
 /*****************************************************************/
 
 	/* Software reset */
-	writel(SAR_CFG_SWRST, SAR_REG_CFG);
+	writel(SAR_CFG_SWRST, (void __iomem *)SAR_REG_CFG);
 	mdelay(1);
-	writel(0, SAR_REG_CFG);
+	writel(0, (void __iomem *)SAR_REG_CFG);
 
 	IPRINTK("%s: Software resetted.\n", card->name);
 	return 0;
 }
@@ -3653,17 +3653,17 @@ static unsigned long __devinit
 probe_sram(struct idt77252_dev *card)
 {
 	u32 data, addr;
 
-	writel(0, SAR_REG_DR0);
-	writel(SAR_CMD_WRITE_SRAM | (0 << 2), SAR_REG_CMD);
+	writel(0, (void __iomem *)SAR_REG_DR0);
+	writel(SAR_CMD_WRITE_SRAM | (0 << 2), (void __iomem *)SAR_REG_CMD);
 
 	for (addr = 0x4000; addr < 0x80000; addr += 0x4000) {
-		writel(0xdeadbeef, SAR_REG_DR0);
-		writel(SAR_CMD_WRITE_SRAM | (addr << 2), SAR_REG_CMD);
+		writel(0xdeadbeef, (void __iomem *)SAR_REG_DR0);
+		writel(SAR_CMD_WRITE_SRAM | (addr << 2), (void __iomem *)SAR_REG_CMD);
 
-		writel(SAR_CMD_READ_SRAM | (0 << 2), SAR_REG_CMD);
-		data = readl(SAR_REG_DR0);
+		writel(SAR_CMD_READ_SRAM | (0 << 2), (void __iomem *)SAR_REG_CMD);
+		data = readl((void __iomem *)SAR_REG_DR0);
 
 		if (data != 0)
 			break;
 	}
@@ -3755,9 +3755,9 @@ idt77252_init_one(struct pci_dev *pcidev
 
 	card->sramsize = probe_sram(card);
 
 	for (i = 0; i < 4; i++) {
-		card->fbq[i] = (unsigned long)
+		card->fbq[i] = 
 			    ioremap(srambase | 0x200000 | (i << 18), 4);
 		if (!card->fbq[i]) {
 			printk("%s: can't ioremap() FBQ%d\n", card->name, i);
 			err = -EIO;
Index: linux-2.6.8/drivers/atm/nicstar.c
===================================================================
--- linux-2.6.8.orig/drivers/atm/nicstar.c
+++ linux-2.6.8/drivers/atm/nicstar.c
@@ -466,8 +466,9 @@ static int __devinit ns_init_card(int i,
    u32 data;
    u32 u32d[4];
    u32 ns_cfg_rctsize;
    int bcount;
+   unsigned long mbase;
 
    error = 0;
 
    if (pci_enable_device(pcidev))
@@ -493,10 +494,10 @@ static int __devinit ns_init_card(int i,
    
    card->index = i;
    card->atmdev = NULL;
    card->pcidev = pcidev;
-   card->membase = pci_resource_start(pcidev, 1);
-   card->membase = (unsigned long) ioremap(card->membase, NS_IOREMAP_SIZE);
+   mbase = pci_resource_start(pcidev, 1);
+   card->membase = ioremap(mbase, NS_IOREMAP_SIZE);
    if (card->membase == 0)
    {
       printk("nicstar%d: can't ioremap() membase.\n",i);
       error = 3;
Index: linux-2.6.8/drivers/atm/iphase.c
===================================================================
--- linux-2.6.8.orig/drivers/atm/iphase.c
+++ linux-2.6.8/drivers/atm/iphase.c
@@ -1009,9 +1009,10 @@ static struct atm_dev *ia_boards = NULL;
   
 void desc_dbg(IADEV *iadev) {
 
   u_short tcq_wr_ptr, tcq_st_ptr, tcq_ed_ptr;
-  u32 tmp, i;
+  u32 i;
+  void __iomem *tmp;
   // regval = readl((u32)ia_cmds->maddr);
   tcq_wr_ptr =  readw(iadev->seg_reg+TCQ_WR_PTR);
   printk("B_tcq_wr = 0x%x desc = %d last desc = %d\n",
                      tcq_wr_ptr, readw(iadev->seg_ram+tcq_wr_ptr),
@@ -1023,9 +1024,9 @@ void desc_dbg(IADEV *iadev) {
   printk("tcq_st_ptr = 0x%x    tcq_ed_ptr = 0x%x \n", tcq_st_ptr, tcq_ed_ptr);
   i = 0;
   while (tcq_st_ptr != tcq_ed_ptr) {
       tmp = iadev->seg_ram+tcq_st_ptr;
-      printk("TCQ slot %d desc = %d  Addr = 0x%x\n", i++, readw(tmp), tmp);
+      printk("TCQ slot %d desc = %d  Addr = %p\n", i++, readw(tmp), tmp);
       tcq_st_ptr += 2;
   }
   for(i=0; i <iadev->num_tx_desc; i++)
       printk("Desc_tbl[%d] = %d \n", i, iadev->desc_tbl[i].timestamp);
@@ -2033,28 +2034,28 @@ static int tx_init(struct atm_dev *dev) 
         IF_INIT(printk("Start CBR Init\n");)
 #if 1  /* for 1K VC board, CBR_PTR_BASE is 0 */
         writew(0,iadev->seg_reg+CBR_PTR_BASE);
 #else /* Charlie's logic is wrong ? */
-        tmp16 = (iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize)>>17;
+        tmp16 = (u_short) (iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize)>>17;
         IF_INIT(printk("cbr_ptr_base = 0x%x ", tmp16);)
         writew(tmp16,iadev->seg_reg+CBR_PTR_BASE);
 #endif
 
         IF_INIT(printk("value in register = 0x%x\n",
                                    readw(iadev->seg_reg+CBR_PTR_BASE));)
-        tmp16 = (CBR_SCHED_TABLE*iadev->memSize) >> 1;
+        tmp16 = (u_short) (CBR_SCHED_TABLE*iadev->memSize) >> 1;
         writew(tmp16, iadev->seg_reg+CBR_TAB_BEG);
         IF_INIT(printk("cbr_tab_beg = 0x%x in reg = 0x%x \n", tmp16,
                                         readw(iadev->seg_reg+CBR_TAB_BEG));)
         writew(tmp16, iadev->seg_reg+CBR_TAB_END+1); // CBR_PTR;
-        tmp16 = (CBR_SCHED_TABLE*iadev->memSize + iadev->num_vc*6 - 2) >> 1;
+        tmp16 = (u_short) (CBR_SCHED_TABLE*iadev->memSize + iadev->num_vc*6 - 2) >> 1;
         writew(tmp16, iadev->seg_reg+CBR_TAB_END);
-        IF_INIT(printk("iadev->seg_reg = 0x%x CBR_PTR_BASE = 0x%x\n",
+        IF_INIT(printk("iadev->seg_reg = 0x%p CBR_PTR_BASE = 0x%x\n",
                (u32)iadev->seg_reg, readw(iadev->seg_reg+CBR_PTR_BASE));)
         IF_INIT(printk("CBR_TAB_BEG = 0x%x, CBR_TAB_END = 0x%x, CBR_PTR = 0x%x\n",
           readw(iadev->seg_reg+CBR_TAB_BEG), readw(iadev->seg_reg+CBR_TAB_END),
           readw(iadev->seg_reg+CBR_TAB_END+1));)
-        tmp16 = (iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize);
+        tmp16 = (u_short) (iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize);
 
         /* Initialize the CBR Schedualing Table */
         memset((caddr_t)(iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize), 
                                                           0, iadev->num_vc*6); 
Index: linux-2.6.8/drivers/atm/he.c
===================================================================
--- linux-2.6.8.orig/drivers/atm/he.c
+++ linux-2.6.8/drivers/atm/he.c
@@ -1006,8 +1006,9 @@ static int __init
 he_start(struct atm_dev *dev)
 {
 	struct he_dev *he_dev;
 	struct pci_dev *pci_dev;
+	unsigned long mbase;
 
 	u16 command;
 	u32 gen_cntl_0, host_cntl, lb_swap;
 	u8 cache_size, timer;
@@ -1018,10 +1019,10 @@ he_start(struct atm_dev *dev)
 
 	he_dev = HE_DEV(dev);
 	pci_dev = he_dev->pci_dev;
 
-	he_dev->membase = pci_dev->resource[0].start;
-	HPRINTK("membase = 0x%lx  irq = %d.\n", he_dev->membase, pci_dev->irq);
+	mbase = pci_dev->resource[0].start;
+	HPRINTK("membase = 0x%p  irq = %d.\n", he_dev->membase, pci_dev->irq);
 
 	/*
 	 * pci bus controller initialization 
 	 */
@@ -1079,9 +1080,9 @@ he_start(struct atm_dev *dev)
 		if (pci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, timer))
 			hprintk("can't set latency timer to %d\n", timer);
 	}
 
-	if (!(he_dev->membase = (unsigned long) ioremap(he_dev->membase, HE_REGMAP_SIZE))) {
+	if (!(he_dev->membase = ioremap(mbase, HE_REGMAP_SIZE))) {
 		hprintk("can't set up page mapping\n");
 		return -EINVAL;
 	}
 
