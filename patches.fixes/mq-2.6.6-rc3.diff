reverted:
Index: linux-2.6.5/arch/ia64/ia32/ia32_entry.S
===================================================================
--- linux-2.6.5.orig/arch/ia64/ia32/ia32_entry.S
+++ linux-2.6.5/arch/ia64/ia32/ia32_entry.S
@@ -483,6 +483,14 @@ ia32_syscall_table:
  	data8 sys32_fadvise64_64
  	data8 sys_ni_syscall
   	data8 sys_ni_syscall
+ 	data8 sys_ni_syscall	/* 275 */
+  	data8 sys_ni_syscall
+  	data8 compat_sys_mq_open
+  	data8 sys_mq_unlink
+  	data8 compat_sys_mq_timedsend
+  	data8 compat_sys_mq_timedreceive	/* 280 */
+  	data8 compat_sys_mq_notify
+  	data8 compat_sys_mq_getsetattr
 
 	// guard against failures to increase IA32_NR_syscalls
 	.org ia32_syscall_table + 8*IA32_NR_syscalls
Index: linux-2.6.5/arch/ia64/kernel/entry.S
===================================================================
--- linux-2.6.5.orig/arch/ia64/kernel/entry.S
+++ linux-2.6.5/arch/ia64/kernel/entry.S
@@ -1504,12 +1504,12 @@ sys_call_table:
 	data8 sys_mbind
 	data8 sys_get_mempolicy			// 1260
 	data8 sys_set_mempolicy
-	data8 sys_ni_syscall
-	data8 sys_ni_syscall
-	data8 sys_ni_syscall
-	data8 sys_ni_syscall			// 1265
-	data8 sys_ni_syscall
-	data8 sys_ni_syscall
+	data8 sys_mq_open
+	data8 sys_mq_unlink
+	data8 sys_mq_timedsend
+	data8 sys_mq_timedreceive               // 1265
+	data8 sys_mq_notify
+	data8 sys_mq_getsetattr
 	data8 sys_ni_syscall
 	data8 sys_ni_syscall
 	data8 sys_ni_syscall			// 1270
Index: linux-2.6.5/arch/ia64/kernel/fsys.S
===================================================================
--- linux-2.6.5.orig/arch/ia64/kernel/fsys.S
+++ linux-2.6.5/arch/ia64/kernel/fsys.S
@@ -851,12 +851,12 @@ fsyscall_table:
 	data8 0
 	data8 0							// 1260
 	data8 0
-	data8 0
-	data8 0
-	data8 0
-	data8 0							// 1265
-	data8 0
-	data8 0
+	data8 0				// mq_open
+	data8 0				// mq_unlink
+	data8 0				// mq_timedsend
+	data8 0				// mq_timedreceive	// 1265
+	data8 0				// mq_notify
+	data8 0				// mq_getsetattr
 	data8 0
 	data8 0
 	data8 0							// 1270
Index: linux-2.6.5/arch/ppc/kernel/misc.S
===================================================================
--- linux-2.6.5.orig/arch/ppc/kernel/misc.S
+++ linux-2.6.5/arch/ppc/kernel/misc.S
@@ -1369,4 +1369,16 @@ _GLOBAL(sys_call_table)
 	.long sys_statfs64
 	.long sys_fstatfs64
 	.long ppc_fadvise64_64
-	.long sys_ni_syscall	/* 255 - rtas (used on ppc64) */
+	.long sys_ni_syscall		/* 255 - rtas (used on ppc64) */
+	.long sys_ni_syscall		/* 256 reserved for sys_debug_setcontext */
+	.long sys_ni_syscall		/* 257 reserved for vserver */
+	.long sys_ni_syscall		/* 258 reserved for new sys_remap_file_pages */
+	.long sys_ni_syscall		/* 259 reserved for new sys_mbind */
+	.long sys_ni_syscall		/* 260 reserved for new sys_get_mempolicy */
+	.long sys_ni_syscall		/* 261 reserved for new sys_set_mempolicy */
+	.long sys_mq_open
+	.long sys_mq_unlink
+	.long sys_mq_timedsend
+	.long sys_mq_timedreceive	/* 265 */
+	.long sys_mq_notify
+	.long sys_mq_getsetattr
Index: linux-2.6.5/arch/ppc64/kernel/misc.S
===================================================================
--- linux-2.6.5.orig/arch/ppc64/kernel/misc.S
+++ linux-2.6.5/arch/ppc64/kernel/misc.S
@@ -834,21 +834,13 @@ _GLOBAL(sys_call_table32)
 	.llong .sys_ni_syscall		/* 259 reserved for new sys_mbind */
 	.llong .sys_ni_syscall		/* 260 reserved for new sys_get_mempolicy */
 	.llong .sys_ni_syscall		/* 261 reserved for new sys_set_mempolicy */
-#if 0
 	.llong .compat_sys_mq_open
 	.llong .sys_mq_unlink
 	.llong .compat_sys_mq_timedsend
 	.llong .compat_sys_mq_timedreceive /* 265 */
 	.llong .compat_sys_mq_notify
 	.llong .compat_sys_mq_getsetattr
-#else
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-#endif
+
 	.balign 8
 _GLOBAL(sys_call_table)
 	.llong .sys_restart_syscall	/* 0 */
@@ -1113,18 +1105,9 @@ _GLOBAL(sys_call_table)
 	.llong .sys_ni_syscall		/* 259 reserved for new sys_mbind */
 	.llong .sys_ni_syscall		/* 260 reserved for new sys_get_mempolicy */
 	.llong .sys_ni_syscall		/* 261 reserved for new sys_set_mempolicy */
-#if 0
 	.llong .sys_mq_open
 	.llong .sys_mq_unlink
 	.llong .sys_mq_timedsend
 	.llong .sys_mq_timedreceive	/* 265 */
 	.llong .sys_mq_notify
 	.llong .sys_mq_getsetattr
-#else
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-	.llong .sys_ni_syscall
-#endif
Index: linux-2.6.5/arch/s390/kernel/compat_wrapper.S
===================================================================
--- linux-2.6.5.orig/arch/s390/kernel/compat_wrapper.S
+++ linux-2.6.5/arch/s390/kernel/compat_wrapper.S
@@ -1361,7 +1361,7 @@ compat_sys_mq_open_wrapper:
 	llgtr	%r5,%r5			# struct compat_mq_attr *
 	jg	compat_sys_mq_open
 
-	.globl	sys_mq_unlink_wrapper
+	.globl	sys32_mq_unlink_wrapper
 sys32_mq_unlink_wrapper:
 	llgtr	%r2,%r2			# const char *
 	jg	sys_mq_unlink
Index: linux-2.6.5/arch/sparc/kernel/systbls.S
===================================================================
--- linux-2.6.5.orig/arch/sparc/kernel/systbls.S
+++ linux-2.6.5/arch/sparc/kernel/systbls.S
@@ -73,7 +73,9 @@ sys_call_table:
 /*255*/	.long sys_nis_syscall, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep
 /*260*/	.long sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
 /*265*/	.long sys_timer_delete, sys_timer_create, sys_nis_syscall, sys_io_setup, sys_io_destroy
-/*270*/	.long sys_io_submit, sys_io_cancel, sys_io_getevents, sys_nis_syscall
+/*270*/	.long sys_io_submit, sys_io_cancel, sys_io_getevents, sys_mq_open, sys_mq_unlink
+/*275*/	.long sys_mq_timedsend, sys_mq_timedreceive, sys_mq_notify, sys_mq_getsetattr, sys_ni_syscall
+/*280*/	.long sys_ni_syscall, sys_ni_syscall, sys_ni_syscall
 
 #ifdef CONFIG_SUNOS_EMUL
 	/* Now the SunOS syscall table. */
@@ -175,6 +177,9 @@ sunos_sys_table:
 	.long sunos_nosys, sunos_nosys, sunos_nosys
 	.long sunos_nosys
 /*270*/	.long sunos_nosys, sunos_nosys, sunos_nosys
+	.long sunos_nosys, sunos_nosys, sunos_nosys
+	.long sunos_nosys, sunos_nosys, sunos_nosys
 	.long sunos_nosys
+/*280*/	.long sunos_nosys, sunos_nosys, sunos_nosys
 
 #endif
Index: linux-2.6.5/arch/sparc64/kernel/sys32.S
===================================================================
--- linux-2.6.5.orig/arch/sparc64/kernel/sys32.S
+++ linux-2.6.5/arch/sparc64/kernel/sys32.S
@@ -68,6 +68,17 @@ sys32_mmap2:
 	jmpl		%g1 + %lo(sys_mmap), %g0
 	 sllx		%o5, 12, %o5
 
+	.globl		sys32_mq_timedsend
+sys32_mq_timedsend:
+	sethi		%hi(compat_sys_mq_timedsend), %g1
+	jmpl		%g1 + %lo(compat_sys_mq_timedsend), %g0
+	 srl		%o4, 0, %o4
+	.globl		sys32_mq_timedreceive
+sys32_mq_timedreceive:
+	sethi		%hi(compat_sys_mq_timedreceive), %g1
+	jmpl		%g1 + %lo(compat_sys_mq_timedreceive), %g0
+	 srl		%o4, 0, %o4
+
 	.align		32
 	.globl		sys32_socketcall
 sys32_socketcall:	/* %o0=call, %o1=args */
Index: linux-2.6.5/arch/sparc64/kernel/systbls.S
===================================================================
--- linux-2.6.5.orig/arch/sparc64/kernel/systbls.S
+++ linux-2.6.5/arch/sparc64/kernel/systbls.S
@@ -73,7 +73,9 @@ sys_call_table32:
 	.word sys_ni_syscall, compat_clock_settime, compat_clock_gettime, compat_clock_getres, compat_clock_nanosleep
 /*260*/	.word compat_sys_sched_getaffinity, compat_sys_sched_setaffinity, compat_timer_settime, compat_timer_gettime, sys_timer_getoverrun
 	.word sys_timer_delete, sys32_timer_create, sys_ni_syscall, compat_sys_io_setup, sys_io_destroy
-/*270*/	.word compat_sys_io_submit, sys_io_cancel, compat_sys_io_getevents, sys_ni_syscall
+/*270*/	.word compat_sys_io_submit, sys_io_cancel, compat_sys_io_getevents, compat_sys_mq_open, sys_mq_unlink
+	.word sys32_mq_timedsend, sys32_mq_timedreceive, compat_sys_mq_notify, compat_sys_mq_getsetattr, sys_ni_syscall
+/*280*/	.word sys_ni_syscall, sys_ni_syscall, sys_ni_syscall
 
 	/* Now the 64-bit native Linux syscall table. */
 
@@ -135,7 +137,9 @@ sys_call_table:
 	.word sys_ni_syscall, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep
 /*260*/	.word sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun
 	.word sys_timer_delete, sys_timer_create, sys_ni_syscall, sys_io_setup, sys_io_destroy
-/*270*/	.word sys_io_submit, sys_io_cancel, sys_io_getevents, sys_ni_syscall
+/*270*/	.word sys_io_submit, sys_io_cancel, sys_io_getevents, sys_mq_open, sys_mq_unlink
+	.word sys_mq_timedsend, sys_mq_timedreceive, sys_mq_notify, sys_mq_getsetattr, sys_ni_syscall
+/*280*/	.word sys_ni_syscall, sys_ni_syscall, sys_ni_syscall
 
 #if defined(CONFIG_SUNOS_EMUL) || defined(CONFIG_SOLARIS_EMUL) || \
     defined(CONFIG_SOLARIS_EMUL_MODULE)
@@ -237,5 +241,8 @@ sunos_sys_table:
 	.word sunos_nosys, sunos_nosys, sunos_nosys
 	.word sunos_nosys, sunos_nosys, sunos_nosys
 	.word sunos_nosys, sunos_nosys, sunos_nosys
+	.word sunos_nosys, sunos_nosys, sunos_nosys
+	.word sunos_nosys, sunos_nosys, sunos_nosys
+	.word sunos_nosys, sunos_nosys, sunos_nosys
 
 #endif
Index: linux-2.6.5/include/asm-ia64/unistd.h
===================================================================
--- linux-2.6.5.orig/include/asm-ia64/unistd.h
+++ linux-2.6.5/include/asm-ia64/unistd.h
@@ -251,6 +251,12 @@
 #define __NR_mbind			1259
 #define __NR_get_mempolicy		1260
 #define __NR_set_mempolicy		1261
+#define __NR_mq_open			1262
+#define __NR_mq_unlink			1263
+#define __NR_mq_timedsend		1264
+#define __NR_mq_timedreceive		1265
+#define __NR_mq_notify			1266
+#define __NR_mq_getsetattr		1267
 
 #ifdef __KERNEL__
 
Index: linux-2.6.5/include/asm-ppc/unistd.h
===================================================================
--- linux-2.6.5.orig/include/asm-ppc/unistd.h
+++ linux-2.6.5/include/asm-ppc/unistd.h
@@ -260,8 +260,20 @@
 #define __NR_fstatfs64		253
 #define __NR_fadvise64_64	254
 #define __NR_rtas		255
+/* Number 256 is reserved for sys_debug_setcontext */
+/* Number 257 is reserved for vserver */
+/* Number 258 is reserved for new sys_remap_file_pages */
+/* Number 259 is reserved for new sys_mbind */
+/* Number 260 is reserved for new sys_get_mempolicy */
+/* Number 261 is reserved for new sys_set_mempolicy */
+#define __NR_mq_open		262
+#define __NR_mq_unlink		263
+#define __NR_mq_timedsend	264
+#define __NR_mq_timedreceive	265
+#define __NR_mq_notify		266
+#define __NR_mq_getsetattr	267
 
-#define __NR_syscalls		256
+#define __NR_syscalls		268
 
 #define __NR(n)	#n
 
Index: linux-2.6.5/include/asm-s390/unistd.h
===================================================================
--- linux-2.6.5.orig/include/asm-s390/unistd.h
+++ linux-2.6.5/include/asm-s390/unistd.h
@@ -233,7 +233,9 @@
 #define __NR_sched_setaffinity	239
 #define __NR_sched_getaffinity	240
 #define __NR_tgkill		241
-/* Number 242 is reserved for tux */
+/*
+ * Number 242 is reserved for tux
+ */
 #define __NR_io_setup		243
 #define __NR_io_destroy		244
 #define __NR_io_getevents	245
Index: linux-2.6.5/include/asm-sparc/unistd.h
===================================================================
--- linux-2.6.5.orig/include/asm-sparc/unistd.h
+++ linux-2.6.5/include/asm-sparc/unistd.h
@@ -289,10 +289,17 @@
 #define __NR_io_submit		270
 #define __NR_io_cancel		271
 #define __NR_io_getevents	272
-/* WARNING: You MAY NOT add syscall numbers larger than 272, since
+#define __NR_mq_open		273
+#define __NR_mq_unlink		(__NR_mq_open+1)
+#define __NR_mq_timedsend	(__NR_mq_open+2)
+#define __NR_mq_timedreceive	(__NR_mq_open+3)
+#define __NR_mq_notify		(__NR_mq_open+4)
+#define __NR_mq_getsetattr	(__NR_mq_open+5)
+
+/* WARNING: You MAY NOT add syscall numbers larger than 282, since
  *          all of the syscall tables in the Sparc kernel are
- *          sized to have 273 entries (starting at zero).  Therefore
- *          find a free slot in the 0-272 range.
+ *          sized to have 283 entries (starting at zero).  Therefore
+ *          find a free slot in the 0-282 range.
  */
 
 #define _syscall0(type,name) \
Index: linux-2.6.5/include/asm-sparc64/unistd.h
===================================================================
--- linux-2.6.5.orig/include/asm-sparc64/unistd.h
+++ linux-2.6.5/include/asm-sparc64/unistd.h
@@ -291,10 +291,16 @@
 #define __NR_io_submit		270
 #define __NR_io_cancel		271
 #define __NR_io_getevents	272
-/* WARNING: You MAY NOT add syscall numbers larger than 272, since
+#define __NR_mq_open		273
+#define __NR_mq_unlink		(__NR_mq_open+1)
+#define __NR_mq_timedsend	(__NR_mq_open+2)
+#define __NR_mq_timedreceive	(__NR_mq_open+3)
+#define __NR_mq_notify		(__NR_mq_open+4)
+#define __NR_mq_getsetattr	(__NR_mq_open+5)
+/* WARNING: You MAY NOT add syscall numbers larger than 282, since
  *          all of the syscall tables in the Sparc kernel are
- *          sized to have 273 entries (starting at zero).  Therefore
- *          find a free slot in the 0-272 range.
+ *          sized to have 283 entries (starting at zero).  Therefore
+ *          find a free slot in the 0-282 range.
  */
 
 #define _syscall0(type,name) \
Index: linux-2.6.5/include/linux/netlink.h
===================================================================
--- linux-2.6.5.orig/include/linux/netlink.h
+++ linux-2.6.5/include/linux/netlink.h
@@ -119,6 +119,13 @@ extern void netlink_set_err(struct sock 
 extern int netlink_register_notifier(struct notifier_block *nb);
 extern int netlink_unregister_notifier(struct notifier_block *nb);
 
+/* finegrained unicast helpers: */
+struct sock *netlink_getsockbypid(struct sock *ssk, u32 pid);
+struct sock *netlink_getsockbyfilp(struct file *filp);
+int netlink_attachskb(struct sock *sk, struct sk_buff *skb, int nonblock, long timeo);
+void netlink_detachskb(struct sock *sk, struct sk_buff *skb);
+int netlink_sendskb(struct sock *sk, struct sk_buff *skb, int protocol);
+
 /*
  *	skb should fit one page. This choice is good for headerless malloc.
  *
Index: linux-2.6.5/ipc/mqueue.c
===================================================================
--- linux-2.6.5.orig/ipc/mqueue.c
+++ linux-2.6.5/ipc/mqueue.c
@@ -153,7 +153,7 @@ static int mqueue_fill_super(struct supe
 	sb->s_magic = MQUEUE_MAGIC;
 	sb->s_op = &mqueue_super_ops;
 
-	inode = mqueue_get_inode(sb, S_IFDIR | S_IRWXUGO);
+	inode = mqueue_get_inode(sb, S_IFDIR | S_ISVTX | S_IRWXUGO);
 	if (!inode)
 		return -ENOMEM;
 
@@ -685,10 +685,6 @@ asmlinkage long sys_mq_unlink(const char
 		goto out_err;
 	}
 
-	if (permission(dentry->d_inode, MAY_WRITE, NULL)) {
-		err = -EACCES;
-		goto out_err;
-	}
 	inode = dentry->d_inode;
 	if (inode)
 		atomic_inc(&inode->i_count);
Index: linux-2.6.5/net/netlink/af_netlink.c
===================================================================
--- linux-2.6.5.orig/net/netlink/af_netlink.c
+++ linux-2.6.5/net/netlink/af_netlink.c
@@ -415,38 +415,65 @@ static void netlink_overrun(struct sock 
 	}
 }
 
-int netlink_unicast(struct sock *ssk, struct sk_buff *skb, u32 pid, int nonblock)
+struct sock *netlink_getsockbypid(struct sock *ssk, u32 pid)
 {
-	struct sock *sk;
-	struct netlink_opt *nlk;
-	int len = skb->len;
 	int protocol = ssk->sk_protocol;
-	long timeo;
-        DECLARE_WAITQUEUE(wait, current);
-
-	timeo = sock_sndtimeo(ssk, nonblock);
+	struct sock *sock;
+	struct netlink_opt *nlk;
 
-retry:
-	sk = netlink_lookup(protocol, pid);
-	if (sk == NULL)
-		goto no_dst;
-	nlk = nlk_sk(sk);
+	sock = netlink_lookup(protocol, pid);
+	if (!sock)
+		return ERR_PTR(-ECONNREFUSED);
 
 	/* Don't bother queuing skb if kernel socket has no input function */
-        if (nlk->pid == 0 && !nlk->data_ready)
-        	goto no_dst;
+	nlk = nlk_sk(sock);
+	if (nlk->pid == 0 && !nlk->data_ready) {
+		sock_put(sock);
+		return ERR_PTR(-ECONNREFUSED);
+	}
+	return sock;
+}
+
+struct sock *netlink_getsockbyfilp(struct file *filp)
+{
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct socket *socket;
+	struct sock *sock;
+
+	if (!inode->i_sock || !(socket = SOCKET_I(inode)))
+		return ERR_PTR(-ENOTSOCK);
+
+	sock = socket->sk;
+	if (sock->sk_family != AF_NETLINK)
+		return ERR_PTR(-EINVAL);
+
+	sock_hold(sock);
+	return sock;
+}
+
+/*
+ * Attach a skb to a netlink socket.
+ * The caller must hold a reference to the destination socket. On error, the
+ * reference is dropped. The skb is not send to the destination, just all
+ * all error checks are performed and memory in the queue is reserved.
+ * Return values:
+ * < 0: error. skb freed, reference to sock dropped.
+ * 0: continue
+ * 1: repeat lookup - reference dropped while waiting for socket memory.
+ */
+int netlink_attachskb(struct sock *sk, struct sk_buff *skb, int nonblock, long timeo)
+{
+	struct netlink_opt *nlk;
+
+	nlk = nlk_sk(sk);
 
 #ifdef NL_EMULATE_DEV
-	if (nlk->handler) {
-		skb_orphan(skb);
-		len = nlk->handler(protocol, skb);
-		sock_put(sk);
-		return len;
-	}
+	if (nlk->handler)
+		return 0;
 #endif
-
 	if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf ||
 	    test_bit(0, &nlk->state)) {
+		DECLARE_WAITQUEUE(wait, current);
 		if (!timeo) {
 			if (!nlk->pid)
 				netlink_overrun(sk);
@@ -471,19 +498,60 @@ retry:
 			kfree_skb(skb);
 			return sock_intr_errno(timeo);
 		}
-		goto retry;
+		return 1;
 	}
-
 	skb_orphan(skb);
 	skb_set_owner_r(skb, sk);
+	return 0;
+}
+
+int netlink_sendskb(struct sock *sk, struct sk_buff *skb, int protocol)
+{
+	struct netlink_opt *nlk;
+	int len = skb->len;
+
+	nlk = nlk_sk(sk);
+#ifdef NL_EMULATE_DEV
+	if (nlk->handler) {
+		skb_orphan(skb);
+		len = nlk->handler(protocol, skb);
+		sock_put(sk);
+		return len;
+	}
+#endif
+
 	skb_queue_tail(&sk->sk_receive_queue, skb);
 	sk->sk_data_ready(sk, len);
 	sock_put(sk);
 	return len;
+}
 
-no_dst:
+void netlink_detachskb(struct sock *sk, struct sk_buff *skb)
+{
 	kfree_skb(skb);
-	return -ECONNREFUSED;
+	sock_put(sk);
+}
+
+int netlink_unicast(struct sock *ssk, struct sk_buff *skb, u32 pid, int nonblock)
+{
+	struct sock *sk;
+	int err;
+	long timeo;
+
+	timeo = sock_sndtimeo(ssk, nonblock);
+retry:
+	sk = netlink_getsockbypid(ssk, pid);
+	if (IS_ERR(sk)) {
+		kfree_skb(skb);
+		return PTR_ERR(sk);
+	}
+	err = netlink_attachskb(sk, skb, nonblock, timeo);
+	if (err == 1)
+		goto retry;
+	if (err)
+		return err;
+
+	return netlink_sendskb(sk, skb, ssk->sk_protocol);
 }
 
 static __inline__ int netlink_broadcast_deliver(struct sock *sk, struct sk_buff *skb)
