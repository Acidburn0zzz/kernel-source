From: Jens Axboe <axboe@suse.de>
Subject: Fix sdev <-> queue reference counting problems
Patch-mainline: 
References: 

sdev embeds the queue lock for the block layer request queue, but the sdev
can disappear while the queue is still active. Move the lock to the
request_queue instead.

Acked-by: 
Signed-off-by: 

Index: linux-2.6.11/drivers/scsi/scsi_lib.c
===================================================================
--- linux-2.6.11.orig/drivers/scsi/scsi_lib.c
+++ linux-2.6.11/drivers/scsi/scsi_lib.c
@@ -349,9 +349,9 @@ void scsi_device_unbusy(struct scsi_devi
 		     shost->host_failed))
 		scsi_eh_wakeup(shost);
 	spin_unlock(shost->host_lock);
-	spin_lock(&sdev->sdev_lock);
+	spin_lock(sdev->request_queue->queue_lock);
 	sdev->device_busy--;
-	spin_unlock_irqrestore(&sdev->sdev_lock, flags);
+	spin_unlock_irqrestore(sdev->request_queue->queue_lock, flags);
 }
 
 /*
@@ -1411,7 +1411,7 @@ struct request_queue *scsi_alloc_queue(s
 	struct Scsi_Host *shost = sdev->host;
 	struct request_queue *q;
 
-	q = blk_init_queue(scsi_request_fn, &sdev->sdev_lock);
+	q = blk_init_queue(scsi_request_fn, NULL);
 	if (!q)
 		return NULL;
 
Index: linux-2.6.11/include/linux/blkdev.h
===================================================================
--- linux-2.6.11.orig/include/linux/blkdev.h
+++ linux-2.6.11/include/linux/blkdev.h
@@ -364,8 +364,11 @@ struct request_queue
 	unsigned long		queue_flags;
 
 	/*
-	 * protects queue structures from reentrancy
+	 * protects queue structures from reentrancy. ->__queue_lock should
+	 * _never_ be used directly, it is queue private. always use
+	 * ->queue_lock.
 	 */
+	spinlock_t		__queue_lock;
 	spinlock_t		*queue_lock;
 
 	/*
Index: linux-2.6.11/drivers/scsi/scsi_scan.c
===================================================================
--- linux-2.6.11.orig/drivers/scsi/scsi_scan.c
+++ linux-2.6.11/drivers/scsi/scsi_scan.c
@@ -256,7 +256,6 @@ static struct scsi_device *scsi_alloc_sd
 	 */
 	sdev->borken = 1;
 
-	spin_lock_init(&sdev->sdev_lock);
 	sdev->request_queue = scsi_alloc_queue(sdev);
 	if (!sdev->request_queue)
 		goto out_free_dev;
Index: linux-2.6.11/drivers/block/ll_rw_blk.c
===================================================================
--- linux-2.6.11.orig/drivers/block/ll_rw_blk.c
+++ linux-2.6.11/drivers/block/ll_rw_blk.c
@@ -1712,6 +1712,15 @@ request_queue_t *blk_init_queue(request_
 	if (blk_init_free_list(q))
 		goto out_init;
 
+	/*
+	 * if caller didn't supply a lock, they get per-queue locking with
+	 * our embedded lock
+	 */
+	if (!lock) {
+		spin_lock_init(&q->__queue_lock);
+		lock = &q->__queue_lock;
+	}
+
 	q->request_fn		= rfn;
 	q->back_merge_fn       	= ll_back_merge_fn;
 	q->front_merge_fn      	= ll_front_merge_fn;
