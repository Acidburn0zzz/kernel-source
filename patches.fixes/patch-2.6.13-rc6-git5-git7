Subject: patch-2.6.13-rc6-git7
From: torvalds@osdl.org


Signed-off-by: Olaf Hering <olh@suse.de>

diff -purN linux-2.6.13-rc6-git5/Makefile linux-2.6.13-rc6-git7/Makefile
--- linux-2.6.13-rc6-git5/Makefile	2005-08-13 20:03:53.000000000 +0200
+++ linux-2.6.13-rc6-git7/Makefile	2005-08-15 13:09:31.289263651 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 13
-EXTRAVERSION = -rc6-git5
+EXTRAVERSION = -rc6-git7
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.13-rc6-git5/drivers/acpi/motherboard.c linux-2.6.13-rc6-git7/drivers/acpi/motherboard.c
--- linux-2.6.13-rc6-git5/drivers/acpi/motherboard.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/drivers/acpi/motherboard.c	2005-08-15 13:09:31.338256063 +0200
@@ -43,7 +43,7 @@ ACPI_MODULE_NAME		("acpi_motherboard")
  */
 #define IS_RESERVED_ADDR(base, len) \
 	(((len) > 0) && ((base) > 0) && ((base) + (len) < IO_SPACE_LIMIT) \
-	&& ((base) + (len) > 0x1000))
+	&& ((base) + (len) > PCIBIOS_MIN_IO))
 
 /*
  * Clearing the flag (IORESOURCE_BUSY) allows drivers to use
diff -purN linux-2.6.13-rc6-git5/drivers/char/mem.c linux-2.6.13-rc6-git7/drivers/char/mem.c
--- linux-2.6.13-rc6-git5/drivers/char/mem.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/drivers/char/mem.c	2005-08-15 13:09:31.344255134 +0200
@@ -261,7 +261,11 @@ static int mmap_mem(struct file * file, 
 
 static int mmap_kmem(struct file * file, struct vm_area_struct * vma)
 {
-        unsigned long long val;
+	unsigned long pfn;
+
+	/* Turn a kernel-virtual address into a physical page frame */
+	pfn = __pa((u64)vma->vm_pgoff << PAGE_SHIFT) >> PAGE_SHIFT;
+
 	/*
 	 * RED-PEN: on some architectures there is more mapped memory
 	 * than available in mem_map which pfn_valid checks
@@ -269,10 +273,10 @@ static int mmap_kmem(struct file * file,
 	 *
 	 * RED-PEN: vmalloc is not supported right now.
 	 */
-	if (!pfn_valid(vma->vm_pgoff))
+	if (!pfn_valid(pfn))
 		return -EIO;
-	val = (u64)vma->vm_pgoff << PAGE_SHIFT;
-	vma->vm_pgoff = __pa(val) >> PAGE_SHIFT;
+
+	vma->vm_pgoff = pfn;
 	return mmap_mem(file, vma);
 }
 
diff -purN linux-2.6.13-rc6-git5/drivers/scsi/dc395x.c linux-2.6.13-rc6-git7/drivers/scsi/dc395x.c
--- linux-2.6.13-rc6-git5/drivers/scsi/dc395x.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/drivers/scsi/dc395x.c	2005-08-15 13:09:31.452238409 +0200
@@ -183,7 +183,7 @@
  * cross a page boundy.
  */
 #define SEGMENTX_LEN	(sizeof(struct SGentry)*DC395x_MAX_SG_LISTENTRY)
-#define VIRTX_LEN	(sizeof(void *) * DC395x_MAX_SG_LISTENTRY)
+
 
 struct SGentry {
 	u32 address;		/* bus! address */
@@ -235,7 +235,6 @@ struct ScsiReqBlk {
 	u8 sg_count;			/* No of HW sg entries for this request */
 	u8 sg_index;			/* Index of HW sg entry for this request */
 	u32 total_xfer_length;		/* Total number of bytes remaining to be transfered */
-	void **virt_map;
 	unsigned char *virt_addr;	/* Virtual address of current transfer position */
 
 	/*
@@ -1022,14 +1021,14 @@ static void build_srb(struct scsi_cmnd *
 			reqlen, cmd->request_buffer, cmd->use_sg,
 			srb->sg_count);
 
+		srb->virt_addr = page_address(sl->page);
 		for (i = 0; i < srb->sg_count; i++) {
-			u32 seglen = (u32)sg_dma_len(sl + i);
-			sgp[i].address = (u32)sg_dma_address(sl + i);
+			u32 busaddr = (u32)sg_dma_address(&sl[i]);
+			u32 seglen = (u32)sl[i].length;
+			sgp[i].address = busaddr;
 			sgp[i].length = seglen;
 			srb->total_xfer_length += seglen;
-			srb->virt_map[i] = kmap(sl[i].page);
 		}
-		srb->virt_addr = srb->virt_map[0];
 		sgp += srb->sg_count - 1;
 
 		/*
@@ -1976,7 +1975,6 @@ static void sg_update_list(struct ScsiRe
 	int segment = cmd->use_sg;
 	u32 xferred = srb->total_xfer_length - left; /* bytes transfered */
 	struct SGentry *psge = srb->segment_x + srb->sg_index;
-	void **virt = srb->virt_map;
 
 	dprintkdbg(DBG_0,
 		"sg_update_list: Transfered %i of %i bytes, %i remain\n",
@@ -2016,16 +2014,16 @@ static void sg_update_list(struct ScsiRe
 
 	/* We have to walk the scatterlist to find it */
 	sg = (struct scatterlist *)cmd->request_buffer;
-	idx = 0;
 	while (segment--) {
 		unsigned long mask =
 		    ~((unsigned long)sg->length - 1) & PAGE_MASK;
 		if ((sg_dma_address(sg) & mask) == (psge->address & mask)) {
-			srb->virt_addr = virt[idx] + (psge->address & ~PAGE_MASK);
+			srb->virt_addr = (page_address(sg->page)
+					   + psge->address -
+					   (psge->address & PAGE_MASK));
 			return;
 		}
 		++sg;
-		++idx;
 	}
 
 	dprintkl(KERN_ERR, "sg_update_list: sg_to_virt failed\n");
@@ -2151,7 +2149,7 @@ static void data_out_phase0(struct Adapt
 				DC395x_read32(acb, TRM_S1040_DMA_CXCNT));
 		}
 		/*
-		 * calculate all the residue data that not yet transfered
+		 * calculate all the residue data that not yet tranfered
 		 * SCSI transfer counter + left in SCSI FIFO data
 		 *
 		 * .....TRM_S1040_SCSI_COUNTER (24bits)
@@ -3269,7 +3267,6 @@ static void pci_unmap_srb(struct Adapter
 	struct scsi_cmnd *cmd = srb->cmd;
 	enum dma_data_direction dir = cmd->sc_data_direction;
 	if (cmd->use_sg && dir != PCI_DMA_NONE) {
-		int i;
 		/* unmap DC395x SG list */
 		dprintkdbg(DBG_SG, "pci_unmap_srb: list=%08x(%05x)\n",
 			srb->sg_bus_addr, SEGMENTX_LEN);
@@ -3279,8 +3276,6 @@ static void pci_unmap_srb(struct Adapter
 		dprintkdbg(DBG_SG, "pci_unmap_srb: segs=%i buffer=%p\n",
 			cmd->use_sg, cmd->request_buffer);
 		/* unmap the sg segments */
-		for (i = 0; i < srb->sg_count; i++)
-			kunmap(virt_to_page(srb->virt_map[i]));
 		pci_unmap_sg(acb->dev,
 			     (struct scatterlist *)cmd->request_buffer,
 			     cmd->use_sg, dir);
@@ -3327,7 +3322,7 @@ static void srb_done(struct AdapterCtlBl
 
 	if (cmd->use_sg) {
 		struct scatterlist* sg = (struct scatterlist *)cmd->request_buffer;
-		ptr = (struct ScsiInqData *)(srb->virt_map[0] + sg->offset);
+		ptr = (struct ScsiInqData *)(page_address(sg->page) + sg->offset);
 	} else {
 		ptr = (struct ScsiInqData *)(cmd->request_buffer);
 	}
@@ -4262,9 +4257,8 @@ static void adapter_sg_tables_free(struc
 	const unsigned srbs_per_page = PAGE_SIZE/SEGMENTX_LEN;
 
 	for (i = 0; i < DC395x_MAX_SRB_CNT; i += srbs_per_page)
-		kfree(acb->srb_array[i].segment_x);
-
-	vfree(acb->srb_array[0].virt_map);
+		if (acb->srb_array[i].segment_x)
+			kfree(acb->srb_array[i].segment_x);
 }
 
 
@@ -4280,12 +4274,9 @@ static int __devinit adapter_sg_tables_a
 	int srb_idx = 0;
 	unsigned i = 0;
 	struct SGentry *ptr;
-	void **virt_array;
 
-	for (i = 0; i < DC395x_MAX_SRB_CNT; i++) {
+	for (i = 0; i < DC395x_MAX_SRB_CNT; i++)
 		acb->srb_array[i].segment_x = NULL;
-		acb->srb_array[i].virt_map = NULL;
-	}
 
 	dprintkdbg(DBG_1, "Allocate %i pages for SG tables\n", pages);
 	while (pages--) {
@@ -4306,19 +4297,6 @@ static int __devinit adapter_sg_tables_a
 		    ptr + (i * DC395x_MAX_SG_LISTENTRY);
 	else
 		dprintkl(KERN_DEBUG, "No space for tmsrb SG table reserved?!\n");
-
-	virt_array = vmalloc((DC395x_MAX_SRB_CNT + 1) * DC395x_MAX_SG_LISTENTRY * sizeof(void*));
-
-	if (!virt_array) {
-		adapter_sg_tables_free(acb);
-		return 1;
-	}
-
-	for (i = 0; i < DC395x_MAX_SRB_CNT + 1; i++) {
-		acb->srb_array[i].virt_map = virt_array;
-		virt_array += DC395x_MAX_SG_LISTENTRY;
-	}
-
 	return 0;
 }
 
diff -purN linux-2.6.13-rc6-git5/fs/cifs/CHANGES linux-2.6.13-rc6-git7/fs/cifs/CHANGES
--- linux-2.6.13-rc6-git5/fs/cifs/CHANGES	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/fs/cifs/CHANGES	2005-08-15 13:09:31.499231130 +0200
@@ -1,3 +1,9 @@
+Version 1.35
+------------
+Add writepage performance improvements.  Fix path name conversions
+for long filenames on mounts which were done with "mapchars" mount option
+specified.
+
 Version 1.34
 ------------
 Fix error mapping of the TOO_MANY_LINKS (hardlinks) case.
diff -purN linux-2.6.13-rc6-git5/fs/cifs/cifssmb.c linux-2.6.13-rc6-git7/fs/cifs/cifssmb.c
--- linux-2.6.13-rc6-git5/fs/cifs/cifssmb.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/fs/cifs/cifssmb.c	2005-08-15 13:09:31.510229426 +0200
@@ -2602,6 +2602,9 @@ int CIFSFindNext(const int xid, struct c
 	if(name_len < PATH_MAX) {
 		memcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);
 		byte_count += name_len;
+		/* 14 byte parm len above enough for 2 byte null terminator */
+		pSMB->ResumeFileName[name_len] = 0;
+		pSMB->ResumeFileName[name_len+1] = 0;
 	} else {
 		rc = -EINVAL;
 		goto FNext2_err_exit;
diff -purN linux-2.6.13-rc6-git5/fs/cifs/misc.c linux-2.6.13-rc6-git7/fs/cifs/misc.c
--- linux-2.6.13-rc6-git5/fs/cifs/misc.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/fs/cifs/misc.c	2005-08-15 13:09:31.513228962 +0200
@@ -611,6 +611,7 @@ cifsConvertToUCS(__le16 * target, const 
 		src_char = source[i];
 		switch (src_char) {
 			case 0:
+				target[j] = 0;
 				goto ctoUCS_out;
 			case ':':
 				target[j] = cpu_to_le16(UNI_COLON);
diff -purN linux-2.6.13-rc6-git5/fs/reiserfs/namei.c linux-2.6.13-rc6-git7/fs/reiserfs/namei.c
--- linux-2.6.13-rc6-git5/fs/reiserfs/namei.c	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/fs/reiserfs/namei.c	2005-08-15 13:09:31.528226639 +0200
@@ -593,6 +593,9 @@ static int new_inode_init(struct inode *
 	 */
 	inode->i_uid = current->fsuid;
 	inode->i_mode = mode;
+	/* Make inode invalid - just in case we are going to drop it before
+	 * the initialization happens */
+	INODE_PKEY(inode)->k_objectid = 0;
 
 	if (dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;
diff -purN linux-2.6.13-rc6-git5/include/asm-i386/pci.h linux-2.6.13-rc6-git7/include/asm-i386/pci.h
--- linux-2.6.13-rc6-git5/include/asm-i386/pci.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/include/asm-i386/pci.h	2005-08-15 13:09:31.532226019 +0200
@@ -18,9 +18,11 @@ extern unsigned int pcibios_assign_all_b
 #define pcibios_scan_all_fns(a, b)	0
 
 extern unsigned long pci_mem_start;
-#define PCIBIOS_MIN_IO		0x4000
+#define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		(pci_mem_start)
 
+#define PCIBIOS_MIN_CARDBUS_IO	0x4000
+
 void pcibios_config_init(void);
 struct pci_bus * pcibios_scan_root(int bus);
 
diff -purN linux-2.6.13-rc6-git5/include/asm-sh/unistd.h linux-2.6.13-rc6-git7/include/asm-sh/unistd.h
--- linux-2.6.13-rc6-git5/include/asm-sh/unistd.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/include/asm-sh/unistd.h	2005-08-15 13:09:31.538225090 +0200
@@ -406,7 +406,7 @@ register long __sc6 __asm__ ("r6") = (lo
 register long __sc7 __asm__ ("r7") = (long) arg4; \
 register long __sc0 __asm__ ("r0") = (long) arg5; \
 register long __sc1 __asm__ ("r1") = (long) arg6; \
-__asm__ __volatile__ ("trapa	#0x15" \
+__asm__ __volatile__ ("trapa	#0x16" \
 	: "=z" (__sc0) \
 	: "0" (__sc0), "r" (__sc4), "r" (__sc5), "r" (__sc6), "r" (__sc7),  \
 	  "r" (__sc3), "r" (__sc1) \
diff -purN linux-2.6.13-rc6-git5/include/asm-x86_64/pci.h linux-2.6.13-rc6-git7/include/asm-x86_64/pci.h
--- linux-2.6.13-rc6-git5/include/asm-x86_64/pci.h	2005-08-07 20:18:56.000000000 +0200
+++ linux-2.6.13-rc6-git7/include/asm-x86_64/pci.h	2005-08-15 13:09:31.541224626 +0200
@@ -22,9 +22,11 @@ extern unsigned int pcibios_assign_all_b
 extern int no_iommu, force_iommu;
 
 extern unsigned long pci_mem_start;
-#define PCIBIOS_MIN_IO		0x4000
+#define PCIBIOS_MIN_IO		0x1000
 #define PCIBIOS_MIN_MEM		(pci_mem_start)
 
+#define PCIBIOS_MIN_CARDBUS_IO	0x4000
+
 void pcibios_config_init(void);
 struct pci_bus * pcibios_scan_root(int bus);
 extern int (*pci_config_read)(int seg, int bus, int dev, int fn, int reg, int len, u32 *value);
