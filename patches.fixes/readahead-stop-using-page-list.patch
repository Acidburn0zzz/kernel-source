

The address_space.readapges() function currently takes a list of pages,
strung together via page->list.  Switch it to using page->lru.

This changes the API into filesystems.


Index: linux.t/fs/cifs/file.c
===================================================================
--- linux.t.orig/fs/cifs/file.c	2004-03-15 15:03:27.696235875 -0500
+++ linux.t/fs/cifs/file.c	2004-03-15 15:20:41.795619956 -0500
@@ -898,9 +898,9 @@ static void cifs_copy_cache_pages(struct
 		if(list_empty(pages))
 			break;
 
-		page = list_entry(pages->prev, struct page, list);
+		page = list_entry(pages->prev, struct page, lru);
 
-		list_del(&page->list);
+		list_del(&page->lru);
 
 		if (add_to_page_cache(page, mapping, page->index, GFP_KERNEL)) {
 			page_cache_release(page);
@@ -962,7 +962,7 @@ cifs_readpages(struct file *file, struct
 	for(i = 0;i<num_pages;) {
 		if(list_empty(page_list))
 			break;
-		page = list_entry(page_list->prev, struct page, list);
+		page = list_entry(page_list->prev, struct page, lru);
 		offset = (loff_t)page->index << PAGE_CACHE_SHIFT;
 
 		/* for reads over a certain size could initiate async read ahead */
@@ -984,8 +984,9 @@ cifs_readpages(struct file *file, struct
 			/* clean up remaing pages off list */
             
 			while (!list_empty(page_list) && (i < num_pages)) {
-				page = list_entry(page_list->prev, struct page, list);
-				list_del(&page->list);
+				page = list_entry(page_list->prev,
+						struct page, lru);
+				list_del(&page->lru);
 			}
 			break;
 		} else if (bytes_read > 0) {
@@ -1002,8 +1003,9 @@ cifs_readpages(struct file *file, struct
 			cFYI(1,("No bytes read cleaning remaining pages off readahead list"));
 			/* BB turn off caching and do new lookup on file size at server? */
 			while (!list_empty(page_list) && (i < num_pages)) {
-				page = list_entry(page_list->prev, struct page, list);
-				list_del(&page->list);
+				page = list_entry(page_list->prev,
+						struct page, lru);
+				list_del(&page->lru);
 			}
 
 			break;
Index: linux.t/fs/mpage.c
===================================================================
--- linux.t.orig/fs/mpage.c	2004-03-15 15:07:50.469873329 -0500
+++ linux.t/fs/mpage.c	2004-03-15 15:20:41.792620316 -0500
@@ -329,10 +329,10 @@ mpage_readpages(struct address_space *ma
 
 	pagevec_init(&lru_pvec, 0);
 	for (page_idx = 0; page_idx < nr_pages; page_idx++) {
-		struct page *page = list_entry(pages->prev, struct page, list);
+		struct page *page = list_entry(pages->prev, struct page, lru);
 
 		prefetchw(&page->flags);
-		list_del(&page->list);
+		list_del(&page->lru);
 		if (!add_to_page_cache(page, mapping,
 					page->index, GFP_KERNEL)) {
 			bio = do_mpage_readpage(bio, page,
Index: linux.t/mm/readahead.c
===================================================================
--- linux.t.orig/mm/readahead.c	2004-03-15 15:03:27.688236834 -0500
+++ linux.t/mm/readahead.c	2004-03-15 15:20:41.791620435 -0500
@@ -54,7 +54,7 @@ static inline unsigned long get_min_read
 	return (VM_MIN_READAHEAD * 1024) / PAGE_CACHE_SIZE;
 }
 
-#define list_to_page(head) (list_entry((head)->prev, struct page, list))
+#define list_to_page(head) (list_entry((head)->prev, struct page, lru))
 
 /**
  * read_cache_pages - populate an address space with some pages, and
@@ -78,7 +78,7 @@ int read_cache_pages(struct address_spac
 
 	while (!list_empty(pages)) {
 		page = list_to_page(pages);
-		list_del(&page->list);
+		list_del(&page->lru);
 		if (add_to_page_cache(page, mapping, page->index, GFP_KERNEL)) {
 			page_cache_release(page);
 			continue;
@@ -91,7 +91,7 @@ int read_cache_pages(struct address_spac
 				struct page *victim;
 
 				victim = list_to_page(pages);
-				list_del(&victim->list);
+				list_del(&victim->lru);
 				page_cache_release(victim);
 			}
 			break;
@@ -118,7 +118,7 @@ static int read_pages(struct address_spa
 	pagevec_init(&lru_pvec, 0);
 	for (page_idx = 0; page_idx < nr_pages; page_idx++) {
 		struct page *page = list_to_page(pages);
-		list_del(&page->list);
+		list_del(&page->lru);
 		if (!add_to_page_cache(page, mapping,
 					page->index, GFP_KERNEL)) {
 			mapping->a_ops->readpage(filp, page);
@@ -253,7 +253,7 @@ __do_page_cache_readahead(struct address
 		if (!page)
 			break;
 		page->index = page_offset;
-		list_add(&page->list, &page_pool);
+		list_add(&page->lru, &page_pool);
 		ret++;
 	}
 	spin_unlock_irq(&mapping->tree_lock);
