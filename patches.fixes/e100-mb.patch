Date: Wed, 28 Apr 2004 05:14:25 +1000
From: Anton Blanchard <anton@samba.org>
To: olh@suse.de
Subject: e100/e1000 mb patch


Hi,

We need mb to order between cacheable and non cacheable accesses.
This is in reference to LTC 7055.

Longer term I will try and push for the addition of io_barrier into
Linux but this will fix things in the mean time.

Anton

e100_rx_indicate() needs also a barrier (#40376 - LTC8434)
e100_exec_cmd() needs also a barrier (#40387 - LTC8455)

--- linux-2.6.5/drivers/net/e100.c~	2004-04-28 01:44:16.768827235 +1000
+++ linux-2.6.5/drivers/net/e100.c	2004-04-28 01:44:50.709368795 +1000
@@ -772,6 +772,8 @@ static inline int e100_exec_cmd(struct n
 
 	spin_lock_irqsave(&nic->cmd_lock, flags);
 
+	mb();
+
 	/* Previous command is accepted when SCB clears */
 	for(i = 0; i < E100_WAIT_SCB_TIMEOUT; i++) {
 		if(likely(!readb(&nic->csr->scb.cmd_lo)))
@@ -822,7 +822,7 @@
 	/* Order is important otherwise we'll be in a race with h/w:
 	 * set S-bit in current first, then clear S-bit in previous. */
 	cb->command |= cpu_to_le16(cb_s);
-	wmb();
+	mb();
 	cb->prev->command &= cpu_to_le16(~cb_s);
 
 	while(nic->cb_to_send != nic->cb_to_use) {
@@ -1405,7 +1405,7 @@
 		struct rfd *prev_rfd = (struct rfd *)rx->prev->skb->data;
 		put_unaligned(cpu_to_le32(rx->dma_addr),
 			(u32 *)&prev_rfd->link);
-		wmb();
+		mb();
 		prev_rfd->command &= ~cpu_to_le16(cb_el);
 		pci_dma_sync_single_for_device(nic->pdev, rx->prev->dma_addr,
 					       sizeof(struct rfd), PCI_DMA_TODEVICE);
@@ -1437,6 +1437,8 @@ static inline int e100_rx_indicate(struc
 	if(unlikely(!(rfd_status & cb_complete)))
        		return -EAGAIN;
 
+	rmb();
+
 	/* Get actual data size */
 	actual_size = le16_to_cpu(rfd->actual_size) & 0x3FFF;
 	if(unlikely(actual_size > RFD_BUF_LEN - sizeof(struct rfd)))
--- ./drivers/net/e100.c~	2004-05-15 17:59:16.000000000 +0200
+++ ./drivers/net/e100.c	2004-05-15 20:59:34.000000000 +0200
