Date: Wed, 28 Apr 2004 05:14:25 +1000
From: Anton Blanchard <anton@samba.org>
To: olh@suse.de
Subject: e100/e1000 mb patch


Hi,

We need mb to order between cacheable and non cacheable accesses.
This is in reference to LTC 7055.

Longer term I will try and push for the addition of io_barrier into
Linux but this will fix things in the mean time.

Anton

e100_rx_indicate() needs also a barrier (#40376 - LTC8434)
e100_exec_cmd() needs also a barrier (#40387 - LTC8455)

Index: linux-2.6.7/drivers/net/e100.c
===================================================================
--- linux-2.6.7.orig/drivers/net/e100.c	2004-06-16 07:20:26.000000000 +0200
+++ linux-2.6.7/drivers/net/e100.c	2004-08-05 13:46:40.187702572 +0200
@@ -773,6 +773,8 @@
 
 	spin_lock_irqsave(&nic->cmd_lock, flags);
 
+	mb();
+
 	/* Previous command is accepted when SCB clears */
 	for(i = 0; i < E100_WAIT_SCB_TIMEOUT; i++) {
 		if(likely(!readb(&nic->csr->scb.cmd_lo)))
@@ -823,7 +825,7 @@
 	/* Order is important otherwise we'll be in a race with h/w:
 	 * set S-bit in current first, then clear S-bit in previous. */
 	cb->command |= cpu_to_le16(cb_s);
-	wmb();
+	mb();
 	cb->prev->command &= cpu_to_le16(~cb_s);
 
 	while(nic->cb_to_send != nic->cb_to_use) {
@@ -1406,7 +1408,7 @@
 		struct rfd *prev_rfd = (struct rfd *)rx->prev->skb->data;
 		put_unaligned(cpu_to_le32(rx->dma_addr),
 			(u32 *)&prev_rfd->link);
-		wmb();
+		mb();
 		prev_rfd->command &= ~cpu_to_le16(cb_el);
 		pci_dma_sync_single_for_device(nic->pdev, rx->prev->dma_addr,
 			sizeof(struct rfd), PCI_DMA_TODEVICE);
@@ -1436,6 +1438,8 @@
 	if(unlikely(!(rfd_status & cb_complete)))
        		return -EAGAIN;
 
+	rmb();
+
 	/* Get actual data size */
 	actual_size = le16_to_cpu(rfd->actual_size) & 0x3FFF;
 	if(unlikely(actual_size > RFD_BUF_LEN - sizeof(struct rfd)))
