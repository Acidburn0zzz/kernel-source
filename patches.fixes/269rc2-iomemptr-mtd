Index: linux-2.6.8/drivers/mtd/maps/dilnetpc.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/dilnetpc.c
+++ linux-2.6.8/drivers/mtd/maps/dilnetpc.c
@@ -402,9 +402,9 @@ static int __init init_dnpc(void)
 
 	printk(KERN_NOTICE "DIL/Net %s flash: 0x%lx at 0x%lx\n", 
 		is_dnp ? "DNPC" : "ADNP", dnpc_map.size, dnpc_map.phys);
 
-	dnpc_map.virt = (unsigned long)ioremap_nocache(dnpc_map.phys, dnpc_map.size);
+	dnpc_map.virt = ioremap_nocache(dnpc_map.phys, dnpc_map.size);
 
 	dnpc_map_flash(dnpc_map.phys, dnpc_map.size);
 
 	if (!dnpc_map.virt) {
@@ -412,9 +412,9 @@ static int __init init_dnpc(void)
 		return -EIO;
 	}
 	simple_map_init(&dnpc_map);
 
-	printk("FLASH virtual address: 0x%lx\n", dnpc_map.virt);
+	printk("FLASH virtual address: 0x%p\n", dnpc_map.virt);
 
 	mymtd = do_map_probe("jedec_probe", &dnpc_map);
 
 	if (!mymtd)
Index: linux-2.6.8/include/linux/mtd/doc2000.h
===================================================================
--- linux-2.6.8.orig/include/linux/mtd/doc2000.h
+++ linux-2.6.8/include/linux/mtd/doc2000.h
@@ -80,18 +80,18 @@
  * On PPC, it's mmap'd and 16-bit wide.
  * Others use readb/writeb 
  */
 #if defined(__arm__)
-#define ReadDOC_(adr, reg)      ((unsigned char)(*(volatile __u32 *)(((unsigned long)adr)+((reg)<<2))))
-#define WriteDOC_(d, adr, reg)  do{ *(volatile __u32 *)(((unsigned long)adr)+((reg)<<2)) = (__u32)d; wmb();} while(0)
+#define ReadDOC_(adr, reg)      ((unsigned char)(*(volatile __u32 *)(((void __iomem *)adr)+((reg)<<2))))
+#define WriteDOC_(d, adr, reg)  do{ *(volatile __u32 *)(((void __iomem *)adr)+((reg)<<2)) = (__u32)d; wmb();} while(0)
 #define DOC_IOREMAP_LEN 0x8000
 #elif defined(__ppc__)
-#define ReadDOC_(adr, reg)      ((unsigned char)(*(volatile __u16 *)(((unsigned long)adr)+((reg)<<1))))
-#define WriteDOC_(d, adr, reg)  do{ *(volatile __u16 *)(((unsigned long)adr)+((reg)<<1)) = (__u16)d; wmb();} while(0)
+#define ReadDOC_(adr, reg)      ((unsigned char)(*(volatile __u16 *)(((void __iomem *)adr)+((reg)<<1))))
+#define WriteDOC_(d, adr, reg)  do{ *(volatile __u16 *)(((void __iomem *)adr)+((reg)<<1)) = (__u16)d; wmb();} while(0)
 #define DOC_IOREMAP_LEN 0x4000
 #else
-#define ReadDOC_(adr, reg)      readb(((unsigned long)adr) + (reg))
-#define WriteDOC_(d, adr, reg)  writeb(d, ((unsigned long)adr) + (reg))
+#define ReadDOC_(adr, reg)      readb(((void __iomem *)adr) + (reg))
+#define WriteDOC_(d, adr, reg)  writeb(d, ((void __iomem *)adr) + (reg))
 #define DOC_IOREMAP_LEN 0x2000
 
 #endif
 
Index: linux-2.6.8/drivers/mtd/maps/elan-104nc.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/elan-104nc.c
+++ linux-2.6.8/drivers/mtd/maps/elan-104nc.c
@@ -52,9 +52,9 @@ always fail.  So we don't do it.  I just
 #define PAGE_IO 0x22
 #define PAGE_IO_SIZE 2
 
 static volatile int page_in_window = -1; // Current page in window.
-static unsigned long iomapadr;
+static void __iomem * iomapadr;
 static spinlock_t elan_104nc_spin = SPIN_LOCK_UNLOCKED;
 
 /* partition_info gives details on the logical partitions that the split the 
  * single flash device into. If the size if zero we use up to the end of the
@@ -181,17 +181,17 @@ static void cleanup_elan_104nc(void)
 		del_mtd_partitions( all_mtd );
 		map_destroy( all_mtd );
 	}
 
-	iounmap((void *)iomapadr);
+	iounmap(iomapadr);
 }
 
 int __init init_elan_104nc(void)
 {
 	/* Urg! We use I/O port 0x22 without request_region()ing it,
 	   because it's already allocated to the PIC. */
 
-  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+  	iomapadr = ioremap(WINDOW_START, WINDOW_LENGTH);
 	if (!iomapadr) {
 		printk( KERN_ERR"%s: failed to ioremap memory region\n",
 			elan_104nc_map.name );
 		return -EIO;
Index: linux-2.6.8/drivers/mtd/maps/l440gx.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/l440gx.c
+++ linux-2.6.8/drivers/mtd/maps/l440gx.c
@@ -72,9 +72,9 @@ static int __init init_l440gx(void)
 		printk(KERN_NOTICE "L440GX flash mapping: failed to find PIIX4 ISA bridge, cannot continue\n");
 		return -ENODEV;
 	}
 
-	l440gx_map.virt = (unsigned long)ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
+	l440gx_map.virt = ioremap_nocache(WINDOW_ADDR, WINDOW_SIZE);
 
 	if (!l440gx_map.virt) {
 		printk(KERN_WARNING "Failed to ioremap L440GX flash region\n");
 		return -ENOMEM;
Index: linux-2.6.8/drivers/mtd/maps/nettel.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/nettel.c
+++ linux-2.6.8/drivers/mtd/maps/nettel.c
@@ -231,9 +231,9 @@ int __init nettel_init(void)
 	int num_intel_partitions;
 #endif
 	int rc = 0;
 
-	nettel_mmcrp = (void *) ioremap_nocache(0xfffef000, 4096);
+	nettel_mmcrp = (void __iomem *) ioremap_nocache(0xfffef000, 4096);
 	if (nettel_mmcrp == NULL) {
 		printk("SNAPGEAR: failed to disable MMCR cache??\n");
 		return(-EIO);
 	}
@@ -272,10 +272,9 @@ int __init nettel_init(void)
 	*amdpar = SC520_PAR(SC520_PAR_BOOTCS, amdaddr, maxsize);
 	__asm__ ("wbinvd");
 
 	nettel_amd_map.phys = amdaddr;
-	nettel_amd_map.virt = (unsigned long)
-		ioremap_nocache(amdaddr, maxsize);
+	nettel_amd_map.virt = ioremap_nocache(amdaddr, maxsize);
 	if (!nettel_amd_map.virt) {
 		printk("SNAPGEAR: failed to ioremap() BOOTCS\n");
 		return(-EIO);
 	}
@@ -357,10 +356,9 @@ int __init nettel_init(void)
 
 	/* Probe for the the size of the first Intel flash */
 	nettel_intel_map.size = maxsize;
 	nettel_intel_map.phys = intel0addr;
-	nettel_intel_map.virt = (unsigned long)
-		ioremap_nocache(intel0addr, maxsize);
+	nettel_intel_map.virt = ioremap_nocache(intel0addr, maxsize);
 	if (!nettel_intel_map.virt) {
 		printk("SNAPGEAR: failed to ioremap() ROMCS1\n");
 		return(-EIO);
 	}
@@ -391,10 +389,9 @@ int __init nettel_init(void)
 	intel_mtd = NULL;
 	iounmap((void *) nettel_intel_map.virt);
 
 	nettel_intel_map.size = maxsize;
-	nettel_intel_map.virt = (unsigned long)
-		ioremap_nocache(intel0addr, maxsize);
+	nettel_intel_map.virt = ioremap_nocache(intel0addr, maxsize);
 	if (!nettel_intel_map.virt) {
 		printk("SNAPGEAR: failed to ioremap() ROMCS1/2\n");
 		return(-EIO);
 	}
Index: linux-2.6.8/drivers/mtd/maps/ichxrom.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/ichxrom.c
+++ linux-2.6.8/drivers/mtd/maps/ichxrom.c
@@ -47,16 +47,16 @@ struct ichxrom_map_info {
 	struct resource rom_rsrc;
 	char mtd_name[MTD_DEV_NAME_LENGTH];
 };
 
-static inline unsigned long addr(struct map_info *map, unsigned long ofs)
+static inline void __iomem * addr(struct map_info *map, unsigned long ofs)
 {
 	unsigned long offset;
 	offset = ((8*1024*1024) - map->size) + ofs;
 	if (offset >= (4*1024*1024)) {
 		offset += 0x400000;
 	}
-	return map->map_priv_1 + 0x400000 + offset;
+	return (void __iomem *)map->map_priv_1 + 0x400000 + offset;
 }
 
 static inline unsigned long dbg_addr(struct map_info *map, unsigned long addr)
 {
@@ -166,9 +166,9 @@ static int ichxrom_set_lock_state(struct
 	/* round down to 64K boundaries */
 	start = start & ~0xFFFF;
 	end = end & ~0xFFFF;
 	while (start <= end) {
-		unsigned long ctrl_addr;
+		void __iomem * ctrl_addr;
 		ctrl_addr = addr(map, start) - 0x400000 + 2;
 		writeb(state, ctrl_addr);
 		start = start + 0x10000;
 	}
Index: linux-2.6.8/drivers/mtd/maps/sc520cdp.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/sc520cdp.c
+++ linux-2.6.8/drivers/mtd/maps/sc520cdp.c
@@ -240,9 +240,9 @@ static int __init init_sc520cdp(void)
 	for (i = 0; i < NUM_FLASH_BANKS; i++) {
 		printk(KERN_NOTICE "SC520 CDP flash device: 0x%lx at 0x%lx\n",
 		       sc520cdp_map[i].size, sc520cdp_map[i].phys);
 
-		sc520cdp_map[i].virt = (unsigned long)ioremap_nocache(sc520cdp_map[i].phys, sc520cdp_map[i].size);
+		sc520cdp_map[i].virt = ioremap_nocache(sc520cdp_map[i].phys, sc520cdp_map[i].size);
 
 		if (!sc520cdp_map[i].virt) {
 			printk("Failed to ioremap_nocache\n");
 			return -EIO;
Index: linux-2.6.8/drivers/mtd/maps/netsc520.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/netsc520.c
+++ linux-2.6.8/drivers/mtd/maps/netsc520.c
@@ -94,9 +94,9 @@ static struct mtd_info *mymtd;
 
 static int __init init_netsc520(void)
 {
 	printk(KERN_NOTICE "NetSc520 flash device: 0x%lx at 0x%lx\n", netsc520_map.size, netsc520_map.phys);
-	netsc520_map.virt = (unsigned long)ioremap_nocache(netsc520_map.phys, netsc520_map.size);
+	netsc520_map.virt = ioremap_nocache(netsc520_map.phys, netsc520_map.size);
 
 	if (!netsc520_map.virt) {
 		printk("Failed to ioremap_nocache\n");
 		return -EIO;
Index: linux-2.6.8/drivers/mtd/maps/physmap.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/physmap.c
+++ linux-2.6.8/drivers/mtd/maps/physmap.c
@@ -50,9 +50,9 @@ static int __init init_physmap(void)
 	static const char *rom_probe_types[] = { "cfi_probe", "jedec_probe", "map_rom", NULL };
 	const char **type;
 
        	printk(KERN_NOTICE "physmap flash device: %lx at %lx\n", physmap_map.size, physmap_map.phys);
-	physmap_map.virt = (unsigned long)ioremap(physmap_map.phys, physmap_map.size);
+	physmap_map.virt = ioremap(physmap_map.phys, physmap_map.size);
 
 	if (!physmap_map.virt) {
 		printk("Failed to ioremap\n");
 		return -EIO;
Index: linux-2.6.8/drivers/mtd/maps/sbc_gxx.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/sbc_gxx.c
+++ linux-2.6.8/drivers/mtd/maps/sbc_gxx.c
@@ -83,9 +83,9 @@ separate MTD devices.
 
 // Globals
 
 static volatile int page_in_window = -1; // Current page in window.
-static unsigned long iomapadr;
+static void __iomem * iomapadr;
 static spinlock_t sbc_gxx_spin = SPIN_LOCK_UNLOCKED;
 
 /* partition_info gives details on the logical partitions that the split the 
  * single flash device into. If the size if zero we use up to the end of the
@@ -194,9 +194,9 @@ static void cleanup_sbc_gxx(void)
 }
 
 int __init init_sbc_gxx(void)
 {
-  	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
+  	iomapadr = ioremap(WINDOW_START, WINDOW_LENGTH);
 	if (!iomapadr) {
 		printk( KERN_ERR"%s: failed to ioremap memory region\n",
 			sbc_gxx_map.name );
 		return -EIO;
Index: linux-2.6.8/drivers/mtd/maps/scx200_docflash.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/scx200_docflash.c
+++ linux-2.6.8/drivers/mtd/maps/scx200_docflash.c
@@ -179,9 +179,9 @@ int __init init_scx200_docflash(void)
 
 	simple_map_init(&scx200_docflash_map);
 
 	scx200_docflash_map.phys = docmem.start;
-	scx200_docflash_map.virt = (unsigned long)ioremap(docmem.start, scx200_docflash_map.size);
+	scx200_docflash_map.virt = ioremap(docmem.start, scx200_docflash_map.size);
 	if (!scx200_docflash_map.virt) {
 		printk(KERN_ERR NAME ": failed to ioremap the flash\n");
 		release_resource(&docmem);
 		return -EIO;
Index: linux-2.6.8/drivers/mtd/maps/pnc2000.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/pnc2000.c
+++ linux-2.6.8/drivers/mtd/maps/pnc2000.c
@@ -17,9 +17,9 @@
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
 
 
-#define WINDOW_ADDR 0xbf000000
+#define WINDOW_ADDR (void __iomem *)0xbf000000
 #define WINDOW_SIZE 0x00400000
 
 /* 
  * MAP DRIVER STUFF
@@ -63,9 +63,9 @@ static struct mtd_partition pnc_partitio
 static struct mtd_info *mymtd;
 
 int __init init_pnc2000(void)
 {
-	printk(KERN_NOTICE "Photron PNC-2000 flash mapping: %x at %x\n", WINDOW_SIZE, WINDOW_ADDR);
+	printk(KERN_NOTICE "Photron PNC-2000 flash mapping: %x at %p\n", WINDOW_SIZE, WINDOW_ADDR);
 
 	simple_map_init(&pnc_map);
 
 	mymtd = do_map_probe("cfi_probe", &pnc_map);
Index: linux-2.6.8/include/linux/mtd/nand.h
===================================================================
--- linux-2.6.8.orig/include/linux/mtd/nand.h
+++ linux-2.6.8/include/linux/mtd/nand.h
@@ -268,10 +268,10 @@ typedef enum {
  * @priv:		[OPTIONAL] pointer to private chip date
  */
  
 struct nand_chip {
-	unsigned long 	IO_ADDR_R;
-	unsigned long 	IO_ADDR_W;
+	void __iomem * 	IO_ADDR_R;
+	void __iomem * 	IO_ADDR_W;
 	
 	u_char		(*read_byte)(struct mtd_info *mtd);
 	void		(*write_byte)(struct mtd_info *mtd, u_char byte);
 	u16		(*read_word)(struct mtd_info *mtd);
Index: linux-2.6.8/drivers/mtd/maps/scb2_flash.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/maps/scb2_flash.c
+++ linux-2.6.8/drivers/mtd/maps/scb2_flash.c
@@ -61,9 +61,9 @@
 #define SCB2_ADDR	0xfff00000
 #define SCB2_WINDOW	0x00100000
 
 
-static void *scb2_ioaddr;
+static void __iomem *scb2_ioaddr;
 static struct mtd_info *scb2_mtd;
 struct map_info scb2_map = {
 	.name =      "SCB2 BIOS Flash",
 	.size =      0,
@@ -162,9 +162,9 @@ scb2_flash_probe(struct pci_dev *dev, co
 		return -ENOMEM;
 	}
 
 	scb2_map.phys = SCB2_ADDR;
-	scb2_map.virt = (unsigned long)scb2_ioaddr;
+	scb2_map.virt = scb2_ioaddr;
 	scb2_map.size = SCB2_WINDOW;
 
 	simple_map_init(&scb2_map);
 
Index: linux-2.6.8/drivers/mtd/nand/diskonchip.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/nand/diskonchip.c
+++ linux-2.6.8/drivers/mtd/nand/diskonchip.c
@@ -61,9 +61,9 @@ static unsigned long __initdata doc_loca
 
 static struct mtd_info *doclist = NULL;
 
 struct doc_priv {
-	unsigned long virtadr;
+	void __iomem *virtadr;
 	unsigned long physadr;
 	u_char ChipID;
 	u_char CDSNControl;
 	int chips_per_floor; /* The number of chips detected on each floor */
@@ -251,9 +251,9 @@ static void doc2000_readbuf_dword(struct
 			    u_char *buf, int len)
 {
 	struct nand_chip *this = mtd->priv;
 	struct doc_priv *doc = (void *)this->priv;
-	unsigned long docptr = doc->virtadr;
+	void __iomem * docptr = doc->virtadr;
  	int i;
 
 	if (debug) printk("readbuf_dword of %d bytes: ", len);
 
@@ -304,9 +304,9 @@ static uint16_t __init doc200x_ident_chi
 		union {
 			uint32_t dword;
 			uint8_t byte[4];
 		} ident;
-		unsigned long docptr = doc->virtadr;
+		void __iomem * docptr = doc->virtadr;
 
 		doc200x_hwcontrol(mtd, NAND_CTL_SETCLE);
 		doc2000_write_byte(mtd, NAND_CMD_READID);
 		doc200x_hwcontrol(mtd, NAND_CTL_CLRCLE);
@@ -1384,15 +1384,15 @@ static inline int __init doc_probe(unsig
 	unsigned char ChipID;
 	struct mtd_info *mtd;
 	struct nand_chip *nand;
 	struct doc_priv *doc;
-	unsigned long virtadr;
+	void __iomem * virtadr;
 	unsigned char save_control;
 	unsigned char tmp, tmpb, tmpc;
 	int reg, len, numchips;
 	int ret = 0;
 
-	virtadr = (unsigned long)ioremap(physadr, DOC_IOREMAP_LEN);
+	virtadr = ioremap(physadr, DOC_IOREMAP_LEN);
 	if (!virtadr) {
 		printk(KERN_ERR "Diskonchip ioremap failed: 0x%x bytes at 0x%lx\n", DOC_IOREMAP_LEN, physadr);
 		return -EIO;
 	}
@@ -1584,9 +1584,9 @@ notfound:
 	/* Put back the contents of the DOCControl register, in case it's not
 	   actually a DiskOnChip.  */
 	WriteDOC(save_control, virtadr, DOCControl);
 fail:
-	iounmap((void *)virtadr);
+	iounmap(virtadr);
 	return ret;
 }
 
 int __init init_nanddoc(void)
@@ -1621,9 +1621,9 @@ void __exit cleanup_nanddoc(void)
 		doc = (void *)nand->priv;
 
 		nextmtd = doc->nextdoc;
 		nand_release(mtd);
-		iounmap((void *)doc->virtadr);
+		iounmap(doc->virtadr);
 		kfree(mtd);
 	}
 }
 
Index: linux-2.6.8/drivers/mtd/devices/doc2001plus.c
===================================================================
--- linux-2.6.8.orig/drivers/mtd/devices/doc2001plus.c
+++ linux-2.6.8/drivers/mtd/devices/doc2001plus.c
@@ -370,9 +370,9 @@ static void DoC_ScanChips(struct DiskOnC
 		u_char conf = ReadDOC(this->virtadr, Mplus_Configuration);
 		printk(KERN_NOTICE "Setting DiskOnChip Millennium Plus interleave to %s\n",
 		       this->interleave?"on (16-bit)":"off (8-bit)");
 		conf ^= 4;
-		WriteDOC(this->virtadr, conf, Mplus_Configuration);
+		WriteDOC(conf, this->virtadr, Mplus_Configuration);
 	}
 
 	/* For each floor, find the number of valid chips it contains */
 	for (floor = 0,ret = 1; floor < MAX_FLOORS_MPLUS; floor++) {
