diff -purN linux-post-2.6.3-20040222/Documentation/Changes linux-post-2.6.3-20040223/Documentation/Changes
--- linux-post-2.6.3-20040222/Documentation/Changes	2004-02-19 03:42:35.000000000 +0000
+++ linux-post-2.6.3-20040223/Documentation/Changes	2004-02-23 05:24:15.000000000 +0000
@@ -49,7 +49,7 @@ Card) hardware, for example, you probabl
 with pcmcia-cs.
 
 o  Gnu C                  2.95.3                  # gcc --version
-o  Gnu make               3.78                    # make --version
+o  Gnu make               3.79.1                  # make --version
 o  binutils               2.12                    # ld -v
 o  util-linux             2.10o                   # fdformat --version
 o  module-init-tools      0.9.10                  # depmod -V
@@ -96,7 +96,7 @@ your version of gcc 2.95.x, may necessit
 Make
 ----
 
-You will need Gnu make 3.78 or later to build the kernel.
+You will need Gnu make 3.79.1 or later to build the kernel.
 
 Binutils
 --------
@@ -301,9 +301,9 @@ gcc 2.95.3
 ----------
 o  <ftp://ftp.gnu.org/gnu/gcc/gcc-2.95.3.tar.gz>
 
-Make 3.78
----------
-o  <ftp://ftp.gnu.org/gnu/make/make-3.78.1.tar.gz>
+Make
+----
+o  <ftp://ftp.gnu.org/gnu/make/>
 
 Binutils
 --------
diff -purN linux-post-2.6.3-20040222/Documentation/CodingStyle linux-post-2.6.3-20040223/Documentation/CodingStyle
--- linux-post-2.6.3-20040222/Documentation/CodingStyle	2004-02-19 03:43:17.000000000 +0000
+++ linux-post-2.6.3-20040223/Documentation/CodingStyle	2004-02-23 05:24:12.000000000 +0000
@@ -411,13 +411,19 @@ The C Programming Language, Second Editi
 by Brian W. Kernighan and Dennis M. Ritchie.
 Prentice Hall, Inc., 1988.
 ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback).
+URL: http://cm.bell-labs.com/cm/cs/cbook/
 
 The Practice of Programming
-Brian W. Kernighan, Rob Pike
-Addison-Wesley, 1999, ISBN 0-201-61586-X
+by Brian W. Kernighan and Rob Pike.
+Addison-Wesley, Inc., 1999.
+ISBN 0-201-61586-X.
+URL: http://cm.bell-labs.com/cm/cs/tpop/
 
 GNU manuals - where in compliance with K&R and this text - for cpp, gcc,
-gcc internals and indent, all available from www.gnu.org.
+gcc internals and indent, all available from http://www.gnu.org
+
+WG14 is the international standardization working group for the programming
+language C, URL: http://std.dkuug.dk/JTC1/SC22/WG14/
 
 --
 Last updated on 16 February 2004 by a community effort on LKML.
diff -purN linux-post-2.6.3-20040222/arch/arm/Kconfig linux-post-2.6.3-20040223/arch/arm/Kconfig
--- linux-post-2.6.3-20040222/arch/arm/Kconfig	2004-02-21 01:06:56.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/arm/Kconfig	2004-02-22 23:45:07.000000000 +0000
@@ -615,7 +615,7 @@ source "drivers/char/Kconfig"
 
 source "drivers/i2c/Kconfig"
 
-source "drivers/l3/Kconfig"
+#source "drivers/l3/Kconfig"
 
 source "drivers/media/Kconfig"
 
diff -purN linux-post-2.6.3-20040222/arch/arm/common/sa1111.c linux-post-2.6.3-20040223/arch/arm/common/sa1111.c
--- linux-post-2.6.3-20040222/arch/arm/common/sa1111.c	2003-11-18 01:18:03.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/arm/common/sa1111.c	2004-02-22 15:51:55.000000000 +0000
@@ -1100,6 +1100,62 @@ int sa1111_get_audio_rate(struct sa1111_
 	return __sa1111_pll_clock(sachip) / (256 * div);
 }
 
+void sa1111_set_io_dir(struct sa1111_dev *sadev,
+		       unsigned int bits, unsigned int dir,
+		       unsigned int sleep_dir)
+{
+	struct sa1111 *sachip = sa1111_chip_driver(sadev);
+	unsigned long flags;
+	unsigned int val;
+	void *gpio = sachip->base + SA1111_GPIO;
+
+#define MODIFY_BITS(port, mask, dir)		\
+	if (mask) {				\
+		val = sa1111_readl(port);	\
+		val &= ~(mask);			\
+		val |= (dir) & (mask);		\
+		sa1111_writel(val, port);	\
+	}
+
+	spin_lock_irqsave(&sachip->lock, flags);
+	MODIFY_BITS(gpio + SA1111_GPIO_PADDR, bits & 15, dir);
+	MODIFY_BITS(gpio + SA1111_GPIO_PBDDR, (bits >> 8) & 255, dir >> 8);
+	MODIFY_BITS(gpio + SA1111_GPIO_PCDDR, (bits >> 16) & 255, dir >> 16);
+
+	MODIFY_BITS(gpio + SA1111_GPIO_PASDR, bits & 15, sleep_dir);
+	MODIFY_BITS(gpio + SA1111_GPIO_PBSDR, (bits >> 8) & 255, sleep_dir >> 8);
+	MODIFY_BITS(gpio + SA1111_GPIO_PCSDR, (bits >> 16) & 255, sleep_dir >> 16);
+	spin_unlock_irqrestore(&sachip->lock, flags);
+}
+
+void sa1111_set_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v)
+{
+	struct sa1111 *sachip = sa1111_chip_driver(sadev);
+	unsigned long flags;
+	unsigned int val;
+	void *gpio = sachip->base + SA1111_GPIO;
+
+	spin_lock_irqsave(&sachip->lock, flags);
+	MODIFY_BITS(gpio + SA1111_GPIO_PADWR, bits & 15, v);
+	MODIFY_BITS(gpio + SA1111_GPIO_PBDWR, (bits >> 8) & 255, v >> 8);
+	MODIFY_BITS(gpio + SA1111_GPIO_PCDWR, (bits >> 16) & 255, v >> 16);
+	spin_unlock_irqrestore(&sachip->lock, flags);
+}
+
+void sa1111_set_sleep_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v)
+{
+	struct sa1111 *sachip = sa1111_chip_driver(sadev);
+	unsigned long flags;
+	unsigned int val;
+	void *gpio = sachip->base + SA1111_GPIO;
+
+	spin_lock_irqsave(&sachip->lock, flags);
+	MODIFY_BITS(gpio + SA1111_GPIO_PASSR, bits & 15, v);
+	MODIFY_BITS(gpio + SA1111_GPIO_PBSSR, (bits >> 8) & 255, v >> 8);
+	MODIFY_BITS(gpio + SA1111_GPIO_PCSSR, (bits >> 16) & 255, v >> 16);
+	spin_unlock_irqrestore(&sachip->lock, flags);
+}
+
 /*
  * Individual device operations.
  */
@@ -1238,6 +1294,9 @@ EXPORT_SYMBOL(sa1111_check_dma_bug);
 EXPORT_SYMBOL(sa1111_select_audio_mode);
 EXPORT_SYMBOL(sa1111_set_audio_rate);
 EXPORT_SYMBOL(sa1111_get_audio_rate);
+EXPORT_SYMBOL(sa1111_set_io_dir);
+EXPORT_SYMBOL(sa1111_set_io);
+EXPORT_SYMBOL(sa1111_set_sleep_io);
 EXPORT_SYMBOL(sa1111_enable_device);
 EXPORT_SYMBOL(sa1111_disable_device);
 EXPORT_SYMBOL(sa1111_pll_clock);
diff -purN linux-post-2.6.3-20040222/arch/arm/mm/abort-lv4t.S linux-post-2.6.3-20040223/arch/arm/mm/abort-lv4t.S
--- linux-post-2.6.3-20040222/arch/arm/mm/abort-lv4t.S	2002-08-21 00:33:33.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/arm/mm/abort-lv4t.S	2004-02-22 23:38:41.000000000 +0000
@@ -220,6 +220,6 @@ ENTRY(v4t_late_abort)
 	and	r6, r6, #15			@ number of regs to transfer
 	and	r5, r8, #7 << 8
 	ldr	r7, [sp, r5, lsr #6]
-	sub	r7, r7, r6, lsr #2		@ always decrement
+	sub	r7, r7, r6, lsl #2		@ always decrement
 	str	r7, [sp, r5, lsr #6]
 	mov	pc, lr
diff -purN linux-post-2.6.3-20040222/arch/i386/kernel/cpu/cpufreq/powernow-k8.c linux-post-2.6.3-20040223/arch/i386/kernel/cpu/cpufreq/powernow-k8.c
--- linux-post-2.6.3-20040222/arch/i386/kernel/cpu/cpufreq/powernow-k8.c	2004-02-10 17:54:29.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/i386/kernel/cpu/cpufreq/powernow-k8.c	2004-02-23 05:24:15.000000000 +0000
@@ -521,7 +521,8 @@ static int check_pst_table(struct pst_s 
 		}
 		if ((pst[j].fid > MAX_FID)
 		    || (pst[j].fid & 1)
-		    || (pst[j].fid < HI_FID_TABLE_BOTTOM)){
+		    || (j && (pst[j].fid < HI_FID_TABLE_BOTTOM))) {
+			/* Only first fid is allowed to be in "low" range */
 			printk(KERN_ERR PFX "fid %d invalid : 0x%x\n", j, pst[j].fid);
 			return -EINVAL;
 		}
diff -purN linux-post-2.6.3-20040222/arch/i386/kernel/cpu/mtrr/generic.c linux-post-2.6.3-20040223/arch/i386/kernel/cpu/mtrr/generic.c
--- linux-post-2.6.3-20040222/arch/i386/kernel/cpu/mtrr/generic.c	2003-08-15 01:17:16.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/i386/kernel/cpu/mtrr/generic.c	2004-02-23 05:24:12.000000000 +0000
@@ -45,7 +45,7 @@ get_fixed_ranges(mtrr_type * frs)
 }
 
 /*  Grab all of the MTRR state for this CPU into *state  */
-void get_mtrr_state(void)
+void __init get_mtrr_state(void)
 {
 	unsigned int i;
 	struct mtrr_var_range *vrs;
@@ -142,7 +142,7 @@ void generic_get_mtrr(unsigned int reg, 
 	*type = base_lo & 0xff;
 }
 
-static int __init set_fixed_ranges(mtrr_type * frs)
+static int set_fixed_ranges(mtrr_type * frs)
 {
 	unsigned int *p = (unsigned int *) frs;
 	int changed = FALSE;
@@ -177,7 +177,7 @@ static int __init set_fixed_ranges(mtrr_
 
 /*  Set the MSR pair relating to a var range. Returns TRUE if
     changes are made  */
-static int __init set_mtrr_var_ranges(unsigned int index, struct mtrr_var_range *vr)
+static int set_mtrr_var_ranges(unsigned int index, struct mtrr_var_range *vr)
 {
 	unsigned int lo, hi;
 	int changed = FALSE;
diff -purN linux-post-2.6.3-20040222/arch/i386/kernel/cpu/mtrr/main.c linux-post-2.6.3-20040223/arch/i386/kernel/cpu/mtrr/main.c
--- linux-post-2.6.3-20040222/arch/i386/kernel/cpu/mtrr/main.c	2003-08-31 23:14:43.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/i386/kernel/cpu/mtrr/main.c	2004-02-23 05:24:12.000000000 +0000
@@ -111,7 +111,7 @@ void __init set_num_var_ranges(void)
 	num_var_ranges = config & 0xff;
 }
 
-static void init_table(void)
+static void __init init_table(void)
 {
 	int i, max;
 
@@ -541,7 +541,7 @@ static void __init init_ifs(void)
 	centaur_init_mtrr();
 }
 
-static void init_other_cpus(void)
+static void __init init_other_cpus(void)
 {
 	if (use_intel())
 		get_mtrr_state();
@@ -608,7 +608,7 @@ static struct sysdev_driver mtrr_sysdev_
 
 
 /**
- * mtrr_init - initialie mtrrs on the boot CPU
+ * mtrr_init - initialize mtrrs on the boot CPU
  *
  * This needs to be called early; before any of the other CPUs are 
  * initialized (i.e. before smp_init()).
@@ -618,7 +618,7 @@ static int __init mtrr_init(void)
 {
 	init_ifs();
 
-	if ( cpu_has_mtrr ) {
+	if (cpu_has_mtrr) {
 		mtrr_if = &generic_mtrr_ops;
 		size_or_mask = 0xff000000;	/* 36 bits */
 		size_and_mask = 0x00f00000;
@@ -660,7 +660,7 @@ static int __init mtrr_init(void)
 	} else {
 		switch (boot_cpu_data.x86_vendor) {
 		case X86_VENDOR_AMD:
-			if ( cpu_has_k6_mtrr ) {
+			if (cpu_has_k6_mtrr) {
 				/* Pre-Athlon (K6) AMD CPU MTRRs */
 				mtrr_if = mtrr_ops[X86_VENDOR_AMD];
 				size_or_mask = 0xfff00000;	/* 32 bits */
@@ -668,14 +668,14 @@ static int __init mtrr_init(void)
 			}
 			break;
 		case X86_VENDOR_CENTAUR:
-			if ( cpu_has_centaur_mcr ) {
+			if (cpu_has_centaur_mcr) {
 				mtrr_if = mtrr_ops[X86_VENDOR_CENTAUR];
 				size_or_mask = 0xfff00000;	/* 32 bits */
 				size_and_mask = 0;
 			}
 			break;
 		case X86_VENDOR_CYRIX:
-			if ( cpu_has_cyrix_arr ) {
+			if (cpu_has_cyrix_arr) {
 				mtrr_if = mtrr_ops[X86_VENDOR_CYRIX];
 				size_or_mask = 0xfff00000;	/* 32 bits */
 				size_and_mask = 0;
diff -purN linux-post-2.6.3-20040222/arch/m68k/Kconfig linux-post-2.6.3-20040223/arch/m68k/Kconfig
--- linux-post-2.6.3-20040222/arch/m68k/Kconfig	2004-02-19 03:42:35.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/Kconfig	2004-02-23 05:24:07.000000000 +0000
@@ -70,8 +70,21 @@ config PCMCIA
 	  To compile this driver as modules, choose M here: the
 	  modules will be called pcmcia_core and ds.
 
+config SUN3
+	bool "Sun3 support"
+	select M68020
+	select MMU_SUN3 if MMU
+	help
+	  This option enables support for the Sun 3 series of workstations
+	  (3/50, 3/60, 3/1xx, 3/2xx systems). Enabling this option requires 
+	  that all other hardware types must be disabled, as Sun 3 kernels 
+	  are incompatible with all other m68k targets (including Sun 3x!).  
+
+	  If you don't want to compile a kernel exclusively for a Sun 3, say N.
+
 config AMIGA
 	bool "Amiga support"
+	depends on !MMU_SUN3
 	help
 	  This option enables support for the Amiga series of computers. If
 	  you plan to use this kernel on an Amiga, say Y here and browse the
@@ -79,6 +92,7 @@ config AMIGA
 
 config ATARI
 	bool "Atari support"
+	depends on !MMU_SUN3
 	help
 	  This option enables support for the 68000-based Atari series of
 	  computers (including the TT, Falcon and Medusa). If you plan to use
@@ -109,6 +123,7 @@ config PCI
 
 config MAC
 	bool "Macintosh support"
+	depends on !MMU_SUN3
 	help
 	  This option enables support for the Apple Macintosh series of
 	  computers (yes, there is experimental support now, at least for part
@@ -129,12 +144,14 @@ config M68K_L2_CACHE
 
 config APOLLO
 	bool "Apollo support"
+	depends on !MMU_SUN3
 	help
 	  Say Y here if you want to run Linux on an MC680x0-based Apollo
 	  Domain workstation such as the DN3500.
 
 config VME
 	bool "VME (Motorola and BVM) support"
+	depends on !MMU_SUN3
 	help
 	  Say Y here if you want to build a kernel for a 680x0 based VME
 	  board.  Boards currently supported include Motorola boards MVME147,
@@ -171,6 +188,7 @@ config BVME6000
 
 config HP300
 	bool "HP9000/300 support"
+	depends on !MMU_SUN3
 	help
 	  This option enables support for the HP9000/300 series of
 	  workstations. Support for these machines is still very experimental.
@@ -187,30 +205,20 @@ config DIO
 
 config SUN3X
 	bool "Sun3x support"
+	depends on !MMU_SUN3
+	select M68030
 	help
 	  This option enables support for the Sun 3x series of workstations.
-	  Be warned that this support is very experimental. You will also want
-	  to say Y to 68030 support and N to the other processors below.
+	  Be warned that this support is very experimental.
 	  Note that Sun 3x kernels are not compatible with Sun 3 hardware.
 	  General Linux information on the Sun 3x series (now discontinued)
 	  is at <http://www.angelfire.com/ca2/tech68k/sun3.html>.
 
 	  If you don't want to compile a kernel for a Sun 3x, say N.
 
-config SUN3
-	bool "Sun3 support"
-	help
-	  This option enables support for the Sun 3 series of workstations
-	  (3/50, 3/60, 3/1xx, 3/2xx systems). Enabling this option requires 
-	  that all other hardware types must be disabled, as Sun 3 kernels 
-	  are incompatible with all other m68k targets (including Sun 3x!).  
-	  Also, you will want to say Y to 68020 support and N to the other 
-	  processors below.
-
-	  If you don't want to compile a kernel exclusively for a Sun 3, say N.
-
 config Q40
 	bool "Q40/Q60 support"
+	depends on !MMU_SUN3
 	help
 	  The Q40 is a Motorola 68040-based successor to the Sinclair QL
 	  manufactured in Germany.  There is an official Q40 home page at
@@ -230,6 +238,7 @@ config M68020
 
 config M68030
 	bool "68030 support"
+	depends on !MMU_SUN3
 	help
 	  If you anticipate running this kernel on a computer with a MC68030
 	  processor, say Y. Otherwise, say N. Note that a MC68EC030 will not
@@ -237,6 +246,7 @@ config M68030
 
 config M68040
 	bool "68040 support"
+	depends on !MMU_SUN3
 	help
 	  If you anticipate running this kernel on a computer with a MC68LC040
 	  or MC68040 processor, say Y. Otherwise, say N. Note that an
@@ -245,10 +255,19 @@ config M68040
 
 config M68060
 	bool "68060 support"
+	depends on !MMU_SUN3
 	help
 	  If you anticipate running this kernel on a computer with a MC68060
 	  processor, say Y. Otherwise, say N.
 
+config MMU_MOTOROLA
+	bool
+	depends on MMU && !MMU_SUN3
+	default y
+
+config MMU_SUN3
+	bool
+
 config M68KFPU_EMU
 	bool "Math emulation support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -404,105 +423,6 @@ config PROC_HARDWARE
 	  including the model, CPU, MMU, clock speed, BogoMIPS rating,
 	  and memory size.
 
-config PARPORT
-	tristate "Parallel port support (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
-	---help---
-	  If you want to use devices connected to your machine's parallel port
-	  (the connector at the computer with 25 holes), e.g. printer, ZIP
-	  drive, PLIP link (Parallel Line Internet Protocol is mainly used to
-	  create a mini network by connecting the parallel ports of two local
-	  machines) etc., then you need to say Y here; please read
-	  <file:Documentation/parport.txt> and
-	  <file:drivers/parport/BUGS-parport>.
-
-	  For extensive information about drivers for many devices attaching
-	  to the parallel port see <http://www.torque.net/linux-pp.html> on
-	  the WWW.
-
-	  It is possible to share a single parallel port among several devices
-	  and it is safe to compile all the corresponding drivers into the
-	  kernel. To compile parallel port support as a module, choose M here:
-	  the module will be called parport.
-	  If you have more than one parallel port and want to specify which
-	  port and IRQ to be used by this driver at module load time, take a
-	  look at <file:Documentation/parport.txt>.
-
-	  If unsure, say Y.
-
-config PARPORT_AMIGA
-	tristate "Amiga builtin port"
-	depends on AMIGA && PARPORT
-	help
-	  Say Y here if you need support for the parallel port hardware on
-	  Amiga machines. This code is also available as a module (say M),
-	  called parport_amiga. If in doubt, saying N is the safe plan.
-
-config PARPORT_MFC3
-	tristate "Multiface III parallel port"
-	depends on ZORRO && PARPORT
-	help
-	  Say Y here if you need parallel port support for the MFC3 card.
-	  This code is also available as a module (say M), called
-	  parport_mfc3. If in doubt, saying N is the safe plan.
-
-config PARPORT_PC
-	bool
-	depends on Q40 && PARPORT
-	default y
-	---help---
-	  You should say Y here if you have a PC-style parallel port. All IBM
-	  PC compatible computers and some Alphas have PC-style parallel
-	  ports.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called parport_pc.
-
-	  If unsure, say Y.
-
-config PARPORT_ATARI
-	tristate "Atari builtin port"
-	depends on ATARI && PARPORT
-	help
-	  Say Y here if you need support for the parallel port hardware on
-	  Atari machines. This code is also available as a module (say M),
-	  called parport_atari. If in doubt, saying N is the safe plan.
-
-config PRINTER
-	tristate "Parallel printer support"
-	depends on PARPORT
-	---help---
-	  If you intend to attach a printer to the parallel port of your Linux
-	  box (as opposed to using a serial printer; if the connector at the
-	  printer has 9 or 25 holes ["female"], then it's serial), say Y.
-	  Also read the Printing-HOWTO, available from
-	  <http://www.tldp.org/docs.html#howto>.
-
-	  It is possible to share one parallel port among several devices
-	  (e.g. printer and ZIP drive) and it is safe to compile the
-	  corresponding drivers into the kernel.
-	  To compile this driver as a module, choose M here and read
-	  <file:Documentation/parport.txt>.  The module will be called lp.
-
-	  If you have several parallel ports, you can specify which ports to
-	  use with the "lp" kernel command line option.  (Try "man bootparam"
-	  or see the documentation of your boot loader (lilo or loadlin) about
-	  how to pass options to the kernel at boot time.)  The syntax of the
-	  "lp" command line option can be found in <file:drivers/char/lp.c>.
-
-	  If you have more than 8 printers, you need to increase the LP_NO
-	  macro in lp.c and the PARPORT_MAX macro in parport.h.
-
-config PARPORT_1284
-	bool "IEEE 1284 transfer modes"
-	depends on PRINTER
-	help
-	  If you have a printer that supports status readback or device ID, or
-	  want to use a device that uses enhanced parallel port transfer modes
-	  such as EPP and ECP, say Y here to enable advanced IEEE 1284
-	  transfer modes. Also say Y if you want device ID information to
-	  appear in /proc/sys/dev/parport/*/autoprobe*. It is safe to say N.
-
 config ISA
 	bool
 	depends on Q40 || AMIGA_PCMCIA || GG2
@@ -523,192 +443,13 @@ source "drivers/pci/Kconfig"
 
 source "drivers/zorro/Kconfig"
 
-if Q40
-source "drivers/pnp/Kconfig"
-endif
-
 endmenu
 
-source "drivers/base/Kconfig"
-
-source "drivers/mtd/Kconfig"
-
-source "drivers/block/Kconfig"
-
-source "drivers/md/Kconfig"
-
-source "drivers/input/Kconfig"
-
-source "drivers/ide/Kconfig"
-
-source "drivers/scsi/Kconfig"
-
-source "net/Kconfig"
+source "drivers/Kconfig"
 
 
 menu "Character devices"
 
-config SERIAL
-	tristate "Q40 Standard/generic serial support" if Q40
-	default DN_SERIAL if APOLLO
-	---help---
-	  This selects whether you want to include the driver for the standard
-	  serial ports.  The standard answer is Y.  People who might say N
-	  here are those that are setting up dedicated Ethernet WWW/FTP
-	  servers, or users that have one of the various bus mice instead of a
-	  serial mouse and don't intend to use their machine's standard serial
-	  port for anything.  (Note that the Cyclades and Stallion multi
-	  serial port drivers do not need this driver built in for them to
-	  work.)
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called serial.
-	  [WARNING: Do not compile this driver as a module if you are using
-	  non-standard serial ports, since the configuration information will
-	  be lost when the driver is unloaded.  This limitation may be lifted
-	  in the future.]
-
-	  BTW1: If you have a mouseman serial mouse which is not recognized by
-	  the X window system, try running gpm first.
-
-	  BTW2: If you intend to use a software modem (also called Winmodem)
-	  under Linux, forget it.  These modems are crippled and require
-	  proprietary drivers which are only available under Windows.
-
-	  Most people will say Y or M here, so that they can use serial mice,
-	  modems and similar devices connecting to the standard serial ports.
-
-config SERIAL_EXTENDED
-	bool "Extended dumb serial driver options"
-	depends on SERIAL=y
-	help
-	  If you wish to use any non-standard features of the standard "dumb"
-	  driver, say Y here. This includes HUB6 support, shared serial
-	  interrupts, special multiport support, support for more than the
-	  four COM 1/2/3/4 boards, etc.
-
-	  Note that the answer to this question won't directly affect the
-	  kernel: saying N will just cause the configurator to skip all
-	  the questions about serial driver options. If unsure, say N.
-
-config SERIAL_MANY_PORTS
-	bool "Support more than 4 serial ports"
-	depends on SERIAL_EXTENDED
-	help
-	  Say Y here if you have dumb serial boards other than the four
-	  standard COM 1/2/3/4 ports. This may happen if you have an AST
-	  FourPort, Accent Async, Boca (read the Boca mini-HOWTO, available
-	  from <http://www.tldp.org/docs.html#howto>), or other custom
-	  serial port hardware which acts similar to standard serial port
-	  hardware. If you only use the standard COM 1/2/3/4 ports, you can
-	  say N here to save some memory. You can also say Y if you have an
-	  "intelligent" multiport card such as Cyclades, Digiboards, etc.
-
-config SERIAL_SHARE_IRQ
-	bool "Support for sharing serial interrupts"
-	depends on SERIAL_EXTENDED
-	help
-	  Some serial boards have hardware support which allows multiple dumb
-	  serial ports on the same board to share a single IRQ. To enable
-	  support for this in the serial driver, say Y here.
-
-config SERIAL_MULTIPORT
-	bool "Support special multiport boards"
-	depends on SERIAL_EXTENDED
-	help
-	  Some multiport serial ports have special ports which are used to
-	  signal when there are any serial ports on the board which need
-	  servicing. Say Y here to enable the serial driver to take advantage
-	  of those special I/O ports.
-
-config HUB6
-	bool "Support the Bell Technologies HUB6 card"
-	depends on SERIAL_EXTENDED
-	help
-	  Say Y here to enable support in the dumb serial driver to support
-	  the HUB6 card.
-
-config VT
-	bool "Virtual terminal"
-	---help---
-	  If you say Y here, you will get support for terminal devices with
-	  display and keyboard devices. These are called "virtual" because you
-	  can run several virtual terminals (also called virtual consoles) on
-	  one physical terminal. This is rather useful, for example one
-	  virtual terminal can collect system messages and warnings, another
-	  one can be used for a text-mode user session, and a third could run
-	  an X session, all in parallel. Switching between virtual terminals
-	  is done with certain key combinations, usually Alt-<function key>.
-
-	  The setterm command ("man setterm") can be used to change the
-	  properties (such as colors or beeping) of a virtual terminal. The
-	  man page console_codes(4) ("man console_codes") contains the special
-	  character sequences that can be used to change those properties
-	  directly. The fonts used on virtual terminals can be changed with
-	  the setfont ("man setfont") command and the key bindings are defined
-	  with the loadkeys ("man loadkeys") command.
-
-	  You need at least one virtual terminal device in order to make use
-	  of your keyboard and monitor. Therefore, only people configuring an
-	  embedded system would want to say N here in order to save some
-	  memory; the only way to log into such a system is then via a serial
-	  or network connection.
-
-	  If unsure, say Y, or else you won't be able to do much with your new
-	  shiny Linux system :-)
-
-config VT_CONSOLE
-	bool "Support for console on virtual terminal"
-	depends on VT
-	---help---
-	  The system console is the device which receives all kernel messages
-	  and warnings and which allows logins in single user mode. If you
-	  answer Y here, a virtual terminal (the device used to interact with
-	  a physical terminal) can be used as system console. This is the most
-	  common mode of operations, so you should say Y here unless you want
-	  the kernel messages be output only to a serial port (in which case
-	  you should say Y to "Console on serial port", below).
-
-	  If you do say Y here, by default the currently visible virtual
-	  terminal (/dev/tty0) will be used as system console. You can change
-	  that with a kernel command line option such as "console=tty3" which
-	  would use the third virtual terminal as system console. (Try "man
-	  bootparam" or see the documentation of your boot loader (lilo or
-	  loadlin) about how to pass options to the kernel at boot time.)
-
-	  If unsure, say Y.
-
-config HW_CONSOLE
-	bool
-	depends on VT
-	default y
-
-config NVRAM
-	bool
-	depends on ATARI
-	default y
-	---help---
-	  If you say Y here and create a character special file /dev/nvram
-	  with major number 10 and minor number 144 using mknod ("man mknod"),
-	  you get read and write access to the 50 bytes of non-volatile memory
-	  in the real time clock (RTC), which is contained in every PC and
-	  most Ataris.
-
-	  This memory is conventionally called "CMOS RAM" on PCs and "NVRAM"
-	  on Ataris. /dev/nvram may be used to view settings there, or to
-	  change them (with some utility). It could also be used to frequently
-	  save a few bits of very important data that may not be lost over
-	  power-off and for which writing to disk is too insecure. Note
-	  however that most NVRAM space in a PC belongs to the BIOS and you
-	  should NEVER idly tamper with it. See Ralf Brown's interrupt list
-	  for a guide to the use of CMOS bytes by your BIOS.
-
-	  On Atari machines, /dev/nvram is always configured and does not need
-	  to be selected.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called nvram.
-
 config ATARI_MFPSER
 	tristate "Atari MFP serial support"
 	depends on ATARI
@@ -787,22 +528,6 @@ config MULTIFACE_III_TTY
 
 	  To compile this driver as a module, choose M here.
 
-config A2232
-	tristate "Commodore A2232 serial support (EXPERIMENTAL)"
-	depends on AMIGA && EXPERIMENTAL
-	---help---
-	  This option supports the 2232 7-port serial card shipped with the
-	  Amiga 2000 and other Zorro-bus machines, dating from 1989.  At
-	  a max of 19,200 bps, the ports are served by a 6551 ACIA UART chip
-	  each, plus a 8520 CIA, and a master 6502 CPU and buffer as well. The
-	  ports were connected with 8 pin DIN connectors on the card bracket,
-	  for which 8 pin to DB25 adapters were supplied. The card also had
-	  jumpers internally to toggle various pinning configurations.
-
-	  This driver can be built as a module; but then "generic_serial"
-	  will also be built as a module. This has to be loaded before
-	  "ser_a2232". If you want to do this, answer M here.
-
 config GVPIOEXT
 	tristate "GVP IO-Extender support"
 	depends on PARPORT=n && ZORRO
@@ -1009,86 +734,10 @@ config SERIAL_CONSOLE
 
 	  If unsure, say N.
 
-config USERIAL
-	bool "Support for user serial device modules"
-
-source "drivers/char/watchdog/Kconfig"
-
-config GEN_RTC
-	tristate "Generic /dev/rtc emulation" if !SUN3
-	default y if SUN3
-	---help---
-	  If you say Y here and create a character special file /dev/rtc with
-	  major number 10 and minor number 135 using mknod ("man mknod"), you
-	  will get access to the real time clock (or hardware clock) built
-	  into your computer.
-
-	  It reports status information via the file /proc/driver/rtc and its
-	  behaviour is set by various ioctls on /dev/rtc. If you enable the
-	  "extended RTC operation" below it will also provide an emulation
-	  for RTC_UIE which is required by some programs and may improve
-	  precision in some cases.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called genrtc.
-
-config GEN_RTC_X
-	bool "Extended RTC operation"
-	depends on GEN_RTC
-	help
-	  Provides an emulation for RTC_UIE which is required by some programs
-	  and may improve precision of the generic RTC support in some cases.
-
-config UNIX98_PTYS
-	bool "Unix98 PTY support"
-	---help---
-	  A pseudo terminal (PTY) is a software device consisting of two
-	  halves: a master and a slave. The slave device behaves identical to
-	  a physical terminal; the master device is used by a process to
-	  read data from and write data to the slave, thereby emulating a
-	  terminal. Typical programs for the master side are telnet servers
-	  and xterms.
-
-	  Linux has traditionally used the BSD-like names /dev/ptyxx for
-	  masters and /dev/ttyxx for slaves of pseudo terminals. This scheme
-	  has a number of problems. The GNU C library glibc 2.1 and later,
-	  however, supports the Unix98 naming standard: in order to acquire a
-	  pseudo terminal, a process opens /dev/ptmx; the number of the pseudo
-	  terminal is then made available to the process and the pseudo
-	  terminal slave can be accessed as /dev/pts/<number>. What was
-	  traditionally /dev/ttyp2 will then be /dev/pts/2, for example.
-
-	  The entries in /dev/pts/ are created on the fly by a virtual
-	  file system; therefore, if you say Y here you should say Y to
-	  "/dev/pts file system for Unix98 PTYs" as well.
-
-	  If you want to say Y here, you need to have the C library glibc 2.1
-	  or later (equal to libc-6.1, check with "ls -l /lib/libc.so.*").
-	  Read the instructions in <file:Documentation/Changes> pertaining to
-	  pseudo terminals. It's safe to say N.
-
-config UNIX98_PTY_COUNT
-	int "Maximum number of Unix98 PTYs in use (0-2048)"
-	depends on UNIX98_PTYS
-	default "256"
-	help
-	  The maximum number of Unix98 PTYs that can be used at any one time.
-	  The default is 256, and should be enough for desktop systems. Server
-	  machines which support incoming telnet/rlogin/ssh connections and/or
-	  serve several X terminals may want to increase this: every incoming
-	  connection and every xterm uses up one PTY.
-
-	  When not in use, each additional set of 256 PTYs occupy
-	  approximately 8 KB of kernel memory on 32-bit architectures.
-
 endmenu
 
-source "sound/Kconfig"
-
 source "fs/Kconfig"
 
-source "drivers/video/Kconfig"
-
 menu "Kernel hacking"
 
 config DEBUG_KERNEL
diff -purN linux-post-2.6.3-20040222/arch/m68k/Makefile linux-post-2.6.3-20040223/arch/m68k/Makefile
--- linux-post-2.6.3-20040222/arch/m68k/Makefile	2003-09-03 13:16:32.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/Makefile	2004-02-23 05:24:04.000000000 +0000
@@ -111,6 +111,14 @@ else
 	bzip2 -1c vmlinux >vmlinux.bz2
 endif
 
+prepare: include/asm-$(ARCH)/offsets.h
+CLEAN_FILES += include/asm-$(ARCH)/offsets.h
+
+arch/$(ARCH)/kernel/asm-offsets.s: include/asm include/linux/version.h \
+				   include/config/MARKER
+
+include/asm-$(ARCH)/offsets.h: arch/$(ARCH)/kernel/asm-offsets.s
+	$(call filechk,gen-asm-offsets)
+
 archclean:
 	rm -f vmlinux.gz vmlinux.bz2
-	rm -f arch/m68k/kernel/m68k_defs.h arch/m68k/kernel/m68k_defs.d
diff -purN linux-post-2.6.3-20040222/arch/m68k/atari/config.c linux-post-2.6.3-20040223/arch/m68k/atari/config.c
--- linux-post-2.6.3-20040222/arch/m68k/atari/config.c	2003-05-26 00:00:00.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/atari/config.c	2004-02-23 05:24:05.000000000 +0000
@@ -344,7 +344,7 @@ void __init config_atari(void)
 	ATARIHW_SET(PCM_8BIT);
         printk( "PCM " );
     }
-    if (!MACH_IS_HADES && hwreg_present( &codec.unused5 )) {
+    if (!MACH_IS_HADES && hwreg_present( &falcon_codec.unused5 )) {
 	ATARIHW_SET(CODEC);
         printk( "CODEC " );
     }
diff -purN linux-post-2.6.3-20040222/arch/m68k/fpsp040/skeleton.S linux-post-2.6.3-20040223/arch/m68k/fpsp040/skeleton.S
--- linux-post-2.6.3-20040222/arch/m68k/fpsp040/skeleton.S	2002-10-10 17:51:24.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/fpsp040/skeleton.S	2004-02-23 05:24:04.000000000 +0000
@@ -40,7 +40,7 @@
 
 #include <linux/linkage.h>
 #include <asm/entry.h>
-#include "../kernel/m68k_defs.h"
+#include <asm/offsets.h>
 
 |SKELETON	idnt    2,1 | Motorola 040 Floating Point Software Package
 
diff -purN linux-post-2.6.3-20040222/arch/m68k/ifpsp060/iskeleton.S linux-post-2.6.3-20040223/arch/m68k/ifpsp060/iskeleton.S
--- linux-post-2.6.3-20040222/arch/m68k/ifpsp060/iskeleton.S	2003-02-27 17:20:37.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/ifpsp060/iskeleton.S	2004-02-23 05:24:04.000000000 +0000
@@ -36,7 +36,7 @@
 
 #include <linux/linkage.h>
 #include <asm/entry.h>
-#include "../kernel/m68k_defs.h"
+#include <asm/offsets.h>
 
 
 |################################
diff -purN linux-post-2.6.3-20040222/arch/m68k/kernel/Makefile linux-post-2.6.3-20040223/arch/m68k/kernel/Makefile
--- linux-post-2.6.3-20040222/arch/m68k/kernel/Makefile	2003-08-05 03:55:18.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/kernel/Makefile	2004-02-23 05:24:04.000000000 +0000
@@ -16,20 +16,3 @@ obj-$(CONFIG_PCI)	+= bios32.o
 obj-$(CONFIG_MODULES)	+= module.o
 
 EXTRA_AFLAGS := -traditional
-
-$(obj)/head.o: $(obj)/head.S $(obj)/m68k_defs.h
-
-$(obj)/entry.o: $(obj)/entry.S $(obj)/m68k_defs.h
-
-$(obj)/sun3-head.o: $(obj)/sun3-head.S $(obj)/m68k_defs.h
-
-$(obj)/m68k_defs.h: $(src)/m68k_defs.c $(src)/m68k_defs.head
-	rm -f $(obj)/m68k_defs.d
-	SUNPRO_DEPENDENCIES="$(obj)/m68k_defs.d $(obj)/m68k_defs.h" \
-	$(CC) $(filter-out -MD,$(CFLAGS)) -S $(src)/m68k_defs.c -o \
-	$(obj)/m68k_defs.s
-	cp $(src)/m68k_defs.head $(obj)/m68k_defs.h
-	grep '^#define' $(obj)/m68k_defs.s >> $(obj)/m68k_defs.h
-	rm $(obj)/m68k_defs.s
--include $(obj)/m68k_defs.d
-
diff -purN linux-post-2.6.3-20040222/arch/m68k/kernel/asm-offsets.c linux-post-2.6.3-20040223/arch/m68k/kernel/asm-offsets.c
--- linux-post-2.6.3-20040222/arch/m68k/kernel/asm-offsets.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/kernel/asm-offsets.c	2004-02-23 05:24:04.000000000 +0000
@@ -0,0 +1,109 @@
+/*
+ * This program is used to generate definitions needed by
+ * assembly language modules.
+ *
+ * We use the technique used in the OSF Mach kernel code:
+ * generate asm statements containing #defines,
+ * compile this file to assembler, and then extract the
+ * #defines from the assembly-language output.
+ */
+
+#include <linux/stddef.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/amigahw.h>
+#include <linux/font.h>
+
+#define DEFINE(sym, val) \
+	asm volatile("\n->" #sym " %0 " #val : : "i" (val))
+
+int main(void)
+{
+	/* offsets into the task struct */
+	DEFINE(TASK_STATE, offsetof(struct task_struct, state));
+	DEFINE(TASK_FLAGS, offsetof(struct task_struct, flags));
+	DEFINE(TASK_PTRACE, offsetof(struct task_struct, ptrace));
+	DEFINE(TASK_WORK, offsetof(struct task_struct, thread.work));
+	DEFINE(TASK_NEEDRESCHED, offsetof(struct task_struct, thread.work.need_resched));
+	DEFINE(TASK_SYSCALL_TRACE, offsetof(struct task_struct, thread.work.syscall_trace));
+	DEFINE(TASK_SIGPENDING, offsetof(struct task_struct, thread.work.sigpending));
+	DEFINE(TASK_NOTIFY_RESUME, offsetof(struct task_struct, thread.work.notify_resume));
+	DEFINE(TASK_THREAD, offsetof(struct task_struct, thread));
+	DEFINE(TASK_MM, offsetof(struct task_struct, mm));
+	DEFINE(TASK_ACTIVE_MM, offsetof(struct task_struct, active_mm));
+
+	/* offsets into the thread struct */
+	DEFINE(THREAD_KSP, offsetof(struct thread_struct, ksp));
+	DEFINE(THREAD_USP, offsetof(struct thread_struct, usp));
+	DEFINE(THREAD_SR, offsetof(struct thread_struct, sr));
+	DEFINE(THREAD_FS, offsetof(struct thread_struct, fs));
+	DEFINE(THREAD_CRP, offsetof(struct thread_struct, crp));
+	DEFINE(THREAD_ESP0, offsetof(struct thread_struct, esp0));
+	DEFINE(THREAD_FPREG, offsetof(struct thread_struct, fp));
+	DEFINE(THREAD_FPCNTL, offsetof(struct thread_struct, fpcntl));
+	DEFINE(THREAD_FPSTATE, offsetof(struct thread_struct, fpstate));
+
+	/* offsets into the pt_regs */
+	DEFINE(PT_D0, offsetof(struct pt_regs, d0));
+	DEFINE(PT_ORIG_D0, offsetof(struct pt_regs, orig_d0));
+	DEFINE(PT_D1, offsetof(struct pt_regs, d1));
+	DEFINE(PT_D2, offsetof(struct pt_regs, d2));
+	DEFINE(PT_D3, offsetof(struct pt_regs, d3));
+	DEFINE(PT_D4, offsetof(struct pt_regs, d4));
+	DEFINE(PT_D5, offsetof(struct pt_regs, d5));
+	DEFINE(PT_A0, offsetof(struct pt_regs, a0));
+	DEFINE(PT_A1, offsetof(struct pt_regs, a1));
+	DEFINE(PT_A2, offsetof(struct pt_regs, a2));
+	DEFINE(PT_PC, offsetof(struct pt_regs, pc));
+	DEFINE(PT_SR, offsetof(struct pt_regs, sr));
+	/* bitfields are a bit difficult */
+	DEFINE(PT_VECTOR, offsetof(struct pt_regs, pc) + 4);
+
+	/* offsets into the irq_handler struct */
+	DEFINE(IRQ_HANDLER, offsetof(struct irq_node, handler));
+	DEFINE(IRQ_DEVID, offsetof(struct irq_node, dev_id));
+	DEFINE(IRQ_NEXT, offsetof(struct irq_node, next));
+
+	/* offsets into the kernel_stat struct */
+	DEFINE(STAT_IRQ, offsetof(struct kernel_stat, irqs));
+
+	/* offsets into the irq_cpustat_t struct */
+	DEFINE(CPUSTAT_SOFTIRQ_PENDING, offsetof(irq_cpustat_t, __softirq_pending));
+
+	/* offsets into the bi_record struct */
+	DEFINE(BIR_TAG, offsetof(struct bi_record, tag));
+	DEFINE(BIR_SIZE, offsetof(struct bi_record, size));
+	DEFINE(BIR_DATA, offsetof(struct bi_record, data));
+
+	/* offsets into font_desc (drivers/video/console/font.h) */
+	DEFINE(FONT_DESC_IDX, offsetof(struct font_desc, idx));
+	DEFINE(FONT_DESC_NAME, offsetof(struct font_desc, name));
+	DEFINE(FONT_DESC_WIDTH, offsetof(struct font_desc, width));
+	DEFINE(FONT_DESC_HEIGHT, offsetof(struct font_desc, height));
+	DEFINE(FONT_DESC_DATA, offsetof(struct font_desc, data));
+	DEFINE(FONT_DESC_PREF, offsetof(struct font_desc, pref));
+
+	/* signal defines */
+	DEFINE(SIGSEGV, SIGSEGV);
+	DEFINE(SEGV_MAPERR, SEGV_MAPERR);
+	DEFINE(SIGTRAP, SIGTRAP);
+	DEFINE(TRAP_TRACE, TRAP_TRACE);
+
+	/* offsets into the custom struct */
+	DEFINE(CUSTOMBASE, &custom);
+	DEFINE(C_INTENAR, offsetof(struct CUSTOM, intenar));
+	DEFINE(C_INTREQR, offsetof(struct CUSTOM, intreqr));
+	DEFINE(C_INTENA, offsetof(struct CUSTOM, intena));
+	DEFINE(C_INTREQ, offsetof(struct CUSTOM, intreq));
+	DEFINE(C_SERDATR, offsetof(struct CUSTOM, serdatr));
+	DEFINE(C_SERDAT, offsetof(struct CUSTOM, serdat));
+	DEFINE(C_SERPER, offsetof(struct CUSTOM, serper));
+	DEFINE(CIAABASE, &ciaa);
+	DEFINE(CIABBASE, &ciab);
+	DEFINE(C_PRA, offsetof(struct CIA, pra));
+	DEFINE(ZTWOBASE, zTwoBase);
+
+	return 0;
+}
diff -purN linux-post-2.6.3-20040222/arch/m68k/kernel/entry.S linux-post-2.6.3-20040223/arch/m68k/kernel/entry.S
--- linux-post-2.6.3-20040222/arch/m68k/kernel/entry.S	2003-07-18 16:23:57.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/kernel/entry.S	2004-02-23 05:24:04.000000000 +0000
@@ -42,7 +42,7 @@
 #include <asm/traps.h>
 #include <asm/unistd.h>
 
-#include "m68k_defs.h"
+#include <asm/offsets.h>
 
 .globl system_call, buserr, trap
 .globl resume, ret_from_exception
diff -purN linux-post-2.6.3-20040222/arch/m68k/kernel/head.S linux-post-2.6.3-20040223/arch/m68k/kernel/head.S
--- linux-post-2.6.3-20040222/arch/m68k/kernel/head.S	2004-01-19 06:35:37.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/kernel/head.S	2004-02-23 05:24:04.000000000 +0000
@@ -262,7 +262,7 @@
 #include <asm/entry.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
-#include "m68k_defs.h"
+#include <asm/offsets.h>
 
 #ifdef CONFIG_MAC
 
diff -purN linux-post-2.6.3-20040222/arch/m68k/kernel/m68k_defs.c linux-post-2.6.3-20040223/arch/m68k/kernel/m68k_defs.c
--- linux-post-2.6.3-20040222/arch/m68k/kernel/m68k_defs.c	2003-07-04 15:06:09.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/kernel/m68k_defs.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,109 +0,0 @@
-/*
- * This program is used to generate definitions needed by
- * assembly language modules.
- *
- * We use the technique used in the OSF Mach kernel code:
- * generate asm statements containing #defines,
- * compile this file to assembler, and then extract the
- * #defines from the assembly-language output.
- */
-
-#include <linux/stddef.h>
-#include <linux/sched.h>
-#include <linux/kernel_stat.h>
-#include <asm/bootinfo.h>
-#include <asm/irq.h>
-#include <asm/amigahw.h>
-#include <linux/font.h>
-
-#define DEFINE(sym, val) \
-	asm volatile("\n#define " #sym " %c0" : : "i" (val))
-
-int main(void)
-{
-	/* offsets into the task struct */
-	DEFINE(TASK_STATE, offsetof(struct task_struct, state));
-	DEFINE(TASK_FLAGS, offsetof(struct task_struct, flags));
-	DEFINE(TASK_PTRACE, offsetof(struct task_struct, ptrace));
-	DEFINE(TASK_WORK, offsetof(struct task_struct, thread.work));
-	DEFINE(TASK_NEEDRESCHED, offsetof(struct task_struct, thread.work.need_resched));
-	DEFINE(TASK_SYSCALL_TRACE, offsetof(struct task_struct, thread.work.syscall_trace));
-	DEFINE(TASK_SIGPENDING, offsetof(struct task_struct, thread.work.sigpending));
-	DEFINE(TASK_NOTIFY_RESUME, offsetof(struct task_struct, thread.work.notify_resume));
-	DEFINE(TASK_THREAD, offsetof(struct task_struct, thread));
-	DEFINE(TASK_MM, offsetof(struct task_struct, mm));
-	DEFINE(TASK_ACTIVE_MM, offsetof(struct task_struct, active_mm));
-
-	/* offsets into the thread struct */
-	DEFINE(THREAD_KSP, offsetof(struct thread_struct, ksp));
-	DEFINE(THREAD_USP, offsetof(struct thread_struct, usp));
-	DEFINE(THREAD_SR, offsetof(struct thread_struct, sr));
-	DEFINE(THREAD_FS, offsetof(struct thread_struct, fs));
-	DEFINE(THREAD_CRP, offsetof(struct thread_struct, crp));
-	DEFINE(THREAD_ESP0, offsetof(struct thread_struct, esp0));
-	DEFINE(THREAD_FPREG, offsetof(struct thread_struct, fp));
-	DEFINE(THREAD_FPCNTL, offsetof(struct thread_struct, fpcntl));
-	DEFINE(THREAD_FPSTATE, offsetof(struct thread_struct, fpstate));
-
-	/* offsets into the pt_regs */
-	DEFINE(PT_D0, offsetof(struct pt_regs, d0));
-	DEFINE(PT_ORIG_D0, offsetof(struct pt_regs, orig_d0));
-	DEFINE(PT_D1, offsetof(struct pt_regs, d1));
-	DEFINE(PT_D2, offsetof(struct pt_regs, d2));
-	DEFINE(PT_D3, offsetof(struct pt_regs, d3));
-	DEFINE(PT_D4, offsetof(struct pt_regs, d4));
-	DEFINE(PT_D5, offsetof(struct pt_regs, d5));
-	DEFINE(PT_A0, offsetof(struct pt_regs, a0));
-	DEFINE(PT_A1, offsetof(struct pt_regs, a1));
-	DEFINE(PT_A2, offsetof(struct pt_regs, a2));
-	DEFINE(PT_PC, offsetof(struct pt_regs, pc));
-	DEFINE(PT_SR, offsetof(struct pt_regs, sr));
-	/* bitfields are a bit difficult */
-	DEFINE(PT_VECTOR, offsetof(struct pt_regs, pc) + 4);
-
-	/* offsets into the irq_handler struct */
-	DEFINE(IRQ_HANDLER, offsetof(struct irq_node, handler));
-	DEFINE(IRQ_DEVID, offsetof(struct irq_node, dev_id));
-	DEFINE(IRQ_NEXT, offsetof(struct irq_node, next));
-
-	/* offsets into the kernel_stat struct */
-	DEFINE(STAT_IRQ, offsetof(struct kernel_stat, irqs));
-
-	/* offsets into the irq_cpustat_t struct */
-	DEFINE(CPUSTAT_SOFTIRQ_PENDING, offsetof(irq_cpustat_t, __softirq_pending));
-
-	/* offsets into the bi_record struct */
-	DEFINE(BIR_TAG, offsetof(struct bi_record, tag));
-	DEFINE(BIR_SIZE, offsetof(struct bi_record, size));
-	DEFINE(BIR_DATA, offsetof(struct bi_record, data));
-
-	/* offsets into font_desc (drivers/video/console/font.h) */
-	DEFINE(FONT_DESC_IDX, offsetof(struct font_desc, idx));
-	DEFINE(FONT_DESC_NAME, offsetof(struct font_desc, name));
-	DEFINE(FONT_DESC_WIDTH, offsetof(struct font_desc, width));
-	DEFINE(FONT_DESC_HEIGHT, offsetof(struct font_desc, height));
-	DEFINE(FONT_DESC_DATA, offsetof(struct font_desc, data));
-	DEFINE(FONT_DESC_PREF, offsetof(struct font_desc, pref));
-
-	/* signal defines */
-	DEFINE(SIGSEGV, SIGSEGV);
-	DEFINE(SEGV_MAPERR, SEGV_MAPERR);
-	DEFINE(SIGTRAP, SIGTRAP);
-	DEFINE(TRAP_TRACE, TRAP_TRACE);
-
-	/* offsets into the custom struct */
-	DEFINE(CUSTOMBASE, &custom);
-	DEFINE(C_INTENAR, offsetof(struct CUSTOM, intenar));
-	DEFINE(C_INTREQR, offsetof(struct CUSTOM, intreqr));
-	DEFINE(C_INTENA, offsetof(struct CUSTOM, intena));
-	DEFINE(C_INTREQ, offsetof(struct CUSTOM, intreq));
-	DEFINE(C_SERDATR, offsetof(struct CUSTOM, serdatr));
-	DEFINE(C_SERDAT, offsetof(struct CUSTOM, serdat));
-	DEFINE(C_SERPER, offsetof(struct CUSTOM, serper));
-	DEFINE(CIAABASE, &ciaa);
-	DEFINE(CIABBASE, &ciab);
-	DEFINE(C_PRA, offsetof(struct CIA, pra));
-	DEFINE(ZTWOBASE, zTwoBase);
-
-	return 0;
-}
diff -purN linux-post-2.6.3-20040222/arch/m68k/kernel/m68k_defs.head linux-post-2.6.3-20040223/arch/m68k/kernel/m68k_defs.head
--- linux-post-2.6.3-20040222/arch/m68k/kernel/m68k_defs.head	2002-02-05 17:40:27.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/kernel/m68k_defs.head	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-/*
- * WARNING! This file is automatically generated - DO NOT EDIT!
- */
-
-#define TS_MAGICKEY	0x5a5a5a5a
diff -purN linux-post-2.6.3-20040222/arch/m68k/kernel/module.c linux-post-2.6.3-20040223/arch/m68k/kernel/module.c
--- linux-post-2.6.3-20040222/arch/m68k/kernel/module.c	2003-06-08 13:06:00.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/kernel/module.c	2004-02-23 05:24:07.000000000 +0000
@@ -82,9 +82,38 @@ int apply_relocate_add(Elf32_Shdr *sechd
 		       unsigned int relsec,
 		       struct module *me)
 {
-	printk(KERN_ERR "module %s: ADD RELOCATION unsupported\n",
-	       me->name);
-	return -ENOEXEC;
+	unsigned int i;
+	Elf32_Rela *rel = (void *)sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	uint32_t *location;
+
+	DEBUGP("Applying relocate_add section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to.  Note that all
+		   undefined symbols have been resolved.  */
+		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
+			+ ELF32_R_SYM(rel[i].r_info);
+
+		switch (ELF32_R_TYPE(rel[i].r_info)) {
+		case R_68K_32:
+			/* We add the value into the location given */
+			*location = rel[i].r_addend + sym->st_value;
+			break;
+		case R_68K_PC32:
+			/* Add the value, subtract its postition */
+			*location = rel[i].r_addend + sym->st_value - (uint32_t)location;
+			break;
+		default:
+			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
+			       me->name, ELF32_R_TYPE(rel[i].r_info));
+			return -ENOEXEC;
+		}
+	}
+	return 0;
 }
 
 int module_finalize(const Elf_Ehdr *hdr,
diff -purN linux-post-2.6.3-20040222/arch/m68k/kernel/setup.c linux-post-2.6.3-20040223/arch/m68k/kernel/setup.c
--- linux-post-2.6.3-20040222/arch/m68k/kernel/setup.c	2003-05-26 00:00:00.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/kernel/setup.c	2004-02-23 05:24:08.000000000 +0000
@@ -538,7 +538,6 @@ void check_bugs(void)
 				"WHICH IS REQUIRED BY LINUX/M68K ***\n" );
 		printk( KERN_EMERG "Upgrade your hardware or join the FPU "
 				"emulation project\n" );
-		printk( KERN_EMERG "(see http://no-fpu.linux-m68k.org)\n" );
 		panic( "no FPU" );
 	}
 
diff -purN linux-post-2.6.3-20040222/arch/m68k/kernel/traps.c linux-post-2.6.3-20040223/arch/m68k/kernel/traps.c
--- linux-post-2.6.3-20040222/arch/m68k/kernel/traps.c	2004-01-19 06:35:43.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/kernel/traps.c	2004-02-23 05:24:09.000000000 +0000
@@ -30,6 +30,7 @@
 #include <linux/linkage.h>
 #include <linux/init.h>
 #include <linux/ptrace.h>
+#include <linux/kallsyms.h>
 
 #include <asm/setup.h>
 #include <asm/fpu.h>
@@ -645,7 +646,7 @@ static inline void bus_error030 (struct 
 			if (do_page_fault (&fp->ptregs, addr, errorcode) < 0)
 				return;
 		} else if (!(mmusr & MMU_I)) {
-			/* propably a 020 cas fault */
+			/* probably a 020 cas fault */
 			if (!(ssw & RM))
 				printk("unexpected bus error (%#x,%#x)\n", ssw, mmusr);
 		} else if (mmusr & (MMU_B|MMU_L|MMU_S)) {
@@ -825,9 +826,12 @@ void show_trace(unsigned long *stack)
 		 * out the call path that was taken.
 		 */
 		if (kernel_text_address(addr)) {
-			if (i % 4 == 0)
+#ifndef CONFIG_KALLSYMS
+			if (i % 5 == 0)
 				printk("\n       ");
+#endif
 			printk(" [<%08lx>]", addr);
+			print_symbol(" %s\n", addr);
 			i++;
 		}
 	}
@@ -1098,8 +1102,10 @@ void die_if_kernel (char *str, struct pt
 
 	console_verbose();
 	printk("%s: %08x\n",str,nr);
-	printk("PC: [<%08lx>]\nSR: %04x  SP: %p  a2: %08lx\n",
-	       fp->pc, fp->sr, fp, fp->a2);
+	printk("PC: [<%08lx>]",fp->pc);
+	print_symbol(" %s\n", fp->pc);
+	printk("\nSR: %04x  SP: %p  a2: %08lx\n",
+	       fp->sr, fp, fp->a2);
 	printk("d0: %08lx    d1: %08lx    d2: %08lx    d3: %08lx\n",
 	       fp->d0, fp->d1, fp->d2, fp->d3);
 	printk("d4: %08lx    d5: %08lx    a0: %08lx    a1: %08lx\n",
diff -purN linux-post-2.6.3-20040222/arch/m68k/mac/iop.c linux-post-2.6.3-20040223/arch/m68k/mac/iop.c
--- linux-post-2.6.3-20040222/arch/m68k/mac/iop.c	2003-05-06 13:50:49.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/mac/iop.c	2004-02-23 05:24:09.000000000 +0000
@@ -87,7 +87,7 @@
  * or more messages on the receive channels have gone to the MSG_NEW state.
  *
  * Since each channel handles only one message we have to implement a small
- * interrupt-driven queue on our end. Messages to e sent are placed on the
+ * interrupt-driven queue on our end. Messages to be sent are placed on the
  * queue for sending and contain a pointer to an optional callback function.
  * The handler for a message is called when the message state goes to
  * MSG_COMPLETE.
diff -purN linux-post-2.6.3-20040222/arch/m68k/math-emu/fp_emu.h linux-post-2.6.3-20040223/arch/m68k/math-emu/fp_emu.h
--- linux-post-2.6.3-20040222/arch/m68k/math-emu/fp_emu.h	2003-07-23 22:15:29.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/math-emu/fp_emu.h	2004-02-23 05:24:04.000000000 +0000
@@ -39,7 +39,7 @@
 #define _FP_EMU_H
 
 #ifdef __ASSEMBLY__
-#include "../kernel/m68k_defs.h"
+#include <asm/offsets.h>
 #endif
 #include <asm/math-emu.h>
 
diff -purN linux-post-2.6.3-20040222/arch/m68k/mm/Makefile linux-post-2.6.3-20040223/arch/m68k/mm/Makefile
--- linux-post-2.6.3-20040222/arch/m68k/mm/Makefile	2004-01-18 11:36:54.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/mm/Makefile	2004-02-23 05:24:07.000000000 +0000
@@ -4,8 +4,5 @@
 
 obj-y		:= init.o fault.o hwtest.o
 
-ifndef CONFIG_SUN3
-obj-y		+= kmap.o memory.o motorola.o
-else
-obj-y		+= sun3kmap.o sun3mmu.o
-endif
+obj-$(CONFIG_MMU_MOTOROLA)	+= kmap.o memory.o motorola.o
+obj-$(CONFIG_MMU_SUN3)		+= sun3kmap.o sun3mmu.o
diff -purN linux-post-2.6.3-20040222/arch/m68k/mm/init.c linux-post-2.6.3-20040223/arch/m68k/mm/init.c
--- linux-post-2.6.3-20040222/arch/m68k/mm/init.c	2003-05-02 17:20:35.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/mm/init.c	2004-02-23 05:24:04.000000000 +0000
@@ -82,7 +82,9 @@ void __init mem_init(void)
 	int datapages = 0;
 	int initpages = 0;
 	unsigned long tmp;
+#ifndef CONFIG_SUN3
 	int i;
+#endif
 
 	max_mapnr = num_physpages = (((unsigned long)high_memory - PAGE_OFFSET) >> PAGE_SHIFT);
 
diff -purN linux-post-2.6.3-20040222/arch/m68k/sun3/config.c linux-post-2.6.3-20040223/arch/m68k/sun3/config.c
--- linux-post-2.6.3-20040222/arch/m68k/sun3/config.c	2003-09-01 13:50:04.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/m68k/sun3/config.c	2004-02-23 05:24:04.000000000 +0000
@@ -160,7 +160,7 @@ void __init config_sun3(void)
 	mach_hwclk           =  sun3_hwclk;
 	mach_halt	     =  sun3_halt;
 	mach_get_hardware_list = sun3_get_hardware_list;
-#if !defined(CONFIG_SERIAL_CONSOLE) && defined(CONFIG_DUMMY_CONSOLE)
+#if defined(CONFIG_DUMMY_CONSOLE)
 	conswitchp 	     = &dummy_con;
 #endif
 
diff -purN linux-post-2.6.3-20040222/arch/x86_64/kernel/head.S linux-post-2.6.3-20040223/arch/x86_64/kernel/head.S
--- linux-post-2.6.3-20040222/arch/x86_64/kernel/head.S	2004-02-18 02:14:37.000000000 +0000
+++ linux-post-2.6.3-20040223/arch/x86_64/kernel/head.S	2004-02-23 05:24:12.000000000 +0000
@@ -358,7 +358,7 @@ gdt_end:	
 	/* asm/segment.h:GDT_ENTRIES must match this */	
 	/* This should be a multiple of the cache line size */
 	/* GDTs of other CPUs: */	
-	.fill (L1_CACHE_BYTES * NR_CPUS) - (gdt_end - cpu_gdt_table) 
+	.fill (GDT_SIZE * NR_CPUS) - (gdt_end - cpu_gdt_table)
 
 	.align  L1_CACHE_BYTES
 ENTRY(idt_table)	
diff -purN linux-post-2.6.3-20040222/drivers/base/power/runtime.c linux-post-2.6.3-20040223/drivers/base/power/runtime.c
--- linux-post-2.6.3-20040222/drivers/base/power/runtime.c	2003-08-20 06:23:32.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/base/power/runtime.c	2004-02-23 05:24:16.000000000 +0000
@@ -51,7 +51,7 @@ int dpm_runtime_suspend(struct device * 
 		goto Done;
 
 	if (dev->power.power_state)
-		dpm_runtime_resume(dev);
+		runtime_resume(dev);
 
 	if (!(error = suspend_device(dev,state)))
 		dev->power.power_state = state;
diff -purN linux-post-2.6.3-20040222/drivers/block/Kconfig linux-post-2.6.3-20040223/drivers/block/Kconfig
--- linux-post-2.6.3-20040222/drivers/block/Kconfig	2004-01-19 06:35:36.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/block/Kconfig	2004-02-23 05:24:10.000000000 +0000
@@ -235,10 +235,13 @@ config BLK_DEV_LOOP
 	  bits of, say, a sound file). This is also safe if the file resides
 	  on a remote file server.
 
-	  There are several ways of doing this. Some of these require kernel
-	  patches. The vanilla kernel offers the cryptoloop option. If you
-	  want to use that, say Y to both LOOP and CRYPTOLOOP, and make sure
-	  you have a recent (version 2.12 or later) version of util-linux.
+	  There are several ways of encrypting disks. Some of these require
+	  kernel patches. The vanilla kernel offers the cryptoloop option
+	  and a Device Mapper target (which is superior, as it supports all
+	  file systems). If you want to use the cryptoloop, say Y to both
+	  LOOP and CRYPTOLOOP, and make sure you have a recent (version 2.12
+	  or later) version of util-linux. Additionally, be aware that
+	  the cryptoloop is not safe for storing journaled filesystems.
 
 	  Note that this loop device has nothing to do with the loopback
 	  device used for network connections from the machine to itself.
@@ -257,6 +260,11 @@ config BLK_DEV_CRYPTOLOOP
 	  provided by the CryptoAPI as loop transformation. This might be
 	  used as hard disk encryption.
 
+	  WARNING: This device is not safe for journaled file systems like
+	  ext3 or Reiserfs. Please use the Device Mapper crypto module
+	  instead, which can be configured to be on-disk compatible with the
+	  cryptoloop device.
+
 config BLK_DEV_NBD
 	tristate "Network block device support"
 	depends on NET
diff -purN linux-post-2.6.3-20040222/drivers/block/nbd.c linux-post-2.6.3-20040223/drivers/block/nbd.c
--- linux-post-2.6.3-20040222/drivers/block/nbd.c	2004-02-19 03:43:04.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/block/nbd.c	2004-02-23 05:24:11.000000000 +0000
@@ -36,7 +36,7 @@
  * 03-06-24 Remove unneeded blksize_bits field from nbd_device struct.
  *   <ldl@aros.net>
  * 03-06-24 Cleanup PARANOIA usage & code. <ldl@aros.net>
- *
+ * 04-02-19 Remove PARANOIA, plus various cleanups (Paul Clements)
  * possible FIXME: make set_sock / set_blksize / set_size / do_it one syscall
  * why not: would need verify_area and friends, would share yet another 
  *          structure with userland
@@ -61,12 +61,9 @@
 #include <asm/uaccess.h>
 #include <asm/types.h>
 
-/* Define PARANOIA in linux/nbd.h to turn on extra sanity checking */
 #include <linux/nbd.h>
 
-#ifdef PARANOIA
 #define LO_MAGIC 0x68797548
-#endif
 
 #ifdef NDEBUG
 #define dprintk(flags, fmt...)
@@ -97,11 +94,6 @@ static struct nbd_device nbd_dev[MAX_NBD
  */
 static spinlock_t nbd_lock = SPIN_LOCK_UNLOCKED;
 
-#ifdef PARANOIA
-static int requests_in;
-static int requests_out;
-#endif
-
 #ifndef NDEBUG
 static const char *ioctl_cmd_to_ascii(int cmd)
 {
@@ -153,9 +145,6 @@ static void nbd_end_request(struct reque
 	}
 	spin_unlock(&lo->queue_lock);
 
-#ifdef PARANOIA
-	requests_out++;
-#endif
 	spin_lock_irqsave(q->queue_lock, flags);
 	if (!end_that_request_first(req, uptodate, req->nr_sectors)) {
 		end_that_request_last(req);
@@ -217,10 +206,8 @@ static int sock_xmit(struct socket *sock
 		}
 
 		if (result <= 0) {
-#ifdef PARANOIA
-			printk(KERN_ERR "nbd: %s - sock=%p at buf=%p, size=%d returned %d.\n",
-			       send? "send": "receive", sock, buf, size, result);
-#endif
+			if (result == 0)
+				result = -EPIPE; /* short read */
 			break;
 		}
 		size -= result;
@@ -309,7 +296,7 @@ void nbd_send_req(struct nbd_device *lo,
 	up(&lo->tx_lock);
 	return;
 
-      error_out:
+error_out:
 	up(&lo->tx_lock);
 	req->errors++;
 }
@@ -358,23 +345,22 @@ struct request *nbd_read_stat(struct nbd
 	if (result <= 0) {
 		printk(KERN_ERR "%s: Receive control failed (result %d)\n",
 				lo->disk->disk_name, result);
-		lo->harderror = result;
-		return NULL;
+		goto harderror;
 	}
 	req = nbd_find_request(lo, reply.handle);
 	if (req == NULL) {
 		printk(KERN_ERR "%s: Unexpected reply (%p)\n",
 				lo->disk->disk_name, reply.handle);
-		lo->harderror = result;
-		return NULL;
+		result = -EBADR;
+		goto harderror;
 	}
 
 	if (ntohl(reply.magic) != NBD_REPLY_MAGIC) {
 		printk(KERN_ERR "%s: Wrong magic (0x%lx)\n",
 				lo->disk->disk_name,
 				(unsigned long)ntohl(reply.magic));
-		lo->harderror = result;
-		return NULL;
+		result = -EPROTO;
+		goto harderror;
 	}
 	if (ntohl(reply.error)) {
 		printk(KERN_ERR "%s: Other side returned error (%d)\n",
@@ -396,8 +382,7 @@ struct request *nbd_read_stat(struct nbd
 					printk(KERN_ERR "%s: Receive data failed (result %d)\n",
 							lo->disk->disk_name,
 							result);
-					lo->harderror = result;
-					return NULL;
+					goto harderror;
 				}
 				dprintk(DBG_RX, "%s: request %p: got %d bytes data\n",
 					lo->disk->disk_name, req, bvec->bv_len);
@@ -405,19 +390,19 @@ struct request *nbd_read_stat(struct nbd
 		}
 	}
 	return req;
+harderror:
+	lo->harderror = result;
+	return NULL;
 }
 
 void nbd_do_it(struct nbd_device *lo)
 {
 	struct request *req;
 
-#ifdef PARANOIA
 	BUG_ON(lo->magic != LO_MAGIC);
-#endif
+
 	while ((req = nbd_read_stat(lo)) != NULL)
 		nbd_end_request(req);
-	printk(KERN_NOTICE "%s: req should never be null\n",
-			lo->disk->disk_name);
 	return;
 }
 
@@ -425,9 +410,7 @@ void nbd_clear_que(struct nbd_device *lo
 {
 	struct request *req;
 
-#ifdef PARANOIA
 	BUG_ON(lo->magic != LO_MAGIC);
-#endif
 
 	do {
 		req = NULL;
@@ -466,9 +449,9 @@ static void do_nbd_request(request_queue
 			goto error_out;
 
 		lo = req->rq_disk->private_data;
-#ifdef PARANOIA
+
 		BUG_ON(lo->magic != LO_MAGIC);
-#endif
+
 		if (!lo->file) {
 			printk(KERN_ERR "%s: Request when not-ready\n",
 					lo->disk->disk_name);
@@ -483,9 +466,6 @@ static void do_nbd_request(request_queue
 				goto error_out;
 			}
 		}
-#ifdef PARANOIA
-		requests_in++;
-#endif
 
 		req->errors = 0;
 		spin_unlock_irq(q->queue_lock);
@@ -526,7 +506,7 @@ static void do_nbd_request(request_queue
 		spin_lock_irq(q->queue_lock);
 		continue;
 
-	      error_out:
+error_out:
 		req->errors++;
 		spin_unlock(q->queue_lock);
 		nbd_end_request(req);
@@ -544,9 +524,9 @@ static int nbd_ioctl(struct inode *inode
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
-#ifdef PARANOIA
+
 	BUG_ON(lo->magic != LO_MAGIC);
-#endif
+
 	/* Anyone capable of this syscall can do *real bad* things */
 	dprintk(DBG_IOCTL, "%s: nbd_ioctl cmd=%s(0x%x) arg=%lu\n",
 			lo->disk->disk_name, ioctl_cmd_to_ascii(cmd), cmd, arg);
@@ -662,15 +642,10 @@ static int nbd_ioctl(struct inode *inode
 		nbd_clear_que(lo);
 		return 0;
 	case NBD_PRINT_DEBUG:
-#ifdef PARANOIA
-		printk(KERN_INFO "%s: next = %p, prev = %p. Global: in %d, out %d\n",
-			inode->i_bdev->bd_disk->disk_name, lo->queue_head.next,
-			lo->queue_head.prev, requests_in, requests_out);
-#else
-		printk(KERN_INFO "%s: next = %p, prev = %p\n",
+		printk(KERN_INFO "%s: next = %p, prev = %p, head = %p\n",
 			inode->i_bdev->bd_disk->disk_name,
-			lo->queue_head.next, lo->queue_head.prev);
-#endif
+			lo->queue_head.next, lo->queue_head.prev,
+			&lo->queue_head);
 		return 0;
 	}
 	return -EINVAL;
@@ -692,12 +667,10 @@ static int __init nbd_init(void)
 	int err = -ENOMEM;
 	int i;
 
-#ifdef PARANOIA
 	if (sizeof(struct nbd_request) != 28) {
-		printk(KERN_CRIT "nbd: Sizeof nbd_request needs to be 28 in order to work!\n" );
+		printk(KERN_CRIT "nbd: sizeof nbd_request needs to be 28 in order to work!\n" );
 		return -EIO;
 	}
-#endif
 
 	for (i = 0; i < MAX_NBD; i++) {
 		struct gendisk *disk = alloc_disk(1);
@@ -728,15 +701,13 @@ static int __init nbd_init(void)
 	for (i = 0; i < MAX_NBD; i++) {
 		struct gendisk *disk = nbd_dev[i].disk;
 		nbd_dev[i].file = NULL;
-#ifdef PARANOIA
 		nbd_dev[i].magic = LO_MAGIC;
-#endif
 		nbd_dev[i].flags = 0;
 		spin_lock_init(&nbd_dev[i].queue_lock);
 		INIT_LIST_HEAD(&nbd_dev[i].queue_head);
 		init_MUTEX(&nbd_dev[i].tx_lock);
 		nbd_dev[i].blksize = 1024;
-		nbd_dev[i].bytesize = ((u64)0x7ffffc00) << 10; /* 2TB */
+		nbd_dev[i].bytesize = 0x7ffffc00ULL << 10; /* 2TB */
 		disk->major = NBD_MAJOR;
 		disk->first_minor = i;
 		disk->fops = &nbd_fops;
@@ -744,15 +715,14 @@ static int __init nbd_init(void)
 		disk->flags |= GENHD_FL_SUPPRESS_PARTITION_INFO;
 		sprintf(disk->disk_name, "nbd%d", i);
 		sprintf(disk->devfs_name, "nbd/%d", i);
-		set_capacity(disk, 0x3ffffe);
+		set_capacity(disk, 0x7ffffc00ULL << 1); /* 2 TB */
 		add_disk(disk);
 	}
 
 	return 0;
 out:
 	while (i--) {
-		if (nbd_dev[i].disk->queue)
-			blk_cleanup_queue(nbd_dev[i].disk->queue);
+		blk_cleanup_queue(nbd_dev[i].disk->queue);
 		put_disk(nbd_dev[i].disk);
 	}
 	return err;
@@ -764,9 +734,8 @@ static void __exit nbd_cleanup(void)
 	for (i = 0; i < MAX_NBD; i++) {
 		struct gendisk *disk = nbd_dev[i].disk;
 		if (disk) {
-			if (disk->queue)
-				blk_cleanup_queue(disk->queue);
 			del_gendisk(disk);
+			blk_cleanup_queue(disk->queue);
 			put_disk(disk);
 		}
 	}
diff -purN linux-post-2.6.3-20040222/drivers/char/Kconfig linux-post-2.6.3-20040223/drivers/char/Kconfig
--- linux-post-2.6.3-20040222/drivers/char/Kconfig	2004-02-19 03:42:35.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/Kconfig	2004-02-23 05:24:06.000000000 +0000
@@ -445,7 +445,8 @@ config A2232
 source "drivers/serial/Kconfig"
 
 config UNIX98_PTYS
-	bool "Unix98 PTY support"
+	bool "Unix98 PTY support" if EMBEDDED
+	default y
 	---help---
 	  A pseudo terminal (PTY) is a software device consisting of two
 	  halves: a master and a slave. The slave device behaves identical to
@@ -463,28 +464,38 @@ config UNIX98_PTYS
 	  terminal slave can be accessed as /dev/pts/<number>. What was
 	  traditionally /dev/ttyp2 will then be /dev/pts/2, for example.
 
-	  The entries in /dev/pts/ are created on the fly by a virtual
-	  file system; therefore, if you say Y here you should say Y to
-	  "/dev/pts file system for Unix98 PTYs" as well.
-
-	  If you want to say Y here, you need to have the C library glibc 2.1
-	  or later (equal to libc-6.1, check with "ls -l /lib/libc.so.*").
-	  Read the instructions in <file:Documentation/Changes> pertaining to
-	  pseudo terminals. It's safe to say N.
-
-config UNIX98_PTY_COUNT
-	int "Maximum number of Unix98 PTYs in use (0-2048)"
-	depends on UNIX98_PTYS
+	  All modern Linux systems use the Unix98 ptys.  Say Y unless
+	  you're on an embedded system and want to conserve memory.
+
+config LEGACY_PTYS
+	bool "Legacy (BSD) PTY support"
+	default y
+	---help---
+	  A pseudo terminal (PTY) is a software device consisting of two
+	  halves: a master and a slave. The slave device behaves identical to
+	  a physical terminal; the master device is used by a process to
+	  read data from and write data to the slave, thereby emulating a
+	  terminal. Typical programs for the master side are telnet servers
+	  and xterms.
+
+	  Linux has traditionally used the BSD-like names /dev/ptyxx
+	  for masters and /dev/ttyxx for slaves of pseudo
+	  terminals. This scheme has a number of problems, including
+	  security.  This option enables these legacy devices; on most
+	  systems, it is safe to say N.
+
+
+config LEGACY_PTY_COUNT
+	int "Maximum number of legacy PTY in use"
+	depends on LEGACY_PTYS
 	default "256"
-	help
-	  The maximum number of Unix98 PTYs that can be used at any one time.
-	  The default is 256, and should be enough for desktop systems. Server
-	  machines which support incoming telnet/rlogin/ssh connections and/or
-	  serve several X terminals may want to increase this: every incoming
-	  connection and every xterm uses up one PTY.
+	---help---
+	  The maximum number of legacy PTYs that can be used at any one time.
+	  The default is 256, and should be more than enough.  Embedded
+	  systems may want to reduce this to save memory.
 
-	  When not in use, each additional set of 256 PTYs occupy
-	  approximately 8 KB of kernel memory on 32-bit architectures.
+	  When not in use, each legacy PTY occupies 12 bytes on 32-bit
+	  architectures and 24 bytes on 64-bit architectures.
 
 config PRINTER
 	tristate "Parallel printer support"
@@ -754,7 +765,7 @@ config NVRAM
 
 config RTC
 	tristate "Enhanced Real Time Clock Support"
-	depends on !PPC32 && !PARISC && !IA64 && !X86_PC9800
+	depends on !PPC32 && !PARISC && !IA64 && !X86_PC9800 && !M68K
 	---help---
 	  If you say Y here and create a character special file /dev/rtc with
 	  major number 10 and minor number 135 using mknod ("man mknod"), you
diff -purN linux-post-2.6.3-20040222/drivers/char/agp/Kconfig linux-post-2.6.3-20040223/drivers/char/agp/Kconfig
--- linux-post-2.6.3-20040222/drivers/char/agp/Kconfig	2004-02-19 00:02:05.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/agp/Kconfig	2004-02-23 05:24:06.000000000 +0000
@@ -1,5 +1,5 @@
 config AGP
-	tristate "/dev/agpgart (AGP Support)" if !GART_IOMMU
+	tristate "/dev/agpgart (AGP Support)" if !GART_IOMMU && !M68K
 	default y if GART_IOMMU
 	---help---
 	  AGP (Accelerated Graphics Port) is a bus system mainly used to
diff -purN linux-post-2.6.3-20040222/drivers/char/agp/intel-agp.c linux-post-2.6.3-20040223/drivers/char/agp/intel-agp.c
--- linux-post-2.6.3-20040222/drivers/char/agp/intel-agp.c	2003-11-21 12:38:07.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/agp/intel-agp.c	2004-02-23 03:10:09.000000000 +0000
@@ -1432,6 +1432,8 @@ static int agp_intel_resume(struct pci_d
 		intel_configure();
 	else if (bridge->driver == &intel_845_driver)
 		intel_845_configure();
+	else if (bridge->driver == &intel_830mp_driver)
+		intel_830mp_configure();
 
 	return 0;
 }
diff -purN linux-post-2.6.3-20040222/drivers/char/amiserial.c linux-post-2.6.3-20040223/drivers/char/amiserial.c
--- linux-post-2.6.3-20040222/drivers/char/amiserial.c	2003-09-30 00:23:52.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/amiserial.c	2004-02-23 03:09:24.000000000 +0000
@@ -1248,57 +1248,48 @@ static int get_lsr_info(struct async_str
 }
 
 
-static int get_modem_info(struct async_struct * info, unsigned int *value)
+static int rs_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
 	unsigned char control, status;
-	unsigned int result;
 	unsigned long flags;
 
+	if (serial_paranoia_check(info, tty->name, "rs_ioctl"))
+		return -ENODEV;
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
+
 	control = info->MCR;
 	local_irq_save(flags);
 	status = ciab.pra;
 	local_irq_restore(flags);
-	result =  ((control & SER_RTS) ? TIOCM_RTS : 0)
+	return    ((control & SER_RTS) ? TIOCM_RTS : 0)
 		| ((control & SER_DTR) ? TIOCM_DTR : 0)
 		| (!(status  & SER_DCD) ? TIOCM_CAR : 0)
 		| (!(status  & SER_DSR) ? TIOCM_DSR : 0)
 		| (!(status  & SER_CTS) ? TIOCM_CTS : 0);
-	if (copy_to_user(value, &result, sizeof(int)))
-		return -EFAULT;
-	return 0;
 }
 
-static int set_modem_info(struct async_struct * info, unsigned int cmd,
-			  unsigned int *value)
+static int rs_tiocmset(struct tty_struct *tty, struct file *file,
+		       unsigned int set, unsigned int clear)
 {
-	unsigned int arg;
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
 	unsigned long flags;
 
-	if (copy_from_user(&arg, value, sizeof(int)))
-		return -EFAULT;
+	if (serial_paranoia_check(info, tty->name, "rs_ioctl"))
+		return -ENODEV;
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
 
-	switch (cmd) {
-	case TIOCMBIS: 
-	        if (arg & TIOCM_RTS)
-			info->MCR |= SER_RTS;
-		if (arg & TIOCM_DTR)
-			info->MCR |= SER_DTR;
-		break;
-	case TIOCMBIC:
-	        if (arg & TIOCM_RTS)
-			info->MCR &= ~SER_RTS;
-		if (arg & TIOCM_DTR)
-			info->MCR &= ~SER_DTR;
-		break;
-	case TIOCMSET:
-		info->MCR = ((info->MCR & ~(SER_RTS | SER_DTR))
-			     | ((arg & TIOCM_RTS) ? SER_RTS : 0)
-			     | ((arg & TIOCM_DTR) ? SER_DTR : 0));
-		break;
-	default:
-		return -EINVAL;
-	}
 	local_irq_save(flags);
+	if (set & TIOCM_RTS)
+		info->MCR |= SER_RTS;
+	if (set & TIOCM_DTR)
+		info->MCR |= SER_DTR;
+	if (clear & TIOCM_RTS)
+		info->MCR &= ~SER_RTS;
+	if (clear & TIOCM_DTR)
+		info->MCR &= ~SER_DTR;
 	rtsdtr_ctrl(info->MCR);
 	local_irq_restore(flags);
 	return 0;
@@ -1344,12 +1335,6 @@ static int rs_ioctl(struct tty_struct *t
 	}
 
 	switch (cmd) {
-		case TIOCMGET:
-			return get_modem_info(info, (unsigned int *) arg);
-		case TIOCMBIS:
-		case TIOCMBIC:
-		case TIOCMSET:
-			return set_modem_info(info, cmd, (unsigned int *) arg);
 		case TIOCGSERIAL:
 			return get_serial_info(info,
 					       (struct serial_struct *) arg);
@@ -2045,6 +2030,8 @@ static struct tty_operations serial_ops 
 	.send_xchar = rs_send_xchar,
 	.wait_until_sent = rs_wait_until_sent,
 	.read_proc = rs_read_proc,
+	.tiocmget = rs_tiocmget,
+	.tiocmset = rs_tiocmset,
 };
 
 /*
diff -purN linux-post-2.6.3-20040222/drivers/char/cyclades.c linux-post-2.6.3-20040223/drivers/char/cyclades.c
--- linux-post-2.6.3-20040222/drivers/char/cyclades.c	2003-09-30 00:34:28.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/cyclades.c	2004-02-23 03:08:27.000000000 +0000
@@ -3632,8 +3632,9 @@ static int get_lsr_info(struct cyclades_
 }
 
 static int
-get_modem_info(struct cyclades_port * info, unsigned int *value)
+cy_tiocmget(struct tty_struct *tty, struct file *file)
 {
+  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
   int card,chip,channel,index;
   unsigned char *base_addr;
   unsigned long flags;
@@ -3645,6 +3646,9 @@ get_modem_info(struct cyclades_port * in
   struct BOARD_CTRL *board_ctrl;
   struct CH_CTRL *ch_ctrl;
 
+    if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+	return -ENODEV;
+
     card = info->card;
     channel = (info->line) - (cy_card[card].first_line);
     if (!IS_CYC_Z(cy_card[card])) {
@@ -3700,24 +3704,27 @@ get_modem_info(struct cyclades_port * in
 	}
 
     }
-    return cy_put_user(result, value);
-} /* get_modem_info */
+    return result;
+} /* cy_tiomget */
 
 
 static int
-set_modem_info(struct cyclades_port * info, unsigned int cmd,
-                          unsigned int *value)
+cy_tiocmset(struct tty_struct *tty, struct file *file,
+            unsigned int set, unsigned int clear)
 {
+  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
   int card,chip,channel,index;
   unsigned char *base_addr;
   unsigned long flags;
-  unsigned int arg = cy_get_user((unsigned long *) value);
   struct FIRM_ID *firm_id;
   struct ZFW_CTRL *zfw_ctrl;
   struct BOARD_CTRL *board_ctrl;
   struct CH_CTRL *ch_ctrl;
   int retval;
 
+    if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+	return -ENODEV;
+
     card = info->card;
     channel = (info->line) - (cy_card[card].first_line);
     if (!IS_CYC_Z(cy_card[card])) {
@@ -3728,66 +3735,7 @@ set_modem_info(struct cyclades_port * in
 		       (cy_card[card].base_addr
 		       + (cy_chip_offset[chip]<<index));
 
-	switch (cmd) {
-	case TIOCMBIS:
-	    if (arg & TIOCM_RTS){
-		CY_LOCK(info, flags);
-		cy_writeb((u_long)base_addr+(CyCAR<<index), (u_char)channel);
-                if (info->rtsdtr_inv) {
-		    cy_writeb((u_long)base_addr+(CyMSVR2<<index), CyDTR);
-                } else {
-		    cy_writeb((u_long)base_addr+(CyMSVR1<<index), CyRTS);
-                }
-		CY_UNLOCK(info, flags);
-	    }
-	    if (arg & TIOCM_DTR){
-		CY_LOCK(info, flags);
-		cy_writeb((u_long)base_addr+(CyCAR<<index), (u_char)channel);
-                if (info->rtsdtr_inv) {
-		    cy_writeb((u_long)base_addr+(CyMSVR1<<index), CyRTS);
-                } else {
-		    cy_writeb((u_long)base_addr+(CyMSVR2<<index), CyDTR);
-                }
-#ifdef CY_DEBUG_DTR
-		printk("cyc:set_modem_info raising DTR\n");
-		printk("     status: 0x%x, 0x%x\n",
-		    cy_readb(base_addr+(CyMSVR1<<index)), 
-                    cy_readb(base_addr+(CyMSVR2<<index)));
-#endif
-		CY_UNLOCK(info, flags);
-	    }
-	    break;
-	case TIOCMBIC:
-	    if (arg & TIOCM_RTS){
-		CY_LOCK(info, flags);
-		cy_writeb((u_long)base_addr+(CyCAR<<index), 
-                          (u_char)channel);
-                if (info->rtsdtr_inv) {
-		    	cy_writeb((u_long)base_addr+(CyMSVR2<<index), ~CyDTR);
-                } else {
-		    	cy_writeb((u_long)base_addr+(CyMSVR1<<index), ~CyRTS);
-                }
-		CY_UNLOCK(info, flags);
-	    }
-	    if (arg & TIOCM_DTR){
-		CY_LOCK(info, flags);
-		cy_writeb((u_long)base_addr+(CyCAR<<index), (u_char)channel);
-                if (info->rtsdtr_inv) {
-			cy_writeb((u_long)base_addr+(CyMSVR1<<index), ~CyRTS);
-                } else {
-			cy_writeb((u_long)base_addr+(CyMSVR2<<index), ~CyDTR);
-                }
-#ifdef CY_DEBUG_DTR
-		printk("cyc:set_modem_info dropping DTR\n");
-		printk("     status: 0x%x, 0x%x\n",
-		    cy_readb(base_addr+(CyMSVR1<<index)), 
-                    cy_readb(base_addr+(CyMSVR2<<index)));
-#endif
-		CY_UNLOCK(info, flags);
-	    }
-	    break;
-	case TIOCMSET:
-	    if (arg & TIOCM_RTS){
+	if (set & TIOCM_RTS){
 		CY_LOCK(info, flags);
 	        cy_writeb((u_long)base_addr+(CyCAR<<index), (u_char)channel);
                 if (info->rtsdtr_inv) {
@@ -3796,7 +3744,8 @@ set_modem_info(struct cyclades_port * in
 			cy_writeb((u_long)base_addr+(CyMSVR1<<index), CyRTS);
                 }
 		CY_UNLOCK(info, flags);
-	    }else{
+	}
+	if (clear & TIOCM_RTS) {
 		CY_LOCK(info, flags);
 		cy_writeb((u_long)base_addr+(CyCAR<<index), (u_char)channel);
                 if (info->rtsdtr_inv) {
@@ -3805,8 +3754,8 @@ set_modem_info(struct cyclades_port * in
 			cy_writeb((u_long)base_addr+(CyMSVR1<<index), ~CyRTS);
                 }
 		CY_UNLOCK(info, flags);
-	    }
-	    if (arg & TIOCM_DTR){
+	}
+	if (set & TIOCM_DTR){
 		CY_LOCK(info, flags);
 		cy_writeb((u_long)base_addr+(CyCAR<<index), (u_char)channel);
                 if (info->rtsdtr_inv) {
@@ -3821,7 +3770,8 @@ set_modem_info(struct cyclades_port * in
                     cy_readb(base_addr+(CyMSVR2<<index)));
 #endif
 		CY_UNLOCK(info, flags);
-	    }else{
+	}
+	if (clear & TIOCM_DTR) {
 		CY_LOCK(info, flags);
 		cy_writeb((u_long)base_addr+(CyCAR<<index), (u_char)channel);
                 if (info->rtsdtr_inv) {
@@ -3837,10 +3787,6 @@ set_modem_info(struct cyclades_port * in
                     cy_readb(base_addr+(CyMSVR2<<index)));
 #endif
 		CY_UNLOCK(info, flags);
-	    }
-	    break;
-	default:
-	    return -EINVAL;
 	}
     } else {
 	base_addr = (unsigned char*) (cy_card[card].base_addr);
@@ -3854,54 +3800,19 @@ set_modem_info(struct cyclades_port * in
 	    board_ctrl = &zfw_ctrl->board_ctrl;
 	    ch_ctrl = zfw_ctrl->ch_ctrl;
 
-	    switch (cmd) {
-	    case TIOCMBIS:
-		if (arg & TIOCM_RTS){
-		    CY_LOCK(info, flags);
-		    cy_writel(&ch_ctrl[channel].rs_control,
-                       cy_readl(&ch_ctrl[channel].rs_control) | C_RS_RTS);
-		    CY_UNLOCK(info, flags);
-		}
-		if (arg & TIOCM_DTR){
-		    CY_LOCK(info, flags);
-		    cy_writel(&ch_ctrl[channel].rs_control,
-                       cy_readl(&ch_ctrl[channel].rs_control) | C_RS_DTR);
-#ifdef CY_DEBUG_DTR
-		    printk("cyc:set_modem_info raising Z DTR\n");
-#endif
-		    CY_UNLOCK(info, flags);
-		}
-		break;
-	    case TIOCMBIC:
-		if (arg & TIOCM_RTS){
-		    CY_LOCK(info, flags);
-		    cy_writel(&ch_ctrl[channel].rs_control,
-                       cy_readl(&ch_ctrl[channel].rs_control) & ~C_RS_RTS);
-		    CY_UNLOCK(info, flags);
-		}
-		if (arg & TIOCM_DTR){
-		    CY_LOCK(info, flags);
-		    cy_writel(&ch_ctrl[channel].rs_control,
-                       cy_readl(&ch_ctrl[channel].rs_control) & ~C_RS_DTR);
-#ifdef CY_DEBUG_DTR
-		    printk("cyc:set_modem_info clearing Z DTR\n");
-#endif
-		    CY_UNLOCK(info, flags);
-		}
-		break;
-	    case TIOCMSET:
-		if (arg & TIOCM_RTS){
+	    if (set & TIOCM_RTS){
 		    CY_LOCK(info, flags);
 		    cy_writel(&ch_ctrl[channel].rs_control,
                        cy_readl(&ch_ctrl[channel].rs_control) | C_RS_RTS);
 		    CY_UNLOCK(info, flags);
-		}else{
+	    }
+	    if (clear & TIOCM_RTS) {
 		    CY_LOCK(info, flags);
 		    cy_writel(&ch_ctrl[channel].rs_control,
                        cy_readl(&ch_ctrl[channel].rs_control) & ~C_RS_RTS);
 		    CY_UNLOCK(info, flags);
-		}
-		if (arg & TIOCM_DTR){
+	    }
+	    if (set & TIOCM_DTR){
 		    CY_LOCK(info, flags);
 		    cy_writel(&ch_ctrl[channel].rs_control,
                        cy_readl(&ch_ctrl[channel].rs_control) | C_RS_DTR);
@@ -3909,7 +3820,8 @@ set_modem_info(struct cyclades_port * in
 		    printk("cyc:set_modem_info raising Z DTR\n");
 #endif
 		    CY_UNLOCK(info, flags);
-		}else{
+	    }
+	    if (clear & TIOCM_DTR) {
 		    CY_LOCK(info, flags);
 		    cy_writel(&ch_ctrl[channel].rs_control,
                        cy_readl(&ch_ctrl[channel].rs_control) & ~C_RS_DTR);
@@ -3917,10 +3829,6 @@ set_modem_info(struct cyclades_port * in
 		    printk("cyc:set_modem_info clearing Z DTR\n");
 #endif
 		    CY_UNLOCK(info, flags);
-		}
-		break;
-	    default:
-		return -EINVAL;
 	    }
 	}else{
 	    return -ENODEV;
@@ -3935,7 +3843,7 @@ set_modem_info(struct cyclades_port * in
 	CY_UNLOCK(info, flags);
     }
     return 0;
-} /* set_modem_info */
+} /* cy_tiocmset */
 
 /*
  * cy_break() --- routine which turns the break handling on or off
@@ -4242,14 +4150,6 @@ cy_ioctl(struct tty_struct *tty, struct 
 	case CYGETWAIT:
 	    ret_val = info->closing_wait / (HZ/100);
 	    break;
-        case TIOCMGET:
-            ret_val = get_modem_info(info, (unsigned int *) arg);
-            break;
-        case TIOCMBIS:
-        case TIOCMBIC:
-        case TIOCMSET:
-            ret_val = set_modem_info(info, cmd, (unsigned int *) arg);
-            break;
         case TIOCGSERIAL:
             ret_val = get_serial_info(info, (struct serial_struct *) arg);
             break;
@@ -5429,6 +5329,8 @@ static struct tty_operations cy_ops = {
     .break_ctl = cy_break,
     .wait_until_sent = cy_wait_until_sent,
     .read_proc = cyclades_get_proc_info,
+    .tiocmget = cy_tiocmget,
+    .tiocmset = cy_tiocmset,
 };
 
 static int __init
diff -purN linux-post-2.6.3-20040222/drivers/char/epca.c linux-post-2.6.3-20040223/drivers/char/epca.c
--- linux-post-2.6.3-20040222/drivers/char/epca.c	2003-09-11 22:46:11.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/epca.c	2004-02-23 03:09:24.000000000 +0000
@@ -2931,6 +2931,96 @@ static int info_ioctl(struct tty_struct 
 }
 /* --------------------- Begin pc_ioctl  ----------------------- */
 
+static int pc_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct channel *ch = (struct channel *) tty->driver_data;
+	volatile struct board_chan *bc;
+	unsigned int mstat, mflag = 0;
+	unsigned long flags;
+
+	if (ch)
+		bc = ch->brdchan;
+	else
+	{
+		printk(KERN_ERR "<Error> - ch is NULL in pc_tiocmget!\n");
+		return(-EINVAL);
+	}
+
+	save_flags(flags);
+	cli();
+	globalwinon(ch);
+	mstat = bc->mstat;
+	memoff(ch);
+	restore_flags(flags);
+
+	if (mstat & ch->m_dtr)
+		mflag |= TIOCM_DTR;
+
+	if (mstat & ch->m_rts)
+		mflag |= TIOCM_RTS;
+
+	if (mstat & ch->m_cts)
+		mflag |= TIOCM_CTS;
+
+	if (mstat & ch->dsr)
+		mflag |= TIOCM_DSR;
+
+	if (mstat & ch->m_ri)
+		mflag |= TIOCM_RI;
+
+	if (mstat & ch->dcd)
+		mflag |= TIOCM_CD;
+
+	return mflag;
+}
+
+static int pc_tiocmset(struct tty_struct *tty, struct file *file,
+		       unsigned int set, unsigned int clear)
+{
+	struct channel *ch = (struct channel *) tty->driver_data;
+	unsigned long flags;
+
+	if (!ch) {
+		printk(KERN_ERR "<Error> - ch is NULL in pc_tiocmset!\n");
+		return(-EINVAL);
+	}
+
+	save_flags(flags);
+	cli();
+	/*
+	 * I think this modemfake stuff is broken.  It doesn't
+	 * correctly reflect the behaviour desired by the TIOCM*
+	 * ioctls.  Therefore this is probably broken.
+	 */
+	if (set & TIOCM_RTS) {
+		ch->modemfake |= ch->m_rts;
+		ch->modem |= ch->m_rts;
+	}
+	if (set & TIOCM_DTR) {
+		ch->modemfake |= ch->m_dtr;
+		ch->modem |= ch->m_dtr;
+	}
+	if (clear & TIOCM_RTS) {
+		ch->modemfake |= ch->m_rts;
+		ch->modem &= ~ch->m_rts;
+	}
+	if (clear & TIOCM_DTR) {
+		ch->modemfake |= ch->m_dtr;
+		ch->modem &= ~ch->m_dtr;
+	}
+
+	globalwinon(ch);
+
+	/*  --------------------------------------------------------------
+		The below routine generally sets up parity, baud, flow control
+		issues, etc.... It effect both control flags and input flags.
+	------------------------------------------------------------------ */
+
+	epcaparam(tty,ch);
+	memoff(ch);
+	restore_flags(flags);
+}
+
 static int pc_ioctl(struct tty_struct *tty, struct file * file,
 		    unsigned int cmd, unsigned long arg)
 { /* Begin pc_ioctl */
@@ -3021,90 +3111,15 @@ static int pc_ioctl(struct tty_struct *t
 		}
 
 		case TIOCMODG:
-		case TIOCMGET:
-
-			mflag = 0;
-
-			cli();
-			globalwinon(ch);
-			mstat = bc->mstat;
-			memoff(ch);
-			restore_flags(flags);
-
-			if (mstat & ch->m_dtr)
-				mflag |= TIOCM_DTR;
-
-			if (mstat & ch->m_rts)
-				mflag |= TIOCM_RTS;
-
-			if (mstat & ch->m_cts)
-				mflag |= TIOCM_CTS;
-
-			if (mstat & ch->dsr)
-				mflag |= TIOCM_DSR;
-
-			if (mstat & ch->m_ri)
-				mflag |= TIOCM_RI;
-
-			if (mstat & ch->dcd)
-				mflag |= TIOCM_CD;
-
-			error = verify_area(VERIFY_WRITE, (void *) arg,sizeof(long));
-
-			if (error)
-				return error;
-
-			putUser(mflag, (unsigned int *) arg);
-
+			mflag = pc_tiocmget(tty, file);
+			if (putUser(mflag, (unsigned int *) arg))
+				return -EFAULT;
 			break;
 
-		case TIOCMBIS:
-		case TIOCMBIC:
 		case TIOCMODS:
-		case TIOCMSET:
-
-			getUser(mstat, (unsigned int *)arg);
-
-			mflag = 0;
-			if (mstat & TIOCM_DTR)
-				mflag |= ch->m_dtr;
-
-			if (mstat & TIOCM_RTS)
-				mflag |= ch->m_rts;
-
-			switch (cmd) 
-			{ /* Begin switch cmd */
-
-				case TIOCMODS:
-				case TIOCMSET:
-					ch->modemfake = ch->m_dtr|ch->m_rts;
-					ch->modem = mflag;
-					break;
-
-				case TIOCMBIS:
-					ch->modemfake |= mflag;
-					ch->modem |= mflag;
-					break;
-
-				case TIOCMBIC:
-					ch->modemfake |= mflag;
-					ch->modem &= ~mflag;
-					break;
-
-			} /* End switch cmd */
-
-			cli();
-			globalwinon(ch);
-
-			/*  --------------------------------------------------------------
-				The below routine generally sets up parity, baud, flow control 
-				issues, etc.... It effect both control flags and input flags.
-			------------------------------------------------------------------ */
-
-			epcaparam(tty,ch);
-			memoff(ch);
-			restore_flags(flags);
-			break;
+			if (getUser(mstat, (unsigned int *)arg))
+				return -EFAULT;
+			return pc_tiocmset(tty, file, mstat, ~mstat);
 
 		case TIOCSDTR:
 			ch->omodem |= ch->m_dtr;
diff -purN linux-post-2.6.3-20040222/drivers/char/esp.c linux-post-2.6.3-20040223/drivers/char/esp.c
--- linux-post-2.6.3-20040222/drivers/char/esp.c	2003-10-05 06:51:01.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/esp.c	2004-02-23 03:09:24.000000000 +0000
@@ -1753,55 +1753,52 @@ static int get_lsr_info(struct esp_struc
 }
 
 
-static int get_modem_info(struct esp_struct * info, unsigned int *value)
+static int esp_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct esp_struct * info = (struct esp_struct *)tty->driver_data;
 	unsigned char control, status;
-	unsigned int result;
+
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
 
 	control = info->MCR;
 	cli();
 	serial_out(info, UART_ESI_CMD1, ESI_GET_UART_STAT);
 	status = serial_in(info, UART_ESI_STAT2);
 	sti();
-	result =  ((control & UART_MCR_RTS) ? TIOCM_RTS : 0)
+	return    ((control & UART_MCR_RTS) ? TIOCM_RTS : 0)
 		| ((control & UART_MCR_DTR) ? TIOCM_DTR : 0)
 		| ((status  & UART_MSR_DCD) ? TIOCM_CAR : 0)
 		| ((status  & UART_MSR_RI) ? TIOCM_RNG : 0)
 		| ((status  & UART_MSR_DSR) ? TIOCM_DSR : 0)
 		| ((status  & UART_MSR_CTS) ? TIOCM_CTS : 0);
-	return put_user(result,value);
 }
 
-static int set_modem_info(struct esp_struct * info, unsigned int cmd,
-			  unsigned int *value)
+static int esp_tiocmset(struct tty_struct *tty, struct file *file,
+			unsigned int set, unsigned int clear)
 {
+	struct esp_struct * info = (struct esp_struct *)tty->driver_data;
 	unsigned int arg;
 
-	if (get_user(arg, value))
-		return -EFAULT;
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
 
-	switch (cmd) {
-	case TIOCMBIS: 
-		if (arg & TIOCM_RTS)
-			info->MCR |= UART_MCR_RTS;
-		if (arg & TIOCM_DTR)
-			info->MCR |= UART_MCR_DTR;
-		break;
-	case TIOCMBIC:
-		if (arg & TIOCM_RTS)
-			info->MCR &= ~UART_MCR_RTS;
-		if (arg & TIOCM_DTR)
-			info->MCR &= ~UART_MCR_DTR;
-		break;
-	case TIOCMSET:
-		info->MCR = ((info->MCR & ~(UART_MCR_RTS | UART_MCR_DTR))
-			     | ((arg & TIOCM_RTS) ? UART_MCR_RTS : 0)
-			     | ((arg & TIOCM_DTR) ? UART_MCR_DTR : 0));
-		break;
-	default:
-		return -EINVAL;
-	}
 	cli();
+
+	if (set & TIOCM_RTS)
+		info->MCR |= UART_MCR_RTS;
+	if (set & TIOCM_DTR)
+		info->MCR |= UART_MCR_DTR;
+
+	if (clear & TIOCM_RTS)
+		info->MCR &= ~UART_MCR_RTS;
+	if (clear & TIOCM_DTR)
+		info->MCR &= ~UART_MCR_DTR;
+
 	serial_out(info, UART_ESI_CMD1, ESI_WRITE_UART);
 	serial_out(info, UART_ESI_CMD2, UART_MCR);
 	serial_out(info, UART_ESI_CMD2, info->MCR);
@@ -1853,12 +1850,6 @@ static int rs_ioctl(struct tty_struct *t
 	}
 	
 	switch (cmd) {
-		case TIOCMGET:
-			return get_modem_info(info, (unsigned int *) arg);
-		case TIOCMBIS:
-		case TIOCMBIC:
-		case TIOCMSET:
-			return set_modem_info(info, cmd, (unsigned int *) arg);
 		case TIOCGSERIAL:
 			return get_serial_info(info,
 					       (struct serial_struct *) arg);
@@ -2444,6 +2435,8 @@ static struct tty_operations esp_ops = {
 	.hangup = esp_hangup,
 	.break_ctl = esp_break,
 	.wait_until_sent = rs_wait_until_sent,
+	.tiocmget = esp_tiocmget,
+	.tiocmset = esp_tiocmset,
 };
 
 /*
diff -purN linux-post-2.6.3-20040222/drivers/char/ip2main.c linux-post-2.6.3-20040223/drivers/char/ip2main.c
--- linux-post-2.6.3-20040222/drivers/char/ip2main.c	2003-09-30 00:23:52.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/ip2main.c	2004-02-23 03:08:27.000000000 +0000
@@ -186,6 +186,9 @@ static void ip2_unthrottle(PTTY);
 static void ip2_stop(PTTY);
 static void ip2_start(PTTY);
 static void ip2_hangup(PTTY);
+static int  ip2_tiocmget(struct tty_struct *tty, struct file *file);
+static int  ip2_tiocmset(struct tty_struct *tty, struct file *file,
+			 unsigned int set, unsigned int clear);
 
 static void set_irq(int, int);
 static void ip2_interrupt_bh(i2eBordStrPtr pB);
@@ -466,6 +469,8 @@ static struct tty_operations ip2_ops = {
 	.start           = ip2_start,
 	.hangup          = ip2_hangup,
 	.read_proc       = ip2_read_proc,
+	.tiocmget	 = ip2_tiocmget,
+	.tiocmset	 = ip2_tiocmset,
 };
 
 /******************************************************************************/
@@ -1951,6 +1956,80 @@ ip2_stop ( PTTY tty )
 /* Device Ioctl Section                                                       */
 /******************************************************************************/
 
+static int ip2_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	i2ChanStrPtr pCh = DevTable[tty->index];
+	wait_queue_t wait;
+
+	if (pCh == NULL)
+		return -ENODEV;
+
+/*
+	FIXME - the following code is causing a NULL pointer dereference in
+	2.3.51 in an interrupt handler.  It's suppose to prompt the board
+	to return the DSS signal status immediately.  Why doesn't it do
+	the same thing in 2.2.14?
+*/
+
+/*	This thing is still busted in the 1.2.12 driver on 2.4.x
+	and even hoses the serial console so the oops can be trapped.
+		/\/\|=mhw=|\/\/			*/
+
+#ifdef	ENABLE_DSSNOW
+	i2QueueCommands(PTYPE_BYPASS, pCh, 100, 1, CMD_DSS_NOW);
+
+	init_waitqueue_entry(&wait, current);
+	add_wait_queue(&pCh->dss_now_wait, &wait);
+	set_current_state( TASK_INTERRUPTIBLE );
+
+	serviceOutgoingFifo( pCh->pMyBord );
+
+	schedule();
+
+	set_current_state( TASK_RUNNING );
+	remove_wait_queue(&pCh->dss_now_wait, &wait);
+
+	if (signal_pending(current)) {
+		return -EINTR;
+	}
+#endif
+	return  ((pCh->dataSetOut & I2_RTS) ? TIOCM_RTS : 0)
+	      | ((pCh->dataSetOut & I2_DTR) ? TIOCM_DTR : 0)
+	      | ((pCh->dataSetIn  & I2_DCD) ? TIOCM_CAR : 0)
+	      | ((pCh->dataSetIn  & I2_RI)  ? TIOCM_RNG : 0)
+	      | ((pCh->dataSetIn  & I2_DSR) ? TIOCM_DSR : 0)
+	      | ((pCh->dataSetIn  & I2_CTS) ? TIOCM_CTS : 0);
+}
+
+static int ip2_tiocmset(struct tty_struct *tty, struct file *file,
+			unsigned int set, unsigned int clear)
+{
+	i2ChanStrPtr pCh = DevTable[tty->index];
+
+	if (pCh == NULL)
+		return -ENODEV;
+
+	if (set & TIOCM_RTS) {
+		i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_RTSUP);
+		pCh->dataSetOut |= I2_RTS;
+	}
+	if (set & TIOCM_DTR) {
+		i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_DTRUP);
+		pCh->dataSetOut |= I2_DTR;
+	}
+
+	if (clear & TIOCM_RTS) {
+		i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_RTSDN);
+		pCh->dataSetOut &= ~I2_RTS;
+	}
+	if (clear & TIOCM_DTR) {
+		i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_DTRDN);
+		pCh->dataSetOut &= ~I2_DTR;
+	}
+	serviceOutgoingFifo( pCh->pMyBord );
+	return 0;
+}
+
 /******************************************************************************/
 /* Function:   ip2_ioctl()                                                    */
 /* Parameters: Pointer to tty structure                                       */
@@ -2078,57 +2157,6 @@ ip2_ioctl ( PTTY tty, struct file *pFile
 		
 		break;
 
-	case TIOCMGET:
-
-		ip2trace (CHANN, ITRC_IOCTL, 8, 1, rc );
-
-/*
-	FIXME - the following code is causing a NULL pointer dereference in
-	2.3.51 in an interrupt handler.  It's suppose to prompt the board
-	to return the DSS signal status immediately.  Why doesn't it do
-	the same thing in 2.2.14?
-*/
-
-/*	This thing is still busted in the 1.2.12 driver on 2.4.x
-	and even hoses the serial console so the oops can be trapped.
-		/\/\|=mhw=|\/\/			*/
-
-#ifdef	ENABLE_DSSNOW
-		i2QueueCommands(PTYPE_BYPASS, pCh, 100, 1, CMD_DSS_NOW);
-
-		init_waitqueue_entry(&wait, current);
-		add_wait_queue(&pCh->dss_now_wait, &wait);
-		set_current_state( TASK_INTERRUPTIBLE );
-
-		serviceOutgoingFifo( pCh->pMyBord );
-
-		schedule();
-
-		set_current_state( TASK_RUNNING );
-		remove_wait_queue(&pCh->dss_now_wait, &wait);
-
-		if (signal_pending(current)) {
-			return -EINTR;
-		}
-#endif
-		rc = put_user(
-				    ((pCh->dataSetOut & I2_RTS) ? TIOCM_RTS : 0)
-				  | ((pCh->dataSetOut & I2_DTR) ? TIOCM_DTR : 0)
-				  | ((pCh->dataSetIn  & I2_DCD) ? TIOCM_CAR : 0)
-				  | ((pCh->dataSetIn  & I2_RI)  ? TIOCM_RNG : 0)
-				  | ((pCh->dataSetIn  & I2_DSR) ? TIOCM_DSR : 0)
-				  | ((pCh->dataSetIn  & I2_CTS) ? TIOCM_CTS : 0),
-				(unsigned int *) arg);
-		break;
-
-	case TIOCMBIS:
-	case TIOCMBIC:
-	case TIOCMSET:
-		ip2trace (CHANN, ITRC_IOCTL, 9, 0 );
-
-		rc = set_modem_info(pCh, cmd, (unsigned int *) arg);
-		break;
-
 	/*
 	 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change - mask
 	 * passed in arg for lines of interest (use |'ed TIOCM_RNG/DSR/CD/CTS
@@ -2239,70 +2267,6 @@ ip2_ioctl ( PTTY tty, struct file *pFile
 }
 
 /******************************************************************************/
-/* Function:   set_modem_info()                                               */
-/* Parameters: Pointer to channel structure                                   */
-/*             Specific ioctl command                                         */
-/*             Pointer to source for new settings                             */
-/* Returns:    Nothing                                                        */
-/*                                                                            */
-/* Description:                                                               */
-/* This returns the current settings of the dataset signal inputs to the user */
-/* program.                                                                   */
-/******************************************************************************/
-static int
-set_modem_info(i2ChanStrPtr pCh, unsigned cmd, unsigned int *value)
-{
-	int rc;
-	unsigned int arg;
-
-	rc = get_user(arg,value);
-	if (rc)
-		return rc;
-	switch(cmd) {
-	case TIOCMBIS:
-		if (arg & TIOCM_RTS) {
-			i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_RTSUP);
-			pCh->dataSetOut |= I2_RTS;
-		}
-		if (arg & TIOCM_DTR) {
-			i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_DTRUP);
-			pCh->dataSetOut |= I2_DTR;
-		}
-		break;
-	case TIOCMBIC:
-		if (arg & TIOCM_RTS) {
-			i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_RTSDN);
-			pCh->dataSetOut &= ~I2_RTS;
-		}
-		if (arg & TIOCM_DTR) {
-			i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_DTRDN);
-			pCh->dataSetOut &= ~I2_DTR;
-		}
-		break;
-	case TIOCMSET:
-		if ( (arg & TIOCM_RTS) && !(pCh->dataSetOut & I2_RTS) ) {
-			i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_RTSUP);
-			pCh->dataSetOut |= I2_RTS;
-		} else if ( !(arg & TIOCM_RTS) && (pCh->dataSetOut & I2_RTS) ) {
-			i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_RTSDN);
-			pCh->dataSetOut &= ~I2_RTS;
-		}
-		if ( (arg & TIOCM_DTR) && !(pCh->dataSetOut & I2_DTR) ) {
-			i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_DTRUP);
-			pCh->dataSetOut |= I2_DTR;
-		} else if ( !(arg & TIOCM_DTR) && (pCh->dataSetOut & I2_DTR) ) {
-			i2QueueCommands(PTYPE_INLINE, pCh, 100, 1, CMD_DTRDN);
-			pCh->dataSetOut &= ~I2_DTR;
-		}
-		break;
-	default:
-		return -EINVAL;
-	}
-	serviceOutgoingFifo( pCh->pMyBord );
-	return 0;
-}
-
-/******************************************************************************/
 /* Function:   GetSerialInfo()                                                */
 /* Parameters: Pointer to channel structure                                   */
 /*             Pointer to old termios structure                               */
@@ -2964,7 +2928,7 @@ ip2_ipl_ioctl ( struct inode *pInode, st
 			rc = put_user(ip2_throttle, pIndex++ );
 			rc = put_user(ip2_unthrottle, pIndex++ );
 			rc = put_user(ip2_ioctl, pIndex++ );
-			rc = put_user(set_modem_info, pIndex++ );
+			rc = put_user(0, pIndex++ );
 			rc = put_user(get_serial_info, pIndex++ );
 			rc = put_user(set_serial_info, pIndex++ );
 			rc = put_user(ip2_set_termios, pIndex++ );
diff -purN linux-post-2.6.3-20040222/drivers/char/ipmi/ipmi_kcs_intf.c linux-post-2.6.3-20040223/drivers/char/ipmi/ipmi_kcs_intf.c
--- linux-post-2.6.3-20040222/drivers/char/ipmi/ipmi_kcs_intf.c	2003-08-15 01:17:28.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/ipmi/ipmi_kcs_intf.c	2004-02-23 05:24:11.000000000 +0000
@@ -55,6 +55,7 @@
 #include <linux/rcupdate.h>
 #include <linux/ipmi_smi.h>
 #include <asm/io.h>
+#include <asm/irq.h>
 #include "ipmi_kcs_sm.h"
 #include <linux/init.h>
 
diff -purN linux-post-2.6.3-20040222/drivers/char/ipmi/ipmi_kcs_sm.c linux-post-2.6.3-20040223/drivers/char/ipmi/ipmi_kcs_sm.c
--- linux-post-2.6.3-20040222/drivers/char/ipmi/ipmi_kcs_sm.c	2003-03-27 16:46:03.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/ipmi/ipmi_kcs_sm.c	2004-02-23 05:24:11.000000000 +0000
@@ -37,8 +37,11 @@
  * that document.
  */
 
+#include <linux/types.h>
+
 #include <asm/io.h>
 #include <asm/string.h>		/* Gets rid of memcpy warning */
+#include <asm/system.h>
 
 #include "ipmi_kcs_sm.h"
 
diff -purN linux-post-2.6.3-20040222/drivers/char/isicom.c linux-post-2.6.3-20040223/drivers/char/isicom.c
--- linux-post-2.6.3-20040222/drivers/char/isicom.c	2004-02-19 03:42:35.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/isicom.c	2004-02-23 03:09:24.000000000 +0000
@@ -1291,63 +1291,44 @@ static inline void isicom_send_break(str
 out:	restore_flags(flags);
 }
 
-static int isicom_get_modem_info(struct isi_port * port, unsigned int * value)
+static int isicom_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct isi_port * port = (struct isi_port *) tty->driver_data;
 	/* just send the port status */
-	unsigned int info;
 	unsigned short status = port->status;
+
+	if (isicom_paranoia_check(port, tty->name, "isicom_ioctl"))
+		return -ENODEV;
 	
-	info =  ((status & ISI_RTS) ? TIOCM_RTS : 0) |
+	return  ((status & ISI_RTS) ? TIOCM_RTS : 0) |
 		((status & ISI_DTR) ? TIOCM_DTR : 0) |
 		((status & ISI_DCD) ? TIOCM_CAR : 0) |
 		((status & ISI_DSR) ? TIOCM_DSR : 0) |
 		((status & ISI_CTS) ? TIOCM_CTS : 0) |
 		((status & ISI_RI ) ? TIOCM_RI  : 0);
-	return put_user(info, (unsigned int *) value);
 }
 
-static int isicom_set_modem_info(struct isi_port * port, unsigned int cmd,
-					unsigned int * value)
+static int isicom_tiocmset(struct tty_struct *tty, struct file *file,
+			   unsigned int set, unsigned int clear)
 {
+	struct isi_port * port = (struct isi_port *) tty->driver_data;
 	unsigned int arg;
 	unsigned long flags;
 	
-	if(get_user(arg, value))
-		return -EFAULT;
+	if (isicom_paranoia_check(port, tty->name, "isicom_ioctl"))
+		return -ENODEV;
 	
 	save_flags(flags); cli();
-	
-	switch(cmd) {
-		case TIOCMBIS:
-			if (arg & TIOCM_RTS) 
-				raise_rts(port);
-			if (arg & TIOCM_DTR) 
-				raise_dtr(port);
-			break;
-		
-		case TIOCMBIC:
-			if (arg & TIOCM_RTS)
-				drop_rts(port);
-			if (arg & TIOCM_DTR)
-				drop_dtr(port);	
-			break;
-			
-		case TIOCMSET:
-			if (arg & TIOCM_RTS)
-				raise_rts(port);
-			else
-				drop_rts(port);
-			
-			if (arg & TIOCM_DTR)
-				raise_dtr(port);
-			else
-				drop_dtr(port);
-			break;
-		
-		default:
-			restore_flags(flags);
-			return -EINVAL;		 	
-	}
+	if (set & TIOCM_RTS)
+		raise_rts(port);
+	if (set & TIOCM_DTR)
+		raise_dtr(port);
+
+	if (clear & TIOCM_RTS)
+		drop_rts(port);
+	if (clear & TIOCM_DTR)
+		drop_dtr(port);
+
 	restore_flags(flags);
 	return 0;
 }			
@@ -1445,15 +1426,6 @@ static int isicom_ioctl(struct tty_struc
 				(arg ? CLOCAL : 0));
 			return 0;	
 			
-		case TIOCMGET:
-			return isicom_get_modem_info(port, (unsigned int*) arg);
-			
-		case TIOCMBIS:
-		case TIOCMBIC:
-		case TIOCMSET: 	
-			return isicom_set_modem_info(port, cmd, 
-					(unsigned int *) arg);
-		
 		case TIOCGSERIAL:
 			return isicom_get_serial_info(port, 
 					(struct serial_struct *) arg);
@@ -1640,6 +1612,8 @@ static struct tty_operations isicom_ops 
 	.start	= isicom_start,
 	.hangup	= isicom_hangup,
 	.flush_buffer	= isicom_flush_buffer,
+	.tiocmget	= isicom_tiocmget,
+	.tiocmset	= isicom_tiocmset,
 };
 
 static int register_drivers(void)
diff -purN linux-post-2.6.3-20040222/drivers/char/istallion.c linux-post-2.6.3-20040223/drivers/char/istallion.c
--- linux-post-2.6.3-20040222/drivers/char/istallion.c	2004-02-04 05:39:35.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/istallion.c	2004-02-23 03:08:27.000000000 +0000
@@ -1991,6 +1991,61 @@ static int stli_setserial(stliport_t *po
 
 /*****************************************************************************/
 
+static int stli_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	stliport_t *portp = tty->driver_data;
+	stlibrd_t *brdp;
+	int rc;
+
+	if (portp == (stliport_t *) NULL)
+		return(-ENODEV);
+	if ((portp->brdnr < 0) || (portp->brdnr >= stli_nrbrds))
+		return(0);
+	brdp = stli_brds[portp->brdnr];
+	if (brdp == (stlibrd_t *) NULL)
+		return(0);
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return(-EIO);
+
+	if ((rc = stli_cmdwait(brdp, portp, A_GETSIGNALS,
+			       &portp->asig, sizeof(asysigs_t), 1)) < 0)
+		return(rc);
+
+	return stli_mktiocm(portp->asig.sigvalue);
+}
+
+static int stli_tiocmset(struct tty_struct *tty, struct file *file,
+			 unsigned int set, unsigned int clear)
+{
+	stliport_t *portp = tty->driver_data;
+	stlibrd_t *brdp;
+	int rts = -1, dtr = -1;
+
+	if (portp == (stliport_t *) NULL)
+		return(-ENODEV);
+	if ((portp->brdnr < 0) || (portp->brdnr >= stli_nrbrds))
+		return(0);
+	brdp = stli_brds[portp->brdnr];
+	if (brdp == (stlibrd_t *) NULL)
+		return(0);
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return(-EIO);
+
+	if (set & TIOCM_RTS)
+		rts = 1;
+	if (set & TIOCM_DTR)
+		dtr = 1;
+	if (clear & TIOCM_RTS)
+		rts = 0;
+	if (clear & TIOCM_DTR)
+		dtr = 0;
+
+	stli_mkasysigs(&portp->asig, dtr, rts);
+
+	return stli_cmdwait(brdp, portp, A_SETSIGNALS, &portp->asig,
+			    sizeof(asysigs_t), 0);
+}
+
 static int stli_ioctl(struct tty_struct *tty, struct file *file, unsigned int cmd, unsigned long arg)
 {
 	stliport_t	*portp;
@@ -2034,43 +2089,6 @@ static int stli_ioctl(struct tty_struct 
 				(tty->termios->c_cflag & ~CLOCAL) |
 				(ival ? CLOCAL : 0);
 		break;
-	case TIOCMGET:
-		if ((rc = verify_area(VERIFY_WRITE, (void *) arg,
-		    sizeof(unsigned int))) == 0) {
-			if ((rc = stli_cmdwait(brdp, portp, A_GETSIGNALS,
-			    &portp->asig, sizeof(asysigs_t), 1)) < 0)
-				return(rc);
-			lval = stli_mktiocm(portp->asig.sigvalue);
-			put_user(lval, (unsigned int *) arg);
-		}
-		break;
-	case TIOCMBIS:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			stli_mkasysigs(&portp->asig,
-				((ival & TIOCM_DTR) ? 1 : -1),
-				((ival & TIOCM_RTS) ? 1 : -1));
-			rc = stli_cmdwait(brdp, portp, A_SETSIGNALS,
-				&portp->asig, sizeof(asysigs_t), 0);
-		}
-		break;
-	case TIOCMBIC:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			stli_mkasysigs(&portp->asig,
-				((ival & TIOCM_DTR) ? 0 : -1),
-				((ival & TIOCM_RTS) ? 0 : -1));
-			rc = stli_cmdwait(brdp, portp, A_SETSIGNALS,
-				&portp->asig, sizeof(asysigs_t), 0);
-		}
-		break;
-	case TIOCMSET:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			stli_mkasysigs(&portp->asig,
-				((ival & TIOCM_DTR) ? 1 : 0),
-				((ival & TIOCM_RTS) ? 1 : 0));
-			rc = stli_cmdwait(brdp, portp, A_SETSIGNALS,
-				&portp->asig, sizeof(asysigs_t), 0);
-		}
-		break;
 	case TIOCGSERIAL:
 		if ((rc = verify_area(VERIFY_WRITE, (void *) arg,
 		    sizeof(struct serial_struct))) == 0)
@@ -5255,6 +5273,8 @@ static struct tty_operations stli_ops = 
 	.wait_until_sent = stli_waituntilsent,
 	.send_xchar = stli_sendxchar,
 	.read_proc = stli_readproc,
+	.tiocmget = stli_tiocmget,
+	.tiocmset = stli_tiocmset,
 };
 
 /*****************************************************************************/
diff -purN linux-post-2.6.3-20040222/drivers/char/moxa.c linux-post-2.6.3-20040223/drivers/char/moxa.c
--- linux-post-2.6.3-20040222/drivers/char/moxa.c	2004-02-04 05:39:35.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/moxa.c	2004-02-23 03:09:24.000000000 +0000
@@ -232,6 +232,9 @@ static void moxa_set_termios(struct tty_
 static void moxa_stop(struct tty_struct *);
 static void moxa_start(struct tty_struct *);
 static void moxa_hangup(struct tty_struct *);
+static int moxa_tiocmget(struct tty_struct *tty, struct file *file);
+static int moxa_tiocmset(struct tty_struct *tty, struct file *file,
+			 unsigned int set, unsigned int clear);
 static void moxa_poll(unsigned long);
 static void set_tty_param(struct tty_struct *);
 static int block_till_ready(struct tty_struct *, struct file *,
@@ -289,6 +292,8 @@ static struct tty_operations moxa_ops = 
 	.stop = moxa_stop,
 	.start = moxa_start,
 	.hangup = moxa_hangup,
+	.tiocmget = moxa_tiocmget,
+	.tiocmset = moxa_tiocmset,
 };
 
 static int __init moxa_init(void)
@@ -742,6 +747,55 @@ static void moxa_put_char(struct tty_str
 	ch->statusflags |= LOWWAIT;
 }
 
+static int moxa_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct moxa_str *ch = (struct moxa_str *) tty->driver_data;
+	int port;
+	int flag = 0, dtr, rts;
+
+	port = PORTNO(tty);
+	if ((port != MAX_PORTS) && (!ch))
+		return (-EINVAL);
+
+	MoxaPortGetLineOut(ch->port, &dtr, &rts);
+	if (dtr)
+		flag |= TIOCM_DTR;
+	if (rts)
+		flag |= TIOCM_RTS;
+	dtr = MoxaPortLineStatus(ch->port);
+	if (dtr & 1)
+		flag |= TIOCM_CTS;
+	if (dtr & 2)
+		flag |= TIOCM_DSR;
+	if (dtr & 4)
+		flag |= TIOCM_CD;
+	return flag;
+}
+
+static int moxa_tiocmset(struct tty_struct *tty, struct file *file,
+			 unsigned int set, unsigned int clear)
+{
+	struct moxa_str *ch = (struct moxa_str *) tty->driver_data;
+	int port;
+	int flag = 0, dtr, rts;
+
+	port = PORTNO(tty);
+	if ((port != MAX_PORTS) && (!ch))
+		return (-EINVAL);
+
+	MoxaPortGetLineOut(ch->port, &dtr, &rts);
+	if (set & TIOCM_RTS)
+		rts = 1;
+	if (set & TIOCM_DTR)
+		dtr = 1;
+	if (clear & TIOCM_RTS)
+		rts = 0;
+	if (clear & TIOCM_DTR)
+		dtr = 0;
+	MoxaPortLineCtrl(ch->port, dtr, rts);
+	return 0;
+}
+
 static int moxa_ioctl(struct tty_struct *tty, struct file *file,
 		      unsigned int cmd, unsigned long arg)
 {
@@ -785,51 +839,6 @@ static int moxa_ioctl(struct tty_struct 
 		else
 			ch->asyncflags |= ASYNC_CHECK_CD;
 		return (0);
-	case TIOCMGET:
-		flag = 0;
-		MoxaPortGetLineOut(ch->port, &dtr, &rts);
-		if (dtr)
-			flag |= TIOCM_DTR;
-		if (rts)
-			flag |= TIOCM_RTS;
-		dtr = MoxaPortLineStatus(ch->port);
-		if (dtr & 1)
-			flag |= TIOCM_CTS;
-		if (dtr & 2)
-			flag |= TIOCM_DSR;
-		if (dtr & 4)
-			flag |= TIOCM_CD;
-		return put_user(flag, (unsigned int *) arg);
-	case TIOCMBIS:
-		if(get_user(retval, (unsigned int *) arg))
-			return -EFAULT;
-		MoxaPortGetLineOut(ch->port, &dtr, &rts);
-		if (retval & TIOCM_RTS)
-			rts = 1;
-		if (retval & TIOCM_DTR)
-			dtr = 1;
-		MoxaPortLineCtrl(ch->port, dtr, rts);
-		return (0);
-	case TIOCMBIC:
-		if(get_user(retval, (unsigned int *) arg))
-			return -EFAULT;
-		MoxaPortGetLineOut(ch->port, &dtr, &rts);
-		if (retval & TIOCM_RTS)
-			rts = 0;
-		if (retval & TIOCM_DTR)
-			dtr = 0;
-		MoxaPortLineCtrl(ch->port, dtr, rts);
-		return (0);
-	case TIOCMSET:
-		if(get_user(retval, (unsigned long *) arg))
-			return -EFAULT;
-		dtr = rts = 0;
-		if (retval & TIOCM_RTS)
-			rts = 1;
-		if (retval & TIOCM_DTR)
-			dtr = 1;
-		MoxaPortLineCtrl(ch->port, dtr, rts);
-		return (0);
 	case TIOCGSERIAL:
 		return (moxa_get_serial_info(ch, (struct serial_struct *) arg));
 
diff -purN linux-post-2.6.3-20040222/drivers/char/mxser.c linux-post-2.6.3-20040223/drivers/char/mxser.c
--- linux-post-2.6.3-20040222/drivers/char/mxser.c	2004-02-06 08:30:20.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/mxser.c	2004-02-23 03:09:24.000000000 +0000
@@ -350,8 +350,8 @@ static int mxser_get_serial_info(struct 
 static int mxser_set_serial_info(struct mxser_struct *, struct serial_struct *);
 static int mxser_get_lsr_info(struct mxser_struct *, unsigned int *);
 static void mxser_send_break(struct mxser_struct *, int);
-static int mxser_get_modem_info(struct mxser_struct *, unsigned int *);
-static int mxser_set_modem_info(struct mxser_struct *, unsigned int, unsigned int *);
+static int mxser_tiocmget(struct tty_struct *, struct file *);
+static int mxser_tiocmset(struct tty_struct *, struct file *, unsigned int, unsigned int);
 
 /*
  * The MOXA C168/C104 serial driver boot-time initialization code!
@@ -492,6 +492,8 @@ static struct tty_operations mxser_ops =
 	.stop = mxser_stop,
 	.start = mxser_start,
 	.hangup = mxser_hangup,
+	.tiocmget = mxser_tiocmget,
+	.tiocmset = mxser_tiocmset,
 };
 
 static int __init mxser_module_init(void)
@@ -1009,12 +1011,6 @@ static int mxser_ioctl(struct tty_struct
 		tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) |
 					 (arg ? CLOCAL : 0));
 		return (0);
-	case TIOCMGET:
-		return (mxser_get_modem_info(info, (unsigned int *) arg));
-	case TIOCMBIS:
-	case TIOCMBIC:
-	case TIOCMSET:
-		return (mxser_set_modem_info(info, cmd, (unsigned int *) arg));
 	case TIOCGSERIAL:
 		return (mxser_get_serial_info(info, (struct serial_struct *) arg));
 	case TIOCSSERIAL:
@@ -2150,13 +2146,18 @@ static void mxser_send_break(struct mxse
 	restore_flags(flags);
 }
 
-static int mxser_get_modem_info(struct mxser_struct *info,
-				unsigned int *value)
+static int mxser_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
 	unsigned char control, status;
 	unsigned int result;
 	unsigned long flags;
 
+	if (PORTNO(tty) == MXSER_PORTS)
+		return (-ENOIOCTLCMD);
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return (-EIO);
+
 	control = info->MCR;
 	save_flags(flags);
 	cli();
@@ -2164,46 +2165,38 @@ static int mxser_get_modem_info(struct m
 	if (status & UART_MSR_ANY_DELTA)
 		mxser_check_modem_status(info, status);
 	restore_flags(flags);
-	result = ((control & UART_MCR_RTS) ? TIOCM_RTS : 0) |
+	return ((control & UART_MCR_RTS) ? TIOCM_RTS : 0) |
 	    ((control & UART_MCR_DTR) ? TIOCM_DTR : 0) |
 	    ((status & UART_MSR_DCD) ? TIOCM_CAR : 0) |
 	    ((status & UART_MSR_RI) ? TIOCM_RNG : 0) |
 	    ((status & UART_MSR_DSR) ? TIOCM_DSR : 0) |
 	    ((status & UART_MSR_CTS) ? TIOCM_CTS : 0);
-	return put_user(result, value);
 }
 
-static int mxser_set_modem_info(struct mxser_struct *info, unsigned int cmd,
-				unsigned int *value)
+static int mxser_tiocmset(struct tty_struct *tty, struct file *file,
+			  unsigned int set, unsigned int clear)
 {
+	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
 	unsigned int arg;
 	unsigned long flags;
 
-	if(get_user(arg, value))
-		return -EFAULT;
-	switch (cmd) {
-	case TIOCMBIS:
-		if (arg & TIOCM_RTS)
-			info->MCR |= UART_MCR_RTS;
-		if (arg & TIOCM_DTR)
-			info->MCR |= UART_MCR_DTR;
-		break;
-	case TIOCMBIC:
-		if (arg & TIOCM_RTS)
-			info->MCR &= ~UART_MCR_RTS;
-		if (arg & TIOCM_DTR)
-			info->MCR &= ~UART_MCR_DTR;
-		break;
-	case TIOCMSET:
-		info->MCR = ((info->MCR & ~(UART_MCR_RTS | UART_MCR_DTR)) |
-			     ((arg & TIOCM_RTS) ? UART_MCR_RTS : 0) |
-			     ((arg & TIOCM_DTR) ? UART_MCR_DTR : 0));
-		break;
-	default:
-		return (-EINVAL);
-	}
+	if (PORTNO(tty) == MXSER_PORTS)
+		return (-ENOIOCTLCMD);
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return (-EIO);
+
 	save_flags(flags);
 	cli();
+	if (set & TIOCM_RTS)
+		info->MCR |= UART_MCR_RTS;
+	if (set & TIOCM_DTR)
+		info->MCR |= UART_MCR_DTR;
+
+	if (clear & TIOCM_RTS)
+		info->MCR &= ~UART_MCR_RTS;
+	if (clear & TIOCM_DTR)
+		info->MCR &= ~UART_MCR_DTR;
+
 	outb(info->MCR, info->base + UART_MCR);
 	restore_flags(flags);
 	return (0);
diff -purN linux-post-2.6.3-20040222/drivers/char/pcxx.c linux-post-2.6.3-20040223/drivers/char/pcxx.c
--- linux-post-2.6.3-20040222/drivers/char/pcxx.c	2003-09-30 00:23:52.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/pcxx.c	2004-02-23 03:09:24.000000000 +0000
@@ -173,6 +173,9 @@ static inline void txwinon(struct channe
 static inline void memoff(struct channel *ch);
 static inline void assertgwinon(struct channel *ch);
 static inline void assertmemoff(struct channel *ch);
+static int pcxe_tiocmget(struct tty_struct *tty, struct file *file);
+static int pcxe_tiocmset(struct tty_struct *tty, struct file *file,
+			 unsigned int set, unsigned int clear);
 
 #define TZ_BUFSZ 4096
 
@@ -1029,6 +1032,8 @@ static struct tty_operations pcxe_ops = 
 	.stop = pcxe_stop,
 	.start = pcxe_start,
 	.hangup = pcxe_hangup,
+	.tiocmget = pcxe_tiocmget,
+	.tiocmset = pcxe_tiocmset,
 };
 
 /*
@@ -1983,6 +1988,89 @@ static void receive_data(struct channel 
 }
 
 
+static int pcxe_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct channel *ch = (struct channel *) tty->driver_data;
+	volatile struct board_chan *bc;
+	unsigned long flags;
+	int mflag = 0;
+
+	if(ch)
+		bc = ch->brdchan;
+	else {
+		printk("ch is NULL in %s!\n", __FUNCTION__);
+		return(-EINVAL);
+	}
+
+	save_flags(flags);
+	cli();
+	globalwinon(ch);
+	mstat = bc->mstat;
+	memoff(ch);
+	restore_flags(flags);
+
+	if(mstat & DTR)
+		mflag |= TIOCM_DTR;
+	if(mstat & RTS)
+		mflag |= TIOCM_RTS;
+	if(mstat & CTS)
+		mflag |= TIOCM_CTS;
+	if(mstat & ch->dsr)
+		mflag |= TIOCM_DSR;
+	if(mstat & RI)
+		mflag |= TIOCM_RI;
+	if(mstat & ch->dcd)
+		mflag |= TIOCM_CD;
+
+	return mflag;
+}
+
+
+static int pcxe_tiocmset(struct tty_struct *tty, struct file *file,
+			 unsigned int set, unsigned int clear)
+{
+	struct channel *ch = (struct channel *) tty->driver_data;
+	volatile struct board_chan *bc;
+	unsigned long flags;
+
+	if(ch)
+		bc = ch->brdchan;
+	else {
+		printk("ch is NULL in %s!\n", __FUNCTION__);
+		return(-EINVAL);
+	}
+
+	save_flags(flags);
+	cli();
+	/*
+	 * I think this modemfake stuff is broken.  It doesn't
+	 * correctly reflect the behaviour desired by the TIOCM*
+	 * ioctls.  Therefore this is probably broken.
+	 */
+	if (set & TIOCM_DTR) {
+		ch->modemfake |= DTR;
+		ch->modem |= DTR;
+	}
+	if (set & TIOCM_RTS) {
+		ch->modemfake |= RTS;
+		ch->modem |= RTS;
+	}
+
+	if (clear & TIOCM_DTR) {
+		ch->modemfake |= DTR;
+		ch->modem &= ~DTR;
+	}
+	if (clear & TIOCM_RTS) {
+		ch->modemfake |= RTS;
+		ch->modem &= ~RTS;
+	}
+	globalwinon(ch);
+	pcxxparam(tty,ch);
+	memoff(ch);
+	restore_flags(flags);
+}
+
+
 static int pcxe_ioctl(struct tty_struct *tty, struct file * file,
 		    unsigned int cmd, unsigned long arg)
 {
@@ -2036,69 +2124,15 @@ static int pcxe_ioctl(struct tty_struct 
 			return 0;
 
 		case TIOCMODG:
-		case TIOCMGET:
-			mflag = 0;
-
-			cli();
-			globalwinon(ch);
-			mstat = bc->mstat;
-			memoff(ch);
-			restore_flags(flags);
-
-			if(mstat & DTR)
-				mflag |= TIOCM_DTR;
-			if(mstat & RTS)
-				mflag |= TIOCM_RTS;
-			if(mstat & CTS)
-				mflag |= TIOCM_CTS;
-			if(mstat & ch->dsr)
-				mflag |= TIOCM_DSR;
-			if(mstat & RI)
-				mflag |= TIOCM_RI;
-			if(mstat & ch->dcd)
-				mflag |= TIOCM_CD;
-
+			mflag = pcxe_tiocmget(tty, file);
 			if (put_user(mflag, (unsigned int *) arg))
 				return -EFAULT;
 			break;
 
-		case TIOCMBIS:
-		case TIOCMBIC:
 		case TIOCMODS:
-		case TIOCMSET:
 			if (get_user(mstat, (unsigned int *) arg))
 				return -EFAULT;
-
-			mflag = 0;
-			if(mstat & TIOCM_DTR)
-				mflag |= DTR;
-			if(mstat & TIOCM_RTS)
-				mflag |= RTS;
-
-			switch(cmd) {
-				case TIOCMODS:
-				case TIOCMSET:
-					ch->modemfake = DTR|RTS;
-					ch->modem = mflag;
-					break;
-
-				case TIOCMBIS:
-					ch->modemfake |= mflag;
-					ch->modem |= mflag;
-					break;
-
-				case TIOCMBIC:
-					ch->modemfake &= ~mflag;
-					ch->modem &= ~mflag;
-					break;
-			}
-
-			cli();
-			globalwinon(ch);
-			pcxxparam(tty,ch);
-			memoff(ch);
-			restore_flags(flags);
-			break;
+			return pcxe_tiocmset(tty, file, mstat, ~mstat);
 
 		case TIOCSDTR:
 			cli();
diff -purN linux-post-2.6.3-20040222/drivers/char/pty.c linux-post-2.6.3-20040223/drivers/char/pty.c
--- linux-post-2.6.3-20040222/drivers/char/pty.c	2003-09-24 06:15:15.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/pty.c	2004-02-23 05:24:03.000000000 +0000
@@ -25,16 +25,21 @@
 #include <linux/mm.h>
 #include <linux/init.h>
 #include <linux/devfs_fs_kernel.h>
+#include <linux/sysctl.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <asm/bitops.h>
 #include <linux/devpts_fs.h>
 
+#if defined(CONFIG_LEGACY_PTYS) || defined(CONFIG_UNIX98_PTYS)
+
+#ifdef CONFIG_LEGACY_PTYS
 static struct tty_driver *pty_driver, *pty_slave_driver;
+#endif
 
-#ifdef CONFIG_UNIX98_PTYS
 /* These are global because they are accessed in tty_io.c */
+#ifdef CONFIG_UNIX98_PTYS
 struct tty_driver *ptm_driver;
 struct tty_driver *pts_driver;
 #endif
@@ -226,8 +231,9 @@ static int pty_set_lock(struct tty_struc
 	return 0;
 }
 
+#ifdef CONFIG_LEGACY_PTYS
 static int pty_bsd_ioctl(struct tty_struct *tty, struct file *file,
-			unsigned int cmd, unsigned long arg)
+			 unsigned int cmd, unsigned long arg)
 {
 	if (!tty) {
 		printk("pty_ioctl called with NULL tty!\n");
@@ -239,6 +245,7 @@ static int pty_bsd_ioctl(struct tty_stru
 	}
 	return -ENOIOCTLCMD;
 }
+#endif
 
 #ifdef CONFIG_UNIX98_PTYS
 static int pty_unix98_ioctl(struct tty_struct *tty, struct file *file,
@@ -249,11 +256,13 @@ static int pty_unix98_ioctl(struct tty_s
 		return -EIO;
 	}
 	switch(cmd) {
+	case TIOCSPTLCK: /* Set PT Lock (disallow slave open) */
+		return pty_set_lock(tty, (int *)arg);
 	case TIOCGPTN: /* Get PT Number */
 		return pty_get_device_number(tty, (unsigned int *)arg);
 	}
 
-	return pty_bsd_ioctl(tty,file,cmd,arg);
+	return -ENOIOCTLCMD;
 }
 #endif
 
@@ -313,8 +322,41 @@ static struct tty_operations pty_ops = {
 	.set_termios = pty_set_termios,
 };
 
+/* sysctl support for setting limits on the number of Unix98 ptys allocated.
+   Otherwise one can eat up all kernel memory by opening /dev/ptmx repeatedly. */
+#ifdef CONFIG_UNIX98_PTYS
+int pty_limit = NR_UNIX98_PTY_DEFAULT;
+static int pty_limit_min = 0;
+static int pty_limit_max = NR_UNIX98_PTY_MAX;
+
+ctl_table pty_table[] = {
+	{
+		.ctl_name	= PTY_MAX,
+		.procname	= "max",
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.data		= &pty_limit,
+		.proc_handler	= &proc_dointvec_minmax,
+		.strategy	= &sysctl_intvec,
+		.extra1		= &pty_limit_min,
+		.extra2		= &pty_limit_max,
+	}, {
+		.ctl_name	= PTY_NR,
+		.procname	= "nr",
+		.maxlen		= sizeof(int),
+		.mode		= 0444,
+		.proc_handler	= &proc_dointvec,
+	}, {
+		.ctl_name	= 0
+	}
+};
+#endif
+
+/* Initialization */
+
 static int __init pty_init(void)
 {
+#ifdef CONFIG_LEGACY_PTYS
 	/* Traditional BSD devices */
 
 	pty_driver = alloc_tty_driver(NR_PTYS);
@@ -363,15 +405,15 @@ static int __init pty_init(void)
 	if (tty_register_driver(pty_slave_driver))
 		panic("Couldn't register pty slave driver");
 
+#endif /* CONFIG_LEGACY_PTYS */
 
-	/* Unix98 devices */
 #ifdef CONFIG_UNIX98_PTYS
+	/* Unix98 devices */
 	devfs_mk_dir("pts");
-	printk("pty: %d Unix98 ptys configured\n", UNIX98_NR_MAJORS*NR_PTYS);
-	ptm_driver = alloc_tty_driver(UNIX98_NR_MAJORS * NR_PTYS);
+	ptm_driver = alloc_tty_driver(NR_UNIX98_PTY_MAX);
 	if (!ptm_driver)
 		panic("Couldn't allocate Unix98 ptm driver");
-	pts_driver = alloc_tty_driver(UNIX98_NR_MAJORS * NR_PTYS);
+	pts_driver = alloc_tty_driver(NR_UNIX98_PTY_MAX);
 	if (!pts_driver)
 		panic("Couldn't allocate Unix98 pts driver");
 
@@ -388,7 +430,7 @@ static int __init pty_init(void)
 	ptm_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;
 	ptm_driver->init_termios.c_lflag = 0;
 	ptm_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW |
-				TTY_DRIVER_NO_DEVFS;
+		TTY_DRIVER_NO_DEVFS | TTY_DRIVER_DEVPTS_MEM;
 	ptm_driver->other = pts_driver;
 	tty_set_operations(ptm_driver, &pty_ops);
 	ptm_driver->ioctl = pty_unix98_ioctl;
@@ -402,8 +444,8 @@ static int __init pty_init(void)
 	pts_driver->subtype = PTY_TYPE_SLAVE;
 	pts_driver->init_termios = tty_std_termios;
 	pts_driver->init_termios.c_cflag = B38400 | CS8 | CREAD;
-	pts_driver->flags = TTY_DRIVER_RESET_TERMIOS |
-			TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
+	pts_driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW |
+		TTY_DRIVER_NO_DEVFS | TTY_DRIVER_DEVPTS_MEM;
 	pts_driver->other = ptm_driver;
 	tty_set_operations(pts_driver, &pty_ops);
 	
@@ -411,7 +453,12 @@ static int __init pty_init(void)
 		panic("Couldn't register Unix98 ptm driver");
 	if (tty_register_driver(pts_driver))
 		panic("Couldn't register Unix98 pts driver");
-#endif
+
+	pty_table[1].data = &ptm_driver->refcount;
+#endif /* CONFIG_UNIX98_PTYS */
+
 	return 0;
 }
 module_init(pty_init);
+
+#endif /* CONFIG_LEGACY_PTYS || CONFIG_UNIX98_PTYS */
diff -purN linux-post-2.6.3-20040222/drivers/char/rio/rio_linux.c linux-post-2.6.3-20040223/drivers/char/rio/rio_linux.c
--- linux-post-2.6.3-20040222/drivers/char/rio/rio_linux.c	2003-09-30 00:34:28.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/rio/rio_linux.c	2004-02-23 03:08:27.000000000 +0000
@@ -728,6 +728,11 @@ static int rio_ioctl (struct tty_struct 
       rc = gs_setserial(&PortP->gs, (struct serial_struct *) arg);
     break;
 #if 0
+  /*
+   * note: these IOCTLs no longer reach here.  Use
+   * tiocmset/tiocmget driver methods instead.  The
+   * #if 0 disablement predates this comment.
+   */
   case TIOCMGET:
     if ((rc = verify_area(VERIFY_WRITE, (void *) arg,
                           sizeof(unsigned int))) == 0) {
diff -purN linux-post-2.6.3-20040222/drivers/char/riscom8.c linux-post-2.6.3-20040223/drivers/char/riscom8.c
--- linux-post-2.6.3-20040222/drivers/char/riscom8.c	2003-09-04 06:39:56.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/riscom8.c	2004-02-23 03:09:24.000000000 +0000
@@ -1306,13 +1306,17 @@ static void rc_flush_buffer(struct tty_s
 		(tty->ldisc.write_wakeup)(tty);
 }
 
-static int rc_get_modem_info(struct riscom_port * port, unsigned int *value)
+static int rc_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
 	struct riscom_board * bp;
 	unsigned char status;
 	unsigned int result;
 	unsigned long flags;
 
+	if (rc_paranoia_check(port, tty->name, __FUNCTION__))
+		return -ENODEV;
+
 	bp = port_Board(port);
 	save_flags(flags); cli();
 	rc_out(bp, CD180_CAR, port_No(port));
@@ -1324,41 +1328,32 @@ static int rc_get_modem_info(struct risc
 		| ((status & MSVR_CD)  ? TIOCM_CAR : 0)
 		| ((status & MSVR_DSR) ? TIOCM_DSR : 0)
 		| ((status & MSVR_CTS) ? TIOCM_CTS : 0);
-	return put_user(result, value);
+	return result;
 }
 
-static int rc_set_modem_info(struct riscom_port * port, unsigned int cmd,
-			     unsigned int *value)
+static int rc_tiocmset(struct tty_struct *tty, struct file *file,
+		       unsigned int set, unsigned int clear)
 {
-	unsigned int arg;
+	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
 	unsigned long flags;
-	struct riscom_board *bp = port_Board(port);
+	struct riscom_board *bp;
+
+	if (rc_paranoia_check(port, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	bp = port_Board(port);
 
-	if (get_user(arg, value))
-		return -EFAULT;
-	switch (cmd) {
-	 case TIOCMBIS: 
-		if (arg & TIOCM_RTS) 
-			port->MSVR |= MSVR_RTS;
-		if (arg & TIOCM_DTR)
-			bp->DTR &= ~(1u << port_No(port));
-		break;
-	case TIOCMBIC:
-		if (arg & TIOCM_RTS)
-			port->MSVR &= ~MSVR_RTS;
-		if (arg & TIOCM_DTR)
-			bp->DTR |= (1u << port_No(port));
-		break;
-	case TIOCMSET:
-		port->MSVR = (arg & TIOCM_RTS) ? (port->MSVR | MSVR_RTS) : 
-					         (port->MSVR & ~MSVR_RTS);
-		bp->DTR = arg & TIOCM_DTR ? (bp->DTR &= ~(1u << port_No(port))) :
-					    (bp->DTR |=  (1u << port_No(port)));
-		break;
-	 default:
-		return -EINVAL;
-	}
 	save_flags(flags); cli();
+	if (set & TIOCM_RTS)
+		port->MSVR |= MSVR_RTS;
+	if (set & TIOCM_DTR)
+		bp->DTR &= ~(1u << port_No(port));
+
+	if (clear & TIOCM_RTS)
+		port->MSVR &= ~MSVR_RTS;
+	if (clear & TIOCM_DTR)
+		bp->DTR |= (1u << port_No(port));
+
 	rc_out(bp, CD180_CAR, port_No(port));
 	rc_out(bp, CD180_MSVR, port->MSVR);
 	rc_out(bp, RC_DTR, bp->DTR);
@@ -1485,12 +1480,6 @@ static int rc_ioctl(struct tty_struct * 
 			((tty->termios->c_cflag & ~CLOCAL) |
 			(arg ? CLOCAL : 0));
 		break;
-	 case TIOCMGET:
-		return rc_get_modem_info(port, (unsigned int *) arg);
-	 case TIOCMBIS:
-	 case TIOCMBIC:
-	 case TIOCMSET:
-		return rc_set_modem_info(port, cmd, (unsigned int *) arg);
 	 case TIOCGSERIAL:	
 		return rc_get_serial_info(port, (struct serial_struct *) arg);
 	 case TIOCSSERIAL:	
@@ -1677,6 +1666,8 @@ static struct tty_operations riscom_ops 
 	.stop = rc_stop,
 	.start = rc_start,
 	.hangup = rc_hangup,
+	.tiocmget = rc_tiocmget,
+	.tiocmset = rc_tiocmset,
 };
 
 static inline int rc_init_drivers(void)
diff -purN linux-post-2.6.3-20040222/drivers/char/rocket.c linux-post-2.6.3-20040223/drivers/char/rocket.c
--- linux-post-2.6.3-20040222/drivers/char/rocket.c	2003-10-09 22:13:53.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/rocket.c	2004-02-23 03:08:27.000000000 +0000
@@ -1216,59 +1216,6 @@ static int sGetChanRI(CHANNEL_T * ChP)
 /********************************************************************************************/
 /*  Here are the routines used by rp_ioctl.  These are all called from exception handlers.  */
 
-static int get_modem_info(struct r_port *info, unsigned int *value)
-{
-	unsigned int control, result, ChanStatus;
-
-	ChanStatus = sGetChanStatusLo(&info->channel);
-
-	control = info->channel.TxControl[3];
-	result = ((control & SET_RTS) ? TIOCM_RTS : 0) | 
-		((control & SET_DTR) ?  TIOCM_DTR : 0) |
-		((ChanStatus & CD_ACT) ? TIOCM_CAR : 0) |
-		(sGetChanRI(&info->channel) ? TIOCM_RNG : 0) |
-		((ChanStatus & DSR_ACT) ? TIOCM_DSR : 0) |
-		((ChanStatus & CTS_ACT) ? TIOCM_CTS : 0);
-
-	if (copy_to_user(value, &result, sizeof (int)))
-		return -EFAULT;
-	return 0;
-}
-
-static int set_modem_info(struct r_port *info, unsigned int cmd,
-			  unsigned int *value)
-{
-	unsigned int arg;
-
-	if (copy_from_user(&arg, value, sizeof (int)))
-		return -EFAULT;
-
-	switch (cmd) {
-	case TIOCMBIS:
-		if (arg & TIOCM_RTS)
-			info->channel.TxControl[3] |= SET_RTS;
-		if (arg & TIOCM_DTR)
-			info->channel.TxControl[3] |= SET_DTR;
-		break;
-	case TIOCMBIC:
-		if (arg & TIOCM_RTS)
-			info->channel.TxControl[3] &= ~SET_RTS;
-		if (arg & TIOCM_DTR)
-			info->channel.TxControl[3] &= ~SET_DTR;
-		break;
-	case TIOCMSET:
-		info->channel.TxControl[3] = ((info->channel.TxControl[3] & ~(SET_RTS | SET_DTR)) | 
-					      ((arg & TIOCM_RTS) ? SET_RTS : 0) | 
-					      ((arg & TIOCM_DTR) ? SET_DTR : 0));
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	sOutDW(info->channel.IndexAddr, *(DWord_t *) & (info->channel.TxControl[0]));
-	return 0;
-}
-
 /*
  *  Returns the state of the serial modem control lines.  These next 2 functions 
  *  are the way kernel versions > 2.5 handle modem control lines rather than IOCTLs.
@@ -1432,12 +1379,6 @@ static int rp_ioctl(struct tty_struct *t
 		return -ENXIO;
 
 	switch (cmd) {
-	case TIOCMGET:
-		return get_modem_info(info, (unsigned int *) arg);
-	case TIOCMBIS:
-	case TIOCMBIC:
-	case TIOCMSET:
-		return set_modem_info(info, cmd, (unsigned int *) arg);
 	case RCKP_GET_STRUCT:
 		if (copy_to_user((void *) arg, info, sizeof (struct r_port)))
 			return -EFAULT;
diff -purN linux-post-2.6.3-20040222/drivers/char/serial167.c linux-post-2.6.3-20040223/drivers/char/serial167.c
--- linux-post-2.6.3-20040222/drivers/char/serial167.c	2003-09-30 00:23:52.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/serial167.c	2004-02-23 03:09:24.000000000 +0000
@@ -1492,8 +1492,9 @@ check_and_exit:
 } /* set_serial_info */
 
 static int
-get_modem_info(struct cyclades_port * info, unsigned int *value)
+cy_tiocmget(struct tty_struct *tty, struct file *file)
 {
+  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
   int channel;
   volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
   unsigned long flags;
@@ -1507,36 +1508,32 @@ get_modem_info(struct cyclades_port * in
         status = base_addr[CyMSVR1] | base_addr[CyMSVR2];
     local_irq_restore(flags);
 
-    result =  ((status  & CyRTS) ? TIOCM_RTS : 0)
+    return    ((status  & CyRTS) ? TIOCM_RTS : 0)
             | ((status  & CyDTR) ? TIOCM_DTR : 0)
             | ((status  & CyDCD) ? TIOCM_CAR : 0)
             | ((status  & CyDSR) ? TIOCM_DSR : 0)
             | ((status  & CyCTS) ? TIOCM_CTS : 0);
-    return put_user(result,(unsigned int *) value);
-} /* get_modem_info */
+} /* cy_tiocmget */
 
 static int
-set_modem_info(struct cyclades_port * info, unsigned int cmd,
-                          unsigned int *value)
+cy_tiocmset(struct tty_struct *tty, struct file *file,
+	    unsigned int set, unsigned int clear)
 {
+  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
   int channel;
   volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
   unsigned long flags;
   unsigned int arg;
 	  
-    if (get_user(arg, (unsigned long *) value))
-	return -EFAULT;
     channel = info->line;
 
-    switch (cmd) {
-    case TIOCMBIS:
-	if (arg & TIOCM_RTS){
+	if (set & TIOCM_RTS){
 	    local_irq_save(flags);
 		base_addr[CyCAR] = (u_char)channel;
 		base_addr[CyMSVR1] = CyRTS;
 	    local_irq_restore(flags);
 	}
-	if (arg & TIOCM_DTR){
+	if (set & TIOCM_DTR){
 	    local_irq_save(flags);
 	    base_addr[CyCAR] = (u_char)channel;
 /* CP('S');CP('2'); */
@@ -1547,15 +1544,14 @@ set_modem_info(struct cyclades_port * in
 #endif
 	    local_irq_restore(flags);
 	}
-	break;
-    case TIOCMBIC:
-	if (arg & TIOCM_RTS){
+
+	if (clear & TIOCM_RTS){
 	    local_irq_save(flags);
 		base_addr[CyCAR] = (u_char)channel;
 		base_addr[CyMSVR1] = 0;
 	    local_irq_restore(flags);
 	}
-	if (arg & TIOCM_DTR){
+	if (clear & TIOCM_DTR){
 	    local_irq_save(flags);
 	    base_addr[CyCAR] = (u_char)channel;
 /* CP('C');CP('2'); */
@@ -1566,44 +1562,7 @@ set_modem_info(struct cyclades_port * in
 #endif
 	    local_irq_restore(flags);
 	}
-	break;
-    case TIOCMSET:
-	if (arg & TIOCM_RTS){
-	    local_irq_save(flags);
-		base_addr[CyCAR] = (u_char)channel;
-		base_addr[CyMSVR1] = CyRTS;
-	    local_irq_restore(flags);
-	}else{
-	    local_irq_save(flags);
-		base_addr[CyCAR] = (u_char)channel;
-		base_addr[CyMSVR1] = 0;
-	    local_irq_restore(flags);
-	}
-	if (arg & TIOCM_DTR){
-	    local_irq_save(flags);
-	    base_addr[CyCAR] = (u_char)channel;
-/* CP('S');CP('3'); */
-	    base_addr[CyMSVR2] = CyDTR;
-#ifdef SERIAL_DEBUG_DTR
-            printk("cyc: %d: raising DTR\n", __LINE__);
-            printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1], base_addr[CyMSVR2]);
-#endif
-	    local_irq_restore(flags);
-	}else{
-	    local_irq_save(flags);
-	    base_addr[CyCAR] = (u_char)channel;
-/* CP('C');CP('3'); */
-	    base_addr[CyMSVR2] = 0;
-#ifdef SERIAL_DEBUG_DTR
-            printk("cyc: %d: dropping DTR\n", __LINE__);
-            printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1], base_addr[CyMSVR2]);
-#endif
-	    local_irq_restore(flags);
-	}
-	break;
-    default:
-		return -EINVAL;
-        }
+
     return 0;
 } /* set_modem_info */
 
@@ -1777,11 +1736,6 @@ cy_ioctl(struct tty_struct *tty, struct 
             tty_wait_until_sent(tty,0);
             send_break(info, arg ? arg*(HZ/10) : HZ/4);
             break;
-        case TIOCMBIS:
-        case TIOCMBIC:
-        case TIOCMSET:
-            ret_val = set_modem_info(info, cmd, (unsigned int *) arg);
-            break;
 
 /* The following commands are incompletely implemented!!! */
         case TIOCGSOFTCAR:
@@ -1794,9 +1748,6 @@ cy_ioctl(struct tty_struct *tty, struct 
             tty->termios->c_cflag =
                     ((tty->termios->c_cflag & ~CLOCAL) | (val ? CLOCAL : 0));
             break;
-        case TIOCMGET:
-            ret_val = get_modem_info(info, (unsigned int *) arg);
-            break;
         case TIOCGSERIAL:
             ret_val = get_serial_info(info, (struct serial_struct *) arg);
             break;
@@ -2299,6 +2250,8 @@ static struct tty_operations cy_ops = {
 	.stop = cy_stop,
 	.start = cy_start,
 	.hangup = cy_hangup,
+	.tiocmget = cy_tiocmget,
+	.tiocmset = cy_tiocmset,
 };
 /* The serial driver boot-time initialization code!
     Hardware I/O ports are mapped to character special devices on a
diff -purN linux-post-2.6.3-20040222/drivers/char/sh-sci.c linux-post-2.6.3-20040223/drivers/char/sh-sci.c
--- linux-post-2.6.3-20040222/drivers/char/sh-sci.c	2004-02-13 15:19:29.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/sh-sci.c	2004-02-23 03:08:27.000000000 +0000
@@ -1109,6 +1109,31 @@ static void sci_close(void *ptr)
         return;
 }
 
+static int sci_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct sci_port *port = tty->driver_data;
+	return sci_getsignals(port);
+}
+
+static int sci_tiocmset(struct tty_struct *tty, struct file *file,
+			unsigned int set, unsigned int clear)
+{
+	struct sci_port *port = tty->driver_data;
+	int rts = -1, dtr = -1;
+
+	if (set & TIOCM_RTS)
+		rts = 1;
+	if (set & TIOCM_DTR)
+		dtr = 1;
+	if (clear & TIOCM_RTS)
+		rts = 0;
+	if (clear & TIOCM_DTR)
+		dtr = 0;
+
+	sci_setsignals(port, dtr, rts);
+	return 0;
+}
+
 static int sci_ioctl(struct tty_struct * tty, struct file * filp, 
                      unsigned int cmd, unsigned long arg)
 {
@@ -1139,26 +1164,6 @@ static int sci_ioctl(struct tty_struct *
 			rc = gs_setserial(&port->gs,
 					  (struct serial_struct *) arg);
 		break;
-	case TIOCMGET:
-		ival = sci_getsignals(port);
-		rc = put_user(ival, (unsigned int __user *) arg);
-		break;
-	case TIOCMBIS:
-		if ((rc = get_user(ival, (unsigned int __user *) arg)) == 0)
-			sci_setsignals(port, ((ival & TIOCM_DTR) ? 1 : -1),
-			                     ((ival & TIOCM_RTS) ? 1 : -1));
-		break;
-	case TIOCMBIC:
-		if ((rc = get_user(ival, (unsigned int __user *) arg)) == 0)
-			sci_setsignals(port, ((ival & TIOCM_DTR) ? 0 : -1),
-			                     ((ival & TIOCM_RTS) ? 0 : -1));
-		break;
-	case TIOCMSET:
-		if ((rc = get_user(ival, (unsigned int __user *)arg)) == 0)
-			sci_setsignals(port, ((ival & TIOCM_DTR) ? 1 : 0),
-			                     ((ival & TIOCM_RTS) ? 1 : 0));
-		break;
-
 	default:
 		rc = -ENOIOCTLCMD;
 		break;
@@ -1272,6 +1277,8 @@ static struct tty_operations sci_ops = {
 #ifdef CONFIG_PROC_FS
 	.read_proc = sci_read_proc,
 #endif
+	.tiocmget = sci_tiocmget,
+	.tiocmset = sci_tiocmset,
 };
 
 /* ********************************************************************** *
diff -purN linux-post-2.6.3-20040222/drivers/char/specialix.c linux-post-2.6.3-20040223/drivers/char/specialix.c
--- linux-post-2.6.3-20040222/drivers/char/specialix.c	2004-02-04 05:39:36.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/specialix.c	2004-02-23 03:09:24.000000000 +0000
@@ -1653,13 +1653,17 @@ static void sx_flush_buffer(struct tty_s
 }
 
 
-static int sx_get_modem_info(struct specialix_port * port, unsigned int *value)
+static int sx_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
 	struct specialix_board * bp;
 	unsigned char status;
 	unsigned int result;
 	unsigned long flags;
 
+	if (sx_paranoia_check(port, tty->name, __FUNCTION__))
+		return -ENODEV;
+
 	bp = port_Board(port);
 	save_flags(flags); cli();
 	sx_out(bp, CD186x_CAR, port_No(port));
@@ -1683,71 +1687,51 @@ static int sx_get_modem_info(struct spec
 		          |/* ((status & MSVR_DSR) ? */ TIOCM_DSR /* : 0) */
 		          |   ((status & MSVR_CTS) ? TIOCM_CTS : 0);
 	}
-	put_user(result,(unsigned int *) value);
-	return 0;
+
+	return result;
 }
 
 
-static int sx_set_modem_info(struct specialix_port * port, unsigned int cmd,
-                             unsigned int *value)
+static int sx_tiocmset(struct tty_struct *tty, struct file *file,
+		       unsigned int set, unsigned int clear)
 {
+	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
 	int error;
 	unsigned int arg;
 	unsigned long flags;
-	struct specialix_board *bp = port_Board(port);
+	struct specialix_board *bp;
 
-	error = verify_area(VERIFY_READ, value, sizeof(int));
-	if (error) 
-		return error;
+	if (sx_paranoia_check(port, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	bp = port_Board(port);
 
-	get_user(arg, (unsigned long *) value);
-	switch (cmd) {
-	case TIOCMBIS: 
-	   /*	if (arg & TIOCM_RTS) 
-			port->MSVR |= MSVR_RTS; */
-	   /*   if (arg & TIOCM_DTR)
-			port->MSVR |= MSVR_DTR; */
-
-		if (SX_CRTSCTS(port->tty)) {
-			if (arg & TIOCM_RTS)
-				port->MSVR |= MSVR_DTR; 
-		} else {
-			if (arg & TIOCM_DTR)
-				port->MSVR |= MSVR_DTR; 
-		}	     
-		break;
-	case TIOCMBIC:
-	  /*	if (arg & TIOCM_RTS)
-			port->MSVR &= ~MSVR_RTS; */
-	  /*    if (arg & TIOCM_DTR)
-			port->MSVR &= ~MSVR_DTR; */
-		if (SX_CRTSCTS(port->tty)) {
-			if (arg & TIOCM_RTS)
-				port->MSVR &= ~MSVR_DTR;
-		} else {
-			if (arg & TIOCM_DTR)
-				port->MSVR &= ~MSVR_DTR;
-		}
-		break;
-	case TIOCMSET:
-	  /* port->MSVR = (arg & TIOCM_RTS) ? (port->MSVR | MSVR_RTS) : 
-						 (port->MSVR & ~MSVR_RTS); */
-	  /* port->MSVR = (arg & TIOCM_DTR) ? (port->MSVR | MSVR_DTR) : 
-						 (port->MSVR & ~MSVR_DTR); */
-		if (SX_CRTSCTS(port->tty)) {
-	  		port->MSVR = (arg & TIOCM_RTS) ? 
-			                         (port->MSVR |  MSVR_DTR) : 
-			                         (port->MSVR & ~MSVR_DTR);
-		} else {
-			port->MSVR = (arg & TIOCM_DTR) ?
-			                         (port->MSVR |  MSVR_DTR):
-			                         (port->MSVR & ~MSVR_DTR);
-		}
-		break;
-	default:
-		return -EINVAL;
-	}
 	save_flags(flags); cli();
+   /*	if (set & TIOCM_RTS)
+		port->MSVR |= MSVR_RTS; */
+   /*   if (set & TIOCM_DTR)
+		port->MSVR |= MSVR_DTR; */
+
+	if (SX_CRTSCTS(port->tty)) {
+		if (set & TIOCM_RTS)
+			port->MSVR |= MSVR_DTR;
+	} else {
+		if (set & TIOCM_DTR)
+			port->MSVR |= MSVR_DTR;
+	}
+
+  /*	if (clear & TIOCM_RTS)
+		port->MSVR &= ~MSVR_RTS; */
+  /*    if (clear & TIOCM_DTR)
+		port->MSVR &= ~MSVR_DTR; */
+	if (SX_CRTSCTS(port->tty)) {
+		if (clear & TIOCM_RTS)
+			port->MSVR &= ~MSVR_DTR;
+	} else {
+		if (clear & TIOCM_DTR)
+			port->MSVR &= ~MSVR_DTR;
+	}
+
 	sx_out(bp, CD186x_CAR, port_No(port));
 	sx_out(bp, CD186x_MSVR, port->MSVR);
 	restore_flags(flags);
@@ -1897,16 +1881,6 @@ static int sx_ioctl(struct tty_struct * 
 			((tty->termios->c_cflag & ~CLOCAL) |
 			(arg ? CLOCAL : 0));
 		return 0;
-	 case TIOCMGET:
-		error = verify_area(VERIFY_WRITE, (void *) arg,
-		                    sizeof(unsigned int));
-		if (error)
-			return error;
-		return sx_get_modem_info(port, (unsigned int *) arg);
-	 case TIOCMBIS:
-	 case TIOCMBIC:
-	 case TIOCMSET:
-		return sx_set_modem_info(port, cmd, (unsigned int *) arg);
 	 case TIOCGSERIAL:	
 		return sx_get_serial_info(port, (struct serial_struct *) arg);
 	 case TIOCSSERIAL:	
@@ -2116,6 +2090,8 @@ static struct tty_operations sx_ops = {
 	.stop = sx_stop,
 	.start = sx_start,
 	.hangup = sx_hangup,
+	.tiocmget = sx_tiocmget,
+	.tiocmset = sx_tiocmset,
 };
 
 static int sx_init_drivers(void)
diff -purN linux-post-2.6.3-20040222/drivers/char/stallion.c linux-post-2.6.3-20040223/drivers/char/stallion.c
--- linux-post-2.6.3-20040222/drivers/char/stallion.c	2003-09-30 00:34:28.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/stallion.c	2004-02-23 03:08:27.000000000 +0000
@@ -1514,6 +1514,48 @@ static int stl_setserial(stlport_t *port
 
 /*****************************************************************************/
 
+static int stl_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	stlport_t	*portp;
+
+	if (tty == (struct tty_struct *) NULL)
+		return(-ENODEV);
+	portp = tty->driver_data;
+	if (portp == (stlport_t *) NULL)
+		return(-ENODEV);
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return(-EIO);
+
+	return stl_getsignals(portp);
+}
+
+static int stl_tiocmset(struct tty_struct *tty, struct file *file,
+			unsigned int set, unsigned int clear)
+{
+	stlport_t	*portp;
+	int rts = -1, dtr = -1;
+
+	if (tty == (struct tty_struct *) NULL)
+		return(-ENODEV);
+	portp = tty->driver_data;
+	if (portp == (stlport_t *) NULL)
+		return(-ENODEV);
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return(-EIO);
+
+	if (set & TIOCM_RTS)
+		rts = 1;
+	if (set & TIOCM_DTR)
+		dtr = 1;
+	if (clear & TIOCM_RTS)
+		rts = 0;
+	if (clear & TIOCM_DTR)
+		dtr = 0;
+
+	stl_setsignals(portp, dtr, rts);
+	return 0;
+}
+
 static int stl_ioctl(struct tty_struct *tty, struct file *file, unsigned int cmd, unsigned long arg)
 {
 	stlport_t	*portp;
@@ -1553,37 +1595,6 @@ static int stl_ioctl(struct tty_struct *
 				(ival ? CLOCAL : 0);
 		}
 		break;
-	case TIOCMGET:
-		if ((rc = verify_area(VERIFY_WRITE, (void *) arg,
-		    sizeof(unsigned int))) == 0) {
-			ival = stl_getsignals(portp);
-			put_user(ival, (unsigned int *) arg);
-		}
-		break;
-	case TIOCMBIS:
-		if ((rc = verify_area(VERIFY_READ, (void *) arg,
-		    sizeof(unsigned int))) == 0) {
-			get_user(ival, (unsigned int *) arg);
-			stl_setsignals(portp, ((ival & TIOCM_DTR) ? 1 : -1),
-				((ival & TIOCM_RTS) ? 1 : -1));
-		}
-		break;
-	case TIOCMBIC:
-		if ((rc = verify_area(VERIFY_READ, (void *) arg,
-		    sizeof(unsigned int))) == 0) {
-			get_user(ival, (unsigned int *) arg);
-			stl_setsignals(portp, ((ival & TIOCM_DTR) ? 0 : -1),
-				((ival & TIOCM_RTS) ? 0 : -1));
-		}
-		break;
-	case TIOCMSET:
-		if ((rc = verify_area(VERIFY_READ, (void *) arg,
-		    sizeof(unsigned int))) == 0) {
-			get_user(ival, (unsigned int *) arg);
-			stl_setsignals(portp, ((ival & TIOCM_DTR) ? 1 : 0),
-				((ival & TIOCM_RTS) ? 1 : 0));
-		}
-		break;
 	case TIOCGSERIAL:
 		if ((rc = verify_area(VERIFY_WRITE, (void *) arg,
 		    sizeof(struct serial_struct))) == 0)
@@ -3137,6 +3148,8 @@ static struct tty_operations stl_ops = {
 	.wait_until_sent = stl_waituntilsent,
 	.send_xchar = stl_sendxchar,
 	.read_proc = stl_readproc,
+	.tiocmget = stl_tiocmget,
+	.tiocmset = stl_tiocmset,
 };
 
 /*****************************************************************************/
diff -purN linux-post-2.6.3-20040222/drivers/char/sx.c linux-post-2.6.3-20040223/drivers/char/sx.c
--- linux-post-2.6.3-20040222/drivers/char/sx.c	2003-12-30 08:41:41.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/sx.c	2004-02-23 03:08:27.000000000 +0000
@@ -1743,6 +1743,32 @@ static void sx_break (struct tty_struct 
 }
 
 
+static int sx_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct sx_port *port = tty->driver_data;
+	return sx_getsignals(port);
+}
+
+static int sx_tiocmset(struct tty_struct *tty, struct file *file,
+		       unsigned int set, unsigned int clear)
+{
+	struct sx_port *port = tty->driver_data;
+	int rts = -1, dtr = -1;
+
+	if (set & TIOCM_RTS)
+		rts = 1;
+	if (set & TIOCM_DTR)
+		dtr = 1;
+	if (clear & TIOCM_RTS)
+		rts = 0;
+	if (clear & TIOCM_DTR)
+		dtr = 0;
+
+	sx_setsignals(port, dtr, rts);
+	sx_reconfigure_port(port);
+	return 0;
+}
+
 static int sx_ioctl (struct tty_struct * tty, struct file * filp, 
                      unsigned int cmd, unsigned long arg)
 {
@@ -1775,34 +1801,6 @@ static int sx_ioctl (struct tty_struct *
 		                      sizeof(struct serial_struct))) == 0)
 			rc = gs_setserial(&port->gs, (struct serial_struct *) arg);
 		break;
-	case TIOCMGET:
-		if ((rc = verify_area(VERIFY_WRITE, (void *) arg,
-		                      sizeof(unsigned int))) == 0) {
-			ival = sx_getsignals(port);
-			put_user(ival, (unsigned int *) arg);
-		}
-		break;
-	case TIOCMBIS:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			sx_setsignals(port, ((ival & TIOCM_DTR) ? 1 : -1),
-			                     ((ival & TIOCM_RTS) ? 1 : -1));
-			sx_reconfigure_port(port);
-		}
-		break;
-	case TIOCMBIC:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			sx_setsignals(port, ((ival & TIOCM_DTR) ? 0 : -1),
-			                     ((ival & TIOCM_RTS) ? 0 : -1));
-			sx_reconfigure_port(port);
-		}
-		break;
-	case TIOCMSET:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			sx_setsignals(port, ((ival & TIOCM_DTR) ? 1 : 0),
-			                     ((ival & TIOCM_RTS) ? 1 : 0));
-			sx_reconfigure_port(port);
-		}
-		break;
 	default:
 		rc = -ENOIOCTLCMD;
 		break;
@@ -2217,6 +2215,8 @@ static struct tty_operations sx_ops = {
 	.stop = gs_stop,
 	.start = gs_start,
 	.hangup = gs_hangup,
+	.tiocmget = sx_tiocmget,
+	.tiocmset = sx_tiocmset,
 };
 
 static int sx_init_drivers(void)
diff -purN linux-post-2.6.3-20040222/drivers/char/tty_io.c linux-post-2.6.3-20040223/drivers/char/tty_io.c
--- linux-post-2.6.3-20040222/drivers/char/tty_io.c	2004-02-06 08:18:38.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/char/tty_io.c	2004-02-23 05:24:03.000000000 +0000
@@ -124,7 +124,7 @@ struct tty_ldisc ldiscs[NR_LDISCS];	/* l
 
 #ifdef CONFIG_UNIX98_PTYS
 extern struct tty_driver *ptm_driver;	/* Unix98 pty masters; for /dev/ptmx */
-extern struct tty_driver *pts_driver;	/* Unix98 pty slaves;  for /dev/ptmx */
+extern int pty_limit;		/* Config limit on Unix98 ptys */
 #endif
 
 extern void disable_early_printk(void);
@@ -799,7 +799,13 @@ static int init_dev(struct tty_driver *d
 	down_tty_sem(idx);
 
 	/* check whether we're reopening an existing tty */
-	tty = driver->ttys[idx];
+	if (driver->flags & TTY_DRIVER_DEVPTS_MEM) {
+		tty = devpts_get_tty(idx);
+		if (tty && driver->subtype == PTY_TYPE_MASTER)
+			tty = tty->link;
+	} else {
+		tty = driver->ttys[idx];
+	}
 	if (tty) goto fast_track;
 
 	/*
@@ -827,7 +833,14 @@ static int init_dev(struct tty_driver *d
 	tty->index = idx;
 	tty_line_name(driver, idx, tty->name);
 
-	tp_loc = &driver->termios[idx];
+	if (driver->flags & TTY_DRIVER_DEVPTS_MEM) {
+		tp_loc = &tty->termios;
+		ltp_loc = &tty->termios_locked;
+	} else {
+		tp_loc = &driver->termios[idx];
+		ltp_loc = &driver->termios_locked[idx];
+	}
+
 	if (!*tp_loc) {
 		tp = (struct termios *) kmalloc(sizeof(struct termios),
 						GFP_KERNEL);
@@ -836,7 +849,6 @@ static int init_dev(struct tty_driver *d
 		*tp = driver->init_termios;
 	}
 
-	ltp_loc = &driver->termios_locked[idx];
 	if (!*ltp_loc) {
 		ltp = (struct termios *) kmalloc(sizeof(struct termios),
 						 GFP_KERNEL);
@@ -854,7 +866,14 @@ static int init_dev(struct tty_driver *d
 		o_tty->index = idx;
 		tty_line_name(driver->other, idx, o_tty->name);
 
-		o_tp_loc  = &driver->other->termios[idx];
+		if (driver->flags & TTY_DRIVER_DEVPTS_MEM) {
+			o_tp_loc = &o_tty->termios;
+			o_ltp_loc = &o_tty->termios_locked;
+		} else {
+			o_tp_loc = &driver->other->termios[idx];
+			o_ltp_loc = &driver->other->termios_locked[idx];
+		}
+
 		if (!*o_tp_loc) {
 			o_tp = (struct termios *)
 				kmalloc(sizeof(struct termios), GFP_KERNEL);
@@ -863,7 +882,6 @@ static int init_dev(struct tty_driver *d
 			*o_tp = driver->other->init_termios;
 		}
 
-		o_ltp_loc = &driver->other->termios_locked[idx];
 		if (!*o_ltp_loc) {
 			o_ltp = (struct termios *)
 				kmalloc(sizeof(struct termios), GFP_KERNEL);
@@ -875,7 +893,9 @@ static int init_dev(struct tty_driver *d
 		/*
 		 * Everything allocated ... set up the o_tty structure.
 		 */
-		driver->other->ttys[idx] = o_tty;
+		if (!(driver->other->flags & TTY_DRIVER_DEVPTS_MEM)) {
+			driver->other->ttys[idx] = o_tty;
+		}
 		if (!*o_tp_loc)
 			*o_tp_loc = o_tp;
 		if (!*o_ltp_loc)
@@ -896,7 +916,9 @@ static int init_dev(struct tty_driver *d
 	 * Failures after this point use release_mem to clean up, so 
 	 * there's no need to null out the local pointers.
 	 */
-	driver->ttys[idx] = tty;
+	if (!(driver->flags & TTY_DRIVER_DEVPTS_MEM)) {
+		driver->ttys[idx] = tty;
+	}
 	
 	if (!*tp_loc)
 		*tp_loc = tp;
@@ -994,12 +1016,20 @@ static void release_mem(struct tty_struc
 {
 	struct tty_struct *o_tty;
 	struct termios *tp;
+	int devpts = tty->driver->flags & TTY_DRIVER_DEVPTS_MEM;
 
 	if ((o_tty = tty->link) != NULL) {
-		o_tty->driver->ttys[idx] = NULL;
+		if (!devpts)
+			o_tty->driver->ttys[idx] = NULL;
 		if (o_tty->driver->flags & TTY_DRIVER_RESET_TERMIOS) {
-			tp = o_tty->driver->termios[idx];
-			o_tty->driver->termios[idx] = NULL;
+			tp = o_tty->termios;
+			if (!devpts)
+				o_tty->driver->termios[idx] = NULL;
+			kfree(tp);
+
+			tp = o_tty->termios_locked;
+			if (!devpts)
+				o_tty->driver->termios_locked[idx] = NULL;
 			kfree(tp);
 		}
 		o_tty->magic = 0;
@@ -1010,12 +1040,20 @@ static void release_mem(struct tty_struc
 		free_tty_struct(o_tty);
 	}
 
-	tty->driver->ttys[idx] = NULL;
+	if (!devpts)
+		tty->driver->ttys[idx] = NULL;
 	if (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS) {
-		tp = tty->driver->termios[idx];
-		tty->driver->termios[idx] = NULL;
+		tp = tty->termios;
+		if (!devpts)
+			tty->driver->termios[idx] = NULL;
+		kfree(tp);
+
+		tp = tty->termios_locked;
+		if (!devpts)
+			tty->driver->termios_locked[idx] = NULL;
 		kfree(tp);
 	}
+
 	tty->magic = 0;
 	tty->driver->refcount--;
 	file_list_lock();
@@ -1059,22 +1097,24 @@ static void release_dev(struct file * fi
 				  "free (%s)\n", tty->name);
 		return;
 	}
-	if (tty != tty->driver->ttys[idx]) {
-		printk(KERN_DEBUG "release_dev: driver.table[%d] not tty "
-				  "for (%s)\n", idx, tty->name);
-		return;
-	}
-	if (tty->termios != tty->driver->termios[idx]) {
-		printk(KERN_DEBUG "release_dev: driver.termios[%d] not termios "
-		       "for (%s)\n",
-		       idx, tty->name);
-		return;
-	}
-	if (tty->termios_locked != tty->driver->termios_locked[idx]) {
-		printk(KERN_DEBUG "release_dev: driver.termios_locked[%d] not "
-		       "termios_locked for (%s)\n",
-		       idx, tty->name);
-		return;
+	if (!(tty->driver->flags & TTY_DRIVER_DEVPTS_MEM)) {
+		if (tty != tty->driver->ttys[idx]) {
+			printk(KERN_DEBUG "release_dev: driver.table[%d] not tty "
+			       "for (%s)\n", idx, tty->name);
+			return;
+		}
+		if (tty->termios != tty->driver->termios[idx]) {
+			printk(KERN_DEBUG "release_dev: driver.termios[%d] not termios "
+			       "for (%s)\n",
+			       idx, tty->name);
+			return;
+		}
+		if (tty->termios_locked != tty->driver->termios_locked[idx]) {
+			printk(KERN_DEBUG "release_dev: driver.termios_locked[%d] not "
+			       "termios_locked for (%s)\n",
+			       idx, tty->name);
+			return;
+		}
 	}
 #endif
 
@@ -1084,7 +1124,8 @@ static void release_dev(struct file * fi
 #endif
 
 #ifdef TTY_PARANOIA_CHECK
-	if (tty->driver->other) {
+	if (tty->driver->other &&
+	     !(tty->driver->flags & TTY_DRIVER_DEVPTS_MEM)) {
 		if (o_tty != tty->driver->other->ttys[idx]) {
 			printk(KERN_DEBUG "release_dev: other->table[%d] "
 					  "not o_tty for (%s)\n",
@@ -1328,23 +1369,29 @@ retry_open:
 		return -ENODEV;
 	}
 
-	if (device == MKDEV(TTYAUX_MAJOR,2)) {
 #ifdef CONFIG_UNIX98_PTYS
+	if (device == MKDEV(TTYAUX_MAJOR,2)) {
 		/* find a device that is not in use. */
+		static int next_ptmx_dev = 0;
 		retval = -1;
 		driver = ptm_driver;
-		for (index = 0; index < driver->num ; index++)
+		while (driver->refcount < pty_limit) {
+			index = next_ptmx_dev;
+			next_ptmx_dev = (next_ptmx_dev+1) % driver->num;
 			if (!init_dev(driver, index, &tty))
 				goto ptmx_found; /* ok! */
+		}
 		return -EIO; /* no free ptys */
 	ptmx_found:
 		set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
-		devpts_pty_new(index, MKDEV(pts_driver->major, pts_driver->minor_start) + index);
+		if (devpts_pty_new(tty->link)) {
+			/* BADNESS - need to destroy both ptm and pts! */
+			return -ENOMEM;
+		}
 		noctty = 1;
-#else
-		return -ENODEV;
-#endif  /* CONFIG_UNIX_98_PTYS */
-	} else {
+	} else
+#endif
+	{
 		driver = get_tty_driver(device, &index);
 		if (!driver)
 			return -ENODEV;
@@ -2190,15 +2237,17 @@ int tty_register_driver(struct tty_drive
         int i;
 	dev_t dev;
 	char *s;
-	void **p;
+	void **p = NULL;
 
 	if (driver->flags & TTY_DRIVER_INSTALLED)
 		return 0;
 
-	p = kmalloc(driver->num * 3 * sizeof(void *), GFP_KERNEL);
-	if (!p)
-		return -ENOMEM;
-	memset(p, 0, driver->num * 3 * sizeof(void *));
+	if (!(driver->flags & TTY_DRIVER_DEVPTS_MEM)) {
+		p = kmalloc(driver->num * 3 * sizeof(void *), GFP_KERNEL);
+		if (!p)
+			return -ENOMEM;
+		memset(p, 0, driver->num * 3 * sizeof(void *));
+	}
 
 	if (!driver->major) {
 		error = alloc_chrdev_region(&dev, driver->minor_start, driver->num,
@@ -2217,9 +2266,15 @@ int tty_register_driver(struct tty_drive
 		return error;
 	}
 
-	driver->ttys = (struct tty_struct **)p;
-	driver->termios = (struct termios **)(p + driver->num);
-	driver->termios_locked = (struct termios **)(p + driver->num * 2);
+	if (p) {
+		driver->ttys = (struct tty_struct **)p;
+		driver->termios = (struct termios **)(p + driver->num);
+		driver->termios_locked = (struct termios **)(p + driver->num * 2);
+	} else {
+		driver->ttys = NULL;
+		driver->termios = NULL;
+		driver->termios_locked = NULL;
+	}
 
 	driver->cdev.kobj.parent = &tty_kobj;
 	strcpy(driver->cdev.kobj.name, driver->name);
@@ -2388,7 +2443,7 @@ static int __init tty_init(void)
 	devfs_mk_cdev(MKDEV(TTYAUX_MAJOR, 2), S_IFCHR|S_IRUGO|S_IWUGO, "ptmx");
 	class_simple_device_add(tty_class, MKDEV(TTYAUX_MAJOR, 2), NULL, "ptmx");
 #endif
-	
+
 #ifdef CONFIG_VT
 	strcpy(vc0_cdev.kobj.name, "dev.vc0");
 	cdev_init(&vc0_cdev, &console_fops);
diff -purN linux-post-2.6.3-20040222/drivers/ide/ide-generic.c linux-post-2.6.3-20040223/drivers/ide/ide-generic.c
--- linux-post-2.6.3-20040222/drivers/ide/ide-generic.c	2004-02-07 19:44:16.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ide/ide-generic.c	2004-02-22 17:36:17.000000000 +0000
@@ -22,9 +22,8 @@ static int __init ide_generic_init(void)
 	if (ide_hwifs[0].io_ports[IDE_DATA_OFFSET])
 		ide_release_lock();	/* for atari only */
 
-#ifdef CONFIG_PROC_FS
 	create_proc_ide_interfaces();
-#endif
+
 	return 0;
 }
 
diff -purN linux-post-2.6.3-20040222/drivers/ide/ide.c linux-post-2.6.3-20040223/drivers/ide/ide.c
--- linux-post-2.6.3-20040222/drivers/ide/ide.c	2004-02-19 01:14:51.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ide/ide.c	2004-02-22 17:36:06.000000000 +0000
@@ -995,9 +995,7 @@ found:
 
 	if (!initializing) {
 		probe_hwif_init(hwif);
-#ifdef CONFIG_PROC_FS
 		create_proc_ide_interfaces();
-#endif
 	}
 
 	if (hwifp)
diff -purN linux-post-2.6.3-20040222/drivers/ide/setup-pci.c linux-post-2.6.3-20040223/drivers/ide/setup-pci.c
--- linux-post-2.6.3-20040222/drivers/ide/setup-pci.c	2004-02-17 15:09:59.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ide/setup-pci.c	2004-02-22 17:36:33.000000000 +0000
@@ -749,6 +749,8 @@ void ide_setup_pci_device (struct pci_de
 		probe_hwif_init(&ide_hwifs[index_list.b.low]);
 	if ((index_list.b.high & 0xf0) != 0xf0)
 		probe_hwif_init(&ide_hwifs[index_list.b.high]);
+
+	create_proc_ide_interfaces();
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_pci_device);
@@ -766,6 +768,8 @@ void ide_setup_pci_devices (struct pci_d
 		probe_hwif_init(&ide_hwifs[index_list2.b.low]);
 	if ((index_list2.b.high & 0xf0) != 0xf0)
 		probe_hwif_init(&ide_hwifs[index_list2.b.high]);
+
+	create_proc_ide_interfaces();
 }
 
 EXPORT_SYMBOL_GPL(ide_setup_pci_devices);
diff -purN linux-post-2.6.3-20040222/drivers/ieee1394/Kconfig linux-post-2.6.3-20040223/drivers/ieee1394/Kconfig
--- linux-post-2.6.3-20040222/drivers/ieee1394/Kconfig	2004-02-17 12:45:23.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ieee1394/Kconfig	2004-02-21 05:09:53.000000000 +0000
@@ -1,10 +1,9 @@
 # -*- shell-script -*-
 
-menu "IEEE 1394 (FireWire) support (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
+menu "IEEE 1394 (FireWire) support"
 
 config IEEE1394
-	tristate "IEEE 1394 (FireWire) support (EXPERIMENTAL)"
+	tristate "IEEE 1394 (FireWire) support"
 	help
 	  IEEE 1394 describes a high performance serial bus, which is also
 	  known as FireWire(tm) or i.Link(tm) and is used for connecting all
@@ -108,7 +107,7 @@ config IEEE1394_SBP2_PHYS_DMA
 
 config IEEE1394_ETH1394
 	tristate "Ethernet over 1394"
-	depends on IEEE1394
+	depends on IEEE1394 && EXPERIMENTAL
 	help
 	  This driver implements a functional majority of RFC 2734: IPv4 over
 	  1394.  It will provide IP connectivity with implementations of RFC
diff -purN linux-post-2.6.3-20040222/drivers/ieee1394/eth1394.c linux-post-2.6.3-20040223/drivers/ieee1394/eth1394.c
--- linux-post-2.6.3-20040222/drivers/ieee1394/eth1394.c	2004-02-17 12:47:23.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ieee1394/eth1394.c	2004-02-21 16:44:50.000000000 +0000
@@ -411,7 +411,7 @@ static int eth1394_remove(struct device 
 	return 0;
 }
 
-static void eth1394_update(struct unit_directory *ud)
+static int eth1394_update(struct unit_directory *ud)
 {
 	struct eth1394_host_info *hi;
 	struct eth1394_priv *priv;
@@ -420,7 +420,7 @@ static void eth1394_update(struct unit_d
 
 	hi = hpsb_get_hostinfo(&eth1394_highlevel, ud->ne->host);
 	if (!hi)
-		return;
+		return -ENOENT;
 
 	priv = (struct eth1394_priv *)hi->dev->priv;
 
@@ -430,7 +430,7 @@ static void eth1394_update(struct unit_d
 		node = kmalloc(sizeof(struct eth1394_node_ref),
 			       in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
 		if (!node)
-			return;
+			return -ENOMEM;
 
 
 		node_info = kmalloc(sizeof(struct eth1394_node_info),
@@ -446,6 +446,8 @@ static void eth1394_update(struct unit_d
 		priv = (struct eth1394_priv *)hi->dev->priv;
 		list_add_tail(&node->list, &priv->ip_node_list);
 	}
+
+	return 0;
 }
 
 
@@ -604,8 +606,8 @@ static void ether1394_add_host (struct h
 		goto out;
 	}
 
-	ETH1394_PRINT (KERN_ERR, dev->name, "IEEE-1394 IPv4 over 1394 Ethernet (%s)\n",
-		       host->driver->name);
+	ETH1394_PRINT (KERN_ERR, dev->name, "IEEE-1394 IPv4 over 1394 Ethernet (fw-host%d)\n",
+		       host->id);
 
 	hi->host = host;
 	hi->dev = dev;
@@ -639,6 +641,7 @@ static void ether1394_add_host (struct h
 			       "Config ROM\n");
 		goto out;
 	}
+	hi->host->update_config_rom = 1;
 	return;
 
 out:
@@ -1681,7 +1684,7 @@ static int ether1394_tx (struct sk_buff 
 	     IN_MULTICAST(__constant_ntohl(skb->nh.iph->daddr)))) {
 		tx_type = ETH1394_GASP;
 		dest_node = LOCAL_BUS | ALL_NODES;
-		max_payload = priv->bc_maxpayload - ETHER1394_GASP_OVERHEAD;
+		max_payload = priv->bc_maxpayload;
 		BUG_ON(max_payload < (512 - ETHER1394_GASP_OVERHEAD));
 		dgl = priv->bc_dgl;
 		if (max_payload < dg_size + hdr_type_len[ETH1394_HDR_LF_UF])
diff -purN linux-post-2.6.3-20040222/drivers/ieee1394/nodemgr.c linux-post-2.6.3-20040223/drivers/ieee1394/nodemgr.c
--- linux-post-2.6.3-20040222/drivers/ieee1394/nodemgr.c	2004-02-19 19:07:58.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ieee1394/nodemgr.c	2004-02-21 15:44:40.000000000 +0000
@@ -1364,8 +1364,11 @@ static void nodemgr_ud_update_pdrv(struc
 	if (ud->device.driver) {
 		pdrv = container_of(ud->device.driver, struct hpsb_protocol_driver, driver);
 
-		if (pdrv->update)
-			pdrv->update(ud);
+		if (pdrv->update && pdrv->update(ud)) {
+			down_write(&ud->device.bus->subsys.rwsem);
+			device_release_driver(&ud->device);
+			up_write(&ud->device.bus->subsys.rwsem);
+		}
 	}
 
 	put_device(&ud->device);
diff -purN linux-post-2.6.3-20040222/drivers/ieee1394/nodemgr.h linux-post-2.6.3-20040223/drivers/ieee1394/nodemgr.h
--- linux-post-2.6.3-20040222/drivers/ieee1394/nodemgr.h	2004-02-19 15:47:32.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ieee1394/nodemgr.h	2004-02-21 15:44:40.000000000 +0000
@@ -128,9 +128,11 @@ struct hpsb_protocol_driver {
 	 * The update function is called when the node has just
 	 * survived a bus reset, i.e. it is still present on the bus.
 	 * However, it may be necessary to reestablish the connection
-	 * or login into the node again, depending on the protocol.
+	 * or login into the node again, depending on the protocol. If the
+	 * probe fails (returns non-zero), we unbind the driver from this
+	 * device.
 	 */
-	void (*update)(struct unit_directory *ud);
+	int (*update)(struct unit_directory *ud);
 
 	/* Our LDM structure */
 	struct device_driver driver;
diff -purN linux-post-2.6.3-20040222/drivers/ieee1394/ohci1394.c linux-post-2.6.3-20040223/drivers/ieee1394/ohci1394.c
--- linux-post-2.6.3-20040222/drivers/ieee1394/ohci1394.c	2004-02-17 12:47:23.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ieee1394/ohci1394.c	2004-02-22 16:08:07.000000000 +0000
@@ -523,7 +523,8 @@ static void ohci_initialize(struct ti_oh
   
 	/* Enable cycle timer and cycle master and set the IRM
 	 * contender bit in our self ID packets. */
-	reg_write(ohci, OHCI1394_LinkControlSet, 0x00300000);
+	reg_write(ohci, OHCI1394_LinkControlSet, OHCI1394_LinkControl_CycleTimerEnable |
+		  OHCI1394_LinkControl_CycleMaster);
 	set_phy_reg_mask(ohci, 4, 0xc0);
 
 	/* Clear interrupt registers */
@@ -533,8 +534,9 @@ static void ohci_initialize(struct ti_oh
 	/* Set up self-id dma buffer */
 	reg_write(ohci, OHCI1394_SelfIDBuffer, ohci->selfid_buf_bus);
 
-	/* enable self-id dma */
-	reg_write(ohci, OHCI1394_LinkControlSet, 0x00000200);
+	/* enable self-id and phys */
+	reg_write(ohci, OHCI1394_LinkControlSet, OHCI1394_LinkControl_RcvSelfID |
+		  OHCI1394_LinkControl_RcvPhyPkt);
 
 	/* Set the Config ROM mapping register */
 	reg_write(ohci, OHCI1394_ConfigROMmap, ohci->csr_config_rom_bus);
@@ -970,11 +972,15 @@ static int ohci_devctl(struct hpsb_host 
 				 */
 				DBGMSG(ohci->id, "Cycle master enabled");
 				reg_write(ohci, OHCI1394_LinkControlSet, 
-					  0x00300000);
+					  OHCI1394_LinkControl_CycleTimerEnable |
+					  OHCI1394_LinkControl_CycleMaster);
 			}
 		} else {
 			/* disable cycleTimer, cycleMaster, cycleSource */
-			reg_write(ohci, OHCI1394_LinkControlClear, 0x00700000);
+			reg_write(ohci, OHCI1394_LinkControlClear,
+				  OHCI1394_LinkControl_CycleTimerEnable |
+				  OHCI1394_LinkControl_CycleMaster |
+				  OHCI1394_LinkControl_CycleSource);
 		}
 		break;
 
@@ -3283,6 +3289,11 @@ static int __devinit ohci1394_pci_probe(
 	 * will lock up the machine.  Wait 50msec to make sure we have
 	 * full link enabled.  */
 	reg_write(ohci, OHCI1394_HCControlSet, OHCI1394_HCControl_LPS);
+
+	/* Disable and clear interrupts */
+	reg_write(ohci, OHCI1394_IntEventClear, 0xffffffff);
+	reg_write(ohci, OHCI1394_IntMaskClear, 0xffffffff);
+
 	mdelay(50);
 
 	/* Determine the number of available IR and IT contexts. */
@@ -3474,9 +3485,38 @@ static void ohci1394_pci_remove(struct p
 }
 
 
-static int ohci1394_pci_resume (struct pci_dev *dev)
+static int ohci1394_pci_resume (struct pci_dev *pdev)
 {
-	pci_enable_device(dev);
+#ifdef CONFIG_PMAC_PBOOK
+	{
+		struct device_node *of_node;
+
+		/* Re-enable 1394 */
+		of_node = pci_device_to_OF_node (pdev);
+		if (of_node)
+			pmac_call_feature (PMAC_FTR_1394_ENABLE, of_node, 0, 1);
+	}
+#endif
+
+	pci_enable_device(pdev);
+
+	return 0;
+}
+
+
+static int ohci1394_pci_suspend (struct pci_dev *pdev, u32 state)
+{
+#ifdef CONFIG_PMAC_PBOOK
+	{
+		struct device_node *of_node;
+
+		/* Disable 1394 */
+		of_node = pci_device_to_OF_node (pdev);
+		if (of_node)
+			pmac_call_feature(PMAC_FTR_1394_ENABLE, of_node, 0, 0);
+	}
+#endif
+
 	return 0;
 }
 
@@ -3503,6 +3543,7 @@ static struct pci_driver ohci1394_pci_dr
 	.probe =	ohci1394_pci_probe,
 	.remove =	ohci1394_pci_remove,
 	.resume =	ohci1394_pci_resume,
+	.suspend =	ohci1394_pci_suspend,
 };
 
 
diff -purN linux-post-2.6.3-20040222/drivers/ieee1394/ohci1394.h linux-post-2.6.3-20040223/drivers/ieee1394/ohci1394.h
--- linux-post-2.6.3-20040222/drivers/ieee1394/ohci1394.h	2003-09-02 18:08:00.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ieee1394/ohci1394.h	2004-02-22 16:08:07.000000000 +0000
@@ -320,6 +320,11 @@ static inline u32 reg_read(const struct 
 #define OHCI1394_FairnessControl              0x0DC
 #define OHCI1394_LinkControlSet               0x0E0
 #define OHCI1394_LinkControlClear             0x0E4
+#define  OHCI1394_LinkControl_RcvSelfID		0x00000200
+#define  OHCI1394_LinkControl_RcvPhyPkt		0x00000400
+#define  OHCI1394_LinkControl_CycleTimerEnable	0x00100000
+#define  OHCI1394_LinkControl_CycleMaster	0x00200000
+#define  OHCI1394_LinkControl_CycleSource	0x00400000
 #define OHCI1394_NodeID                       0x0E8
 #define OHCI1394_PhyControl                   0x0EC
 #define OHCI1394_IsochronousCycleTimer        0x0F0
diff -purN linux-post-2.6.3-20040222/drivers/ieee1394/sbp2.c linux-post-2.6.3-20040223/drivers/ieee1394/sbp2.c
--- linux-post-2.6.3-20040222/drivers/ieee1394/sbp2.c	2004-02-20 23:40:44.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ieee1394/sbp2.c	2004-02-22 00:24:52.000000000 +0000
@@ -234,6 +234,10 @@ const u8 sbp2_speedto_max_payload[] = { 
 static void sbp2_remove_host(struct hpsb_host *host);
 static void sbp2_host_reset(struct hpsb_host *host);
 
+static int sbp2_probe(struct device *dev);
+static int sbp2_remove(struct device *dev);
+static int sbp2_update(struct unit_directory *ud);
+
 static struct hpsb_highlevel sbp2_highlevel = {
 	.name =		SBP2_DEVICE_NAME,
 	.remove_host =	sbp2_remove_host,
@@ -638,28 +642,26 @@ static int sbp2_remove(struct device *de
 	return 0;
 }
 
-static void sbp2_update(struct unit_directory *ud)
+static int sbp2_update(struct unit_directory *ud)
 {
 	struct scsi_id_instance_data *scsi_id = ud->device.driver_data;
-	struct sbp2scsi_host_info *hi = scsi_id->hi;
 
 	SBP2_DEBUG("sbp2_update");
 
-	hi = scsi_id->hi;
-
 	if (sbp2_reconnect_device(scsi_id)) {
 		
 		/* 
 		 * Ok, reconnect has failed. Perhaps we didn't
-		 * reconnect fast enough. Try doing a regular login.
+		 * reconnect fast enough. Try doing a regular login, but
+		 * first do a logout just in case of any weirdness.
 		 */
 		sbp2_logout_device(scsi_id);
 
 		if (sbp2_login_device(scsi_id)) {
-			/* Login failed too, just remove the device. */
-			SBP2_ERR("sbp2_reconnect_device failed!");
-			sbp2_remove_device(scsi_id);
-			return;
+			/* Login failed too, just fail, and the backend
+			 * will call our sbp2_remove for us */
+			SBP2_INFO("sbp2_reconnect_device failed!");
+			return -EBUSY;
 		}
 	}
 
@@ -676,6 +678,8 @@ static void sbp2_update(struct unit_dire
 	 * retried) and remove them from our queue
 	 */
 	sbp2scsi_complete_all_commands(scsi_id, DID_BUS_BUSY);
+
+	return 0;
 }
 
 /* This functions is called by the sbp2_probe, for each new device. We now
@@ -727,7 +731,7 @@ static struct scsi_id_instance_data *sbp
 #ifdef CONFIG_IEEE1394_SBP2_PHYS_DMA
 		/* Handle data movement if physical dma is not
 		 * enabled/supportedon host controller */
-		hpsb_register_addrspace(&sbp2_highlevel, host, &sbp2_physdma_ops,
+		hpsb_register_addrspace(&sbp2_highlevel, ud->ne->host, &sbp2_physdma_ops,
 					0x0ULL, 0xfffffffcULL);
 #endif
 	}
@@ -1145,12 +1149,12 @@ static int sbp2_query_logins(struct scsi
 	SBP2_DEBUG("sbp2_query_logins: written");
 
 	if (sbp2util_down_timeout(&scsi_id->sbp2_login_complete, 2*HZ)) {
-		SBP2_ERR("Error querying logins to SBP-2 device - timed out");
+		SBP2_INFO("Error querying logins to SBP-2 device - timed out");
 		return(-EIO);
 	}
 
 	if (scsi_id->status_block.ORB_offset_lo != scsi_id->query_logins_orb_dma) {
-		SBP2_ERR("Error querying logins to SBP-2 device - timed out");
+		SBP2_INFO("Error querying logins to SBP-2 device - timed out");
 		return(-EIO);
 	}
 
@@ -1158,7 +1162,7 @@ static int sbp2_query_logins(struct scsi
 	    STATUS_GET_DEAD_BIT(scsi_id->status_block.ORB_offset_hi_misc) ||
 	    STATUS_GET_SBP_STATUS(scsi_id->status_block.ORB_offset_hi_misc)) {
 
-		SBP2_ERR("Error querying logins to SBP-2 device - timed out");
+		SBP2_INFO("Error querying logins to SBP-2 device - timed out");
 		return(-EIO);
 	}
 
@@ -1167,13 +1171,13 @@ static int sbp2_query_logins(struct scsi
 	SBP2_DEBUG("length_max_logins = %x",
 		   (unsigned int)scsi_id->query_logins_response->length_max_logins);
 
-	SBP2_INFO("Query logins to SBP-2 device successful");
+	SBP2_DEBUG("Query logins to SBP-2 device successful");
 
 	max_logins = RESPONSE_GET_MAX_LOGINS(scsi_id->query_logins_response->length_max_logins);
-	SBP2_INFO("Maximum concurrent logins supported: %d", max_logins);
+	SBP2_DEBUG("Maximum concurrent logins supported: %d", max_logins);
                                                                                 
 	active_logins = RESPONSE_GET_ACTIVE_LOGINS(scsi_id->query_logins_response->length_max_logins);
-	SBP2_INFO("Number of active logins: %d", active_logins);
+	SBP2_DEBUG("Number of active logins: %d", active_logins);
                                                                                 
 	if (active_logins >= max_logins) {
 		return(-EIO);
@@ -1200,7 +1204,7 @@ static int sbp2_login_device(struct scsi
 
 	if (!exclusive_login) {
 		if (sbp2_query_logins(scsi_id)) {
-			SBP2_ERR("Device does not support any more concurrent logins");
+			SBP2_INFO("Device does not support any more concurrent logins");
 			return(-EIO);
 		}
 	}
@@ -2683,6 +2687,15 @@ static void sbp2scsi_complete_command(st
 	return;
 }
 
+
+static int sbp2scsi_slave_configure (struct scsi_device *sdev)
+{
+	blk_queue_dma_alignment(sdev->request_queue, (512 - 1));
+
+	return 0;
+}
+
+
 /*
  * Called by scsi stack when something has really gone wrong.  Usually
  * called when a command has timed-out for some reason.
@@ -2798,6 +2811,7 @@ static Scsi_Host_Template scsi_driver_te
 	.eh_device_reset_handler =	sbp2scsi_reset,
 	.eh_bus_reset_handler =		sbp2scsi_reset,
 	.eh_host_reset_handler =	sbp2scsi_reset,
+	.slave_configure =		sbp2scsi_slave_configure,
 	.this_id =			-1,
 	.sg_tablesize =			SG_ALL,
 	.use_clustering =		ENABLE_CLUSTERING,
diff -purN linux-post-2.6.3-20040222/drivers/ieee1394/sbp2.h linux-post-2.6.3-20040223/drivers/ieee1394/sbp2.h
--- linux-post-2.6.3-20040222/drivers/ieee1394/sbp2.h	2004-02-20 23:35:57.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/ieee1394/sbp2.h	2004-02-21 15:44:41.000000000 +0000
@@ -439,12 +439,6 @@ static struct sbp2_command_info *sbp2uti
 static void sbp2util_mark_command_completed(struct scsi_id_instance_data *scsi_id,
 		struct sbp2_command_info *command);
 
-/*
- * IEEE-1394 core driver related prototypes
- */
-static int sbp2_probe(struct device *dev);
-static int sbp2_remove(struct device *dev);
-static void sbp2_update(struct unit_directory *ud);
 
 static int sbp2_start_device(struct scsi_id_instance_data *scsi_id);
 static void sbp2_remove_device(struct scsi_id_instance_data *scsi_id);
diff -purN linux-post-2.6.3-20040222/drivers/isdn/i4l/isdn_v110.c linux-post-2.6.3-20040223/drivers/isdn/i4l/isdn_v110.c
--- linux-post-2.6.3-20040222/drivers/isdn/i4l/isdn_v110.c	2004-02-19 03:42:12.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/isdn/i4l/isdn_v110.c	2004-02-23 05:24:14.000000000 +0000
@@ -535,13 +535,15 @@ isdn_v110_stat_callback(int idx, isdn_ct
 			if (!(v = dev->v110[idx]))
 				return 0;
 			atomic_inc(&dev->v110use[idx]);
-			if (v->skbidle > 0) {
-				v->skbidle--;
-				ret = 1;
-			} else {
-				if (v->skbuser > 0)
-					v->skbuser--;
-				ret = 0;
+			for (i=0; i * v->framelen < c->parm.length; i++) {
+				if (v->skbidle > 0) {
+					v->skbidle--;
+					ret = 1;
+				} else {
+					if (v->skbuser > 0)
+						v->skbuser--;
+					ret = 0;
+				}
 			}
 			for (i = v->skbuser + v->skbidle; i < 2; i++) {
 				struct sk_buff *skb;
diff -purN linux-post-2.6.3-20040222/drivers/macintosh/macio_asic.c linux-post-2.6.3-20040223/drivers/macintosh/macio_asic.c
--- linux-post-2.6.3-20040222/drivers/macintosh/macio_asic.c	2004-02-12 04:47:10.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/macintosh/macio_asic.c	2004-02-23 14:09:16.000000000 +0000
@@ -23,7 +23,7 @@
 #include <asm/prom.h>
 #include <asm/pci-bridge.h>
 
-#define DEBUG
+#undef DEBUG
 
 #define MAX_NODE_NAME_SIZE (BUS_ID_SIZE - 12)
 
diff -purN linux-post-2.6.3-20040222/drivers/macintosh/macserial.c linux-post-2.6.3-20040223/drivers/macintosh/macserial.c
--- linux-post-2.6.3-20040222/drivers/macintosh/macserial.c	2003-09-24 06:15:15.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/macintosh/macserial.c	2004-02-23 03:08:27.000000000 +0000
@@ -1777,47 +1777,65 @@ static int get_lsr_info(struct mac_seria
 	return put_user(status,value);
 }
 
-static int get_modem_info(struct mac_serial *info, unsigned int *value)
+static int rs_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct mac_serial * info = (struct mac_serial *)tty->driver_data;
 	unsigned char control, status;
-	unsigned int result;
 	unsigned long flags;
 
+#ifdef CONFIG_KGDB
+	if (info->kgdb_channel)
+		return -ENODEV;
+#endif
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+	    (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT)) {
+		if (tty->flags & (1 << TTY_IO_ERROR))
+		    return -EIO;
+	}
+
 	spin_lock_irqsave(&info->lock, flags);
 	control = info->curregs[5];
 	status = read_zsreg(info->zs_channel, 0);
 	spin_unlock_irqrestore(&info->lock, flags);
-	result =  ((control & RTS) ? TIOCM_RTS: 0)
+	return    ((control & RTS) ? TIOCM_RTS: 0)
 		| ((control & DTR) ? TIOCM_DTR: 0)
 		| ((status  & DCD) ? TIOCM_CAR: 0)
 		| ((status  & CTS) ? 0: TIOCM_CTS);
-	return put_user(result,value);
 }
 
-static int set_modem_info(struct mac_serial *info, unsigned int cmd,
-			  unsigned int *value)
+static int rs_tiocmset(struct tty_struct *tty, struct file *file,
+		       unsigned int set, unsigned int clear)
 {
+	struct mac_serial * info = (struct mac_serial *)tty->driver_data;
 	unsigned int arg, bits;
 	unsigned long flags;
 
-	if (get_user(arg, value))
-		return -EFAULT;
-	bits = (arg & TIOCM_RTS? RTS: 0) + (arg & TIOCM_DTR? DTR: 0);
-	spin_lock_irqsave(&info->lock, flags);
-	switch (cmd) {
-	case TIOCMBIS:
-		info->curregs[5] |= bits;
-		break;
-	case TIOCMBIC:
-		info->curregs[5] &= ~bits;
-		break;
-	case TIOCMSET:
-		info->curregs[5] = (info->curregs[5] & ~(DTR | RTS)) | bits;
-		break;
-	default:
-		spin_unlock_irqrestore(&info->lock, flags);
-		return -EINVAL;
+#ifdef CONFIG_KGDB
+	if (info->kgdb_channel)
+		return -ENODEV;
+#endif
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+	    (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT)) {
+		if (tty->flags & (1 << TTY_IO_ERROR))
+		    return -EIO;
 	}
+
+	spin_lock_irqsave(&info->lock, flags);
+	if (set & TIOCM_RTS)
+		info->curregs[5] |= RTS;
+	if (set & TIOCM_DTR)
+		info->curregs[5] |= DTR;
+	if (clear & TIOCM_RTS)
+		info->curregs[5] &= ~RTS;
+	if (clear & TIOCM_DTR)
+		info->curregs[5] &= ~DTR;
+
 	info->pendregs[5] = info->curregs[5];
 	write_zsreg(info->zs_channel, 5, info->curregs[5]);
 	spin_unlock_irqrestore(&info->lock, flags);
@@ -1863,12 +1881,6 @@ static int rs_ioctl(struct tty_struct *t
 	}
 
 	switch (cmd) {
-		case TIOCMGET:
-			return get_modem_info(info, (unsigned int *) arg);
-		case TIOCMBIS:
-		case TIOCMBIC:
-		case TIOCMSET:
-			return set_modem_info(info, cmd, (unsigned int *) arg);
 		case TIOCGSERIAL:
 			return get_serial_info(info,
 					(struct serial_struct __user *) arg);
@@ -2488,6 +2500,8 @@ static struct tty_operations serial_ops 
 	.break_ctl = rs_break,
 	.wait_until_sent = rs_wait_until_sent,
 	.read_proc = macserial_read_proc,
+	.tiocmget = rs_tiocmget,
+	.tiocmset = rs_tiocmset,
 };
 
 static int macserial_init(void)
diff -purN linux-post-2.6.3-20040222/drivers/media/video/saa5249.c linux-post-2.6.3-20040223/drivers/media/video/saa5249.c
--- linux-post-2.6.3-20040222/drivers/media/video/saa5249.c	2003-10-29 15:50:27.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/media/video/saa5249.c	2004-02-23 05:24:14.000000000 +0000
@@ -122,10 +122,6 @@ struct saa5249_device
 #define FALSE 0
 #define TRUE 1
 #endif
-#ifndef MIN
-#define MIN(a, b) ((a) < (b) ? (a) : (b))
-#define MAX(a, b) ((a) > (b) ? (a) : (b))
-#endif
 
 #define RESCHED do { cond_resched(); } while(0)
 
@@ -518,8 +514,8 @@ static int do_saa5249_ioctl(struct inode
 			{
 				int len;
 				char buf[16];  
-				start = MAX(req->start, 32);
-				end = MIN(req->end, 39);
+				start = max(req->start, 32);
+				end = min(req->end, 39);
 				len=end-start+1;
 				if (i2c_senddata(t, 8, 0, 0, start, -1) ||
 					i2c_getdata(t, len, buf))
@@ -532,8 +528,8 @@ static int do_saa5249_ioctl(struct inode
 			{
 				char buf[32];
 				int len;
-				start = MAX(req->start, 7);
-				end = MIN(req->end, 31);
+				start = max(req->start, 7);
+				end = min(req->end, 31);
 				len=end-start+1;
 				if (i2c_senddata(t, 8, 0, 0, start, -1) ||
 					i2c_getdata(t, len, buf))
diff -purN linux-post-2.6.3-20040222/drivers/parport/Kconfig linux-post-2.6.3-20040223/drivers/parport/Kconfig
--- linux-post-2.6.3-20040222/drivers/parport/Kconfig	2003-09-12 03:19:35.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/parport/Kconfig	2004-02-23 05:24:06.000000000 +0000
@@ -102,7 +102,7 @@ config PARPORT_AMIGA
 
 config PARPORT_MFC3
 	tristate "Multiface III parallel port"
-	depends on AMIGA && ZORRO && PARPORT
+	depends on ZORRO && PARPORT
 	help
 	  Say Y here if you need parallel port support for the MFC3 card.
 	  This code is also available as a module (say M), called
diff -purN linux-post-2.6.3-20040222/drivers/pcmcia/sa1100_neponset.c linux-post-2.6.3-20040223/drivers/pcmcia/sa1100_neponset.c
--- linux-post-2.6.3-20040222/drivers/pcmcia/sa1100_neponset.c	2003-03-30 08:13:49.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/pcmcia/sa1100_neponset.c	2004-02-22 16:34:29.000000000 +0000
@@ -49,7 +49,7 @@ neponset_pcmcia_configure_socket(struct 
 
 	switch (skt->nr) {
 	case 0:
-		pa_dwr_mask = GPIO_GPIO0 | GPIO_GPIO1;
+		pa_dwr_mask = GPIO_A0 | GPIO_A1;
 		ncr_mask = NCR_A0VPP | NCR_A1VPP;
 
 		if (state->Vpp == 0)
@@ -66,7 +66,7 @@ neponset_pcmcia_configure_socket(struct 
 		break;
 
 	case 1:
-		pa_dwr_mask = GPIO_GPIO2 | GPIO_GPIO3;
+		pa_dwr_mask = GPIO_A2 | GPIO_A3;
 		ncr_mask = 0;
 		ncr_set = 0;
 
@@ -87,9 +87,9 @@ neponset_pcmcia_configure_socket(struct 
 	 */
 	switch (state->Vcc) {
 	default:
-	case 0:  pa_dwr_set = 0;			break;
-	case 33: pa_dwr_set = GPIO_GPIO1|GPIO_GPIO2;	break;
-	case 50: pa_dwr_set = GPIO_GPIO0|GPIO_GPIO3;	break;
+	case 0:  pa_dwr_set = 0;		break;
+	case 33: pa_dwr_set = GPIO_A1|GPIO_A2;	break;
+	case 50: pa_dwr_set = GPIO_A0|GPIO_A3;	break;
 	}
 
 	ret = sa1111_pcmcia_configure_socket(skt, state);
@@ -99,8 +99,8 @@ neponset_pcmcia_configure_socket(struct 
 		local_irq_save(flags);
 		NCR_0 = (NCR_0 & ~ncr_mask) | ncr_set;
 
-		PA_DWR = (PA_DWR & ~pa_dwr_mask) | (pa_dwr_set & pa_dwr_mask);
 		local_irq_restore(flags);
+		sa1111_set_io(SA1111_DEV(skt->dev), pa_dwr_mask, pa_dwr_set);
 	}
 
 	return 0;
@@ -111,33 +111,32 @@ static void neponset_pcmcia_socket_init(
 	if (skt->nr == 0)
 		NCR_0 &= ~(NCR_A0VPP | NCR_A1VPP);
 
-        sa1111_pcmcia_socket_init(skt);
+	sa1111_pcmcia_socket_init(skt);
 }
 
 static struct pcmcia_low_level neponset_pcmcia_ops = {
-        .owner                  = THIS_MODULE,
-        .hw_init                = sa1111_pcmcia_hw_init,
-        .hw_shutdown            = sa1111_pcmcia_hw_shutdown,
-        .socket_state           = sa1111_pcmcia_socket_state,
-        .configure_socket       = neponset_pcmcia_configure_socket,
-        .socket_init            = neponset_pcmcia_socket_init,
-        .socket_suspend         = sa1111_pcmcia_socket_suspend,
+	.owner			= THIS_MODULE,
+	.hw_init		= sa1111_pcmcia_hw_init,
+	.hw_shutdown		= sa1111_pcmcia_hw_shutdown,
+	.socket_state		= sa1111_pcmcia_socket_state,
+	.configure_socket	= neponset_pcmcia_configure_socket,
+	.socket_init		= neponset_pcmcia_socket_init,
+	.socket_suspend 	= sa1111_pcmcia_socket_suspend,
 };
 
-int __init pcmcia_neponset_init(struct device *dev)
+int __init pcmcia_neponset_init(struct sa1111_dev *sadev)
 {
-        int ret = -ENODEV;
+	int ret = -ENODEV;
 
-        if (machine_is_assabet()) {
-                /*
-                 * Set GPIO_A<3:0> to be outputs for the MAX1600,
-                 * and switch to standby mode.
-                 */
-                PA_DDR = 0;
-                PA_DWR = 0;
-		PA_SDR = 0;
-		PA_SSR = 0;
-		ret = sa11xx_drv_pcmcia_probe(dev, &neponset_pcmcia_ops, 0, 2);
+	if (machine_is_assabet()) {
+		/*
+		 * Set GPIO_A<3:0> to be outputs for the MAX1600,
+		 * and switch to standby mode.
+		 */
+		sa1111_set_io_dir(sadev, GPIO_A0|GPIO_A1|GPIO_A2|GPIO_A3, 0, 0);
+		sa1111_set_io(sadev, GPIO_A0|GPIO_A1|GPIO_A2|GPIO_A3, 0);
+		sa1111_set_sleep_io(sadev, GPIO_A0|GPIO_A1|GPIO_A2|GPIO_A3, 0);
+		ret = sa11xx_drv_pcmcia_probe(&sadev->dev, &neponset_pcmcia_ops, 0, 2);
 	}
 
 	return ret;
diff -purN linux-post-2.6.3-20040222/drivers/pcmcia/sa1111_generic.c linux-post-2.6.3-20040223/drivers/pcmcia/sa1111_generic.c
--- linux-post-2.6.3-20040222/drivers/pcmcia/sa1111_generic.c	2003-09-20 09:42:46.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/pcmcia/sa1111_generic.c	2004-02-22 16:34:29.000000000 +0000
@@ -149,7 +149,7 @@ static int pcmcia_probe(struct sa1111_de
 	pcmcia_jornada720_init(&dev->dev);
 #endif
 #ifdef CONFIG_ASSABET_NEPONSET
-	pcmcia_neponset_init(&dev->dev);
+	pcmcia_neponset_init(dev);
 #endif
 #ifdef CONFIG_SA1100_PFS168
 	pcmcia_pfs_init(&dev->dev);
diff -purN linux-post-2.6.3-20040222/drivers/pcmcia/sa1111_generic.h linux-post-2.6.3-20040223/drivers/pcmcia/sa1111_generic.h
--- linux-post-2.6.3-20040222/drivers/pcmcia/sa1111_generic.h	2003-04-11 18:36:50.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/pcmcia/sa1111_generic.h	2004-02-22 16:34:29.000000000 +0000
@@ -9,5 +9,5 @@ extern void sa1111_pcmcia_socket_suspend
 
 extern int pcmcia_badge4_init(struct device *);
 extern int pcmcia_jornada720_init(struct device *);
-extern int pcmcia_neponset_init(struct device *);
+extern int pcmcia_neponset_init(struct sa1111_dev *);
 
diff -purN linux-post-2.6.3-20040222/drivers/pcmcia/sa11xx_core.c linux-post-2.6.3-20040223/drivers/pcmcia/sa11xx_core.c
--- linux-post-2.6.3-20040222/drivers/pcmcia/sa11xx_core.c	2003-09-27 23:04:09.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/pcmcia/sa11xx_core.c	2004-02-22 16:58:39.000000000 +0000
@@ -58,14 +58,6 @@
 static int pc_debug;
 #endif
 
-/* This structure maintains housekeeping state for each socket, such
- * as the last known values of the card detect pins, or the Card Services
- * callback value associated with the socket:
- */
-static struct sa1100_pcmcia_socket sa1100_pcmcia_socket[SA1100_PCMCIA_MAX_SOCK];
-
-#define PCMCIA_SOCKET(x)	(sa1100_pcmcia_socket + (x))
-
 #define to_sa1100_socket(x)	container_of(x, struct sa1100_pcmcia_socket, socket)
 
 /*
@@ -682,6 +674,9 @@ void sa11xx_enable_irqs(struct sa1100_pc
 }
 EXPORT_SYMBOL(sa11xx_enable_irqs);
 
+static LIST_HEAD(sa1100_sockets);
+static DECLARE_MUTEX(sa1100_sockets_lock);
+
 static const char *skt_names[] = {
 	"PCMCIA socket 0",
 	"PCMCIA socket 1",
@@ -689,8 +684,12 @@ static const char *skt_names[] = {
 
 struct skt_dev_info {
 	int nskt;
+	struct sa1100_pcmcia_socket skt[0];
 };
 
+#define SKT_DEV_INFO_SIZE(n) \
+	(sizeof(struct skt_dev_info) + (n)*sizeof(struct sa1100_pcmcia_socket))
+
 int sa11xx_drv_pcmcia_probe(struct device *dev, struct pcmcia_low_level *ops, int first, int nr)
 {
 	struct skt_dev_info *sinfo;
@@ -704,13 +703,15 @@ int sa11xx_drv_pcmcia_probe(struct devic
 	if (!ops->socket_get_timing)
 		ops->socket_get_timing = sa1100_pcmcia_default_mecr_timing;
 
-	sinfo = kmalloc(sizeof(struct skt_dev_info), GFP_KERNEL);
+	down(&sa1100_sockets_lock);
+
+	sinfo = kmalloc(SKT_DEV_INFO_SIZE(nr), GFP_KERNEL);
 	if (!sinfo) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
-	memset(sinfo, 0, sizeof(struct skt_dev_info));
+	memset(sinfo, 0, SKT_DEV_INFO_SIZE(nr));
 	sinfo->nskt = nr;
 
 	cpu_clock = cpufreq_get(0);
@@ -719,8 +720,7 @@ int sa11xx_drv_pcmcia_probe(struct devic
 	 * Initialise the per-socket structure.
 	 */
 	for (i = 0; i < nr; i++) {
-		struct sa1100_pcmcia_socket *skt = PCMCIA_SOCKET(i);
-		memset(skt, 0, sizeof(*skt));
+		struct sa1100_pcmcia_socket *skt = &sinfo->skt[i];
 
 		skt->socket.ops = &sa11xx_pcmcia_operations;
 		skt->socket.owner = ops->owner;
@@ -778,6 +778,8 @@ int sa11xx_drv_pcmcia_probe(struct devic
 			goto out_err_5;
 		}
 
+		list_add(&skt->node, &sa1100_sockets);
+
 		/*
 		 * We initialize the MECR to default values here, because
 		 * we are not guaranteed to see a SetIOMap operation at
@@ -809,10 +811,11 @@ int sa11xx_drv_pcmcia_probe(struct devic
 	}
 
 	dev_set_drvdata(dev, sinfo);
-	return 0;
+	ret = 0;
+	goto out;
 
 	do {
-		struct sa1100_pcmcia_socket *skt = PCMCIA_SOCKET(i);
+		struct sa1100_pcmcia_socket *skt = &sinfo->skt[i];
 
 		del_timer_sync(&skt->poll_timer);
 		pcmcia_unregister_socket(&skt->socket);
@@ -822,6 +825,7 @@ int sa11xx_drv_pcmcia_probe(struct devic
 
 		ops->hw_shutdown(skt);
  out_err_6:
+ 		list_del(&skt->node);
 		iounmap(skt->virt_io);
  out_err_5:
 		release_resource(&skt->res_attr);
@@ -838,6 +842,7 @@ int sa11xx_drv_pcmcia_probe(struct devic
 	kfree(sinfo);
 
  out:
+	up(&sa1100_sockets_lock);
 	return ret;
 }
 EXPORT_SYMBOL(sa11xx_drv_pcmcia_probe);
@@ -849,8 +854,9 @@ int sa11xx_drv_pcmcia_remove(struct devi
 
 	dev_set_drvdata(dev, NULL);
 
+	down(&sa1100_sockets_lock);
 	for (i = 0; i < sinfo->nskt; i++) {
-		struct sa1100_pcmcia_socket *skt = PCMCIA_SOCKET(i);
+		struct sa1100_pcmcia_socket *skt = &sinfo->skt[i];
 
 		del_timer_sync(&skt->poll_timer);
 
@@ -862,6 +868,7 @@ int sa11xx_drv_pcmcia_remove(struct devi
 
 		sa1100_pcmcia_config_skt(skt, &dead_socket);
 
+		list_del(&skt->node);
 		iounmap(skt->virt_io);
 		skt->virt_io = NULL;
 		release_resource(&skt->res_attr);
@@ -869,6 +876,7 @@ int sa11xx_drv_pcmcia_remove(struct devi
 		release_resource(&skt->res_io);
 		release_resource(&skt->res_skt);
 	}
+	up(&sa1100_sockets_lock);
 
 	kfree(sinfo);
 
@@ -886,13 +894,12 @@ EXPORT_SYMBOL(sa11xx_drv_pcmcia_remove);
  */
 static void sa1100_pcmcia_update_mecr(unsigned int clock)
 {
-	unsigned int sock;
+	struct sa1100_pcmcia_socket *skt;
 
-	for (sock = 0; sock < SA1100_PCMCIA_MAX_SOCK; ++sock) {
-		struct sa1100_pcmcia_socket *skt = PCMCIA_SOCKET(sock);
-		if (skt->ops)
-			sa1100_pcmcia_set_mecr(skt, clock);
-	}
+	down(&sa1100_sockets_lock);
+	list_for_each_entry(skt, &sa1100_sockets, node)
+		sa1100_pcmcia_set_mecr(skt, clock);
+	up(&sa1100_sockets_lock);
 }
 
 /* sa1100_pcmcia_notifier()
diff -purN linux-post-2.6.3-20040222/drivers/pcmcia/sa11xx_core.h linux-post-2.6.3-20040223/drivers/pcmcia/sa11xx_core.h
--- linux-post-2.6.3-20040222/drivers/pcmcia/sa11xx_core.h	2003-06-30 20:32:59.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/pcmcia/sa11xx_core.h	2004-02-22 16:58:39.000000000 +0000
@@ -73,6 +73,7 @@ struct sa1100_pcmcia_socket {
 	unsigned int		irq_state;
 
 	struct timer_list	poll_timer;
+	struct list_head	node;
 };
 
 struct pcmcia_low_level {
diff -purN linux-post-2.6.3-20040222/drivers/sbus/char/aurora.c linux-post-2.6.3-20040223/drivers/sbus/char/aurora.c
--- linux-post-2.6.3-20040222/drivers/sbus/char/aurora.c	2003-06-11 19:32:35.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/sbus/char/aurora.c	2004-02-23 03:09:24.000000000 +0000
@@ -1752,8 +1752,9 @@ static void aurora_flush_buffer(struct t
 #endif
 }
 
-static int aurora_get_modem_info(struct Aurora_port * port, unsigned int *value)
+static int aurora_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct Aurora_port *port = (struct Aurora_port *) tty->driver_data;
 	struct Aurora_board * bp;
 	unsigned char status,chip;
 	unsigned int result;
@@ -1762,6 +1763,9 @@ static int aurora_get_modem_info(struct 
 #ifdef AURORA_DEBUG
 	printk("aurora_get_modem_info: start\n");
 #endif
+	if ((aurora_paranoia_check(port, tty->name, __FUNCTION__))
+		return -ENODEV;
+
 	chip = AURORA_CD180(port_No(port));
 
 	bp = port_Board(port);
@@ -1782,16 +1786,16 @@ static int aurora_get_modem_info(struct 
 		| ((status & MSVR_DSR) ? TIOCM_DSR : 0)
 		| ((status & MSVR_CTS) ? TIOCM_CTS : 0);
 
-	put_user(result,(unsigned long *) value);
 #ifdef AURORA_DEBUG
 	printk("aurora_get_modem_info: end\n");
 #endif
-	return 0;
+	return result;
 }
 
-static int aurora_set_modem_info(struct Aurora_port * port, unsigned int cmd,
-				 unsigned int *value)
+static int aurora_tiocmset(struct tty_struct *tty, struct file *file,
+			   unsigned int set, unsigned int clear)
 {
+	struct Aurora_port *port = (struct Aurora_port *) tty->driver_data;
 	unsigned int arg;
 	unsigned long flags;
 	struct Aurora_board *bp = port_Board(port);
@@ -1800,33 +1804,20 @@ static int aurora_set_modem_info(struct 
 #ifdef AURORA_DEBUG
 	printk("aurora_set_modem_info: start\n");
 #endif
-	if (get_user(arg, value))
-		return -EFAULT;
+	if ((aurora_paranoia_check(port, tty->name, __FUNCTION__))
+		return -ENODEV;
+
 	chip = AURORA_CD180(port_No(port));
-	switch (cmd) {
-	 case TIOCMBIS: 
-		if (arg & TIOCM_RTS) 
-			port->MSVR |= bp->RTS;
-		if (arg & TIOCM_DTR)
-			port->MSVR |= bp->DTR;
-		break;
-	case TIOCMBIC:
-		if (arg & TIOCM_RTS)
-			port->MSVR &= ~bp->RTS;
-		if (arg & TIOCM_DTR)
-			port->MSVR &= ~bp->DTR;
-		break;
-	case TIOCMSET:
-		port->MSVR = (arg & TIOCM_RTS) ? (port->MSVR | bp->RTS) : 
-					         (port->MSVR & ~bp->RTS);
-		port->MSVR = (arg & TIOCM_DTR) ? (port->MSVR | bp->RTS) :
-						 (port->MSVR & ~bp->RTS);
-		break;
-	 default:
-		return -EINVAL;
-	};
 
 	save_flags(flags); cli();
+	if (set & TIOCM_RTS)
+		port->MSVR |= bp->RTS;
+	if (set & TIOCM_DTR)
+		port->MSVR |= bp->DTR;
+	if (clear & TIOCM_RTS)
+		port->MSVR &= ~bp->RTS;
+	if (clear & TIOCM_DTR)
+		port->MSVR &= ~bp->DTR;
 
 	sbus_writeb(port_No(port) & 7, &bp->r[chip]->r[CD180_CAR]);
 	udelay(1);
@@ -1993,16 +1984,6 @@ static int aurora_ioctl(struct tty_struc
 			((tty->termios->c_cflag & ~CLOCAL) |
 			 (arg ? CLOCAL : 0));
 		return 0;
-	case TIOCMGET:
-		retval = verify_area(VERIFY_WRITE, (void *) arg,
-				    sizeof(unsigned int));
-		if (retval)
-			return retval;
-		return aurora_get_modem_info(port, (unsigned int *) arg);
-	case TIOCMBIS:
-	case TIOCMBIC:
-	case TIOCMSET:
-		return aurora_set_modem_info(port, cmd, (unsigned int *) arg);
 	case TIOCGSERIAL:	
 		return aurora_get_serial_info(port, (struct serial_struct *) arg);
 	case TIOCSSERIAL:	
@@ -2268,6 +2249,8 @@ static struct tty_operations aurora_ops 
 	.stop = aurora_stop,
 	.start = aurora_start,
 	.hangup = aurora_hangup,
+	.tiocmget = aurora_tiocmget,
+	.tiocmset = aurora_tiocmset,
 };
 
 static int aurora_init_drivers(void)
diff -purN linux-post-2.6.3-20040222/drivers/serial/68360serial.c linux-post-2.6.3-20040223/drivers/serial/68360serial.c
--- linux-post-2.6.3-20040222/drivers/serial/68360serial.c	2003-06-11 19:32:34.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/serial/68360serial.c	2004-02-23 03:09:24.000000000 +0000
@@ -1282,12 +1282,19 @@ static int get_lsr_info(struct async_str
 }
 #endif
 
-static int get_modem_info(ser_info_t *info, unsigned int *value)
+static int rs_360_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	ser_info_t *info = (ser_info_t *)tty->driver_data;
 	unsigned int result = 0;
 #ifdef modem_control
 	unsigned char control, status;
 
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
+
 	control = info->MCR;
 	local_irq_disable();
 	status = serial_in(info, UART_MSR);
@@ -1303,63 +1310,42 @@ static int get_modem_info(ser_info_t *in
 		| ((status  & UART_MSR_DSR) ? TIOCM_DSR : 0)
 		| ((status  & UART_MSR_CTS) ? TIOCM_CTS : 0);
 #endif
-	/* return put_user(result,value); */
-	put_user(result,value);
-	return (0);
+	return result;
 }
 
-static int set_modem_info(ser_info_t *info, unsigned int cmd,
-			  unsigned int *value)
+static int rs_360_tiocmset(struct tty_struct *tty, struct file *file,
+			   unsigned int set, unsigned int clear)
 {
-	int error;
- 	unsigned int arg; 
-
-	error = get_user(arg,value);
-	if (error)
-		return error;
 #ifdef modem_control
-	switch (cmd) {
-	case TIOCMBIS: 
-		if (arg & TIOCM_RTS)
-			info->MCR |= UART_MCR_RTS;
-		if (arg & TIOCM_DTR)
-			info->MCR |= UART_MCR_DTR;
-#ifdef TIOCM_OUT1
-		if (arg & TIOCM_OUT1)
-			info->MCR |= UART_MCR_OUT1;
-		if (arg & TIOCM_OUT2)
-			info->MCR |= UART_MCR_OUT2;
-#endif
-		break;
-	case TIOCMBIC:
-		if (arg & TIOCM_RTS)
-			info->MCR &= ~UART_MCR_RTS;
-		if (arg & TIOCM_DTR)
-			info->MCR &= ~UART_MCR_DTR;
-#ifdef TIOCM_OUT1
-		if (arg & TIOCM_OUT1)
-			info->MCR &= ~UART_MCR_OUT1;
-		if (arg & TIOCM_OUT2)
-			info->MCR &= ~UART_MCR_OUT2;
-#endif
-		break;
-	case TIOCMSET:
-		info->MCR = ((info->MCR & ~(UART_MCR_RTS |
-#ifdef TIOCM_OUT1
-					    UART_MCR_OUT1 |
-					    UART_MCR_OUT2 |
-#endif
-					    UART_MCR_DTR))
-			     | ((arg & TIOCM_RTS) ? UART_MCR_RTS : 0)
+	ser_info_t *info = (ser_info_t *)tty->driver_data;
+ 	unsigned int arg;
+
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
+
+ 	if (set & TIOCM_RTS)
+ 		info->mcr |= UART_MCR_RTS;
+ 	if (set & TIOCM_DTR)
+ 		info->mcr |= UART_MCR_DTR;
+	if (clear & TIOCM_RTS)
+		info->MCR &= ~UART_MCR_RTS;
+	if (clear & TIOCM_DTR)
+		info->MCR &= ~UART_MCR_DTR;
+
 #ifdef TIOCM_OUT1
-			     | ((arg & TIOCM_OUT1) ? UART_MCR_OUT1 : 0)
-			     | ((arg & TIOCM_OUT2) ? UART_MCR_OUT2 : 0)
+	if (set & TIOCM_OUT1)
+		info->MCR |= UART_MCR_OUT1;
+	if (set & TIOCM_OUT2)
+		info->MCR |= UART_MCR_OUT2;
+	if (clear & TIOCM_OUT1)
+		info->MCR &= ~UART_MCR_OUT1;
+	if (clear & TIOCM_OUT2)
+		info->MCR &= ~UART_MCR_OUT2;
 #endif
-			     | ((arg & TIOCM_DTR) ? UART_MCR_DTR : 0));
-		break;
-	default:
-		return -EINVAL;
-	}
+
 	local_irq_disable();
 	serial_out(info, UART_MCR, info->MCR);
 	local_irq_enable();
@@ -1506,12 +1492,6 @@ static int rs_360_ioctl(struct tty_struc
 				((tty->termios->c_cflag & ~CLOCAL) |
 				 (arg ? CLOCAL : 0));
 			return 0;
-		case TIOCMGET:
-			return get_modem_info(info, (unsigned int *) arg);
-		case TIOCMBIS:
-		case TIOCMBIC:
-		case TIOCMSET:
-			return set_modem_info(info, cmd, (unsigned int *) arg);
 #ifdef maybe
 		case TIOCSERGETLSR: /* Get line status register */
 			return get_lsr_info(info, (unsigned int *) arg);
@@ -2513,6 +2493,8 @@ static struct tty_operations rs_360_ops 
 	.hangup = rs_360_hangup,
 	/* .wait_until_sent = rs_360_wait_until_sent, */
 	/* .read_proc = rs_360_read_proc, */
+	.tiocmget = rs_360_tiocmget,
+	.tiocmset = rs_360_tiocmset,
 };
 
 /* int __init rs_360_init(void) */
diff -purN linux-post-2.6.3-20040222/drivers/serial/mcfserial.c linux-post-2.6.3-20040223/drivers/serial/mcfserial.c
--- linux-post-2.6.3-20040222/drivers/serial/mcfserial.c	2003-07-03 01:18:07.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/serial/mcfserial.c	2004-02-23 03:08:32.000000000 +0000
@@ -985,13 +985,51 @@ static void send_break(	struct mcf_seria
 	local_irq_restore(flags);
 }
 
+static int mcfrs_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct mcf_serial * info = (struct mcf_serial *)tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->name, "mcfrs_ioctl"))
+		return -ENODEV;
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
+
+	return mcfrs_getsignals(info);
+}
+
+static int mcfrs_tiocmset(struct tty_struct *tty, struct file *file,
+			  unsigned int set, unsigned int clear)
+{
+	struct mcf_serial * info = (struct mcf_serial *)tty->driver_data;
+	int rts = -1, dtr = -1;
+
+	if (serial_paranoia_check(info, tty->name, "mcfrs_ioctl"))
+		return -ENODEV;
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
+
+	if (set & TIOCM_RTS)
+		rts = 1;
+	if (set & TIOCM_DTR)
+		dtr = 1;
+	if (clear & TIOCM_RTS)
+		rts = 0;
+	if (clear & TIOCM_DTR)
+		dtr = 0;
+
+	mcfrs_setsignals(info, dtr, rts);
+
+	return 0;
+}
+
 static int mcfrs_ioctl(struct tty_struct *tty, struct file * file,
 		    unsigned int cmd, unsigned long arg)
 {
 	struct mcf_serial * info = (struct mcf_serial *)tty->driver_data;
+#ifdef TIOCSET422
 	unsigned int val;
+#endif
 	int retval, error;
-	int dtr, rts;
 
 	if (serial_paranoia_check(info, tty->name, "mcfrs_ioctl"))
 		return -ENODEV;
@@ -1059,45 +1097,6 @@ static int mcfrs_ioctl(struct tty_struct
 				    info, sizeof(struct mcf_serial));
 			return 0;
 			
-		case TIOCMGET:
-			if ((error = verify_area(VERIFY_WRITE, (void *) arg,
-                            sizeof(unsigned int))))
-                                return(error);
-			val = mcfrs_getsignals(info);
-			put_user(val, (unsigned int *) arg);
-			break;
-
-                case TIOCMBIS:
-			if ((error = verify_area(VERIFY_WRITE, (void *) arg,
-                            sizeof(unsigned int))))
-				return(error);
-
-			get_user(val, (unsigned int *) arg);
-			rts = (val & TIOCM_RTS) ? 1 : -1;
-			dtr = (val & TIOCM_DTR) ? 1 : -1;
-			mcfrs_setsignals(info, dtr, rts);
-			break;
-
-                case TIOCMBIC:
-			if ((error = verify_area(VERIFY_WRITE, (void *) arg,
-                            sizeof(unsigned int))))
-				return(error);
-			get_user(val, (unsigned int *) arg);
-			rts = (val & TIOCM_RTS) ? 0 : -1;
-			dtr = (val & TIOCM_DTR) ? 0 : -1;
-			mcfrs_setsignals(info, dtr, rts);
-			break;
-
-                case TIOCMSET:
-			if ((error = verify_area(VERIFY_WRITE, (void *) arg,
-                            sizeof(unsigned int))))
-				return(error);
-			get_user(val, (unsigned int *) arg);
-			rts = (val & TIOCM_RTS) ? 1 : 0;
-			dtr = (val & TIOCM_DTR) ? 1 : 0;
-			mcfrs_setsignals(info, dtr, rts);
-			break;
-
 #ifdef TIOCSET422
 		case TIOCSET422:
 			get_user(val, (unsigned int *) arg);
@@ -1563,6 +1562,8 @@ static struct tty_operations mcfrs_ops =
 	.start = mcfrs_start,
 	.hangup = mcfrs_hangup,
 	.read_proc = mcfrs_readproc,
+	.tiocmget = mcfrs_tiocmget,
+	.tiocmset = mcfrs_tiocmset,
 };
 
 /* mcfrs_init inits the driver */
diff -purN linux-post-2.6.3-20040222/drivers/tc/zs.c linux-post-2.6.3-20040223/drivers/tc/zs.c
--- linux-post-2.6.3-20040222/drivers/tc/zs.c	2003-09-25 23:38:44.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/tc/zs.c	2004-02-23 03:09:24.000000000 +0000
@@ -1176,11 +1176,21 @@ static int get_lsr_info(struct dec_seria
 	return 0;
 }
 
-static int get_modem_info(struct dec_serial *info, unsigned int *value)
+static int rs_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct dec_serial * info = (struct dec_serial *)tty->driver_data;
 	unsigned char control, status_a, status_b;
 	unsigned int result;
 
+	if (info->hook)
+		return -ENODEV;
+
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
+
 	if (info->zs_channel == info->zs_chan_a)
 		result = 0;
 	else {
@@ -1196,41 +1206,37 @@ static int get_modem_info(struct dec_ser
 			| ((status_a & SYNC_HUNT) ? TIOCM_DSR: 0)
 			| ((status_b & CTS) ? TIOCM_CTS: 0);
 	}
-	put_user(result, value);
-	return 0;
+	return result;
 }
 
-static int set_modem_info(struct dec_serial *info, unsigned int cmd,
-			  unsigned int *value)
+static int rs_tiocmset(struct tty_struct *tty, struct file *file,
+		       unsigned int set, unsigned int clear)
 {
+	struct dec_serial * info = (struct dec_serial *)tty->driver_data;
 	int error;
 	unsigned int arg, bits;
 
-	error = verify_area(VERIFY_READ, value, sizeof(int));
-	if (error)
-		return error;
+	if (info->hook)
+		return -ENODEV;
+
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
 
 	if (info->zs_channel == info->zs_chan_a)
 		return 0;
 
-	get_user(arg, value);
-	bits = (arg & TIOCM_RTS? RTS: 0) + (arg & TIOCM_DTR? DTR: 0);
 	cli();
-	switch (cmd) {
-	case TIOCMBIS:
-		info->zs_chan_a->curregs[5] |= bits;
-		break;
-	case TIOCMBIC:
-		info->zs_chan_a->curregs[5] &= ~bits;
-		break;
-	case TIOCMSET:
-		info->zs_chan_a->curregs[5] = 
-			(info->zs_chan_a->curregs[5] & ~(DTR | RTS)) | bits;
-		break;
-	default:
-		sti();
-		return -EINVAL;
-	}
+	if (set & TIOCM_RTS)
+		info->zs_chan_a->curregs[5] |= RTS;
+	if (set & TIOCM_DTR)
+		info->zs_chan_a->curregs[5] |= DTR;
+	if (clear & TIOCM_RTS)
+		info->zs_chan_a->curregs[5] &= ~RTS;
+	if (clear & TIOCM_DTR)
+		info->zs_chan_a->curregs[5] &= ~DTR;
 	write_zsreg(info->zs_chan_a, 5, info->zs_chan_a->curregs[5]);
 	sti();
 	return 0;
@@ -1278,16 +1284,6 @@ static int rs_ioctl(struct tty_struct *t
 	}
 	
 	switch (cmd) {
-		case TIOCMGET:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-				sizeof(unsigned int));
-			if (error)
-				return error;
-			return get_modem_info(info, (unsigned int *) arg);
-		case TIOCMBIS:
-		case TIOCMBIC:
-		case TIOCMSET:
-			return set_modem_info(info, cmd, (unsigned int *) arg);
 		case TIOCGSERIAL:
 			error = verify_area(VERIFY_WRITE, (void *) arg,
 						sizeof(struct serial_struct));
@@ -1816,6 +1812,8 @@ static struct tty_operations serial_ops 
 	.hangup = rs_hangup,
 	.break_ctl = rs_break,
 	.wait_until_sent = rs_wait_until_sent,
+	.tiocmget = rs_tiocmget,
+	.tiocmset = rs_tiocmset,
 };
 
 /* zs_init inits the driver */
diff -purN linux-post-2.6.3-20040222/drivers/telephony/ixj.h linux-post-2.6.3-20040223/drivers/telephony/ixj.h
--- linux-post-2.6.3-20040222/drivers/telephony/ixj.h	2003-09-30 00:22:54.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/telephony/ixj.h	2004-02-23 05:24:14.000000000 +0000
@@ -60,13 +60,6 @@ typedef __u8 BOOL;
 #define TRUE 1
 #define FALSE 0
 
-#ifndef min
-#define min(a,b) (((a)<(b))?(a):(b))
-#endif
-#ifndef max
-#define max(a,b) (((a)>(b))?(a):(b))
-#endif
-
 /******************************************************************************
 *
 *  This structure when unioned with the structures below makes simple byte
diff -purN linux-post-2.6.3-20040222/drivers/video/acornfb.c linux-post-2.6.3-20040223/drivers/video/acornfb.c
--- linux-post-2.6.3-20040222/drivers/video/acornfb.c	2003-10-24 23:47:52.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/video/acornfb.c	2004-02-22 17:14:16.000000000 +0000
@@ -68,12 +68,12 @@
  */
 #define NR_MONTYPES	6
 static struct fb_monspecs monspecs[NR_MONTYPES] __initdata = {
-	{ 15469, 15781, 49, 51, 0 },	/* TV		*/
-	{     0, 99999,  0, 99, 0 },	/* Multi Freq	*/
-	{ 58608, 58608, 64, 64, 0 },	/* Hi-res mono	*/
-	{ 30000, 70000, 60, 60, 0 },	/* VGA		*/
-	{ 30000, 70000, 56, 75, 0 },	/* SVGA		*/
-	{ 30000, 70000, 60, 60, 0 }
+	{ 15469, 15781, 49,  51, 0 },	/* TV		*/
+	{     0, 99999,  0, 199, 0 },	/* Multi Freq	*/
+	{ 58608, 58608, 64,  64, 0 },	/* Hi-res mono	*/
+	{ 30000, 70000, 60,  60, 0 },	/* VGA		*/
+	{ 30000, 70000, 56,  75, 0 },	/* SVGA		*/
+	{ 30000, 70000, 60,  60, 0 }
 };
 
 static struct fb_info fb_info;
@@ -127,10 +127,14 @@ static struct pixclock a5k_clocks[] = {
 #endif
 
 static struct pixclock *
-acornfb_valid_pixrate(u_long pixclock)
+acornfb_valid_pixrate(struct fb_var_screeninfo *var)
 {
+	u_long pixclock = var->pixclock;
 	u_int i;
 
+	if (!var->pixclock)
+		return NULL;
+
 	for (i = 0; i < ARRAY_SIZE(arc_clocks); i++)
 		if (pixclock > arc_clocks[i].min_clock &&
 		    pixclock < arc_clocks[i].max_clock)
@@ -173,7 +177,7 @@ acornfb_set_timing(struct fb_var_screeni
 
 	memset(&vidc, 0, sizeof(vidc));
 
-	pclk = acornfb_valid_pixrate(var->pixclock);
+	pclk = acornfb_valid_pixrate(var);
 	vidc_ctl = pclk->vidc_ctl;
 	vid_ctl  = pclk->vid_ctl;
 
@@ -345,9 +349,9 @@ acornfb_setcolreg(u_int regno, u_int red
  *  vdsr : >= 1
  *  vder : >= vdsr
  */
-static void
-acornfb_set_timing(struct fb_info *info, struct fb_var_screeninfo *var)
+static void acornfb_set_timing(struct fb_info *info)
 {
+	struct fb_var_screeninfo *var = &info->var;
 	struct vidc_timing vidc;
 	u_int vcr, fsize;
 	u_int ext_ctl, dat_ctl;
@@ -448,9 +452,9 @@ acornfb_set_timing(struct fb_info *info,
 	 * 1MB VRAM	32bit
 	 * 2MB VRAM	64bit
 	 */
-	if (current_par.using_vram && current_par.vram_half_sam == 2048) {
+	if (current_par.using_vram && current_par.vram_half_sam == 2048)
 		dat_ctl |= VIDC20_DCTL_BUS_D63_0;
-	} else 
+	else
 		dat_ctl |= VIDC20_DCTL_BUS_D31_0;
 
 	vidc_writel(VIDC20_DCTL | dat_ctl);
@@ -502,11 +506,20 @@ acornfb_setcolreg(u_int regno, u_int red
 		  u_int trans, struct fb_info *info)
 {
 	union palette pal;
-	int bpp = info->var.bits_per_pixel;
 
 	if (regno >= current_par.palette_size)
 		return 1;
 
+	if (regno < 16 && info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+		u32 pseudo_val;
+
+		pseudo_val  = regno << info->var.red.offset;
+		pseudo_val |= regno << info->var.green.offset;
+		pseudo_val |= regno << info->var.blue.offset;
+
+		((u32 *)info->pseudo_palette)[regno] = pseudo_val;
+	}
+
 	pal.p = 0;
 	pal.vidc20.red   = red >> 8;
 	pal.vidc20.green = green >> 8;
@@ -514,16 +527,9 @@ acornfb_setcolreg(u_int regno, u_int red
 
 	current_par.palette[regno] = pal;
 
-	if (bpp == 32 && regno < 16) {
-		current_par.cmap.cfb32[regno] =
-				regno | regno << 8 | regno << 16;
-	}
-	if (bpp == 16 && regno < 16) {
+	if (info->var.bits_per_pixel == 16) {
 		int i;
 
-		current_par.cmap.cfb16[regno] =
-				regno | regno << 5 | regno << 10;
-
 		pal.p = 0;
 		vidc_writel(0x10000000);
 		for (i = 0; i < 256; i += 1) {
@@ -677,8 +683,7 @@ acornfb_validate_timing(struct fb_var_sc
 static inline void
 acornfb_update_dma(struct fb_info *info, struct fb_var_screeninfo *var)
 {
-	u_int off = (var->yoffset * var->xres_virtual *
-		     var->bits_per_pixel) >> 3;
+	u_int off = var->yoffset * info->fix.line_length;
 
 #if defined(HAS_MEMC)
 	memc_write(VDMA_INIT, off >> 2);
@@ -698,6 +703,11 @@ acornfb_check_var(struct fb_var_screenin
 	 */
 	fontht = 8;
 
+	var->red.msb_right = 0;
+	var->green.msb_right = 0;
+	var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+
 	switch (var->bits_per_pixel) {
 	case 1:	case 2:	case 4:	case 8:
 		var->red.offset    = 0;
@@ -738,7 +748,7 @@ acornfb_check_var(struct fb_var_screenin
 	/*
 	 * Check to see if the pixel rate is valid.
 	 */
-	if (!var->pixclock || !acornfb_valid_pixrate(var->pixclock))
+	if (!acornfb_valid_pixrate(var))
 		return -EINVAL;
 
 	/*
@@ -782,13 +792,11 @@ static int acornfb_set_par(struct fb_inf
 #ifdef HAS_VIDC20
 	case 16:
 		current_par.palette_size = 32;
-		info->pseudo_palette = current_par.cmap.cfb16;
 		info->fix.visual = FB_VISUAL_DIRECTCOLOR;
 		break;
 	case 32:
 		current_par.palette_size = VIDC_PALETTE_SIZE;
-		info->pseudo_palette = current_par.cmap.cfb32;
-		info->fix.visual = FB_VISUAL_TRUECOLOR;
+		info->fix.visual = FB_VISUAL_DIRECTCOLOR;
 		break;
 #endif
 	default:
@@ -827,7 +835,7 @@ static int acornfb_set_par(struct fb_inf
 #endif
 
 	acornfb_update_dma(info, &info->var);
-	acornfb_set_timing(info, &info->var);
+	acornfb_set_timing(info);
 
 	return 0;
 }
@@ -869,9 +877,7 @@ acornfb_mmap(struct fb_info *info, struc
 	/* This is an IO map - tell maydump to skip this VMA */
 	vma->vm_flags |= VM_IO;
 
-#ifdef CONFIG_CPU_32
-	pgprot_val(vma->vm_page_prot) &= ~L_PTE_CACHEABLE;
-#endif
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 
 	/*
 	 * Don't alter the page protection flags; we want to keep the area
@@ -981,6 +987,7 @@ static void __init acornfb_init_fbinfo(v
 
 	fb_info.fbops		= &acornfb_ops;
 	fb_info.flags		= FBINFO_FLAG_DEFAULT;
+	fb_info.pseudo_palette	= current_par.pseudo_palette;
 
 	strcpy(fb_info.fix.id, "Acorn");
 	fb_info.fix.type	= FB_TYPE_PACKED_PIXELS;
diff -purN linux-post-2.6.3-20040222/drivers/video/acornfb.h linux-post-2.6.3-20040223/drivers/video/acornfb.h
--- linux-post-2.6.3-20040222/drivers/video/acornfb.h	2002-10-13 16:26:33.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/video/acornfb.h	2004-02-22 17:14:16.000000000 +0000
@@ -57,10 +57,7 @@ struct acornfb_par {
 
 	union palette palette[VIDC_PALETTE_SIZE];
 
-	union {
-		unsigned short cfb16[16];
-		unsigned long  cfb32[16];
-	} cmap;
+	u32		pseudo_palette[16];
 };
 
 struct vidc_timing {
diff -purN linux-post-2.6.3-20040222/drivers/video/amifb.c linux-post-2.6.3-20040223/drivers/video/amifb.c
--- linux-post-2.6.3-20040222/drivers/video/amifb.c	2003-05-27 00:51:43.000000000 +0000
+++ linux-post-2.6.3-20040223/drivers/video/amifb.c	2004-02-23 05:24:06.000000000 +0000
@@ -832,7 +832,7 @@ static struct fb_videomode ami_modedb[] 
 	FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
     }, {
 	/* 640x400, 15 kHz, 60 Hz interlaced (NTSC) */
-	"ntsc-lace", 60, 640, TAG_HIRES, 106, 86, 88, 33, 76, 4,
+	"ntsc-lace", 60, 640, 400, TAG_HIRES, 106, 86, 88, 33, 76, 4,
 	FB_SYNC_BROADCAST, FB_VMODE_INTERLACED | FB_VMODE_YWRAP
     }, {
 	/* 640x256, 15 kHz, 50 Hz (PAL) */
@@ -927,7 +927,7 @@ static struct fb_videomode ami_modedb[] 
 	0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
     }, {
 	/* 1024x800, 15 Hz */
-	"a2024-15", 10, 1024, 800, TAG_HIRES, 0, 0, 0, 0, 0, 0,
+	"a2024-15", 15, 1024, 800, TAG_HIRES, 0, 0, 0, 0, 0, 0,
 	0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
     }
 #endif
diff -purN linux-post-2.6.3-20040222/fs/Kconfig linux-post-2.6.3-20040223/fs/Kconfig
--- linux-post-2.6.3-20040222/fs/Kconfig	2004-02-19 03:42:40.000000000 +0000
+++ linux-post-2.6.3-20040223/fs/Kconfig	2004-02-23 05:24:03.000000000 +0000
@@ -797,8 +797,7 @@ config DEVFS_FS
 	  the file README there.
 
 	  Note that devfs no longer manages /dev/pts!  If you are using UNIX98
-	  ptys, you will also need to enable (and mount) the /dev/pts
-	  filesystem (CONFIG_DEVPTS_FS).
+	  ptys, you will also need to mount the /dev/pts filesystem (devpts).
 
 	  Note that devfs has been obsoleted by udev,
 	  <http://www.kernel.org/pub/linux/utils/kernel/hotplug/>.
@@ -831,32 +830,9 @@ config DEVFS_DEBUG
 
 	  If unsure, say N.
 
-config DEVPTS_FS
-# It compiles as a module for testing only.  It should not be used
-# as a module in general.  If we make this "tristate", a bunch of people
-# who don't know what they are doing turn it on and complain when it
-# breaks.
-	bool "/dev/pts file system for Unix98 PTYs"
-	depends on UNIX98_PTYS
-	---help---
-	  You should say Y here if you said Y to "Unix98 PTY support" above.
-	  You'll then get a virtual file system which can be mounted on
-	  /dev/pts with "mount -t devpts". This, together with the pseudo
-	  terminal master multiplexer /dev/ptmx, is used for pseudo terminal
-	  support as described in The Open Group's Unix98 standard: in order
-	  to acquire a pseudo terminal, a process opens /dev/ptmx; the number
-	  of the pseudo terminal is then made available to the process and the
-	  pseudo terminal slave can be accessed as /dev/pts/<number>. What was
-	  traditionally /dev/ttyp2 will then be /dev/pts/2, for example.
-
-	  The GNU C library glibc 2.1 contains the requisite support for this
-	  mode of operation; you also need client programs that use the Unix98
-	  API. Please read <file:Documentation/Changes> for more information
-	  about the Unix98 pty devices.
-
 config DEVPTS_FS_XATTR
 	bool "/dev/pts Extended Attributes"
-	depends on DEVPTS_FS
+	depends on UNIX98_PTYS
 	help
 	  Extended attributes are name:value pairs associated with inodes by
 	  the kernel or by users (see the attr(5) manual page, or visit
diff -purN linux-post-2.6.3-20040222/fs/dcache.c linux-post-2.6.3-20040223/fs/dcache.c
--- linux-post-2.6.3-20040222/fs/dcache.c	2004-02-19 03:42:32.000000000 +0000
+++ linux-post-2.6.3-20040223/fs/dcache.c	2004-02-23 05:24:13.000000000 +0000
@@ -895,7 +895,7 @@ struct dentry *d_splice_alias(struct ino
 			new = list_entry(inode->i_dentry.next, struct dentry, d_alias);
 			__dget_locked(new);
 			spin_unlock(&dcache_lock);
-			security_d_instantiate(dentry, inode);
+			security_d_instantiate(new, inode);
 			d_rehash(dentry);
 			d_move(new, dentry);
 			iput(inode);
diff -purN linux-post-2.6.3-20040222/fs/devpts/Makefile linux-post-2.6.3-20040223/fs/devpts/Makefile
--- linux-post-2.6.3-20040222/fs/devpts/Makefile	2003-07-19 21:24:33.000000000 +0000
+++ linux-post-2.6.3-20040223/fs/devpts/Makefile	2004-02-23 05:24:03.000000000 +0000
@@ -2,8 +2,8 @@
 # Makefile for the Linux /dev/pts virtual filesystem.
 #
 
-obj-$(CONFIG_DEVPTS_FS) += devpts.o
+obj-$(CONFIG_UNIX98_PTYS)		+= devpts.o
 
-devpts-y := inode.o
+devpts-$(CONFIG_UNIX98_PTYS)		:= inode.o
 devpts-$(CONFIG_DEVPTS_FS_XATTR)	+= xattr.o 
 devpts-$(CONFIG_DEVPTS_FS_SECURITY)	+= xattr_security.o
diff -purN linux-post-2.6.3-20040222/fs/devpts/inode.c linux-post-2.6.3-20040223/fs/devpts/inode.c
--- linux-post-2.6.3-20040222/fs/devpts/inode.c	2003-05-26 06:16:56.000000000 +0000
+++ linux-post-2.6.3-20040223/fs/devpts/inode.c	2004-02-23 05:24:03.000000000 +0000
@@ -2,7 +2,7 @@
  *
  * linux/fs/devpts/inode.c
  *
- *  Copyright 1998 H. Peter Anvin -- All Rights Reserved
+ *  Copyright 1998-2004 H. Peter Anvin -- All Rights Reserved
  *
  * This file is part of the Linux kernel and is made available under
  * the terms of the GNU General Public License, version 2, or at your
@@ -16,6 +16,8 @@
 #include <linux/sched.h>
 #include <linux/namei.h>
 #include <linux/mount.h>
+#include <linux/tty.h>
+#include <linux/devpts_fs.h>
 #include "xattr.h"
 
 #define DEVPTS_SUPER_MAGIC 0x1cd1
@@ -126,7 +128,7 @@ static struct file_system_type devpts_fs
 
 static struct dentry *get_node(int num)
 {
-	char s[10];
+	char s[12];
 	struct dentry *root = devpts_root;
 	down(&root->d_inode->i_sem);
 	return lookup_one_len(s, root, sprintf(s, "%d", num));
@@ -139,12 +141,21 @@ static struct inode_operations devpts_fi
 	.removexattr	= devpts_removexattr,
 };
 
-void devpts_pty_new(int number, dev_t device)
+int devpts_pty_new(struct tty_struct *tty)
 {
+	int number = tty->index;
+	struct tty_driver *driver = tty->driver;
+	dev_t device = MKDEV(driver->major, driver->minor_start+number);
 	struct dentry *dentry;
 	struct inode *inode = new_inode(devpts_mnt->mnt_sb);
+
+	/* We're supposed to be given the slave end of a pty */
+	BUG_ON(driver->type != TTY_DRIVER_TYPE_PTY);
+	BUG_ON(driver->subtype != PTY_TYPE_SLAVE);
+
 	if (!inode)
-		return;
+		return -ENOMEM;
+
 	inode->i_ino = number+2;
 	inode->i_blksize = 1024;
 	inode->i_uid = config.setuid ? config.uid : current->fsuid;
@@ -152,11 +163,28 @@ void devpts_pty_new(int number, dev_t de
 	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
 	init_special_inode(inode, S_IFCHR|config.mode, device);
 	inode->i_op = &devpts_file_inode_operations;
+	inode->u.generic_ip = tty;
 
 	dentry = get_node(number);
 	if (!IS_ERR(dentry) && !dentry->d_inode)
 		d_instantiate(dentry, inode);
+
+	up(&devpts_root->d_inode->i_sem);
+
+	return 0;
+}
+
+struct tty_struct *devpts_get_tty(int number)
+{
+	struct dentry *dentry = get_node(number);
+	struct tty_struct *tty;
+
+	tty = (IS_ERR(dentry) || !dentry->d_inode) ? NULL :
+			dentry->d_inode->u.generic_ip;
+
 	up(&devpts_root->d_inode->i_sem);
+
+	return tty;
 }
 
 void devpts_pty_kill(int number)
diff -purN linux-post-2.6.3-20040222/fs/ext3/balloc.c linux-post-2.6.3-20040223/fs/ext3/balloc.c
--- linux-post-2.6.3-20040222/fs/ext3/balloc.c	2003-12-30 08:39:31.000000000 +0000
+++ linux-post-2.6.3-20040223/fs/ext3/balloc.c	2004-02-23 05:24:13.000000000 +0000
@@ -239,9 +239,10 @@ do_more:
 		BUFFER_TRACE(bitmap_bh, "clear bit");
 		if (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),
 						bit + i, bitmap_bh->b_data)) {
-			ext3_error (sb, __FUNCTION__,
-				      "bit already cleared for block %lu", 
-				      block + i);
+			jbd_unlock_bh_state(bitmap_bh);
+			ext3_error(sb, __FUNCTION__,
+				"bit already cleared for block %lu", block + i);
+			jbd_lock_bh_state(bitmap_bh);
 			BUFFER_TRACE(bitmap_bh, "bit already cleared");
 		} else {
 			dquot_freed_blocks++;
diff -purN linux-post-2.6.3-20040222/fs/jffs/inode-v23.c linux-post-2.6.3-20040223/fs/jffs/inode-v23.c
--- linux-post-2.6.3-20040222/fs/jffs/inode-v23.c	2003-09-22 02:07:45.000000000 +0000
+++ linux-post-2.6.3-20040223/fs/jffs/inode-v23.c	2004-02-23 05:24:13.000000000 +0000
@@ -1807,13 +1807,25 @@ init_jffs_fs(void)
 	
 #ifdef CONFIG_JFFS_PROC_FS
 	jffs_proc_root = proc_mkdir("jffs", proc_root_fs);
+	if (!jffs_proc_root) {
+		printk(KERN_WARNING "cannot create /proc/jffs entry\n");
+	}
 #endif
 	fm_cache = kmem_cache_create("jffs_fm", sizeof(struct jffs_fm),
 				     0, SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, 
 				     NULL, NULL);
+	if (!fm_cache) {
+		return -ENOMEM;
+	}
+
 	node_cache = kmem_cache_create("jffs_node",sizeof(struct jffs_node),
 				       0, SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, 
 				       NULL, NULL);
+	if (!node_cache) {
+		kmem_cache_destroy(fm_cache);
+		return -ENOMEM;
+	}
+
 	return register_filesystem(&jffs_fs_type);
 }
 
diff -purN linux-post-2.6.3-20040222/fs/partitions/efi.c linux-post-2.6.3-20040223/fs/partitions/efi.c
--- linux-post-2.6.3-20040222/fs/partitions/efi.c	2003-09-23 18:50:44.000000000 +0000
+++ linux-post-2.6.3-20040223/fs/partitions/efi.c	2004-02-23 05:24:15.000000000 +0000
@@ -91,16 +91,6 @@
 #include "check.h"
 #include "efi.h"
 
-/* Handle printing of 64-bit values */
-/* Borrowed from /usr/include/inttypes.h */
-# if BITS_PER_LONG == 64 
-#  define __PRI64_PREFIX	"l"
-# else
-#  define __PRI64_PREFIX	"ll"
-# endif
-# define PRIx64		__PRI64_PREFIX "x"
-
-
 #undef EFI_DEBUG
 #ifdef EFI_DEBUG
 #define Dprintk(x...) printk(KERN_DEBUG x)
@@ -307,9 +297,10 @@ is_gpt_valid(struct block_device *bdev, 
 
 	/* Check the GUID Partition Table signature */
 	if (le64_to_cpu((*gpt)->signature) != GPT_HEADER_SIGNATURE) {
-		Dprintk("GUID Partition Table Header signature is wrong: %"
-			PRIx64 " != %" PRIx64 "\n", le64_to_cpu((*gpt)->signature),
-			GPT_HEADER_SIGNATURE);
+		Dprintk("GUID Partition Table Header signature is wrong:"
+			"%lld != %lld\n",
+			(unsigned long long)le64_to_cpu((*gpt)->signature),
+			(unsigned long long)GPT_HEADER_SIGNATURE);
 		kfree(*gpt);
 		*gpt = NULL;
 		return 0;
@@ -333,8 +324,9 @@ is_gpt_valid(struct block_device *bdev, 
 	/* Check that the my_lba entry points to the LBA that contains
 	 * the GUID Partition Table */
 	if (le64_to_cpu((*gpt)->my_lba) != lba) {
-		Dprintk("GPT my_lba incorrect: %" PRIx64 " != %" PRIx64 "\n",
-			le64_to_cpu((*gpt)->my_lba), lba);
+		Dprintk("GPT my_lba incorrect: %lld != %lld\n",
+			(unsigned long long)le64_to_cpu((*gpt)->my_lba),
+			(unsigned long long)lba);
 		kfree(*gpt);
 		*gpt = NULL;
 		return 0;
@@ -382,33 +374,33 @@ compare_gpts(gpt_header *pgpt, gpt_heade
 	if (le64_to_cpu(pgpt->my_lba) != le64_to_cpu(agpt->alternate_lba)) {
 		printk(KERN_WARNING
 		       "GPT:Primary header LBA != Alt. header alternate_lba\n");
-		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
-		       le64_to_cpu(pgpt->my_lba),
-                       le64_to_cpu(agpt->alternate_lba));
+		printk(KERN_WARNING "GPT:%lld != %lld\n",
+		       (unsigned long long)le64_to_cpu(pgpt->my_lba),
+                       (unsigned long long)le64_to_cpu(agpt->alternate_lba));
 		error_found++;
 	}
 	if (le64_to_cpu(pgpt->alternate_lba) != le64_to_cpu(agpt->my_lba)) {
 		printk(KERN_WARNING
 		       "GPT:Primary header alternate_lba != Alt. header my_lba\n");
-		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
-		       le64_to_cpu(pgpt->alternate_lba),
-                       le64_to_cpu(agpt->my_lba));
+		printk(KERN_WARNING "GPT:%lld != %lld\n",
+		       (unsigned long long)le64_to_cpu(pgpt->alternate_lba),
+                       (unsigned long long)le64_to_cpu(agpt->my_lba));
 		error_found++;
 	}
 	if (le64_to_cpu(pgpt->first_usable_lba) !=
             le64_to_cpu(agpt->first_usable_lba)) {
 		printk(KERN_WARNING "GPT:first_usable_lbas don't match.\n");
-		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
-		       le64_to_cpu(pgpt->first_usable_lba),
-                       le64_to_cpu(agpt->first_usable_lba));
+		printk(KERN_WARNING "GPT:%lld != %lld\n",
+		       (unsigned long long)le64_to_cpu(pgpt->first_usable_lba),
+                       (unsigned long long)le64_to_cpu(agpt->first_usable_lba));
 		error_found++;
 	}
 	if (le64_to_cpu(pgpt->last_usable_lba) !=
             le64_to_cpu(agpt->last_usable_lba)) {
 		printk(KERN_WARNING "GPT:last_usable_lbas don't match.\n");
-		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
-		       le64_to_cpu(pgpt->last_usable_lba),
-                       le64_to_cpu(agpt->last_usable_lba));
+		printk(KERN_WARNING "GPT:%lld != %lld\n",
+		       (unsigned long long)le64_to_cpu(pgpt->last_usable_lba),
+                       (unsigned long long)le64_to_cpu(agpt->last_usable_lba));
 		error_found++;
 	}
 	if (efi_guidcmp(pgpt->disk_guid, agpt->disk_guid)) {
@@ -444,16 +436,18 @@ compare_gpts(gpt_header *pgpt, gpt_heade
 	if (le64_to_cpu(pgpt->alternate_lba) != lastlba) {
 		printk(KERN_WARNING
 		       "GPT:Primary header thinks Alt. header is not at the end of the disk.\n");
-		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
-		       le64_to_cpu(pgpt->alternate_lba), lastlba);
+		printk(KERN_WARNING "GPT:%lld != %lld\n",
+			(unsigned long long)le64_to_cpu(pgpt->alternate_lba),
+			(unsigned long long)lastlba);
 		error_found++;
 	}
 
 	if (le64_to_cpu(agpt->my_lba) != lastlba) {
 		printk(KERN_WARNING
 		       "GPT:Alternate GPT header not at the end of the disk.\n");
-		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
-		       le64_to_cpu(agpt->my_lba), lastlba);
+		printk(KERN_WARNING "GPT:%lld != %lld\n",
+			(unsigned long long)le64_to_cpu(agpt->my_lba),
+			(unsigned long long)lastlba);
 		error_found++;
 	}
 
diff -purN linux-post-2.6.3-20040222/include/asm-arm/arch-cl7500/acornfb.h linux-post-2.6.3-20040223/include/asm-arm/arch-cl7500/acornfb.h
--- linux-post-2.6.3-20040222/include/asm-arm/arch-cl7500/acornfb.h	2002-02-05 17:39:52.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-arm/arch-cl7500/acornfb.h	2004-02-22 17:14:16.000000000 +0000
@@ -1,5 +1,5 @@
 #include <linux/config.h>
-#define acornfb_valid_pixrate(rate) (rate >= 39325 && rate <= 40119)
+#define acornfb_valid_pixrate(var) (var->pixclock >= 39325 && var->pixclock <= 40119)
 
 static inline void
 acornfb_vidc20_find_rates(struct vidc_timing *vidc,
diff -purN linux-post-2.6.3-20040222/include/asm-arm/arch-rpc/acornfb.h linux-post-2.6.3-20040223/include/asm-arm/arch-rpc/acornfb.h
--- linux-post-2.6.3-20040222/include/asm-arm/arch-rpc/acornfb.h	2002-02-05 17:39:51.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-arm/arch-rpc/acornfb.h	2004-02-22 17:14:16.000000000 +0000
@@ -10,7 +10,30 @@
  *  AcornFB architecture specific code
  */
 
-#define acornfb_valid_pixrate(rate) (1)
+#define acornfb_bandwidth(var) ((var)->pixclock * 8 / (var)->bits_per_pixel)
+
+static inline int
+acornfb_valid_pixrate(struct fb_var_screeninfo *var)
+{
+	u_long limit;
+
+	if (!var->pixclock)
+		return 0;
+
+	/*
+	 * Limits below are taken from RISC OS bandwidthlimit file
+	 */
+	if (current_par.using_vram) {
+		if (current_par.vram_half_sam == 2048)
+			limit = 6578;
+		else
+			limit = 13157;
+	} else {
+		limit = 26315;
+	}
+
+	return acornfb_bandwidth(var) >= limit;
+}
 
 /*
  * Try to find the best PLL parameters for the pixel clock.
@@ -59,7 +82,7 @@ static inline void
 acornfb_vidc20_find_rates(struct vidc_timing *vidc,
 			  struct fb_var_screeninfo *var)
 {
-	u_int div, bandwidth;
+	u_int div;
 
 	/* Select pixel-clock divisor to keep PLL in range */
 	div = var->pixclock / 9090; /*9921*/
@@ -82,21 +105,35 @@ acornfb_vidc20_find_rates(struct vidc_ti
 	case 8: vidc->control |= VIDC20_CTRL_PIX_CK8; break;
 	}
 
-	/* Calculate bandwidth */
-	bandwidth = var->pixclock * 8 / var->bits_per_pixel;
-
-	/* Encode bandwidth as VIDC20 setting */
-	if (bandwidth > 33334)
-		vidc->control |= VIDC20_CTRL_FIFO_16;	/* < 30.0MB/s */
-	else if (bandwidth > 26666)
-		vidc->control |= VIDC20_CTRL_FIFO_20;	/* < 37.5MB/s */
-	else if (bandwidth > 22222)
-		vidc->control |= VIDC20_CTRL_FIFO_24;	/* < 45.0MB/s */
-	else
-		vidc->control |= VIDC20_CTRL_FIFO_28;	/* > 45.0MB/s */
+	/*
+	 * With VRAM, the FIFO can be set to the highest possible setting
+	 * because there are no latency considerations for other memory
+	 * accesses. However, in 64 bit bus mode the FIFO preload value
+	 * must not be set to VIDC20_CTRL_FIFO_28 because this will let
+	 * the FIFO overflow. See VIDC20 manual page 33 (6.0 Setting the
+	 * FIFO preload value).
+	 */
+	if (current_par.using_vram) {
+		if (current_par.vram_half_sam == 2048)
+			vidc->control |= VIDC20_CTRL_FIFO_24;
+		else
+			vidc->control |= VIDC20_CTRL_FIFO_28;
+	} else {
+		unsigned long bandwidth = acornfb_bandwidth(var);
+
+		/* Encode bandwidth as VIDC20 setting */
+		if (bandwidth > 33334)		/* < 30.0MB/s */
+			vidc->control |= VIDC20_CTRL_FIFO_16;
+		else if (bandwidth > 26666)	/* < 37.5MB/s */
+			vidc->control |= VIDC20_CTRL_FIFO_20;
+		else if (bandwidth > 22222)	/* < 45.0MB/s */
+			vidc->control |= VIDC20_CTRL_FIFO_24;
+		else				/* > 45.0MB/s */
+			vidc->control |= VIDC20_CTRL_FIFO_28;
+	}
 
 	/* Find the PLL values */
-	vidc->pll_ctl  = acornfb_vidc20_find_pll(var->pixclock / div);
+	vidc->pll_ctl = acornfb_vidc20_find_pll(var->pixclock / div);
 }
 
 #define acornfb_default_control()	(VIDC20_CTRL_PIX_VCLK)
diff -purN linux-post-2.6.3-20040222/include/asm-arm/hardware/sa1111.h linux-post-2.6.3-20040223/include/asm-arm/hardware/sa1111.h
--- linux-post-2.6.3-20040222/include/asm-arm/hardware/sa1111.h	2004-02-06 13:04:59.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-arm/hardware/sa1111.h	2004-02-22 15:51:55.000000000 +0000
@@ -364,6 +364,47 @@
 #define _PC_SDR		_SA1111( 0x1028 )
 #define _PC_SSR		_SA1111( 0x102c )
 
+#define SA1111_GPIO	0x1000
+
+#define SA1111_GPIO_PADDR	(0x000)
+#define SA1111_GPIO_PADRR	(0x004)
+#define SA1111_GPIO_PADWR	(0x004)
+#define SA1111_GPIO_PASDR	(0x008)
+#define SA1111_GPIO_PASSR	(0x00c)
+#define SA1111_GPIO_PBDDR	(0x010)
+#define SA1111_GPIO_PBDRR	(0x014)
+#define SA1111_GPIO_PBDWR	(0x014)
+#define SA1111_GPIO_PBSDR	(0x018)
+#define SA1111_GPIO_PBSSR	(0x01c)
+#define SA1111_GPIO_PCDDR	(0x020)
+#define SA1111_GPIO_PCDRR	(0x024)
+#define SA1111_GPIO_PCDWR	(0x024)
+#define SA1111_GPIO_PCSDR	(0x028)
+#define SA1111_GPIO_PCSSR	(0x02c)
+
+#define GPIO_A0		(1 << 0)
+#define GPIO_A1		(1 << 1)
+#define GPIO_A2		(1 << 2)
+#define GPIO_A3		(1 << 3)
+
+#define GPIO_B0		(1 << 8)
+#define GPIO_B1		(1 << 9)
+#define GPIO_B2		(1 << 10)
+#define GPIO_B3		(1 << 11)
+#define GPIO_B4		(1 << 12)
+#define GPIO_B5		(1 << 13)
+#define GPIO_B6		(1 << 14)
+#define GPIO_B7		(1 << 15)
+
+#define GPIO_C0		(1 << 16)
+#define GPIO_C1		(1 << 17)
+#define GPIO_C2		(1 << 18)
+#define GPIO_C3		(1 << 19)
+#define GPIO_C4		(1 << 20)
+#define GPIO_C5		(1 << 21)
+#define GPIO_C6		(1 << 22)
+#define GPIO_C7		(1 << 23)
+
 #define PA_DDR		__CCREG(0x1000)
 #define PA_DRR		__CCREG(0x1004)
 #define PA_DWR		__CCREG(0x1004)
@@ -570,4 +611,8 @@ int sa1111_check_dma_bug(dma_addr_t addr
 int sa1111_driver_register(struct sa1111_driver *);
 void sa1111_driver_unregister(struct sa1111_driver *);
 
+void sa1111_set_io_dir(struct sa1111_dev *sadev, unsigned int bits, unsigned int dir, unsigned int sleep_dir);
+void sa1111_set_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v);
+void sa1111_set_sleep_io(struct sa1111_dev *sadev, unsigned int bits, unsigned int v);
+
 #endif  /* _ASM_ARCH_SA1111 */
diff -purN linux-post-2.6.3-20040222/include/asm-generic/dma-mapping-broken.h linux-post-2.6.3-20040223/include/asm-generic/dma-mapping-broken.h
--- linux-post-2.6.3-20040222/include/asm-generic/dma-mapping-broken.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-generic/dma-mapping-broken.h	2004-02-23 05:24:09.000000000 +0000
@@ -0,0 +1,22 @@
+#ifndef _ASM_GENERIC_DMA_MAPPING_H
+#define _ASM_GENERIC_DMA_MAPPING_H
+
+/* This is used for archs that do not support DMA */
+
+
+static inline void *
+dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle,
+		   int flag)
+{
+	BUG();
+	return 0;
+}
+
+static inline void
+dma_free_coherent(struct device *dev, size_t size, void *cpu_addr,
+		    dma_addr_t dma_handle)
+{
+	BUG();
+}
+
+#endif /* _ASM_GENERIC_DMA_MAPPING_H */
diff -purN linux-post-2.6.3-20040222/include/asm-m68k/atarihw.h linux-post-2.6.3-20040223/include/asm-m68k/atarihw.h
--- linux-post-2.6.3-20040222/include/asm-m68k/atarihw.h	2002-05-21 10:19:34.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-m68k/atarihw.h	2004-02-23 05:24:05.000000000 +0000
@@ -376,7 +376,7 @@ struct MATRIX
   u_char external_frequency_divider;
   u_char internal_frequency_divider;
 };
-#define matrix (*(volatile struct MATRIX *)MATRIX_BASE)
+#define falcon_matrix (*(volatile struct MATRIX *)MATRIX_BASE)
 
 #define CODEC_BASE (0xffff8936)
 struct CODEC
@@ -405,7 +405,7 @@ struct CODEC
   u_char unused6;
   u_char gpio_data;
 };
-#define codec (*(volatile struct CODEC *)CODEC_BASE)
+#define falcon_codec (*(volatile struct CODEC *)CODEC_BASE)
 
 /*
 ** Falcon Blitter
diff -purN linux-post-2.6.3-20040222/include/asm-m68k/dma-mapping.h linux-post-2.6.3-20040223/include/asm-m68k/dma-mapping.h
--- linux-post-2.6.3-20040222/include/asm-m68k/dma-mapping.h	2003-07-22 19:07:38.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-m68k/dma-mapping.h	2004-02-23 05:24:09.000000000 +0000
@@ -5,6 +5,8 @@
 
 #ifdef CONFIG_PCI
 #include <asm-generic/dma-mapping.h>
+#else
+#include <asm-generic/dma-mapping-broken.h>
 #endif
 
 #endif  /* _M68K_DMA_MAPPING_H */
diff -purN linux-post-2.6.3-20040222/include/asm-m68k/processor.h linux-post-2.6.3-20040223/include/asm-m68k/processor.h
--- linux-post-2.6.3-20040222/include/asm-m68k/processor.h	2004-01-19 06:35:43.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-m68k/processor.h	2004-02-23 05:24:05.000000000 +0000
@@ -55,11 +55,6 @@ static inline void wrusp(unsigned long u
 #endif
 #define TASK_UNMAPPED_ALIGN(addr, off)	PAGE_ALIGN(addr)
 
-/*
- * Bus types
- */
-#define MCA_bus 0
-
 struct task_work {
 	unsigned char sigpending;
 	unsigned char notify_resume;	/* request for notification on
diff -purN linux-post-2.6.3-20040222/include/asm-m68k/sbus.h linux-post-2.6.3-20040223/include/asm-m68k/sbus.h
--- linux-post-2.6.3-20040222/include/asm-m68k/sbus.h	2004-01-19 06:35:43.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-m68k/sbus.h	2004-02-23 05:24:05.000000000 +0000
@@ -36,8 +36,15 @@ static inline void _sbus_writel(unsigned
 
 }
 
+extern inline unsigned long _sbus_readl(unsigned long addr)
+{
+	return *(volatile unsigned long *)addr;
+}
+
+
 #define sbus_readb(a) _sbus_readb((unsigned long)a)
 #define sbus_writeb(v, a) _sbus_writeb(v, (unsigned long)a)
+#define sbus_readl(a) _sbus_readl((unsigned long)a)
 #define sbus_writel(v, a) _sbus_writel(v, (unsigned long)a)
 
 #endif
diff -purN linux-post-2.6.3-20040222/include/asm-m68k/system.h linux-post-2.6.3-20040223/include/asm-m68k/system.h
--- linux-post-2.6.3-20040222/include/asm-m68k/system.h	2004-01-19 06:35:42.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-m68k/system.h	2004-02-23 05:24:08.000000000 +0000
@@ -158,6 +158,42 @@ static inline unsigned long __xchg(unsig
 }
 #endif
 
+/*
+ * Atomic compare and exchange.  Compare OLD with MEM, if identical,
+ * store NEW in MEM.  Return the initial value in MEM.  Success is
+ * indicated by comparing RETURN with OLD.
+ */
+#ifdef CONFIG_RMW_INSNS
+#define __HAVE_ARCH_CMPXCHG	1
+
+static inline unsigned long __cmpxchg(volatile void *p, unsigned long old,
+				      unsigned long new, int size)
+{
+	switch (size) {
+	case 1:
+		__asm__ __volatile__ ("casb %0,%2,%1"
+				      : "=d" (old), "=m" (*(char *)p)
+				      : "d" (new), "0" (old), "m" (*(char *)p));
+		break;
+	case 2:
+		__asm__ __volatile__ ("casw %0,%2,%1"
+				      : "=d" (old), "=m" (*(short *)p)
+				      : "d" (new), "0" (old), "m" (*(short *)p));
+		break;
+	case 4:
+		__asm__ __volatile__ ("casl %0,%2,%1"
+				      : "=d" (old), "=m" (*(int *)p)
+				      : "d" (new), "0" (old), "m" (*(int *)p));
+		break;
+	}
+	return old;
+}
+
+#define cmpxchg(ptr,o,n)\
+	((__typeof__(*(ptr)))__cmpxchg((ptr),(unsigned long)(o),\
+					(unsigned long)(n),sizeof(*(ptr))))
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _M68K_SYSTEM_H */
diff -purN linux-post-2.6.3-20040222/include/asm-x86_64/segment.h linux-post-2.6.3-20040223/include/asm-x86_64/segment.h
--- linux-post-2.6.3-20040222/include/asm-x86_64/segment.h	2004-02-18 02:14:37.000000000 +0000
+++ linux-post-2.6.3-20040223/include/asm-x86_64/segment.h	2004-02-23 05:24:12.000000000 +0000
@@ -40,7 +40,7 @@
 #define FS_TLS_SEL ((GDT_ENTRY_TLS_MIN+FS_TLS)*8 + 3)
 
 #define IDT_ENTRIES 256
-#define GDT_ENTRIES (L1_CACHE_BYTES / 8) 
+#define GDT_ENTRIES 16
 #define GDT_SIZE (GDT_ENTRIES * 8)
 #define TLS_SIZE (GDT_ENTRY_TLS_ENTRIES * 8) 
 
diff -purN linux-post-2.6.3-20040222/include/linux/devpts_fs.h linux-post-2.6.3-20040223/include/linux/devpts_fs.h
--- linux-post-2.6.3-20040222/include/linux/devpts_fs.h	2002-07-05 00:01:50.000000000 +0000
+++ linux-post-2.6.3-20040223/include/linux/devpts_fs.h	2004-02-23 05:24:03.000000000 +0000
@@ -2,7 +2,7 @@
  *
  * linux/include/linux/devpts_fs.h
  *
- *  Copyright 1998 H. Peter Anvin -- All Rights Reserved
+ *  Copyright 1998-2004 H. Peter Anvin -- All Rights Reserved
  *
  * This file is part of the Linux kernel and is made available under
  * the terms of the GNU General Public License, version 2, or at your
@@ -13,21 +13,22 @@
 #ifndef _LINUX_DEVPTS_FS_H
 #define _LINUX_DEVPTS_FS_H 1
 
-#ifdef CONFIG_DEVPTS_FS
+#include <linux/errno.h>
 
-void devpts_pty_new(int, dev_t);	/* mknod in devpts */
-void devpts_pty_kill(int);		/* unlink */
+#if CONFIG_UNIX98_PTYS
+
+int devpts_pty_new(struct tty_struct *); /* mknod in devpts */
+struct tty_struct *devpts_get_tty(int);	 /* get tty structure */
+void devpts_pty_kill(int);		 /* unlink */
 
 #else
 
-static inline void devpts_pty_new(int line, dev_t device)
-{
-}
-
-static inline void devpts_pty_kill(int line)
-{
-}
+/* Dummy stubs in the no-pty case */
+static inline int devpts_pty_new(struct tty_struct *) { return -EINVAL; }
+static inline struct tty_struct *devpts_get_tty(int)  { return NULL; }
+static inline void devpts_pty_kill(int) { }
 
 #endif
 
+
 #endif /* _LINUX_DEVPTS_FS_H */
diff -purN linux-post-2.6.3-20040222/include/linux/ide.h linux-post-2.6.3-20040223/include/linux/ide.h
--- linux-post-2.6.3-20040222/include/linux/ide.h	2004-02-19 01:14:51.000000000 +0000
+++ linux-post-2.6.3-20040223/include/linux/ide.h	2004-02-22 17:35:49.000000000 +0000
@@ -1119,6 +1119,7 @@ void ide_pci_create_host_proc(const char
 	return len;			\
 }
 #else
+static inline void create_proc_ide_interfaces(void) { ; }
 #define PROC_IDE_READ_RETURN(page,start,off,count,eof,len) return 0;
 #endif
 
diff -purN linux-post-2.6.3-20040222/include/linux/nbd.h linux-post-2.6.3-20040223/include/linux/nbd.h
--- linux-post-2.6.3-20040222/include/linux/nbd.h	2003-12-29 21:38:08.000000000 +0000
+++ linux-post-2.6.3-20040223/include/linux/nbd.h	2004-02-23 05:24:11.000000000 +0000
@@ -8,6 +8,8 @@
  * 2003/06/24 Louis D. Langholtz <ldl@aros.net>
  *            Removed unneeded blksize_bits field from nbd_device struct.
  *            Cleanup PARANOIA usage & code.
+ * 2004/02/19 Paul Clements
+ *            Removed PARANOIA, plus various cleanup and comments
  */
 
 #ifndef LINUX_NBD_H
@@ -32,22 +34,19 @@ enum {
 #define nbd_cmd(req) ((req)->cmd[0])
 #define MAX_NBD 128
 
-/* Define PARANOIA to include extra sanity checking code in here & driver */
-#define PARANOIA
-
 /* userspace doesn't need the nbd_device structure */
 #ifdef __KERNEL__
 
+/* values for flags field */
+#define NBD_READ_ONLY 0x0001
+#define NBD_WRITE_NOCHK 0x0002
+
 struct nbd_device {
 	int flags;
 	int harderror;		/* Code of hard error			*/
-#define NBD_READ_ONLY 0x0001
-#define NBD_WRITE_NOCHK 0x0002
 	struct socket * sock;
 	struct file * file; 	/* If == NULL, device is not ready, yet	*/
-#ifdef PARANOIA
-	int magic;		/* FIXME: not if debugging is off	*/
-#endif
+	int magic;
 	spinlock_t queue_lock;
 	struct list_head queue_head;/* Requests are added here...	*/
 	struct semaphore tx_lock;
@@ -58,16 +57,14 @@ struct nbd_device {
 
 #endif
 
-/* This now IS in some kind of include file...	*/
-
-/* These are send over network in request/reply magic field */
+/* These are sent over the network in the request/reply magic fields */
 
 #define NBD_REQUEST_MAGIC 0x25609513
 #define NBD_REPLY_MAGIC 0x67446698
 /* Do *not* use magics: 0x12560953 0x96744668. */
 
 /*
- * This is packet used for communication between client and
+ * This is the packet used for communication between client and
  * server. All data are in network byte order.
  */
 struct nbd_request {
@@ -82,6 +79,10 @@ struct nbd_request {
 #endif
 ;
 
+/*
+ * This is the reply packet that nbd-server sends back to the client after
+ * it has completed an I/O request (or an error occurs).
+ */
 struct nbd_reply {
 	u32 magic;
 	u32 error;		/* 0 = ok, else error	*/
diff -purN linux-post-2.6.3-20040222/include/linux/sysctl.h linux-post-2.6.3-20040223/include/linux/sysctl.h
--- linux-post-2.6.3-20040222/include/linux/sysctl.h	2004-02-20 22:51:48.000000000 +0000
+++ linux-post-2.6.3-20040223/include/linux/sysctl.h	2004-02-23 05:24:03.000000000 +0000
@@ -129,6 +129,7 @@ enum
 	KERN_HPPA_UNALIGNED=59,	/* int: hppa unaligned-trap enable */
 	KERN_PRINTK_RATELIMIT=60, /* int: tune printk ratelimiting */
 	KERN_PRINTK_RATELIMIT_BURST=61,	/* int: tune printk ratelimiting */
+	KERN_PTY=62,		/* dir: pty driver */
 };
 
 
@@ -192,6 +193,13 @@ enum
 	RANDOM_UUID=6
 };
 
+/* /proc/sys/kernel/pty */
+enum
+{
+	PTY_MAX=1,
+	PTY_NR=2
+};
+
 /* /proc/sys/bus/isa */
 enum
 {
diff -purN linux-post-2.6.3-20040222/include/linux/tty.h linux-post-2.6.3-20040223/include/linux/tty.h
--- linux-post-2.6.3-20040222/include/linux/tty.h	2003-09-24 06:15:15.000000000 +0000
+++ linux-post-2.6.3-20040223/include/linux/tty.h	2004-02-23 05:24:03.000000000 +0000
@@ -28,29 +28,13 @@
 
 
 /*
- * Note: don't mess with NR_PTYS until you understand the tty minor 
- * number allocation game...
  * (Note: the *_driver.minor_start values 1, 64, 128, 192 are
  * hardcoded at present.)
  */
-#define NR_PTYS		256	/* ptys/major */
-#define NR_LDISCS	16
-
-/*
- * Unix98 PTY's can be defined as any multiple of NR_PTYS up to
- * UNIX98_PTY_MAJOR_COUNT; this section defines what we need from the
- * config options
- */
-#ifdef CONFIG_UNIX98_PTYS
-# define UNIX98_NR_MAJORS ((CONFIG_UNIX98_PTY_COUNT+NR_PTYS-1)/NR_PTYS)
-# if UNIX98_NR_MAJORS <= 0
-#  undef CONFIG_UNIX98_PTYS
-# elif UNIX98_NR_MAJORS > UNIX98_PTY_MAJOR_COUNT
-#  error  Too many Unix98 ptys defined
-#  undef  UNIX98_NR_MAJORS
-#  define UNIX98_NR_MAJORS UNIX98_PTY_MAJOR_COUNT
-# endif
-#endif
+#define NR_PTYS	CONFIG_LEGACY_PTY_COUNT   /* Number of legacy ptys */
+#define NR_UNIX98_PTY_DEFAULT	4096      /* Default maximum for Unix98 ptys */
+#define NR_UNIX98_PTY_MAX	(1 << MINORBITS) /* Absolute limit */
+#define NR_LDISCS		16
 
 /*
  * These are set up by the setup-routine at boot-time:
diff -purN linux-post-2.6.3-20040222/include/linux/tty_driver.h linux-post-2.6.3-20040223/include/linux/tty_driver.h
--- linux-post-2.6.3-20040222/include/linux/tty_driver.h	2003-06-11 19:32:33.000000000 +0000
+++ linux-post-2.6.3-20040223/include/linux/tty_driver.h	2004-02-23 05:24:03.000000000 +0000
@@ -160,9 +160,10 @@ struct tty_driver {
 	const char	*devfs_name;
 	const char	*name;
 	int	name_base;	/* offset of printed name */
-	short	major;		/* major device number */
-	short	minor_start;	/* start of minor device number*/
-	short	num;		/* number of devices */
+	int	major;		/* major device number */
+	int	minor_start;	/* start of minor device number */
+	int	minor_num;	/* number of *possible* devices */
+	int	num;		/* number of devices allocated */
 	short	type;		/* type of tty driver */
 	short	subtype;	/* subtype of tty driver */
 	struct termios init_termios; /* Initial termios */
@@ -244,11 +245,15 @@ void tty_set_operations(struct tty_drive
  * TTY_DRIVER_NO_DEVFS --- if set, do not create devfs entries. This
  *	is only used by tty_register_driver().
  *
+ * TTY_DRIVER_DEVPTS_MEM -- don't use the standard arrays, instead
+ *	use dynamic memory keyed through the devpts filesystem.  This
+ *	is only applicable to the pty driver.
  */
 #define TTY_DRIVER_INSTALLED		0x0001
 #define TTY_DRIVER_RESET_TERMIOS	0x0002
 #define TTY_DRIVER_REAL_RAW		0x0004
 #define TTY_DRIVER_NO_DEVFS		0x0008
+#define TTY_DRIVER_DEVPTS_MEM		0x0010
 
 /* tty driver types */
 #define TTY_DRIVER_TYPE_SYSTEM		0x0001
diff -purN linux-post-2.6.3-20040222/ipc/shm.c linux-post-2.6.3-20040223/ipc/shm.c
--- linux-post-2.6.3-20040222/ipc/shm.c	2003-08-28 17:08:22.000000000 +0000
+++ linux-post-2.6.3-20040223/ipc/shm.c	2004-02-23 03:10:39.000000000 +0000
@@ -635,7 +635,7 @@ out:
  * "raddr" thing points to kernel space, and there has to be a wrapper around
  * this.
  */
-long sys_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr)
+asmlinkage long sys_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr)
 {
 	struct shmid_kernel *shp;
 	unsigned long addr;
diff -purN linux-post-2.6.3-20040222/ipc/util.c linux-post-2.6.3-20040223/ipc/util.c
--- linux-post-2.6.3-20040222/ipc/util.c	2004-01-27 11:21:35.000000000 +0000
+++ linux-post-2.6.3-20040223/ipc/util.c	2004-02-23 05:24:11.000000000 +0000
@@ -547,67 +547,4 @@ void exit_sem(struct task_struct *tsk)
 	return;
 }
 
-asmlinkage long sys_semget (key_t key, int nsems, int semflg)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_semop (int semid, struct sembuf *sops, unsigned nsops)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_semtimedop(int semid, struct sembuf *sops, unsigned nsops,
-				const struct timespec *timeout)
-{
-	return -ENOSYS;
-}
-
-
-asmlinkage long sys_semctl (int semid, int semnum, int cmd, union semun arg)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_msgget (key_t key, int msgflg)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_msgsnd (int msqid, struct msgbuf *msgp, size_t msgsz, int msgflg)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_msgrcv (int msqid, struct msgbuf *msgp, size_t msgsz, long msgtyp,
-		       int msgflg)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_msgctl (int msqid, int cmd, struct msqid_ds *buf)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_shmget (key_t key, size_t size, int shmflag)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_shmat (int shmid, char *shmaddr, int shmflg, ulong *addr)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_shmdt (char *shmaddr)
-{
-	return -ENOSYS;
-}
-
-asmlinkage long sys_shmctl (int shmid, int cmd, struct shmid_ds *buf)
-{
-	return -ENOSYS;
-}
-
 #endif /* CONFIG_SYSVIPC */
diff -purN linux-post-2.6.3-20040222/kernel/sys.c linux-post-2.6.3-20040223/kernel/sys.c
--- linux-post-2.6.3-20040222/kernel/sys.c	2004-02-19 03:42:38.000000000 +0000
+++ linux-post-2.6.3-20040223/kernel/sys.c	2004-02-23 05:24:11.000000000 +0000
@@ -249,6 +249,18 @@ cond_syscall(compat_sys_futex)
 cond_syscall(sys_epoll_create)
 cond_syscall(sys_epoll_ctl)
 cond_syscall(sys_epoll_wait)
+cond_syscall(sys_semget)
+cond_syscall(sys_semop)
+cond_syscall(sys_semtimedop)
+cond_syscall(sys_semctl)
+cond_syscall(sys_msgget)
+cond_syscall(sys_msgsnd)
+cond_syscall(sys_msgrcv)
+cond_syscall(sys_msgctl)
+cond_syscall(sys_shmget)
+cond_syscall(sys_shmat)
+cond_syscall(sys_shmdt)
+cond_syscall(sys_shmctl)
 
 /* arch-specific weak syscall entries */
 cond_syscall(sys_pciconfig_read)
diff -purN linux-post-2.6.3-20040222/kernel/sysctl.c linux-post-2.6.3-20040223/kernel/sysctl.c
--- linux-post-2.6.3-20040222/kernel/sysctl.c	2004-02-19 03:43:21.000000000 +0000
+++ linux-post-2.6.3-20040223/kernel/sysctl.c	2004-02-23 05:24:10.000000000 +0000
@@ -133,6 +133,9 @@ static ctl_table fs_table[];
 static ctl_table debug_table[];
 static ctl_table dev_table[];
 extern ctl_table random_table[];
+#ifdef CONFIG_UNIX98_PTYS
+extern ctl_table pty_table[];
+#endif
 
 /* /proc declarations: */
 
@@ -518,6 +521,14 @@ static ctl_table kern_table[] = {
 		.mode		= 0555,
 		.child		= random_table,
 	},
+#ifdef CONFIG_UNIX98_PTYS
+	{
+		.ctl_name	= KERN_PTY,
+		.procname	= "pty",
+		.mode		= 0555,
+		.child		= pty_table,
+	},
+#endif
 	{
 		.ctl_name	= KERN_OVERFLOWUID,
 		.procname	= "overflowuid",
@@ -877,27 +888,13 @@ int do_sysctl(int __user *name, int nlen
 asmlinkage long sys_sysctl(struct __sysctl_args __user *args)
 {
 	struct __sysctl_args tmp;
-	int name[2];
 	int error;
 
 	if (copy_from_user(&tmp, args, sizeof(tmp)))
 		return -EFAULT;
-	
-	if (tmp.nlen != 2 || copy_from_user(name, tmp.name, sizeof(name)) ||
-	    name[0] != CTL_KERN || name[1] != KERN_VERSION) { 
-		int i;
-		printk(KERN_INFO "%s: numerical sysctl ", current->comm); 
-		for (i = 0; i < tmp.nlen; i++) {
-			int n;
-			
-			if (get_user(n, tmp.name+i)) {
-				printk("? ");
-			} else {
-				printk("%d ", n);
-			}
-		}
-		printk("is obsolete.\n");
-	} 
+
+	if (tmp.nlen < 0 || tmp.nlen > CTL_MAXNAME)
+		return -EINVAL;
 
 	lock_kernel();
 	error = do_sysctl(tmp.name, tmp.nlen, tmp.oldval, tmp.oldlenp,
