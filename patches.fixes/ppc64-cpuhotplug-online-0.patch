--- ./drivers/base/cpu.c.orig	Tue Jun  1 15:02:29 2004
+++ ./drivers/base/cpu.c	Tue Jun  1 15:14:33 2004
@@ -48,7 +48,8 @@ static SYSDEV_ATTR(online, 0600, show_on
 
 static void __init register_cpu_control(struct cpu *cpu)
 {
-	sysdev_create_file(&cpu->sysdev, &attr_online);
+	if (cpu_is_hotpluggable(cpu))
+		sysdev_create_file(&cpu->sysdev, &attr_online);
 }
 #else /* ... !CONFIG_HOTPLUG_CPU */
 static inline void register_cpu_control(struct cpu *cpu)
--- ./include/linux/cpu.h.orig	Tue Jun  1 15:16:49 2004
+++ ./include/linux/cpu.h	Tue Jun  1 15:16:57 2004
@@ -64,6 +64,7 @@ extern struct semaphore cpucontrol;
 	register_cpu_notifier(&fn##_nb);			\
 }
 int cpu_down(unsigned int cpu);
+extern int cpu_is_hotpluggable(struct cpu *cpu);
 #define cpu_is_offline(cpu) unlikely(!cpu_online(cpu))
 #else
 #define lock_cpu_hotplug()	do { } while (0)
@@ -73,6 +74,7 @@ int cpu_down(unsigned int cpu);
 
 /* CPUs don't go offline once they're online w/o CONFIG_HOTPLUG_CPU */
 #define cpu_is_offline(cpu) 0
+#define cpu_is_hotpluggable(cpu) 0
 #endif
 
 #endif /* _LINUX_CPU_H_ */
--- ./arch/ppc64/kernel/smp.c.orig	Tue Jun  1 15:20:33 2004
+++ ./arch/ppc64/kernel/smp.c	Tue Jun  1 15:20:37 2004
@@ -530,6 +530,19 @@ static inline void look_for_more_cpus(vo
 	for (i = 0; i < maxcpus; i++)
 		cpu_set(i, cpu_possible_map);
 }
+
+int cpu_is_hotpluggable(struct cpu *cpu)
+{
+	/*
+	 * Instead of just checking the platform, we should
+	 * actually go look up the OpenFirmware node for the
+	 * CPU and make sure that this is OK.  Not all LPARs
+	 * support CPU hotplug.
+	 */
+	if (systemcfg->platform != PLATFORM_PSERIES_LPAR)
+		return 0;
+	return 1;
+}
 #else /* ... CONFIG_HOTPLUG_CPU */
 static inline int __devinit smp_startup_cpu(unsigned int lcpu)
 {
