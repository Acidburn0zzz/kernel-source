diff -purN linux-post-2.6.4rc2-20040306/Documentation/kernel-parameters.txt linux-post-2.6.4rc2-20040307/Documentation/kernel-parameters.txt
--- linux-post-2.6.4rc2-20040306/Documentation/kernel-parameters.txt	2004-02-26 11:26:00.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/Documentation/kernel-parameters.txt	2004-02-27 07:43:54.000000000 +0000
@@ -90,10 +90,13 @@ running once the system is up.
 			Format: <irq>, default is 13
 
 	acpi=		[HW,ACPI] Advanced Configuration and Power Interface 
-			Format: { force | off | ht }
+			Format: { force | off | ht | strict }
 			force -- enables ACPI for systems with default off
 			off -- disabled ACPI for systems with default on
 			ht -- run only enough ACPI to enable Hyper Threading
+			strict --  Be less tolerant of platforms that are not
+				strictly ACPI specification compliant.
+
 			See also Documentation/pm.txt.
  
 	acpi_pic_sci=	[HW,ACPI] ACPI System Control Interrupt trigger mode
diff -purN linux-post-2.6.4rc2-20040306/MAINTAINERS linux-post-2.6.4rc2-20040307/MAINTAINERS
--- linux-post-2.6.4rc2-20040306/MAINTAINERS	2004-03-02 03:01:27.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/MAINTAINERS	2004-03-06 16:19:10.000000000 +0000
@@ -172,7 +172,7 @@ ACPI
 P:	Len Brown
 M:	len.brown@intel.com
 L:	acpi-devel@lists.sourceforge.net
-W:	http://sf.net/projects/acpi/
+W:	http://acpi.sourceforge.net/
 S:	Maintained
 
 AD1816 SOUND DRIVER
diff -purN linux-post-2.6.4rc2-20040306/arch/i386/Kconfig linux-post-2.6.4rc2-20040307/arch/i386/Kconfig
--- linux-post-2.6.4rc2-20040306/arch/i386/Kconfig	2004-02-25 02:33:39.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/i386/Kconfig	2004-03-01 06:25:38.000000000 +0000
@@ -1068,12 +1068,16 @@ config PCI_GOBIOS
 	  PCI-based systems don't have any BIOS at all. Linux can also try to
 	  detect the PCI hardware directly without using the BIOS.
 
-	  With this option, you can specify how Linux should detect the PCI
-	  devices. If you choose "BIOS", the BIOS will be used, if you choose
-	  "Direct", the BIOS won't be used, and if you choose "Any", the
-	  kernel will try the direct access method and falls back to the BIOS
-	  if that doesn't work. If unsure, go with the default, which is
-	  "Any".
+	  With this option, you can specify how Linux should detect the
+	  PCI devices. If you choose "BIOS", the BIOS will be used,
+	  if you choose "Direct", the BIOS won't be used, and if you
+	  choose "MMConfig", then PCI Express MMCONFIG will be used.
+	  If you choose "Any", the kernel will try MMCONFIG, then the
+	  direct access method and falls back to the BIOS if that doesn't
+	  work. If unsure, go with the default, which is "Any".
+
+config PCI_GOMMCONFIG
+	bool "MMConfig"
 
 config PCI_GODIRECT
 	bool "Direct"
@@ -1093,6 +1097,12 @@ config PCI_DIRECT
  	depends on PCI && ((PCI_GODIRECT || PCI_GOANY) || X86_VISWS)
 	default y
 
+config PCI_MMCONFIG
+	bool
+	depends on PCI && (PCI_GOMMCONFIG || PCI_GOANY)
+	select ACPI_BOOT
+	default y
+
 config PCI_USE_VECTOR
 	bool "Vector-based interrupt indexing (MSI)"
 	depends on X86_LOCAL_APIC && X86_IO_APIC
diff -purN linux-post-2.6.4rc2-20040306/arch/i386/kernel/acpi/boot.c linux-post-2.6.4rc2-20040307/arch/i386/kernel/acpi/boot.c
--- linux-post-2.6.4rc2-20040306/arch/i386/kernel/acpi/boot.c	2004-02-19 03:42:28.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/i386/kernel/acpi/boot.c	2004-03-01 08:30:55.000000000 +0000
@@ -35,7 +35,7 @@
 #include <asm/irq.h>
 #include <asm/mpspec.h>
 
-#if defined (CONFIG_X86_LOCAL_APIC)
+#ifdef CONFIG_X86_LOCAL_APIC
 #include <mach_apic.h>
 #include <mach_mpparse.h>
 #include <asm/io_apic.h>
@@ -43,17 +43,26 @@
 
 #define PREFIX			"ACPI: "
 
-int acpi_noirq __initdata = 0;	/* skip ACPI IRQ initialization */
+int acpi_noirq __initdata;	/* skip ACPI IRQ initialization */
 int acpi_ht __initdata = 1;	/* enable HT */
 
 int acpi_lapic;
 int acpi_ioapic;
+int acpi_strict;
+
+#ifdef CONFIG_X86_LOCAL_APIC
+static u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;
+#endif
 
 /* --------------------------------------------------------------------------
                               Boot-time Configuration
    -------------------------------------------------------------------------- */
 
-enum acpi_irq_model_id		acpi_irq_model;
+/*
+ * The default interrupt routing model is PIC (8259).  This gets
+ * overriden if IOAPICs are enumerated (below).
+ */
+enum acpi_irq_model_id		acpi_irq_model = ACPI_IRQ_MODEL_PIC;
 
 /*
  * Temporarily use the virtual area starting from FIX_IO_APIC_BASE_END,
@@ -96,11 +105,32 @@ char *__acpi_map_table(unsigned long phy
 }
 
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#ifdef CONFIG_PCI_MMCONFIG
+static int __init acpi_parse_mcfg(unsigned long phys_addr, unsigned long size)
+{
+	struct acpi_table_mcfg *mcfg;
 
-static u64 acpi_lapic_addr __initdata = APIC_DEFAULT_PHYS_BASE;
+	if (!phys_addr || !size)
+		return -EINVAL;
+
+	mcfg = (struct acpi_table_mcfg *) __acpi_map_table(phys_addr, size);
+	if (!mcfg) {
+		printk(KERN_WARNING PREFIX "Unable to map MCFG\n");
+		return -ENODEV;
+	}
 
+	if (mcfg->base_reserved) {
+		printk(KERN_ERR PREFIX "MMCONFIG not in low 4GB of memory\n");
+		return -ENODEV;
+	}
+
+	pci_mmcfg_base_addr = mcfg->base_address;
+
+	return 0;
+}
+#endif /* CONFIG_PCI_MMCONFIG */
 
+#ifdef CONFIG_X86_LOCAL_APIC
 static int __init
 acpi_parse_madt (
 	unsigned long		phys_addr,
@@ -117,11 +147,12 @@ acpi_parse_madt (
 		return -ENODEV;
 	}
 
-	if (madt->lapic_address)
+	if (madt->lapic_address) {
 		acpi_lapic_addr = (u64) madt->lapic_address;
 
-	printk(KERN_INFO PREFIX "Local APIC address 0x%08x\n",
-		madt->lapic_address);
+		printk(KERN_DEBUG PREFIX "Local APIC address 0x%08x\n",
+			madt->lapic_address);
+	}
 
 	acpi_madt_oem_check(madt->header.oem_id, madt->header.oem_table_id);
 	
@@ -251,7 +282,7 @@ acpi_parse_nmi_src (
 	return 0;
 }
 
-#endif /*CONFIG_X86_IO_APIC*/
+#endif /* CONFIG_X86_IO_APIC */
 
 #ifdef	CONFIG_ACPI_BUS
 /*
@@ -259,7 +290,7 @@ acpi_parse_nmi_src (
  * programs the PIC-mode SCI to Level Trigger.
  * (NO-OP if the BIOS set Level Trigger already)
  *
- * If a PIC-mode SCI is not recogznied or gives spurious IRQ7's
+ * If a PIC-mode SCI is not recognized or gives spurious IRQ7's
  * it may require Edge Trigger -- use "acpi_pic_sci=edge"
  * (NO-OP if the BIOS set Edge Trigger already)
  *
@@ -347,6 +378,25 @@ acpi_scan_rsdp (
 	return 0;
 }
 
+static int __init acpi_parse_sbf(unsigned long phys_addr, unsigned long size)
+{
+	struct acpi_table_sbf *sb;
+
+	if (!phys_addr || !size)
+	return -EINVAL;
+
+	sb = (struct acpi_table_sbf *) __acpi_map_table(phys_addr, size);
+	if (!sb) {
+		printk(KERN_WARNING PREFIX "Unable to map SBF\n");
+		return -ENODEV;
+	}
+
+	sbf_port = sb->sbf_cmos; /* Save CMOS port */
+
+	return 0;
+}
+
+
 #ifdef CONFIG_HPET_TIMER
 extern unsigned long hpet_address;
 
@@ -429,126 +479,61 @@ acpi_find_rsdp (void)
 	return rsdp_phys;
 }
 
+#ifdef	CONFIG_X86_LOCAL_APIC
 /*
- * acpi_boot_init()
- *  called from setup_arch(), always.
- *	1. maps ACPI tables for later use
- *	2. enumerates lapics
- *	3. enumerates io-apics
- *
- * side effects:
- *	acpi_lapic = 1 if LAPIC found
- *	acpi_ioapic = 1 if IOAPIC found
- *	if (acpi_lapic && acpi_ioapic) smp_found_config = 1;
- *	if acpi_blacklisted() acpi_disabled = 1;
- *	acpi_irq_model=...
- *	...
- *
- * return value: (currently ignored)
- *	0: success
- *	!0: failure
+ * Parse LAPIC entries in MADT
+ * returns 0 on success, < 0 on error
  */
-
-int __init
-acpi_boot_init (void)
+static int __init
+acpi_parse_madt_lapic_entries(void)
 {
-	int			result = 0;
-
-	if (acpi_disabled && !acpi_ht)
-		 return 1;
-
-	/*
-	 * The default interrupt routing model is PIC (8259).  This gets
-	 * overriden if IOAPICs are enumerated (below).
-	 */
-	acpi_irq_model = ACPI_IRQ_MODEL_PIC;
-
-	/* 
-	 * Initialize the ACPI boot-time table parser.
-	 */
-	result = acpi_table_init();
-	if (result) {
-		acpi_disabled = 1;
-		return result;
-	}
-
-	result = acpi_blacklisted();
-	if (result) {
-		printk(KERN_WARNING PREFIX "BIOS listed in blacklist, disabling ACPI support\n");
-		acpi_disabled = 1;
-		return result;
-	}
-
-#ifdef CONFIG_X86_PM_TIMER
-	acpi_table_parse(ACPI_FADT, acpi_parse_fadt);
-#endif
-
-#ifdef CONFIG_X86_LOCAL_APIC
-
-	/* 
-	 * MADT
-	 * ----
-	 * Parse the Multiple APIC Description Table (MADT), if exists.
-	 * Note that this table provides platform SMP configuration 
-	 * information -- the successor to MPS tables.
-	 */
-
-	result = acpi_table_parse(ACPI_APIC, acpi_parse_madt);
-	if (!result) {
-		return 0;
-	}
-	else if (result < 0) {
-		printk(KERN_ERR PREFIX "Error parsing MADT\n");
-		return result;
-	}
-	else if (result > 1) 
-		printk(KERN_WARNING PREFIX "Multiple MADT tables exist\n");
+	int count;
 
 	/* 
-	 * Local APIC
-	 * ----------
 	 * Note that the LAPIC address is obtained from the MADT (32-bit value)
 	 * and (optionally) overriden by a LAPIC_ADDR_OVR entry (64-bit value).
 	 */
 
-	result = acpi_table_parse_madt(ACPI_MADT_LAPIC_ADDR_OVR, acpi_parse_lapic_addr_ovr, 0);
-	if (result < 0) {
+	count = acpi_table_parse_madt(ACPI_MADT_LAPIC_ADDR_OVR, acpi_parse_lapic_addr_ovr, 0);
+	if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing LAPIC address override entry\n");
-		return result;
+		return count;
 	}
 
 	mp_register_lapic_address(acpi_lapic_addr);
 
-	result = acpi_table_parse_madt(ACPI_MADT_LAPIC, acpi_parse_lapic,
+	count = acpi_table_parse_madt(ACPI_MADT_LAPIC, acpi_parse_lapic,
 				       MAX_APICS);
-	if (!result) { 
+	if (!count) { 
 		printk(KERN_ERR PREFIX "No LAPIC entries present\n");
 		/* TBD: Cleanup to allow fallback to MPS */
 		return -ENODEV;
 	}
-	else if (result < 0) {
+	else if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing LAPIC entry\n");
 		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
+		return count;
 	}
 
-	result = acpi_table_parse_madt(ACPI_MADT_LAPIC_NMI, acpi_parse_lapic_nmi, 0);
-	if (result < 0) {
+	count = acpi_table_parse_madt(ACPI_MADT_LAPIC_NMI, acpi_parse_lapic_nmi, 0);
+	if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing LAPIC NMI entry\n");
 		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
+		return count;
 	}
-
-	acpi_lapic = 1;
-
-#endif /*CONFIG_X86_LOCAL_APIC*/
+	return 0;
+}
+#endif /* CONFIG_X86_LOCAL_APIC */
 
 #if defined(CONFIG_X86_IO_APIC) && defined(CONFIG_ACPI_INTERPRETER)
-
-	/* 
-	 * I/O APIC 
-	 * --------
-	 */
+/*
+ * Parse IOAPIC related entries in MADT
+ * returns 0 on success, < 0 on error
+ */
+static int __init
+acpi_parse_madt_ioapic_entries(void)
+{
+	int count;
 
 	/*
 	 * ACPI interpreter is required to complete interrupt setup,
@@ -557,7 +542,7 @@ acpi_boot_init (void)
 	 * otherwise the system will stay in PIC mode
 	 */
 	if (acpi_disabled || acpi_noirq) {
-		return 1;
+		return -ENODEV;
         }
 
 	/*
@@ -566,54 +551,152 @@ acpi_boot_init (void)
 	if (ioapic_setup_disabled()) {
 		printk(KERN_INFO PREFIX "Skipping IOAPIC probe "
 			"due to 'noapic' option.\n");
-		return 1;
+		return -ENODEV;
 	}
 
-	result = acpi_table_parse_madt(ACPI_MADT_IOAPIC, acpi_parse_ioapic, MAX_IO_APICS);
-	if (!result) {
+	count = acpi_table_parse_madt(ACPI_MADT_IOAPIC, acpi_parse_ioapic, MAX_IO_APICS);
+	if (!count) {
 		printk(KERN_ERR PREFIX "No IOAPIC entries present\n");
 		return -ENODEV;
 	}
-	else if (result < 0) {
+	else if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing IOAPIC entry\n");
-		return result;
+		return count;
 	}
 
 	/* Build a default routing table for legacy (ISA) interrupts. */
 	mp_config_acpi_legacy_irqs();
 
-	result = acpi_table_parse_madt(ACPI_MADT_INT_SRC_OVR, acpi_parse_int_src_ovr, NR_IRQ_VECTORS);
-	if (result < 0) {
+	count = acpi_table_parse_madt(ACPI_MADT_INT_SRC_OVR, acpi_parse_int_src_ovr, NR_IRQ_VECTORS);
+	if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing interrupt source overrides entry\n");
 		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
+		return count;
 	}
 
-	result = acpi_table_parse_madt(ACPI_MADT_NMI_SRC, acpi_parse_nmi_src, NR_IRQ_VECTORS);
-	if (result < 0) {
+	count = acpi_table_parse_madt(ACPI_MADT_NMI_SRC, acpi_parse_nmi_src, NR_IRQ_VECTORS);
+	if (count < 0) {
 		printk(KERN_ERR PREFIX "Error parsing NMI SRC entry\n");
 		/* TBD: Cleanup to allow fallback to MPS */
-		return result;
+		return count;
 	}
 
-	acpi_irq_model = ACPI_IRQ_MODEL_IOAPIC;
+	return 0;
+}
+#else
+static inline int acpi_parse_madt_ioapic_entries(void)
+{
+	return -1;
+}
+#endif /* !(CONFIG_X86_IO_APIC && CONFIG_ACPI_INTERPRETER) */
 
-	acpi_irq_balance_set(NULL);
 
-	acpi_ioapic = 1;
+static void __init
+acpi_process_madt(void)
+{
+#ifdef CONFIG_X86_LOCAL_APIC
+	int count, error;
 
-#endif /* CONFIG_X86_IO_APIC && CONFIG_ACPI_INTERPRETER */
+	count = acpi_table_parse(ACPI_APIC, acpi_parse_madt);
+	if (count == 1) {
 
-#ifdef CONFIG_X86_LOCAL_APIC
-	if (acpi_lapic && acpi_ioapic) {
-		smp_found_config = 1;
-		clustered_apic_check();
+		/*
+		 * Parse MADT LAPIC entries
+		 */
+		error = acpi_parse_madt_lapic_entries();
+		if (!error) {
+			acpi_lapic = 1;
+
+			/*
+			 * Parse MADT IO-APIC entries
+			 */
+			error = acpi_parse_madt_ioapic_entries();
+			if (!error) {
+				acpi_irq_model = ACPI_IRQ_MODEL_IOAPIC;
+				acpi_irq_balance_set(NULL);
+				acpi_ioapic = 1;
+
+				smp_found_config = 1;
+				clustered_apic_check();
+			}
+		}
 	}
 #endif
+	return;
+}
+
+/*
+ * acpi_boot_init()
+ *  called from setup_arch(), always.
+ *	1. checksums all tables
+ *	2. enumerates lapics
+ *	3. enumerates io-apics
+ *
+ * side effects:
+ *	acpi_lapic = 1 if LAPIC found
+ *	acpi_ioapic = 1 if IOAPIC found
+ *	if (acpi_lapic && acpi_ioapic) smp_found_config = 1;
+ *	if acpi_blacklisted() acpi_disabled = 1;
+ *	acpi_irq_model=...
+ *	...
+ *
+ * return value: (currently ignored)
+ *	0: success
+ *	!0: failure
+ */
+
+int __init
+acpi_boot_init (void)
+{
+	int error;
+
+	/*
+	 * If acpi_disabled, bail out
+	 * One exception: acpi=ht continues far enough to enumerate LAPICs
+	 */
+	if (acpi_disabled && !acpi_ht)
+		 return 1;
+
+	/* 
+	 * Initialize the ACPI boot-time table parser.
+	 */
+	error = acpi_table_init();
+	if (error) {
+		acpi_disabled = 1;
+		return error;
+	}
+
+	(void) acpi_table_parse(ACPI_BOOT, acpi_parse_sbf);
+
+	/*
+	 * blacklist may disable ACPI entirely
+	 */
+	error = acpi_blacklisted();
+	if (error) {
+		printk(KERN_WARNING PREFIX "BIOS listed in blacklist, disabling ACPI support\n");
+		acpi_disabled = 1;
+		return error;
+	}
+
+	/*
+	 * Process the Multiple APIC Description Table (MADT), if present
+	 */
+	acpi_process_madt();
+
+#ifdef CONFIG_X86_PM_TIMER
+	acpi_table_parse(ACPI_FADT, acpi_parse_fadt);
+#endif
 
 #ifdef CONFIG_HPET_TIMER
-	acpi_table_parse(ACPI_HPET, acpi_parse_hpet);
+	(void) acpi_table_parse(ACPI_HPET, acpi_parse_hpet);
+#endif
+
+#ifdef CONFIG_PCI_MMCONFIG
+	error = acpi_table_parse(ACPI_MCFG, acpi_parse_mcfg);
+	if (error)
+		printk(KERN_ERR PREFIX "Error %d parsing MCFG\n", error);
 #endif
 
 	return 0;
 }
+
diff -purN linux-post-2.6.4rc2-20040306/arch/i386/kernel/bootflag.c linux-post-2.6.4rc2-20040307/arch/i386/kernel/bootflag.c
--- linux-post-2.6.4rc2-20040306/arch/i386/kernel/bootflag.c	2002-12-21 01:46:02.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/i386/kernel/bootflag.c	2004-03-01 08:26:35.000000000 +0000
@@ -1,6 +1,5 @@
 /*
- *	Implement 'Simple Boot Flag Specification 1.0'
- *
+ *	Implement 'Simple Boot Flag Specification 2.0'
  */
 
 
@@ -11,6 +10,7 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#include <linux/acpi.h>
 #include <asm/io.h>
 
 #include <linux/mc146818rtc.h>
@@ -23,56 +23,8 @@
 #define SBF_PARITY   (1<<7)
 
 
-struct sbf_boot
-{
-	u8 sbf_signature[4];
-	u32 sbf_len;
-	u8 sbf_revision __attribute((packed));
-	u8 sbf_csum __attribute((packed));
-	u8 sbf_oemid[6] __attribute((packed));
-	u8 sbf_oemtable[8] __attribute((packed));
-	u8 sbf_revdata[4] __attribute((packed));
-	u8 sbf_creator[4] __attribute((packed));
-	u8 sbf_crearev[4] __attribute((packed));
-	u8 sbf_cmos __attribute((packed));
-	u8 sbf_spare[3] __attribute((packed));
-};
-
-
-static int sbf_port __initdata = -1;
-
-static int __init sbf_struct_valid(unsigned long tptr)
-{
-	u8 *ap;
-	u8 v;
-	unsigned int i;
-	struct sbf_boot sb;
-	
-	memcpy_fromio(&sb, (void *)tptr, sizeof(sb));
-
-	if(sb.sbf_len != 40 && sb.sbf_len != 39)
-		// 39 on IBM ThinkPad A21m, BIOS version 1.02b (KXET24WW; 2000-12-19).
-		return 0;
-
-	ap = (u8 *)&sb;
-	v= 0;
-	
-	for(i=0;i<sb.sbf_len;i++)
-		v+=*ap++;
-		
-	if(v)
-		return 0;
-
-	if(memcmp(sb.sbf_signature, "BOOT", 4))
-		return 0;
+int sbf_port __initdata = -1;	/* set via acpi_boot_init() */
 
-	if (sb.sbf_len == 39)
-		printk (KERN_WARNING "SBF: ACPI BOOT descriptor is wrong length (%d)\n",
-			sb.sbf_len);
-
-	sbf_port = sb.sbf_cmos;	/* Save CMOS port */
-	return 1;
-}
 
 static int __init parity(u8 v)
 {
@@ -96,7 +48,7 @@ static void __init sbf_write(u8 v)
 		if(!parity(v))
 			v|=SBF_PARITY;
 
-		printk(KERN_INFO "SBF: Setting boot flags 0x%x\n",v);
+		printk(KERN_INFO "Simple Boot Flag 0x%x\n", v);
 
 		spin_lock_irqsave(&rtc_lock, flags);
 		CMOS_WRITE(v, sbf_port);
@@ -125,15 +77,15 @@ static int __init sbf_value_valid(u8 v)
 	return 1;
 }
 
-
-static void __init sbf_bootup(void)
+static int __init sbf_init(void)
 {
 	u8 v;
 	if(sbf_port == -1)
-		return;
+		return 0;
 	v = sbf_read();
 	if(!sbf_value_valid(v))
-		printk(KERN_WARNING "SBF: Simple boot flag value 0x%x read from CMOS RAM was invalid\n",v);
+		printk(KERN_WARNING "Simple Boot Flag value 0x%x read from CMOS RAM was invalid\n",v);
+
 	v &= ~SBF_RESERVED;
 	v &= ~SBF_BOOTING;
 	v &= ~SBF_DIAG;
@@ -141,112 +93,6 @@ static void __init sbf_bootup(void)
 	v |= SBF_PNPOS;
 #endif
 	sbf_write(v);
-}
-
-static int __init sbf_init(void)
-{
-	unsigned int i;
-	void *rsdt;
-	u32 rsdtlen = 0;
-	u32 rsdtbase = 0;
-	u8 sum = 0;
-	int n;
-	
-	u8 *p;
-	
-	for(i=0xE0000; i <= 0xFFFE0; i+=16)
-	{
-		p = phys_to_virt(i);
-		
-		if(memcmp(p, "RSD PTR ", 8))
-			continue;
-		
-		sum = 0;
-		for(n=0; n<20; n++)
-			sum+=p[n];
-			
-		if(sum != 0)
-			continue;
-			
-		/* So it says RSD PTR and it checksums... */
-
-		/*
-		 *	Process the RDSP pointer
-		 */
-	 
-		rsdtbase = *(u32 *)(p+16);
-		
-		/*
-		 *	RSDT length is ACPI 2 only, for ACPI 1 we must map
-		 *	and remap.
-		 */
-		 
-		if(p[15]>1)
-			rsdtlen = *(u32 *)(p+20);
-		else
-			rsdtlen = 36;
-
-		if(rsdtlen < 36 || rsdtlen > 1024)
-			continue;
-		break;
-	}
-	if(i>0xFFFE0)
-		return 0;
-		
-		
-	rsdt = ioremap(rsdtbase, rsdtlen);
-	if(rsdt == 0)
-		return 0;
-		
-	i = readl(rsdt + 4);
-	
-	/*
-	 *	Remap if needed
-	 */
-	 
-	if(i > rsdtlen)
-	{
-		rsdtlen = i;
-		iounmap(rsdt);
-		rsdt = ioremap(rsdtbase, rsdtlen);
-		if(rsdt == 0)
-			return 0;
-	}
-	
-	for(n = 0; n < i; n++)
-		sum += readb(rsdt + n);
-		
-	if(sum)
-	{
-		iounmap(rsdt);
-		return 0;
-	}
-	
-	/* Ok the RSDT checksums too */
-	
-	for(n = 36; n+3 < i; n += 4)
-	{
-		unsigned long rp = readl(rsdt+n);
-		int len = 4096;
-
-		if(rp > 0xFFFFFFFFUL - len)
-			len = 0xFFFFFFFFUL - rp;
-			
-		/* Too close to the end!! */
-		if(len < 20)
-			continue;
-		rp = (unsigned long)ioremap(rp, 4096);
-		if(rp == 0)
-			continue;
-		if(sbf_struct_valid(rp))
-		{
-			/* Found the BOOT table and processed it */
-			printk(KERN_INFO "SBF: Simple Boot Flag extension found and enabled.\n");
-		}
-		iounmap((void *)rp);
-	}
-	iounmap(rsdt);
-	sbf_bootup();
 	return 0;
 }
 
diff -purN linux-post-2.6.4rc2-20040306/arch/i386/kernel/mpparse.c linux-post-2.6.4rc2-20040307/arch/i386/kernel/mpparse.c
--- linux-post-2.6.4rc2-20040306/arch/i386/kernel/mpparse.c	2004-02-11 02:30:25.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/i386/kernel/mpparse.c	2004-02-26 05:11:46.000000000 +0000
@@ -1156,7 +1156,7 @@ void __init mp_parse_prt (void)
 			continue;
 		}
 		if ((1<<bit) & mp_ioapic_routing[ioapic].pin_programmed[idx]) {
-			printk(KERN_DEBUG "Pin %d-%d already programmed\n",
+			Dprintk(KERN_DEBUG "Pin %d-%d already programmed\n",
 				mp_ioapic_routing[ioapic].apic_id, ioapic_pin);
  			entry->irq = acpi_irq_to_vector(irq);
 			continue;
diff -purN linux-post-2.6.4rc2-20040306/arch/i386/kernel/setup.c linux-post-2.6.4rc2-20040307/arch/i386/kernel/setup.c
--- linux-post-2.6.4rc2-20040306/arch/i386/kernel/setup.c	2004-02-19 03:42:21.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/i386/kernel/setup.c	2004-02-27 06:59:50.000000000 +0000
@@ -569,6 +569,11 @@ static void __init parse_cmdline_early (
 			acpi_disabled = 0;
 		}
 
+		/* acpi=strict disables out-of-spec workarounds */
+		else if (!memcmp(from, "acpi=strict", 11)) {
+			acpi_strict = 1;
+		}
+
 		/* Limit ACPI just to boot-time to enable HT */
 		else if (!memcmp(from, "acpi=ht", 7)) {
 			acpi_ht = 1;
diff -purN linux-post-2.6.4rc2-20040306/arch/i386/pci/Makefile linux-post-2.6.4rc2-20040307/arch/i386/pci/Makefile
--- linux-post-2.6.4rc2-20040306/arch/i386/pci/Makefile	2003-06-23 15:47:46.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/i386/pci/Makefile	2004-03-01 06:20:00.000000000 +0000
@@ -1,6 +1,7 @@
 obj-y				:= i386.o
 
 obj-$(CONFIG_PCI_BIOS)		+= pcbios.o
+obj-$(CONFIG_PCI_MMCONFIG)	+= mmconfig.o
 obj-$(CONFIG_PCI_DIRECT)	+= direct.o
 
 pci-y				:= fixup.o
diff -purN linux-post-2.6.4rc2-20040306/arch/i386/pci/common.c linux-post-2.6.4rc2-20040307/arch/i386/pci/common.c
--- linux-post-2.6.4rc2-20040306/arch/i386/pci/common.c	2003-12-12 02:19:07.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/i386/pci/common.c	2004-03-01 06:20:00.000000000 +0000
@@ -20,7 +20,8 @@
 extern  void pcibios_sort(void);
 #endif
 
-unsigned int pci_probe = PCI_PROBE_BIOS | PCI_PROBE_CONF1 | PCI_PROBE_CONF2;
+unsigned int pci_probe = PCI_PROBE_BIOS | PCI_PROBE_CONF1 | PCI_PROBE_CONF2 |
+				PCI_PROBE_MMCONF;
 
 int pcibios_last_bus = -1;
 struct pci_bus *pci_root_bus = NULL;
@@ -198,6 +199,12 @@ char * __devinit  pcibios_setup(char *st
 		return NULL;
 	}
 #endif
+#ifdef CONFIG_PCI_MMCONFIG
+	else if (!strcmp(str, "nommconf")) {
+		pci_probe &= ~PCI_PROBE_MMCONF;
+		return NULL;
+	}
+#endif
 	else if (!strcmp(str, "noacpi")) {
 		acpi_noirq_set();
 		return NULL;
diff -purN linux-post-2.6.4rc2-20040306/arch/i386/pci/mmconfig.c linux-post-2.6.4rc2-20040307/arch/i386/pci/mmconfig.c
--- linux-post-2.6.4rc2-20040306/arch/i386/pci/mmconfig.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/i386/pci/mmconfig.c	2004-03-01 06:20:00.000000000 +0000
@@ -0,0 +1,109 @@
+/*
+ * mmconfig.c - Low-level direct PCI config space access via MMCONFIG
+ */
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include "pci.h"
+
+/* The physical address of the MMCONFIG aperture.  Set from ACPI tables. */
+u32 pci_mmcfg_base_addr;
+
+#define mmcfg_virt_addr (fix_to_virt(FIX_PCIE_MCFG))
+
+/* The base address of the last MMCONFIG device accessed */
+static u32 mmcfg_last_accessed_device;
+
+/*
+ * Functions for accessing PCI configuration space with MMCONFIG accesses
+ */
+
+static inline void pci_exp_set_dev_base(int bus, int devfn)
+{
+	u32 dev_base = pci_mmcfg_base_addr | (bus << 20) | (devfn << 12);
+	if (dev_base != mmcfg_last_accessed_device) {
+		mmcfg_last_accessed_device = dev_base;
+		set_fixmap(FIX_PCIE_MCFG, dev_base);
+	}
+}
+
+static int pci_mmcfg_read(int seg, int bus, int devfn, int reg, int len, u32 *value)
+{
+	unsigned long flags;
+
+	if (!value || (bus > 255) || (devfn > 255) || (reg > 4095))
+		return -EINVAL;
+
+	spin_lock_irqsave(&pci_config_lock, flags);
+
+	pci_exp_set_dev_base(bus, devfn);
+
+	switch (len) {
+	case 1:
+		*value = readb(mmcfg_virt_addr + reg);
+		break;
+	case 2:
+		*value = readw(mmcfg_virt_addr + reg);
+		break;
+	case 4:
+		*value = readl(mmcfg_virt_addr + reg);
+		break;
+	}
+
+	spin_unlock_irqrestore(&pci_config_lock, flags);
+
+	return 0;
+}
+
+static int pci_mmcfg_write(int seg, int bus, int devfn, int reg, int len, u32 value)
+{
+	unsigned long flags;
+
+	if ((bus > 255) || (devfn > 255) || (reg > 4095)) 
+		return -EINVAL;
+
+	spin_lock_irqsave(&pci_config_lock, flags);
+
+	pci_exp_set_dev_base(bus, devfn);
+
+	switch (len) {
+	case 1:
+		writeb(value, mmcfg_virt_addr + reg);
+		break;
+	case 2:
+		writew(value, mmcfg_virt_addr + reg);
+		break;
+	case 4:
+		writel(value, mmcfg_virt_addr + reg);
+		break;
+	}
+
+	/* Dummy read to flush PCI write */
+	readl(mmcfg_virt_addr);
+
+	spin_unlock_irqrestore(&pci_config_lock, flags);
+
+	return 0;
+}
+
+static struct pci_raw_ops pci_mmcfg = {
+	.read =		pci_mmcfg_read,
+	.write =	pci_mmcfg_write,
+};
+
+static int __init pci_mmcfg_init(void)
+{
+	if ((pci_probe & PCI_PROBE_MMCONF) == 0)
+		goto out;
+	if (!pci_mmcfg_base_addr)
+		goto out;
+
+	printk(KERN_INFO "PCI: Using MMCONFIG\n");
+	raw_pci_ops = &pci_mmcfg;
+	pci_probe = (pci_probe & ~PCI_PROBE_MASK) | PCI_PROBE_MMCONF;
+
+ out:
+	return 0;
+}
+
+arch_initcall(pci_mmcfg_init);
diff -purN linux-post-2.6.4rc2-20040306/arch/i386/pci/pci.h linux-post-2.6.4rc2-20040307/arch/i386/pci/pci.h
--- linux-post-2.6.4rc2-20040306/arch/i386/pci/pci.h	2003-12-12 02:19:07.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/i386/pci/pci.h	2004-03-01 06:20:00.000000000 +0000
@@ -15,6 +15,9 @@
 #define PCI_PROBE_BIOS		0x0001
 #define PCI_PROBE_CONF1		0x0002
 #define PCI_PROBE_CONF2		0x0004
+#define PCI_PROBE_MMCONF	0x0008
+#define PCI_PROBE_MASK		0x000f
+
 #define PCI_NO_SORT		0x0100
 #define PCI_BIOS_SORT		0x0200
 #define PCI_NO_CHECKS		0x0400
diff -purN linux-post-2.6.4rc2-20040306/arch/x86_64/kernel/acpi/boot.c linux-post-2.6.4rc2-20040307/arch/x86_64/kernel/acpi/boot.c
--- linux-post-2.6.4rc2-20040306/arch/x86_64/kernel/acpi/boot.c	2004-02-11 02:28:58.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/x86_64/kernel/acpi/boot.c	2004-02-27 06:59:50.000000000 +0000
@@ -48,11 +48,12 @@
 
 #define PREFIX			"ACPI: "
 
-int acpi_noirq __initdata = 0;	/* skip ACPI IRQ initialization */
+int acpi_noirq __initdata;	/* skip ACPI IRQ initialization */
 int acpi_ht __initdata = 1;	/* enable HT */
 
 int acpi_lapic;
 int acpi_ioapic;
+int acpi_strict;
 
 /* --------------------------------------------------------------------------
                               Boot-time Configuration
@@ -264,7 +265,7 @@ acpi_parse_hpet (
  * programs the PIC-mode SCI to Level Trigger.
  * (NO-OP if the BIOS set Level Trigger already)
  *
- * If a PIC-mode SCI is not recogznied or gives spurious IRQ7's
+ * If a PIC-mode SCI is not recognized or gives spurious IRQ7's
  * it may require Edge Trigger -- use "acpi_pic_sci=edge"
  * (NO-OP if the BIOS set Edge Trigger already)
  *
diff -purN linux-post-2.6.4rc2-20040306/arch/x86_64/kernel/mpparse.c linux-post-2.6.4rc2-20040307/arch/x86_64/kernel/mpparse.c
--- linux-post-2.6.4rc2-20040306/arch/x86_64/kernel/mpparse.c	2004-02-25 16:06:01.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/arch/x86_64/kernel/mpparse.c	2004-02-26 05:11:46.000000000 +0000
@@ -996,7 +996,7 @@ void __init mp_parse_prt (void)
 			continue;
 		}
 		if ((1<<bit) & mp_ioapic_routing[ioapic].pin_programmed[idx]) {
-			printk(KERN_DEBUG "Pin %d-%d already programmed\n",
+			Dprintk(KERN_DEBUG "Pin %d-%d already programmed\n",
 				mp_ioapic_routing[ioapic].apic_id, ioapic_pin);
  			if (use_pci_vector() && !platform_legacy_irq(irq))
  				irq = IO_APIC_VECTOR(irq);
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/Kconfig linux-post-2.6.4rc2-20040307/drivers/acpi/Kconfig
--- linux-post-2.6.4rc2-20040306/drivers/acpi/Kconfig	2004-02-19 03:42:28.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/Kconfig	2004-02-27 07:02:52.000000000 +0000
@@ -251,18 +251,6 @@ config ACPI_SYSTEM
 	  This driver will enable your system to shut down using ACPI, and
 	  dump your ACPI DSDT table using /proc/acpi/dsdt.
 
-config ACPI_RELAXED_AML
-	bool "Relaxed AML"
-	depends on ACPI_INTERPRETER
-	depends on !IA64_SGI_SN
-	default n
-	help
-	  If you say `Y' here, the ACPI interpreter will relax its checking
-	  for valid AML and will ignore some AML mistakes, such as off-by-one
-	  errors in region sizes.  Some laptops may require this option.  In
-	  particular, many Toshiba laptops require this for correct operation
-	  of the AC module.
-
 config X86_PM_TIMER
 	bool "Power Management Timer Support"
 	depends on X86 && ACPI
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/executer/exfldio.c linux-post-2.6.4rc2-20040307/drivers/acpi/executer/exfldio.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/executer/exfldio.c	2004-02-13 23:08:40.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/executer/exfldio.c	2004-02-27 05:57:51.000000000 +0000
@@ -154,8 +154,7 @@ acpi_ex_setup_region (
 			field_datum_byte_offset, obj_desc->common_field.access_byte_width,
 			acpi_ut_get_node_name (rgn_desc->region.node), rgn_desc->region.length));
 
-		#ifdef CONFIG_ACPI_RELAXED_AML
-		{
+		if (!acpi_strict) {
 			/*
 			 * Allow access to the field if it is within the region size
 			 * rounded up to a multiple of the access byte width.  This
@@ -186,9 +185,9 @@ acpi_ex_setup_region (
 				return_ACPI_STATUS (AE_OK);
 			}
 		}
-		#else
+		else {
 			return_ACPI_STATUS (AE_AML_REGION_LIMIT);
-		#endif
+		}
 	}
 
 	return_ACPI_STATUS (AE_OK);
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/hardware/hwgpe.c linux-post-2.6.4rc2-20040307/drivers/acpi/hardware/hwgpe.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/hardware/hwgpe.c	2004-01-17 23:12:31.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/hardware/hwgpe.c	2004-02-27 01:20:55.000000000 +0000
@@ -528,6 +528,14 @@ acpi_hw_enable_non_wakeup_gpe_block (
 	/* Examine each GPE register within the block */
 
 	for (i = 0; i < gpe_block->register_count; i++) {
+		/* Clear the entire status register */
+
+		status = acpi_hw_low_level_write (8, 0xFF,
+				 &gpe_block->register_info[i].status_address);
+		if (ACPI_FAILURE (status)) {
+			return (status);
+		}
+
 		/*
 		 * We previously stored the enabled status of all GPEs.
 		 * Blast them back in.
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/hardware/hwregs.c linux-post-2.6.4rc2-20040307/drivers/acpi/hardware/hwregs.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/hardware/hwregs.c	2004-01-17 23:12:32.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/hardware/hwregs.c	2004-02-27 01:20:55.000000000 +0000
@@ -152,11 +152,11 @@ acpi_get_sleep_type_data (
 	/*
 	 * Evaluate the namespace object containing the values for this state
 	 */
-	status = acpi_ns_evaluate_by_name ((char *) acpi_gbl_db_sleep_states[sleep_state],
+	status = acpi_ns_evaluate_by_name ((char *) acpi_gbl_sleep_state_names[sleep_state],
 			  NULL, &obj_desc);
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, "%s while evaluating sleep_state [%s]\n",
-			acpi_format_exception (status), acpi_gbl_db_sleep_states[sleep_state]));
+			acpi_format_exception (status), acpi_gbl_sleep_state_names[sleep_state]));
 
 		return_ACPI_STATUS (status);
 	}
@@ -201,7 +201,7 @@ acpi_get_sleep_type_data (
 
 	if (ACPI_FAILURE (status)) {
 		ACPI_DEBUG_PRINT ((ACPI_DB_ERROR, "While evaluating sleep_state [%s], bad Sleep object %p type %s\n",
-			acpi_gbl_db_sleep_states[sleep_state], obj_desc, acpi_ut_get_object_type_name (obj_desc)));
+			acpi_gbl_sleep_state_names[sleep_state], obj_desc, acpi_ut_get_object_type_name (obj_desc)));
 	}
 
 	acpi_ut_remove_reference (obj_desc);
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/hardware/hwsleep.c linux-post-2.6.4rc2-20040307/drivers/acpi/hardware/hwsleep.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/hardware/hwsleep.c	2004-02-25 02:34:52.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/hardware/hwsleep.c	2004-02-27 06:59:50.000000000 +0000
@@ -48,6 +48,19 @@
 	 ACPI_MODULE_NAME    ("hwsleep")
 
 
+#define METHOD_NAME__BFS        "\\_BFS"
+#define METHOD_NAME__GTS        "\\_GTS"
+#define METHOD_NAME__PTS        "\\_PTS"
+#define METHOD_NAME__SST        "\\_SI._SST"
+#define METHOD_NAME__WAK        "\\_WAK"
+
+#define ACPI_SST_INDICATOR_OFF  0
+#define ACPI_SST_WORKING        1
+#define ACPI_SST_WAKING         2
+#define ACPI_SST_SLEEPING       3
+#define ACPI_SST_SLEEP_CONTEXT  4
+
+
 /******************************************************************************
  *
  * FUNCTION:    acpi_set_firmware_waking_vector
@@ -171,19 +184,41 @@ acpi_enter_sleep_state_prep (
 
 	/* Run the _PTS and _GTS methods */
 
-	status = acpi_evaluate_object (NULL, "\\_PTS", &arg_list, NULL);
+	status = acpi_evaluate_object (NULL, METHOD_NAME__PTS, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
 		return_ACPI_STATUS (status);
 	}
 
-	status = acpi_evaluate_object (NULL, "\\_GTS", &arg_list, NULL);
+	status = acpi_evaluate_object (NULL, METHOD_NAME__GTS, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
 		return_ACPI_STATUS (status);
 	}
 
+	/* Setup the argument to _SST */
+
+	switch (sleep_state) {
+	case ACPI_STATE_S0:
+		arg.integer.value = ACPI_SST_WORKING;
+		break;
+
+	case ACPI_STATE_S1:
+	case ACPI_STATE_S2:
+	case ACPI_STATE_S3:
+		arg.integer.value = ACPI_SST_SLEEPING;
+		break;
+
+	case ACPI_STATE_S4:
+		arg.integer.value = ACPI_SST_SLEEP_CONTEXT;
+		break;
+
+	default:
+		arg.integer.value = ACPI_SST_INDICATOR_OFF; /* Default is indicator off */
+		break;
+	}
+
 	/* Set the system indicators to show the desired sleep state. */
 
-	status = acpi_evaluate_object (NULL, "\\_SI._SST", &arg_list, NULL);
+	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
 		 ACPI_REPORT_ERROR (("Method _SST failed, %s\n", acpi_format_exception (status)));
 	}
@@ -477,19 +512,19 @@ acpi_leave_sleep_state (
 
 	/* Ignore any errors from these methods */
 
-	arg.integer.value = 0;
-	status = acpi_evaluate_object (NULL, "\\_SI._SST", &arg_list, NULL);
+	arg.integer.value = ACPI_SST_WAKING;
+	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
 		ACPI_REPORT_ERROR (("Method _SST failed, %s\n", acpi_format_exception (status)));
 	}
 
 	arg.integer.value = sleep_state;
-	status = acpi_evaluate_object (NULL, "\\_BFS", &arg_list, NULL);
+	status = acpi_evaluate_object (NULL, METHOD_NAME__BFS, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
 		ACPI_REPORT_ERROR (("Method _BFS failed, %s\n", acpi_format_exception (status)));
 	}
 
-	status = acpi_evaluate_object (NULL, "\\_WAK", &arg_list, NULL);
+	status = acpi_evaluate_object (NULL, METHOD_NAME__WAK, &arg_list, NULL);
 	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
 		ACPI_REPORT_ERROR (("Method _WAK failed, %s\n", acpi_format_exception (status)));
 	}
@@ -501,8 +536,25 @@ acpi_leave_sleep_state (
 		return_ACPI_STATUS (status);
 	}
 
+	/* Enable power button */
+
+	acpi_set_register(acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].enable_register_id,
+			1, ACPI_MTX_DO_NOT_LOCK);
+	acpi_set_register(acpi_gbl_fixed_event_info[ACPI_EVENT_POWER_BUTTON].status_register_id,
+			1, ACPI_MTX_DO_NOT_LOCK);
+
 	/* Enable BM arbitration */
 
 	status = acpi_set_register (ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_LOCK);
+	if (ACPI_FAILURE (status)) {
+		return_ACPI_STATUS (status);
+	}
+
+	arg.integer.value = ACPI_SST_WORKING;
+	status = acpi_evaluate_object (NULL, METHOD_NAME__SST, &arg_list, NULL);
+	if (ACPI_FAILURE (status) && status != AE_NOT_FOUND) {
+		ACPI_REPORT_ERROR (("Method _SST failed, %s\n", acpi_format_exception (status)));
+	}
+
 	return_ACPI_STATUS (status);
 }
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/namespace/nseval.c linux-post-2.6.4rc2-20040307/drivers/acpi/namespace/nseval.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/namespace/nseval.c	2004-01-17 23:12:32.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/namespace/nseval.c	2004-02-27 01:20:55.000000000 +0000
@@ -110,7 +110,7 @@ acpi_ns_evaluate_relative (
 
 	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
 	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+		goto cleanup;
 	}
 
 	prefix_node = acpi_ns_map_handle_to_node (handle);
@@ -197,7 +197,7 @@ acpi_ns_evaluate_by_name (
 
 	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
 	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+		goto cleanup;
 	}
 
 	/* Lookup the name in the namespace */
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/namespace/nsutils.c linux-post-2.6.4rc2-20040307/drivers/acpi/namespace/nsutils.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/namespace/nsutils.c	2004-01-17 23:12:32.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/namespace/nsutils.c	2004-02-27 01:20:55.000000000 +0000
@@ -918,7 +918,7 @@ acpi_ns_get_node_by_path (
 
 	status = acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE);
 	if (ACPI_FAILURE (status)) {
-		return_ACPI_STATUS (status);
+		goto cleanup;
 	}
 
 	/* Setup lookup scope (search starting point) */
@@ -936,10 +936,10 @@ acpi_ns_get_node_by_path (
 				internal_path, acpi_format_exception (status)));
 	}
 
-	/* Cleanup */
-
 	(void) acpi_ut_release_mutex (ACPI_MTX_NAMESPACE);
 
+cleanup:
+	/* Cleanup */
 	if (internal_path) {
 		ACPI_MEM_FREE (internal_path);
 	}
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/namespace/nsxfname.c linux-post-2.6.4rc2-20040307/drivers/acpi/namespace/nsxfname.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/namespace/nsxfname.c	2004-01-17 23:12:31.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/namespace/nsxfname.c	2004-02-27 01:20:55.000000000 +0000
@@ -326,6 +326,13 @@ acpi_get_object_info (
 			info.valid |= ACPI_VALID_ADR;
 		}
 
+		/* Execute the Device._sx_d methods */
+
+		status = acpi_ut_execute_sxds (node, info.highest_dstates);
+		if (ACPI_SUCCESS (status)) {
+			info.valid |= ACPI_VALID_STA;
+		}
+
 		status = AE_OK;
 	}
 
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/pci_link.c linux-post-2.6.4rc2-20040307/drivers/acpi/pci_link.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/pci_link.c	2004-02-04 05:29:19.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/pci_link.c	2004-02-26 05:11:46.000000000 +0000
@@ -768,7 +768,6 @@ __setup("acpi_irq_pci=", acpi_irq_pci);
 
 static int __init acpi_irq_nobalance_set(char *str)
 {
-printk("ACPI STATIC SET\n");
 	acpi_irq_balance = 0;
 	return(1);
 }
@@ -776,7 +775,6 @@ __setup("acpi_irq_nobalance", acpi_irq_n
 
 int __init acpi_irq_balance_set(char *str)
 {
-printk("ACPI BALANCE SET\n");
 	acpi_irq_balance = 1;
 	return(1);
 }
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/resources/rsxface.c linux-post-2.6.4rc2-20040307/drivers/acpi/resources/rsxface.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/resources/rsxface.c	2004-01-17 23:12:31.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/resources/rsxface.c	2004-02-27 01:20:55.000000000 +0000
@@ -239,6 +239,7 @@ acpi_walk_resources (
 	acpi_status                         status;
 	struct acpi_buffer                  buffer = {ACPI_ALLOCATE_BUFFER, NULL};
 	struct acpi_resource                *resource;
+	struct acpi_resource                *buffer_end;
 
 
 	ACPI_FUNCTION_TRACE ("acpi_walk_resources");
@@ -255,7 +256,13 @@ acpi_walk_resources (
 		return_ACPI_STATUS (status);
 	}
 
-	resource = (struct acpi_resource *) buffer.pointer;
+	/* Setup pointers */
+
+	resource  = (struct acpi_resource *) buffer.pointer;
+	buffer_end = (struct acpi_resource *) ((u8 *) buffer.pointer + buffer.length);
+
+	/* Walk the resource list */
+
 	for (;;) {
 		if (!resource || resource->id == ACPI_RSTYPE_END_TAG) {
 			break;
@@ -268,6 +275,7 @@ acpi_walk_resources (
 		case AE_CTRL_DEPTH:
 
 			/* Just keep going */
+
 			status = AE_OK;
 			break;
 
@@ -285,7 +293,15 @@ acpi_walk_resources (
 			goto cleanup;
 		}
 
+		/* Get the next resource descriptor */
+
 		resource = ACPI_NEXT_RESOURCE (resource);
+
+		/* Check for end-of-buffer */
+
+		if (resource >= buffer_end) {
+			goto cleanup;
+		}
 	}
 
 cleanup:
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/tables.c linux-post-2.6.4rc2-20040307/drivers/acpi/tables.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/tables.c	2004-01-13 00:52:36.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/tables.c	2004-03-01 06:20:00.000000000 +0000
@@ -58,6 +58,7 @@ static char *acpi_table_signatures[ACPI_
 	[ACPI_SSDT]		= "SSDT",
 	[ACPI_SPMI]		= "SPMI",
 	[ACPI_HPET]		= "HPET",
+	[ACPI_MCFG]		= "MCFG",
 };
 
 static char *mps_inti_flags_polarity[] = { "dfl", "high", "res", "low" };
@@ -550,6 +551,14 @@ acpi_table_get_sdt (
 	return 0;
 }
 
+/*
+ * acpi_table_init()
+ *
+ * find RSDP, find and checksum SDT/XSDT.
+ * checksum all tables, print SDT/XSDT
+ * 
+ * result: sdt_entry[] is initialized
+ */
 
 int __init
 acpi_table_init (void)
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/utilities/uteval.c linux-post-2.6.4rc2-20040307/drivers/acpi/utilities/uteval.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/utilities/uteval.c	2004-01-17 23:12:31.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/utilities/uteval.c	2004-02-27 01:20:55.000000000 +0000
@@ -562,3 +562,63 @@ acpi_ut_execute_STA (
 	acpi_ut_remove_reference (obj_desc);
 	return_ACPI_STATUS (status);
 }
+
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_execute_Sxds
+ *
+ * PARAMETERS:  device_node         - Node for the device
+ *              *Flags              - Where the status flags are returned
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Executes _STA for selected device and stores results in
+ *              *Flags.
+ *
+ *              NOTE: Internal function, no parameter validation
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ut_execute_sxds (
+	struct acpi_namespace_node      *device_node,
+	u8                              *highest)
+{
+	union acpi_operand_object       *obj_desc;
+	acpi_status                     status;
+	u32                             i;
+
+
+	ACPI_FUNCTION_TRACE ("ut_execute_Sxds");
+
+
+	for (i = 0; i < 4; i++) {
+		highest[i] = 0xFF;
+		status = acpi_ut_evaluate_object (device_node,
+				 (char *) acpi_gbl_highest_dstate_names[i],
+				 ACPI_BTYPE_INTEGER, &obj_desc);
+		if (ACPI_FAILURE (status)) {
+			if (status != AE_NOT_FOUND) {
+				ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+					"%s on Device %4.4s, %s\n",
+					(char *) acpi_gbl_highest_dstate_names[i],
+					acpi_ut_get_node_name (device_node),
+					acpi_format_exception (status)));
+
+				return_ACPI_STATUS (status);
+			}
+		}
+		else {
+			/* Extract the Dstate value */
+
+			highest[i] = (u8) obj_desc->integer.value;
+
+			/* Delete the return object */
+
+			acpi_ut_remove_reference (obj_desc);
+		}
+	}
+
+	return_ACPI_STATUS (AE_OK);
+}
diff -purN linux-post-2.6.4rc2-20040306/drivers/acpi/utilities/utglobal.c linux-post-2.6.4rc2-20040307/drivers/acpi/utilities/utglobal.c
--- linux-post-2.6.4rc2-20040306/drivers/acpi/utilities/utglobal.c	2004-01-17 23:12:31.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/drivers/acpi/utilities/utglobal.c	2004-02-27 01:20:55.000000000 +0000
@@ -171,7 +171,7 @@ u8                                  acpi
 
 const u8                            acpi_gbl_decode_to8bit [8] = {1,2,4,8,16,32,64,128};
 
-const char                          *acpi_gbl_db_sleep_states[ACPI_S_STATE_COUNT] = {
+const char                          *acpi_gbl_sleep_state_names[ACPI_S_STATE_COUNT] = {
 			  "\\_S0_",
 			  "\\_S1_",
 			  "\\_S2_",
@@ -179,6 +179,11 @@ const char                          *acp
 			  "\\_S4_",
 			  "\\_S5_"};
 
+const char                          *acpi_gbl_highest_dstate_names[4] = {
+					   "_S1D",
+					   "_S2D",
+					   "_S3D",
+					   "_S4D"};
 
 /******************************************************************************
  *
diff -purN linux-post-2.6.4rc2-20040306/fs/hfsplus/dir.c linux-post-2.6.4rc2-20040307/fs/hfsplus/dir.c
--- linux-post-2.6.4rc2-20040306/fs/hfsplus/dir.c	2004-02-26 11:19:09.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/fs/hfsplus/dir.c	2004-03-04 15:49:30.000000000 +0000
@@ -399,6 +399,7 @@ int hfsplus_symlink(struct inode *dir, s
 	res = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);
 
 	if (!res) {
+		dentry->d_fsdata = (void *)inode->i_ino;
 		d_instantiate(dentry, inode);
 		mark_inode_dirty(inode);
 	}
@@ -424,6 +425,7 @@ int hfsplus_mknod(struct inode *dir, str
 		return res;
 	}
 	init_special_inode(inode, mode, rdev);
+	dentry->d_fsdata = (void *)inode->i_ino;
 	d_instantiate(dentry, inode);
 	mark_inode_dirty(inode);
 
diff -purN linux-post-2.6.4rc2-20040306/fs/hfsplus/inode.c linux-post-2.6.4rc2-20040307/fs/hfsplus/inode.c
--- linux-post-2.6.4rc2-20040306/fs/hfsplus/inode.c	2004-02-26 11:19:09.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/fs/hfsplus/inode.c	2004-03-04 15:55:25.000000000 +0000
@@ -335,6 +335,14 @@ struct inode *hfsplus_new_inode(struct s
 	init_MUTEX(&HFSPLUS_I(inode).extents_lock);
 	atomic_set(&HFSPLUS_I(inode).opencnt, 0);
 	HFSPLUS_I(inode).flags = 0;
+	memset(HFSPLUS_I(inode).first_extents, 0, sizeof(hfsplus_extent_rec));
+	memset(HFSPLUS_I(inode).cached_extents, 0, sizeof(hfsplus_extent_rec));
+	HFSPLUS_I(inode).alloc_blocks = 0;
+	HFSPLUS_I(inode).first_blocks = 0;
+	HFSPLUS_I(inode).cached_start = 0;
+	HFSPLUS_I(inode).cached_blocks = 0;
+	HFSPLUS_I(inode).phys_size = 0;
+	HFSPLUS_I(inode).rsrc_inode = 0;
 	if (S_ISDIR(inode->i_mode)) {
 		inode->i_size = 2;
 		HFSPLUS_SB(sb).folder_count++;
@@ -346,14 +354,6 @@ struct inode *hfsplus_new_inode(struct s
 		inode->i_fop = &hfsplus_file_operations;
 		inode->i_mapping->a_ops = &hfsplus_aops;
 		HFSPLUS_I(inode).clump_blocks = HFSPLUS_SB(sb).data_clump_blocks;
-		memset(HFSPLUS_I(inode).first_extents, 0, sizeof(hfsplus_extent_rec));
-		memset(HFSPLUS_I(inode).cached_extents, 0, sizeof(hfsplus_extent_rec));
-		HFSPLUS_I(inode).alloc_blocks = 0;
-		HFSPLUS_I(inode).first_blocks = 0;
-		HFSPLUS_I(inode).cached_start = 0;
-		HFSPLUS_I(inode).cached_blocks = 0;
-		HFSPLUS_I(inode).phys_size = 0;
-		HFSPLUS_I(inode).rsrc_inode = 0;
 	} else if (S_ISLNK(inode->i_mode)) {
 		HFSPLUS_SB(sb).file_count++;
 		inode->i_op = &page_symlink_inode_operations;
diff -purN linux-post-2.6.4rc2-20040306/fs/nfsd/nfsfh.c linux-post-2.6.4rc2-20040307/fs/nfsd/nfsfh.c
--- linux-post-2.6.4rc2-20040306/fs/nfsd/nfsfh.c	2004-03-05 05:36:13.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/fs/nfsd/nfsfh.c	2004-03-06 21:46:05.000000000 +0000
@@ -396,6 +396,7 @@ fh_compose(struct svc_fh *fhp, struct sv
 				 */
 				mk_fsid_v0(datap, ex_dev,
 					exp->ex_dentry->d_inode->i_ino);
+				break;
 			case 1:
 				/* fsid_type 1 == 4 bytes filesystem id */
 				mk_fsid_v1(datap, exp->ex_fsid);
diff -purN linux-post-2.6.4rc2-20040306/fs/xfs/linux/xfs_super.c linux-post-2.6.4rc2-20040307/fs/xfs/linux/xfs_super.c
--- linux-post-2.6.4rc2-20040306/fs/xfs/linux/xfs_super.c	2004-02-27 06:48:48.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/fs/xfs/linux/xfs_super.c	2004-03-06 03:46:51.000000000 +0000
@@ -247,7 +247,7 @@ xfs_flush_inode(
 {
 	struct inode	*inode = LINVFS_GET_IP(XFS_ITOV(ip));
 
-	filemap_fdatawrite(inode->i_mapping);
+	filemap_flush(inode->i_mapping);
 }
 
 void
diff -purN linux-post-2.6.4rc2-20040306/fs/xfs/xfs_log.c linux-post-2.6.4rc2-20040307/fs/xfs/xfs_log.c
--- linux-post-2.6.4rc2-20040306/fs/xfs/xfs_log.c	2004-03-02 05:42:14.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/fs/xfs/xfs_log.c	2004-03-06 03:16:30.000000000 +0000
@@ -1227,7 +1227,7 @@ xlog_alloc_log(xfs_mount_t	*mp,
 			  kmem_zalloc(sizeof(xlog_in_core_t), KM_SLEEP);
 		iclog = *iclogp;
 		iclog->hic_data = (xlog_in_core_2_t *)
-			  kmem_alloc(iclogsize, KM_SLEEP);
+			  kmem_zalloc(iclogsize, KM_SLEEP);
 
 		iclog->ic_prev = prev_iclog;
 		prev_iclog = iclog;
diff -purN linux-post-2.6.4rc2-20040306/include/acpi/acconfig.h linux-post-2.6.4rc2-20040307/include/acpi/acconfig.h
--- linux-post-2.6.4rc2-20040306/include/acpi/acconfig.h	2004-02-13 23:08:40.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/include/acpi/acconfig.h	2004-02-27 01:20:52.000000000 +0000
@@ -64,7 +64,7 @@
 
 /* Version string */
 
-#define ACPI_CA_VERSION                 0x20040211
+#define ACPI_CA_VERSION                 0x20040220
 
 /* Maximum objects in the various object caches */
 
diff -purN linux-post-2.6.4rc2-20040306/include/acpi/acglobal.h linux-post-2.6.4rc2-20040307/include/acpi/acglobal.h
--- linux-post-2.6.4rc2-20040306/include/acpi/acglobal.h	2004-01-17 23:12:31.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/include/acpi/acglobal.h	2004-02-27 01:20:52.000000000 +0000
@@ -57,6 +57,12 @@
 #define ACPI_EXTERN extern
 #endif
 
+/*
+ * Keep local copies of these FADT-based registers.  NOTE: These globals
+ * are first in this file for alignment reasons on 64-bit systems.
+ */
+ACPI_EXTERN struct acpi_generic_address         acpi_gbl_xpm1a_enable;
+ACPI_EXTERN struct acpi_generic_address         acpi_gbl_xpm1b_enable;
 
 /*****************************************************************************
  *
@@ -97,6 +103,11 @@ ACPI_EXTERN FADT_DESCRIPTOR            *
 ACPI_EXTERN struct acpi_table_header           *acpi_gbl_DSDT;
 ACPI_EXTERN FACS_DESCRIPTOR            *acpi_gbl_FACS;
 ACPI_EXTERN struct acpi_common_facs             acpi_gbl_common_fACS;
+/*
+ * Since there may be multiple SSDTs and PSDTS, a single pointer is not
+ * sufficient; Therefore, there isn't one!
+ */
+
 
 /*
  * Handle both ACPI 1.0 and ACPI 2.0 Integer widths
@@ -107,17 +118,6 @@ ACPI_EXTERN u8                          
 ACPI_EXTERN u8                                  acpi_gbl_integer_byte_width;
 ACPI_EXTERN u8                                  acpi_gbl_integer_nybble_width;
 
-/* Keep local copies of these FADT-based registers */
-
-ACPI_EXTERN struct acpi_generic_address         acpi_gbl_xpm1a_enable;
-ACPI_EXTERN struct acpi_generic_address         acpi_gbl_xpm1b_enable;
-
-/*
- * Since there may be multiple SSDTs and PSDTS, a single pointer is not
- * sufficient; Therefore, there isn't one!
- */
-
-
 /*
  * ACPI Table info arrays
  */
@@ -165,7 +165,8 @@ ACPI_EXTERN u8                          
 extern u8                                       acpi_gbl_shutdown;
 extern u32                                      acpi_gbl_startup_flags;
 extern const u8                                 acpi_gbl_decode_to8bit[8];
-extern const char                              *acpi_gbl_db_sleep_states[ACPI_S_STATE_COUNT];
+extern const char                              *acpi_gbl_sleep_state_names[ACPI_S_STATE_COUNT];
+extern const char                              *acpi_gbl_highest_dstate_names[4];
 extern const struct acpi_opcode_info            acpi_gbl_aml_op_info[AML_NUM_OPCODES];
 extern const char                              *acpi_gbl_region_types[ACPI_NUM_PREDEFINED_REGIONS];
 
diff -purN linux-post-2.6.4rc2-20040306/include/acpi/actypes.h linux-post-2.6.4rc2-20040307/include/acpi/actypes.h
--- linux-post-2.6.4rc2-20040306/include/acpi/actypes.h	2004-01-17 23:12:32.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/include/acpi/actypes.h	2004-02-27 01:20:52.000000000 +0000
@@ -880,7 +880,8 @@ struct acpi_device_info
 {
 	ACPI_COMMON_OBJ_INFO;
 
-	u32                                 valid;              /* Indicates which fields are valid */
+	u8                                  highest_dstates[4]; /* _sx_d values 0xFF indicates not valid */
+	u32                                 valid;              /* Indicates which fields below are valid */
 	u32                                 current_status;     /* _STA value */
 	acpi_integer                        address;            /* _ADR value if any */
 	struct acpi_device_id               hardware_id;        /* _HID value if any */
diff -purN linux-post-2.6.4rc2-20040306/include/acpi/acutils.h linux-post-2.6.4rc2-20040307/include/acpi/acutils.h
--- linux-post-2.6.4rc2-20040306/include/acpi/acutils.h	2004-01-17 23:12:31.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/include/acpi/acutils.h	2004-02-27 01:20:52.000000000 +0000
@@ -508,6 +508,10 @@ acpi_ut_execute_UID (
 	struct acpi_namespace_node      *device_node,
 	struct acpi_device_id           *uid);
 
+acpi_status
+acpi_ut_execute_sxds (
+	struct acpi_namespace_node      *device_node,
+	u8                              *highest);
 
 /*
  * ut_mutex - mutual exclusion interfaces
diff -purN linux-post-2.6.4rc2-20040306/include/asm-i386/acpi.h linux-post-2.6.4rc2-20040307/include/asm-i386/acpi.h
--- linux-post-2.6.4rc2-20040306/include/asm-i386/acpi.h	2004-02-04 05:28:39.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/include/asm-i386/acpi.h	2004-02-27 06:53:16.000000000 +0000
@@ -110,6 +110,7 @@
 extern int acpi_lapic;
 extern int acpi_ioapic;
 extern int acpi_noirq;
+extern int acpi_strict;
 
 /* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
 #define FIX_ACPI_PAGES 4
diff -purN linux-post-2.6.4rc2-20040306/include/asm-i386/fixmap.h linux-post-2.6.4rc2-20040307/include/asm-i386/fixmap.h
--- linux-post-2.6.4rc2-20040306/include/asm-i386/fixmap.h	2003-06-12 23:46:11.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/include/asm-i386/fixmap.h	2004-03-01 06:20:00.000000000 +0000
@@ -71,6 +71,9 @@ enum fixed_addresses {
 	FIX_ACPI_BEGIN,
 	FIX_ACPI_END = FIX_ACPI_BEGIN + FIX_ACPI_PAGES - 1,
 #endif
+#ifdef CONFIG_PCI_MMCONFIG
+	FIX_PCIE_MCFG,
+#endif
 	__end_of_permanent_fixed_addresses,
 	/* temporary boot-time mappings, used before ioremap() is functional */
 #define NR_FIX_BTMAPS	16
diff -purN linux-post-2.6.4rc2-20040306/include/asm-ia64/acpi.h linux-post-2.6.4rc2-20040307/include/asm-ia64/acpi.h
--- linux-post-2.6.4rc2-20040306/include/asm-ia64/acpi.h	2004-01-12 07:20:13.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/include/asm-ia64/acpi.h	2004-02-27 06:49:53.000000000 +0000
@@ -88,6 +88,8 @@ ia64_acpi_release_global_lock (unsigned 
 #define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq)				\
 	((Acq) = ia64_acpi_release_global_lock((unsigned int *) GLptr))
 
+#define acpi_strict 1	/* no ACPI spec workarounds on IA64 */
+
 const char *acpi_get_sysname (void);
 int acpi_request_vector (u32 int_type);
 int acpi_register_irq (u32 gsi, u32 polarity, u32 trigger);
diff -purN linux-post-2.6.4rc2-20040306/include/asm-x86_64/acpi.h linux-post-2.6.4rc2-20040307/include/asm-x86_64/acpi.h
--- linux-post-2.6.4rc2-20040306/include/asm-x86_64/acpi.h	2004-01-09 08:31:10.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/include/asm-x86_64/acpi.h	2004-02-27 05:57:51.000000000 +0000
@@ -104,6 +104,7 @@ __acpi_release_global_lock (unsigned int
 extern int acpi_lapic;
 extern int acpi_ioapic;
 extern int acpi_noirq;
+extern int acpi_strict;
 
 /* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
 #define FIX_ACPI_PAGES 4
diff -purN linux-post-2.6.4rc2-20040306/include/linux/acpi.h linux-post-2.6.4rc2-20040307/include/linux/acpi.h
--- linux-post-2.6.4rc2-20040306/include/linux/acpi.h	2004-01-13 00:51:02.000000000 +0000
+++ linux-post-2.6.4rc2-20040307/include/linux/acpi.h	2004-03-01 08:26:35.000000000 +0000
@@ -233,8 +233,27 @@ struct acpi_table_hpet {
 } __attribute__ ((packed));
 
 /*
+ * Simple Boot Flags
+ * http://www.microsoft.com/whdc/hwdev/resources/specs/simp_bios.mspx
+ */
+struct acpi_table_sbf
+{
+	u8 sbf_signature[4];
+	u32 sbf_len;
+	u8 sbf_revision;
+	u8 sbf_csum;
+	u8 sbf_oemid[6];
+	u8 sbf_oemtable[8];
+	u8 sbf_revdata[4];
+	u8 sbf_creator[4];
+	u8 sbf_crearev[4];
+	u8 sbf_cmos;
+	u8 sbf_spare[3];
+} __attribute__ ((packed));
+
+/*
  * System Resource Affinity Table (SRAT)
- *   see http://www.microsoft.com/hwdev/design/srat.htm
+ * http://www.microsoft.com/whdc/hwdev/platform/proc/SRAT.mspx
  */
 
 struct acpi_table_srat {
@@ -317,6 +336,15 @@ struct acpi_table_ecdt {
 	char				ec_id[0];
 } __attribute__ ((packed));
 
+/* PCI MMCONFIG */
+
+struct acpi_table_mcfg {
+	struct acpi_table_header	header;
+	u8				reserved[8];
+	u32				base_address;
+	u32				base_reserved;
+} __attribute__ ((packed));
+
 /* Table Handlers */
 
 enum acpi_table_id {
@@ -338,6 +366,7 @@ enum acpi_table_id {
 	ACPI_SSDT,
 	ACPI_SPMI,
 	ACPI_HPET,
+	ACPI_MCFG,
 	ACPI_TABLE_COUNT
 };
 
@@ -369,6 +398,10 @@ void acpi_numa_arch_fixup(void);
 
 extern int acpi_mp_config;
 
+extern u32 pci_mmcfg_base_addr;
+
+extern int sbf_port ;
+
 #else	/*!CONFIG_ACPI_BOOT*/
 
 #define acpi_mp_config	0
