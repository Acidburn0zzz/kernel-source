From Andrew Morton

asynchronous writes via pdflush or kswapd can race with data=ordered
writes in both ext3 and reiserfs in such a way that a concurrent
synchronous write via fsync or O_SYNC won't wait on some pages.

Basically filesystem writepage functions need to leave a page dirty or
set it as writeback if they don't actually clean the page.  This fixes
__block_write_full_page to do that.

reiserfs is fixed by patches.suse/reiserfs-writepage-ordered-race

Index: linux.t/fs/buffer.c
===================================================================
--- linux.t.orig/fs/buffer.c	2004-03-26 10:15:26.000000000 -0500
+++ linux.t/fs/buffer.c	2004-03-26 11:01:59.000000000 -0500
@@ -1820,14 +1820,18 @@ static int __block_write_full_page(struc
 		get_bh(bh);
 		if (!buffer_mapped(bh))
 			continue;
-		if (wbc->sync_mode != WB_SYNC_NONE) {
+		/*
+		 * If it's a fully non-blocking write attempt and we cannot
+		 * lock the buffer then redirty the page.  Note that this can
+		 * potentially cause a busy-wait loop from pdflush and kswapd
+		 * activity, but those code paths have their own higher-level
+		 * throttling.
+		 */
+		if (wbc->sync_mode != WB_SYNC_NONE || !wbc->nonblocking) {
 			lock_buffer(bh);
-		} else {
-			if (test_set_buffer_locked(bh)) {
-				if (buffer_dirty(bh))
-					__set_page_dirty_nobuffers(page);
-				continue;
-			}
+		} else if (test_set_buffer_locked(bh)) {
+			__set_page_dirty_nobuffers(page);
+			continue;
 		}
 		if (test_clear_buffer_dirty(bh)) {
 			if (!buffer_uptodate(bh))
