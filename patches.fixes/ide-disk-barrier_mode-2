Only use IDE barriers if advertised by the drive

The patch changes the kernel default to only enable barriers when the
drive advertises the feature.  It also adds a global barrier=off and
barrier=on to change the default for all drives on the box.  This isn't
very fine grained, but the basic goal is to be able to turn barriers off
when incorrect detection causes boot failures.

Index: linux.t/drivers/ide/ide-disk.c
===================================================================
--- linux.t.orig/drivers/ide/ide-disk.c	2004-06-27 21:21:48.221532464 -0400
+++ linux.t/drivers/ide/ide-disk.c	2004-06-27 21:22:47.478524032 -0400
@@ -1597,6 +1597,24 @@ static ide_startstop_t idedisk_start_pow
 	return ide_stopped;
 }
 
+typedef enum
+{
+	barrier_default,
+	barrier_on,
+	barrier_off
+} barrier_mode_t;
+static barrier_mode_t chosen_barrier_mode = barrier_default;
+
+static int __init barrier_setup (char *str)
+{
+	if (!strcmp (str, "on"))
+		chosen_barrier_mode = barrier_on;
+	else if (!strcmp (str, "off"))
+		chosen_barrier_mode = barrier_off;
+	return 1;
+}
+__setup ("barrier=", barrier_setup);
+
 static void idedisk_setup (ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;
@@ -1737,10 +1755,21 @@ static void idedisk_setup (ide_drive_t *
 	 * if write back caching is enabled. LBA48 drives are newer, so
 	 * expect it to flag support properly. We can safely support
 	 * FLUSH_CACHE on lba48, if capacity doesn't exceed lba28
+	 * Let the user modify this decision using a boot parameter
+	 * barrier={on|off|default}
 	 */
-	barrier = 1;
+
+	if (chosen_barrier_mode == barrier_on) {
+		barrier = 1;
+		if (drive->addressing == 1)
+			barrier = ide_id_has_flush_cache (id);
+	}
+	else if (chosen_barrier_mode == barrier_off)
+		barrier = 0;
+	else
+		barrier = ide_id_has_flush_cache (id);
+
 	if (drive->addressing == 1) {
-		barrier = ide_id_has_flush_cache(id);
 		if (capacity > (1ULL << 28) && !ide_id_has_flush_cache_ext(id))
 			barrier = 0;
 	}
