
This should fix a race condition seen on ppc. We should really get the
inet and sock pointer while we hold the lock, not before.

--- linux-2.6.4/net/sunrpc/xprt.c.race	2004-03-31 13:40:28.341234000 +0200
+++ linux-2.6.4/net/sunrpc/xprt.c	2004-03-31 14:27:08.639669333 +0200
@@ -389,26 +389,28 @@
 static void
 xprt_close(struct rpc_xprt *xprt)
 {
-	struct socket	*sock = xprt->sock;
-	struct sock	*sk = xprt->inet;
-
-	if (!sk)
-		return;
+	struct socket	*sock;
+	struct sock	*sk;
 
 	write_lock_bh(&sk->sk_callback_lock);
-	xprt->inet = NULL;
-	xprt->sock = NULL;
-
-	sk->sk_user_data    = NULL;
-	sk->sk_data_ready   = xprt->old_data_ready;
-	sk->sk_state_change = xprt->old_state_change;
-	sk->sk_write_space  = xprt->old_write_space;
+	sock = xprt->sock;
+	sk = xprt->inet;
+	if (sk != NULL) {
+		xprt->inet = NULL;
+		xprt->sock = NULL;
+
+		sk->sk_user_data    = NULL;
+		sk->sk_data_ready   = xprt->old_data_ready;
+		sk->sk_state_change = xprt->old_state_change;
+		sk->sk_write_space  = xprt->old_write_space;
+		sk->sk_no_check	 = 0;
+	}
 	write_unlock_bh(&sk->sk_callback_lock);
 
 	xprt_disconnect(xprt);
-	sk->sk_no_check	 = 0;
 
-	sock_release(sock);
+	if (sock)
+		sock_release(sock);
 }
 
 static void
