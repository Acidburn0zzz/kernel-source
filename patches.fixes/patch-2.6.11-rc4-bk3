From: olh@suse.de
Subject: 2.6.11-rc4-bk3

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc4-bk2.log	2005-02-14 13:40:47.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc4-bk3.log	2005-02-15 13:40:37.000000000 +0100
 ChangeSet@1.2039.2.5, 2005-02-14 14:21:09-08:00, eike-kernel@sf-tec.de
   [PATCH] make ACPI_BLACKLIST_YEAR depend on ACPI_INTERPRETER
   
   this oneliner fixes the situation that I can enter a year to blacklist
   ACPI devices even if ACPI is completely disabled.
   
   Signed-off-by: Rolf Eike Beer <eike-kernel@sf-tec.de>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2039.2.4, 2005-02-14 14:20:06-08:00, hch@lst.de
   [PATCH] block new writers on frozen filesystems
   
   When the lockfs patches went in an important bit got lost, the call in
   generic_file_write to put newly incoming writers to sleep when a filesystem
   is frozen.  Nathan added back the call in the now separate XFS write patch,
   and the patch for the generic code is below:
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2039.2.3, 2005-02-14 14:19:53-08:00, minyard@acm.org
   [PATCH] IPMI: Fix LAN bridging
   
   The size of LAN bridged messages was not being returned properly from the
   function that calculated address sizes.
   
   Signed-off-by: Corey Minyard <minyard@acm.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2039.2.2, 2005-02-14 14:19:40-08:00, olh@suse.de
   [PATCH] ppc64: remove extra whitespace before preprocessor token
   
   unifdef complains about the space before #ifndef.
   
   Signed-off-by: Olaf Hering <olh@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2039.2.1, 2005-02-14 14:19:26-08:00, herbert@gondor.apana.org.au
   [PATCH] ISDN locking fix
   
   isdn_net_get_locked_lp is doing a local_bh_enable with hard IRQs disabled. 
   This is not allowed.
   
   The following patch fixes the problem by removing the unnecessary
   local_bh_enable while the hard IRQs are disabled.
   
   Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2044, 2005-02-14 18:09:02+00:00, rmk@flint.arm.linux.org.uk
   [ARM] Fix sparse warnings for Integrator builds.
   
   Add some missing __iomem annotations for Integrator machines.
   
   Signed-off-by: Russell King <rmk@arm.linux.org.uk>
 
 ChangeSet@1.2043, 2005-02-14 17:32:31+00:00, rmk@flint.arm.linux.org.uk
   [ARM] Fix SA1111 and PXA iomem sparse warnings.
   
   This adds some missing annotations found by making the raw IO
   operations check their pointer type.
   
   Signed-off-by: Russell King <rmk@arm.linux.org.uk>
 
 ChangeSet@1.2042, 2005-02-14 16:59:51+00:00, rmk@flint.arm.linux.org.uk
   [ARM] Add missing __user annotations to sys_clone()
   
   Signed-off-by: Russell King <rmk@arm.linux.org.uk>
 
 ChangeSet@1.2041, 2005-02-14 16:05:37+00:00, ben-linux@org.rmk.(none)
   [ARM PATCH] 2481/1: IXP2000 - replace sti/cli with local_irq{save,restore}
   
   Patch from Ben Dooks
   
   Fix the following:
   arch/arm/mach-ixp2000/pci.c:148: warning: `cli' is deprecated (declared at include/linux/interrupt.h:65)
   arch/arm/mach-ixp2000/pci.c:161: warning: `sti' is deprecated (declared at include/linux/interrupt.h:69)
   arch/arm/mach-ixp2000/pci.c:178: warning: `cli' is deprecated (declared at include/linux/interrupt.h:65)
   arch/arm/mach-ixp2000/pci.c:191: warning: `sti' is deprecated (declared at include/linux/interrupt.h:69)
   By replacing cli() wht local_irq_save() and sti() with local_irq_restore().
   This patch has not been tested.
   
   Signed-off-by: Ben Dooks
   Signed-off-by: Russell King
 
 ChangeSet@1.2040, 2005-02-14 15:58:47+00:00, ben-linux@org.rmk.(none)
   [ARM PATCH] 2480/1: IXP4XX - cleanup resource for i2c controller
   
   Patch from Ben Dooks
   
   Fix the following:
   arch/arm/mach-ixp4xx/common.c:305: warning: initialization from incompatible pointer type
   
   Signed-off-by: Ben Dooks
   Signed-off-by: Russell King
 
diff -purN linux-2.6.11-rc4-bk2/Makefile linux-2.6.11-rc4-bk3/Makefile
--- linux-2.6.11-rc4-bk2/Makefile	2005-02-15 15:08:07.656912337 +0100
+++ linux-2.6.11-rc4-bk3/Makefile	2005-02-15 15:08:13.500935632 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc4-bk2
+EXTRAVERSION = -rc4-bk3
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc4-bk2/arch/arm/common/sa1111.c linux-2.6.11-rc4-bk3/arch/arm/common/sa1111.c
--- linux-2.6.11-rc4-bk2/arch/arm/common/sa1111.c	2005-02-13 04:07:40.000000000 +0100
+++ linux-2.6.11-rc4-bk3/arch/arm/common/sa1111.c	2005-02-15 15:08:13.505934852 +0100
@@ -53,7 +53,7 @@ struct sa1111 {
 	unsigned long	phys;
 	int		irq;
 	spinlock_t	lock;
-	void		*base;
+	void __iomem	*base;
 };
 
 /*
@@ -141,15 +141,16 @@ static void
 sa1111_irq_handler(unsigned int irq, struct irqdesc *desc, struct pt_regs *regs)
 {
 	unsigned int stat0, stat1, i;
+	void __iomem *base = desc->data;
 
-	stat0 = sa1111_readl(desc->data + SA1111_INTSTATCLR0);
-	stat1 = sa1111_readl(desc->data + SA1111_INTSTATCLR1);
+	stat0 = sa1111_readl(base + SA1111_INTSTATCLR0);
+	stat1 = sa1111_readl(base + SA1111_INTSTATCLR1);
 
-	sa1111_writel(stat0, desc->data + SA1111_INTSTATCLR0);
+	sa1111_writel(stat0, base + SA1111_INTSTATCLR0);
 
 	desc->chip->ack(irq);
 
-	sa1111_writel(stat1, desc->data + SA1111_INTSTATCLR1);
+	sa1111_writel(stat1, base + SA1111_INTSTATCLR1);
 
 	if (stat0 == 0 && stat1 == 0) {
 		do_bad_IRQ(irq, desc, regs);
@@ -177,7 +178,7 @@ static void sa1111_ack_irq(unsigned int 
 
 static void sa1111_mask_lowirq(unsigned int irq)
 {
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long ie0;
 
 	ie0 = sa1111_readl(mapbase + SA1111_INTEN0);
@@ -187,7 +188,7 @@ static void sa1111_mask_lowirq(unsigned 
 
 static void sa1111_unmask_lowirq(unsigned int irq)
 {
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long ie0;
 
 	ie0 = sa1111_readl(mapbase + SA1111_INTEN0);
@@ -205,7 +206,7 @@ static void sa1111_unmask_lowirq(unsigne
 static int sa1111_retrigger_lowirq(unsigned int irq)
 {
 	unsigned int mask = SA1111_IRQMASK_LO(irq);
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long ip0;
 	int i;
 
@@ -226,7 +227,7 @@ static int sa1111_retrigger_lowirq(unsig
 static int sa1111_type_lowirq(unsigned int irq, unsigned int flags)
 {
 	unsigned int mask = SA1111_IRQMASK_LO(irq);
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long ip0;
 
 	if (flags == IRQT_PROBE)
@@ -249,7 +250,7 @@ static int sa1111_type_lowirq(unsigned i
 static int sa1111_wake_lowirq(unsigned int irq, unsigned int on)
 {
 	unsigned int mask = SA1111_IRQMASK_LO(irq);
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long we0;
 
 	we0 = sa1111_readl(mapbase + SA1111_WAKEEN0);
@@ -273,7 +274,7 @@ static struct irqchip sa1111_low_chip = 
 
 static void sa1111_mask_highirq(unsigned int irq)
 {
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long ie1;
 
 	ie1 = sa1111_readl(mapbase + SA1111_INTEN1);
@@ -283,7 +284,7 @@ static void sa1111_mask_highirq(unsigned
 
 static void sa1111_unmask_highirq(unsigned int irq)
 {
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long ie1;
 
 	ie1 = sa1111_readl(mapbase + SA1111_INTEN1);
@@ -301,7 +302,7 @@ static void sa1111_unmask_highirq(unsign
 static int sa1111_retrigger_highirq(unsigned int irq)
 {
 	unsigned int mask = SA1111_IRQMASK_HI(irq);
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long ip1;
 	int i;
 
@@ -322,7 +323,7 @@ static int sa1111_retrigger_highirq(unsi
 static int sa1111_type_highirq(unsigned int irq, unsigned int flags)
 {
 	unsigned int mask = SA1111_IRQMASK_HI(irq);
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long ip1;
 
 	if (flags == IRQT_PROBE)
@@ -345,7 +346,7 @@ static int sa1111_type_highirq(unsigned 
 static int sa1111_wake_highirq(unsigned int irq, unsigned int on)
 {
 	unsigned int mask = SA1111_IRQMASK_HI(irq);
-	void *mapbase = get_irq_chipdata(irq);
+	void __iomem *mapbase = get_irq_chipdata(irq);
 	unsigned long we1;
 
 	we1 = sa1111_readl(mapbase + SA1111_WAKEEN1);
@@ -369,7 +370,7 @@ static struct irqchip sa1111_high_chip =
 
 static void sa1111_setup_irq(struct sa1111 *sachip)
 {
-	void *irqbase = sachip->base + SA1111_INTC;
+	void __iomem *irqbase = sachip->base + SA1111_INTC;
 	unsigned int irq;
 
 	/*
@@ -723,7 +724,7 @@ __sa1111_probe(struct device *me, struct
 static void __sa1111_remove(struct sa1111 *sachip)
 {
 	struct list_head *l, *n;
-	void *irqbase = sachip->base + SA1111_INTC;
+	void __iomem *irqbase = sachip->base + SA1111_INTC;
 
 	list_for_each_safe(l, n, &sachip->dev->children) {
 		struct device *d = list_to_dev(l);
@@ -805,7 +806,7 @@ static int sa1111_suspend(struct device 
 	struct sa1111_save_data *save;
 	unsigned long flags;
 	unsigned int val;
-	char *base;
+	void __iomem *base;
 
 	if (level != SUSPEND_DISABLE)
 		return 0;
@@ -866,7 +867,7 @@ static int sa1111_resume(struct device *
 	struct sa1111 *sachip = dev_get_drvdata(dev);
 	struct sa1111_save_data *save;
 	unsigned long flags, id;
-	char *base;
+	void __iomem *base;
 
 	if (level != RESUME_ENABLE)
 		return 0;
@@ -1094,7 +1095,7 @@ void sa1111_set_io_dir(struct sa1111_dev
 	struct sa1111 *sachip = sa1111_chip_driver(sadev);
 	unsigned long flags;
 	unsigned int val;
-	void *gpio = sachip->base + SA1111_GPIO;
+	void __iomem *gpio = sachip->base + SA1111_GPIO;
 
 #define MODIFY_BITS(port, mask, dir)		\
 	if (mask) {				\
@@ -1120,7 +1121,7 @@ void sa1111_set_io(struct sa1111_dev *sa
 	struct sa1111 *sachip = sa1111_chip_driver(sadev);
 	unsigned long flags;
 	unsigned int val;
-	void *gpio = sachip->base + SA1111_GPIO;
+	void __iomem *gpio = sachip->base + SA1111_GPIO;
 
 	spin_lock_irqsave(&sachip->lock, flags);
 	MODIFY_BITS(gpio + SA1111_GPIO_PADWR, bits & 15, v);
@@ -1134,7 +1135,7 @@ void sa1111_set_sleep_io(struct sa1111_d
 	struct sa1111 *sachip = sa1111_chip_driver(sadev);
 	unsigned long flags;
 	unsigned int val;
-	void *gpio = sachip->base + SA1111_GPIO;
+	void __iomem *gpio = sachip->base + SA1111_GPIO;
 
 	spin_lock_irqsave(&sachip->lock, flags);
 	MODIFY_BITS(gpio + SA1111_GPIO_PASSR, bits & 15, v);
diff -purN linux-2.6.11-rc4-bk2/arch/arm/kernel/sys_arm.c linux-2.6.11-rc4-bk3/arch/arm/kernel/sys_arm.c
--- linux-2.6.11-rc4-bk2/arch/arm/kernel/sys_arm.c	2005-02-13 04:05:41.000000000 +0100
+++ linux-2.6.11-rc4-bk3/arch/arm/kernel/sys_arm.c	2005-02-15 15:08:13.506934696 +0100
@@ -242,8 +242,8 @@ asmlinkage int sys_fork(struct pt_regs *
  * This is called indirectly via a small wrapper
  */
 asmlinkage int sys_clone(unsigned long clone_flags, unsigned long newsp,
-			 int *parent_tidptr, int tls_val, int *child_tidptr,
-			 struct pt_regs *regs)
+			 int __user *parent_tidptr, int tls_val,
+			 int __user *child_tidptr, struct pt_regs *regs)
 {
 	if (!newsp)
 		newsp = regs->ARM_sp;
diff -purN linux-2.6.11-rc4-bk2/arch/arm/mach-integrator/impd1.c linux-2.6.11-rc4-bk3/arch/arm/mach-integrator/impd1.c
--- linux-2.6.11-rc4-bk2/arch/arm/mach-integrator/impd1.c	2005-02-13 04:05:51.000000000 +0100
+++ linux-2.6.11-rc4-bk3/arch/arm/mach-integrator/impd1.c	2005-02-15 15:08:13.507934540 +0100
@@ -35,7 +35,7 @@ module_param_named(lmid, module_id, int,
 MODULE_PARM_DESC(lmid, "logic module stack position");
 
 struct impd1_module {
-	void		*base;
+	void __iomem	*base;
 	struct clk	vcos[2];
 };
 
diff -purN linux-2.6.11-rc4-bk2/arch/arm/mach-integrator/time.c linux-2.6.11-rc4-bk3/arch/arm/mach-integrator/time.c
--- linux-2.6.11-rc4-bk2/arch/arm/mach-integrator/time.c	2005-02-13 04:06:23.000000000 +0100
+++ linux-2.6.11-rc4-bk3/arch/arm/mach-integrator/time.c	2005-02-15 15:08:13.508934384 +0100
@@ -32,7 +32,7 @@
 #define RTC_CR_MIE	(1 << 0)
 
 extern int (*set_rtc)(void);
-static void *rtc_base;
+static void __iomem *rtc_base;
 
 static int integrator_set_rtc(void)
 {
@@ -118,7 +118,7 @@ static int rtc_probe(struct amba_device 
 	xtime.tv_sec = __raw_readl(rtc_base + RTC_DR);
 
 	ret = request_irq(dev->irq[0], rtc_interrupt, SA_INTERRUPT,
-			  "rtc-pl030", rtc_base);
+			  "rtc-pl030", dev);
 	if (ret)
 		goto map_out;
 
@@ -130,7 +130,7 @@ static int rtc_probe(struct amba_device 
 	return 0;
 
  irq_out:
-	free_irq(dev->irq[0], rtc_base);
+	free_irq(dev->irq[0], dev);
  map_out:
 	iounmap(rtc_base);
 	rtc_base = NULL;
@@ -146,7 +146,7 @@ static int rtc_remove(struct amba_device
 
 	writel(0, rtc_base + RTC_CR);
 
-	free_irq(dev->irq[0], rtc_base);
+	free_irq(dev->irq[0], dev);
 	unregister_rtc(&rtc_ops);
 
 	iounmap(rtc_base);
diff -purN linux-2.6.11-rc4-bk2/arch/arm/mach-ixp2000/pci.c linux-2.6.11-rc4-bk3/arch/arm/mach-ixp2000/pci.c
--- linux-2.6.11-rc4-bk2/arch/arm/mach-ixp2000/pci.c	2005-02-13 04:06:54.000000000 +0100
+++ linux-2.6.11-rc4-bk3/arch/arm/mach-ixp2000/pci.c	2005-02-15 15:08:13.509934228 +0100
@@ -142,10 +142,11 @@ int ixp2000_pci_abort_handler(unsigned l
 {
 
 	volatile u32 temp;
+	unsigned long flags;
 
 	pci_master_aborts = 1;
 
-	cli();
+	local_irq_save(flags);
 	temp = *(IXP2000_PCI_CONTROL);
 	if (temp & ((1 << 8) | (1 << 5))) {
 		ixp2000_reg_write(IXP2000_PCI_CONTROL, temp);
@@ -158,7 +159,7 @@ int ixp2000_pci_abort_handler(unsigned l
 			temp = *(IXP2000_PCI_CMDSTAT);
 		}
 	}
-	sti();
+	local_irq_restore(flags);
 
 	/*
 	 * If it was an imprecise abort, then we need to correct the
@@ -174,8 +175,9 @@ int
 clear_master_aborts(void)
 {
 	volatile u32 temp;
+	unsigned long flags;
 
-	cli();
+	local_irq_save(flags);
 	temp = *(IXP2000_PCI_CONTROL);
 	if (temp & ((1 << 8) | (1 << 5))) {	
 		ixp2000_reg_write(IXP2000_PCI_CONTROL, temp);
@@ -188,7 +190,7 @@ clear_master_aborts(void)
 			temp = *(IXP2000_PCI_CMDSTAT);
 		}
 	}
-	sti();
+	local_irq_restore(flags);
 
 	return 0;
 }
diff -purN linux-2.6.11-rc4-bk2/arch/arm/mach-ixp4xx/common.c linux-2.6.11-rc4-bk3/arch/arm/mach-ixp4xx/common.c
--- linux-2.6.11-rc4-bk2/arch/arm/mach-ixp4xx/common.c	2005-02-13 04:06:38.000000000 +0100
+++ linux-2.6.11-rc4-bk3/arch/arm/mach-ixp4xx/common.c	2005-02-15 15:08:13.510934072 +0100
@@ -301,7 +301,7 @@ static struct platform_device ixp46x_i2c
 	.name		= "IOP3xx-I2C",
 	.id		= 0,
 	.num_resources	= 2,
-	.resource	= &ixp46x_i2c_resources
+	.resource	= ixp46x_i2c_resources
 };
 
 static struct platform_device *ixp46x_devices[] __initdata = {
diff -purN linux-2.6.11-rc4-bk2/drivers/acpi/Kconfig linux-2.6.11-rc4-bk3/drivers/acpi/Kconfig
--- linux-2.6.11-rc4-bk2/drivers/acpi/Kconfig	2005-02-13 04:07:50.000000000 +0100
+++ linux-2.6.11-rc4-bk3/drivers/acpi/Kconfig	2005-02-15 15:08:13.514933448 +0100
@@ -259,6 +259,7 @@ config ACPI_CUSTOM_DSDT_FILE
 
 config ACPI_BLACKLIST_YEAR
 	int "Disable ACPI for systems before Jan 1st this year"
+	depends on ACPI_INTERPRETER
 	default 0
 	help
 	  enter a 4-digit year, eg. 2001 to disable ACPI by default
diff -purN linux-2.6.11-rc4-bk2/drivers/char/ipmi/ipmi_msghandler.c linux-2.6.11-rc4-bk3/drivers/char/ipmi/ipmi_msghandler.c
--- linux-2.6.11-rc4-bk2/drivers/char/ipmi/ipmi_msghandler.c	2005-02-13 04:06:53.000000000 +0100
+++ linux-2.6.11-rc4-bk3/drivers/char/ipmi/ipmi_msghandler.c	2005-02-15 15:08:13.519932668 +0100
@@ -443,6 +443,9 @@ unsigned int ipmi_addr_length(int addr_t
 		return sizeof(struct ipmi_ipmb_addr);
 	}
 
+	if (addr_type == IPMI_LAN_ADDR_TYPE)
+		return sizeof(struct ipmi_lan_addr);
+
 	return 0;
 }
 
diff -purN linux-2.6.11-rc4-bk2/drivers/input/serio/ambakmi.c linux-2.6.11-rc4-bk3/drivers/input/serio/ambakmi.c
--- linux-2.6.11-rc4-bk2/drivers/input/serio/ambakmi.c	2005-02-13 04:06:56.000000000 +0100
+++ linux-2.6.11-rc4-bk3/drivers/input/serio/ambakmi.c	2005-02-15 15:08:13.521932356 +0100
@@ -31,7 +31,7 @@
 struct amba_kmi_port {
 	struct serio		*io;
 	struct clk		*clk;
-	unsigned char		*base;
+	void __iomem		*base;
 	unsigned int		irq;
 	unsigned int		divisor;
 	unsigned int		open;
diff -purN linux-2.6.11-rc4-bk2/drivers/input/serio/sa1111ps2.c linux-2.6.11-rc4-bk3/drivers/input/serio/sa1111ps2.c
--- linux-2.6.11-rc4-bk2/drivers/input/serio/sa1111ps2.c	2005-02-13 04:08:05.000000000 +0100
+++ linux-2.6.11-rc4-bk3/drivers/input/serio/sa1111ps2.c	2005-02-15 15:08:13.522932200 +0100
@@ -28,7 +28,7 @@
 struct ps2if {
 	struct serio		*io;
 	struct sa1111_dev	*dev;
-	unsigned long		base;
+	void __iomem		*base;
 	unsigned int		open;
 	spinlock_t		lock;
 	unsigned int		head;
@@ -272,7 +272,7 @@ static int ps2_probe(struct sa1111_dev *
 	/*
 	 * Our parent device has already mapped the region.
 	 */
-	ps2if->base = (unsigned long)dev->mapbase;
+	ps2if->base = dev->mapbase;
 
 	sa1111_enable_device(ps2if->dev);
 
diff -purN linux-2.6.11-rc4-bk2/drivers/isdn/i4l/isdn_net.h linux-2.6.11-rc4-bk3/drivers/isdn/i4l/isdn_net.h
--- linux-2.6.11-rc4-bk2/drivers/isdn/i4l/isdn_net.h	2005-02-13 04:07:36.000000000 +0100
+++ linux-2.6.11-rc4-bk3/drivers/isdn/i4l/isdn_net.h	2005-02-15 15:08:13.524931888 +0100
@@ -78,18 +78,19 @@ static __inline__ isdn_net_local * isdn_
 
 	spin_lock_irqsave(&nd->queue_lock, flags);
 	lp = nd->queue;         /* get lp on top of queue */
-	spin_lock_bh(&nd->queue->xmit_lock);
+	spin_lock(&nd->queue->xmit_lock);
 	while (isdn_net_lp_busy(nd->queue)) {
-		spin_unlock_bh(&nd->queue->xmit_lock);
+		spin_unlock(&nd->queue->xmit_lock);
 		nd->queue = nd->queue->next;
 		if (nd->queue == lp) { /* not found -- should never happen */
 			lp = NULL;
 			goto errout;
 		}
-		spin_lock_bh(&nd->queue->xmit_lock);
+		spin_lock(&nd->queue->xmit_lock);
 	}
 	lp = nd->queue;
 	nd->queue = nd->queue->next;
+	local_bh_disable();
 errout:
 	spin_unlock_irqrestore(&nd->queue_lock, flags);
 	return lp;
diff -purN linux-2.6.11-rc4-bk2/drivers/mmc/pxamci.c linux-2.6.11-rc4-bk3/drivers/mmc/pxamci.c
--- linux-2.6.11-rc4-bk2/drivers/mmc/pxamci.c	2005-02-13 04:07:00.000000000 +0100
+++ linux-2.6.11-rc4-bk3/drivers/mmc/pxamci.c	2005-02-15 15:08:13.526931576 +0100
@@ -52,7 +52,7 @@ struct pxamci_host {
 	struct mmc_host		*mmc;
 	spinlock_t		lock;
 	struct resource		*res;
-	void			*base;
+	void __iomem		*base;
 	int			irq;
 	int			dma;
 	unsigned int		clkrt;
diff -purN linux-2.6.11-rc4-bk2/drivers/pcmcia/soc_common.c linux-2.6.11-rc4-bk3/drivers/pcmcia/soc_common.c
--- linux-2.6.11-rc4-bk2/drivers/pcmcia/soc_common.c	2005-02-13 04:05:41.000000000 +0100
+++ linux-2.6.11-rc4-bk3/drivers/pcmcia/soc_common.c	2005-02-15 15:08:13.544928769 +0100
@@ -397,8 +397,8 @@ soc_common_pcmcia_set_io_map(struct pcmc
 		map->stop = PAGE_SIZE-1;
 
 	map->stop -= map->start;
-	map->stop += (unsigned long)skt->virt_io;
-	map->start = (unsigned long)skt->virt_io;
+	map->stop += skt->socket.io_offset;
+	map->start = skt->socket.io_offset;
 
 	return 0;
 }
diff -purN linux-2.6.11-rc4-bk2/drivers/pcmcia/soc_common.h linux-2.6.11-rc4-bk3/drivers/pcmcia/soc_common.h
--- linux-2.6.11-rc4-bk2/drivers/pcmcia/soc_common.h	2005-02-13 04:07:01.000000000 +0100
+++ linux-2.6.11-rc4-bk3/drivers/pcmcia/soc_common.h	2005-02-15 15:08:13.545928613 +0100
@@ -53,7 +53,7 @@ struct soc_pcmcia_socket {
 	struct resource		res_io;
 	struct resource		res_mem;
 	struct resource		res_attr;
-	void			*virt_io;
+	void __iomem		*virt_io;
 
 	unsigned int		irq_state;
 
diff -purN linux-2.6.11-rc4-bk2/fs/xfs/linux-2.6/xfs_aops.c linux-2.6.11-rc4-bk3/fs/xfs/linux-2.6/xfs_aops.c
--- linux-2.6.11-rc4-bk2/fs/xfs/linux-2.6/xfs_aops.c	2005-02-13 04:08:05.000000000 +0100
+++ linux-2.6.11-rc4-bk3/fs/xfs/linux-2.6/xfs_aops.c	2005-02-15 15:08:13.561926118 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2005 Silicon Graphics, Inc.  All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -156,9 +156,7 @@ linvfs_unwritten_convert_direct(
 {
 	ASSERT(!private || inode == (struct inode *)private);
 
-	/* private indicates an unwritten extent lay beneath this IO,
-	 * see linvfs_get_block_core.
-	 */
+	/* private indicates an unwritten extent lay beneath this IO */
 	if (private && size > 0) {
 		vnode_t	*vp = LINVFS_GET_VP(inode);
 		int	error;
@@ -728,11 +726,9 @@ xfs_page_state_convert(
 	pgoff_t                 end_index, last_index, tlast;
 	int			len, err, i, cnt = 0, uptodate = 1;
 	int			flags = startio ? 0 : BMAPI_TRYLOCK;
-	int			page_dirty = 1;
-	int                     delalloc = 0;
-
+	int			page_dirty, delalloc = 0;
 
-	/* Are we off the end of the file ? */
+	/* Is this page beyond the end of the file? */
 	offset = i_size_read(inode);
 	end_index = offset >> PAGE_CACHE_SHIFT;
 	last_index = (offset - 1) >> PAGE_CACHE_SHIFT;
@@ -751,7 +747,13 @@ xfs_page_state_convert(
 	bh = head = page_buffers(page);
 	iomp = NULL;
 
+	/*
+	 * page_dirty is initially a count of buffers on the page and
+	 * is decrememted as we move each into a cleanable state.
+	 */
 	len = bh->b_size;
+	page_dirty = PAGE_CACHE_SIZE / len;
+
 	do {
 		if (offset >= end_offset)
 			break;
@@ -794,7 +796,7 @@ xfs_page_state_convert(
 				}
 				BUG_ON(!buffer_locked(bh));
 				bh_arr[cnt++] = bh;
-				page_dirty = 0;
+				page_dirty--;
 			}
 		/*
 		 * Second case, allocate space for a delalloc buffer.
@@ -821,7 +823,7 @@ xfs_page_state_convert(
 					unlock_buffer(bh);
 					mark_buffer_dirty(bh);
 				}
-				page_dirty = 0;
+				page_dirty--;
 			}
 		} else if ((buffer_uptodate(bh) || PageUptodate(page)) &&
 			   (unmapped || startio)) {
@@ -857,13 +859,13 @@ xfs_page_state_convert(
 						unlock_buffer(bh);
 						mark_buffer_dirty(bh);
 					}
-					page_dirty = 0;
+					page_dirty--;
 				}
 			} else if (startio) {
 				if (buffer_uptodate(bh) &&
 				    !test_and_set_bit(BH_Lock, &bh->b_state)) {
 					bh_arr[cnt++] = bh;
-					page_dirty = 0;
+					page_dirty--;
 				}
 			}
 		}
@@ -907,7 +909,7 @@ error:
 }
 
 STATIC int
-linvfs_get_block_core(
+__linvfs_get_block(
 	struct inode		*inode,
 	sector_t		iblock,
 	unsigned long		blocks,
@@ -977,10 +979,10 @@ linvfs_get_block_core(
 	if (iomap.iomap_flags & IOMAP_DELAY) {
 		BUG_ON(direct);
 		if (create) {
-			set_buffer_mapped(bh_result);
 			set_buffer_uptodate(bh_result);
+			set_buffer_mapped(bh_result);
+			set_buffer_delay(bh_result);
 		}
-		set_buffer_delay(bh_result);
 	}
 
 	if (blocks) {
@@ -999,7 +1001,7 @@ linvfs_get_block(
 	struct buffer_head	*bh_result,
 	int			create)
 {
-	return linvfs_get_block_core(inode, iblock, 0, bh_result,
+	return __linvfs_get_block(inode, iblock, 0, bh_result,
 					create, 0, BMAPI_WRITE);
 }
 
@@ -1011,7 +1013,7 @@ linvfs_get_blocks_direct(
 	struct buffer_head	*bh_result,
 	int			create)
 {
-	return linvfs_get_block_core(inode, iblock, max_blocks, bh_result,
+	return __linvfs_get_block(inode, iblock, max_blocks, bh_result,
 					create, 1, BMAPI_WRITE|BMAPI_DIRECT);
 }
 
diff -purN linux-2.6.11-rc4-bk2/fs/xfs/linux-2.6/xfs_lrw.c linux-2.6.11-rc4-bk3/fs/xfs/linux-2.6/xfs_lrw.c
--- linux-2.6.11-rc4-bk2/fs/xfs/linux-2.6/xfs_lrw.c	2005-02-13 04:04:47.000000000 +0100
+++ linux-2.6.11-rc4-bk3/fs/xfs/linux-2.6/xfs_lrw.c	2005-02-15 15:08:13.564925650 +0100
@@ -676,6 +676,8 @@ xfs_write(
 	if (XFS_FORCED_SHUTDOWN(mp))
 		return -EIO;
 
+	fs_check_frozen(vp->v_vfsp, SB_FREEZE_WRITE);
+
 	if (ioflags & IO_ISDIRECT) {
 		xfs_buftarg_t	*target =
 			(xip->i_d.di_flags & XFS_DIFLAG_REALTIME) ?
@@ -960,9 +962,9 @@ retry:
 				xfs_trans_set_sync(tp);
 				error = xfs_trans_commit(tp, 0, NULL);
 				xfs_iunlock(xip, XFS_ILOCK_EXCL);
-				if (error)
-					goto out_unlock_internal;
 			}
+			if (error)
+				goto out_unlock_internal;
 		}
 	
 		xfs_rwunlock(bdp, locktype);
diff -purN linux-2.6.11-rc4-bk2/fs/xfs/linux-2.6/xfs_super.c linux-2.6.11-rc4-bk3/fs/xfs/linux-2.6/xfs_super.c
--- linux-2.6.11-rc4-bk2/fs/xfs/linux-2.6/xfs_super.c	2005-02-13 04:07:40.000000000 +0100
+++ linux-2.6.11-rc4-bk3/fs/xfs/linux-2.6/xfs_super.c	2005-02-15 15:08:13.565925494 +0100
@@ -348,6 +348,12 @@ linvfs_write_inode(
 		if (sync)
 			flags |= FLUSH_SYNC;
 		VOP_IFLUSH(vp, flags, error);
+		if (error == EAGAIN) {
+			if (sync)
+				VOP_IFLUSH(vp, flags | FLUSH_LOG, error);
+			else
+				error = 0;
+		}
 	}
 
 	return -error;
diff -purN linux-2.6.11-rc4-bk2/fs/xfs/xfs_vnodeops.c linux-2.6.11-rc4-bk3/fs/xfs/xfs_vnodeops.c
--- linux-2.6.11-rc4-bk2/fs/xfs/xfs_vnodeops.c	2005-02-13 04:07:50.000000000 +0100
+++ linux-2.6.11-rc4-bk3/fs/xfs/xfs_vnodeops.c	2005-02-15 15:08:13.573924246 +0100
@@ -3681,27 +3681,27 @@ xfs_inode_flush(
 {
 	xfs_inode_t	*ip;
 	xfs_mount_t	*mp;
+	xfs_inode_log_item_t *iip;
 	int		error = 0;
 
 	ip = XFS_BHVTOI(bdp);
 	mp = ip->i_mount;
+	iip = ip->i_itemp;
 
 	if (XFS_FORCED_SHUTDOWN(mp))
 		return XFS_ERROR(EIO);
 
-	/* Bypass inodes which have already been cleaned by
+	/*
+	 * Bypass inodes which have already been cleaned by
 	 * the inode flush clustering code inside xfs_iflush
 	 */
 	if ((ip->i_update_core == 0) &&
-	    ((ip->i_itemp == NULL) ||
-	     !(ip->i_itemp->ili_format.ilf_fields & XFS_ILOG_ALL)))
+	    ((iip == NULL) || !(iip->ili_format.ilf_fields & XFS_ILOG_ALL)))
 		return 0;
 
 	if (flags & FLUSH_LOG) {
-		xfs_inode_log_item_t *iip = ip->i_itemp;
-
 		if (iip && iip->ili_last_lsn) {
-			xlog_t	*log = mp->m_log;
+			xlog_t		*log = mp->m_log;
 			xfs_lsn_t	sync_lsn;
 			int		s, log_flags = XFS_LOG_FORCE;
 
@@ -3714,12 +3714,12 @@ xfs_inode_flush(
 
 			if (flags & FLUSH_SYNC)
 				log_flags |= XFS_LOG_SYNC;
-			return xfs_log_force(mp, iip->ili_last_lsn,
-						log_flags);
+			return xfs_log_force(mp, iip->ili_last_lsn, log_flags);
 		}
 	}
 
-	/* We make this non-blocking if the inode is contended,
+	/*
+	 * We make this non-blocking if the inode is contended,
 	 * return EAGAIN to indicate to the caller that they
 	 * did not succeed. This prevents the flush path from
 	 * blocking on inodes inside another operation right
diff -purN linux-2.6.11-rc4-bk2/include/asm-arm/hardware/sa1111.h linux-2.6.11-rc4-bk3/include/asm-arm/hardware/sa1111.h
--- linux-2.6.11-rc4-bk2/include/asm-arm/hardware/sa1111.h	2005-02-13 04:07:49.000000000 +0100
+++ linux-2.6.11-rc4-bk3/include/asm-arm/hardware/sa1111.h	2005-02-15 15:08:13.575923934 +0100
@@ -49,8 +49,8 @@
  */
 #define __CCREG(x)	__REGP(SA1111_VBASE + (x))
 
-#define sa1111_writel(val,addr)	({ *(volatile unsigned int *)(addr) = (val); })
-#define sa1111_readl(addr)	(*(volatile unsigned int *)(addr))
+#define sa1111_writel(val,addr)	__raw_writel(val, addr)
+#define sa1111_readl(addr)	__raw_readl(addr)
 
 /*
  * System Bus Interface (SBI)
@@ -551,7 +551,7 @@ struct sa1111_dev {
 	struct device	dev;
 	unsigned int	devid;
 	struct resource	res;
-	void		*mapbase;
+	void __iomem	*mapbase;
 	unsigned int	skpcr_mask;
 	unsigned int	irq[6];
 	u64		dma_mask;
diff -purN linux-2.6.11-rc4-bk2/include/asm-ppc64/io.h linux-2.6.11-rc4-bk3/include/asm-ppc64/io.h
--- linux-2.6.11-rc4-bk2/include/asm-ppc64/io.h	2005-02-13 04:07:49.000000000 +0100
+++ linux-2.6.11-rc4-bk3/include/asm-ppc64/io.h	2005-02-15 15:08:13.578923466 +0100
@@ -1,4 +1,4 @@
- #ifndef _PPC64_IO_H
+#ifndef _PPC64_IO_H
 #define _PPC64_IO_H
 
 /* 
diff -purN linux-2.6.11-rc4-bk2/mm/filemap.c linux-2.6.11-rc4-bk3/mm/filemap.c
--- linux-2.6.11-rc4-bk2/mm/filemap.c	2005-02-13 04:08:05.000000000 +0100
+++ linux-2.6.11-rc4-bk3/mm/filemap.c	2005-02-15 15:08:13.583922686 +0100
@@ -2078,6 +2078,8 @@ __generic_file_aio_write_nolock(struct k
 	count = ocount;
 	pos = *ppos;
 
+	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
+
 	/* We can write back this queue in page reclaim */
 	current->backing_dev_info = mapping->backing_dev_info;
 	written = 0;
