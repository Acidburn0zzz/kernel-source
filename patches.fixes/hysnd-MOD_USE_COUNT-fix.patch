
From: Christoph Hellwig <hch@lst.de>

the maintainer doesn't response unfortauntely, but removing these from
net_devices unconditionally is the 2.6 way to go, there's no more module
refcounting on net devices.


---

 25-akpm/drivers/isdn/hysdn/hysdn_net.c |    9 ---------
 1 files changed, 9 deletions(-)

diff -puN drivers/isdn/hysdn/hysdn_net.c~hysnd-MOD_USE_COUNT-fix drivers/isdn/hysdn/hysdn_net.c
--- 25/drivers/isdn/hysdn/hysdn_net.c~hysnd-MOD_USE_COUNT-fix	2004-04-03 03:00:08.131995304 -0800
+++ 25-akpm/drivers/isdn/hysdn/hysdn_net.c	2004-04-03 03:00:08.134994848 -0800
@@ -53,8 +53,6 @@ struct net_local {
 	struct sk_buff *skbs[MAX_SKB_BUFFERS];	/* pointers to tx-skbs */
 	int in_idx, out_idx;	/* indexes to buffer ring */
 	int sk_count;		/* number of buffers currently in ring */
-
-	int is_open;		/* flag controlling module locking */
 };				/* net_local */
 
 
@@ -82,10 +80,6 @@ net_open(struct net_device *dev)
 	hysdn_card *card = dev->priv;
 	int i;
 
-	if (!((struct net_local *) dev)->is_open)
-		MOD_INC_USE_COUNT;	/* increment only if interface is actually down */
-	((struct net_local *) dev)->is_open = 1;	/* device actually open */
-
 	netif_start_queue(dev);	/* start tx-queueing */
 
 	/* Fill in the MAC-level header (if not already set) */
@@ -130,9 +124,6 @@ net_close(struct net_device *dev)
 
 	netif_stop_queue(dev);	/* disable queueing */
 
-	if (((struct net_local *) dev)->is_open)
-		MOD_DEC_USE_COUNT;	/* adjust module counter */
-	((struct net_local *) dev)->is_open = 0;
 	flush_tx_buffers((struct net_local *) dev);
 
 	return (0);		/* success */

_
