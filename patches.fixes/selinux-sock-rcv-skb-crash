--- linux-2.6.5/security/selinux/hooks.c.crash	2004-04-30 11:01:05.000000000 +0200
+++ linux-2.6.5/security/selinux/hooks.c	2004-04-30 15:47:27.000000000 +0200
@@ -3070,7 +3070,7 @@
 	return 0;
 }
 
-static int selinux_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+static int __selinux_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	u16 family;
 	char *addrp;
@@ -3176,6 +3176,20 @@
 	return err;
 }
 
+/* To make sure sk->sk_socket doesn't disappear while we mess
+ * with this skb, we need to take sk_callback_lock.
+ * See sock_orphan()
+ */
+static int selinux_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
+{
+	int res;
+
+	write_lock_bh(&sk->sk_callback_lock);
+	res = __selinux_socket_sock_rcv_skb(sk, skb);
+	write_unlock_bh(&sk->sk_callback_lock);
+	return res;
+}
+
 static int selinux_socket_getpeersec(struct socket *sock, char __user *optval,
 				     int __user *optlen, unsigned len)
 {
