Bug 42619, make reiserfs and ext3 honor barrier=off kernel boot
parameter.  This prevents an oops for devices that don't handle the
barrier failures well, like multipathing.

The barrier=off kernel boot parameter only controls the reiserfs
and ext3 default mount options.  mounting -o barrier=flush for
reiserfs or -o barrier=1 for ext3 will still turn barriers on
at the filesystem level.  This would only be useful for scsi
drives that ignore the barrier=off global.

Index: linux.t/drivers/ide/ide-disk.c
===================================================================
--- linux.t.orig/drivers/ide/ide-disk.c	2004-06-30 15:09:04.000000000 -0400
+++ linux.t/drivers/ide/ide-disk.c	2004-06-30 15:26:40.530645576 -0400
@@ -1615,6 +1615,12 @@ static int __init barrier_setup (char *s
 }
 __setup ("barrier=", barrier_setup);
 
+/* returns true if ide barriers are globally disabled */
+int flush_barriers_disabled() {
+	return chosen_barrier_mode == barrier_off;
+}
+EXPORT_SYMBOL(flush_barriers_disabled);
+
 static void idedisk_setup (ide_drive_t *drive)
 {
 	struct hd_driveid *id = drive->id;
Index: linux.t/fs/ext3/super.c
===================================================================
--- linux.t.orig/fs/ext3/super.c	2004-06-30 15:08:56.000000000 -0400
+++ linux.t/fs/ext3/super.c	2004-06-30 15:09:41.000000000 -0400
@@ -1131,7 +1131,8 @@ static int ext3_fill_super (struct super
 	sbi->s_resgid = le16_to_cpu(es->s_def_resgid);
 
 	/* enable barriers by default */
-	set_opt(sbi->s_mount_opt, BARRIER);
+	if (!flush_barriers_disabled())
+		set_opt(sbi->s_mount_opt, BARRIER);
 
 	if (!parse_options ((char *) data, sbi, &journal_inum, 0))
 		goto failed_mount;
Index: linux.t/fs/reiserfs/super.c
===================================================================
--- linux.t.orig/fs/reiserfs/super.c	2004-06-30 15:08:56.000000000 -0400
+++ linux.t/fs/reiserfs/super.c	2004-06-30 15:09:41.000000000 -0400
@@ -1487,7 +1487,7 @@ static int reiserfs_fill_super (struct s
     }
     /* make barrer=flush the default */
 
-    if (!reiserfs_barrier_none(s))
+    if (!reiserfs_barrier_none(s) && !flush_barriers_disabled())
 	REISERFS_SB(s)->s_mount_opt |= (1 << REISERFS_BARRIER_FLUSH);
     if (reiserfs_barrier_flush(s))
     	printk("reiserfs: using flush barriers\n");
Index: linux.t/include/linux/blkdev.h
===================================================================
--- linux.t.orig/include/linux/blkdev.h	2004-06-30 15:08:52.000000000 -0400
+++ linux.t/include/linux/blkdev.h	2004-06-30 15:09:41.000000000 -0400
@@ -646,6 +646,7 @@ extern long blk_congestion_wait(int rw, 
 extern void blk_rq_bio_prep(request_queue_t *, struct request *, struct bio *);
 extern void blk_rq_prep_restart(struct request *);
 extern int blkdev_issue_flush(struct block_device *, sector_t *);
+extern int flush_barriers_disabled(void);
 
 #define MAX_PHYS_SEGMENTS 128
 #define MAX_HW_SEGMENTS 128
