diff -purN linux-post-2.6.5-rc2-20040329/CREDITS linux-2.6.5-rc3/CREDITS
--- linux-post-2.6.5-rc2-20040329/CREDITS	2004-03-19 18:32:33.000000000 +0000
+++ linux-2.6.5-rc3/CREDITS	2004-03-13 08:24:38.000000000 +0000
@@ -1666,7 +1666,7 @@ S: 63225 Langen
 S: Germany
 
 N: Alain L. Knaff
-E: Alain.Knaff@poboxes.com
+E: Alain.Knaff@lll.lu
 D: floppy driver
 S: 19, rue Jean l'Aveugle
 S: L-1148 Luxembourg-City
diff -purN linux-post-2.6.5-rc2-20040329/Documentation/java.txt linux-2.6.5-rc3/Documentation/java.txt
--- linux-post-2.6.5-rc2-20040329/Documentation/java.txt	2002-02-05 07:41:11.000000000 +0000
+++ linux-2.6.5-rc3/Documentation/java.txt	2004-03-23 21:46:42.000000000 +0000
@@ -22,7 +22,7 @@ other program after you have done the fo
    the kernel (CONFIG_BINFMT_MISC) and set it up properly.
    If you choose to compile it as a module, you will have
    to insert it manually with modprobe/insmod, as kmod
-   can not easy be supported with binfmt_misc. 
+   can not easily be supported with binfmt_misc. 
    Read the file 'binfmt_misc.txt' in this directory to know
    more about the configuration process.
 
diff -purN linux-post-2.6.5-rc2-20040329/Documentation/mono.txt linux-2.6.5-rc3/Documentation/mono.txt
--- linux-post-2.6.5-rc2-20040329/Documentation/mono.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5-rc3/Documentation/mono.txt	2004-03-23 21:51:02.000000000 +0000
@@ -0,0 +1,66 @@
+               Mono(tm) Binary Kernel Support for Linux
+               -----------------------------------------
+
+To configure Linux to automatically execute Mono-based .NET binaries
+(in the form of .exe files) without the need to use the mono CLR
+wrapper, you can use the BINFMT_MISC kernel support.
+
+This will allow you to execute Mono-based .NET binaries just like any
+other program after you have done the following:
+
+1) You MUST FIRST install the Mono CLR support, either by downloading
+   a binary package, a source tarball or by installing from CVS. Binary
+   packages for several distributions can be found at:
+
+	http://go-mono.com/download.html
+
+   Instructions for compiling Mono can be found at:
+
+	http://www.go-mono.com/compiling.html
+
+   Once the Mono CLR support has been installed, just check that
+   /usr/bin/mono (which could be located elsewhere, for example
+   /usr/local/bin/mono) is working.
+
+2) You have to compile BINFMT_MISC either as a module or into
+   the kernel (CONFIG_BINFMT_MISC) and set it up properly.
+   If you choose to compile it as a module, you will have
+   to insert it manually with modprobe/insmod, as kmod
+   can not be easily supported with binfmt_misc. 
+   Read the file 'binfmt_misc.txt' in this directory to know
+   more about the configuration process.
+
+3) Add the following enries to /etc/rc.local or similar script
+   to be run at system startup:
+
+# Insert BINFMT_MISC module into the kernel
+if [ ! -e /proc/sys/fs/binfmt_misc/register ]; then
+        /sbin/modprobe binfmt_misc
+	# Some distributions, like Fedora Core, perform
+	# the following command automatically when the
+	# binfmt_misc module is loaded into the kernel.
+	# Thus, it is possible that the following line
+	# is not needed at all. Look at /etc/modprobe.conf
+	# to check whether this is applicable or not.
+        mount -t binfmt_misc none /proc/sys/fs/binfmt_misc
+fi
+
+# Register support for .NET CLR binaries
+if [ -e /proc/sys/fs/binfmt_misc/register ]; then
+	# Replace /usr/bin/mono with the correct pathname to
+	# the Mono CLR runtime (usually /usr/local/bin/mono
+	# when compiling from sources or CVS).
+        echo ':CLR:M::MZ::/usr/bin/mono:' > /proc/sys/fs/binfmt_misc/register
+else
+        echo "No binfmt_misc support"
+        exit 1
+fi
+
+4) Check that .exe binaries can be ran without the need of a
+   wrapper script, simply by launching the .exe file directly
+   from a command prompt, for example:
+
+	/usr/bin/xsd.exe
+
+   NOTE: If this fails with a permission denied error, check
+         that the .exe file has execute permissions.
diff -purN linux-post-2.6.5-rc2-20040329/MAINTAINERS linux-2.6.5-rc3/MAINTAINERS
--- linux-post-2.6.5-rc2-20040329/MAINTAINERS	2004-03-16 18:13:59.000000000 +0000
+++ linux-2.6.5-rc3/MAINTAINERS	2004-03-19 19:13:21.000000000 +0000
@@ -201,7 +201,7 @@ S:	Maintained
 AGPGART DRIVER
 P:	Dave Jones
 M:	davej@codemonkey.org.uk
-W:	http://www.codemonkey.org.uk/agp/
+W:	http://www.codemonkey.org.uk/projects/agp/
 S:	Maintained
 
 AHA152X SCSI DRIVER
diff -purN linux-post-2.6.5-rc2-20040329/Makefile linux-2.6.5-rc3/Makefile
--- linux-post-2.6.5-rc2-20040329/Makefile	2004-03-21 08:00:57.000000000 +0000
+++ linux-2.6.5-rc3/Makefile	2004-03-30 03:24:36.000000000 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 5
-EXTRAVERSION =-rc2
+EXTRAVERSION =-rc3
 NAME=Feisty Dunnart
 
 # *DOCUMENTATION*
diff -purN linux-post-2.6.5-rc2-20040329/arch/arm/Kconfig linux-2.6.5-rc3/arch/arm/Kconfig
--- linux-post-2.6.5-rc2-20040329/arch/arm/Kconfig	2004-03-25 17:56:53.000000000 +0000
+++ linux-2.6.5-rc3/arch/arm/Kconfig	2004-03-27 10:11:54.000000000 +0000
@@ -601,12 +601,8 @@ source "arch/arm/oprofile/Kconfig"
 
 source "drivers/video/Kconfig"
 
-if ARCH_ACORN || ARCH_CLPS7500 || ARCH_TBOX || ARCH_SHARK || ARCH_SA1100 || PCI
-
 source "sound/Kconfig"
 
-endif
-
 source "drivers/misc/Kconfig"
 
 source "drivers/usb/Kconfig"
diff -purN linux-post-2.6.5-rc2-20040329/arch/arm/mm/consistent.c linux-2.6.5-rc3/arch/arm/mm/consistent.c
--- linux-post-2.6.5-rc2-20040329/arch/arm/mm/consistent.c	2004-03-15 17:13:05.000000000 +0000
+++ linux-2.6.5-rc3/arch/arm/mm/consistent.c	2004-03-29 18:46:38.000000000 +0000
@@ -76,34 +76,27 @@ static struct vm_region consistent_head 
 	.vm_end		= CONSISTENT_END,
 };
 
-#if 0
-static void vm_region_dump(struct vm_region *head, char *fn)
+static struct vm_region *
+vm_region_alloc(struct vm_region *head, size_t size, int gfp)
 {
-	struct vm_region *c;
+	unsigned long addr = head->vm_start, end = head->vm_end - size;
+	unsigned long flags;
+	struct vm_region *c, *new;
 
-	printk("Consistent Allocation Map (%s):\n", fn);
-	list_for_each_entry(c, &head->vm_list, vm_list) {
-		printk(" %p:  %08lx - %08lx   (0x%08x)\n", c,
-		       c->vm_start, c->vm_end, c->vm_end - c->vm_start);
-	}
-}
-#else
-#define vm_region_dump(head,fn)	do { } while(0)
-#endif
+	new = kmalloc(sizeof(struct vm_region), gfp);
+	if (!new)
+		goto out;
 
-static int vm_region_alloc(struct vm_region *head, struct vm_region *new, size_t size)
-{
-	unsigned long addr = head->vm_start, end = head->vm_end - size;
-	struct vm_region *c;
+	spin_lock_irqsave(&consistent_lock, flags);
 
 	list_for_each_entry(c, &head->vm_list, vm_list) {
 		if ((addr + size) < addr)
-			goto out;
+			goto nospc;
 		if ((addr + size) <= c->vm_start)
 			goto found;
 		addr = c->vm_end;
 		if (addr > end)
-			goto out;
+			goto nospc;
 	}
 
  found:
@@ -114,10 +107,14 @@ static int vm_region_alloc(struct vm_reg
 	new->vm_start = addr;
 	new->vm_end = addr + size;
 
-	return 0;
+	spin_unlock_irqrestore(&consistent_lock, flags);
+	return new;
 
+ nospc:
+	spin_unlock_irqrestore(&consistent_lock, flags);
+	kfree(new);
  out:
-	return -ENOMEM;
+	return NULL;
 }
 
 static struct vm_region *vm_region_find(struct vm_region *head, unsigned long addr)
@@ -133,28 +130,46 @@ static struct vm_region *vm_region_find(
 	return c;
 }
 
-/*
- * This allocates one page of cache-coherent memory space and returns
- * both the virtual and a "dma" address to that space.
- */
-void *consistent_alloc(int gfp, size_t size, dma_addr_t *handle,
-		       unsigned long cache_flags)
+#ifdef CONFIG_HUGETLB_PAGE
+#error ARM Coherent DMA allocator does not (yet) support huge TLB
+#endif
+
+static void *
+__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle, int gfp,
+	    pgprot_t prot)
 {
 	struct page *page;
 	struct vm_region *c;
-	unsigned long order, flags;
-	void *ret = NULL;
-	int res;
+	unsigned long order;
+	u64 mask = 0x00ffffff, limit; /* ISA default */
 
 	if (!consistent_pte) {
-		printk(KERN_ERR "consistent_alloc: not initialised\n");
+		printk(KERN_ERR "%s: not initialised\n", __func__);
 		dump_stack();
 		return NULL;
 	}
 
+	if (dev) {
+		mask = dev->coherent_dma_mask;
+		if (mask == 0) {
+			dev_warn(dev, "coherent DMA mask is unset\n");
+			return NULL;
+		}
+	}
+
 	size = PAGE_ALIGN(size);
+	limit = (mask + 1) & ~mask;
+	if ((limit && size >= limit) || size >= (CONSISTENT_END - CONSISTENT_BASE)) {
+		printk(KERN_WARNING "coherent allocation too big (requested %#x mask %#Lx)\n",
+		       size, mask);
+		return NULL;
+	}
+
 	order = get_order(size);
 
+	if (mask != 0xffffffff)
+		gfp |= GFP_DMA;
+
 	page = alloc_pages(gfp, order);
 	if (!page)
 		goto no_page;
@@ -165,36 +180,18 @@ void *consistent_alloc(int gfp, size_t s
 	 */
 	{
 		unsigned long kaddr = (unsigned long)page_address(page);
-		dmac_inv_range(kaddr, kaddr + size);
+		memset(page_address(page), 0, size);
+		dmac_flush_range(kaddr, kaddr + size);
 	}
 
 	/*
-	 * Our housekeeping doesn't need to come from DMA,
-	 * but it must not come from highmem.
-	 */
-	c = kmalloc(sizeof(struct vm_region),
-		    gfp & ~(__GFP_DMA | __GFP_HIGHMEM));
-	if (!c)
-		goto no_remap;
-
-	/*
-	 * Attempt to allocate a virtual address in the
-	 * consistent mapping region.
+	 * Allocate a virtual address in the consistent mapping region.
 	 */
-	spin_lock_irqsave(&consistent_lock, flags);
-	vm_region_dump(&consistent_head, "before alloc");
-
-	res = vm_region_alloc(&consistent_head, c, size);
-
-	vm_region_dump(&consistent_head, "after alloc");
-	spin_unlock_irqrestore(&consistent_lock, flags);
-
-	if (!res) {
+	c = vm_region_alloc(&consistent_head, size,
+			    gfp & ~(__GFP_DMA | __GFP_HIGHMEM));
+	if (c) {
 		pte_t *pte = consistent_pte + CONSISTENT_OFFSET(c->vm_start);
 		struct page *end = page + (1 << order);
-		pgprot_t prot = __pgprot(L_PTE_PRESENT | L_PTE_YOUNG |
-					 L_PTE_DIRTY | L_PTE_WRITE |
-					 cache_flags);
 
 		/*
 		 * Set the "dma handle"
@@ -220,38 +217,43 @@ void *consistent_alloc(int gfp, size_t s
 			page++;
 		}
 
-		ret = (void *)c->vm_start;
+		return (void *)c->vm_start;
 	}
 
- no_remap:
-	if (ret == NULL) {
-		kfree(c);
+	if (page)
 		__free_pages(page, order);
-	}
  no_page:
-	return ret;
+	return NULL;
 }
-EXPORT_SYMBOL(consistent_alloc);
 
 /*
- * Since we have the DMA mask available to us here, we could try to do
- * a normal allocation, and only fall back to a "DMA" allocation if the
- * resulting bus address does not satisfy the dma_mask requirements.
+ * Allocate DMA-coherent memory space and return both the kernel remapped
+ * virtual and bus address for that space.
  */
 void *
 dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, int gfp)
 {
-	if (dev == NULL || *dev->dma_mask != 0xffffffff)
-		gfp |= GFP_DMA;
-
-	return consistent_alloc(gfp, size, handle, 0);
+	return __dma_alloc(dev, size, handle, gfp,
+			   pgprot_noncached(pgprot_kernel));
 }
 EXPORT_SYMBOL(dma_alloc_coherent);
 
 /*
+ * Allocate a writecombining region, in much the same way as
+ * dma_alloc_coherent above.
+ */
+void *
+dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *handle, int gfp)
+{
+	return __dma_alloc(dev, size, handle, gfp,
+			   pgprot_writecombine(pgprot_kernel));
+}
+EXPORT_SYMBOL(dma_alloc_writecombine);
+
+/*
  * free a page as defined by the above mapping.
  */
-void consistent_free(void *vaddr, size_t size, dma_addr_t handle)
+void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t handle)
 {
 	struct vm_region *c;
 	unsigned long flags;
@@ -260,15 +262,14 @@ void consistent_free(void *vaddr, size_t
 	size = PAGE_ALIGN(size);
 
 	spin_lock_irqsave(&consistent_lock, flags);
-	vm_region_dump(&consistent_head, "before free");
 
-	c = vm_region_find(&consistent_head, (unsigned long)vaddr);
+	c = vm_region_find(&consistent_head, (unsigned long)cpu_addr);
 	if (!c)
 		goto no_area;
 
 	if ((c->vm_end - c->vm_start) != size) {
-		printk(KERN_ERR "consistent_free: wrong size (%ld != %d)\n",
-		       c->vm_end - c->vm_start, size);
+		printk(KERN_ERR "%s: freeing wrong coherent size (%ld != %d)\n",
+		       __func__, c->vm_end - c->vm_start, size);
 		dump_stack();
 		size = c->vm_end - c->vm_start;
 	}
@@ -292,15 +293,14 @@ void consistent_free(void *vaddr, size_t
 			}
 		}
 
-		printk(KERN_CRIT "consistent_free: bad page in kernel page "
-		       "table\n");
+		printk(KERN_CRIT "%s: bad page in kernel page table\n",
+		       __func__);
 	} while (size -= PAGE_SIZE);
 
 	flush_tlb_kernel_range(c->vm_start, c->vm_end);
 
 	list_del(&c->vm_list);
 
-	vm_region_dump(&consistent_head, "after free");
 	spin_unlock_irqrestore(&consistent_lock, flags);
 
 	kfree(c);
@@ -308,11 +308,11 @@ void consistent_free(void *vaddr, size_t
 
  no_area:
 	spin_unlock_irqrestore(&consistent_lock, flags);
-	printk(KERN_ERR "consistent_free: trying to free "
-	       "invalid area: %p\n", vaddr);
+	printk(KERN_ERR "%s: trying to free invalid coherent area: %p\n",
+	       __func__, cpu_addr);
 	dump_stack();
 }
-EXPORT_SYMBOL(consistent_free);
+EXPORT_SYMBOL(dma_free_coherent);
 
 /*
  * Initialise the consistent memory allocation.
@@ -330,7 +330,7 @@ static int __init consistent_init(void)
 		pgd = pgd_offset(&init_mm, CONSISTENT_BASE);
 		pmd = pmd_alloc(&init_mm, pgd, CONSISTENT_BASE);
 		if (!pmd) {
-			printk(KERN_ERR "consistent_init: no pmd tables\n");
+			printk(KERN_ERR "%s: no pmd tables\n", __func__);
 			ret = -ENOMEM;
 			break;
 		}
@@ -338,7 +338,7 @@ static int __init consistent_init(void)
 
 		pte = pte_alloc_kernel(&init_mm, pmd, CONSISTENT_BASE);
 		if (!pte) {
-			printk(KERN_ERR "consistent_init: no pte tables\n");
+			printk(KERN_ERR "%s: no pte tables\n", __func__);
 			ret = -ENOMEM;
 			break;
 		}
diff -purN linux-post-2.6.5-rc2-20040329/arch/i386/defconfig linux-2.6.5-rc3/arch/i386/defconfig
--- linux-post-2.6.5-rc2-20040329/arch/i386/defconfig	2004-03-23 18:18:46.000000000 +0000
+++ linux-2.6.5-rc3/arch/i386/defconfig	2004-03-29 13:44:18.000000000 +0000
@@ -100,6 +100,10 @@ CONFIG_X86_MCE_P4THERMAL=y
 # CONFIG_MICROCODE is not set
 # CONFIG_X86_MSR is not set
 # CONFIG_X86_CPUID is not set
+
+#
+# Firmware Drivers
+#
 # CONFIG_EDD is not set
 CONFIG_NOHIGHMEM=y
 # CONFIG_HIGHMEM4G is not set
@@ -157,10 +161,12 @@ CONFIG_ACPI_SYSTEM=y
 #
 CONFIG_PCI=y
 # CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
 # CONFIG_PCI_GODIRECT is not set
 CONFIG_PCI_GOANY=y
 CONFIG_PCI_BIOS=y
 CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
 # CONFIG_PCI_USE_VECTOR is not set
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -237,8 +243,8 @@ CONFIG_BLK_DEV_FD=y
 # CONFIG_BLK_DEV_UMEM is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_CARMEL is not set
 # CONFIG_BLK_DEV_RAM is not set
-# CONFIG_BLK_DEV_INITRD is not set
 CONFIG_LBD=y
 
 #
@@ -282,6 +288,7 @@ CONFIG_BLK_DEV_ADMA=y
 # CONFIG_BLK_DEV_AEC62XX is not set
 # CONFIG_BLK_DEV_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -330,6 +337,12 @@ CONFIG_SCSI_REPORT_LUNS=y
 # CONFIG_SCSI_LOGGING is not set
 
 #
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
 # SCSI low-level drivers
 #
 # CONFIG_BLK_DEV_3W_XXXX_RAID is not set
@@ -348,7 +361,9 @@ CONFIG_SCSI_SATA=y
 # CONFIG_SCSI_SATA_SVW is not set
 CONFIG_SCSI_ATA_PIIX=y
 # CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SIL is not set
 # CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -439,10 +454,6 @@ CONFIG_IEEE1394_RAWIO=y
 # CONFIG_I2O is not set
 
 #
-# Macintosh device drivers
-#
-
-#
 # Networking support
 #
 CONFIG_NET=y
@@ -463,7 +474,6 @@ CONFIG_IP_MULTICAST=y
 # CONFIG_NET_IPGRE is not set
 # CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
-# CONFIG_INET_ECN is not set
 # CONFIG_SYN_COOKIES is not set
 # CONFIG_INET_AH is not set
 # CONFIG_INET_ESP is not set
@@ -533,7 +543,6 @@ CONFIG_IP_NF_ARP_MANGLE=y
 #
 # SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -654,6 +663,7 @@ CONFIG_8139_RXBUF_IDX=2
 # CONFIG_NET_FC is not set
 # CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
 
 #
 # Wan interfaces
@@ -674,6 +684,8 @@ CONFIG_8139_RXBUF_IDX=2
 # Bluetooth support
 #
 # CONFIG_BT is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -720,6 +732,7 @@ CONFIG_SERIO_I8042=y
 CONFIG_INPUT_KEYBOARD=y
 CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
 # CONFIG_KEYBOARD_XTKBD is not set
 # CONFIG_KEYBOARD_NEWTON is not set
 CONFIG_INPUT_MOUSE=y
@@ -728,6 +741,7 @@ CONFIG_MOUSE_PS2=y
 # CONFIG_MOUSE_INPORT is not set
 # CONFIG_MOUSE_LOGIBM is not set
 # CONFIG_MOUSE_PC110PAD is not set
+# CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
@@ -760,11 +774,6 @@ CONFIG_PRINTER=y
 # CONFIG_LP_CONSOLE is not set
 # CONFIG_PPDEV is not set
 # CONFIG_TIPAR is not set
-
-#
-# Mice
-#
-# CONFIG_BUSMOUSE is not set
 # CONFIG_QIC02_TAPE is not set
 
 #
@@ -818,6 +827,11 @@ CONFIG_DRM_I830=y
 # CONFIG_I2C is not set
 
 #
+# Misc devices
+#
+# CONFIG_IBM_ASM is not set
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -849,6 +863,9 @@ CONFIG_SOUND=y
 # Advanced Linux Sound Architecture
 #
 CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_RAWMIDI=y
 CONFIG_SND_SEQUENCER=y
 # CONFIG_SND_SEQ_DUMMY is not set
 CONFIG_SND_OSSEMUL=y
@@ -861,6 +878,7 @@ CONFIG_SND_SEQUENCER_OSS=y
 #
 # Generic devices
 #
+CONFIG_SND_MPU401_UART=y
 # CONFIG_SND_DUMMY is not set
 # CONFIG_SND_VIRMIDI is not set
 # CONFIG_SND_MTPAV is not set
@@ -896,13 +914,19 @@ CONFIG_SND_SEQUENCER_OSS=y
 #
 # PCI devices
 #
+CONFIG_SND_AC97_CODEC=y
 # CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
 # CONFIG_SND_AZT3328 is not set
 # CONFIG_SND_BT87X is not set
 # CONFIG_SND_CS46XX is not set
 # CONFIG_SND_CS4281 is not set
 # CONFIG_SND_EMU10K1 is not set
 # CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_MIXART is not set
 # CONFIG_SND_NM256 is not set
 # CONFIG_SND_RME32 is not set
 # CONFIG_SND_RME96 is not set
@@ -921,6 +945,7 @@ CONFIG_SND_SEQUENCER_OSS=y
 # CONFIG_SND_ICE1712 is not set
 # CONFIG_SND_ICE1724 is not set
 CONFIG_SND_INTEL8X0=y
+# CONFIG_SND_INTEL8X0M is not set
 # CONFIG_SND_SONICVIBES is not set
 # CONFIG_SND_VIA82XX is not set
 # CONFIG_SND_VX222 is not set
@@ -952,6 +977,7 @@ CONFIG_USB_DEVICEFS=y
 # USB Host Controller Drivers
 #
 CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
 # CONFIG_USB_OHCI_HCD is not set
 CONFIG_USB_UHCI_HCD=y
 
@@ -985,7 +1011,9 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_WACOM is not set
 # CONFIG_USB_KBTAB is not set
 # CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
 # CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
 
 #
 # USB Imaging devices
@@ -1031,7 +1059,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_AUERSWALD is not set
 # CONFIG_USB_RIO500 is not set
 # CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_BRLVGER is not set
 # CONFIG_USB_LCD is not set
 # CONFIG_USB_LED is not set
 # CONFIG_USB_TEST is not set
@@ -1120,11 +1147,12 @@ CONFIG_NFSD=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=y
 CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_GSS is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
diff -purN linux-post-2.6.5-rc2-20040329/arch/ppc/kernel/align.c linux-2.6.5-rc3/arch/ppc/kernel/align.c
--- linux-post-2.6.5-rc2-20040329/arch/ppc/kernel/align.c	2003-09-05 11:54:27.000000000 +0000
+++ linux-2.6.5-rc3/arch/ppc/kernel/align.c	2004-03-29 04:45:57.000000000 +0000
@@ -262,8 +262,12 @@ fix_alignment(struct pt_regs *regs)
 			return -EFAULT;	/* bad address */
 	}
 
-	if ((flags & F) && (regs->msr & MSR_FP))
-		giveup_fpu(current);
+	if (flags & F) {
+		preempt_disable();
+		if (regs->msr & MSR_FP)
+			giveup_fpu(current);
+		preempt_enable();
+	}
 	if (flags & M)
 		return 0;		/* too hard for now */
 
diff -purN linux-post-2.6.5-rc2-20040329/arch/ppc/kernel/head.S linux-2.6.5-rc3/arch/ppc/kernel/head.S
--- linux-post-2.6.5-rc2-20040329/arch/ppc/kernel/head.S	2004-03-06 11:03:00.000000000 +0000
+++ linux-2.6.5-rc3/arch/ppc/kernel/head.S	2004-03-29 04:52:30.000000000 +0000
@@ -462,7 +462,7 @@ Alignment:
 	EXC_XFER_EE(0x600, AlignmentException)
 
 /* Program check exception */
-	EXCEPTION(0x700, ProgramCheck, ProgramCheckException, EXC_XFER_EE)
+	EXCEPTION(0x700, ProgramCheck, ProgramCheckException, EXC_XFER_STD)
 
 /* Floating-point unavailable */
 	. = 0x800
@@ -485,7 +485,7 @@ SystemCall:
 	EXC_XFER_EE_LITE(0xc00, DoSyscall)
 
 /* Single step - not used on 601 */
-	EXCEPTION(0xd00, SingleStep, SingleStepException, EXC_XFER_EE)
+	EXCEPTION(0xd00, SingleStep, SingleStepException, EXC_XFER_STD)
 	EXCEPTION(0xe00, Trap_0e, UnknownException, EXC_XFER_EE)
 
 /*
diff -purN linux-post-2.6.5-rc2-20040329/arch/ppc/kernel/ptrace.c linux-2.6.5-rc3/arch/ppc/kernel/ptrace.c
--- linux-post-2.6.5-rc2-20040329/arch/ppc/kernel/ptrace.c	2003-09-12 16:26:52.000000000 +0000
+++ linux-2.6.5-rc3/arch/ppc/kernel/ptrace.c	2004-03-29 04:48:22.000000000 +0000
@@ -242,8 +242,10 @@ int sys_ptrace(long request, long pid, l
 		if (index < PT_FPR0) {
 			tmp = get_reg(child, (int) index);
 		} else {
+			preempt_disable();
 			if (child->thread.regs->msr & MSR_FP)
 				giveup_fpu(child);
+			preempt_enable();
 			tmp = ((unsigned long *)child->thread.fpr)[index - PT_FPR0];
 		}
 		ret = put_user(tmp,(unsigned long *) data);
@@ -276,8 +278,10 @@ int sys_ptrace(long request, long pid, l
 		if (index < PT_FPR0) {
 			ret = put_reg(child, index, data);
 		} else {
+			preempt_disable();
 			if (child->thread.regs->msr & MSR_FP)
 				giveup_fpu(child);
+			preempt_enable();
 			((unsigned long *)child->thread.fpr)[index - PT_FPR0] = data;
 			ret = 0;
 		}
@@ -338,8 +342,10 @@ int sys_ptrace(long request, long pid, l
 #ifdef CONFIG_ALTIVEC
 	case PTRACE_GETVRREGS:
 		/* Get the child altivec register state. */
+		preempt_disable();
 		if (child->thread.regs->msr & MSR_VEC)
 			giveup_altivec(child);
+		preempt_enable();
 		ret = get_vrregs((unsigned long *)data, child);
 		break;
 
@@ -347,8 +353,10 @@ int sys_ptrace(long request, long pid, l
 		/* Set the child altivec register state. */
 		/* this is to clear the MSR_VEC bit to force a reload
 		 * of register state from memory */
+		preempt_disable();
 		if (child->thread.regs->msr & MSR_VEC)
 			giveup_altivec(child);
+		preempt_enable();
 		ret = set_vrregs(child, (unsigned long *)data);
 		break;
 #endif
diff -purN linux-post-2.6.5-rc2-20040329/arch/ppc/kernel/signal.c linux-2.6.5-rc3/arch/ppc/kernel/signal.c
--- linux-post-2.6.5-rc2-20040329/arch/ppc/kernel/signal.c	2004-01-23 05:37:05.000000000 +0000
+++ linux-2.6.5-rc3/arch/ppc/kernel/signal.c	2004-03-29 04:51:39.000000000 +0000
@@ -191,8 +191,15 @@ save_user_regs(struct pt_regs *regs, str
 {
 	/* save general and floating-point registers */
 	CHECK_FULL_REGS(regs);
+	preempt_disable();
 	if (regs->msr & MSR_FP)
 		giveup_fpu(current);
+#ifdef CONFIG_ALTIVEC
+	if (current->thread.used_vr && (regs->msr & MSR_VEC))
+		giveup_altivec(current);
+#endif /* CONFIG_ALTIVEC */
+	preempt_enable();
+
 	if (__copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE)
 	    || __copy_to_user(&frame->mc_fregs, current->thread.fpr,
 			      ELF_NFPREG * sizeof(double)))
@@ -203,8 +210,6 @@ save_user_regs(struct pt_regs *regs, str
 #ifdef CONFIG_ALTIVEC
 	/* save altivec registers */
 	if (current->thread.used_vr) {
-		if (regs->msr & MSR_VEC)
-			giveup_altivec(current);
 		if (__copy_to_user(&frame->mc_vregs, current->thread.vr,
 				   ELF_NVRREG * sizeof(vector128)))
 			return 1;
diff -purN linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/entry.S linux-2.6.5-rc3/arch/ppc64/kernel/entry.S
--- linux-post-2.6.5-rc2-20040329/arch/ppc64/kernel/entry.S	2004-03-19 05:59:29.000000000 +0000
+++ linux-2.6.5-rc3/arch/ppc64/kernel/entry.S	2004-03-26 17:56:07.000000000 +0000
@@ -139,7 +139,7 @@ _GLOBAL(ret_from_syscall_1)
 91:
 #endif
 	li	r10,-_LAST_ERRNO
-	cmpl	0,r3,r10
+	cmpld	0,r3,r10
 	blt	30f
 	neg	r3,r3
 22:	ld	r10,_CCR(r1)	/* Set SO bit in CR */
diff -purN linux-post-2.6.5-rc2-20040329/arch/x86_64/ia32/sys_ia32.c linux-2.6.5-rc3/arch/x86_64/ia32/sys_ia32.c
--- linux-post-2.6.5-rc2-20040329/arch/x86_64/ia32/sys_ia32.c	2004-03-27 21:46:54.000000000 +0000
+++ linux-2.6.5-rc3/arch/x86_64/ia32/sys_ia32.c	2004-03-29 13:38:03.000000000 +0000
@@ -60,6 +60,7 @@
 #include <linux/vfs.h>
 #include <linux/ptrace.h>
 #include <linux/highuid.h>
+#include <linux/vmalloc.h>
 #include <asm/mman.h>
 #include <asm/types.h>
 #include <asm/uaccess.h>
diff -purN linux-post-2.6.5-rc2-20040329/drivers/acorn/char/i2c.c linux-2.6.5-rc3/drivers/acorn/char/i2c.c
--- linux-post-2.6.5-rc2-20040329/drivers/acorn/char/i2c.c	2004-02-20 19:40:36.000000000 +0000
+++ linux-2.6.5-rc3/drivers/acorn/char/i2c.c	2004-03-29 22:16:31.000000000 +0000
@@ -34,9 +34,13 @@ extern int (*set_rtc)(void);
 static struct i2c_client *rtc_client;
 static const unsigned char days_in_mon[] = 
 	{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-static unsigned int rtc_epoch = 1900;
 
 #define CMOS_CHECKSUM	(63)
+
+/*
+ * Acorn machines store the year in the static RAM at
+ * location 128.
+ */
 #define CMOS_YEAR	(64 + 128)
 
 static inline int rtc_command(int cmd, void *data)
@@ -50,51 +54,89 @@ static inline int rtc_command(int cmd, v
 }
 
 /*
+ * Update the century + year bytes in the CMOS RAM, ensuring
+ * that the check byte is correctly adjusted for the change.
+ */
+static int rtc_update_year(unsigned int new_year)
+{
+	unsigned char yr[2], chk;
+	struct mem cmos_year  = { CMOS_YEAR, sizeof(yr), yr };
+	struct mem cmos_check = { CMOS_CHECKSUM, 1, &chk };
+	int ret;
+
+	ret = rtc_command(MEM_READ, &cmos_check);
+	if (ret)
+		goto out;
+	ret = rtc_command(MEM_READ, &cmos_year);
+	if (ret)
+		goto out;
+
+	chk -= yr[1] + yr[0];
+
+	yr[1] = new_year / 100;
+	yr[0] = new_year % 100;
+
+	chk += yr[1] + yr[0];
+
+	ret = rtc_command(MEM_WRITE, &cmos_year);
+	if (ret == 0)
+		ret = rtc_command(MEM_WRITE, &cmos_check);
+ out:
+	return ret;
+}
+
+/*
  * Read the current RTC time and date, and update xtime.
  */
 static void get_rtc_time(struct rtc_tm *rtctm, unsigned int *year)
 {
 	unsigned char ctrl, yr[2];
 	struct mem rtcmem = { CMOS_YEAR, sizeof(yr), yr };
+	int real_year, year_offset;
 
 	/*
 	 * Ensure that the RTC is running.
 	 */
 	rtc_command(RTC_GETCTRL, &ctrl);
 	if (ctrl & 0xc0) {
-		unsigned char new_ctrl;
-
-		new_ctrl = ctrl & ~0xc0;
+		unsigned char new_ctrl = ctrl & ~0xc0;
 
-		printk("RTC: resetting control %02X -> %02X\n",
+		printk(KERN_WARNING "RTC: resetting control %02x -> %02x\n",
 		       ctrl, new_ctrl);
 
 		rtc_command(RTC_SETCTRL, &new_ctrl);
 	}
 
-	/*
-	 * Acorn machines store the year in
-	 * the static RAM at location 192.
-	 */
-	if (rtc_command(MEM_READ, &rtcmem))
+	if (rtc_command(RTC_GETDATETIME, rtctm) ||
+	    rtc_command(MEM_READ, &rtcmem))
 		return;
 
-	if (rtc_command(RTC_GETDATETIME, rtctm))
-		return;
+	real_year = yr[0];
 
-	*year = yr[1] * 100 + yr[0];
+	/*
+	 * The RTC year holds the LSB two bits of the current
+	 * year, which should reflect the LSB two bits of the
+	 * CMOS copy of the year.  Any difference indicates
+	 * that we have to correct the CMOS version.
+	 */
+	year_offset = rtctm->year_off - (real_year & 3);
+	if (year_offset < 0)
+		/*
+		 * RTC year wrapped.  Adjust it appropriately.
+		 */
+		year_offset += 4;
+
+	*year = real_year + year_offset + yr[1] * 100;
 }
 
 static int set_rtc_time(struct rtc_tm *rtctm, unsigned int year)
 {
-	unsigned char yr[2], leap, chk;
-	struct mem cmos_year  = { CMOS_YEAR, sizeof(yr), yr };
-	struct mem cmos_check = { CMOS_CHECKSUM, 1, &chk };
+	unsigned char leap;
 	int ret;
 
 	leap = (!(year % 4) && (year % 100)) || !(year % 400);
 
-	if (rtctm->mon > 12 || rtctm->mday == 0)
+	if (rtctm->mon > 12 || rtctm->mon == 0 || rtctm->mday == 0)
 		return -EINVAL;
 
 	if (rtctm->mday > (days_in_mon[rtctm->mon] + (rtctm->mon == 2 && leap)))
@@ -103,21 +145,16 @@ static int set_rtc_time(struct rtc_tm *r
 	if (rtctm->hours >= 24 || rtctm->mins >= 60 || rtctm->secs >= 60)
 		return -EINVAL;
 
-	ret = rtc_command(RTC_SETDATETIME, rtctm);
-	if (ret == 0) {
-		rtc_command(MEM_READ, &cmos_check);
-		rtc_command(MEM_READ, &cmos_year);
-
-		chk -= yr[1] + yr[0];
-
-		yr[1] = year / 100;
-		yr[0] = year % 100;
+	/*
+	 * The RTC's own 2-bit year must reflect the least
+	 * significant two bits of the CMOS year.
+	 */
+	rtctm->year_off = (year % 100) & 3;
 
-		chk += yr[1] + yr[0];
+	ret = rtc_command(RTC_SETDATETIME, rtctm);
+	if (ret == 0)
+		ret = rtc_update_year(year);
 
-		rtc_command(MEM_WRITE, &cmos_year);
-		rtc_command(MEM_WRITE, &cmos_check);
-	}
 	return ret;
 }
 
@@ -189,13 +226,12 @@ static int rtc_ioctl(struct inode *inode
 		rtc_raw.hours    = rtctm.tm_hour;
 		rtc_raw.mday     = rtctm.tm_mday;
 		rtc_raw.mon      = rtctm.tm_mon + 1;
-		rtc_raw.year_off = 2;
 		year             = rtctm.tm_year + 1900;
 		return set_rtc_time(&rtc_raw, year);
 		break;
 
 	case RTC_EPOCH_READ:
-		return put_user(rtc_epoch, (unsigned long *)arg);
+		return put_user(1900, (unsigned long *)arg);
 
 	}
 	return -EINVAL;
diff -purN linux-post-2.6.5-rc2-20040329/drivers/block/cciss.c linux-2.6.5-rc3/drivers/block/cciss.c
--- linux-post-2.6.5-rc2-20040329/drivers/block/cciss.c	2004-02-08 07:39:27.000000000 +0000
+++ linux-2.6.5-rc3/drivers/block/cciss.c	2004-03-29 13:44:17.000000000 +0000
@@ -469,11 +469,8 @@ static int cciss_ioctl(struct inode *ino
                         driver_geo.heads = drv->heads;
                         driver_geo.sectors = drv->sectors;
                         driver_geo.cylinders = drv->cylinders;
-                } else {
-                        driver_geo.heads = 0xff;
-                        driver_geo.sectors = 0x3f;
-                        driver_geo.cylinders = (int)drv->nr_blocks / (0xff*0x3f);
-                }
+                } else
+			return -ENXIO;
                 driver_geo.start= get_start_sect(inode->i_bdev);
                 if (copy_to_user((void *) arg, &driver_geo,
                                 sizeof( struct hd_geometry)))
diff -purN linux-post-2.6.5-rc2-20040329/drivers/block/cciss_scsi.c linux-2.6.5-rc3/drivers/block/cciss_scsi.c
--- linux-post-2.6.5-rc2-20040329/drivers/block/cciss_scsi.c	2004-03-12 09:33:02.000000000 +0000
+++ linux-2.6.5-rc3/drivers/block/cciss_scsi.c	2004-03-29 13:44:17.000000000 +0000
@@ -1058,6 +1058,7 @@ cciss_update_non_disk_devices(int cntl_n
 		int devtype;
 
 		/* for each physical lun, do an inquiry */
+		if (ld_buff->LUN[i][3] & 0xC0) continue;
 		memset(inq_buff, 0, sizeof(InquiryData_struct));
 		memcpy(&scsi3addr[0], &ld_buff->LUN[i][0], 8);
 
diff -purN linux-post-2.6.5-rc2-20040329/drivers/cdrom/viocd.c linux-2.6.5-rc3/drivers/cdrom/viocd.c
--- linux-post-2.6.5-rc2-20040329/drivers/cdrom/viocd.c	2004-03-23 10:05:25.000000000 +0000
+++ linux-2.6.5-rc3/drivers/cdrom/viocd.c	2004-03-29 13:44:19.000000000 +0000
@@ -615,7 +615,7 @@ static int __init viocd_init(void)
 				VIOCD_DEVICE_DEVFS "%d", deviceno);
 		gendisk->queue = viocd_queue;
 		gendisk->fops = &viocd_fops;
-		gendisk->flags = GENHD_FL_CD;
+		gendisk->flags = GENHD_FL_CD|GENHD_FL_REMOVABLE;
 		set_capacity(gendisk, 0);
 		gendisk->private_data = d;
 		d->viocd_disk = gendisk;
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/Kconfig linux-2.6.5-rc3/drivers/char/agp/Kconfig
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/Kconfig	2004-02-23 05:24:06.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/Kconfig	2004-03-24 17:01:28.000000000 +0000
@@ -77,7 +77,7 @@ config AGP_AMD64
 
 config AGP_INTEL
 	tristate "Intel 440LX/BX/GX, I8xx and E7x05 chipset support"
-	depends on AGP && X86
+	depends on AGP && X86 && !X86_64
 	help
 	  This option gives you AGP support for the GLX component of XFree86 4.x
 	  on Intel 440LX/BX/GX, 815, 820, 830, 840, 845, 850, 860, 875,
@@ -88,6 +88,16 @@ config AGP_INTEL
 	  use GLX or DRI, or if you have any Intel integrated graphics
 	  chipsets.  If unsure, say Y.
 
+config AGP_INTEL_MCH
+	tristate "Intel i865 chipset support"
+	depends on AGP && X86
+	help
+	  This option gives you AGP support for the GLX component of XFree86 4.x
+	  on Intel chipsets that support Intel EM64T processors.
+
+	  You should say Y here if you use XFree86 3.3.6 or 4.x and want to
+	  use GLX or DRI.  If unsure, say Y.
+
 config AGP_NVIDIA
 	tristate "NVIDIA nForce/nForce2 chipset support"
 	depends on AGP && X86 && !X86_64
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/Makefile linux-2.6.5-rc3/drivers/char/agp/Makefile
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/Makefile	2004-02-19 00:02:05.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/Makefile	2004-03-24 17:01:28.000000000 +0000
@@ -9,6 +9,7 @@ obj-$(CONFIG_AGP_ALPHA_CORE)	+= alpha-ag
 obj-$(CONFIG_AGP_EFFICEON)	+= efficeon-agp.o
 obj-$(CONFIG_AGP_HP_ZX1)	+= hp-agp.o
 obj-$(CONFIG_AGP_I460)		+= i460-agp.o
+obj-$(CONFIG_AGP_INTEL_MCH)		+= intel-mch-agp.o
 obj-$(CONFIG_AGP_INTEL)		+= intel-agp.o
 obj-$(CONFIG_AGP_NVIDIA)	+= nvidia-agp.o
 obj-$(CONFIG_AGP_SIS)		+= sis-agp.o
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/agp.h linux-2.6.5-rc3/drivers/char/agp/agp.h
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/agp.h	2003-09-05 19:47:05.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/agp.h	2004-03-19 20:23:25.000000000 +0000
@@ -1,6 +1,6 @@
 /*
  * AGPGART
- * Copyright (C) 2002-2003 Dave Jones
+ * Copyright (C) 2002-2004 Dave Jones
  * Copyright (C) 1999 Jeff Hartmann
  * Copyright (C) 1999 Precision Insight, Inc.
  * Copyright (C) 1999 Xi Graphics, Inc.
@@ -167,8 +167,6 @@ struct agp_bridge_data {
 
 #define PGE_EMPTY(b, p)	(!(p) || (p) == (unsigned long) (b)->scratch_page)
 
-/* Chipset independant registers (from AGP Spec) */
-#define AGP_APBASE	0x10
 
 /* Intel registers */
 #define INTEL_APSIZE	0xb4
@@ -177,14 +175,6 @@ struct agp_bridge_data {
 #define INTEL_NBXCFG	0x50
 #define INTEL_ERRSTS	0x91
 
-/* Intel 460GX Registers */
-#define INTEL_I460_BAPBASE		0x98
-#define INTEL_I460_GXBCTL		0xa0
-#define INTEL_I460_AGPSIZ		0xa2
-#define INTEL_I460_ATTBASE		0xfe200000
-#define INTEL_I460_GATT_VALID		(1UL << 24)
-#define INTEL_I460_GATT_COHERENT	(1UL << 25)
-
 /* Intel i830 registers */
 #define I830_GMCH_CTRL			0x52
 #define I830_GMCH_ENABLED		0x4
@@ -219,26 +209,10 @@ struct agp_bridge_data {
 #define I852_GME			0x2
 #define I852_GM				0x5
 
-/* Intel 815 register */
-#define INTEL_815_APCONT	0x51
-#define INTEL_815_ATTBASE_MASK	~0x1FFFFFFF
-
-/* Intel i820 registers */
-#define INTEL_I820_RDCR		0x51
-#define INTEL_I820_ERRSTS	0xc8
-
-/* Intel i840 registers */
-#define INTEL_I840_MCHCFG	0x50
-#define INTEL_I840_ERRSTS	0xc8
- 
 /* Intel i845 registers */
 #define INTEL_I845_AGPM		0x51
 #define INTEL_I845_ERRSTS	0xc8
 
-/* Intel i850 registers */
-#define INTEL_I850_MCHCFG	0x50
-#define INTEL_I850_ERRSTS	0xc8
-
 /* Intel i860 registers */
 #define INTEL_I860_MCHCFG	0x50
 #define INTEL_I860_ERRSTS	0xc8
@@ -261,110 +235,6 @@ struct agp_bridge_data {
 #define I810_DRAM_ROW_0		0x00000001
 #define I810_DRAM_ROW_0_SDRAM	0x00000001
 
-/* Intel 7505 registers */
-#define INTEL_I7505_APSIZE	0x74
-#define INTEL_I7505_NCAPID	0x60
-#define INTEL_I7505_NISTAT	0x6c
-#define INTEL_I7505_ATTBASE	0x78
-#define INTEL_I7505_ERRSTS	0x42
-#define INTEL_I7505_AGPCTRL	0x70
-#define INTEL_I7505_MCHCFG	0x50
-
-/* VIA register */
-#define VIA_GARTCTRL	0x80
-#define VIA_APSIZE	0x84
-#define VIA_ATTBASE	0x88
-
-/* VIA KT400 */
-#define VIA_AGP3_GARTCTRL	0x90
-#define VIA_AGP3_APSIZE		0x94
-#define VIA_AGP3_ATTBASE	0x98
-#define VIA_AGPSEL		0xfd
-
-/* SiS registers */
-#define SIS_ATTBASE	0x90
-#define SIS_APSIZE	0x94
-#define SIS_TLBCNTRL	0x97
-#define SIS_TLBFLUSH	0x98
-
-/* AMD registers */
-#define AMD_MMBASE	0x14
-#define AMD_APSIZE	0xac
-#define AMD_MODECNTL	0xb0
-#define AMD_MODECNTL2	0xb2
-#define AMD_GARTENABLE	0x02	/* In mmio region (16-bit register) */
-#define AMD_ATTBASE	0x04	/* In mmio region (32-bit register) */
-#define AMD_TLBFLUSH	0x0c	/* In mmio region (32-bit register) */
-#define AMD_CACHEENTRY	0x10	/* In mmio region (32-bit register) */
-
-/* AMD64 registers */
-#define AMD64_GARTAPERTURECTL	0x90
-#define AMD64_GARTAPERTUREBASE	0x94
-#define AMD64_GARTTABLEBASE	0x98
-#define AMD64_GARTCACHECTL		0x9c
-#define AMD64_GARTEN		(1<<0)
-
-/* ALi registers */
-#define ALI_AGPCTRL			0xb8
-#define ALI_ATTBASE			0xbc
-#define ALI_TLBCTRL			0xc0
-#define ALI_TAGCTRL			0xc4
-#define ALI_CACHE_FLUSH_CTRL		0xD0
-#define ALI_CACHE_FLUSH_ADDR_MASK	0xFFFFF000
-#define ALI_CACHE_FLUSH_EN		0x100
-
-/* ATI register */
-#define ATI_GART_MMBASE_ADDR	0x14
-#define ATI_RS100_APSIZE	0xac
-#define ATI_RS300_APSIZE	0xf8
-#define ATI_RS100_IG_AGPMODE	0xb0
-#define ATI_RS300_IG_AGPMODE	0xfc
-
-#define ATI_GART_FEATURE_ID		0x00
-#define ATI_GART_BASE			0x04
-#define ATI_GART_CACHE_SZBASE		0x08
-#define ATI_GART_CACHE_CNTRL		0x0c
-#define ATI_GART_CACHE_ENTRY_CNTRL	0x10
-
-/* Serverworks Registers */
-#define SVWRKS_APSIZE		0x10
-#define SVWRKS_SIZE_MASK	0xfe000000
-
-#define SVWRKS_MMBASE		0x14
-#define SVWRKS_CACHING		0x4b
-#define SVWRKS_FEATURE		0x68
-
-/* func 1 registers */
-#define SVWRKS_AGP_ENABLE	0x60
-#define SVWRKS_COMMAND		0x04
-
-/* Memory mapped registers */
-#define SVWRKS_GART_CACHE	0x02
-#define SVWRKS_GATTBASE		0x04
-#define SVWRKS_TLBFLUSH		0x10
-#define SVWRKS_POSTFLUSH	0x14
-#define SVWRKS_DIRFLUSH		0x0c
-
-/* HP ZX1 SBA registers */
-#define HP_ZX1_CTRL		0x200
-#define HP_ZX1_IBASE		0x300
-#define HP_ZX1_IMASK		0x308
-#define HP_ZX1_PCOM		0x310
-#define HP_ZX1_TCNFG		0x318
-#define HP_ZX1_PDIR_BASE	0x320
-#define HP_ZX1_CACHE_FLUSH	0x428
-
-/* NVIDIA registers */
-#define NVIDIA_0_APSIZE		0x80
-#define NVIDIA_1_WBC		0xf0
-#define NVIDIA_2_GARTCTRL	0xd0
-#define NVIDIA_2_APBASE		0xd8
-#define NVIDIA_2_APLIMIT	0xdc
-#define NVIDIA_2_ATTBASE(i)	(0xe0 + (i) * 4)
-#define NVIDIA_3_APBASE		0x50
-#define NVIDIA_3_APLIMIT	0x54
-
-
 struct agp_device_ids {
 	unsigned short device_id; /* first, to make table easier to read */
 	enum chipset_type chipset;
@@ -402,21 +272,38 @@ void global_cache_flush(void);
 void get_agp_version(struct agp_bridge_data *bridge);
 unsigned long agp_generic_mask_memory(unsigned long addr, int type);
 
+/* generic routines for agp>=3 */
+int agp3_generic_fetch_size(void);
+void agp3_generic_tlbflush(struct agp_memory *mem);
+int agp3_generic_configure(void);
+void agp3_generic_cleanup(void);
+
+/* aperture sizes have been standardised since v3 */
+#define AGP_GENERIC_SIZES_ENTRIES 11
+extern struct aper_size_info_16 agp3_generic_sizes[];
+
+
 extern int agp_off;
 extern int agp_try_unsupported_boot;
 
-/* Standard agp registers */
-#define AGPSTAT			0x4
-#define AGPCMD			0x8
-#define AGPNISTAT		0xc
-#define AGPCTRL                 0x10
-#define AGPNEPG			0x16
-#define AGPNICMD		0x20
+/* Chipset independant registers (from AGP Spec) */
+#define AGP_APBASE	0x10
+
+#define AGPSTAT		0x4
+#define AGPCMD		0x8
+#define AGPNISTAT	0xc
+#define AGPCTRL		0x10
+#define AGPAPSIZE	0x14
+#define AGPNEPG		0x16
+#define AGPGARTLO	0x18
+#define AGPGARTHI	0x1c
+#define AGPNICMD	0x20
 
 #define AGP_MAJOR_VERSION_SHIFT	(20)
 #define AGP_MINOR_VERSION_SHIFT	(16)
 
 #define AGPSTAT_RQ_DEPTH	(0xff000000)
+#define AGPSTAT_RQ_DEPTH_SHIFT	24
 
 #define AGPSTAT_CAL_MASK	(1<<12|1<<11|1<<10)
 #define AGPSTAT_ARQSZ		(1<<15|1<<14|1<<13)
@@ -435,4 +322,7 @@ extern int agp_try_unsupported_boot;
 #define AGPSTAT3_8X		(1<<1)
 #define AGPSTAT3_4X		(1)
 
-#endif				/* _AGP_BACKEND_PRIV_H */
+#define AGPCTRL_APERENB		(1<<8)
+#define AGPCTRL_GTLBEN		(1<<7)
+
+#endif	/* _AGP_BACKEND_PRIV_H */
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/ali-agp.c linux-2.6.5-rc3/drivers/char/agp/ali-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/ali-agp.c	2003-10-13 18:05:42.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/ali-agp.c	2004-03-19 20:06:32.000000000 +0000
@@ -9,6 +9,14 @@
 #include <linux/agp_backend.h>
 #include "agp.h"
 
+#define ALI_AGPCTRL	0xb8
+#define ALI_ATTBASE	0xbc
+#define ALI_TLBCTRL	0xc0
+#define ALI_TAGCTRL	0xc4
+#define ALI_CACHE_FLUSH_CTRL	0xD0
+#define ALI_CACHE_FLUSH_ADDR_MASK	0xFFFFF000
+#define ALI_CACHE_FLUSH_EN	0x100
+
 static int ali_fetch_size(void)
 {
 	int i;
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/amd-k7-agp.c linux-2.6.5-rc3/drivers/char/agp/amd-k7-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/amd-k7-agp.c	2003-10-13 18:05:42.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/amd-k7-agp.c	2004-03-19 20:06:32.000000000 +0000
@@ -11,6 +11,15 @@
 #include <linux/mm.h>
 #include "agp.h"
 
+#define AMD_MMBASE	0x14
+#define AMD_APSIZE	0xac
+#define AMD_MODECNTL	0xb0
+#define AMD_MODECNTL2	0xb2
+#define AMD_GARTENABLE	0x02	/* In mmio region (16-bit register) */
+#define AMD_ATTBASE	0x04	/* In mmio region (32-bit register) */
+#define AMD_TLBFLUSH	0x0c	/* In mmio region (32-bit register) */
+#define AMD_CACHEENTRY	0x10	/* In mmio region (32-bit register) */
+
 struct amd_page_map {
 	unsigned long *real;
 	unsigned long *remapped;
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/amd64-agp.c linux-2.6.5-rc3/drivers/char/agp/amd64-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/amd64-agp.c	2004-02-25 16:06:01.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/amd64-agp.c	2004-03-19 20:06:32.000000000 +0000
@@ -31,6 +31,13 @@
 #define INVGART		(1<<0)
 #define GARTPTEERR	(1<<1)
 
+/* K8 On-cpu GART registers */
+#define AMD64_GARTAPERTURECTL	0x90
+#define AMD64_GARTAPERTUREBASE	0x94
+#define AMD64_GARTTABLEBASE	0x98
+#define AMD64_GARTCACHECTL	0x9c
+#define AMD64_GARTEN		(1<<0)
+
 /* NVIDIA K8 registers */
 #define NVIDIA_X86_64_0_APBASE		0x10
 #define NVIDIA_X86_64_1_APBASE1		0x50
@@ -382,8 +389,9 @@ static void __devinit amd8151_init(struc
 	case 0x11: revstring="B0"; break;
 	case 0x12: revstring="B1"; break;
 	case 0x13: revstring="B2"; break;
+	case 0x14: revstring="B3"; break;
 	default:   revstring="??"; break;
-		}
+	}
 
 	printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
 
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/ati-agp.c linux-2.6.5-rc3/drivers/char/agp/ati-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/ati-agp.c	2004-01-08 13:25:31.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/ati-agp.c	2004-03-19 20:06:32.000000000 +0000
@@ -10,6 +10,18 @@
 #include <asm/agp.h>
 #include "agp.h"
 
+#define ATI_GART_MMBASE_ADDR	0x14
+#define ATI_RS100_APSIZE	0xac
+#define ATI_RS100_IG_AGPMODE	0xb0
+#define ATI_RS300_APSIZE	0xf8
+#define ATI_RS300_IG_AGPMODE	0xfc
+#define ATI_GART_FEATURE_ID		0x00
+#define ATI_GART_BASE			0x04
+#define ATI_GART_CACHE_SZBASE		0x08
+#define ATI_GART_CACHE_CNTRL		0x0c
+#define ATI_GART_CACHE_ENTRY_CNTRL	0x10
+
+
 static struct aper_size_info_lvl2 ati_generic_sizes[7] =
 {
 	{2048, 524288, 0x0000000c},
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/generic.c linux-2.6.5-rc3/drivers/char/agp/generic.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/generic.c	2003-12-12 13:00:37.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/generic.c	2004-03-29 15:02:25.000000000 +0000
@@ -880,7 +880,7 @@ EXPORT_SYMBOL(agp_generic_free_by_type);
 void *agp_generic_alloc_page(void)
 {
 	struct page * page;
-	
+
 	page = alloc_page(GFP_KERNEL);
 	if (page == NULL)
 		return 0;
@@ -956,3 +956,85 @@ unsigned long agp_generic_mask_memory(un
 }
 EXPORT_SYMBOL(agp_generic_mask_memory);
 
+/*
+ * These functions are implemented according to the AGPv3 spec,
+ * which covers implementation details that had previously been
+ * left open.
+ */
+
+int agp3_generic_fetch_size(void)
+{
+	u16 temp_size;
+	int i;
+	struct aper_size_info_16 *values;
+
+	pci_read_config_word(agp_bridge->dev, agp_bridge->capndx+AGPAPSIZE, &temp_size);
+	values = A_SIZE_16(agp_bridge->driver->aperture_sizes);
+
+	for (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {
+		if (temp_size == values[i].size_value) {
+			agp_bridge->previous_size =
+				agp_bridge->current_size = (void *) (values + i);
+
+			agp_bridge->aperture_size_idx = i;
+			return values[i].size;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(agp3_generic_fetch_size);
+
+void agp3_generic_tlbflush(struct agp_memory *mem)
+{
+	u32 ctrl;
+	pci_read_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, &ctrl);
+	pci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, ctrl & ~AGPCTRL_GTLBEN);
+	pci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, ctrl);
+}
+EXPORT_SYMBOL(agp3_generic_tlbflush);
+
+int agp3_generic_configure(void)
+{
+	u32 temp;
+	struct aper_size_info_16 *current_size;
+
+	current_size = A_SIZE_16(agp_bridge->current_size);
+
+	pci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);
+	agp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
+
+	/* set aperture size */
+	pci_write_config_word(agp_bridge->dev, agp_bridge->capndx+AGPAPSIZE, current_size->size_value);
+	/* set gart pointer */
+	pci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPGARTLO, agp_bridge->gatt_bus_addr);
+	/* enable aperture and GTLB */
+	pci_read_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, &temp);
+	pci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, temp | AGPCTRL_APERENB | AGPCTRL_GTLBEN);
+	return 0;
+}
+EXPORT_SYMBOL(agp3_generic_configure);
+
+void agp3_generic_cleanup(void)
+{
+	u32 ctrl;
+	pci_read_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, &ctrl);
+	pci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, ctrl & ~AGPCTRL_APERENB);
+}
+EXPORT_SYMBOL(agp3_generic_cleanup);
+
+struct aper_size_info_16 agp3_generic_sizes[AGP_GENERIC_SIZES_ENTRIES] =
+{
+	{4096, 1048576, 10,0x000},
+	{2048,  524288, 9, 0x800},
+	{1024,  262144, 8, 0xc00},
+	{ 512,  131072, 7, 0xe00},
+	{ 256,   65536, 6, 0xf00},
+	{ 128,   32768, 5, 0xf20},
+	{  64,   16384, 4, 0xf30},
+	{  32,    8192, 3, 0xf38},
+	{  16,    4096, 2, 0xf3c},
+	{   8,    2048, 1, 0xf3e},
+	{   4,    1024, 0, 0xf3f}
+};
+EXPORT_SYMBOL(agp3_generic_sizes);
+
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/i460-agp.c linux-2.6.5-rc3/drivers/char/agp/i460-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/i460-agp.c	2003-10-13 18:05:42.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/i460-agp.c	2004-03-19 20:06:32.000000000 +0000
@@ -14,6 +14,13 @@
 
 #include "agp.h"
 
+#define INTEL_I460_BAPBASE		0x98
+#define INTEL_I460_GXBCTL		0xa0
+#define INTEL_I460_AGPSIZ		0xa2
+#define INTEL_I460_ATTBASE		0xfe200000
+#define INTEL_I460_GATT_VALID		(1UL << 24)
+#define INTEL_I460_GATT_COHERENT	(1UL << 25)
+
 /*
  * The i460 can operate with large (4MB) pages, but there is no sane way to support this
  * within the current kernel/DRM environment, so we disable the relevant code for now.
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/intel-agp.c linux-2.6.5-rc3/drivers/char/agp/intel-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/intel-agp.c	2004-02-23 03:10:09.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/intel-agp.c	2004-03-21 13:30:09.000000000 +0000
@@ -13,6 +13,31 @@
 #include <linux/agp_backend.h>
 #include "agp.h"
 
+/* Intel 815 register */
+#define INTEL_815_APCONT	0x51
+#define INTEL_815_ATTBASE_MASK	~0x1FFFFFFF
+
+/* Intel i820 registers */
+#define INTEL_I820_RDCR		0x51
+#define INTEL_I820_ERRSTS	0xc8
+
+/* Intel i840 registers */
+#define INTEL_I840_MCHCFG	0x50
+#define INTEL_I840_ERRSTS	0xc8
+
+/* Intel i850 registers */
+#define INTEL_I850_MCHCFG	0x50
+#define INTEL_I850_ERRSTS	0xc8
+
+/* Intel 7505 registers */
+#define INTEL_I7505_APSIZE	0x74
+#define INTEL_I7505_NCAPID	0x60
+#define INTEL_I7505_NISTAT	0x6c
+#define INTEL_I7505_ATTBASE	0x78
+#define INTEL_I7505_ERRSTS	0x42
+#define INTEL_I7505_AGPCTRL	0x70
+#define INTEL_I7505_MCHCFG	0x50
+
 static struct aper_size_info_fixed intel_i810_sizes[] =
 {
 	{64, 16384, 4},
@@ -942,7 +967,7 @@ static struct aper_size_info_8 intel_830
 	{32, 8192, 3, 56}
 };
 
-struct agp_bridge_driver intel_generic_driver = {
+static struct agp_bridge_driver intel_generic_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_generic_sizes,
 	.size_type		= U16_APER_SIZE,
@@ -965,7 +990,7 @@ struct agp_bridge_driver intel_generic_d
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-struct agp_bridge_driver intel_810_driver = {
+static struct agp_bridge_driver intel_810_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_i810_sizes,
 	.size_type		= FIXED_APER_SIZE,
@@ -989,8 +1014,7 @@ struct agp_bridge_driver intel_810_drive
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-
-struct agp_bridge_driver intel_815_driver = {
+static struct agp_bridge_driver intel_815_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_815_sizes,
 	.size_type		= U8_APER_SIZE,
@@ -1013,7 +1037,7 @@ struct agp_bridge_driver intel_815_drive
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-struct agp_bridge_driver intel_830_driver = {
+static struct agp_bridge_driver intel_830_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_i830_sizes,
 	.size_type		= FIXED_APER_SIZE,
@@ -1037,8 +1061,7 @@ struct agp_bridge_driver intel_830_drive
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-
-struct agp_bridge_driver intel_820_driver = {
+static struct agp_bridge_driver intel_820_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_8xx_sizes,
 	.size_type		= U8_APER_SIZE,
@@ -1061,7 +1084,7 @@ struct agp_bridge_driver intel_820_drive
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-struct agp_bridge_driver intel_830mp_driver = {
+static struct agp_bridge_driver intel_830mp_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_830mp_sizes,
 	.size_type		= U8_APER_SIZE,
@@ -1084,7 +1107,7 @@ struct agp_bridge_driver intel_830mp_dri
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-struct agp_bridge_driver intel_840_driver = {
+static struct agp_bridge_driver intel_840_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_8xx_sizes,
 	.size_type		= U8_APER_SIZE,
@@ -1107,7 +1130,7 @@ struct agp_bridge_driver intel_840_drive
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-struct agp_bridge_driver intel_845_driver = {
+static struct agp_bridge_driver intel_845_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_8xx_sizes,
 	.size_type		= U8_APER_SIZE,
@@ -1130,7 +1153,7 @@ struct agp_bridge_driver intel_845_drive
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-struct agp_bridge_driver intel_850_driver = {
+static struct agp_bridge_driver intel_850_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_8xx_sizes,
 	.size_type		= U8_APER_SIZE,
@@ -1153,7 +1176,7 @@ struct agp_bridge_driver intel_850_drive
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-struct agp_bridge_driver intel_860_driver = {
+static struct agp_bridge_driver intel_860_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_8xx_sizes,
 	.size_type		= U8_APER_SIZE,
@@ -1176,7 +1199,7 @@ struct agp_bridge_driver intel_860_drive
 	.agp_destroy_page	= agp_generic_destroy_page,
 };
 
-struct agp_bridge_driver intel_7505_driver = {
+static struct agp_bridge_driver intel_7505_driver = {
 	.owner			= THIS_MODULE,
 	.aperture_sizes		= intel_8xx_sizes,
 	.size_type		= U8_APER_SIZE,
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/intel-mch-agp.c linux-2.6.5-rc3/drivers/char/agp/intel-mch-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/intel-mch-agp.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/intel-mch-agp.c	2004-03-24 17:03:47.000000000 +0000
@@ -0,0 +1,631 @@
+/*
+ * Intel MCH AGPGART routines.
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/agp_backend.h>
+#include "agp.h"
+
+
+#define AGP_DCACHE_MEMORY	1
+#define AGP_PHYS_MEMORY		2
+
+static struct gatt_mask intel_i810_masks[] =
+{
+	{.mask = I810_PTE_VALID, .type = 0},
+	{.mask = (I810_PTE_VALID | I810_PTE_LOCAL), .type = AGP_DCACHE_MEMORY},
+	{.mask = I810_PTE_VALID, .type = 0}
+};
+
+static void intel_i810_tlbflush(struct agp_memory *mem)
+{
+	return;
+}
+
+static void intel_i810_agp_enable(u32 mode)
+{
+	return;
+}
+
+
+/*
+ * The i810/i830 requires a physical address to program its mouse
+ * pointer into hardware.
+ * However the Xserver still writes to it through the agp aperture.
+ */
+static struct agp_memory *alloc_agpphysmem_i8xx(size_t pg_count, int type)
+{
+	struct agp_memory *new;
+	void *addr;
+
+	if (pg_count != 1)
+		return NULL;
+
+	addr = agp_bridge->driver->agp_alloc_page();
+	if (addr == NULL)
+		return NULL;
+
+	new = agp_create_memory(1);
+	if (new == NULL)
+		return NULL;
+
+	new->memory[0] = agp_bridge->driver->mask_memory(virt_to_phys(addr), type);
+	new->page_count = 1;
+	new->num_scratch_pages = 1;
+	new->type = AGP_PHYS_MEMORY;
+	new->physical = new->memory[0];
+	return new;
+}
+
+static void intel_i810_free_by_type(struct agp_memory *curr)
+{
+	agp_free_key(curr->key);
+	if(curr->type == AGP_PHYS_MEMORY) {
+		agp_bridge->driver->agp_destroy_page(phys_to_virt(curr->memory[0]));
+		vfree(curr->memory);
+	}
+	kfree(curr);
+}
+
+static unsigned long intel_i810_mask_memory(unsigned long addr, int type)
+{
+	/* Type checking must be done elsewhere */
+	return addr | agp_bridge->driver->masks[type].mask;
+}
+
+static struct aper_size_info_fixed intel_i830_sizes[] =
+{
+	{128, 32768, 5},
+	/* The 64M mode still requires a 128k gatt */
+	{64, 16384, 5}
+};
+
+static struct _intel_i830_private {
+	struct pci_dev *i830_dev;		/* device one */
+	volatile u8 *registers;
+	int gtt_entries;
+} intel_i830_private;
+
+static void intel_i830_init_gtt_entries(void)
+{
+	u16 gmch_ctrl;
+	int gtt_entries;
+	u8 rdct;
+	int local = 0;
+	static const int ddt[4] = { 0, 16, 32, 64 };
+
+	pci_read_config_word(agp_bridge->dev,I830_GMCH_CTRL,&gmch_ctrl);
+
+	if (agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82830_HB ||
+	    agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82845G_HB) {
+		switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
+		case I830_GMCH_GMS_STOLEN_512:
+			gtt_entries = KB(512) - KB(132);
+			break;
+		case I830_GMCH_GMS_STOLEN_1024:
+			gtt_entries = MB(1) - KB(132);
+			break;
+		case I830_GMCH_GMS_STOLEN_8192:
+			gtt_entries = MB(8) - KB(132);
+			break;
+		case I830_GMCH_GMS_LOCAL:
+			rdct = INREG8(intel_i830_private.registers,
+				      I830_RDRAM_CHANNEL_TYPE);
+			gtt_entries = (I830_RDRAM_ND(rdct) + 1) *
+					MB(ddt[I830_RDRAM_DDT(rdct)]);
+			local = 1;
+			break;
+		default:
+			gtt_entries = 0;
+			break;
+		}
+	} else {
+		switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
+		case I855_GMCH_GMS_STOLEN_1M:
+			gtt_entries = MB(1) - KB(132);
+			break;
+		case I855_GMCH_GMS_STOLEN_4M:
+			gtt_entries = MB(4) - KB(132);
+			break;
+		case I855_GMCH_GMS_STOLEN_8M:
+			gtt_entries = MB(8) - KB(132);
+			break;
+		case I855_GMCH_GMS_STOLEN_16M:
+			gtt_entries = MB(16) - KB(132);
+			break;
+		case I855_GMCH_GMS_STOLEN_32M:
+			gtt_entries = MB(32) - KB(132);
+			break;
+		default:
+			gtt_entries = 0;
+			break;
+		}
+	}
+	if (gtt_entries > 0)
+		printk(KERN_INFO PFX "Detected %dK %s memory.\n",
+		       gtt_entries / KB(1), local ? "local" : "stolen");
+	else
+		printk(KERN_INFO PFX
+		       "No pre-allocated video memory detected.\n");
+	gtt_entries /= KB(4);
+
+	intel_i830_private.gtt_entries = gtt_entries;
+}
+
+/* The intel i830 automatically initializes the agp aperture during POST.
+ * Use the memory already set aside for in the GTT.
+ */
+static int intel_i830_create_gatt_table(void)
+{
+	int page_order;
+	struct aper_size_info_fixed *size;
+	int num_entries;
+	u32 temp;
+
+	size = agp_bridge->current_size;
+	page_order = size->page_order;
+	num_entries = size->num_entries;
+	agp_bridge->gatt_table_real = 0;
+
+	pci_read_config_dword(intel_i830_private.i830_dev,I810_MMADDR,&temp);
+	temp &= 0xfff80000;
+
+	intel_i830_private.registers = (volatile u8 *) ioremap(temp,128 * 4096);
+	if (!intel_i830_private.registers)
+		return (-ENOMEM);
+
+	temp = INREG32(intel_i830_private.registers,I810_PGETBL_CTL) & 0xfffff000;
+	global_cache_flush();
+
+	/* we have to call this as early as possible after the MMIO base address is known */
+	intel_i830_init_gtt_entries();
+
+	agp_bridge->gatt_table = NULL;
+
+	agp_bridge->gatt_bus_addr = temp;
+
+	return(0);
+}
+
+/* Return the gatt table to a sane state. Use the top of stolen
+ * memory for the GTT.
+ */
+static int intel_i830_free_gatt_table(void)
+{
+	return(0);
+}
+
+static int intel_i830_fetch_size(void)
+{
+	u16 gmch_ctrl;
+	struct aper_size_info_fixed *values;
+
+	values = A_SIZE_FIX(agp_bridge->driver->aperture_sizes);
+
+	if (agp_bridge->dev->device != PCI_DEVICE_ID_INTEL_82830_HB &&
+	    agp_bridge->dev->device != PCI_DEVICE_ID_INTEL_82845G_HB) {
+		/* 855GM/852GM/865G has 128MB aperture size */
+		agp_bridge->previous_size = agp_bridge->current_size = (void *) values;
+		agp_bridge->aperture_size_idx = 0;
+		return(values[0].size);
+	}
+
+	pci_read_config_word(agp_bridge->dev,I830_GMCH_CTRL,&gmch_ctrl);
+
+	if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M) {
+		agp_bridge->previous_size = agp_bridge->current_size = (void *) values;
+		agp_bridge->aperture_size_idx = 0;
+		return(values[0].size);
+	} else {
+		agp_bridge->previous_size = agp_bridge->current_size = (void *) values;
+		agp_bridge->aperture_size_idx = 1;
+		return(values[1].size);
+	}
+
+	return(0);
+}
+
+static int intel_i830_configure(void)
+{
+	struct aper_size_info_fixed *current_size;
+	u32 temp;
+	u16 gmch_ctrl;
+	int i;
+
+	current_size = A_SIZE_FIX(agp_bridge->current_size);
+
+	pci_read_config_dword(intel_i830_private.i830_dev,I810_GMADDR,&temp);
+	agp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
+
+	pci_read_config_word(agp_bridge->dev,I830_GMCH_CTRL,&gmch_ctrl);
+	gmch_ctrl |= I830_GMCH_ENABLED;
+	pci_write_config_word(agp_bridge->dev,I830_GMCH_CTRL,gmch_ctrl);
+
+	OUTREG32(intel_i830_private.registers,I810_PGETBL_CTL,agp_bridge->gatt_bus_addr | I810_PGETBL_ENABLED);
+	global_cache_flush();
+
+	if (agp_bridge->driver->needs_scratch_page)
+		for (i = intel_i830_private.gtt_entries; i < current_size->num_entries; i++)
+			OUTREG32(intel_i830_private.registers,I810_PTE_BASE + (i * 4),agp_bridge->scratch_page);
+
+	return (0);
+}
+
+static void intel_i830_cleanup(void)
+{
+	iounmap((void *) intel_i830_private.registers);
+}
+
+static int intel_i830_insert_entries(struct agp_memory *mem,off_t pg_start,
+				int type)
+{
+	int i,j,num_entries;
+	void *temp;
+
+	temp = agp_bridge->current_size;
+	num_entries = A_SIZE_FIX(temp)->num_entries;
+
+	if (pg_start < intel_i830_private.gtt_entries) {
+		printk (KERN_DEBUG PFX "pg_start == 0x%.8lx,intel_i830_private.gtt_entries == 0x%.8x\n",
+				pg_start,intel_i830_private.gtt_entries);
+
+		printk (KERN_INFO PFX "Trying to insert into local/stolen memory\n");
+		return (-EINVAL);
+	}
+
+	if ((pg_start + mem->page_count) > num_entries)
+		return (-EINVAL);
+
+	/* The i830 can't check the GTT for entries since its read only,
+	 * depend on the caller to make the correct offset decisions.
+	 */
+
+	if ((type != 0 && type != AGP_PHYS_MEMORY) ||
+		(mem->type != 0 && mem->type != AGP_PHYS_MEMORY))
+		return (-EINVAL);
+
+	global_cache_flush();
+
+	for (i = 0, j = pg_start; i < mem->page_count; i++, j++)
+		OUTREG32(intel_i830_private.registers,I810_PTE_BASE + (j * 4),
+			agp_bridge->driver->mask_memory(mem->memory[i], mem->type));
+
+	global_cache_flush();
+
+	agp_bridge->driver->tlb_flush(mem);
+
+	return(0);
+}
+
+static int intel_i830_remove_entries(struct agp_memory *mem,off_t pg_start,
+				int type)
+{
+	int i;
+
+	global_cache_flush();
+
+	if (pg_start < intel_i830_private.gtt_entries) {
+		printk (KERN_INFO PFX "Trying to disable local/stolen memory\n");
+		return (-EINVAL);
+	}
+
+	for (i = pg_start; i < (mem->page_count + pg_start); i++)
+		OUTREG32(intel_i830_private.registers,I810_PTE_BASE + (i * 4),agp_bridge->scratch_page);
+
+	global_cache_flush();
+
+	agp_bridge->driver->tlb_flush(mem);
+
+	return (0);
+}
+
+static struct agp_memory *intel_i830_alloc_by_type(size_t pg_count,int type)
+{
+	if (type == AGP_PHYS_MEMORY)
+		return(alloc_agpphysmem_i8xx(pg_count, type));
+
+	/* always return NULL for other allocation types for now */
+	return(NULL);
+}
+
+static int intel_8xx_fetch_size(void)
+{
+	u8 temp;
+	int i;
+	struct aper_size_info_8 *values;
+
+	pci_read_config_byte(agp_bridge->dev, INTEL_APSIZE, &temp);
+
+	values = A_SIZE_8(agp_bridge->driver->aperture_sizes);
+
+	for (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {
+		if (temp == values[i].size_value) {
+			agp_bridge->previous_size =
+				agp_bridge->current_size = (void *) (values + i);
+			agp_bridge->aperture_size_idx = i;
+			return values[i].size;
+		}
+	}
+	return 0;
+}
+
+static void intel_8xx_tlbflush(struct agp_memory *mem)
+{
+	u32 temp;
+	pci_read_config_dword(agp_bridge->dev, INTEL_AGPCTRL, &temp);
+	pci_write_config_dword(agp_bridge->dev, INTEL_AGPCTRL, temp & ~(1 << 7));
+	pci_read_config_dword(agp_bridge->dev, INTEL_AGPCTRL, &temp);
+	pci_write_config_dword(agp_bridge->dev, INTEL_AGPCTRL, temp | (1 << 7));
+}
+
+static void intel_8xx_cleanup(void)
+{
+	u16 temp;
+	struct aper_size_info_8 *previous_size;
+
+	previous_size = A_SIZE_8(agp_bridge->previous_size);
+	pci_read_config_word(agp_bridge->dev, INTEL_NBXCFG, &temp);
+	pci_write_config_word(agp_bridge->dev, INTEL_NBXCFG, temp & ~(1 << 9));
+	pci_write_config_byte(agp_bridge->dev, INTEL_APSIZE, previous_size->size_value);
+}
+
+static int intel_845_configure(void)
+{
+	u32 temp;
+	u8 temp2;
+	struct aper_size_info_8 *current_size;
+
+	current_size = A_SIZE_8(agp_bridge->current_size);
+
+	/* aperture size */
+	pci_write_config_byte(agp_bridge->dev, INTEL_APSIZE, current_size->size_value); 
+
+	/* address to map to */
+	pci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);
+	agp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
+
+	/* attbase - aperture base */
+	pci_write_config_dword(agp_bridge->dev, INTEL_ATTBASE, agp_bridge->gatt_bus_addr); 
+
+	/* agpctrl */
+	pci_write_config_dword(agp_bridge->dev, INTEL_AGPCTRL, 0x0000); 
+
+	/* agpm */
+	pci_read_config_byte(agp_bridge->dev, INTEL_I845_AGPM, &temp2);
+	pci_write_config_byte(agp_bridge->dev, INTEL_I845_AGPM, temp2 | (1 << 1));
+	/* clear any possible error conditions */
+	pci_write_config_word(agp_bridge->dev, INTEL_I845_ERRSTS, 0x001c); 
+	return 0;
+}
+
+
+/* Setup function */
+static struct gatt_mask intel_generic_masks[] =
+{
+	{.mask = 0x00000017, .type = 0}
+};
+
+static struct aper_size_info_8 intel_8xx_sizes[7] =
+{
+	{256, 65536, 6, 0},
+	{128, 32768, 5, 32},
+	{64, 16384, 4, 48},
+	{32, 8192, 3, 56},
+	{16, 4096, 2, 60},
+	{8, 2048, 1, 62},
+	{4, 1024, 0, 63}
+};
+
+static struct agp_bridge_driver intel_830_driver = {
+	.owner			= THIS_MODULE,
+	.aperture_sizes		= intel_i830_sizes,
+	.size_type		= FIXED_APER_SIZE,
+	.num_aperture_sizes 	= 2,
+	.needs_scratch_page	= TRUE,
+	.configure		= intel_i830_configure,
+	.fetch_size		= intel_i830_fetch_size,
+	.cleanup		= intel_i830_cleanup,
+	.tlb_flush		= intel_i810_tlbflush,
+	.mask_memory		= intel_i810_mask_memory,
+	.masks			= intel_i810_masks,
+	.agp_enable		= intel_i810_agp_enable,
+	.cache_flush		= global_cache_flush,
+	.create_gatt_table	= intel_i830_create_gatt_table,
+	.free_gatt_table	= intel_i830_free_gatt_table,
+	.insert_memory		= intel_i830_insert_entries,
+	.remove_memory		= intel_i830_remove_entries,
+	.alloc_by_type		= intel_i830_alloc_by_type,
+	.free_by_type		= intel_i810_free_by_type,
+	.agp_alloc_page		= agp_generic_alloc_page,
+	.agp_destroy_page	= agp_generic_destroy_page,
+};
+
+static struct agp_bridge_driver intel_845_driver = {
+	.owner			= THIS_MODULE,
+	.aperture_sizes		= intel_8xx_sizes,
+	.size_type		= U8_APER_SIZE,
+	.num_aperture_sizes	= 7,
+	.configure		= intel_845_configure,
+	.fetch_size		= intel_8xx_fetch_size,
+	.cleanup		= intel_8xx_cleanup,
+	.tlb_flush		= intel_8xx_tlbflush,
+	.mask_memory		= agp_generic_mask_memory,
+	.masks			= intel_generic_masks,
+	.agp_enable		= agp_generic_enable,
+	.cache_flush		= global_cache_flush,
+	.create_gatt_table	= agp_generic_create_gatt_table,
+	.free_gatt_table	= agp_generic_free_gatt_table,
+	.insert_memory		= agp_generic_insert_memory,
+	.remove_memory		= agp_generic_remove_memory,
+	.alloc_by_type		= agp_generic_alloc_by_type,
+	.free_by_type		= agp_generic_free_by_type,
+	.agp_alloc_page		= agp_generic_alloc_page,
+	.agp_destroy_page	= agp_generic_destroy_page,
+};
+
+
+static int find_i830(u16 device)
+{
+	struct pci_dev *i830_dev;
+
+	i830_dev = pci_find_device(PCI_VENDOR_ID_INTEL, device, NULL);
+	if (i830_dev && PCI_FUNC(i830_dev->devfn) != 0) {
+		i830_dev = pci_find_device(PCI_VENDOR_ID_INTEL,
+				device, i830_dev);
+	}
+
+	if (!i830_dev)
+		return 0;
+
+	intel_i830_private.i830_dev = i830_dev;
+	return 1;
+}
+
+static int __devinit agp_intelmch_probe(struct pci_dev *pdev,
+				     const struct pci_device_id *ent)
+{
+	struct agp_bridge_data *bridge;
+	char *name = "(unknown)";
+	u8 cap_ptr = 0;
+	struct resource *r;
+
+	cap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);
+
+	bridge = agp_alloc_bridge();
+	if (!bridge)
+		return -ENOMEM;
+
+	switch (pdev->device) {
+	case PCI_DEVICE_ID_INTEL_82865_HB:
+		if (find_i830(PCI_DEVICE_ID_INTEL_82865_IG)) {
+			bridge->driver = &intel_830_driver;
+		} else {
+			bridge->driver = &intel_845_driver;
+		}
+		name = "865";
+		break;
+	case PCI_DEVICE_ID_INTEL_82875_HB:
+		bridge->driver = &intel_845_driver;
+		name = "i875";
+		break;
+
+	default:
+		printk(KERN_ERR PFX "Unsupported Intel chipset (device id: %04x)\n",
+			    pdev->device);
+		return -ENODEV;
+	};
+
+	bridge->dev = pdev;
+	bridge->capndx = cap_ptr;
+
+	if (bridge->driver == &intel_830_driver)
+		bridge->dev_private_data = &intel_i830_private;
+
+	printk(KERN_INFO PFX "Detected an Intel %s Chipset.\n", name);
+
+	/*
+	* The following fixes the case where the BIOS has "forgotten" to
+	* provide an address range for the GART.
+	* 20030610 - hamish@zot.org
+	*/
+	r = &pdev->resource[0];
+	if (!r->start && r->end) {
+		if(pci_assign_resource(pdev, 0)) {
+			printk(KERN_ERR PFX "could not assign resource 0\n");
+			return (-ENODEV);
+		}
+	}
+
+	/*
+	* If the device has not been properly setup, the following will catch
+	* the problem and should stop the system from crashing.
+	* 20030610 - hamish@zot.org
+	*/
+	if (pci_enable_device(pdev)) {
+		printk(KERN_ERR PFX "Unable to Enable PCI device\n");
+		return (-ENODEV);
+	}
+
+	/* Fill in the mode register */
+	if (cap_ptr) {
+		pci_read_config_dword(pdev,
+				bridge->capndx+PCI_AGP_STATUS,
+				&bridge->mode);
+	}
+
+	pci_set_drvdata(pdev, bridge);
+	return agp_add_bridge(bridge);
+}
+
+static void __devexit agp_intelmch_remove(struct pci_dev *pdev)
+{
+	struct agp_bridge_data *bridge = pci_get_drvdata(pdev);
+
+	agp_remove_bridge(bridge);
+	agp_put_bridge(bridge);
+}
+
+static int agp_intelmch_suspend(struct pci_dev *dev, u32 state)
+{
+	return 0;
+}
+
+static int agp_intelmch_resume(struct pci_dev *pdev)
+{
+	struct agp_bridge_data *bridge = pci_get_drvdata(pdev);
+
+	if (bridge->driver == &intel_845_driver)
+		intel_845_configure();
+
+	return 0;
+}
+
+static struct pci_device_id agp_intelmch_pci_table[] = {
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_INTEL,
+	.device		= PCI_ANY_ID,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(pci, agp_intelmch_pci_table);
+
+static struct pci_driver agp_intelmch_pci_driver = {
+	.name		= "agpgart-intel-mch",
+	.id_table	= agp_intelmch_pci_table,
+	.probe		= agp_intelmch_probe,
+	.remove		= agp_intelmch_remove,
+	.suspend	= agp_intelmch_suspend,
+	.resume		= agp_intelmch_resume,
+};
+
+/* intel_agp_init() must not be declared static for explicit
+   early initialization to work (ie i810fb) */
+int __init agp_intelmch_init(void)
+{
+	static int agp_initialised=0;
+
+	if (agp_initialised == 1)
+		return 0;
+	agp_initialised=1;
+
+	return pci_module_init(&agp_intelmch_pci_driver);
+}
+
+static void __exit agp_intelmch_cleanup(void)
+{
+	pci_unregister_driver(&agp_intelmch_pci_driver);
+}
+
+module_init(agp_intelmch_init);
+module_exit(agp_intelmch_cleanup);
+
+MODULE_AUTHOR("Dave Jones <davej@codemonkey.org.uk>");
+MODULE_LICENSE("GPL and additional rights");
+
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/nvidia-agp.c linux-2.6.5-rc3/drivers/char/agp/nvidia-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/nvidia-agp.c	2003-11-30 12:18:29.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/nvidia-agp.c	2004-03-19 20:06:32.000000000 +0000
@@ -13,6 +13,17 @@
 #include <linux/mm.h>
 #include "agp.h"
 
+/* NVIDIA registers */
+#define NVIDIA_0_APSIZE		0x80
+#define NVIDIA_1_WBC		0xf0
+#define NVIDIA_2_GARTCTRL	0xd0
+#define NVIDIA_2_APBASE		0xd8
+#define NVIDIA_2_APLIMIT	0xdc
+#define NVIDIA_2_ATTBASE(i)	(0xe0 + (i) * 4)
+#define NVIDIA_3_APBASE		0x50
+#define NVIDIA_3_APLIMIT	0x54
+
+
 static struct _nvidia_private {
 	struct pci_dev *dev_1;
 	struct pci_dev *dev_2;
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/sis-agp.c linux-2.6.5-rc3/drivers/char/agp/sis-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/sis-agp.c	2003-11-01 07:12:14.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/sis-agp.c	2004-03-19 20:30:41.000000000 +0000
@@ -8,6 +8,12 @@
 #include <linux/agp_backend.h>
 #include "agp.h"
 
+#define SIS_ATTBASE	0x90
+#define SIS_APSIZE	0x94
+#define SIS_TLBCNTRL	0x97
+#define SIS_TLBFLUSH	0x98
+
+
 static int sis_fetch_size(void)
 {
 	u8 temp_size;
@@ -61,6 +67,42 @@ static void sis_cleanup(void)
 			      (previous_size->size_value & ~(0x03)));
 }
 
+static void sis_648_enable(u32 mode)
+{
+	struct pci_dev *device = NULL;
+	u32 command;
+	int rate;
+
+	printk(KERN_INFO PFX "Found an AGP %d.%d compliant device at %s.\n",
+		agp_bridge->major_version,
+		agp_bridge->minor_version,
+		agp_bridge->dev->slot_name);
+
+	pci_read_config_dword(agp_bridge->dev, agp_bridge->capndx + PCI_AGP_STATUS, &command);
+	command = agp_collect_device_status(mode, command);
+	command |= AGPSTAT_AGP_ENABLE;
+	rate = (command & 0x7) << 2;
+
+	while ((device = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, device)) != NULL) {
+		u8 agp = pci_find_capability(device, PCI_CAP_ID_AGP);
+		if (!agp)
+			continue;
+
+		printk(KERN_INFO PFX "Putting AGP V3 device at %s into %dx mode\n",
+			pci_name(device), rate);
+
+		pci_write_config_dword(device, agp + PCI_AGP_COMMAND, command);
+
+		if(device->device == PCI_DEVICE_ID_SI_648) {
+			// weird: on 648 and 648fx chipsets any rate change in the target command register
+			// triggers a 5ms screwup during which the master cannot be configured
+			printk(KERN_INFO PFX "sis 648 agp fix - giving bridge time to recover\n");
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout (1+(HZ*10)/1000);
+		}
+	}
+}
+
 static struct aper_size_info_8 sis_generic_sizes[7] =
 {
 	{256, 65536, 6, 99},
@@ -176,6 +218,26 @@ static struct agp_device_ids sis_agp_dev
 	{ }, /* dummy final entry, always present */
 };
 
+
+static void __devinit sis_get_driver(struct agp_bridge_data *bridge)
+{
+	if (bridge->dev->device == PCI_DEVICE_ID_SI_648) {
+		if (agp_bridge->major_version == 3 && agp_bridge->minor_version < 5) {
+			sis_driver.agp_enable=sis_648_enable;
+		} else {
+			sis_driver.agp_enable			= sis_648_enable;
+			sis_driver.aperture_sizes		= agp3_generic_sizes;
+			sis_driver.size_type			= U16_APER_SIZE;
+			sis_driver.num_aperture_sizes	= AGP_GENERIC_SIZES_ENTRIES;
+			sis_driver.configure			= agp3_generic_configure;
+			sis_driver.fetch_size			= agp3_generic_fetch_size;
+			sis_driver.cleanup				= agp3_generic_cleanup;
+			sis_driver.tlb_flush			= agp3_generic_tlbflush;
+		}
+	}
+}
+
+
 static int __devinit agp_sis_probe(struct pci_dev *pdev,
 				   const struct pci_device_id *ent)
 {
@@ -210,10 +272,11 @@ found:
 	bridge->dev = pdev;
 	bridge->capndx = cap_ptr;
 
+	get_agp_version(bridge);
+
 	/* Fill in the mode register */
-	pci_read_config_dword(pdev,
-			bridge->capndx+PCI_AGP_STATUS,
-			&bridge->mode);
+	pci_read_config_dword(pdev, bridge->capndx+PCI_AGP_STATUS, &bridge->mode);
+	sis_get_driver(bridge);
 
 	pci_set_drvdata(pdev, bridge);
 	return agp_add_bridge(bridge);
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/sworks-agp.c linux-2.6.5-rc3/drivers/char/agp/sworks-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/sworks-agp.c	2003-10-13 18:05:43.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/sworks-agp.c	2004-03-19 20:06:32.000000000 +0000
@@ -8,6 +8,23 @@
 #include <linux/agp_backend.h>
 #include "agp.h"
 
+#define SVWRKS_COMMAND		0x04
+#define SVWRKS_APSIZE		0x10
+#define SVWRKS_MMBASE		0x14
+#define SVWRKS_CACHING		0x4b
+#define SVWRKS_AGP_ENABLE	0x60
+#define SVWRKS_FEATURE		0x68
+
+#define SVWRKS_SIZE_MASK	0xfe000000
+
+/* Memory mapped registers */
+#define SVWRKS_GART_CACHE	0x02
+#define SVWRKS_GATTBASE		0x04
+#define SVWRKS_TLBFLUSH		0x10
+#define SVWRKS_POSTFLUSH	0x14
+#define SVWRKS_DIRFLUSH		0x0c
+
+
 struct serverworks_page_map {
 	unsigned long *real;
 	unsigned long *remapped;
@@ -454,10 +471,17 @@ static int __devinit agp_serverworks_pro
 	}
 
 	switch (pdev->device) {
+	case 0x0006:
+		/* ServerWorks CNB20HE
+		Fail silently.*/
+		printk (KERN_ERR PFX "Detected ServerWorks CNB20HE chipset: No AGP present.\n");
+		return -ENODEV;
+
 	case PCI_DEVICE_ID_SERVERWORKS_HE:
 	case PCI_DEVICE_ID_SERVERWORKS_LE:
 	case 0x0007:
 		break;
+
 	default:
 		printk(KERN_ERR PFX "Unsupported Serverworks chipset "
 				"(device id: %04x)\n", pdev->device);
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/agp/via-agp.c linux-2.6.5-rc3/drivers/char/agp/via-agp.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/agp/via-agp.c	2003-10-13 18:05:43.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/agp/via-agp.c	2004-03-19 20:06:32.000000000 +0000
@@ -9,6 +9,15 @@
 #include <linux/agp_backend.h>
 #include "agp.h"
 
+#define VIA_GARTCTRL	0x80
+#define VIA_APSIZE	0x84
+#define VIA_ATTBASE	0x88
+
+#define VIA_AGP3_GARTCTRL	0x90
+#define VIA_AGP3_APSIZE		0x94
+#define VIA_AGP3_ATTBASE	0x98
+#define VIA_AGPSEL		0xfd
+
 static int via_fetch_size(void)
 {
 	int i;
diff -purN linux-post-2.6.5-rc2-20040329/drivers/char/watchdog/pcwd.c linux-2.6.5-rc3/drivers/char/watchdog/pcwd.c
--- linux-post-2.6.5-rc2-20040329/drivers/char/watchdog/pcwd.c	2004-03-21 19:32:20.000000000 +0000
+++ linux-2.6.5-rc3/drivers/char/watchdog/pcwd.c	2004-03-27 16:21:17.000000000 +0000
@@ -44,10 +44,16 @@
  *              Added timeout module option to override default
  */
 
+/*
+ *	A bells and whistles driver is available from http://www.pcwd.de/
+ *	More info available at http://www.berkprod.com/ or http://www.pcwatchdog.com/
+ */
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/types.h>
 #include <linux/timer.h>
+#include <linux/jiffies.h>
 #include <linux/config.h>
 #include <linux/wait.h>
 #include <linux/slab.h>
@@ -56,6 +62,7 @@
 #include <linux/fs.h>
 #include <linux/miscdevice.h>
 #include <linux/watchdog.h>
+#include <linux/notifier.h>
 #include <linux/init.h>
 #include <linux/spinlock.h>
 #include <linux/reboot.h>
@@ -63,15 +70,8 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
-/*
- * These are the auto-probe addresses available.
- *
- * Revision A only uses ports 0x270 and 0x370.  Revision C introduced 0x350.
- * Revision A has an address range of 2 addresses, while Revision C has 3.
- */
-static int pcwd_ioports[] = { 0x270, 0x350, 0x370, 0x000 };
-
-#define WD_VER                  "1.14 (03/12/2004)"
+#define WD_VER                  "1.16 (03/27/2004)"
+#define PFX			"pcwd: "
 
 /*
  * It should be noted that PCWD_REVISION_B was removed because A and B
@@ -83,26 +83,9 @@ static int pcwd_ioports[] = { 0x270, 0x3
 #define	PCWD_REVISION_A		1
 #define	PCWD_REVISION_C		2
 
-#define	WD_TIMEOUT		4	/* 2 seconds for a timeout */
-static int timeout_val = WD_TIMEOUT;
-static int timeout = 2;
-static char expect_close;
-
-module_param(timeout, int, 0);
-MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds (default=2)");
-
-#ifdef CONFIG_WATCHDOG_NOWAYOUT
-static int nowayout = 1;
-#else
-static int nowayout = 0;
-#endif
-
-module_param(nowayout, int, 0);
-MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=CONFIG_WATCHDOG_NOWAYOUT)");
-
-
 /*
- * These are the defines for the PC Watchdog card, revision A.
+ * These are the defines that describe the control status bits for the
+ * PC Watchdog card, revision A.
  */
 #define WD_WDRST                0x01	/* Previously reset state */
 #define WD_T110                 0x02	/* Temperature overheat sense */
@@ -110,120 +93,161 @@ MODULE_PARM_DESC(nowayout, "Watchdog can
 #define WD_RLY2                 0x08	/* External relay triggered */
 #define WD_SRLY2                0x80	/* Software external relay triggered */
 
-static int current_readport, revision, temp_panic;
-static atomic_t open_allowed = ATOMIC_INIT(1);
-static int initial_status, supports_temp, mode_debug;
-static spinlock_t io_lock;
+/*
+ * These are the defines that describe the control status bits for the
+ * PC Watchdog card, revision C.
+ */
+#define WD_REVC_WTRP            0x01	/* Watchdog Trip status */
+#define WD_REVC_HRBT            0x02	/* Watchdog Heartbeat */
+#define WD_REVC_TTRP            0x04	/* Temperature Trip status */
+
+/* max. time we give an ISA watchdog card to process a command */
+/* 500ms for each 4 bit response (according to spec.) */
+#define ISA_COMMAND_TIMEOUT     1000
+
+/* Watchdog's internal commands */
+#define CMD_ISA_IDLE                    0x00
+#define CMD_ISA_VERSION_INTEGER         0x01
+#define CMD_ISA_VERSION_TENTH           0x02
+#define CMD_ISA_VERSION_HUNDRETH        0x03
+#define CMD_ISA_VERSION_MINOR           0x04
+#define CMD_ISA_SWITCH_SETTINGS         0x05
+#define CMD_ISA_DELAY_TIME_2SECS        0x0A
+#define CMD_ISA_DELAY_TIME_4SECS        0x0B
+#define CMD_ISA_DELAY_TIME_8SECS        0x0C
 
 /*
- * PCWD_CHECKCARD
- *
- * This routine checks the "current_readport" to see if the card lies there.
- * If it does, it returns accordingly.
+ * We are using an kernel timer to do the pinging of the watchdog
+ * every ~500ms. We try to set the internal heartbeat of the
+ * watchdog to 2 ms.
  */
-static int __init pcwd_checkcard(void)
-{
-	int card_dat, prev_card_dat, found = 0, count = 0, done = 0;
 
-	card_dat = 0x00;
-	prev_card_dat = 0x00;
+#define WDT_INTERVAL (HZ/2+1)
 
-	prev_card_dat = inb(current_readport);
-	if (prev_card_dat == 0xFF)
-		return 0;
+/* We can only use 1 card due to the /dev/watchdog restriction */
+static int cards_found;
 
-	while(count < timeout_val) {
+/* internal variables */
+static atomic_t open_allowed = ATOMIC_INIT(1);
+static char expect_close;
+static struct timer_list timer;
+static unsigned long next_heartbeat;
+static int temp_panic;
+static int revision;			/* The card's revision */
+static int supports_temp;		/* Wether or not the card has a temperature device */
+static int command_mode;		/* Wether or not the card is in command mode */
+static int initial_status;		/* The card's boot status */
+static int current_readport;		/* The cards I/O address */
+static spinlock_t io_lock;
 
-	/* Read the raw card data from the port, and strip off the
-	   first 4 bits */
+/* module parameters */
+#define WATCHDOG_HEARTBEAT 60		/* 60 sec default heartbeat */
+static int heartbeat = WATCHDOG_HEARTBEAT;
+module_param(heartbeat, int, 0);
+MODULE_PARM_DESC(heartbeat, "Watchdog heartbeat in seconds. (2<=heartbeat<=7200, default=" __MODULE_STRING(WATCHDOG_HEARTBEAT) ")");
 
-		card_dat = inb_p(current_readport);
-		card_dat &= 0x000F;
+#ifdef CONFIG_WATCHDOG_NOWAYOUT
+static int nowayout = 1;
+#else
+static int nowayout = 0;
+#endif
 
-	/* Sleep 1/2 second (or 500000 microseconds :) */
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=CONFIG_WATCHDOG_NOWAYOUT)");
 
-		mdelay(500);
-		done = 0;
+/*
+ *	Internal functions
+ */
 
-	/* If there's a heart beat in both instances, then this means we
-	   found our card.  This also means that either the card was
-	   previously reset, or the computer was power-cycled. */
+static int send_isa_command(int cmd)
+{
+	int i;
+	int control_status;
+	int port0, last_port0;	/* Double read for stabilising */
 
-		if ((card_dat & WD_HRTBT) && (prev_card_dat & WD_HRTBT) &&
-			(!done)) {
-			found = 1;
-			done = 1;
-			break;
-		}
+	/* The WCMD bit must be 1 and the command is only 4 bits in size */
+	control_status = (cmd & 0x0F) | 0x80;
+	outb_p(control_status, current_readport + 2);
+	udelay(ISA_COMMAND_TIMEOUT);
 
-	/* If the card data is exactly the same as the previous card data,
-	   it's safe to assume that we should check again.  The manual says
-	   that the heart beat will change every second (or the bit will
-	   toggle), and this can be used to see if the card is there.  If
-	   the card was powered up with a cold boot, then the card will
-	   not start blinking until 2.5 minutes after a reboot, so this
-	   bit will stay at 1. */
+	port0 = inb_p(current_readport);
+	for (i = 0; i < 25; ++i) {
+		last_port0 = port0;
+		port0 = inb_p(current_readport);
 
-		if ((card_dat == prev_card_dat) && (!done)) {
-			count++;
-			done = 1;
-		}
+		if (port0 == last_port0)
+			break;	/* Data is stable */
 
-	/* If the card data is toggling any bits, this means that the heart
-	   beat was detected, or something else about the card is set. */
+		udelay (250);
+	}
 
-		if ((card_dat != prev_card_dat) && (!done)) {
-			done = 1;
-			found = 1;
-			break;
-		}
+	return port0;
+}
 
-	/* Otherwise something else strange happened. */
+static int set_command_mode(void)
+{
+	int i, found=0, count=0;
+
+	/* Set the card into command mode */
+	spin_lock(&io_lock);
+	while ((!found) && (count < 3)) {
+		i = send_isa_command(CMD_ISA_IDLE);
 
-		if (!done)
-			count++;
+		if (i == 0x00)
+			found = 1;
+		else if (i == 0xF3) {
+			/* Card does not like what we've done to it */
+			outb_p(0x00, current_readport + 2);
+			udelay(1200);	/* Spec says wait 1ms */
+			outb_p(0x00, current_readport + 2);
+			udelay(ISA_COMMAND_TIMEOUT);
+		}
+		count++;
 	}
+	spin_unlock(&io_lock);
+	command_mode = found;
 
-	return((found) ? 1 : 0);
+	return(found);
 }
 
-void pcwd_showprevstate(void)
+static void unset_command_mode(void)
 {
-	int card_status = 0x0000;
+	/* Set the card into normal mode */
+	spin_lock(&io_lock);
+	outb_p(0x00, current_readport + 2);
+	udelay(ISA_COMMAND_TIMEOUT);
+	spin_unlock(&io_lock);
 
-	if (revision == PCWD_REVISION_A)
-		initial_status = card_status = inb(current_readport);
-	else {
-		initial_status = card_status = inb(current_readport + 1);
-		outb_p(0x00, current_readport + 1); /* clear reset status */
-	}
+	command_mode = 0;
+}
 
-	if (revision == PCWD_REVISION_A) {
-		if (card_status & WD_WDRST)
-			printk(KERN_INFO "pcwd: Previous reboot was caused by the card.\n");
+static void pcwd_timer_ping(unsigned long data)
+{
+	int wdrst_stat;
 
-		if (card_status & WD_T110) {
-			printk(KERN_EMERG "pcwd: Card senses a CPU Overheat.  Panicking!\n");
-			printk(KERN_EMERG "pcwd: CPU Overheat.\n");
-			machine_power_off();
+	/* If we got a heartbeat pulse within the WDT_INTERVAL
+	 * we agree to ping the WDT */
+	if(time_before(jiffies, next_heartbeat)) {
+		/* Ping the watchdog */
+		spin_lock(&io_lock);
+		if (revision == PCWD_REVISION_A) {
+			/*  Rev A cards are reset by setting the WD_WDRST bit in register 1 */
+			wdrst_stat = inb_p(current_readport);
+			wdrst_stat &= 0x0F;
+			wdrst_stat |= WD_WDRST;
+
+			outb_p(wdrst_stat, current_readport + 1);
+		} else {
+			/* Re-trigger watchdog by writing to port 0 */
+			outb_p(0x00, current_readport);
 		}
 
-		if ((!(card_status & WD_WDRST)) &&
-		    (!(card_status & WD_T110)))
-			printk(KERN_INFO "pcwd: Cold boot sense.\n");
-	} else {
-		if (card_status & 0x01)
-			printk(KERN_INFO "pcwd: Previous reboot was caused by the card.\n");
-
-		if (card_status & 0x04) {
-			printk(KERN_EMERG "pcwd: Card senses a CPU Overheat.  Panicking!\n");
-			printk(KERN_EMERG "pcwd: CPU Overheat.\n");
-			machine_power_off();
-		}
+		/* Re-set the timer interval */
+		mod_timer(&timer, jiffies + WDT_INTERVAL);
 
-		if ((!(card_status & 0x01)) &&
-		    (!(card_status & 0x04)))
-			printk(KERN_INFO "pcwd: Cold boot sense.\n");
+		spin_unlock(&io_lock);
+	} else {
+		printk(KERN_WARNING PFX "Heartbeat lost! Will not ping the watchdog\n");
 	}
 }
 
@@ -231,15 +255,20 @@ static int pcwd_start(void)
 {
 	int stat_reg;
 
-	/*  Enable the port  */
+	next_heartbeat = jiffies + (heartbeat * HZ);
+
+	/* Start the timer */
+	mod_timer(&timer, jiffies + WDT_INTERVAL);
+
+	/* Enable the port */
 	if (revision == PCWD_REVISION_C) {
 		spin_lock(&io_lock);
 		outb_p(0x00, current_readport + 3);
+		udelay(ISA_COMMAND_TIMEOUT);
 		stat_reg = inb_p(current_readport + 2);
 		spin_unlock(&io_lock);
-		if (stat_reg & 0x10)
-		{
-			printk(KERN_INFO "pcwd: Could not start watchdog.\n");
+		if (stat_reg & 0x10) {
+			printk(KERN_INFO PFX "Could not start watchdog\n");
 			return -EIO;
 		}
 	}
@@ -250,41 +279,103 @@ static int pcwd_stop(void)
 {
 	int stat_reg;
 
+	/* Stop the timer */
+	del_timer(&timer);
+
 	/*  Disable the board  */
 	if (revision == PCWD_REVISION_C) {
 		spin_lock(&io_lock);
 		outb_p(0xA5, current_readport + 3);
+		udelay(ISA_COMMAND_TIMEOUT);
 		outb_p(0xA5, current_readport + 3);
+		udelay(ISA_COMMAND_TIMEOUT);
 		stat_reg = inb_p(current_readport + 2);
 		spin_unlock(&io_lock);
-		if ((stat_reg & 0x10) == 0)
-		{
-			printk(KERN_INFO "pcwd: Could not stop watchdog.\n");
+		if ((stat_reg & 0x10) == 0) {
+			printk(KERN_INFO PFX "Could not stop watchdog\n");
 			return -EIO;
 		}
 	}
 	return 0;
 }
 
-static void pcwd_send_heartbeat(void)
+static void pcwd_keepalive(void)
 {
-	int wdrst_stat;
+	/* user land ping */
+	next_heartbeat = jiffies + (heartbeat * HZ);
+}
 
-	wdrst_stat = inb_p(current_readport);
-	wdrst_stat &= 0x0F;
+static int pcwd_set_heartbeat(int t)
+{
+	if ((t < 2) || (t > 7200)) /* arbitrary upper limit */
+		return -EINVAL;
 
-	wdrst_stat |= WD_WDRST;
+	heartbeat = t;
+	return 0;
+}
 
+static int pcwd_get_status(int *status)
+{
+	int card_status;
+
+	*status=0;
+	spin_lock(&io_lock);
 	if (revision == PCWD_REVISION_A)
-		outb_p(wdrst_stat, current_readport + 1);
-	else
-		outb_p(wdrst_stat, current_readport);
+		/* Rev A cards return status information from
+		 * the base register, which is used for the
+		 * temperature in other cards. */
+		card_status = inb(current_readport);
+	else {
+		/* Rev C cards return card status in the base
+		 * address + 1 register. And use different bits
+		 * to indicate a card initiated reset, and an
+		 * over-temperature condition. And the reboot
+		 * status can be reset. */
+		card_status = inb(current_readport + 1);
+	}
+	spin_unlock(&io_lock);
+
+	if (revision == PCWD_REVISION_A) {
+		if (card_status & WD_WDRST)
+			*status |= WDIOF_CARDRESET;
+
+		if (card_status & WD_T110) {
+			*status |= WDIOF_OVERHEAT;
+			if (temp_panic) {
+				printk (KERN_INFO PFX "Temperature overheat trip!\n");
+				machine_power_off();
+			}
+		}
+	} else {
+		if (card_status & WD_REVC_WTRP)
+			*status |= WDIOF_CARDRESET;
+
+		if (card_status & WD_REVC_TTRP) {
+			*status |= WDIOF_OVERHEAT;
+			if (temp_panic) {
+				printk (KERN_INFO PFX "Temperature overheat trip!\n");
+				machine_power_off();
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int pcwd_clear_status(void)
+{
+	if (revision == PCWD_REVISION_C) {
+		spin_lock(&io_lock);
+		outb_p(0x00, current_readport + 1); /* clear reset status */
+		spin_unlock(&io_lock);
+	}
+	return 0;
 }
 
 static int pcwd_get_temperature(int *temperature)
 {
 	/* check that port 0 gives temperature info and no command results */
-	if (mode_debug)
+	if (command_mode)
 		return -1;
 
 	*temperature = 0;
@@ -309,12 +400,15 @@ static int pcwd_get_temperature(int *tem
 static int pcwd_ioctl(struct inode *inode, struct file *file,
 		      unsigned int cmd, unsigned long arg)
 {
-	int cdat, rv;
+	int rv;
+	int status;
 	int temperature;
-	static struct watchdog_info ident=
-	{
+	int new_heartbeat;
+	static struct watchdog_info ident = {
 		.options =		WDIOF_OVERHEAT |
 					WDIOF_CARDRESET |
+					WDIOF_KEEPALIVEPING |
+					WDIOF_SETTIMEOUT |
 					WDIOF_MAGICCLOSE,
 		.firmware_version =	1,
 		.identity =		"PCWD",
@@ -330,75 +424,13 @@ static int pcwd_ioctl(struct inode *inod
 		return 0;
 
 	case WDIOC_GETSTATUS:
-		spin_lock(&io_lock);
-		if (revision == PCWD_REVISION_A)
-			cdat = inb(current_readport);
-		else
-			cdat = inb(current_readport + 1 );
-		spin_unlock(&io_lock);
-		rv = WDIOF_MAGICCLOSE;
-
-		if (revision == PCWD_REVISION_A)
-		{
-			if (cdat & WD_WDRST)
-				rv |= WDIOF_CARDRESET;
-
-			if (cdat & WD_T110)
-			{
-				rv |= WDIOF_OVERHEAT;
-
-				if (temp_panic) {
-					printk (KERN_INFO "pcwd: Temperature overheat trip!\n");
-					machine_power_off();
-				}
-			}
-		}
-		else
-		{
-			if (cdat & 0x01)
-				rv |= WDIOF_CARDRESET;
-
-			if (cdat & 0x04)
-			{
-				rv |= WDIOF_OVERHEAT;
-
-				if (temp_panic) {
-					printk (KERN_INFO "pcwd: Temperature overheat trip!\n");
-					machine_power_off();
-				}
-			}
-		}
-
-		if(put_user(rv, (int *) arg))
-			return -EFAULT;
-		return 0;
+		pcwd_get_status(&status);
+		return put_user(status, (int *) arg);
 
 	case WDIOC_GETBOOTSTATUS:
-		rv = 0;
-
-		if (revision == PCWD_REVISION_A)
-		{
-			if (initial_status & WD_WDRST)
-				rv |= WDIOF_CARDRESET;
-
-			if (initial_status & WD_T110)
-				rv |= WDIOF_OVERHEAT;
-		}
-		else
-		{
-			if (initial_status & 0x01)
-				rv |= WDIOF_CARDRESET;
-
-			if (initial_status & 0x04)
-				rv |= WDIOF_OVERHEAT;
-		}
-
-		if(put_user(rv, (int *) arg))
-			return -EFAULT;
-		return 0;
+		return put_user(initial_status, (int *) arg);
 
 	case WDIOC_GETTEMP:
-
 		if (pcwd_get_temperature(&temperature))
 			return -EFAULT;
 
@@ -428,8 +460,21 @@ static int pcwd_ioctl(struct inode *inod
 		return -EINVAL;
 
 	case WDIOC_KEEPALIVE:
-		pcwd_send_heartbeat();
+		pcwd_keepalive();
 		return 0;
+
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_heartbeat, (int *) arg))
+			return -EFAULT;
+
+		if (pcwd_set_heartbeat(new_heartbeat))
+			return -EINVAL;
+
+		pcwd_keepalive();
+		/* Fall */
+
+	case WDIOC_GETTIMEOUT:
+		return put_user(heartbeat, (int *)arg);
 	}
 
 	return 0;
@@ -458,7 +503,7 @@ static ssize_t pcwd_write(struct file *f
 					expect_close = 42;
 			}
 		}
-		pcwd_send_heartbeat();
+		pcwd_keepalive();
 	}
 	return len;
 }
@@ -475,6 +520,7 @@ static int pcwd_open(struct inode *inode
 
 	/* Activate */
 	pcwd_start();
+	pcwd_keepalive();
 	return(0);
 }
 
@@ -483,9 +529,9 @@ static int pcwd_close(struct inode *inod
 	if (expect_close == 42) {
 		pcwd_stop();
 		atomic_inc( &open_allowed );
-        } else {
-                printk(KERN_CRIT "pcwd: Unexpected close, not stopping watchdog!\n");
-                pcwd_send_heartbeat();
+	} else {
+		printk(KERN_CRIT PFX "Unexpected close, not stopping watchdog!\n");
+		pcwd_keepalive();
 	}
 	expect_close = 0;
 	return 0;
@@ -500,7 +546,7 @@ static ssize_t pcwd_temp_read(struct fil
 {
 	int temperature;
 
-	/*  Can't seek (pread) on this device  */
+	/* Can't seek (pread) on this device */
 	if (ppos != &file->f_pos)
 		return -ESPIPE;
 
@@ -526,6 +572,61 @@ static int pcwd_temp_close(struct inode 
 	return 0;
 }
 
+/*
+ *	Notify system
+ */
+
+static int pcwd_notify_sys(struct notifier_block *this, unsigned long code, void *unused)
+{
+	if (code==SYS_DOWN || code==SYS_HALT) {
+		/* Turn the WDT off */
+		pcwd_stop();
+	}
+
+	return NOTIFY_DONE;
+}
+
+/*
+ *	Kernel Interfaces
+ */
+
+static struct file_operations pcwd_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= pcwd_write,
+	.ioctl		= pcwd_ioctl,
+	.open		= pcwd_open,
+	.release	= pcwd_close,
+};
+
+static struct miscdevice pcwd_miscdev = {
+	.minor =	WATCHDOG_MINOR,
+	.name =		"watchdog",
+	.fops =		&pcwd_fops,
+};
+
+static struct file_operations pcwd_temp_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= pcwd_temp_read,
+	.open		= pcwd_temp_open,
+	.release	= pcwd_temp_close,
+};
+
+static struct miscdevice temp_miscdev = {
+	.minor =	TEMP_MINOR,
+	.name =		"temperature",
+	.fops =		&pcwd_temp_fops,
+};
+
+static struct notifier_block pcwd_notifier = {
+	.notifier_call =	pcwd_notify_sys,
+};
+
+/*
+ *	Init & exit routines
+ */
+
 static inline void get_support(void)
 {
 	if (inb(current_readport) != 0xF0)
@@ -537,6 +638,8 @@ static inline int get_revision(void)
 	int r = PCWD_REVISION_C;
 
 	spin_lock(&io_lock);
+	/* REV A cards use only 2 io ports; test
+	 * presumes a floating bus reads as 0xff. */
 	if ((inb(current_readport + 2) == 0xFF) ||
 	    (inb(current_readport + 3) == 0xFF))
 		r=PCWD_REVISION_A;
@@ -545,207 +648,283 @@ static inline int get_revision(void)
 	return r;
 }
 
-static int __init send_command(int cmd)
-{
-	int i;
-
-	outb_p(cmd, current_readport + 2);
-	mdelay(1);
-
-	i = inb(current_readport);
-	i = inb(current_readport);
-
-	return(i);
-}
-
 static inline char *get_firmware(void)
 {
-	int i, found = 0, count = 0, one, ten, hund, minor;
+	int one, ten, hund, minor;
 	char *ret;
 
 	ret = kmalloc(6, GFP_KERNEL);
 	if(ret == NULL)
 		return NULL;
 
-	while((count < 3) && (!found)) {
-		outb_p(0x80, current_readport + 2);
-		i = inb(current_readport);
-
-		if (i == 0x00)
-			found = 1;
-		else if (i == 0xF3)
-			outb_p(0x00, current_readport + 2);
-
-		udelay(400L);
-		count++;
-	}
-
-	if (found) {
-		mode_debug = 1;
-
-		one = send_command(0x81);
-		ten = send_command(0x82);
-		hund = send_command(0x83);
-		minor = send_command(0x84);
+	if (set_command_mode()) {
+		one = send_isa_command(CMD_ISA_VERSION_INTEGER);
+		ten = send_isa_command(CMD_ISA_VERSION_TENTH);
+		hund = send_isa_command(CMD_ISA_VERSION_HUNDRETH);
+		minor = send_isa_command(CMD_ISA_VERSION_MINOR);
 		sprintf(ret, "%c.%c%c%c", one, ten, hund, minor);
 	}
 	else
 		sprintf(ret, "ERROR");
 
+	unset_command_mode();
 	return(ret);
 }
 
-static void debug_off(void)
+static inline int get_option_switches(void)
 {
-	outb_p(0x00, current_readport + 2);
-	mode_debug = 0;
-}
-
-static struct file_operations pcwd_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.write		= pcwd_write,
-	.ioctl		= pcwd_ioctl,
-	.open		= pcwd_open,
-	.release	= pcwd_close,
-};
-
-static struct miscdevice pcwd_miscdev = {
-	.minor =	WATCHDOG_MINOR,
-	.name =		"watchdog",
-	.fops =		&pcwd_fops,
-};
+	int rv=0;
 
-static struct file_operations pcwd_temp_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= pcwd_temp_read,
-	.open		= pcwd_temp_open,
-	.release	= pcwd_temp_close,
-};
-
-static struct miscdevice temp_miscdev = {
-	.minor =	TEMP_MINOR,
-	.name =		"temperature",
-	.fops =		&pcwd_temp_fops,
-};
+	if (set_command_mode()) {
+		/* Get switch settings */
+		rv = send_isa_command(CMD_ISA_SWITCH_SETTINGS);
+	}
 
-static void __init pcwd_validate_timeout(void)
-{
-	timeout_val = timeout * 2;
+	unset_command_mode();
+	return(rv);
 }
 
-static int __init pcwatchdog_init(void)
+static int __devinit pcwatchdog_init(int base_addr)
 {
+	int ret;
 	char *firmware;
-	int i, found = 0;
-	pcwd_validate_timeout();
-	spin_lock_init(&io_lock);
+	int option_switches;
+
+	cards_found++;
+	if (cards_found == 1)
+		printk(KERN_INFO PFX "v%s Ken Hollis (kenji@bitgate.com)\n", WD_VER);
+
+	if (cards_found > 1) {
+		printk(KERN_ERR PFX "This driver only supports 1 device\n");
+		return -ENODEV;
+	}
+
+	if (base_addr == 0x0000) {
+		printk(KERN_ERR PFX "No I/O-Address for card detected\n");
+		return -ENODEV;
+	}
+	current_readport = base_addr;
 
-	revision = PCWD_REVISION_A;
+	/* Check card's revision */
+	revision = get_revision();
 
-	printk(KERN_INFO "pcwd: v%s Ken Hollis (kenji@bitgate.com)\n", WD_VER);
+	if (!request_region(current_readport, (revision == PCWD_REVISION_A) ? 2 : 4, "PCWD")) {
+		printk(KERN_ERR PFX "I/O address 0x%04x already in use\n",
+			current_readport);
+		current_readport = 0x0000;
+		return -EIO;
+	}
 
 	/* Initial variables */
 	supports_temp = 0;
-	mode_debug = 0;
 	temp_panic = 0;
 	initial_status = 0x0000;
 
-#ifndef	PCWD_BLIND
-	for (i = 0; pcwd_ioports[i] != 0; i++) {
-		current_readport = pcwd_ioports[i];
+	/* get the boot_status */
+	pcwd_get_status(&initial_status);
 
-		if (pcwd_checkcard()) {
-			found = 1;
-			break;
-		}
-	}
+	/* clear the "card caused reboot" flag */
+	pcwd_clear_status();
 
-	if (!found) {
-		printk(KERN_INFO "pcwd: No card detected, or port not available.\n");
-		return(-EIO);
-	}
-#endif
+	init_timer(&timer);
+	timer.function = pcwd_timer_ping;
+	timer.data = 0;
 
-#ifdef	PCWD_BLIND
-	current_readport = PCWD_BLIND;
-#endif
+	/*  Disable the board  */
+	pcwd_stop();
 
+	/*  Check whether or not the card supports the temperature device */
 	get_support();
-	revision = get_revision();
 
+	/* Get some extra info from the hardware (in command/debug/diag mode) */
 	if (revision == PCWD_REVISION_A)
-		printk(KERN_INFO "pcwd: PC Watchdog (REV.A) detected at port 0x%03x\n", current_readport);
+		printk(KERN_INFO PFX "ISA-PC Watchdog (REV.A) detected at port 0x%04x\n", current_readport);
 	else if (revision == PCWD_REVISION_C) {
 		firmware = get_firmware();
-		printk(KERN_INFO "pcwd: PC Watchdog (REV.C) detected at port 0x%03x (Firmware version: %s)\n",
+		printk(KERN_INFO PFX "ISA-PC Watchdog (REV.C) detected at port 0x%04x (Firmware version: %s)\n",
 			current_readport, firmware);
 		kfree(firmware);
+		option_switches = get_option_switches();
+		printk(KERN_INFO PFX "Option switches (0x%02x): Temperature Reset Enable=%s, Power On Delay=%s\n",
+			option_switches,
+			((option_switches & 0x10) ? "ON" : "OFF"),
+			((option_switches & 0x08) ? "ON" : "OFF"));
+
+		/* Reprogram internal heartbeat to 2 seconds */
+		if (set_command_mode()) {
+			send_isa_command(CMD_ISA_DELAY_TIME_2SECS);
+			unset_command_mode();
+		}
 	} else {
 		/* Should NEVER happen, unless get_revision() fails. */
-		printk("pcwd: Unable to get revision.\n");
+		printk(KERN_INFO PFX "Unable to get revision\n");
+		release_region(current_readport, (revision == PCWD_REVISION_A) ? 2 : 4);
+		current_readport = 0x0000;
 		return -1;
 	}
 
 	if (supports_temp)
-		printk(KERN_INFO "pcwd: Temperature Option Detected.\n");
+		printk(KERN_INFO PFX "Temperature Option Detected\n");
 
-	debug_off();
+	if (initial_status & WDIOF_CARDRESET)
+		printk(KERN_INFO PFX "Previous reboot was caused by the card\n");
 
-	pcwd_showprevstate();
-
-	/*  Disable the board  */
-	if (revision == PCWD_REVISION_C) {
-		outb_p(0xA5, current_readport + 3);
-		outb_p(0xA5, current_readport + 3);
+	if (initial_status & WDIOF_OVERHEAT) {
+		printk(KERN_EMERG PFX "Card senses a CPU Overheat. Panicking!\n");
+		printk(KERN_EMERG PFX "CPU Overheat\n");
 	}
 
-	if (misc_register(&pcwd_miscdev))
-		return -ENODEV;
+	if (initial_status == 0)
+		printk(KERN_INFO PFX "No previous trip detected - Cold boot or reset\n");
 
-	if (supports_temp)
-		if (misc_register(&temp_miscdev)) {
-			misc_deregister(&pcwd_miscdev);
-			return -ENODEV;
-		}
+	/* Check that the heartbeat value is within it's range ; if not reset to the default */
+        if (pcwd_set_heartbeat(heartbeat)) {
+                pcwd_set_heartbeat(WATCHDOG_HEARTBEAT);
+                printk(KERN_INFO PFX "heartbeat value must be 2<=heartbeat<=7200, using %d\n",
+                        WATCHDOG_HEARTBEAT);
+	}
 
+	ret = register_reboot_notifier(&pcwd_notifier);
+	if (ret) {
+		printk(KERN_ERR PFX "cannot register reboot notifier (err=%d)\n",
+			ret);
+		release_region(current_readport, (revision == PCWD_REVISION_A) ? 2 : 4);
+		current_readport = 0x0000;
+		return ret;
+	}
 
-	if (revision == PCWD_REVISION_A) {
-		if (!request_region(current_readport, 2, "PCWD Rev.A (Berkshire)")) {
-			misc_deregister(&pcwd_miscdev);
-			if (supports_temp)
-				misc_deregister(&pcwd_miscdev);
-			return -EIO;
+	if (supports_temp) {
+		ret = misc_register(&temp_miscdev);
+		if (ret) {
+			printk(KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+				TEMP_MINOR, ret);
+			unregister_reboot_notifier(&pcwd_notifier);
+			release_region(current_readport, (revision == PCWD_REVISION_A) ? 2 : 4);
+			current_readport = 0x0000;
+			return ret;
 		}
 	}
-	else
-		if (!request_region(current_readport, 4, "PCWD Rev.C (Berkshire)")) {
-			misc_deregister(&pcwd_miscdev);
-			if (supports_temp)
-				misc_deregister(&pcwd_miscdev);
-			return -EIO;
-		}
+
+	ret = misc_register(&pcwd_miscdev);
+	if (ret) {
+		printk(KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+			WATCHDOG_MINOR, ret);
+		if (supports_temp)
+			misc_deregister(&temp_miscdev);
+		unregister_reboot_notifier(&pcwd_notifier);
+		release_region(current_readport, (revision == PCWD_REVISION_A) ? 2 : 4);
+		current_readport = 0x0000;
+		return ret;
+	}
+
+	printk(KERN_INFO PFX "initialized. heartbeat=%d sec (nowayout=%d)\n",
+		heartbeat, nowayout);
 
 	return 0;
 }
 
-static void __exit pcwatchdog_exit(void)
+static void __devexit pcwatchdog_exit(void)
 {
-	misc_deregister(&pcwd_miscdev);
 	/*  Disable the board  */
-	if (revision == PCWD_REVISION_C) {
-		outb_p(0xA5, current_readport + 3);
-		outb_p(0xA5, current_readport + 3);
-	}
+	if (!nowayout)
+		pcwd_stop();
+
+	/* Deregister */
+	misc_deregister(&pcwd_miscdev);
 	if (supports_temp)
 		misc_deregister(&temp_miscdev);
-
+	unregister_reboot_notifier(&pcwd_notifier);
 	release_region(current_readport, (revision == PCWD_REVISION_A) ? 2 : 4);
+	current_readport = 0x0000;
+}
+
+/*
+ *  The ISA cards have a heartbeat bit in one of the registers, which
+ *  register is card dependent.  The heartbeat bit is monitored, and if
+ *  found, is considered proof that a Berkshire card has been found.
+ *  The initial rate is once per second at board start up, then twice
+ *  per second for normal operation.
+ */
+static int __init pcwd_checkcard(int base_addr)
+{
+	int port0, last_port0;	/* Reg 0, in case it's REV A */
+	int port1, last_port1;	/* Register 1 for REV C cards */
+	int i;
+	int retval;
+
+	if (!request_region (base_addr, 4, "PCWD")) {
+		printk (KERN_INFO PFX "Port 0x%04x unavailable\n", base_addr);
+		return 0;
+	}
+
+	retval = 0;
+
+	port0 = inb_p(base_addr);	/* For REV A boards */
+	port1 = inb_p(base_addr + 1);	/* For REV C boards */
+	if (port0 != 0xff || port1 != 0xff) {
+		/* Not an 'ff' from a floating bus, so must be a card! */
+		for (i = 0; i < 4; ++i) {
+
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ / 2);
+
+			last_port0 = port0;
+			last_port1 = port1;
+
+			port0 = inb_p(base_addr);
+			port1 = inb_p(base_addr + 1);
+
+			/* Has either hearbeat bit changed?  */
+			if ((port0 ^ last_port0) & WD_HRTBT ||
+			    (port1 ^ last_port1) & WD_REVC_HRBT) {
+				retval = 1;
+				break;
+			}
+		}
+	}
+	release_region (base_addr, 4);
+
+	return retval;
+}
+
+/*
+ * These are the auto-probe addresses available.
+ *
+ * Revision A only uses ports 0x270 and 0x370.  Revision C introduced 0x350.
+ * Revision A has an address range of 2 addresses, while Revision C has 4.
+ */
+static int pcwd_ioports[] = { 0x270, 0x350, 0x370, 0x000 };
+
+static int __init pcwd_init_module(void)
+{
+	int i, found = 0;
+
+	spin_lock_init(&io_lock);
+
+	for (i = 0; pcwd_ioports[i] != 0; i++) {
+		if (pcwd_checkcard(pcwd_ioports[i])) {
+			if (!(pcwatchdog_init(pcwd_ioports[i])))
+				found++;
+		}
+	}
+
+	if (!found) {
+		printk (KERN_INFO PFX "No card detected, or port not available\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit pcwd_cleanup_module(void)
+{
+	if (current_readport)
+		pcwatchdog_exit();
+	return;
 }
 
-module_init(pcwatchdog_init);
-module_exit(pcwatchdog_exit);
+module_init(pcwd_init_module);
+module_exit(pcwd_cleanup_module);
 
 MODULE_AUTHOR("Ken Hollis <kenji@bitgate.com>");
 MODULE_DESCRIPTION("Berkshire ISA-PC Watchdog driver");
diff -purN linux-post-2.6.5-rc2-20040329/drivers/isdn/capi/capi.c linux-2.6.5-rc3/drivers/isdn/capi/capi.c
--- linux-post-2.6.5-rc2-20040329/drivers/isdn/capi/capi.c	2004-02-19 03:42:12.000000000 +0000
+++ linux-2.6.5-rc3/drivers/isdn/capi/capi.c	2004-03-29 14:25:54.000000000 +0000
@@ -1,4 +1,4 @@
-/* $Id: capi.c,v 1.1.2.3 2004/01/16 21:09:26 keil Exp $
+/* $Id: capi.c,v 1.1.2.4 2004/03/29 10:38:02 armin Exp $
  *
  * CAPI 2.0 Interface for Linux
  *
@@ -44,7 +44,7 @@
 #include "capifs.h"
 #endif
 
-static char *revision = "$Revision: 1.1.2.3 $";
+static char *revision = "$Revision: 1.1.2.4 $";
 
 MODULE_DESCRIPTION("CAPI4Linux: Userspace /dev/capi20 interface");
 MODULE_AUTHOR("Carsten Paeth");
@@ -200,7 +200,6 @@ static void capiminor_del_all_ack(struct
 static struct capiminor *capiminor_alloc(struct capi20_appl *ap, u32 ncci)
 {
 	struct capiminor *mp, *p;
-	struct list_head *l;
 	unsigned int minor = 0;
 	unsigned long flags;
 
@@ -219,26 +218,31 @@ static struct capiminor *capiminor_alloc
 	skb_queue_head_init(&mp->inqueue);
 	skb_queue_head_init(&mp->outqueue);
 
+	/* Allocate the least unused minor number.
+	 */
 	write_lock_irqsave(&capiminor_list_lock, flags);
-	if (list_empty(&capiminor_list)) {
+	if (list_empty(&capiminor_list))
 		list_add(&mp->list, &capiminor_list);
-		write_unlock_irqrestore(&capiminor_list_lock, flags);
-	} else {
-		list_for_each(l, &capiminor_list) {
-			p = list_entry(l, struct capiminor, list);
-			if (p->minor > minor) {
-				mp->minor = minor;
-				list_add_tail(&mp->list, &p->list);
+	else {
+		list_for_each_entry(p, &capiminor_list, list) {
+			if (p->minor > minor)
 				break;
-			}
 			minor++;
 		}
+		
+		if (minor < capi_ttyminors) {
+			mp->minor = minor;
+			list_add(&mp->list, p->list.prev);
+		}
+	}
 		write_unlock_irqrestore(&capiminor_list_lock, flags);
-		if (l == &capiminor_list) {
+
+	if (!(minor < capi_ttyminors)) {
+		printk(KERN_NOTICE "capi: out of minors\n");
 			kfree(mp);
-			return NULL;
-		}
+		return 0;
 	}
+
 	return mp;
 }
 
diff -purN linux-post-2.6.5-rc2-20040329/drivers/md/md.c linux-2.6.5-rc3/drivers/md/md.c
--- linux-post-2.6.5-rc2-20040329/drivers/md/md.c	2004-03-14 01:57:41.000000000 +0000
+++ linux-2.6.5-rc3/drivers/md/md.c	2004-03-29 13:38:06.000000000 +0000
@@ -3178,13 +3178,14 @@ DECLARE_WAIT_QUEUE_HEAD(resync_wait);
 static void md_do_sync(mddev_t *mddev)
 {
 	mddev_t *mddev2;
-	unsigned int max_sectors, currspeed = 0,
-		j, window;
+	unsigned int currspeed = 0,
+		 window;
+	sector_t max_sectors,j;
 	unsigned long mark[SYNC_MARKS];
-	unsigned long mark_cnt[SYNC_MARKS];
+	sector_t mark_cnt[SYNC_MARKS];
 	int last_mark,m;
 	struct list_head *tmp;
-	unsigned long last_check;
+	sector_t last_check;
 
 	/* just incase thread restarts... */
 	if (test_bit(MD_RECOVERY_DONE, &mddev->recovery))
@@ -3253,8 +3254,8 @@ static void md_do_sync(mddev_t *mddev)
 	 * Tune reconstruction:
 	 */
 	window = 32*(PAGE_SIZE/512);
-	printk(KERN_INFO "md: using %dk window, over a total of %d blocks.\n",
-		window/2,max_sectors/2);
+	printk(KERN_INFO "md: using %dk window, over a total of %Lu blocks.\n",
+		window/2,(unsigned long long) max_sectors/2);
 
 	atomic_set(&mddev->recovery_active, 0);
 	init_waitqueue_head(&mddev->recovery_wait);
@@ -3322,7 +3323,7 @@ static void md_do_sync(mddev_t *mddev)
 		 */
 		cond_resched();
 
-		currspeed = (j-mddev->resync_mark_cnt)/2/((jiffies-mddev->resync_mark)/HZ +1) +1;
+		currspeed = ((unsigned long)(j-mddev->resync_mark_cnt))/2/((jiffies-mddev->resync_mark)/HZ +1) +1;
 
 		if (currspeed > sysctl_speed_limit_min) {
 			if ((currspeed > sysctl_speed_limit_max) ||
diff -purN linux-post-2.6.5-rc2-20040329/drivers/md/raid5.c linux-2.6.5-rc3/drivers/md/raid5.c
--- linux-post-2.6.5-rc2-20040329/drivers/md/raid5.c	2004-03-14 01:57:41.000000000 +0000
+++ linux-2.6.5-rc3/drivers/md/raid5.c	2004-03-29 13:38:11.000000000 +0000
@@ -181,7 +181,7 @@ static int grow_buffers(struct stripe_he
 
 static void raid5_build_block (struct stripe_head *sh, int i);
 
-static inline void init_stripe(struct stripe_head *sh, unsigned long sector, int pd_idx)
+static inline void init_stripe(struct stripe_head *sh, sector_t sector, int pd_idx)
 {
 	raid5_conf_t *conf = sh->raid_conf;
 	int disks = conf->raid_disks, i;
@@ -218,25 +218,25 @@ static inline void init_stripe(struct st
 	insert_hash(conf, sh);
 }
 
-static struct stripe_head *__find_stripe(raid5_conf_t *conf, unsigned long sector)
+static struct stripe_head *__find_stripe(raid5_conf_t *conf, sector_t sector)
 {
 	struct stripe_head *sh;
 
 	CHECK_DEVLOCK();
-	PRINTK("__find_stripe, sector %lu\n", sector);
+	PRINTK("__find_stripe, sector %llu\n", (unsigned long long)sector);
 	for (sh = stripe_hash(conf, sector); sh; sh = sh->hash_next)
 		if (sh->sector == sector)
 			return sh;
-	PRINTK("__stripe %lu not in cache\n", sector);
+	PRINTK("__stripe %llu not in cache\n", (unsigned long long)sector);
 	return NULL;
 }
 
-static struct stripe_head *get_active_stripe(raid5_conf_t *conf, unsigned long sector, 
+static struct stripe_head *get_active_stripe(raid5_conf_t *conf, sector_t sector,
 					     int pd_idx, int noblock) 
 {
 	struct stripe_head *sh;
 
-	PRINTK("get_stripe, sector %lu\n", sector);
+	PRINTK("get_stripe, sector %llu\n", (unsigned long long)sector);
 
 	spin_lock_irq(&conf->device_lock);
 
@@ -495,7 +495,7 @@ static void error(mddev_t *mddev, mdk_rd
  * Input: a 'big' sector number,
  * Output: index of the data and parity disk, and the sector # in them.
  */
-static unsigned long raid5_compute_sector(sector_t r_sector, unsigned int raid_disks,
+static sector_t raid5_compute_sector(sector_t r_sector, unsigned int raid_disks,
 			unsigned int data_disks, unsigned int * dd_idx,
 			unsigned int * pd_idx, raid5_conf_t *conf)
 {
@@ -556,7 +556,7 @@ static unsigned long raid5_compute_secto
 	/*
 	 * Finally, compute the new sector number
 	 */
-	new_sector = stripe * sectors_per_chunk + chunk_offset;
+	new_sector = (sector_t)stripe * sectors_per_chunk + chunk_offset;
 	return new_sector;
 }
 
@@ -567,7 +567,7 @@ static sector_t compute_blocknr(struct s
 	int raid_disks = conf->raid_disks, data_disks = raid_disks - 1;
 	sector_t new_sector = sh->sector, check;
 	int sectors_per_chunk = conf->chunk_size >> 9;
-	long stripe;
+	sector_t stripe;
 	int chunk_offset;
 	int chunk_number, dummy1, dummy2, dd_idx = i;
 	sector_t r_sector;
@@ -1388,7 +1388,7 @@ static int sync_request (mddev_t *mddev,
 	unsigned long stripe;
 	int chunk_offset;
 	int dd_idx, pd_idx;
-	unsigned long first_sector;
+	sector_t first_sector;
 	int raid_disks = conf->raid_disks;
 	int data_disks = raid_disks-1;
 
@@ -1401,7 +1401,7 @@ static int sync_request (mddev_t *mddev,
 	stripe = x;
 	BUG_ON(x != stripe);
 
-	first_sector = raid5_compute_sector(stripe*data_disks*sectors_per_chunk
+	first_sector = raid5_compute_sector((sector_t)stripe*data_disks*sectors_per_chunk
 		+ chunk_offset, raid_disks, data_disks, &dd_idx, &pd_idx, conf);
 	sh = get_active_stripe(conf, sector_nr, pd_idx, 1);
 	if (sh == NULL) {
diff -purN linux-post-2.6.5-rc2-20040329/drivers/md/raid6main.c linux-2.6.5-rc3/drivers/md/raid6main.c
--- linux-post-2.6.5-rc2-20040329/drivers/md/raid6main.c	2004-03-14 01:57:41.000000000 +0000
+++ linux-2.6.5-rc3/drivers/md/raid6main.c	2004-03-29 13:38:11.000000000 +0000
@@ -200,7 +200,7 @@ static int grow_buffers(struct stripe_he
 
 static void raid6_build_block (struct stripe_head *sh, int i);
 
-static inline void init_stripe(struct stripe_head *sh, unsigned long sector, int pd_idx)
+static inline void init_stripe(struct stripe_head *sh, sector_t sector, int pd_idx)
 {
 	raid6_conf_t *conf = sh->raid_conf;
 	int disks = conf->raid_disks, i;
@@ -237,25 +237,25 @@ static inline void init_stripe(struct st
 	insert_hash(conf, sh);
 }
 
-static struct stripe_head *__find_stripe(raid6_conf_t *conf, unsigned long sector)
+static struct stripe_head *__find_stripe(raid6_conf_t *conf, sector_t sector)
 {
 	struct stripe_head *sh;
 
 	CHECK_DEVLOCK();
-	PRINTK("__find_stripe, sector %lu\n", sector);
+	PRINTK("__find_stripe, sector %llu\n", (unsigned long long)sector);
 	for (sh = stripe_hash(conf, sector); sh; sh = sh->hash_next)
 		if (sh->sector == sector)
 			return sh;
-	PRINTK("__stripe %lu not in cache\n", sector);
+	PRINTK("__stripe %llu not in cache\n", (unsigned long long)sector);
 	return NULL;
 }
 
-static struct stripe_head *get_active_stripe(raid6_conf_t *conf, unsigned long sector,
+static struct stripe_head *get_active_stripe(raid6_conf_t *conf, sector_t sector,
 					     int pd_idx, int noblock)
 {
 	struct stripe_head *sh;
 
-	PRINTK("get_stripe, sector %lu\n", sector);
+	PRINTK("get_stripe, sector %llu\n", (unsigned long long)sector);
 
 	spin_lock_irq(&conf->device_lock);
 
@@ -516,7 +516,7 @@ static void error(mddev_t *mddev, mdk_rd
  * Input: a 'big' sector number,
  * Output: index of the data and parity disk, and the sector # in them.
  */
-static unsigned long raid6_compute_sector(sector_t r_sector, unsigned int raid_disks,
+static sector_t raid6_compute_sector(sector_t r_sector, unsigned int raid_disks,
 			unsigned int data_disks, unsigned int * dd_idx,
 			unsigned int * pd_idx, raid6_conf_t *conf)
 {
@@ -588,7 +588,7 @@ static unsigned long raid6_compute_secto
 	/*
 	 * Finally, compute the new sector number
 	 */
-	new_sector = stripe * sectors_per_chunk + chunk_offset;
+	new_sector = (sector_t) stripe * sectors_per_chunk + chunk_offset;
 	return new_sector;
 }
 
@@ -599,7 +599,7 @@ static sector_t compute_blocknr(struct s
 	int raid_disks = conf->raid_disks, data_disks = raid_disks - 2;
 	sector_t new_sector = sh->sector, check;
 	int sectors_per_chunk = conf->chunk_size >> 9;
-	long stripe;
+	sector_t stripe;
 	int chunk_offset;
 	int chunk_number, dummy1, dummy2, dd_idx = i;
 	sector_t r_sector;
@@ -1550,7 +1550,7 @@ static int sync_request (mddev_t *mddev,
 	unsigned long stripe;
 	int chunk_offset;
 	int dd_idx, pd_idx;
-	unsigned long first_sector;
+	sector_t first_sector;
 	int raid_disks = conf->raid_disks;
 	int data_disks = raid_disks - 2;
 
@@ -1563,7 +1563,7 @@ static int sync_request (mddev_t *mddev,
 	stripe = x;
 	BUG_ON(x != stripe);
 
-	first_sector = raid6_compute_sector(stripe*data_disks*sectors_per_chunk
+	first_sector = raid6_compute_sector((sector_t)stripe*data_disks*sectors_per_chunk
 		+ chunk_offset, raid_disks, data_disks, &dd_idx, &pd_idx, conf);
 	sh = get_active_stripe(conf, sector_nr, pd_idx, 1);
 	if (sh == NULL) {
diff -purN linux-post-2.6.5-rc2-20040329/drivers/parport/daisy.c linux-2.6.5-rc3/drivers/parport/daisy.c
--- linux-post-2.6.5-rc2-20040329/drivers/parport/daisy.c	2004-03-03 12:45:16.000000000 +0000
+++ linux-2.6.5-rc3/drivers/parport/daisy.c	2004-03-29 13:44:20.000000000 +0000
@@ -27,7 +27,7 @@
 #include <asm/current.h>
 #include <asm/uaccess.h>
 
-#define DEBUG /* undef me for production */
+#undef DEBUG
 
 #ifdef DEBUG
 #define DPRINTK(stuff...) printk (stuff)
diff -purN linux-post-2.6.5-rc2-20040329/drivers/scsi/libata-scsi.c linux-2.6.5-rc3/drivers/scsi/libata-scsi.c
--- linux-post-2.6.5-rc2-20040329/drivers/scsi/libata-scsi.c	2004-02-27 02:23:26.000000000 +0000
+++ linux-2.6.5-rc3/drivers/scsi/libata-scsi.c	2004-03-27 23:08:37.000000000 +0000
@@ -251,6 +251,8 @@ static unsigned int ata_scsi_rw_xlat(str
 		tf->lbam = scsicmd[2];
 		tf->lbah = scsicmd[1] & 0x1f; /* mask out reserved bits */
 
+		tf->device |= ATA_LBA;
+
 		VPRINTK("six-byte command\n");
 		return 0;
 	}
diff -purN linux-post-2.6.5-rc2-20040329/drivers/serial/pmac_zilog.c linux-2.6.5-rc3/drivers/serial/pmac_zilog.c
--- linux-post-2.6.5-rc2-20040329/drivers/serial/pmac_zilog.c	2004-03-24 10:01:17.000000000 +0000
+++ linux-2.6.5-rc3/drivers/serial/pmac_zilog.c	2004-03-29 08:42:07.000000000 +0000
@@ -1875,9 +1875,6 @@ static void __exit exit_pmz(void)
 	/* Get rid of macio-driver (detach from macio) */
 	macio_unregister_driver(&pmz_driver);
 
-	/* Unregister UART driver */
-	uart_unregister_driver(&pmz_uart_reg);
-
 	for (i = 0; i < pmz_ports_count; i++) {
 		struct uart_pmac_port *uport = &pmz_ports[i];
 		if (uport->node != NULL) {
@@ -1885,6 +1882,8 @@ static void __exit exit_pmz(void)
 			pmz_dispose_port(uport);
 		}
 	}
+	/* Unregister UART driver */
+	uart_unregister_driver(&pmz_uart_reg);
 }
 
 #ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE
diff -purN linux-post-2.6.5-rc2-20040329/drivers/video/acornfb.c linux-2.6.5-rc3/drivers/video/acornfb.c
--- linux-post-2.6.5-rc2-20040329/drivers/video/acornfb.c	2004-02-22 17:14:16.000000000 +0000
+++ linux-2.6.5-rc3/drivers/video/acornfb.c	2004-03-29 16:36:17.000000000 +0000
@@ -29,6 +29,8 @@
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/fb.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/hardware.h>
 #include <asm/io.h>
@@ -1254,6 +1256,11 @@ free_unused_pages(unsigned int virtual_s
 	printk("acornfb: freed %dK memory\n", mb_freed);
 }
 
+static struct device acornfb_device = {
+	.bus_id			= "acornfb",
+	.coherent_dma_mask	= 0xffffffff,
+};
+
 int __init
 acornfb_init(void)
 {
@@ -1263,6 +1270,8 @@ acornfb_init(void)
 
 	acornfb_init_fbinfo();
 
+	current_par.dev = &acornfb_device;
+
 	if (current_par.montype == -1)
 		current_par.montype = acornfb_detect_monitortype();
 
@@ -1323,37 +1332,30 @@ acornfb_init(void)
 
 #if defined(HAS_VIDC20)
 	if (!current_par.using_vram) {
+		dma_addr_t handle;
+		void *base;
+
 		/*
 		 * RiscPC needs to allocate the DRAM memory
 		 * for the framebuffer if we are not using
-		 * VRAM.  Archimedes/A5000 machines use a
-		 * fixed address for their framebuffers.
+		 * VRAM.
 		 */
-		unsigned long page, top, base;
-		int order = get_order(size);
-
-		base = __get_free_pages(GFP_KERNEL, order);
-		if (base == 0) {
+		base = dma_alloc_writecombine(current_par.dev, size, &handle,
+					      GFP_KERNEL);
+		if (base == NULL) {
 			printk(KERN_ERR "acornfb: unable to allocate screen "
 			       "memory\n");
 			return -ENOMEM;
 		}
-		top = base + (PAGE_SIZE << order);
-
-		/* Mark the framebuffer pages as reserved so mmap will work. */
-		for (page = base; page < PAGE_ALIGN(base + size); page += PAGE_SIZE)
-			SetPageReserved(virt_to_page(page));
-		/* Hand back any excess pages that we allocated. */
-		for (page = base + size; page < top; page += PAGE_SIZE)
-			free_page(page);
 
-		fb_info.screen_base = (char *)base;
-		fb_info.fix.smem_start = virt_to_phys(fb_info.screen_base);
+		fb_info.screen_base = base;
+		fb_info.fix.smem_start = handle;
 	}
 #endif
 #if defined(HAS_VIDC)
 	/*
-	 * Free unused pages
+	 * Archimedes/A5000 machines use a fixed address for their
+	 * framebuffers.  Free unused pages
 	 */
 	free_unused_pages(PAGE_OFFSET + size, PAGE_OFFSET + MAX_SIZE);
 #endif
diff -purN linux-post-2.6.5-rc2-20040329/drivers/video/acornfb.h linux-2.6.5-rc3/drivers/video/acornfb.h
--- linux-post-2.6.5-rc2-20040329/drivers/video/acornfb.h	2004-02-22 17:14:16.000000000 +0000
+++ linux-2.6.5-rc3/drivers/video/acornfb.h	2004-03-29 16:36:17.000000000 +0000
@@ -47,6 +47,7 @@ union palette {
 };
 
 struct acornfb_par {
+	struct device	*dev;
 	unsigned long	screen_end;
 	unsigned int	dram_size;
 	unsigned int	vram_half_sam;
diff -purN linux-post-2.6.5-rc2-20040329/drivers/video/sa1100fb.c linux-2.6.5-rc3/drivers/video/sa1100fb.c
--- linux-post-2.6.5-rc2-20040329/drivers/video/sa1100fb.c	2003-10-23 05:27:14.000000000 +0000
+++ linux-2.6.5-rc3/drivers/video/sa1100fb.c	2004-03-29 10:24:17.000000000 +0000
@@ -1595,12 +1595,18 @@ static int __init sa1100fb_map_video_mem
 	 * of the framebuffer.
 	 */
 	fbi->map_size = PAGE_ALIGN(fbi->fb.fix.smem_len + PAGE_SIZE);
-	fbi->map_cpu = consistent_alloc(GFP_KERNEL, fbi->map_size,
-					&fbi->map_dma, PTE_BUFFERABLE);
+	fbi->map_cpu = dma_alloc_writecombine(fbi->dev, fbi->map_size,
+					      &fbi->map_dma, GFP_KERNEL);
 
 	if (fbi->map_cpu) {
 		fbi->fb.screen_base = fbi->map_cpu + PAGE_SIZE;
 		fbi->screen_dma = fbi->map_dma + PAGE_SIZE;
+		/*
+		 * FIXME: this is actually the wrong thing to place in
+		 * smem_start.  But fbdev suffers from the problem that
+		 * it needs an API which doesn't exist (in this case,
+		 * dma_writecombine_mmap)
+		 */
 		fbi->fb.fix.smem_start = fbi->screen_dma;
 	}
 
@@ -1613,7 +1619,7 @@ static struct fb_monspecs monspecs __ini
 };
 
 
-static struct sa1100fb_info * __init sa1100fb_init_fbinfo(void)
+static struct sa1100fb_info * __init sa1100fb_init_fbinfo(struct device *dev)
 {
 	struct sa1100fb_mach_info *inf;
 	struct sa1100fb_info *fbi;
@@ -1624,6 +1630,7 @@ static struct sa1100fb_info * __init sa1
 		return NULL;
 
 	memset(fbi, 0, sizeof(struct sa1100fb_info));
+	fbi->dev = dev;
 
 	strcpy(fbi->fb.fix.id, SA1100_NAME);
 
@@ -1703,7 +1710,7 @@ static int __init sa1100fb_probe(struct 
 	if (!request_mem_region(0xb0100000, 0x10000, "LCD"))
 		return -EBUSY;
 
-	fbi = sa1100fb_init_fbinfo();
+	fbi = sa1100fb_init_fbinfo(dev);
 	ret = -ENOMEM;
 	if (!fbi)
 		goto failed;
diff -purN linux-post-2.6.5-rc2-20040329/drivers/video/sa1100fb.h linux-2.6.5-rc3/drivers/video/sa1100fb.h
--- linux-post-2.6.5-rc2-20040329/drivers/video/sa1100fb.h	2003-01-16 13:11:38.000000000 +0000
+++ linux-2.6.5-rc3/drivers/video/sa1100fb.h	2004-03-29 10:24:47.000000000 +0000
@@ -63,6 +63,7 @@ struct sa1100fb_lcd_reg {
 
 struct sa1100fb_info {
 	struct fb_info		fb;
+	struct device		*dev;
 	struct sa1100fb_rgb	*rgb[NR_RGB];
 
 	u_int			max_bpp;
diff -purN linux-post-2.6.5-rc2-20040329/fs/Kconfig.binfmt linux-2.6.5-rc3/fs/Kconfig.binfmt
--- linux-post-2.6.5-rc2-20040329/fs/Kconfig.binfmt	2004-03-21 22:55:43.000000000 +0000
+++ linux-2.6.5-rc3/fs/Kconfig.binfmt	2004-03-23 21:54:31.000000000 +0000
@@ -99,7 +99,7 @@ config BINFMT_MISC
 	---help---
 	  If you say Y here, it will be possible to plug wrapper-driven binary
 	  formats into the kernel. You will like this especially when you use
-	  programs that need an interpreter to run like Java, Python or
+	  programs that need an interpreter to run like Java, Python, .NET or
 	  Emacs-Lisp. It's also useful if you often run DOS executables under
 	  the Linux DOS emulator DOSEMU (read the DOSEMU-HOWTO, available from
 	  <http://www.tldp.org/docs.html#howto>). Once you have
@@ -109,8 +109,9 @@ config BINFMT_MISC
 
 	  You can do other nice things, too. Read the file
 	  <file:Documentation/binfmt_misc.txt> to learn how to use this
-	  feature, and <file:Documentation/java.txt> for information about how
-	  to include Java support.
+	  feature, <file:Documentation/java.txt> for information about how
+	  to include Java support. and <file:Documentation/mono.txt> for
+          information about how to include Mono-based .NET support.
 
           To use binfmt_misc, you will need to mount it:
 		mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc
diff -purN linux-post-2.6.5-rc2-20040329/fs/fs-writeback.c linux-2.6.5-rc3/fs/fs-writeback.c
--- linux-post-2.6.5-rc2-20040329/fs/fs-writeback.c	2004-03-02 03:01:21.000000000 +0000
+++ linux-2.6.5-rc3/fs/fs-writeback.c	2004-03-29 13:44:20.000000000 +0000
@@ -44,6 +44,13 @@ extern struct super_block *blockdev_supe
  *
  * This function *must* be atomic for the I_DIRTY_PAGES case -
  * set_page_dirty() is called under spinlock in several places.
+ *
+ * Note that for blockdevs, inode->dirtied_when represents the dirtying time of
+ * the block-special inode (/dev/hda1) itself.  And the ->dirtied_when field of
+ * the kernel-internal blockdev inode represents the dirtying time of the
+ * blockdev's pages.  This is why for I_DIRTY_PAGES we always use
+ * page->mapping->host, so the page-dirtying time is recorded in the internal
+ * blockdev inode.
  */
 void __mark_inode_dirty(struct inode *inode, int flags)
 {
@@ -71,7 +78,6 @@ void __mark_inode_dirty(struct inode *in
 	spin_lock(&inode_lock);
 	if ((inode->i_state & flags) != flags) {
 		const int was_dirty = inode->i_state & I_DIRTY;
-		struct address_space *mapping = inode->i_mapping;
 
 		inode->i_state |= flags;
 
@@ -99,7 +105,7 @@ void __mark_inode_dirty(struct inode *in
 		 * reposition it (that would break s_dirty time-ordering).
 		 */
 		if (!was_dirty) {
-			mapping->dirtied_when = jiffies;
+			inode->dirtied_when = jiffies;
 			list_move(&inode->i_list, &sb->s_dirty);
 		}
 	}
@@ -176,11 +182,11 @@ __sync_single_inode(struct inode *inode,
 		} else if (!list_empty(&mapping->dirty_pages)) {
 			/* Redirtied */
 			inode->i_state |= I_DIRTY_PAGES;
-			mapping->dirtied_when = jiffies;
+			inode->dirtied_when = jiffies;
 			list_move(&inode->i_list, &sb->s_dirty);
 		} else if (inode->i_state & I_DIRTY) {
 			/* Redirtied */
-			mapping->dirtied_when = jiffies;
+			inode->dirtied_when = jiffies;
 			list_move(&inode->i_list, &sb->s_dirty);
 		} else if (atomic_read(&inode->i_count)) {
 			list_move(&inode->i_list, &inode_in_use);
@@ -220,7 +226,7 @@ __writeback_single_inode(struct inode *i
  * Write out a superblock's list of dirty inodes.  A wait will be performed
  * upon no inodes, all inodes or the final one, depending upon sync_mode.
  *
- * If older_than_this is non-NULL, then only write out mappings which
+ * If older_than_this is non-NULL, then only write out inodes which
  * had their first dirtying at a time earlier than *older_than_this.
  *
  * If we're a pdlfush thread, then implement pdflush collision avoidance
@@ -292,11 +298,11 @@ sync_sb_inodes(struct super_block *sb, s
 		}
 
 		/* Was this inode dirtied after sync_sb_inodes was called? */
-		if (time_after(mapping->dirtied_when, start))
+		if (time_after(inode->dirtied_when, start))
 			break;
 
 		/* Was this inode dirtied too recently? */
-		if (wbc->older_than_this && time_after(mapping->dirtied_when,
+		if (wbc->older_than_this && time_after(inode->dirtied_when,
 						*wbc->older_than_this))
 			break;
 
@@ -308,7 +314,7 @@ sync_sb_inodes(struct super_block *sb, s
 		__iget(inode);
 		__writeback_single_inode(inode, wbc);
 		if (wbc->sync_mode == WB_SYNC_HOLD) {
-			mapping->dirtied_when = jiffies;
+			inode->dirtied_when = jiffies;
 			list_move(&inode->i_list, &sb->s_dirty);
 		}
 		if (current_is_pdflush())
diff -purN linux-post-2.6.5-rc2-20040329/fs/inode.c linux-2.6.5-rc3/fs/inode.c
--- linux-post-2.6.5-rc2-20040329/fs/inode.c	2004-03-14 02:25:27.000000000 +0000
+++ linux-2.6.5-rc3/fs/inode.c	2004-03-29 13:44:20.000000000 +0000
@@ -132,6 +132,7 @@ static struct inode *alloc_inode(struct 
 		inode->i_cdev = NULL;
 		inode->i_rdev = 0;
 		inode->i_security = NULL;
+		inode->dirtied_when = 0;
 		if (security_inode_alloc(inode)) {
 			if (inode->i_sb->s_op->destroy_inode)
 				inode->i_sb->s_op->destroy_inode(inode);
@@ -144,7 +145,6 @@ static struct inode *alloc_inode(struct 
  		mapping->host = inode;
 		mapping->flags = 0;
 		mapping_set_gfp_mask(mapping, GFP_HIGHUSER);
-		mapping->dirtied_when = 0;
 		mapping->assoc_mapping = NULL;
 		mapping->backing_dev_info = &default_backing_dev_info;
 		if (sb->s_bdev)
diff -purN linux-post-2.6.5-rc2-20040329/include/asm-arm/dma-mapping.h linux-2.6.5-rc3/include/asm-arm/dma-mapping.h
--- linux-post-2.6.5-rc2-20040329/include/asm-arm/dma-mapping.h	2004-03-25 19:50:12.000000000 +0000
+++ linux-2.6.5-rc3/include/asm-arm/dma-mapping.h	2004-03-29 16:49:01.000000000 +0000
@@ -14,8 +14,6 @@
  * devices.  This is the "generic" version.  The PCI specific version
  * is in pci.h
  */
-extern void *consistent_alloc(int gfp, size_t size, dma_addr_t *handle, unsigned long flags);
-extern void consistent_free(void *vaddr, size_t size, dma_addr_t handle);
 extern void consistent_sync(void *kaddr, size_t size, int rw);
 
 /*
@@ -99,12 +97,26 @@ dma_alloc_coherent(struct device *dev, s
  * References to memory and mappings associated with cpu_addr/handle
  * during and after this call executing are illegal.
  */
-static inline void
+extern void
 dma_free_coherent(struct device *dev, size_t size, void *cpu_addr,
-		  dma_addr_t handle)
-{
-	consistent_free(cpu_addr, size, handle);
-}
+		  dma_addr_t handle);
+
+/**
+ * dma_alloc_writecombine - allocate writecombining memory for DMA
+ * @dev: valid struct device pointer, or NULL for ISA and EISA-like devices
+ * @size: required memory size
+ * @handle: bus-specific DMA address
+ *
+ * Allocate some uncached, buffered memory for a device for
+ * performing DMA.  This function allocates pages, and will
+ * return the CPU-viewed address, and sets @handle to be the
+ * device-viewed address.
+ */
+extern void *
+dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *handle, int gfp);
+
+#define dma_free_writecombine(dev,size,cpu_addr,handle) \
+	dma_free_coherent(dev,size,cpu_addr,handle)
 
 /**
  * dma_map_single - map a single buffer for streaming DMA
diff -purN linux-post-2.6.5-rc2-20040329/include/asm-parisc/ide.h linux-2.6.5-rc3/include/asm-parisc/ide.h
--- linux-post-2.6.5-rc2-20040329/include/asm-parisc/ide.h	2004-03-12 11:40:59.000000000 +0000
+++ linux-2.6.5-rc3/include/asm-parisc/ide.h	2004-03-28 16:43:26.000000000 +0000
@@ -41,19 +41,8 @@ static __inline__ void ide_init_hwif_por
 	hw->io_ports[IDE_IRQ_OFFSET] = 0;
 }
 
-static __inline__ void ide_init_default_hwifs(void)
-{
-#ifndef CONFIG_PCI
-	hw_regs_t hw;
-	int index;
-
-	for(index = 0; index < MAX_HWIFS; index++) {
-		ide_init_hwif_ports(&hw, ide_default_io_base(index), 0, NULL);
-		hw.irq = ide_default_irq(ide_default_io_base(index));
-		ide_register_hw(&hw);
-	}
-#endif
-}
+/* There are no standard ports. */
+static inline void ide_init_default_hwifs(void)	{ ; }
 
 #define ide_request_irq(irq,hand,flg,dev,id)	request_irq((irq),(hand),(flg),(dev),(id))
 #define ide_free_irq(irq,dev_id)		free_irq((irq), (dev_id))
diff -purN linux-post-2.6.5-rc2-20040329/include/asm-ppc/types.h linux-2.6.5-rc3/include/asm-ppc/types.h
--- linux-post-2.6.5-rc2-20040329/include/asm-ppc/types.h	2003-06-07 09:18:02.000000000 +0000
+++ linux-2.6.5-rc3/include/asm-ppc/types.h	2004-03-28 21:52:55.000000000 +0000
@@ -37,6 +37,8 @@ typedef unsigned short umode_t;
 
 #ifndef __ASSEMBLY__
 
+#include <linux/config.h>
+
 typedef signed char s8;
 typedef unsigned char u8;
 
diff -purN linux-post-2.6.5-rc2-20040329/include/asm-s390/types.h linux-2.6.5-rc3/include/asm-s390/types.h
--- linux-post-2.6.5-rc2-20040329/include/asm-s390/types.h	2003-04-14 19:11:59.000000000 +0000
+++ linux-2.6.5-rc3/include/asm-s390/types.h	2004-03-28 21:52:55.000000000 +0000
@@ -58,6 +58,8 @@ typedef __signed__ long saddr_t;
 
 #ifndef __ASSEMBLY__
 
+#include <linux/config.h>
+
 typedef signed char s8;
 typedef unsigned char u8;
 
diff -purN linux-post-2.6.5-rc2-20040329/include/asm-sh/types.h linux-2.6.5-rc3/include/asm-sh/types.h
--- linux-post-2.6.5-rc2-20040329/include/asm-sh/types.h	2003-05-06 19:33:19.000000000 +0000
+++ linux-2.6.5-rc3/include/asm-sh/types.h	2004-03-28 21:52:55.000000000 +0000
@@ -35,6 +35,8 @@ typedef unsigned long long __u64;
 
 #ifndef __ASSEMBLY__
 
+#include <linux/config.h>
+
 typedef __signed__ char s8;
 typedef unsigned char u8;
 
diff -purN linux-post-2.6.5-rc2-20040329/include/asm-sparc/ide.h linux-2.6.5-rc3/include/asm-sparc/ide.h
--- linux-post-2.6.5-rc2-20040329/include/asm-sparc/ide.h	2003-02-19 22:28:16.000000000 +0000
+++ linux-2.6.5-rc3/include/asm-sparc/ide.h	2004-03-28 16:42:28.000000000 +0000
@@ -53,24 +53,8 @@ static __inline__ void ide_init_hwif_por
 	hw->io_ports[IDE_IRQ_OFFSET] = 0;
 }
 
-/*
- * This registers the standard ports for this architecture with the IDE
- * driver.
- */
-static __inline__ void ide_init_default_hwifs(void)
-{
-#ifndef CONFIG_PCI
-	hw_regs_t hw;
-	int index;
-
-	for (index = 0; index < MAX_HWIFS; index++) {
-		memset(&hw, 0, sizeof hw);
-		ide_init_hwif_ports(&hw, ide_default_io_base(index), 0, NULL);
-		hw.irq = ide_default_irq(ide_default_io_base(index));
-		ide_register_hw(&hw, NULL);
-	}
-#endif
-}
+/* There are no standard ports. */
+static inline void ide_init_default_hwifs(void)	{ ; }
 
 #define __ide_insl(data_reg, buffer, wcount) \
 	__ide_insw(data_reg, buffer, (wcount)<<1)
diff -purN linux-post-2.6.5-rc2-20040329/include/asm-sparc64/ide.h linux-2.6.5-rc3/include/asm-sparc64/ide.h
--- linux-post-2.6.5-rc2-20040329/include/asm-sparc64/ide.h	2003-03-24 06:03:00.000000000 +0000
+++ linux-2.6.5-rc3/include/asm-sparc64/ide.h	2004-03-28 16:42:28.000000000 +0000
@@ -54,24 +54,8 @@ static __inline__ void ide_init_hwif_por
 	hw->io_ports[IDE_IRQ_OFFSET] = 0;
 }
 
-/*
- * This registers the standard ports for this architecture with the IDE
- * driver.
- */
-static __inline__ void ide_init_default_hwifs(void)
-{
-#ifndef CONFIG_BLK_DEV_IDEPCI
-	hw_regs_t hw;
-	int index;
-
-	for (index = 0; index < MAX_HWIFS; index++) {
-		memset(&hw, 0, sizeof hw);
-		ide_init_hwif_ports(&hw, ide_default_io_base(index), 0, NULL);
-		hw.irq = ide_default_irq(ide_default_io_base(index));
-		ide_register_hw(&hw, NULL);
-	}
-#endif /* CONFIG_BLK_DEV_IDEPCI */
-}
+/* There are no standard ports. */
+static inline void ide_init_default_hwifs(void)	{ ; }
 
 #define __ide_insl(data_reg, buffer, wcount) \
 	__ide_insw(data_reg, buffer, (wcount)<<1)
diff -purN linux-post-2.6.5-rc2-20040329/include/asm-x86_64/types.h linux-2.6.5-rc3/include/asm-x86_64/types.h
--- linux-post-2.6.5-rc2-20040329/include/asm-x86_64/types.h	2002-12-31 04:14:21.000000000 +0000
+++ linux-2.6.5-rc3/include/asm-x86_64/types.h	2004-03-28 21:52:55.000000000 +0000
@@ -33,6 +33,8 @@ typedef unsigned long long  __u64;
 
 #ifndef __ASSEMBLY__
 
+#include <linux/config.h>
+
 typedef signed char s8;
 typedef unsigned char u8;
 
diff -purN linux-post-2.6.5-rc2-20040329/include/linux/fs.h linux-2.6.5-rc3/include/linux/fs.h
--- linux-post-2.6.5-rc2-20040329/include/linux/fs.h	2004-03-19 06:04:57.000000000 +0000
+++ linux-2.6.5-rc3/include/linux/fs.h	2004-03-29 13:44:20.000000000 +0000
@@ -333,7 +333,6 @@ struct address_space {
 	struct list_head	i_mmap_shared;	/* list of shared mappings */
 	struct semaphore	i_shared_sem;	/* protect both above lists */
 	atomic_t		truncate_count;	/* Cover race condition with truncate */
-	unsigned long		dirtied_when;	/* jiffies of first page dirtying */
 	unsigned long		flags;		/* error bits/gfp mask */
 	struct backing_dev_info *backing_dev_info; /* device readahead, etc */
 	spinlock_t		private_lock;	/* for use by the address_space */
@@ -416,6 +415,7 @@ struct inode {
 	struct dnotify_struct	*i_dnotify; /* for directory notifications */
 
 	unsigned long		i_state;
+	unsigned long		dirtied_when;	/* jiffies of first dirtying */
 
 	unsigned int		i_flags;
 	unsigned char		i_sock;
diff -purN linux-post-2.6.5-rc2-20040329/include/linux/ide.h linux-2.6.5-rc3/include/linux/ide.h
--- linux-post-2.6.5-rc2-20040329/include/linux/ide.h	2004-03-23 18:26:40.000000000 +0000
+++ linux-2.6.5-rc3/include/linux/ide.h	2004-03-29 13:44:18.000000000 +0000
@@ -24,8 +24,6 @@
 #include <asm/io.h>
 #include <asm/semaphore.h>
 
-#define DEBUG_PM
-
 /*
  * This is the multiple IDE interface driver, as evolved from hd.c.
  * It supports up to four IDE interfaces, on one or more IRQs (usually 14 & 15).
diff -purN linux-post-2.6.5-rc2-20040329/include/linux/raid/md_k.h linux-2.6.5-rc3/include/linux/raid/md_k.h
--- linux-post-2.6.5-rc2-20040329/include/linux/raid/md_k.h	2004-02-19 03:42:51.000000000 +0000
+++ linux-2.6.5-rc3/include/linux/raid/md_k.h	2004-03-29 13:38:06.000000000 +0000
@@ -212,9 +212,9 @@ struct mddev_s
 
 	struct mdk_thread_s		*thread;	/* management thread */
 	struct mdk_thread_s		*sync_thread;	/* doing resync or reconstruct */
-	unsigned long			curr_resync;	/* blocks scheduled */
+	sector_t			curr_resync;	/* blocks scheduled */
 	unsigned long			resync_mark;	/* a recent timestamp */
-	unsigned long			resync_mark_cnt;/* blocks written at resync_mark */
+	sector_t			resync_mark_cnt;/* blocks written at resync_mark */
 
 	/* recovery/resync flags 
 	 * NEEDED:   we might need to start a resync/recover
diff -purN linux-post-2.6.5-rc2-20040329/kernel/ptrace.c linux-2.6.5-rc3/kernel/ptrace.c
--- linux-post-2.6.5-rc2-20040329/kernel/ptrace.c	2003-10-08 02:53:43.000000000 +0000
+++ linux-2.6.5-rc3/kernel/ptrace.c	2004-03-29 13:42:44.000000000 +0000
@@ -168,7 +168,7 @@ int access_process_vm(struct task_struct
 		int bytes, ret, offset;
 		void *maddr;
 
-		ret = get_user_pages(current, mm, addr, 1,
+		ret = get_user_pages(tsk, mm, addr, 1,
 				write, 1, &page, &vma);
 		if (ret <= 0)
 			break;
diff -purN linux-post-2.6.5-rc2-20040329/kernel/sched.c linux-2.6.5-rc3/kernel/sched.c
--- linux-post-2.6.5-rc2-20040329/kernel/sched.c	2004-03-19 04:54:57.000000000 +0000
+++ linux-2.6.5-rc3/kernel/sched.c	2004-03-29 13:42:41.000000000 +0000
@@ -1678,7 +1678,7 @@ need_resched:
 	queue = array->queue + idx;
 	next = list_entry(queue->next, task_t, run_list);
 
-	if (next->activated > 0) {
+	if (!rt_task(next) && next->activated > 0) {
 		unsigned long long delta = now - next->timestamp;
 
 		if (next->activated == 1)
diff -purN linux-post-2.6.5-rc2-20040329/mm/slab.c linux-2.6.5-rc3/mm/slab.c
--- linux-post-2.6.5-rc2-20040329/mm/slab.c	2004-03-21 07:49:49.000000000 +0000
+++ linux-2.6.5-rc3/mm/slab.c	2004-03-29 13:42:42.000000000 +0000
@@ -1279,6 +1279,9 @@ next:
 	cachep->dtor = dtor;
 	cachep->name = name;
 
+	/* Don't let CPUs to come and go */
+	lock_cpu_hotplug();
+
 	if (g_cpucache_up == FULL) {
 		enable_cpucache(cachep);
 	} else {
@@ -1328,6 +1331,7 @@ next:
 			if (!strcmp(pc->name,name)) { 
 				printk("kmem_cache_create: duplicate cache %s\n",name); 
 				up(&cache_chain_sem); 
+				unlock_cpu_hotplug();
 				BUG(); 
 			}	
 		}
@@ -1337,6 +1341,7 @@ next:
 	/* cache setup completed, link it into the list */
 	list_add(&cachep->next, &cache_chain);
 	up(&cache_chain_sem);
+	unlock_cpu_hotplug();
 opps:
 	return cachep;
 }
@@ -1487,6 +1492,9 @@ int kmem_cache_destroy (kmem_cache_t * c
 	if (!cachep || in_interrupt())
 		BUG();
 
+	/* Don't let CPUs to come and go */
+	lock_cpu_hotplug();
+
 	/* Find the cache in the chain of caches. */
 	down(&cache_chain_sem);
 	/*
@@ -1500,6 +1508,7 @@ int kmem_cache_destroy (kmem_cache_t * c
 		down(&cache_chain_sem);
 		list_add(&cachep->next,&cache_chain);
 		up(&cache_chain_sem);
+		unlock_cpu_hotplug();
 		return 1;
 	}
 
@@ -1514,6 +1523,8 @@ int kmem_cache_destroy (kmem_cache_t * c
 	cachep->lists.shared = NULL;
 	kmem_cache_free(&cache_cache, cachep);
 
+	unlock_cpu_hotplug();
+
 	return 0;
 }
 
diff -purN linux-post-2.6.5-rc2-20040329/mm/swapfile.c linux-2.6.5-rc3/mm/swapfile.c
--- linux-post-2.6.5-rc2-20040329/mm/swapfile.c	2004-03-15 15:11:39.000000000 +0000
+++ linux-2.6.5-rc3/mm/swapfile.c	2004-03-29 13:44:19.000000000 +0000
@@ -1167,7 +1167,7 @@ static int swap_show(struct seq_file *sw
 
 	file = ptr->swap_file;
 	len = seq_path(swap, file->f_vfsmnt, file->f_dentry, " \t\n\\");
-	seq_printf(swap, "%*s %s\t%d\t%ld\t%d\n",
+	seq_printf(swap, "%*s%s\t%d\t%ld\t%d\n",
 		       len < 40 ? 40 - len : 1, " ",
 		       S_ISBLK(file->f_dentry->d_inode->i_mode) ?
 				"partition" : "file\t",
diff -purN linux-post-2.6.5-rc2-20040329/sound/oss/cmpci.c linux-2.6.5-rc3/sound/oss/cmpci.c
--- linux-post-2.6.5-rc2-20040329/sound/oss/cmpci.c	2003-12-29 21:37:28.000000000 +0000
+++ linux-2.6.5-rc3/sound/oss/cmpci.c	2004-03-29 13:42:43.000000000 +0000
@@ -1462,7 +1462,9 @@ static int cm_open_mixdev(struct inode *
 
 static int cm_release_mixdev(struct inode *inode, struct file *file)
 {
-	struct cm_state *s = (struct cm_state *)file->private_data;
+	struct cm_state *s;
+
+	s = file->private_data;
 	
 	VALIDATE_STATE(s);
 	return 0;
diff -purN linux-post-2.6.5-rc2-20040329/sound/oss/opl3sa2.c linux-2.6.5-rc3/sound/oss/opl3sa2.c
--- linux-post-2.6.5-rc2-20040329/sound/oss/opl3sa2.c	2003-09-30 00:18:51.000000000 +0000
+++ linux-2.6.5-rc3/sound/oss/opl3sa2.c	2004-03-29 13:43:05.000000000 +0000
@@ -160,7 +160,6 @@ typedef struct {
 } opl3sa2_state_t;
 static opl3sa2_state_t opl3sa2_state[OPL3SA2_CARDS_MAX];
 
-static spinlock_t opl3sa2_lock = SPIN_LOCK_UNLOCKED;
 	
 
 /* Our parameters */
@@ -853,6 +852,8 @@ static struct pnp_driver opl3sa2_driver 
 /* End of component functions */
 
 #ifdef CONFIG_PM
+static spinlock_t opl3sa2_lock = SPIN_LOCK_UNLOCKED;
+
 /* Power Management support functions */
 static int opl3sa2_suspend(struct pm_dev *pdev, unsigned int pm_mode)
 {
