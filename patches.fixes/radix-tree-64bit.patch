From: Holger Smolinski <smolinski@de.ibm.com>
Problem: setting DASDs offline after dasdfmt leads to kernel oops

We have investigated this and found it related to EFI partitioning code. Due to
the DASD size being 0 right after dasdfmt, this code is establishing a mapping
for a page at index (~0UL >> 3) related to a bdev inode by reading the assumed
last sector. This page mapping is never released when the bdev gets released in
destroy partitions and as a consequence the nrpages counter in the mapping is
still 1 when the inode tries to get freed -> BUG();
Besides the obvious flaw, that efi is trying the last block of a device, that
reports size 0, we identified a 64bit flaw in radix-tree functions __lookup_tag
and  __lookup which shifts a 1 by more than 32 bits instead of a 1UL.


Index: linux-2.6.5/lib/radix-tree.c
===================================================================
--- linux-2.6.5.orig/lib/radix-tree.c
+++ linux-2.6.5/lib/radix-tree.c
@@ -490,10 +490,10 @@ __lookup(struct radix_tree_root *root, v
 		for ( ; i < RADIX_TREE_MAP_SIZE; i++) {
 			if (slot->slots[i] != NULL)
 				break;
-			index &= ~((1 << shift) - 1);
-			index += 1 << shift;
+			index &= ~((1UL << shift) - 1);
+			index += 1UL << shift;
 			if (index == 0)
-				goto out;	/* 32-bit wraparound */
+				goto out;	/* wraparound */
 		}
 		if (i == RADIX_TREE_MAP_SIZE)
 			goto out;
@@ -580,10 +580,10 @@ __lookup_tag(struct radix_tree_root *roo
 				BUG_ON(slot->slots[i] == NULL);
 				break;
 			}
-			index &= ~((1 << shift) - 1);
-			index += 1 << shift;
+			index &= ~((1UL << shift) - 1);
+			index += 1UL << shift;
 			if (index == 0)
-				goto out;	/* 32-bit wraparound */
+				goto out;	/* wraparound */
 		}
 		if (i == RADIX_TREE_MAP_SIZE)
 			goto out;
