

The compound page logic is using page->lru, and these get will scribbled on
in various places so switch the Compound page logic over to using ->mapping
and ->private.


Index: linux.t/arch/i386/mm/hugetlbpage.c
===================================================================
--- linux.t.orig/arch/i386/mm/hugetlbpage.c	2004-03-15 15:20:31.296877239 -0500
+++ linux.t/arch/i386/mm/hugetlbpage.c	2004-03-15 15:20:47.690913952 -0500
@@ -278,7 +278,6 @@ follow_huge_pmd(struct mm_struct *mm, un
 static void free_huge_page(struct page *page)
 {
 	BUG_ON(page_count(page));
-	BUG_ON(page->mapping);
 
 	INIT_LIST_HEAD(&page->lru);
 
Index: linux.t/arch/ia64/mm/hugetlbpage.c
===================================================================
--- linux.t.orig/arch/ia64/mm/hugetlbpage.c	2004-03-15 15:20:31.316874845 -0500
+++ linux.t/arch/ia64/mm/hugetlbpage.c	2004-03-15 15:20:47.691913832 -0500
@@ -246,7 +246,6 @@ follow_huge_pmd(struct mm_struct *mm, un
 void free_huge_page(struct page *page)
 {
 	BUG_ON(page_count(page));
-	BUG_ON(page->mapping);
 
 	INIT_LIST_HEAD(&page->lru);
 
Index: linux.t/arch/ppc64/mm/hugetlbpage.c
===================================================================
--- linux.t.orig/arch/ppc64/mm/hugetlbpage.c	2004-03-15 15:20:31.326873647 -0500
+++ linux.t/arch/ppc64/mm/hugetlbpage.c	2004-03-15 15:20:47.693913593 -0500
@@ -407,7 +407,6 @@ follow_huge_pmd(struct mm_struct *mm, un
 static void free_huge_page(struct page *page)
 {
 	BUG_ON(page_count(page));
-	BUG_ON(page->mapping);
 
 	INIT_LIST_HEAD(&page->lru);
 
Index: linux.t/arch/sparc64/mm/hugetlbpage.c
===================================================================
--- linux.t.orig/arch/sparc64/mm/hugetlbpage.c	2004-03-15 15:20:31.337872330 -0500
+++ linux.t/arch/sparc64/mm/hugetlbpage.c	2004-03-15 15:20:47.694913473 -0500
@@ -248,7 +248,6 @@ struct page *follow_huge_pmd(struct mm_s
 static void free_huge_page(struct page *page)
 {
 	BUG_ON(page_count(page));
-	BUG_ON(page->mapping);
 
 	INIT_LIST_HEAD(&page->lru);
 
Index: linux.t/include/linux/mm.h
===================================================================
--- linux.t.orig/include/linux/mm.h	2004-03-15 15:08:24.359827572 -0500
+++ linux.t/include/linux/mm.h	2004-03-15 15:20:47.689914071 -0500
@@ -241,24 +241,24 @@ extern void FASTCALL(__page_cache_releas
 static inline int page_count(struct page *p)
 {
 	if (PageCompound(p))
-		p = (struct page *)p->lru.next;
+		p = (struct page *)p->private;
 	return atomic_read(&(p)->count);
 }
 
 static inline void get_page(struct page *page)
 {
 	if (PageCompound(page))
-		page = (struct page *)page->lru.next;
+		page = (struct page *)page->private;
 	atomic_inc(&page->count);
 }
 
 static inline void put_page(struct page *page)
 {
 	if (PageCompound(page)) {
-		page = (struct page *)page->lru.next;
+		page = (struct page *)page->private;
 		if (put_page_testzero(page)) {
-			if (page->lru.prev) {	/* destructor? */
-				(*(void (*)(struct page *))page->lru.prev)(page);
+			if (page[1].mapping) {	/* destructor? */
+				(*(void (*)(struct page *))page[1].mapping)(page);
 			} else {
 				__page_cache_release(page);
 			}
Index: linux.t/mm/page_alloc.c
===================================================================
--- linux.t.orig/mm/page_alloc.c	2004-03-15 15:20:23.514809170 -0500
+++ linux.t/mm/page_alloc.c	2004-03-15 15:20:47.687914311 -0500
@@ -77,13 +77,14 @@ static int bad_range(struct zone *zone, 
 
 static void bad_page(const char *function, struct page *page)
 {
-	printk("Bad page state at %s (in process '%s', page %p)\n", function, current->comm, page);
-	printk("flags:0x%08lx mapping:%p mapped:%d count:%d\n",
+	printk(KERN_EMERG "Bad page state at %s (in process '%s', page %p)\n",
+		function, current->comm, page);
+	printk(KERN_EMERG "flags:0x%08lx mapping:%p mapped:%d count:%d\n",
 		page->flags, page->mapping,
 		page_mapped(page), page_count(page));
-	printk("Backtrace:\n");
+	printk(KERN_EMERG "Backtrace:\n");
 	dump_stack();
-	printk("Trying to fix it up, but a reboot is needed\n");
+	printk(KERN_EMERG "Trying to fix it up, but a reboot is needed\n");
 	page->flags &= ~(1 << PG_private	|
 			1 << PG_locked	|
 			1 << PG_lru	|
@@ -106,13 +107,13 @@ static void bad_page(const char *functio
  *
  * The remaining PAGE_SIZE pages are called "tail pages".
  *
- * All pages have PG_compound set.  All pages have their lru.next pointing at
+ * All pages have PG_compound set.  All pages have their ->private pointing at
  * the head page (even the head page has this).
  *
- * The head page's lru.prev, if non-zero, holds the address of the compound
- * page's put_page() function.
+ * The first tail page's ->mapping, if non-zero, holds the address of the
+ * compound page's put_page() function.
  *
- * The order of the allocation is stored in the first tail page's lru.prev.
+ * The order of the allocation is stored in the first tail page's ->index
  * This is only for debug at present.  This usage means that zero-order pages
  * may not be compound.
  */
@@ -121,13 +122,13 @@ static void prep_compound_page(struct pa
 	int i;
 	int nr_pages = 1 << order;
 
-	page->lru.prev = NULL;
-	page[1].lru.prev = (void *)order;
+	page[1].mapping = 0;
+	page[1].index = order;
 	for (i = 0; i < nr_pages; i++) {
 		struct page *p = page + i;
 
 		SetPageCompound(p);
-		p->lru.next = (void *)page;
+		p->private = (unsigned long)page;
 	}
 }
 
@@ -136,7 +137,7 @@ static void destroy_compound_page(struct
 	int i;
 	int nr_pages = 1 << order;
 
-	if (page[1].lru.prev != (void *)order)
+	if (page[1].index != order)
 		bad_page(__FUNCTION__, page);
 
 	for (i = 0; i < nr_pages; i++) {
@@ -144,7 +145,7 @@ static void destroy_compound_page(struct
 
 		if (!PageCompound(p))
 			bad_page(__FUNCTION__, page);
-		if (p->lru.next != (void *)page)
+		if (p->private != (unsigned long)page)
 			bad_page(__FUNCTION__, page);
 		ClearPageCompound(p);
 	}
@@ -525,14 +526,14 @@ static struct page *buffered_rmqueue(str
 		spin_lock_irqsave(&zone->lock, flags);
 		page = __rmqueue(zone, order);
 		spin_unlock_irqrestore(&zone->lock, flags);
-		if (order && page)
-			prep_compound_page(page, order);
 	}
 
 	if (page != NULL) {
 		BUG_ON(bad_range(zone, page));
 		mod_page_state_zone(zone, pgalloc, 1 << order);
 		prep_new_page(page, order);
+		if (order)
+			prep_compound_page(page, order);
 	}
 	return page;
 }
