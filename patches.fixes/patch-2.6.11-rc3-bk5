From: olh@suse.de
Subject: patch-2.6.11-rc3-bk5

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc3-bk4.log	2005-02-07 14:02:16.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc3-bk5.log	2005-02-08 13:56:59.000000000 +0100
 ChangeSet@1.2143, 2005-02-07 21:32:50-08:00, andrew.vasquez@qlogic.com
   [PATCH] qlogic nonatomic warning fix
   
   The qlogic driver complains about the use of smp_processor_id() in
   preemptible code.  And it's right.
   
   But it's just for an affinity optimisation and we can validly quash the
   warning.
   
   Signed-off-by: Andrew Vasquez <andrew.vasquez@qlogic.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2142, 2005-02-07 21:32:36-08:00, yuasa@hh.iij4u.or.jp
   [PATCH] mips: add unknown page size string
   
   This patch had fixed the following warning.
   
   arch/mips/lib-32/dump_tlb.c: In function 'dump_tlb':
   arch/mips/lib-32/dump_tlb.c:69: warning: control may reach end of non-void function 'msk2str' being inlined
   
   This patch adds return value, when page size is not match.
   
   Signed-off-by: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2141, 2005-02-07 21:32:21-08:00, e9925248@student.tuwien.ac.at
   [PATCH] serial: fix low-latency mode deadlock
   
   We presently deadlock in low-latency mode because the receive code holds
   port.lock while calling into the tty code to perform echoing.  The tty code
   calls back into the driver, which then takes port.lock.
   
   Fix that by dropping the lock around the echo call.
   
   Acked-by: Russell King <rmk@arm.linux.org.uk>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2140, 2005-02-07 21:32:06-08:00, suresh.b.siddha@intel.com
   [PATCH] x86_64: missing lock prefix in switch_to
   
   Add the missing "lock" prefix in switch_to macro.
   
   Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2139, 2005-02-07 21:31:52-08:00, blaisorblade@yahoo.it
   [PATCH] uml: hostfs: (security) fix chmod +s permission check
   
   Frank Fricke reported that hostfs does not verify that a chmod +s, for
   instance, is done by a sufficiently privileged user, as long as the UML
   kernel itself can complete the operation on the host.
   
   So, for instance, if UML is run as root and under /mnt/host we have a hostfs
   mount, this works successfully:
   
   paolo@zion:~ (0)$ chmod 4755 /mnt/host/bin/bash
   paolo@zion:~ (0)$ ll /mnt/host/bin/bash
   
    -rwsr-xr-x  1 root root 662724 2004-10-20 02:15 /mnt/host/bin/bash*
   
   (bash refuses running as setuid, but you could have another shell on the
   host, as dash or whatever).
   
   In general, if UML is run as uid 500 on the host, a hostfs mount is done
   and under the hostfs mount there is a file with uid 500 on the host, I can
   freely make it setuid (if it's executable).
   
   This is especially bad when UML is run as root (which you should not do),
   but is a problem in general, since it allows any user to create setuid 500
   (in this example) executables on the host filesystem.
   
   Finally, while I was looking at the chmod() implementation, I spotted a
   kludge in the code and explained it with a comment.
   
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Cc: Frank 'xraz' Fricke <xraz@rwxr-xr-x.de>
   Cc: Alexander Viro <viro@parcelfarce.linux.theplanet.co.uk>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2138, 2005-02-07 21:31:37-08:00, blaisorblade@yahoo.it
   [PATCH] uml: kbuild: add further cleaning
   
   Descend into arch/um/kernel/skas/util during make clean.
   
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2137, 2005-02-07 21:31:22-08:00, mingo@elte.hu
   [PATCH] add design comment to kick_process()
   
   Signed-off-by: Ingo Molnar <mingo@elte.hu>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2136, 2005-02-07 21:31:08-08:00, nickpiggin@yahoo.com.au
   [PATCH] fix wait_task_inactive race
   
   When a task is put to sleep, it is dequeued from the runqueue while it is
   still running.  The problem is that one some arches that have non-atomic
   scheduling, the runqueue lock can be dropped and retaken in schedule() before
   the task actually schedules off, and wait_task_inactive did not account for
   this.
   
   Signed-off-by: Nick Piggin <nickpiggin@yahoo.com.au>
   Signed-off-by: Ingo Molnar <mingo@elte.hu>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2135, 2005-02-07 21:30:52-08:00, yust@anti-leasure.ru
   [PATCH] Add missing configure calls to intel agp resume code.
   
   Fix for resume on i850. Maybe for i855GM.
   
   Signed-off by: Nigel Cunningham <ncunningham@linuxmail.org>
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2134, 2005-02-07 21:30:37-08:00, hch@lst.de
   [PATCH] add MAP_POPULATE/sys_remap_file_pages support to XFS
   
   filemap_populate needs to be exported so that filesystems with their own
   vm_operations (like XFS) can use it.
   
   Cc: Nathan Scott <nathans@sgi.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2133, 2005-02-07 16:43:44-08:00, johnrose@austin.ibm.com
   [PATCH] PCI Hotplug: fix rpaphp firmware dependency
   
   Noted by David Woodhouse <dwmw2@infradead.org>
   
   Here's a fix for the ppc64 crash during boot.  This corrects the
   offending function to use more conventional error codes.  I'll follow up
   with return code cleanups for the entire module, and for RTAS code,
   since these are probably too big for 2.6.11. 
   
   Signed-off-by: John Rose <johnrose@austin.ibm.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2132, 2005-02-07 08:37:08-08:00, torvalds@ppc970.osdl.org
   Undo recent tty_io.c "fix".
   
   The fix was just trying to hide the real bug, which was in
   an old udev script. The change made matters worse.
   
   Cset exclude: pavenis@latnet.lv[torvalds]|ChangeSet|20050202164823|05506
 
 ChangeSet@1.2131, 2005-02-07 08:28:04-08:00, petero2@telia.com
   [PATCH] Make mousedev.c report all events to user space immediately
   
   mousedev_packet() clears list->ready too early when called with
   "tail == head - 1".  The effect is that the last mouse event from the
   hardware isn't reported to userspace until another hardware mouse
   event arrives.  This can make the left mouse button get stuck when
   tapping on a touchpad.  When this happens, the butten doesn't unstick
   until you interact with the touchpad again.
   
   Signed-off-by: Peter Osterlund <petero2@telia.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2128.1.2, 2005-02-07 03:41:33-05:00, jgarzik@pobox.com
   [BK] ignore drivers/md/raid6altivec[1248].c
 
 ChangeSet@1.2128.1.1, 2005-02-07 03:00:00-05:00, jgarzik@pobox.com
   [block sx8] fix warning
   
   As 'i' and 'host->id' are of different types (signed vs. unsigned),
   we need a cast.
   
   Eventually host->id should probably be made unsigned, but this
   requires further analysis.
 
 ChangeSet@1.2127.2.12, 2005-02-06 22:20:30-08:00, matthew@wil.cx
   [IPV4]: ipconfig should use memmove() instead of strcpy()
   
   strcpy is undefined if src and dest overlap.  That's clearly possible
   here with a sufficiently deep path on the server.  Use memmove instead.
   
   Signed-off-by: Matthew Wilcox <matthew@wil.cx>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.2.11, 2005-02-06 22:19:21-08:00, chas@cmf.nrl.navy.mil
   [ATM]: [zatm] replace sleep_on() with wait_event()
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.2.10, 2005-02-06 22:18:39-08:00, chas@cmf.nrl.navy.mil
   [ATM]: [iphase] remove sleep_on*() usage
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.2.9, 2005-02-06 22:17:47-08:00, chas@cmf.nrl.navy.mil
   [ATM]: [horizon] replace interruptible_sleep_on() with wait_event_interruptible()
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.2.8, 2005-02-06 22:11:58-08:00, bunk@stusta.de
   [CRYPTO]: Make some code static in i386 crypto AES.
   
   This patch makes some needlessly global code static.
   
   Signed-off-by: Adrian Bunk <bunk@stusta.de>
   Signed-off-by: James Morris <jmorris@redhat.com>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.2.7, 2005-02-06 22:00:12-08:00, tgraf@suug.ch
   [NETLINK]: Use SKB_MAXORDER to calculate NLMSG_GOODSIZE
   
   NLMSG_GOODSIZE specifies a good default size for the skb tailroom
   used in netlink messages when the size is unknown at the time of
   the allocation.
   
   The current value doesn't make much sense anymore because
   skb_shared_info isn't taken into account which means that
   depending on the architecture NLMSG_GOOSIZE can exceed PAGE_SIZE
   resulting in a waste of almost a complete page.
   
   Using SKB_MAXORDER solves this potential leak at the cost of
   slightly smaller but safer sizes for some architectures.
   
   Signed-off-by: Thomas Graf <tgraf@suug.ch>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.2.6, 2005-02-06 21:49:00-08:00, kaber@trash.net
   [NETFILTER]: Clean NAT status bits on module unload
   
   another patch which I think should go in 2.6.11, it fixes a crash
   when unloading, then reloading iptable_nat.
   
   ip_nat_core doesn't clear the status bits in struct ip_conntrack on
   module unload, but zeroes out the nat area. When the module is loaded
   again and a connection times out ip_nat_cleanup_conntrack tries to
   list_del the zeroed list-head and crashes. There are probably more
   conditions under which it can crash or cause other misbehaviour.
   
   Signed-off-by: Patrick McHardy <kaber@trash.net>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.2.4, 2005-02-06 21:43:24-08:00, shemminger@osdl.org
   [PKT_SCHED]: netem: memory leak
   
   Good catch.. netem needs to free skb's that are dropped due to loss
   simulation.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.2.3, 2005-02-06 21:41:12-08:00, yoshfuji@linux-ipv6.org
   [IPV6]: Fix tunnel list locking in ip6_tunnel.c
   
   We need to fix tunnel list locking in ip6_tunnel.c as well.
   Noticed by jean-mickael guerin <jean-mickael.guerin@6WIND.com>.
   
   Signed-off-by: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.2.2, 2005-02-06 21:40:01-08:00, kaber@trash.net
   [PKT_SCHED]: ipt action: add back pskb_expand_head() call
   
   Jamal asked me to add back the call to pskb_expand_head before 2.6.11.
   This fixes a regression caused by my tc action cleanup patches, the
   tc actions most not replace packets, so it must prevent netfilter from
   doing so.
   
   Signed-off-by: Patrick McHardy <kaber@trash.net>
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.1.3, 2005-02-06 21:20:23-08:00, davem@nuts.davemloft.net
   [DOC]: Some atomic_ops.txt updates.
   
   Based upon feedback from Linus:
   - Touch on xchg(), cmpxchg() and spinlocks lightly.
   - Discuss atomic_dec_and_test()
   - Add some historical platform notes.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.1.2, 2005-02-06 20:52:02-08:00, davem@nuts.davemloft.net
   [SPARC64]: Correct rwlock membars.
   
   read_unlock should order all previous memory operations
   before the atomic counter update to drop the lock.
   The debugging version of write_unlock had a similar error.
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.2127.1.1, 2005-02-06 20:43:48-08:00, davem@nuts.davemloft.net
   [SPARC64]: Add missing membars for xchg() and cmpxchg().
   
   Signed-off-by: David S. Miller <davem@davemloft.net>
 
 ChangeSet@1.1992.7.11, 2005-02-06 01:57:50-05:00, jgarzik@pobox.com
   [libata ahci] Add support for ULi M5288
   
   Contributed by Peer Chen @ ULi
 
 ChangeSet@1.1992.7.10, 2005-02-06 00:04:29-05:00, mkrikis@yahoo.com
   [PATCH] libata: fix ata_piix on ICH6R in RAID mode
   
   Here is the cleaned up patch (as you suggested) that enables ata_piix
   to work in RAID mode on ICH6R.  I tested it and it seems to behave
   correctly
   
   in all the modes---sees all 4 disks in IDE and RAID modes, doesn't
   see any in Compatibility mode (which is right, because only two are
   available and the regular IDE driver has picked them up already).
   
   
   Change description:  only test for PCI IDE legacy mode, via the
   PCI programming interface register, if the PCI device is of class
   PCI_CLASS_STORAGE_IDE.
   
   
   Signed-off-by: Martins Krikis <mkrikis@yahoo.com>
   Signed-off-by: Jeff Garzik <jgarzik@pobox.com>
 
 ChangeSet@1.1992.9.7, 2005-02-05 19:24:20-08:00, herbert@gondor.apana.org.au
 ChangeSet@1.1992.10.7, 2005-02-05 19:24:20-08:00, herbert@gondor.apana.org.au
 ChangeSet@1.1992.9.6, 2005-02-05 19:23:27-08:00, herbert@gondor.apana.org.au
 ChangeSet@1.1992.10.6, 2005-02-05 19:23:27-08:00, herbert@gondor.apana.org.au
 ChangeSet@1.1992.7.9, 2005-02-05 21:54:35-05:00, jpaana@s2.org
   [libata sata_promise] add PCI ID for new SATAII TX2 card
 
 ChangeSet@1.1992.7.8, 2005-02-05 21:29:11-05:00, syntax@pa.net
   [libata sata_sil] add another Seagate drive to blacklist
 
 ChangeSet@1.1992.7.7, 2005-02-05 21:20:34-05:00, zaitcev@redhat.com
   [libata] fix probe object allocation bugs
   
   The code previously alloced a 2-entry array, then freed each
   entry individually, for users of "combined mode".
   
   Convert code to use allocation function that only allocates
   one object at a time.
   
   Also, un-export ata_pci_init_legacy_mode(), as its only user is
   libata-core.
 
 ChangeSet@1.1992.7.6, 2005-02-05 20:22:23-05:00, russb@emc.com
   [libata scsi] verify cmd bug fixes/support
   
   Also, trim trailing whitespace.
 
 ChangeSet@1.2082.1.2, 2005-02-05 01:59:27+01:00, marcel@holtmann.org
   [Bluetooth] Support for Digianswer BPA 100/105 sniffers
   
   This adds a driver for the Digianswer BPA 100/105 USB sniffer
   devices. These devices are using a H:4 over H:2 host transport
   protocol for the HCI communication.
   
   Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
 
 ChangeSet@1.2082.1.1, 2005-02-05 01:55:56+01:00, marcel@holtmann.org
   [Bluetooth] Support Broadcom BCM92035 USB dongles
   
   This patch adds support for special initialization commands inside
   the Bluetooth core layer. It is used for the BCM92035 USB dongles
   from Broadcom to switch them from HID mode into HCI mode.
   
   Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
 
 ChangeSet@1.1992.9.5, 2005-02-03 15:18:37-08:00, herbert@gondor.apana.org.au
 ChangeSet@1.1992.10.5, 2005-02-03 15:18:37-08:00, herbert@gondor.apana.org.au
 ChangeSet@1.1992.10.17, 2005-02-03 16:59:05+01:00, bzolnier@trik.(none)
 ChangeSet@1.1992.11.17, 2005-02-03 16:59:05+01:00, bzolnier@trik.(none)
 ChangeSet@1.1992.10.16, 2005-02-03 16:52:26+01:00, prarit@sgi.com
 ChangeSet@1.1992.11.16, 2005-02-03 16:52:26+01:00, prarit@sgi.com
 ChangeSet@1.1992.10.15, 2005-02-03 16:50:28+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.15, 2005-02-03 16:50:28+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.14, 2005-02-03 16:48:42+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.14, 2005-02-03 16:48:42+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.13, 2005-02-03 16:47:16+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.13, 2005-02-03 16:47:16+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.12, 2005-02-03 16:45:57+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.12, 2005-02-03 16:45:57+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.11, 2005-02-03 16:44:41+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.11, 2005-02-03 16:44:41+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.10, 2005-02-03 16:43:04+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.10, 2005-02-03 16:43:04+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.9, 2005-02-03 16:41:20+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.9, 2005-02-03 16:41:20+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.8, 2005-02-03 16:39:36+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.8, 2005-02-03 16:39:36+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.7, 2005-02-03 16:38:05+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.7, 2005-02-03 16:38:05+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.6, 2005-02-03 16:36:41+01:00, bzolnier@trik.(none)
 ChangeSet@1.1992.11.6, 2005-02-03 16:36:41+01:00, bzolnier@trik.(none)
 ChangeSet@1.1992.10.5, 2005-02-03 16:35:12+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.5, 2005-02-03 16:35:12+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.4, 2005-02-03 16:33:36+01:00, tj@home-tj.org
 ChangeSet@1.1992.11.4, 2005-02-03 16:33:36+01:00, tj@home-tj.org
 ChangeSet@1.1992.10.3, 2005-02-03 16:29:50+01:00, bunk@stusta.de
 ChangeSet@1.1992.11.3, 2005-02-03 16:29:50+01:00, bunk@stusta.de
 ChangeSet@1.1992.10.2, 2005-02-03 16:21:14+01:00, arjan@infradead.org
 ChangeSet@1.1992.11.2, 2005-02-03 16:21:14+01:00, arjan@infradead.org
diff -purN linux-2.6.11-rc3-bk4/Documentation/atomic_ops.txt linux-2.6.11-rc3-bk5/Documentation/atomic_ops.txt
--- linux-2.6.11-rc3-bk4/Documentation/atomic_ops.txt	2005-02-08 15:30:45.945802170 +0100
+++ linux-2.6.11-rc3-bk5/Documentation/atomic_ops.txt	2005-02-08 15:30:51.983664136 +0100
@@ -4,8 +4,8 @@
 			  David S. Miller	 
 
 	This document is intended to serve as a guide to Linux port
-maintainers on how to implement atomic counter and bitops interfaces
-properly.
+maintainers on how to implement atomic counter, bitops, and spinlock
+interfaces properly.
 
 	The atomic_t type should be defined as a signed integer.
 Also, it should be made opaque such that any kind of cast to a normal
@@ -242,6 +242,19 @@ happen.  Specifically, in the above case
 counter decrement would not become globally visible until the
 obj->active update does.
 
+As a historical note, 32-bit Sparc used to only allow usage of
+24-bits of it's atomic_t type.  This was because it used 8 bits
+as a spinlock for SMP safety.  Sparc32 lacked a "compare and swap"
+type instruction.  However, 32-bit Sparc has since been moved over
+to a "hash table of spinlocks" scheme, that allows the full 32-bit
+counter to be realized.  Essentially, an array of spinlocks are
+indexed into based upon the address of the atomic_t being operated
+on, and that lock protects the atomic operation.  Parisc uses the
+same scheme.
+
+Another note is that the atomic_t operations returning values are
+extremely slow on an old 386.
+
 We will now cover the atomic bitmask operations.  You will find that
 their SMP and memory barrier semantics are similar in shape and scope
 to the atomic_t ops above.
@@ -345,3 +358,99 @@ except that two underscores are prefixed
 
 These non-atomic variants also do not require any special memory
 barrier semantics.
+
+The routines xchg() and cmpxchg() need the same exact memory barriers
+as the atomic and bit operations returning values.
+
+Spinlocks and rwlocks have memory barrier expectations as well.
+The rule to follow is simple:
+
+1) When acquiring a lock, the implementation must make it globally
+   visible before any subsequent memory operation.
+
+2) When releasing a lock, the implementation must make it such that
+   all previous memory operations are globally visible before the
+   lock release.
+
+Which finally brings us to _atomic_dec_and_lock().  There is an
+architecture-neutral version implemented in lib/dec_and_lock.c,
+but most platforms will wish to optimize this in assembler.
+
+	int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);
+
+Atomically decrement the given counter, and if will drop to zero
+atomically acquire the given spinlock and perform the decrement
+of the counter to zero.  If it does not drop to zero, do nothing
+with the spinlock.
+
+It is actually pretty simple to get the memory barrier correct.
+Simply satisfy the spinlock grab requirements, which is make
+sure the spinlock operation is globally visible before any
+subsequent memory operation.
+
+We can demonstrate this operation more clearly if we define
+an abstract atomic operation:
+
+	long cas(long *mem, long old, long new);
+
+"cas" stands for "compare and swap".  It atomically:
+
+1) Compares "old" with the value currently at "mem".
+2) If they are equal, "new" is written to "mem".
+3) Regardless, the current value at "mem" is returned.
+
+As an example usage, here is what an atomic counter update
+might look like:
+
+void example_atomic_inc(long *counter)
+{
+	long old, new, ret;
+
+	while (1) {
+		old = *counter;
+		new = old + 1;
+
+		ret = cas(counter, old, new);
+		if (ret == old)
+			break;
+	}
+}
+
+Let's use cas() in order to build a pseudo-C atomic_dec_and_lock():
+
+int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock)
+{
+	long old, new, ret;
+	int went_to_zero;
+
+	went_to_zero = 0;
+	while (1) {
+		old = atomic_read(atomic);
+		new = old - 1;
+		if (new == 0) {
+			went_to_zero = 1;
+			spin_lock(lock);
+		}
+		ret = cas(atomic, old, new);
+		if (ret == old)
+			break;
+		if (went_to_zero) {
+			spin_unlock(lock);
+			went_to_zero = 0;
+		}
+	}
+
+	return went_to_zero;
+}
+
+Now, as far as memory barriers go, as long as spin_lock()
+strictly orders all subsequent memory operations (including
+the cas()) with respect to itself, things will be fine.
+
+Said another way, _atomic_dec_and_lock() must guarentee that
+a counter dropping to zero is never made visible before the
+spinlock being acquired.
+
+Note that this also means that for the case where the counter
+is not dropping to zero, there are no memory ordering
+requirements.
diff -purN linux-2.6.11-rc3-bk4/Makefile linux-2.6.11-rc3-bk5/Makefile
--- linux-2.6.11-rc3-bk4/Makefile	2005-02-08 15:30:45.962799524 +0100
+++ linux-2.6.11-rc3-bk5/Makefile	2005-02-08 15:30:52.001793688 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc3-bk4
+EXTRAVERSION = -rc3-bk5
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc3-bk4/arch/i386/crypto/aes.c linux-2.6.11-rc3-bk5/arch/i386/crypto/aes.c
--- linux-2.6.11-rc3-bk4/arch/i386/crypto/aes.c	2005-02-03 02:55:53.000000000 +0100
+++ linux-2.6.11-rc3-bk5/arch/i386/crypto/aes.c	2005-02-08 15:30:52.018791042 +0100
@@ -93,12 +93,12 @@ static u32 rcon_tab[RC_LENGTH];
 
 u32 ft_tab[4][256];
 u32 fl_tab[4][256];
-u32 ls_tab[4][256];
-u32 im_tab[4][256];
+static u32 ls_tab[4][256];
+static u32 im_tab[4][256];
 u32 il_tab[4][256];
 u32 it_tab[4][256];
 
-void gen_tabs(void)
+static void gen_tabs(void)
 {
 	u32 i, w;
 	u8 pow[512], log[256];
diff -purN linux-2.6.11-rc3-bk4/arch/mips/lib-32/dump_tlb.c linux-2.6.11-rc3-bk5/arch/mips/lib-32/dump_tlb.c
--- linux-2.6.11-rc3-bk4/arch/mips/lib-32/dump_tlb.c	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk5/arch/mips/lib-32/dump_tlb.c	2005-02-08 15:30:52.176766448 +0100
@@ -32,6 +32,8 @@ static inline const char *msk2str(unsign
 	case PM_256M:	return "256Mb";
 #endif
 	}
+
+	return "unknown";
 }
 
 #define BARRIER()					\
diff -purN linux-2.6.11-rc3-bk4/arch/mips/lib-64/dump_tlb.c linux-2.6.11-rc3-bk5/arch/mips/lib-64/dump_tlb.c
--- linux-2.6.11-rc3-bk4/arch/mips/lib-64/dump_tlb.c	2005-02-03 02:57:16.000000000 +0100
+++ linux-2.6.11-rc3-bk5/arch/mips/lib-64/dump_tlb.c	2005-02-08 15:30:52.177766293 +0100
@@ -32,6 +32,8 @@ static inline const char *msk2str(unsign
 	case PM_256M:	return "256Mb";
 #endif
 	}
+
+	return "unknown";
 }
 
 #define BARRIER()					\
diff -purN linux-2.6.11-rc3-bk4/arch/sparc64/lib/debuglocks.c linux-2.6.11-rc3-bk5/arch/sparc64/lib/debuglocks.c
--- linux-2.6.11-rc3-bk4/arch/sparc64/lib/debuglocks.c	2005-02-03 02:56:10.000000000 +0100
+++ linux-2.6.11-rc3-bk5/arch/sparc64/lib/debuglocks.c	2005-02-08 15:30:52.258753685 +0100
@@ -172,6 +172,7 @@ void _do_read_unlock (rwlock_t *rw, char
 runlock_again:
 	/* Spin trying to decrement the counter using casx.  */
 	__asm__ __volatile__(
+"	membar	#StoreLoad | #LoadLoad\n"
 "	ldx	[%0], %%g5\n"
 "	sub	%%g5, 1, %%g7\n"
 "	casx	[%0], %%g5, %%g7\n"
@@ -290,6 +291,7 @@ void _do_write_unlock(rwlock_t *rw)
 	current->thread.smp_lock_count--;
 wlock_again:
 	__asm__ __volatile__(
+"	membar	#StoreLoad | #LoadLoad\n"
 "	mov	1, %%g3\n"
 "	sllx	%%g3, 63, %%g3\n"
 "	ldx	[%0], %%g5\n"
diff -purN linux-2.6.11-rc3-bk4/arch/um/kernel/skas/Makefile linux-2.6.11-rc3-bk5/arch/um/kernel/skas/Makefile
--- linux-2.6.11-rc3-bk4/arch/um/kernel/skas/Makefile	2005-02-03 02:55:35.000000000 +0100
+++ linux-2.6.11-rc3-bk5/arch/um/kernel/skas/Makefile	2005-02-08 15:30:52.268752128 +0100
@@ -11,3 +11,5 @@ USER_OBJS := $(foreach file,$(USER_OBJS)
 
 $(USER_OBJS) : %.o: %.c
 	$(CC) $(CFLAGS_$(notdir $@)) $(USER_CFLAGS) -c -o $@ $<
+
+subdir- := util
diff -purN linux-2.6.11-rc3-bk4/drivers/atm/horizon.c linux-2.6.11-rc3-bk5/drivers/atm/horizon.c
--- linux-2.6.11-rc3-bk4/drivers/atm/horizon.c	2005-02-03 02:54:38.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/atm/horizon.c	2005-02-08 15:30:52.279750416 +0100
@@ -39,6 +39,7 @@
 #include <linux/uio.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
+#include <linux/wait.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
@@ -1089,13 +1090,11 @@ static inline void rx_bus_master_complet
 /********** (queue to) become the next TX thread **********/
 
 static inline int tx_hold (hrz_dev * dev) {
-  while (test_and_set_bit (tx_busy, &dev->flags)) {
-    PRINTD (DBG_TX, "sleeping at tx lock %p %lu", dev, dev->flags);
-    interruptible_sleep_on (&dev->tx_queue);
-    PRINTD (DBG_TX, "woken at tx lock %p %lu", dev, dev->flags);
-    if (signal_pending (current))
-      return -1;
-  }
+  PRINTD (DBG_TX, "sleeping at tx lock %p %lu", dev, dev->flags);
+  wait_event_interruptible(dev->tx_queue, (!test_and_set_bit(tx_busy, &dev->flags)));
+  PRINTD (DBG_TX, "woken at tx lock %p %lu", dev, dev->flags);
+  if (signal_pending (current))
+    return -1;
   PRINTD (DBG_TX, "set tx_busy for dev %p", dev);
   return 0;
 }
diff -purN linux-2.6.11-rc3-bk4/drivers/atm/iphase.c linux-2.6.11-rc3-bk5/drivers/atm/iphase.c
--- linux-2.6.11-rc3-bk4/drivers/atm/iphase.c	2005-02-03 02:56:53.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/atm/iphase.c	2005-02-08 15:30:52.286749326 +0100
@@ -53,6 +53,7 @@
 #include <linux/delay.h>  
 #include <linux/uio.h>  
 #include <linux/init.h>  
+#include <linux/wait.h>
 #include <asm/system.h>  
 #include <asm/io.h>  
 #include <asm/atomic.h>  
@@ -2586,14 +2587,14 @@ err_out:
 }  
   
 static void ia_close(struct atm_vcc *vcc)  
-{  
+{
+	DEFINE_WAIT(wait);
         u16 *vc_table;
         IADEV *iadev;
         struct ia_vcc *ia_vcc;
         struct sk_buff *skb = NULL;
         struct sk_buff_head tmp_tx_backlog, tmp_vcc_backlog;
         unsigned long closetime, flags;
-        int ctimeout;
 
         iadev = INPH_IA_DEV(vcc->dev);
         ia_vcc = INPH_IA_VCC(vcc);
@@ -2606,7 +2607,9 @@ static void ia_close(struct atm_vcc *vcc
         skb_queue_head_init (&tmp_vcc_backlog); 
         if (vcc->qos.txtp.traffic_class != ATM_NONE) {
            iadev->close_pending++;
-           sleep_on_timeout(&iadev->timeout_wait, 50);
+	   prepare_to_wait(&iadev->timeout_wait, &wait, TASK_UNINTERRUPTIBLE);
+	   schedule_timeout(50);
+	   finish_wait(&iadev->timeout_wait, &wait);
            spin_lock_irqsave(&iadev->tx_lock, flags); 
            while((skb = skb_dequeue(&iadev->tx_backlog))) {
               if (ATM_SKB(skb)->vcc == vcc){ 
@@ -2619,17 +2622,12 @@ static void ia_close(struct atm_vcc *vcc
            while((skb = skb_dequeue(&tmp_tx_backlog))) 
              skb_queue_tail(&iadev->tx_backlog, skb);
            IF_EVENT(printk("IA TX Done decs_cnt = %d\n", ia_vcc->vc_desc_cnt);) 
-           closetime = jiffies;
-           ctimeout = 300000 / ia_vcc->pcr;
-           if (ctimeout == 0)
-              ctimeout = 1;
-           while (ia_vcc->vc_desc_cnt > 0){
-              if ((jiffies - closetime) >= ctimeout) 
-                 break;
-              spin_unlock_irqrestore(&iadev->tx_lock, flags);
-              sleep_on(&iadev->close_wait);
-              spin_lock_irqsave(&iadev->tx_lock, flags);
-           }    
+           closetime = 300000 / ia_vcc->pcr;
+           if (closetime == 0)
+              closetime = 1;
+           spin_unlock_irqrestore(&iadev->tx_lock, flags);
+           wait_event_timeout(iadev->close_wait, (ia_vcc->vc_desc_cnt <= 0), closetime);
+           spin_lock_irqsave(&iadev->tx_lock, flags);
            iadev->close_pending--;
            iadev->testTable[vcc->vci]->lastTime = 0;
            iadev->testTable[vcc->vci]->fract = 0; 
diff -purN linux-2.6.11-rc3-bk4/drivers/atm/zatm.c linux-2.6.11-rc3-bk5/drivers/atm/zatm.c
--- linux-2.6.11-rc3-bk4/drivers/atm/zatm.c	2005-02-03 02:55:22.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/atm/zatm.c	2005-02-08 15:30:52.290748704 +0100
@@ -22,6 +22,7 @@
 #include <linux/atm_zatm.h>
 #include <linux/capability.h>
 #include <linux/bitops.h>
+#include <linux/wait.h>
 #include <asm/byteorder.h>
 #include <asm/system.h>
 #include <asm/string.h>
@@ -867,31 +868,21 @@ static void close_tx(struct atm_vcc *vcc
 	struct zatm_vcc *zatm_vcc;
 	unsigned long flags;
 	int chan;
-struct sk_buff *skb;
-int once = 1;
 
 	zatm_vcc = ZATM_VCC(vcc);
 	zatm_dev = ZATM_DEV(vcc->dev);
 	chan = zatm_vcc->tx_chan;
 	if (!chan) return;
 	DPRINTK("close_tx\n");
-	while (skb_peek(&zatm_vcc->backlog)) {
-if (once) {
-printk("waiting for backlog to drain ...\n");
-event_dump();
-once = 0;
-}
-		sleep_on(&zatm_vcc->tx_wait);
-	}
-once = 1;
-	while ((skb = skb_peek(&zatm_vcc->tx_queue))) {
-if (once) {
-printk("waiting for TX queue to drain ... %p\n",skb);
-event_dump();
-once = 0;
-}
-		DPRINTK("waiting for TX queue to drain ... %p\n",skb);
-		sleep_on(&zatm_vcc->tx_wait);
+	if (skb_peek(&zatm_vcc->backlog)) {
+		printk("waiting for backlog to drain ...\n");
+		event_dump();
+		wait_event(zatm_vcc->tx_wait, !skb_peek(&zatm_vcc->backlog));
+	}
+	if (skb_peek(&zatm_vcc->tx_queue)) {
+		printk("waiting for TX queue to drain ...\n");
+		event_dump();
+		wait_event(zatm_vcc->tx_wait, !skb_peek(&zatm_vcc->tx_queue));
 	}
 	spin_lock_irqsave(&zatm_dev->lock, flags);
 #if 0
diff -purN linux-2.6.11-rc3-bk4/drivers/block/sx8.c linux-2.6.11-rc3-bk5/drivers/block/sx8.c
--- linux-2.6.11-rc3-bk4/drivers/block/sx8.c	2005-02-03 02:57:16.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/block/sx8.c	2005-02-08 15:30:52.293748237 +0100
@@ -1503,7 +1503,8 @@ static int carm_init_disks(struct carm_h
 		}
 
 		port->disk = disk;
-		sprintf(disk->disk_name, DRV_NAME "/%u", (host->id * CARM_MAX_PORTS) + i);
+		sprintf(disk->disk_name, DRV_NAME "/%u",
+			(unsigned int) (host->id * CARM_MAX_PORTS) + i);
 		sprintf(disk->devfs_name, DRV_NAME "/%u_%u", host->id, i);
 		disk->major = host->major;
 		disk->first_minor = i * CARM_MINORS_PER_MAJOR;
diff -purN linux-2.6.11-rc3-bk4/drivers/bluetooth/Kconfig linux-2.6.11-rc3-bk5/drivers/bluetooth/Kconfig
--- linux-2.6.11-rc3-bk4/drivers/bluetooth/Kconfig	2005-02-03 02:55:40.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/bluetooth/Kconfig	2005-02-08 15:30:52.294748081 +0100
@@ -75,6 +75,17 @@ config BT_HCIBCM203X
 	  Say Y here to compile support for HCI BCM203x devices into the
 	  kernel or say M to compile it as module (bcm203x).
 
+config BT_HCIBPA10X
+	tristate "HCI BPA10x USB driver"
+	depends on USB
+	help
+	  Bluetooth HCI BPA10x USB driver.
+	  This driver provides support for the Digianswer BPA 100/105 Bluetooth
+	  sniffer devices.
+
+	  Say Y here to compile support for HCI BPA10x devices into the
+	  kernel or say M to compile it as module (bpa10x).
+
 config BT_HCIBFUSB
 	tristate "HCI BlueFRITZ! USB driver"
 	depends on USB
diff -purN linux-2.6.11-rc3-bk4/drivers/bluetooth/Makefile linux-2.6.11-rc3-bk5/drivers/bluetooth/Makefile
--- linux-2.6.11-rc3-bk4/drivers/bluetooth/Makefile	2005-02-03 02:56:53.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/bluetooth/Makefile	2005-02-08 15:30:52.294748081 +0100
@@ -6,6 +6,7 @@ obj-$(CONFIG_BT_HCIUSB)		+= hci_usb.o
 obj-$(CONFIG_BT_HCIVHCI)	+= hci_vhci.o
 obj-$(CONFIG_BT_HCIUART)	+= hci_uart.o
 obj-$(CONFIG_BT_HCIBCM203X)	+= bcm203x.o
+obj-$(CONFIG_BT_HCIBPA10X)	+= bpa10x.o
 obj-$(CONFIG_BT_HCIBFUSB)	+= bfusb.o
 obj-$(CONFIG_BT_HCIDTL1)	+= dtl1_cs.o
 obj-$(CONFIG_BT_HCIBT3C)	+= bt3c_cs.o
diff -purN linux-2.6.11-rc3-bk4/drivers/bluetooth/bpa10x.c linux-2.6.11-rc3-bk5/drivers/bluetooth/bpa10x.c
--- linux-2.6.11-rc3-bk4/drivers/bluetooth/bpa10x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/bluetooth/bpa10x.c	2005-02-08 15:30:52.300747147 +0100
@@ -0,0 +1,657 @@
+/*
+ *
+ *  Digianswer Bluetooth USB driver
+ *
+ *  Copyright (C) 2004-2005  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+
+#include <linux/usb.h>
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+
+#ifndef CONFIG_BT_HCIBPA10X_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
+#define VERSION "0.8"
+
+static int ignore = 0;
+
+static struct usb_device_id bpa10x_table[] = {
+	/* Tektronix BPA 100/105 (Digianswer) */
+	{ USB_DEVICE(0x08fd, 0x0002) },
+
+	{ }	/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, bpa10x_table);
+
+#define BPA10X_CMD_EP		0x00
+#define BPA10X_EVT_EP		0x81
+#define BPA10X_TX_EP		0x02
+#define BPA10X_RX_EP		0x82
+
+#define BPA10X_CMD_BUF_SIZE	252
+#define BPA10X_EVT_BUF_SIZE	16
+#define BPA10X_TX_BUF_SIZE	384
+#define BPA10X_RX_BUF_SIZE	384
+
+struct bpa10x_data {
+	struct hci_dev		*hdev;
+	struct usb_device	*udev;
+
+	rwlock_t		lock;
+
+	struct sk_buff_head	cmd_queue;
+	struct urb		*cmd_urb;
+	struct urb		*evt_urb;
+	struct sk_buff		*evt_skb;
+	unsigned int		evt_len;
+
+	struct sk_buff_head	tx_queue;
+	struct urb		*tx_urb;
+	struct urb		*rx_urb;
+};
+
+#define HCI_VENDOR_HDR_SIZE	5
+
+struct hci_vendor_hdr {
+	__u8	type;
+	__u16	snum;
+	__u16	dlen;
+} __attribute__ ((packed));
+
+static void bpa10x_recv_bulk(struct bpa10x_data *data, unsigned char *buf, int count)
+{
+	struct hci_acl_hdr *ah;
+	struct hci_sco_hdr *sh;
+	struct hci_vendor_hdr *vh;
+	struct sk_buff *skb;
+	int len;
+
+	while (count) {
+		switch (*buf++) {
+		case HCI_ACLDATA_PKT:
+			ah = (struct hci_acl_hdr *) buf;
+			len = HCI_ACL_HDR_SIZE + __le16_to_cpu(ah->dlen);
+			skb = bt_skb_alloc(len, GFP_ATOMIC);
+			if (skb) {
+				memcpy(skb_put(skb, len), buf, len);
+				skb->dev = (void *) data->hdev;
+				skb->pkt_type = HCI_ACLDATA_PKT;
+				hci_recv_frame(skb);
+			}
+			break;
+
+		case HCI_SCODATA_PKT:
+			sh = (struct hci_sco_hdr *) buf;
+			len = HCI_SCO_HDR_SIZE + sh->dlen;
+			skb = bt_skb_alloc(len, GFP_ATOMIC);
+			if (skb) {
+				memcpy(skb_put(skb, len), buf, len);
+				skb->dev = (void *) data->hdev;
+				skb->pkt_type = HCI_SCODATA_PKT;
+				hci_recv_frame(skb);
+			}
+			break;
+
+		case HCI_VENDOR_PKT:
+			vh = (struct hci_vendor_hdr *) buf;
+			len = HCI_VENDOR_HDR_SIZE + __le16_to_cpu(vh->dlen);
+			skb = bt_skb_alloc(len, GFP_ATOMIC);
+			if (skb) {
+				memcpy(skb_put(skb, len), buf, len);
+				skb->dev = (void *) data->hdev;
+				skb->pkt_type = HCI_VENDOR_PKT;
+				hci_recv_frame(skb);
+			}
+			break;
+
+		default:
+			len = count - 1;
+			break;
+		}
+
+		buf   += len;
+		count -= (len + 1);
+	}
+}
+
+static int bpa10x_recv_event(struct bpa10x_data *data, unsigned char *buf, int size)
+{
+	BT_DBG("data %p buf %p size %d", data, buf, size);
+
+	if (data->evt_skb) {
+		struct sk_buff *skb = data->evt_skb;
+
+		memcpy(skb_put(skb, size), buf, size);
+
+		if (skb->len == data->evt_len) {
+			data->evt_skb = NULL;
+			data->evt_len = 0;
+			hci_recv_frame(skb);
+		}
+	} else {
+		struct sk_buff *skb;
+		struct hci_event_hdr *hdr;
+		unsigned char pkt_type;
+		int pkt_len = 0;
+
+		if (size < HCI_EVENT_HDR_SIZE + 1) {
+			BT_ERR("%s event packet block with size %d is too short",
+							data->hdev->name, size);
+			return -EILSEQ;
+		}
+
+		pkt_type = *buf++;
+		size--;
+
+		if (pkt_type != HCI_EVENT_PKT) {
+			BT_ERR("%s unexpected event packet start byte 0x%02x",
+							data->hdev->name, pkt_type);
+			return -EPROTO;
+		}
+
+		hdr = (struct hci_event_hdr *) buf;
+		pkt_len = HCI_EVENT_HDR_SIZE + hdr->plen;
+
+		skb = bt_skb_alloc(pkt_len, GFP_ATOMIC);
+		if (!skb) {
+			BT_ERR("%s no memory for new event packet",
+							data->hdev->name);
+			return -ENOMEM;
+		}
+
+		skb->dev = (void *) data->hdev;
+		skb->pkt_type = pkt_type;
+
+		memcpy(skb_put(skb, size), buf, size);
+
+		if (pkt_len == size) {
+			hci_recv_frame(skb);
+		} else {
+			data->evt_skb = skb;
+			data->evt_len = pkt_len;
+		}
+	}
+
+	return 0;
+}
+
+static void bpa10x_wakeup(struct bpa10x_data *data)
+{
+	struct urb *urb;
+	struct sk_buff *skb;
+	int err;
+
+	BT_DBG("data %p", data);
+
+	urb = data->cmd_urb;
+	if (urb->status == -EINPROGRESS)
+		skb = NULL;
+	else
+		skb = skb_dequeue(&data->cmd_queue);
+
+	if (skb) {
+		struct usb_ctrlrequest *cr;
+
+		if (skb->len > BPA10X_CMD_BUF_SIZE) {
+			BT_ERR("%s command packet with size %d is too big",
+							data->hdev->name, skb->len);
+			kfree_skb(skb);
+			return;
+		}
+
+		cr = (struct usb_ctrlrequest *) urb->setup_packet;
+		cr->wLength = __cpu_to_le16(skb->len);
+
+		memcpy(urb->transfer_buffer, skb->data, skb->len);
+		urb->transfer_buffer_length = skb->len;
+
+		err = usb_submit_urb(urb, GFP_ATOMIC);
+		if (err < 0 && err != -ENODEV) {
+			BT_ERR("%s submit failed for command urb %p with error %d",
+							data->hdev->name, urb, err);
+			skb_queue_head(&data->cmd_queue, skb);
+		} else
+			kfree_skb(skb);
+	}
+
+	urb = data->tx_urb;
+	if (urb->status == -EINPROGRESS)
+		skb = NULL;
+	else
+		skb = skb_dequeue(&data->tx_queue);
+
+	if (skb) {
+		memcpy(urb->transfer_buffer, skb->data, skb->len);
+		urb->transfer_buffer_length = skb->len;
+
+		err = usb_submit_urb(urb, GFP_ATOMIC);
+		if (err < 0 && err != -ENODEV) {
+			BT_ERR("%s submit failed for command urb %p with error %d",
+							data->hdev->name, urb, err);
+			skb_queue_head(&data->tx_queue, skb);
+		} else
+			kfree_skb(skb);
+	}
+}
+
+static void bpa10x_complete(struct urb *urb, struct pt_regs *regs)
+{
+	struct bpa10x_data *data = urb->context;
+	unsigned char *buf = urb->transfer_buffer;
+	int err, count = urb->actual_length;
+
+	BT_DBG("data %p urb %p buf %p count %d", data, urb, buf, count);
+
+	read_lock(&data->lock);
+
+	if (!test_bit(HCI_RUNNING, &data->hdev->flags))
+		goto unlock;
+
+	if (urb->status < 0 || !count)
+		goto resubmit;
+
+	if (usb_pipein(urb->pipe)) {
+		data->hdev->stat.byte_rx += count;
+
+		if (usb_pipetype(urb->pipe) == PIPE_INTERRUPT)
+			bpa10x_recv_event(data, buf, count);
+
+		if (usb_pipetype(urb->pipe) == PIPE_BULK)
+			bpa10x_recv_bulk(data, buf, count);
+	} else {
+		data->hdev->stat.byte_tx += count;
+
+		bpa10x_wakeup(data);
+	}
+
+resubmit:
+	if (usb_pipein(urb->pipe)) {
+		err = usb_submit_urb(urb, GFP_ATOMIC);
+		if (err < 0 && err != -ENODEV) {
+			BT_ERR("%s urb %p type %d resubmit status %d",
+				data->hdev->name, urb, usb_pipetype(urb->pipe), err);
+		}
+	}
+
+unlock:
+	read_unlock(&data->lock);
+}
+
+static inline struct urb *bpa10x_alloc_urb(struct usb_device *udev, unsigned int pipe, size_t size, int flags, void *data)
+{
+	struct urb *urb;
+	struct usb_ctrlrequest *cr;
+	unsigned char *buf;
+
+	BT_DBG("udev %p data %p", udev, data);
+
+	urb = usb_alloc_urb(0, flags);
+	if (!urb)
+		return NULL;
+
+	buf = kmalloc(size, flags);
+	if (!buf) {
+		usb_free_urb(urb);
+		return NULL;
+	}
+
+	switch (usb_pipetype(pipe)) {
+	case PIPE_CONTROL:
+		cr = kmalloc(sizeof(*cr), flags);
+		if (!cr) {
+			kfree(buf);
+			usb_free_urb(urb);
+			return NULL;
+		}
+
+		cr->bRequestType = USB_TYPE_VENDOR;
+		cr->bRequest     = 0;
+		cr->wIndex       = 0;
+		cr->wValue       = 0;
+		cr->wLength      = __cpu_to_le16(0);
+
+		usb_fill_control_urb(urb, udev, pipe, (void *) cr, buf, 0, bpa10x_complete, data);
+		break;
+
+	case PIPE_INTERRUPT:
+		usb_fill_int_urb(urb, udev, pipe, buf, size, bpa10x_complete, data, 1);
+		break;
+
+	case PIPE_BULK:
+		usb_fill_bulk_urb(urb, udev, pipe, buf, size, bpa10x_complete, data);
+		break;
+
+	default:
+		kfree(buf);
+		usb_free_urb(urb);
+		return NULL;
+	}
+
+	return urb;
+}
+
+static inline void bpa10x_free_urb(struct urb *urb)
+{
+	BT_DBG("urb %p", urb);
+
+	if (!urb)
+		return;
+
+	if (urb->setup_packet)
+		kfree(urb->setup_packet);
+
+	if (urb->transfer_buffer)
+		kfree(urb->transfer_buffer);
+
+	usb_free_urb(urb);
+}
+
+static int bpa10x_open(struct hci_dev *hdev)
+{
+	struct bpa10x_data *data = hdev->driver_data;
+	struct usb_device *udev = data->udev;
+	unsigned long flags;
+	int err;
+
+	BT_DBG("hdev %p data %p", hdev, data);
+
+	if (test_and_set_bit(HCI_RUNNING, &hdev->flags))
+		return 0;
+
+	data->cmd_urb = bpa10x_alloc_urb(udev, usb_sndctrlpipe(udev, BPA10X_CMD_EP),
+					BPA10X_CMD_BUF_SIZE, GFP_KERNEL, data);
+	if (!data->cmd_urb) {
+		err = -ENOMEM;
+		goto done;
+	}
+
+	data->evt_urb = bpa10x_alloc_urb(udev, usb_rcvintpipe(udev, BPA10X_EVT_EP),
+					BPA10X_EVT_BUF_SIZE, GFP_KERNEL, data);
+	if (!data->evt_urb) {
+		bpa10x_free_urb(data->cmd_urb);
+		err = -ENOMEM;
+		goto done;
+	}
+
+	data->rx_urb = bpa10x_alloc_urb(udev, usb_rcvbulkpipe(udev, BPA10X_RX_EP),
+					BPA10X_RX_BUF_SIZE, GFP_KERNEL, data);
+	if (!data->rx_urb) {
+		bpa10x_free_urb(data->evt_urb);
+		bpa10x_free_urb(data->cmd_urb);
+		err = -ENOMEM;
+		goto done;
+	}
+
+	data->tx_urb = bpa10x_alloc_urb(udev, usb_sndbulkpipe(udev, BPA10X_TX_EP),
+					BPA10X_TX_BUF_SIZE, GFP_KERNEL, data);
+	if (!data->rx_urb) {
+		bpa10x_free_urb(data->rx_urb);
+		bpa10x_free_urb(data->evt_urb);
+		bpa10x_free_urb(data->cmd_urb);
+		err = -ENOMEM;
+		goto done;
+	}
+
+	write_lock_irqsave(&data->lock, flags);
+
+	err = usb_submit_urb(data->evt_urb, GFP_ATOMIC);
+	if (err < 0) {
+		BT_ERR("%s submit failed for event urb %p with error %d",
+					data->hdev->name, data->evt_urb, err);
+	} else {
+		err = usb_submit_urb(data->rx_urb, GFP_ATOMIC);
+		if (err < 0) {
+			BT_ERR("%s submit failed for rx urb %p with error %d",
+					data->hdev->name, data->evt_urb, err);
+			usb_kill_urb(data->evt_urb);
+		}
+	}
+
+	write_unlock_irqrestore(&data->lock, flags);
+
+done:
+	if (err < 0)
+		clear_bit(HCI_RUNNING, &hdev->flags);
+
+	return err;
+}
+
+static int bpa10x_close(struct hci_dev *hdev)
+{
+	struct bpa10x_data *data = hdev->driver_data;
+	unsigned long flags;
+
+	BT_DBG("hdev %p data %p", hdev, data);
+
+	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
+		return 0;
+
+	write_lock_irqsave(&data->lock, flags);
+
+	skb_queue_purge(&data->cmd_queue);
+	usb_kill_urb(data->cmd_urb);
+	usb_kill_urb(data->evt_urb);
+	usb_kill_urb(data->rx_urb);
+	usb_kill_urb(data->tx_urb);
+
+	write_unlock_irqrestore(&data->lock, flags);
+
+	bpa10x_free_urb(data->cmd_urb);
+	bpa10x_free_urb(data->evt_urb);
+	bpa10x_free_urb(data->rx_urb);
+	bpa10x_free_urb(data->tx_urb);
+
+	return 0;
+}
+
+static int bpa10x_flush(struct hci_dev *hdev)
+{
+	struct bpa10x_data *data = hdev->driver_data;
+
+	BT_DBG("hdev %p data %p", hdev, data);
+
+	skb_queue_purge(&data->cmd_queue);
+
+	return 0;
+}
+
+static int bpa10x_send_frame(struct sk_buff *skb)
+{
+	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+	struct bpa10x_data *data;
+
+	BT_DBG("hdev %p skb %p type %d len %d", hdev, skb, skb->pkt_type, skb->len);
+
+	if (!hdev) {
+		BT_ERR("Frame for unknown HCI device");
+		return -ENODEV;
+	}
+
+	if (!test_bit(HCI_RUNNING, &hdev->flags))
+		return -EBUSY;
+
+	data = hdev->driver_data;
+
+	/* Prepend skb with frame type */
+	memcpy(skb_push(skb, 1), &(skb->pkt_type), 1);
+
+	switch (skb->pkt_type) {
+	case HCI_COMMAND_PKT:
+		hdev->stat.cmd_tx++;
+		skb_queue_tail(&data->cmd_queue, skb);
+		break;
+
+	case HCI_ACLDATA_PKT:
+		hdev->stat.acl_tx++;
+		skb_queue_tail(&data->tx_queue, skb);
+		break;
+
+	case HCI_SCODATA_PKT:
+		hdev->stat.sco_tx++;
+		skb_queue_tail(&data->tx_queue, skb);
+		break;
+	};
+
+	read_lock(&data->lock);
+
+	bpa10x_wakeup(data);
+
+	read_unlock(&data->lock);
+
+	return 0;
+}
+
+static void bpa10x_destruct(struct hci_dev *hdev)
+{
+	struct bpa10x_data *data = hdev->driver_data;
+
+	BT_DBG("hdev %p data %p", hdev, data);
+
+	kfree(data);
+}
+
+static int bpa10x_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct hci_dev *hdev;
+	struct bpa10x_data *data;
+	int err;
+
+	BT_DBG("intf %p id %p", intf, id);
+
+	if (ignore)
+		return -ENODEV;
+
+	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		BT_ERR("Can't allocate data structure");
+		return -ENOMEM;
+	}
+
+	memset(data, 0, sizeof(*data));
+
+	data->udev = udev;
+
+	rwlock_init(&data->lock);
+
+	skb_queue_head_init(&data->cmd_queue);
+	skb_queue_head_init(&data->tx_queue);
+
+	hdev = hci_alloc_dev();
+	if (!hdev) {
+		BT_ERR("Can't allocate HCI device");
+		kfree(data);
+		return -ENOMEM;
+	}
+
+	data->hdev = hdev;
+
+	hdev->type = HCI_USB;
+	hdev->driver_data = data;
+	SET_HCIDEV_DEV(hdev, &intf->dev);
+
+	hdev->open	= bpa10x_open;
+	hdev->close	= bpa10x_close;
+	hdev->flush	= bpa10x_flush;
+	hdev->send	= bpa10x_send_frame;
+	hdev->destruct	= bpa10x_destruct;
+
+	hdev->owner = THIS_MODULE;
+
+	err = hci_register_dev(hdev);
+	if (err < 0) {
+		BT_ERR("Can't register HCI device");
+		kfree(data);
+		hci_free_dev(hdev);
+		return err;
+	}
+
+	usb_set_intfdata(intf, data);
+
+	return 0;
+}
+
+static void bpa10x_disconnect(struct usb_interface *intf)
+{
+	struct bpa10x_data *data = usb_get_intfdata(intf);
+	struct hci_dev *hdev = data->hdev;
+
+	BT_DBG("intf %p", intf);
+
+	if (!hdev)
+		return;
+
+	usb_set_intfdata(intf, NULL);
+
+	if (hci_unregister_dev(hdev) < 0)
+		BT_ERR("Can't unregister HCI device %s", hdev->name);
+
+	hci_free_dev(hdev);
+}
+
+static struct usb_driver bpa10x_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "bpa10x",
+	.probe		= bpa10x_probe,
+	.disconnect	= bpa10x_disconnect,
+	.id_table	= bpa10x_table,
+};
+
+static int __init bpa10x_init(void)
+{
+	int err;
+
+	BT_INFO("Digianswer Bluetooth USB driver ver %s", VERSION);
+
+	err = usb_register(&bpa10x_driver);
+	if (err < 0)
+		BT_ERR("Failed to register USB driver");
+
+	return err;
+}
+
+static void __exit bpa10x_exit(void)
+{
+	usb_deregister(&bpa10x_driver);
+}
+
+module_init(bpa10x_init);
+module_exit(bpa10x_exit);
+
+module_param(ignore, bool, 0644);
+MODULE_PARM_DESC(ignore, "Ignore devices from the matching table");
+
+MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
+MODULE_DESCRIPTION("Digianswer Bluetooth USB driver ver " VERSION);
+MODULE_VERSION(VERSION);
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.11-rc3-bk4/drivers/bluetooth/hci_usb.c linux-2.6.11-rc3-bk5/drivers/bluetooth/hci_usb.c
--- linux-2.6.11-rc3-bk4/drivers/bluetooth/hci_usb.c	2005-02-03 02:56:48.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/bluetooth/hci_usb.c	2005-02-08 15:30:52.303746680 +0100
@@ -73,7 +73,7 @@ static int reset = 0;
 static int isoc = 2;
 #endif
 
-#define VERSION "2.7"
+#define VERSION "2.8"
 
 static struct usb_driver hci_usb_driver; 
 
@@ -104,11 +104,11 @@ static struct usb_device_id blacklist_id
 	{ USB_DEVICE(0x0a5c, 0x2033), .driver_info = HCI_IGNORE },
 
 	/* Broadcom BCM2035 */
-	{ USB_DEVICE(0x0a5c, 0x2009), .driver_info = HCI_RESET | HCI_BROKEN_ISOC },
 	{ USB_DEVICE(0x0a5c, 0x200a), .driver_info = HCI_RESET | HCI_BROKEN_ISOC },
+	{ USB_DEVICE(0x0a5c, 0x2009), .driver_info = HCI_BCM92035 },
 
 	/* Microsoft Wireless Transceiver for Bluetooth 2.0 */
-	{ USB_DEVICE(0x045e, 0x009c), .driver_info = HCI_RESET | HCI_BROKEN_ISOC },
+	{ USB_DEVICE(0x045e, 0x009c), .driver_info = HCI_BCM92035 },
 
 	/* ISSC Bluetooth Adapter v3.1 */
 	{ USB_DEVICE(0x1131, 0x1001), .driver_info = HCI_RESET },
@@ -977,6 +977,17 @@ static int hci_usb_probe(struct usb_inte
 			set_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);
 	}
 
+	if (id->driver_info & HCI_BCM92035) {
+		unsigned char cmd[] = { 0x3b, 0xfc, 0x01, 0x00 };
+		struct sk_buff *skb;
+
+		skb = bt_skb_alloc(sizeof(cmd), GFP_KERNEL);
+		if (skb) {
+			memcpy(skb_put(skb, sizeof(cmd)), cmd, sizeof(cmd));
+			skb_queue_tail(&hdev->driver_init, skb);
+		}
+	}
+
 	if (hci_register_dev(hdev) < 0) {
 		BT_ERR("Can't register HCI device");
 		hci_free_dev(hdev);
diff -purN linux-2.6.11-rc3-bk4/drivers/bluetooth/hci_usb.h linux-2.6.11-rc3-bk5/drivers/bluetooth/hci_usb.h
--- linux-2.6.11-rc3-bk4/drivers/bluetooth/hci_usb.h	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/bluetooth/hci_usb.h	2005-02-08 15:30:52.304746525 +0100
@@ -33,6 +33,7 @@
 #define HCI_DIGIANSWER		0x04
 #define HCI_SNIFFER		0x08
 #define HCI_BROKEN_ISOC		0x10
+#define HCI_BCM92035		0x20
 
 #define HCI_MAX_IFACE_NUM	3
 
diff -purN linux-2.6.11-rc3-bk4/drivers/char/agp/intel-agp.c linux-2.6.11-rc3-bk5/drivers/char/agp/intel-agp.c
--- linux-2.6.11-rc3-bk4/drivers/char/agp/intel-agp.c	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/char/agp/intel-agp.c	2005-02-08 15:30:52.307746058 +0100
@@ -1748,12 +1748,16 @@ static int agp_intel_resume(struct pci_d
 
 	if (bridge->driver == &intel_generic_driver)
 		intel_configure();
+	else if (bridge->driver == &intel_850_driver)
+		intel_850_configure();
 	else if (bridge->driver == &intel_845_driver)
 		intel_845_configure();
 	else if (bridge->driver == &intel_830mp_driver)
 		intel_830mp_configure();
 	else if (bridge->driver == &intel_915_driver)
 		intel_i915_configure();
+	else if (bridge->driver == &intel_830_driver)
+		intel_i830_configure();
 
 	return 0;
 }
diff -purN linux-2.6.11-rc3-bk4/drivers/char/tty_io.c linux-2.6.11-rc3-bk5/drivers/char/tty_io.c
--- linux-2.6.11-rc3-bk4/drivers/char/tty_io.c	2005-02-03 02:56:10.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/char/tty_io.c	2005-02-08 15:30:52.322743723 +0100
@@ -1156,8 +1156,8 @@ static inline void pty_line_name(struct 
 	int i = index + driver->name_base;
 	/* ->name is initialized to "ttyp", but "tty" is expected */
 	sprintf(p, "%s%c%x",
-		driver->subtype == PTY_TYPE_SLAVE ? "pty" : driver->name,
-		ptychar[i >> 4 & 0xf], i & 0xf);
+			driver->subtype == PTY_TYPE_SLAVE ? "tty" : driver->name,
+			ptychar[i >> 4 & 0xf], i & 0xf);
 }
 
 static inline void tty_line_name(struct tty_driver *driver, int index, char *p)
diff -purN linux-2.6.11-rc3-bk4/drivers/input/mousedev.c linux-2.6.11-rc3-bk5/drivers/input/mousedev.c
--- linux-2.6.11-rc3-bk4/drivers/input/mousedev.c	2005-02-03 02:56:48.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/input/mousedev.c	2005-02-08 15:30:52.453723332 +0100
@@ -467,10 +467,10 @@ static void mousedev_packet(struct mouse
 	}
 
 	if (!p->dx && !p->dy && !p->dz) {
-		if (list->tail != list->head)
-			list->tail = (list->tail + 1) % PACKET_QUEUE_LEN;
 		if (list->tail == list->head)
 			list->ready = 0;
+		else
+			list->tail = (list->tail + 1) % PACKET_QUEUE_LEN;
 	}
 
 	spin_unlock_irqrestore(&list->packet_lock, flags);
diff -purN linux-2.6.11-rc3-bk4/drivers/pci/hotplug/rpaphp_core.c linux-2.6.11-rc3-bk5/drivers/pci/hotplug/rpaphp_core.c
--- linux-2.6.11-rc3-bk4/drivers/pci/hotplug/rpaphp_core.c	2005-02-08 15:30:46.508714536 +0100
+++ linux-2.6.11-rc3-bk5/drivers/pci/hotplug/rpaphp_core.c	2005-02-08 15:30:52.516713526 +0100
@@ -224,7 +224,7 @@ static int get_children_props(struct dev
 
 	if (!indexes || !names || !types || !domains) {
 		/* Slot does not have dynamically-removable children */
-		return 1;
+		return -EINVAL;
 	}
 	if (drc_indexes)
 		*drc_indexes = indexes;
@@ -260,7 +260,7 @@ int rpaphp_get_drc_props(struct device_n
 	}
 
 	rc = get_children_props(dn->parent, &indexes, &names, &types, &domains);
-	if (rc) {
+	if (rc < 0) {
 		return 1;
 	}
 
@@ -307,7 +307,7 @@ static int is_php_dn(struct device_node 
 	int rc;
 
 	rc = get_children_props(dn, indexes, names, &drc_types, power_domains);
-	if (rc) {
+	if (rc >= 0) {
 		if (is_php_type((char *) &drc_types[1])) {
 			*types = drc_types;
 			return 1;
@@ -331,7 +331,7 @@ static int is_dr_dn(struct device_node *
 
 	rc = get_children_props(dn->parent, indexes, names, types,
 				power_domains);
-	return (rc == 0);
+	return (rc >= 0);
 }
 
 static inline int is_vdevice_root(struct device_node *dn)
diff -purN linux-2.6.11-rc3-bk4/drivers/scsi/ahci.c linux-2.6.11-rc3-bk5/drivers/scsi/ahci.c
--- linux-2.6.11-rc3-bk4/drivers/scsi/ahci.c	2005-02-03 02:55:22.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/scsi/ahci.c	2005-02-08 15:30:52.577704031 +0100
@@ -250,6 +250,8 @@ static struct pci_device_id ahci_pci_tbl
 	  board_ahci }, /* ICH7R */
 	{ PCI_VENDOR_ID_INTEL, 0x27c3, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	  board_ahci }, /* ICH7R */
+	{ PCI_VENDOR_ID_AL, 0x5288, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+	  board_ahci }, /* ULi M5288 */
 	{ }	/* terminate list */
 };
 
diff -purN linux-2.6.11-rc3-bk4/drivers/scsi/libata-core.c linux-2.6.11-rc3-bk5/drivers/scsi/libata-core.c
--- linux-2.6.11-rc3-bk4/drivers/scsi/libata-core.c	2005-02-03 02:54:38.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/scsi/libata-core.c	2005-02-08 15:30:52.588702318 +0100
@@ -1700,6 +1700,69 @@ err_out:
 	DPRINTK("EXIT\n");
 }
 
+static void ata_pr_blacklisted(struct ata_port *ap, struct ata_device *dev)
+{
+	printk(KERN_WARNING "ata%u: dev %u is on DMA blacklist, disabling DMA\n",
+		ap->id, dev->devno);
+}
+
+static const char * ata_dma_blacklist [] = {
+	"WDC AC11000H",
+	"WDC AC22100H",
+	"WDC AC32500H",
+	"WDC AC33100H",
+	"WDC AC31600H",
+	"WDC AC32100H",
+	"WDC AC23200L",
+	"Compaq CRD-8241B",
+	"CRD-8400B",
+	"CRD-8480B",
+	"CRD-8482B",
+ 	"CRD-84",
+	"SanDisk SDP3B",
+	"SanDisk SDP3B-64",
+	"SANYO CD-ROM CRD",
+	"HITACHI CDR-8",
+	"HITACHI CDR-8335",
+	"HITACHI CDR-8435",
+	"Toshiba CD-ROM XM-6202B",
+	"CD-532E-A",
+	"E-IDE CD-ROM CR-840",
+	"CD-ROM Drive/F5A",
+	"WPI CDD-820",
+	"SAMSUNG CD-ROM SC-148C",
+	"SAMSUNG CD-ROM SC",
+	"SanDisk SDP3B-64",
+	"SAMSUNG CD-ROM SN-124",
+	"ATAPI CD-ROM DRIVE 40X MAXIMUM",
+	"_NEC DV5800A",
+};
+
+static int ata_dma_blacklisted(struct ata_port *ap, struct ata_device *dev)
+{
+	unsigned char model_num[40];
+	char *s;
+	unsigned int len;
+	int i;
+
+	ata_dev_id_string(dev->id, model_num, ATA_ID_PROD_OFS,
+			  sizeof(model_num));
+	s = &model_num[0];
+	len = strnlen(s, sizeof(model_num));
+
+	/* ATAPI specifies that empty space is blank-filled; remove blanks */
+	while ((len > 0) && (s[len - 1] == ' ')) {
+		len--;
+		s[len] = 0;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ata_dma_blacklist); i++)
+		if (!strncmp(ata_dma_blacklist[i], s, len))
+			return 1;
+
+	return 0;
+}
+
 static unsigned int ata_get_mode_mask(struct ata_port *ap, int shift)
 {
 	struct ata_device *master, *slave;
@@ -1712,17 +1775,37 @@ static unsigned int ata_get_mode_mask(st
 
 	if (shift == ATA_SHIFT_UDMA) {
 		mask = ap->udma_mask;
-		if (ata_dev_present(master))
+		if (ata_dev_present(master)) {
 			mask &= (master->id[ATA_ID_UDMA_MODES] & 0xff);
-		if (ata_dev_present(slave))
+			if (ata_dma_blacklisted(ap, master)) {
+				mask = 0;
+				ata_pr_blacklisted(ap, master);
+			}
+		}
+		if (ata_dev_present(slave)) {
 			mask &= (slave->id[ATA_ID_UDMA_MODES] & 0xff);
+			if (ata_dma_blacklisted(ap, slave)) {
+				mask = 0;
+				ata_pr_blacklisted(ap, slave);
+			}
+		}
 	}
 	else if (shift == ATA_SHIFT_MWDMA) {
 		mask = ap->mwdma_mask;
-		if (ata_dev_present(master))
+		if (ata_dev_present(master)) {
 			mask &= (master->id[ATA_ID_MWDMA_MODES] & 0x07);
-		if (ata_dev_present(slave))
+			if (ata_dma_blacklisted(ap, master)) {
+				mask = 0;
+				ata_pr_blacklisted(ap, master);
+			}
+		}
+		if (ata_dev_present(slave)) {
 			mask &= (slave->id[ATA_ID_MWDMA_MODES] & 0x07);
+			if (ata_dma_blacklisted(ap, slave)) {
+				mask = 0;
+				ata_pr_blacklisted(ap, slave);
+			}
+		}
 	}
 	else if (shift == ATA_SHIFT_PIO) {
 		mask = ap->pio_mask;
@@ -3452,32 +3535,28 @@ void ata_std_ports(struct ata_ioports *i
 }
 
 static struct ata_probe_ent *
-ata_probe_ent_alloc(int n, struct device *dev, struct ata_port_info **port)
+ata_probe_ent_alloc(struct device *dev, struct ata_port_info *port)
 {
 	struct ata_probe_ent *probe_ent;
-	int i;
 
-	probe_ent = kmalloc(sizeof(*probe_ent) * n, GFP_KERNEL);
+	probe_ent = kmalloc(sizeof(*probe_ent), GFP_KERNEL);
 	if (!probe_ent) {
 		printk(KERN_ERR DRV_NAME "(%s): out of memory\n",
 		       kobject_name(&(dev->kobj)));
 		return NULL;
 	}
 
-	memset(probe_ent, 0, sizeof(*probe_ent) * n);
+	memset(probe_ent, 0, sizeof(*probe_ent));
 
-	for (i = 0; i < n; i++) {
-		INIT_LIST_HEAD(&probe_ent[i].node);
-		probe_ent[i].dev = dev;
-
-		probe_ent[i].sht = port[i]->sht;
-		probe_ent[i].host_flags = port[i]->host_flags;
-		probe_ent[i].pio_mask = port[i]->pio_mask;
-		probe_ent[i].mwdma_mask = port[i]->mwdma_mask;
-		probe_ent[i].udma_mask = port[i]->udma_mask;
-		probe_ent[i].port_ops = port[i]->port_ops;
+	INIT_LIST_HEAD(&probe_ent->node);
+	probe_ent->dev = dev;
 
-	}
+	probe_ent->sht = port->sht;
+	probe_ent->host_flags = port->host_flags;
+	probe_ent->pio_mask = port->pio_mask;
+	probe_ent->mwdma_mask = port->mwdma_mask;
+	probe_ent->udma_mask = port->udma_mask;
+	probe_ent->port_ops = port->port_ops;
 
 	return probe_ent;
 }
@@ -3487,7 +3566,7 @@ struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port)
 {
 	struct ata_probe_ent *probe_ent =
-		ata_probe_ent_alloc(1, pci_dev_to_dev(pdev), port);
+		ata_probe_ent_alloc(pci_dev_to_dev(pdev), port[0]);
 	if (!probe_ent)
 		return NULL;
 
@@ -3513,39 +3592,47 @@ ata_pci_init_native_mode(struct pci_dev 
 	return probe_ent;
 }
 
-struct ata_probe_ent *
-ata_pci_init_legacy_mode(struct pci_dev *pdev, struct ata_port_info **port)
+static struct ata_probe_ent *
+ata_pci_init_legacy_mode(struct pci_dev *pdev, struct ata_port_info **port,
+    struct ata_probe_ent **ppe2)
 {
-	struct ata_probe_ent *probe_ent =
-		ata_probe_ent_alloc(2, pci_dev_to_dev(pdev), port);
+	struct ata_probe_ent *probe_ent, *probe_ent2;
+
+	probe_ent = ata_probe_ent_alloc(pci_dev_to_dev(pdev), port[0]);
 	if (!probe_ent)
 		return NULL;
+	probe_ent2 = ata_probe_ent_alloc(pci_dev_to_dev(pdev), port[1]);
+	if (!probe_ent2) {
+		kfree(probe_ent);
+		return NULL;
+	}
+
+	probe_ent->n_ports = 1;
+	probe_ent->irq = 14;
 
-	probe_ent[0].n_ports = 1;
-	probe_ent[0].irq = 14;
+	probe_ent->hard_port_no = 0;
+	probe_ent->legacy_mode = 1;
 
-	probe_ent[0].hard_port_no = 0;
-	probe_ent[0].legacy_mode = 1;
+	probe_ent2->n_ports = 1;
+	probe_ent2->irq = 15;
 
-	probe_ent[1].n_ports = 1;
-	probe_ent[1].irq = 15;
+	probe_ent2->hard_port_no = 1;
+	probe_ent2->legacy_mode = 1;
 
-	probe_ent[1].hard_port_no = 1;
-	probe_ent[1].legacy_mode = 1;
-
-	probe_ent[0].port[0].cmd_addr = 0x1f0;
-	probe_ent[0].port[0].altstatus_addr =
-	probe_ent[0].port[0].ctl_addr = 0x3f6;
-	probe_ent[0].port[0].bmdma_addr = pci_resource_start(pdev, 4);
-
-	probe_ent[1].port[0].cmd_addr = 0x170;
-	probe_ent[1].port[0].altstatus_addr =
-	probe_ent[1].port[0].ctl_addr = 0x376;
-	probe_ent[1].port[0].bmdma_addr = pci_resource_start(pdev, 4)+8;
+	probe_ent->port[0].cmd_addr = 0x1f0;
+	probe_ent->port[0].altstatus_addr =
+	probe_ent->port[0].ctl_addr = 0x3f6;
+	probe_ent->port[0].bmdma_addr = pci_resource_start(pdev, 4);
 
-	ata_std_ports(&probe_ent[0].port[0]);
-	ata_std_ports(&probe_ent[1].port[0]);
+	probe_ent2->port[0].cmd_addr = 0x170;
+	probe_ent2->port[0].altstatus_addr =
+	probe_ent2->port[0].ctl_addr = 0x376;
+	probe_ent2->port[0].bmdma_addr = pci_resource_start(pdev, 4)+8;
+
+	ata_std_ports(&probe_ent->port[0]);
+	ata_std_ports(&probe_ent2->port[0]);
 
+	*ppe2 = probe_ent2;
 	return probe_ent;
 }
 
@@ -3579,7 +3666,8 @@ int ata_pci_init_one (struct pci_dev *pd
 	else
 		port[1] = port[0];
 
-	if ((port[0]->host_flags & ATA_FLAG_NO_LEGACY) == 0) {
+	if ((port[0]->host_flags & ATA_FLAG_NO_LEGACY) == 0
+	    && (pdev->class >> 8) == PCI_CLASS_STORAGE_IDE) {
 		/* TODO: support transitioning to native mode? */
 		pci_read_config_byte(pdev, PCI_CLASS_PROG, &tmp8);
 		mask = (1 << 2) | (1 << 0);
@@ -3641,9 +3729,7 @@ int ata_pci_init_one (struct pci_dev *pd
 		goto err_out_regions;
 
 	if (legacy_mode) {
-		probe_ent = ata_pci_init_legacy_mode(pdev, port);
-		if (probe_ent)
-			probe_ent2 = &probe_ent[1];
+		probe_ent = ata_pci_init_legacy_mode(pdev, port, &probe_ent2);
 	} else
 		probe_ent = ata_pci_init_native_mode(pdev, port);
 	if (!probe_ent) {
@@ -3657,8 +3743,12 @@ int ata_pci_init_one (struct pci_dev *pd
 	if (legacy_mode) {
 		if (legacy_mode & (1 << 0))
 			ata_device_add(probe_ent);
+		else
+			kfree(probe_ent);
 		if (legacy_mode & (1 << 1))
 			ata_device_add(probe_ent2);
+		else
+			kfree(probe_ent2);
 	} else {
 		ata_device_add(probe_ent);
 	}
@@ -3848,7 +3938,6 @@ EXPORT_SYMBOL_GPL(ata_scsi_simulate);
 
 #ifdef CONFIG_PCI
 EXPORT_SYMBOL_GPL(pci_test_config_bits);
-EXPORT_SYMBOL_GPL(ata_pci_init_legacy_mode);
 EXPORT_SYMBOL_GPL(ata_pci_init_native_mode);
 EXPORT_SYMBOL_GPL(ata_pci_init_one);
 EXPORT_SYMBOL_GPL(ata_pci_remove_one);
diff -purN linux-2.6.11-rc3-bk4/drivers/scsi/libata-scsi.c linux-2.6.11-rc3-bk5/drivers/scsi/libata-scsi.c
--- linux-2.6.11-rc3-bk4/drivers/scsi/libata-scsi.c	2005-02-03 02:55:39.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/scsi/libata-scsi.c	2005-02-08 15:30:52.592701696 +0100
@@ -202,7 +202,7 @@ void ata_to_sense_error(struct ata_queue
 		{0x40, 		MEDIUM_ERROR, 0x11, 0x04}, 	// Uncorrectable ECC error      Unrecovered read error
 		/* BBD - block marked bad */
 		{0x80, 		MEDIUM_ERROR, 0x11, 0x04}, 	// Block marked bad		  Medium error, unrecovered read error
-		{0xFF, 0xFF, 0xFF, 0xFF}, // END mark 
+		{0xFF, 0xFF, 0xFF, 0xFF}, // END mark
 	};
 	static unsigned char stat_table[][4] = {
 		/* Must be first because BUSY means no other bits valid */
@@ -210,22 +210,22 @@ void ata_to_sense_error(struct ata_queue
 		{0x20, 		HARDWARE_ERROR,  0x00, 0x00}, 	// Device fault
 		{0x08, 		ABORTED_COMMAND, 0x47, 0x00},	// Timed out in xfer, fake parity for now
 		{0x04, 		RECOVERED_ERROR, 0x11, 0x00},	// Recovered ECC error	  Medium error, recovered
-		{0xFF, 0xFF, 0xFF, 0xFF}, // END mark 
+		{0xFF, 0xFF, 0xFF, 0xFF}, // END mark
 	};
 	int i = 0;
 
 	cmd->result = SAM_STAT_CHECK_CONDITION;
-	
+
 	/*
 	 *	Is this an error we can process/parse
 	 */
-	 
+
 	if(drv_stat & ATA_ERR)
 		/* Read the err bits */
 		err = ata_chk_err(qc->ap);
 
 	/* Display the ATA level error info */
-	
+
 	printk(KERN_WARNING "ata%u: status=0x%02x { ", qc->ap->id, drv_stat);
 	if(drv_stat & 0x80)
 	{
@@ -242,7 +242,7 @@ void ata_to_sense_error(struct ata_queue
 		if(drv_stat & 0x01)	printk("Error ");
 	}
 	printk("}\n");
-	
+
 	if(err)
 	{
 		printk(KERN_WARNING "ata%u: error=0x%02x { ", qc->ap->id, err);
@@ -259,11 +259,11 @@ void ata_to_sense_error(struct ata_queue
 		if(err & 0x02)		printk("TrackZeroNotFound ");
 		if(err & 0x01)		printk("AddrMarkNotFound ");
 		printk("}\n");
-		
+
 		/* Should we dump sector info here too ?? */
 	}
-		
-	
+
+
 	/* Look for err */
 	while(sense_table[i][0] != 0xFF)
 	{
@@ -301,7 +301,7 @@ void ata_to_sense_error(struct ata_queue
 	/* No error ?? */
 	printk(KERN_ERR "ata%u: called with no error (%02X)!\n", qc->ap->id, drv_stat);
 	/* additional-sense-code[-qualifier] */
-	
+
 	sb[0] = 0x70;
 	sb[2] = MEDIUM_ERROR;
 	sb[7] = 0x0A;
@@ -488,19 +488,24 @@ static unsigned int ata_scsi_verify_xlat
 	}
 
 	if (lba48) {
+		tf->command = ATA_CMD_VERIFY_EXT;
+
 		tf->hob_nsect = (n_sect >> 8) & 0xff;
 
 		tf->hob_lbah = (sect >> 40) & 0xff;
 		tf->hob_lbam = (sect >> 32) & 0xff;
 		tf->hob_lbal = (sect >> 24) & 0xff;
-	} else
+	} else {
+		tf->command = ATA_CMD_VERIFY;
+
 		tf->device |= (sect >> 24) & 0xf;
+	}
 
 	tf->nsect = n_sect & 0xff;
 
-	tf->hob_lbah = (sect >> 16) & 0xff;
-	tf->hob_lbam = (sect >> 8) & 0xff;
-	tf->hob_lbal = sect & 0xff;
+	tf->lbah = (sect >> 16) & 0xff;
+	tf->lbam = (sect >> 8) & 0xff;
+	tf->lbal = sect & 0xff;
 
 	return 0;
 }
@@ -600,7 +605,7 @@ static unsigned int ata_scsi_rw_xlat(str
 				return 1;
 
 			/* stores LBA27:24 in lower 4 bits of device reg */
-			tf->device |= scsicmd[2];
+			tf->device |= scsicmd[6];
 
 			qc->nsect = scsicmd[13];
 		}
diff -purN linux-2.6.11-rc3-bk4/drivers/scsi/qla2xxx/qla_os.c linux-2.6.11-rc3-bk5/drivers/scsi/qla2xxx/qla_os.c
--- linux-2.6.11-rc3-bk4/drivers/scsi/qla2xxx/qla_os.c	2005-02-03 02:56:54.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/scsi/qla2xxx/qla_os.c	2005-02-08 15:30:52.599700606 +0100
@@ -859,7 +859,7 @@ qla2x00_queuecommand(struct scsi_cmnd *c
 	 * In all other cases we'll let an irq pick up our IO and submit it
 	 * to the controller to improve affinity.
 	 */
-	if (smp_processor_id() == ha->last_irq_cpu || was_empty)
+	if (_smp_processor_id() == ha->last_irq_cpu || was_empty)
 		qla2x00_next(ha);
 
 	spin_lock_irq(ha->host->host_lock);
diff -purN linux-2.6.11-rc3-bk4/drivers/scsi/sata_nv.c linux-2.6.11-rc3-bk5/drivers/scsi/sata_nv.c
--- linux-2.6.11-rc3-bk4/drivers/scsi/sata_nv.c	2005-02-03 02:55:15.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/scsi/sata_nv.c	2005-02-08 15:30:52.602700139 +0100
@@ -20,6 +20,10 @@
  *  If you do not delete the provisions above, a recipient may use your
  *  version of this file under either the OSL or the GPL.
  *
+ *  0.06
+ *     - Added generic SATA support by using a pci_device_id that filters on
+ *       the IDE storage class code.
+ *
  *  0.03
  *     - Fixed a bug where the hotplug handlers for non-CK804/MCP04 were using
  *       mmio_base, which is only set for the CK804/MCP04 case.
@@ -44,7 +48,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME			"sata_nv"
-#define DRV_VERSION			"0.5"
+#define DRV_VERSION			"0.6"
 
 #define NV_PORTS			2
 #define NV_PIO_MASK			0x1f
@@ -108,6 +112,7 @@ static void nv_check_hotplug_ck804(struc
 
 enum nv_host_type
 {
+	GENERIC,
 	NFORCE2,
 	NFORCE3,
 	CK804
@@ -128,6 +133,9 @@ static struct pci_device_id nv_pci_tbl[]
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, CK804 },
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP04_SATA2,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, CK804 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,
+		PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_STORAGE_IDE<<8, 0xffff00, GENERIC },
 	{ 0, } /* terminate list */
 };
 
@@ -136,7 +144,6 @@ static struct pci_device_id nv_pci_tbl[]
 struct nv_host_desc
 {
 	enum nv_host_type	host_type;
-	unsigned long		host_flags;
 	void			(*enable_hotplug)(struct ata_probe_ent *probe_ent);
 	void			(*disable_hotplug)(struct ata_host_set *host_set);
 	void			(*check_hotplug)(struct ata_host_set *host_set);
@@ -144,21 +151,24 @@ struct nv_host_desc
 };
 static struct nv_host_desc nv_device_tbl[] = {
 	{
+		.host_type	= GENERIC,
+		.enable_hotplug	= NULL,
+		.disable_hotplug= NULL,
+		.check_hotplug	= NULL,
+	},
+	{
 		.host_type	= NFORCE2,
-		.host_flags	= 0x00000000,
 		.enable_hotplug	= nv_enable_hotplug,
 		.disable_hotplug= nv_disable_hotplug,
 		.check_hotplug	= nv_check_hotplug,
 	},
 	{
 		.host_type	= NFORCE3,
-		.host_flags	= 0x00000000,
 		.enable_hotplug	= nv_enable_hotplug,
 		.disable_hotplug= nv_disable_hotplug,
 		.check_hotplug	= nv_check_hotplug,
 	},
 	{	.host_type	= CK804,
-		.host_flags	= NV_HOST_FLAGS_SCR_MMIO,
 		.enable_hotplug	= nv_enable_hotplug_ck804,
 		.disable_hotplug= nv_disable_hotplug_ck804,
 		.check_hotplug	= nv_check_hotplug_ck804,
@@ -168,6 +178,7 @@ static struct nv_host_desc nv_device_tbl
 struct nv_host
 {
 	struct nv_host_desc	*host_desc;
+	unsigned long		host_flags;
 };
 
 static struct pci_driver nv_pci_driver = {
@@ -284,8 +295,8 @@ static u32 nv_scr_read (struct ata_port 
 	if (sc_reg > SCR_CONTROL)
 		return 0xffffffffU;
 
-	if (host->host_desc->host_flags & NV_HOST_FLAGS_SCR_MMIO)
-		return readl(ap->ioaddr.scr_addr + (sc_reg * 4));
+	if (host->host_flags & NV_HOST_FLAGS_SCR_MMIO)
+		return readl((void*)ap->ioaddr.scr_addr + (sc_reg * 4));
 	else
 		return inl(ap->ioaddr.scr_addr + (sc_reg * 4));
 }
@@ -298,8 +309,8 @@ static void nv_scr_write (struct ata_por
 	if (sc_reg > SCR_CONTROL)
 		return;
 
-	if (host->host_desc->host_flags & NV_HOST_FLAGS_SCR_MMIO)
-		writel(val, ap->ioaddr.scr_addr + (sc_reg * 4));
+	if (host->host_flags & NV_HOST_FLAGS_SCR_MMIO)
+		writel(val, (void*)ap->ioaddr.scr_addr + (sc_reg * 4));
 	else
 		outl(val, ap->ioaddr.scr_addr + (sc_reg * 4));
 }
@@ -322,6 +333,14 @@ static int nv_init_one (struct pci_dev *
 	struct ata_port_info *ppi;
 	struct ata_probe_ent *probe_ent;
 	int rc;
+	u32 bar;
+
+        // Make sure this is a SATA controller by counting the number of bars
+        // (NVIDIA SATA controllers will always have six bars).  Otherwise,
+        // it's an IDE controller and we ignore it.
+	for (bar=0; bar<6; bar++)
+		if (pci_resource_start(pdev, bar) == 0)
+			return -ENODEV;
 
 	if (!printed_version++)
 		printk(KERN_DEBUG DRV_NAME " version " DRV_VERSION "\n");
@@ -352,11 +371,15 @@ static int nv_init_one (struct pci_dev *
 	if (!host)
 		goto err_out_free_ent;
 
+	memset(host, 0, sizeof(struct nv_host));
 	host->host_desc = &nv_device_tbl[ent->driver_data];
 
 	probe_ent->private_data = host;
 
-	if (host->host_desc->host_flags & NV_HOST_FLAGS_SCR_MMIO) {
+	if (pci_resource_flags(pdev, 5) & IORESOURCE_MEM)
+		host->host_flags |= NV_HOST_FLAGS_SCR_MMIO;
+
+	if (host->host_flags & NV_HOST_FLAGS_SCR_MMIO) {
 		unsigned long base;
 
 		probe_ent->mmio_base = ioremap(pci_resource_start(pdev, 5),
@@ -395,7 +418,7 @@ static int nv_init_one (struct pci_dev *
 	return 0;
 
 err_out_iounmap:
-	if (host->host_desc->host_flags & NV_HOST_FLAGS_SCR_MMIO)
+	if (host->host_flags & NV_HOST_FLAGS_SCR_MMIO)
 		iounmap(probe_ent->mmio_base);
 err_out_free_host:
 	kfree(host);
diff -purN linux-2.6.11-rc3-bk4/drivers/scsi/sata_promise.c linux-2.6.11-rc3-bk5/drivers/scsi/sata_promise.c
--- linux-2.6.11-rc3-bk4/drivers/scsi/sata_promise.c	2005-02-03 02:56:22.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/scsi/sata_promise.c	2005-02-08 15:30:52.604699828 +0100
@@ -156,10 +156,18 @@ static struct pci_device_id pdc_ata_pci_
 	  board_2037x },
 	{ PCI_VENDOR_ID_PROMISE, 0x3376, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	  board_2037x },
+	{ PCI_VENDOR_ID_PROMISE, 0x3574, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+	  board_2037x },
+	{ PCI_VENDOR_ID_PROMISE, 0x3d75, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+	  board_2037x },
+
 	{ PCI_VENDOR_ID_PROMISE, 0x3318, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	  board_20319 },
 	{ PCI_VENDOR_ID_PROMISE, 0x3319, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 	  board_20319 },
+	{ PCI_VENDOR_ID_PROMISE, 0x3d18, PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+	  board_20319 },
+
 	{ }	/* terminate list */
 };
 
@@ -406,9 +414,11 @@ static irqreturn_t pdc_interrupt (int ir
 		return IRQ_NONE;
 	}
 
-        spin_lock(&host_set->lock);
+	spin_lock(&host_set->lock);
+
+	writel(mask, mmio_base + PDC_INT_SEQMASK);
 
-        for (i = 0; i < host_set->n_ports; i++) {
+	for (i = 0; i < host_set->n_ports; i++) {
 		VPRINTK("port %u\n", i);
 		ap = host_set->ports[i];
 		tmp = mask & (1 << (i + 1));
diff -purN linux-2.6.11-rc3-bk4/drivers/scsi/sata_sil.c linux-2.6.11-rc3-bk5/drivers/scsi/sata_sil.c
--- linux-2.6.11-rc3-bk4/drivers/scsi/sata_sil.c	2005-02-03 02:54:38.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/scsi/sata_sil.c	2005-02-08 15:30:52.606699517 +0100
@@ -86,6 +86,7 @@ struct sil_drivelist {
 	{ "ST330013AS",		SIL_QUIRK_MOD15WRITE },
 	{ "ST340017AS",		SIL_QUIRK_MOD15WRITE },
 	{ "ST360015AS",		SIL_QUIRK_MOD15WRITE },
+	{ "ST380013AS",		SIL_QUIRK_MOD15WRITE },
 	{ "ST380023AS",		SIL_QUIRK_MOD15WRITE },
 	{ "ST3120023AS",	SIL_QUIRK_MOD15WRITE },
 	{ "ST3160023AS",	SIL_QUIRK_MOD15WRITE },
diff -purN linux-2.6.11-rc3-bk4/drivers/serial/8250.c linux-2.6.11-rc3-bk5/drivers/serial/8250.c
--- linux-2.6.11-rc3-bk4/drivers/serial/8250.c	2005-02-03 02:55:02.000000000 +0100
+++ linux-2.6.11-rc3-bk5/drivers/serial/8250.c	2005-02-08 15:30:52.611698738 +0100
@@ -987,8 +987,11 @@ receive_chars(struct uart_8250_port *up,
 		/* The following is not allowed by the tty layer and
 		   unsafe. It should be fixed ASAP */
 		if (unlikely(tty->flip.count >= TTY_FLIPBUF_SIZE)) {
-			if(tty->low_latency)
+			if (tty->low_latency) {
+				spin_unlock(&up->port.lock);
 				tty_flip_buffer_push(tty);
+				spin_lock(&up->port.lock);
+			}
 			/* If this failed then we will throw away the
 			   bytes but must do so to clear interrupts */
 		}
@@ -1059,7 +1062,9 @@ receive_chars(struct uart_8250_port *up,
 	ignore_char:
 		lsr = serial_inp(up, UART_LSR);
 	} while ((lsr & UART_LSR_DR) && (max_count-- > 0));
+	spin_unlock(&up->port.lock);
 	tty_flip_buffer_push(tty);
+	spin_lock(&up->port.lock);
 	*status = lsr;
 }
 
diff -purN linux-2.6.11-rc3-bk4/fs/hostfs/hostfs.h linux-2.6.11-rc3-bk5/fs/hostfs/hostfs.h
--- linux-2.6.11-rc3-bk4/fs/hostfs/hostfs.h	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk5/fs/hostfs/hostfs.h	2005-02-08 15:30:52.662690800 +0100
@@ -16,9 +16,30 @@
 #define HOSTFS_ATTR_CTIME	64
 #define HOSTFS_ATTR_ATIME_SET	128
 #define HOSTFS_ATTR_MTIME_SET	256
+
+/* These two are unused by hostfs. */
 #define HOSTFS_ATTR_FORCE	512	/* Not a change, but a change it */
 #define HOSTFS_ATTR_ATTR_FLAG	1024
 
+/* If you are very careful, you'll notice that these two are missing:
+ *
+ * #define ATTR_KILL_SUID	2048
+ * #define ATTR_KILL_SGID	4096
+ *
+ * and this is because they were added in 2.5 development in this patch:
+ *
+ * http://linux.bkbits.net:8080/linux-2.5/
+ * cset@3caf4a12k4XgDzK7wyK-TGpSZ9u2Ww?nav=index.html
+ * |src/.|src/include|src/include/linux|related/include/linux/fs.h
+ *
+ * Actually, they are not needed by most ->setattr() methods - they are set by
+ * callers of notify_change() to notify that the setuid/setgid bits must be
+ * dropped.
+ * notify_change() will delete those flags, make sure attr->ia_valid & ATTR_MODE
+ * is on, and remove the appropriate bits from attr->ia_mode (attr is a
+ * "struct iattr *"). -BlaisorBlade
+ */
+
 struct hostfs_iattr {
 	unsigned int	ia_valid;
 	mode_t		ia_mode;
diff -purN linux-2.6.11-rc3-bk4/fs/hostfs/hostfs_kern.c linux-2.6.11-rc3-bk5/fs/hostfs/hostfs_kern.c
--- linux-2.6.11-rc3-bk4/fs/hostfs/hostfs_kern.c	2005-02-03 02:55:15.000000000 +0100
+++ linux-2.6.11-rc3-bk5/fs/hostfs/hostfs_kern.c	2005-02-08 15:30:52.664690489 +0100
@@ -823,6 +823,10 @@ int hostfs_setattr(struct dentry *dentry
 	char *name;
 	int err;
 
+	err = inode_change_ok(dentry->d_inode, attr);
+	if (err)
+		return err;
+
 	if(append)
 		attr->ia_valid &= ~ATTR_SIZE;
 
diff -purN linux-2.6.11-rc3-bk4/fs/xfs/linux-2.6/xfs_file.c linux-2.6.11-rc3-bk5/fs/xfs/linux-2.6/xfs_file.c
--- linux-2.6.11-rc3-bk4/fs/xfs/linux-2.6/xfs_file.c	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk5/fs/xfs/linux-2.6/xfs_file.c	2005-02-08 15:30:52.672689243 +0100
@@ -531,6 +531,7 @@ struct file_operations linvfs_dir_operat
 
 static struct vm_operations_struct linvfs_file_vm_ops = {
 	.nopage		= filemap_nopage,
+	.populate	= filemap_populate,
 #ifdef HAVE_VMOP_MPROTECT
 	.mprotect	= linvfs_mprotect,
 #endif
diff -purN linux-2.6.11-rc3-bk4/include/asm-sparc64/spinlock.h linux-2.6.11-rc3-bk5/include/asm-sparc64/spinlock.h
--- linux-2.6.11-rc3-bk4/include/asm-sparc64/spinlock.h	2005-02-03 02:55:15.000000000 +0100
+++ linux-2.6.11-rc3-bk5/include/asm-sparc64/spinlock.h	2005-02-08 15:30:52.784671810 +0100
@@ -171,12 +171,13 @@ static void inline __read_unlock(rwlock_
 	unsigned long tmp1, tmp2;
 
 	__asm__ __volatile__(
+"	membar	#StoreLoad | #LoadLoad\n"
 "1:	lduw	[%2], %0\n"
 "	sub	%0, 1, %1\n"
 "	cas	[%2], %0, %1\n"
 "	cmp	%0, %1\n"
 "	bne,pn	%%xcc, 1b\n"
-"	 membar	#StoreLoad | #StoreStore"
+"	 nop"
 	: "=&r" (tmp1), "=&r" (tmp2)
 	: "r" (lock)
 	: "memory");
diff -purN linux-2.6.11-rc3-bk4/include/asm-sparc64/system.h linux-2.6.11-rc3-bk5/include/asm-sparc64/system.h
--- linux-2.6.11-rc3-bk4/include/asm-sparc64/system.h	2005-02-08 15:30:46.734679358 +0100
+++ linux-2.6.11-rc3-bk5/include/asm-sparc64/system.h	2005-02-08 15:30:52.786671499 +0100
@@ -229,6 +229,7 @@ do {	if (test_thread_flag(TIF_PERFCTR)) 
 static __inline__ unsigned long xchg32(__volatile__ unsigned int *m, unsigned int val)
 {
 	__asm__ __volatile__(
+"	membar		#StoreLoad | #LoadLoad\n"
 "	mov		%0, %%g5\n"
 "1:	lduw		[%2], %%g7\n"
 "	cas		[%2], %%g7, %0\n"
@@ -245,6 +246,7 @@ static __inline__ unsigned long xchg32(_
 static __inline__ unsigned long xchg64(__volatile__ unsigned long *m, unsigned long val)
 {
 	__asm__ __volatile__(
+"	membar		#StoreLoad | #LoadLoad\n"
 "	mov		%0, %%g5\n"
 "1:	ldx		[%2], %%g7\n"
 "	casx		[%2], %%g7, %0\n"
@@ -289,7 +291,8 @@ extern void die_if_kernel(char *str, str
 static __inline__ unsigned long
 __cmpxchg_u32(volatile int *m, int old, int new)
 {
-	__asm__ __volatile__("cas [%2], %3, %0\n\t"
+	__asm__ __volatile__("membar #StoreLoad | #LoadLoad\n"
+			     "cas [%2], %3, %0\n\t"
 			     "membar #StoreLoad | #StoreStore"
 			     : "=&r" (new)
 			     : "0" (new), "r" (m), "r" (old)
@@ -301,7 +304,8 @@ __cmpxchg_u32(volatile int *m, int old, 
 static __inline__ unsigned long
 __cmpxchg_u64(volatile long *m, unsigned long old, unsigned long new)
 {
-	__asm__ __volatile__("casx [%2], %3, %0\n\t"
+	__asm__ __volatile__("membar #StoreLoad | #LoadLoad\n"
+			     "casx [%2], %3, %0\n\t"
 			     "membar #StoreLoad | #StoreStore"
 			     : "=&r" (new)
 			     : "0" (new), "r" (m), "r" (old)
diff -purN linux-2.6.11-rc3-bk4/include/asm-x86_64/system.h linux-2.6.11-rc3-bk5/include/asm-x86_64/system.h
--- linux-2.6.11-rc3-bk4/include/asm-x86_64/system.h	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk5/include/asm-x86_64/system.h	2005-02-08 15:30:52.791670720 +0100
@@ -35,7 +35,7 @@
 		     "thread_return:\n\t"					    \
 		     "movq %%gs:%P[pda_pcurrent],%%rsi\n\t"			  \
 		     "movq %P[thread_info](%%rsi),%%r8\n\t"			  \
-		     "btr  %[tif_fork],%P[ti_flags](%%r8)\n\t"			  \
+		     LOCK "btr  %[tif_fork],%P[ti_flags](%%r8)\n\t"		  \
 		     "movq %%rax,%%rdi\n\t" 					  \
 		     "jc   ret_from_fork\n\t"					  \
 		     RESTORE_CONTEXT						    \
diff -purN linux-2.6.11-rc3-bk4/include/linux/ata.h linux-2.6.11-rc3-bk5/include/linux/ata.h
--- linux-2.6.11-rc3-bk4/include/linux/ata.h	2005-02-03 02:56:10.000000000 +0100
+++ linux-2.6.11-rc3-bk5/include/linux/ata.h	2005-02-08 15:30:52.793670409 +0100
@@ -123,6 +123,8 @@ enum {
 	ATA_CMD_PIO_WRITE_EXT	= 0x34,
 	ATA_CMD_SET_FEATURES	= 0xEF,
 	ATA_CMD_PACKET		= 0xA0,
+	ATA_CMD_VERIFY		= 0x40,
+	ATA_CMD_VERIFY_EXT	= 0x42,
 
 	/* SETFEATURES stuff */
 	SETFEATURES_XFER	= 0x03,
diff -purN linux-2.6.11-rc3-bk4/include/linux/libata.h linux-2.6.11-rc3-bk5/include/linux/libata.h
--- linux-2.6.11-rc3-bk4/include/linux/libata.h	2005-02-03 02:54:59.000000000 +0100
+++ linux-2.6.11-rc3-bk5/include/linux/libata.h	2005-02-08 15:30:52.806668386 +0100
@@ -436,8 +436,6 @@ struct pci_bits {
 
 extern struct ata_probe_ent *
 ata_pci_init_native_mode(struct pci_dev *pdev, struct ata_port_info **port);
-extern struct ata_probe_ent *
-ata_pci_init_legacy_mode(struct pci_dev *pdev, struct ata_port_info **port);
 extern int pci_test_config_bits(struct pci_dev *pdev, struct pci_bits *bits);
 
 #endif /* CONFIG_PCI */
diff -purN linux-2.6.11-rc3-bk4/include/linux/mm.h linux-2.6.11-rc3-bk5/include/linux/mm.h
--- linux-2.6.11-rc3-bk4/include/linux/mm.h	2005-02-08 15:30:46.751810911 +0100
+++ linux-2.6.11-rc3-bk5/include/linux/mm.h	2005-02-08 15:30:52.808668074 +0100
@@ -756,7 +756,9 @@ extern unsigned long page_unuse(struct p
 extern void truncate_inode_pages(struct address_space *, loff_t);
 
 /* generic vm_area_ops exported for stackable file systems */
-struct page *filemap_nopage(struct vm_area_struct *, unsigned long, int *);
+extern struct page *filemap_nopage(struct vm_area_struct *, unsigned long, int *);
+extern int filemap_populate(struct vm_area_struct *, unsigned long,
+		unsigned long, pgprot_t, unsigned long, int);
 
 /* mm/page-writeback.c */
 int write_one_page(struct page *page, int wait);
diff -purN linux-2.6.11-rc3-bk4/include/linux/netfilter_ipv4/ip_conntrack_tcp.h linux-2.6.11-rc3-bk5/include/linux/netfilter_ipv4/ip_conntrack_tcp.h
--- linux-2.6.11-rc3-bk4/include/linux/netfilter_ipv4/ip_conntrack_tcp.h	2005-02-03 02:55:36.000000000 +0100
+++ linux-2.6.11-rc3-bk5/include/linux/netfilter_ipv4/ip_conntrack_tcp.h	2005-02-08 15:30:52.809667919 +0100
@@ -41,6 +41,7 @@ struct ip_ct_tcp
 	u_int8_t	retrans;	/* Number of retransmitted packets */
 	u_int8_t	last_index;	/* Index of the last packet */
 	u_int32_t	last_seq;	/* Last sequence number seen in dir */
+	u_int32_t	last_ack;	/* Last sequence number seen in opposite dir */
 	u_int32_t	last_end;	/* Last seq + len */
 };
 
diff -purN linux-2.6.11-rc3-bk4/include/linux/netfilter_ipv4/ip_conntrack_tuple.h linux-2.6.11-rc3-bk5/include/linux/netfilter_ipv4/ip_conntrack_tuple.h
--- linux-2.6.11-rc3-bk4/include/linux/netfilter_ipv4/ip_conntrack_tuple.h	2005-02-03 02:56:22.000000000 +0100
+++ linux-2.6.11-rc3-bk5/include/linux/netfilter_ipv4/ip_conntrack_tuple.h	2005-02-08 15:30:52.810667763 +0100
@@ -64,10 +64,10 @@ struct ip_conntrack_tuple
 		} u;
 
 		/* The protocol. */
-		u8 protonum;
+		u_int8_t protonum;
 
 		/* The direction (for tuplehash) */
-		u8 dir;
+		u_int8_t dir;
 	} dst;
 };
 
diff -purN linux-2.6.11-rc3-bk4/include/linux/netlink.h linux-2.6.11-rc3-bk5/include/linux/netlink.h
--- linux-2.6.11-rc3-bk4/include/linux/netlink.h	2005-02-03 02:56:36.000000000 +0100
+++ linux-2.6.11-rc3-bk5/include/linux/netlink.h	2005-02-08 15:30:52.811667607 +0100
@@ -133,10 +133,9 @@ int netlink_sendskb(struct sock *sk, str
 
 /*
  *	skb should fit one page. This choice is good for headerless malloc.
- *
- *      FIXME: What is the best size for SLAB???? --ANK
  */
-#define NLMSG_GOODSIZE (PAGE_SIZE - ((sizeof(struct sk_buff)+0xF)&~0xF))
+#define NLMSG_GOODORDER 0
+#define NLMSG_GOODSIZE (SKB_MAX_ORDER(0, NLMSG_GOODORDER))
 
 
 struct netlink_callback
diff -purN linux-2.6.11-rc3-bk4/include/net/bluetooth/hci_core.h linux-2.6.11-rc3-bk5/include/net/bluetooth/hci_core.h
--- linux-2.6.11-rc3-bk4/include/net/bluetooth/hci_core.h	2005-02-03 02:55:53.000000000 +0100
+++ linux-2.6.11-rc3-bk5/include/net/bluetooth/hci_core.h	2005-02-08 15:30:52.818666518 +0100
@@ -119,6 +119,8 @@ struct hci_dev {
 
 	struct hci_dev_stats	stat;
 
+	struct sk_buff_head	driver_init;
+
 	void			*driver_data;
 	void			*core_data;
 
diff -purN linux-2.6.11-rc3-bk4/kernel/sched.c linux-2.6.11-rc3-bk5/kernel/sched.c
--- linux-2.6.11-rc3-bk4/kernel/sched.c	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk5/kernel/sched.c	2005-02-08 15:30:52.830664650 +0100
@@ -867,7 +867,7 @@ void wait_task_inactive(task_t * p)
 repeat:
 	rq = task_rq_lock(p, &flags);
 	/* Must be off runqueue entirely, not preempted. */
-	if (unlikely(p->array)) {
+	if (unlikely(p->array || task_running(rq, p))) {
 		/* If it's preempted, we yield.  It could be a while. */
 		preempted = !task_running(rq, p);
 		task_rq_unlock(rq, &flags);
@@ -885,6 +885,12 @@ repeat:
  *
  * Cause a process which is running on another CPU to enter
  * kernel-mode, without any delay. (to get signals handled.)
+ *
+ * NOTE: this function doesnt have to take the runqueue lock,
+ * because all it wants to ensure is that the remote task enters
+ * the kernel. If the IPI races and the task has been migrated
+ * to another CPU then no harm is done and the purpose has been
+ * achieved as well.
  */
 void kick_process(task_t *p)
 {
diff -purN linux-2.6.11-rc3-bk4/mm/filemap.c linux-2.6.11-rc3-bk5/mm/filemap.c
--- linux-2.6.11-rc3-bk4/mm/filemap.c	2005-02-03 02:57:16.000000000 +0100
+++ linux-2.6.11-rc3-bk5/mm/filemap.c	2005-02-08 15:30:52.835663872 +0100
@@ -1458,12 +1458,9 @@ err:
 	return NULL;
 }
 
-static int filemap_populate(struct vm_area_struct *vma,
-			unsigned long addr,
-			unsigned long len,
-			pgprot_t prot,
-			unsigned long pgoff,
-			int nonblock)
+int filemap_populate(struct vm_area_struct *vma, unsigned long addr,
+		unsigned long len, pgprot_t prot, unsigned long pgoff,
+		int nonblock)
 {
 	struct file *file = vma->vm_file;
 	struct address_space *mapping = file->f_mapping;
@@ -1523,6 +1520,7 @@ int generic_file_mmap(struct file * file
 	vma->vm_ops = &generic_file_vm_ops;
 	return 0;
 }
+EXPORT_SYMBOL(filemap_populate);
 
 /*
  * This is for filesystems which do not implement ->writepage.
diff -purN linux-2.6.11-rc3-bk4/net/bluetooth/hci_core.c linux-2.6.11-rc3-bk5/net/bluetooth/hci_core.c
--- linux-2.6.11-rc3-bk4/net/bluetooth/hci_core.c	2005-02-03 02:55:23.000000000 +0100
+++ linux-2.6.11-rc3-bk5/net/bluetooth/hci_core.c	2005-02-08 15:30:52.854660914 +0100
@@ -183,10 +183,22 @@ static void hci_reset_req(struct hci_dev
 
 static void hci_init_req(struct hci_dev *hdev, unsigned long opt)
 {
+	struct sk_buff *skb;
 	__u16 param;
 
 	BT_DBG("%s %ld", hdev->name, opt);
 
+	/* Driver initialization */
+
+	/* Special commands */
+	while ((skb = skb_dequeue(&hdev->driver_init))) {
+		skb->pkt_type = HCI_COMMAND_PKT;
+		skb->dev = (void *) hdev;
+		skb_queue_tail(&hdev->cmd_q, skb);
+		hci_sched_cmd(hdev);
+	}
+	skb_queue_purge(&hdev->driver_init);
+
 	/* Mandatory initialization */
 
 	/* Reset */
@@ -792,6 +804,8 @@ struct hci_dev *hci_alloc_dev(void)
 
 	memset(hdev, 0, sizeof(struct hci_dev));
 
+	skb_queue_head_init(&hdev->driver_init);
+
 	return hdev;
 }
 EXPORT_SYMBOL(hci_alloc_dev);
@@ -799,6 +813,8 @@ EXPORT_SYMBOL(hci_alloc_dev);
 /* Free HCI device */
 void hci_free_dev(struct hci_dev *hdev)
 {
+	skb_queue_purge(&hdev->driver_init);
+
 	/* will free via class release */
 	class_device_put(&hdev->class_dev);
 }
diff -purN linux-2.6.11-rc3-bk4/net/ipv4/ipconfig.c linux-2.6.11-rc3-bk5/net/ipv4/ipconfig.c
--- linux-2.6.11-rc3-bk4/net/ipv4/ipconfig.c	2005-02-03 02:55:01.000000000 +0100
+++ linux-2.6.11-rc3-bk5/net/ipv4/ipconfig.c	2005-02-08 15:30:52.857660447 +0100
@@ -1232,7 +1232,7 @@ u32 __init root_nfs_parse_addr(char *nam
 		if (*cp == ':')
 			*cp++ = '\0';
 		addr = in_aton(name);
-		strcpy(name, cp);
+		memmove(name, cp, strlen(cp) + 1);
 	} else
 		addr = INADDR_NONE;
 
diff -purN linux-2.6.11-rc3-bk4/net/ipv4/netfilter/ip_conntrack_ftp.c linux-2.6.11-rc3-bk5/net/ipv4/netfilter/ip_conntrack_ftp.c
--- linux-2.6.11-rc3-bk4/net/ipv4/netfilter/ip_conntrack_ftp.c	2005-02-03 02:57:17.000000000 +0100
+++ linux-2.6.11-rc3-bk5/net/ipv4/netfilter/ip_conntrack_ftp.c	2005-02-08 15:30:52.859660136 +0100
@@ -373,10 +373,9 @@ static int help(struct sk_buff **pskb,
 		goto out_update_nl;
 	}
 
-	DEBUGP("conntrack_ftp: match `%.*s' (%u bytes at %u)\n",
-	       (int)matchlen, data + matchoff,
-	       matchlen, ntohl(th->seq) + matchoff);
-
+	DEBUGP("conntrack_ftp: match `%s' (%u bytes at %u)\n",
+	       fb_ptr + matchoff, matchlen, ntohl(th->seq) + matchoff);
+			 
 	/* Allocate expectation which will be inserted */
 	exp = ip_conntrack_expect_alloc();
 	if (exp == NULL) {
diff -purN linux-2.6.11-rc3-bk4/net/ipv4/netfilter/ip_conntrack_proto_tcp.c linux-2.6.11-rc3-bk5/net/ipv4/netfilter/ip_conntrack_proto_tcp.c
--- linux-2.6.11-rc3-bk4/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2005-02-03 02:56:54.000000000 +0100
+++ linux-2.6.11-rc3-bk5/net/ipv4/netfilter/ip_conntrack_proto_tcp.c	2005-02-08 15:30:52.861659824 +0100
@@ -665,11 +665,13 @@ static int tcp_in_window(struct ip_ct_tc
 		if (*index == TCP_ACK_SET) {
 			if (state->last_dir == dir
 			    && state->last_seq == seq
+			    && state->last_ack == ack
 			    && state->last_end == end)
 				state->retrans++;
 			else {
 				state->last_dir = dir;
 				state->last_seq = seq;
+				state->last_ack = ack;
 				state->last_end = end;
 				state->retrans = 0;
 			}
diff -purN linux-2.6.11-rc3-bk4/net/ipv4/netfilter/ip_nat_core.c linux-2.6.11-rc3-bk5/net/ipv4/netfilter/ip_nat_core.c
--- linux-2.6.11-rc3-bk4/net/ipv4/netfilter/ip_nat_core.c	2005-02-03 02:55:14.000000000 +0100
+++ linux-2.6.11-rc3-bk5/net/ipv4/netfilter/ip_nat_core.c	2005-02-08 15:30:52.863659513 +0100
@@ -543,6 +543,7 @@ int __init ip_nat_init(void)
 static int clean_nat(struct ip_conntrack *i, void *data)
 {
 	memset(&i->nat, 0, sizeof(i->nat));
+	i->status &= ~(IPS_NAT_MASK | IPS_NAT_DONE_MASK | IPS_SEQ_ADJUST);
 	return 0;
 }
 
diff -purN linux-2.6.11-rc3-bk4/net/ipv4/netfilter/ipt_hashlimit.c linux-2.6.11-rc3-bk5/net/ipv4/netfilter/ipt_hashlimit.c
--- linux-2.6.11-rc3-bk4/net/ipv4/netfilter/ipt_hashlimit.c	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk5/net/ipv4/netfilter/ipt_hashlimit.c	2005-02-08 15:30:52.865659202 +0100
@@ -570,7 +570,7 @@ static void *dl_seq_start(struct seq_fil
 	if (*pos >= htable->cfg.size)
 		return NULL;
 
-	bucket = kmalloc(sizeof(unsigned int), GFP_KERNEL);
+	bucket = kmalloc(sizeof(unsigned int), GFP_ATOMIC);
 	if (!bucket)
 		return ERR_PTR(-ENOMEM);
 
diff -purN linux-2.6.11-rc3-bk4/net/ipv6/ip6_tunnel.c linux-2.6.11-rc3-bk5/net/ipv6/ip6_tunnel.c
--- linux-2.6.11-rc3-bk4/net/ipv6/ip6_tunnel.c	2005-02-03 02:55:07.000000000 +0100
+++ linux-2.6.11-rc3-bk5/net/ipv6/ip6_tunnel.c	2005-02-08 15:30:52.872658112 +0100
@@ -180,10 +180,10 @@ ip6ip6_tnl_link(struct ip6_tnl *t)
 {
 	struct ip6_tnl **tp = ip6ip6_bucket(&t->parms);
 
-	write_lock_bh(&ip6ip6_lock);
 	t->next = *tp;
-	write_unlock_bh(&ip6ip6_lock);
+	write_lock_bh(&ip6ip6_lock);
 	*tp = t;
+	write_unlock_bh(&ip6ip6_lock);
 }
 
 /**
diff -purN linux-2.6.11-rc3-bk4/net/sched/ipt.c linux-2.6.11-rc3-bk5/net/sched/ipt.c
--- linux-2.6.11-rc3-bk4/net/sched/ipt.c	2005-02-03 02:54:38.000000000 +0100
+++ linux-2.6.11-rc3-bk5/net/sched/ipt.c	2005-02-08 15:30:52.873657957 +0100
@@ -207,6 +207,11 @@ tcf_ipt(struct sk_buff **pskb, struct tc
 	struct tcf_ipt *p = PRIV(a, ipt);
 	struct sk_buff *skb = *pskb;
 
+	if (skb_cloned(skb)) {
+		if (pskb_expand_head(skb, 0, 0, GFP_ATOMIC))
+			return TC_ACT_UNSPEC;
+	}
+
 	spin_lock(&p->lock);
 
 	p->tm.lastuse = jiffies;
diff -purN linux-2.6.11-rc3-bk4/net/sched/sch_netem.c linux-2.6.11-rc3-bk5/net/sched/sch_netem.c
--- linux-2.6.11-rc3-bk4/net/sched/sch_netem.c	2005-02-03 02:56:53.000000000 +0100
+++ linux-2.6.11-rc3-bk5/net/sched/sch_netem.c	2005-02-08 15:30:52.876789845 +0100
@@ -177,6 +177,7 @@ static int netem_enqueue(struct sk_buff 
 	if (q->loss && q->loss >= get_crandom(&q->loss_cor)) {
 		pr_debug("netem_enqueue: random loss\n");
 		sch->qstats.drops++;
+		kfree_skb(skb);
 		return 0;	/* lie about loss so TCP doesn't know */
 	}
 
