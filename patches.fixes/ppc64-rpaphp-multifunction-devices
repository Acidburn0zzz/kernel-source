diff -uprN sles9-0525-vanilla/drivers/pci/hotplug/rpadlpar_core.c sles9-0525-new/drivers/pci/hotplug/rpadlpar_core.c
--- sles9-0525-vanilla/drivers/pci/hotplug/rpadlpar_core.c	2004-05-26 16:56:07.000000000 -0500
+++ sles9-0525-new/drivers/pci/hotplug/rpadlpar_core.c	2004-05-26 17:13:27.000000000 -0500
@@ -24,13 +24,6 @@
 
 static DECLARE_MUTEX(rpadlpar_sem);
 
-static inline int is_hotplug_capable(struct device_node *dn)
-{
-	unsigned char *ptr = get_property(dn, "ibm,fw-pci-hot-plug-ctrl", NULL);
-
-	return (int) (ptr != NULL);
-}
-
 static char *get_node_drc_name(struct device_node *dn)
 {
 	char *ptr = NULL;
@@ -52,7 +45,7 @@ static struct device_node *find_php_slot
 	if (!parent)
 		return NULL;
 
-	for (child = of_get_next_child(parent, NULL);
+	for (child = of_get_next_child(parent, NULL);	
 	     child; child = of_get_next_child(parent, child)) {
 		loc_code = get_property(child, "ibm,loc-code", NULL);
 		if (loc_code && !strcmp(loc_code, drc_name))
@@ -262,6 +255,7 @@ int dlpar_add_slot(char *drc_name)
 	}
 
 	/* Add hotplug slot for new VIOA or PCI */
+	
 	if (!rc && rpaphp_add_slot(dn)) {
 		printk(KERN_ERR "%s: unable to add hotplug slot %s\n",
 			__FUNCTION__, drc_name);
@@ -324,6 +318,7 @@ int dlpar_remove_pci_slot(struct slot *s
 	}
 
 	/* Remove pci bus */
+
 	if (dlpar_pci_remove_bus(bridge_dev)) {
 		printk(KERN_ERR "%s: unable to remove pci bus %s\n",
 			__FUNCTION__, drc_name);
@@ -352,7 +347,7 @@ int dlpar_remove_slot(char *drc_name)
 
 	if (down_interruptible(&rpadlpar_sem))
 		return -ERESTARTSYS;
-
+	
 	if (!find_php_slot_vio_node(drc_name) &&
 	    !find_php_slot_pci_node(drc_name)) {
 		rc = -ENODEV;
@@ -364,7 +359,7 @@ int dlpar_remove_slot(char *drc_name)
 		rc = -EINVAL;
 		goto exit;
 	}
-
+	
 	switch (slot->dev_type) {
 		case PCI_DEV:
 			rc = dlpar_remove_pci_slot(slot, drc_name);
diff -uprN sles9-0525-vanilla/drivers/pci/hotplug/rpaphp.h sles9-0525-new/drivers/pci/hotplug/rpaphp.h
--- sles9-0525-vanilla/drivers/pci/hotplug/rpaphp.h	2004-05-26 16:56:07.000000000 -0500
+++ sles9-0525-new/drivers/pci/hotplug/rpaphp.h	2004-05-26 17:13:27.000000000 -0500
@@ -30,6 +30,9 @@
 #include <linux/pci.h>
 #include "pci_hotplug.h"
 
+#define	HOTPLUG	1
+#define	EMBEDDED 0
+
 #define DR_INDICATOR 9002
 #define DR_ENTITY_SENSE 9003
 
@@ -62,8 +65,6 @@ extern int debug;
 #define info(format, arg...) printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
 #define warn(format, arg...) printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
 
-#define SLOT_MAGIC	0x67267322
-
 /* slot types */
 #define VIO_DEV	1
 #define PCI_DEV	2
@@ -75,25 +76,28 @@ extern int debug;
 #define	CONFIGURED	1
 #define	EMPTY		0
 
+struct rpaphp_pci_func {
+	struct pci_dev *pci_dev;
+	struct list_head sibling;
+};
+
 /*
  * struct slot - slot information for each *physical* slot
  */
 struct slot {
-	u32 magic;
 	int state;
 	u32 index;
 	u32 type;
 	u32 power_domain;
 	char *name;
 	char *location;
+	u8 removable;
 	struct device_node *dn;	/* slot's device_node in OFDT */
-	/* dn has phb info */
+				/* dn has phb info */
 	struct pci_dev *bridge;	/* slot's pci_dev in pci_devices */
 	union {
-		struct pci_dev *pci_dev;	/* pci_dev of device in this slot */
-		/* it will be used for unconfig */
-		/* NULL if slot is empty */
-		struct vio_dev *vio_dev;	/* vio_dev of the device in this slot */
+		struct list_head pci_funcs; /* pci_devs in PCI slot */ 
+		struct vio_dev *vio_dev; /* vio_dev in VIO slot */
 	} dev;
 	u8 dev_type;		/* VIO or PCI */
 	struct hotplug_slot *hotplug_slot;
@@ -104,6 +108,13 @@ extern struct hotplug_slot_ops rpaphp_ho
 extern struct list_head rpaphp_slot_head;
 extern int num_slots;
 
+static inline int is_hotplug_capable(struct device_node *dn)
+{
+	unsigned char *ptr = get_property(dn, "ibm,fw-pci-hot-plug-ctrl", NULL);
+
+	return (int) (ptr != NULL);
+}
+
 /* function prototypes */
 
 /* rpaphp_pci.c */
@@ -113,6 +124,7 @@ extern int rpaphp_enable_pci_slot(struct
 extern int register_pci_slot(struct slot *slot);
 extern int rpaphp_unconfig_pci_adapter(struct slot *slot);
 extern int rpaphp_get_pci_adapter_status(struct slot *slot, int is_init, u8 * value);
+extern struct hotplug_slot *rpaphp_find_hotplug_slot(struct pci_dev *dev);
 
 /* rpaphp_core.c */
 extern int rpaphp_add_slot(struct device_node *dn);
@@ -131,7 +143,6 @@ extern int register_slot(struct slot *sl
 extern int rpaphp_get_power_status(struct slot *slot, u8 * value);
 extern int rpaphp_set_attention_status(struct slot *slot, u8 status);
 extern void rpaphp_sysfs_remove_attr_location(struct hotplug_slot *slot);
+extern void rpaphp_sysfs_remove_attr_removable(struct hotplug_slot *slot);
 	
-extern struct hotplug_slot *rpaphp_find_hotplug_slot(struct pci_dev *dev);
-
 #endif				/* _PPC64PHP_H */
diff -uprN sles9-0525-vanilla/drivers/pci/hotplug/rpaphp_core.c sles9-0525-new/drivers/pci/hotplug/rpaphp_core.c
--- sles9-0525-vanilla/drivers/pci/hotplug/rpaphp_core.c	2004-05-26 16:56:07.000000000 -0500
+++ sles9-0525-new/drivers/pci/hotplug/rpaphp_core.c	2004-05-26 17:13:27.000000000 -0500
@@ -56,7 +56,7 @@ MODULE_LICENSE("GPL");
 
 void eeh_register_disable_func(int (*)(struct pci_dev *));
 
-module_param(debug, int, 0644);
+module_param(debug, bool, 0644);
 
 static int enable_slot(struct hotplug_slot *slot);
 static int disable_slot(struct hotplug_slot *slot);
@@ -65,7 +65,6 @@ static int get_power_status(struct hotpl
 static int get_attention_status(struct hotplug_slot *slot, u8 * value);
 static int get_adapter_status(struct hotplug_slot *slot, u8 * value);
 static int get_max_bus_speed(struct hotplug_slot *hotplug_slot, enum pci_bus_speed *value);
-static int get_cur_bus_speed(struct hotplug_slot *hotplug_slot, enum pci_bus_speed *value);
 static int rpaphp_disable_slot(struct pci_dev *dev);
 
 struct hotplug_slot_ops rpaphp_hotplug_slot_ops = {
@@ -77,18 +76,8 @@ struct hotplug_slot_ops rpaphp_hotplug_s
 	.get_attention_status = get_attention_status,
 	.get_adapter_status = get_adapter_status,
 	.get_max_bus_speed = get_max_bus_speed,
-	.get_cur_bus_speed = get_cur_bus_speed,
 };
 
-static inline struct slot *get_slot (struct hotplug_slot *hotplug_slot, const char *function)
-{
-	if (!hotplug_slot) {
-		dbg("%s - hotplug_slot == NULL\n", function);
-		return NULL;
-	}
-	return (struct slot *)hotplug_slot->private;
-}
-
 static int rpaphp_get_attention_status(struct slot *slot)
 {
 	return slot->hotplug_slot->info->attention_status;
@@ -104,10 +93,7 @@ static int rpaphp_get_attention_status(s
 static int set_attention_status(struct hotplug_slot *hotplug_slot, u8 value)
 {
 	int retval = 0;
-	struct slot *slot = get_slot(hotplug_slot, __FUNCTION__);
-
-	if (slot == NULL)
-		return -ENODEV;
+	struct slot *slot = (struct slot *)hotplug_slot->private;
 
 	down(&rpaphp_sem);
 	switch (value) {
@@ -139,10 +125,7 @@ static int set_attention_status(struct h
 static int get_power_status(struct hotplug_slot *hotplug_slot, u8 * value)
 {
 	int retval;
-	struct slot *slot = get_slot(hotplug_slot, __FUNCTION__);
-
-	if (slot == NULL)
-		return -ENODEV;
+	struct slot *slot = (struct slot *)hotplug_slot->private;
 
 	down(&rpaphp_sem);
 	retval = rpaphp_get_power_status(slot, value);
@@ -158,10 +141,7 @@ static int get_power_status(struct hotpl
 static int get_attention_status(struct hotplug_slot *hotplug_slot, u8 * value)
 {
 	int retval = 0;
-	struct slot *slot = get_slot(hotplug_slot, __FUNCTION__);
-
-	if (slot == NULL)
-		return -ENODEV;
+	struct slot *slot = (struct slot *)hotplug_slot->private;
 
 	down(&rpaphp_sem);
 	*value = rpaphp_get_attention_status(slot);
@@ -171,11 +151,9 @@ static int get_attention_status(struct h
 
 static int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 * value)
 {
-	struct slot *slot = get_slot(hotplug_slot, __FUNCTION__);
+	struct slot *slot = (struct slot *)hotplug_slot->private;
 	int retval = 0;
 
-	if (slot == NULL)
-		return -ENODEV;
 	down(&rpaphp_sem);
 	/*  have to go through this */
 	switch (slot->dev_type) {
@@ -194,10 +172,7 @@ static int get_adapter_status(struct hot
 
 static int get_max_bus_speed(struct hotplug_slot *hotplug_slot, enum pci_bus_speed *value)
 {
-	struct slot *slot = get_slot(hotplug_slot, __FUNCTION__);
-
-	if (slot == NULL)
-		return -ENODEV;
+	struct slot *slot = (struct slot *)hotplug_slot->private;
 
 	down(&rpaphp_sem);
 	switch (slot->type) {
@@ -234,18 +209,6 @@ static int get_max_bus_speed(struct hotp
 	return 0;
 }
 
-/* return dummy value because not sure if PRA provides any method... */
-static int get_cur_bus_speed(struct hotplug_slot *hotplug_slot, enum pci_bus_speed *value)
-{
-	struct slot *slot = get_slot(hotplug_slot, __FUNCTION__);
-
-	if (slot == NULL)
-		return -ENODEV;
-
-	*value = PCI_SPEED_UNKNOWN;
-	return 0;
-}
-
 int rpaphp_remove_slot(struct slot *slot)
 {
 	int retval = 0;
@@ -253,9 +216,12 @@ int rpaphp_remove_slot(struct slot *slot
 
 	list_del(&slot->rpaphp_slot_list);
 	
-	/* remove "php_location" file */
+	/* remove "phy_location" file */
 	rpaphp_sysfs_remove_attr_location(php_slot);
 
+	/* remove "phy_removable" file */
+	rpaphp_sysfs_remove_attr_removable(php_slot);
+
 	retval = pci_hp_deregister(php_slot);
 	if (retval)
 		err("Problem unregistering a slot %s\n", slot->name);
@@ -266,45 +232,69 @@ int rpaphp_remove_slot(struct slot *slot
 	return retval;
 }
 
-static int is_php_dn(struct device_node *dn, int **indexes, int **names, int **types,
-	  int **power_domains)
+static int get_dn_properties(struct device_node *dn, int **indexes, int **names, 
+	int **types, int **power_domains)
 {
 	*indexes = (int *) get_property(dn, "ibm,drc-indexes", NULL);
-	if (!*indexes)
-		return (0);
+
 	/* &names[1] contains NULL terminated slot names */
 	*names = (int *) get_property(dn, "ibm,drc-names", NULL);
-	if (!*names)
-		return (0);
+
 	/* &types[1] contains NULL terminated slot types */
 	*types = (int *) get_property(dn, "ibm,drc-types", NULL);
-	if (!*types)
-		return (0);
+
 	/* power_domains[1...n] are the slot power domains */
-	*power_domains = (int *) get_property(dn,
-					      "ibm,drc-power-domains", NULL);
-	if (!*power_domains)
+	*power_domains = (int *) get_property(dn, "ibm,drc-power-domains", NULL);
+	
+	if (*indexes && *names && *types && *power_domains) 
+		return (1);
+	
+	return (0);
+}
+
+static int is_php_dn(struct device_node *dn, int **indexes, int **names, int **types,
+	  int **power_domains)
+{
+	if (!is_hotplug_capable(dn))
 		return (0);
-	if (strcmp(dn->name, "pci") == 0 &&
-	    !get_property(dn, "ibm,fw-pci-hot-plug-ctrl", NULL))
+	if (!get_dn_properties(dn, indexes, names, types, power_domains))
 		return (0);
 	return (1);
 }
 
+static int is_dr_dn(struct device_node *dn, int **indexes, int **names, int **types,
+	  int **power_domains, int **my_drc_index)
+{
+	if (!is_hotplug_capable(dn))
+		return (0);
+
+	*my_drc_index = (int *) get_property(dn, "ibm,my-drc-index", NULL);
+	if(!*my_drc_index) 		
+		return (0);
+
+	if (!dn->parent)
+		return (0);
+
+	return get_dn_properties(dn->parent, indexes, names, types, power_domains);
+}
+
 static inline int is_vdevice_root(struct device_node *dn)
 {
 	return !strcmp(dn->name, "vdevice");
 }
 
-/*************************************
- * Add  Hot Plug slot(s) to sysfs
- *
- ************************************/
+/****************************************************************
+ *	rpaphp not only registers PCI hotplug slots(HOTPLUG), 
+ *	but also logical DR slots(EMBEDDED).
+ *	HOTPLUG slot: An adapter can be physically added/removed. 
+ *	EMBEDDED slot: An adapter can be logically removed/added
+ *		  from/to a partition with the slot.
+ ***************************************************************/
 int rpaphp_add_slot(struct device_node *dn)
 {
 	struct slot *slot;
 	int retval = 0;
-	int i;
+	int i, *my_drc_index, slot_type;
 	int *indexes, *names, *types, *power_domains;
 	char *name, *type;
 
@@ -317,27 +307,41 @@ int rpaphp_add_slot(struct device_node *
 	}
 
 	/* register PCI devices */
-	if (dn->name != 0 && strcmp(dn->name, "pci") == 0 &&
-	    is_php_dn(dn, &indexes, &names, &types, &power_domains)) {
+	if (dn->name != 0 && strcmp(dn->name, "pci") == 0) {
+		if (is_php_dn(dn, &indexes, &names, &types, &power_domains))  
+			slot_type = HOTPLUG;
+		else if (is_dr_dn(dn, &indexes, &names, &types, &power_domains, &my_drc_index)) 
+			slot_type = EMBEDDED;
+		else goto exit;
 
 		name = (char *) &names[1];
 		type = (char *) &types[1];
-		for (i = 0; i < indexes[0];
-		     i++,
-		     name += (strlen(name) + 1), type += (strlen(type) + 1)) {
-			if (!(slot = alloc_slot_struct(dn, indexes[i + 1], name,
-						       power_domains[i + 1]))) {
-				retval = -ENOMEM;
-				goto exit;
+		for (i = 0; i < indexes[0]; i++,
+	     		name += (strlen(name) + 1), type += (strlen(type) + 1)) {
+
+			if ( slot_type == HOTPLUG || 
+				(slot_type == EMBEDDED && indexes[i + 1] == my_drc_index[0])) {
+				
+				if (!(slot = alloc_slot_struct(dn, indexes[i + 1], name,
+					       power_domains[i + 1]))) {
+					retval = -ENOMEM;
+					goto exit;
+				}
+				if (slot_type == EMBEDDED)
+					slot->type = EMBEDDED;
+				else
+					slot->type = simple_strtoul(type, NULL, 10);
+				
+				dbg("    Found drc-index:0x%x drc-name:%s drc-type:%s\n",
+					indexes[i + 1], name, type);
+
+				retval = register_pci_slot(slot);
+				if (slot_type == EMBEDDED)
+					goto exit;
 			}
-			slot->type = simple_strtoul(type, NULL, 10);
-			if (slot->type < 1 || slot->type > 16)
-				slot->type = 0;
-			retval = register_pci_slot(slot);
-
-		}		/* for indexes */
-	}			/* end of PCI device_node */
-      exit:
+		}
+	}
+exit:
 	dbg("%s - Exit: num_slots=%d rc[%d]\n",
 	    __FUNCTION__, num_slots, retval);
 	return retval;
@@ -355,7 +359,7 @@ static void init_slots(void)
 		rpaphp_add_slot(dn);
 }
 
-static int init_rpa(void)
+static int __init init_rpa(void)
 {
 
 	init_MUTEX(&rpaphp_sem);
@@ -368,7 +372,7 @@ static int init_rpa(void)
 	return 0;
 }
 
-static void cleanup_slots(void)
+static void __exit cleanup_slots(void)
 {
 	struct list_head *tmp, *n;
 	struct slot *slot;
@@ -409,10 +413,7 @@ static void __exit rpaphp_exit(void)
 static int enable_slot(struct hotplug_slot *hotplug_slot)
 {
 	int retval = 0;
-	struct slot *slot = get_slot(hotplug_slot, __FUNCTION__);
-
-	if (slot == NULL)
-		return -ENODEV;
+	struct slot *slot = (struct slot *)hotplug_slot->private;
 
 	if (slot->state == CONFIGURED) {
 		dbg("%s: %s is already enabled\n", __FUNCTION__, slot->name);
@@ -432,7 +433,7 @@ static int enable_slot(struct hotplug_sl
 		retval = -EINVAL;
 	}
 	up(&rpaphp_sem);
-      exit:
+exit:
 	dbg("%s - Exit: rc[%d]\n", __FUNCTION__, retval);
 	return retval;
 }
@@ -445,10 +446,7 @@ static int rpaphp_disable_slot(struct pc
 static int disable_slot(struct hotplug_slot *hotplug_slot)
 {
 	int retval;
-	struct slot *slot = get_slot(hotplug_slot, __FUNCTION__);
-
-	if (slot == NULL)
-		return -ENODEV;
+	struct slot *slot = (struct slot *)hotplug_slot->private;
 
 	dbg("%s - Entry: slot[%s]\n", __FUNCTION__, slot->name);
 
@@ -461,9 +459,7 @@ static int disable_slot(struct hotplug_s
 	down(&rpaphp_sem);
 	switch (slot->dev_type) {
 	case PCI_DEV:
-		rpaphp_set_attention_status(slot, LED_ID);
 		retval = rpaphp_unconfig_pci_adapter(slot);
-		rpaphp_set_attention_status(slot, LED_OFF);
 		break;
 	case VIO_DEV:
 		retval = rpaphp_unconfig_vio_adapter(slot);
@@ -472,7 +468,7 @@ static int disable_slot(struct hotplug_s
 		retval = -ENODEV;
 	}
 	up(&rpaphp_sem);
-      exit:
+exit:
 	dbg("%s - Exit: rc[%d]\n", __FUNCTION__, retval);
 	return retval;
 }
diff -uprN sles9-0525-vanilla/drivers/pci/hotplug/rpaphp_pci.c sles9-0525-new/drivers/pci/hotplug/rpaphp_pci.c
--- sles9-0525-vanilla/drivers/pci/hotplug/rpaphp_pci.c	2004-05-26 16:56:07.000000000 -0500
+++ sles9-0525-new/drivers/pci/hotplug/rpaphp_pci.c	2004-05-26 17:13:27.000000000 -0500
@@ -32,22 +32,23 @@ struct pci_dev *rpaphp_find_pci_dev(stru
 {
 	struct pci_dev *retval_dev = NULL, *dev = NULL;
 	char bus_id[BUS_ID_SIZE];
+	int *vendor_id, *device_id, vid = PCI_ANY_ID, did = PCI_ANY_ID;
 
 	sprintf(bus_id, "%04x:%02x:%02x.%d",dn->phb->global_number,
 		dn->busno, PCI_SLOT(dn->devfn), PCI_FUNC(dn->devfn));
-
-	dbg("Enter rpaphp_find_pci_dev() full_name=%s bus_id=%s\n", 
-		dn->full_name, bus_id);
-	
-	while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
-               if (!strcmp(pci_name(dev), bus_id)) {
+	vendor_id = (int *) get_property(dn, "vendor-id", NULL);
+	device_id = (int *) get_property(dn, "device-id", NULL);
+	if (vendor_id) 
+		vid = *vendor_id;
+	if (device_id) 
+		did = *device_id;
+	while ((dev = pci_find_device(vid, did, dev)) != NULL) {
+		if (!strcmp(pci_name(dev), bus_id)) {
 			retval_dev = dev;
-			dbg("rpaphp_find_pci_dev(): found dev=%p\n\n", dev);
 			break;
 		}
 	}
 	return retval_dev;
-
 }
 
 EXPORT_SYMBOL_GPL(rpaphp_find_pci_dev);
@@ -57,9 +58,8 @@ int rpaphp_claim_resource(struct pci_dev
 	struct resource *res = &dev->resource[resource];
 	struct resource *root = pci_find_parent_resource(dev, res);
 	char *dtype = resource < PCI_BRIDGE_RESOURCES ? "device" : "bridge";
-	int err;
+	int err = -EINVAL;
 
-	err = -EINVAL;
 	if (root != NULL) {
 		err = request_resource(root, res);
 	}
@@ -80,11 +80,6 @@ static struct pci_dev *rpaphp_find_bridg
 	return rpaphp_find_pci_dev(slot->dn);
 }
 
-static struct pci_dev *rpaphp_find_adapter_pdev(struct slot *slot)
-{
-	return rpaphp_find_pci_dev(slot->dn->child);
-}
-
 static int rpaphp_get_sensor_state(struct slot *slot, int *state)
 {
 	int rc;
@@ -117,8 +112,8 @@ static int rpaphp_get_sensor_state(struc
 	return rc;
 }
 
-/*
- * get_pci_adapter_status - get  the status of a slot
+/**
+ * get_pci_adapter_status - get the status of a slot
  * 
  * 0-- slot is empty
  * 1-- adapter is configured
@@ -136,7 +131,7 @@ int rpaphp_get_pci_adapter_status(struct
 	if (state == PRESENT) {
 		if (!is_init)
 			/* at run-time slot->state can be changed by */
-			/* config/unconfig adapter                        */
+			/* config/unconfig adapter */
 			*value = slot->state;
 		else {
 			if (!slot->dn->child)
@@ -145,7 +140,8 @@ int rpaphp_get_pci_adapter_status(struct
 			else if (rpaphp_find_pci_dev(slot->dn->child))
 				*value = CONFIGURED;
 			else {
-				dbg("%s: can't find pdev of adapter in slot[%s]\n", __FUNCTION__, slot->name);
+				err("%s: can't find pdev of adapter in slot[%s]\n", 
+					__FUNCTION__, slot->dn->full_name);
 				*value = NOT_CONFIGURED;
 			}
 		}
@@ -154,12 +150,13 @@ int rpaphp_get_pci_adapter_status(struct
 		*value = state;
 	}
 
-      exit:
+exit:
 	return rc;
 }
 
 /* Must be called before pci_bus_add_devices */
-static void rpaphp_fixup_new_pci_devices(struct pci_bus *bus)
+static void 
+rpaphp_fixup_new_pci_devices(struct pci_bus *bus, int fix_bus)
 {
 	struct pci_dev *dev;
 
@@ -170,8 +167,9 @@ static void rpaphp_fixup_new_pci_devices
 		 */
 		if (list_empty(&dev->global_list)) {
 			int i;
-
-			pcibios_fixup_device_resources(dev, bus);
+			
+			if(fix_bus)
+				pcibios_fixup_device_resources(dev, bus);
 			pci_read_irq_line(dev);
 			for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 				struct resource *r = &dev->resource[i];
@@ -184,68 +182,135 @@ static void rpaphp_fixup_new_pci_devices
 	}
 }
 
-static void rpaphp_pci_config_device(struct pci_bus *pci_bus, struct device_node *dn)
+static int rpaphp_pci_config_bridge(struct pci_dev *dev);
+
+/*****************************************************************************
+ rpaphp_pci_config_slot() will  configure all devices under the 
+ given slot->dn and return the the first pci_dev.
+ *****************************************************************************/
+static struct pci_dev *
+rpaphp_pci_config_slot(struct device_node *dn, struct pci_bus *bus)
 {
+	struct device_node *eads_first_child = dn->child;
+	struct pci_dev *dev;
 	int num;
+	
+	dbg("Enter %s: dn=%s bus=%s\n", __FUNCTION__, dn->full_name, bus->name);
 
-	num = pci_scan_slot(pci_bus, PCI_DEVFN(PCI_SLOT(dn->devfn), 0));
-	if (num) {
-		rpaphp_fixup_new_pci_devices(pci_bus);
-		pci_bus_add_devices(pci_bus);
+	if (eads_first_child) {
+		/* pci_scan_slot should find all children of EADs */
+		num = pci_scan_slot(bus, PCI_DEVFN(PCI_SLOT(eads_first_child->devfn), 0));
+		if (num) {
+			rpaphp_fixup_new_pci_devices(bus, 1); 
+			pci_bus_add_devices(bus);
+		}
+		dev = rpaphp_find_pci_dev(eads_first_child);
+		if (!dev) {
+			err("No new device found\n");
+			return NULL;
+		}
+		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) 
+			rpaphp_pci_config_bridge(dev);
 	}
-	return;
+	return dev;
 }
 
-static int rpaphp_pci_config_bridge(struct pci_dev *dev, struct device_node *dn);
-
-/*****************************************************************************
- rpaphp_pci_config_dn() will recursively configure all devices under the 
- given slot->dn and return the dn's pci_dev.
- *****************************************************************************/
-static struct pci_dev *rpaphp_pci_config_dn(struct device_node *dn, struct pci_bus *bus)
+static int rpaphp_pci_config_bridge(struct pci_dev *dev)
 {
-	struct device_node *local;
-	struct pci_dev *dev;
+	u8 sec_busno;
+	struct pci_bus *child_bus;
+	struct pci_dev *child_dev;
 
-	for (local = dn->child; local; local = local->sibling) {
-		rpaphp_pci_config_device(bus, local);
-		dev = rpaphp_find_pci_dev(local);
-		if (!rpaphp_pci_config_bridge(dev, local))
-			return NULL;
+	dbg("Enter %s:  BRIDGE dev=%s\n", __FUNCTION__, pci_name(dev));
+
+	/* get busno of downstream bus */
+	pci_read_config_byte(dev, PCI_SECONDARY_BUS, &sec_busno);
+		
+	/* add to children of PCI bridge dev->bus */
+	child_bus = pci_add_new_bus(dev->bus, dev, sec_busno);
+	if (!child_bus) {
+		err("%s: could not add second bus\n", __FUNCTION__);
+		return -EIO;
 	}
+	sprintf(child_bus->name, "PCI Bus #%02x", child_bus->number);
+	/* do pci_scan_child_bus */
+	pci_scan_child_bus(child_bus);
 
-	return dev;
+	list_for_each_entry(child_dev, &child_bus->devices, bus_list) {
+		eeh_add_device_late(child_dev);
+	}
+
+	 /* fixup new pci devices without touching bus struct */
+	rpaphp_fixup_new_pci_devices(child_bus, 0);
+
+	/* Make the discovered devices available */
+	pci_bus_add_devices(child_bus);
+	return 0;
 }
 
-static int rpaphp_pci_config_bridge(struct pci_dev *dev, struct device_node *dn)
+static void enable_eeh(struct device_node *dn)
 {
-	if (dev && dn->child) {	/* dn is a PCI bridge node */
-		struct pci_bus *child;
-		u8 sec_busno;
+	struct device_node *sib;
 
-		/* get busno of downstream bus */
-		pci_read_config_byte(dev, PCI_SECONDARY_BUS, &sec_busno);
+	for (sib = dn->child; sib; sib = sib->sibling) 
+		enable_eeh(sib);
+	eeh_add_device_early(dn);
+	return;
+	
+}
 
-		/* add to children of PCI bridge dev->bus */
-		child = pci_add_new_bus(dev->bus, dev, sec_busno);
-		if (!child) {
-			err("%s: could not add second bus\n", __FUNCTION__);
-			return 0;
+#ifdef DEBUG
+static void print_slot_pci_funcs(struct slot *slot)
+{
+	struct list_head *l;
+
+	if (slot->dev_type == PCI_DEV) {
+		printk("pci_funcs of slot[%s]\n", slot->name);
+		if (list_empty(&slot->dev.pci_funcs))
+			printk("	pci_funcs is EMPTY\n");
+
+		list_for_each (l, &slot->dev.pci_funcs) {
+			struct rpaphp_pci_func *func =
+				list_entry(l, struct rpaphp_pci_func, sibling);
+			printk("	FOUND dev=%s\n", pci_name(func->pci_dev));
 		}
-		sprintf(child->name, "PCI Bus #%02x", child->number);
-		/* Fixup subordinate bridge bases and resureces */
-		pcibios_fixup_bus(child);
+	}
+}
+#endif
 
-		/* may need do more stuff here */
-		rpaphp_pci_config_dn(dn, dev->subordinate);
+static int init_slot_pci_funcs(struct slot *slot)
+{
+	struct device_node *child;
+
+	for (child = slot->dn->child; child != NULL; child = child->sibling) {
+		struct pci_dev *pdev = rpaphp_find_pci_dev(child);
+
+		if (pdev) {
+			struct rpaphp_pci_func *func;
+			func = kmalloc(sizeof(struct rpaphp_pci_func), GFP_KERNEL);
+			if (!func) 
+				return -ENOMEM;
+			memset(func, 0, sizeof(struct rpaphp_pci_func));
+			INIT_LIST_HEAD(&func->sibling);
+			func->pci_dev = pdev;
+			list_add_tail(&func->sibling, &slot->dev.pci_funcs);
+#ifdef DEBUG
+			print_slot_pci_funcs(slot);
+#endif
+		} else {
+			err("%s: dn=%s has no pci_dev\n", 
+				__FUNCTION__, child->full_name);
+			return -EIO;
+		}
 	}
-	return 1;
+	return 0;
 }
 
-static struct pci_dev *rpaphp_config_pci_adapter(struct slot *slot)
+static int rpaphp_config_pci_adapter(struct slot *slot)
 {
 	struct pci_bus *pci_bus;
-	struct pci_dev *dev = NULL;
+	struct pci_dev *dev;
+	int rc = -ENODEV;
 
 	dbg("Entry %s: slot[%s]\n", __FUNCTION__, slot->name);
 
@@ -256,39 +321,76 @@ static struct pci_dev *rpaphp_config_pci
 			err("%s: can't find bus structure\n", __FUNCTION__);
 			goto exit;
 		}
-
-		eeh_add_device_early(slot->dn->child);
-		dev = rpaphp_pci_config_dn(slot->dn, pci_bus);
-		eeh_add_device_late(dev);
+		enable_eeh(slot->dn);
+		dev = rpaphp_pci_config_slot(slot->dn, pci_bus);
+		if (!dev) {
+			err("%s: can't find any devices.\n", __FUNCTION__);
+			goto exit;
+		}
+		/* associate corresponding pci_dev */	
+		rc = init_slot_pci_funcs(slot);
+		if (rc)
+			goto exit;
+#ifdef DEBUG
+		print_slot_pci_funcs(slot);
+#endif
+		if (!list_empty(&slot->dev.pci_funcs)) 
+			rc = 0;
 	} else {
 		/* slot is not enabled */
 		err("slot doesn't have pci_dev structure\n");
-		dev = NULL;
-		goto exit;
 	}
+exit:
+	dbg("Exit %s:  rc=%d\n", __FUNCTION__, rc);
+	return rc;
+}
 
-      exit:
-	dbg("Exit %s: pci_dev %s\n", __FUNCTION__, dev ? "found" : "not found");
-	return dev;
+
+static void rpaphp_eeh_remove_bus_device(struct pci_dev *dev)
+{
+	eeh_remove_device(dev);
+	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
+		struct pci_bus *bus = dev->subordinate;
+		struct list_head *ln;
+		if (!bus)
+			return; 
+		for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
+			struct pci_dev *pdev = pci_dev_b(ln);
+			if (pdev)
+				rpaphp_eeh_remove_bus_device(pdev);
+		}
+
+	}
+	return;
 }
 
 int rpaphp_unconfig_pci_adapter(struct slot *slot)
 {
 	int retval = 0;
+	struct list_head *ln;
 
 	dbg("Entry %s: slot[%s]\n", __FUNCTION__, slot->name);
-	if (!slot->dev.pci_dev) {
-		info("%s: no card in slot[%s]\n", __FUNCTION__, slot->name);
+	if (list_empty(&slot->dev.pci_funcs)) {
+		err("%s: slot[%s] doesn't have any devices.\n", __FUNCTION__, 
+			slot->name);
 
 		retval = -EINVAL;
 		goto exit;
 	}
-	/* remove the device from the pci core */
-	eeh_remove_device(slot->dev.pci_dev);
-	pci_remove_bus_device(slot->dev.pci_dev);
-
+	/* remove the devices from the pci core */
+	list_for_each (ln, &slot->dev.pci_funcs) {
+		struct rpaphp_pci_func *func;
+	
+		func = list_entry(ln, struct rpaphp_pci_func, sibling);
+		if (func->pci_dev) {
+			rpaphp_eeh_remove_bus_device(func->pci_dev);
+			pci_remove_bus_device(func->pci_dev); 
+		}
+		kfree(func);
+	}
+	INIT_LIST_HEAD(&slot->dev.pci_funcs);
 	slot->state = NOT_CONFIGURED;
-	info("%s: adapter in slot[%s] unconfigured.\n", __FUNCTION__,
+	info("%s: devices in slot[%s] unconfigured.\n", __FUNCTION__,
 	     slot->name);
 exit:
 	dbg("Exit %s, rc=0x%x\n", __FUNCTION__, retval);
@@ -306,40 +408,48 @@ static int setup_pci_hotplug_slot_info(s
 	if (slot->hotplug_slot->info->adapter_status == NOT_VALID) {
 		dbg("%s: NOT_VALID: skip dn->full_name=%s\n",
 		    __FUNCTION__, slot->dn->full_name);
-		return (-1);
+		return -1;
 	}
-	return (0);
+	return 0;
 }
 
 static int setup_pci_slot(struct slot *slot)
 {
 	slot->bridge = rpaphp_find_bridge_pdev(slot);
 	if (!slot->bridge) {	/* slot being added doesn't have pci_dev yet */
-		dbg("%s: no pci_dev for bridge dn %s\n", __FUNCTION__, slot->name);
+		err("%s: no pci_dev for bridge dn %s\n", __FUNCTION__, slot->name);
 		dealloc_slot_struct(slot);
 		return 1;
 	}
 
 	strcpy(slot->name, pci_name(slot->bridge));
+
 	/* find slot's pci_dev if it's not empty */
 	if (slot->hotplug_slot->info->adapter_status == EMPTY) {
 		slot->state = EMPTY;	/* slot is empty */
-		slot->dev.pci_dev = NULL;
 	} else {
 		/* slot is occupied */
 		if (!(slot->dn->child)) {
 			/* non-empty slot has to have child */
-			err("%s: slot[%s]'s device_node doesn't have child for adapter\n", __FUNCTION__, slot->name);
+			err("%s: slot[%s]'s device_node doesn't have child for adapter\n", 
+				__FUNCTION__, slot->name);
 			dealloc_slot_struct(slot);
 			return 1;
 		}
-		slot->dev.pci_dev = rpaphp_find_adapter_pdev(slot);
-		if (slot->dev.pci_dev) {
+		if (init_slot_pci_funcs(slot)) {
+			err("%s: init_slot_pci_funcs failed\n", __FUNCTION__);
+			dealloc_slot_struct(slot);
+			return 1;		
+		}
+#ifdef DEBUG
+		print_slot_pci_funcs(slot);
+#endif	
+		if (!list_empty(&slot->dev.pci_funcs)) {
 			slot->state = CONFIGURED;
-		
+	
 		} else {
 			/* DLPAR add as opposed to 
-			 * boot time */
+		 	 * boot time */
 			slot->state = NOT_CONFIGURED;
 		}
 	}
@@ -351,12 +461,17 @@ int register_pci_slot(struct slot *slot)
 	int rc = 1;
 
 	slot->dev_type = PCI_DEV;
+	if (slot->type == EMBEDDED)
+		slot->removable = EMBEDDED;
+	else
+		slot->removable = HOTPLUG;
+	INIT_LIST_HEAD(&slot->dev.pci_funcs);
 	if (setup_pci_hotplug_slot_info(slot))
 		goto exit_rc;
 	if (setup_pci_slot(slot))
 		goto exit_rc;
 	rc = register_slot(slot);
-      exit_rc:
+exit_rc:
 	if (rc)
 		dealloc_slot_struct(slot);
 	return rc;
@@ -372,12 +487,12 @@ int rpaphp_enable_pci_slot(struct slot *
 	dbg("%s: sensor state[%d]\n", __FUNCTION__, state);
 	/* if slot is not empty, enable the adapter */
 	if (state == PRESENT) {
-		dbg("%s : slot[%s] is occupid.\n", __FUNCTION__, slot->name);
-		if ((slot->dev.pci_dev =
-		     rpaphp_config_pci_adapter(slot)) != NULL) {
+		dbg("%s : slot[%s] is occupied.\n", __FUNCTION__, slot->name);
+		retval = rpaphp_config_pci_adapter(slot);
+		if (!retval) {
 			slot->state = CONFIGURED;
-			dbg("%s: PCI adapter %s in slot[%s] has been configured\n", 
-				__FUNCTION__, pci_name(slot->dev.pci_dev), slot->name);
+			dbg("%s: PCI devices in slot[%s] has been configured\n", 
+				__FUNCTION__, slot->name);
 		} else {
 			slot->state = NOT_CONFIGURED;
 			dbg("%s: no pci_dev struct for adapter in slot[%s]\n",
@@ -392,11 +507,7 @@ int rpaphp_enable_pci_slot(struct slot *
 		slot->state = NOT_VALID;
 		retval = -EINVAL;
 	}
-      exit:
-	if (slot->state != NOT_VALID)
-		rpaphp_set_attention_status(slot, LED_ON);
-	else
-		rpaphp_set_attention_status(slot, LED_ID);
+exit:
 	dbg("%s - Exit: rc[%d]\n", __FUNCTION__, retval);
 	return retval;
 }
@@ -407,9 +518,18 @@ struct hotplug_slot *rpaphp_find_hotplug
 	struct slot		*slot;
 
 	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
+		struct pci_bus *bus;
+		struct list_head *ln;
+
 		slot = list_entry(tmp, struct slot, rpaphp_slot_list);
-		if (slot->dev.pci_dev == dev)
-			return slot->hotplug_slot;
+		bus = slot->bridge->subordinate;
+		if (!bus)
+			return NULL; /* shouldn't be here */
+		for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
+                                struct pci_dev *pdev = pci_dev_b(ln);
+				if (pdev == dev)
+					return slot->hotplug_slot;
+		}
 	}
 
 	return NULL;
diff -uprN sles9-0525-vanilla/drivers/pci/hotplug/rpaphp_slot.c sles9-0525-new/drivers/pci/hotplug/rpaphp_slot.c
--- sles9-0525-vanilla/drivers/pci/hotplug/rpaphp_slot.c	2004-05-26 16:56:07.000000000 -0500
+++ sles9-0525-new/drivers/pci/hotplug/rpaphp_slot.c	2004-05-26 17:13:27.000000000 -0500
@@ -29,6 +29,35 @@
 #include <linux/pci.h>
 #include "rpaphp.h"
 
+static ssize_t removable_read_file (struct hotplug_slot *php_slot, char *buf)
+{
+        u8 value;
+        int retval = -ENOENT;
+	struct slot *slot = (struct slot *)php_slot->private;
+
+	if (!slot)
+		return retval;
+
+        value = slot->removable;
+        retval = sprintf (buf, "%d\n", value);
+        return retval;
+}
+
+static struct hotplug_slot_attribute hotplug_slot_attr_removable = {
+	.attr = {.name = "phy_removable", .mode = S_IFREG | S_IRUGO},
+	.show = removable_read_file,
+};
+
+static void rpaphp_sysfs_add_attr_removable (struct hotplug_slot *slot)
+{
+	sysfs_create_file(&slot->kobj, &hotplug_slot_attr_removable.attr);
+}
+
+void rpaphp_sysfs_remove_attr_removable (struct hotplug_slot *slot)
+{
+	sysfs_remove_file(&slot->kobj, &hotplug_slot_attr_removable.attr);
+}
+
 static ssize_t location_read_file (struct hotplug_slot *php_slot, char *buf)
 {
         char *value;
@@ -58,19 +87,26 @@ void rpaphp_sysfs_remove_attr_location (
 	sysfs_remove_file(&slot->kobj, &hotplug_slot_attr_location.attr);
 }
 
-/* free up the memory user by a slot */
+/* free up the memory used by a slot */
 static void rpaphp_release_slot(struct hotplug_slot *hotplug_slot)
 {
-	struct slot *slot = hotplug_slot? (struct slot *) hotplug_slot->private:NULL;
-
-	if (slot == NULL)
-		return;
+	struct slot *slot = (struct slot *) hotplug_slot->private;
 
 	dealloc_slot_struct(slot);
 }
 
 void dealloc_slot_struct(struct slot *slot)
 {
+	struct list_head *ln, *n;
+	
+	if (slot->dev_type == PCI_DEV) {
+		list_for_each_safe (ln, n, &slot->dev.pci_funcs) {
+			struct rpaphp_pci_func *func;
+		
+			func = list_entry(ln, struct rpaphp_pci_func, sibling);
+			kfree(func);
+		}
+	}
 	kfree(slot->hotplug_slot->info);
 	kfree(slot->hotplug_slot->name);
 	kfree(slot->hotplug_slot);
@@ -85,91 +121,116 @@ struct slot *alloc_slot_struct(struct de
 	
 	slot = kmalloc(sizeof (struct slot), GFP_KERNEL);
 	if (!slot)
-		return (NULL);
+		goto error_nomem;
 	memset(slot, 0, sizeof (struct slot));
 	slot->hotplug_slot = kmalloc(sizeof (struct hotplug_slot), GFP_KERNEL);
-	if (!slot->hotplug_slot) {
-		kfree(slot);
-		return (NULL);
-	}
+	if (!slot->hotplug_slot)
+		goto error_slot;	
 	memset(slot->hotplug_slot, 0, sizeof (struct hotplug_slot));
 	slot->hotplug_slot->info = kmalloc(sizeof (struct hotplug_slot_info),
 					   GFP_KERNEL);
-	if (!slot->hotplug_slot->info) {
-		kfree(slot->hotplug_slot);
-		kfree(slot);
-		return (NULL);
-	}
+	if (!slot->hotplug_slot->info)
+		goto error_hpslot;
 	memset(slot->hotplug_slot->info, 0, sizeof (struct hotplug_slot_info));
 	slot->hotplug_slot->name = kmalloc(BUS_ID_SIZE + 1, GFP_KERNEL);
-	if (!slot->hotplug_slot->name) {
-		kfree(slot->hotplug_slot->info);
-		kfree(slot->hotplug_slot);
-		kfree(slot);
-		return (NULL);
-	}
+	if (!slot->hotplug_slot->name)
+		goto error_info;	
 	slot->location = kmalloc(strlen(drc_name) + 1, GFP_KERNEL);
-	if (!slot->location) {
-		kfree(slot->hotplug_slot->info);
-		kfree(slot->hotplug_slot->name);
-		kfree(slot->hotplug_slot);
-		kfree(slot);
-		return (NULL);
-	}
+	if (!slot->location)
+		goto error_name;
 	slot->name = slot->hotplug_slot->name;
 	slot->dn = dn;
 	slot->index = drc_index;
 	strcpy(slot->location, drc_name);
 	slot->power_domain = power_domain;
-	slot->magic = SLOT_MAGIC;
 	slot->hotplug_slot->private = slot;
 	slot->hotplug_slot->ops = &rpaphp_hotplug_slot_ops;
 	slot->hotplug_slot->release = &rpaphp_release_slot;
 	
 	return (slot);
+
+error_name:
+	kfree(slot->hotplug_slot->name);
+error_info:
+	kfree(slot->hotplug_slot->info);
+error_hpslot:
+	kfree(slot->hotplug_slot);
+error_slot:
+	kfree(slot);
+error_nomem:
+	return NULL;
+}
+
+static int is_registered(struct slot *slot)
+{
+	struct list_head        *tmp, *n;
+	struct slot             *tmp_slot;
+
+	list_for_each_safe(tmp, n, &rpaphp_slot_head) {
+		tmp_slot = list_entry(tmp, struct slot, rpaphp_slot_list);
+		if (!strcmp(tmp_slot->name, slot->name))
+			return 1;
+	}	
+	return 0;
 }
 
 int register_slot(struct slot *slot)
 {
 	int retval;
-	char *vio_uni_addr = NULL;
-
-	dbg("%s registering slot:path[%s] index[%x], name[%s] pdomain[%x] type[%d]\n", __FUNCTION__, slot->dn->full_name, slot->index, slot->name, slot->power_domain, slot->type);
 
+	dbg("%s registering slot:path[%s] index[%x], name[%s] pdomain[%x] type[%d]\n", 
+		__FUNCTION__, slot->dn->full_name, slot->index, slot->name, 
+		slot->power_domain, slot->type);
+	/* should not try to register the same slot twice */
+	if (is_registered(slot)) { /* should't be here */
+		err("register_slot: slot[%s] is already registered\n", slot->name);
+		rpaphp_release_slot(slot->hotplug_slot);
+		return (1);
+	}	
 	retval = pci_hp_register(slot->hotplug_slot);
 	if (retval) {
 		err("pci_hp_register failed with error %d\n", retval);
 		rpaphp_release_slot(slot->hotplug_slot);
-		return (retval);
+		return retval;
 	}
 	
 	/* create "phy_locatoin" file */
 	rpaphp_sysfs_add_attr_location(slot->hotplug_slot);	
 
+	/* create "phy_removable" file */
+	rpaphp_sysfs_add_attr_removable(slot->hotplug_slot);	
+
 	/* add slot to our internal list */
 	dbg("%s adding slot[%s] to rpaphp_slot_list\n",
 	    __FUNCTION__, slot->name);
 
 	list_add(&slot->rpaphp_slot_list, &rpaphp_slot_head);
 
-	if (vio_uni_addr)
-		info("Slot [%s](vio_uni_addr=%s) registered\n",
-		     slot->name, vio_uni_addr);
+	if (slot->dev_type == VIO_DEV)
+		info("Slot [%s](VIO location=%s) registered\n",
+		     slot->name, slot->location);
 	else
-		info("Slot [%s](bus_id=%s) registered\n",
-		     slot->name, pci_name(slot->bridge));
+		info("Slot [%s](PCI location=%s) registered\n",
+		     slot->name, slot->location);
 	num_slots++;
-	return (0);
+	return 0;
 }
 
 int rpaphp_get_power_status(struct slot *slot, u8 * value)
 {
-	int rc;
-
-	rc = rtas_get_power_level(slot->power_domain, (int *) value);
-	if (rc)
-		err("failed to get power-level for slot(%s), rc=0x%x\n",
-		    slot->name, rc);
+	int rc = 0;
+	
+	if (slot->type == EMBEDDED) {
+		printk("%s set to POWER_ON for EMBEDDED slot %s\n",
+			__FUNCTION__, slot->location);
+		*value = POWER_ON;
+	}
+	else {
+		rc = rtas_get_power_level(slot->power_domain, (int *) value);
+		if (rc)
+			err("failed to get power-level for slot(%s), rc=0x%x\n",
+		    		slot->name, rc);
+	}
 
 	return rc;
 }
@@ -181,8 +242,8 @@ int rpaphp_set_attention_status(struct s
 	/* status: LED_OFF or LED_ON */
 	rc = rtas_set_indicator(DR_INDICATOR, slot->index, status);
 	if (rc)
-		err("slot(%s) set attention-status(%d) failed! rc=0x%x\n",
-		    slot->name, status, rc);
+		err("slot(name=%s location=%s index=0x%x) set attention-status(%d) failed! rc=0x%x\n",
+		    slot->name, slot->location, slot->index, status, rc);
 
 	return rc;
 }
diff -uprN sles9-0525-vanilla/drivers/pci/probe.c sles9-0525-new/drivers/pci/probe.c
--- sles9-0525-vanilla/drivers/pci/probe.c	2004-05-26 16:56:07.000000000 -0500
+++ sles9-0525-new/drivers/pci/probe.c	2004-05-26 17:14:21.000000000 -0500
@@ -324,7 +324,7 @@ struct pci_bus * __devinit pci_add_new_b
 	return child;
 }
 
-static unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus);
+unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus);
 
 /*
  * If it's a bridge, configure it and scan the bus behind it.
@@ -652,7 +652,7 @@ int __devinit pci_scan_slot(struct pci_b
 	return nr;
 }
 
-static unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
+unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 {
 	unsigned int devfn, pass, max = bus->secondary;
 	struct pci_dev *dev;
@@ -759,4 +759,5 @@ EXPORT_SYMBOL(pci_do_scan_bus);
 EXPORT_SYMBOL(pci_scan_slot);
 EXPORT_SYMBOL(pci_scan_bridge);
 EXPORT_SYMBOL(pci_scan_single_device);
+EXPORT_SYMBOL_GPL(pci_scan_child_bus);
 #endif
diff -uprN sles9-0525-vanilla/include/linux/pci.h sles9-0525-new/include/linux/pci.h
--- sles9-0525-vanilla/include/linux/pci.h	2004-05-26 16:56:28.000000000 -0500
+++ sles9-0525-new/include/linux/pci.h	2004-05-26 17:15:00.000000000 -0500
@@ -581,6 +581,7 @@ static inline struct pci_bus *pci_scan_b
 }
 int pci_scan_slot(struct pci_bus *bus, int devfn);
 struct pci_dev * pci_scan_single_device(struct pci_bus *bus, int devfn);
+unsigned int pci_scan_child_bus(struct pci_bus *bus);
 void pci_bus_add_devices(struct pci_bus *bus);
 void pci_name_device(struct pci_dev *dev);
 char *pci_class_name(u32 class);
